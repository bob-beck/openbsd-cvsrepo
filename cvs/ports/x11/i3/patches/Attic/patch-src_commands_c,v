head	1.20;
access;
symbols
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.2
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.9.0.2
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.1.0.2
	OPENBSD_5_2_BASE:1.1;
locks; strict;
comment	@# @;


1.20
date	2017.09.25.06.30.43;	author dcoppa;	state dead;
branches;
next	1.19;
commitid	XdoD9A6U49Y0B3KZ;

1.19
date	2017.09.13.12.50.33;	author dcoppa;	state Exp;
branches;
next	1.18;
commitid	ygjP2ceTncTZ5BPk;

1.18
date	2016.03.09.09.25.51;	author dcoppa;	state dead;
branches;
next	1.17;
commitid	5e0lb25PYzcoURwg;

1.17
date	2016.01.26.09.42.35;	author dcoppa;	state Exp;
branches;
next	1.16;
commitid	mkjgRfx7SCNrsHTR;

1.16
date	2016.01.21.13.22.58;	author dcoppa;	state Exp;
branches;
next	1.15;
commitid	JO2klPLuYBs0OO0t;

1.15
date	2015.12.18.15.53.09;	author dcoppa;	state Exp;
branches;
next	1.14;
commitid	0OqseA58UoyREWdQ;

1.14
date	2015.03.30.12.33.46;	author dcoppa;	state Exp;
branches;
next	1.13;
commitid	iVyfQtDXLWKbSbnJ;

1.13
date	2015.03.17.15.39.47;	author dcoppa;	state Exp;
branches;
next	1.12;
commitid	WQl7M1uD6B2NjHh4;

1.12
date	2014.08.18.08.46.27;	author dcoppa;	state Exp;
branches;
next	1.11;
commitid	Bi02IjLxhs8ESxGu;

1.11
date	2014.07.11.15.49.58;	author dcoppa;	state Exp;
branches;
next	1.10;
commitid	dpkYaZL7eWFGPiTd;

1.10
date	2014.03.18.12.12.05;	author dcoppa;	state Exp;
branches;
next	1.9;

1.9
date	2014.01.11.16.04.43;	author dcoppa;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.13.10.01.56;	author dcoppa;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.17.10.21.42;	author dcoppa;	state Exp;
branches;
next	1.6;

1.6
date	2013.05.16.18.42.30;	author dcoppa;	state Exp;
branches;
next	1.5;

1.5
date	2012.12.13.12.10.13;	author dcoppa;	state Exp;
branches;
next	1.4;

1.4
date	2012.09.21.17.16.14;	author dcoppa;	state Exp;
branches;
next	1.3;

1.3
date	2012.08.27.09.49.18;	author dcoppa;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.08.14.33.25;	author dcoppa;	state Exp;
branches;
next	1.1;

1.1
date	2012.05.28.13.37.50;	author dcoppa;	state Exp;
branches;
next	;


desc
@@


1.20
log
@
Bugfixing update to i3-4.14.1
@
text
@$OpenBSD: patch-src_commands_c,v 1.19 2017/09/13 12:50:33 dcoppa Exp $

commit 369c9ed50f2b9fc2dc904db07907cd5f95f0a5ad
Author: Orestis <orestisf1993@@gmail.com>
Date:   Wed Sep 6 05:34:14 2017

Check if con_id exists in cmd_swap

Index: src/commands.c
--- src/commands.c.orig
+++ src/commands.c
@@@@ -1841,7 +1841,7 @@@@ void cmd_swap(I3_CMD, const char *mode, const char *ar
             return;
         }
 
-        con = (Con *)target;
+        con = con_by_con_id(target);
     } else if (strcmp(mode, "mark") == 0) {
         con = con_by_mark(arg);
     } else {
@@@@ -1854,7 +1854,7 @@@@ void cmd_swap(I3_CMD, const char *mode, const char *ar
         return;
     }
 
-    if (match == TAILQ_LAST(&owindows, owindows_head)) {
+    if (match != TAILQ_LAST(&owindows, owindows_head)) {
         DLOG("More than one container matched the swap command, only using the first one.");
     }
 
@


1.19
log
@
Merge fixes from upstream:

Check if con_id exists in cmd_swap
(git commit 369c9ed50f2b9fc2dc904db07907cd5f95f0a5ad)

Set marks to NULL after freeing
realloc() was being called on an already freed pointer.
(git commit b48cbe42af94cf69700843922e57c68b81f3fddd)

Properly initialize sigaction struct
(git commit 09ee12d8e5e1cd219493fde3393dbca10c0cc23f)
@
text
@d1 1
a1 1
$OpenBSD$
@


1.18
log
@
Update to i3-4.12
Added halex@@'s window hints fix
Fixed trailing whitespace in pkg/DESCR (spotted by Josh Grosse)

Tested by tb@@ and Josh Grosse
OK tb@@
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.17 2016/01/26 09:42:35 dcoppa Exp $
d3 12
a14 271
Fix duplicated marks on append_layout.

Correctly handle command criteria for "move window to output".

Migrate the resize command to use typed numbers.

Migrate the move command to use typed numbers.

Turn "char *" into "const char *" for all command parser functions.

Fix crash when trying to split and float a dock container.

Refactor parsing of matches to avoid code duplication.

Remove commented-out code.

--- src/commands.c.orig	Wed Sep 30 08:55:10 2015
+++ src/commands.c	Tue Jan 26 10:20:25 2016
@@@@ -83,7 +83,7 @@@@ static Output *get_output_of_con(Con *con) {
  * and return true, signaling that no further workspace switching should occur in the calling function.
  *
  */
-static bool maybe_back_and_forth(struct CommandResultIR *cmd_output, char *name) {
+static bool maybe_back_and_forth(struct CommandResultIR *cmd_output, const char *name) {
     Con *ws = con_get_workspace(focused);
 
     /* If we switched to a different workspace, do nothing */
@@@@ -121,102 +121,6 @@@@ static Con *maybe_auto_back_and_forth_workspace(Con *w
     return workspace;
 }
 
-// This code is commented out because we might recycle it for popping up error
-// messages on parser errors.
-#if 0
-static pid_t migration_pid = -1;
-
-/*
- * Handler which will be called when we get a SIGCHLD for the nagbar, meaning
- * it exited (or could not be started, depending on the exit code).
- *
- */
-static void nagbar_exited(EV_P_ ev_child *watcher, int revents) {
-    ev_child_stop(EV_A_ watcher);
-    if (!WIFEXITED(watcher->rstatus)) {
-        fprintf(stderr, "ERROR: i3-nagbar did not exit normally.\n");
-        return;
-    }
-
-    int exitcode = WEXITSTATUS(watcher->rstatus);
-    printf("i3-nagbar process exited with status %d\n", exitcode);
-    if (exitcode == 2) {
-        fprintf(stderr, "ERROR: i3-nagbar could not be found. Is it correctly installed on your system?\n");
-    }
-
-    migration_pid = -1;
-}
-
-/* We need ev >= 4 for the following code. Since it is not *that* important (it
- * only makes sure that there are no i3-nagbar instances left behind) we still
- * support old systems with libev 3. */
-#if EV_VERSION_MAJOR >= 4
-/*
- * Cleanup handler. Will be called when i3 exits. Kills i3-nagbar with signal
- * SIGKILL (9) to make sure there are no left-over i3-nagbar processes.
- *
- */
-static void nagbar_cleanup(EV_P_ ev_cleanup *watcher, int revent) {
-    if (migration_pid != -1) {
-        LOG("Sending SIGKILL (9) to i3-nagbar with PID %d\n", migration_pid);
-        kill(migration_pid, SIGKILL);
-    }
-}
-#endif
-
-void cmd_MIGRATION_start_nagbar(void) {
-    if (migration_pid != -1) {
-        fprintf(stderr, "i3-nagbar already running.\n");
-        return;
-    }
-    fprintf(stderr, "Starting i3-nagbar, command parsing differs from expected output.\n");
-    ELOG("Please report this on IRC or in the bugtracker. Make sure to include the full debug level logfile:\n");
-    ELOG("i3-dump-log | gzip -9c > /tmp/i3.log.gz\n");
-    ELOG("FYI: Your i3 version is " I3_VERSION "\n");
-    migration_pid = fork();
-    if (migration_pid == -1) {
-        warn("Could not fork()");
-        return;
-    }
-
-    /* child */
-    if (migration_pid == 0) {
-        char *pageraction;
-        sasprintf(&pageraction, "i3-sensible-terminal -e i3-sensible-pager \"%s\"", errorfilename);
-        char *argv[] = {
-            NULL, /* will be replaced by the executable path */
-            "-t",
-            "error",
-            "-m",
-            "You found a parsing error. Please, please, please, report it!",
-            "-b",
-            "show errors",
-            pageraction,
-            NULL
-        };
-        exec_i3_utility("i3-nagbar", argv);
-    }
-
-    /* parent */
-    /* install a child watcher */
-    ev_child *child = smalloc(sizeof(ev_child));
-    ev_child_init(child, &nagbar_exited, migration_pid, 0);
-    ev_child_start(main_loop, child);
-
-/* We need ev >= 4 for the following code. Since it is not *that* important (it
- * only makes sure that there are no i3-nagbar instances left behind) we still
- * support old systems with libev 3. */
-#if EV_VERSION_MAJOR >= 4
-    /* install a cleanup watcher (will be called when i3 exits and i3-nagbar is
-     * still running) */
-    ev_cleanup *cleanup = smalloc(sizeof(ev_cleanup));
-    ev_cleanup_init(cleanup, nagbar_cleanup);
-    ev_cleanup_start(main_loop, cleanup);
-#endif
-}
-
-#endif
-
 /*******************************************************************************
  * Criteria functions.
  ******************************************************************************/
@@@@ -315,108 +219,8 @@@@ void cmd_criteria_match_windows(I3_CMD) {
  * specification.
  *
  */
-void cmd_criteria_add(I3_CMD, char *ctype, char *cvalue) {
-    DLOG("ctype=*%s*, cvalue=*%s*\n", ctype, cvalue);
-
-    if (strcmp(ctype, "class") == 0) {
-        current_match->class = regex_new(cvalue);
-        return;
-    }
-
-    if (strcmp(ctype, "instance") == 0) {
-        current_match->instance = regex_new(cvalue);
-        return;
-    }
-
-    if (strcmp(ctype, "window_role") == 0) {
-        current_match->window_role = regex_new(cvalue);
-        return;
-    }
-
-    if (strcmp(ctype, "con_id") == 0) {
-        char *end;
-        long parsed = strtol(cvalue, &end, 0);
-        if (parsed == LONG_MIN ||
-            parsed == LONG_MAX ||
-            parsed < 0 ||
-            (end && *end != '\0')) {
-            ELOG("Could not parse con id \"%s\"\n", cvalue);
-        } else {
-            current_match->con_id = (Con *)parsed;
-            DLOG("id as int = %p\n", current_match->con_id);
-        }
-        return;
-    }
-
-    if (strcmp(ctype, "id") == 0) {
-        char *end;
-        long parsed = strtol(cvalue, &end, 0);
-        if (parsed == LONG_MIN ||
-            parsed == LONG_MAX ||
-            parsed < 0 ||
-            (end && *end != '\0')) {
-            ELOG("Could not parse window id \"%s\"\n", cvalue);
-        } else {
-            current_match->id = parsed;
-            DLOG("window id as int = %d\n", current_match->id);
-        }
-        return;
-    }
-
-    if (strcmp(ctype, "window_type") == 0) {
-        if (strcasecmp(cvalue, "normal") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_NORMAL;
-        else if (strcasecmp(cvalue, "dialog") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_DIALOG;
-        else if (strcasecmp(cvalue, "utility") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_UTILITY;
-        else if (strcasecmp(cvalue, "toolbar") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_TOOLBAR;
-        else if (strcasecmp(cvalue, "splash") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_SPLASH;
-        else if (strcasecmp(cvalue, "menu") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_MENU;
-        else if (strcasecmp(cvalue, "dropdown_menu") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_DROPDOWN_MENU;
-        else if (strcasecmp(cvalue, "popup_menu") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_POPUP_MENU;
-        else if (strcasecmp(cvalue, "tooltip") == 0)
-            current_match->window_type = A__NET_WM_WINDOW_TYPE_TOOLTIP;
-        else
-            ELOG("unknown window_type value \"%s\"\n", cvalue);
-
-        return;
-    }
-
-    if (strcmp(ctype, "con_mark") == 0) {
-        current_match->mark = regex_new(cvalue);
-        return;
-    }
-
-    if (strcmp(ctype, "title") == 0) {
-        current_match->title = regex_new(cvalue);
-        return;
-    }
-
-    if (strcmp(ctype, "urgent") == 0) {
-        if (strcasecmp(cvalue, "latest") == 0 ||
-            strcasecmp(cvalue, "newest") == 0 ||
-            strcasecmp(cvalue, "recent") == 0 ||
-            strcasecmp(cvalue, "last") == 0) {
-            current_match->urgent = U_LATEST;
-        } else if (strcasecmp(cvalue, "oldest") == 0 ||
-                   strcasecmp(cvalue, "first") == 0) {
-            current_match->urgent = U_OLDEST;
-        }
-        return;
-    }
-
-    if (strcmp(ctype, "workspace") == 0) {
-        current_match->workspace = regex_new(cvalue);
-        return;
-    }
-
-    ELOG("Unknown criterion: %s\n", ctype);
+void cmd_criteria_add(I3_CMD, const char *ctype, const char *cvalue) {
+    match_parse_property(current_match, ctype, cvalue);
 }
 
 /*
@@@@ -424,7 +228,7 @@@@ void cmd_criteria_add(I3_CMD, char *ctype, char *cvalu
  * next|prev|next_on_output|prev_on_output|current'.
  *
  */
-void cmd_move_con_to_workspace(I3_CMD, char *which) {
+void cmd_move_con_to_workspace(I3_CMD, const char *which) {
     owindow *current;
 
     DLOG("which=%s\n", which);
@@@@ -500,7 +304,7 @@@@ void cmd_move_con_to_workspace_back_and_forth(I3_CMD) 
  * Implementation of 'move [window|container] [to] workspace <name>'.
  *
  */
-void cmd_move_con_to_workspace_name(I3_CMD, char *name) {
+void cmd_move_con_to_workspace_name(I3_CMD, const char *name) {
     if (strncasecmp(name, "__", strlen("__")) == 0) {
         LOG("You cannot move containers to i3-internal workspaces (\"%s\").\n", name);
         ysuccess(false);
@@@@ -544,7 +348,7 @@@@ void cmd_move_con_to_workspace_name(I3_CMD, char *name
  * Implementation of 'move [window|container] [to] workspace number <name>'.
  *
  */
-void cmd_move_con_to_workspace_number(I3_CMD, char *which) {
+void cmd_move_con_to_workspace_number(I3_CMD, const char *which) {
     owindow *current;
 
     /* We have nothing to move:
@@@@ -591,7 +395,7 @@@@ void cmd_move_con_to_workspace_number(I3_CMD, char *wh
     ysuccess(true);
 }
d16 6
a21 78
-static void cmd_resize_floating(I3_CMD, char *way, char *direction, Con *floating_con, int px) {
+static void cmd_resize_floating(I3_CMD, const char *way, const char *direction, Con *floating_con, int px) {
     LOG("floating resize\n");
     Rect old_rect = floating_con->rect;
     Con *focused_con = con_descend_focused(floating_con);
@@@@ -643,7 +447,7 @@@@ static void cmd_resize_floating(I3_CMD, char *way, cha
         floating_con->scratchpad_state = SCRATCHPAD_CHANGED;
 }
 
-static bool cmd_resize_tiling_direction(I3_CMD, Con *current, char *way, char *direction, int ppt) {
+static bool cmd_resize_tiling_direction(I3_CMD, Con *current, const char *way, const char *direction, int ppt) {
     LOG("tiling resize\n");
     Con *second = NULL;
     Con *first = current;
@@@@ -696,7 +500,7 @@@@ static bool cmd_resize_tiling_direction(I3_CMD, Con *c
     return true;
 }
 
-static bool cmd_resize_tiling_width_height(I3_CMD, Con *current, char *way, char *direction, int ppt) {
+static bool cmd_resize_tiling_width_height(I3_CMD, Con *current, const char *way, const char *direction, int ppt) {
     LOG("width/height resize\n");
     /* get the appropriate current container (skip stacked/tabbed cons) */
     while (current->parent->layout == L_STACKED ||
@@@@ -782,15 +586,11 @@@@ static bool cmd_resize_tiling_width_height(I3_CMD, Con
  * Implementation of 'resize grow|shrink <direction> [<px> px] [or <ppt> ppt]'.
  *
  */
-void cmd_resize(I3_CMD, char *way, char *direction, char *resize_px, char *resize_ppt) {
-    /* resize <grow|shrink> <direction> [<px> px] [or <ppt> ppt] */
-    DLOG("resizing in way %s, direction %s, px %s or ppt %s\n", way, direction, resize_px, resize_ppt);
-    // TODO: We could either handle this in the parser itself as a separate token (and make the stack typed) or we need a better way to convert a string to a number with error checking
-    int px = atoi(resize_px);
-    int ppt = atoi(resize_ppt);
+void cmd_resize(I3_CMD, const char *way, const char *direction, long resize_px, long resize_ppt) {
+    DLOG("resizing in way %s, direction %s, px %ld or ppt %ld\n", way, direction, resize_px, resize_ppt);
     if (strcmp(way, "shrink") == 0) {
-        px *= -1;
-        ppt *= -1;
+        resize_px *= -1;
+        resize_ppt *= -1;
     }
 
     HANDLE_EMPTY_MATCH;
@@@@ -805,14 +605,16 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
 
         Con *floating_con;
         if ((floating_con = con_inside_floating(current->con))) {
-            cmd_resize_floating(current_match, cmd_output, way, direction, floating_con, px);
+            cmd_resize_floating(current_match, cmd_output, way, direction, floating_con, resize_px);
         } else {
             if (strcmp(direction, "width") == 0 ||
                 strcmp(direction, "height") == 0) {
-                if (!cmd_resize_tiling_width_height(current_match, cmd_output, current->con, way, direction, ppt))
+                if (!cmd_resize_tiling_width_height(current_match, cmd_output,
+                                                    current->con, way, direction, resize_ppt))
                     return;
             } else {
-                if (!cmd_resize_tiling_direction(current_match, cmd_output, current->con, way, direction, ppt))
+                if (!cmd_resize_tiling_direction(current_match, cmd_output,
+                                                 current->con, way, direction, resize_ppt))
                     return;
             }
         }
@@@@ -827,13 +629,10 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
  * Implementation of 'resize set <px> [px] <px> [px]'.
  *
  */
-void cmd_size(I3_CMD, char *cwidth, char *cheight) {
-    DLOG("resizing to %sx%s px\n", cwidth, cheight);
-    // TODO: We could either handle this in the parser itself as a separate token (and make the stack typed) or we need a better way to convert a string to a number with error checking
-    int x = atoi(cwidth);
-    int y = atoi(cheight);
-    if (x <= 0 || y <= 0) {
-        ELOG("Resize failed: dimensions cannot be negative (was %sx%s)\n", cwidth, cheight);
+void cmd_resize_set(I3_CMD, long cwidth, long cheight) {
+    DLOG("resizing to %ldx%ld px\n", cwidth, cheight);
+    if (cwidth <= 0 || cheight <= 0) {
+        ELOG("Resize failed: dimensions cannot be negative (was %ldx%ld)\n", cwidth, cheight);
d25 3
a27 288
@@@@ -843,7 +642,7 @@@@ void cmd_size(I3_CMD, char *cwidth, char *cheight) {
     TAILQ_FOREACH(current, &owindows, owindows) {
         Con *floating_con;
         if ((floating_con = con_inside_floating(current->con))) {
-            floating_resize(floating_con, x, y);
+            floating_resize(floating_con, cwidth, cheight);
         } else {
             ELOG("Resize failed: %p not a floating container\n", current->con);
         }
@@@@ -858,7 +657,7 @@@@ void cmd_size(I3_CMD, char *cwidth, char *cheight) {
  * Implementation of 'border normal|pixel [<n>]', 'border none|1pixel|toggle'.
  *
  */
-void cmd_border(I3_CMD, char *border_style_str, char *border_width) {
+void cmd_border(I3_CMD, const char *border_style_str, const char *border_width) {
     DLOG("border style should be changed to %s with border width %s\n", border_style_str, border_width);
     owindow *current;
 
@@@@ -911,7 +710,7 @@@@ void cmd_border(I3_CMD, char *border_style_str, char *
  * Implementation of 'nop <comment>'.
  *
  */
-void cmd_nop(I3_CMD, char *comment) {
+void cmd_nop(I3_CMD, const char *comment) {
     LOG("-------------------------------------------------\n");
     LOG("  NOP: %s\n", comment);
     LOG("-------------------------------------------------\n");
@@@@ -921,7 +720,8 @@@@ void cmd_nop(I3_CMD, char *comment) {
  * Implementation of 'append_layout <path>'.
  *
  */
-void cmd_append_layout(I3_CMD, char *path) {
+void cmd_append_layout(I3_CMD, const char *cpath) {
+    char *path = sstrdup(cpath);
     LOG("Appending layout \"%s\"\n", path);
 
     /* Make sure we allow paths like '~/.i3/layout.json' */
@@@@ -982,7 +782,7 @@@@ void cmd_append_layout(I3_CMD, char *path) {
  * Implementation of 'workspace next|prev|next_on_output|prev_on_output'.
  *
  */
-void cmd_workspace(I3_CMD, char *which) {
+void cmd_workspace(I3_CMD, const char *which) {
     Con *ws;
 
     DLOG("which=%s\n", which);
@@@@ -1018,7 +818,7 @@@@ void cmd_workspace(I3_CMD, char *which) {
  * Implementation of 'workspace number <name>'
  *
  */
-void cmd_workspace_number(I3_CMD, char *which) {
+void cmd_workspace_number(I3_CMD, const char *which) {
     Con *output, *workspace = NULL;
 
     if (con_get_fullscreen_con(croot, CF_GLOBAL)) {
@@@@ -1077,7 +877,7 @@@@ void cmd_workspace_back_and_forth(I3_CMD) {
  * Implementation of 'workspace <name>'
  *
  */
-void cmd_workspace_name(I3_CMD, char *name) {
+void cmd_workspace_name(I3_CMD, const char *name) {
     if (strncasecmp(name, "__", strlen("__")) == 0) {
         LOG("You cannot switch to the i3-internal workspaces (\"%s\").\n", name);
         ysuccess(false);
@@@@ -1104,7 +904,7 @@@@ void cmd_workspace_name(I3_CMD, char *name) {
  * Implementation of 'mark [--toggle] <mark>'
  *
  */
-void cmd_mark(I3_CMD, char *mark, char *toggle) {
+void cmd_mark(I3_CMD, const char *mark, const char *toggle) {
     HANDLE_EMPTY_MATCH;
 
     owindow *current = TAILQ_FIRST(&owindows);
@@@@ -1135,7 +935,7 @@@@ void cmd_mark(I3_CMD, char *mark, char *toggle) {
  * Implementation of 'unmark [mark]'
  *
  */
-void cmd_unmark(I3_CMD, char *mark) {
+void cmd_unmark(I3_CMD, const char *mark) {
     con_unmark(mark);
 
     cmd_output->needs_tree_render = true;
@@@@ -1147,7 +947,7 @@@@ void cmd_unmark(I3_CMD, char *mark) {
  * Implementation of 'mode <string>'.
  *
  */
-void cmd_mode(I3_CMD, char *mode) {
+void cmd_mode(I3_CMD, const char *mode) {
     DLOG("mode=%s\n", mode);
     switch_mode(mode);
 
@@@@ -1159,7 +959,7 @@@@ void cmd_mode(I3_CMD, char *mode) {
  * Implementation of 'move [window|container] [to] output <str>'.
  *
  */
-void cmd_move_con_to_output(I3_CMD, char *name) {
+void cmd_move_con_to_output(I3_CMD, const char *name) {
     DLOG("Should move window to output \"%s\".\n", name);
     HANDLE_EMPTY_MATCH;
 
@@@@ -1197,7 +997,7 @@@@ void cmd_move_con_to_output(I3_CMD, char *name) {
  * Implementation of 'move [container|window] [to] mark <str>'.
  *
  */
-void cmd_move_con_to_mark(I3_CMD, char *mark) {
+void cmd_move_con_to_mark(I3_CMD, const char *mark) {
     DLOG("moving window to mark \"%s\"\n", mark);
 
     HANDLE_EMPTY_MATCH;
@@@@ -1217,7 +1017,7 @@@@ void cmd_move_con_to_mark(I3_CMD, char *mark) {
  * Implementation of 'floating enable|disable|toggle'
  *
  */
-void cmd_floating(I3_CMD, char *floating_mode) {
+void cmd_floating(I3_CMD, const char *floating_mode) {
     owindow *current;
 
     DLOG("floating_mode=%s\n", floating_mode);
@@@@ -1248,7 +1048,7 @@@@ void cmd_floating(I3_CMD, char *floating_mode) {
  * Implementation of 'move workspace to [output] <str>'.
  *
  */
-void cmd_move_workspace_to_output(I3_CMD, char *name) {
+void cmd_move_workspace_to_output(I3_CMD, const char *name) {
     DLOG("should move workspace to output %s\n", name);
 
     HANDLE_EMPTY_MATCH;
@@@@ -1273,17 +1073,19 @@@@ void cmd_move_workspace_to_output(I3_CMD, char *name) 
  * Implementation of 'split v|h|vertical|horizontal'.
  *
  */
-void cmd_split(I3_CMD, char *direction) {
+void cmd_split(I3_CMD, const char *direction) {
+    HANDLE_EMPTY_MATCH;
+
     owindow *current;
-    /* TODO: use matches */
     LOG("splitting in direction %c\n", direction[0]);
-    if (match_is_empty(current_match))
-        tree_split(focused, (direction[0] == 'v' ? VERT : HORIZ));
-    else {
-        TAILQ_FOREACH(current, &owindows, owindows) {
-            DLOG("matching: %p / %s\n", current->con, current->con->name);
-            tree_split(current->con, (direction[0] == 'v' ? VERT : HORIZ));
+    TAILQ_FOREACH(current, &owindows, owindows) {
+        if (con_is_docked(current->con)) {
+            ELOG("Cannot split a docked container, skipping.\n");
+            continue;
         }
+
+        DLOG("matching: %p / %s\n", current->con, current->con->name);
+        tree_split(current->con, (direction[0] == 'v' ? VERT : HORIZ));
     }
 
     cmd_output->needs_tree_render = true;
@@@@ -1295,7 +1097,7 @@@@ void cmd_split(I3_CMD, char *direction) {
  * Implementation of 'kill [window|client]'.
  *
  */
-void cmd_kill(I3_CMD, char *kill_mode_str) {
+void cmd_kill(I3_CMD, const char *kill_mode_str) {
     if (kill_mode_str == NULL)
         kill_mode_str = "window";
     owindow *current;
@@@@ -1332,7 +1134,7 @@@@ void cmd_kill(I3_CMD, char *kill_mode_str) {
  * Implementation of 'exec [--no-startup-id] <command>'.
  *
  */
-void cmd_exec(I3_CMD, char *nosn, char *command) {
+void cmd_exec(I3_CMD, const char *nosn, const char *command) {
     bool no_startup_id = (nosn != NULL);
 
     DLOG("should execute %s, no_startup_id = %d\n", command, no_startup_id);
@@@@ -1346,7 +1148,7 @@@@ void cmd_exec(I3_CMD, char *nosn, char *command) {
  * Implementation of 'focus left|right|up|down'.
  *
  */
-void cmd_focus_direction(I3_CMD, char *direction) {
+void cmd_focus_direction(I3_CMD, const char *direction) {
     DLOG("direction = *%s*\n", direction);
 
     if (strcmp(direction, "left") == 0)
@@@@ -1372,7 +1174,7 @@@@ void cmd_focus_direction(I3_CMD, char *direction) {
  * Implementation of 'focus tiling|floating|mode_toggle'.
  *
  */
-void cmd_focus_window_mode(I3_CMD, char *window_mode) {
+void cmd_focus_window_mode(I3_CMD, const char *window_mode) {
     DLOG("window_mode = %s\n", window_mode);
 
     Con *ws = con_get_workspace(focused);
@@@@ -1403,7 +1205,7 @@@@ void cmd_focus_window_mode(I3_CMD, char *window_mode) 
  * Implementation of 'focus parent|child'.
  *
  */
-void cmd_focus_level(I3_CMD, char *level) {
+void cmd_focus_level(I3_CMD, const char *level) {
     DLOG("level = %s\n", level);
     bool success = false;
 
@@@@ -1507,7 +1309,7 @@@@ void cmd_focus(I3_CMD) {
  *                   'fullscreen disable'
  *
  */
-void cmd_fullscreen(I3_CMD, char *action, char *fullscreen_mode) {
+void cmd_fullscreen(I3_CMD, const char *action, const char *fullscreen_mode) {
     fullscreen_mode_t mode = strcmp(fullscreen_mode, "global") == 0 ? CF_GLOBAL : CF_OUTPUT;
     DLOG("%s fullscreen, mode = %s\n", action, fullscreen_mode);
     owindow *current;
@@@@ -1534,7 +1336,7 @@@@ void cmd_fullscreen(I3_CMD, char *action, char *fullsc
  * Implementation of 'sticky enable|disable|toggle'.
  *
  */
-void cmd_sticky(I3_CMD, char *action) {
+void cmd_sticky(I3_CMD, const char *action) {
     DLOG("%s sticky on window\n", action);
     HANDLE_EMPTY_MATCH;
 
@@@@ -1570,28 +1372,25 @@@@ void cmd_sticky(I3_CMD, char *action) {
  * Implementation of 'move <direction> [<pixels> [px]]'.
  *
  */
-void cmd_move_direction(I3_CMD, char *direction, char *move_px) {
-    // TODO: We could either handle this in the parser itself as a separate token (and make the stack typed) or we need a better way to convert a string to a number with error checking
-    int px = atoi(move_px);
-
+void cmd_move_direction(I3_CMD, const char *direction, long move_px) {
     owindow *current;
     HANDLE_EMPTY_MATCH;
 
     Con *initially_focused = focused;
 
     TAILQ_FOREACH(current, &owindows, owindows) {
-        DLOG("moving in direction %s, px %s\n", direction, move_px);
+        DLOG("moving in direction %s, px %ld\n", direction, move_px);
         if (con_is_floating(current->con)) {
-            DLOG("floating move with %d pixels\n", px);
+            DLOG("floating move with %ld pixels\n", move_px);
             Rect newrect = current->con->parent->rect;
             if (strcmp(direction, "left") == 0) {
-                newrect.x -= px;
+                newrect.x -= move_px;
             } else if (strcmp(direction, "right") == 0) {
-                newrect.x += px;
+                newrect.x += move_px;
             } else if (strcmp(direction, "up") == 0) {
-                newrect.y -= px;
+                newrect.y -= move_px;
             } else if (strcmp(direction, "down") == 0) {
-                newrect.y += px;
+                newrect.y += move_px;
             }
             floating_reposition(current->con->parent, newrect);
         } else {
@@@@ -1612,10 +1411,11 @@@@ void cmd_move_direction(I3_CMD, char *direction, char 
  * Implementation of 'layout default|stacked|stacking|tabbed|splitv|splith'.
  *
  */
-void cmd_layout(I3_CMD, char *layout_str) {
+void cmd_layout(I3_CMD, const char *layout_str) {
+    HANDLE_EMPTY_MATCH;
+
     if (strcmp(layout_str, "stacking") == 0)
         layout_str = "stacked";
-    owindow *current;
     layout_t layout;
     /* default is a special case which will be handled in con_set_layout(). */
     if (strcmp(layout_str, "default") == 0)
@@@@ -1635,14 +1435,15 @@@@ void cmd_layout(I3_CMD, char *layout_str) {
 
     DLOG("changing layout to %s (%d)\n", layout_str, layout);
 
-    /* check if the match is empty, not if the result is empty */
-    if (match_is_empty(current_match))
-        con_set_layout(focused, layout);
-    else {
-        TAILQ_FOREACH(current, &owindows, owindows) {
-            DLOG("matching: %p / %s\n", current->con, current->con->name);
-            con_set_layout(current->con, layout);
+    owindow *current;
+    TAILQ_FOREACH(current, &owindows, owindows) {
+        if (con_is_docked(current->con)) {
+            ELOG("cannot change layout of a docked container, skipping it.\n");
+            continue;
         }
+
+        DLOG("matching: %p / %s\n", current->con, current->con->name);
+        con_set_layout(current->con, layout);
a29 120
     cmd_output->needs_tree_render = true;
@@@@ -1654,7 +1455,7 @@@@ void cmd_layout(I3_CMD, char *layout_str) {
  * Implementation of 'layout toggle [all|split]'.
  *
  */
-void cmd_layout_toggle(I3_CMD, char *toggle_mode) {
+void cmd_layout_toggle(I3_CMD, const char *toggle_mode) {
     owindow *current;
 
     if (toggle_mode == NULL)
@@@@ -1751,7 +1552,7 @@@@ void cmd_open(I3_CMD) {
  * Implementation of 'focus output <output>'.
  *
  */
-void cmd_focus_output(I3_CMD, char *name) {
+void cmd_focus_output(I3_CMD, const char *name) {
     owindow *current;
 
     DLOG("name = %s\n", name);
@@@@ -1793,9 +1594,7 @@@@ void cmd_focus_output(I3_CMD, char *name) {
  * Implementation of 'move [window|container] [to] [absolute] position <px> [px] <px> [px]
  *
  */
-void cmd_move_window_to_position(I3_CMD, char *method, char *cx, char *cy) {
-    int x = atoi(cx);
-    int y = atoi(cy);
+void cmd_move_window_to_position(I3_CMD, const char *method, long x, long y) {
     bool has_error = false;
 
     owindow *current;
@@@@ -1817,7 +1616,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
             current->con->parent->rect.x = x;
             current->con->parent->rect.y = y;
 
-            DLOG("moving to absolute position %d %d\n", x, y);
+            DLOG("moving to absolute position %ld %ld\n", x, y);
             floating_maybe_reassign_ws(current->con->parent);
             cmd_output->needs_tree_render = true;
         }
@@@@ -1825,7 +1624,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
         if (strcmp(method, "position") == 0) {
             Rect newrect = current->con->parent->rect;
 
-            DLOG("moving to position %d %d\n", x, y);
+            DLOG("moving to position %ld %ld\n", x, y);
             newrect.x = x;
             newrect.y = y;
 
@@@@ -1842,7 +1641,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
  * Implementation of 'move [window|container] [to] [absolute] position center
  *
  */
-void cmd_move_window_to_center(I3_CMD, char *method) {
+void cmd_move_window_to_center(I3_CMD, const char *method) {
     if (!con_is_floating(focused)) {
         ELOG("Cannot change position. The window/container is not floating\n");
         yerror("Cannot change position. The window/container is not floating.");
@@@@ -1938,7 +1737,7 @@@@ void cmd_scratchpad_show(I3_CMD) {
  * Implementation of 'title_format <format>'
  *
  */
-void cmd_title_format(I3_CMD, char *format) {
+void cmd_title_format(I3_CMD, const char *format) {
     DLOG("setting title_format to \"%s\"\n", format);
     HANDLE_EMPTY_MATCH;
 
@@@@ -1975,7 +1774,7 @@@@ void cmd_title_format(I3_CMD, char *format) {
  * Implementation of 'rename workspace [<name>] to <name>'
  *
  */
-void cmd_rename_workspace(I3_CMD, char *old_name, char *new_name) {
+void cmd_rename_workspace(I3_CMD, const char *old_name, const char *new_name) {
     if (strncasecmp(new_name, "__", strlen("__")) == 0) {
         LOG("Cannot rename workspace to \"%s\": names starting with __ are i3-internal.\n", new_name);
         ysuccess(false);
@@@@ -2060,7 +1859,7 @@@@ void cmd_rename_workspace(I3_CMD, char *old_name, char
  * Implementation of 'bar mode dock|hide|invisible|toggle [<bar_id>]'
  *
  */
-bool cmd_bar_mode(char *bar_mode, char *bar_id) {
+bool cmd_bar_mode(const char *bar_mode, const char *bar_id) {
     int mode = M_DOCK;
     bool toggle = false;
     if (strcmp(bar_mode, "dock") == 0)
@@@@ -2105,7 +1904,7 @@@@ bool cmd_bar_mode(char *bar_mode, char *bar_id) {
  * Implementation of 'bar hidden_state hide|show|toggle [<bar_id>]'
  *
  */
-bool cmd_bar_hidden_state(char *bar_hidden_state, char *bar_id) {
+bool cmd_bar_hidden_state(const char *bar_hidden_state, const char *bar_id) {
     int hidden_state = S_SHOW;
     bool toggle = false;
     if (strcmp(bar_hidden_state, "hide") == 0)
@@@@ -2148,7 +1947,7 @@@@ bool cmd_bar_hidden_state(char *bar_hidden_state, char
  * Implementation of 'bar (hidden_state hide|show|toggle)|(mode dock|hide|invisible|toggle) [<bar_id>]'
  *
  */
-void cmd_bar(I3_CMD, char *bar_type, char *bar_value, char *bar_id) {
+void cmd_bar(I3_CMD, const char *bar_type, const char *bar_value, const char *bar_id) {
     bool ret;
     if (strcmp(bar_type, "mode") == 0)
         ret = cmd_bar_mode(bar_value, bar_id);
@@@@ -2170,7 +1969,7 @@@@ void cmd_bar(I3_CMD, char *bar_type, char *bar_value, 
  * Implementation of 'shmlog <size>|toggle|on|off'
  *
  */
-void cmd_shmlog(I3_CMD, char *argument) {
+void cmd_shmlog(I3_CMD, const char *argument) {
     if (!strcmp(argument, "toggle"))
         /* Toggle shm log, if size is not 0. If it is 0, set it to default. */
         shmlog_size = shmlog_size ? -shmlog_size : default_shmlog_size;
@@@@ -2201,7 +2000,7 @@@@ void cmd_shmlog(I3_CMD, char *argument) {
  * Implementation of 'debuglog toggle|on|off'
  *
  */
-void cmd_debuglog(I3_CMD, char *argument) {
+void cmd_debuglog(I3_CMD, const char *argument) {
     bool logging = get_debug_logging();
     if (!strcmp(argument, "toggle")) {
         LOG("%s debug logging\n", logging ? "Disabling" : "Enabling");
@


1.17
log
@
Sync with upstream
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.16 2016/01/21 13:22:58 dcoppa Exp $
@


1.16
log
@
Fix i3-nagbar invocation from src/commands.c and the example in its
manpage.
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.15 2015/12/18 15:53:09 dcoppa Exp $
d3 1
a3 1
Fix duplicated marks on append_layout
d17 2
d20 1
a20 1
+++ src/commands.c	Thu Jan 21 14:14:34 2016
d30 65
a94 4
@@@@ -182,9 +182,11 @@@@ void cmd_MIGRATION_start_nagbar(void) {
     /* child */
     if (migration_pid == 0) {
         char *pageraction;
d96 38
a133 9
+        sasprintf(&pageraction, "/usr/bin/less \"%s\"\n", errorfilename);
         char *argv[] = {
             NULL, /* will be replaced by the executable path */
+            "-f",
+            config.font.pattern,
             "-t",
             "error",
             "-m",
@@@@ -315,108 +317,8 @@@@ void cmd_criteria_match_windows(I3_CMD) {
d244 1
a244 1
@@@@ -424,7 +326,7 @@@@ void cmd_criteria_add(I3_CMD, char *ctype, char *cvalu
d253 1
a253 1
@@@@ -500,7 +402,7 @@@@ void cmd_move_con_to_workspace_back_and_forth(I3_CMD) 
d262 1
a262 1
@@@@ -544,7 +446,7 @@@@ void cmd_move_con_to_workspace_name(I3_CMD, char *name
d271 1
a271 1
@@@@ -591,7 +493,7 @@@@ void cmd_move_con_to_workspace_number(I3_CMD, char *wh
d280 1
a280 1
@@@@ -643,7 +545,7 @@@@ static void cmd_resize_floating(I3_CMD, char *way, cha
d289 1
a289 1
@@@@ -696,7 +598,7 @@@@ static bool cmd_resize_tiling_direction(I3_CMD, Con *c
d298 1
a298 1
@@@@ -782,15 +684,11 @@@@ static bool cmd_resize_tiling_width_height(I3_CMD, Con
d318 1
a318 1
@@@@ -805,14 +703,16 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
d338 1
a338 1
@@@@ -827,13 +727,10 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
d356 1
a356 1
@@@@ -843,7 +740,7 @@@@ void cmd_size(I3_CMD, char *cwidth, char *cheight) {
d365 1
a365 1
@@@@ -858,7 +755,7 @@@@ void cmd_size(I3_CMD, char *cwidth, char *cheight) {
d374 1
a374 1
@@@@ -911,7 +808,7 @@@@ void cmd_border(I3_CMD, char *border_style_str, char *
d383 1
a383 1
@@@@ -921,7 +818,8 @@@@ void cmd_nop(I3_CMD, char *comment) {
d393 1
a393 1
@@@@ -982,7 +880,7 @@@@ void cmd_append_layout(I3_CMD, char *path) {
d402 1
a402 1
@@@@ -1018,7 +916,7 @@@@ void cmd_workspace(I3_CMD, char *which) {
d411 1
a411 1
@@@@ -1077,7 +975,7 @@@@ void cmd_workspace_back_and_forth(I3_CMD) {
d420 1
a420 1
@@@@ -1104,7 +1002,7 @@@@ void cmd_workspace_name(I3_CMD, char *name) {
d429 1
a429 1
@@@@ -1135,7 +1033,7 @@@@ void cmd_mark(I3_CMD, char *mark, char *toggle) {
d438 1
a438 1
@@@@ -1147,7 +1045,7 @@@@ void cmd_unmark(I3_CMD, char *mark) {
d447 1
a447 1
@@@@ -1159,7 +1057,7 @@@@ void cmd_mode(I3_CMD, char *mode) {
d456 1
a456 1
@@@@ -1197,7 +1095,7 @@@@ void cmd_move_con_to_output(I3_CMD, char *name) {
d465 1
a465 1
@@@@ -1217,7 +1115,7 @@@@ void cmd_move_con_to_mark(I3_CMD, char *mark) {
d474 1
a474 1
@@@@ -1248,7 +1146,7 @@@@ void cmd_floating(I3_CMD, char *floating_mode) {
d483 1
a483 1
@@@@ -1273,17 +1171,19 @@@@ void cmd_move_workspace_to_output(I3_CMD, char *name) 
d511 1
a511 1
@@@@ -1295,7 +1195,7 @@@@ void cmd_split(I3_CMD, char *direction) {
d520 1
a520 1
@@@@ -1332,7 +1232,7 @@@@ void cmd_kill(I3_CMD, char *kill_mode_str) {
d529 1
a529 1
@@@@ -1346,7 +1246,7 @@@@ void cmd_exec(I3_CMD, char *nosn, char *command) {
d538 1
a538 1
@@@@ -1372,7 +1272,7 @@@@ void cmd_focus_direction(I3_CMD, char *direction) {
d547 1
a547 1
@@@@ -1403,7 +1303,7 @@@@ void cmd_focus_window_mode(I3_CMD, char *window_mode) 
d556 1
a556 1
@@@@ -1507,7 +1407,7 @@@@ void cmd_focus(I3_CMD) {
d565 1
a565 1
@@@@ -1534,7 +1434,7 @@@@ void cmd_fullscreen(I3_CMD, char *action, char *fullsc
d574 1
a574 1
@@@@ -1570,28 +1470,25 @@@@ void cmd_sticky(I3_CMD, char *action) {
d610 1
a610 1
@@@@ -1612,10 +1509,11 @@@@ void cmd_move_direction(I3_CMD, char *direction, char 
d624 1
a624 1
@@@@ -1635,14 +1533,15 @@@@ void cmd_layout(I3_CMD, char *layout_str) {
d647 1
a647 1
@@@@ -1654,7 +1553,7 @@@@ void cmd_layout(I3_CMD, char *layout_str) {
d656 1
a656 1
@@@@ -1751,7 +1650,7 @@@@ void cmd_open(I3_CMD) {
d665 1
a665 1
@@@@ -1793,9 +1692,7 @@@@ void cmd_focus_output(I3_CMD, char *name) {
d676 1
a676 1
@@@@ -1817,7 +1714,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
d685 1
a685 1
@@@@ -1825,7 +1722,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
d694 1
a694 1
@@@@ -1842,7 +1739,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
d703 1
a703 1
@@@@ -1938,7 +1835,7 @@@@ void cmd_scratchpad_show(I3_CMD) {
d712 1
a712 1
@@@@ -1975,7 +1872,7 @@@@ void cmd_title_format(I3_CMD, char *format) {
d721 1
a721 1
@@@@ -2060,7 +1957,7 @@@@ void cmd_rename_workspace(I3_CMD, char *old_name, char
d730 1
a730 1
@@@@ -2105,7 +2002,7 @@@@ bool cmd_bar_mode(char *bar_mode, char *bar_id) {
d739 1
a739 1
@@@@ -2148,7 +2045,7 @@@@ bool cmd_bar_hidden_state(char *bar_hidden_state, char
d748 1
a748 1
@@@@ -2170,7 +2067,7 @@@@ void cmd_bar(I3_CMD, char *bar_type, char *bar_value, 
d757 1
a757 1
@@@@ -2201,7 +2098,7 @@@@ void cmd_shmlog(I3_CMD, char *argument) {
@


1.15
log
@
Merge all the fixes from the git stable branch of i3
Regen WANTLIB while here
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.14 2015/03/30 12:33:46 dcoppa Exp $
d18 1
a18 1
+++ src/commands.c	Fri Dec 18 13:58:58 2015
d28 1
a28 1
@@@@ -182,7 +182,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
d33 1
a33 1
+        sasprintf(&pageraction, "${X11BASE}/bin/xterm -e /usr/bin/less \"%s\"", errorfilename);
d36 2
d39 3
a41 1
@@@@ -315,108 +315,8 @@@@ void cmd_criteria_match_windows(I3_CMD) {
d152 1
a152 1
@@@@ -424,7 +324,7 @@@@ void cmd_criteria_add(I3_CMD, char *ctype, char *cvalu
d161 1
a161 1
@@@@ -500,7 +400,7 @@@@ void cmd_move_con_to_workspace_back_and_forth(I3_CMD) 
d170 1
a170 1
@@@@ -544,7 +444,7 @@@@ void cmd_move_con_to_workspace_name(I3_CMD, char *name
d179 1
a179 1
@@@@ -591,7 +491,7 @@@@ void cmd_move_con_to_workspace_number(I3_CMD, char *wh
d188 1
a188 1
@@@@ -643,7 +543,7 @@@@ static void cmd_resize_floating(I3_CMD, char *way, cha
d197 1
a197 1
@@@@ -696,7 +596,7 @@@@ static bool cmd_resize_tiling_direction(I3_CMD, Con *c
d206 1
a206 1
@@@@ -782,15 +682,11 @@@@ static bool cmd_resize_tiling_width_height(I3_CMD, Con
d226 1
a226 1
@@@@ -805,14 +701,16 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
d246 1
a246 1
@@@@ -827,13 +725,10 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
d264 1
a264 1
@@@@ -843,7 +738,7 @@@@ void cmd_size(I3_CMD, char *cwidth, char *cheight) {
d273 1
a273 1
@@@@ -858,7 +753,7 @@@@ void cmd_size(I3_CMD, char *cwidth, char *cheight) {
d282 1
a282 1
@@@@ -911,7 +806,7 @@@@ void cmd_border(I3_CMD, char *border_style_str, char *
d291 1
a291 1
@@@@ -921,7 +816,8 @@@@ void cmd_nop(I3_CMD, char *comment) {
d301 1
a301 1
@@@@ -982,7 +878,7 @@@@ void cmd_append_layout(I3_CMD, char *path) {
d310 1
a310 1
@@@@ -1018,7 +914,7 @@@@ void cmd_workspace(I3_CMD, char *which) {
d319 1
a319 1
@@@@ -1077,7 +973,7 @@@@ void cmd_workspace_back_and_forth(I3_CMD) {
d328 1
a328 1
@@@@ -1104,7 +1000,7 @@@@ void cmd_workspace_name(I3_CMD, char *name) {
d337 1
a337 1
@@@@ -1135,7 +1031,7 @@@@ void cmd_mark(I3_CMD, char *mark, char *toggle) {
d346 1
a346 1
@@@@ -1147,7 +1043,7 @@@@ void cmd_unmark(I3_CMD, char *mark) {
d355 1
a355 1
@@@@ -1159,7 +1055,7 @@@@ void cmd_mode(I3_CMD, char *mode) {
d364 1
a364 1
@@@@ -1197,7 +1093,7 @@@@ void cmd_move_con_to_output(I3_CMD, char *name) {
d373 1
a373 1
@@@@ -1217,7 +1113,7 @@@@ void cmd_move_con_to_mark(I3_CMD, char *mark) {
d382 1
a382 1
@@@@ -1248,7 +1144,7 @@@@ void cmd_floating(I3_CMD, char *floating_mode) {
d391 1
a391 1
@@@@ -1273,17 +1169,19 @@@@ void cmd_move_workspace_to_output(I3_CMD, char *name) 
d419 1
a419 1
@@@@ -1295,7 +1193,7 @@@@ void cmd_split(I3_CMD, char *direction) {
d428 1
a428 1
@@@@ -1332,7 +1230,7 @@@@ void cmd_kill(I3_CMD, char *kill_mode_str) {
d437 1
a437 1
@@@@ -1346,7 +1244,7 @@@@ void cmd_exec(I3_CMD, char *nosn, char *command) {
d446 1
a446 1
@@@@ -1372,7 +1270,7 @@@@ void cmd_focus_direction(I3_CMD, char *direction) {
d455 1
a455 1
@@@@ -1403,7 +1301,7 @@@@ void cmd_focus_window_mode(I3_CMD, char *window_mode) 
d464 1
a464 1
@@@@ -1507,7 +1405,7 @@@@ void cmd_focus(I3_CMD) {
d473 1
a473 1
@@@@ -1534,7 +1432,7 @@@@ void cmd_fullscreen(I3_CMD, char *action, char *fullsc
d482 1
a482 1
@@@@ -1570,28 +1468,25 @@@@ void cmd_sticky(I3_CMD, char *action) {
d518 1
a518 1
@@@@ -1612,10 +1507,11 @@@@ void cmd_move_direction(I3_CMD, char *direction, char 
d532 1
a532 1
@@@@ -1635,14 +1531,15 @@@@ void cmd_layout(I3_CMD, char *layout_str) {
d555 1
a555 1
@@@@ -1654,7 +1551,7 @@@@ void cmd_layout(I3_CMD, char *layout_str) {
d564 1
a564 1
@@@@ -1751,7 +1648,7 @@@@ void cmd_open(I3_CMD) {
d573 1
a573 1
@@@@ -1793,9 +1690,7 @@@@ void cmd_focus_output(I3_CMD, char *name) {
d584 1
a584 1
@@@@ -1817,7 +1712,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
d593 1
a593 1
@@@@ -1825,7 +1720,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
d602 1
a602 1
@@@@ -1842,7 +1737,7 @@@@ void cmd_move_window_to_position(I3_CMD, char *method,
d611 1
a611 1
@@@@ -1938,7 +1833,7 @@@@ void cmd_scratchpad_show(I3_CMD) {
d620 1
a620 1
@@@@ -1975,7 +1870,7 @@@@ void cmd_title_format(I3_CMD, char *format) {
d629 1
a629 1
@@@@ -2060,7 +1955,7 @@@@ void cmd_rename_workspace(I3_CMD, char *old_name, char
d638 1
a638 1
@@@@ -2105,7 +2000,7 @@@@ bool cmd_bar_mode(char *bar_mode, char *bar_id) {
d647 1
a647 1
@@@@ -2148,7 +2043,7 @@@@ bool cmd_bar_hidden_state(char *bar_hidden_state, char
d656 1
a656 1
@@@@ -2170,7 +2065,7 @@@@ void cmd_bar(I3_CMD, char *bar_type, char *bar_value, 
d665 1
a665 1
@@@@ -2201,7 +2096,7 @@@@ void cmd_shmlog(I3_CMD, char *argument) {
@


1.14
log
@
Update to i3-4.10.1
@
text
@d1 27
a27 3
$OpenBSD: patch-src_commands_c,v 1.13 2015/03/17 15:39:47 dcoppa Exp $
--- src/commands.c.orig	Sun Mar 29 19:07:08 2015
+++ src/commands.c	Mon Mar 30 14:13:25 2015
d37 633
@


1.13
log
@
Update to i3-4.9.1

new dependency on x11/xkbcommon
@
text
@d1 4
a4 4
$OpenBSD: patch-src_commands_c,v 1.12 2014/08/18 08:46:27 dcoppa Exp $
--- src/commands.c.orig	Sat Mar  7 13:26:13 2015
+++ src/commands.c	Tue Mar 17 10:24:24 2015
@@@@ -204,7 +204,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
@


1.12
log
@
Fixes from upstream:

Bugfix: properly restore workspace containers
(upstream git commit 679a5de8cfb9211afb1a1dd882e53bd672084754)

Bugfix: missed case for decoration rerender
(upstream git commit 56c284af8e281d9d5657e55b3edb7f7c673fc747)

Bugfix: add a sync call to i3bar to confirm reparents before exiting
(upstream git commit 4699c714b33afb1c264f3d19911b880267165b94)

Bugfix: don't set focus in con_set_layout() on invisible workspaces
(upstream git commit fc886315342b3a2292ad0c08394b6bb452663bb1)
@
text
@d1 4
a4 17
$OpenBSD: patch-src_commands_c,v 1.11 2014/07/11 15:49:58 dcoppa Exp $

commit 679a5de8cfb9211afb1a1dd882e53bd672084754
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Tue Jul 15 10:15:04 2014 +0200

Bugfix: properly restore workspace containers

commit c159fc4197ad06d603ba404add501ac02d76c64f
Author: Michael Stapelberg <michael@@stapelberg.de>
Date:   Fri Jun 27 09:04:51 2014 +0200

Bugfix: create the directory for storing the restart state

--- src/commands.c.orig	Sun Jun 15 19:12:43 2014
+++ src/commands.c	Mon Aug 18 08:25:05 2014
@@@@ -201,7 +201,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
a12 61
@@@@ -882,15 +882,27 @@@@ void cmd_nop(I3_CMD, char *comment) {
  */
 void cmd_append_layout(I3_CMD, char *path) {
     LOG("Appending layout \"%s\"\n", path);
+
+    json_content_t content = json_determine_content(path);
+    LOG("JSON content = %d\n", content);
+    if (content == JSON_CONTENT_UNKNOWN) {
+        ELOG("Could not determine the contents of \"%s\", not loading.\n", path);
+        ysuccess(false);
+        return;
+    }
+
     Con *parent = focused;
-    /* We need to append the layout to a split container, since a leaf
-     * container must not have any children (by definition).
-     * Note that we explicitly check for workspaces, since they are okay for
-     * this purpose, but con_accepts_window() returns false for workspaces. */
-    while (parent->type != CT_WORKSPACE && !con_accepts_window(parent))
-        parent = parent->parent;
-    DLOG("Appending to parent=%p instead of focused=%p\n",
-         parent, focused);
+    if (content == JSON_CONTENT_WORKSPACE) {
+        parent = output_get_content(con_get_output(parent));
+    } else {
+        /* We need to append the layout to a split container, since a leaf
+         * container must not have any children (by definition).
+         * Note that we explicitly check for workspaces, since they are okay for
+         * this purpose, but con_accepts_window() returns false for workspaces. */
+        while (parent->type != CT_WORKSPACE && !con_accepts_window(parent))
+            parent = parent->parent;
+    }
+    DLOG("Appending to parent=%p instead of focused=%p\n", parent, focused);
     char *errormsg = NULL;
     tree_append_json(parent, path, &errormsg);
     if (errormsg != NULL) {
@@@@ -914,6 +926,9 @@@@ void cmd_append_layout(I3_CMD, char *path) {
 
     restore_open_placeholder_windows(parent);
 
+    if (content == JSON_CONTENT_WORKSPACE)
+        ipc_send_event("workspace", I3_IPC_EVENT_WORKSPACE, "{\"change\":\"restored\"}");
+
     cmd_output->needs_tree_render = true;
 }
 
@@@@ -1685,13 +1700,10 @@@@ void cmd_reload(I3_CMD) {
 void cmd_restart(I3_CMD) {
     LOG("restarting i3\n");
     ipc_shutdown();
+    unlink(config.ipc_socket_path);
     /* We need to call this manually since atexit handlers donâ€™t get called
      * when exec()ing */
     purge_zerobyte_logfile();
-    /* The unlink call is intentionally after the purge_zerobyte_logfile() so
-     * that the latter does not remove the directory yet. We need to store the
-     * restart layout state in there. */
-    unlink(config.ipc_socket_path);
     i3_restart(false);
 
     // XXX: default reply for now, make this a better reply
@


1.11
log
@
Update to i3-4.8 plus fixes.

Initial diff by Theo Buehler <theo AT math DOT ethz DOT ch>
@
text
@d1 7
a7 1
$OpenBSD: patch-src_commands_c,v 1.10 2014/03/18 12:12:05 dcoppa Exp $
d16 1
a16 1
+++ src/commands.c	Fri Jul 11 16:39:36 2014
d26 47
a72 1
@@@@ -1685,13 +1685,10 @@@@ void cmd_reload(I3_CMD) {
@


1.10
log
@
Bugfix: don't try to resize docks by command

cmd_resize does not implement a method to resize dock clients.
A command like `[instance=".*"] resize grow width 160 px or 16 ppt`
when a dock client matched would crash i3.

(upstream git commit a6a6c9b6d9d47ef1ccbff5ac5d4fe17f9666f29f)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.9 2014/01/11 16:04:43 dcoppa Exp $
d3 3
a5 3
commit a6a6c9b6d9d47ef1ccbff5ac5d4fe17f9666f29f
Author: Tony Crisci <tony@@dubstepdish.com>
Date:   Fri Mar 14 22:59:08 2014 -0400
d7 1
a7 1
Bugfix: don't try to resize docks by command
d9 3
a11 8
cmd_resize does not implement a method to resize dock clients.

A command like `[instance=".*"] resize grow width 160 px or 16 ppt`
when a dock client matched would crash i3.

--- src/commands.c.orig	Thu Jan 23 22:52:24 2014
+++ src/commands.c	Tue Mar 18 13:05:59 2014
@@@@ -194,7 +194,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
d20 13
a32 1
@@@@ -779,6 +779,12 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
d34 1
a34 11
     owindow *current;
     TAILQ_FOREACH(current, &owindows, owindows) {
+        /* Don't handle dock windows (issue #1201) */
+        if (current->con->window->dock) {
+            DLOG("This is a dock window. Not resizing (con = %p)\n)", current->con);
+            continue;
+        }
+
         Con *floating_con;
         if ((floating_con = con_inside_floating(current->con))) {
             cmd_resize_floating(current_match, cmd_output, way, direction, floating_con, px);
@


1.9
log
@Update to i3-4.7
@
text
@d1 15
a15 3
$OpenBSD: patch-src_commands_c,v 1.8 2013/08/13 10:01:56 dcoppa Exp $
--- src/commands.c.orig	Sun Dec 22 21:12:41 2013
+++ src/commands.c	Fri Jan 10 16:31:33 2014
d25 13
@


1.8
log
@Update to i3-4.6

ok tobiasu@@, abieber@@
@
text
@d1 4
a4 11
$OpenBSD: patch-src_commands_c,v 1.7 2013/05/17 10:21:42 dcoppa Exp $

commit 69d7adcf499aa716586e4b920dfd60e10f9233b0
Author: Franck Michea <franck.michea@@gmail.com>
Date:   Mon Jul 29 22:45:27 2013 +0200

Add missing return after error reporting.

--- src/commands.c.orig	Wed Aug  7 20:50:24 2013
+++ src/commands.c	Mon Aug 12 16:00:47 2013
@@@@ -175,7 +175,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
a12 8
@@@@ -1796,6 +1796,7 @@@@ void cmd_move_window_to_center(I3_CMD, char *method) {
         ystr("error");
         ystr("Cannot change position. The window/container is not floating.");
         y(map_close);
+        return;
     }
 
     if (strcmp(method, "absolute") == 0) {
@


1.7
log
@Bunch of fixes from upstream:

Fix crash when not having tray_output configured

libi3: mark IPC fd CLOEXEC

Ensure that resize will take place even if pixel is smaller than
size increments

Fix floating window size with hide_edge_borders

render_con: fix height rounding in aspect ratio computation

tabbed: floor(), put extra pixels into the last tab
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.6 2013/05/16 18:42:30 dcoppa Exp $
d3 3
a5 3
commit a93e1e5c59573887f9cc49c1c40bf28b92e567b2
Author: oblique <psyberbits@@gmail.com>
Date:   Mon Apr 15 21:30:22 2013 +0300
d7 1
a7 2
Ensure that resize will take place even if pixel is smaller than
size increments.
d9 3
a11 3
--- src/commands.c.orig	Mon Mar 18 22:43:36 2013
+++ src/commands.c	Fri May 17 11:46:30 2013
@@@@ -174,7 +174,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
d20 6
a25 21
@@@@ -569,6 +569,23 @@@@ void cmd_move_con_to_workspace_number(I3_CMD, char *wh
 static void cmd_resize_floating(I3_CMD, char *way, char *direction, Con *floating_con, int px) {
     LOG("floating resize\n");
     Rect old_rect = floating_con->rect;
+    Con *focused_con = con_descend_focused(floating_con);
+
+    /* ensure that resize will take place even if pixel increment is smaller than
+     * height increment or width increment.
+     * fixes #1011 */
+    if (strcmp(direction, "up") == 0 || strcmp(direction, "down") == 0 ||
+        strcmp(direction, "height") == 0) {
+        if (px < 0)
+            px = (-px < focused_con->height_increment) ? -focused_con->height_increment : px;
+        else
+            px = (px < focused_con->height_increment) ? focused_con->height_increment : px;
+    } else if (strcmp(direction, "left") == 0 || strcmp(direction, "right") == 0) {
+        if (px < 0)
+            px = (-px < focused_con->width_increment) ? -focused_con->width_increment : px;
+        else
+            px = (px < focused_con->width_increment) ? focused_con->width_increment : px;
+    }
d27 1
a27 2
     if (strcmp(direction, "up") == 0) {
         floating_con->rect.height += px;
@


1.6
log
@Update to i3-4.5.1

ok jasper@@, abieber@@
@
text
@d1 9
a9 1
$OpenBSD: patch-src_commands_c,v 1.5 2012/12/13 12:10:13 dcoppa Exp $
d11 1
a11 1
+++ src/commands.c	Mon May 13 08:27:23 2013
d21 24
@


1.5
log
@Update to i3-4.4
@
text
@d1 4
a4 4
$OpenBSD: patch-src_commands_c,v 1.4 2012/09/21 17:16:14 dcoppa Exp $
--- src/commands.c.orig	Wed Dec 12 00:08:17 2012
+++ src/commands.c	Thu Dec 13 09:45:54 2012
@@@@ -182,7 +182,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
@


1.4
log
@Update to i3-4.3

OK jasper@@
@
text
@d1 4
a4 4
$OpenBSD: patch-src_commands_c,v 1.3 2012/08/27 09:49:18 dcoppa Exp $
--- src/commands.c.orig	Thu Sep 20 14:38:12 2012
+++ src/commands.c	Thu Sep 20 14:39:06 2012
@@@@ -160,7 +160,7 @@@@ void cmd_MIGRATION_start_nagbar(void) {
@


1.3
log
@Fix resizing floating windows by height
(upstream git commit 1089b0b201cef30fbfd03620339f5e8a166feded)
@
text
@d1 12
a12 258
$OpenBSD: patch-src_commands_c,v 1.2 2012/08/08 14:33:25 dcoppa Exp $

From b88ab981fd0a5725ed886a9f9788a5b1e721534c Mon Sep 17 00:00:00 2001
From: Ondrej Grover <ondrej.grover@@gmail.com>
Date: Wed, 02 May 2012 14:05:27 +0000
Subject: bugfix: less differentiation between named and numbered workspaces

calling workspace by number now also checks for switching back and forth
and creates a new workspace if no workspace starting with that number is
found

also removed the obsolete tree_render() in favor of setting
cmd_output->needs_tree_render to true

From 1089b0b201cef30fbfd03620339f5e8a166feded Mon Sep 17 00:00:00 2001
From: Joel Stemmer <stemmertech@@gmail.com>
Date: Sat, 18 Aug 2012 13:25:00 +0000
Subject: fix resizing floating windows by height

From 83dc5d5cb6c71d365cd79b376fcb073e9120144d Mon Sep 17 00:00:00 2001
From: Michael Stapelberg <michael@@stapelberg.de>
Date: Sun, 22 Jul 2012 19:25:38 +0000
Subject: Bugfix: Fix duplicate return value for 'resize' command

From 4eab046e8fa40535d1a2ad80533915983ef0ee7e Mon Sep 17 00:00:00 2001
From: Fernando Tarla Cardoso Lemos <fernandotcl@@gmail.com>
Date: Sat, 21 Apr 2012 19:34:25 +0000
Subject: Allow focus w/ target when in fs in some cases.

If the target is in a different workspace, there's no reason why
we wouldn't allow the user to focus it. We already allow this when
focusing a workspace, for example.

--- src/commands.c.orig	Wed Apr 25 23:21:25 2012
+++ src/commands.c	Mon Aug 27 11:43:14 2012
@@@@ -65,6 +65,28 @@@@ static Output *get_output_from_string(Output *current_
     return output;
 }
 
+/*
+ * Checks whether we switched to a new workspace and returns false in that case,
+ * signaling that further workspace switching should be done by the calling function
+ * If not, calls workspace_back_and_forth() if workspace_auto_back_and_forth is set
+ * and return true, signaling that no further workspace switching should occur in the calling function.
+ *
+ */
+static bool maybe_back_and_forth(struct CommandResult *cmd_output, char *name) {
+    Con *ws = con_get_workspace(focused);
+
+    /* If we switched to a different workspace, do nothing */
+    if (strcmp(ws->name, name) != 0)
+        return false;
+
+    DLOG("This workspace is already focused.\n");
+    if (config.workspace_auto_back_and_forth) {
+        workspace_back_and_forth();
+        cmd_output->needs_tree_render = true;
+    }
+    return true;
+}
+
 // This code is commented out because we might recycle it for popping up error
 // messages on parser errors.
 #if 0
@@@@ -448,7 +470,7 @@@@ static void cmd_resize_floating(I3_CMD, char *way, cha
     if (strcmp(direction, "up") == 0) {
         floating_con->rect.y -= px;
         floating_con->rect.height += px;
-    } else if (strcmp(direction, "down") == 0) {
+    } else if (strcmp(direction, "down") == 0 || strcmp(direction, "height") == 0) {
         floating_con->rect.height += px;
     } else if (strcmp(direction, "left") == 0) {
         floating_con->rect.x -= px;
@@@@ -458,7 +480,7 @@@@ static void cmd_resize_floating(I3_CMD, char *way, cha
     }
 }
 
-static void cmd_resize_tiling_direction(I3_CMD, char *way, char *direction, int ppt) {
+static bool cmd_resize_tiling_direction(I3_CMD, char *way, char *direction, int ppt) {
     LOG("tiling resize\n");
     /* get the appropriate current container (skip stacked/tabbed cons) */
     Con *current = focused;
@@@@ -491,7 +513,7 @@@@ static void cmd_resize_tiling_direction(I3_CMD, char *
         LOG("You cannot resize in that direction. Your focus is in a %s split container currently.\n",
             (orientation == HORIZ ? "horizontal" : "vertical"));
         cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
+        return false;
     }
 
     if (strcmp(direction, "up") == 0 || strcmp(direction, "left") == 0) {
@@@@ -502,7 +524,7 @@@@ static void cmd_resize_tiling_direction(I3_CMD, char *
     if (other == TAILQ_END(workspaces)) {
         LOG("No other container in this direction found, cannot resize.\n");
         cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
+        return false;
     }
     LOG("other->percent = %f\n", other->percent);
     LOG("current->percent before = %f\n", current->percent);
@@@@ -525,9 +547,11 @@@@ static void cmd_resize_tiling_direction(I3_CMD, char *
     } else {
         LOG("Not resizing, already at minimum size\n");
     }
+
+    return true;
 }
 
-static void cmd_resize_tiling_width_height(I3_CMD, char *way, char *direction, int ppt) {
+static bool cmd_resize_tiling_width_height(I3_CMD, char *way, char *direction, int ppt) {
     LOG("width/height resize\n");
     /* get the appropriate current container (skip stacked/tabbed cons) */
     Con *current = focused;
@@@@ -559,13 +583,13 @@@@ static void cmd_resize_tiling_width_height(I3_CMD, cha
         LOG("You cannot resize in that direction. Your focus is in a %s split container currently.\n",
             (orientation == HORIZ ? "horizontal" : "vertical"));
         cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
+        return false;
     }
 
     if (children == 1) {
         LOG("This is the only container, cannot resize.\n");
         cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
+        return false;
     }
 
     /* Ensure all the other children have a percentage set. */
@@@@ -588,13 +612,13 @@@@ static void cmd_resize_tiling_width_height(I3_CMD, cha
         if (!definitelyGreaterThan(child->percent - subtract_percent, 0.05, DBL_EPSILON)) {
             LOG("Not resizing, already at minimum size (child %p would end up with a size of %.f\n", child, child->percent - subtract_percent);
             cmd_output->json_output = sstrdup("{\"sucess\": false}");
-            return;
+            return false;
         }
     }
     if (!definitelyGreaterThan(new_current_percent, 0.05, DBL_EPSILON)) {
         LOG("Not resizing, already at minimum size\n");
         cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
+        return false;
     }
 
     current->percent += ((double)ppt / 100.0);
@@@@ -606,6 +630,8 @@@@ static void cmd_resize_tiling_width_height(I3_CMD, cha
         child->percent -= subtract_percent;
         LOG("child->percent after (%p) = %f\n", child, child->percent);
     }
+
+    return true;
 }
 
 /*
@@@@ -628,9 +654,13 @@@@ void cmd_resize(I3_CMD, char *way, char *direction, ch
         cmd_resize_floating(current_match, cmd_output, way, direction, floating_con, px);
     } else {
         if (strcmp(direction, "width") == 0 ||
-            strcmp(direction, "height") == 0)
-            cmd_resize_tiling_width_height(current_match, cmd_output, way, direction, ppt);
-        else cmd_resize_tiling_direction(current_match, cmd_output, way, direction, ppt);
+            strcmp(direction, "height") == 0) {
+            if (!cmd_resize_tiling_width_height(current_match, cmd_output, way, direction, ppt))
+                return;
+        } else {
+            if (!cmd_resize_tiling_direction(current_match, cmd_output, way, direction, ppt))
+                return;
+        }
     }
 
     cmd_output->needs_tree_render = true;
@@@@ -752,12 +782,19 @@@@ void cmd_workspace_number(I3_CMD, char *which) {
             child->num == parsed_num);
 
     if (!workspace) {
-        LOG("There is no workspace with number %d.\n", parsed_num);
+        LOG("There is no workspace with number %d, creating a new one.\n", parsed_num);
         cmd_output->json_output = sstrdup("{\"success\": false, "
                 "\"error\": \"No such workspace\"}");
+        /* terminate the which string after the endposition of the number */
+        *endptr = '\0';
+        if (maybe_back_and_forth(cmd_output, which))
+            return;
+        workspace_show_by_name(which);
+        cmd_output->needs_tree_render = true;
         return;
     }
-
+    if (maybe_back_and_forth(cmd_output, which))
+        return;
     workspace_show(workspace);
 
     cmd_output->needs_tree_render = true;
@@@@ -789,20 +826,8 @@@@ void cmd_workspace_name(I3_CMD, char *name) {
     }
 
     DLOG("should switch to workspace %s\n", name);
-
-    Con *ws = con_get_workspace(focused);
-
-    /* Check if the command wants to switch to the current workspace */
-    if (strcmp(ws->name, name) == 0) {
-        DLOG("This workspace is already focused.\n");
-        if (config.workspace_auto_back_and_forth) {
-            workspace_back_and_forth();
-            tree_render();
-        }
-        cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
-    }
-
+    if (maybe_back_and_forth(cmd_output, name))
+       return;
     workspace_show_by_name(name);
 
     cmd_output->needs_tree_render = true;
@@@@ -1196,16 +1221,7 @@@@ void cmd_focus_level(I3_CMD, char *level) {
  */
 void cmd_focus(I3_CMD) {
     DLOG("current_match = %p\n", current_match);
-    if (focused &&
-        focused->type != CT_WORKSPACE &&
-        focused->fullscreen_mode != CF_NONE) {
-        LOG("Cannot change focus while in fullscreen mode.\n");
-        cmd_output->json_output = sstrdup("{\"sucess\": false}");
-        return;
-    }
 
-    owindow *current;
-
     if (match_is_empty(current_match)) {
         ELOG("You have to specify which window/container should be focused.\n");
         ELOG("Example: [class=\"urxvt\" title=\"irssi\"] focus\n");
@@@@ -1217,12 +1233,24 @@@@ void cmd_focus(I3_CMD) {
     }
 
     int count = 0;
+    owindow *current;
     TAILQ_FOREACH(current, &owindows, owindows) {
         Con *ws = con_get_workspace(current->con);
         /* If no workspace could be found, this was a dock window.
          * Just skip it, you cannot focus dock windows. */
         if (!ws)
             continue;
+
+        /* Don't allow the focus switch if the focused and current
+         * containers are in the same workspace. */
+        if (focused &&
+            focused->type != CT_WORKSPACE &&
+            focused->fullscreen_mode != CF_NONE &&
+            con_get_workspace(focused) == ws) {
+            LOG("Cannot change focus while in fullscreen mode (same workspace).\n");
+            cmd_output->json_output = sstrdup("{\"success\": false}");
+            return;
+        }
 
         /* If the container is not on the current workspace,
          * workspace_show() will switch to a different workspace and (if
@


1.2
log
@
Bugfix: fix duplicate return value for 'resize' command
(upstream git commit 83dc5d5cb6c71d365cd79b376fcb073e9120144d)

floating_fix_coordinates: properly deal with negative positions
(upstream git commit 74510c59c7db676f1228d054791e1e37456f6660)

randr: fix a crash when the current output cannot be determined
(upstream git commit e867fd810516431f06af0799c90c0f833bf61219)

randr: properly fix floating coordinates when disabling outputs
(upstream git commit d57d51da6d040e8572159332224615f232c4645a)
@
text
@d1 1
a1 1
$OpenBSD: patch-src_commands_c,v 1.1 2012/05/28 13:37:50 dcoppa Exp $
d15 5
d35 1
a35 1
+++ src/commands.c	Wed Aug  8 16:02:40 2012
d65 9
@


1.1
log
@
Bugfix: less differentiation between named and numbered workspaces
(upstream git commit b88ab981fd0a5725ed886a9f9788a5b1e721534c)

Bugfix: fix stray workspaces "number 1" being created when having
workspace number 1 in your config (upstream git commit
ec4e6d1cdf5b76c79da2879635e4094e25a01f3d)

Fix for i3bar: don't wrap when changing workspaces by mouse wheel
scrolling (upstream git commit 4f93e0587a849de00a1f50bfcd48a549009178c0)
@
text
@d1 1
a1 1
$OpenBSD$
d15 5
d30 1
a30 1
+++ src/commands.c	Mon May 28 13:50:28 2012
d60 99
a158 1
@@@@ -752,12 +774,19 @@@@ void cmd_workspace_number(I3_CMD, char *which) {
d180 1
a180 1
@@@@ -789,20 +818,8 @@@@ void cmd_workspace_name(I3_CMD, char *name) {
d203 1
a203 1
@@@@ -1196,16 +1213,7 @@@@ void cmd_focus_level(I3_CMD, char *level) {
d220 1
a220 1
@@@@ -1217,12 +1225,24 @@@@ void cmd_focus(I3_CMD) {
@

