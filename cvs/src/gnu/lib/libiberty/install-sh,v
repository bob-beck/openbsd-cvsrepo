head	1.4;
access;
symbols
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.34
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.30
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.4.0.32
	OPENBSD_5_8_BASE:1.4
	OPENBSD_5_7:1.4.0.24
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.4.0.28
	OPENBSD_5_6_BASE:1.4
	OPENBSD_5_5:1.4.0.26
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.22
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.4.0.20
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.18
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.16
	OPENBSD_5_0:1.4.0.14
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.12
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.10
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.6
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.8
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.4
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	BINUTILS_2_17_1:1.1.1.4
	OPENBSD_4_3:1.3.0.18
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.16
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.14
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.12
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.10
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.8
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.6
	OPENBSD_3_7_BASE:1.3
	gcc-3_3_5:1.1.1.3
	OPENBSD_3_6:1.3.0.4
	OPENBSD_3_6_BASE:1.3
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	binutils-2_14:1.1.1.2
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.4
date	2008.05.27.18.52.40;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.25.18.02.30;	author espie;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.25.21.06.18;	author espie;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.24.16.53.23;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.25.20.39.02;	author espie;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.25.17.52.54;	author espie;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.12.24.21.48.15;	author espie;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.05.27.18.46.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge OpenBSD specific changes:
- pexecute implementation replaced with the older gcc 2.95 implementation,
  as gcc 2.95's collect2 relies upon an implementation behaviour which has
  been lost in further libiberty updates.
- keep the old hash table interfaces, which are used by gcc 2.95.
- keep the OpenBSD replacement for the md5 interface.
- keep the OpenBSD strl{cat,cpy} and snprinft usage.

Bump libiberty minor version due to the addition of a few new symbols.
@
text
@#!/bin/sh
# install - install a program, script, or datafile

scriptversion=2005-05-14.22

# This originates from X11R5 (mit/util/scripts/install.sh), which was
# later released in X11R6 (xc/config/util/install.sh) with the
# following copyright and license.
#
# Copyright (C) 1994 X Consortium
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of the X Consortium shall not
# be used in advertising or otherwise to promote the sale, use or other deal-
# ings in this Software without prior written authorization from the X Consor-
# tium.
#
#
# FSF changes to this file are in the public domain.
#
# Calling this script install-sh is preferred over install.sh, to prevent
# `make' implicit rules from creating a file called install from it
# when there is no Makefile.
#
# This script is compatible with the BSD install script, but was written
# from scratch.  It can only install one file at a time, a restriction
# shared with many OS's install programs.

# set DOITPROG to echo to test this script

# Don't use :- since 4.3BSD and earlier shells don't like it.
doit="${DOITPROG-}"

# put in absolute paths if you don't have them in your path; or use env. vars.

mvprog="${MVPROG-mv}"
cpprog="${CPPROG-cp}"
chmodprog="${CHMODPROG-chmod}"
chownprog="${CHOWNPROG-chown}"
chgrpprog="${CHGRPPROG-chgrp}"
stripprog="${STRIPPROG-strip}"
rmprog="${RMPROG-rm}"
mkdirprog="${MKDIRPROG-mkdir}"

chmodcmd="$chmodprog 0755"
chowncmd=
chgrpcmd=
stripcmd=
rmcmd="$rmprog -f"
mvcmd="$mvprog"
src=
dst=
dir_arg=
dstarg=
no_target_directory=

usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
   or: $0 [OPTION]... SRCFILES... DIRECTORY
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...

In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.

Options:
-c         (ignored)
-d         create directories instead of installing files.
-g GROUP   $chgrpprog installed files to GROUP.
-m MODE    $chmodprog installed files to MODE.
-o USER    $chownprog installed files to USER.
-s         $stripprog installed files.
-t DIRECTORY  install into DIRECTORY.
-T         report an error if DSTFILE is a directory.
--help     display this help and exit.
--version  display version info and exit.

Environment variables override the default commands:
  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
"

while test -n "$1"; do
  case $1 in
    -c) shift
        continue;;

    -d) dir_arg=true
        shift
        continue;;

    -g) chgrpcmd="$chgrpprog $2"
        shift
        shift
        continue;;

    --help) echo "$usage"; exit $?;;

    -m) chmodcmd="$chmodprog $2"
        shift
        shift
        continue;;

    -o) chowncmd="$chownprog $2"
        shift
        shift
        continue;;

    -s) stripcmd=$stripprog
        shift
        continue;;

    -t) dstarg=$2
	shift
	shift
	continue;;

    -T) no_target_directory=true
	shift
	continue;;

    --version) echo "$0 $scriptversion"; exit $?;;

    *)  # When -d is used, all remaining arguments are directories to create.
	# When -t is used, the destination is already specified.
	test -n "$dir_arg$dstarg" && break
        # Otherwise, the last argument is the destination.  Remove it from $@@.
	for arg
	do
          if test -n "$dstarg"; then
	    # $@@ is not empty: it contains at least $arg.
	    set fnord "$@@" "$dstarg"
	    shift # fnord
	  fi
	  shift # arg
	  dstarg=$arg
	done
	break;;
  esac
done

if test -z "$1"; then
  if test -z "$dir_arg"; then
    echo "$0: no input file specified." >&2
    exit 1
  fi
  # It's OK to call `install-sh -d' without argument.
  # This can happen when creating conditional directories.
  exit 0
fi

for src
do
  # Protect names starting with `-'.
  case $src in
    -*) src=./$src ;;
  esac

  if test -n "$dir_arg"; then
    dst=$src
    src=

    if test -d "$dst"; then
      mkdircmd=:
      chmodcmd=
    else
      mkdircmd=$mkdirprog
    fi
  else
    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
    # might cause directories to be created, which would be especially bad
    # if $src (and thus $dsttmp) contains '*'.
    if test ! -f "$src" && test ! -d "$src"; then
      echo "$0: $src does not exist." >&2
      exit 1
    fi

    if test -z "$dstarg"; then
      echo "$0: no destination specified." >&2
      exit 1
    fi

    dst=$dstarg
    # Protect names starting with `-'.
    case $dst in
      -*) dst=./$dst ;;
    esac

    # If destination is a directory, append the input filename; won't work
    # if double slashes aren't ignored.
    if test -d "$dst"; then
      if test -n "$no_target_directory"; then
	echo "$0: $dstarg: Is a directory" >&2
	exit 1
      fi
      dst=$dst/`basename "$src"`
    fi
  fi

  # This sed command emulates the dirname command.
  dstdir=`echo "$dst" | sed -e 's,/*$,,;s,[^/]*$,,;s,/*$,,;s,^$,.,'`

  # Make sure that the destination directory exists.

  # Skip lots of stat calls in the usual case.
  if test ! -d "$dstdir"; then
    defaultIFS='
	 '
    IFS="${IFS-$defaultIFS}"

    oIFS=$IFS
    # Some sh's can't handle IFS=/ for some reason.
    IFS='%'
    set x `echo "$dstdir" | sed -e 's@@/@@%@@g' -e 's@@^%@@/@@'`
    shift
    IFS=$oIFS

    pathcomp=

    while test $# -ne 0 ; do
      pathcomp=$pathcomp$1
      shift
      if test ! -d "$pathcomp"; then
        $mkdirprog "$pathcomp"
	# mkdir can fail with a `File exist' error in case several
	# install-sh are creating the directory concurrently.  This
	# is OK.
	test -d "$pathcomp" || exit
      fi
      pathcomp=$pathcomp/
    done
  fi

  if test -n "$dir_arg"; then
    $doit $mkdircmd "$dst" \
      && { test -z "$chowncmd" || $doit $chowncmd "$dst"; } \
      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } \
      && { test -z "$stripcmd" || $doit $stripcmd "$dst"; } \
      && { test -z "$chmodcmd" || $doit $chmodcmd "$dst"; }

  else
    dstfile=`basename "$dst"`

    # Make a couple of temp file names in the proper directory.
    dsttmp=$dstdir/_inst.$$_
    rmtmp=$dstdir/_rm.$$_

    # Trap to clean up those temp files at exit.
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
    trap '(exit $?); exit' 1 2 13 15

    # Copy the file name to the temp name.
    $doit $cpprog "$src" "$dsttmp" &&

    # and set any options; do chmod last to preserve setuid bits.
    #
    # If any of these fail, we abort the whole thing.  If we want to
    # ignore errors from any of these, just make sure not to ignore
    # errors from the above "$doit $cpprog $src $dsttmp" command.
    #
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } \
      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } \
      && { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } \
      && { test -z "$chmodcmd" || $doit $chmodcmd "$dsttmp"; } &&

    # Now rename the file to the real destination.
    { $doit $mvcmd -f "$dsttmp" "$dstdir/$dstfile" 2>/dev/null \
      || {
	   # The rename failed, perhaps because mv can't rename something else
	   # to itself, or perhaps because mv is so ancient that it does not
	   # support -f.

	   # Now remove or move aside any old file at destination location.
	   # We try this two ways since rm can't unlink itself on some
	   # systems and the destination file might be busy for other
	   # reasons.  In this case, the final cleanup might fail but the new
	   # file should still install successfully.
	   {
	     if test -f "$dstdir/$dstfile"; then
	       $doit $rmcmd -f "$dstdir/$dstfile" 2>/dev/null \
	       || $doit $mvcmd -f "$dstdir/$dstfile" "$rmtmp" 2>/dev/null \
	       || {
		 echo "$0: cannot unlink or rename $dstdir/$dstfile" >&2
		 (exit 1); exit 1
	       }
	     else
	       :
	     fi
	   } &&

	   # Now rename the file to the real destination.
	   $doit $mvcmd "$dsttmp" "$dstdir/$dstfile"
	 }
    }
  fi || { (exit 1); exit 1; }
done

# The final little trick to "correctly" pass the exit status to the exit trap.
{
  (exit 0); exit 0
}

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-end: "$"
# End:
@


1.3
log
@Automatic merge
@
text
@d2 19
d22 11
a32 2
# install - install a program, script, or datafile
# This comes from X11R5 (mit/util/scripts/install.sh).
a33 1
# Copyright 1991 by the Massachusetts Institute of Technology
d35 1
a35 9
# Permission to use, copy, modify, distribute, and sell this software and its
# documentation for any purpose is hereby granted without fee, provided that
# the above copyright notice appear in all copies and that both that
# copyright notice and this permission notice appear in supporting
# documentation, and that the name of M.I.T. not be used in advertising or
# publicity pertaining to distribution of the software without specific,
# written prior permission.  M.I.T. makes no representations about the
# suitability of this software for any purpose.  It is provided "as is"
# without express or implied warranty.
a44 1

a49 1

a60 3
transformbasename=""
transform_arg=""
instcmd="$mvprog"
d62 3
a64 3
chowncmd=""
chgrpcmd=""
stripcmd=""
d67 60
a126 53
src=""
dst=""
dir_arg=""

while [ x"$1" != x ]; do
    case $1 in
	-c) instcmd="$cpprog"
	    shift
	    continue;;

	-d) dir_arg=true
	    shift
	    continue;;

	-m) chmodcmd="$chmodprog $2"
	    shift
	    shift
	    continue;;

	-o) chowncmd="$chownprog $2"
	    shift
	    shift
	    continue;;

	-g) chgrpcmd="$chgrpprog $2"
	    shift
	    shift
	    continue;;

	-s) stripcmd="$stripprog"
	    shift
	    continue;;

	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
	    shift
	    continue;;

	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
	    shift
	    continue;;

	*)  if [ x"$src" = x ]
	    then
		src=$1
	    else
		# this colon is to work around a 386BSD /bin/sh bug
		:
		dst=$1
	    fi
	    shift
	    continue;;
    esac
done
d128 4
a131 68
if [ x"$src" = x ]
then
	echo "install:	no input file specified"
	exit 1
else
	true
fi

if [ x"$dir_arg" != x ]; then
	dst=$src
	src=""
	
	if [ -d $dst ]; then
		instcmd=:
		chmodcmd=""
	else
		instcmd=mkdir
	fi
else

# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
# might cause directories to be created, which would be especially bad 
# if $src (and thus $dsttmp) contains '*'.

	if [ -f $src -o -d $src ]
	then
		true
	else
		echo "install:  $src does not exist"
		exit 1
	fi
	
	if [ x"$dst" = x ]
	then
		echo "install:	no destination specified"
		exit 1
	else
		true
	fi

# If destination is a directory, append the input filename; if your system
# does not like double slashes in filenames, you may need to add some logic

	if [ -d $dst ]
	then
		dst="$dst"/`basename $src`
	else
		true
	fi
fi

## this sed command emulates the dirname command
dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`

# Make sure that the destination directory exists.
#  this part is taken from Noah Friedman's mkinstalldirs script

# Skip lots of stat calls in the usual case.
if [ ! -d "$dstdir" ]; then
defaultIFS='	
'
IFS="${IFS-${defaultIFS}}"

oIFS="${IFS}"
# Some sh's can't handle IFS=/ for some reason.
IFS='%'
set - `echo ${dstdir} | sed -e 's@@/@@%@@g' -e 's@@^%@@/@@'`
IFS="${oIFS}"
d133 1
a133 4
pathcomp=''

while [ $# -ne 0 ] ; do
	pathcomp="${pathcomp}${1}"
d135 1
d137 1
a137 6
	if [ ! -d "${pathcomp}" ] ;
        then
		$mkdirprog "${pathcomp}"
	else
		true
	fi
d139 16
a154 1
	pathcomp="${pathcomp}/"
d156 9
d167 36
a202 56
if [ x"$dir_arg" != x ]
then
	$doit $instcmd $dst &&

	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
else

# If we're going to rename the final executable, determine the name now.

	if [ x"$transformarg" = x ] 
	then
		dstfile=`basename $dst`
	else
		dstfile=`basename $dst $transformbasename | 
			sed $transformarg`$transformbasename
	fi

# don't allow the sed command to completely eliminate the filename

	if [ x"$dstfile" = x ] 
	then
		dstfile=`basename $dst`
	else
		true
	fi

# Make a temp file name in the proper directory.

	dsttmp=$dstdir/#inst.$$#

# Move or copy the file name to the temp name

	$doit $instcmd $src $dsttmp &&

	trap "rm -f ${dsttmp}" 0 &&

# and set any options; do chmod last to preserve setuid bits

# If any of these fail, we abort the whole thing.  If we want to
# ignore errors from any of these, just make sure not to ignore
# errors from the above "$doit $instcmd $src $dsttmp" command.

	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&

# Now rename the file to the real destination.

	$doit $rmcmd -f $dstdir/$dstfile &&
	$doit $mvcmd $dsttmp $dstdir/$dstfile 

fi &&
d204 108
d313 11
a323 1
exit 0
@


1.2
log
@fix stupid cvs conflicts.
I think that cvs is a poor lonesome, depressive program.
The only way it has found of getting your attention is to throw
senseless conflicts that shouldn't exist in your way.
@
text
@d224 1
a224 1
	dsttmp=$dstdir/_inst.$$_
@


1.1
log
@Add build pieces
@
text
@d224 1
a224 1
	dsttmp=$dstdir/#inst.$$#
@


1.1.1.1
log
@Synch with gcc-3.3.2 version
@
text
@d224 1
a224 1
	dsttmp=$dstdir/_inst.$$_
@


1.1.1.2
log
@Update to libiberty from binutils-2.14
@
text
@d224 1
a224 1
	dsttmp=$dstdir/#inst.$$#
@


1.1.1.3
log
@update to gcc 3.3.5
@
text
@d224 1
a224 1
	dsttmp=$dstdir/_inst.$$_
@


1.1.1.4
log
@Update libiberty to the version found in binutils 2.17.1 (which still
identifies itself as the gcc 3 version...)
@
text
@d2 1
d4 1
a4 18

scriptversion=2005-05-14.22

# This originates from X11R5 (mit/util/scripts/install.sh), which was
# later released in X11R6 (xc/config/util/install.sh) with the
# following copyright and license.
#
# Copyright (C) 1994 X Consortium
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
d6 1
a6 6
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
d8 9
a16 7
# Except as contained in this notice, the name of the X Consortium shall not
# be used in advertising or otherwise to promote the sale, use or other deal-
# ings in this Software without prior written authorization from the X Consor-
# tium.
#
#
# FSF changes to this file are in the public domain.
d26 1
d32 1
d44 3
d48 3
a50 3
chowncmd=
chgrpcmd=
stripcmd=
d53 110
a162 60
src=
dst=
dir_arg=
dstarg=
no_target_directory=

usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
   or: $0 [OPTION]... SRCFILES... DIRECTORY
   or: $0 [OPTION]... -t DIRECTORY SRCFILES...
   or: $0 [OPTION]... -d DIRECTORIES...

In the 1st form, copy SRCFILE to DSTFILE.
In the 2nd and 3rd, copy all SRCFILES to DIRECTORY.
In the 4th, create DIRECTORIES.

Options:
-c         (ignored)
-d         create directories instead of installing files.
-g GROUP   $chgrpprog installed files to GROUP.
-m MODE    $chmodprog installed files to MODE.
-o USER    $chownprog installed files to USER.
-s         $stripprog installed files.
-t DIRECTORY  install into DIRECTORY.
-T         report an error if DSTFILE is a directory.
--help     display this help and exit.
--version  display version info and exit.

Environment variables override the default commands:
  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
"

while test -n "$1"; do
  case $1 in
    -c) shift
        continue;;

    -d) dir_arg=true
        shift
        continue;;

    -g) chgrpcmd="$chgrpprog $2"
        shift
        shift
        continue;;

    --help) echo "$usage"; exit $?;;

    -m) chmodcmd="$chmodprog $2"
        shift
        shift
        continue;;

    -o) chowncmd="$chownprog $2"
        shift
        shift
        continue;;

    -s) stripcmd=$stripprog
        shift
        continue;;
d164 13
a176 4
    -t) dstarg=$2
	shift
	shift
	continue;;
d178 2
a179 1
    -T) no_target_directory=true
a180 1
	continue;;
d182 6
a187 1
    --version) echo "$0 $scriptversion"; exit $?;;
d189 1
a189 16
    *)  # When -d is used, all remaining arguments are directories to create.
	# When -t is used, the destination is already specified.
	test -n "$dir_arg$dstarg" && break
        # Otherwise, the last argument is the destination.  Remove it from $@@.
	for arg
	do
          if test -n "$dstarg"; then
	    # $@@ is not empty: it contains at least $arg.
	    set fnord "$@@" "$dstarg"
	    shift # fnord
	  fi
	  shift # arg
	  dstarg=$arg
	done
	break;;
  esac
d191 36
d228 19
a246 9
if test -z "$1"; then
  if test -z "$dir_arg"; then
    echo "$0: no input file specified." >&2
    exit 1
  fi
  # It's OK to call `install-sh -d' without argument.
  # This can happen when creating conditional directories.
  exit 0
fi
d248 1
a248 36
for src
do
  # Protect names starting with `-'.
  case $src in
    -*) src=./$src ;;
  esac

  if test -n "$dir_arg"; then
    dst=$src
    src=

    if test -d "$dst"; then
      mkdircmd=:
      chmodcmd=
    else
      mkdircmd=$mkdirprog
    fi
  else
    # Waiting for this to be detected by the "$cpprog $src $dsttmp" command
    # might cause directories to be created, which would be especially bad
    # if $src (and thus $dsttmp) contains '*'.
    if test ! -f "$src" && test ! -d "$src"; then
      echo "$0: $src does not exist." >&2
      exit 1
    fi

    if test -z "$dstarg"; then
      echo "$0: no destination specified." >&2
      exit 1
    fi

    dst=$dstarg
    # Protect names starting with `-'.
    case $dst in
      -*) dst=./$dst ;;
    esac
a249 108
    # If destination is a directory, append the input filename; won't work
    # if double slashes aren't ignored.
    if test -d "$dst"; then
      if test -n "$no_target_directory"; then
	echo "$0: $dstarg: Is a directory" >&2
	exit 1
      fi
      dst=$dst/`basename "$src"`
    fi
  fi

  # This sed command emulates the dirname command.
  dstdir=`echo "$dst" | sed -e 's,/*$,,;s,[^/]*$,,;s,/*$,,;s,^$,.,'`

  # Make sure that the destination directory exists.

  # Skip lots of stat calls in the usual case.
  if test ! -d "$dstdir"; then
    defaultIFS='
	 '
    IFS="${IFS-$defaultIFS}"

    oIFS=$IFS
    # Some sh's can't handle IFS=/ for some reason.
    IFS='%'
    set x `echo "$dstdir" | sed -e 's@@/@@%@@g' -e 's@@^%@@/@@'`
    shift
    IFS=$oIFS

    pathcomp=

    while test $# -ne 0 ; do
      pathcomp=$pathcomp$1
      shift
      if test ! -d "$pathcomp"; then
        $mkdirprog "$pathcomp"
	# mkdir can fail with a `File exist' error in case several
	# install-sh are creating the directory concurrently.  This
	# is OK.
	test -d "$pathcomp" || exit
      fi
      pathcomp=$pathcomp/
    done
  fi

  if test -n "$dir_arg"; then
    $doit $mkdircmd "$dst" \
      && { test -z "$chowncmd" || $doit $chowncmd "$dst"; } \
      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dst"; } \
      && { test -z "$stripcmd" || $doit $stripcmd "$dst"; } \
      && { test -z "$chmodcmd" || $doit $chmodcmd "$dst"; }

  else
    dstfile=`basename "$dst"`

    # Make a couple of temp file names in the proper directory.
    dsttmp=$dstdir/_inst.$$_
    rmtmp=$dstdir/_rm.$$_

    # Trap to clean up those temp files at exit.
    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
    trap '(exit $?); exit' 1 2 13 15

    # Copy the file name to the temp name.
    $doit $cpprog "$src" "$dsttmp" &&

    # and set any options; do chmod last to preserve setuid bits.
    #
    # If any of these fail, we abort the whole thing.  If we want to
    # ignore errors from any of these, just make sure not to ignore
    # errors from the above "$doit $cpprog $src $dsttmp" command.
    #
    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } \
      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } \
      && { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } \
      && { test -z "$chmodcmd" || $doit $chmodcmd "$dsttmp"; } &&

    # Now rename the file to the real destination.
    { $doit $mvcmd -f "$dsttmp" "$dstdir/$dstfile" 2>/dev/null \
      || {
	   # The rename failed, perhaps because mv can't rename something else
	   # to itself, or perhaps because mv is so ancient that it does not
	   # support -f.

	   # Now remove or move aside any old file at destination location.
	   # We try this two ways since rm can't unlink itself on some
	   # systems and the destination file might be busy for other
	   # reasons.  In this case, the final cleanup might fail but the new
	   # file should still install successfully.
	   {
	     if test -f "$dstdir/$dstfile"; then
	       $doit $rmcmd -f "$dstdir/$dstfile" 2>/dev/null \
	       || $doit $mvcmd -f "$dstdir/$dstfile" "$rmtmp" 2>/dev/null \
	       || {
		 echo "$0: cannot unlink or rename $dstdir/$dstfile" >&2
		 (exit 1); exit 1
	       }
	     else
	       :
	     fi
	   } &&

	   # Now rename the file to the real destination.
	   $doit $mvcmd "$dsttmp" "$dstdir/$dstfile"
	 }
    }
  fi || { (exit 1); exit 1; }
done
d251 1
a251 11
# The final little trick to "correctly" pass the exit status to the exit trap.
{
  (exit 0); exit 0
}

# Local variables:
# eval: (add-hook 'write-file-hooks 'time-stamp)
# time-stamp-start: "scriptversion="
# time-stamp-format: "%:y-%02m-%02d.%02H"
# time-stamp-end: "$"
# End:
@


