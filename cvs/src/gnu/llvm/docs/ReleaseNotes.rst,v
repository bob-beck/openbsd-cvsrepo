head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.4.0.2
	OPENBSD_6_1_BASE:1.1.1.4
	LLVM_4_0_0:1.1.1.4
	LLVM_4_0_0_RC1:1.1.1.3
	LLVM_3_9_1:1.1.1.2
	LLVM_3_8_1:1.1.1.1
	LLVM:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches
	1.1.1.1;
next	;
commitid	piLU3CHugy63NlaI;

1.1.1.1
date	2016.09.03.22.46.59;	author pascal;	state Exp;
branches;
next	1.1.1.2;
commitid	piLU3CHugy63NlaI;

1.1.1.2
date	2017.01.14.19.55.59;	author patrick;	state Exp;
branches;
next	1.1.1.3;
commitid	qMUxATnKgqN83Oct;

1.1.1.3
date	2017.01.24.08.33.22;	author patrick;	state Exp;
branches;
next	1.1.1.4;
commitid	so2WA7LCP6wbxtYl;

1.1.1.4
date	2017.03.14.08.08.04;	author patrick;	state Exp;
branches;
next	;
commitid	aUi5NxOzBSLCN5eN;


desc
@@


1.1
log
@Initial revision
@
text
@======================
LLVM 3.8 Release Notes
======================

.. contents::
    :local:


Introduction
============

This document contains the release notes for the LLVM Compiler Infrastructure,
release 3.8.  Here we describe the status of LLVM, including major improvements
from the previous release, improvements in various subprojects of LLVM, and
some of the current users of the code.  All LLVM releases may be downloaded
from the `LLVM releases web site <http://llvm.org/releases/>`_.

For more information about LLVM, including information about the latest
release, please check out the `main LLVM web site <http://llvm.org/>`_.  If you
have questions or comments, the `LLVM Developer's Mailing List
<http://lists.llvm.org/mailman/listinfo/llvm-dev>`_ is a good place to send
them.

Non-comprehensive list of changes in this release
=================================================
* With this release, the minimum Windows version required for running LLVM is
  Windows 7. Earlier versions, including Windows Vista and XP are no longer
  supported.

* With this release, the autoconf build system is deprecated. It will be removed
  in the 3.9 release. Please migrate to using CMake. For more information see:
  `Building LLVM with CMake <CMake.html>`_

* We have documented our C API stability guarantees for both development and
  release branches, as well as documented how to extend the C API. Please see
  the `developer documentation <DeveloperPolicy.html#c-api-changes>`_ for more
  information.

* The C API function ``LLVMLinkModules`` is deprecated. It will be removed in the
  3.9 release. Please migrate to ``LLVMLinkModules2``. Unlike the old function the
  new one

   * Doesn't take an unused parameter.
   * Destroys the source instead of only damaging it.
   * Does not record a message. Use the diagnostic handler instead.

* The C API functions ``LLVMParseBitcode``, ``LLVMParseBitcodeInContext``,
  ``LLVMGetBitcodeModuleInContext`` and ``LLVMGetBitcodeModule`` have been deprecated.
  They will be removed in 3.9. Please migrate to the versions with a 2 suffix.
  Unlike the old ones the new ones do not record a diagnostic message. Use
  the diagnostic handler instead.

* The deprecated C APIs ``LLVMGetBitcodeModuleProviderInContext`` and
  ``LLVMGetBitcodeModuleProvider`` have been removed.

* The deprecated C APIs ``LLVMCreateExecutionEngine``, ``LLVMCreateInterpreter``,
  ``LLVMCreateJITCompiler``, ``LLVMAddModuleProvider`` and ``LLVMRemoveModuleProvider``
  have been removed.

* With this release, the C API headers have been reorganized to improve build
  time. Type specific declarations have been moved to Type.h, and error
  handling routines have been moved to ErrorHandling.h. Both are included in
  Core.h so nothing should change for projects directly including the headers,
  but transitive dependencies may be affected.

* llvm-ar now supports thin archives.

* llvm doesn't produce ``.data.rel.ro.local`` or ``.data.rel`` sections anymore.

* Aliases to ``available_externally`` globals are now rejected by the verifier.

* The IR Linker has been split into ``IRMover`` that moves bits from one module to
  another and Linker proper that decides what to link.

* Support for dematerializing has been dropped.

* ``RegisterScheduler::setDefault`` was removed. Targets that used to call into the
  command line parser to set the ``DAGScheduler``, and that don't have enough
  control with ``setSchedulingPreference``, should look into overriding the
  ``SubTargetHook`` "``getDAGScheduler()``".

* ``ilist_iterator<T>`` no longer has implicit conversions to and from ``T*``,
  since ``ilist_iterator<T>`` may be pointing at the sentinel (which is usually
  not of type ``T`` at all).  To convert from an iterator ``I`` to a pointer,
  use ``&*I``; to convert from a pointer ``P`` to an iterator, use
  ``P->getIterator()``.  Alternatively, explicit conversions via
  ``static_cast<T>(U)`` are still available.

* ``ilist_node<T>::getNextNode()`` and ``ilist_node<T>::getPrevNode()`` now
  fail at compile time when the node cannot access its parent list.
  Previously, when the sentinel was was an ``ilist_half_node<T>``, this API
  could return the sentinel instead of ``nullptr``.  Frustrated callers should
  be updated to use ``iplist<T>::getNextNode(T*)`` instead.  Alternatively, if
  the node ``N`` is guaranteed not to be the last in the list, it is safe to
  call ``&*++N->getIterator()`` directly.

* The `Kaleidoscope tutorials <tutorial/index.html>`_ have been updated to use
  the ORC JIT APIs.

* ORC now has a basic set of C bindings.

* Optional support for linking clang and the LLVM tools with a single libLLVM
  shared library. To enable this, pass ``-DLLVM_LINK_LLVM_DYLIB=ON`` to CMake.
  See `Building LLVM with CMake`_ for more details.

* The optimization to move the prologue and epilogue of functions in colder
  code path (shrink-wrapping) is now enabled by default.

* A new target-independent gcc-compatible emulated Thread Local Storage mode
  is added.  When ``-femultated-tls`` flag is used, all accesses to TLS
  variables are converted to calls to ``__emutls_get_address`` in the runtime
  library.

* MSVC-compatible exception handling has been completely overhauled. New
  instructions have been introduced to facilitate this:
  `New exception handling instructions <ExceptionHandling.html#new-exception-handling-instructions>`_. 
  While we have done our best to test this feature thoroughly, it would
  not be completely surprising if there were a few lingering issues that
  early adopters might bump into.


Changes to the ARM Backends
---------------------------

During this release the AArch64 target has:

* Added support for more sanitizers (MSAN, TSAN) and made them compatible with
  all VMA kernel configurations (currently tested on 39 and 42 bits).
* Gained initial LLD support in the new ELF back-end
* Extended the Load/Store optimiser and cleaned up some of the bad decisions
  made earlier.
* Expanded LLDB support, including watchpoints, native building, Renderscript,
  LLDB-server, debugging 32-bit applications.
* Added support for the ``Exynos M1`` chip.

During this release the ARM target has:

* Gained massive performance improvements on embedded benchmarks due to finally
  running the stride vectorizer in full form, incrementing the performance gains
  that we already had in the previous releases with limited stride vectorization.
* Expanded LLDB support, including watchpoints, unwind tables
* Extended the Load/Store optimiser and cleaned up some of the bad decisions
  made earlier.
* Simplified code generation for global variable addresses in ELF, resulting in
  a significant (4% in Chromium) reduction in code size.
* Gained some additional code size improvements, though there's still a long road
  ahead, especially for older cores.
* Added some EABI floating point comparison functions to Compiler-RT
* Added support for Windows+GNU triple, ``+features`` in ``-mcpu``/``-march`` options.


Changes to the MIPS Target
--------------------------

During this release the MIPS target has:

* Significantly extended support for the Integrated Assembler. See below for
  more information
* Added support for the ``P5600`` processor.
* Added support for the ``interrupt`` attribute for MIPS32R2 and later. This
  attribute will generate a function which can be used as a interrupt handler
  on bare metal MIPS targets using the static relocation model.
* Added support for the ``ERETNC`` instruction found in MIPS32R5 and later.
* Added support for OpenCL. See http://portablecl.org/.

* Address spaces 1 to 255 are now reserved for software use and conversions
  between them are no-op casts.

* Removed the ``mips16`` value for the ``-mcpu`` option since it is an :abbr:`ASE
  (Application Specific Extension)` and not a processor. If you were using this,
  please specify another CPU and use ``-mips16`` to enable MIPS16.
* Removed ``copy_u.w`` from 32-bit MSA and ``copy_u.d`` from 64-bit MSA since
  they have been removed from the MSA specification due to forward compatibility
  issues.  For example, 32-bit MSA code containing ``copy_u.w`` would behave
  differently on a 64-bit processor supporting MSA. The corresponding intrinsics
  are still available and may expand to ``copy_s.[wd]`` where this is
  appropriate for forward compatibility purposes.
* Relaxed the ``-mnan`` option to allow ``-mnan=2008`` on MIPS32R2/MIPS64R2 for
  compatibility with GCC.
* Made MIPS64R6 the default CPU for 64-bit Android triples.

The MIPS target has also fixed various bugs including the following notable
fixes:

* Fixed reversed operands on ``mthi``/``mtlo`` in the DSP :abbr:`ASE
  (Application Specific Extension)`.
* The code generator no longer uses ``jal`` for calls to absolute immediate
  addresses.
* Disabled fast instruction selection on MIPS32R6 and MIPS64R6 since this is not
  yet supported.
* Corrected addend for ``R_MIPS_HI16`` and ``R_MIPS_PCHI16`` in MCJIT
* The code generator no longer crashes when handling subregisters of an 64-bit
  FPU register with undefined value.
* The code generator no longer attempts to use ``$zero`` for operands that do
  not permit ``$zero``.
* Corrected the opcode used for ``ll``/``sc`` when using MIPS32R6/MIPS64R6 and
  the Integrated Assembler.
* Added support for atomic load and atomic store.
* Corrected debug info when dynamically re-aligning the stack.

We have made a large number of improvements to the integrated assembler for
MIPS. In this release, the integrated assembler isn't quite production-ready
since there are a few known issues related to bare-metal support, checking
immediates on instructions, and the N32/N64 ABI's. However, the current support
should be sufficient for many users of the O32 ABI, particularly those targeting
MIPS32 on Linux or bare-metal MIPS32.

If you would like to try the integrated assembler, please use
``-fintegrated-as``.

Changes to the PowerPC Target
-----------------------------

There are numerous improvements to the PowerPC target in this release:

* Shrink wrapping optimization has been enabled for PowerPC Little Endian

* Direct move instructions are used when converting scalars to vectors

* Thread Sanitizer (TSAN) is now supported for PowerPC

* New MI peephole pass to clean up redundant XXPERMDI instructions  

* Add branch hints to highly biased branch instructions (code reaching
  unreachable terminators and exceptional control flow constructs)

* Promote boolean return values to integer to prevent excessive usage of
  condition registers

* Additional vector APIs for vector comparisons and vector merges have been
  added to altivec.h

* Many bugs have been identified and fixed


Changes to the X86 Target
-----------------------------

* TLS is enabled for Cygwin as emutls.

* Smaller code for materializing 32-bit 1 and -1 constants at ``-Os``.

* More efficient code for wide integer compares. (E.g. 64-bit compares
  on 32-bit targets.)

* Tail call support for ``thiscall``, ``stdcall``, ``vectorcall``, and
  ``fastcall`` functions.

Changes to the Hexagon Target
-----------------------------

In addition to general code size and performance improvements, Hexagon target
now has basic support for Hexagon V60 architecture and Hexagon Vector
Extensions (HVX).

Changes to the AVR Target
-------------------------

Slightly less than half of the AVR backend has been merged in at this point. It is still
missing a number large parts which cause it to be unusable, but is well on the
road to being completely merged and workable.

Changes to the OCaml bindings
-----------------------------

* The ocaml function link_modules has been replaced with link_modules' which
  uses LLVMLinkModules2.


External Open Source Projects Using LLVM 3.8
============================================

An exciting aspect of LLVM is that it is used as an enabling technology for
a lot of other language and tools projects. This section lists some of the
projects that have already been updated to work with LLVM 3.8.

LDC - the LLVM-based D compiler
-------------------------------

`D <http://dlang.org>`_ is a language with C-like syntax and static typing. It
pragmatically combines efficiency, control, and modeling power, with safety and
programmer productivity. D supports powerful concepts like Compile-Time Function
Execution (CTFE) and Template Meta-Programming, provides an innovative approach
to concurrency and offers many classical paradigms.

`LDC <http://wiki.dlang.org/LDC>`_ uses the frontend from the reference compiler
combined with LLVM as backend to produce efficient native code. LDC targets
x86/x86_64 systems like Linux, OS X and Windows and also PowerPC (32/64 bit)
and ARM. Ports to other architectures like AArch64 and MIPS64 are underway.


Additional Information
======================

A wide variety of additional information is available on the `LLVM web page
<http://llvm.org/>`_, in particular in the `documentation
<http://llvm.org/docs/>`_ section.  The web page also contains versions of the
API documentation which is up-to-date with the Subversion version of the source
code.  You can access versions of these documents specific to this release by
going into the ``llvm/docs/`` directory in the LLVM tree.

If you have any questions or comments about LLVM, please feel free to contact
us via the `mailing lists <http://llvm.org/docs/#maillist>`_.
@


1.1.1.1
log
@Use the space freed up by sparc and zaurus to import LLVM.

ok hackroom@@
@
text
@@


1.1.1.2
log
@Import LLVM 3.9.1 including clang and lld.
@
text
@d2 1
a2 1
LLVM 3.9 Release Notes
d8 1
d13 1
a13 1
release 3.9.  Here we describe the status of LLVM, including major improvements
d26 95
a120 84
* The LLVMContext gains a new runtime check (see
  LLVMContext::discardValueNames()) that can be set to discard Value names
  (other than GlobalValue). This is intended to be used in release builds by
  clients that are interested in saving CPU/memory as much as possible.

* There is no longer a "global context" available in LLVM, except for the C API.

* The autoconf build system has been removed in favor of CMake. LLVM 3.9
  requires CMake 3.4.3 or later to build. For information about using CMake
  please see the documentation on :doc:`CMake`. For information about the CMake
  language there is also a :doc:`CMakePrimer` document available.

* C API functions LLVMParseBitcode,
  LLVMParseBitcodeInContext, LLVMGetBitcodeModuleInContext and
  LLVMGetBitcodeModule having been removed. LLVMGetTargetMachineData has been
  removed (use LLVMGetDataLayout instead).

* The C API function LLVMLinkModules has been removed.

* The C API function LLVMAddTargetData has been removed.

* The C API function LLVMGetDataLayout is deprecated
  in favor of LLVMGetDataLayoutStr.

* The C API enum LLVMAttribute and associated API is deprecated in favor of
  the new LLVMAttributeRef API. The deprecated functions are
  LLVMAddFunctionAttr, LLVMAddTargetDependentFunctionAttr,
  LLVMRemoveFunctionAttr, LLVMGetFunctionAttr, LLVMAddAttribute,
  LLVMRemoveAttribute, LLVMGetAttribute, LLVMAddInstrAttribute,
  LLVMRemoveInstrAttribute and LLVMSetInstrParamAlignment.

* ``TargetFrameLowering::eliminateCallFramePseudoInstr`` now returns an
  iterator to the next instruction instead of ``void``. Targets that previously
  did ``MBB.erase(I); return;`` now probably want ``return MBB.erase(I);``.

* ``SelectionDAGISel::Select`` now returns ``void``. Out-of-tree targets will
  need to be updated to replace the argument node and remove any dead nodes in
  cases where they currently return an ``SDNode *`` from this interface.

* Added the MemorySSA analysis, which hopes to replace MemoryDependenceAnalysis.
  It should provide higher-quality results than MemDep, and be algorithmically
  faster than MemDep. Currently, GVNHoist (which is off by default) makes use of
  MemorySSA.

* The minimum density for lowering switches with jump tables has been reduced
  from 40% to 10% for functions which are not marked ``optsize`` (that is,
  compiled with ``-Os``).

GCC ABI Tag
-----------

Recently, many of the Linux distributions (e.g. `Fedora <http://developerblog.redhat.com/2015/02/10/gcc-5-in-fedora/>`_,
`Debian <https://wiki.debian.org/GCC5>`_, `Ubuntu <https://wiki.ubuntu.com/GCC5>`_)
have moved on to use the new `GCC ABI <https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Attributes.html>`_
to work around `C++11 incompatibilities in libstdc++ <https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html>`_.
This caused `incompatibility problems <https://gcc.gnu.org/ml/gcc-patches/2015-04/msg00153.html>`_
with other compilers (e.g. Clang), which needed to be fixed, but due to the
experimental nature of GCC's own implementation, it took a long time for it to
land in LLVM (`D18035 <https://reviews.llvm.org/D18035>`_ and
`D17567 <https://reviews.llvm.org/D17567>`_), not in time for the 3.8 release.

Those patches are now present in the 3.9.0 release and should be working in the
majority of cases, as they have been tested thoroughly. However, some bugs were
`filed in GCC <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71712>`_ and have not
yet been fixed, so there may be corner cases not covered by either GCC or Clang.
Bug fixes to those problems should be reported in Bugzilla (either LLVM or GCC),
and patches to LLVM's trunk are very likely to be back-ported to future 3.9.x
releases (depends on how destructive it is).

Unfortunately, these patches won't be back-ported to 3.8.x or earlier, so we
strongly recommend people to use 3.9.x when GCC ABI cases are at stake.

For a more in-depth view of the issue, check our `Bugzilla entry <https://llvm.org/bugs/show_bug.cgi?id=23529>`_.

Changes to the LLVM IR
----------------------

* New intrinsics ``llvm.masked.load``, ``llvm.masked.store``,
  ``llvm.masked.gather`` and ``llvm.masked.scatter`` were introduced to the
  LLVM IR to allow selective memory access for vector data types.

* The new ``notail`` attribute prevents optimization passes from adding ``tail``
  or ``musttail`` markers to a call. It is used to prevent tail call
  optimization from being performed on the call.
d122 1
a122 1
Changes to LLVM's IPO model
d125 1
a125 21
LLVM no longer does inter-procedural analysis and optimization (except
inlining) on functions with comdat linkage.  Doing IPO over such
functions is unsound because the implementation the linker chooses at
link-time may be differently optimized than the one what was visible
during optimization, and may have arbitrarily different observable
behavior.  See `PR26774 <http://llvm.org/PR26774>`_ for more details.

Support for ThinLTO
-------------------

LLVM now supports ThinLTO compilation, which can be invoked by compiling
and linking with ``-flto=thin``. The gold linker plugin, as well as linkers
that use the new ThinLTO API in libLTO (like ld64), will transparently
execute the ThinLTO backends in parallel threads.
For more information on ThinLTO and the LLVM implementation, see the
`ThinLTO blog post <http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html>`_.

Changes to the ARM Targets
--------------------------

**During this release the AArch64 backend has:**
d127 23
a149 31
* Gained support for Qualcomm's Kryo and Broadcom's Vulcan CPUs, including
  scheduling models.
* Landed a scheduling model for Samsung's Exynos M1.
* Seen a lot of work on GlobalISel.
* Learned a few more useful combines (fadd and fmul into fmadd, adjustments to the
  stack pointer for callee-save stack memory and local stack memory etc).
* Gained support for the Swift calling convention.
* Switched to using SubtargetFeatures rather than testing for specific CPUs and
  to using TableGen for handling system instruction operands.
* Like ARM, AArch64 is now using the TargetParser, so no more StringSwitches
  matching CPU, FPU or feature names will be accepted in normal code.
* Clang can now self-host itself using LLD on AArch64.
* Gained a big batch of tests from Halide.

 Furthermore, LLDB now supports AArch64 compact unwind tables, as used on iOS,
 tvos and watchos.

**During this release the ARM target has:**

* ARMv8.2-A can now be targeted directly via Clang flags.
* Adding preliminary support for Cortex-R8.
* LLDB can now parse EABI attributes for an ELF input.
* Initial ARM/Thumb support was added to LLD.
* The ExecutionEngine now supports COFF/ARM.
* Swift calling convention was ported to ARM.
* A large number of codegen fixes around ARMv8, DSP, correct sub-target support,
  relocations, EABI, EHABI, Windows on ARM, atomics..
* Improved assembler support for Linux/Android/Chromium sub-projects.
* Initial support for MUSL (libc) on ARM.
* Support for Thumb1 targets in libunwind.
* Gained a big batch of tests from Halide.
d155 1
a155 1
**During this release the MIPS target has:**
d157 50
a206 39
* Enabled the Integrated Assembler by default for all ``mips-*`` and
  ``mipsel-*`` triples.
* Significantly improved the Integrated Assembler support for the n64 ABI.
* Added the Clang frontend ``-mcompact-branches={never,optimal,always}`` option
  that controls how LLVM generates compact branches for MIPS targets.
* Improved performance and code size for stack pointer adjustments in functions
  with large frames.
* Implemented many instructions from the microMIPS32R6 ISA and added CodeGen
  support for most of them.
* Added support for the triple used by Debian Stretch for little endian
  MIPS64, ie. ``mips64el-linux-gnuabi64``.
* Removed EABI which was neither tested nor properly supported.
* Gained the ability to self-host on MIPS32R6.
* Gained the ability to self-host on MIPS64R2 and MIPS64R6 when using the n64
  ABI.
* Added support for the ``LA`` macro in PIC mode for o32.
* Added support for safestack in compiler-rt.
* Added support for the MIPS n64 ABI in LLD.
* Added LLD support for TLS relocations for both o32 and n64 MIPS ABIs.

**The MIPS target has also fixed various bugs including the following notable
fixes:**

* Delay slots are no longer filled multiple times when either ``-save-temps``
  or ``-via-file-asm`` are used.
* Updated n32 and n64 to follow the standard ELF conventions for label prefixes
  (``.L``), whereas o32 still uses its own (``$``).
* Properly sign-extend values to GPR width for instructions that expect 32-bit
  values on 64-bit ISAs.
* Several fixes for the delay-slot filler pass, including correct
  forbidden-slot hazard handling.
* Fixed several errors caught by the machine verifier when turned on for MIPS.
* Fixed broken predicate for ``SELECT`` patterns in MIPS64.
* Fixed wrong truncation of memory address for ``LL``/``SC`` seqeuences in
  MIPS64.
* Fixed the o32, n32 and n64 handling of ``.cprestore`` directives when inside
  a ``.set noat`` region by the Integrated Assembler.
* Fixed the ordering of ``HI``/``LO`` pairs in the relocation table.
* Fixed the generated ELF ``EFlags`` when Octeon is the target.
d208 2
d214 20
a233 1
* Moved some optimizations from O3 to O2 (D18562)
a234 1
* Enable sibling call optimization on ppc64 ELFv1/ELFv2 abi
d237 20
d259 3
a261 11
* LLVM now supports the Intel CPU codenamed Skylake Server with AVX-512
  extensions using ``-march=skylake-avx512``. The switch enables the
  ISA extensions AVX-512{F, CD, VL, BW, DQ}.

* LLVM now supports the Intel CPU codenamed Knights Landing with AVX-512
  extensions using ``-march=knl``. The switch enables the ISA extensions
  AVX-512{F, CD, ER, PF}.

* LLVM will now prefer ``PUSH`` instructions rather than ``%esp``-relative
  ``MOV`` instructions for function calls at all optimization levels greater
  than ``-O0``. Previously this transformation only occurred at ``-Os``.
d263 1
a263 1
Changes to the AMDGPU Target
d266 2
a267 4
 * Added backend support for OpenGL shader image, buffer storage, atomic
   counter, and compute shader extensions (supported since Mesa 12)

 * Mesa 11.0.x is no longer supported
d270 1
a270 1
External Open Source Projects Using LLVM 3.9
d275 1
a275 1
projects that have already been updated to work with LLVM 3.9.
d288 2
a289 3
x86/x86_64 systems like Linux, OS X, FreeBSD and Windows and also Linux on ARM
and PowerPC (32/64 bit). Ports to other architectures like AArch64 and MIPS64
are underway.
a303 1

@


1.1.1.3
log
@Import LLVM 4.0.0 rc1 including clang and lld to help the current
development effort on OpenBSD/arm64.
@
text
@d1 3
a3 3
========================
LLVM 4.0.0 Release Notes
========================
a7 6
.. warning::
   These are in-progress notes for the upcoming LLVM 4.0.0 release.  You may
   prefer the `LLVM 3.9 Release Notes <http://llvm.org/releases/3.9.0/docs
   /ReleaseNotes.html>`_.


d12 1
a12 1
release 4.0.0.  Here we describe the status of LLVM, including major improvements
d25 73
a97 46
* The C API functions LLVMAddFunctionAttr, LLVMGetFunctionAttr,
  LLVMRemoveFunctionAttr, LLVMAddAttribute, LLVMRemoveAttribute,
  LLVMGetAttribute, LLVMAddInstrAttribute and
  LLVMRemoveInstrAttribute have been removed.

* The C API enum LLVMAttribute has been deleted.

.. NOTE
   For small 1-3 sentence descriptions, just add an entry at the end of
   this list. If your description won't fit comfortably in one bullet
   point (e.g. maybe you would like to give an example of the
   functionality, or simply have a lot to talk about), see the `NOTE` below
   for adding a new subsection.

* The definition and uses of LLVM_ATRIBUTE_UNUSED_RESULT in the LLVM source
  were replaced with LLVM_NODISCARD, which matches the C++17 [[nodiscard]]
  semantics rather than gcc's __attribute__((warn_unused_result)).

* Minimum compiler version to build has been raised to GCC 4.8 and VS 2015.

* The Timer related APIs now expect a Name and Description. When upgrading code
  the previously used names should become descriptions and a short name in the
  style of a programming language identifier should be added.

* LLVM now handles invariant.group across different basic blocks, which makes
  it possible to devirtualize virtual calls inside loops.

* ... next change ...

.. NOTE
   If you would like to document a larger change, then you can add a
   subsection about it right here. You can copy the following boilerplate
   and un-indent it (the indentation causes it to be inside this comment).

   Special New Feature
   -------------------

   Makes programs 10x faster by doing Special New Thing.

   Improvements to ThinLTO (-flto=thin)
   ------------------------------------
   * Integration with profile data (PGO). When available, profile data 
     enables more accurate function importing decisions, as well as 
     cross-module indirect call promotion.
   * Significant build-time and binary-size improvements when compiling with 
     debug info (-g).
d102 29
a130 1
Changes to the ARM Backend
d133 33
a165 1
 During this release ...
d171 41
a211 1
 During this release ...
d217 3
a219 1
 During this release ...
d224 11
a234 1
 During this release ...
d239 2
a240 1
 During this release ...
d242 1
a242 2
Changes to the AVR Target
-----------------------------
a243 3
* The entire backend has been merged in-tree with all tests passing. All of
  the instruction selection code and the machine code backend has landed
  recently and is fully usable.
d245 2
a246 2
Changes to the OCaml bindings
-----------------------------
d248 3
a250 2
* The attribute API was completely overhauled, following the changes
  to the C API.
d252 2
d255 5
a259 2
External Open Source Projects Using LLVM 4.0.0
==============================================
d261 5
a265 1
* A project...
d280 1
@


1.1.1.4
log
@Import LLVM 4.0.0 release including clang and lld.
@
text
@d8 6
a28 8
New Versioning Scheme
=====================
Starting with this release, LLVM is using a
`new versioning scheme <http://blog.llvm.org/2016/12/llvms-new-versioning-scheme.html>`_,
increasing the major version number with each major release. Stable updates to
this release will be versioned 4.0.x, and the next major release, six months
from now, will be version 5.0.0.

d31 17
a47 2
* The minimum compiler version required for building LLVM has been raised to
  4.8 for GCC and 2015 for Visual Studio.
d49 1
a49 10
* The C API functions ``LLVMAddFunctionAttr``, ``LLVMGetFunctionAttr``,
  ``LLVMRemoveFunctionAttr``, ``LLVMAddAttribute``, ``LLVMRemoveAttribute``,
  ``LLVMGetAttribute``, ``LLVMAddInstrAttribute`` and
  ``LLVMRemoveInstrAttribute`` have been removed.

* The C API enum ``LLVMAttribute`` has been deleted.

* The definition and uses of ``LLVM_ATRIBUTE_UNUSED_RESULT`` in the LLVM source
  were replaced with ``LLVM_NODISCARD``, which matches the C++17 ``[[nodiscard]]``
  semantics rather than gcc's ``__attribute__((warn_unused_result))``.
d55 1
a55 1
* LLVM now handles ``invariant.group`` across different basic blocks, which makes
d58 22
a79 137
* The aggressive dead code elimination phase ("adce") now removes
  branches which do not effect program behavior. Loops are retained by
  default since they may be infinite but these can also be removed
  with LLVM option ``-adce-remove-loops`` when the loop body otherwise has
  no live operations.

* The llvm-cov tool can now export coverage data as json. Its html output mode
  has also improved.

Improvements to ThinLTO (-flto=thin)
------------------------------------
Integration with profile data (PGO). When available, profile data
enables more accurate function importing decisions, as well as
cross-module indirect call promotion.

Significant build-time and binary-size improvements when compiling with
debug info (-g).

LLVM Coroutines
---------------

Experimental support for :doc:`Coroutines` was added, which can be enabled
with ``-enable-coroutines`` in ``opt`` the command tool or using the
``addCoroutinePassesToExtensionPoints`` API when building the optimization
pipeline.

For more information on LLVM Coroutines and the LLVM implementation, see
`2016 LLVM Developersâ€™ Meeting talk on LLVM Coroutines
<http://llvm.org/devmtg/2016-11/#talk4>`_.

Regcall and Vectorcall Calling Conventions
--------------------------------------------------

Support was added for ``_regcall`` calling convention.
Existing ``__vectorcall`` calling convention support was extended to include
correct handling of HVAs.

The ``__vectorcall`` calling convention was introduced by Microsoft to
enhance register usage when passing parameters.
For more information please read `__vectorcall documentation
<https://msdn.microsoft.com/en-us/library/dn375768.aspx>`_.

The ``__regcall`` calling convention was introduced by Intel to
optimize parameter transfer on function call.
This calling convention ensures that as many values as possible are
passed or returned in registers.
For more information please read `__regcall documentation
<https://software.intel.com/en-us/node/693069>`_.

Code Generation Testing
-----------------------

Passes that work on the machine instruction representation can be tested with
the .mir serialization format. ``llc`` supports the ``-run-pass``,
``-stop-after``, ``-stop-before``, ``-start-after``, ``-start-before`` to
run a single pass of the code generation pipeline, or to stop or start the code
generation pipeline at a given point.

Additional information can be found in the :doc:`MIRLangRef`. The format is
used by the tests ending in ``.mir`` in the ``test/CodeGen`` directory.

This feature is available since 2015. It is used more often lately and was not
mentioned in the release notes yet.

Intrusive list API overhaul
---------------------------

The intrusive list infrastructure was substantially rewritten over the last
couple of releases, primarily to excise undefined behaviour.  The biggest
changes landed in this release.

* ``simple_ilist<T>`` is a lower-level intrusive list that never takes
  ownership of its nodes.  New intrusive-list clients should consider using it
  instead of ``ilist<T>``.

  * ``ilist_tag<class>`` allows a single data type to be inserted into two
    parallel intrusive lists.  A type can inherit twice from ``ilist_node``,
    first using ``ilist_node<T,ilist_tag<A>>`` (enabling insertion into
    ``simple_ilist<T,ilist_tag<A>>``) and second using
    ``ilist_node<T,ilist_tag<B>>`` (enabling insertion into
    ``simple_ilist<T,ilist_tag<B>>``), where ``A`` and ``B`` are arbitrary
    types.

  * ``ilist_sentinel_tracking<bool>`` controls whether an iterator knows
    whether it's pointing at the sentinel (``end()``).  By default, sentinel
    tracking is on when ABI-breaking checks are enabled, and off otherwise;
    this is used for an assertion when dereferencing ``end()`` (this assertion
    triggered often in practice, and many backend bugs were fixed).  Explicitly
    turning on sentinel tracking also enables ``iterator::isEnd()``.  This is
    used by ``MachineInstrBundleIterator`` to iterate over bundles.

* ``ilist<T>`` is built on top of ``simple_ilist<T>``, and supports the same
  configuration options.  As before (and unlike ``simple_ilist<T>``),
  ``ilist<T>`` takes ownership of its nodes.  However, it no longer supports
  *allocating* nodes, and is now equivalent to ``iplist<T>``.  ``iplist<T>``
  will likely be removed in the future.

  * ``ilist<T>`` now always uses ``ilist_traits<T>``.  Instead of passing a
    custom traits class in via a template parameter, clients that want to
    customize the traits should specialize ``ilist_traits<T>``.  Clients that
    want to avoid ownership can specialize ``ilist_alloc_traits<T>`` to inherit
    from ``ilist_noalloc_traits<T>`` (or to do something funky); clients that
    need callbacks can specialize ``ilist_callback_traits<T>`` directly.

* The underlying data structure is now a simple recursive linked list.  The
  sentinel node contains only a "next" (``begin()``) and "prev" (``rbegin()``)
  pointer and is stored in the same allocation as ``simple_ilist<T>``.
  Previously, it was malloc-allocated on-demand by default, although the
  now-defunct ``ilist_sentinel_traits<T>`` was sometimes specialized to avoid
  this.

* The ``reverse_iterator`` class no longer uses ``std::reverse_iterator``.
  Instead, it now has a handle to the same node that it dereferences to.
  Reverse iterators now have the same iterator invalidation semantics as
  forward iterators.

  * ``iterator`` and ``reverse_iterator`` have explicit conversion constructors
    that match ``std::reverse_iterator``'s off-by-one semantics, so that
    reversing the end points of an iterator range results in the same range
    (albeit in reverse).  I.e., ``reverse_iterator(begin())`` equals
    ``rend()``.

  * ``iterator::getReverse()`` and ``reverse_iterator::getReverse()`` return an
    iterator that dereferences to the *same* node.  I.e.,
    ``begin().getReverse()`` equals ``--rend()``.

  * ``ilist_node<T>::getIterator()`` and
    ``ilist_node<T>::getReverseIterator()`` return the forward and reverse
    iterators that dereference to the current node.  I.e.,
    ``begin()->getIterator()`` equals ``begin()`` and
    ``rbegin()->getReverseIterator()`` equals ``rbegin()``.

* ``iterator`` now stores an ``ilist_node_base*`` instead of a ``T*``.  The
  implicit conversions between ``ilist<T>::iterator`` and ``T*`` have been
  removed.  Clients may use ``N->getIterator()`` (if not ``nullptr``) or
  ``&*I`` (if not ``end()``); alternatively, clients may refactor to use
  references for known-good nodes.
d81 1
a81 1
Changes to the ARM Targets
d84 1
a84 1
**During this release the AArch64 target has:**
a85 28
* Gained support for ILP32 relocations.
* Gained support for XRay.
* Made even more progress on GlobalISel. There is still some work left before
  it is production-ready though.
* Refined the support for Qualcomm's Falkor and Samsung's Exynos CPUs.
* Learned a few new tricks for lowering multiplications by constants, folding
  spilled/refilled copies etc.

**During this release the ARM target has:**

* Gained support for ROPI (read-only position independence) and RWPI
  (read-write position independence), which can be used to remove the need for
  a dynamic linker.
* Gained support for execute-only code, which is placed in pages without read
  permissions.
* Gained a machine scheduler for Cortex-R52.
* Gained support for XRay.
* Gained Thumb1 implementations for several compiler-rt builtins. It also
  has some support for building the builtins for HF targets.
* Started using the generic bitreverse intrinsic instead of rbit.
* Gained very basic support for GlobalISel.

A lot of work has also been done in LLD for ARM, which now supports more
relocations and TLS.

Note: From the next release (5.0), the "vulcan" target will be renamed to
"thunderx2t99", including command line options, assembly directives, etc. This
release (4.0) will be the last one to accept "vulcan" as its name.
d87 4
a90 2
Changes to the AVR Target
-----------------------------
a91 17
This marks the first release where the AVR backend has been completely merged
from a fork into LLVM trunk. The backend is still marked experimental, but
is generally quite usable. All downstream development has halted on
`GitHub <https://github.com/avr-llvm/llvm>`_, and changes now go directly into
LLVM trunk.

* Instruction selector and pseudo instruction expansion pass landed
* `read_register` and `write_register` intrinsics are now supported
* Support stack stores greater than 63-bytes from the bottom of the stack
* A number of assertion errors have been fixed
* Support stores to `undef` locations
* Very basic support for the target has been added to clang
* Small optimizations to some 16-bit boolean expressions

Most of the work behind the scenes has been on correctness of generated
assembly, and also fixing some assertions we would hit on some well-formed
inputs.
d93 1
a93 1
Changes to the MIPS Target
d96 1
a96 24
**During this release the MIPS target has:**

* IAS is now enabled by default for Debian mips64el.
* Added support for the two operand form for many instructions.
* Added the following macros: unaligned load/store, seq, double word load/store for O32.
* Improved the parsing of complex memory offset expressions.
* Enabled the integrated assembler by default for Debian mips64el.
* Added a generic scheduler based on the interAptiv CPU.
* Added support for thread local relocations.
* Added recip, rsqrt, evp, dvp, synci instructions in IAS.
* Optimized the generation of constants from some cases.

**The following issues have been fixed:**

* Thread local debug information is correctly recorded.
* MSA intrinsics are now range checked.
* Fixed an issue with MSA and the no-odd-spreg abi.
* Fixed some corner cases in handling forbidden slots for MIPSR6.
* Fixed an issue with jumps not being converted to relative branches for assembly.
* Fixed the handling of local symbols and jal instruction.
* N32/N64 no longer have their relocation tables sorted as per their ABIs.
* Fixed a crash when half-precision floating point conversion MSA intrinsics are used.
* Fixed several crashes involving FastISel.
* Corrected the corrected definitions for aui/daui/dahi/dati for MIPSR6.
d101 1
a101 1
**During this release the X86 target has:**
d103 11
a113 3
* Added support AMD Ryzen (znver1) CPUs.
* Gained support for using VEX encoding on AVX-512 CPUs to reduce code size when possible.
* Improved AVX-512 codegen.
d125 1
a125 42
LDC - the LLVM-based D compiler
-------------------------------

`D <http://dlang.org>`_ is a language with C-like syntax and static typing. It
pragmatically combines efficiency, control, and modeling power, with safety and
programmer productivity. D supports powerful concepts like Compile-Time Function
Execution (CTFE) and Template Meta-Programming, provides an innovative approach
to concurrency and offers many classical paradigms.

`LDC <http://wiki.dlang.org/LDC>`_ uses the frontend from the reference compiler
combined with LLVM as backend to produce efficient native code. LDC targets
x86/x86_64 systems like Linux, OS X, FreeBSD and Windows and also Linux on ARM
and PowerPC (32/64 bit). Ports to other architectures like AArch64 and MIPS64
are underway.

Portable Computing Language (pocl)
----------------------------------

In addition to producing an easily portable open source OpenCL
implementation, another major goal of `pocl <http://pocl.sourceforge.net/>`_
is improving performance portability of OpenCL programs with
compiler optimizations, reducing the need for target-dependent manual
optimizations. An important part of pocl is a set of LLVM passes used to
statically parallelize multiple work-items with the kernel compiler, even in
the presence of work-group barriers. This enables static parallelization of
the fine-grained static concurrency in the work groups in multiple ways.

TTA-based Co-design Environment (TCE)
-------------------------------------

`TCE <http://tce.cs.tut.fi/>`_ is a toolset for designing customized
processors based on the Transport Triggered Architecture (TTA).
The toolset provides a complete co-design flow from C/C++
programs down to synthesizable VHDL/Verilog and parallel program binaries.
Processor customization points include register files, function units,
supported operations, and the interconnection network.

TCE uses Clang and LLVM for C/C++/OpenCL C language support, target independent
optimizations and also for parts of code generation. It generates new
LLVM-based code generators "on the fly" for the designed TTA processors and
loads them in to the compiler backend as runtime libraries to avoid
per-target recompilation of larger parts of the compiler chain.
@


