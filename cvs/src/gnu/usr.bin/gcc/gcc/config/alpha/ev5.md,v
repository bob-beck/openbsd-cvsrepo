head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.1.0.54
	OPENBSD_6_2_BASE:1.1.1.1
	OPENBSD_6_1:1.1.1.1.0.56
	OPENBSD_6_1_BASE:1.1.1.1
	OPENBSD_6_0:1.1.1.1.0.52
	OPENBSD_6_0_BASE:1.1.1.1
	OPENBSD_5_9:1.1.1.1.0.48
	OPENBSD_5_9_BASE:1.1.1.1
	OPENBSD_5_8:1.1.1.1.0.50
	OPENBSD_5_8_BASE:1.1.1.1
	OPENBSD_5_7:1.1.1.1.0.42
	OPENBSD_5_7_BASE:1.1.1.1
	OPENBSD_5_6:1.1.1.1.0.46
	OPENBSD_5_6_BASE:1.1.1.1
	OPENBSD_5_5:1.1.1.1.0.44
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.40
	OPENBSD_5_4_BASE:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.38
	OPENBSD_5_3_BASE:1.1.1.1
	gcc-3_3_6:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.36
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.34
	OPENBSD_5_0:1.1.1.1.0.32
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.30
	OPENBSD_4_9_BASE:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.28
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.24
	OPENBSD_4_7_BASE:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.26
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.22
	OPENBSD_4_5_BASE:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.20
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.18
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.16
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.14
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.12
	OPENBSD_4_0_BASE:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.10
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.8
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.6
	OPENBSD_3_7_BASE:1.1.1.1
	gcc-3_3_5:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.4
	OPENBSD_3_6_BASE:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	gcc-3_3_2:1.1.1.1
	FSF:1.1.1;
locks; strict;
comment	@# @;


1.1
date	2003.11.29.12.31.24;	author espie;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.11.29.12.31.24;	author espie;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@;; Scheduling description for Alpha EV5.
;;   Copyright (C) 2002 Free Software Foundation, Inc.
;;
;; This file is part of GNU CC.
;;
;; GNU CC is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; GNU CC is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GNU CC; see the file COPYING.  If not, write to
;; the Free Software Foundation, 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;; EV5 has two asymetric integer units, E0 and E1, plus separate
;; FP add and multiply units.

(define_automaton "ev5_0,ev5_1")
(define_cpu_unit "ev5_e0,ev5_e1,ev5_fa,ev5_fm" "ev5_0")
(define_reservation "ev5_e01" "ev5_e0|ev5_e1")
(define_reservation "ev5_fam" "ev5_fa|ev5_fm")
(define_cpu_unit "ev5_imul" "ev5_0")
(define_cpu_unit "ev5_fdiv" "ev5_1")

; Assume type "multi" single issues.
(define_insn_reservation "ev5_multi" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "multi"))
  "ev5_e0+ev5_e1+ev5_fa+ev5_fm")

; Stores can only issue to E0, and may not issue with loads.
; Model this with some fake units.

(define_cpu_unit "ev5_l0,ev5_l1,ev5_st" "ev5_0")
(define_reservation "ev5_ld" "ev5_l0|ev5_l1")
(exclusion_set "ev5_l0,ev5_l1" "ev5_st")

(define_insn_reservation "ev5_st" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "ist,fst"))
  "ev5_e0+ev5_st")

; Loads from L0 complete in two cycles.  adjust_cost still factors
; in user-specified memory latency, so return 1 here.
(define_insn_reservation "ev5_ld" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "ild,fld,ldsym"))
  "ev5_e01+ev5_ld")

; Integer branches slot only to E1.
(define_insn_reservation "ev5_ibr" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "ibr"))
  "ev5_e1")

(define_insn_reservation "ev5_callpal" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "callpal"))
  "ev5_e1")

(define_insn_reservation "ev5_jsr" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "jsr"))
  "ev5_e1")

(define_insn_reservation "ev5_shift" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "shift"))
  "ev5_e0")

(define_insn_reservation "ev5_mvi" 2
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "mvi"))
  "ev5_e0")

(define_insn_reservation "ev5_cmov" 2
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "icmov"))
  "ev5_e01")

(define_insn_reservation "ev5_iadd" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "iadd"))
  "ev5_e01")

(define_insn_reservation "ev5_ilogcmp" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "ilog,icmp"))
  "ev5_e01")

; Conditional move and branch can issue the same cycle as the test.
(define_bypass 0 "ev5_ilogcmp" "ev5_ibr,ev5_cmov" "if_test_bypass_p")

; Multiplies use a non-piplined imul unit.  Also, "no insn can be issued
; to E0 exactly two cycles before an integer multiply completes".

(define_insn_reservation "ev5_imull" 8
  (and (eq_attr "cpu" "ev5")
       (and (eq_attr "type" "imul")
	    (eq_attr "opsize" "si")))
  "ev5_e0+ev5_imul,ev5_imul*3,nothing,ev5_e0")

(define_insn_reservation "ev5_imulq" 12
  (and (eq_attr "cpu" "ev5")
       (and (eq_attr "type" "imul")
	    (eq_attr "opsize" "di")))
  "ev5_e0+ev5_imul,ev5_imul*7,nothing,ev5_e0")

(define_insn_reservation "ev5_imulh" 14
  (and (eq_attr "cpu" "ev5")
       (and (eq_attr "type" "imul")
	    (eq_attr "opsize" "udi")))
  "ev5_e0+ev5_imul,ev5_imul*7,nothing*3,ev5_e0")

; The multiplier is unable to receive data from Ebox bypass paths.  The
; instruction issues at the expected time, but its latency is increased
; by the time it takes for the input data to become available to the
; multiplier.  For example, an IMULL instruction issued one cycle later
; than an ADDL instruction, which produced one of its operands, has a
; latency of 10 (8 + 2).  If the IMULL instruction is issued two cycles
; later than the ADDL instruction, the latency is 9 (8 + 1).
;
; Model this instead with increased latency on the input instruction.

(define_bypass 3
  "ev5_ld,ev5_shift,ev5_mvi,ev5_cmov,ev5_iadd,ev5_ilogcmp"
  "ev5_imull,ev5_imulq,ev5_imulh")

(define_bypass  9 "ev5_imull" "ev5_imull,ev5_imulq,ev5_imulh")
(define_bypass 13 "ev5_imulq" "ev5_imull,ev5_imulq,ev5_imulh")
(define_bypass 15 "ev5_imulh" "ev5_imull,ev5_imulq,ev5_imulh")

; Similarly for the FPU we have two asymetric units.

(define_insn_reservation "ev5_fadd" 4
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "fadd,fcmov"))
  "ev5_fa")

(define_insn_reservation "ev5_fbr" 1
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "fbr"))
  "ev5_fa")

(define_insn_reservation "ev5_fcpys" 4
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "fcpys"))
  "ev5_fam")

(define_insn_reservation "ev5_fmul" 4
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "fmul"))
  "ev5_fm")

; The floating point divider is not pipelined.  Also, "no insn can be issued
; to FA exactly five before an fdiv insn completes".
;
; ??? Do not model this late reservation due to the enormously increased
; size of the resulting DFA.
;
; ??? Putting ev5_fa and ev5_fdiv alone into the same automata produces
; a DFA of acceptable size, but putting ev5_fm and ev5_fa into separate
; automata produces incorrect results for insns that can choose one or
; the other, i.e. ev5_fcpys.

(define_insn_reservation "ev5_fdivsf" 15
  (and (eq_attr "cpu" "ev5")
       (and (eq_attr "type" "fdiv")
	    (eq_attr "opsize" "si")))
  ; "ev5_fa+ev5_fdiv,ev5_fdiv*9,ev5_fa+ev5_fdiv,ev5_fdiv*4"
  "ev5_fa+ev5_fdiv,ev5_fdiv*14")

(define_insn_reservation "ev5_fdivdf" 22
  (and (eq_attr "cpu" "ev5")
       (and (eq_attr "type" "fdiv")
	    (eq_attr "opsize" "di")))
  ; "ev5_fa+ev5_fdiv,ev5_fdiv*17,ev5_fa+ev5_fdiv,ev5_fdiv*4"
  "ev5_fa+ev5_fdiv,ev5_fdiv*21")

; Traps don't consume or produce data; rpcc is latency 2 if we ever add it.
(define_insn_reservation "ev5_misc" 2
  (and (eq_attr "cpu" "ev5")
       (eq_attr "type" "misc"))
  "ev5_e0")
@


1.1.1.1
log
@Import gcc-3.3.2. Only the compiler. ada frontend removed for space 
considerations.
@
text
@@
