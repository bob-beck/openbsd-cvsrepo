head	1.2;
access;
symbols
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.3.0.10
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.4
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.6
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.2.0.4
	OPENBSD_5_6_BASE:1.1.1.2
	PERL_5_18_2:1.1.1.2
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.1.0.6
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.2
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.02;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2013.03.25.20.07.57;	author sthen;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2013.03.25.20.07.57;	author sthen;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2014.03.24.14.58.55;	author afresh1;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.11.17.20.52.57;	author afresh1;	state Exp;
branches;
next	1.1.1.4;
commitid	B31cAbBIXiCqnL97;

1.1.1.4
date	2017.08.14.13.46.00;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# -*- mode: cperl; tab-width: 8; indent-tabs-mode: nil; basic-offset: 2 -*-
# vim:ts=8:sw=2:et:sta:sts=2
package Module::Metadata; # git description: v1.000030-2-g52f466c
# ABSTRACT: Gather package and POD information from perl module files

# Adapted from Perl-licensed code originally distributed with
# Module-Build by Ken Williams

# This module provides routines to gather information about
# perl modules (assuming this may be expanded in the distant
# parrot future to look at other types of modules).

sub __clean_eval { eval $_[0] }
use strict;
use warnings;

our $VERSION = '1.000031'; # TRIAL

use Carp qw/croak/;
use File::Spec;
BEGIN {
       # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
       eval {
               require Fcntl; Fcntl->import('SEEK_SET'); 1;
       } or *SEEK_SET = sub { 0 }
}
use version 0.87;
BEGIN {
  if ($INC{'Log/Contextual.pm'}) {
    require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
    Log::Contextual->import('log_info',
      '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
    );
  }
  else {
    *log_info = sub (&) { warn $_[0]->() };
  }
}
use File::Find qw(find);

my $V_NUM_REGEXP = qr{v?[0-9._]+};  # crudely, a v-string or decimal

my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
  [a-zA-Z_]                     # the first word CANNOT start with a digit
    (?:
      [\w']?                    # can contain letters, digits, _, or ticks
      \w                        # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
  \w                           # the 2nd+ word CAN start with digits
    (?:
      [\w']?                   # and can contain letters or ticks
      \w                       # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_NAME_REGEXP = qr{ # match a package name
  (?: :: )?               # a pkg name can start with arisdottle
  $PKG_FIRST_WORD_REGEXP  # a package word
  (?:
    (?: :: )+             ### arisdottle (allow one or many times)
    $PKG_ADDL_WORD_REGEXP ### a package word
  )*                      # ^ zero, one or many times
  (?:
    ::                    # allow trailing arisdottle
  )?
}x;

my $PKG_REGEXP  = qr{   # match a package declaration
  ^[\s\{;]*             # intro chars on a line
  package               # the word 'package'
  \s+                   # whitespace
  ($PKG_NAME_REGEXP)    # a package name
  \s*                   # optional whitespace
  ($V_NUM_REGEXP)?        # optional version number
  \s*                   # optional whitesapce
  [;\{]                 # semicolon line terminator or block start (since 5.16)
}x;

my $VARNAME_REGEXP = qr{ # match fully-qualified VERSION name
  ([\$*])         # sigil - $ or *
  (
    (             # optional leading package name
      (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
      (?:\w+(?:::|\'))*  # Foo::Bar:: ...
    )?
    VERSION
  )\b
}x;

my $VERS_REGEXP = qr{ # match a VERSION definition
  (?:
    \(\s*$VARNAME_REGEXP\s*\) # with parens
  |
    $VARNAME_REGEXP           # without parens
  )
  \s*
  =[^=~>]  # = but not ==, nor =~, nor =>
}x;

sub new_from_file {
  my $class    = shift;
  my $filename = File::Spec->rel2abs( shift );

  return undef unless defined( $filename ) && -f $filename;
  return $class->_init(undef, $filename, @@_);
}

sub new_from_handle {
  my $class    = shift;
  my $handle   = shift;
  my $filename = shift;
  return undef unless defined($handle) && defined($filename);
  $filename = File::Spec->rel2abs( $filename );

  return $class->_init(undef, $filename, @@_, handle => $handle);

}


sub new_from_module {
  my $class   = shift;
  my $module  = shift;
  my %props   = @@_;

  $props{inc} ||= \@@INC;
  my $filename = $class->find_module_by_name( $module, $props{inc} );
  return undef unless defined( $filename ) && -f $filename;
  return $class->_init($module, $filename, %props);
}

{

  my $compare_versions = sub {
    my ($v1, $op, $v2) = @@_;
    $v1 = version->new($v1)
      unless UNIVERSAL::isa($v1,'version');

    my $eval_str = "\$v1 $op \$v2";
    my $result   = eval $eval_str;
    log_info { "error comparing versions: '$eval_str' $@@" } if $@@;

    return $result;
  };

  my $normalize_version = sub {
    my ($version) = @@_;
    if ( $version =~ /[=<>!,]/ ) { # logic, not just version
      # take as is without modification
    }
    elsif ( ref $version eq 'version' ) { # version objects
      $version = $version->is_qv ? $version->normal : $version->stringify;
    }
    elsif ( $version =~ /^[^v][^.]*\.[^.]+\./ ) { # no leading v, multiple dots
      # normalize string tuples without "v": "1.2.3" -> "v1.2.3"
      $version = "v$version";
    }
    else {
      # leave alone
    }
    return $version;
  };

  # separate out some of the conflict resolution logic

  my $resolve_module_versions = sub {
    my $packages = shift;

    my( $file, $version );
    my $err = '';
      foreach my $p ( @@$packages ) {
        if ( defined( $p->{version} ) ) {
          if ( defined( $version ) ) {
            if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
              $err .= "  $p->{file} ($p->{version})\n";
            }
            else {
              # same version declared multiple times, ignore
            }
          }
          else {
            $file    = $p->{file};
            $version = $p->{version};
          }
        }
      $file ||= $p->{file} if defined( $p->{file} );
    }

    if ( $err ) {
      $err = "  $file ($version)\n" . $err;
    }

    my %result = (
      file    => $file,
      version => $version,
      err     => $err
    );

    return \%result;
  };

  sub provides {
    my $class = shift;

    croak "provides() requires key/value pairs \n" if @@_ % 2;
    my %args = @@_;

    croak "provides() takes only one of 'dir' or 'files'\n"
      if $args{dir} && $args{files};

    croak "provides() requires a 'version' argument"
      unless defined $args{version};

    croak "provides() does not support version '$args{version}' metadata"
        unless grep { $args{version} eq $_ } qw/1.4 2/;

    $args{prefix} = 'lib' unless defined $args{prefix};

    my $p;
    if ( $args{dir} ) {
      $p = $class->package_versions_from_directory($args{dir});
    }
    else {
      croak "provides() requires 'files' to be an array reference\n"
        unless ref $args{files} eq 'ARRAY';
      $p = $class->package_versions_from_directory($args{files});
    }

    # Now, fix up files with prefix
    if ( length $args{prefix} ) { # check in case disabled with q{}
      $args{prefix} =~ s{/$}{};
      for my $v ( values %$p ) {
        $v->{file} = "$args{prefix}/$v->{file}";
      }
    }

    return $p
  }

  sub package_versions_from_directory {
    my ( $class, $dir, $files ) = @@_;

    my @@files;

    if ( $files ) {
      @@files = @@$files;
    }
    else {
      find( {
        wanted => sub {
          push @@files, $_ if -f $_ && /\.pm$/;
        },
        no_chdir => 1,
      }, $dir );
    }

    # First, we enumerate all packages & versions,
    # separating into primary & alternative candidates
    my( %prime, %alt );
    foreach my $file (@@files) {
      my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
      my @@path = split( /\//, $mapped_filename );
      (my $prime_package = join( '::', @@path )) =~ s/\.pm$//;

      my $pm_info = $class->new_from_file( $file );

      foreach my $package ( $pm_info->packages_inside ) {
        next if $package eq 'main';  # main can appear numerous times, ignore
        next if $package eq 'DB';    # special debugging package, ignore
        next if grep /^_/, split( /::/, $package ); # private package, ignore

        my $version = $pm_info->version( $package );

        $prime_package = $package if lc($prime_package) eq lc($package);
        if ( $package eq $prime_package ) {
          if ( exists( $prime{$package} ) ) {
            croak "Unexpected conflict in '$package'; multiple versions found.\n";
          }
          else {
            $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
            $prime{$package}{file} = $mapped_filename;
            $prime{$package}{version} = $version if defined( $version );
          }
        }
        else {
          push( @@{$alt{$package}}, {
                                    file    => $mapped_filename,
                                    version => $version,
                                   } );
        }
      }
    }

    # Then we iterate over all the packages found above, identifying conflicts
    # and selecting the "best" candidate for recording the file & version
    # for each package.
    foreach my $package ( keys( %alt ) ) {
      my $result = $resolve_module_versions->( $alt{$package} );

      if ( exists( $prime{$package} ) ) { # primary package selected

        if ( $result->{err} ) {
        # Use the selected primary package, but there are conflicting
        # errors among multiple alternative packages that need to be
        # reported
          log_info {
            "Found conflicting versions for package '$package'\n" .
            "  $prime{$package}{file} ($prime{$package}{version})\n" .
            $result->{err}
          };

        }
        elsif ( defined( $result->{version} ) ) {
        # There is a primary package selected, and exactly one
        # alternative package

        if ( exists( $prime{$package}{version} ) &&
             defined( $prime{$package}{version} ) ) {
          # Unless the version of the primary package agrees with the
          # version of the alternative package, report a conflict
        if ( $compare_versions->(
                 $prime{$package}{version}, '!=', $result->{version}
               )
             ) {

            log_info {
              "Found conflicting versions for package '$package'\n" .
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              "  $result->{file} ($result->{version})\n"
            };
          }

        }
        else {
          # The prime package selected has no version so, we choose to
          # use any alternative package that does have a version
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version};
        }

        }
        else {
        # no alt package found with a version, but we have a prime
        # package so we use it whether it has a version or not
        }

      }
      else { # No primary package was selected, use the best alternative

        if ( $result->{err} ) {
          log_info {
            "Found conflicting versions for package '$package'\n" .
            $result->{err}
          };
        }

        # Despite possible conflicting versions, we choose to record
        # something rather than nothing
        $prime{$package}{file}    = $result->{file};
        $prime{$package}{version} = $result->{version}
          if defined( $result->{version} );
      }
    }

    # Normalize versions.  Can't use exists() here because of bug in YAML::Node.
    # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
    for (grep defined $_->{version}, values %prime) {
      $_->{version} = $normalize_version->( $_->{version} );
    }

    return \%prime;
  }
}


sub _init {
  my $class    = shift;
  my $module   = shift;
  my $filename = shift;
  my %props = @@_;

  my $handle = delete $props{handle};
  my( %valid_props, @@valid_props );
  @@valid_props = qw( collect_pod inc );
  @@valid_props{@@valid_props} = delete( @@props{@@valid_props} );
  warn "Unknown properties: @@{[keys %props]}\n" if scalar( %props );

  my %data = (
    module       => $module,
    filename     => $filename,
    version      => undef,
    packages     => [],
    versions     => {},
    pod          => {},
    pod_headings => [],
    collect_pod  => 0,

    %valid_props,
  );

  my $self = bless(\%data, $class);

  if ( not $handle ) {
    my $filename = $self->{filename};
    open $handle, '<', $filename
      or croak( "Can't open '$filename': $!" );

    $self->_handle_bom($handle, $filename);
  }
  $self->_parse_fh($handle);

  unless($self->{module} and length($self->{module})) {
    my ($v, $d, $f) = File::Spec->splitpath($self->{filename});
    if($f =~ /\.pm$/) {
      $f =~ s/\..+$//;
      my @@candidates = grep /$f$/, @@{$self->{packages}};
      $self->{module} = shift(@@candidates); # punt
    }
    else {
      $self->{module} = 'main';
    }
  }

  $self->{version} = $self->{versions}{$self->{module}}
    if defined( $self->{module} );

  return $self;
}

# class method
sub _do_find_module {
  my $class   = shift;
  my $module  = shift || croak 'find_module_by_name() requires a package name';
  my $dirs    = shift || \@@INC;

  my $file = File::Spec->catfile(split( /::/, $module));
  foreach my $dir ( @@$dirs ) {
    my $testfile = File::Spec->catfile($dir, $file);
    return [ File::Spec->rel2abs( $testfile ), $dir ]
      if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
    $testfile .= '.pm';
    return [ File::Spec->rel2abs( $testfile ), $dir ]
      if -e $testfile;
  }
  return;
}

# class method
sub find_module_by_name {
  my $found = shift()->_do_find_module(@@_) or return;
  return $found->[0];
}

# class method
sub find_module_dir_by_name {
  my $found = shift()->_do_find_module(@@_) or return;
  return $found->[1];
}


# given a line of perl code, attempt to parse it if it looks like a
# $VERSION assignment, returning sigil, full name, & package name
sub _parse_version_expression {
  my $self = shift;
  my $line = shift;

  my( $sigil, $variable_name, $package);
  if ( $line =~ /$VERS_REGEXP/o ) {
    ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
    if ( $package ) {
      $package = ($package eq '::') ? 'main' : $package;
      $package =~ s/::$//;
    }
  }

  return ( $sigil, $variable_name, $package );
}

# Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
# If there's one, then skip it and set the :encoding layer appropriately.
sub _handle_bom {
  my ($self, $fh, $filename) = @@_;

  my $pos = tell $fh;
  return unless defined $pos;

  my $buf = ' ' x 2;
  my $count = read $fh, $buf, length $buf;
  return unless defined $count and $count >= 2;

  my $encoding;
  if ( $buf eq "\x{FE}\x{FF}" ) {
    $encoding = 'UTF-16BE';
  }
  elsif ( $buf eq "\x{FF}\x{FE}" ) {
    $encoding = 'UTF-16LE';
  }
  elsif ( $buf eq "\x{EF}\x{BB}" ) {
    $buf = ' ';
    $count = read $fh, $buf, length $buf;
    if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
      $encoding = 'UTF-8';
    }
  }

  if ( defined $encoding ) {
    if ( "$]" >= 5.008 ) {
      binmode( $fh, ":encoding($encoding)" );
    }
  }
  else {
    seek $fh, $pos, SEEK_SET
      or croak( sprintf "Can't reset position to the top of '$filename'" );
  }

  return $encoding;
}

sub _parse_fh {
  my ($self, $fh) = @@_;

  my( $in_pod, $seen_end, $need_vers ) = ( 0, 0, 0 );
  my( @@packages, %vers, %pod, @@pod );
  my $package = 'main';
  my $pod_sect = '';
  my $pod_data = '';
  my $in_end = 0;

  while (defined( my $line = <$fh> )) {
    my $line_num = $.;

    chomp( $line );

    # From toke.c : any line that begins by "=X", where X is an alphabetic
    # character, introduces a POD segment.
    my $is_cut;
    if ( $line =~ /^=([a-zA-Z].*)/ ) {
      my $cmd = $1;
      # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
      # character (which includes the newline, but here we chomped it away).
      $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
      $in_pod = !$is_cut;
    }

    if ( $in_pod ) {

      if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
        push( @@pod, $1 );
        if ( $self->{collect_pod} && length( $pod_data ) ) {
          $pod{$pod_sect} = $pod_data;
          $pod_data = '';
        }
        $pod_sect = $1;
      }
      elsif ( $self->{collect_pod} ) {
        $pod_data .= "$line\n";
      }
      next;
    }
    elsif ( $is_cut ) {
      if ( $self->{collect_pod} && length( $pod_data ) ) {
        $pod{$pod_sect} = $pod_data;
        $pod_data = '';
      }
      $pod_sect = '';
      next;
    }

    # Skip after __END__
    next if $in_end;

    # Skip comments in code
    next if $line =~ /^\s*#/;

    # Would be nice if we could also check $in_string or something too
    if ($line eq '__END__') {
      $in_end++;
      next;
    }

    last if $line eq '__DATA__';

    # parse $line to see if it's a $VERSION declaration
    my( $version_sigil, $version_fullname, $version_package ) =
      index($line, 'VERSION') >= 1
        ? $self->_parse_version_expression( $line )
        : ();

    if ( $line =~ /$PKG_REGEXP/o ) {
      $package = $1;
      my $version = $2;
      push( @@packages, $package ) unless grep( $package eq $_, @@packages );
      $need_vers = defined $version ? 0 : 1;

      if ( not exists $vers{$package} and defined $version ){
        # Upgrade to a version object.
        my $dwim_version = eval { _dwim_version($version) };
        croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@@\n"
          unless defined $dwim_version;  # "0" is OK!
        $vers{$package} = $dwim_version;
      }
    }

    # VERSION defined with full package spec, i.e. $Module::VERSION
    elsif ( $version_fullname && $version_package ) {
      # we do NOT save this package in found @@packages
      $need_vers = 0 if $version_package eq $package;

      unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
        $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
      }
    }

    # first non-comment line in undeclared package main is VERSION
    elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
      $need_vers = 0;
      my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
      $vers{$package} = $v;
      push( @@packages, 'main' );
    }

    # first non-comment line in undeclared package defines package main
    elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
      $need_vers = 1;
      $vers{main} = '';
      push( @@packages, 'main' );
    }

    # only keep if this is the first $VERSION seen
    elsif ( $version_fullname && $need_vers ) {
      $need_vers = 0;
      my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );

      unless ( defined $vers{$package} && length $vers{$package} ) {
        $vers{$package} = $v;
      }
    }
  } # end loop over each line

  if ( $self->{collect_pod} && length($pod_data) ) {
    $pod{$pod_sect} = $pod_data;
  }

  $self->{versions} = \%vers;
  $self->{packages} = \@@packages;
  $self->{pod} = \%pod;
  $self->{pod_headings} = \@@pod;
}

{
my $pn = 0;
sub _evaluate_version_line {
  my $self = shift;
  my( $sigil, $variable_name, $line ) = @@_;

  # We compile into a local sub because 'use version' would cause
  # compiletime/runtime issues with local()
  $pn++; # everybody gets their own package
  my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
    #; package Module::Metadata::_version::p${pn};
    use version;
    sub {
      local $sigil$variable_name;
      $line;
      return \$$variable_name if defined \$$variable_name;
      return \$Module::Metadata::_version::p${pn}::$variable_name;
    };
  };

  $eval = $1 if $eval =~ m{^(.+)}s;

  local $^W;
  # Try to get the $VERSION
  my $vsub = __clean_eval($eval);
  # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
  # installed, so we need to hunt in ./lib for it
  if ( $@@ =~ /Can't locate/ && -d 'lib' ) {
    local @@INC = ('lib',@@INC);
    $vsub = __clean_eval($eval);
  }
  warn "Error evaling version line '$eval' in $self->{filename}: $@@\n"
    if $@@;

  (ref($vsub) eq 'CODE') or
    croak "failed to build version sub for $self->{filename}";

  my $result = eval { $vsub->() };
  # FIXME: $eval is not the right thing to print here
  croak "Could not get version from $self->{filename} by executing:\n$eval\n\nThe fatal error was: $@@\n"
    if $@@;

  # Upgrade it into a version object
  my $version = eval { _dwim_version($result) };

  # FIXME: $eval is not the right thing to print here
  croak "Version '$result' from $self->{filename} does not appear to be valid:\n$eval\n\nThe fatal error was: $@@\n"
    unless defined $version; # "0" is OK!

  return $version;
}
}

# Try to DWIM when things fail the lax version test in obvious ways
{
  my @@version_prep = (
    # Best case, it just works
    sub { return shift },

    # If we still don't have a version, try stripping any
    # trailing junk that is prohibited by lax rules
    sub {
      my $v = shift;
      $v =~ s{([0-9])[a-z-].*$}{$1}i; # 1.23-alpha or 1.23b
      return $v;
    },

    # Activestate apparently creates custom versions like '1.23_45_01', which
    # cause version.pm to think it's an invalid alpha.  So check for that
    # and strip them
    sub {
      my $v = shift;
      my $num_dots = () = $v =~ m{(\.)}g;
      my $num_unders = () = $v =~ m{(_)}g;
      my $leading_v = substr($v,0,1) eq 'v';
      if ( ! $leading_v && $num_dots < 2 && $num_unders > 1 ) {
        $v =~ s{_}{}g;
        $num_unders = () = $v =~ m{(_)}g;
      }
      return $v;
    },

    # Worst case, try numifying it like we would have before version objects
    sub {
      my $v = shift;
      no warnings 'numeric';
      return 0 + $v;
    },

  );

  sub _dwim_version {
    my ($result) = shift;

    return $result if ref($result) eq 'version';

    my ($version, $error);
    for my $f (@@version_prep) {
      $result = $f->($result);
      $version = eval { version->new($result) };
      $error ||= $@@ if $@@; # capture first failure
      last if defined $version;
    }

    croak $error unless defined $version;

    return $version;
  }
}

############################################################

# accessors
sub name            { $_[0]->{module}            }

sub filename        { $_[0]->{filename}          }
sub packages_inside { @@{$_[0]->{packages}}       }
sub pod_inside      { @@{$_[0]->{pod_headings}}   }
sub contains_pod    { 0+@@{$_[0]->{pod_headings}} }

sub version {
    my $self = shift;
    my $mod  = shift || $self->{module};
    my $vers;
    if ( defined( $mod ) && length( $mod ) &&
         exists( $self->{versions}{$mod} ) ) {
        return $self->{versions}{$mod};
    }
    else {
        return undef;
    }
}

sub pod {
    my $self = shift;
    my $sect = shift;
    if ( defined( $sect ) && length( $sect ) &&
         exists( $self->{pod}{$sect} ) ) {
        return $self->{pod}{$sect};
    }
    else {
        return undef;
    }
}

sub is_indexable {
  my ($self, $package) = @@_;

  my @@indexable_packages = grep { $_ ne 'main' } $self->packages_inside;

  # check for specific package, if provided
  return !! grep { $_ eq $package } @@indexable_packages if $package;

  # otherwise, check for any indexable packages at all
  return !! @@indexable_packages;
}

1;

__END__

=pod

=encoding UTF-8

=head1 NAME

Module::Metadata - Gather package and POD information from perl module files

=head1 VERSION

version 1.000031

=head1 SYNOPSIS

  use Module::Metadata;

  # information about a .pm file
  my $info = Module::Metadata->new_from_file( $file );
  my $version = $info->version;

  # CPAN META 'provides' field for .pm files in a directory
  my $provides = Module::Metadata->provides(
    dir => 'lib', version => 2
  );

=head1 DESCRIPTION

This module provides a standard way to gather metadata about a .pm file through
(mostly) static analysis and (some) code execution.  When determining the
version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
in the CPAN toolchain.

=head1 CLASS METHODS

=head2 C<< new_from_file($filename, collect_pod => 1) >>

Constructs a C<Module::Metadata> object given the path to a file.  Returns
undef if the filename does not exist.

C<collect_pod> is a optional boolean argument that determines whether POD
data is collected and stored for reference.  POD data is not collected by
default.  POD headings are always collected.

If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
it is skipped before processing, and the content of the file is also decoded
appropriately starting from perl 5.8.

=head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>

This works just like C<new_from_file>, except that a handle can be provided
as the first argument.

Note that there is no validation to confirm that the handle is a handle or
something that can act like one.  Passing something that isn't a handle will
cause a exception when trying to read from it.  The C<filename> argument is
mandatory or undef will be returned.

You are responsible for setting the decoding layers on C<$handle> if
required.

=head2 C<< new_from_module($module, collect_pod => 1, inc => \@@dirs) >>

Constructs a C<Module::Metadata> object given a module or package name.
Returns undef if the module cannot be found.

In addition to accepting the C<collect_pod> argument as described above,
this method accepts a C<inc> argument which is a reference to an array of
directories to search for the module.  If none are given, the default is
@@INC.

If the file that contains the module begins by an UTF-8, UTF-16BE or
UTF-16LE byte-order mark, then it is skipped before processing, and the
content of the file is also decoded appropriately starting from perl 5.8.

=head2 C<< find_module_by_name($module, \@@dirs) >>

Returns the path to a module given the module or package name. A list
of directories can be passed in as an optional parameter, otherwise
@@INC is searched.

Can be called as either an object or a class method.

=head2 C<< find_module_dir_by_name($module, \@@dirs) >>

Returns the entry in C<@@dirs> (or C<@@INC> by default) that contains
the module C<$module>. A list of directories can be passed in as an
optional parameter, otherwise @@INC is searched.

Can be called as either an object or a class method.

=head2 C<< provides( %options ) >>

This is a convenience wrapper around C<package_versions_from_directory>
to generate a CPAN META C<provides> data structure.  It takes key/value
pairs.  Valid option keys include:

=over

=item version B<(required)>

Specifies which version of the L<CPAN::Meta::Spec> should be used as
the format of the C<provides> output.  Currently only '1.4' and '2'
are supported (and their format is identical).  This may change in
the future as the definition of C<provides> changes.

The C<version> option is required.  If it is omitted or if
an unsupported version is given, then C<provides> will throw an error.

=item dir

Directory to search recursively for F<.pm> files.  May not be specified with
C<files>.

=item files

Array reference of files to examine.  May not be specified with C<dir>.

=item prefix

String to prepend to the C<file> field of the resulting output. This defaults
to F<lib>, which is the common case for most CPAN distributions with their
F<.pm> files in F<lib>.  This option ensures the META information has the
correct relative path even when the C<dir> or C<files> arguments are
absolute or have relative paths from a location other than the distribution
root.

=back

For example, given C<dir> of 'lib' and C<prefix> of 'lib', the return value
is a hashref of the form:

  {
    'Package::Name' => {
      version => '0.123',
      file => 'lib/Package/Name.pm'
    },
    'OtherPackage::Name' => ...
  }

=head2 C<< package_versions_from_directory($dir, \@@files?) >>

Scans C<$dir> for .pm files (unless C<@@files> is given, in which case looks
for those files in C<$dir> - and reads each file for packages and versions,
returning a hashref of the form:

  {
    'Package::Name' => {
      version => '0.123',
      file => 'Package/Name.pm'
    },
    'OtherPackage::Name' => ...
  }

The C<DB> and C<main> packages are always omitted, as are any "private"
packages that have leading underscores in the namespace (e.g.
C<Foo::_private>)

Note that the file path is relative to C<$dir> if that is specified.
This B<must not> be used directly for CPAN META C<provides>.  See
the C<provides> method instead.

=head2 C<< log_info (internal) >>

Used internally to perform logging; imported from Log::Contextual if
Log::Contextual has already been loaded, otherwise simply calls warn.

=head1 OBJECT METHODS

=head2 C<< name() >>

Returns the name of the package represented by this module. If there
is more than one package, it makes a best guess based on the
filename. If it's a script (i.e. not a *.pm) the package name is
'main'.

=head2 C<< version($package) >>

Returns the version as defined by the $VERSION variable for the
package as returned by the C<name> method if no arguments are
given. If given the name of a package it will attempt to return the
version of that package if it is specified in the file.

=head2 C<< filename() >>

Returns the absolute path to the file.
Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.

=head2 C<< packages_inside() >>

Returns a list of packages. Note: this is a raw list of packages
discovered (or assumed, in the case of C<main>).  It is not
filtered for C<DB>, C<main> or private packages the way the
C<provides> method does.  Invalid package names are not returned,
for example "Foo:Bar".  Strange but valid package names are
returned, for example "Foo::Bar::", and are left up to the caller
on how to handle.

=head2 C<< pod_inside() >>

Returns a list of POD sections.

=head2 C<< contains_pod() >>

Returns true if there is any POD in the file.

=head2 C<< pod($section) >>

Returns the POD data in the given section.

=head2 C<< is_indexable($package) >> or C<< is_indexable() >>

Available since version 1.000020.

Returns a boolean indicating whether the package (if provided) or any package
(otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
Note This only checks for valid C<package> declarations, and does not take any
ownership information into account.

=head1 SUPPORT

Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata>
(or L<bug-Module-Metadata@@rt.cpan.org|mailto:bug-Module-Metadata@@rt.cpan.org>).

There is also a mailing list available for users of this distribution, at
L<http://lists.perl.org/list/cpan-workers.html>.

There is also an irc channel available for users of this distribution, at
L<irc://irc.perl.org/#toolchain>.

=head1 AUTHOR

Original code from Module::Build::ModuleInfo by Ken Williams
<kwilliams@@cpan.org>, Randy W. Sims <RandyS@@ThePierianSpring.org>

Released as Module::Metadata by Matt S Trout (mst) <mst@@shadowcat.co.uk> with
assistance from David Golden (xdg) <dagolden@@cpan.org>.

=head1 CONTRIBUTORS

=for stopwords Karen Etheridge David Golden Vincent Pit Matt S Trout Chris Nehren Graham Knop Olivier Mengu√© Tomas Doran Tatsuhiko Miyagawa tokuhirom Peter Rabbitson Steve Hay Josh Jore Craig A. Berry Mitchell Steinbrunner Edward Zborowski Gareth Harper James Raspass Jerry D. Hedden 'BinGOs' Williams Kent Fredric

=over 4

=item *

Karen Etheridge <ether@@cpan.org>

=item *

David Golden <dagolden@@cpan.org>

=item *

Vincent Pit <perl@@profvince.com>

=item *

Matt S Trout <mst@@shadowcat.co.uk>

=item *

Chris Nehren <apeiron@@cpan.org>

=item *

Graham Knop <haarg@@haarg.org>

=item *

Olivier Mengu√© <dolmen@@cpan.org>

=item *

Tomas Doran <bobtfish@@bobtfish.net>

=item *

Tatsuhiko Miyagawa <miyagawa@@bulknews.net>

=item *

tokuhirom <tokuhirom@@gmail.com>

=item *

Peter Rabbitson <ribasushi@@cpan.org>

=item *

Steve Hay <steve.m.hay@@googlemail.com>

=item *

Josh Jore <jjore@@cpan.org>

=item *

Craig A. Berry <cberry@@cpan.org>

=item *

David Mitchell <davem@@iabyn.com>

=item *

David Steinbrunner <dsteinbrunner@@pobox.com>

=item *

Edward Zborowski <ed@@rubensteintech.com>

=item *

Gareth Harper <gareth@@broadbean.com>

=item *

James Raspass <jraspass@@gmail.com>

=item *

Jerry D. Hedden <jdhedden@@cpan.org>

=item *

Chris 'BinGOs' Williams <chris@@bingosnet.co.uk>

=item *

Kent Fredric <kentnl@@cpan.org>

=back

=head1 COPYRIGHT & LICENSE

Original code Copyright (c) 2001-2011 Ken Williams.
Additional code Copyright (c) 2010-2011 Matt Trout and David Golden.
All rights reserved.

This library is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
package Module::Metadata;
d13 1
d15 3
a17 3
use vars qw($VERSION);
$VERSION = '1.000009';
$VERSION = eval $VERSION;
d21 6
a26 1
use IO::File;
d30 6
a35 2
    Log::Contextual->import('log_info');
  } else {
d43 28
d75 1
a75 1
  ([\w:]+)              # a package name
d86 1
a86 1
      (?:::|\')?  # possibly starting like just :: (Ã  la $::VERSION)
d100 1
a100 1
  =[^=~]  # = but not ==, nor =~
a102 1

d135 1
a135 1
  
d140 1
a140 1
  
d144 1
a144 1
  
d170 1
a170 1
  
d175 12
a186 10
  	if ( defined( $version ) ) {
   	  if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
  	    $err .= "  $p->{file} ($p->{version})\n";
  	  } else {
  	    # same version declared multiple times, ignore
  	  }
  	} else {
  	  $file    = $p->{file};
  	  $version = $p->{version};
  	}
d188 3
a190 3
        $file ||= $p->{file} if defined( $p->{file} );
      }
  
d194 1
a194 1
  
d200 1
a200 1
  
d249 2
a250 1
    } else {
d263 1
a263 1
      my $mapped_filename = File::Spec->abs2rel( $file, $dir );
d266 1
a266 1
  
d268 1
a268 1
  
d273 1
a273 1
  
d275 2
a276 1
  
d280 3
a282 1
          } else {
d286 2
a287 1
        } else {
d295 1
a295 1
  
d301 1
a301 1
  
d303 1
a303 1
  
d305 3
a307 3
  	# Use the selected primary package, but there are conflicting
  	# errors among multiple alternative packages that need to be
  	# reported
d309 3
a311 3
  	    "Found conflicting versions for package '$package'\n" .
  	    "  $prime{$package}{file} ($prime{$package}{version})\n" .
  	    $result->{err}
d313 11
a323 10
  
        } elsif ( defined( $result->{version} ) ) {
  	# There is a primary package selected, and exactly one
  	# alternative package
  
  	if ( exists( $prime{$package}{version} ) &&
  	     defined( $prime{$package}{version} ) ) {
  	  # Unless the version of the primary package agrees with the
  	  # version of the alternative package, report a conflict
  	  if ( $compare_versions->(
d330 2
a331 2
  	      "  $prime{$package}{file} ($prime{$package}{version})\n" .
  	      "  $result->{file} ($result->{version})\n"
d333 14
a346 12
  	  }
  
  	} else {
  	  # The prime package selected has no version so, we choose to
  	  # use any alternative package that does have a version
  	  $prime{$package}{file}    = $result->{file};
  	  $prime{$package}{version} = $result->{version};
  	}
  
        } else {
  	# no alt package found with a version, but we have a prime
  	# package so we use it whether it has a version or not
d348 4
a351 3
  
      } else { # No primary package was selected, use the best alternative
  
d355 1
a355 1
  	    $result->{err}
d358 1
a358 1
  
d363 1
a363 1
  	  if defined( $result->{version} );
d366 1
a366 1
  
d368 1
a368 1
    # XXX "bug in YAML::Node" comment seems irrelvant -- dagolden, 2009-05-18
d372 1
a372 1
  
d375 2
a376 2
} 
  
d405 6
a410 5
  if ( $handle ) {
    $self->_parse_fh($handle);
  }
  else {
    $self->_parse_file();
d412 1
d422 1
a422 6
      if(grep /main/, @@{$self->{packages}}) {
        $self->{module} = 'main';
      }
      else {
        $self->{module} = $self->{packages}[0] || '';
      }
d427 1
a427 1
      if defined( $self->{module} );
d442 4
a445 3
	if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
    return [ File::Spec->rel2abs( "$testfile.pm" ), $dir ]
	if -e "$testfile.pm";
d469 6
a474 6
  my( $sig, $var, $pkg );
  if ( $line =~ $VERS_REGEXP ) {
    ( $sig, $var, $pkg ) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
    if ( $pkg ) {
      $pkg = ($pkg eq '::') ? 'main' : $pkg;
      $pkg =~ s/::$//;
d478 1
a478 1
  return ( $sig, $var, $pkg );
d481 26
a506 2
sub _parse_file {
  my $self = shift;
d508 9
a516 3
  my $filename = $self->{filename};
  my $fh = IO::File->new( $filename )
    or croak( "Can't open '$filename': $!" );
d518 1
a518 1
  $self->_parse_fh($fh);
d525 2
a526 2
  my( @@pkgs, %vers, %pod, @@pod );
  my $pkg = 'main';
d529 1
a534 1
    next if $line =~ /^\s*#/;
d536 10
a545 4
    $in_pod = ($line =~ /^=(?!cut)/) ? 1 : ($line =~ /^=cut/) ? 0 : $in_pod;

    # Would be nice if we could also check $in_string or something too
    last if !$in_pod && $line =~ /^__(?:DATA|END)__$/;
d547 1
a547 1
    if ( $in_pod || $line =~ /^=cut/ ) {
d549 3
a551 3
      if ( $line =~ /^=head\d\s+(.+)\s*$/ ) {
	push( @@pod, $1 );
	if ( $self->{collect_pod} && length( $pod_data ) ) {
d555 15
a569 1
	$pod_sect = $1;
d571 2
d574 2
a575 2
      } elsif ( $self->{collect_pod} ) {
	$pod_data .= "$line\n";
d577 5
a581 1
      }
d583 1
a583 1
    } else {
d585 20
a604 2
      $pod_sect = '';
      $pod_data = '';
d606 4
a609 57
      # parse $line to see if it's a $VERSION declaration
      my( $vers_sig, $vers_fullname, $vers_pkg ) =
	  $self->_parse_version_expression( $line );

      if ( $line =~ $PKG_REGEXP ) {
        $pkg = $1;
        push( @@pkgs, $pkg ) unless grep( $pkg eq $_, @@pkgs );
        $vers{$pkg} = (defined $2 ? $2 : undef)  unless exists( $vers{$pkg} );
        $need_vers = defined $2 ? 0 : 1;

      # VERSION defined with full package spec, i.e. $Module::VERSION
      } elsif ( $vers_fullname && $vers_pkg ) {
	push( @@pkgs, $vers_pkg ) unless grep( $vers_pkg eq $_, @@pkgs );
	$need_vers = 0 if $vers_pkg eq $pkg;

	unless ( defined $vers{$vers_pkg} && length $vers{$vers_pkg} ) {
	  $vers{$vers_pkg} =
	    $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
	} else {
	  # Warn unless the user is using the "$VERSION = eval
	  # $VERSION" idiom (though there are probably other idioms
	  # that we should watch out for...)
	  warn <<"EOM" unless $line =~ /=\s*eval/;
Package '$vers_pkg' already declared with version '$vers{$vers_pkg}',
ignoring subsequent declaration on line $line_num.
EOM
	}

      # first non-comment line in undeclared package main is VERSION
      } elsif ( !exists($vers{main}) && $pkg eq 'main' && $vers_fullname ) {
	$need_vers = 0;
	my $v =
	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );
	$vers{$pkg} = $v;
	push( @@pkgs, 'main' );

      # first non-comment line in undeclared package defines package main
      } elsif ( !exists($vers{main}) && $pkg eq 'main' && $line =~ /\w+/ ) {
	$need_vers = 1;
	$vers{main} = '';
	push( @@pkgs, 'main' );

      # only keep if this is the first $VERSION seen
      } elsif ( $vers_fullname && $need_vers ) {
	$need_vers = 0;
	my $v =
	  $self->_evaluate_version_line( $vers_sig, $vers_fullname, $line );


	unless ( defined $vers{$pkg} && length $vers{$pkg} ) {
	  $vers{$pkg} = $v;
	} else {
	  warn <<"EOM";
Package '$pkg' already declared with version '$vers{$pkg}'
ignoring new version '$v' on line $line_num.
EOM
	}
d611 2
d614 9
d624 5
d631 10
a640 1
  }
d647 1
a647 1
  $self->{packages} = \@@pkgs;
d656 1
a656 3
  my( $sigil, $var, $line ) = @@_;

  # Some of this code came from the ExtUtils:: hierarchy.
d658 1
a658 1
  # We compile into $vsub because 'use version' would cause
a659 1
  my $vsub;
d661 2
a662 2
  my $eval = qq{BEGIN { q#  Hide from _packages_inside()
    #; package Module::Metadata::_version::p$pn;
d664 7
a670 1
    no strict;
d672 1
a672 7
      \$vsub = sub {
        local $sigil$var;
        \$$var=undef;
        $line;
        \$$var
      };
  }};
d676 2
a677 2
  eval $eval;
  # some modules say $VERSION = $Foo::Bar::VERSION, but Foo::Bar isn't
d681 1
a681 1
    eval $eval;
d685 1
d688 1
d690 1
d697 1
d765 1
a765 1
sub name            { $_[0]->{module}           }
d767 4
a770 4
sub filename        { $_[0]->{filename}         }
sub packages_inside { @@{$_[0]->{packages}}      }
sub pod_inside      { @@{$_[0]->{pod_headings}}  }
sub contains_pod    { $#{$_[0]->{pod_headings}} }
d777 5
a781 4
	 exists( $self->{versions}{$mod} ) ) {
	return $self->{versions}{$mod};
    } else {
	return undef;
d789 5
a793 4
	 exists( $self->{pod}{$sect} ) ) {
	return $self->{pod}{$sect};
    } else {
	return undef;
d797 12
d811 6
d821 4
d840 4
a843 2
This module provides a standard way to gather metadata about a .pm file
without executing unsafe code.
d845 1
a845 1
=head1 USAGE
d847 1
a847 1
=head2 Class methods
d849 2
a850 1
=over 4
d852 3
a854 1
=item C<< new_from_file($filename, collect_pod => 1) >>
d856 3
a858 5
Construct a C<Module::Metadata> object given the path to a file. Takes an
optional argument C<collect_pod> which is a boolean that determines whether POD
data is collected and stored for reference. POD data is not collected by
default. POD headings are always collected.  Returns undef if the filename
does not exist.
d860 1
a860 1
=item C<< new_from_handle($handle, $filename, collect_pod => 1) >>
d863 6
a868 12
as the first argument.  Note that there is no validation to confirm that the
handle is a handle or something that can act like one.  Passing something that
isn't a handle will cause a exception when trying to read from it.  The
C<filename> argument is mandatory or undef will be returned.

=item C<< new_from_module($module, collect_pod => 1, inc => \@@dirs) >>

Construct a C<Module::Metadata> object given a module or package name. In addition
to accepting the C<collect_pod> argument as described above, this
method accepts a C<inc> argument which is a reference to an array of
of directories to search for the module. If none are given, the
default is @@INC.  Returns undef if the module cannot be found.
d870 18
a887 1
=item C<< find_module_by_name($module, \@@dirs) >>
d895 1
a895 1
=item C<< find_module_dir_by_name($module, \@@dirs) >>
d903 1
a903 1
=item C<< provides( %options ) >>
d952 1
a952 1
=item C<< package_versions_from_directory($dir, \@@files?) >>
d974 1
a974 1
=item C<< log_info (internal) >>
d979 1
a979 1
=back
d981 1
a981 5
=head2 Object methods

=over 4

=item C<< name() >>
d984 1
a984 1
are more than one packages, it makes a best guess based on the
d988 1
a988 1
=item C<< version($package) >>
d995 1
a995 1
=item C<< filename() >>
d998 1
d1000 1
a1000 1
=item C<< packages_inside() >>
d1005 4
a1008 1
C<provides> method does.
d1010 1
a1010 1
=item C<< pod_inside() >>
d1014 1
a1014 1
=item C<< contains_pod() >>
d1018 1
a1018 1
=item C<< pod($section) >>
d1022 19
a1040 1
=back
d1050 97
a1146 1
=head1 COPYRIGHT
a1155 1

@


1.1.1.1
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@@


1.1.1.2
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d14 1
a14 1
$VERSION = '1.000011';
d64 1
d222 1
a222 1
      my $mapped_filename = File::Spec::Unix->abs2rel( $file, $dir );
a234 1
        $prime_package = $package if lc($prime_package) eq lc($package);
a238 1
            $mapped_filename = "$package.pm" if lc("$package.pm") eq lc($mapped_filename);
d423 1
a423 1
  if ( $line =~ /$VERS_REGEXP/o ) {
a440 2
  $self->_handle_bom($fh, $filename);

a443 38
# Look for a UTF-8/UTF-16BE/UTF-16LE BOM at the beginning of the stream.
# If there's one, then skip it and set the :encoding layer appropriately.
sub _handle_bom {
  my ($self, $fh, $filename) = @@_;

  my $pos = $fh->getpos;
  return unless defined $pos;

  my $buf = ' ' x 2;
  my $count = $fh->read( $buf, length $buf );
  return unless defined $count and $count >= 2;

  my $encoding;
  if ( $buf eq "\x{FE}\x{FF}" ) {
    $encoding = 'UTF-16BE';
  } elsif ( $buf eq "\x{FF}\x{FE}" ) {
    $encoding = 'UTF-16LE';
  } elsif ( $buf eq "\x{EF}\x{BB}" ) {
    $buf = ' ';
    $count = $fh->read( $buf, length $buf );
    if ( defined $count and $count >= 1 and $buf eq "\x{BF}" ) {
      $encoding = 'UTF-8';
    }
  }

  if ( defined $encoding ) {
    if ( "$]" >= 5.008 ) {
      # $fh->binmode requires perl 5.10
      binmode( $fh, ":encoding($encoding)" );
    }
  } else {
    $fh->setpos($pos)
      or croak( sprintf "Can't reset position to the top of '$filename'" );
  }

  return $encoding;
}

d457 3
d461 2
a462 10
    # From toke.c : any line that begins by "=X", where X is an alphabetic
    # character, introduces a POD segment.
    my $is_cut;
    if ( $line =~ /^=([a-zA-Z].*)/ ) {
      my $cmd = $1;
      # Then it goes back to Perl code for "=cutX" where X is a non-alphabetic
      # character (which includes the newline, but here we chomped it away).
      $is_cut = $cmd =~ /^cut(?:[^a-zA-Z]|$)/;
      $in_pod = !$is_cut;
    }
d464 1
a464 1
    if ( $in_pod ) {
d466 1
a466 1
      if ( $line =~ /^=head[1-4]\s+(.+)\s*$/ ) {
d474 1
d480 1
a480 1
    } elsif ( $is_cut ) {
a481 4
      if ( $self->{collect_pod} && length( $pod_data ) ) {
        $pod{$pod_sect} = $pod_data;
        $pod_data = '';
      }
d483 1
a483 8

    } else {

      # Skip comments in code
      next if $line =~ /^\s*#/;

      # Would be nice if we could also check $in_string or something too
      last if $line =~ /^__(?:DATA|END)__$/;
d487 1
a487 3
          ($line =~ /VERSION/)
              ? $self->_parse_version_expression( $line )
              : ();
d489 1
a489 1
      if ( $line =~ /$PKG_REGEXP/o ) {
d492 1
a492 1
        $vers{$pkg} = $2 unless exists( $vers{$pkg} );
d503 8
d536 6
a541 1
	} 
d733 5
a737 10
Constructs a C<Module::Metadata> object given the path to a file.  Returns
undef if the filename does not exist.

C<collect_pod> is a optional boolean argument that determines whether POD
data is collected and stored for reference.  POD data is not collected by
default.  POD headings are always collected.

If the file begins by an UTF-8, UTF-16BE or UTF-16LE byte-order mark, then
it is skipped before processing, and the content of the file is also decoded
appropriately starting from perl 5.8.
d742 4
a745 9
as the first argument.

Note that there is no validation to confirm that the handle is a handle or
something that can act like one.  Passing something that isn't a handle will
cause a exception when trying to read from it.  The C<filename> argument is
mandatory or undef will be returned.

You are responsible for setting the decoding layers on C<$handle> if
required.
d749 5
a753 11
Constructs a C<Module::Metadata> object given a module or package name.
Returns undef if the module cannot be found.

In addition to accepting the C<collect_pod> argument as described above,
this method accepts a C<inc> argument which is a reference to an array of
directories to search for the module.  If none are given, the default is
@@INC.

If the file that contains the module begins by an UTF-8, UTF-16BE or
UTF-16LE byte-order mark, then it is skipped before processing, and the
content of the file is also decoded appropriately starting from perl 5.8.
d900 1
a900 1
=head1 COPYRIGHT & LICENSE
@


1.1.1.3
log
@Import perl-5.20.1
@
text
@d13 2
a14 3
use warnings;

our $VERSION = '1.000019';
a31 28
my $PKG_FIRST_WORD_REGEXP = qr{ # the FIRST word in a package name
  [a-zA-Z_]                     # the first word CANNOT start with a digit
    (?:
      [\w']?                    # can contain letters, digits, _, or ticks
      \w                        # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_ADDL_WORD_REGEXP = qr{ # the 2nd+ word in a package name
  \w                           # the 2nd+ word CAN start with digits
    (?:
      [\w']?                   # and can contain letters or ticks
      \w                       # But, NO multi-ticks or trailing ticks
    )*
}x;

my $PKG_NAME_REGEXP = qr{ # match a package name
  (?: :: )?               # a pkg name can start with aristotle
  $PKG_FIRST_WORD_REGEXP  # a package word
  (?:
    (?: :: )+             ### aristotle (allow one or many times)
    $PKG_ADDL_WORD_REGEXP ### a package word
  )*                      # ^ zero, one or many times
  (?:
    ::                    # allow trailing aristotle
  )?
}x;

d36 1
a36 1
  ($PKG_NAME_REGEXP)    # a package name
d96 1
a96 1

d101 1
a101 1

d105 1
a105 1

d131 1
a131 1

d149 1
a149 1

d153 1
a153 1

d159 1
a159 1

d224 1
a224 1

d226 1
a226 1

d231 1
a231 1

d233 1
a233 1

d251 1
a251 1

d257 1
a257 1

d259 1
a259 1

d269 1
a269 1

d273 1
a273 1

d289 1
a289 1

d296 1
a296 1

d301 1
a301 1

d303 1
a303 1

d310 1
a310 1

d318 1
a318 1

d320 1
a320 1
    # XXX "bug in YAML::Node" comment seems irrelevant -- dagolden, 2009-05-18
d324 1
a324 1

d327 2
a328 2
}

a492 1
  my $in_end = 0;
a534 3
      # Skip after __END__
      next if $in_end;

d539 1
a539 5
      if ($line eq '__END__') {
        $in_end++;
        next;
      }
      last if $line eq '__DATA__';
d586 1
a586 1
	}
d616 1
a616 1
  my $eval = qq{BEGIN { my \$dummy = q#  Hide from _packages_inside()
a619 1
    no warnings;
a628 2
  $eval = $1 if $eval =~ m{^(.+)}s;

d716 1
a716 1
sub name            { $_[0]->{module}            }
d718 4
a721 4
sub filename        { $_[0]->{filename}          }
sub packages_inside { @@{$_[0]->{packages}}       }
sub pod_inside      { @@{$_[0]->{pod_headings}}   }
sub contains_pod    { 0+@@{$_[0]->{pod_headings}} }
d767 2
a768 4
This module provides a standard way to gather metadata about a .pm file through
(mostly) static analysis and (some) code execution.  When determining the
version of a module, the C<$VERSION> assignment is C<eval>ed, as is traditional
in the CPAN toolchain.
d937 1
a937 4
C<provides> method does.  Invalid package names are not returned,
for example "Foo:Bar".  Strange but valid package names are
returned, for example "Foo::Bar::", and are left up to the caller
on how to handle.
@


1.1.1.4
log
@Import perl-5.24.2
@
text
@d3 1
a3 2
package Module::Metadata; # git description: v1.000030-2-g52f466c
# ABSTRACT: Gather package and POD information from perl module files
a11 1
sub __clean_eval { eval $_[0] }
d15 2
a16 1
our $VERSION = '1.000031'; # TRIAL
d20 1
a20 6
BEGIN {
       # Try really hard to not depend ony any DynaLoaded module, such as IO::File or Fcntl
       eval {
               require Fcntl; Fcntl->import('SEEK_SET'); 1;
       } or *SEEK_SET = sub { 0 }
}
d24 2
a25 6
    require "Log/Contextual/WarnLogger.pm"; # Hide from AutoPrereqs
    Log::Contextual->import('log_info',
      '-default_logger' => Log::Contextual::WarnLogger->new({ env_prefix => 'MODULE_METADATA', }),
    );
  }
  else {
d50 1
a50 1
  (?: :: )?               # a pkg name can start with arisdottle
d53 1
a53 1
    (?: :: )+             ### arisdottle (allow one or many times)
d57 1
a57 1
    ::                    # allow trailing arisdottle
d76 1
a76 1
      (?:::|\')?  # possibly starting like just :: (a la $::VERSION)
d90 1
a90 1
  =[^=~>]  # = but not ==, nor =~, nor =>
d165 10
a174 12
          if ( defined( $version ) ) {
            if ( $compare_versions->( $version, '!=', $p->{version} ) ) {
              $err .= "  $p->{file} ($p->{version})\n";
            }
            else {
              # same version declared multiple times, ignore
            }
          }
          else {
            $file    = $p->{file};
            $version = $p->{version};
          }
d176 2
a177 2
      $file ||= $p->{file} if defined( $p->{file} );
    }
d237 1
a237 2
    }
    else {
d267 1
a267 2
          }
          else {
d272 1
a272 2
        }
        else {
d290 3
a292 3
        # Use the selected primary package, but there are conflicting
        # errors among multiple alternative packages that need to be
        # reported
d294 3
a296 3
            "Found conflicting versions for package '$package'\n" .
            "  $prime{$package}{file} ($prime{$package}{version})\n" .
            $result->{err}
d299 9
a307 10
        }
        elsif ( defined( $result->{version} ) ) {
        # There is a primary package selected, and exactly one
        # alternative package

        if ( exists( $prime{$package}{version} ) &&
             defined( $prime{$package}{version} ) ) {
          # Unless the version of the primary package agrees with the
          # version of the alternative package, report a conflict
        if ( $compare_versions->(
d314 2
a315 2
              "  $prime{$package}{file} ($prime{$package}{version})\n" .
              "  $result->{file} ($result->{version})\n"
d317 1
a317 1
          }
d319 10
a328 6
        }
        else {
          # The prime package selected has no version so, we choose to
          # use any alternative package that does have a version
          $prime{$package}{file}    = $result->{file};
          $prime{$package}{version} = $result->{version};
d331 1
a331 8
        }
        else {
        # no alt package found with a version, but we have a prime
        # package so we use it whether it has a version or not
        }

      }
      else { # No primary package was selected, use the best alternative
d336 1
a336 1
            $result->{err}
d344 1
a344 1
          if defined( $result->{version} );
d386 5
a390 6
  if ( not $handle ) {
    my $filename = $self->{filename};
    open $handle, '<', $filename
      or croak( "Can't open '$filename': $!" );

    $self->_handle_bom($handle, $filename);
a391 1
  $self->_parse_fh($handle);
d401 6
a406 1
      $self->{module} = 'main';
d411 1
a411 1
    if defined( $self->{module} );
d426 3
a428 4
      if -e $testfile and !-d _;  # For stuff like ExtUtils::xsubpp
    $testfile .= '.pm';
    return [ File::Spec->rel2abs( $testfile ), $dir ]
      if -e $testfile;
d452 1
a452 1
  my( $sigil, $variable_name, $package);
d454 4
a457 4
    ( $sigil, $variable_name, $package) = $2 ? ( $1, $2, $3 ) : ( $4, $5, $6 );
    if ( $package ) {
      $package = ($package eq '::') ? 'main' : $package;
      $package =~ s/::$//;
d461 13
a473 1
  return ( $sigil, $variable_name, $package );
d481 1
a481 1
  my $pos = tell $fh;
d485 1
a485 1
  my $count = read $fh, $buf, length $buf;
d491 1
a491 2
  }
  elsif ( $buf eq "\x{FF}\x{FE}" ) {
d493 1
a493 2
  }
  elsif ( $buf eq "\x{EF}\x{BB}" ) {
d495 1
a495 1
    $count = read $fh, $buf, length $buf;
d503 1
d506 2
a507 3
  }
  else {
    seek $fh, $pos, SEEK_SET
d518 2
a519 2
  my( @@packages, %vers, %pod, @@pod );
  my $package = 'main';
d543 2
a544 2
        push( @@pod, $1 );
        if ( $self->{collect_pod} && length( $pod_data ) ) {
d548 5
a552 1
        $pod_sect = $1;
d554 3
a556 6
      elsif ( $self->{collect_pod} ) {
        $pod_data .= "$line\n";
      }
      next;
    }
    elsif ( $is_cut ) {
a561 2
      next;
    }
d563 1
a563 2
    # Skip after __END__
    next if $in_end;
d565 2
a566 2
    # Skip comments in code
    next if $line =~ /^\s*#/;
d568 2
a569 13
    # Would be nice if we could also check $in_string or something too
    if ($line eq '__END__') {
      $in_end++;
      next;
    }

    last if $line eq '__DATA__';

    # parse $line to see if it's a $VERSION declaration
    my( $version_sigil, $version_fullname, $version_package ) =
      index($line, 'VERSION') >= 1
        ? $self->_parse_version_expression( $line )
        : ();
d571 53
a623 5
    if ( $line =~ /$PKG_REGEXP/o ) {
      $package = $1;
      my $version = $2;
      push( @@packages, $package ) unless grep( $package eq $_, @@packages );
      $need_vers = defined $version ? 0 : 1;
a624 6
      if ( not exists $vers{$package} and defined $version ){
        # Upgrade to a version object.
        my $dwim_version = eval { _dwim_version($version) };
        croak "Version '$version' from $self->{filename} does not appear to be valid:\n$line\n\nThe fatal error was: $@@\n"
          unless defined $dwim_version;  # "0" is OK!
        $vers{$package} = $dwim_version;
a625 6
    }

    # VERSION defined with full package spec, i.e. $Module::VERSION
    elsif ( $version_fullname && $version_package ) {
      # we do NOT save this package in found @@packages
      $need_vers = 0 if $version_package eq $package;
a626 3
      unless ( defined $vers{$version_package} && length $vers{$version_package} ) {
        $vers{$version_package} = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
      }
d629 1
a629 25
    # first non-comment line in undeclared package main is VERSION
    elsif ( $package eq 'main' && $version_fullname && !exists($vers{main}) ) {
      $need_vers = 0;
      my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );
      $vers{$package} = $v;
      push( @@packages, 'main' );
    }

    # first non-comment line in undeclared package defines package main
    elsif ( $package eq 'main' && !exists($vers{main}) && $line =~ /\w/ ) {
      $need_vers = 1;
      $vers{main} = '';
      push( @@packages, 'main' );
    }

    # only keep if this is the first $VERSION seen
    elsif ( $version_fullname && $need_vers ) {
      $need_vers = 0;
      my $v = $self->_evaluate_version_line( $version_sigil, $version_fullname, $line );

      unless ( defined $vers{$package} && length $vers{$package} ) {
        $vers{$package} = $v;
      }
    }
  } # end loop over each line
d636 1
a636 1
  $self->{packages} = \@@packages;
d645 3
a647 1
  my( $sigil, $variable_name, $line ) = @@_;
d649 1
a649 1
  # We compile into a local sub because 'use version' would cause
d651 1
d653 2
a654 2
  my $eval = qq{ my \$dummy = q#  Hide from _packages_inside()
    #; package Module::Metadata::_version::p${pn};
d656 10
a665 7
    sub {
      local $sigil$variable_name;
      $line;
      return \$$variable_name if defined \$$variable_name;
      return \$Module::Metadata::_version::p${pn}::$variable_name;
    };
  };
d671 2
a672 2
  my $vsub = __clean_eval($eval);
  # some modules say $VERSION <equal sign> $Foo::Bar::VERSION, but Foo::Bar isn't
d676 1
a676 1
    $vsub = __clean_eval($eval);
a679 1

a681 1

a682 1
  # FIXME: $eval is not the right thing to print here
a688 1
  # FIXME: $eval is not the right thing to print here
d768 4
a771 5
         exists( $self->{versions}{$mod} ) ) {
        return $self->{versions}{$mod};
    }
    else {
        return undef;
d779 4
a782 2
         exists( $self->{pod}{$sect} ) ) {
        return $self->{pod}{$sect};
a783 15
    else {
        return undef;
    }
}

sub is_indexable {
  my ($self, $package) = @@_;

  my @@indexable_packages = grep { $_ ne 'main' } $self->packages_inside;

  # check for specific package, if provided
  return !! grep { $_ eq $package } @@indexable_packages if $package;

  # otherwise, check for any indexable packages at all
  return !! @@indexable_packages;
a787 6
__END__

=pod

=encoding UTF-8

a791 4
=head1 VERSION

version 1.000031

d812 1
a812 1
=head1 CLASS METHODS
d814 5
a818 1
=head2 C<< new_from_file($filename, collect_pod => 1) >>
d831 1
a831 1
=head2 C<< new_from_handle($handle, $filename, collect_pod => 1) >>
d844 1
a844 1
=head2 C<< new_from_module($module, collect_pod => 1, inc => \@@dirs) >>
d858 1
a858 1
=head2 C<< find_module_by_name($module, \@@dirs) >>
d866 1
a866 1
=head2 C<< find_module_dir_by_name($module, \@@dirs) >>
d874 1
a874 1
=head2 C<< provides( %options ) >>
d923 1
a923 1
=head2 C<< package_versions_from_directory($dir, \@@files?) >>
d945 1
a945 1
=head2 C<< log_info (internal) >>
d950 3
a952 1
=head1 OBJECT METHODS
d954 3
a956 1
=head2 C<< name() >>
d959 1
a959 1
is more than one package, it makes a best guess based on the
d963 1
a963 1
=head2 C<< version($package) >>
d970 1
a970 1
=head2 C<< filename() >>
a972 1
Note that this file may not actually exist on disk yet, e.g. if the module was read from an in-memory filehandle.
d974 1
a974 1
=head2 C<< packages_inside() >>
d984 1
a984 1
=head2 C<< pod_inside() >>
d988 1
a988 1
=head2 C<< contains_pod() >>
d992 1
a992 1
=head2 C<< pod($section) >>
d996 1
a996 19
=head2 C<< is_indexable($package) >> or C<< is_indexable() >>

Available since version 1.000020.

Returns a boolean indicating whether the package (if provided) or any package
(otherwise) is eligible for indexing by PAUSE, the Perl Authors Upload Server.
Note This only checks for valid C<package> declarations, and does not take any
ownership information into account.

=head1 SUPPORT

Bugs may be submitted through L<the RT bug tracker|https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata>
(or L<bug-Module-Metadata@@rt.cpan.org|mailto:bug-Module-Metadata@@rt.cpan.org>).

There is also a mailing list available for users of this distribution, at
L<http://lists.perl.org/list/cpan-workers.html>.

There is also an irc channel available for users of this distribution, at
L<irc://irc.perl.org/#toolchain>.
a1005 96
=head1 CONTRIBUTORS

=for stopwords Karen Etheridge David Golden Vincent Pit Matt S Trout Chris Nehren Graham Knop Olivier Mengu√© Tomas Doran Tatsuhiko Miyagawa tokuhirom Peter Rabbitson Steve Hay Josh Jore Craig A. Berry Mitchell Steinbrunner Edward Zborowski Gareth Harper James Raspass Jerry D. Hedden 'BinGOs' Williams Kent Fredric

=over 4

=item *

Karen Etheridge <ether@@cpan.org>

=item *

David Golden <dagolden@@cpan.org>

=item *

Vincent Pit <perl@@profvince.com>

=item *

Matt S Trout <mst@@shadowcat.co.uk>

=item *

Chris Nehren <apeiron@@cpan.org>

=item *

Graham Knop <haarg@@haarg.org>

=item *

Olivier Mengu√© <dolmen@@cpan.org>

=item *

Tomas Doran <bobtfish@@bobtfish.net>

=item *

Tatsuhiko Miyagawa <miyagawa@@bulknews.net>

=item *

tokuhirom <tokuhirom@@gmail.com>

=item *

Peter Rabbitson <ribasushi@@cpan.org>

=item *

Steve Hay <steve.m.hay@@googlemail.com>

=item *

Josh Jore <jjore@@cpan.org>

=item *

Craig A. Berry <cberry@@cpan.org>

=item *

David Mitchell <davem@@iabyn.com>

=item *

David Steinbrunner <dsteinbrunner@@pobox.com>

=item *

Edward Zborowski <ed@@rubensteintech.com>

=item *

Gareth Harper <gareth@@broadbean.com>

=item *

James Raspass <jraspass@@gmail.com>

=item *

Jerry D. Hedden <jdhedden@@cpan.org>

=item *

Chris 'BinGOs' Williams <chris@@bingosnet.co.uk>

=item *

Kent Fredric <kentnl@@cpan.org>

=back

d1016 1
@


