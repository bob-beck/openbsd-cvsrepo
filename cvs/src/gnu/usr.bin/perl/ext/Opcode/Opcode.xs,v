head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.2
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2017.02.05.00.32.13;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2013.03.25.20.40.54;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.06.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.23;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.14;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.05.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.32;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.55.37;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.38.52;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.17;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.54;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.52;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.23;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.15;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.48.49;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.08.45;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.06;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#define PERL_NO_GET_CONTEXT
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* PL_maxo shouldn't differ from MAXO but leave room anyway (see BOOT:)	*/
#define OP_MASK_BUF_SIZE (MAXO + 100)

/* XXX op_named_bits and opset_all are never freed */
#define MY_CXT_KEY "Opcode::_guts" XS_VERSION

typedef struct {
    HV *	x_op_named_bits;	/* cache shared for whole process */
    SV *	x_opset_all;		/* mask with all bits set	*/
    IV		x_opset_len;		/* length of opmasks in bytes	*/
#ifdef OPCODE_DEBUG
    int		x_opcode_debug;		/* unused warn() emitting debugging code */
#endif
} my_cxt_t;

START_MY_CXT

#define op_named_bits		(MY_CXT.x_op_named_bits)
#define opset_all		(MY_CXT.x_opset_all)
#define opset_len		(MY_CXT.x_opset_len)
#ifdef OPCODE_DEBUG
#  define opcode_debug		(MY_CXT.x_opcode_debug)
#else
 /* no API to turn this on at runtime, so constant fold the code away */
#  define opcode_debug		0
#endif

static SV  *new_opset (pTHX_ SV *old_opset);
static int  verify_opset (pTHX_ SV *opset, int fatal);
static void set_opset_bits (pTHX_ char *bitmap, SV *bitspec, int on, const char *opname);
static void put_op_bitspec (pTHX_ const char *optag,  STRLEN len, SV *opset);
static SV  *get_op_bitspec (pTHX_ const char *opname, STRLEN len, int fatal);


/* Initialise our private op_named_bits HV.
 * It is first loaded with the name and number of each perl operator.
 * Then the builtin tags :none and :all are added.
 * Opcode.pm loads the standard optags from __DATA__
 * XXX leak-alert: data allocated here is never freed, call this
 *     at most once
 */

static void
op_names_init(pTHX)
{
    int i;
    STRLEN len;
    char **op_names;
    char *bitmap;
    dMY_CXT;

    op_named_bits = newHV();
    op_names = get_op_names();
    for(i=0; i < PL_maxo; ++i) {
	SV * const sv = newSViv(i);
	SvREADONLY_on(sv);
	(void) hv_store(op_named_bits, op_names[i], strlen(op_names[i]), sv, 0);
    }

    put_op_bitspec(aTHX_ STR_WITH_LEN(":none"), sv_2mortal(new_opset(aTHX_ Nullsv)));

    opset_all = new_opset(aTHX_ Nullsv);
    bitmap = SvPV(opset_all, len);
    memset(bitmap, 0xFF, len-1); /* deal with last byte specially, see below */
    /* Take care to set the right number of bits in the last byte */
    bitmap[len-1] = (PL_maxo & 0x07) ? ~(0xFF << (PL_maxo & 0x07)) : 0xFF;
    put_op_bitspec(aTHX_ STR_WITH_LEN(":all"), opset_all); /* don't mortalise */
}


/* Store a new tag definition. Always a mask.
 * The tag must not already be defined.
 * SV *mask is copied not referenced.
 */

static void
put_op_bitspec(pTHX_ const char *optag, STRLEN len, SV *mask)
{
    SV **svp;
    dMY_CXT;

    verify_opset(aTHX_ mask,1);
    svp = hv_fetch(op_named_bits, optag, len, 1);
    if (SvOK(*svp))
	croak("Opcode tag \"%s\" already defined", optag);
    sv_setsv(*svp, mask);
    SvREADONLY_on(*svp);
}



/* Fetch a 'bits' entry for an opname or optag (IV/PV).
 * Note that we return the actual entry for speed.
 * Always sv_mortalcopy() if returning it to user code.
 */

static SV *
get_op_bitspec(pTHX_ const char *opname, STRLEN len, int fatal)
{
    SV **svp;
    dMY_CXT;

    svp = hv_fetch(op_named_bits, opname, len, 0);
    if (!svp || !SvOK(*svp)) {
	if (!fatal)
	    return Nullsv;
	if (*opname == ':')
	    croak("Unknown operator tag \"%s\"", opname);
	if (*opname == '!')	/* XXX here later, or elsewhere? */
	    croak("Can't negate operators here (\"%s\")", opname);
	if (isALPHA(*opname))
	    croak("Unknown operator name \"%s\"", opname);
	croak("Unknown operator prefix \"%s\"", opname);
    }
    return *svp;
}



static SV *
new_opset(pTHX_ SV *old_opset)
{
    SV *opset;
    dMY_CXT;

    if (old_opset) {
	verify_opset(aTHX_ old_opset,1);
	opset = newSVsv(old_opset);
    }
    else {
	opset = newSV(opset_len);
	Zero(SvPVX_const(opset), opset_len + 1, char);
	SvCUR_set(opset, opset_len);
	(void)SvPOK_only(opset);
    }
    /* not mortalised here */
    return opset;
}


static int
verify_opset(pTHX_ SV *opset, int fatal)
{
    const char *err = NULL;
    dMY_CXT;

    if      (!SvOK(opset))              err = "undefined";
    else if (!SvPOK(opset))             err = "wrong type";
    else if (SvCUR(opset) != (STRLEN)opset_len) err = "wrong size";
    if (err && fatal) {
	croak("Invalid opset: %s", err);
    }
    return !err;
}


static void
set_opset_bits(pTHX_ char *bitmap, SV *bitspec, int on, const char *opname)
{
    dMY_CXT;

    if (SvIOK(bitspec)) {
	const int myopcode = SvIV(bitspec);
	const int offset = myopcode >> 3;
	const int bit    = myopcode & 0x07;
	if (myopcode >= PL_maxo || myopcode < 0)
	    croak("panic: opcode \"%s\" value %d is invalid", opname, myopcode);
	if (opcode_debug >= 2)
	    warn("set_opset_bits bit %2d (off=%d, bit=%d) %s %s\n",
			myopcode, offset, bit, opname, (on)?"on":"off");
	if (on)
	    bitmap[offset] |= 1 << bit;
	else
	    bitmap[offset] &= ~(1 << bit);
    }
    else if (SvPOK(bitspec) && SvCUR(bitspec) == (STRLEN)opset_len) {

	STRLEN len;
	const char * const specbits = SvPV(bitspec, len);
	if (opcode_debug >= 2)
	    warn("set_opset_bits opset %s %s\n", opname, (on)?"on":"off");
	if (on) 
	    while(len-- > 0) bitmap[len] |=  specbits[len];
	else
	    while(len-- > 0) bitmap[len] &= ~specbits[len];
    }
    else
	croak("panic: invalid bitspec for \"%s\" (type %u)",
		opname, (unsigned)SvTYPE(bitspec));
}


static void
opmask_add(pTHX_ SV *opset)	/* THE ONLY FUNCTION TO EDIT PL_op_mask ITSELF	*/
{
    int i,j;
    char *bitmask;
    STRLEN len;
    int myopcode = 0;
    dMY_CXT;

    verify_opset(aTHX_ opset,1);		/* croaks on bad opset	*/

    if (!PL_op_mask)		/* caller must ensure PL_op_mask exists	*/
	croak("Can't add to uninitialised PL_op_mask");

    /* OPCODES ALREADY MASKED ARE NEVER UNMASKED. See opmask_addlocal()	*/

    bitmask = SvPV(opset, len);
    for (i=0; i < opset_len; i++) {
	const U16 bits = bitmask[i];
	if (!bits) {	/* optimise for sparse masks */
	    myopcode += 8;
	    continue;
	}
	for (j=0; j < 8 && myopcode < PL_maxo; )
	    PL_op_mask[myopcode++] |= bits & (1 << j++);
    }
}

static void
opmask_addlocal(pTHX_ SV *opset, char *op_mask_buf) /* Localise PL_op_mask then opmask_add() */
{
    char *orig_op_mask = PL_op_mask;
#ifdef OPCODE_DEBUG
    dMY_CXT;
#endif

    SAVEVPTR(PL_op_mask);
    /* XXX casting to an ordinary function ptr from a member function ptr
     * is disallowed by Borland
     */
    if (opcode_debug >= 2)
	SAVEDESTRUCTOR((void(*)(void*))Perl_warn,"PL_op_mask restored");
    PL_op_mask = &op_mask_buf[0];
    if (orig_op_mask)
	Copy(orig_op_mask, PL_op_mask, PL_maxo, char);
    else
	Zero(PL_op_mask, PL_maxo, char);
    opmask_add(aTHX_ opset);
}



MODULE = Opcode	PACKAGE = Opcode

PROTOTYPES: ENABLE

BOOT:
{
    MY_CXT_INIT;
    assert(PL_maxo < OP_MASK_BUF_SIZE);
    opset_len = (PL_maxo + 7) / 8;
    if (opcode_debug >= 1)
	warn("opset_len %ld\n", (long)opset_len);
    op_names_init(aTHX);
}

void
_safe_pkg_prep(Package)
    SV *Package
PPCODE:
    HV *hv; 
    char *hvname;
    ENTER;
   
    hv = gv_stashsv(Package, GV_ADDWARN); /* should exist already	*/

    hvname = HvNAME_get(hv);
    if (!hvname || strNE(hvname, "main")) {
        /* make it think it's in main:: */
	hv_name_set(hv, "main", 4, 0);
        (void) hv_store(hv,"_",1,(SV *)PL_defgv,0);  /* connect _ to global */
        SvREFCNT_inc((SV *)PL_defgv);  /* want to keep _ around! */
    }
    LEAVE;





void
_safe_call_sv(Package, mask, codesv)
    SV *	Package
    SV *	mask
    SV *	codesv
PPCODE:
    char op_mask_buf[OP_MASK_BUF_SIZE];
    GV *gv;
    HV *dummy_hv;

    ENTER;

    opmask_addlocal(aTHX_ mask, op_mask_buf);

    save_aptr(&PL_endav);
    PL_endav = (AV*)sv_2mortal((SV*)newAV()); /* ignore END blocks for now	*/

    save_hptr(&PL_defstash);		/* save current default stash	*/
    /* the assignment to global defstash changes our sense of 'main'	*/
    PL_defstash = gv_stashsv(Package, GV_ADDWARN); /* should exist already	*/

    SAVEGENERICSV(PL_curstash);
    PL_curstash = (HV *)SvREFCNT_inc_simple(PL_defstash);

    /* defstash must itself contain a main:: so we'll add that now	*/
    /* take care with the ref counts (was cause of long standing bug)	*/
    /* XXX I'm still not sure if this is right, GV_ADDWARN should warn!	*/
    gv = gv_fetchpvs("main::", GV_ADDWARN, SVt_PVHV);
    sv_free((SV*)GvHV(gv));
    GvHV(gv) = (HV*)SvREFCNT_inc(PL_defstash);

    /* %INC must be clean for use/require in compartment */
    dummy_hv = save_hash(PL_incgv);
    GvHV(PL_incgv) = (HV*)SvREFCNT_inc(GvHV(gv_HVadd(gv_fetchpvs("INC",GV_ADD,SVt_PVHV))));

    /* Invalidate class and method caches */
    ++PL_sub_generation;
    hv_clear(PL_stashcache);

    PUSHMARK(SP);
    /* use callerâ€™s context */
    perl_call_sv(codesv, GIMME_V|G_EVAL|G_KEEPERR);
    sv_free( (SV *) dummy_hv);  /* get rid of what save_hash gave us*/
    SPAGAIN; /* for the PUTBACK added by xsubpp */
    LEAVE;

    /* Invalidate again */
    ++PL_sub_generation;
    hv_clear(PL_stashcache);


int
verify_opset(opset, fatal = 0)
    SV *opset
    int fatal
CODE:
    RETVAL = verify_opset(aTHX_ opset,fatal);
OUTPUT:
    RETVAL

void
invert_opset(opset)
    SV *opset
CODE:
    {
    char *bitmap;
    dMY_CXT;
    STRLEN len = opset_len;

    opset = sv_2mortal(new_opset(aTHX_ opset));	/* verify and clone opset */
    bitmap = SvPVX(opset);
    while(len-- > 0)
	bitmap[len] = ~bitmap[len];
    /* take care of extra bits beyond PL_maxo in last byte	*/
    if (PL_maxo & 07)
	bitmap[opset_len-1] &= ~(0xFF << (PL_maxo & 0x07));
    }
    ST(0) = opset;


void
opset_to_ops(opset, desc = 0)
    SV *opset
    int	desc
PPCODE:
    {
    STRLEN len;
    int i, j, myopcode;
    const char * const bitmap = SvPV(opset, len);
    char **names = (desc) ? get_op_descs() : get_op_names();
    dMY_CXT;

    verify_opset(aTHX_ opset,1);
    for (myopcode=0, i=0; i < opset_len; i++) {
	const U16 bits = bitmap[i];
	for (j=0; j < 8 && myopcode < PL_maxo; j++, myopcode++) {
	    if ( bits & (1 << j) )
		XPUSHs(newSVpvn_flags(names[myopcode], strlen(names[myopcode]),
				      SVs_TEMP));
	}
    }
    }


void
opset(...)
CODE:
    int i;
    SV *bitspec;
    STRLEN len, on;

    SV * const opset = sv_2mortal(new_opset(aTHX_ Nullsv));
    char * const bitmap = SvPVX(opset);
    for (i = 0; i < items; i++) {
	const char *opname;
	on = 1;
	if (verify_opset(aTHX_ ST(i),0)) {
	    opname = "(opset)";
	    bitspec = ST(i);
	}
	else {
	    opname = SvPV(ST(i), len);
	    if (*opname == '!') { on=0; ++opname;--len; }
	    bitspec = get_op_bitspec(aTHX_ opname, len, 1);
	}
	set_opset_bits(aTHX_ bitmap, bitspec, on, opname);
    }
    ST(0) = opset;


#define PERMITING  (ix == 0 || ix == 1)
#define ONLY_THESE (ix == 0 || ix == 2)

void
permit_only(safe, ...)
    SV *safe
ALIAS:
	permit    = 1
	deny_only = 2
	deny      = 3
CODE:
    int i;
    SV *bitspec, *mask;
    char *bitmap;
    STRLEN len;
    dMY_CXT;

    if (!SvROK(safe) || !SvOBJECT(SvRV(safe)) || SvTYPE(SvRV(safe))!=SVt_PVHV)
	croak("Not a Safe object");
    mask = *hv_fetch((HV*)SvRV(safe), "Mask",4, 1);
    if (ONLY_THESE)	/* *_only = new mask, else edit current	*/
	sv_setsv(mask, sv_2mortal(new_opset(aTHX_ PERMITING ? opset_all : Nullsv)));
    else
	verify_opset(aTHX_ mask,1); /* croaks */
    bitmap = SvPVX(mask);
    for (i = 1; i < items; i++) {
	const char *opname;
	int on = PERMITING ? 0 : 1;		/* deny = mask bit on	*/
	if (verify_opset(aTHX_ ST(i),0)) {	/* it's a valid mask	*/
	    opname = "(opset)";
	    bitspec = ST(i);
	}
	else {				/* it's an opname/optag	*/
	    opname = SvPV(ST(i), len);
	    /* invert if op has ! prefix (only one allowed)	*/
	    if (*opname == '!') { on = !on; ++opname; --len; }
	    bitspec = get_op_bitspec(aTHX_ opname, len, 1); /* croaks */
	}
	set_opset_bits(aTHX_ bitmap, bitspec, on, opname);
    }
    ST(0) = &PL_sv_yes;



void
opdesc(...)
PPCODE:
    int i;
    STRLEN len;
    SV **args;
    char **op_desc = get_op_descs(); 
    dMY_CXT;

    /* copy args to a scratch area since we may push output values onto	*/
    /* the stack faster than we read values off it if masks are used.	*/
    args = (SV**)SvPVX(newSVpvn_flags((char*)&ST(0), items*sizeof(SV*), SVs_TEMP));
    for (i = 0; i < items; i++) {
	const char * const opname = SvPV(args[i], len);
	SV *bitspec = get_op_bitspec(aTHX_ opname, len, 1);
	if (SvIOK(bitspec)) {
	    const int myopcode = SvIV(bitspec);
	    if (myopcode < 0 || myopcode >= PL_maxo)
		croak("panic: opcode %d (%s) out of range",myopcode,opname);
	    XPUSHs(newSVpvn_flags(op_desc[myopcode], strlen(op_desc[myopcode]),
				  SVs_TEMP));
	}
	else if (SvPOK(bitspec) && SvCUR(bitspec) == (STRLEN)opset_len) {
	    int b, j;
	    const char * const bitmap = SvPV_nolen_const(bitspec);
	    int myopcode = 0;
	    for (b=0; b < opset_len; b++) {
		const U16 bits = bitmap[b];
		for (j=0; j < 8 && myopcode < PL_maxo; j++, myopcode++)
		    if (bits & (1 << j))
			XPUSHs(newSVpvn_flags(op_desc[myopcode],
					      strlen(op_desc[myopcode]),
					      SVs_TEMP));
	    }
	}
	else
	    croak("panic: invalid bitspec for \"%s\" (type %u)",
		opname, (unsigned)SvTYPE(bitspec));
    }


void
define_optag(optagsv, mask)
    SV *optagsv
    SV *mask
CODE:
    STRLEN len;
    const char *optag = SvPV(optagsv, len);

    put_op_bitspec(aTHX_ optag, len, mask); /* croaks */
    ST(0) = &PL_sv_yes;


void
empty_opset()
CODE:
    ST(0) = sv_2mortal(new_opset(aTHX_ Nullsv));

void
full_opset()
CODE:
    dMY_CXT;
    ST(0) = sv_2mortal(new_opset(aTHX_ opset_all));

void
opmask_add(opset)
    SV *opset
PREINIT:
    if (!PL_op_mask)
	Newxz(PL_op_mask, PL_maxo, char);
CODE:
    opmask_add(aTHX_ opset);

void
opcodes()
PPCODE:
    if (GIMME_V == G_ARRAY) {
	croak("opcodes in list context not yet implemented"); /* XXX */
    }
    else {
	XPUSHs(sv_2mortal(newSViv(PL_maxo)));
    }

void
opmask()
CODE:
    ST(0) = sv_2mortal(new_opset(aTHX_ Nullsv));
    if (PL_op_mask) {
	char * const bitmap = SvPVX(ST(0));
	int myopcode;
	for(myopcode=0; myopcode < PL_maxo; ++myopcode) {
	    if (PL_op_mask[myopcode])
		bitmap[myopcode >> 3] |= 1 << (myopcode & 0x07);
	}
    }

@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d16 3
a18 1
    int		x_opcode_debug;
d26 6
a31 1
#define opcode_debug		(MY_CXT.x_opcode_debug)
d230 1
d232 1
d322 1
a322 1
    /* Invalidate ISA and method caches */
d327 2
a328 1
    perl_call_sv(codesv, GIMME|G_EVAL|G_KEEPERR); /* use callers context */
d333 4
d537 1
a537 1
    if (GIMME == G_ARRAY) {
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d260 1
d265 2
a266 1
    if (strNE(HvNAME_get(hv),"main")) {
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d55 1
a55 1
	hv_store(op_named_bits, op_names[i], strlen(op_names[i]), sv, 0);
d58 1
a58 1
    put_op_bitspec(aTHX_ ":none",0, sv_2mortal(new_opset(aTHX_ Nullsv)));
d62 1
a62 3
    i = len-1; /* deal with last byte specially, see below */
    while(i-- > 0)
	bitmap[i] = (char)0xFF;
d65 1
a65 1
    put_op_bitspec(aTHX_ ":all",0, opset_all); /* don't mortalise */
a80 2
    if (!len)
	len = strlen(optag);
d92 1
a92 1
 * Always sv_mortalcopy() if returing it to user code.
a100 2
    if (!len)
	len = strlen(opname);
d267 1
a267 1
        hv_store(hv,"_",1,(SV *)PL_defgv,0);  /* connect _ to global */
d297 2
a298 2
    save_hptr(&PL_curstash);
    PL_curstash = PL_defstash;
@


1.9
log
@Merge in perl 5.10.1
@
text
@d263 1
a263 1
    const char *Package
d268 1
a268 1
    hv = gv_stashpv(Package, GV_ADDWARN); /* should exist already	*/
d284 1
a284 1
    char *	Package
d301 1
a301 1
    PL_defstash = gv_stashpv(Package, GV_ADDWARN); /* should exist already	*/
d309 1
a309 1
    gv = gv_fetchpv("main::", GV_ADDWARN, SVt_PVHV);
d315 1
a315 1
    GvHV(PL_incgv) = (HV*)SvREFCNT_inc(GvHV(gv_HVadd(gv_fetchpv("INC",TRUE,SVt_PVHV))));
d374 2
a375 1
		XPUSHs(sv_2mortal(newSVpv(names[myopcode], 0)));
d462 1
a462 1
    args = (SV**)SvPVX(sv_2mortal(newSVpvn((char*)&ST(0), items*sizeof(SV*))));
d470 2
a471 1
	    XPUSHs(sv_2mortal(newSVpv(op_desc[myopcode], 0)));
d481 3
a483 1
			XPUSHs(sv_2mortal(newSVpv(op_desc[myopcode], 0)));
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d148 1
a148 1
    const char *err = Nullch;
@


1.7
log
@merge in perl 5.8.8
@
text
@d135 1
a135 1
	opset = NEWSV(1156, opset_len);
d316 4
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d28 3
a30 3
static void set_opset_bits (pTHX_ char *bitmap, SV *bitspec, int on, char *opname);
static void put_op_bitspec (pTHX_ char *optag,  STRLEN len, SV *opset);
static SV  *get_op_bitspec (pTHX_ char *opname, STRLEN len, int fatal);
d53 1
a53 2
	SV *sv;
	sv = newSViv(i);
d77 1
a77 1
put_op_bitspec(pTHX_ char *optag, STRLEN len, SV *mask)
d100 1
a100 1
get_op_bitspec(pTHX_ char *opname, STRLEN len, int fatal)
d136 1
a136 1
	Zero(SvPVX(opset), opset_len + 1, char);
d148 1
a148 1
    char *err = Nullch;
d162 1
a162 1
set_opset_bits(pTHX_ char *bitmap, SV *bitspec, int on, char *opname)
d167 3
a169 3
	int myopcode = SvIV(bitspec);
	int offset = myopcode >> 3;
	int bit    = myopcode & 0x07;
d183 1
a183 1
	char *specbits = SvPV(bitspec, len);
d215 1
a215 1
	U16 bits = bitmask[i];
d263 1
a263 1
    char *	Package
d270 3
a272 3
    if (strNE(HvNAME(hv),"main")) {
        Safefree(HvNAME(hv));         
        HvNAME(hv) = savepv("main"); /* make it think it's in main:: */
d361 1
a361 1
    char *bitmap = SvPV(opset, len);
d367 1
a367 1
	U16 bits = bitmap[i];
d380 1
a380 2
    SV *bitspec, *opset;
    char *bitmap;
d383 2
a384 2
    opset = sv_2mortal(new_opset(aTHX_ Nullsv));
    bitmap = SvPVX(opset);
d386 1
a386 1
	char *opname;
d413 1
a413 1
    int i, on;
d415 1
a415 1
    char *bitmap, *opname;
d428 2
a429 1
	on = PERMITING ? 0 : 1;		/* deny = mask bit on	*/
d449 1
a449 1
    int i, myopcode;
d459 1
a459 1
	char *opname = SvPV(args[i], len);
d462 1
a462 1
	    myopcode = SvIV(bitspec);
d469 2
a470 3
	    STRLEN n_a;
	    char *bitmap = SvPV(bitspec,n_a);
	    myopcode = 0;
d472 1
a472 1
		U16 bits = bitmap[b];
d490 1
a490 1
    char *optag = SvPV(optagsv, len);
d512 1
a512 1
	Newz(0, PL_op_mask, PL_maxo, char);
d531 1
a531 1
	char *bitmap = SvPVX(ST(0));
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d291 1
d315 1
a315 2
    save_hash(PL_incgv);
    sv_free((SV*)GvHV(PL_incgv));  /* get rid of what save_hash gave us*/
d320 1
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d10 15
a24 4
static HV *op_named_bits;	/* cache shared for whole process	*/
static SV *opset_all;		/* mask with all bits set		*/
static IV  opset_len;		/* length of opmasks in bytes		*/
static int opcode_debug = 0;
d48 1
d65 1
a65 1
	bitmap[i] = 0xFF;
d81 2
d104 2
d129 2
d150 2
d154 1
a154 1
    else if (SvCUR(opset) != opset_len) err = "wrong size";
d165 2
d181 1
a181 1
    else if (SvPOK(bitspec) && SvCUR(bitspec) == opset_len) {
d205 1
d230 2
a232 1
#if !defined(PERL_OBJECT)
a237 1
#endif
d253 2
d260 21
d302 1
d339 1
d341 1
d363 2
d383 1
d418 1
d453 2
d467 1
a467 1
	else if (SvPOK(bitspec) && SvCUR(bitspec) == opset_len) {
d492 1
d505 1
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d253 1
a253 1
    save_hptr(&PL_defstash);		/* save current default stack	*/
d266 5
d328 1
a328 1
    int i, j;
@


1.2
log
@perl5.005_03 (stock)
@
text
@d1 1
d15 5
a19 5
static SV  *new_opset _((SV *old_opset));
static int  verify_opset _((SV *opset, int fatal));
static void set_opset_bits _((char *bitmap, SV *bitspec, int on, char *opname));
static void put_op_bitspec _((char *optag,  STRLEN len, SV *opset));
static SV  *get_op_bitspec _((char *opname, STRLEN len, int fatal));
d31 1
a31 1
op_names_init(void)
d47 1
a47 1
    put_op_bitspec(":none",0, sv_2mortal(new_opset(Nullsv)));
d49 1
a49 1
    opset_all = new_opset(Nullsv);
d56 1
a56 1
    put_op_bitspec(":all",0, opset_all); /* don't mortalise */
d66 1
a66 1
put_op_bitspec(char *optag, STRLEN len, SV *mask)
d69 1
a69 1
    verify_opset(mask,1);
d87 1
a87 1
get_op_bitspec(char *opname, STRLEN len, int fatal)
d110 1
a110 1
new_opset(SV *old_opset)
d114 1
a114 1
	verify_opset(old_opset,1);
d129 1
a129 1
verify_opset(SV *opset, int fatal)
d143 1
a143 1
set_opset_bits(char *bitmap, SV *bitspec, int on, char *opname)
d177 1
a177 1
opmask_add(SV *opset)	/* THE ONLY FUNCTION TO EDIT PL_op_mask ITSELF	*/
d184 1
a184 1
    verify_opset(opset,1);			/* croaks on bad opset	*/
d204 1
a204 1
opmask_addlocal(SV *opset, char *op_mask_buf) /* Localise PL_op_mask then opmask_add() */
d207 1
a207 1
    SAVEPPTR(PL_op_mask);
d213 1
a213 1
	SAVEDESTRUCTOR((void(CPERLscope(*))_((void*)))warn,"PL_op_mask restored");
d220 1
a220 1
    opmask_add(opset);
d234 1
a234 1
    op_names_init();
d248 1
a248 1
    opmask_addlocal(mask, op_mask_buf);
d256 2
d276 4
a279 1

d288 1
a288 1
    opset = sv_2mortal(new_opset(opset));	/* verify and clone opset */
d309 1
a309 1
    verify_opset(opset,1);
d327 1
a327 1
    opset = sv_2mortal(new_opset(Nullsv));
d332 1
a332 1
	if (verify_opset(ST(i),0)) {
d339 1
a339 1
	    bitspec = get_op_bitspec(opname, len, 1);
d341 1
a341 1
	set_opset_bits(bitmap, bitspec, on, opname);
d366 1
a366 1
	sv_setsv(mask, sv_2mortal(new_opset(PERMITING ? opset_all : Nullsv)));
d368 1
a368 1
	verify_opset(mask,1); /* croaks */
d372 1
a372 1
	if (verify_opset(ST(i),0)) {	/* it's a valid mask	*/
d380 1
a380 1
	    bitspec = get_op_bitspec(opname, len, 1); /* croaks */
d382 1
a382 1
	set_opset_bits(bitmap, bitspec, on, opname);
d397 1
a397 1
    args = (SV**)SvPVX(sv_2mortal(newSVpv((char*)&ST(0), items*sizeof(SV*))));
d400 1
a400 1
	SV *bitspec = get_op_bitspec(opname, len, 1);
d432 1
a432 1
    put_op_bitspec(optag, len, mask); /* croaks */
d439 1
a439 1
    ST(0) = sv_2mortal(new_opset(Nullsv));
d444 1
a444 1
    ST(0) = sv_2mortal(new_opset(opset_all));
d452 2
d468 1
a468 1
    ST(0) = sv_2mortal(new_opset(Nullsv));
@


1.1
log
@perl 5.004_04
@
text
@d5 1
a5 1
/* maxo shouldn't differ from MAXO but leave room anyway (see BOOT:)	*/
d8 1
d25 2
d30 1
a30 1
op_names_init()
d34 1
a34 1
    char *opname;
d38 6
a43 4
    for(i=0; i < maxo; ++i) {
	hv_store(op_named_bits, op_name[i],strlen(op_name[i]),
		Sv=newSViv(i), 0);
	SvREADONLY_on(Sv);
d54 1
a54 1
    bitmap[len-1] = (maxo & 0x07) ? ~(0xFF << (maxo & 0x07)) : 0xFF;
d65 1
a65 4
put_op_bitspec(optag, len, mask)
    char *optag;
    STRLEN len;
    SV *mask;
d86 1
a86 4
get_op_bitspec(opname, len, fatal)
    char *opname;
    STRLEN len;
    int fatal;
d109 1
a109 2
new_opset(old_opset)
    SV *old_opset;
d117 1
a117 1
	opset = newSV(opset_len);
d128 1
a128 3
verify_opset(opset, fatal)
    SV *opset;
    int fatal;
d142 1
a142 5
set_opset_bits(bitmap, bitspec, on, opname)
    char *bitmap;
    SV *bitspec;
    int on;
    char *opname;
d148 1
a148 1
	if (myopcode >= maxo || myopcode < 0)
d176 1
a176 2
opmask_add(opset)	/* THE ONLY FUNCTION TO EDIT op_mask ITSELF	*/
    SV *opset;
d185 2
a186 2
    if (!op_mask)		/* caller must ensure op_mask exists	*/
	croak("Can't add to uninitialised op_mask");
d197 2
a198 2
	for (j=0; j < 8 && myopcode < maxo; )
	    op_mask[myopcode++] |= bits & (1 << j++);
d203 1
a203 3
opmask_addlocal(opset, op_mask_buf) /* Localise op_mask then opmask_add() */
    SV *opset;
    char *op_mask_buf;
d205 6
a210 2
    char *orig_op_mask = op_mask;
    SAVEPPTR(op_mask);
d212 3
a214 2
	SAVEDESTRUCTOR((void(*)_((void*)))warn,"op_mask restored");
    op_mask = &op_mask_buf[0];
d216 1
a216 1
	Copy(orig_op_mask, op_mask, maxo, char);
d218 1
a218 1
	Zero(op_mask, maxo, char);
d229 2
a230 2
    assert(maxo < OP_MASK_BUF_SIZE);
    opset_len = (maxo + 7) / 8;
d237 2
a238 2
_safe_call_sv(package, mask, codesv)
    char *	package
d241 1
a241 1
    PPCODE:
d249 2
a250 2
    save_aptr(&endav);
    endav = (AV*)sv_2mortal((SV*)newAV()); /* ignore END blocks for now	*/
d252 1
a252 1
    save_hptr(&defstash);		/* save current default stack	*/
d254 1
a254 1
    defstash = gv_stashpv(package, GV_ADDWARN); /* should exist already	*/
d261 1
a261 1
    GvHV(gv) = (HV*)SvREFCNT_inc(defstash);
d263 1
a263 1
    PUSHMARK(sp);
d278 1
a278 1
    CODE:
d282 1
a282 1
    opset = new_opset(opset);	/* verify and clone opset */
d286 3
a288 3
    /* take care of extra bits beyond maxo in last byte	*/
    if (maxo & 07)
	bitmap[opset_len-1] &= ~(0xFF << (maxo & 0x07));
d297 1
a297 1
    PPCODE:
d302 1
a302 1
    char **names = (desc) ? op_desc : op_name;
d306 1
a306 1
	for (j=0; j < 8 && myopcode < maxo; j++, myopcode++) {
d316 1
a316 1
    CODE:
d321 1
a321 1
    opset = new_opset(Nullsv);
d346 1
a346 1
    ALIAS:
d350 1
a350 1
    CODE:
d360 3
a362 2
	 sv_setsv(mask, new_opset(PERMITING ? opset_all : Nullsv));
    else verify_opset(mask,1); /* croaks */
d378 1
a378 1
    ST(0) = &sv_yes;
d384 1
a384 1
    PPCODE:
d388 1
d397 1
a397 1
	    if (myopcode < 0 || myopcode >= maxo)
d403 2
a404 1
	    char *bitmap = SvPV(bitspec,na);
d408 1
a408 1
		for (j=0; j < 8 && myopcode < maxo; j++, myopcode++)
d423 1
a423 1
    CODE:
d427 1
a427 1
    ST(0) = &sv_yes;
d432 1
a432 1
    CODE:
d437 1
a437 1
    CODE:
d443 3
a445 3
    PREINIT:
    if (!op_mask)
	Newz(0, op_mask, maxo, char);
d449 1
a449 1
    PPCODE:
d454 1
a454 1
	XPUSHs(sv_2mortal(newSViv(maxo)));
d459 1
a459 1
    CODE:
d461 1
a461 1
    if (op_mask) {
d464 2
a465 2
	for(myopcode=0; myopcode < maxo; ++myopcode) {
	    if (op_mask[myopcode])
@


1.1.1.1
log
@perl5.005_03
@
text
@d5 1
a5 1
/* PL_maxo shouldn't differ from MAXO but leave room anyway (see BOOT:)	*/
a7 1
/* XXX op_named_bits and opset_all are never freed */
a23 2
 * XXX leak-alert: data allocated here is never freed, call this
 *     at most once
d27 1
a27 1
op_names_init(void)
d31 1
a31 1
    char **op_names;
d35 4
a38 6
    op_names = get_op_names();
    for(i=0; i < PL_maxo; ++i) {
	SV *sv;
	sv = newSViv(i);
	SvREADONLY_on(sv);
	hv_store(op_named_bits, op_names[i], strlen(op_names[i]), sv, 0);
d49 1
a49 1
    bitmap[len-1] = (PL_maxo & 0x07) ? ~(0xFF << (PL_maxo & 0x07)) : 0xFF;
d60 4
a63 1
put_op_bitspec(char *optag, STRLEN len, SV *mask)
d84 4
a87 1
get_op_bitspec(char *opname, STRLEN len, int fatal)
d110 2
a111 1
new_opset(SV *old_opset)
d119 1
a119 1
	opset = NEWSV(1156, opset_len);
d130 3
a132 1
verify_opset(SV *opset, int fatal)
d146 5
a150 1
set_opset_bits(char *bitmap, SV *bitspec, int on, char *opname)
d156 1
a156 1
	if (myopcode >= PL_maxo || myopcode < 0)
d184 2
a185 1
opmask_add(SV *opset)	/* THE ONLY FUNCTION TO EDIT PL_op_mask ITSELF	*/
d194 2
a195 2
    if (!PL_op_mask)		/* caller must ensure PL_op_mask exists	*/
	croak("Can't add to uninitialised PL_op_mask");
d206 2
a207 2
	for (j=0; j < 8 && myopcode < PL_maxo; )
	    PL_op_mask[myopcode++] |= bits & (1 << j++);
d212 3
a214 1
opmask_addlocal(SV *opset, char *op_mask_buf) /* Localise PL_op_mask then opmask_add() */
d216 2
a217 6
    char *orig_op_mask = PL_op_mask;
    SAVEPPTR(PL_op_mask);
#if !defined(PERL_OBJECT)
    /* XXX casting to an ordinary function ptr from a member function ptr
     * is disallowed by Borland
     */
d219 2
a220 3
	SAVEDESTRUCTOR((void(CPERLscope(*))_((void*)))warn,"PL_op_mask restored");
#endif
    PL_op_mask = &op_mask_buf[0];
d222 1
a222 1
	Copy(orig_op_mask, PL_op_mask, PL_maxo, char);
d224 1
a224 1
	Zero(PL_op_mask, PL_maxo, char);
d235 2
a236 2
    assert(PL_maxo < OP_MASK_BUF_SIZE);
    opset_len = (PL_maxo + 7) / 8;
d243 2
a244 2
_safe_call_sv(Package, mask, codesv)
    char *	Package
d247 1
a247 1
PPCODE:
d255 2
a256 2
    save_aptr(&PL_endav);
    PL_endav = (AV*)sv_2mortal((SV*)newAV()); /* ignore END blocks for now	*/
d258 1
a258 1
    save_hptr(&PL_defstash);		/* save current default stack	*/
d260 1
a260 1
    PL_defstash = gv_stashpv(Package, GV_ADDWARN); /* should exist already	*/
d267 1
a267 1
    GvHV(gv) = (HV*)SvREFCNT_inc(PL_defstash);
d269 1
a269 1
    PUSHMARK(SP);
d284 1
a284 1
CODE:
d288 1
a288 1
    opset = sv_2mortal(new_opset(opset));	/* verify and clone opset */
d292 3
a294 3
    /* take care of extra bits beyond PL_maxo in last byte	*/
    if (PL_maxo & 07)
	bitmap[opset_len-1] &= ~(0xFF << (PL_maxo & 0x07));
d303 1
a303 1
PPCODE:
d308 1
a308 1
    char **names = (desc) ? get_op_descs() : get_op_names();
d312 1
a312 1
	for (j=0; j < 8 && myopcode < PL_maxo; j++, myopcode++) {
d322 1
a322 1
CODE:
d327 1
a327 1
    opset = sv_2mortal(new_opset(Nullsv));
d352 1
a352 1
ALIAS:
d356 1
a356 1
CODE:
d366 2
a367 3
	sv_setsv(mask, sv_2mortal(new_opset(PERMITING ? opset_all : Nullsv)));
    else
	verify_opset(mask,1); /* croaks */
d383 1
a383 1
    ST(0) = &PL_sv_yes;
d389 1
a389 1
PPCODE:
a392 1
    char **op_desc = get_op_descs(); 
d401 1
a401 1
	    if (myopcode < 0 || myopcode >= PL_maxo)
d407 1
a407 2
	    STRLEN n_a;
	    char *bitmap = SvPV(bitspec,n_a);
d411 1
a411 1
		for (j=0; j < 8 && myopcode < PL_maxo; j++, myopcode++)
d426 1
a426 1
CODE:
d430 1
a430 1
    ST(0) = &PL_sv_yes;
d435 1
a435 1
CODE:
d440 1
a440 1
CODE:
d446 3
a448 3
PREINIT:
    if (!PL_op_mask)
	Newz(0, PL_op_mask, PL_maxo, char);
d452 1
a452 1
PPCODE:
d457 1
a457 1
	XPUSHs(sv_2mortal(newSViv(PL_maxo)));
d462 1
a462 1
CODE:
d464 1
a464 1
    if (PL_op_mask) {
d467 2
a468 2
	for(myopcode=0; myopcode < PL_maxo; ++myopcode) {
	    if (PL_op_mask[myopcode])
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a0 1
#define PERL_NO_GET_CONTEXT
d14 5
a18 5
static SV  *new_opset (pTHX_ SV *old_opset);
static int  verify_opset (pTHX_ SV *opset, int fatal);
static void set_opset_bits (pTHX_ char *bitmap, SV *bitspec, int on, char *opname);
static void put_op_bitspec (pTHX_ char *optag,  STRLEN len, SV *opset);
static SV  *get_op_bitspec (pTHX_ char *opname, STRLEN len, int fatal);
d30 1
a30 1
op_names_init(pTHX)
d46 1
a46 1
    put_op_bitspec(aTHX_ ":none",0, sv_2mortal(new_opset(aTHX_ Nullsv)));
d48 1
a48 1
    opset_all = new_opset(aTHX_ Nullsv);
d55 1
a55 1
    put_op_bitspec(aTHX_ ":all",0, opset_all); /* don't mortalise */
d65 1
a65 1
put_op_bitspec(pTHX_ char *optag, STRLEN len, SV *mask)
d68 1
a68 1
    verify_opset(aTHX_ mask,1);
d86 1
a86 1
get_op_bitspec(pTHX_ char *opname, STRLEN len, int fatal)
d109 1
a109 1
new_opset(pTHX_ SV *old_opset)
d113 1
a113 1
	verify_opset(aTHX_ old_opset,1);
d128 1
a128 1
verify_opset(pTHX_ SV *opset, int fatal)
d142 1
a142 1
set_opset_bits(pTHX_ char *bitmap, SV *bitspec, int on, char *opname)
d176 1
a176 1
opmask_add(pTHX_ SV *opset)	/* THE ONLY FUNCTION TO EDIT PL_op_mask ITSELF	*/
d183 1
a183 1
    verify_opset(aTHX_ opset,1);		/* croaks on bad opset	*/
d203 1
a203 1
opmask_addlocal(pTHX_ SV *opset, char *op_mask_buf) /* Localise PL_op_mask then opmask_add() */
d206 1
a206 1
    SAVEVPTR(PL_op_mask);
d212 1
a212 1
	SAVEDESTRUCTOR((void(*)(void*))Perl_warn,"PL_op_mask restored");
d219 1
a219 1
    opmask_add(aTHX_ opset);
d233 1
a233 1
    op_names_init(aTHX);
d247 1
a247 1
    opmask_addlocal(aTHX_ mask, op_mask_buf);
a254 2
    save_hptr(&PL_curstash);
    PL_curstash = PL_defstash;
d273 1
a273 4
CODE:
    RETVAL = verify_opset(aTHX_ opset,fatal);
OUTPUT:
    RETVAL
d282 1
a282 1
    opset = sv_2mortal(new_opset(aTHX_ opset));	/* verify and clone opset */
d303 1
a303 1
    verify_opset(aTHX_ opset,1);
d321 1
a321 1
    opset = sv_2mortal(new_opset(aTHX_ Nullsv));
d326 1
a326 1
	if (verify_opset(aTHX_ ST(i),0)) {
d333 1
a333 1
	    bitspec = get_op_bitspec(aTHX_ opname, len, 1);
d335 1
a335 1
	set_opset_bits(aTHX_ bitmap, bitspec, on, opname);
d360 1
a360 1
	sv_setsv(mask, sv_2mortal(new_opset(aTHX_ PERMITING ? opset_all : Nullsv)));
d362 1
a362 1
	verify_opset(aTHX_ mask,1); /* croaks */
d366 1
a366 1
	if (verify_opset(aTHX_ ST(i),0)) {	/* it's a valid mask	*/
d374 1
a374 1
	    bitspec = get_op_bitspec(aTHX_ opname, len, 1); /* croaks */
d376 1
a376 1
	set_opset_bits(aTHX_ bitmap, bitspec, on, opname);
d391 1
a391 1
    args = (SV**)SvPVX(sv_2mortal(newSVpvn((char*)&ST(0), items*sizeof(SV*))));
d394 1
a394 1
	SV *bitspec = get_op_bitspec(aTHX_ opname, len, 1);
d426 1
a426 1
    put_op_bitspec(aTHX_ optag, len, mask); /* croaks */
d433 1
a433 1
    ST(0) = sv_2mortal(new_opset(aTHX_ Nullsv));
d438 1
a438 1
    ST(0) = sv_2mortal(new_opset(aTHX_ opset_all));
a445 2
CODE:
    opmask_add(aTHX_ opset);
d460 1
a460 1
    ST(0) = sv_2mortal(new_opset(aTHX_ Nullsv));
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d253 1
a253 1
    save_hptr(&PL_defstash);		/* save current default stash	*/
a265 5
    /* %INC must be clean for use/require in compartment */
    save_hash(PL_incgv);
    sv_free((SV*)GvHV(PL_incgv));  /* get rid of what save_hash gave us*/
    GvHV(PL_incgv) = (HV*)SvREFCNT_inc(GvHV(gv_HVadd(gv_fetchpv("INC",TRUE,SVt_PVHV))));

d323 1
a323 1
    int i;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d10 4
a13 15
#define MY_CXT_KEY "Opcode::_guts" XS_VERSION

typedef struct {
    HV *	x_op_named_bits;	/* cache shared for whole process */
    SV *	x_opset_all;		/* mask with all bits set	*/
    IV		x_opset_len;		/* length of opmasks in bytes	*/
    int		x_opcode_debug;
} my_cxt_t;

START_MY_CXT

#define op_named_bits		(MY_CXT.x_op_named_bits)
#define opset_all		(MY_CXT.x_opset_all)
#define opset_len		(MY_CXT.x_opset_len)
#define opcode_debug		(MY_CXT.x_opcode_debug)
a36 1
    dMY_CXT;
d53 1
a53 1
	bitmap[i] = (char)0xFF;
a68 2
    dMY_CXT;

a89 2
    dMY_CXT;

a112 2
    dMY_CXT;

a131 2
    dMY_CXT;

d134 1
a134 1
    else if (SvCUR(opset) != (STRLEN)opset_len) err = "wrong size";
a144 2
    dMY_CXT;

d159 1
a159 1
    else if (SvPOK(bitspec) && SvCUR(bitspec) == (STRLEN)opset_len) {
a182 1
    dMY_CXT;
a206 2
    dMY_CXT;

d208 1
d214 1
a229 2
{
    MY_CXT_INIT;
a234 21
}

void
_safe_pkg_prep(Package)
    char *	Package
PPCODE:
    HV *hv; 
    ENTER;
   
    hv = gv_stashpv(Package, GV_ADDWARN); /* should exist already	*/

    if (strNE(HvNAME(hv),"main")) {
        Safefree(HvNAME(hv));         
        HvNAME(hv) = savepv("main"); /* make it think it's in main:: */
        hv_store(hv,"_",1,(SV *)PL_defgv,0);  /* connect _ to global */
        SvREFCNT_inc((SV *)PL_defgv);  /* want to keep _ around! */
    }
    LEAVE;



a255 1

a291 1
    dMY_CXT;
a292 1

a313 2
    dMY_CXT;

a331 1

a365 1
    dMY_CXT;
a399 2
    dMY_CXT;

d412 1
a412 1
	else if (SvPOK(bitspec) && SvCUR(bitspec) == (STRLEN)opset_len) {
a436 1

a448 1
    dMY_CXT;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a290 1
    HV *dummy_hv;
d314 2
a315 1
    dummy_hv = save_hash(PL_incgv);
a319 1
    sv_free( (SV *) dummy_hv);  /* get rid of what save_hash gave us*/
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d28 3
a30 3
static void set_opset_bits (pTHX_ char *bitmap, SV *bitspec, int on, const char *opname);
static void put_op_bitspec (pTHX_ const char *optag,  STRLEN len, SV *opset);
static SV  *get_op_bitspec (pTHX_ const char *opname, STRLEN len, int fatal);
d53 2
a54 1
	SV * const sv = newSViv(i);
d78 1
a78 1
put_op_bitspec(pTHX_ const char *optag, STRLEN len, SV *mask)
d101 1
a101 1
get_op_bitspec(pTHX_ const char *opname, STRLEN len, int fatal)
d137 1
a137 1
	Zero(SvPVX_const(opset), opset_len + 1, char);
d149 1
a149 1
    const char *err = Nullch;
d163 1
a163 1
set_opset_bits(pTHX_ char *bitmap, SV *bitspec, int on, const char *opname)
d168 3
a170 3
	const int myopcode = SvIV(bitspec);
	const int offset = myopcode >> 3;
	const int bit    = myopcode & 0x07;
d184 1
a184 1
	const char * const specbits = SvPV(bitspec, len);
d216 1
a216 1
	const U16 bits = bitmask[i];
d264 1
a264 1
    const char *Package
d271 3
a273 3
    if (strNE(HvNAME_get(hv),"main")) {
        /* make it think it's in main:: */
	hv_name_set(hv, "main", 4, 0);
d362 1
a362 1
    const char * const bitmap = SvPV(opset, len);
d368 1
a368 1
	const U16 bits = bitmap[i];
d381 2
a382 1
    SV *bitspec;
d385 2
a386 2
    SV * const opset = sv_2mortal(new_opset(aTHX_ Nullsv));
    char * const bitmap = SvPVX(opset);
d388 1
a388 1
	const char *opname;
d415 1
a415 1
    int i;
d417 1
a417 1
    char *bitmap;
d430 1
a430 2
	const char *opname;
	int on = PERMITING ? 0 : 1;		/* deny = mask bit on	*/
d450 1
a450 1
    int i;
d460 1
a460 1
	const char * const opname = SvPV(args[i], len);
d463 1
a463 1
	    const int myopcode = SvIV(bitspec);
d470 3
a472 2
	    const char * const bitmap = SvPV_nolen_const(bitspec);
	    int myopcode = 0;
d474 1
a474 1
		const U16 bits = bitmap[b];
d492 1
a492 1
    const char *optag = SvPV(optagsv, len);
d514 1
a514 1
	Newxz(PL_op_mask, PL_maxo, char);
d533 1
a533 1
	char * const bitmap = SvPVX(ST(0));
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d135 1
a135 1
	opset = newSV(opset_len);
a315 4

    /* Invalidate ISA and method caches */
    ++PL_sub_generation;
    hv_clear(PL_stashcache);
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d148 1
a148 1
    const char *err = NULL;
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d263 1
a263 1
    SV *Package
d268 1
a268 1
    hv = gv_stashsv(Package, GV_ADDWARN); /* should exist already	*/
d284 1
a284 1
    SV *	Package
d301 1
a301 1
    PL_defstash = gv_stashsv(Package, GV_ADDWARN); /* should exist already	*/
d309 1
a309 1
    gv = gv_fetchpvs("main::", GV_ADDWARN, SVt_PVHV);
d315 1
a315 1
    GvHV(PL_incgv) = (HV*)SvREFCNT_inc(GvHV(gv_HVadd(gv_fetchpvs("INC",GV_ADD,SVt_PVHV))));
d374 1
a374 2
		XPUSHs(newSVpvn_flags(names[myopcode], strlen(names[myopcode]),
				      SVs_TEMP));
d461 1
a461 1
    args = (SV**)SvPVX(newSVpvn_flags((char*)&ST(0), items*sizeof(SV*), SVs_TEMP));
d469 1
a469 2
	    XPUSHs(newSVpvn_flags(op_desc[myopcode], strlen(op_desc[myopcode]),
				  SVs_TEMP));
d479 1
a479 3
			XPUSHs(newSVpvn_flags(op_desc[myopcode],
					      strlen(op_desc[myopcode]),
					      SVs_TEMP));
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d55 1
a55 1
	(void) hv_store(op_named_bits, op_names[i], strlen(op_names[i]), sv, 0);
d58 1
a58 1
    put_op_bitspec(aTHX_ STR_WITH_LEN(":none"), sv_2mortal(new_opset(aTHX_ Nullsv)));
d62 3
a64 1
    memset(bitmap, 0xFF, len-1); /* deal with last byte specially, see below */
d67 1
a67 1
    put_op_bitspec(aTHX_ STR_WITH_LEN(":all"), opset_all); /* don't mortalise */
d83 2
d96 1
a96 1
 * Always sv_mortalcopy() if returning it to user code.
d105 2
d273 1
a273 1
        (void) hv_store(hv,"_",1,(SV *)PL_defgv,0);  /* connect _ to global */
d303 2
a304 2
    SAVEGENERICSV(PL_curstash);
    PL_curstash = (HV *)SvREFCNT_inc_simple(PL_defstash);
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@a259 1
    char *hvname;
d264 1
a264 2
    hvname = HvNAME_get(hv);
    if (!hvname || strNE(hvname, "main")) {
@


