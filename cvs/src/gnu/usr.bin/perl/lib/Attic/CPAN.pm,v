head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2010.09.24.14.59.32;	author millert;	state dead;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.37;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.43;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.39;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.42;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.34;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.16;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.46.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.17.08;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.48.34;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.28;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.48;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.10
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
# vim: ts=4 sts=4 sw=4:
use strict;
package CPAN;
$CPAN::VERSION = '1.9402';
$CPAN::VERSION =~ s/_//;

# we need to run chdir all over and we would get at wrong libraries
# there
use File::Spec ();
BEGIN {
    if (File::Spec->can("rel2abs")) {
        for my $inc (@@INC) {
            $inc = File::Spec->rel2abs($inc) unless ref $inc;
        }
    }
}
use CPAN::Author;
use CPAN::HandleConfig;
use CPAN::Version;
use CPAN::Bundle;
use CPAN::CacheMgr;
use CPAN::Complete;
use CPAN::Debug;
use CPAN::Distribution;
use CPAN::Distrostatus;
use CPAN::FTP;
use CPAN::Index 1.93; # https://rt.cpan.org/Ticket/Display.html?id=43349
use CPAN::InfoObj;
use CPAN::Module;
use CPAN::Prompt;
use CPAN::URL;
use CPAN::Queue;
use CPAN::Tarzip;
use CPAN::DeferredCode;
use CPAN::Shell;
use CPAN::LWP::UserAgent;
use CPAN::Exception::RecursiveDependency;
use CPAN::Exception::yaml_not_installed;

use Carp ();
use Config ();
use Cwd qw(chdir);
use DirHandle ();
use Exporter ();
use ExtUtils::MakeMaker qw(prompt); # for some unknown reason,
                                    # 5.005_04 does not work without
                                    # this
use File::Basename ();
use File::Copy ();
use File::Find;
use File::Path ();
use FileHandle ();
use Fcntl qw(:flock);
use Safe ();
use Sys::Hostname qw(hostname);
use Text::ParseWords ();
use Text::Wrap ();

# protect against "called too early"
sub find_perl ();
sub anycwd ();
sub _uniq;

no lib ".";

require Mac::BuildTools if $^O eq 'MacOS';
if ($ENV{PERL5_CPAN_IS_RUNNING} && $$ != $ENV{PERL5_CPAN_IS_RUNNING}) {
    $ENV{PERL5_CPAN_IS_RUNNING_IN_RECURSION} ||= $ENV{PERL5_CPAN_IS_RUNNING};
    my @@rec = _uniq split(/,/, $ENV{PERL5_CPAN_IS_RUNNING_IN_RECURSION}), $$;
    $ENV{PERL5_CPAN_IS_RUNNING_IN_RECURSION} = join ",", @@rec;
    # warn "# Note: Recursive call of CPAN.pm detected\n";
    my $w = sprintf "# Note: CPAN.pm is running in process %d now", pop @@rec;
    my %sleep = (
                 5 => 30,
                 6 => 60,
                 7 => 120,
                );
    my $sleep = @@rec > 7 ? 300 : ($sleep{scalar @@rec}||0);
    my $verbose = @@rec >= 4;
    while (@@rec) {
        $w .= sprintf " which has been called by process %d", pop @@rec;
    }
    if ($sleep) {
        $w .= ".\n\n# Sleeping $sleep seconds to protect other processes\n";
    }
    if ($verbose) {
        warn $w;
    }
    local $| = 1;
    while ($sleep > 0) {
        printf "\r#%5d", --$sleep;
        sleep 1;
    }
    print "\n";
}
$ENV{PERL5_CPAN_IS_RUNNING}=$$;
$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$; # https://rt.cpan.org/Ticket/Display.html?id=23735

END { $CPAN::End++; &cleanup; }

$CPAN::Signal ||= 0;
$CPAN::Frontend ||= "CPAN::Shell";
unless (@@CPAN::Defaultsites) {
    @@CPAN::Defaultsites = map {
        CPAN::URL->new(TEXT => $_, FROM => "DEF")
    }
        "http://www.perl.org/CPAN/",
        "ftp://ftp.perl.org/pub/CPAN/";
}
# $CPAN::iCwd (i for initial)
$CPAN::iCwd ||= CPAN::anycwd();
$CPAN::Perl ||= CPAN::find_perl();
$CPAN::Defaultdocs ||= "http://search.cpan.org/perldoc?";
$CPAN::Defaultrecent ||= "http://search.cpan.org/uploads.rdf";
$CPAN::Defaultrecent ||= "http://cpan.uwinnipeg.ca/htdocs/cpan.xml";

# our globals are getting a mess
use vars qw(
            $AUTOLOAD
            $Be_Silent
            $CONFIG_DIRTY
            $Defaultdocs
            $Echo_readline
            $Frontend
            $GOTOSHELL
            $HAS_USABLE
            $Have_warned
            $MAX_RECURSION
            $META
            $RUN_DEGRADED
            $Signal
            $SQLite
            $Suppress_readline
            $VERSION
            $autoload_recursion
            $term
            @@Defaultsites
            @@EXPORT
           );

$MAX_RECURSION = 32;

@@CPAN::ISA = qw(CPAN::Debug Exporter);

# note that these functions live in CPAN::Shell and get executed via
# AUTOLOAD when called directly
@@EXPORT = qw(
             autobundle
             bundle
             clean
             cvs_import
             expand
             force
             fforce
             get
             install
             install_tested
             is_tested
             make
             mkmyconfig
             notest
             perldoc
             readme
             recent
             recompile
             report
             shell
             smoke
             test
             upgrade
            );

sub soft_chdir_with_alternatives ($);

{
    $autoload_recursion ||= 0;

    #-> sub CPAN::AUTOLOAD ;
    sub AUTOLOAD { ## no critic
        $autoload_recursion++;
        my($l) = $AUTOLOAD;
        $l =~ s/.*:://;
        if ($CPAN::Signal) {
            warn "Refusing to autoload '$l' while signal pending";
            $autoload_recursion--;
            return;
        }
        if ($autoload_recursion > 1) {
            my $fullcommand = join " ", map { "'$_'" } $l, @@_;
            warn "Refusing to autoload $fullcommand in recursion\n";
            $autoload_recursion--;
            return;
        }
        my(%export);
        @@export{@@EXPORT} = '';
        CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
        if (exists $export{$l}) {
            CPAN::Shell->$l(@@_);
        } else {
            die(qq{Unknown CPAN command "$AUTOLOAD". }.
                qq{Type ? for help.\n});
        }
        $autoload_recursion--;
    }
}

{
    my $x = *SAVEOUT; # avoid warning
    open($x,">&STDOUT") or die "dup failed";
    my $redir = 0;
    sub _redirect(@@) {
        #die if $redir;
        local $_;
        push(@@_,undef);
        while(defined($_=shift)) {
            if (s/^\s*>//){
                my ($m) = s/^>// ? ">" : "";
                s/\s+//;
                $_=shift unless length;
                die "no dest" unless defined;
                open(STDOUT,">$m$_") or die "open:$_:$!\n";
                $redir=1;
            } elsif ( s/^\s*\|\s*// ) {
                my $pipe="| $_";
                while(defined($_[0])){
                    $pipe .= ' ' . shift;
                }
                open(STDOUT,$pipe) or die "open:$pipe:$!\n";
                $redir=1;
            } else {
                push(@@_,$_);
            }
        }
        return @@_;
    }
    sub _unredirect {
        return unless $redir;
        $redir = 0;
        ## redirect: unredirect and propagate errors.  explicit close to wait for pipe.
        close(STDOUT);
        open(STDOUT,">&SAVEOUT");
        die "$@@" if "$@@";
        ## redirect: done
    }
}

sub _uniq {
    my(@@list) = @@_;
    my %seen;
    return grep { !$seen{$_}++ } @@list;
}

#-> sub CPAN::shell ;
sub shell {
    my($self) = @@_;
    $Suppress_readline = ! -t STDIN unless defined $Suppress_readline;
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;

    my $oprompt = shift || CPAN::Prompt->new;
    my $prompt = $oprompt;
    my $commandline = shift || "";
    $CPAN::CurrentCommandId ||= 1;

    local($^W) = 1;
    unless ($Suppress_readline) {
        require Term::ReadLine;
        if (! $term
            or
            $term->ReadLine eq "Term::ReadLine::Stub"
           ) {
            $term = Term::ReadLine->new('CPAN Monitor');
        }
        if ($term->ReadLine eq "Term::ReadLine::Gnu") {
            my $attribs = $term->Attribs;
            $attribs->{attempted_completion_function} = sub {
                &CPAN::Complete::gnu_cpl;
            }
        } else {
            $readline::rl_completion_function =
                $readline::rl_completion_function = 'CPAN::Complete::cpl';
        }
        if (my $histfile = $CPAN::Config->{'histfile'}) {{
            unless ($term->can("AddHistory")) {
                $CPAN::Frontend->mywarn("Terminal does not support AddHistory.\n");
                last;
            }
            $META->readhist($term,$histfile);
        }}
        for ($CPAN::Config->{term_ornaments}) { # alias
            local $Term::ReadLine::termcap_nowarn = 1;
            $term->ornaments($_) if defined;
        }
        # $term->OUT is autoflushed anyway
        my $odef = select STDERR;
        $| = 1;
        select STDOUT;
        $| = 1;
        select $odef;
    }

    $META->checklock();
    my @@cwd = grep { defined $_ and length $_ }
        CPAN::anycwd(),
              File::Spec->can("tmpdir") ? File::Spec->tmpdir() : (),
                    File::Spec->rootdir();
    my $try_detect_readline;
    $try_detect_readline = $term->ReadLine eq "Term::ReadLine::Stub" if $term;
    unless ($CPAN::Config->{inhibit_startup_message}) {
        my $rl_avail = $Suppress_readline ? "suppressed" :
            ($term->ReadLine ne "Term::ReadLine::Stub") ? "enabled" :
                "available (maybe install Bundle::CPAN or Bundle::CPANxxl?)";
        $CPAN::Frontend->myprint(
                                 sprintf qq{
cpan shell -- CPAN exploration and modules installation (v%s)
Enter 'h' for help.

},
                                 $CPAN::VERSION,
                                 $rl_avail
                                )
    }
    my($continuation) = "";
    my $last_term_ornaments;
  SHELLCOMMAND: while () {
        if ($Suppress_readline) {
            if ($Echo_readline) {
                $|=1;
            }
            print $prompt;
            last SHELLCOMMAND unless defined ($_ = <> );
            if ($Echo_readline) {
                # backdoor: I could not find a way to record sessions
                print $_;
            }
            chomp;
        } else {
            last SHELLCOMMAND unless
                defined ($_ = $term->readline($prompt, $commandline));
        }
        $_ = "$continuation$_" if $continuation;
        s/^\s+//;
        next SHELLCOMMAND if /^$/;
        s/^\s*\?\s*/help /;
        if (/^(?:q(?:uit)?|bye|exit)$/i) {
            last SHELLCOMMAND;
        } elsif (s/\\$//s) {
            chomp;
            $continuation = $_;
            $prompt = "    > ";
        } elsif (/^\!/) {
            s/^\!//;
            my($eval) = $_;
            package
                CPAN::Eval; # hide from the indexer
            use strict;
            use vars qw($import_done);
            CPAN->import(':DEFAULT') unless $import_done++;
            CPAN->debug("eval[$eval]") if $CPAN::DEBUG;
            eval($eval);
            warn $@@ if $@@;
            $continuation = "";
            $prompt = $oprompt;
        } elsif (/./) {
            my(@@line);
            eval { @@line = Text::ParseWords::shellwords($_) };
            warn($@@), next SHELLCOMMAND if $@@;
            warn("Text::Parsewords could not parse the line [$_]"),
                next SHELLCOMMAND unless @@line;
            $CPAN::META->debug("line[".join("|",@@line)."]") if $CPAN::DEBUG;
            my $command = shift @@line;
            eval {
                local (*STDOUT)=*STDOUT;
                @@line = _redirect(@@line);
                CPAN::Shell->$command(@@line)
              };
            my $command_error = $@@;
            _unredirect;
            my $reported_error;
            if ($command_error) {
                my $err = $command_error;
                if (ref $err and $err->isa('CPAN::Exception::blocked_urllist')) {
                    $CPAN::Frontend->mywarn("Client not fully configured, please proceed with configuring.$err");
                    $reported_error = ref $err;
                } else {
                    # I'd prefer never to arrive here and make all errors exception objects
                    if ($err =~ /\S/) {
                        require Carp;
                        require Dumpvalue;
                        my $dv = Dumpvalue->new(tick => '"');
                        Carp::cluck(sprintf "Catching error: %s", $dv->stringify($err));
                    }
                }
            }
            if ($command =~ /^(
                             # classic commands
                             make
                             |test
                             |install
                             |clean

                             # pragmas for classic commands
                             |ff?orce
                             |notest

                             # compounds
                             |report
                             |smoke
                             |upgrade
                            )$/x) {
                # only commands that tell us something about failed distros
                # eval necessary for people without an urllist
                eval {CPAN::Shell->failed($CPAN::CurrentCommandId,1);};
                if (my $err = $@@) {
                    unless (ref $err and $reported_error eq ref $err) {
                        die $@@;
                    }
                }
            }
            soft_chdir_with_alternatives(\@@cwd);
            $CPAN::Frontend->myprint("\n");
            $continuation = "";
            $CPAN::CurrentCommandId++;
            $prompt = $oprompt;
        }
    } continue {
        $commandline = ""; # I do want to be able to pass a default to
                           # shell, but on the second command I see no
                           # use in that
        $Signal=0;
        CPAN::Queue->nullify_queue;
        if ($try_detect_readline) {
            if ($CPAN::META->has_inst("Term::ReadLine::Gnu")
                ||
                $CPAN::META->has_inst("Term::ReadLine::Perl")
            ) {
                delete $INC{"Term/ReadLine.pm"};
                my $redef = 0;
                local($SIG{__WARN__}) = CPAN::Shell::paintdots_onreload(\$redef);
                require Term::ReadLine;
                $CPAN::Frontend->myprint("\n$redef subroutines in ".
                                         "Term::ReadLine redefined\n");
                $GOTOSHELL = 1;
            }
        }
        if ($term and $term->can("ornaments")) {
            for ($CPAN::Config->{term_ornaments}) { # alias
                if (defined $_) {
                    if (not defined $last_term_ornaments
                        or $_ != $last_term_ornaments
                    ) {
                        local $Term::ReadLine::termcap_nowarn = 1;
                        $term->ornaments($_);
                        $last_term_ornaments = $_;
                    }
                } else {
                    undef $last_term_ornaments;
                }
            }
        }
        for my $class (qw(Module Distribution)) {
            # again unsafe meta access?
            for my $dm (keys %{$CPAN::META->{readwrite}{"CPAN::$class"}}) {
                next unless $CPAN::META->{readwrite}{"CPAN::$class"}{$dm}{incommandcolor};
                CPAN->debug("BUG: $class '$dm' was in command state, resetting");
                delete $CPAN::META->{readwrite}{"CPAN::$class"}{$dm}{incommandcolor};
            }
        }
        if ($GOTOSHELL) {
            $GOTOSHELL = 0; # not too often
            $META->savehist if $CPAN::term && $CPAN::term->can("GetHistory");
            @@_ = ($oprompt,"");
            goto &shell;
        }
    }
    soft_chdir_with_alternatives(\@@cwd);
}

#-> CPAN::soft_chdir_with_alternatives ;
sub soft_chdir_with_alternatives ($) {
    my($cwd) = @@_;
    unless (@@$cwd) {
        my $root = File::Spec->rootdir();
        $CPAN::Frontend->mywarn(qq{Warning: no good directory to chdir to!
Trying '$root' as temporary haven.
});
        push @@$cwd, $root;
    }
    while () {
        if (chdir $cwd->[0]) {
            return;
        } else {
            if (@@$cwd>1) {
                $CPAN::Frontend->mywarn(qq{Could not chdir to "$cwd->[0]": $!
Trying to chdir to "$cwd->[1]" instead.
});
                shift @@$cwd;
            } else {
                $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd->[0]": $!});
            }
        }
    }
}

sub _flock {
    my($fh,$mode) = @@_;
    if ( $Config::Config{d_flock} || $Config::Config{d_fcntl_can_lock} ) {
        return flock $fh, $mode;
    } elsif (!$Have_warned->{"d_flock"}++) {
        $CPAN::Frontend->mywarn("Your OS does not seem to support locking; continuing and ignoring all locking issues\n");
        $CPAN::Frontend->mysleep(5);
        return 1;
    } else {
        return 1;
    }
}

sub _yaml_module () {
    my $yaml_module = $CPAN::Config->{yaml_module} || "YAML";
    if (
        $yaml_module ne "YAML"
        &&
        !$CPAN::META->has_inst($yaml_module)
       ) {
        # $CPAN::Frontend->mywarn("'$yaml_module' not installed, falling back to 'YAML'\n");
        $yaml_module = "YAML";
    }
    if ($yaml_module eq "YAML"
        &&
        $CPAN::META->has_inst($yaml_module)
        &&
        $YAML::VERSION < 0.60
        &&
        !$Have_warned->{"YAML"}++
       ) {
        $CPAN::Frontend->mywarn("Warning: YAML version '$YAML::VERSION' is too low, please upgrade!\n".
                                "I'll continue but problems are *very* likely to happen.\n"
                               );
        $CPAN::Frontend->mysleep(5);
    }
    return $yaml_module;
}

# CPAN::_yaml_loadfile
sub _yaml_loadfile {
    my($self,$local_file) = @@_;
    return +[] unless -s $local_file;
    my $yaml_module = _yaml_module;
    if ($CPAN::META->has_inst($yaml_module)) {
        # temporarly enable yaml code deserialisation
        no strict 'refs';
        # 5.6.2 could not do the local() with the reference
        # so we do it manually instead
        my $old_loadcode = ${"$yaml_module\::LoadCode"};
        ${ "$yaml_module\::LoadCode" } = $CPAN::Config->{yaml_load_code} || 0;

        my ($code, @@yaml);
        if ($code = UNIVERSAL::can($yaml_module, "LoadFile")) {
            eval { @@yaml = $code->($local_file); };
            if ($@@) {
                # this shall not be done by the frontend
                die CPAN::Exception::yaml_process_error->new($yaml_module,$local_file,"parse",$@@);
            }
        } elsif ($code = UNIVERSAL::can($yaml_module, "Load")) {
            local *FH;
            open FH, $local_file or die "Could not open '$local_file': $!";
            local $/;
            my $ystream = <FH>;
            eval { @@yaml = $code->($ystream); };
            if ($@@) {
                # this shall not be done by the frontend
                die CPAN::Exception::yaml_process_error->new($yaml_module,$local_file,"parse",$@@);
            }
        }
        ${"$yaml_module\::LoadCode"} = $old_loadcode;
        return \@@yaml;
    } else {
        # this shall not be done by the frontend
        die CPAN::Exception::yaml_not_installed->new($yaml_module, $local_file, "parse");
    }
    return +[];
}

# CPAN::_yaml_dumpfile
sub _yaml_dumpfile {
    my($self,$local_file,@@what) = @@_;
    my $yaml_module = _yaml_module;
    if ($CPAN::META->has_inst($yaml_module)) {
        my $code;
        if (UNIVERSAL::isa($local_file, "FileHandle")) {
            $code = UNIVERSAL::can($yaml_module, "Dump");
            eval { print $local_file $code->(@@what) };
        } elsif ($code = UNIVERSAL::can($yaml_module, "DumpFile")) {
            eval { $code->($local_file,@@what); };
        } elsif ($code = UNIVERSAL::can($yaml_module, "Dump")) {
            local *FH;
            open FH, ">$local_file" or die "Could not open '$local_file': $!";
            print FH $code->(@@what);
        }
        if ($@@) {
            die CPAN::Exception::yaml_process_error->new($yaml_module,$local_file,"dump",$@@);
        }
    } else {
        if (UNIVERSAL::isa($local_file, "FileHandle")) {
            # I think this case does not justify a warning at all
        } else {
            die CPAN::Exception::yaml_not_installed->new($yaml_module, $local_file, "dump");
        }
    }
}

sub _init_sqlite () {
    unless ($CPAN::META->has_inst("CPAN::SQLite")) {
        $CPAN::Frontend->mywarn(qq{CPAN::SQLite not installed, trying to work without\n})
            unless $Have_warned->{"CPAN::SQLite"}++;
        return;
    }
    require CPAN::SQLite::META; # not needed since CVS version of 2006-12-17
    $CPAN::SQLite ||= CPAN::SQLite::META->new($CPAN::META);
}

{
    my $negative_cache = {};
    sub _sqlite_running {
        if ($negative_cache->{time} && time < $negative_cache->{time} + 60) {
            # need to cache the result, otherwise too slow
            return $negative_cache->{fact};
        } else {
            $negative_cache = {}; # reset
        }
        my $ret = $CPAN::Config->{use_sqlite} && ($CPAN::SQLite || _init_sqlite());
        return $ret if $ret; # fast anyway
        $negative_cache->{time} = time;
        return $negative_cache->{fact} = $ret;
    }
}

$META ||= CPAN->new; # In case we re-eval ourselves we need the ||

# from here on only subs.
################################################################################

sub _perl_fingerprint {
    my($self,$other_fingerprint) = @@_;
    my $dll = eval {OS2::DLLname()};
    my $mtime_dll = 0;
    if (defined $dll) {
        $mtime_dll = (-f $dll ? (stat(_))[9] : '-1');
    }
    my $mtime_perl = (-f CPAN::find_perl ? (stat(_))[9] : '-1');
    my $this_fingerprint = {
                            '$^X' => CPAN::find_perl,
                            sitearchexp => $Config::Config{sitearchexp},
                            'mtime_$^X' => $mtime_perl,
                            'mtime_dll' => $mtime_dll,
                           };
    if ($other_fingerprint) {
        if (exists $other_fingerprint->{'stat($^X)'}) { # repair fp from rev. 1.88_57
            $other_fingerprint->{'mtime_$^X'} = $other_fingerprint->{'stat($^X)'}[9];
        }
        # mandatory keys since 1.88_57
        for my $key (qw($^X sitearchexp mtime_dll mtime_$^X)) {
            return unless $other_fingerprint->{$key} eq $this_fingerprint->{$key};
        }
        return 1;
    } else {
        return $this_fingerprint;
    }
}

sub suggest_myconfig () {
  SUGGEST_MYCONFIG: if(!$INC{'CPAN/MyConfig.pm'}) {
        $CPAN::Frontend->myprint("You don't seem to have a user ".
                                 "configuration (MyConfig.pm) yet.\n");
        my $new = CPAN::Shell::colorable_makemaker_prompt("Do you want to create a ".
                                              "user configuration now? (Y/n)",
                                              "yes");
        if($new =~ m{^y}i) {
            CPAN::Shell->mkmyconfig();
            return &checklock;
        } else {
            $CPAN::Frontend->mydie("OK, giving up.");
        }
    }
}

#-> sub CPAN::all_objects ;
sub all_objects {
    my($mgr,$class) = @@_;
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
    CPAN->debug("mgr[$mgr] class[$class]") if $CPAN::DEBUG;
    CPAN::Index->reload;
    values %{ $META->{readwrite}{$class} }; # unsafe meta access, ok
}

# Called by shell, not in batch mode. In batch mode I see no risk in
# having many processes updating something as installations are
# continually checked at runtime. In shell mode I suspect it is
# unintentional to open more than one shell at a time

#-> sub CPAN::checklock ;
sub checklock {
    my($self) = @@_;
    my $lockfile = File::Spec->catfile($CPAN::Config->{cpan_home},".lock");
    if (-f $lockfile && -M _ > 0) {
        my $fh = FileHandle->new($lockfile) or
            $CPAN::Frontend->mydie("Could not open lockfile '$lockfile': $!");
        my $otherpid  = <$fh>;
        my $otherhost = <$fh>;
        $fh->close;
        if (defined $otherpid && $otherpid) {
            chomp $otherpid;
        }
        if (defined $otherhost && $otherhost) {
            chomp $otherhost;
        }
        my $thishost  = hostname();
        if (defined $otherhost && defined $thishost &&
            $otherhost ne '' && $thishost ne '' &&
            $otherhost ne $thishost) {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile '$lockfile'\n".
                                           "reports other host $otherhost and other ".
                                           "process $otherpid.\n".
                                           "Cannot proceed.\n"));
        } elsif ($RUN_DEGRADED) {
            $CPAN::Frontend->mywarn("Running in downgraded mode (experimental)\n");
        } elsif (defined $otherpid && $otherpid) {
            return if $$ == $otherpid; # should never happen
            $CPAN::Frontend->mywarn(
                                    qq{
There seems to be running another CPAN process (pid $otherpid).  Contacting...
});
            if (kill 0, $otherpid or $!{EPERM}) {
                $CPAN::Frontend->mywarn(qq{Other job is running.\n});
                my($ans) =
                    CPAN::Shell::colorable_makemaker_prompt
                        (qq{Shall I try to run in downgraded }.
                        qq{mode? (Y/n)},"y");
                if ($ans =~ /^y/i) {
                    $CPAN::Frontend->mywarn("Running in downgraded mode (experimental).
Please report if something unexpected happens\n");
                    $RUN_DEGRADED = 1;
                    for ($CPAN::Config) {
                        # XXX
                        # $_->{build_dir_reuse} = 0; # 2006-11-17 akoenig Why was that?
                        $_->{commandnumber_in_prompt} = 0; # visibility
                        $_->{histfile}       = "";  # who should win otherwise?
                        $_->{cache_metadata} = 0;   # better would be a lock?
                        $_->{use_sqlite}     = 0;   # better would be a write lock!
                        $_->{auto_commit}    = 0;   # we are violent, do not persist
                        $_->{test_report}    = 0;   # Oliver Paukstadt had sent wrong reports in degraded mode
                    }
                } else {
                    $CPAN::Frontend->mydie("
You may want to kill the other job and delete the lockfile. On UNIX try:
    kill $otherpid
    rm $lockfile
");
                }
            } elsif (-w $lockfile) {
                my($ans) =
                    CPAN::Shell::colorable_makemaker_prompt
                        (qq{Other job not responding. Shall I overwrite }.
                        qq{the lockfile '$lockfile'? (Y/n)},"y");
            $CPAN::Frontend->myexit("Ok, bye\n")
                unless $ans =~ /^y/i;
            } else {
                Carp::croak(
                    qq{Lockfile '$lockfile' not writable by you. }.
                    qq{Cannot proceed.\n}.
                    qq{    On UNIX try:\n}.
                    qq{    rm '$lockfile'\n}.
                    qq{  and then rerun us.\n}
                );
            }
        } else {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Found invalid lockfile ".
                                           "'$lockfile', please remove. Cannot proceed.\n"));
        }
    }
    my $dotcpan = $CPAN::Config->{cpan_home};
    eval { File::Path::mkpath($dotcpan);};
    if ($@@) {
        # A special case at least for Jarkko.
        my $firsterror = $@@;
        my $seconderror;
        my $symlinkcpan;
        if (-l $dotcpan) {
            $symlinkcpan = readlink $dotcpan;
            die "readlink $dotcpan failed: $!" unless defined $symlinkcpan;
            eval { File::Path::mkpath($symlinkcpan); };
            if ($@@) {
                $seconderror = $@@;
            } else {
                $CPAN::Frontend->mywarn(qq{
Working directory $symlinkcpan created.
});
            }
        }
        unless (-d $dotcpan) {
            my $mess = qq{
Your configuration suggests "$dotcpan" as your
CPAN.pm working directory. I could not create this directory due
to this error: $firsterror\n};
            $mess .= qq{
As "$dotcpan" is a symlink to "$symlinkcpan",
I tried to create that, but I failed with this error: $seconderror
} if $seconderror;
            $mess .= qq{
Please make sure the directory exists and is writable.
};
            $CPAN::Frontend->mywarn($mess);
            return suggest_myconfig;
        }
    } # $@@ after eval mkpath $dotcpan
    if (0) { # to test what happens when a race condition occurs
        for (reverse 1..10) {
            print $_, "\n";
            sleep 1;
        }
    }
    # locking
    if (!$RUN_DEGRADED && !$self->{LOCKFH}) {
        my $fh;
        unless ($fh = FileHandle->new("+>>$lockfile")) {
            if ($! =~ /Permission/) {
                $CPAN::Frontend->mywarn(qq{

Your configuration suggests that CPAN.pm should use a working
directory of
    $CPAN::Config->{cpan_home}
Unfortunately we could not create the lock file
    $lockfile
due to permission problems.

Please make sure that the configuration variable
    \$CPAN::Config->{cpan_home}
points to a directory where you can write a .lock file. You can set
this variable in either a CPAN/MyConfig.pm or a CPAN/Config.pm in your
\@@INC path;
});
                return suggest_myconfig;
            }
        }
        my $sleep = 1;
        while (!CPAN::_flock($fh, LOCK_EX|LOCK_NB)) {
            if ($sleep>10) {
                $CPAN::Frontend->mydie("Giving up\n");
            }
            $CPAN::Frontend->mysleep($sleep++);
            $CPAN::Frontend->mywarn("Could not lock lockfile with flock: $!; retrying\n");
        }

        seek $fh, 0, 0;
        truncate $fh, 0;
        $fh->autoflush(1);
        $fh->print($$, "\n");
        $fh->print(hostname(), "\n");
        $self->{LOCK} = $lockfile;
        $self->{LOCKFH} = $fh;
    }
    $SIG{TERM} = sub {
        my $sig = shift;
        &cleanup;
        $CPAN::Frontend->mydie("Got SIG$sig, leaving");
    };
    $SIG{INT} = sub {
      # no blocks!!!
        my $sig = shift;
        &cleanup if $Signal;
        die "Got yet another signal" if $Signal > 1;
        $CPAN::Frontend->mydie("Got another SIG$sig") if $Signal;
        $CPAN::Frontend->mywarn("Caught SIG$sig, trying to continue\n");
        $Signal++;
    };

#       From: Larry Wall <larry@@wall.org>
#       Subject: Re: deprecating SIGDIE
#       To: perl5-porters@@perl.org
#       Date: Thu, 30 Sep 1999 14:58:40 -0700 (PDT)
#
#       The original intent of __DIE__ was only to allow you to substitute one
#       kind of death for another on an application-wide basis without respect
#       to whether you were in an eval or not.  As a global backstop, it should
#       not be used any more lightly (or any more heavily :-) than class
#       UNIVERSAL.  Any attempt to build a general exception model on it should
#       be politely squashed.  Any bug that causes every eval {} to have to be
#       modified should be not so politely squashed.
#
#       Those are my current opinions.  It is also my optinion that polite
#       arguments degenerate to personal arguments far too frequently, and that
#       when they do, it's because both people wanted it to, or at least didn't
#       sufficiently want it not to.
#
#       Larry

    # global backstop to cleanup if we should really die
    $SIG{__DIE__} = \&cleanup;
    $self->debug("Signal handler set.") if $CPAN::DEBUG;
}

#-> sub CPAN::DESTROY ;
sub DESTROY {
    &cleanup; # need an eval?
}

#-> sub CPAN::anycwd ;
sub anycwd () {
    my $getcwd;
    $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    CPAN->$getcwd();
}

#-> sub CPAN::cwd ;
sub cwd {Cwd::cwd();}

#-> sub CPAN::getcwd ;
sub getcwd {Cwd::getcwd();}

#-> sub CPAN::fastcwd ;
sub fastcwd {Cwd::fastcwd();}

#-> sub CPAN::backtickcwd ;
sub backtickcwd {my $cwd = `cwd`; chomp $cwd; $cwd}

#-> sub CPAN::find_perl ;
sub find_perl () {
    my($perl) = File::Spec->file_name_is_absolute($^X) ? $^X : "";
    unless ($perl) {
        my $candidate = File::Spec->catfile($CPAN::iCwd,$^X);
        $^X = $perl = $candidate if MM->maybe_command($candidate);
    }
    unless ($perl) {
        my ($component,$perl_name);
      DIST_PERLNAME: foreach $perl_name ($^X, 'perl', 'perl5', "perl$]") {
          PATH_COMPONENT: foreach $component (File::Spec->path(),
                                                $Config::Config{'binexp'}) {
                next unless defined($component) && $component;
                my($abs) = File::Spec->catfile($component,$perl_name);
                if (MM->maybe_command($abs)) {
                    $^X = $perl = $abs;
                    last DIST_PERLNAME;
                }
            }
        }
    }
    return $perl;
}


#-> sub CPAN::exists ;
sub exists {
    my($mgr,$class,$id) = @@_;
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
    CPAN::Index->reload;
    ### Carp::croak "exists called without class argument" unless $class;
    $id ||= "";
    $id =~ s/:+/::/g if $class eq "CPAN::Module";
    my $exists;
    if (CPAN::_sqlite_running) {
        $exists = (exists $META->{readonly}{$class}{$id} or
                   $CPAN::SQLite->set($class, $id));
    } else {
        $exists =  exists $META->{readonly}{$class}{$id};
    }
    $exists ||= exists $META->{readwrite}{$class}{$id}; # unsafe meta access, ok
}

#-> sub CPAN::delete ;
sub delete {
  my($mgr,$class,$id) = @@_;
  delete $META->{readonly}{$class}{$id}; # unsafe meta access, ok
  delete $META->{readwrite}{$class}{$id}; # unsafe meta access, ok
}

#-> sub CPAN::has_usable
# has_inst is sometimes too optimistic, we should replace it with this
# has_usable whenever a case is given
sub has_usable {
    my($self,$mod,$message) = @@_;
    return 1 if $HAS_USABLE->{$mod};
    my $has_inst = $self->has_inst($mod,$message);
    return unless $has_inst;
    my $usable;
    $usable = {
               LWP => [ # we frequently had "Can't locate object
                        # method "new" via package "LWP::UserAgent" at
                        # (eval 69) line 2006
                       sub {require LWP},
                       sub {require LWP::UserAgent},
                       sub {require HTTP::Request},
                       sub {require URI::URL},
                      ],
               'Net::FTP' => [
                            sub {require Net::FTP},
                            sub {require Net::Config},
                           ],
               'File::HomeDir' => [
                                   sub {require File::HomeDir;
                                        unless (CPAN::Version->vge(File::HomeDir::->VERSION, 0.52)) {
                                            for ("Will not use File::HomeDir, need 0.52\n") {
                                                $CPAN::Frontend->mywarn($_);
                                                die $_;
                                            }
                                        }
                                    },
                                  ],
               'Archive::Tar' => [
                                  sub {require Archive::Tar;
                                       unless (CPAN::Version->vge(Archive::Tar::->VERSION, 1.50)) {
                                            for ("Will not use Archive::Tar, need 1.00\n") {
                                                $CPAN::Frontend->mywarn($_);
                                                die $_;
                                            }
                                       }
                                       unless (CPAN::Version->vge(Archive::Tar::->VERSION, 1.50)) {
                                            my $atv = Archive::Tar->VERSION;
                                            $CPAN::Frontend->mywarn("You have Archive::Tar $atv, but 1.50 or later is recommended. Please upgrade.\n");
                                       }
                                  },
                                 ],
               'File::Temp' => [
                                # XXX we should probably delete from
                                # %INC too so we can load after we
                                # installed a new enough version --
                                # I'm not sure.
                                sub {require File::Temp;
                                     unless (CPAN::Version->vge(File::Temp::->VERSION,0.16)) {
                                         for ("Will not use File::Temp, need 0.16\n") {
                                                $CPAN::Frontend->mywarn($_);
                                                die $_;
                                         }
                                     }
                                },
                               ]
              };
    if ($usable->{$mod}) {
        for my $c (0..$#{$usable->{$mod}}) {
            my $code = $usable->{$mod}[$c];
            my $ret = eval { &$code() };
            $ret = "" unless defined $ret;
            if ($@@) {
                # warn "DEBUG: c[$c]\$\@@[$@@]ret[$ret]";
                return;
            }
        }
    }
    return $HAS_USABLE->{$mod} = 1;
}

#-> sub CPAN::has_inst
sub has_inst {
    my($self,$mod,$message) = @@_;
    Carp::croak("CPAN->has_inst() called without an argument")
        unless defined $mod;
    my %dont = map { $_ => 1 } keys %{$CPAN::META->{dontload_hash}||{}},
        keys %{$CPAN::Config->{dontload_hash}||{}},
            @@{$CPAN::Config->{dontload_list}||[]};
    if (defined $message && $message eq "no"  # afair only used by Nox
        ||
        $dont{$mod}
       ) {
      $CPAN::META->{dontload_hash}{$mod}||=1; # unsafe meta access, ok
      return 0;
    }
    my $file = $mod;
    my $obj;
    $file =~ s|::|/|g;
    $file .= ".pm";
    if ($INC{$file}) {
        # checking %INC is wrong, because $INC{LWP} may be true
        # although $INC{"URI/URL.pm"} may have failed. But as
        # I really want to say "bla loaded OK", I have to somehow
        # cache results.
        ### warn "$file in %INC"; #debug
        return 1;
    } elsif (eval { require $file }) {
        # eval is good: if we haven't yet read the database it's
        # perfect and if we have installed the module in the meantime,
        # it tries again. The second require is only a NOOP returning
        # 1 if we had success, otherwise it's retrying

        my $mtime = (stat $INC{$file})[9];
        # privileged files loaded by has_inst; Note: we use $mtime
        # as a proxy for a checksum.
        $CPAN::Shell::reload->{$file} = $mtime;
        my $v = eval "\$$mod\::VERSION";
        $v = $v ? " (v$v)" : "";
        CPAN::Shell->optprint("load_module","CPAN: $mod loaded ok$v\n");
        if ($mod eq "CPAN::WAIT") {
            push @@CPAN::Shell::ISA, 'CPAN::WAIT';
        }
        return 1;
    } elsif ($mod eq "Net::FTP") {
        $CPAN::Frontend->mywarn(qq{
  Please, install Net::FTP as soon as possible. CPAN.pm installs it for you
  if you just type
      install Bundle::libnet

}) unless $Have_warned->{"Net::FTP"}++;
        $CPAN::Frontend->mysleep(3);
    } elsif ($mod eq "Digest::SHA") {
        if ($Have_warned->{"Digest::SHA"}++) {
            $CPAN::Frontend->mywarn(qq{CPAN: checksum security checks disabled }.
                                     qq{because Digest::SHA not installed.\n});
        } else {
            $CPAN::Frontend->mywarn(qq{
  CPAN: checksum security checks disabled because Digest::SHA not installed.
  Please consider installing the Digest::SHA module.

});
            $CPAN::Frontend->mysleep(2);
        }
    } elsif ($mod eq "Module::Signature") {
        # NOT prefs_lookup, we are not a distro
        my $check_sigs = $CPAN::Config->{check_sigs};
        if (not $check_sigs) {
            # they do not want us:-(
        } elsif (not $Have_warned->{"Module::Signature"}++) {
            # No point in complaining unless the user can
            # reasonably install and use it.
            if (eval { require Crypt::OpenPGP; 1 } ||
                (
                 defined $CPAN::Config->{'gpg'}
                 &&
                 $CPAN::Config->{'gpg'} =~ /\S/
                )
               ) {
                $CPAN::Frontend->mywarn(qq{
  CPAN: Module::Signature security checks disabled because Module::Signature
  not installed.  Please consider installing the Module::Signature module.
  You may also need to be able to connect over the Internet to the public
  keyservers like pgp.mit.edu (port 11371).

});
                $CPAN::Frontend->mysleep(2);
            }
        }
    } else {
        delete $INC{$file}; # if it inc'd LWP but failed during, say, URI
    }
    return 0;
}

#-> sub CPAN::instance ;
sub instance {
    my($mgr,$class,$id) = @@_;
    CPAN::Index->reload;
    $id ||= "";
    # unsafe meta access, ok?
    return $META->{readwrite}{$class}{$id} if exists $META->{readwrite}{$class}{$id};
    $META->{readwrite}{$class}{$id} ||= $class->new(ID => $id);
}

#-> sub CPAN::new ;
sub new {
    bless {}, shift;
}

#-> sub CPAN::cleanup ;
sub cleanup {
  # warn "cleanup called with arg[@@_] End[$CPAN::End] Signal[$Signal]";
  local $SIG{__DIE__} = '';
  my($message) = @@_;
  my $i = 0;
  my $ineval = 0;
  my($subroutine);
  while ((undef,undef,undef,$subroutine) = caller(++$i)) {
      $ineval = 1, last if
        $subroutine eq '(eval)';
  }
  return if $ineval && !$CPAN::End;
  return unless defined $META->{LOCK};
  return unless -f $META->{LOCK};
  $META->savehist;
  close $META->{LOCKFH};
  unlink $META->{LOCK};
  # require Carp;
  # Carp::cluck("DEBUGGING");
  if ( $CPAN::CONFIG_DIRTY ) {
      $CPAN::Frontend->mywarn("Warning: Configuration not saved.\n");
  }
  $CPAN::Frontend->myprint("Lockfile removed.\n");
}

#-> sub CPAN::readhist
sub readhist {
    my($self,$term,$histfile) = @@_;
    my $histsize = $CPAN::Config->{'histsize'} || 100;
    $term->Attribs->{'MaxHistorySize'} = $histsize if (defined($term->Attribs->{'MaxHistorySize'}));
    my($fh) = FileHandle->new;
    open $fh, "<$histfile" or return;
    local $/ = "\n";
    while (<$fh>) {
        chomp;
        $term->AddHistory($_);
    }
    close $fh;
}

#-> sub CPAN::savehist
sub savehist {
    my($self) = @@_;
    my($histfile,$histsize);
    unless ($histfile = $CPAN::Config->{'histfile'}) {
        $CPAN::Frontend->mywarn("No history written (no histfile specified).\n");
        return;
    }
    $histsize = $CPAN::Config->{'histsize'} || 100;
    if ($CPAN::term) {
        unless ($CPAN::term->can("GetHistory")) {
            $CPAN::Frontend->mywarn("Terminal does not support GetHistory.\n");
            return;
        }
    } else {
        return;
    }
    my @@h = $CPAN::term->GetHistory;
    splice @@h, 0, @@h-$histsize if @@h>$histsize;
    my($fh) = FileHandle->new;
    open $fh, ">$histfile" or $CPAN::Frontend->mydie("Couldn't open >$histfile: $!");
    local $\ = local $, = "\n";
    print $fh @@h;
    close $fh;
}

#-> sub CPAN::is_tested
sub is_tested {
    my($self,$what,$when) = @@_;
    unless ($what) {
        Carp::cluck("DEBUG: empty what");
        return;
    }
    $self->{is_tested}{$what} = $when;
}

#-> sub CPAN::reset_tested
# forget all distributions tested -- resets what gets included in PERL5LIB
sub reset_tested {
    my ($self) = @@_;
    $self->{is_tested} = {};
}

#-> sub CPAN::is_installed
# unsets the is_tested flag: as soon as the thing is installed, it is
# not needed in set_perl5lib anymore
sub is_installed {
    my($self,$what) = @@_;
    delete $self->{is_tested}{$what};
}

sub _list_sorted_descending_is_tested {
    my($self) = @@_;
    sort
        { ($self->{is_tested}{$b}||0) <=> ($self->{is_tested}{$a}||0) }
            keys %{$self->{is_tested}}
}

#-> sub CPAN::set_perl5lib
# Notes on max environment variable length:
#   - Win32 : XP or later, 8191; Win2000 or NT4, 2047
{
my $fh;
sub set_perl5lib {
    my($self,$for) = @@_;
    unless ($for) {
        (undef,undef,undef,$for) = caller(1);
        $for =~ s/.*://;
    }
    $self->{is_tested} ||= {};
    return unless %{$self->{is_tested}};
    my $env = $ENV{PERL5LIB};
    $env = $ENV{PERLLIB} unless defined $env;
    my @@env;
    push @@env, split /\Q$Config::Config{path_sep}\E/, $env if defined $env and length $env;
    #my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} keys %{$self->{is_tested}};
    #$CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB.\n");

    my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} $self->_list_sorted_descending_is_tested;
    return if !@@dirs;

    if (@@dirs < 12) {
        $CPAN::Frontend->optprint('perl5lib', "Prepending @@dirs to PERL5LIB for '$for'\n");
        $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
    } elsif (@@dirs < 24 ) {
        my @@d = map {my $cp = $_;
                     $cp =~ s/^\Q$CPAN::Config->{build_dir}\E/%BUILDDIR%/;
                     $cp
                 } @@dirs;
        $CPAN::Frontend->optprint('perl5lib', "Prepending @@d to PERL5LIB; ".
                                 "%BUILDDIR%=$CPAN::Config->{build_dir} ".
                                 "for '$for'\n"
                                );
        $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
    } else {
        my $cnt = keys %{$self->{is_tested}};
        $CPAN::Frontend->optprint('perl5lib', "Prepending blib/arch and blib/lib of ".
                                 "$cnt build dirs to PERL5LIB; ".
                                 "for '$for'\n"
                                );
        $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
    }
}}


1;


__END__

=head1 NAME

CPAN - query, download and build perl modules from CPAN sites

=head1 SYNOPSIS

Interactive mode:

  perl -MCPAN -e shell

--or--

  cpan

Basic commands:

  # Modules:

  cpan> install Acme::Meta                       # in the shell

  CPAN::Shell->install("Acme::Meta");            # in perl

  # Distributions:

  cpan> install NWCLARK/Acme-Meta-0.02.tar.gz    # in the shell

  CPAN::Shell->
    install("NWCLARK/Acme-Meta-0.02.tar.gz");    # in perl

  # module objects:

  $mo = CPAN::Shell->expandany($mod);
  $mo = CPAN::Shell->expand("Module",$mod);      # same thing

  # distribution objects:

  $do = CPAN::Shell->expand("Module",$mod)->distribution;
  $do = CPAN::Shell->expandany($distro);         # same thing
  $do = CPAN::Shell->expand("Distribution",
                            $distro);            # same thing

=head1 DESCRIPTION

The CPAN module automates or at least simplifies the make and install
of perl modules and extensions. It includes some primitive searching
capabilities and knows how to use Net::FTP, LWP, and certain external
download clients to fetch distributions from the net.

These are fetched from one or more mirrored CPAN (Comprehensive
Perl Archive Network) sites and unpacked in a dedicated directory.

The CPAN module also supports named and versioned
I<bundles> of modules. Bundles simplify handling of sets of
related modules. See Bundles below.

The package contains a session manager and a cache manager. The
session manager keeps track of what has been fetched, built, and
installed in the current session. The cache manager keeps track of the
disk space occupied by the make processes and deletes excess space
using a simple FIFO mechanism.

All methods provided are accessible in a programmer style and in an
interactive shell style.

=head2 CPAN::shell([$prompt, $command]) Starting Interactive Mode

Enter interactive mode by running

    perl -MCPAN -e shell

or

    cpan

which puts you into a readline interface. If C<Term::ReadKey> and
either of C<Term::ReadLine::Perl> or C<Term::ReadLine::Gnu> are installed,
history and command completion are supported.

Once at the command line, type C<h> for one-page help
screen; the rest should be self-explanatory.

The function call C<shell> takes two optional arguments: one the
prompt, the second the default initial command line (the latter
only works if a real ReadLine interface module is installed).

The most common uses of the interactive modes are

=over 2

=item Searching for authors, bundles, distribution files and modules

There are corresponding one-letter commands C<a>, C<b>, C<d>, and C<m>
for each of the four categories and another, C<i> for any of the
mentioned four. Each of the four entities is implemented as a class
with slightly differing methods for displaying an object.

Arguments to these commands are either strings exactly matching
the identification string of an object, or regular expressions 
matched case-insensitively against various attributes of the
objects. The parser only recognizes a regular expression when you
enclose it with slashes.

The principle is that the number of objects found influences how an
item is displayed. If the search finds one item, the result is
displayed with the rather verbose method C<as_string>, but if 
more than one is found, each object is displayed with the terse method
C<as_glimpse>.

Examples:

  cpan> m Acme::MetaSyntactic
  Module id = Acme::MetaSyntactic
      CPAN_USERID  BOOK (Philippe Bruhat (BooK) <[...]>)
      CPAN_VERSION 0.99
      CPAN_FILE    B/BO/BOOK/Acme-MetaSyntactic-0.99.tar.gz
      UPLOAD_DATE  2006-11-06
      MANPAGE      Acme::MetaSyntactic - Themed metasyntactic variables names
      INST_FILE    /usr/local/lib/perl/5.10.0/Acme/MetaSyntactic.pm
      INST_VERSION 0.99
  cpan> a BOOK
  Author id = BOOK
      EMAIL        [...]
      FULLNAME     Philippe Bruhat (BooK)
  cpan> d BOOK/Acme-MetaSyntactic-0.99.tar.gz
  Distribution id = B/BO/BOOK/Acme-MetaSyntactic-0.99.tar.gz
      CPAN_USERID  BOOK (Philippe Bruhat (BooK) <[...]>)
      CONTAINSMODS Acme::MetaSyntactic Acme::MetaSyntactic::Alias [...]
      UPLOAD_DATE  2006-11-06
  cpan> m /lorem/
  Module  = Acme::MetaSyntactic::loremipsum (BOOK/Acme-MetaSyntactic-0.99.tar.gz)
  Module    Text::Lorem            (ADEOLA/Text-Lorem-0.3.tar.gz)
  Module    Text::Lorem::More      (RKRIMEN/Text-Lorem-More-0.12.tar.gz)
  Module    Text::Lorem::More::Source (RKRIMEN/Text-Lorem-More-0.12.tar.gz)
  cpan> i /berlin/
  Distribution    BEATNIK/Filter-NumberLines-0.02.tar.gz
  Module  = DateTime::TimeZone::Europe::Berlin (DROLSKY/DateTime-TimeZone-0.7904.tar.gz)
  Module    Filter::NumberLines    (BEATNIK/Filter-NumberLines-0.02.tar.gz)
  Author          [...]

The examples illustrate several aspects: the first three queries
target modules, authors, or distros directly and yield exactly one
result. The last two use regular expressions and yield several
results. The last one targets all of bundles, modules, authors, and
distros simultaneously. When more than one result is available, they
are printed in one-line format.

=item C<get>, C<make>, C<test>, C<install>, C<clean> modules or distributions

These commands take any number of arguments and investigate what is
necessary to perform the action. If the argument is a distribution
file name (recognized by embedded slashes), it is processed. If it is
a module, CPAN determines the distribution file in which this module
is included and processes that, following any dependencies named in
the module's META.yml or Makefile.PL (this behavior is controlled by
the configuration parameter C<prerequisites_policy>.)

C<get> downloads a distribution file and untars or unzips it, C<make>
builds it, C<test> runs the test suite, and C<install> installs it.

Any C<make> or C<test> is run unconditionally. An

  install <distribution_file>

is also run unconditionally. But for

  install <module>

CPAN checks whether an install is needed and prints
I<module up to date> if the distribution file containing
the module doesn't need updating.

CPAN also keeps track of what it has done within the current session
and doesn't try to build a package a second time regardless of whether it
succeeded or not. It does not repeat a test run if the test
has been run successfully before. Same for install runs.

The C<force> pragma may precede another command (currently: C<get>,
C<make>, C<test>, or C<install>) to execute the command from scratch
and attempt to continue past certain errors. See the section below on
the C<force> and the C<fforce> pragma.

The C<notest> pragma skips the test part in the build
process.

Example:

    cpan> notest install Tk

A C<clean> command results in a

  make clean

being executed within the distribution file's working directory.

=item C<readme>, C<perldoc>, C<look> module or distribution

C<readme> displays the README file of the associated distribution.
C<Look> gets and untars (if not yet done) the distribution file,
changes to the appropriate directory and opens a subshell process in
that directory. C<perldoc> displays the module's pod documentation 
in html or plain text format.

=item C<ls> author

=item C<ls> globbing_expression

The first form lists all distribution files in and below an author's
CPAN directory as stored in the CHECKUMS files distributed on
CPAN. The listing recurses into subdirectories.

The second form limits or expands the output with shell
globbing as in the following examples:

      ls JV/make*
      ls GSAR/*make*
      ls */*make*

The last example is very slow and outputs extra progress indicators
that break the alignment of the result.

Note that globbing only lists directories explicitly asked for, for
example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be
regarded as a bug that may be changed in some future version.

=item C<failed>

The C<failed> command reports all distributions that failed on one of
C<make>, C<test> or C<install> for some reason in the currently
running shell session.

=item Persistence between sessions

If the C<YAML> or the C<YAML::Syck> module is installed a record of
the internal state of all modules is written to disk after each step.
The files contain a signature of the currently running perl version
for later perusal.

If the configurations variable C<build_dir_reuse> is set to a true
value, then CPAN.pm reads the collected YAML files. If the stored
signature matches the currently running perl, the stored state is
loaded into memory such that persistence between sessions
is effectively established.

=item The C<force> and the C<fforce> pragma

To speed things up in complex installation scenarios, CPAN.pm keeps
track of what it has already done and refuses to do some things a
second time. A C<get>, a C<make>, and an C<install> are not repeated.
A C<test> is repeated only if the previous test was unsuccessful. The
diagnostic message when CPAN.pm refuses to do something a second time
is one of I<Has already been >C<unwrapped|made|tested successfully> or
something similar. Another situation where CPAN refuses to act is an
C<install> if the corresponding C<test> was not successful.

In all these cases, the user can override this stubborn behaviour by
prepending the command with the word force, for example:

  cpan> force get Foo
  cpan> force make AUTHOR/Bar-3.14.tar.gz
  cpan> force test Baz
  cpan> force install Acme::Meta

Each I<forced> command is executed with the corresponding part of its
memory erased.

The C<fforce> pragma is a variant that emulates a C<force get> which
erases the entire memory followed by the action specified, effectively
restarting the whole get/make/test/install procedure from scratch.

=item Lockfile

Interactive sessions maintain a lockfile, by default C<~/.cpan/.lock>.
Batch jobs can run without a lockfile and not disturb each other.

The shell offers to run in I<downgraded mode> when another process is
holding the lockfile. This is an experimental feature that is not yet
tested very well. This second shell then does not write the history
file, does not use the metadata file, and has a different prompt.

=item Signals

CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are
in the cpan-shell, it is intended that you can press C<^C> anytime and
return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell
to clean up and leave the shell loop. You can emulate the effect of a
SIGTERM by sending two consecutive SIGINTs, which usually means by
pressing C<^C> twice.

CPAN.pm ignores SIGPIPE. If the user sets C<inactivity_timeout>, a
SIGALRM is used during the run of the C<perl Makefile.PL> or C<perl
Build.PL> subprocess.

=back

=head2 CPAN::Shell

The commands available in the shell interface are methods in
the package CPAN::Shell. If you enter the shell command, your
input is split by the Text::ParseWords::shellwords() routine, which
acts like most shells do. The first word is interpreted as the
method to be invoked, and the rest of the words are treated as the method's arguments.
Continuation lines are supported by ending a line with a
literal backslash.

=head2 autobundle

C<autobundle> writes a bundle file into the
C<$CPAN::Config-E<gt>{cpan_home}/Bundle> directory. The file contains
a list of all modules that are both available from CPAN and currently
installed within @@INC. The name of the bundle file is based on the
current date and a counter.

=head2 hosts

Note: this feature is still in alpha state and may change in future
versions of CPAN.pm

This commands provides a statistical overview over recent download
activities. The data for this is collected in the YAML file
C<FTPstats.yml> in your C<cpan_home> directory. If no YAML module is
configured or YAML not installed, no stats are provided.

=head2 mkmyconfig

mkmyconfig() writes your own CPAN::MyConfig file into your C<~/.cpan/>
directory so that you can save your own preferences instead of the
system-wide ones.

=head2 recent ***EXPERIMENTAL COMMAND***

The C<recent> command downloads a list of recent uploads to CPAN and
displays them I<slowly>. While the command is running, a $SIG{INT} 
exits the loop after displaying the current item.

B<Note>: This command requires XML::LibXML installed.

B<Note>: This whole command currently is just a hack and will
probably change in future versions of CPAN.pm, but the general
approach will likely remain.

B<Note>: See also L<smoke>

=head2 recompile

recompile() is a special command that takes no argument and
runs the make/test/install cycle with brute force over all installed
dynamically loadable extensions (aka XS modules) with 'force' in
effect. The primary purpose of this command is to finish a network
installation. Imagine you have a common source tree for two different
architectures. You decide to do a completely independent fresh
installation. You start on one architecture with the help of a Bundle
file produced earlier. CPAN installs the whole Bundle for you, but
when you try to repeat the job on the second architecture, CPAN
responds with a C<"Foo up to date"> message for all modules. So you
invoke CPAN's recompile on the second architecture and you're done.

Another popular use for C<recompile> is to act as a rescue in case your
perl breaks binary compatibility. If one of the modules that CPAN uses
is in turn depending on binary compatibility (so you cannot run CPAN
commands), then you should try the CPAN::Nox module for recovery.

=head2 report Bundle|Distribution|Module

The C<report> command temporarily turns on the C<test_report> config
variable, then runs the C<force test> command with the given
arguments. The C<force> pragma reruns the tests and repeats
every step that might have failed before.

=head2 smoke ***EXPERIMENTAL COMMAND***

B<*** WARNING: this command downloads and executes software from CPAN to
your computer of completely unknown status. You should never do
this with your normal account and better have a dedicated well
separated and secured machine to do this. ***>

The C<smoke> command takes the list of recent uploads to CPAN as
provided by the C<recent> command and tests them all. While the
command is running $SIG{INT} is defined to mean that the current item
shall be skipped.

B<Note>: This whole command currently is just a hack and will
probably change in future versions of CPAN.pm, but the general
approach will likely remain.

B<Note>: See also L<recent>

=head2 upgrade [Module|/Regex/]...

The C<upgrade> command first runs an C<r> command with the given
arguments and then installs the newest versions of all modules that
were listed by that.

=head2 The four C<CPAN::*> Classes: Author, Bundle, Module, Distribution

Although it may be considered internal, the class hierarchy does matter
for both users and programmer. CPAN.pm deals with the four
classes mentioned above, and those classes all share a set of methods. Classical
single polymorphism is in effect. A metaclass object registers all
objects of all kinds and indexes them with a string. The strings
referencing objects have a separated namespace (well, not completely
separated):

         Namespace                         Class

   words containing a "/" (slash)      Distribution
    words starting with Bundle::          Bundle
          everything else            Module or Author

Modules know their associated Distribution objects. They always refer
to the most recent official release. Developers may mark their releases
as unstable development versions (by inserting an underbar into the
module version number which will also be reflected in the distribution
name when you run 'make dist'), so the really hottest and newest
distribution is not always the default.  If a module Foo circulates
on CPAN in both version 1.23 and 1.23_90, CPAN.pm offers a convenient
way to install version 1.23 by saying

    install Foo

This would install the complete distribution file (say
BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would
like to install version 1.23_90, you need to know where the
distribution file resides on CPAN relative to the authors/id/
directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz;
so you would have to say

    install BAR/Foo-1.23_90.tar.gz

The first example will be driven by an object of the class
CPAN::Module, the second by an object of class CPAN::Distribution.

=head2 Integrating local directories

Note: this feature is still in alpha state and may change in future
versions of CPAN.pm

Distribution objects are normally distributions from the CPAN, but
there is a slightly degenerate case for Distribution objects, too, of
projects held on the local disk. These distribution objects have the
same name as the local directory and end with a dot. A dot by itself
is also allowed for the current directory at the time CPAN.pm was
used. All actions such as C<make>, C<test>, and C<install> are applied
directly to that directory. This gives the command C<cpan .> an
interesting touch: while the normal mantra of installing a CPAN module
without CPAN.pm is one of

    perl Makefile.PL                 perl Build.PL
           ( go and get prerequisites )
    make                             ./Build
    make test                        ./Build test
    make install                     ./Build install

the command C<cpan .> does all of this at once. It figures out which
of the two mantras is appropriate, fetches and installs all
prerequisites, takes care of them recursively, and finally finishes the
installation of the module in the current directory, be it a CPAN
module or not.

The typical usage case is for private modules or working copies of
projects from remote repositories on the local disk.

=head2 Redirection

The usual shell redirection symbols C< | > and C<< > >> are recognized
by the cpan shell B<only when surrounded by whitespace>. So piping to
pager or redirecting output into a file works somewhat as in a normal
shell, with the stipulation that you must type extra spaces.

=head1 CONFIGURATION

When the CPAN module is used for the first time, a configuration
dialogue tries to determine a couple of site specific options. The
result of the dialog is stored in a hash reference C< $CPAN::Config >
in a file CPAN/Config.pm.

Default values defined in the CPAN/Config.pm file can be
overridden in a user specific file: CPAN/MyConfig.pm. Such a file is
best placed in C<$HOME/.cpan/CPAN/MyConfig.pm>, because C<$HOME/.cpan> is
added to the search path of the CPAN module before the use() or
require() statements. The mkmyconfig command writes this file for you.

The C<o conf> command has various bells and whistles:

=over

=item completion support

If you have a ReadLine module installed, you can hit TAB at any point
of the commandline and C<o conf> will offer you completion for the
built-in subcommands and/or config variable names.

=item displaying some help: o conf help

Displays a short help

=item displaying current values: o conf [KEY]

Displays the current value(s) for this config variable. Without KEY,
displays all subcommands and config variables.

Example:

  o conf shell

If KEY starts and ends with a slash, the string in between is
treated as a regular expression and only keys matching this regex
are displayed

Example:

  o conf /color/

=item changing of scalar values: o conf KEY VALUE

Sets the config variable KEY to VALUE. The empty string can be
specified as usual in shells, with C<''> or C<"">

Example:

  o conf wget /usr/bin/wget

=item changing of list values: o conf KEY SHIFT|UNSHIFT|PUSH|POP|SPLICE|LIST

If a config variable name ends with C<list>, it is a list. C<o conf
KEY shift> removes the first element of the list, C<o conf KEY pop>
removes the last element of the list. C<o conf KEYS unshift LIST>
prepends a list of values to the list, C<o conf KEYS push LIST>
appends a list of valued to the list.

Likewise, C<o conf KEY splice LIST> passes the LIST to the corresponding
splice command.

Finally, any other list of arguments is taken as a new list value for
the KEY variable discarding the previous value.

Examples:

  o conf urllist unshift http://cpan.dev.local/CPAN
  o conf urllist splice 3 1
  o conf urllist http://cpan1.local http://cpan2.local ftp://ftp.perl.org

=item reverting to saved: o conf defaults

Reverts all config variables to the state in the saved config file.

=item saving the config: o conf commit

Saves all config variables to the current config file (CPAN/Config.pm
or CPAN/MyConfig.pm that was loaded at start).

=back

The configuration dialog can be started any time later again by
issuing the command C< o conf init > in the CPAN shell. A subset of
the configuration dialog can be run by issuing C<o conf init WORD>
where WORD is any valid config variable or a regular expression.

=head2 Config Variables

The following keys in the hash reference $CPAN::Config are
currently defined:

  applypatch         path to external prg
  auto_commit        commit all changes to config variables to disk
  build_cache        size of cache for directories to build modules
  build_dir          locally accessible directory to build modules
  build_dir_reuse    boolean if distros in build_dir are persistent
  build_requires_install_policy
                     to install or not to install when a module is
                     only needed for building. yes|no|ask/yes|ask/no
  bzip2              path to external prg
  cache_metadata     use serializer to cache metadata
  check_sigs         if signatures should be verified
  colorize_debug     Term::ANSIColor attributes for debugging output
  colorize_output    boolean if Term::ANSIColor should colorize output
  colorize_print     Term::ANSIColor attributes for normal output
  colorize_warn      Term::ANSIColor attributes for warnings
  commandnumber_in_prompt
                     boolean if you want to see current command number
  commands_quote     preferred character to use for quoting external
                     commands when running them. Defaults to double
                     quote on Windows, single tick everywhere else;
                     can be set to space to disable quoting
  connect_to_internet_ok
                     whether to ask if opening a connection is ok before
                     urllist is specified
  cpan_home          local directory reserved for this package
  curl               path to external prg
  dontload_hash      DEPRECATED
  dontload_list      arrayref: modules in the list will not be
                     loaded by the CPAN::has_inst() routine
  ftp                path to external prg
  ftp_passive        if set, the envariable FTP_PASSIVE is set for downloads
  ftp_proxy          proxy host for ftp requests
  ftpstats_period    max number of days to keep download statistics
  ftpstats_size      max number of items to keep in the download statistics
  getcwd             see below
  gpg                path to external prg
  gzip               location of external program gzip
  halt_on_failure    stop processing after the first failure of queued
                     items or dependencies
  histfile           file to maintain history between sessions
  histsize           maximum number of lines to keep in histfile
  http_proxy         proxy host for http requests
  inactivity_timeout breaks interactive Makefile.PLs or Build.PLs
                     after this many seconds inactivity. Set to 0 to
                     disable timeouts.
  index_expire       refetch index files after this many days 
  inhibit_startup_message
                     if true, suppress the startup message
  keep_source_where  directory in which to keep the source (if we do)
  load_module_verbosity
                     report loading of optional modules used by CPAN.pm
  lynx               path to external prg
  make               location of external make program
  make_arg           arguments that should always be passed to 'make'
  make_install_make_command
                     the make command for running 'make install', for
                     example 'sudo make'
  make_install_arg   same as make_arg for 'make install'
  makepl_arg         arguments passed to 'perl Makefile.PL'
  mbuild_arg         arguments passed to './Build'
  mbuild_install_arg arguments passed to './Build install'
  mbuild_install_build_command
                     command to use instead of './Build' when we are
                     in the install stage, for example 'sudo ./Build'
  mbuildpl_arg       arguments passed to 'perl Build.PL'
  ncftp              path to external prg
  ncftpget           path to external prg
  no_proxy           don't proxy to these hosts/domains (comma separated list)
  pager              location of external program more (or any pager)
  password           your password if you CPAN server wants one
  patch              path to external prg
  patches_dir        local directory containing patch files
  perl5lib_verbosity verbosity level for PERL5LIB additions
  prefer_installer   legal values are MB and EUMM: if a module comes
                     with both a Makefile.PL and a Build.PL, use the
                     former (EUMM) or the latter (MB); if the module
                     comes with only one of the two, that one will be
                     used no matter the setting
  prerequisites_policy
                     what to do if you are missing module prerequisites
                     ('follow' automatically, 'ask' me, or 'ignore')
  prefs_dir          local directory to store per-distro build options
  proxy_user         username for accessing an authenticating proxy
  proxy_pass         password for accessing an authenticating proxy
  randomize_urllist  add some randomness to the sequence of the urllist
  scan_cache         controls scanning of cache ('atstart' or 'never')
  shell              your favorite shell
  show_unparsable_versions
                     boolean if r command tells which modules are versionless
  show_upload_date   boolean if commands should try to determine upload date
  show_zero_versions boolean if r command tells for which modules $version==0
  tar                location of external program tar
  tar_verbosity      verbosity level for the tar command
  term_is_latin      deprecated: if true Unicode is translated to ISO-8859-1
                     (and nonsense for characters outside latin range)
  term_ornaments     boolean to turn ReadLine ornamenting on/off
  test_report        email test reports (if CPAN::Reporter is installed)
  trust_test_report_history
                     skip testing when previously tested ok (according to
                     CPAN::Reporter history)
  unzip              location of external program unzip
  urllist            arrayref to nearby CPAN sites (or equivalent locations)
  use_sqlite         use CPAN::SQLite for metadata storage (fast and lean)
  username           your username if you CPAN server wants one
  wait_list          arrayref to a wait server to try (See CPAN::WAIT)
  wget               path to external prg
  yaml_load_code     enable YAML code deserialisation via CPAN::DeferredCode
  yaml_module        which module to use to read/write YAML files

You can set and query each of these options interactively in the cpan
shell with the C<o conf> or the C<o conf init> command as specified below.

=over 2

=item C<o conf E<lt>scalar optionE<gt>>

prints the current value of the I<scalar option>

=item C<o conf E<lt>scalar optionE<gt> E<lt>valueE<gt>>

Sets the value of the I<scalar option> to I<value>

=item C<o conf E<lt>list optionE<gt>>

prints the current value of the I<list option> in MakeMaker's
neatvalue format.

=item C<o conf E<lt>list optionE<gt> [shift|pop]>

shifts or pops the array in the I<list option> variable

=item C<o conf E<lt>list optionE<gt> [unshift|push|splice] E<lt>listE<gt>>

works like the corresponding perl commands.

=item interactive editing: o conf init [MATCH|LIST]

Runs an interactive configuration dialog for matching variables.
Without argument runs the dialog over all supported config variables.
To specify a MATCH the argument must be enclosed by slashes.

Examples:

  o conf init ftp_passive ftp_proxy
  o conf init /color/

Note: this method of setting config variables often provides more
explanation about the functioning of a variable than the manpage.

=back

=head2 CPAN::anycwd($path): Note on config variable getcwd

CPAN.pm changes the current working directory often and needs to
determine its own current working directory. By default it uses
Cwd::cwd, but if for some reason this doesn't work on your system,
configure alternatives according to the following table:

=over 4

=item cwd

Calls Cwd::cwd

=item getcwd

Calls Cwd::getcwd

=item fastcwd

Calls Cwd::fastcwd

=item backtickcwd

Calls the external command cwd.

=back

=head2 Note on the format of the urllist parameter

urllist parameters are URLs according to RFC 1738. We do a little
guessing if your URL is not compliant, but if you have problems with
C<file> URLs, please try the correct format. Either:

    file://localhost/whatever/ftp/pub/CPAN/

or

    file:///home/ftp/pub/CPAN/

=head2 The urllist parameter has CD-ROM support

The C<urllist> parameter of the configuration table contains a list of
URLs used for downloading. If the list contains any
C<file> URLs, CPAN always tries there first. This
feature is disabled for index files. So the recommendation for the
owner of a CD-ROM with CPAN contents is: include your local, possibly
outdated CD-ROM as a C<file> URL at the end of urllist, e.g.

  o conf urllist push file://localhost/CDROM/CPAN

CPAN.pm will then fetch the index files from one of the CPAN sites
that come at the beginning of urllist. It will later check for each
module to see whether there is a local copy of the most recent version.

Another peculiarity of urllist is that the site that we could
successfully fetch the last file from automatically gets a preference
token and is tried as the first site for the next request. So if you
add a new site at runtime it may happen that the previously preferred
site will be tried another time. This means that if you want to disallow
a site for the next transfer, it must be explicitly removed from
urllist.

=head2 Maintaining the urllist parameter

If you have YAML.pm (or some other YAML module configured in
C<yaml_module>) installed, CPAN.pm collects a few statistical data
about recent downloads. You can view the statistics with the C<hosts>
command or inspect them directly by looking into the C<FTPstats.yml>
file in your C<cpan_home> directory.

To get some interesting statistics, it is recommended that
C<randomize_urllist> be set; this introduces some amount of
randomness into the URL selection.

=head2 The C<requires> and C<build_requires> dependency declarations

Since CPAN.pm version 1.88_51 modules declared as C<build_requires> by
a distribution are treated differently depending on the config
variable C<build_requires_install_policy>. By setting
C<build_requires_install_policy> to C<no>, such a module is not 
installed. It is only built and tested, and then kept in the list of
tested but uninstalled modules. As such, it is available during the
build of the dependent module by integrating the path to the
C<blib/arch> and C<blib/lib> directories in the environment variable
PERL5LIB. If C<build_requires_install_policy> is set ti C<yes>, then
both modules declared as C<requires> and those declared as
C<build_requires> are treated alike. By setting to C<ask/yes> or
C<ask/no>, CPAN.pm asks the user and sets the default accordingly.

=head2 Configuration for individual distributions (I<Distroprefs>)

(B<Note:> This feature has been introduced in CPAN.pm 1.8854 and is
still considered beta quality)

Distributions on CPAN usually behave according to what we call the
CPAN mantra. Or since the advent of Module::Build we should talk about
two mantras:

    perl Makefile.PL     perl Build.PL
    make                 ./Build
    make test            ./Build test
    make install         ./Build install

But some modules cannot be built with this mantra. They try to get
some extra data from the user via the environment, extra arguments, or
interactively--thus disturbing the installation of large bundles like
Phalanx100 or modules with many dependencies like Plagger.

The distroprefs system of C<CPAN.pm> addresses this problem by
allowing the user to specify extra informations and recipes in YAML
files to either

=over

=item

pass additional arguments to one of the four commands,

=item

set environment variables

=item

instantiate an Expect object that reads from the console, waits for
some regular expressions and enters some answers

=item

temporarily override assorted C<CPAN.pm> configuration variables

=item

specify dependencies the original maintainer forgot 

=item

disable the installation of an object altogether

=back

See the YAML and Data::Dumper files that come with the C<CPAN.pm>
distribution in the C<distroprefs/> directory for examples.

=head2 Filenames

The YAML files themselves must have the C<.yml> extension; all other
files are ignored (for two exceptions see I<Fallback Data::Dumper and
Storable> below). The containing directory can be specified in
C<CPAN.pm> in the C<prefs_dir> config variable. Try C<o conf init
prefs_dir> in the CPAN shell to set and activate the distroprefs
system.

Every YAML file may contain arbitrary documents according to the YAML
specification, and every document is treated as an entity that
can specify the treatment of a single distribution.

Filenames can be picked arbitrarily; C<CPAN.pm> always reads
all files (in alphabetical order) and takes the key C<match> (see
below in I<Language Specs>) as a hashref containing match criteria
that determine if the current distribution matches the YAML document
or not.

=head2 Fallback Data::Dumper and Storable

If neither your configured C<yaml_module> nor YAML.pm is installed,
CPAN.pm falls back to using Data::Dumper and Storable and looks for
files with the extensions C<.dd> or C<.st> in the C<prefs_dir>
directory. These files are expected to contain one or more hashrefs.
For Data::Dumper generated files, this is expected to be done with by
defining C<$VAR1>, C<$VAR2>, etc. The YAML shell would produce these
with the command

    ysh < somefile.yml > somefile.dd

For Storable files the rule is that they must be constructed such that
C<Storable::retrieve(file)> returns an array reference and the array
elements represent one distropref object each. The conversion from
YAML would look like so:

    perl -MYAML=LoadFile -MStorable=nstore -e '
        @@y=LoadFile(shift);
        nstore(\@@y, shift)' somefile.yml somefile.st

In bootstrapping situations it is usually sufficient to translate only
a few YAML files to Data::Dumper for crucial modules like
C<YAML::Syck>, C<YAML.pm> and C<Expect.pm>. If you prefer Storable
over Data::Dumper, remember to pull out a Storable version that writes
an older format than all the other Storable versions that will need to
read them.

=head2 Blueprint

The following example contains all supported keywords and structures
with the exception of C<eexpect> which can be used instead of
C<expect>.

  ---
  comment: "Demo"
  match:
    module: "Dancing::Queen"
    distribution: "^CHACHACHA/Dancing-"
    not_distribution: "\.zip$"
    perl: "/usr/local/cariba-perl/bin/perl"
    perlconfig:
      archname: "freebsd"
      not_cc: "gcc"
    env:
      DANCING_FLOOR: "Shubiduh"
  disabled: 1
  cpanconfig:
    make: gmake
  pl:
    args:
      - "--somearg=specialcase"

    env: {}

    expect:
      - "Which is your favorite fruit"
      - "apple\n"

  make:
    args:
      - all
      - extra-all

    env: {}

    expect: []

    commendline: "echo SKIPPING make"

  test:
    args: []

    env: {}

    expect: []

  install:
    args: []

    env:
      WANT_TO_INSTALL: YES

    expect:
      - "Do you really want to install"
      - "y\n"

  patches:
    - "ABCDE/Fedcba-3.14-ABCDE-01.patch"

  depends:
    configure_requires:
      LWP: 5.8
    build_requires:
      Test::Exception: 0.25
    requires:
      Spiffy: 0.30


=head2 Language Specs

Every YAML document represents a single hash reference. The valid keys
in this hash are as follows:

=over

=item comment [scalar]

A comment

=item cpanconfig [hash]

Temporarily override assorted C<CPAN.pm> configuration variables.

Supported are: C<build_requires_install_policy>, C<check_sigs>,
C<make>, C<make_install_make_command>, C<prefer_installer>,
C<test_report>. Please report as a bug when you need another one
supported.

=item depends [hash] *** EXPERIMENTAL FEATURE ***

All three types, namely C<configure_requires>, C<build_requires>, and
C<requires> are supported in the way specified in the META.yml
specification. The current implementation I<merges> the specified
dependencies with those declared by the package maintainer. In a
future implementation this may be changed to override the original
declaration.

=item disabled [boolean]

Specifies that this distribution shall not be processed at all.

=item features [array] *** EXPERIMENTAL FEATURE ***

Experimental implementation to deal with optional_features from
META.yml. Still needs coordination with installer software and
currently works only for META.yml declaring C<dynamic_config=0>. Use
with caution.

=item goto [string]

The canonical name of a delegate distribution to install
instead. Useful when a new version, although it tests OK itself,
breaks something else or a developer release or a fork is already
uploaded that is better than the last released version.

=item install [hash]

Processing instructions for the C<make install> or C<./Build install>
phase of the CPAN mantra. See below under I<Processing Instructions>.

=item make [hash]

Processing instructions for the C<make> or C<./Build> phase of the
CPAN mantra. See below under I<Processing Instructions>.

=item match [hash]

A hashref with one or more of the keys C<distribution>, C<modules>,
C<perl>, C<perlconfig>, and C<env> that specify whether a document is
targeted at a specific CPAN distribution or installation.
Keys prefixed with C<not_> negates the corresponding match.

The corresponding values are interpreted as regular expressions. The
C<distribution> related one will be matched against the canonical
distribution name, e.g. "AUTHOR/Foo-Bar-3.14.tar.gz".

The C<module> related one will be matched against I<all> modules
contained in the distribution until one module matches.

The C<perl> related one will be matched against C<$^X> (but with the
absolute path).

The value associated with C<perlconfig> is itself a hashref that is
matched against corresponding values in the C<%Config::Config> hash
living in the C<Config.pm> module.
Keys prefixed with C<not_> negates the corresponding match.

The value associated with C<env> is itself a hashref that is
matched against corresponding values in the C<%ENV> hash.
Keys prefixed with C<not_> negates the corresponding match.

If more than one restriction of C<module>, C<distribution>, etc. is
specified, the results of the separately computed match values must
all match. If so, the hashref represented by the
YAML document is returned as the preference structure for the current
distribution.

=item patches [array]

An array of patches on CPAN or on the local disk to be applied in
order via an external patch program. If the value for the C<-p>
parameter is C<0> or C<1> is determined by reading the patch
beforehand. The path to each patch is either an absolute path on the
local filesystem or relative to a patch directory specified in the
C<patches_dir> configuration variable or in the format of a canonical
distroname. For examples please consult the distroprefs/ directory in
the CPAN.pm distribution (these examples are not installed by
default).

Note: if the C<applypatch> program is installed and C<CPAN::Config>
knows about it B<and> a patch is written by the C<makepatch> program,
then C<CPAN.pm> lets C<applypatch> apply the patch. Both C<makepatch>
and C<applypatch> are available from CPAN in the C<JV/makepatch-*>
distribution.

=item pl [hash]

Processing instructions for the C<perl Makefile.PL> or C<perl
Build.PL> phase of the CPAN mantra. See below under I<Processing
Instructions>.

=item test [hash]

Processing instructions for the C<make test> or C<./Build test> phase
of the CPAN mantra. See below under I<Processing Instructions>.

=back

=head2 Processing Instructions

=over

=item args [array]

Arguments to be added to the command line

=item commandline

A full commandline to run via C<system()>.
During execution, the environment variable PERL is set
to $^X (but with an absolute path). If C<commandline> is specified,
C<args> is not used.

=item eexpect [hash]

Extended C<expect>. This is a hash reference with four allowed keys,
C<mode>, C<timeout>, C<reuse>, and C<talk>.

C<mode> may have the values C<deterministic> for the case where all
questions come in the order written down and C<anyorder> for the case
where the questions may come in any order. The default mode is
C<deterministic>.

C<timeout> denotes a timeout in seconds. Floating-point timeouts are
OK. With C<mode=deterministic>, the timeout denotes the
timeout per question; with C<mode=anyorder> it denotes the
timeout per byte received from the stream or questions.

C<talk> is a reference to an array that contains alternating questions
and answers. Questions are regular expressions and answers are literal
strings. The Expect module watches the stream from the
execution of the external program (C<perl Makefile.PL>, C<perl
Build.PL>, C<make>, etc.).

For C<mode=deterministic>, the CPAN.pm injects the
corresponding answer as soon as the stream matches the regular expression.

For C<mode=anyorder> CPAN.pm answers a question as soon
as the timeout is reached for the next byte in the input stream. In
this mode you can use the C<reuse> parameter to decide what will
happen with a question-answer pair after it has been used. In the
default case (reuse=0) it is removed from the array, avoiding being
used again accidentally. If you want to answer the
question C<Do you really want to do that> several times, then it must
be included in the array at least as often as you want this answer to
be given. Setting the parameter C<reuse> to 1 makes this repetition
unnecessary.

=item env [hash]

Environment variables to be set during the command

=item expect [array]

C<< expect: <array> >> is a short notation for

eexpect:
    mode: deterministic
    timeout: 15
    talk: <array>

=back

=head2 Schema verification with C<Kwalify>

If you have the C<Kwalify> module installed (which is part of the
Bundle::CPANxxl), then all your distroprefs files are checked for
syntactic correctness.

=head2 Example Distroprefs Files

C<CPAN.pm> comes with a collection of example YAML files. Note that these
are really just examples and should not be used without care because
they cannot fit everybody's purpose. After all, the authors of the
packages that ask questions had a need to ask, so you should watch
their questions and adjust the examples to your environment and your
needs. You have been warned:-)

=head1 PROGRAMMER'S INTERFACE

If you do not enter the shell, shell commands are 
available both as methods (C<CPAN::Shell-E<gt>install(...)>) and as
functions in the calling package (C<install(...)>).  Before calling low-level
commands, it makes sense to initialize components of CPAN you need, e.g.:

  CPAN::HandleConfig->load;
  CPAN::Shell::setup_output;
  CPAN::Index->reload;

High-level commands do such initializations automatically.

There's currently only one class that has a stable interface -
CPAN::Shell. All commands that are available in the CPAN shell are
methods of the class CPAN::Shell. Each of the commands that produce
listings of modules (C<r>, C<autobundle>, C<u>) also return a list of
the IDs of all modules within the list.

=over 2

=item expand($type,@@things)

The IDs of all objects available within a program are strings that can
be expanded to the corresponding real objects with the
C<CPAN::Shell-E<gt>expand("Module",@@things)> method. Expand returns a
list of CPAN::Module objects according to the C<@@things> arguments
given. In scalar context, it returns only the first element of the
list.

=item expandany(@@things)

Like expand, but returns objects of the appropriate type, i.e.
CPAN::Bundle objects for bundles, CPAN::Module objects for modules, and
CPAN::Distribution objects for distributions. Note: it does not expand
to CPAN::Author objects.

=item Programming Examples

This enables the programmer to do operations that combine
functionalities that are available in the shell.

    # install everything that is outdated on my disk:
    perl -MCPAN -e 'CPAN::Shell->install(CPAN::Shell->r)'

    # install my favorite programs if necessary:
    for $mod (qw(Net::FTP Digest::SHA Data::Dumper)) {
        CPAN::Shell->install($mod);
    }

    # list all modules on my disk that have no VERSION number
    for $mod (CPAN::Shell->expand("Module","/./")) {
        next unless $mod->inst_file;
        # MakeMaker convention for undefined $VERSION:
        next unless $mod->inst_version eq "undef";
        print "No VERSION in ", $mod->id, "\n";
    }

    # find out which distribution on CPAN contains a module:
    print CPAN::Shell->expand("Module","Apache::Constants")->cpan_file

Or if you want to schedule a I<cron> job to watch CPAN, you could list
all modules that need updating. First a quick and dirty way:

    perl -e 'use CPAN; CPAN::Shell->r;'

If you don't want any output should all modules be
up to date, parse the output of above command for the regular
expression C</modules are up to date/> and decide to mail the output
only if it doesn't match. 

If you prefer to do it more in a programmerish style in one single
process, something like this may better suit you:

  # list all modules on my disk that have newer versions on CPAN
  for $mod (CPAN::Shell->expand("Module","/./")) {
    next unless $mod->inst_file;
    next if $mod->uptodate;
    printf "Module %s is installed as %s, could be updated to %s from CPAN\n",
        $mod->id, $mod->inst_version, $mod->cpan_version;
  }

If that gives too much output every day, you may want to
watch only for three modules. You can write

  for $mod (CPAN::Shell->expand("Module","/Apache|LWP|CGI/")) {

as the first line instead. Or you can combine some of the above
tricks:

  # watch only for a new mod_perl module
  $mod = CPAN::Shell->expand("Module","mod_perl");
  exit if $mod->uptodate;
  # new mod_perl arrived, let me know all update recommendations
  CPAN::Shell->r;

=back

=head2 Methods in the other Classes

=over 4

=item CPAN::Author::as_glimpse()

Returns a one-line description of the author

=item CPAN::Author::as_string()

Returns a multi-line description of the author

=item CPAN::Author::email()

Returns the author's email address

=item CPAN::Author::fullname()

Returns the author's name

=item CPAN::Author::name()

An alias for fullname

=item CPAN::Bundle::as_glimpse()

Returns a one-line description of the bundle

=item CPAN::Bundle::as_string()

Returns a multi-line description of the bundle

=item CPAN::Bundle::clean()

Recursively runs the C<clean> method on all items contained in the bundle.

=item CPAN::Bundle::contains()

Returns a list of objects' IDs contained in a bundle. The associated
objects may be bundles, modules or distributions.

=item CPAN::Bundle::force($method,@@args)

Forces CPAN to perform a task that it normally would have refused to
do. Force takes as arguments a method name to be called and any number
of additional arguments that should be passed to the called method.
The internals of the object get the needed changes so that CPAN.pm
does not refuse to take the action. The C<force> is passed recursively
to all contained objects. See also the section above on the C<force>
and the C<fforce> pragma.

=item CPAN::Bundle::get()

Recursively runs the C<get> method on all items contained in the bundle

=item CPAN::Bundle::inst_file()

Returns the highest installed version of the bundle in either @@INC or
C<$CPAN::Config->{cpan_home}>. Note that this is different from
CPAN::Module::inst_file.

=item CPAN::Bundle::inst_version()

Like CPAN::Bundle::inst_file, but returns the $VERSION

=item CPAN::Bundle::uptodate()

Returns 1 if the bundle itself and all its members are uptodate.

=item CPAN::Bundle::install()

Recursively runs the C<install> method on all items contained in the bundle

=item CPAN::Bundle::make()

Recursively runs the C<make> method on all items contained in the bundle

=item CPAN::Bundle::readme()

Recursively runs the C<readme> method on all items contained in the bundle

=item CPAN::Bundle::test()

Recursively runs the C<test> method on all items contained in the bundle

=item CPAN::Distribution::as_glimpse()

Returns a one-line description of the distribution

=item CPAN::Distribution::as_string()

Returns a multi-line description of the distribution

=item CPAN::Distribution::author

Returns the CPAN::Author object of the maintainer who uploaded this
distribution

=item CPAN::Distribution::pretty_id()

Returns a string of the form "AUTHORID/TARBALL", where AUTHORID is the
author's PAUSE ID and TARBALL is the distribution filename.

=item CPAN::Distribution::base_id()

Returns the distribution filename without any archive suffix.  E.g
"Foo-Bar-0.01"

=item CPAN::Distribution::clean()

Changes to the directory where the distribution has been unpacked and
runs C<make clean> there.

=item CPAN::Distribution::containsmods()

Returns a list of IDs of modules contained in a distribution file.
Works only for distributions listed in the 02packages.details.txt.gz
file. This typically means that just most recent version of a
distribution is covered.

=item CPAN::Distribution::cvs_import()

Changes to the directory where the distribution has been unpacked and
runs something like

    cvs -d $cvs_root import -m $cvs_log $cvs_dir $userid v$version

there.

=item CPAN::Distribution::dir()

Returns the directory into which this distribution has been unpacked.

=item CPAN::Distribution::force($method,@@args)

Forces CPAN to perform a task that it normally would have refused to
do. Force takes as arguments a method name to be called and any number
of additional arguments that should be passed to the called method.
The internals of the object get the needed changes so that CPAN.pm
does not refuse to take the action. See also the section above on the
C<force> and the C<fforce> pragma.

=item CPAN::Distribution::get()

Downloads the distribution from CPAN and unpacks it. Does nothing if
the distribution has already been downloaded and unpacked within the
current session.

=item CPAN::Distribution::install()

Changes to the directory where the distribution has been unpacked and
runs the external command C<make install> there. If C<make> has not
yet been run, it will be run first. A C<make test> is issued in
any case and if this fails, the install is cancelled. The
cancellation can be avoided by letting C<force> run the C<install> for
you.

This install method only has the power to install the distribution if
there are no dependencies in the way. To install an object along with all 
its dependencies, use CPAN::Shell->install.

Note that install() gives no meaningful return value. See uptodate().

=item CPAN::Distribution::install_tested()

Install all distributions that have tested sucessfully but
not yet installed. See also C<is_tested>.

=item CPAN::Distribution::isa_perl()

Returns 1 if this distribution file seems to be a perl distribution.
Normally this is derived from the file name only, but the index from
CPAN can contain a hint to achieve a return value of true for other
filenames too.

=item CPAN::Distribution::look()

Changes to the directory where the distribution has been unpacked and
opens a subshell there. Exiting the subshell returns.

=item CPAN::Distribution::make()

First runs the C<get> method to make sure the distribution is
downloaded and unpacked. Changes to the directory where the
distribution has been unpacked and runs the external commands C<perl
Makefile.PL> or C<perl Build.PL> and C<make> there.

=item CPAN::Distribution::perldoc()

Downloads the pod documentation of the file associated with a
distribution (in HTML format) and runs it through the external
command I<lynx> specified in C<$CPAN::Config->{lynx}>. If I<lynx>
isn't available, it converts it to plain text with the external
command I<html2text> and runs it through the pager specified
in C<$CPAN::Config->{pager}>

=item CPAN::Distribution::prefs()

Returns the hash reference from the first matching YAML file that the
user has deposited in the C<prefs_dir/> directory. The first
succeeding match wins. The files in the C<prefs_dir/> are processed
alphabetically, and the canonical distroname (e.g.
AUTHOR/Foo-Bar-3.14.tar.gz) is matched against the regular expressions
stored in the $root->{match}{distribution} attribute value.
Additionally all module names contained in a distribution are matched
against the regular expressions in the $root->{match}{module} attribute
value. The two match values are ANDed together. Each of the two
attributes are optional.

=item CPAN::Distribution::prereq_pm()

Returns the hash reference that has been announced by a distribution
as the C<requires> and C<build_requires> elements. These can be
declared either by the C<META.yml> (if authoritative) or can be
deposited after the run of C<Build.PL> in the file C<./_build/prereqs>
or after the run of C<Makfile.PL> written as the C<PREREQ_PM> hash in
a comment in the produced C<Makefile>. I<Note>: this method only works
after an attempt has been made to C<make> the distribution. Returns
undef otherwise.

=item CPAN::Distribution::readme()

Downloads the README file associated with a distribution and runs it
through the pager specified in C<$CPAN::Config->{pager}>.

=item CPAN::Distribution::reports()

Downloads report data for this distribution from www.cpantesters.org
and displays a subset of them.

=item CPAN::Distribution::read_yaml()

Returns the content of the META.yml of this distro as a hashref. Note:
works only after an attempt has been made to C<make> the distribution.
Returns undef otherwise. Also returns undef if the content of META.yml
is not authoritative. (The rules about what exactly makes the content
authoritative are still in flux.)

=item CPAN::Distribution::test()

Changes to the directory where the distribution has been unpacked and
runs C<make test> there.

=item CPAN::Distribution::uptodate()

Returns 1 if all the modules contained in the distribution are
uptodate. Relies on containsmods.

=item CPAN::Index::force_reload()

Forces a reload of all indices.

=item CPAN::Index::reload()

Reloads all indices if they have not been read for more than
C<$CPAN::Config->{index_expire}> days.

=item CPAN::InfoObj::dump()

CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution
inherit this method. It prints the data structure associated with an
object. Useful for debugging. Note: the data structure is considered
internal and thus subject to change without notice.

=item CPAN::Module::as_glimpse()

Returns a one-line description of the module in four columns: The
first column contains the word C<Module>, the second column consists
of one character: an equals sign if this module is already installed
and uptodate, a less-than sign if this module is installed but can be
upgraded, and a space if the module is not installed. The third column
is the name of the module and the fourth column gives maintainer or
distribution information.

=item CPAN::Module::as_string()

Returns a multi-line description of the module

=item CPAN::Module::clean()

Runs a clean on the distribution associated with this module.

=item CPAN::Module::cpan_file()

Returns the filename on CPAN that is associated with the module.

=item CPAN::Module::cpan_version()

Returns the latest version of this module available on CPAN.

=item CPAN::Module::cvs_import()

Runs a cvs_import on the distribution associated with this module.

=item CPAN::Module::description()

Returns a 44 character description of this module. Only available for
modules listed in The Module List (CPAN/modules/00modlist.long.html
or 00modlist.long.txt.gz)

=item CPAN::Module::distribution()

Returns the CPAN::Distribution object that contains the current
version of this module.

=item CPAN::Module::dslip_status()

Returns a hash reference. The keys of the hash are the letters C<D>,
C<S>, C<L>, C<I>, and <P>, for development status, support level,
language, interface and public licence respectively. The data for the
DSLIP status are collected by pause.perl.org when authors register
their namespaces. The values of the 5 hash elements are one-character
words whose meaning is described in the table below. There are also 5
hash elements C<DV>, C<SV>, C<LV>, C<IV>, and <PV> that carry a more
verbose value of the 5 status variables.

Where the 'DSLIP' characters have the following meanings:

  D - Development Stage  (Note: *NO IMPLIED TIMESCALES*):
    i   - Idea, listed to gain consensus or as a placeholder
    c   - under construction but pre-alpha (not yet released)
    a/b - Alpha/Beta testing
    R   - Released
    M   - Mature (no rigorous definition)
    S   - Standard, supplied with Perl 5

  S - Support Level:
    m   - Mailing-list
    d   - Developer
    u   - Usenet newsgroup comp.lang.perl.modules
    n   - None known, try comp.lang.perl.modules
    a   - abandoned; volunteers welcome to take over maintainance

  L - Language Used:
    p   - Perl-only, no compiler needed, should be platform independent
    c   - C and perl, a C compiler will be needed
    h   - Hybrid, written in perl with optional C code, no compiler needed
    +   - C++ and perl, a C++ compiler will be needed
    o   - perl and another language other than C or C++

  I - Interface Style
    f   - plain Functions, no references used
    h   - hybrid, object and function interfaces available
    n   - no interface at all (huh?)
    r   - some use of unblessed References or ties
    O   - Object oriented using blessed references and/or inheritance

  P - Public License
    p   - Standard-Perl: user may choose between GPL and Artistic
    g   - GPL: GNU General Public License
    l   - LGPL: "GNU Lesser General Public License" (previously known as
          "GNU Library General Public License")
    b   - BSD: The BSD License
    a   - Artistic license alone
    2   - Artistic license 2.0 or later
    o   - open source: appoved by www.opensource.org
    d   - allows distribution without restrictions
    r   - restricted distribtion
    n   - no license at all

=item CPAN::Module::force($method,@@args)

Forces CPAN to perform a task it would normally refuse to
do. Force takes as arguments a method name to be invoked and any number
of additional arguments to pass that method.
The internals of the object get the needed changes so that CPAN.pm
does not refuse to take the action. See also the section above on the
C<force> and the C<fforce> pragma.

=item CPAN::Module::get()

Runs a get on the distribution associated with this module.

=item CPAN::Module::inst_file()

Returns the filename of the module found in @@INC. The first file found
is reported, just as perl itself stops searching @@INC once it finds a
module.

=item CPAN::Module::available_file()

Returns the filename of the module found in PERL5LIB or @@INC. The
first file found is reported. The advantage of this method over
C<inst_file> is that modules that have been tested but not yet
installed are included because PERL5LIB keeps track of tested modules.

=item CPAN::Module::inst_version()

Returns the version number of the installed module in readable format.

=item CPAN::Module::available_version()

Returns the version number of the available module in readable format.

=item CPAN::Module::install()

Runs an C<install> on the distribution associated with this module.

=item CPAN::Module::look()

Changes to the directory where the distribution associated with this
module has been unpacked and opens a subshell there. Exiting the
subshell returns.

=item CPAN::Module::make()

Runs a C<make> on the distribution associated with this module.

=item CPAN::Module::manpage_headline()

If module is installed, peeks into the module's manpage, reads the
headline, and returns it. Moreover, if the module has been downloaded
within this session, does the equivalent on the downloaded module even
if it hasn't been installed yet.

=item CPAN::Module::perldoc()

Runs a C<perldoc> on this module.

=item CPAN::Module::readme()

Runs a C<readme> on the distribution associated with this module.

=item CPAN::Module::reports()

Calls the reports() method on the associated distribution object.

=item CPAN::Module::test()

Runs a C<test> on the distribution associated with this module.

=item CPAN::Module::uptodate()

Returns 1 if the module is installed and up-to-date.

=item CPAN::Module::userid()

Returns the author's ID of the module.

=back

=head2 Cache Manager

Currently the cache manager only keeps track of the build directory
($CPAN::Config->{build_dir}). It is a simple FIFO mechanism that
deletes complete directories below C<build_dir> as soon as the size of
all directories there gets bigger than $CPAN::Config->{build_cache}
(in MB). The contents of this cache may be used for later
re-installations that you intend to do manually, but will never be
trusted by CPAN itself. This is due to the fact that the user might
use these directories for building modules on different architectures.

There is another directory ($CPAN::Config->{keep_source_where}) where
the original distribution files are kept. This directory is not
covered by the cache manager and must be controlled by the user. If
you choose to have the same directory as build_dir and as
keep_source_where directory, then your sources will be deleted with
the same fifo mechanism.

=head2 Bundles

A bundle is just a perl module in the namespace Bundle:: that does not
define any functions or methods. It usually only contains documentation.

It starts like a perl module with a package declaration and a $VERSION
variable. After that the pod section looks like any other pod with the
only difference being that I<one special pod section> exists starting with
(verbatim):

    =head1 CONTENTS

In this pod section each line obeys the format

        Module_Name [Version_String] [- optional text]

The only required part is the first field, the name of a module
(e.g. Foo::Bar, ie. I<not> the name of the distribution file). The rest
of the line is optional. The comment part is delimited by a dash just
as in the man page header.

The distribution of a bundle should follow the same convention as
other distributions.

Bundles are treated specially in the CPAN package. If you say 'install
Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all
the modules in the CONTENTS section of the pod. You can install your
own Bundles locally by placing a conformant Bundle file somewhere into
your @@INC path. The autobundle() command which is available in the
shell interface does that for you by including all currently installed
modules in a snapshot bundle file.

=head1 PREREQUISITES

If you have a local mirror of CPAN and can access all files with
"file:" URLs, then you only need a perl later than perl5.003 to run
this module. Otherwise Net::FTP is strongly recommended. LWP may be
required for non-UNIX systems, or if your nearest CPAN site is
associated with a URL that is not C<ftp:>.

If you have neither Net::FTP nor LWP, there is a fallback mechanism
implemented for an external ftp command or for an external lynx
command.

=head1 UTILITIES

=head2 Finding packages and VERSION

This module presumes that all packages on CPAN

=over 2

=item *

declare their $VERSION variable in an easy to parse manner. This
prerequisite can hardly be relaxed because it consumes far too much
memory to load all packages into the running program just to determine
the $VERSION variable. Currently all programs that are dealing with
version use something like this

    perl -MExtUtils::MakeMaker -le \
        'print MM->parse_version(shift)' filename

If you are author of a package and wonder if your $VERSION can be
parsed, please try the above method.

=item *

come as compressed or gzipped tarfiles or as zip files and contain a
C<Makefile.PL> or C<Build.PL> (well, we try to handle a bit more, but
with little enthusiasm).

=back

=head2 Debugging

Debugging this module is more than a bit complex due to interference from
the software producing the indices on CPAN, the mirroring process on CPAN,
packaging, configuration, synchronicity, and even (gasp!) due to bugs
within the CPAN.pm module itself.

For debugging the code of CPAN.pm itself in interactive mode, some 
debugging aid can be turned on for most packages within
CPAN.pm with one of

=over 2

=item o debug package...

sets debug mode for packages.

=item o debug -package...

unsets debug mode for packages.

=item o debug all

turns debugging on for all packages.

=item o debug number

=back

which sets the debugging packages directly. Note that C<o debug 0>
turns debugging off.

What seems a successful strategy is the combination of C<reload
cpan> and the debugging switches. Add a new debug statement while
running in the shell and then issue a C<reload cpan> and see the new
debugging messages immediately without losing the current context.

C<o debug> without an argument lists the valid package names and the
current set of packages in debugging mode. C<o debug> has built-in
completion support.

For debugging of CPAN data there is the C<dump> command which takes
the same arguments as make/test/install and outputs each object's
Data::Dumper dump. If an argument looks like a perl variable and
contains one of C<$>, C<@@> or C<%>, it is eval()ed and fed to
Data::Dumper directly.

=head2 Floppy, Zip, Offline Mode

CPAN.pm works nicely without network access, too. If you maintain machines
that are not networked at all, you should consider working with C<file:>
URLs. You'll have to collect your modules somewhere first. So
you might use CPAN.pm to put together all you need on a networked
machine. Then copy the $CPAN::Config->{keep_source_where} (but not
$CPAN::Config->{build_dir}) directory on a floppy. This floppy is kind
of a personal CPAN. CPAN.pm on the non-networked machines works nicely
with this floppy. See also below the paragraph about CD-ROM support.

=head2 Basic Utilities for Programmers

=over 2

=item has_inst($module)

Returns true if the module is installed. Used to load all modules into
the running CPAN.pm that are considered optional. The config variable
C<dontload_list> intercepts the C<has_inst()> call such
that an optional module is not loaded despite being available. For
example, the following command will prevent C<YAML.pm> from being
loaded:

    cpan> o conf dontload_list push YAML

See the source for details.

=item has_usable($module)

Returns true if the module is installed and in a usable state. Only
useful for a handful of modules that are used internally. See the
source for details.

=item instance($module)

The constructor for all the singletons used to represent modules,
distributions, authors, and bundles. If the object already exists, this
method returns the object; otherwise, it calls the constructor.

=back

=head1 SECURITY

There's no strong security layer in CPAN.pm. CPAN.pm helps you to
install foreign, unmasked, unsigned code on your machine. We compare
to a checksum that comes from the net just as the distribution file
itself. But we try to make it easy to add security on demand:

=head2 Cryptographically signed modules

Since release 1.77, CPAN.pm has been able to verify cryptographically
signed module distributions using Module::Signature.  The CPAN modules
can be signed by their authors, thus giving more security.  The simple
unsigned MD5 checksums that were used before by CPAN protect mainly
against accidental file corruption.

You will need to have Module::Signature installed, which in turn
requires that you have at least one of Crypt::OpenPGP module or the
command-line F<gpg> tool installed.

You will also need to be able to connect over the Internet to the public
keyservers, like pgp.mit.edu, and their port 11731 (the HKP protocol).

The configuration parameter check_sigs is there to turn signature
checking on or off.

=head1 EXPORT

Most functions in package CPAN are exported by default. The reason
for this is that the primary use is intended for the cpan shell or for
one-liners.

=head1 ENVIRONMENT

When the CPAN shell enters a subshell via the look command, it sets
the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is
already set.

When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING
to the ID of the running process. It also sets
PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could
happen with older versions of Module::Install.

When running C<perl Makefile.PL>, the environment variable
C<PERL5_CPAN_IS_EXECUTING> is set to the full path of the
C<Makefile.PL> that is being executed. This prevents runaway processes
with newer versions of Module::Install.

When the config variable ftp_passive is set, all downloads will be run
with the environment variable FTP_PASSIVE set to this value. This is
in general a good idea as it influences both Net::FTP and LWP based
connections. The same effect can be achieved by starting the cpan
shell with this environment variable set. For Net::FTP alone, one can
also always set passive mode by running libnetcfg.

=head1 POPULATE AN INSTALLATION WITH LOTS OF MODULES

Populating a freshly installed perl with one's favorite modules is pretty
easy if you maintain a private bundle definition file. To get a useful
blueprint of a bundle definition file, the command autobundle can be used
on the CPAN shell command line. This command writes a bundle definition
file for all modules installed for the current perl
interpreter. It's recommended to run this command once only, and from then
on maintain the file manually under a private name, say
Bundle/my_bundle.pm. With a clever bundle file you can then simply say

    cpan> install Bundle::my_bundle

then answer a few questions and go out for coffee (possibly
even in a different city).

Maintaining a bundle definition file means keeping track of two
things: dependencies and interactivity. CPAN.pm sometimes fails on
calculating dependencies because not all modules define all MakeMaker
attributes correctly, so a bundle definition file should specify
prerequisites as early as possible. On the other hand, it's 
annoying that so many distributions need some interactive configuring. So
what you can try to accomplish in your private bundle file is to have the
packages that need to be configured early in the file and the gentle
ones later, so you can go out for cofeee after a few minutes and leave CPAN.pm
to churn away untended.

=head1 WORKING WITH CPAN.pm BEHIND FIREWALLS

Thanks to Graham Barr for contributing the following paragraphs about
the interaction between perl, and various firewall configurations. For
further information on firewalls, it is recommended to consult the
documentation that comes with the I<ncftp> program. If you are unable to
go through the firewall with a simple Perl setup, it is likely
that you can configure I<ncftp> so that it works through your firewall.

=head2 Three basic types of firewalls

Firewalls can be categorized into three basic types.

=over 4

=item http firewall

This is when the firewall machine runs a web server, and to access the
outside world, you must do so via that web server. If you set environment
variables like http_proxy or ftp_proxy to values beginning with http://,
or in your web browser you've proxy information set, then you know
you are running behind an http firewall.

To access servers outside these types of firewalls with perl (even for
ftp), you need LWP.

=item ftp firewall

This where the firewall machine runs an ftp server. This kind of
firewall will only let you access ftp servers outside the firewall.
This is usually done by connecting to the firewall with ftp, then
entering a username like "user@@outside.host.com".

To access servers outside these type of firewalls with perl, you
need Net::FTP.

=item One-way visibility

One-way visibility means these firewalls try to make themselves 
invisible to users inside the firewall. An FTP data connection is
normally created by sending your IP address to the remote server and then
listening for the return connection. But the remote server will not be able to
connect to you because of the firewall. For these types of firewall,
FTP connections need to be done in a passive mode.

There are two that I can think off.

=over 4

=item SOCKS

If you are using a SOCKS firewall, you will need to compile perl and link
it with the SOCKS library.  This is what is normally called a 'socksified'
perl. With this executable you will be able to connect to servers outside
the firewall as if it were not there.

=item IP Masquerade

This is when the firewall implemented in the kernel (via NAT, or networking
address translation), it allows you to hide a complete network behind one
IP address. With this firewall no special compiling is needed as you can
access hosts directly.

For accessing ftp servers behind such firewalls you usually need to
set the environment variable C<FTP_PASSIVE> or the config variable
ftp_passive to a true value.

=back

=back

=head2 Configuring lynx or ncftp for going through a firewall

If you can go through your firewall with e.g. lynx, presumably with a
command such as

    /usr/local/bin/lynx -pscott:tiger

then you would configure CPAN.pm with the command

    o conf lynx "/usr/local/bin/lynx -pscott:tiger"

That's all. Similarly for ncftp or ftp, you would configure something
like

    o conf ncftp "/usr/bin/ncftp -f /home/scott/ncftplogin.cfg"

Your mileage may vary...

=head1 FAQ

=over 4

=item 1)

I installed a new version of module X but CPAN keeps saying,
I have the old version installed

Probably you B<do> have the old version installed. This can
happen if a module installs itself into a different directory in the
@@INC path than it was previously installed. This is not really a
CPAN.pm problem, you would have the same problem when installing the
module manually. The easiest way to prevent this behaviour is to add
the argument C<UNINST=1> to the C<make install> call, and that is why
many people add this argument permanently by configuring

  o conf make_install_arg UNINST=1

=item 2)

So why is UNINST=1 not the default?

Because there are people who have their precise expectations about who
may install where in the @@INC path and who uses which @@INC array. In
fine tuned environments C<UNINST=1> can cause damage.

=item 3)

I want to clean up my mess, and install a new perl along with
all modules I have. How do I go about it?

Run the autobundle command for your old perl and optionally rename the
resulting bundle file (e.g. Bundle/mybundle.pm), install the new perl
with the Configure option prefix, e.g.

    ./Configure -Dprefix=/usr/local/perl-5.6.78.9

Install the bundle file you produced in the first step with something like

    cpan> install Bundle::mybundle

and you're done.

=item 4)

When I install bundles or multiple modules with one command
there is too much output to keep track of.

You may want to configure something like

  o conf make_arg "| tee -ai /root/.cpan/logs/make.out"
  o conf make_install_arg "| tee -ai /root/.cpan/logs/make_install.out"

so that STDOUT is captured in a file for later inspection.


=item 5)

I am not root, how can I install a module in a personal directory?

First of all, you will want to use your own configuration, not the one
that your root user installed. If you do not have permission to write
in the cpan directory that root has configured, you will be asked if
you want to create your own config. Answering "yes" will bring you into
CPAN's configuration stage, using the system config for all defaults except
things that have to do with CPAN's work directory, saving your choices to
your MyConfig.pm file.

You can also manually initiate this process with the following command:

    % perl -MCPAN -e 'mkmyconfig'

or by running

    mkmyconfig

from the CPAN shell.

You will most probably also want to configure something like this:

  o conf makepl_arg "LIB=~/myperl/lib \
                    INSTALLMAN1DIR=~/myperl/man/man1 \
                    INSTALLMAN3DIR=~/myperl/man/man3 \
                    INSTALLSCRIPT=~/myperl/bin \
                    INSTALLBIN=~/myperl/bin"

and then the equivalent command for Module::Build, which is

  o conf mbuildpl_arg "--lib=~/myperl/lib \
                    --installman1dir=~/myperl/man/man1 \
                    --installman3dir=~/myperl/man/man3 \
                    --installscript=~/myperl/bin \
                    --installbin=~/myperl/bin"

You can make this setting permanent like all C<o conf> settings with
C<o conf commit> or by setting C<auto_commit> beforehand.

You will have to add ~/myperl/man to the MANPATH environment variable
and also tell your perl programs to look into ~/myperl/lib, e.g. by
including

  use lib "$ENV{HOME}/myperl/lib";

or setting the PERL5LIB environment variable.

While we're speaking about $ENV{HOME}, it might be worth mentioning,
that for Windows we use the File::HomeDir module that provides an
equivalent to the concept of the home directory on Unix.

Another thing you should bear in mind is that the UNINST parameter can
be dangerous when you are installing into a private area because you
might accidentally remove modules that other people depend on that are
not using the private area.

=item 6)

How to get a package, unwrap it, and make a change before building it?

Have a look at the C<look> (!) command.

=item 7)

I installed a Bundle and had a couple of fails. When I
retried, everything resolved nicely. Can this be fixed to work
on first try?

The reason for this is that CPAN does not know the dependencies of all
modules when it starts out. To decide about the additional items to
install, it just uses data found in the META.yml file or the generated
Makefile. An undetected missing piece breaks the process. But it may
well be that your Bundle installs some prerequisite later than some
depending item and thus your second try is able to resolve everything.
Please note, CPAN.pm does not know the dependency tree in advance and
cannot sort the queue of things to install in a topologically correct
order. It resolves perfectly well B<if> all modules declare the
prerequisites correctly with the PREREQ_PM attribute to MakeMaker or
the C<requires> stanza of Module::Build. For bundles which fail and
you need to install often, it is recommended to sort the Bundle
definition file manually.

=item 8)

In our intranet, we have many modules for internal use. How
can I integrate these modules with CPAN.pm but without uploading
the modules to CPAN?

Have a look at the CPAN::Site module.

=item 9)

When I run CPAN's shell, I get an error message about things in my
C</etc/inputrc> (or C<~/.inputrc>) file.

These are readline issues and can only be fixed by studying readline
configuration on your architecture and adjusting the referenced file
accordingly. Please make a backup of the C</etc/inputrc> or C<~/.inputrc>
and edit them. Quite often harmless changes like uppercasing or
lowercasing some arguments solves the problem.

=item 10)

Some authors have strange characters in their names.

Internally CPAN.pm uses the UTF-8 charset. If your terminal is
expecting ISO-8859-1 charset, a converter can be activated by setting
term_is_latin to a true value in your config file. One way of doing so
would be

    cpan> o conf term_is_latin 1

If other charset support is needed, please file a bugreport against
CPAN.pm at rt.cpan.org and describe your needs. Maybe we can extend
the support or maybe UTF-8 terminals become widely available.

Note: this config variable is deprecated and will be removed in a
future version of CPAN.pm. It will be replaced with the conventions
around the family of $LANG and $LC_* environment variables.

=item 11)

When an install fails for some reason and then I correct the error
condition and retry, CPAN.pm refuses to install the module, saying
C<Already tried without success>.

Use the force pragma like so

  force install Foo::Bar

Or you can use

  look Foo::Bar

and then C<make install> directly in the subshell.

=item 12)

How do I install a "DEVELOPER RELEASE" of a module?

By default, CPAN will install the latest non-developer release of a
module. If you want to install a dev release, you have to specify the
partial path starting with the author id to the tarball you wish to
install, like so:

    cpan> install KWILLIAMS/Module-Build-0.27_07.tar.gz

Note that you can use the C<ls> command to get this path listed.

=item 13)

How do I install a module and all its dependencies from the commandline,
without being prompted for anything, despite my CPAN configuration
(or lack thereof)?

CPAN uses ExtUtils::MakeMaker's prompt() function to ask its questions, so
if you set the PERL_MM_USE_DEFAULT environment variable, you shouldn't be
asked any questions at all (assuming the modules you are installing are
nice about obeying that variable as well):

    % PERL_MM_USE_DEFAULT=1 perl -MCPAN -e 'install My::Module'

=item 14)

How do I create a Module::Build based Build.PL derived from an
ExtUtils::MakeMaker focused Makefile.PL?

http://search.cpan.org/search?query=Module::Build::Convert

http://www.refcnt.org/papers/module-build-convert

=item 15)

I'm frequently irritated with the CPAN shell's inability to help me
select a good mirror.

The urllist config parameter is yours. You can add and remove sites at
will. You should find out which sites have the best uptodateness,
bandwidth, reliability, etc. and are topologically close to you. Some
people prefer fast downloads, others uptodateness, others reliability.
You decide which to try in which order.

Henk P. Penning maintains a site that collects data about CPAN sites:

  http://www.cs.uu.nl/people/henkp/mirmon/cpan.html

Also, feel free to play with experimental features. Run

  o conf init randomize_urllist ftpstats_period ftpstats_size

and choose your favorite parameters. After a few downloads running the
C<hosts> command will probably assist you in choosing the best mirror
sites.

=item 16)

Why do I get asked the same questions every time I start the shell?

You can make your configuration changes permanent by calling the
command C<o conf commit>. Alternatively set the C<auto_commit>
variable to true by running C<o conf init auto_commit> and answering
the following question with yes.

=item 17)

Older versions of CPAN.pm had the original root directory of all
tarballs in the build directory. Now there are always random
characters appended to these directory names. Why was this done?

The random characters are provided by File::Temp and ensure that each
module's individual build directory is unique. This makes running
CPAN.pm in concurrent processes simultaneously safe.

=item 18)

Speaking of the build directory. Do I have to clean it up myself?

You have the choice to set the config variable C<scan_cache> to
C<never>. Then you must clean it up yourself. The other possible
value, C<atstart> only cleans up the build directory when you start
the CPAN shell. If you never start up the CPAN shell, you probably
also have to clean up the build directory yourself.

=back

=head1 COMPATIBILITY

=head2 OLD PERL VERSIONS

CPAN.pm is regularly tested to run under 5.004, 5.005, and assorted
newer versions. It is getting more and more difficult to get the
minimal prerequisites working on older perls. It is close to
impossible to get the whole Bundle::CPAN working there. If you're in
the position to have only these old versions, be advised that CPAN is
designed to work fine without the Bundle::CPAN installed.

To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is
compatible with ancient perls and that File::Temp is listed as a
prerequisite but CPAN has reasonable workarounds if it is missing.

=head2 CPANPLUS

This module and its competitor, the CPANPLUS module, are both much
cooler than the other. CPAN.pm is older. CPANPLUS was designed to be
more modular, but it was never intended to be compatible with CPAN.pm.

=head1 SECURITY ADVICE

This software enables you to upgrade software on your computer and so
is inherently dangerous because the newly installed software may
contain bugs and may alter the way your computer works or even make it
unusable. Please consider backing up your data before every upgrade.

=head1 BUGS

Please report bugs via L<http://rt.cpan.org/>

Before submitting a bug, please make sure that the traditional method
of building a Perl module package from a shell by following the
installation instructions of that package still works in your
environment.

=head1 AUTHOR

Andreas Koenig C<< <andk@@cpan.org> >>

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>

=head1 TRANSLATIONS

Kawai,Takanori provides a Japanese translation of this manpage at
L<http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm>

=head1 SEE ALSO

L<cpan>, L<CPAN::Nox>, L<CPAN::Version>

=cut
@


1.9
log
@Merge in perl 5.10.1
@
text
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d2 1
d5 2
a6 2
$CPAN::VERSION = '1.9205';
$CPAN::VERSION = eval $CPAN::VERSION if $CPAN::VERSION =~ /_/;
d8 11
d21 3
d25 8
d35 6
a40 1
use CPAN::DeferedCode;
d43 1
a43 1
use Cwd ();
a52 1
use File::Spec ();
d60 1
d62 2
a64 9
# we need to run chdir all over and we would get at wrong libraries
# there
BEGIN {
    if (File::Spec->can("rel2abs")) {
        for my $inc (@@INC) {
            $inc = File::Spec->rel2abs($inc) unless ref $inc;
        }
    }
}
d68 29
d109 1
a109 1
            "ftp://ftp.perl.org/pub/CPAN/";
d111 2
a112 1
# $CPAN::iCwd (i for initial) is going to be initialized during find_perl
d180 1
a180 1
    sub AUTOLOAD {
d208 46
d316 1
a316 1
ReadLine support %s
d354 2
a355 1
            package CPAN::Eval;
d372 21
a392 8
            eval { CPAN::Shell->$command(@@line) };
            if ($@@) {
                my $err = "$@@";
                if ($err =~ /\S/) {
                    require Carp;
                    require Dumpvalue;
                    my $dv = Dumpvalue->new();
                    Carp::cluck(sprintf "Catching error: %s", $dv->stringify($err));
d412 7
a418 1
                CPAN::Shell->failed($CPAN::CurrentCommandId,1);
d507 1
a507 1
    if ($Config::Config{d_flock}) {
d510 1
a510 1
        $CPAN::Frontend->mywarn("Your OS does not support locking; continuing and ignoring all locking issues\n");
d553 2
a554 2
        local $YAML::LoadCode;
        local $YAML::Syck::LoadCode;
d557 1
a557 1
        my $code;
a558 1
            my @@yaml;
a563 1
            return \@@yaml;
a568 1
            my @@yaml;
a573 1
            return \@@yaml;
d575 2
a637 380
package CPAN::CacheMgr;
use strict;
@@CPAN::CacheMgr::ISA = qw(CPAN::InfoObj CPAN);
use File::Find;

package CPAN::FTP;
use strict;
use Fcntl qw(:flock);
use vars qw($connect_to_internet_ok $Ua $Thesite $ThesiteURL $Themethod);
@@CPAN::FTP::ISA = qw(CPAN::Debug);

package CPAN::LWP::UserAgent;
use strict;
use vars qw(@@ISA $USER $PASSWD $SETUPDONE);
# we delay requiring LWP::UserAgent and setting up inheritance until we need it

package CPAN::Complete;
use strict;
@@CPAN::Complete::ISA = qw(CPAN::Debug);
# Q: where is the "How do I add a new command" HOWTO?
# A: svn diff -r 1048:1049 where andk added the report command
@@CPAN::Complete::COMMANDS = sort qw(
                                    ? ! a b d h i m o q r u
                                    autobundle
                                    bye
                                    clean
                                    cvs_import
                                    dump
                                    exit
                                    failed
                                    force
                                    fforce
                                    hosts
                                    install
                                    install_tested
                                    is_tested
                                    look
                                    ls
                                    make
                                    mkmyconfig
                                    notest
                                    perldoc
                                    quit
                                    readme
                                    recent
                                    recompile
                                    reload
                                    report
                                    reports
                                    scripts
                                    smoke
                                    test
                                    upgrade
);

package CPAN::Index;
use strict;
use vars qw($LAST_TIME $DATE_OF_02 $DATE_OF_03 $HAVE_REANIMATED);
@@CPAN::Index::ISA = qw(CPAN::Debug);
$LAST_TIME ||= 0;
$DATE_OF_03 ||= 0;
# use constant PROTOCOL => "2.0"; # outcommented to avoid warning on upgrade from 1.57
sub PROTOCOL { 2.0 }

package CPAN::InfoObj;
use strict;
@@CPAN::InfoObj::ISA = qw(CPAN::Debug);

package CPAN::Author;
use strict;
@@CPAN::Author::ISA = qw(CPAN::InfoObj);

package CPAN::Distribution;
use strict;
@@CPAN::Distribution::ISA = qw(CPAN::InfoObj);

package CPAN::Bundle;
use strict;
@@CPAN::Bundle::ISA = qw(CPAN::Module);

package CPAN::Module;
use strict;
@@CPAN::Module::ISA = qw(CPAN::InfoObj);

package CPAN::Exception::RecursiveDependency;
use strict;
use overload '""' => "as_string";

# a module sees its distribution (no version)
# a distribution sees its prereqs (which are module names) (usually with versions)
# a bundle sees its module names and/or its distributions (no version)

sub new {
    my($class) = shift;
    my($deps) = shift;
    my (@@deps,%seen,$loop_starts_with);
  DCHAIN: for my $dep (@@$deps) {
        push @@deps, {name => $dep, display_as => $dep};
        if ($seen{$dep}++) {
            $loop_starts_with = $dep;
            last DCHAIN;
        }
    }
    my $in_loop = 0;
    for my $i (0..$#deps) {
        my $x = $deps[$i]{name};
        $in_loop ||= $x eq $loop_starts_with;
        my $xo = CPAN::Shell->expandany($x) or next;
        if ($xo->isa("CPAN::Module")) {
            my $have = $xo->inst_version || "N/A";
            my($want,$d,$want_type);
            if ($i>0 and $d = $deps[$i-1]{name}) {
                my $do = CPAN::Shell->expandany($d);
                $want = $do->{prereq_pm}{requires}{$x};
                if (defined $want) {
                    $want_type = "requires: ";
                } else {
                    $want = $do->{prereq_pm}{build_requires}{$x};
                    if (defined $want) {
                        $want_type = "build_requires: ";
                    } else {
                        $want_type = "unknown status";
                        $want = "???";
                    }
                }
            } else {
                $want = $xo->cpan_version;
                $want_type = "want: ";
            }
            $deps[$i]{have} = $have;
            $deps[$i]{want_type} = $want_type;
            $deps[$i]{want} = $want;
            $deps[$i]{display_as} = "$x (have: $have; $want_type$want)";
        } elsif ($xo->isa("CPAN::Distribution")) {
            $deps[$i]{display_as} = $xo->pretty_id;
            if ($in_loop) {
                $xo->{make} = CPAN::Distrostatus->new("NO cannot resolve circular dependency");
            } else {
                $xo->{make} = CPAN::Distrostatus->new("NO one dependency ($loop_starts_with) is a circular dependency");
            }
            $xo->store_persistent_state; # otherwise I will not reach
                                         # all involved parties for
                                         # the next session
        }
    }
    bless { deps => \@@deps }, $class;
}

sub as_string {
    my($self) = shift;
    my $ret = "\nRecursive dependency detected:\n    ";
    $ret .= join("\n => ", map {$_->{display_as}} @@{$self->{deps}});
    $ret .= ".\nCannot resolve.\n";
    $ret;
}

package CPAN::Exception::yaml_not_installed;
use strict;
use overload '""' => "as_string";

sub new {
    my($class,$module,$file,$during) = @@_;
    bless { module => $module, file => $file, during => $during }, $class;
}

sub as_string {
    my($self) = shift;
    "'$self->{module}' not installed, cannot $self->{during} '$self->{file}'\n";
}

package CPAN::Exception::yaml_process_error;
use strict;
use overload '""' => "as_string";

sub new {
    my($class,$module,$file,$during,$error) = @@_;
    bless { module => $module,
            file => $file,
            during => $during,
            error => $error }, $class;
}

sub as_string {
    my($self) = shift;
    if ($self->{during}) {
        if ($self->{file}) {
            if ($self->{module}) {
                if ($self->{error}) {
                    return "Alert: While trying to '$self->{during}' YAML file\n".
                        " '$self->{file}'\n".
                            "with '$self->{module}' the following error was encountered:\n".
                                "  $self->{error}\n";
                } else {
                    return "Alert: While trying to '$self->{during}' YAML file\n".
                        " '$self->{file}'\n".
                            "with '$self->{module}' some unknown error was encountered\n";
                }
            } else {
                return "Alert: While trying to '$self->{during}' YAML file\n".
                    " '$self->{file}'\n".
                        "some unknown error was encountered\n";
            }
        } else {
            return "Alert: While trying to '$self->{during}' some YAML file\n".
                    "some unknown error was encountered\n";
        }
    } else {
        return "Alert: unknown error encountered\n";
    }
}

package CPAN::Prompt; use overload '""' => "as_string";
use vars qw($prompt);
$prompt = "cpan> ";
$CPAN::CurrentCommandId ||= 0;
sub new {
    bless {}, shift;
}
sub as_string {
    my $word = "cpan";
    unless ($CPAN::META->{LOCK}) {
        $word = "nolock_cpan";
    }
    if ($CPAN::Config->{commandnumber_in_prompt}) {
        sprintf "$word\[%d]> ", $CPAN::CurrentCommandId;
    } else {
        "$word> ";
    }
}

package CPAN::URL; use overload '""' => "as_string", fallback => 1;
# accessors: TEXT(the url string), FROM(DEF=>defaultlist,USER=>urllist),
# planned are things like age or quality
sub new {
    my($class,%args) = @@_;
    bless {
           %args
          }, $class;
}
sub as_string {
    my($self) = @@_;
    $self->text;
}
sub text {
    my($self,$set) = @@_;
    if (defined $set) {
        $self->{TEXT} = $set;
    }
    $self->{TEXT};
}

package CPAN::Distrostatus;
use overload '""' => "as_string",
    fallback => 1;
sub new {
    my($class,$arg) = @@_;
    bless {
           TEXT => $arg,
           FAILED => substr($arg,0,2) eq "NO",
           COMMANDID => $CPAN::CurrentCommandId,
           TIME => time,
          }, $class;
}
sub commandid { shift->{COMMANDID} }
sub failed { shift->{FAILED} }
sub text {
    my($self,$set) = @@_;
    if (defined $set) {
        $self->{TEXT} = $set;
    }
    $self->{TEXT};
}
sub as_string {
    my($self) = @@_;
    $self->text;
}

package CPAN::Shell;
use strict;
use vars qw(
            $ADVANCED_QUERY
            $AUTOLOAD
            $COLOR_REGISTERED
            $Help
            $autoload_recursion
            $reload
            @@ISA
           );
@@CPAN::Shell::ISA = qw(CPAN::Debug);
$COLOR_REGISTERED ||= 0;
$Help = {
         '?' => \"help",
         '!' => "eval the rest of the line as perl",
         a => "whois author",
         autobundle => "wtite inventory into a bundle file",
         b => "info about bundle",
         bye => \"quit",
         clean => "clean up a distribution's build directory",
         # cvs_import
         d => "info about a distribution",
         # dump
         exit => \"quit",
         failed => "list all failed actions within current session",
         fforce => "redo a command from scratch",
         force => "redo a command",
         h => \"help",
         help => "overview over commands; 'help ...' explains specific commands",
         hosts => "statistics about recently used hosts",
         i => "info about authors/bundles/distributions/modules",
         install => "install a distribution",
         install_tested => "install all distributions tested OK",
         is_tested => "list all distributions tested OK",
         look => "open a subshell in a distribution's directory",
         ls => "list distributions according to a glob",
         m => "info about a module",
         make => "make/build a distribution",
         mkmyconfig => "write current config into a CPAN/MyConfig.pm file",
         notest => "run a (usually install) command but leave out the test phase",
         o => "'o conf ...' for config stuff; 'o debug ...' for debugging",
         perldoc => "try to get a manpage for a module",
         q => \"quit",
         quit => "leave the cpan shell",
         r => "review over upgradeable modules",
         readme => "display the README of a distro woth a pager",
         recent => "show recent uploads to the CPAN",
         # recompile
         reload => "'reload cpan' or 'reload index'",
         report => "test a distribution and send a test report to cpantesters",
         reports => "info about reported tests from cpantesters",
         # scripts
         # smoke
         test => "test a distribution",
         u => "display uninstalled modules",
         upgrade => "combine 'r' command with immediate installation",
        };
{
    $autoload_recursion   ||= 0;

    #-> sub CPAN::Shell::AUTOLOAD ;
    sub AUTOLOAD {
        $autoload_recursion++;
        my($l) = $AUTOLOAD;
        my $class = shift(@@_);
        # warn "autoload[$l] class[$class]";
        $l =~ s/.*:://;
        if ($CPAN::Signal) {
            warn "Refusing to autoload '$l' while signal pending";
            $autoload_recursion--;
            return;
        }
        if ($autoload_recursion > 1) {
            my $fullcommand = join " ", map { "'$_'" } $l, @@_;
            warn "Refusing to autoload $fullcommand in recursion\n";
            $autoload_recursion--;
            return;
        }
        if ($l =~ /^w/) {
            # XXX needs to be reconsidered
            if ($CPAN::META->has_inst('CPAN::WAIT')) {
                CPAN::WAIT->$l(@@_);
            } else {
                $CPAN::Frontend->mywarn(qq{
Commands starting with "w" require CPAN::WAIT to be installed.
Please consider installing CPAN::WAIT to use the fulltext index.
For this you just need to type
    install CPAN::WAIT
});
            }
        } else {
            $CPAN::Frontend->mywarn(qq{Unknown shell command '$l'. }.
                                    qq{Type ? for help.
});
        }
        $autoload_recursion--;
    }
}

package CPAN;
use strict;

d726 1
a726 1
            $CPAN::Frontend->mywarn("Running in degraded mode (experimental)\n");
d733 1
a733 1
            if (kill 0, $otherpid) {
d737 1
a737 1
                        (qq{Shall I try to run in degraded }.
d740 1
a740 1
                    $CPAN::Frontend->mywarn("Running in degraded mode (experimental).
d747 5
a751 3
                        $_->{histfile} = "";               # who should win otherwise?
                        $_->{cache_metadata} = 0;          # better would be a lock?
                        $_->{use_sqlite} = 0;              # better would be a write lock!
d769 1
a769 1
                    qq{Lockfile '$lockfile' not writeable by you. }.
d929 4
a932 4
    my $pwd  = $CPAN::iCwd = CPAN::anycwd();
    my $candidate = File::Spec->catfile($pwd,$^X);
    $perl ||= $candidate if MM->maybe_command($candidate);

d941 1
a941 1
                    $perl = $abs;
a946 1

d1010 1
a1010 1
                                       unless (CPAN::Version->vge(Archive::Tar::->VERSION, 1.00)) {
d1016 4
d1100 10
a1109 8482
}) unless $Have_warned->{"Net::FTP"}++;
        $CPAN::Frontend->mysleep(3);
    } elsif ($mod eq "Digest::SHA") {
        if ($Have_warned->{"Digest::SHA"}++) {
            $CPAN::Frontend->mywarn(qq{CPAN: checksum security checks disabled }.
                                     qq{because Digest::SHA not installed.\n});
        } else {
            $CPAN::Frontend->mywarn(qq{
  CPAN: checksum security checks disabled because Digest::SHA not installed.
  Please consider installing the Digest::SHA module.

});
            $CPAN::Frontend->mysleep(2);
        }
    } elsif ($mod eq "Module::Signature") {
        # NOT prefs_lookup, we are not a distro
        my $check_sigs = $CPAN::Config->{check_sigs};
        if (not $check_sigs) {
            # they do not want us:-(
        } elsif (not $Have_warned->{"Module::Signature"}++) {
            # No point in complaining unless the user can
            # reasonably install and use it.
            if (eval { require Crypt::OpenPGP; 1 } ||
                (
                 defined $CPAN::Config->{'gpg'}
                 &&
                 $CPAN::Config->{'gpg'} =~ /\S/
                )
               ) {
                $CPAN::Frontend->mywarn(qq{
  CPAN: Module::Signature security checks disabled because Module::Signature
  not installed.  Please consider installing the Module::Signature module.
  You may also need to be able to connect over the Internet to the public
  keyservers like pgp.mit.edu (port 11371).

});
                $CPAN::Frontend->mysleep(2);
            }
        }
    } else {
        delete $INC{$file}; # if it inc'd LWP but failed during, say, URI
    }
    return 0;
}

#-> sub CPAN::instance ;
sub instance {
    my($mgr,$class,$id) = @@_;
    CPAN::Index->reload;
    $id ||= "";
    # unsafe meta access, ok?
    return $META->{readwrite}{$class}{$id} if exists $META->{readwrite}{$class}{$id};
    $META->{readwrite}{$class}{$id} ||= $class->new(ID => $id);
}

#-> sub CPAN::new ;
sub new {
    bless {}, shift;
}

#-> sub CPAN::cleanup ;
sub cleanup {
  # warn "cleanup called with arg[@@_] End[$CPAN::End] Signal[$Signal]";
  local $SIG{__DIE__} = '';
  my($message) = @@_;
  my $i = 0;
  my $ineval = 0;
  my($subroutine);
  while ((undef,undef,undef,$subroutine) = caller(++$i)) {
      $ineval = 1, last if
        $subroutine eq '(eval)';
  }
  return if $ineval && !$CPAN::End;
  return unless defined $META->{LOCK};
  return unless -f $META->{LOCK};
  $META->savehist;
  close $META->{LOCKFH};
  unlink $META->{LOCK};
  # require Carp;
  # Carp::cluck("DEBUGGING");
  if ( $CPAN::CONFIG_DIRTY ) {
      $CPAN::Frontend->mywarn("Warning: Configuration not saved.\n");
  }
  $CPAN::Frontend->myprint("Lockfile removed.\n");
}

#-> sub CPAN::readhist
sub readhist {
    my($self,$term,$histfile) = @@_;
    my($fh) = FileHandle->new;
    open $fh, "<$histfile" or last;
    local $/ = "\n";
    while (<$fh>) {
        chomp;
        $term->AddHistory($_);
    }
    close $fh;
}

#-> sub CPAN::savehist
sub savehist {
    my($self) = @@_;
    my($histfile,$histsize);
    unless ($histfile = $CPAN::Config->{'histfile'}) {
        $CPAN::Frontend->mywarn("No history written (no histfile specified).\n");
        return;
    }
    $histsize = $CPAN::Config->{'histsize'} || 100;
    if ($CPAN::term) {
        unless ($CPAN::term->can("GetHistory")) {
            $CPAN::Frontend->mywarn("Terminal does not support GetHistory.\n");
            return;
        }
    } else {
        return;
    }
    my @@h = $CPAN::term->GetHistory;
    splice @@h, 0, @@h-$histsize if @@h>$histsize;
    my($fh) = FileHandle->new;
    open $fh, ">$histfile" or $CPAN::Frontend->mydie("Couldn't open >$histfile: $!");
    local $\ = local $, = "\n";
    print $fh @@h;
    close $fh;
}

#-> sub CPAN::is_tested
sub is_tested {
    my($self,$what,$when) = @@_;
    unless ($what) {
        Carp::cluck("DEBUG: empty what");
        return;
    }
    $self->{is_tested}{$what} = $when;
}

#-> sub CPAN::is_installed
# unsets the is_tested flag: as soon as the thing is installed, it is
# not needed in set_perl5lib anymore
sub is_installed {
    my($self,$what) = @@_;
    delete $self->{is_tested}{$what};
}

sub _list_sorted_descending_is_tested {
    my($self) = @@_;
    sort
        { ($self->{is_tested}{$b}||0) <=> ($self->{is_tested}{$a}||0) }
            keys %{$self->{is_tested}}
}

#-> sub CPAN::set_perl5lib
sub set_perl5lib {
    my($self,$for) = @@_;
    unless ($for) {
        (undef,undef,undef,$for) = caller(1);
        $for =~ s/.*://;
    }
    $self->{is_tested} ||= {};
    return unless %{$self->{is_tested}};
    my $env = $ENV{PERL5LIB};
    $env = $ENV{PERLLIB} unless defined $env;
    my @@env;
    push @@env, $env if defined $env and length $env;
    #my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} keys %{$self->{is_tested}};
    #$CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB.\n");

    my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} $self->_list_sorted_descending_is_tested;
    if (@@dirs < 12) {
        $CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB for '$for'\n");
    } elsif (@@dirs < 24) {
        my @@d = map {my $cp = $_;
                     $cp =~ s/^\Q$CPAN::Config->{build_dir}\E/%BUILDDIR%/;
                     $cp
                 } @@dirs;
        $CPAN::Frontend->myprint("Prepending @@d to PERL5LIB; ".
                                 "%BUILDDIR%=$CPAN::Config->{build_dir} ".
                                 "for '$for'\n"
                                );
    } else {
        my $cnt = keys %{$self->{is_tested}};
        $CPAN::Frontend->myprint("Prepending blib/arch and blib/lib of ".
                                 "$cnt build dirs to PERL5LIB; ".
                                 "for '$for'\n"
                                );
    }

    $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
}

package CPAN::CacheMgr;
use strict;

#-> sub CPAN::CacheMgr::as_string ;
sub as_string {
    eval { require Data::Dumper };
    if ($@@) {
        return shift->SUPER::as_string;
    } else {
        return Data::Dumper::Dumper(shift);
    }
}

#-> sub CPAN::CacheMgr::cachesize ;
sub cachesize {
    shift->{DU};
}

#-> sub CPAN::CacheMgr::tidyup ;
sub tidyup {
  my($self) = @@_;
  return unless $CPAN::META->{LOCK};
  return unless -d $self->{ID};
  my @@toremove = grep { $self->{SIZE}{$_}==0 } @@{$self->{FIFO}};
  for my $current (0..$#toremove) {
    my $toremove = $toremove[$current];
    $CPAN::Frontend->myprint(sprintf(
                                     "DEL(%d/%d): %s \n",
                                     $current+1,
                                     scalar @@toremove,
                                     $toremove,
                                    )
                            );
    return if $CPAN::Signal;
    $self->_clean_cache($toremove);
    return if $CPAN::Signal;
  }
}

#-> sub CPAN::CacheMgr::dir ;
sub dir {
    shift->{ID};
}

#-> sub CPAN::CacheMgr::entries ;
sub entries {
    my($self,$dir) = @@_;
    return unless defined $dir;
    $self->debug("reading dir[$dir]") if $CPAN::DEBUG;
    $dir ||= $self->{ID};
    my($cwd) = CPAN::anycwd();
    chdir $dir or Carp::croak("Can't chdir to $dir: $!");
    my $dh = DirHandle->new(File::Spec->curdir)
        or Carp::croak("Couldn't opendir $dir: $!");
    my(@@entries);
    for ($dh->read) {
        next if $_ eq "." || $_ eq "..";
        if (-f $_) {
            push @@entries, File::Spec->catfile($dir,$_);
        } elsif (-d _) {
            push @@entries, File::Spec->catdir($dir,$_);
        } else {
            $CPAN::Frontend->mywarn("Warning: weird direntry in $dir: $_\n");
        }
    }
    chdir $cwd or Carp::croak("Can't chdir to $cwd: $!");
    sort { -M $a <=> -M $b} @@entries;
}

#-> sub CPAN::CacheMgr::disk_usage ;
sub disk_usage {
    my($self,$dir,$fast) = @@_;
    return if exists $self->{SIZE}{$dir};
    return if $CPAN::Signal;
    my($Du) = 0;
    if (-e $dir) {
        if (-d $dir) {
            unless (-x $dir) {
                unless (chmod 0755, $dir) {
                    $CPAN::Frontend->mywarn("I have neither the -x permission nor the ".
                                            "permission to change the permission; cannot ".
                                            "estimate disk usage of '$dir'\n");
                    $CPAN::Frontend->mysleep(5);
                    return;
                }
            }
        } elsif (-f $dir) {
            # nothing to say, no matter what the permissions
        }
    } else {
        $CPAN::Frontend->mywarn("File or directory '$dir' has gone, ignoring\n");
        return;
    }
    if ($fast) {
        $Du = 0; # placeholder
    } else {
        find(
             sub {
           $File::Find::prune++ if $CPAN::Signal;
           return if -l $_;
           if ($^O eq 'MacOS') {
             require Mac::Files;
             my $cat  = Mac::Files::FSpGetCatInfo($_);
             $Du += $cat->ioFlLgLen() + $cat->ioFlRLgLen() if $cat;
           } else {
             if (-d _) {
               unless (-x _) {
                 unless (chmod 0755, $_) {
                   $CPAN::Frontend->mywarn("I have neither the -x permission nor ".
                                           "the permission to change the permission; ".
                                           "can only partially estimate disk usage ".
                                           "of '$_'\n");
                   $CPAN::Frontend->mysleep(5);
                   return;
                 }
               }
             } else {
               $Du += (-s _);
             }
           }
         },
         $dir
            );
    }
    return if $CPAN::Signal;
    $self->{SIZE}{$dir} = $Du/1024/1024;
    unshift @@{$self->{FIFO}}, $dir;
    $self->debug("measured $dir is $Du") if $CPAN::DEBUG;
    $self->{DU} += $Du/1024/1024;
    $self->{DU};
}

#-> sub CPAN::CacheMgr::_clean_cache ;
sub _clean_cache {
    my($self,$dir) = @@_;
    return unless -e $dir;
    unless (File::Spec->canonpath(File::Basename::dirname($dir))
            eq File::Spec->canonpath($CPAN::Config->{build_dir})) {
        $CPAN::Frontend->mywarn("Directory '$dir' not below $CPAN::Config->{build_dir}, ".
                                "will not remove\n");
        $CPAN::Frontend->mysleep(5);
        return;
    }
    $self->debug("have to rmtree $dir, will free $self->{SIZE}{$dir}")
        if $CPAN::DEBUG;
    File::Path::rmtree($dir);
    my $id_deleted = 0;
    if ($dir !~ /\.yml$/ && -f "$dir.yml") {
        my $yaml_module = CPAN::_yaml_module;
        if ($CPAN::META->has_inst($yaml_module)) {
            my($peek_yaml) = eval { CPAN->_yaml_loadfile("$dir.yml"); };
            if ($@@) {
                $CPAN::Frontend->mywarn("(parse error on '$dir.yml' removing anyway)");
                unlink "$dir.yml" or
                    $CPAN::Frontend->mywarn("(Could not unlink '$dir.yml': $!)");
                return;
            } elsif (my $id = $peek_yaml->[0]{distribution}{ID}) {
                $CPAN::META->delete("CPAN::Distribution", $id);

                # XXX we should restore the state NOW, otherise this
                # distro does not exist until we read an index. BUG ALERT(?)

                # $CPAN::Frontend->mywarn (" +++\n");
                $id_deleted++;
            }
        }
        unlink "$dir.yml"; # may fail
        unless ($id_deleted) {
            CPAN->debug("no distro found associated with '$dir'");
        }
    }
    $self->{DU} -= $self->{SIZE}{$dir};
    delete $self->{SIZE}{$dir};
}

#-> sub CPAN::CacheMgr::new ;
sub new {
    my $class = shift;
    my $time = time;
    my($debug,$t2);
    $debug = "";
    my $self = {
        ID => $CPAN::Config->{build_dir},
        MAX => $CPAN::Config->{'build_cache'},
        SCAN => $CPAN::Config->{'scan_cache'} || 'atstart',
        DU => 0
    };
    File::Path::mkpath($self->{ID});
    my $dh = DirHandle->new($self->{ID});
    bless $self, $class;
    $self->scan_cache;
    $t2 = time;
    $debug .= "timing of CacheMgr->new: ".($t2 - $time);
    $time = $t2;
    CPAN->debug($debug) if $CPAN::DEBUG;
    $self;
}

#-> sub CPAN::CacheMgr::scan_cache ;
sub scan_cache {
    my $self = shift;
    return if $self->{SCAN} eq 'never';
    $CPAN::Frontend->mydie("Unknown scan_cache argument: $self->{SCAN}")
        unless $self->{SCAN} eq 'atstart';
    return unless $CPAN::META->{LOCK};
    $CPAN::Frontend->myprint(
                             sprintf("Scanning cache %s for sizes\n",
                             $self->{ID}));
    my $e;
    my @@entries = $self->entries($self->{ID});
    my $i = 0;
    my $painted = 0;
    for $e (@@entries) {
        my $symbol = ".";
        if ($self->{DU} > $self->{MAX}) {
            $symbol = "-";
            $self->disk_usage($e,1);
        } else {
            $self->disk_usage($e);
        }
        $i++;
        while (($painted/76) < ($i/@@entries)) {
            $CPAN::Frontend->myprint($symbol);
            $painted++;
        }
        return if $CPAN::Signal;
    }
    $CPAN::Frontend->myprint("DONE\n");
    $self->tidyup;
}

package CPAN::Shell;
use strict;

#-> sub CPAN::Shell::h ;
sub h {
    my($class,$about) = @@_;
    if (defined $about) {
        my $help;
        if (exists $Help->{$about}) {
            if (ref $Help->{$about}) { # aliases
                $about = ${$Help->{$about}};
            }
            $help = $Help->{$about};
        } else {
            $help = "No help available";
        }
        $CPAN::Frontend->myprint("$about\: $help\n");
    } else {
        my $filler = " " x (80 - 28 - length($CPAN::VERSION));
        $CPAN::Frontend->myprint(qq{
Display Information $filler (ver $CPAN::VERSION)
 command  argument          description
 a,b,d,m  WORD or /REGEXP/  about authors, bundles, distributions, modules
 i        WORD or /REGEXP/  about any of the above
 ls       AUTHOR or GLOB    about files in the author's directory
    (with WORD being a module, bundle or author name or a distribution
    name of the form AUTHOR/DISTRIBUTION)

Download, Test, Make, Install...
 get      download                     clean    make clean
 make     make (implies get)           look     open subshell in dist directory
 test     make test (implies make)     readme   display these README files
 install  make install (implies test)  perldoc  display POD documentation

Upgrade
 r        WORDs or /REGEXP/ or NONE    report updates for some/matching/all modules
 upgrade  WORDs or /REGEXP/ or NONE    upgrade some/matching/all modules

Pragmas
 force  CMD    try hard to do command  fforce CMD    try harder
 notest CMD    skip testing

Other
 h,?           display this menu       ! perl-code   eval a perl command
 o conf [opt]  set and query options   q             quit the cpan shell
 reload cpan   load CPAN.pm again      reload index  load newer indices
 autobundle    Snapshot                recent        latest CPAN uploads});
}
}

*help = \&h;

#-> sub CPAN::Shell::a ;
sub a {
  my($self,@@arg) = @@_;
  # authors are always UPPERCASE
  for (@@arg) {
    $_ = uc $_ unless /=/;
  }
  $CPAN::Frontend->myprint($self->format_result('Author',@@arg));
}

#-> sub CPAN::Shell::globls ;
sub globls {
    my($self,$s,$pragmas) = @@_;
    # ls is really very different, but we had it once as an ordinary
    # command in the Shell (upto rev. 321) and we could not handle
    # force well then
    my(@@accept,@@preexpand);
    if ($s =~ /[\*\?\/]/) {
        if ($CPAN::META->has_inst("Text::Glob")) {
            if (my($au,$pathglob) = $s =~ m|(.*?)/(.*)|) {
                my $rau = Text::Glob::glob_to_regex(uc $au);
                CPAN::Shell->debug("au[$au]pathglob[$pathglob]rau[$rau]")
                      if $CPAN::DEBUG;
                push @@preexpand, map { $_->id . "/" . $pathglob }
                    CPAN::Shell->expand_by_method('CPAN::Author',['id'],"/$rau/");
            } else {
                my $rau = Text::Glob::glob_to_regex(uc $s);
                push @@preexpand, map { $_->id }
                    CPAN::Shell->expand_by_method('CPAN::Author',
                                                  ['id'],
                                                  "/$rau/");
            }
        } else {
            $CPAN::Frontend->mydie("Text::Glob not installed, cannot proceed");
        }
    } else {
        push @@preexpand, uc $s;
    }
    for (@@preexpand) {
        unless (/^[A-Z0-9\-]+(\/|$)/i) {
            $CPAN::Frontend->mywarn("ls command rejects argument $_: not an author\n");
            next;
        }
        push @@accept, $_;
    }
    my $silent = @@accept>1;
    my $last_alpha = "";
    my @@results;
    for my $a (@@accept) {
        my($author,$pathglob);
        if ($a =~ m|(.*?)/(.*)|) {
            my $a2 = $1;
            $pathglob = $2;
            $author = CPAN::Shell->expand_by_method('CPAN::Author',
                                                    ['id'],
                                                    $a2)
                or $CPAN::Frontend->mydie("No author found for $a2\n");
        } else {
            $author = CPAN::Shell->expand_by_method('CPAN::Author',
                                                    ['id'],
                                                    $a)
                or $CPAN::Frontend->mydie("No author found for $a\n");
        }
        if ($silent) {
            my $alpha = substr $author->id, 0, 1;
            my $ad;
            if ($alpha eq $last_alpha) {
                $ad = "";
            } else {
                $ad = "[$alpha]";
                $last_alpha = $alpha;
            }
            $CPAN::Frontend->myprint($ad);
        }
        for my $pragma (@@$pragmas) {
            if ($author->can($pragma)) {
                $author->$pragma();
            }
        }
        push @@results, $author->ls($pathglob,$silent); # silent if
                                                       # more than one
                                                       # author
        for my $pragma (@@$pragmas) {
            my $unpragma = "un$pragma";
            if ($author->can($unpragma)) {
                $author->$unpragma();
            }
        }
    }
    @@results;
}

#-> sub CPAN::Shell::local_bundles ;
sub local_bundles {
    my($self,@@which) = @@_;
    my($incdir,$bdir,$dh);
    foreach $incdir ($CPAN::Config->{'cpan_home'},@@INC) {
        my @@bbase = "Bundle";
        while (my $bbase = shift @@bbase) {
            $bdir = File::Spec->catdir($incdir,split /::/, $bbase);
            CPAN->debug("bdir[$bdir]\@@bbase[@@bbase]") if $CPAN::DEBUG;
            if ($dh = DirHandle->new($bdir)) { # may fail
                my($entry);
                for $entry ($dh->read) {
                    next if $entry =~ /^\./;
                    next unless $entry =~ /^\w+(\.pm)?(?!\n)\Z/;
                    if (-d File::Spec->catdir($bdir,$entry)) {
                        push @@bbase, "$bbase\::$entry";
                    } else {
                        next unless $entry =~ s/\.pm(?!\n)\Z//;
                        $CPAN::META->instance('CPAN::Bundle',"$bbase\::$entry");
                    }
                }
            }
        }
    }
}

#-> sub CPAN::Shell::b ;
sub b {
    my($self,@@which) = @@_;
    CPAN->debug("which[@@which]") if $CPAN::DEBUG;
    $self->local_bundles;
    $CPAN::Frontend->myprint($self->format_result('Bundle',@@which));
}

#-> sub CPAN::Shell::d ;
sub d { $CPAN::Frontend->myprint(shift->format_result('Distribution',@@_));}

#-> sub CPAN::Shell::m ;
sub m { # emacs confused here }; sub mimimimimi { # emacs in sync here
    my $self = shift;
    $CPAN::Frontend->myprint($self->format_result('Module',@@_));
}

#-> sub CPAN::Shell::i ;
sub i {
    my($self) = shift;
    my(@@args) = @@_;
    @@args = '/./' unless @@args;
    my(@@result);
    for my $type (qw/Bundle Distribution Module/) {
        push @@result, $self->expand($type,@@args);
    }
    # Authors are always uppercase.
    push @@result, $self->expand("Author", map { uc $_ } @@args);

    my $result = @@result == 1 ?
        $result[0]->as_string :
            @@result == 0 ?
                "No objects found of any type for argument @@args\n" :
                    join("",
                         (map {$_->as_glimpse} @@result),
                         scalar @@result, " items found\n",
                        );
    $CPAN::Frontend->myprint($result);
}

#-> sub CPAN::Shell::o ;

# CPAN::Shell::o and CPAN::HandleConfig::edit are closely related. 'o
# conf' calls through to CPAN::HandleConfig::edit. 'o conf' should
# probably have been called 'set' and 'o debug' maybe 'set debug' or
# 'debug'; 'o conf ARGS' calls ->edit in CPAN/HandleConfig.pm
sub o {
    my($self,$o_type,@@o_what) = @@_;
    $o_type ||= "";
    CPAN->debug("o_type[$o_type] o_what[".join(" | ",@@o_what)."]\n");
    if ($o_type eq 'conf') {
        my($cfilter);
        ($cfilter) = $o_what[0] =~ m|^/(.*)/$| if @@o_what;
        if (!@@o_what or $cfilter) { # print all things, "o conf"
            $cfilter ||= "";
            my $qrfilter = eval 'qr/$cfilter/';
            my($k,$v);
            $CPAN::Frontend->myprint("\$CPAN::Config options from ");
            my @@from;
            if (exists $INC{'CPAN/Config.pm'}) {
                push @@from, $INC{'CPAN/Config.pm'};
            }
            if (exists $INC{'CPAN/MyConfig.pm'}) {
                push @@from, $INC{'CPAN/MyConfig.pm'};
            }
            $CPAN::Frontend->myprint(join " and ", map {"'$_'"} @@from);
            $CPAN::Frontend->myprint(":\n");
            for $k (sort keys %CPAN::HandleConfig::can) {
                next unless $k =~ /$qrfilter/;
                $v = $CPAN::HandleConfig::can{$k};
                $CPAN::Frontend->myprint(sprintf "    %-18s [%s]\n", $k, $v);
            }
            $CPAN::Frontend->myprint("\n");
            for $k (sort keys %CPAN::HandleConfig::keys) {
                next unless $k =~ /$qrfilter/;
                CPAN::HandleConfig->prettyprint($k);
            }
            $CPAN::Frontend->myprint("\n");
        } else {
            if (CPAN::HandleConfig->edit(@@o_what)) {
            } else {
                $CPAN::Frontend->myprint(qq{Type 'o conf' to view all configuration }.
                                         qq{items\n\n});
            }
        }
    } elsif ($o_type eq 'debug') {
        my(%valid);
        @@o_what = () if defined $o_what[0] && $o_what[0] =~ /help/i;
        if (@@o_what) {
            while (@@o_what) {
                my($what) = shift @@o_what;
                if ($what =~ s/^-// && exists $CPAN::DEBUG{$what}) {
                    $CPAN::DEBUG &= $CPAN::DEBUG ^ $CPAN::DEBUG{$what};
                    next;
                }
                if ( exists $CPAN::DEBUG{$what} ) {
                    $CPAN::DEBUG |= $CPAN::DEBUG{$what};
                } elsif ($what =~ /^\d/) {
                    $CPAN::DEBUG = $what;
                } elsif (lc $what eq 'all') {
                    my($max) = 0;
                    for (values %CPAN::DEBUG) {
                        $max += $_;
                    }
                    $CPAN::DEBUG = $max;
                } else {
                    my($known) = 0;
                    for (keys %CPAN::DEBUG) {
                        next unless lc($_) eq lc($what);
                        $CPAN::DEBUG |= $CPAN::DEBUG{$_};
                        $known = 1;
                    }
                    $CPAN::Frontend->myprint("unknown argument [$what]\n")
                        unless $known;
                }
            }
        } else {
            my $raw = "Valid options for debug are ".
                join(", ",sort(keys %CPAN::DEBUG), 'all').
                     qq{ or a number. Completion works on the options. }.
                     qq{Case is ignored.};
            require Text::Wrap;
            $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
            $CPAN::Frontend->myprint("\n\n");
        }
        if ($CPAN::DEBUG) {
            $CPAN::Frontend->myprint("Options set for debugging ($CPAN::DEBUG):\n");
            my($k,$v);
            for $k (sort {$CPAN::DEBUG{$a} <=> $CPAN::DEBUG{$b}} keys %CPAN::DEBUG) {
                $v = $CPAN::DEBUG{$k};
                $CPAN::Frontend->myprint(sprintf "    %-14s(%s)\n", $k, $v)
                    if $v & $CPAN::DEBUG;
            }
        } else {
            $CPAN::Frontend->myprint("Debugging turned off completely.\n");
        }
    } else {
        $CPAN::Frontend->myprint(qq{
Known options:
  conf    set or get configuration variables
  debug   set or get debugging options
});
    }
}

# CPAN::Shell::paintdots_onreload
sub paintdots_onreload {
    my($ref) = shift;
    sub {
        if ( $_[0] =~ /[Ss]ubroutine ([\w:]+) redefined/ ) {
            my($subr) = $1;
            ++$$ref;
            local($|) = 1;
            # $CPAN::Frontend->myprint(".($subr)");
            $CPAN::Frontend->myprint(".");
            if ($subr =~ /\bshell\b/i) {
                # warn "debug[$_[0]]";

                # It would be nice if we could detect that a
                # subroutine has actually changed, but for now we
                # practically always set the GOTOSHELL global

                $CPAN::GOTOSHELL=1;
            }
            return;
        }
        warn @@_;
    };
}

#-> sub CPAN::Shell::hosts ;
sub hosts {
    my($self) = @@_;
    my $fullstats = CPAN::FTP->_ftp_statistics();
    my $history = $fullstats->{history} || [];
    my %S; # statistics
    while (my $last = pop @@$history) {
        my $attempts = $last->{attempts} or next;
        my $start;
        if (@@$attempts) {
            $start = $attempts->[-1]{start};
            if ($#$attempts > 0) {
                for my $i (0..$#$attempts-1) {
                    my $url = $attempts->[$i]{url} or next;
                    $S{no}{$url}++;
                }
            }
        } else {
            $start = $last->{start};
        }
        next unless $last->{thesiteurl}; # C-C? bad filenames?
        $S{start} = $start;
        $S{end} ||= $last->{end};
        my $dltime = $last->{end} - $start;
        my $dlsize = $last->{filesize} || 0;
        my $url = ref $last->{thesiteurl} ? $last->{thesiteurl}->text : $last->{thesiteurl};
        my $s = $S{ok}{$url} ||= {};
        $s->{n}++;
        $s->{dlsize} ||= 0;
        $s->{dlsize} += $dlsize/1024;
        $s->{dltime} ||= 0;
        $s->{dltime} += $dltime;
    }
    my $res;
    for my $url (keys %{$S{ok}}) {
        next if $S{ok}{$url}{dltime} == 0; # div by zero
        push @@{$res->{ok}}, [@@{$S{ok}{$url}}{qw(n dlsize dltime)},
                             $S{ok}{$url}{dlsize}/$S{ok}{$url}{dltime},
                             $url,
                            ];
    }
    for my $url (keys %{$S{no}}) {
        push @@{$res->{no}}, [$S{no}{$url},
                             $url,
                            ];
    }
    my $R = ""; # report
    if ($S{start} && $S{end}) {
        $R .= sprintf "Log starts: %s\n", $S{start} ? scalar(localtime $S{start}) : "unknown";
        $R .= sprintf "Log ends  : %s\n", $S{end}   ? scalar(localtime $S{end})   : "unknown";
    }
    if ($res->{ok} && @@{$res->{ok}}) {
        $R .= sprintf "\nSuccessful downloads:
   N       kB  secs      kB/s url\n";
        my $i = 20;
        for (sort { $b->[3] <=> $a->[3] } @@{$res->{ok}}) {
            $R .= sprintf "%4d %8d %5d %9.1f %s\n", @@$_;
            last if --$i<=0;
        }
    }
    if ($res->{no} && @@{$res->{no}}) {
        $R .= sprintf "\nUnsuccessful downloads:\n";
        my $i = 20;
        for (sort { $b->[0] <=> $a->[0] } @@{$res->{no}}) {
            $R .= sprintf "%4d %s\n", @@$_;
            last if --$i<=0;
        }
    }
    $CPAN::Frontend->myprint($R);
}

#-> sub CPAN::Shell::reload ;
sub reload {
    my($self,$command,@@arg) = @@_;
    $command ||= "";
    $self->debug("self[$self]command[$command]arg[@@arg]") if $CPAN::DEBUG;
    if ($command =~ /^cpan$/i) {
        my $redef = 0;
        chdir $CPAN::iCwd if $CPAN::iCwd; # may fail
        my $failed;
        my @@relo = (
                    "CPAN.pm",
                    "CPAN/Debug.pm",
                    "CPAN/FirstTime.pm",
                    "CPAN/HandleConfig.pm",
                    "CPAN/Kwalify.pm",
                    "CPAN/Queue.pm",
                    "CPAN/Reporter/Config.pm",
                    "CPAN/Reporter/History.pm",
                    "CPAN/Reporter.pm",
                    "CPAN/SQLite.pm",
                    "CPAN/Tarzip.pm",
                    "CPAN/Version.pm",
                   );
      MFILE: for my $f (@@relo) {
            next unless exists $INC{$f};
            my $p = $f;
            $p =~ s/\.pm$//;
            $p =~ s|/|::|g;
            $CPAN::Frontend->myprint("($p");
            local($SIG{__WARN__}) = paintdots_onreload(\$redef);
            $self->_reload_this($f) or $failed++;
            my $v = eval "$p\::->VERSION";
            $CPAN::Frontend->myprint("v$v)");
        }
        $CPAN::Frontend->myprint("\n$redef subroutines redefined\n");
        if ($failed) {
            my $errors = $failed == 1 ? "error" : "errors";
            $CPAN::Frontend->mywarn("\n$failed $errors during reload. You better quit ".
                                    "this session.\n");
        }
    } elsif ($command =~ /^index$/i) {
      CPAN::Index->force_reload;
    } else {
      $CPAN::Frontend->myprint(qq{cpan     re-evals the CPAN modules
index    re-reads the index files\n});
    }
}

# reload means only load again what we have loaded before
#-> sub CPAN::Shell::_reload_this ;
sub _reload_this {
    my($self,$f,$args) = @@_;
    CPAN->debug("f[$f]") if $CPAN::DEBUG;
    return 1 unless $INC{$f}; # we never loaded this, so we do not
                              # reload but say OK
    my $pwd = CPAN::anycwd();
    CPAN->debug("pwd[$pwd]") if $CPAN::DEBUG;
    my($file);
    for my $inc (@@INC) {
        $file = File::Spec->catfile($inc,split /\//, $f);
        last if -f $file;
        $file = "";
    }
    CPAN->debug("file[$file]") if $CPAN::DEBUG;
    my @@inc = @@INC;
    unless ($file && -f $file) {
        # this thingie is not in the INC path, maybe CPAN/MyConfig.pm?
        $file = $INC{$f};
        unless (CPAN->has_inst("File::Basename")) {
            @@inc = File::Basename::dirname($file);
        } else {
            # do we ever need this?
            @@inc = substr($file,0,-length($f)-1); # bring in back to me!
        }
    }
    CPAN->debug("file[$file]inc[@@inc]") if $CPAN::DEBUG;
    unless (-f $file) {
        $CPAN::Frontend->mywarn("Found no file to reload for '$f'\n");
        return;
    }
    my $mtime = (stat $file)[9];
    if ($reload->{$f}) {
    } elsif ($^T < $mtime) {
        # since we started the file has changed, force it to be reloaded
        $reload->{$f} = -1;
    } else {
        $reload->{$f} = $mtime;
    }
    my $must_reload = $mtime != $reload->{$f};
    $args ||= {};
    $must_reload ||= $args->{reloforce}; # o conf defaults needs this
    if ($must_reload) {
        my $fh = FileHandle->new($file) or
            $CPAN::Frontend->mydie("Could not open $file: $!");
        local($/);
        local $^W = 1;
        my $content = <$fh>;
        CPAN->debug(sprintf("reload file[%s] content[%s...]",$file,substr($content,0,128)))
            if $CPAN::DEBUG;
        delete $INC{$f};
        local @@INC = @@inc;
        eval "require '$f'";
        if ($@@) {
            warn $@@;
            return;
        }
        $reload->{$f} = $mtime;
    } else {
        $CPAN::Frontend->myprint("__unchanged__");
    }
    return 1;
}

#-> sub CPAN::Shell::mkmyconfig ;
sub mkmyconfig {
    my($self, $cpanpm, %args) = @@_;
    require CPAN::FirstTime;
    my $home = CPAN::HandleConfig::home;
    $cpanpm = $INC{'CPAN/MyConfig.pm'} ||
        File::Spec->catfile(split /\//, "$home/.cpan/CPAN/MyConfig.pm");
    File::Path::mkpath(File::Basename::dirname($cpanpm)) unless -e $cpanpm;
    CPAN::HandleConfig::require_myconfig_or_config;
    $CPAN::Config ||= {};
    $CPAN::Config = {
        %$CPAN::Config,
        build_dir           =>  undef,
        cpan_home           =>  undef,
        keep_source_where   =>  undef,
        histfile            =>  undef,
    };
    CPAN::FirstTime::init($cpanpm, %args);
}

#-> sub CPAN::Shell::_binary_extensions ;
sub _binary_extensions {
    my($self) = shift @@_;
    my(@@result,$module,%seen,%need,$headerdone);
    for $module ($self->expand('Module','/./')) {
        my $file  = $module->cpan_file;
        next if $file eq "N/A";
        next if $file =~ /^Contact Author/;
        my $dist = $CPAN::META->instance('CPAN::Distribution',$file);
        next if $dist->isa_perl;
        next unless $module->xs_file;
        local($|) = 1;
        $CPAN::Frontend->myprint(".");
        push @@result, $module;
    }
#    print join " | ", @@result;
    $CPAN::Frontend->myprint("\n");
    return @@result;
}

#-> sub CPAN::Shell::recompile ;
sub recompile {
    my($self) = shift @@_;
    my($module,@@module,$cpan_file,%dist);
    @@module = $self->_binary_extensions();
    for $module (@@module) { # we force now and compile later, so we
                            # don't do it twice
        $cpan_file = $module->cpan_file;
        my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
        $pack->force;
        $dist{$cpan_file}++;
    }
    for $cpan_file (sort keys %dist) {
        $CPAN::Frontend->myprint("  CPAN: Recompiling $cpan_file\n\n");
        my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
        $pack->install;
        $CPAN::Signal = 0; # it's tempting to reset Signal, so we can
                           # stop a package from recompiling,
                           # e.g. IO-1.12 when we have perl5.003_10
    }
}

#-> sub CPAN::Shell::scripts ;
sub scripts {
    my($self, $arg) = @@_;
    $CPAN::Frontend->mywarn(">>>> experimental command, currently unsupported <<<<\n\n");

    for my $req (qw( HTML::LinkExtor Sort::Versions List::Util )) {
        unless ($CPAN::META->has_inst($req)) {
            $CPAN::Frontend->mywarn("  $req not available\n");
        }
    }
    my $p = HTML::LinkExtor->new();
    my $indexfile = "/home/ftp/pub/PAUSE/scripts/new/index.html";
    unless (-f $indexfile) {
        $CPAN::Frontend->mydie("found no indexfile[$indexfile]\n");
    }
    $p->parse_file($indexfile);
    my @@hrefs;
    my $qrarg;
    if ($arg =~ s|^/(.+)/$|$1|) {
        $qrarg = eval 'qr/$arg/'; # hide construct from 5.004
    }
    for my $l ($p->links) {
        my $tag = shift @@$l;
        next unless $tag eq "a";
        my %att = @@$l;
        my $href = $att{href};
        next unless $href =~ s|^\.\./authors/id/./../||;
        if ($arg) {
            if ($qrarg) {
                if ($href =~ $qrarg) {
                    push @@hrefs, $href;
                }
            } else {
                if ($href =~ /\Q$arg\E/) {
                    push @@hrefs, $href;
                }
            }
        } else {
            push @@hrefs, $href;
        }
    }
    # now filter for the latest version if there is more than one of a name
    my %stems;
    for (sort @@hrefs) {
        my $href = $_;
        s/-v?\d.*//;
        my $stem = $_;
        $stems{$stem} ||= [];
        push @@{$stems{$stem}}, $href;
    }
    for (sort keys %stems) {
        my $highest;
        if (@@{$stems{$_}} > 1) {
            $highest = List::Util::reduce {
                Sort::Versions::versioncmp($a,$b) > 0 ? $a : $b
              } @@{$stems{$_}};
        } else {
            $highest = $stems{$_}[0];
        }
        $CPAN::Frontend->myprint("$highest\n");
    }
}

#-> sub CPAN::Shell::report ;
sub report {
    my($self,@@args) = @@_;
    unless ($CPAN::META->has_inst("CPAN::Reporter")) {
        $CPAN::Frontend->mydie("CPAN::Reporter not installed; cannot continue");
    }
    local $CPAN::Config->{test_report} = 1;
    $self->force("test",@@args); # force is there so that the test be
                                # re-run (as documented)
}

# compare with is_tested
#-> sub CPAN::Shell::install_tested
sub install_tested {
    my($self,@@some) = @@_;
    $CPAN::Frontend->mywarn("install_tested() must not be called with arguments.\n"),
        return if @@some;
    CPAN::Index->reload;

    for my $b (reverse $CPAN::META->_list_sorted_descending_is_tested) {
        my $yaml = "$b.yml";
        unless (-f $yaml) {
            $CPAN::Frontend->mywarn("No YAML file for $b available, skipping\n");
            next;
        }
        my $yaml_content = CPAN->_yaml_loadfile($yaml);
        my $id = $yaml_content->[0]{distribution}{ID};
        unless ($id) {
            $CPAN::Frontend->mywarn("No ID found in '$yaml', skipping\n");
            next;
        }
        my $do = CPAN::Shell->expandany($id);
        unless ($do) {
            $CPAN::Frontend->mywarn("Could not expand ID '$id', skipping\n");
            next;
        }
        unless ($do->{build_dir}) {
            $CPAN::Frontend->mywarn("Distro '$id' has no build_dir, skipping\n");
            next;
        }
        unless ($do->{build_dir} eq $b) {
            $CPAN::Frontend->mywarn("Distro '$id' has build_dir '$do->{build_dir}' but expected '$b', skipping\n");
            next;
        }
        push @@some, $do;
    }

    $CPAN::Frontend->mywarn("No tested distributions found.\n"),
        return unless @@some;

    @@some = grep { $_->{make_test} && ! $_->{make_test}->failed } @@some;
    $CPAN::Frontend->mywarn("No distributions tested with this build of perl found.\n"),
        return unless @@some;

    # @@some = grep { not $_->uptodate } @@some;
    # $CPAN::Frontend->mywarn("No non-uptodate distributions tested with this build of perl found.\n"),
    #     return unless @@some;

    CPAN->debug("some[@@some]");
    for my $d (@@some) {
        my $id = $d->can("pretty_id") ? $d->pretty_id : $d->id;
        $CPAN::Frontend->myprint("install_tested: Running for $id\n");
        $CPAN::Frontend->mysleep(1);
        $self->install($d);
    }
}

#-> sub CPAN::Shell::upgrade ;
sub upgrade {
    my($self,@@args) = @@_;
    $self->install($self->r(@@args));
}

#-> sub CPAN::Shell::_u_r_common ;
sub _u_r_common {
    my($self) = shift @@_;
    my($what) = shift @@_;
    CPAN->debug("self[$self] what[$what] args[@@_]") if $CPAN::DEBUG;
    Carp::croak "Usage: \$obj->_u_r_common(a|r|u)" unless
          $what && $what =~ /^[aru]$/;
    my(@@args) = @@_;
    @@args = '/./' unless @@args;
    my(@@result,$module,%seen,%need,$headerdone,
       $version_undefs,$version_zeroes,
       @@version_undefs,@@version_zeroes);
    $version_undefs = $version_zeroes = 0;
    my $sprintf = "%s%-25s%s %9s %9s  %s\n";
    my @@expand = $self->expand('Module',@@args);
    my $expand = scalar @@expand;
    if (0) { # Looks like noise to me, was very useful for debugging
             # for metadata cache
        $CPAN::Frontend->myprint(sprintf "%d matches in the database\n", $expand);
    }
  MODULE: for $module (@@expand) {
        my $file  = $module->cpan_file;
        next MODULE unless defined $file; # ??
        $file =~ s!^./../!!;
        my($latest) = $module->cpan_version;
        my($inst_file) = $module->inst_file;
        my($have);
        return if $CPAN::Signal;
        if ($inst_file) {
            if ($what eq "a") {
                $have = $module->inst_version;
            } elsif ($what eq "r") {
                $have = $module->inst_version;
                local($^W) = 0;
                if ($have eq "undef") {
                    $version_undefs++;
                    push @@version_undefs, $module->as_glimpse;
                } elsif (CPAN::Version->vcmp($have,0)==0) {
                    $version_zeroes++;
                    push @@version_zeroes, $module->as_glimpse;
                }
                next MODULE unless CPAN::Version->vgt($latest, $have);
# to be pedantic we should probably say:
#    && !($have eq "undef" && $latest ne "undef" && $latest gt "");
# to catch the case where CPAN has a version 0 and we have a version undef
            } elsif ($what eq "u") {
                next MODULE;
            }
        } else {
            if ($what eq "a") {
                next MODULE;
            } elsif ($what eq "r") {
                next MODULE;
            } elsif ($what eq "u") {
                $have = "-";
            }
        }
        return if $CPAN::Signal; # this is sometimes lengthy
        $seen{$file} ||= 0;
        if ($what eq "a") {
            push @@result, sprintf "%s %s\n", $module->id, $have;
        } elsif ($what eq "r") {
            push @@result, $module->id;
            next MODULE if $seen{$file}++;
        } elsif ($what eq "u") {
            push @@result, $module->id;
            next MODULE if $seen{$file}++;
            next MODULE if $file =~ /^Contact/;
        }
        unless ($headerdone++) {
            $CPAN::Frontend->myprint("\n");
            $CPAN::Frontend->myprint(sprintf(
                                             $sprintf,
                                             "",
                                             "Package namespace",
                                             "",
                                             "installed",
                                             "latest",
                                             "in CPAN file"
                                            ));
        }
        my $color_on = "";
        my $color_off = "";
        if (
            $COLOR_REGISTERED
            &&
            $CPAN::META->has_inst("Term::ANSIColor")
            &&
            $module->description
           ) {
            $color_on = Term::ANSIColor::color("green");
            $color_off = Term::ANSIColor::color("reset");
        }
        $CPAN::Frontend->myprint(sprintf $sprintf,
                                 $color_on,
                                 $module->id,
                                 $color_off,
                                 $have,
                                 $latest,
                                 $file);
        $need{$module->id}++;
    }
    unless (%need) {
        if ($what eq "u") {
            $CPAN::Frontend->myprint("No modules found for @@args\n");
        } elsif ($what eq "r") {
            $CPAN::Frontend->myprint("All modules are up to date for @@args\n");
        }
    }
    if ($what eq "r") {
        if ($version_zeroes) {
            my $s_has = $version_zeroes > 1 ? "s have" : " has";
            $CPAN::Frontend->myprint(qq{$version_zeroes installed module$s_has }.
                                     qq{a version number of 0\n});
            if ($CPAN::Config->{show_zero_versions}) {
                local $" = "\t";
                $CPAN::Frontend->myprint(qq{  they are\n\t@@version_zeroes\n});
                $CPAN::Frontend->myprint(qq{(use 'o conf show_zero_versions 0' }.
                                         qq{to hide them)\n});
            } else {
                $CPAN::Frontend->myprint(qq{(use 'o conf show_zero_versions 1' }.
                                         qq{to show them)\n});
            }
        }
        if ($version_undefs) {
            my $s_has = $version_undefs > 1 ? "s have" : " has";
            $CPAN::Frontend->myprint(qq{$version_undefs installed module$s_has no }.
                                     qq{parseable version number\n});
            if ($CPAN::Config->{show_unparsable_versions}) {
                local $" = "\t";
                $CPAN::Frontend->myprint(qq{  they are\n\t@@version_undefs\n});
                $CPAN::Frontend->myprint(qq{(use 'o conf show_unparsable_versions 0' }.
                                         qq{to hide them)\n});
            } else {
                $CPAN::Frontend->myprint(qq{(use 'o conf show_unparsable_versions 1' }.
                                         qq{to show them)\n});
            }
        }
    }
    @@result;
}

#-> sub CPAN::Shell::r ;
sub r {
    shift->_u_r_common("r",@@_);
}

#-> sub CPAN::Shell::u ;
sub u {
    shift->_u_r_common("u",@@_);
}

#-> sub CPAN::Shell::failed ;
sub failed {
    my($self,$only_id,$silent) = @@_;
    my @@failed;
  DIST: for my $d ($CPAN::META->all_objects("CPAN::Distribution")) {
        my $failed = "";
      NAY: for my $nosayer ( # order matters!
                            "unwrapped",
                            "writemakefile",
                            "signature_verify",
                            "make",
                            "make_test",
                            "install",
                            "make_clean",
                           ) {
            next unless exists $d->{$nosayer};
            next unless defined $d->{$nosayer};
            next unless (
                         UNIVERSAL::can($d->{$nosayer},"failed") ?
                         $d->{$nosayer}->failed :
                         $d->{$nosayer} =~ /^NO/
                        );
            next NAY if $only_id && $only_id != (
                                                 UNIVERSAL::can($d->{$nosayer},"commandid")
                                                 ?
                                                 $d->{$nosayer}->commandid
                                                 :
                                                 $CPAN::CurrentCommandId
                                                );
            $failed = $nosayer;
            last;
        }
        next DIST unless $failed;
        my $id = $d->id;
        $id =~ s|^./../||;
        #$print .= sprintf(
        #                  "  %-45s: %s %s\n",
        push @@failed,
            (
             UNIVERSAL::can($d->{$failed},"failed") ?
             [
              $d->{$failed}->commandid,
              $id,
              $failed,
              $d->{$failed}->text,
              $d->{$failed}{TIME}||0,
             ] :
             [
              1,
              $id,
              $failed,
              $d->{$failed},
              0,
             ]
            );
    }
    my $scope;
    if ($only_id) {
        $scope = "this command";
    } elsif ($CPAN::Index::HAVE_REANIMATED) {
        $scope = "this or a previous session";
        # it might be nice to have a section for previous session and
        # a second for this
    } else {
        $scope = "this session";
    }
    if (@@failed) {
        my $print;
        my $debug = 0;
        if ($debug) {
            $print = join "",
                map { sprintf "%5d %-45s: %s %s\n", @@$_ }
                    sort { $a->[0] <=> $b->[0] } @@failed;
        } else {
            $print = join "",
                map { sprintf " %-45s: %s %s\n", @@$_[1..3] }
                    sort {
                        $a->[0] <=> $b->[0]
                            ||
                                $a->[4] <=> $b->[4]
                       } @@failed;
        }
        $CPAN::Frontend->myprint("Failed during $scope:\n$print");
    } elsif (!$only_id || !$silent) {
        $CPAN::Frontend->myprint("Nothing failed in $scope\n");
    }
}

# XXX intentionally undocumented because completely bogus, unportable,
# useless, etc.

#-> sub CPAN::Shell::status ;
sub status {
    my($self) = @@_;
    require Devel::Size;
    my $ps = FileHandle->new;
    open $ps, "/proc/$$/status";
    my $vm = 0;
    while (<$ps>) {
        next unless /VmSize:\s+(\d+)/;
        $vm = $1;
        last;
    }
    $CPAN::Frontend->mywarn(sprintf(
                                    "%-27s %6d\n%-27s %6d\n",
                                    "vm",
                                    $vm,
                                    "CPAN::META",
                                    Devel::Size::total_size($CPAN::META)/1024,
                                   ));
    for my $k (sort keys %$CPAN::META) {
        next unless substr($k,0,4) eq "read";
        warn sprintf " %-26s %6d\n", $k, Devel::Size::total_size($CPAN::META->{$k})/1024;
        for my $k2 (sort keys %{$CPAN::META->{$k}}) {
            warn sprintf "  %-25s %6d (keys: %6d)\n",
                $k2,
                    Devel::Size::total_size($CPAN::META->{$k}{$k2})/1024,
                          scalar keys %{$CPAN::META->{$k}{$k2}};
        }
    }
}

# compare with install_tested
#-> sub CPAN::Shell::is_tested
sub is_tested {
    my($self) = @@_;
    CPAN::Index->reload;
    for my $b (reverse $CPAN::META->_list_sorted_descending_is_tested) {
        my $time;
        if ($CPAN::META->{is_tested}{$b}) {
            $time = scalar(localtime $CPAN::META->{is_tested}{$b});
        } else {
            $time = scalar localtime;
            $time =~ s/\S/?/g;
        }
        $CPAN::Frontend->myprint(sprintf "%s %s\n", $time, $b);
    }
}

#-> sub CPAN::Shell::autobundle ;
sub autobundle {
    my($self) = shift;
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
    my(@@bundle) = $self->_u_r_common("a",@@_);
    my($todir) = File::Spec->catdir($CPAN::Config->{'cpan_home'},"Bundle");
    File::Path::mkpath($todir);
    unless (-d $todir) {
        $CPAN::Frontend->myprint("Couldn't mkdir $todir for some reason\n");
        return;
    }
    my($y,$m,$d) =  (localtime)[5,4,3];
    $y+=1900;
    $m++;
    my($c) = 0;
    my($me) = sprintf "Snapshot_%04d_%02d_%02d_%02d", $y, $m, $d, $c;
    my($to) = File::Spec->catfile($todir,"$me.pm");
    while (-f $to) {
        $me = sprintf "Snapshot_%04d_%02d_%02d_%02d", $y, $m, $d, ++$c;
        $to = File::Spec->catfile($todir,"$me.pm");
    }
    my($fh) = FileHandle->new(">$to") or Carp::croak "Can't open >$to: $!";
    $fh->print(
               "package Bundle::$me;\n\n",
               "\$VERSION = '0.01';\n\n",
               "1;\n\n",
               "__END__\n\n",
               "=head1 NAME\n\n",
               "Bundle::$me - Snapshot of installation on ",
               $Config::Config{'myhostname'},
               " on ",
               scalar(localtime),
               "\n\n=head1 SYNOPSIS\n\n",
               "perl -MCPAN -e 'install Bundle::$me'\n\n",
               "=head1 CONTENTS\n\n",
               join("\n", @@bundle),
               "\n\n=head1 CONFIGURATION\n\n",
               Config->myconfig,
               "\n\n=head1 AUTHOR\n\n",
               "This Bundle has been generated automatically ",
               "by the autobundle routine in CPAN.pm.\n",
              );
    $fh->close;
    $CPAN::Frontend->myprint("\nWrote bundle file
    $to\n\n");
}

#-> sub CPAN::Shell::expandany ;
sub expandany {
    my($self,$s) = @@_;
    CPAN->debug("s[$s]") if $CPAN::DEBUG;
    if ($s =~ m|/| or substr($s,-1,1) eq ".") { # looks like a file or a directory
        $s = CPAN::Distribution->normalize($s);
        return $CPAN::META->instance('CPAN::Distribution',$s);
        # Distributions spring into existence, not expand
    } elsif ($s =~ m|^Bundle::|) {
        $self->local_bundles; # scanning so late for bundles seems
                              # both attractive and crumpy: always
                              # current state but easy to forget
                              # somewhere
        return $self->expand('Bundle',$s);
    } else {
        return $self->expand('Module',$s)
            if $CPAN::META->exists('CPAN::Module',$s);
    }
    return;
}

#-> sub CPAN::Shell::expand ;
sub expand {
    my $self = shift;
    my($type,@@args) = @@_;
    CPAN->debug("type[$type]args[@@args]") if $CPAN::DEBUG;
    my $class = "CPAN::$type";
    my $methods = ['id'];
    for my $meth (qw(name)) {
        next unless $class->can($meth);
        push @@$methods, $meth;
    }
    $self->expand_by_method($class,$methods,@@args);
}

#-> sub CPAN::Shell::expand_by_method ;
sub expand_by_method {
    my $self = shift;
    my($class,$methods,@@args) = @@_;
    my($arg,@@m);
    for $arg (@@args) {
        my($regex,$command);
        if ($arg =~ m|^/(.*)/$|) {
            $regex = $1;
# FIXME:  there seem to be some ='s in the author data, which trigger
#         a failure here.  This needs to be contemplated.
#            } elsif ($arg =~ m/=/) {
#                $command = 1;
        }
        my $obj;
        CPAN->debug(sprintf "class[%s]regex[%s]command[%s]",
                    $class,
                    defined $regex ? $regex : "UNDEFINED",
                    defined $command ? $command : "UNDEFINED",
                   ) if $CPAN::DEBUG;
        if (defined $regex) {
            if (CPAN::_sqlite_running) {
                $CPAN::SQLite->search($class, $regex);
            }
            for $obj (
                      $CPAN::META->all_objects($class)
                     ) {
                unless ($obj && UNIVERSAL::can($obj,"id") && $obj->id) {
                    # BUG, we got an empty object somewhere
                    require Data::Dumper;
                    CPAN->debug(sprintf(
                                        "Bug in CPAN: Empty id on obj[%s][%s]",
                                        $obj,
                                        Data::Dumper::Dumper($obj)
                                       )) if $CPAN::DEBUG;
                    next;
                }
                for my $method (@@$methods) {
                    my $match = eval {$obj->$method() =~ /$regex/i};
                    if ($@@) {
                        my($err) = $@@ =~ /^(.+) at .+? line \d+\.$/;
                        $err ||= $@@; # if we were too restrictive above
                        $CPAN::Frontend->mydie("$err\n");
                    } elsif ($match) {
                        push @@m, $obj;
                        last;
                    }
                }
            }
        } elsif ($command) {
            die "equal sign in command disabled (immature interface), ".
                "you can set
 ! \$CPAN::Shell::ADVANCED_QUERY=1
to enable it. But please note, this is HIGHLY EXPERIMENTAL code
that may go away anytime.\n"
                    unless $ADVANCED_QUERY;
            my($method,$criterion) = $arg =~ /(.+?)=(.+)/;
            my($matchcrit) = $criterion =~ m/^~(.+)/;
            for my $self (
                          sort
                          {$a->id cmp $b->id}
                          $CPAN::META->all_objects($class)
                         ) {
                my $lhs = $self->$method() or next; # () for 5.00503
                if ($matchcrit) {
                    push @@m, $self if $lhs =~ m/$matchcrit/;
                } else {
                    push @@m, $self if $lhs eq $criterion;
                }
            }
        } else {
            my($xarg) = $arg;
            if ( $class eq 'CPAN::Bundle' ) {
                $xarg =~ s/^(Bundle::)?(.*)/Bundle::$2/;
            } elsif ($class eq "CPAN::Distribution") {
                $xarg = CPAN::Distribution->normalize($arg);
            } else {
                $xarg =~ s/:+/::/g;
            }
            if ($CPAN::META->exists($class,$xarg)) {
                $obj = $CPAN::META->instance($class,$xarg);
            } elsif ($CPAN::META->exists($class,$arg)) {
                $obj = $CPAN::META->instance($class,$arg);
            } else {
                next;
            }
            push @@m, $obj;
        }
    }
    @@m = sort {$a->id cmp $b->id} @@m;
    if ( $CPAN::DEBUG ) {
        my $wantarray = wantarray;
        my $join_m = join ",", map {$_->id} @@m;
        $self->debug("wantarray[$wantarray]join_m[$join_m]");
    }
    return wantarray ? @@m : $m[0];
}

#-> sub CPAN::Shell::format_result ;
sub format_result {
    my($self) = shift;
    my($type,@@args) = @@_;
    @@args = '/./' unless @@args;
    my(@@result) = $self->expand($type,@@args);
    my $result = @@result == 1 ?
        $result[0]->as_string :
            @@result == 0 ?
                "No objects of type $type found for argument @@args\n" :
                    join("",
                         (map {$_->as_glimpse} @@result),
                         scalar @@result, " items found\n",
                        );
    $result;
}

#-> sub CPAN::Shell::report_fh ;
{
    my $installation_report_fh;
    my $previously_noticed = 0;

    sub report_fh {
        return $installation_report_fh if $installation_report_fh;
        if ($CPAN::META->has_usable("File::Temp")) {
            $installation_report_fh
                = File::Temp->new(
                                  dir      => File::Spec->tmpdir,
                                  template => 'cpan_install_XXXX',
                                  suffix   => '.txt',
                                  unlink   => 0,
                                 );
        }
        unless ( $installation_report_fh ) {
            warn("Couldn't open installation report file; " .
                 "no report file will be generated."
                ) unless $previously_noticed++;
        }
    }
}


# The only reason for this method is currently to have a reliable
# debugging utility that reveals which output is going through which
# channel. No, I don't like the colors ;-)

# to turn colordebugging on, write
# cpan> o conf colorize_output 1

#-> sub CPAN::Shell::print_ornamented ;
{
    my $print_ornamented_have_warned = 0;
    sub colorize_output {
        my $colorize_output = $CPAN::Config->{colorize_output};
        if ($colorize_output && !$CPAN::META->has_inst("Term::ANSIColor")) {
            unless ($print_ornamented_have_warned++) {
                # no myprint/mywarn within myprint/mywarn!
                warn "Colorize_output is set to true but Term::ANSIColor is not
installed. To activate colorized output, please install Term::ANSIColor.\n\n";
            }
            $colorize_output = 0;
        }
        return $colorize_output;
    }
}


#-> sub CPAN::Shell::print_ornamented ;
sub print_ornamented {
    my($self,$what,$ornament) = @@_;
    return unless defined $what;

    local $| = 1; # Flush immediately
    if ( $CPAN::Be_Silent ) {
        print {report_fh()} $what;
        return;
    }
    my $swhat = "$what"; # stringify if it is an object
    if ($CPAN::Config->{term_is_latin}) {
        # note: deprecated, need to switch to $LANG and $LC_*
        # courtesy jhi:
        $swhat
            =~ s{([\xC0-\xDF])([\x80-\xBF])}{chr(ord($1)<<6&0xC0|ord($2)&0x3F)}eg; #};
    }
    if ($self->colorize_output) {
        if ( $CPAN::DEBUG && $swhat =~ /^Debug\(/ ) {
            # if you want to have this configurable, please file a bugreport
            $ornament = $CPAN::Config->{colorize_debug} || "black on_cyan";
        }
        my $color_on = eval { Term::ANSIColor::color($ornament) } || "";
        if ($@@) {
            print "Term::ANSIColor rejects color[$ornament]: $@@\n
Please choose a different color (Hint: try 'o conf init /color/')\n";
        }
        # GGOLDBACH/Test-GreaterVersion-0.008 broke wthout this
        # $trailer construct. We want the newline be the last thing if
        # there is a newline at the end ensuring that the next line is
        # empty for other players
        my $trailer = "";
        $trailer = $1 if $swhat =~ s/([\r\n]+)\z//;
        print $color_on,
            $swhat,
                Term::ANSIColor::color("reset"),
                      $trailer;
    } else {
        print $swhat;
    }
}

#-> sub CPAN::Shell::myprint ;

# where is myprint/mywarn/Frontend/etc. documented? Where to use what?
# I think, we send everything to STDOUT and use print for normal/good
# news and warn for news that need more attention. Yes, this is our
# working contract for now.
sub myprint {
    my($self,$what) = @@_;
    $self->print_ornamented($what,
                            $CPAN::Config->{colorize_print}||'bold blue on_white',
                           );
}

sub optprint {
    my($self,$category,$what) = @@_;
    my $vname = $category . "_verbosity";
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
    if (!$CPAN::Config->{$vname}
        || $CPAN::Config->{$vname} =~ /^v/
       ) {
        $CPAN::Frontend->myprint($what);
    }
}

#-> sub CPAN::Shell::myexit ;
sub myexit {
    my($self,$what) = @@_;
    $self->myprint($what);
    exit;
}

#-> sub CPAN::Shell::mywarn ;
sub mywarn {
    my($self,$what) = @@_;
    $self->print_ornamented($what, $CPAN::Config->{colorize_warn}||'bold red on_white');
}

# only to be used for shell commands
#-> sub CPAN::Shell::mydie ;
sub mydie {
    my($self,$what) = @@_;
    $self->mywarn($what);

    # If it is the shell, we want the following die to be silent,
    # but if it is not the shell, we would need a 'die $what'. We need
    # to take care that only shell commands use mydie. Is this
    # possible?

    die "\n";
}

# sub CPAN::Shell::colorable_makemaker_prompt ;
sub colorable_makemaker_prompt {
    my($foo,$bar) = @@_;
    if (CPAN::Shell->colorize_output) {
        my $ornament = $CPAN::Config->{colorize_print}||'bold blue on_white';
        my $color_on = eval { Term::ANSIColor::color($ornament); } || "";
        print $color_on;
    }
    my $ans = ExtUtils::MakeMaker::prompt($foo,$bar);
    if (CPAN::Shell->colorize_output) {
        print Term::ANSIColor::color('reset');
    }
    return $ans;
}

# use this only for unrecoverable errors!
#-> sub CPAN::Shell::unrecoverable_error ;
sub unrecoverable_error {
    my($self,$what) = @@_;
    my @@lines = split /\n/, $what;
    my $longest = 0;
    for my $l (@@lines) {
        $longest = length $l if length $l > $longest;
    }
    $longest = 62 if $longest > 62;
    for my $l (@@lines) {
        if ($l =~ /^\s*$/) {
            $l = "\n";
            next;
        }
        $l = "==> $l";
        if (length $l < 66) {
            $l = pack "A66 A*", $l, "<==";
        }
        $l .= "\n";
    }
    unshift @@lines, "\n";
    $self->mydie(join "", @@lines);
}

#-> sub CPAN::Shell::mysleep ;
sub mysleep {
    my($self, $sleep) = @@_;
    if (CPAN->has_inst("Time::HiRes")) {
        Time::HiRes::sleep($sleep);
    } else {
        sleep($sleep < 1 ? 1 : int($sleep + 0.5));
    }
}

#-> sub CPAN::Shell::setup_output ;
sub setup_output {
    return if -t STDOUT;
    my $odef = select STDERR;
    $| = 1;
    select STDOUT;
    $| = 1;
    select $odef;
}

#-> sub CPAN::Shell::rematein ;
# RE-adme||MA-ke||TE-st||IN-stall : nearly everything runs through here
sub rematein {
    my $self = shift;
    my($meth,@@some) = @@_;
    my @@pragma;
    while($meth =~ /^(ff?orce|notest)$/) {
        push @@pragma, $meth;
        $meth = shift @@some or
            $CPAN::Frontend->mydie("Pragma $pragma[-1] used without method: ".
                                   "cannot continue");
    }
    setup_output();
    CPAN->debug("pragma[@@pragma]meth[$meth]some[@@some]") if $CPAN::DEBUG;

    # Here is the place to set "test_count" on all involved parties to
    # 0. We then can pass this counter on to the involved
    # distributions and those can refuse to test if test_count > X. In
    # the first stab at it we could use a 1 for "X".

    # But when do I reset the distributions to start with 0 again?
    # Jost suggested to have a random or cycling interaction ID that
    # we pass through. But the ID is something that is just left lying
    # around in addition to the counter, so I'd prefer to set the
    # counter to 0 now, and repeat at the end of the loop. But what
    # about dependencies? They appear later and are not reset, they
    # enter the queue but not its copy. How do they get a sensible
    # test_count?

    # With configure_requires, "get" is vulnerable in recursion.

    my $needs_recursion_protection = "get|make|test|install";

    # construct the queue
    my($s,@@s,@@qcopy);
  STHING: foreach $s (@@some) {
        my $obj;
        if (ref $s) {
            CPAN->debug("s is an object[$s]") if $CPAN::DEBUG;
            $obj = $s;
        } elsif ($s =~ m|[\$\@@\%]|) { # looks like a perl variable
        } elsif ($s =~ m|^/|) { # looks like a regexp
            if (substr($s,-1,1) eq ".") {
                $obj = CPAN::Shell->expandany($s);
            } else {
                $CPAN::Frontend->mywarn("Sorry, $meth with a regular expression is ".
                                        "not supported.\nRejecting argument '$s'\n");
                $CPAN::Frontend->mysleep(2);
                next;
            }
        } elsif ($meth eq "ls") {
            $self->globls($s,\@@pragma);
            next STHING;
        } else {
            CPAN->debug("calling expandany [$s]") if $CPAN::DEBUG;
            $obj = CPAN::Shell->expandany($s);
        }
        if (0) {
        } elsif (ref $obj) {
            if ($meth =~ /^($needs_recursion_protection)$/) {
                # it would be silly to check for recursion for look or dump
                # (we are in CPAN::Shell::rematein)
                CPAN->debug("Going to test against recursion") if $CPAN::DEBUG;
                eval {  $obj->color_cmd_tmps(0,1); };
                if ($@@) {
                    if (ref $@@
                        and $@@->isa("CPAN::Exception::RecursiveDependency")) {
                        $CPAN::Frontend->mywarn($@@);
                    } else {
                        if (0) {
                            require Carp;
                            Carp::confess(sprintf "DEBUG: \$\@@[%s]ref[%s]", $@@, ref $@@);
                        }
                        die;
                    }
                }
            }
            CPAN::Queue->queue_item(qmod => $obj->id, reqtype => "c");
            push @@qcopy, $obj;
        } elsif ($CPAN::META->exists('CPAN::Author',uc($s))) {
            $obj = $CPAN::META->instance('CPAN::Author',uc($s));
            if ($meth =~ /^(dump|ls|reports)$/) {
                $obj->$meth();
            } else {
                $CPAN::Frontend->mywarn(
                                        join "",
                                        "Don't be silly, you can't $meth ",
                                        $obj->fullname,
                                        " ;-)\n"
                                       );
                $CPAN::Frontend->mysleep(2);
            }
        } elsif ($s =~ m|[\$\@@\%]| && $meth eq "dump") {
            CPAN::InfoObj->dump($s);
        } else {
            $CPAN::Frontend
                ->mywarn(qq{Warning: Cannot $meth $s, }.
                         qq{don't know what it is.
Try the command

    i /$s/

to find objects with matching identifiers.
});
            $CPAN::Frontend->mysleep(2);
        }
    }

    # queuerunner (please be warned: when I started to change the
    # queue to hold objects instead of names, I made one or two
    # mistakes and never found which. I reverted back instead)
    while (my $q = CPAN::Queue->first) {
        my $obj;
        my $s = $q->as_string;
        my $reqtype = $q->reqtype || "";
        $obj = CPAN::Shell->expandany($s);
        unless ($obj) {
            # don't know how this can happen, maybe we should panic,
            # but maybe we get a solution from the first user who hits
            # this unfortunate exception?
            $CPAN::Frontend->mywarn("Warning: Could not expand string '$s' ".
                                    "to an object. Skipping.\n");
            $CPAN::Frontend->mysleep(5);
            CPAN::Queue->delete_first($s);
            next;
        }
        $obj->{reqtype} ||= "";
        {
            # force debugging because CPAN::SQLite somehow delivers us
            # an empty object;

            # local $CPAN::DEBUG = 1024; # Shell; probably fixed now

            CPAN->debug("s[$s]obj-reqtype[$obj->{reqtype}]".
                        "q-reqtype[$reqtype]") if $CPAN::DEBUG;
        }
        if ($obj->{reqtype}) {
            if ($obj->{reqtype} eq "b" && $reqtype =~ /^[rc]$/) {
                $obj->{reqtype} = $reqtype;
                if (
                    exists $obj->{install}
                    &&
                    (
                     UNIVERSAL::can($obj->{install},"failed") ?
                     $obj->{install}->failed :
                     $obj->{install} =~ /^NO/
                    )
                   ) {
                    delete $obj->{install};
                    $CPAN::Frontend->mywarn
                        ("Promoting $obj->{ID} from 'build_requires' to 'requires'");
                }
            }
        } else {
            $obj->{reqtype} = $reqtype;
        }

        for my $pragma (@@pragma) {
            if ($pragma
                &&
                $obj->can($pragma)) {
                $obj->$pragma($meth);
            }
        }
        if (UNIVERSAL::can($obj, 'called_for')) {
            $obj->called_for($s);
        }
        CPAN->debug(qq{pragma[@@pragma]meth[$meth]}.
                    qq{ID[$obj->{ID}]}) if $CPAN::DEBUG;

        push @@qcopy, $obj;
        if ($meth =~ /^(report)$/) { # they came here with a pragma?
            $self->$meth($obj);
        } elsif (! UNIVERSAL::can($obj,$meth)) {
            # Must never happen
            my $serialized = "";
            if (0) {
            } elsif ($CPAN::META->has_inst("YAML::Syck")) {
                $serialized = YAML::Syck::Dump($obj);
            } elsif ($CPAN::META->has_inst("YAML")) {
                $serialized = YAML::Dump($obj);
            } elsif ($CPAN::META->has_inst("Data::Dumper")) {
                $serialized = Data::Dumper::Dumper($obj);
            } else {
                require overload;
                $serialized = overload::StrVal($obj);
            }
            CPAN->debug("Going to panic. meth[$meth]s[$s]") if $CPAN::DEBUG;
            $CPAN::Frontend->mydie("Panic: obj[$serialized] cannot meth[$meth]");
        } elsif ($obj->$meth()) {
            CPAN::Queue->delete($s);
            CPAN->debug("From queue deleted. meth[$meth]s[$s]") if $CPAN::DEBUG;
        } else {
            CPAN->debug("Failed. pragma[@@pragma]meth[$meth]") if $CPAN::DEBUG;
        }

        $obj->undelay;
        for my $pragma (@@pragma) {
            my $unpragma = "un$pragma";
            if ($obj->can($unpragma)) {
                $obj->$unpragma();
            }
        }
        CPAN::Queue->delete_first($s);
    }
    if ($meth =~ /^($needs_recursion_protection)$/) {
        for my $obj (@@qcopy) {
            $obj->color_cmd_tmps(0,0);
        }
    }
}

#-> sub CPAN::Shell::recent ;
sub recent {
  my($self) = @@_;
  if ($CPAN::META->has_inst("XML::LibXML")) {
      my $url = $CPAN::Defaultrecent;
      $CPAN::Frontend->myprint("Going to fetch '$url'\n");
      unless ($CPAN::META->has_usable("LWP")) {
          $CPAN::Frontend->mydie("LWP not installed; cannot continue");
      }
      CPAN::LWP::UserAgent->config;
      my $Ua;
      eval { $Ua = CPAN::LWP::UserAgent->new; };
      if ($@@) {
          $CPAN::Frontend->mydie("CPAN::LWP::UserAgent->new dies with $@@\n");
      }
      my $resp = $Ua->get($url);
      unless ($resp->is_success) {
          $CPAN::Frontend->mydie(sprintf "Could not download '%s': %s\n", $url, $resp->code);
      }
      $CPAN::Frontend->myprint("DONE\n\n");
      my $xml = XML::LibXML->new->parse_string($resp->content);
      if (0) {
          my $s = $xml->serialize(2);
          $s =~ s/\n\s*\n/\n/g;
          $CPAN::Frontend->myprint($s);
          return;
      }
      my @@distros;
      if ($url =~ /winnipeg/) {
          my $pubdate = $xml->findvalue("/rss/channel/pubDate");
          $CPAN::Frontend->myprint("    pubDate: $pubdate\n\n");
          for my $eitem ($xml->findnodes("/rss/channel/item")) {
              my $distro = $eitem->findvalue("enclosure/\@@url");
              $distro =~ s|.*?/authors/id/./../||;
              my $size   = $eitem->findvalue("enclosure/\@@length");
              my $desc   = $eitem->findvalue("description");
               $desc =~ s/.+? - //;
              $CPAN::Frontend->myprint("$distro [$size b]\n    $desc\n");
              push @@distros, $distro;
          }
      } elsif ($url =~ /search.*uploads.rdf/) {
          # xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
          # xmlns="http://purl.org/rss/1.0/"
          # xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/"
          # xmlns:dc="http://purl.org/dc/elements/1.1/"
          # xmlns:syn="http://purl.org/rss/1.0/modules/syndication/"
          # xmlns:admin="http://webns.net/mvcb/"


          my $dc_date = $xml->findvalue("//*[local-name(.) = 'RDF']/*[local-name(.) = 'channel']/*[local-name(.) = 'date']");
          $CPAN::Frontend->myprint("    dc:date: $dc_date\n\n");
          my $finish_eitem = 0;
          local $SIG{INT} = sub { $finish_eitem = 1 };
        EITEM: for my $eitem ($xml->findnodes("//*[local-name(.) = 'RDF']/*[local-name(.) = 'item']")) {
              my $distro = $eitem->findvalue("\@@rdf:about");
              $distro =~ s|.*~||; # remove up to the tilde before the name
              $distro =~ s|/$||; # remove trailing slash
              $distro =~ s|([^/]+)|\U$1\E|; # upcase the name
              my $author = uc $1 or die "distro[$distro] without author, cannot continue";
              my $desc   = $eitem->findvalue("*[local-name(.) = 'description']");
              my $i = 0;
            SUBDIRTEST: while () {
                  last SUBDIRTEST if ++$i >= 6; # half a dozen must do!
                  if (my @@ret = $self->globls("$distro*")) {
                      @@ret = grep {$_->[2] !~ /meta/} @@ret;
                      @@ret = grep {length $_->[2]} @@ret;
                      if (@@ret) {
                          $distro = "$author/$ret[0][2]";
                          last SUBDIRTEST;
                      }
                  }
                  $distro =~ s|/|/*/|; # allow it to reside in a subdirectory
              }

              next EITEM if $distro =~ m|\*|; # did not find the thing
              $CPAN::Frontend->myprint("____$desc\n");
              push @@distros, $distro;
              last EITEM if $finish_eitem;
          }
      }
      return \@@distros;
  } else {
      # deprecated old version
      $CPAN::Frontend->mydie("no XML::LibXML installed, cannot continue\n");
  }
}

#-> sub CPAN::Shell::smoke ;
sub smoke {
    my($self) = @@_;
    my $distros = $self->recent;
  DISTRO: for my $distro (@@$distros) {
        $CPAN::Frontend->myprint(sprintf "Going to download and test '$distro'\n");
        {
            my $skip = 0;
            local $SIG{INT} = sub { $skip = 1 };
            for (0..9) {
                $CPAN::Frontend->myprint(sprintf "\r%2d (Hit ^C to skip)", 10-$_);
                sleep 1;
                if ($skip) {
                    $CPAN::Frontend->myprint(" skipped\n");
                    next DISTRO;
                }
            }
        }
        $CPAN::Frontend->myprint("\r  \n"); # leave the dirty line with a newline
        $self->test($distro);
    }
}

{
    # set up the dispatching methods
    no strict "refs";
    for my $command (qw(
                        clean
                        cvs_import
                        dump
                        force
                        fforce
                        get
                        install
                        look
                        ls
                        make
                        notest
                        perldoc
                        readme
                        reports
                        test
                       )) {
        *$command = sub { shift->rematein($command, @@_); };
    }
}

package CPAN::LWP::UserAgent;
use strict;

sub config {
    return if $SETUPDONE;
    if ($CPAN::META->has_usable('LWP::UserAgent')) {
        require LWP::UserAgent;
        @@ISA = qw(Exporter LWP::UserAgent);
        $SETUPDONE++;
    } else {
        $CPAN::Frontend->mywarn("  LWP::UserAgent not available\n");
    }
}

sub get_basic_credentials {
    my($self, $realm, $uri, $proxy) = @@_;
    if ($USER && $PASSWD) {
        return ($USER, $PASSWD);
    }
    if ( $proxy ) {
        ($USER,$PASSWD) = $self->get_proxy_credentials();
    } else {
        ($USER,$PASSWD) = $self->get_non_proxy_credentials();
    }
    return($USER,$PASSWD);
}

sub get_proxy_credentials {
    my $self = shift;
    my ($user, $password);
    if ( defined $CPAN::Config->{proxy_user} &&
         defined $CPAN::Config->{proxy_pass}) {
        $user = $CPAN::Config->{proxy_user};
        $password = $CPAN::Config->{proxy_pass};
        return ($user, $password);
    }
    my $username_prompt = "\nProxy authentication needed!
 (Note: to permanently configure username and password run
   o conf proxy_user your_username
   o conf proxy_pass your_password
     )\nUsername:";
    ($user, $password) =
        _get_username_and_password_from_user($username_prompt);
    return ($user,$password);
}

sub get_non_proxy_credentials {
    my $self = shift;
    my ($user,$password);
    if ( defined $CPAN::Config->{username} &&
         defined $CPAN::Config->{password}) {
        $user = $CPAN::Config->{username};
        $password = $CPAN::Config->{password};
        return ($user, $password);
    }
    my $username_prompt = "\nAuthentication needed!
     (Note: to permanently configure username and password run
       o conf username your_username
       o conf password your_password
     )\nUsername:";

    ($user, $password) =
        _get_username_and_password_from_user($username_prompt);
    return ($user,$password);
}

sub _get_username_and_password_from_user {
    my $username_message = shift;
    my ($username,$password);

    ExtUtils::MakeMaker->import(qw(prompt));
    $username = prompt($username_message);
        if ($CPAN::META->has_inst("Term::ReadKey")) {
            Term::ReadKey::ReadMode("noecho");
        }
    else {
        $CPAN::Frontend->mywarn(
            "Warning: Term::ReadKey seems not to be available, your password will be echoed to the terminal!\n"
        );
    }
    $password = prompt("Password:");

        if ($CPAN::META->has_inst("Term::ReadKey")) {
            Term::ReadKey::ReadMode("restore");
        }
        $CPAN::Frontend->myprint("\n\n");
    return ($username,$password);
}

# mirror(): Its purpose is to deal with proxy authentication. When we
# call SUPER::mirror, we relly call the mirror method in
# LWP::UserAgent. LWP::UserAgent will then call
# $self->get_basic_credentials or some equivalent and this will be
# $self->dispatched to our own get_basic_credentials method.

# Our own get_basic_credentials sets $USER and $PASSWD, two globals.

# 407 stands for HTTP_PROXY_AUTHENTICATION_REQUIRED. Which means
# although we have gone through our get_basic_credentials, the proxy
# server refuses to connect. This could be a case where the username or
# password has changed in the meantime, so I'm trying once again without
# $USER and $PASSWD to give the get_basic_credentials routine another
# chance to set $USER and $PASSWD.

# mirror(): Its purpose is to deal with proxy authentication. When we
# call SUPER::mirror, we relly call the mirror method in
# LWP::UserAgent. LWP::UserAgent will then call
# $self->get_basic_credentials or some equivalent and this will be
# $self->dispatched to our own get_basic_credentials method.

# Our own get_basic_credentials sets $USER and $PASSWD, two globals.

# 407 stands for HTTP_PROXY_AUTHENTICATION_REQUIRED. Which means
# although we have gone through our get_basic_credentials, the proxy
# server refuses to connect. This could be a case where the username or
# password has changed in the meantime, so I'm trying once again without
# $USER and $PASSWD to give the get_basic_credentials routine another
# chance to set $USER and $PASSWD.

sub mirror {
    my($self,$url,$aslocal) = @@_;
    my $result = $self->SUPER::mirror($url,$aslocal);
    if ($result->code == 407) {
        undef $USER;
        undef $PASSWD;
        $result = $self->SUPER::mirror($url,$aslocal);
    }
    $result;
}

package CPAN::FTP;
use strict;

#-> sub CPAN::FTP::ftp_statistics
# if they want to rewrite, they need to pass in a filehandle
sub _ftp_statistics {
    my($self,$fh) = @@_;
    my $locktype = $fh ? LOCK_EX : LOCK_SH;
    $fh ||= FileHandle->new;
    my $file = File::Spec->catfile($CPAN::Config->{cpan_home},"FTPstats.yml");
    open $fh, "+>>$file" or $CPAN::Frontend->mydie("Could not open '$file': $!");
    my $sleep = 1;
    my $waitstart;
    while (!CPAN::_flock($fh, $locktype|LOCK_NB)) {
        $waitstart ||= localtime();
        if ($sleep>3) {
            $CPAN::Frontend->mywarn("Waiting for a read lock on '$file' (since $waitstart)\n");
        }
        $CPAN::Frontend->mysleep($sleep);
        if ($sleep <= 3) {
            $sleep+=0.33;
        } elsif ($sleep <=6) {
            $sleep+=0.11;
        }
    }
    my $stats = eval { CPAN->_yaml_loadfile($file); };
    if ($@@) {
        if (ref $@@) {
            if (ref $@@ eq "CPAN::Exception::yaml_not_installed") {
                $CPAN::Frontend->myprint("Warning (usually harmless): $@@");
                return;
            } elsif (ref $@@ eq "CPAN::Exception::yaml_process_error") {
                $CPAN::Frontend->mydie($@@);
            }
        } else {
            $CPAN::Frontend->mydie($@@);
        }
    }
    return $stats->[0];
}

#-> sub CPAN::FTP::_mytime
sub _mytime () {
    if (CPAN->has_inst("Time::HiRes")) {
        return Time::HiRes::time();
    } else {
        return time;
    }
}

#-> sub CPAN::FTP::_new_stats
sub _new_stats {
    my($self,$file) = @@_;
    my $ret = {
               file => $file,
               attempts => [],
               start => _mytime,
              };
    $ret;
}

#-> sub CPAN::FTP::_add_to_statistics
sub _add_to_statistics {
    my($self,$stats) = @@_;
    my $yaml_module = CPAN::_yaml_module;
    $self->debug("yaml_module[$yaml_module]") if $CPAN::DEBUG;
    if ($CPAN::META->has_inst($yaml_module)) {
        $stats->{thesiteurl} = $ThesiteURL;
        if (CPAN->has_inst("Time::HiRes")) {
            $stats->{end} = Time::HiRes::time();
        } else {
            $stats->{end} = time;
        }
        my $fh = FileHandle->new;
        my $time = time;
        my $sdebug = 0;
        my @@debug;
        @@debug = $time if $sdebug;
        my $fullstats = $self->_ftp_statistics($fh);
        close $fh;
        $fullstats->{history} ||= [];
        push @@debug, scalar @@{$fullstats->{history}} if $sdebug;
        push @@debug, time if $sdebug;
        push @@{$fullstats->{history}}, $stats;
        # arbitrary hardcoded constants until somebody demands to have
        # them settable; YAML.pm 0.62 is unacceptably slow with 999;
        # YAML::Syck 0.82 has no noticable performance problem with 999;
        while (
               @@{$fullstats->{history}} > 99
               || $time - $fullstats->{history}[0]{start} > 14*86400
              ) {
            shift @@{$fullstats->{history}}
        }
        push @@debug, scalar @@{$fullstats->{history}} if $sdebug;
        push @@debug, time if $sdebug;
        push @@debug, scalar localtime($fullstats->{history}[0]{start}) if $sdebug;
        # need no eval because if this fails, it is serious
        my $sfile = File::Spec->catfile($CPAN::Config->{cpan_home},"FTPstats.yml");
        CPAN->_yaml_dumpfile("$sfile.$$",$fullstats);
        if ( $sdebug ) {
            local $CPAN::DEBUG = 512; # FTP
            push @@debug, time;
            CPAN->debug(sprintf("DEBUG history: before_read[%d]before[%d]at[%d]".
                                "after[%d]at[%d]oldest[%s]dumped backat[%d]",
                                @@debug,
                               ));
        }
        # Win32 cannot rename a file to an existing filename
        unlink($sfile) if ($^O eq 'MSWin32');
        rename "$sfile.$$", $sfile
            or $CPAN::Frontend->mydie("Could not rename '$sfile.$$' to '$sfile': $!\n");
    }
}

# if file is CHECKSUMS, suggest the place where we got the file to be
# checked from, maybe only for young files?
#-> sub CPAN::FTP::_recommend_url_for
sub _recommend_url_for {
    my($self, $file) = @@_;
    my $urllist = $self->_get_urllist;
    if ($file =~ s|/CHECKSUMS(.gz)?$||) {
        my $fullstats = $self->_ftp_statistics();
        my $history = $fullstats->{history} || [];
        while (my $last = pop @@$history) {
            last if $last->{end} - time > 3600; # only young results are interesting
            next unless $last->{file}; # dirname of nothing dies!
            next unless $file eq File::Basename::dirname($last->{file});
            return $last->{thesiteurl};
        }
    }
    if ($CPAN::Config->{randomize_urllist}
        &&
        rand(1) < $CPAN::Config->{randomize_urllist}
       ) {
        $urllist->[int rand scalar @@$urllist];
    } else {
        return ();
    }
}

#-> sub CPAN::FTP::_get_urllist
sub _get_urllist {
    my($self) = @@_;
    $CPAN::Config->{urllist} ||= [];
    unless (ref $CPAN::Config->{urllist} eq 'ARRAY') {
        $CPAN::Frontend->mywarn("Malformed urllist; ignoring.  Configuration file corrupt?\n");
        $CPAN::Config->{urllist} = [];
    }
    my @@urllist = grep { defined $_ and length $_ } @@{$CPAN::Config->{urllist}};
    for my $u (@@urllist) {
        CPAN->debug("u[$u]") if $CPAN::DEBUG;
        if (UNIVERSAL::can($u,"text")) {
            $u->{TEXT} .= "/" unless substr($u->{TEXT},-1) eq "/";
        } else {
            $u .= "/" unless substr($u,-1) eq "/";
            $u = CPAN::URL->new(TEXT => $u, FROM => "USER");
        }
    }
    \@@urllist;
}

#-> sub CPAN::FTP::ftp_get ;
sub ftp_get {
    my($class,$host,$dir,$file,$target) = @@_;
    $class->debug(
                  qq[Going to fetch file [$file] from dir [$dir]
	on host [$host] as local [$target]\n]
                 ) if $CPAN::DEBUG;
    my $ftp = Net::FTP->new($host);
    unless ($ftp) {
        $CPAN::Frontend->mywarn("  Could not connect to host '$host' with Net::FTP\n");
        return;
    }
    return 0 unless defined $ftp;
    $ftp->debug(1) if $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG;
    $class->debug(qq[Going to login("anonymous","$Config::Config{cf_email}")]);
    unless ( $ftp->login("anonymous",$Config::Config{'cf_email'}) ) {
        my $msg = $ftp->message;
        $CPAN::Frontend->mywarn("  Couldn't login on $host: $msg");
        return;
    }
    unless ( $ftp->cwd($dir) ) {
        my $msg = $ftp->message;
        $CPAN::Frontend->mywarn("  Couldn't cwd $dir: $msg");
        return;
    }
    $ftp->binary;
    $class->debug(qq[Going to ->get("$file","$target")\n]) if $CPAN::DEBUG;
    unless ( $ftp->get($file,$target) ) {
        my $msg = $ftp->message;
        $CPAN::Frontend->mywarn("  Couldn't fetch $file from $host: $msg");
        return;
    }
    $ftp->quit; # it's ok if this fails
    return 1;
}

# If more accuracy is wanted/needed, Chris Leach sent me this patch...

 # > *** /install/perl/live/lib/CPAN.pm-	Wed Sep 24 13:08:48 1997
 # > --- /tmp/cp	Wed Sep 24 13:26:40 1997
 # > ***************
 # > *** 1562,1567 ****
 # > --- 1562,1580 ----
 # >       return 1 if substr($url,0,4) eq "file";
 # >       return 1 unless $url =~ m|://([^/]+)|;
 # >       my $host = $1;
 # > +     my $proxy = $CPAN::Config->{'http_proxy'} || $ENV{'http_proxy'};
 # > +     if ($proxy) {
 # > +         $proxy =~ m|://([^/:]+)|;
 # > +         $proxy = $1;
 # > +         my $noproxy = $CPAN::Config->{'no_proxy'} || $ENV{'no_proxy'};
 # > +         if ($noproxy) {
 # > +             if ($host !~ /$noproxy$/) {
 # > +                 $host = $proxy;
 # > +             }
 # > +         } else {
 # > +             $host = $proxy;
 # > +         }
 # > +     }
 # >       require Net::Ping;
 # >       return 1 unless $Net::Ping::VERSION >= 2;
 # >       my $p;


#-> sub CPAN::FTP::localize ;
sub localize {
    my($self,$file,$aslocal,$force) = @@_;
    $force ||= 0;
    Carp::croak "Usage: ->localize(cpan_file,as_local_file[,$force])"
        unless defined $aslocal;
    $self->debug("file[$file] aslocal[$aslocal] force[$force]")
        if $CPAN::DEBUG;

    if ($^O eq 'MacOS') {
        # Comment by AK on 2000-09-03: Uniq short filenames would be
        # available in CHECKSUMS file
        my($name, $path) = File::Basename::fileparse($aslocal, '');
        if (length($name) > 31) {
            $name =~ s/(
                        \.(
                           readme(\.(gz|Z))? |
                           (tar\.)?(gz|Z) |
                           tgz |
                           zip |
                           pm\.(gz|Z)
                          )
                       )$//x;
            my $suf = $1;
            my $size = 31 - length($suf);
            while (length($name) > $size) {
                chop $name;
            }
            $name .= $suf;
            $aslocal = File::Spec->catfile($path, $name);
        }
    }

    if (-f $aslocal && -r _ && !($force & 1)) {
        my $size;
        if ($size = -s $aslocal) {
            $self->debug("aslocal[$aslocal]size[$size]") if $CPAN::DEBUG;
            return $aslocal;
        } else {
            # empty file from a previous unsuccessful attempt to download it
            unlink $aslocal or
                $CPAN::Frontend->mydie("Found a zero-length '$aslocal' that I ".
                                       "could not remove.");
        }
    }
    my($maybe_restore) = 0;
    if (-f $aslocal) {
        rename $aslocal, "$aslocal.bak$$";
        $maybe_restore++;
    }

    my($aslocal_dir) = File::Basename::dirname($aslocal);
    $self->mymkpath($aslocal_dir); # too early for file URLs / RT #28438
    # Inheritance is not easier to manage than a few if/else branches
    if ($CPAN::META->has_usable('LWP::UserAgent')) {
        unless ($Ua) {
            CPAN::LWP::UserAgent->config;
            eval {$Ua = CPAN::LWP::UserAgent->new;}; # Why is has_usable still not fit enough?
            if ($@@) {
                $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@\n")
                    if $CPAN::DEBUG;
            } else {
                my($var);
                $Ua->proxy('ftp',  $var)
                    if $var = $CPAN::Config->{ftp_proxy} || $ENV{ftp_proxy};
                $Ua->proxy('http', $var)
                    if $var = $CPAN::Config->{http_proxy} || $ENV{http_proxy};
                $Ua->no_proxy($var)
                    if $var = $CPAN::Config->{no_proxy} || $ENV{no_proxy};
            }
        }
    }
    for my $prx (qw(ftp_proxy http_proxy no_proxy)) {
        $ENV{$prx} = $CPAN::Config->{$prx} if $CPAN::Config->{$prx};
    }

    # Try the list of urls for each single object. We keep a record
    # where we did get a file from
    my(@@reordered,$last);
    my $ccurllist = $self->_get_urllist;
    $last = $#$ccurllist;
    if ($force & 2) { # local cpans probably out of date, don't reorder
        @@reordered = (0..$last);
    } else {
        @@reordered =
            sort {
                (substr($ccurllist->[$b],0,4) eq "file")
                    <=>
                (substr($ccurllist->[$a],0,4) eq "file")
                    or
                defined($ThesiteURL)
                    and
                ($ccurllist->[$b] eq $ThesiteURL)
                    <=>
                ($ccurllist->[$a] eq $ThesiteURL)
            } 0..$last;
    }
    my(@@levels);
    $Themethod ||= "";
    $self->debug("Themethod[$Themethod]reordered[@@reordered]") if $CPAN::DEBUG;
    my @@all_levels = (
                      ["dleasy",   "file"],
                      ["dleasy"],
                      ["dlhard"],
                      ["dlhardest"],
                      ["dleasy",   "http","defaultsites"],
                      ["dlhard",   "http","defaultsites"],
                      ["dleasy",   "ftp", "defaultsites"],
                      ["dlhard",   "ftp", "defaultsites"],
                      ["dlhardest","",    "defaultsites"],
                     );
    if ($Themethod) {
        @@levels = grep {$_->[0] eq $Themethod} @@all_levels;
        push @@levels, grep {$_->[0] ne $Themethod} @@all_levels;
    } else {
        @@levels = @@all_levels;
    }
    @@levels = qw/dleasy/ if $^O eq 'MacOS';
    my($levelno);
    local $ENV{FTP_PASSIVE} =
        exists $CPAN::Config->{ftp_passive} ?
        $CPAN::Config->{ftp_passive} : 1;
    my $ret;
    my $stats = $self->_new_stats($file);
  LEVEL: for $levelno (0..$#levels) {
        my $level_tuple = $levels[$levelno];
        my($level,$scheme,$sitetag) = @@$level_tuple;
        my $defaultsites = $sitetag && $sitetag eq "defaultsites";
        my @@urllist;
        if ($defaultsites) {
            unless (defined $connect_to_internet_ok) {
                $CPAN::Frontend->myprint(sprintf qq{
I would like to connect to one of the following sites to get '%s':

%s
},
                                         $file,
                                         join("",map { " ".$_->text."\n" } @@CPAN::Defaultsites),
                                        );
                my $answer = CPAN::Shell::colorable_makemaker_prompt("Is it OK to try to connect to the Internet?", "yes");
                if ($answer =~ /^y/i) {
                    $connect_to_internet_ok = 1;
                } else {
                    $connect_to_internet_ok = 0;
                }
            }
            if ($connect_to_internet_ok) {
                @@urllist = @@CPAN::Defaultsites;
            } else {
                @@urllist = ();
            }
        } else {
            my @@host_seq = $level =~ /dleasy/ ?
                @@reordered : 0..$last;  # reordered has file and $Thesiteurl first
            @@urllist = map { $ccurllist->[$_] } @@host_seq;
        }
        $self->debug("synth. urllist[@@urllist]") if $CPAN::DEBUG;
        my $aslocal_tempfile = $aslocal . ".tmp" . $$;
        if (my $recommend = $self->_recommend_url_for($file)) {
            @@urllist = grep { $_ ne $recommend } @@urllist;
            unshift @@urllist, $recommend;
        }
        $self->debug("synth. urllist[@@urllist]") if $CPAN::DEBUG;
        $ret = $self->hostdlxxx($level,$scheme,\@@urllist,$file,$aslocal_tempfile,$stats);
        if ($ret) {
            CPAN->debug("ret[$ret]aslocal[$aslocal]") if $CPAN::DEBUG;
            if ($ret eq $aslocal_tempfile) {
                # if we got it exactly as we asked for, only then we
                # want to rename
                rename $aslocal_tempfile, $aslocal
                    or $CPAN::Frontend->mydie("Error while trying to rename ".
                                              "'$ret' to '$aslocal': $!");
                $ret = $aslocal;
            }
            $Themethod = $level;
            my $now = time;
            # utime $now, $now, $aslocal; # too bad, if we do that, we
                                          # might alter a local mirror
            $self->debug("level[$level]") if $CPAN::DEBUG;
            last LEVEL;
        } else {
            unlink $aslocal_tempfile;
            last if $CPAN::Signal; # need to cleanup
        }
    }
    if ($ret) {
        $stats->{filesize} = -s $ret;
    }
    $self->debug("before _add_to_statistics") if $CPAN::DEBUG;
    $self->_add_to_statistics($stats);
    $self->debug("after _add_to_statistics") if $CPAN::DEBUG;
    if ($ret) {
        unlink "$aslocal.bak$$";
        return $ret;
    }
    unless ($CPAN::Signal) {
        my(@@mess);
        local $" = " ";
        if (@@{$CPAN::Config->{urllist}}) {
            push @@mess,
                qq{Please check, if the URLs I found in your configuration file \(}.
                    join(", ", @@{$CPAN::Config->{urllist}}).
                        qq{\) are valid.};
        } else {
            push @@mess, qq{Your urllist is empty!};
        }
        push @@mess, qq{The urllist can be edited.},
            qq{E.g. with 'o conf urllist push ftp://myurl/'};
        $CPAN::Frontend->mywarn(Text::Wrap::wrap("","","@@mess"). "\n\n");
        $CPAN::Frontend->mywarn("Could not fetch $file\n");
        $CPAN::Frontend->mysleep(2);
    }
    if ($maybe_restore) {
        rename "$aslocal.bak$$", $aslocal;
        $CPAN::Frontend->myprint("Trying to get away with old file:\n" .
                                 $self->ls($aslocal));
        return $aslocal;
    }
    return;
}

sub mymkpath {
    my($self, $aslocal_dir) = @@_;
    File::Path::mkpath($aslocal_dir);
    $CPAN::Frontend->mywarn(qq{Warning: You are not allowed to write into }.
                            qq{directory "$aslocal_dir".
    I\'ll continue, but if you encounter problems, they may be due
    to insufficient permissions.\n}) unless -w $aslocal_dir;
}

sub hostdlxxx {
    my $self = shift;
    my $level = shift;
    my $scheme = shift;
    my $h = shift;
    $h = [ grep /^\Q$scheme\E:/, @@$h ] if $scheme;
    my $method = "host$level";
    $self->$method($h, @@_);
}

sub _set_attempt {
    my($self,$stats,$method,$url) = @@_;
    push @@{$stats->{attempts}}, {
                                 method => $method,
                                 start => _mytime,
                                 url => $url,
                                };
}

# package CPAN::FTP;
sub hostdleasy {
    my($self,$host_seq,$file,$aslocal,$stats) = @@_;
    my($ro_url);
  HOSTEASY: for $ro_url (@@$host_seq) {
        $self->_set_attempt($stats,"dleasy",$ro_url);
        my $url .= "$ro_url$file";
        $self->debug("localizing perlish[$url]") if $CPAN::DEBUG;
        if ($url =~ /^file:/) {
            my $l;
            if ($CPAN::META->has_inst('URI::URL')) {
                my $u =  URI::URL->new($url);
                $l = $u->path;
            } else { # works only on Unix, is poorly constructed, but
                # hopefully better than nothing.
                # RFC 1738 says fileurl BNF is
                # fileurl = "file://" [ host | "localhost" ] "/" fpath
                # Thanks to "Mark D. Baushke" <mdb@@cisco.com> for
                # the code
                ($l = $url) =~ s|^file://[^/]*/|/|; # discard the host part
                $l =~ s|^file:||;                   # assume they
                                                    # meant
                                                    # file://localhost
                $l =~ s|^/||s
                    if ! -f $l && $l =~ m|^/\w:|;   # e.g. /P:
            }
            $self->debug("local file[$l]") if $CPAN::DEBUG;
            if ( -f $l && -r _) {
                $ThesiteURL = $ro_url;
                return $l;
            }
            if ($l =~ /(.+)\.gz$/) {
                my $ungz = $1;
                if ( -f $ungz && -r _) {
                    $ThesiteURL = $ro_url;
                    return $ungz;
                }
            }
            # Maybe mirror has compressed it?
            if (-f "$l.gz") {
                $self->debug("found compressed $l.gz") if $CPAN::DEBUG;
                eval { CPAN::Tarzip->new("$l.gz")->gunzip($aslocal) };
                if ( -f $aslocal) {
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                }
            }
            $CPAN::Frontend->mywarn("Could not find '$l'\n");
        }
        $self->debug("it was not a file URL") if $CPAN::DEBUG;
        if ($CPAN::META->has_usable('LWP')) {
            $CPAN::Frontend->myprint("Fetching with LWP:
  $url
");
            unless ($Ua) {
                CPAN::LWP::UserAgent->config;
                eval { $Ua = CPAN::LWP::UserAgent->new; };
                if ($@@) {
                    $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@\n");
                }
            }
            my $res = $Ua->mirror($url, $aslocal);
            if ($res->is_success) {
                $ThesiteURL = $ro_url;
                my $now = time;
                utime $now, $now, $aslocal; # download time is more
                                            # important than upload
                                            # time
                return $aslocal;
            } elsif ($url !~ /\.gz(?!\n)\Z/) {
                my $gzurl = "$url.gz";
                $CPAN::Frontend->myprint("Fetching with LWP:
  $gzurl
");
                $res = $Ua->mirror($gzurl, "$aslocal.gz");
                if ($res->is_success) {
                    if (eval {CPAN::Tarzip->new("$aslocal.gz")->gunzip($aslocal)}) {
                        $ThesiteURL = $ro_url;
                        return $aslocal;
                    }
                }
            } else {
                $CPAN::Frontend->myprint(sprintf(
                                                 "LWP failed with code[%s] message[%s]\n",
                                                 $res->code,
                                                 $res->message,
                                                ));
                # Alan Burlison informed me that in firewall environments
                # Net::FTP can still succeed where LWP fails. So we do not
                # skip Net::FTP anymore when LWP is available.
            }
        } else {
            $CPAN::Frontend->mywarn("  LWP not available\n");
        }
        return if $CPAN::Signal;
        if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
            # that's the nice and easy way thanks to Graham
            $self->debug("recognized ftp") if $CPAN::DEBUG;
            my($host,$dir,$getfile) = ($1,$2,$3);
            if ($CPAN::META->has_usable('Net::FTP')) {
                $dir =~ s|/+|/|g;
                $CPAN::Frontend->myprint("Fetching with Net::FTP:
  $url
");
                $self->debug("getfile[$getfile]dir[$dir]host[$host]" .
                             "aslocal[$aslocal]") if $CPAN::DEBUG;
                if (CPAN::FTP->ftp_get($host,$dir,$getfile,$aslocal)) {
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                }
                if ($aslocal !~ /\.gz(?!\n)\Z/) {
                    my $gz = "$aslocal.gz";
                    $CPAN::Frontend->myprint("Fetching with Net::FTP
  $url.gz
");
                    if (CPAN::FTP->ftp_get($host,
                                           $dir,
                                           "$getfile.gz",
                                           $gz) &&
                        eval{CPAN::Tarzip->new($gz)->gunzip($aslocal)}
                    ) {
                        $ThesiteURL = $ro_url;
                        return $aslocal;
                    }
                }
                # next HOSTEASY;
            } else {
                CPAN->debug("Net::FTP does not count as usable atm") if $CPAN::DEBUG;
            }
        }
        if (
            UNIVERSAL::can($ro_url,"text")
            and
            $ro_url->{FROM} eq "USER"
           ) {
            ##address #17973: default URLs should not try to override
            ##user-defined URLs just because LWP is not available
            my $ret = $self->hostdlhard([$ro_url],$file,$aslocal,$stats);
            return $ret if $ret;
        }
        return if $CPAN::Signal;
    }
}

# package CPAN::FTP;
sub hostdlhard {
    my($self,$host_seq,$file,$aslocal,$stats) = @@_;

    # Came back if Net::FTP couldn't establish connection (or
    # failed otherwise) Maybe they are behind a firewall, but they
    # gave us a socksified (or other) ftp program...

    my($ro_url);
    my($devnull) = $CPAN::Config->{devnull} || "";
    # < /dev/null ";
    my($aslocal_dir) = File::Basename::dirname($aslocal);
    File::Path::mkpath($aslocal_dir);
  HOSTHARD: for $ro_url (@@$host_seq) {
        $self->_set_attempt($stats,"dlhard",$ro_url);
        my $url = "$ro_url$file";
        my($proto,$host,$dir,$getfile);

        # Courtesy Mark Conty mark_conty@@cargill.com change from
        # if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
        # to
        if ($url =~ m|^([^:]+)://(.*?)/(.*)/(.*)|) {
            # proto not yet used
            ($proto,$host,$dir,$getfile) = ($1,$2,$3,$4);
        } else {
            next HOSTHARD; # who said, we could ftp anything except ftp?
        }
        next HOSTHARD if $proto eq "file"; # file URLs would have had
                                           # success above. Likely a bogus URL

        $self->debug("localizing funkyftpwise[$url]") if $CPAN::DEBUG;

        # Try the most capable first and leave ncftp* for last as it only
        # does FTP.
      DLPRG: for my $f (qw(curl wget lynx ncftpget ncftp)) {
            my $funkyftp = CPAN::HandleConfig->safe_quote($CPAN::Config->{$f});
            next unless defined $funkyftp;
            next if $funkyftp =~ /^\s*$/;

            my($asl_ungz, $asl_gz);
            ($asl_ungz = $aslocal) =~ s/\.gz//;
                $asl_gz = "$asl_ungz.gz";

            my($src_switch) = "";
            my($chdir) = "";
            my($stdout_redir) = " > $asl_ungz";
            if ($f eq "lynx") {
                $src_switch = " -source";
            } elsif ($f eq "ncftp") {
                $src_switch = " -c";
            } elsif ($f eq "wget") {
                $src_switch = " -O $asl_ungz";
                $stdout_redir = "";
            } elsif ($f eq 'curl') {
                $src_switch = ' -L -f -s -S --netrc-optional';
            }

            if ($f eq "ncftpget") {
                $chdir = "cd $aslocal_dir && ";
                $stdout_redir = "";
            }
            $CPAN::Frontend->myprint(
                                     qq[
Trying with "$funkyftp$src_switch" to get
    $url
]);
            my($system) =
                "$chdir$funkyftp$src_switch \"$url\" $devnull$stdout_redir";
            $self->debug("system[$system]") if $CPAN::DEBUG;
            my($wstatus) = system($system);
            if ($f eq "lynx") {
                # lynx returns 0 when it fails somewhere
                if (-s $asl_ungz) {
                    my $content = do { local *FH;
                                       open FH, $asl_ungz or die;
                                       local $/;
                                       <FH> };
                    if ($content =~ /^<.*(<title>[45]|Error [45])/si) {
                        $CPAN::Frontend->mywarn(qq{
No success, the file that lynx has downloaded looks like an error message:
$content
});
                        $CPAN::Frontend->mysleep(1);
                        next DLPRG;
                    }
                } else {
                    $CPAN::Frontend->myprint(qq{
No success, the file that lynx has downloaded is an empty file.
});
                    next DLPRG;
                }
            }
            if ($wstatus == 0) {
                if (-s $aslocal) {
                    # Looks good
                } elsif ($asl_ungz ne $aslocal) {
                    # test gzip integrity
                    if (eval{CPAN::Tarzip->new($asl_ungz)->gtest}) {
                        # e.g. foo.tar is gzipped --> foo.tar.gz
                        rename $asl_ungz, $aslocal;
                    } else {
                        eval{CPAN::Tarzip->new($asl_gz)->gzip($asl_ungz)};
                    }
                }
                $ThesiteURL = $ro_url;
                return $aslocal;
            } elsif ($url !~ /\.gz(?!\n)\Z/) {
                unlink $asl_ungz if
                    -f $asl_ungz && -s _ == 0;
                my $gz = "$aslocal.gz";
                my $gzurl = "$url.gz";
                $CPAN::Frontend->myprint(
                                        qq[
    Trying with "$funkyftp$src_switch" to get
    $url.gz
    ]);
                my($system) = "$funkyftp$src_switch \"$url.gz\" $devnull > $asl_gz";
                $self->debug("system[$system]") if $CPAN::DEBUG;
                my($wstatus);
                if (($wstatus = system($system)) == 0
                    &&
                    -s $asl_gz
                ) {
                    # test gzip integrity
                    my $ct = eval{CPAN::Tarzip->new($asl_gz)};
                    if ($ct && $ct->gtest) {
                        $ct->gunzip($aslocal);
                    } else {
                        # somebody uncompressed file for us?
                        rename $asl_ungz, $aslocal;
                    }
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                } else {
                    unlink $asl_gz if -f $asl_gz;
                }
            } else {
                my $estatus = $wstatus >> 8;
                my $size = -f $aslocal ?
                    ", left\n$aslocal with size ".-s _ :
                    "\nWarning: expected file [$aslocal] doesn't exist";
                $CPAN::Frontend->myprint(qq{
    System call "$system"
    returned status $estatus (wstat $wstatus)$size
    });
            }
            return if $CPAN::Signal;
        } # transfer programs
    } # host
}

# package CPAN::FTP;
sub hostdlhardest {
    my($self,$host_seq,$file,$aslocal,$stats) = @@_;

    return unless @@$host_seq;
    my($ro_url);
    my($aslocal_dir) = File::Basename::dirname($aslocal);
    File::Path::mkpath($aslocal_dir);
    my $ftpbin = $CPAN::Config->{ftp};
    unless ($ftpbin && length $ftpbin && MM->maybe_command($ftpbin)) {
        $CPAN::Frontend->myprint("No external ftp command available\n\n");
        return;
    }
    $CPAN::Frontend->mywarn(qq{
As a last ressort we now switch to the external ftp command '$ftpbin'
to get '$aslocal'.

Doing so often leads to problems that are hard to diagnose.

If you're victim of such problems, please consider unsetting the ftp
config variable with

    o conf ftp ""
    o conf commit

});
    $CPAN::Frontend->mysleep(2);
  HOSTHARDEST: for $ro_url (@@$host_seq) {
        $self->_set_attempt($stats,"dlhardest",$ro_url);
        my $url = "$ro_url$file";
        $self->debug("localizing ftpwise[$url]") if $CPAN::DEBUG;
        unless ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
            next;
        }
        my($host,$dir,$getfile) = ($1,$2,$3);
        my $timestamp = 0;
        my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,
            $ctime,$blksize,$blocks) = stat($aslocal);
        $timestamp = $mtime ||= 0;
        my($netrc) = CPAN::FTP::netrc->new;
        my($netrcfile) = $netrc->netrc;
        my($verbose) = $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG ? " -v" : "";
        my $targetfile = File::Basename::basename($aslocal);
        my(@@dialog);
        push(
             @@dialog,
             "lcd $aslocal_dir",
             "cd /",
             map("cd $_", split /\//, $dir), # RFC 1738
             "bin",
             "get $getfile $targetfile",
             "quit"
        );
        if (! $netrcfile) {
            CPAN->debug("No ~/.netrc file found") if $CPAN::DEBUG;
        } elsif ($netrc->hasdefault || $netrc->contains($host)) {
            CPAN->debug(sprintf("hasdef[%d]cont($host)[%d]",
                                $netrc->hasdefault,
                                $netrc->contains($host))) if $CPAN::DEBUG;
            if ($netrc->protected) {
                my $dialog = join "", map { "    $_\n" } @@dialog;
                my $netrc_explain;
                if ($netrc->contains($host)) {
                    $netrc_explain = "Relying that your .netrc entry for '$host' ".
                        "manages the login";
                } else {
                    $netrc_explain = "Relying that your default .netrc entry ".
                        "manages the login";
                }
                $CPAN::Frontend->myprint(qq{
  Trying with external ftp to get
    $url
  $netrc_explain
  Going to send the dialog
$dialog
}
                );
                $self->talk_ftp("$ftpbin$verbose $host",
                                @@dialog);
                ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
                    $atime,$mtime,$ctime,$blksize,$blocks) = stat($aslocal);
                $mtime ||= 0;
                if ($mtime > $timestamp) {
                    $CPAN::Frontend->myprint("GOT $aslocal\n");
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                } else {
                    $CPAN::Frontend->myprint("Hmm... Still failed!\n");
                }
                    return if $CPAN::Signal;
            } else {
                $CPAN::Frontend->mywarn(qq{Your $netrcfile is not }.
                                        qq{correctly protected.\n});
            }
        } else {
            $CPAN::Frontend->mywarn("Your ~/.netrc neither contains $host
  nor does it have a default entry\n");
        }

        # OK, they don't have a valid ~/.netrc. Use 'ftp -n'
        # then and login manually to host, using e-mail as
        # password.
        $CPAN::Frontend->myprint(qq{Issuing "$ftpbin$verbose -n"\n});
        unshift(
                @@dialog,
                "open $host",
                "user anonymous $Config::Config{'cf_email'}"
        );
        my $dialog = join "", map { "    $_\n" } @@dialog;
        $CPAN::Frontend->myprint(qq{
  Trying with external ftp to get
    $url
  Going to send the dialog
$dialog
}
        );
        $self->talk_ftp("$ftpbin$verbose -n", @@dialog);
        ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
            $atime,$mtime,$ctime,$blksize,$blocks) = stat($aslocal);
        $mtime ||= 0;
        if ($mtime > $timestamp) {
            $CPAN::Frontend->myprint("GOT $aslocal\n");
            $ThesiteURL = $ro_url;
            return $aslocal;
        } else {
            $CPAN::Frontend->myprint("Bad luck... Still failed!\n");
        }
        return if $CPAN::Signal;
        $CPAN::Frontend->mywarn("Can't access URL $url.\n\n");
        $CPAN::Frontend->mysleep(2);
    } # host
}

# package CPAN::FTP;
sub talk_ftp {
    my($self,$command,@@dialog) = @@_;
    my $fh = FileHandle->new;
    $fh->open("|$command") or die "Couldn't open ftp: $!";
    foreach (@@dialog) { $fh->print("$_\n") }
    $fh->close; # Wait for process to complete
    my $wstatus = $?;
    my $estatus = $wstatus >> 8;
    $CPAN::Frontend->myprint(qq{
Subprocess "|$command"
  returned status $estatus (wstat $wstatus)
}) if $wstatus;
}

# find2perl needs modularization, too, all the following is stolen
# from there
# CPAN::FTP::ls
sub ls {
    my($self,$name) = @@_;
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$sizemm,
     $atime,$mtime,$ctime,$blksize,$blocks) = lstat($name);

    my($perms,%user,%group);
    my $pname = $name;

    if ($blocks) {
        $blocks = int(($blocks + 1) / 2);
    }
    else {
        $blocks = int(($sizemm + 1023) / 1024);
    }

    if    (-f _) { $perms = '-'; }
    elsif (-d _) { $perms = 'd'; }
    elsif (-c _) { $perms = 'c'; $sizemm = &sizemm; }
    elsif (-b _) { $perms = 'b'; $sizemm = &sizemm; }
    elsif (-p _) { $perms = 'p'; }
    elsif (-S _) { $perms = 's'; }
    else         { $perms = 'l'; $pname .= ' -> ' . readlink($_); }

    my(@@rwx) = ('---','--x','-w-','-wx','r--','r-x','rw-','rwx');
    my(@@moname) = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
    my $tmpmode = $mode;
    my $tmp = $rwx[$tmpmode & 7];
    $tmpmode >>= 3;
    $tmp = $rwx[$tmpmode & 7] . $tmp;
    $tmpmode >>= 3;
    $tmp = $rwx[$tmpmode & 7] . $tmp;
    substr($tmp,2,1) =~ tr/-x/Ss/ if -u _;
    substr($tmp,5,1) =~ tr/-x/Ss/ if -g _;
    substr($tmp,8,1) =~ tr/-x/Tt/ if -k _;
    $perms .= $tmp;

    my $user = $user{$uid} || $uid;   # too lazy to implement lookup
    my $group = $group{$gid} || $gid;

    my($sec,$min,$hour,$mday,$mon,$year) = localtime($mtime);
    my($timeyear);
    my($moname) = $moname[$mon];
    if (-M _ > 365.25 / 2) {
        $timeyear = $year + 1900;
    }
    else {
        $timeyear = sprintf("%02d:%02d", $hour, $min);
    }

    sprintf "%5lu %4ld %-10s %2d %-8s %-8s %8s %s %2d %5s %s\n",
             $ino,
                  $blocks,
                       $perms,
                             $nlink,
                                 $user,
                                      $group,
                                           $sizemm,
                                               $moname,
                                                  $mday,
                                                      $timeyear,
                                                          $pname;
}

package CPAN::FTP::netrc;
use strict;

# package CPAN::FTP::netrc;
sub new {
    my($class) = @@_;
    my $home = CPAN::HandleConfig::home;
    my $file = File::Spec->catfile($home,".netrc");

    my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
       $atime,$mtime,$ctime,$blksize,$blocks)
        = stat($file);
    $mode ||= 0;
    my $protected = 0;

    my($fh,@@machines,$hasdefault);
    $hasdefault = 0;
    $fh = FileHandle->new or die "Could not create a filehandle";

    if($fh->open($file)) {
        $protected = ($mode & 077) == 0;
        local($/) = "";
      NETRC: while (<$fh>) {
            my(@@tokens) = split " ", $_;
          TOKEN: while (@@tokens) {
                my($t) = shift @@tokens;
                if ($t eq "default") {
                    $hasdefault++;
                    last NETRC;
                }
                last TOKEN if $t eq "macdef";
                if ($t eq "machine") {
                    push @@machines, shift @@tokens;
                }
            }
        }
    } else {
        $file = $hasdefault = $protected = "";
    }

    bless {
        'mach' => [@@machines],
        'netrc' => $file,
        'hasdefault' => $hasdefault,
        'protected' => $protected,
    }, $class;
}

# CPAN::FTP::netrc::hasdefault;
sub hasdefault { shift->{'hasdefault'} }
sub netrc      { shift->{'netrc'}      }
sub protected  { shift->{'protected'}  }
sub contains {
    my($self,$mach) = @@_;
    for ( @@{$self->{'mach'}} ) {
        return 1 if $_ eq $mach;
    }
    return 0;
}

package CPAN::Complete;
use strict;

sub gnu_cpl {
    my($text, $line, $start, $end) = @@_;
    my(@@perlret) = cpl($text, $line, $start);
    # find longest common match. Can anybody show me how to peruse
    # T::R::Gnu to have this done automatically? Seems expensive.
    return () unless @@perlret;
    my($newtext) = $text;
    for (my $i = length($text)+1;;$i++) {
        last unless length($perlret[0]) && length($perlret[0]) >= $i;
        my $try = substr($perlret[0],0,$i);
        my @@tries = grep {substr($_,0,$i) eq $try} @@perlret;
        # warn "try[$try]tries[@@tries]";
        if (@@tries == @@perlret) {
            $newtext = $try;
        } else {
            last;
        }
    }
    ($newtext,@@perlret);
}

#-> sub CPAN::Complete::cpl ;
sub cpl {
    my($word,$line,$pos) = @@_;
    $word ||= "";
    $line ||= "";
    $pos ||= 0;
    CPAN->debug("word [$word] line[$line] pos[$pos]") if $CPAN::DEBUG;
    $line =~ s/^\s*//;
    if ($line =~ s/^((?:notest|f?force)\s*)//) {
        $pos -= length($1);
    }
    my @@return;
    if ($pos == 0 || $line =~ /^(?:h(?:elp)?|\?)\s/) {
        @@return = grep /^\Q$word\E/, @@CPAN::Complete::COMMANDS;
    } elsif ( $line !~ /^[\!abcdghimorutl]/ ) {
        @@return = ();
    } elsif ($line =~ /^(a|ls)\s/) {
        @@return = cplx('CPAN::Author',uc($word));
    } elsif ($line =~ /^b\s/) {
        CPAN::Shell->local_bundles;
        @@return = cplx('CPAN::Bundle',$word);
    } elsif ($line =~ /^d\s/) {
        @@return = cplx('CPAN::Distribution',$word);
    } elsif ($line =~ m/^(
                          [mru]|make|clean|dump|get|test|install|readme|look|cvs_import|perldoc|recent
                         )\s/x ) {
        if ($word =~ /^Bundle::/) {
            CPAN::Shell->local_bundles;
        }
        @@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
    } elsif ($line =~ /^i\s/) {
        @@return = cpl_any($word);
    } elsif ($line =~ /^reload\s/) {
        @@return = cpl_reload($word,$line,$pos);
    } elsif ($line =~ /^o\s/) {
        @@return = cpl_option($word,$line,$pos);
    } elsif ($line =~ m/^\S+\s/ ) {
        # fallback for future commands and what we have forgotten above
        @@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
    } else {
        @@return = ();
    }
    return @@return;
}

#-> sub CPAN::Complete::cplx ;
sub cplx {
    my($class, $word) = @@_;
    if (CPAN::_sqlite_running) {
        $CPAN::SQLite->search($class, "^\Q$word\E");
    }
    sort grep /^\Q$word\E/, map { $_->id } $CPAN::META->all_objects($class);
}

#-> sub CPAN::Complete::cpl_any ;
sub cpl_any {
    my($word) = shift;
    return (
            cplx('CPAN::Author',$word),
            cplx('CPAN::Bundle',$word),
            cplx('CPAN::Distribution',$word),
            cplx('CPAN::Module',$word),
           );
}

#-> sub CPAN::Complete::cpl_reload ;
sub cpl_reload {
    my($word,$line,$pos) = @@_;
    $word ||= "";
    my(@@words) = split " ", $line;
    CPAN->debug("word[$word] line[$line] pos[$pos]") if $CPAN::DEBUG;
    my(@@ok) = qw(cpan index);
    return @@ok if @@words == 1;
    return grep /^\Q$word\E/, @@ok if @@words == 2 && $word;
}

#-> sub CPAN::Complete::cpl_option ;
sub cpl_option {
    my($word,$line,$pos) = @@_;
    $word ||= "";
    my(@@words) = split " ", $line;
    CPAN->debug("word[$word] line[$line] pos[$pos]") if $CPAN::DEBUG;
    my(@@ok) = qw(conf debug);
    return @@ok if @@words == 1;
    return grep /^\Q$word\E/, @@ok if @@words == 2 && length($word);
    if (0) {
    } elsif ($words[1] eq 'index') {
        return ();
    } elsif ($words[1] eq 'conf') {
        return CPAN::HandleConfig::cpl(@@_);
    } elsif ($words[1] eq 'debug') {
        return sort grep /^\Q$word\E/i,
            sort keys %CPAN::DEBUG, 'all';
    }
}

package CPAN::Index;
use strict;

#-> sub CPAN::Index::force_reload ;
sub force_reload {
    my($class) = @@_;
    $CPAN::Index::LAST_TIME = 0;
    $class->reload(1);
}

#-> sub CPAN::Index::reload ;
sub reload {
    my($self,$force) = @@_;
    my $time = time;

    # XXX check if a newer one is available. (We currently read it
    # from time to time)
    for ($CPAN::Config->{index_expire}) {
        $_ = 0.001 unless $_ && $_ > 0.001;
    }
    unless (1 || $CPAN::Have_warned->{readmetadatacache}++) {
        # debug here when CPAN doesn't seem to read the Metadata
        require Carp;
        Carp::cluck("META-PROTOCOL[$CPAN::META->{PROTOCOL}]");
    }
    unless ($CPAN::META->{PROTOCOL}) {
        $self->read_metadata_cache;
        $CPAN::META->{PROTOCOL} ||= "1.0";
    }
    if ( $CPAN::META->{PROTOCOL} < PROTOCOL  ) {
        # warn "Setting last_time to 0";
        $LAST_TIME = 0; # No warning necessary
    }
    if ($LAST_TIME + $CPAN::Config->{index_expire}*86400 > $time
        and ! $force) {
        # called too often
        # CPAN->debug("LAST_TIME[$LAST_TIME]index_expire[$CPAN::Config->{index_expire}]time[$time]");
    } elsif (0) {
        # IFF we are developing, it helps to wipe out the memory
        # between reloads, otherwise it is not what a user expects.
        undef $CPAN::META; # Neue Gruendlichkeit since v1.52(r1.274)
        $CPAN::META = CPAN->new;
    } else {
        my($debug,$t2);
        local $LAST_TIME = $time;
        local $CPAN::META->{PROTOCOL} = PROTOCOL;

        my $needshort = $^O eq "dos";

        $self->rd_authindex($self
                          ->reload_x(
                                     "authors/01mailrc.txt.gz",
                                     $needshort ?
                                     File::Spec->catfile('authors', '01mailrc.gz') :
                                     File::Spec->catfile('authors', '01mailrc.txt.gz'),
                                     $force));
        $t2 = time;
        $debug = "timing reading 01[".($t2 - $time)."]";
        $time = $t2;
        return if $CPAN::Signal; # this is sometimes lengthy
        $self->rd_modpacks($self
                         ->reload_x(
                                    "modules/02packages.details.txt.gz",
                                    $needshort ?
                                    File::Spec->catfile('modules', '02packag.gz') :
                                    File::Spec->catfile('modules', '02packages.details.txt.gz'),
                                    $force));
        $t2 = time;
        $debug .= "02[".($t2 - $time)."]";
        $time = $t2;
        return if $CPAN::Signal; # this is sometimes lengthy
        $self->rd_modlist($self
                        ->reload_x(
                                   "modules/03modlist.data.gz",
                                   $needshort ?
                                   File::Spec->catfile('modules', '03mlist.gz') :
                                   File::Spec->catfile('modules', '03modlist.data.gz'),
                                   $force));
        $self->write_metadata_cache;
        $t2 = time;
        $debug .= "03[".($t2 - $time)."]";
        $time = $t2;
        CPAN->debug($debug) if $CPAN::DEBUG;
    }
    if ($CPAN::Config->{build_dir_reuse}) {
        $self->reanimate_build_dir;
    }
    if (CPAN::_sqlite_running) {
        $CPAN::SQLite->reload(time => $time, force => $force)
            if not $LAST_TIME;
    }
    $LAST_TIME = $time;
    $CPAN::META->{PROTOCOL} = PROTOCOL;
}

#-> sub CPAN::Index::reanimate_build_dir ;
sub reanimate_build_dir {
    my($self) = @@_;
    unless ($CPAN::META->has_inst($CPAN::Config->{yaml_module}||"YAML")) {
        return;
    }
    return if $HAVE_REANIMATED++;
    my $d = $CPAN::Config->{build_dir};
    my $dh = DirHandle->new;
    opendir $dh, $d or return; # does not exist
    my $dirent;
    my $i = 0;
    my $painted = 0;
    my $restored = 0;
    $CPAN::Frontend->myprint("Going to read $CPAN::Config->{build_dir}/\n");
    my @@candidates = map { $_->[0] }
        sort { $b->[1] <=> $a->[1] }
            map { [ $_, -M File::Spec->catfile($d,$_) ] }
                grep {/\.yml$/} readdir $dh;
  DISTRO: for $i (0..$#candidates) {
        my $dirent = $candidates[$i];
        my $y = eval {CPAN->_yaml_loadfile(File::Spec->catfile($d,$dirent))};
        if ($@@) {
            warn "Error while parsing file '$dirent'; error: '$@@'";
            next DISTRO;
        }
        my $c = $y->[0];
        if ($c && CPAN->_perl_fingerprint($c->{perl})) {
            my $key = $c->{distribution}{ID};
            for my $k (keys %{$c->{distribution}}) {
                if ($c->{distribution}{$k}
                    && ref $c->{distribution}{$k}
                    && UNIVERSAL::isa($c->{distribution}{$k},"CPAN::Distrostatus")) {
                    $c->{distribution}{$k}{COMMANDID} = $i - @@candidates;
                }
            }

            #we tried to restore only if element already
            #exists; but then we do not work with metadata
            #turned off.
            my $do
                = $CPAN::META->{readwrite}{'CPAN::Distribution'}{$key}
                    = $c->{distribution};
            for my $skipper (qw(
                                badtestcnt
                                configure_requires_later
                                configure_requires_later_for
                                force_update
                                later
                                later_for
                                notest
                                should_report
                                sponsored_mods
                               )) {
                delete $do->{$skipper};
            }
            # $DB::single = 1;
            if ($do->{make_test}
                && $do->{build_dir}
                && !(UNIVERSAL::can($do->{make_test},"failed") ?
                     $do->{make_test}->failed :
                     $do->{make_test} =~ /^YES/
                    )
                && (
                    !$do->{install}
                    ||
                    $do->{install}->failed
                   )
               ) {
                $CPAN::META->is_tested($do->{build_dir},$do->{make_test}{TIME});
            }
            $restored++;
        }
        $i++;
        while (($painted/76) < ($i/@@candidates)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
    }
    $CPAN::Frontend->myprint(sprintf(
                                     "DONE\nFound %s old build%s, restored the state of %s\n",
                                     @@candidates ? sprintf("%d",scalar @@candidates) : "no",
                                     @@candidates==1 ? "" : "s",
                                     $restored || "none",
                                    ));
}


#-> sub CPAN::Index::reload_x ;
sub reload_x {
    my($cl,$wanted,$localname,$force) = @@_;
    $force |= 2; # means we're dealing with an index here
    CPAN::HandleConfig->load; # we should guarantee loading wherever
                              # we rely on Config XXX
    $localname ||= $wanted;
    my $abs_wanted = File::Spec->catfile($CPAN::Config->{'keep_source_where'},
                                         $localname);
    if (
        -f $abs_wanted &&
        -M $abs_wanted < $CPAN::Config->{'index_expire'} &&
        !($force & 1)
       ) {
        my $s = $CPAN::Config->{'index_expire'} == 1 ? "" : "s";
        $cl->debug(qq{$abs_wanted younger than $CPAN::Config->{'index_expire'} }.
                   qq{day$s. I\'ll use that.});
        return $abs_wanted;
    } else {
        $force |= 1; # means we're quite serious about it.
    }
    return CPAN::FTP->localize($wanted,$abs_wanted,$force);
}

#-> sub CPAN::Index::rd_authindex ;
sub rd_authindex {
    my($cl, $index_target) = @@_;
    return unless defined $index_target;
    return if CPAN::_sqlite_running;
    my @@lines;
    $CPAN::Frontend->myprint("Going to read $index_target\n");
    local(*FH);
    tie *FH, 'CPAN::Tarzip', $index_target;
    local($/) = "\n";
    local($_);
    push @@lines, split /\012/ while <FH>;
    my $i = 0;
    my $painted = 0;
    foreach (@@lines) {
        my($userid,$fullname,$email) =
            m/alias\s+(\S+)\s+\"([^\"\<]*)\s+\<(.*)\>\"/;
        $fullname ||= $email;
        if ($userid && $fullname && $email) {
            my $userobj = $CPAN::META->instance('CPAN::Author',$userid);
            $userobj->set('FULLNAME' => $fullname, 'EMAIL' => $email);
        } else {
            CPAN->debug(sprintf "line[%s]", $_) if $CPAN::DEBUG;
        }
        $i++;
        while (($painted/76) < ($i/@@lines)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
        return if $CPAN::Signal;
    }
    $CPAN::Frontend->myprint("DONE\n");
}

sub userid {
  my($self,$dist) = @@_;
  $dist = $self->{'id'} unless defined $dist;
  my($ret) = $dist =~ m|(?:\w/\w\w/)?([^/]+)/|;
  $ret;
}

#-> sub CPAN::Index::rd_modpacks ;
sub rd_modpacks {
    my($self, $index_target) = @@_;
    return unless defined $index_target;
    return if CPAN::_sqlite_running;
    $CPAN::Frontend->myprint("Going to read $index_target\n");
    my $fh = CPAN::Tarzip->TIEHANDLE($index_target);
    local $_;
    CPAN->debug(sprintf "start[%d]", time) if $CPAN::DEBUG;
    my $slurp = "";
    my $chunk;
    while (my $bytes = $fh->READ(\$chunk,8192)) {
        $slurp.=$chunk;
    }
    my @@lines = split /\012/, $slurp;
    CPAN->debug(sprintf "end[%d]", time) if $CPAN::DEBUG;
    undef $fh;
    # read header
    my($line_count,$last_updated);
    while (@@lines) {
        my $shift = shift(@@lines);
        last if $shift =~ /^\s*$/;
        $shift =~ /^Line-Count:\s+(\d+)/ and $line_count = $1;
        $shift =~ /^Last-Updated:\s+(.+)/ and $last_updated = $1;
    }
    CPAN->debug("line_count[$line_count]last_updated[$last_updated]") if $CPAN::DEBUG;
    if (not defined $line_count) {

        $CPAN::Frontend->mywarn(qq{Warning: Your $index_target does not contain a Line-Count header.
Please check the validity of the index file by comparing it to more
than one CPAN mirror. I'll continue but problems seem likely to
happen.\a
});

        $CPAN::Frontend->mysleep(5);
    } elsif ($line_count != scalar @@lines) {

        $CPAN::Frontend->mywarn(sprintf qq{Warning: Your %s
contains a Line-Count header of %d but I see %d lines there. Please
check the validity of the index file by comparing it to more than one
CPAN mirror. I'll continue but problems seem likely to happen.\a\n},
$index_target, $line_count, scalar(@@lines));

    }
    if (not defined $last_updated) {

        $CPAN::Frontend->mywarn(qq{Warning: Your $index_target does not contain a Last-Updated header.
Please check the validity of the index file by comparing it to more
than one CPAN mirror. I'll continue but problems seem likely to
happen.\a
});

        $CPAN::Frontend->mysleep(5);
    } else {

        $CPAN::Frontend
            ->myprint(sprintf qq{  Database was generated on %s\n},
                      $last_updated);
        $DATE_OF_02 = $last_updated;

        my $age = time;
        if ($CPAN::META->has_inst('HTTP::Date')) {
            require HTTP::Date;
            $age -= HTTP::Date::str2time($last_updated);
        } else {
            $CPAN::Frontend->mywarn("  HTTP::Date not available\n");
            require Time::Local;
            my(@@d) = $last_updated =~ / (\d+) (\w+) (\d+) (\d+):(\d+):(\d+) /;
            $d[1] = index("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", $d[1])/4;
            $age -= $d[1]>=0 ? Time::Local::timegm(@@d[5,4,3,0,1,2]) : 0;
        }
        $age /= 3600*24;
        if ($age > 30) {

            $CPAN::Frontend
                ->mywarn(sprintf
                         qq{Warning: This index file is %d days old.
  Please check the host you chose as your CPAN mirror for staleness.
  I'll continue but problems seem likely to happen.\a\n},
                         $age);

        } elsif ($age < -1) {

            $CPAN::Frontend
                ->mywarn(sprintf
                         qq{Warning: Your system date is %d days behind this index file!
  System time:          %s
  Timestamp index file: %s
  Please fix your system time, problems with the make command expected.\n},
                         -$age,
                         scalar gmtime,
                         $DATE_OF_02,
                        );

        }
    }


    # A necessity since we have metadata_cache: delete what isn't
    # there anymore
    my $secondtime = $CPAN::META->exists("CPAN::Module","CPAN");
    CPAN->debug("secondtime[$secondtime]") if $CPAN::DEBUG;
    my(%exists);
    my $i = 0;
    my $painted = 0;
    foreach (@@lines) {
        # before 1.56 we split into 3 and discarded the rest. From
        # 1.57 we assign remaining text to $comment thus allowing to
        # influence isa_perl
        my($mod,$version,$dist,$comment) = split " ", $_, 4;
        my($bundle,$id,$userid);

        if ($mod eq 'CPAN' &&
            ! (
            CPAN::Queue->exists('Bundle::CPAN') ||
            CPAN::Queue->exists('CPAN')
            )
        ) {
            local($^W)= 0;
            if ($version > $CPAN::VERSION) {
                $CPAN::Frontend->mywarn(qq{
  New CPAN.pm version (v$version) available.
  [Currently running version is v$CPAN::VERSION]
  You might want to try
    install CPAN
    reload cpan
  to both upgrade CPAN.pm and run the new version without leaving
  the current session.

}); #});
                $CPAN::Frontend->mysleep(2);
                $CPAN::Frontend->myprint(qq{\n});
            }
            last if $CPAN::Signal;
        } elsif ($mod =~ /^Bundle::(.*)/) {
            $bundle = $1;
        }

        if ($bundle) {
            $id =  $CPAN::META->instance('CPAN::Bundle',$mod);
            # Let's make it a module too, because bundles have so much
            # in common with modules.

            # Changed in 1.57_63: seems like memory bloat now without
            # any value, so commented out

            # $CPAN::META->instance('CPAN::Module',$mod);

        } else {

            # instantiate a module object
            $id = $CPAN::META->instance('CPAN::Module',$mod);

        }

        # Although CPAN prohibits same name with different version the
        # indexer may have changed the version for the same distro
        # since the last time ("Force Reindexing" feature)
        if ($id->cpan_file ne $dist
            ||
            $id->cpan_version ne $version
           ) {
            $userid = $id->userid || $self->userid($dist);
            $id->set(
                     'CPAN_USERID' => $userid,
                     'CPAN_VERSION' => $version,
                     'CPAN_FILE' => $dist,
                    );
        }

        # instantiate a distribution object
        if ($CPAN::META->exists('CPAN::Distribution',$dist)) {
        # we do not need CONTAINSMODS unless we do something with
        # this dist, so we better produce it on demand.

        ## my $obj = $CPAN::META->instance(
        ##                                 'CPAN::Distribution' => $dist
        ##                                );
        ## $obj->{CONTAINSMODS}{$mod} = undef; # experimental
        } else {
            $CPAN::META->instance(
                                  'CPAN::Distribution' => $dist
                                 )->set(
                                        'CPAN_USERID' => $userid,
                                        'CPAN_COMMENT' => $comment,
                                       );
        }
        if ($secondtime) {
            for my $name ($mod,$dist) {
                # $self->debug("exists name[$name]") if $CPAN::DEBUG;
                $exists{$name} = undef;
            }
        }
        $i++;
        while (($painted/76) < ($i/@@lines)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
        return if $CPAN::Signal;
    }
    $CPAN::Frontend->myprint("DONE\n");
    if ($secondtime) {
        for my $class (qw(CPAN::Module CPAN::Bundle CPAN::Distribution)) {
            for my $o ($CPAN::META->all_objects($class)) {
                next if exists $exists{$o->{ID}};
                $CPAN::META->delete($class,$o->{ID});
                # CPAN->debug("deleting ID[$o->{ID}] in class[$class]")
                #     if $CPAN::DEBUG;
            }
        }
    }
}

#-> sub CPAN::Index::rd_modlist ;
sub rd_modlist {
    my($cl,$index_target) = @@_;
    return unless defined $index_target;
    return if CPAN::_sqlite_running;
    $CPAN::Frontend->myprint("Going to read $index_target\n");
    my $fh = CPAN::Tarzip->TIEHANDLE($index_target);
    local $_;
    my $slurp = "";
    my $chunk;
    while (my $bytes = $fh->READ(\$chunk,8192)) {
        $slurp.=$chunk;
    }
    my @@eval2 = split /\012/, $slurp;

    while (@@eval2) {
        my $shift = shift(@@eval2);
        if ($shift =~ /^Date:\s+(.*)/) {
            if ($DATE_OF_03 eq $1) {
                $CPAN::Frontend->myprint("Unchanged.\n");
                return;
            }
            ($DATE_OF_03) = $1;
        }
        last if $shift =~ /^\s*$/;
    }
    push @@eval2, q{CPAN::Modulelist->data;};
    local($^W) = 0;
    my($comp) = Safe->new("CPAN::Safe1");
    my($eval2) = join("\n", @@eval2);
    CPAN->debug(sprintf "length of eval2[%d]", length $eval2) if $CPAN::DEBUG;
    my $ret = $comp->reval($eval2);
    Carp::confess($@@) if $@@;
    return if $CPAN::Signal;
    my $i = 0;
    my $until = keys(%$ret);
    my $painted = 0;
    CPAN->debug(sprintf "until[%d]", $until) if $CPAN::DEBUG;
    for (keys %$ret) {
        my $obj = $CPAN::META->instance("CPAN::Module",$_);
        delete $ret->{$_}{modid}; # not needed here, maybe elsewhere
        $obj->set(%{$ret->{$_}});
        $i++;
        while (($painted/76) < ($i/$until)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
        return if $CPAN::Signal;
    }
    $CPAN::Frontend->myprint("DONE\n");
}

#-> sub CPAN::Index::write_metadata_cache ;
sub write_metadata_cache {
    my($self) = @@_;
    return unless $CPAN::Config->{'cache_metadata'};
    return if CPAN::_sqlite_running;
    return unless $CPAN::META->has_usable("Storable");
    my $cache;
    foreach my $k (qw(CPAN::Bundle CPAN::Author CPAN::Module
                      CPAN::Distribution)) {
        $cache->{$k} = $CPAN::META->{readonly}{$k}; # unsafe meta access, ok
    }
    my $metadata_file = File::Spec->catfile($CPAN::Config->{cpan_home},"Metadata");
    $cache->{last_time} = $LAST_TIME;
    $cache->{DATE_OF_02} = $DATE_OF_02;
    $cache->{PROTOCOL} = PROTOCOL;
    $CPAN::Frontend->myprint("Going to write $metadata_file\n");
    eval { Storable::nstore($cache, $metadata_file) };
    $CPAN::Frontend->mywarn($@@) if $@@; # ?? missing "\n" after $@@ in mywarn ??
}

#-> sub CPAN::Index::read_metadata_cache ;
sub read_metadata_cache {
    my($self) = @@_;
    return unless $CPAN::Config->{'cache_metadata'};
    return if CPAN::_sqlite_running;
    return unless $CPAN::META->has_usable("Storable");
    my $metadata_file = File::Spec->catfile($CPAN::Config->{cpan_home},"Metadata");
    return unless -r $metadata_file and -f $metadata_file;
    $CPAN::Frontend->myprint("Going to read $metadata_file\n");
    my $cache;
    eval { $cache = Storable::retrieve($metadata_file) };
    $CPAN::Frontend->mywarn($@@) if $@@; # ?? missing "\n" after $@@ in mywarn ??
    if (!$cache || !UNIVERSAL::isa($cache, 'HASH')) {
        $LAST_TIME = 0;
        return;
    }
    if (exists $cache->{PROTOCOL}) {
        if (PROTOCOL > $cache->{PROTOCOL}) {
            $CPAN::Frontend->mywarn(sprintf("Ignoring Metadata cache written ".
                                            "with protocol v%s, requiring v%s\n",
                                            $cache->{PROTOCOL},
                                            PROTOCOL)
                                   );
            return;
        }
    } else {
        $CPAN::Frontend->mywarn("Ignoring Metadata cache written ".
                                "with protocol v1.0\n");
        return;
    }
    my $clcnt = 0;
    my $idcnt = 0;
    while(my($class,$v) = each %$cache) {
        next unless $class =~ /^CPAN::/;
        $CPAN::META->{readonly}{$class} = $v; # unsafe meta access, ok
        while (my($id,$ro) = each %$v) {
            $CPAN::META->{readwrite}{$class}{$id} ||=
                $class->new(ID=>$id, RO=>$ro);
            $idcnt++;
        }
        $clcnt++;
    }
    unless ($clcnt) { # sanity check
        $CPAN::Frontend->myprint("Warning: Found no data in $metadata_file\n");
        return;
    }
    if ($idcnt < 1000) {
        $CPAN::Frontend->myprint("Warning: Found only $idcnt objects ".
                                 "in $metadata_file\n");
        return;
    }
    $CPAN::META->{PROTOCOL} ||=
        $cache->{PROTOCOL}; # reading does not up or downgrade, but it
                            # does initialize to some protocol
    $LAST_TIME = $cache->{last_time};
    $DATE_OF_02 = $cache->{DATE_OF_02};
    $CPAN::Frontend->myprint("  Database was generated on $DATE_OF_02\n")
        if defined $DATE_OF_02; # An old cache may not contain DATE_OF_02
    return;
}

package CPAN::InfoObj;
use strict;

sub ro {
    my $self = shift;
    exists $self->{RO} and return $self->{RO};
}

#-> sub CPAN::InfoObj::cpan_userid
sub cpan_userid {
    my $self = shift;
    my $ro = $self->ro;
    if ($ro) {
        return $ro->{CPAN_USERID} || "N/A";
    } else {
        $self->debug("ID[$self->{ID}]");
        # N/A for bundles found locally
        return "N/A";
    }
}

sub id { shift->{ID}; }

#-> sub CPAN::InfoObj::new ;
sub new {
    my $this = bless {}, shift;
    %$this = @@_;
    $this
}

# The set method may only be used by code that reads index data or
# otherwise "objective" data from the outside world. All session
# related material may do anything else with instance variables but
# must not touch the hash under the RO attribute. The reason is that
# the RO hash gets written to Metadata file and is thus persistent.

#-> sub CPAN::InfoObj::safe_chdir ;
sub safe_chdir {
  my($self,$todir) = @@_;
  # we die if we cannot chdir and we are debuggable
  Carp::confess("safe_chdir called without todir argument")
        unless defined $todir and length $todir;
  if (chdir $todir) {
    $self->debug(sprintf "changed directory to %s", CPAN::anycwd())
        if $CPAN::DEBUG;
  } else {
    if (-e $todir) {
        unless (-x $todir) {
            unless (chmod 0755, $todir) {
                my $cwd = CPAN::anycwd();
                $CPAN::Frontend->mywarn("I have neither the -x permission nor the ".
                                        "permission to change the permission; cannot ".
                                        "chdir to '$todir'\n");
                $CPAN::Frontend->mysleep(5);
                $CPAN::Frontend->mydie(qq{Could not chdir from cwd[$cwd] }.
                                       qq{to todir[$todir]: $!});
            }
        }
    } else {
        $CPAN::Frontend->mydie("Directory '$todir' has gone. Cannot continue.\n");
    }
    if (chdir $todir) {
      $self->debug(sprintf "changed directory to %s", CPAN::anycwd())
          if $CPAN::DEBUG;
    } else {
      my $cwd = CPAN::anycwd();
      $CPAN::Frontend->mydie(qq{Could not chdir from cwd[$cwd] }.
                             qq{to todir[$todir] (a chmod has been issued): $!});
    }
  }
}

#-> sub CPAN::InfoObj::set ;
sub set {
    my($self,%att) = @@_;
    my $class = ref $self;

    # This must be ||=, not ||, because only if we write an empty
    # reference, only then the set method will write into the readonly
    # area. But for Distributions that spring into existence, maybe
    # because of a typo, we do not like it that they are written into
    # the readonly area and made permanent (at least for a while) and
    # that is why we do not "allow" other places to call ->set.
    unless ($self->id) {
        CPAN->debug("Bug? Empty ID, rejecting");
        return;
    }
    my $ro = $self->{RO} =
        $CPAN::META->{readonly}{$class}{$self->id} ||= {};

    while (my($k,$v) = each %att) {
        $ro->{$k} = $v;
    }
}

#-> sub CPAN::InfoObj::as_glimpse ;
sub as_glimpse {
    my($self) = @@_;
    my(@@m);
    my $class = ref($self);
    $class =~ s/^CPAN:://;
    my $id = $self->can("pretty_id") ? $self->pretty_id : $self->{ID};
    push @@m, sprintf "%-15s %s\n", $class, $id;
    join "", @@m;
}

#-> sub CPAN::InfoObj::as_string ;
sub as_string {
    my($self) = @@_;
    my(@@m);
    my $class = ref($self);
    $class =~ s/^CPAN:://;
    push @@m, $class, " id = $self->{ID}\n";
    my $ro;
    unless ($ro = $self->ro) {
        if (substr($self->{ID},-1,1) eq ".") { # directory
            $ro = +{};
        } else {
            $CPAN::Frontend->mywarn("Unknown object $self->{ID}\n");
            $CPAN::Frontend->mysleep(5);
            return;
        }
    }
    for (sort keys %$ro) {
        # next if m/^(ID|RO)$/;
        my $extra = "";
        if ($_ eq "CPAN_USERID") {
            $extra .= " (";
            $extra .= $self->fullname;
            my $email; # old perls!
            if ($email = $CPAN::META->instance("CPAN::Author",
                                               $self->cpan_userid
                                              )->email) {
                $extra .= " <$email>";
            } else {
                $extra .= " <no email>";
            }
            $extra .= ")";
        } elsif ($_ eq "FULLNAME") { # potential UTF-8 conversion
            push @@m, sprintf "    %-12s %s\n", $_, $self->fullname;
            next;
        }
        next unless defined $ro->{$_};
        push @@m, sprintf "    %-12s %s%s\n", $_, $ro->{$_}, $extra;
    }
  KEY: for (sort keys %$self) {
        next if m/^(ID|RO)$/;
        unless (defined $self->{$_}) {
            delete $self->{$_};
            next KEY;
        }
        if (ref($self->{$_}) eq "ARRAY") {
            push @@m, sprintf "    %-12s %s\n", $_, "@@{$self->{$_}}";
        } elsif (ref($self->{$_}) eq "HASH") {
            my $value;
            if (/^CONTAINSMODS$/) {
                $value = join(" ",sort keys %{$self->{$_}});
            } elsif (/^prereq_pm$/) {
                my @@value;
                my $v = $self->{$_};
                for my $x (sort keys %$v) {
                    my @@svalue;
                    for my $y (sort keys %{$v->{$x}}) {
                        push @@svalue, "$y=>$v->{$x}{$y}";
                    }
                    push @@value, "$x\:" . join ",", @@svalue if @@svalue;
                }
                $value = join ";", @@value;
            } else {
                $value = $self->{$_};
            }
            push @@m, sprintf(
                             "    %-12s %s\n",
                             $_,
                             $value,
                            );
        } else {
            push @@m, sprintf "    %-12s %s\n", $_, $self->{$_};
        }
    }
    join "", @@m, "\n";
}

#-> sub CPAN::InfoObj::fullname ;
sub fullname {
    my($self) = @@_;
    $CPAN::META->instance("CPAN::Author",$self->cpan_userid)->fullname;
}

#-> sub CPAN::InfoObj::dump ;
sub dump {
    my($self, $what) = @@_;
    unless ($CPAN::META->has_inst("Data::Dumper")) {
        $CPAN::Frontend->mydie("dump command requires Data::Dumper installed");
    }
    local $Data::Dumper::Sortkeys;
    $Data::Dumper::Sortkeys = 1;
    my $out = Data::Dumper::Dumper($what ? eval $what : $self);
    if (length $out > 100000) {
        my $fh_pager = FileHandle->new;
        local($SIG{PIPE}) = "IGNORE";
        my $pager = $CPAN::Config->{'pager'} || "cat";
        $fh_pager->open("|$pager")
            or die "Could not open pager $pager\: $!";
        $fh_pager->print($out);
        close $fh_pager;
    } else {
        $CPAN::Frontend->myprint($out);
    }
}

package CPAN::Author;
use strict;

#-> sub CPAN::Author::force
sub force {
    my $self = shift;
    $self->{force}++;
}

#-> sub CPAN::Author::force
sub unforce {
    my $self = shift;
    delete $self->{force};
}

#-> sub CPAN::Author::id
sub id {
    my $self = shift;
    my $id = $self->{ID};
    $CPAN::Frontend->mydie("Illegal author id[$id]") unless $id =~ /^[A-Z]/;
    $id;
}

#-> sub CPAN::Author::as_glimpse ;
sub as_glimpse {
    my($self) = @@_;
    my(@@m);
    my $class = ref($self);
    $class =~ s/^CPAN:://;
    push @@m, sprintf(qq{%-15s %s ("%s" <%s>)\n},
                     $class,
                     $self->{ID},
                     $self->fullname,
                     $self->email);
    join "", @@m;
}

#-> sub CPAN::Author::fullname ;
sub fullname {
    shift->ro->{FULLNAME};
}
*name = \&fullname;

#-> sub CPAN::Author::email ;
sub email    { shift->ro->{EMAIL}; }

#-> sub CPAN::Author::ls ;
sub ls {
    my $self = shift;
    my $glob = shift || "";
    my $silent = shift || 0;
    my $id = $self->id;

    # adapted from CPAN::Distribution::verifyCHECKSUM ;
    my(@@csf); # chksumfile
    @@csf = $self->id =~ /(.)(.)(.*)/;
    $csf[1] = join "", @@csf[0,1];
    $csf[2] = join "", @@csf[1,2]; # ("A","AN","ANDK")
    my(@@dl);
    @@dl = $self->dir_listing([$csf[0],"CHECKSUMS"], 0, 1);
    unless (grep {$_->[2] eq $csf[1]} @@dl) {
        $CPAN::Frontend->myprint("Directory $csf[1]/ does not exist\n") unless $silent ;
        return;
    }
    @@dl = $self->dir_listing([@@csf[0,1],"CHECKSUMS"], 0, 1);
    unless (grep {$_->[2] eq $csf[2]} @@dl) {
        $CPAN::Frontend->myprint("Directory $id/ does not exist\n") unless $silent;
        return;
    }
    @@dl = $self->dir_listing([@@csf,"CHECKSUMS"], 1, 1);
    if ($glob) {
        if ($CPAN::META->has_inst("Text::Glob")) {
            my $rglob = Text::Glob::glob_to_regex($glob);
            @@dl = grep { $_->[2] =~ /$rglob/ } @@dl;
        } else {
            $CPAN::Frontend->mydie("Text::Glob not installed, cannot proceed");
        }
    }
    unless ($silent >= 2) {
        $CPAN::Frontend->myprint(join "", map {
            sprintf("%8d %10s %s/%s\n", $_->[0], $_->[1], $id, $_->[2])
        } sort { $a->[2] cmp $b->[2] } @@dl);
    }
    @@dl;
}

# returns an array of arrays, the latter contain (size,mtime,filename)
#-> sub CPAN::Author::dir_listing ;
sub dir_listing {
    my $self = shift;
    my $chksumfile = shift;
    my $recursive = shift;
    my $may_ftp = shift;

    my $lc_want =
        File::Spec->catfile($CPAN::Config->{keep_source_where},
                            "authors", "id", @@$chksumfile);

    my $fh;

    # Purge and refetch old (pre-PGP) CHECKSUMS; they are a security
    # hazard.  (Without GPG installed they are not that much better,
    # though.)
    $fh = FileHandle->new;
    if (open($fh, $lc_want)) {
        my $line = <$fh>; close $fh;
        unlink($lc_want) unless $line =~ /PGP/;
    }

    local($") = "/";
    # connect "force" argument with "index_expire".
    my $force = $self->{force};
    if (my @@stat = stat $lc_want) {
        $force ||= $stat[9] + $CPAN::Config->{index_expire}*86400 <= time;
    }
    my $lc_file;
    if ($may_ftp) {
        $lc_file = CPAN::FTP->localize(
                                       "authors/id/@@$chksumfile",
                                       $lc_want,
                                       $force,
                                      );
        unless ($lc_file) {
            $CPAN::Frontend->myprint("Trying $lc_want.gz\n");
            $chksumfile->[-1] .= ".gz";
            $lc_file = CPAN::FTP->localize("authors/id/@@$chksumfile",
                                           "$lc_want.gz",1);
            if ($lc_file) {
                $lc_file =~ s{\.gz(?!\n)\Z}{}; #};
                eval{CPAN::Tarzip->new("$lc_file.gz")->gunzip($lc_file)};
            } else {
                return;
            }
        }
    } else {
        $lc_file = $lc_want;
        # we *could* second-guess and if the user has a file: URL,
        # then we could look there. But on the other hand, if they do
        # have a file: URL, wy did they choose to set
        # $CPAN::Config->{show_upload_date} to false?
    }

    # adapted from CPAN::Distribution::CHECKSUM_check_file ;
    $fh = FileHandle->new;
    my($cksum);
    if (open $fh, $lc_file) {
        local($/);
        my $eval = <$fh>;
        $eval =~ s/\015?\012/\n/g;
        close $fh;
        my($comp) = Safe->new();
        $cksum = $comp->reval($eval);
        if ($@@) {
            rename $lc_file, "$lc_file.bad";
            Carp::confess($@@) if $@@;
        }
    } elsif ($may_ftp) {
        Carp::carp "Could not open '$lc_file' for reading.";
    } else {
        # Maybe should warn: "You may want to set show_upload_date to a true value"
        return;
    }
    my(@@result,$f);
    for $f (sort keys %$cksum) {
        if (exists $cksum->{$f}{isdir}) {
            if ($recursive) {
                my(@@dir) = @@$chksumfile;
                pop @@dir;
                push @@dir, $f, "CHECKSUMS";
                push @@result, map {
                    [$_->[0], $_->[1], "$f/$_->[2]"]
                } $self->dir_listing(\@@dir,1,$may_ftp);
            } else {
                push @@result, [ 0, "-", $f ];
            }
        } else {
            push @@result, [
                           ($cksum->{$f}{"size"}||0),
                           $cksum->{$f}{"mtime"}||"---",
                           $f
                          ];
        }
    }
    @@result;
}

#-> sub CPAN::Author::reports
sub reports {
    $CPAN::Frontend->mywarn("reports on authors not implemented.
Please file a bugreport if you need this.\n");
}

package CPAN::Distribution;
use strict;

# Accessors
sub cpan_comment {
    my $self = shift;
    my $ro = $self->ro or return;
    $ro->{CPAN_COMMENT}
}

#-> CPAN::Distribution::undelay
sub undelay {
    my $self = shift;
    for my $delayer (
                     "configure_requires_later",
                     "configure_requires_later_for",
                     "later",
                     "later_for",
                    ) {
        delete $self->{$delayer};
    }
}

#-> CPAN::Distribution::is_dot_dist
sub is_dot_dist {
    my($self) = @@_;
    return substr($self->id,-1,1) eq ".";
}

# add the A/AN/ stuff
#-> CPAN::Distribution::normalize
sub normalize {
    my($self,$s) = @@_;
    $s = $self->id unless defined $s;
    if (substr($s,-1,1) eq ".") {
        # using a global because we are sometimes called as static method
        if (!$CPAN::META->{LOCK}
            && !$CPAN::Have_warned->{"$s is unlocked"}++
           ) {
            $CPAN::Frontend->mywarn("You are visiting the local directory
  '$s'
  without lock, take care that concurrent processes do not do likewise.\n");
            $CPAN::Frontend->mysleep(1);
        }
        if ($s eq ".") {
            $s = "$CPAN::iCwd/.";
        } elsif (File::Spec->file_name_is_absolute($s)) {
        } elsif (File::Spec->can("rel2abs")) {
            $s = File::Spec->rel2abs($s);
        } else {
            $CPAN::Frontend->mydie("Your File::Spec is too old, please upgrade File::Spec");
        }
        CPAN->debug("s[$s]") if $CPAN::DEBUG;
        unless ($CPAN::META->exists("CPAN::Distribution", $s)) {
            for ($CPAN::META->instance("CPAN::Distribution", $s)) {
                $_->{build_dir} = $s;
                $_->{archived} = "local_directory";
                $_->{unwrapped} = CPAN::Distrostatus->new("YES -- local_directory");
            }
        }
    } elsif (
        $s =~ tr|/|| == 1
        or
        $s !~ m|[A-Z]/[A-Z-]{2}/[A-Z-]{2,}/|
       ) {
        return $s if $s =~ m:^N/A|^Contact Author: ;
        $s =~ s|^(.)(.)([^/]*/)(.+)$|$1/$1$2/$1$2$3$4| or
            $CPAN::Frontend->mywarn("Strange distribution name [$s]\n");
        CPAN->debug("s[$s]") if $CPAN::DEBUG;
    }
    $s;
}

#-> sub CPAN::Distribution::author ;
sub author {
    my($self) = @@_;
    my($authorid);
    if (substr($self->id,-1,1) eq ".") {
        $authorid = "LOCAL";
    } else {
        ($authorid) = $self->pretty_id =~ /^([\w\-]+)/;
    }
    CPAN::Shell->expand("Author",$authorid);
}

# tries to get the yaml from CPAN instead of the distro itself:
# EXPERIMENTAL, UNDOCUMENTED AND UNTESTED, for Tels
sub fast_yaml {
    my($self) = @@_;
    my $meta = $self->pretty_id;
    $meta =~ s/\.(tar.gz|tgz|zip|tar.bz2)/.meta/;
    my(@@ls) = CPAN::Shell->globls($meta);
    my $norm = $self->normalize($meta);

    my($local_file);
    my($local_wanted) =
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,$norm)
                           );
    $self->debug("Doing localize") if $CPAN::DEBUG;
    unless ($local_file =
            CPAN::FTP->localize("authors/id/$norm",
                                $local_wanted)) {
        $CPAN::Frontend->mydie("Giving up on downloading yaml file '$local_wanted'\n");
    }
    my $yaml = CPAN->_yaml_loadfile($local_file)->[0];
}

#-> sub CPAN::Distribution::cpan_userid
sub cpan_userid {
    my $self = shift;
    if ($self->{ID} =~ m{[A-Z]/[A-Z\-]{2}/([A-Z\-]+)/}) {
        return $1;
    }
    return $self->SUPER::cpan_userid;
}

#-> sub CPAN::Distribution::pretty_id
sub pretty_id {
    my $self = shift;
    my $id = $self->id;
    return $id unless $id =~ m|^./../|;
    substr($id,5);
}

#-> sub CPAN::Distribution::base_id
sub base_id {
    my $self = shift;
    my $id = $self->pretty_id();
    my $base_id = File::Basename::basename($id);
    $base_id =~ s{\.(?:tar\.(bz2|gz|Z)|t(?:gz|bz)|zip)$}{}i;
    return $base_id;
}

# mark as dirty/clean for the sake of recursion detection. $color=1
# means "in use", $color=0 means "not in use anymore". $color=2 means
# we have determined prereqs now and thus insist on passing this
# through (at least) once again.

#-> sub CPAN::Distribution::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    my($ancestors) = shift || [];
    # a distribution needs to recurse into its prereq_pms

    return if exists $self->{incommandcolor}
        && $color==1
        && $self->{incommandcolor}==$color;
    if ($depth>=$CPAN::MAX_RECURSION) {
        die(CPAN::Exception::RecursiveDependency->new($ancestors));
    }
    # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
    my $prereq_pm = $self->prereq_pm;
    if (defined $prereq_pm) {
      PREREQ: for my $pre (keys %{$prereq_pm->{requires}||{}},
                           keys %{$prereq_pm->{build_requires}||{}}) {
            next PREREQ if $pre eq "perl";
            my $premo;
            unless ($premo = CPAN::Shell->expand("Module",$pre)) {
                $CPAN::Frontend->mywarn("prerequisite module[$pre] not known\n");
                $CPAN::Frontend->mysleep(2);
                next PREREQ;
            }
            $premo->color_cmd_tmps($depth+1,$color,[@@$ancestors, $self->id]);
        }
    }
    if ($color==0) {
        delete $self->{sponsored_mods};

        # as we are at the end of a command, we'll give up this
        # reminder of a broken test. Other commands may test this guy
        # again. Maybe 'badtestcnt' should be renamed to
        # 'make_test_failed_within_command'?
        delete $self->{badtestcnt};
    }
    $self->{incommandcolor} = $color;
}

#-> sub CPAN::Distribution::as_string ;
sub as_string {
    my $self = shift;
    $self->containsmods;
    $self->upload_date;
    $self->SUPER::as_string(@@_);
}

#-> sub CPAN::Distribution::containsmods ;
sub containsmods {
    my $self = shift;
    return keys %{$self->{CONTAINSMODS}} if exists $self->{CONTAINSMODS};
    my $dist_id = $self->{ID};
    for my $mod ($CPAN::META->all_objects("CPAN::Module")) {
        my $mod_file = $mod->cpan_file or next;
        my $mod_id = $mod->{ID} or next;
        # warn "mod_file[$mod_file] dist_id[$dist_id] mod_id[$mod_id]";
        # sleep 1;
        if ($CPAN::Signal) {
            delete $self->{CONTAINSMODS};
            return;
        }
        $self->{CONTAINSMODS}{$mod_id} = undef if $mod_file eq $dist_id;
    }
    keys %{$self->{CONTAINSMODS}||={}};
}

#-> sub CPAN::Distribution::upload_date ;
sub upload_date {
    my $self = shift;
    return $self->{UPLOAD_DATE} if exists $self->{UPLOAD_DATE};
    my(@@local_wanted) = split(/\//,$self->id);
    my $filename = pop @@local_wanted;
    push @@local_wanted, "CHECKSUMS";
    my $author = CPAN::Shell->expand("Author",$self->cpan_userid);
    return unless $author;
    my @@dl = $author->dir_listing(\@@local_wanted,0,$CPAN::Config->{show_upload_date});
    return unless @@dl;
    my($dirent) = grep { $_->[2] eq $filename } @@dl;
    # warn sprintf "dirent[%s]id[%s]", $dirent, $self->id;
    return unless $dirent->[1];
    return $self->{UPLOAD_DATE} = $dirent->[1];
}

#-> sub CPAN::Distribution::uptodate ;
sub uptodate {
    my($self) = @@_;
    my $c;
    foreach $c ($self->containsmods) {
        my $obj = CPAN::Shell->expandany($c);
        unless ($obj->uptodate) {
            my $id = $self->pretty_id;
            $self->debug("$id not uptodate due to $c") if $CPAN::DEBUG;
            return 0;
        }
    }
    return 1;
}

#-> sub CPAN::Distribution::called_for ;
sub called_for {
    my($self,$id) = @@_;
    $self->{CALLED_FOR} = $id if defined $id;
    return $self->{CALLED_FOR};
}

#-> sub CPAN::Distribution::get ;
sub get {
    my($self) = @@_;
    $self->debug("checking goto id[$self->{ID}]") if $CPAN::DEBUG;
    if (my $goto = $self->prefs->{goto}) {
        $CPAN::Frontend->mywarn
            (sprintf(
                     "delegating to '%s' as specified in prefs file '%s' doc %d\n",
                     $goto,
                     $self->{prefs_file},
                     $self->{prefs_file_doc},
                    ));
        return $self->goto($goto);
    }
    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");

    $CPAN::META->set_perl5lib;
    local $ENV{MAKEFLAGS}; # protect us from outer make calls

  EXCUSE: {
        my @@e;
        my $goodbye_message;
        $self->debug("checking disabled id[$self->{ID}]") if $CPAN::DEBUG;
        if ($self->prefs->{disabled}) {
            my $why = sprintf(
                              "Disabled via prefs file '%s' doc %d",
                              $self->{prefs_file},
                              $self->{prefs_file_doc},
                             );
            push @@e, $why;
            $self->{unwrapped} = CPAN::Distrostatus->new("NO $why");
            $goodbye_message = "[disabled] -- NA $why";
            # note: not intended to be persistent but at least visible
            # during this session
        } else {
            if (exists $self->{build_dir} && -d $self->{build_dir}
                && ($self->{modulebuild}||$self->{writemakefile})
               ) {
                # this deserves print, not warn:
                $CPAN::Frontend->myprint("  Has already been unwrapped into directory ".
                                         "$self->{build_dir}\n"
                                        );
                return 1;
            }

            # although we talk about 'force' we shall not test on
            # force directly. New model of force tries to refrain from
            # direct checking of force.
            exists $self->{unwrapped} and (
                                           UNIVERSAL::can($self->{unwrapped},"failed") ?
                                           $self->{unwrapped}->failed :
                                           $self->{unwrapped} =~ /^NO/
                                          )
                and push @@e, "Unwrapping had some problem, won't try again without force";
        }
        if (@@e) {
            $CPAN::Frontend->mywarn(join "", map {"$_\n"} @@e);
            if ($goodbye_message) {
                 $self->goodbye($goodbye_message);
            }
            return;
        }
    }
    my $sub_wd = CPAN::anycwd(); # for cleaning up as good as possible

    my($local_file);
    unless ($self->{build_dir} && -d $self->{build_dir}) {
        $self->get_file_onto_local_disk;
        return if $CPAN::Signal;
        $self->check_integrity;
        return if $CPAN::Signal;
        (my $packagedir,$local_file) = $self->run_preps_on_packagedir;
        $packagedir ||= $self->{build_dir};
        $self->{build_dir} = $packagedir;
    }

    if ($CPAN::Signal) {
        $self->safe_chdir($sub_wd);
        return;
    }
    return $self->run_MM_or_MB($local_file);
}

#-> CPAN::Distribution::get_file_onto_local_disk
sub get_file_onto_local_disk {
    my($self) = @@_;

    return if $self->is_dot_dist;
    my($local_file);
    my($local_wanted) =
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,$self->id)
                           );

    $self->debug("Doing localize") if $CPAN::DEBUG;
    unless ($local_file =
            CPAN::FTP->localize("authors/id/$self->{ID}",
                                $local_wanted)) {
        my $note = "";
        if ($CPAN::Index::DATE_OF_02) {
            $note = "Note: Current database in memory was generated ".
                "on $CPAN::Index::DATE_OF_02\n";
        }
        $CPAN::Frontend->mydie("Giving up on '$local_wanted'\n$note");
    }

    $self->debug("local_wanted[$local_wanted]local_file[$local_file]") if $CPAN::DEBUG;
    $self->{localfile} = $local_file;
}


#-> CPAN::Distribution::check_integrity
sub check_integrity {
    my($self) = @@_;

    return if $self->is_dot_dist;
    if ($CPAN::META->has_inst("Digest::SHA")) {
        $self->debug("Digest::SHA is installed, verifying");
        $self->verifyCHECKSUM;
    } else {
        $self->debug("Digest::SHA is NOT installed");
    }
}

#-> CPAN::Distribution::run_preps_on_packagedir
sub run_preps_on_packagedir {
    my($self) = @@_;
    return if $self->is_dot_dist;

    $CPAN::META->{cachemgr} ||= CPAN::CacheMgr->new(); # unsafe meta access, ok
    my $builddir = $CPAN::META->{cachemgr}->dir; # unsafe meta access, ok
    $self->safe_chdir($builddir);
    $self->debug("Removing tmp-$$") if $CPAN::DEBUG;
    File::Path::rmtree("tmp-$$");
    unless (mkdir "tmp-$$", 0755) {
        $CPAN::Frontend->unrecoverable_error(<<EOF);
Couldn't mkdir '$builddir/tmp-$$': $!

Cannot continue: Please find the reason why I cannot make the
directory
$builddir/tmp-$$
and fix the problem, then retry.

EOF
    }
    if ($CPAN::Signal) {
        return;
    }
    $self->safe_chdir("tmp-$$");

    #
    # Unpack the goods
    #
    my $local_file = $self->{localfile};
    my $ct = eval{CPAN::Tarzip->new($local_file)};
    unless ($ct) {
        $self->{unwrapped} = CPAN::Distrostatus->new("NO");
        delete $self->{build_dir};
        return;
    }
    if ($local_file =~ /(\.tar\.(bz2|gz|Z)|\.tgz)(?!\n)\Z/i) {
        $self->{was_uncompressed}++ unless eval{$ct->gtest()};
        $self->untar_me($ct);
    } elsif ( $local_file =~ /\.zip(?!\n)\Z/i ) {
        $self->unzip_me($ct);
    } else {
        $self->{was_uncompressed}++ unless $ct->gtest();
        $local_file = $self->handle_singlefile($local_file);
    }

    # we are still in the tmp directory!
    # Let's check if the package has its own directory.
    my $dh = DirHandle->new(File::Spec->curdir)
        or Carp::croak("Couldn't opendir .: $!");
    my @@readdir = grep $_ !~ /^\.\.?(?!\n)\Z/s, $dh->read; ### MAC??
    $dh->close;
    my ($packagedir);
    # XXX here we want in each branch File::Temp to protect all build_dir directories
    if (CPAN->has_usable("File::Temp")) {
        my $tdir_base;
        my $from_dir;
        my @@dirents;
        if (@@readdir == 1 && -d $readdir[0]) {
            $tdir_base = $readdir[0];
            $from_dir = File::Spec->catdir(File::Spec->curdir,$readdir[0]);
            my $dh2 = DirHandle->new($from_dir)
                or Carp::croak("Couldn't opendir $from_dir: $!");
            @@dirents = grep $_ !~ /^\.\.?(?!\n)\Z/s, $dh2->read; ### MAC??
        } else {
            my $userid = $self->cpan_userid;
            CPAN->debug("userid[$userid]");
            if (!$userid or $userid eq "N/A") {
                $userid = "anon";
            }
            $tdir_base = $userid;
            $from_dir = File::Spec->curdir;
            @@dirents = @@readdir;
        }
        $packagedir = File::Temp::tempdir(
                                          "$tdir_base-XXXXXX",
                                          DIR => $builddir,
                                          CLEANUP => 0,
                                         );
        my $f;
        for $f (@@dirents) { # is already without "." and ".."
            my $from = File::Spec->catdir($from_dir,$f);
            my $to = File::Spec->catdir($packagedir,$f);
            unless (File::Copy::move($from,$to)) {
                my $err = $!;
                $from = File::Spec->rel2abs($from);
                Carp::confess("Couldn't move $from to $to: $err");
            }
        }
    } else { # older code below, still better than nothing when there is no File::Temp
        my($distdir);
        if (@@readdir == 1 && -d $readdir[0]) {
            $distdir = $readdir[0];
            $packagedir = File::Spec->catdir($builddir,$distdir);
            $self->debug("packagedir[$packagedir]builddir[$builddir]distdir[$distdir]")
                if $CPAN::DEBUG;
            -d $packagedir and $CPAN::Frontend->myprint("Removing previously used ".
                                                        "$packagedir\n");
            File::Path::rmtree($packagedir);
            unless (File::Copy::move($distdir,$packagedir)) {
                $CPAN::Frontend->unrecoverable_error(<<EOF);
Couldn't move '$distdir' to '$packagedir': $!

Cannot continue: Please find the reason why I cannot move
$builddir/tmp-$$/$distdir
to
$packagedir
and fix the problem, then retry

EOF
            }
            $self->debug(sprintf("moved distdir[%s] to packagedir[%s] -e[%s]-d[%s]",
                                 $distdir,
                                 $packagedir,
                                 -e $packagedir,
                                 -d $packagedir,
                                )) if $CPAN::DEBUG;
        } else {
            my $userid = $self->cpan_userid;
            CPAN->debug("userid[$userid]") if $CPAN::DEBUG;
            if (!$userid or $userid eq "N/A") {
                $userid = "anon";
            }
            my $pragmatic_dir = $userid . '000';
            $pragmatic_dir =~ s/\W_//g;
            $pragmatic_dir++ while -d "../$pragmatic_dir";
            $packagedir = File::Spec->catdir($builddir,$pragmatic_dir);
            $self->debug("packagedir[$packagedir]") if $CPAN::DEBUG;
            File::Path::mkpath($packagedir);
            my($f);
            for $f (@@readdir) { # is already without "." and ".."
                my $to = File::Spec->catdir($packagedir,$f);
                File::Copy::move($f,$to) or Carp::confess("Couldn't move $f to $to: $!");
            }
        }
    }
    $self->{build_dir} = $packagedir;
    $self->safe_chdir($builddir);
    File::Path::rmtree("tmp-$$");

    $self->safe_chdir($packagedir);
    $self->_signature_business();
    $self->safe_chdir($builddir);

    return($packagedir,$local_file);
}

#-> sub CPAN::Distribution::parse_meta_yml ;
sub parse_meta_yml {
    my($self) = @@_;
    my $build_dir = $self->{build_dir} or die "PANIC: cannot parse yaml without a build_dir";
    my $yaml = File::Spec->catfile($build_dir,"META.yml");
    $self->debug("yaml[$yaml]") if $CPAN::DEBUG;
    return unless -f $yaml;
    my $early_yaml;
    eval {
        require Parse::Metayaml; # hypothetical
        $early_yaml = Parse::Metayaml::LoadFile($yaml)->[0];
    };
    unless ($early_yaml) {
        eval { $early_yaml = CPAN->_yaml_loadfile($yaml)->[0]; };
    }
    unless ($early_yaml) {
        return;
    }
    return $early_yaml;
}

#-> sub CPAN::Distribution::satisfy_configure_requires ;
sub satisfy_configure_requires {
    my($self) = @@_;
    my $enable_configure_requires = 1;
    if (!$enable_configure_requires) {
        return 1;
        # if we return 1 here, everything is as before we introduced
        # configure_requires that means, things with
        # configure_requires simply fail, all others succeed
    }
    my @@prereq = $self->unsat_prereq("configure_requires_later") or return 1;
    if ($self->{configure_requires_later}) {
        for my $k (keys %{$self->{configure_requires_later_for}||{}}) {
            if ($self->{configure_requires_later_for}{$k}>1) {
                # we must not come here a second time
                $CPAN::Frontend->mywarn("Panic: Some prerequisites is not available, please investigate...");
                require YAML::Syck;
                $CPAN::Frontend->mydie
                    (
                     YAML::Syck::Dump
                     ({self=>$self, prereq=>\@@prereq})
                    );
            }
        }
    }
    if ($prereq[0][0] eq "perl") {
        my $need = "requires perl '$prereq[0][1]'";
        my $id = $self->pretty_id;
        $CPAN::Frontend->mywarn("$id $need; you have only $]; giving up\n");
        $self->{make} = CPAN::Distrostatus->new("NO $need");
        $self->store_persistent_state;
        return $self->goodbye("[prereq] -- NOT OK");
    } else {
        my $follow = eval {
            $self->follow_prereqs("configure_requires_later", @@prereq);
        };
        if (0) {
        } elsif ($follow) {
            return;
        } elsif ($@@ && ref $@@ && $@@->isa("CPAN::Exception::RecursiveDependency")) {
            $CPAN::Frontend->mywarn($@@);
            return $self->goodbye("[depend] -- NOT OK");
        }
    }
    die "never reached";
}

#-> sub CPAN::Distribution::run_MM_or_MB ;
sub run_MM_or_MB {
    my($self,$local_file) = @@_;
    $self->satisfy_configure_requires() or return;
    my($mpl) = File::Spec->catfile($self->{build_dir},"Makefile.PL");
    my($mpl_exists) = -f $mpl;
    unless ($mpl_exists) {
        # NFS has been reported to have racing problems after the
        # renaming of a directory in some environments.
        # This trick helps.
        $CPAN::Frontend->mysleep(1);
        my $mpldh = DirHandle->new($self->{build_dir})
            or Carp::croak("Couldn't opendir $self->{build_dir}: $!");
        $mpl_exists = grep /^Makefile\.PL$/, $mpldh->read;
        $mpldh->close;
    }
    my $prefer_installer = "eumm"; # eumm|mb
    if (-f File::Spec->catfile($self->{build_dir},"Build.PL")) {
        if ($mpl_exists) { # they *can* choose
            if ($CPAN::META->has_inst("Module::Build")) {
                $prefer_installer = CPAN::HandleConfig->prefs_lookup($self,
                                                                     q{prefer_installer});
            }
        } else {
            $prefer_installer = "mb";
        }
    }
    return unless $self->patch;
    if (lc($prefer_installer) eq "rand") {
        $prefer_installer = rand()<.5 ? "eumm" : "mb";
    }
    if (lc($prefer_installer) eq "mb") {
        $self->{modulebuild} = 1;
    } elsif ($self->{archived} eq "patch") {
        # not an edge case, nothing to install for sure
        my $why = "A patch file cannot be installed";
        $CPAN::Frontend->mywarn("Refusing to handle this file: $why\n");
        $self->{writemakefile} = CPAN::Distrostatus->new("NO $why");
    } elsif (! $mpl_exists) {
        $self->_edge_cases($mpl,$local_file);
    }
    if ($self->{build_dir}
        &&
        $CPAN::Config->{build_dir_reuse}
       ) {
        $self->store_persistent_state;
    }
    return $self;
}

#-> CPAN::Distribution::store_persistent_state
sub store_persistent_state {
    my($self) = @@_;
    my $dir = $self->{build_dir};
    unless (File::Spec->canonpath(File::Basename::dirname($dir))
            eq File::Spec->canonpath($CPAN::Config->{build_dir})) {
        $CPAN::Frontend->mywarn("Directory '$dir' not below $CPAN::Config->{build_dir}, ".
                                "will not store persistent state\n");
        return;
    }
    my $file = sprintf "%s.yml", $dir;
    my $yaml_module = CPAN::_yaml_module;
    if ($CPAN::META->has_inst($yaml_module)) {
        CPAN->_yaml_dumpfile(
                             $file,
                             {
                              time => time,
                              perl => CPAN::_perl_fingerprint,
                              distribution => $self,
                             }
                            );
    } else {
        $CPAN::Frontend->myprint("Warning (usually harmless): '$yaml_module' not installed, ".
                                "will not store persistent state\n");
    }
}

#-> CPAN::Distribution::try_download
sub try_download {
    my($self,$patch) = @@_;
    my $norm = $self->normalize($patch);
    my($local_wanted) =
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,$norm),
                           );
    $self->debug("Doing localize") if $CPAN::DEBUG;
    return CPAN::FTP->localize("authors/id/$norm",
                               $local_wanted);
}

{
    my $stdpatchargs = "";
    #-> CPAN::Distribution::patch
    sub patch {
        my($self) = @@_;
        $self->debug("checking patches id[$self->{ID}]") if $CPAN::DEBUG;
        my $patches = $self->prefs->{patches};
        $patches ||= "";
        $self->debug("patches[$patches]") if $CPAN::DEBUG;
        if ($patches) {
            return unless @@$patches;
            $self->safe_chdir($self->{build_dir});
            CPAN->debug("patches[$patches]") if $CPAN::DEBUG;
            my $patchbin = $CPAN::Config->{patch};
            unless ($patchbin && length $patchbin) {
                $CPAN::Frontend->mydie("No external patch command configured\n\n".
                                       "Please run 'o conf init /patch/'\n\n");
            }
            unless (MM->maybe_command($patchbin)) {
                $CPAN::Frontend->mydie("No external patch command available\n\n".
                                       "Please run 'o conf init /patch/'\n\n");
            }
            $patchbin = CPAN::HandleConfig->safe_quote($patchbin);
            local $ENV{PATCH_GET} = 0; # formerly known as -g0
            unless ($stdpatchargs) {
                my $system = "$patchbin --version |";
                local *FH;
                open FH, $system or die "Could not fork '$system': $!";
                local $/ = "\n";
                my $pversion;
              PARSEVERSION: while (<FH>) {
                    if (/^patch\s+([\d\.]+)/) {
                        $pversion = $1;
                        last PARSEVERSION;
                    }
                }
                if ($pversion) {
                    $stdpatchargs = "-N --fuzz=3";
                } else {
                    $stdpatchargs = "-N";
                }
            }
            my $countedpatches = @@$patches == 1 ? "1 patch" : (scalar @@$patches . " patches");
            $CPAN::Frontend->myprint("Going to apply $countedpatches:\n");
            for my $patch (@@$patches) {
                unless (-f $patch) {
                    if (my $trydl = $self->try_download($patch)) {
                        $patch = $trydl;
                    } else {
                        my $fail = "Could not find patch '$patch'";
                        $CPAN::Frontend->mywarn("$fail; cannot continue\n");
                        $self->{unwrapped} = CPAN::Distrostatus->new("NO -- $fail");
                        delete $self->{build_dir};
                        return;
                    }
                }
                $CPAN::Frontend->myprint("  $patch\n");
                my $readfh = CPAN::Tarzip->TIEHANDLE($patch);

                my $pcommand;
                my $ppp = $self->_patch_p_parameter($readfh);
                if ($ppp eq "applypatch") {
                    $pcommand = "$CPAN::Config->{applypatch} -verbose";
                } else {
                    my $thispatchargs = join " ", $stdpatchargs, $ppp;
                    $pcommand = "$patchbin $thispatchargs";
                }

                $readfh = CPAN::Tarzip->TIEHANDLE($patch); # open again
                my $writefh = FileHandle->new;
                $CPAN::Frontend->myprint("  $pcommand\n");
                unless (open $writefh, "|$pcommand") {
                    my $fail = "Could not fork '$pcommand'";
                    $CPAN::Frontend->mywarn("$fail; cannot continue\n");
                    $self->{unwrapped} = CPAN::Distrostatus->new("NO -- $fail");
                    delete $self->{build_dir};
                    return;
                }
                while (my $x = $readfh->READLINE) {
                    print $writefh $x;
                }
                unless (close $writefh) {
                    my $fail = "Could not apply patch '$patch'";
                    $CPAN::Frontend->mywarn("$fail; cannot continue\n");
                    $self->{unwrapped} = CPAN::Distrostatus->new("NO -- $fail");
                    delete $self->{build_dir};
                    return;
                }
            }
            $self->{patched}++;
        }
        return 1;
    }
}

sub _patch_p_parameter {
    my($self,$fh) = @@_;
    my $cnt_files   = 0;
    my $cnt_p0files = 0;
    local($_);
    while ($_ = $fh->READLINE) {
        if (
            $CPAN::Config->{applypatch}
            &&
            /\#\#\#\# ApplyPatch data follows \#\#\#\#/
           ) {
            return "applypatch"
        }
        next unless /^[\*\+]{3}\s(\S+)/;
        my $file = $1;
        $cnt_files++;
        $cnt_p0files++ if -f $file;
        CPAN->debug("file[$file]cnt_files[$cnt_files]cnt_p0files[$cnt_p0files]")
            if $CPAN::DEBUG;
    }
    return "-p1" unless $cnt_files;
    return $cnt_files==$cnt_p0files ? "-p0" : "-p1";
}

#-> sub CPAN::Distribution::_edge_cases
# with "configure" or "Makefile" or single file scripts
sub _edge_cases {
    my($self,$mpl,$local_file) = @@_;
    $self->debug(sprintf("makefilepl[%s]anycwd[%s]",
                         $mpl,
                         CPAN::anycwd(),
                        )) if $CPAN::DEBUG;
    my $build_dir = $self->{build_dir};
    my($configure) = File::Spec->catfile($build_dir,"Configure");
    if (-f $configure) {
        # do we have anything to do?
        $self->{configure} = $configure;
    } elsif (-f File::Spec->catfile($build_dir,"Makefile")) {
        $CPAN::Frontend->mywarn(qq{
Package comes with a Makefile and without a Makefile.PL.
We\'ll try to build it with that Makefile then.
});
        $self->{writemakefile} = CPAN::Distrostatus->new("YES");
        $CPAN::Frontend->mysleep(2);
    } else {
        my $cf = $self->called_for || "unknown";
        if ($cf =~ m|/|) {
            $cf =~ s|.*/||;
            $cf =~ s|\W.*||;
        }
        $cf =~ s|[/\\:]||g;     # risk of filesystem damage
        $cf = "unknown" unless length($cf);
        $CPAN::Frontend->mywarn(qq{Package seems to come without Makefile.PL.
  (The test -f "$mpl" returned false.)
  Writing one on our own (setting NAME to $cf)\a\n});
        $self->{had_no_makefile_pl}++;
        $CPAN::Frontend->mysleep(3);

        # Writing our own Makefile.PL

        my $script = "";
        if ($self->{archived} eq "maybe_pl") {
            my $fh = FileHandle->new;
            my $script_file = File::Spec->catfile($build_dir,$local_file);
            $fh->open($script_file)
                or Carp::croak("Could not open script '$script_file': $!");
            local $/ = "\n";
            # name parsen und prereq
            my($state) = "poddir";
            my($name, $prereq) = ("", "");
            while (<$fh>) {
                if ($state eq "poddir" && /^=head\d\s+(\S+)/) {
                    if ($1 eq 'NAME') {
                        $state = "name";
                    } elsif ($1 eq 'PREREQUISITES') {
                        $state = "prereq";
                    }
                } elsif ($state =~ m{^(name|prereq)$}) {
                    if (/^=/) {
                        $state = "poddir";
                    } elsif (/^\s*$/) {
                        # nop
                    } elsif ($state eq "name") {
                        if ($name eq "") {
                            ($name) = /^(\S+)/;
                            $state = "poddir";
                        }
                    } elsif ($state eq "prereq") {
                        $prereq .= $_;
                    }
                } elsif (/^=cut\b/) {
                    last;
                }
            }
            $fh->close;

            for ($name) {
                s{.*<}{};       # strip X<...>
                s{>.*}{};
            }
            chomp $prereq;
            $prereq = join " ", split /\s+/, $prereq;
            my($PREREQ_PM) = join("\n", map {
                s{.*<}{};       # strip X<...>
                s{>.*}{};
                if (/[\s\'\"]/) { # prose?
                } else {
                    s/[^\w:]$//; # period?
                    " "x28 . "'$_' => 0,";
                }
            } split /\s*,\s*/, $prereq);

            $script = "
              EXE_FILES => ['$name'],
              PREREQ_PM => {
$PREREQ_PM
                           },
";
            if ($name) {
                my $to_file = File::Spec->catfile($build_dir, $name);
                rename $script_file, $to_file
                    or die "Can't rename $script_file to $to_file: $!";
            }
        }

        my $fh = FileHandle->new;
        $fh->open(">$mpl")
            or Carp::croak("Could not open >$mpl: $!");
        $fh->print(
                   qq{# This Makefile.PL has been autogenerated by the module CPAN.pm
# because there was no Makefile.PL supplied.
# Autogenerated on: }.scalar localtime().qq{

use ExtUtils::MakeMaker;
WriteMakefile(
              NAME => q[$cf],$script
             );
});
        $fh->close;
    }
}

#-> CPAN::Distribution::_signature_business
sub _signature_business {
    my($self) = @@_;
    my $check_sigs = CPAN::HandleConfig->prefs_lookup($self,
                                                      q{check_sigs});
    if ($check_sigs) {
        if ($CPAN::META->has_inst("Module::Signature")) {
            if (-f "SIGNATURE") {
                $self->debug("Module::Signature is installed, verifying") if $CPAN::DEBUG;
                my $rv = Module::Signature::verify();
                if ($rv != Module::Signature::SIGNATURE_OK() and
                    $rv != Module::Signature::SIGNATURE_MISSING()) {
                    $CPAN::Frontend->mywarn(
                                            qq{\nSignature invalid for }.
                                            qq{distribution file. }.
                                            qq{Please investigate.\n\n}
                                           );

                    my $wrap =
                        sprintf(qq{I'd recommend removing %s. Some error occured    }.
                                qq{while checking its signature, so it could        }.
                                qq{be invalid. Maybe you have configured            }.
                                qq{your 'urllist' with a bad URL. Please check this }.
                                qq{array with 'o conf urllist' and retry. Or        }.
                                qq{examine the distribution in a subshell. Try
  look %s
and run
  cpansign -v
},
                                $self->{localfile},
                                $self->pretty_id,
                               );
                    $self->{signature_verify} = CPAN::Distrostatus->new("NO");
                    $CPAN::Frontend->mywarn(Text::Wrap::wrap("","",$wrap));
                    $CPAN::Frontend->mysleep(5) if $CPAN::Frontend->can("mysleep");
                } else {
                    $self->{signature_verify} = CPAN::Distrostatus->new("YES");
                    $self->debug("Module::Signature has verified") if $CPAN::DEBUG;
                }
            } else {
                $CPAN::Frontend->mywarn(qq{Package came without SIGNATURE\n\n});
            }
        } else {
            $self->debug("Module::Signature is NOT installed") if $CPAN::DEBUG;
        }
    }
}

#-> CPAN::Distribution::untar_me ;
sub untar_me {
    my($self,$ct) = @@_;
    $self->{archived} = "tar";
    if ($ct->untar()) {
        $self->{unwrapped} = CPAN::Distrostatus->new("YES");
    } else {
        $self->{unwrapped} = CPAN::Distrostatus->new("NO -- untar failed");
    }
}

# CPAN::Distribution::unzip_me ;
sub unzip_me {
    my($self,$ct) = @@_;
    $self->{archived} = "zip";
    if ($ct->unzip()) {
        $self->{unwrapped} = CPAN::Distrostatus->new("YES");
    } else {
        $self->{unwrapped} = CPAN::Distrostatus->new("NO -- unzip failed");
    }
    return;
}

sub handle_singlefile {
    my($self,$local_file) = @@_;

    if ( $local_file =~ /\.pm(\.(gz|Z))?(?!\n)\Z/ ) {
        $self->{archived} = "pm";
    } elsif ( $local_file =~ /\.patch(\.(gz|bz2))?(?!\n)\Z/ ) {
        $self->{archived} = "patch";
    } else {
        $self->{archived} = "maybe_pl";
    }

    my $to = File::Basename::basename($local_file);
    if ($to =~ s/\.(gz|Z)(?!\n)\Z//) {
        if (eval{CPAN::Tarzip->new($local_file)->gunzip($to)}) {
            $self->{unwrapped} = CPAN::Distrostatus->new("YES");
        } else {
            $self->{unwrapped} = CPAN::Distrostatus->new("NO -- uncompressing failed");
        }
    } else {
        if (File::Copy::cp($local_file,".")) {
            $self->{unwrapped} = CPAN::Distrostatus->new("YES");
        } else {
            $self->{unwrapped} = CPAN::Distrostatus->new("NO -- copying failed");
        }
    }
    return $to;
}

#-> sub CPAN::Distribution::new ;
sub new {
    my($class,%att) = @@_;

    # $CPAN::META->{cachemgr} ||= CPAN::CacheMgr->new();

    my $this = { %att };
    return bless $this, $class;
}

#-> sub CPAN::Distribution::look ;
sub look {
    my($self) = @@_;

    if ($^O eq 'MacOS') {
      $self->Mac::BuildTools::look;
      return;
    }

    if (  $CPAN::Config->{'shell'} ) {
        $CPAN::Frontend->myprint(qq{
Trying to open a subshell in the build directory...
});
    } else {
        $CPAN::Frontend->myprint(qq{
Your configuration does not define a value for subshells.
Please define it with "o conf shell <your shell>"
});
        return;
    }
    my $dist = $self->id;
    my $dir;
    unless ($dir = $self->dir) {
        $self->get;
    }
    unless ($dir ||= $self->dir) {
        $CPAN::Frontend->mywarn(qq{
Could not determine which directory to use for looking at $dist.
});
        return;
    }
    my $pwd  = CPAN::anycwd();
    $self->safe_chdir($dir);
    $CPAN::Frontend->myprint(qq{Working directory is $dir\n});
    {
        local $ENV{CPAN_SHELL_LEVEL} = $ENV{CPAN_SHELL_LEVEL}||0;
        $ENV{CPAN_SHELL_LEVEL} += 1;
        my $shell = CPAN::HandleConfig->safe_quote($CPAN::Config->{'shell'});
        unless (system($shell) == 0) {
            my $code = $? >> 8;
            $CPAN::Frontend->mywarn("Subprocess shell exit code $code\n");
        }
    }
    $self->safe_chdir($pwd);
}

# CPAN::Distribution::cvs_import ;
sub cvs_import {
    my($self) = @@_;
    $self->get;
    my $dir = $self->dir;

    my $package = $self->called_for;
    my $module = $CPAN::META->instance('CPAN::Module', $package);
    my $version = $module->cpan_version;

    my $userid = $self->cpan_userid;

    my $cvs_dir = (split /\//, $dir)[-1];
    $cvs_dir =~ s/-\d+[^-]+(?!\n)\Z//;
    my $cvs_root =
      $CPAN::Config->{cvsroot} || $ENV{CVSROOT};
    my $cvs_site_perl =
      $CPAN::Config->{cvs_site_perl} || $ENV{CVS_SITE_PERL};
    if ($cvs_site_perl) {
        $cvs_dir = "$cvs_site_perl/$cvs_dir";
    }
    my $cvs_log = qq{"imported $package $version sources"};
    $version =~ s/\./_/g;
    # XXX cvs: undocumented and unclear how it was meant to work
    my @@cmd = ('cvs', '-d', $cvs_root, 'import', '-m', $cvs_log,
               "$cvs_dir", $userid, "v$version");

    my $pwd  = CPAN::anycwd();
    chdir($dir) or $CPAN::Frontend->mydie(qq{Could not chdir to "$dir": $!});

    $CPAN::Frontend->myprint(qq{Working directory is $dir\n});

    $CPAN::Frontend->myprint(qq{@@cmd\n});
    system(@@cmd) == 0 or
    # XXX cvs
        $CPAN::Frontend->mydie("cvs import failed");
    chdir($pwd) or $CPAN::Frontend->mydie(qq{Could not chdir to "$pwd": $!});
}

#-> sub CPAN::Distribution::readme ;
sub readme {
    my($self) = @@_;
    my($dist) = $self->id;
    my($sans,$suffix) = $dist =~ /(.+)\.(tgz|tar[\._-]gz|tar\.Z|zip)$/;
    $self->debug("sans[$sans] suffix[$suffix]\n") if $CPAN::DEBUG;
    my($local_file);
    my($local_wanted) =
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,"$sans.readme"),
                           );
    $self->debug("Doing localize") if $CPAN::DEBUG;
    $local_file = CPAN::FTP->localize("authors/id/$sans.readme",
                                      $local_wanted)
        or $CPAN::Frontend->mydie(qq{No $sans.readme found});;

    if ($^O eq 'MacOS') {
        Mac::BuildTools::launch_file($local_file);
        return;
    }

    my $fh_pager = FileHandle->new;
    local($SIG{PIPE}) = "IGNORE";
    my $pager = $CPAN::Config->{'pager'} || "cat";
    $fh_pager->open("|$pager")
        or die "Could not open pager $pager\: $!";
    my $fh_readme = FileHandle->new;
    $fh_readme->open($local_file)
        or $CPAN::Frontend->mydie(qq{Could not open "$local_file": $!});
    $CPAN::Frontend->myprint(qq{
Displaying file
  $local_file
with pager "$pager"
});
    $fh_pager->print(<$fh_readme>);
    $fh_pager->close;
}

#-> sub CPAN::Distribution::verifyCHECKSUM ;
sub verifyCHECKSUM {
    my($self) = @@_;
  EXCUSE: {
        my @@e;
        $self->{CHECKSUM_STATUS} ||= "";
        $self->{CHECKSUM_STATUS} eq "OK" and push @@e, "Checksum was ok";
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    my($lc_want,$lc_file,@@local,$basename);
    @@local = split(/\//,$self->id);
    pop @@local;
    push @@local, "CHECKSUMS";
    $lc_want =
        File::Spec->catfile($CPAN::Config->{keep_source_where},
                            "authors", "id", @@local);
    local($") = "/";
    if (my $size = -s $lc_want) {
        $self->debug("lc_want[$lc_want]size[$size]") if $CPAN::DEBUG;
        if ($self->CHECKSUM_check_file($lc_want,1)) {
            return $self->{CHECKSUM_STATUS} = "OK";
        }
    }
    $lc_file = CPAN::FTP->localize("authors/id/@@local",
                                   $lc_want,1);
    unless ($lc_file) {
        $CPAN::Frontend->myprint("Trying $lc_want.gz\n");
        $local[-1] .= ".gz";
        $lc_file = CPAN::FTP->localize("authors/id/@@local",
                                       "$lc_want.gz",1);
        if ($lc_file) {
            $lc_file =~ s/\.gz(?!\n)\Z//;
            eval{CPAN::Tarzip->new("$lc_file.gz")->gunzip($lc_file)};
        } else {
            return;
        }
    }
    if ($self->CHECKSUM_check_file($lc_file)) {
        return $self->{CHECKSUM_STATUS} = "OK";
    }
}

#-> sub CPAN::Distribution::SIG_check_file ;
sub SIG_check_file {
    my($self,$chk_file) = @@_;
    my $rv = eval { Module::Signature::_verify($chk_file) };

    if ($rv == Module::Signature::SIGNATURE_OK()) {
        $CPAN::Frontend->myprint("Signature for $chk_file ok\n");
        return $self->{SIG_STATUS} = "OK";
    } else {
        $CPAN::Frontend->myprint(qq{\nSignature invalid for }.
                                 qq{distribution file. }.
                                 qq{Please investigate.\n\n}.
                                 $self->as_string,
                                 $CPAN::META->instance(
                                                       'CPAN::Author',
                                                       $self->cpan_userid
                                                      )->as_string);

        my $wrap = qq{I\'d recommend removing $chk_file. Its signature
is invalid. Maybe you have configured your 'urllist' with
a bad URL. Please check this array with 'o conf urllist', and
retry.};

        $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));
    }
}

#-> sub CPAN::Distribution::CHECKSUM_check_file ;

# sloppy is 1 when we have an old checksums file that maybe is good
# enough

sub CHECKSUM_check_file {
    my($self,$chk_file,$sloppy) = @@_;
    my($cksum,$file,$basename);

    $sloppy ||= 0;
    $self->debug("chk_file[$chk_file]sloppy[$sloppy]") if $CPAN::DEBUG;
    my $check_sigs = CPAN::HandleConfig->prefs_lookup($self,
                                                      q{check_sigs});
    if ($check_sigs) {
        if ($CPAN::META->has_inst("Module::Signature")) {
            $self->debug("Module::Signature is installed, verifying") if $CPAN::DEBUG;
            $self->SIG_check_file($chk_file);
        } else {
            $self->debug("Module::Signature is NOT installed") if $CPAN::DEBUG;
        }
    }

    $file = $self->{localfile};
    $basename = File::Basename::basename($file);
    my $fh = FileHandle->new;
    if (open $fh, $chk_file) {
        local($/);
        my $eval = <$fh>;
        $eval =~ s/\015?\012/\n/g;
        close $fh;
        my($comp) = Safe->new();
        $cksum = $comp->reval($eval);
        if ($@@) {
            rename $chk_file, "$chk_file.bad";
            Carp::confess($@@) if $@@;
        }
    } else {
        Carp::carp "Could not open $chk_file for reading";
    }

    if (! ref $cksum or ref $cksum ne "HASH") {
        $CPAN::Frontend->mywarn(qq{
Warning: checksum file '$chk_file' broken.

When trying to read that file I expected to get a hash reference
for further processing, but got garbage instead.
});
        my $answer = CPAN::Shell::colorable_makemaker_prompt("Proceed nonetheless?", "no");
        $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted.\n");
        $self->{CHECKSUM_STATUS} = "NIL -- CHECKSUMS file broken";
        return;
    } elsif (exists $cksum->{$basename}{sha256}) {
        $self->debug("Found checksum for $basename:" .
                     "$cksum->{$basename}{sha256}\n") if $CPAN::DEBUG;

        open($fh, $file);
        binmode $fh;
        my $eq = $self->eq_CHECKSUM($fh,$cksum->{$basename}{sha256});
        $fh->close;
        $fh = CPAN::Tarzip->TIEHANDLE($file);

        unless ($eq) {
            my $dg = Digest::SHA->new(256);
            my($data,$ref);
            $ref = \$data;
            while ($fh->READ($ref, 4096) > 0) {
                $dg->add($data);
            }
            my $hexdigest = $dg->hexdigest;
            $eq += $hexdigest eq $cksum->{$basename}{'sha256-ungz'};
        }

        if ($eq) {
            $CPAN::Frontend->myprint("Checksum for $file ok\n");
            return $self->{CHECKSUM_STATUS} = "OK";
        } else {
            $CPAN::Frontend->myprint(qq{\nChecksum mismatch for }.
                                     qq{distribution file. }.
                                     qq{Please investigate.\n\n}.
                                     $self->as_string,
                                     $CPAN::META->instance(
                                                           'CPAN::Author',
                                                           $self->cpan_userid
                                                          )->as_string);

            my $wrap = qq{I\'d recommend removing $file. Its
checksum is incorrect. Maybe you have configured your 'urllist' with
a bad URL. Please check this array with 'o conf urllist', and
retry.};

            $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));

            # former versions just returned here but this seems a
            # serious threat that deserves a die

            # $CPAN::Frontend->myprint("\n\n");
            # sleep 3;
            # return;
        }
        # close $fh if fileno($fh);
    } else {
        return if $sloppy;
        unless ($self->{CHECKSUM_STATUS}) {
            $CPAN::Frontend->mywarn(qq{
Warning: No checksum for $basename in $chk_file.

The cause for this may be that the file is very new and the checksum
has not yet been calculated, but it may also be that something is
going awry right now.
});
            my $answer = CPAN::Shell::colorable_makemaker_prompt("Proceed?", "yes");
            $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted.\n");
        }
        $self->{CHECKSUM_STATUS} = "NIL -- distro not in CHECKSUMS file";
        return;
    }
}

#-> sub CPAN::Distribution::eq_CHECKSUM ;
sub eq_CHECKSUM {
    my($self,$fh,$expect) = @@_;
    if ($CPAN::META->has_inst("Digest::SHA")) {
        my $dg = Digest::SHA->new(256);
        my($data);
        while (read($fh, $data, 4096)) {
            $dg->add($data);
        }
        my $hexdigest = $dg->hexdigest;
        # warn "fh[$fh] hex[$hexdigest] aexp[$expectMD5]";
        return $hexdigest eq $expect;
    }
    return 1;
}

#-> sub CPAN::Distribution::force ;

# Both CPAN::Modules and CPAN::Distributions know if "force" is in
# effect by autoinspection, not by inspecting a global variable. One
# of the reason why this was chosen to work that way was the treatment
# of dependencies. They should not automatically inherit the force
# status. But this has the downside that ^C and die() will return to
# the prompt but will not be able to reset the force_update
# attributes. We try to correct for it currently in the read_metadata
# routine, and immediately before we check for a Signal. I hope this
# works out in one of v1.57_53ff

# "Force get forgets previous error conditions"

#-> sub CPAN::Distribution::fforce ;
sub fforce {
  my($self, $method) = @@_;
  $self->force($method,1);
}

#-> sub CPAN::Distribution::force ;
sub force {
  my($self, $method,$fforce) = @@_;
  my %phase_map = (
                   get => [
                           "unwrapped",
                           "build_dir",
                           "archived",
                           "localfile",
                           "CHECKSUM_STATUS",
                           "signature_verify",
                           "prefs",
                           "prefs_file",
                           "prefs_file_doc",
                          ],
                   make => [
                            "writemakefile",
                            "make",
                            "modulebuild",
                            "prereq_pm",
                            "prereq_pm_detected",
                           ],
                   test => [
                            "badtestcnt",
                            "make_test",
                           ],
                   install => [
                               "install",
                              ],
                   unknown => [
                               "reqtype",
                               "yaml_content",
                              ],
                  );
  my $methodmatch = 0;
  my $ldebug = 0;
 PHASE: for my $phase (qw(unknown get make test install)) { # order matters
      $methodmatch = 1 if $fforce || $phase eq $method;
      next unless $methodmatch;
    ATTRIBUTE: for my $att (@@{$phase_map{$phase}}) {
          if ($phase eq "get") {
              if (substr($self->id,-1,1) eq "."
                  && $att =~ /(unwrapped|build_dir|archived)/ ) {
                  # cannot be undone for local distros
                  next ATTRIBUTE;
              }
              if ($att eq "build_dir"
                  && $self->{build_dir}
                  && $CPAN::META->{is_tested}
                 ) {
                  delete $CPAN::META->{is_tested}{$self->{build_dir}};
              }
          } elsif ($phase eq "test") {
              if ($att eq "make_test"
                  && $self->{make_test}
                  && $self->{make_test}{COMMANDID}
                  && $self->{make_test}{COMMANDID} == $CPAN::CurrentCommandId
                 ) {
                  # endless loop too likely
                  next ATTRIBUTE;
              }
          }
          delete $self->{$att};
          if ($ldebug || $CPAN::DEBUG) {
              # local $CPAN::DEBUG = 16; # Distribution
              CPAN->debug(sprintf "id[%s]phase[%s]att[%s]", $self->id, $phase, $att);
          }
      }
  }
  if ($method && $method =~ /make|test|install/) {
    $self->{force_update} = 1; # name should probably have been force_install
  }
}

#-> sub CPAN::Distribution::notest ;
sub notest {
  my($self, $method) = @@_;
  # $CPAN::Frontend->mywarn("XDEBUG: set notest for $self $method");
  $self->{"notest"}++; # name should probably have been force_install
}

#-> sub CPAN::Distribution::unnotest ;
sub unnotest {
  my($self) = @@_;
  # warn "XDEBUG: deleting notest";
  delete $self->{notest};
}

#-> sub CPAN::Distribution::unforce ;
sub unforce {
  my($self) = @@_;
  delete $self->{force_update};
}

#-> sub CPAN::Distribution::isa_perl ;
sub isa_perl {
  my($self) = @@_;
  my $file = File::Basename::basename($self->id);
  if ($file =~ m{ ^ perl
                  -?
                  (5)
                  ([._-])
                  (
                   \d{3}(_[0-4][0-9])?
                   |
                   \d+\.\d+
                  )
                  \.tar[._-](?:gz|bz2)
                  (?!\n)\Z
                }xs) {
    return "$1.$3";
  } elsif ($self->cpan_comment
           &&
           $self->cpan_comment =~ /isa_perl\(.+?\)/) {
    return $1;
  }
}


#-> sub CPAN::Distribution::perl ;
sub perl {
    my ($self) = @@_;
    if (! $self) {
        use Carp qw(carp);
        carp __PACKAGE__ . "::perl was called without parameters.";
    }
    return CPAN::HandleConfig->safe_quote($CPAN::Perl);
}


#-> sub CPAN::Distribution::make ;
sub make {
    my($self) = @@_;
    if (my $goto = $self->prefs->{goto}) {
        return $self->goto($goto);
    }
    my $make = $self->{modulebuild} ? "Build" : "make";
    # Emergency brake if they said install Pippi and get newest perl
    if ($self->isa_perl) {
        if (
            $self->called_for ne $self->id &&
            ! $self->{force_update}
        ) {
            # if we die here, we break bundles
            $CPAN::Frontend
                ->mywarn(sprintf(
                            qq{The most recent version "%s" of the module "%s"
is part of the perl-%s distribution. To install that, you need to run
  force install %s   --or--
  install %s
},
                             $CPAN::META->instance(
                                                   'CPAN::Module',
                                                   $self->called_for
                                                  )->cpan_version,
                             $self->called_for,
                             $self->isa_perl,
                             $self->called_for,
                             $self->id,
                            ));
            $self->{make} = CPAN::Distrostatus->new("NO isa perl");
            $CPAN::Frontend->mysleep(1);
            return;
        }
    }
    $CPAN::Frontend->myprint(sprintf "Running %s for %s\n", $make, $self->id);
    $self->get;
    if ($self->{configure_requires_later}) {
        return;
    }
    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");
    $CPAN::META->set_perl5lib;
    local $ENV{MAKEFLAGS}; # protect us from outer make calls

    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }

    my $builddir;
  EXCUSE: {
        my @@e;
        if (!$self->{archived} || $self->{archived} eq "NO") {
            push @@e, "Is neither a tar nor a zip archive.";
        }

        if (!$self->{unwrapped}
            || (
                UNIVERSAL::can($self->{unwrapped},"failed") ?
                $self->{unwrapped}->failed :
                $self->{unwrapped} =~ /^NO/
               )) {
            push @@e, "Had problems unarchiving. Please build manually";
        }

        unless ($self->{force_update}) {
            exists $self->{signature_verify} and
                (
                 UNIVERSAL::can($self->{signature_verify},"failed") ?
                 $self->{signature_verify}->failed :
                 $self->{signature_verify} =~ /^NO/
                )
                and push @@e, "Did not pass the signature test.";
        }

        if (exists $self->{writemakefile} &&
            (
             UNIVERSAL::can($self->{writemakefile},"failed") ?
             $self->{writemakefile}->failed :
             $self->{writemakefile} =~ /^NO/
            )) {
            # XXX maybe a retry would be in order?
            my $err = UNIVERSAL::can($self->{writemakefile},"text") ?
                $self->{writemakefile}->text :
                    $self->{writemakefile};
            $err =~ s/^NO\s*//;
            $err ||= "Had some problem writing Makefile";
            $err .= ", won't make";
            push @@e, $err;
        }

        if (defined $self->{make}) {
            if (UNIVERSAL::can($self->{make},"failed") ?
                $self->{make}->failed :
                $self->{make} =~ /^NO/) {
                if ($self->{force_update}) {
                    # Trying an already failed 'make' (unless somebody else blocks)
                } else {
                    # introduced for turning recursion detection into a distrostatus
                    my $error = length $self->{make}>3
                        ? substr($self->{make},3) : "Unknown error";
                    $CPAN::Frontend->mywarn("Could not make: $error\n");
                    $self->store_persistent_state;
                    return;
                }
            } else {
                push @@e, "Has already been made";
            }
        }

        my $later = $self->{later} || $self->{configure_requires_later};
        if ($later) { # see also undelay
            if ($later) {
                push @@e, $later;
            }
        }

        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
        $builddir = $self->dir or
            $CPAN::Frontend->mydie("PANIC: Cannot determine build directory\n");
        unless (chdir $builddir) {
            push @@e, "Couldn't chdir to '$builddir': $!";
        }
        $CPAN::Frontend->mywarn(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }
    $CPAN::Frontend->myprint("\n  CPAN.pm: Going to build ".$self->id."\n\n");
    $self->debug("Changed directory to $builddir") if $CPAN::DEBUG;

    if ($^O eq 'MacOS') {
        Mac::BuildTools::make($self);
        return;
    }

    my %env;
    while (my($k,$v) = each %ENV) {
        next unless defined $v;
        $env{$k} = $v;
    }
    local %ENV = %env;
    my $system;
    if (my $commandline = $self->prefs->{pl}{commandline}) {
        $system = $commandline;
        $ENV{PERL} = $^X;
    } elsif ($self->{'configure'}) {
        $system = $self->{'configure'};
    } elsif ($self->{modulebuild}) {
        my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
        $system = "$perl Build.PL $CPAN::Config->{mbuildpl_arg}";
    } else {
        my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
        my $switch = "";
# This needs a handler that can be turned on or off:
#        $switch = "-MExtUtils::MakeMaker ".
#            "-Mops=:default,:filesys_read,:filesys_open,require,chdir"
#            if $] > 5.00310;
        my $makepl_arg = $self->make_x_arg("pl");
        $ENV{PERL5_CPAN_IS_EXECUTING} = File::Spec->catfile($self->{build_dir},
                                                            "Makefile.PL");
        $system = sprintf("%s%s Makefile.PL%s",
                          $perl,
                          $switch ? " $switch" : "",
                          $makepl_arg ? " $makepl_arg" : "",
                         );
    }
    if (my $env = $self->prefs->{pl}{env}) {
        for my $e (keys %$env) {
            $ENV{$e} = $env->{$e};
        }
    }
    if (exists $self->{writemakefile}) {
    } else {
        local($SIG{ALRM}) = sub { die "inactivity_timeout reached\n" };
        my($ret,$pid,$output);
        $@@ = "";
        my $go_via_alarm;
        if ($CPAN::Config->{inactivity_timeout}) {
            require Config;
            if ($Config::Config{d_alarm}
                &&
                $Config::Config{d_alarm} eq "define"
               ) {
                $go_via_alarm++
            } else {
                $CPAN::Frontend->mywarn("Warning: you have configured the config ".
                                        "variable 'inactivity_timeout' to ".
                                        "'$CPAN::Config->{inactivity_timeout}'. But ".
                                        "on this machine the system call 'alarm' ".
                                        "isn't available. This means that we cannot ".
                                        "provide the feature of intercepting long ".
                                        "waiting code and will turn this feature off.\n"
                                       );
                $CPAN::Config->{inactivity_timeout} = 0;
            }
        }
        if ($go_via_alarm) {
            if ( $self->_should_report('pl') ) {
                ($output, $ret) = CPAN::Reporter::record_command(
                    $system,
                    $CPAN::Config->{inactivity_timeout},
                );
                CPAN::Reporter::grade_PL( $self, $system, $output, $ret );
            }
            else {
                eval {
                    alarm $CPAN::Config->{inactivity_timeout};
                    local $SIG{CHLD}; # = sub { wait };
                    if (defined($pid = fork)) {
                        if ($pid) { #parent
                            # wait;
                            waitpid $pid, 0;
                        } else {    #child
                            # note, this exec isn't necessary if
                            # inactivity_timeout is 0. On the Mac I'd
                            # suggest, we set it always to 0.
                            exec $system;
                        }
                    } else {
                        $CPAN::Frontend->myprint("Cannot fork: $!");
                        return;
                    }
                };
                alarm 0;
                if ($@@) {
                    kill 9, $pid;
                    waitpid $pid, 0;
                    my $err = "$@@";
                    $CPAN::Frontend->myprint($err);
                    $self->{writemakefile} = CPAN::Distrostatus->new("NO $err");
                    $@@ = "";
                    $self->store_persistent_state;
                    return $self->goodbye("$system -- TIMED OUT");
                }
            }
        } else {
            if (my $expect_model = $self->_prefs_with_expect("pl")) {
                # XXX probably want to check _should_report here and warn
                # about not being able to use CPAN::Reporter with expect
                $ret = $self->_run_via_expect($system,$expect_model);
                if (! defined $ret
                    && $self->{writemakefile}
                    && $self->{writemakefile}->failed) {
                    # timeout
                    return;
                }
            }
            elsif ( $self->_should_report('pl') ) {
                ($output, $ret) = CPAN::Reporter::record_command($system);
                CPAN::Reporter::grade_PL( $self, $system, $output, $ret );
            }
            else {
                $ret = system($system);
            }
            if ($ret != 0) {
                $self->{writemakefile} = CPAN::Distrostatus
                    ->new("NO '$system' returned status $ret");
                $CPAN::Frontend->mywarn("Warning: No success on command[$system]\n");
                $self->store_persistent_state;
                return $self->goodbye("$system -- NOT OK");
            }
        }
        if (-f "Makefile" || -f "Build") {
            $self->{writemakefile} = CPAN::Distrostatus->new("YES");
            delete $self->{make_clean}; # if cleaned before, enable next
        } else {
            my $makefile = $self->{modulebuild} ? "Build" : "Makefile";
            $self->{writemakefile} = CPAN::Distrostatus
                ->new(qq{NO -- No $makefile created});
            $self->store_persistent_state;
            return $self->goodbye("$system -- NO $makefile created");
        }
    }
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }
    if (my @@prereq = $self->unsat_prereq("later")) {
        if ($prereq[0][0] eq "perl") {
            my $need = "requires perl '$prereq[0][1]'";
            my $id = $self->pretty_id;
            $CPAN::Frontend->mywarn("$id $need; you have only $]; giving up\n");
            $self->{make} = CPAN::Distrostatus->new("NO $need");
            $self->store_persistent_state;
            return $self->goodbye("[prereq] -- NOT OK");
        } else {
            my $follow = eval { $self->follow_prereqs("later",@@prereq); };
            if (0) {
            } elsif ($follow) {
                # signal success to the queuerunner
                return 1;
            } elsif ($@@ && ref $@@ && $@@->isa("CPAN::Exception::RecursiveDependency")) {
                $CPAN::Frontend->mywarn($@@);
                return $self->goodbye("[depend] -- NOT OK");
            }
        }
    }
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }
    if (my $commandline = $self->prefs->{make}{commandline}) {
        $system = $commandline;
        $ENV{PERL} = CPAN::find_perl;
    } else {
        if ($self->{modulebuild}) {
            unless (-f "Build") {
                my $cwd = CPAN::anycwd();
                $CPAN::Frontend->mywarn("Alert: no Build file available for 'make $self->{id}'".
                                        " in cwd[$cwd]. Danger, Will Robinson!\n");
                $CPAN::Frontend->mysleep(5);
            }
            $system = join " ", $self->_build_command(), $CPAN::Config->{mbuild_arg};
        } else {
            $system = join " ", $self->_make_command(),  $CPAN::Config->{make_arg};
        }
        $system =~ s/\s+$//;
        my $make_arg = $self->make_x_arg("make");
        $system = sprintf("%s%s",
                          $system,
                          $make_arg ? " $make_arg" : "",
                         );
    }
    if (my $env = $self->prefs->{make}{env}) { # overriding the local
                                               # ENV of PL, not the
                                               # outer ENV, but
                                               # unlikely to be a risk
        for my $e (keys %$env) {
            $ENV{$e} = $env->{$e};
        }
    }
    my $expect_model = $self->_prefs_with_expect("make");
    my $want_expect = 0;
    if ( $expect_model && @@{$expect_model->{talk}} ) {
        my $can_expect = $CPAN::META->has_inst("Expect");
        if ($can_expect) {
            $want_expect = 1;
        } else {
            $CPAN::Frontend->mywarn("Expect not installed, falling back to ".
                                    "system()\n");
        }
    }
    my $system_ok;
    if ($want_expect) {
        # XXX probably want to check _should_report here and
        # warn about not being able to use CPAN::Reporter with expect
        $system_ok = $self->_run_via_expect($system,$expect_model) == 0;
    }
    elsif ( $self->_should_report('make') ) {
        my ($output, $ret) = CPAN::Reporter::record_command($system);
        CPAN::Reporter::grade_make( $self, $system, $output, $ret );
        $system_ok = ! $ret;
    }
    else {
        $system_ok = system($system) == 0;
    }
    $self->introduce_myself;
    if ( $system_ok ) {
        $CPAN::Frontend->myprint("  $system -- OK\n");
        $self->{make} = CPAN::Distrostatus->new("YES");
    } else {
        $self->{writemakefile} ||= CPAN::Distrostatus->new("YES");
        $self->{make} = CPAN::Distrostatus->new("NO");
        $CPAN::Frontend->mywarn("  $system -- NOT OK\n");
    }
    $self->store_persistent_state;
}

# CPAN::Distribution::goodbye ;
sub goodbye {
    my($self,$goodbye) = @@_;
    my $id = $self->pretty_id;
    $CPAN::Frontend->mywarn("  $id\n  $goodbye\n");
    return;
}

# CPAN::Distribution::_run_via_expect ;
sub _run_via_expect {
    my($self,$system,$expect_model) = @@_;
    CPAN->debug("system[$system]expect_model[$expect_model]") if $CPAN::DEBUG;
    if ($CPAN::META->has_inst("Expect")) {
        my $expo = Expect->new;  # expo Expect object;
        $expo->spawn($system);
        $expect_model->{mode} ||= "deterministic";
        if ($expect_model->{mode} eq "deterministic") {
            return $self->_run_via_expect_deterministic($expo,$expect_model);
        } elsif ($expect_model->{mode} eq "anyorder") {
            return $self->_run_via_expect_anyorder($expo,$expect_model);
        } else {
            die "Panic: Illegal expect mode: $expect_model->{mode}";
        }
    } else {
        $CPAN::Frontend->mywarn("Expect not installed, falling back to system()\n");
        return system($system);
    }
}

sub _run_via_expect_anyorder {
    my($self,$expo,$expect_model) = @@_;
    my $timeout = $expect_model->{timeout} || 5;
    my $reuse = $expect_model->{reuse};
    my @@expectacopy = @@{$expect_model->{talk}}; # we trash it!
    my $but = "";
  EXPECT: while () {
        my($eof,$ran_into_timeout);
        my @@match = $expo->expect($timeout,
                                  [ eof => sub {
                                        $eof++;
                                    } ],
                                  [ timeout => sub {
                                        $ran_into_timeout++;
                                    } ],
                                  -re => eval"qr{.}",
                                 );
        if ($match[2]) {
            $but .= $match[2];
        }
        $but .= $expo->clear_accum;
        if ($eof) {
            $expo->soft_close;
            return $expo->exitstatus();
        } elsif ($ran_into_timeout) {
            # warn "DEBUG: they are asking a question, but[$but]";
            for (my $i = 0; $i <= $#expectacopy; $i+=2) {
                my($next,$send) = @@expectacopy[$i,$i+1];
                my $regex = eval "qr{$next}";
                # warn "DEBUG: will compare with regex[$regex].";
                if ($but =~ /$regex/) {
                    # warn "DEBUG: will send send[$send]";
                    $expo->send($send);
                    # never allow reusing an QA pair unless they told us
                    splice @@expectacopy, $i, 2 unless $reuse;
                    next EXPECT;
                }
            }
            my $why = "could not answer a question during the dialog";
            $CPAN::Frontend->mywarn("Failing: $why\n");
            $self->{writemakefile} =
                CPAN::Distrostatus->new("NO $why");
            return;
        }
    }
}

sub _run_via_expect_deterministic {
    my($self,$expo,$expect_model) = @@_;
    my $ran_into_timeout;
    my $timeout = $expect_model->{timeout} || 15; # currently unsettable
    my $expecta = $expect_model->{talk};
  EXPECT: for (my $i = 0; $i <= $#$expecta; $i+=2) {
        my($re,$send) = @@$expecta[$i,$i+1];
        CPAN->debug("timeout[$timeout]re[$re]") if $CPAN::DEBUG;
        my $regex = eval "qr{$re}";
        $expo->expect($timeout,
                      [ eof => sub {
                            my $but = $expo->clear_accum;
                            $CPAN::Frontend->mywarn("EOF (maybe harmless)
expected[$regex]\nbut[$but]\n\n");
                            last EXPECT;
                        } ],
                      [ timeout => sub {
                            my $but = $expo->clear_accum;
                            $CPAN::Frontend->mywarn("TIMEOUT
expected[$regex]\nbut[$but]\n\n");
                            $ran_into_timeout++;
                        } ],
                      -re => $regex);
        if ($ran_into_timeout) {
            # note that the caller expects 0 for success
            $self->{writemakefile} =
                CPAN::Distrostatus->new("NO timeout during expect dialog");
            return;
        }
        $expo->send($send);
    }
    $expo->soft_close;
    return $expo->exitstatus();
}

#-> CPAN::Distribution::_validate_distropref
sub _validate_distropref {
    my($self,@@args) = @@_;
    if (
        $CPAN::META->has_inst("CPAN::Kwalify")
        &&
        $CPAN::META->has_inst("Kwalify")
       ) {
        eval {CPAN::Kwalify::_validate("distroprefs",@@args);};
        if ($@@) {
            $CPAN::Frontend->mywarn($@@);
        }
    } else {
        CPAN->debug("not validating '@@args'") if $CPAN::DEBUG;
    }
}

#-> CPAN::Distribution::_find_prefs
sub _find_prefs {
    my($self) = @@_;
    my $distroid = $self->pretty_id;
    #CPAN->debug("distroid[$distroid]") if $CPAN::DEBUG;
    my $prefs_dir = $CPAN::Config->{prefs_dir};
    return if $prefs_dir =~ /^\s*$/;
    eval { File::Path::mkpath($prefs_dir); };
    if ($@@) {
        $CPAN::Frontend->mydie("Cannot create directory $prefs_dir");
    }
    my $yaml_module = CPAN::_yaml_module;
    my @@extensions;
    if ($CPAN::META->has_inst($yaml_module)) {
        push @@extensions, "yml";
    } else {
        my @@fallbacks;
        if ($CPAN::META->has_inst("Data::Dumper")) {
            push @@extensions, "dd";
            push @@fallbacks, "Data::Dumper";
        }
        if ($CPAN::META->has_inst("Storable")) {
            push @@extensions, "st";
            push @@fallbacks, "Storable";
        }
        if (@@fallbacks) {
            local $" = " and ";
            unless ($self->{have_complained_about_missing_yaml}++) {
                $CPAN::Frontend->mywarn("'$yaml_module' not installed, falling back ".
                                        "to @@fallbacks to read prefs '$prefs_dir'\n");
            }
        } else {
            unless ($self->{have_complained_about_missing_yaml}++) {
                $CPAN::Frontend->mywarn("'$yaml_module' not installed, cannot ".
                                        "read prefs '$prefs_dir'\n");
            }
        }
    }
    if (@@extensions) {
        my $dh = DirHandle->new($prefs_dir)
            or die Carp::croak("Couldn't open '$prefs_dir': $!");
      DIRENT: for (sort $dh->read) {
            next if $_ eq "." || $_ eq "..";
            my $exte = join "|", @@extensions;
            next unless /\.($exte)$/;
            my $thisexte = $1;
            my $abs = File::Spec->catfile($prefs_dir, $_);
            if (-f $abs) {
                #CPAN->debug(sprintf "abs[%s]", $abs) if $CPAN::DEBUG;
                my @@distropref;
                if ($thisexte eq "yml") {
                    # need no eval because if we have no YAML we do not try to read *.yml
                    #CPAN->debug(sprintf "before yaml load abs[%s]", $abs) if $CPAN::DEBUG;
                    @@distropref = @@{CPAN->_yaml_loadfile($abs)};
                    #CPAN->debug(sprintf "after yaml load abs[%s]", $abs) if $CPAN::DEBUG;
                } elsif ($thisexte eq "dd") {
                    package CPAN::Eval;
                    no strict;
                    open FH, "<$abs" or $CPAN::Frontend->mydie("Could not open '$abs': $!");
                    local $/;
                    my $eval = <FH>;
                    close FH;
                    eval $eval;
                    if ($@@) {
                        $CPAN::Frontend->mydie("Error in distroprefs file $_\: $@@");
                    }
                    my $i = 1;
                    while (${"VAR".$i}) {
                        push @@distropref, ${"VAR".$i};
                        $i++;
                    }
                } elsif ($thisexte eq "st") {
                    # eval because Storable is never forward compatible
                    eval { @@distropref = @@{scalar Storable::retrieve($abs)}; };
                    if ($@@) {
                        $CPAN::Frontend->mywarn("Error reading distroprefs file ".
                                                "$_, skipping\: $@@");
                        $CPAN::Frontend->mysleep(4);
                        next DIRENT;
                    }
                }
                # $DB::single=1;
                #CPAN->debug(sprintf "#distropref[%d]", scalar @@distropref) if $CPAN::DEBUG;
              ELEMENT: for my $y (0..$#distropref) {
                    my $distropref = $distropref[$y];
                    $self->_validate_distropref($distropref,$abs,$y);
                    my $match = $distropref->{match};
                    unless ($match) {
                        #CPAN->debug("no 'match' in abs[$abs], skipping") if $CPAN::DEBUG;
                        next ELEMENT;
                    }
                    my $ok = 1;
                    # do not take the order of C<keys %$match> because
                    # "module" is by far the slowest
                    my $saw_valid_subkeys = 0;
                    for my $sub_attribute (qw(distribution perl perlconfig module)) {
                        next unless exists $match->{$sub_attribute};
                        $saw_valid_subkeys++;
                        my $qr = eval "qr{$distropref->{match}{$sub_attribute}}";
                        if ($sub_attribute eq "module") {
                            my $okm = 0;
                            #CPAN->debug(sprintf "distropref[%d]", scalar @@distropref) if $CPAN::DEBUG;
                            my @@modules = $self->containsmods;
                            #CPAN->debug(sprintf "modules[%s]", join(",",@@modules)) if $CPAN::DEBUG;
                          MODULE: for my $module (@@modules) {
                                $okm ||= $module =~ /$qr/;
                                last MODULE if $okm;
                            }
                            $ok &&= $okm;
                        } elsif ($sub_attribute eq "distribution") {
                            my $okd = $distroid =~ /$qr/;
                            $ok &&= $okd;
                        } elsif ($sub_attribute eq "perl") {
                            my $okp = CPAN::find_perl =~ /$qr/;
                            $ok &&= $okp;
                        } elsif ($sub_attribute eq "perlconfig") {
                            for my $perlconfigkey (keys %{$match->{perlconfig}}) {
                                my $perlconfigval = $match->{perlconfig}->{$perlconfigkey};
                                # XXX should probably warn if Config does not exist
                                my $okpc = $Config::Config{$perlconfigkey} =~ /$perlconfigval/;
                                $ok &&= $okpc;
                                last if $ok == 0;
                            }
                        } else {
                            $CPAN::Frontend->mydie("Nonconforming .$thisexte file '$abs': ".
                                                   "unknown sub_attribut '$sub_attribute'. ".
                                                   "Please ".
                                                   "remove, cannot continue.");
                        }
                        last if $ok == 0; # short circuit
                    }
                    unless ($saw_valid_subkeys) {
                        $CPAN::Frontend->mydie("Nonconforming .$thisexte file '$abs': ".
                                               "missing match/* subattribute. ".
                                               "Please ".
                                               "remove, cannot continue.");
                    }
                    #CPAN->debug(sprintf "ok[%d]", $ok) if $CPAN::DEBUG;
                    if ($ok) {
                        return {
                                prefs => $distropref,
                                prefs_file => $abs,
                                prefs_file_doc => $y,
                               };
                    }

                }
            }
        }
        $dh->close;
    }
    return;
}

# CPAN::Distribution::prefs
sub prefs {
    my($self) = @@_;
    if (exists $self->{negative_prefs_cache}
        &&
        $self->{negative_prefs_cache} != $CPAN::CurrentCommandId
       ) {
        delete $self->{negative_prefs_cache};
        delete $self->{prefs};
    }
    if (exists $self->{prefs}) {
        return $self->{prefs}; # XXX comment out during debugging
    }
    if ($CPAN::Config->{prefs_dir}) {
        CPAN->debug("prefs_dir[$CPAN::Config->{prefs_dir}]") if $CPAN::DEBUG;
        my $prefs = $self->_find_prefs();
        $prefs ||= ""; # avoid warning next line
        CPAN->debug("prefs[$prefs]") if $CPAN::DEBUG;
        if ($prefs) {
            for my $x (qw(prefs prefs_file prefs_file_doc)) {
                $self->{$x} = $prefs->{$x};
            }
            my $bs = sprintf(
                             "%s[%s]",
                             File::Basename::basename($self->{prefs_file}),
                             $self->{prefs_file_doc},
                            );
            my $filler1 = "_" x 22;
            my $filler2 = int(66 - length($bs))/2;
            $filler2 = 0 if $filler2 < 0;
            $filler2 = " " x $filler2;
            $CPAN::Frontend->myprint("
$filler1 D i s t r o P r e f s $filler1
$filler2 $bs $filler2
");
            $CPAN::Frontend->mysleep(1);
            return $self->{prefs};
        }
    }
    $self->{negative_prefs_cache} = $CPAN::CurrentCommandId;
    return $self->{prefs} = +{};
}

# CPAN::Distribution::make_x_arg
sub make_x_arg {
    my($self, $whixh) = @@_;
    my $make_x_arg;
    my $prefs = $self->prefs;
    if (
        $prefs
        && exists $prefs->{$whixh}
        && exists $prefs->{$whixh}{args}
        && $prefs->{$whixh}{args}
       ) {
        $make_x_arg = join(" ",
                           map {CPAN::HandleConfig
                                 ->safe_quote($_)} @@{$prefs->{$whixh}{args}},
                          );
    }
    my $what = sprintf "make%s_arg", $whixh eq "make" ? "" : $whixh;
    $make_x_arg ||= $CPAN::Config->{$what};
    return $make_x_arg;
}

# CPAN::Distribution::_make_command
sub _make_command {
    my ($self) = @@_;
    if ($self) {
        return
            CPAN::HandleConfig
                ->safe_quote(
                             CPAN::HandleConfig->prefs_lookup($self,
                                                              q{make})
                             || $Config::Config{make}
                             || 'make'
                            );
    } else {
        # Old style call, without object. Deprecated
        Carp::confess("CPAN::_make_command() used as function. Don't Do That.");
        return
          safe_quote(undef,
                     CPAN::HandleConfig->prefs_lookup($self,q{make})
                     || $CPAN::Config->{make}
                     || $Config::Config{make}
                     || 'make');
    }
}

#-> sub CPAN::Distribution::follow_prereqs ;
sub follow_prereqs {
    my($self) = shift;
    my($slot) = shift;
    my(@@prereq_tuples) = grep {$_->[0] ne "perl"} @@_;
    return unless @@prereq_tuples;
    my @@prereq = map { $_->[0] } @@prereq_tuples;
    my $pretty_id = $self->pretty_id;
    my %map = (
               b => "build_requires",
               r => "requires",
               c => "commandline",
              );
    my($filler1,$filler2,$filler3,$filler4);
    # $DB::single=1;
    my $unsat = "Unsatisfied dependencies detected during";
    my $w = length($unsat) > length($pretty_id) ? length($unsat) : length($pretty_id);
    {
        my $r = int(($w - length($unsat))/2);
        my $l = $w - length($unsat) - $r;
        $filler1 = "-"x4 . " "x$l;
        $filler2 = " "x$r . "-"x4 . "\n";
    }
    {
        my $r = int(($w - length($pretty_id))/2);
        my $l = $w - length($pretty_id) - $r;
        $filler3 = "-"x4 . " "x$l;
        $filler4 = " "x$r . "-"x4 . "\n";
    }
    $CPAN::Frontend->
        myprint("$filler1 $unsat $filler2".
                "$filler3 $pretty_id $filler4".
                join("", map {"    $_->[0] \[$map{$_->[1]}]\n"} @@prereq_tuples),
               );
    my $follow = 0;
    if ($CPAN::Config->{prerequisites_policy} eq "follow") {
        $follow = 1;
    } elsif ($CPAN::Config->{prerequisites_policy} eq "ask") {
        my $answer = CPAN::Shell::colorable_makemaker_prompt(
"Shall I follow them and prepend them to the queue
of modules we are processing right now?", "yes");
        $follow = $answer =~ /^\s*y/i;
    } else {
        local($") = ", ";
        $CPAN::Frontend->
            myprint("  Ignoring dependencies on modules @@prereq\n");
    }
    if ($follow) {
        my $id = $self->id;
        # color them as dirty
        for my $p (@@prereq) {
            # warn "calling color_cmd_tmps(0,1)";
            my $any = CPAN::Shell->expandany($p);
            $self->{$slot . "_for"}{$any->id}++;
            if ($any) {
                $any->color_cmd_tmps(0,2);
            } else {
                $CPAN::Frontend->mywarn("Warning (maybe a bug): Cannot expand prereq '$p'\n");
                $CPAN::Frontend->mysleep(2);
            }
        }
        # queue them and re-queue yourself
        CPAN::Queue->jumpqueue({qmod => $id, reqtype => $self->{reqtype}},
                               map {+{qmod=>$_->[0],reqtype=>$_->[1]}} reverse @@prereq_tuples);
        $self->{$slot} = "Delayed until after prerequisites";
        return 1; # signal success to the queuerunner
    }
    return;
}

#-> sub CPAN::Distribution::unsat_prereq ;
# return ([Foo=>1],[Bar=>1.2]) for normal modules
# return ([perl=>5.008]) if we need a newer perl than we are running under
sub unsat_prereq {
    my($self,$slot) = @@_;
    my(%merged,$prereq_pm);
    my $prefs_depends = $self->prefs->{depends}||{};
    if ($slot eq "configure_requires_later") {
        my $meta_yml = $self->parse_meta_yml();
        %merged = (%{$meta_yml->{configure_requires}||{}},
                   %{$prefs_depends->{configure_requires}||{}});
        $prereq_pm = {}; # configure_requires defined as "b"
    } elsif ($slot eq "later") {
        my $prereq_pm_0 = $self->prereq_pm || {};
        for my $reqtype (qw(requires build_requires)) {
            $prereq_pm->{$reqtype} = {%{$prereq_pm_0->{$reqtype}||{}}}; # copy to not pollute it
            for my $k (keys %{$prefs_depends->{$reqtype}||{}}) {
                $prereq_pm->{$reqtype}{$k} = $prefs_depends->{$reqtype}{$k};
            }
        }
        %merged = (%{$prereq_pm->{requires}||{}},%{$prereq_pm->{build_requires}||{}});
    } else {
        die "Panic: illegal slot '$slot'";
    }
    my(@@need);
    my @@merged = %merged;
    CPAN->debug("all merged_prereqs[@@merged]") if $CPAN::DEBUG;
  NEED: while (my($need_module, $need_version) = each %merged) {
        my($available_version,$available_file,$nmo);
        if ($need_module eq "perl") {
            $available_version = $];
            $available_file = CPAN::find_perl;
        } else {
            $nmo = $CPAN::META->instance("CPAN::Module",$need_module);
            next if $nmo->uptodate;
            $available_file = $nmo->available_file;

            # if they have not specified a version, we accept any installed one
            if (defined $available_file
                and ( # a few quick shortcurcuits
                     not defined $need_version
                     or $need_version eq '0'    # "==" would trigger warning when not numeric
                     or $need_version eq "undef"
                    )) {
                next NEED;
            }

            $available_version = $nmo->available_version;
        }

        # We only want to install prereqs if either they're not installed
        # or if the installed version is too old. We cannot omit this
        # check, because if 'force' is in effect, nobody else will check.
        if (defined $available_file) {
            my(@@all_requirements) = split /\s*,\s*/, $need_version;
            local($^W) = 0;
            my $ok = 0;
          RQ: for my $rq (@@all_requirements) {
                if ($rq =~ s|>=\s*||) {
                } elsif ($rq =~ s|>\s*||) {
                    # 2005-12: one user
                    if (CPAN::Version->vgt($available_version,$rq)) {
                        $ok++;
                    }
                    next RQ;
                } elsif ($rq =~ s|!=\s*||) {
                    # 2005-12: no user
                    if (CPAN::Version->vcmp($available_version,$rq)) {
                        $ok++;
                        next RQ;
                    } else {
                        last RQ;
                    }
                } elsif ($rq =~ m|<=?\s*|) {
                    # 2005-12: no user
                    $CPAN::Frontend->mywarn("Downgrading not supported (rq[$rq])\n");
                    $ok++;
                    next RQ;
                }
                if (! CPAN::Version->vgt($rq, $available_version)) {
                    $ok++;
                }
                CPAN->debug(sprintf("need_module[%s]available_file[%s]".
                                    "available_version[%s]rq[%s]ok[%d]",
                                    $need_module,
                                    $available_file,
                                    $available_version,
                                    CPAN::Version->readable($rq),
                                    $ok,
                                   )) if $CPAN::DEBUG;
            }
            next NEED if $ok == @@all_requirements;
        }

        if ($need_module eq "perl") {
            return ["perl", $need_version];
        }
        $self->{sponsored_mods}{$need_module} ||= 0;
        CPAN->debug("need_module[$need_module]s/s/n[$self->{sponsored_mods}{$need_module}]") if $CPAN::DEBUG;
        if ($self->{sponsored_mods}{$need_module}++) {
            # We have already sponsored it and for some reason it's still
            # not available. So we do ... what??

            # if we push it again, we have a potential infinite loop

            # The following "next" was a very problematic construct.
            # It helped a lot but broke some day and had to be
            # replaced.

            # We must be able to deal with modules that come again and
            # again as a prereq and have themselves prereqs and the
            # queue becomes long but finally we would find the correct
            # order. The RecursiveDependency check should trigger a
            # die when it's becoming too weird. Unfortunately removing
            # this next breaks many other things.

            # The bug that brought this up is described in Todo under
            # "5.8.9 cannot install Compress::Zlib"

            # next; # this is the next that had to go away

            # The following "next NEED" are fine and the error message
            # explains well what is going on. For example when the DBI
            # fails and consequently DBD::SQLite fails and now we are
            # processing CPAN::SQLite. Then we must have a "next" for
            # DBD::SQLite. How can we get it and how can we identify
            # all other cases we must identify?

            my $do = $nmo->distribution;
            next NEED unless $do; # not on CPAN
            if (CPAN::Version->vcmp($need_version, $nmo->ro->{CPAN_VERSION}) > 0){
                $CPAN::Frontend->mywarn("Warning: Prerequisite ".
                                        "'$need_module => $need_version' ".
                                        "for '$self->{ID}' seems ".
                                        "not available according to the indexes\n"
                                       );
                next NEED;
            }
          NOSAYER: for my $nosayer (
                                    "unwrapped",
                                    "writemakefile",
                                    "signature_verify",
                                    "make",
                                    "make_test",
                                    "install",
                                    "make_clean",
                                   ) {
                if ($do->{$nosayer}) {
                    if (UNIVERSAL::can($do->{$nosayer},"failed") ?
                        $do->{$nosayer}->failed :
                        $do->{$nosayer} =~ /^NO/) {
                        if ($nosayer eq "make_test"
                            &&
                            $do->{make_test}{COMMANDID} != $CPAN::CurrentCommandId
                           ) {
                            next NOSAYER;
                        }
                        $CPAN::Frontend->mywarn("Warning: Prerequisite ".
                                                "'$need_module => $need_version' ".
                                                "for '$self->{ID}' failed when ".
                                                "processing '$do->{ID}' with ".
                                                "'$nosayer => $do->{$nosayer}'. Continuing, ".
                                                "but chances to succeed are limited.\n"
                                               );
                        next NEED;
                    } else { # the other guy succeeded
                        if ($nosayer eq "install") {
                            # we had this with
                            # DMAKI/DateTime-Calendar-Chinese-0.05.tar.gz
                            # 2007-03
                            $CPAN::Frontend->mywarn("Warning: Prerequisite ".
                                                    "'$need_module => $need_version' ".
                                                    "for '$self->{ID}' already installed ".
                                                    "but installation looks suspicious. ".
                                                    "Skipping another installation attempt, ".
                                                    "to prevent looping endlessly.\n"
                                                   );
                            next NEED;
                        }
                    }
                }
            }
        }
        my $needed_as = exists $prereq_pm->{requires}{$need_module} ? "r" : "b";
        push @@need, [$need_module,$needed_as];
    }
    my @@unfolded = map { "[".join(",",@@$_)."]" } @@need;
    CPAN->debug("returning from unsat_prereq[@@unfolded]") if $CPAN::DEBUG;
    @@need;
}

#-> sub CPAN::Distribution::read_yaml ;
sub read_yaml {
    my($self) = @@_;
    return $self->{yaml_content} if exists $self->{yaml_content};
    my $build_dir = $self->{build_dir};
    my $yaml = File::Spec->catfile($build_dir,"META.yml");
    $self->debug("yaml[$yaml]") if $CPAN::DEBUG;
    return unless -f $yaml;
    eval { $self->{yaml_content} = CPAN->_yaml_loadfile($yaml)->[0]; };
    if ($@@) {
        $CPAN::Frontend->mywarn("Could not read ".
                                "'$yaml'. Falling back to other ".
                                "methods to determine prerequisites\n");
        return $self->{yaml_content} = undef; # if we die, then we
                                              # cannot read YAML's own
                                              # META.yml
    }
    # not "authoritative"
    if (not exists $self->{yaml_content}{dynamic_config}
        or $self->{yaml_content}{dynamic_config}
       ) {
        $self->{yaml_content} = undef;
    }
    $self->debug(sprintf "yaml_content[%s]", $self->{yaml_content} || "UNDEF")
        if $CPAN::DEBUG;
    return $self->{yaml_content};
}

#-> sub CPAN::Distribution::prereq_pm ;
sub prereq_pm {
    my($self) = @@_;
    $self->{prereq_pm_detected} ||= 0;
    CPAN->debug("ID[$self->{ID}]prereq_pm_detected[$self->{prereq_pm_detected}]") if $CPAN::DEBUG;
    return $self->{prereq_pm} if $self->{prereq_pm_detected};
    return unless $self->{writemakefile}  # no need to have succeeded
                                          # but we must have run it
        || $self->{modulebuild};
    CPAN->debug(sprintf "writemakefile[%s]modulebuild[%s]",
                $self->{writemakefile}||"",
                $self->{modulebuild}||"",
               ) if $CPAN::DEBUG;
    my($req,$breq);
    if (my $yaml = $self->read_yaml) { # often dynamic_config prevents a result here
        $req =  $yaml->{requires} || {};
        $breq =  $yaml->{build_requires} || {};
        undef $req unless ref $req eq "HASH" && %$req;
        if ($req) {
            if ($yaml->{generated_by} &&
                $yaml->{generated_by} =~ /ExtUtils::MakeMaker version ([\d\._]+)/) {
                my $eummv = do { local $^W = 0; $1+0; };
                if ($eummv < 6.2501) {
                    # thanks to Slaven for digging that out: MM before
                    # that could be wrong because it could reflect a
                    # previous release
                    undef $req;
                }
            }
            my $areq;
            my $do_replace;
            while (my($k,$v) = each %{$req||{}}) {
                if ($v =~ /\d/) {
                    $areq->{$k} = $v;
                } elsif ($k =~ /[A-Za-z]/ &&
                         $v =~ /[A-Za-z]/ &&
                         $CPAN::META->exists("Module",$v)
                        ) {
                    $CPAN::Frontend->mywarn("Suspicious key-value pair in META.yml's ".
                                            "requires hash: $k => $v; I'll take both ".
                                            "key and value as a module name\n");
                    $CPAN::Frontend->mysleep(1);
                    $areq->{$k} = 0;
                    $areq->{$v} = 0;
                    $do_replace++;
                }
            }
            $req = $areq if $do_replace;
        }
    }
    unless ($req || $breq) {
        my $build_dir = $self->{build_dir} or die "Panic: no build_dir?";
        my $makefile = File::Spec->catfile($build_dir,"Makefile");
        my $fh;
        if (-f $makefile
            and
            $fh = FileHandle->new("<$makefile\0")) {
            CPAN->debug("Getting prereq from Makefile") if $CPAN::DEBUG;
            local($/) = "\n";
            while (<$fh>) {
                last if /MakeMaker post_initialize section/;
                my($p) = m{^[\#]
                           \s+PREREQ_PM\s+=>\s+(.+)
                       }x;
                next unless $p;
                # warn "Found prereq expr[$p]";

                #  Regexp modified by A.Speer to remember actual version of file
                #  PREREQ_PM hash key wants, then add to
                while ( $p =~ m/(?:\s)([\w\:]+)=>(q\[.*?\]|undef),?/g ) {
                    # In case a prereq is mentioned twice, complain.
                    if ( defined $req->{$1} ) {
                        warn "Warning: PREREQ_PM mentions $1 more than once, ".
                            "last mention wins";
                    }
                    my($m,$n) = ($1,$2);
                    if ($n =~ /^q\[(.*?)\]$/) {
                        $n = $1;
                    }
                    $req->{$m} = $n;
                }
                last;
            }
        }
    }
    unless ($req || $breq) {
        my $build_dir = $self->{build_dir} or die "Panic: no build_dir?";
        my $buildfile = File::Spec->catfile($build_dir,"Build");
        if (-f $buildfile) {
            CPAN->debug("Found '$buildfile'") if $CPAN::DEBUG;
            my $build_prereqs = File::Spec->catfile($build_dir,"_build","prereqs");
            if (-f $build_prereqs) {
                CPAN->debug("Getting prerequisites from '$build_prereqs'") if $CPAN::DEBUG;
                my $content = do { local *FH;
                                   open FH, $build_prereqs
                                       or $CPAN::Frontend->mydie("Could not open ".
                                                                 "'$build_prereqs': $!");
                                   local $/;
                                   <FH>;
                               };
                my $bphash = eval $content;
                if ($@@) {
                } else {
                    $req  = $bphash->{requires} || +{};
                    $breq = $bphash->{build_requires} || +{};
                }
            }
        }
    }
    if (-f "Build.PL"
        && ! -f "Makefile.PL"
        && ! exists $req->{"Module::Build"}
        && ! $CPAN::META->has_inst("Module::Build")) {
        $CPAN::Frontend->mywarn("  Warning: CPAN.pm discovered Module::Build as ".
                                "undeclared prerequisite.\n".
                                "  Adding it now as such.\n"
                               );
        $CPAN::Frontend->mysleep(5);
        $req->{"Module::Build"} = 0;
        delete $self->{writemakefile};
    }
    if ($req || $breq) {
        $self->{prereq_pm_detected}++;
        return $self->{prereq_pm} = { requires => $req, build_requires => $breq };
    }
}

#-> sub CPAN::Distribution::test ;
sub test {
    my($self) = @@_;
    if (my $goto = $self->prefs->{goto}) {
        return $self->goto($goto);
    }
    $self->make;
    if ($CPAN::Signal) {
      delete $self->{force_update};
      return;
    }
    # warn "XDEBUG: checking for notest: $self->{notest} $self";
    if ($self->{notest}) {
        $CPAN::Frontend->myprint("Skipping test because of notest pragma\n");
        return 1;
    }

    my $make = $self->{modulebuild} ? "Build" : "make";

    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");

    $CPAN::META->set_perl5lib;
    local $ENV{MAKEFLAGS}; # protect us from outer make calls

    $CPAN::Frontend->myprint("Running $make test\n");

  EXCUSE: {
        my @@e;
        if ($self->{make} or $self->{later}) {
            # go ahead
        } else {
            push @@e,
                "Make had some problems, won't test";
        }

        exists $self->{make} and
            (
             UNIVERSAL::can($self->{make},"failed") ?
             $self->{make}->failed :
             $self->{make} =~ /^NO/
            ) and push @@e, "Can't test without successful make";
        $self->{badtestcnt} ||= 0;
        if ($self->{badtestcnt} > 0) {
            require Data::Dumper;
            CPAN->debug(sprintf "NOREPEAT[%s]", Data::Dumper::Dumper($self)) if $CPAN::DEBUG;
            push @@e, "Won't repeat unsuccessful test during this command";
        }

        push @@e, $self->{later} if $self->{later};
        push @@e, $self->{configure_requires_later} if $self->{configure_requires_later};

        if (exists $self->{build_dir}) {
            if (exists $self->{make_test}) {
                if (
                    UNIVERSAL::can($self->{make_test},"failed") ?
                    $self->{make_test}->failed :
                    $self->{make_test} =~ /^NO/
                   ) {
                    if (
                        UNIVERSAL::can($self->{make_test},"commandid")
                        &&
                        $self->{make_test}->commandid == $CPAN::CurrentCommandId
                       ) {
                        push @@e, "Has already been tested within this command";
                    }
                } else {
                    push @@e, "Has already been tested successfully";
                }
            }
        } elsif (!@@e) {
            push @@e, "Has no own directory";
        }
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
        unless (chdir $self->{build_dir}) {
            push @@e, "Couldn't chdir to '$self->{build_dir}': $!";
        }
        $CPAN::Frontend->mywarn(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    $self->debug("Changed directory to $self->{build_dir}")
        if $CPAN::DEBUG;

    if ($^O eq 'MacOS') {
        Mac::BuildTools::make_test($self);
        return;
    }

    if ($self->{modulebuild}) {
        my $v = CPAN::Shell->expand("Module","Test::Harness")->inst_version;
        if (CPAN::Version->vlt($v,2.62)) {
            $CPAN::Frontend->mywarn(qq{The version of your Test::Harness is only
  '$v', you need at least '2.62'. Please upgrade your Test::Harness.\n});
            $self->{make_test} = CPAN::Distrostatus->new("NO Test::Harness too old");
            return;
        }
    }

    my $system;
    my $prefs_test = $self->prefs->{test};
    if (my $commandline
        = exists $prefs_test->{commandline} ? $prefs_test->{commandline} : "") {
        $system = $commandline;
        $ENV{PERL} = CPAN::find_perl;
    } elsif ($self->{modulebuild}) {
        $system = sprintf "%s test", $self->_build_command();
    } else {
        $system = join " ", $self->_make_command(), "test";
    }
    my $make_test_arg = $self->make_x_arg("test");
    $system = sprintf("%s%s",
                      $system,
                      $make_test_arg ? " $make_test_arg" : "",
                     );
    my($tests_ok);
    my %env;
    while (my($k,$v) = each %ENV) {
        next unless defined $v;
        $env{$k} = $v;
    }
    local %ENV = %env;
    if (my $env = $self->prefs->{test}{env}) {
        for my $e (keys %$env) {
            $ENV{$e} = $env->{$e};
        }
    }
    my $expect_model = $self->_prefs_with_expect("test");
    my $want_expect = 0;
    if ( $expect_model && @@{$expect_model->{talk}} ) {
        my $can_expect = $CPAN::META->has_inst("Expect");
        if ($can_expect) {
            $want_expect = 1;
        } else {
            $CPAN::Frontend->mywarn("Expect not installed, falling back to ".
                                    "testing without\n");
        }
    }
    if ($want_expect) {
        if ($self->_should_report('test')) {
            $CPAN::Frontend->mywarn("Reporting via CPAN::Reporter is currently ".
                                    "not supported when distroprefs specify ".
                                    "an interactive test\n");
        }
        $tests_ok = $self->_run_via_expect($system,$expect_model) == 0;
    } elsif ( $self->_should_report('test') ) {
        $tests_ok = CPAN::Reporter::test($self, $system);
    } else {
        $tests_ok = system($system) == 0;
    }
    $self->introduce_myself;
    if ( $tests_ok ) {
        {
            my @@prereq;

            # local $CPAN::DEBUG = 16; # Distribution
            for my $m (keys %{$self->{sponsored_mods}}) {
                next unless $self->{sponsored_mods}{$m} > 0;
                my $m_obj = CPAN::Shell->expand("Module",$m) or next;
                # XXX we need available_version which reflects
                # $ENV{PERL5LIB} so that already tested but not yet
                # installed modules are counted.
                my $available_version = $m_obj->available_version;
                my $available_file = $m_obj->available_file;
                if ($available_version &&
                    !CPAN::Version->vlt($available_version,$self->{prereq_pm}{$m})
                   ) {
                    CPAN->debug("m[$m] good enough available_version[$available_version]")
                        if $CPAN::DEBUG;
                } elsif ($available_file
                         && (
                             !$self->{prereq_pm}{$m}
                             ||
                             $self->{prereq_pm}{$m} == 0
                            )
                        ) {
                    # lex Class::Accessor::Chained::Fast which has no $VERSION
                    CPAN->debug("m[$m] have available_file[$available_file]")
                        if $CPAN::DEBUG;
                } else {
                    push @@prereq, $m;
                }
            }
            if (@@prereq) {
                my $cnt = @@prereq;
                my $which = join ",", @@prereq;
                my $but = $cnt == 1 ? "one dependency not OK ($which)" :
                    "$cnt dependencies missing ($which)";
                $CPAN::Frontend->mywarn("Tests succeeded but $but\n");
                $self->{make_test} = CPAN::Distrostatus->new("NO $but");
                $self->store_persistent_state;
                return $self->goodbye("[dependencies] -- NA");
            }
        }

        $CPAN::Frontend->myprint("  $system -- OK\n");
        $self->{make_test} = CPAN::Distrostatus->new("YES");
        $CPAN::META->is_tested($self->{build_dir},$self->{make_test}{TIME});
        # probably impossible to need the next line because badtestcnt
        # has a lifespan of one command
        delete $self->{badtestcnt};
    } else {
        $self->{make_test} = CPAN::Distrostatus->new("NO");
        $self->{badtestcnt}++;
        $CPAN::Frontend->mywarn("  $system -- NOT OK\n");
        CPAN::Shell->optprint
              ("hint",
               sprintf
               ("//hint// to see the cpan-testers results for installing this module, try:
  reports %s\n",
                $self->pretty_id));
    }
    $self->store_persistent_state;
}

sub _prefs_with_expect {
    my($self,$where) = @@_;
    return unless my $prefs = $self->prefs;
    return unless my $where_prefs = $prefs->{$where};
    if ($where_prefs->{expect}) {
        return {
                mode => "deterministic",
                timeout => 15,
                talk => $where_prefs->{expect},
               };
    } elsif ($where_prefs->{"eexpect"}) {
        return $where_prefs->{"eexpect"};
    }
    return;
}

#-> sub CPAN::Distribution::clean ;
sub clean {
    my($self) = @@_;
    my $make = $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint("Running $make clean\n");
    unless (exists $self->{archived}) {
        $CPAN::Frontend->mywarn("Distribution seems to have never been unzipped".
                                "/untarred, nothing done\n");
        return 1;
    }
    unless (exists $self->{build_dir}) {
        $CPAN::Frontend->mywarn("Distribution has no own directory, nothing to do.\n");
        return 1;
    }
    if (exists $self->{writemakefile}
        and $self->{writemakefile}->failed
       ) {
        $CPAN::Frontend->mywarn("No Makefile, don't know how to 'make clean'\n");
        return 1;
    }
  EXCUSE: {
        my @@e;
        exists $self->{make_clean} and $self->{make_clean} eq "YES" and
            push @@e, "make clean already called once";
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    chdir $self->{build_dir} or
        Carp::confess("Couldn't chdir to $self->{build_dir}: $!");
    $self->debug("Changed directory to $self->{build_dir}") if $CPAN::DEBUG;

    if ($^O eq 'MacOS') {
        Mac::BuildTools::make_clean($self);
        return;
    }

    my $system;
    if ($self->{modulebuild}) {
        unless (-f "Build") {
            my $cwd = CPAN::anycwd();
            $CPAN::Frontend->mywarn("Alert: no Build file available for 'clean $self->{id}".
                                    " in cwd[$cwd]. Danger, Will Robinson!");
            $CPAN::Frontend->mysleep(5);
        }
        $system = sprintf "%s clean", $self->_build_command();
    } else {
        $system  = join " ", $self->_make_command(), "clean";
    }
    my $system_ok = system($system) == 0;
    $self->introduce_myself;
    if ( $system_ok ) {
      $CPAN::Frontend->myprint("  $system -- OK\n");

      # $self->force;

      # Jost Krieger pointed out that this "force" was wrong because
      # it has the effect that the next "install" on this distribution
      # will untar everything again. Instead we should bring the
      # object's state back to where it is after untarring.

      for my $k (qw(
                    force_update
                    install
                    writemakefile
                    make
                    make_test
                   )) {
          delete $self->{$k};
      }
      $self->{make_clean} = CPAN::Distrostatus->new("YES");

    } else {
      # Hmmm, what to do if make clean failed?

      $self->{make_clean} = CPAN::Distrostatus->new("NO");
      $CPAN::Frontend->mywarn(qq{  $system -- NOT OK\n});

      # 2006-02-27: seems silly to me to force a make now
      # $self->force("make"); # so that this directory won't be used again

    }
    $self->store_persistent_state;
}

#-> sub CPAN::Distribution::goto ;
sub goto {
    my($self,$goto) = @@_;
    $goto = $self->normalize($goto);
    my $why = sprintf(
                      "Goto '$goto' via prefs file '%s' doc %d",
                      $self->{prefs_file},
                      $self->{prefs_file_doc},
                     );
    $self->{unwrapped} = CPAN::Distrostatus->new("NO $why");
    # 2007-07-16 akoenig : Better than NA would be if we could inherit
    # the status of the $goto distro but given the exceptional nature
    # of 'goto' I feel reluctant to implement it
    my $goodbye_message = "[goto] -- NA $why";
    $self->goodbye($goodbye_message);

    # inject into the queue

    CPAN::Queue->delete($self->id);
    CPAN::Queue->jumpqueue({qmod => $goto, reqtype => $self->{reqtype}});

    # and run where we left off

    my($method) = (caller(1))[3];
    CPAN->instance("CPAN::Distribution",$goto)->$method();
    CPAN::Queue->delete_first($goto);
}

#-> sub CPAN::Distribution::install ;
sub install {
    my($self) = @@_;
    if (my $goto = $self->prefs->{goto}) {
        return $self->goto($goto);
    }
    # $DB::single=1;
    unless ($self->{badtestcnt}) {
        $self->test;
    }
    if ($CPAN::Signal) {
      delete $self->{force_update};
      return;
    }
    my $make = $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint("Running $make install\n");
  EXCUSE: {
        my @@e;
        if ($self->{make} or $self->{later}) {
            # go ahead
        } else {
            push @@e,
                "Make had some problems, won't install";
        }

        exists $self->{make} and
            (
             UNIVERSAL::can($self->{make},"failed") ?
             $self->{make}->failed :
             $self->{make} =~ /^NO/
            ) and
            push @@e, "Make had returned bad status, install seems impossible";

        if (exists $self->{build_dir}) {
        } elsif (!@@e) {
            push @@e, "Has no own directory";
        }

        if (exists $self->{make_test} and
            (
             UNIVERSAL::can($self->{make_test},"failed") ?
             $self->{make_test}->failed :
             $self->{make_test} =~ /^NO/
            )) {
            if ($self->{force_update}) {
                $self->{make_test}->text("FAILED but failure ignored because ".
                                         "'force' in effect");
            } else {
                push @@e, "make test had returned bad status, ".
                    "won't install without force"
            }
        }
        if (exists $self->{install}) {
            if (UNIVERSAL::can($self->{install},"text") ?
                $self->{install}->text eq "YES" :
                $self->{install} =~ /^YES/
               ) {
                $CPAN::Frontend->myprint("  Already done\n");
                $CPAN::META->is_installed($self->{build_dir});
                return 1;
            } else {
                # comment in Todo on 2006-02-11; maybe retry?
                push @@e, "Already tried without success";
            }
        }

        push @@e, $self->{later} if $self->{later};
        push @@e, $self->{configure_requires_later} if $self->{configure_requires_later};

        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
        unless (chdir $self->{build_dir}) {
            push @@e, "Couldn't chdir to '$self->{build_dir}': $!";
        }
        $CPAN::Frontend->mywarn(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    $self->debug("Changed directory to $self->{build_dir}")
        if $CPAN::DEBUG;

    if ($^O eq 'MacOS') {
        Mac::BuildTools::make_install($self);
        return;
    }

    my $system;
    if (my $commandline = $self->prefs->{install}{commandline}) {
        $system = $commandline;
        $ENV{PERL} = CPAN::find_perl;
    } elsif ($self->{modulebuild}) {
        my($mbuild_install_build_command) =
            exists $CPAN::HandleConfig::keys{mbuild_install_build_command} &&
                $CPAN::Config->{mbuild_install_build_command} ?
                    $CPAN::Config->{mbuild_install_build_command} :
                        $self->_build_command();
        $system = sprintf("%s install %s",
                          $mbuild_install_build_command,
                          $CPAN::Config->{mbuild_install_arg},
                         );
    } else {
        my($make_install_make_command) =
            CPAN::HandleConfig->prefs_lookup($self,
                                             q{make_install_make_command})
                  || $self->_make_command();
        $system = sprintf("%s install %s",
                          $make_install_make_command,
                          $CPAN::Config->{make_install_arg},
                         );
    }

    my($stderr) = $^O eq "MSWin32" ? "" : " 2>&1 ";
    my $brip = CPAN::HandleConfig->prefs_lookup($self,
                                                q{build_requires_install_policy});
    $brip ||="ask/yes";
    my $id = $self->id;
    my $reqtype = $self->{reqtype} ||= "c"; # in doubt it was a command
    my $want_install = "yes";
    if ($reqtype eq "b") {
        if ($brip eq "no") {
            $want_install = "no";
        } elsif ($brip =~ m|^ask/(.+)|) {
            my $default = $1;
            $default = "yes" unless $default =~ /^(y|n)/i;
            $want_install =
                CPAN::Shell::colorable_makemaker_prompt
                      ("$id is just needed temporarily during building or testing. ".
                       "Do you want to install it permanently? (Y/n)",
                       $default);
        }
    }
    unless ($want_install =~ /^y/i) {
        my $is_only = "is only 'build_requires'";
        $CPAN::Frontend->mywarn("Not installing because $is_only\n");
        $self->{install} = CPAN::Distrostatus->new("NO -- $is_only");
        delete $self->{force_update};
        return;
    }
    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");

    $CPAN::META->set_perl5lib;
    my($pipe) = FileHandle->new("$system $stderr |");
    my($makeout) = "";
    while (<$pipe>) {
        print $_; # intentionally NOT use Frontend->myprint because it
                  # looks irritating when we markup in color what we
                  # just pass through from an external program
        $makeout .= $_;
    }
    $pipe->close;
    my $close_ok = $? == 0;
    $self->introduce_myself;
    if ( $close_ok ) {
        $CPAN::Frontend->myprint("  $system -- OK\n");
        $CPAN::META->is_installed($self->{build_dir});
        $self->{install} = CPAN::Distrostatus->new("YES");
    } else {
        $self->{install} = CPAN::Distrostatus->new("NO");
        $CPAN::Frontend->mywarn("  $system -- NOT OK\n");
        my $mimc =
            CPAN::HandleConfig->prefs_lookup($self,
                                             q{make_install_make_command});
        if (
            $makeout =~ /permission/s
            && $> > 0
            && (
                ! $mimc
                || $mimc eq (CPAN::HandleConfig->prefs_lookup($self,
                                                              q{make}))
               )
           ) {
            $CPAN::Frontend->myprint(
                                     qq{----\n}.
                                     qq{  You may have to su }.
                                     qq{to root to install the package\n}.
                                     qq{  (Or you may want to run something like\n}.
                                     qq{    o conf make_install_make_command 'sudo make'\n}.
                                     qq{  to raise your permissions.}
                                    );
        }
    }
    delete $self->{force_update};
    # $DB::single = 1;
    $self->store_persistent_state;
}

sub introduce_myself {
    my($self) = @@_;
    $CPAN::Frontend->myprint(sprintf("  %s\n",$self->pretty_id));
}

#-> sub CPAN::Distribution::dir ;
sub dir {
    shift->{build_dir};
}

#-> sub CPAN::Distribution::perldoc ;
sub perldoc {
    my($self) = @@_;

    my($dist) = $self->id;
    my $package = $self->called_for;

    $self->_display_url( $CPAN::Defaultdocs . $package );
}

#-> sub CPAN::Distribution::_check_binary ;
sub _check_binary {
    my ($dist,$shell,$binary) = @@_;
    my ($pid,$out);

    $CPAN::Frontend->myprint(qq{ + _check_binary($binary)\n})
      if $CPAN::DEBUG;

    if ($CPAN::META->has_inst("File::Which")) {
        return File::Which::which($binary);
    } else {
        local *README;
        $pid = open README, "which $binary|"
            or $CPAN::Frontend->mywarn(qq{Could not fork 'which $binary': $!\n});
        return unless $pid;
        while (<README>) {
            $out .= $_;
        }
        close README
            or $CPAN::Frontend->mywarn("Could not run 'which $binary': $!\n")
                and return;
    }

    $CPAN::Frontend->myprint(qq{   + $out \n})
      if $CPAN::DEBUG && $out;

    return $out;
}

#-> sub CPAN::Distribution::_display_url ;
sub _display_url {
    my($self,$url) = @@_;
    my($res,$saved_file,$pid,$out);

    $CPAN::Frontend->myprint(qq{ + _display_url($url)\n})
      if $CPAN::DEBUG;

    # should we define it in the config instead?
    my $html_converter = "html2text.pl";

    my $web_browser = $CPAN::Config->{'lynx'} || undef;
    my $web_browser_out = $web_browser
        ? CPAN::Distribution->_check_binary($self,$web_browser)
        : undef;

    if ($web_browser_out) {
        # web browser found, run the action
        my $browser = CPAN::HandleConfig->safe_quote($CPAN::Config->{'lynx'});
        $CPAN::Frontend->myprint(qq{system[$browser $url]})
            if $CPAN::DEBUG;
        $CPAN::Frontend->myprint(qq{
Displaying URL
  $url
with browser $browser
});
        $CPAN::Frontend->mysleep(1);
        system("$browser $url");
        if ($saved_file) { 1 while unlink($saved_file) }
    } else {
        # web browser not found, let's try text only
        my $html_converter_out =
            CPAN::Distribution->_check_binary($self,$html_converter);
        $html_converter_out = CPAN::HandleConfig->safe_quote($html_converter_out);

        if ($html_converter_out ) {
            # html2text found, run it
            $saved_file = CPAN::Distribution->_getsave_url( $self, $url );
            $CPAN::Frontend->mydie(qq{ERROR: problems while getting $url\n})
                unless defined($saved_file);

            local *README;
            $pid = open README, "$html_converter $saved_file |"
                or $CPAN::Frontend->mydie(qq{
Could not fork '$html_converter $saved_file': $!});
            my($fh,$filename);
            if ($CPAN::META->has_usable("File::Temp")) {
                $fh = File::Temp->new(
                                      dir      => File::Spec->tmpdir,
                                      template => 'cpan_htmlconvert_XXXX',
                                      suffix => '.txt',
                                      unlink => 0,
                                     );
                $filename = $fh->filename;
            } else {
                $filename = "cpan_htmlconvert_$$.txt";
                $fh = FileHandle->new();
                open $fh, ">$filename" or die;
            }
            while (<README>) {
                $fh->print($_);
            }
            close README or
                $CPAN::Frontend->mydie(qq{Could not run '$html_converter $saved_file': $!});
            my $tmpin = $fh->filename;
            $CPAN::Frontend->myprint(sprintf(qq{
Run '%s %s' and
saved output to %s\n},
                                             $html_converter,
                                             $saved_file,
                                             $tmpin,
                                            )) if $CPAN::DEBUG;
            close $fh;
            local *FH;
            open FH, $tmpin
                or $CPAN::Frontend->mydie(qq{Could not open "$tmpin": $!});
            my $fh_pager = FileHandle->new;
            local($SIG{PIPE}) = "IGNORE";
            my $pager = $CPAN::Config->{'pager'} || "cat";
            $fh_pager->open("|$pager")
                or $CPAN::Frontend->mydie(qq{
Could not open pager '$pager': $!});
            $CPAN::Frontend->myprint(qq{
Displaying URL
  $url
with pager "$pager"
});
            $CPAN::Frontend->mysleep(1);
            $fh_pager->print(<FH>);
            $fh_pager->close;
        } else {
            # coldn't find the web browser or html converter
            $CPAN::Frontend->myprint(qq{
You need to install lynx or $html_converter to use this feature.});
        }
    }
}

#-> sub CPAN::Distribution::_getsave_url ;
sub _getsave_url {
    my($dist, $shell, $url) = @@_;

    $CPAN::Frontend->myprint(qq{ + _getsave_url($url)\n})
      if $CPAN::DEBUG;

    my($fh,$filename);
    if ($CPAN::META->has_usable("File::Temp")) {
        $fh = File::Temp->new(
                              dir      => File::Spec->tmpdir,
                              template => "cpan_getsave_url_XXXX",
                              suffix => ".html",
                              unlink => 0,
                             );
        $filename = $fh->filename;
    } else {
        $fh = FileHandle->new;
        $filename = "cpan_getsave_url_$$.html";
    }
    my $tmpin = $filename;
    if ($CPAN::META->has_usable('LWP')) {
        $CPAN::Frontend->myprint("Fetching with LWP:
  $url
");
        my $Ua;
        CPAN::LWP::UserAgent->config;
        eval { $Ua = CPAN::LWP::UserAgent->new; };
        if ($@@) {
            $CPAN::Frontend->mywarn("ERROR: CPAN::LWP::UserAgent->new dies with $@@\n");
            return;
        } else {
            my($var);
            $Ua->proxy('http', $var)
                if $var = $CPAN::Config->{http_proxy} || $ENV{http_proxy};
            $Ua->no_proxy($var)
                if $var = $CPAN::Config->{no_proxy} || $ENV{no_proxy};
        }

        my $req = HTTP::Request->new(GET => $url);
        $req->header('Accept' => 'text/html');
        my $res = $Ua->request($req);
        if ($res->is_success) {
            $CPAN::Frontend->myprint(" + request successful.\n")
                if $CPAN::DEBUG;
            print $fh $res->content;
            close $fh;
            $CPAN::Frontend->myprint(qq{ + saved content to $tmpin \n})
                if $CPAN::DEBUG;
            return $tmpin;
        } else {
            $CPAN::Frontend->myprint(sprintf(
                                             "LWP failed with code[%s], message[%s]\n",
                                             $res->code,
                                             $res->message,
                                            ));
            return;
        }
    } else {
        $CPAN::Frontend->mywarn("  LWP not available\n");
        return;
    }
}

#-> sub CPAN::Distribution::_build_command
sub _build_command {
    my($self) = @@_;
    if ($^O eq "MSWin32") { # special code needed at least up to
                            # Module::Build 0.2611 and 0.2706; a fix
                            # in M:B has been promised 2006-01-30
        my($perl) = $self->perl or $CPAN::Frontend->mydie("Couldn't find executable perl\n");
        return "$perl ./Build";
    }
    return "./Build";
}

#-> sub CPAN::Distribution::_should_report
sub _should_report {
    my($self, $phase) = @@_;
    die "_should_report() requires a 'phase' argument"
        if ! defined $phase;

    # configured
    my $test_report = CPAN::HandleConfig->prefs_lookup($self,
                                                       q{test_report});
    return unless $test_report;

    # don't repeat if we cached a result
    return $self->{should_report}
        if exists $self->{should_report};

    # available
    if ( ! $CPAN::META->has_inst("CPAN::Reporter")) {
        $CPAN::Frontend->mywarn(
            "CPAN::Reporter not installed.  No reports will be sent.\n"
        );
        return $self->{should_report} = 0;
    }

    # capable
    my $crv = CPAN::Reporter->VERSION;
    if ( CPAN::Version->vlt( $crv, 0.99 ) ) {
        # don't cache $self->{should_report} -- need to check each phase
        if ( $phase eq 'test' ) {
            return 1;
        }
        else {
            $CPAN::Frontend->mywarn(
                "Reporting on the '$phase' phase requires CPAN::Reporter 0.99, but \n" .
                "you only have version $crv\.  Only 'test' phase reports will be sent.\n"
            );
            return;
        }
    }

    # appropriate
    if ($self->is_dot_dist) {
        $CPAN::Frontend->mywarn("Reporting via CPAN::Reporter is disabled ".
                                "for local directories\n");
        return $self->{should_report} = 0;
    }
    if ($self->prefs->{patches}
        &&
        @@{$self->prefs->{patches}}
        &&
        $self->{patched}
       ) {
        $CPAN::Frontend->mywarn("Reporting via CPAN::Reporter is disabled ".
                                "when the source has been patched\n");
        return $self->{should_report} = 0;
    }

    # proceed and cache success
    return $self->{should_report} = 1;
}

#-> sub CPAN::Distribution::reports
sub reports {
    my($self) = @@_;
    my $pathname = $self->id;
    $CPAN::Frontend->myprint("Distribution: $pathname\n");

    unless ($CPAN::META->has_inst("CPAN::DistnameInfo")) {
        $CPAN::Frontend->mydie("CPAN::DistnameInfo not installed; cannot continue");
    }
    unless ($CPAN::META->has_usable("LWP")) {
        $CPAN::Frontend->mydie("LWP not installed; cannot continue");
    }
    unless ($CPAN::META->has_usable("File::Temp")) {
        $CPAN::Frontend->mydie("File::Temp not installed; cannot continue");
    }

    my $d = CPAN::DistnameInfo->new($pathname);

    my $dist      = $d->dist;      # "CPAN-DistnameInfo"
    my $version   = $d->version;   # "0.02"
    my $maturity  = $d->maturity;  # "released"
    my $filename  = $d->filename;  # "CPAN-DistnameInfo-0.02.tar.gz"
    my $cpanid    = $d->cpanid;    # "GBARR"
    my $distvname = $d->distvname; # "CPAN-DistnameInfo-0.02"

    my $url = sprintf "http://cpantesters.perl.org/show/%s.yaml", $dist;

    CPAN::LWP::UserAgent->config;
    my $Ua;
    eval { $Ua = CPAN::LWP::UserAgent->new; };
    if ($@@) {
        $CPAN::Frontend->mydie("CPAN::LWP::UserAgent->new dies with $@@\n");
    }
    $CPAN::Frontend->myprint("Fetching '$url'...");
    my $resp = $Ua->get($url);
    unless ($resp->is_success) {
        $CPAN::Frontend->mydie(sprintf "Could not download '%s': %s\n", $url, $resp->code);
    }
    $CPAN::Frontend->myprint("DONE\n\n");
    my $yaml = $resp->content;
    # was fuer ein Umweg!
    my $fh = File::Temp->new(
                             dir      => File::Spec->tmpdir,
                             template => 'cpan_reports_XXXX',
                             suffix => '.yaml',
                             unlink => 0,
                            );
    my $tfilename = $fh->filename;
    print $fh $yaml;
    close $fh or $CPAN::Frontend->mydie("Could not close '$tfilename': $!");
    my $unserialized = CPAN->_yaml_loadfile($tfilename)->[0];
    unlink $tfilename or $CPAN::Frontend->mydie("Could not unlink '$tfilename': $!");
    my %other_versions;
    my $this_version_seen;
    for my $rep (@@$unserialized) {
        my $rversion = $rep->{version};
        if ($rversion eq $version) {
            unless ($this_version_seen++) {
                $CPAN::Frontend->myprint ("$rep->{version}:\n");
            }
            $CPAN::Frontend->myprint
                (sprintf("%1s%1s%-4s %s on %s %s (%s)\n",
                         $rep->{archname} eq $Config::Config{archname}?"*":"",
                         $rep->{action}eq"PASS"?"+":$rep->{action}eq"FAIL"?"-":"",
                         $rep->{action},
                         $rep->{perl},
                         ucfirst $rep->{osname},
                         $rep->{osvers},
                         $rep->{archname},
                        ));
        } else {
            $other_versions{$rep->{version}}++;
        }
    }
    unless ($this_version_seen) {
        $CPAN::Frontend->myprint("No reports found for version '$version'
Reports for other versions:\n");
        for my $v (sort keys %other_versions) {
            $CPAN::Frontend->myprint(" $v\: $other_versions{$v}\n");
        }
    }
    $url =~ s/\.yaml/.html/;
    $CPAN::Frontend->myprint("See $url for details\n");
}

package CPAN::Bundle;
use strict;

sub look {
    my $self = shift;
    $CPAN::Frontend->myprint($self->as_string);
}

#-> CPAN::Bundle::undelay
sub undelay {
    my $self = shift;
    delete $self->{later};
    for my $c ( $self->contains ) {
        my $obj = CPAN::Shell->expandany($c) or next;
        $obj->undelay;
    }
}

# mark as dirty/clean
#-> sub CPAN::Bundle::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    my($ancestors) = shift || [];
    # a module needs to recurse to its cpan_file, a distribution needs
    # to recurse into its prereq_pms, a bundle needs to recurse into its modules

    return if exists $self->{incommandcolor}
        && $color==1
        && $self->{incommandcolor}==$color;
    if ($depth>=$CPAN::MAX_RECURSION) {
        die(CPAN::Exception::RecursiveDependency->new($ancestors));
    }
    # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;

    for my $c ( $self->contains ) {
        my $obj = CPAN::Shell->expandany($c) or next;
        CPAN->debug("c[$c]obj[$obj]") if $CPAN::DEBUG;
        $obj->color_cmd_tmps($depth+1,$color,[@@$ancestors, $self->id]);
    }
    # never reached code?
    #if ($color==0) {
      #delete $self->{badtestcnt};
    #}
    $self->{incommandcolor} = $color;
}

#-> sub CPAN::Bundle::as_string ;
sub as_string {
    my($self) = @@_;
    $self->contains;
    # following line must be "=", not "||=" because we have a moving target
    $self->{INST_VERSION} = $self->inst_version;
    return $self->SUPER::as_string;
}

#-> sub CPAN::Bundle::contains ;
sub contains {
    my($self) = @@_;
    my($inst_file) = $self->inst_file || "";
    my($id) = $self->id;
    $self->debug("inst_file[$inst_file]id[$id]") if $CPAN::DEBUG;
    if ($inst_file && CPAN::Version->vlt($self->inst_version,$self->cpan_version)) {
        undef $inst_file;
    }
    unless ($inst_file) {
        # Try to get at it in the cpan directory
        $self->debug("no inst_file") if $CPAN::DEBUG;
        my $cpan_file;
        $CPAN::Frontend->mydie("I don't know a bundle with ID $id\n") unless
              $cpan_file = $self->cpan_file;
        if ($cpan_file eq "N/A") {
            $CPAN::Frontend->mydie("Bundle $id not found on disk and not on CPAN.
  Maybe stale symlink? Maybe removed during session? Giving up.\n");
        }
        my $dist = $CPAN::META->instance('CPAN::Distribution',
                                         $self->cpan_file);
        $self->debug("before get id[$dist->{ID}]") if $CPAN::DEBUG;
        $dist->get;
        $self->debug("after get id[$dist->{ID}]") if $CPAN::DEBUG;
        my($todir) = $CPAN::Config->{'cpan_home'};
        my(@@me,$from,$to,$me);
        @@me = split /::/, $self->id;
        $me[-1] .= ".pm";
        $me = File::Spec->catfile(@@me);
        $from = $self->find_bundle_file($dist->{build_dir},join('/',@@me));
        $to = File::Spec->catfile($todir,$me);
        File::Path::mkpath(File::Basename::dirname($to));
        File::Copy::copy($from, $to)
              or Carp::confess("Couldn't copy $from to $to: $!");
        $inst_file = $to;
    }
    my @@result;
    my $fh = FileHandle->new;
    local $/ = "\n";
    open($fh,$inst_file) or die "Could not open '$inst_file': $!";
    my $in_cont = 0;
    $self->debug("inst_file[$inst_file]") if $CPAN::DEBUG;
    while (<$fh>) {
        $in_cont = m/^=(?!head1\s+CONTENTS)/ ? 0 :
            m/^=head1\s+CONTENTS/ ? 1 : $in_cont;
        next unless $in_cont;
        next if /^=/;
        s/\#.*//;
        next if /^\s+$/;
        chomp;
        push @@result, (split " ", $_, 2)[0];
    }
    close $fh;
    delete $self->{STATUS};
    $self->{CONTAINS} = \@@result;
    $self->debug("CONTAINS[@@result]") if $CPAN::DEBUG;
    unless (@@result) {
        $CPAN::Frontend->mywarn(qq{
The bundle file "$inst_file" may be a broken
bundlefile. It seems not to contain any bundle definition.
Please check the file and if it is bogus, please delete it.
Sorry for the inconvenience.
});
    }
    @@result;
}

#-> sub CPAN::Bundle::find_bundle_file
# $where is in local format, $what is in unix format
sub find_bundle_file {
    my($self,$where,$what) = @@_;
    $self->debug("where[$where]what[$what]") if $CPAN::DEBUG;
### The following two lines let CPAN.pm become Bundle/CPAN.pm :-(
###    my $bu = File::Spec->catfile($where,$what);
###    return $bu if -f $bu;
    my $manifest = File::Spec->catfile($where,"MANIFEST");
    unless (-f $manifest) {
        require ExtUtils::Manifest;
        my $cwd = CPAN::anycwd();
        $self->safe_chdir($where);
        ExtUtils::Manifest::mkmanifest();
        $self->safe_chdir($cwd);
    }
    my $fh = FileHandle->new($manifest)
        or Carp::croak("Couldn't open $manifest: $!");
    local($/) = "\n";
    my $bundle_filename = $what;
    $bundle_filename =~ s|Bundle.*/||;
    my $bundle_unixpath;
    while (<$fh>) {
        next if /^\s*\#/;
        my($file) = /(\S+)/;
        if ($file =~ m|\Q$what\E$|) {
            $bundle_unixpath = $file;
            # return File::Spec->catfile($where,$bundle_unixpath); # bad
            last;
        }
        # retry if she managed to have no Bundle directory
        $bundle_unixpath = $file if $file =~ m|\Q$bundle_filename\E$|;
    }
    return File::Spec->catfile($where, split /\//, $bundle_unixpath)
        if $bundle_unixpath;
    Carp::croak("Couldn't find a Bundle file in $where");
}

# needs to work quite differently from Module::inst_file because of
# cpan_home/Bundle/ directory and the possibility that we have
# shadowing effect. As it makes no sense to take the first in @@INC for
# Bundles, we parse them all for $VERSION and take the newest.

#-> sub CPAN::Bundle::inst_file ;
sub inst_file {
    my($self) = @@_;
    my($inst_file);
    my(@@me);
    @@me = split /::/, $self->id;
    $me[-1] .= ".pm";
    my($incdir,$bestv);
    foreach $incdir ($CPAN::Config->{'cpan_home'},@@INC) {
        my $bfile = File::Spec->catfile($incdir, @@me);
        CPAN->debug("bfile[$bfile]") if $CPAN::DEBUG;
        next unless -f $bfile;
        my $foundv = MM->parse_version($bfile);
        if (!$bestv || CPAN::Version->vgt($foundv,$bestv)) {
            $self->{INST_FILE} = $bfile;
            $self->{INST_VERSION} = $bestv = $foundv;
        }
    }
    $self->{INST_FILE};
}

#-> sub CPAN::Bundle::inst_version ;
sub inst_version {
    my($self) = @@_;
    $self->inst_file; # finds INST_VERSION as side effect
    $self->{INST_VERSION};
}

#-> sub CPAN::Bundle::rematein ;
sub rematein {
    my($self,$meth) = @@_;
    $self->debug("self[$self] meth[$meth]") if $CPAN::DEBUG;
    my($id) = $self->id;
    Carp::croak "Can't $meth $id, don't have an associated bundle file. :-(\n"
        unless $self->inst_file || $self->cpan_file;
    my($s,%fail);
    for $s ($self->contains) {
        my($type) = $s =~ m|/| ? 'CPAN::Distribution' :
            $s =~ m|^Bundle::| ? 'CPAN::Bundle' : 'CPAN::Module';
        if ($type eq 'CPAN::Distribution') {
            $CPAN::Frontend->mywarn(qq{
The Bundle }.$self->id.qq{ contains
explicitly a file '$s'.
Going to $meth that.
});
            $CPAN::Frontend->mysleep(5);
        }
        # possibly noisy action:
        $self->debug("type[$type] s[$s]") if $CPAN::DEBUG;
        my $obj = $CPAN::META->instance($type,$s);
        $obj->{reqtype} = $self->{reqtype};
        $obj->$meth();
    }
}

# If a bundle contains another that contains an xs_file we have here,
# we just don't bother I suppose
#-> sub CPAN::Bundle::xs_file
sub xs_file {
    return 0;
}

#-> sub CPAN::Bundle::force ;
sub fforce   { shift->rematein('fforce',@@_); }
#-> sub CPAN::Bundle::force ;
sub force   { shift->rematein('force',@@_); }
#-> sub CPAN::Bundle::notest ;
sub notest  { shift->rematein('notest',@@_); }
#-> sub CPAN::Bundle::get ;
sub get     { shift->rematein('get',@@_); }
#-> sub CPAN::Bundle::make ;
sub make    { shift->rematein('make',@@_); }
#-> sub CPAN::Bundle::test ;
sub test    {
    my $self = shift;
    # $self->{badtestcnt} ||= 0;
    $self->rematein('test',@@_);
}
#-> sub CPAN::Bundle::install ;
sub install {
  my $self = shift;
  $self->rematein('install',@@_);
}
#-> sub CPAN::Bundle::clean ;
sub clean   { shift->rematein('clean',@@_); }

#-> sub CPAN::Bundle::uptodate ;
sub uptodate {
    my($self) = @@_;
    return 0 unless $self->SUPER::uptodate; # we mut have the current Bundle def
    my $c;
    foreach $c ($self->contains) {
        my $obj = CPAN::Shell->expandany($c);
        return 0 unless $obj->uptodate;
    }
    return 1;
}

#-> sub CPAN::Bundle::readme ;
sub readme  {
    my($self) = @@_;
    my($file) = $self->cpan_file or $CPAN::Frontend->myprint(qq{
No File found for bundle } . $self->id . qq{\n}), return;
    $self->debug("self[$self] file[$file]") if $CPAN::DEBUG;
    $CPAN::META->instance('CPAN::Distribution',$file)->readme;
}

package CPAN::Module;
use strict;

# Accessors
#-> sub CPAN::Module::userid
sub userid {
    my $self = shift;
    my $ro = $self->ro;
    return unless $ro;
    return $ro->{userid} || $ro->{CPAN_USERID};
}
#-> sub CPAN::Module::description
sub description {
    my $self = shift;
    my $ro = $self->ro or return "";
    $ro->{description}
}

#-> sub CPAN::Module::distribution
sub distribution {
    my($self) = @@_;
    CPAN::Shell->expand("Distribution",$self->cpan_file);
}

#-> sub CPAN::Module::undelay
sub undelay {
    my $self = shift;
    delete $self->{later};
    if ( my $dist = CPAN::Shell->expand("Distribution", $self->cpan_file) ) {
        $dist->undelay;
    }
}

# mark as dirty/clean
#-> sub CPAN::Module::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    my($ancestors) = shift || [];
    # a module needs to recurse to its cpan_file

    return if exists $self->{incommandcolor}
        && $color==1
        && $self->{incommandcolor}==$color;
    return if $color==0 && !$self->{incommandcolor};
    if ($color>=1) {
        if ( $self->uptodate ) {
            $self->{incommandcolor} = $color;
            return;
        } elsif (my $have_version = $self->available_version) {
            # maybe what we have is good enough
            if (@@$ancestors) {
                my $who_asked_for_me = $ancestors->[-1];
                my $obj = CPAN::Shell->expandany($who_asked_for_me);
                if (0) {
                } elsif ($obj->isa("CPAN::Bundle")) {
                    # bundles cannot specify a minimum version
                    return;
                } elsif ($obj->isa("CPAN::Distribution")) {
                    if (my $prereq_pm = $obj->prereq_pm) {
                        for my $k (keys %$prereq_pm) {
                            if (my $want_version = $prereq_pm->{$k}{$self->id}) {
                                if (CPAN::Version->vcmp($have_version,$want_version) >= 0) {
                                    $self->{incommandcolor} = $color;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        $self->{incommandcolor} = $color; # set me before recursion,
                                          # so we can break it
    }
    if ($depth>=$CPAN::MAX_RECURSION) {
        die(CPAN::Exception::RecursiveDependency->new($ancestors));
    }
    # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;

    if ( my $dist = CPAN::Shell->expand("Distribution", $self->cpan_file) ) {
        $dist->color_cmd_tmps($depth+1,$color,[@@$ancestors, $self->id]);
    }
    # unreached code?
    # if ($color==0) {
    #    delete $self->{badtestcnt};
    # }
    $self->{incommandcolor} = $color;
}

#-> sub CPAN::Module::as_glimpse ;
sub as_glimpse {
    my($self) = @@_;
    my(@@m);
    my $class = ref($self);
    $class =~ s/^CPAN:://;
    my $color_on = "";
    my $color_off = "";
    if (
        $CPAN::Shell::COLOR_REGISTERED
        &&
        $CPAN::META->has_inst("Term::ANSIColor")
        &&
        $self->description
       ) {
        $color_on = Term::ANSIColor::color("green");
        $color_off = Term::ANSIColor::color("reset");
    }
    my $uptodateness = " ";
    unless ($class eq "Bundle") {
        my $u = $self->uptodate;
        $uptodateness = $u ? "=" : "<" if defined $u;
    };
    my $id = do {
        my $d = $self->distribution;
        $d ? $d -> pretty_id : $self->cpan_userid;
    };
    push @@m, sprintf("%-7s %1s %s%-22s%s (%s)\n",
                     $class,
                     $uptodateness,
                     $color_on,
                     $self->id,
                     $color_off,
                     $id,
                    );
    join "", @@m;
}

#-> sub CPAN::Module::dslip_status
sub dslip_status {
    my($self) = @@_;
    my($stat);
    # development status
    @@{$stat->{D}}{qw,i c a b R M S,}     = qw,idea
                                              pre-alpha alpha beta released
                                              mature standard,;
    # support level
    @@{$stat->{S}}{qw,m d u n a,}         = qw,mailing-list
                                              developer comp.lang.perl.*
                                              none abandoned,;
    # language
    @@{$stat->{L}}{qw,p c + o h,}         = qw,perl C C++ other hybrid,;
    # interface
    @@{$stat->{I}}{qw,f r O p h n,}       = qw,functions
                                              references+ties
                                              object-oriented pragma
                                              hybrid none,;
    # public licence
    @@{$stat->{P}}{qw,p g l b a 2 o d r n,} = qw,Standard-Perl
                                              GPL LGPL
                                              BSD Artistic Artistic_2
                                              open-source
                                              distribution_allowed
                                              restricted_distribution
                                              no_licence,;
    for my $x (qw(d s l i p)) {
        $stat->{$x}{' '} = 'unknown';
        $stat->{$x}{'?'} = 'unknown';
    }
    my $ro = $self->ro;
    return +{} unless $ro && $ro->{statd};
    return {
            D  => $ro->{statd},
            S  => $ro->{stats},
            L  => $ro->{statl},
            I  => $ro->{stati},
            P  => $ro->{statp},
            DV => $stat->{D}{$ro->{statd}},
            SV => $stat->{S}{$ro->{stats}},
            LV => $stat->{L}{$ro->{statl}},
            IV => $stat->{I}{$ro->{stati}},
            PV => $stat->{P}{$ro->{statp}},
           };
}
d1111 2
a1112 29
#-> sub CPAN::Module::as_string ;
sub as_string {
    my($self) = @@_;
    my(@@m);
    CPAN->debug("$self entering as_string") if $CPAN::DEBUG;
    my $class = ref($self);
    $class =~ s/^CPAN:://;
    local($^W) = 0;
    push @@m, $class, " id = $self->{ID}\n";
    my $sprintf = "    %-12s %s\n";
    push @@m, sprintf($sprintf, 'DESCRIPTION', $self->description)
        if $self->description;
    my $sprintf2 = "    %-12s %s (%s)\n";
    my($userid);
    $userid = $self->userid;
    if ( $userid ) {
        my $author;
        if ($author = CPAN::Shell->expand('Author',$userid)) {
            my $email = "";
            my $m; # old perls
            if ($m = $author->email) {
                $email = " <$m>";
            }
            push @@m, sprintf(
                             $sprintf2,
                             'CPAN_USERID',
                             $userid,
                             $author->fullname . $email
                            );
d1114 14
a1127 37
    }
    push @@m, sprintf($sprintf, 'CPAN_VERSION', $self->cpan_version)
        if $self->cpan_version;
    if (my $cpan_file = $self->cpan_file) {
        push @@m, sprintf($sprintf, 'CPAN_FILE', $cpan_file);
        if (my $dist = CPAN::Shell->expand("Distribution",$cpan_file)) {
            my $upload_date = $dist->upload_date;
            if ($upload_date) {
                push @@m, sprintf($sprintf, 'UPLOAD_DATE', $upload_date);
            }
        }
    }
    my $sprintf3 = "    %-12s %1s%1s%1s%1s%1s (%s,%s,%s,%s,%s)\n";
    my $dslip = $self->dslip_status;
    push @@m, sprintf(
                     $sprintf3,
                     'DSLIP_STATUS',
                     @@{$dslip}{qw(D S L I P DV SV LV IV PV)},
                    ) if $dslip->{D};
    my $local_file = $self->inst_file;
    unless ($self->{MANPAGE}) {
        my $manpage;
        if ($local_file) {
            $manpage = $self->manpage_headline($local_file);
        } else {
            # If we have already untarred it, we should look there
            my $dist = $CPAN::META->instance('CPAN::Distribution',
                                             $self->cpan_file);
            # warn "dist[$dist]";
            # mff=manifest file; mfh=manifest handle
            my($mff,$mfh);
            if (
                $dist->{build_dir}
                and
                (-f  ($mff = File::Spec->catfile($dist->{build_dir}, "MANIFEST")))
                and
                $mfh = FileHandle->new($mff)
d1129 8
a1136 23
                CPAN->debug("mff[$mff]") if $CPAN::DEBUG;
                my $lfre = $self->id; # local file RE
                $lfre =~ s/::/./g;
                $lfre .= "\\.pm\$";
                my($lfl); # local file file
                local $/ = "\n";
                my(@@mflines) = <$mfh>;
                for (@@mflines) {
                    s/^\s+//;
                    s/\s.*//s;
                }
                while (length($lfre)>5 and !$lfl) {
                    ($lfl) = grep /$lfre/, @@mflines;
                    CPAN->debug("lfl[$lfl]lfre[$lfre]") if $CPAN::DEBUG;
                    $lfre =~ s/.+?\.//;
                }
                $lfl =~ s/\s.*//; # remove comments
                $lfl =~ s/\s+//g; # chomp would maybe be too system-specific
                my $lfl_abs = File::Spec->catfile($dist->{build_dir},$lfl);
                # warn "lfl_abs[$lfl_abs]";
                if (-f $lfl_abs) {
                    $manpage = $self->manpage_headline($lfl_abs);
                }
d1139 2
a1140 1
        $self->{MANPAGE} = $manpage if $manpage;
d1142 1
a1142 14
    my($item);
    for $item (qw/MANPAGE/) {
        push @@m, sprintf($sprintf, $item, $self->{$item})
            if exists $self->{$item};
    }
    for $item (qw/CONTAINS/) {
        push @@m, sprintf($sprintf, $item, join(" ",@@{$self->{$item}}))
            if exists $self->{$item} && @@{$self->{$item}};
    }
    push @@m, sprintf($sprintf, 'INST_FILE',
                     $local_file || "(not installed)");
    push @@m, sprintf($sprintf, 'INST_VERSION',
                     $self->inst_version) if $local_file;
    join "", @@m, "\n";
d1145 8
a1152 30
#-> sub CPAN::Module::manpage_headline
sub manpage_headline {
    my($self,$local_file) = @@_;
    my(@@local_file) = $local_file;
    $local_file =~ s/\.pm(?!\n)\Z/.pod/;
    push @@local_file, $local_file;
    my(@@result,$locf);
    for $locf (@@local_file) {
        next unless -f $locf;
        my $fh = FileHandle->new($locf)
            or $Carp::Frontend->mydie("Couldn't open $locf: $!");
        my $inpod = 0;
        local $/ = "\n";
        while (<$fh>) {
            $inpod = m/^=(?!head1\s+NAME\s*$)/ ? 0 :
                m/^=head1\s+NAME\s*$/ ? 1 : $inpod;
            next unless $inpod;
            next if /^=/;
            next if /^\s+$/;
            chomp;
            push @@result, $_;
        }
        close $fh;
        last if @@result;
    }
    for (@@result) {
        s/^\s+//;
        s/\s+$//;
    }
    join " ", @@result;
d1155 3
a1157 32
#-> sub CPAN::Module::cpan_file ;
# Note: also inherited by CPAN::Bundle
sub cpan_file {
    my $self = shift;
    # CPAN->debug(sprintf "id[%s]", $self->id) if $CPAN::DEBUG;
    unless ($self->ro) {
        CPAN::Index->reload;
    }
    my $ro = $self->ro;
    if ($ro && defined $ro->{CPAN_FILE}) {
        return $ro->{CPAN_FILE};
    } else {
        my $userid = $self->userid;
        if ( $userid ) {
            if ($CPAN::META->exists("CPAN::Author",$userid)) {
                my $author = $CPAN::META->instance("CPAN::Author",
                                                   $userid);
                my $fullname = $author->fullname;
                my $email = $author->email;
                unless (defined $fullname && defined $email) {
                    return sprintf("Contact Author %s",
                                   $userid,
                                  );
                }
                return "Contact Author $fullname <$email>";
            } else {
                return "Contact Author $userid (Email address not available)";
            }
        } else {
            return "N/A";
        }
    }
d1160 24
a1183 12
#-> sub CPAN::Module::cpan_version ;
sub cpan_version {
    my $self = shift;

    my $ro = $self->ro;
    unless ($ro) {
        # Can happen with modules that are not on CPAN
        $ro = {};
    }
    $ro->{CPAN_VERSION} = 'undef'
        unless defined $ro->{CPAN_VERSION};
    $ro->{CPAN_VERSION};
d1186 13
a1198 4
#-> sub CPAN::Module::force ;
sub force {
    my($self) = @@_;
    $self->{force_update} = 1;
d1201 2
a1202 2
#-> sub CPAN::Module::fforce ;
sub fforce {
d1204 3
a1206 28
    $self->{force_update} = 2;
}

#-> sub CPAN::Module::notest ;
sub notest {
    my($self) = @@_;
    # $CPAN::Frontend->mywarn("XDEBUG: set notest for Module");
    $self->{notest}++;
}

#-> sub CPAN::Module::rematein ;
sub rematein {
    my($self,$meth) = @@_;
    $CPAN::Frontend->myprint(sprintf("Running %s for module '%s'\n",
                                     $meth,
                                     $self->id));
    my $cpan_file = $self->cpan_file;
    if ($cpan_file eq "N/A" || $cpan_file =~ /^Contact Author/) {
        $CPAN::Frontend->mywarn(sprintf qq{
  The module %s isn\'t available on CPAN.

  Either the module has not yet been uploaded to CPAN, or it is
  temporary unavailable. Please contact the author to find out
  more about the status. Try 'i %s'.
},
                                $self->id,
                                $self->id,
                               );
d1209 5
a1213 7
    my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
    $pack->called_for($self->id);
    if (exists $self->{force_update}) {
        if ($self->{force_update} == 2) {
            $pack->fforce($meth);
        } else {
            $pack->force($meth);
d1215 2
d1218 8
a1225 1
    $pack->notest($meth) if exists $self->{notest} && $self->{notest};
d1227 6
a1232 34
    $pack->{reqtype} ||= "";
    CPAN->debug("dist-reqtype[$pack->{reqtype}]".
                "self-reqtype[$self->{reqtype}]") if $CPAN::DEBUG;
        if ($pack->{reqtype}) {
            if ($pack->{reqtype} eq "b" && $self->{reqtype} =~ /^[rc]$/) {
                $pack->{reqtype} = $self->{reqtype};
                if (
                    exists $pack->{install}
                    &&
                    (
                     UNIVERSAL::can($pack->{install},"failed") ?
                     $pack->{install}->failed :
                     $pack->{install} =~ /^NO/
                    )
                   ) {
                    delete $pack->{install};
                    $CPAN::Frontend->mywarn
                        ("Promoting $pack->{ID} from 'build_requires' to 'requires'");
                }
            }
        } else {
            $pack->{reqtype} = $self->{reqtype};
        }

    my $success = eval {
        $pack->$meth();
    };
    my $err = $@@;
    $pack->unforce if $pack->can("unforce") && exists $self->{force_update};
    $pack->unnotest if $pack->can("unnotest") && exists $self->{notest};
    delete $self->{force_update};
    delete $self->{notest};
    if ($err) {
        die $err;
d1234 1
a1234 1
    return $success;
d1237 3
a1239 21
#-> sub CPAN::Module::perldoc ;
sub perldoc { shift->rematein('perldoc') }
#-> sub CPAN::Module::readme ;
sub readme  { shift->rematein('readme') }
#-> sub CPAN::Module::look ;
sub look    { shift->rematein('look') }
#-> sub CPAN::Module::cvs_import ;
sub cvs_import { shift->rematein('cvs_import') }
#-> sub CPAN::Module::get ;
sub get     { shift->rematein('get',@@_) }
#-> sub CPAN::Module::make ;
sub make    { shift->rematein('make') }
#-> sub CPAN::Module::test ;
sub test   {
    my $self = shift;
    # $self->{badtestcnt} ||= 0;
    $self->rematein('test',@@_);
}

#-> sub CPAN::Module::uptodate ;
sub uptodate {
d1241 1
a1241 10
    local ($_);
    my $inst = $self->inst_version or return undef;
    my $cpan = $self->cpan_version;
    local ($^W) = 0;
    CPAN::Version->vgt($cpan,$inst) and return 0;
    CPAN->debug(join("",
                     "returning uptodate. inst_file[",
                     $self->inst_file,
                     "cpan[$cpan] inst[$inst]")) if $CPAN::DEBUG;
    return 1;
d1244 6
a1249 24
#-> sub CPAN::Module::install ;
sub install {
    my($self) = @@_;
    my($doit) = 0;
    if ($self->uptodate
        &&
        not exists $self->{force_update}
       ) {
        $CPAN::Frontend->myprint(sprintf("%s is up to date (%s).\n",
                                         $self->id,
                                         $self->inst_version,
                                        ));
    } else {
        $doit = 1;
    }
    my $ro = $self->ro;
    if ($ro && $ro->{stats} && $ro->{stats} eq "a") {
        $CPAN::Frontend->mywarn(qq{
\n\n\n     ***WARNING***
     The module $self->{ID} has no active maintainer.\n\n\n
});
        $CPAN::Frontend->mysleep(5);
    }
    $self->rematein('install') if $doit;
a1250 2
#-> sub CPAN::Module::clean ;
sub clean  { shift->rematein('clean') }
d1252 1
a1252 2
#-> sub CPAN::Module::inst_file ;
sub inst_file {
d1254 3
a1256 1
    $self->_file_in_path([@@INC]);
d1259 19
a1277 9
#-> sub CPAN::Module::available_file ;
sub available_file {
    my($self) = @@_;
    my $sep = $Config::Config{path_sep};
    my $perllib = $ENV{PERL5LIB};
    $perllib = $ENV{PERLLIB} unless defined $perllib;
    my @@perllib = split(/$sep/,$perllib) if defined $perllib;
    $self->_file_in_path([@@perllib,@@INC]);
}
d1279 2
a1280 17
#-> sub CPAN::Module::file_in_path ;
sub _file_in_path {
    my($self,$path) = @@_;
    my($dir,@@packpath);
    @@packpath = split /::/, $self->{ID};
    $packpath[-1] .= ".pm";
    if (@@packpath == 1 && $packpath[0] eq "readline.pm") {
        unshift @@packpath, "Term", "ReadLine"; # historical reasons
    }
    foreach $dir (@@$path) {
        my $pmfile = File::Spec->catfile($dir,@@packpath);
        if (-f $pmfile) {
            return $pmfile;
        }
    }
    return;
}
d1282 20
a1301 12
#-> sub CPAN::Module::xs_file ;
sub xs_file {
    my($self) = @@_;
    my($dir,@@packpath);
    @@packpath = split /::/, $self->{ID};
    push @@packpath, $packpath[-1];
    $packpath[-1] .= "." . $Config::Config{'dlext'};
    foreach $dir (@@INC) {
        my $xsfile = File::Spec->catfile($dir,'auto',@@packpath);
        if (-f $xsfile) {
            return $xsfile;
        }
d1303 1
a1303 18
    return;
}

#-> sub CPAN::Module::inst_version ;
sub inst_version {
    my($self) = @@_;
    my $parsefile = $self->inst_file or return;
    my $have = $self->parse_version($parsefile);
    $have;
}

#-> sub CPAN::Module::inst_version ;
sub available_version {
    my($self) = @@_;
    my $parsefile = $self->available_file or return;
    my $have = $self->parse_version($parsefile);
    $have;
}
a1304 22
#-> sub CPAN::Module::parse_version ;
sub parse_version {
    my($self,$parsefile) = @@_;
    my $have = MM->parse_version($parsefile);
    $have = "undef" unless defined $have && length $have;
    $have =~ s/^ //; # since the %vd hack these two lines here are needed
    $have =~ s/ $//; # trailing whitespace happens all the time

    $have = CPAN::Version->readable($have);

    $have =~ s/\s*//g; # stringify to float around floating point issues
    $have; # no stringify needed, \s* above matches always
}

#-> sub CPAN::Module::reports
sub reports {
    my($self) = @@_;
    $self->distribution->reports;
}

package CPAN;
use strict;
d1356 2
a1357 2
capabilities and knows how to use Net::FTP or LWP or some external
download clients to fetch the distributions from the net.
d1359 1
a1359 1
These are fetched from one or more of the mirrored CPAN (Comprehensive
d1362 2
a1363 2
The CPAN module also supports the concept of named and versioned
I<bundles> of modules. Bundles simplify the handling of sets of
d1367 1
a1367 1
session manager keeps track of what has been fetched, built and
d1370 1
a1370 1
according to a simple FIFO mechanism.
d1377 1
a1377 1
The interactive mode is entered by running
d1386 2
a1387 2
either C<Term::ReadLine::Perl> or C<Term::ReadLine::Gnu> are installed
it supports both history and command completion.
d1389 2
a1390 2
Once you are on the command line, type C<h> to get a one page help
screen and the rest should be self-explanatory.
d1392 2
a1393 2
The function call C<shell> takes two optional arguments, one is the
prompt, the second is the default initial command line (the latter
d1407 5
a1411 5
Arguments you pass to these commands are either strings exactly matching
the identification string of an object or regular expressions that are
then matched case-insensitively against various attributes of the
objects. The parser recognizes a regular expression only if you
enclose it between two slashes.
d1413 1
a1413 1
The principle is that the number of found objects influences how an
d1415 2
a1416 2
displayed with the rather verbose method C<as_string>, but if we find
more than one, we display each object with the terse method
d1419 38
d1470 1
a1470 1
Any C<make> or C<test> are run unconditionally. An
d1474 1
a1474 1
also is run unconditionally. But for
d1478 3
a1480 3
CPAN checks if an install is actually needed for it and prints
I<module up to date> in the case that the distribution file containing
the module doesn't need to be updated.
d1483 1
a1483 1
and doesn't try to build a package a second time regardless if it
d1488 2
a1489 2
C<make>, C<test>, or C<install>) and executes the command from scratch
and tries to continue in case of some errors. See the section below on
d1492 1
a1492 1
The C<notest> pragma may be used to skip the test part in the build
d1510 2
a1511 2
that directory. C<perldoc> displays the pod documentation of the
module in html or plain text format.
d1518 2
a1519 2
CPAN directory as they are stored in the CHECKUMS files distributed on
CPAN. The listing goes recursive into all subdirectories.
d1521 1
a1521 1
The second form allows to limit or expand the output with shell
d1533 1
a1533 1
regarded as a bug and may be changed in future versions.
d1550 3
a1552 3
signature matches the currently running perl the stored state is
loaded into memory such that effectively persistence between sessions
is established.
d1559 1
a1559 1
A C<test> is only repeated if the previous test was unsuccessful. The
d1563 1
a1563 1
C<install> if the according C<test> was not successful.
d1565 1
a1565 1
In all these cases, the user can override the goatish behaviour by
d1573 1
a1573 1
Each I<forced> command is executed with the according part of its
d1582 2
a1583 2
Interactive sessions maintain a lockfile, per default C<~/.cpan/.lock>.
Batch jobs can run without a lockfile and do not disturb each other.
d1585 1
a1585 1
The shell offers to run in I<degraded mode> when another process is
d1588 1
a1588 1
file, does not use the metadata file and has a different prompt.
d1593 1
a1593 1
in the cpan-shell it is intended that you can press C<^C> anytime and
d1599 1
a1599 1
CPAN.pm ignores a SIGPIPE. If the user sets C<inactivity_timeout>, a
d1607 6
a1612 6
The commands that are available in the shell interface are methods in
the package CPAN::Shell. If you enter the shell command, all your
input is split by the Text::ParseWords::shellwords() routine which
acts like most shells do. The first word is being interpreted as the
method to be called and the rest of the words are treated as arguments
to this method. Continuation lines are supported if a line ends with a
d1631 1
a1631 1
configured or YAML not installed, then no stats are provided.
d1635 1
a1635 1
mkmyconfig() writes your own CPAN::MyConfig file into your ~/.cpan/
d1637 1
a1637 1
system wide ones.
d1642 2
a1643 3
displays them I<slowly>. While the command is running $SIG{INT} is
defined to mean that the loop shall be left after having displayed the
current item.
d1647 3
a1649 3
B<Note>: This whole command currently is a bit klunky and will
probably change in future versions of CPAN.pm but the general
approach will likely stay.
d1655 1
a1655 1
recompile() is a very special command in that it takes no argument and
d1659 1
a1659 1
installation. Imagine, you have a common source tree for two different
d1676 1
a1676 1
arguments. The C<force> pragma is used to re-run the tests and repeat
d1691 3
a1693 3
B<Note>: This whole command currently is a bit klunky and will
probably change in future versions of CPAN.pm but the general
approach will likely stay.
d1706 2
a1707 2
for both users and programmer. CPAN.pm deals with above mentioned four
classes, and all those classes share a set of methods. A classical
d1765 1
a1765 1
prerequisites, cares for them recursively and finally finishes the
d1772 7
d1782 1
a1782 1
dialog tries to determine a couple of site specific options. The
d1786 1
a1786 1
The default values defined in the CPAN/Config.pm file can be
d1788 1
a1788 1
best placed in $HOME/.cpan/CPAN/MyConfig.pm, because $HOME/.cpan is
d1808 1
a1808 1
Displays the current value(s) for this config variable. Without KEY
d1815 2
a1816 2
If KEY starts and ends with a slash the string in between is
interpreted as a regular expression and only keys matching this regex
d1840 1
a1840 1
Likewise, C<o conf KEY splice LIST> passes the LIST to the according
d1870 2
a1871 2
Currently the following keys in the hash reference $CPAN::Config are
defined:
a1882 4
  commands_quote     prefered character to use for quoting external
                     commands when running them. Defaults to double
                     quote on Windows, single tick everywhere else;
                     can be set to space to disable quoting
d1890 7
d1905 2
d1910 2
d1917 2
a1918 2
                     never break.
  index_expire       after this many days refetch index files
d1920 1
a1920 1
                     if true, does not print the startup message
d1944 2
d1950 1
a1950 1
                     used in any case
d1970 3
d1979 1
a1979 1
  yaml_load_code     enable YAML code deserialisation
d2027 3
a2029 3
determine its own current working directory. Per default it uses
Cwd::cwd but if this doesn't work on your system for some reason,
alternatives can be configured according to the following table:
d2066 2
a2067 2
URLs that are to be used for downloading. If the list contains any
C<file> URLs, CPAN always tries to get files from there first. This
d2076 1
a2076 1
module if there is a local copy of the most recent version.
d2094 2
a2095 2
To get some interesting statistics it is recommended to set the
C<randomize_urllist> parameter that introduces some amount of
d2103 3
a2105 3
C<build_requires_install_policy> to C<no> such a module is not being
installed. It is only built and tested and then kept in the list of
tested but uninstalled modules. As such it is available during the
d2118 2
a2119 2
Distributions on the CPAN usually behave according to what we call the
CPAN mantra. Or since the event of Module::Build we should talk about
d2128 2
a2129 2
some extra data from the user via the environment, extra arguments or
interactively thus disturbing the installation of large bundles like
d2157 1
a2157 1
specify dependencies that the original maintainer forgot to specify
d2170 1
a2170 1
The YAML files themselves must have the C<.yml> extension, all other
d2178 1
a2178 1
specification and every single document is treated as an entity that
d2181 1
a2181 1
The names of the files can be picked freely, C<CPAN.pm> always reads
d2189 1
a2189 1
If neither your configured C<yaml_module> nor YAML.pm is installed
d2209 1
a2209 1
a few YAML files to Data::Dumper for the crucial modules like
d2226 1
d2230 3
d2319 7
d2328 1
a2328 1
The canonical name of a delegate distribution that shall be installed
d2336 1
a2336 1
phase of the CPAN mantra. See below under I<Processiong Instructions>.
d2341 1
a2341 1
CPAN mantra. See below under I<Processiong Instructions>.
d2346 3
a2348 2
C<perl>, and C<perlconfig> that specify if a document is targeted at a
specific CPAN distribution or installation.
d2362 2
a2363 1
living in the C< Config.pm > module.
d2365 9
a2373 5
If more than one restriction of C<module>, C<distribution>, and
C<perl> is specified, the results of the separately computed match
values must all match. If this is the case then the hashref
represented by the YAML document is returned as the preference
structure for the current distribution.
d2378 1
a2378 1
order via the external patch program. If the value for the C<-p>
d2380 6
a2385 1
beforehand.
d2396 1
a2396 1
Build.PL> phase of the CPAN mantra. See below under I<Processiong
d2402 1
a2402 1
of the CPAN mantra. See below under I<Processiong Instructions>.
d2416 2
a2417 2
A full commandline that will be executed as it stands by a system
call. During the execution the environment variable PERL will is set
d2419 1
a2419 1
the content of C<args> is not used.
d2431 3
a2433 3
C<timeout> denotes a timeout in seconds. Floating point timeouts are
OK. In the case of a C<mode=deterministic> the timeout denotes the
timeout per question, in the case of C<mode=anyorder> it denotes the
d2438 1
a2438 1
strings. The Expect module will then watch the stream coming from the
d2442 2
a2443 2
In the case of C<mode=deterministic> the CPAN.pm will inject the
according answer as soon as the stream matches the regular expression.
d2445 1
a2445 1
In the case of C<mode=anyorder> CPAN.pm will answer a question as soon
d2447 1
a2447 1
this mode you can use the C<reuse> parameter to decide what shall
d2449 2
a2450 2
default case (reuse=0) it is removed from the array, so it cannot be
used again accidentally. In this case, if you want to answer the
d2464 1
a2464 1
  eexpect:
d2475 1
a2475 1
syntactical correctness.
d2481 1
a2481 1
they cannot fit everybody's purpose. After all the authors of the
d2484 1
a2484 1
needs. You have beend warned:-)
d2488 2
a2489 2
If you do not enter the shell, the available shell commands are both
available as methods (C<CPAN::Shell-E<gt>install(...)>) and as
d2491 1
a2491 1
commands it makes sense to initialize components of CPAN you need, e.g.:
d2513 1
a2513 1
given. In scalar context it only returns the first element of the
d2519 1
a2519 1
CPAN::Bundle objects for bundles, CPAN::Module objects for modules and
d2547 1
a2547 1
Or if you want to write a cronjob to watch The CPAN, you could list
d2552 4
a2555 4
If you don't want to get any output in the case that all modules are
up to date, you can parse the output of above command for the regular
expression //modules are up to date// and decide to mail the output
only if it doesn't match. Ick?
d2557 2
a2558 2
If you prefer to do it more in a programmer style in one single
process, maybe something like this suits you better:
d2568 2
a2569 2
If that gives you too much output every day, you maybe only want to
watch for three modules. You can write
d2700 2
a2701 2
Only works for distributions listed in the 02packages.details.txt.gz
file. This typically means that only the most recent version of a
d2736 2
a2737 2
yet been run, it will be run first. A C<make test> will be issued in
any case and if this fails, the install will be canceled. The
d2741 2
a2742 2
This install method has only the power to install the distribution if
there are no dependencies in the way. To install an object and all of
d2749 1
a2749 1
Install all the distributions that have been tested sucessfully but
a2758 5
=item CPAN::Distribution::is_tested()

List all the distributions that have been tested sucessfully but not
yet installed. See also C<install_tested>.

d2774 4
a2777 4
distribution (in html format) and runs it through the external
command lynx specified in C<$CPAN::Config->{lynx}>. If lynx
isn't available, it converts it to plain text with external
command html2text and runs it through the pager specified
d2785 1
a2785 1
alphabetically and the canonical distroname (e.g.
d2789 1
a2789 1
agains the regular expressions in the $root->{match}{module} attribute
d2796 1
a2796 1
as the the C<requires> and C<build_requires> elements. These can be
d2811 1
a2811 1
Downloads report data for this distribution from cpantesters.perl.org
d2946 3
a2948 3
Forces CPAN to perform a task that it normally would have refused to
do. Force takes as arguments a method name to be called and any number
of additional arguments that should be passed to the called method.
d2960 1
a2960 1
is reported just like perl itself stops searching @@INC when it finds a
d2995 1
a2995 1
headline and returns it. Moreover, if the module has been downloaded
d2997 1
a2997 1
if it is not installed.
d3078 1
a3078 1
"file:" URLs, then you only need a perl better than perl5.003 to run
d3080 1
a3080 1
required for non-UNIX systems or if your nearest CPAN site is
d3113 1
a3113 1
without much enthusiasm).
d3119 4
a3122 4
The debugging of this module is a bit complex, because we have
interferences of the software producing the indices on CPAN, of the
mirroring process on CPAN, of packaging, of configuration, of
synchronicity, and of bugs within CPAN.pm.
d3124 2
a3125 2
For debugging the code of CPAN.pm itself in interactive mode some more
or less useful debugging aid can be turned on for most packages within
d3149 1
a3149 1
What seems quite a successful strategy is the combination of C<reload
d3166 3
a3168 3
CPAN.pm works nicely without network too. If you maintain machines
that are not networked at all, you should consider working with file:
URLs. Of course, you have to collect your modules somewhere first. So
d3182 2
a3183 2
the running CPAN.pm which are considered optional. The config variable
C<dontload_list> can be used to intercept the C<has_inst()> call such
d3185 1
a3185 1
example the following command will prevent that C<YAML.pm> is being
d3194 1
a3194 1
Returns true if the module is installed and is in a usable state. Only
d3201 2
a3202 2
distributions, authors and bundles. If the object already exists, this
method returns the object, otherwise it calls the constructor.
d3215 1
a3215 1
Since release 1.77 CPAN.pm has been able to verify cryptographically
d3233 1
a3233 1
Most functions in package CPAN are exported per default. The reason
d3240 1
a3240 1
the environment CPAN_SHELL_LEVEL to 1 or increments it if it is
d3262 1
a3262 1
Populating a freshly installed perl with my favorite modules is pretty
d3266 2
a3267 2
file for all modules that are installed for the currently running perl
interpreter. It's recommended to run this command only once and from then
d3273 2
a3274 1
then answer a few questions and then go out for a coffee.
d3280 3
a3282 3
prerequisites as early as possible. On the other hand, it's a bit
annoying that many distributions need some interactive configuring. So
what I try to accomplish in my private bundle file is to have the
d3284 2
a3285 2
ones later, so I can go out after a few minutes and leave CPAN.pm
untended.
d3292 3
a3294 3
documentation that comes with the ncftp program. If you are unable to
go through the firewall with a simple Perl setup, it is very likely
that you can configure ncftp so that it works for your firewall.
d3304 5
a3308 5
This is where the firewall machine runs a web server and to access the
outside world you must do it via the web server. If you set environment
variables like http_proxy or ftp_proxy to a values beginning with http://
or in your web browser you have to set proxy information then you know
you are running an http firewall.
d3311 1
a3311 1
ftp) you will need to use LWP.
d3318 1
a3318 1
entering a username like "user@@outside.host.com"
d3320 2
a3321 2
To access servers outside these type of firewalls with perl you
will need to use Net::FTP.
d3323 1
a3323 1
=item One way visibility
d3325 5
a3329 5
I say one way visibility as these firewalls try to make themselves look
invisible to the users inside the firewall. An FTP data connection is
normally created by sending the remote server your IP address and then
listening for the connection. But the remote server will not be able to
connect to you because of the firewall. So for these types of firewall
d3338 2
a3339 2
If you are using a SOCKS firewall you will need to compile perl and link
it with the SOCKS library, this is what is normally called a 'socksified'
d3341 1
a3341 1
the firewall as if it is not there.
d3345 4
a3348 3
This is the firewall implemented in the Linux kernel, it allows you to
hide a complete network behind one IP address. With this firewall no
special compiling is needed as you can access hosts directly.
d3385 1
a3385 1
Most probably you B<do> have the old version installed. This can
d3463 1
a3463 2
and then (oh joy) the equivalent command for Module::Build. That would
be
d3511 1
a3511 1
order. It resolves perfectly well IF all modules declare the
d3519 1
a3519 1
In our intranet we have many modules for internal use. How
d3528 1
a3528 1
/etc/inputrc (or ~/.inputrc) file.
d3532 1
a3532 1
accordingly. Please make a backup of the /etc/inputrc or ~/.inputrc
d3569 1
a3569 1
and then 'make install' directly in the subshell.
d3608 2
a3609 1
What's the best CPAN site for me?
d3621 8
d3638 20
d3679 1
a3679 1
more modular but it was never tried to make it compatible with CPAN.pm.
a3717 2


@


1.7
log
@merge in perl 5.8.8
@
text
@d2 1
d4 2
a5 7
$VERSION = '1.76_02';
$VERSION = eval $VERSION;
# $Id: CPAN.pm,v 1.6 2003/12/03 03:02:35 millert Exp $

# only used during development:
$Revision = "";
# $Revision = "[".substr(q$Revision: 1.6 $, 10)."]";
d7 6
d16 1
a16 1
use DirHandle;
d18 3
a20 1
use ExtUtils::MakeMaker (); # $SelfLoader::DEBUG=1;
d25 1
d27 1
d29 1
d31 14
a44 5
use Text::Wrap;
use File::Spec;
use Sys::Hostname;
no lib "."; # we need to run chdir all over and we would get at wrong
            # libraries there
d47 2
d50 1
a50 20
END { $End++; &cleanup; }

%CPAN::DEBUG = qw[
		  CPAN              1
		  Index             2
		  InfoObj           4
		  Author            8
		  Distribution     16
		  Bundle           32
		  Module           64
		  CacheMgr        128
		  Complete        256
		  FTP             512
		  Shell          1024
		  Eval           2048
		  Config         4096
		  Tarzip         8192
		  Version       16384
		  Queue         32768
];
a51 1
$CPAN::DEBUG ||= 0;
d54 36
a89 4
$CPAN::Defaultsite ||= "ftp://ftp.perl.org/pub/CPAN";

package CPAN;
use strict qw(vars);
d91 1
a91 3
use vars qw($VERSION @@EXPORT $AUTOLOAD $DEBUG $META $HAS_USABLE $term
            $Revision $Signal $End $Suppress_readline $Frontend
            $Defaultsite $Have_warned);
d95 2
d98 56
a153 17
	     autobundle bundle expand force get cvs_import
	     install make readme recompile shell test clean
	    );

#-> sub CPAN::AUTOLOAD ;
sub AUTOLOAD {
    my($l) = $AUTOLOAD;
    $l =~ s/.*:://;
    my(%EXPORT);
    @@EXPORT{@@EXPORT} = '';
    CPAN::Config->load unless $CPAN::Config_loaded++;
    if (exists $EXPORT{$l}){
	CPAN::Shell->$l(@@_);
    } else {
	$CPAN::Frontend->mywarn(qq{Unknown command "$AUTOLOAD". }.
				qq{Type ? for help.
});
d161 1
a161 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
d163 1
a163 1
    my $oprompt = shift || "cpan> ";
d166 1
d170 1
a170 1
	require Term::ReadLine;
d177 9
a185 9
	if ($term->ReadLine eq "Term::ReadLine::Gnu") {
	    my $attribs = $term->Attribs;
	     $attribs->{attempted_completion_function} = sub {
		 &CPAN::Complete::gnu_cpl;
	     }
	} else {
	    $readline::rl_completion_function =
		$readline::rl_completion_function = 'CPAN::Complete::cpl';
	}
d191 1
a191 8
            my($fh) = FileHandle->new;
            open $fh, "<$histfile" or last;
            local $/ = "\n";
            while (<$fh>) {
                chomp;
                $term->AddHistory($_);
            }
            close $fh;
d193 10
a202 6
	# $term->OUT is autoflushed anyway
	my $odef = select STDERR;
	$| = 1;
	select STDOUT;
	$| = 1;
	select $odef;
a204 1
    # no strict; # I do not recall why no strict was here (2000-09-03)
d206 4
a209 1
    my $cwd = CPAN::anycwd();
d212 7
a218 7
    my $rl_avail = $Suppress_readline ? "suppressed" :
	($term->ReadLine ne "Term::ReadLine::Stub") ? "enabled" :
	    "available (try 'install Bundle::CPAN')";

    $CPAN::Frontend->myprint(
			     sprintf qq{
cpan shell -- CPAN exploration and modules installation (v%s%s)
d222 4
a225 5
                             $CPAN::VERSION,
                             $CPAN::Revision,
                             $rl_avail
                            )
        unless $CPAN::Config->{'inhibit_startup_message'} ;
d227 1
d229 13
a241 6
	if ($Suppress_readline) {
	    print $prompt;
	    last SHELLCOMMAND unless defined ($_ = <> );
	    chomp;
	} else {
	    last SHELLCOMMAND unless
d243 66
a308 41
	}
	$_ = "$continuation$_" if $continuation;
	s/^\s+//;
	next SHELLCOMMAND if /^$/;
	$_ = 'h' if /^\s*\?/;
	if (/^(?:q(?:uit)?|bye|exit)$/i) {
	    last SHELLCOMMAND;
	} elsif (s/\\$//s) {
	    chomp;
	    $continuation = $_;
	    $prompt = "    > ";
	} elsif (/^\!/) {
	    s/^\!//;
	    my($eval) = $_;
	    package CPAN::Eval;
	    use vars qw($import_done);
	    CPAN->import(':DEFAULT') unless $import_done++;
	    CPAN->debug("eval[$eval]") if $CPAN::DEBUG;
	    eval($eval);
	    warn $@@ if $@@;
	    $continuation = "";
	    $prompt = $oprompt;
	} elsif (/./) {
	    my(@@line);
	    if ($] < 5.00322) { # parsewords had a bug until recently
		@@line = split;
	    } else {
		eval { @@line = Text::ParseWords::shellwords($_) };
		warn($@@), next SHELLCOMMAND if $@@;
                warn("Text::Parsewords could not parse the line [$_]"),
                    next SHELLCOMMAND unless @@line;
	    }
	    $CPAN::META->debug("line[".join("|",@@line)."]") if $CPAN::DEBUG;
	    my $command = shift @@line;
	    eval { CPAN::Shell->$command(@@line) };
	    warn $@@ if $@@;
	    chdir $cwd or $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!});
	    $CPAN::Frontend->myprint("\n");
	    $continuation = "";
	    $prompt = $oprompt;
	}
d310 45
a354 16
      $commandline = ""; # I do want to be able to pass a default to
                         # shell, but on the second command I see no
                         # use in that
      $Signal=0;
      CPAN::Queue->nullify_queue;
      if ($try_detect_readline) {
	if ($CPAN::META->has_inst("Term::ReadLine::Gnu")
	    ||
	    $CPAN::META->has_inst("Term::ReadLine::Perl")
	   ) {
	    delete $INC{"Term/ReadLine.pm"};
	    my $redef = 0;
	    local($SIG{__WARN__}) = CPAN::Shell::paintdots_onreload(\$redef);
	    require Term::ReadLine;
	    $CPAN::Frontend->myprint("\n$redef subroutines in ".
				     "Term::ReadLine redefined\n");
d356 164
a519 3
	    goto &shell;
	}
      }
a520 1
    chdir $cwd or $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!});
d524 1
a527 9
package CPAN::Config;
use vars qw(%can $dot_cpan);

%can = (
  'commit' => "Commit changes to disk",
  'defaults' => "Reload defaults from disk",
  'init'   => "Interactive setting of all options",
);

d529 3
a531 1
use vars qw($Ua $Thesite $Themethod);
d535 1
d537 1
a537 1
# we delay requiring LWP::UserAgent and setting up inheritence until we need it
d540 1
d542 2
d545 32
a576 4
		       ! a b d h i m o q r u autobundle clean dump
		       make test install force readme reload look
                       cvs_import ls
) unless @@CPAN::Complete::COMMANDS;
d579 2
a580 1
use vars qw($LAST_TIME $DATE_OF_02 $DATE_OF_03);
d588 1
d592 1
d596 1
d600 1
d604 1
d608 1
d611 4
d618 49
a666 5
    my @@deps;
    my %seen;
    for my $dep (@@$deps) {
        push @@deps, $dep;
        last if $seen{$dep}++;
d673 4
a676 3
    "\nRecursive dependency detected:\n    " .
        join("\n => ", @@{$self->{deps}}) .
            ".\nCannot continue.\n";
d679 3
a681 5
package CPAN::Shell;
use vars qw($AUTOLOAD @@ISA $COLOR_REGISTERED $ADVANCED_QUERY $PRINT_ORNAMENTING);
@@CPAN::Shell::ISA = qw(CPAN::Debug);
$COLOR_REGISTERED ||= 0;
$PRINT_ORNAMENTING ||= 0;
d683 3
a685 22
#-> sub CPAN::Shell::AUTOLOAD ;
sub AUTOLOAD {
    my($autoload) = $AUTOLOAD;
    my $class = shift(@@_);
    # warn "autoload[$autoload] class[$class]";
    $autoload =~ s/.*:://;
    if ($autoload =~ /^w/) {
	if ($CPAN::META->has_inst('CPAN::WAIT')) {
	    CPAN::WAIT->$autoload(@@_);
	} else {
	    $CPAN::Frontend->mywarn(qq{
Commands starting with "w" require CPAN::WAIT to be installed.
Please consider installing CPAN::WAIT to use the fulltext index.
For this you just need to type
    install CPAN::WAIT
});
	}
    } else {
	$CPAN::Frontend->mywarn(qq{Unknown command '$autoload'. }.
				qq{Type ? for help.
});
    }
d688 4
a691 51
package CPAN::Tarzip;
use vars qw($AUTOLOAD @@ISA $BUGHUNTING);
@@CPAN::Tarzip::ISA = qw(CPAN::Debug);
$BUGHUNTING = 0; # released code must have turned off

package CPAN::Queue;

# One use of the queue is to determine if we should or shouldn't
# announce the availability of a new CPAN module

# Now we try to use it for dependency tracking. For that to happen
# we need to draw a dependency tree and do the leaves first. This can
# easily be reached by running CPAN.pm recursively, but we don't want
# to waste memory and run into deep recursion. So what we can do is
# this:

# CPAN::Queue is the package where the queue is maintained. Dependencies
# often have high priority and must be brought to the head of the queue,
# possibly by jumping the queue if they are already there. My first code
# attempt tried to be extremely correct. Whenever a module needed
# immediate treatment, I either unshifted it to the front of the queue,
# or, if it was already in the queue, I spliced and let it bypass the
# others. This became a too correct model that made it impossible to put
# an item more than once into the queue. Why would you need that? Well,
# you need temporary duplicates as the manager of the queue is a loop
# that
#
#  (1) looks at the first item in the queue without shifting it off
#
#  (2) cares for the item
#
#  (3) removes the item from the queue, *even if its agenda failed and
#      even if the item isn't the first in the queue anymore* (that way
#      protecting against never ending queues)
#
# So if an item has prerequisites, the installation fails now, but we
# want to retry later. That's easy if we have it twice in the queue.
#
# I also expect insane dependency situations where an item gets more
# than two lives in the queue. Simplest example is triggered by 'install
# Foo Foo Foo'. People make this kind of mistakes and I don't want to
# get in the way. I wanted the queue manager to be a dumb servant, not
# one that knows everything.
#
# Who would I tell in this model that the user wants to be asked before
# processing? I can't attach that information to the module object,
# because not modules are installed but distributions. So I'd have to
# tell the distribution object that it should ask the user before
# processing. Where would the question be triggered then? Most probably
# in CPAN::Distribution::rematein.
# Hope that makes sense, my head is a bit off:-) -- AK
d693 3
a695 1
use vars qw{ @@All };
a696 1
# CPAN::Queue::new ;
d698 5
a702 22
  my($class,$s) = @@_;
  my $self = bless { qmod => $s }, $class;
  push @@All, $self;
  return $self;
}

# CPAN::Queue::first ;
sub first {
  my $obj = $All[0];
  $obj->{qmod};
}

# CPAN::Queue::delete_first ;
sub delete_first {
  my($class,$what) = @@_;
  my $i;
  for my $i (0..$#All) {
    if (  $All[$i]->{qmod} eq $what ) {
      splice @@All, $i, 1;
      return;
    }
  }
d705 14
a718 21
# CPAN::Queue::jumpqueue ;
sub jumpqueue {
    my $class = shift;
    my @@what = @@_;
    CPAN->debug(sprintf("before jumpqueue All[%s] what[%s]",
                        join(",",map {$_->{qmod}} @@All),
                        join(",",@@what)
                       )) if $CPAN::DEBUG;
  WHAT: for my $what (reverse @@what) {
        my $jumped = 0;
        for (my $i=0; $i<$#All;$i++) { #prevent deep recursion
            CPAN->debug("i[$All[$i]]what[$what]") if $CPAN::DEBUG;
            if ($All[$i]->{qmod} eq $what){
                $jumped++;
                if ($jumped > 100) { # one's OK if e.g. just
                                     # processing now; more are OK if
                                     # user typed it several times
                    $CPAN::Frontend->mywarn(
qq{Object [$what] queued more than 100 times, ignoring}
				 );
                    next WHAT;
d720 4
d725 3
d729 2
a730 2
        my $obj = bless { qmod => $what }, $class;
        unshift @@All, $obj;
a731 4
    CPAN->debug(sprintf("after jumpqueue All[%s] what[%s]",
                        join(",",map {$_->{qmod}} @@All),
                        join(",",@@what)
                       )) if $CPAN::DEBUG;
d734 17
a750 7
# CPAN::Queue::exists ;
sub exists {
  my($self,$what) = @@_;
  my @@all = map { $_->{qmod} } @@All;
  my $exists = grep { $_->{qmod} eq $what } @@All;
  # warn "in exists what[$what] all[@@all] exists[$exists]";
  $exists;
d753 19
a771 4
# CPAN::Queue::delete ;
sub delete {
  my($self,$mod) = @@_;
  @@All = grep { $_->{qmod} ne $mod } @@All;
d774 24
a797 3
# CPAN::Queue::nullify_queue ;
sub nullify_queue {
  @@All = ();
d800 99
a898 1

d901 1
d908 44
d955 1
a955 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
a959 1
*all = \&all_objects;
d971 18
a988 17
	my $fh = FileHandle->new($lockfile) or
            $CPAN::Frontend->mydie("Could not open $lockfile: $!");
	my $otherpid  = <$fh>;
	my $otherhost = <$fh>;
	$fh->close;
	if (defined $otherpid && $otherpid) {
	    chomp $otherpid;
        }
	if (defined $otherhost && $otherhost) {
	    chomp $otherhost;
	}
	my $thishost  = hostname();
	if (defined $otherhost && defined $thishost &&
	    $otherhost ne '' && $thishost ne '' &&
	    $otherhost ne $thishost) {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile $lockfile\n".
                                           "reports other host $otherhost and other process $otherpid.\n".
d990 6
a995 5
	}
	elsif (defined $otherpid && $otherpid) {
	    return if $$ == $otherpid; # should never happen
	    $CPAN::Frontend->mywarn(
				    qq{
d998 21
a1018 3
	    if (kill 0, $otherpid) {
		$CPAN::Frontend->mydie(qq{Other job is running.
You may want to kill it and delete the lockfile, maybe. On UNIX try:
d1021 21
a1041 21
});
	    } elsif (-w $lockfile) {
		my($ans) =
		    ExtUtils::MakeMaker::prompt
			(qq{Other job not responding. Shall I overwrite }.
			 qq{the lockfile? (Y/N)},"y");
		$CPAN::Frontend->myexit("Ok, bye\n")
		    unless $ans =~ /^y/i;
	    } else {
		Carp::croak(
			    qq{Lockfile $lockfile not writeable by you. }.
			    qq{Cannot proceed.\n}.
			    qq{    On UNIX try:\n}.
			    qq{    rm $lockfile\n}.
			    qq{  and then rerun us.\n}
			   );
	    }
	} else {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile $lockfile\n".
                                           "reports other process with ID ".
                                           "$otherpid. Cannot proceed.\n"));
d1047 12
a1058 12
      # A special case at least for Jarkko.
      my $firsterror = $@@;
      my $seconderror;
      my $symlinkcpan;
      if (-l $dotcpan) {
	$symlinkcpan = readlink $dotcpan;
	die "readlink $dotcpan failed: $!" unless defined $symlinkcpan;
	eval { File::Path::mkpath($symlinkcpan); };
	if ($@@) {
	  $seconderror = $@@;
	} else {
	  $CPAN::Frontend->mywarn(qq{
d1061 4
a1064 4
	}
      }
      unless (-d $dotcpan) {
	my $diemess = qq{
d1068 1
a1068 1
	$diemess .= qq{
d1072 1
a1072 1
	$diemess .= qq{
d1075 16
a1090 9
	$CPAN::Frontend->mydie($diemess);
      }
    }
    my $fh;
    unless ($fh = FileHandle->new(">$lockfile")) {
	if ($! =~ /Permission/) {
	    my $incc = $INC{'CPAN/Config.pm'};
	    my $myincc = File::Spec->catfile($ENV{HOME},'.cpan','CPAN','MyConfig.pm');
	    $CPAN::Frontend->myprint(qq{
d1102 14
a1115 4
this variable in either
    $incc
or
    $myincc
d1117 7
a1123 3
});
	}
	$CPAN::Frontend->mydie("Could not open >$lockfile: $!");
a1124 4
    $fh->print($$, "\n");
    $fh->print(hostname(), "\n");
    $self->{LOCK} = $lockfile;
    $fh->close;
d1126 3
a1128 2
      &cleanup;
      $CPAN::Frontend->mydie("Got SIGTERM, leaving");
d1132 6
a1137 4
      &cleanup if $Signal;
      $CPAN::Frontend->mydie("Got another SIGINT") if $Signal;
      print "Caught SIGINT\n";
      $Signal++;
d1183 32
d1218 1
a1218 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
d1222 9
a1230 2
    exists $META->{readonly}{$class}{$id} or
        exists $META->{readwrite}{$class}{$id}; # unsafe meta access, ok
d1258 1
a1258 1
               Net::FTP => [
d1261 35
a1295 1
                           ]
d1298 8
a1305 6
      for my $c (0..$#{$usable->{$mod}}) {
        my $code = $usable->{$mod}[$c];
        my $ret = eval { &$code() };
        if ($@@) {
          warn "DEBUG: c[$c]\$\@@[$@@]ret[$ret]";
          return;
a1306 1
      }
d1315 5
a1319 4
	unless defined $mod;
    if (defined $message && $message eq "no"
        ||
        exists $CPAN::META->{dontload_hash}{$mod} # unsafe meta access, ok
d1321 1
a1321 1
        exists $CPAN::Config->{dontload_hash}{$mod}
d1331 6
a1336 6
	# checking %INC is wrong, because $INC{LWP} may be true
	# although $INC{"URI/URL.pm"} may have failed. But as
	# I really want to say "bla loaded OK", I have to somehow
	# cache results.
	### warn "$file in %INC"; #debug
	return 1;
d1338 16
a1353 10
	# eval is good: if we haven't yet read the database it's
	# perfect and if we have installed the module in the meantime,
	# it tries again. The second require is only a NOOP returning
	# 1 if we had success, otherwise it's retrying

	$CPAN::Frontend->myprint("CPAN: $mod loaded ok\n");
	if ($mod eq "CPAN::WAIT") {
	    push @@CPAN::Shell::ISA, CPAN::WAIT;
	}
	return 1;
d1355 1
a1355 1
	$CPAN::Frontend->mywarn(qq{
d1361 33
a1393 5
	sleep 3;
    } elsif ($mod eq "Digest::MD5"){
	$CPAN::Frontend->myprint(qq{
  CPAN: MD5 security checks disabled because Digest::MD5 not installed.
  Please consider installing the Digest::MD5 module.
d1396 3
a1398 1
	sleep 2;
d1400 1
a1400 1
	delete $INC{$file}; # if it inc'd LWP but failed during, say, URI
d1422 1
a1422 1
  # warn "cleanup called with arg[@@_] End[$End] Signal[$Signal]";
d1430 1
a1430 1
	  $subroutine eq '(eval)';
d1432 1
a1432 1
  return if $ineval && !$End;
d1436 1
d1440 17
a1456 1
  $CPAN::Frontend->mywarn("Lockfile removed.\n");
d1463 1
a1463 1
    unless ($histfile = $CPAN::Config->{'histfile'}){
d1468 1
a1468 1
    if ($CPAN::term){
d1485 1
d1487 6
a1492 2
    my($self,$what) = @@_;
    $self->{is_tested}{$what} = 1;
d1495 3
d1503 8
d1512 5
a1516 1
    my($self) = @@_;
d1523 23
a1545 2
    my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} keys %{$self->{is_tested}};
    $CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB.\n");
d1550 1
d1556 1
a1556 1
	return shift->SUPER::as_string;
d1558 1
a1558 1
	return Data::Dumper::Dumper(shift);
d1570 1
d1572 3
a1574 2
  while ($self->{DU} > $self->{'MAX'} ) {
    my($toremove) = shift @@{$self->{FIFO}};
d1576 6
a1581 4
				     "Deleting from cache".
				     ": $toremove (%.1f>%.1f MB)\n",
				     $self->{DU}, $self->{'MAX'})
			    );
d1583 1
a1583 1
    $self->force_clean_cache($toremove);
d1605 8
a1612 8
	next if $_ eq "." || $_ eq "..";
	if (-f $_) {
	    push @@entries, File::Spec->catfile($dir,$_);
	} elsif (-d _) {
	    push @@entries, File::Spec->catdir($dir,$_);
	} else {
	    $CPAN::Frontend->mywarn("Warning: weird direntry in $dir: $_\n");
	}
d1615 1
a1615 1
    sort { -M $b <=> -M $a} @@entries;
d1620 1
a1620 1
    my($self,$dir) = @@_;
d1624 49
a1672 14
    find(
	 sub {
	   $File::Find::prune++ if $CPAN::Signal;
	   return if -l $_;
	   if ($^O eq 'MacOS') {
	     require Mac::Files;
	     my $cat  = Mac::Files::FSpGetCatInfo($_);
	     $Du += $cat->ioFlLgLen() + $cat->ioFlRLgLen() if $cat;
	   } else {
	     $Du += (-s _);
	   }
	 },
	 $dir
	);
d1675 1
a1675 1
    push @@{$self->{FIFO}}, $dir;
d1681 2
a1682 2
#-> sub CPAN::CacheMgr::force_clean_cache ;
sub force_clean_cache {
d1685 7
d1693 1
a1693 1
	if $CPAN::DEBUG;
d1695 25
d1731 5
a1735 5
		ID => $CPAN::Config->{'build_dir'},
		MAX => $CPAN::Config->{'build_cache'},
		SCAN => $CPAN::Config->{'scan_cache'} || 'atstart',
		DU => 0
	       };
d1752 2
a1753 1
	unless $self->{SCAN} eq 'atstart';
d1755 2
a1756 2
			     sprintf("Scanning cache %s for sizes\n",
				     $self->{ID}));
d1758 17
a1774 4
    for $e ($self->entries($self->{ID})) {
	next if $e eq ".." || $e eq ".";
	$self->disk_usage($e);
	return if $CPAN::Signal;
d1776 1
a1779 336
package CPAN::Debug;

#-> sub CPAN::Debug::debug ;
sub debug {
    my($self,$arg) = @@_;
    my($caller,$func,$line,@@rest) = caller(1); # caller(0) eg
                                               # Complete, caller(1)
                                               # eg readline
    ($caller) = caller(0);
    $caller =~ s/.*:://;
    $arg = "" unless defined $arg;
    my $rest = join "|", map { defined $_ ? $_ : "UNDEF" } @@rest;
    if ($CPAN::DEBUG{$caller} & $CPAN::DEBUG){
	if ($arg and ref $arg) {
	    eval { require Data::Dumper };
	    if ($@@) {
		$CPAN::Frontend->myprint($arg->as_string);
	    } else {
		$CPAN::Frontend->myprint(Data::Dumper::Dumper($arg));
	    }
	} else {
	    $CPAN::Frontend->myprint("Debug($caller:$func,$line,[$rest]): $arg\n");
	}
    }
}

package CPAN::Config;

#-> sub CPAN::Config::edit ;
# returns true on successful action
sub edit {
    my($self,@@args) = @@_;
    return unless @@args;
    CPAN->debug("self[$self]args[".join(" | ",@@args)."]");
    my($o,$str,$func,$args,$key_exists);
    $o = shift @@args;
    if($can{$o}) {
	$self->$o(@@args);
	return 1;
    } else {
        CPAN->debug("o[$o]") if $CPAN::DEBUG;
	if ($o =~ /list$/) {
	    $func = shift @@args;
	    $func ||= "";
            CPAN->debug("func[$func]") if $CPAN::DEBUG;
            my $changed;
	    # Let's avoid eval, it's easier to comprehend without.
	    if ($func eq "push") {
		push @@{$CPAN::Config->{$o}}, @@args;
                $changed = 1;
	    } elsif ($func eq "pop") {
		pop @@{$CPAN::Config->{$o}};
                $changed = 1;
	    } elsif ($func eq "shift") {
		shift @@{$CPAN::Config->{$o}};
                $changed = 1;
	    } elsif ($func eq "unshift") {
		unshift @@{$CPAN::Config->{$o}}, @@args;
                $changed = 1;
	    } elsif ($func eq "splice") {
		splice @@{$CPAN::Config->{$o}}, @@args;
                $changed = 1;
	    } elsif (@@args) {
		$CPAN::Config->{$o} = [@@args];
                $changed = 1;
	    } else {
                $self->prettyprint($o);
	    }
            if ($o eq "urllist" && $changed) {
                # reset the cached values
                undef $CPAN::FTP::Thesite;
                undef $CPAN::FTP::Themethod;
            }
            return $changed;
	} else {
	    $CPAN::Config->{$o} = $args[0] if defined $args[0];
	    $self->prettyprint($o);
	}
    }
}

sub prettyprint {
  my($self,$k) = @@_;
  my $v = $CPAN::Config->{$k};
  if (ref $v) {
    my(@@report) = ref $v eq "ARRAY" ?
        @@$v :
            map { sprintf("   %-18s => %s\n",
                          $_,
                          defined $v->{$_} ? $v->{$_} : "UNDEFINED"
                         )} keys %$v;
    $CPAN::Frontend->myprint(
                             join(
                                  "",
                                  sprintf(
                                          "    %-18s\n",
                                          $k
                                         ),
                                  map {"\t$_\n"} @@report
                                 )
                            );
  } elsif (defined $v) {
    $CPAN::Frontend->myprint(sprintf "    %-18s %s\n", $k, $v);
  } else {
    $CPAN::Frontend->myprint(sprintf "    %-18s %s\n", $k, "UNDEFINED");
  }
}

#-> sub CPAN::Config::commit ;
sub commit {
    my($self,$configpm) = @@_;
    unless (defined $configpm){
	$configpm ||= $INC{"CPAN/MyConfig.pm"};
	$configpm ||= $INC{"CPAN/Config.pm"};
	$configpm || Carp::confess(q{
CPAN::Config::commit called without an argument.
Please specify a filename where to save the configuration or try
"o conf init" to have an interactive course through configing.
});
    }
    my($mode);
    if (-f $configpm) {
	$mode = (stat $configpm)[2];
	if ($mode && ! -w _) {
	    Carp::confess("$configpm is not writable");
	}
    }

    my $msg;
    $msg = <<EOF unless $configpm =~ /MyConfig/;

# This is CPAN.pm's systemwide configuration file. This file provides
# defaults for users, and the values can be changed in a per-user
# configuration file. The user-config file is being looked for as
# ~/.cpan/CPAN/MyConfig.pm.

EOF
    $msg ||= "\n";
    my($fh) = FileHandle->new;
    rename $configpm, "$configpm~" if -f $configpm;
    open $fh, ">$configpm" or
        $CPAN::Frontend->mydie("Couldn't open >$configpm: $!");
    $fh->print(qq[$msg\$CPAN::Config = \{\n]);
    foreach (sort keys %$CPAN::Config) {
	$fh->print(
		   "  '$_' => ",
		   ExtUtils::MakeMaker::neatvalue($CPAN::Config->{$_}),
		   ",\n"
		  );
    }

    $fh->print("};\n1;\n__END__\n");
    close $fh;

    #$mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
    #chmod $mode, $configpm;
###why was that so?    $self->defaults;
    $CPAN::Frontend->myprint("commit: wrote $configpm\n");
    1;
}

*default = \&defaults;
#-> sub CPAN::Config::defaults ;
sub defaults {
    my($self) = @@_;
    $self->unload;
    $self->load;
    1;
}

sub init {
    my($self) = @@_;
    undef $CPAN::Config->{'inhibit_startup_message'}; # lazy trick to
                                                      # have the least
                                                      # important
                                                      # variable
                                                      # undefined
    $self->load;
    1;
}

# This is a piece of repeated code that is abstracted here for
# maintainability.  RMB
#
sub _configpmtest {
    my($configpmdir, $configpmtest) = @@_; 
    if (-w $configpmtest) {
        return $configpmtest;
    } elsif (-w $configpmdir) {
        #_#_# following code dumped core on me with 5.003_11, a.k.
        my $configpm_bak = "$configpmtest.bak";
        unlink $configpm_bak if -f $configpm_bak;
        if( -f $configpmtest ) {	
            if( rename $configpmtest, $configpm_bak ) {  
                $CPAN::Frontend->mywarn(<<END)
Old configuration file $configpmtest
    moved to $configpm_bak
END
	    }
	}	
	my $fh = FileHandle->new;
	if ($fh->open(">$configpmtest")) {
	    $fh->print("1;\n");
	    return $configpmtest;
	} else {
	    # Should never happen
	    Carp::confess("Cannot open >$configpmtest");
	}
    } else { return } 
}

#-> sub CPAN::Config::load ;
sub load {
    my($self) = shift;
    my(@@miss);
    use Carp;
    eval {require CPAN::Config;};       # We eval because of some
                                        # MakeMaker problems
    unless ($dot_cpan++){
      unshift @@INC, File::Spec->catdir($ENV{HOME},".cpan");
      eval {require CPAN::MyConfig;};   # where you can override
                                        # system wide settings
      shift @@INC;
    }
    return unless @@miss = $self->missing_config_data;

    require CPAN::FirstTime;
    my($configpm,$fh,$redo,$theycalled);
    $redo ||= "";
    $theycalled++ if @@miss==1 && $miss[0] eq 'inhibit_startup_message';
    if (defined $INC{"CPAN/Config.pm"} && -w $INC{"CPAN/Config.pm"}) {
	$configpm = $INC{"CPAN/Config.pm"};
	$redo++;
    } elsif (defined $INC{"CPAN/MyConfig.pm"} && -w $INC{"CPAN/MyConfig.pm"}) {
	$configpm = $INC{"CPAN/MyConfig.pm"};
	$redo++;
    } else {
	my($path_to_cpan) = File::Basename::dirname($INC{"CPAN.pm"});
	my($configpmdir) = File::Spec->catdir($path_to_cpan,"CPAN");
	my($configpmtest) = File::Spec->catfile($configpmdir,"Config.pm");
	if (-d $configpmdir or File::Path::mkpath($configpmdir)) {
	    $configpm = _configpmtest($configpmdir,$configpmtest); 
	}
	unless ($configpm) {
	    $configpmdir = File::Spec->catdir($ENV{HOME},".cpan","CPAN");
	    File::Path::mkpath($configpmdir);
	    $configpmtest = File::Spec->catfile($configpmdir,"MyConfig.pm");
	    $configpm = _configpmtest($configpmdir,$configpmtest); 
	    unless ($configpm) {
		Carp::confess(qq{WARNING: CPAN.pm is unable to }.
			      qq{create a configuration file.});
	    }
	}
    }
    local($") = ", ";
    $CPAN::Frontend->myprint(<<END) if $redo && ! $theycalled;
We have to reconfigure CPAN.pm due to following uninitialized parameters:

@@miss
END
    $CPAN::Frontend->myprint(qq{
$configpm initialized.
});
    sleep 2;
    CPAN::FirstTime::init($configpm);
}

#-> sub CPAN::Config::missing_config_data ;
sub missing_config_data {
    my(@@miss);
    for (
         "cpan_home", "keep_source_where", "build_dir", "build_cache",
         "scan_cache", "index_expire", "gzip", "tar", "unzip", "make",
         "pager",
         "makepl_arg", "make_arg", "make_install_arg", "urllist",
         "inhibit_startup_message", "ftp_proxy", "http_proxy", "no_proxy",
         "prerequisites_policy",
         "cache_metadata",
        ) {
	push @@miss, $_ unless defined $CPAN::Config->{$_};
    }
    return @@miss;
}

#-> sub CPAN::Config::unload ;
sub unload {
    delete $INC{'CPAN/MyConfig.pm'};
    delete $INC{'CPAN/Config.pm'};
}

#-> sub CPAN::Config::help ;
sub help {
    $CPAN::Frontend->myprint(q[
Known options:
  defaults  reload default config values from disk
  commit    commit session changes to disk
  init      go through a dialog to set all parameters

You may edit key values in the follow fashion (the "o" is a literal
letter o):

  o conf build_cache 15

  o conf build_dir "/foo/bar"

  o conf urllist shift

  o conf urllist unshift ftp://ftp.foo.bar/

]);
    undef; #don't reprint CPAN::Config
}

#-> sub CPAN::Config::cpl ;
sub cpl {
    my($word,$line,$pos) = @@_;
    $word ||= "";
    CPAN->debug("word[$word] line[$line] pos[$pos]") if $CPAN::DEBUG;
    my(@@words) = split " ", substr($line,0,$pos+1);
    if (
	defined($words[2])
	and
	(
	 $words[2] =~ /list$/ && @@words == 3
	 ||
	 $words[2] =~ /list$/ && @@words == 4 && length($word)
	)
       ) {
	return grep /^\Q$word\E/, qw(splice shift unshift pop push);
    } elsif (@@words >= 4) {
	return ();
    }
    my(@@o_conf) = (keys %CPAN::Config::can, keys %$CPAN::Config);
    return grep /^\Q$word\E/, @@o_conf;
}

d1781 1
d1787 10
a1796 1
	$CPAN::Frontend->myprint("Detailed help not yet implemented\n");
d1798 3
a1800 2
	$CPAN::Frontend->myprint(q{
Display Information
d1803 4
a1806 3
 i        WORD or /REGEXP/  about anything of above
 r        NONE              reinstall recommendations
 ls       AUTHOR            about files in the author's directory
d1809 12
a1820 7
 get                        download
 make                       make (implies get)
 test      MODULES,         make test (implies make)
 install   DISTS, BUNDLES   make install (implies test)
 clean                      make clean
 look                       open subshell in these dists' directories
 readme                     display these dists' README files
d1826 2
a1827 2
 autobundle    Snapshot                force cmd     unconditionally do cmd});
    }
d1842 30
a1871 6
#-> sub CPAN::Shell::ls ;
sub ls      {
    my($self,@@arg) = @@_;
    my @@accept;
    for (@@arg) {
        unless (/^[A-Z\-]+$/i) {
d1875 1
a1875 1
        push @@accept, uc $_;
d1877 43
a1919 3
    for my $a (@@accept){
        my $author = $self->expand('Author',$a) or die "No author found for $a";
        $author->ls;
d1921 1
d1937 2
a1938 1
                    if (-d File::Spec->catdir($bdir,$entry)){
a1970 2
    my(@@type,$type,@@m);
    @@type = qw/Author Bundle Distribution Module/;
d1973 2
a1974 2
    for $type (@@type) {
	push @@result, $self->expand($type,@@args);
d1976 3
d1980 1
a1980 1
	$result[0]->as_string :
d1992 4
a1995 2
# CPAN::Shell::o and CPAN::Config::edit are closely related. 'o conf'
# should have been called set and 'o debug' maybe 'set debug'
d2001 34
a2034 24
	shift @@o_what if @@o_what && $o_what[0] eq 'help';
	if (!@@o_what) { # print all things, "o conf"
	    my($k,$v);
	    $CPAN::Frontend->myprint("CPAN::Config options");
	    if (exists $INC{'CPAN/Config.pm'}) {
	      $CPAN::Frontend->myprint(" from $INC{'CPAN/Config.pm'}");
	    }
	    if (exists $INC{'CPAN/MyConfig.pm'}) {
	      $CPAN::Frontend->myprint(" and $INC{'CPAN/MyConfig.pm'}");
	    }
	    $CPAN::Frontend->myprint(":\n");
	    for $k (sort keys %CPAN::Config::can) {
		$v = $CPAN::Config::can{$k};
		$CPAN::Frontend->myprint(sprintf "    %-18s %s\n", $k, $v);
	    }
	    $CPAN::Frontend->myprint("\n");
	    for $k (sort keys %$CPAN::Config) {
                CPAN::Config->prettyprint($k);
	    }
	    $CPAN::Frontend->myprint("\n");
	} elsif (!CPAN::Config->edit(@@o_what)) {
	    $CPAN::Frontend->myprint(qq{Type 'o conf' to view configuration }.
                                     qq{edit options\n\n});
	}
d2036 5
a2040 5
	my(%valid);
	@@o_what = () if defined $o_what[0] && $o_what[0] =~ /help/i;
	if (@@o_what) {
	    while (@@o_what) {
		my($what) = shift @@o_what;
d2045 36
a2080 36
		if ( exists $CPAN::DEBUG{$what} ) {
		    $CPAN::DEBUG |= $CPAN::DEBUG{$what};
		} elsif ($what =~ /^\d/) {
		    $CPAN::DEBUG = $what;
		} elsif (lc $what eq 'all') {
		    my($max) = 0;
		    for (values %CPAN::DEBUG) {
			$max += $_;
		    }
		    $CPAN::DEBUG = $max;
		} else {
		    my($known) = 0;
		    for (keys %CPAN::DEBUG) {
			next unless lc($_) eq lc($what);
			$CPAN::DEBUG |= $CPAN::DEBUG{$_};
			$known = 1;
		    }
		    $CPAN::Frontend->myprint("unknown argument [$what]\n")
			unless $known;
		}
	    }
	} else {
	  my $raw = "Valid options for debug are ".
	      join(", ",sort(keys %CPAN::DEBUG), 'all').
		  qq{ or a number. Completion works on the options. }.
		      qq{Case is ignored.};
	  require Text::Wrap;
	  $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
	  $CPAN::Frontend->myprint("\n\n");
	}
	if ($CPAN::DEBUG) {
	    $CPAN::Frontend->myprint("Options set for debugging:\n");
	    my($k,$v);
	    for $k (sort {$CPAN::DEBUG{$a} <=> $CPAN::DEBUG{$b}} keys %CPAN::DEBUG) {
		$v = $CPAN::DEBUG{$k};
		$CPAN::Frontend->myprint(sprintf "    %-14s(%s)\n", $k, $v)
d2082 4
a2085 4
	    }
	} else {
	    $CPAN::Frontend->myprint("Debugging turned off completely.\n");
	}
d2087 1
a2087 1
	$CPAN::Frontend->myprint(qq{
d2095 1
d2099 18
a2116 9
	if ( $_[0] =~ /[Ss]ubroutine ([\w:]+) redefined/ ) {
	    my($subr) = $1;
	    ++$$ref;
	    local($|) = 1;
	    # $CPAN::Frontend->myprint(".($subr)");
	    $CPAN::Frontend->myprint(".");
	    return;
	}
	warn @@_;
d2120 71
d2196 24
a2219 7
    if ($command =~ /cpan/i) {
        for my $f (qw(CPAN.pm CPAN/FirstTime.pm)) {
            next unless $INC{$f};
            CPAN->debug("reloading the whole $f") if $CPAN::DEBUG;
            my $fh = FileHandle->new($INC{$f});
            local($/);
            my $redef = 0;
d2221 9
a2229 3
            eval <$fh>;
            warn $@@ if $@@;
            $CPAN::Frontend->myprint("\n$redef subroutines redefined\n");
d2231 1
a2231 1
    } elsif ($command =~ /index/) {
d2234 1
a2234 1
      $CPAN::Frontend->myprint(qq{cpan     re-evals the CPAN.pm file
d2239 85
d2329 3
a2331 3
	my $file  = $module->cpan_file;
	next if $file eq "N/A";
	next if $file =~ /^Contact Author/;
d2333 5
a2337 5
	next if $dist->isa_perl;
	next unless $module->xs_file;
	local($|) = 1;
	$CPAN::Frontend->myprint(".");
	push @@result, $module;
d2349 1
a2349 1
    for $module (@@module){  # we force now and compile later, so we
d2351 4
a2354 4
	$cpan_file = $module->cpan_file;
	my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
	$pack->force;
	$dist{$cpan_file}++;
d2357 4
a2360 4
	$CPAN::Frontend->myprint("  CPAN: Recompiling $cpan_file\n\n");
	my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
	$pack->install;
	$CPAN::Signal = 0; # it's tempting to reset Signal, so we can
d2366 136
d2512 2
a2513 1
       $version_undefs,$version_zeroes);
d2522 22
a2543 19
    for $module (@@expand) {
	my $file  = $module->cpan_file;
	next unless defined $file; # ??
	my($latest) = $module->cpan_version;
	my($inst_file) = $module->inst_file;
	my($have);
	return if $CPAN::Signal;
	if ($inst_file){
	    if ($what eq "a") {
		$have = $module->inst_version;
	    } elsif ($what eq "r") {
		$have = $module->inst_version;
		local($^W) = 0;
		if ($have eq "undef"){
		    $version_undefs++;
		} elsif ($have == 0){
		    $version_zeroes++;
		}
		next unless CPAN::Version->vgt($latest, $have);
d2547 27
a2573 27
	    } elsif ($what eq "u") {
		next;
	    }
	} else {
	    if ($what eq "a") {
		next;
	    } elsif ($what eq "r") {
		next;
	    } elsif ($what eq "u") {
		$have = "-";
	    }
	}
	return if $CPAN::Signal; # this is sometimes lengthy
	$seen{$file} ||= 0;
	if ($what eq "a") {
	    push @@result, sprintf "%s %s\n", $module->id, $have;
	} elsif ($what eq "r") {
	    push @@result, $module->id;
	    next if $seen{$file}++;
	} elsif ($what eq "u") {
	    push @@result, $module->id;
	    next if $seen{$file}++;
	    next if $file =~ /^Contact/;
	}
	unless ($headerdone++){
	    $CPAN::Frontend->myprint("\n");
	    $CPAN::Frontend->myprint(sprintf(
d2582 1
a2582 1
	}
d2590 1
a2590 1
            $module->{RO}{description}
d2595 1
a2595 1
	$CPAN::Frontend->myprint(sprintf $sprintf,
d2602 1
a2602 1
	$need{$module->id}++;
d2605 5
a2609 5
	if ($what eq "u") {
	    $CPAN::Frontend->myprint("No modules found for @@args\n");
	} elsif ($what eq "r") {
	    $CPAN::Frontend->myprint("All modules are up to date for @@args\n");
	}
d2612 28
a2639 10
	if ($version_zeroes) {
	    my $s_has = $version_zeroes > 1 ? "s have" : " has";
	    $CPAN::Frontend->myprint(qq{$version_zeroes installed module$s_has }.
		qq{a version number of 0\n});
	}
	if ($version_undefs) {
	    my $s_has = $version_undefs > 1 ? "s have" : " has";
	    $CPAN::Frontend->myprint(qq{$version_undefs installed module$s_has no }.
		qq{parseable version number\n});
	}
d2654 139
d2796 1
a2796 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
d2801 2
a2802 2
	$CPAN::Frontend->myprint("Couldn't mkdir $todir for some reason\n");
	return;
d2811 2
a2812 2
	$me = sprintf "Snapshot_%04d_%02d_%02d_%02d", $y, $m, $d, ++$c;
	$to = File::Spec->catfile($todir,"$me.pm");
d2816 19
a2834 19
	       "package Bundle::$me;\n\n",
	       "\$VERSION = '0.01';\n\n",
	       "1;\n\n",
	       "__END__\n\n",
	       "=head1 NAME\n\n",
	       "Bundle::$me - Snapshot of installation on ",
	       $Config::Config{'myhostname'},
	       " on ",
	       scalar(localtime),
	       "\n\n=head1 SYNOPSIS\n\n",
	       "perl -MCPAN -e 'install Bundle::$me'\n\n",
	       "=head1 CONTENTS\n\n",
	       join("\n", @@bundle),
	       "\n\n=head1 CONFIGURATION\n\n",
	       Config->myconfig,
	       "\n\n=head1 AUTHOR\n\n",
	       "This Bundle has been generated automatically ",
	       "by the autobundle routine in CPAN.pm.\n",
	      );
d2844 1
a2844 1
    if ($s =~ m|/|) { # looks like a file
d2863 1
a2863 1
    shift;
d2865 14
a2879 1
    CPAN->debug("type[$type]args[@@args]") if $CPAN::DEBUG;
d2881 7
a2887 5
	my($regex,$command);
	if ($arg =~ m|^/(.*)/$|) {
	    $regex = $1;
	} elsif ($arg =~ m/=/) {
            $command = 1;
d2889 1
a2889 2
	my $class = "CPAN::$type";
	my $obj;
d2893 1
a2893 1
                    $command || "UNDEFINED",
d2895 4
a2898 1
	if (defined $regex) {
a2899 2
                      sort
                      {$a->id cmp $b->id}
d2902 1
a2902 1
                unless ($obj->id){
d2912 11
a2922 13
                push @@m, $obj
                    if $obj->id =~ /$regex/i
                        or
                            (
                             (
                              $] < 5.00303 ### provide sort of
                              ### compatibility with 5.003
                              ||
                              $obj->can('name')
                             )
                             &&
                             $obj->name  =~ /$regex/i
                            );
d2945 5
a2949 5
	} else {
	    my($xarg) = $arg;
	    if ( $type eq 'Bundle' ) {
		$xarg =~ s/^(Bundle::)?(.*)/Bundle::$2/;
	    } elsif ($type eq "Distribution") {
d2951 9
d2961 8
a2968 9
	    if ($CPAN::META->exists($class,$xarg)) {
		$obj = $CPAN::META->instance($class,$xarg);
	    } elsif ($CPAN::META->exists($class,$arg)) {
		$obj = $CPAN::META->instance($class,$arg);
	    } else {
		next;
	    }
	    push @@m, $obj;
	}
d2980 1
a2980 1
	$result[0]->as_string :
d2990 25
d3019 22
a3040 1
#-> sub CPAN::Shell::print_ornameted ;
a3042 1
    my $longest = 0;
d3045 8
a3052 1
    if ($CPAN::Config->{term_is_latin}){
d3054 1
a3054 1
        $what
d3057 22
a3078 25
    if ($PRINT_ORNAMENTING) {
	unless (defined &color) {
	    if ($CPAN::META->has_inst("Term::ANSIColor")) {
		import Term::ANSIColor "color";
	    } else {
		*color = sub { return "" };
	    }
	}
	my $line;
	for $line (split /\n/, $what) {
	    $longest = length($line) if length($line) > $longest;
	}
	my $sprintf = "%-" . $longest . "s";
	while ($what){
	    $what =~ s/(.*\n?)//m;
	    my $line = $1;
	    last unless $line;
	    my($nl) = chomp $line ? "\n" : "";
	    #	print "line[$line]ornament[$ornament]sprintf[$sprintf]\n";
	    print color($ornament), sprintf($sprintf,$line), color("reset"), $nl;
	}
    } else {
        # chomp $what;
        # $what .= "\n"; # newlines unless $PRINT_ORNAMENTING
	print $what;
d3082 6
d3090 4
d3095 9
a3103 1
    $self->print_ornamented($what, 'bold blue on_yellow');
d3106 1
d3113 1
d3116 1
a3116 1
    $self->print_ornamented($what, 'bold red on_yellow');
d3119 3
a3121 1
sub myconfess {
d3123 8
a3130 2
    $self->print_ornamented($what, 'bold red on_white');
    Carp::confess "died";
d3133 18
a3150 1
sub mydie {
d3152 29
a3180 2
    $self->print_ornamented($what, 'bold red on_white');
    die "\n";
d3183 1
d3194 1
a3194 1
# RE-adme||MA-ke||TE-st||IN-stall
d3196 1
a3196 1
    shift;
d3198 6
a3203 4
    my $pragma = "";
    if ($meth eq 'force') {
	$pragma = $meth;
	$meth = shift @@some;
d3206 1
a3206 1
    CPAN->debug("pragma[$pragma]meth[$meth] some[@@some]") if $CPAN::DEBUG;
d3222 4
d3228 3
a3230 3
    foreach $s (@@some) {
	my $obj;
	if (ref $s) {
d3232 15
a3246 7
	    $obj = $s;
	} elsif ($s =~ m|^/|) { # looks like a regexp
            $CPAN::Frontend->mywarn("Sorry, $meth with a regular expression is ".
                                    "not supported\n");
            sleep 2;
            next;
	} else {
d3248 23
a3270 5
	    $obj = CPAN::Shell->expandany($s);
	}
	if (ref $obj) {
            $obj->color_cmd_tmps(0,1);
            CPAN::Queue->new($obj->id);
d3272 3
a3274 3
	} elsif ($CPAN::META->exists('CPAN::Author',$s)) {
	    $obj = $CPAN::META->instance('CPAN::Author',$s);
            if ($meth =~ /^(dump|ls)$/) {
d3277 7
a3283 7
                $CPAN::Frontend->myprint(
                                         join "",
                                         "Don't be silly, you can't $meth ",
                                         $obj->fullname,
                                         " ;-)\n"
                                        );
                sleep 2;
d3285 6
a3290 4
	} else {
	    $CPAN::Frontend
		->myprint(qq{Warning: Cannot $meth $s, }.
			  qq{don\'t know what it is.
d3297 2
a3298 2
            sleep 2;
	}
d3304 1
a3304 1
    while ($s = CPAN::Queue->first) {
d3306 50
a3355 12
	if (ref $s) {
	    $obj = $s; # I do not believe, we would survive if this happened
	} else {
	    $obj = CPAN::Shell->expandany($s);
	}
        if ($pragma
            &&
            ($] < 5.00303 || $obj->can($pragma))){
            ### compatibility with 5.003
            $obj->$pragma($meth); # the pragma "force" in
                                  # "CPAN::Distribution" must know
                                  # what we are intending
d3357 1
a3357 1
        if ($]>=5.00303 && $obj->can('called_for')) {
d3360 2
a3361 5
        CPAN->debug(
                    qq{pragma[$pragma]meth[$meth]obj[$obj]as_string\[}.
                    $obj->as_string.
                    qq{\]}
                   ) if $CPAN::DEBUG;
d3363 20
a3382 1
        if ($obj->$meth()){
d3384 1
d3386 1
a3386 1
            CPAN->debug("failed");
d3390 12
a3401 1
	CPAN::Queue->delete_first($s);
d3403 109
a3511 2
    for my $obj (@@qcopy) {
        $obj->color_cmd_tmps(0,0);
d3515 23
a3537 20
#-> sub CPAN::Shell::dump ;
sub dump    { shift->rematein('dump',@@_); }
#-> sub CPAN::Shell::force ;
sub force   { shift->rematein('force',@@_); }
#-> sub CPAN::Shell::get ;
sub get     { shift->rematein('get',@@_); }
#-> sub CPAN::Shell::readme ;
sub readme  { shift->rematein('readme',@@_); }
#-> sub CPAN::Shell::make ;
sub make    { shift->rematein('make',@@_); }
#-> sub CPAN::Shell::test ;
sub test    { shift->rematein('test',@@_); }
#-> sub CPAN::Shell::install ;
sub install { shift->rematein('install',@@_); }
#-> sub CPAN::Shell::clean ;
sub clean   { shift->rematein('clean',@@_); }
#-> sub CPAN::Shell::look ;
sub look   { shift->rematein('look',@@_); }
#-> sub CPAN::Shell::cvs_import ;
sub cvs_import   { shift->rematein('cvs_import',@@_); }
d3540 1
d3549 1
a3549 1
        $CPAN::Frontend->mywarn("LWP::UserAgent not available\n");
a3554 1
    return unless $proxy;
d3556 20
a3575 8
    } elsif (defined $CPAN::Config->{proxy_user} &&
             defined $CPAN::Config->{proxy_pass}) {
        $USER = $CPAN::Config->{proxy_user};
        $PASSWD = $CPAN::Config->{proxy_pass};
    } else {
        require ExtUtils::MakeMaker;
        ExtUtils::MakeMaker->import(qw(prompt));
        $USER = prompt("Proxy authentication needed!
d3579 32
a3610 1
 )\nUsername:");
a3612 2
        } else {
            $CPAN::Frontend->mywarn("Warning: Term::ReadKey seems not to be available, your password will be echoed to the terminal!\n");
d3614 7
a3620 1
        $PASSWD = prompt("Password:");
d3625 1
a3625 2
    }
    return($USER,$PASSWD);
d3643 15
d3670 159
d3832 3
a3834 3
  my($class,$host,$dir,$file,$target) = @@_;
  $class->debug(
		qq[Going to fetch file [$file] from dir [$dir]
d3836 28
a3863 21
		      ) if $CPAN::DEBUG;
  my $ftp = Net::FTP->new($host);
  return 0 unless defined $ftp;
  $ftp->debug(1) if $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG;
  $class->debug(qq[Going to login("anonymous","$Config::Config{cf_email}")]);
  unless ( $ftp->login("anonymous",$Config::Config{'cf_email'}) ){
    warn "Couldn't login on $host";
    return;
  }
  unless ( $ftp->cwd($dir) ){
    warn "Couldn't cwd $dir";
    return;
  }
  $ftp->binary;
  $class->debug(qq[Going to ->get("$file","$target")\n]) if $CPAN::DEBUG;
  unless ( $ftp->get($file,$target) ){
    warn "Couldn't fetch $file from $host\n";
    return;
  }
  $ftp->quit; # it's ok if this fails
  return 1;
d3899 1
a3899 1
	unless defined $aslocal;
d3901 1
a3901 1
	if $CPAN::DEBUG;
d3927 16
a3942 5
    return $aslocal if -f $aslocal && -r _ && !($force & 1);
    my($restore) = 0;
    if (-f $aslocal){
	rename $aslocal, "$aslocal.bak";
	$restore++;
d3946 1
a3946 6
    File::Path::mkpath($aslocal_dir);
    $CPAN::Frontend->mywarn(qq{Warning: You are not allowed to write into }.
	qq{directory "$aslocal_dir".
    I\'ll continue, but if you encounter problems, they may be due
    to insufficient permissions.\n}) unless -w $aslocal_dir;

d3949 1
a3949 1
 	unless ($Ua) {
d3951 1
a3951 1
	    eval {$Ua = CPAN::LWP::UserAgent->new;}; # Why is has_usable still not fit enough?
a3960 14


# >>>>> On Wed, 13 Dec 2000 09:21:34 -0500, "Robison, Jonathon (J.M.)" <jrobiso2@@visteon.com> said:
# 
#  > I note that although CPAN.pm can use proxies, it doesn't seem equipped to
#  > use ones that require basic autorization.
#  
#  > Example of when I use it manually in my own stuff:
#  
#  > $ua->proxy(['http','ftp'], http://my.proxy.server:83');
#  > $req->proxy_authorization_basic("username","password");
#  > $res = $ua->request($req);
# 

d3964 1
a3964 1
	}
d3973 2
a3974 5
    $CPAN::Config->{urllist} ||= [];
    unless (ref $CPAN::Config->{urllist} eq 'ARRAY') {
        warn "Malformed urllist; ignoring.  Configuration file corrupt?\n";
    }
    $last = $#{$CPAN::Config->{urllist}};
d3976 1
a3976 1
	@@reordered = (0..$last);
d3978 12
a3989 12
	@@reordered =
	    sort {
		(substr($CPAN::Config->{urllist}[$b],0,4) eq "file")
		    <=>
		(substr($CPAN::Config->{urllist}[$a],0,4) eq "file")
		    or
		defined($Thesite)
		    and
		($b == $Thesite)
		    <=>
		($a == $Thesite)
	    } 0..$last;
d3992 13
d4006 2
a4007 1
	@@levels = ($Themethod, grep {$_ ne $Themethod} qw/easy hard hardest/);
d4009 1
a4009 1
	@@levels = qw/easy hard hardest/;
d4011 1
a4011 1
    @@levels = qw/easy/ if $^O eq 'MacOS';
d4013 75
a4087 18
    for $levelno (0..$#levels) {
        my $level = $levels[$levelno];
	my $method = "host$level";
	my @@host_seq = $level eq "easy" ?
	    @@reordered : 0..$last;  # reordered has CDROM up front
	@@host_seq = (0) unless @@host_seq;
	my $ret = $self->$method(\@@host_seq,$file,$aslocal);
	if ($ret) {
	  $Themethod = $level;
	  my $now = time;
	  # utime $now, $now, $aslocal; # too bad, if we do that, we
                                      # might alter a local mirror
	  $self->debug("level[$level]") if $CPAN::DEBUG;
	  return $ret;
	} else {
	  unlink $aslocal;
          last if $CPAN::Signal; # need to cleanup
	}
d4091 20
a4110 14
        push @@mess,
            qq{Please check, if the URLs I found in your configuration file \(}.
                join(", ", @@{$CPAN::Config->{urllist}}).
                    qq{\) are valid. The urllist can be edited.},
                        qq{E.g. with 'o conf urllist push ftp://myurl/'};
        $CPAN::Frontend->myprint(Text::Wrap::wrap("","",@@mess). "\n\n");
        sleep 2;
        $CPAN::Frontend->myprint("Could not fetch $file\n");
    }
    if ($restore) {
	rename "$aslocal.bak", $aslocal;
	$CPAN::Frontend->myprint("Trying to get away with old file:\n" .
				 $self->ls($aslocal));
	return $aslocal;
d4115 49
a4163 21
sub hosteasy {
    my($self,$host_seq,$file,$aslocal) = @@_;
    my($i);
  HOSTEASY: for $i (@@$host_seq) {
        my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
	$url .= "/" unless substr($url,-1) eq "/";
	$url .= $file;
	$self->debug("localizing perlish[$url]") if $CPAN::DEBUG;
	if ($url =~ /^file:/) {
	    my $l;
	    if ($CPAN::META->has_inst('URI::URL')) {
		my $u =  URI::URL->new($url);
		$l = $u->path;
	    } else { # works only on Unix, is poorly constructed, but
		# hopefully better than nothing.
		# RFC 1738 says fileurl BNF is
		# fileurl = "file://" [ host | "localhost" ] "/" fpath
		# Thanks to "Mark D. Baushke" <mdb@@cisco.com> for
		# the code
		($l = $url) =~ s|^file://[^/]*/|/|; # discard the host part
		$l =~ s|^file:||;                   # assume they
d4166 27
a4192 17
		$l =~ s|^/||s unless -f $l;         # e.g. /P:
		$self->debug("without URI::URL we try local file $l") if $CPAN::DEBUG;
	    }
	    if ( -f $l && -r _) {
		$Thesite = $i;
		return $l;
	    }
	    # Maybe mirror has compressed it?
	    if (-f "$l.gz") {
		$self->debug("found compressed $l.gz") if $CPAN::DEBUG;
		CPAN::Tarzip->gunzip("$l.gz", $aslocal);
		if ( -f $aslocal) {
		    $Thesite = $i;
		    return $aslocal;
		}
	    }
	}
d4194 1
a4194 1
	  $CPAN::Frontend->myprint("Fetching with LWP:
d4197 18
a4214 17
	  unless ($Ua) {
              CPAN::LWP::UserAgent->config;
              eval { $Ua = CPAN::LWP::UserAgent->new; };
              if ($@@) {
                  $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@\n");
              }
	  }
	  my $res = $Ua->mirror($url, $aslocal);
	  if ($res->is_success) {
	    $Thesite = $i;
	    my $now = time;
	    utime $now, $now, $aslocal; # download time is more
                                        # important than upload time
	    return $aslocal;
	  } elsif ($url !~ /\.gz(?!\n)\Z/) {
	    my $gzurl = "$url.gz";
	    $CPAN::Frontend->myprint("Fetching with LWP:
d4217 20
a4236 20
	    $res = $Ua->mirror($gzurl, "$aslocal.gz");
	    if ($res->is_success &&
		CPAN::Tarzip->gunzip("$aslocal.gz",$aslocal)
	       ) {
	      $Thesite = $i;
	      return $aslocal;
	    }
	  } else {
              $CPAN::Frontend->myprint(sprintf(
                                               "LWP failed with code[%s] message[%s]\n",
                                               $res->code,
                                               $res->message,
                                              ));
	    # Alan Burlison informed me that in firewall environments
	    # Net::FTP can still succeed where LWP fails. So we do not
	    # skip Net::FTP anymore when LWP is available.
	  }
	} else {
            $CPAN::Frontend->myprint("LWP not available\n");
	}
d4238 7
a4244 6
	if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
	    # that's the nice and easy way thanks to Graham
	    my($host,$dir,$getfile) = ($1,$2,$3);
	    if ($CPAN::META->has_usable('Net::FTP')) {
		$dir =~ s|/+|/|g;
		$CPAN::Frontend->myprint("Fetching with Net::FTP:
d4247 9
a4255 9
		$self->debug("getfile[$getfile]dir[$dir]host[$host]" .
			     "aslocal[$aslocal]") if $CPAN::DEBUG;
		if (CPAN::FTP->ftp_get($host,$dir,$getfile,$aslocal)) {
		    $Thesite = $i;
		    return $aslocal;
		}
		if ($aslocal !~ /\.gz(?!\n)\Z/) {
		    my $gz = "$aslocal.gz";
		    $CPAN::Frontend->myprint("Fetching with Net::FTP
d4258 25
a4282 13
		   if (CPAN::FTP->ftp_get($host,
					   $dir,
					   "$getfile.gz",
					   $gz) &&
			CPAN::Tarzip->gunzip($gz,$aslocal)
		       ){
			$Thesite = $i;
			return $aslocal;
		    }
		}
		# next HOSTEASY;
	    }
	}
d4287 27
a4313 27
sub hosthard {
  my($self,$host_seq,$file,$aslocal) = @@_;

  # Came back if Net::FTP couldn't establish connection (or
  # failed otherwise) Maybe they are behind a firewall, but they
  # gave us a socksified (or other) ftp program...

  my($i);
  my($devnull) = $CPAN::Config->{devnull} || "";
  # < /dev/null ";
  my($aslocal_dir) = File::Basename::dirname($aslocal);
  File::Path::mkpath($aslocal_dir);
  HOSTHARD: for $i (@@$host_seq) {
	my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
	$url .= "/" unless substr($url,-1) eq "/";
	$url .= $file;
	my($proto,$host,$dir,$getfile);

	# Courtesy Mark Conty mark_conty@@cargill.com change from
	# if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
	# to
	if ($url =~ m|^([^:]+)://(.*?)/(.*)/(.*)|) {
	  # proto not yet used
	  ($proto,$host,$dir,$getfile) = ($1,$2,$3,$4);
	} else {
	  next HOSTHARD; # who said, we could ftp anything except ftp?
	}
d4317 33
a4349 26
	$self->debug("localizing funkyftpwise[$url]") if $CPAN::DEBUG;
	my($f,$funkyftp);
	for $f ('lynx','ncftpget','ncftp','wget') {
	  next unless exists $CPAN::Config->{$f};
	  $funkyftp = $CPAN::Config->{$f};
	  next unless defined $funkyftp;
	  next if $funkyftp =~ /^\s*$/;
	  my($asl_ungz, $asl_gz);
	  ($asl_ungz = $aslocal) =~ s/\.gz//;
          $asl_gz = "$asl_ungz.gz";
	  my($src_switch) = "";
	  if ($f eq "lynx"){
	    $src_switch = " -source";
	  } elsif ($f eq "ncftp"){
	    $src_switch = " -c";
          } elsif ($f eq "wget"){
              $src_switch = " -O -";
	  }
	  my($chdir) = "";
	  my($stdout_redir) = " > $asl_ungz";
	  if ($f eq "ncftpget"){
	    $chdir = "cd $aslocal_dir && ";
	    $stdout_redir = "";
	  }
	  $CPAN::Frontend->myprint(
				   qq[
d4353 22
a4374 61
	  my($system) =
	      "$chdir$funkyftp$src_switch \"$url\" $devnull$stdout_redir";
	  $self->debug("system[$system]") if $CPAN::DEBUG;
	  my($wstatus);
	  if (($wstatus = system($system)) == 0
	      &&
	      ($f eq "lynx" ?
	       -s $asl_ungz # lynx returns 0 when it fails somewhere
	       : 1
	      )
	     ) {
	    if (-s $aslocal) {
	      # Looks good
	    } elsif ($asl_ungz ne $aslocal) {
	      # test gzip integrity
	      if (CPAN::Tarzip->gtest($asl_ungz)) {
                  # e.g. foo.tar is gzipped --> foo.tar.gz
                  rename $asl_ungz, $aslocal;
	      } else {
                  CPAN::Tarzip->gzip($asl_ungz,$asl_gz);
	      }
	    }
	    $Thesite = $i;
	    return $aslocal;
	  } elsif ($url !~ /\.gz(?!\n)\Z/) {
	    unlink $asl_ungz if
		-f $asl_ungz && -s _ == 0;
	    my $gz = "$aslocal.gz";
	    my $gzurl = "$url.gz";
	    $CPAN::Frontend->myprint(
				     qq[
Trying with "$funkyftp$src_switch" to get
  $url.gz
]);
	    my($system) = "$funkyftp$src_switch \"$url.gz\" $devnull > $asl_gz";
	    $self->debug("system[$system]") if $CPAN::DEBUG;
	    my($wstatus);
	    if (($wstatus = system($system)) == 0
		&&
		-s $asl_gz
	       ) {
	      # test gzip integrity
	      if (CPAN::Tarzip->gtest($asl_gz)) {
                  CPAN::Tarzip->gunzip($asl_gz,$aslocal);
	      } else {
                  # somebody uncompressed file for us?
                  rename $asl_ungz, $aslocal;
	      }
	      $Thesite = $i;
	      return $aslocal;
	    } else {
	      unlink $asl_gz if -f $asl_gz;
	    }
	  } else {
	    my $estatus = $wstatus >> 8;
	    my $size = -f $aslocal ?
		", left\n$aslocal with size ".-s _ :
		    "\nWarning: expected file [$aslocal] doesn't exist";
	    $CPAN::Frontend->myprint(qq{
System call "$system"
returned status $estatus (wstat $wstatus)$size
d4376 59
a4434 3
	  }
          return if $CPAN::Signal;
	} # lynx,ncftpget,ncftp
d4438 3
a4440 2
sub hosthardest {
    my($self,$host_seq,$file,$aslocal) = @@_;
d4442 2
a4443 1
    my($i);
d4447 61
a4507 39
  HOSTHARDEST: for $i (@@$host_seq) {
	unless (length $ftpbin && MM->maybe_command($ftpbin)) {
	    $CPAN::Frontend->myprint("No external ftp command available\n\n");
	    last HOSTHARDEST;
	}
	my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
	$url .= "/" unless substr($url,-1) eq "/";
	$url .= $file;
	$self->debug("localizing ftpwise[$url]") if $CPAN::DEBUG;
	unless ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
	    next;
	}
	my($host,$dir,$getfile) = ($1,$2,$3);
	my $timestamp = 0;
	my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,
	   $ctime,$blksize,$blocks) = stat($aslocal);
	$timestamp = $mtime ||= 0;
	my($netrc) = CPAN::FTP::netrc->new;
	my($netrcfile) = $netrc->netrc;
	my($verbose) = $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG ? " -v" : "";
	my $targetfile = File::Basename::basename($aslocal);
	my(@@dialog);
	push(
	     @@dialog,
	     "lcd $aslocal_dir",
	     "cd /",
	     map("cd $_", split /\//, $dir), # RFC 1738
	     "bin",
	     "get $getfile $targetfile",
	     "quit"
	    );
	if (! $netrcfile) {
	    CPAN->debug("No ~/.netrc file found") if $CPAN::DEBUG;
	} elsif ($netrc->hasdefault || $netrc->contains($host)) {
	    CPAN->debug(sprintf("hasdef[%d]cont($host)[%d]",
				$netrc->hasdefault,
				$netrc->contains($host))) if $CPAN::DEBUG;
	    if ($netrc->protected) {
		$CPAN::Frontend->myprint(qq{
d4510 26
a4535 2
  As this requires some features that are not thoroughly tested, we\'re
  not sure, that we get it right....
d4537 15
d4553 12
a4564 43
		     );
		$self->talk_ftp("$ftpbin$verbose $host",
				@@dialog);
		($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
		 $atime,$mtime,$ctime,$blksize,$blocks) = stat($aslocal);
		$mtime ||= 0;
		if ($mtime > $timestamp) {
		    $CPAN::Frontend->myprint("GOT $aslocal\n");
		    $Thesite = $i;
		    return $aslocal;
		} else {
		    $CPAN::Frontend->myprint("Hmm... Still failed!\n");
		}
                return if $CPAN::Signal;
	    } else {
		$CPAN::Frontend->mywarn(qq{Your $netrcfile is not }.
					qq{correctly protected.\n});
	    }
	} else {
	    $CPAN::Frontend->mywarn("Your ~/.netrc neither contains $host
  nor does it have a default entry\n");
	}

	# OK, they don't have a valid ~/.netrc. Use 'ftp -n'
	# then and login manually to host, using e-mail as
	# password.
	$CPAN::Frontend->myprint(qq{Issuing "$ftpbin$verbose -n"\n});
	unshift(
		@@dialog,
		"open $host",
		"user anonymous $Config::Config{'cf_email'}"
	       );
	$self->talk_ftp("$ftpbin$verbose -n", @@dialog);
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	 $atime,$mtime,$ctime,$blksize,$blocks) = stat($aslocal);
	$mtime ||= 0;
	if ($mtime > $timestamp) {
	    $CPAN::Frontend->myprint("GOT $aslocal\n");
	    $Thesite = $i;
	    return $aslocal;
	} else {
	    $CPAN::Frontend->myprint("Bad luck... Still failed!\n");
	}
d4566 2
a4567 2
	$CPAN::Frontend->myprint("Can't access URL $url.\n\n");
	sleep 2;
d4571 1
d4577 1
a4577 1
    $fh->close;		# Wait for process to complete
d4598 1
a4598 1
	$blocks = int(($blocks + 1) / 2);
d4601 1
a4601 1
	$blocks = int(($sizemm + 1023) / 1024);
d4632 1
a4632 1
	$timeyear = $year + 1900;
d4635 1
a4635 1
	$timeyear = sprintf("%02d:%02d", $hour, $min);
d4639 11
a4649 11
	    $ino,
		 $blocks,
		      $perms,
			    $nlink,
				$user,
				     $group,
					  $sizemm,
					      $moname,
						 $mday,
						     $timeyear,
							 $pname;
d4653 1
d4655 1
d4658 2
a4659 1
    my $file = File::Spec->catfile($ENV{HOME},".netrc");
d4663 1
a4663 1
	= stat($file);
d4671 3
a4673 3
    if($fh->open($file)){
	$protected = ($mode & 077) == 0;
	local($/) = "";
d4675 13
a4687 13
	    my(@@tokens) = split " ", $_;
	  TOKEN: while (@@tokens) {
		my($t) = shift @@tokens;
		if ($t eq "default"){
		    $hasdefault++;
		    last NETRC;
		}
		last TOKEN if $t eq "macdef";
		if ($t eq "machine") {
		    push @@machines, shift @@tokens;
		}
	    }
	}
d4689 1
a4689 1
	$file = $hasdefault = $protected = "";
d4693 5
a4697 5
	   'mach' => [@@machines],
	   'netrc' => $file,
	   'hasdefault' => $hasdefault,
	   'protected' => $protected,
	  }, $class;
d4700 1
a4700 1
# CPAN::FTP::hasdefault;
d4707 1
a4707 1
	return 1 if $_ eq $mach;
d4713 1
d4723 9
a4731 9
	last unless length($perlret[0]) && length($perlret[0]) >= $i;
	my $try = substr($perlret[0],0,$i);
	my @@tries = grep {substr($_,0,$i) eq $try} @@perlret;
	# warn "try[$try]tries[@@tries]";
	if (@@tries == @@perlret) {
	    $newtext = $try;
	} else {
	    last;
	}
d4744 2
a4745 2
    if ($line =~ s/^(force\s*)//) {
	$pos -= length($1);
d4748 2
a4749 2
    if ($pos == 0) {
	@@return = grep /^$word/, @@CPAN::Complete::COMMANDS;
d4751 1
a4751 1
	@@return = ();
d4753 1
a4753 1
	@@return = cplx('CPAN::Author',uc($word));
d4756 1
a4756 1
	@@return = cplx('CPAN::Bundle',$word);
d4758 1
a4758 1
	@@return = cplx('CPAN::Distribution',$word);
d4760 1
a4760 1
                          [mru]|make|clean|dump|get|test|install|readme|look|cvs_import
d4765 1
a4765 1
	@@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
d4767 1
a4767 1
	@@return = cpl_any($word);
d4769 1
a4769 1
	@@return = cpl_reload($word,$line,$pos);
d4771 1
a4771 1
	@@return = cpl_option($word,$line,$pos);
d4774 1
a4774 1
	@@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
d4776 1
a4776 1
	@@return = ();
d4784 3
a4786 4
    # I believed for many years that this was sorted, today I
    # realized, it wasn't sorted anymore. Now (rev 1.301 / v 1.55) I
    # make it sorted again. Maybe sort was dropped when GNU-readline
    # support came in? The RCS file is difficult to read on that:-(
d4794 5
a4798 5
	    cplx('CPAN::Author',$word),
	    cplx('CPAN::Bundle',$word),
	    cplx('CPAN::Distribution',$word),
	    cplx('CPAN::Module',$word),
	   );
d4823 1
a4823 1
	return ();
d4825 1
a4825 1
	return CPAN::Config::cpl(@@_);
d4827 2
a4828 1
	return sort grep /^\Q$word\E/, sort keys %CPAN::DEBUG, 'all';
d4833 1
d4844 1
a4844 1
    my($cl,$force) = @@_;
d4850 1
a4850 1
	$_ = 0.001 unless $_ && $_ > 0.001;
d4858 1
a4858 1
        $cl->read_metadata_cache;
d4865 5
a4869 3
    return if $LAST_TIME + $CPAN::Config->{index_expire}*86400 > $time
	and ! $force;
    if (0) {
d4874 1
a4874 2
    }
    {
d4881 1
a4881 1
        $cl->rd_authindex($cl
d4892 1
a4892 1
        $cl->rd_modpacks($cl
d4903 1
a4903 1
        $cl->rd_modlist($cl
d4910 1
a4910 1
        $cl->write_metadata_cache;
d4916 7
d4927 88
d5019 2
a5020 2
    CPAN::Config->load; # we should guarantee loading wherever we rely
                        # on Config XXX
d5023 1
a5023 1
					 $localname);
d5025 3
a5027 3
	-f $abs_wanted &&
	-M $abs_wanted < $CPAN::Config->{'index_expire'} &&
	!($force & 1)
d5029 4
a5032 4
	my $s = $CPAN::Config->{'index_expire'} == 1 ? "" : "s";
	$cl->debug(qq{$abs_wanted younger than $CPAN::Config->{'index_expire'} }.
		   qq{day$s. I\'ll use that.});
	return $abs_wanted;
d5034 1
a5034 1
	$force |= 1; # means we're quite serious about it.
d5042 2
a5044 1
    return unless defined $index_target;
d5047 1
a5047 1
    tie *FH, CPAN::Tarzip, $index_target;
d5049 1
d5051 2
d5054 15
a5068 8
	my($userid,$fullname,$email) =
	    m/alias\s+(\S+)\s+\"([^\"\<]+)\s+\<([^\>]+)\>\"/;
	next unless $userid && $fullname && $email;

	# instantiate an author object
 	my $userobj = $CPAN::META->instance('CPAN::Author',$userid);
	$userobj->set('FULLNAME' => $fullname, 'EMAIL' => $email);
	return if $CPAN::Signal;
d5070 1
a5082 1
    my @@lines;
d5084 1
d5087 6
a5092 6
    local($/) = "\n";
    while ($_ = $fh->READLINE) {
	s/\012/\n/g;
	my @@ls = map {"$_\n"} split /\n/, $_;
	unshift @@ls, "\n" x length($1) if /^(\n+)/;
	push @@lines, @@ls;
d5094 3
d5100 3
a5102 3
	my $shift = shift(@@lines);
	last if $shift =~ /^\s*$/;
	$shift =~ /^Line-Count:\s+(\d+)/ and $line_count = $1;
d5105 1
d5108 1
a5108 1
	warn qq{Warning: Your $index_target does not contain a Line-Count header.
d5112 1
a5112 1
};
d5114 1
a5114 1
	sleep 5;
d5117 1
a5117 1
	warn sprintf qq{Warning: Your %s
d5121 1
a5121 1
$index_target, $line_count, scalar(@@lines);
d5126 1
a5126 1
	warn qq{Warning: Your $index_target does not contain a Last-Updated header.
d5130 1
a5130 1
};
d5132 1
a5132 1
	sleep 5;
d5135 1
a5135 1
	$CPAN::Frontend
d5140 2
a5141 1
        if ($CPAN::META->has_inst(HTTP::Date)) {
d5143 14
a5156 6
            my($age) = (time - HTTP::Date::str2time($last_updated))/3600/24;
            if ($age > 30) {

                $CPAN::Frontend
                    ->mywarn(sprintf
                             qq{Warning: This index file is %d days old.
d5159 14
a5172 1
                             $age);
a5173 3
            }
        } else {
            $CPAN::Frontend->myprint("  HTTP::Date not available\n");
d5183 2
a5185 1
	chomp;
d5189 2
a5190 2
	my($mod,$version,$dist,$comment) = split " ", $_, 4;
	my($bundle,$id,$userid);
d5192 6
a5197 6
	if ($mod eq 'CPAN' &&
	    ! (
	       CPAN::Queue->exists('Bundle::CPAN') ||
	       CPAN::Queue->exists('CPAN')
	      )
	   ) {
d5199 4
a5202 4
            if ($version > $CPAN::VERSION){
                $CPAN::Frontend->myprint(qq{
  There's a new CPAN.pm version (v$version) available!
  [Current version is v$CPAN::VERSION]
d5204 1
a5204 1
    install Bundle::CPAN
d5206 3
a5208 2
  without quitting the current session. It should be a seamless upgrade
  while we are running...
d5210 12
a5221 12
                sleep 2;
		$CPAN::Frontend->myprint(qq{\n});
	    }
	    last if $CPAN::Signal;
	} elsif ($mod =~ /^Bundle::(.*)/) {
	    $bundle = $1;
	}

	if ($bundle){
	    $id =  $CPAN::META->instance('CPAN::Bundle',$mod);
	    # Let's make it a module too, because bundles have so much
	    # in common with modules.
d5226 1
a5226 1
	    # $CPAN::META->instance('CPAN::Module',$mod);
d5228 1
a5228 1
	} else {
d5230 2
a5231 2
	    # instantiate a module object
	    $id = $CPAN::META->instance('CPAN::Module',$mod);
d5233 1
a5233 1
	}
d5235 32
a5266 28
	if ($id->cpan_file ne $dist){ # update only if file is
                                      # different. CPAN prohibits same
                                      # name with different version
	    $userid = $id->userid || $self->userid($dist);
	    $id->set(
		     'CPAN_USERID' => $userid,
		     'CPAN_VERSION' => $version,
		     'CPAN_FILE' => $dist,
		    );
	}

	# instantiate a distribution object
	if ($CPAN::META->exists('CPAN::Distribution',$dist)) {
	  # we do not need CONTAINSMODS unless we do something with
	  # this dist, so we better produce it on demand.

	  ## my $obj = $CPAN::META->instance(
	  ## 				  'CPAN::Distribution' => $dist
	  ## 				 );
	  ## $obj->{CONTAINSMODS}{$mod} = undef; # experimental
	} else {
	  $CPAN::META->instance(
				'CPAN::Distribution' => $dist
			       )->set(
				      'CPAN_USERID' => $userid,
                                      'CPAN_COMMENT' => $comment,
				     );
	}
d5269 1
a5269 1
                CPAN->debug("exists name[$name]") if $CPAN::DEBUG;
d5273 6
a5278 1
	return if $CPAN::Signal;
d5280 1
a5280 1
    undef $fh;
d5286 2
a5287 2
                CPAN->debug("deleting ID[$o->{ID}] in class[$class]")
                    if $CPAN::DEBUG;
d5297 1
d5300 18
a5317 15
    my @@eval;
    local($/) = "\n";
    while ($_ = $fh->READLINE) {
	s/\012/\n/g;
	my @@ls = map {"$_\n"} split /\n/, $_;
	unshift @@ls, "\n" x length($1) if /^(\n+)/;
	push @@eval, @@ls;
    }
    while (@@eval) {
	my $shift = shift(@@eval);
	if ($shift =~ /^Date:\s+(.*)/){
	    return if $DATE_OF_03 eq $1;
	    ($DATE_OF_03) = $1;
	}
	last if $shift =~ /^\s*$/;
d5319 1
a5319 2
    undef $fh;
    push @@eval, q{CPAN::Modulelist->data;};
d5322 3
a5324 2
    my($eval) = join("", @@eval);
    my $ret = $comp->reval($eval);
d5327 4
d5332 1
a5332 1
	my $obj = $CPAN::META->instance("CPAN::Module",$_);
d5334 7
a5340 2
	$obj->set(%{$ret->{$_}});
	return if $CPAN::Signal;
d5342 1
d5349 1
d5353 2
a5354 2
		      CPAN::Distribution)) {
	$cache->{$k} = $CPAN::META->{readonly}{$k}; # unsafe meta access, ok
d5369 1
d5377 1
a5377 1
    if (!$cache || ref $cache ne 'HASH'){
d5398 2
a5399 2
	next unless $class =~ /^CPAN::/;
	$CPAN::META->{readonly}{$class} = $v; # unsafe meta access, ok
d5422 1
a5422 1
	if defined $DATE_OF_02; # An old cache may not contain DATE_OF_02
d5427 6
d5434 1
a5434 1
# Accessors
d5437 8
a5444 1
    $self->{RO}{CPAN_USERID}
d5462 36
d5527 2
a5528 1
    push @@m, sprintf "%-15s %s\n", $class, $self->{ID};
d5539 16
a5554 5
    for (sort keys %{$self->{RO}}) {
	# next if m/^(ID|RO)$/;
	my $extra = "";
	if ($_ eq "CPAN_USERID") {
            $extra .= " (".$self->author;
d5568 2
a5569 2
        next unless defined $self->{RO}{$_};
        push @@m, sprintf "    %-12s %s%s\n", $_, $self->{RO}{$_}, $extra;
d5571 34
a5604 13
    for (sort keys %$self) {
	next if m/^(ID|RO)$/;
	if (ref($self->{$_}) eq "ARRAY") {
	  push @@m, sprintf "    %-12s %s\n", $_, "@@{$self->{$_}}";
	} elsif (ref($self->{$_}) eq "HASH") {
	  push @@m, sprintf(
			   "    %-12s %s\n",
			   $_,
			   join(" ",keys %{$self->{$_}}),
                          );
	} else {
	  push @@m, sprintf "    %-12s %s\n", $_, $self->{$_};
	}
d5609 2
a5610 2
#-> sub CPAN::InfoObj::author ;
sub author {
d5617 18
a5634 3
  my($self) = @@_;
  require Data::Dumper;
  print Data::Dumper::Dumper($self);
d5638 13
d5676 1
a5676 1
    shift->{RO}{FULLNAME};
d5681 1
a5681 1
sub email    { shift->{RO}{EMAIL}; }
d5686 2
d5690 1
a5690 1
    # adapted from CPAN::Distribution::verifyMD5 ;
d5694 1
a5694 1
    $csf[2] = join "", @@csf[1,2];
d5696 1
a5696 1
    @@dl = $self->dir_listing([$csf[0],"CHECKSUMS"], 0);
d5698 1
a5698 1
        $CPAN::Frontend->myprint("No files in the directory of $id\n");
d5701 1
a5701 1
    @@dl = $self->dir_listing([@@csf[0,1],"CHECKSUMS"], 0);
d5703 1
a5703 1
        $CPAN::Frontend->myprint("No files in the directory of $id\n");
d5706 15
a5720 4
    @@dl = $self->dir_listing([@@csf,"CHECKSUMS"], 1);
    $CPAN::Frontend->myprint(join "", map {
        sprintf("%8d %10s %s/%s\n", $_->[0], $_->[1], $id, $_->[2])
    } sort { $a->[2] cmp $b->[2] } @@dl);
d5729 2
d5732 14
a5745 2
	File::Spec->catfile($CPAN::Config->{keep_source_where},
			    "authors", "id", @@$chksumfile);
d5748 1
a5748 1
    my $force = 0;
d5750 1
a5750 1
        $force = $stat[9] + $CPAN::Config->{index_expire}*86400 <= time;
d5752 25
a5776 13
    my $lc_file = CPAN::FTP->localize("authors/id/@@$chksumfile",
                                      $lc_want,$force);
    unless ($lc_file) {
        $CPAN::Frontend->myprint("Trying $lc_want.gz\n");
	$chksumfile->[-1] .= ".gz";
	$lc_file = CPAN::FTP->localize("authors/id/@@$chksumfile",
                                       "$lc_want.gz",1);
	if ($lc_file) {
	    $lc_file =~ s{\.gz(?!\n)\Z}{}; #};
	    CPAN::Tarzip->gunzip("$lc_file.gz",$lc_file);
	} else {
	    return;
	}
d5779 2
a5780 2
    # adapted from CPAN::Distribution::MD5_check_file ;
    my $fh = FileHandle->new;
d5782 13
a5794 11
    if (open $fh, $lc_file){
	local($/);
	my $eval = <$fh>;
	$eval =~ s/\015?\012/\n/g;
	close $fh;
	my($comp) = Safe->new();
	$cksum = $comp->reval($eval);
	if ($@@) {
	    rename $lc_file, "$lc_file.bad";
	    Carp::confess($@@) if $@@;
	}
d5796 2
a5797 1
	Carp::carp "Could not open $lc_file for reading";
d5808 1
a5808 1
                } $self->dir_listing(\@@dir,1);
d5823 6
d5830 1
d5833 5
a5837 1
sub cpan_comment { shift->{RO}{CPAN_COMMENT} }
d5839 1
d5842 14
a5855 1
    delete $self->{later};
d5858 2
a5859 1
# CPAN::Distribution::normalize
d5863 27
a5889 1
    if (
d5902 76
a5977 7
#-> sub CPAN::Distribution::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    my($ancestors) = shift || [];
    # a distribution needs to recurse into its prereq_pms
d5980 1
d5982 2
a5983 2
    if ($depth>=100){
        $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
d5988 9
a5996 2
        for my $pre (keys %$prereq_pm) {
            my $premo = CPAN::Shell->expand("Module",$pre);
d6002 5
d6014 4
a6017 3
  my $self = shift;
  $self->containsmods;
  $self->SUPER::as_string(@@_);
d6022 32
a6053 11
  my $self = shift;
  return keys %{$self->{CONTAINSMODS}} if exists $self->{CONTAINSMODS};
  my $dist_id = $self->{ID};
  for my $mod ($CPAN::META->all_objects("CPAN::Module")) {
    my $mod_file = $mod->cpan_file or next;
    my $mod_id = $mod->{ID} or next;
    # warn "mod_file[$mod_file] dist_id[$dist_id] mod_id[$mod_id]";
    # sleep 1;
    $self->{CONTAINSMODS}{$mod_id} = undef if $mod_file eq $dist_id;
  }
  keys %{$self->{CONTAINSMODS}};
d6062 5
a6066 1
        return 0 unless $obj->uptodate;
a6077 16
#-> sub CPAN::Distribution::safe_chdir ;
sub safe_chdir {
    my($self,$todir) = @@_;
    # we die if we cannot chdir and we are debuggable
    Carp::confess("safe_chdir called without todir argument")
          unless defined $todir and length $todir;
    if (chdir $todir) {
        $self->debug(sprintf "changed directory to %s", CPAN::anycwd())
            if $CPAN::DEBUG;
    } else {
        my $cwd = CPAN::anycwd();
        $CPAN::Frontend->mydie(qq{Could not chdir from cwd[$cwd] }.
                               qq{to todir[$todir]: $!});
    }
}

d6081 18
d6100 42
a6141 4
	my @@e;
	exists $self->{'build_dir'} and push @@e,
	    "Is already unwrapped into directory $self->{'build_dir'}";
	$CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
d6145 21
a6165 3
    #
    # Get the file on local disk
    #
d6167 1
d6171 5
a6175 5
			    $CPAN::Config->{keep_source_where},
			    "authors",
			    "id",
			    split(/\//,$self->id)
			   );
d6188 2
a6189 1
    $self->debug("local_file[$local_file]") if $CPAN::DEBUG;
d6191 6
a6196 1
    return if $CPAN::Signal;
d6198 4
a6201 6
    #
    # Check integrity
    #
    if ($CPAN::META->has_inst("Digest::MD5")) {
	$self->debug("Digest::MD5 is installed, verifying");
	$self->verifyMD5;
d6203 1
a6203 1
	$self->debug("Digest::MD5 is NOT installed");
d6205 6
a6210 1
    return if $CPAN::Signal;
a6211 3
    #
    # Create a clean room and go there
    #
d6215 14
a6228 5
    $self->debug("Removing tmp") if $CPAN::DEBUG;
    File::Path::rmtree("tmp");
    mkdir "tmp", 0755 or Carp::croak "Couldn't mkdir tmp: $!";
    if ($CPAN::Signal){
        $self->safe_chdir($sub_wd);
d6231 1
a6231 1
    $self->safe_chdir("tmp");
d6236 10
a6245 3
    if ($local_file =~ /(\.tar\.(gz|Z)|\.tgz)(?!\n)\Z/i){
        $self->{was_uncompressed}++ unless CPAN::Tarzip->gtest($local_file);
	$self->untar_me($local_file);
d6247 1
a6247 4
	$self->unzip_me($local_file);
    } elsif ( $local_file =~ /\.pm\.(gz|Z)(?!\n)\Z/) {
        $self->{was_uncompressed}++ unless CPAN::Tarzip->gtest($local_file);
	$self->pm2dir_me($local_file);
d6249 2
a6250 3
	$self->{archived} = "NO";
        $self->safe_chdir($sub_wd);
        return;
d6259 30
a6288 31
    my ($distdir,$packagedir);
    if (@@readdir == 1 && -d $readdir[0]) {
        $distdir = $readdir[0];
        $packagedir = File::Spec->catdir($builddir,$distdir);
        $self->debug("packagedir[$packagedir]builddir[$builddir]distdir[$distdir]")
            if $CPAN::DEBUG;
        -d $packagedir and $CPAN::Frontend->myprint("Removing previously used ".
                                                    "$packagedir\n");
        File::Path::rmtree($packagedir);
        rename($distdir,$packagedir) or
            Carp::confess("Couldn't rename $distdir to $packagedir: $!");
        $self->debug(sprintf("renamed distdir[%s] to packagedir[%s] -e[%s]-d[%s]",
                             $distdir,
                             $packagedir,
                             -e $packagedir,
                             -d $packagedir,
                            )) if $CPAN::DEBUG;
    } else {
        my $userid = $self->cpan_userid;
        unless ($userid) {
            CPAN->debug("no userid? self[$self]");
            $userid = "anon";
        }
        my $pragmatic_dir = $userid . '000';
        $pragmatic_dir =~ s/\W_//g;
        $pragmatic_dir++ while -d "../$pragmatic_dir";
        $packagedir = File::Spec->catdir($builddir,$pragmatic_dir);
        $self->debug("packagedir[$packagedir]") if $CPAN::DEBUG;
        File::Path::mkpath($packagedir);
        my($f);
        for $f (@@readdir) { # is already without "." and ".."
d6290 51
a6340 1
            rename($f,$to) or Carp::confess("Couldn't rename $f to $to: $!");
d6343 27
a6369 2
    if ($CPAN::Signal){
        $self->safe_chdir($sub_wd);
d6372 2
d6375 46
a6420 3
    $self->{'build_dir'} = $packagedir;
    $self->safe_chdir($builddir);
    File::Path::rmtree("tmp");
d6422 5
a6426 1
    my($mpl) = File::Spec->catfile($packagedir,"Makefile.PL");
d6432 3
a6434 3
        sleep 1;
        my $mpldh = DirHandle->new($packagedir)
            or Carp::croak("Couldn't opendir $packagedir: $!");
d6438 211
a6648 11
    unless ($mpl_exists) {
        $self->debug(sprintf("makefilepl[%s]anycwd[%s]",
                             $mpl,
                             CPAN::anycwd(),
                            )) if $CPAN::DEBUG;
        my($configure) = File::Spec->catfile($packagedir,"Configure");
        if (-f $configure) {
            # do we have anything to do?
            $self->{'configure'} = $configure;
        } elsif (-f File::Spec->catfile($packagedir,"Makefile")) {
            $CPAN::Frontend->myprint(qq{
d6652 11
a6662 11
            $self->{writemakefile} = "YES";
            sleep 2;
        } else {
            my $cf = $self->called_for || "unknown";
            if ($cf =~ m|/|) {
                $cf =~ s|.*/||;
                $cf =~ s|\W.*||;
            }
            $cf =~ s|[/\\:]||g; # risk of filesystem damage
            $cf = "unknown" unless length($cf);
            $CPAN::Frontend->myprint(qq{Package seems to come without Makefile.PL.
d6665 2
a6666 2
            $self->{had_no_makefile_pl}++;
            sleep 3;
d6668 1
a6668 1
            # Writing our own Makefile.PL
d6670 2
d6673 67
a6739 4
            $fh->open(">$mpl")
                or Carp::croak("Could not open >$mpl: $!");
            $fh->print(
qq{# This Makefile.PL has been autogenerated by the module CPAN.pm
d6744 7
a6750 1
WriteMakefile(NAME => q[$cf]);
d6752 44
a6795 2
});
            $fh->close;
a6797 2

    return $self;
d6800 1
a6800 1
# CPAN::Distribution::untar_me ;
d6802 1
a6802 1
    my($self,$local_file) = @@_;
d6804 2
a6805 2
    if (CPAN::Tarzip->untar($local_file)) {
	$self->{unwrapped} = "YES";
d6807 1
a6807 1
	$self->{unwrapped} = "NO";
d6813 1
a6813 1
    my($self,$local_file) = @@_;
d6815 2
a6816 2
    if (CPAN::Tarzip->unzip($local_file)) {
	$self->{unwrapped} = "YES";
d6818 1
a6818 1
	$self->{unwrapped} = "NO";
d6823 1
a6823 1
sub pm2dir_me {
d6825 9
a6833 1
    $self->{archived} = "pm";
d6835 6
a6840 3
    $to =~ s/\.(gz|Z)(?!\n)\Z//;
    if (CPAN::Tarzip->gunzip($local_file,$to)) {
	$self->{unwrapped} = "YES";
d6842 5
a6846 1
	$self->{unwrapped} = "NO";
d6848 1
d6871 1
a6871 1
	$CPAN::Frontend->myprint(qq{
d6875 1
a6875 1
	$CPAN::Frontend->myprint(qq{
d6879 1
a6879 1
	return;
d6887 1
a6887 1
	$CPAN::Frontend->mywarn(qq{
d6890 1
a6890 1
	return;
d6895 8
a6902 3
    unless (system($CPAN::Config->{'shell'}) == 0) {
        my $code = $? >> 8;
        $CPAN::Frontend->mywarn("Subprocess shell exit code $code\n");
d6921 1
a6921 1
    my $cvs_root = 
d6923 1
a6923 1
    my $cvs_site_perl = 
d6926 1
a6926 1
	$cvs_dir = "$cvs_site_perl/$cvs_dir";
d6930 1
d6932 1
a6932 1
	       "$cvs_dir", $userid, "v$version");
d6941 2
a6942 1
	$CPAN::Frontend->mydie("cvs import failed");
d6954 6
a6959 6
	 File::Spec->catfile(
			     $CPAN::Config->{keep_source_where},
			     "authors",
			     "id",
			     split(/\//,"$sans.readme"),
			    );
d6962 2
a6963 2
				      $local_wanted)
	or $CPAN::Frontend->mydie(qq{No $sans.readme found});;
d6972 3
a6974 2
    $fh_pager->open("|$CPAN::Config->{'pager'}")
	or die "Could not open pager $CPAN::Config->{'pager'}: $!";
d6977 1
a6977 1
	or $CPAN::Frontend->mydie(qq{Could not open "$local_file": $!});
d6981 1
a6981 1
with pager "$CPAN::Config->{'pager'}"
a6982 1
    sleep 2;
d6984 1
d6987 2
a6988 2
#-> sub CPAN::Distribution::verifyMD5 ;
sub verifyMD5 {
d6991 4
a6994 4
	my @@e;
	$self->{MD5_STATUS} ||= "";
	$self->{MD5_STATUS} eq "OK" and push @@e, "MD5 Checksum was ok";
	$CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
d7001 2
a7002 2
	File::Spec->catfile($CPAN::Config->{keep_source_where},
			    "authors", "id", @@local);
d7004 5
a7008 6
    if (
	-s $lc_want
	&&
	$self->MD5_check_file($lc_want)
       ) {
	return $self->{MD5_STATUS} = "OK";
d7011 1
a7011 1
				   $lc_want,1);
d7014 12
a7025 9
	$local[-1] .= ".gz";
	$lc_file = CPAN::FTP->localize("authors/id/@@local",
				       "$lc_want.gz",1);
	if ($lc_file) {
	    $lc_file =~ s/\.gz(?!\n)\Z//;
	    CPAN::Tarzip->gunzip("$lc_file.gz",$lc_file);
	} else {
	    return;
	}
a7026 1
    $self->MD5_check_file($lc_file);
d7029 2
a7030 2
#-> sub CPAN::Distribution::MD5_check_file ;
sub MD5_check_file {
d7032 14
a7045 54
    my($cksum,$file,$basename);
    $file = $self->{localfile};
    $basename = File::Basename::basename($file);
    my $fh = FileHandle->new;
    if (open $fh, $chk_file){
	local($/);
	my $eval = <$fh>;
	$eval =~ s/\015?\012/\n/g;
	close $fh;
	my($comp) = Safe->new();
	$cksum = $comp->reval($eval);
	if ($@@) {
	    rename $chk_file, "$chk_file.bad";
	    Carp::confess($@@) if $@@;
	}
    } else {
	Carp::carp "Could not open $chk_file for reading";
    }

    if (exists $cksum->{$basename}{md5}) {
	$self->debug("Found checksum for $basename:" .
		     "$cksum->{$basename}{md5}\n") if $CPAN::DEBUG;

	open($fh, $file);
	binmode $fh;
	my $eq = $self->eq_MD5($fh,$cksum->{$basename}{'md5'});
	$fh->close;
	$fh = CPAN::Tarzip->TIEHANDLE($file);

	unless ($eq) {
	  # had to inline it, when I tied it, the tiedness got lost on
	  # the call to eq_MD5. (Jan 1998)
	  my $md5 = Digest::MD5->new;
	  my($data,$ref);
	  $ref = \$data;
	  while ($fh->READ($ref, 4096) > 0){
	    $md5->add($data);
	  }
	  my $hexdigest = $md5->hexdigest;
	  $eq += $hexdigest eq $cksum->{$basename}{'md5-ungz'};
	}

	if ($eq) {
	  $CPAN::Frontend->myprint("Checksum for $file ok\n");
	  return $self->{MD5_STATUS} = "OK";
	} else {
	    $CPAN::Frontend->myprint(qq{\nChecksum mismatch for }.
				     qq{distribution file. }.
				     qq{Please investigate.\n\n}.
				     $self->as_string,
				     $CPAN::META->instance(
							   'CPAN::Author',
							   $self->cpan_userid
							  )->as_string);
d7047 2
a7048 2
	    my $wrap = qq{I\'d recommend removing $file. Its MD5
checksum is incorrect. Maybe you have configured your 'urllist' with
d7052 95
a7146 1
            $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));
d7151 10
a7160 10
	    # $CPAN::Frontend->myprint("\n\n");
	    # sleep 3;
	    # return;
	}
	# close $fh if fileno($fh);
    } else {
	$self->{MD5_STATUS} ||= "";
	if ($self->{MD5_STATUS} eq "NIL") {
	    $CPAN::Frontend->mywarn(qq{
Warning: No md5 checksum for $basename in $chk_file.
d7166 5
a7170 5
            my $answer = ExtUtils::MakeMaker::prompt("Proceed?", "yes");
            $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted.");
	}
	$self->{MD5_STATUS} = "NIL";
	return;
d7174 14
a7187 12
#-> sub CPAN::Distribution::eq_MD5 ;
sub eq_MD5 {
    my($self,$fh,$expectMD5) = @@_;
    my $md5 = Digest::MD5->new;
    my($data);
    while (read($fh, $data, 4096)){
      $md5->add($data);
    }
    # $md5->addfile($fh);
    my $hexdigest = $md5->hexdigest;
    # warn "fh[$fh] hex[$hexdigest] aexp[$expectMD5]";
    $hexdigest eq $expectMD5;
d7192 4
a7195 4
# Both modules and distributions know if "force" is in effect by
# autoinspection, not by inspecting a global variable. One of the
# reason why this was chosen to work that way was the treatment of
# dependencies. They should not autpomatically inherit the force
d7202 9
d7212 66
a7277 6
  my($self, $method) = @@_;
  for my $att (qw(
  MD5_STATUS archived build_dir localfile make install unwrapped
  writemakefile
 )) {
    delete $self->{$att};
d7279 2
a7280 2
  if ($method && $method eq "install") {
    $self->{"force_update"}++; # name should probably have been force_install
d7284 14
d7301 1
a7301 1
  delete $self->{'force_update'};
d7310 3
a7312 3
		  (5)
		  ([._-])
		  (
d7315 1
a7315 1
                   \d*[24680]\.\d+
d7317 3
a7319 3
		  \.tar[._-]gz
		  (?!\n)\Z
		}xs){
d7323 1
a7323 1
           $self->cpan_comment =~ /isa_perl\(.+?\)/){
d7328 1
d7331 4
a7334 18
    my($self) = @@_;
    my($perl) = File::Spec->file_name_is_absolute($^X) ? $^X : "";
    my $pwd  = CPAN::anycwd();
    my $candidate = File::Spec->catfile($pwd,$^X);
    $perl ||= $candidate if MM->maybe_command($candidate);
    unless ($perl) {
	my ($component,$perl_name);
      DIST_PERLNAME: foreach $perl_name ($^X, 'perl', 'perl5', "perl$]") {
	    PATH_COMPONENT: foreach $component (File::Spec->path(),
						$Config::Config{'binexp'}) {
		  next unless defined($component) && $component;
		  my($abs) = File::Spec->catfile($component,$perl_name);
		  if (MM->maybe_command($abs)) {
		      $perl = $abs;
		      last DIST_PERLNAME;
		  }
	      }
	  }
d7336 1
a7336 1
    $perl;
d7339 1
d7343 4
a7346 1
    $CPAN::Frontend->myprint(sprintf "Running make for %s\n", $self->id);
d7349 11
a7359 12
      if (
	  $self->called_for ne $self->id &&
          ! $self->{force_update}
	 ) {
        # if we die here, we break bundles
	$CPAN::Frontend->mywarn(sprintf qq{
The most recent version "%s" of the module "%s"
comes with the current version of perl (%s).
I\'ll build that only if you ask for something like
    force install %s
or
    install %s
d7361 13
a7373 10
			       $CPAN::META->instance(
						     'CPAN::Module',
						     $self->called_for
						    )->cpan_version,
			       $self->called_for,
			       $self->isa_perl,
			       $self->called_for,
			       $self->id);
        sleep 5; return;
      }
d7375 1
d7377 8
a7384 4
  EXCUSE: {
	my @@e;
	$self->{archived} eq "NO" and push @@e,
	"Is neither a tar nor a zip archive.";
d7386 4
a7389 2
	$self->{unwrapped} eq "NO" and push @@e,
	"had problems unarchiving. Please build manually";
d7391 60
a7450 3
	exists $self->{writemakefile} &&
	    $self->{writemakefile} =~ m/ ^ NO\s* ( .* ) /sx and push @@e,
		$1 || "Had some problem writing Makefile";
d7452 6
a7457 2
	defined $self->{'make'} and push @@e,
            "Has already been processed within this session";
d7459 11
a7469 4
        exists $self->{later} and length($self->{later}) and
            push @@e, $self->{later};

	$CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
a7471 2
    my $builddir = $self->dir;
    chdir $builddir or Carp::croak("Couldn't chdir $builddir: $!");
d7479 6
d7486 8
a7493 2
    if ($self->{'configure'}) {
      $system = $self->{'configure'};
d7495 2
a7496 2
	my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
	my $switch = "";
d7498 505
a8002 55
#	$switch = "-MExtUtils::MakeMaker ".
#	    "-Mops=:default,:filesys_read,:filesys_open,require,chdir"
#	    if $] > 5.00310;
	$system = "$perl $switch Makefile.PL $CPAN::Config->{makepl_arg}";
    }
    unless (exists $self->{writemakefile}) {
	local($SIG{ALRM}) = sub { die "inactivity_timeout reached\n" };
	my($ret,$pid);
	$@@ = "";
	if ($CPAN::Config->{inactivity_timeout}) {
	    eval {
		alarm $CPAN::Config->{inactivity_timeout};
		local $SIG{CHLD}; # = sub { wait };
		if (defined($pid = fork)) {
		    if ($pid) { #parent
			# wait;
			waitpid $pid, 0;
		    } else {    #child
		      # note, this exec isn't necessary if
		      # inactivity_timeout is 0. On the Mac I'd
		      # suggest, we set it always to 0.
		      exec $system;
		    }
		} else {
		    $CPAN::Frontend->myprint("Cannot fork: $!");
		    return;
		}
	    };
	    alarm 0;
	    if ($@@){
		kill 9, $pid;
		waitpid $pid, 0;
		$CPAN::Frontend->myprint($@@);
		$self->{writemakefile} = "NO $@@";
		$@@ = "";
		return;
	    }
	} else {
	  $ret = system($system);
	  if ($ret != 0) {
	    $self->{writemakefile} = "NO Makefile.PL returned status $ret";
	    return;
	  }
	}
	if (-f "Makefile") {
	  $self->{writemakefile} = "YES";
          delete $self->{make_clean}; # if cleaned before, enable next
	} else {
	  $self->{writemakefile} =
	      qq{NO Makefile.PL refused to write a Makefile.};
	  # It's probably worth it to record the reason, so let's retry
	  # local $/;
	  # my $fh = IO::File->new("$system |"); # STDERR? STDIN?
	  # $self->{writemakefile} .= <$fh>;
	}
d8004 28
a8031 3
    if ($CPAN::Signal){
      delete $self->{force_update};
      return;
d8033 19
a8051 2
    if (my @@prereq = $self->unsat_prereq){
      return 1 if $self->follow_prereqs(@@prereq); # signal success to the queuerunner
d8053 26
a8078 8
    $system = join " ", $CPAN::Config->{'make'}, $CPAN::Config->{make_arg};
    if (system($system) == 0) {
	 $CPAN::Frontend->myprint("  $system -- OK\n");
	 $self->{'make'} = "YES";
    } else {
	 $self->{writemakefile} ||= "YES";
	 $self->{'make'} = "NO";
	 $CPAN::Frontend->myprint("  $system -- NOT OK\n");
d8082 1
d8085 19
a8103 7
    my(@@prereq) = @@_;
    my $id = $self->id;
    $CPAN::Frontend->myprint("---- Unsatisfied dependencies detected ".
                             "during [$id] -----\n");

    for my $p (@@prereq) {
	$CPAN::Frontend->myprint("    $p\n");
d8105 11
d8118 1
a8118 1
	$follow = 1;
d8120 1
a8120 2
	require ExtUtils::MakeMaker;
	my $answer = ExtUtils::MakeMaker::prompt(
d8123 1
a8123 1
	$follow = $answer =~ /^\s*y/i;
d8125 2
a8126 2
	local($") = ", ";
	$CPAN::Frontend->
d8130 1
d8134 8
a8141 1
            CPAN::Shell->expandany($p)->color_cmd_tmps(0,1);
d8143 4
a8146 2
        CPAN::Queue->jumpqueue(@@prereq,$id); # queue them and requeue yourself
        $self->{later} = "Delayed until after prerequisites";
d8149 1
d8153 2
d8156 20
a8175 2
    my($self) = @@_;
    my $prereq_pm = $self->prereq_pm or return;
d8177 23
a8199 10
  NEED: while (my($need_module, $need_version) = each %$prereq_pm) {
        my $nmo = $CPAN::META->instance("CPAN::Module",$need_module);
        # we were too demanding:
        next if $nmo->uptodate;

        # if they have not specified a version, we accept any installed one
        if (not defined $need_version or
           $need_version == 0 or
           $need_version eq "undef") {
            next if defined $nmo->inst_file;
d8205 2
a8206 1
        {
d8208 34
a8241 11
            if (
                defined $nmo->inst_file &&
                ! CPAN::Version->vgt($need_version, $nmo->inst_version)
               ){
                CPAN->debug(sprintf "id[%s]inst_file[%s]inst_version[%s]need_version[%s]",
                            $nmo->id,
                            $nmo->inst_file,
                            $nmo->inst_version,
                            CPAN::Version->readable($need_version)
                           );
                next NEED;
d8243 1
d8246 6
a8251 1
        if ($self->{sponsored_mods}{$need_module}++){
d8253 2
a8254 1
            # not available. So we do nothing. Or what should we do?
d8256 78
a8333 1
            next;
d8335 2
a8336 1
        push @@need, $need_module;
d8338 2
d8343 28
a8372 42
  my($self) = @@_;
  return $self->{prereq_pm} if
      exists $self->{prereq_pm_detected} && $self->{prereq_pm_detected};
  return unless $self->{writemakefile}; # no need to have succeeded
                                        # but we must have run it
  my $build_dir = $self->{build_dir} or die "Panic: no build_dir?";
  my $makefile = File::Spec->catfile($build_dir,"Makefile");
  my(%p) = ();
  my $fh;
  if (-f $makefile
      and
      $fh = FileHandle->new("<$makefile\0")) {

      local($/) = "\n";

      #  A.Speer @@p -> %p, where %p is $p{Module::Name}=Required_Version
      while (<$fh>) {
          last if /MakeMaker post_initialize section/;
          my($p) = m{^[\#]
		 \s+PREREQ_PM\s+=>\s+(.+)
		 }x;
          next unless $p;
          # warn "Found prereq expr[$p]";

          #  Regexp modified by A.Speer to remember actual version of file
          #  PREREQ_PM hash key wants, then add to
          while ( $p =~ m/(?:\s)([\w\:]+)=>q\[(.*?)\],?/g ){
              # In case a prereq is mentioned twice, complain.
              if ( defined $p{$1} ) {
                  warn "Warning: PREREQ_PM mentions $1 more than once, last mention wins";
              }
              $p{$1} = $2;
          }
          last;
      }
  }
  $self->{prereq_pm_detected}++;
  return $self->{prereq_pm} = \%p;
}

#-> sub CPAN::Distribution::test ;
sub test {
d8374 130
d8505 1
a8505 1
    if ($CPAN::Signal){
d8509 4
a8512 3
    $CPAN::Frontend->myprint("Running make test\n");
    if (my @@prereq = $self->unsat_prereq){
      return 1 if $self->follow_prereqs(@@prereq); # signal success to the queuerunner
d8514 12
d8527 7
a8533 7
	my @@e;
	exists $self->{make} or exists $self->{later} or push @@e,
	"Make had some problems, maybe interrupted? Won't test";

	exists $self->{'make'} and
	    $self->{'make'} eq 'NO' and
		push @@e, "Can't test without successful make";
d8535 6
a8540 1
	exists $self->{build_dir} or push @@e, "Has no own directory";
d8542 3
a8544 1
        $self->{badtestcnt} > 0 and
d8546 1
d8548 2
a8549 2
        exists $self->{later} and length($self->{later}) and
            push @@e, $self->{later};
d8551 26
a8576 1
	$CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
d8578 2
a8579 4
    chdir $self->{'build_dir'} or
	Carp::croak("Couldn't chdir to $self->{'build_dir'}");
    $self->debug("Changed directory to $self->{'build_dir'}")
	if $CPAN::DEBUG;
d8586 138
a8723 11
    local $ENV{PERL5LIB} = $ENV{PERL5LIB} || "";
    $CPAN::META->set_perl5lib;
    my $system = join " ", $CPAN::Config->{'make'}, "test";
    if (system($system) == 0) {
	 $CPAN::Frontend->myprint("  $system -- OK\n");
	 $CPAN::META->is_tested($self->{'build_dir'});
	 $self->{make_test} = "YES";
    } else {
	 $self->{make_test} = "NO";
         $self->{badtestcnt}++;
	 $CPAN::Frontend->myprint("  $system -- NOT OK\n");
d8725 1
d8731 17
a8747 1
    $CPAN::Frontend->myprint("Running make clean\n");
d8749 1
a8749 1
	my @@e;
d8752 1
a8752 2
	exists $self->{build_dir} or push @@e, "Has no own directory";
	$CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
d8754 3
a8756 3
    chdir $self->{'build_dir'} or
	Carp::croak("Couldn't chdir to $self->{'build_dir'}");
    $self->debug("Changed directory to $self->{'build_dir'}") if $CPAN::DEBUG;
d8763 15
a8777 2
    my $system = join " ", $CPAN::Config->{'make'}, "clean";
    if (system($system) == 0) {
d8787 10
a8796 6
      delete $self->{force_update};
      delete $self->{install};
      delete $self->{writemakefile};
      delete $self->{make};
      delete $self->{make_test}; # no matter if yes or no, tests must be redone
      $self->{make_clean} = "YES";
d8801 2
a8802 1
      $CPAN::Frontend->myprint(qq{  $system -- NOT OK
d8804 2
a8805 3
make clean did not succeed, marking directory as unusable for further work.
});
      $self->force("make"); # so that this directory won't be used again
d8808 29
d8842 8
a8849 2
    $self->test;
    if ($CPAN::Signal){
d8853 2
a8854 1
    $CPAN::Frontend->myprint("Running make install\n");
d8856 48
a8903 2
	my @@e;
	exists $self->{build_dir} or push @@e, "Has no own directory";
d8905 2
a8906 2
	exists $self->{make} or exists $self->{later} or push @@e,
	"Make had some problems, maybe interrupted? Won't install";
d8908 8
a8915 23
	exists $self->{'make'} and
	    $self->{'make'} eq 'NO' and
		push @@e, "make had returned bad status, install seems impossible";

	push @@e, "make test had returned bad status, ".
	    "won't install without force"
	    if exists $self->{'make_test'} and
	    $self->{'make_test'} eq 'NO' and
	    ! $self->{'force_update'};

	exists $self->{'install'} and push @@e,
	$self->{'install'} eq "YES" ?
	    "Already done" : "Already tried without success";

        exists $self->{later} and length($self->{later}) and
            push @@e, $self->{later};

	$CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    chdir $self->{'build_dir'} or
	Carp::croak("Couldn't chdir to $self->{'build_dir'}");
    $self->debug("Changed directory to $self->{'build_dir'}")
	if $CPAN::DEBUG;
d8922 57
a8978 3
    my $system = join(" ", $CPAN::Config->{'make'},
		      "install", $CPAN::Config->{make_install_arg});
    my($stderr) = $^O =~ /Win/i ? "" : " 2>&1 ";
d8981 5
a8985 3
    while (<$pipe>){
	$CPAN::Frontend->myprint($_);
	$makeout .= $_;
d8988 30
a9017 11
    if ($?==0) {
	 $CPAN::Frontend->myprint("  $system -- OK\n");
	 $CPAN::META->is_installed($self->{'build_dir'});
	 return $self->{'install'} = "YES";
    } else {
	 $self->{'install'} = "NO";
	 $CPAN::Frontend->myprint("  $system -- NOT OK\n");
	 if ($makeout =~ /permission/s && $> > 0) {
	     $CPAN::Frontend->myprint(qq{    You may have to su }.
				      qq{to root to install the package\n});
	 }
d9020 7
d9031 359
a9389 1
    shift->{'build_dir'};
d9393 1
d9400 1
d9410 1
d9421 1
d9423 2
a9424 2
    if ($depth>=100){
        $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
d9433 4
a9436 3
    if ($color==0) {
        delete $self->{badtestcnt};
    }
d9455 3
d9470 1
d9472 1
a9472 1
        $self->debug($dist->as_string) if $CPAN::DEBUG;
d9478 1
a9478 1
        $from = $self->find_bundle_file($dist->{'build_dir'},$me);
d9517 1
d9526 5
a9530 5
	require ExtUtils::Manifest;
	my $cwd = CPAN::anycwd();
	chdir $where or $CPAN::Frontend->mydie(qq{Could not chdir to "$where": $!});
	ExtUtils::Manifest::mkmanifest();
	chdir $cwd or $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!});
d9533 1
a9533 1
	or Carp::croak("Couldn't open $manifest: $!");
d9535 3
a9537 10
    my $what2 = $what;
    if ($^O eq 'MacOS') {
      $what =~ s/^://;
      $what =~ tr|:|/|;
      $what2 =~ s/:Bundle://;
      $what2 =~ tr|:|/|;
    } else {
	$what2 =~ s|Bundle[/\\]||;
    }
    my $bu;
d9539 9
a9547 10
	next if /^\s*\#/;
	my($file) = /(\S+)/;
	if ($file =~ m|\Q$what\E$|) {
	    $bu = $file;
	    # return File::Spec->catfile($where,$bu); # bad
	    last;
	}
	# retry if she managed to
	# have no Bundle directory
	$bu = $file if $file =~ m|\Q$what2\E$|;
d9549 2
a9550 2
    $bu =~ tr|/|:| if $^O eq 'MacOS';
    return File::Spec->catfile($where, $bu) if $bu;
d9593 1
a9593 1
	unless $self->inst_file || $self->cpan_file;
d9596 4
a9599 4
	my($type) = $s =~ m|/| ? 'CPAN::Distribution' :
	    $s =~ m|^Bundle::| ? 'CPAN::Bundle' : 'CPAN::Module';
	if ($type eq 'CPAN::Distribution') {
	    $CPAN::Frontend->mywarn(qq{
d9601 2
a9602 1
explicitly a file $s.
d9604 3
a9606 3
	    sleep 3;
	}
	# possibly noisy action:
d9608 3
a9610 58
	my $obj = $CPAN::META->instance($type,$s);
	$obj->$meth();
        if ($obj->isa(CPAN::Bundle)
            &&
            exists $obj->{install_failed}
            &&
            ref($obj->{install_failed}) eq "HASH"
           ) {
          for (keys %{$obj->{install_failed}}) {
            $self->{install_failed}{$_} = undef; # propagate faiure up
                                                 # to me in a
                                                 # recursive call
            $fail{$s} = 1; # the bundle itself may have succeeded but
                           # not all children
          }
        } else {
          my $success;
          $success = $obj->can("uptodate") ? $obj->uptodate : 0;
          $success ||= $obj->{'install'} && $obj->{'install'} eq "YES";
          if ($success) {
            delete $self->{install_failed}{$s};
          } else {
            $fail{$s} = 1;
          }
        }
    }

    # recap with less noise
    if ( $meth eq "install" ) {
	if (%fail) {
	    require Text::Wrap;
	    my $raw = sprintf(qq{Bundle summary:
The following items in bundle %s had installation problems:},
			      $self->id
			     );
	    $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
	    $CPAN::Frontend->myprint("\n");
	    my $paragraph = "";
            my %reported;
	    for $s ($self->contains) {
              if ($fail{$s}){
		$paragraph .= "$s ";
                $self->{install_failed}{$s} = undef;
                $reported{$s} = undef;
              }
	    }
            my $report_propagated;
            for $s (sort keys %{$self->{install_failed}}) {
              next if exists $reported{$s};
              $paragraph .= "and the following items had problems
during recursive bundle calls: " unless $report_propagated++;
              $paragraph .= "$s ";
            }
	    $CPAN::Frontend->myprint(Text::Wrap::fill("  ","  ",$paragraph));
	    $CPAN::Frontend->myprint("\n");
	} else {
	    $self->{'install'} = 'YES';
	}
d9614 3
a9616 1
#sub CPAN::Bundle::xs_file
a9617 2
    # If a bundle contains another that contains an xs_file we have
    # here, we just don't bother I suppose
d9622 2
d9625 2
d9634 1
a9634 1
    $self->{badtestcnt} ||= 0;
d9667 1
d9670 1
a9670 1
# sub CPAN::Module::userid
d9673 15
a9687 2
    return unless exists $self->{RO}; # should never happen
    return $self->{RO}{userid} || $self->{RO}{CPAN_USERID};
a9688 2
# sub CPAN::Module::description
sub description { shift->{RO}{description} }
d9690 1
d9699 1
d9709 1
d9711 34
a9744 2
    if ($depth>=100){
        $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
d9751 4
a9754 3
    if ($color==0) {
        delete $self->{badtestcnt};
    }
d9771 1
a9771 1
        $self->{RO}{description}
d9776 10
a9785 1
    push @@m, sprintf("%-15s %s%-15s%s (%s)\n",
d9787 1
d9791 2
a9792 1
		     $self->cpan_file);
d9796 47
d9854 1
a9854 1
	if $self->description;
d9858 15
a9872 15
    if ( $userid ){
	my $author;
	if ($author = CPAN::Shell->expand('Author',$userid)) {
	  my $email = "";
	  my $m; # old perls
	  if ($m = $author->email) {
            $email = " <$m>";
          }
	  push @@m, sprintf(
			   $sprintf2,
			   'CPAN_USERID',
			   $userid,
			   $author->fullname . $email
			  );
	}
d9875 12
a9886 16
	if $self->cpan_version;
    push @@m, sprintf($sprintf, 'CPAN_FILE', $self->cpan_file)
	if $self->cpan_file;
    my $sprintf3 = "    %-12s %1s%1s%1s%1s (%s,%s,%s,%s)\n";
    my(%statd,%stats,%statl,%stati);
    @@statd{qw,? i c a b R M S,} = qw,unknown idea
	pre-alpha alpha beta released mature standard,;
    @@stats{qw,? m d u n a,}       = qw,unknown mailing-list
	developer comp.lang.perl.* none abandoned,;
    @@statl{qw,? p c + o h,}       = qw,unknown perl C C++ other hybrid,;
    @@stati{qw,? f r O h,}         = qw,unknown functions
	references+ties object-oriented hybrid,;
    $statd{' '} = 'unknown';
    $stats{' '} = 'unknown';
    $statl{' '} = 'unknown';
    $stati{' '} = 'unknown';
d9888 4
a9891 11
		     $sprintf3,
		     'DSLI_STATUS',
		     $self->{RO}{statd},
		     $self->{RO}{stats},
		     $self->{RO}{statl},
		     $self->{RO}{stati},
		     $statd{$self->{RO}{statd}},
		     $stats{$self->{RO}{stats}},
		     $statl{$self->{RO}{statl}},
		     $stati{$self->{RO}{stati}}
		    ) if $self->{RO}{statd};
d9894 1
d9896 1
a9896 1
            $self->{MANPAGE} = $self->manpage_headline($local_file);
d9932 1
a9932 1
                    $self->{MANPAGE} = $self->manpage_headline($lfl_abs);
d9936 1
d9940 2
a9941 2
	push @@m, sprintf($sprintf, $item, $self->{$item})
	    if exists $self->{$item};
d9944 2
a9945 2
	push @@m, sprintf($sprintf, $item, join(" ",@@{$self->{$item}}))
	    if exists $self->{$item} && @@{$self->{$item}};
d9948 1
a9948 1
		     $local_file || "(not installed)");
d9950 1
a9950 1
		     $self->inst_version) if $local_file;
d9954 1
d9956 26
a9981 19
  my($self,$local_file) = @@_;
  my(@@local_file) = $local_file;
  $local_file =~ s/\.pm(?!\n)\Z/.pod/;
  push @@local_file, $local_file;
  my(@@result,$locf);
  for $locf (@@local_file) {
    next unless -f $locf;
    my $fh = FileHandle->new($locf)
	or $Carp::Frontend->mydie("Couldn't open $locf: $!");
    my $inpod = 0;
    local $/ = "\n";
    while (<$fh>) {
      $inpod = m/^=(?!head1\s+NAME\s*$)/ ? 0 :
	  m/^=head1\s+NAME\s*$/ ? 1 : $inpod;
      next unless $inpod;
      next if /^=/;
      next if /^\s+$/;
      chomp;
      push @@result, $_;
d9983 1
a9983 4
    close $fh;
    last if @@result;
  }
  join " ", @@result;
d9990 7
a9996 6
    CPAN->debug(sprintf "id[%s]", $self->id) if $CPAN::DEBUG;
    unless (defined $self->{RO}{CPAN_FILE}) {
	CPAN::Index->reload;
    }
    if (exists $self->{RO}{CPAN_FILE} && defined $self->{RO}{CPAN_FILE}){
	return $self->{RO}{CPAN_FILE};
d10024 8
a10031 7
    $self->{RO}{CPAN_VERSION} = 'undef'
	unless defined $self->{RO}{CPAN_VERSION};
    # I believe this is always a bug in the index and should be reported
    # as such, but usually I find out such an error and do not want to
    # provoke too many bugreports

    $self->{RO}{CPAN_VERSION};
d10037 14
a10050 1
    $self->{'force_update'}++;
d10056 1
a10056 1
    $CPAN::Frontend->myprint(sprintf("Running %s for module %s\n",
d10060 2
a10061 2
    if ($cpan_file eq "N/A" || $cpan_file =~ /^Contact Author/){
      $CPAN::Frontend->mywarn(sprintf qq{
d10068 4
a10071 4
			      $self->id,
			      $self->id,
			     );
      return;
d10075 8
a10082 5
    $pack->force($meth) if exists $self->{'force_update'};
    $pack->$meth();
    $pack->unforce if $pack->can("unforce") && exists $self->{'force_update'};
    delete $self->{'force_update'};
}
d10084 40
d10125 1
a10125 1
sub readme { shift->rematein('readme') }
d10127 1
a10127 1
sub look { shift->rematein('look') }
d10131 1
a10131 1
sub get    { shift->rematein('get',@@_); }
d10133 1
a10133 4
sub make   {
    my $self = shift;
    $self->rematein('make');
}
d10137 1
a10137 1
    $self->{badtestcnt} ||= 0;
d10140 1
d10143 11
a10153 18
    my($self) = @@_;
    my($latest) = $self->cpan_version;
    $latest ||= 0;
    my($inst_file) = $self->inst_file;
    my($have) = 0;
    if (defined $inst_file) {
	$have = $self->inst_version;
    }
    local($^W)=0;
    if ($inst_file
	&&
	! CPAN::Version->vgt($latest, $have)
       ) {
        CPAN->debug("returning uptodate. inst_file[$inst_file] ".
                    "latest[$latest] have[$have]") if $CPAN::DEBUG;
        return 1;
    }
    return;
d10155 1
d10161 2
a10162 2
	&&
	not exists $self->{'force_update'}
d10164 4
a10167 1
	$CPAN::Frontend->myprint( $self->id. " is up to date.\n");
d10169 1
a10169 1
	$doit = 1;
d10171 2
a10172 1
    if ($self->{RO}{stats} && $self->{RO}{stats} eq "a") {
d10177 1
a10177 1
        sleep 5;
d10187 16
d10206 8
a10213 5
    foreach $dir (@@INC) {
	my $pmfile = File::Spec->catfile($dir,@@packpath);
	if (-f $pmfile){
	    return $pmfile;
	}
d10226 4
a10229 4
	my $xsfile = File::Spec->catfile($dir,'auto',@@packpath);
	if (-f $xsfile){
	    return $xsfile;
	}
d10238 3
a10240 2
    local($^W) = 0 if $] < 5.00303 && $ExtUtils::MakeMaker::VERSION < 5.38;
    my $have;
d10242 7
a10248 7
    # there was a bug in 5.6.0 that let lots of unini warnings out of
    # parse_version. Fixed shortly after 5.6.0 by PMQS. We can remove
    # the following workaround after 5.6.1 is out.
    local($SIG{__WARN__}) =  sub { my $w = shift;
                                   return if $w =~ /uninitialized/i;
                                   warn $w;
                                 };
d10250 5
a10254 1
    $have = MM->parse_version($parsefile) || "undef";
a10257 20
    # My thoughts about why %vd processing should happen here

    # Alt1 maintain it as string with leading v:
    # read index files     do nothing
    # compare it           use utility for compare
    # print it             do nothing

    # Alt2 maintain it as what it is
    # read index files     convert
    # compare it           use utility because there's still a ">" vs "gt" issue
    # print it             use CPAN::Version for print

    # Seems cleaner to hold it in memory as a string starting with a "v"

    # If the author of this module made a mistake and wrote a quoted
    # "v1.13" instead of v1.13, we simply leave it at that with the
    # effect that *we* will treat it like a v-tring while the rest of
    # perl won't. Seems sensible when we consider that any action we
    # could take now would just add complexity.

d10264 2
a10265 127
package CPAN::Tarzip;

# CPAN::Tarzip::gzip
sub gzip {
  my($class,$read,$write) = @@_;
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my($buffer,$fhw);
    $fhw = FileHandle->new($read)
	or $CPAN::Frontend->mydie("Could not open $read: $!");
    my $gz = Compress::Zlib::gzopen($write, "wb")
	or $CPAN::Frontend->mydie("Cannot gzopen $write: $!\n");
    $gz->gzwrite($buffer)
	while read($fhw,$buffer,4096) > 0 ;
    $gz->gzclose() ;
    $fhw->close;
    return 1;
  } else {
    system("$CPAN::Config->{gzip} -c $read > $write")==0;
  }
}


# CPAN::Tarzip::gunzip
sub gunzip {
  my($class,$read,$write) = @@_;
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my($buffer,$fhw);
    $fhw = FileHandle->new(">$write")
	or $CPAN::Frontend->mydie("Could not open >$write: $!");
    my $gz = Compress::Zlib::gzopen($read, "rb")
	or $CPAN::Frontend->mydie("Cannot gzopen $read: $!\n");
    $fhw->print($buffer)
	while $gz->gzread($buffer) > 0 ;
    $CPAN::Frontend->mydie("Error reading from $read: $!\n")
	if $gz->gzerror != Compress::Zlib::Z_STREAM_END();
    $gz->gzclose() ;
    $fhw->close;
    return 1;
  } else {
    system("$CPAN::Config->{gzip} -dc $read > $write")==0;
  }
}


# CPAN::Tarzip::gtest
sub gtest {
  my($class,$read) = @@_;
  # After I had reread the documentation in zlib.h, I discovered that
  # uncompressed files do not lead to an gzerror (anymore?).
  if ( $CPAN::META->has_inst("Compress::Zlib") ) {
    my($buffer,$len);
    $len = 0;
    my $gz = Compress::Zlib::gzopen($read, "rb")
	or $CPAN::Frontend->mydie(sprintf("Cannot gzopen %s: %s\n",
                                          $read,
                                          $Compress::Zlib::gzerrno));
    while ($gz->gzread($buffer) > 0 ){
        $len += length($buffer);
        $buffer = "";
    }
    my $err = $gz->gzerror;
    my $success = ! $err || $err == Compress::Zlib::Z_STREAM_END();
    if ($len == -s $read){
        $success = 0;
        CPAN->debug("hit an uncompressed file") if $CPAN::DEBUG;
    }
    $gz->gzclose();
    CPAN->debug("err[$err]success[$success]") if $CPAN::DEBUG;
    return $success;
  } else {
      return system("$CPAN::Config->{gzip} -dt $read")==0;
  }
}


# CPAN::Tarzip::TIEHANDLE
sub TIEHANDLE {
  my($class,$file) = @@_;
  my $ret;
  $class->debug("file[$file]");
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my $gz = Compress::Zlib::gzopen($file,"rb") or
	die "Could not gzopen $file";
    $ret = bless {GZ => $gz}, $class;
  } else {
    my $pipe = "$CPAN::Config->{gzip} --decompress --stdout $file |";
    my $fh = FileHandle->new($pipe) or die "Could not pipe[$pipe]: $!";
    binmode $fh;
    $ret = bless {FH => $fh}, $class;
  }
  $ret;
}


# CPAN::Tarzip::READLINE
sub READLINE {
  my($self) = @@_;
  if (exists $self->{GZ}) {
    my $gz = $self->{GZ};
    my($line,$bytesread);
    $bytesread = $gz->gzreadline($line);
    return undef if $bytesread <= 0;
    return $line;
  } else {
    my $fh = $self->{FH};
    return scalar <$fh>;
  }
}


# CPAN::Tarzip::READ
sub READ {
  my($self,$ref,$length,$offset) = @@_;
  die "read with offset not implemented" if defined $offset;
  if (exists $self->{GZ}) {
    my $gz = $self->{GZ};
    my $byteread = $gz->gzread($$ref,$length);# 30eaf79e8b446ef52464b5422da328a8
    return $byteread;
  } else {
    my $fh = $self->{FH};
    return read($fh,$$ref,$length);
  }
}


# CPAN::Tarzip::DESTROY
sub DESTROY {
d10267 1
a10267 9
    if (exists $self->{GZ}) {
        my $gz = $self->{GZ};
        $gz->gzclose() if defined $gz; # hard to say if it is allowed
                                       # to be undef ever. AK, 2000-09
    } else {
        my $fh = $self->{FH};
        $fh->close if defined $fh;
    }
    undef $self;
d10270 2
d10273 1
a10273 89
# CPAN::Tarzip::untar
sub untar {
  my($class,$file) = @@_;
  my($prefer) = 0;

  if (0) { # makes changing order easier
  } elsif ($BUGHUNTING){
      $prefer=2;
  } elsif (MM->maybe_command($CPAN::Config->{gzip})
           &&
           MM->maybe_command($CPAN::Config->{'tar'})) {
      # should be default until Archive::Tar is fixed
      $prefer = 1;
  } elsif (
           $CPAN::META->has_inst("Archive::Tar")
           &&
           $CPAN::META->has_inst("Compress::Zlib") ) {
      $prefer = 2;
  } else {
    $CPAN::Frontend->mydie(qq{
CPAN.pm needs either both external programs tar and gzip installed or
both the modules Archive::Tar and Compress::Zlib. Neither prerequisite
is available. Can\'t continue.
});
  }
  if ($prefer==1) { # 1 => external gzip+tar
    my($system);
    my $is_compressed = $class->gtest($file);
    if ($is_compressed) {
        $system = "$CPAN::Config->{gzip} --decompress --stdout " .
            "< $file | $CPAN::Config->{tar} xvf -";
    } else {
        $system = "$CPAN::Config->{tar} xvf $file";
    }
    if (system($system) != 0) {
        # people find the most curious tar binaries that cannot handle
        # pipes
        if ($is_compressed) {
            (my $ungzf = $file) =~ s/\.gz(?!\n)\Z//;
            if (CPAN::Tarzip->gunzip($file, $ungzf)) {
                $CPAN::Frontend->myprint(qq{Uncompressed $file successfully\n});
            } else {
                $CPAN::Frontend->mydie(qq{Couldn\'t uncompress $file\n});
            }
            $file = $ungzf;
        }
        $system = "$CPAN::Config->{tar} xvf $file";
        $CPAN::Frontend->myprint(qq{Using Tar:$system:\n});
        if (system($system)==0) {
            $CPAN::Frontend->myprint(qq{Untarred $file successfully\n});
        } else {
            $CPAN::Frontend->mydie(qq{Couldn\'t untar $file\n});
        }
        return 1;
    } else {
        return 1;
    }
  } elsif ($prefer==2) { # 2 => modules
    my $tar = Archive::Tar->new($file,1);
    my $af; # archive file
    my @@af;
    if ($BUGHUNTING) {
        # RCS 1.337 had this code, it turned out unacceptable slow but
        # it revealed a bug in Archive::Tar. Code is only here to hunt
        # the bug again. It should never be enabled in published code.
        # GDGraph3d-0.53 was an interesting case according to Larry
        # Virden.
        warn(">>>Bughunting code enabled<<< " x 20);
        for $af ($tar->list_files) {
            if ($af =~ m!^(/|\.\./)!) {
                $CPAN::Frontend->mydie("ALERT: Archive contains ".
                                       "illegal member [$af]");
            }
            $CPAN::Frontend->myprint("$af\n");
            $tar->extract($af); # slow but effective for finding the bug
            return if $CPAN::Signal;
        }
    } else {
        for $af ($tar->list_files) {
            if ($af =~ m!^(/|\.\./)!) {
                $CPAN::Frontend->mydie("ALERT: Archive contains ".
                                       "illegal member [$af]");
            }
            $CPAN::Frontend->myprint("$af\n");
            push @@af, $af;
            return if $CPAN::Signal;
        }
        $tar->extract(@@af);
    }
a10274 2
    Mac::BuildTools::convert_files([$tar->list_files], 1)
        if ($^O eq 'MacOS');
d10276 1
a10276 3
    return 1;
  }
}
d10278 1
a10278 30
sub unzip {
    my($class,$file) = @@_;
    if ($CPAN::META->has_inst("Archive::Zip")) {
        # blueprint of the code from Archive::Zip::Tree::extractTree();
        my $zip = Archive::Zip->new();
        my $status;
        $status = $zip->read($file);
        die "Read of file[$file] failed\n" if $status != Archive::Zip::AZ_OK();
        $CPAN::META->debug("Successfully read file[$file]") if $CPAN::DEBUG;
        my @@members = $zip->members();
        for my $member ( @@members ) {
            my $af = $member->fileName();
            if ($af =~ m!^(/|\.\./)!) {
                $CPAN::Frontend->mydie("ALERT: Archive contains ".
                                       "illegal member [$af]");
            }
            my $status = $member->extractToFileNamed( $af );
            $CPAN::META->debug("af[$af]status[$status]") if $CPAN::DEBUG;
            die "Extracting of file[$af] from zipfile[$file] failed\n" if
                $status != Archive::Zip::AZ_OK();
            return if $CPAN::Signal;
        }
        return 1;
    } else {
        my $unzip = $CPAN::Config->{unzip} or
            $CPAN::Frontend->mydie("Cannot unzip, no unzip program available");
        my @@system = ($unzip, $file);
        return system(@@system) == 0;
    }
}
d10280 1
d10282 1
a10282 6
package CPAN::Version;
# CPAN::Version::vcmp courtesy Jost Krieger
sub vcmp {
  my($self,$l,$r) = @@_;
  local($^W) = 0;
  CPAN->debug("l[$l] r[$r]") if $CPAN::DEBUG;
d10284 1
a10284 8
  return 0 if $l eq $r; # short circuit for quicker success

  if ($l=~/^v/ <=> $r=~/^v/) {
      for ($l,$r) {
          next if /^v/;
          $_ = $self->float2vv($_);
      }
  }
d10286 1
a10286 63
  return
      ($l ne "undef") <=> ($r ne "undef") ||
          ($] >= 5.006 &&
           $l =~ /^v/ &&
           $r =~ /^v/ &&
           $self->vstring($l) cmp $self->vstring($r)) ||
               $l <=> $r ||
                   $l cmp $r;
}

sub vgt {
  my($self,$l,$r) = @@_;
  $self->vcmp($l,$r) > 0;
}

sub vstring {
  my($self,$n) = @@_;
  $n =~ s/^v// or die "CPAN::Version::vstring() called with invalid arg [$n]";
  pack "U*", split /\./, $n;
}

# vv => visible vstring
sub float2vv {
    my($self,$n) = @@_;
    my($rev) = int($n);
    $rev ||= 0;
    my($mantissa) = $n =~ /\.(\d{1,12})/; # limit to 12 digits to limit
                                          # architecture influence
    $mantissa ||= 0;
    $mantissa .= "0" while length($mantissa)%3;
    my $ret = "v" . $rev;
    while ($mantissa) {
        $mantissa =~ s/(\d{1,3})// or
            die "Panic: length>0 but not a digit? mantissa[$mantissa]";
        $ret .= ".".int($1);
    }
    # warn "n[$n]ret[$ret]";
    $ret;
}

sub readable {
  my($self,$n) = @@_;
  $n =~ /^([\w\-\+\.]+)/;

  return $1 if defined $1 && length($1)>0;
  # if the first user reaches version v43, he will be treated as "+".
  # We'll have to decide about a new rule here then, depending on what
  # will be the prevailing versioning behavior then.

  if ($] < 5.006) { # or whenever v-strings were introduced
    # we get them wrong anyway, whatever we do, because 5.005 will
    # have already interpreted 0.2.4 to be "0.24". So even if he
    # indexer sends us something like "v0.2.4" we compare wrongly.

    # And if they say v1.2, then the old perl takes it as "v12"

    $CPAN::Frontend->mywarn("Suspicious version string seen [$n]\n");
    return $n;
  }
  my $better = sprintf "v%vd", $n;
  CPAN->debug("n[$n] better[$better]") if $CPAN::DEBUG;
  return $better;
}
d10288 1
a10288 1
package CPAN;
d10290 1
a10290 1
1;
d10292 1
a10292 1
__END__
d10294 1
a10294 1
=head1 NAME
d10296 1
a10296 1
CPAN - query, download and build perl modules from CPAN sites
d10298 1
a10298 1
=head1 SYNOPSIS
d10300 1
a10300 1
Interactive mode:
d10302 1
a10302 1
  perl -MCPAN -e shell;
d10304 2
a10305 1
Batch mode:
d10307 1
a10307 1
  use CPAN;
d10309 2
a10310 1
  autobundle, clean, install, make, recompile, test
d10312 1
a10312 1
=head1 STATUS
d10314 4
a10317 7
This module will eventually be replaced by CPANPLUS. CPANPLUS is kind
of a modern rewrite from ground up with greater extensibility and more
features but no full compatibility. If you're new to CPAN.pm, you
probably should investigate if CPANPLUS is the better choice for you.
If you're already used to CPAN.pm you're welcome to continue using it,
if you accept that its development is mostly (though not completely)
stalled.
d10321 7
a10327 8
The CPAN module is designed to automate the make and install of perl
modules and extensions. It includes some primitive searching capabilities and
knows how to use Net::FTP or LWP (or lynx or an external ftp client)
to fetch the raw data from the net.

Modules are fetched from one or more of the mirrored CPAN
(Comprehensive Perl Archive Network) sites and unpacked in a dedicated
directory.
d10333 5
a10337 14
The package contains a session manager and a cache manager. There is
no status retained between sessions. The session manager keeps track
of what has been fetched, built and installed in the current
session. The cache manager keeps track of the disk space occupied by
the make processes and deletes excess space according to a simple FIFO
mechanism.

For extended searching capabilities there's a plugin for CPAN available,
L<C<CPAN::WAIT>|CPAN::WAIT>. C<CPAN::WAIT> is a full-text search engine
that indexes all documents available in CPAN authors directories. If
C<CPAN::WAIT> is installed on your system, the interactive shell of
CPAN.pm will enable the C<wq>, C<wr>, C<wd>, C<wl>, and C<wh> commands
which send queries to the WAIT server that has been configured for your
installation.
d10339 1
a10339 1
All other methods provided are accessible in a programmer style and in an
d10342 1
a10342 1
=head2 Interactive Mode
d10348 7
a10354 3
which puts you into a readline interface. You will have the most fun if
you install Term::ReadKey and Term::ReadLine to enjoy both history and
command completion.
d10356 2
a10357 2
Once you are on the command line, type 'h' and the rest should be
self-explanatory.
d10384 1
a10384 1
<as_glimpse>.
d10386 1
a10386 1
=item make, test, install, clean  modules or distributions
d10393 5
a10397 2
the module's Makefile.PL (this behavior is controlled by
I<prerequisites_policy>.)
d10413 10
a10422 3
succeeded or not. The C<force> command takes as a first argument the
method to invoke (currently: C<make>, C<test>, or C<install>) and executes the
command from scratch.
d10426 1
a10426 7
    cpan> install OpenGL
    OpenGL is up to date.
    cpan> force install OpenGL
    Running make
    OpenGL-0.4/
    OpenGL-0.4/COPYRIGHT
    [...]
d10434 67
a10500 1
=item get, readme, look module or distribution
d10502 16
a10517 11
C<get> downloads a distribution file without further action. C<readme>
displays the README file of the associated distribution. C<Look> gets
and untars (if not yet done) the distribution file, changes to the
appropriate directory and opens a subshell process in that directory.

=item ls author

C<ls> lists all distribution files in and below an author's CPAN
directory. Only those files that contain modules are listed and if
there is more than one for any given module, only the most recent one
is listed.
d10526 763
a11288 1
pressing C<^C> twice.
d11290 2
a11291 2
CPAN.pm ignores a SIGPIPE. If the user sets inactivity_timeout, a
SIGALRM is used during the run of the C<perl Makefile.PL> subprocess.
d11295 14
a11308 1
=head2 CPAN::Shell
d11310 1
a11310 7
The commands that are available in the shell interface are methods in
the package CPAN::Shell. If you enter the shell command, all your
input is split by the Text::ParseWords::shellwords() routine which
acts like most shells do. The first word is being interpreted as the
method to be called and the rest of the words are treated as arguments
to this method. Continuation lines are supported if a line ends with a
literal backslash.
d11312 2
a11313 1
=head2 autobundle
d11315 4
a11318 5
C<autobundle> writes a bundle file into the
C<$CPAN::Config-E<gt>{cpan_home}/Bundle> directory. The file contains
a list of all modules that are both available from CPAN and currently
installed within @@INC. The name of the bundle file is based on the
current date and a counter.
d11320 4
a11323 1
=head2 recompile
d11325 5
a11329 11
recompile() is a very special command in that it takes no argument and
runs the make/test/install cycle with brute force over all installed
dynamically loadable extensions (aka XS modules) with 'force' in
effect. The primary purpose of this command is to finish a network
installation. Imagine, you have a common source tree for two different
architectures. You decide to do a completely independent fresh
installation. You start on one architecture with the help of a Bundle
file produced earlier. CPAN installs the whole Bundle for you, but
when you try to repeat the job on the second architecture, CPAN
responds with a C<"Foo up to date"> message for all modules. So you
invoke CPAN's recompile on the second architecture and you're done.
d11331 2
a11332 4
Another popular use for C<recompile> is to act as a rescue in case your
perl breaks binary compatibility. If one of the modules that CPAN uses
is in turn depending on binary compatibility (so you cannot run CPAN
commands), then you should try the CPAN::Nox module for recovery.
d11334 10
a11343 1
=head2 The four C<CPAN::*> Classes: Author, Bundle, Module, Distribution
d11345 1
a11345 7
Although it may be considered internal, the class hierarchy does matter
for both users and programmer. CPAN.pm deals with above mentioned four
classes, and all those classes share a set of methods. A classical
single polymorphism is in effect. A metaclass object registers all
objects of all kinds and indexes them with a string. The strings
referencing objects have a separated namespace (well, not completely
separated):
d11347 1
a11347 1
         Namespace                         Class
d11349 1
a11349 3
   words containing a "/" (slash)      Distribution
    words starting with Bundle::          Bundle
          everything else            Module or Author
d11351 1
a11351 8
Modules know their associated Distribution objects. They always refer
to the most recent official release. Developers may mark their releases
as unstable development versions (by inserting an underbar into the
module version number which will also be reflected in the distribution
name when you run 'make dist'), so the really hottest and newest 
distribution is not always the default.  If a module Foo circulates 
on CPAN in both version 1.23 and 1.23_90, CPAN.pm offers a convenient 
way to install version 1.23 by saying
d11353 4
a11356 1
    install Foo
d11358 1
a11358 6
This would install the complete distribution file (say
BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would
like to install version 1.23_90, you need to know where the
distribution file resides on CPAN relative to the authors/id/
directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz;
so you would have to say
d11360 1
a11360 1
    install BAR/Foo-1.23_90.tar.gz
d11362 12
a11373 2
The first example will be driven by an object of the class
CPAN::Module, the second by an object of class CPAN::Distribution.
d11375 1
a11375 1
=head2 Programmer's interface
d11379 8
a11386 1
functions in the calling package (C<install(...)>).
d11409 2
a11410 1
CPAN::Distribution objects fro distributions.
d11421 2
a11422 3
    for $mod (qw(Net::FTP Digest::MD5 Data::Dumper)){
        my $obj = CPAN::Shell->expand('Module',$mod);
        $obj->install;
d11426 2
a11427 2
    for $mod (CPAN::Shell->expand("Module","/./")){
	next unless $mod->inst_file;
d11429 2
a11430 2
	next unless $mod->inst_version eq "undef";
	print "No VERSION in ", $mod->id, "\n";
d11450 1
a11450 1
  for $mod (CPAN::Shell->expand("Module","/./")){
d11460 1
a11460 1
  for $mod (CPAN::Shell->expand("Module","/Apache|LWP|CGI/")){
a11474 6
The programming interface for the classes CPAN::Module,
CPAN::Distribution, CPAN::Bundle, and CPAN::Author is still considered
beta and partially even alpha. In the following paragraphs only those
methods are documented that have proven useful over a longer time and
thus are unlikely to change.

d11516 7
a11522 6
Forces CPAN to perform a task that normally would have failed. Force
takes as arguments a method name to be called and any number of
additional arguments that should be passed to the called method. The
internals of the object get the needed changes so that CPAN.pm does
not refuse to take the action. The C<force> is passed recursively to
all contained objects.
d11566 15
d11608 6
a11613 5
Forces CPAN to perform a task that normally would have failed. Force
takes as arguments a method name to be called and any number of
additional arguments that should be passed to the called method. The
internals of the object get the needed changes so that CPAN.pm does
not refuse to take the action.
d11630 11
d11648 5
d11663 23
a11685 1
Makefile.PL> and C<make> there.
d11690 7
a11696 3
as the PREREQ_PM hash in the Makefile.PL. Note: works only after an
attempt has been made to C<make> the distribution. Returns undef
otherwise.
d11703 13
d11732 1
a11732 1
Reloads all indices if they have been read more than
d11744 7
a11750 1
Returns a one-line description of the module
d11778 60
d11840 6
a11845 5
Forces CPAN to perform a task that normally would have failed. Force
takes as arguments a method name to be called and any number of
additional arguments that should be passed to the called method. The
internals of the object get the needed changes so that CPAN.pm does
not refuse to take the action.
d11857 7
d11866 5
a11870 1
Returns the version number of the module in readable format.
d11893 4
d11901 4
d11947 1
a11947 1
	=head1 CONTENTS
d11969 1
a11969 1
=head2 Prerequisites
d11981 2
d12006 2
a12007 2
Makefile.PL (well, we try to handle a bit more, but without much
enthusiasm).
d12018 39
a12056 7
For code debugging in interactive mode you can try "o debug" which
will list options for debugging the various parts of the code. You
should know that "o debug" has built-in completion support.

For data debugging there is the C<dump> command which takes the same
arguments as make/test/install and outputs the object's Data::Dumper
dump.
d12069 1
a12069 57
=head1 CONFIGURATION

When the CPAN module is used for the first time, a configuration
dialog tries to determine a couple of site specific options. The
result of the dialog is stored in a hash reference C< $CPAN::Config >
in a file CPAN/Config.pm.

The default values defined in the CPAN/Config.pm file can be
overridden in a user specific file: CPAN/MyConfig.pm. Such a file is
best placed in $HOME/.cpan/CPAN/MyConfig.pm, because $HOME/.cpan is
added to the search path of the CPAN module before the use() or
require() statements.

The configuration dialog can be started any time later again by
issueing the command C< o conf init > in the CPAN shell.

Currently the following keys in the hash reference $CPAN::Config are
defined:

  build_cache        size of cache for directories to build modules
  build_dir          locally accessible directory to build modules
  index_expire       after this many days refetch index files
  cache_metadata     use serializer to cache metadata
  cpan_home          local directory reserved for this package
  dontload_hash      anonymous hash: modules in the keys will not be
                     loaded by the CPAN::has_inst() routine
  gzip		     location of external program gzip
  histfile           file to maintain history between sessions
  histsize           maximum number of lines to keep in histfile
  inactivity_timeout breaks interactive Makefile.PLs after this
                     many seconds inactivity. Set to 0 to never break.
  inhibit_startup_message
                     if true, does not print the startup message
  keep_source_where  directory in which to keep the source (if we do)
  make               location of external make program
  make_arg	     arguments that should always be passed to 'make'
  make_install_arg   same as make_arg for 'make install'
  makepl_arg	     arguments passed to 'perl Makefile.PL'
  pager              location of external program more (or any pager)
  prerequisites_policy
                     what to do if you are missing module prerequisites
                     ('follow' automatically, 'ask' me, or 'ignore')
  proxy_user         username for accessing an authenticating proxy
  proxy_pass         password for accessing an authenticating proxy
  scan_cache	     controls scanning of cache ('atstart' or 'never')
  tar                location of external program tar
  term_is_latin      if true internal UTF-8 is translated to ISO-8859-1
                     (and nonsense for characters outside latin range)
  unzip              location of external program unzip
  urllist	     arrayref to nearby CPAN sites (or equivalent locations)
  wait_list          arrayref to a wait server to try (See CPAN::WAIT)
  ftp_proxy,      }  the three usual variables for configuring
    http_proxy,   }  proxy requests. Both as CPAN::Config variables
    no_proxy      }  and as environment variables configurable.

You can set and query each of these options interactively in the cpan
shell with the command set defined within the C<o conf> command:
d12073 1
a12073 5
=item C<o conf E<lt>scalar optionE<gt>>

prints the current value of the I<scalar option>

=item C<o conf E<lt>scalar optionE<gt> E<lt>valueE<gt>>
d12075 6
a12080 1
Sets the value of the I<scalar option> to I<value>
d12082 1
a12082 1
=item C<o conf E<lt>list optionE<gt>>
d12084 1
a12084 2
prints the current value of the I<list option> in MakeMaker's
neatvalue format.
d12086 1
a12086 1
=item C<o conf E<lt>list optionE<gt> [shift|pop]>
d12088 3
a12090 1
shifts or pops the array in the I<list option> variable
d12092 1
a12092 1
=item C<o conf E<lt>list optionE<gt> [unshift|push|splice] E<lt>listE<gt>>
d12094 3
a12096 1
works like the corresponding perl commands.
d12100 1
a12100 1
=head2 Note on urllist parameter's format
d12102 4
a12105 7
urllist parameters are URLs according to RFC 1738. We do a little
guessing if your URL is not compliant, but if you have problems with
file URLs, please try the correct format. Either:

    file://localhost/whatever/ftp/pub/CPAN/

or
d12107 1
a12107 12
    file:///home/ftp/pub/CPAN/

=head2 urllist parameter has CD-ROM support

The C<urllist> parameter of the configuration table contains a list of
URLs that are to be used for downloading. If the list contains any
C<file> URLs, CPAN always tries to get files from there first. This
feature is disabled for index files. So the recommendation for the
owner of a CD-ROM with CPAN contents is: include your local, possibly
outdated CD-ROM as a C<file> URL at the end of urllist, e.g.

  o conf urllist push file://localhost/CDROM/CPAN
d12109 5
a12113 3
CPAN.pm will then fetch the index files from one of the CPAN sites
that come at the beginning of urllist. It will later check for each
module if there is a local copy of the most recent version.
d12115 3
a12117 7
Another peculiarity of urllist is that the site that we could
successfully fetch the last file from automatically gets a preference
token and is tried as the first site for the next request. So if you
add a new site at runtime it may happen that the previously preferred
site will be tried another time. This means that if you want to disallow
a site for the next transfer, it must be explicitly removed from
urllist.
d12119 2
a12120 1
=head1 SECURITY
d12122 2
a12123 6
There's no strong security layer in CPAN.pm. CPAN.pm helps you to
install foreign, unmasked, unsigned code on your machine. We compare
to a checksum that comes from the net just as the distribution file
itself. If somebody has managed to tamper with the distribution file,
they may have as well tampered with the CHECKSUMS file. Future
development will go towards strong authentication.
d12131 23
d12184 1
a12184 1
further informations on firewalls, it is recommended to consult the
d12242 3
a12244 9
For accessing ftp servers behind such firewalls you may need to set
the environment variable C<FTP_PASSIVE> to a true value, e.g.

    env FTP_PASSIVE=1 perl -MCPAN -eshell

or

    perl -MCPAN -e '$ENV{FTP_PASSIVE} = 1; shell'

d12329 19
a12347 1
You will most probably like something like this:
d12351 12
a12362 2
                    INSTALLMAN3DIR=~/myperl/man/man3"
  install Sybase::Sybperl
d12365 1
a12365 1
C<o conf commit>.
d12375 8
a12382 2
Another thing you should bear in mind is that the UNINST parameter
should never be set if you are not root.
d12388 1
a12388 1
  look Sybase::Sybperl
d12398 11
a12408 12
install, it just uses data found in the generated Makefile. An
undetected missing piece breaks the process. But it may well be that
your Bundle installs some prerequisite later than some depending item
and thus your second try is able to resolve everything. Please note,
CPAN.pm does not know the dependency tree in advance and cannot sort
the queue of things to install in a topologically correct order. It
resolves perfectly well IFF all modules declare the prerequisites
correctly with the PREREQ_PM attribute to MakeMaker. For bundles which
fail and you need to install often, it is recommended sort the Bundle
definition file manually. It is planned to improve the metadata
situation for dependencies on CPAN in general, but this will still
take some time.
d12420 2
a12421 2
When I run CPAN's shell, I get error msg about line 1 to 4,
setting meta input/output via the /etc/inputrc file.
d12423 5
a12427 4
Some versions of readline are picky about capitalization in the
/etc/inputrc file and specifically RedHat 6.2 comes with a
/etc/inputrc that contains the word C<on> in lowercase. Change the
occurrences of C<on> to C<On> and the bug should disappear.
d12438 27
a12464 1
    cpan> ! $CPAN::Config->{term_is_latin}=1
d12466 55
a12520 2
Extended support for converters will be made available as soon as perl
becomes stable with regard to charset issues.
d12524 28
d12554 6
a12559 12
We should give coverage for B<all> of the CPAN and not just the PAUSE
part, right? In this discussion CPAN and PAUSE have become equal --
but they are not. PAUSE is authors/, modules/ and scripts/. CPAN is
PAUSE plus the clpa/, doc/, misc/, ports/, and src/.

Future development should be directed towards a better integration of
the other parts.

If a Makefile.PL requires special customization of libraries, prompts
the user for special input, etc. then you may find CPAN is not able to
build the distribution. In that case, you should attempt the
traditional method of building a Perl module package from a shell.
d12563 8
a12570 1
Andreas Koenig E<lt>andreas.koenig@@anima.deE<gt>
d12575 1
a12575 1
http://member.nifty.ne.jp/hippo2000/perltips/CPAN.htm
d12579 1
a12579 1
perl(1), CPAN::Nox(3)
d12582 1
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
$VERSION = '1.76_01';
d5 1
a5 1
# $Id: CPAN.pm,v 1.412 2003/07/31 14:53:04 k Exp $
d9 1
a9 1
# $Revision = "[".substr(q$Revision: 1.412 $, 10)."]";
a741 1
    $file =~ s|/|\\|g if $^O eq 'MSWin32';
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 3
a5 2
$VERSION = '1.61';
# $Id: CPAN.pm,v 1.390 2002/05/07 10:04:58 k Exp $
d9 1
a9 1
# $Revision = "[".substr(q$Revision: 1.390 $, 10)."]";
d116 14
d285 22
d805 2
a806 8
  if (
      0 &&           # disabled, try reload cpan with it
      $] > 5.004_60  # thereabouts
     ) {
    $ineval = $^S;
  } else {
    my($subroutine);
    while ((undef,undef,undef,$subroutine) = caller(++$i)) {
a808 1
    }
d811 4
a814 3
  return unless defined $META->{LOCK}; # unsafe meta access, ok
  return unless -f $META->{LOCK}; # unsafe meta access, ok
  unlink $META->{LOCK}; # unsafe meta access, ok
d820 26
d1400 1
a1400 1
            $CPAN::Frontend->mywarn("ls command rejects argument $_: not an author");
d1449 2
a1450 1
    $CPAN::Frontend->myprint(shift->format_result('Module',@@_));
d1571 1
a1571 1
	if ( $_[0] =~ /[Ss]ubroutine (\w+) redefined/ ) {
d1589 11
a1599 8
	CPAN->debug("reloading the whole CPAN.pm") if $CPAN::DEBUG;
	my $fh = FileHandle->new($INC{'CPAN.pm'});
	local($/);
	my $redef = 0;
	local($SIG{__WARN__}) = paintdots_onreload(\$redef);
	eval <$fh>;
	warn $@@ if $@@;
	$CPAN::Frontend->myprint("\n$redef subroutines redefined\n");
d1993 2
d2086 2
a2087 2
            if ($meth eq "dump") {
                $obj->dump;
d2191 1
a2191 1
        defined $CPAN::Config->{proxy_pass}) {
d2216 15
d2354 1
a2354 1
                $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@")
d2381 3
a2383 4
    $ENV{ftp_proxy} = $CPAN::Config->{ftp_proxy} if $CPAN::Config->{ftp_proxy};
    $ENV{http_proxy} = $CPAN::Config->{http_proxy}
        if $CPAN::Config->{http_proxy};
    $ENV{no_proxy} = $CPAN::Config->{no_proxy} if $CPAN::Config->{no_proxy};
d2504 1
a2504 1
                  $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@");
d2709 1
d2711 1
a2711 1
	unless (length $CPAN::Config->{'ftp'}) {
d2736 1
a2736 1
	     map("cd $_", split "/", $dir), # RFC 1738
d2756 1
a2756 1
		$self->talk_ftp("$CPAN::Config->{'ftp'}$verbose $host",
d2781 1
a2781 1
	$CPAN::Frontend->myprint(qq{Issuing "$CPAN::Config->{'ftp'}$verbose -n"\n});
d2787 1
a2787 1
	$self->talk_ftp("$CPAN::Config->{'ftp'}$verbose -n", @@dialog);
d3332 1
a3332 1
	    $userid = $self->userid($dist);
d3432 1
a3432 1
    $CPAN::Frontend->mywarn($@@) if $@@;
d3445 1
a3445 1
    $CPAN::Frontend->mywarn($@@) if $@@;
d3453 1
a3453 1
                                            "with protocol v%s, requiring v%s",
d3461 1
a3461 1
                                "with protocol v1.0");
d3498 5
a3502 1
sub cpan_userid { shift->{RO}{CPAN_USERID} }
d3761 1
a3761 1
            $CPAN::Frontend->mywarn("Strange distribution name [$s]");
d3772 1
d3777 4
a3780 7
    $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: deep recursion in ".
                                   "color_cmd_tmps depth[%s] self[%s] id[%s]",
                                   $depth,
                                   $self,
                                   $self->id
                                  )) if $depth>=100;
    ##### warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
d3785 1
a3785 1
            $premo->color_cmd_tmps($depth+1,$color);
d3872 1
a3872 1
			    split("/",$self->id)
d3980 1
a3980 1
    $self->safe_chdir(File::Spec->updir);
d4125 4
a4128 2
    system($CPAN::Config->{'shell'}) == 0
	or $CPAN::Frontend->mydie("Subprocess shell error");
d4144 1
a4144 1
    my $cvs_dir = (split '/', $dir)[-1];
d4181 1
a4181 1
			     split("/","$sans.readme"),
d4219 1
a4219 1
    @@local = split("/",$self->id);
d4603 1
d4885 1
a4885 4
    $CPAN::Frontend->myprint(
                             qq{ look() commmand on bundles not}.
                             qq{ implemented (What should it do?)}
                            );
d4902 1
d4908 4
a4911 7
    $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: deep recursion in ".
                                   "color_cmd_tmps depth[%s] self[%s] id[%s]",
                                   $depth,
                                   $self,
                                   $self->id
                                  )) if $depth>=100;
    ##### warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
d4916 1
a4916 1
        $obj->color_cmd_tmps($depth+1,$color);
d5206 1
a5206 1
# sub cpan_userid { shift->{RO}{CPAN_USERID} }
d5210 1
a5210 1
    return $self->{RO}{CPAN_USERID} || $self->{RO}{userid};
d5212 1
d5228 1
d5233 4
a5236 7
    $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: deep recursion in ".
                                   "color_cmd_tmps depth[%s] self[%s] id[%s]",
                                   $depth,
                                   $self,
                                   $self->id
                                  )) if $depth>=100;
    ##### warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
d5239 1
a5239 1
        $dist->color_cmd_tmps($depth+1,$color);
d5278 1
a5278 1
    CPAN->debug($self) if $CPAN::DEBUG;
d5288 2
a5289 1
    if ($userid = $self->cpan_userid || $self->userid){
d5313 2
a5314 2
    @@stats{qw,? m d u n,}       = qw,unknown mailing-list
	developer comp.lang.perl.* none,;
d5446 1
a5446 1
                return "UserID $userid";
d5553 7
d5982 1
a5982 1
    $CPAN::Frontend->mywarn("Suspicious version string seen [$n]");
d6012 10
d6025 1
a6025 1
modules and extensions. It includes some searching capabilities and
d6746 13
a6758 6
When the CPAN module is installed, a site wide configuration file is
created as CPAN/Config.pm. The default values defined there can be
overridden in another configuration file: CPAN/MyConfig.pm. You can
store this file in $HOME/.cpan/CPAN/MyConfig.pm if you want, because
$HOME/.cpan is added to the search path of the CPAN module before the
use() or require() statements.
d6771 2
d6964 10
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 2
a4 2
$VERSION = '1.59_54';
# $Id: CPAN.pm,v 1.385 2001/02/09 21:37:57 k Exp $
d8 1
a8 1
# $Revision = "[".substr(q$Revision: 1.385 $, 10)."]";
d25 1
d29 2
d460 1
a460 1
    my $lockfile = MM->catfile($CPAN::Config->{cpan_home},".lock");
d464 2
a465 1
	my $other = <$fh>;
d467 16
a482 3
	if (defined $other && $other) {
	    chomp $other;
	    return if $$==$other; # should never happen
d485 1
a485 1
There seems to be running another CPAN process ($other). Contacting...
d487 1
a487 1
	    if (kill 0, $other) {
d490 1
a490 1
    kill $other
d510 1
a510 1
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile $lockfile ".
d512 1
a512 1
                                           "$other. Cannot proceed.\n"));
d553 1
a553 1
	    my $myincc = MM->catfile($ENV{HOME},'.cpan','CPAN','MyConfig.pm');
d576 1
d733 1
a733 1
    } elsif ($mod eq "MD5"){
d735 2
a736 2
  CPAN: MD5 security checks disabled because MD5 not installed.
  Please consider installing the MD5 module.
d789 23
d865 1
a865 1
	    push @@entries, MM->catfile($dir,$_);
d867 1
a867 1
	    push @@entries, MM->catdir($dir,$_);
d1137 30
d1175 1
a1175 1
      unshift @@INC, MM->catdir($ENV{HOME},".cpan");
d1194 2
a1195 2
	my($configpmdir) = MM->catdir($path_to_cpan,"CPAN");
	my($configpmtest) = MM->catfile($configpmdir,"Config.pm");
d1197 1
a1197 15
	    if (-w $configpmtest) {
		$configpm = $configpmtest;
	    } elsif (-w $configpmdir) {
		#_#_# following code dumped core on me with 5.003_11, a.k.
		unlink "$configpmtest.bak" if -f "$configpmtest.bak";
		rename $configpmtest, "$configpmtest.bak" if -f $configpmtest;
		my $fh = FileHandle->new;
		if ($fh->open(">$configpmtest")) {
		    $fh->print("1;\n");
		    $configpm = $configpmtest;
		} else {
		    # Should never happen
		    Carp::confess("Cannot open >$configpmtest");
		}
	    }
d1200 1
a1200 1
	    $configpmdir = MM->catdir($ENV{HOME},".cpan","CPAN");
d1202 3
a1204 14
	    $configpmtest = MM->catfile($configpmdir,"MyConfig.pm");
	    if (-w $configpmtest) {
		$configpm = $configpmtest;
	    } elsif (-w $configpmdir) {
		#_#_# following code dumped core on me with 5.003_11, a.k.
		my $fh = FileHandle->new;
		if ($fh->open(">$configpmtest")) {
		    $fh->print("1;\n");
		    $configpm = $configpmtest;
		} else {
		    # Should never happen
		    Carp::confess("Cannot open >$configpmtest");
		}
	    } else {
d1361 1
a1361 1
            $bdir = MM->catdir($incdir,split /::/, $bbase);
d1367 1
a1367 1
                    if (-d MM->catdir($bdir,$entry)){
d1724 1
a1724 1
    my($todir) = MM->catdir($CPAN::Config->{'cpan_home'},"Bundle");
d1735 1
a1735 1
    my($to) = MM->catfile($todir,"$me.pm");
d1738 1
a1738 1
	$to = MM->catfile($todir,"$me.pm");
d2119 1
a2119 1
        $CPAN::Frontent->mywarn("LWP::UserAgent not available\n");
d2276 1
a2276 1
                $CPAN::Frontent->mywarn("CPAN::LWP::UserAgent->new dies with $@@")
d2312 3
d2427 1
a2427 1
                  $CPAN::Frontent->mywarn("CPAN::LWP::UserAgent->new dies with $@@");
d2559 1
a2559 1
	      "$chdir$funkyftp$src_switch '$url' $devnull$stdout_redir";
d2592 1
a2592 1
	    my($system) = "$funkyftp$src_switch '$url.gz' $devnull > $asl_gz";
d2810 1
a2810 1
    my $file = MM->catfile($ENV{HOME},".netrc");
d3075 2
a3076 2
    my $abs_wanted = MM->catfile($CPAN::Config->{'keep_source_where'},
				   $localname);
d3348 1
a3348 1
    my $metadata_file = MM->catfile($CPAN::Config->{cpan_home},"Metadata");
d3362 1
a3362 1
    my $metadata_file = MM->catfile($CPAN::Config->{cpan_home},"Metadata");
d3412 2
a3413 1
    $CPAN::Frontend->myprint("  Database was generated on $DATE_OF_02\n");
d3594 2
a3595 2
	MM->catfile($CPAN::Config->{keep_source_where},
                    "authors", "id", @@$chksumfile);
d3788 6
a3793 6
        MM->catfile(
                    $CPAN::Config->{keep_source_where},
                    "authors",
                    "id",
                    split("/",$self->id)
                   );
d3813 2
a3814 2
    if ($CPAN::META->has_inst("MD5")) {
	$self->debug("MD5 is installed, verifying");
d3817 1
a3817 1
	$self->debug("MD5 is NOT installed");
d3862 1
a3862 1
        $packagedir = MM->catdir($builddir,$distdir);
d3885 1
a3885 1
        $packagedir = MM->catdir($builddir,$pragmatic_dir);
d3890 1
a3890 1
            my $to = MM->catdir($packagedir,$f);
d3903 1
a3903 1
    my($mpl) = MM->catfile($packagedir,"Makefile.PL");
d3920 1
a3920 1
        my($configure) = MM->catfile($packagedir,"Configure");
d3924 1
a3924 1
        } elsif (-f MM->catfile($packagedir,"Makefile")) {
d4016 1
a4016 1
      $self->ExtUtils::MM_MacOS::look;
d4095 6
a4100 6
	 MM->catfile(
			$CPAN::Config->{keep_source_where},
			"authors",
			"id",
			split("/","$sans.readme"),
		       );
d4107 1
a4107 1
        ExtUtils::MM_MacOS::launch_file($local_file);
d4141 2
a4142 2
	MM->catfile($CPAN::Config->{keep_source_where},
		      "authors", "id", @@local);
d4203 1
a4203 1
	  my $md5 = MD5->new;
d4262 1
a4262 1
    my $md5 = MD5->new;
d4331 1
a4331 1
    my($perl) = MM->file_name_is_absolute($^X) ? $^X : "";
d4333 1
a4333 1
    my $candidate = MM->catfile($pwd,$^X);
d4338 1
a4338 1
	    PATH_COMPONENT: foreach $component (MM->path(),
d4341 1
a4341 1
		  my($abs) = MM->catfile($component,$perl_name);
d4409 1
a4409 1
        ExtUtils::MM_MacOS::make($self);
d4470 1
a4470 1
	  # It's probably worth to record the reason, so let's retry
d4655 1
a4655 1
        ExtUtils::MM_MacOS::make_test($self);
d4659 2
d4664 1
d4689 1
a4689 1
        ExtUtils::MM_MacOS::make_clean($self);
d4764 1
a4764 1
        ExtUtils::MM_MacOS::make_install($self);
d4780 1
d4800 8
d4879 1
a4879 1
        $me = MM->catfile(@@me);
d4881 1
a4881 1
        $to = MM->catfile($todir,$me);
d4923 1
a4923 1
###    my $bu = MM->catfile($where,$what);
d4925 1
a4925 1
    my $manifest = MM->catfile($where,"MANIFEST");
d4939 1
a4939 1
      $what2 =~ tr|:|/|;
d4951 1
a4951 1
	    # return MM->catfile($where,$bu); # bad
d4959 1
a4959 1
    return MM->catfile($where, $bu) if $bu;
d4977 1
a4977 1
        my $bfile = MM->catfile($incdir, @@me);
d5270 1
a5270 1
                (-f  ($mff = MM->catfile($dist->{build_dir}, "MANIFEST")))
d5292 1
a5292 1
                my $lfl_abs = MM->catfile($dist->{build_dir},$lfl);
d5329 2
a5330 2
      $inpod = m/^=(?!head1\s+NAME)/ ? 0 :
	  m/^=head1\s+NAME/ ? 1 : $inpod;
d5487 1
a5487 1
	my $pmfile = MM->catfile($dir,@@packpath);
d5503 1
a5503 1
	my $xsfile = MM->catfile($dir,'auto',@@packpath);
d5537 1
a5537 1
    # Alt2 maintain it as what is is
d5786 1
a5786 1
    ExtUtils::MM_MacOS::convert_files([$tar->list_files], 1)
d6128 5
a6132 4
visible version number), so the really hottest and newest distribution
file is not always the default.  If a module Foo circulates on CPAN in
both version 1.23 and 1.23_90, CPAN.pm offers a convenient way to
install version 1.23 by saying
d6186 1
a6186 1
    for $mod (qw(Net::FTP MD5 Data::Dumper)){
d6247 1
a6247 1
=over
d6381 1
a6381 1
any case and if this fails, the install will be cancelled. The
d6468 1
a6468 1
Returns a 44 chracter description of this module. Only available for
d6500 1
a6500 1
Changes to the directory where the distribution assoicated with this
d6589 1
a6589 1
associated with an URL that is not C<ftp:>.
d6771 1
a6771 1
oneliners.
d6812 1
a6812 1
=over
d6820 1
a6820 1
you are running a http firewall.
d6827 1
a6827 1
This where the firewall machine runs a ftp server. This kind of
d6837 1
a6837 1
I say one way visibility as these firewalls try to make themselve look
d6846 1
a6846 1
=over
d6881 1
a6881 1
Your milage may vary...
d6885 1
a6885 1
=over
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d1 1
d3 2
a4 10
use vars qw{$Try_autoload
            $Revision
	    $META $Signal $Cwd $End
	    $Suppress_readline %Dontload
	    $Frontend  $Defaultsite
	   }; #};

$VERSION = '1.52';

# $Id: CPAN.pm,v 1.276 2000/01/08 15:29:46 k Exp $
d8 1
a8 1
# $Revision = "[".substr(q$Revision: 1.276 $, 10)."]";
d25 2
d45 2
a54 1
use vars qw($VERSION @@EXPORT $AUTOLOAD $DEBUG $META $term);
d57 4
a77 6
	my $ok = CPAN::Shell->try_dot_al($AUTOLOAD);
	if ($ok) {
	    goto &$AUTOLOAD;
#	} else {
#	    $CPAN::Frontend->mywarn("Could not autoload $AUTOLOAD");
	}
d90 4
a93 1
    my $prompt = "cpan> ";
d97 6
a102 2
#	import Term::ReadLine;
	$term = Term::ReadLine->new('CPAN Monitor');
a104 2
#	     $attribs->{completion_entry_function} =
#		 $attribs->{'list_completion_function'};
a107 3
#	    $attribs->{completion_word} =
#		[qw(help me somebody to find out how
#                    to use completion with GNU)];
d120 1
a120 1
    no strict;
d122 1
a122 3
    my $getcwd;
    $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    my $cwd = CPAN->$getcwd();
d127 1
a127 1
	    "available (try ``install Bundle::CPAN'')";
d130 3
a132 3
			     qq{
cpan shell -- CPAN exploration and modules installation (v$CPAN::VERSION$CPAN::Revision)
ReadLine support $rl_avail
d134 6
a139 1
}) unless $CPAN::Config->{'inhibit_startup_message'} ;
d141 1
a141 1
    while () {
d144 1
a144 1
	    last unless defined ($_ = <> );
d147 2
a148 1
	    last unless defined ($_ = $term->readline($prompt));
d152 1
a152 1
	next if /^$/;
d155 1
a155 1
	    last;
d170 1
a170 1
	    $prompt = "cpan> ";
d177 3
a179 1
		warn($@@), next if $@@;
d185 1
a185 1
	    chdir $cwd;
d188 1
a188 1
	    $prompt = "cpan> ";
d191 3
d202 2
a203 2
	    my $redef;
	    local($SIG{__WARN__}) = CPAN::Shell::dotdot_onreload(\$redef);
d207 1
d212 1
a219 1
import ExtUtils::MakeMaker 'neatvalue';
d232 4
d238 5
d245 1
a245 1
use vars qw($last_time $date_of_03);
d247 4
a250 2
$last_time ||= 0;
$date_of_03 ||= 0;
d268 1
a268 1
use vars qw($AUTOLOAD $redef @@ISA);
d270 2
a290 6
	my $ok = CPAN::Shell->try_dot_al($AUTOLOAD);
	if ($ok) {
	    goto &$AUTOLOAD;
#	} else {
#	    $CPAN::Frontend->mywarn("Could not autoload $autoload");
	}
a296 68
#-> CPAN::Shell::try_dot_al
sub try_dot_al {
    my($class,$autoload) = @@_;
    return unless $CPAN::Try_autoload;
    # I don't see how to re-use that from the AutoLoader...
    my($name,$ok);
    # Braces used to preserve $1 et al.
    {
	my ($pkg,$func) = $autoload =~ /(.*)::([^:]+)$/;
	$pkg =~ s|::|/|g;
	if (defined($name=$INC{"$pkg.pm"}))
	    {
		$name =~ s|^(.*)$pkg\.pm\z|$1auto/$pkg/$func.al|s;
		$name = undef unless (-r $name);
	    }
	unless (defined $name)
	    {
		$name = "auto/$autoload.al";
		$name =~ s|::|/|g;
	    }
    }
    my $save = $@@;
    eval {local $SIG{__DIE__};require $name};
    if ($@@) {
	if (substr($autoload,-9) eq '::DESTROY') {
	    *$autoload = sub {};
	    $ok = 1;
	} else {
	    if ($name =~ s{(\w{12,})\.al\z}{substr($1,0,11).".al"}e){
		eval {local $SIG{__DIE__};require $name};
	    }
	    if ($@@){
		$@@ =~ s/ at .*\n//;
		Carp::croak $@@;
	    } else {
		$ok = 1;
	    }
	}
    } else {

      $ok = 1;

    }
    $@@ = $save;
#    my $lm = Carp::longmess();
#    warn "ok[$ok] autoload[$autoload] longmess[$lm]"; # debug
    return $ok;
}

#### autoloader is experimental
#### to try it we have to set $Try_autoload and uncomment
#### the use statement and uncomment the __END__ below
#### You also need AutoSplit 1.01 available. MakeMaker will
#### then build CPAN with all the AutoLoad stuff.
# use AutoLoader;
# $Try_autoload = 1;

if ($CPAN::Try_autoload) {
  my $p;
    for $p (qw(
	       CPAN::Author CPAN::Bundle CPAN::CacheMgr CPAN::Complete
	       CPAN::Config CPAN::Debug CPAN::Distribution CPAN::FTP
	       CPAN::FTP::netrc CPAN::Index CPAN::InfoObj CPAN::Module
		 )) {
	*{"$p\::AUTOLOAD"} = \&AutoLoader::AUTOLOAD;
    }
}

d298 1
a298 1
use vars qw($AUTOLOAD @@ISA);
d300 1
d351 1
d353 2
a354 2
  my($class,$mod) = @@_;
  my $self = bless {mod => $mod}, $class;
a355 2
  # my @@all = map { $_->{mod} } @@All;
  # warn "Adding Queue object for mod[$mod] all[@@all]";
d359 1
d362 1
a362 1
  $obj->{mod};
d365 1
d370 1
a370 1
    if (  $All[$i]->{mod} eq $what ) {
d377 1
d379 6
a384 3
  my $class = shift;
  my @@what = @@_;
  my $obj;
d386 9
a394 8
    my $jumped = 0;
    for (my $i=0; $i<$#All;$i++) { #prevent deep recursion
      if ($All[$i]->{mod} eq $what){
	$jumped++;
	if ($jumped > 100) { # one's OK if e.g. just processing now;
                             # more are OK if user typed it several
                             # times
	  $CPAN::Frontend->mywarn(
d397 6
a402 3
	  next WHAT;
	}
      }
d404 4
a407 3
    my $obj = bless { mod => $what }, $class;
    unshift @@All, $obj;
  }
d410 1
d413 3
a415 3
  my @@all = map { $_->{mod} } @@All;
  my $exists = grep { $_->{mod} eq $what } @@All;
  # warn "Checking exists in Queue object for mod[$what] all[@@all] exists[$exists]";
d419 1
d422 1
a422 3
  @@All = grep { $_->{mod} ne $mod } @@All;
  # my @@all = map { $_->{mod} } @@All;
  # warn "Deleting Queue object for mod[$mod] all[@@all]";
d425 1
d436 2
a437 3
1;

# __END__ # uncomment this and AutoSplit version 1.01 will split it
d439 1
a439 18
#-> sub CPAN::autobundle ;
sub autobundle;
#-> sub CPAN::bundle ;
sub bundle;
#-> sub CPAN::expand ;
sub expand;
#-> sub CPAN::force ;
sub force;
#-> sub CPAN::install ;
sub install;
#-> sub CPAN::make ;
sub make;
#-> sub CPAN::clean ;
sub clean;
#-> sub CPAN::test ;
sub test;

#-> sub CPAN::all ;
d445 1
a445 1
    values %{ $META->{$class} };
d449 5
a453 1
# Called by shell, not in batch mode. Not clean XXX
d459 2
a460 1
	my $fh = FileHandle->new($lockfile);
d492 5
a496 1
	}
d561 1
a561 1
    $SIG{'TERM'} = sub {
d565 1
a565 1
    $SIG{'INT'} = sub {
d593 2
a594 1
    $SIG{'__DIE__'} = \&cleanup;
d603 7
d619 1
d623 2
a624 1
    exists $META->{$class}{$id};
d630 38
a667 1
  delete $META->{$class}{$id};
d675 8
a682 5
    if (defined $message && $message eq "no") {
	$Dontload{$mod}||=1;
	return 0;
    } elsif (exists $Dontload{$mod}) {
	return 0;
d708 1
a708 1
	warn qq{
d713 2
a714 2
};
	sleep 2;
d733 3
a735 1
    $META->{$class}{$id} ||= $class->new(ID => $id );
d763 3
a765 3
  return unless defined $META->{'LOCK'};
  return unless -f $META->{'LOCK'};
  unlink $META->{'LOCK'};
d788 1
d816 1
a816 3
    my $getcwd;
    $getcwd  = $CPAN::Config->{'getcwd'} || 'cwd';
    my($cwd) = CPAN->$getcwd();
d944 1
d946 1
a946 1
    my($class,@@args) = @@_;
d948 1
a948 1
    CPAN->debug("class[$class]args[".join(" | ",@@args)."]");
d952 1
a952 1
	$class->$o(@@args);
d955 2
a956 1
	if (ref($CPAN::Config->{$o}) eq ARRAY) {
d959 2
d964 1
d967 1
d970 1
d973 1
d976 1
d979 1
d981 1
a981 6
		$CPAN::Frontend->myprint(
					 join "",
					 "  $o  ",
					 ExtUtils::MakeMaker::neatvalue($CPAN::Config->{$o}),
					 "\n"
		     );
d983 6
d991 1
a991 3
	    $CPAN::Frontend->myprint("    $o    " .
				     (defined $CPAN::Config->{$o} ?
				      $CPAN::Config->{$o} : "UNDEFINED"));
d996 27
d1043 2
a1044 1
    my $msg = <<EOF unless $configpm =~ /MyConfig/;
d1055 2
a1056 1
    open $fh, ">$configpm" or warn "Couldn't open >$configpm: $!";
d1109 2
a1110 2
    return unless @@miss = $self->not_loaded;
    # XXX better check for arrayrefs too
d1177 2
a1178 2
#-> sub CPAN::Config::not_loaded ;
sub not_loaded {
d1180 9
a1188 6
    for (qw(
	    cpan_home keep_source_where build_dir build_cache scan_cache
	    index_expire gzip tar unzip make pager makepl_arg make_arg
	    make_install_arg urllist inhibit_startup_message
	    ftp_proxy http_proxy no_proxy prerequisites_policy
	   )) {
d1256 5
a1260 7
 a                                    authors
 b         string           display   bundles
 d         or               info      distributions
 m         /regex/          about     modules
 i         or                         anything of above
 r         none             reinstall recommendations
 u                          uninstalled distributions
d1265 2
a1266 2
 test      modules,         make test (implies make)
 install   dists, bundles   make install (implies test)
d1282 51
a1332 1
sub a { $CPAN::Frontend->myprint(shift->format_result('Author',@@_));}
d1337 1
a1337 12
    my($incdir,$bdir,$dh);
    foreach $incdir ($CPAN::Config->{'cpan_home'},@@INC) {
	$bdir = MM->catdir($incdir,"Bundle");
	if ($dh = DirHandle->new($bdir)) { # may fail
	    my($entry);
	    for $entry ($dh->read) {
		next if -d MM->catdir($bdir,$entry);
		next unless $entry =~ s/\.pm\z//;
		$CPAN::META->instance('CPAN::Bundle',"Bundle::$entry");
	    }
	}
    }
d1340 1
d1343 1
d1360 1
a1360 1
    my $result =  @@result == 1 ?
d1362 6
a1367 2
	    join "", map {$_->as_glimpse} @@result;
    $result ||= "No objects found of any type for argument @@args\n";
d1372 3
d1381 1
a1381 1
	if (!@@o_what) {
d1397 1
a1397 15
		$v = $CPAN::Config->{$k};
		if (ref $v) {
		    $CPAN::Frontend->myprint(
					     join(
						  "",
						  sprintf(
							  "    %-18s\n",
							  $k
							 ),
						  map {"\t$_\n"} @@{$v}
						 )
					    );
		} else {
		    $CPAN::Frontend->myprint(sprintf "    %-18s %s\n", $k, $v);
		}
d1401 2
a1402 1
	    $CPAN::Frontend->myprint(qq[Type 'o conf' to view configuration edit options\n\n]);
d1410 4
d1449 2
a1450 1
		$CPAN::Frontend->myprint(sprintf "    %-14s(%s)\n", $k, $v) if $v & $CPAN::DEBUG;
d1464 1
a1464 1
sub dotdot_onreload {
d1467 1
a1467 1
	if ( $_[0] =~ /Subroutine (\w+) redefined/ ) {
d1488 2
a1489 2
	$redef = 0;
	local($SIG{__WARN__}) = dotdot_onreload(\$redef);
a1504 1
    my $isaperl = q{perl5[._-]\\d{3}(_[0-4][0-9])?\\.tar[._-]gz\z};
d1509 2
a1510 1
	next if $file =~ / $isaperl /xo;
d1548 2
a1549 2
    Carp::croak "Usage: \$obj->_u_r_common($what)" unless defined $what;
    Carp::croak "Usage: \$obj->_u_r_common(a|r|u)" unless $what =~ /^[aru]$/;
d1555 8
a1562 2
    my $sprintf = "%-25s %9s %9s  %s\n";
    for $module ($self->expand('Module',@@args)) {
d1580 1
a1580 1
		next if $have >= $latest;
d1611 28
a1638 10
		   $sprintf,
		   "Package namespace",
		   "installed",
		   "latest",
		   "in CPAN file"
		   ));
	}
	$latest = substr($latest,0,8) if length($latest) > 8;
	$have = substr($have,0,8) if length($have) > 8;
	$CPAN::Frontend->myprint(sprintf $sprintf, $module->id, $have, $latest, $file);
d1720 21
d1746 1
d1748 1
a1748 1
	my $regex;
d1751 3
a1753 1
	}
d1756 5
d1762 50
a1811 28
	  for $obj (
		    sort
		    {$a->id cmp $b->id}
		    $CPAN::META->all_objects($class)
		   ) {
	    unless ($obj->id){
	      # BUG, we got an empty object somewhere
	      CPAN->debug(sprintf(
				  "Empty id on obj[%s]%%[%s]",
				  $obj,
				  join(":", %$obj)
				 )) if $CPAN::DEBUG;
	      next;
	    }
	    push @@m, $obj
		if $obj->id =~ /$regex/i
		    or
			(
			 (
			  $] < 5.00303 ### provide sort of
                                       ### compatibility with 5.003
			  ||
			  $obj->can('name')
			 )
			 &&
			 $obj->name  =~ /$regex/i
			);
	  }
d1816 3
a1818 1
	    }
d1838 1
a1838 1
    my $result =  @@result == 1 ?
d1840 6
a1845 2
	    join "", map {$_->as_glimpse} @@result;
    $result ||= "No objects of type $type found for argument @@args\n";
d1852 2
d1857 1
a1857 1
    my $ornamenting = 0; # turn the colors on
d1859 6
a1864 1
    if ($ornamenting) {
d1892 1
d1940 17
a1956 1
    my($s,@@s);
a1957 3
      CPAN::Queue->new($s);
    }
    while ($s = CPAN::Queue->first) {
d1960 1
d1962 5
a1966 4
	} elsif ($s =~ m|/|) { # looks like a file
	    $obj = $CPAN::META->instance('CPAN::Distribution',$s);
	} elsif ($s =~ m|^Bundle::|) {
	    $obj = $CPAN::META->instance('CPAN::Bundle',$s);
d1968 2
a1969 2
	    $obj = $CPAN::META->instance('CPAN::Module',$s)
		if $CPAN::META->exists('CPAN::Module',$s);
d1972 3
a1974 19
	    CPAN->debug(
			qq{pragma[$pragma]meth[$meth]obj[$obj]as_string\[}.
			$obj->as_string.
			qq{\]}
		       ) if $CPAN::DEBUG;
	    $obj->$pragma()
		if
		    $pragma
			&&
		    ($] < 5.00303 || $obj->can($pragma)); ###
                                                          ### compatibility
                                                          ### with
                                                          ### 5.003
	    if ($]>=5.00303 && $obj->can('called_for')) {
	      $obj->called_for($s);
	    }
	    CPAN::Queue->delete($s) if $obj->$meth(); # if it is more
                                                      # than once in
                                                      # the queue
d1977 11
a1987 6
	    $CPAN::Frontend->myprint(
				     join "",
				     "Don't be silly, you can't $meth ",
				     $obj->fullname,
				     " ;-)\n"
				    );
d1996 1
a1996 1
to find objects with similar identifiers.
d1998 13
d2012 24
d2038 3
d2043 2
d2064 54
d2130 1
a2130 1
  $class->debug(qq[Going to ->login("anonymous","$Config::Config{'cf_email'}")\n]);
d2151 25
a2175 51
 # leach,> *** /install/perl/live/lib/CPAN.pm-	Wed Sep 24 13:08:48 1997
 # leach,> --- /tmp/cp	Wed Sep 24 13:26:40 1997
 # leach,> ***************
 # leach,> *** 1562,1567 ****
 # leach,> --- 1562,1580 ----
 # leach,>       return 1 if substr($url,0,4) eq "file";
 # leach,>       return 1 unless $url =~ m|://([^/]+)|;
 # leach,>       my $host = $1;
 # leach,> +     my $proxy = $CPAN::Config->{'http_proxy'} || $ENV{'http_proxy'};
 # leach,> +     if ($proxy) {
 # leach,> +         $proxy =~ m|://([^/:]+)|;
 # leach,> +         $proxy = $1;
 # leach,> +         my $noproxy = $CPAN::Config->{'no_proxy'} || $ENV{'no_proxy'};
 # leach,> +         if ($noproxy) {
 # leach,> +             if ($host !~ /$noproxy$/) {
 # leach,> +                 $host = $proxy;
 # leach,> +             }
 # leach,> +         } else {
 # leach,> +             $host = $proxy;
 # leach,> +         }
 # leach,> +     }
 # leach,>       require Net::Ping;
 # leach,>       return 1 unless $Net::Ping::VERSION >= 2;
 # leach,>       my $p;


# this is quite optimistic and returns one on several occasions where
# inappropriate. But this does no harm. It would do harm if we were
# too pessimistic (as I was before the http_proxy
sub is_reachable {
    my($self,$url) = @@_;
    return 1; # we can't simply roll our own, firewalls may break ping
    return 0 unless $url;
    return 1 if substr($url,0,4) eq "file";
    return 1 unless $url =~ m|^(\w+)://([^/]+)|;
    my $proxytype = $1 . "_proxy"; # ftp_proxy or http_proxy
    my $host = $2;
    return 1 if $CPAN::Config->{$proxytype} || $ENV{$proxytype};
    require Net::Ping;
    return 1 unless $Net::Ping::VERSION >= 2;
    my $p;
    # 1.3101 had it different: only if the first eval raised an
    # exception we tried it with TCP. Now we are happy if icmp wins
    # the order and return, we don't even check for $@@. Thanks to
    # thayer@@uis.edu for the suggestion.
    eval {$p = Net::Ping->new("icmp");};
    return 1 if $p && ref($p) && $p->ping($host, 10);
    eval {$p = Net::Ping->new("tcp");};
    $CPAN::Frontend->mydie($@@) if $@@;
    return $p->ping($host, 10);
}
a2177 2
# sorry for the ugly code here, I'll clean it up as soon as Net::FTP
# is in the core
d2187 2
d2191 9
a2199 1
            $name =~ s/(\.(readme(\.(gz|Z))?|(tar\.)?(gz|Z)|tgz|zip|pm\.(gz|Z)))$//;
d2225 1
a2225 2
    if ($CPAN::META->has_inst('LWP::UserAgent')) {
	require LWP::UserAgent;
d2227 28
a2254 8
	    $Ua = LWP::UserAgent->new;
	    my($var);
	    $Ua->proxy('ftp',  $var)
		if $var = $CPAN::Config->{'ftp_proxy'} || $ENV{'ftp_proxy'};
	    $Ua->proxy('http', $var)
		if $var = $CPAN::Config->{'http_proxy'} || $ENV{'http_proxy'};
	    $Ua->no_proxy($var)
		if $var = $CPAN::Config->{'no_proxy'} || $ENV{'no_proxy'};
d2257 4
d2283 1
a2283 1
    my($level,@@levels);
d2290 3
a2292 1
    for $level (@@levels) {
d2307 1
d2310 11
a2320 9
    my(@@mess);
    push @@mess,
    qq{Please check, if the URLs I found in your configuration file \(}.
	join(", ", @@{$CPAN::Config->{urllist}}).
	    qq{\) are valid. The urllist can be edited.},
	    qq{E.g. with ``o conf urllist push ftp://myurl/''};
    $CPAN::Frontend->myprint(Text::Wrap::wrap("","",@@mess). "\n\n");
    sleep 2;
    $CPAN::Frontend->myprint("Cannot fetch $file\n\n");
d2334 1
a2334 6
      my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
	unless ($self->is_reachable($url)) {
	    $CPAN::Frontend->myprint("Skipping $url (seems to be not reachable)\n");
	    sleep 2;
	    next;
	}
d2340 1
a2340 2
	    if ($CPAN::META->has_inst('LWP')) {
		require URI::URL;
d2354 1
d2370 1
a2370 1
      if ($CPAN::META->has_inst('LWP')) {
d2375 5
a2379 2
	    require LWP::UserAgent;
	    $Ua = LWP::UserAgent->new;
d2388 1
a2388 1
	  } elsif ($url !~ /\.gz\z/) {
a2398 2
	    } else {
	      # next HOSTEASY ;
d2401 8
a2408 4
	    # Alan Burlison informed me that in firewall envs Net::FTP
	    # can still succeed where LWP fails. So we do not skip
	    # Net::FTP anymore when LWP is available.
	    # next HOSTEASY ;
d2411 1
a2411 1
	  $self->debug("LWP not installed") if $CPAN::DEBUG;
d2413 1
d2417 1
a2417 1
	    if ($CPAN::META->has_inst('Net::FTP')) {
d2428 1
a2428 1
		if ($aslocal !~ /\.gz\z/) {
d2446 1
a2463 4
	unless ($self->is_reachable($url)) {
	  $CPAN::Frontend->myprint("Skipping $url (not reachable)\n");
	  next;
	}
d2477 2
d2482 1
a2482 1
	for $f ('lynx','ncftpget','ncftp') {
d2487 4
a2490 4
	  my($want_compressed);
	  my $aslocal_uncompressed;
	  ($aslocal_uncompressed = $aslocal) =~ s/\.gz//;
	  my($source_switch) = "";
d2492 1
a2492 1
	    $source_switch = " -source";
d2494 3
a2496 1
	    $source_switch = " -c";
d2499 1
a2499 1
	  my($stdout_redir) = " > $aslocal_uncompressed";
d2506 1
a2506 1
Trying with "$funkyftp$source_switch" to get
d2510 1
a2510 1
	      "$chdir$funkyftp$source_switch '$url' $devnull$stdout_redir";
d2516 1
a2516 2
	       -s $aslocal_uncompressed   # lynx returns 0 on my
                                          # system even if it fails
d2522 1
a2522 1
	    } elsif ($aslocal_uncompressed ne $aslocal) {
d2524 3
a2526 4
	      if (
		  CPAN::Tarzip->gtest($aslocal_uncompressed)
		 ) {
		rename $aslocal_uncompressed, $aslocal;
d2528 1
a2528 2
		CPAN::Tarzip->gzip($aslocal_uncompressed,
				   "$aslocal_uncompressed.gz");
d2533 3
a2535 3
	  } elsif ($url !~ /\.gz\z/) {
	    unlink $aslocal_uncompressed if
		-f $aslocal_uncompressed && -s _ == 0;
d2540 1
a2540 1
Trying with "$funkyftp$source_switch" to get
d2543 1
a2543 2
	    my($system) = "$funkyftp$source_switch '$url.gz' $devnull > ".
		"$aslocal_uncompressed.gz";
d2548 1
a2548 1
		-s "$aslocal_uncompressed.gz"
d2551 2
a2552 3
	      if (CPAN::Tarzip->gtest("$aslocal_uncompressed.gz")) {
		CPAN::Tarzip->gunzip("$aslocal_uncompressed.gz",
				     $aslocal);
d2554 2
a2555 1
		rename $aslocal_uncompressed, $aslocal;
d2560 1
a2560 2
	      unlink "$aslocal_uncompressed.gz" if
		  -f "$aslocal_uncompressed.gz";
d2572 3
a2574 2
	}
    }
a2588 4
	unless ($self->is_reachable($url)) {
	    $CPAN::Frontend->myprint("Skipping $url (not reachable)\n");
	    next;
	}
d2641 1
d2671 1
d2674 1
a2674 1
    }
d2802 1
d2850 2
a2851 8
	@@return = grep(
		       /^$word/,
		       sort qw(
			       ! a b d h i m o q r u autobundle clean
			       make test install force reload look cvs_import
			      )
		      );
    } elsif ( $line !~ /^[\!abcdhimorutl]/ ) {
d2853 2
a2854 2
    } elsif ($line =~ /^a\s/) {
	@@return = cplx('CPAN::Author',$word);
d2856 1
d2860 6
a2865 1
    } elsif ($line =~ /^([mru]|make|clean|test|install|readme|look|cvs_import)\s/ ) {
d2873 3
d2885 5
a2889 1
    grep /^\Q$word\E/, map { $_->id } $CPAN::META->all_objects($class);
d2938 1
a2938 1
    $CPAN::Index::last_time = 0;
d2952 14
a2965 1
    return if $last_time + $CPAN::Config->{index_expire}*86400 > $time
d2967 50
a3016 43
    ## IFF we are developing, it helps to wipe out the memory between
    ## reloads, otherwise it is not what a user expects.

    ## undef $CPAN::META; # Neue Gruendlichkeit since v1.52(r1.274)
    ## $CPAN::META = CPAN->new;
    my($debug,$t2);
    $last_time = $time;

    my $needshort = $^O eq "dos";

    $cl->rd_authindex($cl
		      ->reload_x(
				 "authors/01mailrc.txt.gz",
				 $needshort ?
				 File::Spec->catfile('authors', '01mailrc.gz') :
				 File::Spec->catfile('authors', '01mailrc.txt.gz'),
				 $force));
    $t2 = time;
    $debug = "timing reading 01[".($t2 - $time)."]";
    $time = $t2;
    return if $CPAN::Signal; # this is sometimes lengthy
    $cl->rd_modpacks($cl
		     ->reload_x(
				"modules/02packages.details.txt.gz",
				$needshort ?
				File::Spec->catfile('modules', '02packag.gz') :
				File::Spec->catfile('modules', '02packages.details.txt.gz'),
				$force));
    $t2 = time;
    $debug .= "02[".($t2 - $time)."]";
    $time = $t2;
    return if $CPAN::Signal; # this is sometimes lengthy
    $cl->rd_modlist($cl
		    ->reload_x(
			       "modules/03modlist.data.gz",
			       $needshort ?
			       File::Spec->catfile('modules', '03mlist.gz') :
			       File::Spec->catfile('modules', '03modlist.data.gz'),
			       $force));
    $t2 = time;
    $debug .= "03[".($t2 - $time)."]";
    $time = $t2;
    CPAN->debug($debug) if $CPAN::DEBUG;
a3048 3
#    my $fh = CPAN::Tarzip->TIEHANDLE($index_target);
#    while ($_ = $fh->READLINE) {
    # no strict 'refs';
d3074 1
a3074 1
    my($cl, $index_target) = @@_;
d3086 2
d3091 53
d3145 7
d3154 4
a3157 4
	my($mod,$version,$dist) = split;
###	$version =~ s/^\+//;

	# if it is a bundle, instantiate a bundle object
d3166 4
a3169 4
	    local($^W)= 0;
	    if ($version > $CPAN::VERSION){
		$CPAN::Frontend->myprint(qq{
  There\'s a new CPAN.pm version (v$version) available!
d3176 2
a3177 2
});
		sleep 2;
a3186 1
	    # warn "made mod[$mod]a bundle";
d3188 4
a3191 3
	    # in common with modules
	    $CPAN::META->instance('CPAN::Module',$mod);
	    # warn "made mod[$mod]a module";
d3193 3
a3195 4
# This "next" makes us faster but if the job is running long, we ignore
# rereads which is bad. So we have to be a bit slower again.
#	} elsif ($CPAN::META->exists('CPAN::Module',$mod)) {
#	    next;
a3196 2
	}
	else {
d3199 1
d3202 4
a3205 2
	if ($id->cpan_file ne $dist){
	    $userid = $cl->userid($dist);
d3209 1
a3209 1
		     'CPAN_FILE' => $dist
d3226 2
a3227 1
				      'CPAN_USERID' => $userid
d3230 6
a3235 1

d3239 10
d3268 2
a3269 2
	    return if $date_of_03 eq $1;
	    ($date_of_03) = $1;
d3282 2
a3283 1
	my $obj = $CPAN::META->instance(CPAN::Module,$_);
d3289 78
d3369 4
d3374 11
a3384 1
sub new { my $this = bless {}, shift; %$this = @@_; $this }
d3389 18
a3406 2
    my(%oldatt) = %$self;
    %$self = (%oldatt, %att);
a3408 3
#-> sub CPAN::InfoObj::id ;
sub id { shift->{'ID'} }

d3426 2
a3427 2
    for (sort keys %$self) {
	next if $_ eq 'ID';
d3430 21
a3450 13
	  $extra .= " (".$self->author;
	  my $email; # old perls!
	  if ($email = $CPAN::META->instance(CPAN::Author,
						$self->{$_}
					       )->email) {
	    $extra .= " <$email>";
	  } else {
	    $extra .= " <no email>";
	  }
	  $extra .= ")";
	}
	if (ref($self->{$_}) eq "ARRAY") { # language interface? XXX
	  push @@m, sprintf "    %-12s %s%s\n", $_, "@@{$self->{$_}}", $extra;
d3453 1
a3453 1
			   "    %-12s %s%s\n",
d3456 1
a3456 1
			   $extra);
d3458 1
a3458 1
	  push @@m, sprintf "    %-12s %s%s\n", $_, $self->{$_}, $extra;
d3467 1
a3467 1
    $CPAN::META->instance(CPAN::Author,$self->{CPAN_USERID})->fullname;
d3470 1
d3474 1
a3474 1
  Data::Dumper::Dumper($self);
d3479 8
d3493 5
a3497 1
    push @@m, sprintf "%-15s %s (%s)\n", $class, $self->{ID}, $self->fullname;
a3500 6
# Dead code, I would have liked to have,,, but it was never reached,,,
#sub make {
#    my($self) = @@_;
#    return "Don't be silly, you can't make $self->{FULLNAME} ;-)\n";
#}

d3502 3
a3504 1
sub fullname { shift->{'FULLNAME'} }
d3508 1
a3508 1
sub email    { shift->{'EMAIL'} }
d3510 154
a3663 1
package CPAN::Distribution;
d3675 2
a3676 1
  return if exists $self->{CONTAINSMODS};
d3678 1
a3678 2
    my $mod_file = $mod->{CPAN_FILE} or next;
    my $dist_id = $self->{ID} or next;
d3680 2
d3684 12
d3701 18
a3718 2
    $self->{'CALLED_FOR'} = $id if defined $id;
    return $self->{'CALLED_FOR'};
d3727 1
a3727 1
	    "Unwrapped into directory $self->{'build_dir'}";
d3730 6
d3738 6
a3743 6
	 MM->catfile(
			$CPAN::Config->{keep_source_where},
			"authors",
			"id",
			split("/",$self->{ID})
		       );
d3746 11
a3756 3
    $local_file =
	CPAN::FTP->localize("authors/id/$self->{ID}", $local_wanted)
	    or $CPAN::Frontend->mydie("Giving up on '$local_wanted'\n");
d3758 1
a3758 4
    my $builddir = $CPAN::META->{cachemgr}->dir;
    $self->debug("doing chdir $builddir") if $CPAN::DEBUG;
    chdir $builddir or Carp::croak("Couldn't chdir $builddir: $!");
    my $packagedir;
d3760 4
a3763 2
    $self->debug("local_file[$local_file]") if $CPAN::DEBUG;
    if ($CPAN::META->has_inst('MD5')) {
d3769 8
d3780 11
a3790 5
    chdir "tmp";
    $self->debug("Changed directory to tmp") if $CPAN::DEBUG;
    if (! $local_file) {
	Carp::croak "bad download, can't do anything :-(\n";
    } elsif ($local_file =~ /(\.tar\.(gz|Z)|\.tgz)\z/i){
d3792 1
a3792 1
    } elsif ( $local_file =~ /\.zip\z/i ) {
d3794 2
a3795 1
    } elsif ( $local_file =~ /\.pm\.(gz|Z)\z/) {
d3799 48
a3847 29
    chdir File::Spec->updir;
    if ($self->{archived} ne 'NO') {
	chdir File::Spec->catdir(File::Spec->curdir, "tmp");
	# Let's check if the package has its own directory.
	my $dh = DirHandle->new(File::Spec->curdir)
	    or Carp::croak("Couldn't opendir .: $!");
	my @@readdir = grep $_ !~ /^\.\.?\z/s, $dh->read; ### MAC??
	$dh->close;
	my ($distdir,$packagedir);
	if (@@readdir == 1 && -d $readdir[0]) {
	    $distdir = $readdir[0];
	    $packagedir = MM->catdir($builddir,$distdir);
	    -d $packagedir and $CPAN::Frontend->myprint("Removing previously used $packagedir\n");
	    File::Path::rmtree($packagedir);
	    rename($distdir,$packagedir) or Carp::confess("Couldn't rename $distdir to $packagedir: $!");
	} else {
	    my $pragmatic_dir = $self->{'CPAN_USERID'} . '000';
	    $pragmatic_dir =~ s/\W_//g;
	    $pragmatic_dir++ while -d "../$pragmatic_dir";
	    $packagedir = MM->catdir($builddir,$pragmatic_dir);
	    File::Path::mkpath($packagedir);
	    my($f);
	    for $f (@@readdir) { # is already without "." and ".."
		my $to = MM->catdir($packagedir,$f);
		rename($f,$to) or Carp::confess("Couldn't rename $f to $to: $!");
	    }
	}
	$self->{'build_dir'} = $packagedir;
	chdir File::Spec->updir;
d3849 27
a3875 15
	$self->debug("Changed directory to .. (self is $self [".$self->as_string."])")
	    if $CPAN::DEBUG;
	File::Path::rmtree("tmp");
	if ($CPAN::Config->{keep_source_where} =~ /^no/i ){
	    $CPAN::Frontend->myprint("Going to unlink $local_file\n");
	    unlink $local_file or Carp::carp "Couldn't unlink $local_file";
	}
	my($makefilepl) = MM->catfile($packagedir,"Makefile.PL");
	unless (-f $makefilepl) {
	  my($configure) = MM->catfile($packagedir,"Configure");
	  if (-f $configure) {
	    # do we have anything to do?
	    $self->{'configure'} = $configure;
	  } elsif (-f MM->catfile($packagedir,"Makefile")) {
	    $CPAN::Frontend->myprint(qq{
d3879 22
a3900 7
	    $self->{writemakefile} = "YES";
	    sleep 2;
	  } else {
	    my $fh = FileHandle->new(">$makefilepl")
		or Carp::croak("Could not open >$makefilepl");
	    my $cf = $self->called_for || "unknown";
	    $fh->print(
d3909 2
a3910 4
	    $CPAN::Frontend->myprint(qq{Package comes without Makefile.PL.
  Writing one on our own (calling it $cf)\n});
	    }
	}
d3912 1
d3916 1
d3927 1
d3931 1
a3931 2
    my $system = "$CPAN::Config->{unzip} $local_file";
    if (system($system) == 0) {
d3936 1
d3943 1
a3943 1
    $to =~ s/\.(gz|Z)\z//;
d3955 1
a3955 1
    $CPAN::META->{cachemgr} ||= CPAN::CacheMgr->new();
d3982 12
a3993 6
    my $dir  = $self->dir or $self->get;
    $dir = $self->dir;
    my $getcwd;
    $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    my $pwd  = CPAN->$getcwd();
    chdir($dir);
d3997 1
a3997 1
    chdir($pwd);
d4000 1
d4010 1
a4010 1
    my $userid = $self->{CPAN_USERID};
d4013 1
a4013 1
    $cvs_dir =~ s/-\d+[^-]+\z//;
d4026 2
a4027 4
    my $getcwd;
    $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    my $pwd  = CPAN->$getcwd();
    chdir($dir);
d4032 1
a4032 1
    system(@@cmd) == 0 or 
d4034 1
a4034 1
    chdir($pwd);
d4087 1
a4087 1
    @@local = split("/",$self->{ID});
d4104 1
d4109 1
a4109 1
	    $lc_file =~ s/\.gz\z//;
d4167 1
a4167 1
	    $CPAN::Frontend->myprint(qq{Checksum mismatch for }.
d4173 1
a4173 1
							   $self->{CPAN_USERID}
d4175 4
a4178 3
	    my $wrap = qq{I\'d recommend removing $file. It seems to
be a bogus file. Maybe you have configured your \`urllist\' with a
bad URL. Please check this array with \`o conf urllist\', and
d4180 9
a4188 4
	    $CPAN::Frontend->myprint(Text::Wrap::wrap("","",$wrap));
	    $CPAN::Frontend->myprint("\n\n");
	    sleep 3;
	    return;
d4194 6
a4199 3
	    $CPAN::Frontend->myprint(qq{
No md5 checksum for $basename in local $chk_file.
Removing $chk_file
d4201 2
a4202 2
	    unlink $chk_file or $CPAN::Frontend->myprint("Could not unlink: $!");
	    sleep 1;
d4224 11
d4236 1
a4236 2
  my($self) = @@_;
  $self->{'force_update'}++;
d4243 9
d4254 1
d4258 18
a4275 8
  return unless $file =~ m{ ^ perl
			    (5)
			    ([._-])
			    (\d{3}(_[0-4][0-9])?)
			    \.tar[._-]gz
			    \z
			  }xs;
  "$1.$3";
d4282 1
a4282 2
    my $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    my $pwd  = CPAN->$getcwd();
d4309 2
a4310 1
	  $self->called_for ne $self->id && ! $self->{'force_update'}
d4312 2
a4313 1
	$CPAN::Frontend->mydie(sprintf qq{
d4329 1
d4346 4
a4349 1
	"Has already been processed within this session";
d4416 1
d4426 24
a4449 5
    return if $CPAN::Signal;
    if (my @@prereq = $self->needs_prereq){
      my $id = $self->id;
      $CPAN::Frontend->myprint("---- Dependencies detected ".
			       "during [$id] -----\n");
d4451 1
a4451 1
      for my $p (@@prereq) {
d4453 3
a4455 3
      }
      my $follow = 0;
      if ($CPAN::Config->{prerequisites_policy} eq "follow") {
d4457 1
a4457 1
      } elsif ($CPAN::Config->{prerequisites_policy} eq "ask") {
d4463 1
a4463 1
      } else {
d4465 11
a4475 6
	$CPAN::Frontend->myprint("  Ignoring dependencies on modules @@prereq\n");
      }
      if ($follow) {
	CPAN::Queue->jumpqueue(@@prereq,$id); # requeue yourself
	return;
      }
d4477 45
a4521 8
    $system = join " ", $CPAN::Config->{'make'}, $CPAN::Config->{make_arg};
    if (system($system) == 0) {
	 $CPAN::Frontend->myprint("  $system -- OK\n");
	 $self->{'make'} = "YES";
    } else {
	 $self->{writemakefile} ||= "YES";
	 $self->{'make'} = "NO";
	 $CPAN::Frontend->myprint("  $system -- NOT OK\n");
d4523 1
d4526 2
a4527 2
#-> sub CPAN::Distribution::needs_prereq ;
sub needs_prereq {
d4529 18
a4546 9
  return unless -f "Makefile"; # we cannot say much
  my $fh = FileHandle->new("<Makefile") or
      $CPAN::Frontend->mydie("Couldn't open Makefile: $!");
  local($/) = "\n";

  my(@@p,@@need);
  while (<$fh>) {
    last if /MakeMaker post_initialize section/;
    my($p) = m{^[\#]
d4549 2
a4550 2
    next unless $p;
    # warn "Found prereq expr[$p]";
d4552 11
a4562 4
    while ( $p =~ m/(?:\s)([\w\:]+)=>q\[.*?\],?/g ){
      push @@p, $1;
    }
    last;
d4564 2
a4565 14
  for my $p (@@p) {
    my $mo = $CPAN::META->instance("CPAN::Module",$p);
    next if $mo->uptodate;
    # it's not needed, so don't push it. We cannot omit this step, because
    # if 'force' is in effect, nobody else will check.
    if ($self->{have_sponsored}{$p}++){
      # We have already sponsored it and for some reason it's still
      # not available. So we do nothing. Or what should we do?
      # if we push it again, we have a potential infinite loop
      next;
    }
    push @@need, $p;
  }
  return @@need;
d4572 4
a4575 1
    return if $CPAN::Signal;
d4577 3
d4582 1
a4582 1
	exists $self->{'make'} or push @@e,
d4587 9
a4595 1
		push @@e, "Oops, make had returned bad status";
a4596 1
	exists $self->{'build_dir'} or push @@e, "Has no own directory";
d4612 1
a4612 1
	 $self->{'make_test'} = "YES";
d4614 2
a4615 1
	 $self->{'make_test'} = "NO";
d4626 3
a4628 1
	exists $self->{'build_dir'} or push @@e, "Has no own directory";
d4642 16
a4657 2
	$CPAN::Frontend->myprint("  $system -- OK\n");
	$self->force;
d4659 8
a4666 1
	# Hmmm, what to do if make clean failed?
d4674 4
a4677 1
    return if $CPAN::Signal;
d4681 1
a4681 1
	exists $self->{'build_dir'} or push @@e, "Has no own directory";
d4683 1
a4683 1
	exists $self->{'make'} or push @@e,
d4688 1
a4688 1
		push @@e, "Oops, make had returned bad status";
d4700 3
d4736 1
d4746 38
d4788 1
d4795 53
a4847 47
  my($self) = @@_;
  my($parsefile) = $self->inst_file;
  my($id) = $self->id;
  $self->debug("parsefile[$parsefile]id[$id]") if $CPAN::DEBUG;
  unless ($parsefile) {
    # Try to get at it in the cpan directory
    $self->debug("no parsefile") if $CPAN::DEBUG;
    Carp::confess "I don't know a $id" unless $self->{CPAN_FILE};
    my $dist = $CPAN::META->instance('CPAN::Distribution',
				     $self->{CPAN_FILE});
    $dist->get;
    $self->debug($dist->as_string) if $CPAN::DEBUG;
    my($todir) = $CPAN::Config->{'cpan_home'};
    my(@@me,$from,$to,$me);
    @@me = split /::/, $self->id;
    $me[-1] .= ".pm";
    $me = MM->catfile(@@me);
    $from = $self->find_bundle_file($dist->{'build_dir'},$me);
    $to = MM->catfile($todir,$me);
    File::Path::mkpath(File::Basename::dirname($to));
    File::Copy::copy($from, $to)
	or Carp::confess("Couldn't copy $from to $to: $!");
    $parsefile = $to;
  }
  my @@result;
  my $fh = FileHandle->new;
  local $/ = "\n";
  open($fh,$parsefile) or die "Could not open '$parsefile': $!";
  my $in_cont = 0;
  $self->debug("parsefile[$parsefile]") if $CPAN::DEBUG;
  while (<$fh>) {
    $in_cont = m/^=(?!head1\s+CONTENTS)/ ? 0 :
	m/^=head1\s+CONTENTS/ ? 1 : $in_cont;
    next unless $in_cont;
    next if /^=/;
    s/\#.*//;
    next if /^\s+$/;
    chomp;
    push @@result, (split " ", $_, 2)[0];
  }
  close $fh;
  delete $self->{STATUS};
  $self->{CONTAINS} = join ", ", @@result;
  $self->debug("CONTAINS[@@result]") if $CPAN::DEBUG;
  unless (@@result) {
    $CPAN::Frontend->mywarn(qq{
The bundle file "$parsefile" may be a broken
d4852 2
a4853 2
  }
  @@result;
d4866 2
a4867 3
	my $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
	my $cwd = CPAN->$getcwd();
	chdir $where;
d4869 1
a4869 1
	chdir $cwd;
d4901 5
d4909 23
a4931 13
    my($me,$inst_file);
    ($me = $self->id) =~ s/.*://;
##    my(@@me,$inst_file);
##    @@me = split /::/, $self->id;
##    $me[-1] .= ".pm";
    $inst_file = MM->catfile($CPAN::Config->{'cpan_home'},
				      "Bundle", "$me.pm");
##				      "Bundle", @@me);
    return $self->{'INST_FILE'} = $inst_file if -f $inst_file;
#    $inst_file =
    $self->SUPER::inst_file;
#    return $self->{'INST_FILE'} = $inst_file if -f $inst_file;
#    return $self->{'INST_FILE'}; # even if undefined?
d4940 1
a4940 1
	unless $self->inst_file || $self->{CPAN_FILE};
d4953 1
d4956 23
a4978 3
	my $success = $obj->can("uptodate") ? $obj->uptodate : 0;
	$success ||= $obj->{'install'} && $obj->{'install'} eq "YES";
	$fail{$s} = 1 unless $success;
d4980 1
d4982 1
a4982 1
    if ( $meth eq "install") {
d4992 1
d4994 5
a4998 1
		$paragraph .= "$s " if $fail{$s};
d5000 7
d5029 5
a5033 1
sub test    { shift->rematein('test',@@_); }
d5042 12
d5065 43
d5114 17
a5130 1
    push @@m, sprintf("%-15s %-15s (%s)\n", $class, $self->{ID},
d5145 2
a5146 2
    push @@m, sprintf($sprintf, 'DESCRIPTION', $self->{description})
	if $self->{description};
d5149 1
a5149 1
    if ($userid = $self->{'CPAN_USERID'} || $self->{'userid'}){
d5165 4
a5168 4
    push @@m, sprintf($sprintf, 'CPAN_VERSION', $self->{CPAN_VERSION})
	if $self->{CPAN_VERSION};
    push @@m, sprintf($sprintf, 'CPAN_FILE', $self->{CPAN_FILE})
	if $self->{CPAN_FILE};
d5185 9
a5193 9
		     $self->{statd},
		     $self->{stats},
		     $self->{statl},
		     $self->{stati},
		     $statd{$self->{statd}},
		     $stats{$self->{stats}},
		     $statl{$self->{statl}},
		     $stati{$self->{stati}}
		    ) if $self->{statd};
d5195 42
a5236 2
    if ($local_file) {
      $self->{MANPAGE} ||= $self->manpage_headline($local_file);
d5239 1
a5239 1
    for $item (qw/MANPAGE CONTAINS/) {
d5243 4
d5257 1
a5257 1
  $local_file =~ s/\.pm\z/.pod/;
d5282 2
a5283 1
sub cpan_file    {
d5285 2
a5286 2
    CPAN->debug($self->id) if $CPAN::DEBUG;
    unless (defined $self->{'CPAN_FILE'}) {
d5289 2
a5290 11
    if (exists $self->{'CPAN_FILE'} && defined $self->{'CPAN_FILE'}){
	return $self->{'CPAN_FILE'};
    } elsif (exists $self->{'userid'} && defined $self->{'userid'}) {
	my $fullname = $CPAN::META->instance(CPAN::Author,
				      $self->{'userid'})->fullname;
	my $email = $CPAN::META->instance(CPAN::Author,
				      $self->{'userid'})->email;
	unless (defined $fullname && defined $email) {
	    return "Contact Author $self->{userid} (Try ``a $self->{userid}'')";
	}
	return "Contact Author $fullname <$email>";
d5292 19
a5310 1
	return "N/A";
a5313 2
*name = \&cpan_file;

d5317 8
a5324 11
    $self->{'CPAN_VERSION'} = 'undef'
	unless defined $self->{'CPAN_VERSION'}; # I believe this is
                                                # always a bug in the
                                                # index and should be
                                                # reported as such,
                                                # but usually I find
                                                # out such an error
                                                # and do not want to
                                                # provoke too many
                                                # bugreports
    $self->{'CPAN_VERSION'};
d5336 3
a5338 1
    $self->debug($self->id) if $CPAN::DEBUG;
d5346 1
a5346 1
  more about the status. Try ``i %s''.
d5355 1
a5355 1
    $pack->force if exists $self->{'force_update'};
d5357 1
d5370 4
a5373 1
sub make   { shift->rematein('make') }
d5375 5
a5379 1
sub test   { shift->rematein('test') }
d5393 1
a5393 1
	$have >= $latest
d5395 3
a5397 1
      return 1;
d5454 36
a5489 2
    # warn "HERE";
    my $have = MM->parse_version($parsefile) || "undef";
d5491 1
a5491 1
    $have;
d5496 1
d5511 1
a5511 1
    system("$CPAN::Config->{'gzip'} -c $read > $write")==0;
d5515 2
d5533 1
a5533 1
    system("$CPAN::Config->{'gzip'} -dc $read > $write")==0;
d5537 2
d5541 5
a5545 2
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my($buffer);
d5547 16
a5562 6
	or $CPAN::Frontend->mydie("Cannot open $read: $!\n");
    1 while $gz->gzread($buffer) > 0 ;
    $CPAN::Frontend->mydie("Error reading from $read: $!\n")
	if $gz->gzerror != Compress::Zlib::Z_STREAM_END();
    $gz->gzclose() ;
    return 1;
d5564 1
a5564 1
    return system("$CPAN::Config->{'gzip'} -dt $read")==0;
d5568 2
d5579 2
a5580 2
    my $pipe = "$CPAN::Config->{'gzip'} --decompress --stdout $file |";
    my $fh = FileHandle->new($pipe) or die "Could pipe[$pipe]: $!";
d5587 2
d5603 2
d5618 2
d5621 10
a5630 9
  my($self) = @@_;
  if (exists $self->{GZ}) {
    my $gz = $self->{GZ};
    $gz->gzclose();
  } else {
    my $fh = $self->{FH};
    $fh->close if defined $fh;
  }
  undef $self;
d5633 2
d5637 31
a5667 6
  # had to disable, because version 0.07 seems to be buggy
  if (MM->maybe_command($CPAN::Config->{'gzip'})
      &&
      MM->maybe_command($CPAN::Config->{'tar'})) {
    my $system = "$CPAN::Config->{'gzip'} --decompress --stdout " .
      "< $file | $CPAN::Config->{tar} xvf -";
d5669 19
a5687 19
      # people find the most curious tar binaries that cannot handle
      # pipes
      my $system = "$CPAN::Config->{'gzip'} --decompress $file";
      if (system($system)==0) {
	$CPAN::Frontend->myprint(qq{Uncompressed $file successfully\n});
      } else {
	$CPAN::Frontend->mydie(
			       qq{Couldn\'t uncompress $file\n}
			      );
      }
      $file =~ s/\.gz\z//;
      $system = "$CPAN::Config->{tar} xvf $file";
      $CPAN::Frontend->myprint(qq{Using Tar:$system:\n});
      if (system($system)==0) {
	$CPAN::Frontend->myprint(qq{Untarred $file successfully\n});
      } else {
	$CPAN::Frontend->mydie(qq{Couldn\'t untar $file\n});
      }
      return 1;
d5689 1
a5689 1
      return 1;
d5691 1
a5691 3
  } elsif ($CPAN::META->has_inst("Archive::Tar")
      &&
      $CPAN::META->has_inst("Compress::Zlib") ) {
d5693 30
a5722 2
    $tar->extract($tar->list_files); # I'm pretty sure we have nothing
                                     # that isn't compressed
a5727 6
  } else {
    $CPAN::Frontend->mydie(qq{
CPAN.pm needs either both external programs tar and gzip installed or
both the modules Archive::Tar and Compress::Zlib. Neither prerequisite
is available. Can\'t continue.
});
d5731 112
d5888 5
a5892 5
L<CPAN::WAIT>. C<CPAN::WAIT> is a full-text search engine that indexes
all documents available in CPAN authors directories. If C<CPAN::WAIT>
is installed on your system, the interactive shell of <CPAN.pm> will
enable the C<wq>, C<wr>, C<wd>, C<wl>, and C<wh> commands which send
queries to the WAIT server that has been configured for your
d5911 4
d5958 1
a5958 1
the module doesnE<39>t need to be updated.
d5961 1
a5961 1
and doesnE<39>t try to build a package a second time regardless if it
d5989 7
d6040 1
a6040 1
invoke CPAN's recompile on the second architecture and youE<39>re done.
d6085 1
a6085 1
=head2 ProgrammerE<39>s interface
d6108 6
d6136 3
d6140 1
a6140 1
all modules that need updating:
d6144 4
a6147 4
If you don't want to get any output if all modules are up to date, you
can parse the output of above command for the regular expression
//modules are up to date// and decide to mail the output only if it
doesn't match. Ick?
d6150 1
a6150 1
process, maybe something like this suites you better:
d6176 293
a6468 1
=head2 Methods in the four Classes
d6562 1
a6562 1
The debugging of this module is pretty difficult, because we have
d6567 7
a6573 6
In interactive mode you can try "o debug" which will list options for
debugging the various parts of the package. The output may not be very
useful for you as it's just a by-product of my own testing, but if you
have an idea which part of the package may have a bug, it's sometimes
worth to give it a try and send me more specific output. You should
know that "o debug" has built-in completion support.
d6601 1
d6603 2
d6619 2
d6623 2
d6663 2
a6664 1
guessing if your URL is not compliant, but if you have problems with file URLs, please try the correct format. Either:
d6712 2
a6713 2
To populate a freshly installed perl with my favorite modules is pretty
easiest by maintaining a private bundle definition file. To get a useful
d6725 1
a6725 1
Maintaining a bundle definition file means to keep track of two
d6734 1
a6734 1
unattained.
d6739 7
a6745 1
the interaction between perl, and various firewall configurations.
d6788 1
a6788 1
it with the SOCKS library, this is what is normally called a ``socksified''
d6796 1
a6796 1
special compiling is need as you can access hosts directly.
d6802 161
d6967 2
a6968 2
but they are not. PAUSE is authors/ and modules/. CPAN is PAUSE plus
the clpa/, doc/, misc/, ports/, src/, scripts/.
d6981 5
@


1.2
log
@perl5.005_03 (stock)
@
text
@d9 1
a9 1
$VERSION = '1.48';
d11 1
a11 1
# $Id: CPAN.pm,v 1.260 1999/03/06 19:31:02 k Exp $
d15 1
a15 1
# $Revision = "[".substr(q$Revision: 1.260 $, 10)."]";
d64 1
a64 1
	     autobundle bundle expand force get
d93 1
a93 1
    $Suppress_readline ||= ! -t STDIN;
d116 6
d129 2
a130 1
    my $try_detect_readline = $term->ReadLine eq "Term::ReadLine::Stub";
d200 2
a201 1
	    $CPAN::Frontend->myprint("\n$redef subroutines in Term::ReadLine redefined\n");
d296 1
a296 1
		$name =~ s|^(.*)$pkg\.pm$|$1auto/$pkg/$func.al|;
d312 1
a312 1
	    if ($name =~ s{(\w{12,})\.al$}{substr($1,0,11).".al"}e){
d550 34
a583 1
    File::Path::mkpath($CPAN::Config->{cpan_home});
d624 21
d849 1
a849 1
	     $Du += $cat->ioFlLgLen() + $cat->ioFlRLgLen();
d1168 2
a1169 1
You may edit key values in the follow fashion:
d1215 23
a1237 23
command   arguments       description
a         string                  authors
b         or              display bundles
d         /regex/         info    distributions
m         or              about   modules
i         none                    anything of above

r          as             reinstall recommendations
u          above          uninstalled distributions
See manpage for autobundle, recompile, force, look, etc.

make                      make
test      modules,        make test (implies make)
install   dists, bundles, make install (implies test)
clean     "r" or "u"      make clean
readme                    display the README file

reload    index|cpan    load most recent indices/CPAN.pm
h or ?                  display this menu
o         various       set and query options
!         perl-code     eval a perl command
q                       quit the shell subroutine
});
d1256 1
a1256 1
		next unless $entry =~ s/\.pm$//;
d1359 7
a1365 4
	    $CPAN::Frontend->myprint("Valid options for debug are ".
				     join(", ",sort(keys %CPAN::DEBUG), 'all').
		    qq{ or a number. Completion works on the options. }.
			qq{Case is ignored.\n\n});
d1427 1
a1427 1
    my $isaperl = q{perl5[._-]\\d{3}(_[0-4][0-9])?\\.tar[._-]gz$};
d1631 17
a1647 5
	    for $obj ( sort {$a->id cmp $b->id} $CPAN::META->all_objects($class)) {
		push @@m, $obj
		    if
			$obj->id =~ /$regex/i
			    or
d1650 2
a1651 1
			  $] < 5.00303 ### provide sort of compatibility with 5.003
d1658 1
a1658 1
	    }
d1752 9
d1771 1
d1848 2
d2026 3
d2082 1
a2082 1
		$l =~ s|^/|| unless -f $l;          # e.g. /P:
d2109 3
d2113 1
a2113 1
	  } elsif ($url !~ /\.gz$/) {
d2150 1
a2150 1
		if ($aslocal !~ /\.gz$/) {
d2186 2
a2187 2
	    $CPAN::Frontend->myprint("Skipping $url (not reachable)\n");
	    next;
d2197 2
a2198 2
	    # proto not yet used
	    ($proto,$host,$dir,$getfile) = ($1,$2,$3,$4);
d2200 1
a2200 1
	    next HOSTHARD; # who said, we could ftp anything except ftp?
d2202 1
d2206 56
a2261 10
	    next unless exists $CPAN::Config->{$f};
	    $funkyftp = $CPAN::Config->{$f};
	    next unless defined $funkyftp;
	    next if $funkyftp =~ /^\s*$/;
	    my($want_compressed);
	    my $aslocal_uncompressed;
	    ($aslocal_uncompressed = $aslocal) =~ s/\.gz//;
	    my($source_switch) = "";
	    $source_switch = " -source" if $funkyftp =~ /\blynx$/;
	    $source_switch = " -c" if $funkyftp =~ /\bncftp$/;
d2263 1
a2263 1
		  qq[
d2265 1
a2265 1
    $url
d2267 2
a2268 2
	    my($system) = "$funkyftp$source_switch '$url' $devnull > ".
		"$aslocal_uncompressed";
d2273 1
a2273 2
		-s $aslocal_uncompressed   # lynx returns 0 on my
                                           # system even if it fails
d2275 4
a2278 40
		if ($aslocal_uncompressed ne $aslocal) {
		  # test gzip integrity
		  if (
		      CPAN::Tarzip->gtest($aslocal_uncompressed)
		     ) {
		    rename $aslocal_uncompressed, $aslocal;
		  } else {
		    CPAN::Tarzip->gzip($aslocal_uncompressed,
				     "$aslocal_uncompressed.gz");
		  }
		}
		$Thesite = $i;
		return $aslocal;
	    } elsif ($url !~ /\.gz$/) {
	      unlink $aslocal_uncompressed if
		  -f $aslocal_uncompressed && -s _ == 0;
	      my $gz = "$aslocal.gz";
	      my $gzurl = "$url.gz";
	      $CPAN::Frontend->myprint(
		      qq[
Trying with "$funkyftp$source_switch" to get
  $url.gz
]);
	      my($system) = "$funkyftp$source_switch '$url.gz' $devnull > ".
		  "$aslocal_uncompressed.gz";
	      $self->debug("system[$system]") if $CPAN::DEBUG;
	      my($wstatus);
	      if (($wstatus = system($system)) == 0
		  &&
		  -s "$aslocal_uncompressed.gz"
		 ) {
		# test gzip integrity
		if (CPAN::Tarzip->gtest("$aslocal_uncompressed.gz")) {
		  CPAN::Tarzip->gunzip("$aslocal_uncompressed.gz",
				       $aslocal);
		} else {
		  rename $aslocal_uncompressed, $aslocal;
		}
		$Thesite = $i;
		return $aslocal;
d2280 1
a2280 2
		unlink "$aslocal_uncompressed.gz" if
		    -f "$aslocal_uncompressed.gz";
d2282 2
d2285 9
a2293 3
		my $estatus = $wstatus >> 8;
		my $size = -f $aslocal ? ", left\n$aslocal with size ".-s _ : "";
		$CPAN::Frontend->myprint(qq{
d2297 1
a2297 1
	    }
a2324 1
	my($netrcfile,$fh);
d2330 1
d2343 1
a2343 1
	if (! $netrc->netrc) {
d2580 1
a2580 1
			       make test install force reload look
d2583 1
a2583 1
    } elsif ( $line !~ /^[\!abdhimorutl]/ ) {
d2591 1
a2591 1
    } elsif ($line =~ /^([mru]|make|clean|test|install|readme|look)\s/ ) {
d2669 1
a2669 1
	$_ = 0.001 unless $_ > 0.001;
d2673 5
d2797 1
a2797 1
	# if it is a bundle, instatiate a bundle object
d2810 1
d2854 14
a2867 6
	unless ($CPAN::META->exists('CPAN::Distribution',$dist)) {
	    $CPAN::META->instance(
				  'CPAN::Distribution' => $dist
				 )->set(
					'CPAN_USERID' => $userid
				       );
d2960 7
a2966 1
	    push @@m, sprintf "    %-12s %s%s\n", $_, "@@{$self->{$_}}", $extra;
d2968 1
a2968 1
	    push @@m, sprintf "    %-12s %s%s\n", $_, $self->{$_}, $extra;
d2980 6
d3013 19
d3081 1
a3081 1
    } elsif ($local_file =~ /(\.tar\.(gz|Z)|\.tgz)$/i){
d3083 1
a3083 1
    } elsif ( $local_file =~ /\.zip$/i ) {
d3085 1
a3085 1
    } elsif ( $local_file =~ /\.pm\.(gz|Z)$/) {
d3096 1
a3096 1
	my @@readdir = grep $_ !~ /^\.\.?$/, $dh->read; ### MAC??
d3186 1
a3186 1
    $to =~ s/\.(gz|Z)$//;
d3237 38
d3346 1
a3346 1
	    $lc_file =~ s/\.gz$//;
d3393 1
a3393 1
	  while ($fh->READ($ref, 4096)){
d3457 1
a3457 1
  writemakefile have_sponsored
d3471 2
a3472 2
			    $
			  }x;
d3538 2
a3539 2
	    $self->{writemakefile} eq "NO" and push @@e,
	    "Had some problem writing Makefile";
d3596 1
a3596 1
		$self->{writemakefile} = "NO - $@@";
d3603 1
a3603 1
	    $self->{writemakefile} = "NO";
d3607 10
a3616 1
	$self->{writemakefile} = "YES";
d3650 1
a3650 1
	 $self->{writemakefile} = "YES";
d3683 1
a3683 1
    if ($self->{'have_sponsored'}{$p}++){
d3866 1
a3866 1
  my $inpod = 0;
d3869 3
a3871 3
    $inpod = m/^=(?!head1\s+CONTENTS)/ ? 0 :
	m/^=head1\s+CONTENTS/ ? 1 : $inpod;
    next unless $inpod;
d3873 1
d3919 1
a3919 1
	$what2 =~ s|Bundle/||;
d3985 8
a3992 3
	    $CPAN::Frontend->myprint(qq{\nBundle summary: }.
				     qq{The following items seem to }.
				     qq{have had installation problems:\n});
d3994 1
a3994 1
		$CPAN::Frontend->myprint( "$s " ) if $fail{$s};
d3996 2
a3997 1
	    $CPAN::Frontend->myprint(qq{\n});
d4127 1
a4127 1
  $local_file =~ s/\.pm$/.pod/;
d4227 2
d4309 1
a4309 1
    $have =~ s/\s+//g;
d4392 1
a4392 1
    return undef if $bytesread == 0;
d4420 1
a4420 1
    $fh->close;
d4431 22
a4452 19
    if ($^O =~ /win/i) { # irgggh
	# people find the most curious tar binaries that cannot handle
	# pipes
	my $system = "$CPAN::Config->{'gzip'} --decompress $file";
	if (system($system)==0) {
	    $CPAN::Frontend->myprint(qq{Uncompressed $file successfully\n});
	} else {
	    $CPAN::Frontend->mydie(
				   qq{Couldn\'t uncompress $file\n}
				  );
	}
	$file =~ s/\.gz$//;
	$system = "$CPAN::Config->{tar} xvf $file";
	if (system($system)==0) {
	    $CPAN::Frontend->myprint(qq{Untarred $file successfully\n});
	} else {
	    $CPAN::Frontend->mydie(qq{Couldn\'t untar $file\n});
	}
	return 1;
d4454 1
a4454 3
	my $system = "$CPAN::Config->{'gzip'} --decompress --stdout " .
	    "< $file | $CPAN::Config->{tar} xvf -";
	return system($system) == 0;
d4510 2
a4511 2
'bundles' of modules. Bundles simplify the handling of sets of
related modules. See BUNDLES below.
d4562 4
a4565 19
item is displayed. If the search finds one item, the result is displayed
as object-E<gt>as_string, but if we find more than one, we display
each as object-E<gt>as_glimpse. E.g.

    cpan> a ANDK
    Author id = ANDK
	EMAIL        a.koenig@@franz.ww.TU-Berlin.DE
	FULLNAME     Andreas Knig


    cpan> a /andk/
    Author id = ANDK
	EMAIL        a.koenig@@franz.ww.TU-Berlin.DE
	FULLNAME     Andreas Knig


    cpan> a /and.*rt/
    Author          ANDYD (Andy Dougherty)
    Author          MERLYN (Randal L. Schwartz)
d4569 1
a4569 1
These commands take any number of arguments and investigates what is
d4611 1
a4611 1
=item readme, look module or distribution
d4613 3
a4615 4
These two commands take only one argument, be it a module or a
distribution file. C<readme> unconditionally runs, displaying the
README of the associated distribution file. C<Look> gets and
untars (if not yet done) the distribution file, changes to the
d4716 2
a4717 2
listings of modules (C<r>, C<autobundle>, C<u>) returns a list of the
IDs of all modules within the list.
d4752 35
d4904 1
a4904 1
with this floppy.
a4926 1
  keep_source        keep the source in a local directory?
d4950 1
a4950 1
=item o conf E<lt>scalar optionE<gt>
d4954 1
a4954 1
=item o conf E<lt>scalar optionE<gt> E<lt>valueE<gt>
d4958 1
a4958 1
=item o conf E<lt>list optionE<gt>
d4963 1
a4963 1
=item o conf E<lt>list optionE<gt> [shift|pop]
d4967 1
a4967 1
=item o conf E<lt>list optionE<gt> [unshift|push|splice] E<lt>listE<gt>
d4973 11
d5028 1
a5028 1
file for all modules that re installed for the currently running perl
d5035 1
a5035 1
then answer a few questions and then go out.
d5037 10
a5046 9
Maintaining a bundle definition file means to keep track of two things:
dependencies and interactivity. CPAN.pm (currently) does not take into
account dependencies between distributions, so a bundle definition file
should specify distributions that depend on others B<after> the others.
On the other hand, it's a bit annoying that many distributions need some
interactive configuring. So what I try to accomplish in my private bundle
file is to have the packages that need to be configured early in the file
and the gentle ones later, so I can go out after a few minutes and leave
CPAN.pm unattained.
d5050 2
a5051 1
Thanks to Graham Barr for contributing the firewall following howto.
d5070 4
a5073 4
This where the firewall machine runs a ftp server. This kind of firewall will
only let you access ftp serves outside the firewall. This is usually done by
connecting to the firewall with ftp, then entering a username like
"user@@outside.host.com"
d5110 1
a5110 1
We should give coverage for _all_ of the CPAN and not just the PAUSE
d5125 1
a5125 1
Andreas Knig E<lt>a.koenig@@kulturbox.deE<gt>
@


1.1
log
@perl 5.004_04
@
text
@d2 2
a3 1
use vars qw{$Try_autoload $Revision
d6 2
a7 2
	    $Frontend
	   };
d9 1
a9 1
$VERSION = '1.3102';
d11 1
a11 1
# $Id: CPAN.pm,v 1.202 1997/09/23 18:30:36 k Exp k $
d15 1
a15 1
# $Revision = "[".substr(q$Revision: 1.202 $, 10)."]";
d22 1
a22 1
use ExtUtils::MakeMaker ();
d31 1
d35 1
a35 1
%CPAN::DEBUG = qw(
d49 2
a50 1
		 );
d55 1
d61 1
a61 7
@@CPAN::ISA = qw(CPAN::Debug Exporter MM); # MM will go away
                                          # soonish. Already version
                                          # 1.29 doesn't rely on
                                          # catfile and catdir being
                                          # available via
                                          # inheritance. Anything else
                                          # in danger?
d74 1
d92 1
d94 1
d102 14
a115 2
	$readline::rl_completion_function =
	    $readline::rl_completion_function = 'CPAN::Complete::cpl';
d123 1
d146 2
a147 2
	$_ = 'h' if $_ eq '?';
	if (/^q(?:uit)?$/i) {
d182 15
a196 1
	&cleanup, $CPAN::Frontend->mydie("Goodbye\n") if $Signal;
a200 1
use vars qw($Du);
d250 1
d259 1
a259 1
For this you just need to type 
d289 1
a289 1
		$name = undef unless (-r $name); 
d304 1
a304 1
	    if ($name =~ s/(\w{12,})\.al$/substr($1,0,11).".al"/e){
d315 3
a317 1
	$ok = 1;
d334 1
a334 1
    my $p;
d344 122
d469 1
a469 5
$META ||= CPAN->new;                 # In case we reeval ourselves we
                                    # need a ||

# Do this after you have set up the whole inheritance
CPAN::Config->load unless defined $CPAN::No_Config_is_ok;
d493 1
a493 1
sub all {
d495 1
d500 1
d573 2
a574 2
	&cleanup;
	$CPAN::Frontend->mydie("Got SIGTERM, leaving");
d577 5
a581 3
	my $s = $Signal == 2 ? "a second" : "another";
	&cleanup, $CPAN::Frontend->mydie("Got $s SIGINT") if $Signal;
	$Signal = 1;
d607 6
d630 5
a634 1
#	warn "$file in %INC"; #debug
d641 1
d662 2
d683 24
a706 10
    local $SIG{__DIE__} = '';
    my $i = 0; my $ineval = 0; my $sub;
    while ((undef,undef,undef,$sub) = caller(++$i)) {
      $ineval = 1, last if $sub eq '(eval)';
    }
    return if $ineval && !$End;
    return unless defined $META->{'LOCK'};
    return unless -f $META->{'LOCK'};
    unlink $META->{'LOCK'};
    $CPAN::Frontend->mywarn("Lockfile removed.\n");
d726 15
a740 19
# sub check {
#     my($self,@@dirs) = @@_;
#     return unless -d $self->{ID};
#     my $dir;
#     @@dirs = $self->dirs unless @@dirs;
#     for $dir (@@dirs) {
# 	  $self->disk_usage($dir);
#     }
# }

#-> sub CPAN::CacheMgr::clean_cache ;
#=# sub clean_cache {
#=# 	my $self = shift;
#=# 	my $dir;
#=# 	while ($self->{DU} > $self->{'MAX'} and $dir = shift @@{$self->{FIFO}}) {
#=# 	    $self->force_clean_cache($dir);
#=# 	}
#=# 	$self->debug("leaving clean_cache with $self->{DU}") if $CPAN::DEBUG;
#=# }
d757 2
a758 1
    my $dh = DirHandle->new(".") or Carp::croak("Couldn't opendir $dir: $!");
d777 3
a779 6
#    if (! defined $dir or $dir eq "") {
#	$self->debug("Cannot determine disk usage for some reason") if $CPAN::DEBUG;
#	return;
#    }
    return if $self->{SIZE}{$dir};
    local($Du) = 0;
d782 9
a790 2
	     return if -l $_;
	     $Du += -s _;
d794 1
a798 10
    if ($self->{DU} > $self->{'MAX'} ) {
	my($toremove) = shift @@{$self->{FIFO}};
	$CPAN::Frontend->myprint(sprintf(
					 "...Hold on a sec... ".
					 "cleaning from cache ".
					 "(%.1f>%.1f MB): $toremove\n",
					 $self->{DU}, $self->{'MAX'})
				);
	$self->force_clean_cache($toremove);
    }
d805 1
d822 1
d828 1
a828 6
    $self->debug("dir [$self->{ID}]") if $CPAN::DEBUG;
    my $e;
    for $e ($self->entries) {
	next if $e eq ".." || $e eq ".";
	$self->disk_usage($e);
    }
d836 18
d932 1
a932 1
	$configpm || Carp::confess(qq{
d948 1
a948 1
# This is CPAN.pm's systemwide configuration file.  This file provides
d956 1
d1001 1
d1004 3
a1006 2
    unshift @@INC, MM->catdir($ENV{HOME},".cpan") unless $dot_cpan++;
    eval {require CPAN::MyConfig;};     # where you can override
d1008 2
d1066 1
a1066 1
    $CPAN::Frontend->myprint(qq{
d1070 1
a1070 1
}) if $redo && ! $theycalled;
d1082 4
a1085 3
	    cpan_home keep_source_where build_dir build_cache index_expire
	    gzip tar unzip make pager makepl_arg make_arg make_install_arg
	    urllist inhibit_startup_message ftp_proxy http_proxy no_proxy
a1097 1
*h = \&help;
d1100 1
a1100 1
    $CPAN::Frontend->myprint(qq{
d1116 1
a1116 1
});
d1127 7
a1133 3
	$words[2] =~ /list$/ && @@words == 3
	||
	$words[2] =~ /list$/ && @@words == 4 && length($word) 
d1178 2
d1203 3
a1205 1
sub m { $CPAN::Frontend->myprint(shift->format_result('Module',@@_));}
d1234 8
a1241 1
	    $CPAN::Frontend->myprint("CPAN::Config options:\n");
d1320 15
a1343 1
	undef $/;
d1345 1
a1345 10
	local($SIG{__WARN__})
	    = sub {
		if ( $_[0] =~ /Subroutine \w+ redefined/ ) {
		    ++$redef;
		    local($|) = 1;
		    $CPAN::Frontend->myprint(".");
		    return;
		}
		warn @@_;
	    };
d1350 1
a1350 1
	CPAN::Index->force_reload;
d1352 2
a1353 3
	$CPAN::Frontend->myprint(qq{cpan     re-evals the CPAN.pm file
index    re-reads the index files
});
d1418 1
d1508 1
d1565 1
a1565 1
	    for $obj ( sort {$a->id cmp $b->id} $CPAN::META->all($class)) {
d1627 2
a1628 1
	for my $line (split /\n/, $what) {
d1674 1
d1686 3
d1702 1
a1702 1
			qq{pragma[$pragma] meth[$meth] obj[$obj] as_string\[}.
d1710 10
a1719 2
		    ($] < 5.00303 || $obj->can($pragma)); ### compatibility with 5.003
	    $obj->$meth();
d1729 3
a1731 1
	    $CPAN::Frontend->myprint(qq{Warning: Cannot $meth $s, don\'t know what it is.
d1739 1
d1764 3
a1766 3
    my($class,$host,$dir,$file,$target) = @@_;
    $class->debug(
		       qq[Going to fetch file [$file] from dir [$dir]
d1769 53
a1821 22
    my $ftp = Net::FTP->new($host);
    return 0 unless defined $ftp;
    $ftp->debug(1) if $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG;
    $class->debug(qq[Going to ->login("anonymous","$Config::Config{'cf_email'}")\n]);
    unless ( $ftp->login("anonymous",$Config::Config{'cf_email'}) ){
	warn "Couldn't login on $host";
	return;
    }
    unless ( $ftp->cwd($dir) ){
	warn "Couldn't cwd $dir";
	return;
    }
    $ftp->binary;
    $class->debug(qq[Going to ->get("$file","$target")\n]) if $CPAN::DEBUG;
    unless ( $ftp->get($file,$target) ){
	warn "Couldn't fetch $file from $host\n";
	return;
    }
    $ftp->quit; # it's ok if this fails
    return 1;
}

d1827 4
a1830 2
    return 1 unless $url =~ m|://([^/]+)|;
    my $host = $1;
d1834 4
d1839 2
a1840 1
    eval {$p = Net::Ping->new("tcp");} if $@@;
d1842 1
a1842 1
    return $p->ping($host, 3);
d1856 14
d1885 1
a1885 1
    if ($CPAN::META->has_inst('LWP')) {
d1902 1
a1902 1
#line 1621
d1910 1
a1910 1
		    <=> 
a1918 5

#	    ((grep { substr($CPAN::Config->{urllist}[$_],0,4)
#			 eq "file" } 0..$last),
#	     (grep { substr($CPAN::Config->{urllist}[$_],0,4)
#			 ne "file" } 0..$last));
d1926 1
d1931 1
d1934 5
a1938 3
	    $Themethod = $level;
	    $self->debug("level[$level]") if $CPAN::DEBUG;
	    return $ret;
d1963 1
a1963 1
	my $url = $CPAN::Config->{urllist}[$i];
d1984 5
a1988 2
		($l = $url) =~ s,^file://[^/]+,,; # discard the host part
		$l =~ s/^file://;	# assume they meant file://localhost
d1997 1
a1997 1
		system("$CPAN::Config->{gzip} -dc $l.gz > $aslocal");
d2004 2
a2005 2
	if ($CPAN::META->has_inst('LWP')) {
	    $CPAN::Frontend->myprint("Fetching with LWP:
d2008 11
a2018 7
	    my $res = $Ua->mirror($url, $aslocal);
	    if ($res->is_success) {
		$Thesite = $i;
		return $aslocal;
	    } elsif ($url !~ /\.gz$/) {
		my $gzurl = "$url.gz";
		$CPAN::Frontend->myprint("Fetching with LWP:
d2021 6
a2026 8
		$res = $Ua->mirror($gzurl, "$aslocal.gz");
		if ($res->is_success &&
		    system("$CPAN::Config->{gzip} -d $aslocal.gz")==0) {
		    $Thesite = $i;
		    return $aslocal;
		} else {
		    next HOSTEASY ;
		}
d2028 1
a2028 1
		next HOSTEASY ;
d2030 8
d2045 1
a2045 1
  $aslocal
d2056 1
a2056 1
   $gz
d2058 6
a2063 5
		    if (CPAN::FTP->ftp_get($host,
				       $dir,
				       "$getfile.gz",
				       $gz) &&
			system("$CPAN::Config->{gzip} -d $gz")==0 ){
d2068 1
a2068 1
		next HOSTEASY;
d2075 1
a2075 1
    my($self,$host_seq,$file,$aslocal) = @@_;
d2077 9
a2085 7
    # Came back if Net::FTP couldn't establish connection (or
    # failed otherwise) Maybe they are behind a firewall, but they
    # gave us a socksified (or other) ftp program...

    my($i);
    my($aslocal_dir) = File::Basename::dirname($aslocal);
    File::Path::mkpath($aslocal_dir);
d2087 1
a2087 1
	my $url = $CPAN::Config->{urllist}[$i];
d2094 8
a2101 3
	my($host,$dir,$getfile);
	if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
	    ($host,$dir,$getfile) = ($1,$2,$3);
d2107 1
a2107 1
	for $f ('lynx','ncftp') {
d2116 2
a2117 2
	    $source_switch = "-source" if $funkyftp =~ /\blynx$/;
	    $source_switch = "-c" if $funkyftp =~ /\bncftp$/;
d2119 2
a2120 2
		  qq{
Trying with "$funkyftp $source_switch" to get
d2122 2
a2123 2
});
	    my($system) = "$funkyftp $source_switch '$url' > ".
d2133 9
a2141 12
		    # test gzip integrity
		    $system =
			"$CPAN::Config->{'gzip'} -dt $aslocal_uncompressed";
		    if (system($system) == 0) {
			rename $aslocal_uncompressed, $aslocal;
		    } else {
			$system =
			    "$CPAN::Config->{'gzip'} $aslocal_uncompressed";
			system($system);
		    }
		    $Thesite = $i;
		    return $aslocal;
d2143 2
d2146 7
a2152 5
		my $gz = "$aslocal.gz";
		my $gzurl = "$url.gz";
		$CPAN::Frontend->myprint(
		      qq{
Trying with "$funkyftp $source_switch" to get
d2154 15
a2168 24
});
		my($system) = "$funkyftp $source_switch '$url.gz' > ".
		    "$aslocal_uncompressed.gz";
		$self->debug("system[$system]") if $CPAN::DEBUG;
		my($wstatus);
		if (($wstatus = system($system)) == 0
		    &&
		    -s "$aslocal_uncompressed.gz"
		   ) {
		    # test gzip integrity
		    $system =
			"$CPAN::Config->{'gzip'} -dt $aslocal_uncompressed.gz";
		    $CPAN::Frontend->mywarn("system[$system]");
		    if (system($system) == 0) {
			$system = "$CPAN::Config->{'gzip'} -dc ".
			    "$aslocal_uncompressed.gz > $aslocal";
			$CPAN::Frontend->mywarn("system[$system]");
			system($system);
		    } else {
			rename $aslocal_uncompressed, $aslocal;
		    }
#line 1739
		    $Thesite = $i;
		    return $aslocal;
d2170 6
d2199 1
a2199 1
	my $url = $CPAN::Config->{urllist}[$i];
d2264 1
a2264 1
	
a2301 1
    
d2306 1
d2428 21
d2494 1
a2494 1
    grep /^\Q$word\E/, map { $_->id } $CPAN::META->all($class);
d2564 7
a2570 4
    $cl->rd_authindex($cl->reload_x(
				    "authors/01mailrc.txt.gz",
				    $needshort ? "01mailrc.gz" : "",
				    $force));
d2575 7
a2581 4
    $cl->rd_modpacks($cl->reload_x(
				   "modules/02packages.details.txt.gz",
				   $needshort ? "02packag.gz" : "",
				   $force));
d2586 7
a2592 4
    $cl->rd_modlist($cl->reload_x(
				  "modules/03modlist.data.gz",
				  $needshort ? "03mlist.gz" : "",
				  $force));
d2625 2
a2626 1
    my($cl,$index_target) = @@_;
a2627 1
    my $pipe = "$CPAN::Config->{gzip} --decompress --stdout $index_target";
d2629 8
a2636 3
    my $fh = FileHandle->new("$pipe|");
    while (<$fh>) {
	chomp;
d2638 1
a2638 1
	    /alias\s+(\S+)\s+\"([^\"\<]+)\s+<([^\>]+)\>\"/;
d2646 7
a2652 2
    $fh->close;
    $? and Carp::croak "FAILED $pipe: exit status [$?]";
d2657 2
a2658 1
    my($cl,$index_target) = @@_;
a2659 1
    my $pipe = "$CPAN::Config->{gzip} --decompress --stdout $index_target";
d2661 11
a2671 3
    my $fh = FileHandle->new("$pipe|");
    while (<$fh>) {
	last if /^\s*$/;
d2673 1
a2673 1
    while (<$fh>) {
d2678 1
a2678 1
	# if it as a bundle, instatiate a bundle object
d2680 7
a2686 2
	
	if ($mod eq 'CPAN') {
d2692 1
a2692 1
    install CPAN
d2707 1
d2711 1
d2725 1
a2725 2
	    # determine the author
	    ($userid) = $dist =~ /([^\/]+)/;
d2744 1
a2744 2
    $fh->close;
    $? and Carp::croak "FAILED $pipe: exit status [$?]";
a2750 1
    my $pipe = "$CPAN::Config->{gzip} --decompress --stdout $index_target";
d2752 12
a2763 4
    my $fh = FileHandle->new("$pipe|");
    my $eval;
    while (<$fh>) {
	if (/^Date:\s+(.*)/){
d2767 1
a2767 1
	last if /^\s*$/;
d2769 2
a2770 4
    local($/) = undef;
    $eval = <$fh>;
    $fh->close;
    $eval .= q{CPAN::Modulelist->data;};
d2773 1
d2819 13
a2831 2
	$_ eq "CPAN_USERID" and $extra = " (".$self->author.")";
	if (ref($self->{$_}) eq "ARRAY") { # Should we setup a language interface? XXX
d2867 1
d2931 1
a2931 1
    chdir "..";
d2933 1
a2933 1
	chdir "tmp";
d2935 2
a2936 1
	my $dh = DirHandle->new(".") or Carp::croak("Couldn't opendir .: $!");
d2959 1
a2959 1
	chdir "..";
d2970 16
a2985 9
	    my($configure) = MM->catfile($packagedir,"Configure");
	    if (-f $configure) {
		# do we have anything to do?
		$self->{'configure'} = $configure;
	    } else {
		my $fh = FileHandle->new(">$makefilepl")
		    or Carp::croak("Could not open >$makefilepl");
		my $cf = $self->called_for || "unknown";
		$fh->print(
d2990 2
a2991 2
		    use ExtUtils::MakeMaker;
		    WriteMakefile(NAME => q[$cf]);
d2994 2
a2995 2
		$CPAN::Frontend->myprint(qq{Package comes without Makefile.PL.\n}.
		    qq{  Writing one on our own (calling it $cf)\n});
d3005 1
a3005 3
    my $system = "$CPAN::Config->{gzip} --decompress --stdout " .
	"$local_file | $CPAN::Config->{tar} xvf -";
    if (system($system)== 0) {
d3028 1
a3028 3
    my $system = "$CPAN::Config->{gzip} --decompress --stdout ".
	"$local_file > $to";
    if (system($system) == 0) {
d3048 6
d3096 6
a3148 2
	    my @@system = ($CPAN::Config->{gzip}, '--decompress', $lc_file);
	    system(@@system) == 0 or die "Could not uncompress $lc_file";
d3150 1
d3168 1
d3179 2
a3180 1
    if ($cksum->{$basename}->{md5}) {
d3182 24
a3205 14
		     "$cksum->{$basename}->{md5}\n") if $CPAN::DEBUG;
	my $pipe = "$CPAN::Config->{gzip} --decompress ".
	    "--stdout $file|";
	if (
	    open($fh, $file) &&
	    binmode $fh &&
	    $self->eq_MD5($fh,$cksum->{$basename}->{md5})
	    or
	    open($fh, $pipe) &&
	    binmode $fh  &&
	    $self->eq_MD5($fh,$cksum->{$basename}->{'md5-ungz'})
	   ){
	    $CPAN::Frontend->myprint("Checksum for $file ok\n");
	    return $self->{MD5_STATUS} = "OK";
d3216 2
a3217 2
be a bogus file.  Maybe you have configured your \`urllist\' with a
bad URL.  Please check this array with \`o conf urllist\', and
d3224 1
a3224 1
	close $fh if fileno($fh);
d3244 5
a3248 1
    $md5->addfile($fh);
d3250 1
d3256 21
a3276 10
    my($self) = @@_;
    $self->{'force_update'}++;
    delete $self->{'MD5_STATUS'};
    delete $self->{'archived'};
    delete $self->{'build_dir'};
    delete $self->{'localfile'};
    delete $self->{'make'};
    delete $self->{'install'};
    delete $self->{'unwrapped'};
    delete $self->{'writemakefile'};
d3308 23
d3354 5
d3361 1
a3361 1
	$system = $self->{'configure'};
d3371 1
a3371 1
    {
d3378 1
a3378 1
		local $SIG{CHLD} = sub { wait };
d3381 2
a3382 1
			wait;
d3384 4
a3387 1
			exec $system;
d3404 5
a3408 5
	    $ret = system($system);
	    if ($ret != 0) {
		$self->{writemakefile} = "NO";
		return;
	    }
d3410 1
a3411 1
    $self->{writemakefile} = "YES";
d3413 26
d3450 38
d3510 6
d3538 6
d3586 6
d3594 2
a3595 1
    my($pipe) = FileHandle->new("$system 2>&1 |");
d3604 1
a3604 1
	 $self->{'install'} = "YES";
d3632 52
a3683 44
    my($self) = @@_;
    my($parsefile) = $self->inst_file;
    my($id) = $self->id;
    $self->debug("parsefile[$parsefile]id[$id]") if $CPAN::DEBUG;
    unless ($parsefile) {
	# Try to get at it in the cpan directory
	$self->debug("no parsefile") if $CPAN::DEBUG;
	Carp::confess "I don't know a $id" unless $self->{CPAN_FILE};
	my $dist = $CPAN::META->instance('CPAN::Distribution',
					 $self->{CPAN_FILE});
	$dist->get;
	$self->debug($dist->as_string) if $CPAN::DEBUG;
	my($todir) = $CPAN::Config->{'cpan_home'};
	my(@@me,$from,$to,$me);
	@@me = split /::/, $self->id;
	$me[-1] .= ".pm";
	$me = MM->catfile(@@me);
	$from = $self->find_bundle_file($dist->{'build_dir'},$me);
	$to = MM->catfile($todir,$me);
	File::Path::mkpath(File::Basename::dirname($to));
	File::Copy::copy($from, $to)
	    or Carp::confess("Couldn't copy $from to $to: $!");
	$parsefile = $to;
    }
    my @@result;
    my $fh = FileHandle->new;
    local $/ = "\n";
    open($fh,$parsefile) or die "Could not open '$parsefile': $!";
    my $inpod = 0;
    $self->debug("parsefile[$parsefile]") if $CPAN::DEBUG;
    while (<$fh>) {
	$inpod = /^=(?!head1\s+CONTENTS)/ ? 0 :
	    /^=head1\s+CONTENTS/ ? 1 : $inpod;
	next unless $inpod;
	next if /^=/;
	next if /^\s+$/;
	chomp;
	push @@result, (split " ", $_, 2)[0];
    }
    close $fh;
    delete $self->{STATUS};
    $self->{CONTAINS} = join ", ", @@result;
    $self->debug("CONTAINS[@@result]") if $CPAN::DEBUG;
    @@result;
d3690 3
a3692 2
    my $bu = MM->catfile($where,$what);
    return $bu if -f $bu;
d3705 10
d3720 2
a3721 7
	    return MM->catfile($where,$bu);
	} elsif ($what =~ s|Bundle/||) { # retry if she managed to
                                         # have no Bundle directory
	    if ($file =~ m|\Q$what\E$|) {
		$bu = $file;
		return MM->catfile($where,$bu);
	    }
d3723 3
d3727 2
d3757 1
a3757 1
    my($s);
d3768 20
a3787 1
	$CPAN::META->instance($type,$s)->$meth();
d3807 4
a3810 1
sub install { shift->rematein('install',@@_); }
d3853 11
a3863 6
	    push @@m, sprintf(
			     $sprintf2,
			     'CPAN_USERID',
			     $userid,
			     $author->fullname
			    );
d3876 3
a3878 3
    @@statl{qw,? p c + o,}       = qw,unknown perl C C++ other,;
    @@stati{qw,? f r O,}         = qw,unknown functions
	references+ties object-oriented,;
d3896 2
a3897 17
    if ($local_file && ! exists $self->{MANPAGE}) {
	my $fh = FileHandle->new($local_file)
	    or Carp::croak("Couldn't open $local_file: $!");
	my $inpod = 0;
	my(@@result);
	local $/ = "\n";
	while (<$fh>) {
	    $inpod = /^=(?!head1\s+NAME)/ ? 0 :
		/^=head1\s+NAME/ ? 1 : $inpod;
	    next unless $inpod;
	    next if /^=/;
	    next if /^\s+$/;
	    chomp;
	    push @@result, $_;
	}
	close $fh;
	$self->{MANPAGE} = join " ", @@result;
d3911 27
d3950 4
a3953 4
	unless (defined $fullname) {
	    $CPAN::Frontend->mywarn(qq{Full name of author }.
				    qq{$self->{userid} not known});
	    return "Contact Author $self->{userid}";
d3955 1
a3955 1
	return "Contact Author $self->{userid} ($fullname)"
d3966 1
a3966 1
    $self->{'CPAN_VERSION'} = 'undef' 
d3990 13
a4002 2
    return if $cpan_file eq "N/A";
    return if $cpan_file =~ /^Contact Author/;
d4020 2
a4021 2
#-> sub CPAN::Module::install ;
sub install {
a4022 1
    my($doit) = 0;
d4030 20
a4049 13
    if (1){ # A block for scoping $^W, the if is just for the visual
            # appeal
	local($^W)=0;
	if ($inst_file
	    &&
	    $have >= $latest
	    &&
	    not exists $self->{'force_update'}
	   ) {
	    $CPAN::Frontend->myprint( $self->id. " is up to date.\n");
	} else {
	    $doit = 1;
	}
d4092 1
d4098 162
d4304 9
a4312 1
All methods provided are accessible in a programmer style and in an
d4321 1
a4321 1
which puts you into a readline interface. You will have most fun if
d4323 1
a4323 1
completion.
d4339 1
a4339 1
Arguments you pass to these commands are either strings matching exact
d4342 1
a4342 1
objects. The parser recognizes a regualar expression only if you
d4346 2
a4347 2
item is displayed. If the search finds one item, we display the result
of object-E<gt>as_string, but if we find more than one, we display
d4368 7
a4374 5
These commands do indeed exist just as written above. Each of them
takes any number of arguments and investigates for each what it might
be. Is it a distribution file (recognized by embedded slashes), this
file is being processed. Is it a module, CPAN determines the
distribution file where this module is included and processes that.
d4376 1
a4376 1
Any C<make>, C<test>, and C<readme> are run unconditionally. A
d4380 1
a4380 1
also is run unconditionally.  But for
d4385 2
a4386 1
I<Foo up to date> in case the module doesnE<39>t need to be updated.
d4390 2
a4391 2
succeeded or not. The C<force > command takes as first argument the
method to invoke (currently: make, test, or install) and executes the
d4404 6
d4413 16
a4428 4
distribution file. C<readme> displays the README of the associated
distribution file. C<Look> gets and untars (if not yet done) the
distribution file, changes to the appropriate directory and opens a
subshell process in that directory.
d4455 1
a4455 1
effect. Primary purpose of this command is to finish a network
d4462 1
a4462 2
will be glad to run recompile in the second architecture and
youE<39>re done.
d4471 7
a4477 7
Although it may be considered internal, the class hierarchie does
matter for both users and programmer. CPAN.pm deals with above
mentioned four classes, and all those classes share a set of
methods. It is a classical single polymorphism that is in effect.  A
metaclass object registers all objects of all kinds and indexes them
with a string. The strings referencing objects have a separated
namespace (well, not completely separated):
d4486 6
a4491 6
to the most recent official release. Developers may mark their
releases as unstable development versions (by inserting an underbar
into the visible version number), so not always is the default
distribution for a given module the really hottest and newest. If a
module Foo circulates on CPAN in both version 1.23 and 1.23_90,
CPAN.pm offers a convenient way to install version 1.23 by saying
d4496 2
a4497 2
BAR/Foo-1.23.tar.gz) with all accompanying material in there. But if
you would like to install version 1.23_90, you need to know where the
d4499 1
a4499 1
directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz,
d4513 1
a4513 1
There's currently only one class that has a stable interface,
d4554 1
a4554 1
=head2 Methods in the four
d4581 1
a4581 1
only difference, that I<one special pod section> exists starting with
d4591 1
a4591 1
(eg. Foo::Bar, ie. I<not> the name of the distribution file). The rest
d4600 1
a4600 1
the modules in the CONTENTS section of the pod.  You can install your
d4618 2
d4627 1
a4627 1
prerequisite can hardly be relaxed because it consumes by far too much
d4629 1
a4629 1
the $VERSION variable . Currently all programs that are dealing with
d4633 1
a4633 1
        'print MM->parse_version($ARGV[0])' filename
d4641 1
a4641 1
Makefile.PL (well we try to handle a bit more, but without much
d4655 1
a4655 1
useful for you as it's just a byproduct of my own testing, but if you
d4660 1
a4660 1
=head2 Floppy, Zip, and all that Jazz
d4673 1
a4673 1
When the CPAN module is installed a site wide configuration file is
d4685 1
a4685 1
  index_expire       after how many days refetch index files
d4688 1
a4688 1
  inactivity_timeout breaks interactive Makefile.PLs after that
d4693 2
a4694 2
  keep_source_where  where keep the source (if we do)
  make               location of external program make
d4699 4
d4706 4
d4739 1
a4739 1
=head2 CD-ROM support
d4754 8
d4769 1
a4769 1
development will go towards strong authentification.
d4777 84
d4863 4
a4866 4
we should give coverage for _all_ of the CPAN and not just the
PAUSE part, right? In this discussion CPAN and PAUSE have become
equal -- but they are not. PAUSE is authors/ and modules/. CPAN is
PAUSE plus the clpa/, doc/, misc/, ports/, src/, scripts/.
d4871 5
d4878 1
a4878 1
Andreas Knig E<lt>a.koenig@@mind.deE<gt>
@


1.1.1.1
log
@perl5.005_03
@
text
@d2 1
a2 2
use vars qw{$Try_autoload
            $Revision
d5 2
a6 2
	    $Frontend  $Defaultsite
	   }; #};
d8 1
a8 1
$VERSION = '1.48';
d10 1
a10 1
# $Id: CPAN.pm,v 1.260 1999/03/06 19:31:02 k Exp $
d14 1
a14 1
# $Revision = "[".substr(q$Revision: 1.260 $, 10)."]";
d21 1
a21 1
use ExtUtils::MakeMaker (); # $SelfLoader::DEBUG=1;
a29 1
use File::Spec;
d33 1
a33 1
%CPAN::DEBUG = qw[
d47 1
a47 2
		  Tarzip         8192
];
a51 1
$CPAN::Defaultsite ||= "ftp://ftp.perl.org/pub/CPAN";
d57 7
a63 1
@@CPAN::ISA = qw(CPAN::Debug Exporter);
a75 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
a92 1
    my($self) = @@_;
a93 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
d101 2
a102 14
	if ($term->ReadLine eq "Term::ReadLine::Gnu") {
	    my $attribs = $term->Attribs;
#	     $attribs->{completion_entry_function} =
#		 $attribs->{'list_completion_function'};
	     $attribs->{attempted_completion_function} = sub {
		 &CPAN::Complete::gnu_cpl;
	     }
#	    $attribs->{completion_word} =
#		[qw(help me somebody to find out how
#                    to use completion with GNU)];
	} else {
	    $readline::rl_completion_function =
		$readline::rl_completion_function = 'CPAN::Complete::cpl';
	}
a109 1
    my $try_detect_readline = $term->ReadLine eq "Term::ReadLine::Stub";
d132 2
a133 2
	$_ = 'h' if /^\s*\?/;
	if (/^(?:q(?:uit)?|bye|exit)$/i) {
d168 1
a168 15
      $Signal=0;
      CPAN::Queue->nullify_queue;
      if ($try_detect_readline) {
	if ($CPAN::META->has_inst("Term::ReadLine::Gnu")
	    ||
	    $CPAN::META->has_inst("Term::ReadLine::Perl")
	   ) {
	    delete $INC{"Term/ReadLine.pm"};
	    my $redef;
	    local($SIG{__WARN__}) = CPAN::Shell::dotdot_onreload(\$redef);
	    require Term::ReadLine;
	    $CPAN::Frontend->myprint("\n$redef subroutines in Term::ReadLine redefined\n");
	    goto &shell;
	}
      }
d173 1
a222 1
    # warn "autoload[$autoload] class[$class]";
d231 1
a231 1
For this you just need to type
d261 1
a261 1
		$name = undef unless (-r $name);
d276 1
a276 1
	    if ($name =~ s{(\w{12,})\.al$}{substr($1,0,11).".al"}e){
d287 1
a287 3

      $ok = 1;

d304 1
a304 1
  my $p;
a313 121
package CPAN::Tarzip;
use vars qw($AUTOLOAD @@ISA);
@@CPAN::Tarzip::ISA = qw(CPAN::Debug);

package CPAN::Queue;

# One use of the queue is to determine if we should or shouldn't
# announce the availability of a new CPAN module

# Now we try to use it for dependency tracking. For that to happen
# we need to draw a dependency tree and do the leaves first. This can
# easily be reached by running CPAN.pm recursively, but we don't want
# to waste memory and run into deep recursion. So what we can do is
# this:

# CPAN::Queue is the package where the queue is maintained. Dependencies
# often have high priority and must be brought to the head of the queue,
# possibly by jumping the queue if they are already there. My first code
# attempt tried to be extremely correct. Whenever a module needed
# immediate treatment, I either unshifted it to the front of the queue,
# or, if it was already in the queue, I spliced and let it bypass the
# others. This became a too correct model that made it impossible to put
# an item more than once into the queue. Why would you need that? Well,
# you need temporary duplicates as the manager of the queue is a loop
# that
#
#  (1) looks at the first item in the queue without shifting it off
#
#  (2) cares for the item
#
#  (3) removes the item from the queue, *even if its agenda failed and
#      even if the item isn't the first in the queue anymore* (that way
#      protecting against never ending queues)
#
# So if an item has prerequisites, the installation fails now, but we
# want to retry later. That's easy if we have it twice in the queue.
#
# I also expect insane dependency situations where an item gets more
# than two lives in the queue. Simplest example is triggered by 'install
# Foo Foo Foo'. People make this kind of mistakes and I don't want to
# get in the way. I wanted the queue manager to be a dumb servant, not
# one that knows everything.
#
# Who would I tell in this model that the user wants to be asked before
# processing? I can't attach that information to the module object,
# because not modules are installed but distributions. So I'd have to
# tell the distribution object that it should ask the user before
# processing. Where would the question be triggered then? Most probably
# in CPAN::Distribution::rematein.
# Hope that makes sense, my head is a bit off:-) -- AK

use vars qw{ @@All };

sub new {
  my($class,$mod) = @@_;
  my $self = bless {mod => $mod}, $class;
  push @@All, $self;
  # my @@all = map { $_->{mod} } @@All;
  # warn "Adding Queue object for mod[$mod] all[@@all]";
  return $self;
}

sub first {
  my $obj = $All[0];
  $obj->{mod};
}

sub delete_first {
  my($class,$what) = @@_;
  my $i;
  for my $i (0..$#All) {
    if (  $All[$i]->{mod} eq $what ) {
      splice @@All, $i, 1;
      return;
    }
  }
}

sub jumpqueue {
  my $class = shift;
  my @@what = @@_;
  my $obj;
  WHAT: for my $what (reverse @@what) {
    my $jumped = 0;
    for (my $i=0; $i<$#All;$i++) { #prevent deep recursion
      if ($All[$i]->{mod} eq $what){
	$jumped++;
	if ($jumped > 100) { # one's OK if e.g. just processing now;
                             # more are OK if user typed it several
                             # times
	  $CPAN::Frontend->mywarn(
qq{Object [$what] queued more than 100 times, ignoring}
				 );
	  next WHAT;
	}
      }
    }
    my $obj = bless { mod => $what }, $class;
    unshift @@All, $obj;
  }
}

sub exists {
  my($self,$what) = @@_;
  my @@all = map { $_->{mod} } @@All;
  my $exists = grep { $_->{mod} eq $what } @@All;
  # warn "Checking exists in Queue object for mod[$what] all[@@all] exists[$exists]";
  $exists;
}

sub delete {
  my($self,$mod) = @@_;
  @@All = grep { $_->{mod} ne $mod } @@All;
  # my @@all = map { $_->{mod} } @@All;
  # warn "Deleting Queue object for mod[$mod] all[@@all]";
}

sub nullify_queue {
  @@All = ();
}

d315 1
d317 2
a318 1
package CPAN;
d320 2
a321 1
$META ||= CPAN->new; # In case we re-eval ourselves we need the ||
d345 1
a345 1
sub all_objects {
a346 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
a350 1
*all = \&all_objects;
d423 2
a424 2
      &cleanup;
      $CPAN::Frontend->mydie("Got SIGTERM, leaving");
d427 3
a429 5
      # no blocks!!!
      &cleanup if $Signal;
      $CPAN::Frontend->mydie("Got another SIGINT") if $Signal;
      print "Caught SIGINT\n";
      $Signal++;
a454 6
#-> sub CPAN::delete ;
sub delete {
  my($mgr,$class,$id) = @@_;
  delete $META->{$class}{$id};
}

d472 1
a472 5
	# checking %INC is wrong, because $INC{LWP} may be true
	# although $INC{"URI/URL.pm"} may have failed. But as
	# I really want to say "bla loaded OK", I have to somehow
	# cache results.
	### warn "$file in %INC"; #debug
a478 1

a498 2
    } else {
	delete $INC{$file}; # if it inc'd LWP but failed during, say, URI
d518 10
a527 24
  # warn "cleanup called with arg[@@_] End[$End] Signal[$Signal]";
  local $SIG{__DIE__} = '';
  my($message) = @@_;
  my $i = 0;
  my $ineval = 0;
  if (
      0 &&           # disabled, try reload cpan with it
      $] > 5.004_60  # thereabouts
     ) {
    $ineval = $^S;
  } else {
    my($subroutine);
    while ((undef,undef,undef,$subroutine) = caller(++$i)) {
      $ineval = 1, last if
	  $subroutine eq '(eval)';
    }
  }
  return if $ineval && !$End;
  return unless defined $META->{'LOCK'};
  return unless -f $META->{'LOCK'};
  unlink $META->{'LOCK'};
  # require Carp;
  # Carp::cluck("DEBUGGING");
  $CPAN::Frontend->mywarn("Lockfile removed.\n");
d547 19
a565 15
sub tidyup {
  my($self) = @@_;
  return unless -d $self->{ID};
  while ($self->{DU} > $self->{'MAX'} ) {
    my($toremove) = shift @@{$self->{FIFO}};
    $CPAN::Frontend->myprint(sprintf(
				     "Deleting from cache".
				     ": $toremove (%.1f>%.1f MB)\n",
				     $self->{DU}, $self->{'MAX'})
			    );
    return if $CPAN::Signal;
    $self->force_clean_cache($toremove);
    return if $CPAN::Signal;
  }
}
d582 1
a582 2
    my $dh = DirHandle->new(File::Spec->curdir)
        or Carp::croak("Couldn't opendir $dir: $!");
d601 6
a606 3
    return if exists $self->{SIZE}{$dir};
    return if $CPAN::Signal;
    my($Du) = 0;
d609 2
a610 9
	   $File::Find::prune++ if $CPAN::Signal;
	   return if -l $_;
	   if ($^O eq 'MacOS') {
	     require Mac::Files;
	     my $cat  = Mac::Files::FSpGetCatInfo($_);
	     $Du += $cat->ioFlLgLen() + $cat->ioFlRLgLen();
	   } else {
	     $Du += (-s _);
	   }
a613 1
    return if $CPAN::Signal;
d618 10
a633 1
    return unless -e $dir;
a649 1
		SCAN => $CPAN::Config->{'scan_cache'} || 'atstart',
d655 6
a660 1
    $self->scan_cache;
a667 18
#-> sub CPAN::CacheMgr::scan_cache ;
sub scan_cache {
    my $self = shift;
    return if $self->{SCAN} eq 'never';
    $CPAN::Frontend->mydie("Unknown scan_cache argument: $self->{SCAN}")
	unless $self->{SCAN} eq 'atstart';
    $CPAN::Frontend->myprint(
			     sprintf("Scanning cache %s for sizes\n",
				     $self->{ID}));
    my $e;
    for $e ($self->entries($self->{ID})) {
	next if $e eq ".." || $e eq ".";
	$self->disk_usage($e);
	return if $CPAN::Signal;
    }
    $self->tidyup;
}

d746 1
a746 1
	$configpm || Carp::confess(q{
d762 1
a762 1
# This is CPAN.pm's systemwide configuration file. This file provides
a769 1
    rename $configpm, "$configpm~" if -f $configpm;
a813 1
    use Carp;
d816 2
a817 3
    unless ($dot_cpan++){
      unshift @@INC, MM->catdir($ENV{HOME},".cpan");
      eval {require CPAN::MyConfig;};   # where you can override
a818 2
      shift @@INC;
    }
d875 1
a875 1
    $CPAN::Frontend->myprint(<<END) if $redo && ! $theycalled;
d879 1
a879 1
END
d891 3
a893 4
	    cpan_home keep_source_where build_dir build_cache scan_cache
	    index_expire gzip tar unzip make pager makepl_arg make_arg
	    make_install_arg urllist inhibit_startup_message
	    ftp_proxy http_proxy no_proxy prerequisites_policy
d906 1
d909 1
a909 1
    $CPAN::Frontend->myprint(q[
d925 1
a925 1
]);
d936 3
a938 7
	defined($words[2])
	and
	(
	 $words[2] =~ /list$/ && @@words == 3
	 ||
	 $words[2] =~ /list$/ && @@words == 4 && length($word)
	)
a982 2
*help = \&h;

d1006 1
a1006 3
sub m { # emacs confused here }; sub mimimimimi { # emacs in sync here
    $CPAN::Frontend->myprint(shift->format_result('Module',@@_));
}
d1035 1
a1035 8
	    $CPAN::Frontend->myprint("CPAN::Config options");
	    if (exists $INC{'CPAN/Config.pm'}) {
	      $CPAN::Frontend->myprint(" from $INC{'CPAN/Config.pm'}");
	    }
	    if (exists $INC{'CPAN/MyConfig.pm'}) {
	      $CPAN::Frontend->myprint(" and $INC{'CPAN/MyConfig.pm'}");
	    }
	    $CPAN::Frontend->myprint(":\n");
a1113 15
sub dotdot_onreload {
    my($ref) = shift;
    sub {
	if ( $_[0] =~ /Subroutine (\w+) redefined/ ) {
	    my($subr) = $1;
	    ++$$ref;
	    local($|) = 1;
	    # $CPAN::Frontend->myprint(".($subr)");
	    $CPAN::Frontend->myprint(".");
	    return;
	}
	warn @@_;
    };
}

d1123 1
d1125 10
a1134 1
	local($SIG{__WARN__}) = dotdot_onreload(\$redef);
d1139 1
a1139 1
      CPAN::Index->force_reload;
d1141 3
a1143 2
      $CPAN::Frontend->myprint(qq{cpan     re-evals the CPAN.pm file
index    re-reads the index files\n});
a1207 1
	return if $CPAN::Signal;
a1296 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
d1353 1
a1353 1
	    for $obj ( sort {$a->id cmp $b->id} $CPAN::META->all_objects($class)) {
d1415 1
a1415 2
	my $line;
	for $line (split /\n/, $what) {
a1460 1
# RE-adme||MA-ke||TE-st||IN-stall
a1471 3
      CPAN::Queue->new($s);
    }
    while ($s = CPAN::Queue->first) {
d1485 1
a1485 1
			qq{pragma[$pragma]meth[$meth]obj[$obj]as_string\[}.
d1493 2
a1494 10
		    ($] < 5.00303 || $obj->can($pragma)); ###
                                                          ### compatibility
                                                          ### with
                                                          ### 5.003
	    if ($]>=5.00303 && $obj->can('called_for')) {
	      $obj->called_for($s);
	    }
	    CPAN::Queue->delete($s) if $obj->$meth(); # if it is more
                                                      # than once in
                                                      # the queue
d1504 1
a1504 3
	    $CPAN::Frontend
		->myprint(qq{Warning: Cannot $meth $s, }.
			  qq{don\'t know what it is.
a1511 1
	CPAN::Queue->delete_first($s);
d1536 3
a1538 3
  my($class,$host,$dir,$file,$target) = @@_;
  $class->debug(
		qq[Going to fetch file [$file] from dir [$dir]
d1541 22
a1562 53
  my $ftp = Net::FTP->new($host);
  return 0 unless defined $ftp;
  $ftp->debug(1) if $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG;
  $class->debug(qq[Going to ->login("anonymous","$Config::Config{'cf_email'}")\n]);
  unless ( $ftp->login("anonymous",$Config::Config{'cf_email'}) ){
    warn "Couldn't login on $host";
    return;
  }
  unless ( $ftp->cwd($dir) ){
    warn "Couldn't cwd $dir";
    return;
  }
  $ftp->binary;
  $class->debug(qq[Going to ->get("$file","$target")\n]) if $CPAN::DEBUG;
  unless ( $ftp->get($file,$target) ){
    warn "Couldn't fetch $file from $host\n";
    return;
  }
  $ftp->quit; # it's ok if this fails
  return 1;
}

# If more accuracy is wanted/needed, Chris Leach sent me this patch...

 # leach,> *** /install/perl/live/lib/CPAN.pm-	Wed Sep 24 13:08:48 1997
 # leach,> --- /tmp/cp	Wed Sep 24 13:26:40 1997
 # leach,> ***************
 # leach,> *** 1562,1567 ****
 # leach,> --- 1562,1580 ----
 # leach,>       return 1 if substr($url,0,4) eq "file";
 # leach,>       return 1 unless $url =~ m|://([^/]+)|;
 # leach,>       my $host = $1;
 # leach,> +     my $proxy = $CPAN::Config->{'http_proxy'} || $ENV{'http_proxy'};
 # leach,> +     if ($proxy) {
 # leach,> +         $proxy =~ m|://([^/:]+)|;
 # leach,> +         $proxy = $1;
 # leach,> +         my $noproxy = $CPAN::Config->{'no_proxy'} || $ENV{'no_proxy'};
 # leach,> +         if ($noproxy) {
 # leach,> +             if ($host !~ /$noproxy$/) {
 # leach,> +                 $host = $proxy;
 # leach,> +             }
 # leach,> +         } else {
 # leach,> +             $host = $proxy;
 # leach,> +         }
 # leach,> +     }
 # leach,>       require Net::Ping;
 # leach,>       return 1 unless $Net::Ping::VERSION >= 2;
 # leach,>       my $p;


# this is quite optimistic and returns one on several occasions where
# inappropriate. But this does no harm. It would do harm if we were
# too pessimistic (as I was before the http_proxy
d1568 2
a1569 4
    return 1 unless $url =~ m|^(\w+)://([^/]+)|;
    my $proxytype = $1 . "_proxy"; # ftp_proxy or http_proxy
    my $host = $2;
    return 1 if $CPAN::Config->{$proxytype} || $ENV{$proxytype};
a1572 4
    # 1.3101 had it different: only if the first eval raised an
    # exception we tried it with TCP. Now we are happy if icmp wins
    # the order and return, we don't even check for $@@. Thanks to
    # thayer@@uis.edu for the suggestion.
d1574 1
a1574 2
    return 1 if $p && ref($p) && $p->ping($host, 10);
    eval {$p = Net::Ping->new("tcp");};
d1576 1
a1576 1
    return $p->ping($host, 10);
a1589 14
    if ($^O eq 'MacOS') {
        my($name, $path) = File::Basename::fileparse($aslocal, '');
        if (length($name) > 31) {
            $name =~ s/(\.(readme(\.(gz|Z))?|(tar\.)?(gz|Z)|tgz|zip|pm\.(gz|Z)))$//;
            my $suf = $1;
            my $size = 31 - length($suf);
            while (length($name) > $size) {
                chop $name;
            }
            $name .= $suf;
            $aslocal = File::Spec->catfile($path, $name);
        }
    }

d1605 1
a1605 1
    if ($CPAN::META->has_inst('LWP::UserAgent')) {
d1622 1
a1622 1
    $CPAN::Config->{urllist} ||= [];
d1630 1
a1630 1
		    <=>
d1639 5
a1650 1
    @@levels = qw/easy/ if $^O eq 'MacOS';
a1654 1
	@@host_seq = (0) unless @@host_seq;
d1657 3
a1659 5
	  $Themethod = $level;
	  $self->debug("level[$level]") if $CPAN::DEBUG;
	  return $ret;
	} else {
	  unlink $aslocal;
d1684 1
a1684 1
      my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
d1705 2
a1706 5
		($l = $url) =~ s|^file://[^/]*/|/|; # discard the host part
		$l =~ s|^file:||;                   # assume they
                                                    # meant
                                                    # file://localhost
		$l =~ s|^/|| unless -f $l;          # e.g. /P:
d1715 1
a1715 1
		CPAN::Tarzip->gunzip("$l.gz", $aslocal);
d1722 2
a1723 2
      if ($CPAN::META->has_inst('LWP')) {
	  $CPAN::Frontend->myprint("Fetching with LWP:
d1726 7
a1732 11
	  unless ($Ua) {
	    require LWP::UserAgent;
	    $Ua = LWP::UserAgent->new;
	  }
	  my $res = $Ua->mirror($url, $aslocal);
	  if ($res->is_success) {
	    $Thesite = $i;
	    return $aslocal;
	  } elsif ($url !~ /\.gz$/) {
	    my $gzurl = "$url.gz";
	    $CPAN::Frontend->myprint("Fetching with LWP:
d1735 8
a1742 6
	    $res = $Ua->mirror($gzurl, "$aslocal.gz");
	    if ($res->is_success &&
		CPAN::Tarzip->gunzip("$aslocal.gz",$aslocal)
	       ) {
	      $Thesite = $i;
	      return $aslocal;
d1744 1
a1744 1
	      # next HOSTEASY ;
a1745 8
	  } else {
	    # Alan Burlison informed me that in firewall envs Net::FTP
	    # can still succeed where LWP fails. So we do not skip
	    # Net::FTP anymore when LWP is available.
	    # next HOSTEASY ;
	  }
	} else {
	  $self->debug("LWP not installed") if $CPAN::DEBUG;
d1753 1
a1753 1
  $url
d1764 1
a1764 1
  $url.gz
d1766 5
a1770 6
		   if (CPAN::FTP->ftp_get($host,
					   $dir,
					   "$getfile.gz",
					   $gz) &&
			CPAN::Tarzip->gunzip($gz,$aslocal)
		       ){
d1775 1
a1775 1
		# next HOSTEASY;
d1782 1
a1782 1
  my($self,$host_seq,$file,$aslocal) = @@_;
d1784 7
a1790 9
  # Came back if Net::FTP couldn't establish connection (or
  # failed otherwise) Maybe they are behind a firewall, but they
  # gave us a socksified (or other) ftp program...

  my($i);
  my($devnull) = $CPAN::Config->{devnull} || "";
  # < /dev/null ";
  my($aslocal_dir) = File::Basename::dirname($aslocal);
  File::Path::mkpath($aslocal_dir);
d1792 1
a1792 1
	my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
d1799 3
a1801 8
	my($proto,$host,$dir,$getfile);

	# Courtesy Mark Conty mark_conty@@cargill.com change from
	# if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
	# to
	if ($url =~ m|^([^:]+)://(.*?)/(.*)/(.*)|) {
	    # proto not yet used
	    ($proto,$host,$dir,$getfile) = ($1,$2,$3,$4);
d1807 1
a1807 1
	for $f ('lynx','ncftpget','ncftp') {
d1816 2
a1817 2
	    $source_switch = " -source" if $funkyftp =~ /\blynx$/;
	    $source_switch = " -c" if $funkyftp =~ /\bncftp$/;
d1819 2
a1820 2
		  qq[
Trying with "$funkyftp$source_switch" to get
d1822 2
a1823 2
]);
	    my($system) = "$funkyftp$source_switch '$url' $devnull > ".
d1833 12
a1844 9
		  # test gzip integrity
		  if (
		      CPAN::Tarzip->gtest($aslocal_uncompressed)
		     ) {
		    rename $aslocal_uncompressed, $aslocal;
		  } else {
		    CPAN::Tarzip->gzip($aslocal_uncompressed,
				     "$aslocal_uncompressed.gz");
		  }
a1845 2
		$Thesite = $i;
		return $aslocal;
d1847 5
a1851 7
	      unlink $aslocal_uncompressed if
		  -f $aslocal_uncompressed && -s _ == 0;
	      my $gz = "$aslocal.gz";
	      my $gzurl = "$url.gz";
	      $CPAN::Frontend->myprint(
		      qq[
Trying with "$funkyftp$source_switch" to get
d1853 24
a1876 15
]);
	      my($system) = "$funkyftp$source_switch '$url.gz' $devnull > ".
		  "$aslocal_uncompressed.gz";
	      $self->debug("system[$system]") if $CPAN::DEBUG;
	      my($wstatus);
	      if (($wstatus = system($system)) == 0
		  &&
		  -s "$aslocal_uncompressed.gz"
		 ) {
		# test gzip integrity
		if (CPAN::Tarzip->gtest("$aslocal_uncompressed.gz")) {
		  CPAN::Tarzip->gunzip("$aslocal_uncompressed.gz",
				       $aslocal);
		} else {
		  rename $aslocal_uncompressed, $aslocal;
a1877 6
		$Thesite = $i;
		return $aslocal;
	      } else {
		unlink "$aslocal_uncompressed.gz" if
		    -f "$aslocal_uncompressed.gz";
	      }
d1901 1
a1901 1
	my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
d1966 1
a1966 1

d2004 1
a2008 1
# CPAN::FTP::ls
a2129 21
sub gnu_cpl {
    my($text, $line, $start, $end) = @@_;
    my(@@perlret) = cpl($text, $line, $start);
    # find longest common match. Can anybody show me how to peruse
    # T::R::Gnu to have this done automatically? Seems expensive.
    return () unless @@perlret;
    my($newtext) = $text;
    for (my $i = length($text)+1;;$i++) {
	last unless length($perlret[0]) && length($perlret[0]) >= $i;
	my $try = substr($perlret[0],0,$i);
	my @@tries = grep {substr($_,0,$i) eq $try} @@perlret;
	# warn "try[$try]tries[@@tries]";
	if (@@tries == @@perlret) {
	    $newtext = $try;
	} else {
	    last;
	}
    }
    ($newtext,@@perlret);
}

d2175 1
a2175 1
    grep /^\Q$word\E/, map { $_->id } $CPAN::META->all_objects($class);
d2245 4
a2248 7
    $cl->rd_authindex($cl
		      ->reload_x(
				 "authors/01mailrc.txt.gz",
				 $needshort ?
				 File::Spec->catfile('authors', '01mailrc.gz') :
				 File::Spec->catfile('authors', '01mailrc.txt.gz'),
				 $force));
d2253 4
a2256 7
    $cl->rd_modpacks($cl
		     ->reload_x(
				"modules/02packages.details.txt.gz",
				$needshort ?
				File::Spec->catfile('modules', '02packag.gz') :
				File::Spec->catfile('modules', '02packages.details.txt.gz'),
				$force));
d2261 4
a2264 7
    $cl->rd_modlist($cl
		    ->reload_x(
			       "modules/03modlist.data.gz",
			       $needshort ?
			       File::Spec->catfile('modules', '03mlist.gz') :
			       File::Spec->catfile('modules', '03modlist.data.gz'),
			       $force));
d2297 1
a2297 2
    my($cl, $index_target) = @@_;
    my @@lines;
d2299 1
d2301 3
a2303 8
#    my $fh = CPAN::Tarzip->TIEHANDLE($index_target);
#    while ($_ = $fh->READLINE) {
    # no strict 'refs';
    local(*FH);
    tie *FH, CPAN::Tarzip, $index_target;
    local($/) = "\n";
    push @@lines, split /\012/ while <FH>;
    foreach (@@lines) {
d2305 1
a2305 1
	    m/alias\s+(\S+)\s+\"([^\"\<]+)\s+\<([^\>]+)\>\"/;
d2313 2
a2314 7
}

sub userid {
  my($self,$dist) = @@_;
  $dist = $self->{'id'} unless defined $dist;
  my($ret) = $dist =~ m|(?:\w/\w\w/)?([^/]+)/|;
  $ret;
d2319 1
a2319 2
    my($cl, $index_target) = @@_;
    my @@lines;
d2321 1
d2323 3
a2325 11
    my $fh = CPAN::Tarzip->TIEHANDLE($index_target);
    local($/) = "\n";
    while ($_ = $fh->READLINE) {
	s/\012/\n/g;
	my @@ls = map {"$_\n"} split /\n/, $_;
	unshift @@ls, "\n" x length($1) if /^(\n+)/;
	push @@lines, @@ls;
    }
    while (@@lines) {
	my $shift = shift(@@lines);
	last if $shift =~ /^\s*$/;
d2327 1
a2327 1
    foreach (@@lines) {
d2332 1
a2332 1
	# if it is a bundle, instatiate a bundle object
d2334 2
a2335 7

	if ($mod eq 'CPAN' &&
	    ! (
	       CPAN::Queue->exists('Bundle::CPAN') ||
	       CPAN::Queue->exists('CPAN')
	      )
	   ) {
d2341 1
a2341 1
    install Bundle::CPAN
a2355 1
	    # warn "made mod[$mod]a bundle";
a2358 1
	    # warn "made mod[$mod]a module";
d2372 2
a2373 1
	    $userid = $cl->userid($dist);
d2392 2
a2393 1
    undef $fh;
d2400 1
d2402 4
a2405 12
    my $fh = CPAN::Tarzip->TIEHANDLE($index_target);
    my @@eval;
    local($/) = "\n";
    while ($_ = $fh->READLINE) {
	s/\012/\n/g;
	my @@ls = map {"$_\n"} split /\n/, $_;
	unshift @@ls, "\n" x length($1) if /^(\n+)/;
	push @@eval, @@ls;
    }
    while (@@eval) {
	my $shift = shift(@@eval);
	if ($shift =~ /^Date:\s+(.*)/){
d2409 1
a2409 1
	last if $shift =~ /^\s*$/;
d2411 4
a2414 2
    undef $fh;
    push @@eval, q{CPAN::Modulelist->data;};
a2416 1
    my($eval) = join("", @@eval);
d2462 2
a2463 13
	if ($_ eq "CPAN_USERID") {
	  $extra .= " (".$self->author;
	  my $email; # old perls!
	  if ($email = $CPAN::META->instance(CPAN::Author,
						$self->{$_}
					       )->email) {
	    $extra .= " <$email>";
	  } else {
	    $extra .= " <no email>";
	  }
	  $extra .= ")";
	}
	if (ref($self->{$_}) eq "ARRAY") { # language interface? XXX
a2498 1

d2562 1
a2562 1
    chdir File::Spec->updir;
d2564 1
a2564 1
	chdir File::Spec->catdir(File::Spec->curdir, "tmp");
d2566 1
a2566 2
	my $dh = DirHandle->new(File::Spec->curdir)
	    or Carp::croak("Couldn't opendir .: $!");
d2589 1
a2589 1
	chdir File::Spec->updir;
d2600 9
a2608 16
	  my($configure) = MM->catfile($packagedir,"Configure");
	  if (-f $configure) {
	    # do we have anything to do?
	    $self->{'configure'} = $configure;
	  } elsif (-f MM->catfile($packagedir,"Makefile")) {
	    $CPAN::Frontend->myprint(qq{
Package comes with a Makefile and without a Makefile.PL.
We\'ll try to build it with that Makefile then.
});
	    $self->{writemakefile} = "YES";
	    sleep 2;
	  } else {
	    my $fh = FileHandle->new(">$makefilepl")
		or Carp::croak("Could not open >$makefilepl");
	    my $cf = $self->called_for || "unknown";
	    $fh->print(
d2613 2
a2614 2
use ExtUtils::MakeMaker;
WriteMakefile(NAME => q[$cf]);
d2617 2
a2618 2
	    $CPAN::Frontend->myprint(qq{Package comes without Makefile.PL.
  Writing one on our own (calling it $cf)\n});
d2628 3
a2630 1
    if (CPAN::Tarzip->untar($local_file)) {
d2653 3
a2655 1
    if (CPAN::Tarzip->gunzip($local_file,$to)) {
a2674 6

    if ($^O eq 'MacOS') {
      $self->ExtUtils::MM_MacOS::look;
      return;
    }

a2716 6

    if ($^O eq 'MacOS') {
        ExtUtils::MM_MacOS::launch_file($local_file);
        return;
    }

d2764 2
a2766 1
	    CPAN::Tarzip->gunzip("$lc_file.gz",$lc_file);
a2783 1
	$eval =~ s/\015?\012/\n/g;
d2794 1
a2794 2

    if (exists $cksum->{$basename}{md5}) {
d2796 14
a2809 24
		     "$cksum->{$basename}{md5}\n") if $CPAN::DEBUG;

	open($fh, $file);
	binmode $fh;
	my $eq = $self->eq_MD5($fh,$cksum->{$basename}{'md5'});
	$fh->close;
	$fh = CPAN::Tarzip->TIEHANDLE($file);

	unless ($eq) {
	  # had to inline it, when I tied it, the tiedness got lost on
	  # the call to eq_MD5. (Jan 1998)
	  my $md5 = MD5->new;
	  my($data,$ref);
	  $ref = \$data;
	  while ($fh->READ($ref, 4096)){
	    $md5->add($data);
	  }
	  my $hexdigest = $md5->hexdigest;
	  $eq += $hexdigest eq $cksum->{$basename}{'md5-ungz'};
	}

	if ($eq) {
	  $CPAN::Frontend->myprint("Checksum for $file ok\n");
	  return $self->{MD5_STATUS} = "OK";
d2820 2
a2821 2
be a bogus file. Maybe you have configured your \`urllist\' with a
bad URL. Please check this array with \`o conf urllist\', and
d2828 1
a2828 1
	# close $fh if fileno($fh);
d2848 1
a2848 5
    my($data);
    while (read($fh, $data, 4096)){
      $md5->add($data);
    }
    # $md5->addfile($fh);
a2849 1
    # warn "fh[$fh] hex[$hexdigest] aexp[$expectMD5]";
d2855 10
a2864 21
  my($self) = @@_;
  $self->{'force_update'}++;
  for my $att (qw(
  MD5_STATUS archived build_dir localfile make install unwrapped
  writemakefile have_sponsored
 )) {
    delete $self->{$att};
  }
}

sub isa_perl {
  my($self) = @@_;
  my $file = File::Basename::basename($self->id);
  return unless $file =~ m{ ^ perl
			    (5)
			    ([._-])
			    (\d{3}(_[0-4][0-9])?)
			    \.tar[._-]gz
			    $
			  }x;
  "$1.$3";
a2895 23
    # Emergency brake if they said install Pippi and get newest perl
    if ($self->isa_perl) {
      if (
	  $self->called_for ne $self->id && ! $self->{'force_update'}
	 ) {
	$CPAN::Frontend->mydie(sprintf qq{
The most recent version "%s" of the module "%s"
comes with the current version of perl (%s).
I\'ll build that only if you ask for something like
    force install %s
or
    install %s
},
			       $CPAN::META->instance(
						     'CPAN::Module',
						     $self->called_for
						    )->cpan_version,
			       $self->called_for,
			       $self->isa_perl,
			       $self->called_for,
			       $self->id);
      }
    }
a2918 5
    if ($^O eq 'MacOS') {
        ExtUtils::MM_MacOS::make($self);
        return;
    }

d2921 1
a2921 1
      $system = $self->{'configure'};
d2931 1
a2931 1
    unless (exists $self->{writemakefile}) {
d2938 1
a2938 1
		local $SIG{CHLD}; # = sub { wait };
d2941 1
a2941 2
			# wait;
			waitpid $pid, 0;
d2943 1
a2943 4
		      # note, this exec isn't necessary if
		      # inactivity_timeout is 0. On the Mac I'd
		      # suggest, we set it always to 0.
		      exec $system;
d2960 5
a2964 5
	  $ret = system($system);
	  if ($ret != 0) {
	    $self->{writemakefile} = "NO";
	    return;
	  }
a2965 1
	$self->{writemakefile} = "YES";
d2967 1
a2968 26
    if (my @@prereq = $self->needs_prereq){
      my $id = $self->id;
      $CPAN::Frontend->myprint("---- Dependencies detected ".
			       "during [$id] -----\n");

      for my $p (@@prereq) {
	$CPAN::Frontend->myprint("    $p\n");
      }
      my $follow = 0;
      if ($CPAN::Config->{prerequisites_policy} eq "follow") {
	$follow = 1;
      } elsif ($CPAN::Config->{prerequisites_policy} eq "ask") {
	require ExtUtils::MakeMaker;
	my $answer = ExtUtils::MakeMaker::prompt(
"Shall I follow them and prepend them to the queue
of modules we are processing right now?", "yes");
	$follow = $answer =~ /^\s*y/i;
      } else {
	local($") = ", ";
	$CPAN::Frontend->myprint("  Ignoring dependencies on modules @@prereq\n");
      }
      if ($follow) {
	CPAN::Queue->jumpqueue(@@prereq,$id); # requeue yourself
	return;
      }
    }
a2979 38
#-> sub CPAN::Distribution::needs_prereq ;
sub needs_prereq {
  my($self) = @@_;
  return unless -f "Makefile"; # we cannot say much
  my $fh = FileHandle->new("<Makefile") or
      $CPAN::Frontend->mydie("Couldn't open Makefile: $!");
  local($/) = "\n";

  my(@@p,@@need);
  while (<$fh>) {
    last if /MakeMaker post_initialize section/;
    my($p) = m{^[\#]
		 \s+PREREQ_PM\s+=>\s+(.+)
		 }x;
    next unless $p;
    # warn "Found prereq expr[$p]";

    while ( $p =~ m/(?:\s)([\w\:]+)=>q\[.*?\],?/g ){
      push @@p, $1;
    }
    last;
  }
  for my $p (@@p) {
    my $mo = $CPAN::META->instance("CPAN::Module",$p);
    next if $mo->uptodate;
    # it's not needed, so don't push it. We cannot omit this step, because
    # if 'force' is in effect, nobody else will check.
    if ($self->{'have_sponsored'}{$p}++){
      # We have already sponsored it and for some reason it's still
      # not available. So we do nothing. Or what should we do?
      # if we push it again, we have a potential infinite loop
      next;
    }
    push @@need, $p;
  }
  return @@need;
}

a3001 6

    if ($^O eq 'MacOS') {
        ExtUtils::MM_MacOS::make_test($self);
        return;
    }

a3023 6

    if ($^O eq 'MacOS') {
        ExtUtils::MM_MacOS::make_clean($self);
        return;
    }

a3065 6

    if ($^O eq 'MacOS') {
        ExtUtils::MM_MacOS::make_install($self);
        return;
    }

d3068 1
a3068 2
    my($stderr) = $^O =~ /Win/i ? "" : " 2>&1 ";
    my($pipe) = FileHandle->new("$system $stderr |");
d3077 1
a3077 1
	 return $self->{'install'} = "YES";
d3105 44
a3148 52
  my($self) = @@_;
  my($parsefile) = $self->inst_file;
  my($id) = $self->id;
  $self->debug("parsefile[$parsefile]id[$id]") if $CPAN::DEBUG;
  unless ($parsefile) {
    # Try to get at it in the cpan directory
    $self->debug("no parsefile") if $CPAN::DEBUG;
    Carp::confess "I don't know a $id" unless $self->{CPAN_FILE};
    my $dist = $CPAN::META->instance('CPAN::Distribution',
				     $self->{CPAN_FILE});
    $dist->get;
    $self->debug($dist->as_string) if $CPAN::DEBUG;
    my($todir) = $CPAN::Config->{'cpan_home'};
    my(@@me,$from,$to,$me);
    @@me = split /::/, $self->id;
    $me[-1] .= ".pm";
    $me = MM->catfile(@@me);
    $from = $self->find_bundle_file($dist->{'build_dir'},$me);
    $to = MM->catfile($todir,$me);
    File::Path::mkpath(File::Basename::dirname($to));
    File::Copy::copy($from, $to)
	or Carp::confess("Couldn't copy $from to $to: $!");
    $parsefile = $to;
  }
  my @@result;
  my $fh = FileHandle->new;
  local $/ = "\n";
  open($fh,$parsefile) or die "Could not open '$parsefile': $!";
  my $inpod = 0;
  $self->debug("parsefile[$parsefile]") if $CPAN::DEBUG;
  while (<$fh>) {
    $inpod = m/^=(?!head1\s+CONTENTS)/ ? 0 :
	m/^=head1\s+CONTENTS/ ? 1 : $inpod;
    next unless $inpod;
    next if /^=/;
    next if /^\s+$/;
    chomp;
    push @@result, (split " ", $_, 2)[0];
  }
  close $fh;
  delete $self->{STATUS};
  $self->{CONTAINS} = join ", ", @@result;
  $self->debug("CONTAINS[@@result]") if $CPAN::DEBUG;
  unless (@@result) {
    $CPAN::Frontend->mywarn(qq{
The bundle file "$parsefile" may be a broken
bundlefile. It seems not to contain any bundle definition.
Please check the file and if it is bogus, please delete it.
Sorry for the inconvenience.
});
  }
  @@result;
d3155 2
a3156 3
### The following two lines let CPAN.pm become Bundle/CPAN.pm :-(
###    my $bu = MM->catfile($where,$what);
###    return $bu if -f $bu;
a3168 10
    my $what2 = $what;
    if ($^O eq 'MacOS') {
      $what =~ s/^://;
      $what2 =~ tr|:|/|;
      $what2 =~ s/:Bundle://;
      $what2 =~ tr|:|/|;
    } else {
	$what2 =~ s|Bundle/||;
    }
    my $bu;
d3174 7
a3180 2
	    # return MM->catfile($where,$bu); # bad
	    last;
a3181 3
	# retry if she managed to
	# have no Bundle directory
	$bu = $file if $file =~ m|\Q$what2\E$|;
a3182 2
    $bu =~ tr|/|:| if $^O eq 'MacOS';
    return MM->catfile($where, $bu) if $bu;
d3211 1
a3211 1
    my($s,%fail);
d3222 1
a3222 20
	# possibly noisy action:
	my $obj = $CPAN::META->instance($type,$s);
	$obj->$meth();
	my $success = $obj->can("uptodate") ? $obj->uptodate : 0;
	$success ||= $obj->{'install'} && $obj->{'install'} eq "YES";
	$fail{$s} = 1 unless $success;
    }
    # recap with less noise
    if ( $meth eq "install") {
	if (%fail) {
	    $CPAN::Frontend->myprint(qq{\nBundle summary: }.
				     qq{The following items seem to }.
				     qq{have had installation problems:\n});
	    for $s ($self->contains) {
		$CPAN::Frontend->myprint( "$s " ) if $fail{$s};
	    }
	    $CPAN::Frontend->myprint(qq{\n});
	} else {
	    $self->{'install'} = 'YES';
	}
d3242 1
a3242 4
sub install {
  my $self = shift;
  $self->rematein('install',@@_);
}
d3285 6
a3290 11
	  my $email = "";
	  my $m; # old perls
	  if ($m = $author->email) {
            $email = " <$m>";
          }
	  push @@m, sprintf(
			   $sprintf2,
			   'CPAN_USERID',
			   $userid,
			   $author->fullname . $email
			  );
d3303 3
a3305 3
    @@statl{qw,? p c + o h,}       = qw,unknown perl C C++ other hybrid,;
    @@stati{qw,? f r O h,}         = qw,unknown functions
	references+ties object-oriented hybrid,;
d3323 17
a3339 2
    if ($local_file) {
      $self->{MANPAGE} ||= $self->manpage_headline($local_file);
a3352 27
sub manpage_headline {
  my($self,$local_file) = @@_;
  my(@@local_file) = $local_file;
  $local_file =~ s/\.pm$/.pod/;
  push @@local_file, $local_file;
  my(@@result,$locf);
  for $locf (@@local_file) {
    next unless -f $locf;
    my $fh = FileHandle->new($locf)
	or $Carp::Frontend->mydie("Couldn't open $locf: $!");
    my $inpod = 0;
    local $/ = "\n";
    while (<$fh>) {
      $inpod = m/^=(?!head1\s+NAME)/ ? 0 :
	  m/^=head1\s+NAME/ ? 1 : $inpod;
      next unless $inpod;
      next if /^=/;
      next if /^\s+$/;
      chomp;
      push @@result, $_;
    }
    close $fh;
    last if @@result;
  }
  join " ", @@result;
}

d3365 4
a3368 4
	my $email = $CPAN::META->instance(CPAN::Author,
				      $self->{'userid'})->email;
	unless (defined $fullname && defined $email) {
	    return "Contact Author $self->{userid} (Try ``a $self->{userid}'')";
d3370 1
a3370 1
	return "Contact Author $fullname <$email>";
d3381 1
a3381 1
    $self->{'CPAN_VERSION'} = 'undef'
d3405 2
a3406 13
    if ($cpan_file eq "N/A" || $cpan_file =~ /^Contact Author/){
      $CPAN::Frontend->mywarn(sprintf qq{
  The module %s isn\'t available on CPAN.

  Either the module has not yet been uploaded to CPAN, or it is
  temporary unavailable. Please contact the author to find out
  more about the status. Try ``i %s''.
},
			      $self->id,
			      $self->id,
			     );
      return;
    }
d3424 2
a3425 2
#-> sub CPAN::Module::uptodate ;
sub uptodate {
d3427 1
d3435 13
a3447 20
    local($^W)=0;
    if ($inst_file
	&&
	$have >= $latest
       ) {
      return 1;
    }
    return;
}
#-> sub CPAN::Module::install ;
sub install {
    my($self) = @@_;
    my($doit) = 0;
    if ($self->uptodate
	&&
	not exists $self->{'force_update'}
       ) {
	$CPAN::Frontend->myprint( $self->id. " is up to date.\n");
    } else {
	$doit = 1;
a3489 1
    # warn "HERE";
a3494 162
package CPAN::Tarzip;

sub gzip {
  my($class,$read,$write) = @@_;
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my($buffer,$fhw);
    $fhw = FileHandle->new($read)
	or $CPAN::Frontend->mydie("Could not open $read: $!");
    my $gz = Compress::Zlib::gzopen($write, "wb")
	or $CPAN::Frontend->mydie("Cannot gzopen $write: $!\n");
    $gz->gzwrite($buffer)
	while read($fhw,$buffer,4096) > 0 ;
    $gz->gzclose() ;
    $fhw->close;
    return 1;
  } else {
    system("$CPAN::Config->{'gzip'} -c $read > $write")==0;
  }
}

sub gunzip {
  my($class,$read,$write) = @@_;
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my($buffer,$fhw);
    $fhw = FileHandle->new(">$write")
	or $CPAN::Frontend->mydie("Could not open >$write: $!");
    my $gz = Compress::Zlib::gzopen($read, "rb")
	or $CPAN::Frontend->mydie("Cannot gzopen $read: $!\n");
    $fhw->print($buffer)
	while $gz->gzread($buffer) > 0 ;
    $CPAN::Frontend->mydie("Error reading from $read: $!\n")
	if $gz->gzerror != Compress::Zlib::Z_STREAM_END();
    $gz->gzclose() ;
    $fhw->close;
    return 1;
  } else {
    system("$CPAN::Config->{'gzip'} -dc $read > $write")==0;
  }
}

sub gtest {
  my($class,$read) = @@_;
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my($buffer);
    my $gz = Compress::Zlib::gzopen($read, "rb")
	or $CPAN::Frontend->mydie("Cannot open $read: $!\n");
    1 while $gz->gzread($buffer) > 0 ;
    $CPAN::Frontend->mydie("Error reading from $read: $!\n")
	if $gz->gzerror != Compress::Zlib::Z_STREAM_END();
    $gz->gzclose() ;
    return 1;
  } else {
    return system("$CPAN::Config->{'gzip'} -dt $read")==0;
  }
}

sub TIEHANDLE {
  my($class,$file) = @@_;
  my $ret;
  $class->debug("file[$file]");
  if ($CPAN::META->has_inst("Compress::Zlib")) {
    my $gz = Compress::Zlib::gzopen($file,"rb") or
	die "Could not gzopen $file";
    $ret = bless {GZ => $gz}, $class;
  } else {
    my $pipe = "$CPAN::Config->{'gzip'} --decompress --stdout $file |";
    my $fh = FileHandle->new($pipe) or die "Could pipe[$pipe]: $!";
    binmode $fh;
    $ret = bless {FH => $fh}, $class;
  }
  $ret;
}

sub READLINE {
  my($self) = @@_;
  if (exists $self->{GZ}) {
    my $gz = $self->{GZ};
    my($line,$bytesread);
    $bytesread = $gz->gzreadline($line);
    return undef if $bytesread == 0;
    return $line;
  } else {
    my $fh = $self->{FH};
    return scalar <$fh>;
  }
}

sub READ {
  my($self,$ref,$length,$offset) = @@_;
  die "read with offset not implemented" if defined $offset;
  if (exists $self->{GZ}) {
    my $gz = $self->{GZ};
    my $byteread = $gz->gzread($$ref,$length);# 30eaf79e8b446ef52464b5422da328a8
    return $byteread;
  } else {
    my $fh = $self->{FH};
    return read($fh,$$ref,$length);
  }
}

sub DESTROY {
  my($self) = @@_;
  if (exists $self->{GZ}) {
    my $gz = $self->{GZ};
    $gz->gzclose();
  } else {
    my $fh = $self->{FH};
    $fh->close;
  }
  undef $self;
}

sub untar {
  my($class,$file) = @@_;
  # had to disable, because version 0.07 seems to be buggy
  if (MM->maybe_command($CPAN::Config->{'gzip'})
      &&
      MM->maybe_command($CPAN::Config->{'tar'})) {
    if ($^O =~ /win/i) { # irgggh
	# people find the most curious tar binaries that cannot handle
	# pipes
	my $system = "$CPAN::Config->{'gzip'} --decompress $file";
	if (system($system)==0) {
	    $CPAN::Frontend->myprint(qq{Uncompressed $file successfully\n});
	} else {
	    $CPAN::Frontend->mydie(
				   qq{Couldn\'t uncompress $file\n}
				  );
	}
	$file =~ s/\.gz$//;
	$system = "$CPAN::Config->{tar} xvf $file";
	if (system($system)==0) {
	    $CPAN::Frontend->myprint(qq{Untarred $file successfully\n});
	} else {
	    $CPAN::Frontend->mydie(qq{Couldn\'t untar $file\n});
	}
	return 1;
    } else {
	my $system = "$CPAN::Config->{'gzip'} --decompress --stdout " .
	    "< $file | $CPAN::Config->{tar} xvf -";
	return system($system) == 0;
    }
  } elsif ($CPAN::META->has_inst("Archive::Tar")
      &&
      $CPAN::META->has_inst("Compress::Zlib") ) {
    my $tar = Archive::Tar->new($file,1);
    $tar->extract($tar->list_files); # I'm pretty sure we have nothing
                                     # that isn't compressed

    ExtUtils::MM_MacOS::convert_files([$tar->list_files], 1)
        if ($^O eq 'MacOS');

    return 1;
  } else {
    $CPAN::Frontend->mydie(qq{
CPAN.pm needs either both external programs tar and gzip installed or
both the modules Archive::Tar and Compress::Zlib. Neither prerequisite
is available. Can\'t continue.
});
  }
}

d3539 1
a3539 9
For extended searching capabilities there's a plugin for CPAN available,
L<CPAN::WAIT>. C<CPAN::WAIT> is a full-text search engine that indexes
all documents available in CPAN authors directories. If C<CPAN::WAIT>
is installed on your system, the interactive shell of <CPAN.pm> will
enable the C<wq>, C<wr>, C<wd>, C<wl>, and C<wh> commands which send
queries to the WAIT server that has been configured for your
installation.

All other methods provided are accessible in a programmer style and in an
d3548 1
a3548 1
which puts you into a readline interface. You will have the most fun if
d3550 1
a3550 1
command completion.
d3566 1
a3566 1
Arguments you pass to these commands are either strings exactly matching
d3569 1
a3569 1
objects. The parser recognizes a regular expression only if you
d3573 2
a3574 2
item is displayed. If the search finds one item, the result is displayed
as object-E<gt>as_string, but if we find more than one, we display
d3595 5
a3599 7
These commands take any number of arguments and investigates what is
necessary to perform the action. If the argument is a distribution
file name (recognized by embedded slashes), it is processed. If it is
a module, CPAN determines the distribution file in which this module
is included and processes that, following any dependencies named in
the module's Makefile.PL (this behavior is controlled by
I<prerequisites_policy>.)
d3601 1
a3601 1
Any C<make> or C<test> are run unconditionally. An
d3605 1
a3605 1
also is run unconditionally. But for
d3610 1
a3610 2
I<module up to date> in the case that the distribution file containing
the module doesnE<39>t need to be updated.
d3614 2
a3615 2
succeeded or not. The C<force> command takes as a first argument the
method to invoke (currently: C<make>, C<test>, or C<install>) and executes the
a3627 6
A C<clean> command results in a

  make clean

being executed within the distribution file's working directory.

d3631 4
a3634 16
distribution file. C<readme> unconditionally runs, displaying the
README of the associated distribution file. C<Look> gets and
untars (if not yet done) the distribution file, changes to the
appropriate directory and opens a subshell process in that directory.

=item Signals

CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are
in the cpan-shell it is intended that you can press C<^C> anytime and
return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell
to clean up and leave the shell loop. You can emulate the effect of a
SIGTERM by sending two consecutive SIGINTs, which usually means by
pressing C<^C> twice.

CPAN.pm ignores a SIGPIPE. If the user sets inactivity_timeout, a
SIGALRM is used during the run of the C<perl Makefile.PL> subprocess.
d3661 1
a3661 1
effect. The primary purpose of this command is to finish a network
d3668 2
a3669 1
invoke CPAN's recompile on the second architecture and youE<39>re done.
d3678 7
a3684 7
Although it may be considered internal, the class hierarchy does matter
for both users and programmer. CPAN.pm deals with above mentioned four
classes, and all those classes share a set of methods. A classical
single polymorphism is in effect. A metaclass object registers all
objects of all kinds and indexes them with a string. The strings
referencing objects have a separated namespace (well, not completely
separated):
d3693 6
a3698 6
to the most recent official release. Developers may mark their releases
as unstable development versions (by inserting an underbar into the
visible version number), so the really hottest and newest distribution
file is not always the default.  If a module Foo circulates on CPAN in
both version 1.23 and 1.23_90, CPAN.pm offers a convenient way to
install version 1.23 by saying
d3703 2
a3704 2
BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would
like to install version 1.23_90, you need to know where the
d3706 1
a3706 1
directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz;
d3720 1
a3720 1
There's currently only one class that has a stable interface -
d3761 1
a3761 1
=head2 Methods in the four Classes
d3788 1
a3788 1
only difference being that I<one special pod section> exists starting with
d3798 1
a3798 1
(e.g. Foo::Bar, ie. I<not> the name of the distribution file). The rest
d3807 1
a3807 1
the modules in the CONTENTS section of the pod. You can install your
a3824 2
=head2 Finding packages and VERSION

d3832 1
a3832 1
prerequisite can hardly be relaxed because it consumes far too much
d3834 1
a3834 1
the $VERSION variable. Currently all programs that are dealing with
d3838 1
a3838 1
        'print MM->parse_version(shift)' filename
d3846 1
a3846 1
Makefile.PL (well, we try to handle a bit more, but without much
d3860 1
a3860 1
useful for you as it's just a by-product of my own testing, but if you
d3865 1
a3865 1
=head2 Floppy, Zip, Offline Mode
d3878 1
a3878 1
When the CPAN module is installed, a site wide configuration file is
d3890 1
a3890 1
  index_expire       after this many days refetch index files
d3893 1
a3893 1
  inactivity_timeout breaks interactive Makefile.PLs after this
d3898 2
a3899 2
  keep_source_where  directory in which to keep the source (if we do)
  make               location of external make program
a3903 4
  prerequisites_policy
                     what to do if you are missing module prerequisites
                     ('follow' automatically, 'ask' me, or 'ignore')
  scan_cache	     controls scanning of cache ('atstart' or 'never')
a3906 4
  wait_list          arrayref to a wait server to try (See CPAN::WAIT)
  ftp_proxy,      }  the three usual variables for configuring
    http_proxy,   }  proxy requests. Both as CPAN::Config variables
    no_proxy      }  and as environment variables configurable.
d3936 1
a3936 1
=head2 urllist parameter has CD-ROM support
a3950 8
Another peculiarity of urllist is that the site that we could
successfully fetch the last file from automatically gets a preference
token and is tried as the first site for the next request. So if you
add a new site at runtime it may happen that the previously preferred
site will be tried another time. This means that if you want to disallow
a site for the next transfer, it must be explicitly removed from
urllist.

d3958 1
a3958 1
development will go towards strong authentication.
a3965 84
=head1 POPULATE AN INSTALLATION WITH LOTS OF MODULES

To populate a freshly installed perl with my favorite modules is pretty
easiest by maintaining a private bundle definition file. To get a useful
blueprint of a bundle definition file, the command autobundle can be used
on the CPAN shell command line. This command writes a bundle definition
file for all modules that re installed for the currently running perl
interpreter. It's recommended to run this command only once and from then
on maintain the file manually under a private name, say
Bundle/my_bundle.pm. With a clever bundle file you can then simply say

    cpan> install Bundle::my_bundle

then answer a few questions and then go out.

Maintaining a bundle definition file means to keep track of two things:
dependencies and interactivity. CPAN.pm (currently) does not take into
account dependencies between distributions, so a bundle definition file
should specify distributions that depend on others B<after> the others.
On the other hand, it's a bit annoying that many distributions need some
interactive configuring. So what I try to accomplish in my private bundle
file is to have the packages that need to be configured early in the file
and the gentle ones later, so I can go out after a few minutes and leave
CPAN.pm unattained.

=head1 WORKING WITH CPAN.pm BEHIND FIREWALLS

Thanks to Graham Barr for contributing the firewall following howto.

Firewalls can be categorized into three basic types.

=over

=item http firewall

This is where the firewall machine runs a web server and to access the
outside world you must do it via the web server. If you set environment
variables like http_proxy or ftp_proxy to a values beginning with http://
or in your web browser you have to set proxy information then you know
you are running a http firewall.

To access servers outside these types of firewalls with perl (even for
ftp) you will need to use LWP.

=item ftp firewall

This where the firewall machine runs a ftp server. This kind of firewall will
only let you access ftp serves outside the firewall. This is usually done by
connecting to the firewall with ftp, then entering a username like
"user@@outside.host.com"

To access servers outside these type of firewalls with perl you
will need to use Net::FTP.

=item One way visibility

I say one way visibility as these firewalls try to make themselve look
invisible to the users inside the firewall. An FTP data connection is
normally created by sending the remote server your IP address and then
listening for the connection. But the remote server will not be able to
connect to you because of the firewall. So for these types of firewall
FTP connections need to be done in a passive mode.

There are two that I can think off.

=over

=item SOCKS

If you are using a SOCKS firewall you will need to compile perl and link
it with the SOCKS library, this is what is normally called a ``socksified''
perl. With this executable you will be able to connect to servers outside
the firewall as if it is not there.

=item IP Masquerade

This is the firewall implemented in the Linux kernel, it allows you to
hide a complete network behind one IP address. With this firewall no
special compiling is need as you can access hosts directly.

=back

=back

d3968 4
a3971 4
We should give coverage for _all_ of the CPAN and not just the PAUSE
part, right? In this discussion CPAN and PAUSE have become equal --
but they are not. PAUSE is authors/ and modules/. CPAN is PAUSE plus
the clpa/, doc/, misc/, ports/, src/, scripts/.
a3975 5
If a Makefile.PL requires special customization of libraries, prompts
the user for special input, etc. then you may find CPAN is not able to
build the distribution. In that case, you should attempt the
traditional method of building a Perl module package from a shell.

d3978 1
a3978 1
Andreas Knig E<lt>a.koenig@@kulturbox.deE<gt>
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d9 1
a9 1
$VERSION = '1.52';
d11 1
a11 1
# $Id: CPAN.pm,v 1.276 2000/01/08 15:29:46 k Exp $
d15 1
a15 1
# $Revision = "[".substr(q$Revision: 1.276 $, 10)."]";
d64 1
a64 1
	     autobundle bundle expand force get cvs_import
d93 1
a93 1
    $Suppress_readline = ! -t STDIN unless defined $Suppress_readline;
a115 6
	# $term->OUT is autoflushed anyway
	my $odef = select STDERR;
	$| = 1;
	select STDOUT;
	$| = 1;
	select $odef;
d123 1
a123 2
    my $try_detect_readline;
    $try_detect_readline = $term->ReadLine eq "Term::ReadLine::Stub" if $term;
d193 1
a193 2
	    $CPAN::Frontend->myprint("\n$redef subroutines in ".
				     "Term::ReadLine redefined\n");
d288 1
a288 1
		$name =~ s|^(.*)$pkg\.pm\z|$1auto/$pkg/$func.al|s;
d304 1
a304 1
	    if ($name =~ s{(\w{12,})\.al\z}{substr($1,0,11).".al"}e){
d542 1
a542 34
    my $dotcpan = $CPAN::Config->{cpan_home};
    eval { File::Path::mkpath($dotcpan);};
    if ($@@) {
      # A special case at least for Jarkko.
      my $firsterror = $@@;
      my $seconderror;
      my $symlinkcpan;
      if (-l $dotcpan) {
	$symlinkcpan = readlink $dotcpan;
	die "readlink $dotcpan failed: $!" unless defined $symlinkcpan;
	eval { File::Path::mkpath($symlinkcpan); };
	if ($@@) {
	  $seconderror = $@@;
	} else {
	  $CPAN::Frontend->mywarn(qq{
Working directory $symlinkcpan created.
});
	}
      }
      unless (-d $dotcpan) {
	my $diemess = qq{
Your configuration suggests "$dotcpan" as your
CPAN.pm working directory. I could not create this directory due
to this error: $firsterror\n};
	$diemess .= qq{
As "$dotcpan" is a symlink to "$symlinkcpan",
I tried to create that, but I failed with this error: $seconderror
} if $seconderror;
	$diemess .= qq{
Please make sure the directory exists and is writable.
};
	$CPAN::Frontend->mydie($diemess);
      }
    }
a582 21

#       From: Larry Wall <larry@@wall.org>
#       Subject: Re: deprecating SIGDIE
#       To: perl5-porters@@perl.org
#       Date: Thu, 30 Sep 1999 14:58:40 -0700 (PDT)
#
#       The original intent of __DIE__ was only to allow you to substitute one
#       kind of death for another on an application-wide basis without respect
#       to whether you were in an eval or not.  As a global backstop, it should
#       not be used any more lightly (or any more heavily :-) than class
#       UNIVERSAL.  Any attempt to build a general exception model on it should
#       be politely squashed.  Any bug that causes every eval {} to have to be
#       modified should be not so politely squashed.
#
#       Those are my current opinions.  It is also my optinion that polite
#       arguments degenerate to personal arguments far too frequently, and that
#       when they do, it's because both people wanted it to, or at least didn't
#       sufficiently want it not to.
#
#       Larry

d787 1
a787 1
	     $Du += $cat->ioFlLgLen() + $cat->ioFlRLgLen() if $cat;
d1106 1
a1106 2
You may edit key values in the follow fashion (the "o" is a literal
letter o):
d1152 23
a1174 23
Display Information
 a                                    authors
 b         string           display   bundles
 d         or               info      distributions
 m         /regex/          about     modules
 i         or                         anything of above
 r         none             reinstall recommendations
 u                          uninstalled distributions

Download, Test, Make, Install...
 get                        download
 make                       make (implies get)
 test      modules,         make test (implies make)
 install   dists, bundles   make install (implies test)
 clean                      make clean
 look                       open subshell in these dists' directories
 readme                     display these dists' README files

Other
 h,?           display this menu       ! perl-code   eval a perl command
 o conf [opt]  set and query options   q             quit the cpan shell
 reload cpan   load CPAN.pm again      reload index  load newer indices
 autobundle    Snapshot                force cmd     unconditionally do cmd});
d1193 1
a1193 1
		next unless $entry =~ s/\.pm\z//;
d1296 4
a1299 7
	  my $raw = "Valid options for debug are ".
	      join(", ",sort(keys %CPAN::DEBUG), 'all').
		  qq{ or a number. Completion works on the options. }.
		      qq{Case is ignored.};
	  require Text::Wrap;
	  $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
	  $CPAN::Frontend->myprint("\n\n");
d1361 1
a1361 1
    my $isaperl = q{perl5[._-]\\d{3}(_[0-4][0-9])?\\.tar[._-]gz\z};
d1565 5
a1569 17
	  for $obj (
		    sort
		    {$a->id cmp $b->id}
		    $CPAN::META->all_objects($class)
		   ) {
	    unless ($obj->id){
	      # BUG, we got an empty object somewhere
	      CPAN->debug(sprintf(
				  "Empty id on obj[%s]%%[%s]",
				  $obj,
				  join(":", %$obj)
				 )) if $CPAN::DEBUG;
	      next;
	    }
	    push @@m, $obj
		if $obj->id =~ /$regex/i
		    or
d1572 1
a1572 2
			  $] < 5.00303 ### provide sort of
                                       ### compatibility with 5.003
d1579 1
a1579 1
	  }
a1672 9
sub setup_output {
    return if -t STDOUT;
    my $odef = select STDERR;
    $| = 1;
    select STDOUT;
    $| = 1;
    select $odef;
}

a1682 1
    setup_output();
a1758 2
#-> sub CPAN::Shell::cvs_import ;
sub cvs_import   { shift->rematein('cvs_import',@@_); }
a1934 3
	  my $now = time;
	  # utime $now, $now, $aslocal; # too bad, if we do that, we
                                      # might alter a local mirror
d1988 1
a1988 1
		$l =~ s|^/||s unless -f $l;         # e.g. /P:
a2014 3
	    my $now = time;
	    utime $now, $now, $aslocal; # download time is more
                                        # important than upload time
d2016 1
a2016 1
	  } elsif ($url !~ /\.gz\z/) {
d2053 1
a2053 1
		if ($aslocal !~ /\.gz\z/) {
d2089 2
a2090 2
	  $CPAN::Frontend->myprint("Skipping $url (not reachable)\n");
	  next;
d2100 2
a2101 2
	  # proto not yet used
	  ($proto,$host,$dir,$getfile) = ($1,$2,$3,$4);
d2103 1
a2103 1
	  next HOSTHARD; # who said, we could ftp anything except ftp?
a2104 1

d2108 12
a2119 21
	  next unless exists $CPAN::Config->{$f};
	  $funkyftp = $CPAN::Config->{$f};
	  next unless defined $funkyftp;
	  next if $funkyftp =~ /^\s*$/;
	  my($want_compressed);
	  my $aslocal_uncompressed;
	  ($aslocal_uncompressed = $aslocal) =~ s/\.gz//;
	  my($source_switch) = "";
	  if ($f eq "lynx"){
	    $source_switch = " -source";
	  } elsif ($f eq "ncftp"){
	    $source_switch = " -c";
	  }
	  my($chdir) = "";
	  my($stdout_redir) = " > $aslocal_uncompressed";
	  if ($f eq "ncftpget"){
	    $chdir = "cd $aslocal_dir && ";
	    $stdout_redir = "";
	  }
	  $CPAN::Frontend->myprint(
				   qq[
d2123 2
a2124 39
	  my($system) =
	      "$chdir$funkyftp$source_switch '$url' $devnull$stdout_redir";
	  $self->debug("system[$system]") if $CPAN::DEBUG;
	  my($wstatus);
	  if (($wstatus = system($system)) == 0
	      &&
	      ($f eq "lynx" ?
	       -s $aslocal_uncompressed   # lynx returns 0 on my
                                          # system even if it fails
	       : 1
	      )
	     ) {
	    if (-s $aslocal) {
	      # Looks good
	    } elsif ($aslocal_uncompressed ne $aslocal) {
	      # test gzip integrity
	      if (
		  CPAN::Tarzip->gtest($aslocal_uncompressed)
		 ) {
		rename $aslocal_uncompressed, $aslocal;
	      } else {
		CPAN::Tarzip->gzip($aslocal_uncompressed,
				   "$aslocal_uncompressed.gz");
	      }
	    }
	    $Thesite = $i;
	    return $aslocal;
	  } elsif ($url !~ /\.gz\z/) {
	    unlink $aslocal_uncompressed if
		-f $aslocal_uncompressed && -s _ == 0;
	    my $gz = "$aslocal.gz";
	    my $gzurl = "$url.gz";
	    $CPAN::Frontend->myprint(
				     qq[
Trying with "$funkyftp$source_switch" to get
  $url.gz
]);
	    my($system) = "$funkyftp$source_switch '$url.gz' $devnull > ".
		"$aslocal_uncompressed.gz";
d2129 2
a2130 1
		-s "$aslocal_uncompressed.gz"
d2132 40
a2171 4
	      # test gzip integrity
	      if (CPAN::Tarzip->gtest("$aslocal_uncompressed.gz")) {
		CPAN::Tarzip->gunzip("$aslocal_uncompressed.gz",
				     $aslocal);
d2173 2
a2174 1
		rename $aslocal_uncompressed, $aslocal;
a2175 2
	      $Thesite = $i;
	      return $aslocal;
d2177 3
a2179 9
	      unlink "$aslocal_uncompressed.gz" if
		  -f "$aslocal_uncompressed.gz";
	    }
	  } else {
	    my $estatus = $wstatus >> 8;
	    my $size = -f $aslocal ?
		", left\n$aslocal with size ".-s _ :
		    "\nWarning: expected file [$aslocal] doesn't exist";
	    $CPAN::Frontend->myprint(qq{
d2183 1
a2183 1
	  }
d2211 1
a2216 1
	my($netrcfile) = $netrc->netrc;
d2229 1
a2229 1
	if (! $netrcfile) {
d2466 1
a2466 1
			       make test install force reload look cvs_import
d2469 1
a2469 1
    } elsif ( $line !~ /^[\!abcdhimorutl]/ ) {
d2477 1
a2477 1
    } elsif ($line =~ /^([mru]|make|clean|test|install|readme|look|cvs_import)\s/ ) {
d2555 1
a2555 1
	$_ = 0.001 unless $_ && $_ > 0.001;
a2558 5
    ## IFF we are developing, it helps to wipe out the memory between
    ## reloads, otherwise it is not what a user expects.

    ## undef $CPAN::META; # Neue Gruendlichkeit since v1.52(r1.274)
    ## $CPAN::META = CPAN->new;
d2678 1
a2678 1
	# if it is a bundle, instantiate a bundle object
a2690 1
  [Current version is v$CPAN::VERSION]
d2734 6
a2739 14
	if ($CPAN::META->exists('CPAN::Distribution',$dist)) {
	  # we do not need CONTAINSMODS unless we do something with
	  # this dist, so we better produce it on demand.

	  ## my $obj = $CPAN::META->instance(
	  ## 				  'CPAN::Distribution' => $dist
	  ## 				 );
	  ## $obj->{CONTAINSMODS}{$mod} = undef; # experimental
	} else {
	  $CPAN::META->instance(
				'CPAN::Distribution' => $dist
			       )->set(
				      'CPAN_USERID' => $userid
				     );
d2832 1
a2832 7
	  push @@m, sprintf "    %-12s %s%s\n", $_, "@@{$self->{$_}}", $extra;
	} elsif (ref($self->{$_}) eq "HASH") {
	  push @@m, sprintf(
			   "    %-12s %s%s\n",
			   $_,
			   join(" ",keys %{$self->{$_}}),
			   $extra);
d2834 1
a2834 1
	  push @@m, sprintf "    %-12s %s%s\n", $_, $self->{$_}, $extra;
a2845 6
sub dump {
  my($self) = @@_;
  require Data::Dumper;
  Data::Dumper::Dumper($self);
}

a2872 19
#-> sub CPAN::Distribution::as_string ;
sub as_string {
  my $self = shift;
  $self->containsmods;
  $self->SUPER::as_string(@@_);
}

#-> sub CPAN::Distribution::containsmods ;
sub containsmods {
  my $self = shift;
  return if exists $self->{CONTAINSMODS};
  for my $mod ($CPAN::META->all_objects("CPAN::Module")) {
    my $mod_file = $mod->{CPAN_FILE} or next;
    my $dist_id = $self->{ID} or next;
    my $mod_id = $mod->{ID} or next;
    $self->{CONTAINSMODS}{$mod_id} = undef if $mod_file eq $dist_id;
  }
}

d2922 1
a2922 1
    } elsif ($local_file =~ /(\.tar\.(gz|Z)|\.tgz)\z/i){
d2924 1
a2924 1
    } elsif ( $local_file =~ /\.zip\z/i ) {
d2926 1
a2926 1
    } elsif ( $local_file =~ /\.pm\.(gz|Z)\z/) {
d2937 1
a2937 1
	my @@readdir = grep $_ !~ /^\.\.?\z/s, $dh->read; ### MAC??
d3027 1
a3027 1
    $to =~ s/\.(gz|Z)\z//;
a3077 38
sub cvs_import {
    my($self) = @@_;
    $self->get;
    my $dir = $self->dir;

    my $package = $self->called_for;
    my $module = $CPAN::META->instance('CPAN::Module', $package);
    my $version = $module->cpan_version;

    my $userid = $self->{CPAN_USERID};

    my $cvs_dir = (split '/', $dir)[-1];
    $cvs_dir =~ s/-\d+[^-]+\z//;
    my $cvs_root = 
      $CPAN::Config->{cvsroot} || $ENV{CVSROOT};
    my $cvs_site_perl = 
      $CPAN::Config->{cvs_site_perl} || $ENV{CVS_SITE_PERL};
    if ($cvs_site_perl) {
	$cvs_dir = "$cvs_site_perl/$cvs_dir";
    }
    my $cvs_log = qq{"imported $package $version sources"};
    $version =~ s/\./_/g;
    my @@cmd = ('cvs', '-d', $cvs_root, 'import', '-m', $cvs_log,
	       "$cvs_dir", $userid, "v$version");

    my $getcwd;
    $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    my $pwd  = CPAN->$getcwd();
    chdir($dir);

    $CPAN::Frontend->myprint(qq{Working directory is $dir\n});

    $CPAN::Frontend->myprint(qq{@@cmd\n});
    system(@@cmd) == 0 or 
	$CPAN::Frontend->mydie("cvs import failed");
    chdir($pwd);
}

d3149 1
a3149 1
	    $lc_file =~ s/\.gz\z//;
d3196 1
a3196 1
	  while ($fh->READ($ref, 4096) > 0){
d3260 1
a3260 1
  writemakefile
d3274 2
a3275 2
			    \z
			  }xs;
d3341 2
a3342 2
	    $self->{writemakefile} =~ m/ ^ NO\s* ( .* ) /sx and push @@e,
		$1 || "Had some problem writing Makefile";
d3399 1
a3399 1
		$self->{writemakefile} = "NO $@@";
d3406 1
a3406 1
	    $self->{writemakefile} = "NO Makefile.PL returned status $ret";
d3410 1
a3410 10
	if (-f "Makefile") {
	  $self->{writemakefile} = "YES";
	} else {
	  $self->{writemakefile} =
	      qq{NO Makefile.PL refused to write a Makefile.};
	  # It's probably worth to record the reason, so let's retry
	  # local $/;
	  # my $fh = IO::File->new("$system |"); # STDERR? STDIN?
	  # $self->{writemakefile} .= <$fh>;
	}
d3444 1
a3444 1
	 $self->{writemakefile} ||= "YES";
d3477 1
a3477 1
    if ($self->{have_sponsored}{$p}++){
d3660 1
a3660 1
  my $in_cont = 0;
d3663 3
a3665 3
    $in_cont = m/^=(?!head1\s+CONTENTS)/ ? 0 :
	m/^=head1\s+CONTENTS/ ? 1 : $in_cont;
    next unless $in_cont;
a3666 1
    s/\#.*//;
d3712 1
a3712 1
	$what2 =~ s|Bundle[/\\]||;
d3778 3
a3780 8
	    require Text::Wrap;
	    my $raw = sprintf(qq{Bundle summary:
The following items in bundle %s had installation problems:},
			      $self->id
			     );
	    $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
	    $CPAN::Frontend->myprint("\n");
	    my $paragraph = "";
d3782 1
a3782 1
		$paragraph .= "$s " if $fail{$s};
d3784 1
a3784 2
	    $CPAN::Frontend->myprint(Text::Wrap::fill("  ","  ",$paragraph));
	    $CPAN::Frontend->myprint("\n");
d3914 1
a3914 1
  $local_file =~ s/\.pm\z/.pod/;
a4013 2
#-> sub CPAN::Module::cvs_import ;
sub cvs_import { shift->rematein('cvs_import') }
d4094 1
a4094 1
    $have =~ s/\s*//g; # stringify to float around floating point issues
d4177 1
a4177 1
    return undef if $bytesread <= 0;
d4205 1
a4205 1
    $fh->close if defined $fh;
d4216 19
a4234 22
    my $system = "$CPAN::Config->{'gzip'} --decompress --stdout " .
      "< $file | $CPAN::Config->{tar} xvf -";
    if (system($system) != 0) {
      # people find the most curious tar binaries that cannot handle
      # pipes
      my $system = "$CPAN::Config->{'gzip'} --decompress $file";
      if (system($system)==0) {
	$CPAN::Frontend->myprint(qq{Uncompressed $file successfully\n});
      } else {
	$CPAN::Frontend->mydie(
			       qq{Couldn\'t uncompress $file\n}
			      );
      }
      $file =~ s/\.gz\z//;
      $system = "$CPAN::Config->{tar} xvf $file";
      $CPAN::Frontend->myprint(qq{Using Tar:$system:\n});
      if (system($system)==0) {
	$CPAN::Frontend->myprint(qq{Untarred $file successfully\n});
      } else {
	$CPAN::Frontend->mydie(qq{Couldn\'t untar $file\n});
      }
      return 1;
d4236 3
a4238 1
      return 1;
d4294 2
a4295 2
I<bundles> of modules. Bundles simplify the handling of sets of
related modules. See Bundles below.
d4346 19
a4364 4
item is displayed. If the search finds one item, the result is
displayed with the rather verbose method C<as_string>, but if we find
more than one, we display each object with the terse method
<as_glimpse>.
d4368 1
a4368 1
These commands take any number of arguments and investigate what is
d4410 1
a4410 1
=item get, readme, look module or distribution
d4412 4
a4415 3
C<get> downloads a distribution file without further action. C<readme>
displays the README file of the associated distribution. C<Look> gets
and untars (if not yet done) the distribution file, changes to the
d4516 2
a4517 2
listings of modules (C<r>, C<autobundle>, C<u>) also return a list of
the IDs of all modules within the list.
a4551 35
Or if you want to write a cronjob to watch The CPAN, you could list
all modules that need updating:

    perl -e 'use CPAN; CPAN::Shell->r;'

If you don't want to get any output if all modules are up to date, you
can parse the output of above command for the regular expression
//modules are up to date// and decide to mail the output only if it
doesn't match. Ick?

If you prefer to do it more in a programmer style in one single
process, maybe something like this suites you better:

  # list all modules on my disk that have newer versions on CPAN
  for $mod (CPAN::Shell->expand("Module","/./")){
    next unless $mod->inst_file;
    next if $mod->uptodate;
    printf "Module %s is installed as %s, could be updated to %s from CPAN\n",
        $mod->id, $mod->inst_version, $mod->cpan_version;
  }

If that gives you too much output every day, you maybe only want to
watch for three modules. You can write

  for $mod (CPAN::Shell->expand("Module","/Apache|LWP|CGI/")){

as the first line instead. Or you can combine some of the above
tricks:

  # watch only for a new mod_perl module
  $mod = CPAN::Shell->expand("Module","mod_perl");
  exit if $mod->uptodate;
  # new mod_perl arrived, let me know all update recommendations
  CPAN::Shell->r;

d4669 1
a4669 1
with this floppy. See also below the paragraph about CD-ROM support.
d4692 1
d4716 1
a4716 1
=item C<o conf E<lt>scalar optionE<gt>>
d4720 1
a4720 1
=item C<o conf E<lt>scalar optionE<gt> E<lt>valueE<gt>>
d4724 1
a4724 1
=item C<o conf E<lt>list optionE<gt>>
d4729 1
a4729 1
=item C<o conf E<lt>list optionE<gt> [shift|pop]>
d4733 1
a4733 1
=item C<o conf E<lt>list optionE<gt> [unshift|push|splice] E<lt>listE<gt>>
a4738 11
=head2 Note on urllist parameter's format

urllist parameters are URLs according to RFC 1738. We do a little
guessing if your URL is not compliant, but if you have problems with file URLs, please try the correct format. Either:

    file://localhost/whatever/ftp/pub/CPAN/

or

    file:///home/ftp/pub/CPAN/

d4783 1
a4783 1
file for all modules that are installed for the currently running perl
d4790 1
a4790 1
then answer a few questions and then go out for a coffee.
d4792 9
a4800 10
Maintaining a bundle definition file means to keep track of two
things: dependencies and interactivity. CPAN.pm sometimes fails on
calculating dependencies because not all modules define all MakeMaker
attributes correctly, so a bundle definition file should specify
prerequisites as early as possible. On the other hand, it's a bit
annoying that many distributions need some interactive configuring. So
what I try to accomplish in my private bundle file is to have the
packages that need to be configured early in the file and the gentle
ones later, so I can go out after a few minutes and leave CPAN.pm
unattained.
d4804 1
a4804 2
Thanks to Graham Barr for contributing the following paragraphs about
the interaction between perl, and various firewall configurations.
d4823 4
a4826 4
This where the firewall machine runs a ftp server. This kind of
firewall will only let you access ftp servers outside the firewall.
This is usually done by connecting to the firewall with ftp, then
entering a username like "user@@outside.host.com"
d4863 1
a4863 1
We should give coverage for B<all> of the CPAN and not just the PAUSE
d4878 1
a4878 1
Andreas Koenig E<lt>andreas.koenig@@anima.deE<gt>
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a0 1
# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
d2 10
a11 2
$VERSION = '1.59_54';
# $Id: CPAN.pm,v 1.385 2001/02/09 21:37:57 k Exp $
d15 1
a15 1
# $Revision = "[".substr(q$Revision: 1.385 $, 10)."]";
a31 2
no lib "."; # we need to run chdir all over and we would get at wrong
            # libraries there
a49 2
		  Version       16384
		  Queue         32768
d58 1
a60 4
use vars qw($VERSION @@EXPORT $AUTOLOAD $DEBUG $META $HAS_USABLE $term
            $Revision $Signal $End $Suppress_readline $Frontend
            $Defaultsite $Have_warned);

d78 6
d96 1
a96 4
    my $oprompt = shift || "cpan> ";
    my $prompt = $oprompt;
    my $commandline = shift || "";

d100 2
a101 6
        if (! $term
            or
            $term->ReadLine eq "Term::ReadLine::Stub"
           ) {
            $term = Term::ReadLine->new('CPAN Monitor');
        }
d104 2
d109 3
d124 1
a124 1
    # no strict; # I do not recall why no strict was here (2000-09-03)
d126 3
a128 1
    my $cwd = CPAN::anycwd();
d133 1
a133 1
	    "available (try 'install Bundle::CPAN')";
d136 3
a138 3
			     sprintf qq{
cpan shell -- CPAN exploration and modules installation (v%s%s)
ReadLine support %s
d140 1
a140 6
},
                             $CPAN::VERSION,
                             $CPAN::Revision,
                             $rl_avail
                            )
        unless $CPAN::Config->{'inhibit_startup_message'} ;
d142 1
a142 1
  SHELLCOMMAND: while () {
d145 1
a145 1
	    last SHELLCOMMAND unless defined ($_ = <> );
d148 1
a148 2
	    last SHELLCOMMAND unless
                defined ($_ = $term->readline($prompt, $commandline));
d152 1
a152 1
	next SHELLCOMMAND if /^$/;
d155 1
a155 1
	    last SHELLCOMMAND;
d170 1
a170 1
	    $prompt = $oprompt;
d177 1
a177 3
		warn($@@), next SHELLCOMMAND if $@@;
                warn("Text::Parsewords could not parse the line [$_]"),
                    next SHELLCOMMAND unless @@line;
d183 1
a183 1
	    chdir $cwd or $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!});
d186 1
a186 1
	    $prompt = $oprompt;
a188 3
      $commandline = ""; # I do want to be able to pass a default to
                         # shell, but on the second command I see no
                         # use in that
d197 2
a198 2
	    my $redef = 0;
	    local($SIG{__WARN__}) = CPAN::Shell::paintdots_onreload(\$redef);
a201 1
            @@_ = ($oprompt,"");
a205 1
    chdir $cwd or $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!});
d213 1
a225 4
package CPAN::LWP::UserAgent;
use vars qw(@@ISA $USER $PASSWD $SETUPDONE);
# we delay requiring LWP::UserAgent and setting up inheritence until we need it

a227 5
@@CPAN::Complete::COMMANDS = sort qw(
		       ! a b d h i m o q r u autobundle clean dump
		       make test install force readme reload look
                       cvs_import ls
) unless @@CPAN::Complete::COMMANDS;
d230 1
a230 1
use vars qw($LAST_TIME $DATE_OF_02 $DATE_OF_03);
d232 2
a233 4
$LAST_TIME ||= 0;
$DATE_OF_03 ||= 0;
# use constant PROTOCOL => "2.0"; # outcommented to avoid warning on upgrade from 1.57
sub PROTOCOL { 2.0 }
d251 1
a251 1
use vars qw($AUTOLOAD @@ISA $COLOR_REGISTERED $ADVANCED_QUERY $PRINT_ORNAMENTING);
a252 2
$COLOR_REGISTERED ||= 0;
$PRINT_ORNAMENTING ||= 0;
d272 6
d284 68
d353 1
a353 1
use vars qw($AUTOLOAD @@ISA $BUGHUNTING);
a354 1
$BUGHUNTING = 0; # released code must have turned off
a404 1
# CPAN::Queue::new ;
d406 2
a407 2
  my($class,$s) = @@_;
  my $self = bless { qmod => $s }, $class;
d409 2
a413 1
# CPAN::Queue::first ;
d416 1
a416 1
  $obj->{qmod};
a418 1
# CPAN::Queue::delete_first ;
d423 1
a423 1
    if (  $All[$i]->{qmod} eq $what ) {
a429 1
# CPAN::Queue::jumpqueue ;
d431 3
a433 6
    my $class = shift;
    my @@what = @@_;
    CPAN->debug(sprintf("before jumpqueue All[%s] what[%s]",
                        join(",",map {$_->{qmod}} @@All),
                        join(",",@@what)
                       )) if $CPAN::DEBUG;
d435 8
a442 9
        my $jumped = 0;
        for (my $i=0; $i<$#All;$i++) { #prevent deep recursion
            CPAN->debug("i[$All[$i]]what[$what]") if $CPAN::DEBUG;
            if ($All[$i]->{qmod} eq $what){
                $jumped++;
                if ($jumped > 100) { # one's OK if e.g. just
                                     # processing now; more are OK if
                                     # user typed it several times
                    $CPAN::Frontend->mywarn(
d445 3
a447 6
                    next WHAT;
                }
            }
        }
        my $obj = bless { qmod => $what }, $class;
        unshift @@All, $obj;
d449 3
a451 4
    CPAN->debug(sprintf("after jumpqueue All[%s] what[%s]",
                        join(",",map {$_->{qmod}} @@All),
                        join(",",@@what)
                       )) if $CPAN::DEBUG;
a453 1
# CPAN::Queue::exists ;
d456 3
a458 3
  my @@all = map { $_->{qmod} } @@All;
  my $exists = grep { $_->{qmod} eq $what } @@All;
  # warn "in exists what[$what] all[@@all] exists[$exists]";
a461 1
# CPAN::Queue::delete ;
d464 3
a466 1
  @@All = grep { $_->{qmod} ne $mod } @@All;
a468 1
# CPAN::Queue::nullify_queue ;
d479 3
a481 2
# from here on only subs.
################################################################################
d483 18
a500 1
#-> sub CPAN::all_objects ;
d506 1
a506 1
    values %{ $META->{readwrite}{$class} }; # unsafe meta access, ok
d510 1
a510 5
# Called by shell, not in batch mode. In batch mode I see no risk in
# having many processes updating something as installations are
# continually checked at runtime. In shell mode I suspect it is
# unintentional to open more than one shell at a time

d516 1
a516 2
	my $fh = FileHandle->new($lockfile) or
            $CPAN::Frontend->mydie("Could not open $lockfile: $!");
d548 1
a548 5
	} else {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile $lockfile ".
                                           "reports other process with ID ".
                                           "$other. Cannot proceed.\n"));
        }
d613 1
a613 1
    $SIG{TERM} = sub {
d617 1
a617 1
    $SIG{INT} = sub {
d645 1
a645 2
    # global backstop to cleanup if we should really die
    $SIG{__DIE__} = \&cleanup;
a653 7
#-> sub CPAN::anycwd ;
sub anycwd () {
    my $getcwd;
    $getcwd = $CPAN::Config->{'getcwd'} || 'cwd';
    CPAN->$getcwd();
}

a662 1
    CPAN::Config->load unless $CPAN::Config_loaded++;
d666 1
a666 2
    exists $META->{readonly}{$class}{$id} or
        exists $META->{readwrite}{$class}{$id}; # unsafe meta access, ok
d672 1
a672 38
  delete $META->{readonly}{$class}{$id}; # unsafe meta access, ok
  delete $META->{readwrite}{$class}{$id}; # unsafe meta access, ok
}

#-> sub CPAN::has_usable
# has_inst is sometimes too optimistic, we should replace it with this
# has_usable whenever a case is given
sub has_usable {
    my($self,$mod,$message) = @@_;
    return 1 if $HAS_USABLE->{$mod};
    my $has_inst = $self->has_inst($mod,$message);
    return unless $has_inst;
    my $usable;
    $usable = {
               LWP => [ # we frequently had "Can't locate object
                        # method "new" via package "LWP::UserAgent" at
                        # (eval 69) line 2006
                       sub {require LWP},
                       sub {require LWP::UserAgent},
                       sub {require HTTP::Request},
                       sub {require URI::URL},
                      ],
               Net::FTP => [
                            sub {require Net::FTP},
                            sub {require Net::Config},
                           ]
              };
    if ($usable->{$mod}) {
      for my $c (0..$#{$usable->{$mod}}) {
        my $code = $usable->{$mod}[$c];
        my $ret = eval { &$code() };
        if ($@@) {
          warn "DEBUG: c[$c]\$\@@[$@@]ret[$ret]";
          return;
        }
      }
    }
    return $HAS_USABLE->{$mod} = 1;
d680 5
a684 8
    if (defined $message && $message eq "no"
        ||
        exists $CPAN::META->{dontload_hash}{$mod} # unsafe meta access, ok
        ||
        exists $CPAN::Config->{dontload_hash}{$mod}
       ) {
      $CPAN::META->{dontload_hash}{$mod}||=1; # unsafe meta access, ok
      return 0;
d710 1
a710 1
	$CPAN::Frontend->mywarn(qq{
d715 2
a716 2
}) unless $Have_warned->{"Net::FTP"}++;
	sleep 3;
d735 1
a735 3
    # unsafe meta access, ok?
    return $META->{readwrite}{$class}{$id} if exists $META->{readwrite}{$class}{$id};
    $META->{readwrite}{$class}{$id} ||= $class->new(ID => $id);
d763 3
a765 3
  return unless defined $META->{LOCK}; # unsafe meta access, ok
  return unless -f $META->{LOCK}; # unsafe meta access, ok
  unlink $META->{LOCK}; # unsafe meta access, ok
a787 1
#-> sub CPAN::CacheMgr::tidyup ;
d815 3
a817 1
    my($cwd) = CPAN::anycwd();
a944 1
# returns true on successful action
d946 1
a946 1
    my($self,@@args) = @@_;
d948 1
a948 1
    CPAN->debug("self[$self]args[".join(" | ",@@args)."]");
d952 1
a952 1
	$self->$o(@@args);
d955 1
a955 2
        CPAN->debug("o[$o]") if $CPAN::DEBUG;
	if ($o =~ /list$/) {
a957 2
            CPAN->debug("func[$func]") if $CPAN::DEBUG;
            my $changed;
a960 1
                $changed = 1;
a962 1
                $changed = 1;
a964 1
                $changed = 1;
a966 1
                $changed = 1;
a968 1
                $changed = 1;
a970 1
                $changed = 1;
d972 6
a977 1
                $self->prettyprint($o);
a978 6
            if ($o eq "urllist" && $changed) {
                # reset the cached values
                undef $CPAN::FTP::Thesite;
                undef $CPAN::FTP::Themethod;
            }
            return $changed;
d981 3
a983 1
	    $self->prettyprint($o);
a987 27
sub prettyprint {
  my($self,$k) = @@_;
  my $v = $CPAN::Config->{$k};
  if (ref $v) {
    my(@@report) = ref $v eq "ARRAY" ?
        @@$v :
            map { sprintf("   %-18s => %s\n",
                          $_,
                          defined $v->{$_} ? $v->{$_} : "UNDEFINED"
                         )} keys %$v;
    $CPAN::Frontend->myprint(
                             join(
                                  "",
                                  sprintf(
                                          "    %-18s\n",
                                          $k
                                         ),
                                  map {"\t$_\n"} @@report
                                 )
                            );
  } elsif (defined $v) {
    $CPAN::Frontend->myprint(sprintf "    %-18s %s\n", $k, $v);
  } else {
    $CPAN::Frontend->myprint(sprintf "    %-18s %s\n", $k, "UNDEFINED");
  }
}

d1008 1
a1008 2
    my $msg;
    $msg = <<EOF unless $configpm =~ /MyConfig/;
d1019 1
a1019 2
    open $fh, ">$configpm" or
        $CPAN::Frontend->mydie("Couldn't open >$configpm: $!");
d1072 2
a1073 2
    return unless @@miss = $self->missing_config_data;

d1140 2
a1141 2
#-> sub CPAN::Config::missing_config_data ;
sub missing_config_data {
d1143 6
a1148 9
    for (
         "cpan_home", "keep_source_where", "build_dir", "build_cache",
         "scan_cache", "index_expire", "gzip", "tar", "unzip", "make",
         "pager",
         "makepl_arg", "make_arg", "make_install_arg", "urllist",
         "inhibit_startup_message", "ftp_proxy", "http_proxy", "no_proxy",
         "prerequisites_policy",
         "cache_metadata",
        ) {
d1216 7
a1222 5
 command  argument          description
 a,b,d,m  WORD or /REGEXP/  about authors, bundles, distributions, modules
 i        WORD or /REGEXP/  about anything of above
 r        NONE              reinstall recommendations
 ls       AUTHOR            about files in the author's directory
d1227 2
a1228 2
 test      MODULES,         make test (implies make)
 install   DISTS, BUNDLES   make install (implies test)
d1244 3
a1246 28
sub a {
  my($self,@@arg) = @@_;
  # authors are always UPPERCASE
  for (@@arg) {
    $_ = uc $_ unless /=/;
  }
  $CPAN::Frontend->myprint($self->format_result('Author',@@arg));
}

#-> sub CPAN::Shell::ls ;
sub ls      {
    my($self,@@arg) = @@_;
    my @@accept;
    for (@@arg) {
        unless (/^[A-Z\-]+$/i) {
            $CPAN::Frontend->mywarn("ls command rejects argument $_: not an author");
            next;
        }
        push @@accept, uc $_;
    }
    for my $a (@@accept){
        my $author = $self->expand('Author',$a) or die "No author found for $a";
        $author->ls;
    }
}

#-> sub CPAN::Shell::local_bundles ;
sub local_bundles {
d1248 1
d1251 9
a1259 17
        my @@bbase = "Bundle";
        while (my $bbase = shift @@bbase) {
            $bdir = MM->catdir($incdir,split /::/, $bbase);
            CPAN->debug("bdir[$bdir]\@@bbase[@@bbase]") if $CPAN::DEBUG;
            if ($dh = DirHandle->new($bdir)) { # may fail
                my($entry);
                for $entry ($dh->read) {
                    next if $entry =~ /^\./;
                    if (-d MM->catdir($bdir,$entry)){
                        push @@bbase, "$bbase\::$entry";
                    } else {
                        next unless $entry =~ s/\.pm(?!\n)\Z//;
                        $CPAN::META->instance('CPAN::Bundle',"$bbase\::$entry");
                    }
                }
            }
        }
a1260 7
}

#-> sub CPAN::Shell::b ;
sub b {
    my($self,@@which) = @@_;
    CPAN->debug("which[@@which]") if $CPAN::DEBUG;
    $self->local_bundles;
a1262 1

a1264 1

d1281 1
a1281 1
    my $result = @@result == 1 ?
d1283 2
a1284 6
            @@result == 0 ?
                "No objects found of any type for argument @@args\n" :
                    join("",
                         (map {$_->as_glimpse} @@result),
                         scalar @@result, " items found\n",
                        );
a1288 3

# CPAN::Shell::o and CPAN::Config::edit are closely related. 'o conf'
# should have been called set and 'o debug' maybe 'set debug'
d1295 1
a1295 1
	if (!@@o_what) { # print all things, "o conf"
d1311 15
a1325 1
                CPAN::Config->prettyprint($k);
d1329 1
a1329 2
	    $CPAN::Frontend->myprint(qq{Type 'o conf' to view configuration }.
                                     qq{edit options\n\n});
a1336 4
                if ($what =~ s/^-// && exists $CPAN::DEBUG{$what}) {
                    $CPAN::DEBUG &= $CPAN::DEBUG ^ $CPAN::DEBUG{$what};
                    next;
                }
d1372 1
a1372 2
		$CPAN::Frontend->myprint(sprintf "    %-14s(%s)\n", $k, $v)
                    if $v & $CPAN::DEBUG;
d1386 1
a1386 1
sub paintdots_onreload {
d1389 1
a1389 1
	if ( $_[0] =~ /[Ss]ubroutine (\w+) redefined/ ) {
d1410 2
a1411 2
	my $redef = 0;
	local($SIG{__WARN__}) = paintdots_onreload(\$redef);
d1427 1
d1432 1
a1432 2
        my $dist = $CPAN::META->instance('CPAN::Distribution',$file);
	next if $dist->isa_perl;
d1470 2
a1471 2
    Carp::croak "Usage: \$obj->_u_r_common(a|r|u)" unless
          $what && $what =~ /^[aru]$/;
d1477 2
a1478 8
    my $sprintf = "%s%-25s%s %9s %9s  %s\n";
    my @@expand = $self->expand('Module',@@args);
    my $expand = scalar @@expand;
    if (0) { # Looks like noise to me, was very useful for debugging
             # for metadata cache
        $CPAN::Frontend->myprint(sprintf "%d matches in the database\n", $expand);
    }
    for $module (@@expand) {
d1496 1
a1496 1
		next unless CPAN::Version->vgt($latest, $have);
d1527 10
a1536 28
                                             $sprintf,
                                             "",
                                             "Package namespace",
                                             "",
                                             "installed",
                                             "latest",
                                             "in CPAN file"
                                            ));
	}
        my $color_on = "";
        my $color_off = "";
        if (
            $COLOR_REGISTERED
            &&
            $CPAN::META->has_inst("Term::ANSIColor")
            &&
            $module->{RO}{description}
           ) {
            $color_on = Term::ANSIColor::color("green");
            $color_off = Term::ANSIColor::color("reset");
        }
	$CPAN::Frontend->myprint(sprintf $sprintf,
                                 $color_on,
                                 $module->id,
                                 $color_off,
                                 $have,
                                 $latest,
                                 $file);
a1617 21
#-> sub CPAN::Shell::expandany ;
sub expandany {
    my($self,$s) = @@_;
    CPAN->debug("s[$s]") if $CPAN::DEBUG;
    if ($s =~ m|/|) { # looks like a file
        $s = CPAN::Distribution->normalize($s);
        return $CPAN::META->instance('CPAN::Distribution',$s);
        # Distributions spring into existence, not expand
    } elsif ($s =~ m|^Bundle::|) {
        $self->local_bundles; # scanning so late for bundles seems
                              # both attractive and crumpy: always
                              # current state but easy to forget
                              # somewhere
        return $self->expand('Bundle',$s);
    } else {
        return $self->expand('Module',$s)
            if $CPAN::META->exists('CPAN::Module',$s);
    }
    return;
}

a1622 1
    CPAN->debug("type[$type]args[@@args]") if $CPAN::DEBUG;
d1624 1
a1624 1
	my($regex,$command);
d1627 1
a1627 3
	} elsif ($arg =~ m/=/) {
            $command = 1;
        }
a1629 5
        CPAN->debug(sprintf "class[%s]regex[%s]command[%s]",
                    $class,
                    defined $regex ? $regex : "UNDEFINED",
                    $command || "UNDEFINED",
                   ) if $CPAN::DEBUG;
d1631 28
a1658 50
            for $obj (
                      sort
                      {$a->id cmp $b->id}
                      $CPAN::META->all_objects($class)
                     ) {
                unless ($obj->id){
                    # BUG, we got an empty object somewhere
                    require Data::Dumper;
                    CPAN->debug(sprintf(
                                        "Bug in CPAN: Empty id on obj[%s][%s]",
                                        $obj,
                                        Data::Dumper::Dumper($obj)
                                       )) if $CPAN::DEBUG;
                    next;
                }
                push @@m, $obj
                    if $obj->id =~ /$regex/i
                        or
                            (
                             (
                              $] < 5.00303 ### provide sort of
                              ### compatibility with 5.003
                              ||
                              $obj->can('name')
                             )
                             &&
                             $obj->name  =~ /$regex/i
                            );
            }
        } elsif ($command) {
            die "equal sign in command disabled (immature interface), ".
                "you can set
 ! \$CPAN::Shell::ADVANCED_QUERY=1
to enable it. But please note, this is HIGHLY EXPERIMENTAL code
that may go away anytime.\n"
                    unless $ADVANCED_QUERY;
            my($method,$criterion) = $arg =~ /(.+?)=(.+)/;
            my($matchcrit) = $criterion =~ m/^~(.+)/;
            for my $self (
                          sort
                          {$a->id cmp $b->id}
                          $CPAN::META->all_objects($class)
                         ) {
                my $lhs = $self->$method() or next; # () for 5.00503
                if ($matchcrit) {
                    push @@m, $self if $lhs =~ m/$matchcrit/;
                } else {
                    push @@m, $self if $lhs eq $criterion;
                }
            }
d1663 1
a1663 3
	    } elsif ($type eq "Distribution") {
                $xarg = CPAN::Distribution->normalize($arg);
            }
d1683 1
a1683 1
    my $result = @@result == 1 ?
d1685 2
a1686 6
            @@result == 0 ?
                "No objects of type $type found for argument @@args\n" :
                    join("",
                         (map {$_->as_glimpse} @@result),
                         scalar @@result, " items found\n",
                        );
a1692 2

#-> sub CPAN::Shell::print_ornameted ;
d1696 1
a1696 1
    return unless defined $what;
d1698 1
a1698 6
    if ($CPAN::Config->{term_is_latin}){
        # courtesy jhi:
        $what
            =~ s{([\xC0-\xDF])([\x80-\xBF])}{chr(ord($1)<<6&0xC0|ord($2)&0x3F)}eg; #};
    }
    if ($PRINT_ORNAMENTING) {
a1725 1

d1773 1
a1773 17

    # Here is the place to set "test_count" on all involved parties to
    # 0. We then can pass this counter on to the involved
    # distributions and those can refuse to test if test_count > X. In
    # the first stab at it we could use a 1 for "X".

    # But when do I reset the distributions to start with 0 again?
    # Jost suggested to have a random or cycling interaction ID that
    # we pass through. But the ID is something that is just left lying
    # around in addition to the counter, so I'd prefer to set the
    # counter to 0 now, and repeat at the end of the loop. But what
    # about dependencies? They appear later and are not reset, they
    # enter the queue but not its copy. How do they get a sensible
    # test_count?

    # construct the queue
    my($s,@@s,@@qcopy);
d1775 3
a1779 1
            CPAN->debug("s is an object[$s]") if $CPAN::DEBUG;
d1781 4
a1784 5
	} elsif ($s =~ m|^/|) { # looks like a regexp
            $CPAN::Frontend->mywarn("Sorry, $meth with a regular expression is ".
                                    "not supported\n");
            sleep 2;
            next;
d1786 2
a1787 2
            CPAN->debug("calling expandany [$s]") if $CPAN::DEBUG;
	    $obj = CPAN::Shell->expandany($s);
d1790 19
a1808 3
            $obj->color_cmd_tmps(0,1);
            CPAN::Queue->new($obj->id);
            push @@qcopy, $obj;
d1811 6
a1816 11
            if ($meth eq "dump") {
                $obj->dump;
            } else {
                $CPAN::Frontend->myprint(
                                         join "",
                                         "Don't be silly, you can't $meth ",
                                         $obj->fullname,
                                         " ;-)\n"
                                        );
                sleep 2;
            }
d1825 1
a1825 1
to find objects with matching identifiers.
a1826 13
            sleep 2;
	}
    }

    # queuerunner (please be warned: when I started to change the
    # queue to hold objects instead of names, I made one or two
    # mistakes and never found which. I reverted back instead)
    while ($s = CPAN::Queue->first) {
        my $obj;
	if (ref $s) {
	    $obj = $s; # I do not believe, we would survive if this happened
	} else {
	    $obj = CPAN::Shell->expandany($s);
a1827 24
        if ($pragma
            &&
            ($] < 5.00303 || $obj->can($pragma))){
            ### compatibility with 5.003
            $obj->$pragma($meth); # the pragma "force" in
                                  # "CPAN::Distribution" must know
                                  # what we are intending
        }
        if ($]>=5.00303 && $obj->can('called_for')) {
            $obj->called_for($s);
        }
        CPAN->debug(
                    qq{pragma[$pragma]meth[$meth]obj[$obj]as_string\[}.
                    $obj->as_string.
                    qq{\]}
                   ) if $CPAN::DEBUG;

        if ($obj->$meth()){
            CPAN::Queue->delete($s);
        } else {
            CPAN->debug("failed");
        }

        $obj->undelay;
a1829 3
    for my $obj (@@qcopy) {
        $obj->color_cmd_tmps(0,0);
    }
a1831 2
#-> sub CPAN::Shell::dump ;
sub dump    { shift->rematein('dump',@@_); }
a1850 54
package CPAN::LWP::UserAgent;

sub config {
    return if $SETUPDONE;
    if ($CPAN::META->has_usable('LWP::UserAgent')) {
        require LWP::UserAgent;
        @@ISA = qw(Exporter LWP::UserAgent);
        $SETUPDONE++;
    } else {
        $CPAN::Frontent->mywarn("LWP::UserAgent not available\n");
    }
}

sub get_basic_credentials {
    my($self, $realm, $uri, $proxy) = @@_;
    return unless $proxy;
    if ($USER && $PASSWD) {
    } elsif (defined $CPAN::Config->{proxy_user} &&
        defined $CPAN::Config->{proxy_pass}) {
        $USER = $CPAN::Config->{proxy_user};
        $PASSWD = $CPAN::Config->{proxy_pass};
    } else {
        require ExtUtils::MakeMaker;
        ExtUtils::MakeMaker->import(qw(prompt));
        $USER = prompt("Proxy authentication needed!
 (Note: to permanently configure username and password run
   o conf proxy_user your_username
   o conf proxy_pass your_password
 )\nUsername:");
        if ($CPAN::META->has_inst("Term::ReadKey")) {
            Term::ReadKey::ReadMode("noecho");
        } else {
            $CPAN::Frontend->mywarn("Warning: Term::ReadKey seems not to be available, your password will be echoed to the terminal!\n");
        }
        $PASSWD = prompt("Password:");
        if ($CPAN::META->has_inst("Term::ReadKey")) {
            Term::ReadKey::ReadMode("restore");
        }
        $CPAN::Frontend->myprint("\n\n");
    }
    return($USER,$PASSWD);
}

sub mirror {
    my($self,$url,$aslocal) = @@_;
    my $result = $self->SUPER::mirror($url,$aslocal);
    if ($result->code == 407) {
        undef $USER;
        undef $PASSWD;
        $result = $self->SUPER::mirror($url,$aslocal);
    }
    $result;
}

d1863 1
a1863 1
  $class->debug(qq[Going to login("anonymous","$Config::Config{cf_email}")]);
d1884 51
a1934 25
 # > *** /install/perl/live/lib/CPAN.pm-	Wed Sep 24 13:08:48 1997
 # > --- /tmp/cp	Wed Sep 24 13:26:40 1997
 # > ***************
 # > *** 1562,1567 ****
 # > --- 1562,1580 ----
 # >       return 1 if substr($url,0,4) eq "file";
 # >       return 1 unless $url =~ m|://([^/]+)|;
 # >       my $host = $1;
 # > +     my $proxy = $CPAN::Config->{'http_proxy'} || $ENV{'http_proxy'};
 # > +     if ($proxy) {
 # > +         $proxy =~ m|://([^/:]+)|;
 # > +         $proxy = $1;
 # > +         my $noproxy = $CPAN::Config->{'no_proxy'} || $ENV{'no_proxy'};
 # > +         if ($noproxy) {
 # > +             if ($host !~ /$noproxy$/) {
 # > +                 $host = $proxy;
 # > +             }
 # > +         } else {
 # > +             $host = $proxy;
 # > +         }
 # > +     }
 # >       require Net::Ping;
 # >       return 1 unless $Net::Ping::VERSION >= 2;
 # >       my $p;

d1937 2
a1947 2
        # Comment by AK on 2000-09-03: Uniq short filenames would be
        # available in CHECKSUMS file
d1950 1
a1950 9
            $name =~ s/(
                        \.(
                           readme(\.(gz|Z))? |
                           (tar\.)?(gz|Z) |
                           tgz |
                           zip |
                           pm\.(gz|Z)
                          )
                       )$//x;
d1976 2
a1977 1
    if ($CPAN::META->has_usable('LWP::UserAgent')) {
d1979 8
a1986 28
            CPAN::LWP::UserAgent->config;
	    eval {$Ua = CPAN::LWP::UserAgent->new;}; # Why is has_usable still not fit enough?
            if ($@@) {
                $CPAN::Frontent->mywarn("CPAN::LWP::UserAgent->new dies with $@@")
                    if $CPAN::DEBUG;
            } else {
                my($var);
                $Ua->proxy('ftp',  $var)
                    if $var = $CPAN::Config->{ftp_proxy} || $ENV{ftp_proxy};
                $Ua->proxy('http', $var)
                    if $var = $CPAN::Config->{http_proxy} || $ENV{http_proxy};


# >>>>> On Wed, 13 Dec 2000 09:21:34 -0500, "Robison, Jonathon (J.M.)" <jrobiso2@@visteon.com> said:
# 
#  > I note that although CPAN.pm can use proxies, it doesn't seem equipped to
#  > use ones that require basic autorization.
#  
#  > Example of when I use it manually in my own stuff:
#  
#  > $ua->proxy(['http','ftp'], http://my.proxy.server:83');
#  > $req->proxy_authorization_basic("username","password");
#  > $res = $ua->request($req);
# 

                $Ua->no_proxy($var)
                    if $var = $CPAN::Config->{no_proxy} || $ENV{no_proxy};
            }
a1988 4
    $ENV{ftp_proxy} = $CPAN::Config->{ftp_proxy} if $CPAN::Config->{ftp_proxy};
    $ENV{http_proxy} = $CPAN::Config->{http_proxy}
        if $CPAN::Config->{http_proxy};
    $ENV{no_proxy} = $CPAN::Config->{no_proxy} if $CPAN::Config->{no_proxy};
d2011 1
a2011 1
    my(@@levels);
d2018 1
a2018 3
    my($levelno);
    for $levelno (0..$#levels) {
        my $level = $levels[$levelno];
a2032 1
          last if $CPAN::Signal; # need to cleanup
d2035 9
a2043 11
    unless ($CPAN::Signal) {
        my(@@mess);
        push @@mess,
            qq{Please check, if the URLs I found in your configuration file \(}.
                join(", ", @@{$CPAN::Config->{urllist}}).
                    qq{\) are valid. The urllist can be edited.},
                        qq{E.g. with 'o conf urllist push ftp://myurl/'};
        $CPAN::Frontend->myprint(Text::Wrap::wrap("","",@@mess). "\n\n");
        sleep 2;
        $CPAN::Frontend->myprint("Could not fetch $file\n");
    }
d2057 6
a2062 1
        my $url = $CPAN::Config->{urllist}[$i] || $CPAN::Defaultsite;
d2068 2
a2069 1
	    if ($CPAN::META->has_inst('URI::URL')) {
a2082 1
		$self->debug("without URI::URL we try local file $l") if $CPAN::DEBUG;
d2098 1
a2098 1
        if ($CPAN::META->has_usable('LWP')) {
d2103 2
a2104 5
              CPAN::LWP::UserAgent->config;
              eval { $Ua = CPAN::LWP::UserAgent->new; };
              if ($@@) {
                  $CPAN::Frontent->mywarn("CPAN::LWP::UserAgent->new dies with $@@");
              }
d2113 1
a2113 1
	  } elsif ($url !~ /\.gz(?!\n)\Z/) {
d2124 2
d2128 4
a2131 8
              $CPAN::Frontend->myprint(sprintf(
                                               "LWP failed with code[%s] message[%s]\n",
                                               $res->code,
                                               $res->message,
                                              ));
	    # Alan Burlison informed me that in firewall environments
	    # Net::FTP can still succeed where LWP fails. So we do not
	    # skip Net::FTP anymore when LWP is available.
d2134 1
a2134 1
            $CPAN::Frontend->myprint("LWP not available\n");
a2135 1
        return if $CPAN::Signal;
d2139 1
a2139 1
	    if ($CPAN::META->has_usable('Net::FTP')) {
d2150 1
a2150 1
		if ($aslocal !~ /\.gz(?!\n)\Z/) {
a2167 1
        return if $CPAN::Signal;
d2185 4
a2201 2
        next HOSTHARD if $proto eq "file"; # file URLs would have had
                                           # success above. Likely a bogus URL
d2205 1
a2205 1
	for $f ('lynx','ncftpget','ncftp','wget') {
d2210 4
a2213 4
	  my($asl_ungz, $asl_gz);
	  ($asl_ungz = $aslocal) =~ s/\.gz//;
          $asl_gz = "$asl_ungz.gz";
	  my($src_switch) = "";
d2215 1
a2215 1
	    $src_switch = " -source";
d2217 1
a2217 3
	    $src_switch = " -c";
          } elsif ($f eq "wget"){
              $src_switch = " -O -";
d2220 1
a2220 1
	  my($stdout_redir) = " > $asl_ungz";
d2227 1
a2227 1
Trying with "$funkyftp$src_switch" to get
d2231 1
a2231 1
	      "$chdir$funkyftp$src_switch '$url' $devnull$stdout_redir";
d2237 2
a2238 1
	       -s $asl_ungz # lynx returns 0 when it fails somewhere
d2244 1
a2244 1
	    } elsif ($asl_ungz ne $aslocal) {
d2246 4
a2249 3
	      if (CPAN::Tarzip->gtest($asl_ungz)) {
                  # e.g. foo.tar is gzipped --> foo.tar.gz
                  rename $asl_ungz, $aslocal;
d2251 2
a2252 1
                  CPAN::Tarzip->gzip($asl_ungz,$asl_gz);
d2257 3
a2259 3
	  } elsif ($url !~ /\.gz(?!\n)\Z/) {
	    unlink $asl_ungz if
		-f $asl_ungz && -s _ == 0;
d2264 1
a2264 1
Trying with "$funkyftp$src_switch" to get
d2267 2
a2268 1
	    my($system) = "$funkyftp$src_switch '$url.gz' $devnull > $asl_gz";
d2273 1
a2273 1
		-s $asl_gz
d2276 3
a2278 2
	      if (CPAN::Tarzip->gtest($asl_gz)) {
                  CPAN::Tarzip->gunzip($asl_gz,$aslocal);
d2280 1
a2280 2
                  # somebody uncompressed file for us?
                  rename $asl_ungz, $aslocal;
d2285 2
a2286 1
	      unlink $asl_gz if -f $asl_gz;
d2298 2
a2299 3
          return if $CPAN::Signal;
	} # lynx,ncftpget,ncftp
    } # host
d2314 4
a2369 1
                return if $CPAN::Signal;
a2398 1
        return if $CPAN::Signal;
d2401 1
a2401 1
    } # host
a2528 1
# CPAN::FTP::hasdefault;
d2576 8
a2583 2
	@@return = grep /^$word/, @@CPAN::Complete::COMMANDS;
    } elsif ( $line !~ /^[\!abcdghimorutl]/ ) {
d2585 2
a2586 2
    } elsif ($line =~ /^(a|ls)\s/) {
	@@return = cplx('CPAN::Author',uc($word));
a2587 1
        CPAN::Shell->local_bundles;
d2591 1
a2591 6
    } elsif ($line =~ m/^(
                          [mru]|make|clean|dump|get|test|install|readme|look|cvs_import
                         )\s/x ) {
        if ($word =~ /^Bundle::/) {
            CPAN::Shell->local_bundles;
        }
a2598 3
    } elsif ($line =~ m/^\S+\s/ ) {
        # fallback for future commands and what we have forgotten above
	@@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
d2608 1
a2608 5
    # I believed for many years that this was sorted, today I
    # realized, it wasn't sorted anymore. Now (rev 1.301 / v 1.55) I
    # make it sorted again. Maybe sort was dropped when GNU-readline
    # support came in? The RCS file is difficult to read on that:-(
    sort grep /^\Q$word\E/, map { $_->id } $CPAN::META->all_objects($class);
d2657 1
a2657 1
    $CPAN::Index::LAST_TIME = 0;
d2671 1
a2671 14
    unless (1 || $CPAN::Have_warned->{readmetadatacache}++) {
        # debug here when CPAN doesn't seem to read the Metadata
        require Carp;
        Carp::cluck("META-PROTOCOL[$CPAN::META->{PROTOCOL}]");
    }
    unless ($CPAN::META->{PROTOCOL}) {
        $cl->read_metadata_cache;
        $CPAN::META->{PROTOCOL} ||= "1.0";
    }
    if ( $CPAN::META->{PROTOCOL} < PROTOCOL  ) {
        # warn "Setting last_time to 0";
        $LAST_TIME = 0; # No warning necessary
    }
    return if $LAST_TIME + $CPAN::Config->{index_expire}*86400 > $time
d2673 43
a2715 50
    if (0) {
        # IFF we are developing, it helps to wipe out the memory
        # between reloads, otherwise it is not what a user expects.
        undef $CPAN::META; # Neue Gruendlichkeit since v1.52(r1.274)
        $CPAN::META = CPAN->new;
    }
    {
        my($debug,$t2);
        local $LAST_TIME = $time;
        local $CPAN::META->{PROTOCOL} = PROTOCOL;

        my $needshort = $^O eq "dos";

        $cl->rd_authindex($cl
                          ->reload_x(
                                     "authors/01mailrc.txt.gz",
                                     $needshort ?
                                     File::Spec->catfile('authors', '01mailrc.gz') :
                                     File::Spec->catfile('authors', '01mailrc.txt.gz'),
                                     $force));
        $t2 = time;
        $debug = "timing reading 01[".($t2 - $time)."]";
        $time = $t2;
        return if $CPAN::Signal; # this is sometimes lengthy
        $cl->rd_modpacks($cl
                         ->reload_x(
                                    "modules/02packages.details.txt.gz",
                                    $needshort ?
                                    File::Spec->catfile('modules', '02packag.gz') :
                                    File::Spec->catfile('modules', '02packages.details.txt.gz'),
                                    $force));
        $t2 = time;
        $debug .= "02[".($t2 - $time)."]";
        $time = $t2;
        return if $CPAN::Signal; # this is sometimes lengthy
        $cl->rd_modlist($cl
                        ->reload_x(
                                   "modules/03modlist.data.gz",
                                   $needshort ?
                                   File::Spec->catfile('modules', '03mlist.gz') :
                                   File::Spec->catfile('modules', '03modlist.data.gz'),
                                   $force));
        $cl->write_metadata_cache;
        $t2 = time;
        $debug .= "03[".($t2 - $time)."]";
        $time = $t2;
        CPAN->debug($debug) if $CPAN::DEBUG;
    }
    $LAST_TIME = $time;
    $CPAN::META->{PROTOCOL} = PROTOCOL;
d2748 3
d2776 1
a2776 1
    my($self, $index_target) = @@_;
a2787 2
    # read header
    my($line_count,$last_updated);
a2790 53
	$shift =~ /^Line-Count:\s+(\d+)/ and $line_count = $1;
        $shift =~ /^Last-Updated:\s+(.+)/ and $last_updated = $1;
    }
    if (not defined $line_count) {

	warn qq{Warning: Your $index_target does not contain a Line-Count header.
Please check the validity of the index file by comparing it to more
than one CPAN mirror. I'll continue but problems seem likely to
happen.\a
};

	sleep 5;
    } elsif ($line_count != scalar @@lines) {

	warn sprintf qq{Warning: Your %s
contains a Line-Count header of %d but I see %d lines there. Please
check the validity of the index file by comparing it to more than one
CPAN mirror. I'll continue but problems seem likely to happen.\a\n},
$index_target, $line_count, scalar(@@lines);

    }
    if (not defined $last_updated) {

	warn qq{Warning: Your $index_target does not contain a Last-Updated header.
Please check the validity of the index file by comparing it to more
than one CPAN mirror. I'll continue but problems seem likely to
happen.\a
};

	sleep 5;
    } else {

	$CPAN::Frontend
            ->myprint(sprintf qq{  Database was generated on %s\n},
                      $last_updated);
        $DATE_OF_02 = $last_updated;

        if ($CPAN::META->has_inst(HTTP::Date)) {
            require HTTP::Date;
            my($age) = (time - HTTP::Date::str2time($last_updated))/3600/24;
            if ($age > 30) {

                $CPAN::Frontend
                    ->mywarn(sprintf
                             qq{Warning: This index file is %d days old.
  Please check the host you chose as your CPAN mirror for staleness.
  I'll continue but problems seem likely to happen.\a\n},
                             $age);

            }
        } else {
            $CPAN::Frontend->myprint("  HTTP::Date not available\n");
        }
a2791 7


    # A necessity since we have metadata_cache: delete what isn't
    # there anymore
    my $secondtime = $CPAN::META->exists("CPAN::Module","CPAN");
    CPAN->debug("secondtime[$secondtime]") if $CPAN::DEBUG;
    my(%exists);
d2794 4
a2797 4
        # before 1.56 we split into 3 and discarded the rest. From
        # 1.57 we assign remaining text to $comment thus allowing to
        # influence isa_perl
	my($mod,$version,$dist,$comment) = split " ", $_, 4;
d2806 4
a2809 4
            local($^W)= 0;
            if ($version > $CPAN::VERSION){
                $CPAN::Frontend->myprint(qq{
  There's a new CPAN.pm version (v$version) available!
d2816 2
a2817 2
}); #});
                sleep 2;
d2827 1
d2829 3
a2831 1
	    # in common with modules.
d2833 4
a2836 6
            # Changed in 1.57_63: seems like memory bloat now without
            # any value, so commented out

	    # $CPAN::META->instance('CPAN::Module',$mod);

	} else {
d2838 2
a2841 1

d2844 2
a2845 4
	if ($id->cpan_file ne $dist){ # update only if file is
                                      # different. CPAN prohibits same
                                      # name with different version
	    $userid = $self->userid($dist);
d2849 1
a2849 1
		     'CPAN_FILE' => $dist,
d2866 1
a2866 2
				      'CPAN_USERID' => $userid,
                                      'CPAN_COMMENT' => $comment,
d2869 1
a2869 6
        if ($secondtime) {
            for my $name ($mod,$dist) {
                CPAN->debug("exists name[$name]") if $CPAN::DEBUG;
                $exists{$name} = undef;
            }
        }
a2872 10
    if ($secondtime) {
        for my $class (qw(CPAN::Module CPAN::Bundle CPAN::Distribution)) {
            for my $o ($CPAN::META->all_objects($class)) {
                next if exists $exists{$o->{ID}};
                $CPAN::META->delete($class,$o->{ID});
                CPAN->debug("deleting ID[$o->{ID}] in class[$class]")
                    if $CPAN::DEBUG;
            }
        }
    }
d2892 2
a2893 2
	    return if $DATE_OF_03 eq $1;
	    ($DATE_OF_03) = $1;
d2906 1
a2906 2
	my $obj = $CPAN::META->instance("CPAN::Module",$_);
        delete $ret->{$_}{modid}; # not needed here, maybe elsewhere
a2911 78
#-> sub CPAN::Index::write_metadata_cache ;
sub write_metadata_cache {
    my($self) = @@_;
    return unless $CPAN::Config->{'cache_metadata'};
    return unless $CPAN::META->has_usable("Storable");
    my $cache;
    foreach my $k (qw(CPAN::Bundle CPAN::Author CPAN::Module
		      CPAN::Distribution)) {
	$cache->{$k} = $CPAN::META->{readonly}{$k}; # unsafe meta access, ok
    }
    my $metadata_file = MM->catfile($CPAN::Config->{cpan_home},"Metadata");
    $cache->{last_time} = $LAST_TIME;
    $cache->{DATE_OF_02} = $DATE_OF_02;
    $cache->{PROTOCOL} = PROTOCOL;
    $CPAN::Frontend->myprint("Going to write $metadata_file\n");
    eval { Storable::nstore($cache, $metadata_file) };
    $CPAN::Frontend->mywarn($@@) if $@@;
}

#-> sub CPAN::Index::read_metadata_cache ;
sub read_metadata_cache {
    my($self) = @@_;
    return unless $CPAN::Config->{'cache_metadata'};
    return unless $CPAN::META->has_usable("Storable");
    my $metadata_file = MM->catfile($CPAN::Config->{cpan_home},"Metadata");
    return unless -r $metadata_file and -f $metadata_file;
    $CPAN::Frontend->myprint("Going to read $metadata_file\n");
    my $cache;
    eval { $cache = Storable::retrieve($metadata_file) };
    $CPAN::Frontend->mywarn($@@) if $@@;
    if (!$cache || ref $cache ne 'HASH'){
        $LAST_TIME = 0;
        return;
    }
    if (exists $cache->{PROTOCOL}) {
        if (PROTOCOL > $cache->{PROTOCOL}) {
            $CPAN::Frontend->mywarn(sprintf("Ignoring Metadata cache written ".
                                            "with protocol v%s, requiring v%s",
                                            $cache->{PROTOCOL},
                                            PROTOCOL)
                                   );
            return;
        }
    } else {
        $CPAN::Frontend->mywarn("Ignoring Metadata cache written ".
                                "with protocol v1.0");
        return;
    }
    my $clcnt = 0;
    my $idcnt = 0;
    while(my($class,$v) = each %$cache) {
	next unless $class =~ /^CPAN::/;
	$CPAN::META->{readonly}{$class} = $v; # unsafe meta access, ok
        while (my($id,$ro) = each %$v) {
            $CPAN::META->{readwrite}{$class}{$id} ||=
                $class->new(ID=>$id, RO=>$ro);
            $idcnt++;
        }
        $clcnt++;
    }
    unless ($clcnt) { # sanity check
        $CPAN::Frontend->myprint("Warning: Found no data in $metadata_file\n");
        return;
    }
    if ($idcnt < 1000) {
        $CPAN::Frontend->myprint("Warning: Found only $idcnt objects ".
                                 "in $metadata_file\n");
        return;
    }
    $CPAN::META->{PROTOCOL} ||=
        $cache->{PROTOCOL}; # reading does not up or downgrade, but it
                            # does initialize to some protocol
    $LAST_TIME = $cache->{last_time};
    $DATE_OF_02 = $cache->{DATE_OF_02};
    $CPAN::Frontend->myprint("  Database was generated on $DATE_OF_02\n");
    return;
}

a2913 4
# Accessors
sub cpan_userid { shift->{RO}{CPAN_USERID} }
sub id { shift->{ID}; }

d2915 1
a2915 11
sub new {
    my $this = bless {}, shift;
    %$this = @@_;
    $this
}

# The set method may only be used by code that reads index data or
# otherwise "objective" data from the outside world. All session
# related material may do anything else with instance variables but
# must not touch the hash under the RO attribute. The reason is that
# the RO hash gets written to Metadata file and is thus persistent.
d2920 3
a2922 14
    my $class = ref $self;

    # This must be ||=, not ||, because only if we write an empty
    # reference, only then the set method will write into the readonly
    # area. But for Distributions that spring into existence, maybe
    # because of a typo, we do not like it that they are written into
    # the readonly area and made permanent (at least for a while) and
    # that is why we do not "allow" other places to call ->set.
    unless ($self->id) {
        CPAN->debug("Bug? Empty ID, rejecting");
        return;
    }
    my $ro = $self->{RO} =
        $CPAN::META->{readonly}{$class}{$self->id} ||= {};
d2924 2
a2925 4
    while (my($k,$v) = each %att) {
        $ro->{$k} = $v;
    }
}
d2944 2
a2945 2
    for (sort keys %{$self->{RO}}) {
	# next if m/^(ID|RO)$/;
d2948 13
a2960 21
            $extra .= " (".$self->author;
            my $email; # old perls!
            if ($email = $CPAN::META->instance("CPAN::Author",
                                               $self->cpan_userid
                                              )->email) {
                $extra .= " <$email>";
            } else {
                $extra .= " <no email>";
            }
            $extra .= ")";
        } elsif ($_ eq "FULLNAME") { # potential UTF-8 conversion
            push @@m, sprintf "    %-12s %s\n", $_, $self->fullname;
            next;
        }
        next unless defined $self->{RO}{$_};
        push @@m, sprintf "    %-12s %s%s\n", $_, $self->{RO}{$_}, $extra;
    }
    for (sort keys %$self) {
	next if m/^(ID|RO)$/;
	if (ref($self->{$_}) eq "ARRAY") {
	  push @@m, sprintf "    %-12s %s\n", $_, "@@{$self->{$_}}";
d2963 1
a2963 1
			   "    %-12s %s\n",
d2966 1
a2966 1
                          );
d2968 1
a2968 1
	  push @@m, sprintf "    %-12s %s\n", $_, $self->{$_};
d2977 1
a2977 1
    $CPAN::META->instance("CPAN::Author",$self->cpan_userid)->fullname;
a2979 1
#-> sub CPAN::InfoObj::dump ;
d2983 1
a2983 1
  print Data::Dumper::Dumper($self);
a2987 8
#-> sub CPAN::Author::id
sub id {
    my $self = shift;
    my $id = $self->{ID};
    $CPAN::Frontend->mydie("Illegal author id[$id]") unless $id =~ /^[A-Z]/;
    $id;
}

d2994 1
a2994 5
    push @@m, sprintf(qq{%-15s %s ("%s" <%s>)\n},
                     $class,
                     $self->{ID},
                     $self->fullname,
                     $self->email);
d2998 6
d3005 1
a3005 3
sub fullname {
    shift->{RO}{FULLNAME};
}
d3009 1
a3009 1
sub email    { shift->{RO}{EMAIL}; }
d3011 1
a3011 4
#-> sub CPAN::Author::ls ;
sub ls {
    my $self = shift;
    my $id = $self->id;
d3013 5
a3017 155
    # adapted from CPAN::Distribution::verifyMD5 ;
    my(@@csf); # chksumfile
    @@csf = $self->id =~ /(.)(.)(.*)/;
    $csf[1] = join "", @@csf[0,1];
    $csf[2] = join "", @@csf[1,2];
    my(@@dl);
    @@dl = $self->dir_listing([$csf[0],"CHECKSUMS"], 0);
    unless (grep {$_->[2] eq $csf[1]} @@dl) {
        $CPAN::Frontend->myprint("No files in the directory of $id\n");
        return;
    }
    @@dl = $self->dir_listing([@@csf[0,1],"CHECKSUMS"], 0);
    unless (grep {$_->[2] eq $csf[2]} @@dl) {
        $CPAN::Frontend->myprint("No files in the directory of $id\n");
        return;
    }
    @@dl = $self->dir_listing([@@csf,"CHECKSUMS"], 1);
    $CPAN::Frontend->myprint(join "", map {
        sprintf("%8d %10s %s/%s\n", $_->[0], $_->[1], $id, $_->[2])
    } sort { $a->[2] cmp $b->[2] } @@dl);
}

# returns an array of arrays, the latter contain (size,mtime,filename)
#-> sub CPAN::Author::dir_listing ;
sub dir_listing {
    my $self = shift;
    my $chksumfile = shift;
    my $recursive = shift;
    my $lc_want =
	MM->catfile($CPAN::Config->{keep_source_where},
                    "authors", "id", @@$chksumfile);
    local($") = "/";
    # connect "force" argument with "index_expire".
    my $force = 0;
    if (my @@stat = stat $lc_want) {
        $force = $stat[9] + $CPAN::Config->{index_expire}*86400 <= time;
    }
    my $lc_file = CPAN::FTP->localize("authors/id/@@$chksumfile",
                                      $lc_want,$force);
    unless ($lc_file) {
        $CPAN::Frontend->myprint("Trying $lc_want.gz\n");
	$chksumfile->[-1] .= ".gz";
	$lc_file = CPAN::FTP->localize("authors/id/@@$chksumfile",
                                       "$lc_want.gz",1);
	if ($lc_file) {
	    $lc_file =~ s{\.gz(?!\n)\Z}{}; #};
	    CPAN::Tarzip->gunzip("$lc_file.gz",$lc_file);
	} else {
	    return;
	}
    }

    # adapted from CPAN::Distribution::MD5_check_file ;
    my $fh = FileHandle->new;
    my($cksum);
    if (open $fh, $lc_file){
	local($/);
	my $eval = <$fh>;
	$eval =~ s/\015?\012/\n/g;
	close $fh;
	my($comp) = Safe->new();
	$cksum = $comp->reval($eval);
	if ($@@) {
	    rename $lc_file, "$lc_file.bad";
	    Carp::confess($@@) if $@@;
	}
    } else {
	Carp::carp "Could not open $lc_file for reading";
    }
    my(@@result,$f);
    for $f (sort keys %$cksum) {
        if (exists $cksum->{$f}{isdir}) {
            if ($recursive) {
                my(@@dir) = @@$chksumfile;
                pop @@dir;
                push @@dir, $f, "CHECKSUMS";
                push @@result, map {
                    [$_->[0], $_->[1], "$f/$_->[2]"]
                } $self->dir_listing(\@@dir,1);
            } else {
                push @@result, [ 0, "-", $f ];
            }
        } else {
            push @@result, [
                           ($cksum->{$f}{"size"}||0),
                           $cksum->{$f}{"mtime"}||"---",
                           $f
                          ];
        }
    }
    @@result;
}

package CPAN::Distribution;

# Accessors
sub cpan_comment { shift->{RO}{CPAN_COMMENT} }

sub undelay {
    my $self = shift;
    delete $self->{later};
}

# CPAN::Distribution::normalize
sub normalize {
    my($self,$s) = @@_;
    $s = $self->id unless defined $s;
    if (
        $s =~ tr|/|| == 1
        or
        $s !~ m|[A-Z]/[A-Z-]{2}/[A-Z-]{2,}/|
       ) {
        return $s if $s =~ m:^N/A|^Contact Author: ;
        $s =~ s|^(.)(.)([^/]*/)(.+)$|$1/$1$2/$1$2$3$4| or
            $CPAN::Frontend->mywarn("Strange distribution name [$s]");
        CPAN->debug("s[$s]") if $CPAN::DEBUG;
    }
    $s;
}

#-> sub CPAN::Distribution::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    # a distribution needs to recurse into its prereq_pms

    return if exists $self->{incommandcolor}
        && $self->{incommandcolor}==$color;
    $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: deep recursion in ".
                                   "color_cmd_tmps depth[%s] self[%s] id[%s]",
                                   $depth,
                                   $self,
                                   $self->id
                                  )) if $depth>=100;
    ##### warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
    my $prereq_pm = $self->prereq_pm;
    if (defined $prereq_pm) {
        for my $pre (keys %$prereq_pm) {
            my $premo = CPAN::Shell->expand("Module",$pre);
            $premo->color_cmd_tmps($depth+1,$color);
        }
    }
    if ($color==0) {
        delete $self->{sponsored_mods};
        delete $self->{badtestcnt};
    }
    $self->{incommandcolor} = $color;
}

#-> sub CPAN::Distribution::as_string ;
sub as_string {
  my $self = shift;
  $self->containsmods;
  $self->SUPER::as_string(@@_);
d3023 1
a3023 2
  return keys %{$self->{CONTAINSMODS}} if exists $self->{CONTAINSMODS};
  my $dist_id = $self->{ID};
d3025 2
a3026 1
    my $mod_file = $mod->cpan_file or next;
a3027 2
    # warn "mod_file[$mod_file] dist_id[$dist_id] mod_id[$mod_id]";
    # sleep 1;
a3029 12
  keys %{$self->{CONTAINSMODS}};
}

#-> sub CPAN::Distribution::uptodate ;
sub uptodate {
    my($self) = @@_;
    my $c;
    foreach $c ($self->containsmods) {
        my $obj = CPAN::Shell->expandany($c);
        return 0 unless $obj->uptodate;
    }
    return 1;
d3035 2
a3036 18
    $self->{CALLED_FOR} = $id if defined $id;
    return $self->{CALLED_FOR};
}

#-> sub CPAN::Distribution::safe_chdir ;
sub safe_chdir {
    my($self,$todir) = @@_;
    # we die if we cannot chdir and we are debuggable
    Carp::confess("safe_chdir called without todir argument")
          unless defined $todir and length $todir;
    if (chdir $todir) {
        $self->debug(sprintf "changed directory to %s", CPAN::anycwd())
            if $CPAN::DEBUG;
    } else {
        my $cwd = CPAN::anycwd();
        $CPAN::Frontend->mydie(qq{Could not chdir from cwd[$cwd] }.
                               qq{to todir[$todir]: $!});
    }
d3045 1
a3045 1
	    "Is already unwrapped into directory $self->{'build_dir'}";
a3047 6
    my $sub_wd = CPAN::anycwd(); # for cleaning up as good as possible

    #
    # Get the file on local disk
    #

d3050 6
a3055 6
        MM->catfile(
                    $CPAN::Config->{keep_source_where},
                    "authors",
                    "id",
                    split("/",$self->id)
                   );
d3058 3
a3060 11
    unless ($local_file =
            CPAN::FTP->localize("authors/id/$self->{ID}",
                                $local_wanted)) {
        my $note = "";
        if ($CPAN::Index::DATE_OF_02) {
            $note = "Note: Current database in memory was generated ".
                "on $CPAN::Index::DATE_OF_02\n";
        }
        $CPAN::Frontend->mydie("Giving up on '$local_wanted'\n$note");
    }
    $self->debug("local_file[$local_file]") if $CPAN::DEBUG;
d3062 4
a3065 1
    return if $CPAN::Signal;
d3067 2
a3068 4
    #
    # Check integrity
    #
    if ($CPAN::META->has_inst("MD5")) {
a3073 8
    return if $CPAN::Signal;

    #
    # Create a clean room and go there
    #
    $CPAN::META->{cachemgr} ||= CPAN::CacheMgr->new(); # unsafe meta access, ok
    my $builddir = $CPAN::META->{cachemgr}->dir; # unsafe meta access, ok
    $self->safe_chdir($builddir);
d3077 5
a3081 11
    if ($CPAN::Signal){
        $self->safe_chdir($sub_wd);
        return;
    }
    $self->safe_chdir("tmp");

    #
    # Unpack the goods
    #
    if ($local_file =~ /(\.tar\.(gz|Z)|\.tgz)(?!\n)\Z/i){
        $self->{was_uncompressed}++ unless CPAN::Tarzip->gtest($local_file);
d3083 1
a3083 1
    } elsif ( $local_file =~ /\.zip(?!\n)\Z/i ) {
d3085 1
a3085 2
    } elsif ( $local_file =~ /\.pm\.(gz|Z)(?!\n)\Z/) {
        $self->{was_uncompressed}++ unless CPAN::Tarzip->gtest($local_file);
a3088 2
        $self->safe_chdir($sub_wd);
        return;
d3090 29
d3120 15
a3134 73
    # we are still in the tmp directory!
    # Let's check if the package has its own directory.
    my $dh = DirHandle->new(File::Spec->curdir)
        or Carp::croak("Couldn't opendir .: $!");
    my @@readdir = grep $_ !~ /^\.\.?(?!\n)\Z/s, $dh->read; ### MAC??
    $dh->close;
    my ($distdir,$packagedir);
    if (@@readdir == 1 && -d $readdir[0]) {
        $distdir = $readdir[0];
        $packagedir = MM->catdir($builddir,$distdir);
        $self->debug("packagedir[$packagedir]builddir[$builddir]distdir[$distdir]")
            if $CPAN::DEBUG;
        -d $packagedir and $CPAN::Frontend->myprint("Removing previously used ".
                                                    "$packagedir\n");
        File::Path::rmtree($packagedir);
        rename($distdir,$packagedir) or
            Carp::confess("Couldn't rename $distdir to $packagedir: $!");
        $self->debug(sprintf("renamed distdir[%s] to packagedir[%s] -e[%s]-d[%s]",
                             $distdir,
                             $packagedir,
                             -e $packagedir,
                             -d $packagedir,
                            )) if $CPAN::DEBUG;
    } else {
        my $userid = $self->cpan_userid;
        unless ($userid) {
            CPAN->debug("no userid? self[$self]");
            $userid = "anon";
        }
        my $pragmatic_dir = $userid . '000';
        $pragmatic_dir =~ s/\W_//g;
        $pragmatic_dir++ while -d "../$pragmatic_dir";
        $packagedir = MM->catdir($builddir,$pragmatic_dir);
        $self->debug("packagedir[$packagedir]") if $CPAN::DEBUG;
        File::Path::mkpath($packagedir);
        my($f);
        for $f (@@readdir) { # is already without "." and ".."
            my $to = MM->catdir($packagedir,$f);
            rename($f,$to) or Carp::confess("Couldn't rename $f to $to: $!");
        }
    }
    if ($CPAN::Signal){
        $self->safe_chdir($sub_wd);
        return;
    }

    $self->{'build_dir'} = $packagedir;
    $self->safe_chdir(File::Spec->updir);
    File::Path::rmtree("tmp");

    my($mpl) = MM->catfile($packagedir,"Makefile.PL");
    my($mpl_exists) = -f $mpl;
    unless ($mpl_exists) {
        # NFS has been reported to have racing problems after the
        # renaming of a directory in some environments.
        # This trick helps.
        sleep 1;
        my $mpldh = DirHandle->new($packagedir)
            or Carp::croak("Couldn't opendir $packagedir: $!");
        $mpl_exists = grep /^Makefile\.PL$/, $mpldh->read;
        $mpldh->close;
    }
    unless ($mpl_exists) {
        $self->debug(sprintf("makefilepl[%s]anycwd[%s]",
                             $mpl,
                             CPAN::anycwd(),
                            )) if $CPAN::DEBUG;
        my($configure) = MM->catfile($packagedir,"Configure");
        if (-f $configure) {
            # do we have anything to do?
            $self->{'configure'} = $configure;
        } elsif (-f MM->catfile($packagedir,"Makefile")) {
            $CPAN::Frontend->myprint(qq{
d3138 7
a3144 22
            $self->{writemakefile} = "YES";
            sleep 2;
        } else {
            my $cf = $self->called_for || "unknown";
            if ($cf =~ m|/|) {
                $cf =~ s|.*/||;
                $cf =~ s|\W.*||;
            }
            $cf =~ s|[/\\:]||g; # risk of filesystem damage
            $cf = "unknown" unless length($cf);
            $CPAN::Frontend->myprint(qq{Package seems to come without Makefile.PL.
  (The test -f "$mpl" returned false.)
  Writing one on our own (setting NAME to $cf)\a\n});
            $self->{had_no_makefile_pl}++;
            sleep 3;

            # Writing our own Makefile.PL

            my $fh = FileHandle->new;
            $fh->open(">$mpl")
                or Carp::croak("Could not open >$mpl: $!");
            $fh->print(
d3153 4
a3156 2
            $fh->close;
        }
a3157 1

a3160 1
# CPAN::Distribution::untar_me ;
a3170 1
# CPAN::Distribution::unzip_me ;
d3174 2
a3175 1
    if (CPAN::Tarzip->unzip($local_file)) {
a3179 1
    return;
d3186 1
a3186 1
    $to =~ s/\.(gz|Z)(?!\n)\Z//;
d3198 1
a3198 1
    # $CPAN::META->{cachemgr} ||= CPAN::CacheMgr->new();
d3225 6
a3230 12
    my $dir;
    unless ($dir = $self->dir) {
        $self->get;
    }
    unless ($dir ||= $self->dir) {
	$CPAN::Frontend->mywarn(qq{
Could not determine which directory to use for looking at $dist.
});
	return;
    }
    my $pwd  = CPAN::anycwd();
    $self->safe_chdir($dir);
d3234 1
a3234 1
    $self->safe_chdir($pwd);
a3236 1
# CPAN::Distribution::cvs_import ;
d3246 1
a3246 1
    my $userid = $self->cpan_userid;
d3249 1
a3249 1
    $cvs_dir =~ s/-\d+[^-]+(?!\n)\Z//;
d3262 4
a3265 2
    my $pwd  = CPAN::anycwd();
    chdir($dir) or $CPAN::Frontend->mydie(qq{Could not chdir to "$dir": $!});
d3270 1
a3270 1
    system(@@cmd) == 0 or
d3272 1
a3272 1
    chdir($pwd) or $CPAN::Frontend->mydie(qq{Could not chdir to "$pwd": $!});
d3325 1
a3325 1
    @@local = split("/",$self->id);
a3341 1
        $CPAN::Frontend->myprint("Trying $lc_want.gz\n");
d3346 1
a3346 1
	    $lc_file =~ s/\.gz(?!\n)\Z//;
d3404 1
a3404 1
	    $CPAN::Frontend->myprint(qq{\nChecksum mismatch for }.
d3410 1
a3410 1
							   $self->cpan_userid
d3412 3
a3414 4

	    my $wrap = qq{I\'d recommend removing $file. Its MD5
checksum is incorrect. Maybe you have configured your 'urllist' with
a bad URL. Please check this array with 'o conf urllist', and
d3416 4
a3419 9

            $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));

            # former versions just returned here but this seems a
            # serious threat that deserves a die

	    # $CPAN::Frontend->myprint("\n\n");
	    # sleep 3;
	    # return;
d3425 3
a3427 6
	    $CPAN::Frontend->mywarn(qq{
Warning: No md5 checksum for $basename in $chk_file.

The cause for this may be that the file is very new and the checksum
has not yet been calculated, but it may also be that something is
going awry right now.
d3429 2
a3430 2
            my $answer = ExtUtils::MakeMaker::prompt("Proceed?", "yes");
            $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted.");
a3451 11

# Both modules and distributions know if "force" is in effect by
# autoinspection, not by inspecting a global variable. One of the
# reason why this was chosen to work that way was the treatment of
# dependencies. They should not autpomatically inherit the force
# status. But this has the downside that ^C and die() will return to
# the prompt but will not be able to reset the force_update
# attributes. We try to correct for it currently in the read_metadata
# routine, and immediately before we check for a Signal. I hope this
# works out in one of v1.57_53ff

d3453 2
a3454 1
  my($self, $method) = @@_;
a3460 9
  if ($method && $method eq "install") {
    $self->{"force_update"}++; # name should probably have been force_install
  }
}

#-> sub CPAN::Distribution::unforce ;
sub unforce {
  my($self) = @@_;
  delete $self->{'force_update'};
a3462 1
#-> sub CPAN::Distribution::isa_perl ;
d3466 8
a3473 18
  if ($file =~ m{ ^ perl
                  -?
		  (5)
		  ([._-])
		  (
                   \d{3}(_[0-4][0-9])?
                   |
                   \d*[24680]\.\d+
                  )
		  \.tar[._-]gz
		  (?!\n)\Z
		}xs){
    return "$1.$3";
  } elsif ($self->cpan_comment
           &&
           $self->cpan_comment =~ /isa_perl\(.+?\)/){
    return $1;
  }
d3480 2
a3481 1
    my $pwd  = CPAN::anycwd();
d3508 1
a3508 2
	  $self->called_for ne $self->id &&
          ! $self->{force_update}
d3510 1
a3510 2
        # if we die here, we break bundles
	$CPAN::Frontend->mywarn(sprintf qq{
a3525 1
        sleep 5; return;
d3542 1
a3542 4
            "Has already been processed within this session";

        exists $self->{later} and length($self->{later}) and
            push @@e, $self->{later};
a3608 1
          delete $self->{make_clean}; # if cleaned before, enable next
d3618 5
a3622 17
    if ($CPAN::Signal){
      delete $self->{force_update};
      return;
    }
    if (my @@prereq = $self->unsat_prereq){
      return 1 if $self->follow_prereqs(@@prereq); # signal success to the queuerunner
    }
    $system = join " ", $CPAN::Config->{'make'}, $CPAN::Config->{make_arg};
    if (system($system) == 0) {
	 $CPAN::Frontend->myprint("  $system -- OK\n");
	 $self->{'make'} = "YES";
    } else {
	 $self->{writemakefile} ||= "YES";
	 $self->{'make'} = "NO";
	 $CPAN::Frontend->myprint("  $system -- NOT OK\n");
    }
}
d3624 1
a3624 8
sub follow_prereqs {
    my($self) = shift;
    my(@@prereq) = @@_;
    my $id = $self->id;
    $CPAN::Frontend->myprint("---- Unsatisfied dependencies detected ".
                             "during [$id] -----\n");

    for my $p (@@prereq) {
d3626 3
a3628 3
    }
    my $follow = 0;
    if ($CPAN::Config->{prerequisites_policy} eq "follow") {
d3630 1
a3630 1
    } elsif ($CPAN::Config->{prerequisites_policy} eq "ask") {
d3636 1
a3636 1
    } else {
d3638 6
a3643 2
	$CPAN::Frontend->
            myprint("  Ignoring dependencies on modules @@prereq\n");
d3645 8
a3652 54
    if ($follow) {
        # color them as dirty
        for my $p (@@prereq) {
            CPAN::Shell->expandany($p)->color_cmd_tmps(0,1);
        }
        CPAN::Queue->jumpqueue(@@prereq,$id); # queue them and requeue yourself
        $self->{later} = "Delayed until after prerequisites";
        return 1; # signal success to the queuerunner
    }
}

#-> sub CPAN::Distribution::unsat_prereq ;
sub unsat_prereq {
    my($self) = @@_;
    my $prereq_pm = $self->prereq_pm or return;
    my(@@need);
  NEED: while (my($need_module, $need_version) = each %$prereq_pm) {
        my $nmo = $CPAN::META->instance("CPAN::Module",$need_module);
        # we were too demanding:
        next if $nmo->uptodate;

        # if they have not specified a version, we accept any installed one
        if (not defined $need_version or
           $need_version == 0 or
           $need_version eq "undef") {
            next if defined $nmo->inst_file;
        }

        # We only want to install prereqs if either they're not installed
        # or if the installed version is too old. We cannot omit this
        # check, because if 'force' is in effect, nobody else will check.
        {
            local($^W) = 0;
            if (
                defined $nmo->inst_file &&
                ! CPAN::Version->vgt($need_version, $nmo->inst_version)
               ){
                CPAN->debug(sprintf "id[%s]inst_file[%s]inst_version[%s]need_version[%s]",
                            $nmo->id,
                            $nmo->inst_file,
                            $nmo->inst_version,
                            CPAN::Version->readable($need_version)
                           );
                next NEED;
            }
        }

        if ($self->{sponsored_mods}{$need_module}++){
            # We have already sponsored it and for some reason it's still
            # not available. So we do nothing. Or what should we do?
            # if we push it again, we have a potential infinite loop
            next;
        }
        push @@need, $need_module;
a3653 1
    @@need;
d3656 2
a3657 2
#-> sub CPAN::Distribution::prereq_pm ;
sub prereq_pm {
d3659 9
a3667 18
  return $self->{prereq_pm} if
      exists $self->{prereq_pm_detected} && $self->{prereq_pm_detected};
  return unless $self->{writemakefile}; # no need to have succeeded
                                        # but we must have run it
  my $build_dir = $self->{build_dir} or die "Panic: no build_dir?";
  my $makefile = File::Spec->catfile($build_dir,"Makefile");
  my(%p) = ();
  my $fh;
  if (-f $makefile
      and
      $fh = FileHandle->new("<$makefile\0")) {

      local($/) = "\n";

      #  A.Speer @@p -> %p, where %p is $p{Module::Name}=Required_Version
      while (<$fh>) {
          last if /MakeMaker post_initialize section/;
          my($p) = m{^[\#]
d3670 2
a3671 2
          next unless $p;
          # warn "Found prereq expr[$p]";
d3673 17
a3689 11
          #  Regexp modified by A.Speer to remember actual version of file
          #  PREREQ_PM hash key wants, then add to
          while ( $p =~ m/(?:\s)([\w\:]+)=>q\[(.*?)\],?/g ){
              # In case a prereq is mentioned twice, complain.
              if ( defined $p{$1} ) {
                  warn "Warning: PREREQ_PM mentions $1 more than once, last mention wins";
              }
              $p{$1} = $2;
          }
          last;
      }
d3691 1
a3691 2
  $self->{prereq_pm_detected}++;
  return $self->{prereq_pm} = \%p;
d3698 1
a3698 4
    if ($CPAN::Signal){
      delete $self->{force_update};
      return;
    }
a3699 3
    if (my @@prereq = $self->unsat_prereq){
      return 1 if $self->follow_prereqs(@@prereq); # signal success to the queuerunner
    }
d3702 1
a3702 1
	exists $self->{make} or exists $self->{later} or push @@e,
d3707 1
a3707 9
		push @@e, "Can't test without successful make";

	exists $self->{build_dir} or push @@e, "Has no own directory";
        $self->{badtestcnt} ||= 0;
        $self->{badtestcnt} > 0 and
            push @@e, "Won't repeat unsuccessful test during this command";

        exists $self->{later} and length($self->{later}) and
            push @@e, $self->{later};
d3709 1
d3725 1
a3725 1
	 $self->{make_test} = "YES";
d3727 1
a3727 2
	 $self->{make_test} = "NO";
         $self->{badtestcnt}++;
d3738 1
a3738 3
        exists $self->{make_clean} and $self->{make_clean} eq "YES" and
            push @@e, "make clean already called once";
	exists $self->{build_dir} or push @@e, "Has no own directory";
d3752 2
a3753 16
      $CPAN::Frontend->myprint("  $system -- OK\n");

      # $self->force;

      # Jost Krieger pointed out that this "force" was wrong because
      # it has the effect that the next "install" on this distribution
      # will untar everything again. Instead we should bring the
      # object's state back to where it is after untarring.

      delete $self->{force_update};
      delete $self->{install};
      delete $self->{writemakefile};
      delete $self->{make};
      delete $self->{make_test}; # no matter if yes or no, tests must be redone
      $self->{make_clean} = "YES";

d3755 1
a3755 8
      # Hmmm, what to do if make clean failed?

      $CPAN::Frontend->myprint(qq{  $system -- NOT OK

make clean did not succeed, marking directory as unusable for further work.
});
      $self->force("make"); # so that this directory won't be used again

d3763 1
a3763 4
    if ($CPAN::Signal){
      delete $self->{force_update};
      return;
    }
d3767 1
a3767 1
	exists $self->{build_dir} or push @@e, "Has no own directory";
d3769 1
a3769 1
	exists $self->{make} or exists $self->{later} or push @@e,
d3774 1
a3774 1
		push @@e, "make had returned bad status, install seems impossible";
a3785 3
        exists $self->{later} and length($self->{later}) and
            push @@e, $self->{later};

a3818 1
    delete $self->{force_update};
a3827 38
sub undelay {
    my $self = shift;
    delete $self->{later};
    for my $c ( $self->contains ) {
        my $obj = CPAN::Shell->expandany($c) or next;
        $obj->undelay;
    }
}

#-> sub CPAN::Bundle::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    # a module needs to recurse to its cpan_file, a distribution needs
    # to recurse into its prereq_pms, a bundle needs to recurse into its modules

    return if exists $self->{incommandcolor}
        && $self->{incommandcolor}==$color;
    $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: deep recursion in ".
                                   "color_cmd_tmps depth[%s] self[%s] id[%s]",
                                   $depth,
                                   $self,
                                   $self->id
                                  )) if $depth>=100;
    ##### warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;

    for my $c ( $self->contains ) {
        my $obj = CPAN::Shell->expandany($c) or next;
        CPAN->debug("c[$c]obj[$obj]") if $CPAN::DEBUG;
        $obj->color_cmd_tmps($depth+1,$color);
    }
    if ($color==0) {
        delete $self->{badtestcnt};
    }
    $self->{incommandcolor} = $color;
}

a3831 1
    # following line must be "=", not "||=" because we have a moving target
d3838 47
a3884 53
    my($self) = @@_;
    my($inst_file) = $self->inst_file || "";
    my($id) = $self->id;
    $self->debug("inst_file[$inst_file]id[$id]") if $CPAN::DEBUG;
    unless ($inst_file) {
        # Try to get at it in the cpan directory
        $self->debug("no inst_file") if $CPAN::DEBUG;
        my $cpan_file;
        $CPAN::Frontend->mydie("I don't know a bundle with ID $id\n") unless
              $cpan_file = $self->cpan_file;
        if ($cpan_file eq "N/A") {
            $CPAN::Frontend->mydie("Bundle $id not found on disk and not on CPAN.
  Maybe stale symlink? Maybe removed during session? Giving up.\n");
        }
        my $dist = $CPAN::META->instance('CPAN::Distribution',
                                         $self->cpan_file);
        $dist->get;
        $self->debug($dist->as_string) if $CPAN::DEBUG;
        my($todir) = $CPAN::Config->{'cpan_home'};
        my(@@me,$from,$to,$me);
        @@me = split /::/, $self->id;
        $me[-1] .= ".pm";
        $me = MM->catfile(@@me);
        $from = $self->find_bundle_file($dist->{'build_dir'},$me);
        $to = MM->catfile($todir,$me);
        File::Path::mkpath(File::Basename::dirname($to));
        File::Copy::copy($from, $to)
              or Carp::confess("Couldn't copy $from to $to: $!");
        $inst_file = $to;
    }
    my @@result;
    my $fh = FileHandle->new;
    local $/ = "\n";
    open($fh,$inst_file) or die "Could not open '$inst_file': $!";
    my $in_cont = 0;
    $self->debug("inst_file[$inst_file]") if $CPAN::DEBUG;
    while (<$fh>) {
        $in_cont = m/^=(?!head1\s+CONTENTS)/ ? 0 :
            m/^=head1\s+CONTENTS/ ? 1 : $in_cont;
        next unless $in_cont;
        next if /^=/;
        s/\#.*//;
        next if /^\s+$/;
        chomp;
        push @@result, (split " ", $_, 2)[0];
    }
    close $fh;
    delete $self->{STATUS};
    $self->{CONTAINS} = \@@result;
    $self->debug("CONTAINS[@@result]") if $CPAN::DEBUG;
    unless (@@result) {
        $CPAN::Frontend->mywarn(qq{
The bundle file "$inst_file" may be a broken
d3889 2
a3890 2
    }
    @@result;
d3903 3
a3905 2
	my $cwd = CPAN::anycwd();
	chdir $where or $CPAN::Frontend->mydie(qq{Could not chdir to "$where": $!});
d3907 1
a3907 1
	chdir $cwd or $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!});
a3938 5
# needs to work quite differently from Module::inst_file because of
# cpan_home/Bundle/ directory and the possibility that we have
# shadowing effect. As it makes no sense to take the first in @@INC for
# Bundles, we parse them all for $VERSION and take the newest.

d3942 13
a3954 23
    my($inst_file);
    my(@@me);
    @@me = split /::/, $self->id;
    $me[-1] .= ".pm";
    my($incdir,$bestv);
    foreach $incdir ($CPAN::Config->{'cpan_home'},@@INC) {
        my $bfile = MM->catfile($incdir, @@me);
        CPAN->debug("bfile[$bfile]") if $CPAN::DEBUG;
        next unless -f $bfile;
        my $foundv = MM->parse_version($bfile);
        if (!$bestv || CPAN::Version->vgt($foundv,$bestv)) {
            $self->{INST_FILE} = $bfile;
            $self->{INST_VERSION} = $bestv = $foundv;
        }
    }
    $self->{INST_FILE};
}

#-> sub CPAN::Bundle::inst_version ;
sub inst_version {
    my($self) = @@_;
    $self->inst_file; # finds INST_VERSION as side effect
    $self->{INST_VERSION};
d3963 1
a3963 1
	unless $self->inst_file || $self->cpan_file;
a3975 1
        $self->debug("type[$type] s[$s]") if $CPAN::DEBUG;
d3978 3
a3980 23
        if ($obj->isa(CPAN::Bundle)
            &&
            exists $obj->{install_failed}
            &&
            ref($obj->{install_failed}) eq "HASH"
           ) {
          for (keys %{$obj->{install_failed}}) {
            $self->{install_failed}{$_} = undef; # propagate faiure up
                                                 # to me in a
                                                 # recursive call
            $fail{$s} = 1; # the bundle itself may have succeeded but
                           # not all children
          }
        } else {
          my $success;
          $success = $obj->can("uptodate") ? $obj->uptodate : 0;
          $success ||= $obj->{'install'} && $obj->{'install'} eq "YES";
          if ($success) {
            delete $self->{install_failed}{$s};
          } else {
            $fail{$s} = 1;
          }
        }
a3981 1

d3983 1
a3983 1
    if ( $meth eq "install" ) {
a3992 1
            my %reported;
d3994 1
a3994 5
              if ($fail{$s}){
		$paragraph .= "$s ";
                $self->{install_failed}{$s} = undef;
                $reported{$s} = undef;
              }
a3995 7
            my $report_propagated;
            for $s (sort keys %{$self->{install_failed}}) {
              next if exists $reported{$s};
              $paragraph .= "and the following items had problems
during recursive bundle calls: " unless $report_propagated++;
              $paragraph .= "$s ";
            }
d4018 1
a4018 5
sub test    {
    my $self = shift;
    $self->{badtestcnt} ||= 0;
    $self->rematein('test',@@_);
}
a4026 12
#-> sub CPAN::Bundle::uptodate ;
sub uptodate {
    my($self) = @@_;
    return 0 unless $self->SUPER::uptodate; # we mut have the current Bundle def
    my $c;
    foreach $c ($self->contains) {
        my $obj = CPAN::Shell->expandany($c);
        return 0 unless $obj->uptodate;
    }
    return 1;
}

d4038 10
a4047 69
# Accessors
# sub cpan_userid { shift->{RO}{CPAN_USERID} }
sub userid {
    my $self = shift;
    return unless exists $self->{RO}; # should never happen
    return $self->{RO}{CPAN_USERID} || $self->{RO}{userid};
}
sub description { shift->{RO}{description} }

sub undelay {
    my $self = shift;
    delete $self->{later};
    if ( my $dist = CPAN::Shell->expand("Distribution", $self->cpan_file) ) {
        $dist->undelay;
    }
}

#-> sub CPAN::Module::color_cmd_tmps ;
sub color_cmd_tmps {
    my($self) = shift;
    my($depth) = shift || 0;
    my($color) = shift || 0;
    # a module needs to recurse to its cpan_file

    return if exists $self->{incommandcolor}
        && $self->{incommandcolor}==$color;
    $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: deep recursion in ".
                                   "color_cmd_tmps depth[%s] self[%s] id[%s]",
                                   $depth,
                                   $self,
                                   $self->id
                                  )) if $depth>=100;
    ##### warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;

    if ( my $dist = CPAN::Shell->expand("Distribution", $self->cpan_file) ) {
        $dist->color_cmd_tmps($depth+1,$color);
    }
    if ($color==0) {
        delete $self->{badtestcnt};
    }
    $self->{incommandcolor} = $color;
}

#-> sub CPAN::Module::as_glimpse ;
sub as_glimpse {
    my($self) = @@_;
    my(@@m);
    my $class = ref($self);
    $class =~ s/^CPAN:://;
    my $color_on = "";
    my $color_off = "";
    if (
        $CPAN::Shell::COLOR_REGISTERED
        &&
        $CPAN::META->has_inst("Term::ANSIColor")
        &&
        $self->{RO}{description}
       ) {
        $color_on = Term::ANSIColor::color("green");
        $color_off = Term::ANSIColor::color("reset");
    }
    push @@m, sprintf("%-15s %s%-15s%s (%s)\n",
                     $class,
                     $color_on,
                     $self->id,
                     $color_off,
		     $self->cpan_file);
    join "", @@m;
}
d4059 2
a4060 2
    push @@m, sprintf($sprintf, 'DESCRIPTION', $self->description)
	if $self->description;
d4063 1
a4063 1
    if ($userid = $self->cpan_userid || $self->userid){
d4079 4
a4082 4
    push @@m, sprintf($sprintf, 'CPAN_VERSION', $self->cpan_version)
	if $self->cpan_version;
    push @@m, sprintf($sprintf, 'CPAN_FILE', $self->cpan_file)
	if $self->cpan_file;
d4099 9
a4107 9
		     $self->{RO}{statd},
		     $self->{RO}{stats},
		     $self->{RO}{statl},
		     $self->{RO}{stati},
		     $statd{$self->{RO}{statd}},
		     $stats{$self->{RO}{stats}},
		     $statl{$self->{RO}{statl}},
		     $stati{$self->{RO}{stati}}
		    ) if $self->{RO}{statd};
d4109 2
a4110 42
    unless ($self->{MANPAGE}) {
        if ($local_file) {
            $self->{MANPAGE} = $self->manpage_headline($local_file);
        } else {
            # If we have already untarred it, we should look there
            my $dist = $CPAN::META->instance('CPAN::Distribution',
                                             $self->cpan_file);
            # warn "dist[$dist]";
            # mff=manifest file; mfh=manifest handle
            my($mff,$mfh);
            if (
                $dist->{build_dir}
                and
                (-f  ($mff = MM->catfile($dist->{build_dir}, "MANIFEST")))
                and
                $mfh = FileHandle->new($mff)
               ) {
                CPAN->debug("mff[$mff]") if $CPAN::DEBUG;
                my $lfre = $self->id; # local file RE
                $lfre =~ s/::/./g;
                $lfre .= "\\.pm\$";
                my($lfl); # local file file
                local $/ = "\n";
                my(@@mflines) = <$mfh>;
                for (@@mflines) {
                    s/^\s+//;
                    s/\s.*//s;
                }
                while (length($lfre)>5 and !$lfl) {
                    ($lfl) = grep /$lfre/, @@mflines;
                    CPAN->debug("lfl[$lfl]lfre[$lfre]") if $CPAN::DEBUG;
                    $lfre =~ s/.+?\.//;
                }
                $lfl =~ s/\s.*//; # remove comments
                $lfl =~ s/\s+//g; # chomp would maybe be too system-specific
                my $lfl_abs = MM->catfile($dist->{build_dir},$lfl);
                # warn "lfl_abs[$lfl_abs]";
                if (-f $lfl_abs) {
                    $self->{MANPAGE} = $self->manpage_headline($lfl_abs);
                }
            }
        }
d4113 1
a4113 1
    for $item (qw/MANPAGE/) {
a4116 4
    for $item (qw/CONTAINS/) {
	push @@m, sprintf($sprintf, $item, join(" ",@@{$self->{$item}}))
	    if exists $self->{$item} && @@{$self->{$item}};
    }
d4127 1
a4127 1
  $local_file =~ s/\.pm(?!\n)\Z/.pod/;
d4152 1
a4152 2
# Note: also inherited by CPAN::Bundle
sub cpan_file {
d4154 2
a4155 2
    CPAN->debug(sprintf "id[%s]", $self->id) if $CPAN::DEBUG;
    unless (defined $self->{RO}{CPAN_FILE}) {
d4158 11
a4168 2
    if (exists $self->{RO}{CPAN_FILE} && defined $self->{RO}{CPAN_FILE}){
	return $self->{RO}{CPAN_FILE};
d4170 1
a4170 19
        my $userid = $self->userid;
        if ( $userid ) {
            if ($CPAN::META->exists("CPAN::Author",$userid)) {
                my $author = $CPAN::META->instance("CPAN::Author",
                                                   $userid);
                my $fullname = $author->fullname;
                my $email = $author->email;
                unless (defined $fullname && defined $email) {
                    return sprintf("Contact Author %s",
                                   $userid,
                                  );
                }
                return "Contact Author $fullname <$email>";
            } else {
                return "UserID $userid";
            }
        } else {
            return "N/A";
        }
d4174 2
d4179 11
a4189 8

    $self->{RO}{CPAN_VERSION} = 'undef'
	unless defined $self->{RO}{CPAN_VERSION};
    # I believe this is always a bug in the index and should be reported
    # as such, but usually I find out such an error and do not want to
    # provoke too many bugreports

    $self->{RO}{CPAN_VERSION};
d4201 1
a4201 3
    $CPAN::Frontend->myprint(sprintf("Running %s for module %s\n",
                                     $meth,
                                     $self->id));
d4209 1
a4209 1
  more about the status. Try 'i %s'.
d4218 1
a4218 1
    $pack->force($meth) if exists $self->{'force_update'};
a4219 1
    $pack->unforce if $pack->can("unforce") && exists $self->{'force_update'};
d4232 1
a4232 4
sub make   {
    my $self = shift;
    $self->rematein('make');
}
d4234 1
a4234 5
sub test   {
    my $self = shift;
    $self->{badtestcnt} ||= 0;
    $self->rematein('test',@@_);
}
d4248 1
a4248 1
	! CPAN::Version->vgt($latest, $have)
d4250 1
a4250 3
        CPAN->debug("returning uptodate. inst_file[$inst_file] ".
                    "latest[$latest] have[$have]") if $CPAN::DEBUG;
        return 1;
d4307 2
a4308 36
    my $have;

    # there was a bug in 5.6.0 that let lots of unini warnings out of
    # parse_version. Fixed shortly after 5.6.0 by PMQS. We can remove
    # the following workaround after 5.6.1 is out.
    local($SIG{__WARN__}) =  sub { my $w = shift;
                                   return if $w =~ /uninitialized/i;
                                   warn $w;
                                 };

    $have = MM->parse_version($parsefile) || "undef";
    $have =~ s/^ //; # since the %vd hack these two lines here are needed
    $have =~ s/ $//; # trailing whitespace happens all the time

    # My thoughts about why %vd processing should happen here

    # Alt1 maintain it as string with leading v:
    # read index files     do nothing
    # compare it           use utility for compare
    # print it             do nothing

    # Alt2 maintain it as what is is
    # read index files     convert
    # compare it           use utility because there's still a ">" vs "gt" issue
    # print it             use CPAN::Version for print

    # Seems cleaner to hold it in memory as a string starting with a "v"

    # If the author of this module made a mistake and wrote a quoted
    # "v1.13" instead of v1.13, we simply leave it at that with the
    # effect that *we* will treat it like a v-tring while the rest of
    # perl won't. Seems sensible when we consider that any action we
    # could take now would just add complexity.

    $have = CPAN::Version->readable($have);

d4310 1
a4310 1
    $have; # no stringify needed, \s* above matches always
a4314 1
# CPAN::Tarzip::gzip
d4329 1
a4329 1
    system("$CPAN::Config->{gzip} -c $read > $write")==0;
a4332 2

# CPAN::Tarzip::gunzip
d4349 1
a4349 1
    system("$CPAN::Config->{gzip} -dc $read > $write")==0;
a4352 2

# CPAN::Tarzip::gtest
d4355 2
a4356 5
  # After I had reread the documentation in zlib.h, I discovered that
  # uncompressed files do not lead to an gzerror (anymore?).
  if ( $CPAN::META->has_inst("Compress::Zlib") ) {
    my($buffer,$len);
    $len = 0;
d4358 6
a4363 16
	or $CPAN::Frontend->mydie(sprintf("Cannot gzopen %s: %s\n",
                                          $read,
                                          $Compress::Zlib::gzerrno));
    while ($gz->gzread($buffer) > 0 ){
        $len += length($buffer);
        $buffer = "";
    }
    my $err = $gz->gzerror;
    my $success = ! $err || $err == Compress::Zlib::Z_STREAM_END();
    if ($len == -s $read){
        $success = 0;
        CPAN->debug("hit an uncompressed file") if $CPAN::DEBUG;
    }
    $gz->gzclose();
    CPAN->debug("err[$err]success[$success]") if $CPAN::DEBUG;
    return $success;
d4365 1
a4365 1
      return system("$CPAN::Config->{gzip} -dt $read")==0;
a4368 2

# CPAN::Tarzip::TIEHANDLE
d4378 2
a4379 2
    my $pipe = "$CPAN::Config->{gzip} --decompress --stdout $file |";
    my $fh = FileHandle->new($pipe) or die "Could not pipe[$pipe]: $!";
a4385 2

# CPAN::Tarzip::READLINE
a4399 2

# CPAN::Tarzip::READ
a4412 2

# CPAN::Tarzip::DESTROY
d4414 9
a4422 10
    my($self) = @@_;
    if (exists $self->{GZ}) {
        my $gz = $self->{GZ};
        $gz->gzclose() if defined $gz; # hard to say if it is allowed
                                       # to be undef ever. AK, 2000-09
    } else {
        my $fh = $self->{FH};
        $fh->close if defined $fh;
    }
    undef $self;
a4424 2

# CPAN::Tarzip::untar
d4427 6
a4432 31
  my($prefer) = 0;

  if (0) { # makes changing order easier
  } elsif ($BUGHUNTING){
      $prefer=2;
  } elsif (MM->maybe_command($CPAN::Config->{gzip})
           &&
           MM->maybe_command($CPAN::Config->{'tar'})) {
      # should be default until Archive::Tar is fixed
      $prefer = 1;
  } elsif (
           $CPAN::META->has_inst("Archive::Tar")
           &&
           $CPAN::META->has_inst("Compress::Zlib") ) {
      $prefer = 2;
  } else {
    $CPAN::Frontend->mydie(qq{
CPAN.pm needs either both external programs tar and gzip installed or
both the modules Archive::Tar and Compress::Zlib. Neither prerequisite
is available. Can\'t continue.
});
  }
  if ($prefer==1) { # 1 => external gzip+tar
    my($system);
    my $is_compressed = $class->gtest($file);
    if ($is_compressed) {
        $system = "$CPAN::Config->{gzip} --decompress --stdout " .
            "< $file | $CPAN::Config->{tar} xvf -";
    } else {
        $system = "$CPAN::Config->{tar} xvf $file";
    }
d4434 19
a4452 19
        # people find the most curious tar binaries that cannot handle
        # pipes
        if ($is_compressed) {
            (my $ungzf = $file) =~ s/\.gz(?!\n)\Z//;
            if (CPAN::Tarzip->gunzip($file, $ungzf)) {
                $CPAN::Frontend->myprint(qq{Uncompressed $file successfully\n});
            } else {
                $CPAN::Frontend->mydie(qq{Couldn\'t uncompress $file\n});
            }
            $file = $ungzf;
        }
        $system = "$CPAN::Config->{tar} xvf $file";
        $CPAN::Frontend->myprint(qq{Using Tar:$system:\n});
        if (system($system)==0) {
            $CPAN::Frontend->myprint(qq{Untarred $file successfully\n});
        } else {
            $CPAN::Frontend->mydie(qq{Couldn\'t untar $file\n});
        }
        return 1;
d4454 1
a4454 1
        return 1;
d4456 3
a4458 1
  } elsif ($prefer==2) { # 2 => modules
d4460 2
a4461 30
    my $af; # archive file
    my @@af;
    if ($BUGHUNTING) {
        # RCS 1.337 had this code, it turned out unacceptable slow but
        # it revealed a bug in Archive::Tar. Code is only here to hunt
        # the bug again. It should never be enabled in published code.
        # GDGraph3d-0.53 was an interesting case according to Larry
        # Virden.
        warn(">>>Bughunting code enabled<<< " x 20);
        for $af ($tar->list_files) {
            if ($af =~ m!^(/|\.\./)!) {
                $CPAN::Frontend->mydie("ALERT: Archive contains ".
                                       "illegal member [$af]");
            }
            $CPAN::Frontend->myprint("$af\n");
            $tar->extract($af); # slow but effective for finding the bug
            return if $CPAN::Signal;
        }
    } else {
        for $af ($tar->list_files) {
            if ($af =~ m!^(/|\.\./)!) {
                $CPAN::Frontend->mydie("ALERT: Archive contains ".
                                       "illegal member [$af]");
            }
            $CPAN::Frontend->myprint("$af\n");
            push @@af, $af;
            return if $CPAN::Signal;
        }
        $tar->extract(@@af);
    }
d4467 6
a4475 112
sub unzip {
    my($class,$file) = @@_;
    if ($CPAN::META->has_inst("Archive::Zip")) {
        # blueprint of the code from Archive::Zip::Tree::extractTree();
        my $zip = Archive::Zip->new();
        my $status;
        $status = $zip->read($file);
        die "Read of file[$file] failed\n" if $status != Archive::Zip::AZ_OK();
        $CPAN::META->debug("Successfully read file[$file]") if $CPAN::DEBUG;
        my @@members = $zip->members();
        for my $member ( @@members ) {
            my $af = $member->fileName();
            if ($af =~ m!^(/|\.\./)!) {
                $CPAN::Frontend->mydie("ALERT: Archive contains ".
                                       "illegal member [$af]");
            }
            my $status = $member->extractToFileNamed( $af );
            $CPAN::META->debug("af[$af]status[$status]") if $CPAN::DEBUG;
            die "Extracting of file[$af] from zipfile[$file] failed\n" if
                $status != Archive::Zip::AZ_OK();
            return if $CPAN::Signal;
        }
        return 1;
    } else {
        my $unzip = $CPAN::Config->{unzip} or
            $CPAN::Frontend->mydie("Cannot unzip, no unzip program available");
        my @@system = ($unzip, $file);
        return system(@@system) == 0;
    }
}


package CPAN::Version;
# CPAN::Version::vcmp courtesy Jost Krieger
sub vcmp {
  my($self,$l,$r) = @@_;
  local($^W) = 0;
  CPAN->debug("l[$l] r[$r]") if $CPAN::DEBUG;

  return 0 if $l eq $r; # short circuit for quicker success

  if ($l=~/^v/ <=> $r=~/^v/) {
      for ($l,$r) {
          next if /^v/;
          $_ = $self->float2vv($_);
      }
  }

  return
      ($l ne "undef") <=> ($r ne "undef") ||
          ($] >= 5.006 &&
           $l =~ /^v/ &&
           $r =~ /^v/ &&
           $self->vstring($l) cmp $self->vstring($r)) ||
               $l <=> $r ||
                   $l cmp $r;
}

sub vgt {
  my($self,$l,$r) = @@_;
  $self->vcmp($l,$r) > 0;
}

sub vstring {
  my($self,$n) = @@_;
  $n =~ s/^v// or die "CPAN::Version::vstring() called with invalid arg [$n]";
  pack "U*", split /\./, $n;
}

# vv => visible vstring
sub float2vv {
    my($self,$n) = @@_;
    my($rev) = int($n);
    $rev ||= 0;
    my($mantissa) = $n =~ /\.(\d{1,12})/; # limit to 12 digits to limit
                                          # architecture influence
    $mantissa ||= 0;
    $mantissa .= "0" while length($mantissa)%3;
    my $ret = "v" . $rev;
    while ($mantissa) {
        $mantissa =~ s/(\d{1,3})// or
            die "Panic: length>0 but not a digit? mantissa[$mantissa]";
        $ret .= ".".int($1);
    }
    # warn "n[$n]ret[$ret]";
    $ret;
}

sub readable {
  my($self,$n) = @@_;
  $n =~ /^([\w\-\+\.]+)/;

  return $1 if defined $1 && length($1)>0;
  # if the first user reaches version v43, he will be treated as "+".
  # We'll have to decide about a new rule here then, depending on what
  # will be the prevailing versioning behavior then.

  if ($] < 5.006) { # or whenever v-strings were introduced
    # we get them wrong anyway, whatever we do, because 5.005 will
    # have already interpreted 0.2.4 to be "0.24". So even if he
    # indexer sends us something like "v0.2.4" we compare wrongly.

    # And if they say v1.2, then the old perl takes it as "v12"

    $CPAN::Frontend->mywarn("Suspicious version string seen [$n]");
    return $n;
  }
  my $better = sprintf "v%vd", $n;
  CPAN->debug("n[$n] better[$better]") if $CPAN::DEBUG;
  return $better;
}

d4521 5
a4525 5
L<C<CPAN::WAIT>|CPAN::WAIT>. C<CPAN::WAIT> is a full-text search engine
that indexes all documents available in CPAN authors directories. If
C<CPAN::WAIT> is installed on your system, the interactive shell of
CPAN.pm will enable the C<wq>, C<wr>, C<wd>, C<wl>, and C<wh> commands
which send queries to the WAIT server that has been configured for your
a4543 4
The function call C<shell> takes two optional arguments, one is the
prompt, the second is the default initial command line (the latter
only works if a real ReadLine interface module is installed).

d4587 1
a4587 1
the module doesn't need to be updated.
d4590 1
a4590 1
and doesn't try to build a package a second time regardless if it
a4617 7
=item ls author

C<ls> lists all distribution files in and below an author's CPAN
directory. Only those files that contain modules are listed and if
there is more than one for any given module, only the most recent one
is listed.

d4662 1
a4662 1
invoke CPAN's recompile on the second architecture and you're done.
d4707 1
a4707 1
=head2 Programmer's interface
a4729 6
=item expandany(@@things)

Like expand, but returns objects of the appropriate type, i.e.
CPAN::Bundle objects for bundles, CPAN::Module objects for modules and
CPAN::Distribution objects fro distributions.

a4751 3
    # find out which distribution on CPAN contains a module:
    print CPAN::Shell->expand("Module","Apache::Constants")->cpan_file

d4753 1
a4753 1
all modules that need updating. First a quick and dirty way:
d4757 4
a4760 4
If you don't want to get any output in the case that all modules are
up to date, you can parse the output of above command for the regular
expression //modules are up to date// and decide to mail the output
only if it doesn't match. Ick?
d4763 1
a4763 1
process, maybe something like this suits you better:
d4789 1
a4789 293
=head2 Methods in the other Classes

The programming interface for the classes CPAN::Module,
CPAN::Distribution, CPAN::Bundle, and CPAN::Author is still considered
beta and partially even alpha. In the following paragraphs only those
methods are documented that have proven useful over a longer time and
thus are unlikely to change.

=over

=item CPAN::Author::as_glimpse()

Returns a one-line description of the author

=item CPAN::Author::as_string()

Returns a multi-line description of the author

=item CPAN::Author::email()

Returns the author's email address

=item CPAN::Author::fullname()

Returns the author's name

=item CPAN::Author::name()

An alias for fullname

=item CPAN::Bundle::as_glimpse()

Returns a one-line description of the bundle

=item CPAN::Bundle::as_string()

Returns a multi-line description of the bundle

=item CPAN::Bundle::clean()

Recursively runs the C<clean> method on all items contained in the bundle.

=item CPAN::Bundle::contains()

Returns a list of objects' IDs contained in a bundle. The associated
objects may be bundles, modules or distributions.

=item CPAN::Bundle::force($method,@@args)

Forces CPAN to perform a task that normally would have failed. Force
takes as arguments a method name to be called and any number of
additional arguments that should be passed to the called method. The
internals of the object get the needed changes so that CPAN.pm does
not refuse to take the action. The C<force> is passed recursively to
all contained objects.

=item CPAN::Bundle::get()

Recursively runs the C<get> method on all items contained in the bundle

=item CPAN::Bundle::inst_file()

Returns the highest installed version of the bundle in either @@INC or
C<$CPAN::Config->{cpan_home}>. Note that this is different from
CPAN::Module::inst_file.

=item CPAN::Bundle::inst_version()

Like CPAN::Bundle::inst_file, but returns the $VERSION

=item CPAN::Bundle::uptodate()

Returns 1 if the bundle itself and all its members are uptodate.

=item CPAN::Bundle::install()

Recursively runs the C<install> method on all items contained in the bundle

=item CPAN::Bundle::make()

Recursively runs the C<make> method on all items contained in the bundle

=item CPAN::Bundle::readme()

Recursively runs the C<readme> method on all items contained in the bundle

=item CPAN::Bundle::test()

Recursively runs the C<test> method on all items contained in the bundle

=item CPAN::Distribution::as_glimpse()

Returns a one-line description of the distribution

=item CPAN::Distribution::as_string()

Returns a multi-line description of the distribution

=item CPAN::Distribution::clean()

Changes to the directory where the distribution has been unpacked and
runs C<make clean> there.

=item CPAN::Distribution::containsmods()

Returns a list of IDs of modules contained in a distribution file.
Only works for distributions listed in the 02packages.details.txt.gz
file. This typically means that only the most recent version of a
distribution is covered.

=item CPAN::Distribution::cvs_import()

Changes to the directory where the distribution has been unpacked and
runs something like

    cvs -d $cvs_root import -m $cvs_log $cvs_dir $userid v$version

there.

=item CPAN::Distribution::dir()

Returns the directory into which this distribution has been unpacked.

=item CPAN::Distribution::force($method,@@args)

Forces CPAN to perform a task that normally would have failed. Force
takes as arguments a method name to be called and any number of
additional arguments that should be passed to the called method. The
internals of the object get the needed changes so that CPAN.pm does
not refuse to take the action.

=item CPAN::Distribution::get()

Downloads the distribution from CPAN and unpacks it. Does nothing if
the distribution has already been downloaded and unpacked within the
current session.

=item CPAN::Distribution::install()

Changes to the directory where the distribution has been unpacked and
runs the external command C<make install> there. If C<make> has not
yet been run, it will be run first. A C<make test> will be issued in
any case and if this fails, the install will be cancelled. The
cancellation can be avoided by letting C<force> run the C<install> for
you.

=item CPAN::Distribution::isa_perl()

Returns 1 if this distribution file seems to be a perl distribution.
Normally this is derived from the file name only, but the index from
CPAN can contain a hint to achieve a return value of true for other
filenames too.

=item CPAN::Distribution::look()

Changes to the directory where the distribution has been unpacked and
opens a subshell there. Exiting the subshell returns.

=item CPAN::Distribution::make()

First runs the C<get> method to make sure the distribution is
downloaded and unpacked. Changes to the directory where the
distribution has been unpacked and runs the external commands C<perl
Makefile.PL> and C<make> there.

=item CPAN::Distribution::prereq_pm()

Returns the hash reference that has been announced by a distribution
as the PREREQ_PM hash in the Makefile.PL. Note: works only after an
attempt has been made to C<make> the distribution. Returns undef
otherwise.

=item CPAN::Distribution::readme()

Downloads the README file associated with a distribution and runs it
through the pager specified in C<$CPAN::Config->{pager}>.

=item CPAN::Distribution::test()

Changes to the directory where the distribution has been unpacked and
runs C<make test> there.

=item CPAN::Distribution::uptodate()

Returns 1 if all the modules contained in the distribution are
uptodate. Relies on containsmods.

=item CPAN::Index::force_reload()

Forces a reload of all indices.

=item CPAN::Index::reload()

Reloads all indices if they have been read more than
C<$CPAN::Config->{index_expire}> days.

=item CPAN::InfoObj::dump()

CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution
inherit this method. It prints the data structure associated with an
object. Useful for debugging. Note: the data structure is considered
internal and thus subject to change without notice.

=item CPAN::Module::as_glimpse()

Returns a one-line description of the module

=item CPAN::Module::as_string()

Returns a multi-line description of the module

=item CPAN::Module::clean()

Runs a clean on the distribution associated with this module.

=item CPAN::Module::cpan_file()

Returns the filename on CPAN that is associated with the module.

=item CPAN::Module::cpan_version()

Returns the latest version of this module available on CPAN.

=item CPAN::Module::cvs_import()

Runs a cvs_import on the distribution associated with this module.

=item CPAN::Module::description()

Returns a 44 chracter description of this module. Only available for
modules listed in The Module List (CPAN/modules/00modlist.long.html
or 00modlist.long.txt.gz)

=item CPAN::Module::force($method,@@args)

Forces CPAN to perform a task that normally would have failed. Force
takes as arguments a method name to be called and any number of
additional arguments that should be passed to the called method. The
internals of the object get the needed changes so that CPAN.pm does
not refuse to take the action.

=item CPAN::Module::get()

Runs a get on the distribution associated with this module.

=item CPAN::Module::inst_file()

Returns the filename of the module found in @@INC. The first file found
is reported just like perl itself stops searching @@INC when it finds a
module.

=item CPAN::Module::inst_version()

Returns the version number of the module in readable format.

=item CPAN::Module::install()

Runs an C<install> on the distribution associated with this module.

=item CPAN::Module::look()

Changes to the directory where the distribution assoicated with this
module has been unpacked and opens a subshell there. Exiting the
subshell returns.

=item CPAN::Module::make()

Runs a C<make> on the distribution associated with this module.

=item CPAN::Module::manpage_headline()

If module is installed, peeks into the module's manpage, reads the
headline and returns it. Moreover, if the module has been downloaded
within this session, does the equivalent on the downloaded module even
if it is not installed.

=item CPAN::Module::readme()

Runs a C<readme> on the distribution associated with this module.

=item CPAN::Module::test()

Runs a C<test> on the distribution associated with this module.

=item CPAN::Module::uptodate()

Returns 1 if the module is installed and up-to-date.

=item CPAN::Module::userid()

Returns the author's ID of the module.

=back
d4883 1
a4883 1
The debugging of this module is a bit complex, because we have
d4888 6
a4893 7
For code debugging in interactive mode you can try "o debug" which
will list options for debugging the various parts of the code. You
should know that "o debug" has built-in completion support.

For data debugging there is the C<dump> command which takes the same
arguments as make/test/install and outputs the object's Data::Dumper
dump.
a4920 1
  cache_metadata     use serializer to cache metadata
a4921 2
  dontload_hash      anonymous hash: modules in the keys will not be
                     loaded by the CPAN::has_inst() routine
a4935 2
  proxy_user         username for accessing an authenticating proxy
  proxy_pass         password for accessing an authenticating proxy
a4937 2
  term_is_latin      if true internal UTF-8 is translated to ISO-8859-1
                     (and nonsense for characters outside latin range)
d4976 1
a4976 2
guessing if your URL is not compliant, but if you have problems with
file URLs, please try the correct format. Either:
d5024 2
a5025 2
Populating a freshly installed perl with my favorite modules is pretty
easy if you maintain a private bundle definition file. To get a useful
d5037 1
a5037 1
Maintaining a bundle definition file means keeping track of two
d5046 1
a5046 1
untended.
d5051 1
a5051 7
the interaction between perl, and various firewall configurations. For
further informations on firewalls, it is recommended to consult the
documentation that comes with the ncftp program. If you are unable to
go through the firewall with a simple Perl setup, it is very likely
that you can configure ncftp so that it works for your firewall.

=head2 Three basic types of firewalls
d5094 1
a5094 1
it with the SOCKS library, this is what is normally called a 'socksified'
d5102 1
a5102 3
special compiling is needed as you can access hosts directly.

=back
a5105 159
=head2 Configuring lynx or ncftp for going through a firewall

If you can go through your firewall with e.g. lynx, presumably with a
command such as

    /usr/local/bin/lynx -pscott:tiger

then you would configure CPAN.pm with the command

    o conf lynx "/usr/local/bin/lynx -pscott:tiger"

That's all. Similarly for ncftp or ftp, you would configure something
like

    o conf ncftp "/usr/bin/ncftp -f /home/scott/ncftplogin.cfg"

Your milage may vary...

=head1 FAQ

=over

=item 1)

I installed a new version of module X but CPAN keeps saying,
I have the old version installed

Most probably you B<do> have the old version installed. This can
happen if a module installs itself into a different directory in the
@@INC path than it was previously installed. This is not really a
CPAN.pm problem, you would have the same problem when installing the
module manually. The easiest way to prevent this behaviour is to add
the argument C<UNINST=1> to the C<make install> call, and that is why
many people add this argument permanently by configuring

  o conf make_install_arg UNINST=1

=item 2)

So why is UNINST=1 not the default?

Because there are people who have their precise expectations about who
may install where in the @@INC path and who uses which @@INC array. In
fine tuned environments C<UNINST=1> can cause damage.

=item 3)

I want to clean up my mess, and install a new perl along with
all modules I have. How do I go about it?

Run the autobundle command for your old perl and optionally rename the
resulting bundle file (e.g. Bundle/mybundle.pm), install the new perl
with the Configure option prefix, e.g.

    ./Configure -Dprefix=/usr/local/perl-5.6.78.9

Install the bundle file you produced in the first step with something like

    cpan> install Bundle::mybundle

and you're done.

=item 4)

When I install bundles or multiple modules with one command
there is too much output to keep track of.

You may want to configure something like

  o conf make_arg "| tee -ai /root/.cpan/logs/make.out"
  o conf make_install_arg "| tee -ai /root/.cpan/logs/make_install.out"

so that STDOUT is captured in a file for later inspection.


=item 5)

I am not root, how can I install a module in a personal directory?

You will most probably like something like this:

  o conf makepl_arg "LIB=~/myperl/lib \
                    INSTALLMAN1DIR=~/myperl/man/man1 \
                    INSTALLMAN3DIR=~/myperl/man/man3"
  install Sybase::Sybperl

You can make this setting permanent like all C<o conf> settings with
C<o conf commit>.

You will have to add ~/myperl/man to the MANPATH environment variable
and also tell your perl programs to look into ~/myperl/lib, e.g. by
including

  use lib "$ENV{HOME}/myperl/lib";

or setting the PERL5LIB environment variable.

Another thing you should bear in mind is that the UNINST parameter
should never be set if you are not root.

=item 6)

How to get a package, unwrap it, and make a change before building it?

  look Sybase::Sybperl

=item 7)

I installed a Bundle and had a couple of fails. When I
retried, everything resolved nicely. Can this be fixed to work
on first try?

The reason for this is that CPAN does not know the dependencies of all
modules when it starts out. To decide about the additional items to
install, it just uses data found in the generated Makefile. An
undetected missing piece breaks the process. But it may well be that
your Bundle installs some prerequisite later than some depending item
and thus your second try is able to resolve everything. Please note,
CPAN.pm does not know the dependency tree in advance and cannot sort
the queue of things to install in a topologically correct order. It
resolves perfectly well IFF all modules declare the prerequisites
correctly with the PREREQ_PM attribute to MakeMaker. For bundles which
fail and you need to install often, it is recommended sort the Bundle
definition file manually. It is planned to improve the metadata
situation for dependencies on CPAN in general, but this will still
take some time.

=item 8)

In our intranet we have many modules for internal use. How
can I integrate these modules with CPAN.pm but without uploading
the modules to CPAN?

Have a look at the CPAN::Site module.

=item 9)

When I run CPAN's shell, I get error msg about line 1 to 4,
setting meta input/output via the /etc/inputrc file.

Some versions of readline are picky about capitalization in the
/etc/inputrc file and specifically RedHat 6.2 comes with a
/etc/inputrc that contains the word C<on> in lowercase. Change the
occurrences of C<on> to C<On> and the bug should disappear.

=item 10)

Some authors have strange characters in their names.

Internally CPAN.pm uses the UTF-8 charset. If your terminal is
expecting ISO-8859-1 charset, a converter can be activated by setting
term_is_latin to a true value in your config file. One way of doing so
would be

    cpan> ! $CPAN::Config->{term_is_latin}=1

Extended support for converters will be made available as soon as perl
becomes stable with regard to charset issues.

d5112 2
a5113 2
but they are not. PAUSE is authors/, modules/ and scripts/. CPAN is
PAUSE plus the clpa/, doc/, misc/, ports/, and src/.
a5125 5

=head1 TRANSLATIONS

Kawai,Takanori provides a Japanese translation of this manpage at
http://member.nifty.ne.jp/hippo2000/perltips/CPAN.htm
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 2
a4 2
$VERSION = '1.61';
# $Id: CPAN.pm,v 1.390 2002/05/07 10:04:58 k Exp $
d8 1
a8 1
# $Revision = "[".substr(q$Revision: 1.390 $, 10)."]";
a24 1
use Sys::Hostname;
a27 2
require Mac::BuildTools if $^O eq 'MacOS';

d457 1
a457 1
    my $lockfile = File::Spec->catfile($CPAN::Config->{cpan_home},".lock");
d461 1
a461 2
	my $otherpid  = <$fh>;
	my $otherhost = <$fh>;
d463 3
a465 16
	if (defined $otherpid && $otherpid) {
	    chomp $otherpid;
        }
	if (defined $otherhost && $otherhost) {
	    chomp $otherhost;
	}
	my $thishost  = hostname();
	if (defined $otherhost && defined $thishost &&
	    $otherhost ne '' && $thishost ne '' &&
	    $otherhost ne $thishost) {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile $lockfile\n".
                                           "reports other host $otherhost and other process $otherpid.\n".
                                           "Cannot proceed.\n"));
	}
	elsif (defined $otherpid && $otherpid) {
	    return if $$ == $otherpid; # should never happen
d468 1
a468 1
There seems to be running another CPAN process (pid $otherpid).  Contacting...
d470 1
a470 1
	    if (kill 0, $otherpid) {
d473 1
a473 1
    kill $otherpid
d493 1
a493 1
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile $lockfile\n".
d495 1
a495 1
                                           "$otherpid. Cannot proceed.\n"));
d536 1
a536 1
	    my $myincc = File::Spec->catfile($ENV{HOME},'.cpan','CPAN','MyConfig.pm');
a558 1
    $fh->print(hostname(), "\n");
d715 1
a715 1
    } elsif ($mod eq "Digest::MD5"){
d717 2
a718 2
  CPAN: MD5 security checks disabled because Digest::MD5 not installed.
  Please consider installing the Digest::MD5 module.
a770 23
sub is_tested {
    my($self,$what) = @@_;
    $self->{is_tested}{$what} = 1;
}

sub is_installed {
    my($self,$what) = @@_;
    delete $self->{is_tested}{$what};
}

sub set_perl5lib {
    my($self) = @@_;
    $self->{is_tested} ||= {};
    return unless %{$self->{is_tested}};
    my $env = $ENV{PERL5LIB};
    $env = $ENV{PERLLIB} unless defined $env;
    my @@env;
    push @@env, $env if defined $env and length $env;
    my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} keys %{$self->{is_tested}};
    $CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB.\n");
    $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
}

d824 1
a824 1
	    push @@entries, File::Spec->catfile($dir,$_);
d826 1
a826 1
	    push @@entries, File::Spec->catdir($dir,$_);
a1095 30
# This is a piece of repeated code that is abstracted here for
# maintainability.  RMB
#
sub _configpmtest {
    my($configpmdir, $configpmtest) = @@_; 
    if (-w $configpmtest) {
        return $configpmtest;
    } elsif (-w $configpmdir) {
        #_#_# following code dumped core on me with 5.003_11, a.k.
        my $configpm_bak = "$configpmtest.bak";
        unlink $configpm_bak if -f $configpm_bak;
        if( -f $configpmtest ) {	
            if( rename $configpmtest, $configpm_bak ) {  
                $CPAN::Frontend->mywarn(<<END)
Old configuration file $configpmtest
    moved to $configpm_bak
END
	    }
	}	
	my $fh = FileHandle->new;
	if ($fh->open(">$configpmtest")) {
	    $fh->print("1;\n");
	    return $configpmtest;
	} else {
	    # Should never happen
	    Carp::confess("Cannot open >$configpmtest");
	}
    } else { return } 
}

d1104 1
a1104 1
      unshift @@INC, File::Spec->catdir($ENV{HOME},".cpan");
d1123 2
a1124 2
	my($configpmdir) = File::Spec->catdir($path_to_cpan,"CPAN");
	my($configpmtest) = File::Spec->catfile($configpmdir,"Config.pm");
d1126 15
a1140 1
	    $configpm = _configpmtest($configpmdir,$configpmtest); 
d1143 1
a1143 1
	    $configpmdir = File::Spec->catdir($ENV{HOME},".cpan","CPAN");
d1145 14
a1158 3
	    $configpmtest = File::Spec->catfile($configpmdir,"MyConfig.pm");
	    $configpm = _configpmtest($configpmdir,$configpmtest); 
	    unless ($configpm) {
d1315 1
a1315 1
            $bdir = File::Spec->catdir($incdir,split /::/, $bbase);
d1321 1
a1321 1
                    if (-d File::Spec->catdir($bdir,$entry)){
d1678 1
a1678 1
    my($todir) = File::Spec->catdir($CPAN::Config->{'cpan_home'},"Bundle");
d1689 1
a1689 1
    my($to) = File::Spec->catfile($todir,"$me.pm");
d1692 1
a1692 1
	$to = File::Spec->catfile($todir,"$me.pm");
d2073 1
a2073 1
        $CPAN::Frontend->mywarn("LWP::UserAgent not available\n");
d2230 1
a2230 1
                $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@")
a2265 3
    unless (ref $CPAN::Config->{urllist} eq 'ARRAY') {
        warn "Malformed urllist; ignoring.  Configuration file corrupt?\n";
    }
d2378 1
a2378 1
                  $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@");
d2510 1
a2510 1
	      "$chdir$funkyftp$src_switch \"$url\" $devnull$stdout_redir";
d2543 1
a2543 1
	    my($system) = "$funkyftp$src_switch \"$url.gz\" $devnull > $asl_gz";
d2761 1
a2761 1
    my $file = File::Spec->catfile($ENV{HOME},".netrc");
d3026 2
a3027 2
    my $abs_wanted = File::Spec->catfile($CPAN::Config->{'keep_source_where'},
					 $localname);
d3299 1
a3299 1
    my $metadata_file = File::Spec->catfile($CPAN::Config->{cpan_home},"Metadata");
d3313 1
a3313 1
    my $metadata_file = File::Spec->catfile($CPAN::Config->{cpan_home},"Metadata");
d3363 1
a3363 2
    $CPAN::Frontend->myprint("  Database was generated on $DATE_OF_02\n")
	if defined $DATE_OF_02; # An old cache may not contain DATE_OF_02
d3544 2
a3545 2
	File::Spec->catfile($CPAN::Config->{keep_source_where},
			    "authors", "id", @@$chksumfile);
d3738 6
a3743 6
        File::Spec->catfile(
			    $CPAN::Config->{keep_source_where},
			    "authors",
			    "id",
			    split("/",$self->id)
			   );
d3763 2
a3764 2
    if ($CPAN::META->has_inst("Digest::MD5")) {
	$self->debug("Digest::MD5 is installed, verifying");
d3767 1
a3767 1
	$self->debug("Digest::MD5 is NOT installed");
d3812 1
a3812 1
        $packagedir = File::Spec->catdir($builddir,$distdir);
d3835 1
a3835 1
        $packagedir = File::Spec->catdir($builddir,$pragmatic_dir);
d3840 1
a3840 1
            my $to = File::Spec->catdir($packagedir,$f);
d3853 1
a3853 1
    my($mpl) = File::Spec->catfile($packagedir,"Makefile.PL");
d3870 1
a3870 1
        my($configure) = File::Spec->catfile($packagedir,"Configure");
d3874 1
a3874 1
        } elsif (-f File::Spec->catfile($packagedir,"Makefile")) {
d3966 1
a3966 1
      $self->Mac::BuildTools::look;
d4045 6
a4050 6
	 File::Spec->catfile(
			     $CPAN::Config->{keep_source_where},
			     "authors",
			     "id",
			     split("/","$sans.readme"),
			    );
d4057 1
a4057 1
        Mac::BuildTools::launch_file($local_file);
d4091 2
a4092 2
	File::Spec->catfile($CPAN::Config->{keep_source_where},
			    "authors", "id", @@local);
d4153 1
a4153 1
	  my $md5 = Digest::MD5->new;
d4212 1
a4212 1
    my $md5 = Digest::MD5->new;
d4281 1
a4281 1
    my($perl) = File::Spec->file_name_is_absolute($^X) ? $^X : "";
d4283 1
a4283 1
    my $candidate = File::Spec->catfile($pwd,$^X);
d4288 1
a4288 1
	    PATH_COMPONENT: foreach $component (File::Spec->path(),
d4291 1
a4291 1
		  my($abs) = File::Spec->catfile($component,$perl_name);
d4359 1
a4359 1
        Mac::BuildTools::make($self);
d4420 1
a4420 1
	  # It's probably worth it to record the reason, so let's retry
d4605 1
a4605 1
        Mac::BuildTools::make_test($self);
a4608 2
    local $ENV{PERL5LIB} = $ENV{PERL5LIB} || "";
    $CPAN::META->set_perl5lib;
a4611 1
	 $CPAN::META->is_tested($self->{'build_dir'});
d4636 1
a4636 1
        Mac::BuildTools::make_clean($self);
d4711 1
a4711 1
        Mac::BuildTools::make_install($self);
a4726 1
	 $CPAN::META->is_installed($self->{'build_dir'});
a4745 8
sub look {
    my $self = shift;
    $CPAN::Frontend->myprint(
                             qq{ look() commmand on bundles not}.
                             qq{ implemented (What should it do?)}
                            );
}

d4817 1
a4817 1
        $me = File::Spec->catfile(@@me);
d4819 1
a4819 1
        $to = File::Spec->catfile($todir,$me);
d4861 1
a4861 1
###    my $bu = File::Spec->catfile($where,$what);
d4863 1
a4863 1
    my $manifest = File::Spec->catfile($where,"MANIFEST");
d4877 1
a4877 1
      $what =~ tr|:|/|;
d4889 1
a4889 1
	    # return File::Spec->catfile($where,$bu); # bad
d4897 1
a4897 1
    return File::Spec->catfile($where, $bu) if $bu;
d4915 1
a4915 1
        my $bfile = File::Spec->catfile($incdir, @@me);
d5208 1
a5208 1
                (-f  ($mff = File::Spec->catfile($dist->{build_dir}, "MANIFEST")))
d5230 1
a5230 1
                my $lfl_abs = File::Spec->catfile($dist->{build_dir},$lfl);
d5267 2
a5268 2
      $inpod = m/^=(?!head1\s+NAME\s*$)/ ? 0 :
	  m/^=head1\s+NAME\s*$/ ? 1 : $inpod;
d5425 1
a5425 1
	my $pmfile = File::Spec->catfile($dir,@@packpath);
d5441 1
a5441 1
	my $xsfile = File::Spec->catfile($dir,'auto',@@packpath);
d5475 1
a5475 1
    # Alt2 maintain it as what it is
d5724 1
a5724 1
    Mac::BuildTools::convert_files([$tar->list_files], 1)
d6066 4
a6069 5
module version number which will also be reflected in the distribution
name when you run 'make dist'), so the really hottest and newest 
distribution is not always the default.  If a module Foo circulates 
on CPAN in both version 1.23 and 1.23_90, CPAN.pm offers a convenient 
way to install version 1.23 by saying
d6123 1
a6123 1
    for $mod (qw(Net::FTP Digest::MD5 Data::Dumper)){
d6184 1
a6184 1
=over 4
d6318 1
a6318 1
any case and if this fails, the install will be canceled. The
d6405 1
a6405 1
Returns a 44 character description of this module. Only available for
d6437 1
a6437 1
Changes to the directory where the distribution associated with this
d6526 1
a6526 1
associated with a URL that is not C<ftp:>.
d6708 1
a6708 1
one-liners.
d6749 1
a6749 1
=over 4
d6757 1
a6757 1
you are running an http firewall.
d6764 1
a6764 1
This where the firewall machine runs an ftp server. This kind of
d6774 1
a6774 1
I say one way visibility as these firewalls try to make themselves look
d6783 1
a6783 1
=over 4
d6818 1
a6818 1
Your mileage may vary...
d6822 1
a6822 1
=over 4
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 2
a4 3
$VERSION = '1.76_01';
$VERSION = eval $VERSION;
# $Id: CPAN.pm,v 1.412 2003/07/31 14:53:04 k Exp $
d8 1
a8 1
# $Revision = "[".substr(q$Revision: 1.412 $, 10)."]";
a114 14
        if (my $histfile = $CPAN::Config->{'histfile'}) {{
            unless ($term->can("AddHistory")) {
                $CPAN::Frontend->mywarn("Terminal does not support AddHistory.\n");
                last;
            }
            my($fh) = FileHandle->new;
            open $fh, "<$histfile" or last;
            local $/ = "\n";
            while (<$fh>) {
                chomp;
                $term->AddHistory($_);
            }
            close $fh;
        }}
a269 22
package CPAN::Exception::RecursiveDependency;
use overload '""' => "as_string";

sub new {
    my($class) = shift;
    my($deps) = shift;
    my @@deps;
    my %seen;
    for my $dep (@@$deps) {
        push @@deps, $dep;
        last if $seen{$dep}++;
    }
    bless { deps => \@@deps }, $class;
}

sub as_string {
    my($self) = shift;
    "\nRecursive dependency detected:\n    " .
        join("\n => ", @@{$self->{deps}}) .
            ".\nCannot continue.\n";
}

d768 8
a775 2
  my($subroutine);
  while ((undef,undef,undef,$subroutine) = caller(++$i)) {
d778 1
d781 3
a783 4
  return unless defined $META->{LOCK};
  return unless -f $META->{LOCK};
  $META->savehist;
  unlink $META->{LOCK};
a788 26
#-> sub CPAN::savehist
sub savehist {
    my($self) = @@_;
    my($histfile,$histsize);
    unless ($histfile = $CPAN::Config->{'histfile'}){
        $CPAN::Frontend->mywarn("No history written (no histfile specified).\n");
        return;
    }
    $histsize = $CPAN::Config->{'histsize'} || 100;
    if ($CPAN::term){
        unless ($CPAN::term->can("GetHistory")) {
            $CPAN::Frontend->mywarn("Terminal does not support GetHistory.\n");
            return;
        }
    } else {
        return;
    }
    my @@h = $CPAN::term->GetHistory;
    splice @@h, 0, @@h-$histsize if @@h>$histsize;
    my($fh) = FileHandle->new;
    open $fh, ">$histfile" or $CPAN::Frontend->mydie("Couldn't open >$histfile: $!");
    local $\ = local $, = "\n";
    print $fh @@h;
    close $fh;
}

d1343 1
a1343 1
            $CPAN::Frontend->mywarn("ls command rejects argument $_: not an author\n");
d1392 1
a1392 2
    my $self = shift;
    $CPAN::Frontend->myprint($self->format_result('Module',@@_));
d1513 1
a1513 1
	if ( $_[0] =~ /[Ss]ubroutine ([\w:]+) redefined/ ) {
d1531 8
a1538 11
        for my $f (qw(CPAN.pm CPAN/FirstTime.pm)) {
            next unless $INC{$f};
            CPAN->debug("reloading the whole $f") if $CPAN::DEBUG;
            my $fh = FileHandle->new($INC{$f});
            local($/);
            my $redef = 0;
            local($SIG{__WARN__}) = paintdots_onreload(\$redef);
            eval <$fh>;
            warn $@@ if $@@;
            $CPAN::Frontend->myprint("\n$redef subroutines redefined\n");
        }
a1931 2
        # chomp $what;
        # $what .= "\n"; # newlines unless $PRINT_ORNAMENTING
d2023 2
a2024 2
            if ($meth =~ /^(dump|ls)$/) {
                $obj->$meth();
d2128 1
a2128 1
             defined $CPAN::Config->{proxy_pass}) {
a2152 15
# mirror(): Its purpose is to deal with proxy authentication. When we
# call SUPER::mirror, we relly call the mirror method in
# LWP::UserAgent. LWP::UserAgent will then call
# $self->get_basic_credentials or some equivalent and this will be
# $self->dispatched to our own get_basic_credentials method.

# Our own get_basic_credentials sets $USER and $PASSWD, two globals.

# 407 stands for HTTP_PROXY_AUTHENTICATION_REQUIRED. Which means
# although we have gone through our get_basic_credentials, the proxy
# server refuses to connect. This could be a case where the username or
# password has changed in the meantime, so I'm trying once again without
# $USER and $PASSWD to give the get_basic_credentials routine another
# chance to set $USER and $PASSWD.

d2276 1
a2276 1
                $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@\n")
d2303 4
a2306 3
    for my $prx (qw(ftp_proxy http_proxy no_proxy)) {
        $ENV{$prx} = $CPAN::Config->{$prx} if $CPAN::Config->{$prx};
    }
d2427 1
a2427 1
                  $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@\n");
a2631 1
    my $ftpbin = $CPAN::Config->{ftp};
d2633 1
a2633 1
	unless (length $ftpbin && MM->maybe_command($ftpbin)) {
d2658 1
a2658 1
	     map("cd $_", split /\//, $dir), # RFC 1738
d2678 1
a2678 1
		$self->talk_ftp("$ftpbin$verbose $host",
d2703 1
a2703 1
	$CPAN::Frontend->myprint(qq{Issuing "$ftpbin$verbose -n"\n});
d2709 1
a2709 1
	$self->talk_ftp("$ftpbin$verbose -n", @@dialog);
d3254 1
a3254 1
	    $userid = $id->userid || $self->userid($dist);
d3354 1
a3354 1
    $CPAN::Frontend->mywarn($@@) if $@@; # ?? missing "\n" after $@@ in mywarn ??
d3367 1
a3367 1
    $CPAN::Frontend->mywarn($@@) if $@@; # ?? missing "\n" after $@@ in mywarn ??
d3375 1
a3375 1
                                            "with protocol v%s, requiring v%s\n",
d3383 1
a3383 1
                                "with protocol v1.0\n");
d3420 1
a3420 5
sub cpan_userid {
    my $self = shift;
    $self->{RO}{CPAN_USERID}
}

d3679 1
a3679 1
            $CPAN::Frontend->mywarn("Strange distribution name [$s]\n");
a3689 1
    my($ancestors) = shift || [];
d3694 7
a3700 4
    if ($depth>=100){
        $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
    }
    # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
d3705 1
a3705 1
            $premo->color_cmd_tmps($depth+1,$color,[@@$ancestors, $self->id]);
d3792 1
a3792 1
			    split(/\//,$self->id)
d3900 1
a3900 1
    $self->safe_chdir($builddir);
d4045 2
a4046 4
    unless (system($CPAN::Config->{'shell'}) == 0) {
        my $code = $? >> 8;
        $CPAN::Frontend->mywarn("Subprocess shell exit code $code\n");
    }
d4062 1
a4062 1
    my $cvs_dir = (split /\//, $dir)[-1];
d4099 1
a4099 1
			     split(/\//,"$sans.readme"),
d4137 1
a4137 1
    @@local = split(/\//,$self->id);
a4520 1
            # warn "calling color_cmd_tmps(0,1)";
d4802 4
a4805 1
    $CPAN::Frontend->myprint($self->as_string);
a4821 1
    my($ancestors) = shift || [];
d4827 7
a4833 4
    if ($depth>=100){
        $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
    }
    # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
d4838 1
a4838 1
        $obj->color_cmd_tmps($depth+1,$color,[@@$ancestors, $self->id]);
d5128 1
a5128 1
# sub CPAN::Module::userid
d5132 1
a5132 1
    return $self->{RO}{userid} || $self->{RO}{CPAN_USERID};
a5133 1
# sub CPAN::Module::description
a5148 1
    my($ancestors) = shift || [];
d5153 7
a5159 4
    if ($depth>=100){
        $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
    }
    # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;
d5162 1
a5162 1
        $dist->color_cmd_tmps($depth+1,$color,[@@$ancestors, $self->id]);
d5201 1
a5201 1
    CPAN->debug("$self entering as_string") if $CPAN::DEBUG;
d5211 1
a5211 2
    $userid = $self->userid;
    if ( $userid ){
d5235 2
a5236 2
    @@stats{qw,? m d u n a,}       = qw,unknown mailing-list
	developer comp.lang.perl.* none abandoned,;
d5368 1
a5368 1
                return "Contact Author $userid (Email address not available)";
a5474 7
    if ($self->{RO}{stats} && $self->{RO}{stats} eq "a") {
        $CPAN::Frontend->mywarn(qq{
\n\n\n     ***WARNING***
     The module $self->{ID} has no active maintainer.\n\n\n
});
        sleep 5;
    }
d5897 1
a5897 1
    $CPAN::Frontend->mywarn("Suspicious version string seen [$n]\n");
a5926 10
=head1 STATUS

This module will eventually be replaced by CPANPLUS. CPANPLUS is kind
of a modern rewrite from ground up with greater extensibility and more
features but no full compatibility. If you're new to CPAN.pm, you
probably should investigate if CPANPLUS is the better choice for you.
If you're already used to CPAN.pm you're welcome to continue using it,
if you accept that its development is mostly (though not completely)
stalled.

d5930 1
a5930 1
modules and extensions. It includes some primitive searching capabilities and
d6651 6
a6656 13
When the CPAN module is used for the first time, a configuration
dialog tries to determine a couple of site specific options. The
result of the dialog is stored in a hash reference C< $CPAN::Config >
in a file CPAN/Config.pm.

The default values defined in the CPAN/Config.pm file can be
overridden in a user specific file: CPAN/MyConfig.pm. Such a file is
best placed in $HOME/.cpan/CPAN/MyConfig.pm, because $HOME/.cpan is
added to the search path of the CPAN module before the use() or
require() statements.

The configuration dialog can be started any time later again by
issueing the command C< o conf init > in the CPAN shell.
a6668 2
  histfile           file to maintain history between sessions
  histsize           maximum number of lines to keep in histfile
a6859 10

For accessing ftp servers behind such firewalls you may need to set
the environment variable C<FTP_PASSIVE> to a true value, e.g.

    env FTP_PASSIVE=1 perl -MCPAN -eshell

or

    perl -MCPAN -e '$ENV{FTP_PASSIVE} = 1; shell'

@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 1
# $Id: CPAN.pm,v 1.6 2003/12/03 03:02:35 millert Exp $
d9 1
a9 1
# $Revision = "[".substr(q$Revision: 1.6 $, 10)."]";
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d5 1
a5 1
# $Id: CPAN.pm,v 1.412 2003/07/31 14:53:04 k Exp $
d9 1
a9 1
# $Revision = "[".substr(q$Revision: 1.412 $, 10)."]";
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
$VERSION = '1.76_02';
d742 1
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@a1 1
use strict;
d3 7
a9 2
$CPAN::VERSION = '1.9205';
$CPAN::VERSION = eval $CPAN::VERSION if $CPAN::VERSION =~ /_/;
a10 6
use CPAN::HandleConfig;
use CPAN::Version;
use CPAN::Debug;
use CPAN::Queue;
use CPAN::Tarzip;
use CPAN::DeferedCode;
d14 1
a14 1
use DirHandle ();
d16 1
a16 3
use ExtUtils::MakeMaker qw(prompt); # for some unknown reason,
                                    # 5.005_04 does not work without
                                    # this
a20 1
use File::Spec ();
a21 1
use Fcntl qw(:flock);
a22 1
use Sys::Hostname qw(hostname);
d24 5
a28 1
use Text::Wrap ();
d30 1
a30 12
sub find_perl ();

# we need to run chdir all over and we would get at wrong libraries
# there
BEGIN {
    if (File::Spec->can("rel2abs")) {
        for my $inc (@@INC) {
            $inc = File::Spec->rel2abs($inc) unless ref $inc;
        }
    }
}
no lib ".";
d32 1
a32 3
require Mac::BuildTools if $^O eq 'MacOS';
$ENV{PERL5_CPAN_IS_RUNNING}=$$;
$ENV{PERL5_CPANPLUS_IS_RUNNING}=$$; # https://rt.cpan.org/Ticket/Display.html?id=23735
d34 18
a51 1
END { $CPAN::End++; &cleanup; }
d53 1
d56 4
a59 36
unless (@@CPAN::Defaultsites) {
    @@CPAN::Defaultsites = map {
        CPAN::URL->new(TEXT => $_, FROM => "DEF")
    }
        "http://www.perl.org/CPAN/",
            "ftp://ftp.perl.org/pub/CPAN/";
}
# $CPAN::iCwd (i for initial) is going to be initialized during find_perl
$CPAN::Perl ||= CPAN::find_perl();
$CPAN::Defaultdocs ||= "http://search.cpan.org/perldoc?";
$CPAN::Defaultrecent ||= "http://search.cpan.org/uploads.rdf";
$CPAN::Defaultrecent ||= "http://cpan.uwinnipeg.ca/htdocs/cpan.xml";

# our globals are getting a mess
use vars qw(
            $AUTOLOAD
            $Be_Silent
            $CONFIG_DIRTY
            $Defaultdocs
            $Echo_readline
            $Frontend
            $GOTOSHELL
            $HAS_USABLE
            $Have_warned
            $MAX_RECURSION
            $META
            $RUN_DEGRADED
            $Signal
            $SQLite
            $Suppress_readline
            $VERSION
            $autoload_recursion
            $term
            @@Defaultsites
            @@EXPORT
           );
d61 3
a63 1
$MAX_RECURSION = 32;
a66 2
# note that these functions live in CPAN::Shell and get executed via
# AUTOLOAD when called directly
d68 17
a84 56
             autobundle
             bundle
             clean
             cvs_import
             expand
             force
             fforce
             get
             install
             install_tested
             is_tested
             make
             mkmyconfig
             notest
             perldoc
             readme
             recent
             recompile
             report
             shell
             smoke
             test
             upgrade
            );

sub soft_chdir_with_alternatives ($);

{
    $autoload_recursion ||= 0;

    #-> sub CPAN::AUTOLOAD ;
    sub AUTOLOAD {
        $autoload_recursion++;
        my($l) = $AUTOLOAD;
        $l =~ s/.*:://;
        if ($CPAN::Signal) {
            warn "Refusing to autoload '$l' while signal pending";
            $autoload_recursion--;
            return;
        }
        if ($autoload_recursion > 1) {
            my $fullcommand = join " ", map { "'$_'" } $l, @@_;
            warn "Refusing to autoload $fullcommand in recursion\n";
            $autoload_recursion--;
            return;
        }
        my(%export);
        @@export{@@EXPORT} = '';
        CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
        if (exists $export{$l}) {
            CPAN::Shell->$l(@@_);
        } else {
            die(qq{Unknown CPAN command "$AUTOLOAD". }.
                qq{Type ? for help.\n});
        }
        $autoload_recursion--;
d92 1
a92 1
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
d94 1
a94 1
    my $oprompt = shift || CPAN::Prompt->new;
a96 1
    $CPAN::CurrentCommandId ||= 1;
d100 1
a100 1
        require Term::ReadLine;
d107 9
a115 9
        if ($term->ReadLine eq "Term::ReadLine::Gnu") {
            my $attribs = $term->Attribs;
            $attribs->{attempted_completion_function} = sub {
                &CPAN::Complete::gnu_cpl;
            }
        } else {
            $readline::rl_completion_function =
                $readline::rl_completion_function = 'CPAN::Complete::cpl';
        }
d121 8
a128 1
            $META->readhist($term,$histfile);
d130 6
a135 10
        for ($CPAN::Config->{term_ornaments}) { # alias
            local $Term::ReadLine::termcap_nowarn = 1;
            $term->ornaments($_) if defined;
        }
        # $term->OUT is autoflushed anyway
        my $odef = select STDERR;
        $| = 1;
        select STDOUT;
        $| = 1;
        select $odef;
d138 1
d140 1
a140 4
    my @@cwd = grep { defined $_ and length $_ }
        CPAN::anycwd(),
              File::Spec->can("tmpdir") ? File::Spec->tmpdir() : (),
                    File::Spec->rootdir();
d143 7
a149 7
    unless ($CPAN::Config->{inhibit_startup_message}) {
        my $rl_avail = $Suppress_readline ? "suppressed" :
            ($term->ReadLine ne "Term::ReadLine::Stub") ? "enabled" :
                "available (maybe install Bundle::CPAN or Bundle::CPANxxl?)";
        $CPAN::Frontend->myprint(
                                 sprintf qq{
cpan shell -- CPAN exploration and modules installation (v%s)
d153 5
a157 4
                                 $CPAN::VERSION,
                                 $rl_avail
                                )
    }
a158 1
    my $last_term_ornaments;
d160 6
a165 13
        if ($Suppress_readline) {
            if ($Echo_readline) {
                $|=1;
            }
            print $prompt;
            last SHELLCOMMAND unless defined ($_ = <> );
            if ($Echo_readline) {
                # backdoor: I could not find a way to record sessions
                print $_;
            }
            chomp;
        } else {
            last SHELLCOMMAND unless
d167 41
a207 66
        }
        $_ = "$continuation$_" if $continuation;
        s/^\s+//;
        next SHELLCOMMAND if /^$/;
        s/^\s*\?\s*/help /;
        if (/^(?:q(?:uit)?|bye|exit)$/i) {
            last SHELLCOMMAND;
        } elsif (s/\\$//s) {
            chomp;
            $continuation = $_;
            $prompt = "    > ";
        } elsif (/^\!/) {
            s/^\!//;
            my($eval) = $_;
            package CPAN::Eval;
            use strict;
            use vars qw($import_done);
            CPAN->import(':DEFAULT') unless $import_done++;
            CPAN->debug("eval[$eval]") if $CPAN::DEBUG;
            eval($eval);
            warn $@@ if $@@;
            $continuation = "";
            $prompt = $oprompt;
        } elsif (/./) {
            my(@@line);
            eval { @@line = Text::ParseWords::shellwords($_) };
            warn($@@), next SHELLCOMMAND if $@@;
            warn("Text::Parsewords could not parse the line [$_]"),
                next SHELLCOMMAND unless @@line;
            $CPAN::META->debug("line[".join("|",@@line)."]") if $CPAN::DEBUG;
            my $command = shift @@line;
            eval { CPAN::Shell->$command(@@line) };
            if ($@@) {
                my $err = "$@@";
                if ($err =~ /\S/) {
                    require Carp;
                    require Dumpvalue;
                    my $dv = Dumpvalue->new();
                    Carp::cluck(sprintf "Catching error: %s", $dv->stringify($err));
                }
            }
            if ($command =~ /^(
                             # classic commands
                             make
                             |test
                             |install
                             |clean

                             # pragmas for classic commands
                             |ff?orce
                             |notest

                             # compounds
                             |report
                             |smoke
                             |upgrade
                            )$/x) {
                # only commands that tell us something about failed distros
                CPAN::Shell->failed($CPAN::CurrentCommandId,1);
            }
            soft_chdir_with_alternatives(\@@cwd);
            $CPAN::Frontend->myprint("\n");
            $continuation = "";
            $CPAN::CurrentCommandId++;
            $prompt = $oprompt;
        }
d209 16
a224 45
        $commandline = ""; # I do want to be able to pass a default to
                           # shell, but on the second command I see no
                           # use in that
        $Signal=0;
        CPAN::Queue->nullify_queue;
        if ($try_detect_readline) {
            if ($CPAN::META->has_inst("Term::ReadLine::Gnu")
                ||
                $CPAN::META->has_inst("Term::ReadLine::Perl")
            ) {
                delete $INC{"Term/ReadLine.pm"};
                my $redef = 0;
                local($SIG{__WARN__}) = CPAN::Shell::paintdots_onreload(\$redef);
                require Term::ReadLine;
                $CPAN::Frontend->myprint("\n$redef subroutines in ".
                                         "Term::ReadLine redefined\n");
                $GOTOSHELL = 1;
            }
        }
        if ($term and $term->can("ornaments")) {
            for ($CPAN::Config->{term_ornaments}) { # alias
                if (defined $_) {
                    if (not defined $last_term_ornaments
                        or $_ != $last_term_ornaments
                    ) {
                        local $Term::ReadLine::termcap_nowarn = 1;
                        $term->ornaments($_);
                        $last_term_ornaments = $_;
                    }
                } else {
                    undef $last_term_ornaments;
                }
            }
        }
        for my $class (qw(Module Distribution)) {
            # again unsafe meta access?
            for my $dm (keys %{$CPAN::META->{readwrite}{"CPAN::$class"}}) {
                next unless $CPAN::META->{readwrite}{"CPAN::$class"}{$dm}{incommandcolor};
                CPAN->debug("BUG: $class '$dm' was in command state, resetting");
                delete $CPAN::META->{readwrite}{"CPAN::$class"}{$dm}{incommandcolor};
            }
        }
        if ($GOTOSHELL) {
            $GOTOSHELL = 0; # not too often
            $META->savehist if $CPAN::term && $CPAN::term->can("GetHistory");
d226 3
a228 164
            goto &shell;
        }
    }
    soft_chdir_with_alternatives(\@@cwd);
}

#-> CPAN::soft_chdir_with_alternatives ;
sub soft_chdir_with_alternatives ($) {
    my($cwd) = @@_;
    unless (@@$cwd) {
        my $root = File::Spec->rootdir();
        $CPAN::Frontend->mywarn(qq{Warning: no good directory to chdir to!
Trying '$root' as temporary haven.
});
        push @@$cwd, $root;
    }
    while () {
        if (chdir $cwd->[0]) {
            return;
        } else {
            if (@@$cwd>1) {
                $CPAN::Frontend->mywarn(qq{Could not chdir to "$cwd->[0]": $!
Trying to chdir to "$cwd->[1]" instead.
});
                shift @@$cwd;
            } else {
                $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd->[0]": $!});
            }
        }
    }
}

sub _flock {
    my($fh,$mode) = @@_;
    if ($Config::Config{d_flock}) {
        return flock $fh, $mode;
    } elsif (!$Have_warned->{"d_flock"}++) {
        $CPAN::Frontend->mywarn("Your OS does not support locking; continuing and ignoring all locking issues\n");
        $CPAN::Frontend->mysleep(5);
        return 1;
    } else {
        return 1;
    }
}

sub _yaml_module () {
    my $yaml_module = $CPAN::Config->{yaml_module} || "YAML";
    if (
        $yaml_module ne "YAML"
        &&
        !$CPAN::META->has_inst($yaml_module)
       ) {
        # $CPAN::Frontend->mywarn("'$yaml_module' not installed, falling back to 'YAML'\n");
        $yaml_module = "YAML";
    }
    if ($yaml_module eq "YAML"
        &&
        $CPAN::META->has_inst($yaml_module)
        &&
        $YAML::VERSION < 0.60
        &&
        !$Have_warned->{"YAML"}++
       ) {
        $CPAN::Frontend->mywarn("Warning: YAML version '$YAML::VERSION' is too low, please upgrade!\n".
                                "I'll continue but problems are *very* likely to happen.\n"
                               );
        $CPAN::Frontend->mysleep(5);
    }
    return $yaml_module;
}

# CPAN::_yaml_loadfile
sub _yaml_loadfile {
    my($self,$local_file) = @@_;
    return +[] unless -s $local_file;
    my $yaml_module = _yaml_module;
    if ($CPAN::META->has_inst($yaml_module)) {
        # temporarly enable yaml code deserialisation
        no strict 'refs';
        # 5.6.2 could not do the local() with the reference
        local $YAML::LoadCode;
        local $YAML::Syck::LoadCode;
        ${ "$yaml_module\::LoadCode" } = $CPAN::Config->{yaml_load_code} || 0;

        my $code;
        if ($code = UNIVERSAL::can($yaml_module, "LoadFile")) {
            my @@yaml;
            eval { @@yaml = $code->($local_file); };
            if ($@@) {
                # this shall not be done by the frontend
                die CPAN::Exception::yaml_process_error->new($yaml_module,$local_file,"parse",$@@);
            }
            return \@@yaml;
        } elsif ($code = UNIVERSAL::can($yaml_module, "Load")) {
            local *FH;
            open FH, $local_file or die "Could not open '$local_file': $!";
            local $/;
            my $ystream = <FH>;
            my @@yaml;
            eval { @@yaml = $code->($ystream); };
            if ($@@) {
                # this shall not be done by the frontend
                die CPAN::Exception::yaml_process_error->new($yaml_module,$local_file,"parse",$@@);
            }
            return \@@yaml;
        }
    } else {
        # this shall not be done by the frontend
        die CPAN::Exception::yaml_not_installed->new($yaml_module, $local_file, "parse");
    }
    return +[];
}

# CPAN::_yaml_dumpfile
sub _yaml_dumpfile {
    my($self,$local_file,@@what) = @@_;
    my $yaml_module = _yaml_module;
    if ($CPAN::META->has_inst($yaml_module)) {
        my $code;
        if (UNIVERSAL::isa($local_file, "FileHandle")) {
            $code = UNIVERSAL::can($yaml_module, "Dump");
            eval { print $local_file $code->(@@what) };
        } elsif ($code = UNIVERSAL::can($yaml_module, "DumpFile")) {
            eval { $code->($local_file,@@what); };
        } elsif ($code = UNIVERSAL::can($yaml_module, "Dump")) {
            local *FH;
            open FH, ">$local_file" or die "Could not open '$local_file': $!";
            print FH $code->(@@what);
        }
        if ($@@) {
            die CPAN::Exception::yaml_process_error->new($yaml_module,$local_file,"dump",$@@);
        }
    } else {
        if (UNIVERSAL::isa($local_file, "FileHandle")) {
            # I think this case does not justify a warning at all
        } else {
            die CPAN::Exception::yaml_not_installed->new($yaml_module, $local_file, "dump");
        }
    }
}

sub _init_sqlite () {
    unless ($CPAN::META->has_inst("CPAN::SQLite")) {
        $CPAN::Frontend->mywarn(qq{CPAN::SQLite not installed, trying to work without\n})
            unless $Have_warned->{"CPAN::SQLite"}++;
        return;
    }
    require CPAN::SQLite::META; # not needed since CVS version of 2006-12-17
    $CPAN::SQLite ||= CPAN::SQLite::META->new($CPAN::META);
}

{
    my $negative_cache = {};
    sub _sqlite_running {
        if ($negative_cache->{time} && time < $negative_cache->{time} + 60) {
            # need to cache the result, otherwise too slow
            return $negative_cache->{fact};
        } else {
            $negative_cache = {}; # reset
        }
        my $ret = $CPAN::Config->{use_sqlite} && ($CPAN::SQLite || _init_sqlite());
        return $ret if $ret; # fast anyway
        $negative_cache->{time} = time;
        return $negative_cache->{fact} = $ret;
d230 1
a233 1
use strict;
d237 9
d247 1
a247 3
use strict;
use Fcntl qw(:flock);
use vars qw($connect_to_internet_ok $Ua $Thesite $ThesiteURL $Themethod);
a250 1
use strict;
d252 1
a252 1
# we delay requiring LWP::UserAgent and setting up inheritance until we need it
a254 1
use strict;
a255 2
# Q: where is the "How do I add a new command" HOWTO?
# A: svn diff -r 1048:1049 where andk added the report command
d257 4
a260 32
                                    ? ! a b d h i m o q r u
                                    autobundle
                                    bye
                                    clean
                                    cvs_import
                                    dump
                                    exit
                                    failed
                                    force
                                    fforce
                                    hosts
                                    install
                                    install_tested
                                    is_tested
                                    look
                                    ls
                                    make
                                    mkmyconfig
                                    notest
                                    perldoc
                                    quit
                                    readme
                                    recent
                                    recompile
                                    reload
                                    report
                                    reports
                                    scripts
                                    smoke
                                    test
                                    upgrade
);
d263 1
a263 2
use strict;
use vars qw($LAST_TIME $DATE_OF_02 $DATE_OF_03 $HAVE_REANIMATED);
a270 1
use strict;
a273 1
use strict;
a276 1
use strict;
a279 1
use strict;
a282 1
use strict;
a285 1
use strict;
a287 4
# a module sees its distribution (no version)
# a distribution sees its prereqs (which are module names) (usually with versions)
# a bundle sees its module names and/or its distributions (no version)

d291 5
a295 49
    my (@@deps,%seen,$loop_starts_with);
  DCHAIN: for my $dep (@@$deps) {
        push @@deps, {name => $dep, display_as => $dep};
        if ($seen{$dep}++) {
            $loop_starts_with = $dep;
            last DCHAIN;
        }
    }
    my $in_loop = 0;
    for my $i (0..$#deps) {
        my $x = $deps[$i]{name};
        $in_loop ||= $x eq $loop_starts_with;
        my $xo = CPAN::Shell->expandany($x) or next;
        if ($xo->isa("CPAN::Module")) {
            my $have = $xo->inst_version || "N/A";
            my($want,$d,$want_type);
            if ($i>0 and $d = $deps[$i-1]{name}) {
                my $do = CPAN::Shell->expandany($d);
                $want = $do->{prereq_pm}{requires}{$x};
                if (defined $want) {
                    $want_type = "requires: ";
                } else {
                    $want = $do->{prereq_pm}{build_requires}{$x};
                    if (defined $want) {
                        $want_type = "build_requires: ";
                    } else {
                        $want_type = "unknown status";
                        $want = "???";
                    }
                }
            } else {
                $want = $xo->cpan_version;
                $want_type = "want: ";
            }
            $deps[$i]{have} = $have;
            $deps[$i]{want_type} = $want_type;
            $deps[$i]{want} = $want;
            $deps[$i]{display_as} = "$x (have: $have; $want_type$want)";
        } elsif ($xo->isa("CPAN::Distribution")) {
            $deps[$i]{display_as} = $xo->pretty_id;
            if ($in_loop) {
                $xo->{make} = CPAN::Distrostatus->new("NO cannot resolve circular dependency");
            } else {
                $xo->{make} = CPAN::Distrostatus->new("NO one dependency ($loop_starts_with) is a circular dependency");
            }
            $xo->store_persistent_state; # otherwise I will not reach
                                         # all involved parties for
                                         # the next session
        }
d302 3
a304 4
    my $ret = "\nRecursive dependency detected:\n    ";
    $ret .= join("\n => ", map {$_->{display_as}} @@{$self->{deps}});
    $ret .= ".\nCannot resolve.\n";
    $ret;
d307 5
a311 3
package CPAN::Exception::yaml_not_installed;
use strict;
use overload '""' => "as_string";
d313 22
a334 3
sub new {
    my($class,$module,$file,$during) = @@_;
    bless { module => $module, file => $file, during => $during }, $class;
d337 51
a387 4
sub as_string {
    my($self) = shift;
    "'$self->{module}' not installed, cannot $self->{during} '$self->{file}'\n";
}
d389 1
a389 3
package CPAN::Exception::yaml_process_error;
use strict;
use overload '""' => "as_string";
d391 1
d393 22
a414 5
    my($class,$module,$file,$during,$error) = @@_;
    bless { module => $module,
            file => $file,
            during => $during,
            error => $error }, $class;
d417 21
a437 14
sub as_string {
    my($self) = shift;
    if ($self->{during}) {
        if ($self->{file}) {
            if ($self->{module}) {
                if ($self->{error}) {
                    return "Alert: While trying to '$self->{during}' YAML file\n".
                        " '$self->{file}'\n".
                            "with '$self->{module}' the following error was encountered:\n".
                                "  $self->{error}\n";
                } else {
                    return "Alert: While trying to '$self->{during}' YAML file\n".
                        " '$self->{file}'\n".
                            "with '$self->{module}' some unknown error was encountered\n";
a438 4
            } else {
                return "Alert: While trying to '$self->{during}' YAML file\n".
                    " '$self->{file}'\n".
                        "some unknown error was encountered\n";
a439 3
        } else {
            return "Alert: While trying to '$self->{during}' some YAML file\n".
                    "some unknown error was encountered\n";
d441 2
a442 2
    } else {
        return "Alert: unknown error encountered\n";
d444 4
d450 7
a456 6
package CPAN::Prompt; use overload '""' => "as_string";
use vars qw($prompt);
$prompt = "cpan> ";
$CPAN::CurrentCommandId ||= 0;
sub new {
    bless {}, shift;
d458 5
a462 10
sub as_string {
    my $word = "cpan";
    unless ($CPAN::META->{LOCK}) {
        $word = "nolock_cpan";
    }
    if ($CPAN::Config->{commandnumber_in_prompt}) {
        sprintf "$word\[%d]> ", $CPAN::CurrentCommandId;
    } else {
        "$word> ";
    }
d465 3
a467 19
package CPAN::URL; use overload '""' => "as_string", fallback => 1;
# accessors: TEXT(the url string), FROM(DEF=>defaultlist,USER=>urllist),
# planned are things like age or quality
sub new {
    my($class,%args) = @@_;
    bless {
           %args
          }, $class;
}
sub as_string {
    my($self) = @@_;
    $self->text;
}
sub text {
    my($self,$set) = @@_;
    if (defined $set) {
        $self->{TEXT} = $set;
    }
    $self->{TEXT};
a469 25
package CPAN::Distrostatus;
use overload '""' => "as_string",
    fallback => 1;
sub new {
    my($class,$arg) = @@_;
    bless {
           TEXT => $arg,
           FAILED => substr($arg,0,2) eq "NO",
           COMMANDID => $CPAN::CurrentCommandId,
           TIME => time,
          }, $class;
}
sub commandid { shift->{COMMANDID} }
sub failed { shift->{FAILED} }
sub text {
    my($self,$set) = @@_;
    if (defined $set) {
        $self->{TEXT} = $set;
    }
    $self->{TEXT};
}
sub as_string {
    my($self) = @@_;
    $self->text;
}
a470 99
package CPAN::Shell;
use strict;
use vars qw(
            $ADVANCED_QUERY
            $AUTOLOAD
            $COLOR_REGISTERED
            $Help
            $autoload_recursion
            $reload
            @@ISA
           );
@@CPAN::Shell::ISA = qw(CPAN::Debug);
$COLOR_REGISTERED ||= 0;
$Help = {
         '?' => \"help",
         '!' => "eval the rest of the line as perl",
         a => "whois author",
         autobundle => "wtite inventory into a bundle file",
         b => "info about bundle",
         bye => \"quit",
         clean => "clean up a distribution's build directory",
         # cvs_import
         d => "info about a distribution",
         # dump
         exit => \"quit",
         failed => "list all failed actions within current session",
         fforce => "redo a command from scratch",
         force => "redo a command",
         h => \"help",
         help => "overview over commands; 'help ...' explains specific commands",
         hosts => "statistics about recently used hosts",
         i => "info about authors/bundles/distributions/modules",
         install => "install a distribution",
         install_tested => "install all distributions tested OK",
         is_tested => "list all distributions tested OK",
         look => "open a subshell in a distribution's directory",
         ls => "list distributions according to a glob",
         m => "info about a module",
         make => "make/build a distribution",
         mkmyconfig => "write current config into a CPAN/MyConfig.pm file",
         notest => "run a (usually install) command but leave out the test phase",
         o => "'o conf ...' for config stuff; 'o debug ...' for debugging",
         perldoc => "try to get a manpage for a module",
         q => \"quit",
         quit => "leave the cpan shell",
         r => "review over upgradeable modules",
         readme => "display the README of a distro woth a pager",
         recent => "show recent uploads to the CPAN",
         # recompile
         reload => "'reload cpan' or 'reload index'",
         report => "test a distribution and send a test report to cpantesters",
         reports => "info about reported tests from cpantesters",
         # scripts
         # smoke
         test => "test a distribution",
         u => "display uninstalled modules",
         upgrade => "combine 'r' command with immediate installation",
        };
{
    $autoload_recursion   ||= 0;

    #-> sub CPAN::Shell::AUTOLOAD ;
    sub AUTOLOAD {
        $autoload_recursion++;
        my($l) = $AUTOLOAD;
        my $class = shift(@@_);
        # warn "autoload[$l] class[$class]";
        $l =~ s/.*:://;
        if ($CPAN::Signal) {
            warn "Refusing to autoload '$l' while signal pending";
            $autoload_recursion--;
            return;
        }
        if ($autoload_recursion > 1) {
            my $fullcommand = join " ", map { "'$_'" } $l, @@_;
            warn "Refusing to autoload $fullcommand in recursion\n";
            $autoload_recursion--;
            return;
        }
        if ($l =~ /^w/) {
            # XXX needs to be reconsidered
            if ($CPAN::META->has_inst('CPAN::WAIT')) {
                CPAN::WAIT->$l(@@_);
            } else {
                $CPAN::Frontend->mywarn(qq{
Commands starting with "w" require CPAN::WAIT to be installed.
Please consider installing CPAN::WAIT to use the fulltext index.
For this you just need to type
    install CPAN::WAIT
});
            }
        } else {
            $CPAN::Frontend->mywarn(qq{Unknown shell command '$l'. }.
                                    qq{Type ? for help.
});
        }
        $autoload_recursion--;
    }
}
a472 1
use strict;
a478 44
sub _perl_fingerprint {
    my($self,$other_fingerprint) = @@_;
    my $dll = eval {OS2::DLLname()};
    my $mtime_dll = 0;
    if (defined $dll) {
        $mtime_dll = (-f $dll ? (stat(_))[9] : '-1');
    }
    my $mtime_perl = (-f CPAN::find_perl ? (stat(_))[9] : '-1');
    my $this_fingerprint = {
                            '$^X' => CPAN::find_perl,
                            sitearchexp => $Config::Config{sitearchexp},
                            'mtime_$^X' => $mtime_perl,
                            'mtime_dll' => $mtime_dll,
                           };
    if ($other_fingerprint) {
        if (exists $other_fingerprint->{'stat($^X)'}) { # repair fp from rev. 1.88_57
            $other_fingerprint->{'mtime_$^X'} = $other_fingerprint->{'stat($^X)'}[9];
        }
        # mandatory keys since 1.88_57
        for my $key (qw($^X sitearchexp mtime_dll mtime_$^X)) {
            return unless $other_fingerprint->{$key} eq $this_fingerprint->{$key};
        }
        return 1;
    } else {
        return $this_fingerprint;
    }
}

sub suggest_myconfig () {
  SUGGEST_MYCONFIG: if(!$INC{'CPAN/MyConfig.pm'}) {
        $CPAN::Frontend->myprint("You don't seem to have a user ".
                                 "configuration (MyConfig.pm) yet.\n");
        my $new = CPAN::Shell::colorable_makemaker_prompt("Do you want to create a ".
                                              "user configuration now? (Y/n)",
                                              "yes");
        if($new =~ m{^y}i) {
            CPAN::Shell->mkmyconfig();
            return &checklock;
        } else {
            $CPAN::Frontend->mydie("OK, giving up.");
        }
    }
}

d482 1
a482 1
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
d487 1
d499 17
a515 18
        my $fh = FileHandle->new($lockfile) or
            $CPAN::Frontend->mydie("Could not open lockfile '$lockfile': $!");
        my $otherpid  = <$fh>;
        my $otherhost = <$fh>;
        $fh->close;
        if (defined $otherpid && $otherpid) {
            chomp $otherpid;
        }
        if (defined $otherhost && $otherhost) {
            chomp $otherhost;
        }
        my $thishost  = hostname();
        if (defined $otherhost && defined $thishost &&
            $otherhost ne '' && $thishost ne '' &&
            $otherhost ne $thishost) {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Lockfile '$lockfile'\n".
                                           "reports other host $otherhost and other ".
                                           "process $otherpid.\n".
d517 5
a521 6
        } elsif ($RUN_DEGRADED) {
            $CPAN::Frontend->mywarn("Running in degraded mode (experimental)\n");
        } elsif (defined $otherpid && $otherpid) {
            return if $$ == $otherpid; # should never happen
            $CPAN::Frontend->mywarn(
                                    qq{
d524 3
a526 21
            if (kill 0, $otherpid) {
                $CPAN::Frontend->mywarn(qq{Other job is running.\n});
                my($ans) =
                    CPAN::Shell::colorable_makemaker_prompt
                        (qq{Shall I try to run in degraded }.
                        qq{mode? (Y/n)},"y");
                if ($ans =~ /^y/i) {
                    $CPAN::Frontend->mywarn("Running in degraded mode (experimental).
Please report if something unexpected happens\n");
                    $RUN_DEGRADED = 1;
                    for ($CPAN::Config) {
                        # XXX
                        # $_->{build_dir_reuse} = 0; # 2006-11-17 akoenig Why was that?
                        $_->{commandnumber_in_prompt} = 0; # visibility
                        $_->{histfile} = "";               # who should win otherwise?
                        $_->{cache_metadata} = 0;          # better would be a lock?
                        $_->{use_sqlite} = 0;              # better would be a write lock!
                    }
                } else {
                    $CPAN::Frontend->mydie("
You may want to kill the other job and delete the lockfile. On UNIX try:
d529 21
a549 21
");
                }
            } elsif (-w $lockfile) {
                my($ans) =
                    CPAN::Shell::colorable_makemaker_prompt
                        (qq{Other job not responding. Shall I overwrite }.
                        qq{the lockfile '$lockfile'? (Y/n)},"y");
            $CPAN::Frontend->myexit("Ok, bye\n")
                unless $ans =~ /^y/i;
            } else {
                Carp::croak(
                    qq{Lockfile '$lockfile' not writeable by you. }.
                    qq{Cannot proceed.\n}.
                    qq{    On UNIX try:\n}.
                    qq{    rm '$lockfile'\n}.
                    qq{  and then rerun us.\n}
                );
            }
        } else {
            $CPAN::Frontend->mydie(sprintf("CPAN.pm panic: Found invalid lockfile ".
                                           "'$lockfile', please remove. Cannot proceed.\n"));
d555 12
a566 12
        # A special case at least for Jarkko.
        my $firsterror = $@@;
        my $seconderror;
        my $symlinkcpan;
        if (-l $dotcpan) {
            $symlinkcpan = readlink $dotcpan;
            die "readlink $dotcpan failed: $!" unless defined $symlinkcpan;
            eval { File::Path::mkpath($symlinkcpan); };
            if ($@@) {
                $seconderror = $@@;
            } else {
                $CPAN::Frontend->mywarn(qq{
d569 4
a572 4
            }
        }
        unless (-d $dotcpan) {
            my $mess = qq{
d576 1
a576 1
            $mess .= qq{
d580 1
a580 1
            $mess .= qq{
d583 9
a591 16
            $CPAN::Frontend->mywarn($mess);
            return suggest_myconfig;
        }
    } # $@@ after eval mkpath $dotcpan
    if (0) { # to test what happens when a race condition occurs
        for (reverse 1..10) {
            print $_, "\n";
            sleep 1;
        }
    }
    # locking
    if (!$RUN_DEGRADED && !$self->{LOCKFH}) {
        my $fh;
        unless ($fh = FileHandle->new("+>>$lockfile")) {
            if ($! =~ /Permission/) {
                $CPAN::Frontend->mywarn(qq{
d603 5
a607 2
this variable in either a CPAN/MyConfig.pm or a CPAN/Config.pm in your
\@@INC path;
d609 2
a610 19
                return suggest_myconfig;
            }
        }
        my $sleep = 1;
        while (!CPAN::_flock($fh, LOCK_EX|LOCK_NB)) {
            if ($sleep>10) {
                $CPAN::Frontend->mydie("Giving up\n");
            }
            $CPAN::Frontend->mysleep($sleep++);
            $CPAN::Frontend->mywarn("Could not lock lockfile with flock: $!; retrying\n");
        }

        seek $fh, 0, 0;
        truncate $fh, 0;
        $fh->autoflush(1);
        $fh->print($$, "\n");
        $fh->print(hostname(), "\n");
        $self->{LOCK} = $lockfile;
        $self->{LOCKFH} = $fh;
d612 4
d617 2
a618 3
        my $sig = shift;
        &cleanup;
        $CPAN::Frontend->mydie("Got SIG$sig, leaving");
d622 4
a625 6
        my $sig = shift;
        &cleanup if $Signal;
        die "Got yet another signal" if $Signal > 1;
        $CPAN::Frontend->mydie("Got another SIG$sig") if $Signal;
        $CPAN::Frontend->mywarn("Caught SIG$sig, trying to continue\n");
        $Signal++;
a670 32
#-> sub CPAN::fastcwd ;
sub fastcwd {Cwd::fastcwd();}

#-> sub CPAN::backtickcwd ;
sub backtickcwd {my $cwd = `cwd`; chomp $cwd; $cwd}

#-> sub CPAN::find_perl ;
sub find_perl () {
    my($perl) = File::Spec->file_name_is_absolute($^X) ? $^X : "";
    my $pwd  = $CPAN::iCwd = CPAN::anycwd();
    my $candidate = File::Spec->catfile($pwd,$^X);
    $perl ||= $candidate if MM->maybe_command($candidate);

    unless ($perl) {
        my ($component,$perl_name);
      DIST_PERLNAME: foreach $perl_name ($^X, 'perl', 'perl5', "perl$]") {
          PATH_COMPONENT: foreach $component (File::Spec->path(),
                                                $Config::Config{'binexp'}) {
                next unless defined($component) && $component;
                my($abs) = File::Spec->catfile($component,$perl_name);
                if (MM->maybe_command($abs)) {
                    $perl = $abs;
                    last DIST_PERLNAME;
                }
            }
        }
    }

    return $perl;
}


d674 1
a674 1
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
d678 2
a679 9
    $id =~ s/:+/::/g if $class eq "CPAN::Module";
    my $exists;
    if (CPAN::_sqlite_running) {
        $exists = (exists $META->{readonly}{$class}{$id} or
                   $CPAN::SQLite->set($class, $id));
    } else {
        $exists =  exists $META->{readonly}{$class}{$id};
    }
    $exists ||= exists $META->{readwrite}{$class}{$id}; # unsafe meta access, ok
d707 1
a707 1
               'Net::FTP' => [
d710 1
a710 35
                           ],
               'File::HomeDir' => [
                                   sub {require File::HomeDir;
                                        unless (CPAN::Version->vge(File::HomeDir::->VERSION, 0.52)) {
                                            for ("Will not use File::HomeDir, need 0.52\n") {
                                                $CPAN::Frontend->mywarn($_);
                                                die $_;
                                            }
                                        }
                                    },
                                  ],
               'Archive::Tar' => [
                                  sub {require Archive::Tar;
                                       unless (CPAN::Version->vge(Archive::Tar::->VERSION, 1.00)) {
                                            for ("Will not use Archive::Tar, need 1.00\n") {
                                                $CPAN::Frontend->mywarn($_);
                                                die $_;
                                            }
                                       }
                                  },
                                 ],
               'File::Temp' => [
                                # XXX we should probably delete from
                                # %INC too so we can load after we
                                # installed a new enough version --
                                # I'm not sure.
                                sub {require File::Temp;
                                     unless (CPAN::Version->vge(File::Temp::->VERSION,0.16)) {
                                         for ("Will not use File::Temp, need 0.16\n") {
                                                $CPAN::Frontend->mywarn($_);
                                                die $_;
                                         }
                                     }
                                },
                               ]
d713 6
a718 8
        for my $c (0..$#{$usable->{$mod}}) {
            my $code = $usable->{$mod}[$c];
            my $ret = eval { &$code() };
            $ret = "" unless defined $ret;
            if ($@@) {
                # warn "DEBUG: c[$c]\$\@@[$@@]ret[$ret]";
                return;
            }
d720 1
d729 4
a732 5
        unless defined $mod;
    my %dont = map { $_ => 1 } keys %{$CPAN::META->{dontload_hash}||{}},
        keys %{$CPAN::Config->{dontload_hash}||{}},
            @@{$CPAN::Config->{dontload_list}||[]};
    if (defined $message && $message eq "no"  # afair only used by Nox
d734 1
a734 1
        $dont{$mod}
d744 6
a749 6
        # checking %INC is wrong, because $INC{LWP} may be true
        # although $INC{"URI/URL.pm"} may have failed. But as
        # I really want to say "bla loaded OK", I have to somehow
        # cache results.
        ### warn "$file in %INC"; #debug
        return 1;
d751 10
a760 16
        # eval is good: if we haven't yet read the database it's
        # perfect and if we have installed the module in the meantime,
        # it tries again. The second require is only a NOOP returning
        # 1 if we had success, otherwise it's retrying

        my $mtime = (stat $INC{$file})[9];
        # privileged files loaded by has_inst; Note: we use $mtime
        # as a proxy for a checksum.
        $CPAN::Shell::reload->{$file} = $mtime;
        my $v = eval "\$$mod\::VERSION";
        $v = $v ? " (v$v)" : "";
        CPAN::Shell->optprint("load_module","CPAN: $mod loaded ok$v\n");
        if ($mod eq "CPAN::WAIT") {
            push @@CPAN::Shell::ISA, 'CPAN::WAIT';
        }
        return 1;
d762 1
a762 1
        $CPAN::Frontend->mywarn(qq{
d768 5
a772 33
        $CPAN::Frontend->mysleep(3);
    } elsif ($mod eq "Digest::SHA") {
        if ($Have_warned->{"Digest::SHA"}++) {
            $CPAN::Frontend->mywarn(qq{CPAN: checksum security checks disabled }.
                                     qq{because Digest::SHA not installed.\n});
        } else {
            $CPAN::Frontend->mywarn(qq{
  CPAN: checksum security checks disabled because Digest::SHA not installed.
  Please consider installing the Digest::SHA module.

});
            $CPAN::Frontend->mysleep(2);
        }
    } elsif ($mod eq "Module::Signature") {
        # NOT prefs_lookup, we are not a distro
        my $check_sigs = $CPAN::Config->{check_sigs};
        if (not $check_sigs) {
            # they do not want us:-(
        } elsif (not $Have_warned->{"Module::Signature"}++) {
            # No point in complaining unless the user can
            # reasonably install and use it.
            if (eval { require Crypt::OpenPGP; 1 } ||
                (
                 defined $CPAN::Config->{'gpg'}
                 &&
                 $CPAN::Config->{'gpg'} =~ /\S/
                )
               ) {
                $CPAN::Frontend->mywarn(qq{
  CPAN: Module::Signature security checks disabled because Module::Signature
  not installed.  Please consider installing the Module::Signature module.
  You may also need to be able to connect over the Internet to the public
  keyservers like pgp.mit.edu (port 11371).
d775 1
a775 3
                $CPAN::Frontend->mysleep(2);
            }
        }
d777 1
a777 1
        delete $INC{$file}; # if it inc'd LWP but failed during, say, URI
d799 1
a799 1
  # warn "cleanup called with arg[@@_] End[$CPAN::End] Signal[$Signal]";
d807 1
a807 1
        $subroutine eq '(eval)';
d809 1
a809 1
  return if $ineval && !$CPAN::End;
a812 1
  close $META->{LOCKFH};
d816 1
a816 17
  if ( $CPAN::CONFIG_DIRTY ) {
      $CPAN::Frontend->mywarn("Warning: Configuration not saved.\n");
  }
  $CPAN::Frontend->myprint("Lockfile removed.\n");
}

#-> sub CPAN::readhist
sub readhist {
    my($self,$term,$histfile) = @@_;
    my($fh) = FileHandle->new;
    open $fh, "<$histfile" or last;
    local $/ = "\n";
    while (<$fh>) {
        chomp;
        $term->AddHistory($_);
    }
    close $fh;
d823 1
a823 1
    unless ($histfile = $CPAN::Config->{'histfile'}) {
d828 1
a828 1
    if ($CPAN::term) {
a844 1
#-> sub CPAN::is_tested
d846 2
a847 6
    my($self,$what,$when) = @@_;
    unless ($what) {
        Carp::cluck("DEBUG: empty what");
        return;
    }
    $self->{is_tested}{$what} = $when;
a849 3
#-> sub CPAN::is_installed
# unsets the is_tested flag: as soon as the thing is installed, it is
# not needed in set_perl5lib anymore
d855 1
a855 1
sub _list_sorted_descending_is_tested {
a856 12
    sort
        { ($self->{is_tested}{$b}||0) <=> ($self->{is_tested}{$a}||0) }
            keys %{$self->{is_tested}}
}

#-> sub CPAN::set_perl5lib
sub set_perl5lib {
    my($self,$for) = @@_;
    unless ($for) {
        (undef,undef,undef,$for) = caller(1);
        $for =~ s/.*://;
    }
d863 2
a864 23
    #my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} keys %{$self->{is_tested}};
    #$CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB.\n");

    my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} $self->_list_sorted_descending_is_tested;
    if (@@dirs < 12) {
        $CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB for '$for'\n");
    } elsif (@@dirs < 24) {
        my @@d = map {my $cp = $_;
                     $cp =~ s/^\Q$CPAN::Config->{build_dir}\E/%BUILDDIR%/;
                     $cp
                 } @@dirs;
        $CPAN::Frontend->myprint("Prepending @@d to PERL5LIB; ".
                                 "%BUILDDIR%=$CPAN::Config->{build_dir} ".
                                 "for '$for'\n"
                                );
    } else {
        my $cnt = keys %{$self->{is_tested}};
        $CPAN::Frontend->myprint("Prepending blib/arch and blib/lib of ".
                                 "$cnt build dirs to PERL5LIB; ".
                                 "for '$for'\n"
                                );
    }

a868 1
use strict;
d874 1
a874 1
        return shift->SUPER::as_string;
d876 1
a876 1
        return Data::Dumper::Dumper(shift);
a887 1
  return unless $CPAN::META->{LOCK};
d889 2
a890 3
  my @@toremove = grep { $self->{SIZE}{$_}==0 } @@{$self->{FIFO}};
  for my $current (0..$#toremove) {
    my $toremove = $toremove[$current];
d892 4
a895 6
                                     "DEL(%d/%d): %s \n",
                                     $current+1,
                                     scalar @@toremove,
                                     $toremove,
                                    )
                            );
d897 1
a897 1
    $self->_clean_cache($toremove);
d919 8
a926 8
        next if $_ eq "." || $_ eq "..";
        if (-f $_) {
            push @@entries, File::Spec->catfile($dir,$_);
        } elsif (-d _) {
            push @@entries, File::Spec->catdir($dir,$_);
        } else {
            $CPAN::Frontend->mywarn("Warning: weird direntry in $dir: $_\n");
        }
d929 1
a929 1
    sort { -M $a <=> -M $b} @@entries;
d934 1
a934 1
    my($self,$dir,$fast) = @@_;
d938 14
a951 49
    if (-e $dir) {
        if (-d $dir) {
            unless (-x $dir) {
                unless (chmod 0755, $dir) {
                    $CPAN::Frontend->mywarn("I have neither the -x permission nor the ".
                                            "permission to change the permission; cannot ".
                                            "estimate disk usage of '$dir'\n");
                    $CPAN::Frontend->mysleep(5);
                    return;
                }
            }
        } elsif (-f $dir) {
            # nothing to say, no matter what the permissions
        }
    } else {
        $CPAN::Frontend->mywarn("File or directory '$dir' has gone, ignoring\n");
        return;
    }
    if ($fast) {
        $Du = 0; # placeholder
    } else {
        find(
             sub {
           $File::Find::prune++ if $CPAN::Signal;
           return if -l $_;
           if ($^O eq 'MacOS') {
             require Mac::Files;
             my $cat  = Mac::Files::FSpGetCatInfo($_);
             $Du += $cat->ioFlLgLen() + $cat->ioFlRLgLen() if $cat;
           } else {
             if (-d _) {
               unless (-x _) {
                 unless (chmod 0755, $_) {
                   $CPAN::Frontend->mywarn("I have neither the -x permission nor ".
                                           "the permission to change the permission; ".
                                           "can only partially estimate disk usage ".
                                           "of '$_'\n");
                   $CPAN::Frontend->mysleep(5);
                   return;
                 }
               }
             } else {
               $Du += (-s _);
             }
           }
         },
         $dir
            );
    }
d954 1
a954 1
    unshift @@{$self->{FIFO}}, $dir;
d960 2
a961 2
#-> sub CPAN::CacheMgr::_clean_cache ;
sub _clean_cache {
a963 7
    unless (File::Spec->canonpath(File::Basename::dirname($dir))
            eq File::Spec->canonpath($CPAN::Config->{build_dir})) {
        $CPAN::Frontend->mywarn("Directory '$dir' not below $CPAN::Config->{build_dir}, ".
                                "will not remove\n");
        $CPAN::Frontend->mysleep(5);
        return;
    }
d965 1
a965 1
        if $CPAN::DEBUG;
a966 25
    my $id_deleted = 0;
    if ($dir !~ /\.yml$/ && -f "$dir.yml") {
        my $yaml_module = CPAN::_yaml_module;
        if ($CPAN::META->has_inst($yaml_module)) {
            my($peek_yaml) = eval { CPAN->_yaml_loadfile("$dir.yml"); };
            if ($@@) {
                $CPAN::Frontend->mywarn("(parse error on '$dir.yml' removing anyway)");
                unlink "$dir.yml" or
                    $CPAN::Frontend->mywarn("(Could not unlink '$dir.yml': $!)");
                return;
            } elsif (my $id = $peek_yaml->[0]{distribution}{ID}) {
                $CPAN::META->delete("CPAN::Distribution", $id);

                # XXX we should restore the state NOW, otherise this
                # distro does not exist until we read an index. BUG ALERT(?)

                # $CPAN::Frontend->mywarn (" +++\n");
                $id_deleted++;
            }
        }
        unlink "$dir.yml"; # may fail
        unless ($id_deleted) {
            CPAN->debug("no distro found associated with '$dir'");
        }
    }
d978 5
a982 5
        ID => $CPAN::Config->{build_dir},
        MAX => $CPAN::Config->{'build_cache'},
        SCAN => $CPAN::Config->{'scan_cache'} || 'atstart',
        DU => 0
    };
d999 1
a999 2
        unless $self->{SCAN} eq 'atstart';
    return unless $CPAN::META->{LOCK};
d1001 2
a1002 2
                             sprintf("Scanning cache %s for sizes\n",
                             $self->{ID}));
d1004 4
a1007 17
    my @@entries = $self->entries($self->{ID});
    my $i = 0;
    my $painted = 0;
    for $e (@@entries) {
        my $symbol = ".";
        if ($self->{DU} > $self->{MAX}) {
            $symbol = "-";
            $self->disk_usage($e,1);
        } else {
            $self->disk_usage($e);
        }
        $i++;
        while (($painted/76) < ($i/@@entries)) {
            $CPAN::Frontend->myprint($symbol);
            $painted++;
        }
        return if $CPAN::Signal;
a1008 1
    $CPAN::Frontend->myprint("DONE\n");
d1012 336
a1348 1
use strict;
d1354 1
a1354 10
        my $help;
        if (exists $Help->{$about}) {
            if (ref $Help->{$about}) { # aliases
                $about = ${$Help->{$about}};
            }
            $help = $Help->{$about};
        } else {
            $help = "No help available";
        }
        $CPAN::Frontend->myprint("$about\: $help\n");
d1356 2
a1357 3
        my $filler = " " x (80 - 28 - length($CPAN::VERSION));
        $CPAN::Frontend->myprint(qq{
Display Information $filler (ver $CPAN::VERSION)
d1360 3
a1362 4
 i        WORD or /REGEXP/  about any of the above
 ls       AUTHOR or GLOB    about files in the author's directory
    (with WORD being a module, bundle or author name or a distribution
    name of the form AUTHOR/DISTRIBUTION)
d1365 7
a1371 12
 get      download                     clean    make clean
 make     make (implies get)           look     open subshell in dist directory
 test     make test (implies make)     readme   display these README files
 install  make install (implies test)  perldoc  display POD documentation

Upgrade
 r        WORDs or /REGEXP/ or NONE    report updates for some/matching/all modules
 upgrade  WORDs or /REGEXP/ or NONE    upgrade some/matching/all modules

Pragmas
 force  CMD    try hard to do command  fforce CMD    try harder
 notest CMD    skip testing
d1377 2
a1378 2
 autobundle    Snapshot                recent        latest CPAN uploads});
}
d1393 6
a1398 30
#-> sub CPAN::Shell::globls ;
sub globls {
    my($self,$s,$pragmas) = @@_;
    # ls is really very different, but we had it once as an ordinary
    # command in the Shell (upto rev. 321) and we could not handle
    # force well then
    my(@@accept,@@preexpand);
    if ($s =~ /[\*\?\/]/) {
        if ($CPAN::META->has_inst("Text::Glob")) {
            if (my($au,$pathglob) = $s =~ m|(.*?)/(.*)|) {
                my $rau = Text::Glob::glob_to_regex(uc $au);
                CPAN::Shell->debug("au[$au]pathglob[$pathglob]rau[$rau]")
                      if $CPAN::DEBUG;
                push @@preexpand, map { $_->id . "/" . $pathglob }
                    CPAN::Shell->expand_by_method('CPAN::Author',['id'],"/$rau/");
            } else {
                my $rau = Text::Glob::glob_to_regex(uc $s);
                push @@preexpand, map { $_->id }
                    CPAN::Shell->expand_by_method('CPAN::Author',
                                                  ['id'],
                                                  "/$rau/");
            }
        } else {
            $CPAN::Frontend->mydie("Text::Glob not installed, cannot proceed");
        }
    } else {
        push @@preexpand, uc $s;
    }
    for (@@preexpand) {
        unless (/^[A-Z0-9\-]+(\/|$)/i) {
d1402 1
a1402 1
        push @@accept, $_;
d1404 3
a1406 43
    my $silent = @@accept>1;
    my $last_alpha = "";
    my @@results;
    for my $a (@@accept) {
        my($author,$pathglob);
        if ($a =~ m|(.*?)/(.*)|) {
            my $a2 = $1;
            $pathglob = $2;
            $author = CPAN::Shell->expand_by_method('CPAN::Author',
                                                    ['id'],
                                                    $a2)
                or $CPAN::Frontend->mydie("No author found for $a2\n");
        } else {
            $author = CPAN::Shell->expand_by_method('CPAN::Author',
                                                    ['id'],
                                                    $a)
                or $CPAN::Frontend->mydie("No author found for $a\n");
        }
        if ($silent) {
            my $alpha = substr $author->id, 0, 1;
            my $ad;
            if ($alpha eq $last_alpha) {
                $ad = "";
            } else {
                $ad = "[$alpha]";
                $last_alpha = $alpha;
            }
            $CPAN::Frontend->myprint($ad);
        }
        for my $pragma (@@$pragmas) {
            if ($author->can($pragma)) {
                $author->$pragma();
            }
        }
        push @@results, $author->ls($pathglob,$silent); # silent if
                                                       # more than one
                                                       # author
        for my $pragma (@@$pragmas) {
            my $unpragma = "un$pragma";
            if ($author->can($unpragma)) {
                $author->$unpragma();
            }
        }
a1407 1
    @@results;
d1423 1
a1423 2
                    next unless $entry =~ /^\w+(\.pm)?(?!\n)\Z/;
                    if (-d File::Spec->catdir($bdir,$entry)) {
d1456 2
d1460 2
a1461 2
    for my $type (qw/Bundle Distribution Module/) {
        push @@result, $self->expand($type,@@args);
a1462 3
    # Authors are always uppercase.
    push @@result, $self->expand("Author", map { uc $_ } @@args);

d1464 1
a1464 1
        $result[0]->as_string :
d1476 2
a1477 4
# CPAN::Shell::o and CPAN::HandleConfig::edit are closely related. 'o
# conf' calls through to CPAN::HandleConfig::edit. 'o conf' should
# probably have been called 'set' and 'o debug' maybe 'set debug' or
# 'debug'; 'o conf ARGS' calls ->edit in CPAN/HandleConfig.pm
d1483 24
a1506 34
        my($cfilter);
        ($cfilter) = $o_what[0] =~ m|^/(.*)/$| if @@o_what;
        if (!@@o_what or $cfilter) { # print all things, "o conf"
            $cfilter ||= "";
            my $qrfilter = eval 'qr/$cfilter/';
            my($k,$v);
            $CPAN::Frontend->myprint("\$CPAN::Config options from ");
            my @@from;
            if (exists $INC{'CPAN/Config.pm'}) {
                push @@from, $INC{'CPAN/Config.pm'};
            }
            if (exists $INC{'CPAN/MyConfig.pm'}) {
                push @@from, $INC{'CPAN/MyConfig.pm'};
            }
            $CPAN::Frontend->myprint(join " and ", map {"'$_'"} @@from);
            $CPAN::Frontend->myprint(":\n");
            for $k (sort keys %CPAN::HandleConfig::can) {
                next unless $k =~ /$qrfilter/;
                $v = $CPAN::HandleConfig::can{$k};
                $CPAN::Frontend->myprint(sprintf "    %-18s [%s]\n", $k, $v);
            }
            $CPAN::Frontend->myprint("\n");
            for $k (sort keys %CPAN::HandleConfig::keys) {
                next unless $k =~ /$qrfilter/;
                CPAN::HandleConfig->prettyprint($k);
            }
            $CPAN::Frontend->myprint("\n");
        } else {
            if (CPAN::HandleConfig->edit(@@o_what)) {
            } else {
                $CPAN::Frontend->myprint(qq{Type 'o conf' to view all configuration }.
                                         qq{items\n\n});
            }
        }
d1508 5
a1512 5
        my(%valid);
        @@o_what = () if defined $o_what[0] && $o_what[0] =~ /help/i;
        if (@@o_what) {
            while (@@o_what) {
                my($what) = shift @@o_what;
d1517 36
a1552 36
                if ( exists $CPAN::DEBUG{$what} ) {
                    $CPAN::DEBUG |= $CPAN::DEBUG{$what};
                } elsif ($what =~ /^\d/) {
                    $CPAN::DEBUG = $what;
                } elsif (lc $what eq 'all') {
                    my($max) = 0;
                    for (values %CPAN::DEBUG) {
                        $max += $_;
                    }
                    $CPAN::DEBUG = $max;
                } else {
                    my($known) = 0;
                    for (keys %CPAN::DEBUG) {
                        next unless lc($_) eq lc($what);
                        $CPAN::DEBUG |= $CPAN::DEBUG{$_};
                        $known = 1;
                    }
                    $CPAN::Frontend->myprint("unknown argument [$what]\n")
                        unless $known;
                }
            }
        } else {
            my $raw = "Valid options for debug are ".
                join(", ",sort(keys %CPAN::DEBUG), 'all').
                     qq{ or a number. Completion works on the options. }.
                     qq{Case is ignored.};
            require Text::Wrap;
            $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
            $CPAN::Frontend->myprint("\n\n");
        }
        if ($CPAN::DEBUG) {
            $CPAN::Frontend->myprint("Options set for debugging ($CPAN::DEBUG):\n");
            my($k,$v);
            for $k (sort {$CPAN::DEBUG{$a} <=> $CPAN::DEBUG{$b}} keys %CPAN::DEBUG) {
                $v = $CPAN::DEBUG{$k};
                $CPAN::Frontend->myprint(sprintf "    %-14s(%s)\n", $k, $v)
d1554 4
a1557 4
            }
        } else {
            $CPAN::Frontend->myprint("Debugging turned off completely.\n");
        }
d1559 1
a1559 1
        $CPAN::Frontend->myprint(qq{
a1566 1
# CPAN::Shell::paintdots_onreload
d1570 9
a1578 18
        if ( $_[0] =~ /[Ss]ubroutine ([\w:]+) redefined/ ) {
            my($subr) = $1;
            ++$$ref;
            local($|) = 1;
            # $CPAN::Frontend->myprint(".($subr)");
            $CPAN::Frontend->myprint(".");
            if ($subr =~ /\bshell\b/i) {
                # warn "debug[$_[0]]";

                # It would be nice if we could detect that a
                # subroutine has actually changed, but for now we
                # practically always set the GOTOSHELL global

                $CPAN::GOTOSHELL=1;
            }
            return;
        }
        warn @@_;
a1581 71
#-> sub CPAN::Shell::hosts ;
sub hosts {
    my($self) = @@_;
    my $fullstats = CPAN::FTP->_ftp_statistics();
    my $history = $fullstats->{history} || [];
    my %S; # statistics
    while (my $last = pop @@$history) {
        my $attempts = $last->{attempts} or next;
        my $start;
        if (@@$attempts) {
            $start = $attempts->[-1]{start};
            if ($#$attempts > 0) {
                for my $i (0..$#$attempts-1) {
                    my $url = $attempts->[$i]{url} or next;
                    $S{no}{$url}++;
                }
            }
        } else {
            $start = $last->{start};
        }
        next unless $last->{thesiteurl}; # C-C? bad filenames?
        $S{start} = $start;
        $S{end} ||= $last->{end};
        my $dltime = $last->{end} - $start;
        my $dlsize = $last->{filesize} || 0;
        my $url = ref $last->{thesiteurl} ? $last->{thesiteurl}->text : $last->{thesiteurl};
        my $s = $S{ok}{$url} ||= {};
        $s->{n}++;
        $s->{dlsize} ||= 0;
        $s->{dlsize} += $dlsize/1024;
        $s->{dltime} ||= 0;
        $s->{dltime} += $dltime;
    }
    my $res;
    for my $url (keys %{$S{ok}}) {
        next if $S{ok}{$url}{dltime} == 0; # div by zero
        push @@{$res->{ok}}, [@@{$S{ok}{$url}}{qw(n dlsize dltime)},
                             $S{ok}{$url}{dlsize}/$S{ok}{$url}{dltime},
                             $url,
                            ];
    }
    for my $url (keys %{$S{no}}) {
        push @@{$res->{no}}, [$S{no}{$url},
                             $url,
                            ];
    }
    my $R = ""; # report
    if ($S{start} && $S{end}) {
        $R .= sprintf "Log starts: %s\n", $S{start} ? scalar(localtime $S{start}) : "unknown";
        $R .= sprintf "Log ends  : %s\n", $S{end}   ? scalar(localtime $S{end})   : "unknown";
    }
    if ($res->{ok} && @@{$res->{ok}}) {
        $R .= sprintf "\nSuccessful downloads:
   N       kB  secs      kB/s url\n";
        my $i = 20;
        for (sort { $b->[3] <=> $a->[3] } @@{$res->{ok}}) {
            $R .= sprintf "%4d %8d %5d %9.1f %s\n", @@$_;
            last if --$i<=0;
        }
    }
    if ($res->{no} && @@{$res->{no}}) {
        $R .= sprintf "\nUnsuccessful downloads:\n";
        my $i = 20;
        for (sort { $b->[0] <=> $a->[0] } @@{$res->{no}}) {
            $R .= sprintf "%4d %s\n", @@$_;
            last if --$i<=0;
        }
    }
    $CPAN::Frontend->myprint($R);
}

d1587 7
a1593 24
    if ($command =~ /^cpan$/i) {
        my $redef = 0;
        chdir $CPAN::iCwd if $CPAN::iCwd; # may fail
        my $failed;
        my @@relo = (
                    "CPAN.pm",
                    "CPAN/Debug.pm",
                    "CPAN/FirstTime.pm",
                    "CPAN/HandleConfig.pm",
                    "CPAN/Kwalify.pm",
                    "CPAN/Queue.pm",
                    "CPAN/Reporter/Config.pm",
                    "CPAN/Reporter/History.pm",
                    "CPAN/Reporter.pm",
                    "CPAN/SQLite.pm",
                    "CPAN/Tarzip.pm",
                    "CPAN/Version.pm",
                   );
      MFILE: for my $f (@@relo) {
            next unless exists $INC{$f};
            my $p = $f;
            $p =~ s/\.pm$//;
            $p =~ s|/|::|g;
            $CPAN::Frontend->myprint("($p");
d1595 3
a1597 9
            $self->_reload_this($f) or $failed++;
            my $v = eval "$p\::->VERSION";
            $CPAN::Frontend->myprint("v$v)");
        }
        $CPAN::Frontend->myprint("\n$redef subroutines redefined\n");
        if ($failed) {
            my $errors = $failed == 1 ? "error" : "errors";
            $CPAN::Frontend->mywarn("\n$failed $errors during reload. You better quit ".
                                    "this session.\n");
d1599 1
a1599 1
    } elsif ($command =~ /^index$/i) {
d1602 1
a1602 1
      $CPAN::Frontend->myprint(qq{cpan     re-evals the CPAN modules
a1606 85
# reload means only load again what we have loaded before
#-> sub CPAN::Shell::_reload_this ;
sub _reload_this {
    my($self,$f,$args) = @@_;
    CPAN->debug("f[$f]") if $CPAN::DEBUG;
    return 1 unless $INC{$f}; # we never loaded this, so we do not
                              # reload but say OK
    my $pwd = CPAN::anycwd();
    CPAN->debug("pwd[$pwd]") if $CPAN::DEBUG;
    my($file);
    for my $inc (@@INC) {
        $file = File::Spec->catfile($inc,split /\//, $f);
        last if -f $file;
        $file = "";
    }
    CPAN->debug("file[$file]") if $CPAN::DEBUG;
    my @@inc = @@INC;
    unless ($file && -f $file) {
        # this thingie is not in the INC path, maybe CPAN/MyConfig.pm?
        $file = $INC{$f};
        unless (CPAN->has_inst("File::Basename")) {
            @@inc = File::Basename::dirname($file);
        } else {
            # do we ever need this?
            @@inc = substr($file,0,-length($f)-1); # bring in back to me!
        }
    }
    CPAN->debug("file[$file]inc[@@inc]") if $CPAN::DEBUG;
    unless (-f $file) {
        $CPAN::Frontend->mywarn("Found no file to reload for '$f'\n");
        return;
    }
    my $mtime = (stat $file)[9];
    if ($reload->{$f}) {
    } elsif ($^T < $mtime) {
        # since we started the file has changed, force it to be reloaded
        $reload->{$f} = -1;
    } else {
        $reload->{$f} = $mtime;
    }
    my $must_reload = $mtime != $reload->{$f};
    $args ||= {};
    $must_reload ||= $args->{reloforce}; # o conf defaults needs this
    if ($must_reload) {
        my $fh = FileHandle->new($file) or
            $CPAN::Frontend->mydie("Could not open $file: $!");
        local($/);
        local $^W = 1;
        my $content = <$fh>;
        CPAN->debug(sprintf("reload file[%s] content[%s...]",$file,substr($content,0,128)))
            if $CPAN::DEBUG;
        delete $INC{$f};
        local @@INC = @@inc;
        eval "require '$f'";
        if ($@@) {
            warn $@@;
            return;
        }
        $reload->{$f} = $mtime;
    } else {
        $CPAN::Frontend->myprint("__unchanged__");
    }
    return 1;
}

#-> sub CPAN::Shell::mkmyconfig ;
sub mkmyconfig {
    my($self, $cpanpm, %args) = @@_;
    require CPAN::FirstTime;
    my $home = CPAN::HandleConfig::home;
    $cpanpm = $INC{'CPAN/MyConfig.pm'} ||
        File::Spec->catfile(split /\//, "$home/.cpan/CPAN/MyConfig.pm");
    File::Path::mkpath(File::Basename::dirname($cpanpm)) unless -e $cpanpm;
    CPAN::HandleConfig::require_myconfig_or_config;
    $CPAN::Config ||= {};
    $CPAN::Config = {
        %$CPAN::Config,
        build_dir           =>  undef,
        cpan_home           =>  undef,
        keep_source_where   =>  undef,
        histfile            =>  undef,
    };
    CPAN::FirstTime::init($cpanpm, %args);
}

d1612 3
a1614 3
        my $file  = $module->cpan_file;
        next if $file eq "N/A";
        next if $file =~ /^Contact Author/;
d1616 5
a1620 5
        next if $dist->isa_perl;
        next unless $module->xs_file;
        local($|) = 1;
        $CPAN::Frontend->myprint(".");
        push @@result, $module;
d1632 1
a1632 1
    for $module (@@module) { # we force now and compile later, so we
d1634 4
a1637 4
        $cpan_file = $module->cpan_file;
        my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
        $pack->force;
        $dist{$cpan_file}++;
d1640 4
a1643 4
        $CPAN::Frontend->myprint("  CPAN: Recompiling $cpan_file\n\n");
        my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
        $pack->install;
        $CPAN::Signal = 0; # it's tempting to reset Signal, so we can
a1648 136
#-> sub CPAN::Shell::scripts ;
sub scripts {
    my($self, $arg) = @@_;
    $CPAN::Frontend->mywarn(">>>> experimental command, currently unsupported <<<<\n\n");

    for my $req (qw( HTML::LinkExtor Sort::Versions List::Util )) {
        unless ($CPAN::META->has_inst($req)) {
            $CPAN::Frontend->mywarn("  $req not available\n");
        }
    }
    my $p = HTML::LinkExtor->new();
    my $indexfile = "/home/ftp/pub/PAUSE/scripts/new/index.html";
    unless (-f $indexfile) {
        $CPAN::Frontend->mydie("found no indexfile[$indexfile]\n");
    }
    $p->parse_file($indexfile);
    my @@hrefs;
    my $qrarg;
    if ($arg =~ s|^/(.+)/$|$1|) {
        $qrarg = eval 'qr/$arg/'; # hide construct from 5.004
    }
    for my $l ($p->links) {
        my $tag = shift @@$l;
        next unless $tag eq "a";
        my %att = @@$l;
        my $href = $att{href};
        next unless $href =~ s|^\.\./authors/id/./../||;
        if ($arg) {
            if ($qrarg) {
                if ($href =~ $qrarg) {
                    push @@hrefs, $href;
                }
            } else {
                if ($href =~ /\Q$arg\E/) {
                    push @@hrefs, $href;
                }
            }
        } else {
            push @@hrefs, $href;
        }
    }
    # now filter for the latest version if there is more than one of a name
    my %stems;
    for (sort @@hrefs) {
        my $href = $_;
        s/-v?\d.*//;
        my $stem = $_;
        $stems{$stem} ||= [];
        push @@{$stems{$stem}}, $href;
    }
    for (sort keys %stems) {
        my $highest;
        if (@@{$stems{$_}} > 1) {
            $highest = List::Util::reduce {
                Sort::Versions::versioncmp($a,$b) > 0 ? $a : $b
              } @@{$stems{$_}};
        } else {
            $highest = $stems{$_}[0];
        }
        $CPAN::Frontend->myprint("$highest\n");
    }
}

#-> sub CPAN::Shell::report ;
sub report {
    my($self,@@args) = @@_;
    unless ($CPAN::META->has_inst("CPAN::Reporter")) {
        $CPAN::Frontend->mydie("CPAN::Reporter not installed; cannot continue");
    }
    local $CPAN::Config->{test_report} = 1;
    $self->force("test",@@args); # force is there so that the test be
                                # re-run (as documented)
}

# compare with is_tested
#-> sub CPAN::Shell::install_tested
sub install_tested {
    my($self,@@some) = @@_;
    $CPAN::Frontend->mywarn("install_tested() must not be called with arguments.\n"),
        return if @@some;
    CPAN::Index->reload;

    for my $b (reverse $CPAN::META->_list_sorted_descending_is_tested) {
        my $yaml = "$b.yml";
        unless (-f $yaml) {
            $CPAN::Frontend->mywarn("No YAML file for $b available, skipping\n");
            next;
        }
        my $yaml_content = CPAN->_yaml_loadfile($yaml);
        my $id = $yaml_content->[0]{distribution}{ID};
        unless ($id) {
            $CPAN::Frontend->mywarn("No ID found in '$yaml', skipping\n");
            next;
        }
        my $do = CPAN::Shell->expandany($id);
        unless ($do) {
            $CPAN::Frontend->mywarn("Could not expand ID '$id', skipping\n");
            next;
        }
        unless ($do->{build_dir}) {
            $CPAN::Frontend->mywarn("Distro '$id' has no build_dir, skipping\n");
            next;
        }
        unless ($do->{build_dir} eq $b) {
            $CPAN::Frontend->mywarn("Distro '$id' has build_dir '$do->{build_dir}' but expected '$b', skipping\n");
            next;
        }
        push @@some, $do;
    }

    $CPAN::Frontend->mywarn("No tested distributions found.\n"),
        return unless @@some;

    @@some = grep { $_->{make_test} && ! $_->{make_test}->failed } @@some;
    $CPAN::Frontend->mywarn("No distributions tested with this build of perl found.\n"),
        return unless @@some;

    # @@some = grep { not $_->uptodate } @@some;
    # $CPAN::Frontend->mywarn("No non-uptodate distributions tested with this build of perl found.\n"),
    #     return unless @@some;

    CPAN->debug("some[@@some]");
    for my $d (@@some) {
        my $id = $d->can("pretty_id") ? $d->pretty_id : $d->id;
        $CPAN::Frontend->myprint("install_tested: Running for $id\n");
        $CPAN::Frontend->mysleep(1);
        $self->install($d);
    }
}

#-> sub CPAN::Shell::upgrade ;
sub upgrade {
    my($self,@@args) = @@_;
    $self->install($self->r(@@args));
}

d1659 1
a1659 2
       $version_undefs,$version_zeroes,
       @@version_undefs,@@version_zeroes);
d1668 19
a1686 22
  MODULE: for $module (@@expand) {
        my $file  = $module->cpan_file;
        next MODULE unless defined $file; # ??
        $file =~ s!^./../!!;
        my($latest) = $module->cpan_version;
        my($inst_file) = $module->inst_file;
        my($have);
        return if $CPAN::Signal;
        if ($inst_file) {
            if ($what eq "a") {
                $have = $module->inst_version;
            } elsif ($what eq "r") {
                $have = $module->inst_version;
                local($^W) = 0;
                if ($have eq "undef") {
                    $version_undefs++;
                    push @@version_undefs, $module->as_glimpse;
                } elsif (CPAN::Version->vcmp($have,0)==0) {
                    $version_zeroes++;
                    push @@version_zeroes, $module->as_glimpse;
                }
                next MODULE unless CPAN::Version->vgt($latest, $have);
d1690 27
a1716 27
            } elsif ($what eq "u") {
                next MODULE;
            }
        } else {
            if ($what eq "a") {
                next MODULE;
            } elsif ($what eq "r") {
                next MODULE;
            } elsif ($what eq "u") {
                $have = "-";
            }
        }
        return if $CPAN::Signal; # this is sometimes lengthy
        $seen{$file} ||= 0;
        if ($what eq "a") {
            push @@result, sprintf "%s %s\n", $module->id, $have;
        } elsif ($what eq "r") {
            push @@result, $module->id;
            next MODULE if $seen{$file}++;
        } elsif ($what eq "u") {
            push @@result, $module->id;
            next MODULE if $seen{$file}++;
            next MODULE if $file =~ /^Contact/;
        }
        unless ($headerdone++) {
            $CPAN::Frontend->myprint("\n");
            $CPAN::Frontend->myprint(sprintf(
d1725 1
a1725 1
        }
d1733 1
a1733 1
            $module->description
d1738 1
a1738 1
        $CPAN::Frontend->myprint(sprintf $sprintf,
d1745 1
a1745 1
        $need{$module->id}++;
d1748 5
a1752 5
        if ($what eq "u") {
            $CPAN::Frontend->myprint("No modules found for @@args\n");
        } elsif ($what eq "r") {
            $CPAN::Frontend->myprint("All modules are up to date for @@args\n");
        }
d1755 10
a1764 28
        if ($version_zeroes) {
            my $s_has = $version_zeroes > 1 ? "s have" : " has";
            $CPAN::Frontend->myprint(qq{$version_zeroes installed module$s_has }.
                                     qq{a version number of 0\n});
            if ($CPAN::Config->{show_zero_versions}) {
                local $" = "\t";
                $CPAN::Frontend->myprint(qq{  they are\n\t@@version_zeroes\n});
                $CPAN::Frontend->myprint(qq{(use 'o conf show_zero_versions 0' }.
                                         qq{to hide them)\n});
            } else {
                $CPAN::Frontend->myprint(qq{(use 'o conf show_zero_versions 1' }.
                                         qq{to show them)\n});
            }
        }
        if ($version_undefs) {
            my $s_has = $version_undefs > 1 ? "s have" : " has";
            $CPAN::Frontend->myprint(qq{$version_undefs installed module$s_has no }.
                                     qq{parseable version number\n});
            if ($CPAN::Config->{show_unparsable_versions}) {
                local $" = "\t";
                $CPAN::Frontend->myprint(qq{  they are\n\t@@version_undefs\n});
                $CPAN::Frontend->myprint(qq{(use 'o conf show_unparsable_versions 0' }.
                                         qq{to hide them)\n});
            } else {
                $CPAN::Frontend->myprint(qq{(use 'o conf show_unparsable_versions 1' }.
                                         qq{to show them)\n});
            }
        }
d1779 7
a1785 146
#-> sub CPAN::Shell::failed ;
sub failed {
    my($self,$only_id,$silent) = @@_;
    my @@failed;
  DIST: for my $d ($CPAN::META->all_objects("CPAN::Distribution")) {
        my $failed = "";
      NAY: for my $nosayer ( # order matters!
                            "unwrapped",
                            "writemakefile",
                            "signature_verify",
                            "make",
                            "make_test",
                            "install",
                            "make_clean",
                           ) {
            next unless exists $d->{$nosayer};
            next unless defined $d->{$nosayer};
            next unless (
                         UNIVERSAL::can($d->{$nosayer},"failed") ?
                         $d->{$nosayer}->failed :
                         $d->{$nosayer} =~ /^NO/
                        );
            next NAY if $only_id && $only_id != (
                                                 UNIVERSAL::can($d->{$nosayer},"commandid")
                                                 ?
                                                 $d->{$nosayer}->commandid
                                                 :
                                                 $CPAN::CurrentCommandId
                                                );
            $failed = $nosayer;
            last;
        }
        next DIST unless $failed;
        my $id = $d->id;
        $id =~ s|^./../||;
        #$print .= sprintf(
        #                  "  %-45s: %s %s\n",
        push @@failed,
            (
             UNIVERSAL::can($d->{$failed},"failed") ?
             [
              $d->{$failed}->commandid,
              $id,
              $failed,
              $d->{$failed}->text,
              $d->{$failed}{TIME}||0,
             ] :
             [
              1,
              $id,
              $failed,
              $d->{$failed},
              0,
             ]
            );
    }
    my $scope;
    if ($only_id) {
        $scope = "this command";
    } elsif ($CPAN::Index::HAVE_REANIMATED) {
        $scope = "this or a previous session";
        # it might be nice to have a section for previous session and
        # a second for this
    } else {
        $scope = "this session";
    }
    if (@@failed) {
        my $print;
        my $debug = 0;
        if ($debug) {
            $print = join "",
                map { sprintf "%5d %-45s: %s %s\n", @@$_ }
                    sort { $a->[0] <=> $b->[0] } @@failed;
        } else {
            $print = join "",
                map { sprintf " %-45s: %s %s\n", @@$_[1..3] }
                    sort {
                        $a->[0] <=> $b->[0]
                            ||
                                $a->[4] <=> $b->[4]
                       } @@failed;
        }
        $CPAN::Frontend->myprint("Failed during $scope:\n$print");
    } elsif (!$only_id || !$silent) {
        $CPAN::Frontend->myprint("Nothing failed in $scope\n");
    }
}

# XXX intentionally undocumented because completely bogus, unportable,
# useless, etc.

#-> sub CPAN::Shell::status ;
sub status {
    my($self) = @@_;
    require Devel::Size;
    my $ps = FileHandle->new;
    open $ps, "/proc/$$/status";
    my $vm = 0;
    while (<$ps>) {
        next unless /VmSize:\s+(\d+)/;
        $vm = $1;
        last;
    }
    $CPAN::Frontend->mywarn(sprintf(
                                    "%-27s %6d\n%-27s %6d\n",
                                    "vm",
                                    $vm,
                                    "CPAN::META",
                                    Devel::Size::total_size($CPAN::META)/1024,
                                   ));
    for my $k (sort keys %$CPAN::META) {
        next unless substr($k,0,4) eq "read";
        warn sprintf " %-26s %6d\n", $k, Devel::Size::total_size($CPAN::META->{$k})/1024;
        for my $k2 (sort keys %{$CPAN::META->{$k}}) {
            warn sprintf "  %-25s %6d (keys: %6d)\n",
                $k2,
                    Devel::Size::total_size($CPAN::META->{$k}{$k2})/1024,
                          scalar keys %{$CPAN::META->{$k}{$k2}};
        }
    }
}

# compare with install_tested
#-> sub CPAN::Shell::is_tested
sub is_tested {
    my($self) = @@_;
    CPAN::Index->reload;
    for my $b (reverse $CPAN::META->_list_sorted_descending_is_tested) {
        my $time;
        if ($CPAN::META->{is_tested}{$b}) {
            $time = scalar(localtime $CPAN::META->{is_tested}{$b});
        } else {
            $time = scalar localtime;
            $time =~ s/\S/?/g;
        }
        $CPAN::Frontend->myprint(sprintf "%s %s\n", $time, $b);
    }
}

#-> sub CPAN::Shell::autobundle ;
sub autobundle {
    my($self) = shift;
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
    my(@@bundle) = $self->_u_r_common("a",@@_);
    my($todir) = File::Spec->catdir($CPAN::Config->{'cpan_home'},"Bundle");
    File::Path::mkpath($todir);
d1787 2
a1788 2
        $CPAN::Frontend->myprint("Couldn't mkdir $todir for some reason\n");
        return;
d1797 2
a1798 2
        $me = sprintf "Snapshot_%04d_%02d_%02d_%02d", $y, $m, $d, ++$c;
        $to = File::Spec->catfile($todir,"$me.pm");
d1802 19
a1820 19
               "package Bundle::$me;\n\n",
               "\$VERSION = '0.01';\n\n",
               "1;\n\n",
               "__END__\n\n",
               "=head1 NAME\n\n",
               "Bundle::$me - Snapshot of installation on ",
               $Config::Config{'myhostname'},
               " on ",
               scalar(localtime),
               "\n\n=head1 SYNOPSIS\n\n",
               "perl -MCPAN -e 'install Bundle::$me'\n\n",
               "=head1 CONTENTS\n\n",
               join("\n", @@bundle),
               "\n\n=head1 CONFIGURATION\n\n",
               Config->myconfig,
               "\n\n=head1 AUTHOR\n\n",
               "This Bundle has been generated automatically ",
               "by the autobundle routine in CPAN.pm.\n",
              );
d1830 1
a1830 1
    if ($s =~ m|/| or substr($s,-1,1) eq ".") { # looks like a file or a directory
d1849 1
a1849 1
    my $self = shift;
d1851 1
a1852 14
    my $class = "CPAN::$type";
    my $methods = ['id'];
    for my $meth (qw(name)) {
        next unless $class->can($meth);
        push @@$methods, $meth;
    }
    $self->expand_by_method($class,$methods,@@args);
}

#-> sub CPAN::Shell::expand_by_method ;
sub expand_by_method {
    my $self = shift;
    my($class,$methods,@@args) = @@_;
    my($arg,@@m);
d1854 5
a1858 7
        my($regex,$command);
        if ($arg =~ m|^/(.*)/$|) {
            $regex = $1;
# FIXME:  there seem to be some ='s in the author data, which trigger
#         a failure here.  This needs to be contemplated.
#            } elsif ($arg =~ m/=/) {
#                $command = 1;
d1860 2
a1861 1
        my $obj;
d1865 1
a1865 1
                    defined $command ? $command : "UNDEFINED",
d1867 1
a1867 4
        if (defined $regex) {
            if (CPAN::_sqlite_running) {
                $CPAN::SQLite->search($class, $regex);
            }
d1869 2
d1873 1
a1873 1
                unless ($obj && UNIVERSAL::can($obj,"id") && $obj->id) {
d1883 13
a1895 11
                for my $method (@@$methods) {
                    my $match = eval {$obj->$method() =~ /$regex/i};
                    if ($@@) {
                        my($err) = $@@ =~ /^(.+) at .+? line \d+\.$/;
                        $err ||= $@@; # if we were too restrictive above
                        $CPAN::Frontend->mydie("$err\n");
                    } elsif ($match) {
                        push @@m, $obj;
                        last;
                    }
                }
d1918 5
a1922 5
        } else {
            my($xarg) = $arg;
            if ( $class eq 'CPAN::Bundle' ) {
                $xarg =~ s/^(Bundle::)?(.*)/Bundle::$2/;
            } elsif ($class eq "CPAN::Distribution") {
a1923 9
            } else {
                $xarg =~ s/:+/::/g;
            }
            if ($CPAN::META->exists($class,$xarg)) {
                $obj = $CPAN::META->instance($class,$xarg);
            } elsif ($CPAN::META->exists($class,$arg)) {
                $obj = $CPAN::META->instance($class,$arg);
            } else {
                next;
d1925 9
a1933 8
            push @@m, $obj;
        }
    }
    @@m = sort {$a->id cmp $b->id} @@m;
    if ( $CPAN::DEBUG ) {
        my $wantarray = wantarray;
        my $join_m = join ",", map {$_->id} @@m;
        $self->debug("wantarray[$wantarray]join_m[$join_m]");
d1945 1
a1945 1
        $result[0]->as_string :
a1954 25
#-> sub CPAN::Shell::report_fh ;
{
    my $installation_report_fh;
    my $previously_noticed = 0;

    sub report_fh {
        return $installation_report_fh if $installation_report_fh;
        if ($CPAN::META->has_usable("File::Temp")) {
            $installation_report_fh
                = File::Temp->new(
                                  dir      => File::Spec->tmpdir,
                                  template => 'cpan_install_XXXX',
                                  suffix   => '.txt',
                                  unlink   => 0,
                                 );
        }
        unless ( $installation_report_fh ) {
            warn("Couldn't open installation report file; " .
                 "no report file will be generated."
                ) unless $previously_noticed++;
        }
    }
}


d1959 1
a1959 22
# to turn colordebugging on, write
# cpan> o conf colorize_output 1

#-> sub CPAN::Shell::print_ornamented ;
{
    my $print_ornamented_have_warned = 0;
    sub colorize_output {
        my $colorize_output = $CPAN::Config->{colorize_output};
        if ($colorize_output && !$CPAN::META->has_inst("Term::ANSIColor")) {
            unless ($print_ornamented_have_warned++) {
                # no myprint/mywarn within myprint/mywarn!
                warn "Colorize_output is set to true but Term::ANSIColor is not
installed. To activate colorized output, please install Term::ANSIColor.\n\n";
            }
            $colorize_output = 0;
        }
        return $colorize_output;
    }
}


#-> sub CPAN::Shell::print_ornamented ;
d1962 1
d1965 1
a1965 8
    local $| = 1; # Flush immediately
    if ( $CPAN::Be_Silent ) {
        print {report_fh()} $what;
        return;
    }
    my $swhat = "$what"; # stringify if it is an object
    if ($CPAN::Config->{term_is_latin}) {
        # note: deprecated, need to switch to $LANG and $LC_*
d1967 1
a1967 1
        $swhat
d1970 25
a1994 22
    if ($self->colorize_output) {
        if ( $CPAN::DEBUG && $swhat =~ /^Debug\(/ ) {
            # if you want to have this configurable, please file a bugreport
            $ornament = $CPAN::Config->{colorize_debug} || "black on_cyan";
        }
        my $color_on = eval { Term::ANSIColor::color($ornament) } || "";
        if ($@@) {
            print "Term::ANSIColor rejects color[$ornament]: $@@\n
Please choose a different color (Hint: try 'o conf init /color/')\n";
        }
        # GGOLDBACH/Test-GreaterVersion-0.008 broke wthout this
        # $trailer construct. We want the newline be the last thing if
        # there is a newline at the end ensuring that the next line is
        # empty for other players
        my $trailer = "";
        $trailer = $1 if $swhat =~ s/([\r\n]+)\z//;
        print $color_on,
            $swhat,
                Term::ANSIColor::color("reset"),
                      $trailer;
    } else {
        print $swhat;
a1997 6
#-> sub CPAN::Shell::myprint ;

# where is myprint/mywarn/Frontend/etc. documented? Where to use what?
# I think, we send everything to STDOUT and use print for normal/good
# news and warn for news that need more attention. Yes, this is our
# working contract for now.
a1999 4
    $self->print_ornamented($what,
                            $CPAN::Config->{colorize_print}||'bold blue on_white',
                           );
}
d2001 1
a2001 9
sub optprint {
    my($self,$category,$what) = @@_;
    my $vname = $category . "_verbosity";
    CPAN::HandleConfig->load unless $CPAN::Config_loaded++;
    if (!$CPAN::Config->{$vname}
        || $CPAN::Config->{$vname} =~ /^v/
       ) {
        $CPAN::Frontend->myprint($what);
    }
a2003 1
#-> sub CPAN::Shell::myexit ;
a2009 1
#-> sub CPAN::Shell::mywarn ;
d2012 1
a2012 1
    $self->print_ornamented($what, $CPAN::Config->{colorize_warn}||'bold red on_white');
d2015 1
a2015 3
# only to be used for shell commands
#-> sub CPAN::Shell::mydie ;
sub mydie {
d2017 2
a2018 8
    $self->mywarn($what);

    # If it is the shell, we want the following die to be silent,
    # but if it is not the shell, we would need a 'die $what'. We need
    # to take care that only shell commands use mydie. Is this
    # possible?

    die "\n";
d2021 1
a2021 18
# sub CPAN::Shell::colorable_makemaker_prompt ;
sub colorable_makemaker_prompt {
    my($foo,$bar) = @@_;
    if (CPAN::Shell->colorize_output) {
        my $ornament = $CPAN::Config->{colorize_print}||'bold blue on_white';
        my $color_on = eval { Term::ANSIColor::color($ornament); } || "";
        print $color_on;
    }
    my $ans = ExtUtils::MakeMaker::prompt($foo,$bar);
    if (CPAN::Shell->colorize_output) {
        print Term::ANSIColor::color('reset');
    }
    return $ans;
}

# use this only for unrecoverable errors!
#-> sub CPAN::Shell::unrecoverable_error ;
sub unrecoverable_error {
d2023 2
a2024 29
    my @@lines = split /\n/, $what;
    my $longest = 0;
    for my $l (@@lines) {
        $longest = length $l if length $l > $longest;
    }
    $longest = 62 if $longest > 62;
    for my $l (@@lines) {
        if ($l =~ /^\s*$/) {
            $l = "\n";
            next;
        }
        $l = "==> $l";
        if (length $l < 66) {
            $l = pack "A66 A*", $l, "<==";
        }
        $l .= "\n";
    }
    unshift @@lines, "\n";
    $self->mydie(join "", @@lines);
}

#-> sub CPAN::Shell::mysleep ;
sub mysleep {
    my($self, $sleep) = @@_;
    if (CPAN->has_inst("Time::HiRes")) {
        Time::HiRes::sleep($sleep);
    } else {
        sleep($sleep < 1 ? 1 : int($sleep + 0.5));
    }
a2026 1
#-> sub CPAN::Shell::setup_output ;
d2037 1
a2037 1
# RE-adme||MA-ke||TE-st||IN-stall : nearly everything runs through here
d2039 1
a2039 1
    my $self = shift;
d2041 4
a2044 6
    my @@pragma;
    while($meth =~ /^(ff?orce|notest)$/) {
        push @@pragma, $meth;
        $meth = shift @@some or
            $CPAN::Frontend->mydie("Pragma $pragma[-1] used without method: ".
                                   "cannot continue");
d2047 1
a2047 1
    CPAN->debug("pragma[@@pragma]meth[$meth]some[@@some]") if $CPAN::DEBUG;
a2062 4
    # With configure_requires, "get" is vulnerable in recursion.

    my $needs_recursion_protection = "get|make|test|install";

d2065 3
a2067 3
  STHING: foreach $s (@@some) {
        my $obj;
        if (ref $s) {
d2069 7
a2075 15
            $obj = $s;
        } elsif ($s =~ m|[\$\@@\%]|) { # looks like a perl variable
        } elsif ($s =~ m|^/|) { # looks like a regexp
            if (substr($s,-1,1) eq ".") {
                $obj = CPAN::Shell->expandany($s);
            } else {
                $CPAN::Frontend->mywarn("Sorry, $meth with a regular expression is ".
                                        "not supported.\nRejecting argument '$s'\n");
                $CPAN::Frontend->mysleep(2);
                next;
            }
        } elsif ($meth eq "ls") {
            $self->globls($s,\@@pragma);
            next STHING;
        } else {
d2077 5
a2081 23
            $obj = CPAN::Shell->expandany($s);
        }
        if (0) {
        } elsif (ref $obj) {
            if ($meth =~ /^($needs_recursion_protection)$/) {
                # it would be silly to check for recursion for look or dump
                # (we are in CPAN::Shell::rematein)
                CPAN->debug("Going to test against recursion") if $CPAN::DEBUG;
                eval {  $obj->color_cmd_tmps(0,1); };
                if ($@@) {
                    if (ref $@@
                        and $@@->isa("CPAN::Exception::RecursiveDependency")) {
                        $CPAN::Frontend->mywarn($@@);
                    } else {
                        if (0) {
                            require Carp;
                            Carp::confess(sprintf "DEBUG: \$\@@[%s]ref[%s]", $@@, ref $@@);
                        }
                        die;
                    }
                }
            }
            CPAN::Queue->queue_item(qmod => $obj->id, reqtype => "c");
d2083 3
a2085 3
        } elsif ($CPAN::META->exists('CPAN::Author',uc($s))) {
            $obj = $CPAN::META->instance('CPAN::Author',uc($s));
            if ($meth =~ /^(dump|ls|reports)$/) {
d2088 7
a2094 7
                $CPAN::Frontend->mywarn(
                                        join "",
                                        "Don't be silly, you can't $meth ",
                                        $obj->fullname,
                                        " ;-)\n"
                                       );
                $CPAN::Frontend->mysleep(2);
d2096 4
a2099 6
        } elsif ($s =~ m|[\$\@@\%]| && $meth eq "dump") {
            CPAN::InfoObj->dump($s);
        } else {
            $CPAN::Frontend
                ->mywarn(qq{Warning: Cannot $meth $s, }.
                         qq{don't know what it is.
d2106 2
a2107 2
            $CPAN::Frontend->mysleep(2);
        }
d2113 1
a2113 1
    while (my $q = CPAN::Queue->first) {
d2115 12
a2126 50
        my $s = $q->as_string;
        my $reqtype = $q->reqtype || "";
        $obj = CPAN::Shell->expandany($s);
        unless ($obj) {
            # don't know how this can happen, maybe we should panic,
            # but maybe we get a solution from the first user who hits
            # this unfortunate exception?
            $CPAN::Frontend->mywarn("Warning: Could not expand string '$s' ".
                                    "to an object. Skipping.\n");
            $CPAN::Frontend->mysleep(5);
            CPAN::Queue->delete_first($s);
            next;
        }
        $obj->{reqtype} ||= "";
        {
            # force debugging because CPAN::SQLite somehow delivers us
            # an empty object;

            # local $CPAN::DEBUG = 1024; # Shell; probably fixed now

            CPAN->debug("s[$s]obj-reqtype[$obj->{reqtype}]".
                        "q-reqtype[$reqtype]") if $CPAN::DEBUG;
        }
        if ($obj->{reqtype}) {
            if ($obj->{reqtype} eq "b" && $reqtype =~ /^[rc]$/) {
                $obj->{reqtype} = $reqtype;
                if (
                    exists $obj->{install}
                    &&
                    (
                     UNIVERSAL::can($obj->{install},"failed") ?
                     $obj->{install}->failed :
                     $obj->{install} =~ /^NO/
                    )
                   ) {
                    delete $obj->{install};
                    $CPAN::Frontend->mywarn
                        ("Promoting $obj->{ID} from 'build_requires' to 'requires'");
                }
            }
        } else {
            $obj->{reqtype} = $reqtype;
        }

        for my $pragma (@@pragma) {
            if ($pragma
                &&
                $obj->can($pragma)) {
                $obj->$pragma($meth);
            }
d2128 1
a2128 1
        if (UNIVERSAL::can($obj, 'called_for')) {
d2131 5
a2135 2
        CPAN->debug(qq{pragma[@@pragma]meth[$meth]}.
                    qq{ID[$obj->{ID}]}) if $CPAN::DEBUG;
d2137 1
a2137 20
        push @@qcopy, $obj;
        if ($meth =~ /^(report)$/) { # they came here with a pragma?
            $self->$meth($obj);
        } elsif (! UNIVERSAL::can($obj,$meth)) {
            # Must never happen
            my $serialized = "";
            if (0) {
            } elsif ($CPAN::META->has_inst("YAML::Syck")) {
                $serialized = YAML::Syck::Dump($obj);
            } elsif ($CPAN::META->has_inst("YAML")) {
                $serialized = YAML::Dump($obj);
            } elsif ($CPAN::META->has_inst("Data::Dumper")) {
                $serialized = Data::Dumper::Dumper($obj);
            } else {
                require overload;
                $serialized = overload::StrVal($obj);
            }
            CPAN->debug("Going to panic. meth[$meth]s[$s]") if $CPAN::DEBUG;
            $CPAN::Frontend->mydie("Panic: obj[$serialized] cannot meth[$meth]");
        } elsif ($obj->$meth()) {
a2138 1
            CPAN->debug("From queue deleted. meth[$meth]s[$s]") if $CPAN::DEBUG;
d2140 1
a2140 1
            CPAN->debug("Failed. pragma[@@pragma]meth[$meth]") if $CPAN::DEBUG;
d2144 1
a2144 7
        for my $pragma (@@pragma) {
            my $unpragma = "un$pragma";
            if ($obj->can($unpragma)) {
                $obj->$unpragma();
            }
        }
        CPAN::Queue->delete_first($s);
d2146 2
a2147 4
    if ($meth =~ /^($needs_recursion_protection)$/) {
        for my $obj (@@qcopy) {
            $obj->color_cmd_tmps(0,0);
        }
d2151 20
a2170 133
#-> sub CPAN::Shell::recent ;
sub recent {
  my($self) = @@_;
  if ($CPAN::META->has_inst("XML::LibXML")) {
      my $url = $CPAN::Defaultrecent;
      $CPAN::Frontend->myprint("Going to fetch '$url'\n");
      unless ($CPAN::META->has_usable("LWP")) {
          $CPAN::Frontend->mydie("LWP not installed; cannot continue");
      }
      CPAN::LWP::UserAgent->config;
      my $Ua;
      eval { $Ua = CPAN::LWP::UserAgent->new; };
      if ($@@) {
          $CPAN::Frontend->mydie("CPAN::LWP::UserAgent->new dies with $@@\n");
      }
      my $resp = $Ua->get($url);
      unless ($resp->is_success) {
          $CPAN::Frontend->mydie(sprintf "Could not download '%s': %s\n", $url, $resp->code);
      }
      $CPAN::Frontend->myprint("DONE\n\n");
      my $xml = XML::LibXML->new->parse_string($resp->content);
      if (0) {
          my $s = $xml->serialize(2);
          $s =~ s/\n\s*\n/\n/g;
          $CPAN::Frontend->myprint($s);
          return;
      }
      my @@distros;
      if ($url =~ /winnipeg/) {
          my $pubdate = $xml->findvalue("/rss/channel/pubDate");
          $CPAN::Frontend->myprint("    pubDate: $pubdate\n\n");
          for my $eitem ($xml->findnodes("/rss/channel/item")) {
              my $distro = $eitem->findvalue("enclosure/\@@url");
              $distro =~ s|.*?/authors/id/./../||;
              my $size   = $eitem->findvalue("enclosure/\@@length");
              my $desc   = $eitem->findvalue("description");
               $desc =~ s/.+? - //;
              $CPAN::Frontend->myprint("$distro [$size b]\n    $desc\n");
              push @@distros, $distro;
          }
      } elsif ($url =~ /search.*uploads.rdf/) {
          # xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
          # xmlns="http://purl.org/rss/1.0/"
          # xmlns:taxo="http://purl.org/rss/1.0/modules/taxonomy/"
          # xmlns:dc="http://purl.org/dc/elements/1.1/"
          # xmlns:syn="http://purl.org/rss/1.0/modules/syndication/"
          # xmlns:admin="http://webns.net/mvcb/"


          my $dc_date = $xml->findvalue("//*[local-name(.) = 'RDF']/*[local-name(.) = 'channel']/*[local-name(.) = 'date']");
          $CPAN::Frontend->myprint("    dc:date: $dc_date\n\n");
          my $finish_eitem = 0;
          local $SIG{INT} = sub { $finish_eitem = 1 };
        EITEM: for my $eitem ($xml->findnodes("//*[local-name(.) = 'RDF']/*[local-name(.) = 'item']")) {
              my $distro = $eitem->findvalue("\@@rdf:about");
              $distro =~ s|.*~||; # remove up to the tilde before the name
              $distro =~ s|/$||; # remove trailing slash
              $distro =~ s|([^/]+)|\U$1\E|; # upcase the name
              my $author = uc $1 or die "distro[$distro] without author, cannot continue";
              my $desc   = $eitem->findvalue("*[local-name(.) = 'description']");
              my $i = 0;
            SUBDIRTEST: while () {
                  last SUBDIRTEST if ++$i >= 6; # half a dozen must do!
                  if (my @@ret = $self->globls("$distro*")) {
                      @@ret = grep {$_->[2] !~ /meta/} @@ret;
                      @@ret = grep {length $_->[2]} @@ret;
                      if (@@ret) {
                          $distro = "$author/$ret[0][2]";
                          last SUBDIRTEST;
                      }
                  }
                  $distro =~ s|/|/*/|; # allow it to reside in a subdirectory
              }

              next EITEM if $distro =~ m|\*|; # did not find the thing
              $CPAN::Frontend->myprint("____$desc\n");
              push @@distros, $distro;
              last EITEM if $finish_eitem;
          }
      }
      return \@@distros;
  } else {
      # deprecated old version
      $CPAN::Frontend->mydie("no XML::LibXML installed, cannot continue\n");
  }
}

#-> sub CPAN::Shell::smoke ;
sub smoke {
    my($self) = @@_;
    my $distros = $self->recent;
  DISTRO: for my $distro (@@$distros) {
        $CPAN::Frontend->myprint(sprintf "Going to download and test '$distro'\n");
        {
            my $skip = 0;
            local $SIG{INT} = sub { $skip = 1 };
            for (0..9) {
                $CPAN::Frontend->myprint(sprintf "\r%2d (Hit ^C to skip)", 10-$_);
                sleep 1;
                if ($skip) {
                    $CPAN::Frontend->myprint(" skipped\n");
                    next DISTRO;
                }
            }
        }
        $CPAN::Frontend->myprint("\r  \n"); # leave the dirty line with a newline
        $self->test($distro);
    }
}

{
    # set up the dispatching methods
    no strict "refs";
    for my $command (qw(
                        clean
                        cvs_import
                        dump
                        force
                        fforce
                        get
                        install
                        look
                        ls
                        make
                        notest
                        perldoc
                        readme
                        reports
                        test
                       )) {
        *$command = sub { shift->rematein($command, @@_); };
    }
}
a2172 1
use strict;
d2181 1
a2181 1
        $CPAN::Frontend->mywarn("  LWP::UserAgent not available\n");
d2187 1
d2189 8
a2196 20
        return ($USER, $PASSWD);
    }
    if ( $proxy ) {
        ($USER,$PASSWD) = $self->get_proxy_credentials();
    } else {
        ($USER,$PASSWD) = $self->get_non_proxy_credentials();
    }
    return($USER,$PASSWD);
}

sub get_proxy_credentials {
    my $self = shift;
    my ($user, $password);
    if ( defined $CPAN::Config->{proxy_user} &&
         defined $CPAN::Config->{proxy_pass}) {
        $user = $CPAN::Config->{proxy_user};
        $password = $CPAN::Config->{proxy_pass};
        return ($user, $password);
    }
    my $username_prompt = "\nProxy authentication needed!
d2200 1
a2200 32
     )\nUsername:";
    ($user, $password) =
        _get_username_and_password_from_user($username_prompt);
    return ($user,$password);
}

sub get_non_proxy_credentials {
    my $self = shift;
    my ($user,$password);
    if ( defined $CPAN::Config->{username} &&
         defined $CPAN::Config->{password}) {
        $user = $CPAN::Config->{username};
        $password = $CPAN::Config->{password};
        return ($user, $password);
    }
    my $username_prompt = "\nAuthentication needed!
     (Note: to permanently configure username and password run
       o conf username your_username
       o conf password your_password
     )\nUsername:";

    ($user, $password) =
        _get_username_and_password_from_user($username_prompt);
    return ($user,$password);
}

sub _get_username_and_password_from_user {
    my $username_message = shift;
    my ($username,$password);

    ExtUtils::MakeMaker->import(qw(prompt));
    $username = prompt($username_message);
d2203 2
d2206 1
a2206 7
    else {
        $CPAN::Frontend->mywarn(
            "Warning: Term::ReadKey seems not to be available, your password will be echoed to the terminal!\n"
        );
    }
    $password = prompt("Password:");

d2211 2
a2212 1
    return ($username,$password);
a2229 15
# mirror(): Its purpose is to deal with proxy authentication. When we
# call SUPER::mirror, we relly call the mirror method in
# LWP::UserAgent. LWP::UserAgent will then call
# $self->get_basic_credentials or some equivalent and this will be
# $self->dispatched to our own get_basic_credentials method.

# Our own get_basic_credentials sets $USER and $PASSWD, two globals.

# 407 stands for HTTP_PROXY_AUTHENTICATION_REQUIRED. Which means
# although we have gone through our get_basic_credentials, the proxy
# server refuses to connect. This could be a case where the username or
# password has changed in the meantime, so I'm trying once again without
# $USER and $PASSWD to give the get_basic_credentials routine another
# chance to set $USER and $PASSWD.

a2241 159
use strict;

#-> sub CPAN::FTP::ftp_statistics
# if they want to rewrite, they need to pass in a filehandle
sub _ftp_statistics {
    my($self,$fh) = @@_;
    my $locktype = $fh ? LOCK_EX : LOCK_SH;
    $fh ||= FileHandle->new;
    my $file = File::Spec->catfile($CPAN::Config->{cpan_home},"FTPstats.yml");
    open $fh, "+>>$file" or $CPAN::Frontend->mydie("Could not open '$file': $!");
    my $sleep = 1;
    my $waitstart;
    while (!CPAN::_flock($fh, $locktype|LOCK_NB)) {
        $waitstart ||= localtime();
        if ($sleep>3) {
            $CPAN::Frontend->mywarn("Waiting for a read lock on '$file' (since $waitstart)\n");
        }
        $CPAN::Frontend->mysleep($sleep);
        if ($sleep <= 3) {
            $sleep+=0.33;
        } elsif ($sleep <=6) {
            $sleep+=0.11;
        }
    }
    my $stats = eval { CPAN->_yaml_loadfile($file); };
    if ($@@) {
        if (ref $@@) {
            if (ref $@@ eq "CPAN::Exception::yaml_not_installed") {
                $CPAN::Frontend->myprint("Warning (usually harmless): $@@");
                return;
            } elsif (ref $@@ eq "CPAN::Exception::yaml_process_error") {
                $CPAN::Frontend->mydie($@@);
            }
        } else {
            $CPAN::Frontend->mydie($@@);
        }
    }
    return $stats->[0];
}

#-> sub CPAN::FTP::_mytime
sub _mytime () {
    if (CPAN->has_inst("Time::HiRes")) {
        return Time::HiRes::time();
    } else {
        return time;
    }
}

#-> sub CPAN::FTP::_new_stats
sub _new_stats {
    my($self,$file) = @@_;
    my $ret = {
               file => $file,
               attempts => [],
               start => _mytime,
              };
    $ret;
}

#-> sub CPAN::FTP::_add_to_statistics
sub _add_to_statistics {
    my($self,$stats) = @@_;
    my $yaml_module = CPAN::_yaml_module;
    $self->debug("yaml_module[$yaml_module]") if $CPAN::DEBUG;
    if ($CPAN::META->has_inst($yaml_module)) {
        $stats->{thesiteurl} = $ThesiteURL;
        if (CPAN->has_inst("Time::HiRes")) {
            $stats->{end} = Time::HiRes::time();
        } else {
            $stats->{end} = time;
        }
        my $fh = FileHandle->new;
        my $time = time;
        my $sdebug = 0;
        my @@debug;
        @@debug = $time if $sdebug;
        my $fullstats = $self->_ftp_statistics($fh);
        close $fh;
        $fullstats->{history} ||= [];
        push @@debug, scalar @@{$fullstats->{history}} if $sdebug;
        push @@debug, time if $sdebug;
        push @@{$fullstats->{history}}, $stats;
        # arbitrary hardcoded constants until somebody demands to have
        # them settable; YAML.pm 0.62 is unacceptably slow with 999;
        # YAML::Syck 0.82 has no noticable performance problem with 999;
        while (
               @@{$fullstats->{history}} > 99
               || $time - $fullstats->{history}[0]{start} > 14*86400
              ) {
            shift @@{$fullstats->{history}}
        }
        push @@debug, scalar @@{$fullstats->{history}} if $sdebug;
        push @@debug, time if $sdebug;
        push @@debug, scalar localtime($fullstats->{history}[0]{start}) if $sdebug;
        # need no eval because if this fails, it is serious
        my $sfile = File::Spec->catfile($CPAN::Config->{cpan_home},"FTPstats.yml");
        CPAN->_yaml_dumpfile("$sfile.$$",$fullstats);
        if ( $sdebug ) {
            local $CPAN::DEBUG = 512; # FTP
            push @@debug, time;
            CPAN->debug(sprintf("DEBUG history: before_read[%d]before[%d]at[%d]".
                                "after[%d]at[%d]oldest[%s]dumped backat[%d]",
                                @@debug,
                               ));
        }
        # Win32 cannot rename a file to an existing filename
        unlink($sfile) if ($^O eq 'MSWin32');
        rename "$sfile.$$", $sfile
            or $CPAN::Frontend->mydie("Could not rename '$sfile.$$' to '$sfile': $!\n");
    }
}

# if file is CHECKSUMS, suggest the place where we got the file to be
# checked from, maybe only for young files?
#-> sub CPAN::FTP::_recommend_url_for
sub _recommend_url_for {
    my($self, $file) = @@_;
    my $urllist = $self->_get_urllist;
    if ($file =~ s|/CHECKSUMS(.gz)?$||) {
        my $fullstats = $self->_ftp_statistics();
        my $history = $fullstats->{history} || [];
        while (my $last = pop @@$history) {
            last if $last->{end} - time > 3600; # only young results are interesting
            next unless $last->{file}; # dirname of nothing dies!
            next unless $file eq File::Basename::dirname($last->{file});
            return $last->{thesiteurl};
        }
    }
    if ($CPAN::Config->{randomize_urllist}
        &&
        rand(1) < $CPAN::Config->{randomize_urllist}
       ) {
        $urllist->[int rand scalar @@$urllist];
    } else {
        return ();
    }
}

#-> sub CPAN::FTP::_get_urllist
sub _get_urllist {
    my($self) = @@_;
    $CPAN::Config->{urllist} ||= [];
    unless (ref $CPAN::Config->{urllist} eq 'ARRAY') {
        $CPAN::Frontend->mywarn("Malformed urllist; ignoring.  Configuration file corrupt?\n");
        $CPAN::Config->{urllist} = [];
    }
    my @@urllist = grep { defined $_ and length $_ } @@{$CPAN::Config->{urllist}};
    for my $u (@@urllist) {
        CPAN->debug("u[$u]") if $CPAN::DEBUG;
        if (UNIVERSAL::can($u,"text")) {
            $u->{TEXT} .= "/" unless substr($u->{TEXT},-1) eq "/";
        } else {
            $u .= "/" unless substr($u,-1) eq "/";
            $u = CPAN::URL->new(TEXT => $u, FROM => "USER");
        }
    }
    \@@urllist;
}
d2245 3
a2247 3
    my($class,$host,$dir,$file,$target) = @@_;
    $class->debug(
                  qq[Going to fetch file [$file] from dir [$dir]
d2249 21
a2269 28
                 ) if $CPAN::DEBUG;
    my $ftp = Net::FTP->new($host);
    unless ($ftp) {
        $CPAN::Frontend->mywarn("  Could not connect to host '$host' with Net::FTP\n");
        return;
    }
    return 0 unless defined $ftp;
    $ftp->debug(1) if $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG;
    $class->debug(qq[Going to login("anonymous","$Config::Config{cf_email}")]);
    unless ( $ftp->login("anonymous",$Config::Config{'cf_email'}) ) {
        my $msg = $ftp->message;
        $CPAN::Frontend->mywarn("  Couldn't login on $host: $msg");
        return;
    }
    unless ( $ftp->cwd($dir) ) {
        my $msg = $ftp->message;
        $CPAN::Frontend->mywarn("  Couldn't cwd $dir: $msg");
        return;
    }
    $ftp->binary;
    $class->debug(qq[Going to ->get("$file","$target")\n]) if $CPAN::DEBUG;
    unless ( $ftp->get($file,$target) ) {
        my $msg = $ftp->message;
        $CPAN::Frontend->mywarn("  Couldn't fetch $file from $host: $msg");
        return;
    }
    $ftp->quit; # it's ok if this fails
    return 1;
d2305 1
a2305 1
        unless defined $aslocal;
d2307 1
a2307 1
        if $CPAN::DEBUG;
d2333 5
a2337 16
    if (-f $aslocal && -r _ && !($force & 1)) {
        my $size;
        if ($size = -s $aslocal) {
            $self->debug("aslocal[$aslocal]size[$size]") if $CPAN::DEBUG;
            return $aslocal;
        } else {
            # empty file from a previous unsuccessful attempt to download it
            unlink $aslocal or
                $CPAN::Frontend->mydie("Found a zero-length '$aslocal' that I ".
                                       "could not remove.");
        }
    }
    my($maybe_restore) = 0;
    if (-f $aslocal) {
        rename $aslocal, "$aslocal.bak$$";
        $maybe_restore++;
d2341 6
a2346 1
    $self->mymkpath($aslocal_dir); # too early for file URLs / RT #28438
d2349 1
a2349 1
        unless ($Ua) {
d2351 1
a2351 1
            eval {$Ua = CPAN::LWP::UserAgent->new;}; # Why is has_usable still not fit enough?
d2361 14
d2378 1
a2378 1
        }
d2387 5
a2391 2
    my $ccurllist = $self->_get_urllist;
    $last = $#$ccurllist;
d2393 1
a2393 1
        @@reordered = (0..$last);
d2395 12
a2406 12
        @@reordered =
            sort {
                (substr($ccurllist->[$b],0,4) eq "file")
                    <=>
                (substr($ccurllist->[$a],0,4) eq "file")
                    or
                defined($ThesiteURL)
                    and
                ($ccurllist->[$b] eq $ThesiteURL)
                    <=>
                ($ccurllist->[$a] eq $ThesiteURL)
            } 0..$last;
a2408 13
    $Themethod ||= "";
    $self->debug("Themethod[$Themethod]reordered[@@reordered]") if $CPAN::DEBUG;
    my @@all_levels = (
                      ["dleasy",   "file"],
                      ["dleasy"],
                      ["dlhard"],
                      ["dlhardest"],
                      ["dleasy",   "http","defaultsites"],
                      ["dlhard",   "http","defaultsites"],
                      ["dleasy",   "ftp", "defaultsites"],
                      ["dlhard",   "ftp", "defaultsites"],
                      ["dlhardest","",    "defaultsites"],
                     );
d2410 1
a2410 2
        @@levels = grep {$_->[0] eq $Themethod} @@all_levels;
        push @@levels, grep {$_->[0] ne $Themethod} @@all_levels;
d2412 1
a2412 1
        @@levels = @@all_levels;
d2414 1
a2414 1
    @@levels = qw/dleasy/ if $^O eq 'MacOS';
d2416 38
a2453 14
    local $ENV{FTP_PASSIVE} =
        exists $CPAN::Config->{ftp_passive} ?
        $CPAN::Config->{ftp_passive} : 1;
    my $ret;
    my $stats = $self->_new_stats($file);
  LEVEL: for $levelno (0..$#levels) {
        my $level_tuple = $levels[$levelno];
        my($level,$scheme,$sitetag) = @@$level_tuple;
        my $defaultsites = $sitetag && $sitetag eq "defaultsites";
        my @@urllist;
        if ($defaultsites) {
            unless (defined $connect_to_internet_ok) {
                $CPAN::Frontend->myprint(sprintf qq{
I would like to connect to one of the following sites to get '%s':
d2455 21
a2475 136
%s
},
                                         $file,
                                         join("",map { " ".$_->text."\n" } @@CPAN::Defaultsites),
                                        );
                my $answer = CPAN::Shell::colorable_makemaker_prompt("Is it OK to try to connect to the Internet?", "yes");
                if ($answer =~ /^y/i) {
                    $connect_to_internet_ok = 1;
                } else {
                    $connect_to_internet_ok = 0;
                }
            }
            if ($connect_to_internet_ok) {
                @@urllist = @@CPAN::Defaultsites;
            } else {
                @@urllist = ();
            }
        } else {
            my @@host_seq = $level =~ /dleasy/ ?
                @@reordered : 0..$last;  # reordered has file and $Thesiteurl first
            @@urllist = map { $ccurllist->[$_] } @@host_seq;
        }
        $self->debug("synth. urllist[@@urllist]") if $CPAN::DEBUG;
        my $aslocal_tempfile = $aslocal . ".tmp" . $$;
        if (my $recommend = $self->_recommend_url_for($file)) {
            @@urllist = grep { $_ ne $recommend } @@urllist;
            unshift @@urllist, $recommend;
        }
        $self->debug("synth. urllist[@@urllist]") if $CPAN::DEBUG;
        $ret = $self->hostdlxxx($level,$scheme,\@@urllist,$file,$aslocal_tempfile,$stats);
        if ($ret) {
            CPAN->debug("ret[$ret]aslocal[$aslocal]") if $CPAN::DEBUG;
            if ($ret eq $aslocal_tempfile) {
                # if we got it exactly as we asked for, only then we
                # want to rename
                rename $aslocal_tempfile, $aslocal
                    or $CPAN::Frontend->mydie("Error while trying to rename ".
                                              "'$ret' to '$aslocal': $!");
                $ret = $aslocal;
            }
            $Themethod = $level;
            my $now = time;
            # utime $now, $now, $aslocal; # too bad, if we do that, we
                                          # might alter a local mirror
            $self->debug("level[$level]") if $CPAN::DEBUG;
            last LEVEL;
        } else {
            unlink $aslocal_tempfile;
            last if $CPAN::Signal; # need to cleanup
        }
    }
    if ($ret) {
        $stats->{filesize} = -s $ret;
    }
    $self->debug("before _add_to_statistics") if $CPAN::DEBUG;
    $self->_add_to_statistics($stats);
    $self->debug("after _add_to_statistics") if $CPAN::DEBUG;
    if ($ret) {
        unlink "$aslocal.bak$$";
        return $ret;
    }
    unless ($CPAN::Signal) {
        my(@@mess);
        local $" = " ";
        if (@@{$CPAN::Config->{urllist}}) {
            push @@mess,
                qq{Please check, if the URLs I found in your configuration file \(}.
                    join(", ", @@{$CPAN::Config->{urllist}}).
                        qq{\) are valid.};
        } else {
            push @@mess, qq{Your urllist is empty!};
        }
        push @@mess, qq{The urllist can be edited.},
            qq{E.g. with 'o conf urllist push ftp://myurl/'};
        $CPAN::Frontend->mywarn(Text::Wrap::wrap("","","@@mess"). "\n\n");
        $CPAN::Frontend->mywarn("Could not fetch $file\n");
        $CPAN::Frontend->mysleep(2);
    }
    if ($maybe_restore) {
        rename "$aslocal.bak$$", $aslocal;
        $CPAN::Frontend->myprint("Trying to get away with old file:\n" .
                                 $self->ls($aslocal));
        return $aslocal;
    }
    return;
}

sub mymkpath {
    my($self, $aslocal_dir) = @@_;
    File::Path::mkpath($aslocal_dir);
    $CPAN::Frontend->mywarn(qq{Warning: You are not allowed to write into }.
                            qq{directory "$aslocal_dir".
    I\'ll continue, but if you encounter problems, they may be due
    to insufficient permissions.\n}) unless -w $aslocal_dir;
}

sub hostdlxxx {
    my $self = shift;
    my $level = shift;
    my $scheme = shift;
    my $h = shift;
    $h = [ grep /^\Q$scheme\E:/, @@$h ] if $scheme;
    my $method = "host$level";
    $self->$method($h, @@_);
}

sub _set_attempt {
    my($self,$stats,$method,$url) = @@_;
    push @@{$stats->{attempts}}, {
                                 method => $method,
                                 start => _mytime,
                                 url => $url,
                                };
}

# package CPAN::FTP;
sub hostdleasy {
    my($self,$host_seq,$file,$aslocal,$stats) = @@_;
    my($ro_url);
  HOSTEASY: for $ro_url (@@$host_seq) {
        $self->_set_attempt($stats,"dleasy",$ro_url);
        my $url .= "$ro_url$file";
        $self->debug("localizing perlish[$url]") if $CPAN::DEBUG;
        if ($url =~ /^file:/) {
            my $l;
            if ($CPAN::META->has_inst('URI::URL')) {
                my $u =  URI::URL->new($url);
                $l = $u->path;
            } else { # works only on Unix, is poorly constructed, but
                # hopefully better than nothing.
                # RFC 1738 says fileurl BNF is
                # fileurl = "file://" [ host | "localhost" ] "/" fpath
                # Thanks to "Mark D. Baushke" <mdb@@cisco.com> for
                # the code
                ($l = $url) =~ s|^file://[^/]*/|/|; # discard the host part
                $l =~ s|^file:||;                   # assume they
d2478 17
a2494 27
                $l =~ s|^/||s
                    if ! -f $l && $l =~ m|^/\w:|;   # e.g. /P:
            }
            $self->debug("local file[$l]") if $CPAN::DEBUG;
            if ( -f $l && -r _) {
                $ThesiteURL = $ro_url;
                return $l;
            }
            if ($l =~ /(.+)\.gz$/) {
                my $ungz = $1;
                if ( -f $ungz && -r _) {
                    $ThesiteURL = $ro_url;
                    return $ungz;
                }
            }
            # Maybe mirror has compressed it?
            if (-f "$l.gz") {
                $self->debug("found compressed $l.gz") if $CPAN::DEBUG;
                eval { CPAN::Tarzip->new("$l.gz")->gunzip($aslocal) };
                if ( -f $aslocal) {
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                }
            }
            $CPAN::Frontend->mywarn("Could not find '$l'\n");
        }
        $self->debug("it was not a file URL") if $CPAN::DEBUG;
d2496 1
a2496 1
            $CPAN::Frontend->myprint("Fetching with LWP:
d2499 17
a2515 18
            unless ($Ua) {
                CPAN::LWP::UserAgent->config;
                eval { $Ua = CPAN::LWP::UserAgent->new; };
                if ($@@) {
                    $CPAN::Frontend->mywarn("CPAN::LWP::UserAgent->new dies with $@@\n");
                }
            }
            my $res = $Ua->mirror($url, $aslocal);
            if ($res->is_success) {
                $ThesiteURL = $ro_url;
                my $now = time;
                utime $now, $now, $aslocal; # download time is more
                                            # important than upload
                                            # time
                return $aslocal;
            } elsif ($url !~ /\.gz(?!\n)\Z/) {
                my $gzurl = "$url.gz";
                $CPAN::Frontend->myprint("Fetching with LWP:
d2518 20
a2537 20
                $res = $Ua->mirror($gzurl, "$aslocal.gz");
                if ($res->is_success) {
                    if (eval {CPAN::Tarzip->new("$aslocal.gz")->gunzip($aslocal)}) {
                        $ThesiteURL = $ro_url;
                        return $aslocal;
                    }
                }
            } else {
                $CPAN::Frontend->myprint(sprintf(
                                                 "LWP failed with code[%s] message[%s]\n",
                                                 $res->code,
                                                 $res->message,
                                                ));
                # Alan Burlison informed me that in firewall environments
                # Net::FTP can still succeed where LWP fails. So we do not
                # skip Net::FTP anymore when LWP is available.
            }
        } else {
            $CPAN::Frontend->mywarn("  LWP not available\n");
        }
d2539 6
a2544 7
        if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
            # that's the nice and easy way thanks to Graham
            $self->debug("recognized ftp") if $CPAN::DEBUG;
            my($host,$dir,$getfile) = ($1,$2,$3);
            if ($CPAN::META->has_usable('Net::FTP')) {
                $dir =~ s|/+|/|g;
                $CPAN::Frontend->myprint("Fetching with Net::FTP:
d2547 9
a2555 9
                $self->debug("getfile[$getfile]dir[$dir]host[$host]" .
                             "aslocal[$aslocal]") if $CPAN::DEBUG;
                if (CPAN::FTP->ftp_get($host,$dir,$getfile,$aslocal)) {
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                }
                if ($aslocal !~ /\.gz(?!\n)\Z/) {
                    my $gz = "$aslocal.gz";
                    $CPAN::Frontend->myprint("Fetching with Net::FTP
d2558 13
a2570 25
                    if (CPAN::FTP->ftp_get($host,
                                           $dir,
                                           "$getfile.gz",
                                           $gz) &&
                        eval{CPAN::Tarzip->new($gz)->gunzip($aslocal)}
                    ) {
                        $ThesiteURL = $ro_url;
                        return $aslocal;
                    }
                }
                # next HOSTEASY;
            } else {
                CPAN->debug("Net::FTP does not count as usable atm") if $CPAN::DEBUG;
            }
        }
        if (
            UNIVERSAL::can($ro_url,"text")
            and
            $ro_url->{FROM} eq "USER"
           ) {
            ##address #17973: default URLs should not try to override
            ##user-defined URLs just because LWP is not available
            my $ret = $self->hostdlhard([$ro_url],$file,$aslocal,$stats);
            return $ret if $ret;
        }
d2575 27
a2601 27
# package CPAN::FTP;
sub hostdlhard {
    my($self,$host_seq,$file,$aslocal,$stats) = @@_;

    # Came back if Net::FTP couldn't establish connection (or
    # failed otherwise) Maybe they are behind a firewall, but they
    # gave us a socksified (or other) ftp program...

    my($ro_url);
    my($devnull) = $CPAN::Config->{devnull} || "";
    # < /dev/null ";
    my($aslocal_dir) = File::Basename::dirname($aslocal);
    File::Path::mkpath($aslocal_dir);
  HOSTHARD: for $ro_url (@@$host_seq) {
        $self->_set_attempt($stats,"dlhard",$ro_url);
        my $url = "$ro_url$file";
        my($proto,$host,$dir,$getfile);

        # Courtesy Mark Conty mark_conty@@cargill.com change from
        # if ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
        # to
        if ($url =~ m|^([^:]+)://(.*?)/(.*)/(.*)|) {
            # proto not yet used
            ($proto,$host,$dir,$getfile) = ($1,$2,$3,$4);
        } else {
            next HOSTHARD; # who said, we could ftp anything except ftp?
        }
d2605 26
a2630 33
        $self->debug("localizing funkyftpwise[$url]") if $CPAN::DEBUG;

        # Try the most capable first and leave ncftp* for last as it only
        # does FTP.
      DLPRG: for my $f (qw(curl wget lynx ncftpget ncftp)) {
            my $funkyftp = CPAN::HandleConfig->safe_quote($CPAN::Config->{$f});
            next unless defined $funkyftp;
            next if $funkyftp =~ /^\s*$/;

            my($asl_ungz, $asl_gz);
            ($asl_ungz = $aslocal) =~ s/\.gz//;
                $asl_gz = "$asl_ungz.gz";

            my($src_switch) = "";
            my($chdir) = "";
            my($stdout_redir) = " > $asl_ungz";
            if ($f eq "lynx") {
                $src_switch = " -source";
            } elsif ($f eq "ncftp") {
                $src_switch = " -c";
            } elsif ($f eq "wget") {
                $src_switch = " -O $asl_ungz";
                $stdout_redir = "";
            } elsif ($f eq 'curl') {
                $src_switch = ' -L -f -s -S --netrc-optional';
            }

            if ($f eq "ncftpget") {
                $chdir = "cd $aslocal_dir && ";
                $stdout_redir = "";
            }
            $CPAN::Frontend->myprint(
                                     qq[
d2634 61
a2694 22
            my($system) =
                "$chdir$funkyftp$src_switch \"$url\" $devnull$stdout_redir";
            $self->debug("system[$system]") if $CPAN::DEBUG;
            my($wstatus) = system($system);
            if ($f eq "lynx") {
                # lynx returns 0 when it fails somewhere
                if (-s $asl_ungz) {
                    my $content = do { local *FH;
                                       open FH, $asl_ungz or die;
                                       local $/;
                                       <FH> };
                    if ($content =~ /^<.*(<title>[45]|Error [45])/si) {
                        $CPAN::Frontend->mywarn(qq{
No success, the file that lynx has downloaded looks like an error message:
$content
});
                        $CPAN::Frontend->mysleep(1);
                        next DLPRG;
                    }
                } else {
                    $CPAN::Frontend->myprint(qq{
No success, the file that lynx has downloaded is an empty file.
d2696 3
a2698 59
                    next DLPRG;
                }
            }
            if ($wstatus == 0) {
                if (-s $aslocal) {
                    # Looks good
                } elsif ($asl_ungz ne $aslocal) {
                    # test gzip integrity
                    if (eval{CPAN::Tarzip->new($asl_ungz)->gtest}) {
                        # e.g. foo.tar is gzipped --> foo.tar.gz
                        rename $asl_ungz, $aslocal;
                    } else {
                        eval{CPAN::Tarzip->new($asl_gz)->gzip($asl_ungz)};
                    }
                }
                $ThesiteURL = $ro_url;
                return $aslocal;
            } elsif ($url !~ /\.gz(?!\n)\Z/) {
                unlink $asl_ungz if
                    -f $asl_ungz && -s _ == 0;
                my $gz = "$aslocal.gz";
                my $gzurl = "$url.gz";
                $CPAN::Frontend->myprint(
                                        qq[
    Trying with "$funkyftp$src_switch" to get
    $url.gz
    ]);
                my($system) = "$funkyftp$src_switch \"$url.gz\" $devnull > $asl_gz";
                $self->debug("system[$system]") if $CPAN::DEBUG;
                my($wstatus);
                if (($wstatus = system($system)) == 0
                    &&
                    -s $asl_gz
                ) {
                    # test gzip integrity
                    my $ct = eval{CPAN::Tarzip->new($asl_gz)};
                    if ($ct && $ct->gtest) {
                        $ct->gunzip($aslocal);
                    } else {
                        # somebody uncompressed file for us?
                        rename $asl_ungz, $aslocal;
                    }
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                } else {
                    unlink $asl_gz if -f $asl_gz;
                }
            } else {
                my $estatus = $wstatus >> 8;
                my $size = -f $aslocal ?
                    ", left\n$aslocal with size ".-s _ :
                    "\nWarning: expected file [$aslocal] doesn't exist";
                $CPAN::Frontend->myprint(qq{
    System call "$system"
    returned status $estatus (wstat $wstatus)$size
    });
            }
            return if $CPAN::Signal;
        } # transfer programs
d2702 2
a2703 3
# package CPAN::FTP;
sub hostdlhardest {
    my($self,$host_seq,$file,$aslocal,$stats) = @@_;
d2705 1
a2705 2
    return unless @@$host_seq;
    my($ro_url);
d2709 39
a2747 61
    unless ($ftpbin && length $ftpbin && MM->maybe_command($ftpbin)) {
        $CPAN::Frontend->myprint("No external ftp command available\n\n");
        return;
    }
    $CPAN::Frontend->mywarn(qq{
As a last ressort we now switch to the external ftp command '$ftpbin'
to get '$aslocal'.

Doing so often leads to problems that are hard to diagnose.

If you're victim of such problems, please consider unsetting the ftp
config variable with

    o conf ftp ""
    o conf commit

});
    $CPAN::Frontend->mysleep(2);
  HOSTHARDEST: for $ro_url (@@$host_seq) {
        $self->_set_attempt($stats,"dlhardest",$ro_url);
        my $url = "$ro_url$file";
        $self->debug("localizing ftpwise[$url]") if $CPAN::DEBUG;
        unless ($url =~ m|^ftp://(.*?)/(.*)/(.*)|) {
            next;
        }
        my($host,$dir,$getfile) = ($1,$2,$3);
        my $timestamp = 0;
        my($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,
            $ctime,$blksize,$blocks) = stat($aslocal);
        $timestamp = $mtime ||= 0;
        my($netrc) = CPAN::FTP::netrc->new;
        my($netrcfile) = $netrc->netrc;
        my($verbose) = $CPAN::DEBUG{'FTP'} & $CPAN::DEBUG ? " -v" : "";
        my $targetfile = File::Basename::basename($aslocal);
        my(@@dialog);
        push(
             @@dialog,
             "lcd $aslocal_dir",
             "cd /",
             map("cd $_", split /\//, $dir), # RFC 1738
             "bin",
             "get $getfile $targetfile",
             "quit"
        );
        if (! $netrcfile) {
            CPAN->debug("No ~/.netrc file found") if $CPAN::DEBUG;
        } elsif ($netrc->hasdefault || $netrc->contains($host)) {
            CPAN->debug(sprintf("hasdef[%d]cont($host)[%d]",
                                $netrc->hasdefault,
                                $netrc->contains($host))) if $CPAN::DEBUG;
            if ($netrc->protected) {
                my $dialog = join "", map { "    $_\n" } @@dialog;
                my $netrc_explain;
                if ($netrc->contains($host)) {
                    $netrc_explain = "Relying that your .netrc entry for '$host' ".
                        "manages the login";
                } else {
                    $netrc_explain = "Relying that your default .netrc entry ".
                        "manages the login";
                }
                $CPAN::Frontend->myprint(qq{
d2750 24
a2773 24
  $netrc_explain
  Going to send the dialog
$dialog
}
                );
                $self->talk_ftp("$ftpbin$verbose $host",
                                @@dialog);
                ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
                    $atime,$mtime,$ctime,$blksize,$blocks) = stat($aslocal);
                $mtime ||= 0;
                if ($mtime > $timestamp) {
                    $CPAN::Frontend->myprint("GOT $aslocal\n");
                    $ThesiteURL = $ro_url;
                    return $aslocal;
                } else {
                    $CPAN::Frontend->myprint("Hmm... Still failed!\n");
                }
                    return if $CPAN::Signal;
            } else {
                $CPAN::Frontend->mywarn(qq{Your $netrcfile is not }.
                                        qq{correctly protected.\n});
            }
        } else {
            $CPAN::Frontend->mywarn("Your ~/.netrc neither contains $host
d2775 1
a2775 1
        }
d2777 20
a2796 28
        # OK, they don't have a valid ~/.netrc. Use 'ftp -n'
        # then and login manually to host, using e-mail as
        # password.
        $CPAN::Frontend->myprint(qq{Issuing "$ftpbin$verbose -n"\n});
        unshift(
                @@dialog,
                "open $host",
                "user anonymous $Config::Config{'cf_email'}"
        );
        my $dialog = join "", map { "    $_\n" } @@dialog;
        $CPAN::Frontend->myprint(qq{
  Trying with external ftp to get
    $url
  Going to send the dialog
$dialog
}
        );
        $self->talk_ftp("$ftpbin$verbose -n", @@dialog);
        ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
            $atime,$mtime,$ctime,$blksize,$blocks) = stat($aslocal);
        $mtime ||= 0;
        if ($mtime > $timestamp) {
            $CPAN::Frontend->myprint("GOT $aslocal\n");
            $ThesiteURL = $ro_url;
            return $aslocal;
        } else {
            $CPAN::Frontend->myprint("Bad luck... Still failed!\n");
        }
d2798 2
a2799 2
        $CPAN::Frontend->mywarn("Can't access URL $url.\n\n");
        $CPAN::Frontend->mysleep(2);
a2802 1
# package CPAN::FTP;
d2808 1
a2808 1
    $fh->close; # Wait for process to complete
d2829 1
a2829 1
        $blocks = int(($blocks + 1) / 2);
d2832 1
a2832 1
        $blocks = int(($sizemm + 1023) / 1024);
d2863 1
a2863 1
        $timeyear = $year + 1900;
d2866 1
a2866 1
        $timeyear = sprintf("%02d:%02d", $hour, $min);
d2870 11
a2880 11
             $ino,
                  $blocks,
                       $perms,
                             $nlink,
                                 $user,
                                      $group,
                                           $sizemm,
                                               $moname,
                                                  $mday,
                                                      $timeyear,
                                                          $pname;
a2883 1
use strict;
a2884 1
# package CPAN::FTP::netrc;
d2887 1
a2887 2
    my $home = CPAN::HandleConfig::home;
    my $file = File::Spec->catfile($home,".netrc");
d2891 1
a2891 1
        = stat($file);
d2899 3
a2901 3
    if($fh->open($file)) {
        $protected = ($mode & 077) == 0;
        local($/) = "";
d2903 13
a2915 13
            my(@@tokens) = split " ", $_;
          TOKEN: while (@@tokens) {
                my($t) = shift @@tokens;
                if ($t eq "default") {
                    $hasdefault++;
                    last NETRC;
                }
                last TOKEN if $t eq "macdef";
                if ($t eq "machine") {
                    push @@machines, shift @@tokens;
                }
            }
        }
d2917 1
a2917 1
        $file = $hasdefault = $protected = "";
d2921 5
a2925 5
        'mach' => [@@machines],
        'netrc' => $file,
        'hasdefault' => $hasdefault,
        'protected' => $protected,
    }, $class;
d2928 1
a2928 1
# CPAN::FTP::netrc::hasdefault;
d2935 1
a2935 1
        return 1 if $_ eq $mach;
a2940 1
use strict;
d2950 9
a2958 9
        last unless length($perlret[0]) && length($perlret[0]) >= $i;
        my $try = substr($perlret[0],0,$i);
        my @@tries = grep {substr($_,0,$i) eq $try} @@perlret;
        # warn "try[$try]tries[@@tries]";
        if (@@tries == @@perlret) {
            $newtext = $try;
        } else {
            last;
        }
d2971 2
a2972 2
    if ($line =~ s/^((?:notest|f?force)\s*)//) {
        $pos -= length($1);
d2975 2
a2976 2
    if ($pos == 0 || $line =~ /^(?:h(?:elp)?|\?)\s/) {
        @@return = grep /^\Q$word\E/, @@CPAN::Complete::COMMANDS;
d2978 1
a2978 1
        @@return = ();
d2980 1
a2980 1
        @@return = cplx('CPAN::Author',uc($word));
d2983 1
a2983 1
        @@return = cplx('CPAN::Bundle',$word);
d2985 1
a2985 1
        @@return = cplx('CPAN::Distribution',$word);
d2987 1
a2987 1
                          [mru]|make|clean|dump|get|test|install|readme|look|cvs_import|perldoc|recent
d2992 1
a2992 1
        @@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
d2994 1
a2994 1
        @@return = cpl_any($word);
d2996 1
a2996 1
        @@return = cpl_reload($word,$line,$pos);
d2998 1
a2998 1
        @@return = cpl_option($word,$line,$pos);
d3001 1
a3001 1
        @@return = (cplx('CPAN::Module',$word),cplx('CPAN::Bundle',$word));
d3003 1
a3003 1
        @@return = ();
d3011 4
a3014 3
    if (CPAN::_sqlite_running) {
        $CPAN::SQLite->search($class, "^\Q$word\E");
    }
d3022 5
a3026 5
            cplx('CPAN::Author',$word),
            cplx('CPAN::Bundle',$word),
            cplx('CPAN::Distribution',$word),
            cplx('CPAN::Module',$word),
           );
d3051 1
a3051 1
        return ();
d3053 1
a3053 1
        return CPAN::HandleConfig::cpl(@@_);
d3055 1
a3055 2
        return sort grep /^\Q$word\E/i,
            sort keys %CPAN::DEBUG, 'all';
a3059 1
use strict;
d3070 1
a3070 1
    my($self,$force) = @@_;
d3076 1
a3076 1
        $_ = 0.001 unless $_ && $_ > 0.001;
d3084 1
a3084 1
        $self->read_metadata_cache;
d3091 3
a3093 5
    if ($LAST_TIME + $CPAN::Config->{index_expire}*86400 > $time
        and ! $force) {
        # called too often
        # CPAN->debug("LAST_TIME[$LAST_TIME]index_expire[$CPAN::Config->{index_expire}]time[$time]");
    } elsif (0) {
d3098 2
a3099 1
    } else {
d3106 1
a3106 1
        $self->rd_authindex($self
d3117 1
a3117 1
        $self->rd_modpacks($self
d3128 1
a3128 1
        $self->rd_modlist($self
d3135 1
a3135 1
        $self->write_metadata_cache;
a3140 7
    if ($CPAN::Config->{build_dir_reuse}) {
        $self->reanimate_build_dir;
    }
    if (CPAN::_sqlite_running) {
        $CPAN::SQLite->reload(time => $time, force => $force)
            if not $LAST_TIME;
    }
a3144 88
#-> sub CPAN::Index::reanimate_build_dir ;
sub reanimate_build_dir {
    my($self) = @@_;
    unless ($CPAN::META->has_inst($CPAN::Config->{yaml_module}||"YAML")) {
        return;
    }
    return if $HAVE_REANIMATED++;
    my $d = $CPAN::Config->{build_dir};
    my $dh = DirHandle->new;
    opendir $dh, $d or return; # does not exist
    my $dirent;
    my $i = 0;
    my $painted = 0;
    my $restored = 0;
    $CPAN::Frontend->myprint("Going to read $CPAN::Config->{build_dir}/\n");
    my @@candidates = map { $_->[0] }
        sort { $b->[1] <=> $a->[1] }
            map { [ $_, -M File::Spec->catfile($d,$_) ] }
                grep {/\.yml$/} readdir $dh;
  DISTRO: for $i (0..$#candidates) {
        my $dirent = $candidates[$i];
        my $y = eval {CPAN->_yaml_loadfile(File::Spec->catfile($d,$dirent))};
        if ($@@) {
            warn "Error while parsing file '$dirent'; error: '$@@'";
            next DISTRO;
        }
        my $c = $y->[0];
        if ($c && CPAN->_perl_fingerprint($c->{perl})) {
            my $key = $c->{distribution}{ID};
            for my $k (keys %{$c->{distribution}}) {
                if ($c->{distribution}{$k}
                    && ref $c->{distribution}{$k}
                    && UNIVERSAL::isa($c->{distribution}{$k},"CPAN::Distrostatus")) {
                    $c->{distribution}{$k}{COMMANDID} = $i - @@candidates;
                }
            }

            #we tried to restore only if element already
            #exists; but then we do not work with metadata
            #turned off.
            my $do
                = $CPAN::META->{readwrite}{'CPAN::Distribution'}{$key}
                    = $c->{distribution};
            for my $skipper (qw(
                                badtestcnt
                                configure_requires_later
                                configure_requires_later_for
                                force_update
                                later
                                later_for
                                notest
                                should_report
                                sponsored_mods
                               )) {
                delete $do->{$skipper};
            }
            # $DB::single = 1;
            if ($do->{make_test}
                && $do->{build_dir}
                && !(UNIVERSAL::can($do->{make_test},"failed") ?
                     $do->{make_test}->failed :
                     $do->{make_test} =~ /^YES/
                    )
                && (
                    !$do->{install}
                    ||
                    $do->{install}->failed
                   )
               ) {
                $CPAN::META->is_tested($do->{build_dir},$do->{make_test}{TIME});
            }
            $restored++;
        }
        $i++;
        while (($painted/76) < ($i/@@candidates)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
    }
    $CPAN::Frontend->myprint(sprintf(
                                     "DONE\nFound %s old build%s, restored the state of %s\n",
                                     @@candidates ? sprintf("%d",scalar @@candidates) : "no",
                                     @@candidates==1 ? "" : "s",
                                     $restored || "none",
                                    ));
}


d3149 2
a3150 2
    CPAN::HandleConfig->load; # we should guarantee loading wherever
                              # we rely on Config XXX
d3153 1
a3153 1
                                         $localname);
d3155 3
a3157 3
        -f $abs_wanted &&
        -M $abs_wanted < $CPAN::Config->{'index_expire'} &&
        !($force & 1)
d3159 4
a3162 4
        my $s = $CPAN::Config->{'index_expire'} == 1 ? "" : "s";
        $cl->debug(qq{$abs_wanted younger than $CPAN::Config->{'index_expire'} }.
                   qq{day$s. I\'ll use that.});
        return $abs_wanted;
d3164 1
a3164 1
        $force |= 1; # means we're quite serious about it.
d3172 1
a3173 2
    return if CPAN::_sqlite_running;
    my @@lines;
d3176 1
a3176 1
    tie *FH, 'CPAN::Tarzip', $index_target;
a3177 1
    local($_);
a3178 2
    my $i = 0;
    my $painted = 0;
d3180 8
a3187 15
        my($userid,$fullname,$email) =
            m/alias\s+(\S+)\s+\"([^\"\<]*)\s+\<(.*)\>\"/;
        $fullname ||= $email;
        if ($userid && $fullname && $email) {
            my $userobj = $CPAN::META->instance('CPAN::Author',$userid);
            $userobj->set('FULLNAME' => $fullname, 'EMAIL' => $email);
        } else {
            CPAN->debug(sprintf "line[%s]", $_) if $CPAN::DEBUG;
        }
        $i++;
        while (($painted/76) < ($i/@@lines)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
        return if $CPAN::Signal;
a3188 1
    $CPAN::Frontend->myprint("DONE\n");
d3201 1
a3202 1
    return if CPAN::_sqlite_running;
d3205 6
a3210 6
    local $_;
    CPAN->debug(sprintf "start[%d]", time) if $CPAN::DEBUG;
    my $slurp = "";
    my $chunk;
    while (my $bytes = $fh->READ(\$chunk,8192)) {
        $slurp.=$chunk;
a3211 3
    my @@lines = split /\012/, $slurp;
    CPAN->debug(sprintf "end[%d]", time) if $CPAN::DEBUG;
    undef $fh;
d3215 3
a3217 3
        my $shift = shift(@@lines);
        last if $shift =~ /^\s*$/;
        $shift =~ /^Line-Count:\s+(\d+)/ and $line_count = $1;
a3219 1
    CPAN->debug("line_count[$line_count]last_updated[$last_updated]") if $CPAN::DEBUG;
d3222 1
a3222 1
        $CPAN::Frontend->mywarn(qq{Warning: Your $index_target does not contain a Line-Count header.
d3226 1
a3226 1
});
d3228 1
a3228 1
        $CPAN::Frontend->mysleep(5);
d3231 1
a3231 1
        $CPAN::Frontend->mywarn(sprintf qq{Warning: Your %s
d3235 1
a3235 1
$index_target, $line_count, scalar(@@lines));
d3240 1
a3240 1
        $CPAN::Frontend->mywarn(qq{Warning: Your $index_target does not contain a Last-Updated header.
d3244 1
a3244 1
});
d3246 1
a3246 1
        $CPAN::Frontend->mysleep(5);
d3249 1
a3249 1
        $CPAN::Frontend
d3254 1
a3254 2
        my $age = time;
        if ($CPAN::META->has_inst('HTTP::Date')) {
d3256 6
a3261 14
            $age -= HTTP::Date::str2time($last_updated);
        } else {
            $CPAN::Frontend->mywarn("  HTTP::Date not available\n");
            require Time::Local;
            my(@@d) = $last_updated =~ / (\d+) (\w+) (\d+) (\d+):(\d+):(\d+) /;
            $d[1] = index("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec", $d[1])/4;
            $age -= $d[1]>=0 ? Time::Local::timegm(@@d[5,4,3,0,1,2]) : 0;
        }
        $age /= 3600*24;
        if ($age > 30) {

            $CPAN::Frontend
                ->mywarn(sprintf
                         qq{Warning: This index file is %d days old.
d3264 1
a3264 14
                         $age);

        } elsif ($age < -1) {

            $CPAN::Frontend
                ->mywarn(sprintf
                         qq{Warning: Your system date is %d days behind this index file!
  System time:          %s
  Timestamp index file: %s
  Please fix your system time, problems with the make command expected.\n},
                         -$age,
                         scalar gmtime,
                         $DATE_OF_02,
                        );
d3266 3
a3277 2
    my $i = 0;
    my $painted = 0;
d3279 1
d3283 2
a3284 2
        my($mod,$version,$dist,$comment) = split " ", $_, 4;
        my($bundle,$id,$userid);
d3286 6
a3291 6
        if ($mod eq 'CPAN' &&
            ! (
            CPAN::Queue->exists('Bundle::CPAN') ||
            CPAN::Queue->exists('CPAN')
            )
        ) {
d3293 4
a3296 4
            if ($version > $CPAN::VERSION) {
                $CPAN::Frontend->mywarn(qq{
  New CPAN.pm version (v$version) available.
  [Currently running version is v$CPAN::VERSION]
d3298 1
a3298 1
    install CPAN
d3300 2
a3301 3
  to both upgrade CPAN.pm and run the new version without leaving
  the current session.

d3303 12
a3314 12
                $CPAN::Frontend->mysleep(2);
                $CPAN::Frontend->myprint(qq{\n});
            }
            last if $CPAN::Signal;
        } elsif ($mod =~ /^Bundle::(.*)/) {
            $bundle = $1;
        }

        if ($bundle) {
            $id =  $CPAN::META->instance('CPAN::Bundle',$mod);
            # Let's make it a module too, because bundles have so much
            # in common with modules.
d3319 1
a3319 1
            # $CPAN::META->instance('CPAN::Module',$mod);
d3321 1
a3321 1
        } else {
d3323 2
a3324 2
            # instantiate a module object
            $id = $CPAN::META->instance('CPAN::Module',$mod);
d3326 1
a3326 1
        }
d3328 28
a3355 32
        # Although CPAN prohibits same name with different version the
        # indexer may have changed the version for the same distro
        # since the last time ("Force Reindexing" feature)
        if ($id->cpan_file ne $dist
            ||
            $id->cpan_version ne $version
           ) {
            $userid = $id->userid || $self->userid($dist);
            $id->set(
                     'CPAN_USERID' => $userid,
                     'CPAN_VERSION' => $version,
                     'CPAN_FILE' => $dist,
                    );
        }

        # instantiate a distribution object
        if ($CPAN::META->exists('CPAN::Distribution',$dist)) {
        # we do not need CONTAINSMODS unless we do something with
        # this dist, so we better produce it on demand.

        ## my $obj = $CPAN::META->instance(
        ##                                 'CPAN::Distribution' => $dist
        ##                                );
        ## $obj->{CONTAINSMODS}{$mod} = undef; # experimental
        } else {
            $CPAN::META->instance(
                                  'CPAN::Distribution' => $dist
                                 )->set(
                                        'CPAN_USERID' => $userid,
                                        'CPAN_COMMENT' => $comment,
                                       );
        }
d3358 1
a3358 1
                # $self->debug("exists name[$name]") if $CPAN::DEBUG;
d3362 1
a3362 6
        $i++;
        while (($painted/76) < ($i/@@lines)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
        return if $CPAN::Signal;
d3364 1
a3364 1
    $CPAN::Frontend->myprint("DONE\n");
d3370 2
a3371 2
                # CPAN->debug("deleting ID[$o->{ID}] in class[$class]")
                #     if $CPAN::DEBUG;
a3380 1
    return if CPAN::_sqlite_running;
d3383 15
a3397 18
    local $_;
    my $slurp = "";
    my $chunk;
    while (my $bytes = $fh->READ(\$chunk,8192)) {
        $slurp.=$chunk;
    }
    my @@eval2 = split /\012/, $slurp;

    while (@@eval2) {
        my $shift = shift(@@eval2);
        if ($shift =~ /^Date:\s+(.*)/) {
            if ($DATE_OF_03 eq $1) {
                $CPAN::Frontend->myprint("Unchanged.\n");
                return;
            }
            ($DATE_OF_03) = $1;
        }
        last if $shift =~ /^\s*$/;
d3399 2
a3400 1
    push @@eval2, q{CPAN::Modulelist->data;};
d3403 2
a3404 3
    my($eval2) = join("\n", @@eval2);
    CPAN->debug(sprintf "length of eval2[%d]", length $eval2) if $CPAN::DEBUG;
    my $ret = $comp->reval($eval2);
a3406 4
    my $i = 0;
    my $until = keys(%$ret);
    my $painted = 0;
    CPAN->debug(sprintf "until[%d]", $until) if $CPAN::DEBUG;
d3408 1
a3408 1
        my $obj = $CPAN::META->instance("CPAN::Module",$_);
d3410 2
a3411 7
        $obj->set(%{$ret->{$_}});
        $i++;
        while (($painted/76) < ($i/$until)) {
            $CPAN::Frontend->myprint(".");
            $painted++;
        }
        return if $CPAN::Signal;
a3412 1
    $CPAN::Frontend->myprint("DONE\n");
a3418 1
    return if CPAN::_sqlite_running;
d3422 2
a3423 2
                      CPAN::Distribution)) {
        $cache->{$k} = $CPAN::META->{readonly}{$k}; # unsafe meta access, ok
a3437 1
    return if CPAN::_sqlite_running;
d3445 1
a3445 1
    if (!$cache || !UNIVERSAL::isa($cache, 'HASH')) {
d3466 2
a3467 2
        next unless $class =~ /^CPAN::/;
        $CPAN::META->{readonly}{$class} = $v; # unsafe meta access, ok
d3490 1
a3490 1
        if defined $DATE_OF_02; # An old cache may not contain DATE_OF_02
a3494 1
use strict;
d3496 1
a3496 6
sub ro {
    my $self = shift;
    exists $self->{RO} and return $self->{RO};
}

#-> sub CPAN::InfoObj::cpan_userid
d3499 1
a3499 8
    my $ro = $self->ro;
    if ($ro) {
        return $ro->{CPAN_USERID} || "N/A";
    } else {
        $self->debug("ID[$self->{ID}]");
        # N/A for bundles found locally
        return "N/A";
    }
a3516 36
#-> sub CPAN::InfoObj::safe_chdir ;
sub safe_chdir {
  my($self,$todir) = @@_;
  # we die if we cannot chdir and we are debuggable
  Carp::confess("safe_chdir called without todir argument")
        unless defined $todir and length $todir;
  if (chdir $todir) {
    $self->debug(sprintf "changed directory to %s", CPAN::anycwd())
        if $CPAN::DEBUG;
  } else {
    if (-e $todir) {
        unless (-x $todir) {
            unless (chmod 0755, $todir) {
                my $cwd = CPAN::anycwd();
                $CPAN::Frontend->mywarn("I have neither the -x permission nor the ".
                                        "permission to change the permission; cannot ".
                                        "chdir to '$todir'\n");
                $CPAN::Frontend->mysleep(5);
                $CPAN::Frontend->mydie(qq{Could not chdir from cwd[$cwd] }.
                                       qq{to todir[$todir]: $!});
            }
        }
    } else {
        $CPAN::Frontend->mydie("Directory '$todir' has gone. Cannot continue.\n");
    }
    if (chdir $todir) {
      $self->debug(sprintf "changed directory to %s", CPAN::anycwd())
          if $CPAN::DEBUG;
    } else {
      my $cwd = CPAN::anycwd();
      $CPAN::Frontend->mydie(qq{Could not chdir from cwd[$cwd] }.
                             qq{to todir[$todir] (a chmod has been issued): $!});
    }
  }
}

d3546 1
a3546 2
    my $id = $self->can("pretty_id") ? $self->pretty_id : $self->{ID};
    push @@m, sprintf "%-15s %s\n", $class, $id;
d3557 5
a3561 16
    my $ro;
    unless ($ro = $self->ro) {
        if (substr($self->{ID},-1,1) eq ".") { # directory
            $ro = +{};
        } else {
            $CPAN::Frontend->mywarn("Unknown object $self->{ID}\n");
            $CPAN::Frontend->mysleep(5);
            return;
        }
    }
    for (sort keys %$ro) {
        # next if m/^(ID|RO)$/;
        my $extra = "";
        if ($_ eq "CPAN_USERID") {
            $extra .= " (";
            $extra .= $self->fullname;
d3575 2
a3576 2
        next unless defined $ro->{$_};
        push @@m, sprintf "    %-12s %s%s\n", $_, $ro->{$_}, $extra;
d3578 13
a3590 34
  KEY: for (sort keys %$self) {
        next if m/^(ID|RO)$/;
        unless (defined $self->{$_}) {
            delete $self->{$_};
            next KEY;
        }
        if (ref($self->{$_}) eq "ARRAY") {
            push @@m, sprintf "    %-12s %s\n", $_, "@@{$self->{$_}}";
        } elsif (ref($self->{$_}) eq "HASH") {
            my $value;
            if (/^CONTAINSMODS$/) {
                $value = join(" ",sort keys %{$self->{$_}});
            } elsif (/^prereq_pm$/) {
                my @@value;
                my $v = $self->{$_};
                for my $x (sort keys %$v) {
                    my @@svalue;
                    for my $y (sort keys %{$v->{$x}}) {
                        push @@svalue, "$y=>$v->{$x}{$y}";
                    }
                    push @@value, "$x\:" . join ",", @@svalue if @@svalue;
                }
                $value = join ";", @@value;
            } else {
                $value = $self->{$_};
            }
            push @@m, sprintf(
                             "    %-12s %s\n",
                             $_,
                             $value,
                            );
        } else {
            push @@m, sprintf "    %-12s %s\n", $_, $self->{$_};
        }
d3595 2
a3596 2
#-> sub CPAN::InfoObj::fullname ;
sub fullname {
d3603 3
a3605 18
    my($self, $what) = @@_;
    unless ($CPAN::META->has_inst("Data::Dumper")) {
        $CPAN::Frontend->mydie("dump command requires Data::Dumper installed");
    }
    local $Data::Dumper::Sortkeys;
    $Data::Dumper::Sortkeys = 1;
    my $out = Data::Dumper::Dumper($what ? eval $what : $self);
    if (length $out > 100000) {
        my $fh_pager = FileHandle->new;
        local($SIG{PIPE}) = "IGNORE";
        my $pager = $CPAN::Config->{'pager'} || "cat";
        $fh_pager->open("|$pager")
            or die "Could not open pager $pager\: $!";
        $fh_pager->print($out);
        close $fh_pager;
    } else {
        $CPAN::Frontend->myprint($out);
    }
a3608 13
use strict;

#-> sub CPAN::Author::force
sub force {
    my $self = shift;
    $self->{force}++;
}

#-> sub CPAN::Author::force
sub unforce {
    my $self = shift;
    delete $self->{force};
}
d3634 1
a3634 1
    shift->ro->{FULLNAME};
d3639 1
a3639 1
sub email    { shift->ro->{EMAIL}; }
a3643 2
    my $glob = shift || "";
    my $silent = shift || 0;
d3646 1
a3646 1
    # adapted from CPAN::Distribution::verifyCHECKSUM ;
d3650 1
a3650 1
    $csf[2] = join "", @@csf[1,2]; # ("A","AN","ANDK")
d3652 1
a3652 1
    @@dl = $self->dir_listing([$csf[0],"CHECKSUMS"], 0, 1);
d3654 1
a3654 1
        $CPAN::Frontend->myprint("Directory $csf[1]/ does not exist\n") unless $silent ;
d3657 1
a3657 1
    @@dl = $self->dir_listing([@@csf[0,1],"CHECKSUMS"], 0, 1);
d3659 1
a3659 1
        $CPAN::Frontend->myprint("Directory $id/ does not exist\n") unless $silent;
d3662 4
a3665 15
    @@dl = $self->dir_listing([@@csf,"CHECKSUMS"], 1, 1);
    if ($glob) {
        if ($CPAN::META->has_inst("Text::Glob")) {
            my $rglob = Text::Glob::glob_to_regex($glob);
            @@dl = grep { $_->[2] =~ /$rglob/ } @@dl;
        } else {
            $CPAN::Frontend->mydie("Text::Glob not installed, cannot proceed");
        }
    }
    unless ($silent >= 2) {
        $CPAN::Frontend->myprint(join "", map {
            sprintf("%8d %10s %s/%s\n", $_->[0], $_->[1], $id, $_->[2])
        } sort { $a->[2] cmp $b->[2] } @@dl);
    }
    @@dl;
a3673 2
    my $may_ftp = shift;

d3675 2
a3676 14
        File::Spec->catfile($CPAN::Config->{keep_source_where},
                            "authors", "id", @@$chksumfile);

    my $fh;

    # Purge and refetch old (pre-PGP) CHECKSUMS; they are a security
    # hazard.  (Without GPG installed they are not that much better,
    # though.)
    $fh = FileHandle->new;
    if (open($fh, $lc_want)) {
        my $line = <$fh>; close $fh;
        unlink($lc_want) unless $line =~ /PGP/;
    }

d3679 1
a3679 1
    my $force = $self->{force};
d3681 1
a3681 1
        $force ||= $stat[9] + $CPAN::Config->{index_expire}*86400 <= time;
d3683 13
a3695 25
    my $lc_file;
    if ($may_ftp) {
        $lc_file = CPAN::FTP->localize(
                                       "authors/id/@@$chksumfile",
                                       $lc_want,
                                       $force,
                                      );
        unless ($lc_file) {
            $CPAN::Frontend->myprint("Trying $lc_want.gz\n");
            $chksumfile->[-1] .= ".gz";
            $lc_file = CPAN::FTP->localize("authors/id/@@$chksumfile",
                                           "$lc_want.gz",1);
            if ($lc_file) {
                $lc_file =~ s{\.gz(?!\n)\Z}{}; #};
                eval{CPAN::Tarzip->new("$lc_file.gz")->gunzip($lc_file)};
            } else {
                return;
            }
        }
    } else {
        $lc_file = $lc_want;
        # we *could* second-guess and if the user has a file: URL,
        # then we could look there. But on the other hand, if they do
        # have a file: URL, wy did they choose to set
        # $CPAN::Config->{show_upload_date} to false?
d3698 2
a3699 2
    # adapted from CPAN::Distribution::CHECKSUM_check_file ;
    $fh = FileHandle->new;
d3701 11
a3711 13
    if (open $fh, $lc_file) {
        local($/);
        my $eval = <$fh>;
        $eval =~ s/\015?\012/\n/g;
        close $fh;
        my($comp) = Safe->new();
        $cksum = $comp->reval($eval);
        if ($@@) {
            rename $lc_file, "$lc_file.bad";
            Carp::confess($@@) if $@@;
        }
    } elsif ($may_ftp) {
        Carp::carp "Could not open '$lc_file' for reading.";
d3713 1
a3713 2
        # Maybe should warn: "You may want to set show_upload_date to a true value"
        return;
d3724 1
a3724 1
                } $self->dir_listing(\@@dir,1,$may_ftp);
a3738 6
#-> sub CPAN::Author::reports
sub reports {
    $CPAN::Frontend->mywarn("reports on authors not implemented.
Please file a bugreport if you need this.\n");
}

a3739 1
use strict;
d3742 1
a3742 5
sub cpan_comment {
    my $self = shift;
    my $ro = $self->ro or return;
    $ro->{CPAN_COMMENT}
}
a3743 1
#-> CPAN::Distribution::undelay
d3746 1
a3746 14
    for my $delayer (
                     "configure_requires_later",
                     "configure_requires_later_for",
                     "later",
                     "later_for",
                    ) {
        delete $self->{$delayer};
    }
}

#-> CPAN::Distribution::is_dot_dist
sub is_dot_dist {
    my($self) = @@_;
    return substr($self->id,-1,1) eq ".";
d3749 1
a3749 2
# add the A/AN/ stuff
#-> CPAN::Distribution::normalize
d3753 2
a3754 28
    if (substr($s,-1,1) eq ".") {
        # using a global because we are sometimes called as static method
        if (!$CPAN::META->{LOCK}
            && !$CPAN::Have_warned->{"$s is unlocked"}++
           ) {
            $CPAN::Frontend->mywarn("You are visiting the local directory
  '$s'
  without lock, take care that concurrent processes do not do likewise.\n");
            $CPAN::Frontend->mysleep(1);
        }
        if ($s eq ".") {
            $s = "$CPAN::iCwd/.";
        } elsif (File::Spec->file_name_is_absolute($s)) {
        } elsif (File::Spec->can("rel2abs")) {
            $s = File::Spec->rel2abs($s);
        } else {
            $CPAN::Frontend->mydie("Your File::Spec is too old, please upgrade File::Spec");
        }
        CPAN->debug("s[$s]") if $CPAN::DEBUG;
        unless ($CPAN::META->exists("CPAN::Distribution", $s)) {
            for ($CPAN::META->instance("CPAN::Distribution", $s)) {
                $_->{build_dir} = $s;
                $_->{archived} = "local_directory";
                $_->{unwrapped} = CPAN::Distrostatus->new("YES -- local_directory");
            }
        }
    } elsif (
        $s =~ tr|/|| == 1
a3765 69
#-> sub CPAN::Distribution::author ;
sub author {
    my($self) = @@_;
    my($authorid);
    if (substr($self->id,-1,1) eq ".") {
        $authorid = "LOCAL";
    } else {
        ($authorid) = $self->pretty_id =~ /^([\w\-]+)/;
    }
    CPAN::Shell->expand("Author",$authorid);
}

# tries to get the yaml from CPAN instead of the distro itself:
# EXPERIMENTAL, UNDOCUMENTED AND UNTESTED, for Tels
sub fast_yaml {
    my($self) = @@_;
    my $meta = $self->pretty_id;
    $meta =~ s/\.(tar.gz|tgz|zip|tar.bz2)/.meta/;
    my(@@ls) = CPAN::Shell->globls($meta);
    my $norm = $self->normalize($meta);

    my($local_file);
    my($local_wanted) =
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,$norm)
                           );
    $self->debug("Doing localize") if $CPAN::DEBUG;
    unless ($local_file =
            CPAN::FTP->localize("authors/id/$norm",
                                $local_wanted)) {
        $CPAN::Frontend->mydie("Giving up on downloading yaml file '$local_wanted'\n");
    }
    my $yaml = CPAN->_yaml_loadfile($local_file)->[0];
}

#-> sub CPAN::Distribution::cpan_userid
sub cpan_userid {
    my $self = shift;
    if ($self->{ID} =~ m{[A-Z]/[A-Z\-]{2}/([A-Z\-]+)/}) {
        return $1;
    }
    return $self->SUPER::cpan_userid;
}

#-> sub CPAN::Distribution::pretty_id
sub pretty_id {
    my $self = shift;
    my $id = $self->id;
    return $id unless $id =~ m|^./../|;
    substr($id,5);
}

#-> sub CPAN::Distribution::base_id
sub base_id {
    my $self = shift;
    my $id = $self->pretty_id();
    my $base_id = File::Basename::basename($id);
    $base_id =~ s{\.(?:tar\.(bz2|gz|Z)|t(?:gz|bz)|zip)$}{}i;
    return $base_id;
}

# mark as dirty/clean for the sake of recursion detection. $color=1
# means "in use", $color=0 means "not in use anymore". $color=2 means
# we have determined prereqs now and thus insist on passing this
# through (at least) once again.

a3774 1
        && $color==1
d3776 2
a3777 2
    if ($depth>=$CPAN::MAX_RECURSION) {
        die(CPAN::Exception::RecursiveDependency->new($ancestors));
d3782 2
a3783 9
      PREREQ: for my $pre (keys %{$prereq_pm->{requires}||{}},
                           keys %{$prereq_pm->{build_requires}||{}}) {
            next PREREQ if $pre eq "perl";
            my $premo;
            unless ($premo = CPAN::Shell->expand("Module",$pre)) {
                $CPAN::Frontend->mywarn("prerequisite module[$pre] not known\n");
                $CPAN::Frontend->mysleep(2);
                next PREREQ;
            }
a3788 5

        # as we are at the end of a command, we'll give up this
        # reminder of a broken test. Other commands may test this guy
        # again. Maybe 'badtestcnt' should be renamed to
        # 'make_test_failed_within_command'?
d3796 3
a3798 4
    my $self = shift;
    $self->containsmods;
    $self->upload_date;
    $self->SUPER::as_string(@@_);
d3803 11
a3813 32
    my $self = shift;
    return keys %{$self->{CONTAINSMODS}} if exists $self->{CONTAINSMODS};
    my $dist_id = $self->{ID};
    for my $mod ($CPAN::META->all_objects("CPAN::Module")) {
        my $mod_file = $mod->cpan_file or next;
        my $mod_id = $mod->{ID} or next;
        # warn "mod_file[$mod_file] dist_id[$dist_id] mod_id[$mod_id]";
        # sleep 1;
        if ($CPAN::Signal) {
            delete $self->{CONTAINSMODS};
            return;
        }
        $self->{CONTAINSMODS}{$mod_id} = undef if $mod_file eq $dist_id;
    }
    keys %{$self->{CONTAINSMODS}||={}};
}

#-> sub CPAN::Distribution::upload_date ;
sub upload_date {
    my $self = shift;
    return $self->{UPLOAD_DATE} if exists $self->{UPLOAD_DATE};
    my(@@local_wanted) = split(/\//,$self->id);
    my $filename = pop @@local_wanted;
    push @@local_wanted, "CHECKSUMS";
    my $author = CPAN::Shell->expand("Author",$self->cpan_userid);
    return unless $author;
    my @@dl = $author->dir_listing(\@@local_wanted,0,$CPAN::Config->{show_upload_date});
    return unless @@dl;
    my($dirent) = grep { $_->[2] eq $filename } @@dl;
    # warn sprintf "dirent[%s]id[%s]", $dirent, $self->id;
    return unless $dirent->[1];
    return $self->{UPLOAD_DATE} = $dirent->[1];
d3822 1
a3822 5
        unless ($obj->uptodate) {
            my $id = $self->pretty_id;
            $self->debug("$id not uptodate due to $c") if $CPAN::DEBUG;
            return 0;
        }
d3834 16
a3852 18
    $self->debug("checking goto id[$self->{ID}]") if $CPAN::DEBUG;
    if (my $goto = $self->prefs->{goto}) {
        $CPAN::Frontend->mywarn
            (sprintf(
                     "delegating to '%s' as specified in prefs file '%s' doc %d\n",
                     $goto,
                     $self->{prefs_file},
                     $self->{prefs_file_doc},
                    ));
        return $self->goto($goto);
    }
    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");

    $CPAN::META->set_perl5lib;
    local $ENV{MAKEFLAGS}; # protect us from outer make calls

d3854 4
a3857 42
        my @@e;
        my $goodbye_message;
        $self->debug("checking disabled id[$self->{ID}]") if $CPAN::DEBUG;
        if ($self->prefs->{disabled}) {
            my $why = sprintf(
                              "Disabled via prefs file '%s' doc %d",
                              $self->{prefs_file},
                              $self->{prefs_file_doc},
                             );
            push @@e, $why;
            $self->{unwrapped} = CPAN::Distrostatus->new("NO $why");
            $goodbye_message = "[disabled] -- NA $why";
            # note: not intended to be persistent but at least visible
            # during this session
        } else {
            if (exists $self->{build_dir} && -d $self->{build_dir}
                && ($self->{modulebuild}||$self->{writemakefile})
               ) {
                # this deserves print, not warn:
                $CPAN::Frontend->myprint("  Has already been unwrapped into directory ".
                                         "$self->{build_dir}\n"
                                        );
                return 1;
            }

            # although we talk about 'force' we shall not test on
            # force directly. New model of force tries to refrain from
            # direct checking of force.
            exists $self->{unwrapped} and (
                                           UNIVERSAL::can($self->{unwrapped},"failed") ?
                                           $self->{unwrapped}->failed :
                                           $self->{unwrapped} =~ /^NO/
                                          )
                and push @@e, "Unwrapping had some problem, won't try again without force";
        }
        if (@@e) {
            $CPAN::Frontend->mywarn(join "", map {"$_\n"} @@e);
            if ($goodbye_message) {
                 $self->goodbye($goodbye_message);
            }
            return;
        }
d3861 3
a3863 21
    my($local_file);
    unless ($self->{build_dir} && -d $self->{build_dir}) {
        $self->get_file_onto_local_disk;
        return if $CPAN::Signal;
        $self->check_integrity;
        return if $CPAN::Signal;
        (my $packagedir,$local_file) = $self->run_preps_on_packagedir;
        $packagedir ||= $self->{build_dir};
        $self->{build_dir} = $packagedir;
    }

    if ($CPAN::Signal) {
        $self->safe_chdir($sub_wd);
        return;
    }
    return $self->run_MM_or_MB($local_file);
}

#-> CPAN::Distribution::get_file_onto_local_disk
sub get_file_onto_local_disk {
    my($self) = @@_;
a3864 1
    return if $self->is_dot_dist;
d3868 5
a3872 5
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,$self->id)
                           );
d3885 1
a3885 2

    $self->debug("local_wanted[$local_wanted]local_file[$local_file]") if $CPAN::DEBUG;
d3887 1
a3887 1
}
d3889 6
a3894 9

#-> CPAN::Distribution::check_integrity
sub check_integrity {
    my($self) = @@_;

    return if $self->is_dot_dist;
    if ($CPAN::META->has_inst("Digest::SHA")) {
        $self->debug("Digest::SHA is installed, verifying");
        $self->verifyCHECKSUM;
d3896 1
a3896 1
        $self->debug("Digest::SHA is NOT installed");
d3898 1
a3898 6
}

#-> CPAN::Distribution::run_preps_on_packagedir
sub run_preps_on_packagedir {
    my($self) = @@_;
    return if $self->is_dot_dist;
d3900 3
d3906 5
a3910 14
    $self->debug("Removing tmp-$$") if $CPAN::DEBUG;
    File::Path::rmtree("tmp-$$");
    unless (mkdir "tmp-$$", 0755) {
        $CPAN::Frontend->unrecoverable_error(<<EOF);
Couldn't mkdir '$builddir/tmp-$$': $!

Cannot continue: Please find the reason why I cannot make the
directory
$builddir/tmp-$$
and fix the problem, then retry.

EOF
    }
    if ($CPAN::Signal) {
d3913 1
a3913 1
    $self->safe_chdir("tmp-$$");
d3918 3
a3920 10
    my $local_file = $self->{localfile};
    my $ct = eval{CPAN::Tarzip->new($local_file)};
    unless ($ct) {
        $self->{unwrapped} = CPAN::Distrostatus->new("NO");
        delete $self->{build_dir};
        return;
    }
    if ($local_file =~ /(\.tar\.(bz2|gz|Z)|\.tgz)(?!\n)\Z/i) {
        $self->{was_uncompressed}++ unless eval{$ct->gtest()};
        $self->untar_me($ct);
d3922 4
a3925 1
        $self->unzip_me($ct);
d3927 3
a3929 2
        $self->{was_uncompressed}++ unless $ct->gtest();
        $local_file = $self->handle_singlefile($local_file);
d3938 31
a3968 30
    my ($packagedir);
    # XXX here we want in each branch File::Temp to protect all build_dir directories
    if (CPAN->has_usable("File::Temp")) {
        my $tdir_base;
        my $from_dir;
        my @@dirents;
        if (@@readdir == 1 && -d $readdir[0]) {
            $tdir_base = $readdir[0];
            $from_dir = File::Spec->catdir(File::Spec->curdir,$readdir[0]);
            my $dh2 = DirHandle->new($from_dir)
                or Carp::croak("Couldn't opendir $from_dir: $!");
            @@dirents = grep $_ !~ /^\.\.?(?!\n)\Z/s, $dh2->read; ### MAC??
        } else {
            my $userid = $self->cpan_userid;
            CPAN->debug("userid[$userid]");
            if (!$userid or $userid eq "N/A") {
                $userid = "anon";
            }
            $tdir_base = $userid;
            $from_dir = File::Spec->curdir;
            @@dirents = @@readdir;
        }
        $packagedir = File::Temp::tempdir(
                                          "$tdir_base-XXXXXX",
                                          DIR => $builddir,
                                          CLEANUP => 0,
                                         );
        my $f;
        for $f (@@dirents) { # is already without "." and ".."
            my $from = File::Spec->catdir($from_dir,$f);
d3970 1
a3970 51
            unless (File::Copy::move($from,$to)) {
                my $err = $!;
                $from = File::Spec->rel2abs($from);
                Carp::confess("Couldn't move $from to $to: $err");
            }
        }
    } else { # older code below, still better than nothing when there is no File::Temp
        my($distdir);
        if (@@readdir == 1 && -d $readdir[0]) {
            $distdir = $readdir[0];
            $packagedir = File::Spec->catdir($builddir,$distdir);
            $self->debug("packagedir[$packagedir]builddir[$builddir]distdir[$distdir]")
                if $CPAN::DEBUG;
            -d $packagedir and $CPAN::Frontend->myprint("Removing previously used ".
                                                        "$packagedir\n");
            File::Path::rmtree($packagedir);
            unless (File::Copy::move($distdir,$packagedir)) {
                $CPAN::Frontend->unrecoverable_error(<<EOF);
Couldn't move '$distdir' to '$packagedir': $!

Cannot continue: Please find the reason why I cannot move
$builddir/tmp-$$/$distdir
to
$packagedir
and fix the problem, then retry

EOF
            }
            $self->debug(sprintf("moved distdir[%s] to packagedir[%s] -e[%s]-d[%s]",
                                 $distdir,
                                 $packagedir,
                                 -e $packagedir,
                                 -d $packagedir,
                                )) if $CPAN::DEBUG;
        } else {
            my $userid = $self->cpan_userid;
            CPAN->debug("userid[$userid]") if $CPAN::DEBUG;
            if (!$userid or $userid eq "N/A") {
                $userid = "anon";
            }
            my $pragmatic_dir = $userid . '000';
            $pragmatic_dir =~ s/\W_//g;
            $pragmatic_dir++ while -d "../$pragmatic_dir";
            $packagedir = File::Spec->catdir($builddir,$pragmatic_dir);
            $self->debug("packagedir[$packagedir]") if $CPAN::DEBUG;
            File::Path::mkpath($packagedir);
            my($f);
            for $f (@@readdir) { # is already without "." and ".."
                my $to = File::Spec->catdir($packagedir,$f);
                File::Copy::move($f,$to) or Carp::confess("Couldn't move $f to $to: $!");
            }
d3973 2
a3974 27
    $self->{build_dir} = $packagedir;
    $self->safe_chdir($builddir);
    File::Path::rmtree("tmp-$$");

    $self->safe_chdir($packagedir);
    $self->_signature_business();
    $self->safe_chdir($builddir);

    return($packagedir,$local_file);
}

#-> sub CPAN::Distribution::parse_meta_yml ;
sub parse_meta_yml {
    my($self) = @@_;
    my $build_dir = $self->{build_dir} or die "PANIC: cannot parse yaml without a build_dir";
    my $yaml = File::Spec->catfile($build_dir,"META.yml");
    $self->debug("yaml[$yaml]") if $CPAN::DEBUG;
    return unless -f $yaml;
    my $early_yaml;
    eval {
        require Parse::Metayaml; # hypothetical
        $early_yaml = Parse::Metayaml::LoadFile($yaml)->[0];
    };
    unless ($early_yaml) {
        eval { $early_yaml = CPAN->_yaml_loadfile($yaml)->[0]; };
    }
    unless ($early_yaml) {
a3976 2
    return $early_yaml;
}
d3978 3
a3980 46
#-> sub CPAN::Distribution::satisfy_configure_requires ;
sub satisfy_configure_requires {
    my($self) = @@_;
    my $enable_configure_requires = 1;
    if (!$enable_configure_requires) {
        return 1;
        # if we return 1 here, everything is as before we introduced
        # configure_requires that means, things with
        # configure_requires simply fail, all others succeed
    }
    my @@prereq = $self->unsat_prereq("configure_requires_later") or return 1;
    if ($self->{configure_requires_later}) {
        for my $k (keys %{$self->{configure_requires_later_for}||{}}) {
            if ($self->{configure_requires_later_for}{$k}>1) {
                # we must not come here a second time
                $CPAN::Frontend->mywarn("Panic: Some prerequisites is not available, please investigate...");
                require YAML::Syck;
                $CPAN::Frontend->mydie
                    (
                     YAML::Syck::Dump
                     ({self=>$self, prereq=>\@@prereq})
                    );
            }
        }
    }
    if ($prereq[0][0] eq "perl") {
        my $need = "requires perl '$prereq[0][1]'";
        my $id = $self->pretty_id;
        $CPAN::Frontend->mywarn("$id $need; you have only $]; giving up\n");
        $self->{make} = CPAN::Distrostatus->new("NO $need");
        $self->store_persistent_state;
        return $self->goodbye("[prereq] -- NOT OK");
    } else {
        my $follow = eval {
            $self->follow_prereqs("configure_requires_later", @@prereq);
        };
        if (0) {
        } elsif ($follow) {
            return;
        } elsif ($@@ && ref $@@ && $@@->isa("CPAN::Exception::RecursiveDependency")) {
            $CPAN::Frontend->mywarn($@@);
            return $self->goodbye("[depend] -- NOT OK");
        }
    }
    die "never reached";
}
d3982 1
a3982 5
#-> sub CPAN::Distribution::run_MM_or_MB ;
sub run_MM_or_MB {
    my($self,$local_file) = @@_;
    $self->satisfy_configure_requires() or return;
    my($mpl) = File::Spec->catfile($self->{build_dir},"Makefile.PL");
d3988 3
a3990 3
        $CPAN::Frontend->mysleep(1);
        my $mpldh = DirHandle->new($self->{build_dir})
            or Carp::croak("Couldn't opendir $self->{build_dir}: $!");
d3994 11
a4004 211
    my $prefer_installer = "eumm"; # eumm|mb
    if (-f File::Spec->catfile($self->{build_dir},"Build.PL")) {
        if ($mpl_exists) { # they *can* choose
            if ($CPAN::META->has_inst("Module::Build")) {
                $prefer_installer = CPAN::HandleConfig->prefs_lookup($self,
                                                                     q{prefer_installer});
            }
        } else {
            $prefer_installer = "mb";
        }
    }
    return unless $self->patch;
    if (lc($prefer_installer) eq "rand") {
        $prefer_installer = rand()<.5 ? "eumm" : "mb";
    }
    if (lc($prefer_installer) eq "mb") {
        $self->{modulebuild} = 1;
    } elsif ($self->{archived} eq "patch") {
        # not an edge case, nothing to install for sure
        my $why = "A patch file cannot be installed";
        $CPAN::Frontend->mywarn("Refusing to handle this file: $why\n");
        $self->{writemakefile} = CPAN::Distrostatus->new("NO $why");
    } elsif (! $mpl_exists) {
        $self->_edge_cases($mpl,$local_file);
    }
    if ($self->{build_dir}
        &&
        $CPAN::Config->{build_dir_reuse}
       ) {
        $self->store_persistent_state;
    }
    return $self;
}

#-> CPAN::Distribution::store_persistent_state
sub store_persistent_state {
    my($self) = @@_;
    my $dir = $self->{build_dir};
    unless (File::Spec->canonpath(File::Basename::dirname($dir))
            eq File::Spec->canonpath($CPAN::Config->{build_dir})) {
        $CPAN::Frontend->mywarn("Directory '$dir' not below $CPAN::Config->{build_dir}, ".
                                "will not store persistent state\n");
        return;
    }
    my $file = sprintf "%s.yml", $dir;
    my $yaml_module = CPAN::_yaml_module;
    if ($CPAN::META->has_inst($yaml_module)) {
        CPAN->_yaml_dumpfile(
                             $file,
                             {
                              time => time,
                              perl => CPAN::_perl_fingerprint,
                              distribution => $self,
                             }
                            );
    } else {
        $CPAN::Frontend->myprint("Warning (usually harmless): '$yaml_module' not installed, ".
                                "will not store persistent state\n");
    }
}

#-> CPAN::Distribution::try_download
sub try_download {
    my($self,$patch) = @@_;
    my $norm = $self->normalize($patch);
    my($local_wanted) =
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,$norm),
                           );
    $self->debug("Doing localize") if $CPAN::DEBUG;
    return CPAN::FTP->localize("authors/id/$norm",
                               $local_wanted);
}

{
    my $stdpatchargs = "";
    #-> CPAN::Distribution::patch
    sub patch {
        my($self) = @@_;
        $self->debug("checking patches id[$self->{ID}]") if $CPAN::DEBUG;
        my $patches = $self->prefs->{patches};
        $patches ||= "";
        $self->debug("patches[$patches]") if $CPAN::DEBUG;
        if ($patches) {
            return unless @@$patches;
            $self->safe_chdir($self->{build_dir});
            CPAN->debug("patches[$patches]") if $CPAN::DEBUG;
            my $patchbin = $CPAN::Config->{patch};
            unless ($patchbin && length $patchbin) {
                $CPAN::Frontend->mydie("No external patch command configured\n\n".
                                       "Please run 'o conf init /patch/'\n\n");
            }
            unless (MM->maybe_command($patchbin)) {
                $CPAN::Frontend->mydie("No external patch command available\n\n".
                                       "Please run 'o conf init /patch/'\n\n");
            }
            $patchbin = CPAN::HandleConfig->safe_quote($patchbin);
            local $ENV{PATCH_GET} = 0; # formerly known as -g0
            unless ($stdpatchargs) {
                my $system = "$patchbin --version |";
                local *FH;
                open FH, $system or die "Could not fork '$system': $!";
                local $/ = "\n";
                my $pversion;
              PARSEVERSION: while (<FH>) {
                    if (/^patch\s+([\d\.]+)/) {
                        $pversion = $1;
                        last PARSEVERSION;
                    }
                }
                if ($pversion) {
                    $stdpatchargs = "-N --fuzz=3";
                } else {
                    $stdpatchargs = "-N";
                }
            }
            my $countedpatches = @@$patches == 1 ? "1 patch" : (scalar @@$patches . " patches");
            $CPAN::Frontend->myprint("Going to apply $countedpatches:\n");
            for my $patch (@@$patches) {
                unless (-f $patch) {
                    if (my $trydl = $self->try_download($patch)) {
                        $patch = $trydl;
                    } else {
                        my $fail = "Could not find patch '$patch'";
                        $CPAN::Frontend->mywarn("$fail; cannot continue\n");
                        $self->{unwrapped} = CPAN::Distrostatus->new("NO -- $fail");
                        delete $self->{build_dir};
                        return;
                    }
                }
                $CPAN::Frontend->myprint("  $patch\n");
                my $readfh = CPAN::Tarzip->TIEHANDLE($patch);

                my $pcommand;
                my $ppp = $self->_patch_p_parameter($readfh);
                if ($ppp eq "applypatch") {
                    $pcommand = "$CPAN::Config->{applypatch} -verbose";
                } else {
                    my $thispatchargs = join " ", $stdpatchargs, $ppp;
                    $pcommand = "$patchbin $thispatchargs";
                }

                $readfh = CPAN::Tarzip->TIEHANDLE($patch); # open again
                my $writefh = FileHandle->new;
                $CPAN::Frontend->myprint("  $pcommand\n");
                unless (open $writefh, "|$pcommand") {
                    my $fail = "Could not fork '$pcommand'";
                    $CPAN::Frontend->mywarn("$fail; cannot continue\n");
                    $self->{unwrapped} = CPAN::Distrostatus->new("NO -- $fail");
                    delete $self->{build_dir};
                    return;
                }
                while (my $x = $readfh->READLINE) {
                    print $writefh $x;
                }
                unless (close $writefh) {
                    my $fail = "Could not apply patch '$patch'";
                    $CPAN::Frontend->mywarn("$fail; cannot continue\n");
                    $self->{unwrapped} = CPAN::Distrostatus->new("NO -- $fail");
                    delete $self->{build_dir};
                    return;
                }
            }
            $self->{patched}++;
        }
        return 1;
    }
}

sub _patch_p_parameter {
    my($self,$fh) = @@_;
    my $cnt_files   = 0;
    my $cnt_p0files = 0;
    local($_);
    while ($_ = $fh->READLINE) {
        if (
            $CPAN::Config->{applypatch}
            &&
            /\#\#\#\# ApplyPatch data follows \#\#\#\#/
           ) {
            return "applypatch"
        }
        next unless /^[\*\+]{3}\s(\S+)/;
        my $file = $1;
        $cnt_files++;
        $cnt_p0files++ if -f $file;
        CPAN->debug("file[$file]cnt_files[$cnt_files]cnt_p0files[$cnt_p0files]")
            if $CPAN::DEBUG;
    }
    return "-p1" unless $cnt_files;
    return $cnt_files==$cnt_p0files ? "-p0" : "-p1";
}

#-> sub CPAN::Distribution::_edge_cases
# with "configure" or "Makefile" or single file scripts
sub _edge_cases {
    my($self,$mpl,$local_file) = @@_;
    $self->debug(sprintf("makefilepl[%s]anycwd[%s]",
                         $mpl,
                         CPAN::anycwd(),
                        )) if $CPAN::DEBUG;
    my $build_dir = $self->{build_dir};
    my($configure) = File::Spec->catfile($build_dir,"Configure");
    if (-f $configure) {
        # do we have anything to do?
        $self->{configure} = $configure;
    } elsif (-f File::Spec->catfile($build_dir,"Makefile")) {
        $CPAN::Frontend->mywarn(qq{
d4008 11
a4018 11
        $self->{writemakefile} = CPAN::Distrostatus->new("YES");
        $CPAN::Frontend->mysleep(2);
    } else {
        my $cf = $self->called_for || "unknown";
        if ($cf =~ m|/|) {
            $cf =~ s|.*/||;
            $cf =~ s|\W.*||;
        }
        $cf =~ s|[/\\:]||g;     # risk of filesystem damage
        $cf = "unknown" unless length($cf);
        $CPAN::Frontend->mywarn(qq{Package seems to come without Makefile.PL.
d4021 2
a4022 2
        $self->{had_no_makefile_pl}++;
        $CPAN::Frontend->mysleep(3);
d4024 1
a4024 1
        # Writing our own Makefile.PL
a4025 2
        my $script = "";
        if ($self->{archived} eq "maybe_pl") {
d4027 4
a4030 67
            my $script_file = File::Spec->catfile($build_dir,$local_file);
            $fh->open($script_file)
                or Carp::croak("Could not open script '$script_file': $!");
            local $/ = "\n";
            # name parsen und prereq
            my($state) = "poddir";
            my($name, $prereq) = ("", "");
            while (<$fh>) {
                if ($state eq "poddir" && /^=head\d\s+(\S+)/) {
                    if ($1 eq 'NAME') {
                        $state = "name";
                    } elsif ($1 eq 'PREREQUISITES') {
                        $state = "prereq";
                    }
                } elsif ($state =~ m{^(name|prereq)$}) {
                    if (/^=/) {
                        $state = "poddir";
                    } elsif (/^\s*$/) {
                        # nop
                    } elsif ($state eq "name") {
                        if ($name eq "") {
                            ($name) = /^(\S+)/;
                            $state = "poddir";
                        }
                    } elsif ($state eq "prereq") {
                        $prereq .= $_;
                    }
                } elsif (/^=cut\b/) {
                    last;
                }
            }
            $fh->close;

            for ($name) {
                s{.*<}{};       # strip X<...>
                s{>.*}{};
            }
            chomp $prereq;
            $prereq = join " ", split /\s+/, $prereq;
            my($PREREQ_PM) = join("\n", map {
                s{.*<}{};       # strip X<...>
                s{>.*}{};
                if (/[\s\'\"]/) { # prose?
                } else {
                    s/[^\w:]$//; # period?
                    " "x28 . "'$_' => 0,";
                }
            } split /\s*,\s*/, $prereq);

            $script = "
              EXE_FILES => ['$name'],
              PREREQ_PM => {
$PREREQ_PM
                           },
";
            if ($name) {
                my $to_file = File::Spec->catfile($build_dir, $name);
                rename $script_file, $to_file
                    or die "Can't rename $script_file to $to_file: $!";
            }
        }

        my $fh = FileHandle->new;
        $fh->open(">$mpl")
            or Carp::croak("Could not open >$mpl: $!");
        $fh->print(
                   qq{# This Makefile.PL has been autogenerated by the module CPAN.pm
d4035 2
a4036 3
WriteMakefile(
              NAME => q[$cf],$script
             );
d4038 2
a4039 1
        $fh->close;
a4040 1
}
d4042 1
a4042 46
#-> CPAN::Distribution::_signature_business
sub _signature_business {
    my($self) = @@_;
    my $check_sigs = CPAN::HandleConfig->prefs_lookup($self,
                                                      q{check_sigs});
    if ($check_sigs) {
        if ($CPAN::META->has_inst("Module::Signature")) {
            if (-f "SIGNATURE") {
                $self->debug("Module::Signature is installed, verifying") if $CPAN::DEBUG;
                my $rv = Module::Signature::verify();
                if ($rv != Module::Signature::SIGNATURE_OK() and
                    $rv != Module::Signature::SIGNATURE_MISSING()) {
                    $CPAN::Frontend->mywarn(
                                            qq{\nSignature invalid for }.
                                            qq{distribution file. }.
                                            qq{Please investigate.\n\n}
                                           );

                    my $wrap =
                        sprintf(qq{I'd recommend removing %s. Some error occured    }.
                                qq{while checking its signature, so it could        }.
                                qq{be invalid. Maybe you have configured            }.
                                qq{your 'urllist' with a bad URL. Please check this }.
                                qq{array with 'o conf urllist' and retry. Or        }.
                                qq{examine the distribution in a subshell. Try
  look %s
and run
  cpansign -v
},
                                $self->{localfile},
                                $self->pretty_id,
                               );
                    $self->{signature_verify} = CPAN::Distrostatus->new("NO");
                    $CPAN::Frontend->mywarn(Text::Wrap::wrap("","",$wrap));
                    $CPAN::Frontend->mysleep(5) if $CPAN::Frontend->can("mysleep");
                } else {
                    $self->{signature_verify} = CPAN::Distrostatus->new("YES");
                    $self->debug("Module::Signature has verified") if $CPAN::DEBUG;
                }
            } else {
                $CPAN::Frontend->mywarn(qq{Package came without SIGNATURE\n\n});
            }
        } else {
            $self->debug("Module::Signature is NOT installed") if $CPAN::DEBUG;
        }
    }
d4045 1
a4045 1
#-> CPAN::Distribution::untar_me ;
d4047 1
a4047 1
    my($self,$ct) = @@_;
d4049 2
a4050 2
    if ($ct->untar()) {
        $self->{unwrapped} = CPAN::Distrostatus->new("YES");
d4052 1
a4052 1
        $self->{unwrapped} = CPAN::Distrostatus->new("NO -- untar failed");
d4058 1
a4058 1
    my($self,$ct) = @@_;
d4060 2
a4061 2
    if ($ct->unzip()) {
        $self->{unwrapped} = CPAN::Distrostatus->new("YES");
d4063 1
a4063 1
        $self->{unwrapped} = CPAN::Distrostatus->new("NO -- unzip failed");
d4068 1
a4068 1
sub handle_singlefile {
d4070 1
a4070 9

    if ( $local_file =~ /\.pm(\.(gz|Z))?(?!\n)\Z/ ) {
        $self->{archived} = "pm";
    } elsif ( $local_file =~ /\.patch(\.(gz|bz2))?(?!\n)\Z/ ) {
        $self->{archived} = "patch";
    } else {
        $self->{archived} = "maybe_pl";
    }

d4072 3
a4074 6
    if ($to =~ s/\.(gz|Z)(?!\n)\Z//) {
        if (eval{CPAN::Tarzip->new($local_file)->gunzip($to)}) {
            $self->{unwrapped} = CPAN::Distrostatus->new("YES");
        } else {
            $self->{unwrapped} = CPAN::Distrostatus->new("NO -- uncompressing failed");
        }
d4076 1
a4076 5
        if (File::Copy::cp($local_file,".")) {
            $self->{unwrapped} = CPAN::Distrostatus->new("YES");
        } else {
            $self->{unwrapped} = CPAN::Distrostatus->new("NO -- copying failed");
        }
a4077 1
    return $to;
d4100 1
a4100 1
        $CPAN::Frontend->myprint(qq{
d4104 1
a4104 1
        $CPAN::Frontend->myprint(qq{
d4108 1
a4108 1
        return;
d4116 1
a4116 1
        $CPAN::Frontend->mywarn(qq{
d4119 1
a4119 1
        return;
d4124 3
a4126 8
    {
        local $ENV{CPAN_SHELL_LEVEL} = $ENV{CPAN_SHELL_LEVEL}||0;
        $ENV{CPAN_SHELL_LEVEL} += 1;
        my $shell = CPAN::HandleConfig->safe_quote($CPAN::Config->{'shell'});
        unless (system($shell) == 0) {
            my $code = $? >> 8;
            $CPAN::Frontend->mywarn("Subprocess shell exit code $code\n");
        }
d4145 1
a4145 1
    my $cvs_root =
d4147 1
a4147 1
    my $cvs_site_perl =
d4150 1
a4150 1
        $cvs_dir = "$cvs_site_perl/$cvs_dir";
a4153 1
    # XXX cvs: undocumented and unclear how it was meant to work
d4155 1
a4155 1
               "$cvs_dir", $userid, "v$version");
d4164 1
a4164 2
    # XXX cvs
        $CPAN::Frontend->mydie("cvs import failed");
d4176 6
a4181 6
        File::Spec->catfile(
                            $CPAN::Config->{keep_source_where},
                            "authors",
                            "id",
                            split(/\//,"$sans.readme"),
                           );
d4184 2
a4185 2
                                      $local_wanted)
        or $CPAN::Frontend->mydie(qq{No $sans.readme found});;
d4194 2
a4195 3
    my $pager = $CPAN::Config->{'pager'} || "cat";
    $fh_pager->open("|$pager")
        or die "Could not open pager $pager\: $!";
d4198 1
a4198 1
        or $CPAN::Frontend->mydie(qq{Could not open "$local_file": $!});
d4202 1
a4202 1
with pager "$pager"
d4204 1
a4205 1
    $fh_pager->close;
d4208 2
a4209 2
#-> sub CPAN::Distribution::verifyCHECKSUM ;
sub verifyCHECKSUM {
d4212 4
a4215 4
        my @@e;
        $self->{CHECKSUM_STATUS} ||= "";
        $self->{CHECKSUM_STATUS} eq "OK" and push @@e, "Checksum was ok";
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
d4222 2
a4223 2
        File::Spec->catfile($CPAN::Config->{keep_source_where},
                            "authors", "id", @@local);
d4225 6
a4230 5
    if (my $size = -s $lc_want) {
        $self->debug("lc_want[$lc_want]size[$size]") if $CPAN::DEBUG;
        if ($self->CHECKSUM_check_file($lc_want,1)) {
            return $self->{CHECKSUM_STATUS} = "OK";
        }
d4233 1
a4233 1
                                   $lc_want,1);
d4236 12
a4247 14
        $local[-1] .= ".gz";
        $lc_file = CPAN::FTP->localize("authors/id/@@local",
                                       "$lc_want.gz",1);
        if ($lc_file) {
            $lc_file =~ s/\.gz(?!\n)\Z//;
            eval{CPAN::Tarzip->new("$lc_file.gz")->gunzip($lc_file)};
        } else {
            return;
        }
    }
    if ($self->CHECKSUM_check_file($lc_file)) {
        return $self->{CHECKSUM_STATUS} = "OK";
    }
}
d4249 2
a4250 2
#-> sub CPAN::Distribution::SIG_check_file ;
sub SIG_check_file {
a4251 31
    my $rv = eval { Module::Signature::_verify($chk_file) };

    if ($rv == Module::Signature::SIGNATURE_OK()) {
        $CPAN::Frontend->myprint("Signature for $chk_file ok\n");
        return $self->{SIG_STATUS} = "OK";
    } else {
        $CPAN::Frontend->myprint(qq{\nSignature invalid for }.
                                 qq{distribution file. }.
                                 qq{Please investigate.\n\n}.
                                 $self->as_string,
                                 $CPAN::META->instance(
                                                       'CPAN::Author',
                                                       $self->cpan_userid
                                                      )->as_string);

        my $wrap = qq{I\'d recommend removing $chk_file. Its signature
is invalid. Maybe you have configured your 'urllist' with
a bad URL. Please check this array with 'o conf urllist', and
retry.};

        $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));
    }
}

#-> sub CPAN::Distribution::CHECKSUM_check_file ;

# sloppy is 1 when we have an old checksums file that maybe is good
# enough

sub CHECKSUM_check_file {
    my($self,$chk_file,$sloppy) = @@_;
a4252 14

    $sloppy ||= 0;
    $self->debug("chk_file[$chk_file]sloppy[$sloppy]") if $CPAN::DEBUG;
    my $check_sigs = CPAN::HandleConfig->prefs_lookup($self,
                                                      q{check_sigs});
    if ($check_sigs) {
        if ($CPAN::META->has_inst("Module::Signature")) {
            $self->debug("Module::Signature is installed, verifying") if $CPAN::DEBUG;
            $self->SIG_check_file($chk_file);
        } else {
            $self->debug("Module::Signature is NOT installed") if $CPAN::DEBUG;
        }
    }

d4256 50
a4305 59
    if (open $fh, $chk_file) {
        local($/);
        my $eval = <$fh>;
        $eval =~ s/\015?\012/\n/g;
        close $fh;
        my($comp) = Safe->new();
        $cksum = $comp->reval($eval);
        if ($@@) {
            rename $chk_file, "$chk_file.bad";
            Carp::confess($@@) if $@@;
        }
    } else {
        Carp::carp "Could not open $chk_file for reading";
    }

    if (! ref $cksum or ref $cksum ne "HASH") {
        $CPAN::Frontend->mywarn(qq{
Warning: checksum file '$chk_file' broken.

When trying to read that file I expected to get a hash reference
for further processing, but got garbage instead.
});
        my $answer = CPAN::Shell::colorable_makemaker_prompt("Proceed nonetheless?", "no");
        $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted.\n");
        $self->{CHECKSUM_STATUS} = "NIL -- CHECKSUMS file broken";
        return;
    } elsif (exists $cksum->{$basename}{sha256}) {
        $self->debug("Found checksum for $basename:" .
                     "$cksum->{$basename}{sha256}\n") if $CPAN::DEBUG;

        open($fh, $file);
        binmode $fh;
        my $eq = $self->eq_CHECKSUM($fh,$cksum->{$basename}{sha256});
        $fh->close;
        $fh = CPAN::Tarzip->TIEHANDLE($file);

        unless ($eq) {
            my $dg = Digest::SHA->new(256);
            my($data,$ref);
            $ref = \$data;
            while ($fh->READ($ref, 4096) > 0) {
                $dg->add($data);
            }
            my $hexdigest = $dg->hexdigest;
            $eq += $hexdigest eq $cksum->{$basename}{'sha256-ungz'};
        }

        if ($eq) {
            $CPAN::Frontend->myprint("Checksum for $file ok\n");
            return $self->{CHECKSUM_STATUS} = "OK";
        } else {
            $CPAN::Frontend->myprint(qq{\nChecksum mismatch for }.
                                     qq{distribution file. }.
                                     qq{Please investigate.\n\n}.
                                     $self->as_string,
                                     $CPAN::META->instance(
                                                           'CPAN::Author',
                                                           $self->cpan_userid
                                                          )->as_string);
d4307 1
a4307 1
            my $wrap = qq{I\'d recommend removing $file. Its
d4317 10
a4326 10
            # $CPAN::Frontend->myprint("\n\n");
            # sleep 3;
            # return;
        }
        # close $fh if fileno($fh);
    } else {
        return if $sloppy;
        unless ($self->{CHECKSUM_STATUS}) {
            $CPAN::Frontend->mywarn(qq{
Warning: No checksum for $basename in $chk_file.
d4332 5
a4336 5
            my $answer = CPAN::Shell::colorable_makemaker_prompt("Proceed?", "yes");
            $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted.\n");
        }
        $self->{CHECKSUM_STATUS} = "NIL -- distro not in CHECKSUMS file";
        return;
d4340 12
a4351 14
#-> sub CPAN::Distribution::eq_CHECKSUM ;
sub eq_CHECKSUM {
    my($self,$fh,$expect) = @@_;
    if ($CPAN::META->has_inst("Digest::SHA")) {
        my $dg = Digest::SHA->new(256);
        my($data);
        while (read($fh, $data, 4096)) {
            $dg->add($data);
        }
        my $hexdigest = $dg->hexdigest;
        # warn "fh[$fh] hex[$hexdigest] aexp[$expectMD5]";
        return $hexdigest eq $expect;
    }
    return 1;
d4356 4
a4359 4
# Both CPAN::Modules and CPAN::Distributions know if "force" is in
# effect by autoinspection, not by inspecting a global variable. One
# of the reason why this was chosen to work that way was the treatment
# of dependencies. They should not automatically inherit the force
d4366 1
a4366 4
# "Force get forgets previous error conditions"

#-> sub CPAN::Distribution::fforce ;
sub fforce {
d4368 5
a4372 71
  $self->force($method,1);
}

#-> sub CPAN::Distribution::force ;
sub force {
  my($self, $method,$fforce) = @@_;
  my %phase_map = (
                   get => [
                           "unwrapped",
                           "build_dir",
                           "archived",
                           "localfile",
                           "CHECKSUM_STATUS",
                           "signature_verify",
                           "prefs",
                           "prefs_file",
                           "prefs_file_doc",
                          ],
                   make => [
                            "writemakefile",
                            "make",
                            "modulebuild",
                            "prereq_pm",
                            "prereq_pm_detected",
                           ],
                   test => [
                            "badtestcnt",
                            "make_test",
                           ],
                   install => [
                               "install",
                              ],
                   unknown => [
                               "reqtype",
                               "yaml_content",
                              ],
                  );
  my $methodmatch = 0;
  my $ldebug = 0;
 PHASE: for my $phase (qw(unknown get make test install)) { # order matters
      $methodmatch = 1 if $fforce || $phase eq $method;
      next unless $methodmatch;
    ATTRIBUTE: for my $att (@@{$phase_map{$phase}}) {
          if ($phase eq "get") {
              if (substr($self->id,-1,1) eq "."
                  && $att =~ /(unwrapped|build_dir|archived)/ ) {
                  # cannot be undone for local distros
                  next ATTRIBUTE;
              }
              if ($att eq "build_dir"
                  && $self->{build_dir}
                  && $CPAN::META->{is_tested}
                 ) {
                  delete $CPAN::META->{is_tested}{$self->{build_dir}};
              }
          } elsif ($phase eq "test") {
              if ($att eq "make_test"
                  && $self->{make_test}
                  && $self->{make_test}{COMMANDID}
                  && $self->{make_test}{COMMANDID} == $CPAN::CurrentCommandId
                 ) {
                  # endless loop too likely
                  next ATTRIBUTE;
              }
          }
          delete $self->{$att};
          if ($ldebug || $CPAN::DEBUG) {
              # local $CPAN::DEBUG = 16; # Distribution
              CPAN->debug(sprintf "id[%s]phase[%s]att[%s]", $self->id, $phase, $att);
          }
      }
d4374 2
a4375 2
  if ($method && $method =~ /make|test|install/) {
    $self->{force_update} = 1; # name should probably have been force_install
a4378 14
#-> sub CPAN::Distribution::notest ;
sub notest {
  my($self, $method) = @@_;
  # $CPAN::Frontend->mywarn("XDEBUG: set notest for $self $method");
  $self->{"notest"}++; # name should probably have been force_install
}

#-> sub CPAN::Distribution::unnotest ;
sub unnotest {
  my($self) = @@_;
  # warn "XDEBUG: deleting notest";
  delete $self->{notest};
}

d4382 1
a4382 1
  delete $self->{force_update};
d4391 3
a4393 3
                  (5)
                  ([._-])
                  (
d4396 1
a4396 1
                   \d+\.\d+
d4398 3
a4400 3
                  \.tar[._-](?:gz|bz2)
                  (?!\n)\Z
                }xs) {
d4404 1
a4404 1
           $self->cpan_comment =~ /isa_perl\(.+?\)/) {
a4408 1

d4411 18
a4428 4
    my ($self) = @@_;
    if (! $self) {
        use Carp qw(carp);
        carp __PACKAGE__ . "::perl was called without parameters.";
d4430 1
a4430 1
    return CPAN::HandleConfig->safe_quote($CPAN::Perl);
a4432 1

d4436 1
a4436 4
    if (my $goto = $self->prefs->{goto}) {
        return $self->goto($goto);
    }
    my $make = $self->{modulebuild} ? "Build" : "make";
d4439 12
a4450 11
        if (
            $self->called_for ne $self->id &&
            ! $self->{force_update}
        ) {
            # if we die here, we break bundles
            $CPAN::Frontend
                ->mywarn(sprintf(
                            qq{The most recent version "%s" of the module "%s"
is part of the perl-%s distribution. To install that, you need to run
  force install %s   --or--
  install %s
d4452 10
a4461 13
                             $CPAN::META->instance(
                                                   'CPAN::Module',
                                                   $self->called_for
                                                  )->cpan_version,
                             $self->called_for,
                             $self->isa_perl,
                             $self->called_for,
                             $self->id,
                            ));
            $self->{make} = CPAN::Distrostatus->new("NO isa perl");
            $CPAN::Frontend->mysleep(1);
            return;
        }
a4462 1
    $CPAN::Frontend->myprint(sprintf "Running %s for %s\n", $make, $self->id);
d4464 7
a4470 8
    if ($self->{configure_requires_later}) {
        return;
    }
    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");
    $CPAN::META->set_perl5lib;
    local $ENV{MAKEFLAGS}; # protect us from outer make calls
d4472 3
a4474 4
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }
d4476 2
a4477 60
    my $builddir;
  EXCUSE: {
        my @@e;
        if (!$self->{archived} || $self->{archived} eq "NO") {
            push @@e, "Is neither a tar nor a zip archive.";
        }

        if (!$self->{unwrapped}
            || (
                UNIVERSAL::can($self->{unwrapped},"failed") ?
                $self->{unwrapped}->failed :
                $self->{unwrapped} =~ /^NO/
               )) {
            push @@e, "Had problems unarchiving. Please build manually";
        }

        unless ($self->{force_update}) {
            exists $self->{signature_verify} and
                (
                 UNIVERSAL::can($self->{signature_verify},"failed") ?
                 $self->{signature_verify}->failed :
                 $self->{signature_verify} =~ /^NO/
                )
                and push @@e, "Did not pass the signature test.";
        }

        if (exists $self->{writemakefile} &&
            (
             UNIVERSAL::can($self->{writemakefile},"failed") ?
             $self->{writemakefile}->failed :
             $self->{writemakefile} =~ /^NO/
            )) {
            # XXX maybe a retry would be in order?
            my $err = UNIVERSAL::can($self->{writemakefile},"text") ?
                $self->{writemakefile}->text :
                    $self->{writemakefile};
            $err =~ s/^NO\s*//;
            $err ||= "Had some problem writing Makefile";
            $err .= ", won't make";
            push @@e, $err;
        }

        if (defined $self->{make}) {
            if (UNIVERSAL::can($self->{make},"failed") ?
                $self->{make}->failed :
                $self->{make} =~ /^NO/) {
                if ($self->{force_update}) {
                    # Trying an already failed 'make' (unless somebody else blocks)
                } else {
                    # introduced for turning recursion detection into a distrostatus
                    my $error = length $self->{make}>3
                        ? substr($self->{make},3) : "Unknown error";
                    $CPAN::Frontend->mywarn("Could not make: $error\n");
                    $self->store_persistent_state;
                    return;
                }
            } else {
                push @@e, "Has already been made";
            }
        }
d4479 2
a4480 6
        my $later = $self->{later} || $self->{configure_requires_later};
        if ($later) { # see also undelay
            if ($later) {
                push @@e, $later;
            }
        }
d4482 1
a4482 11
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
        $builddir = $self->dir or
            $CPAN::Frontend->mydie("PANIC: Cannot determine build directory\n");
        unless (chdir $builddir) {
            push @@e, "Couldn't chdir to '$builddir': $!";
        }
        $CPAN::Frontend->mywarn(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
d4485 2
a4493 6
    my %env;
    while (my($k,$v) = each %ENV) {
        next unless defined $v;
        $env{$k} = $v;
    }
    local %ENV = %env;
d4495 2
a4496 8
    if (my $commandline = $self->prefs->{pl}{commandline}) {
        $system = $commandline;
        $ENV{PERL} = $^X;
    } elsif ($self->{'configure'}) {
        $system = $self->{'configure'};
    } elsif ($self->{modulebuild}) {
        my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
        $system = "$perl Build.PL $CPAN::Config->{mbuildpl_arg}";
d4498 2
a4499 2
        my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
        my $switch = "";
d4501 55
a4555 118
#        $switch = "-MExtUtils::MakeMaker ".
#            "-Mops=:default,:filesys_read,:filesys_open,require,chdir"
#            if $] > 5.00310;
        my $makepl_arg = $self->make_x_arg("pl");
        $ENV{PERL5_CPAN_IS_EXECUTING} = File::Spec->catfile($self->{build_dir},
                                                            "Makefile.PL");
        $system = sprintf("%s%s Makefile.PL%s",
                          $perl,
                          $switch ? " $switch" : "",
                          $makepl_arg ? " $makepl_arg" : "",
                         );
    }
    if (my $env = $self->prefs->{pl}{env}) {
        for my $e (keys %$env) {
            $ENV{$e} = $env->{$e};
        }
    }
    if (exists $self->{writemakefile}) {
    } else {
        local($SIG{ALRM}) = sub { die "inactivity_timeout reached\n" };
        my($ret,$pid,$output);
        $@@ = "";
        my $go_via_alarm;
        if ($CPAN::Config->{inactivity_timeout}) {
            require Config;
            if ($Config::Config{d_alarm}
                &&
                $Config::Config{d_alarm} eq "define"
               ) {
                $go_via_alarm++
            } else {
                $CPAN::Frontend->mywarn("Warning: you have configured the config ".
                                        "variable 'inactivity_timeout' to ".
                                        "'$CPAN::Config->{inactivity_timeout}'. But ".
                                        "on this machine the system call 'alarm' ".
                                        "isn't available. This means that we cannot ".
                                        "provide the feature of intercepting long ".
                                        "waiting code and will turn this feature off.\n"
                                       );
                $CPAN::Config->{inactivity_timeout} = 0;
            }
        }
        if ($go_via_alarm) {
            if ( $self->_should_report('pl') ) {
                ($output, $ret) = CPAN::Reporter::record_command(
                    $system,
                    $CPAN::Config->{inactivity_timeout},
                );
                CPAN::Reporter::grade_PL( $self, $system, $output, $ret );
            }
            else {
                eval {
                    alarm $CPAN::Config->{inactivity_timeout};
                    local $SIG{CHLD}; # = sub { wait };
                    if (defined($pid = fork)) {
                        if ($pid) { #parent
                            # wait;
                            waitpid $pid, 0;
                        } else {    #child
                            # note, this exec isn't necessary if
                            # inactivity_timeout is 0. On the Mac I'd
                            # suggest, we set it always to 0.
                            exec $system;
                        }
                    } else {
                        $CPAN::Frontend->myprint("Cannot fork: $!");
                        return;
                    }
                };
                alarm 0;
                if ($@@) {
                    kill 9, $pid;
                    waitpid $pid, 0;
                    my $err = "$@@";
                    $CPAN::Frontend->myprint($err);
                    $self->{writemakefile} = CPAN::Distrostatus->new("NO $err");
                    $@@ = "";
                    $self->store_persistent_state;
                    return $self->goodbye("$system -- TIMED OUT");
                }
            }
        } else {
            if (my $expect_model = $self->_prefs_with_expect("pl")) {
                # XXX probably want to check _should_report here and warn
                # about not being able to use CPAN::Reporter with expect
                $ret = $self->_run_via_expect($system,$expect_model);
                if (! defined $ret
                    && $self->{writemakefile}
                    && $self->{writemakefile}->failed) {
                    # timeout
                    return;
                }
            }
            elsif ( $self->_should_report('pl') ) {
                ($output, $ret) = CPAN::Reporter::record_command($system);
                CPAN::Reporter::grade_PL( $self, $system, $output, $ret );
            }
            else {
                $ret = system($system);
            }
            if ($ret != 0) {
                $self->{writemakefile} = CPAN::Distrostatus
                    ->new("NO '$system' returned status $ret");
                $CPAN::Frontend->mywarn("Warning: No success on command[$system]\n");
                $self->store_persistent_state;
                return $self->goodbye("$system -- NOT OK");
            }
        }
        if (-f "Makefile" || -f "Build") {
            $self->{writemakefile} = CPAN::Distrostatus->new("YES");
            delete $self->{make_clean}; # if cleaned before, enable next
        } else {
            my $makefile = $self->{modulebuild} ? "Build" : "Makefile";
            $self->{writemakefile} = CPAN::Distrostatus
                ->new(qq{NO -- No $makefile created});
            $self->store_persistent_state;
            return $self->goodbye("$system -- NO $makefile created");
        }
d4557 3
a4559 82
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }
    if (my @@prereq = $self->unsat_prereq("later")) {
        if ($prereq[0][0] eq "perl") {
            my $need = "requires perl '$prereq[0][1]'";
            my $id = $self->pretty_id;
            $CPAN::Frontend->mywarn("$id $need; you have only $]; giving up\n");
            $self->{make} = CPAN::Distrostatus->new("NO $need");
            $self->store_persistent_state;
            return $self->goodbye("[prereq] -- NOT OK");
        } else {
            my $follow = eval { $self->follow_prereqs("later",@@prereq); };
            if (0) {
            } elsif ($follow) {
                # signal success to the queuerunner
                return 1;
            } elsif ($@@ && ref $@@ && $@@->isa("CPAN::Exception::RecursiveDependency")) {
                $CPAN::Frontend->mywarn($@@);
                return $self->goodbye("[depend] -- NOT OK");
            }
        }
    }
    if ($CPAN::Signal) {
        delete $self->{force_update};
        return;
    }
    if (my $commandline = $self->prefs->{make}{commandline}) {
        $system = $commandline;
        $ENV{PERL} = CPAN::find_perl;
    } else {
        if ($self->{modulebuild}) {
            unless (-f "Build") {
                my $cwd = CPAN::anycwd();
                $CPAN::Frontend->mywarn("Alert: no Build file available for 'make $self->{id}'".
                                        " in cwd[$cwd]. Danger, Will Robinson!\n");
                $CPAN::Frontend->mysleep(5);
            }
            $system = join " ", $self->_build_command(), $CPAN::Config->{mbuild_arg};
        } else {
            $system = join " ", $self->_make_command(),  $CPAN::Config->{make_arg};
        }
        $system =~ s/\s+$//;
        my $make_arg = $self->make_x_arg("make");
        $system = sprintf("%s%s",
                          $system,
                          $make_arg ? " $make_arg" : "",
                         );
    }
    if (my $env = $self->prefs->{make}{env}) { # overriding the local
                                               # ENV of PL, not the
                                               # outer ENV, but
                                               # unlikely to be a risk
        for my $e (keys %$env) {
            $ENV{$e} = $env->{$e};
        }
    }
    my $expect_model = $self->_prefs_with_expect("make");
    my $want_expect = 0;
    if ( $expect_model && @@{$expect_model->{talk}} ) {
        my $can_expect = $CPAN::META->has_inst("Expect");
        if ($can_expect) {
            $want_expect = 1;
        } else {
            $CPAN::Frontend->mywarn("Expect not installed, falling back to ".
                                    "system()\n");
        }
    }
    my $system_ok;
    if ($want_expect) {
        # XXX probably want to check _should_report here and
        # warn about not being able to use CPAN::Reporter with expect
        $system_ok = $self->_run_via_expect($system,$expect_model) == 0;
    }
    elsif ( $self->_should_report('make') ) {
        my ($output, $ret) = CPAN::Reporter::record_command($system);
        CPAN::Reporter::grade_make( $self, $system, $output, $ret );
        $system_ok = ! $ret;
    }
    else {
        $system_ok = system($system) == 0;
d4561 2
a4562 352
    $self->introduce_myself;
    if ( $system_ok ) {
        $CPAN::Frontend->myprint("  $system -- OK\n");
        $self->{make} = CPAN::Distrostatus->new("YES");
    } else {
        $self->{writemakefile} ||= CPAN::Distrostatus->new("YES");
        $self->{make} = CPAN::Distrostatus->new("NO");
        $CPAN::Frontend->mywarn("  $system -- NOT OK\n");
    }
    $self->store_persistent_state;
}

# CPAN::Distribution::goodbye ;
sub goodbye {
    my($self,$goodbye) = @@_;
    my $id = $self->pretty_id;
    $CPAN::Frontend->mywarn("  $id\n  $goodbye\n");
    return;
}

# CPAN::Distribution::_run_via_expect ;
sub _run_via_expect {
    my($self,$system,$expect_model) = @@_;
    CPAN->debug("system[$system]expect_model[$expect_model]") if $CPAN::DEBUG;
    if ($CPAN::META->has_inst("Expect")) {
        my $expo = Expect->new;  # expo Expect object;
        $expo->spawn($system);
        $expect_model->{mode} ||= "deterministic";
        if ($expect_model->{mode} eq "deterministic") {
            return $self->_run_via_expect_deterministic($expo,$expect_model);
        } elsif ($expect_model->{mode} eq "anyorder") {
            return $self->_run_via_expect_anyorder($expo,$expect_model);
        } else {
            die "Panic: Illegal expect mode: $expect_model->{mode}";
        }
    } else {
        $CPAN::Frontend->mywarn("Expect not installed, falling back to system()\n");
        return system($system);
    }
}

sub _run_via_expect_anyorder {
    my($self,$expo,$expect_model) = @@_;
    my $timeout = $expect_model->{timeout} || 5;
    my $reuse = $expect_model->{reuse};
    my @@expectacopy = @@{$expect_model->{talk}}; # we trash it!
    my $but = "";
  EXPECT: while () {
        my($eof,$ran_into_timeout);
        my @@match = $expo->expect($timeout,
                                  [ eof => sub {
                                        $eof++;
                                    } ],
                                  [ timeout => sub {
                                        $ran_into_timeout++;
                                    } ],
                                  -re => eval"qr{.}",
                                 );
        if ($match[2]) {
            $but .= $match[2];
        }
        $but .= $expo->clear_accum;
        if ($eof) {
            $expo->soft_close;
            return $expo->exitstatus();
        } elsif ($ran_into_timeout) {
            # warn "DEBUG: they are asking a question, but[$but]";
            for (my $i = 0; $i <= $#expectacopy; $i+=2) {
                my($next,$send) = @@expectacopy[$i,$i+1];
                my $regex = eval "qr{$next}";
                # warn "DEBUG: will compare with regex[$regex].";
                if ($but =~ /$regex/) {
                    # warn "DEBUG: will send send[$send]";
                    $expo->send($send);
                    # never allow reusing an QA pair unless they told us
                    splice @@expectacopy, $i, 2 unless $reuse;
                    next EXPECT;
                }
            }
            my $why = "could not answer a question during the dialog";
            $CPAN::Frontend->mywarn("Failing: $why\n");
            $self->{writemakefile} =
                CPAN::Distrostatus->new("NO $why");
            return;
        }
    }
}

sub _run_via_expect_deterministic {
    my($self,$expo,$expect_model) = @@_;
    my $ran_into_timeout;
    my $timeout = $expect_model->{timeout} || 15; # currently unsettable
    my $expecta = $expect_model->{talk};
  EXPECT: for (my $i = 0; $i <= $#$expecta; $i+=2) {
        my($re,$send) = @@$expecta[$i,$i+1];
        CPAN->debug("timeout[$timeout]re[$re]") if $CPAN::DEBUG;
        my $regex = eval "qr{$re}";
        $expo->expect($timeout,
                      [ eof => sub {
                            my $but = $expo->clear_accum;
                            $CPAN::Frontend->mywarn("EOF (maybe harmless)
expected[$regex]\nbut[$but]\n\n");
                            last EXPECT;
                        } ],
                      [ timeout => sub {
                            my $but = $expo->clear_accum;
                            $CPAN::Frontend->mywarn("TIMEOUT
expected[$regex]\nbut[$but]\n\n");
                            $ran_into_timeout++;
                        } ],
                      -re => $regex);
        if ($ran_into_timeout) {
            # note that the caller expects 0 for success
            $self->{writemakefile} =
                CPAN::Distrostatus->new("NO timeout during expect dialog");
            return;
        }
        $expo->send($send);
    }
    $expo->soft_close;
    return $expo->exitstatus();
}

#-> CPAN::Distribution::_validate_distropref
sub _validate_distropref {
    my($self,@@args) = @@_;
    if (
        $CPAN::META->has_inst("CPAN::Kwalify")
        &&
        $CPAN::META->has_inst("Kwalify")
       ) {
        eval {CPAN::Kwalify::_validate("distroprefs",@@args);};
        if ($@@) {
            $CPAN::Frontend->mywarn($@@);
        }
    } else {
        CPAN->debug("not validating '@@args'") if $CPAN::DEBUG;
    }
}

#-> CPAN::Distribution::_find_prefs
sub _find_prefs {
    my($self) = @@_;
    my $distroid = $self->pretty_id;
    #CPAN->debug("distroid[$distroid]") if $CPAN::DEBUG;
    my $prefs_dir = $CPAN::Config->{prefs_dir};
    return if $prefs_dir =~ /^\s*$/;
    eval { File::Path::mkpath($prefs_dir); };
    if ($@@) {
        $CPAN::Frontend->mydie("Cannot create directory $prefs_dir");
    }
    my $yaml_module = CPAN::_yaml_module;
    my @@extensions;
    if ($CPAN::META->has_inst($yaml_module)) {
        push @@extensions, "yml";
    } else {
        my @@fallbacks;
        if ($CPAN::META->has_inst("Data::Dumper")) {
            push @@extensions, "dd";
            push @@fallbacks, "Data::Dumper";
        }
        if ($CPAN::META->has_inst("Storable")) {
            push @@extensions, "st";
            push @@fallbacks, "Storable";
        }
        if (@@fallbacks) {
            local $" = " and ";
            unless ($self->{have_complained_about_missing_yaml}++) {
                $CPAN::Frontend->mywarn("'$yaml_module' not installed, falling back ".
                                        "to @@fallbacks to read prefs '$prefs_dir'\n");
            }
        } else {
            unless ($self->{have_complained_about_missing_yaml}++) {
                $CPAN::Frontend->mywarn("'$yaml_module' not installed, cannot ".
                                        "read prefs '$prefs_dir'\n");
            }
        }
    }
    if (@@extensions) {
        my $dh = DirHandle->new($prefs_dir)
            or die Carp::croak("Couldn't open '$prefs_dir': $!");
      DIRENT: for (sort $dh->read) {
            next if $_ eq "." || $_ eq "..";
            my $exte = join "|", @@extensions;
            next unless /\.($exte)$/;
            my $thisexte = $1;
            my $abs = File::Spec->catfile($prefs_dir, $_);
            if (-f $abs) {
                #CPAN->debug(sprintf "abs[%s]", $abs) if $CPAN::DEBUG;
                my @@distropref;
                if ($thisexte eq "yml") {
                    # need no eval because if we have no YAML we do not try to read *.yml
                    #CPAN->debug(sprintf "before yaml load abs[%s]", $abs) if $CPAN::DEBUG;
                    @@distropref = @@{CPAN->_yaml_loadfile($abs)};
                    #CPAN->debug(sprintf "after yaml load abs[%s]", $abs) if $CPAN::DEBUG;
                } elsif ($thisexte eq "dd") {
                    package CPAN::Eval;
                    no strict;
                    open FH, "<$abs" or $CPAN::Frontend->mydie("Could not open '$abs': $!");
                    local $/;
                    my $eval = <FH>;
                    close FH;
                    eval $eval;
                    if ($@@) {
                        $CPAN::Frontend->mydie("Error in distroprefs file $_\: $@@");
                    }
                    my $i = 1;
                    while (${"VAR".$i}) {
                        push @@distropref, ${"VAR".$i};
                        $i++;
                    }
                } elsif ($thisexte eq "st") {
                    # eval because Storable is never forward compatible
                    eval { @@distropref = @@{scalar Storable::retrieve($abs)}; };
                    if ($@@) {
                        $CPAN::Frontend->mywarn("Error reading distroprefs file ".
                                                "$_, skipping\: $@@");
                        $CPAN::Frontend->mysleep(4);
                        next DIRENT;
                    }
                }
                # $DB::single=1;
                #CPAN->debug(sprintf "#distropref[%d]", scalar @@distropref) if $CPAN::DEBUG;
              ELEMENT: for my $y (0..$#distropref) {
                    my $distropref = $distropref[$y];
                    $self->_validate_distropref($distropref,$abs,$y);
                    my $match = $distropref->{match};
                    unless ($match) {
                        #CPAN->debug("no 'match' in abs[$abs], skipping") if $CPAN::DEBUG;
                        next ELEMENT;
                    }
                    my $ok = 1;
                    # do not take the order of C<keys %$match> because
                    # "module" is by far the slowest
                    my $saw_valid_subkeys = 0;
                    for my $sub_attribute (qw(distribution perl perlconfig module)) {
                        next unless exists $match->{$sub_attribute};
                        $saw_valid_subkeys++;
                        my $qr = eval "qr{$distropref->{match}{$sub_attribute}}";
                        if ($sub_attribute eq "module") {
                            my $okm = 0;
                            #CPAN->debug(sprintf "distropref[%d]", scalar @@distropref) if $CPAN::DEBUG;
                            my @@modules = $self->containsmods;
                            #CPAN->debug(sprintf "modules[%s]", join(",",@@modules)) if $CPAN::DEBUG;
                          MODULE: for my $module (@@modules) {
                                $okm ||= $module =~ /$qr/;
                                last MODULE if $okm;
                            }
                            $ok &&= $okm;
                        } elsif ($sub_attribute eq "distribution") {
                            my $okd = $distroid =~ /$qr/;
                            $ok &&= $okd;
                        } elsif ($sub_attribute eq "perl") {
                            my $okp = CPAN::find_perl =~ /$qr/;
                            $ok &&= $okp;
                        } elsif ($sub_attribute eq "perlconfig") {
                            for my $perlconfigkey (keys %{$match->{perlconfig}}) {
                                my $perlconfigval = $match->{perlconfig}->{$perlconfigkey};
                                # XXX should probably warn if Config does not exist
                                my $okpc = $Config::Config{$perlconfigkey} =~ /$perlconfigval/;
                                $ok &&= $okpc;
                                last if $ok == 0;
                            }
                        } else {
                            $CPAN::Frontend->mydie("Nonconforming .$thisexte file '$abs': ".
                                                   "unknown sub_attribut '$sub_attribute'. ".
                                                   "Please ".
                                                   "remove, cannot continue.");
                        }
                        last if $ok == 0; # short circuit
                    }
                    unless ($saw_valid_subkeys) {
                        $CPAN::Frontend->mydie("Nonconforming .$thisexte file '$abs': ".
                                               "missing match/* subattribute. ".
                                               "Please ".
                                               "remove, cannot continue.");
                    }
                    #CPAN->debug(sprintf "ok[%d]", $ok) if $CPAN::DEBUG;
                    if ($ok) {
                        return {
                                prefs => $distropref,
                                prefs_file => $abs,
                                prefs_file_doc => $y,
                               };
                    }

                }
            }
        }
        $dh->close;
    }
    return;
}

# CPAN::Distribution::prefs
sub prefs {
    my($self) = @@_;
    if (exists $self->{negative_prefs_cache}
        &&
        $self->{negative_prefs_cache} != $CPAN::CurrentCommandId
       ) {
        delete $self->{negative_prefs_cache};
        delete $self->{prefs};
    }
    if (exists $self->{prefs}) {
        return $self->{prefs}; # XXX comment out during debugging
    }
    if ($CPAN::Config->{prefs_dir}) {
        CPAN->debug("prefs_dir[$CPAN::Config->{prefs_dir}]") if $CPAN::DEBUG;
        my $prefs = $self->_find_prefs();
        $prefs ||= ""; # avoid warning next line
        CPAN->debug("prefs[$prefs]") if $CPAN::DEBUG;
        if ($prefs) {
            for my $x (qw(prefs prefs_file prefs_file_doc)) {
                $self->{$x} = $prefs->{$x};
            }
            my $bs = sprintf(
                             "%s[%s]",
                             File::Basename::basename($self->{prefs_file}),
                             $self->{prefs_file_doc},
                            );
            my $filler1 = "_" x 22;
            my $filler2 = int(66 - length($bs))/2;
            $filler2 = 0 if $filler2 < 0;
            $filler2 = " " x $filler2;
            $CPAN::Frontend->myprint("
$filler1 D i s t r o P r e f s $filler1
$filler2 $bs $filler2
");
            $CPAN::Frontend->mysleep(1);
            return $self->{prefs};
        }
    }
    $self->{negative_prefs_cache} = $CPAN::CurrentCommandId;
    return $self->{prefs} = +{};
}

# CPAN::Distribution::make_x_arg
sub make_x_arg {
    my($self, $whixh) = @@_;
    my $make_x_arg;
    my $prefs = $self->prefs;
    if (
        $prefs
        && exists $prefs->{$whixh}
        && exists $prefs->{$whixh}{args}
        && $prefs->{$whixh}{args}
       ) {
        $make_x_arg = join(" ",
                           map {CPAN::HandleConfig
                                 ->safe_quote($_)} @@{$prefs->{$whixh}{args}},
                          );
d4564 8
a4571 26
    my $what = sprintf "make%s_arg", $whixh eq "make" ? "" : $whixh;
    $make_x_arg ||= $CPAN::Config->{$what};
    return $make_x_arg;
}

# CPAN::Distribution::_make_command
sub _make_command {
    my ($self) = @@_;
    if ($self) {
        return
            CPAN::HandleConfig
                ->safe_quote(
                             CPAN::HandleConfig->prefs_lookup($self,
                                                              q{make})
                             || $Config::Config{make}
                             || 'make'
                            );
    } else {
        # Old style call, without object. Deprecated
        Carp::confess("CPAN::_make_command() used as function. Don't Do That.");
        return
          safe_quote(undef,
                     CPAN::HandleConfig->prefs_lookup($self,q{make})
                     || $CPAN::Config->{make}
                     || $Config::Config{make}
                     || 'make');
a4574 1
#-> sub CPAN::Distribution::follow_prereqs ;
d4577 7
a4583 19
    my($slot) = shift;
    my(@@prereq_tuples) = grep {$_->[0] ne "perl"} @@_;
    return unless @@prereq_tuples;
    my @@prereq = map { $_->[0] } @@prereq_tuples;
    my $pretty_id = $self->pretty_id;
    my %map = (
               b => "build_requires",
               r => "requires",
               c => "commandline",
              );
    my($filler1,$filler2,$filler3,$filler4);
    # $DB::single=1;
    my $unsat = "Unsatisfied dependencies detected during";
    my $w = length($unsat) > length($pretty_id) ? length($unsat) : length($pretty_id);
    {
        my $r = int(($w - length($unsat))/2);
        my $l = $w - length($unsat) - $r;
        $filler1 = "-"x4 . " "x$l;
        $filler2 = " "x$r . "-"x4 . "\n";
a4584 11
    {
        my $r = int(($w - length($pretty_id))/2);
        my $l = $w - length($pretty_id) - $r;
        $filler3 = "-"x4 . " "x$l;
        $filler4 = " "x$r . "-"x4 . "\n";
    }
    $CPAN::Frontend->
        myprint("$filler1 $unsat $filler2".
                "$filler3 $pretty_id $filler4".
                join("", map {"    $_->[0] \[$map{$_->[1]}]\n"} @@prereq_tuples),
               );
d4587 1
a4587 1
        $follow = 1;
d4589 2
a4590 1
        my $answer = CPAN::Shell::colorable_makemaker_prompt(
d4593 1
a4593 1
        $follow = $answer =~ /^\s*y/i;
d4595 2
a4596 2
        local($") = ", ";
        $CPAN::Frontend->
a4599 1
        my $id = $self->id;
d4603 1
a4603 8
            my $any = CPAN::Shell->expandany($p);
            $self->{$slot . "_for"}{$any->id}++;
            if ($any) {
                $any->color_cmd_tmps(0,2);
            } else {
                $CPAN::Frontend->mywarn("Warning (maybe a bug): Cannot expand prereq '$p'\n");
                $CPAN::Frontend->mysleep(2);
            }
d4605 2
a4606 4
        # queue them and re-queue yourself
        CPAN::Queue->jumpqueue({qmod => $id, reqtype => $self->{reqtype}},
                               map {+{qmod=>$_->[0],reqtype=>$_->[1]}} reverse @@prereq_tuples);
        $self->{$slot} = "Delayed until after prerequisites";
a4608 1
    return;
a4611 2
# return ([Foo=>1],[Bar=>1.2]) for normal modules
# return ([perl=>5.008]) if we need a newer perl than we are running under
d4613 2
a4614 20
    my($self,$slot) = @@_;
    my(%merged,$prereq_pm);
    my $prefs_depends = $self->prefs->{depends}||{};
    if ($slot eq "configure_requires_later") {
        my $meta_yml = $self->parse_meta_yml();
        %merged = (%{$meta_yml->{configure_requires}||{}},
                   %{$prefs_depends->{configure_requires}||{}});
        $prereq_pm = {}; # configure_requires defined as "b"
    } elsif ($slot eq "later") {
        my $prereq_pm_0 = $self->prereq_pm || {};
        for my $reqtype (qw(requires build_requires)) {
            $prereq_pm->{$reqtype} = {%{$prereq_pm_0->{$reqtype}||{}}}; # copy to not pollute it
            for my $k (keys %{$prefs_depends->{$reqtype}||{}}) {
                $prereq_pm->{$reqtype}{$k} = $prefs_depends->{$reqtype}{$k};
            }
        }
        %merged = (%{$prereq_pm->{requires}||{}},%{$prereq_pm->{build_requires}||{}});
    } else {
        die "Panic: illegal slot '$slot'";
    }
d4616 10
a4625 23
    my @@merged = %merged;
    CPAN->debug("all merged_prereqs[@@merged]") if $CPAN::DEBUG;
  NEED: while (my($need_module, $need_version) = each %merged) {
        my($available_version,$available_file,$nmo);
        if ($need_module eq "perl") {
            $available_version = $];
            $available_file = CPAN::find_perl;
        } else {
            $nmo = $CPAN::META->instance("CPAN::Module",$need_module);
            next if $nmo->uptodate;
            $available_file = $nmo->available_file;

            # if they have not specified a version, we accept any installed one
            if (defined $available_file
                and ( # a few quick shortcurcuits
                     not defined $need_version
                     or $need_version eq '0'    # "==" would trigger warning when not numeric
                     or $need_version eq "undef"
                    )) {
                next NEED;
            }

            $available_version = $nmo->available_version;
d4631 1
a4631 2
        if (defined $available_file) {
            my(@@all_requirements) = split /\s*,\s*/, $need_version;
d4633 11
a4643 34
            my $ok = 0;
          RQ: for my $rq (@@all_requirements) {
                if ($rq =~ s|>=\s*||) {
                } elsif ($rq =~ s|>\s*||) {
                    # 2005-12: one user
                    if (CPAN::Version->vgt($available_version,$rq)) {
                        $ok++;
                    }
                    next RQ;
                } elsif ($rq =~ s|!=\s*||) {
                    # 2005-12: no user
                    if (CPAN::Version->vcmp($available_version,$rq)) {
                        $ok++;
                        next RQ;
                    } else {
                        last RQ;
                    }
                } elsif ($rq =~ m|<=?\s*|) {
                    # 2005-12: no user
                    $CPAN::Frontend->mywarn("Downgrading not supported (rq[$rq])\n");
                    $ok++;
                    next RQ;
                }
                if (! CPAN::Version->vgt($rq, $available_version)) {
                    $ok++;
                }
                CPAN->debug(sprintf("need_module[%s]available_file[%s]".
                                    "available_version[%s]rq[%s]ok[%d]",
                                    $need_module,
                                    $available_file,
                                    $available_version,
                                    CPAN::Version->readable($rq),
                                    $ok,
                                   )) if $CPAN::DEBUG;
a4644 1
            next NEED if $ok == @@all_requirements;
d4647 1
a4647 6
        if ($need_module eq "perl") {
            return ["perl", $need_version];
        }
        $self->{sponsored_mods}{$need_module} ||= 0;
        CPAN->debug("need_module[$need_module]s/s/n[$self->{sponsored_mods}{$need_module}]") if $CPAN::DEBUG;
        if ($self->{sponsored_mods}{$need_module}++) {
d4649 1
a4649 2
            # not available. So we do ... what??

d4651 1
a4651 78

            # The following "next" was a very problematic construct.
            # It helped a lot but broke some day and had to be
            # replaced.

            # We must be able to deal with modules that come again and
            # again as a prereq and have themselves prereqs and the
            # queue becomes long but finally we would find the correct
            # order. The RecursiveDependency check should trigger a
            # die when it's becoming too weird. Unfortunately removing
            # this next breaks many other things.

            # The bug that brought this up is described in Todo under
            # "5.8.9 cannot install Compress::Zlib"

            # next; # this is the next that had to go away

            # The following "next NEED" are fine and the error message
            # explains well what is going on. For example when the DBI
            # fails and consequently DBD::SQLite fails and now we are
            # processing CPAN::SQLite. Then we must have a "next" for
            # DBD::SQLite. How can we get it and how can we identify
            # all other cases we must identify?

            my $do = $nmo->distribution;
            next NEED unless $do; # not on CPAN
            if (CPAN::Version->vcmp($need_version, $nmo->ro->{CPAN_VERSION}) > 0){
                $CPAN::Frontend->mywarn("Warning: Prerequisite ".
                                        "'$need_module => $need_version' ".
                                        "for '$self->{ID}' seems ".
                                        "not available according to the indexes\n"
                                       );
                next NEED;
            }
          NOSAYER: for my $nosayer (
                                    "unwrapped",
                                    "writemakefile",
                                    "signature_verify",
                                    "make",
                                    "make_test",
                                    "install",
                                    "make_clean",
                                   ) {
                if ($do->{$nosayer}) {
                    if (UNIVERSAL::can($do->{$nosayer},"failed") ?
                        $do->{$nosayer}->failed :
                        $do->{$nosayer} =~ /^NO/) {
                        if ($nosayer eq "make_test"
                            &&
                            $do->{make_test}{COMMANDID} != $CPAN::CurrentCommandId
                           ) {
                            next NOSAYER;
                        }
                        $CPAN::Frontend->mywarn("Warning: Prerequisite ".
                                                "'$need_module => $need_version' ".
                                                "for '$self->{ID}' failed when ".
                                                "processing '$do->{ID}' with ".
                                                "'$nosayer => $do->{$nosayer}'. Continuing, ".
                                                "but chances to succeed are limited.\n"
                                               );
                        next NEED;
                    } else { # the other guy succeeded
                        if ($nosayer eq "install") {
                            # we had this with
                            # DMAKI/DateTime-Calendar-Chinese-0.05.tar.gz
                            # 2007-03
                            $CPAN::Frontend->mywarn("Warning: Prerequisite ".
                                                    "'$need_module => $need_version' ".
                                                    "for '$self->{ID}' already installed ".
                                                    "but installation looks suspicious. ".
                                                    "Skipping another installation attempt, ".
                                                    "to prevent looping endlessly.\n"
                                                   );
                            next NEED;
                        }
                    }
                }
            }
d4653 1
a4653 2
        my $needed_as = exists $prereq_pm->{requires}{$need_module} ? "r" : "b";
        push @@need, [$need_module,$needed_as];
a4654 2
    my @@unfolded = map { "[".join(",",@@$_)."]" } @@need;
    CPAN->debug("returning from unsat_prereq[@@unfolded]") if $CPAN::DEBUG;
d4658 40
a4697 26
#-> sub CPAN::Distribution::read_yaml ;
sub read_yaml {
    my($self) = @@_;
    return $self->{yaml_content} if exists $self->{yaml_content};
    my $build_dir = $self->{build_dir};
    my $yaml = File::Spec->catfile($build_dir,"META.yml");
    $self->debug("yaml[$yaml]") if $CPAN::DEBUG;
    return unless -f $yaml;
    eval { $self->{yaml_content} = CPAN->_yaml_loadfile($yaml)->[0]; };
    if ($@@) {
        $CPAN::Frontend->mywarn("Could not read ".
                                "'$yaml'. Falling back to other ".
                                "methods to determine prerequisites\n");
        return $self->{yaml_content} = undef; # if we die, then we
                                              # cannot read YAML's own
                                              # META.yml
    }
    # not "authoritative"
    if (not exists $self->{yaml_content}{dynamic_config}
        or $self->{yaml_content}{dynamic_config}
       ) {
        $self->{yaml_content} = undef;
    }
    $self->debug(sprintf "yaml_content[%s]", $self->{yaml_content} || "UNDEF")
        if $CPAN::DEBUG;
    return $self->{yaml_content};
d4700 2
a4701 2
#-> sub CPAN::Distribution::prereq_pm ;
sub prereq_pm {
d4703 4
a4706 134
    $self->{prereq_pm_detected} ||= 0;
    CPAN->debug("ID[$self->{ID}]prereq_pm_detected[$self->{prereq_pm_detected}]") if $CPAN::DEBUG;
    return $self->{prereq_pm} if $self->{prereq_pm_detected};
    return unless $self->{writemakefile}  # no need to have succeeded
                                          # but we must have run it
        || $self->{modulebuild};
    CPAN->debug(sprintf "writemakefile[%s]modulebuild[%s]",
                $self->{writemakefile}||"",
                $self->{modulebuild}||"",
               ) if $CPAN::DEBUG;
    my($req,$breq);
    if (my $yaml = $self->read_yaml) { # often dynamic_config prevents a result here
        $req =  $yaml->{requires} || {};
        $breq =  $yaml->{build_requires} || {};
        undef $req unless ref $req eq "HASH" && %$req;
        if ($req) {
            if ($yaml->{generated_by} &&
                $yaml->{generated_by} =~ /ExtUtils::MakeMaker version ([\d\._]+)/) {
                my $eummv = do { local $^W = 0; $1+0; };
                if ($eummv < 6.2501) {
                    # thanks to Slaven for digging that out: MM before
                    # that could be wrong because it could reflect a
                    # previous release
                    undef $req;
                }
            }
            my $areq;
            my $do_replace;
            while (my($k,$v) = each %{$req||{}}) {
                if ($v =~ /\d/) {
                    $areq->{$k} = $v;
                } elsif ($k =~ /[A-Za-z]/ &&
                         $v =~ /[A-Za-z]/ &&
                         $CPAN::META->exists("Module",$v)
                        ) {
                    $CPAN::Frontend->mywarn("Suspicious key-value pair in META.yml's ".
                                            "requires hash: $k => $v; I'll take both ".
                                            "key and value as a module name\n");
                    $CPAN::Frontend->mysleep(1);
                    $areq->{$k} = 0;
                    $areq->{$v} = 0;
                    $do_replace++;
                }
            }
            $req = $areq if $do_replace;
        }
    }
    unless ($req || $breq) {
        my $build_dir = $self->{build_dir} or die "Panic: no build_dir?";
        my $makefile = File::Spec->catfile($build_dir,"Makefile");
        my $fh;
        if (-f $makefile
            and
            $fh = FileHandle->new("<$makefile\0")) {
            CPAN->debug("Getting prereq from Makefile") if $CPAN::DEBUG;
            local($/) = "\n";
            while (<$fh>) {
                last if /MakeMaker post_initialize section/;
                my($p) = m{^[\#]
                           \s+PREREQ_PM\s+=>\s+(.+)
                       }x;
                next unless $p;
                # warn "Found prereq expr[$p]";

                #  Regexp modified by A.Speer to remember actual version of file
                #  PREREQ_PM hash key wants, then add to
                while ( $p =~ m/(?:\s)([\w\:]+)=>(q\[.*?\]|undef),?/g ) {
                    # In case a prereq is mentioned twice, complain.
                    if ( defined $req->{$1} ) {
                        warn "Warning: PREREQ_PM mentions $1 more than once, ".
                            "last mention wins";
                    }
                    my($m,$n) = ($1,$2);
                    if ($n =~ /^q\[(.*?)\]$/) {
                        $n = $1;
                    }
                    $req->{$m} = $n;
                }
                last;
            }
        }
    }
    unless ($req || $breq) {
        my $build_dir = $self->{build_dir} or die "Panic: no build_dir?";
        my $buildfile = File::Spec->catfile($build_dir,"Build");
        if (-f $buildfile) {
            CPAN->debug("Found '$buildfile'") if $CPAN::DEBUG;
            my $build_prereqs = File::Spec->catfile($build_dir,"_build","prereqs");
            if (-f $build_prereqs) {
                CPAN->debug("Getting prerequisites from '$build_prereqs'") if $CPAN::DEBUG;
                my $content = do { local *FH;
                                   open FH, $build_prereqs
                                       or $CPAN::Frontend->mydie("Could not open ".
                                                                 "'$build_prereqs': $!");
                                   local $/;
                                   <FH>;
                               };
                my $bphash = eval $content;
                if ($@@) {
                } else {
                    $req  = $bphash->{requires} || +{};
                    $breq = $bphash->{build_requires} || +{};
                }
            }
        }
    }
    if (-f "Build.PL"
        && ! -f "Makefile.PL"
        && ! exists $req->{"Module::Build"}
        && ! $CPAN::META->has_inst("Module::Build")) {
        $CPAN::Frontend->mywarn("  Warning: CPAN.pm discovered Module::Build as ".
                                "undeclared prerequisite.\n".
                                "  Adding it now as such.\n"
                               );
        $CPAN::Frontend->mysleep(5);
        $req->{"Module::Build"} = 0;
        delete $self->{writemakefile};
    }
    if ($req || $breq) {
        $self->{prereq_pm_detected}++;
        return $self->{prereq_pm} = { requires => $req, build_requires => $breq };
    }
}

#-> sub CPAN::Distribution::test ;
sub test {
    my($self) = @@_;
    if (my $goto = $self->prefs->{goto}) {
        return $self->goto($goto);
    }
    $self->make;
    if ($CPAN::Signal) {
      delete $self->{force_update};
      return;
d4708 3
a4710 4
    # warn "XDEBUG: checking for notest: $self->{notest} $self";
    if ($self->{notest}) {
        $CPAN::Frontend->myprint("Skipping test because of notest pragma\n");
        return 1;
a4711 12

    my $make = $self->{modulebuild} ? "Build" : "make";

    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");

    $CPAN::META->set_perl5lib;
    local $ENV{MAKEFLAGS}; # protect us from outer make calls

    $CPAN::Frontend->myprint("Running $make test\n");

d4713 7
a4719 7
        my @@e;
        if ($self->{make} or $self->{later}) {
            # go ahead
        } else {
            push @@e,
                "Make had some problems, won't test";
        }
d4721 1
a4721 6
        exists $self->{make} and
            (
             UNIVERSAL::can($self->{make},"failed") ?
             $self->{make}->failed :
             $self->{make} =~ /^NO/
            ) and push @@e, "Can't test without successful make";
d4723 1
a4723 3
        if ($self->{badtestcnt} > 0) {
            require Data::Dumper;
            CPAN->debug(sprintf "NOREPEAT[%s]", Data::Dumper::Dumper($self)) if $CPAN::DEBUG;
a4724 1
        }
d4726 2
a4727 2
        push @@e, $self->{later} if $self->{later};
        push @@e, $self->{configure_requires_later} if $self->{configure_requires_later};
d4729 1
a4729 26
        if (exists $self->{build_dir}) {
            if (exists $self->{make_test}) {
                if (
                    UNIVERSAL::can($self->{make_test},"failed") ?
                    $self->{make_test}->failed :
                    $self->{make_test} =~ /^NO/
                   ) {
                    if (
                        UNIVERSAL::can($self->{make_test},"commandid")
                        &&
                        $self->{make_test}->commandid == $CPAN::CurrentCommandId
                       ) {
                        push @@e, "Has already been tested within this command";
                    }
                } else {
                    push @@e, "Has already been tested successfully";
                }
            }
        } elsif (!@@e) {
            push @@e, "Has no own directory";
        }
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
        unless (chdir $self->{build_dir}) {
            push @@e, "Couldn't chdir to '$self->{build_dir}': $!";
        }
        $CPAN::Frontend->mywarn(join "", map {"  $_\n"} @@e) and return if @@e;
d4731 4
a4734 2
    $self->debug("Changed directory to $self->{build_dir}")
        if $CPAN::DEBUG;
d4741 11
a4751 138
    if ($self->{modulebuild}) {
        my $v = CPAN::Shell->expand("Module","Test::Harness")->inst_version;
        if (CPAN::Version->vlt($v,2.62)) {
            $CPAN::Frontend->mywarn(qq{The version of your Test::Harness is only
  '$v', you need at least '2.62'. Please upgrade your Test::Harness.\n});
            $self->{make_test} = CPAN::Distrostatus->new("NO Test::Harness too old");
            return;
        }
    }

    my $system;
    my $prefs_test = $self->prefs->{test};
    if (my $commandline
        = exists $prefs_test->{commandline} ? $prefs_test->{commandline} : "") {
        $system = $commandline;
        $ENV{PERL} = CPAN::find_perl;
    } elsif ($self->{modulebuild}) {
        $system = sprintf "%s test", $self->_build_command();
    } else {
        $system = join " ", $self->_make_command(), "test";
    }
    my $make_test_arg = $self->make_x_arg("test");
    $system = sprintf("%s%s",
                      $system,
                      $make_test_arg ? " $make_test_arg" : "",
                     );
    my($tests_ok);
    my %env;
    while (my($k,$v) = each %ENV) {
        next unless defined $v;
        $env{$k} = $v;
    }
    local %ENV = %env;
    if (my $env = $self->prefs->{test}{env}) {
        for my $e (keys %$env) {
            $ENV{$e} = $env->{$e};
        }
    }
    my $expect_model = $self->_prefs_with_expect("test");
    my $want_expect = 0;
    if ( $expect_model && @@{$expect_model->{talk}} ) {
        my $can_expect = $CPAN::META->has_inst("Expect");
        if ($can_expect) {
            $want_expect = 1;
        } else {
            $CPAN::Frontend->mywarn("Expect not installed, falling back to ".
                                    "testing without\n");
        }
    }
    if ($want_expect) {
        if ($self->_should_report('test')) {
            $CPAN::Frontend->mywarn("Reporting via CPAN::Reporter is currently ".
                                    "not supported when distroprefs specify ".
                                    "an interactive test\n");
        }
        $tests_ok = $self->_run_via_expect($system,$expect_model) == 0;
    } elsif ( $self->_should_report('test') ) {
        $tests_ok = CPAN::Reporter::test($self, $system);
    } else {
        $tests_ok = system($system) == 0;
    }
    $self->introduce_myself;
    if ( $tests_ok ) {
        {
            my @@prereq;

            # local $CPAN::DEBUG = 16; # Distribution
            for my $m (keys %{$self->{sponsored_mods}}) {
                next unless $self->{sponsored_mods}{$m} > 0;
                my $m_obj = CPAN::Shell->expand("Module",$m) or next;
                # XXX we need available_version which reflects
                # $ENV{PERL5LIB} so that already tested but not yet
                # installed modules are counted.
                my $available_version = $m_obj->available_version;
                my $available_file = $m_obj->available_file;
                if ($available_version &&
                    !CPAN::Version->vlt($available_version,$self->{prereq_pm}{$m})
                   ) {
                    CPAN->debug("m[$m] good enough available_version[$available_version]")
                        if $CPAN::DEBUG;
                } elsif ($available_file
                         && (
                             !$self->{prereq_pm}{$m}
                             ||
                             $self->{prereq_pm}{$m} == 0
                            )
                        ) {
                    # lex Class::Accessor::Chained::Fast which has no $VERSION
                    CPAN->debug("m[$m] have available_file[$available_file]")
                        if $CPAN::DEBUG;
                } else {
                    push @@prereq, $m;
                }
            }
            if (@@prereq) {
                my $cnt = @@prereq;
                my $which = join ",", @@prereq;
                my $but = $cnt == 1 ? "one dependency not OK ($which)" :
                    "$cnt dependencies missing ($which)";
                $CPAN::Frontend->mywarn("Tests succeeded but $but\n");
                $self->{make_test} = CPAN::Distrostatus->new("NO $but");
                $self->store_persistent_state;
                return $self->goodbye("[dependencies] -- NA");
            }
        }

        $CPAN::Frontend->myprint("  $system -- OK\n");
        $self->{make_test} = CPAN::Distrostatus->new("YES");
        $CPAN::META->is_tested($self->{build_dir},$self->{make_test}{TIME});
        # probably impossible to need the next line because badtestcnt
        # has a lifespan of one command
        delete $self->{badtestcnt};
    } else {
        $self->{make_test} = CPAN::Distrostatus->new("NO");
        $self->{badtestcnt}++;
        $CPAN::Frontend->mywarn("  $system -- NOT OK\n");
        CPAN::Shell->optprint
              ("hint",
               sprintf
               ("//hint// to see the cpan-testers results for installing this module, try:
  reports %s\n",
                $self->pretty_id));
    }
    $self->store_persistent_state;
}

sub _prefs_with_expect {
    my($self,$where) = @@_;
    return unless my $prefs = $self->prefs;
    return unless my $where_prefs = $prefs->{$where};
    if ($where_prefs->{expect}) {
        return {
                mode => "deterministic",
                timeout => 15,
                talk => $where_prefs->{expect},
               };
    } elsif ($where_prefs->{"eexpect"}) {
        return $where_prefs->{"eexpect"};
a4752 1
    return;
d4758 1
a4758 17
    my $make = $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint("Running $make clean\n");
    unless (exists $self->{archived}) {
        $CPAN::Frontend->mywarn("Distribution seems to have never been unzipped".
                                "/untarred, nothing done\n");
        return 1;
    }
    unless (exists $self->{build_dir}) {
        $CPAN::Frontend->mywarn("Distribution has no own directory, nothing to do.\n");
        return 1;
    }
    if (exists $self->{writemakefile}
        and $self->{writemakefile}->failed
       ) {
        $CPAN::Frontend->mywarn("No Makefile, don't know how to 'make clean'\n");
        return 1;
    }
d4760 1
a4760 1
        my @@e;
d4763 2
a4764 1
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
d4766 3
a4768 3
    chdir $self->{build_dir} or
        Carp::confess("Couldn't chdir to $self->{build_dir}: $!");
    $self->debug("Changed directory to $self->{build_dir}") if $CPAN::DEBUG;
d4775 2
a4776 15
    my $system;
    if ($self->{modulebuild}) {
        unless (-f "Build") {
            my $cwd = CPAN::anycwd();
            $CPAN::Frontend->mywarn("Alert: no Build file available for 'clean $self->{id}".
                                    " in cwd[$cwd]. Danger, Will Robinson!");
            $CPAN::Frontend->mysleep(5);
        }
        $system = sprintf "%s clean", $self->_build_command();
    } else {
        $system  = join " ", $self->_make_command(), "clean";
    }
    my $system_ok = system($system) == 0;
    $self->introduce_myself;
    if ( $system_ok ) {
d4786 6
a4791 10
      for my $k (qw(
                    force_update
                    install
                    writemakefile
                    make
                    make_test
                   )) {
          delete $self->{$k};
      }
      $self->{make_clean} = CPAN::Distrostatus->new("YES");
d4796 1
a4796 2
      $self->{make_clean} = CPAN::Distrostatus->new("NO");
      $CPAN::Frontend->mywarn(qq{  $system -- NOT OK\n});
d4798 3
a4800 2
      # 2006-02-27: seems silly to me to force a make now
      # $self->force("make"); # so that this directory won't be used again
a4802 29
    $self->store_persistent_state;
}

#-> sub CPAN::Distribution::goto ;
sub goto {
    my($self,$goto) = @@_;
    $goto = $self->normalize($goto);
    my $why = sprintf(
                      "Goto '$goto' via prefs file '%s' doc %d",
                      $self->{prefs_file},
                      $self->{prefs_file_doc},
                     );
    $self->{unwrapped} = CPAN::Distrostatus->new("NO $why");
    # 2007-07-16 akoenig : Better than NA would be if we could inherit
    # the status of the $goto distro but given the exceptional nature
    # of 'goto' I feel reluctant to implement it
    my $goodbye_message = "[goto] -- NA $why";
    $self->goodbye($goodbye_message);

    # inject into the queue

    CPAN::Queue->delete($self->id);
    CPAN::Queue->jumpqueue({qmod => $goto, reqtype => $self->{reqtype}});

    # and run where we left off

    my($method) = (caller(1))[3];
    CPAN->instance("CPAN::Distribution",$goto)->$method();
    CPAN::Queue->delete_first($goto);
d4808 2
a4809 8
    if (my $goto = $self->prefs->{goto}) {
        return $self->goto($goto);
    }
    # $DB::single=1;
    unless ($self->{badtestcnt}) {
        $self->test;
    }
    if ($CPAN::Signal) {
d4813 1
a4813 2
    my $make = $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint("Running $make install\n");
d4815 2
a4816 48
        my @@e;
        if ($self->{make} or $self->{later}) {
            # go ahead
        } else {
            push @@e,
                "Make had some problems, won't install";
        }

        exists $self->{make} and
            (
             UNIVERSAL::can($self->{make},"failed") ?
             $self->{make}->failed :
             $self->{make} =~ /^NO/
            ) and
            push @@e, "Make had returned bad status, install seems impossible";

        if (exists $self->{build_dir}) {
        } elsif (!@@e) {
            push @@e, "Has no own directory";
        }

        if (exists $self->{make_test} and
            (
             UNIVERSAL::can($self->{make_test},"failed") ?
             $self->{make_test}->failed :
             $self->{make_test} =~ /^NO/
            )) {
            if ($self->{force_update}) {
                $self->{make_test}->text("FAILED but failure ignored because ".
                                         "'force' in effect");
            } else {
                push @@e, "make test had returned bad status, ".
                    "won't install without force"
            }
        }
        if (exists $self->{install}) {
            if (UNIVERSAL::can($self->{install},"text") ?
                $self->{install}->text eq "YES" :
                $self->{install} =~ /^YES/
               ) {
                $CPAN::Frontend->myprint("  Already done\n");
                $CPAN::META->is_installed($self->{build_dir});
                return 1;
            } else {
                # comment in Todo on 2006-02-11; maybe retry?
                push @@e, "Already tried without success";
            }
        }
d4818 2
a4819 2
        push @@e, $self->{later} if $self->{later};
        push @@e, $self->{configure_requires_later} if $self->{configure_requires_later};
d4821 23
a4843 8
        $CPAN::Frontend->myprint(join "", map {"  $_\n"} @@e) and return if @@e;
        unless (chdir $self->{build_dir}) {
            push @@e, "Couldn't chdir to '$self->{build_dir}': $!";
        }
        $CPAN::Frontend->mywarn(join "", map {"  $_\n"} @@e) and return if @@e;
    }
    $self->debug("Changed directory to $self->{build_dir}")
        if $CPAN::DEBUG;
d4850 3
a4852 57
    my $system;
    if (my $commandline = $self->prefs->{install}{commandline}) {
        $system = $commandline;
        $ENV{PERL} = CPAN::find_perl;
    } elsif ($self->{modulebuild}) {
        my($mbuild_install_build_command) =
            exists $CPAN::HandleConfig::keys{mbuild_install_build_command} &&
                $CPAN::Config->{mbuild_install_build_command} ?
                    $CPAN::Config->{mbuild_install_build_command} :
                        $self->_build_command();
        $system = sprintf("%s install %s",
                          $mbuild_install_build_command,
                          $CPAN::Config->{mbuild_install_arg},
                         );
    } else {
        my($make_install_make_command) =
            CPAN::HandleConfig->prefs_lookup($self,
                                             q{make_install_make_command})
                  || $self->_make_command();
        $system = sprintf("%s install %s",
                          $make_install_make_command,
                          $CPAN::Config->{make_install_arg},
                         );
    }

    my($stderr) = $^O eq "MSWin32" ? "" : " 2>&1 ";
    my $brip = CPAN::HandleConfig->prefs_lookup($self,
                                                q{build_requires_install_policy});
    $brip ||="ask/yes";
    my $id = $self->id;
    my $reqtype = $self->{reqtype} ||= "c"; # in doubt it was a command
    my $want_install = "yes";
    if ($reqtype eq "b") {
        if ($brip eq "no") {
            $want_install = "no";
        } elsif ($brip =~ m|^ask/(.+)|) {
            my $default = $1;
            $default = "yes" unless $default =~ /^(y|n)/i;
            $want_install =
                CPAN::Shell::colorable_makemaker_prompt
                      ("$id is just needed temporarily during building or testing. ".
                       "Do you want to install it permanently? (Y/n)",
                       $default);
        }
    }
    unless ($want_install =~ /^y/i) {
        my $is_only = "is only 'build_requires'";
        $CPAN::Frontend->mywarn("Not installing because $is_only\n");
        $self->{install} = CPAN::Distrostatus->new("NO -- $is_only");
        delete $self->{force_update};
        return;
    }
    local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                           ? $ENV{PERL5LIB}
                           : ($ENV{PERLLIB} || "");

    $CPAN::META->set_perl5lib;
d4855 3
a4857 5
    while (<$pipe>) {
        print $_; # intentionally NOT use Frontend->myprint because it
                  # looks irritating when we markup in color what we
                  # just pass through from an external program
        $makeout .= $_;
d4860 11
a4870 30
    my $close_ok = $? == 0;
    $self->introduce_myself;
    if ( $close_ok ) {
        $CPAN::Frontend->myprint("  $system -- OK\n");
        $CPAN::META->is_installed($self->{build_dir});
        $self->{install} = CPAN::Distrostatus->new("YES");
    } else {
        $self->{install} = CPAN::Distrostatus->new("NO");
        $CPAN::Frontend->mywarn("  $system -- NOT OK\n");
        my $mimc =
            CPAN::HandleConfig->prefs_lookup($self,
                                             q{make_install_make_command});
        if (
            $makeout =~ /permission/s
            && $> > 0
            && (
                ! $mimc
                || $mimc eq (CPAN::HandleConfig->prefs_lookup($self,
                                                              q{make}))
               )
           ) {
            $CPAN::Frontend->myprint(
                                     qq{----\n}.
                                     qq{  You may have to su }.
                                     qq{to root to install the package\n}.
                                     qq{  (Or you may want to run something like\n}.
                                     qq{    o conf make_install_make_command 'sudo make'\n}.
                                     qq{  to raise your permissions.}
                                    );
        }
a4872 7
    # $DB::single = 1;
    $self->store_persistent_state;
}

sub introduce_myself {
    my($self) = @@_;
    $CPAN::Frontend->myprint(sprintf("  %s\n",$self->pretty_id));
d4877 1
a4877 359
    shift->{build_dir};
}

#-> sub CPAN::Distribution::perldoc ;
sub perldoc {
    my($self) = @@_;

    my($dist) = $self->id;
    my $package = $self->called_for;

    $self->_display_url( $CPAN::Defaultdocs . $package );
}

#-> sub CPAN::Distribution::_check_binary ;
sub _check_binary {
    my ($dist,$shell,$binary) = @@_;
    my ($pid,$out);

    $CPAN::Frontend->myprint(qq{ + _check_binary($binary)\n})
      if $CPAN::DEBUG;

    if ($CPAN::META->has_inst("File::Which")) {
        return File::Which::which($binary);
    } else {
        local *README;
        $pid = open README, "which $binary|"
            or $CPAN::Frontend->mywarn(qq{Could not fork 'which $binary': $!\n});
        return unless $pid;
        while (<README>) {
            $out .= $_;
        }
        close README
            or $CPAN::Frontend->mywarn("Could not run 'which $binary': $!\n")
                and return;
    }

    $CPAN::Frontend->myprint(qq{   + $out \n})
      if $CPAN::DEBUG && $out;

    return $out;
}

#-> sub CPAN::Distribution::_display_url ;
sub _display_url {
    my($self,$url) = @@_;
    my($res,$saved_file,$pid,$out);

    $CPAN::Frontend->myprint(qq{ + _display_url($url)\n})
      if $CPAN::DEBUG;

    # should we define it in the config instead?
    my $html_converter = "html2text.pl";

    my $web_browser = $CPAN::Config->{'lynx'} || undef;
    my $web_browser_out = $web_browser
        ? CPAN::Distribution->_check_binary($self,$web_browser)
        : undef;

    if ($web_browser_out) {
        # web browser found, run the action
        my $browser = CPAN::HandleConfig->safe_quote($CPAN::Config->{'lynx'});
        $CPAN::Frontend->myprint(qq{system[$browser $url]})
            if $CPAN::DEBUG;
        $CPAN::Frontend->myprint(qq{
Displaying URL
  $url
with browser $browser
});
        $CPAN::Frontend->mysleep(1);
        system("$browser $url");
        if ($saved_file) { 1 while unlink($saved_file) }
    } else {
        # web browser not found, let's try text only
        my $html_converter_out =
            CPAN::Distribution->_check_binary($self,$html_converter);
        $html_converter_out = CPAN::HandleConfig->safe_quote($html_converter_out);

        if ($html_converter_out ) {
            # html2text found, run it
            $saved_file = CPAN::Distribution->_getsave_url( $self, $url );
            $CPAN::Frontend->mydie(qq{ERROR: problems while getting $url\n})
                unless defined($saved_file);

            local *README;
            $pid = open README, "$html_converter $saved_file |"
                or $CPAN::Frontend->mydie(qq{
Could not fork '$html_converter $saved_file': $!});
            my($fh,$filename);
            if ($CPAN::META->has_usable("File::Temp")) {
                $fh = File::Temp->new(
                                      dir      => File::Spec->tmpdir,
                                      template => 'cpan_htmlconvert_XXXX',
                                      suffix => '.txt',
                                      unlink => 0,
                                     );
                $filename = $fh->filename;
            } else {
                $filename = "cpan_htmlconvert_$$.txt";
                $fh = FileHandle->new();
                open $fh, ">$filename" or die;
            }
            while (<README>) {
                $fh->print($_);
            }
            close README or
                $CPAN::Frontend->mydie(qq{Could not run '$html_converter $saved_file': $!});
            my $tmpin = $fh->filename;
            $CPAN::Frontend->myprint(sprintf(qq{
Run '%s %s' and
saved output to %s\n},
                                             $html_converter,
                                             $saved_file,
                                             $tmpin,
                                            )) if $CPAN::DEBUG;
            close $fh;
            local *FH;
            open FH, $tmpin
                or $CPAN::Frontend->mydie(qq{Could not open "$tmpin": $!});
            my $fh_pager = FileHandle->new;
            local($SIG{PIPE}) = "IGNORE";
            my $pager = $CPAN::Config->{'pager'} || "cat";
            $fh_pager->open("|$pager")
                or $CPAN::Frontend->mydie(qq{
Could not open pager '$pager': $!});
            $CPAN::Frontend->myprint(qq{
Displaying URL
  $url
with pager "$pager"
});
            $CPAN::Frontend->mysleep(1);
            $fh_pager->print(<FH>);
            $fh_pager->close;
        } else {
            # coldn't find the web browser or html converter
            $CPAN::Frontend->myprint(qq{
You need to install lynx or $html_converter to use this feature.});
        }
    }
}

#-> sub CPAN::Distribution::_getsave_url ;
sub _getsave_url {
    my($dist, $shell, $url) = @@_;

    $CPAN::Frontend->myprint(qq{ + _getsave_url($url)\n})
      if $CPAN::DEBUG;

    my($fh,$filename);
    if ($CPAN::META->has_usable("File::Temp")) {
        $fh = File::Temp->new(
                              dir      => File::Spec->tmpdir,
                              template => "cpan_getsave_url_XXXX",
                              suffix => ".html",
                              unlink => 0,
                             );
        $filename = $fh->filename;
    } else {
        $fh = FileHandle->new;
        $filename = "cpan_getsave_url_$$.html";
    }
    my $tmpin = $filename;
    if ($CPAN::META->has_usable('LWP')) {
        $CPAN::Frontend->myprint("Fetching with LWP:
  $url
");
        my $Ua;
        CPAN::LWP::UserAgent->config;
        eval { $Ua = CPAN::LWP::UserAgent->new; };
        if ($@@) {
            $CPAN::Frontend->mywarn("ERROR: CPAN::LWP::UserAgent->new dies with $@@\n");
            return;
        } else {
            my($var);
            $Ua->proxy('http', $var)
                if $var = $CPAN::Config->{http_proxy} || $ENV{http_proxy};
            $Ua->no_proxy($var)
                if $var = $CPAN::Config->{no_proxy} || $ENV{no_proxy};
        }

        my $req = HTTP::Request->new(GET => $url);
        $req->header('Accept' => 'text/html');
        my $res = $Ua->request($req);
        if ($res->is_success) {
            $CPAN::Frontend->myprint(" + request successful.\n")
                if $CPAN::DEBUG;
            print $fh $res->content;
            close $fh;
            $CPAN::Frontend->myprint(qq{ + saved content to $tmpin \n})
                if $CPAN::DEBUG;
            return $tmpin;
        } else {
            $CPAN::Frontend->myprint(sprintf(
                                             "LWP failed with code[%s], message[%s]\n",
                                             $res->code,
                                             $res->message,
                                            ));
            return;
        }
    } else {
        $CPAN::Frontend->mywarn("  LWP not available\n");
        return;
    }
}

#-> sub CPAN::Distribution::_build_command
sub _build_command {
    my($self) = @@_;
    if ($^O eq "MSWin32") { # special code needed at least up to
                            # Module::Build 0.2611 and 0.2706; a fix
                            # in M:B has been promised 2006-01-30
        my($perl) = $self->perl or $CPAN::Frontend->mydie("Couldn't find executable perl\n");
        return "$perl ./Build";
    }
    return "./Build";
}

#-> sub CPAN::Distribution::_should_report
sub _should_report {
    my($self, $phase) = @@_;
    die "_should_report() requires a 'phase' argument"
        if ! defined $phase;

    # configured
    my $test_report = CPAN::HandleConfig->prefs_lookup($self,
                                                       q{test_report});
    return unless $test_report;

    # don't repeat if we cached a result
    return $self->{should_report}
        if exists $self->{should_report};

    # available
    if ( ! $CPAN::META->has_inst("CPAN::Reporter")) {
        $CPAN::Frontend->mywarn(
            "CPAN::Reporter not installed.  No reports will be sent.\n"
        );
        return $self->{should_report} = 0;
    }

    # capable
    my $crv = CPAN::Reporter->VERSION;
    if ( CPAN::Version->vlt( $crv, 0.99 ) ) {
        # don't cache $self->{should_report} -- need to check each phase
        if ( $phase eq 'test' ) {
            return 1;
        }
        else {
            $CPAN::Frontend->mywarn(
                "Reporting on the '$phase' phase requires CPAN::Reporter 0.99, but \n" .
                "you only have version $crv\.  Only 'test' phase reports will be sent.\n"
            );
            return;
        }
    }

    # appropriate
    if ($self->is_dot_dist) {
        $CPAN::Frontend->mywarn("Reporting via CPAN::Reporter is disabled ".
                                "for local directories\n");
        return $self->{should_report} = 0;
    }
    if ($self->prefs->{patches}
        &&
        @@{$self->prefs->{patches}}
        &&
        $self->{patched}
       ) {
        $CPAN::Frontend->mywarn("Reporting via CPAN::Reporter is disabled ".
                                "when the source has been patched\n");
        return $self->{should_report} = 0;
    }

    # proceed and cache success
    return $self->{should_report} = 1;
}

#-> sub CPAN::Distribution::reports
sub reports {
    my($self) = @@_;
    my $pathname = $self->id;
    $CPAN::Frontend->myprint("Distribution: $pathname\n");

    unless ($CPAN::META->has_inst("CPAN::DistnameInfo")) {
        $CPAN::Frontend->mydie("CPAN::DistnameInfo not installed; cannot continue");
    }
    unless ($CPAN::META->has_usable("LWP")) {
        $CPAN::Frontend->mydie("LWP not installed; cannot continue");
    }
    unless ($CPAN::META->has_usable("File::Temp")) {
        $CPAN::Frontend->mydie("File::Temp not installed; cannot continue");
    }

    my $d = CPAN::DistnameInfo->new($pathname);

    my $dist      = $d->dist;      # "CPAN-DistnameInfo"
    my $version   = $d->version;   # "0.02"
    my $maturity  = $d->maturity;  # "released"
    my $filename  = $d->filename;  # "CPAN-DistnameInfo-0.02.tar.gz"
    my $cpanid    = $d->cpanid;    # "GBARR"
    my $distvname = $d->distvname; # "CPAN-DistnameInfo-0.02"

    my $url = sprintf "http://cpantesters.perl.org/show/%s.yaml", $dist;

    CPAN::LWP::UserAgent->config;
    my $Ua;
    eval { $Ua = CPAN::LWP::UserAgent->new; };
    if ($@@) {
        $CPAN::Frontend->mydie("CPAN::LWP::UserAgent->new dies with $@@\n");
    }
    $CPAN::Frontend->myprint("Fetching '$url'...");
    my $resp = $Ua->get($url);
    unless ($resp->is_success) {
        $CPAN::Frontend->mydie(sprintf "Could not download '%s': %s\n", $url, $resp->code);
    }
    $CPAN::Frontend->myprint("DONE\n\n");
    my $yaml = $resp->content;
    # was fuer ein Umweg!
    my $fh = File::Temp->new(
                             dir      => File::Spec->tmpdir,
                             template => 'cpan_reports_XXXX',
                             suffix => '.yaml',
                             unlink => 0,
                            );
    my $tfilename = $fh->filename;
    print $fh $yaml;
    close $fh or $CPAN::Frontend->mydie("Could not close '$tfilename': $!");
    my $unserialized = CPAN->_yaml_loadfile($tfilename)->[0];
    unlink $tfilename or $CPAN::Frontend->mydie("Could not unlink '$tfilename': $!");
    my %other_versions;
    my $this_version_seen;
    for my $rep (@@$unserialized) {
        my $rversion = $rep->{version};
        if ($rversion eq $version) {
            unless ($this_version_seen++) {
                $CPAN::Frontend->myprint ("$rep->{version}:\n");
            }
            $CPAN::Frontend->myprint
                (sprintf("%1s%1s%-4s %s on %s %s (%s)\n",
                         $rep->{archname} eq $Config::Config{archname}?"*":"",
                         $rep->{action}eq"PASS"?"+":$rep->{action}eq"FAIL"?"-":"",
                         $rep->{action},
                         $rep->{perl},
                         ucfirst $rep->{osname},
                         $rep->{osvers},
                         $rep->{archname},
                        ));
        } else {
            $other_versions{$rep->{version}}++;
        }
    }
    unless ($this_version_seen) {
        $CPAN::Frontend->myprint("No reports found for version '$version'
Reports for other versions:\n");
        for my $v (sort keys %other_versions) {
            $CPAN::Frontend->myprint(" $v\: $other_versions{$v}\n");
        }
    }
    $url =~ s/\.yaml/.html/;
    $CPAN::Frontend->myprint("See $url for details\n");
a4880 1
use strict;
a4886 1
#-> CPAN::Bundle::undelay
a4895 1
# mark as dirty/clean
a4905 1
        && $color==1
d4907 2
a4908 2
    if ($depth>=$CPAN::MAX_RECURSION) {
        die(CPAN::Exception::RecursiveDependency->new($ancestors));
d4917 3
a4919 4
    # never reached code?
    #if ($color==0) {
      #delete $self->{badtestcnt};
    #}
a4937 3
    if ($inst_file && CPAN::Version->vlt($self->inst_version,$self->cpan_version)) {
        undef $inst_file;
    }
a4949 1
        $self->debug("before get id[$dist->{ID}]") if $CPAN::DEBUG;
d4951 1
a4951 1
        $self->debug("after get id[$dist->{ID}]") if $CPAN::DEBUG;
d4957 1
a4957 1
        $from = $self->find_bundle_file($dist->{build_dir},join('/',@@me));
a4995 1
# $where is in local format, $what is in unix format
d5004 5
a5008 5
        require ExtUtils::Manifest;
        my $cwd = CPAN::anycwd();
        $self->safe_chdir($where);
        ExtUtils::Manifest::mkmanifest();
        $self->safe_chdir($cwd);
d5011 1
a5011 1
        or Carp::croak("Couldn't open $manifest: $!");
d5013 10
a5022 3
    my $bundle_filename = $what;
    $bundle_filename =~ s|Bundle.*/||;
    my $bundle_unixpath;
d5024 10
a5033 9
        next if /^\s*\#/;
        my($file) = /(\S+)/;
        if ($file =~ m|\Q$what\E$|) {
            $bundle_unixpath = $file;
            # return File::Spec->catfile($where,$bundle_unixpath); # bad
            last;
        }
        # retry if she managed to have no Bundle directory
        $bundle_unixpath = $file if $file =~ m|\Q$bundle_filename\E$|;
d5035 2
a5036 2
    return File::Spec->catfile($where, split /\//, $bundle_unixpath)
        if $bundle_unixpath;
d5079 1
a5079 1
        unless $self->inst_file || $self->cpan_file;
d5082 4
a5085 4
        my($type) = $s =~ m|/| ? 'CPAN::Distribution' :
            $s =~ m|^Bundle::| ? 'CPAN::Bundle' : 'CPAN::Module';
        if ($type eq 'CPAN::Distribution') {
            $CPAN::Frontend->mywarn(qq{
d5087 1
a5087 2
explicitly a file '$s'.
Going to $meth that.
d5089 28
a5116 1
            $CPAN::Frontend->mysleep(5);
d5118 33
a5150 5
        # possibly noisy action:
        $self->debug("type[$type] s[$s]") if $CPAN::DEBUG;
        my $obj = $CPAN::META->instance($type,$s);
        $obj->{reqtype} = $self->{reqtype};
        $obj->$meth();
d5154 1
a5154 3
# If a bundle contains another that contains an xs_file we have here,
# we just don't bother I suppose
#-> sub CPAN::Bundle::xs_file
d5156 2
a5161 2
sub fforce   { shift->rematein('fforce',@@_); }
#-> sub CPAN::Bundle::force ;
a5162 2
#-> sub CPAN::Bundle::notest ;
sub notest  { shift->rematein('notest',@@_); }
d5170 1
a5170 1
    # $self->{badtestcnt} ||= 0;
a5202 1
use strict;
d5205 1
a5205 1
#-> sub CPAN::Module::userid
d5208 2
a5209 15
    my $ro = $self->ro;
    return unless $ro;
    return $ro->{userid} || $ro->{CPAN_USERID};
}
#-> sub CPAN::Module::description
sub description {
    my $self = shift;
    my $ro = $self->ro or return "";
    $ro->{description}
}

#-> sub CPAN::Module::distribution
sub distribution {
    my($self) = @@_;
    CPAN::Shell->expand("Distribution",$self->cpan_file);
d5211 2
a5213 1
#-> sub CPAN::Module::undelay
a5221 1
# mark as dirty/clean
a5230 1
        && $color==1
d5232 2
a5233 34
    return if $color==0 && !$self->{incommandcolor};
    if ($color>=1) {
        if ( $self->uptodate ) {
            $self->{incommandcolor} = $color;
            return;
        } elsif (my $have_version = $self->available_version) {
            # maybe what we have is good enough
            if (@@$ancestors) {
                my $who_asked_for_me = $ancestors->[-1];
                my $obj = CPAN::Shell->expandany($who_asked_for_me);
                if (0) {
                } elsif ($obj->isa("CPAN::Bundle")) {
                    # bundles cannot specify a minimum version
                    return;
                } elsif ($obj->isa("CPAN::Distribution")) {
                    if (my $prereq_pm = $obj->prereq_pm) {
                        for my $k (keys %$prereq_pm) {
                            if (my $want_version = $prereq_pm->{$k}{$self->id}) {
                                if (CPAN::Version->vcmp($have_version,$want_version) >= 0) {
                                    $self->{incommandcolor} = $color;
                                    return;
                                }
                            }
                        }
                    }
                }
            }
        }
    } else {
        $self->{incommandcolor} = $color; # set me before recursion,
                                          # so we can break it
    }
    if ($depth>=$CPAN::MAX_RECURSION) {
        die(CPAN::Exception::RecursiveDependency->new($ancestors));
d5240 3
a5242 4
    # unreached code?
    # if ($color==0) {
    #    delete $self->{badtestcnt};
    # }
d5259 1
a5259 1
        $self->description
d5264 1
a5264 10
    my $uptodateness = " ";
    unless ($class eq "Bundle") {
        my $u = $self->uptodate;
        $uptodateness = $u ? "=" : "<" if defined $u;
    };
    my $id = do {
        my $d = $self->distribution;
        $d ? $d -> pretty_id : $self->cpan_userid;
    };
    push @@m, sprintf("%-7s %1s %s%-22s%s (%s)\n",
a5265 1
                     $uptodateness,
d5269 1
a5269 2
                     $id,
                    );
a5272 47
#-> sub CPAN::Module::dslip_status
sub dslip_status {
    my($self) = @@_;
    my($stat);
    # development status
    @@{$stat->{D}}{qw,i c a b R M S,}     = qw,idea
                                              pre-alpha alpha beta released
                                              mature standard,;
    # support level
    @@{$stat->{S}}{qw,m d u n a,}         = qw,mailing-list
                                              developer comp.lang.perl.*
                                              none abandoned,;
    # language
    @@{$stat->{L}}{qw,p c + o h,}         = qw,perl C C++ other hybrid,;
    # interface
    @@{$stat->{I}}{qw,f r O p h n,}       = qw,functions
                                              references+ties
                                              object-oriented pragma
                                              hybrid none,;
    # public licence
    @@{$stat->{P}}{qw,p g l b a 2 o d r n,} = qw,Standard-Perl
                                              GPL LGPL
                                              BSD Artistic Artistic_2
                                              open-source
                                              distribution_allowed
                                              restricted_distribution
                                              no_licence,;
    for my $x (qw(d s l i p)) {
        $stat->{$x}{' '} = 'unknown';
        $stat->{$x}{'?'} = 'unknown';
    }
    my $ro = $self->ro;
    return +{} unless $ro && $ro->{statd};
    return {
            D  => $ro->{statd},
            S  => $ro->{stats},
            L  => $ro->{statl},
            I  => $ro->{stati},
            P  => $ro->{statp},
            DV => $stat->{D}{$ro->{statd}},
            SV => $stat->{S}{$ro->{stats}},
            LV => $stat->{L}{$ro->{statl}},
            IV => $stat->{I}{$ro->{stati}},
            PV => $stat->{P}{$ro->{statp}},
           };
}

d5284 1
a5284 1
        if $self->description;
d5288 15
a5302 15
    if ( $userid ) {
        my $author;
        if ($author = CPAN::Shell->expand('Author',$userid)) {
            my $email = "";
            my $m; # old perls
            if ($m = $author->email) {
                $email = " <$m>";
            }
            push @@m, sprintf(
                             $sprintf2,
                             'CPAN_USERID',
                             $userid,
                             $author->fullname . $email
                            );
        }
d5305 16
a5320 12
        if $self->cpan_version;
    if (my $cpan_file = $self->cpan_file) {
        push @@m, sprintf($sprintf, 'CPAN_FILE', $cpan_file);
        if (my $dist = CPAN::Shell->expand("Distribution",$cpan_file)) {
            my $upload_date = $dist->upload_date;
            if ($upload_date) {
                push @@m, sprintf($sprintf, 'UPLOAD_DATE', $upload_date);
            }
        }
    }
    my $sprintf3 = "    %-12s %1s%1s%1s%1s%1s (%s,%s,%s,%s,%s)\n";
    my $dslip = $self->dslip_status;
d5322 11
a5332 4
                     $sprintf3,
                     'DSLIP_STATUS',
                     @@{$dslip}{qw(D S L I P DV SV LV IV PV)},
                    ) if $dslip->{D};
a5334 1
        my $manpage;
d5336 1
a5336 1
            $manpage = $self->manpage_headline($local_file);
d5372 1
a5372 1
                    $manpage = $self->manpage_headline($lfl_abs);
a5375 1
        $self->{MANPAGE} = $manpage if $manpage;
d5379 2
a5380 2
        push @@m, sprintf($sprintf, $item, $self->{$item})
            if exists $self->{$item};
d5383 2
a5384 2
        push @@m, sprintf($sprintf, $item, join(" ",@@{$self->{$item}}))
            if exists $self->{$item} && @@{$self->{$item}};
d5387 1
a5387 1
                     $local_file || "(not installed)");
d5389 1
a5389 1
                     $self->inst_version) if $local_file;
a5392 1
#-> sub CPAN::Module::manpage_headline
d5394 19
a5412 26
    my($self,$local_file) = @@_;
    my(@@local_file) = $local_file;
    $local_file =~ s/\.pm(?!\n)\Z/.pod/;
    push @@local_file, $local_file;
    my(@@result,$locf);
    for $locf (@@local_file) {
        next unless -f $locf;
        my $fh = FileHandle->new($locf)
            or $Carp::Frontend->mydie("Couldn't open $locf: $!");
        my $inpod = 0;
        local $/ = "\n";
        while (<$fh>) {
            $inpod = m/^=(?!head1\s+NAME\s*$)/ ? 0 :
                m/^=head1\s+NAME\s*$/ ? 1 : $inpod;
            next unless $inpod;
            next if /^=/;
            next if /^\s+$/;
            chomp;
            push @@result, $_;
        }
        close $fh;
        last if @@result;
    }
    for (@@result) {
        s/^\s+//;
        s/\s+$//;
d5414 4
a5417 1
    join " ", @@result;
d5424 6
a5429 7
    # CPAN->debug(sprintf "id[%s]", $self->id) if $CPAN::DEBUG;
    unless ($self->ro) {
        CPAN::Index->reload;
    }
    my $ro = $self->ro;
    if ($ro && defined $ro->{CPAN_FILE}) {
        return $ro->{CPAN_FILE};
d5457 7
a5463 8
    my $ro = $self->ro;
    unless ($ro) {
        # Can happen with modules that are not on CPAN
        $ro = {};
    }
    $ro->{CPAN_VERSION} = 'undef'
        unless defined $ro->{CPAN_VERSION};
    $ro->{CPAN_VERSION};
d5469 1
a5469 1
    $self->{force_update} = 1;
d5472 4
a5475 17
#-> sub CPAN::Module::fforce ;
sub fforce {
    my($self) = @@_;
    $self->{force_update} = 2;
}

#-> sub CPAN::Module::notest ;
sub notest {
    my($self) = @@_;
    # $CPAN::Frontend->mywarn("XDEBUG: set notest for Module");
    $self->{notest}++;
}

#-> sub CPAN::Module::rematein ;
sub rematein {
    my($self,$meth) = @@_;
    $CPAN::Frontend->myprint(sprintf("Running %s for module '%s'\n",
d5479 2
a5480 2
    if ($cpan_file eq "N/A" || $cpan_file =~ /^Contact Author/) {
        $CPAN::Frontend->mywarn(sprintf qq{
d5487 4
a5490 4
                                $self->id,
                                $self->id,
                               );
        return;
d5494 4
a5497 45
    if (exists $self->{force_update}) {
        if ($self->{force_update} == 2) {
            $pack->fforce($meth);
        } else {
            $pack->force($meth);
        }
    }
    $pack->notest($meth) if exists $self->{notest} && $self->{notest};

    $pack->{reqtype} ||= "";
    CPAN->debug("dist-reqtype[$pack->{reqtype}]".
                "self-reqtype[$self->{reqtype}]") if $CPAN::DEBUG;
        if ($pack->{reqtype}) {
            if ($pack->{reqtype} eq "b" && $self->{reqtype} =~ /^[rc]$/) {
                $pack->{reqtype} = $self->{reqtype};
                if (
                    exists $pack->{install}
                    &&
                    (
                     UNIVERSAL::can($pack->{install},"failed") ?
                     $pack->{install}->failed :
                     $pack->{install} =~ /^NO/
                    )
                   ) {
                    delete $pack->{install};
                    $CPAN::Frontend->mywarn
                        ("Promoting $pack->{ID} from 'build_requires' to 'requires'");
                }
            }
        } else {
            $pack->{reqtype} = $self->{reqtype};
        }

    my $success = eval {
        $pack->$meth();
    };
    my $err = $@@;
    $pack->unforce if $pack->can("unforce") && exists $self->{force_update};
    $pack->unnotest if $pack->can("unnotest") && exists $self->{notest};
    delete $self->{force_update};
    delete $self->{notest};
    if ($err) {
        die $err;
    }
    return $success;
a5499 2
#-> sub CPAN::Module::perldoc ;
sub perldoc { shift->rematein('perldoc') }
d5501 1
a5501 1
sub readme  { shift->rematein('readme') }
d5503 1
a5503 1
sub look    { shift->rematein('look') }
d5507 1
a5507 1
sub get     { shift->rematein('get',@@_) }
d5509 4
a5512 1
sub make    { shift->rematein('make') }
d5516 1
a5516 1
    # $self->{badtestcnt} ||= 0;
a5518 1

d5521 18
a5538 11
    my ($self) = @@_;
    local ($_);
    my $inst = $self->inst_version or return undef;
    my $cpan = $self->cpan_version;
    local ($^W) = 0;
    CPAN::Version->vgt($cpan,$inst) and return 0;
    CPAN->debug(join("",
                     "returning uptodate. inst_file[",
                     $self->inst_file,
                     "cpan[$cpan] inst[$inst]")) if $CPAN::DEBUG;
    return 1;
a5539 1

d5545 2
a5546 2
        &&
        not exists $self->{force_update}
d5548 1
a5548 4
        $CPAN::Frontend->myprint(sprintf("%s is up to date (%s).\n",
                                         $self->id,
                                         $self->inst_version,
                                        ));
d5550 1
a5550 1
        $doit = 1;
d5552 1
a5552 2
    my $ro = $self->ro;
    if ($ro && $ro->{stats} && $ro->{stats} eq "a") {
d5557 1
a5557 1
        $CPAN::Frontend->mysleep(5);
a5566 16
    $self->_file_in_path([@@INC]);
}

#-> sub CPAN::Module::available_file ;
sub available_file {
    my($self) = @@_;
    my $sep = $Config::Config{path_sep};
    my $perllib = $ENV{PERL5LIB};
    $perllib = $ENV{PERLLIB} unless defined $perllib;
    my @@perllib = split(/$sep/,$perllib) if defined $perllib;
    $self->_file_in_path([@@perllib,@@INC]);
}

#-> sub CPAN::Module::file_in_path ;
sub _file_in_path {
    my($self,$path) = @@_;
d5570 5
a5574 8
    if (@@packpath == 1 && $packpath[0] eq "readline.pm") {
        unshift @@packpath, "Term", "ReadLine"; # historical reasons
    }
    foreach $dir (@@$path) {
        my $pmfile = File::Spec->catfile($dir,@@packpath);
        if (-f $pmfile) {
            return $pmfile;
        }
d5587 4
a5590 4
        my $xsfile = File::Spec->catfile($dir,'auto',@@packpath);
        if (-f $xsfile) {
            return $xsfile;
        }
d5599 2
a5600 3
    my $have = $self->parse_version($parsefile);
    $have;
}
d5602 7
a5608 7
#-> sub CPAN::Module::inst_version ;
sub available_version {
    my($self) = @@_;
    my $parsefile = $self->available_file or return;
    my $have = $self->parse_version($parsefile);
    $have;
}
d5610 1
a5610 5
#-> sub CPAN::Module::parse_version ;
sub parse_version {
    my($self,$parsefile) = @@_;
    my $have = MM->parse_version($parsefile);
    $have = "undef" unless defined $have && length $have;
d5614 20
d5640 127
a5766 2
#-> sub CPAN::Module::reports
sub reports {
d5768 107
a5874 1
    $self->distribution->reports;
d5877 30
a5906 2
package CPAN;
use strict;
a5907 1
1;
d5909 6
d5916 1
a5916 1
__END__
d5918 6
a5923 1
=head1 NAME
d5925 39
a5963 1
CPAN - query, download and build perl modules from CPAN sites
d5965 13
a5977 1
=head1 SYNOPSIS
d5979 1
a5979 1
Interactive mode:
d5981 7
a5987 1
  perl -MCPAN -e shell
d5989 1
a5989 1
--or--
d5991 1
a5991 1
  cpan
d5993 1
a5993 1
Basic commands:
d5995 1
a5995 1
  # Modules:
d5997 1
a5997 1
  cpan> install Acme::Meta                       # in the shell
d5999 1
a5999 1
  CPAN::Shell->install("Acme::Meta");            # in perl
d6001 1
a6001 1
  # Distributions:
d6003 1
a6003 1
  cpan> install NWCLARK/Acme-Meta-0.02.tar.gz    # in the shell
d6005 1
a6005 2
  CPAN::Shell->
    install("NWCLARK/Acme-Meta-0.02.tar.gz");    # in perl
d6007 1
a6007 1
  # module objects:
d6009 1
a6009 2
  $mo = CPAN::Shell->expandany($mod);
  $mo = CPAN::Shell->expand("Module",$mod);      # same thing
d6011 1
a6011 1
  # distribution objects:
d6013 7
a6019 4
  $do = CPAN::Shell->expand("Module",$mod)->distribution;
  $do = CPAN::Shell->expandany($distro);         # same thing
  $do = CPAN::Shell->expand("Distribution",
                            $distro);            # same thing
d6023 8
a6030 7
The CPAN module automates or at least simplifies the make and install
of perl modules and extensions. It includes some primitive searching
capabilities and knows how to use Net::FTP or LWP or some external
download clients to fetch the distributions from the net.

These are fetched from one or more of the mirrored CPAN (Comprehensive
Perl Archive Network) sites and unpacked in a dedicated directory.
d6036 14
a6049 5
The package contains a session manager and a cache manager. The
session manager keeps track of what has been fetched, built and
installed in the current session. The cache manager keeps track of the
disk space occupied by the make processes and deletes excess space
according to a simple FIFO mechanism.
d6051 1
a6051 1
All methods provided are accessible in a programmer style and in an
d6054 1
a6054 1
=head2 CPAN::shell([$prompt, $command]) Starting Interactive Mode
d6060 3
a6062 3
or

    cpan
d6064 2
a6065 6
which puts you into a readline interface. If C<Term::ReadKey> and
either C<Term::ReadLine::Perl> or C<Term::ReadLine::Gnu> are installed
it supports both history and command completion.

Once you are on the command line, type C<h> to get a one page help
screen and the rest should be self-explanatory.
d6092 1
a6092 1
C<as_glimpse>.
d6094 1
a6094 1
=item C<get>, C<make>, C<test>, C<install>, C<clean> modules or distributions
d6101 2
a6102 5
the module's META.yml or Makefile.PL (this behavior is controlled by
the configuration parameter C<prerequisites_policy>.)

C<get> downloads a distribution file and untars or unzips it, C<make>
builds it, C<test> runs the test suite, and C<install> installs it.
d6118 3
a6120 10
succeeded or not. It does not repeat a test run if the test
has been run successfully before. Same for install runs.

The C<force> pragma may precede another command (currently: C<get>,
C<make>, C<test>, or C<install>) and executes the command from scratch
and tries to continue in case of some errors. See the section below on
the C<force> and the C<fforce> pragma.

The C<notest> pragma may be used to skip the test part in the build
process.
d6124 7
a6130 1
    cpan> notest install Tk
d6138 1
a6138 22
=item C<readme>, C<perldoc>, C<look> module or distribution

C<readme> displays the README file of the associated distribution.
C<Look> gets and untars (if not yet done) the distribution file,
changes to the appropriate directory and opens a subshell process in
that directory. C<perldoc> displays the pod documentation of the
module in html or plain text format.

=item C<ls> author

=item C<ls> globbing_expression

The first form lists all distribution files in and below an author's
CPAN directory as they are stored in the CHECKUMS files distributed on
CPAN. The listing goes recursive into all subdirectories.

The second form allows to limit or expand the output with shell
globbing as in the following examples:

      ls JV/make*
      ls GSAR/*make*
      ls */*make*
d6140 11
a6150 61
The last example is very slow and outputs extra progress indicators
that break the alignment of the result.

Note that globbing only lists directories explicitly asked for, for
example FOO/* will not list FOO/bar/Acme-Sthg-n.nn.tar.gz. This may be
regarded as a bug and may be changed in future versions.

=item C<failed>

The C<failed> command reports all distributions that failed on one of
C<make>, C<test> or C<install> for some reason in the currently
running shell session.

=item Persistence between sessions

If the C<YAML> or the C<YAML::Syck> module is installed a record of
the internal state of all modules is written to disk after each step.
The files contain a signature of the currently running perl version
for later perusal.

If the configurations variable C<build_dir_reuse> is set to a true
value, then CPAN.pm reads the collected YAML files. If the stored
signature matches the currently running perl the stored state is
loaded into memory such that effectively persistence between sessions
is established.

=item The C<force> and the C<fforce> pragma

To speed things up in complex installation scenarios, CPAN.pm keeps
track of what it has already done and refuses to do some things a
second time. A C<get>, a C<make>, and an C<install> are not repeated.
A C<test> is only repeated if the previous test was unsuccessful. The
diagnostic message when CPAN.pm refuses to do something a second time
is one of I<Has already been >C<unwrapped|made|tested successfully> or
something similar. Another situation where CPAN refuses to act is an
C<install> if the according C<test> was not successful.

In all these cases, the user can override the goatish behaviour by
prepending the command with the word force, for example:

  cpan> force get Foo
  cpan> force make AUTHOR/Bar-3.14.tar.gz
  cpan> force test Baz
  cpan> force install Acme::Meta

Each I<forced> command is executed with the according part of its
memory erased.

The C<fforce> pragma is a variant that emulates a C<force get> which
erases the entire memory followed by the action specified, effectively
restarting the whole get/make/test/install procedure from scratch.

=item Lockfile

Interactive sessions maintain a lockfile, per default C<~/.cpan/.lock>.
Batch jobs can run without a lockfile and do not disturb each other.

The shell offers to run in I<degraded mode> when another process is
holding the lockfile. This is an experimental feature that is not yet
tested very well. This second shell then does not write the history
file, does not use the metadata file and has a different prompt.
d6161 2
a6162 764
CPAN.pm ignores a SIGPIPE. If the user sets C<inactivity_timeout>, a
SIGALRM is used during the run of the C<perl Makefile.PL> or C<perl
Build.PL> subprocess.

=back

=head2 CPAN::Shell

The commands that are available in the shell interface are methods in
the package CPAN::Shell. If you enter the shell command, all your
input is split by the Text::ParseWords::shellwords() routine which
acts like most shells do. The first word is being interpreted as the
method to be called and the rest of the words are treated as arguments
to this method. Continuation lines are supported if a line ends with a
literal backslash.

=head2 autobundle

C<autobundle> writes a bundle file into the
C<$CPAN::Config-E<gt>{cpan_home}/Bundle> directory. The file contains
a list of all modules that are both available from CPAN and currently
installed within @@INC. The name of the bundle file is based on the
current date and a counter.

=head2 hosts

Note: this feature is still in alpha state and may change in future
versions of CPAN.pm

This commands provides a statistical overview over recent download
activities. The data for this is collected in the YAML file
C<FTPstats.yml> in your C<cpan_home> directory. If no YAML module is
configured or YAML not installed, then no stats are provided.

=head2 mkmyconfig

mkmyconfig() writes your own CPAN::MyConfig file into your ~/.cpan/
directory so that you can save your own preferences instead of the
system wide ones.

=head2 recent ***EXPERIMENTAL COMMAND***

The C<recent> command downloads a list of recent uploads to CPAN and
displays them I<slowly>. While the command is running $SIG{INT} is
defined to mean that the loop shall be left after having displayed the
current item.

B<Note>: This command requires XML::LibXML installed.

B<Note>: This whole command currently is a bit klunky and will
probably change in future versions of CPAN.pm but the general
approach will likely stay.

B<Note>: See also L<smoke>

=head2 recompile

recompile() is a very special command in that it takes no argument and
runs the make/test/install cycle with brute force over all installed
dynamically loadable extensions (aka XS modules) with 'force' in
effect. The primary purpose of this command is to finish a network
installation. Imagine, you have a common source tree for two different
architectures. You decide to do a completely independent fresh
installation. You start on one architecture with the help of a Bundle
file produced earlier. CPAN installs the whole Bundle for you, but
when you try to repeat the job on the second architecture, CPAN
responds with a C<"Foo up to date"> message for all modules. So you
invoke CPAN's recompile on the second architecture and you're done.

Another popular use for C<recompile> is to act as a rescue in case your
perl breaks binary compatibility. If one of the modules that CPAN uses
is in turn depending on binary compatibility (so you cannot run CPAN
commands), then you should try the CPAN::Nox module for recovery.

=head2 report Bundle|Distribution|Module

The C<report> command temporarily turns on the C<test_report> config
variable, then runs the C<force test> command with the given
arguments. The C<force> pragma is used to re-run the tests and repeat
every step that might have failed before.

=head2 smoke ***EXPERIMENTAL COMMAND***

B<*** WARNING: this command downloads and executes software from CPAN to
your computer of completely unknown status. You should never do
this with your normal account and better have a dedicated well
separated and secured machine to do this. ***>

The C<smoke> command takes the list of recent uploads to CPAN as
provided by the C<recent> command and tests them all. While the
command is running $SIG{INT} is defined to mean that the current item
shall be skipped.

B<Note>: This whole command currently is a bit klunky and will
probably change in future versions of CPAN.pm but the general
approach will likely stay.

B<Note>: See also L<recent>

=head2 upgrade [Module|/Regex/]...

The C<upgrade> command first runs an C<r> command with the given
arguments and then installs the newest versions of all modules that
were listed by that.

=head2 The four C<CPAN::*> Classes: Author, Bundle, Module, Distribution

Although it may be considered internal, the class hierarchy does matter
for both users and programmer. CPAN.pm deals with above mentioned four
classes, and all those classes share a set of methods. A classical
single polymorphism is in effect. A metaclass object registers all
objects of all kinds and indexes them with a string. The strings
referencing objects have a separated namespace (well, not completely
separated):

         Namespace                         Class

   words containing a "/" (slash)      Distribution
    words starting with Bundle::          Bundle
          everything else            Module or Author

Modules know their associated Distribution objects. They always refer
to the most recent official release. Developers may mark their releases
as unstable development versions (by inserting an underbar into the
module version number which will also be reflected in the distribution
name when you run 'make dist'), so the really hottest and newest
distribution is not always the default.  If a module Foo circulates
on CPAN in both version 1.23 and 1.23_90, CPAN.pm offers a convenient
way to install version 1.23 by saying

    install Foo

This would install the complete distribution file (say
BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would
like to install version 1.23_90, you need to know where the
distribution file resides on CPAN relative to the authors/id/
directory. If the author is BAR, this might be BAR/Foo-1.23_90.tar.gz;
so you would have to say

    install BAR/Foo-1.23_90.tar.gz

The first example will be driven by an object of the class
CPAN::Module, the second by an object of class CPAN::Distribution.

=head2 Integrating local directories

Note: this feature is still in alpha state and may change in future
versions of CPAN.pm

Distribution objects are normally distributions from the CPAN, but
there is a slightly degenerate case for Distribution objects, too, of
projects held on the local disk. These distribution objects have the
same name as the local directory and end with a dot. A dot by itself
is also allowed for the current directory at the time CPAN.pm was
used. All actions such as C<make>, C<test>, and C<install> are applied
directly to that directory. This gives the command C<cpan .> an
interesting touch: while the normal mantra of installing a CPAN module
without CPAN.pm is one of

    perl Makefile.PL                 perl Build.PL
           ( go and get prerequisites )
    make                             ./Build
    make test                        ./Build test
    make install                     ./Build install

the command C<cpan .> does all of this at once. It figures out which
of the two mantras is appropriate, fetches and installs all
prerequisites, cares for them recursively and finally finishes the
installation of the module in the current directory, be it a CPAN
module or not.

The typical usage case is for private modules or working copies of
projects from remote repositories on the local disk.

=head1 CONFIGURATION

When the CPAN module is used for the first time, a configuration
dialog tries to determine a couple of site specific options. The
result of the dialog is stored in a hash reference C< $CPAN::Config >
in a file CPAN/Config.pm.

The default values defined in the CPAN/Config.pm file can be
overridden in a user specific file: CPAN/MyConfig.pm. Such a file is
best placed in $HOME/.cpan/CPAN/MyConfig.pm, because $HOME/.cpan is
added to the search path of the CPAN module before the use() or
require() statements. The mkmyconfig command writes this file for you.

The C<o conf> command has various bells and whistles:

=over

=item completion support

If you have a ReadLine module installed, you can hit TAB at any point
of the commandline and C<o conf> will offer you completion for the
built-in subcommands and/or config variable names.

=item displaying some help: o conf help

Displays a short help

=item displaying current values: o conf [KEY]

Displays the current value(s) for this config variable. Without KEY
displays all subcommands and config variables.

Example:

  o conf shell

If KEY starts and ends with a slash the string in between is
interpreted as a regular expression and only keys matching this regex
are displayed

Example:

  o conf /color/

=item changing of scalar values: o conf KEY VALUE

Sets the config variable KEY to VALUE. The empty string can be
specified as usual in shells, with C<''> or C<"">

Example:

  o conf wget /usr/bin/wget

=item changing of list values: o conf KEY SHIFT|UNSHIFT|PUSH|POP|SPLICE|LIST

If a config variable name ends with C<list>, it is a list. C<o conf
KEY shift> removes the first element of the list, C<o conf KEY pop>
removes the last element of the list. C<o conf KEYS unshift LIST>
prepends a list of values to the list, C<o conf KEYS push LIST>
appends a list of valued to the list.

Likewise, C<o conf KEY splice LIST> passes the LIST to the according
splice command.

Finally, any other list of arguments is taken as a new list value for
the KEY variable discarding the previous value.

Examples:

  o conf urllist unshift http://cpan.dev.local/CPAN
  o conf urllist splice 3 1
  o conf urllist http://cpan1.local http://cpan2.local ftp://ftp.perl.org

=item reverting to saved: o conf defaults

Reverts all config variables to the state in the saved config file.

=item saving the config: o conf commit

Saves all config variables to the current config file (CPAN/Config.pm
or CPAN/MyConfig.pm that was loaded at start).

=back

The configuration dialog can be started any time later again by
issuing the command C< o conf init > in the CPAN shell. A subset of
the configuration dialog can be run by issuing C<o conf init WORD>
where WORD is any valid config variable or a regular expression.

=head2 Config Variables

Currently the following keys in the hash reference $CPAN::Config are
defined:

  applypatch         path to external prg
  auto_commit        commit all changes to config variables to disk
  build_cache        size of cache for directories to build modules
  build_dir          locally accessible directory to build modules
  build_dir_reuse    boolean if distros in build_dir are persistent
  build_requires_install_policy
                     to install or not to install when a module is
                     only needed for building. yes|no|ask/yes|ask/no
  bzip2              path to external prg
  cache_metadata     use serializer to cache metadata
  commands_quote     prefered character to use for quoting external
                     commands when running them. Defaults to double
                     quote on Windows, single tick everywhere else;
                     can be set to space to disable quoting
  check_sigs         if signatures should be verified
  colorize_debug     Term::ANSIColor attributes for debugging output
  colorize_output    boolean if Term::ANSIColor should colorize output
  colorize_print     Term::ANSIColor attributes for normal output
  colorize_warn      Term::ANSIColor attributes for warnings
  commandnumber_in_prompt
                     boolean if you want to see current command number
  cpan_home          local directory reserved for this package
  curl               path to external prg
  dontload_hash      DEPRECATED
  dontload_list      arrayref: modules in the list will not be
                     loaded by the CPAN::has_inst() routine
  ftp                path to external prg
  ftp_passive        if set, the envariable FTP_PASSIVE is set for downloads
  ftp_proxy          proxy host for ftp requests
  getcwd             see below
  gpg                path to external prg
  gzip               location of external program gzip
  histfile           file to maintain history between sessions
  histsize           maximum number of lines to keep in histfile
  http_proxy         proxy host for http requests
  inactivity_timeout breaks interactive Makefile.PLs or Build.PLs
                     after this many seconds inactivity. Set to 0 to
                     never break.
  index_expire       after this many days refetch index files
  inhibit_startup_message
                     if true, does not print the startup message
  keep_source_where  directory in which to keep the source (if we do)
  load_module_verbosity
                     report loading of optional modules used by CPAN.pm
  lynx               path to external prg
  make               location of external make program
  make_arg           arguments that should always be passed to 'make'
  make_install_make_command
                     the make command for running 'make install', for
                     example 'sudo make'
  make_install_arg   same as make_arg for 'make install'
  makepl_arg         arguments passed to 'perl Makefile.PL'
  mbuild_arg         arguments passed to './Build'
  mbuild_install_arg arguments passed to './Build install'
  mbuild_install_build_command
                     command to use instead of './Build' when we are
                     in the install stage, for example 'sudo ./Build'
  mbuildpl_arg       arguments passed to 'perl Build.PL'
  ncftp              path to external prg
  ncftpget           path to external prg
  no_proxy           don't proxy to these hosts/domains (comma separated list)
  pager              location of external program more (or any pager)
  password           your password if you CPAN server wants one
  patch              path to external prg
  prefer_installer   legal values are MB and EUMM: if a module comes
                     with both a Makefile.PL and a Build.PL, use the
                     former (EUMM) or the latter (MB); if the module
                     comes with only one of the two, that one will be
                     used in any case
  prerequisites_policy
                     what to do if you are missing module prerequisites
                     ('follow' automatically, 'ask' me, or 'ignore')
  prefs_dir          local directory to store per-distro build options
  proxy_user         username for accessing an authenticating proxy
  proxy_pass         password for accessing an authenticating proxy
  randomize_urllist  add some randomness to the sequence of the urllist
  scan_cache         controls scanning of cache ('atstart' or 'never')
  shell              your favorite shell
  show_unparsable_versions
                     boolean if r command tells which modules are versionless
  show_upload_date   boolean if commands should try to determine upload date
  show_zero_versions boolean if r command tells for which modules $version==0
  tar                location of external program tar
  tar_verbosity      verbosity level for the tar command
  term_is_latin      deprecated: if true Unicode is translated to ISO-8859-1
                     (and nonsense for characters outside latin range)
  term_ornaments     boolean to turn ReadLine ornamenting on/off
  test_report        email test reports (if CPAN::Reporter is installed)
  unzip              location of external program unzip
  urllist            arrayref to nearby CPAN sites (or equivalent locations)
  use_sqlite         use CPAN::SQLite for metadata storage (fast and lean)
  username           your username if you CPAN server wants one
  wait_list          arrayref to a wait server to try (See CPAN::WAIT)
  wget               path to external prg
  yaml_load_code     enable YAML code deserialisation
  yaml_module        which module to use to read/write YAML files

You can set and query each of these options interactively in the cpan
shell with the C<o conf> or the C<o conf init> command as specified below.

=over 2

=item C<o conf E<lt>scalar optionE<gt>>

prints the current value of the I<scalar option>

=item C<o conf E<lt>scalar optionE<gt> E<lt>valueE<gt>>

Sets the value of the I<scalar option> to I<value>

=item C<o conf E<lt>list optionE<gt>>

prints the current value of the I<list option> in MakeMaker's
neatvalue format.

=item C<o conf E<lt>list optionE<gt> [shift|pop]>

shifts or pops the array in the I<list option> variable

=item C<o conf E<lt>list optionE<gt> [unshift|push|splice] E<lt>listE<gt>>

works like the corresponding perl commands.

=item interactive editing: o conf init [MATCH|LIST]

Runs an interactive configuration dialog for matching variables.
Without argument runs the dialog over all supported config variables.
To specify a MATCH the argument must be enclosed by slashes.

Examples:

  o conf init ftp_passive ftp_proxy
  o conf init /color/

Note: this method of setting config variables often provides more
explanation about the functioning of a variable than the manpage.

=back

=head2 CPAN::anycwd($path): Note on config variable getcwd

CPAN.pm changes the current working directory often and needs to
determine its own current working directory. Per default it uses
Cwd::cwd but if this doesn't work on your system for some reason,
alternatives can be configured according to the following table:

=over 4

=item cwd

Calls Cwd::cwd

=item getcwd

Calls Cwd::getcwd

=item fastcwd

Calls Cwd::fastcwd

=item backtickcwd

Calls the external command cwd.

=back

=head2 Note on the format of the urllist parameter

urllist parameters are URLs according to RFC 1738. We do a little
guessing if your URL is not compliant, but if you have problems with
C<file> URLs, please try the correct format. Either:

    file://localhost/whatever/ftp/pub/CPAN/

or

    file:///home/ftp/pub/CPAN/

=head2 The urllist parameter has CD-ROM support

The C<urllist> parameter of the configuration table contains a list of
URLs that are to be used for downloading. If the list contains any
C<file> URLs, CPAN always tries to get files from there first. This
feature is disabled for index files. So the recommendation for the
owner of a CD-ROM with CPAN contents is: include your local, possibly
outdated CD-ROM as a C<file> URL at the end of urllist, e.g.

  o conf urllist push file://localhost/CDROM/CPAN

CPAN.pm will then fetch the index files from one of the CPAN sites
that come at the beginning of urllist. It will later check for each
module if there is a local copy of the most recent version.

Another peculiarity of urllist is that the site that we could
successfully fetch the last file from automatically gets a preference
token and is tried as the first site for the next request. So if you
add a new site at runtime it may happen that the previously preferred
site will be tried another time. This means that if you want to disallow
a site for the next transfer, it must be explicitly removed from
urllist.

=head2 Maintaining the urllist parameter

If you have YAML.pm (or some other YAML module configured in
C<yaml_module>) installed, CPAN.pm collects a few statistical data
about recent downloads. You can view the statistics with the C<hosts>
command or inspect them directly by looking into the C<FTPstats.yml>
file in your C<cpan_home> directory.

To get some interesting statistics it is recommended to set the
C<randomize_urllist> parameter that introduces some amount of
randomness into the URL selection.

=head2 The C<requires> and C<build_requires> dependency declarations

Since CPAN.pm version 1.88_51 modules declared as C<build_requires> by
a distribution are treated differently depending on the config
variable C<build_requires_install_policy>. By setting
C<build_requires_install_policy> to C<no> such a module is not being
installed. It is only built and tested and then kept in the list of
tested but uninstalled modules. As such it is available during the
build of the dependent module by integrating the path to the
C<blib/arch> and C<blib/lib> directories in the environment variable
PERL5LIB. If C<build_requires_install_policy> is set ti C<yes>, then
both modules declared as C<requires> and those declared as
C<build_requires> are treated alike. By setting to C<ask/yes> or
C<ask/no>, CPAN.pm asks the user and sets the default accordingly.

=head2 Configuration for individual distributions (I<Distroprefs>)

(B<Note:> This feature has been introduced in CPAN.pm 1.8854 and is
still considered beta quality)

Distributions on the CPAN usually behave according to what we call the
CPAN mantra. Or since the event of Module::Build we should talk about
two mantras:

    perl Makefile.PL     perl Build.PL
    make                 ./Build
    make test            ./Build test
    make install         ./Build install

But some modules cannot be built with this mantra. They try to get
some extra data from the user via the environment, extra arguments or
interactively thus disturbing the installation of large bundles like
Phalanx100 or modules with many dependencies like Plagger.

The distroprefs system of C<CPAN.pm> addresses this problem by
allowing the user to specify extra informations and recipes in YAML
files to either

=over

=item

pass additional arguments to one of the four commands,

=item

set environment variables

=item

instantiate an Expect object that reads from the console, waits for
some regular expressions and enters some answers

=item

temporarily override assorted C<CPAN.pm> configuration variables

=item

specify dependencies that the original maintainer forgot to specify

=item

disable the installation of an object altogether

=back

See the YAML and Data::Dumper files that come with the C<CPAN.pm>
distribution in the C<distroprefs/> directory for examples.

=head2 Filenames

The YAML files themselves must have the C<.yml> extension, all other
files are ignored (for two exceptions see I<Fallback Data::Dumper and
Storable> below). The containing directory can be specified in
C<CPAN.pm> in the C<prefs_dir> config variable. Try C<o conf init
prefs_dir> in the CPAN shell to set and activate the distroprefs
system.

Every YAML file may contain arbitrary documents according to the YAML
specification and every single document is treated as an entity that
can specify the treatment of a single distribution.

The names of the files can be picked freely, C<CPAN.pm> always reads
all files (in alphabetical order) and takes the key C<match> (see
below in I<Language Specs>) as a hashref containing match criteria
that determine if the current distribution matches the YAML document
or not.

=head2 Fallback Data::Dumper and Storable

If neither your configured C<yaml_module> nor YAML.pm is installed
CPAN.pm falls back to using Data::Dumper and Storable and looks for
files with the extensions C<.dd> or C<.st> in the C<prefs_dir>
directory. These files are expected to contain one or more hashrefs.
For Data::Dumper generated files, this is expected to be done with by
defining C<$VAR1>, C<$VAR2>, etc. The YAML shell would produce these
with the command

    ysh < somefile.yml > somefile.dd

For Storable files the rule is that they must be constructed such that
C<Storable::retrieve(file)> returns an array reference and the array
elements represent one distropref object each. The conversion from
YAML would look like so:

    perl -MYAML=LoadFile -MStorable=nstore -e '
        @@y=LoadFile(shift);
        nstore(\@@y, shift)' somefile.yml somefile.st

In bootstrapping situations it is usually sufficient to translate only
a few YAML files to Data::Dumper for the crucial modules like
C<YAML::Syck>, C<YAML.pm> and C<Expect.pm>. If you prefer Storable
over Data::Dumper, remember to pull out a Storable version that writes
an older format than all the other Storable versions that will need to
read them.

=head2 Blueprint

The following example contains all supported keywords and structures
with the exception of C<eexpect> which can be used instead of
C<expect>.

  ---
  comment: "Demo"
  match:
    module: "Dancing::Queen"
    distribution: "^CHACHACHA/Dancing-"
    perl: "/usr/local/cariba-perl/bin/perl"
    perlconfig:
      archname: "freebsd"
  disabled: 1
  cpanconfig:
    make: gmake
  pl:
    args:
      - "--somearg=specialcase"

    env: {}

    expect:
      - "Which is your favorite fruit"
      - "apple\n"

  make:
    args:
      - all
      - extra-all

    env: {}

    expect: []

    commendline: "echo SKIPPING make"

  test:
    args: []

    env: {}

    expect: []

  install:
    args: []

    env:
      WANT_TO_INSTALL: YES

    expect:
      - "Do you really want to install"
      - "y\n"

  patches:
    - "ABCDE/Fedcba-3.14-ABCDE-01.patch"

  depends:
    configure_requires:
      LWP: 5.8
    build_requires:
      Test::Exception: 0.25
    requires:
      Spiffy: 0.30


=head2 Language Specs

Every YAML document represents a single hash reference. The valid keys
in this hash are as follows:

=over

=item comment [scalar]

A comment

=item cpanconfig [hash]

Temporarily override assorted C<CPAN.pm> configuration variables.

Supported are: C<build_requires_install_policy>, C<check_sigs>,
C<make>, C<make_install_make_command>, C<prefer_installer>,
C<test_report>. Please report as a bug when you need another one
supported.

=item depends [hash] *** EXPERIMENTAL FEATURE ***

All three types, namely C<configure_requires>, C<build_requires>, and
C<requires> are supported in the way specified in the META.yml
specification. The current implementation I<merges> the specified
dependencies with those declared by the package maintainer. In a
future implementation this may be changed to override the original
declaration.

=item disabled [boolean]

Specifies that this distribution shall not be processed at all.

=item goto [string]

The canonical name of a delegate distribution that shall be installed
instead. Useful when a new version, although it tests OK itself,
breaks something else or a developer release or a fork is already
uploaded that is better than the last released version.

=item install [hash]

Processing instructions for the C<make install> or C<./Build install>
phase of the CPAN mantra. See below under I<Processiong Instructions>.

=item make [hash]

Processing instructions for the C<make> or C<./Build> phase of the
CPAN mantra. See below under I<Processiong Instructions>.

=item match [hash]

A hashref with one or more of the keys C<distribution>, C<modules>,
C<perl>, and C<perlconfig> that specify if a document is targeted at a
specific CPAN distribution or installation.

The corresponding values are interpreted as regular expressions. The
C<distribution> related one will be matched against the canonical
distribution name, e.g. "AUTHOR/Foo-Bar-3.14.tar.gz".

The C<module> related one will be matched against I<all> modules
contained in the distribution until one module matches.

The C<perl> related one will be matched against C<$^X> (but with the
absolute path).

The value associated with C<perlconfig> is itself a hashref that is
matched against corresponding values in the C<%Config::Config> hash
living in the C< Config.pm > module.

If more than one restriction of C<module>, C<distribution>, and
C<perl> is specified, the results of the separately computed match
values must all match. If this is the case then the hashref
represented by the YAML document is returned as the preference
structure for the current distribution.

=item patches [array]

An array of patches on CPAN or on the local disk to be applied in
order via the external patch program. If the value for the C<-p>
parameter is C<0> or C<1> is determined by reading the patch
beforehand.

Note: if the C<applypatch> program is installed and C<CPAN::Config>
knows about it B<and> a patch is written by the C<makepatch> program,
then C<CPAN.pm> lets C<applypatch> apply the patch. Both C<makepatch>
and C<applypatch> are available from CPAN in the C<JV/makepatch-*>
distribution.

=item pl [hash]

Processing instructions for the C<perl Makefile.PL> or C<perl
Build.PL> phase of the CPAN mantra. See below under I<Processiong
Instructions>.

=item test [hash]

Processing instructions for the C<make test> or C<./Build test> phase
of the CPAN mantra. See below under I<Processiong Instructions>.
d6166 1
a6166 1
=head2 Processing Instructions
d6168 7
a6174 1
=over
d6176 1
a6176 1
=item args [array]
d6178 5
a6182 1
Arguments to be added to the command line
d6184 1
a6184 1
=item commandline
d6186 11
a6196 4
A full commandline that will be executed as it stands by a system
call. During the execution the environment variable PERL will is set
to $^X (but with an absolute path). If C<commandline> is specified,
the content of C<args> is not used.
d6198 4
a6201 1
=item eexpect [hash]
d6203 1
a6203 2
Extended C<expect>. This is a hash reference with four allowed keys,
C<mode>, C<timeout>, C<reuse>, and C<talk>.
d6205 7
a6211 4
C<mode> may have the values C<deterministic> for the case where all
questions come in the order written down and C<anyorder> for the case
where the questions may come in any order. The default mode is
C<deterministic>.
d6213 1
a6213 4
C<timeout> denotes a timeout in seconds. Floating point timeouts are
OK. In the case of a C<mode=deterministic> the timeout denotes the
timeout per question, in the case of C<mode=anyorder> it denotes the
timeout per byte received from the stream or questions.
d6215 3
a6217 5
C<talk> is a reference to an array that contains alternating questions
and answers. Questions are regular expressions and answers are literal
strings. The Expect module will then watch the stream coming from the
execution of the external program (C<perl Makefile.PL>, C<perl
Build.PL>, C<make>, etc.).
d6219 8
a6226 2
In the case of C<mode=deterministic> the CPAN.pm will inject the
according answer as soon as the stream matches the regular expression.
d6228 1
a6228 10
In the case of C<mode=anyorder> CPAN.pm will answer a question as soon
as the timeout is reached for the next byte in the input stream. In
this mode you can use the C<reuse> parameter to decide what shall
happen with a question-answer pair after it has been used. In the
default case (reuse=0) it is removed from the array, so it cannot be
used again accidentally. In this case, if you want to answer the
question C<Do you really want to do that> several times, then it must
be included in the array at least as often as you want this answer to
be given. Setting the parameter C<reuse> to 1 makes this repetition
unnecessary.
d6230 6
a6235 1
=item env [hash]
d6237 1
a6237 1
Environment variables to be set during the command
d6239 2
a6240 25
=item expect [array]

C<< expect: <array> >> is a short notation for

  eexpect:
    mode: deterministic
    timeout: 15
    talk: <array>

=back

=head2 Schema verification with C<Kwalify>

If you have the C<Kwalify> module installed (which is part of the
Bundle::CPANxxl), then all your distroprefs files are checked for
syntactical correctness.

=head2 Example Distroprefs Files

C<CPAN.pm> comes with a collection of example YAML files. Note that these
are really just examples and should not be used without care because
they cannot fit everybody's purpose. After all the authors of the
packages that ask questions had a need to ask, so you should watch
their questions and adjust the examples to your environment and your
needs. You have beend warned:-)
d6242 1
a6242 1
=head1 PROGRAMMER'S INTERFACE
d6246 1
a6246 8
functions in the calling package (C<install(...)>).  Before calling low-level
commands it makes sense to initialize components of CPAN you need, e.g.:

  CPAN::HandleConfig->load;
  CPAN::Shell::setup_output;
  CPAN::Index->reload;

High-level commands do such initializations automatically.
d6269 1
a6269 2
CPAN::Distribution objects for distributions. Note: it does not expand
to CPAN::Author objects.
d6280 3
a6282 2
    for $mod (qw(Net::FTP Digest::SHA Data::Dumper)) {
        CPAN::Shell->install($mod);
d6286 2
a6287 2
    for $mod (CPAN::Shell->expand("Module","/./")) {
        next unless $mod->inst_file;
d6289 2
a6290 2
        next unless $mod->inst_version eq "undef";
        print "No VERSION in ", $mod->id, "\n";
d6310 1
a6310 1
  for $mod (CPAN::Shell->expand("Module","/./")) {
d6320 1
a6320 1
  for $mod (CPAN::Shell->expand("Module","/Apache|LWP|CGI/")) {
d6335 6
d6382 6
a6387 7
Forces CPAN to perform a task that it normally would have refused to
do. Force takes as arguments a method name to be called and any number
of additional arguments that should be passed to the called method.
The internals of the object get the needed changes so that CPAN.pm
does not refuse to take the action. The C<force> is passed recursively
to all contained objects. See also the section above on the C<force>
and the C<fforce> pragma.
a6430 15
=item CPAN::Distribution::author

Returns the CPAN::Author object of the maintainer who uploaded this
distribution

=item CPAN::Distribution::pretty_id()

Returns a string of the form "AUTHORID/TARBALL", where AUTHORID is the
author's PAUSE ID and TARBALL is the distribution filename.

=item CPAN::Distribution::base_id()

Returns the distribution filename without any archive suffix.  E.g
"Foo-Bar-0.01"

d6458 5
a6462 6
Forces CPAN to perform a task that it normally would have refused to
do. Force takes as arguments a method name to be called and any number
of additional arguments that should be passed to the called method.
The internals of the object get the needed changes so that CPAN.pm
does not refuse to take the action. See also the section above on the
C<force> and the C<fforce> pragma.
a6478 11
This install method has only the power to install the distribution if
there are no dependencies in the way. To install an object and all of
its dependencies, use CPAN::Shell->install.

Note that install() gives no meaningful return value. See uptodate().

=item CPAN::Distribution::install_tested()

Install all the distributions that have been tested sucessfully but
not yet installed. See also C<is_tested>.

a6485 5
=item CPAN::Distribution::is_tested()

List all the distributions that have been tested sucessfully but not
yet installed. See also C<install_tested>.

d6496 1
a6496 23
Makefile.PL> or C<perl Build.PL> and C<make> there.

=item CPAN::Distribution::perldoc()

Downloads the pod documentation of the file associated with a
distribution (in html format) and runs it through the external
command lynx specified in C<$CPAN::Config->{lynx}>. If lynx
isn't available, it converts it to plain text with external
command html2text and runs it through the pager specified
in C<$CPAN::Config->{pager}>

=item CPAN::Distribution::prefs()

Returns the hash reference from the first matching YAML file that the
user has deposited in the C<prefs_dir/> directory. The first
succeeding match wins. The files in the C<prefs_dir/> are processed
alphabetically and the canonical distroname (e.g.
AUTHOR/Foo-Bar-3.14.tar.gz) is matched against the regular expressions
stored in the $root->{match}{distribution} attribute value.
Additionally all module names contained in a distribution are matched
agains the regular expressions in the $root->{match}{module} attribute
value. The two match values are ANDed together. Each of the two
attributes are optional.
d6501 3
a6503 7
as the the C<requires> and C<build_requires> elements. These can be
declared either by the C<META.yml> (if authoritative) or can be
deposited after the run of C<Build.PL> in the file C<./_build/prereqs>
or after the run of C<Makfile.PL> written as the C<PREREQ_PM> hash in
a comment in the produced C<Makefile>. I<Note>: this method only works
after an attempt has been made to C<make> the distribution. Returns
undef otherwise.
a6509 13
=item CPAN::Distribution::reports()

Downloads report data for this distribution from cpantesters.perl.org
and displays a subset of them.

=item CPAN::Distribution::read_yaml()

Returns the content of the META.yml of this distro as a hashref. Note:
works only after an attempt has been made to C<make> the distribution.
Returns undef otherwise. Also returns undef if the content of META.yml
is not authoritative. (The rules about what exactly makes the content
authoritative are still in flux.)

d6526 1
a6526 1
Reloads all indices if they have not been read for more than
d6538 1
a6538 7
Returns a one-line description of the module in four columns: The
first column contains the word C<Module>, the second column consists
of one character: an equals sign if this module is already installed
and uptodate, a less-than sign if this module is installed but can be
upgraded, and a space if the module is not installed. The third column
is the name of the module and the fourth column gives maintainer or
distribution information.
a6565 60
=item CPAN::Module::distribution()

Returns the CPAN::Distribution object that contains the current
version of this module.

=item CPAN::Module::dslip_status()

Returns a hash reference. The keys of the hash are the letters C<D>,
C<S>, C<L>, C<I>, and <P>, for development status, support level,
language, interface and public licence respectively. The data for the
DSLIP status are collected by pause.perl.org when authors register
their namespaces. The values of the 5 hash elements are one-character
words whose meaning is described in the table below. There are also 5
hash elements C<DV>, C<SV>, C<LV>, C<IV>, and <PV> that carry a more
verbose value of the 5 status variables.

Where the 'DSLIP' characters have the following meanings:

  D - Development Stage  (Note: *NO IMPLIED TIMESCALES*):
    i   - Idea, listed to gain consensus or as a placeholder
    c   - under construction but pre-alpha (not yet released)
    a/b - Alpha/Beta testing
    R   - Released
    M   - Mature (no rigorous definition)
    S   - Standard, supplied with Perl 5

  S - Support Level:
    m   - Mailing-list
    d   - Developer
    u   - Usenet newsgroup comp.lang.perl.modules
    n   - None known, try comp.lang.perl.modules
    a   - abandoned; volunteers welcome to take over maintainance

  L - Language Used:
    p   - Perl-only, no compiler needed, should be platform independent
    c   - C and perl, a C compiler will be needed
    h   - Hybrid, written in perl with optional C code, no compiler needed
    +   - C++ and perl, a C++ compiler will be needed
    o   - perl and another language other than C or C++

  I - Interface Style
    f   - plain Functions, no references used
    h   - hybrid, object and function interfaces available
    n   - no interface at all (huh?)
    r   - some use of unblessed References or ties
    O   - Object oriented using blessed references and/or inheritance

  P - Public License
    p   - Standard-Perl: user may choose between GPL and Artistic
    g   - GPL: GNU General Public License
    l   - LGPL: "GNU Lesser General Public License" (previously known as
          "GNU Library General Public License")
    b   - BSD: The BSD License
    a   - Artistic license alone
    2   - Artistic license 2.0 or later
    o   - open source: appoved by www.opensource.org
    d   - allows distribution without restrictions
    r   - restricted distribtion
    n   - no license at all

d6568 5
a6572 6
Forces CPAN to perform a task that it normally would have refused to
do. Force takes as arguments a method name to be called and any number
of additional arguments that should be passed to the called method.
The internals of the object get the needed changes so that CPAN.pm
does not refuse to take the action. See also the section above on the
C<force> and the C<fforce> pragma.
a6583 7
=item CPAN::Module::available_file()

Returns the filename of the module found in PERL5LIB or @@INC. The
first file found is reported. The advantage of this method over
C<inst_file> is that modules that have been tested but not yet
installed are included because PERL5LIB keeps track of tested modules.

d6586 1
a6586 5
Returns the version number of the installed module in readable format.

=item CPAN::Module::available_version()

Returns the version number of the available module in readable format.
a6608 4
=item CPAN::Module::perldoc()

Runs a C<perldoc> on this module.

a6612 4
=item CPAN::Module::reports()

Calls the reports() method on the associated distribution object.

d6655 1
a6655 1
    =head1 CONTENTS
d6677 1
a6677 1
=head1 PREREQUISITES
a6688 2
=head1 UTILITIES

d6712 2
a6713 2
C<Makefile.PL> or C<Build.PL> (well, we try to handle a bit more, but
without much enthusiasm).
d6724 18
a6741 3
For debugging the code of CPAN.pm itself in interactive mode some more
or less useful debugging aid can be turned on for most packages within
CPAN.pm with one of
d6743 1
a6743 1
=over 2
d6745 4
a6748 1
=item o debug package...
d6750 5
a6754 1
sets debug mode for packages.
d6756 2
a6757 1
=item o debug -package...
d6759 2
a6760 1
unsets debug mode for packages.
d6762 35
a6796 1
=item o debug all
d6798 2
a6799 1
turns debugging on for all packages.
d6801 1
a6801 1
=item o debug number
d6803 1
a6803 1
=back
d6805 1
a6805 2
which sets the debugging packages directly. Note that C<o debug 0>
turns debugging off.
d6807 1
a6807 14
What seems quite a successful strategy is the combination of C<reload
cpan> and the debugging switches. Add a new debug statement while
running in the shell and then issue a C<reload cpan> and see the new
debugging messages immediately without losing the current context.

C<o debug> without an argument lists the valid package names and the
current set of packages in debugging mode. C<o debug> has built-in
completion support.

For debugging of CPAN data there is the C<dump> command which takes
the same arguments as make/test/install and outputs each object's
Data::Dumper dump. If an argument looks like a perl variable and
contains one of C<$>, C<@@> or C<%>, it is eval()ed and fed to
Data::Dumper directly.
d6809 1
a6809 1
=head2 Floppy, Zip, Offline Mode
d6811 1
a6811 8
CPAN.pm works nicely without network too. If you maintain machines
that are not networked at all, you should consider working with file:
URLs. Of course, you have to collect your modules somewhere first. So
you might use CPAN.pm to put together all you need on a networked
machine. Then copy the $CPAN::Config->{keep_source_where} (but not
$CPAN::Config->{build_dir}) directory on a floppy. This floppy is kind
of a personal CPAN. CPAN.pm on the non-networked machines works nicely
with this floppy. See also below the paragraph about CD-ROM support.
d6813 2
a6814 1
=head2 Basic Utilities for Programmers
d6816 1
a6816 1
=over 2
d6818 1
a6818 1
=item has_inst($module)
d6820 1
a6820 6
Returns true if the module is installed. Used to load all modules into
the running CPAN.pm which are considered optional. The config variable
C<dontload_list> can be used to intercept the C<has_inst()> call such
that an optional module is not loaded despite being available. For
example the following command will prevent that C<YAML.pm> is being
loaded:
d6822 1
a6822 1
    cpan> o conf dontload_list push YAML
d6824 1
a6824 1
See the source for details.
d6826 1
a6826 1
=item has_usable($module)
d6828 3
a6830 3
Returns true if the module is installed and is in a usable state. Only
useful for a handful of modules that are used internally. See the
source for details.
d6832 1
a6832 1
=item instance($module)
d6834 1
a6834 3
The constructor for all the singletons used to represent modules,
distributions, authors and bundles. If the object already exists, this
method returns the object, otherwise it calls the constructor.
d6836 1
a6836 1
=back
d6838 1
a6838 1
=head1 SECURITY
d6840 6
a6845 4
There's no strong security layer in CPAN.pm. CPAN.pm helps you to
install foreign, unmasked, unsigned code on your machine. We compare
to a checksum that comes from the net just as the distribution file
itself. But we try to make it easy to add security on demand:
d6847 1
a6847 1
=head2 Cryptographically signed modules
d6849 3
a6851 5
Since release 1.77 CPAN.pm has been able to verify cryptographically
signed module distributions using Module::Signature.  The CPAN modules
can be signed by their authors, thus giving more security.  The simple
unsigned MD5 checksums that were used before by CPAN protect mainly
against accidental file corruption.
d6853 7
a6859 3
You will need to have Module::Signature installed, which in turn
requires that you have at least one of Crypt::OpenPGP module or the
command-line F<gpg> tool installed.
d6861 1
a6861 2
You will also need to be able to connect over the Internet to the public
keyservers, like pgp.mit.edu, and their port 11731 (the HKP protocol).
d6863 6
a6868 2
The configuration parameter check_sigs is there to turn signature
checking on or off.
a6875 23
=head1 ENVIRONMENT

When the CPAN shell enters a subshell via the look command, it sets
the environment CPAN_SHELL_LEVEL to 1 or increments it if it is
already set.

When CPAN runs, it sets the environment variable PERL5_CPAN_IS_RUNNING
to the ID of the running process. It also sets
PERL5_CPANPLUS_IS_RUNNING to prevent runaway processes which could
happen with older versions of Module::Install.

When running C<perl Makefile.PL>, the environment variable
C<PERL5_CPAN_IS_EXECUTING> is set to the full path of the
C<Makefile.PL> that is being executed. This prevents runaway processes
with newer versions of Module::Install.

When the config variable ftp_passive is set, all downloads will be run
with the environment variable FTP_PASSIVE set to this value. This is
in general a good idea as it influences both Net::FTP and LWP based
connections. The same effect can be achieved by starting the cpan
shell with this environment variable set. For Net::FTP alone, one can
also always set passive mode by running libnetcfg.

d6906 1
a6906 1
further information on firewalls, it is recommended to consult the
d6964 9
a6972 3
For accessing ftp servers behind such firewalls you usually need to
set the environment variable C<FTP_PASSIVE> or the config variable
ftp_passive to a true value.
d7057 1
a7057 19
First of all, you will want to use your own configuration, not the one
that your root user installed. If you do not have permission to write
in the cpan directory that root has configured, you will be asked if
you want to create your own config. Answering "yes" will bring you into
CPAN's configuration stage, using the system config for all defaults except
things that have to do with CPAN's work directory, saving your choices to
your MyConfig.pm file.

You can also manually initiate this process with the following command:

    % perl -MCPAN -e 'mkmyconfig'

or by running

    mkmyconfig

from the CPAN shell.

You will most probably also want to configure something like this:
d7061 2
a7062 12
                    INSTALLMAN3DIR=~/myperl/man/man3 \
                    INSTALLSCRIPT=~/myperl/bin \
                    INSTALLBIN=~/myperl/bin"

and then (oh joy) the equivalent command for Module::Build. That would
be

  o conf mbuildpl_arg "--lib=~/myperl/lib \
                    --installman1dir=~/myperl/man/man1 \
                    --installman3dir=~/myperl/man/man3 \
                    --installscript=~/myperl/bin \
                    --installbin=~/myperl/bin"
d7065 1
a7065 1
C<o conf commit> or by setting C<auto_commit> beforehand.
d7075 2
a7076 8
While we're speaking about $ENV{HOME}, it might be worth mentioning,
that for Windows we use the File::HomeDir module that provides an
equivalent to the concept of the home directory on Unix.

Another thing you should bear in mind is that the UNINST parameter can
be dangerous when you are installing into a private area because you
might accidentally remove modules that other people depend on that are
not using the private area.
d7082 1
a7082 1
Have a look at the C<look> (!) command.
d7092 12
a7103 11
install, it just uses data found in the META.yml file or the generated
Makefile. An undetected missing piece breaks the process. But it may
well be that your Bundle installs some prerequisite later than some
depending item and thus your second try is able to resolve everything.
Please note, CPAN.pm does not know the dependency tree in advance and
cannot sort the queue of things to install in a topologically correct
order. It resolves perfectly well IF all modules declare the
prerequisites correctly with the PREREQ_PM attribute to MakeMaker or
the C<requires> stanza of Module::Build. For bundles which fail and
you need to install often, it is recommended to sort the Bundle
definition file manually.
d7115 2
a7116 2
When I run CPAN's shell, I get an error message about things in my
/etc/inputrc (or ~/.inputrc) file.
d7118 4
a7121 5
These are readline issues and can only be fixed by studying readline
configuration on your architecture and adjusting the referenced file
accordingly. Please make a backup of the /etc/inputrc or ~/.inputrc
and edit them. Quite often harmless changes like uppercasing or
lowercasing some arguments solves the problem.
d7132 1
a7132 27
    cpan> o conf term_is_latin 1

If other charset support is needed, please file a bugreport against
CPAN.pm at rt.cpan.org and describe your needs. Maybe we can extend
the support or maybe UTF-8 terminals become widely available.

Note: this config variable is deprecated and will be removed in a
future version of CPAN.pm. It will be replaced with the conventions
around the family of $LANG and $LC_* environment variables.

=item 11)

When an install fails for some reason and then I correct the error
condition and retry, CPAN.pm refuses to install the module, saying
C<Already tried without success>.

Use the force pragma like so

  force install Foo::Bar

Or you can use

  look Foo::Bar

and then 'make install' directly in the subshell.

=item 12)
d7134 2
a7135 55
How do I install a "DEVELOPER RELEASE" of a module?

By default, CPAN will install the latest non-developer release of a
module. If you want to install a dev release, you have to specify the
partial path starting with the author id to the tarball you wish to
install, like so:

    cpan> install KWILLIAMS/Module-Build-0.27_07.tar.gz

Note that you can use the C<ls> command to get this path listed.

=item 13)

How do I install a module and all its dependencies from the commandline,
without being prompted for anything, despite my CPAN configuration
(or lack thereof)?

CPAN uses ExtUtils::MakeMaker's prompt() function to ask its questions, so
if you set the PERL_MM_USE_DEFAULT environment variable, you shouldn't be
asked any questions at all (assuming the modules you are installing are
nice about obeying that variable as well):

    % PERL_MM_USE_DEFAULT=1 perl -MCPAN -e 'install My::Module'

=item 14)

How do I create a Module::Build based Build.PL derived from an
ExtUtils::MakeMaker focused Makefile.PL?

http://search.cpan.org/search?query=Module::Build::Convert

http://www.refcnt.org/papers/module-build-convert

=item 15)

What's the best CPAN site for me?

The urllist config parameter is yours. You can add and remove sites at
will. You should find out which sites have the best uptodateness,
bandwidth, reliability, etc. and are topologically close to you. Some
people prefer fast downloads, others uptodateness, others reliability.
You decide which to try in which order.

Henk P. Penning maintains a site that collects data about CPAN sites:

  http://www.cs.uu.nl/people/henkp/mirmon/cpan.html

=item 16)

Why do I get asked the same questions every time I start the shell?

You can make your configuration changes permanent by calling the
command C<o conf commit>. Alternatively set the C<auto_commit>
variable to true by running C<o conf init auto_commit> and answering
the following question with yes.
a7138 28
=head1 COMPATIBILITY

=head2 OLD PERL VERSIONS

CPAN.pm is regularly tested to run under 5.004, 5.005, and assorted
newer versions. It is getting more and more difficult to get the
minimal prerequisites working on older perls. It is close to
impossible to get the whole Bundle::CPAN working there. If you're in
the position to have only these old versions, be advised that CPAN is
designed to work fine without the Bundle::CPAN installed.

To get things going, note that GBARR/Scalar-List-Utils-1.18.tar.gz is
compatible with ancient perls and that File::Temp is listed as a
prerequisite but CPAN has reasonable workarounds if it is missing.

=head2 CPANPLUS

This module and its competitor, the CPANPLUS module, are both much
cooler than the other. CPAN.pm is older. CPANPLUS was designed to be
more modular but it was never tried to make it compatible with CPAN.pm.

=head1 SECURITY ADVICE

This software enables you to upgrade software on your computer and so
is inherently dangerous because the newly installed software may
contain bugs and may alter the way your computer works or even make it
unusable. Please consider backing up your data before every upgrade.

d7141 12
a7152 6
Please report bugs via L<http://rt.cpan.org/>

Before submitting a bug, please make sure that the traditional method
of building a Perl module package from a shell by following the
installation instructions of that package still works in your
environment.
d7156 1
a7156 8
Andreas Koenig C<< <andk@@cpan.org> >>

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>
d7161 1
a7161 1
L<http://homepage3.nifty.com/hippo2000/perltips/CPAN.htm>
d7165 1
a7165 1
L<cpan>, L<CPAN::Nox>, L<CPAN::Version>
a7167 1

@


1.1.1.10
log
@import perl 5.10.1
@
text
@a1 1
# vim: ts=4 sts=4 sw=4:
d4 2
a5 2
$CPAN::VERSION = '1.9402';
$CPAN::VERSION =~ s/_//;
a6 11
# we need to run chdir all over and we would get at wrong libraries
# there
use File::Spec ();
BEGIN {
    if (File::Spec->can("rel2abs")) {
        for my $inc (@@INC) {
            $inc = File::Spec->rel2abs($inc) unless ref $inc;
        }
    }
}
use CPAN::Author;
a8 3
use CPAN::Bundle;
use CPAN::CacheMgr;
use CPAN::Complete;
a9 8
use CPAN::Distribution;
use CPAN::Distrostatus;
use CPAN::FTP;
use CPAN::Index 1.93; # https://rt.cpan.org/Ticket/Display.html?id=43349
use CPAN::InfoObj;
use CPAN::Module;
use CPAN::Prompt;
use CPAN::URL;
d12 1
a12 6
use CPAN::DeferredCode;
use CPAN::Shell;
use CPAN::LWP::UserAgent;
use CPAN::Exception::RecursiveDependency;
use CPAN::Exception::yaml_not_installed;

d15 1
a15 1
use Cwd qw(chdir);
d25 1
a32 1
# protect against "called too early"
a33 2
sub anycwd ();
sub _uniq;
d35 9
a46 29
if ($ENV{PERL5_CPAN_IS_RUNNING} && $$ != $ENV{PERL5_CPAN_IS_RUNNING}) {
    $ENV{PERL5_CPAN_IS_RUNNING_IN_RECURSION} ||= $ENV{PERL5_CPAN_IS_RUNNING};
    my @@rec = _uniq split(/,/, $ENV{PERL5_CPAN_IS_RUNNING_IN_RECURSION}), $$;
    $ENV{PERL5_CPAN_IS_RUNNING_IN_RECURSION} = join ",", @@rec;
    # warn "# Note: Recursive call of CPAN.pm detected\n";
    my $w = sprintf "# Note: CPAN.pm is running in process %d now", pop @@rec;
    my %sleep = (
                 5 => 30,
                 6 => 60,
                 7 => 120,
                );
    my $sleep = @@rec > 7 ? 300 : ($sleep{scalar @@rec}||0);
    my $verbose = @@rec >= 4;
    while (@@rec) {
        $w .= sprintf " which has been called by process %d", pop @@rec;
    }
    if ($sleep) {
        $w .= ".\n\n# Sleeping $sleep seconds to protect other processes\n";
    }
    if ($verbose) {
        warn $w;
    }
    local $| = 1;
    while ($sleep > 0) {
        printf "\r#%5d", --$sleep;
        sleep 1;
    }
    print "\n";
}
d59 1
a59 1
        "ftp://ftp.perl.org/pub/CPAN/";
d61 1
a61 2
# $CPAN::iCwd (i for initial)
$CPAN::iCwd ||= CPAN::anycwd();
d129 1
a129 1
    sub AUTOLOAD { ## no critic
a156 46
{
    my $x = *SAVEOUT; # avoid warning
    open($x,">&STDOUT") or die "dup failed";
    my $redir = 0;
    sub _redirect(@@) {
        #die if $redir;
        local $_;
        push(@@_,undef);
        while(defined($_=shift)) {
            if (s/^\s*>//){
                my ($m) = s/^>// ? ">" : "";
                s/\s+//;
                $_=shift unless length;
                die "no dest" unless defined;
                open(STDOUT,">$m$_") or die "open:$_:$!\n";
                $redir=1;
            } elsif ( s/^\s*\|\s*// ) {
                my $pipe="| $_";
                while(defined($_[0])){
                    $pipe .= ' ' . shift;
                }
                open(STDOUT,$pipe) or die "open:$pipe:$!\n";
                $redir=1;
            } else {
                push(@@_,$_);
            }
        }
        return @@_;
    }
    sub _unredirect {
        return unless $redir;
        $redir = 0;
        ## redirect: unredirect and propagate errors.  explicit close to wait for pipe.
        close(STDOUT);
        open(STDOUT,">&SAVEOUT");
        die "$@@" if "$@@";
        ## redirect: done
    }
}

sub _uniq {
    my(@@list) = @@_;
    my %seen;
    return grep { !$seen{$_}++ } @@list;
}

d219 1
a219 1
Enter 'h' for help.
d257 1
a257 2
            package
                CPAN::Eval; # hide from the indexer
d274 8
a281 21
            eval {
                local (*STDOUT)=*STDOUT;
                @@line = _redirect(@@line);
                CPAN::Shell->$command(@@line)
              };
            my $command_error = $@@;
            _unredirect;
            my $reported_error;
            if ($command_error) {
                my $err = $command_error;
                if (ref $err and $err->isa('CPAN::Exception::blocked_urllist')) {
                    $CPAN::Frontend->mywarn("Client not fully configured, please proceed with configuring.$err");
                    $reported_error = ref $err;
                } else {
                    # I'd prefer never to arrive here and make all errors exception objects
                    if ($err =~ /\S/) {
                        require Carp;
                        require Dumpvalue;
                        my $dv = Dumpvalue->new(tick => '"');
                        Carp::cluck(sprintf "Catching error: %s", $dv->stringify($err));
                    }
d301 1
a301 7
                # eval necessary for people without an urllist
                eval {CPAN::Shell->failed($CPAN::CurrentCommandId,1);};
                if (my $err = $@@) {
                    unless (ref $err and $reported_error eq ref $err) {
                        die $@@;
                    }
                }
d390 1
a390 1
    if ( $Config::Config{d_flock} || $Config::Config{d_fcntl_can_lock} ) {
d393 1
a393 1
        $CPAN::Frontend->mywarn("Your OS does not seem to support locking; continuing and ignoring all locking issues\n");
d436 2
a437 2
        # so we do it manually instead
        my $old_loadcode = ${"$yaml_module\::LoadCode"};
d440 1
a440 1
        my ($code, @@yaml);
d442 1
d448 1
d454 1
d460 1
a461 2
        ${"$yaml_module\::LoadCode"} = $old_loadcode;
        return \@@yaml;
d523 380
d991 1
a991 1
            $CPAN::Frontend->mywarn("Running in downgraded mode (experimental)\n");
d998 1
a998 1
            if (kill 0, $otherpid or $!{EPERM}) {
d1002 1
a1002 1
                        (qq{Shall I try to run in downgraded }.
d1005 1
a1005 1
                    $CPAN::Frontend->mywarn("Running in downgraded mode (experimental).
d1012 3
a1014 5
                        $_->{histfile}       = "";  # who should win otherwise?
                        $_->{cache_metadata} = 0;   # better would be a lock?
                        $_->{use_sqlite}     = 0;   # better would be a write lock!
                        $_->{auto_commit}    = 0;   # we are violent, do not persist
                        $_->{test_report}    = 0;   # Oliver Paukstadt had sent wrong reports in degraded mode
d1032 1
a1032 1
                    qq{Lockfile '$lockfile' not writable by you. }.
d1192 4
a1195 4
    unless ($perl) {
        my $candidate = File::Spec->catfile($CPAN::iCwd,$^X);
        $^X = $perl = $candidate if MM->maybe_command($candidate);
    }
d1204 1
a1204 1
                    $^X = $perl = $abs;
d1210 1
d1274 1
a1274 1
                                       unless (CPAN::Version->vge(Archive::Tar::->VERSION, 1.50)) {
a1279 4
                                       unless (CPAN::Version->vge(Archive::Tar::->VERSION, 1.50)) {
                                            my $atv = Archive::Tar->VERSION;
                                            $CPAN::Frontend->mywarn("You have Archive::Tar $atv, but 1.50 or later is recommended. Please upgrade.\n");
                                       }
d1347 8536
a9882 5
        my $v = eval "\$$mod\::VERSION";
        $v = $v ? " (v$v)" : "";
        CPAN::Shell->optprint("load_module","CPAN: $mod loaded ok$v\n");
        if ($mod eq "CPAN::WAIT") {
            push @@CPAN::Shell::ISA, 'CPAN::WAIT';
d9884 13
a9896 13
        return 1;
    } elsif ($mod eq "Net::FTP") {
        $CPAN::Frontend->mywarn(qq{
  Please, install Net::FTP as soon as possible. CPAN.pm installs it for you
  if you just type
      install Bundle::libnet

}) unless $Have_warned->{"Net::FTP"}++;
        $CPAN::Frontend->mysleep(3);
    } elsif ($mod eq "Digest::SHA") {
        if ($Have_warned->{"Digest::SHA"}++) {
            $CPAN::Frontend->mywarn(qq{CPAN: checksum security checks disabled }.
                                     qq{because Digest::SHA not installed.\n});
d9898 55
a9952 3
            $CPAN::Frontend->mywarn(qq{
  CPAN: checksum security checks disabled because Digest::SHA not installed.
  Please consider installing the Digest::SHA module.
d9954 21
a9974 2
});
            $CPAN::Frontend->mysleep(2);
d9976 9
a9984 20
    } elsif ($mod eq "Module::Signature") {
        # NOT prefs_lookup, we are not a distro
        my $check_sigs = $CPAN::Config->{check_sigs};
        if (not $check_sigs) {
            # they do not want us:-(
        } elsif (not $Have_warned->{"Module::Signature"}++) {
            # No point in complaining unless the user can
            # reasonably install and use it.
            if (eval { require Crypt::OpenPGP; 1 } ||
                (
                 defined $CPAN::Config->{'gpg'}
                 &&
                 $CPAN::Config->{'gpg'} =~ /\S/
                )
               ) {
                $CPAN::Frontend->mywarn(qq{
  CPAN: Module::Signature security checks disabled because Module::Signature
  not installed.  Please consider installing the Module::Signature module.
  You may also need to be able to connect over the Internet to the public
  keyservers like pgp.mit.edu (port 11371).
d9986 27
a10012 2
});
                $CPAN::Frontend->mysleep(2);
d10014 2
a10016 2
    } else {
        delete $INC{$file}; # if it inc'd LWP but failed during, say, URI
a10017 1
    return 0;
d10020 12
a10031 8
#-> sub CPAN::instance ;
sub instance {
    my($mgr,$class,$id) = @@_;
    CPAN::Index->reload;
    $id ||= "";
    # unsafe meta access, ok?
    return $META->{readwrite}{$class}{$id} if exists $META->{readwrite}{$class}{$id};
    $META->{readwrite}{$class}{$id} ||= $class->new(ID => $id);
d10034 4
a10037 3
#-> sub CPAN::new ;
sub new {
    bless {}, shift;
d10040 4
a10043 24
#-> sub CPAN::cleanup ;
sub cleanup {
  # warn "cleanup called with arg[@@_] End[$CPAN::End] Signal[$Signal]";
  local $SIG{__DIE__} = '';
  my($message) = @@_;
  my $i = 0;
  my $ineval = 0;
  my($subroutine);
  while ((undef,undef,undef,$subroutine) = caller(++$i)) {
      $ineval = 1, last if
        $subroutine eq '(eval)';
  }
  return if $ineval && !$CPAN::End;
  return unless defined $META->{LOCK};
  return unless -f $META->{LOCK};
  $META->savehist;
  close $META->{LOCKFH};
  unlink $META->{LOCK};
  # require Carp;
  # Carp::cluck("DEBUGGING");
  if ( $CPAN::CONFIG_DIRTY ) {
      $CPAN::Frontend->mywarn("Warning: Configuration not saved.\n");
  }
  $CPAN::Frontend->myprint("Lockfile removed.\n");
d10046 5
a10050 13
#-> sub CPAN::readhist
sub readhist {
    my($self,$term,$histfile) = @@_;
    my $histsize = $CPAN::Config->{'histsize'} || 100;
    $term->Attribs->{'MaxHistorySize'} = $histsize if (defined($term->Attribs->{'MaxHistorySize'}));
    my($fh) = FileHandle->new;
    open $fh, "<$histfile" or return;
    local $/ = "\n";
    while (<$fh>) {
        chomp;
        $term->AddHistory($_);
    }
    close $fh;
d10053 18
a10070 6
#-> sub CPAN::savehist
sub savehist {
    my($self) = @@_;
    my($histfile,$histsize);
    unless ($histfile = $CPAN::Config->{'histfile'}) {
        $CPAN::Frontend->mywarn("No history written (no histfile specified).\n");
d10073 33
a10105 5
    $histsize = $CPAN::Config->{'histsize'} || 100;
    if ($CPAN::term) {
        unless ($CPAN::term->can("GetHistory")) {
            $CPAN::Frontend->mywarn("Terminal does not support GetHistory.\n");
            return;
d10107 61
d10169 9
a10177 1
        return;
d10179 19
a10197 7
    my @@h = $CPAN::term->GetHistory;
    splice @@h, 0, @@h-$histsize if @@h>$histsize;
    my($fh) = FileHandle->new;
    open $fh, ">$histfile" or $CPAN::Frontend->mydie("Couldn't open >$histfile: $!");
    local $\ = local $, = "\n";
    print $fh @@h;
    close $fh;
d10200 14
a10213 6
#-> sub CPAN::is_tested
sub is_tested {
    my($self,$what,$when) = @@_;
    unless ($what) {
        Carp::cluck("DEBUG: empty what");
        return;
d10215 1
a10215 1
    $self->{is_tested}{$what} = $when;
d10218 14
a10231 5
#-> sub CPAN::reset_tested
# forget all distributions tested -- resets what gets included in PERL5LIB
sub reset_tested {
    my ($self) = @@_;
    $self->{is_tested} = {};
d10234 6
a10239 6
#-> sub CPAN::is_installed
# unsets the is_tested flag: as soon as the thing is installed, it is
# not needed in set_perl5lib anymore
sub is_installed {
    my($self,$what) = @@_;
    delete $self->{is_tested}{$what};
d10242 2
a10243 1
sub _list_sorted_descending_is_tested {
d10245 3
a10247 3
    sort
        { ($self->{is_tested}{$b}||0) <=> ($self->{is_tested}{$a}||0) }
            keys %{$self->{is_tested}}
d10250 9
a10258 19
#-> sub CPAN::set_perl5lib
# Notes on max environment variable length:
#   - Win32 : XP or later, 8191; Win2000 or NT4, 2047
{
my $fh;
sub set_perl5lib {
    my($self,$for) = @@_;
    unless ($for) {
        (undef,undef,undef,$for) = caller(1);
        $for =~ s/.*://;
    }
    $self->{is_tested} ||= {};
    return unless %{$self->{is_tested}};
    my $env = $ENV{PERL5LIB};
    $env = $ENV{PERLLIB} unless defined $env;
    my @@env;
    push @@env, split /\Q$Config::Config{path_sep}\E/, $env if defined $env and length $env;
    #my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} keys %{$self->{is_tested}};
    #$CPAN::Frontend->myprint("Prepending @@dirs to PERL5LIB.\n");
d10260 3
a10262 2
    my @@dirs = map {("$_/blib/arch", "$_/blib/lib")} $self->_list_sorted_descending_is_tested;
    return if !@@dirs;
d10264 5
a10268 22
    if (@@dirs < 12) {
        $CPAN::Frontend->optprint('perl5lib', "Prepending @@dirs to PERL5LIB for '$for'\n");
        $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
    } elsif (@@dirs < 24 ) {
        my @@d = map {my $cp = $_;
                     $cp =~ s/^\Q$CPAN::Config->{build_dir}\E/%BUILDDIR%/;
                     $cp
                 } @@dirs;
        $CPAN::Frontend->optprint('perl5lib', "Prepending @@d to PERL5LIB; ".
                                 "%BUILDDIR%=$CPAN::Config->{build_dir} ".
                                 "for '$for'\n"
                                );
        $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
    } else {
        my $cnt = keys %{$self->{is_tested}};
        $CPAN::Frontend->optprint('perl5lib', "Prepending blib/arch and blib/lib of ".
                                 "$cnt build dirs to PERL5LIB; ".
                                 "for '$for'\n"
                                );
        $ENV{PERL5LIB} = join $Config::Config{path_sep}, @@dirs, @@env;
    }
}}
d10270 2
d10323 2
a10324 2
capabilities and knows how to use Net::FTP, LWP, and certain external
download clients to fetch distributions from the net.
d10326 1
a10326 1
These are fetched from one or more mirrored CPAN (Comprehensive
d10329 2
a10330 2
The CPAN module also supports named and versioned
I<bundles> of modules. Bundles simplify handling of sets of
d10334 1
a10334 1
session manager keeps track of what has been fetched, built, and
d10337 1
a10337 1
using a simple FIFO mechanism.
d10344 1
a10344 1
Enter interactive mode by running
d10353 2
a10354 2
either of C<Term::ReadLine::Perl> or C<Term::ReadLine::Gnu> are installed,
history and command completion are supported.
d10356 2
a10357 2
Once at the command line, type C<h> for one-page help
screen; the rest should be self-explanatory.
d10359 2
a10360 2
The function call C<shell> takes two optional arguments: one the
prompt, the second the default initial command line (the latter
d10374 5
a10378 5
Arguments to these commands are either strings exactly matching
the identification string of an object, or regular expressions 
matched case-insensitively against various attributes of the
objects. The parser only recognizes a regular expression when you
enclose it with slashes.
d10380 1
a10380 1
The principle is that the number of objects found influences how an
d10382 2
a10383 2
displayed with the rather verbose method C<as_string>, but if 
more than one is found, each object is displayed with the terse method
a10385 38
Examples:

  cpan> m Acme::MetaSyntactic
  Module id = Acme::MetaSyntactic
      CPAN_USERID  BOOK (Philippe Bruhat (BooK) <[...]>)
      CPAN_VERSION 0.99
      CPAN_FILE    B/BO/BOOK/Acme-MetaSyntactic-0.99.tar.gz
      UPLOAD_DATE  2006-11-06
      MANPAGE      Acme::MetaSyntactic - Themed metasyntactic variables names
      INST_FILE    /usr/local/lib/perl/5.10.0/Acme/MetaSyntactic.pm
      INST_VERSION 0.99
  cpan> a BOOK
  Author id = BOOK
      EMAIL        [...]
      FULLNAME     Philippe Bruhat (BooK)
  cpan> d BOOK/Acme-MetaSyntactic-0.99.tar.gz
  Distribution id = B/BO/BOOK/Acme-MetaSyntactic-0.99.tar.gz
      CPAN_USERID  BOOK (Philippe Bruhat (BooK) <[...]>)
      CONTAINSMODS Acme::MetaSyntactic Acme::MetaSyntactic::Alias [...]
      UPLOAD_DATE  2006-11-06
  cpan> m /lorem/
  Module  = Acme::MetaSyntactic::loremipsum (BOOK/Acme-MetaSyntactic-0.99.tar.gz)
  Module    Text::Lorem            (ADEOLA/Text-Lorem-0.3.tar.gz)
  Module    Text::Lorem::More      (RKRIMEN/Text-Lorem-More-0.12.tar.gz)
  Module    Text::Lorem::More::Source (RKRIMEN/Text-Lorem-More-0.12.tar.gz)
  cpan> i /berlin/
  Distribution    BEATNIK/Filter-NumberLines-0.02.tar.gz
  Module  = DateTime::TimeZone::Europe::Berlin (DROLSKY/DateTime-TimeZone-0.7904.tar.gz)
  Module    Filter::NumberLines    (BEATNIK/Filter-NumberLines-0.02.tar.gz)
  Author          [...]

The examples illustrate several aspects: the first three queries
target modules, authors, or distros directly and yield exactly one
result. The last two use regular expressions and yield several
results. The last one targets all of bundles, modules, authors, and
distros simultaneously. When more than one result is available, they
are printed in one-line format.

d10399 1
a10399 1
Any C<make> or C<test> is run unconditionally. An
d10403 1
a10403 1
is also run unconditionally. But for
d10407 3
a10409 3
CPAN checks whether an install is needed and prints
I<module up to date> if the distribution file containing
the module doesn't need updating.
d10412 1
a10412 1
and doesn't try to build a package a second time regardless of whether it
d10417 2
a10418 2
C<make>, C<test>, or C<install>) to execute the command from scratch
and attempt to continue past certain errors. See the section below on
d10421 1
a10421 1
The C<notest> pragma skips the test part in the build
d10439 2
a10440 2
that directory. C<perldoc> displays the module's pod documentation 
in html or plain text format.
d10447 2
a10448 2
CPAN directory as stored in the CHECKUMS files distributed on
CPAN. The listing recurses into subdirectories.
d10450 1
a10450 1
The second form limits or expands the output with shell
d10462 1
a10462 1
regarded as a bug that may be changed in some future version.
d10479 3
a10481 3
signature matches the currently running perl, the stored state is
loaded into memory such that persistence between sessions
is effectively established.
d10488 1
a10488 1
A C<test> is repeated only if the previous test was unsuccessful. The
d10492 1
a10492 1
C<install> if the corresponding C<test> was not successful.
d10494 1
a10494 1
In all these cases, the user can override this stubborn behaviour by
d10502 1
a10502 1
Each I<forced> command is executed with the corresponding part of its
d10511 2
a10512 2
Interactive sessions maintain a lockfile, by default C<~/.cpan/.lock>.
Batch jobs can run without a lockfile and not disturb each other.
d10514 1
a10514 1
The shell offers to run in I<downgraded mode> when another process is
d10517 1
a10517 1
file, does not use the metadata file, and has a different prompt.
d10522 1
a10522 1
in the cpan-shell, it is intended that you can press C<^C> anytime and
d10528 1
a10528 1
CPAN.pm ignores SIGPIPE. If the user sets C<inactivity_timeout>, a
d10536 6
a10541 6
The commands available in the shell interface are methods in
the package CPAN::Shell. If you enter the shell command, your
input is split by the Text::ParseWords::shellwords() routine, which
acts like most shells do. The first word is interpreted as the
method to be invoked, and the rest of the words are treated as the method's arguments.
Continuation lines are supported by ending a line with a
d10560 1
a10560 1
configured or YAML not installed, no stats are provided.
d10564 1
a10564 1
mkmyconfig() writes your own CPAN::MyConfig file into your C<~/.cpan/>
d10566 1
a10566 1
system-wide ones.
d10571 3
a10573 2
displays them I<slowly>. While the command is running, a $SIG{INT} 
exits the loop after displaying the current item.
d10577 3
a10579 3
B<Note>: This whole command currently is just a hack and will
probably change in future versions of CPAN.pm, but the general
approach will likely remain.
d10585 1
a10585 1
recompile() is a special command that takes no argument and
d10589 1
a10589 1
installation. Imagine you have a common source tree for two different
d10606 1
a10606 1
arguments. The C<force> pragma reruns the tests and repeats
d10621 3
a10623 3
B<Note>: This whole command currently is just a hack and will
probably change in future versions of CPAN.pm, but the general
approach will likely remain.
d10636 2
a10637 2
for both users and programmer. CPAN.pm deals with the four
classes mentioned above, and those classes all share a set of methods. Classical
d10695 1
a10695 1
prerequisites, takes care of them recursively, and finally finishes the
a10701 7
=head2 Redirection

The usual shell redirection symbols C< | > and C<< > >> are recognized
by the cpan shell B<only when surrounded by whitespace>. So piping to
pager or redirecting output into a file works somewhat as in a normal
shell, with the stipulation that you must type extra spaces.

d10705 1
a10705 1
dialogue tries to determine a couple of site specific options. The
d10709 1
a10709 1
Default values defined in the CPAN/Config.pm file can be
d10711 1
a10711 1
best placed in C<$HOME/.cpan/CPAN/MyConfig.pm>, because C<$HOME/.cpan> is
d10731 1
a10731 1
Displays the current value(s) for this config variable. Without KEY,
d10738 2
a10739 2
If KEY starts and ends with a slash, the string in between is
treated as a regular expression and only keys matching this regex
d10763 1
a10763 1
Likewise, C<o conf KEY splice LIST> passes the LIST to the corresponding
d10793 2
a10794 2
The following keys in the hash reference $CPAN::Config are
currently defined:
d10806 4
a10816 7
  commands_quote     preferred character to use for quoting external
                     commands when running them. Defaults to double
                     quote on Windows, single tick everywhere else;
                     can be set to space to disable quoting
  connect_to_internet_ok
                     whether to ask if opening a connection is ok before
                     urllist is specified
a10824 2
  ftpstats_period    max number of days to keep download statistics
  ftpstats_size      max number of items to keep in the download statistics
a10827 2
  halt_on_failure    stop processing after the first failure of queued
                     items or dependencies
d10833 2
a10834 2
                     disable timeouts.
  index_expire       refetch index files after this many days 
d10836 1
a10836 1
                     if true, suppress the startup message
a10859 2
  patches_dir        local directory containing patch files
  perl5lib_verbosity verbosity level for PERL5LIB additions
d10864 1
a10864 1
                     used no matter the setting
a10883 3
  trust_test_report_history
                     skip testing when previously tested ok (according to
                     CPAN::Reporter history)
d10890 1
a10890 1
  yaml_load_code     enable YAML code deserialisation via CPAN::DeferredCode
d10938 3
a10940 3
determine its own current working directory. By default it uses
Cwd::cwd, but if for some reason this doesn't work on your system,
configure alternatives according to the following table:
d10977 2
a10978 2
URLs used for downloading. If the list contains any
C<file> URLs, CPAN always tries there first. This
d10987 1
a10987 1
module to see whether there is a local copy of the most recent version.
d11005 2
a11006 2
To get some interesting statistics, it is recommended that
C<randomize_urllist> be set; this introduces some amount of
d11014 3
a11016 3
C<build_requires_install_policy> to C<no>, such a module is not 
installed. It is only built and tested, and then kept in the list of
tested but uninstalled modules. As such, it is available during the
d11029 2
a11030 2
Distributions on CPAN usually behave according to what we call the
CPAN mantra. Or since the advent of Module::Build we should talk about
d11039 2
a11040 2
some extra data from the user via the environment, extra arguments, or
interactively--thus disturbing the installation of large bundles like
d11068 1
a11068 1
specify dependencies the original maintainer forgot 
d11081 1
a11081 1
The YAML files themselves must have the C<.yml> extension; all other
d11089 1
a11089 1
specification, and every document is treated as an entity that
d11092 1
a11092 1
Filenames can be picked arbitrarily; C<CPAN.pm> always reads
d11100 1
a11100 1
If neither your configured C<yaml_module> nor YAML.pm is installed,
d11120 1
a11120 1
a few YAML files to Data::Dumper for crucial modules like
a11136 1
    not_distribution: "\.zip$"
a11139 3
      not_cc: "gcc"
    env:
      DANCING_FLOOR: "Shubiduh"
a11225 7
=item features [array] *** EXPERIMENTAL FEATURE ***

Experimental implementation to deal with optional_features from
META.yml. Still needs coordination with installer software and
currently works only for META.yml declaring C<dynamic_config=0>. Use
with caution.

d11228 1
a11228 1
The canonical name of a delegate distribution to install
d11236 1
a11236 1
phase of the CPAN mantra. See below under I<Processing Instructions>.
d11241 1
a11241 1
CPAN mantra. See below under I<Processing Instructions>.
d11246 2
a11247 3
C<perl>, C<perlconfig>, and C<env> that specify whether a document is
targeted at a specific CPAN distribution or installation.
Keys prefixed with C<not_> negates the corresponding match.
d11261 1
a11261 2
living in the C<Config.pm> module.
Keys prefixed with C<not_> negates the corresponding match.
d11263 5
a11267 9
The value associated with C<env> is itself a hashref that is
matched against corresponding values in the C<%ENV> hash.
Keys prefixed with C<not_> negates the corresponding match.

If more than one restriction of C<module>, C<distribution>, etc. is
specified, the results of the separately computed match values must
all match. If so, the hashref represented by the
YAML document is returned as the preference structure for the current
distribution.
d11272 1
a11272 1
order via an external patch program. If the value for the C<-p>
d11274 1
a11274 6
beforehand. The path to each patch is either an absolute path on the
local filesystem or relative to a patch directory specified in the
C<patches_dir> configuration variable or in the format of a canonical
distroname. For examples please consult the distroprefs/ directory in
the CPAN.pm distribution (these examples are not installed by
default).
d11285 1
a11285 1
Build.PL> phase of the CPAN mantra. See below under I<Processing
d11291 1
a11291 1
of the CPAN mantra. See below under I<Processing Instructions>.
d11305 2
a11306 2
A full commandline to run via C<system()>.
During execution, the environment variable PERL is set
d11308 1
a11308 1
C<args> is not used.
d11320 3
a11322 3
C<timeout> denotes a timeout in seconds. Floating-point timeouts are
OK. With C<mode=deterministic>, the timeout denotes the
timeout per question; with C<mode=anyorder> it denotes the
d11327 1
a11327 1
strings. The Expect module watches the stream from the
d11331 2
a11332 2
For C<mode=deterministic>, the CPAN.pm injects the
corresponding answer as soon as the stream matches the regular expression.
d11334 1
a11334 1
For C<mode=anyorder> CPAN.pm answers a question as soon
d11336 1
a11336 1
this mode you can use the C<reuse> parameter to decide what will
d11338 2
a11339 2
default case (reuse=0) it is removed from the array, avoiding being
used again accidentally. If you want to answer the
d11353 1
a11353 1
eexpect:
d11364 1
a11364 1
syntactic correctness.
d11370 1
a11370 1
they cannot fit everybody's purpose. After all, the authors of the
d11373 1
a11373 1
needs. You have been warned:-)
d11377 2
a11378 2
If you do not enter the shell, shell commands are 
available both as methods (C<CPAN::Shell-E<gt>install(...)>) and as
d11380 1
a11380 1
commands, it makes sense to initialize components of CPAN you need, e.g.:
d11402 1
a11402 1
given. In scalar context, it returns only the first element of the
d11408 1
a11408 1
CPAN::Bundle objects for bundles, CPAN::Module objects for modules, and
d11436 1
a11436 1
Or if you want to schedule a I<cron> job to watch CPAN, you could list
d11441 4
a11444 4
If you don't want any output should all modules be
up to date, parse the output of above command for the regular
expression C</modules are up to date/> and decide to mail the output
only if it doesn't match. 
d11446 2
a11447 2
If you prefer to do it more in a programmerish style in one single
process, something like this may better suit you:
d11457 2
a11458 2
If that gives too much output every day, you may want to
watch only for three modules. You can write
d11589 2
a11590 2
Works only for distributions listed in the 02packages.details.txt.gz
file. This typically means that just most recent version of a
d11625 2
a11626 2
yet been run, it will be run first. A C<make test> is issued in
any case and if this fails, the install is cancelled. The
d11630 2
a11631 2
This install method only has the power to install the distribution if
there are no dependencies in the way. To install an object along with all 
d11638 1
a11638 1
Install all distributions that have tested sucessfully but
d11648 5
d11668 4
a11671 4
distribution (in HTML format) and runs it through the external
command I<lynx> specified in C<$CPAN::Config->{lynx}>. If I<lynx>
isn't available, it converts it to plain text with the external
command I<html2text> and runs it through the pager specified
d11679 1
a11679 1
alphabetically, and the canonical distroname (e.g.
d11683 1
a11683 1
against the regular expressions in the $root->{match}{module} attribute
d11690 1
a11690 1
as the C<requires> and C<build_requires> elements. These can be
d11705 1
a11705 1
Downloads report data for this distribution from www.cpantesters.org
d11840 3
a11842 3
Forces CPAN to perform a task it would normally refuse to
do. Force takes as arguments a method name to be invoked and any number
of additional arguments to pass that method.
d11854 1
a11854 1
is reported, just as perl itself stops searching @@INC once it finds a
d11889 1
a11889 1
headline, and returns it. Moreover, if the module has been downloaded
d11891 1
a11891 1
if it hasn't been installed yet.
d11972 1
a11972 1
"file:" URLs, then you only need a perl later than perl5.003 to run
d11974 1
a11974 1
required for non-UNIX systems, or if your nearest CPAN site is
d12007 1
a12007 1
with little enthusiasm).
d12013 4
a12016 4
Debugging this module is more than a bit complex due to interference from
the software producing the indices on CPAN, the mirroring process on CPAN,
packaging, configuration, synchronicity, and even (gasp!) due to bugs
within the CPAN.pm module itself.
d12018 2
a12019 2
For debugging the code of CPAN.pm itself in interactive mode, some 
debugging aid can be turned on for most packages within
d12043 1
a12043 1
What seems a successful strategy is the combination of C<reload
d12060 3
a12062 3
CPAN.pm works nicely without network access, too. If you maintain machines
that are not networked at all, you should consider working with C<file:>
URLs. You'll have to collect your modules somewhere first. So
d12076 2
a12077 2
the running CPAN.pm that are considered optional. The config variable
C<dontload_list> intercepts the C<has_inst()> call such
d12079 1
a12079 1
example, the following command will prevent C<YAML.pm> from being
d12088 1
a12088 1
Returns true if the module is installed and in a usable state. Only
d12095 2
a12096 2
distributions, authors, and bundles. If the object already exists, this
method returns the object; otherwise, it calls the constructor.
d12109 1
a12109 1
Since release 1.77, CPAN.pm has been able to verify cryptographically
d12127 1
a12127 1
Most functions in package CPAN are exported by default. The reason
d12134 1
a12134 1
the environment CPAN_SHELL_LEVEL to 1, or increments that variable if it is
d12156 1
a12156 1
Populating a freshly installed perl with one's favorite modules is pretty
d12160 2
a12161 2
file for all modules installed for the current perl
interpreter. It's recommended to run this command once only, and from then
d12167 1
a12167 2
then answer a few questions and go out for coffee (possibly
even in a different city).
d12173 3
a12175 3
prerequisites as early as possible. On the other hand, it's 
annoying that so many distributions need some interactive configuring. So
what you can try to accomplish in your private bundle file is to have the
d12177 2
a12178 2
ones later, so you can go out for cofeee after a few minutes and leave CPAN.pm
to churn away untended.
d12185 3
a12187 3
documentation that comes with the I<ncftp> program. If you are unable to
go through the firewall with a simple Perl setup, it is likely
that you can configure I<ncftp> so that it works through your firewall.
d12197 5
a12201 5
This is when the firewall machine runs a web server, and to access the
outside world, you must do so via that web server. If you set environment
variables like http_proxy or ftp_proxy to values beginning with http://,
or in your web browser you've proxy information set, then you know
you are running behind an http firewall.
d12204 1
a12204 1
ftp), you need LWP.
d12211 1
a12211 1
entering a username like "user@@outside.host.com".
d12213 2
a12214 2
To access servers outside these type of firewalls with perl, you
need Net::FTP.
d12216 1
a12216 1
=item One-way visibility
d12218 5
a12222 5
One-way visibility means these firewalls try to make themselves 
invisible to users inside the firewall. An FTP data connection is
normally created by sending your IP address to the remote server and then
listening for the return connection. But the remote server will not be able to
connect to you because of the firewall. For these types of firewall,
d12231 2
a12232 2
If you are using a SOCKS firewall, you will need to compile perl and link
it with the SOCKS library.  This is what is normally called a 'socksified'
d12234 1
a12234 1
the firewall as if it were not there.
d12238 3
a12240 4
This is when the firewall implemented in the kernel (via NAT, or networking
address translation), it allows you to hide a complete network behind one
IP address. With this firewall no special compiling is needed as you can
access hosts directly.
d12277 1
a12277 1
Probably you B<do> have the old version installed. This can
d12355 2
a12356 1
and then the equivalent command for Module::Build, which is
d12404 1
a12404 1
order. It resolves perfectly well B<if> all modules declare the
d12412 1
a12412 1
In our intranet, we have many modules for internal use. How
d12421 1
a12421 1
C</etc/inputrc> (or C<~/.inputrc>) file.
d12425 1
a12425 1
accordingly. Please make a backup of the C</etc/inputrc> or C<~/.inputrc>
d12462 1
a12462 1
and then C<make install> directly in the subshell.
d12501 1
a12501 2
I'm frequently irritated with the CPAN shell's inability to help me
select a good mirror.
a12512 8
Also, feel free to play with experimental features. Run

  o conf init randomize_urllist ftpstats_period ftpstats_size

and choose your favorite parameters. After a few downloads running the
C<hosts> command will probably assist you in choosing the best mirror
sites.

a12521 20
=item 17)

Older versions of CPAN.pm had the original root directory of all
tarballs in the build directory. Now there are always random
characters appended to these directory names. Why was this done?

The random characters are provided by File::Temp and ensure that each
module's individual build directory is unique. This makes running
CPAN.pm in concurrent processes simultaneously safe.

=item 18)

Speaking of the build directory. Do I have to clean it up myself?

You have the choice to set the config variable C<scan_cache> to
C<never>. Then you must clean it up yourself. The other possible
value, C<atstart> only cleans up the build directory when you start
the CPAN shell. If you never start up the CPAN shell, you probably
also have to clean up the build directory yourself.

d12543 1
a12543 1
more modular, but it was never intended to be compatible with CPAN.pm.
d12582 2
@


