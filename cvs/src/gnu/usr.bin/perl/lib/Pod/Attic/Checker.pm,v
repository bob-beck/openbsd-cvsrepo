head	1.5;
access;
symbols
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.8
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.6
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.4
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.6.0.2
	OPENBSD_3_6_BASE:1.1.1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2010.09.24.14.59.48;	author millert;	state dead;
branches;
next	1.4;

1.4
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2009.10.12.18.24.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2008.09.30.12.21.40;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.23.34;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.07;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.13.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.47.20;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.54;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.40;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.11.05;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#############################################################################
# Pod/Checker.pm -- check pod documents for syntax errors
#
# Copyright (C) 1994-2000 by Bradford Appleton. All rights reserved.
# This file is part of "PodParser". PodParser is free software;
# you can redistribute it and/or modify it under the same terms
# as Perl itself.
#############################################################################

package Pod::Checker;
use strict;

use vars qw($VERSION @@ISA @@EXPORT %VALID_COMMANDS %VALID_SEQUENCES);
$VERSION = '1.45';  ## Current version of this package
require  5.005;    ## requires this Perl version or later

use Pod::ParseUtils; ## for hyperlinks and lists

=head1 NAME

Pod::Checker, podchecker - check pod documents for syntax errors

=head1 SYNOPSIS

  use Pod::Checker;

  $syntax_okay = podchecker($filepath, $outputpath, %options);

  my $checker = new Pod::Checker %options;
  $checker->parse_from_file($filepath, \*STDERR);

=head1 OPTIONS/ARGUMENTS

C<$filepath> is the input POD to read and C<$outputpath> is
where to write POD syntax error messages. Either argument may be a scalar
indicating a file-path, or else a reference to an open filehandle.
If unspecified, the input-file it defaults to C<\*STDIN>, and
the output-file defaults to C<\*STDERR>.

=head2 podchecker()

This function can take a hash of options:

=over 4

=item B<-warnings> =E<gt> I<val>

Turn warnings on/off. I<val> is usually 1 for on, but higher values
trigger additional warnings. See L<"Warnings">.

=back

=head1 DESCRIPTION

B<podchecker> will perform syntax checking of Perl5 POD format documentation.

Curious/ambitious users are welcome to propose additional features they wish
to see in B<Pod::Checker> and B<podchecker> and verify that the checks are
consistent with L<perlpod>.

The following checks are currently performed:

=over 4

=item *

Unknown '=xxxx' commands, unknown 'XE<lt>...E<gt>' interior-sequences,
and unterminated interior sequences.

=item *

Check for proper balancing of C<=begin> and C<=end>. The contents of such
a block are generally ignored, i.e. no syntax checks are performed.

=item *

Check for proper nesting and balancing of C<=over>, C<=item> and C<=back>.

=item *

Check for same nested interior-sequences (e.g.
C<LE<lt>...LE<lt>...E<gt>...E<gt>>).

=item *

Check for malformed or non-existing entities C<EE<lt>...E<gt>>.

=item *

Check for correct syntax of hyperlinks C<LE<lt>...E<gt>>. See L<perlpod>
for details.

=item *

Check for unresolved document-internal links. This check may also reveal
misspelled links that seem to be internal links but should be links
to something else.

=back

=head1 DIAGNOSTICS

=head2 Errors

=over 4

=item * empty =headn

A heading (C<=head1> or C<=head2>) without any text? That ain't no
heading!

=item * =over on line I<N> without closing =back

The C<=over> command does not have a corresponding C<=back> before the
next heading (C<=head1> or C<=head2>) or the end of the file.

=item * =item without previous =over

=item * =back without previous =over

An C<=item> or C<=back> command has been found outside a
C<=over>/C<=back> block.

=item * No argument for =begin

A C<=begin> command was found that is not followed by the formatter
specification.

=item * =end without =begin

A standalone C<=end> command was found.

=item * Nested =begin's

There were at least two consecutive C<=begin> commands without
the corresponding C<=end>. Only one C<=begin> may be active at
a time.

=item * =for without formatter specification

There is no specification of the formatter after the C<=for> command.

=item * unresolved internal link I<NAME>

The given link to I<NAME> does not have a matching node in the current
POD. This also happened when a single word node name is not enclosed in
C<"">.

=item * Unknown command "I<CMD>"

An invalid POD command has been found. Valid are C<=head1>, C<=head2>,
C<=head3>, C<=head4>, C<=over>, C<=item>, C<=back>, C<=begin>, C<=end>,
C<=for>, C<=pod>, C<=cut>

=item * Unknown interior-sequence "I<SEQ>"

An invalid markup command has been encountered. Valid are:
C<BE<lt>E<gt>>, C<CE<lt>E<gt>>, C<EE<lt>E<gt>>, C<FE<lt>E<gt>>,
C<IE<lt>E<gt>>, C<LE<lt>E<gt>>, C<SE<lt>E<gt>>, C<XE<lt>E<gt>>,
C<ZE<lt>E<gt>>

=item * nested commands I<CMD>E<lt>...I<CMD>E<lt>...E<gt>...E<gt>

Two nested identical markup commands have been found. Generally this
does not make sense.

=item * garbled entity I<STRING>

The I<STRING> found cannot be interpreted as a character entity.

=item * Entity number out of range

An entity specified by number (dec, hex, oct) is out of range (1-255).

=item * malformed link LE<lt>E<gt>

The link found cannot be parsed because it does not conform to the
syntax described in L<perlpod>.

=item * nonempty ZE<lt>E<gt>

The C<ZE<lt>E<gt>> sequence is supposed to be empty.

=item * empty XE<lt>E<gt>

The index entry specified contains nothing but whitespace.

=item * Spurious text after =pod / =cut

The commands C<=pod> and C<=cut> do not take any arguments.

=item * Spurious character(s) after =back

The C<=back> command does not take any arguments.

=back

=head2 Warnings

These may not necessarily cause trouble, but indicate mediocre style.

=over 4

=item * multiple occurrence of link target I<name>

The POD file has some C<=item> and/or C<=head> commands that have
the same text. Potential hyperlinks to such a text cannot be unique then.
This warning is printed only with warning level greater than one.

=item * line containing nothing but whitespace in paragraph

There is some whitespace on a seemingly empty line. POD is very sensitive
to such things, so this is flagged. B<vi> users switch on the B<list>
option to avoid this problem.

=begin _disabled_

=item * file does not start with =head

The file starts with a different POD directive than head.
This is most probably something you do not want.

=end _disabled_

=item * previous =item has no contents

There is a list C<=item> right above the flagged line that has no
text contents. You probably want to delete empty items.

=item * preceding non-item paragraph(s)

A list introduced by C<=over> starts with a text or verbatim paragraph,
but continues with C<=item>s. Move the non-item paragraph out of the
C<=over>/C<=back> block.

=item * =item type mismatch (I<one> vs. I<two>)

A list started with e.g. a bullet-like C<=item> and continued with a
numbered one. This is obviously inconsistent. For most translators the
type of the I<first> C<=item> determines the type of the list.

=item * I<N> unescaped C<E<lt>E<gt>> in paragraph

Angle brackets not written as C<E<lt>ltE<gt>> and C<E<lt>gtE<gt>>
can potentially cause errors as they could be misinterpreted as
markup commands. This is only printed when the -warnings level is
greater than 1.

=item * Unknown entity

A character entity was found that does not belong to the standard
ISO set or the POD specials C<verbar> and C<sol>.

=item * No items in =over

The list opened with C<=over> does not contain any items.

=item * No argument for =item

C<=item> without any parameters is deprecated. It should either be followed
by C<*> to indicate an unordered list, by a number (optionally followed
by a dot) to indicate an ordered (numbered) list or simple text for a
definition list.

=item * empty section in previous paragraph

The previous section (introduced by a C<=head> command) does not contain
any text. This usually indicates that something is missing. Note: A
C<=head1> followed immediately by C<=head2> does not trigger this warning.

=item * Verbatim paragraph in NAME section

The NAME section (C<=head1 NAME>) should consist of a single paragraph
with the script/module name, followed by a dash `-' and a very short
description of what the thing is good for.

=item * =headI<n> without preceding higher level

For example if there is a C<=head2> in the POD file prior to a
C<=head1>.

=back

=head2 Hyperlinks

There are some warnings with respect to malformed hyperlinks:

=over 4

=item * ignoring leading/trailing whitespace in link

There is whitespace at the beginning or the end of the contents of
LE<lt>...E<gt>.

=item * (section) in '$page' deprecated

There is a section detected in the page name of LE<lt>...E<gt>, e.g.
C<LE<lt>passwd(2)E<gt>>. POD hyperlinks may point to POD documents only.
Please write C<CE<lt>passwd(2)E<gt>> instead. Some formatters are able
to expand this to appropriate code. For links to (builtin) functions,
please say C<LE<lt>perlfunc/mkdirE<gt>>, without ().

=item * alternative text/node '%s' contains non-escaped | or /

The characters C<|> and C</> are special in the LE<lt>...E<gt> context.
Although the hyperlink parser does its best to determine which "/" is
text and which is a delimiter in case of doubt, one ought to escape
these literal characters like this:

  /     E<sol>
  |     E<verbar>

=back

=head1 RETURN VALUE

B<podchecker> returns the number of POD syntax errors found or -1 if
there were no POD commands at all found in the file.

=head1 EXAMPLES

See L</SYNOPSIS>

=head1 INTERFACE

While checking, this module collects document properties, e.g. the nodes
for hyperlinks (C<=headX>, C<=item>) and index entries (C<XE<lt>E<gt>>).
POD translators can use this feature to syntax-check and get the nodes in
a first pass before actually starting to convert. This is expensive in terms
of execution time, but allows for very robust conversions.

Since PodParser-1.24 the B<Pod::Checker> module uses only the B<poderror>
method to print errors and warnings. The summary output (e.g.
"Pod syntax OK") has been dropped from the module and has been included in
B<podchecker> (the script). This allows users of B<Pod::Checker> to
control completely the output behavior. Users of B<podchecker> (the script)
get the well-known behavior.

=cut

#############################################################################

#use diagnostics;
use Carp qw(croak);
use Exporter;
use Pod::Parser;

@@ISA = qw(Pod::Parser);
@@EXPORT = qw(&podchecker);

my %VALID_COMMANDS = (
    'pod'    =>  1,
    'cut'    =>  1,
    'head1'  =>  1,
    'head2'  =>  1,
    'head3'  =>  1,
    'head4'  =>  1,
    'over'   =>  1,
    'back'   =>  1,
    'item'   =>  1,
    'for'    =>  1,
    'begin'  =>  1,
    'end'    =>  1,
    'encoding' =>  1,
);

my %VALID_SEQUENCES = (
    'I'  =>  1,
    'B'  =>  1,
    'S'  =>  1,
    'C'  =>  1,
    'L'  =>  1,
    'F'  =>  1,
    'X'  =>  1,
    'Z'  =>  1,
    'E'  =>  1,
);

# stolen from HTML::Entities
my %ENTITIES = (
 # Some normal chars that have special meaning in SGML context
 amp    => '&',  # ampersand
'gt'    => '>',  # greater than
'lt'    => '<',  # less than
 quot   => '"',  # double quote

 # PUBLIC ISO 8879-1986//ENTITIES Added Latin 1//EN//HTML
 AElig  => 'Æ',  # capital AE diphthong (ligature)
 Aacute => 'Á',  # capital A, acute accent
 Acirc  => 'Â',  # capital A, circumflex accent
 Agrave => 'À',  # capital A, grave accent
 Aring  => 'Å',  # capital A, ring
 Atilde => 'Ã',  # capital A, tilde
 Auml   => 'Ä',  # capital A, dieresis or umlaut mark
 Ccedil => 'Ç',  # capital C, cedilla
 ETH    => 'Ð',  # capital Eth, Icelandic
 Eacute => 'É',  # capital E, acute accent
 Ecirc  => 'Ê',  # capital E, circumflex accent
 Egrave => 'È',  # capital E, grave accent
 Euml   => 'Ë',  # capital E, dieresis or umlaut mark
 Iacute => 'Í',  # capital I, acute accent
 Icirc  => 'Î',  # capital I, circumflex accent
 Igrave => 'Ì',  # capital I, grave accent
 Iuml   => 'Ï',  # capital I, dieresis or umlaut mark
 Ntilde => 'Ñ',  # capital N, tilde
 Oacute => 'Ó',  # capital O, acute accent
 Ocirc  => 'Ô',  # capital O, circumflex accent
 Ograve => 'Ò',  # capital O, grave accent
 Oslash => 'Ø',  # capital O, slash
 Otilde => 'Õ',  # capital O, tilde
 Ouml   => 'Ö',  # capital O, dieresis or umlaut mark
 THORN  => 'Þ',  # capital THORN, Icelandic
 Uacute => 'Ú',  # capital U, acute accent
 Ucirc  => 'Û',  # capital U, circumflex accent
 Ugrave => 'Ù',  # capital U, grave accent
 Uuml   => 'Ü',  # capital U, dieresis or umlaut mark
 Yacute => 'Ý',  # capital Y, acute accent
 aacute => 'á',  # small a, acute accent
 acirc  => 'â',  # small a, circumflex accent
 aelig  => 'æ',  # small ae diphthong (ligature)
 agrave => 'à',  # small a, grave accent
 aring  => 'å',  # small a, ring
 atilde => 'ã',  # small a, tilde
 auml   => 'ä',  # small a, dieresis or umlaut mark
 ccedil => 'ç',  # small c, cedilla
 eacute => 'é',  # small e, acute accent
 ecirc  => 'ê',  # small e, circumflex accent
 egrave => 'è',  # small e, grave accent
 eth    => 'ð',  # small eth, Icelandic
 euml   => 'ë',  # small e, dieresis or umlaut mark
 iacute => 'í',  # small i, acute accent
 icirc  => 'î',  # small i, circumflex accent
 igrave => 'ì',  # small i, grave accent
 iuml   => 'ï',  # small i, dieresis or umlaut mark
 ntilde => 'ñ',  # small n, tilde
 oacute => 'ó',  # small o, acute accent
 ocirc  => 'ô',  # small o, circumflex accent
 ograve => 'ò',  # small o, grave accent
 oslash => 'ø',  # small o, slash
 otilde => 'õ',  # small o, tilde
 ouml   => 'ö',  # small o, dieresis or umlaut mark
 szlig  => 'ß',  # small sharp s, German (sz ligature)
 thorn  => 'þ',  # small thorn, Icelandic
 uacute => 'ú',  # small u, acute accent
 ucirc  => 'û',  # small u, circumflex accent
 ugrave => 'ù',  # small u, grave accent
 uuml   => 'ü',  # small u, dieresis or umlaut mark
 yacute => 'ý',  # small y, acute accent
 yuml   => 'ÿ',  # small y, dieresis or umlaut mark

 # Some extra Latin 1 chars that are listed in the HTML3.2 draft (21-May-96)
 copy   => '©',  # copyright sign
 reg    => '®',  # registered sign
 nbsp   => "\240", # non breaking space

 # Additional ISO-8859/1 entities listed in rfc1866 (section 14)
 iexcl  => '¡',
 cent   => '¢',
 pound  => '£',
 curren => '¤',
 yen    => '¥',
 brvbar => '¦',
 sect   => '§',
 uml    => '¨',
 ordf   => 'ª',
 laquo  => '«',
'not'   => '¬',    # not is a keyword in perl
 shy    => '­',
 macr   => '¯',
 deg    => '°',
 plusmn => '±',
 sup1   => '¹',
 sup2   => '²',
 sup3   => '³',
 acute  => '´',
 micro  => 'µ',
 para   => '¶',
 middot => '·',
 cedil  => '¸',
 ordm   => 'º',
 raquo  => '»',
 frac14 => '¼',
 frac12 => '½',
 frac34 => '¾',
 iquest => '¿',
'times' => '×',    # times is a keyword in perl
 divide => '÷',

# some POD special entities
 verbar => '|',
 sol => '/'
);

##---------------------------------------------------------------------------

##---------------------------------
## Function definitions begin here
##---------------------------------

sub podchecker {
    my ($infile, $outfile, %options) = @@_;
    local $_;

    ## Set defaults
    $infile  ||= \*STDIN;
    $outfile ||= \*STDERR;

    ## Now create a pod checker
    my $checker = new Pod::Checker(%options);

    ## Now check the pod document for errors
    $checker->parse_from_file($infile, $outfile);

    ## Return the number of errors found
    return $checker->num_errors();
}

##---------------------------------------------------------------------------

##-------------------------------
## Method definitions begin here
##-------------------------------

##################################

=over 4

=item C<Pod::Checker-E<gt>new( %options )>

Return a reference to a new Pod::Checker object that inherits from
Pod::Parser and is used for calling the required methods later. The
following options are recognized:

C<-warnings =E<gt> num>
  Print warnings if C<num> is true. The higher the value of C<num>,
the more warnings are printed. Currently there are only levels 1 and 2.

C<-quiet =E<gt> num>
  If C<num> is true, do not print any errors/warnings. This is useful
when Pod::Checker is used to munge POD code into plain text from within
POD formatters.

=cut

## sub new {
##     my $this = shift;
##     my $class = ref($this) || $this;
##     my %params = @@_;
##     my $self = {%params};
##     bless $self, $class;
##     $self->initialize();
##     return $self;
## }

sub initialize {
    my $self = shift;
    ## Initialize number of errors, and setup an error function to
    ## increment this number and then print to the designated output.
    $self->{_NUM_ERRORS} = 0;
    $self->{_NUM_WARNINGS} = 0;
    $self->{-quiet} ||= 0;
    # set the error handling subroutine
    $self->errorsub($self->{-quiet} ? sub { 1; } : 'poderror');
    $self->{_commands} = 0; # total number of POD commands encountered
    $self->{_list_stack} = []; # stack for nested lists
    $self->{_have_begin} = ''; # stores =begin
    $self->{_links} = []; # stack for internal hyperlinks
    $self->{_nodes} = []; # stack for =head/=item nodes
    $self->{_index} = []; # text in X<>
    # print warnings?
    $self->{-warnings} = 1 unless(defined $self->{-warnings});
    $self->{_current_head1} = ''; # the current =head1 block
    $self->parseopts(-process_cut_cmd => 1, -warnings => $self->{-warnings});
}

##################################

=item C<$checker-E<gt>poderror( @@args )>

=item C<$checker-E<gt>poderror( {%opts}, @@args )>

Internal method for printing errors and warnings. If no options are
given, simply prints "@@_". The following options are recognized and used
to form the output:

  -msg

A message to print prior to C<@@args>.

  -line

The line number the error occurred in.

  -file

The file (name) the error occurred in.

  -severity

The error level, should be 'WARNING' or 'ERROR'.

=cut

# Invoked as $self->poderror( @@args ), or $self->poderror( {%opts}, @@args )
sub poderror {
    my $self = shift;
    my %opts = (ref $_[0]) ? %{shift()} : ();

    ## Retrieve options
    chomp( my $msg  = ($opts{-msg} || '')."@@_" );
    my $line = (exists $opts{-line}) ? " at line $opts{-line}" : '';
    my $file = (exists $opts{-file}) ? " in file $opts{-file}" : '';
    unless (exists $opts{-severity}) {
       ## See if can find severity in message prefix
       $opts{-severity} = $1  if ( $msg =~ s/^\**\s*([A-Z]{3,}):\s+// );
    }
    my $severity = (exists $opts{-severity}) ? "*** $opts{-severity}: " : '';

    ## Increment error count and print message "
    ++($self->{_NUM_ERRORS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'ERROR'));
    ++($self->{_NUM_WARNINGS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'WARNING'));
    unless($self->{-quiet}) {
      my $out_fh = $self->output_handle() || \*STDERR;
      print $out_fh ($severity, $msg, $line, $file, "\n")
        if($self->{-warnings} || !%opts || $opts{-severity} ne 'WARNING');
    }
}

##################################

=item C<$checker-E<gt>num_errors()>

Set (if argument specified) and retrieve the number of errors found.

=cut

sub num_errors {
   return (@@_ > 1) ? ($_[0]->{_NUM_ERRORS} = $_[1]) : $_[0]->{_NUM_ERRORS};
}

##################################

=item C<$checker-E<gt>num_warnings()>

Set (if argument specified) and retrieve the number of warnings found.

=cut

sub num_warnings {
   return (@@_ > 1) ? ($_[0]->{_NUM_WARNINGS} = $_[1]) : $_[0]->{_NUM_WARNINGS};
}

##################################

=item C<$checker-E<gt>name()>

Set (if argument specified) and retrieve the canonical name of POD as
found in the C<=head1 NAME> section.

=cut

sub name {
    return (@@_ > 1 && $_[1]) ?
        ($_[0]->{-name} = $_[1]) : $_[0]->{-name};
}

##################################

=item C<$checker-E<gt>node()>

Add (if argument specified) and retrieve the nodes (as defined by C<=headX>
and C<=item>) of the current POD. The nodes are returned in the order of
their occurrence. They consist of plain text, each piece of whitespace is
collapsed to a single blank.

=cut

sub node {
    my ($self,$text) = @@_;
    if(defined $text) {
        $text =~ s/\s+$//s; # strip trailing whitespace
        $text =~ s/\s+/ /gs; # collapse whitespace
        # add node, order important!
        push(@@{$self->{_nodes}}, $text);
        # keep also a uniqueness counter
        $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
        return $text;
    }
    @@{$self->{_nodes}};
}

##################################

=item C<$checker-E<gt>idx()>

Add (if argument specified) and retrieve the index entries (as defined by
C<XE<lt>E<gt>>) of the current POD. They consist of plain text, each piece
of whitespace is collapsed to a single blank.

=cut

# set/return index entries of current POD
sub idx {
    my ($self,$text) = @@_;
    if(defined $text) {
        $text =~ s/\s+$//s; # strip trailing whitespace
        $text =~ s/\s+/ /gs; # collapse whitespace
        # add node, order important!
        push(@@{$self->{_index}}, $text);
        # keep also a uniqueness counter
        $self->{_unique_nodes}->{$text}++ if($text !~ /^\s*$/s);
        return $text;
    }
    @@{$self->{_index}};
}

##################################

=item C<$checker-E<gt>hyperlink()>

Add (if argument specified) and retrieve the hyperlinks (as defined by
C<LE<lt>E<gt>>) of the current POD. They consist of a 2-item array: line
number and C<Pod::Hyperlink> object.

=back

=cut

# set/return hyperlinks of the current POD
sub hyperlink {
    my $self = shift;
    if($_[0]) {
        push(@@{$self->{_links}}, $_[0]);
        return $_[0];
    }
    @@{$self->{_links}};
}

## overrides for Pod::Parser

sub end_pod {
    ## Do some final checks and
    ## print the number of errors found
    my $self   = shift;
    my $infile = $self->input_file();

    if(@@{$self->{_list_stack}}) {
        my $list;
        while(($list = $self->_close_list('EOF',$infile)) &&
          $list->indent() ne 'auto') {
            $self->poderror({ -line => 'EOF', -file => $infile,
                -severity => 'ERROR', -msg => '=over on line ' .
                $list->start() . ' without closing =back' });
        }
    }

    # check validity of document internal hyperlinks
    # first build the node names from the paragraph text
    my %nodes;
    foreach($self->node()) {
        $nodes{$_} = 1;
        if(/^(\S+)\s+\S/) {
            # we have more than one word. Use the first as a node, too.
            # This is used heavily in perlfunc.pod
            $nodes{$1} ||= 2; # derived node
        }
    }
    foreach($self->idx()) {
        $nodes{$_} = 3; # index node
    }
    foreach($self->hyperlink()) {
        my ($line,$link) = @@$_;
        # _TODO_ what if there is a link to the page itself by the name,
        # e.g. in Tk::Pod : L<Tk::Pod/"DESCRIPTION">
        if($link->node() && !$link->page() && $link->type() ne 'hyperlink') {
            my $node = $self->_check_ptree($self->parse_text($link->node(),
                $line), $line, $infile, 'L');
            if($node && !$nodes{$node}) {
                $self->poderror({ -line => $line || '', -file => $infile,
                    -severity => 'ERROR',
                    -msg => "unresolved internal link '$node'"});
            }
        }
    }

    # check the internal nodes for uniqueness. This pertains to
    # =headX, =item and X<...>
    if($self->{-warnings} && $self->{-warnings}>1) {
      foreach(grep($self->{_unique_nodes}->{$_} > 1,
        keys %{$self->{_unique_nodes}})) {
          $self->poderror({ -line => '-', -file => $infile,
            -severity => 'WARNING',
            -msg => "multiple occurrence of link target '$_'"});
      }
    }

    # no POD found here
    $self->num_errors(-1) if($self->{_commands} == 0);
}

# check a POD command directive
sub command {
    my ($self, $cmd, $paragraph, $line_num, $pod_para) = @@_;
    my ($file, $line) = $pod_para->file_line;
    ## Check the command syntax
    my $arg; # this will hold the command argument
    if (! $VALID_COMMANDS{$cmd}) {
       $self->poderror({ -line => $line, -file => $file, -severity => 'ERROR',
                         -msg => "Unknown command '$cmd'" });
    }
    else { # found a valid command
        $self->{_commands}++; # delete this line if below is enabled again

        ##### following check disabled due to strong request
        #if(!$self->{_commands}++ && $cmd !~ /^head/) {
        #    $self->poderror({ -line => $line, -file => $file,
        #         -severity => 'WARNING',
        #         -msg => "file does not start with =head" });
        #}

        # check syntax of particular command
        if($cmd eq 'over') {
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            my $indent = 4; # default
            if($arg && $arg =~ /^\s*(\d+)\s*$/) {
                $indent = $1;
            }
            # start a new list
            $self->_open_list($indent,$line,$file);
        }
        elsif($cmd eq 'item') {
            # are we in a list?
            unless(@@{$self->{_list_stack}}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=item without previous =over' });
                # auto-open in case we encounter many more
                $self->_open_list('auto',$line,$file);
            }
            my $list = $self->{_list_stack}->[0];
            # check whether the previous item had some contents
            if(defined $self->{_list_item_contents} &&
              $self->{_list_item_contents} == 0) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'previous =item has no contents' });
            }
            if($list->{_has_par}) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'preceding non-item paragraph(s)' });
                delete $list->{_has_par};
            }
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line, $file);
            if($arg && $arg =~ /(\S+)/) {
                $arg =~ s/[\s\n]+$//;
                my $type;
                if($arg =~ /^[*]\s*(\S*.*)/) {
                  $type = 'bullet';
                  $self->{_list_item_contents} = $1 ? 1 : 0;
                  $arg = $1;
                }
                elsif($arg =~ /^\d+\.?\s+(\S*)/) {
                  $type = 'number';
                  $self->{_list_item_contents} = $1 ? 1 : 0;
                  $arg = $1;
                }
                else {
                  $type = 'definition';
                  $self->{_list_item_contents} = 1;
                }
                my $first = $list->type();
                if($first && $first ne $type) {
                    $self->poderror({ -line => $line, -file => $file,
                       -severity => 'WARNING',
                       -msg => "=item type mismatch ('$first' vs. '$type')"});
                }
                else { # first item
                    $list->type($type);
                }
            }
            else {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'No argument for =item' });
                $arg = ' '; # empty
                $self->{_list_item_contents} = 0;
            }
            # add this item
            $list->item($arg);
            # remember this node
            $self->node($arg);
        }
        elsif($cmd eq 'back') {
            # check if we have an open list
            unless(@@{$self->{_list_stack}}) {
                $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => '=back without previous =over' });
            }
            else {
                # check for spurious characters
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                if($arg && $arg =~ /\S/) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => 'Spurious character(s) after =back' });
                }
                # close list
                my $list = $self->_close_list($line,$file);
                # check for empty lists
                if(!$list->item() && $self->{-warnings}) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'WARNING',
                         -msg => 'No items in =over (at line ' .
                         $list->start() . ') / =back list'});
                }
            }
        }
        elsif($cmd =~ /^head(\d+)/) {
            my $hnum = $1;
            $self->{"_have_head_$hnum"}++; # count head types
            if($hnum > 1 && !$self->{'_have_head_'.($hnum -1)}) {
              $self->poderror({ -line => $line, -file => $file,
                   -severity => 'WARNING',
                   -msg => "=head$hnum without preceding higher level"});
            }
            # check whether the previous =head section had some contents
            if(defined $self->{_commands_in_head} &&
              $self->{_commands_in_head} == 0 &&
              defined $self->{_last_head} &&
              $self->{_last_head} >= $hnum) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => 'empty section in previous paragraph'});
            }
            $self->{_commands_in_head} = -1;
            $self->{_last_head} = $hnum;
            # check if there is an open list
            if(@@{$self->{_list_stack}}) {
                my $list;
                while(($list = $self->_close_list($line,$file)) &&
                  $list->indent() ne 'auto') {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => '=over on line '. $list->start() .
                         " without closing =back (at $cmd)" });
                }
            }
            # remember this node
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            $arg =~ s/[\s\n]+$//s;
            $self->node($arg);
            unless(length($arg)) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => "empty =$cmd"});
            }
            if($cmd eq 'head1') {
                $self->{_current_head1} = $arg;
            } else {
                $self->{_current_head1} = '';
            }
        }
        elsif($cmd eq 'begin') {
            if($self->{_have_begin}) {
                # already have a begin
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => q{Nested =begin's (first at line } .
                     $self->{_have_begin} . ')'});
            }
            else {
                # check for argument
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                unless($arg && $arg =~ /(\S+)/) {
                    $self->poderror({ -line => $line, -file => $file,
                         -severity => 'ERROR',
                         -msg => 'No argument for =begin'});
                }
                # remember the =begin
                $self->{_have_begin} = "$line:$1";
            }
        }
        elsif($cmd eq 'end') {
            if($self->{_have_begin}) {
                # close the existing =begin
                $self->{_have_begin} = '';
                # check for spurious characters
                $arg = $self->interpolate_and_check($paragraph, $line,$file);
                # the closing argument is optional
                #if($arg && $arg =~ /\S/) {
                #    $self->poderror({ -line => $line, -file => $file,
                #         -severity => 'WARNING',
                #         -msg => "Spurious character(s) after =end" });
                #}
            }
            else {
                # don't have a matching =begin
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=end without =begin' });
            }
        }
        elsif($cmd eq 'for') {
            unless($paragraph =~ /\s*(\S+)\s*/) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'ERROR',
                     -msg => '=for without formatter specification' });
            }
            $arg = ''; # do not expand paragraph below
        }
        elsif($cmd =~ /^(pod|cut)$/) {
            # check for argument
            $arg = $self->interpolate_and_check($paragraph, $line,$file);
            if($arg && $arg =~ /(\S+)/) {
                $self->poderror({ -line => $line, -file => $file,
                      -severity => 'ERROR',
                      -msg => "Spurious text after =$cmd"});
            }
        }
    $self->{_commands_in_head}++;
    ## Check the interior sequences in the command-text
    $self->interpolate_and_check($paragraph, $line,$file)
        unless(defined $arg);
    }
}

sub _open_list
{
    my ($self,$indent,$line,$file) = @@_;
    my $list = Pod::List->new(
           -indent => $indent,
           -start => $line,
           -file => $file);
    unshift(@@{$self->{_list_stack}}, $list);
    undef $self->{_list_item_contents};
    $list;
}

sub _close_list
{
    my ($self,$line,$file) = @@_;
    my $list = shift(@@{$self->{_list_stack}});
    if(defined $self->{_list_item_contents} &&
      $self->{_list_item_contents} == 0) {
        $self->poderror({ -line => $line, -file => $file,
            -severity => 'WARNING',
            -msg => 'previous =item has no contents' });
    }
    undef $self->{_list_item_contents};
    $list;
}

# process a block of some text
sub interpolate_and_check {
    my ($self, $paragraph, $line, $file) = @@_;
    ## Check the interior sequences in the command-text
    # and return the text
    $self->_check_ptree(
        $self->parse_text($paragraph,$line), $line, $file, '');
}

sub _check_ptree {
    my ($self,$ptree,$line,$file,$nestlist) = @@_;
    local($_);
    my $text = '';
    # process each node in the parse tree
    foreach(@@$ptree) {
        # regular text chunk
        unless(ref) {
            # count the unescaped angle brackets
            # complain only when warning level is greater than 1
            if($self->{-warnings} && $self->{-warnings}>1) {
              my $count;
              if($count = tr/<>/<>/) {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING',
                     -msg => "$count unescaped <> in paragraph" });
                }
            }
            $text .= $_;
            next;
        }
        # have an interior sequence
        my $cmd = $_->cmd_name();
        my $contents = $_->parse_tree();
        ($file,$line) = $_->file_line();
        # check for valid tag
        if (! $VALID_SEQUENCES{$cmd}) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'ERROR',
                 -msg => qq(Unknown interior-sequence '$cmd')});
            # expand it anyway
            $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
            next;
        }
        if($nestlist =~ /$cmd/) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'WARNING',
                 -msg => "nested commands $cmd<...$cmd<...>...>"});
            # _TODO_ should we add the contents anyway?
            # expand it anyway, see below
        }
        if($cmd eq 'E') {
            # preserve entities
            if(@@$contents > 1 || ref $$contents[0] || $$contents[0] !~ /^\w+$/) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'garbled entity ' . $_->raw_text()});
                next;
            }
            my $ent = $$contents[0];
            my $val;
            if($ent =~ /^0x[0-9a-f]+$/i) {
                # hexadec entity
                $val = hex($ent);
            }
            elsif($ent =~ /^0\d+$/) {
                # octal
                $val = oct($ent);
            }
            elsif($ent =~ /^\d+$/) {
                # numeric entity
                $val = $ent;
            }
            if(defined $val) {
                if($val>0 && $val<256) {
                    $text .= chr($val);
                }
                else {
                    $self->poderror({ -line => $line, -file => $file,
                        -severity => 'ERROR',
                        -msg => 'Entity number out of range ' . $_->raw_text()});
                }
            }
            elsif($ENTITIES{$ent}) {
                # known ISO entity
                $text .= $ENTITIES{$ent};
            }
            else {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'WARNING',
                    -msg => 'Unknown entity ' . $_->raw_text()});
                $text .= "E<$ent>";
            }
        }
        elsif($cmd eq 'L') {
            # try to parse the hyperlink
            my $link = Pod::Hyperlink->new($contents->raw_text());
            unless(defined $link) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'malformed link ' . $_->raw_text() ." : $@@"});
                next;
            }
            $link->line($line); # remember line
            if($self->{-warnings}) {
                foreach my $w ($link->warning()) {
                    $self->poderror({ -line => $line, -file => $file,
                        -severity => 'WARNING',
                        -msg => $w });
                }
            }
            # check the link text
            $text .= $self->_check_ptree($self->parse_text($link->text(),
                $line), $line, $file, "$nestlist$cmd");
            # remember link
            $self->hyperlink([$line,$link]);
        }
        elsif($cmd =~ /[BCFIS]/) {
            # add the guts
            $text .= $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
        }
        elsif($cmd eq 'Z') {
            if(length($contents->raw_text())) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'Nonempty Z<>'});
            }
        }
        elsif($cmd eq 'X') {
            my $idx = $self->_check_ptree($contents, $line, $file, "$nestlist$cmd");
            if($idx =~ /^\s*$/s) {
                $self->poderror({ -line => $line, -file => $file,
                    -severity => 'ERROR',
                    -msg => 'Empty X<>'});
            }
            else {
                # remember this node
                $self->idx($idx);
            }
        }
        else {
            # not reached
            croak 'internal error';
        }
    }
    $text;
}

# process a block of verbatim text
sub verbatim {
    ## Nothing particular to check
    my ($self, $paragraph, $line_num, $pod_para) = @@_;

    $self->_preproc_par($paragraph);

    if($self->{_current_head1} eq 'NAME') {
        my ($file, $line) = $pod_para->file_line;
        $self->poderror({ -line => $line, -file => $file,
            -severity => 'WARNING',
            -msg => 'Verbatim paragraph in NAME section' });
    }
}

# process a block of regular text
sub textblock {
    my ($self, $paragraph, $line_num, $pod_para) = @@_;
    my ($file, $line) = $pod_para->file_line;

    $self->_preproc_par($paragraph);

    # skip this paragraph if in a =begin block
    unless($self->{_have_begin}) {
        my $block = $self->interpolate_and_check($paragraph, $line,$file);
        if($self->{_current_head1} eq 'NAME') {
            if($block =~ /^\s*(\S+?)\s*[,-]/) {
                # this is the canonical name
                $self->{-name} = $1 unless(defined $self->{-name});
            }
        }
    }
}

sub _preproc_par
{
    my $self = shift;
    $_[0] =~ s/[\s\n]+$//;
    if($_[0]) {
        $self->{_commands_in_head}++;
        $self->{_list_item_contents}++ if(defined $self->{_list_item_contents});
        if(@@{$self->{_list_stack}} && !$self->{_list_stack}->[0]->item()) {
            $self->{_list_stack}->[0]->{_has_par} = 1;
        }
    }
}

1;

__END__

=head1 AUTHOR

Please report bugs using L<http://rt.cpan.org>.

Brad Appleton E<lt>bradapp@@enteract.comE<gt> (initial version),
Marek Rouchal E<lt>marekr@@cpan.orgE<gt>

Based on code for B<Pod::Text::pod2text()> written by
Tom Christiansen E<lt>tchrist@@mox.perl.comE<gt>

=cut

@


1.4
log
@Merge in some local changes that got lost.
@
text
@@


1.3
log
@Merge in perl 5.10.1
@
text
@d21 1
a21 1
Pod::Checker, podchecker() - check pod documents for syntax errors
@


1.2
log
@Remove a couple more bogus man pages and add missing MLINKs.  The
makewhatis info for the perl man pages now matches the pages themselves.
@
text
@d11 1
d13 2
a14 2
use vars qw($VERSION);
$VERSION = "1.43_01";  ## Current version of this package
d21 1
a21 1
Pod::Checker, podchecker - check pod documents for syntax errors
d81 1
a81 1
Check for same nested interior-sequences (e.g. 
d158 2
a159 2
C<BE<lt>E<gt>>, C<CE<lt>E<gt>>, C<EE<lt>E<gt>>, C<FE<lt>E<gt>>, 
C<IE<lt>E<gt>>, C<LE<lt>E<gt>>, C<SE<lt>E<gt>>, C<XE<lt>E<gt>>, 
d268 1
a268 1
any text. This usually indicates that something is missing. Note: A 
d292 1
a292 1
There is whitespace at the beginning or the end of the contents of 
d333 1
a333 1
method to print errors and warnings. The summary output (e.g. 
a342 1
use strict;
d344 1
a344 1
use Carp;
a347 1
use vars qw(@@ISA @@EXPORT);
a350 2
use vars qw(%VALID_COMMANDS %VALID_SEQUENCES);

d364 1
a364 1
    'encoding' => '1',
d382 1
a382 1
 amp    => '&',  # ampersand 
d388 62
a449 62
 AElig	=> 'Æ',  # capital AE diphthong (ligature)
 Aacute	=> 'Á',  # capital A, acute accent
 Acirc	=> 'Â',  # capital A, circumflex accent
 Agrave	=> 'À',  # capital A, grave accent
 Aring	=> 'Å',  # capital A, ring
 Atilde	=> 'Ã',  # capital A, tilde
 Auml	=> 'Ä',  # capital A, dieresis or umlaut mark
 Ccedil	=> 'Ç',  # capital C, cedilla
 ETH	=> 'Ð',  # capital Eth, Icelandic
 Eacute	=> 'É',  # capital E, acute accent
 Ecirc	=> 'Ê',  # capital E, circumflex accent
 Egrave	=> 'È',  # capital E, grave accent
 Euml	=> 'Ë',  # capital E, dieresis or umlaut mark
 Iacute	=> 'Í',  # capital I, acute accent
 Icirc	=> 'Î',  # capital I, circumflex accent
 Igrave	=> 'Ì',  # capital I, grave accent
 Iuml	=> 'Ï',  # capital I, dieresis or umlaut mark
 Ntilde	=> 'Ñ',  # capital N, tilde
 Oacute	=> 'Ó',  # capital O, acute accent
 Ocirc	=> 'Ô',  # capital O, circumflex accent
 Ograve	=> 'Ò',  # capital O, grave accent
 Oslash	=> 'Ø',  # capital O, slash
 Otilde	=> 'Õ',  # capital O, tilde
 Ouml	=> 'Ö',  # capital O, dieresis or umlaut mark
 THORN	=> 'Þ',  # capital THORN, Icelandic
 Uacute	=> 'Ú',  # capital U, acute accent
 Ucirc	=> 'Û',  # capital U, circumflex accent
 Ugrave	=> 'Ù',  # capital U, grave accent
 Uuml	=> 'Ü',  # capital U, dieresis or umlaut mark
 Yacute	=> 'Ý',  # capital Y, acute accent
 aacute	=> 'á',  # small a, acute accent
 acirc	=> 'â',  # small a, circumflex accent
 aelig	=> 'æ',  # small ae diphthong (ligature)
 agrave	=> 'à',  # small a, grave accent
 aring	=> 'å',  # small a, ring
 atilde	=> 'ã',  # small a, tilde
 auml	=> 'ä',  # small a, dieresis or umlaut mark
 ccedil	=> 'ç',  # small c, cedilla
 eacute	=> 'é',  # small e, acute accent
 ecirc	=> 'ê',  # small e, circumflex accent
 egrave	=> 'è',  # small e, grave accent
 eth	=> 'ð',  # small eth, Icelandic
 euml	=> 'ë',  # small e, dieresis or umlaut mark
 iacute	=> 'í',  # small i, acute accent
 icirc	=> 'î',  # small i, circumflex accent
 igrave	=> 'ì',  # small i, grave accent
 iuml	=> 'ï',  # small i, dieresis or umlaut mark
 ntilde	=> 'ñ',  # small n, tilde
 oacute	=> 'ó',  # small o, acute accent
 ocirc	=> 'ô',  # small o, circumflex accent
 ograve	=> 'ò',  # small o, grave accent
 oslash	=> 'ø',  # small o, slash
 otilde	=> 'õ',  # small o, tilde
 ouml	=> 'ö',  # small o, dieresis or umlaut mark
 szlig	=> 'ß',  # small sharp s, German (sz ligature)
 thorn	=> 'þ',  # small thorn, Icelandic
 uacute	=> 'ú',  # small u, acute accent
 ucirc	=> 'û',  # small u, circumflex accent
 ugrave	=> 'ù',  # small u, grave accent
 uuml	=> 'ü',  # small u, dieresis or umlaut mark
 yacute	=> 'ý',  # small y, acute accent
 yuml	=> 'ÿ',  # small y, dieresis or umlaut mark
d500 1
a500 1
sub podchecker( $ ; $ % ) {
d610 3
a612 3
    chomp( my $msg  = ($opts{-msg} || "")."@@_" );
    my $line = (exists $opts{-line}) ? " at line $opts{-line}" : "";
    my $file = (exists $opts{-file}) ? " in file $opts{-file}" : "";
d617 1
a617 1
    my $severity = (exists $opts{-severity}) ? "*** $opts{-severity}: " : "";
d620 1
a620 1
    ++($self->{_NUM_ERRORS}) 
d666 1
a666 1
        ($_[0]->{-name} = $_[1]) : $_[0]->{-name};  
d754 2
a755 2
                -severity => 'ERROR', -msg => "=over on line " .
                $list->start() . " without closing =back" }); #"
d804 1
a804 1
sub command { 
d819 1
a819 1
        #         -severity => 'WARNING', 
d838 2
a839 2
                     -severity => 'ERROR', 
                     -msg => "=item without previous =over" });
d848 2
a849 2
                     -severity => 'WARNING', 
                     -msg => "previous =item has no contents" });
d853 2
a854 2
                     -severity => 'WARNING', 
                     -msg => "preceding non-item paragraph(s)" });
d867 1
a867 1
                elsif($arg =~ /^\d+\.?\s*(\S*)/) {
d879 1
a879 1
                       -severity => 'WARNING', 
d888 3
a890 3
                     -severity => 'WARNING', 
                     -msg => "No argument for =item" });
		$arg = ' '; # empty
d902 2
a903 2
                         -severity => 'ERROR', 
                         -msg => "=back without previous =over" });
d910 2
a911 2
                         -severity => 'ERROR', 
                         -msg => "Spurious character(s) after =back" });
d918 3
a920 3
                         -severity => 'WARNING', 
                         -msg => "No items in =over (at line " .
                         $list->start() . ") / =back list"}); #"
d927 1
a927 1
            if($hnum > 1 && !$self->{"_have_head_".($hnum -1)}) {
d929 1
a929 1
                   -severity => 'WARNING', 
d938 2
a939 2
                     -severity => 'WARNING', 
                     -msg => "empty section in previous paragraph"});
d949 2
a950 2
                         -severity => 'ERROR', 
                         -msg => "=over on line ". $list->start() .
d960 1
a960 1
                     -severity => 'ERROR', 
d973 3
a975 3
                     -severity => 'ERROR', 
                     -msg => "Nested =begin's (first at line " .
                     $self->{_have_begin} . ")"});
d982 2
a983 2
                         -severity => 'ERROR', 
                         -msg => "No argument for =begin"});
d998 1
a998 1
                #         -severity => 'WARNING', 
d1005 2
a1006 2
                     -severity => 'ERROR', 
                     -msg => "=end without =begin" });
d1012 2
a1013 2
                     -severity => 'ERROR', 
                     -msg => "=for without formatter specification" });
d1022 1
a1022 1
                      -severity => 'ERROR', 
d1052 2
a1053 2
            -severity => 'WARNING', 
            -msg => "previous =item has no contents" });
d1082 1
a1082 1
                     -severity => 'WARNING', 
d1096 1
a1096 1
                 -severity => 'ERROR', 
d1104 1
a1104 1
                 -severity => 'WARNING', 
d1113 2
a1114 2
                    -severity => 'ERROR', 
                    -msg => "garbled entity " . $_->raw_text()});
d1137 2
a1138 2
                        -severity => 'ERROR', 
                        -msg => "Entity number out of range " . $_->raw_text()});
d1147 2
a1148 2
                    -severity => 'WARNING', 
                    -msg => "Unknown entity " . $_->raw_text()});
d1157 2
a1158 2
                    -severity => 'ERROR', 
                    -msg => "malformed link " . $_->raw_text() ." : $@@"});
d1165 1
a1165 1
                        -severity => 'WARNING', 
d1182 2
a1183 2
                    -severity => 'ERROR', 
                    -msg => "Nonempty Z<>"});
d1190 2
a1191 2
                    -severity => 'ERROR', 
                    -msg => "Empty X<>"});
d1200 1
a1200 1
            die "internal error";
d1207 1
a1207 1
sub verbatim { 
d1222 1
a1222 1
sub textblock { 
@


1.1
log
@Initial revision
@
text
@d13 1
a13 1
$VERSION = 1.098;  ## Current version of this package
d20 1
a20 1
Pod::Checker, podchecker() - check pod documents for syntax errors
d47 2
a48 1
Turn warnings on/off. See L<"Warnings">.
d56 3
a58 1
I<NOTE THAT THIS MODULE IS CURRENTLY IN THE BETA STAGE!>
d60 1
a60 5
It is hoped that curious/ambitious user will help flesh out and add the
additional features they wish to see in B<Pod::Checker> and B<podchecker>
and verify that the checks are consistent with L<perlpod>.

The following checks are currently preformed:
d85 1
a85 1
Check for malformed or nonexisting entities C<EE<lt>...E<gt>>.
d145 1
a145 1
POD. This also happend when a single word node name is not enclosed in
d151 2
a152 2
C<=over>, C<=item>, C<=back>, C<=begin>, C<=end>, C<=for>, C<=pod>,
C<=cut>
d203 1
a203 1
=item * multiple occurence of link target I<name>
d207 1
d215 2
d222 1
a222 4
=item * No numeric argument for =over

The C<=over> command is supposed to have a numeric argument (the
indentation).
d237 1
a237 1
A list started with e.g. a bulletted C<=item> and continued with a
d245 2
a246 1
markup commands.
d276 1
a276 1
=item * Hyperlinks
d278 33
a310 3
There are some warnings wrt. hyperlinks:
Leading/trailing whitespace, newlines in hyperlinks,
brackets C<()>.
d321 1
a321 1
I<[T.B.D.]>
d331 7
a346 1
require VMS::Filespec if $^O eq 'VMS';
d359 2
d367 1
a512 1
    $checker->parseopts(-process_cut_cmd => 1, -warnings => 1);
d527 21
d563 4
a566 1
    $self->errorsub('poderror'); # set the error handling subroutine
d576 1
a580 2
=over 4

a610 1
    $opts{-file} = VMS::Filespec::unixify($opts{-file}) if (exists($opts{-file}) && $^O eq 'VMS');
d625 7
a631 3
    my $out_fh = $self->output_handle();
    print $out_fh ($severity, $msg, $line, $file, "\n")
      if($self->{-warnings} || !%opts || $opts{-severity} ne 'WARNING');
d648 12
d678 1
a678 1
their occurence. They consist of plain text, each piece of whitespace is
d727 1
a727 1
C<LE<lt>E<gt>>) of the current POD. They consist of an 2-item array: line
a750 2
    $infile = VMS::Filespec::unixify($infile) if $^O eq 'VMS';
    my $out_fh = $self->output_handle();
a752 1
        # _TODO_ display, but don't count them for now
d767 1
a767 1
        if(/^(\S+)\s+/) {
d773 3
d793 4
a796 3
    foreach(grep($self->{_unique_nodes}->{$_} > 1,
      keys %{$self->{_unique_nodes}})) {
        $self->poderror({ -line => '-', -file => $infile,
d798 2
a799 1
            -msg => "multiple occurence of link target '$_'"});
d802 2
a803 13
    ## Print the number of errors found
    my $num_errors = $self->num_errors();
    if ($num_errors > 0) {
        printf $out_fh ("$infile has $num_errors pod syntax %s.\n",
                      ($num_errors == 1) ? "error" : "errors");
    }
    elsif($self->{_commands} == 0) {
        print $out_fh "$infile does not contain any pod commands.\n";
        $self->num_errors(-1);
    }
    else {
        print $out_fh "$infile pod syntax OK.\n";
    }
d816 11
a826 8
    else {
        # found a valid command
        if(!$self->{_commands}++ && $cmd !~ /^head/) {
            $self->poderror({ -line => $line, -file => $file,
                 -severity => 'WARNING', 
                 -msg => "file does not start with =head" });
        }
        ## check syntax of particular command
a832 4
            } else {
                $self->poderror({ -line => $line, -file => $file,
                     -severity => 'WARNING', 
                     -msg => "No numeric argument for =over"});
d928 7
d939 1
a939 1
              $self->{_last_head} >= $1) {
d945 1
a945 1
            $self->{_last_head} = $1;
a1078 1
            my $count;
d1080 4
a1083 2
            my $i = $_;
            if($count = $i =~ tr/<>/<>/) {
d1086 2
a1087 2
                     -msg => "$count unescaped <> in paragraph" })
                if($self->{-warnings});
d1089 1
a1089 1
            $text .= $i;
d1107 1
a1107 1
                 -severity => 'ERROR', 
d1262 2
d1265 1
a1265 1
Marek Rouchal E<lt>marek@@saftsack.fs.uni-bayreuth.deE<gt>
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d13 1
a13 1
$VERSION = 1.2;  ## Current version of this package
d47 1
a47 2
Turn warnings on/off. I<val> is usually 1 for on, but higher values
trigger additional warnings. See L<"Warnings">.
a214 2
=begin _disabled_

d220 4
a223 1
=end _disabled_
d246 1
a246 2
markup commands. This is only printed when the -warnings level is
greater than 1.
d276 1
a276 9
=back

=head2 Hyperlinks

There are some warnings wrt. malformed hyperlinks.

=over 4

=item * ignoring leading/trailing whitespace in link
d278 3
a280 20
There is whitespace at the beginning or the end of the contents of 
LE<lt>...E<gt>.

=item * (section) in '$page' deprecated

There is a section detected in the page name of LE<lt>...E<gt>, e.g.
C<LE<gt>passwd(2)E<gt>>. POD hyperlinks may point to POD documents only.
Please write C<CE<lt>passwd(2)E<gt>> instead. Some formatters are able
to expand this to appropriate code. For links to (builtin) functions,
please say C<LE<lt>perlfunc/mkdirE<gt>>, without ().

=item * alternative text/node '%s' contains non-escaped | or /

The characters C<|> and C</> are special in the LE<lt>...E<gt> context.
Although the hyperlink parser does its best to determine which "/" is
text and which is a delimiter in case of doubt, one ought to escape
these literal characters like this:

  /     E<sol>
  |     E<verbar>
d310 1
d474 1
a488 21
##################################

=over 4

=item C<Pod::Checker-E<gt>new( %options )>

Return a reference to a new Pod::Checker object that inherits from
Pod::Parser and is used for calling the required methods later. The
following options are recognized:

C<-warnings =E<gt> num>
  Print warnings if C<num> is true. The higher the value of C<num>,
the more warnings are printed. Currently there are only levels 1 and 2.

C<-quiet =E<gt> num>
  If C<num> is true, do not print any errors/warnings. This is useful
when Pod::Checker is used to munge POD code into plain text from within
POD formatters.

=cut

d504 1
a504 3
    $self->{-quiet} ||= 0;
    # set the error handling subroutine
    $self->errorsub($self->{-quiet} ? sub { 1; } : 'poderror');
a513 1
    $self->parseopts(-process_cut_cmd => 1, -warnings => $self->{-warnings});
d518 2
d550 1
d565 1
a565 1
    my $out_fh = $self->output_handle() || \*STDERR;
d675 1
d694 1
a694 1
        if(/^(\S+)\s+\S/) {
a699 3
    foreach($self->idx()) {
        $nodes{$_} = 3; # index node
    }
d749 8
a756 11
    else { # found a valid command
        $self->{_commands}++; # delete this line if below is enabled again

        ##### following check disabled due to strong request
        #if(!$self->{_commands}++ && $cmd !~ /^head/) {
        #    $self->poderror({ -line => $line, -file => $file,
        #         -severity => 'WARNING', 
        #         -msg => "file does not start with =head" });
        #}

        # check syntax of particular command
d763 4
a1007 1
            # complain only when warning level is greater than 1
d1013 1
a1013 1
                if($self->{-warnings} && $self->{-warnings}>1);
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d13 1
a13 1
$VERSION = 1.3;  ## Current version of this package
d153 2
a154 2
C<=head3>, C<=head4>, C<=over>, C<=item>, C<=back>, C<=begin>, C<=end>,
C<=for>, C<=pod>, C<=cut>
d205 1
a205 1
=item * multiple occurrence of link target I<name>
d293 1
a293 1
C<LE<lt>passwd(2)E<gt>>. POD hyperlinks may point to POD documents only.
a347 2
    'head3'  =>  1,
    'head4'  =>  1,
d647 1
a647 1
their occurrence. They consist of plain text, each piece of whitespace is
d696 1
a696 1
C<LE<lt>E<gt>>) of the current POD. They consist of a 2-item array: line
d768 1
a768 1
            -msg => "multiple occurrence of link target '$_'"});
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d13 1
a13 1
$VERSION = 1.41;  ## Current version of this package
d56 5
a60 3
Curious/ambitious users are welcome to propose additional features they wish
to see in B<Pod::Checker> and B<podchecker> and verify that the checks are
consistent with L<perlpod>.
a276 5
=item * =headI<n> without preceding higher level

For example if there is a C<=head2> in the POD file prior to a
C<=head1>.

d317 1
a317 1
See L</SYNOPSIS>
a326 7
Since PodParser-1.24 the B<Pod::Checker> module uses only the B<poderror>
method to print errors and warnings. The summary output (e.g. 
"Pod syntax OK") has been dropped from the module and has been included in
B<podchecker> (the script). This allows users of B<Pod::Checker> to
control completely the output behaviour. Users of B<podchecker> (the script)
get the well-known behaviour.

a550 1
    $self->{_NUM_WARNINGS} = 0;
a611 2
    ++($self->{_NUM_WARNINGS})
        if(!%opts || ($opts{-severity} && $opts{-severity} eq 'WARNING'));
a630 12
=item C<$checker-E<gt>num_warnings()>

Set (if argument specified) and retrieve the number of warnings found.

=cut

sub num_warnings {
   return (@@_ > 1) ? ($_[0]->{_NUM_WARNINGS} = $_[1]) : $_[0]->{_NUM_WARNINGS};
}

##################################

d725 1
d773 13
a785 2
    # no POD found here
    $self->num_errors(-1) if($self->{_commands} == 0);
a909 7
            my $hnum = $1;
            $self->{"_have_head_$hnum"}++; # count head types
            if($hnum > 1 && !$self->{"_have_head_".($hnum -1)}) {
              $self->poderror({ -line => $line, -file => $file,
                   -severity => 'WARNING', 
                   -msg => "=head$hnum without preceding higher level"});
            }
d914 1
a914 1
              $self->{_last_head} >= $hnum) {
d920 1
a920 1
            $self->{_last_head} = $hnum;
d1054 1
d1057 2
a1058 3
            if($self->{-warnings} && $self->{-warnings}>1) {
              my $count;
              if($count = tr/<>/<>/) {
d1061 2
a1062 2
                     -msg => "$count unescaped <> in paragraph" });
                }
d1064 1
a1064 1
            $text .= $_;
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@a1256 2
Please report bugs using L<http://rt.cpan.org>.

d1258 1
a1258 1
Marek Rouchal E<lt>marekr@@cpan.orgE<gt>
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d13 1
a13 1
$VERSION = 1.42;  ## Current version of this package
d747 1
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d13 1
a13 1
$VERSION = 1.43;  ## Current version of this package
d60 1
a60 1
The following checks are currently performed:
a206 1
This warning is printed only with warning level greater than one.
d625 3
a627 5
    unless($self->{-quiet}) {
      my $out_fh = $self->output_handle() || \*STDERR;
      print $out_fh ($severity, $msg, $line, $file, "\n")
        if($self->{-warnings} || !%opts || $opts{-severity} ne 'WARNING');
    }
d789 3
a791 4
    if($self->{-warnings} && $self->{-warnings}>1) {
      foreach(grep($self->{_unique_nodes}->{$_} > 1,
        keys %{$self->{_unique_nodes}})) {
          $self->poderror({ -line => '-', -file => $infile,
a793 1
      }
d1101 1
a1101 1
                 -severity => 'WARNING', 
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d13 1
a13 1
$VERSION = "1.43_01";  ## Current version of this package
d85 1
a85 1
Check for malformed or non-existing entities C<EE<lt>...E<gt>>.
d145 1
a145 1
POD. This also happened when a single word node name is not enclosed in
d237 1
a237 1
A list started with e.g. a bullet-like C<=item> and continued with a
d285 1
a285 1
There are some warnings with respect to malformed hyperlinks:
d335 2
a336 2
control completely the output behavior. Users of B<podchecker> (the script)
get the well-known behavior.
a366 1
    'encoding' => '1',
@


1.1.1.9
log
@import perl 5.10.1
@
text
@a10 1
use strict;
d12 2
a13 2
use vars qw($VERSION @@ISA @@EXPORT %VALID_COMMANDS %VALID_SEQUENCES);
$VERSION = '1.45';  ## Current version of this package
d80 1
a80 1
Check for same nested interior-sequences (e.g.
d157 2
a158 2
C<BE<lt>E<gt>>, C<CE<lt>E<gt>>, C<EE<lt>E<gt>>, C<FE<lt>E<gt>>,
C<IE<lt>E<gt>>, C<LE<lt>E<gt>>, C<SE<lt>E<gt>>, C<XE<lt>E<gt>>,
d267 1
a267 1
any text. This usually indicates that something is missing. Note: A
d291 1
a291 1
There is whitespace at the beginning or the end of the contents of
d332 1
a332 1
method to print errors and warnings. The summary output (e.g.
d342 1
d344 1
a344 1
use Carp qw(croak);
d348 1
d352 2
d367 1
a367 1
    'encoding' =>  1,
d385 1
a385 1
 amp    => '&',  # ampersand
d391 62
a452 62
 AElig  => 'Æ',  # capital AE diphthong (ligature)
 Aacute => 'Á',  # capital A, acute accent
 Acirc  => 'Â',  # capital A, circumflex accent
 Agrave => 'À',  # capital A, grave accent
 Aring  => 'Å',  # capital A, ring
 Atilde => 'Ã',  # capital A, tilde
 Auml   => 'Ä',  # capital A, dieresis or umlaut mark
 Ccedil => 'Ç',  # capital C, cedilla
 ETH    => 'Ð',  # capital Eth, Icelandic
 Eacute => 'É',  # capital E, acute accent
 Ecirc  => 'Ê',  # capital E, circumflex accent
 Egrave => 'È',  # capital E, grave accent
 Euml   => 'Ë',  # capital E, dieresis or umlaut mark
 Iacute => 'Í',  # capital I, acute accent
 Icirc  => 'Î',  # capital I, circumflex accent
 Igrave => 'Ì',  # capital I, grave accent
 Iuml   => 'Ï',  # capital I, dieresis or umlaut mark
 Ntilde => 'Ñ',  # capital N, tilde
 Oacute => 'Ó',  # capital O, acute accent
 Ocirc  => 'Ô',  # capital O, circumflex accent
 Ograve => 'Ò',  # capital O, grave accent
 Oslash => 'Ø',  # capital O, slash
 Otilde => 'Õ',  # capital O, tilde
 Ouml   => 'Ö',  # capital O, dieresis or umlaut mark
 THORN  => 'Þ',  # capital THORN, Icelandic
 Uacute => 'Ú',  # capital U, acute accent
 Ucirc  => 'Û',  # capital U, circumflex accent
 Ugrave => 'Ù',  # capital U, grave accent
 Uuml   => 'Ü',  # capital U, dieresis or umlaut mark
 Yacute => 'Ý',  # capital Y, acute accent
 aacute => 'á',  # small a, acute accent
 acirc  => 'â',  # small a, circumflex accent
 aelig  => 'æ',  # small ae diphthong (ligature)
 agrave => 'à',  # small a, grave accent
 aring  => 'å',  # small a, ring
 atilde => 'ã',  # small a, tilde
 auml   => 'ä',  # small a, dieresis or umlaut mark
 ccedil => 'ç',  # small c, cedilla
 eacute => 'é',  # small e, acute accent
 ecirc  => 'ê',  # small e, circumflex accent
 egrave => 'è',  # small e, grave accent
 eth    => 'ð',  # small eth, Icelandic
 euml   => 'ë',  # small e, dieresis or umlaut mark
 iacute => 'í',  # small i, acute accent
 icirc  => 'î',  # small i, circumflex accent
 igrave => 'ì',  # small i, grave accent
 iuml   => 'ï',  # small i, dieresis or umlaut mark
 ntilde => 'ñ',  # small n, tilde
 oacute => 'ó',  # small o, acute accent
 ocirc  => 'ô',  # small o, circumflex accent
 ograve => 'ò',  # small o, grave accent
 oslash => 'ø',  # small o, slash
 otilde => 'õ',  # small o, tilde
 ouml   => 'ö',  # small o, dieresis or umlaut mark
 szlig  => 'ß',  # small sharp s, German (sz ligature)
 thorn  => 'þ',  # small thorn, Icelandic
 uacute => 'ú',  # small u, acute accent
 ucirc  => 'û',  # small u, circumflex accent
 ugrave => 'ù',  # small u, grave accent
 uuml   => 'ü',  # small u, dieresis or umlaut mark
 yacute => 'ý',  # small y, acute accent
 yuml   => 'ÿ',  # small y, dieresis or umlaut mark
d503 1
a503 1
sub podchecker {
d613 3
a615 3
    chomp( my $msg  = ($opts{-msg} || '')."@@_" );
    my $line = (exists $opts{-line}) ? " at line $opts{-line}" : '';
    my $file = (exists $opts{-file}) ? " in file $opts{-file}" : '';
d620 1
a620 1
    my $severity = (exists $opts{-severity}) ? "*** $opts{-severity}: " : '';
d623 1
a623 1
    ++($self->{_NUM_ERRORS})
d669 1
a669 1
        ($_[0]->{-name} = $_[1]) : $_[0]->{-name};
d757 2
a758 2
                -severity => 'ERROR', -msg => '=over on line ' .
                $list->start() . ' without closing =back' });
d807 1
a807 1
sub command {
d822 1
a822 1
        #         -severity => 'WARNING',
d841 2
a842 2
                     -severity => 'ERROR',
                     -msg => '=item without previous =over' });
d851 2
a852 2
                     -severity => 'WARNING',
                     -msg => 'previous =item has no contents' });
d856 2
a857 2
                     -severity => 'WARNING',
                     -msg => 'preceding non-item paragraph(s)' });
d870 1
a870 1
                elsif($arg =~ /^\d+\.?\s+(\S*)/) {
d882 1
a882 1
                       -severity => 'WARNING',
d891 3
a893 3
                     -severity => 'WARNING',
                     -msg => 'No argument for =item' });
                $arg = ' '; # empty
d905 2
a906 2
                         -severity => 'ERROR',
                         -msg => '=back without previous =over' });
d913 2
a914 2
                         -severity => 'ERROR',
                         -msg => 'Spurious character(s) after =back' });
d921 3
a923 3
                         -severity => 'WARNING',
                         -msg => 'No items in =over (at line ' .
                         $list->start() . ') / =back list'});
d930 1
a930 1
            if($hnum > 1 && !$self->{'_have_head_'.($hnum -1)}) {
d932 1
a932 1
                   -severity => 'WARNING',
d941 2
a942 2
                     -severity => 'WARNING',
                     -msg => 'empty section in previous paragraph'});
d952 2
a953 2
                         -severity => 'ERROR',
                         -msg => '=over on line '. $list->start() .
d963 1
a963 1
                     -severity => 'ERROR',
d976 3
a978 3
                     -severity => 'ERROR',
                     -msg => q{Nested =begin's (first at line } .
                     $self->{_have_begin} . ')'});
d985 2
a986 2
                         -severity => 'ERROR',
                         -msg => 'No argument for =begin'});
d1001 1
a1001 1
                #         -severity => 'WARNING',
d1008 2
a1009 2
                     -severity => 'ERROR',
                     -msg => '=end without =begin' });
d1015 2
a1016 2
                     -severity => 'ERROR',
                     -msg => '=for without formatter specification' });
d1025 1
a1025 1
                      -severity => 'ERROR',
d1055 2
a1056 2
            -severity => 'WARNING',
            -msg => 'previous =item has no contents' });
d1085 1
a1085 1
                     -severity => 'WARNING',
d1099 1
a1099 1
                 -severity => 'ERROR',
d1107 1
a1107 1
                 -severity => 'WARNING',
d1116 2
a1117 2
                    -severity => 'ERROR',
                    -msg => 'garbled entity ' . $_->raw_text()});
d1140 2
a1141 2
                        -severity => 'ERROR',
                        -msg => 'Entity number out of range ' . $_->raw_text()});
d1150 2
a1151 2
                    -severity => 'WARNING',
                    -msg => 'Unknown entity ' . $_->raw_text()});
d1160 2
a1161 2
                    -severity => 'ERROR',
                    -msg => 'malformed link ' . $_->raw_text() ." : $@@"});
d1168 1
a1168 1
                        -severity => 'WARNING',
d1185 2
a1186 2
                    -severity => 'ERROR',
                    -msg => 'Nonempty Z<>'});
d1193 2
a1194 2
                    -severity => 'ERROR',
                    -msg => 'Empty X<>'});
d1203 1
a1203 1
            croak 'internal error';
d1210 1
a1210 1
sub verbatim {
d1225 1
a1225 1
sub textblock {
@


