head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.5.0.18
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.14
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.55;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.24;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.47.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.49.02;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Unicode::Collate;

BEGIN {
    if (ord("A") == 193) {
	die "Unicode::Collate not ported to EBCDIC\n";
    }
}

use 5.006;
use strict;
use warnings;
use Carp;
use File::Spec;

require Exporter;

our $VERSION = '0.12';
our $PACKAGE = __PACKAGE__;

our @@ISA = qw(Exporter);

our %EXPORT_TAGS = ();
our @@EXPORT_OK = ();
our @@EXPORT = ();

(our $Path = $INC{'Unicode/Collate.pm'}) =~ s/\.pm$//;
our $KeyFile = "allkeys.txt";

our $UNICODE_VERSION;

eval { require Unicode::UCD };

unless ($@@) {
    $UNICODE_VERSION = Unicode::UCD::UnicodeVersion();
}
else { # XXX, Perl 5.6.1
    my($f, $fh);
    foreach my $d (@@INC) {
	use File::Spec;
	$f = File::Spec->catfile($d, "unicode", "Unicode.301");
	if (open($fh, $f)) {
	    $UNICODE_VERSION = '3.0.1';
	    close $fh;
	    last;
	}
    }
}

our $getCombinClass; # coderef for combining class from Unicode::Normalize

use constant Min2      => 0x20;   # minimum weight at level 2
use constant Min3      => 0x02;   # minimum weight at level 3
use constant UNDEFINED => 0xFF80; # special value for undefined CE's

our $DefaultRearrange = [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ];

sub UCA_Version { "8.0" }

sub Base_Unicode_Version { $UNICODE_VERSION || 'unknown' }

##
## constructor
##
sub new
{
    my $class = shift;
    my $self = bless { @@_ }, $class;

    # alternate lowercased
    $self->{alternate} =
	! exists $self->{alternate} ? 'shifted' : lc($self->{alternate});

    croak "$PACKAGE unknown alternate tag name: $self->{alternate}"
	unless $self->{alternate} eq 'blanked'
	    || $self->{alternate} eq 'non-ignorable'
	    || $self->{alternate} eq 'shifted'
	    || $self->{alternate} eq 'shift-trimmed';

    # collation level
    $self->{level} ||= 4;

    croak "Illegal level lower than 1 (passed $self->{level})."
	if $self->{level} < 1;
    croak "A level higher than 4 (passed $self->{level}) is not supported."
	if 4 < $self->{level};

    # overrideHangul and -CJK
    # If true: CODEREF used; '': default; undef: derived elements
    $self->{overrideHangul} = ''
	if ! exists $self->{overrideHangul};
    $self->{overrideCJK} = ''
	if ! exists $self->{overrideCJK};

    # normalization form
    $self->{normalization} = 'D'
	if ! exists $self->{normalization};
    $self->{UNF} = undef;

    if (defined $self->{normalization}) {
	eval { require Unicode::Normalize };
	croak "Unicode/Normalize.pm is required to normalize strings: $@@"
	    if $@@;

	Unicode::Normalize->import();
	$getCombinClass = \&Unicode::Normalize::getCombinClass
	    if ! $getCombinClass;

	$self->{UNF} =
	    $self->{normalization} =~ /^(?:NF)?C$/  ? \&NFC :
	    $self->{normalization} =~ /^(?:NF)?D$/  ? \&NFD :
	    $self->{normalization} =~ /^(?:NF)?KC$/ ? \&NFKC :
	    $self->{normalization} =~ /^(?:NF)?KD$/ ? \&NFKD :
	  croak "$PACKAGE unknown normalization form name: "
		. $self->{normalization};
    }

    # Open a table file.
    # If undef is passed explicitly, no file is read.
    $self->{table} = $KeyFile
	if ! exists $self->{table};
    $self->read_table
	if defined $self->{table};

    if ($self->{entry}) {
	$self->parseEntry($_) foreach split /\n/, $self->{entry};
    }

    # backwards
    $self->{backwards} ||= [ ];
    $self->{backwards} = [ $self->{backwards} ]
	if ! ref $self->{backwards};

    # rearrange
    $self->{rearrange} = $DefaultRearrange
	if ! exists $self->{rearrange};
    $self->{rearrange} = []
	if ! defined $self->{rearrange};
    croak "$PACKAGE: A list for rearrangement must be store in an ARRAYREF"
	if ! ref $self->{rearrange};

    # keys of $self->{rearrangeHash} are $self->{rearrange}.
    $self->{rearrangeHash} = undef;

    if (@@{ $self->{rearrange} }) {
	@@{ $self->{rearrangeHash} }{ @@{ $self->{rearrange} } } = ();
    }

    return $self;
}

sub read_table {
    my $self = shift;
    my $file = $self->{table} ne '' ? $self->{table} : $KeyFile;

    my $filepath = File::Spec->catfile($Path, $file);
    open my $fk, "<$filepath"
	or croak "File does not exist at $filepath";

    while (<$fk>) {
	next if /^\s*#/;
	if (/^\s*\@@/) {
	    if (/^\@@version\s*(\S*)/) {
		$self->{version} ||= $1;
	    }
	    elsif (/^\@@alternate\s+(.*)/) {
		$self->{alternate} ||= $1;
	    }
	    elsif (/^\@@backwards\s+(.*)/) {
		push @@{ $self->{backwards} }, $1;
	    }
	    elsif (/^\@@rearrange\s+(.*)/) {
		push @@{ $self->{rearrange} }, _getHexArray($1);
	    }
	    next;
	}
	$self->parseEntry($_);
    }
    close $fk;
}


##
## get $line, parse it, and write an entry in $self
##
sub parseEntry
{
    my $self = shift;
    my $line = shift;
    my($name, $ele, @@key);

    return if $line !~ /^\s*[0-9A-Fa-f]/;

    # removes comment and gets name
    $name = $1
	if $line =~ s/[#%]\s*(.*)//;
    return if defined $self->{undefName} && $name =~ /$self->{undefName}/;

    # gets element
    my($e, $k) = split /;/, $line;
    croak "Wrong Entry: <charList> must be separated by ';' from <collElement>"
	if ! $k;

    my @@e = _getHexArray($e);
    $ele = pack('U*', @@e);
    return if defined $self->{undefChar} && $ele =~ /$self->{undefChar}/;

    # get sort key
    if (defined $self->{ignoreName} && $name =~ /$self->{ignoreName}/ ||
	defined $self->{ignoreChar} && $ele  =~ /$self->{ignoreChar}/)
    {
	$self->{entries}{$ele} = $self->{ignored}{$ele} = 1;
    }
    else {
	my $combining = 1; # primary = 0, secondary != 0;

	foreach my $arr ($k =~ /\[([^\[\]]+)\]/g) { # SPACEs allowed
	    my $var = $arr =~ /\*/; # exactly /^\*/ but be lenient.
	    push @@key, $self->altCE($var, _getHexArray($arr));
	    $combining = 0 unless $key[-1][0] == 0 && $key[-1][1] != 0;
	}
	$self->{entries}{$ele} = \@@key;
	$self->{combining}{$ele} = 1 if $combining;
    }
    $self->{maxlength}{ord $ele} = scalar @@e if @@e > 1;
}


##
## arrayref CE = altCE(bool variable?, list[num] weights)
##
sub altCE
{
    my $self = shift;
    my $var  = shift;
    my @@c    = @@_;

    $self->{alternate} eq 'blanked' ?
	$var ? [0,0,0,$c[3]] : \@@c :
    $self->{alternate} eq 'non-ignorable' ?
	\@@c :
    $self->{alternate} eq 'shifted' ?
	$var ? [0,0,0,$c[0] ] : [ @@c[0..2], $c[0]+$c[1]+$c[2] ? 0xFFFF : 0 ] :
    $self->{alternate} eq 'shift-trimmed' ?
	$var ? [0,0,0,$c[0] ] : [ @@c[0..2], 0 ] :
        croak "$PACKAGE unknown alternate name: $self->{alternate}";
}

##
## string hex_sortkey = splitCE(string arg)
##
sub viewSortKey
{
    my $self = shift;
    my $key  = $self->getSortKey(@@_);
    my $view = join " ", map sprintf("%04X", $_), unpack 'n*', $key;
    $view =~ s/ ?0000 ?/|/g;
    return "[$view]";
}


##
## list[strings] elements = splitCE(string arg)
##
sub splitCE
{
    my $self = shift;
    my $code = $self->{preprocess};
    my $norm = $self->{UNF};
    my $ent  = $self->{entries};
    my $max  = $self->{maxlength};
    my $reH  = $self->{rearrangeHash};

    my $str = ref $code ? &$code(shift) : shift;
    $str = &$norm($str) if ref $norm;

    my @@src = unpack('U*', $str);
    my @@buf;

    # rearrangement
    if ($reH) {
	for (my $i = 0; $i < @@src; $i++) {
	    if (exists $reH->{ $src[$i] } && $i + 1 < @@src) {
		($src[$i], $src[$i+1]) = ($src[$i+1], $src[$i]);
		$i++;
	    }
	}
    }

    for (my $i = 0; $i < @@src; $i++) {
	my $ch;
	my $u = $src[$i];

	# non-characters
	next unless defined $u;
	next if $u < 0 || 0x10FFFF < $u    # out of range
	    || (0xD800 <= $u && $u <= 0xDFFF); # unpaired surrogates
	my $four = $u & 0xFFFF; 
	next if $four == 0xFFFE || $four == 0xFFFF;

	if ($max->{$u}) { # contract
	    for (my $j = $max->{$u}; $j >= 1; $j--) {
		next unless $i+$j-1 < @@src;
		$ch = pack 'U*', @@src[$i .. $i+$j-1];
		$i += $j-1, last if $ent->{$ch};
	    }
	} else {
	    $ch = pack('U', $u);
	}

	# with Combining Char (UTS#10, 4.2.1), here requires Unicode::Normalize.
	if ($getCombinClass && defined $ch) {
	    for (my $j = $i+1; $j < @@src; $j++) {
		next unless defined $src[$j];
		last unless $getCombinClass->( $src[$j] );
		my $comb = pack 'U', $src[$j];
		next if ! $ent->{ $ch.$comb };
		$ch .= $comb;
		$src[$j] = undef;
	    }
	}
	push @@buf, $ch;
    }
    wantarray ? @@buf : \@@buf;
}


##
## list[arrayrefs] weight = getWt(string element)
##
sub getWt
{
    my $self = shift;
    my $ch   = shift;
    my $ent  = $self->{entries};
    my $ign  = $self->{ignored};
    my $cjk  = $self->{overrideCJK};
    my $hang = $self->{overrideHangul};

    return if !defined $ch || $ign->{$ch}; # ignored
    return @@{ $ent->{$ch} } if $ent->{$ch};
    my $u = unpack('U', $ch);

    if (0xAC00 <= $u && $u <= 0xD7A3) { # is_Hangul
	return $hang
	    ? &$hang($u)
	    : defined $hang
		? map({
			my $v = $_;
			my $ar = $ent->{pack('U', $v)};
			$ar ? @@$ar : map($self->altCE(0,@@$_), _derivCE($v));
		    } _decompHangul($u))
		: map($self->altCE(0,@@$_), _derivCE($u));
    }
    elsif (0x3400 <= $u && $u <= 0x4DB5 ||
	   0x4E00 <= $u && $u <= 0x9FA5 ||
	   0x20000 <= $u && $u <= 0x2A6D6) { # is_CJK
	return $cjk
	    ? &$cjk($u)
	    : defined $cjk && $u <= 0xFFFF
		? $self->altCE(0, ($u, 0x20, 0x02, $u))
		: map($self->altCE(0,@@$_), _derivCE($u));
    }
    else {
	return map($self->altCE(0,@@$_), _derivCE($u));
    }
}

##
## int = index(string, substring)
##
sub index
{
    my $self = shift;
    my $lev  = $self->{level};
    my $comb = $self->{combining};
    my $str  = $self->splitCE(shift);
    my $sub  = $self->splitCE(shift);

    return wantarray ? (0,0) : 0 if ! @@$sub;
    return wantarray ?  ()  : -1 if ! @@$str;

    my @@subWt = grep _ignorableAtLevel($_,$lev),
		map $self->getWt($_), @@$sub;

    my(@@strWt,@@strPt);
    my $count = 0;
    for (my $i = 0; $i < @@$str; $i++) {
	my $go_ahead = 0;

	my @@tmp = grep _ignorableAtLevel($_,$lev), $self->getWt($str->[$i]);
	$go_ahead += length $str->[$i];

	# /*XXX*/ still broken.
	# index("e\x{300}", "e") should be 'no match' at level 2 or higher
	# as "e\x{300}" is a *single* grapheme cluster and not equal to "e".

	# go ahead as far as we find a combining character;
	while ($i + 1 < @@$str &&
	      (! defined $str->[$i+1] || $comb->{ $str->[$i+1] }) ) {
	    $i++;
	    $go_ahead += length $str->[$i];
	    next if ! defined $str->[$i];
	    push @@tmp,
		grep _ignorableAtLevel($_,$lev), $self->getWt($str->[$i]);
	}

	push @@strWt, @@tmp;
	push @@strPt, ($count) x @@tmp;
	$count += $go_ahead;

	while (@@strWt >= @@subWt) {
	    if (_eqArray(\@@strWt, \@@subWt, $lev)) {
		my $pos = $strPt[0];
		return wantarray ? ($pos, $count-$pos) : $pos;
	    }
	    shift @@strWt;
	    shift @@strPt;
	}
    }
    return wantarray ? () : -1;
}

##
## bool _eqArray(arrayref, arrayref, level)
##
sub _eqArray($$$)
{
    my $a   = shift; # length $a >= length $b;
    my $b   = shift;
    my $lev = shift;
    for my $v (0..$lev-1) {
	for my $c (0..@@$b-1){
	    return if $a->[$c][$v] != $b->[$c][$v];
	}
    }
    return 1;
}


##
## bool _ignorableAtLevel(CE, level)
##
sub _ignorableAtLevel($$)
{
    my $ce = shift;
    return unless defined $ce;
    my $lv = shift;
    return ! grep { ! $ce->[$_] } 0..$lv-1;
}


##
## string sortkey = getSortKey(string arg)
##
sub getSortKey
{
    my $self = shift;
    my $lev  = $self->{level};
    my $rCE  = $self->splitCE(shift); # get an arrayref

    # weight arrays
    my @@buf = grep defined(), map $self->getWt($_), @@$rCE;

    # make sort key
    my @@ret = ([],[],[],[]);
    foreach my $v (0..$lev-1) {
	foreach my $b (@@buf) {
	    push @@{ $ret[$v] }, $b->[$v] if $b->[$v];
	}
    }
    foreach (@@{ $self->{backwards} }) {
	my $v = $_ - 1;
	@@{ $ret[$v] } = reverse @@{ $ret[$v] };
    }

    # modification of tertiary weights
    if ($self->{upper_before_lower}) {
	foreach (@@{ $ret[2] }) {
	    if    (0x8 <= $_ && $_ <= 0xC) { $_ -= 6 } # lower
	    elsif (0x2 <= $_ && $_ <= 0x6) { $_ += 6 } # upper
	    elsif ($_ == 0x1C)             { $_ += 1 } # square upper
	    elsif ($_ == 0x1D)             { $_ -= 1 } # square lower
	}
    }
    if ($self->{katakana_before_hiragana}) {
	foreach (@@{ $ret[2] }) {
	    if    (0x0F <= $_ && $_ <= 0x13) { $_ -= 2 } # katakana
	    elsif (0x0D <= $_ && $_ <= 0x0E) { $_ += 5 } # hiragana
	}
    }
    join "\0\0", map pack('n*', @@$_), @@ret;
}


##
## int compare = cmp(string a, string b)
##
sub cmp { $_[0]->getSortKey($_[1]) cmp $_[0]->getSortKey($_[2]) }
sub eq  { $_[0]->getSortKey($_[1]) eq  $_[0]->getSortKey($_[2]) }
sub ne  { $_[0]->getSortKey($_[1]) ne  $_[0]->getSortKey($_[2]) }
sub lt  { $_[0]->getSortKey($_[1]) lt  $_[0]->getSortKey($_[2]) }
sub le  { $_[0]->getSortKey($_[1]) le  $_[0]->getSortKey($_[2]) }
sub gt  { $_[0]->getSortKey($_[1]) gt  $_[0]->getSortKey($_[2]) }
sub ge  { $_[0]->getSortKey($_[1]) ge  $_[0]->getSortKey($_[2]) }

##
## list[strings] sorted = sort(list[strings] arg)
##
sub sort {
    my $obj = shift;
    return
	map { $_->[1] }
	    sort{ $a->[0] cmp $b->[0] }
		map [ $obj->getSortKey($_), $_ ], @@_;
}

##
## list[arrayrefs] CE = _derivCE(int codepoint)
##
sub _derivCE {
    my $code = shift;
    my $a = UNDEFINED + ($code >> 15); # ok
    my $b = ($code & 0x7FFF) | 0x8000; # ok
#   my $a = 0xFFC2 + ($code >> 15);    # ng
#   my $b = $code & 0x7FFF | 0x1000;   # ng
    $b ? ([$a,2,1,$code],[$b,0,0,$code]) : [$a,2,1,$code];
}

##
## "hhhh hhhh hhhh" to (dddd, dddd, dddd)
##
sub _getHexArray { map hex, $_[0] =~ /([0-9a-fA-F]+)/g }

#
# $code must be in Hangul syllable.
# Check it before you enter here.
#
sub _decompHangul {
    my $code = shift;
    my $SIndex = $code - 0xAC00;
    my $LIndex = int( $SIndex / 588);
    my $VIndex = int(($SIndex % 588) / 28);
    my $TIndex =      $SIndex % 28;
    return (
	0x1100 + $LIndex,
	0x1161 + $VIndex,
	$TIndex ? (0x11A7 + $TIndex) : (),
    );
}

1;
__END__

=head1 NAME

Unicode::Collate - Unicode Collation Algorithm

=head1 SYNOPSIS

  use Unicode::Collate;

  #construct
  $Collator = Unicode::Collate->new(%tailoring);

  #sort
  @@sorted = $Collator->sort(@@not_sorted);

  #compare
  $result = $Collator->cmp($a, $b); # returns 1, 0, or -1.

=head1 DESCRIPTION

=head2 Constructor and Tailoring

The C<new> method returns a collator object.

   $Collator = Unicode::Collate->new(
      alternate => $alternate,
      backwards => $levelNumber, # or \@@levelNumbers
      entry => $element,
      normalization  => $normalization_form,
      ignoreName => qr/$ignoreName/,
      ignoreChar => qr/$ignoreChar/,
      katakana_before_hiragana => $bool,
      level => $collationLevel,
      overrideCJK => \&overrideCJK,
      overrideHangul => \&overrideHangul,
      preprocess => \&preprocess,
      rearrange => \@@charList,
      table => $filename,
      undefName => qr/$undefName/,
      undefChar => qr/$undefChar/,
      upper_before_lower => $bool,
   );
   # if %tailoring is false (i.e. empty),
   # $Collator should do the default collation.

=over 4

=item alternate

-- see 3.2.2 Alternate Weighting, UTR #10.

This key allows to alternate weighting for variable collation elements,
which are marked with an ASTERISK in the table
(NOTE: Many punction marks and symbols are variable in F<allkeys.txt>).

   alternate => 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.

These names are case-insensitive.
By default (if specification is omitted), 'shifted' is adopted.

   'Blanked'        Variable elements are ignorable at levels 1 through 3;
                    considered at the 4th level.

   'Non-ignorable'  Variable elements are not reset to ignorable.

   'Shifted'        Variable elements are ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non-Variable elements is 0xFFFF.

   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.

=item backwards

-- see 3.1.2 French Accents, UTR #10.

     backwards => $levelNumber or \@@levelNumbers

Weights in reverse order; ex. level 2 (diacritic ordering) in French.
If omitted, forwards at all the levels.

=item entry

-- see 3.1 Linguistic Features; 3.2.1 File Format, UTR #10.

Overrides a default order or defines additional collation elements

  entry => <<'ENTRIES', # use the UCA file format
00E6 ; [.0861.0020.0002.00E6] [.08B1.0020.0002.00E6] # ligature <ae> as <a><e>
0063 0068 ; [.0893.0020.0002.0063]      # "ch" in traditional Spanish
0043 0068 ; [.0893.0020.0008.0043]      # "Ch" in traditional Spanish
ENTRIES

=item ignoreName

=item ignoreChar

-- see Completely Ignorable, 3.2.2 Alternate Weighting, UTR #10.

Makes the entry in the table ignorable.
If a collation element is ignorable,
it is ignored as if the element had been deleted from there.

E.g. when 'a' and 'e' are ignorable,
'element' is equal to 'lament' (or 'lmnt').

=item level

-- see 4.3 Form a sort key for each string, UTR #10.

Set the maximum level.
Any higher levels than the specified one are ignored.

  Level 1: alphabetic ordering
  Level 2: diacritic ordering
  Level 3: case ordering
  Level 4: tie-breaking (e.g. in the case when alternate is 'shifted')

  ex.level => 2,

If omitted, the maximum is the 4th.

=item normalization

-- see 4.1 Normalize each input string, UTR #10.

If specified, strings are normalized before preparation of sort keys
(the normalization is executed after preprocess).

As a form name, one of the following names must be used.

  'C'  or 'NFC'  for Normalization Form C
  'D'  or 'NFD'  for Normalization Form D
  'KC' or 'NFKC' for Normalization Form KC
  'KD' or 'NFKD' for Normalization Form KD

If omitted, the string is put into Normalization Form D.

If C<undef> is passed explicitly as the value for this key,
any normalization is not carried out (this may make tailoring easier
if any normalization is not desired).

see B<CAVEAT>.

=item overrideCJK

-- see 7.1 Derived Collation Elements, UTR #10.

By default, mapping of CJK Unified Ideographs
uses the Unicode codepoint order.
But the mapping of CJK Unified Ideographs may be overrided.

ex. CJK Unified Ideographs in the JIS code point order.

  overrideCJK => sub {
      my $u = shift;             # get a Unicode codepoint
      my $b = pack('n', $u);     # to UTF-16BE
      my $s = your_unicode_to_sjis_converter($b); # convert
      my $n = unpack('n', $s);   # convert sjis to short
      [ $n, 0x20, 0x2, $u ];     # return the collation element
  },

ex. ignores all CJK Unified Ideographs.

  overrideCJK => sub {()}, # CODEREF returning empty list

   # where ->eq("Pe\x{4E00}rl", "Perl") is true
   # as U+4E00 is a CJK Unified Ideograph and to be ignorable.

If C<undef> is passed explicitly as the value for this key,
weights for CJK Unified Ideographs are treated as undefined.
But assignment of weight for CJK Unified Ideographs
in table or L<entry> is still valid.

=item overrideHangul

-- see 7.1 Derived Collation Elements, UTR #10.

By default, Hangul Syllables are decomposed into Hangul Jamo.
But the mapping of Hangul Syllables may be overrided.

This tag works like L<overrideCJK>, so see there for examples.

If you want to override the mapping of Hangul Syllables,
the Normalization Forms D and KD are not appropriate
(they will be decomposed before overriding).

If C<undef> is passed explicitly as the value for this key,
weight for Hangul Syllables is treated as undefined
without decomposition into Hangul Jamo.
But definition of weight for Hangul Syllables
in table or L<entry> is still valid.

=item preprocess

-- see 5.1 Preprocessing, UTR #10.

If specified, the coderef is used to preprocess
before the formation of sort keys.

ex. dropping English articles, such as "a" or "the".
Then, "the pen" is before "a pencil".

     preprocess => sub {
           my $str = shift;
           $str =~ s/\b(?:an?|the)\s+//gi;
           $str;
        },

=item rearrange

-- see 3.1.3 Rearrangement, UTR #10.

Characters that are not coded in logical order and to be rearranged.
By default,

    rearrange => [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ],

If you want to disallow any rearrangement,
pass C<undef> or C<[]> (a reference to an empty list)
as the value for this key.

=item table

-- see 3.2 Default Unicode Collation Element Table, UTR #10.

You can use another element table if desired.
The table file must be in your C<lib/Unicode/Collate> directory.

By default, the file C<lib/Unicode/Collate/allkeys.txt> is used.

If C<undef> is passed explicitly as the value for this key,
no file is read (but you can define collation elements via L<entry>).

A typical way to define a collation element table
without any file of table:

   $onlyABC = Unicode::Collate->new(
       table => undef,
       entry => << 'ENTRIES',
0061 ; [.0101.0020.0002.0061] # LATIN SMALL LETTER A
0041 ; [.0101.0020.0008.0041] # LATIN CAPITAL LETTER A
0062 ; [.0102.0020.0002.0062] # LATIN SMALL LETTER B
0042 ; [.0102.0020.0008.0042] # LATIN CAPITAL LETTER B
0063 ; [.0103.0020.0002.0063] # LATIN SMALL LETTER C
0043 ; [.0103.0020.0008.0043] # LATIN CAPITAL LETTER C
ENTRIES
    );

=item undefName

=item undefChar

-- see 6.3.4 Reducing the Repertoire, UTR #10.

Undefines the collation element as if it were unassigned in the table.
This reduces the size of the table.
If an unassigned character appears in the string to be collated,
the sort key is made from its codepoint
as a single-character collation element,
as it is greater than any other assigned collation elements
(in the codepoint order among the unassigned characters).
But, it'd be better to ignore characters
unfamiliar to you and maybe never used.

=item katakana_before_hiragana

=item upper_before_lower

-- see 6.6 Case Comparisons; 7.3.1 Tertiary Weight Table, UTR #10.

By default, lowercase is before uppercase
and hiragana is before katakana.

If the tag is made true, this is reversed.

B<NOTE>: These tags simplemindedly assume
any lowercase/uppercase or hiragana/katakana distinctions
should occur in level 3, and their weights at level 3
should be same as those mentioned in 7.3.1, UTR #10.
If you define your collation elements which violates this,
these tags doesn't work validly.

=back

=head2 Methods for Collation

=over 4

=item C<@@sorted = $Collator-E<gt>sort(@@not_sorted)>

Sorts a list of strings.

=item C<$result = $Collator-E<gt>cmp($a, $b)>

Returns 1 (when C<$a> is greater than C<$b>)
or 0 (when C<$a> is equal to C<$b>)
or -1 (when C<$a> is lesser than C<$b>).

=item C<$result = $Collator-E<gt>eq($a, $b)>

=item C<$result = $Collator-E<gt>ne($a, $b)>

=item C<$result = $Collator-E<gt>lt($a, $b)>

=item C<$result = $Collator-E<gt>le($a, $b)>

=item C<$result = $Collator-E<gt>gt($a, $b)>

=item C<$result = $Collator-E<gt>ge($a, $b)>

They works like the same name operators as theirs.

   eq : whether $a is equal to $b.
   ne : whether $a is not equal to $b.
   lt : whether $a is lesser than $b.
   le : whether $a is lesser than $b or equal to $b.
   gt : whether $a is greater than $b.
   ge : whether $a is greater than $b or equal to $b.

=item C<$sortKey = $Collator-E<gt>getSortKey($string)>

-- see 4.3 Form a sort key for each string, UTR #10.

Returns a sort key.

You compare the sort keys using a binary comparison
and get the result of the comparison of the strings using UCA.

   $Collator->getSortKey($a) cmp $Collator->getSortKey($b)

      is equivalent to

   $Collator->cmp($a, $b)

=item C<$sortKeyForm = $Collator-E<gt>viewSortKey($string)>

Returns a string formalized to display a sort key.
Weights are enclosed with C<'['> and C<']'>
and level boundaries are denoted by C<'|'>.

   use Unicode::Collate;
   my $c = Unicode::Collate->new();
   print $c->viewSortKey("Perl"),"\n";

    # output:
    # [09B3 08B1 09CB 094F|0020 0020 0020 0020|0008 0002 0002 0002|FFFF FFFF FFFF FFFF]
    #  Level 1             Level 2             Level 3             Level 4

=item C<$position = $Collator-E<gt>index($string, $substring)>

=item C<($position, $length) = $Collator-E<gt>index($string, $substring)>

-- see 6.8 Searching, UTR #10.

If C<$substring> matches a part of C<$string>, returns
the position of the first occurrence of the matching part in scalar context;
in list context, returns a two-element list of
the position and the length of the matching part.

B<Notice> that the length of the matching part may differ from
the length of C<$substring>.

B<Note> that the position and the length are counted on the string
after the process of preprocess, normalization, and rearrangement.
Therefore, in case the specified string is not binary equal to
the preprocessed/normalized/rearranged string, the position and the length
may differ form those on the specified string. But it is guaranteed
that, if matched, it returns a non-negative value as C<$position>.

If C<$substring> does not match any part of C<$string>,
returns C<-1> in scalar context and
an empty list in list context.

e.g. you say

  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
  my $str = "Ich mu\x{00DF} studieren.";
  my $sub = "m\x{00FC}ss";
  my $match;
  if (my($pos,$len) = $Collator->index($str, $sub)) {
      $match = substr($str, $pos, $len);
  }

and get C<"mu\x{00DF}"> in C<$match> since C<"mu>E<223>C<">
is primary equal to C<"m>E<252>C<ss">. 

=back

=head2 Other Methods

=over 4

=item UCA_Version

Returns the version number of Unicode Technical Standard 10
this module consults.

=item Base_Unicode_Version

Returns the version number of the Unicode Standard
this module is based on.

=back

=head2 EXPORT

None by default.

=head2 TODO

Unicode::Collate has not been ported to EBCDIC.  The code mostly would
work just fine but a decision needs to be made: how the module should
work in EBCDIC?  Should the low 256 characters be understood as
Unicode or as EBCDIC code points?  Should one be chosen or should
there be a way to do either?  Or should such translation be left
outside the module for the user to do, for example by using
Encode::from_to()?
(or utf8::unicode_to_native()/utf8::native_to_unicode()?)

=head2 CAVEAT

Use of the C<normalization> parameter requires
the B<Unicode::Normalize> module.

If you need not it (say, in the case when you need not
handle any combining characters),
assign C<normalization =E<gt> undef> explicitly.

-- see 6.5 Avoiding Normalization, UTR #10.

=head2 BUGS

C<index()> is an experimental method and
its return value may be unreliable.
The correct implementation for C<index()> must be based
on Locale-Sensitive Support: Level 3 in UTR #18,
F<Unicode Regular Expression Guidelines>.

See also 4.2 Locale-Dependent Graphemes in UTR #18.

=head1 AUTHOR

SADAHIRO Tomoyuki, E<lt>SADAHIRO@@cpan.orgE<gt>

  http://homepage1.nifty.com/nomenclator/perl/

  Copyright(C) 2001-2002, SADAHIRO Tomoyuki. Japan. All rights reserved.

  This library is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.

=head1 SEE ALSO

=over 4

=item http://www.unicode.org/unicode/reports/tr10/

Unicode Collation Algorithm - UTR #10

=item http://www.unicode.org/unicode/reports/tr10/allkeys.txt

The Default Unicode Collation Element Table

=item http://www.unicode.org/unicode/reports/tr15/

Unicode Normalization Forms - UAX #15

=item http://www.unicode.org/unicode/reports/tr18

Unicode Regular Expression Guidelines - UTR #18

=item L<Unicode::Normalize>

=back

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d4 2
a5 2
    unless ("A" eq pack('U', 0x41)) {
	die "Unicode::Collate cannot stringify a Unicode code point\n";
d17 1
a17 1
our $VERSION = '0.30';
d29 1
a29 79
# Perl's boolean
use constant TRUE  => 1;
use constant FALSE => "";
use constant NOMATCHPOS => -1;

# A coderef to get combining class imported from Unicode::Normalize
# (i.e. \&Unicode::Normalize::getCombinClass).
# This is also used as a HAS_UNICODE_NORMALIZE flag.
our $CVgetCombinClass;

# Supported Levels
use constant MinLevel => 1;
use constant MaxLevel => 4;

# Minimum weights at level 2 and 3, respectively
use constant Min2Wt => 0x20;
use constant Min3Wt => 0x02;

# Shifted weight at 4th level
use constant Shift4Wt => 0xFFFF;

# Variable weight at 1st level.
# This is a negative value but should be regarded as zero on collation.
# This is for distinction of variable chars from level 3 ignorable chars.
use constant Var1Wt => -1;


# A boolean for Variable and 16-bit weights at 4 levels of Collation Element
# PROBLEM: The Default Unicode Collation Element Table
# has weights over 0xFFFF at the 4th level.
# The tie-breaking in the variable weights
# other than "shift" (as well as "shift-trimmed") is unreliable.
use constant VCE_TEMPLATE => 'Cn4';

# A sort key: 16-bit weights
# See also the PROBLEM on VCE_TEMPLATE above.
use constant KEY_TEMPLATE => 'n*';

# Level separator in a sort key:
# i.e. pack(KEY_TEMPLATE, 0)
use constant LEVEL_SEP => "\0\0";

# As Unicode code point separator for hash keys.
# A joined code point string (denoted by JCPS below)
# like "65;768" is used for internal processing
# instead of Perl's Unicode string like "\x41\x{300}",
# as the native code point is different from the Unicode code point
# on EBCDIC platform.
# This character must not be included in any stringified
# representation of an integer.
use constant CODE_SEP => ';';

# boolean values of variable weights
use constant NON_VAR => 0; # Non-Variable character
use constant VAR     => 1; # Variable character

# specific code points
use constant Hangul_LBase  => 0x1100;
use constant Hangul_LIni   => 0x1100;
use constant Hangul_LFin   => 0x1159;
use constant Hangul_LFill  => 0x115F;
use constant Hangul_VBase  => 0x1161;
use constant Hangul_VIni   => 0x1160;
use constant Hangul_VFin   => 0x11A2;
use constant Hangul_TBase  => 0x11A7;
use constant Hangul_TIni   => 0x11A8;
use constant Hangul_TFin   => 0x11F9;
use constant Hangul_TCount => 28;
use constant Hangul_NCount => 588;
use constant Hangul_SBase  => 0xAC00;
use constant Hangul_SIni   => 0xAC00;
use constant Hangul_SFin   => 0xD7A3;
use constant CJK_UidIni    => 0x4E00;
use constant CJK_UidFin    => 0x9FA5;
use constant CJK_ExtAIni   => 0x3400;
use constant CJK_ExtAFin   => 0x4DB5;
use constant CJK_ExtBIni   => 0x20000;
use constant CJK_ExtBFin   => 0x2A6D6;
use constant BMP_Max       => 0xFFFF;
d31 1
a31 13
# Logical_Order_Exception in PropList.txt
# TODO: synchronization with change of PropList.txt.
our $DefaultRearrange = [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ];

sub UCA_Version { "11" }

sub Base_Unicode_Version { "4.0" }

######

sub pack_U {
    return pack('U*', @@_);
}
d33 2
a34 2
sub unpack_U {
    return unpack('U*', pack('U*').shift);
d36 9
a44 53

######

my (%VariableOK);
@@VariableOK{ qw/
    blanked  non-ignorable  shifted  shift-trimmed
  / } = (); # keys lowercased

our @@ChangeOK = qw/
    alternate backwards level normalization rearrange
    katakana_before_hiragana upper_before_lower
    overrideHangul overrideCJK preprocess UCA_Version
    hangul_terminator variable
  /;

our @@ChangeNG = qw/
    entry mapping table maxlength
    ignoreChar ignoreName undefChar undefName variableTable
    versionTable alternateTable backwardsTable forwardsTable rearrangeTable
    derivCode normCode rearrangeHash L3_ignorable
    backwardsFlag
  /;
# The hash key 'ignored' is deleted at v 0.21.
# The hash key 'isShift' is deleted at v 0.23.
# The hash key 'combining' is deleted at v 0.24.
# The hash key 'entries' is deleted at v 0.30.

sub version {
    my $self = shift;
    return $self->{versionTable} || 'unknown';
}

my (%ChangeOK, %ChangeNG);
@@ChangeOK{ @@ChangeOK } = ();
@@ChangeNG{ @@ChangeNG } = ();

sub change {
    my $self = shift;
    my %hash = @@_;
    my %old;
    if (exists $hash{variable} && exists $hash{alternate}) {
	delete $hash{alternate};
    }
    elsif (!exists $hash{variable} && exists $hash{alternate}) {
	$hash{variable} = $hash{alternate};
    }
    foreach my $k (keys %hash) {
	if (exists $ChangeOK{$k}) {
	    $old{$k} = $self->{$k};
	    $self->{$k} = $hash{$k};
	}
	elsif (exists $ChangeNG{$k}) {
	    croak "change of $k via change() is not allowed!";
a45 1
	# else => ignored
a46 2
    $self->checkCollator;
    return wantarray ? %old : $self;
d49 1
a49 8
sub _checkLevel {
    my $level = shift;
    my $key   = shift;
    croak sprintf "Illegal level %d (in \$self->{%s}) lower than %d.",
	$level, $key, MinLevel if MinLevel > $level;
    croak sprintf "Unsupported level %d (in \$self->{%s}) higher than %d ",
	$level, $key, MaxLevel if MaxLevel < $level;
}
d51 3
a53 5
my %DerivCode = (
    8 => \&_derivCE_8,
    9 => \&_derivCE_9,
   11 => \&_derivCE_9, # 11 == 9
);
d55 1
a55 3
sub checkCollator {
    my $self = shift;
    _checkLevel($self->{level}, "level");
d57 1
a57 2
    $self->{derivCode} = $DerivCode{ $self->{UCA_Version} }
	or croak "Illegal UCA version (passed $self->{UCA_Version}).";
d59 1
a59 5
    $self->{variable} ||= $self->{alternate} || $self->{variableTable} ||
		$self->{alternateTable} || $self->{alternate} || 'shifted';
    $self->{variable} = $self->{alternate} = lc($self->{variable});
    exists $VariableOK{ $self->{variable} }
	or croak "$PACKAGE unknown variable tag name: $self->{variable}";
d61 7
a67 18
    if (! defined $self->{backwards}) {
	$self->{backwardsFlag} = 0;
    }
    elsif (! ref $self->{backwards}) {
	_checkLevel($self->{backwards}, "backwards");
	$self->{backwardsFlag} = 1 << $self->{backwards};
    }
    else {
	my %level;
	$self->{backwardsFlag} = 0;
	for my $b (@@{ $self->{backwards} }) {
	    _checkLevel($b, "backwards");
	    $level{$b} = 1;
	}
	for my $v (sort keys %level) {
	    $self->{backwardsFlag} += 1 << $v;
	}
    }
d69 17
a85 3
    defined $self->{rearrange} or $self->{rearrange} = [];
    ref $self->{rearrange}
	or croak "$PACKAGE: list for rearrangement must be store in ARRAYREF";
d87 6
a92 2
    # keys of $self->{rearrangeHash} are $self->{rearrange}.
    $self->{rearrangeHash} = undef;
d94 4
a97 5
    if (@@{ $self->{rearrange} }) {
	@@{ $self->{rearrangeHash} }{ @@{ $self->{rearrange} } } = ();
    }

    $self->{normCode} = undef;
d101 2
a102 3
	$@@ and croak "Unicode::Normalize is required to normalize strings";

	$CVgetCombinClass ||= \&Unicode::Normalize::getCombinClass;
d104 11
a114 11
	if ($self->{normalization} =~ /^(?:NF)D\z/) { # tweak for default
	    $self->{normCode} = \&Unicode::Normalize::NFD;
	}
	elsif ($self->{normalization} ne 'prenormalized') {
	    my $norm = $self->{normalization};
	    $self->{normCode} = sub {
		Unicode::Normalize::normalize($norm, shift);
	    };
	    eval { $self->{normCode}->("") }; # try
	    $@@ and croak "$PACKAGE unknown normalization form name: $norm";
	}
a115 7
    return;
}

sub new
{
    my $class = shift;
    my $self = bless { @@_ }, $class;
d117 1
d119 4
a122 2
    $self->{table} = $KeyFile if ! exists $self->{table};
    $self->read_table if defined $self->{table};
d128 4
a131 2
    $self->{level} ||= MaxLevel;
    $self->{UCA_Version} ||= UCA_Version();
d133 2
a134 7
    $self->{overrideHangul} = ''
	if ! exists $self->{overrideHangul};
    $self->{overrideCJK} = ''
	if ! exists $self->{overrideCJK};
    $self->{normalization} = 'NFD'
	if ! exists $self->{normalization};
    $self->{rearrange} = $self->{rearrangeTable} || $DefaultRearrange
d136 4
a139 2
    $self->{backwards} = $self->{backwardsTable}
	if ! exists $self->{backwards};
d141 6
a146 1
    $self->checkCollator;
d162 2
a163 8
	    if    (/^\s*\@@version\s*(\S*)/) {
		$self->{versionTable} ||= $1;
	    }
	    elsif (/^\s*\@@variable\s+(\S*)/) { # since UTS #10-9
		$self->{variableTable} ||= $1;
	    }
	    elsif (/^\s*\@@alternate\s+(\S*)/) { # till UTS #10-8
		$self->{alternateTable} ||= $1;
d165 2
a166 2
	    elsif (/^\s*\@@backwards\s+(\S*)/) {
		push @@{ $self->{backwardsTable} }, $1;
d168 2
a169 2
	    elsif (/^\s*\@@forwards\s+(\S*)/) { # parhaps no use
		push @@{ $self->{forwardsTable} }, $1;
d171 2
a172 2
	    elsif (/^\s*\@@rearrange\s+(.*)/) { # (\S*) is NG
		push @@{ $self->{rearrangeTable} }, _getHexArray($1);
d189 1
a189 1
    my($name, $entry, @@uv, @@key);
d203 9
a211 15
    @@uv = _getHexArray($e);
    return if !@@uv;

    $entry = join(CODE_SEP, @@uv); # in JCPS

    if (defined $self->{undefChar} || defined $self->{ignoreChar}) {
	my $ele = pack_U(@@uv);

	# regarded as if it were not entried in the table
	return
	    if defined $self->{undefChar} && $ele =~ /$self->{undefChar}/;

	# replaced as completely ignorable
	$k = '[.0000.0000.0000.0000]'
	    if defined $self->{ignoreChar} && $ele =~ /$self->{ignoreChar}/;
d213 2
d216 7
a222 29
    # replaced as completely ignorable
    $k = '[.0000.0000.0000.0000]'
	if defined $self->{ignoreName} && $name =~ /$self->{ignoreName}/;

    my $is_L3_ignorable = TRUE;

    foreach my $arr ($k =~ /\[([^\[\]]+)\]/g) { # SPACEs allowed
	my $var = $arr =~ /\*/; # exactly /^\*/ but be lenient.
	my @@wt = _getHexArray($arr);
	push @@key, pack(VCE_TEMPLATE, $var, @@wt);
	$is_L3_ignorable = FALSE
	    if $wt[0] + $wt[1] + $wt[2] != 0;
	  # if $arr !~ /[1-9A-Fa-f]/; NG
	  # Conformance Test shows L3-ignorable is completely ignorable.
	# For expansion, an entry $is_L3_ignorable
	# if and only if "all" CEs are [.0000.0000.0000].
    }

    $self->{mapping}{$entry} = \@@key;

    if (@@uv > 1) {
	(!$self->{maxlength}{$uv[0]} || $self->{maxlength}{$uv[0]} < @@uv)
	    and $self->{maxlength}{$uv[0]} = @@uv;
    }
    else {
	$is_L3_ignorable
	    ? ($self->{L3_ignorable}{$uv[0]} = TRUE)
	    : ($self->{L3_ignorable}{$uv[0]} and
	       $self->{L3_ignorable}{$uv[0]} = FALSE); # &&= stores key.
d224 1
d229 1
a229 1
## arrayref[weights] = varCE(VCE)
d231 1
a231 1
sub varCE
d234 2
a235 1
    my($var, @@wt) = unpack(VCE_TEMPLATE, shift);
d237 9
a245 10
    $self->{variable} eq 'blanked' ?
	$var ? [Var1Wt, 0, 0, $wt[3]] : \@@wt :
    $self->{variable} eq 'non-ignorable' ?
	\@@wt :
    $self->{variable} eq 'shifted' ?
	$var ? [Var1Wt, 0, 0, $wt[0] ]
	     : [ @@wt[0..2], $wt[0]+$wt[1]+$wt[2] ? Shift4Wt : 0 ] :
    $self->{variable} eq 'shift-trimmed' ?
	$var ? [Var1Wt, 0, 0, $wt[0] ] : [ @@wt[0..2], 0 ] :
	croak "$PACKAGE unknown variable name: $self->{variable}";
d248 3
d254 3
a256 13
    $self->visualizeSortKey($self->getSortKey(@@_));
}

sub visualizeSortKey
{
    my $self = shift;
    my $view = join " ", map sprintf("%04X", $_), unpack(KEY_TEMPLATE, shift);

    if ($self->{UCA_Version} <= 8) {
	$view =~ s/ ?0000 ?/|/g;
    } else {
	$view =~ s/\b0000\b/|/g;
    }
d262 1
a262 2
## arrayref of JCPS   = splitEnt(string to be collated)
## arrayref of arrayref[JCPS, ini_pos, fin_pos] = splitEnt(string, true)
d264 1
a264 1
sub splitEnt
a266 2
    my $wLen = $_[1];

d268 2
a269 2
    my $norm = $self->{normCode};
    my $map  = $self->{mapping};
a271 2
    my $ign  = $self->{L3_ignorable};
    my $ver9 = $self->{UCA_Version} >= 9;
d273 2
a274 1
    my ($str, @@buf);
d276 2
a277 12
    if ($wLen) {
	$code and croak "Preprocess breaks character positions. "
			. "Don't use with index(), match(), etc.";
	$norm and croak "Normalization breaks character positions. "
			. "Don't use with index(), match(), etc.";
	$str = $_[0];
    }
    else {
	$str = $_[0];
	$str = &$code($str) if ref $code;
	$str = &$norm($str) if ref $norm;
    }
d279 2
a280 7
    # get array of Unicode code point of string.
    my @@src = unpack_U($str);

    # rearrangement:
    # Character positions are not kept if rearranged,
    # then neglected if $wLen is true.
    if ($reH && ! $wLen) {
a288 7
    if ($ver9) {
	# To remove a character marked as a completely ignorable.
	for (my $i = 0; $i < @@src; $i++) {
	    $src[$i] = undef if $ign->{ $src[$i] };
	}
    }

d290 2
a291 1
	next if _isNonCharacter($src[$i]);
d293 12
a304 43
	my $i_orig = $i;
	my $jcps = $src[$i];

	if ($max->{$jcps}) { # contract
	    my $temp_jcps = $jcps;
	    my $jcpsLen = 1;
	    my $maxLen = $max->{$jcps};

	    for (my $p = $i + 1; $jcpsLen < $maxLen && $p < @@src; $p++) {
		next if ! defined $src[$p];
		$temp_jcps .= CODE_SEP . $src[$p];
		$jcpsLen++;
		if ($map->{$temp_jcps}) {
		    $jcps = $temp_jcps;
		    $i = $p;
		}
	    }

	# not-contiguous contraction with Combining Char (cf. UTS#10, S2.1).
	# This process requires Unicode::Normalize.
	# If "normalization" is undef, here should be skipped *always*
	# (in spite of bool value of $CVgetCombinClass),
	# since canonical ordering cannot be expected.
	# Blocked combining character should not be contracted.

	    if ($self->{normalization})
	    # $self->{normCode} is false in the case of "prenormalized".
	    {
		my $preCC = 0;
		my $curCC = 0;

		for (my $p = $i + 1; $p < @@src; $p++) {
		    next if ! defined $src[$p];
		    $curCC = $CVgetCombinClass->($src[$p]);
		    last unless $curCC;
		    my $tail = CODE_SEP . $src[$p];
		    if ($preCC != $curCC && $map->{$jcps.$tail}) {
			$jcps .= $tail;
			$src[$p] = undef;
		    } else {
			$preCC = $curCC;
		    }
		}
d306 2
d310 9
a318 4
	if ($wLen) {
	    for (my $p = $i + 1; $p < @@src; $p++) {
		last if defined $src[$p];
		$i = $p;
d321 1
a321 2

	push @@buf, $wLen ? [$jcps, $i_orig, $i + 1] : $jcps;
d323 1
a323 1
    return \@@buf;
d328 1
a328 1
## list of arrayrefs of weights = getWt(JCPS)
d333 29
a361 59
    my $u    = shift;
    my $map  = $self->{mapping};
    my $der  = $self->{derivCode};

    return if !defined $u;
    return map($self->varCE($_), @@{ $map->{$u} })
	if $map->{$u};

    # JCPS must not be a contraction, then it's a code point.
    if (Hangul_SIni <= $u && $u <= Hangul_SFin) {
	my $hang = $self->{overrideHangul};
	my @@hangulCE;
	if ($hang) {
	    @@hangulCE = map(pack(VCE_TEMPLATE, NON_VAR, @@$_), &$hang($u));
	}
	elsif (!defined $hang) {
	    @@hangulCE = $der->($u);
	}
	else {
	    my $max  = $self->{maxlength};
	    my @@decH = _decompHangul($u);

	    if (@@decH == 2) {
		my $contract = join(CODE_SEP, @@decH);
		@@decH = ($contract) if $map->{$contract};
	    } else { # must be <@@decH == 3>
		if ($max->{$decH[0]}) {
		    my $contract = join(CODE_SEP, @@decH);
		    if ($map->{$contract}) {
			@@decH = ($contract);
		    } else {
			$contract = join(CODE_SEP, @@decH[0,1]);
			$map->{$contract} and @@decH = ($contract, $decH[2]);
		    }
		    # even if V's ignorable, LT contraction is not supported.
		    # If such a situatution were required, NFD should be used.
		}
		if (@@decH == 3 && $max->{$decH[1]}) {
		    my $contract = join(CODE_SEP, @@decH[1,2]);
		    $map->{$contract} and @@decH = ($decH[0], $contract);
		}
	    }

	    @@hangulCE = map({
		    $map->{$_} ? @@{ $map->{$_} } : $der->($_);
		} @@decH);
	}
	return map $self->varCE($_), @@hangulCE;
    }
    elsif (CJK_UidIni  <= $u && $u <= CJK_UidFin  ||
	   CJK_ExtAIni <= $u && $u <= CJK_ExtAFin ||
	   CJK_ExtBIni <= $u && $u <= CJK_ExtBFin) {
	my $cjk  = $self->{overrideCJK};
	return map $self->varCE($_),
	    $cjk
		? map(pack(VCE_TEMPLATE, NON_VAR, @@$_), &$cjk($u))
		: defined $cjk && $self->{UCA_Version} <= 8 && $u <= BMP_Max
		    ? pack(VCE_TEMPLATE, NON_VAR, $u, Min2Wt, Min3Wt, $u)
		    : $der->($u);
d364 1
a364 1
	return map $self->varCE($_), $der->($u);
a367 1

d369 1
a369 1
## string sortkey = getSortKey(string arg)
d371 1
a371 1
sub getSortKey
d375 3
a377 3
    my $rEnt = $self->splitEnt(shift); # get an arrayref of JCPS
    my $ver9 = $self->{UCA_Version} >= 9;
    my $v2i  = $self->{variable} ne 'non-ignorable';
d379 5
a383 2
    # weight arrays
    my (@@wts, @@buf, $last_is_variable);
d385 4
a388 12
    if ($self->{hangul_terminator}) {
	my $preHST = '';
	foreach my $jcps (@@$rEnt) {
	    # weird things like VL, TL-contraction are not considered!
	    my $curHST = '';
	    foreach my $u (split /;/, $jcps) {
		$curHST .= getHST($u);
	    }
	    if ($preHST && !$curHST || # hangul before non-hangul
		$preHST =~ /L\z/ && $curHST =~ /^T/ ||
		$preHST =~ /V\z/ && $curHST =~ /^L/ ||
		$preHST =~ /T\z/ && $curHST =~ /^[LV]/) {
d390 2
a391 3
		push @@wts, $self->varCE_HangulTerm;
	    }
	    $preHST = $curHST;
d393 12
a404 1
	    push @@wts, $self->getWt($jcps);
d406 12
a417 6
	$preHST # end at hangul
	    and push @@wts, $self->varCE_HangulTerm;
    }
    else {
	foreach my $jcps (@@$rEnt) {
	    push @@wts, $self->getWt($jcps);
d420 2
d423 11
a433 7
    foreach my $wt (@@wts) {
	if ($v2i && $ver9) {
	    if ($wt->[0] == 0) { # ignorable
		next if $last_is_variable;
	    } else {
		$last_is_variable = ($wt->[0] == Var1Wt);
	    }
a434 1
	push @@buf, $wt;
d436 27
d468 1
a468 2
	    push @@{ $ret[$v] }, $b->[$v]
		if 0 < $b->[$v];
d471 4
d491 1
a491 10

    if ($self->{backwardsFlag}) {
	for (my $v = MinLevel; $v <= MaxLevel; $v++) {
	    if ($self->{backwardsFlag} & (1 << $v)) {
		@@{ $ret[$v-1] } = reverse @@{ $ret[$v-1] };
	    }
	}
    }

    join LEVEL_SEP, map pack(KEY_TEMPLATE, @@$_), @@ret;
d517 4
a520 19

sub _derivCE_9 {
    my $u = shift;
    my $base =
	(CJK_UidIni  <= $u && $u <= CJK_UidFin)
	    ? 0xFB40 : # CJK
	(CJK_ExtAIni <= $u && $u <= CJK_ExtAFin ||
	 CJK_ExtBIni <= $u && $u <= CJK_ExtBFin)
	    ? 0xFB80   # CJK ext.
	    : 0xFBC0;  # others

    my $aaaa = $base + ($u >> 15);
    my $bbbb = ($u & 0x7FFF) | 0x8000;
    return
	pack(VCE_TEMPLATE, NON_VAR, $aaaa, Min2Wt, Min3Wt, $u),
	pack(VCE_TEMPLATE, NON_VAR, $bbbb,      0,      0, $u);
}

sub _derivCE_8 {
d522 5
a526 12
    my $aaaa =  0xFF80 + ($code >> 15);
    my $bbbb = ($code & 0x7FFF) | 0x8000;
    return
	pack(VCE_TEMPLATE, NON_VAR, $aaaa, 2, 1, $code),
	pack(VCE_TEMPLATE, NON_VAR, $bbbb, 0, 0, $code);
}


sub varCE_HangulTerm {
    my $self = shift;
    return $self->varCE(pack(VCE_TEMPLATE,
	NON_VAR, $self->{hangul_terminator}, 0,0,0));
a528 1

d535 1
a535 1
# $code *must* be in Hangul syllable.
d540 4
a543 4
    my $SIndex = $code - Hangul_SBase;
    my $LIndex = int( $SIndex / Hangul_NCount);
    my $VIndex = int(($SIndex % Hangul_NCount) / Hangul_TCount);
    my $TIndex =      $SIndex % Hangul_TCount;
d545 3
a547 3
	Hangul_LBase + $LIndex,
	Hangul_VBase + $VIndex,
	$TIndex ? (Hangul_TBase + $TIndex) : (),
a550 257
sub _isNonCharacter {
    my $code = shift;
    return ! defined $code                      # removed
	|| ($code < 0 || 0x10FFFF < $code)      # out of range
	|| (($code & 0xFFFE) == 0xFFFE)         # ??FFF[EF] (cf. utf8.c)
	|| (0xD800 <= $code && $code <= 0xDFFF) # unpaired surrogates
	|| (0xFDD0 <= $code && $code <= 0xFDEF) # other non-characters
    ;
}

# Hangul Syllable Type
sub getHST {
    my $u = shift;
    return
	Hangul_LIni <= $u && $u <= Hangul_LFin || $u == Hangul_LFill ? "L" :
	Hangul_VIni <= $u && $u <= Hangul_VFin	     ? "V" :
	Hangul_TIni <= $u && $u <= Hangul_TFin	     ? "T" :
	Hangul_SIni <= $u && $u <= Hangul_SFin ?
	    ($u - Hangul_SBase) % Hangul_TCount ? "LVT" : "LV" : "";
}


##
## bool _nonIgnorAtLevel(arrayref weights, int level)
##
sub _nonIgnorAtLevel($$)
{
    my $wt = shift;
    return if ! defined $wt;
    my $lv = shift;
    return grep($wt->[$_-1] != 0, MinLevel..$lv) ? TRUE : FALSE;
}

##
## bool _eqArray(
##    arrayref of arrayref[weights] source,
##    arrayref of arrayref[weights] substr,
##    int level)
## * comparison of graphemes vs graphemes.
##   @@$source >= @@$substr must be true (check it before call this);
##
sub _eqArray($$$)
{
    my $source = shift;
    my $substr = shift;
    my $lev = shift;

    for my $g (0..@@$substr-1){
	# Do the $g'th graphemes have the same number of AV weigths?
	return if @@{ $source->[$g] } != @@{ $substr->[$g] };

	for my $w (0..@@{ $substr->[$g] }-1) {
	    for my $v (0..$lev-1) {
		return if $source->[$g][$w][$v] != $substr->[$g][$w][$v];
	    }
	}
    }
    return 1;
}

##
## (int position, int length)
## int position = index(string, substring, position, [undoc'ed grobal])
##
## With "grobal" (only for the list context),
##  returns list of arrayref[position, length].
##
sub index
{
    my $self = shift;
    my $str  = shift;
    my $len  = length($str);
    my $subE = $self->splitEnt(shift);
    my $pos  = @@_ ? shift : 0;
       $pos  = 0 if $pos < 0;
    my $grob = shift;

    my $lev  = $self->{level};
    my $ver9 = $self->{UCA_Version} >= 9;
    my $v2i  = $self->{variable} ne 'non-ignorable';

    if (! @@$subE) {
	my $temp = $pos <= 0 ? 0 : $len <= $pos ? $len : $pos;
	return $grob
	    ? map([$_, 0], $temp..$len)
	    : wantarray ? ($temp,0) : $temp;
    }
    if ($len < $pos) {
	return wantarray ? () : NOMATCHPOS;
    }
    my $strE = $self->splitEnt($pos ? substr($str, $pos) : $str, TRUE);
    if (! @@$strE) {
	return wantarray ? () : NOMATCHPOS;
    }
    my $last_is_variable;
    my(@@strWt, @@iniPos, @@finPos, @@subWt, @@g_ret);

    $last_is_variable = FALSE;
    for my $wt (map $self->getWt($_), @@$subE) {
	my $to_be_pushed = _nonIgnorAtLevel($wt,$lev);

	if ($v2i && $ver9) {
	    if ($wt->[0] == 0) {
		$to_be_pushed = FALSE if $last_is_variable;
	    } else {
		$last_is_variable = ($wt->[0] == Var1Wt);
	    }
	}

	if (@@subWt && $wt->[0] == 0) {
	    push @@{ $subWt[-1] }, $wt if $to_be_pushed;
	} else {
	    $wt->[0] = 0 if $wt->[0] == Var1Wt;
	    push @@subWt, [ $wt ];
	}
    }

    my $count = 0;
    my $end = @@$strE - 1;

    $last_is_variable = FALSE;

    for (my $i = 0; $i <= $end; ) { # no $i++
	my $found_base = 0;

	# fetch a grapheme
	while ($i <= $end && $found_base == 0) {
	    for my $wt ($self->getWt($strE->[$i][0])) {
		my $to_be_pushed = _nonIgnorAtLevel($wt,$lev);

		if ($v2i && $ver9) {
		    if ($wt->[0] == 0) {
			$to_be_pushed = FALSE if $last_is_variable;
		    } else {
			$last_is_variable = ($wt->[0] == Var1Wt);
		    }
		}

		if (@@strWt && $wt->[0] == 0) {
		    push @@{ $strWt[-1] }, $wt if $to_be_pushed;
		    $finPos[-1] = $strE->[$i][2];
		} elsif ($to_be_pushed) {
		    $wt->[0] = 0 if $wt->[0] == Var1Wt;
		    push @@strWt,  [ $wt ];
		    push @@iniPos, $found_base ? NOMATCHPOS : $strE->[$i][1];
		    $finPos[-1] = NOMATCHPOS if $found_base;
		    push @@finPos, $strE->[$i][2];
		    $found_base++;
		}
		# else ===> no-op
	    }
	    $i++;
	}

	# try to match
	while ( @@strWt > @@subWt || (@@strWt == @@subWt && $i > $end) ) {
	    if ($iniPos[0] != NOMATCHPOS &&
		    $finPos[$#subWt] != NOMATCHPOS &&
			_eqArray(\@@strWt, \@@subWt, $lev)) {
		my $temp = $iniPos[0] + $pos;

		if ($grob) {
		    push @@g_ret, [$temp, $finPos[$#subWt] - $iniPos[0]];
		    splice @@strWt,  0, $#subWt;
		    splice @@iniPos, 0, $#subWt;
		    splice @@finPos, 0, $#subWt;
		}
		else {
		    return wantarray
			? ($temp, $finPos[$#subWt] - $iniPos[0])
			:  $temp;
		}
	    }
	    shift @@strWt;
	    shift @@iniPos;
	    shift @@finPos;
	}
    }

    return $grob
	? @@g_ret
	: wantarray ? () : NOMATCHPOS;
}

##
## scalarref to matching part = match(string, substring)
##
sub match
{
    my $self = shift;
    if (my($pos,$len) = $self->index($_[0], $_[1])) {
	my $temp = substr($_[0], $pos, $len);
	return wantarray ? $temp : \$temp;
	# An lvalue ref \substr should be avoided,
	# since its value is affected by modification of its referent.
    }
    else {
	return;
    }
}

##
## arrayref matching parts = gmatch(string, substring)
##
sub gmatch
{
    my $self = shift;
    my $str  = shift;
    my $sub  = shift;
    return map substr($str, $_->[0], $_->[1]),
		$self->index($str, $sub, 0, 'g');
}

##
## bool subst'ed = subst(string, substring, replace)
##
sub subst
{
    my $self = shift;
    my $code = ref $_[2] eq 'CODE' ? $_[2] : FALSE;

    if (my($pos,$len) = $self->index($_[0], $_[1])) {
	if ($code) {
	    my $mat = substr($_[0], $pos, $len);
	    substr($_[0], $pos, $len, $code->($mat));
	} else {
	    substr($_[0], $pos, $len, $_[2]);
	}
	return TRUE;
    }
    else {
	return FALSE;
    }
}

##
## int count = gsubst(string, substring, replace)
##
sub gsubst
{
    my $self = shift;
    my $code = ref $_[2] eq 'CODE' ? $_[2] : FALSE;
    my $cnt = 0;

    # Replacement is carried out from the end, then use reverse.
    for my $pos_len (reverse $self->index($_[0], $_[1], 0, 'g')) {
	if ($code) {
	    my $mat = substr($_[0], $pos_len->[0], $pos_len->[1]);
	    substr($_[0], $pos_len->[0], $pos_len->[1], $code->($mat));
	} else {
	    substr($_[0], $pos_len->[0], $pos_len->[1], $_[2]);
	}
	$cnt++;
    }
    return $cnt;
}

a570 3
  # If %tailoring is false (i.e. empty),
  # $Collator should do the default collation.

a572 4
This module is an implementation
of Unicode Technical Standard #10 (UTS #10)
"Unicode Collation Algorithm."

d578 1
a578 2
      UCA_Version => $UCA_Version,
      alternate => $alternate, # deprecated: use of 'variable' is recommended.
d581 1
a581 1
      hangul_terminator => $term_primary_weight,
a585 1
      normalization  => $normalization_form,
a593 1
      variable => $variable,
d595 2
d600 15
a614 1
=item UCA_Version
d616 1
a616 3
If the tracking version number of the older UCA is given,
the older behavior of that tracking version is emulated on collating.
If omitted, the return value of C<UCA_Version()> is used.
d618 3
a620 1
The supported tracking version: 8, 9, or 11.
d622 2
a623 2
B<This parameter may be removed in the future version,
as switching the algorithm would affect the performance.>
d627 1
a627 1
-- see 3.1.2 French Accents, UTS #10.
d636 1
a636 1
-- see 3.1 Linguistic Features; 3.2.1 File Format, UTS #10.
d638 1
a638 4
If the same character (or a sequence of characters) exists
in the collation element table through C<table>,
mapping to collation elements is overrided.
If it does not exist, the mapping is defined additionally.
a645 33
B<NOTE:> The code point in the UCA file format (before C<';'>)
B<must> be a Unicode code point, but not a native code point.
So C<0063> must always denote C<U+0063>,
but not a character of C<"\x63">.

=item hangul_terminator

-- see Condition B.2. in 7.1.4 Trailing Weights, UTS #10.

If a true value is given (non-zero but should be positive),
it will be added as a terminator primary weight to the end of
every standard Hangul syllable. Secondary and any higher weights
for terminator are set to zero.
If the value is false or C<hangul_terminator> key does not exist,
insertion of terminator weights will not be performed.

Boundaries of Hangul syllables are determined
according to conjoining Jamo behavior in F<the Unicode Standard>
and F<HangulSyllableType.txt>.

B<Implementation Note:>
(1) For expansion mapping (Unicode character mapped
to a sequence of collation elements), a terminator will not be added
between collation elements, even if Hangul syllable boundary exists there.
Addition of terminator is restricted to the next position
to the last collation element.

(2) Non-conjoining Hangul letters
(Compatibility Jamo, halfwidth Jamo, and enclosed letters) are not
automatically terminated with a terminator primary weight.
These characters may need terminator included in a collation element
table beforehand.

d650 1
a650 1
-- see Completely Ignorable, 3.2.2 Variable Weighting, UTS #10.
d652 3
a654 2
Makes the entry in the table completely ignorable;
i.e. as if the weights were zero at all level.
d661 1
a661 1
-- see 4.3 Form a sort key for each string, UTS #10.
d669 1
a669 1
  Level 4: tie-breaking (e.g. in the case when variable is 'shifted')
d677 1
a677 1
-- see 4.1 Normalize each input string, UTS #10.
d682 1
a682 5
A form name C<Unicode::Normalize::normalize()> accepts will be applied
as C<$normalization_form>.
Acceptable names include C<'NFD'>, C<'NFC'>, C<'NFKD'>, and C<'NFKC'>.
See C<Unicode::Normalize::normalize()> for detail.
If omitted, C<'NFD'> is used.
d684 4
a687 1
C<normalization> is performed after C<preprocess> (if defined).
d689 1
a689 2
Furthermore, special values, C<undef> and C<"prenormalized">, can be used,
though they are not concerned with C<Unicode::Normalize::normalize()>.
d691 1
a691 2
If C<undef> (not a string C<"undef">) is passed explicitly
as the value for this key,
a693 15
Under C<(normalization =E<gt> undef)>, only contiguous contractions
are resolved; e.g. C<A-cedilla-ring> would be primary equal to C<A>,
even if C<A-ring> (and C<A-ring-cedilla>) is ordered after C<Z>.
In this point,
C<(normalization =E<gt> undef, preprocess =E<gt> sub { NFD(shift) })>
B<is not> equivalent to C<(normalization =E<gt> 'NFD')>.

In the case of C<(normalization =E<gt> "prenormalized")>,
any normalization is not performed, but
non-contiguous contractions with combining characters are performed.
Therefore
C<(normalization =E<gt> 'prenormalized', preprocess =E<gt> sub { NFD(shift) })>
B<is> equivalent to C<(normalization =E<gt> 'NFD')>.
If source strings are finely prenormalized,
C<(normalization =E<gt> 'prenormalized')> may save time for normalization.
d695 1
a695 2
Except C<(normalization =E<gt> undef)>,
B<Unicode::Normalize> is required (see also B<CAVEAT>).
d699 1
a699 6
-- see 7.1 Derived Collation Elements, UTS #10.

By default, CJK Unified Ideographs are ordered in Unicode codepoint order
(but C<CJK Unified Ideographs> [C<U+4E00> to C<U+9FA5>]  are lesser than
C<CJK Unified Ideographs Extension> [C<U+3400> to C<U+4DB5> and
C<U+20000> to C<U+2A6D6>].
d701 3
a703 1
Through C<overrideCJK>, ordering of CJK Unified Ideographs can be overrided.
d725 1
a725 1
in table or C<entry> is still valid.
d729 1
a729 1
-- see 7.1 Derived Collation Elements, UTS #10.
d734 1
a734 1
This tag works like C<overrideCJK>, so see there for examples.
d744 1
a744 1
in table or C<entry> is still valid.
d748 1
a748 1
-- see 5.1 Preprocessing, UTS #10.
d759 1
a759 1
           return $str;
a761 2
C<preprocess> is performed before C<normalization> (if defined).

d764 1
a764 1
-- see 3.1.3 Rearrangement, UTS #10.
a774 3
B<According to the version 9 of UCA, this parameter shall not be used;
but it is not warned at present.>

d777 1
a777 1
-- see 3.2 Default Unicode Collation Element Table, UTS #10.
d779 2
a780 5
You can use another collation element table if desired.
The table file must be put into a directory
where F<Unicode/Collate.pm> is installed.
E.g. in F<perl/lib/Unicode/Collate> directory
when you have F<perl/lib/Unicode/Collate.pm>.
d782 1
a782 1
By default, the filename F<"allkeys.txt"> is used.
d785 1
a785 1
no file is read (but you can define collation elements via C<entry>).
d806 1
a806 1
-- see 6.3.4 Reducing the Repertoire, UTS #10.
d822 1
a822 1
-- see 6.6 Case Comparisons; 7.3.1 Tertiary Weight Table, UTS #10.
d831 4
a834 36
must occur in level 3, and their weights at level 3
must be same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which violate this requirement,
these tags don't work validly.

=item variable

=item alternate

-- see 3.2.2 Variable Weighting, UTS #10.

(the title in UCA version 8: Alternate Weighting)

This key allows to variable weighting for variable collation elements,
which are marked with an ASTERISK in the table
(NOTE: Many punction marks and symbols are variable in F<allkeys.txt>).

   variable => 'blanked', 'non-ignorable', 'shifted', or 'shift-trimmed'.

These names are case-insensitive.
By default (if specification is omitted), 'shifted' is adopted.

   'Blanked'        Variable elements are made ignorable at levels 1 through 3;
                    considered at the 4th level.

   'Non-ignorable'  Variable elements are not reset to ignorable.

   'Shifted'        Variable elements are made ignorable at levels 1 through 3
                    their level 4 weight is replaced by the old level 1 weight.
                    Level 4 weight for Non-Variable elements is 0xFFFF.

   'Shift-Trimmed'  Same as 'shifted', but all FFFF's at the 4th level
                    are trimmed.

For backward compatibility, C<alternate> can be used as an alias
for C<variable>.
d875 1
a875 1
-- see 4.3 Form a sort key for each string, UTS #10.
d890 4
d898 3
a900 3
   # output:
   # [0B67 0A65 0B7F 0B03 | 0020 0020 0020 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF]
   #  Level 1               Level 2               Level 3               Level 4
d902 1
a902 1
    (If C<UCA_Version> is 8, the output is slightly different.)
d904 1
a904 18
=back

=head2 Methods for Searching

B<DISCLAIMER:> If C<preprocess> or C<normalization> tag is true
for C<$Collator>, calling these methods (C<index>, C<match>, C<gmatch>,
C<subst>, C<gsubst>) is croaked,
as the position and the length might differ
from those on the specified string.
(And C<rearrange> and C<hangul_terminator> tags are neglected.)

The C<match>, C<gmatch>, C<subst>, C<gsubst> methods work
like C<m//>, C<m//g>, C<s///>, C<s///g>, respectively,
but they are not aware of any pattern, but only a literal substring.

=over 4

=item C<$position = $Collator-E<gt>index($string, $substring[, $position])>
d906 1
a906 1
=item C<($position, $length) = $Collator-E<gt>index($string, $substring[, $position])>
d913 10
d930 2
a931 3
                                     # (normalization => undef) is REQUIRED.
  my $str = "Ich mu studieren Perl.";
  my $sub = "MSS";
d937 2
a938 72
and get C<"mu"> in C<$match> since C<"mu">
is primary equal to C<"MSS">. 

=item C<$match_ref = $Collator-E<gt>match($string, $substring)>

=item C<($match)   = $Collator-E<gt>match($string, $substring)>

If C<$substring> matches a part of C<$string>, in scalar context, returns
B<a reference to> the first occurrence of the matching part
(C<$match_ref> is always true if matches,
since every reference is B<true>);
in list context, returns the first occurrence of the matching part.

If C<$substring> does not match any part of C<$string>,
returns C<undef> in scalar context and
an empty list in list context.

e.g.

    if ($match_ref = $Collator->match($str, $sub)) { # scalar context
	print "matches [$$match_ref].\n";
    } else {
	print "doesn't match.\n";
    }

     or 

    if (($match) = $Collator->match($str, $sub)) { # list context
	print "matches [$match].\n";
    } else {
	print "doesn't match.\n";
    }

=item C<@@match = $Collator-E<gt>gmatch($string, $substring)>

If C<$substring> matches a part of C<$string>, returns
all the matching parts (or matching count in scalar context).

If C<$substring> does not match any part of C<$string>,
returns an empty list.

=item C<$count = $Collator-E<gt>subst($string, $substring, $replacement)>

If C<$substring> matches a part of C<$string>,
the first occurrence of the matching part is replaced by C<$replacement>
(C<$string> is modified) and return C<$count> (always equals to C<1>).

C<$replacement> can be a C<CODEREF>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to C<s/(..)/$coderef-E<gt>($1)/e>).

=item C<$count = $Collator-E<gt>gsubst($string, $substring, $replacement)>

If C<$substring> matches a part of C<$string>,
all the occurrences of the matching part is replaced by C<$replacement>
(C<$string> is modified) and return C<$count>.

C<$replacement> can be a C<CODEREF>,
taking the matching part as an argument,
and returning a string to replace the matching part
(a bit similar to C<s/(..)/$coderef-E<gt>($1)/eg>).

e.g.

  my $Collator = Unicode::Collate->new( normalization => undef, level => 1 );
                                     # (normalization => undef) is REQUIRED.
  my $str = "Camel ass came\x{301}l CAMEL horse cAm\0E\0L...";
  $Collator->gsubst($str, "camel", sub { "<b>$_[0]</b>" });

  # now $str is "<b>Camel</b> ass <b>came\x{301}l</b> <b>CAMEL</b> horse <b>cAm\0E\0L</b>...";
  # i.e., all the camels are made bold-faced.
d946 1
a946 23
=item C<%old_tailoring = $Collator-E<gt>change(%new_tailoring)>

Change the value of specified keys and returns the changed part.

    $Collator = Unicode::Collate->new(level => 4);

    $Collator->eq("perl", "PERL"); # false

    %old = $Collator->change(level => 2); # returns (level => 4).

    $Collator->eq("perl", "PERL"); # true

    $Collator->change(%old); # returns (level => 2).

    $Collator->eq("perl", "PERL"); # false

Not all C<(key,value)>s are allowed to be changed.
See also C<@@Unicode::Collate::ChangeOK> and C<@@Unicode::Collate::ChangeNG>.

In the scalar context, returns the modified collator
(but it is B<not> a clone from the original).

    $Collator->change(level => 2)->eq("perl", "PERL"); # true
d948 2
a949 1
    $Collator->eq("perl", "PERL"); # true; now max level is 2nd.
d951 1
a951 1
    $Collator->change(level => 4)->eq("perl", "PERL"); # false
d953 2
a954 14
=item C<$version = $Collator-E<gt>version()>

Returns the version number (a string) of the Unicode Standard
which the C<table> file used by the collator object is based on.
If the table does not include a version line (starting with C<@@version>),
returns C<"unknown">.

=item C<UCA_Version()>

Returns the tracking version number of UTS #10 this module consults.

=item C<Base_Unicode_Version()>

Returns the version number of UTS #10 this module consults.
d962 11
d982 1
a982 3
-- see 6.5 Avoiding Normalization, UTS #10.

=head2 Conformance Test
d984 1
a984 3
The Conformance Test for the UCA is provided
in L<http://www.unicode.org/reports/tr10/CollationTest.html>
and L<http://www.unicode.org/reports/tr10/CollationTest.zip>
d986 5
a990 4
For F<CollationTest_SHIFTED.txt>,
a collator via C<Unicode::Collate-E<gt>new( )> should be used;
for F<CollationTest_NON_IGNORABLE.txt>, a collator via
C<Unicode::Collate-E<gt>new(variable =E<gt> "non-ignorable", level =E<gt> 3)>.
d992 1
a992 1
B<Unicode::Normalize is required to try The Conformance Test.>
d996 1
a996 1
SADAHIRO Tomoyuki, <SADAHIRO@@cpan.org>
d1000 1
a1000 1
  Copyright(C) 2001-2003, SADAHIRO Tomoyuki. Japan. All rights reserved.
d1009 1
a1009 7
=item Unicode Collation Algorithm - UTS #10

L<http://www.unicode.org/reports/tr10/>

=item The Default Unicode Collation Element Table (DUCET)

L<http://www.unicode.org/reports/tr10/allkeys.txt>
d1011 1
a1011 1
=item The conformance test for the UCA
d1013 1
a1013 1
L<http://www.unicode.org/reports/tr10/CollationTest.html>
d1015 1
a1015 1
L<http://www.unicode.org/reports/tr10/CollationTest.zip>
d1017 1
a1017 1
=item Hangul Syllable Type
d1019 1
a1019 1
http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt
d1021 1
a1021 1
=item Unicode Normalization Forms - UAX #15
d1023 1
a1023 1
L<http://www.unicode.org/reports/tr15/>
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@a14 2
no warnings 'utf8';

d17 1
a17 1
our $VERSION = '0.33';
d50 6
d188 5
a192 7
    my $key   = shift; # 'level' or 'backwards'
    MinLevel <= $level or croak sprintf
	"Illegal level %d (in value for key '%s') lower than %d.",
	    $level, $key, MinLevel;
    $level <= MaxLevel or croak sprintf
	"Unsupported level %d (in value for key '%s') higher than %d.",
	    $level, $key, MaxLevel;
d209 1
a209 1
				$self->{alternateTable} || 'shifted';
d283 1
a283 1
    $self->{overrideHangul} = FALSE
d285 1
a285 1
    $self->{overrideCJK} = FALSE
d301 1
d303 1
a303 1
    my $filepath = File::Spec->catfile($Path, $self->{table});
d309 19
a327 2
	unless (s/^\s*\@@//) {
	    $self->parseEntry($_);
d330 1
a330 19

	if (/^version\s*(\S*)/) {
	    $self->{versionTable} ||= $1;
	}
	elsif (/^variable\s+(\S*)/) { # since UTS #10-9
	    $self->{variableTable} ||= $1;
	}
	elsif (/^alternate\s+(\S*)/) { # till UTS #10-8
	    $self->{alternateTable} ||= $1;
	}
	elsif (/^backwards\s+(\S*)/) {
	    push @@{ $self->{backwardsTable} }, $1;
	}
	elsif (/^forwards\s+(\S*)/) { # parhaps no use
	    push @@{ $self->{forwardsTable} }, $1;
	}
	elsif (/^rearrange\s+(.*)/) { # (\S*) is NG
	    push @@{ $self->{rearrangeTable} }, _getHexArray($1);
	}
d408 1
a408 1
## VCE = _varCE(variable term, VCE)
d410 1
a410 1
sub _varCE
d412 13
a424 18
    my $vbl = shift;
    my $vce = shift;
    if ($vbl eq 'non-ignorable') {
	return $vce;
    }
    my ($var, @@wt) = unpack VCE_TEMPLATE, $vce;

    if ($var) {
	return pack(VCE_TEMPLATE, $var, 0, 0, 0,
		$vbl eq 'blanked' ? $wt[3] : $wt[0]);
    }
    elsif ($vbl eq 'blanked') {
	return $vce;
    }
    else {
	return pack(VCE_TEMPLATE, $var, @@wt[0..2],
	    $vbl eq 'shifted' && $wt[0]+$wt[1]+$wt[2] ? Shift4Wt : 0);
    }
d494 5
a498 4
    # To remove a character marked as a completely ignorable.
    for (my $i = 0; $i < @@src; $i++) {
	$src[$i] = undef
	    if _isIllegal($src[$i]) || ($ver9 && $ign->{ $src[$i] });
d502 3
a505 2
	next if ! defined $jcps;
	my $i_orig = $i;
d551 3
a553 2
	    for (; $i + 1 < @@src; $i++) {
		last if defined $src[$i + 1];
d564 1
a564 1
## list of VCE = getWt(JCPS)
a569 1
    my $vbl  = $self->{variable};
d574 1
a574 1
    return map(_varCE($vbl, $_), @@{ $map->{$u} })
d616 1
a616 1
	return map _varCE($vbl, $_), @@hangulCE;
d622 1
a622 1
	return map _varCE($vbl, $_),
d630 1
a630 1
	return map _varCE($vbl, $_), $der->($u);
d644 4
a647 1
    my $v2i  = $ver9 && $self->{variable} ne 'non-ignorable';
a648 1
    my @@buf; # weight arrays
d662 1
a662 1
		push @@buf, $self->getWtHangulTerm();
d666 1
a666 1
	    push @@buf, $self->getWt($jcps);
d669 1
a669 1
	    and push @@buf, $self->getWtHangulTerm();
d673 1
a673 1
	    push @@buf, $self->getWt($jcps);
d677 3
a679 11
    # make sort key
    my @@ret = ([],[],[],[]);
    my $last_is_variable;

    foreach my $vwt (@@buf) {
	my($var, @@wt) = unpack(VCE_TEMPLATE, $vwt);
	if ($v2i) {
	    if ($var) {
		$last_is_variable = TRUE;
	    }
	    elsif (!$wt[0]) { # ignorable
d681 2
a682 3
	    }
	    else {
		$last_is_variable = FALSE;
d685 9
a693 2
	foreach my $v (0..$lev-1) {
	    0 < $wt[$v] and push @@{ $ret[$v] }, $wt[$v];
d775 1
a775 1
sub getWtHangulTerm {
d777 2
a778 2
    return _varCE($self->{variable},
	pack(VCE_TEMPLATE, NON_VAR, $self->{hangul_terminator}, 0,0,0));
d804 1
a804 1
sub _isIllegal {
d891 3
a893 2
    $len < $pos
	and return wantarray ? () : NOMATCHPOS;
d895 4
a898 3
    @@$strE
	or return wantarray ? () : NOMATCHPOS;

d901 3
a903 4
    my $last_is_variable;
    for my $vwt (map $self->getWt($_), @@$subE) {
	my($var, @@wt) = unpack(VCE_TEMPLATE, $vwt);
	my $to_be_pushed = _nonIgnorAtLevel(\@@wt,$lev);
d906 1
a906 4
	    if ($var) {
		$last_is_variable = TRUE;
	    }
	    elsif (!$wt[0]) { # ignorable
d908 2
a909 3
	    }
	    else {
		$last_is_variable = FALSE;
d913 2
a914 2
	if (@@subWt && !$var && !$wt[0]) {
	    push @@{ $subWt[-1] }, \@@wt if $to_be_pushed;
d916 2
a917 1
	    push @@subWt, [ \@@wt ];
d924 2
a925 1
    $last_is_variable = FALSE; # reuse
d931 2
a932 3
	    for my $vwt ($self->getWt($strE->[$i][0])) {
		my($var, @@wt) = unpack(VCE_TEMPLATE, $vwt);
		my $to_be_pushed = _nonIgnorAtLevel(\@@wt,$lev);
d935 1
a935 4
		    if ($var) {
			$last_is_variable = TRUE;
		    }
		    elsif (!$wt[0]) { # ignorable
d937 2
a938 3
		    }
		    else {
			$last_is_variable = FALSE;
d942 2
a943 2
		if (@@strWt && !$var && !$wt[0]) {
		    push @@{ $strWt[-1] }, \@@wt if $to_be_pushed;
d946 2
a947 1
		    push @@strWt, [ \@@wt ];
d1147 5
a1151 15
    entry => <<'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
0063 0068 ; [.0E6A.0020.0002.0063] # ch
0043 0068 ; [.0E6A.0020.0007.0043] # Ch
0043 0048 ; [.0E6A.0020.0008.0043] # CH
006C 006C ; [.0F4C.0020.0002.006C] # ll
004C 006C ; [.0F4C.0020.0007.004C] # Ll
004C 004C ; [.0F4C.0020.0008.004C] # LL
006E 0303 ; [.0F7B.0020.0002.006E] # n-tilde
004E 0303 ; [.0F7B.0020.0008.004E] # N-tilde
ENTRY

    entry => <<'ENTRY', # for DUCET v4.0.0 (allkeys-4.0.0.txt)
00E6 ; [.0E33.0020.0002.00E6][.0E8B.0020.0002.00E6] # ae ligature as <a><e>
00C6 ; [.0E33.0020.0008.00C6][.0E8B.0020.0008.00C6] # AE ligature as <A><E>
ENTRY
d1154 1
a1154 2
B<must> be a Unicode code point (defined as hexadecimal),
but not a native code point.
a1157 15
Weighting may vary depending on collation element table.
So ensure the weights defined in C<entry> will be consistent with
those in the collation element table loaded via C<table>.

In DUCET v4.0.0, primary weight of C<C> is C<0E60>
and that of C<D> is C<0E6D>. So setting primary weight of C<CH> to C<0E6A>
(as a value between C<0E60> and C<0E6D>)
makes ordering as C<C E<lt> CH E<lt> D>.
Exactly speaking DUCET already has some characters between C<C> and C<D>:
C<small capital C> (C<U+1D04>) with primary weight C<0E64>,
C<c-hook/C-hook> (C<U+0188/U+0187>) with C<0E65>,
and C<c-curl> (C<U+0255>) with C<0E69>.
Then primary weight C<0E6A> for C<CH> makes C<CH>
ordered between C<c-curl> and C<D>.

d1235 4
a1238 4
if any normalization is not desired). Under C<(normalization =E<gt> undef)>,
only contiguous contractions are resolved;
e.g. even if C<A-ring> (and C<A-ring-cedilla>) is ordered after C<Z>,
C<A-cedilla-ring> would be primary equal to C<A>.
d1292 1
a1292 2
By default, Hangul Syllables are decomposed into Hangul Jamo,
even if C<(normalization =E<gt> undef)>.
d1298 2
a1299 2
NFD, NFKD, and FCD are not appropriate,
since they will decompose Hangul Syllables before overriding.
d1347 3
a1349 2
where F<Unicode/Collate.pm> is installed; e.g. into
F<perl/lib/Unicode/Collate/> if you have F<perl/lib/Unicode/Collate.pm>.
d1351 1
a1351 1
By default, the filename F<allkeys.txt> is used.
d1425 1
a1425 1
   'Non-Ignorable'  Variable elements are not reset to ignorable.
d1683 3
a1685 2
The Conformance Test for the UCA is available
under L<http://www.unicode.org/Public/UCA/>.
d1696 1
a1696 1
SADAHIRO Tomoyuki <SADAHIRO@@cpan.org>
d1715 1
a1715 1
L<http://www.unicode.org/Public/UCA/latest/allkeys.txt>
d1719 1
a1719 1
L<http://www.unicode.org/Public/UCA/latest/CollationTest.html>
d1721 1
a1721 1
L<http://www.unicode.org/Public/UCA/latest/CollationTest.zip>
d1725 1
a1725 1
L<http://www.unicode.org/Public/UNIDATA/HangulSyllableType.txt>
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d17 3
a19 1
our $VERSION = '0.40';
d22 8
a29 2
my @@Path = qw(Unicode Collate);
my $KeyFile = "allkeys.txt";
d39 1
a39 1
my $CVgetCombinClass;
d107 1
a107 1
my $DefaultRearrange = [ 0x0E40..0x0E44, 0x0EC0..0x0EC4 ];
d141 1
a141 1
    derivCode normCode rearrangeHash
a147 1
# The hash key 'L3_ignorable' is deleted at v 0.40.
d275 1
a275 3
	while ($self->{entry} =~ /([^\n]+)/g) {
	    $self->parseEntry($1);
	}
d300 3
a302 8
    my($f, $fh);
    foreach my $d (@@INC) {
	$f = File::Spec->catfile($d, @@Path, $self->{table});
	last if open($fh, $f);
	$f = undef;
    }
    defined $f
	or croak "$PACKAGE: $self->{table} is not found in @@INC";
d304 1
a304 1
    while (<$fh>) {
d330 1
a330 1
    close $fh;
d390 1
a390 1
    $self->{mapping}{$entry} = $is_L3_ignorable ? [] : \@@key;
d396 6
d464 1
d500 1
a500 2
	    if _isIllegal($src[$i]) || ($ver9 &&
		$map->{ $src[$i] } && @@{ $map->{ $src[$i] } } == 0);
d1160 2
a1161 4
00F1      ; [.0F7B.0020.0002.00F1] # n-tilde
006E 0303 ; [.0F7B.0020.0002.00F1] # n-tilde
00D1      ; [.0F7B.0020.0008.00D1] # N-tilde
004E 0303 ; [.0F7B.0020.0008.00D1] # N-tilde
d1379 3
d1383 1
a1383 5
The table file should locate in the F<Unicode/Collate> directory
on C<@@INC>. Say, if the filename is F<Foo.txt>
the table file is searched as F<Unicode/Collate/Foo.txt> in <@@INC>.

By default, F<allkeys.txt> (as the filename of DUCET) is used.
a1418 4
ex. Collation weights for beyond-BMP characters are not stored in object:

    undefChar => qr/[^\0-\x{fffd}]/,

d1731 1
a1731 1
  Copyright(C) 2001-2004, SADAHIRO Tomoyuki. Japan. All rights reserved.
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d17 1
a17 1
our $VERSION = '0.52';
d79 1
a79 1
use constant Hangul_VIni   => 0x1160; # from Vowel Filler
d81 1
a81 1
use constant Hangul_TBase  => 0x11A7; # from "no-final" codepoint
a90 1
use constant CJK_UidF41    => 0x9FBB;
d98 1
d101 1
a101 1
sub UCA_Version { "14" }
d103 1
a103 1
sub Base_Unicode_Version { "4.1.0" }
d112 1
a112 1
    return unpack('U*', shift(@@_).pack('U*'));
d171 1
a171 1
    $self->checkCollator();
a189 1
   14 => \&_derivCE_14,
d203 1
a203 1
	or croak "$PACKAGE unknown variable parameter name: $self->{variable}";
d265 1
a265 1
    $self->read_table() if defined $self->{table};
d282 1
a282 2
    $self->{rearrange} = $self->{rearrangeTable} ||
	($self->{UCA_Version} <= 11 ? $DefaultRearrange : [])
d287 1
a287 1
    $self->checkCollator();
d301 2
a302 4
    if (!defined $f) {
	$f = File::Spec->catfile(@@Path, $self->{table});
	croak("$PACKAGE: Can't locate $f in \@@INC (\@@INC contains: @@INC)");
    }
d304 4
a307 4
    while (my $line = <$fh>) {
	next if $line =~ /^\s*#/;
	unless ($line =~ s/^\s*\@@//) {
	    $self->parseEntry($line);
d311 1
a311 2
	# matched ^\s*\@@
	if ($line =~ /^version\s*(\S*)/) {
d314 1
a314 1
	elsif ($line =~ /^variable\s+(\S*)/) { # since UTS #10-9
d317 1
a317 1
	elsif ($line =~ /^alternate\s+(\S*)/) { # till UTS #10-8
d320 1
a320 1
	elsif ($line =~ /^backwards\s+(\S*)/) {
d323 1
a323 1
	elsif ($line =~ /^forwards\s+(\S*)/) { # parhaps no use
d326 1
a326 1
	elsif ($line =~ /^rearrange\s+(.*)/) { # (\S*) is NG
d383 3
a385 3
	    if $wt[0] || $wt[1] || $wt[2];
	# Conformance Test for 3.1.1 and 4.0.0 shows Level 3 ignorable
	# is completely ignorable.
d458 1
a458 1
    my $ver9 = $self->{UCA_Version} >= 9 && $self->{UCA_Version} <= 11;
d490 1
a490 1
    # remove a code point marked as a completely ignorable.
d499 1
a499 9

	# skip removed code point
	if (! defined $jcps) {
	    if ($wLen && @@buf) {
		$buf[-1][2] = $i + 1;
	    }
	    next;
	}

d502 1
a502 2
	# find contraction
	if ($max->{$jcps}) {
d545 3
a547 4
	# skip completely ignorable
	if ($map->{$jcps} && @@{ $map->{$jcps} } == 0) {
	    if ($wLen && @@buf) {
		$buf[-1][2] = $i + 1;
a548 1
	    next;
d613 3
a615 1
    elsif (_isUIdeo($u, $self->{UCA_Version})) {
d620 2
a621 2
		: defined $cjk && $self->{UCA_Version} <= 8 && $u < 0x10000
		    ? _uideoCE_8($u)
d638 2
a639 2
    my $v2i  = $self->{UCA_Version} >= 9 &&
		$self->{variable} ne 'non-ignorable';
a675 2

	# "Ignorable (L1, L2) after Variable" since track. v. 9
d694 5
a698 5
	foreach my $w (@@{ $ret[2] }) {
	    if    (0x8 <= $w && $w <= 0xC) { $w -= 6 } # lower
	    elsif (0x2 <= $w && $w <= 0x6) { $w += 6 } # upper
	    elsif ($w == 0x1C)             { $w += 1 } # square upper
	    elsif ($w == 0x1D)             { $w -= 1 } # square lower
d702 3
a704 3
	foreach my $w (@@{ $ret[2] }) {
	    if    (0x0F <= $w && $w <= 0x13) { $w -= 2 } # katakana
	    elsif (0x0D <= $w && $w <= 0x0E) { $w += 5 } # hiragana
a742 17
sub _derivCE_14 {
    my $u = shift;
    my $base =
	(CJK_UidIni  <= $u && $u <= CJK_UidF41)
	    ? 0xFB40 : # CJK
	(CJK_ExtAIni <= $u && $u <= CJK_ExtAFin ||
	 CJK_ExtBIni <= $u && $u <= CJK_ExtBFin)
	    ? 0xFB80   # CJK ext.
	    : 0xFBC0;  # others

    my $aaaa = $base + ($u >> 15);
    my $bbbb = ($u & 0x7FFF) | 0x8000;
    return
	pack(VCE_TEMPLATE, NON_VAR, $aaaa, Min2Wt, Min3Wt, $u),
	pack(VCE_TEMPLATE, NON_VAR, $bbbb,      0,      0, $u);
}

a768 17
sub _uideoCE_8 {
    my $u = shift;
    return pack(VCE_TEMPLATE, NON_VAR, $u, Min2Wt, Min3Wt, $u);
}

sub _isUIdeo {
    my ($u, $uca_vers) = @@_;
    return(
	(CJK_UidIni <= $u &&
	    ($uca_vers >= 14 ? ( $u <= CJK_UidF41) : ($u <= CJK_UidFin)))
		||
	(CJK_ExtAIni <= $u && $u <= CJK_ExtAFin)
		||
	(CJK_ExtBIni <= $u && $u <= CJK_ExtBFin)
    );
}

d788 4
a791 4
    my $si = $code - Hangul_SBase;
    my $li = int( $si / Hangul_NCount);
    my $vi = int(($si % Hangul_NCount) / Hangul_TCount);
    my $ti =      $si % Hangul_TCount;
d793 3
a795 3
	Hangul_LBase + $li,
	Hangul_VBase + $vi,
	$ti ? (Hangul_TBase + $ti) : (),
d877 2
a878 2
    my $v2i  = $self->{UCA_Version} >= 9 &&
		$self->{variable} ne 'non-ignorable';
d899 1
a899 2
	# "Ignorable (L1, L2) after Variable" since track. v. 9
	if ($v2i) {
d931 1
a931 2
		# "Ignorable (L1, L2) after Variable" since track. v. 9
		if ($v2i) {
d1086 3
a1088 2
This module is an implementation of Unicode Technical Standard #10
(a.k.a. UTS #10) - Unicode Collation Algorithm (a.k.a. UCA).
d1120 2
a1121 2
If the tracking version number of UCA is given,
behavior of that tracking version is emulated on collating.
a1122 10
C<UCA_Version()> should return the latest tracking version supported.

The supported tracking version: 8, 9, 11, or 14.

     UCA       Unicode Standard         DUCET (@@version)
     ---------------------------------------------------
      8              3.1                3.0.1 (3.0.1d9)
      9     3.1 with Corrigendum 3      3.1.1 (3.1.1)
     11              4.0                4.0.0 (4.0.0)
     14             4.1.0               4.1.0 (4.1.0)
d1124 1
a1124 3
Note: Recent UTS #10 renames "Tracking Version" to "Revision."

=item alternate
d1126 2
a1127 4
-- see 3.2.2 Alternate Weighting, version 8 of UTS #10

For backward compatibility, C<alternate> (old name) can be used
as an alias for C<variable>.
d1188 1
a1188 1
-- see 7.1.4 Trailing Weights, UTS #10.
d1214 2
d1218 1
a1218 3
=item ignoreName

-- see 3.2.2 Variable Weighting, UTS #10.
a1222 5
Through C<ignoreChar>, any character matching C<qr/$ignoreChar/>
will be ignored. Through C<ignoreName>, any character whose name
(given in the C<table> file as a comment) matches C<qr/$ignoreName/>
will be ignored.

a1225 13
=item katakana_before_hiragana

-- see 7.3.1 Tertiary Weight Table, UTS #10.

By default, hiragana is before katakana.
If the parameter is made true, this is reversed.

B<NOTE>: This parameter simplemindedly assumes that any hiragana/katakana
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which violate this requirement,
this parameter does not work validly.

d1228 1
a1228 1
-- see 4.3 Form Sort Key, UTS #10.
d1244 1
a1244 1
-- see 4.1 Normalize, UTS #10.
d1288 3
a1290 4
but C<CJK Unified Ideographs> (if C<UCA_Version> is 8 to 11, its range is
C<U+4E00..U+9FA5>; if C<UCA_Version> is 14, its range is C<U+4E00..U+9FBB>)
are lesser than C<CJK Unified Ideographs Extension> (its range is
C<U+3400..U+4DB5> and C<U+20000..U+2A6D6>).
d1324 1
a1324 1
This parameter works like C<overrideCJK>, so see there for examples.
d1359 1
a1359 1
If C<UCA_Version> is equal to or lesser than 11, default is:
d1363 3
a1365 4
If you want to disallow any rearrangement, pass C<undef> or C<[]>
(a reference to empty list) as the value for this key.

If C<UCA_Version> is equal to 14, default is C<[]> (i.e. no rearrangement).
d1377 2
a1378 2
on C<@@INC>. Say, if the filename is F<Foo.txt>,
the table file is searched as F<Unicode/Collate/Foo.txt> in C<@@INC>.
a1380 2
If you will prepare your own table file, any name other than F<allkeys.txt>
may be better to avoid namespace conflict.
d1400 1
a1400 2
If C<ignoreName> or C<undefName> is used, character names should be
specified as a comment (following C<#>) on each line.
a1403 2
=item undefName

a1415 5
Through C<undefChar>, any character matching C<qr/$undefChar/>
will be undefined. Through C<undefName>, any character whose name
(given in the C<table> file as a comment) matches C<qr/$undefName/>
will be undefined.

d1420 2
d1424 4
a1427 1
-- see 6.6 Case Comparisons, UTS #10.
d1429 1
a1429 2
By default, lowercase is before uppercase.
If the parameter is made true, this is reversed.
d1431 6
a1436 5
B<NOTE>: This parameter simplemindedly assumes that any lowercase/uppercase
distinctions must occur in level 3, and their weights at level 3 must be
same as those mentioned in 7.3.1, UTS #10.
If you define your collation elements which differs from this requirement,
this parameter doesn't work validly.
d1440 2
d1444 2
d1467 3
d1509 1
a1509 1
-- see 4.3 Form Sort Key, UTS #10.
a1523 3
Converts a sorting key into its representation form.
If C<UCA_Version> is 8, the output is slightly different.

d1532 2
d1538 1
a1538 1
B<DISCLAIMER:> If C<preprocess> or C<normalization> parameter is true
d1543 1
a1543 1
(And C<rearrange> and C<hangul_terminator> parameters are neglected.)
d1576 1
a1576 1
is primary equal to C<"MSS">.
d1600 1
a1600 1
     or
d1642 1
a1642 1
  my $str = "Camel donkey zebra came\x{301}l CAMEL horse cAm\0E\0L...";
d1645 1
a1645 1
  # now $str is "<b>Camel</b> donkey zebra <b>came\x{301}l</b> <b>CAMEL</b> horse <b>cAm\0E\0L</b>...";
d1699 1
a1699 13
=head1 EXPORT

No method will be exported.

=head1 INSTALL

Though this module can be used without any C<table> file,
to use this module easily, it is recommended to install a table file
in the UCA format, by copying it under the directory
<a place in @@INC>/Unicode/Collate.

The most preferable one is "The Default Unicode Collation Element Table"
(aka DUCET), available from the Unicode Consortium's website:
d1701 1
a1701 1
   http://www.unicode.org/Public/UCA/
d1703 1
a1703 1
   http://www.unicode.org/Public/UCA/latest/allkeys.txt (latest version)
d1705 2
a1706 13
If DUCET is not installed, it is recommended to copy the file
from http://www.unicode.org/Public/UCA/latest/allkeys.txt
to <a place in @@INC>/Unicode/Collate/allkeys.txt
manually.

=head1 CAVEATS

=over 4

=item Normalization

Use of the C<normalization> parameter requires the B<Unicode::Normalize>
module (see L<Unicode::Normalize>).
d1714 1
a1714 1
=item Conformance Test
d1726 5
a1730 1
=back
d1732 1
a1732 1
=head1 AUTHOR, COPYRIGHT AND LICENSE
d1734 2
a1735 11
The Unicode::Collate module for perl was written by SADAHIRO Tomoyuki,
<SADAHIRO@@cpan.org>. This module is Copyright(C) 2001-2005,
SADAHIRO Tomoyuki. Japan. All rights reserved.

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

The file Unicode/Collate/allkeys.txt was copied directly
from L<http://www.unicode.org/Public/UCA/4.1.0/allkeys.txt>.
This file is Copyright (c) 1991-2005 Unicode, Inc. All rights reserved.
Distributed under the Terms of Use in L<http://www.unicode.org/copyright.html>.
d1762 2
@


