head	1.3;
access;
symbols
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.10.0.4
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.6
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.3
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.30;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.16.26;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.47.28;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.26;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.06.25;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.45.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    locale.c
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *      A Elbereth Gilthoniel,
 *      silivren penna míriel
 *      o menel aglar elenath!
 *      Na-chaered palan-díriel
 *      o galadhremmin ennorath,
 *      Fanuilos, le linnathon
 *      nef aear, si nef aearon!
 *
 *     [p.238 of _The Lord of the Rings_, II/i: "Many Meetings"]
 */

/* utility functions for handling locale-specific stuff like what
 * character represents the decimal point.
 *
 * All C programs have an underlying locale.  Perl generally doesn't pay any
 * attention to it except within the scope of a 'use locale'.  For most
 * categories, it accomplishes this by just using different operations if it is
 * in such scope than if not.  However, various libc functions called by Perl
 * are affected by the LC_NUMERIC category, so there are macros in perl.h that
 * are used to toggle between the current locale and the C locale depending on
 * the desired behavior of those functions at the moment.  And, LC_MESSAGES is
 * switched to the C locale for outputting the message unless within the scope
 * of 'use locale'.
 */

#include "EXTERN.h"
#define PERL_IN_LOCALE_C
#include "perl.h"

#ifdef I_LANGINFO
#   include <langinfo.h>
#endif

#include "reentr.h"

#ifdef USE_LOCALE

/*
 * Standardize the locale name from a string returned by 'setlocale', possibly
 * modifying that string.
 *
 * The typical return value of setlocale() is either
 * (1) "xx_YY" if the first argument of setlocale() is not LC_ALL
 * (2) "xa_YY xb_YY ..." if the first argument of setlocale() is LC_ALL
 *     (the space-separated values represent the various sublocales,
 *      in some unspecified order).  This is not handled by this function.
 *
 * In some platforms it has a form like "LC_SOMETHING=Lang_Country.866\n",
 * which is harmful for further use of the string in setlocale().  This
 * function removes the trailing new line and everything up through the '='
 *
 */
STATIC char *
S_stdize_locale(pTHX_ char *locs)
{
    const char * const s = strchr(locs, '=');
    bool okay = TRUE;

    PERL_ARGS_ASSERT_STDIZE_LOCALE;

    if (s) {
	const char * const t = strchr(s, '.');
	okay = FALSE;
	if (t) {
	    const char * const u = strchr(t, '\n');
	    if (u && (u[1] == 0)) {
		const STRLEN len = u - s;
		Move(s + 1, locs, len, char);
		locs[len] = 0;
		okay = TRUE;
	    }
	}
    }

    if (!okay)
	Perl_croak(aTHX_ "Can't fix broken locale name \"%s\"", locs);

    return locs;
}

#endif

void
Perl_set_numeric_radix(pTHX)
{
#ifdef USE_LOCALE_NUMERIC
# ifdef HAS_LOCALECONV
    const struct lconv* const lc = localeconv();

    if (lc && lc->decimal_point) {
	if (lc->decimal_point[0] == '.' && lc->decimal_point[1] == 0) {
	    SvREFCNT_dec(PL_numeric_radix_sv);
	    PL_numeric_radix_sv = NULL;
	}
	else {
	    if (PL_numeric_radix_sv)
		sv_setpv(PL_numeric_radix_sv, lc->decimal_point);
	    else
		PL_numeric_radix_sv = newSVpv(lc->decimal_point, 0);
            if (! is_invariant_string((U8 *) lc->decimal_point, 0)
                && is_utf8_string((U8 *) lc->decimal_point, 0)
                && _is_cur_LC_category_utf8(LC_NUMERIC))
            {
		SvUTF8_on(PL_numeric_radix_sv);
            }
	}
    }
    else
	PL_numeric_radix_sv = NULL;

    DEBUG_L(PerlIO_printf(Perl_debug_log, "Locale radix is %s, ?UTF-8=%d\n",
                                          (PL_numeric_radix_sv)
                                           ? SvPVX(PL_numeric_radix_sv)
                                           : "NULL",
                                          (PL_numeric_radix_sv)
                                           ? cBOOL(SvUTF8(PL_numeric_radix_sv))
                                           : 0));

# endif /* HAS_LOCALECONV */
#endif /* USE_LOCALE_NUMERIC */
}

/* Is the C string input 'name' "C" or "POSIX"?  If so, and 'name' is the
 * return of setlocale(), then this is extremely likely to be the C or POSIX
 * locale.  However, the output of setlocale() is documented to be opaque, but
 * the odds are extremely small that it would return these two strings for some
 * other locale.  Note that VMS in these two locales includes many non-ASCII
 * characters as controls and punctuation (below are hex bytes):
 *   cntrl:  00-1F 7F 84-97 9B-9F
 *   punct:  21-2F 3A-40 5B-60 7B-7E A1-A3 A5 A7-AB B0-B3 B5-B7 B9-BD BF-CF D1-DD DF-EF F1-FD
 * Oddly, none there are listed as alphas, though some represent alphabetics
 * http://www.nntp.perl.org/group/perl.perl5.porters/2013/02/msg198753.html */
#define isNAME_C_OR_POSIX(name) ((name) != NULL                                 \
                                  && ((*(name) == 'C' && (*(name + 1)) == '\0') \
                                       || strEQ((name), "POSIX")))

void
Perl_new_numeric(pTHX_ const char *newnum)
{
#ifdef USE_LOCALE_NUMERIC

    /* Called after all libc setlocale() calls affecting LC_NUMERIC, to tell
     * core Perl this and that 'newnum' is the name of the new locale.
     * It installs this locale as the current underlying default.
     *
     * The default locale and the C locale can be toggled between by use of the
     * set_numeric_local() and set_numeric_standard() functions, which should
     * probably not be called directly, but only via macros like
     * SET_NUMERIC_STANDARD() in perl.h.
     *
     * The toggling is necessary mainly so that a non-dot radix decimal point
     * character can be output, while allowing internal calculations to use a
     * dot.
     *
     * This sets several interpreter-level variables:
     * PL_numeric_name  The underlying locale's name: a copy of 'newnum'
     * PL_numeric_local A boolean indicating if the toggled state is such
     *                  that the current locale is the program's underlying
     *                  locale
     * PL_numeric_standard An int indicating if the toggled state is such
     *                  that the current locale is the C locale.  If non-zero,
     *                  it is in C; if > 1, it means it may not be toggled away
     *                  from C.
     * Note that both of the last two variables can be true at the same time,
     * if the underlying locale is C.  (Toggling is a no-op under these
     * circumstances.)
     *
     * Any code changing the locale (outside this file) should use
     * POSIX::setlocale, which calls this function.  Therefore this function
     * should be called directly only from this file and from
     * POSIX::setlocale() */

    char *save_newnum;

    if (! newnum) {
	Safefree(PL_numeric_name);
	PL_numeric_name = NULL;
	PL_numeric_standard = TRUE;
	PL_numeric_local = TRUE;
	return;
    }

    save_newnum = stdize_locale(savepv(newnum));

    PL_numeric_standard = isNAME_C_OR_POSIX(save_newnum);
    PL_numeric_local = TRUE;

    if (! PL_numeric_name || strNE(PL_numeric_name, save_newnum)) {
	Safefree(PL_numeric_name);
	PL_numeric_name = save_newnum;
    }
    else {
	Safefree(save_newnum);
    }

    /* Keep LC_NUMERIC in the C locale.  This is for XS modules, so they don't
     * have to worry about the radix being a non-dot.  (Core operations that
     * need the underlying locale change to it temporarily). */
    set_numeric_standard();

    set_numeric_radix();

#else
    PERL_UNUSED_ARG(newnum);
#endif /* USE_LOCALE_NUMERIC */
}

void
Perl_set_numeric_standard(pTHX)
{
#ifdef USE_LOCALE_NUMERIC
    /* Toggle the LC_NUMERIC locale to C.  Most code should use the macros like
     * SET_NUMERIC_STANDARD() in perl.h instead of calling this directly.  The
     * macro avoids calling this routine if toggling isn't necessary according
     * to our records (which could be wrong if some XS code has changed the
     * locale behind our back) */

    setlocale(LC_NUMERIC, "C");
    PL_numeric_standard = TRUE;
    PL_numeric_local = isNAME_C_OR_POSIX(PL_numeric_name);
    set_numeric_radix();
    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Underlying LC_NUMERIC locale now is C\n"));

#endif /* USE_LOCALE_NUMERIC */
}

void
Perl_set_numeric_local(pTHX)
{
#ifdef USE_LOCALE_NUMERIC
    /* Toggle the LC_NUMERIC locale to the current underlying default.  Most
     * code should use the macros like SET_NUMERIC_LOCAL() in perl.h instead of
     * calling this directly.  The macro avoids calling this routine if
     * toggling isn't necessary according to our records (which could be wrong
     * if some XS code has changed the locale behind our back) */

    setlocale(LC_NUMERIC, PL_numeric_name);
    PL_numeric_standard = isNAME_C_OR_POSIX(PL_numeric_name);
    PL_numeric_local = TRUE;
    set_numeric_radix();
    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Underlying LC_NUMERIC locale now is %s\n",
                          PL_numeric_name));

#endif /* USE_LOCALE_NUMERIC */
}

/*
 * Set up for a new ctype locale.
 */
void
Perl_new_ctype(pTHX_ const char *newctype)
{
#ifdef USE_LOCALE_CTYPE

    /* Called after all libc setlocale() calls affecting LC_CTYPE, to tell
     * core Perl this and that 'newctype' is the name of the new locale.
     *
     * This function sets up the folding arrays for all 256 bytes, assuming
     * that tofold() is tolc() since fold case is not a concept in POSIX,
     *
     * Any code changing the locale (outside this file) should use
     * POSIX::setlocale, which calls this function.  Therefore this function
     * should be called directly only from this file and from
     * POSIX::setlocale() */

    dVAR;
    UV i;

    PERL_ARGS_ASSERT_NEW_CTYPE;

    /* We will replace any bad locale warning with 1) nothing if the new one is
     * ok; or 2) a new warning for the bad new locale */
    if (PL_warn_locale) {
        SvREFCNT_dec_NN(PL_warn_locale);
        PL_warn_locale = NULL;
    }

    PL_in_utf8_CTYPE_locale = _is_cur_LC_category_utf8(LC_CTYPE);

    /* A UTF-8 locale gets standard rules.  But note that code still has to
     * handle this specially because of the three problematic code points */
    if (PL_in_utf8_CTYPE_locale) {
        Copy(PL_fold_latin1, PL_fold_locale, 256, U8);
    }
    else {
        /* Assume enough space for every character being bad.  4 spaces each
         * for the 94 printable characters that are output like "'x' "; and 5
         * spaces each for "'\\' ", "'\t' ", and "'\n' "; plus a terminating
         * NUL */
        char bad_chars_list[ (94 * 4) + (3 * 5) + 1 ];

        bool check_for_problems = ckWARN_d(WARN_LOCALE); /* No warnings means
                                                            no check */
        bool multi_byte_locale = FALSE;     /* Assume is a single-byte locale
                                               to start */
        unsigned int bad_count = 0;         /* Count of bad characters */

        for (i = 0; i < 256; i++) {
            if (isUPPER_LC((U8) i))
                PL_fold_locale[i] = (U8) toLOWER_LC((U8) i);
            else if (isLOWER_LC((U8) i))
                PL_fold_locale[i] = (U8) toUPPER_LC((U8) i);
            else
                PL_fold_locale[i] = (U8) i;

            /* If checking for locale problems, see if the native ASCII-range
             * printables plus \n and \t are in their expected categories in
             * the new locale.  If not, this could mean big trouble, upending
             * Perl's and most programs' assumptions, like having a
             * metacharacter with special meaning become a \w.  Fortunately,
             * it's very rare to find locales that aren't supersets of ASCII
             * nowadays.  It isn't a problem for most controls to be changed
             * into something else; we check only \n and \t, though perhaps \r
             * could be an issue as well. */
            if (check_for_problems
                && (isGRAPH_A(i) || isBLANK_A(i) || i == '\n'))
            {
                if ((isALPHANUMERIC_A(i) && ! isALPHANUMERIC_LC(i))
                     || (isPUNCT_A(i) && ! isPUNCT_LC(i))
                     || (isBLANK_A(i) && ! isBLANK_LC(i))
                     || (i == '\n' && ! isCNTRL_LC(i)))
                {
                    if (bad_count) {    /* Separate multiple entries with a
                                           blank */
                        bad_chars_list[bad_count++] = ' ';
                    }
                    bad_chars_list[bad_count++] = '\'';
                    if (isPRINT_A(i)) {
                        bad_chars_list[bad_count++] = (char) i;
                    }
                    else {
                        bad_chars_list[bad_count++] = '\\';
                        if (i == '\n') {
                            bad_chars_list[bad_count++] = 'n';
                        }
                        else {
                            assert(i == '\t');
                            bad_chars_list[bad_count++] = 't';
                        }
                    }
                    bad_chars_list[bad_count++] = '\'';
                    bad_chars_list[bad_count] = '\0';
                }
            }
        }

#ifdef MB_CUR_MAX
        /* We only handle single-byte locales (outside of UTF-8 ones; so if
         * this locale requires than one byte, there are going to be
         * problems. */
        if (check_for_problems && MB_CUR_MAX > 1

               /* Some platforms return MB_CUR_MAX > 1 for even the "C"
                * locale.  Just assume that the implementation for them (plus
                * for POSIX) is correct and the > 1 value is spurious.  (Since
                * these are specially handled to never be considered UTF-8
                * locales, as long as this is the only problem, everything
                * should work fine */
            && strNE(newctype, "C") && strNE(newctype, "POSIX"))
        {
            multi_byte_locale = TRUE;
        }
#endif

        if (bad_count || multi_byte_locale) {
            PL_warn_locale = Perl_newSVpvf(aTHX_
                             "Locale '%s' may not work well.%s%s%s\n",
                             newctype,
                             (multi_byte_locale)
                              ? "  Some characters in it are not recognized by"
                                " Perl."
                              : "",
                             (bad_count)
                              ? "\nThe following characters (and maybe others)"
                                " may not have the same meaning as the Perl"
                                " program expects:\n"
                              : "",
                             (bad_count)
                              ? bad_chars_list
                              : ""
                            );
            /* If we are actually in the scope of the locale, output the
             * message now.  Otherwise we save it to be output at the first
             * operation using this locale, if that actually happens.  Most
             * programs don't use locales, so they are immune to bad ones */
            if (IN_LC(LC_CTYPE)) {

                /* We have to save 'newctype' because the setlocale() just
                 * below may destroy it.  The next setlocale() further down
                 * should restore it properly so that the intermediate change
                 * here is transparent to this function's caller */
                const char * const badlocale = savepv(newctype);

                setlocale(LC_CTYPE, "C");

                /* The '0' below suppresses a bogus gcc compiler warning */
                Perl_warner(aTHX_ packWARN(WARN_LOCALE), SvPVX(PL_warn_locale), 0);
                setlocale(LC_CTYPE, badlocale);
                Safefree(badlocale);
                SvREFCNT_dec_NN(PL_warn_locale);
                PL_warn_locale = NULL;
            }
        }
    }

#endif /* USE_LOCALE_CTYPE */
    PERL_ARGS_ASSERT_NEW_CTYPE;
    PERL_UNUSED_ARG(newctype);
    PERL_UNUSED_CONTEXT;
}

void
Perl__warn_problematic_locale()
{

#ifdef USE_LOCALE_CTYPE

    dTHX;

    /* Internal-to-core function that outputs the message in PL_warn_locale,
     * and then NULLS it.  Should be called only through the macro
     * _CHECK_AND_WARN_PROBLEMATIC_LOCALE */

    if (PL_warn_locale) {
        /*GCC_DIAG_IGNORE(-Wformat-security);   Didn't work */
        Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                             SvPVX(PL_warn_locale),
                             0 /* dummy to avoid compiler warning */ );
        /* GCC_DIAG_RESTORE; */
        SvREFCNT_dec_NN(PL_warn_locale);
        PL_warn_locale = NULL;
    }

#endif

}

void
Perl_new_collate(pTHX_ const char *newcoll)
{
#ifdef USE_LOCALE_COLLATE

    /* Called after all libc setlocale() calls affecting LC_COLLATE, to tell
     * core Perl this and that 'newcoll' is the name of the new locale.
     *
     * Any code changing the locale (outside this file) should use
     * POSIX::setlocale, which calls this function.  Therefore this function
     * should be called directly only from this file and from
     * POSIX::setlocale() */

    if (! newcoll) {
	if (PL_collation_name) {
	    ++PL_collation_ix;
	    Safefree(PL_collation_name);
	    PL_collation_name = NULL;
	}
	PL_collation_standard = TRUE;
	PL_collxfrm_base = 0;
	PL_collxfrm_mult = 2;
	return;
    }

    if (! PL_collation_name || strNE(PL_collation_name, newcoll)) {
	++PL_collation_ix;
	Safefree(PL_collation_name);
	PL_collation_name = stdize_locale(savepv(newcoll));
	PL_collation_standard = isNAME_C_OR_POSIX(newcoll);

	{
	  /*  2: at most so many chars ('a', 'b'). */
	  /* 50: surely no system expands a char more. */
#define XFRMBUFSIZE  (2 * 50)
	  char xbuf[XFRMBUFSIZE];
	  const Size_t fa = strxfrm(xbuf, "a",  XFRMBUFSIZE);
	  const Size_t fb = strxfrm(xbuf, "ab", XFRMBUFSIZE);
	  const SSize_t mult = fb - fa;
	  if (mult < 1 && !(fa == 0 && fb == 0))
	      Perl_croak(aTHX_ "panic: strxfrm() gets absurd - a => %"UVuf", ab => %"UVuf,
			 (UV) fa, (UV) fb);
	  PL_collxfrm_base = (fa > (Size_t)mult) ? (fa - mult) : 0;
	  PL_collxfrm_mult = mult;
	}
    }

#else
    PERL_UNUSED_ARG(newcoll);
#endif /* USE_LOCALE_COLLATE */
}

#ifdef WIN32

char *
Perl_my_setlocale(pTHX_ int category, const char* locale)
{
    /* This, for Windows, emulates POSIX setlocale() behavior.  There is no
     * difference unless the input locale is "", which means on Windows to get
     * the machine default, which is set via the computer's "Regional and
     * Language Options" (or its current equivalent).  In POSIX, it instead
     * means to find the locale from the user's environment.  This routine
     * looks in the environment, and, if anything is found, uses that instead
     * of going to the machine default.  If there is no environment override,
     * the machine default is used, as normal, by calling the real setlocale()
     * with "".  The POSIX behavior is to use the LC_ALL variable if set;
     * otherwise to use the particular category's variable if set; otherwise to
     * use the LANG variable. */

    bool override_LC_ALL = FALSE;
    char * result;

    if (locale && strEQ(locale, "")) {
#   ifdef LC_ALL
        locale = PerlEnv_getenv("LC_ALL");
        if (! locale) {
#endif
            switch (category) {
#   ifdef LC_ALL
                case LC_ALL:
                    override_LC_ALL = TRUE;
                    break;  /* We already know its variable isn't set */
#   endif
#   ifdef USE_LOCALE_TIME
                case LC_TIME:
                    locale = PerlEnv_getenv("LC_TIME");
                    break;
#   endif
#   ifdef USE_LOCALE_CTYPE
                case LC_CTYPE:
                    locale = PerlEnv_getenv("LC_CTYPE");
                    break;
#   endif
#   ifdef USE_LOCALE_COLLATE
                case LC_COLLATE:
                    locale = PerlEnv_getenv("LC_COLLATE");
                    break;
#   endif
#   ifdef USE_LOCALE_MONETARY
                case LC_MONETARY:
                    locale = PerlEnv_getenv("LC_MONETARY");
                    break;
#   endif
#   ifdef USE_LOCALE_NUMERIC
                case LC_NUMERIC:
                    locale = PerlEnv_getenv("LC_NUMERIC");
                    break;
#   endif
#   ifdef USE_LOCALE_MESSAGES
                case LC_MESSAGES:
                    locale = PerlEnv_getenv("LC_MESSAGES");
                    break;
#   endif
                default:
                    /* This is a category, like PAPER_SIZE that we don't
                     * know about; and so can't provide a wrapper. */
                    break;
            }
            if (! locale) {
                locale = PerlEnv_getenv("LANG");
                if (! locale) {
                    locale = "";
                }
            }
#   ifdef LC_ALL
        }
#   endif
    }

    result = setlocale(category, locale);
    DEBUG_L(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n", __FILE__, __LINE__,
                            _setlocale_debug_string(category, locale, result)));

    if (! override_LC_ALL)  {
        return result;
    }

    /* Here the input category was LC_ALL, and we have set it to what is in the
     * LANG variable or the system default if there is no LANG.  But these have
     * lower priority than the other LC_foo variables, so override it for each
     * one that is set.  (If they are set to "", it means to use the same thing
     * we just set LC_ALL to, so can skip) */
#   ifdef USE_LOCALE_TIME
    result = PerlEnv_getenv("LC_TIME");
    if (result && strNE(result, "")) {
        setlocale(LC_TIME, result);
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                    __FILE__, __LINE__,
                    _setlocale_debug_string(LC_TIME, result, "not captured")));
    }
#   endif
#   ifdef USE_LOCALE_CTYPE
    result = PerlEnv_getenv("LC_CTYPE");
    if (result && strNE(result, "")) {
        setlocale(LC_CTYPE, result);
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                    __FILE__, __LINE__,
                    _setlocale_debug_string(LC_CTYPE, result, "not captured")));
    }
#   endif
#   ifdef USE_LOCALE_COLLATE
    result = PerlEnv_getenv("LC_COLLATE");
    if (result && strNE(result, "")) {
        setlocale(LC_COLLATE, result);
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                  __FILE__, __LINE__,
                  _setlocale_debug_string(LC_COLLATE, result, "not captured")));
    }
#   endif
#   ifdef USE_LOCALE_MONETARY
    result = PerlEnv_getenv("LC_MONETARY");
    if (result && strNE(result, "")) {
        setlocale(LC_MONETARY, result);
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                 __FILE__, __LINE__,
                 _setlocale_debug_string(LC_MONETARY, result, "not captured")));
    }
#   endif
#   ifdef USE_LOCALE_NUMERIC
    result = PerlEnv_getenv("LC_NUMERIC");
    if (result && strNE(result, "")) {
        setlocale(LC_NUMERIC, result);
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                 __FILE__, __LINE__,
                 _setlocale_debug_string(LC_NUMERIC, result, "not captured")));
    }
#   endif
#   ifdef USE_LOCALE_MESSAGES
    result = PerlEnv_getenv("LC_MESSAGES");
    if (result && strNE(result, "")) {
        setlocale(LC_MESSAGES, result);
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                 __FILE__, __LINE__,
                 _setlocale_debug_string(LC_MESSAGES, result, "not captured")));
    }
#   endif

    result = setlocale(LC_ALL, NULL);
    DEBUG_L(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                               __FILE__, __LINE__,
                               _setlocale_debug_string(LC_ALL, NULL, result)));

    return result;
}

#endif


/*
 * Initialize locale awareness.
 */
int
Perl_init_i18nl10n(pTHX_ int printwarn)
{
    /* printwarn is
     *
     *    0 if not to output warning when setup locale is bad
     *    1 if to output warning based on value of PERL_BADLANG
     *    >1 if to output regardless of PERL_BADLANG
     *
     * returns
     *    1 = set ok or not applicable,
     *    0 = fallback to a locale of lower priority
     *   -1 = fallback to all locales failed, not even to the C locale
     *
     * Under -DDEBUGGING, if the environment variable PERL_DEBUG_LOCALE_INIT is
     * set, debugging information is output.
     *
     * This looks more complicated than it is, mainly due to the #ifdefs.
     *
     * We try to set LC_ALL to the value determined by the environment.  If
     * there is no LC_ALL on this platform, we try the individual categories we
     * know about.  If this works, we are done.
     *
     * But if it doesn't work, we have to do something else.  We search the
     * environment variables ourselves instead of relying on the system to do
     * it.  We look at, in order, LC_ALL, LANG, a system default locale (if we
     * think there is one), and the ultimate fallback "C".  This is all done in
     * the same loop as above to avoid duplicating code, but it makes things
     * more complex.  After the original failure, we add the fallback
     * possibilities to the list of locales to try, and iterate the loop
     * through them all until one succeeds.
     *
     * On Ultrix, the locale MUST come from the environment, so there is
     * preliminary code to set it.  I (khw) am not sure that it is necessary,
     * and that this couldn't be folded into the loop, but barring any real
     * platforms to test on, it's staying as-is
     *
     * A slight complication is that in embedded Perls, the locale may already
     * be set-up, and we don't want to get it from the normal environment
     * variables.  This is handled by having a special environment variable
     * indicate we're in this situation.  We simply set setlocale's 2nd
     * parameter to be a NULL instead of "".  That indicates to setlocale that
     * it is not to change anything, but to return the current value,
     * effectively initializing perl's db to what the locale already is.
     *
     * We play the same trick with NULL if a LC_ALL succeeds.  We call
     * setlocale() on the individual categores with NULL to get their existing
     * values for our db, instead of trying to change them.
     * */

    int ok = 1;

#if defined(USE_LOCALE)
#ifdef USE_LOCALE_CTYPE
    char *curctype   = NULL;
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    char *curcoll    = NULL;
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    char *curnum     = NULL;
#endif /* USE_LOCALE_NUMERIC */
#ifdef __GLIBC__
    const char * const language   = savepv(PerlEnv_getenv("LANGUAGE"));
#endif

    /* NULL uses the existing already set up locale */
    const char * const setlocale_init = (PerlEnv_getenv("PERL_SKIP_LOCALE_INIT"))
                                        ? NULL
                                        : "";
#ifdef DEBUGGING
    const bool debug = (PerlEnv_getenv("PERL_DEBUG_LOCALE_INIT"))
                       ? TRUE
                       : FALSE;
#   define DEBUG_LOCALE_INIT(category, locale, result)                      \
	STMT_START {                                                        \
		if (debug) {                                                \
                    PerlIO_printf(Perl_debug_log,                           \
                                  "%s:%d: %s\n",                            \
                                  __FILE__, __LINE__,                       \
                                  _setlocale_debug_string(category,         \
                                                          locale,           \
                                                          result));         \
                }                                                           \
	} STMT_END
#else
#   define DEBUG_LOCALE_INIT(a,b,c)
#endif
    const char* trial_locales[5];   /* 5 = 1 each for "", LC_ALL, LANG, "", C */
    unsigned int trial_locales_count;
    const char * const lc_all     = savepv(PerlEnv_getenv("LC_ALL"));
    const char * const lang       = savepv(PerlEnv_getenv("LANG"));
    bool setlocale_failure = FALSE;
    unsigned int i;
    char *p;

    /* A later getenv() could zap this, so only use here */
    const char * const bad_lang_use_once = PerlEnv_getenv("PERL_BADLANG");

    const bool locwarn = (printwarn > 1
                          || (printwarn
                              && (! bad_lang_use_once
                                  || (
                                    /* disallow with "" or "0" */
                                    *bad_lang_use_once
                                    && strNE("0", bad_lang_use_once)))));
    bool done = FALSE;
    char * sl_result;   /* return from setlocale() */
    char * locale_param;
#ifdef WIN32
    /* In some systems you can find out the system default locale
     * and use that as the fallback locale. */
#   define SYSTEM_DEFAULT_LOCALE
#endif
#ifdef SYSTEM_DEFAULT_LOCALE
    const char *system_default_locale = NULL;
#endif

#ifndef LOCALE_ENVIRON_REQUIRED
    PERL_UNUSED_VAR(done);
    PERL_UNUSED_VAR(locale_param);
#else

    /*
     * Ultrix setlocale(..., "") fails if there are no environment
     * variables from which to get a locale name.
     */

#   ifdef LC_ALL
    if (lang) {
	sl_result = my_setlocale(LC_ALL, setlocale_init);
        DEBUG_LOCALE_INIT(LC_ALL, setlocale_init, sl_result);
	if (sl_result)
	    done = TRUE;
	else
	    setlocale_failure = TRUE;
    }
    if (! setlocale_failure) {
#       ifdef USE_LOCALE_CTYPE
        locale_param = (! done && (lang || PerlEnv_getenv("LC_CTYPE")))
                       ? setlocale_init
                       : NULL;
	curctype = my_setlocale(LC_CTYPE, locale_param);
        DEBUG_LOCALE_INIT(LC_CTYPE, locale_param, sl_result);
	if (! curctype)
	    setlocale_failure = TRUE;
	else
	    curctype = savepv(curctype);
#       endif /* USE_LOCALE_CTYPE */
#       ifdef USE_LOCALE_COLLATE
        locale_param = (! done && (lang || PerlEnv_getenv("LC_COLLATE")))
                       ? setlocale_init
                       : NULL;
	curcoll = my_setlocale(LC_COLLATE, locale_param);
        DEBUG_LOCALE_INIT(LC_COLLATE, locale_param, sl_result);
	if (! curcoll)
	    setlocale_failure = TRUE;
	else
	    curcoll = savepv(curcoll);
#       endif /* USE_LOCALE_COLLATE */
#       ifdef USE_LOCALE_NUMERIC
        locale_param = (! done && (lang || PerlEnv_getenv("LC_NUMERIC")))
                       ? setlocale_init
                       : NULL;
	curnum = my_setlocale(LC_NUMERIC, locale_param);
        DEBUG_LOCALE_INIT(LC_NUMERIC, locale_param, sl_result);
	if (! curnum)
	    setlocale_failure = TRUE;
	else
	    curnum = savepv(curnum);
#       endif /* USE_LOCALE_NUMERIC */
#       ifdef USE_LOCALE_MESSAGES
        locale_param = (! done && (lang || PerlEnv_getenv("LC_MESSAGES")))
                       ? setlocale_init
                       : NULL;
	sl_result = my_setlocale(LC_MESSAGES, locale_param);
        DEBUG_LOCALE_INIT(LC_MESSAGES, locale_param, sl_result);
	if (! sl_result)
	    setlocale_failure = TRUE;
        }
#       endif /* USE_LOCALE_MESSAGES */
#       ifdef USE_LOCALE_MONETARY
        locale_param = (! done && (lang || PerlEnv_getenv("LC_MONETARY")))
                       ? setlocale_init
                       : NULL;
	sl_result = my_setlocale(LC_MONETARY, locale_param);
        DEBUG_LOCALE_INIT(LC_MONETARY, locale_param, sl_result);
	if (! sl_result) {
	    setlocale_failure = TRUE;
        }
#       endif /* USE_LOCALE_MONETARY */
    }

#   endif /* LC_ALL */

#endif /* !LOCALE_ENVIRON_REQUIRED */

    /* We try each locale in the list until we get one that works, or exhaust
     * the list.  Normally the loop is executed just once.  But if setting the
     * locale fails, inside the loop we add fallback trials to the array and so
     * will execute the loop multiple times */
    trial_locales[0] = setlocale_init;
    trial_locales_count = 1;
    for (i= 0; i < trial_locales_count; i++) {
        const char * trial_locale = trial_locales[i];

        if (i > 0) {

            /* XXX This is to preserve old behavior for LOCALE_ENVIRON_REQUIRED
             * when i==0, but I (khw) don't think that behavior makes much
             * sense */
            setlocale_failure = FALSE;

#ifdef SYSTEM_DEFAULT_LOCALE
#  ifdef WIN32
            /* On Windows machines, an entry of "" after the 0th means to use
             * the system default locale, which we now proceed to get. */
            if (strEQ(trial_locale, "")) {
                unsigned int j;

                /* Note that this may change the locale, but we are going to do
                 * that anyway just below */
                system_default_locale = setlocale(LC_ALL, "");
                DEBUG_LOCALE_INIT(LC_ALL, "", system_default_locale);

                /* Skip if invalid or it's already on the list of locales to
                 * try */
                if (! system_default_locale) {
                    goto next_iteration;
                }
                for (j = 0; j < trial_locales_count; j++) {
                    if (strEQ(system_default_locale, trial_locales[j])) {
                        goto next_iteration;
                    }
                }

                trial_locale = system_default_locale;
            }
#  endif /* WIN32 */
#endif /* SYSTEM_DEFAULT_LOCALE */
        }

#ifdef LC_ALL
        sl_result = my_setlocale(LC_ALL, trial_locale);
        DEBUG_LOCALE_INIT(LC_ALL, trial_locale, sl_result);
        if (! sl_result) {
            setlocale_failure = TRUE;
        }
        else {
            /* Since LC_ALL succeeded, it should have changed all the other
             * categories it can to its value; so we massage things so that the
             * setlocales below just return their category's current values.
             * This adequately handles the case in NetBSD where LC_COLLATE may
             * not be defined for a locale, and setting it individually will
             * fail, whereas setting LC_ALL suceeds, leaving LC_COLLATE set to
             * the POSIX locale. */
            trial_locale = NULL;
        }
#endif /* LC_ALL */

        if (!setlocale_failure) {
#ifdef USE_LOCALE_CTYPE
            Safefree(curctype);
            curctype = my_setlocale(LC_CTYPE, trial_locale);
            DEBUG_LOCALE_INIT(LC_CTYPE, trial_locale, curctype);
            if (! curctype)
                setlocale_failure = TRUE;
            else
                curctype = savepv(curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
            Safefree(curcoll);
            curcoll = my_setlocale(LC_COLLATE, trial_locale);
            DEBUG_LOCALE_INIT(LC_COLLATE, trial_locale, curcoll);
            if (! curcoll)
                setlocale_failure = TRUE;
            else
                curcoll = savepv(curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
            Safefree(curnum);
            curnum = my_setlocale(LC_NUMERIC, trial_locale);
            DEBUG_LOCALE_INIT(LC_NUMERIC, trial_locale, curnum);
            if (! curnum)
                setlocale_failure = TRUE;
            else
                curnum = savepv(curnum);
#endif /* USE_LOCALE_NUMERIC */
#ifdef USE_LOCALE_MESSAGES
            sl_result = my_setlocale(LC_MESSAGES, trial_locale);
            DEBUG_LOCALE_INIT(LC_MESSAGES, trial_locale, sl_result);
            if (! (sl_result))
                setlocale_failure = TRUE;
#endif /* USE_LOCALE_MESSAGES */
#ifdef USE_LOCALE_MONETARY
            sl_result = my_setlocale(LC_MONETARY, trial_locale);
            DEBUG_LOCALE_INIT(LC_MONETARY, trial_locale, sl_result);
            if (! (sl_result))
                setlocale_failure = TRUE;
#endif /* USE_LOCALE_MONETARY */

            if (! setlocale_failure) {  /* Success */
                break;
            }
        }

        /* Here, something failed; will need to try a fallback. */
        ok = 0;

        if (i == 0) {
            unsigned int j;

            if (locwarn) { /* Output failure info only on the first one */
#ifdef LC_ALL

                PerlIO_printf(Perl_error_log,
                "perl: warning: Setting locale failed.\n");

#else /* !LC_ALL */

                PerlIO_printf(Perl_error_log,
                "perl: warning: Setting locale failed for the categories:\n\t");
#  ifdef USE_LOCALE_CTYPE
                if (! curctype)
                    PerlIO_printf(Perl_error_log, "LC_CTYPE ");
#  endif /* USE_LOCALE_CTYPE */
#  ifdef USE_LOCALE_COLLATE
                if (! curcoll)
                    PerlIO_printf(Perl_error_log, "LC_COLLATE ");
#  endif /* USE_LOCALE_COLLATE */
#  ifdef USE_LOCALE_NUMERIC
                if (! curnum)
                    PerlIO_printf(Perl_error_log, "LC_NUMERIC ");
#  endif /* USE_LOCALE_NUMERIC */
                PerlIO_printf(Perl_error_log, "and possibly others\n");

#endif /* LC_ALL */

                PerlIO_printf(Perl_error_log,
                    "perl: warning: Please check that your locale settings:\n");

#ifdef __GLIBC__
                PerlIO_printf(Perl_error_log,
                            "\tLANGUAGE = %c%s%c,\n",
                            language ? '"' : '(',
                            language ? language : "unset",
                            language ? '"' : ')');
#endif

                PerlIO_printf(Perl_error_log,
                            "\tLC_ALL = %c%s%c,\n",
                            lc_all ? '"' : '(',
                            lc_all ? lc_all : "unset",
                            lc_all ? '"' : ')');

#if defined(USE_ENVIRON_ARRAY)
                {
                char **e;
                for (e = environ; *e; e++) {
                    if (strnEQ(*e, "LC_", 3)
                            && strnNE(*e, "LC_ALL=", 7)
                            && (p = strchr(*e, '=')))
                        PerlIO_printf(Perl_error_log, "\t%.*s = \"%s\",\n",
                                        (int)(p - *e), *e, p + 1);
                }
                }
#else
                PerlIO_printf(Perl_error_log,
                            "\t(possibly more locale environment variables)\n");
#endif

                PerlIO_printf(Perl_error_log,
                            "\tLANG = %c%s%c\n",
                            lang ? '"' : '(',
                            lang ? lang : "unset",
                            lang ? '"' : ')');

                PerlIO_printf(Perl_error_log,
                            "    are supported and installed on your system.\n");
            }

            /* Calculate what fallback locales to try.  We have avoided this
             * until we have to, because failure is quite unlikely.  This will
             * usually change the upper bound of the loop we are in.
             *
             * Since the system's default way of setting the locale has not
             * found one that works, We use Perl's defined ordering: LC_ALL,
             * LANG, and the C locale.  We don't try the same locale twice, so
             * don't add to the list if already there.  (On POSIX systems, the
             * LC_ALL element will likely be a repeat of the 0th element "",
             * but there's no harm done by doing it explicitly.
             *
             * Note that this tries the LC_ALL environment variable even on
             * systems which have no LC_ALL locale setting.  This may or may
             * not have been originally intentional, but there's no real need
             * to change the behavior. */
            if (lc_all) {
                for (j = 0; j < trial_locales_count; j++) {
                    if (strEQ(lc_all, trial_locales[j])) {
                        goto done_lc_all;
                    }
                }
                trial_locales[trial_locales_count++] = lc_all;
            }
          done_lc_all:

            if (lang) {
                for (j = 0; j < trial_locales_count; j++) {
                    if (strEQ(lang, trial_locales[j])) {
                        goto done_lang;
                    }
                }
                trial_locales[trial_locales_count++] = lang;
            }
          done_lang:

#if defined(WIN32) && defined(LC_ALL)
            /* For Windows, we also try the system default locale before "C".
             * (If there exists a Windows without LC_ALL we skip this because
             * it gets too complicated.  For those, the "C" is the next
             * fallback possibility).  The "" is the same as the 0th element of
             * the array, but the code at the loop above knows to treat it
             * differently when not the 0th */
            trial_locales[trial_locales_count++] = "";
#endif

            for (j = 0; j < trial_locales_count; j++) {
                if (strEQ("C", trial_locales[j])) {
                    goto done_C;
                }
            }
            trial_locales[trial_locales_count++] = "C";

          done_C: ;
        }   /* end of first time through the loop */

#ifdef WIN32
      next_iteration: ;
#endif

    }   /* end of looping through the trial locales */

    if (ok < 1) {   /* If we tried to fallback */
        const char* msg;
        if (! setlocale_failure) {  /* fallback succeeded */
           msg = "Falling back to";
        }
        else {  /* fallback failed */

            /* We dropped off the end of the loop, so have to decrement i to
             * get back to the value the last time through */
            i--;

            ok = -1;
            msg = "Failed to fall back to";

            /* To continue, we should use whatever values we've got */
#ifdef USE_LOCALE_CTYPE
            Safefree(curctype);
            curctype = savepv(setlocale(LC_CTYPE, NULL));
            DEBUG_LOCALE_INIT(LC_CTYPE, NULL, curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
            Safefree(curcoll);
            curcoll = savepv(setlocale(LC_COLLATE, NULL));
            DEBUG_LOCALE_INIT(LC_COLLATE, NULL, curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
            Safefree(curnum);
            curnum = savepv(setlocale(LC_NUMERIC, NULL));
            DEBUG_LOCALE_INIT(LC_NUMERIC, NULL, curnum);
#endif /* USE_LOCALE_NUMERIC */
        }

        if (locwarn) {
            const char * description;
            const char * name = "";
            if (strEQ(trial_locales[i], "C")) {
                description = "the standard locale";
                name = "C";
            }
#ifdef SYSTEM_DEFAULT_LOCALE
            else if (strEQ(trial_locales[i], "")) {
                description = "the system default locale";
                if (system_default_locale) {
                    name = system_default_locale;
                }
            }
#endif /* SYSTEM_DEFAULT_LOCALE */
            else {
                description = "a fallback locale";
                name = trial_locales[i];
            }
            if (name && strNE(name, "")) {
                PerlIO_printf(Perl_error_log,
                    "perl: warning: %s %s (\"%s\").\n", msg, description, name);
            }
            else {
                PerlIO_printf(Perl_error_log,
                                   "perl: warning: %s %s.\n", msg, description);
            }
        }
    } /* End of tried to fallback */

#ifdef USE_LOCALE_CTYPE
    new_ctype(curctype);
#endif /* USE_LOCALE_CTYPE */

#ifdef USE_LOCALE_COLLATE
    new_collate(curcoll);
#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE_NUMERIC
    new_numeric(curnum);
#endif /* USE_LOCALE_NUMERIC */

#if defined(USE_PERLIO) && defined(USE_LOCALE_CTYPE)
    /* Set PL_utf8locale to TRUE if using PerlIO _and_ the current LC_CTYPE
     * locale is UTF-8.  If PL_utf8locale and PL_unicode (set by -C or by
     * $ENV{PERL_UNICODE}) are true, perl.c:S_parse_body() will turn on the
     * PerlIO :utf8 layer on STDIN, STDOUT, STDERR, _and_ the default open
     * discipline.  */
    PL_utf8locale = _is_cur_LC_category_utf8(LC_CTYPE);

    /* Set PL_unicode to $ENV{PERL_UNICODE} if using PerlIO.
       This is an alternative to using the -C command line switch
       (the -C if present will override this). */
    {
	 const char *p = PerlEnv_getenv("PERL_UNICODE");
	 PL_unicode = p ? parse_unicode_opts(&p) : 0;
	 if (PL_unicode & PERL_UNICODE_UTF8CACHEASSERT_FLAG)
	     PL_utf8cache = -1;
    }
#endif

#ifdef USE_LOCALE_CTYPE
    Safefree(curctype);
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
    Safefree(curcoll);
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
    Safefree(curnum);
#endif /* USE_LOCALE_NUMERIC */

#ifdef __GLIBC__
    Safefree(language);
#endif

    Safefree(lc_all);
    Safefree(lang);

#else  /* !USE_LOCALE */
    PERL_UNUSED_ARG(printwarn);
#endif /* USE_LOCALE */

    return ok;
}


#ifdef USE_LOCALE_COLLATE

/*
 * mem_collxfrm() is a bit like strxfrm() but with two important
 * differences. First, it handles embedded NULs. Second, it allocates
 * a bit more memory than needed for the transformed data itself.
 * The real transformed data begins at offset sizeof(collationix).
 * Please see sv_collxfrm() to see how this is used.
 */

char *
Perl_mem_collxfrm(pTHX_ const char *s, STRLEN len, STRLEN *xlen)
{
    char *xbuf;
    STRLEN xAlloc, xin, xout; /* xalloc is a reserved word in VC */

    PERL_ARGS_ASSERT_MEM_COLLXFRM;

    /* the first sizeof(collationix) bytes are used by sv_collxfrm(). */
    /* the +1 is for the terminating NUL. */

    xAlloc = sizeof(PL_collation_ix) + PL_collxfrm_base + (PL_collxfrm_mult * len) + 1;
    Newx(xbuf, xAlloc, char);
    if (! xbuf)
	goto bad;

    *(U32*)xbuf = PL_collation_ix;
    xout = sizeof(PL_collation_ix);
    for (xin = 0; xin < len; ) {
	Size_t xused;

	for (;;) {
	    xused = strxfrm(xbuf + xout, s + xin, xAlloc - xout);
	    if (xused >= PERL_INT_MAX)
		goto bad;
	    if ((STRLEN)xused < xAlloc - xout)
		break;
	    xAlloc = (2 * xAlloc) + 1;
	    Renew(xbuf, xAlloc, char);
	    if (! xbuf)
		goto bad;
	}

	xin += strlen(s + xin) + 1;
	xout += xused;

	/* Embedded NULs are understood but silently skipped
	 * because they make no sense in locale collation. */
    }

    xbuf[xout] = '\0';
    *xlen = xout - sizeof(PL_collation_ix);
    return xbuf;

  bad:
    Safefree(xbuf);
    *xlen = 0;
    return NULL;
}

#endif /* USE_LOCALE_COLLATE */

#ifdef USE_LOCALE

bool
Perl__is_cur_LC_category_utf8(pTHX_ int category)
{
    /* Returns TRUE if the current locale for 'category' is UTF-8; FALSE
     * otherwise. 'category' may not be LC_ALL.  If the platform doesn't have
     * nl_langinfo(), nor MB_CUR_MAX, this employs a heuristic, which hence
     * could give the wrong result.  The result will very likely be correct for
     * languages that have commonly used non-ASCII characters, but for notably
     * English, it comes down to if the locale's name ends in something like
     * "UTF-8".  It errs on the side of not being a UTF-8 locale. */

    char *save_input_locale = NULL;
    STRLEN final_pos;

#ifdef LC_ALL
    assert(category != LC_ALL);
#endif

    /* First dispose of the trivial cases */
    save_input_locale = setlocale(category, NULL);
    if (! save_input_locale) {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "Could not find current locale for category %d\n",
                              category));
        return FALSE;   /* XXX maybe should croak */
    }
    save_input_locale = stdize_locale(savepv(save_input_locale));
    if (isNAME_C_OR_POSIX(save_input_locale)) {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "Current locale for category %d is %s\n",
                              category, save_input_locale));
        Safefree(save_input_locale);
        return FALSE;
    }

#if defined(USE_LOCALE_CTYPE)    \
    && (defined(MB_CUR_MAX) || (defined(HAS_NL_LANGINFO) && defined(CODESET)))

    { /* Next try nl_langinfo or MB_CUR_MAX if available */

        char *save_ctype_locale = NULL;
        bool is_utf8;

        if (category != LC_CTYPE) { /* These work only on LC_CTYPE */

            /* Get the current LC_CTYPE locale */
            save_ctype_locale = setlocale(LC_CTYPE, NULL);
            if (! save_ctype_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                               "Could not find current locale for LC_CTYPE\n"));
                goto cant_use_nllanginfo;
            }
            save_ctype_locale = stdize_locale(savepv(save_ctype_locale));

            /* If LC_CTYPE and the desired category use the same locale, this
             * means that finding the value for LC_CTYPE is the same as finding
             * the value for the desired category.  Otherwise, switch LC_CTYPE
             * to the desired category's locale */
            if (strEQ(save_ctype_locale, save_input_locale)) {
                Safefree(save_ctype_locale);
                save_ctype_locale = NULL;
            }
            else if (! setlocale(LC_CTYPE, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                                    "Could not change LC_CTYPE locale to %s\n",
                                    save_input_locale));
                Safefree(save_ctype_locale);
                goto cant_use_nllanginfo;
            }
        }

        DEBUG_L(PerlIO_printf(Perl_debug_log, "Current LC_CTYPE locale=%s\n",
                                              save_input_locale));

        /* Here the current LC_CTYPE is set to the locale of the category whose
         * information is desired.  This means that nl_langinfo() and MB_CUR_MAX
         * should give the correct results */

#   if defined(HAS_NL_LANGINFO) && defined(CODESET)
        {
            char *codeset = nl_langinfo(CODESET);
            if (codeset && strNE(codeset, "")) {
                codeset = savepv(codeset);

                /* If we switched LC_CTYPE, switch back */
                if (save_ctype_locale) {
                    setlocale(LC_CTYPE, save_ctype_locale);
                    Safefree(save_ctype_locale);
                }

                is_utf8 = foldEQ(codeset, STR_WITH_LEN("UTF-8"))
                        || foldEQ(codeset, STR_WITH_LEN("UTF8"));

                DEBUG_L(PerlIO_printf(Perl_debug_log,
                       "\tnllanginfo returned CODESET '%s'; ?UTF8 locale=%d\n",
                                                     codeset,         is_utf8));
                Safefree(codeset);
                Safefree(save_input_locale);
                return is_utf8;
            }
        }

#   endif
#   ifdef MB_CUR_MAX

        /* Here, either we don't have nl_langinfo, or it didn't return a
         * codeset.  Try MB_CUR_MAX */

        /* Standard UTF-8 needs at least 4 bytes to represent the maximum
         * Unicode code point.  Since UTF-8 is the only non-single byte
         * encoding we handle, we just say any such encoding is UTF-8, and if
         * turns out to be wrong, other things will fail */
        is_utf8 = MB_CUR_MAX >= 4;

        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "\tMB_CUR_MAX=%d; ?UTF8 locale=%d\n",
                                   (int) MB_CUR_MAX,      is_utf8));

        Safefree(save_input_locale);

#       ifdef HAS_MBTOWC

        /* ... But, most system that have MB_CUR_MAX will also have mbtowc(),
         * since they are both in the C99 standard.  We can feed a known byte
         * string to the latter function, and check that it gives the expected
         * result */
        if (is_utf8) {
            wchar_t wc;
            PERL_UNUSED_RESULT(mbtowc(&wc, NULL, 0));/* Reset any shift state */
            errno = 0;
            if ((size_t)mbtowc(&wc, HYPHEN_UTF8, strlen(HYPHEN_UTF8))
                                                        != strlen(HYPHEN_UTF8)
                || wc != (wchar_t) 0x2010)
            {
                is_utf8 = FALSE;
                DEBUG_L(PerlIO_printf(Perl_debug_log, "\thyphen=U+%x\n", (unsigned int)wc));
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                        "\treturn from mbtowc=%d; errno=%d; ?UTF8 locale=0\n",
                        mbtowc(&wc, HYPHEN_UTF8, strlen(HYPHEN_UTF8)), errno));
            }
        }
#       endif

        /* If we switched LC_CTYPE, switch back */
        if (save_ctype_locale) {
            setlocale(LC_CTYPE, save_ctype_locale);
            Safefree(save_ctype_locale);
        }

        return is_utf8;
#   endif
    }

  cant_use_nllanginfo:

#else   /* nl_langinfo should work if available, so don't bother compiling this
           fallback code.  The final fallback of looking at the name is
           compiled, and will be executed if nl_langinfo fails */

    /* nl_langinfo not available or failed somehow.  Next try looking at the
     * currency symbol to see if it disambiguates things.  Often that will be
     * in the native script, and if the symbol isn't in UTF-8, we know that the
     * locale isn't.  If it is non-ASCII UTF-8, we infer that the locale is
     * too, as the odds of a non-UTF8 string being valid UTF-8 are quite small
     * */

#ifdef HAS_LOCALECONV
#   ifdef USE_LOCALE_MONETARY
    {
        char *save_monetary_locale = NULL;
        bool only_ascii = FALSE;
        bool is_utf8 = FALSE;
        struct lconv* lc;

        /* Like above for LC_CTYPE, we first set LC_MONETARY to the locale of
         * the desired category, if it isn't that locale already */

        if (category != LC_MONETARY) {

            save_monetary_locale = setlocale(LC_MONETARY, NULL);
            if (! save_monetary_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_MONETARY\n"));
                goto cant_use_monetary;
            }
            save_monetary_locale = stdize_locale(savepv(save_monetary_locale));

            if (strEQ(save_monetary_locale, save_input_locale)) {
                Safefree(save_monetary_locale);
                save_monetary_locale = NULL;
            }
            else if (! setlocale(LC_MONETARY, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not change LC_MONETARY locale to %s\n",
                                                        save_input_locale));
                Safefree(save_monetary_locale);
                goto cant_use_monetary;
            }
        }

        /* Here the current LC_MONETARY is set to the locale of the category
         * whose information is desired. */

        lc = localeconv();
        if (! lc
            || ! lc->currency_symbol
            || is_invariant_string((U8 *) lc->currency_symbol, 0))
        {
            DEBUG_L(PerlIO_printf(Perl_debug_log, "Couldn't get currency symbol for %s, or contains only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
            only_ascii = TRUE;
        }
        else {
            is_utf8 = is_utf8_string((U8 *) lc->currency_symbol, 0);
        }

        /* If we changed it, restore LC_MONETARY to its original locale */
        if (save_monetary_locale) {
            setlocale(LC_MONETARY, save_monetary_locale);
            Safefree(save_monetary_locale);
        }

        if (! only_ascii) {

            /* It isn't a UTF-8 locale if the symbol is not legal UTF-8;
             * otherwise assume the locale is UTF-8 if and only if the symbol
             * is non-ascii UTF-8. */
            DEBUG_L(PerlIO_printf(Perl_debug_log, "\t?Currency symbol for %s is UTF-8=%d\n",
                                    save_input_locale, is_utf8));
            Safefree(save_input_locale);
            return is_utf8;
        }
    }
  cant_use_monetary:

#   endif /* USE_LOCALE_MONETARY */
#endif /* HAS_LOCALECONV */

#if defined(HAS_STRFTIME) && defined(USE_LOCALE_TIME)

/* Still haven't found a non-ASCII string to disambiguate UTF-8 or not.  Try
 * the names of the months and weekdays, timezone, and am/pm indicator */
    {
        char *save_time_locale = NULL;
        int hour = 10;
        bool is_dst = FALSE;
        int dom = 1;
        int month = 0;
        int i;
        char * formatted_time;


        /* Like above for LC_MONETARY, we set LC_TIME to the locale of the
         * desired category, if it isn't that locale already */

        if (category != LC_TIME) {

            save_time_locale = setlocale(LC_TIME, NULL);
            if (! save_time_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_TIME\n"));
                goto cant_use_time;
            }
            save_time_locale = stdize_locale(savepv(save_time_locale));

            if (strEQ(save_time_locale, save_input_locale)) {
                Safefree(save_time_locale);
                save_time_locale = NULL;
            }
            else if (! setlocale(LC_TIME, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not change LC_TIME locale to %s\n",
                                                        save_input_locale));
                Safefree(save_time_locale);
                goto cant_use_time;
            }
        }

        /* Here the current LC_TIME is set to the locale of the category
         * whose information is desired.  Look at all the days of the week and
         * month names, and the timezone and am/pm indicator for UTF-8 variant
         * characters.  The first such a one found will tell us if the locale
         * is UTF-8 or not */

        for (i = 0; i < 7 + 12; i++) {  /* 7 days; 12 months */
            formatted_time = my_strftime("%A %B %Z %p",
                                    0, 0, hour, dom, month, 112, 0, 0, is_dst);
            if (! formatted_time || is_invariant_string((U8 *) formatted_time, 0)) {

                /* Here, we didn't find a non-ASCII.  Try the next time through
                 * with the complemented dst and am/pm, and try with the next
                 * weekday.  After we have gotten all weekdays, try the next
                 * month */
                is_dst = ! is_dst;
                hour = (hour + 12) % 24;
                dom++;
                if (i > 6) {
                    month++;
                }
                continue;
            }

            /* Here, we have a non-ASCII.  Return TRUE is it is valid UTF8;
             * false otherwise.  But first, restore LC_TIME to its original
             * locale if we changed it */
            if (save_time_locale) {
                setlocale(LC_TIME, save_time_locale);
                Safefree(save_time_locale);
            }

            DEBUG_L(PerlIO_printf(Perl_debug_log, "\t?time-related strings for %s are UTF-8=%d\n",
                                save_input_locale,
                                is_utf8_string((U8 *) formatted_time, 0)));
            Safefree(save_input_locale);
            return is_utf8_string((U8 *) formatted_time, 0);
        }

        /* Falling off the end of the loop indicates all the names were just
         * ASCII.  Go on to the next test.  If we changed it, restore LC_TIME
         * to its original locale */
        if (save_time_locale) {
            setlocale(LC_TIME, save_time_locale);
            Safefree(save_time_locale);
        }
        DEBUG_L(PerlIO_printf(Perl_debug_log, "All time-related words for %s contain only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
    }
  cant_use_time:

#endif

#if 0 && defined(USE_LOCALE_MESSAGES) && defined(HAS_SYS_ERRLIST)

/* This code is ifdefd out because it was found to not be necessary in testing
 * on our dromedary test machine, which has over 700 locales.  There, this
 * added no value to looking at the currency symbol and the time strings.  I
 * left it in so as to avoid rewriting it if real-world experience indicates
 * that dromedary is an outlier.  Essentially, instead of returning abpve if we
 * haven't found illegal utf8, we continue on and examine all the strerror()
 * messages on the platform for utf8ness.  If all are ASCII, we still don't
 * know the answer; but otherwise we have a pretty good indication of the
 * utf8ness.  The reason this doesn't help much is that the messages may not
 * have been translated into the locale.  The currency symbol and time strings
 * are much more likely to have been translated.  */
    {
        int e;
        bool is_utf8 = FALSE;
        bool non_ascii = FALSE;
        char *save_messages_locale = NULL;
        const char * errmsg = NULL;

        /* Like above, we set LC_MESSAGES to the locale of the desired
         * category, if it isn't that locale already */

        if (category != LC_MESSAGES) {

            save_messages_locale = setlocale(LC_MESSAGES, NULL);
            if (! save_messages_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_MESSAGES\n"));
                goto cant_use_messages;
            }
            save_messages_locale = stdize_locale(savepv(save_messages_locale));

            if (strEQ(save_messages_locale, save_input_locale)) {
                Safefree(save_messages_locale);
                save_messages_locale = NULL;
            }
            else if (! setlocale(LC_MESSAGES, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not change LC_MESSAGES locale to %s\n",
                                                        save_input_locale));
                Safefree(save_messages_locale);
                goto cant_use_messages;
            }
        }

        /* Here the current LC_MESSAGES is set to the locale of the category
         * whose information is desired.  Look through all the messages.  We
         * can't use Strerror() here because it may expand to code that
         * segfaults in miniperl */

        for (e = 0; e <= sys_nerr; e++) {
            errno = 0;
            errmsg = sys_errlist[e];
            if (errno || !errmsg) {
                break;
            }
            errmsg = savepv(errmsg);
            if (! is_invariant_string((U8 *) errmsg, 0)) {
                non_ascii = TRUE;
                is_utf8 = is_utf8_string((U8 *) errmsg, 0);
                break;
            }
        }
        Safefree(errmsg);

        /* And, if we changed it, restore LC_MESSAGES to its original locale */
        if (save_messages_locale) {
            setlocale(LC_MESSAGES, save_messages_locale);
            Safefree(save_messages_locale);
        }

        if (non_ascii) {

            /* Any non-UTF-8 message means not a UTF-8 locale; if all are valid,
             * any non-ascii means it is one; otherwise we assume it isn't */
            DEBUG_L(PerlIO_printf(Perl_debug_log, "\t?error messages for %s are UTF-8=%d\n",
                                save_input_locale,
                                is_utf8));
            Safefree(save_input_locale);
            return is_utf8;
        }

        DEBUG_L(PerlIO_printf(Perl_debug_log, "All error messages for %s contain only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
    }
  cant_use_messages:

#endif

#endif /* the code that is compiled when no nl_langinfo */

#ifndef EBCDIC  /* On os390, even if the name ends with "UTF-8', it isn't a
                   UTF-8 locale */
    /* As a last resort, look at the locale name to see if it matches
     * qr/UTF -?  * 8 /ix, or some other common locale names.  This "name", the
     * return of setlocale(), is actually defined to be opaque, so we can't
     * really rely on the absence of various substrings in the name to indicate
     * its UTF-8ness, but if it has UTF8 in the name, it is extremely likely to
     * be a UTF-8 locale.  Similarly for the other common names */

    final_pos = strlen(save_input_locale) - 1;
    if (final_pos >= 3) {
        char *name = save_input_locale;

        /* Find next 'U' or 'u' and look from there */
        while ((name += strcspn(name, "Uu") + 1)
                                            <= save_input_locale + final_pos - 2)
        {
            if (!isALPHA_FOLD_NE(*name, 't')
                || isALPHA_FOLD_NE(*(name + 1), 'f'))
            {
                continue;
            }
            name += 2;
            if (*(name) == '-') {
                if ((name > save_input_locale + final_pos - 1)) {
                    break;
                }
                name++;
            }
            if (*(name) == '8') {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                                      "Locale %s ends with UTF-8 in name\n",
                                      save_input_locale));
                Safefree(save_input_locale);
                return TRUE;
            }
        }
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "Locale %s doesn't end with UTF-8 in name\n",
                                save_input_locale));
    }
#endif

#ifdef WIN32
    /* http://msdn.microsoft.com/en-us/library/windows/desktop/dd317756.aspx */
    if (final_pos >= 4
        && *(save_input_locale + final_pos - 0) == '1'
        && *(save_input_locale + final_pos - 1) == '0'
        && *(save_input_locale + final_pos - 2) == '0'
        && *(save_input_locale + final_pos - 3) == '5'
        && *(save_input_locale + final_pos - 4) == '6')
    {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                        "Locale %s ends with 10056 in name, is UTF-8 locale\n",
                        save_input_locale));
        Safefree(save_input_locale);
        return TRUE;
    }
#endif

    /* Other common encodings are the ISO 8859 series, which aren't UTF-8.  But
     * since we are about to return FALSE anyway, there is no point in doing
     * this extra work */
#if 0
    if (instr(save_input_locale, "8859")) {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                             "Locale %s has 8859 in name, not UTF-8 locale\n",
                             save_input_locale));
        Safefree(save_input_locale);
        return FALSE;
    }
#endif

    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Assuming locale %s is not a UTF-8 locale\n",
                                    save_input_locale));
    Safefree(save_input_locale);
    return FALSE;
}

#endif


bool
Perl__is_in_locale_category(pTHX_ const bool compiling, const int category)
{
    dVAR;
    /* Internal function which returns if we are in the scope of a pragma that
     * enables the locale category 'category'.  'compiling' should indicate if
     * this is during the compilation phase (TRUE) or not (FALSE). */

    const COP * const cop = (compiling) ? &PL_compiling : PL_curcop;

    SV *categories = cop_hints_fetch_pvs(cop, "locale", 0);
    if (! categories || categories == &PL_sv_placeholder) {
        return FALSE;
    }

    /* The pseudo-category 'not_characters' is -1, so just add 1 to each to get
     * a valid unsigned */
    assert(category >= -1);
    return cBOOL(SvUV(categories) & (1U << (category + 1)));
}

char *
Perl_my_strerror(pTHX_ const int errnum) {
    dVAR;

    /* Uses C locale for the error text unless within scope of 'use locale' for
     * LC_MESSAGES */

#ifdef USE_LOCALE_MESSAGES
    if (! IN_LC(LC_MESSAGES)) {
        char * save_locale;

        /* We have a critical section to prevent another thread from changing
         * the locale out from under us (or zapping the buffer returned from
         * setlocale() ) */
        LOCALE_LOCK;

        save_locale = setlocale(LC_MESSAGES, NULL);
        if (! isNAME_C_OR_POSIX(save_locale)) {
            char *errstr;

            /* The next setlocale likely will zap this, so create a copy */
            save_locale = savepv(save_locale);

            setlocale(LC_MESSAGES, "C");

            /* This points to the static space in Strerror, with all its
             * limitations */
            errstr = Strerror(errnum);

            setlocale(LC_MESSAGES, save_locale);
            Safefree(save_locale);

            LOCALE_UNLOCK;

            return errstr;
        }

        LOCALE_UNLOCK;
    }
#endif

    return Strerror(errnum);
}

/*

=head1 Locale-related functions and macros

=for apidoc sync_locale

Changing the program's locale should be avoided by XS code.  Nevertheless,
certain non-Perl libraries called from XS, such as C<Gtk> do so.  When this
happens, Perl needs to be told that the locale has changed.  Use this function
to do so, before returning to Perl.

=cut
*/

void
Perl_sync_locale(pTHX)
{

#ifdef USE_LOCALE_CTYPE
    new_ctype(setlocale(LC_CTYPE, NULL));
#endif /* USE_LOCALE_CTYPE */

#ifdef USE_LOCALE_COLLATE
    new_collate(setlocale(LC_COLLATE, NULL));
#endif

#ifdef USE_LOCALE_NUMERIC
    set_numeric_local();    /* Switch from "C" to underlying LC_NUMERIC */
    new_numeric(setlocale(LC_NUMERIC, NULL));
#endif /* USE_LOCALE_NUMERIC */

}

#if defined(DEBUGGING) && defined(USE_LOCALE)

char *
Perl__setlocale_debug_string(const int category,        /* category number,
                                                           like LC_ALL */
                            const char* const locale,   /* locale name */

                            /* return value from setlocale() when attempting to
                             * set 'category' to 'locale' */
                            const char* const retval)
{
    /* Returns a pointer to a NUL-terminated string in static storage with
     * added text about the info passed in.  This is not thread safe and will
     * be overwritten by the next call, so this should be used just to
     * formulate a string to immediately print or savepv() on. */

    /* initialise to a non-null value to keep it out of BSS and so keep
     * -DPERL_GLOBAL_STRUCT_PRIVATE happy */
    static char ret[128] = "x";

    my_strlcpy(ret, "setlocale(", sizeof(ret));

    switch (category) {
        default:
            my_snprintf(ret, sizeof(ret), "%s? %d", ret, category);
            break;
#   ifdef LC_ALL
        case LC_ALL:
            my_strlcat(ret, "LC_ALL", sizeof(ret));
            break;
#   endif
#   ifdef LC_CTYPE
        case LC_CTYPE:
            my_strlcat(ret, "LC_CTYPE", sizeof(ret));
            break;
#   endif
#   ifdef LC_NUMERIC
        case LC_NUMERIC:
            my_strlcat(ret, "LC_NUMERIC", sizeof(ret));
            break;
#   endif
#   ifdef LC_COLLATE
        case LC_COLLATE:
            my_strlcat(ret, "LC_COLLATE", sizeof(ret));
            break;
#   endif
#   ifdef LC_TIME
        case LC_TIME:
            my_strlcat(ret, "LC_TIME", sizeof(ret));
            break;
#   endif
#   ifdef LC_MONETARY
        case LC_MONETARY:
            my_strlcat(ret, "LC_MONETARY", sizeof(ret));
            break;
#   endif
#   ifdef LC_MESSAGES
        case LC_MESSAGES:
            my_strlcat(ret, "LC_MESSAGES", sizeof(ret));
            break;
#   endif
    }

    my_strlcat(ret, ", ", sizeof(ret));

    if (locale) {
        my_strlcat(ret, "\"", sizeof(ret));
        my_strlcat(ret, locale, sizeof(ret));
        my_strlcat(ret, "\"", sizeof(ret));
    }
    else {
        my_strlcat(ret, "NULL", sizeof(ret));
    }

    my_strlcat(ret, ") returned ", sizeof(ret));

    if (retval) {
        my_strlcat(ret, "\"", sizeof(ret));
        my_strlcat(ret, retval, sizeof(ret));
        my_strlcat(ret, "\"", sizeof(ret));
    }
    else {
        my_strlcat(ret, "NULL", sizeof(ret));
    }

    assert(strlen(ret) < sizeof(ret));

    return ret;
}

#endif


/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d32 3
a34 1
 * the desired behavior of those functions at the moment.
a97 1
    dVAR;
d111 1
a111 1
            if (! is_ascii_string((U8 *) lc->decimal_point, 0)
d113 1
a113 1
                && is_cur_LC_category_utf8(LC_NUMERIC))
d122 4
a125 1
    DEBUG_L(PerlIO_printf(Perl_debug_log, "Locale radix is %s\n",
d127 2
a128 2
                                          ? lc->decimal_point
                                          : "NULL"));
d134 14
d167 1
a167 1
     * PL_numeric_name  The default locale's name: a copy of 'newnum'
d169 6
a174 3
     *                  that the current locale is the default locale
     * PL_numeric_standard A boolean indicating if the toggled state is such
     *                  that the current locale is the C locale
a184 1
    dVAR;
d195 4
d203 8
a211 3
    PL_numeric_standard = ((*save_newnum == 'C' && save_newnum[1] == '\0')
                            || strEQ(save_newnum, "POSIX"));
    PL_numeric_local = TRUE;
d214 2
d223 10
a232 12
    dVAR;

    /* Toggle the LC_NUMERIC locale to C, if not already there.  Probably
     * should use the macros like SET_NUMERIC_STANDARD() in perl.h instead of
     * calling this directly. */

    if (! PL_numeric_standard) {
	setlocale(LC_NUMERIC, "C");
	PL_numeric_standard = TRUE;
	PL_numeric_local = FALSE;
	set_numeric_radix();
    }
d243 5
a247 1
    dVAR;
d249 4
a252 10
    /* Toggle the LC_NUMERIC locale to the current underlying default, if not
     * already there.  Probably should use the macros like SET_NUMERIC_LOCAL()
     * in perl.h instead of calling this directly. */

    if (! PL_numeric_local) {
	setlocale(LC_NUMERIC, PL_numeric_name);
	PL_numeric_standard = FALSE;
	PL_numeric_local = TRUE;
	set_numeric_radix();
    }
d284 8
a291 1
    PL_in_utf8_CTYPE_locale = is_cur_LC_category_utf8(LC_CTYPE);
d299 12
d318 98
d426 26
a463 2
    dVAR;

d480 1
a480 2
	PL_collation_standard = ((*newcoll == 'C' && newcoll[1] == '\0')
				 || strEQ(newcoll, "POSIX"));
d498 2
d581 2
d588 1
a588 1
    /* Here the input locale was LC_ALL, and we have set it to what is in the
d597 3
d606 3
d615 3
d624 3
d633 3
d642 3
d648 4
a651 1
    return setlocale(LC_ALL, NULL);
d653 1
d675 36
a710 1
     */
a714 2
    dVAR;

d732 18
d764 4
a767 1
                                  || atoi(bad_lang_use_once))));
d769 8
d778 1
a778 1

d782 1
d792 3
a794 1
	if (my_setlocale(LC_ALL, setlocale_init))
d799 1
a799 1
    if (!setlocale_failure) {
d801 6
a806 5
	Safefree(curctype);
	if (! (curctype =
	       my_setlocale(LC_CTYPE,
			 (!done && (lang || PerlEnv_getenv("LC_CTYPE")))
				    ? setlocale_init : NULL)))
d812 6
a817 5
	Safefree(curcoll);
	if (! (curcoll =
	       my_setlocale(LC_COLLATE,
			 (!done && (lang || PerlEnv_getenv("LC_COLLATE")))
				   ? setlocale_init : NULL)))
d823 6
a828 5
	Safefree(curnum);
	if (! (curnum =
	       my_setlocale(LC_NUMERIC,
			 (!done && (lang || PerlEnv_getenv("LC_NUMERIC")))
				  ? setlocale_init : NULL)))
d834 6
a839 4
	if (! my_setlocale(LC_MESSAGES,
			 (!done && (lang || PerlEnv_getenv("LC_MESSAGES")))
				  ? setlocale_init : NULL))
        {
d844 6
a849 4
	if (! my_setlocale(LC_MONETARY,
			 (!done && (lang || PerlEnv_getenv("LC_MONETARY")))
				  ? setlocale_init : NULL))
        {
d860 3
a862 1
     * the list */
d875 2
a876 2
#ifdef WIN32

d885 1
d900 2
a901 1
#endif
d905 3
a907 1
        if (! my_setlocale(LC_ALL, trial_locale)) {
d925 3
a927 1
            if (! (curctype = my_setlocale(LC_CTYPE, trial_locale)))
d934 3
a936 1
            if (! (curcoll = my_setlocale(LC_COLLATE, trial_locale)))
d943 3
a945 1
            if (! (curnum = my_setlocale(LC_NUMERIC, trial_locale)))
d951 3
a953 1
            if (! (my_setlocale(LC_MESSAGES, trial_locale)))
d957 3
a959 1
            if (! (my_setlocale(LC_MONETARY, trial_locale)))
d984 1
a984 1
#ifdef USE_LOCALE_CTYPE
d987 2
a988 2
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
d991 2
a992 2
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
d995 1
a995 1
#endif /* USE_LOCALE_NUMERIC */
d1044 1
a1044 1
             * until we have to, becuase failure is quite unlikely.  This will
d1052 6
a1057 1
             * but there's no harm done by doing it explicitly */
d1122 1
d1127 1
d1132 1
d1143 1
d1150 1
d1184 1
a1184 1
    PL_utf8locale = is_cur_LC_category_utf8(LC_CTYPE);
a1206 2
#endif /* USE_LOCALE */

d1214 4
a1234 1
    dVAR;
d1286 2
a1287 2
STATIC bool
S_is_cur_LC_category_utf8(pTHX_ int category)
d1292 4
a1295 2
     * could give the wrong result.  It errs on the side of not being a UTF-8
     * locale. */
d1313 1
a1313 3
    if ((*save_input_locale == 'C' && save_input_locale[1] == '\0')
        || strEQ(save_input_locale, "POSIX"))
    {
d1332 1
a1332 1
            save_ctype_locale = stdize_locale(savepv(setlocale(LC_CTYPE, NULL)));
d1338 1
d1366 1
a1366 1
            char *codeset = savepv(nl_langinfo(CODESET));
d1368 1
a1385 1
            Safefree(codeset);
d1416 1
a1416 1
            if (mbtowc(&wc, HYPHEN_UTF8, strlen(HYPHEN_UTF8))
d1421 1
a1421 1
                DEBUG_L(PerlIO_printf(Perl_debug_log, "\thyphen=U+%x\n", wc));
d1441 196
a1636 1
#endif /* HAS_NL_LANGINFO etc */
d1638 76
a1713 2
    /* nl_langinfo not available or failed somehow.  Look at the locale name to
     * see if it matches qr/UTF -? 8 /ix  */
d1723 2
a1724 2
            if (toFOLD(*(name)) != 't'
                || toFOLD(*(name + 1)) != 'f')
a1735 1
                Safefree(save_input_locale);
d1739 1
d1747 1
d1766 4
a1769 1
    /* Other common encodings are the ISO 8859 series, which aren't UTF-8 */
d1777 1
d1779 30
a1808 1
#ifdef HAS_LOCALECONV
d1810 3
a1812 1
#   ifdef USE_LOCALE_MONETARY
d1814 2
a1815 9
    /* Here, there is nothing in the locale name to indicate whether the locale
     * is UTF-8 or not.  This "name", the return of setlocale(), is actually
     * defined to be opaque, so we can't really rely on the absence of various
     * substrings in the name to indicate its UTF-8ness.  Look at the locale's
     * currency symbol.  Often that will be in the native script, and if the
     * symbol isn't in UTF-8, we know that the locale isn't.  If it is
     * non-ASCII UTF-8, we infer that the locale is too.
     * To do this, like above for LC_CTYPE, we first set LC_MONETARY to the
     * locale of the desired category, if it isn't that locale already */
d1817 3
a1819 5
    {
        char *save_monetary_locale = NULL;
        bool illegal_utf8 = FALSE;
        bool only_ascii = FALSE;
        const struct lconv* const lc = localeconv();
d1821 4
a1824 1
        if (category != LC_MONETARY) {
d1826 3
a1828 7
            save_monetary_locale = stdize_locale(savepv(setlocale(LC_MONETARY,
                                                                  NULL)));
            if (! save_monetary_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_MONETARY\n"));
                goto cant_use_monetary;
            }
d1830 2
a1831 10
            if (strNE(save_monetary_locale, save_input_locale)) {
                if (! setlocale(LC_MONETARY, save_input_locale)) {
                    DEBUG_L(PerlIO_printf(Perl_debug_log,
                                "Could not change LC_MONETARY locale to %s\n",
                                                            save_input_locale));
                    Safefree(save_monetary_locale);
                    goto cant_use_monetary;
                }
            }
        }
d1833 1
a1833 2
        /* Here the current LC_MONETARY is set to the locale of the category
         * whose information is desired. */
d1835 3
a1837 12
        if (lc && lc->currency_symbol) {
            if (! is_utf8_string((U8 *) lc->currency_symbol, 0)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Currency symbol for %s is not legal UTF-8\n",
                                        save_input_locale));
                illegal_utf8 = TRUE;
            }
            else if (is_ascii_string((U8 *) lc->currency_symbol, 0)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log, "Currency symbol for %s contains only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
                only_ascii = TRUE;
            }
        }
d1839 2
a1840 5
        /* If we changed it, restore LC_MONETARY to its original locale */
        if (save_monetary_locale) {
            setlocale(LC_MONETARY, save_monetary_locale);
            Safefree(save_monetary_locale);
        }
d1842 1
a1842 1
        Safefree(save_input_locale);
d1844 2
a1845 11
        /* It isn't a UTF-8 locale if the symbol is not legal UTF-8; otherwise
         * assume the locale is UTF-8 if and only if the symbol is non-ascii
         * UTF-8.  (We can't really tell if the locale is UTF-8 or not if the
         * symbol is just a '$', so we err on the side of it not being UTF-8)
         * */
        DEBUG_L(PerlIO_printf(Perl_debug_log, "\tis_utf8=%d\n", (illegal_utf8)
                                                               ? FALSE
                                                               : ! only_ascii));
        return (illegal_utf8)
                ? FALSE
                : ! only_ascii;
d1847 1
d1849 1
a1849 1
  cant_use_monetary:
d1851 2
a1852 2
#   endif /* USE_LOCALE_MONETARY */
#endif /* HAS_LOCALECONV */
d1854 1
a1854 1
#if 0 && defined(HAS_STRERROR) && defined(USE_LOCALE_MESSAGES)
d1856 1
a1856 17
/* This code is ifdefd out because it was found to not be necessary in testing
 * on our dromedary test machine, which has over 700 locales.  There, looking
 * at just the currency symbol gave essentially the same results as doing this
 * extra work.  Executing this also caused segfaults in miniperl.  I left it in
 * so as to avoid rewriting it if real-world experience indicates that
 * dromedary is an outlier.  Essentially, instead of returning abpve if we
 * haven't found illegal utf8, we continue on and examine all the strerror()
 * messages on the platform for utf8ness.  If all are ASCII, we still don't
 * know the answer; but otherwise we have a pretty good indication of the
 * utf8ness.  The reason this doesn't necessarily help much is that the
 * messages may not have been translated into the locale.  The currency symbol
 * is much more likely to have been translated.  The code below would need to
 * be altered somewhat to just be a continuation of testing the currency
 * symbol. */
        int e;
        unsigned int failures = 0, non_ascii = 0;
        char *save_messages_locale = NULL;
d1858 1
a1858 2
        /* Like above for LC_CTYPE, we set LC_MESSAGES to the locale of the
         * desired category, if it isn't that locale already */
d1860 4
a1863 1
        if (category != LC_MESSAGES) {
d1865 2
a1866 5
            save_messages_locale = stdize_locale(savepv(setlocale(LC_MESSAGES,
                                                                  NULL)));
            if (! save_messages_locale) {
                goto cant_use_messages;
            }
d1868 3
a1870 8
            if (strEQ(save_messages_locale, save_input_locale)) {
                Safefree(save_input_locale);
            }
            else if (! setlocale(LC_MESSAGES, save_input_locale)) {
                Safefree(save_messages_locale);
                goto cant_use_messages;
            }
        }
d1872 3
a1874 2
        /* Here the current LC_MESSAGES is set to the locale of the category
         * whose information is desired.  Look through all the messages */
d1876 2
a1877 3
        for (e = 0;
#ifdef HAS_SYS_ERRLIST
             e <= sys_nerr
a1878 13
             ; e++)
        {
            const U8* const errmsg = (U8 *) Strerror(e) ;
            if (!errmsg)
                break;
            if (! is_utf8_string(errmsg, 0)) {
                failures++;
                break;
            }
            else if (! is_ascii_string(errmsg, 0)) {
                non_ascii++;
            }
        }
d1880 80
a1959 5
        /* And, if we changed it, restore LC_MESSAGES to its original locale */
        if (save_messages_locale) {
            setlocale(LC_MESSAGES, save_messages_locale);
            Safefree(save_messages_locale);
        }
d1961 1
a1961 3
        /* Any non-UTF-8 message means not a UTF-8 locale; if all are valid,
         * any non-ascii means it is one; otherwise we assume it isn't */
        return (failures) ? FALSE : non_ascii;
d1963 7
a1970 1
  cant_use_messages:
d1972 1
a1972 1
#endif
d1974 1
a1974 5
    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Assuming locale %s is not a UTF-8 locale\n",
                                    save_input_locale));
    Safefree(save_input_locale);
    return FALSE;
d1979 1
a1980 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
 *    Copyright (c) 2001-2002, Larry Wall
d12 21
a32 7
 * A Elbereth Gilthoniel,
 * silivren penna mriel
 * o menel aglar elenath!
 * Na-chaered palan-driel
 * o galadhremmin ennorath,
 * Fanuilos, le linnathon
 * nef aear, si nef aearon!
a38 4
#ifdef I_LOCALE
#  include <locale.h>
#endif

d45 2
d48 2
a49 1
 * Standardize the locale name from a string returned by 'setlocale'.
d51 1
a51 1
 * The standard return value of setlocale() is either
d55 1
a55 1
 *      in some unspecificed order)
d58 2
a59 1
 * which is harmful for further use of the string in setlocale().
d65 1
a65 1
    char *s;
d68 1
a68 2
    if ((s = strchr(locs, '='))) {
	char *t;
d70 2
d73 7
a79 11
	if ((t = strchr(s, '.'))) {
	    char *u;

	    if ((u = strchr(t, '\n'))) {

		if (u[1] == 0) {
		    STRLEN len = u - s;
		    Move(s + 1, locs, len, char);
		    locs[len] = 0;
		    okay = TRUE;
		}
d90 2
d96 1
d98 1
a98 1
    struct lconv* lc;
a99 1
    lc = localeconv();
d103 1
a103 1
	    PL_numeric_radix_sv = Nullsv;
d110 6
d119 7
a125 1
	PL_numeric_radix_sv = Nullsv;
a129 3
/*
 * Set up for a new numeric locale.
 */
d131 1
a131 1
Perl_new_numeric(pTHX_ char *newnum)
d135 31
d167 2
a168 4
	if (PL_numeric_name) {
	    Safefree(PL_numeric_name);
	    PL_numeric_name = NULL;
	}
d174 2
a175 1
    if (! PL_numeric_name || strNE(PL_numeric_name, newnum)) {
d177 1
a177 4
	PL_numeric_name = stdize_locale(savepv(newnum));
	PL_numeric_standard = (strEQ(newnum, "C") || strEQ(newnum, "POSIX"));
	PL_numeric_local = TRUE;
	set_numeric_radix();
d180 5
d192 5
d204 2
d214 5
d226 3
d237 1
a237 1
Perl_new_ctype(pTHX_ char *newctype)
d241 32
a272 9
    int i;

    for (i = 0; i < 256; i++) {
	if (isUPPER_LC(i))
	    PL_fold_locale[i] = toLOWER_LC(i);
	else if (isLOWER_LC(i))
	    PL_fold_locale[i] = toUPPER_LC(i);
	else
	    PL_fold_locale[i] = i;
d276 3
a280 3
/*
 * Set up for a new collation locale.
 */
d282 1
a282 1
Perl_new_collate(pTHX_ char *newcoll)
d286 10
d312 2
a313 1
	PL_collation_standard = (strEQ(newcoll, "C") || strEQ(newcoll, "POSIX"));
d320 6
a325 5
	  Size_t fa = strxfrm(xbuf, "a",  XFRMBUFSIZE);
	  Size_t fb = strxfrm(xbuf, "ab", XFRMBUFSIZE);
	  SSize_t mult = fb - fa;
	  if (mult < 1)
	      Perl_croak(aTHX_ "strxfrm() gets absurd");
d334 132
d472 7
a478 2
    int ok = 1;
    /* returns
d480 2
a481 2
     *    0 = fallback to C locale,
     *   -1 = fallback to C locale failed
d484 2
d487 1
d499 1
a499 1
    char *language   = PerlEnv_getenv("LANGUAGE");
d501 9
a509 2
    char *lc_all     = PerlEnv_getenv("LC_ALL");
    char *lang       = PerlEnv_getenv("LANG");
d511 2
d514 14
a527 1
#ifdef LOCALE_ENVIRON_REQUIRED
d534 1
a534 3
    bool done = FALSE;

#ifdef LC_ALL
d536 1
a536 1
	if (setlocale(LC_ALL, ""))
d542 2
a543 1
#ifdef USE_LOCALE_CTYPE
d545 1
a545 1
	       setlocale(LC_CTYPE,
d547 1
a547 1
				    ? "" : Nullch)))
d551 3
a553 2
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
d555 1
a555 1
	       setlocale(LC_COLLATE,
d557 1
a557 1
				   ? "" : Nullch)))
d561 3
a563 2
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
d565 1
a565 1
	       setlocale(LC_NUMERIC,
d567 1
a567 1
				  ? "" : Nullch)))
d571 17
a587 1
#endif /* USE_LOCALE_NUMERIC */
d590 1
a590 1
#endif /* LC_ALL */
d594 41
d636 13
a648 2
    if (! setlocale(LC_ALL, ""))
	setlocale_failure = TRUE;
d651 1
a651 1
    if (!setlocale_failure) {
d653 5
a657 4
	if (! (curctype = setlocale(LC_CTYPE, "")))
	    setlocale_failure = TRUE;
	else
	    curctype = savepv(curctype);
d660 5
a664 4
	if (! (curcoll = setlocale(LC_COLLATE, "")))
	    setlocale_failure = TRUE;
	else
	    curcoll = savepv(curcoll);
d667 5
a671 4
	if (! (curnum = setlocale(LC_NUMERIC, "")))
	    setlocale_failure = TRUE;
	else
	    curnum = savepv(curnum);
d673 16
a688 1
    }
d690 2
a691 5
    if (setlocale_failure) {
	char *p;
	bool locwarn = (printwarn > 1 ||
			(printwarn &&
			 (!(p = PerlEnv_getenv("PERL_BADLANG")) || atoi(p))));
d693 1
a693 1
	if (locwarn) {
d696 2
a697 2
	    PerlIO_printf(Perl_error_log,
	       "perl: warning: Setting locale failed.\n");
d701 2
a702 2
	    PerlIO_printf(Perl_error_log,
	       "perl: warning: Setting locale failed for the categories:\n\t");
d704 2
a705 2
	    if (! curctype)
		PerlIO_printf(Perl_error_log, "LC_CTYPE ");
d708 2
a709 2
	    if (! curcoll)
		PerlIO_printf(Perl_error_log, "LC_COLLATE ");
d712 2
a713 2
	    if (! curnum)
		PerlIO_printf(Perl_error_log, "LC_NUMERIC ");
d715 1
a715 1
	    PerlIO_printf(Perl_error_log, "\n");
d719 2
a720 2
	    PerlIO_printf(Perl_error_log,
		"perl: warning: Please check that your locale settings:\n");
d723 5
a727 5
	    PerlIO_printf(Perl_error_log,
			  "\tLANGUAGE = %c%s%c,\n",
			  language ? '"' : '(',
			  language ? language : "unset",
			  language ? '"' : ')');
d730 5
a734 5
	    PerlIO_printf(Perl_error_log,
			  "\tLC_ALL = %c%s%c,\n",
			  lc_all ? '"' : '(',
			  lc_all ? lc_all : "unset",
			  lc_all ? '"' : ')');
d737 10
a746 10
	    {
	      char **e;
	      for (e = environ; *e; e++) {
		  if (strnEQ(*e, "LC_", 3)
			&& strnNE(*e, "LC_ALL=", 7)
			&& (p = strchr(*e, '=')))
		      PerlIO_printf(Perl_error_log, "\t%.*s = \"%s\",\n",
				    (int)(p - *e), *e, p + 1);
	      }
	    }
d748 2
a749 2
	    PerlIO_printf(Perl_error_log,
			  "\t(possibly more locale environment variables)\n");
d752 49
a800 5
	    PerlIO_printf(Perl_error_log,
			  "\tLANG = %c%s%c\n",
			  lang ? '"' : '(',
			  lang ? lang : "unset",
			  lang ? '"' : ')');
d802 6
a807 3
	    PerlIO_printf(Perl_error_log,
			  "    are supported and installed on your system.\n");
	}
d809 2
a810 1
#ifdef LC_ALL
d812 3
a814 12
	if (setlocale(LC_ALL, "C")) {
	    if (locwarn)
		PerlIO_printf(Perl_error_log,
      "perl: warning: Falling back to the standard locale (\"C\").\n");
	    ok = 0;
	}
	else {
	    if (locwarn)
		PerlIO_printf(Perl_error_log,
      "perl: warning: Failed to fall back to the standard locale (\"C\").\n");
	    ok = -1;
	}
d816 1
a816 1
#else /* ! LC_ALL */
d818 10
a827 17
	if (0
#ifdef USE_LOCALE_CTYPE
	    || !(curctype || setlocale(LC_CTYPE, "C"))
#endif /* USE_LOCALE_CTYPE */
#ifdef USE_LOCALE_COLLATE
	    || !(curcoll || setlocale(LC_COLLATE, "C"))
#endif /* USE_LOCALE_COLLATE */
#ifdef USE_LOCALE_NUMERIC
	    || !(curnum || setlocale(LC_NUMERIC, "C"))
#endif /* USE_LOCALE_NUMERIC */
	    )
	{
	    if (locwarn)
		PerlIO_printf(Perl_error_log,
      "perl: warning: Cannot fall back to the standard locale (\"C\").\n");
	    ok = -1;
	}
d829 2
a830 1
#endif /* ! LC_ALL */
d832 1
d834 2
a835 1
	curctype = savepv(setlocale(LC_CTYPE, Nullch));
d838 2
a839 1
	curcoll = savepv(setlocale(LC_COLLATE, Nullch));
d842 2
a843 1
	curnum = savepv(setlocale(LC_NUMERIC, Nullch));
d845 29
a873 2
    }
    else {
d887 11
a897 5
    }

#endif /* USE_LOCALE */

#ifdef USE_PERLIO
d899 4
a902 44
      /* Set PL_wantutf8 to TRUE if using PerlIO _and_
	 any of the following are true:
	 - nl_langinfo(CODESET) contains /^utf-?8/i
	 - $ENV{LANGUAGE} contains /^utf-?8/i (only if using glibc)
	 - $ENV{LC_CALL} contains /^utf-?8/i
	 - $ENV{LC_CTYPE} contains /^utf-?8/i
	 - $ENV{LANG} contains /^utf-?8/i
	 If PL_wantutf8 is true, perl.c:S_parse_body()
	 will turn on the PerlIO :utf8 discipline on STDIN, STDOUT,
	 STDERR, _and_ the default open discipline.
      */
	 bool wantutf8 = FALSE;
	 char *codeset = NULL;
#if defined(HAS_NL_LANGINFO) && defined(CODESET)
	 codeset = nl_langinfo(CODESET);
#endif
	 if (codeset &&
	     (ibcmp(codeset,  "UTF-8", 5) == 0 ||
	      ibcmp(codeset,  "UTF8",  4) == 0))
	      wantutf8 = TRUE;
#if defined(USE_LOCALE)
#ifdef __GLIBC__
	 if (!wantutf8 && language &&
	     (ibcmp(language, "UTF-8", 5) == 0 ||
	      ibcmp(language, "UTF8",  4) == 0))
	      wantutf8 = TRUE;
#endif
	 if (!wantutf8 && lc_all &&
	     (ibcmp(lc_all,   "UTF-8", 5) == 0 ||
	      ibcmp(lc_all,   "UTF8",  4) == 0))
	      wantutf8 = TRUE;
#ifdef USE_LOCALE_CTYPE
	 if (!wantutf8 && curctype &&
	     (ibcmp(curctype,     "UTF-8", 5) == 0 ||
	      ibcmp(curctype,     "UTF8",  4) == 0))
	      wantutf8 = TRUE;
#endif
	 if (!wantutf8 && lang &&
	     (ibcmp(lang,     "UTF-8", 5) == 0 ||
	      ibcmp(lang,     "UTF8",  4) == 0))
	      wantutf8 = TRUE;
#endif /* USE_LOCALE */
	 if (wantutf8)
	      PL_wantutf8 = TRUE;
d907 1
a907 2
    if (curctype != NULL)
	Safefree(curctype);
d910 1
a910 2
    if (curcoll != NULL)
	Safefree(curcoll);
d913 1
a913 2
    if (curnum != NULL)
	Safefree(curnum);
d915 10
a927 6
/* Backwards compatibility. */
int
Perl_init_i18nl14n(pTHX_ int printwarn)
{
    return init_i18nl10n(printwarn);
}
d938 1
d942 1
d946 2
d952 1
a952 1
    New(171, xbuf, xAlloc, char);
d959 1
a959 1
	SSize_t xused;
d963 1
a963 1
	    if (xused == -1)
d992 397
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d478 1
a478 1
      /* Set PL_utf8locale to TRUE if using PerlIO _and_
d481 2
a482 1
	 - $ENV{LC_ALL}   contains /^utf-?8/i
d484 4
a487 10
	 - $ENV{LANG}     contains /^utf-?8/i
	 The LC_ALL, LC_CTYPE, LANG obey the usual override
	 hierarchy of locale environment variables.  (LANGUAGE
	 affects only LC_MESSAGES only under glibc.) (If present,
	 it overrides LC_MESSAGES for GNU gettext, and it also
	 can have more than one locale, separated by spaces,
	 in case you need to know.)
	 If PL_utf8locale and PL_unicode (set by -C or by $ENV{PERL_UNICODE})
         are true, perl.c:S_parse_body() will turn on the PerlIO :utf8 layer
	 on STDIN, STDOUT, STDERR, _and_ the default open discipline.
d489 1
a489 1
	 bool utf8locale = FALSE;
d494 4
a497 3
	 if (codeset)
	      utf8locale = (ibcmp(codeset,  "UTF-8", 5) == 0 ||
 			    ibcmp(codeset,  "UTF8",  4) == 0);
d499 10
a508 6
	 else { /* nl_langinfo(CODESET) is supposed to correctly
		 * interpret the locale environment variables,
		 * but just in case it fails, let's do this manually. */ 
	      if (lang)
		   utf8locale = (ibcmp(lang,     "UTF-8", 5) == 0 ||
			         ibcmp(lang,     "UTF8",  4) == 0);
d510 4
a513 3
	      if (curctype)
		   utf8locale = (ibcmp(curctype,     "UTF-8", 5) == 0 ||
			         ibcmp(curctype,     "UTF8",  4) == 0);
d515 4
a518 4
	      if (lc_all)
		   utf8locale = (ibcmp(lc_all,   "UTF-8", 5) == 0 ||
			         ibcmp(lc_all,   "UTF8",  4) == 0);
	 }
d520 2
a521 9
	 if (utf8locale)
	      PL_utf8locale = TRUE;
    }
    /* Set PL_unicode to $ENV{PERL_UNICODE} if using PerlIO.
       This is an alternative to using the -C command line switch
       (the -C if present will override this). */
    {
	 char *p = PerlEnv_getenv("PERL_UNICODE");
	 PL_unicode = p ? parse_unicode_opts(&p) : 0;
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@a20 4
/* utility functions for handling locale-specific stuff like what
 * character represents the decimal point.
 */

a562 1

@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2005, by Larry Wall and others
a38 1
#if defined(USE_LOCALE_NUMERIC) || defined(USE_LOCALE_COLLATE)
d55 1
a55 1
    const char *s = strchr(locs, '=');
d58 3
a60 2
    if (s) {
	const char * const t = strchr(s, '.');
d62 11
a72 7
	if (t) {
	    const char * const u = strchr(t, '\n');
	    if (u && (u[1] == 0)) {
		const STRLEN len = u - s;
		Move(s + 1, locs, len, char);
		locs[len] = 0;
		okay = TRUE;
a81 1
#endif
d118 4
a121 2
	Safefree(PL_numeric_name);
	PL_numeric_name = NULL;
d130 1
a130 2
	PL_numeric_standard = ((*newnum == 'C' && newnum[1] == '\0')
			       || strEQ(newnum, "POSIX"));
d175 1
a187 1
    PERL_UNUSED_ARG(newctype);
d214 1
a214 2
	PL_collation_standard = ((*newcoll == 'C' && newcoll[1] == '\0')
				 || strEQ(newcoll, "POSIX"));
d221 3
a223 3
	  const Size_t fa = strxfrm(xbuf, "a",  XFRMBUFSIZE);
	  const Size_t fb = strxfrm(xbuf, "ab", XFRMBUFSIZE);
	  const SSize_t mult = fb - fa;
d537 2
a538 1
    Safefree(curctype);
d541 2
a542 1
    Safefree(curcoll);
d545 2
a546 1
    Safefree(curnum);
d578 1
a578 1
    Newx(xbuf, xAlloc, char);
a617 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall and others
d56 1
a56 1
    const char * const s = strchr(locs, '=');
a83 1
    dVAR;
d85 1
a85 1
    const struct lconv* const lc = localeconv();
d87 1
d91 1
a91 1
	    PL_numeric_radix_sv = NULL;
d101 1
a101 1
	PL_numeric_radix_sv = NULL;
d110 1
a110 1
Perl_new_numeric(pTHX_ const char *newnum)
a112 1
    dVAR;
a137 1
    dVAR;
a152 1
    dVAR;
d168 1
a168 1
Perl_new_ctype(pTHX_ const char *newctype)
a170 1
    dVAR;
a183 1
    PERL_UNUSED_CONTEXT;
d190 1
a190 1
Perl_new_collate(pTHX_ const char *newcoll)
a192 1
    dVAR;
a244 1
    dVAR;
d256 1
a256 1
    char * const language   = PerlEnv_getenv("LANGUAGE");
d258 2
a259 2
    char * const lc_all     = PerlEnv_getenv("LC_ALL");
    char * const lang       = PerlEnv_getenv("LANG");
a279 1
	Safefree(curctype);
d283 1
a283 1
				    ? "" : NULL)))
a288 1
	Safefree(curcoll);
d292 1
a292 1
				   ? "" : NULL)))
a297 1
	Safefree(curnum);
d301 1
a301 1
				  ? "" : NULL)))
a318 1
	Safefree(curctype);
a324 1
	Safefree(curcoll);
a330 1
	Safefree(curnum);
d340 1
a340 1
	const bool locwarn = (printwarn > 1 ||
d451 1
a451 2
	Safefree(curctype);
	curctype = savepv(setlocale(LC_CTYPE, NULL));
d454 1
a454 2
	Safefree(curcoll);
	curcoll = savepv(setlocale(LC_COLLATE, NULL));
d457 1
a457 2
	Safefree(curnum);
	curnum = savepv(setlocale(LC_NUMERIC, NULL));
d502 2
a503 2
	      utf8locale = (Perl_ibcmp(aTHX_ codeset, STR_WITH_LEN("UTF-8")) == 0 ||
 			    Perl_ibcmp(aTHX_ codeset, STR_WITH_LEN("UTF8") ) == 0);
d509 2
a510 2
		   utf8locale = (Perl_ibcmp(aTHX_ lang, STR_WITH_LEN("UTF-8")) == 0 ||
			         Perl_ibcmp(aTHX_ lang, STR_WITH_LEN("UTF8") ) == 0);
d513 2
a514 2
		   utf8locale = (Perl_ibcmp(aTHX_ curctype, STR_WITH_LEN("UTF-8")) == 0 ||
			         Perl_ibcmp(aTHX_ curctype, STR_WITH_LEN("UTF8") ) == 0);
d517 2
a518 2
		   utf8locale = (Perl_ibcmp(aTHX_ lc_all, STR_WITH_LEN("UTF-8")) == 0 ||
			         Perl_ibcmp(aTHX_ lc_all, STR_WITH_LEN("UTF8") ) == 0);
d528 1
a528 1
	 const char *p = PerlEnv_getenv("PERL_UNICODE");
a529 2
	 if (PL_unicode & PERL_UNICODE_UTF8CACHEASSERT_FLAG)
	     PL_utf8cache = -1;
d545 7
a564 1
    dVAR;
d579 1
a579 1
	Size_t xused;
d583 1
a583 1
	    if (xused >= PERL_INT_MAX)
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 7
a18 9
 *      A Elbereth Gilthoniel,
 *      silivren penna mriel
 *      o menel aglar elenath!
 *      Na-chaered palan-driel
 *      o galadhremmin ennorath,
 *      Fanuilos, le linnathon
 *      nef aear, si nef aearon!
 *
 *     [p.238 of _The Lord of the Rings_, II/i: "Many Meetings"]
a58 2
    PERL_ARGS_ASSERT_STDIZE_LOCALE;

a176 2
    PERL_ARGS_ASSERT_NEW_CTYPE;

a186 1
    PERL_ARGS_ASSERT_NEW_CTYPE;
a578 2

    PERL_ARGS_ASSERT_MEM_COLLXFRM;
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d525 2
a526 2
	      utf8locale = (ibcmp(codeset, STR_WITH_LEN("UTF-8")) == 0 ||
			    ibcmp(codeset, STR_WITH_LEN("UTF8") ) == 0);
d532 2
a533 2
		   utf8locale = (ibcmp(lang, STR_WITH_LEN("UTF-8")) == 0 ||
			         ibcmp(lang, STR_WITH_LEN("UTF8") ) == 0);
d536 2
a537 2
		   utf8locale = (ibcmp(curctype, STR_WITH_LEN("UTF-8")) == 0 ||
			         ibcmp(curctype, STR_WITH_LEN("UTF8") ) == 0);
d540 2
a541 2
		   utf8locale = (ibcmp(lc_all, STR_WITH_LEN("UTF-8")) == 0 ||
			         ibcmp(lc_all, STR_WITH_LEN("UTF8") ) == 0);
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
 *      silivren penna míriel
d15 1
a15 1
 *      Na-chaered palan-díriel
d31 4
d49 1
a49 1
 *      in some unspecified order)
d234 2
a235 3
	  if (mult < 1 && !(fa == 0 && fb == 0))
	      Perl_croak(aTHX_ "panic: strxfrm() gets absurd - a => %"UVuf", ab => %"UVuf,
			 (UV) fa, (UV) fb);
d525 2
a526 2
	      utf8locale = (foldEQ(codeset, STR_WITH_LEN("UTF-8"))
			    || foldEQ(codeset, STR_WITH_LEN("UTF8") ));
d532 2
a533 2
		   utf8locale = (foldEQ(lang, STR_WITH_LEN("UTF-8"))
				 || foldEQ(lang, STR_WITH_LEN("UTF8") ));
d536 2
a537 2
		   utf8locale = (foldEQ(curctype, STR_WITH_LEN("UTF-8"))
				 || foldEQ(curctype, STR_WITH_LEN("UTF8") ));
d540 2
a541 2
		   utf8locale = (foldEQ(lc_all, STR_WITH_LEN("UTF-8"))
				 || foldEQ(lc_all, STR_WITH_LEN("UTF8") ));
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d634 1
a634 1
 * indent-tabs-mode: nil
d637 1
a637 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@a24 8
 *
 * All C programs have an underlying locale.  Perl generally doesn't pay any
 * attention to it except within the scope of a 'use locale'.  For most
 * categories, it accomplishes this by just using different operations if it is
 * in such scope than if not.  However, various libc functions called by Perl
 * are affected by the LC_NUMERIC category, so there are macros in perl.h that
 * are used to toggle between the current locale and the C locale depending on
 * the desired behavior of those functions at the moment.
d37 1
a37 2
#ifdef USE_LOCALE

d39 1
a39 2
 * Standardize the locale name from a string returned by 'setlocale', possibly
 * modifying that string.
d41 1
a41 1
 * The typical return value of setlocale() is either
d45 1
a45 1
 *      in some unspecified order).  This is not handled by this function.
d48 1
a48 2
 * which is harmful for further use of the string in setlocale().  This
 * function removes the trailing new line and everything up through the '='
a77 1

a97 6
            if (! is_ascii_string((U8 *) lc->decimal_point, 0)
                && is_utf8_string((U8 *) lc->decimal_point, 0)
                && is_cur_LC_category_utf8(LC_NUMERIC))
            {
		SvUTF8_on(PL_numeric_radix_sv);
            }
a101 6

    DEBUG_L(PerlIO_printf(Perl_debug_log, "Locale radix is %s\n",
                                          (PL_numeric_radix_sv)
                                          ? lc->decimal_point
                                          : "NULL"));

d106 3
a112 30

    /* Called after all libc setlocale() calls affecting LC_NUMERIC, to tell
     * core Perl this and that 'newnum' is the name of the new locale.
     * It installs this locale as the current underlying default.
     *
     * The default locale and the C locale can be toggled between by use of the
     * set_numeric_local() and set_numeric_standard() functions, which should
     * probably not be called directly, but only via macros like
     * SET_NUMERIC_STANDARD() in perl.h.
     *
     * The toggling is necessary mainly so that a non-dot radix decimal point
     * character can be output, while allowing internal calculations to use a
     * dot.
     *
     * This sets several interpreter-level variables:
     * PL_numeric_name  The default locale's name: a copy of 'newnum'
     * PL_numeric_local A boolean indicating if the toggled state is such
     *                  that the current locale is the default locale
     * PL_numeric_standard A boolean indicating if the toggled state is such
     *                  that the current locale is the C locale
     * Note that both of the last two variables can be true at the same time,
     * if the underlying locale is C.  (Toggling is a no-op under these
     * circumstances.)
     *
     * Any code changing the locale (outside this file) should use
     * POSIX::setlocale, which calls this function.  Therefore this function
     * should be called directly only from this file and from
     * POSIX::setlocale() */

    char *save_newnum;
d123 1
a123 2
    save_newnum = stdize_locale(savepv(newnum));
    if (! PL_numeric_name || strNE(PL_numeric_name, save_newnum)) {
d125 5
a129 1
	PL_numeric_name = save_newnum;
a131 5
    PL_numeric_standard = ((*save_newnum == 'C' && save_newnum[1] == '\0')
                            || strEQ(save_newnum, "POSIX"));
    PL_numeric_local = TRUE;
    set_numeric_radix();

a140 4
    /* Toggle the LC_NUMERIC locale to C, if not already there.  Probably
     * should use the macros like SET_NUMERIC_STANDARD() in perl.h instead of
     * calling this directly. */

a146 2
    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Underlying LC_NUMERIC locale now is C\n"));
a156 4
    /* Toggle the LC_NUMERIC locale to the current underlying default, if not
     * already there.  Probably should use the macros like SET_NUMERIC_LOCAL()
     * in perl.h instead of calling this directly. */

a162 3
    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Underlying LC_NUMERIC locale now is %s\n",
                          PL_numeric_name));
a173 12

    /* Called after all libc setlocale() calls affecting LC_CTYPE, to tell
     * core Perl this and that 'newctype' is the name of the new locale.
     *
     * This function sets up the folding arrays for all 256 bytes, assuming
     * that tofold() is tolc() since fold case is not a concept in POSIX,
     *
     * Any code changing the locale (outside this file) should use
     * POSIX::setlocale, which calls this function.  Therefore this function
     * should be called directly only from this file and from
     * POSIX::setlocale() */

d175 1
a175 1
    UV i;
d179 7
a185 16
    PL_in_utf8_CTYPE_locale = is_cur_LC_category_utf8(LC_CTYPE);

    /* A UTF-8 locale gets standard rules.  But note that code still has to
     * handle this specially because of the three problematic code points */
    if (PL_in_utf8_CTYPE_locale) {
        Copy(PL_fold_latin1, PL_fold_locale, 256, U8);
    }
    else {
        for (i = 0; i < 256; i++) {
            if (isUPPER_LC((U8) i))
                PL_fold_locale[i] = (U8) toLOWER_LC((U8) i);
            else if (isLOWER_LC((U8) i))
                PL_fold_locale[i] = (U8) toUPPER_LC((U8) i);
            else
                PL_fold_locale[i] = (U8) i;
        }
d194 3
a200 9

    /* Called after all libc setlocale() calls affecting LC_COLLATE, to tell
     * core Perl this and that 'newcoll' is the name of the new locale.
     *
     * Any code changing the locale (outside this file) should use
     * POSIX::setlocale, which calls this function.  Therefore this function
     * should be called directly only from this file and from
     * POSIX::setlocale() */

a240 132
#ifdef WIN32

char *
Perl_my_setlocale(pTHX_ int category, const char* locale)
{
    /* This, for Windows, emulates POSIX setlocale() behavior.  There is no
     * difference unless the input locale is "", which means on Windows to get
     * the machine default, which is set via the computer's "Regional and
     * Language Options" (or its current equivalent).  In POSIX, it instead
     * means to find the locale from the user's environment.  This routine
     * looks in the environment, and, if anything is found, uses that instead
     * of going to the machine default.  If there is no environment override,
     * the machine default is used, as normal, by calling the real setlocale()
     * with "".  The POSIX behavior is to use the LC_ALL variable if set;
     * otherwise to use the particular category's variable if set; otherwise to
     * use the LANG variable. */

    bool override_LC_ALL = 0;
    char * result;

    if (locale && strEQ(locale, "")) {
#   ifdef LC_ALL
        locale = PerlEnv_getenv("LC_ALL");
        if (! locale) {
#endif
            switch (category) {
#   ifdef LC_ALL
                case LC_ALL:
                    override_LC_ALL = TRUE;
                    break;  /* We already know its variable isn't set */
#   endif
#   ifdef USE_LOCALE_TIME
                case LC_TIME:
                    locale = PerlEnv_getenv("LC_TIME");
                    break;
#   endif
#   ifdef USE_LOCALE_CTYPE
                case LC_CTYPE:
                    locale = PerlEnv_getenv("LC_CTYPE");
                    break;
#   endif
#   ifdef USE_LOCALE_COLLATE
                case LC_COLLATE:
                    locale = PerlEnv_getenv("LC_COLLATE");
                    break;
#   endif
#   ifdef USE_LOCALE_MONETARY
                case LC_MONETARY:
                    locale = PerlEnv_getenv("LC_MONETARY");
                    break;
#   endif
#   ifdef USE_LOCALE_NUMERIC
                case LC_NUMERIC:
                    locale = PerlEnv_getenv("LC_NUMERIC");
                    break;
#   endif
#   ifdef USE_LOCALE_MESSAGES
                case LC_MESSAGES:
                    locale = PerlEnv_getenv("LC_MESSAGES");
                    break;
#   endif
                default:
                    /* This is a category, like PAPER_SIZE that we don't
                     * know about; and so can't provide a wrapper. */
                    break;
            }
            if (! locale) {
                locale = PerlEnv_getenv("LANG");
                if (! locale) {
                    locale = "";
                }
            }
#   ifdef LC_ALL
        }
#   endif
    }

    result = setlocale(category, locale);

    if (! override_LC_ALL)  {
        return result;
    }

    /* Here the input locale was LC_ALL, and we have set it to what is in the
     * LANG variable or the system default if there is no LANG.  But these have
     * lower priority than the other LC_foo variables, so override it for each
     * one that is set.  (If they are set to "", it means to use the same thing
     * we just set LC_ALL to, so can skip) */
#   ifdef USE_LOCALE_TIME
    result = PerlEnv_getenv("LC_TIME");
    if (result && strNE(result, "")) {
        setlocale(LC_TIME, result);
    }
#   endif
#   ifdef USE_LOCALE_CTYPE
    result = PerlEnv_getenv("LC_CTYPE");
    if (result && strNE(result, "")) {
        setlocale(LC_CTYPE, result);
    }
#   endif
#   ifdef USE_LOCALE_COLLATE
    result = PerlEnv_getenv("LC_COLLATE");
    if (result && strNE(result, "")) {
        setlocale(LC_COLLATE, result);
    }
#   endif
#   ifdef USE_LOCALE_MONETARY
    result = PerlEnv_getenv("LC_MONETARY");
    if (result && strNE(result, "")) {
        setlocale(LC_MONETARY, result);
    }
#   endif
#   ifdef USE_LOCALE_NUMERIC
    result = PerlEnv_getenv("LC_NUMERIC");
    if (result && strNE(result, "")) {
        setlocale(LC_NUMERIC, result);
    }
#   endif
#   ifdef USE_LOCALE_MESSAGES
    result = PerlEnv_getenv("LC_MESSAGES");
    if (result && strNE(result, "")) {
        setlocale(LC_MESSAGES, result);
    }
#   endif

    return setlocale(LC_ALL, NULL);

}

#endif


d247 2
a248 7
    /* printwarn is
     *
     *    0 if not to output warning when setup locale is bad
     *    1 if to output warning based on value of PERL_BADLANG
     *    >1 if to output regardless of PERL_BADLANG
     *
     * returns
d250 2
a251 2
     *    0 = fallback to a locale of lower priority
     *   -1 = fallback to all locales failed, not even to the C locale
a253 2
    int ok = 1;

a268 7

    /* NULL uses the existing already set up locale */
    const char * const setlocale_init = (PerlEnv_getenv("PERL_SKIP_LOCALE_INIT"))
                                        ? NULL
                                        : "";
    const char* trial_locales[5];   /* 5 = 1 each for "", LC_ALL, LANG, "", C */
    unsigned int trial_locales_count;
a271 7
    unsigned int i;
    char *p;
    const bool locwarn = (printwarn > 1 ||
                    (printwarn &&
                     (!(p = PerlEnv_getenv("PERL_BADLANG")) || atoi(p))));
    bool done = FALSE;
    const char *system_default_locale = NULL;
d273 1
a273 4

#ifndef LOCALE_ENVIRON_REQUIRED
    PERL_UNUSED_VAR(done);
#else
d280 3
a282 1
#   ifdef LC_ALL
d284 1
a284 1
	if (my_setlocale(LC_ALL, setlocale_init))
d290 1
a290 1
#       ifdef USE_LOCALE_CTYPE
d293 1
a293 1
	       my_setlocale(LC_CTYPE,
d295 1
a295 1
				    ? setlocale_init : NULL)))
d299 2
a300 2
#       endif /* USE_LOCALE_CTYPE */
#       ifdef USE_LOCALE_COLLATE
d303 1
a303 1
	       my_setlocale(LC_COLLATE,
d305 1
a305 1
				   ? setlocale_init : NULL)))
d309 2
a310 2
#       endif /* USE_LOCALE_COLLATE */
#       ifdef USE_LOCALE_NUMERIC
d313 1
a313 1
	       my_setlocale(LC_NUMERIC,
d315 1
a315 1
				  ? setlocale_init : NULL)))
d319 1
a319 17
#       endif /* USE_LOCALE_NUMERIC */
#       ifdef USE_LOCALE_MESSAGES
	if (! my_setlocale(LC_MESSAGES,
			 (!done && (lang || PerlEnv_getenv("LC_MESSAGES")))
				  ? setlocale_init : NULL))
        {
	    setlocale_failure = TRUE;
        }
#       endif /* USE_LOCALE_MESSAGES */
#       ifdef USE_LOCALE_MONETARY
	if (! my_setlocale(LC_MONETARY,
			 (!done && (lang || PerlEnv_getenv("LC_MONETARY")))
				  ? setlocale_init : NULL))
        {
	    setlocale_failure = TRUE;
        }
#       endif /* USE_LOCALE_MONETARY */
d322 1
a322 1
#   endif /* LC_ALL */
a325 41
    /* We try each locale in the list until we get one that works, or exhaust
     * the list */
    trial_locales[0] = setlocale_init;
    trial_locales_count = 1;
    for (i= 0; i < trial_locales_count; i++) {
        const char * trial_locale = trial_locales[i];

        if (i > 0) {

            /* XXX This is to preserve old behavior for LOCALE_ENVIRON_REQUIRED
             * when i==0, but I (khw) don't think that behavior makes much
             * sense */
            setlocale_failure = FALSE;

#ifdef WIN32

            /* On Windows machines, an entry of "" after the 0th means to use
             * the system default locale, which we now proceed to get. */
            if (strEQ(trial_locale, "")) {
                unsigned int j;

                /* Note that this may change the locale, but we are going to do
                 * that anyway just below */
                system_default_locale = setlocale(LC_ALL, "");

                /* Skip if invalid or it's already on the list of locales to
                 * try */
                if (! system_default_locale) {
                    goto next_iteration;
                }
                for (j = 0; j < trial_locales_count; j++) {
                    if (strEQ(system_default_locale, trial_locales[j])) {
                        goto next_iteration;
                    }
                }

                trial_locale = system_default_locale;
            }
#endif
        }

d327 2
a328 13
        if (! my_setlocale(LC_ALL, trial_locale)) {
            setlocale_failure = TRUE;
        }
        else {
            /* Since LC_ALL succeeded, it should have changed all the other
             * categories it can to its value; so we massage things so that the
             * setlocales below just return their category's current values.
             * This adequately handles the case in NetBSD where LC_COLLATE may
             * not be defined for a locale, and setting it individually will
             * fail, whereas setting LC_ALL suceeds, leaving LC_COLLATE set to
             * the POSIX locale. */
            trial_locale = NULL;
        }
d331 1
a331 1
        if (!setlocale_failure) {
d333 5
a337 5
            Safefree(curctype);
            if (! (curctype = my_setlocale(LC_CTYPE, trial_locale)))
                setlocale_failure = TRUE;
            else
                curctype = savepv(curctype);
d340 5
a344 5
            Safefree(curcoll);
            if (! (curcoll = my_setlocale(LC_COLLATE, trial_locale)))
                setlocale_failure = TRUE;
            else
                curcoll = savepv(curcoll);
d347 5
a351 5
            Safefree(curnum);
            if (! (curnum = my_setlocale(LC_NUMERIC, trial_locale)))
                setlocale_failure = TRUE;
            else
                curnum = savepv(curnum);
d353 1
a353 13
#ifdef USE_LOCALE_MESSAGES
            if (! (my_setlocale(LC_MESSAGES, trial_locale)))
                setlocale_failure = TRUE;
#endif /* USE_LOCALE_MESSAGES */
#ifdef USE_LOCALE_MONETARY
            if (! (my_setlocale(LC_MONETARY, trial_locale)))
                setlocale_failure = TRUE;
#endif /* USE_LOCALE_MONETARY */

            if (! setlocale_failure) {  /* Success */
                break;
            }
        }
d355 5
a359 2
        /* Here, something failed; will need to try a fallback. */
        ok = 0;
d361 1
a361 4
        if (i == 0) {
            unsigned int j;

            if (locwarn) { /* Output failure info only on the first one */
d364 2
a365 2
                PerlIO_printf(Perl_error_log,
                "perl: warning: Setting locale failed.\n");
d369 2
a370 2
                PerlIO_printf(Perl_error_log,
                "perl: warning: Setting locale failed for the categories:\n\t");
d372 2
a373 2
                if (! curctype)
                    PerlIO_printf(Perl_error_log, "LC_CTYPE ");
d376 2
a377 2
                if (! curcoll)
                    PerlIO_printf(Perl_error_log, "LC_COLLATE ");
d380 2
a381 2
                if (! curnum)
                    PerlIO_printf(Perl_error_log, "LC_NUMERIC ");
d383 1
a383 1
                PerlIO_printf(Perl_error_log, "and possibly others\n");
d387 2
a388 2
                PerlIO_printf(Perl_error_log,
                    "perl: warning: Please check that your locale settings:\n");
d391 5
a395 5
                PerlIO_printf(Perl_error_log,
                            "\tLANGUAGE = %c%s%c,\n",
                            language ? '"' : '(',
                            language ? language : "unset",
                            language ? '"' : ')');
d398 5
a402 5
                PerlIO_printf(Perl_error_log,
                            "\tLC_ALL = %c%s%c,\n",
                            lc_all ? '"' : '(',
                            lc_all ? lc_all : "unset",
                            lc_all ? '"' : ')');
d405 10
a414 10
                {
                char **e;
                for (e = environ; *e; e++) {
                    if (strnEQ(*e, "LC_", 3)
                            && strnNE(*e, "LC_ALL=", 7)
                            && (p = strchr(*e, '=')))
                        PerlIO_printf(Perl_error_log, "\t%.*s = \"%s\",\n",
                                        (int)(p - *e), *e, p + 1);
                }
                }
d416 2
a417 2
                PerlIO_printf(Perl_error_log,
                            "\t(possibly more locale environment variables)\n");
d420 5
a424 49
                PerlIO_printf(Perl_error_log,
                            "\tLANG = %c%s%c\n",
                            lang ? '"' : '(',
                            lang ? lang : "unset",
                            lang ? '"' : ')');

                PerlIO_printf(Perl_error_log,
                            "    are supported and installed on your system.\n");
            }

            /* Calculate what fallback locales to try.  We have avoided this
             * until we have to, becuase failure is quite unlikely.  This will
             * usually change the upper bound of the loop we are in.
             *
             * Since the system's default way of setting the locale has not
             * found one that works, We use Perl's defined ordering: LC_ALL,
             * LANG, and the C locale.  We don't try the same locale twice, so
             * don't add to the list if already there.  (On POSIX systems, the
             * LC_ALL element will likely be a repeat of the 0th element "",
             * but there's no harm done by doing it explicitly */
            if (lc_all) {
                for (j = 0; j < trial_locales_count; j++) {
                    if (strEQ(lc_all, trial_locales[j])) {
                        goto done_lc_all;
                    }
                }
                trial_locales[trial_locales_count++] = lc_all;
            }
          done_lc_all:

            if (lang) {
                for (j = 0; j < trial_locales_count; j++) {
                    if (strEQ(lang, trial_locales[j])) {
                        goto done_lang;
                    }
                }
                trial_locales[trial_locales_count++] = lang;
            }
          done_lang:

#if defined(WIN32) && defined(LC_ALL)
            /* For Windows, we also try the system default locale before "C".
             * (If there exists a Windows without LC_ALL we skip this because
             * it gets too complicated.  For those, the "C" is the next
             * fallback possibility).  The "" is the same as the 0th element of
             * the array, but the code at the loop above knows to treat it
             * differently when not the 0th */
            trial_locales[trial_locales_count++] = "";
#endif
d426 3
a428 6
            for (j = 0; j < trial_locales_count; j++) {
                if (strEQ("C", trial_locales[j])) {
                    goto done_C;
                }
            }
            trial_locales[trial_locales_count++] = "C";
d430 1
a430 2
          done_C: ;
        }   /* end of first time through the loop */
d432 12
a443 3
#ifdef WIN32
      next_iteration: ;
#endif
d445 1
a445 1
    }   /* end of looping through the trial locales */
d447 17
a463 10
    if (ok < 1) {   /* If we tried to fallback */
        const char* msg;
        if (! setlocale_failure) {  /* fallback succeeded */
           msg = "Falling back to";
        }
        else {  /* fallback failed */

            /* We dropped off the end of the loop, so have to decrement i to
             * get back to the value the last time through */
            i--;
d465 1
a465 2
            ok = -1;
            msg = "Failed to fall back to";
a466 1
            /* To continue, we should use whatever values we've got */
d468 2
a469 2
            Safefree(curctype);
            curctype = savepv(setlocale(LC_CTYPE, NULL));
d472 2
a473 2
            Safefree(curcoll);
            curcoll = savepv(setlocale(LC_COLLATE, NULL));
d476 2
a477 2
            Safefree(curnum);
            curnum = savepv(setlocale(LC_NUMERIC, NULL));
d479 2
a480 29
        }

        if (locwarn) {
            const char * description;
            const char * name = "";
            if (strEQ(trial_locales[i], "C")) {
                description = "the standard locale";
                name = "C";
            }
            else if (strEQ(trial_locales[i], "")) {
                description = "the system default locale";
                if (system_default_locale) {
                    name = system_default_locale;
                }
            }
            else {
                description = "a fallback locale";
                name = trial_locales[i];
            }
            if (name && strNE(name, "")) {
                PerlIO_printf(Perl_error_log,
                    "perl: warning: %s %s (\"%s\").\n", msg, description, name);
            }
            else {
                PerlIO_printf(Perl_error_log,
                                   "perl: warning: %s %s.\n", msg, description);
            }
        }
    } /* End of tried to fallback */
d494 3
a496 7
#if defined(USE_PERLIO) && defined(USE_LOCALE_CTYPE)
    /* Set PL_utf8locale to TRUE if using PerlIO _and_ the current LC_CTYPE
     * locale is UTF-8.  If PL_utf8locale and PL_unicode (set by -C or by
     * $ENV{PERL_UNICODE}) are true, perl.c:S_parse_body() will turn on the
     * PerlIO :utf8 layer on STDIN, STDOUT, STDERR, _and_ the default open
     * discipline.  */
    PL_utf8locale = is_cur_LC_category_utf8(LC_CTYPE);
d498 46
a563 3

#endif /* USE_LOCALE */

a566 1

a628 388

#ifdef USE_LOCALE

STATIC bool
S_is_cur_LC_category_utf8(pTHX_ int category)
{
    /* Returns TRUE if the current locale for 'category' is UTF-8; FALSE
     * otherwise. 'category' may not be LC_ALL.  If the platform doesn't have
     * nl_langinfo(), nor MB_CUR_MAX, this employs a heuristic, which hence
     * could give the wrong result.  It errs on the side of not being a UTF-8
     * locale. */

    char *save_input_locale = NULL;
    STRLEN final_pos;

#ifdef LC_ALL
    assert(category != LC_ALL);
#endif

    /* First dispose of the trivial cases */
    save_input_locale = setlocale(category, NULL);
    if (! save_input_locale) {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "Could not find current locale for category %d\n",
                              category));
        return FALSE;   /* XXX maybe should croak */
    }
    save_input_locale = stdize_locale(savepv(save_input_locale));
    if ((*save_input_locale == 'C' && save_input_locale[1] == '\0')
        || strEQ(save_input_locale, "POSIX"))
    {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "Current locale for category %d is %s\n",
                              category, save_input_locale));
        Safefree(save_input_locale);
        return FALSE;
    }

#if defined(USE_LOCALE_CTYPE)    \
    && (defined(MB_CUR_MAX) || (defined(HAS_NL_LANGINFO) && defined(CODESET)))

    { /* Next try nl_langinfo or MB_CUR_MAX if available */

        char *save_ctype_locale = NULL;
        bool is_utf8;

        if (category != LC_CTYPE) { /* These work only on LC_CTYPE */

            /* Get the current LC_CTYPE locale */
            save_ctype_locale = stdize_locale(savepv(setlocale(LC_CTYPE, NULL)));
            if (! save_ctype_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                               "Could not find current locale for LC_CTYPE\n"));
                goto cant_use_nllanginfo;
            }

            /* If LC_CTYPE and the desired category use the same locale, this
             * means that finding the value for LC_CTYPE is the same as finding
             * the value for the desired category.  Otherwise, switch LC_CTYPE
             * to the desired category's locale */
            if (strEQ(save_ctype_locale, save_input_locale)) {
                Safefree(save_ctype_locale);
                save_ctype_locale = NULL;
            }
            else if (! setlocale(LC_CTYPE, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                                    "Could not change LC_CTYPE locale to %s\n",
                                    save_input_locale));
                Safefree(save_ctype_locale);
                goto cant_use_nllanginfo;
            }
        }

        DEBUG_L(PerlIO_printf(Perl_debug_log, "Current LC_CTYPE locale=%s\n",
                                              save_input_locale));

        /* Here the current LC_CTYPE is set to the locale of the category whose
         * information is desired.  This means that nl_langinfo() and MB_CUR_MAX
         * should give the correct results */

#   if defined(HAS_NL_LANGINFO) && defined(CODESET)
        {
            char *codeset = savepv(nl_langinfo(CODESET));
            if (codeset && strNE(codeset, "")) {

                /* If we switched LC_CTYPE, switch back */
                if (save_ctype_locale) {
                    setlocale(LC_CTYPE, save_ctype_locale);
                    Safefree(save_ctype_locale);
                }

                is_utf8 = foldEQ(codeset, STR_WITH_LEN("UTF-8"))
                        || foldEQ(codeset, STR_WITH_LEN("UTF8"));

                DEBUG_L(PerlIO_printf(Perl_debug_log,
                       "\tnllanginfo returned CODESET '%s'; ?UTF8 locale=%d\n",
                                                     codeset,         is_utf8));
                Safefree(codeset);
                Safefree(save_input_locale);
                return is_utf8;
            }
            Safefree(codeset);
        }

#   endif
#   ifdef MB_CUR_MAX

        /* Here, either we don't have nl_langinfo, or it didn't return a
         * codeset.  Try MB_CUR_MAX */

        /* Standard UTF-8 needs at least 4 bytes to represent the maximum
         * Unicode code point.  Since UTF-8 is the only non-single byte
         * encoding we handle, we just say any such encoding is UTF-8, and if
         * turns out to be wrong, other things will fail */
        is_utf8 = MB_CUR_MAX >= 4;

        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "\tMB_CUR_MAX=%d; ?UTF8 locale=%d\n",
                                   (int) MB_CUR_MAX,      is_utf8));

        Safefree(save_input_locale);

#       ifdef HAS_MBTOWC

        /* ... But, most system that have MB_CUR_MAX will also have mbtowc(),
         * since they are both in the C99 standard.  We can feed a known byte
         * string to the latter function, and check that it gives the expected
         * result */
        if (is_utf8) {
            wchar_t wc;
            PERL_UNUSED_RESULT(mbtowc(&wc, NULL, 0));/* Reset any shift state */
            errno = 0;
            if (mbtowc(&wc, HYPHEN_UTF8, strlen(HYPHEN_UTF8))
                                                        != strlen(HYPHEN_UTF8)
                || wc != (wchar_t) 0x2010)
            {
                is_utf8 = FALSE;
                DEBUG_L(PerlIO_printf(Perl_debug_log, "\thyphen=U+%x\n", wc));
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                        "\treturn from mbtowc=%d; errno=%d; ?UTF8 locale=0\n",
                        mbtowc(&wc, HYPHEN_UTF8, strlen(HYPHEN_UTF8)), errno));
            }
        }
#       endif

        /* If we switched LC_CTYPE, switch back */
        if (save_ctype_locale) {
            setlocale(LC_CTYPE, save_ctype_locale);
            Safefree(save_ctype_locale);
        }

        return is_utf8;
#   endif
    }

  cant_use_nllanginfo:

#endif /* HAS_NL_LANGINFO etc */

    /* nl_langinfo not available or failed somehow.  Look at the locale name to
     * see if it matches qr/UTF -? 8 /ix  */

    final_pos = strlen(save_input_locale) - 1;
    if (final_pos >= 3) {
        char *name = save_input_locale;

        /* Find next 'U' or 'u' and look from there */
        while ((name += strcspn(name, "Uu") + 1)
                                            <= save_input_locale + final_pos - 2)
        {
            if (toFOLD(*(name)) != 't'
                || toFOLD(*(name + 1)) != 'f')
            {
                continue;
            }
            name += 2;
            if (*(name) == '-') {
                if ((name > save_input_locale + final_pos - 1)) {
                    break;
                }
                name++;
            }
            if (*(name) == '8') {
                Safefree(save_input_locale);
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                                      "Locale %s ends with UTF-8 in name\n",
                                      save_input_locale));
                return TRUE;
            }
        }
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                              "Locale %s doesn't end with UTF-8 in name\n",
                                save_input_locale));
    }

#ifdef WIN32
    /* http://msdn.microsoft.com/en-us/library/windows/desktop/dd317756.aspx */
    if (final_pos >= 4
        && *(save_input_locale + final_pos - 0) == '1'
        && *(save_input_locale + final_pos - 1) == '0'
        && *(save_input_locale + final_pos - 2) == '0'
        && *(save_input_locale + final_pos - 3) == '5'
        && *(save_input_locale + final_pos - 4) == '6')
    {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                        "Locale %s ends with 10056 in name, is UTF-8 locale\n",
                        save_input_locale));
        Safefree(save_input_locale);
        return TRUE;
    }
#endif

    /* Other common encodings are the ISO 8859 series, which aren't UTF-8 */
    if (instr(save_input_locale, "8859")) {
        DEBUG_L(PerlIO_printf(Perl_debug_log,
                             "Locale %s has 8859 in name, not UTF-8 locale\n",
                             save_input_locale));
        Safefree(save_input_locale);
        return FALSE;
    }

#ifdef HAS_LOCALECONV

#   ifdef USE_LOCALE_MONETARY

    /* Here, there is nothing in the locale name to indicate whether the locale
     * is UTF-8 or not.  This "name", the return of setlocale(), is actually
     * defined to be opaque, so we can't really rely on the absence of various
     * substrings in the name to indicate its UTF-8ness.  Look at the locale's
     * currency symbol.  Often that will be in the native script, and if the
     * symbol isn't in UTF-8, we know that the locale isn't.  If it is
     * non-ASCII UTF-8, we infer that the locale is too.
     * To do this, like above for LC_CTYPE, we first set LC_MONETARY to the
     * locale of the desired category, if it isn't that locale already */

    {
        char *save_monetary_locale = NULL;
        bool illegal_utf8 = FALSE;
        bool only_ascii = FALSE;
        const struct lconv* const lc = localeconv();

        if (category != LC_MONETARY) {

            save_monetary_locale = stdize_locale(savepv(setlocale(LC_MONETARY,
                                                                  NULL)));
            if (! save_monetary_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_MONETARY\n"));
                goto cant_use_monetary;
            }

            if (strNE(save_monetary_locale, save_input_locale)) {
                if (! setlocale(LC_MONETARY, save_input_locale)) {
                    DEBUG_L(PerlIO_printf(Perl_debug_log,
                                "Could not change LC_MONETARY locale to %s\n",
                                                            save_input_locale));
                    Safefree(save_monetary_locale);
                    goto cant_use_monetary;
                }
            }
        }

        /* Here the current LC_MONETARY is set to the locale of the category
         * whose information is desired. */

        if (lc && lc->currency_symbol) {
            if (! is_utf8_string((U8 *) lc->currency_symbol, 0)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Currency symbol for %s is not legal UTF-8\n",
                                        save_input_locale));
                illegal_utf8 = TRUE;
            }
            else if (is_ascii_string((U8 *) lc->currency_symbol, 0)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log, "Currency symbol for %s contains only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
                only_ascii = TRUE;
            }
        }

        /* If we changed it, restore LC_MONETARY to its original locale */
        if (save_monetary_locale) {
            setlocale(LC_MONETARY, save_monetary_locale);
            Safefree(save_monetary_locale);
        }

        Safefree(save_input_locale);

        /* It isn't a UTF-8 locale if the symbol is not legal UTF-8; otherwise
         * assume the locale is UTF-8 if and only if the symbol is non-ascii
         * UTF-8.  (We can't really tell if the locale is UTF-8 or not if the
         * symbol is just a '$', so we err on the side of it not being UTF-8)
         * */
        DEBUG_L(PerlIO_printf(Perl_debug_log, "\tis_utf8=%d\n", (illegal_utf8)
                                                               ? FALSE
                                                               : ! only_ascii));
        return (illegal_utf8)
                ? FALSE
                : ! only_ascii;

    }
  cant_use_monetary:

#   endif /* USE_LOCALE_MONETARY */
#endif /* HAS_LOCALECONV */

#if 0 && defined(HAS_STRERROR) && defined(USE_LOCALE_MESSAGES)

/* This code is ifdefd out because it was found to not be necessary in testing
 * on our dromedary test machine, which has over 700 locales.  There, looking
 * at just the currency symbol gave essentially the same results as doing this
 * extra work.  Executing this also caused segfaults in miniperl.  I left it in
 * so as to avoid rewriting it if real-world experience indicates that
 * dromedary is an outlier.  Essentially, instead of returning abpve if we
 * haven't found illegal utf8, we continue on and examine all the strerror()
 * messages on the platform for utf8ness.  If all are ASCII, we still don't
 * know the answer; but otherwise we have a pretty good indication of the
 * utf8ness.  The reason this doesn't necessarily help much is that the
 * messages may not have been translated into the locale.  The currency symbol
 * is much more likely to have been translated.  The code below would need to
 * be altered somewhat to just be a continuation of testing the currency
 * symbol. */
        int e;
        unsigned int failures = 0, non_ascii = 0;
        char *save_messages_locale = NULL;

        /* Like above for LC_CTYPE, we set LC_MESSAGES to the locale of the
         * desired category, if it isn't that locale already */

        if (category != LC_MESSAGES) {

            save_messages_locale = stdize_locale(savepv(setlocale(LC_MESSAGES,
                                                                  NULL)));
            if (! save_messages_locale) {
                goto cant_use_messages;
            }

            if (strEQ(save_messages_locale, save_input_locale)) {
                Safefree(save_input_locale);
            }
            else if (! setlocale(LC_MESSAGES, save_input_locale)) {
                Safefree(save_messages_locale);
                goto cant_use_messages;
            }
        }

        /* Here the current LC_MESSAGES is set to the locale of the category
         * whose information is desired.  Look through all the messages */

        for (e = 0;
#ifdef HAS_SYS_ERRLIST
             e <= sys_nerr
#endif
             ; e++)
        {
            const U8* const errmsg = (U8 *) Strerror(e) ;
            if (!errmsg)
                break;
            if (! is_utf8_string(errmsg, 0)) {
                failures++;
                break;
            }
            else if (! is_ascii_string(errmsg, 0)) {
                non_ascii++;
            }
        }

        /* And, if we changed it, restore LC_MESSAGES to its original locale */
        if (save_messages_locale) {
            setlocale(LC_MESSAGES, save_messages_locale);
            Safefree(save_messages_locale);
        }

        /* Any non-UTF-8 message means not a UTF-8 locale; if all are valid,
         * any non-ascii means it is one; otherwise we assume it isn't */
        return (failures) ? FALSE : non_ascii;

    }
  cant_use_messages:

#endif

    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Assuming locale %s is not a UTF-8 locale\n",
                                    save_input_locale));
    Safefree(save_input_locale);
    return FALSE;
}

#endif
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d32 1
a32 3
 * the desired behavior of those functions at the moment.  And, LC_MESSAGES is
 * switched to the C locale for outputting the message unless within the scope
 * of 'use locale'.
d96 1
d110 1
a110 1
            if (! is_invariant_string((U8 *) lc->decimal_point, 0)
d112 1
a112 1
                && _is_cur_LC_category_utf8(LC_NUMERIC))
d121 1
a121 4
    DEBUG_L(PerlIO_printf(Perl_debug_log, "Locale radix is %s, ?UTF-8=%d\n",
                                          (PL_numeric_radix_sv)
                                           ? SvPVX(PL_numeric_radix_sv)
                                           : "NULL",
d123 2
a124 2
                                           ? cBOOL(SvUTF8(PL_numeric_radix_sv))
                                           : 0));
a129 14
/* Is the C string input 'name' "C" or "POSIX"?  If so, and 'name' is the
 * return of setlocale(), then this is extremely likely to be the C or POSIX
 * locale.  However, the output of setlocale() is documented to be opaque, but
 * the odds are extremely small that it would return these two strings for some
 * other locale.  Note that VMS in these two locales includes many non-ASCII
 * characters as controls and punctuation (below are hex bytes):
 *   cntrl:  00-1F 7F 84-97 9B-9F
 *   punct:  21-2F 3A-40 5B-60 7B-7E A1-A3 A5 A7-AB B0-B3 B5-B7 B9-BD BF-CF D1-DD DF-EF F1-FD
 * Oddly, none there are listed as alphas, though some represent alphabetics
 * http://www.nntp.perl.org/group/perl.perl5.porters/2013/02/msg198753.html */
#define isNAME_C_OR_POSIX(name) ((name) != NULL                                 \
                                  && ((*(name) == 'C' && (*(name + 1)) == '\0') \
                                       || strEQ((name), "POSIX")))

d149 1
a149 1
     * PL_numeric_name  The underlying locale's name: a copy of 'newnum'
d151 3
a153 6
     *                  that the current locale is the program's underlying
     *                  locale
     * PL_numeric_standard An int indicating if the toggled state is such
     *                  that the current locale is the C locale.  If non-zero,
     *                  it is in C; if > 1, it means it may not be toggled away
     *                  from C.
d164 1
a174 4

    PL_numeric_standard = isNAME_C_OR_POSIX(save_newnum);
    PL_numeric_local = TRUE;

a178 8
    else {
	Safefree(save_newnum);
    }

    /* Keep LC_NUMERIC in the C locale.  This is for XS modules, so they don't
     * have to worry about the radix being a non-dot.  (Core operations that
     * need the underlying locale change to it temporarily). */
    set_numeric_standard();
d180 3
a184 2
#else
    PERL_UNUSED_ARG(newnum);
d192 12
a203 10
    /* Toggle the LC_NUMERIC locale to C.  Most code should use the macros like
     * SET_NUMERIC_STANDARD() in perl.h instead of calling this directly.  The
     * macro avoids calling this routine if toggling isn't necessary according
     * to our records (which could be wrong if some XS code has changed the
     * locale behind our back) */

    setlocale(LC_NUMERIC, "C");
    PL_numeric_standard = TRUE;
    PL_numeric_local = isNAME_C_OR_POSIX(PL_numeric_name);
    set_numeric_radix();
d214 1
a214 5
    /* Toggle the LC_NUMERIC locale to the current underlying default.  Most
     * code should use the macros like SET_NUMERIC_LOCAL() in perl.h instead of
     * calling this directly.  The macro avoids calling this routine if
     * toggling isn't necessary according to our records (which could be wrong
     * if some XS code has changed the locale behind our back) */
d216 10
a225 4
    setlocale(LC_NUMERIC, PL_numeric_name);
    PL_numeric_standard = isNAME_C_OR_POSIX(PL_numeric_name);
    PL_numeric_local = TRUE;
    set_numeric_radix();
d257 1
a257 8
    /* We will replace any bad locale warning with 1) nothing if the new one is
     * ok; or 2) a new warning for the bad new locale */
    if (PL_warn_locale) {
        SvREFCNT_dec_NN(PL_warn_locale);
        PL_warn_locale = NULL;
    }

    PL_in_utf8_CTYPE_locale = _is_cur_LC_category_utf8(LC_CTYPE);
a264 12
        /* Assume enough space for every character being bad.  4 spaces each
         * for the 94 printable characters that are output like "'x' "; and 5
         * spaces each for "'\\' ", "'\t' ", and "'\n' "; plus a terminating
         * NUL */
        char bad_chars_list[ (94 * 4) + (3 * 5) + 1 ];

        bool check_for_problems = ckWARN_d(WARN_LOCALE); /* No warnings means
                                                            no check */
        bool multi_byte_locale = FALSE;     /* Assume is a single-byte locale
                                               to start */
        unsigned int bad_count = 0;         /* Count of bad characters */

a271 98

            /* If checking for locale problems, see if the native ASCII-range
             * printables plus \n and \t are in their expected categories in
             * the new locale.  If not, this could mean big trouble, upending
             * Perl's and most programs' assumptions, like having a
             * metacharacter with special meaning become a \w.  Fortunately,
             * it's very rare to find locales that aren't supersets of ASCII
             * nowadays.  It isn't a problem for most controls to be changed
             * into something else; we check only \n and \t, though perhaps \r
             * could be an issue as well. */
            if (check_for_problems
                && (isGRAPH_A(i) || isBLANK_A(i) || i == '\n'))
            {
                if ((isALPHANUMERIC_A(i) && ! isALPHANUMERIC_LC(i))
                     || (isPUNCT_A(i) && ! isPUNCT_LC(i))
                     || (isBLANK_A(i) && ! isBLANK_LC(i))
                     || (i == '\n' && ! isCNTRL_LC(i)))
                {
                    if (bad_count) {    /* Separate multiple entries with a
                                           blank */
                        bad_chars_list[bad_count++] = ' ';
                    }
                    bad_chars_list[bad_count++] = '\'';
                    if (isPRINT_A(i)) {
                        bad_chars_list[bad_count++] = (char) i;
                    }
                    else {
                        bad_chars_list[bad_count++] = '\\';
                        if (i == '\n') {
                            bad_chars_list[bad_count++] = 'n';
                        }
                        else {
                            assert(i == '\t');
                            bad_chars_list[bad_count++] = 't';
                        }
                    }
                    bad_chars_list[bad_count++] = '\'';
                    bad_chars_list[bad_count] = '\0';
                }
            }
        }

#ifdef MB_CUR_MAX
        /* We only handle single-byte locales (outside of UTF-8 ones; so if
         * this locale requires than one byte, there are going to be
         * problems. */
        if (check_for_problems && MB_CUR_MAX > 1

               /* Some platforms return MB_CUR_MAX > 1 for even the "C"
                * locale.  Just assume that the implementation for them (plus
                * for POSIX) is correct and the > 1 value is spurious.  (Since
                * these are specially handled to never be considered UTF-8
                * locales, as long as this is the only problem, everything
                * should work fine */
            && strNE(newctype, "C") && strNE(newctype, "POSIX"))
        {
            multi_byte_locale = TRUE;
        }
#endif

        if (bad_count || multi_byte_locale) {
            PL_warn_locale = Perl_newSVpvf(aTHX_
                             "Locale '%s' may not work well.%s%s%s\n",
                             newctype,
                             (multi_byte_locale)
                              ? "  Some characters in it are not recognized by"
                                " Perl."
                              : "",
                             (bad_count)
                              ? "\nThe following characters (and maybe others)"
                                " may not have the same meaning as the Perl"
                                " program expects:\n"
                              : "",
                             (bad_count)
                              ? bad_chars_list
                              : ""
                            );
            /* If we are actually in the scope of the locale, output the
             * message now.  Otherwise we save it to be output at the first
             * operation using this locale, if that actually happens.  Most
             * programs don't use locales, so they are immune to bad ones */
            if (IN_LC(LC_CTYPE)) {

                /* We have to save 'newctype' because the setlocale() just
                 * below may destroy it.  The next setlocale() further down
                 * should restore it properly so that the intermediate change
                 * here is transparent to this function's caller */
                const char * const badlocale = savepv(newctype);

                setlocale(LC_CTYPE, "C");

                /* The '0' below suppresses a bogus gcc compiler warning */
                Perl_warner(aTHX_ packWARN(WARN_LOCALE), SvPVX(PL_warn_locale), 0);
                setlocale(LC_CTYPE, badlocale);
                Safefree(badlocale);
                SvREFCNT_dec_NN(PL_warn_locale);
                PL_warn_locale = NULL;
            }
a281 26
Perl__warn_problematic_locale()
{

#ifdef USE_LOCALE_CTYPE

    dTHX;

    /* Internal-to-core function that outputs the message in PL_warn_locale,
     * and then NULLS it.  Should be called only through the macro
     * _CHECK_AND_WARN_PROBLEMATIC_LOCALE */

    if (PL_warn_locale) {
        /*GCC_DIAG_IGNORE(-Wformat-security);   Didn't work */
        Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                             SvPVX(PL_warn_locale),
                             0 /* dummy to avoid compiler warning */ );
        /* GCC_DIAG_RESTORE; */
        SvREFCNT_dec_NN(PL_warn_locale);
        PL_warn_locale = NULL;
    }

#endif

}

void
d294 2
d312 2
a313 1
	PL_collation_standard = isNAME_C_OR_POSIX(newcoll);
a330 2
#else
    PERL_UNUSED_ARG(newcoll);
d351 1
a351 1
    bool override_LC_ALL = FALSE;
a411 2
    DEBUG_L(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n", __FILE__, __LINE__,
                            _setlocale_debug_string(category, locale, result)));
d417 1
a417 1
    /* Here the input category was LC_ALL, and we have set it to what is in the
a425 3
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                    __FILE__, __LINE__,
                    _setlocale_debug_string(LC_TIME, result, "not captured")));
a431 3
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                    __FILE__, __LINE__,
                    _setlocale_debug_string(LC_CTYPE, result, "not captured")));
a437 3
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                  __FILE__, __LINE__,
                  _setlocale_debug_string(LC_COLLATE, result, "not captured")));
a443 3
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                 __FILE__, __LINE__,
                 _setlocale_debug_string(LC_MONETARY, result, "not captured")));
a449 3
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                 __FILE__, __LINE__,
                 _setlocale_debug_string(LC_NUMERIC, result, "not captured")));
a455 3
        DEBUG_Lv(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                 __FILE__, __LINE__,
                 _setlocale_debug_string(LC_MESSAGES, result, "not captured")));
d459 1
a459 4
    result = setlocale(LC_ALL, NULL);
    DEBUG_L(PerlIO_printf(Perl_debug_log, "%s:%d: %s\n",
                               __FILE__, __LINE__,
                               _setlocale_debug_string(LC_ALL, NULL, result)));
a460 1
    return result;
d482 1
a482 36
     *
     * Under -DDEBUGGING, if the environment variable PERL_DEBUG_LOCALE_INIT is
     * set, debugging information is output.
     *
     * This looks more complicated than it is, mainly due to the #ifdefs.
     *
     * We try to set LC_ALL to the value determined by the environment.  If
     * there is no LC_ALL on this platform, we try the individual categories we
     * know about.  If this works, we are done.
     *
     * But if it doesn't work, we have to do something else.  We search the
     * environment variables ourselves instead of relying on the system to do
     * it.  We look at, in order, LC_ALL, LANG, a system default locale (if we
     * think there is one), and the ultimate fallback "C".  This is all done in
     * the same loop as above to avoid duplicating code, but it makes things
     * more complex.  After the original failure, we add the fallback
     * possibilities to the list of locales to try, and iterate the loop
     * through them all until one succeeds.
     *
     * On Ultrix, the locale MUST come from the environment, so there is
     * preliminary code to set it.  I (khw) am not sure that it is necessary,
     * and that this couldn't be folded into the loop, but barring any real
     * platforms to test on, it's staying as-is
     *
     * A slight complication is that in embedded Perls, the locale may already
     * be set-up, and we don't want to get it from the normal environment
     * variables.  This is handled by having a special environment variable
     * indicate we're in this situation.  We simply set setlocale's 2nd
     * parameter to be a NULL instead of "".  That indicates to setlocale that
     * it is not to change anything, but to return the current value,
     * effectively initializing perl's db to what the locale already is.
     *
     * We play the same trick with NULL if a LC_ALL succeeds.  We call
     * setlocale() on the individual categores with NULL to get their existing
     * values for our db, instead of trying to change them.
     * */
d487 2
d499 1
a499 1
    const char * const language   = savepv(PerlEnv_getenv("LANGUAGE"));
a505 18
#ifdef DEBUGGING
    const bool debug = (PerlEnv_getenv("PERL_DEBUG_LOCALE_INIT"))
                       ? TRUE
                       : FALSE;
#   define DEBUG_LOCALE_INIT(category, locale, result)                      \
	STMT_START {                                                        \
		if (debug) {                                                \
                    PerlIO_printf(Perl_debug_log,                           \
                                  "%s:%d: %s\n",                            \
                                  __FILE__, __LINE__,                       \
                                  _setlocale_debug_string(category,         \
                                                          locale,           \
                                                          result));         \
                }                                                           \
	} STMT_END
#else
#   define DEBUG_LOCALE_INIT(a,b,c)
#endif
d508 2
a509 2
    const char * const lc_all     = savepv(PerlEnv_getenv("LC_ALL"));
    const char * const lang       = savepv(PerlEnv_getenv("LANG"));
d513 3
a515 11

    /* A later getenv() could zap this, so only use here */
    const char * const bad_lang_use_once = PerlEnv_getenv("PERL_BADLANG");

    const bool locwarn = (printwarn > 1
                          || (printwarn
                              && (! bad_lang_use_once
                                  || (
                                    /* disallow with "" or "0" */
                                    *bad_lang_use_once
                                    && strNE("0", bad_lang_use_once)))));
a516 8
    char * sl_result;   /* return from setlocale() */
    char * locale_param;
#ifdef WIN32
    /* In some systems you can find out the system default locale
     * and use that as the fallback locale. */
#   define SYSTEM_DEFAULT_LOCALE
#endif
#ifdef SYSTEM_DEFAULT_LOCALE
d518 1
a518 1
#endif
a521 1
    PERL_UNUSED_VAR(locale_param);
d531 1
a531 3
	sl_result = my_setlocale(LC_ALL, setlocale_init);
        DEBUG_LOCALE_INIT(LC_ALL, setlocale_init, sl_result);
	if (sl_result)
d536 1
a536 1
    if (! setlocale_failure) {
d538 5
a542 6
        locale_param = (! done && (lang || PerlEnv_getenv("LC_CTYPE")))
                       ? setlocale_init
                       : NULL;
	curctype = my_setlocale(LC_CTYPE, locale_param);
        DEBUG_LOCALE_INIT(LC_CTYPE, locale_param, sl_result);
	if (! curctype)
d548 5
a552 6
        locale_param = (! done && (lang || PerlEnv_getenv("LC_COLLATE")))
                       ? setlocale_init
                       : NULL;
	curcoll = my_setlocale(LC_COLLATE, locale_param);
        DEBUG_LOCALE_INIT(LC_COLLATE, locale_param, sl_result);
	if (! curcoll)
d558 5
a562 6
        locale_param = (! done && (lang || PerlEnv_getenv("LC_NUMERIC")))
                       ? setlocale_init
                       : NULL;
	curnum = my_setlocale(LC_NUMERIC, locale_param);
        DEBUG_LOCALE_INIT(LC_NUMERIC, locale_param, sl_result);
	if (! curnum)
d568 4
a571 6
        locale_param = (! done && (lang || PerlEnv_getenv("LC_MESSAGES")))
                       ? setlocale_init
                       : NULL;
	sl_result = my_setlocale(LC_MESSAGES, locale_param);
        DEBUG_LOCALE_INIT(LC_MESSAGES, locale_param, sl_result);
	if (! sl_result)
d576 4
a579 6
        locale_param = (! done && (lang || PerlEnv_getenv("LC_MONETARY")))
                       ? setlocale_init
                       : NULL;
	sl_result = my_setlocale(LC_MONETARY, locale_param);
        DEBUG_LOCALE_INIT(LC_MONETARY, locale_param, sl_result);
	if (! sl_result) {
d590 1
a590 3
     * the list.  Normally the loop is executed just once.  But if setting the
     * locale fails, inside the loop we add fallback trials to the array and so
     * will execute the loop multiple times */
d603 2
a604 2
#ifdef SYSTEM_DEFAULT_LOCALE
#  ifdef WIN32
a612 1
                DEBUG_LOCALE_INIT(LC_ALL, "", system_default_locale);
d627 1
a627 2
#  endif /* WIN32 */
#endif /* SYSTEM_DEFAULT_LOCALE */
d631 1
a631 3
        sl_result = my_setlocale(LC_ALL, trial_locale);
        DEBUG_LOCALE_INIT(LC_ALL, trial_locale, sl_result);
        if (! sl_result) {
d649 1
a649 3
            curctype = my_setlocale(LC_CTYPE, trial_locale);
            DEBUG_LOCALE_INIT(LC_CTYPE, trial_locale, curctype);
            if (! curctype)
d656 1
a656 3
            curcoll = my_setlocale(LC_COLLATE, trial_locale);
            DEBUG_LOCALE_INIT(LC_COLLATE, trial_locale, curcoll);
            if (! curcoll)
d663 1
a663 3
            curnum = my_setlocale(LC_NUMERIC, trial_locale);
            DEBUG_LOCALE_INIT(LC_NUMERIC, trial_locale, curnum);
            if (! curnum)
d669 1
a669 3
            sl_result = my_setlocale(LC_MESSAGES, trial_locale);
            DEBUG_LOCALE_INIT(LC_MESSAGES, trial_locale, sl_result);
            if (! (sl_result))
d673 1
a673 3
            sl_result = my_setlocale(LC_MONETARY, trial_locale);
            DEBUG_LOCALE_INIT(LC_MONETARY, trial_locale, sl_result);
            if (! (sl_result))
d698 1
a698 1
#  ifdef USE_LOCALE_CTYPE
d701 2
a702 2
#  endif /* USE_LOCALE_CTYPE */
#  ifdef USE_LOCALE_COLLATE
d705 2
a706 2
#  endif /* USE_LOCALE_COLLATE */
#  ifdef USE_LOCALE_NUMERIC
d709 1
a709 1
#  endif /* USE_LOCALE_NUMERIC */
d758 1
a758 1
             * until we have to, because failure is quite unlikely.  This will
d766 1
a766 6
             * but there's no harm done by doing it explicitly.
             *
             * Note that this tries the LC_ALL environment variable even on
             * systems which have no LC_ALL locale setting.  This may or may
             * not have been originally intentional, but there's no real need
             * to change the behavior. */
a830 1
            DEBUG_LOCALE_INIT(LC_CTYPE, NULL, curctype);
a834 1
            DEBUG_LOCALE_INIT(LC_COLLATE, NULL, curcoll);
a838 1
            DEBUG_LOCALE_INIT(LC_NUMERIC, NULL, curnum);
a848 1
#ifdef SYSTEM_DEFAULT_LOCALE
a854 1
#endif /* SYSTEM_DEFAULT_LOCALE */
d888 1
a888 1
    PL_utf8locale = _is_cur_LC_category_utf8(LC_CTYPE);
a910 9
#ifdef __GLIBC__
    Safefree(language);
#endif

    Safefree(lc_all);
    Safefree(lang);

#else  /* !USE_LOCALE */
    PERL_UNUSED_ARG(printwarn);
d930 1
d982 2
a983 2
bool
Perl__is_cur_LC_category_utf8(pTHX_ int category)
d988 2
a989 4
     * could give the wrong result.  The result will very likely be correct for
     * languages that have commonly used non-ASCII characters, but for notably
     * English, it comes down to if the locale's name ends in something like
     * "UTF-8".  It errs on the side of not being a UTF-8 locale. */
d1007 3
a1009 1
    if (isNAME_C_OR_POSIX(save_input_locale)) {
d1028 1
a1028 1
            save_ctype_locale = setlocale(LC_CTYPE, NULL);
a1033 1
            save_ctype_locale = stdize_locale(savepv(save_ctype_locale));
d1061 1
a1061 1
            char *codeset = nl_langinfo(CODESET);
a1062 1
                codeset = savepv(codeset);
d1080 1
d1111 1
a1111 1
            if ((size_t)mbtowc(&wc, HYPHEN_UTF8, strlen(HYPHEN_UTF8))
d1116 1
a1116 1
                DEBUG_L(PerlIO_printf(Perl_debug_log, "\thyphen=U+%x\n", (unsigned int)wc));
d1136 1
a1136 264
#else   /* nl_langinfo should work if available, so don't bother compiling this
           fallback code.  The final fallback of looking at the name is
           compiled, and will be executed if nl_langinfo fails */

    /* nl_langinfo not available or failed somehow.  Next try looking at the
     * currency symbol to see if it disambiguates things.  Often that will be
     * in the native script, and if the symbol isn't in UTF-8, we know that the
     * locale isn't.  If it is non-ASCII UTF-8, we infer that the locale is
     * too, as the odds of a non-UTF8 string being valid UTF-8 are quite small
     * */

#ifdef HAS_LOCALECONV
#   ifdef USE_LOCALE_MONETARY
    {
        char *save_monetary_locale = NULL;
        bool only_ascii = FALSE;
        bool is_utf8 = FALSE;
        struct lconv* lc;

        /* Like above for LC_CTYPE, we first set LC_MONETARY to the locale of
         * the desired category, if it isn't that locale already */

        if (category != LC_MONETARY) {

            save_monetary_locale = setlocale(LC_MONETARY, NULL);
            if (! save_monetary_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_MONETARY\n"));
                goto cant_use_monetary;
            }
            save_monetary_locale = stdize_locale(savepv(save_monetary_locale));

            if (strEQ(save_monetary_locale, save_input_locale)) {
                Safefree(save_monetary_locale);
                save_monetary_locale = NULL;
            }
            else if (! setlocale(LC_MONETARY, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not change LC_MONETARY locale to %s\n",
                                                        save_input_locale));
                Safefree(save_monetary_locale);
                goto cant_use_monetary;
            }
        }

        /* Here the current LC_MONETARY is set to the locale of the category
         * whose information is desired. */

        lc = localeconv();
        if (! lc
            || ! lc->currency_symbol
            || is_invariant_string((U8 *) lc->currency_symbol, 0))
        {
            DEBUG_L(PerlIO_printf(Perl_debug_log, "Couldn't get currency symbol for %s, or contains only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
            only_ascii = TRUE;
        }
        else {
            is_utf8 = is_utf8_string((U8 *) lc->currency_symbol, 0);
        }

        /* If we changed it, restore LC_MONETARY to its original locale */
        if (save_monetary_locale) {
            setlocale(LC_MONETARY, save_monetary_locale);
            Safefree(save_monetary_locale);
        }

        if (! only_ascii) {

            /* It isn't a UTF-8 locale if the symbol is not legal UTF-8;
             * otherwise assume the locale is UTF-8 if and only if the symbol
             * is non-ascii UTF-8. */
            DEBUG_L(PerlIO_printf(Perl_debug_log, "\t?Currency symbol for %s is UTF-8=%d\n",
                                    save_input_locale, is_utf8));
            Safefree(save_input_locale);
            return is_utf8;
        }
    }
  cant_use_monetary:

#   endif /* USE_LOCALE_MONETARY */
#endif /* HAS_LOCALECONV */

#if defined(HAS_STRFTIME) && defined(USE_LOCALE_TIME)

/* Still haven't found a non-ASCII string to disambiguate UTF-8 or not.  Try
 * the names of the months and weekdays, timezone, and am/pm indicator */
    {
        char *save_time_locale = NULL;
        int hour = 10;
        bool is_dst = FALSE;
        int dom = 1;
        int month = 0;
        int i;
        char * formatted_time;


        /* Like above for LC_MONETARY, we set LC_TIME to the locale of the
         * desired category, if it isn't that locale already */

        if (category != LC_TIME) {

            save_time_locale = setlocale(LC_TIME, NULL);
            if (! save_time_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_TIME\n"));
                goto cant_use_time;
            }
            save_time_locale = stdize_locale(savepv(save_time_locale));

            if (strEQ(save_time_locale, save_input_locale)) {
                Safefree(save_time_locale);
                save_time_locale = NULL;
            }
            else if (! setlocale(LC_TIME, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not change LC_TIME locale to %s\n",
                                                        save_input_locale));
                Safefree(save_time_locale);
                goto cant_use_time;
            }
        }

        /* Here the current LC_TIME is set to the locale of the category
         * whose information is desired.  Look at all the days of the week and
         * month names, and the timezone and am/pm indicator for UTF-8 variant
         * characters.  The first such a one found will tell us if the locale
         * is UTF-8 or not */

        for (i = 0; i < 7 + 12; i++) {  /* 7 days; 12 months */
            formatted_time = my_strftime("%A %B %Z %p",
                                    0, 0, hour, dom, month, 112, 0, 0, is_dst);
            if (! formatted_time || is_invariant_string((U8 *) formatted_time, 0)) {

                /* Here, we didn't find a non-ASCII.  Try the next time through
                 * with the complemented dst and am/pm, and try with the next
                 * weekday.  After we have gotten all weekdays, try the next
                 * month */
                is_dst = ! is_dst;
                hour = (hour + 12) % 24;
                dom++;
                if (i > 6) {
                    month++;
                }
                continue;
            }

            /* Here, we have a non-ASCII.  Return TRUE is it is valid UTF8;
             * false otherwise.  But first, restore LC_TIME to its original
             * locale if we changed it */
            if (save_time_locale) {
                setlocale(LC_TIME, save_time_locale);
                Safefree(save_time_locale);
            }

            DEBUG_L(PerlIO_printf(Perl_debug_log, "\t?time-related strings for %s are UTF-8=%d\n",
                                save_input_locale,
                                is_utf8_string((U8 *) formatted_time, 0)));
            Safefree(save_input_locale);
            return is_utf8_string((U8 *) formatted_time, 0);
        }

        /* Falling off the end of the loop indicates all the names were just
         * ASCII.  Go on to the next test.  If we changed it, restore LC_TIME
         * to its original locale */
        if (save_time_locale) {
            setlocale(LC_TIME, save_time_locale);
            Safefree(save_time_locale);
        }
        DEBUG_L(PerlIO_printf(Perl_debug_log, "All time-related words for %s contain only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
    }
  cant_use_time:

#endif

#if 0 && defined(USE_LOCALE_MESSAGES) && defined(HAS_SYS_ERRLIST)

/* This code is ifdefd out because it was found to not be necessary in testing
 * on our dromedary test machine, which has over 700 locales.  There, this
 * added no value to looking at the currency symbol and the time strings.  I
 * left it in so as to avoid rewriting it if real-world experience indicates
 * that dromedary is an outlier.  Essentially, instead of returning abpve if we
 * haven't found illegal utf8, we continue on and examine all the strerror()
 * messages on the platform for utf8ness.  If all are ASCII, we still don't
 * know the answer; but otherwise we have a pretty good indication of the
 * utf8ness.  The reason this doesn't help much is that the messages may not
 * have been translated into the locale.  The currency symbol and time strings
 * are much more likely to have been translated.  */
    {
        int e;
        bool is_utf8 = FALSE;
        bool non_ascii = FALSE;
        char *save_messages_locale = NULL;
        const char * errmsg = NULL;

        /* Like above, we set LC_MESSAGES to the locale of the desired
         * category, if it isn't that locale already */

        if (category != LC_MESSAGES) {

            save_messages_locale = setlocale(LC_MESSAGES, NULL);
            if (! save_messages_locale) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not find current locale for LC_MESSAGES\n"));
                goto cant_use_messages;
            }
            save_messages_locale = stdize_locale(savepv(save_messages_locale));

            if (strEQ(save_messages_locale, save_input_locale)) {
                Safefree(save_messages_locale);
                save_messages_locale = NULL;
            }
            else if (! setlocale(LC_MESSAGES, save_input_locale)) {
                DEBUG_L(PerlIO_printf(Perl_debug_log,
                            "Could not change LC_MESSAGES locale to %s\n",
                                                        save_input_locale));
                Safefree(save_messages_locale);
                goto cant_use_messages;
            }
        }

        /* Here the current LC_MESSAGES is set to the locale of the category
         * whose information is desired.  Look through all the messages.  We
         * can't use Strerror() here because it may expand to code that
         * segfaults in miniperl */

        for (e = 0; e <= sys_nerr; e++) {
            errno = 0;
            errmsg = sys_errlist[e];
            if (errno || !errmsg) {
                break;
            }
            errmsg = savepv(errmsg);
            if (! is_invariant_string((U8 *) errmsg, 0)) {
                non_ascii = TRUE;
                is_utf8 = is_utf8_string((U8 *) errmsg, 0);
                break;
            }
        }
        Safefree(errmsg);

        /* And, if we changed it, restore LC_MESSAGES to its original locale */
        if (save_messages_locale) {
            setlocale(LC_MESSAGES, save_messages_locale);
            Safefree(save_messages_locale);
        }

        if (non_ascii) {

            /* Any non-UTF-8 message means not a UTF-8 locale; if all are valid,
             * any non-ascii means it is one; otherwise we assume it isn't */
            DEBUG_L(PerlIO_printf(Perl_debug_log, "\t?error messages for %s are UTF-8=%d\n",
                                save_input_locale,
                                is_utf8));
            Safefree(save_input_locale);
            return is_utf8;
        }

        DEBUG_L(PerlIO_printf(Perl_debug_log, "All error messages for %s contain only ASCII; can't use for determining if UTF-8 locale\n", save_input_locale));
    }
  cant_use_messages:

#endif

#endif /* the code that is compiled when no nl_langinfo */
d1138 2
a1139 8
#ifndef EBCDIC  /* On os390, even if the name ends with "UTF-8', it isn't a
                   UTF-8 locale */
    /* As a last resort, look at the locale name to see if it matches
     * qr/UTF -?  * 8 /ix, or some other common locale names.  This "name", the
     * return of setlocale(), is actually defined to be opaque, so we can't
     * really rely on the absence of various substrings in the name to indicate
     * its UTF-8ness, but if it has UTF8 in the name, it is extremely likely to
     * be a UTF-8 locale.  Similarly for the other common names */
d1149 2
a1150 2
            if (!isALPHA_FOLD_NE(*name, 't')
                || isALPHA_FOLD_NE(*(name + 1), 'f'))
d1162 1
a1165 1
                Safefree(save_input_locale);
a1172 1
#endif
d1191 1
a1191 4
    /* Other common encodings are the ISO 8859 series, which aren't UTF-8.  But
     * since we are about to return FALSE anyway, there is no point in doing
     * this extra work */
#if 0
a1198 1
#endif
d1200 1
a1200 6
    DEBUG_L(PerlIO_printf(Perl_debug_log,
                          "Assuming locale %s is not a UTF-8 locale\n",
                                    save_input_locale));
    Safefree(save_input_locale);
    return FALSE;
}
d1202 1
a1202 1
#endif
d1204 9
d1214 5
a1218 7
bool
Perl__is_in_locale_category(pTHX_ const bool compiling, const int category)
{
    dVAR;
    /* Internal function which returns if we are in the scope of a pragma that
     * enables the locale category 'category'.  'compiling' should indicate if
     * this is during the compilation phase (TRUE) or not (FALSE). */
d1220 1
a1220 1
    const COP * const cop = (compiling) ? &PL_compiling : PL_curcop;
d1222 7
a1228 4
    SV *categories = cop_hints_fetch_pvs(cop, "locale", 0);
    if (! categories || categories == &PL_sv_placeholder) {
        return FALSE;
    }
d1230 10
a1239 5
    /* The pseudo-category 'not_characters' is -1, so just add 1 to each to get
     * a valid unsigned */
    assert(category >= -1);
    return cBOOL(SvUV(categories) & (1U << (category + 1)));
}
d1241 2
a1242 3
char *
Perl_my_strerror(pTHX_ const int errnum) {
    dVAR;
d1244 12
a1255 2
    /* Uses C locale for the error text unless within scope of 'use locale' for
     * LC_MESSAGES */
d1257 5
a1261 3
#ifdef USE_LOCALE_MESSAGES
    if (! IN_LC(LC_MESSAGES)) {
        char * save_locale;
d1263 1
a1263 17
        /* We have a critical section to prevent another thread from changing
         * the locale out from under us (or zapping the buffer returned from
         * setlocale() ) */
        LOCALE_LOCK;

        save_locale = setlocale(LC_MESSAGES, NULL);
        if (! isNAME_C_OR_POSIX(save_locale)) {
            char *errstr;

            /* The next setlocale likely will zap this, so create a copy */
            save_locale = savepv(save_locale);

            setlocale(LC_MESSAGES, "C");

            /* This points to the static space in Strerror, with all its
             * limitations */
            errstr = Strerror(errnum);
d1265 11
a1275 2
            setlocale(LC_MESSAGES, save_locale);
            Safefree(save_locale);
a1276 6
            LOCALE_UNLOCK;

            return errstr;
        }

        LOCALE_UNLOCK;
d1278 1
a1278 1
#endif
d1280 2
a1281 2
    return Strerror(errnum);
}
d1283 1
a1283 1
/*
d1285 17
a1301 1
=head1 Locale-related functions and macros
d1303 2
a1304 1
=for apidoc sync_locale
d1306 1
a1306 4
Changing the program's locale should be avoided by XS code.  Nevertheless,
certain non-Perl libraries called from XS, such as C<Gtk> do so.  When this
happens, Perl needs to be told that the locale has changed.  Use this function
to do so, before returning to Perl.
d1308 5
a1312 2
=cut
*/
d1314 8
a1321 3
void
Perl_sync_locale(pTHX)
{
d1323 2
a1324 3
#ifdef USE_LOCALE_CTYPE
    new_ctype(setlocale(LC_CTYPE, NULL));
#endif /* USE_LOCALE_CTYPE */
d1326 3
a1328 2
#ifdef USE_LOCALE_COLLATE
    new_collate(setlocale(LC_COLLATE, NULL));
d1330 13
d1344 5
a1348 69
#ifdef USE_LOCALE_NUMERIC
    set_numeric_local();    /* Switch from "C" to underlying LC_NUMERIC */
    new_numeric(setlocale(LC_NUMERIC, NULL));
#endif /* USE_LOCALE_NUMERIC */

}

#if defined(DEBUGGING) && defined(USE_LOCALE)

char *
Perl__setlocale_debug_string(const int category,        /* category number,
                                                           like LC_ALL */
                            const char* const locale,   /* locale name */

                            /* return value from setlocale() when attempting to
                             * set 'category' to 'locale' */
                            const char* const retval)
{
    /* Returns a pointer to a NUL-terminated string in static storage with
     * added text about the info passed in.  This is not thread safe and will
     * be overwritten by the next call, so this should be used just to
     * formulate a string to immediately print or savepv() on. */

    /* initialise to a non-null value to keep it out of BSS and so keep
     * -DPERL_GLOBAL_STRUCT_PRIVATE happy */
    static char ret[128] = "x";

    my_strlcpy(ret, "setlocale(", sizeof(ret));

    switch (category) {
        default:
            my_snprintf(ret, sizeof(ret), "%s? %d", ret, category);
            break;
#   ifdef LC_ALL
        case LC_ALL:
            my_strlcat(ret, "LC_ALL", sizeof(ret));
            break;
#   endif
#   ifdef LC_CTYPE
        case LC_CTYPE:
            my_strlcat(ret, "LC_CTYPE", sizeof(ret));
            break;
#   endif
#   ifdef LC_NUMERIC
        case LC_NUMERIC:
            my_strlcat(ret, "LC_NUMERIC", sizeof(ret));
            break;
#   endif
#   ifdef LC_COLLATE
        case LC_COLLATE:
            my_strlcat(ret, "LC_COLLATE", sizeof(ret));
            break;
#   endif
#   ifdef LC_TIME
        case LC_TIME:
            my_strlcat(ret, "LC_TIME", sizeof(ret));
            break;
#   endif
#   ifdef LC_MONETARY
        case LC_MONETARY:
            my_strlcat(ret, "LC_MONETARY", sizeof(ret));
            break;
#   endif
#   ifdef LC_MESSAGES
        case LC_MESSAGES:
            my_strlcat(ret, "LC_MESSAGES", sizeof(ret));
            break;
#   endif
    }
d1350 3
a1352 1
    my_strlcat(ret, ", ", sizeof(ret));
a1353 7
    if (locale) {
        my_strlcat(ret, "\"", sizeof(ret));
        my_strlcat(ret, locale, sizeof(ret));
        my_strlcat(ret, "\"", sizeof(ret));
    }
    else {
        my_strlcat(ret, "NULL", sizeof(ret));
d1355 1
d1357 1
a1357 1
    my_strlcat(ret, ") returned ", sizeof(ret));
d1359 5
a1363 12
    if (retval) {
        my_strlcat(ret, "\"", sizeof(ret));
        my_strlcat(ret, retval, sizeof(ret));
        my_strlcat(ret, "\"", sizeof(ret));
    }
    else {
        my_strlcat(ret, "NULL", sizeof(ret));
    }

    assert(strlen(ret) < sizeof(ret));

    return ret;
a1367 1

d1369 6
@


