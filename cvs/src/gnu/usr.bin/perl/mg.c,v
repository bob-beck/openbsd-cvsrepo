head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	PERL_5_24_2:1.1.1.18
	OPENBSD_6_1:1.22.0.4
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.13.0.8
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.6
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.4
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.23
date	2017.08.14.13.48.45;	author afresh1;	state Exp;
branches;
next	1.22;
commitid	CrMEpTqBUsxCMTjx;

1.22
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.21;
commitid	cxJ08BvJA9Pt2PTM;

1.21
date	2016.07.03.01.07.48;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	GzHqjSTnBjdF7Wcw;

1.20
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	XRK22kO4se3v2i2I;

1.19
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	QP75iYx42Uo7mMxO;

1.18
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.17;

1.17
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.24.15.06.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.30.19.20.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2006.03.28.19.22.57;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.15.21.30.19;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.21.32.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.17.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.50;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.41;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.41;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.25;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.06;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.31;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.51;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.27;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.30;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.06;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.27;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.27;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.45;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.37;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.10;	author afresh1;	state Exp;
branches;
next	1.1.1.18;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.18
date	2017.08.14.13.45.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.23
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@/*    mg.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *  Sam sat on the ground and put his head in his hands.  'I wish I had never
 *  come here, and I don't want to see no more magic,' he said, and fell silent.
 *
 *     [p.363 of _The Lord of the Rings_, II/vii: "The Mirror of Galadriel"]
 */

/*
=head1 Magical Functions
"Magic" is special data attached to SV structures in order to give them
"magical" properties.  When any Perl code tries to read from, or assign to,
an SV marked as magical, it calls the 'get' or 'set' function associated
with that SV's magic.  A get is called prior to reading an SV, in order to
give it a chance to update its internal value (get on $. writes the line
number of the last read filehandle into the SV's IV slot), while
set is called after an SV has been written to, in order to allow it to make
use of its changed value (set on $/ copies the SV's new value to the
PL_rs global variable).

Magic is implemented as a linked list of MAGIC structures attached to the
SV.  Each MAGIC struct holds the type of the magic, a pointer to an array
of functions that implement the get(), set(), length() etc functions,
plus space for some flags and pointers.  For example, a tied variable has
a MAGIC structure that contains a pointer to the object associated with the
tie.

=cut

*/

#include "EXTERN.h"
#define PERL_IN_MG_C
#include "perl.h"

#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#  ifdef I_GRP
#    include <grp.h>
#  endif
#endif

#if defined(HAS_SETGROUPS)
#  ifndef NGROUPS
#    define NGROUPS 32
#  endif
#endif

#ifdef __hpux
#  include <sys/pstat.h>
#endif

#ifdef HAS_PRCTL_SET_NAME
#  include <sys/prctl.h>
#endif

#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
Signal_t Perl_csighandler(int sig, siginfo_t *, void *);
#else
Signal_t Perl_csighandler(int sig);
#endif

#ifdef __Lynx__
/* Missing protos on LynxOS */
void setruid(uid_t id);
void seteuid(uid_t id);
void setrgid(uid_t id);
void setegid(uid_t id);
#endif

/*
 * Pre-magic setup and post-magic takedown.
 * Use the "DESTRUCTOR" scope cleanup to reinstate magic.
 */

struct magic_state {
    SV* mgs_sv;
    I32 mgs_ss_ix;
    U32 mgs_flags;
    bool mgs_bumped;
};
/* MGS is typedef'ed to struct magic_state in perl.h */

STATIC void
S_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags)
{
    MGS* mgs;
    bool bumped = FALSE;

    PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS;

    assert(SvMAGICAL(sv));

    /* we shouldn't really be called here with RC==0, but it can sometimes
     * happen via mg_clear() (which also shouldn't be called when RC==0,
     * but it can happen). Handle this case gracefully(ish) by not RC++
     * and thus avoiding the resultant double free */
    if (SvREFCNT(sv) > 0) {
    /* guard against sv getting freed midway through the mg clearing,
     * by holding a private reference for the duration. */
	SvREFCNT_inc_simple_void_NN(sv);
	bumped = TRUE;
    }

    SAVEDESTRUCTOR_X(S_restore_magic, INT2PTR(void*, (IV)mgs_ix));

    mgs = SSPTR(mgs_ix, MGS*);
    mgs->mgs_sv = sv;
    mgs->mgs_flags = SvMAGICAL(sv) | SvREADONLY(sv);
    mgs->mgs_ss_ix = PL_savestack_ix;   /* points after the saved destructor */
    mgs->mgs_bumped = bumped;

    SvFLAGS(sv) &= ~flags;
    SvREADONLY_off(sv);
}

#define save_magic(a,b) save_magic_flags(a,b,SVs_GMG|SVs_SMG|SVs_RMG)

/*
=for apidoc mg_magical

Turns on the magical status of an SV.  See C<L</sv_magic>>.

=cut
*/

void
Perl_mg_magical(SV *sv)
{
    const MAGIC* mg;
    PERL_ARGS_ASSERT_MG_MAGICAL;

    SvMAGICAL_off(sv);
    if ((mg = SvMAGIC(sv))) {
	do {
	    const MGVTBL* const vtbl = mg->mg_virtual;
	    if (vtbl) {
		if (vtbl->svt_get && !(mg->mg_flags & MGf_GSKIP))
		    SvGMAGICAL_on(sv);
		if (vtbl->svt_set)
		    SvSMAGICAL_on(sv);
		if (vtbl->svt_clear)
		    SvRMAGICAL_on(sv);
	    }
	} while ((mg = mg->mg_moremagic));
	if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)))
	    SvRMAGICAL_on(sv);
    }
}

/*
=for apidoc mg_get

Do magic before a value is retrieved from the SV.  The type of SV must
be >= C<SVt_PVMG>.  See C<L</sv_magic>>.

=cut
*/

int
Perl_mg_get(pTHX_ SV *sv)
{
    const I32 mgs_ix = SSNEW(sizeof(MGS));
    bool saved = FALSE;
    bool have_new = 0;
    MAGIC *newmg, *head, *cur, *mg;

    PERL_ARGS_ASSERT_MG_GET;

    if (PL_localizing == 1 && sv == DEFSV) return 0;

    /* We must call svt_get(sv, mg) for each valid entry in the linked
       list of magic. svt_get() may delete the current entry, add new
       magic to the head of the list, or upgrade the SV. AMS 20010810 */

    newmg = cur = head = mg = SvMAGIC(sv);
    while (mg) {
	const MGVTBL * const vtbl = mg->mg_virtual;
	MAGIC * const nextmg = mg->mg_moremagic;	/* it may delete itself */

	if (!(mg->mg_flags & MGf_GSKIP) && vtbl && vtbl->svt_get) {

	    /* taint's mg get is so dumb it doesn't need flag saving */
	    if (!saved && mg->mg_type != PERL_MAGIC_taint) {
		save_magic(mgs_ix, sv);
		saved = TRUE;
	    }

	    vtbl->svt_get(aTHX_ sv, mg);

	    /* guard against magic having been deleted - eg FETCH calling
	     * untie */
	    if (!SvMAGIC(sv)) {
		/* recalculate flags */
		(SSPTR(mgs_ix, MGS *))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);
		break;
	    }

	    /* recalculate flags if this entry was deleted. */
	    if (mg->mg_flags & MGf_GSKIP)
		(SSPTR(mgs_ix, MGS *))->mgs_flags &=
		     ~(SVs_GMG|SVs_SMG|SVs_RMG);
	}
	else if (vtbl == &PL_vtbl_utf8) {
	    /* get-magic can reallocate the PV */
	    magic_setutf8(sv, mg);
	}

	mg = nextmg;

	if (have_new) {
	    /* Have we finished with the new entries we saw? Start again
	       where we left off (unless there are more new entries). */
	    if (mg == head) {
		have_new = 0;
		mg   = cur;
		head = newmg;
	    }
	}

	/* Were any new entries added? */
	if (!have_new && (newmg = SvMAGIC(sv)) != head) {
	    have_new = 1;
	    cur = mg;
	    mg  = newmg;
	    /* recalculate flags */
	    (SSPTR(mgs_ix, MGS *))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);
	}
    }

    if (saved)
	restore_magic(INT2PTR(void *, (IV)mgs_ix));

    return 0;
}

/*
=for apidoc mg_set

Do magic after a value is assigned to the SV.  See C<L</sv_magic>>.

=cut
*/

int
Perl_mg_set(pTHX_ SV *sv)
{
    const I32 mgs_ix = SSNEW(sizeof(MGS));
    MAGIC* mg;
    MAGIC* nextmg;

    PERL_ARGS_ASSERT_MG_SET;

    if (PL_localizing == 2 && sv == DEFSV) return 0;

    save_magic_flags(mgs_ix, sv, SVs_GMG|SVs_SMG); /* leave SVs_RMG on */

    for (mg = SvMAGIC(sv); mg; mg = nextmg) {
        const MGVTBL* vtbl = mg->mg_virtual;
	nextmg = mg->mg_moremagic;	/* it may delete itself */
	if (mg->mg_flags & MGf_GSKIP) {
	    mg->mg_flags &= ~MGf_GSKIP;	/* setting requires another read */
	    (SSPTR(mgs_ix, MGS*))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);
	}
	if (PL_localizing == 2
	    && PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type))
	    continue;
	if (vtbl && vtbl->svt_set)
	    vtbl->svt_set(aTHX_ sv, mg);
    }

    restore_magic(INT2PTR(void*, (IV)mgs_ix));
    return 0;
}

/*
=for apidoc mg_length

Reports on the SV's length in bytes, calling length magic if available,
but does not set the UTF8 flag on C<sv>.  It will fall back to 'get'
magic if there is no 'length' magic, but with no indication as to
whether it called 'get' magic.  It assumes C<sv> is a C<PVMG> or
higher.  Use C<sv_len()> instead.

=cut
*/

U32
Perl_mg_length(pTHX_ SV *sv)
{
    MAGIC* mg;
    STRLEN len;

    PERL_ARGS_ASSERT_MG_LENGTH;

    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
        const MGVTBL * const vtbl = mg->mg_virtual;
	if (vtbl && vtbl->svt_len) {
            const I32 mgs_ix = SSNEW(sizeof(MGS));
	    save_magic(mgs_ix, sv);
	    /* omit MGf_GSKIP -- not changed here */
	    len = vtbl->svt_len(aTHX_ sv, mg);
	    restore_magic(INT2PTR(void*, (IV)mgs_ix));
	    return len;
	}
    }

    (void)SvPV_const(sv, len);
    return len;
}

I32
Perl_mg_size(pTHX_ SV *sv)
{
    MAGIC* mg;

    PERL_ARGS_ASSERT_MG_SIZE;

    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
        const MGVTBL* const vtbl = mg->mg_virtual;
	if (vtbl && vtbl->svt_len) {
            const I32 mgs_ix = SSNEW(sizeof(MGS));
            I32 len;
	    save_magic(mgs_ix, sv);
	    /* omit MGf_GSKIP -- not changed here */
	    len = vtbl->svt_len(aTHX_ sv, mg);
	    restore_magic(INT2PTR(void*, (IV)mgs_ix));
	    return len;
	}
    }

    switch(SvTYPE(sv)) {
	case SVt_PVAV:
	    return AvFILLp((const AV *) sv); /* Fallback to non-tied array */
	case SVt_PVHV:
	    /* FIXME */
	default:
	    Perl_croak(aTHX_ "Size magic not implemented");

    }
    NOT_REACHED; /* NOTREACHED */
}

/*
=for apidoc mg_clear

Clear something magical that the SV represents.  See C<L</sv_magic>>.

=cut
*/

int
Perl_mg_clear(pTHX_ SV *sv)
{
    const I32 mgs_ix = SSNEW(sizeof(MGS));
    MAGIC* mg;
    MAGIC *nextmg;

    PERL_ARGS_ASSERT_MG_CLEAR;

    save_magic(mgs_ix, sv);

    for (mg = SvMAGIC(sv); mg; mg = nextmg) {
        const MGVTBL* const vtbl = mg->mg_virtual;
	/* omit GSKIP -- never set here */

	nextmg = mg->mg_moremagic; /* it may delete itself */

	if (vtbl && vtbl->svt_clear)
	    vtbl->svt_clear(aTHX_ sv, mg);
    }

    restore_magic(INT2PTR(void*, (IV)mgs_ix));
    return 0;
}

static MAGIC*
S_mg_findext_flags(const SV *sv, int type, const MGVTBL *vtbl, U32 flags)
{
    assert(flags <= 1);

    if (sv) {
	MAGIC *mg;

	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	    if (mg->mg_type == type && (!flags || mg->mg_virtual == vtbl)) {
		return mg;
	    }
	}
    }

    return NULL;
}

/*
=for apidoc mg_find

Finds the magic pointer for C<type> matching the SV.  See C<L</sv_magic>>.

=cut
*/

MAGIC*
Perl_mg_find(const SV *sv, int type)
{
    return S_mg_findext_flags(sv, type, NULL, 0);
}

/*
=for apidoc mg_findext

Finds the magic pointer of C<type> with the given C<vtbl> for the C<SV>.  See
C<L</sv_magicext>>.

=cut
*/

MAGIC*
Perl_mg_findext(const SV *sv, int type, const MGVTBL *vtbl)
{
    return S_mg_findext_flags(sv, type, vtbl, 1);
}

MAGIC *
Perl_mg_find_mglob(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_MG_FIND_MGLOB;
    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y') {
        /* This sv is only a delegate.  //g magic must be attached to
           its target. */
        vivify_defelem(sv);
        sv = LvTARG(sv);
    }
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv))
        return S_mg_findext_flags(sv, PERL_MAGIC_regex_global, 0, 0);
    return NULL;
}

/*
=for apidoc mg_copy

Copies the magic from one SV to another.  See C<L</sv_magic>>.

=cut
*/

int
Perl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen)
{
    int count = 0;
    MAGIC* mg;

    PERL_ARGS_ASSERT_MG_COPY;

    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
        const MGVTBL* const vtbl = mg->mg_virtual;
	if ((mg->mg_flags & MGf_COPY) && vtbl->svt_copy){
	    count += vtbl->svt_copy(aTHX_ sv, mg, nsv, key, klen);
	}
	else {
	    const char type = mg->mg_type;
	    if (isUPPER(type) && type != PERL_MAGIC_uvar) {
		sv_magic(nsv,
		     (type == PERL_MAGIC_tied)
			? SvTIED_obj(sv, mg)
			: (type == PERL_MAGIC_regdata && mg->mg_obj)
			    ? sv
			    : mg->mg_obj,
		     toLOWER(type), key, klen);
		count++;
	    }
	}
    }
    return count;
}

/*
=for apidoc mg_localize

Copy some of the magic from an existing SV to new localized version of that
SV.  Container magic (I<e.g.>, C<%ENV>, C<$1>, C<tie>)
gets copied, value magic doesn't (I<e.g.>,
C<taint>, C<pos>).

If C<setmagic> is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. S<C<'local $x = $y'>>),
and that will handle the magic.

=cut
*/

void
Perl_mg_localize(pTHX_ SV *sv, SV *nsv, bool setmagic)
{
    MAGIC *mg;

    PERL_ARGS_ASSERT_MG_LOCALIZE;

    if (nsv == DEFSV)
	return;

    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	const MGVTBL* const vtbl = mg->mg_virtual;
	if (PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type))
	    continue;
		
	if ((mg->mg_flags & MGf_LOCAL) && vtbl->svt_local)
	    (void)vtbl->svt_local(aTHX_ nsv, mg);
	else
	    sv_magicext(nsv, mg->mg_obj, mg->mg_type, vtbl,
			    mg->mg_ptr, mg->mg_len);

	/* container types should remain read-only across localization */
	SvFLAGS(nsv) |= SvREADONLY(sv);
    }

    if (SvTYPE(nsv) >= SVt_PVMG && SvMAGIC(nsv)) {
	SvFLAGS(nsv) |= SvMAGICAL(sv);
	if (setmagic) {
	    PL_localizing = 1;
	    SvSETMAGIC(nsv);
	    PL_localizing = 0;
	}
    }	    
}

#define mg_free_struct(sv, mg) S_mg_free_struct(aTHX_ sv, mg)
static void
S_mg_free_struct(pTHX_ SV *sv, MAGIC *mg)
{
    const MGVTBL* const vtbl = mg->mg_virtual;
    if (vtbl && vtbl->svt_free)
	vtbl->svt_free(aTHX_ sv, mg);
    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
	if (mg->mg_len > 0 || mg->mg_type == PERL_MAGIC_utf8)
	    Safefree(mg->mg_ptr);
	else if (mg->mg_len == HEf_SVKEY)
	    SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
    }
    if (mg->mg_flags & MGf_REFCOUNTED)
	SvREFCNT_dec(mg->mg_obj);
    Safefree(mg);
}

/*
=for apidoc mg_free

Free any magic storage used by the SV.  See C<L</sv_magic>>.

=cut
*/

int
Perl_mg_free(pTHX_ SV *sv)
{
    MAGIC* mg;
    MAGIC* moremagic;

    PERL_ARGS_ASSERT_MG_FREE;

    for (mg = SvMAGIC(sv); mg; mg = moremagic) {
	moremagic = mg->mg_moremagic;
	mg_free_struct(sv, mg);
	SvMAGIC_set(sv, moremagic);
    }
    SvMAGIC_set(sv, NULL);
    SvMAGICAL_off(sv);
    return 0;
}

/*
=for apidoc Am|void|mg_free_type|SV *sv|int how

Remove any magic of type C<how> from the SV C<sv>.  See L</sv_magic>.

=cut
*/

void
Perl_mg_free_type(pTHX_ SV *sv, int how)
{
    MAGIC *mg, *prevmg, *moremg;
    PERL_ARGS_ASSERT_MG_FREE_TYPE;
    for (prevmg = NULL, mg = SvMAGIC(sv); mg; prevmg = mg, mg = moremg) {
	MAGIC *newhead;
	moremg = mg->mg_moremagic;
	if (mg->mg_type == how) {
	    /* temporarily move to the head of the magic chain, in case
	       custom free code relies on this historical aspect of mg_free */
	    if (prevmg) {
		prevmg->mg_moremagic = moremg;
		mg->mg_moremagic = SvMAGIC(sv);
		SvMAGIC_set(sv, mg);
	    }
	    newhead = mg->mg_moremagic;
	    mg_free_struct(sv, mg);
	    SvMAGIC_set(sv, newhead);
	    mg = prevmg;
	}
    }
    mg_magical(sv);
}

#include <signal.h>

U32
Perl_magic_regdata_cnt(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_UNUSED_ARG(sv);

    PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT;

    if (PL_curpm) {
	const REGEXP * const rx = PM_GETRE(PL_curpm);
	if (rx) {
	    if (mg->mg_obj) {			/* @@+ */
		/* return the number possible */
		return RX_NPARENS(rx);
	    } else {				/* @@- */
		I32 paren = RX_LASTPAREN(rx);

		/* return the last filled */
		while ( paren >= 0
			&& (RX_OFFS(rx)[paren].start == -1
			    || RX_OFFS(rx)[paren].end == -1) )
		    paren--;
		return (U32)paren;
	    }
	}
    }

    return (U32)-1;
}

/* @@-, @@+ */

int
Perl_magic_regdatum_get(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET;

    if (PL_curpm) {
	const REGEXP * const rx = PM_GETRE(PL_curpm);
	if (rx) {
	    const I32 paren = mg->mg_len;
	    SSize_t s;
	    SSize_t t;
	    if (paren < 0)
		return 0;
	    if (paren <= (I32)RX_NPARENS(rx) &&
		(s = RX_OFFS(rx)[paren].start) != -1 &&
		(t = RX_OFFS(rx)[paren].end) != -1)
		{
		    SSize_t i;
		    if (mg->mg_obj)		/* @@+ */
			i = t;
		    else			/* @@- */
			i = s;

		    if (RX_MATCH_UTF8(rx)) {
			const char * const b = RX_SUBBEG(rx);
			if (b)
			    i = RX_SUBCOFFSET(rx) +
                                    utf8_length((U8*)b,
                                        (U8*)(b-RX_SUBOFFSET(rx)+i));
		    }

		    sv_setuv(sv, i);
		    return 0;
		}
	}
    }
    sv_setsv(sv, NULL);
    return 0;
}

/* @@-, @@+ */

int
Perl_magic_regdatum_set(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
    Perl_croak_no_modify();
    NORETURN_FUNCTION_END;
}

#define SvRTRIM(sv) STMT_START { \
    if (SvPOK(sv)) { \
        STRLEN len = SvCUR(sv); \
        char * const p = SvPVX(sv); \
	while (len > 0 && isSPACE(p[len-1])) \
	   --len; \
	SvCUR_set(sv, len); \
	p[len] = '\0'; \
    } \
} STMT_END

void
Perl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv)
{
    PERL_ARGS_ASSERT_EMULATE_COP_IO;

    if (!(CopHINTS_get(c) & (HINT_LEXICAL_IO_IN|HINT_LEXICAL_IO_OUT)))
	sv_setsv(sv, &PL_sv_undef);
    else {
	sv_setpvs(sv, "");
	SvUTF8_off(sv);
	if ((CopHINTS_get(c) & HINT_LEXICAL_IO_IN)) {
	    SV *const value = cop_hints_fetch_pvs(c, "open<", 0);
	    assert(value);
	    sv_catsv(sv, value);
	}
	sv_catpvs(sv, "\0");
	if ((CopHINTS_get(c) & HINT_LEXICAL_IO_OUT)) {
	    SV *const value = cop_hints_fetch_pvs(c, "open>", 0);
	    assert(value);
	    sv_catsv(sv, value);
	}
    }
}

STATIC void
S_fixup_errno_string(pTHX_ SV* sv)
{
    /* Do what is necessary to fixup the non-empty string in 'sv' for return to
     * Perl space. */

    PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING;

    assert(SvOK(sv));

    if(strEQ(SvPVX(sv), "")) {
	sv_catpv(sv, UNKNOWN_ERRNO_MSG);
    }
    else {

        /* In some locales the error string may come back as UTF-8, in which
         * case we should turn on that flag.  This didn't use to happen, and to
         * avoid as many possible backward compatibility issues as possible, we
         * don't turn on the flag unless we have to.  So the flag stays off for
         * an entirely invariant string.  We assume that if the string looks
         * like UTF-8, it really is UTF-8:  "text in any other encoding that
         * uses bytes with the high bit set is extremely unlikely to pass a
         * UTF-8 validity test"
         * (http://en.wikipedia.org/wiki/Charset_detection).  There is a
         * potential that we will get it wrong however, especially on short
         * error message text.  (If it turns out to be necessary, we could also
         * keep track if the current LC_MESSAGES locale is UTF-8) */
        if (! IN_BYTES  /* respect 'use bytes' */
            && ! is_invariant_string((U8*) SvPVX_const(sv), SvCUR(sv))
            && is_utf8_string((U8*) SvPVX_const(sv), SvCUR(sv)))
        {
            SvUTF8_on(sv);
        }
    }
}

SV*
Perl__get_encoding(pTHX)
{
    /* For core Perl use only: Returns the $^ENCODING or 'use encoding' in
     * effect; NULL if none.
     *
     * $^ENCODING maps to PL_encoding, and is the old way to do things, and is
     * retained for backwards compatibility.  Now, there is a shadow variable
     * ${^E_NCODING} set only by the encoding pragma, used to give this pragma
     * lexical scope, unlike the global scope it (shudder) used to have.  This
     * variable maps to PL_lex_encoding.  Again for backwards compatibility,
     * PL_encoding has precedence over PL_lex_encoding.  The hints hash is used
     * to determine if PL_lex_encoding is in scope, and hence valid.  The hints
     * hash only accepts simple values, so we can't put an Encode object into
     * it, so we put the object into the global, and put a simple boolean into
     * the hints hash giving whether the global is valid or not */

    dVAR;
    SV *is_encoding;

    if (PL_encoding) {
        return PL_encoding;
    }

    if (! PL_lex_encoding) {
        return NULL;
    }

    is_encoding = cop_hints_fetch_pvs(PL_curcop, "encoding", 0);
    if (   is_encoding
        && is_encoding != &PL_sv_placeholder
        && SvIOK(is_encoding)
        && SvIV(is_encoding))  /* non-zero mean valid */
    {
        return PL_lex_encoding;
    }

    return NULL;
}

#ifdef VMS
#include <descrip.h>
#include <starlet.h>
#endif

int
Perl_magic_get(pTHX_ SV *sv, MAGIC *mg)
{
    I32 paren;
    const char *s = NULL;
    REGEXP *rx;
    const char * const remaining = mg->mg_ptr + 1;
    char nextchar;

    PERL_ARGS_ASSERT_MAGIC_GET;

    if (!mg->mg_ptr) {
        paren = mg->mg_len;
        if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
          do_numbuf_fetch:
            CALLREG_NUMBUF_FETCH(rx,paren,sv);
        } else {
            sv_setsv(sv,&PL_sv_undef);
        }
        return 0;
    }

    nextchar = *remaining;
    switch (*mg->mg_ptr) {
    case '\001':		/* ^A */
	if (SvOK(PL_bodytarget)) sv_copypv(sv, PL_bodytarget);
	else sv_setsv(sv, &PL_sv_undef);
	if (SvTAINTED(PL_bodytarget))
	    SvTAINTED_on(sv);
	break;
    case '\003':		/* ^C, ^CHILD_ERROR_NATIVE */
	if (nextchar == '\0') {
	    sv_setiv(sv, (IV)PL_minus_c);
	}
	else if (strEQ(remaining, "HILD_ERROR_NATIVE")) {
	    sv_setiv(sv, (IV)STATUS_NATIVE);
        }
	break;

    case '\004':		/* ^D */
	sv_setiv(sv, (IV)(PL_debug & DEBUG_MASK));
	break;
    case '\005':  /* ^E */
	 if (nextchar != '\0') {
            if (strEQ(remaining, "NCODING"))
                sv_setsv(sv, _get_encoding());
            else if (strEQ(remaining, "_NCODING"))
                sv_setsv(sv, NULL);
            break;
        }

#if defined(VMS) || defined(OS2) || defined(WIN32)
#   if defined(VMS)
        {
            char msg[255];
            $DESCRIPTOR(msgdsc,msg);
            sv_setnv(sv,(NV) vaxc$errno);
            if (sys$getmsg(vaxc$errno,&msgdsc.dsc$w_length,&msgdsc,0,0) & 1)
                sv_setpvn(sv,msgdsc.dsc$a_pointer,msgdsc.dsc$w_length);
            else
                sv_setpvs(sv,"");
        }
#elif defined(OS2)
        if (!(_emx_env & 0x200)) {	/* Under DOS */
            sv_setnv(sv, (NV)errno);
            sv_setpv(sv, errno ? my_strerror(errno) : "");
        } else {
            if (errno != errno_isOS2) {
                const int tmp = _syserrno();
                if (tmp)	/* 2nd call to _syserrno() makes it 0 */
                    Perl_rc = tmp;
            }
            sv_setnv(sv, (NV)Perl_rc);
            sv_setpv(sv, os2error(Perl_rc));
        }
        if (SvOK(sv) && strNE(SvPVX(sv), "")) {
            fixup_errno_string(sv);
        }
#   elif defined(WIN32)
        {
            const DWORD dwErr = GetLastError();
            sv_setnv(sv, (NV)dwErr);
            if (dwErr) {
                PerlProc_GetOSError(sv, dwErr);
                fixup_errno_string(sv);
            }
            else
                sv_setpvs(sv, "");
            SetLastError(dwErr);
        }
#   else
#   error Missing code for platform
#   endif
        SvRTRIM(sv);
        SvNOK_on(sv);	/* what a wonderful hack! */
	break;
#endif  /* End of platforms with special handling for $^E; others just fall
           through to $! */

    case '!':
	{
            dSAVE_ERRNO;
#ifdef VMS
            sv_setnv(sv, (NV)((errno == EVMSERR) ? vaxc$errno : errno));
#else
            sv_setnv(sv, (NV)errno);
#endif
#ifdef OS2
            if (errno == errno_isOS2 || errno == errno_isOS2_set)
                sv_setpv(sv, os2error(Perl_rc));
            else
#endif
            if (! errno) {
                sv_setpvs(sv, "");
            }
            else {

                /* Strerror can return NULL on some platforms, which will
                 * result in 'sv' not being considered SvOK.  The SvNOK_on()
                 * below will cause just the number part to be valid */
                sv_setpv(sv, my_strerror(errno));
                if (SvOK(sv)) {
                    fixup_errno_string(sv);
                }
            }
            RESTORE_ERRNO;
	}

	SvRTRIM(sv);
	SvNOK_on(sv);	/* what a wonderful hack! */
	break;

    case '\006':		/* ^F */
	sv_setiv(sv, (IV)PL_maxsysfd);
	break;
    case '\007':		/* ^GLOBAL_PHASE */
	if (strEQ(remaining, "LOBAL_PHASE")) {
	    sv_setpvn(sv, PL_phase_names[PL_phase],
		      strlen(PL_phase_names[PL_phase]));
	}
	break;
    case '\010':		/* ^H */
	sv_setiv(sv, (IV)PL_hints);
	break;
    case '\011':		/* ^I */ /* NOT \t in EBCDIC */
	sv_setpv(sv, PL_inplace); /* Will undefine sv if PL_inplace is NULL */
	break;
    case '\014':		/* ^LAST_FH */
	if (strEQ(remaining, "AST_FH")) {
	    if (PL_last_in_gv) {
		assert(isGV_with_GP(PL_last_in_gv));
		SV_CHECK_THINKFIRST_COW_DROP(sv);
		prepare_SV_for_RV(sv);
		SvOK_off(sv);
		SvRV_set(sv, SvREFCNT_inc_simple_NN(PL_last_in_gv));
		SvROK_on(sv);
		sv_rvweaken(sv);
	    }
	    else sv_setsv_nomg(sv, NULL);
	}
	break;
    case '\017':		/* ^O & ^OPEN */
	if (nextchar == '\0') {
	    sv_setpv(sv, PL_osname);
	    SvTAINTED_off(sv);
	}
	else if (strEQ(remaining, "PEN")) {
	    Perl_emulate_cop_io(aTHX_ &PL_compiling, sv);
	}
	break;
    case '\020':
        sv_setiv(sv, (IV)PL_perldb);
	break;
    case '\023':		/* ^S */
        {
	    if (PL_parser && PL_parser->lex_state != LEX_NOTPARSING)
		SvOK_off(sv);
	    else if (PL_in_eval)
 		sv_setiv(sv, PL_in_eval & ~(EVAL_INREQUIRE));
	    else
		sv_setiv(sv, 0);
	}
	break;
    case '\024':		/* ^T */
	if (nextchar == '\0') {
#ifdef BIG_TIME
            sv_setnv(sv, PL_basetime);
#else
            sv_setiv(sv, (IV)PL_basetime);
#endif
        }
	else if (strEQ(remaining, "AINT"))
            sv_setiv(sv, TAINTING_get
		    ? (TAINT_WARN_get || PL_unsafe ? -1 : 1)
		    : 0);
        break;
    case '\025':		/* $^UNICODE, $^UTF8LOCALE, $^UTF8CACHE */
	if (strEQ(remaining, "NICODE"))
	    sv_setuv(sv, (UV) PL_unicode);
	else if (strEQ(remaining, "TF8LOCALE"))
	    sv_setuv(sv, (UV) PL_utf8locale);
	else if (strEQ(remaining, "TF8CACHE"))
	    sv_setiv(sv, (IV) PL_utf8cache);
        break;
    case '\027':		/* ^W  & $^WARNING_BITS */
	if (nextchar == '\0')
	    sv_setiv(sv, (IV)((PL_dowarn & G_WARN_ON) ? TRUE : FALSE));
	else if (strEQ(remaining, "ARNING_BITS")) {
	    if (PL_compiling.cop_warnings == pWARN_NONE) {
	        sv_setpvn(sv, WARN_NONEstring, WARNsize) ;
	    }
	    else if (PL_compiling.cop_warnings == pWARN_STD) {
		sv_setsv(sv, &PL_sv_undef);
		break;
	    }
            else if (PL_compiling.cop_warnings == pWARN_ALL) {
		/* Get the bit mask for $warnings::Bits{all}, because
		 * it could have been extended by warnings::register */
		HV * const bits = get_hv("warnings::Bits", 0);
		SV ** const bits_all = bits ? hv_fetchs(bits, "all", FALSE) : NULL;
		if (bits_all)
		    sv_copypv(sv, *bits_all);
	        else
		    sv_setpvn(sv, WARN_ALLstring, WARNsize);
	    }
            else {
	        sv_setpvn(sv, (char *) (PL_compiling.cop_warnings + 1),
			  *PL_compiling.cop_warnings);
	    }
	}
#ifdef WIN32
	else if (strEQ(remaining, "IN32_SLOPPY_STAT")) {
	    sv_setiv(sv, w32_sloppystat);
	}
#endif
	break;
    case '+':
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    paren = RX_LASTPAREN(rx);
	    if (paren)
                goto do_numbuf_fetch;
	}
	sv_setsv(sv,&PL_sv_undef);
	break;
    case '\016':		/* ^N */
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    paren = RX_LASTCLOSEPAREN(rx);
	    if (paren)
                goto do_numbuf_fetch;
	}
	sv_setsv(sv,&PL_sv_undef);
	break;
    case '.':
	if (GvIO(PL_last_in_gv)) {
	    sv_setiv(sv, (IV)IoLINES(GvIOp(PL_last_in_gv)));
	}
	break;
    case '?':
	{
	    sv_setiv(sv, (IV)STATUS_CURRENT);
#ifdef COMPLEX_STATUS
	    SvUPGRADE(sv, SVt_PVLV);
	    LvTARGOFF(sv) = PL_statusvalue;
	    LvTARGLEN(sv) = PL_statusvalue_vms;
#endif
	}
	break;
    case '^':
	if (GvIOp(PL_defoutgv))
		s = IoTOP_NAME(GvIOp(PL_defoutgv));
	if (s)
	    sv_setpv(sv,s);
	else {
	    sv_setpv(sv,GvENAME(PL_defoutgv));
	    sv_catpvs(sv,"_TOP");
	}
	break;
    case '~':
	if (GvIOp(PL_defoutgv))
	    s = IoFMT_NAME(GvIOp(PL_defoutgv));
	if (!s)
	    s = GvENAME(PL_defoutgv);
	sv_setpv(sv,s);
	break;
    case '=':
	if (GvIO(PL_defoutgv))
	    sv_setiv(sv, (IV)IoPAGE_LEN(GvIOp(PL_defoutgv)));
	break;
    case '-':
	if (GvIO(PL_defoutgv))
	    sv_setiv(sv, (IV)IoLINES_LEFT(GvIOp(PL_defoutgv)));
	break;
    case '%':
	if (GvIO(PL_defoutgv))
	    sv_setiv(sv, (IV)IoPAGE(GvIOp(PL_defoutgv)));
	break;
    case ':':
    case '/':
	break;
    case '[':
	sv_setiv(sv, 0);
	break;
    case '|':
	if (GvIO(PL_defoutgv))
	    sv_setiv(sv, (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0 );
	break;
    case '\\':
	if (PL_ors_sv)
	    sv_copypv(sv, PL_ors_sv);
	else
	    sv_setsv(sv, &PL_sv_undef);
	break;
    case '$': /* $$ */
	{
	    IV const pid = (IV)PerlProc_getpid();
	    if (isGV(mg->mg_obj) || SvIV(mg->mg_obj) != pid) {
		/* never set manually, or at least not since last fork */
		sv_setiv(sv, pid);
		/* never unsafe, even if reading in a tainted expression */
		SvTAINTED_off(sv);
	    }
	    /* else a value has been assigned manually, so do nothing */
	}
	break;
    case '<':
        sv_setuid(sv, PerlProc_getuid());
	break;
    case '>':
        sv_setuid(sv, PerlProc_geteuid());
	break;
    case '(':
        sv_setgid(sv, PerlProc_getgid());
	goto add_groups;
    case ')':
        sv_setgid(sv, PerlProc_getegid());
      add_groups:
#ifdef HAS_GETGROUPS
	{
	    Groups_t *gary = NULL;
	    I32 i;
            I32 num_groups = getgroups(0, gary);
            if (num_groups > 0) {
                Newx(gary, num_groups, Groups_t);
                num_groups = getgroups(num_groups, gary);
                for (i = 0; i < num_groups; i++)
                    Perl_sv_catpvf(aTHX_ sv, " %"IVdf, (IV)gary[i]);
                Safefree(gary);
            }
	}
	(void)SvIOK_on(sv);	/* what a wonderful hack! */
#endif
	break;
    case '0':
	break;
    }
    return 0;
}

int
Perl_magic_getuvar(pTHX_ SV *sv, MAGIC *mg)
{
    struct ufuncs * const uf = (struct ufuncs *)mg->mg_ptr;

    PERL_ARGS_ASSERT_MAGIC_GETUVAR;

    if (uf && uf->uf_val)
	(*uf->uf_val)(aTHX_ uf->uf_index, sv);
    return 0;
}

int
Perl_magic_setenv(pTHX_ SV *sv, MAGIC *mg)
{
    STRLEN len = 0, klen;
    const char * const key = MgPV_const(mg,klen);
    const char *s = "";

    PERL_ARGS_ASSERT_MAGIC_SETENV;

    SvGETMAGIC(sv);
    if (SvOK(sv)) {
        /* defined environment variables are byte strings; unfortunately
           there is no SvPVbyte_force_nomg(), so we must do this piecewise */
        (void)SvPV_force_nomg_nolen(sv);
        sv_utf8_downgrade(sv, /* fail_ok */ TRUE);
        if (SvUTF8(sv)) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), "Wide character in %s", "setenv");
            SvUTF8_off(sv);
        }
        s = SvPVX(sv);
        len = SvCUR(sv);
    }
    my_setenv(key, s); /* does the deed */

#ifdef DYNAMIC_ENV_FETCH
     /* We just undefd an environment var.  Is a replacement */
     /* waiting in the wings? */
    if (!len) {
	SV ** const valp = hv_fetch(GvHVn(PL_envgv), key, klen, FALSE);
	if (valp)
	    s = SvOK(*valp) ? SvPV_const(*valp, len) : "";
    }
#endif

#if !defined(OS2) && !defined(WIN32) && !defined(MSDOS)
			    /* And you'll never guess what the dog had */
			    /*   in its mouth... */
    if (TAINTING_get) {
	MgTAINTEDDIR_off(mg);
#ifdef VMS
	if (s && klen == 8 && strEQ(key, "DCL$PATH")) {
	    char pathbuf[256], eltbuf[256], *cp, *elt;
	    int i = 0, j = 0;

	    my_strlcpy(eltbuf, s, sizeof(eltbuf));
	    elt = eltbuf;
	    do {          /* DCL$PATH may be a search list */
		while (1) {   /* as may dev portion of any element */
		    if ( ((cp = strchr(elt,'[')) || (cp = strchr(elt,'<'))) ) {
			if ( *(cp+1) == '.' || *(cp+1) == '-' ||
			     cando_by_name(S_IWUSR,0,elt) ) {
			    MgTAINTEDDIR_on(mg);
			    return 0;
			}
		    }
		    if ((cp = strchr(elt, ':')) != NULL)
			*cp = '\0';
		    if (my_trnlnm(elt, eltbuf, j++))
			elt = eltbuf;
		    else
			break;
		}
		j = 0;
	    } while (my_trnlnm(s, pathbuf, i++) && (elt = pathbuf));
	}
#endif /* VMS */
	if (s && klen == 4 && strEQ(key,"PATH")) {
	    const char * const strend = s + len;

	    while (s < strend) {
		char tmpbuf[256];
		Stat_t st;
		I32 i;
#ifdef VMS  /* Hmm.  How do we get $Config{path_sep} from C? */
		const char path_sep = '|';
#else
		const char path_sep = ':';
#endif
		s = delimcpy_no_escape(tmpbuf, tmpbuf + sizeof tmpbuf,
			     s, strend, path_sep, &i);
		s++;
		if (i >= (I32)sizeof tmpbuf   /* too long -- assume the worst */
#ifdef VMS
		      || !strchr(tmpbuf, ':') /* no colon thus no device name -- assume relative path */
#else
		      || *tmpbuf != '/'       /* no starting slash -- assume relative path */
#endif
		      || (PerlLIO_stat(tmpbuf, &st) == 0 && (st.st_mode & 2)) ) {
		    MgTAINTEDDIR_on(mg);
		    return 0;
		}
	    }
	}
    }
#endif /* neither OS2 nor WIN32 nor MSDOS */

    return 0;
}

int
Perl_magic_clearenv(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARENV;
    PERL_UNUSED_ARG(sv);
    my_setenv(MgPV_nolen_const(mg),NULL);
    return 0;
}

int
Perl_magic_set_all_env(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV;
    PERL_UNUSED_ARG(mg);
#if defined(VMS)
    Perl_die(aTHX_ "Can't make list assignment to %%ENV on this system");
#else
    if (PL_localizing) {
	HE* entry;
	my_clearenv();
	hv_iterinit(MUTABLE_HV(sv));
	while ((entry = hv_iternext(MUTABLE_HV(sv)))) {
	    I32 keylen;
	    my_setenv(hv_iterkey(entry, &keylen),
		      SvPV_nolen_const(hv_iterval(MUTABLE_HV(sv), entry)));
	}
    }
#endif
    return 0;
}

int
Perl_magic_clear_all_env(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEAR_ALL_ENV;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
#if defined(VMS)
    Perl_die(aTHX_ "Can't make list assignment to %%ENV on this system");
#else
    my_clearenv();
#endif
    return 0;
}

#ifndef PERL_MICRO
#ifdef HAS_SIGPROCMASK
static void
restore_sigmask(pTHX_ SV *save_sv)
{
    const sigset_t * const ossetp = (const sigset_t *) SvPV_nolen_const( save_sv );
    (void)sigprocmask(SIG_SETMASK, ossetp, NULL);
}
#endif
int
Perl_magic_getsig(pTHX_ SV *sv, MAGIC *mg)
{
    /* Are we fetching a signal entry? */
    int i = (I16)mg->mg_private;

    PERL_ARGS_ASSERT_MAGIC_GETSIG;

    if (!i) {
        STRLEN siglen;
        const char * sig = MgPV_const(mg, siglen);
        mg->mg_private = i = whichsig_pvn(sig, siglen);
    }

    if (i > 0) {
    	if(PL_psig_ptr[i])
    	    sv_setsv(sv,PL_psig_ptr[i]);
    	else {
	    Sighandler_t sigstate = rsignal_state(i);
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
	    if (PL_sig_handlers_initted && PL_sig_ignoring[i])
		sigstate = SIG_IGN;
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
	    if (PL_sig_handlers_initted && PL_sig_defaulting[i])
		sigstate = SIG_DFL;
#endif
    	    /* cache state so we don't fetch it again */
    	    if(sigstate == (Sighandler_t) SIG_IGN)
    	    	sv_setpvs(sv,"IGNORE");
    	    else
    	    	sv_setsv(sv,&PL_sv_undef);
	    PL_psig_ptr[i] = SvREFCNT_inc_simple_NN(sv);
    	    SvTEMP_off(sv);
    	}
    }
    return 0;
}
int
Perl_magic_clearsig(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARSIG;

    magic_setsig(NULL, mg);
    return sv_unmagic(sv, mg->mg_type);
}

Signal_t
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
Perl_csighandler(int sig, siginfo_t *sip PERL_UNUSED_DECL, void *uap PERL_UNUSED_DECL)
#else
Perl_csighandler(int sig)
#endif
{
#ifdef PERL_GET_SIG_CONTEXT
    dTHXa(PERL_GET_SIG_CONTEXT);
#else
    dTHX;
#endif
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#if defined(__cplusplus) && defined(__GNUC__)
    /* g++ doesn't support PERL_UNUSED_DECL, so the sip and uap
     * parameters would be warned about. */
    PERL_UNUSED_ARG(sip);
    PERL_UNUSED_ARG(uap);
#endif
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
    (void) rsignal(sig, PL_csighandlerp);
    if (PL_sig_ignoring[sig]) return;
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
    if (PL_sig_defaulting[sig])
#ifdef KILL_BY_SIGPRC
            exit((Perl_sig_to_vmscondition(sig)&STS$M_COND_ID)|STS$K_SEVERE|STS$M_INHIB_MSG);
#else
            exit(1);
#endif
#endif
    if (
#ifdef SIGILL
	   sig == SIGILL ||
#endif
#ifdef SIGBUS
	   sig == SIGBUS ||
#endif
#ifdef SIGSEGV
	   sig == SIGSEGV ||
#endif
	   (PL_signals & PERL_SIGNALS_UNSAFE_FLAG))
	/* Call the perl level handler now--
	 * with risk we may be in malloc() or being destructed etc. */
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
	(*PL_sighandlerp)(sig, NULL, NULL);
#else
	(*PL_sighandlerp)(sig);
#endif
    else {
	if (!PL_psig_pend) return;
	/* Set a flag to say this signal is pending, that is awaiting delivery after
	 * the current Perl opcode completes */
	PL_psig_pend[sig]++;

#ifndef SIG_PENDING_DIE_COUNT
#  define SIG_PENDING_DIE_COUNT 120
#endif
	/* Add one to say _a_ signal is pending */
	if (++PL_sig_pending >= SIG_PENDING_DIE_COUNT)
	    Perl_croak(aTHX_ "Maximal count of pending signals (%lu) exceeded",
		       (unsigned long)SIG_PENDING_DIE_COUNT);
    }
}

#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS) || defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
void
Perl_csighandler_init(void)
{
    int sig;
    if (PL_sig_handlers_initted) return;

    for (sig = 1; sig < SIG_SIZE; sig++) {
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
        dTHX;
        PL_sig_defaulting[sig] = 1;
        (void) rsignal(sig, PL_csighandlerp);
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
        PL_sig_ignoring[sig] = 0;
#endif
    }
    PL_sig_handlers_initted = 1;
}
#endif

#if defined HAS_SIGPROCMASK
static void
unblock_sigmask(pTHX_ void* newset)
{
    PERL_UNUSED_CONTEXT;
    sigprocmask(SIG_UNBLOCK, (sigset_t*)newset, NULL);
}
#endif

void
Perl_despatch_signals(pTHX)
{
    int sig;
    PL_sig_pending = 0;
    for (sig = 1; sig < SIG_SIZE; sig++) {
	if (PL_psig_pend[sig]) {
	    dSAVE_ERRNO;
#ifdef HAS_SIGPROCMASK
	    /* From sigaction(2) (FreeBSD man page):
	     * | Signal routines normally execute with the signal that
	     * | caused their invocation blocked, but other signals may
	     * | yet occur.
	     * Emulation of this behavior (from within Perl) is enabled
	     * using sigprocmask
	     */
	    int was_blocked;
	    sigset_t newset, oldset;

	    sigemptyset(&newset);
	    sigaddset(&newset, sig);
	    sigprocmask(SIG_BLOCK, &newset, &oldset);
	    was_blocked = sigismember(&oldset, sig);
	    if (!was_blocked) {
		SV* save_sv = newSVpvn((char *)(&newset), sizeof(sigset_t));
		ENTER;
		SAVEFREESV(save_sv);
		SAVEDESTRUCTOR_X(unblock_sigmask, SvPV_nolen(save_sv));
	    }
#endif
 	    PL_psig_pend[sig] = 0;
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
	    (*PL_sighandlerp)(sig, NULL, NULL);
#else
	    (*PL_sighandlerp)(sig);
#endif
#ifdef HAS_SIGPROCMASK
	    if (!was_blocked)
		LEAVE;
#endif
	    RESTORE_ERRNO;
	}
    }
}

/* sv of NULL signifies that we're acting as magic_clearsig.  */
int
Perl_magic_setsig(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    I32 i;
    SV** svp = NULL;
    /* Need to be careful with SvREFCNT_dec(), because that can have side
     * effects (due to closures). We must make sure that the new disposition
     * is in place before it is called.
     */
    SV* to_dec = NULL;
    STRLEN len;
#ifdef HAS_SIGPROCMASK
    sigset_t set, save;
    SV* save_sv;
#endif
    const char *s = MgPV_const(mg,len);

    PERL_ARGS_ASSERT_MAGIC_SETSIG;

    if (*s == '_') {
        if (memEQs(s, len, "__DIE__"))
	    svp = &PL_diehook;
	else if (memEQs(s, len, "__WARN__")
		 && (sv ? 1 : PL_warnhook != PERL_WARNHOOK_FATAL)) {
	    /* Merge the existing behaviours, which are as follows:
	       magic_setsig, we always set svp to &PL_warnhook
	       (hence we always change the warnings handler)
	       For magic_clearsig, we don't change the warnings handler if it's
	       set to the &PL_warnhook.  */
	    svp = &PL_warnhook;
        } else if (sv) {
            SV *tmp = sv_newmortal();
            Perl_croak(aTHX_ "No such hook: %s",
                                pv_pretty(tmp, s, len, 0, NULL, NULL, 0));
        }
	i = 0;
	if (svp && *svp) {
	    if (*svp != PERL_WARNHOOK_FATAL)
		to_dec = *svp;
	    *svp = NULL;
	}
    }
    else {
	i = (I16)mg->mg_private;
	if (!i) {
	    i = whichsig_pvn(s, len);   /* ...no, a brick */
	    mg->mg_private = (U16)i;
	}
	if (i <= 0) {
	    if (sv) {
                SV *tmp = sv_newmortal();
		Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL), "No such signal: SIG%s",
                                            pv_pretty(tmp, s, len, 0, NULL, NULL, 0));
            }
	    return 0;
	}
#ifdef HAS_SIGPROCMASK
	/* Avoid having the signal arrive at a bad time, if possible. */
	sigemptyset(&set);
	sigaddset(&set,i);
	sigprocmask(SIG_BLOCK, &set, &save);
	ENTER;
	save_sv = newSVpvn((char *)(&save), sizeof(sigset_t));
	SAVEFREESV(save_sv);
	SAVEDESTRUCTOR_X(restore_sigmask, save_sv);
#endif
	PERL_ASYNC_CHECK();
#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS) || defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
	if (!PL_sig_handlers_initted) Perl_csighandler_init();
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
	PL_sig_ignoring[i] = 0;
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
	PL_sig_defaulting[i] = 0;
#endif
	to_dec = PL_psig_ptr[i];
	if (sv) {
	    PL_psig_ptr[i] = SvREFCNT_inc_simple_NN(sv);
	    SvTEMP_off(sv); /* Make sure it doesn't go away on us */

	    /* Signals don't change name during the program's execution, so once
	       they're cached in the appropriate slot of PL_psig_name, they can
	       stay there.

	       Ideally we'd find some way of making SVs at (C) compile time, or
	       at least, doing most of the work.  */
	    if (!PL_psig_name[i]) {
		PL_psig_name[i] = newSVpvn(s, len);
		SvREADONLY_on(PL_psig_name[i]);
	    }
	} else {
	    SvREFCNT_dec(PL_psig_name[i]);
	    PL_psig_name[i] = NULL;
	    PL_psig_ptr[i] = NULL;
	}
    }
    if (sv && (isGV_with_GP(sv) || SvROK(sv))) {
	if (i) {
	    (void)rsignal(i, PL_csighandlerp);
	}
	else
	    *svp = SvREFCNT_inc_simple_NN(sv);
    } else {
	if (sv && SvOK(sv)) {
	    s = SvPV_force(sv, len);
	} else {
	    sv = NULL;
	}
	if (sv && memEQs(s, len,"IGNORE")) {
	    if (i) {
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
		PL_sig_ignoring[i] = 1;
		(void)rsignal(i, PL_csighandlerp);
#else
		(void)rsignal(i, (Sighandler_t) SIG_IGN);
#endif
	    }
	}
	else if (!sv || memEQs(s, len,"DEFAULT") || !len) {
	    if (i) {
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
		PL_sig_defaulting[i] = 1;
		(void)rsignal(i, PL_csighandlerp);
#else
		(void)rsignal(i, (Sighandler_t) SIG_DFL);
#endif
	    }
	}
	else {
	    /*
	     * We should warn if HINT_STRICT_REFS, but without
	     * access to a known hint bit in a known OP, we can't
	     * tell whether HINT_STRICT_REFS is in force or not.
	     */
	    if (!strchr(s,':') && !strchr(s,'\''))
		Perl_sv_insert_flags(aTHX_ sv, 0, 0, STR_WITH_LEN("main::"),
				     SV_GMAGIC);
	    if (i)
		(void)rsignal(i, PL_csighandlerp);
	    else
		*svp = SvREFCNT_inc_simple_NN(sv);
	}
    }

#ifdef HAS_SIGPROCMASK
    if(i)
	LEAVE;
#endif
    SvREFCNT_dec(to_dec);
    return 0;
}
#endif /* !PERL_MICRO */

int
Perl_magic_setisa(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETISA;
    PERL_UNUSED_ARG(sv);

    /* Skip _isaelem because _isa will handle it shortly */
    if (PL_delaymagic & DM_ARRAY_ISA && mg->mg_type == PERL_MAGIC_isaelem)
	return 0;

    return magic_clearisa(NULL, mg);
}

/* sv of NULL signifies that we're acting as magic_setisa.  */
int
Perl_magic_clearisa(pTHX_ SV *sv, MAGIC *mg)
{
    HV* stash;
    PERL_ARGS_ASSERT_MAGIC_CLEARISA;

    /* Bail out if destruction is going on */
    if(PL_phase == PERL_PHASE_DESTRUCT) return 0;

    if (sv)
	av_clear(MUTABLE_AV(sv));

    if (SvTYPE(mg->mg_obj) != SVt_PVGV && SvSMAGICAL(mg->mg_obj))
	/* This occurs with setisa_elem magic, which calls this
	   same function. */
	mg = mg_find(mg->mg_obj, PERL_MAGIC_isa);

    assert(mg);
    if (SvTYPE(mg->mg_obj) == SVt_PVAV) { /* multiple stashes */
	SV **svp = AvARRAY((AV *)mg->mg_obj);
	I32 items = AvFILLp((AV *)mg->mg_obj) + 1;
	while (items--) {
	    stash = GvSTASH((GV *)*svp++);
	    if (stash && HvENAME(stash)) mro_isa_changed_in(stash);
	}

	return 0;
    }

    stash = GvSTASH(
        (const GV *)mg->mg_obj
    );

    /* The stash may have been detached from the symbol table, so check its
       name before doing anything. */
    if (stash && HvENAME_get(stash))
	mro_isa_changed_in(stash);

    return 0;
}

int
Perl_magic_getnkeys(pTHX_ SV *sv, MAGIC *mg)
{
    HV * const hv = MUTABLE_HV(LvTARG(sv));
    I32 i = 0;

    PERL_ARGS_ASSERT_MAGIC_GETNKEYS;
    PERL_UNUSED_ARG(mg);

    if (hv) {
         (void) hv_iterinit(hv);
         if (! SvTIED_mg((const SV *)hv, PERL_MAGIC_tied))
	     i = HvUSEDKEYS(hv);
         else {
	     while (hv_iternext(hv))
	         i++;
         }
    }

    sv_setiv(sv, (IV)i);
    return 0;
}

int
Perl_magic_setnkeys(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETNKEYS;
    PERL_UNUSED_ARG(mg);
    if (LvTARG(sv)) {
	hv_ksplit(MUTABLE_HV(LvTARG(sv)), SvIV(sv));
    }
    return 0;
}

/*
=for apidoc magic_methcall

Invoke a magic method (like FETCH).

C<sv> and C<mg> are the tied thingy and the tie magic.

C<meth> is the name of the method to call.

C<argc> is the number of args (in addition to $self) to pass to the method.

The C<flags> can be:

    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef

The arguments themselves are any values following the C<flags> argument.

Returns the SV (if any) returned by the method, or C<NULL> on failure.


=cut
*/

SV*
Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags,
		    U32 argc, ...)
{
    dSP;
    SV* ret = NULL;

    PERL_ARGS_ASSERT_MAGIC_METHCALL;

    ENTER;

    if (flags & G_WRITING_TO_STDERR) {
	SAVETMPS;

	save_re_context();
	SAVESPTR(PL_stderrgv);
	PL_stderrgv = NULL;
    }

    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);

    /* EXTEND() expects a signed argc; don't wrap when casting */
    assert(argc <= I32_MAX);
    EXTEND(SP, (I32)argc+1);
    PUSHs(SvTIED_obj(sv, mg));
    if (flags & G_UNDEF_FILL) {
	while (argc--) {
	    PUSHs(&PL_sv_undef);
	}
    } else if (argc > 0) {
	va_list args;
	va_start(args, argc);

	do {
	    SV *const sv = va_arg(args, SV *);
	    PUSHs(sv);
	} while (--argc);

	va_end(args);
    }
    PUTBACK;
    if (flags & G_DISCARD) {
	call_sv(meth, G_SCALAR|G_DISCARD|G_METHOD_NAMED);
    }
    else {
	if (call_sv(meth, G_SCALAR|G_METHOD_NAMED))
	    ret = *PL_stack_sp--;
    }
    POPSTACK;
    if (flags & G_WRITING_TO_STDERR)
	FREETMPS;
    LEAVE;
    return ret;
}

/* wrapper for magic_methcall that creates the first arg */

STATIC SV*
S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags,
    int n, SV *val)
{
    SV* arg1 = NULL;

    PERL_ARGS_ASSERT_MAGIC_METHCALL1;

    if (mg->mg_ptr) {
	if (mg->mg_len >= 0) {
	    arg1 = newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP);
	}
	else if (mg->mg_len == HEf_SVKEY)
	    arg1 = MUTABLE_SV(mg->mg_ptr);
    }
    else if (mg->mg_type == PERL_MAGIC_tiedelem) {
	arg1 = newSViv((IV)(mg->mg_len));
	sv_2mortal(arg1);
    }
    if (!arg1) {
	return Perl_magic_methcall(aTHX_ sv, mg, meth, flags, n - 1, val);
    }
    return Perl_magic_methcall(aTHX_ sv, mg, meth, flags, n, arg1, val);
}

STATIC int
S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth)
{
    SV* ret;

    PERL_ARGS_ASSERT_MAGIC_METHPACK;

    ret = magic_methcall1(sv, mg, meth, 0, 1, NULL);
    if (ret)
	sv_setsv(sv, ret);
    return 0;
}

int
Perl_magic_getpack(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_GETPACK;

    if (mg->mg_type == PERL_MAGIC_tiedelem)
	mg->mg_flags |= MGf_GSKIP;
    magic_methpack(sv,mg,SV_CONST(FETCH));
    return 0;
}

int
Perl_magic_setpack(pTHX_ SV *sv, MAGIC *mg)
{
    MAGIC *tmg;
    SV    *val;

    PERL_ARGS_ASSERT_MAGIC_SETPACK;

    /* in the code C<$tied{foo} = $val>, the "thing" that gets passed to
     * STORE() is not $val, but rather a PVLV (the sv in this call), whose
     * public flags indicate its value based on copying from $val. Doing
     * mg_set() on the PVLV temporarily does SvMAGICAL_off(), then calls us.
     * So STORE()'s $_[2] arg is a temporarily disarmed PVLV. This goes
     * wrong if $val happened to be tainted, as sv hasn't got magic
     * enabled, even though taint magic is in the chain. In which case,
     * fake up a temporary tainted value (this is easier than temporarily
     * re-enabling magic on sv). */

    if (TAINTING_get && (tmg = mg_find(sv, PERL_MAGIC_taint))
	&& (tmg->mg_len & 1))
    {
	val = sv_mortalcopy(sv);
	SvTAINTED_on(val);
    }
    else
	val = sv;

    magic_methcall1(sv, mg, SV_CONST(STORE), G_DISCARD, 2, val);
    return 0;
}

int
Perl_magic_clearpack(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARPACK;

    if (mg->mg_type == PERL_MAGIC_tiedscalar) return 0;
    return magic_methpack(sv,mg,SV_CONST(DELETE));
}


U32
Perl_magic_sizepack(pTHX_ SV *sv, MAGIC *mg)
{
    I32 retval = 0;
    SV* retsv;

    PERL_ARGS_ASSERT_MAGIC_SIZEPACK;

    retsv = magic_methcall1(sv, mg, SV_CONST(FETCHSIZE), 0, 1, NULL);
    if (retsv) {
	retval = SvIV(retsv)-1;
	if (retval < -1)
	    Perl_croak(aTHX_ "FETCHSIZE returned a negative value");
    }
    return (U32) retval;
}

int
Perl_magic_wipepack(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_WIPEPACK;

    Perl_magic_methcall(aTHX_ sv, mg, SV_CONST(CLEAR), G_DISCARD, 0);
    return 0;
}

int
Perl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key)
{
    SV* ret;

    PERL_ARGS_ASSERT_MAGIC_NEXTPACK;

    ret = SvOK(key) ? Perl_magic_methcall(aTHX_ sv, mg, SV_CONST(NEXTKEY), 0, 1, key)
	: Perl_magic_methcall(aTHX_ sv, mg, SV_CONST(FIRSTKEY), 0, 0);
    if (ret)
	sv_setsv(key,ret);
    return 0;
}

int
Perl_magic_existspack(pTHX_ SV *sv, const MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_EXISTSPACK;

    return magic_methpack(sv,mg,SV_CONST(EXISTS));
}

SV *
Perl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg)
{
    SV *retval;
    SV * const tied = SvTIED_obj(MUTABLE_SV(hv), mg);
    HV * const pkg = SvSTASH((const SV *)SvRV(tied));
   
    PERL_ARGS_ASSERT_MAGIC_SCALARPACK;

    if (!gv_fetchmethod_autoload(pkg, "SCALAR", FALSE)) {
        SV *key;
        if (HvEITER_get(hv))
            /* we are in an iteration so the hash cannot be empty */
            return &PL_sv_yes;
        /* no xhv_eiter so now use FIRSTKEY */
        key = sv_newmortal();
        magic_nextpack(MUTABLE_SV(hv), mg, key);
        HvEITER_set(hv, NULL);     /* need to reset iterator */
        return SvOK(key) ? &PL_sv_yes : &PL_sv_no;
    }
   
    /* there is a SCALAR method that we can call */
    retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(hv), mg, SV_CONST(SCALAR), 0, 0);
    if (!retval)
	retval = &PL_sv_undef;
    return retval;
}

int
Perl_magic_setdbline(pTHX_ SV *sv, MAGIC *mg)
{
    SV **svp;

    PERL_ARGS_ASSERT_MAGIC_SETDBLINE;

    /* The magic ptr/len for the debugger's hash should always be an SV.  */
    if (UNLIKELY(mg->mg_len != HEf_SVKEY)) {
        Perl_croak(aTHX_ "panic: magic_setdbline len=%"IVdf", ptr='%s'",
                   (IV)mg->mg_len, mg->mg_ptr);
    }

    /* Use sv_2iv instead of SvIV() as the former generates smaller code, and
       setting/clearing debugger breakpoints is not a hot path.  */
    svp = av_fetch(MUTABLE_AV(mg->mg_obj),
		   sv_2iv(MUTABLE_SV((mg)->mg_ptr)), FALSE);

    if (svp && SvIOKp(*svp)) {
	OP * const o = INT2PTR(OP*,SvIVX(*svp));
	if (o) {
#ifdef PERL_DEBUG_READONLY_OPS
	    Slab_to_rw(OpSLAB(o));
#endif
	    /* set or clear breakpoint in the relevant control op */
	    if (SvTRUE(sv))
		o->op_flags |= OPf_SPECIAL;
	    else
		o->op_flags &= ~OPf_SPECIAL;
#ifdef PERL_DEBUG_READONLY_OPS
	    Slab_to_ro(OpSLAB(o));
#endif
	}
    }
    return 0;
}

int
Perl_magic_getarylen(pTHX_ SV *sv, const MAGIC *mg)
{
    AV * const obj = MUTABLE_AV(mg->mg_obj);

    PERL_ARGS_ASSERT_MAGIC_GETARYLEN;

    if (obj) {
	sv_setiv(sv, AvFILL(obj));
    } else {
	sv_setsv(sv, NULL);
    }
    return 0;
}

int
Perl_magic_setarylen(pTHX_ SV *sv, MAGIC *mg)
{
    AV * const obj = MUTABLE_AV(mg->mg_obj);

    PERL_ARGS_ASSERT_MAGIC_SETARYLEN;

    if (obj) {
	av_fill(obj, SvIV(sv));
    } else {
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
		       "Attempt to set length of freed array");
    }
    return 0;
}

int
Perl_magic_cleararylen_p(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARARYLEN_P;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_CONTEXT;

    /* Reset the iterator when the array is cleared */
#if IVSIZE == I32SIZE
    *((IV *) &(mg->mg_len)) = 0;
#else
    if (mg->mg_ptr)
        *((IV *) mg->mg_ptr) = 0;
#endif

    return 0;
}

int
Perl_magic_freearylen_p(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_FREEARYLEN_P;
    PERL_UNUSED_ARG(sv);

    /* during global destruction, mg_obj may already have been freed */
    if (PL_in_clean_all)
	return 0;

    mg = mg_find (mg->mg_obj, PERL_MAGIC_arylen);

    if (mg) {
	/* arylen scalar holds a pointer back to the array, but doesn't own a
	   reference. Hence the we (the array) are about to go away with it
	   still pointing at us. Clear its pointer, else it would be pointing
	   at free memory. See the comment in sv_magic about reference loops,
	   and why it can't own a reference to us.  */
	mg->mg_obj = 0;
    }
    return 0;
}

int
Perl_magic_getpos(pTHX_ SV *sv, MAGIC *mg)
{
    SV* const lsv = LvTARG(sv);
    MAGIC * const found = mg_find_mglob(lsv);

    PERL_ARGS_ASSERT_MAGIC_GETPOS;
    PERL_UNUSED_ARG(mg);

    if (found && found->mg_len != -1) {
	    STRLEN i = found->mg_len;
	    if (found->mg_flags & MGf_BYTES && DO_UTF8(lsv))
		i = sv_pos_b2u_flags(lsv, i, SV_GMAGIC|SV_CONST_RETURN);
	    sv_setuv(sv, i);
	    return 0;
    }
    sv_setsv(sv,NULL);
    return 0;
}

int
Perl_magic_setpos(pTHX_ SV *sv, MAGIC *mg)
{
    SV* const lsv = LvTARG(sv);
    SSize_t pos;
    STRLEN len;
    STRLEN ulen = 0;
    MAGIC* found;
    const char *s;

    PERL_ARGS_ASSERT_MAGIC_SETPOS;
    PERL_UNUSED_ARG(mg);

    found = mg_find_mglob(lsv);
    if (!found) {
	if (!SvOK(sv))
	    return 0;
	found = sv_magicext_mglob(lsv);
    }
    else if (!SvOK(sv)) {
	found->mg_len = -1;
	return 0;
    }
    s = SvPV_const(lsv, len);

    pos = SvIV(sv);

    if (DO_UTF8(lsv)) {
	ulen = sv_or_pv_len_utf8(lsv, s, len);
	if (ulen)
	    len = ulen;
    }

    if (pos < 0) {
	pos += len;
	if (pos < 0)
	    pos = 0;
    }
    else if (pos > (SSize_t)len)
	pos = len;

    found->mg_len = pos;
    found->mg_flags &= ~(MGf_MINMATCH|MGf_BYTES);

    return 0;
}

int
Perl_magic_getsubstr(pTHX_ SV *sv, MAGIC *mg)
{
    STRLEN len;
    SV * const lsv = LvTARG(sv);
    const char * const tmps = SvPV_const(lsv,len);
    STRLEN offs = LvTARGOFF(sv);
    STRLEN rem = LvTARGLEN(sv);
    const bool negoff = LvFLAGS(sv) & 1;
    const bool negrem = LvFLAGS(sv) & 2;

    PERL_ARGS_ASSERT_MAGIC_GETSUBSTR;
    PERL_UNUSED_ARG(mg);

    if (!translate_substr_offsets(
	    SvUTF8(lsv) ? sv_or_pv_len_utf8(lsv, tmps, len) : len,
	    negoff ? -(IV)offs : (IV)offs, !negoff,
	    negrem ? -(IV)rem  : (IV)rem,  !negrem, &offs, &rem
    )) {
	Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR), "substr outside of string");
	sv_setsv_nomg(sv, &PL_sv_undef);
	return 0;
    }

    if (SvUTF8(lsv))
	offs = sv_or_pv_pos_u2b(lsv, tmps, offs, &rem);
    sv_setpvn(sv, tmps + offs, rem);
    if (SvUTF8(lsv))
        SvUTF8_on(sv);
    return 0;
}

int
Perl_magic_setsubstr(pTHX_ SV *sv, MAGIC *mg)
{
    STRLEN len, lsv_len, oldtarglen, newtarglen;
    const char * const tmps = SvPV_const(sv, len);
    SV * const lsv = LvTARG(sv);
    STRLEN lvoff = LvTARGOFF(sv);
    STRLEN lvlen = LvTARGLEN(sv);
    const bool negoff = LvFLAGS(sv) & 1;
    const bool neglen = LvFLAGS(sv) & 2;

    PERL_ARGS_ASSERT_MAGIC_SETSUBSTR;
    PERL_UNUSED_ARG(mg);

    SvGETMAGIC(lsv);
    if (SvROK(lsv))
	Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
			    "Attempt to use reference as lvalue in substr"
	);
    SvPV_force_nomg(lsv,lsv_len);
    if (SvUTF8(lsv)) lsv_len = sv_len_utf8_nomg(lsv);
    if (!translate_substr_offsets(
	    lsv_len,
	    negoff ? -(IV)lvoff : (IV)lvoff, !negoff,
	    neglen ? -(IV)lvlen : (IV)lvlen, !neglen, &lvoff, &lvlen
    ))
	Perl_croak(aTHX_ "substr outside of string");
    oldtarglen = lvlen;
    if (DO_UTF8(sv)) {
	sv_utf8_upgrade_nomg(lsv);
	lvoff = sv_pos_u2b_flags(lsv, lvoff, &lvlen, SV_CONST_RETURN);
	sv_insert_flags(lsv, lvoff, lvlen, tmps, len, 0);
	newtarglen = sv_or_pv_len_utf8(sv, tmps, len);
	SvUTF8_on(lsv);
    }
    else if (SvUTF8(lsv)) {
	const char *utf8;
	lvoff = sv_pos_u2b_flags(lsv, lvoff, &lvlen, SV_CONST_RETURN);
	newtarglen = len;
	utf8 = (char*)bytes_to_utf8((U8*)tmps, &len);
	sv_insert_flags(lsv, lvoff, lvlen, utf8, len, 0);
	Safefree(utf8);
    }
    else {
	sv_insert_flags(lsv, lvoff, lvlen, tmps, len, 0);
	newtarglen = len;
    }
    if (!neglen) LvTARGLEN(sv) = newtarglen;
    if (negoff)  LvTARGOFF(sv) += newtarglen - oldtarglen;

    return 0;
}

int
Perl_magic_gettaint(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_GETTAINT;
    PERL_UNUSED_ARG(sv);
#ifdef NO_TAINT_SUPPORT
    PERL_UNUSED_ARG(mg);
#endif

    TAINT_IF((PL_localizing != 1) && (mg->mg_len & 1) && IN_PERL_RUNTIME);
    return 0;
}

int
Perl_magic_settaint(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETTAINT;
    PERL_UNUSED_ARG(sv);

    /* update taint status */
    if (TAINT_get)
	mg->mg_len |= 1;
    else
	mg->mg_len &= ~1;
    return 0;
}

int
Perl_magic_getvec(pTHX_ SV *sv, MAGIC *mg)
{
    SV * const lsv = LvTARG(sv);

    PERL_ARGS_ASSERT_MAGIC_GETVEC;
    PERL_UNUSED_ARG(mg);

    sv_setuv(sv, do_vecget(lsv, LvTARGOFF(sv), LvTARGLEN(sv)));

    return 0;
}

int
Perl_magic_setvec(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETVEC;
    PERL_UNUSED_ARG(mg);
    do_vecset(sv);	/* XXX slurp this routine */
    return 0;
}

SV *
Perl_defelem_target(pTHX_ SV *sv, MAGIC *mg)
{
    SV *targ = NULL;
    PERL_ARGS_ASSERT_DEFELEM_TARGET;
    if (!mg) mg = mg_find(sv, PERL_MAGIC_defelem);
    assert(mg);
    if (LvTARGLEN(sv)) {
	if (mg->mg_obj) {
	    SV * const ahv = LvTARG(sv);
	    HE * const he = hv_fetch_ent(MUTABLE_HV(ahv), mg->mg_obj, FALSE, 0);
            if (he)
                targ = HeVAL(he);
	}
	else if (LvSTARGOFF(sv) >= 0) {
	    AV *const av = MUTABLE_AV(LvTARG(sv));
	    if (LvSTARGOFF(sv) <= AvFILL(av))
	    {
	      if (SvRMAGICAL(av)) {
		SV * const * const svp = av_fetch(av, LvSTARGOFF(sv), 0);
		targ = svp ? *svp : NULL;
	      }
	      else
		targ = AvARRAY(av)[LvSTARGOFF(sv)];
	    }
	}
	if (targ && (targ != &PL_sv_undef)) {
	    /* somebody else defined it for us */
	    SvREFCNT_dec(LvTARG(sv));
	    LvTARG(sv) = SvREFCNT_inc_simple_NN(targ);
	    LvTARGLEN(sv) = 0;
	    SvREFCNT_dec(mg->mg_obj);
	    mg->mg_obj = NULL;
	    mg->mg_flags &= ~MGf_REFCOUNTED;
	}
	return targ;
    }
    else
	return LvTARG(sv);
}

int
Perl_magic_getdefelem(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_GETDEFELEM;

    sv_setsv(sv, defelem_target(sv, mg));
    return 0;
}

int
Perl_magic_setdefelem(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETDEFELEM;
    PERL_UNUSED_ARG(mg);
    if (LvTARGLEN(sv))
	vivify_defelem(sv);
    if (LvTARG(sv)) {
	sv_setsv(LvTARG(sv), sv);
	SvSETMAGIC(LvTARG(sv));
    }
    return 0;
}

void
Perl_vivify_defelem(pTHX_ SV *sv)
{
    MAGIC *mg;
    SV *value = NULL;

    PERL_ARGS_ASSERT_VIVIFY_DEFELEM;

    if (!LvTARGLEN(sv) || !(mg = mg_find(sv, PERL_MAGIC_defelem)))
	return;
    if (mg->mg_obj) {
	SV * const ahv = LvTARG(sv);
	HE * const he = hv_fetch_ent(MUTABLE_HV(ahv), mg->mg_obj, TRUE, 0);
        if (he)
            value = HeVAL(he);
	if (!value || value == &PL_sv_undef)
	    Perl_croak(aTHX_ PL_no_helem_sv, SVfARG(mg->mg_obj));
    }
    else if (LvSTARGOFF(sv) < 0)
	Perl_croak(aTHX_ PL_no_aelem, LvSTARGOFF(sv));
    else {
	AV *const av = MUTABLE_AV(LvTARG(sv));
	if ((I32)LvTARGLEN(sv) < 0 && LvSTARGOFF(sv) > AvFILL(av))
	    LvTARG(sv) = NULL;	/* array can't be extended */
	else {
	    SV* const * const svp = av_fetch(av, LvSTARGOFF(sv), TRUE);
	    if (!svp || !(value = *svp))
		Perl_croak(aTHX_ PL_no_aelem, LvSTARGOFF(sv));
	}
    }
    SvREFCNT_inc_simple_void(value);
    SvREFCNT_dec(LvTARG(sv));
    LvTARG(sv) = value;
    LvTARGLEN(sv) = 0;
    SvREFCNT_dec(mg->mg_obj);
    mg->mg_obj = NULL;
    mg->mg_flags &= ~MGf_REFCOUNTED;
}

int
Perl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS;
    Perl_sv_kill_backrefs(aTHX_ sv, MUTABLE_AV(mg->mg_obj));
    return 0;
}

int
Perl_magic_setmglob(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETMGLOB;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    mg->mg_len = -1;
    return 0;
}

int
Perl_magic_setuvar(pTHX_ SV *sv, MAGIC *mg)
{
    const struct ufuncs * const uf = (struct ufuncs *)mg->mg_ptr;

    PERL_ARGS_ASSERT_MAGIC_SETUVAR;

    if (uf && uf->uf_set)
	(*uf->uf_set)(aTHX_ uf->uf_index, sv);
    return 0;
}

int
Perl_magic_setregexp(pTHX_ SV *sv, MAGIC *mg)
{
    const char type = mg->mg_type;

    PERL_ARGS_ASSERT_MAGIC_SETREGEXP;

    if (type == PERL_MAGIC_qr) {
    } else if (type == PERL_MAGIC_bm) {
	SvTAIL_off(sv);
	SvVALID_off(sv);
    } else {
	assert(type == PERL_MAGIC_fm);
    }
    return sv_unmagic(sv, type);
}

#ifdef USE_LOCALE_COLLATE
int
Perl_magic_setcollxfrm(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETCOLLXFRM;

    /*
     * RenE<eacute> Descartes said "I think not."
     * and vanished with a faint plop.
     */
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    if (mg->mg_ptr) {
	Safefree(mg->mg_ptr);
	mg->mg_ptr = NULL;
	mg->mg_len = -1;
    }
    return 0;
}
#endif /* USE_LOCALE_COLLATE */

/* Just clear the UTF-8 cache data. */
int
Perl_magic_setutf8(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETUTF8;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(sv);
    Safefree(mg->mg_ptr);	/* The mg_ptr holds the pos cache. */
    mg->mg_ptr = NULL;
    mg->mg_len = -1;		/* The mg_len holds the len cache. */
    return 0;
}

int
Perl_magic_setlvref(pTHX_ SV *sv, MAGIC *mg)
{
    const char *bad = NULL;
    PERL_ARGS_ASSERT_MAGIC_SETLVREF;
    if (!SvROK(sv)) Perl_croak(aTHX_ "Assigned value is not a reference");
    switch (mg->mg_private & OPpLVREF_TYPE) {
    case OPpLVREF_SV:
	if (SvTYPE(SvRV(sv)) > SVt_PVLV)
	    bad = " SCALAR";
	break;
    case OPpLVREF_AV:
	if (SvTYPE(SvRV(sv)) != SVt_PVAV)
	    bad = "n ARRAY";
	break;
    case OPpLVREF_HV:
	if (SvTYPE(SvRV(sv)) != SVt_PVHV)
	    bad = " HASH";
	break;
    case OPpLVREF_CV:
	if (SvTYPE(SvRV(sv)) != SVt_PVCV)
	    bad = " CODE";
    }
    if (bad)
	/* diag_listed_as: Assigned value is not %s reference */
	Perl_croak(aTHX_ "Assigned value is not a%s reference", bad);
    switch (mg->mg_obj ? SvTYPE(mg->mg_obj) : 0) {
    case 0:
    {
	SV * const old = PAD_SV(mg->mg_len);
	PAD_SETSV(mg->mg_len, SvREFCNT_inc_NN(SvRV(sv)));
	SvREFCNT_dec(old);
	break;
    }
    case SVt_PVGV:
	gv_setref(mg->mg_obj, sv);
	SvSETMAGIC(mg->mg_obj);
	break;
    case SVt_PVAV:
	av_store((AV *)mg->mg_obj, SvIV((SV *)mg->mg_ptr),
		 SvREFCNT_inc_simple_NN(SvRV(sv)));
	break;
    case SVt_PVHV:
	(void)hv_store_ent((HV *)mg->mg_obj, (SV *)mg->mg_ptr,
                           SvREFCNT_inc_simple_NN(SvRV(sv)), 0);
    }
    if (mg->mg_flags & MGf_PERSIST)
	NOOP; /* This sv is in use as an iterator var and will be reused,
		 so we must leave the magic.  */
    else
	/* This sv could be returned by the assignment op, so clear the
	   magic, as lvrefs are an implementation detail that must not be
	   leaked to the user.  */
	sv_unmagic(sv, PERL_MAGIC_lvref);
    return 0;
}

static void
S_set_dollarzero(pTHX_ SV *sv)
    PERL_TSA_REQUIRES(PL_dollarzero_mutex)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    const char *s;
    STRLEN len;
#ifdef HAS_SETPROCTITLE
    /* The BSDs don't show the argv[] in ps(1) output, they
     * show a string from the process struct and provide
     * the setproctitle() routine to manipulate that. */
    if (PL_origalen != 1) {
        s = SvPV_const(sv, len);
#   if __FreeBSD_version > 410001
        /* The leading "-" removes the "perl: " prefix,
         * but not the "(perl) suffix from the ps(1)
         * output, because that's what ps(1) shows if the
         * argv[] is modified. */
        setproctitle("-%s", s);
#   else	/* old FreeBSDs, NetBSD, OpenBSD, anyBSD */
        /* This doesn't really work if you assume that
         * $0 = 'foobar'; will wipe out 'perl' from the $0
         * because in ps(1) output the result will be like
         * sprintf("perl: %s (perl)", s)
         * I guess this is a security feature:
         * one (a user process) cannot get rid of the original name.
         * --jhi */
        setproctitle("%s", s);
#   endif
    }
#elif defined(__hpux) && defined(PSTAT_SETCMD)
    if (PL_origalen != 1) {
        union pstun un;
        s = SvPV_const(sv, len);
        un.pst_command = (char *)s;
        pstat(PSTAT_SETCMD, un, len, 0, 0);
    }
#else
    if (PL_origalen > 1) {
        I32 i;
        /* PL_origalen is set in perl_parse(). */
        s = SvPV_force(sv,len);
        if (len >= (STRLEN)PL_origalen-1) {
            /* Longer than original, will be truncated. We assume that
             * PL_origalen bytes are available. */
            Copy(s, PL_origargv[0], PL_origalen-1, char);
        }
        else {
            /* Shorter than original, will be padded. */
#ifdef PERL_DARWIN
            /* Special case for Mac OS X: see [perl #38868] */
            const int pad = 0;
#else
            /* Is the space counterintuitive?  Yes.
             * (You were expecting \0?)
             * Does it work?  Seems to.  (In Linux 2.4.20 at least.)
             * --jhi */
            const int pad = ' ';
#endif
            Copy(s, PL_origargv[0], len, char);
            PL_origargv[0][len] = 0;
            memset(PL_origargv[0] + len + 1,
                   pad,  PL_origalen - len - 1);
        }
        PL_origargv[0][PL_origalen-1] = 0;
        for (i = 1; i < PL_origargc; i++)
            PL_origargv[i] = 0;
#ifdef HAS_PRCTL_SET_NAME
        /* Set the legacy process name in addition to the POSIX name on Linux */
        if (prctl(PR_SET_NAME, (unsigned long)s, 0, 0, 0) != 0) {
            /* diag_listed_as: SKIPME */
            Perl_croak(aTHX_ "Can't set $0 with prctl(): %s", Strerror(errno));
        }
#endif
    }
#endif
}

int
Perl_magic_set(pTHX_ SV *sv, MAGIC *mg)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
    I32 paren;
    const REGEXP * rx;
    I32 i;
    STRLEN len;
    MAGIC *tmg;

    PERL_ARGS_ASSERT_MAGIC_SET;

    if (!mg->mg_ptr) {
        paren = mg->mg_len;
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
          setparen_got_rx:
            CALLREG_NUMBUF_STORE((REGEXP * const)rx,paren,sv);
	} else {
            /* Croak with a READONLY error when a numbered match var is
             * set without a previous pattern match. Unless it's C<local $1>
             */
          croakparen:
            if (!PL_localizing) {
                Perl_croak_no_modify();
            }
        }
        return 0;
    }

    switch (*mg->mg_ptr) {
    case '\001':	/* ^A */
	if (SvOK(sv)) sv_copypv(PL_bodytarget, sv);
	else SvOK_off(PL_bodytarget);
	FmLINES(PL_bodytarget) = 0;
	if (SvPOK(PL_bodytarget)) {
	    char *s = SvPVX(PL_bodytarget);
	    while ( ((s = strchr(s, '\n'))) ) {
		FmLINES(PL_bodytarget)++;
		s++;
	    }
	}
	/* mg_set() has temporarily made sv non-magical */
	if (TAINTING_get) {
	    if ((tmg = mg_find(sv,PERL_MAGIC_taint)) && tmg->mg_len & 1)
		SvTAINTED_on(PL_bodytarget);
	    else
		SvTAINTED_off(PL_bodytarget);
	}
	break;
    case '\003':	/* ^C */
	PL_minus_c = cBOOL(SvIV(sv));
	break;

    case '\004':	/* ^D */
#ifdef DEBUGGING
        {
            const char *s = SvPV_nolen_const(sv);
            PL_debug = get_debug_opts(&s, 0) | DEBUG_TOP_FLAG;
            if (DEBUG_x_TEST || DEBUG_B_TEST)
                dump_all_perl(!DEBUG_B_TEST);
        }
#else
	PL_debug = (SvIV(sv)) | DEBUG_TOP_FLAG;
#endif
	break;
    case '\005':  /* ^E */
	if (*(mg->mg_ptr+1) == '\0') {
#ifdef VMS
	    set_vaxc_errno(SvIV(sv));
#else
#  ifdef WIN32
	    SetLastError( SvIV(sv) );
#  else
#    ifdef OS2
	    os2_setsyserrno(SvIV(sv));
#    else
	    /* will anyone ever use this? */
	    SETERRNO(SvIV(sv), 4);
#    endif
#  endif
#endif
	}
	else {
            unsigned int offset = 1;
            bool lex = FALSE;

            /* It may be the shadow variable ${E_NCODING} which has lexical
             * scope.  See comments at Perl__get_encoding in this file */
            if (*(mg->mg_ptr + 1) == '_') {
                if (CopSTASH(PL_curcop) != get_hv("encoding::",0))
                    Perl_croak_no_modify();
                lex = TRUE;
                offset++;
            }
            if (strEQ(mg->mg_ptr + offset, "NCODING")) {
                if (lex) {  /* Use the shadow global */
                    SvREFCNT_dec(PL_lex_encoding);
                    if (SvOK(sv) || SvGMAGICAL(sv)) {
                        PL_lex_encoding = newSVsv(sv);
                    }
                    else {
                        PL_lex_encoding = NULL;
                    }
                }
                else { /* Use the regular global */
                    SvREFCNT_dec(PL_encoding);
                    if (SvOK(sv) || SvGMAGICAL(sv)) {
                        if (PL_localizing != 2) {
                            Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
                                          "Setting ${^ENCODING} is deprecated");
                        }
                        PL_encoding = newSVsv(sv);
                    }
                    else {
                        PL_encoding = NULL;
                    }
                }
            }
        }
	break;
    case '\006':	/* ^F */
	PL_maxsysfd = SvIV(sv);
	break;
    case '\010':	/* ^H */
	PL_hints = SvIV(sv);
	break;
    case '\011':	/* ^I */ /* NOT \t in EBCDIC */
	Safefree(PL_inplace);
	PL_inplace = SvOK(sv) ? savesvpv(sv) : NULL;
	break;
    case '\016':	/* ^N */
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))
	 && (paren = RX_LASTCLOSEPAREN(rx))) goto setparen_got_rx;
	goto croakparen;
    case '\017':	/* ^O */
	if (*(mg->mg_ptr+1) == '\0') {
	    Safefree(PL_osname);
	    PL_osname = NULL;
	    if (SvOK(sv)) {
		TAINT_PROPER("assigning to $^O");
		PL_osname = savesvpv(sv);
	    }
	}
	else if (strEQ(mg->mg_ptr, "\017PEN")) {
	    STRLEN len;
	    const char *const start = SvPV(sv, len);
	    const char *out = (const char*)memchr(start, '\0', len);
	    SV *tmp;


	    PL_compiling.cop_hints |= HINT_LEXICAL_IO_IN | HINT_LEXICAL_IO_OUT;
	    PL_hints |= HINT_LEXICAL_IO_IN | HINT_LEXICAL_IO_OUT;

	    /* Opening for input is more common than opening for output, so
	       ensure that hints for input are sooner on linked list.  */
	    tmp = out ? newSVpvn_flags(out + 1, start + len - out - 1,
				       SvUTF8(sv))
		: newSVpvs_flags("", SvUTF8(sv));
	    (void)hv_stores(GvHV(PL_hintgv), "open>", tmp);
	    mg_set(tmp);

	    tmp = newSVpvn_flags(start, out ? (STRLEN)(out - start) : len,
				        SvUTF8(sv));
	    (void)hv_stores(GvHV(PL_hintgv), "open<", tmp);
	    mg_set(tmp);
	}
	break;
    case '\020':	/* ^P */
          PL_perldb = SvIV(sv);
          if (PL_perldb && !PL_DBsingle)
              init_debugger();
      break;
    case '\024':	/* ^T */
#ifdef BIG_TIME
	PL_basetime = (Time_t)(SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv));
#else
	PL_basetime = (Time_t)SvIV(sv);
#endif
	break;
    case '\025':	/* ^UTF8CACHE */
	 if (strEQ(mg->mg_ptr+1, "TF8CACHE")) {
	     PL_utf8cache = (signed char) sv_2iv(sv);
	 }
	 break;
    case '\027':	/* ^W & $^WARNING_BITS */
	if (*(mg->mg_ptr+1) == '\0') {
	    if ( ! (PL_dowarn & G_WARN_ALL_MASK)) {
	        i = SvIV(sv);
	        PL_dowarn = (PL_dowarn & ~G_WARN_ON)
		    		| (i ? G_WARN_ON : G_WARN_OFF) ;
	    }
	}
	else if (strEQ(mg->mg_ptr+1, "ARNING_BITS")) {
	    if ( ! (PL_dowarn & G_WARN_ALL_MASK)) {
		if (!SvPOK(sv)) {
	            PL_compiling.cop_warnings = pWARN_STD;
		    break;
		}
		{
		    STRLEN len, i;
		    int accumulate = 0 ;
		    int any_fatals = 0 ;
		    const char * const ptr = SvPV_const(sv, len) ;
		    for (i = 0 ; i < len ; ++i) {
		        accumulate |= ptr[i] ;
		        any_fatals |= (ptr[i] & 0xAA) ;
		    }
		    if (!accumulate) {
		        if (!specialWARN(PL_compiling.cop_warnings))
			    PerlMemShared_free(PL_compiling.cop_warnings);
			PL_compiling.cop_warnings = pWARN_NONE;
		    }
		    /* Yuck. I can't see how to abstract this:  */
		    else if (isWARN_on(
                                ((STRLEN *)SvPV_nolen_const(sv)) - 1,
                                WARN_ALL)
                            && !any_fatals)
                    {
			if (!specialWARN(PL_compiling.cop_warnings))
			    PerlMemShared_free(PL_compiling.cop_warnings);
	                PL_compiling.cop_warnings = pWARN_ALL;
	                PL_dowarn |= G_WARN_ONCE ;
	            }
                    else {
			STRLEN len;
			const char *const p = SvPV_const(sv, len);

			PL_compiling.cop_warnings
			    = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
							 p, len);

	                if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
	                    PL_dowarn |= G_WARN_ONCE ;
	            }

		}
	    }
	}
#ifdef WIN32
	else if (strEQ(mg->mg_ptr+1, "IN32_SLOPPY_STAT")) {
	    w32_sloppystat = (bool)sv_true(sv);
	}
#endif
	break;
    case '.':
	if (PL_localizing) {
	    if (PL_localizing == 1)
		SAVESPTR(PL_last_in_gv);
	}
	else if (SvOK(sv) && GvIO(PL_last_in_gv))
	    IoLINES(GvIOp(PL_last_in_gv)) = SvIV(sv);
	break;
    case '^':
	Safefree(IoTOP_NAME(GvIOp(PL_defoutgv)));
	IoTOP_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
	IoTOP_GV(GvIOp(PL_defoutgv)) =  gv_fetchsv(sv, GV_ADD, SVt_PVIO);
	break;
    case '~':
	Safefree(IoFMT_NAME(GvIOp(PL_defoutgv)));
	IoFMT_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
	IoFMT_GV(GvIOp(PL_defoutgv)) =  gv_fetchsv(sv, GV_ADD, SVt_PVIO);
	break;
    case '=':
	IoPAGE_LEN(GvIOp(PL_defoutgv)) = (SvIV(sv));
	break;
    case '-':
	IoLINES_LEFT(GvIOp(PL_defoutgv)) = (SvIV(sv));
	if (IoLINES_LEFT(GvIOp(PL_defoutgv)) < 0L)
		IoLINES_LEFT(GvIOp(PL_defoutgv)) = 0L;
	break;
    case '%':
	IoPAGE(GvIOp(PL_defoutgv)) = (SvIV(sv));
	break;
    case '|':
	{
	    IO * const io = GvIO(PL_defoutgv);
	    if(!io)
	      break;
	    if ((SvIV(sv)) == 0)
		IoFLAGS(io) &= ~IOf_FLUSH;
	    else {
		if (!(IoFLAGS(io) & IOf_FLUSH)) {
		    PerlIO *ofp = IoOFP(io);
		    if (ofp)
			(void)PerlIO_flush(ofp);
		    IoFLAGS(io) |= IOf_FLUSH;
		}
	    }
	}
	break;
    case '/':
        {
            SV *tmpsv= sv;
            if (SvROK(sv)) {
                SV *referent= SvRV(sv);
                const char *reftype= sv_reftype(referent, 0);
                /* XXX: dodgy type check: This leaves me feeling dirty, but the alternative
                 * is to copy pretty much the entire sv_reftype() into this routine, or to do
                 * a full string comparison on the return of sv_reftype() both of which
                 * make me feel worse! NOTE, do not modify this comment without reviewing the
                 * corresponding comment in sv_reftype(). - Yves */
                if (reftype[0] == 'S' || reftype[0] == 'L') {
                    IV val= SvIV(referent);
                    if (val <= 0) {
                        tmpsv= &PL_sv_undef;
                        Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
                            "Setting $/ to a reference to %s as a form of slurp is deprecated, treating as undef",
                            SvIV(SvRV(sv)) < 0 ? "a negative integer" : "zero"
                        );
                    }
                } else {
                    sv_setsv(sv, PL_rs);
              /* diag_listed_as: Setting $/ to %s reference is forbidden */
                    Perl_croak(aTHX_ "Setting $/ to a%s %s reference is forbidden",
                                      *reftype == 'A' ? "n" : "", reftype);
                }
            }
            SvREFCNT_dec(PL_rs);
            PL_rs = newSVsv(tmpsv);
        }
	break;
    case '\\':
	SvREFCNT_dec(PL_ors_sv);
	if (SvOK(sv)) {
	    PL_ors_sv = newSVsv(sv);
	}
	else {
	    PL_ors_sv = NULL;
	}
	break;
    case '[':
	if (SvIV(sv) != 0)
	    Perl_croak(aTHX_ "Assigning non-zero to $[ is no longer possible");
	break;
    case '?':
#ifdef COMPLEX_STATUS
	if (PL_localizing == 2) {
	    SvUPGRADE(sv, SVt_PVLV);
	    PL_statusvalue = LvTARGOFF(sv);
	    PL_statusvalue_vms = LvTARGLEN(sv);
	}
	else
#endif
#ifdef VMSISH_STATUS
	if (VMSISH_STATUS)
	    STATUS_NATIVE_CHILD_SET((U32)SvIV(sv));
	else
#endif
	    STATUS_UNIX_EXIT_SET(SvIV(sv));
	break;
    case '!':
        {
#ifdef VMS
#   define PERL_VMS_BANG vaxc$errno
#else
#   define PERL_VMS_BANG 0
#endif
#if defined(WIN32) && ! defined(UNDER_CE)
	SETERRNO(win32_get_errno(SvIOK(sv) ? SvIVX(sv) : SvOK(sv) ? sv_2iv(sv) : 0),
		 (SvIV(sv) == EVMSERR) ? 4 : PERL_VMS_BANG);
#else
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : SvOK(sv) ? sv_2iv(sv) : 0,
		 (SvIV(sv) == EVMSERR) ? 4 : PERL_VMS_BANG);
#endif
	}
	break;
    case '<':
	{
        /* XXX $< currently silently ignores failures */
	const Uid_t new_uid = SvUID(sv);
	PL_delaymagic_uid = new_uid;
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_RUID;
	    break;				/* don't do magic till later */
	}
#ifdef HAS_SETRUID
	PERL_UNUSED_RESULT(setruid(new_uid));
#else
#ifdef HAS_SETREUID
        PERL_UNUSED_RESULT(setreuid(new_uid, (Uid_t)-1));
#else
#ifdef HAS_SETRESUID
        PERL_UNUSED_RESULT(setresuid(new_uid, (Uid_t)-1, (Uid_t)-1));
#else
	if (new_uid == PerlProc_geteuid()) {		/* special case $< = $> */
#ifdef PERL_DARWIN
	    /* workaround for Darwin's setuid peculiarity, cf [perl #24122] */
	    if (new_uid != 0 && PerlProc_getuid() == 0)
                PERL_UNUSED_RESULT(PerlProc_setuid(0));
#endif
            PERL_UNUSED_RESULT(PerlProc_setuid(new_uid));
	} else {
	    Perl_croak(aTHX_ "setruid() not implemented");
	}
#endif
#endif
#endif
	break;
	}
    case '>':
	{
        /* XXX $> currently silently ignores failures */
	const Uid_t new_euid = SvUID(sv);
	PL_delaymagic_euid = new_euid;
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_EUID;
	    break;				/* don't do magic till later */
	}
#ifdef HAS_SETEUID
	PERL_UNUSED_RESULT(seteuid(new_euid));
#else
#ifdef HAS_SETREUID
	PERL_UNUSED_RESULT(setreuid((Uid_t)-1, new_euid));
#else
#ifdef HAS_SETRESUID
	PERL_UNUSED_RESULT(setresuid((Uid_t)-1, new_euid, (Uid_t)-1));
#else
	if (new_euid == PerlProc_getuid())		/* special case $> = $< */
	    PERL_UNUSED_RESULT(PerlProc_setuid(new_euid));
	else {
	    Perl_croak(aTHX_ "seteuid() not implemented");
	}
#endif
#endif
#endif
	break;
	}
    case '(':
	{
        /* XXX $( currently silently ignores failures */
	const Gid_t new_gid = SvGID(sv);
	PL_delaymagic_gid = new_gid;
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_RGID;
	    break;				/* don't do magic till later */
	}
#ifdef HAS_SETRGID
	PERL_UNUSED_RESULT(setrgid(new_gid));
#else
#ifdef HAS_SETREGID
	PERL_UNUSED_RESULT(setregid(new_gid, (Gid_t)-1));
#else
#ifdef HAS_SETRESGID
        PERL_UNUSED_RESULT(setresgid(new_gid, (Gid_t)-1, (Gid_t) -1));
#else
	if (new_gid == PerlProc_getegid())			/* special case $( = $) */
	    PERL_UNUSED_RESULT(PerlProc_setgid(new_gid));
	else {
	    Perl_croak(aTHX_ "setrgid() not implemented");
	}
#endif
#endif
#endif
	break;
	}
    case ')':
	{
/* (hv) best guess: maybe we'll need configure probes to do a better job,
 * but you can override it if you need to.
 */
#ifndef INVALID_GID
#define INVALID_GID ((Gid_t)-1)
#endif
        /* XXX $) currently silently ignores failures */
	Gid_t new_egid;
#ifdef HAS_SETGROUPS
	{
	    const char *p = SvPV_const(sv, len);
            Groups_t *gary = NULL;
            const char* endptr;
            UV uv;
#ifdef _SC_NGROUPS_MAX
           int maxgrp = sysconf(_SC_NGROUPS_MAX);

           if (maxgrp < 0)
               maxgrp = NGROUPS;
#else
           int maxgrp = NGROUPS;
#endif

            while (isSPACE(*p))
                ++p;
            if (grok_atoUV(p, &uv, &endptr))
                new_egid = (Gid_t)uv;
            else {
                new_egid = INVALID_GID;
                endptr = NULL;
            }
            for (i = 0; i < maxgrp; ++i) {
                if (endptr == NULL)
                    break;
                p = endptr;
                while (isSPACE(*p))
                    ++p;
                if (!*p)
                    break;
                if (!gary)
                    Newx(gary, i + 1, Groups_t);
                else
                    Renew(gary, i + 1, Groups_t);
                if (grok_atoUV(p, &uv, &endptr))
                    gary[i] = (Groups_t)uv;
                else {
                    gary[i] = INVALID_GID;
                    endptr = NULL;
                }
            }
            if (i)
                PERL_UNUSED_RESULT(setgroups(i, gary));
	    Safefree(gary);
	}
#else  /* HAS_SETGROUPS */
        new_egid = SvGID(sv);
#endif /* HAS_SETGROUPS */
	PL_delaymagic_egid = new_egid;
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_EGID;
	    break;				/* don't do magic till later */
	}
#ifdef HAS_SETEGID
	PERL_UNUSED_RESULT(setegid(new_egid));
#else
#ifdef HAS_SETREGID
	PERL_UNUSED_RESULT(setregid((Gid_t)-1, new_egid));
#else
#ifdef HAS_SETRESGID
	PERL_UNUSED_RESULT(setresgid((Gid_t)-1, new_egid, (Gid_t)-1));
#else
	if (new_egid == PerlProc_getgid())			/* special case $) = $( */
	    PERL_UNUSED_RESULT(PerlProc_setgid(new_egid));
	else {
	    Perl_croak(aTHX_ "setegid() not implemented");
	}
#endif
#endif
#endif
	break;
	}
    case ':':
	PL_chopset = SvPV_force(sv,len);
	break;
    case '$': /* $$ */
	/* Store the pid in mg->mg_obj so we can tell when a fork has
	   occurred.  mg->mg_obj points to *$ by default, so clear it. */
	if (isGV(mg->mg_obj)) {
	    if (mg->mg_flags & MGf_REFCOUNTED) /* probably never true */
		SvREFCNT_dec(mg->mg_obj);
	    mg->mg_flags |= MGf_REFCOUNTED;
	    mg->mg_obj = newSViv((IV)PerlProc_getpid());
	}
	else sv_setiv(mg->mg_obj, (IV)PerlProc_getpid());
	break;
    case '0':
	LOCK_DOLLARZERO_MUTEX;
        S_set_dollarzero(aTHX_ sv);
	UNLOCK_DOLLARZERO_MUTEX;
	break;
    }
    return 0;
}

I32
Perl_whichsig_sv(pTHX_ SV *sigsv)
{
    const char *sigpv;
    STRLEN siglen;
    PERL_ARGS_ASSERT_WHICHSIG_SV;
    sigpv = SvPV_const(sigsv, siglen);
    return whichsig_pvn(sigpv, siglen);
}

I32
Perl_whichsig_pv(pTHX_ const char *sig)
{
    PERL_ARGS_ASSERT_WHICHSIG_PV;
    return whichsig_pvn(sig, strlen(sig));
}

I32
Perl_whichsig_pvn(pTHX_ const char *sig, STRLEN len)
{
    char* const* sigv;

    PERL_ARGS_ASSERT_WHICHSIG_PVN;
    PERL_UNUSED_CONTEXT;

    for (sigv = (char* const*)PL_sig_name; *sigv; sigv++)
	if (strlen(*sigv) == len && memEQ(sig,*sigv, len))
	    return PL_sig_num[sigv - (char* const*)PL_sig_name];
#ifdef SIGCLD
    if (memEQs(sig, len, "CHLD"))
	return SIGCLD;
#endif
#ifdef SIGCHLD
    if (memEQs(sig, len, "CLD"))
	return SIGCHLD;
#endif
    return -1;
}

Signal_t
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
Perl_sighandler(int sig, siginfo_t *sip, void *uap)
#else
Perl_sighandler(int sig)
#endif
{
#ifdef PERL_GET_SIG_CONTEXT
    dTHXa(PERL_GET_SIG_CONTEXT);
#else
    dTHX;
#endif
    dSP;
    GV *gv = NULL;
    SV *sv = NULL;
    SV * const tSv = PL_Sv;
    CV *cv = NULL;
    OP *myop = PL_op;
    U32 flags = 0;
    XPV * const tXpv = PL_Xpv;
    I32 old_ss_ix = PL_savestack_ix;
    SV *errsv_save = NULL;


    if (!PL_psig_ptr[sig]) {
		PerlIO_printf(Perl_error_log, "Signal SIG%s received, but no signal handler set.\n",
				 PL_sig_name[sig]);
		exit(sig);
	}

    if (PL_signals &  PERL_SIGNALS_UNSAFE_FLAG) {
	/* Max number of items pushed there is 3*n or 4. We cannot fix
	   infinity, so we fix 4 (in fact 5): */
	if (PL_savestack_ix + 15 <= PL_savestack_max) {
	    flags |= 1;
	    PL_savestack_ix += 5;		/* Protect save in progress. */
	    SAVEDESTRUCTOR_X(S_unwind_handler_stack, NULL);
	}
    }
    /* sv_2cv is too complicated, try a simpler variant first: */
    if (!SvROK(PL_psig_ptr[sig]) || !(cv = MUTABLE_CV(SvRV(PL_psig_ptr[sig])))
	|| SvTYPE(cv) != SVt_PVCV) {
	HV *st;
	cv = sv_2cv(PL_psig_ptr[sig], &st, &gv, GV_ADD);
    }

    if (!cv || !CvROOT(cv)) {
	const HEK * const hek = gv
			? GvENAME_HEK(gv)
			: cv && CvNAMED(cv)
			   ? CvNAME_HEK(cv)
			   : cv && CvGV(cv) ? GvENAME_HEK(CvGV(cv)) : NULL;
	if (hek)
	    Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
				"SIG%s handler \"%"HEKf"\" not defined.\n",
			         PL_sig_name[sig], HEKfARG(hek));
	     /* diag_listed_as: SIG%s handler "%s" not defined */
	else Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
			   "SIG%s handler \"__ANON__\" not defined.\n",
			    PL_sig_name[sig]);
	goto cleanup;
    }

    sv = PL_psig_name[sig]
	    ? SvREFCNT_inc_NN(PL_psig_name[sig])
	    : newSVpv(PL_sig_name[sig],0);
    flags |= 8;
    SAVEFREESV(sv);

    if (PL_signals &  PERL_SIGNALS_UNSAFE_FLAG) {
	/* make sure our assumption about the size of the SAVEs are correct:
	 * 3 for SAVEDESTRUCTOR_X, 2 for SAVEFREESV */
	assert(old_ss_ix + 2 + ((flags & 1) ? 3+5 : 0)  == PL_savestack_ix);
    }

    PUSHSTACKi(PERLSI_SIGNAL);
    PUSHMARK(SP);
    PUSHs(sv);
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
    {
	 struct sigaction oact;

	 if (sigaction(sig, 0, &oact) == 0 && oact.sa_flags & SA_SIGINFO) {
	      if (sip) {
		   HV *sih = newHV();
		   SV *rv  = newRV_noinc(MUTABLE_SV(sih));
		   /* The siginfo fields signo, code, errno, pid, uid,
		    * addr, status, and band are defined by POSIX/SUSv3. */
		   (void)hv_stores(sih, "signo", newSViv(sip->si_signo));
		   (void)hv_stores(sih, "code", newSViv(sip->si_code));
#ifdef HAS_SIGINFO_SI_ERRNO
		   (void)hv_stores(sih, "errno",      newSViv(sip->si_errno));
#endif
#ifdef HAS_SIGINFO_SI_STATUS
		   (void)hv_stores(sih, "status",     newSViv(sip->si_status));
#endif
#ifdef HAS_SIGINFO_SI_UID
		   {
			SV *uid = newSV(0);
			sv_setuid(uid, sip->si_uid);
			(void)hv_stores(sih, "uid", uid);
		   }
#endif
#ifdef HAS_SIGINFO_SI_PID
		   (void)hv_stores(sih, "pid",        newSViv(sip->si_pid));
#endif
#ifdef HAS_SIGINFO_SI_ADDR
		   (void)hv_stores(sih, "addr",       newSVuv(PTR2UV(sip->si_addr)));
#endif
#ifdef HAS_SIGINFO_SI_BAND
		   (void)hv_stores(sih, "band",       newSViv(sip->si_band));
#endif
		   EXTEND(SP, 2);
		   PUSHs(rv);
		   mPUSHp((char *)sip, sizeof(*sip));
	      }

	 }
    }
#endif
    PUTBACK;

    errsv_save = newSVsv(ERRSV);

    call_sv(MUTABLE_SV(cv), G_DISCARD|G_EVAL);

    POPSTACK;
    {
	SV * const errsv = ERRSV;
	if (SvTRUE_NN(errsv)) {
	    SvREFCNT_dec(errsv_save);
#ifndef PERL_MICRO
	/* Handler "died", for example to get out of a restart-able read().
	 * Before we re-do that on its behalf re-enable the signal which was
	 * blocked by the system when we entered.
	 */
#ifdef HAS_SIGPROCMASK
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
	    if (sip || uap)
#endif
	    {
		sigset_t set;
		sigemptyset(&set);
		sigaddset(&set,sig);
		sigprocmask(SIG_UNBLOCK, &set, NULL);
	    }
#else
	    /* Not clear if this will work */
	    (void)rsignal(sig, SIG_IGN);
	    (void)rsignal(sig, PL_csighandlerp);
#endif
#endif /* !PERL_MICRO */
	    die_sv(errsv);
	}
	else {
	    sv_setsv(errsv, errsv_save);
	    SvREFCNT_dec(errsv_save);
	}
    }

  cleanup:
    /* pop any of SAVEFREESV, SAVEDESTRUCTOR_X and "save in progress" */
    PL_savestack_ix = old_ss_ix;
    if (flags & 8)
	SvREFCNT_dec_NN(sv);
    PL_op = myop;			/* Apparently not needed... */

    PL_Sv = tSv;			/* Restore global temporaries. */
    PL_Xpv = tXpv;
    return;
}


static void
S_restore_magic(pTHX_ const void *p)
{
    MGS* const mgs = SSPTR(PTR2IV(p), MGS*);
    SV* const sv = mgs->mgs_sv;
    bool bumped;

    if (!sv)
        return;

    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	SvTEMP_off(sv); /* if it's still magical, this value isn't temporary */
	if (mgs->mgs_flags)
	    SvFLAGS(sv) |= mgs->mgs_flags;
	else
	    mg_magical(sv);
    }

    bumped = mgs->mgs_bumped;
    mgs->mgs_sv = NULL;  /* mark the MGS structure as restored */

    /* If we're still on top of the stack, pop us off.  (That condition
     * will be satisfied if restore_magic was called explicitly, but *not*
     * if it's being called via leave_scope.)
     * The reason for doing this is that otherwise, things like sv_2cv()
     * may leave alloc gunk on the savestack, and some code
     * (e.g. sighandler) doesn't expect that...
     */
    if (PL_savestack_ix == mgs->mgs_ss_ix)
    {
	UV popval = SSPOPUV;
        assert(popval == SAVEt_DESTRUCTOR_X);
        PL_savestack_ix -= 2;
	popval = SSPOPUV;
        assert((popval & SAVE_MASK) == SAVEt_ALLOC);
        PL_savestack_ix -= popval >> SAVE_TIGHT_SHIFT;
    }
    if (bumped) {
	if (SvREFCNT(sv) == 1) {
	    /* We hold the last reference to this SV, which implies that the
	       SV was deleted as a side effect of the routines we called.
	       So artificially keep it alive a bit longer.
	       We avoid turning on the TEMP flag, which can cause the SV's
	       buffer to get stolen (and maybe other stuff). */
	    sv_2mortal(sv);
	    SvTEMP_off(sv);
	}
	else
	    SvREFCNT_dec_NN(sv); /* undo the inc in S_save_magic() */
    }
}

/* clean up the mess created by Perl_sighandler().
 * Note that this is only called during an exit in a signal handler;
 * a die is trapped by the call_sv() and the SAVEDESTRUCTOR_X manually
 * skipped over. */

static void
S_unwind_handler_stack(pTHX_ const void *p)
{
    PERL_UNUSED_ARG(p);

    PL_savestack_ix -= 5; /* Unprotect save in progress. */
}

/*
=for apidoc magic_sethint

Triggered by a store to C<%^H>, records the key/value pair to
C<PL_compiling.cop_hints_hash>.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.

=cut
*/
int
Perl_magic_sethint(pTHX_ SV *sv, MAGIC *mg)
{
    SV *key = (mg->mg_len == HEf_SVKEY) ? MUTABLE_SV(mg->mg_ptr)
	: newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP);

    PERL_ARGS_ASSERT_MAGIC_SETHINT;

    /* mg->mg_obj isn't being used.  If needed, it would be possible to store
       an alternative leaf in there, with PL_compiling.cop_hints being used if
       it's NULL. If needed for threads, the alternative could lock a mutex,
       or take other more complex action.  */

    /* Something changed in %^H, so it will need to be restored on scope exit.
       Doing this here saves a lot of doing it manually in perl code (and
       forgetting to do it, and consequent subtle errors.  */
    PL_hints |= HINT_LOCALIZE_HH;
    CopHINTHASH_set(&PL_compiling,
	cophh_store_sv(CopHINTHASH_get(&PL_compiling), key, 0, sv, 0));
    return 0;
}

/*
=for apidoc magic_clearhint

Triggered by a delete from C<%^H>, records the key to
C<PL_compiling.cop_hints_hash>.

=cut
*/
int
Perl_magic_clearhint(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARHINT;
    PERL_UNUSED_ARG(sv);

    PL_hints |= HINT_LOCALIZE_HH;
    CopHINTHASH_set(&PL_compiling,
	mg->mg_len == HEf_SVKEY
	 ? cophh_delete_sv(CopHINTHASH_get(&PL_compiling),
				 MUTABLE_SV(mg->mg_ptr), 0, 0)
	 : cophh_delete_pvn(CopHINTHASH_get(&PL_compiling),
				 mg->mg_ptr, mg->mg_len, 0, 0));
    return 0;
}

/*
=for apidoc magic_clearhints

Triggered by clearing C<%^H>, resets C<PL_compiling.cop_hints_hash>.

=cut
*/
int
Perl_magic_clearhints(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARHINTS;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
    cophh_free(CopHINTHASH_get(&PL_compiling));
    CopHINTHASH_set(&PL_compiling, cophh_new_empty());
    return 0;
}

int
Perl_magic_copycallchecker(pTHX_ SV *sv, MAGIC *mg, SV *nsv,
				 const char *name, I32 namlen)
{
    MAGIC *nmg;

    PERL_ARGS_ASSERT_MAGIC_COPYCALLCHECKER;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(name);
    PERL_UNUSED_ARG(namlen);

    sv_magic(nsv, &PL_sv_undef, mg->mg_type, NULL, 0);
    nmg = mg_find(nsv, mg->mg_type);
    assert(nmg);
    if (nmg->mg_flags & MGf_REFCOUNTED) SvREFCNT_dec(nmg->mg_obj);
    nmg->mg_ptr = mg->mg_ptr;
    nmg->mg_obj = SvREFCNT_inc_simple(mg->mg_obj);
    nmg->mg_flags |= MGf_REFCOUNTED;
    return 1;
}

int
Perl_magic_setdebugvar(pTHX_ SV *sv, MAGIC *mg) {
    PERL_ARGS_ASSERT_MAGIC_SETDEBUGVAR;

#if DBVARMG_SINGLE != 0
    assert(mg->mg_private >= DBVARMG_SINGLE);
#endif
    assert(mg->mg_private < DBVARMG_COUNT);

    PL_DBcontrol[mg->mg_private] = SvIV_nomg(sv);

    return 1;
}

int
Perl_magic_getdebugvar(pTHX_ SV *sv, MAGIC *mg) {
    PERL_ARGS_ASSERT_MAGIC_GETDEBUGVAR;

#if DBVARMG_SINGLE != 0
    assert(mg->mg_private >= DBVARMG_SINGLE);
#endif
    assert(mg->mg_private < DBVARMG_COUNT);
    sv_setiv(sv, PL_DBcontrol[mg->mg_private]);

    return 0;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.22
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d1262 1
a1262 1
		s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf,
@


1.21
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a19 1

d37 2
d87 1
a87 2
    U32 mgs_magical;
    bool mgs_readonly;
a94 1
    dVAR;
d117 1
a117 2
    mgs->mgs_magical = SvMAGICAL(sv);
    mgs->mgs_readonly = SvREADONLY(sv) != 0;
d130 1
a130 1
Turns on the magical status of an SV.  See C<sv_magic>.
d136 1
a136 1
Perl_mg_magical(pTHX_ SV *sv)
a139 1
    PERL_UNUSED_CONTEXT;
d163 1
a163 1
be >= SVt_PVMG.  See C<sv_magic>.
a170 1
    dVAR;
d202 2
a203 1
		(SSPTR(mgs_ix, MGS *))->mgs_magical = 0; /* recalculate flags */
d209 2
a210 1
		(SSPTR(mgs_ix, MGS *))->mgs_magical = 0;
d234 2
a235 1
	    (SSPTR(mgs_ix, MGS *))->mgs_magical = 0; /* recalculate flags */
d248 1
a248 1
Do magic after a value is assigned to the SV.  See C<sv_magic>.
a255 1
    dVAR;
d271 1
a271 1
	    (SSPTR(mgs_ix, MGS*))->mgs_magical = 0;
d288 1
a288 1
but does not set the UTF8 flag on the sv.  It will fall back to 'get'
d290 2
a291 2
whether it called 'get' magic.  It assumes the sv is a PVMG or
higher.  Use sv_len() instead.
a298 1
    dVAR;
d347 1
a347 1
	    break;
d349 1
a349 1
    return 0;
d355 1
a355 1
Clear something magical that the SV represents.  See C<sv_magic>.
d386 1
a386 1
S_mg_findext_flags(pTHX_ const SV *sv, int type, const MGVTBL *vtbl, U32 flags)
a387 2
    PERL_UNUSED_CONTEXT;

a392 2
	assert(!(SvTYPE(sv) == SVt_PVAV && AvPAD_NAMELIST(sv)));

d406 1
a406 1
Finds the magic pointer for type matching the SV.  See C<sv_magic>.
d412 1
a412 1
Perl_mg_find(pTHX_ const SV *sv, int type)
d414 1
a414 1
    return S_mg_findext_flags(aTHX_ sv, type, NULL, 0);
d421 1
a421 1
C<sv_magicext>.
d427 1
a427 1
Perl_mg_findext(pTHX_ const SV *sv, int type, const MGVTBL *vtbl)
d429 1
a429 1
    return S_mg_findext_flags(aTHX_ sv, type, vtbl, 1);
d443 1
a443 1
        return S_mg_findext_flags(aTHX_ sv, PERL_MAGIC_regex_global, 0, 0);
d450 1
a450 1
Copies the magic from one SV to another.  See C<sv_magic>.
d489 3
a491 3
SV.  Container magic (eg %ENV, $1, tie)
gets copied, value magic doesn't (eg
taint, pos).
d493 2
a494 2
If setmagic is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. 'local $x = $y'),
a502 1
    dVAR;
d556 1
a556 1
Free any magic storage used by the SV.  See C<sv_magic>.
d582 1
a582 1
Remove any magic of type I<how> from the SV I<sv>.  See L</sv_magic>.
a616 1
    dVAR;
a647 2
    dVAR;

d691 1
a745 5
#if 0
    /* This is disabled to get v5.20 out the door.  It means that $! behaves as
     * if in the scope of both 'use locale' and 'use bytes'.  This can cause
     * mixed encodings and double utf8 upgrading,  See towards the end of the
     * thread for [perl #119499] */
d750 7
a756 6
         * avoid any possible backward compatibility issues, we don't turn on
         * the flag unless we have to.  So the flag stays off for an entirely
         * ASCII string.  We assume that if the string looks like UTF-8, it
         * really is UTF-8:  "text in any other encoding that uses bytes with
         * the high bit set is extremely unlikely to pass a UTF-8 validity
         * test" (http://en.wikipedia.org/wiki/Charset_detection).  There is a
d761 1
a761 1
            && ! is_ascii_string((U8*) SvPVX_const(sv), SvCUR(sv))
d767 40
a806 1
#endif
a816 1
    dVAR;
d859 3
a861 1
                sv_setsv(sv, PL_encoding);
d879 1
a879 1
            sv_setpv(sv, errno ? Strerror(errno) : "");
d934 1
a934 1
                sv_setpv(sv, Strerror(errno));
d1044 5
d1153 9
a1161 6
	    I32 i, num_groups = getgroups(0, gary);
            Newx(gary, num_groups, Groups_t);
            num_groups = getgroups(num_groups, gary);
	    for (i = 0; i < num_groups; i++)
		Perl_sv_catpvf(aTHX_ sv, " %"IVdf, (IV)gary[i]);
            Safefree(gary);
a1186 1
    dVAR;
d1218 1
a1218 1
#if !defined(OS2) && !defined(AMIGAOS) && !defined(WIN32) && !defined(MSDOS)
d1278 1
a1278 1
#endif /* neither OS2 nor AMIGAOS nor WIN32 nor MSDOS */
a1294 1
    dVAR;
a1316 1
    dVAR;
a1339 1
    dVAR;
d1396 8
d1475 1
a1482 1
    dVAR;
a1683 1
    dVAR;
a1697 1
    dVAR;
a1698 1

d1712 1
d1790 1
a1790 1
Returns the SV (if any) returned by the method, or NULL on failure.
a1799 1
    dVAR;
d1818 3
a1820 1
    EXTEND(SP, argc+1);
a1857 1
    dVAR;
a1881 1
    dVAR;
a1905 1
    dVAR;
a1946 1
    dVAR;
a1963 2
    dVAR;

a1972 1
    dVAR;
a1994 1
    dVAR;
a2022 1
    dVAR;
a2059 1
    dVAR;
a2074 1
    dVAR;
a2090 2
    dVAR;

d2093 1
a2108 2
    dVAR;

a2131 1
    dVAR;
a2151 1
    dVAR;
a2230 1
    dVAR;
a2283 2
    dVAR;

a2296 2
    dVAR;

a2332 1
    dVAR;
a2396 1
    dVAR;
d2515 137
d2654 1
d2656 1
a2656 1
    const char *s;
d2708 6
a2713 4
	s = SvPV_nolen_const(sv);
	PL_debug = get_debug_opts(&s, 0) | DEBUG_TOP_FLAG;
	if (DEBUG_x_TEST || DEBUG_B_TEST)
	    dump_all_perl(!DEBUG_B_TEST);
d2735 37
a2771 9
	else if (strEQ(mg->mg_ptr+1, "NCODING")) {
	    SvREFCNT_dec(PL_encoding);
	    if (SvOK(sv) || SvGMAGICAL(sv)) {
		PL_encoding = newSVsv(sv);
	    }
	    else {
		PL_encoding = NULL;
	    }
	}
d2891 5
d2907 1
a2907 1
	s = IoTOP_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
d2912 1
a2912 1
	s = IoFMT_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
d2958 1
a2958 1
                        Perl_ck_warner(aTHX_ packWARN(WARN_DEPRECATED),
d3110 6
d3122 2
d3135 6
a3140 1
            new_egid = (Gid_t)Atol(p);
d3142 3
a3144 2
                while (*p && !isSPACE(*p))
                    ++p;
d3149 1
a3149 1
                if(!gary)
d3153 6
a3158 1
                gary[i] = (Groups_t)Atol(p);
d3207 1
a3207 68
#ifdef HAS_SETPROCTITLE
	/* The BSDs don't show the argv[] in ps(1) output, they
	 * show a string from the process struct and provide
	 * the setproctitle() routine to manipulate that. */
	if (PL_origalen != 1) {
	    s = SvPV_const(sv, len);
#   if __FreeBSD_version > 410001
	    /* The leading "-" removes the "perl: " prefix,
	     * but not the "(perl) suffix from the ps(1)
	     * output, because that's what ps(1) shows if the
	     * argv[] is modified. */
	    setproctitle("-%s", s);
#   else	/* old FreeBSDs, NetBSD, OpenBSD, anyBSD */
	    /* This doesn't really work if you assume that
	     * $0 = 'foobar'; will wipe out 'perl' from the $0
	     * because in ps(1) output the result will be like
	     * sprintf("perl: %s (perl)", s)
	     * I guess this is a security feature:
	     * one (a user process) cannot get rid of the original name.
	     * --jhi */
	    setproctitle("%s", s);
#   endif
	}
#elif defined(__hpux) && defined(PSTAT_SETCMD)
	if (PL_origalen != 1) {
	     union pstun un;
	     s = SvPV_const(sv, len);
	     un.pst_command = (char *)s;
	     pstat(PSTAT_SETCMD, un, len, 0, 0);
	}
#else
	if (PL_origalen > 1) {
	    /* PL_origalen is set in perl_parse(). */
	    s = SvPV_force(sv,len);
	    if (len >= (STRLEN)PL_origalen-1) {
		/* Longer than original, will be truncated. We assume that
		 * PL_origalen bytes are available. */
		Copy(s, PL_origargv[0], PL_origalen-1, char);
	    }
	    else {
		/* Shorter than original, will be padded. */
#ifdef PERL_DARWIN
		/* Special case for Mac OS X: see [perl #38868] */
		const int pad = 0;
#else
		/* Is the space counterintuitive?  Yes.
		 * (You were expecting \0?)
		 * Does it work?  Seems to.  (In Linux 2.4.20 at least.)
		 * --jhi */
		const int pad = ' ';
#endif
		Copy(s, PL_origargv[0], len, char);
		PL_origargv[0][len] = 0;
		memset(PL_origargv[0] + len + 1,
		       pad,  PL_origalen - len - 1);
	    }
	    PL_origargv[0][PL_origalen-1] = 0;
	    for (i = 1; i < PL_origargc; i++)
		PL_origargv[i] = 0;
#ifdef HAS_PRCTL_SET_NAME
	    /* Set the legacy process name in addition to the POSIX name on Linux */
	    if (prctl(PR_SET_NAME, (unsigned long)s, 0, 0, 0) != 0) {
		/* diag_listed_as: SKIPME */
		Perl_croak(aTHX_ "Can't set $0 with prctl(): %s", Strerror(errno));
	    }
#endif
	}
#endif
a3219 1
    PERL_UNUSED_CONTEXT;
a3227 1
    PERL_UNUSED_CONTEXT;
d3300 13
a3312 5
	Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL), "SIG%s handler \"%s\" not defined.\n",
		       PL_sig_name[sig], (gv ? GvENAME(gv)
					  : ((cv && CvGV(cv))
					     ? GvENAME(CvGV(cv))
					     : "__ANON__")));
d3343 21
a3363 7
#if 0 /* XXX TODO: Configure scan for the existence of these, but even that does not help if the SA_SIGINFO is not implemented according to the spec. */
		   hv_stores(sih, "errno",      newSViv(sip->si_errno));
		   hv_stores(sih, "status",     newSViv(sip->si_status));
		   hv_stores(sih, "uid",        newSViv(sip->si_uid));
		   hv_stores(sih, "pid",        newSViv(sip->si_pid));
		   hv_stores(sih, "addr",       newSVuv(PTR2UV(sip->si_addr)));
		   hv_stores(sih, "band",       newSViv(sip->si_band));
d3413 1
a3413 1
cleanup:
a3428 1
    dVAR;
d3438 2
a3439 10
#ifdef PERL_OLD_COPY_ON_WRITE
	/* While magic was saved (and off) sv_setsv may well have seen
	   this SV as a prime candidate for COW.  */
	if (SvIsCOW(sv))
	    sv_force_normal_flags(sv, 0);
#endif
	if (mgs->mgs_readonly)
	    SvREADONLY_on(sv);
	if (mgs->mgs_magical)
	    SvFLAGS(sv) |= mgs->mgs_magical;
a3485 1
    dVAR;
d3494 1
a3494 1
Triggered by a store to %^H, records the key/value pair to
a3503 1
    dVAR;
d3526 1
a3526 1
Triggered by a delete from %^H, records the key to
a3533 2
    dVAR;

d3550 1
a3550 1
Triggered by clearing %^H, resets C<PL_compiling.cop_hints_hash>.
d3578 1
d3586 27
a3613 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.20
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@a1079 1
	break;
d2777 1
@


1.19
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d2273 1
a2273 1
    TAINT_IF((PL_localizing != 1) && (mg->mg_len & 1));
@


1.18
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d24 1
a24 1
with that SV's magic. A get is called prior to reading an SV, in order to
d26 1
a26 1
number of the last read filehandle into to the SV's IV slot), while
d32 1
a32 1
SV. Each MAGIC struct holds the type of the magic, a pointer to an array
d34 1
a34 1
plus space for some flags and pointers. For example, a tied variable has
d93 1
a93 1
S_save_magic(pTHX_ I32 mgs_ix, SV *sv)
d99 1
a99 1
    PERL_ARGS_ASSERT_SAVE_MAGIC;
d119 1
a119 1
    mgs->mgs_readonly = SvREADONLY(sv) && !SvIsCOW(sv);
d123 2
a124 4
    SvMAGICAL_off(sv);
    /* Turning READONLY off for a copy-on-write scalar (including shared
       hash keys) is a bad idea.  */
    if (!SvIsCOW(sv)) SvREADONLY_off(sv);
d127 2
d166 1
a166 1
be >= SVt_PVMG. See C<sv_magic>.
d266 1
a266 1
    save_magic(mgs_ix, sv);
d289 1
a289 3
This function is deprecated.

It reports on the SV's length in bytes, calling length magic if available,
d398 2
d439 15
d496 2
a497 1
SV. Container magic (eg %ENV, $1, tie) gets copied, value magic doesn't (eg
d530 1
a530 1
	if (!SvIsCOW(sv)) SvFLAGS(nsv) |= SvREADONLY(sv);
d665 2
a666 2
	    I32 s;
	    I32 t;
d673 1
a673 1
		    I32 i;
d679 1
a679 1
		    if (i > 0 && RX_MATCH_UTF8(rx)) {
d687 2
a688 1
		    sv_setiv(sv, i);
d692 1
d743 41
d797 1
a797 1
    const char nextchar = *remaining;
d801 12
d833 17
a849 11
	 if (nextchar == '\0') {
#if defined(VMS)
	     {
		  char msg[255];
		  $DESCRIPTOR(msgdsc,msg);
		  sv_setnv(sv,(NV) vaxc$errno);
		  if (sys$getmsg(vaxc$errno,&msgdsc.dsc$w_length,&msgdsc,0,0) & 1)
		       sv_setpvn(sv,msgdsc.dsc$a_pointer,msgdsc.dsc$w_length);
		  else
		       sv_setpvs(sv,"");
	     }
d851 48
a898 30
	     if (!(_emx_env & 0x200)) {	/* Under DOS */
		  sv_setnv(sv, (NV)errno);
		  sv_setpv(sv, errno ? Strerror(errno) : "");
	     } else {
		  if (errno != errno_isOS2) {
		       const int tmp = _syserrno();
		       if (tmp)	/* 2nd call to _syserrno() makes it 0 */
			    Perl_rc = tmp;
		  }
		  sv_setnv(sv, (NV)Perl_rc);
		  sv_setpv(sv, os2error(Perl_rc));
	     }
#elif defined(WIN32)
	     {
		  const DWORD dwErr = GetLastError();
		  sv_setnv(sv, (NV)dwErr);
		  if (dwErr) {
		       PerlProc_GetOSError(sv, dwErr);
		  }
		  else
		       sv_setpvs(sv, "");
		  SetLastError(dwErr);
	     }
#else
	     {
		 dSAVE_ERRNO;
		 sv_setnv(sv, (NV)errno);
		 sv_setpv(sv, errno ? Strerror(errno) : "");
		 RESTORE_ERRNO;
	     }
d900 20
a919 6
	     SvRTRIM(sv);
	     SvNOK_on(sv);	/* what a wonderful hack! */
	 }
	 else if (strEQ(remaining, "NCODING"))
	      sv_setsv(sv, PL_encoding);
	 break;
d959 1
a959 10
	if (nextchar == '\0') {       /* ^P */
	    sv_setiv(sv, (IV)PL_perldb);
	} else if (strEQ(remaining, "REMATCH")) { /* $^PREMATCH */

            paren = RX_BUFF_IDX_CARET_PREMATCH;
	    goto do_numbuf_fetch;
	} else if (strEQ(remaining, "OSTMATCH")) { /* $^POSTMATCH */
            paren = RX_BUFF_IDX_CARET_POSTMATCH;
	    goto do_numbuf_fetch;
	}
d962 1
a962 1
	if (nextchar == '\0') {
a1018 20
    case '\015': /* $^MATCH */
	if (strEQ(remaining, "ATCH")) {
            paren = RX_BUFF_IDX_CARET_FULLMATCH;
	    goto do_numbuf_fetch;
        }

    case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9': case '&':
        /*
         * Pre-threads, this was paren = atoi(GvENAME((const GV *)mg->mg_obj));
         * XXX Does the new way break anything?
         */
        paren = atoi(mg->mg_ptr); /* $& is in [0] */
      do_numbuf_fetch:
        if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
            CALLREG_NUMBUF_FETCH(rx,paren,sv);
            break;
        }
        sv_setsv(sv,&PL_sv_undef);
	break;
a1034 6
    case '`':
        paren = RX_BUFF_IDX_PREMATCH;
        goto do_numbuf_fetch;
    case '\'':
        paren = RX_BUFF_IDX_POSTMATCH;
        goto do_numbuf_fetch;
a1107 21

    case '!':
	{
	dSAVE_ERRNO;
#ifdef VMS
	sv_setnv(sv, (NV)((errno == EVMSERR) ? vaxc$errno : errno));
#else
	sv_setnv(sv, (NV)errno);
#endif
#ifdef OS2
	if (errno == errno_isOS2 || errno == errno_isOS2_set)
	    sv_setpv(sv, os2error(Perl_rc));
	else
#endif
	sv_setpv(sv, errno ? Strerror(errno) : "");
	RESTORE_ERRNO;
	}

	SvRTRIM(sv);
	SvNOK_on(sv);	/* what a wonderful hack! */
	break;
d1109 1
a1109 1
	sv_setiv(sv, (IV)PerlProc_getuid());
d1112 1
a1112 1
	sv_setiv(sv, (IV)PerlProc_geteuid());
d1115 1
a1115 1
	sv_setiv(sv, (IV)PerlProc_getgid());
d1118 1
a1118 1
	sv_setiv(sv, (IV)PerlProc_getegid());
d1762 1
a1762 1
Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, const char *meth, U32 flags,
d1803 1
a1803 1
	call_method(meth, G_SCALAR|G_DISCARD);
d1806 1
a1806 1
	if (call_method(meth, G_SCALAR))
a1815 1

d1819 1
a1819 1
S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, const char *meth, U32 flags,
d1845 1
a1845 1
S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, const char *meth)
d1865 1
a1865 1
    magic_methpack(sv,mg,"FETCH");
d1897 1
a1897 1
    magic_methcall1(sv, mg, "STORE", G_DISCARD, 2, val);
d1907 1
a1907 1
    return magic_methpack(sv,mg,"DELETE");
d1920 1
a1920 1
    retsv = magic_methcall1(sv, mg, "FETCHSIZE", 0, 1, NULL);
d1936 1
a1936 1
    Perl_magic_methcall(aTHX_ sv, mg, "CLEAR", G_DISCARD, 0);
d1948 2
a1949 2
    ret = SvOK(key) ? Perl_magic_methcall(aTHX_ sv, mg, "NEXTKEY", 0, 1, key)
	: Perl_magic_methcall(aTHX_ sv, mg, "FIRSTKEY", 0, 0);
d1960 1
a1960 1
    return magic_methpack(sv,mg,"EXISTS");
d1986 1
a1986 1
    retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(hv), mg, "SCALAR", 0, 0);
d1996 1
a1996 4
    GV * const gv = PL_DBline;
    const I32 i = SvTRUE(sv);
    SV ** const svp = av_fetch(GvAV(gv),
		     atoi(MgPV_nolen_const(mg)), FALSE);
d2000 11
d2018 1
a2018 1
	    if (i)
d2041 1
a2041 1
	SvOK_off(sv);
d2112 1
d2117 5
a2121 7
    if (SvTYPE(lsv) >= SVt_PVMG && SvMAGIC(lsv)) {
	MAGIC * const found = mg_find(lsv, PERL_MAGIC_regex_global);
	if (found && found->mg_len >= 0) {
	    I32 i = found->mg_len;
	    if (DO_UTF8(lsv))
		sv_pos_b2u(lsv, &i);
	    sv_setiv(sv, i);
a2122 1
	}
d2124 1
a2124 1
    SvOK_off(sv);
d2142 1
a2142 4
    if (SvTYPE(lsv) >= SVt_PVMG && SvMAGIC(lsv))
	found = mg_find(lsv, PERL_MAGIC_regex_global);
    else
	found = NULL;
d2146 1
a2146 6
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(lsv))
        sv_force_normal_flags(lsv, 0);
#endif
	found = sv_magicext(lsv, NULL, PERL_MAGIC_regex_global, &PL_vtbl_mglob,
			    NULL, 0);
a2169 4
    if (ulen) {
	pos = sv_or_pv_pos_u2b(lsv, s, pos, 0);
    }

d2171 1
a2171 1
    found->mg_flags &= ~MGf_MINMATCH;
d2301 1
a2301 4
    if (lsv)
	sv_setuv(sv, do_vecget(lsv, LvTARGOFF(sv), LvTARGLEN(sv)));
    else
	SvOK_off(sv);
d2315 2
a2316 2
int
Perl_magic_getdefelem(pTHX_ SV *sv, MAGIC *mg)
d2320 3
a2322 3

    PERL_ARGS_ASSERT_MAGIC_GETDEFELEM;

d2330 1
a2330 1
	else {
d2332 9
a2340 2
	    if ((I32)LvTARGOFF(sv) <= AvFILL(av))
		targ = AvARRAY(av)[LvTARGOFF(sv)];
d2351 1
d2354 9
a2362 2
	targ = LvTARG(sv);
    sv_setsv(sv, targ ? targ : &PL_sv_undef);
d2399 2
d2403 1
a2403 1
	if ((I32)LvTARGLEN(sv) < 0 && (I32)LvTARGOFF(sv) > AvFILL(av))
d2406 3
a2408 3
	    SV* const * const svp = av_fetch(av, LvTARGOFF(sv), TRUE);
	    if (!svp || (value = *svp) == &PL_sv_undef)
		Perl_croak(aTHX_ PL_no_aelem, (I32)LvTARGOFF(sv));
a2507 1
    const char * const remaining = mg->mg_ptr + 1;
d2514 2
a2515 20
    switch (*mg->mg_ptr) {
    case '\015': /* $^MATCH */
      if (strEQ(remaining, "ATCH"))
          goto do_match;
    case '`': /* ${^PREMATCH} caught below */
      do_prematch:
      paren = RX_BUFF_IDX_PREMATCH;
      goto setparen;
    case '\'': /* ${^POSTMATCH} caught below */
      do_postmatch:
      paren = RX_BUFF_IDX_POSTMATCH;
      goto setparen;
    case '&':
      do_match:
      paren = RX_BUFF_IDX_FULLMATCH;
      goto setparen;
    case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      paren = atoi(mg->mg_ptr);
      setparen:
d2517 1
a2517 1
      setparen_got_rx:
d2523 1
a2523 1
      croakparen:
d2528 4
a2531 1
        break;
a2639 1
      if (*remaining == '\0') { /* ^P */
a2642 6
          break;
      } else if (strEQ(remaining, "REMATCH")) { /* $^PREMATCH */
          goto do_prematch;
      } else if (strEQ(remaining, "OSTMATCH")) { /* $^POSTMATCH */
          goto do_postmatch;
      }
d2685 5
a2689 2
		    else if (isWARN_on(((STRLEN *)SvPV_nolen_const(sv)) - 1,
				       WARN_ALL) && !any_fatals) {
d2758 28
a2785 2
	SvREFCNT_dec(PL_rs);
	PL_rs = newSVsv(sv);
d2823 4
d2829 1
d2834 2
a2835 1
	const IV new_uid = SvIV(sv);
d2842 1
a2842 1
	(void)setruid((Uid_t)new_uid);
d2845 1
a2845 1
	(void)setreuid((Uid_t)new_uid, (Uid_t)-1);
d2848 1
a2848 1
      (void)setresuid((Uid_t)new_uid, (Uid_t)-1, (Uid_t)-1);
d2854 1
a2854 1
		(void)PerlProc_setuid(0);
d2856 1
a2856 1
	    (void)PerlProc_setuid(new_uid);
d2867 2
a2868 1
	const UV new_euid = SvIV(sv);
d2875 1
a2875 1
	(void)seteuid((Uid_t)new_euid);
d2878 1
a2878 1
	(void)setreuid((Uid_t)-1, (Uid_t)new_euid);
d2881 1
a2881 1
	(void)setresuid((Uid_t)-1, (Uid_t)new_euid, (Uid_t)-1);
d2884 1
a2884 1
	    PerlProc_setuid(new_euid);
d2895 2
a2896 1
	const UV new_gid = SvIV(sv);
d2903 1
a2903 1
	(void)setrgid((Gid_t)new_gid);
d2906 1
a2906 1
	(void)setregid((Gid_t)new_gid, (Gid_t)-1);
d2909 1
a2909 1
      (void)setresgid((Gid_t)new_gid, (Gid_t)-1, (Gid_t) -1);
d2912 1
a2912 1
	    (void)PerlProc_setgid(new_gid);
d2923 2
a2924 1
	UV new_egid;
d2940 1
a2940 1
            new_egid = Atol(p);
d2952 1
a2952 1
                gary[i] = Atol(p);
d2955 1
a2955 1
                (void)setgroups(i, gary);
d2959 1
a2959 1
	new_egid = SvIV(sv);
d2967 1
a2967 1
	(void)setegid((Gid_t)new_egid);
d2970 1
a2970 1
	(void)setregid((Gid_t)-1, (Gid_t)new_egid);
d2973 1
a2973 1
	(void)setresgid((Gid_t)-1, (Gid_t)new_egid, (Gid_t)-1);
d2976 1
a2976 1
	    (void)PerlProc_setgid(new_egid);
d3258 1
a3258 1
	SvREFCNT_dec(sv);
d3324 1
a3324 1
	    SvREFCNT_dec(sv); /* undo the inc in S_save_magic() */
@


1.17
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d79 1
d101 2
a113 6
    assert(SvMAGICAL(sv));
    /* Turning READONLY off for a copy-on-write scalar (including shared
       hash keys) is a bad idea.  */
    if (SvIsCOW(sv))
      sv_force_normal_flags(sv, 0);

d119 1
a119 1
    mgs->mgs_readonly = SvREADONLY(sv) != 0;
d124 3
a126 5
    SvREADONLY_off(sv);
    if (!(SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK))) {
	/* No public flags are set, so promote any private flags to public.  */
	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
    }
d165 2
a166 1
Do magic before a value is retrieved from the SV.  See C<sv_magic>.
d176 1
a183 2
    save_magic(mgs_ix, sv);

d194 7
d214 4
d240 3
a242 1
    restore_magic(INT2PTR(void *, (IV)mgs_ix));
d289 7
a295 1
Report on the SV's length.  See C<sv_magic>.
d321 1
a321 9
    {
	/* You can't know whether it's UTF-8 until you get the string again...
	 */
        const U8 *s = (U8*)SvPV_const(sv, len);

	if (DO_UTF8(sv)) {
	    len = utf8_length(s, s + len);
	}
    }
d615 1
a615 1
	register const REGEXP * const rx = PM_GETRE(PL_curpm);
d636 2
d646 1
a646 1
	register const REGEXP * const rx = PM_GETRE(PL_curpm);
d648 3
a650 3
	    register const I32 paren = mg->mg_len;
	    register I32 s;
	    register I32 t;
d657 1
a657 1
		    register I32 i;
d666 3
a668 1
			    i = utf8_length((U8*)b, (U8*)(b+i));
d678 2
d686 1
a686 1
    Perl_croak_no_modify(aTHX);
a689 79
U32
Perl_magic_len(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    register I32 paren;
    register I32 i;
    register const REGEXP * rx;
    const char * const remaining = mg->mg_ptr + 1;

    PERL_ARGS_ASSERT_MAGIC_LEN;

    switch (*mg->mg_ptr) {
    case '\020':		
      if (*remaining == '\0') { /* ^P */
          break;
      } else if (strEQ(remaining, "REMATCH")) { /* $^PREMATCH */
          goto do_prematch;
      } else if (strEQ(remaining, "OSTMATCH")) { /* $^POSTMATCH */
          goto do_postmatch;
      }
      break;
    case '\015': /* $^MATCH */
	if (strEQ(remaining, "ATCH")) {
        goto do_match;
    } else {
        break;
    }
    case '`':
      do_prematch:
      paren = RX_BUFF_IDX_PREMATCH;
      goto maybegetparen;
    case '\'':
      do_postmatch:
      paren = RX_BUFF_IDX_POSTMATCH;
      goto maybegetparen;
    case '&':
      do_match:
      paren = RX_BUFF_IDX_FULLMATCH;
      goto maybegetparen;
    case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      paren = atoi(mg->mg_ptr);
    maybegetparen:
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
      getparen:
        i = CALLREG_NUMBUF_LENGTH((REGEXP * const)rx, sv, paren);

		if (i < 0)
		    Perl_croak(aTHX_ "panic: magic_len: %"IVdf, (IV)i);
		return i;
	} else {
		if (ckWARN(WARN_UNINITIALIZED))
		    report_uninit(sv);
		return 0;
	}
    case '+':
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    paren = RX_LASTPAREN(rx);
	    if (paren)
		goto getparen;
	}
	return 0;
    case '\016': /* ^N */
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    paren = RX_LASTCLOSEPAREN(rx);
	    if (paren)
		goto getparen;
	}
	return 0;
    }
    magic_get(sv,mg);
    if (!SvPOK(sv) && SvNIOK(sv)) {
	sv_2pv(sv, 0);
    }
    if (SvPOK(sv))
	return SvCUR(sv);
    return 0;
}

d725 5
d734 3
a736 3
    register I32 paren;
    register const char *s = NULL;
    register REGEXP *rx;
d744 2
a745 1
	sv_setsv(sv, PL_bodytarget);
a764 2
#	          include <descrip.h>
#	          include <starlet.h>
d826 14
d853 3
a855 1
	    goto do_prematch_fetch;
d857 2
a858 1
	    goto do_postmatch_fetch;
d880 2
a881 2
            sv_setiv(sv, PL_tainting
		    ? (PL_taint_warn || PL_unsafe ? -1 : 1)
d906 6
a911 9
		HV * const bits=get_hv("warnings::Bits", 0);
		if (bits) {
		    SV ** const bits_all = hv_fetchs(bits, "all", FALSE);
		    if (bits_all)
			sv_setsv(sv, *bits_all);
		}
	        else {
		    sv_setpvn(sv, WARN_ALLstring, WARNsize) ;
		}
a916 1
	    SvPOK_only(sv);
d921 4
d927 11
a937 11
	    if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
		/*
		 * Pre-threads, this was paren = atoi(GvENAME((const GV *)mg->mg_obj));
		 * XXX Does the new way break anything?
		 */
		paren = atoi(mg->mg_ptr); /* $& is in [0] */
		CALLREG_NUMBUF_FETCH(rx,paren,sv);
		break;
	    }
	    sv_setsv(sv,&PL_sv_undef);
	}
d941 3
a943 4
	    if (RX_LASTPAREN(rx)) {
	        CALLREG_NUMBUF_FETCH(rx,RX_LASTPAREN(rx),sv);
	        break;
	    }
d949 3
a951 5
	    if (RX_LASTCLOSEPAREN(rx)) {
	        CALLREG_NUMBUF_FETCH(rx,RX_LASTCLOSEPAREN(rx),sv);
	        break;
	    }

d956 2
a957 7
      do_prematch_fetch:
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    CALLREG_NUMBUF_FETCH(rx,-2,sv);
	    break;
	}
	sv_setsv(sv,&PL_sv_undef);
	break;
d959 2
a960 7
      do_postmatch_fetch:
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    CALLREG_NUMBUF_FETCH(rx,-1,sv);
	    break;
	}
	sv_setsv(sv,&PL_sv_undef);
	break;
d1019 2
a1048 2
	if (SvPOKp(sv))
	    SvPOK_on(sv);    /* may have got removed during taint processing */
d1103 2
a1104 3
    const char *s = SvOK(sv) ? SvPV_const(sv,len) : "";
    const char * const ptr = MgPV_const(mg,klen);
    my_setenv(ptr, s);
d1108 15
d1127 1
a1127 1
	SV ** const valp = hv_fetch(GvHVn(PL_envgv), ptr, klen, FALSE);
d1136 1
a1136 1
    if (PL_tainting) {
d1139 1
a1139 1
	if (s && klen == 8 && strEQ(ptr, "DCL$PATH")) {
d1165 1
a1165 1
	if (s && klen == 4 && strEQ(ptr,"PATH")) {
d1452 1
a1452 1
    register const char *s = MgPV_const(mg,len);
a1648 12
Perl_magic_setamagic(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    PERL_ARGS_ASSERT_MAGIC_SETAMAGIC;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
    PL_amagic_generation++;

    return 0;
}

int
d1836 1
a1836 1
    if (PL_tainting && (tmg = mg_find(sv, PERL_MAGIC_taint))
d1954 3
d1962 3
d2004 19
d2079 1
d2102 1
a2102 1
    len = SvPOK(lsv) ? SvCUR(lsv) : sv_len(lsv);
d2107 1
a2107 1
	ulen = sv_len_utf8(lsv);
d2121 1
a2121 3
	I32 p = pos;
	sv_pos_u2b(lsv, &p, 0);
	pos = p;
d2145 1
a2145 1
	    SvUTF8(lsv) ? sv_len_utf8(lsv) : len,
d2155 1
a2155 1
	offs = sv_pos_u2b_flags(lsv, offs, &rem, SV_CONST_RETURN);
d2182 2
a2183 2
    if (SvUTF8(lsv)) lsv_len = sv_len_utf8(lsv);
    else (void)SvPV_nomg(lsv,lsv_len);
d2192 1
a2192 1
	sv_utf8_upgrade(lsv);
d2195 1
a2195 1
	newtarglen = sv_len_utf8(sv);
d2198 1
a2198 1
    else if (lsv && SvUTF8(lsv)) {
d2223 3
d2240 1
a2240 1
    if (PL_tainted)
a2272 13
Perl_magic_setvstring(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETVSTRING;

    if (SvPOKp(sv)) {
	SV * const vecsv = sv_newmortal();
	scan_vstring(mg->mg_ptr, mg->mg_ptr + mg->mg_len, vecsv);
	if (sv_eq_flags(vecsv, sv, 0 /*nomg*/)) return 0;
    }
    return sv_unmagic(sv, mg->mg_type);
}

int
a2400 3
    } else if (type == PERL_MAGIC_study) {
	if (!isGV_with_GP(sv))
	    SvSCREAM_off(sv);
d2445 3
a2447 3
    register const char *s;
    register I32 paren;
    register const REGEXP * rx;
d2476 1
d2482 1
d2484 1
a2484 1
                Perl_croak_no_modify(aTHX);
d2489 2
a2490 1
	sv_setsv(PL_bodytarget, sv);
d2500 1
a2500 1
	if (PL_tainting) {
d2558 4
d2723 1
a2723 1
	if (SvOK(sv) || SvGMAGICAL(sv)) {
d3022 1
a3022 1
    register char* const* sigv;
d3062 1
d3141 2
d3146 4
a3149 1
    if (SvTRUE(ERRSV)) {
d3157 1
a3157 1
       if (sip || uap)
d3159 6
a3164 6
	{
	    sigset_t set;
	    sigemptyset(&set);
	    sigaddset(&set,sig);
	    sigprocmask(SIG_UNBLOCK, &set, NULL);
	}
d3166 3
a3168 3
	/* Not clear if this will work */
	(void)rsignal(sig, SIG_IGN);
	(void)rsignal(sig, PL_csighandlerp);
d3171 6
a3176 1
	die_sv(ERRSV);
d3178 1
d3203 2
a3204 2
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv))
    {
a3210 1

a3216 10
	if (SvGMAGICAL(sv)) {
	    /* downgrade public flags to private,
	       and discard any other private flags */

	    const U32 pubflags = SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK);
	    if (pubflags) {
		SvFLAGS(sv) &= ~( pubflags | (SVp_IOK|SVp_NOK|SVp_POK) );
		SvFLAGS(sv) |= ( pubflags << PRIVSHIFT );
	    }
	}
a3244 1
	    int was_temp = SvTEMP(sv);
d3246 1
a3246 4
	    if (!was_temp) {
		SvTEMP_off(sv);
	    }
	    SvOK_off(sv);
a3315 4
    assert(mg->mg_len == HEf_SVKEY);

    PERL_UNUSED_ARG(sv);

d3318 5
a3322 2
	cophh_delete_sv(CopHINTHASH_get(&PL_compiling),
				 MUTABLE_SV(mg->mg_ptr), 0, 0));
d3344 20
d3368 1
a3368 1
 * indent-tabs-mode: t
d3371 1
a3371 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.16
log
@merge in perl 5.12.2 plus local changes
@
text
@d60 4
d87 1
d96 1
d100 11
d124 1
a166 34

/* is this container magic (%ENV, $1 etc), or value magic (pos, taint etc)? */

STATIC bool
S_is_container_magic(const MAGIC *mg)
{
    assert(mg);
    switch (mg->mg_type) {
    case PERL_MAGIC_bm:
    case PERL_MAGIC_fm:
    case PERL_MAGIC_regex_global:
    case PERL_MAGIC_nkeys:
#ifdef USE_LOCALE_COLLATE
    case PERL_MAGIC_collxfrm:
#endif
    case PERL_MAGIC_qr:
    case PERL_MAGIC_taint:
    case PERL_MAGIC_vec:
    case PERL_MAGIC_vstring:
    case PERL_MAGIC_utf8:
    case PERL_MAGIC_substr:
    case PERL_MAGIC_defelem:
    case PERL_MAGIC_arylen:
    case PERL_MAGIC_pos:
    case PERL_MAGIC_backref:
    case PERL_MAGIC_arylen_p:
    case PERL_MAGIC_rhash:
    case PERL_MAGIC_symtab:
	return 0;
    default:
	return 1;
    }
}

d170 1
a170 1
Do magic after a value is retrieved from the SV.  See C<sv_magic>.
a179 1
    const bool was_temp = (bool)SvTEMP(sv);
a181 2
    /* guard against sv having being freed midway by holding a private
       reference. */
d185 1
a185 8
    /* sv_2mortal has this side effect of turning on the TEMP flag, which can
       cause the SV's buffer to get stolen (and maybe other stuff).
       So restore it.
    */
    sv_2mortal(SvREFCNT_inc_simple_NN(sv));
    if (!was_temp) {
	SvTEMP_off(sv);
    }
d199 1
a199 1
	    CALL_FPTR(vtbl->svt_get)(aTHX_ sv, mg);
a234 6

    if (SvREFCNT(sv) == 1) {
	/* We hold the last reference to this SV, which implies that the
	   SV was deleted as a side effect of the routines we called.  */
	SvOK_off(sv);
    }
d256 2
d267 2
a268 1
	if (PL_localizing == 2 && !S_is_container_magic(mg))
d271 1
a271 1
	    CALL_FPTR(vtbl->svt_set)(aTHX_ sv, mg);
d301 1
a301 1
	    len = CALL_FPTR(vtbl->svt_len)(aTHX_ sv, mg);
d333 1
a333 1
	    len = CALL_FPTR(vtbl->svt_len)(aTHX_ sv, mg);
d377 1
a377 1
	    CALL_FPTR(vtbl->svt_clear)(aTHX_ sv, mg);
d384 20
d415 16
a430 9
    PERL_UNUSED_CONTEXT;
    if (sv) {
        MAGIC *mg;
        for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
            if (mg->mg_type == type)
                return mg;
        }
    }
    return NULL;
d452 1
a452 1
	    count += CALL_FPTR(vtbl->svt_copy)(aTHX_ sv, mg, nsv, key, klen);
d493 3
d498 1
a498 1
	if (!S_is_container_magic(mg))
d502 1
a502 1
	    (void)CALL_FPTR(vtbl->svt_local)(aTHX_ nsv, mg);
d508 1
a508 1
	SvFLAGS(nsv) |= SvREADONLY(sv);
d521 18
a555 1
        const MGVTBL* const vtbl = mg->mg_virtual;
d557 1
a557 11
	if (vtbl && vtbl->svt_free)
	    CALL_FPTR(vtbl->svt_free)(aTHX_ sv, mg);
	if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
	    if (mg->mg_len > 0 || mg->mg_type == PERL_MAGIC_utf8)
		Safefree(mg->mg_ptr);
	    else if (mg->mg_len == HEf_SVKEY)
		SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
	}
	if (mg->mg_flags & MGf_REFCOUNTED)
	    SvREFCNT_dec(mg->mg_obj);
	Safefree(mg);
d565 33
d674 1
a674 1
    Perl_croak(aTHX_ "%s", PL_no_modify);
d779 1
a779 3
	    SV *const value = Perl_refcounted_he_fetch(aTHX_
						       c->cop_hints_hash,
						       0, "open<", 5, 0, 0);
d785 1
a785 3
	    SV *const value = Perl_refcounted_he_fetch(aTHX_
						       c->cop_hints_hash,
						       0, "open>", 5, 0, 0);
d797 1
a797 1
    register char *s = NULL;
d807 2
d877 6
d898 1
a898 1
    case '\020':		
d946 2
a947 5
		sv_setpvn(
		    sv, 
		    (PL_dowarn & G_WARN_ON) ? WARN_ALLstring : WARN_NONEstring,
		    WARNsize
		);
d1037 1
a1037 1
	    s = IoTOP_NAME(GvIOp(PL_defoutgv));
d1053 1
a1053 1
	if (GvIOp(PL_defoutgv))
d1057 1
a1057 1
	if (GvIOp(PL_defoutgv))
d1061 1
a1061 1
	if (GvIOp(PL_defoutgv))
d1069 1
a1069 1
	sv_setiv(sv, (IV)CopARYBASE_get(PL_curcop));
d1072 1
a1072 1
	if (GvIOp(PL_defoutgv))
d1079 13
d1115 1
a1115 1
	sv_setiv(sv, (IV)PL_uid);
d1118 1
a1118 1
	sv_setiv(sv, (IV)PL_euid);
d1121 1
a1121 1
	sv_setiv(sv, (IV)PL_gid);
d1124 1
a1124 1
	sv_setiv(sv, (IV)PL_egid);
a1185 1
	    Stat_t sbuf;
d1309 3
a1311 1
	mg->mg_private = i = whichsig(MgPV_nolen_const(mg));
a1341 1
    PERL_UNUSED_ARG(sv);
d1426 8
d1442 23
a1464 1
	    PERL_BLOCKSIG_ADD(set, sig);
a1465 1
	    PERL_BLOCKSIG_BLOCK(set);
d1471 5
a1475 1
	    PERL_BLOCKSIG_UNBLOCK(set);
d1502 1
a1502 1
	if (strEQ(s,"__DIE__"))
d1504 1
a1504 1
	else if (strEQ(s,"__WARN__")
d1512 5
a1516 2
	} else if (sv)
	    Perl_croak(aTHX_ "No such hook: %s", s);
d1527 1
a1527 1
	    i = whichsig(s);	/* ...no, a brick */
d1531 5
a1535 2
	    if (sv)
		Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL), "No such signal: SIG%s", s);
d1591 1
a1591 1
	if (sv && strEQ(s,"IGNORE")) {
d1601 1
a1601 1
	else if (!sv || strEQ(s,"DEFAULT") || !len) {
d1644 1
a1644 1
    if (PL_delaymagic & DM_ARRAY && mg->mg_type == PERL_MAGIC_isaelem)
d1660 1
a1660 1
    if(PL_dirty) return 0;
d1665 16
a1680 8
    /* XXX Once it's possible, we need to
       detect that our @@ISA is aliased in
       other stashes, and act on the stashes
       of all of the aliases */

    /* The first case occurs via setisa,
       the second via setisa_elem, which
       calls this same magic */
d1682 1
a1682 3
        SvTYPE(mg->mg_obj) == SVt_PVGV
            ? (const GV *)mg->mg_obj
            : (const GV *)mg_find(mg->mg_obj, PERL_MAGIC_isa)->mg_obj
d1685 3
a1687 1
    if (stash)
d1717 1
a1717 1
	     i = HvKEYS(hv);
d1739 29
a1767 3
/* caller is responsible for stack switching/cleanup */
STATIC int
S_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, const char *meth, I32 flags, int n, SV *val)
d1771 1
d1775 11
d1787 2
a1788 1
    EXTEND(SP, n);
d1790 45
a1834 9
    if (n > 1) {
	if (mg->mg_ptr) {
	    if (mg->mg_len >= 0)
		mPUSHp(mg->mg_ptr, mg->mg_len);
	    else if (mg->mg_len == HEf_SVKEY)
		PUSHs(MUTABLE_SV(mg->mg_ptr));
	}
	else if (mg->mg_type == PERL_MAGIC_tiedelem) {
	    mPUSHi(mg->mg_len);
d1836 6
d1843 2
a1844 2
    if (n > 2) {
	PUSHs(val);
d1846 1
a1846 3
    PUTBACK;

    return call_method(meth, flags);
d1852 2
a1853 1
    dVAR; dSP;
d1857 3
a1859 11
    ENTER;
    SAVETMPS;
    PUSHSTACKi(PERLSI_MAGIC);

    if (magic_methcall(sv, mg, meth, G_SCALAR, 2, NULL)) {
	sv_setsv(sv, *PL_stack_sp--);
    }

    POPSTACK;
    FREETMPS;
    LEAVE;
d1868 1
a1868 1
    if (mg->mg_ptr)
d1877 3
a1879 1
    dVAR; dSP;
d1883 20
a1902 5
    ENTER;
    PUSHSTACKi(PERLSI_MAGIC);
    magic_methcall(sv, mg, "STORE", G_SCALAR|G_DISCARD, 3, sv);
    POPSTACK;
    LEAVE;
d1911 1
d1919 1
a1919 1
    dVAR; dSP;
d1921 1
d1925 3
a1927 6
    ENTER;
    SAVETMPS;
    PUSHSTACKi(PERLSI_MAGIC);
    if (magic_methcall(sv, mg, "FETCHSIZE", G_SCALAR, 2, NULL)) {
	sv = *PL_stack_sp--;
	retval = SvIV(sv)-1;
a1930 3
    POPSTACK;
    FREETMPS;
    LEAVE;
d1937 1
a1937 1
    dVAR; dSP;
d1941 1
a1941 9
    ENTER;
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    XPUSHs(SvTIED_obj(sv, mg));
    PUTBACK;
    call_method("CLEAR", G_SCALAR|G_DISCARD);
    POPSTACK;
    LEAVE;

d1948 2
a1949 2
    dVAR; dSP;
    const char * const meth = SvOK(key) ? "NEXTKEY" : "FIRSTKEY";
d1953 4
a1956 16
    ENTER;
    SAVETMPS;
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    EXTEND(SP, 2);
    PUSHs(SvTIED_obj(sv, mg));
    if (SvOK(key))
	PUSHs(key);
    PUTBACK;

    if (call_method(meth, G_SCALAR))
	sv_setsv(key, *PL_stack_sp--);

    POPSTACK;
    FREETMPS;
    LEAVE;
d1971 1
a1971 1
    dVAR; dSP;
d1991 2
a1992 10
    ENTER;
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    EXTEND(SP, 1);
    PUSHs(tied);
    PUTBACK;

    if (call_method("SCALAR", G_SCALAR))
        retval = *PL_stack_sp--; 
    else
a1993 2
    POPSTACK;
    LEAVE;
d2030 1
a2030 1
	sv_setiv(sv, AvFILL(obj) + CopARYBASE_get(PL_curcop));
d2046 1
a2046 1
	av_fill(obj, SvIV(sv) - CopARYBASE_get(PL_curcop));
d2094 1
a2094 1
	    sv_setiv(sv, i + CopARYBASE_get(PL_curcop));
d2135 1
a2135 1
    pos = SvIV(sv) - CopARYBASE_get(PL_curcop);
d2171 2
d2177 10
a2188 4
    if (offs > len)
	offs = len;
    if (rem > len - offs)
	rem = len - offs;
d2199 1
a2199 1
    STRLEN len;
d2204 2
d2210 14
d2227 2
a2228 2
	sv_insert(lsv, lvoff, lvlen, tmps, len);
	LvTARGLEN(sv) = sv_len_utf8(sv);
d2234 1
a2234 1
	LvTARGLEN(sv) = len;
d2236 1
a2236 1
	sv_insert(lsv, lvoff, lvlen, utf8, len);
d2240 2
a2241 2
	sv_insert(lsv, lvoff, lvlen, tmps, len);
	LvTARGLEN(sv) = len;
d2243 2
d2303 13
d2407 2
a2408 1
    return Perl_sv_kill_backrefs(aTHX_ sv, MUTABLE_AV(mg->mg_obj));
d2416 1
a2417 2
    if (!isGV_with_GP(sv))
	SvSCREAM_off(sv);
d2444 3
a2448 1
	SvCOMPILED_off(sv);
d2497 1
a2522 1
            break;
d2528 1
a2528 1
                Perl_croak(aTHX_ "%s", PL_no_modify);
d2531 1
d2534 15
d2551 1
a2551 1
	PL_minus_c = (bool)SvIV(sv);
d2645 1
d2668 2
a2669 3
		if (!SvPOK(sv) && PL_localizing) {
	            sv_setpvn(sv, WARN_NONEstring, WARNsize);
	            PL_compiling.cop_warnings = pWARN_NONE;
d2734 1
a2734 1
	    IoLINES_LEFT(GvIOp(PL_defoutgv)) = 0L;
d2741 1
a2741 1
	    IO * const io = GvIOp(PL_defoutgv);
d2770 2
a2771 1
	CopARYBASE_set(&PL_compiling, SvIV(sv));
d2801 3
a2803 1
	PL_uid = SvIV(sv);
d2809 1
a2809 1
	(void)setruid((Uid_t)PL_uid);
d2812 1
a2812 1
	(void)setreuid((Uid_t)PL_uid, (Uid_t)-1);
d2815 1
a2815 1
      (void)setresuid((Uid_t)PL_uid, (Uid_t)-1, (Uid_t)-1);
d2817 1
a2817 1
	if (PL_uid == PL_euid) {		/* special case $< = $> */
d2820 1
a2820 1
	    if (PL_uid != 0 && PerlProc_getuid() == 0)
d2823 1
a2823 1
	    (void)PerlProc_setuid(PL_uid);
a2824 1
	    PL_uid = PerlProc_getuid();
a2829 2
	PL_uid = PerlProc_getuid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d2831 1
d2833 3
a2835 1
	PL_euid = SvIV(sv);
d2841 1
a2841 1
	(void)seteuid((Uid_t)PL_euid);
d2844 1
a2844 1
	(void)setreuid((Uid_t)-1, (Uid_t)PL_euid);
d2847 1
a2847 1
	(void)setresuid((Uid_t)-1, (Uid_t)PL_euid, (Uid_t)-1);
d2849 2
a2850 2
	if (PL_euid == PL_uid)		/* special case $> = $< */
	    PerlProc_setuid(PL_euid);
a2851 1
	    PL_euid = PerlProc_geteuid();
a2856 2
	PL_euid = PerlProc_geteuid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d2858 1
d2860 3
a2862 1
	PL_gid = SvIV(sv);
d2868 1
a2868 1
	(void)setrgid((Gid_t)PL_gid);
d2871 1
a2871 1
	(void)setregid((Gid_t)PL_gid, (Gid_t)-1);
d2874 1
a2874 1
      (void)setresgid((Gid_t)PL_gid, (Gid_t)-1, (Gid_t) 1);
d2876 2
a2877 2
	if (PL_gid == PL_egid)			/* special case $( = $) */
	    (void)PerlProc_setgid(PL_gid);
a2878 1
	    PL_gid = PerlProc_getgid();
a2883 2
	PL_gid = PerlProc_getgid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d2885 1
d2887 2
d2904 1
a2904 1
            PL_egid = Atol(p);
d2923 1
a2923 1
	PL_egid = SvIV(sv);
d2925 1
d2931 1
a2931 1
	(void)setegid((Gid_t)PL_egid);
d2934 1
a2934 1
	(void)setregid((Gid_t)-1, (Gid_t)PL_egid);
d2937 1
a2937 1
	(void)setresgid((Gid_t)-1, (Gid_t)PL_egid, (Gid_t)-1);
d2939 2
a2940 2
	if (PL_egid == PL_gid)			/* special case $) = $( */
	    (void)PerlProc_setgid(PL_egid);
a2941 1
	    PL_egid = PerlProc_getegid();
a2946 2
	PL_egid = PerlProc_getegid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d2948 1
d2952 11
d3024 7
d3040 20
a3059 1
Perl_whichsig(pTHX_ const char *sig)
d3063 1
a3063 1
    PERL_ARGS_ASSERT_WHICHSIG;
d3067 1
a3067 1
	if (strEQ(sig,*sigv))
d3070 1
a3070 1
    if (strEQ(sig,"CHLD"))
d3074 1
a3074 1
    if (strEQ(sig,"CLD"))
d3082 1
a3082 1
Perl_sighandler(int sig, siginfo_t *sip, void *uap PERL_UNUSED_DECL)
d3100 1
a3101 6
    if (PL_savestack_ix + 15 <= PL_savestack_max)
	flags |= 1;
    if (PL_markstack_ptr < PL_markstack_max - 2)
	flags |= 4;
    if (PL_scopestack_ix < PL_scopestack_max - 3)
	flags |= 16;
d3109 9
a3117 10
    /* Max number of items pushed there is 3*n or 4. We cannot fix
       infinity, so we fix 4 (in fact 5): */
    if (flags & 1) {
	PL_savestack_ix += 5;		/* Protect save in progress. */
	SAVEDESTRUCTOR_X(S_unwind_handler_stack, (void*)&flags);
    }
    if (flags & 4)
	PL_markstack_ptr++;		/* Protect mark. */
    if (flags & 16)
	PL_scopestack_ix += 1;
d3134 10
a3143 9
    if(PL_psig_name[sig]) {
	sv = SvREFCNT_inc_NN(PL_psig_name[sig]);
	flags |= 64;
#if !defined(PERL_IMPLICIT_CONTEXT)
	PL_sig_sv = sv;
#endif
    } else {
	sv = sv_newmortal();
	sv_setpv(sv,PL_sig_name[sig]);
a3183 1
#ifdef HAS_SIGPROCMASK
d3188 10
a3197 4
	sigset_t set;
	sigemptyset(&set);
	sigaddset(&set,sig);
	sigprocmask(SIG_UNBLOCK, &set, NULL);
d3204 1
a3204 1
	Perl_die(aTHX_ NULL);
d3207 3
a3209 7
    if (flags & 1)
	PL_savestack_ix -= 8; /* Unprotect save in progress. */
    if (flags & 4)
	PL_markstack_ptr--;
    if (flags & 16)
	PL_scopestack_ix -= 1;
    if (flags & 64)
d3225 1
d3257 1
d3269 1
a3269 1
	I32 popval = SSPOPINT;
d3272 20
a3291 4
	popval = SSPOPINT;
        assert(popval == SAVEt_ALLOC);
	popval = SSPOPINT;
        PL_savestack_ix -= popval;
d3293 1
d3295 4
a3298 1
}
d3304 1
a3304 3
    const U32 flags = *(const U32*)p;

    PERL_ARGS_ASSERT_UNWIND_HANDLER_STACK;
d3306 1
a3306 6
    if (flags & 1)
	PL_savestack_ix -= 5; /* Unprotect save in progress. */
#if !defined(PERL_IMPLICIT_CONTEXT)
    if (flags & 64)
	SvREFCNT_dec(PL_sig_sv);
#endif
d3337 2
a3338 2
    PL_compiling.cop_hints_hash
	= Perl_refcounted_he_new(aTHX_ PL_compiling.cop_hints_hash, key, sv);
d3363 3
a3365 3
    PL_compiling.cop_hints_hash
	= Perl_refcounted_he_new(aTHX_ PL_compiling.cop_hints_hash,
				 MUTABLE_SV(mg->mg_ptr), &PL_sv_placeholder);
d3382 2
a3383 4
    if (PL_compiling.cop_hints_hash) {
	Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
	PL_compiling.cop_hints_hash = NULL;
    }
@


1.15
log
@Merge in perl 5.10.1
@
text
@a79 1
    U32 mgs_flags;
d81 2
d104 2
a105 1
    mgs->mgs_flags = SvMAGICAL(sv) | SvREADONLY(sv);
d130 2
a132 1
	SvRMAGICAL_off(sv);
d197 1
a197 1
    int have_new = 0;
d222 1
d229 2
a230 1
	    if (!SvMAGIC(sv))
d232 1
d234 1
a234 1
	    /* Don't restore the flags for this entry if it was deleted. */
d236 1
a236 1
		(SSPTR(mgs_ix, MGS *))->mgs_flags = 0;
d239 1
a239 1
	mg = mg->mg_moremagic;
d256 1
d295 1
a295 1
	    (SSPTR(mgs_ix, MGS*))->mgs_flags = 0;
d393 1
d399 1
a399 1
    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
d403 2
d476 7
a482 3
Copy some of the magic from an existing SV to new localized version of
that SV. Container magic (eg %ENV, $1, tie) gets copied, value magic
doesn't (eg taint, pos).
d488 1
a488 1
Perl_mg_localize(pTHX_ SV *sv, SV *nsv)
d512 5
a516 3
	PL_localizing = 1;
	SvSETMAGIC(nsv);
	PL_localizing = 0;
d785 1
a785 8
#if defined(MACOS_TRADITIONAL)
	     {
		  char msg[256];

		  sv_setnv(sv,(double)gMacPerl_OSErr);
		  sv_setpv(sv, gMacPerl_OSErr ? GetSysErrText(gMacPerl_OSErr, msg) : "");
	     }
#elif defined(VMS)
a1032 2
    case ',':
	break;
d1038 2
a1041 1
	sv_setpv(sv, errno ? Strerror(errno) : "");
a1042 2
	{
	dSAVE_ERRNO;
d1044 1
d1051 2
d1055 1
a1055 1
#endif
a1083 1
#ifndef MACOS_TRADITIONAL
a1085 1
#endif
d1250 1
a1250 1
    const I32 i = whichsig(MgPV_nolen_const(mg));
d1254 4
a1284 5
    /* XXX Some of this code was copied from Perl_magic_setsig. A little
     * refactoring might be in order.
     */
    dVAR;
    register const char * const s = MgPV_nolen_const(mg);
d1287 3
a1289 53
    if (*s == '_') {
	SV** svp = NULL;
	if (strEQ(s,"__DIE__"))
	    svp = &PL_diehook;
	else if (strEQ(s,"__WARN__") && PL_warnhook != PERL_WARNHOOK_FATAL)
	    svp = &PL_warnhook;
	if (svp && *svp) {
	    SV *const to_dec = *svp;
	    *svp = NULL;
	    SvREFCNT_dec(to_dec);
	}
    }
    else {
	/* Are we clearing a signal entry? */
	const I32 i = whichsig(s);
	if (i > 0) {
#ifdef HAS_SIGPROCMASK
	    sigset_t set, save;
	    SV* save_sv;
	    /* Avoid having the signal arrive at a bad time, if possible. */
	    sigemptyset(&set);
	    sigaddset(&set,i);
	    sigprocmask(SIG_BLOCK, &set, &save);
	    ENTER;
	    save_sv = newSVpvn((char *)(&save), sizeof(sigset_t));
	    SAVEFREESV(save_sv);
	    SAVEDESTRUCTOR_X(restore_sigmask, save_sv);
#endif
	    PERL_ASYNC_CHECK();
#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS) || defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
	    if (!PL_sig_handlers_initted) Perl_csighandler_init();
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
	    PL_sig_defaulting[i] = 1;
	    (void)rsignal(i, PL_csighandlerp);
#else
	    (void)rsignal(i, (Sighandler_t) SIG_DFL);
#endif
    	    if(PL_psig_name[i]) {
    		SvREFCNT_dec(PL_psig_name[i]);
    		PL_psig_name[i]=0;
    	    }
    	    if(PL_psig_ptr[i]) {
		SV * const to_dec=PL_psig_ptr[i];
    		PL_psig_ptr[i]=0;
		LEAVE;
    		SvREFCNT_dec(to_dec);
    	    }
	    else
		LEAVE;
	}
    }
    return 0;
d1328 1
a1328 1
	 * with risk we may be in malloc() etc. */
d1335 1
d1343 1
a1343 1
	/* And one to say _a_ signal is pending */
d1392 1
d1416 7
a1422 1
	else if (strEQ(s,"__WARN__"))
d1424 1
a1424 1
	else
d1427 1
a1427 1
	if (*svp) {
d1434 5
a1438 1
	i = whichsig(s);	/* ...no, a brick */
d1440 2
a1441 2
	    if (ckWARN(WARN_SIGNAL))
		Perl_warner(aTHX_ packWARN(WARN_SIGNAL), "No such signal: SIG%s", s);
a1463 1
	SvREFCNT_dec(PL_psig_name[i]);
d1465 19
a1483 4
	PL_psig_ptr[i] = SvREFCNT_inc_simple_NN(sv);
	SvTEMP_off(sv); /* Make sure it doesn't go away on us */
	PL_psig_name[i] = newSVpvn(s, len);
	SvREADONLY_on(PL_psig_name[i]);
d1485 1
a1485 1
    if (isGV_with_GP(sv) || SvROK(sv)) {
a1487 3
#ifdef HAS_SIGPROCMASK
	    LEAVE;
#endif
d1491 8
a1498 7
	if(to_dec)
	    SvREFCNT_dec(to_dec);
	return 0;
    }
    s = SvOK(sv) ? SvPV_force(sv,len) : "DEFAULT";
    if (strEQ(s,"IGNORE")) {
	if (i) {
d1500 2
a1501 2
	    PL_sig_ignoring[i] = 1;
	    (void)rsignal(i, PL_csighandlerp);
d1503 1
a1503 1
	    (void)rsignal(i, (Sighandler_t) SIG_IGN);
d1505 1
d1507 2
a1508 3
    }
    else if (strEQ(s,"DEFAULT") || !*s) {
	if (i)
d1510 2
a1511 4
	  {
	    PL_sig_defaulting[i] = 1;
	    (void)rsignal(i, PL_csighandlerp);
	  }
d1513 1
a1513 1
	    (void)rsignal(i, (Sighandler_t) SIG_DFL);
d1515 16
d1532 1
a1532 14
    else {
	/*
	 * We should warn if HINT_STRICT_REFS, but without
	 * access to a known hint bit in a known OP, we can't
	 * tell whether HINT_STRICT_REFS is in force or not.
	 */
	if (!strchr(s,':') && !strchr(s,'\''))
	    Perl_sv_insert_flags(aTHX_ sv, 0, 0, STR_WITH_LEN("main::"),
				 SV_GMAGIC);
	if (i)
	    (void)rsignal(i, PL_csighandlerp);
	else
	    *svp = SvREFCNT_inc_simple_NN(sv);
    }
d1537 1
a1537 2
    if(to_dec)
	SvREFCNT_dec(to_dec);
a1545 2
    HV* stash;

a1548 3
    /* Bail out if destruction is going on */
    if(PL_dirty) return 0;

d1553 1
a1553 18
    /* XXX Once it's possible, we need to
       detect that our @@ISA is aliased in
       other stashes, and act on the stashes
       of all of the aliases */

    /* The first case occurs via setisa,
       the second via setisa_elem, which
       calls this same magic */
    stash = GvSTASH(
        SvTYPE(mg->mg_obj) == SVt_PVGV
            ? (const GV *)mg->mg_obj
            : (const GV *)mg_find(mg->mg_obj, PERL_MAGIC_isa)->mg_obj
    );

    if (stash)
	mro_isa_changed_in(stash);

    return 0;
d1556 1
d1568 2
a1569 1
    av_clear(MUTABLE_AV(sv));
d1571 8
a1578 1
    /* XXX see comments in magic_setisa */
d1868 1
a1868 1
    const AV * const obj = MUTABLE_AV(mg->mg_obj);
d1891 2
a1892 3
	if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
			"Attempt to set length of freed array");
d2012 2
a2013 2
    I32 offs = LvTARGOFF(sv);
    I32 rem = LvTARGLEN(sv);
d2019 2
a2020 2
	sv_pos_u2b(lsv, &offs, &rem);
    if (offs > (I32)len)
d2022 1
a2022 1
    if (rem + offs > (I32)len)
d2024 1
a2024 1
    sv_setpvn(sv, tmps + offs, (STRLEN)rem);
d2037 2
a2038 2
    I32 lvoff = LvTARGOFF(sv);
    I32 lvlen = LvTARGLEN(sv);
d2045 1
a2045 1
 	sv_pos_u2b(lsv, &lvoff, &lvlen);
d2052 1
a2052 1
	sv_pos_u2b(lsv, &lvoff, &lvlen);
a2062 1

d2220 2
a2221 1
    SvSCREAM_off(sv);
a2254 11
int
Perl_magic_freeregexp(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    regexp * const re = (regexp *)mg->mg_obj;
    PERL_UNUSED_ARG(sv);

    ReREFCNT_dec(re);
    return 0;
}

d2344 2
a2345 1
	DEBUG_x(dump_all());
d2352 2
a2353 2
#ifdef MACOS_TRADITIONAL
	    gMacPerl_OSErr = SvIV(sv);
d2355 2
a2356 2
#  ifdef VMS
	    set_vaxc_errno(SvIV(sv));
d2358 2
a2359 2
#    ifdef WIN32
	    SetLastError( SvIV(sv) );
a2360 3
#      ifdef OS2
	    os2_setsyserrno(SvIV(sv));
#      else
a2362 1
#      endif
d2368 1
a2368 2
	    if (PL_encoding)
		SvREFCNT_dec(PL_encoding);
a2400 1
	    struct refcounted_he *tmp_he;
d2404 1
a2404 2
	    PL_hints
		|= HINT_LOCALIZE_HH | HINT_LEXICAL_IO_IN | HINT_LEXICAL_IO_OUT;
d2409 9
a2417 15
				       SVs_TEMP | SvUTF8(sv))
		: newSVpvs_flags("", SVs_TEMP | SvUTF8(sv));

	    tmp_he
		= Perl_refcounted_he_new(aTHX_ PL_compiling.cop_hints_hash, 
					 newSVpvs_flags("open>", SVs_TEMP),
					 tmp);

	    /* The UTF-8 setting is carried over  */
	    sv_setpvn(tmp, start, out ? (STRLEN)(out - start) : len);

	    PL_compiling.cop_hints_hash
		= Perl_refcounted_he_new(aTHX_ tmp_he,
					 newSVpvs_flags("open<", SVs_TEMP),
					 tmp);
d2547 1
a2547 2
	if (PL_ors_sv)
	    SvREFCNT_dec(PL_ors_sv);
a2554 10
    case ',':
	if (PL_ofs_sv)
	    SvREFCNT_dec(PL_ofs_sv);
	if (SvOK(sv) || SvGMAGICAL(sv)) {
	    PL_ofs_sv = newSVsv(sv);
	}
	else {
	    PL_ofs_sv = NULL;
	}
	break;
d2676 8
d2688 1
a2688 1
            for (i = 0; i < NGROUPS; ++i) {
a2735 1
#ifndef MACOS_TRADITIONAL
a2800 1
#endif
d2879 5
a2883 6
	if (ckWARN(WARN_SIGNAL))
	    Perl_warner(aTHX_ packWARN(WARN_SIGNAL), "SIG%s handler \"%s\" not defined.\n",
		PL_sig_name[sig], (gv ? GvENAME(gv)
				: ((cv && CvGV(cv))
				   ? GvENAME(CvGV(cv))
				   : "__ANON__")));
d2989 4
a2992 2
	if (mgs->mgs_flags)
	    SvFLAGS(sv) |= mgs->mgs_flags;
d3102 20
@


1.14
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 4
a15 2
 * "Sam sat on the ground and put his head in his hands.  'I wish I had never
 * come here, and I don't want to see no more magic,' he said, and fell silent."
d90 3
d126 1
d128 15
a142 10
    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	const MGVTBL* const vtbl = mg->mg_virtual;
	if (vtbl) {
	    if (vtbl->svt_get && !(mg->mg_flags & MGf_GSKIP))
		SvGMAGICAL_on(sv);
	    if (vtbl->svt_set)
		SvSMAGICAL_on(sv);
	    if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)) || vtbl->svt_clear)
		SvRMAGICAL_on(sv);
	}
d152 1
d199 2
d279 2
d315 2
d329 3
a331 1
    if (DO_UTF8(sv)) {
d333 4
a336 1
	len = utf8_length(s, s + len);
a337 2
    else
        (void)SvPV_const(sv, len);
d346 2
d363 1
a363 1
	    return AvFILLp((AV *) sv); /* Fallback to non-tied array */
d387 2
d438 3
d478 3
d517 3
d529 1
a529 1
		SvREFCNT_dec((SV*)mg->mg_ptr);
d534 1
d537 1
d549 2
d556 1
a556 1
		return rx->nparens;
d558 1
a558 1
		I32 paren = rx->lastparen;
d562 2
a563 2
			&& (rx->offs[paren].start == -1
			    || rx->offs[paren].end == -1) )
d577 3
d588 3
a590 3
	    if (paren <= (I32)rx->nparens &&
		(s = rx->offs[paren].start) != -1 &&
		(t = rx->offs[paren].end) != -1)
d599 1
a599 1
			const char * const b = rx->subbeg;
d614 1
d617 1
a617 1
    Perl_croak(aTHX_ PL_no_modify);
d630 2
d678 1
a678 1
	    paren = rx->lastparen;
d685 1
a685 1
	    paren = rx->lastcloseparen;
d714 2
d749 2
d786 1
a786 1
		       sv_setpvn(sv,"",0);
d809 1
a809 1
		       sv_setpvn(sv, "", 0);
d814 1
a814 1
		 const int saveerrno = errno;
d817 1
a817 1
		 errno = saveerrno;
d901 1
a901 1
		HV * const bits=get_hv("warnings::Bits", FALSE);
d924 1
a924 1
		 * Pre-threads, this was paren = atoi(GvENAME((GV*)mg->mg_obj));
d936 2
a937 2
	    if (rx->lastparen) {
	        CALLREG_NUMBUF_FETCH(rx,rx->lastparen,sv);
d945 2
a946 2
	    if (rx->lastcloseparen) {
	        CALLREG_NUMBUF_FETCH(rx,rx->lastcloseparen,sv);
d978 1
d1036 1
a1036 1
	const int saveerrno = errno;
d1044 1
a1044 1
	errno = saveerrno;
d1088 2
d1104 2
d1185 1
d1195 1
d1203 2
a1204 2
	hv_iterinit((HV*)sv);
	while ((entry = hv_iternext((HV*)sv))) {
d1207 1
a1207 1
		      SvPV_nolen_const(hv_iterval((HV*)sv, entry)));
d1218 1
d1244 3
d1279 1
a1335 29
/*
 * The signal handling nomenclature has gotten a bit confusing since the advent of
 * safe signals.  S_raise_signal only raises signals by analogy with what the 
 * underlying system's signal mechanism does.  It might be more proper to say that
 * it defers signals that have already been raised and caught.  
 *
 * PL_sig_pending and PL_psig_pend likewise do not track signals that are pending 
 * in the sense of being on the system's signal queue in between raising and delivery.  
 * They are only pending on Perl's deferral list, i.e., they track deferred signals 
 * awaiting delivery after the current Perl opcode completes and say nothing about
 * signals raised but not yet caught in the underlying signal implementation.
 */

#ifndef SIG_PENDING_DIE_COUNT
#  define SIG_PENDING_DIE_COUNT 120
#endif

static void
S_raise_signal(pTHX_ int sig)
{
    dVAR;
    /* Set a flag to say this signal is pending */
    PL_psig_pend[sig]++;
    /* And one to say _a_ signal is pending */
    if (++PL_sig_pending >= SIG_PENDING_DIE_COUNT)
	Perl_croak(aTHX_ "Maximal count of pending signals (%lu) exceeded",
		(unsigned long)SIG_PENDING_DIE_COUNT);
}

a1347 2
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#endif
d1360 1
a1360 3
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#endif
   if (
d1378 13
a1390 2
   else
	S_raise_signal(aTHX_ sig);
d1451 3
a1454 1
    register const char *s = MgPV_const(mg,len);
d1503 1
a1503 1
    if (SvTYPE(sv) == SVt_PVGV || SvROK(sv)) {
d1545 2
a1546 1
	    Perl_sv_insert(aTHX_ sv, 0, 0, STR_WITH_LEN("main::"));
d1567 2
d1588 28
a1615 2
            ? (GV*)mg->mg_obj
            : (GV*)SvMAGIC(mg->mg_obj)->mg_obj
d1618 2
a1619 1
    mro_isa_changed_in(stash);
d1628 1
d1639 1
a1639 1
    HV * const hv = (HV*)LvTARG(sv);
d1641 2
d1647 1
a1647 1
         if (! SvTIED_mg((SV*)hv, PERL_MAGIC_tied))
d1662 1
d1665 1
a1665 1
	hv_ksplit((HV*)LvTARG(sv), SvIV(sv));
d1677 2
d1685 1
a1685 1
		PUSHs(sv_2mortal(newSVpvn(mg->mg_ptr, mg->mg_len)));
d1687 1
a1687 1
		PUSHs((SV*)mg->mg_ptr);
d1690 1
a1690 1
	    PUSHs(sv_2mortal(newSViv(mg->mg_len)));
d1706 2
d1725 2
d1737 3
d1751 2
d1763 2
d1785 2
d1805 2
d1829 2
d1839 2
a1840 2
    SV * const tied = SvTIED_obj((SV*)hv, mg);
    HV * const pkg = SvSTASH((SV*)SvRV(tied));
d1842 2
d1851 1
a1851 1
        magic_nextpack((SV*)hv, mg, key);
d1881 3
d1901 4
a1904 1
    const AV * const obj = (AV*)mg->mg_obj;
d1917 4
a1920 1
    AV * const obj = (AV*)mg->mg_obj;
d1935 2
d1938 1
d1961 2
d1989 1
a2040 24
Perl_magic_setglob(pTHX_ SV *sv, MAGIC *mg)
{
    GV* gv;
    PERL_UNUSED_ARG(mg);

    Perl_croak(aTHX_ "Perl_magic_setglob is dead code?");

    if (!SvOK(sv))
	return 0;
    if (isGV_with_GP(sv)) {
	/* We're actually already a typeglob, so don't need the stuff below.
	 */
	return 0;
    }
    gv =  gv_fetchsv(sv, GV_ADD, SVt_PVGV);
    if (sv == (SV*)gv)
	return 0;
    if (GvGP(sv))
	gp_free((GV*)sv);
    GvGP(sv) = gp_ref(GvGP(gv));
    return 0;
}

int
d2048 2
d2073 2
d2105 2
d2108 1
d2117 2
d2120 1
d2133 2
d2148 1
d2159 3
d2165 1
a2165 1
	    HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, FALSE, 0);
d2170 1
a2170 1
	    AV* const av = (AV*)LvTARG(sv);
d2193 1
d2211 2
d2217 1
a2217 1
	HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, TRUE, 0);
d2224 1
a2224 1
	AV* const av = (AV*)LvTARG(sv);
d2245 2
a2246 1
    return Perl_sv_kill_backrefs(aTHX_ sv, (AV*)mg->mg_obj);
d2252 1
a2259 19
Perl_magic_setbm(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_UNUSED_ARG(mg);
    sv_unmagic(sv, PERL_MAGIC_bm);
    SvTAIL_off(sv);
    SvVALID_off(sv);
    return 0;
}

int
Perl_magic_setfm(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_UNUSED_ARG(mg);
    sv_unmagic(sv, PERL_MAGIC_fm);
    SvCOMPILED_off(sv);
    return 0;
}

int
d2264 2
d2274 13
a2286 3
    PERL_UNUSED_ARG(mg);
    sv_unmagic(sv, PERL_MAGIC_qr);
    return 0;
d2304 2
d2325 1
d2345 2
d2375 1
a2375 1
                Perl_croak(aTHX_ PL_no_modify);
d2459 3
a2461 3
	    tmp = sv_2mortal(out ? newSVpvn(out + 1, start + len - out - 1)
			     : newSVpvs(""));
	    SvFLAGS(tmp) |= SvUTF8(sv);
d2465 2
a2466 1
					 sv_2mortal(newSVpvs("open>")), tmp);
d2473 2
a2474 1
					 sv_2mortal(newSVpvs("open<")), tmp);
d2629 1
d2871 2
d2934 1
a2934 1
    if (!SvROK(PL_psig_ptr[sig]) || !(cv = (CV*)SvRV(PL_psig_ptr[sig]))
d2971 1
a2971 1
		   SV *rv  = newRV_noinc((SV*)sih);
d2985 2
a2986 2
		   PUSHs((SV*)rv);
		   PUSHs(newSVpvn((char *)sip, sizeof(*sip)));
d2994 1
a2994 1
    call_sv((SV*)cv, G_DISCARD|G_EVAL);
d3096 2
d3120 4
a3123 2
    SV *key = (mg->mg_len == HEf_SVKEY) ? (SV *)mg->mg_ptr
	: sv_2mortal(newSVpvn(mg->mg_ptr, mg->mg_len));
d3140 1
a3140 1
=for apidoc magic_sethint
d3151 2
d3162 1
a3162 1
				 (SV *)mg->mg_ptr, &PL_sv_placeholder);
@


1.13
log
@When using setproctitle() don't fall back into the non-setproctitle()
code.  Fixes an environment corruption problem when $0 is modified.
From Alexander Bluhm; this is perl bug #41008
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d58 3
a61 8

/* if you only have signal() and it resets on each signal, FAKE_PERSISTENT_SIGNAL_HANDLERS fixes */
#if !defined(HAS_SIGACTION) && defined(VMS)
#  define  FAKE_PERSISTENT_SIGNAL_HANDLERS
#endif
/* if we're doing kill() with sys$sigprc on VMS, FAKE_DEFAULT_SIGNAL_HANDLERS */
#if defined(KILL_BY_SIGPRC)
#  define  FAKE_DEFAULT_SIGNAL_HANDLERS
d86 1
d89 4
d103 4
a106 1
    SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d121 1
d135 33
d179 1
d191 1
a191 1
    sv_2mortal(SvREFCNT_inc(sv));
d260 1
d274 2
d295 1
d313 1
a313 1
        len = Perl_utf8_length(aTHX_ (U8*)s, (U8*)s + len);
d387 1
a387 1
Perl_mg_find(pTHX_ SV *sv, int type)
d389 1
d397 1
a397 1
    return 0;
d420 1
a420 1
	    if (isUPPER(type)) {
d436 38
d510 1
a510 1
    register const REGEXP *rx;
d513 17
a529 5
    if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	if (mg->mg_obj)		/* @@+ */
	    return rx->nparens;
	else			/* @@- */
	    return rx->lastparen;
d538 24
a561 1
    register REGEXP *rx;
d563 1
a563 20
    if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
        register const I32 paren = mg->mg_len;
        register I32 s;
        register I32 t;
	if (paren < 0)
	    return 0;
	if (paren <= (I32)rx->nparens &&
	    (s = rx->startp[paren]) != -1 &&
	    (t = rx->endp[paren]) != -1)
	    {
                register I32 i;
		if (mg->mg_obj)		/* @@+ */
		    i = t;
		else			/* @@- */
		    i = s;

		if (i > 0 && RX_MATCH_UTF8(rx)) {
		    const char * const b = rx->subbeg;
		    if (b)
		        i = Perl_utf8_length(aTHX_ (U8*)b, (U8*)(b+i));
d565 1
a565 3

		sv_setiv(sv, i);
	    }
d573 2
a574 1
    PERL_UNUSED_ARG(sv); PERL_UNUSED_ARG(mg);
d582 1
d585 2
a586 2
    register const REGEXP *rx;
    I32 s1, t1;
d589 27
d617 3
a619 1
    case '5': case '6': case '7': case '8': case '9': case '&':
d621 2
a623 17
	    paren = atoi(mg->mg_ptr); /* $& is in [0] */
	  getparen:
	    if (paren <= (I32)rx->nparens &&
		(s1 = rx->startp[paren]) != -1 &&
		(t1 = rx->endp[paren]) != -1)
	    {
		i = t1 - s1;
	      getlen:
		if (i > 0 && RX_MATCH_UTF8(rx)) {
		    const char * const s = rx->subbeg + s1;
		    const U8 *ep;
		    STRLEN el;

                    i = t1 - s1;
		    if (is_utf8_string_loclen((U8*)s, i, &ep, &el))
			i = el;
		}
d627 1
a627 2
	    }
	    else {
d629 2
a630 6
		    report_uninit();
	    }
	}
	else {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
a631 1
	return 0;
a645 24
    case '`':
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    if (rx->startp[0] != -1) {
		i = rx->startp[0];
		if (i > 0) {
		    s1 = 0;
		    t1 = i;
		    goto getlen;
		}
	    }
	}
	return 0;
    case '\'':
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    if (rx->endp[0] != -1) {
		i = rx->sublen - rx->endp[0];
		if (i > 0) {
		    s1 = rx->endp[0];
		    t1 = rx->sublen;
		    goto getlen;
		}
	    }
	}
	return 0;
d667 26
d696 1
a698 1
    register I32 i;
d707 7
a713 2
    case '\003':		/* ^C */
	sv_setiv(sv, (IV)PL_minus_c);
a717 3
#if defined(YYDEBUG) && defined(DEBUGGING)
	PL_yydebug = DEBUG_p_TEST;
#endif
d721 1
a721 1
#ifdef MACOS_TRADITIONAL
d728 1
a728 2
#else
#ifdef VMS
d740 1
a740 2
#else
#ifdef OS2
d753 1
a753 2
#else
#ifdef WIN32
d755 1
a755 1
		  DWORD dwErr = GetLastError();
a771 3
#endif
#endif
#endif
d785 1
a785 4
	if (PL_inplace)
	    sv_setpv(sv, PL_inplace);
	else
	    sv_setsv(sv, &PL_sv_undef);
d793 1
a793 5
	    if (!PL_compiling.cop_io)
		sv_setsv(sv, &PL_sv_undef);
            else {
	        sv_setsv(sv, PL_compiling.cop_io);
	    }
d796 8
a803 2
    case '\020':		/* ^P */
	sv_setiv(sv, (IV)PL_perldb);
d807 1
a807 1
	    if (PL_lex_state != LEX_NOTPARSING)
d828 1
a828 1
    case '\025':		/* $^UNICODE, $^UTF8LOCALE */
d833 2
a852 1
		SV **bits_all;
d854 4
a857 2
		if (bits && (bits_all=hv_fetch(bits, "all", 3, FALSE))) {
		    sv_setsv(sv, *bits_all);
d864 2
a865 1
	        sv_setsv(sv, PL_compiling.cop_warnings);
d870 2
d874 8
a881 44
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    I32 s1, t1;

	    /*
	     * Pre-threads, this was paren = atoi(GvENAME((GV*)mg->mg_obj));
	     * XXX Does the new way break anything?
	     */
	    paren = atoi(mg->mg_ptr); /* $& is in [0] */
	  getparen:
	    if (paren <= (I32)rx->nparens &&
		(s1 = rx->startp[paren]) != -1 &&
		(t1 = rx->endp[paren]) != -1)
	    {
		i = t1 - s1;
		s = rx->subbeg + s1;
		if (!rx->subbeg)
		    break;

	      getrx:
		if (i >= 0) {
		    int oldtainted = PL_tainted;
		    TAINT_NOT;
		    sv_setpvn(sv, s, i);
		    PL_tainted = oldtainted;
		    if (RX_MATCH_UTF8(rx) && is_utf8_string((U8*)s, i))
			SvUTF8_on(sv);
		    else
			SvUTF8_off(sv);
		    if (PL_tainting) {
			if (RX_MATCH_TAINTED(rx)) {
			    MAGIC* const mg = SvMAGIC(sv);
			    MAGIC* mgt;
			    PL_tainted = 1;
			    SvMAGIC_set(sv, mg->mg_moremagic);
			    SvTAINT(sv);
			    if ((mgt = SvMAGIC(sv))) {
				mg->mg_moremagic = mgt;
				SvMAGIC_set(sv, mg);
			    }
			} else
			    SvTAINTED_off(sv);
		    }
		    break;
		}
d883 1
a884 1
	sv_setsv(sv,&PL_sv_undef);
d888 4
a891 3
	    paren = rx->lastparen;
	    if (paren)
		goto getparen;
d897 5
a901 3
	    paren = rx->lastcloseparen;
	    if (paren)
		goto getparen;
d906 1
d908 2
a909 4
	    if ((s = rx->subbeg) && rx->startp[0] != -1) {
		i = rx->startp[0];
		goto getrx;
	    }
d914 1
d916 2
a917 5
	    if (rx->subbeg && rx->endp[0] != -1) {
		s = rx->subbeg + rx->endp[0];
		i = rx->sublen - rx->endp[0];
		goto getrx;
	    }
d942 1
a942 1
	    sv_catpv(sv,"_TOP");
d969 1
a969 1
	WITH_THR(sv_setiv(sv, (IV)PL_curcop->cop_arybase));
a980 3
    case '#':
	sv_setpv(sv,PL_ofmt);
	break;
a1008 3
#ifdef HAS_GETGROUPS
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, (long unsigned int)PL_gid);
#endif
a1011 3
#ifdef HAS_GETGROUPS
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, (long unsigned int)PL_egid);
#endif
d1016 1
a1016 1
	    I32 num_groups = getgroups(0, gary);
d1019 2
a1020 3
	    while (--num_groups >= 0)
		Perl_sv_catpvf(aTHX_ sv, " %"Gid_t_f,
                    (long unsigned int)gary[num_groups]);
d1023 1
a1024 3
	(void)SvIOK_on(sv);	/* what a wonderful hack! */
	break;
    case '*':
a1029 5
#ifdef USE_5005THREADS
    case '@@':
	sv_setsv(sv, thr->errsv);
	break;
#endif /* USE_5005THREADS */
d1047 5
a1051 7
    const char *s;
    const char *ptr;
    STRLEN len, klen;

    s = SvPV_const(sv,len);
    ptr = MgPV_const(mg,klen);
    my_setenv((char *)ptr, (char *)s);
d1057 3
a1059 3
	SV **valp;
	if ((valp = hv_fetch(GvHVn(PL_envgv), ptr, klen, FALSE)))
	    s = SvPV_const(*valp, len);
d1070 1
a1070 1
	    char pathbuf[256], eltbuf[256], *cp, *elt = (char *) s;
d1074 2
d1085 1
a1085 1
		    if ((cp = strchr(elt, ':')) != Nullch)
d1103 5
d1109 1
a1109 1
			     (char *) s, (char *) strend, ':', &i);
d1111 6
a1116 2
		if (i >= sizeof tmpbuf   /* too long -- assume the worst */
		      || *tmpbuf != '/'
d1133 1
a1133 1
    my_setenv((char *)MgPV_nolen_const(mg),Nullch);
d1140 2
d1152 1
a1152 1
		      (char *)SvPV_nolen_const(hv_iterval((HV*)sv, entry)));
d1162 1
a1164 1
#ifndef PERL_MICRO
a1169 1
#endif /* !PERL_MICRO */
a1172 10
#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS)||defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
static int PL_sig_handlers_initted = 0;
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
static int PL_sig_ignoring[SIG_SIZE];      /* which signals we are ignoring */
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
static int PL_sig_defaulting[SIG_SIZE];
#endif

d1178 2
a1179 2
    const sigset_t *ossetp = (const sigset_t *) SvPV_nolen_const( save_sv );
    (void)sigprocmask(SIG_SETMASK, ossetp, (sigset_t *)0);
d1185 1
d1187 1
a1187 1
    const I32 i = whichsig((char *)MgPV_nolen_const(mg));
d1192 1
a1192 2
    	    Sighandler_t sigstate;
    	    sigstate = rsignal_state(i);
d1194 2
a1195 1
    	    if (PL_sig_handlers_initted && PL_sig_ignoring[i]) sigstate = SIG_IGN;
d1198 2
a1199 1
    	    if (PL_sig_handlers_initted && PL_sig_defaulting[i]) sigstate = SIG_DFL;
d1202 2
a1203 2
    	    if(sigstate == SIG_IGN)
    	    	sv_setpv(sv,"IGNORE");
d1206 1
a1206 1
    	    PL_psig_ptr[i] = SvREFCNT_inc(sv);
d1218 1
d1222 1
a1222 1
	SV** svp = 0;
d1225 1
a1225 1
	else if (strEQ(s,"__WARN__"))
a1226 2
	else
	    Perl_croak(aTHX_ "No such hook: %s", s);
d1228 3
a1230 3
            SV * const to_dec = *svp;
	    *svp = 0;
    	    SvREFCNT_dec(to_dec);
d1235 1
a1235 1
	const I32 i = whichsig((char *)s);
d1245 1
a1245 1
	    save_sv = newSVpv((char *)(&save), sizeof(sigset_t));
d1257 1
a1257 1
	    (void)rsignal(i, SIG_DFL);
d1264 1
a1264 1
                SV *to_dec=PL_psig_ptr[i];
d1276 17
d1296 1
d1300 3
a1302 1
    PL_sig_pending = 1;
d1306 3
d1310 1
d1317 2
d1331 13
a1343 1
   if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
d1346 3
d1350 1
d1379 1
d1387 3
d1391 1
d1400 1
d1402 1
a1402 1
    SV** svp = 0;
d1407 1
a1407 1
    SV* to_dec = 0;
d1424 3
a1426 2
	    to_dec = *svp;
	    *svp = 0;
d1430 1
a1430 1
	i = whichsig((char *)s);	/* ...no, a brick */
d1442 1
a1442 1
	save_sv = newSVpv((char *)(&save), sizeof(sigset_t));
d1458 1
a1458 1
	PL_psig_ptr[i] = SvREFCNT_inc(sv);
d1471 1
a1471 1
	    *svp = SvREFCNT_inc(sv);
d1476 1
a1476 1
    s = SvPV_force(sv,len);
d1483 1
a1483 1
	    (void)rsignal(i, SIG_IGN);
d1495 1
a1495 1
	    (void)rsignal(i, SIG_DFL);
d1505 1
a1505 1
	    sv_insert(sv, 0, 0, "main::", 6);
d1509 1
a1509 1
	    *svp = SvREFCNT_inc(sv);
d1524 2
d1527 24
a1550 2
    PERL_UNUSED_ARG(mg);
    PL_sub_generation++;
d1557 1
a1559 1
    /* HV_badAMAGIC_on(Sv_STASH(sv)); */
d1600 1
d1628 1
a1628 1
    dSP;
d1656 1
a1656 1
    dSP;
d1675 2
a1676 2
    dSP;
    U32 retval = 0;
d1683 3
a1685 1
	retval = (U32) SvIV(sv)-1;
d1690 1
a1690 1
    return retval;
d1696 1
a1696 1
    dSP;
d1713 1
a1713 1
    dSP;
d1736 1
a1736 1
Perl_magic_existspack(pTHX_ SV *sv, MAGIC *mg)
d1744 2
a1745 2
    dSP;
    SV *retval = &PL_sv_undef;
d1771 2
d1781 1
d1800 1
a1800 1
Perl_magic_getarylen(pTHX_ SV *sv, MAGIC *mg)
d1802 2
a1803 1
    AV *obj = (AV*)mg->mg_obj;
d1805 1
a1805 1
	sv_setiv(sv, AvFILL(obj) + PL_curcop->cop_arybase);
d1815 2
a1816 1
    AV *obj = (AV*)mg->mg_obj;
d1818 1
a1818 1
	av_fill(obj, SvIV(sv) - PL_curcop->cop_arybase);
d1828 22
d1852 1
d1854 1
d1857 3
a1859 3
	mg = mg_find(lsv, PERL_MAGIC_regex_global);
	if (mg && mg->mg_len >= 0) {
	    I32 i = mg->mg_len;
d1862 1
a1862 1
	    sv_setiv(sv, i + PL_curcop->cop_arybase);
d1873 1
d1878 1
d1880 1
a1880 1
    mg = 0;
d1883 4
a1886 2
	mg = mg_find(lsv, PERL_MAGIC_regex_global);
    if (!mg) {
d1889 6
a1894 2
	sv_magic(lsv, (SV*)0, PERL_MAGIC_regex_global, Nullch, 0);
	mg = mg_find(lsv, PERL_MAGIC_regex_global);
d1897 1
a1897 1
	mg->mg_len = -1;
d1902 1
a1902 1
    pos = SvIV(sv) - PL_curcop->cop_arybase;
d1924 2
a1925 2
    mg->mg_len = pos;
    mg->mg_flags &= ~MGf_MINMATCH;
a1930 14
Perl_magic_getglob(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_UNUSED_ARG(mg);
    if (SvFAKE(sv)) {			/* FAKE globs can get coerced */
	SvFAKE_off(sv);
	gv_efullname3(sv,((GV*)sv), "*");
	SvFAKE_on(sv);
    }
    else
	gv_efullname3(sv,((GV*)sv), "*");	/* a gv value, be nice */
    return 0;
}

int
a1932 1
    register char *s;
a1933 1
    STRLEN n_a;
d1936 2
d1940 6
a1945 4
    s = SvPV(sv, n_a);
    if (*s == '*' && s[1])
	s++;
    gv = gv_fetchpv(s,TRUE, SVt_PVGV);
d1979 1
d1981 1
a1981 1
    const char *tmps = SvPV_const(sv, len);
d1990 2
a1991 1
	sv_insert(lsv, lvoff, lvlen, (char *)tmps, len);
d1995 1
d1997 4
a2000 3
	tmps = (char*)bytes_to_utf8((U8*)tmps, &len);
	sv_insert(lsv, lvoff, lvlen, (char *)tmps, len);
	Safefree(tmps);
d2002 5
a2006 2
    else
        sv_insert(lsv, lvoff, lvlen, (char *)tmps, len);
d2014 1
d2016 1
a2016 2
    TAINT_IF((mg->mg_len & 1) ||
	     ((mg->mg_len & 2) && mg->mg_obj == sv));	/* kludge */
d2023 1
d2025 2
a2026 7
    if (PL_localizing) {
	if (PL_localizing == 1)
	    mg->mg_len <<= 1;
	else
	    mg->mg_len >>= 1;
    }
    else if (PL_tainted)
d2039 3
a2041 1
    if (!lsv) {
a2042 2
	return 0;
    }
a2043 1
    sv_setuv(sv, do_vecget(lsv, LvTARGOFF(sv), LvTARGLEN(sv)));
d2058 2
a2059 1
    SV *targ = Nullsv;
d2063 3
a2065 10
	    if (SvTYPE(ahv) == SVt_PVHV) {
		HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, FALSE, 0);
		if (he)
		    targ = HeVAL(he);
	    }
	    else {
		SV **svp = avhv_fetch_ent((AV*)ahv, mg->mg_obj, FALSE, 0);
		if (svp)
		    targ = *svp;
	    }
d2072 1
a2072 1
	if (targ && targ != &PL_sv_undef) {
d2075 1
a2075 1
	    LvTARG(sv) = SvREFCNT_inc(targ);
d2078 1
a2078 1
	    mg->mg_obj = Nullsv;
d2104 1
d2106 1
a2106 1
    SV *value = Nullsv;
d2112 3
a2114 10
	if (SvTYPE(ahv) == SVt_PVHV) {
	    HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, TRUE, 0);
	    if (he)
		value = HeVAL(he);
	}
	else {
	    SV **svp = avhv_fetch_ent((AV*)ahv, mg->mg_obj, TRUE, 0);
	    if (svp)
		value = *svp;
	}
d2116 1
a2116 1
	    Perl_croak(aTHX_ PL_no_helem_sv, mg->mg_obj);
d2121 1
a2121 1
	    LvTARG(sv) = Nullsv;	/* array can't be extended */
d2123 1
a2123 1
	    SV** const svp = av_fetch(av, LvTARGOFF(sv), TRUE);
d2128 1
a2128 1
    (void)SvREFCNT_inc(value);
d2133 1
a2133 1
    mg->mg_obj = Nullsv;
d2140 1
a2140 20
    AV * const av = (AV*)mg->mg_obj;
    SV ** const svp = AvARRAY(av);
    I32 i = AvFILLp(av);
    PERL_UNUSED_ARG(sv);

    while (i >= 0) {
	if (svp[i]) {
	    if (!SvWEAKREF(svp[i]))
		Perl_croak(aTHX_ "panic: magic_killbackrefs (flags=%"UVxf")",
			   (UV)SvFLAGS(svp[i]));
	    /* XXX Should we check that it hasn't changed? */
	    SvRV_set(svp[i], 0);
	    SvOK_off(svp[i]);
	    SvWEAKREF_off(svp[i]);
	    svp[i] = Nullsv;
	}
	i--;
    }
    SvREFCNT_dec(av); /* remove extra count added by sv_add_backref() */
    return 0;
d2146 1
d2157 1
d2192 1
d2208 1
d2223 1
d2225 4
a2228 4
     Safefree(mg->mg_ptr);	/* The mg_ptr holds the pos cache. */
     mg->mg_ptr = 0;
     mg->mg_len = -1; 		/* The mg_len holds the len cache. */
     return 0;
d2234 1
d2236 3
d2241 1
d2243 30
d2277 1
a2277 1
	PL_minus_c = (bool)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2283 1
a2283 1
	PL_debug = get_debug_opts_flags((char **)&s, 0) | DEBUG_TOP_FLAG;
d2286 1
a2286 1
	PL_debug = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) | DEBUG_TOP_FLAG;
d2292 1
a2292 1
	    gMacPerl_OSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2295 1
a2295 1
	    set_vaxc_errno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2301 1
a2301 1
	    os2_setsyserrno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2304 1
a2304 1
	    SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv), 4);
d2317 1
a2317 1
		PL_encoding = Nullsv;
d2322 1
a2322 1
	PL_maxsysfd = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2325 1
a2325 1
	PL_hints = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2329 1
a2329 1
	PL_inplace = SvOK(sv) ? savesvpv(sv) : Nullch;
d2334 1
a2334 1
	    PL_osname = Nullch;
d2341 27
a2367 4
	    if (!PL_compiling.cop_io)
		PL_compiling.cop_io = newSVsv(sv);
	    else
		sv_setsv(PL_compiling.cop_io,sv);
d2371 10
a2380 4
	PL_perldb = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (PL_perldb && !PL_DBsingle)
	    init_debugger();
	break;
d2385 1
a2385 1
	PL_basetime = (Time_t)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2388 5
d2396 1
a2396 1
	        i = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2417 10
a2426 3
		    if (!accumulate)
	                PL_compiling.cop_warnings = pWARN_NONE;
		    else if (isWARN_on(sv, WARN_ALL) && !any_fatals) {
d2431 7
a2437 4
	                if (specialWARN(PL_compiling.cop_warnings))
		            PL_compiling.cop_warnings = newSVsv(sv) ;
	                else
	                    sv_setsv(PL_compiling.cop_warnings, sv);
d2457 1
a2457 1
	IoTOP_GV(GvIOp(PL_defoutgv)) = gv_fetchpv(s,TRUE, SVt_PVIO);
d2462 1
a2462 1
	IoFMT_GV(GvIOp(PL_defoutgv)) = gv_fetchpv(s,TRUE, SVt_PVIO);
d2465 1
a2465 1
	IoPAGE_LEN(GvIOp(PL_defoutgv)) = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2468 1
a2468 1
	IoLINES_LEFT(GvIOp(PL_defoutgv)) = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2473 1
a2473 1
	IoPAGE(GvIOp(PL_defoutgv)) = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2480 1
a2480 1
	    if ((SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) == 0)
a2491 4
    case '*':
	i = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	PL_multiline = (i != 0);
	break;
d2503 1
a2503 1
	    PL_ors_sv = Nullsv;
d2513 1
a2513 1
	    PL_ofs_sv = Nullsv;
a2515 5
    case '#':
	if (PL_ofmt)
	    Safefree(PL_ofmt);
	PL_ofmt = savesvpv(sv);
	break;
d2517 1
a2517 1
	PL_compiling.cop_arybase = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2529 1
a2529 1
	    STATUS_NATIVE_SET((U32)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)));
d2532 1
a2532 1
	    STATUS_POSIX_SET(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2546 1
a2546 1
	PL_uid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2578 1
a2578 1
	PL_euid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2605 1
a2605 1
	PL_gid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2655 1
a2655 2
            if (gary)
                Safefree(gary);
d2658 1
a2658 1
	PL_egid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2695 1
a2695 1
	{
d2715 1
a2715 1
	{
d2722 26
a2747 18
	/* PL_origalen is set in perl_parse(). */
	s = SvPV_force(sv,len);
	if (len >= (STRLEN)PL_origalen) {
	    /* Longer than original, will be truncated. */
	    Copy(s, PL_origargv[0], PL_origalen, char);
	    PL_origargv[0][PL_origalen - 1] = 0;
	}
	else {
	    /* Shorter than original, will be padded. */
	    Copy(s, PL_origargv[0], len, char);
	    PL_origargv[0][len] = 0;
	    memset(PL_origargv[0] + len + 1,
		   /* Is the space counterintuitive?  Yes.
		    * (You were expecting \0?)  
		    * Does it work?  Seems to.  (In Linux 2.4.20 at least.)
		    * --jhi */
		   (int)' ',
		   PL_origalen - len - 1);
d2749 1
a2749 1
		 PL_origargv[i] = 0;
a2754 5
#ifdef USE_5005THREADS
    case '@@':
	sv_setsv(thr->errsv, sv);
	break;
#endif /* USE_5005THREADS */
a2758 15
#ifdef USE_5005THREADS
int
Perl_magic_mutexfree(pTHX_ SV *sv, MAGIC *mg)
{
    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf": magic_mutexfree 0x%"UVxf"\n",
			  PTR2UV(thr), PTR2UV(sv)));
    if (MgOWNER(mg))
	Perl_croak(aTHX_ "panic: magic_mutexfree");
    MUTEX_DESTROY(MgMUTEXP(mg));
    COND_DESTROY(MgCONDP(mg));
    return 0;
}
#endif /* USE_5005THREADS */

d2760 1
a2760 1
Perl_whichsig(pTHX_ char *sig)
d2762 2
a2763 1
    register const char * const *sigv;
d2765 1
a2765 1
    for (sigv = PL_sig_name; *sigv; sigv++)
d2767 1
a2767 1
	    return PL_sig_num[sigv - PL_sig_name];
a2778 4
#if !defined(PERL_IMPLICIT_CONTEXT)
static SV* PL_sig_sv;
#endif

d2780 3
d2784 1
d2792 2
a2793 2
    GV *gv = Nullgv;
    SV *sv = Nullsv;
d2795 1
a2795 1
    CV *cv = Nullcv;
a2803 2
    if (PL_retstack_ix < PL_retstack_max - 2)
	flags |= 8;
a2820 4
    if (flags & 8) {
	PL_retstack_ix++;
	PL_retstack[PL_retstack_ix] = NULL;
    }
d2827 1
a2827 1
	cv = sv_2cv(PL_psig_ptr[sig],&st,&gv,TRUE);
d2841 1
a2841 1
    	sv = SvREFCNT_inc(PL_psig_name[sig]);
d2854 28
d2904 1
a2904 1
	Perl_die(aTHX_ Nullch);
a2910 2
    if (flags & 8)
	PL_retstack_ix--;
d2926 1
d2935 7
d2950 4
a2953 4
	    U32 public = SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK);
	    if (public) {
		SvFLAGS(sv) &= ~( public | SVp_IOK|SVp_NOK|SVp_POK );
		SvFLAGS(sv) |= ( public << PRIVSHIFT );
d2983 1
a2987 1
    /* cxstack_ix-- Not needed, die already unwound it. */
d2992 56
@


1.12
log
@merge in perl 5.8.8
@
text
@d2512 1
a2512 2
#endif
#if defined(__hpux) && defined(PSTAT_SETCMD)
d2519 1
a2519 1
#endif
d2541 1
@


1.11
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d43 6
a51 3
#  ifdef I_GRP
#    include <grp.h>
#  endif
a68 3
static void restore_magic(pTHX_ void *p);
static void unwind_handler_stack(pTHX_ void *p);

d94 1
a94 1
    SAVEDESTRUCTOR_X(restore_magic, INT2PTR(void*, (IV)mgs_ix));
d117 1
a117 1
    MAGIC* mg;
d119 1
a119 1
	MGVTBL* vtbl = mg->mg_virtual;
d142 3
a144 1
    int new = 0;
a145 2
    I32 mgs_ix = SSNEW(sizeof(MGS));
    int was_temp = SvTEMP(sv);
d166 1
a166 1
	MGVTBL *vtbl = mg->mg_virtual;
d183 1
a183 1
	if (new) {
d187 1
a187 1
		new  = 0;
d194 2
a195 2
	if (!new && (newmg = SvMAGIC(sv)) != head) {
	    new = 1;
d201 1
a201 1
    restore_magic(aTHX_ INT2PTR(void *, (IV)mgs_ix));
d222 1
a222 1
    I32 mgs_ix;
a225 1
    mgs_ix = SSNEW(sizeof(MGS));
d229 1
a229 1
	MGVTBL* vtbl = mg->mg_virtual;
d239 1
a239 1
    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d258 1
a258 1
	MGVTBL* vtbl = mg->mg_virtual;
d260 1
a260 3
            I32 mgs_ix;

	    mgs_ix = SSNEW(sizeof(MGS));
d264 1
a264 1
	    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d269 3
a271 4
    if (DO_UTF8(sv))
    {
        U8 *s = (U8*)SvPV(sv, len);
        len = Perl_utf8_length(aTHX_ s, s + len);
d274 1
a274 1
        (void)SvPV(sv, len);
a281 1
    I32 len;
d284 1
a284 1
	MGVTBL* vtbl = mg->mg_virtual;
d286 2
a287 3
            I32 mgs_ix;

	    mgs_ix = SSNEW(sizeof(MGS));
d291 1
a291 1
	    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d298 1
a298 2
	    len = AvFILLp((AV *) sv); /* Fallback to non-tied array */
	    return len;
d319 1
a319 1
    I32 mgs_ix;
a321 1
    mgs_ix = SSNEW(sizeof(MGS));
d325 1
a325 1
	MGVTBL* vtbl = mg->mg_virtual;
d332 1
a332 1
    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d347 6
a352 6
    MAGIC* mg;
    if (!sv)
        return 0;
    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	if (mg->mg_type == type)
	    return mg;
d371 1
a371 1
	MGVTBL* vtbl = mg->mg_virtual;
d375 12
a386 7
	else if (isUPPER(mg->mg_type)) {
	    sv_magic(nsv,
		     mg->mg_type == PERL_MAGIC_tied ? SvTIED_obj(sv, mg) :
		     (mg->mg_type == PERL_MAGIC_regdata && mg->mg_obj)
							? sv : mg->mg_obj,
		     toLOWER(mg->mg_type), key, klen);
	    count++;
d406 1
a406 1
	MGVTBL* vtbl = mg->mg_virtual;
d420 1
a420 1
    SvMAGIC(sv) = 0;
d429 2
a430 1
    register REGEXP *rx;
a444 3
    register I32 paren;
    register I32 s;
    register I32 i;
a445 1
    I32 t;
d448 3
a450 1
	paren = mg->mg_len;
d457 1
d464 1
a464 1
		    char *b = rx->subbeg;
d478 1
d480 1
a480 2
    /* NOT REACHED */
    return 0;
d488 1
a488 1
    register REGEXP *rx;
d505 3
a507 2
		    char *s    = rx->subbeg + s1;
		    char *send = rx->subbeg + t1;
d510 2
a511 2
		    if (is_utf8_string((U8*)s, i))
			i = Perl_utf8_length(aTHX_ (U8*)s, (U8*)send);
d568 1
a568 2
	STRLEN n_a;
	sv_2pv(sv, &n_a);
d575 11
d593 2
d611 1
a611 1
	 if (*(mg->mg_ptr+1) == '\0') {
d630 1
a630 1
		       sv_setpv(sv,"");
d639 1
a639 1
		       int tmp = _syserrno();
d651 1
a651 2
		  if (dwErr)
		  {
d655 1
a655 1
		       sv_setpv(sv, "");
d660 1
a660 1
		 int saveerrno = errno;
d669 1
d672 1
a672 1
	 else if (strEQ(mg->mg_ptr+1, "NCODING"))
d688 1
a688 1
	if (*(mg->mg_ptr+1) == '\0') {
d692 1
a692 1
	else if (strEQ(mg->mg_ptr, "\017PEN")) {
d704 1
a704 1
        if (*(mg->mg_ptr+1) == '\0') {
d714 1
a714 1
        if (*(mg->mg_ptr+1) == '\0') {
d721 1
a721 1
        else if (strEQ(mg->mg_ptr, "\024AINT"))
d726 2
a727 2
    case '\025':		/* $^UNICODE */
        if (strEQ(mg->mg_ptr, "\025NICODE"))
d729 2
d733 1
a733 1
	if (*(mg->mg_ptr+1) == '\0')
d735 2
a736 4
	else if (strEQ(mg->mg_ptr+1, "ARNING_BITS")) {
	    if (PL_compiling.cop_warnings == pWARN_NONE ||
	        PL_compiling.cop_warnings == pWARN_STD)
	    {
d738 8
a745 1
            }
d747 10
a756 1
	        sv_setpvn(sv, WARN_ALLstring, WARNsize) ;
d786 2
d789 1
d796 1
a796 1
			    MAGIC* mg = SvMAGIC(sv);
d799 1
a799 1
			    SvMAGIC(sv) = mg->mg_moremagic;
d803 1
a803 1
				SvMAGIC(sv) = mg;
a849 1
#ifndef lint
a852 1
#endif
a879 1
#ifndef lint
a891 1
#endif
d918 1
a918 1
	int saveerrno = errno;
d929 1
d941 1
a941 1
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, PL_gid);
d947 1
a947 1
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, PL_egid);
d952 8
a959 4
	    Groups_t gary[NGROUPS];
	    i = getgroups(NGROUPS,gary);
	    while (--i >= 0)
		Perl_sv_catpvf(aTHX_ sv, " %"Gid_t_f, gary[i]);
d982 1
a982 1
    struct ufuncs *uf = (struct ufuncs *)mg->mg_ptr;
d992 2
a993 2
    register char *s;
    char *ptr;
d996 3
a998 3
    s = SvPV(sv,len);
    ptr = MgPV(mg,klen);
    my_setenv(ptr, s);
d1006 1
a1006 1
	    s = SvPV(*valp, len);
d1017 1
a1017 1
	    char pathbuf[256], eltbuf[256], *cp, *elt = s;
d1042 1
a1042 1
	    char *strend = s + len;
d1049 1
a1049 1
			     s, strend, ':', &i);
d1068 2
a1069 2
    STRLEN n_a;
    my_setenv(MgPV(mg,n_a),Nullch);
d1081 1
a1081 2
	STRLEN n_a;
	magic_clear_all_env(sv,mg);
d1086 1
a1086 1
		      SvPV(hv_iterval((HV*)sv, entry), n_a));
d1096 2
d1099 1
a1099 1
#if defined(VMS) || defined(EPOC)
d1102 2
a1103 26
#  if defined(PERL_IMPLICIT_SYS) || defined(WIN32)
    PerlEnv_clearenv();
#  else
#    ifdef USE_ENVIRON_ARRAY
#      if defined(USE_ITHREADS)
    /* only the parent thread can clobber the process environment */
    if (PL_curinterp == aTHX)
#      endif
    {
#      ifndef PERL_USE_SAFE_PUTENV
    if (!PL_use_safe_putenv) {
    I32 i;

    if (environ == PL_origenviron)
	environ = (char**)safesysmalloc(sizeof(char*));
    else
	for (i = 0; environ[i]; i++)
	    safesysfree(environ[i]);
    }
#      endif /* PERL_USE_SAFE_PUTENV */

    environ[0] = Nullch;
    }
#    endif /* USE_ENVIRON_ARRAY */
#   endif /* PERL_IMPLICIT_SYS || WIN32 */
#endif /* VMS || EPOC */
d1109 1
a1109 1
static int sig_handlers_initted = 0;
d1112 1
a1112 1
static int sig_ignoring[SIG_SIZE];      /* which signals we are ignoring */
d1115 1
a1115 1
static int sig_defaulting[SIG_SIZE];
d1123 1
a1123 1
    sigset_t *ossetp = (sigset_t *) SvPV_nolen( save_sv );
a1129 2
    I32 i;
    STRLEN n_a;
d1131 1
a1131 1
    i = whichsig(MgPV(mg,n_a));
d1139 1
a1139 1
    	    if (sig_handlers_initted && sig_ignoring[i]) sigstate = SIG_IGN;
d1142 1
a1142 1
    	    if (sig_handlers_initted && sig_defaulting[i]) sigstate = SIG_DFL;
d1161 2
a1162 4
    register char *s;
    STRLEN n_a;
    SV* to_dec;
    s = MgPV(mg,n_a);
d1164 1
a1164 1
	SV** svp;
d1171 2
a1172 2
	if (*svp) {
	    to_dec = *svp;
a1177 1
	I32 i;
d1179 1
a1179 1
	i = whichsig(s);
d1195 1
a1195 1
	    if (!sig_handlers_initted) Perl_csighandler_init();
d1198 1
a1198 1
	    sig_defaulting[i] = 1;
d1208 1
a1208 1
		to_dec=PL_psig_ptr[i];
d1220 2
a1221 2
void
Perl_raise_signal(pTHX_ int sig)
d1239 1
a1239 1
    if (sig_ignoring[sig]) return;
d1242 1
a1242 1
    if (sig_defaulting[sig])
d1254 1
a1254 1
	Perl_raise_signal(aTHX_ sig);
d1262 1
a1262 1
    if (sig_handlers_initted) return;
d1267 1
a1267 1
        sig_defaulting[sig] = 1;
d1271 1
a1271 1
        sig_ignoring[sig] = 0;
d1274 1
a1274 1
    sig_handlers_initted = 1;
a1296 1
    register char *s;
d1310 1
a1310 1
    s = MgPV(mg,len);
d1325 2
a1326 2
	i = whichsig(s);	/* ...no, a brick */
	if (i < 0) {
d1343 1
a1343 1
	if (!sig_handlers_initted) Perl_csighandler_init();
d1346 1
a1346 1
	sig_ignoring[i] = 0;
d1349 1
a1349 1
	sig_defaulting[i] = 0;
d1375 1
a1375 1
	    sig_ignoring[i] = 1;
d1386 1
a1386 1
	    sig_defaulting[i] = 1;
d1419 2
d1428 2
d1439 1
a1439 1
    HV *hv = (HV*)LvTARG(sv);
d1441 1
d1460 1
d1469 1
a1469 1
S_magic_methcall(pTHX_ SV *sv, MAGIC *mg, char *meth, I32 flags, int n, SV *val)
d1496 1
a1496 1
S_magic_methpack(pTHX_ SV *sv, MAGIC *mg, char *meth)
d1582 1
a1582 1
    const char *meth = SvOK(key) ? "NEXTKEY" : "FIRSTKEY";
d1614 2
a1615 2
    SV *tied = SvTIED_obj((SV*)hv, mg);
    HV *pkg = SvSTASH((SV*)SvRV(tied));
d1619 1
a1619 1
        if (HvEITER(hv))
d1625 1
a1625 1
        HvEITER(hv) = NULL;     /* need to reset iterator */
d1647 13
a1659 16
    OP *o;
    I32 i;
    GV* gv;
    SV** svp;
    STRLEN n_a;

    gv = PL_DBline;
    i = SvTRUE(sv);
    svp = av_fetch(GvAV(gv),
		     atoi(MgPV(mg,n_a)), FALSE);
    if (svp && SvIOKp(*svp) && (o = INT2PTR(OP*,SvIVX(*svp)))) {
	/* set or clear breakpoint in the relevant control op */
	if (i)
	    o->op_flags |= OPf_SPECIAL;
	else
	    o->op_flags &= ~OPf_SPECIAL;
d1667 6
a1672 1
    sv_setiv(sv, AvFILL((AV*)mg->mg_obj) + PL_curcop->cop_arybase);
d1679 8
a1686 1
    av_fill((AV*)mg->mg_obj, SvIV(sv) - PL_curcop->cop_arybase);
d1693 1
a1693 1
    SV* lsv = LvTARG(sv);
d1712 1
a1712 1
    SV* lsv = LvTARG(sv);
d1764 1
d1781 1
d1801 2
a1802 2
    SV *lsv = LvTARG(sv);
    char *tmps = SvPV(lsv,len);
d1805 1
d1823 2
a1824 2
    char *tmps = SvPV(sv, len);
    SV *lsv = LvTARG(sv);
d1827 1
d1832 1
a1832 1
	sv_insert(lsv, lvoff, lvlen, tmps, len);
d1838 1
a1838 1
	sv_insert(lsv, lvoff, lvlen, tmps, len);
d1842 1
a1842 1
        sv_insert(lsv, lvoff, lvlen, tmps, len);
d1850 1
d1859 1
d1876 2
a1877 1
    SV *lsv = LvTARG(sv);
d1891 1
d1902 1
a1902 1
	    SV *ahv = LvTARG(sv);
d1904 1
a1904 1
		HE *he = hv_fetch_ent((HV*)ahv, mg->mg_obj, FALSE, 0);
d1915 1
a1915 1
	    AV* av = (AV*)LvTARG(sv);
d1938 1
d1957 1
a1957 2
	SV *ahv = LvTARG(sv);
	STRLEN n_a;
d1959 1
a1959 1
	    HE *he = hv_fetch_ent((HV*)ahv, mg->mg_obj, TRUE, 0);
d1969 1
a1969 1
	    Perl_croak(aTHX_ PL_no_helem, SvPV(mg->mg_obj, n_a));
d1972 1
a1972 1
	AV* av = (AV*)LvTARG(sv);
d1976 1
a1976 1
	    SV** svp = av_fetch(av, LvTARGOFF(sv), TRUE);
d1993 2
a1994 2
    AV *av = (AV*)mg->mg_obj;
    SV **svp = AvARRAY(av);
d1996 2
d2001 2
a2002 1
		Perl_croak(aTHX_ "panic: magic_killbackrefs");
d2004 1
a2004 1
	    SvRV(svp[i]) = 0;
d2026 1
d2035 1
d2044 1
a2044 1
    struct ufuncs *uf = (struct ufuncs *)mg->mg_ptr;
d2054 1
d2062 3
a2064 1
    regexp *re = (regexp *)mg->mg_obj;
d2077 1
d2091 1
d2101 1
a2101 1
    register char *s;
d2114 2
a2115 2
	s = SvPV_nolen(sv);
	PL_debug = get_debug_opts_flags(&s, 0) | DEBUG_TOP_FLAG;
d2160 2
a2161 6
	if (PL_inplace)
	    Safefree(PL_inplace);
	if (SvOK(sv))
	    PL_inplace = savepv(SvPV(sv,len));
	else
	    PL_inplace = Nullch;
d2165 2
a2166 4
	    if (PL_osname) {
		Safefree(PL_osname);
		PL_osname = Nullch;
	    }
d2169 1
a2169 1
		PL_osname = savepv(SvPV(sv,len));
d2181 1
a2181 2
	if ((PERLDB_SUB || PERLDB_LINE || PERLDB_SUBLINE)
		&& !PL_DBsingle)
d2210 1
a2210 1
		    char * ptr = (char*)SvPV(sv, len) ;
d2244 1
a2244 1
	IoTOP_NAME(GvIOp(PL_defoutgv)) = s = savepv(SvPV(sv,len));
d2249 1
a2249 1
	IoFMT_NAME(GvIOp(PL_defoutgv)) = s = savepv(SvPV(sv,len));
d2265 1
a2265 1
	    IO *io = GvIOp(PL_defoutgv);
d2311 1
a2311 1
	PL_ofmt = savepv(SvPV(sv,len));
d2431 2
a2432 2
	    char *p = SvPV(sv, len);
	    Groups_t gary[NGROUPS];
d2434 20
a2453 14
	    while (isSPACE(*p))
		++p;
	    PL_egid = Atol(p);
	    for (i = 0; i < NGROUPS; ++i) {
		while (*p && !isSPACE(*p))
		    ++p;
		while (isSPACE(*p))
		    ++p;
		if (!*p)
		    break;
		gary[i] = Atol(p);
	    }
	    if (i)
		(void)setgroups(i, gary);
d2494 1
a2494 1
	    s = SvPV(sv, len);
d2516 2
a2517 2
	     s = SvPV(sv, len);
	     un.pst_command = s;
d2572 1
a2572 1
    register char **sigv;
d2589 1
a2589 1
static SV* sig_sv;
d2602 2
a2603 2
    HV *st;
    SV *sv = Nullsv, *tSv = PL_Sv;
d2607 1
a2607 1
    XPV *tXpv = PL_Xpv;
d2628 1
a2628 1
	SAVEDESTRUCTOR_X(unwind_handler_stack, (void*)&flags);
d2640 2
a2641 1
	|| SvTYPE(cv) != SVt_PVCV)
d2643 1
d2659 1
a2659 1
	sig_sv = sv;
d2691 1
a2691 1
	Perl_die(aTHX_ Nullformat);
d2713 1
a2713 1
restore_magic(pTHX_ void *p)
d2715 2
a2716 2
    MGS* mgs = SSPTR(PTR2IV(p), MGS*);
    SV* sv = mgs->mgs_sv;
d2727 10
a2736 2
	if (SvGMAGICAL(sv))
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
d2762 1
a2762 1
unwind_handler_stack(pTHX_ void *p)
d2764 1
a2764 1
    U32 flags = *(U32*)p;
d2771 1
a2771 1
	SvREFCNT_dec(sig_sv);
d2775 9
a2783 1

@


1.10
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d18 18
d145 12
a170 4
	    /* guard against sv having been freed */
	    if (SvTYPE(sv) == SVTYPEMASK) {
		Perl_croak(aTHX_ "Tied variable freed while still in use");
	    }
d202 6
d696 1
a696 1
		(void)SvOK_off(sv);
d1081 1
d1089 1
d1689 1
a1689 1
    (void)SvOK_off(sv);
d1857 1
a1857 1
	(void)SvOK_off(sv);
d1978 1
a1978 1
	    (void)SvOK_off(svp[i]);
d2081 1
a2081 1
	PL_debug = get_debug_opts(&s) | DEBUG_TOP_FLAG;
@


1.9
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d646 1
a646 1
	if (*(mg->mg_ptr+1) == '\0')
d648 2
d1939 1
a1939 1
	if (svp[i] && svp[i] != &PL_sv_undef) {
d1946 1
a1946 1
	    svp[i] = &PL_sv_undef;
d2101 1
a2101 1
	    if (PL_osname)
d2103 4
a2106 1
	    if (SvOK(sv))
d2108 1
a2108 2
	    else
		PL_osname = Nullch;
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d382 1
a382 1
	    if (mg->mg_len > 0)
a394 2

#if !defined(NSIG) || defined(M_UNIX) || defined(M_XENIX)
a395 1
#endif
d618 6
a623 2
	     sv_setnv(sv, (NV)errno);
	     sv_setpv(sv, errno ? Strerror(errno) : "");
d1531 1
d1566 35
d2115 2
a2116 1
	if (PL_perldb && !PL_DBsingle)
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d33 6
d51 8
d140 10
d437 1
a437 1
		if (i > 0 && PL_reg_match_utf8) {
d478 1
a478 1
		if (i > 0 && PL_reg_match_utf8) {
d553 1
a553 1
    register char *s;
d659 1
a659 1
	{
d677 3
a679 1
            sv_setiv(sv, PL_tainting);
d681 5
a685 1
    case '\027':		/* ^W  & $^WARNING_BITS & ^WIDE_SYSTEM_CALLS */
a701 2
	else if (strEQ(mg->mg_ptr+1, "IDE_SYSTEM_CALLS"))
	    sv_setiv(sv, (IV)PL_widesyscalls);
a724 5
		    bool was_tainted = FALSE;
		    if (PL_tainting) {
			was_tainted = PL_tainted;
			PL_tainted = FALSE;
		    }
d726 1
a726 1
                   if (PL_reg_match_utf8 && is_utf8_string((U8*)s, i))
d730 14
a743 2
		    if (PL_tainting)
			PL_tainted = (was_tainted || RX_MATCH_TAINTED(rx));
d802 2
a803 1
	s = IoTOP_NAME(GvIOp(PL_defoutgv));
d812 2
a813 1
	s = IoFMT_NAME(GvIOp(PL_defoutgv));
d820 2
a821 1
	sv_setiv(sv, (IV)IoPAGE_LEN(GvIOp(PL_defoutgv)));
d824 2
a825 1
	sv_setiv(sv, (IV)IoLINES_LEFT(GvIOp(PL_defoutgv)));
d828 2
a829 1
	sv_setiv(sv, (IV)IoPAGE(GvIOp(PL_defoutgv)));
d840 2
a841 1
	sv_setiv(sv, (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0 );
d847 1
a847 1
	    sv_setpv(sv,SvPVX(PL_ors_sv));
d1032 1
d1059 2
a1060 1
#endif /* VMS || EPC */
d1075 8
d1090 1
a1090 1
    if (i) {
d1116 4
a1119 1
    I32 i;
d1121 56
a1176 11
    /* Are we clearing a signal entry? */
    i = whichsig(MgPV(mg,n_a));
    if (i) {
    	if(PL_psig_ptr[i]) {
    	    SvREFCNT_dec(PL_psig_ptr[i]);
    	    PL_psig_ptr[i]=0;
    	}
    	if(PL_psig_name[i]) {
    	    SvREFCNT_dec(PL_psig_name[i]);
    	    PL_psig_name[i]=0;
    	}
d1199 1
a1199 1
    (void) rsignal(sig, &Perl_csighandler);
d1210 6
a1215 7

#ifdef PERL_OLD_SIGNALS
    /* Call the perl level handler now with risk we may be in malloc() etc. */
    (*PL_sighandlerp)(sig);
#else
    Perl_raise_signal(aTHX_ sig);
#endif
d1229 1
a1229 1
        (void) rsignal(sig, &Perl_csighandler);
d1246 3
a1248 1
	    PL_psig_pend[sig] = 0;
d1250 1
d1261 5
d1267 4
d1282 1
a1282 1
	    SvREFCNT_dec(*svp);
d1288 1
a1288 1
	if (!i) {
d1293 11
d1311 1
a1311 1
	  sig_defaulting[i] = 0;
d1314 1
a1314 1
	SvREFCNT_dec(PL_psig_ptr[i]);
d1321 6
a1326 2
	if (i)
	    (void)rsignal(i, &Perl_csighandler);
d1329 2
d1338 1
a1338 1
	    (void)rsignal(i, &Perl_csighandler);
d1342 1
a1342 2
	} else
	    *svp = 0;
d1349 1
a1349 1
	    (void)rsignal(i, &Perl_csighandler);
a1353 2
	else
	    *svp = 0;
d1364 1
a1364 1
	    (void)rsignal(i, &Perl_csighandler);
d1368 6
a1472 1
    magic_methpack(sv,mg,"FETCH");
d1475 1
d1577 7
a1583 2
    if (svp && SvIOKp(*svp) && (o = INT2PTR(OP*,SvIVX(*svp))))
	o->op_private = (U8)i;
d1911 1
d1950 7
d1981 10
d2006 5
d2012 1
a2012 1
	DEBUG_x(dump_all());
d2015 1
a2015 1
	 if (*(mg->mg_ptr+1) == '\0') {
d2017 1
a2017 1
	      gMacPerl_OSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d2020 1
a2020 1
	      set_vaxc_errno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2023 1
a2023 1
	      SetLastError( SvIV(sv) );
d2026 1
a2026 1
	      os2_setsyserrno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2028 2
a2029 2
	      /* will anyone ever use this? */
	      SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv), 4);
d2034 12
a2045 7
	 }
	 else if (strEQ(mg->mg_ptr+1, "NCODING")) {
	     if (PL_encoding)
	         sv_setsv(PL_encoding, sv);
	     else
	         PL_encoding = newSVsv(sv);
	 }
d2088 1
a2088 1
    case '\027':	/* ^W & $^WARNING_BITS & ^WIDE_SYSTEM_CALLS */
a2129 2
	else if (strEQ(mg->mg_ptr+1, "IDE_SYSTEM_CALLS"))
	    PL_widesyscalls = (bool)SvTRUE(sv);
d2229 6
d2236 2
a2237 1
		 (SvIV(sv) == EVMSERR) ? 4 : vaxc$errno);
d2254 6
a2259 1
	if (PL_uid == PL_euid)		/* special case $< = $> */
d2261 1
a2261 1
	else {
d2379 1
d2404 7
a2410 21
	if (!PL_origalen) {
	    s = PL_origargv[0];
	    s += strlen(s);
	    /* See if all the arguments are contiguous in memory */
	    for (i = 1; i < PL_origargc; i++) {
		if (PL_origargv[i] == s + 1
#ifdef OS2
		    || PL_origargv[i] == s + 2
#endif
		   )
		{
		    ++s;
		    s += strlen(s);	/* this one is ok too */
		}
		else
		    break;
	    }
	    /* can grab env area too? */
	    if (PL_origenviron
#ifdef USE_ITHREADS
		&& PL_curinterp == aTHX
d2412 1
a2412 14
		&& (PL_origenviron[0] == s + 1))
	    {
		my_setenv("NoNe  SuCh", Nullch);
					    /* force copy of environment */
		for (i = 0; PL_origenviron[i]; i++)
		    if (PL_origenviron[i] == s + 1) {
			++s;
			s += strlen(s);
		    }
		    else
			break;
	    }
	    PL_origalen = s - PL_origargv[0];
	}
d2414 4
a2417 8
	i = len;
	if (i >= (I32)PL_origalen) {
	    i = PL_origalen;
	    /* don't allow system to limit $0 seen by script */
	    /* SvCUR_set(sv, i); *SvEND(sv) = '\0'; */
	    Copy(s, PL_origargv[0], i, char);
	    s = PL_origargv[0]+i;
	    *s = '\0';
d2420 10
a2429 5
	    Copy(s, PL_origargv[0], i, char);
	    s = PL_origargv[0]+i;
	    *s++ = '\0';
	    while (++i < (I32)PL_origalen)
		*s++ = '\0';
d2431 1
a2431 1
		PL_origargv[i] = Nullch;
d2433 1
d2465 1
a2465 1
    for (sigv = PL_sig_name+1; *sigv; sigv++)
d2476 1
a2476 1
    return 0;
d2577 1
a2577 1
	(void)rsignal(sig, &Perl_csighandler);
@


1.6
log
@fix 64bit warnings; ok millert fgsch
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d15 4
d27 3
d32 11
a42 2
static void restore_magic(pTHXo_ void *p);
static void unwind_handler_stack(pTHXo_ void *p);
d61 1
a61 1
    SAVEDESTRUCTOR_X(restore_magic, (void*)(intptr_t)mgs_ix);
d70 1
a70 1
    SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d109 3
a111 4
    I32 mgs_ix;
    MAGIC* mg;
    MAGIC** mgp;
    int mgp_valid = 0;
a112 1
    mgs_ix = SSNEW(sizeof(MGS));
d115 8
a122 3
    mgp = &SvMAGIC(sv);
    while ((mg = *mgp) != 0) {
	MGVTBL* vtbl = mg->mg_virtual;
d125 22
a146 9
	    /* Ignore this magic if it's been deleted */
	    if ((mg == (mgp_valid ? *mgp : SvMAGIC(sv))) &&
		  (mg->mg_flags & MGf_GSKIP))
		(SSPTR(mgs_ix, MGS*))->mgs_flags = 0;
	}
	/* Advance to next magic (complicated by possible deletion) */
	if (mg == (mgp_valid ? *mgp : SvMAGIC(sv))) {
	    mgp = &mg->mg_moremagic;
	    mgp_valid = 1;
a147 2
	else
	    mgp = &SvMAGIC(sv);	/* Re-establish pointer after sv_upgrade */
d150 1
a150 1
    restore_magic(aTHXo_ (void*)(intptr_t)mgs_ix);
d183 1
a183 1
    restore_magic(aTHXo_ (void*)(intptr_t)mgs_ix);
a198 1
    char *junk;
d210 1
a210 1
	    restore_magic(aTHXo_ (void*)(intptr_t)mgs_ix);
d215 7
a221 1
    junk = SvPV(sv, len);
d230 1
a230 1
    
d240 1
a240 1
	    restore_magic(aTHXo_ (void*)(intptr_t)mgs_ix);
d278 1
a278 1
	
d283 1
a283 1
    restore_magic(aTHXo_ (void*)(intptr_t)mgs_ix);
d299 2
d322 5
a326 1
	if (isUPPER(mg->mg_type)) {
d328 3
a330 2
		     mg->mg_type == 'P' ? SvTIED_obj(sv, mg) :
		     (mg->mg_type == 'D' && mg->mg_obj) ? sv : mg->mg_obj,
d356 2
a357 2
	if (mg->mg_ptr && mg->mg_type != 'g')
	    if (mg->mg_len >= 0)
d361 1
d370 1
d380 1
a380 1
    if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d386 1
a386 1
    
d399 1
a399 1
    if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d403 1
a403 1
	if (paren <= rx->nparens &&
d411 8
a418 1
		sv_setiv(sv,i);
d443 1
a443 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d445 1
a445 1
	    paren = atoi(mg->mg_ptr);
d447 1
a447 1
	    if (paren <= rx->nparens &&
d453 2
a454 2
		if (i > 0 && (PL_curpm->op_pmdynflags & PMdf_UTF8) && !IN_BYTE) {
		    char *s = rx->subbeg + s1;
d456 4
a459 5
		    i = 0;
		    while (s < send) {
			s += UTF8SKIP(s);
			i++;
		    }
d461 7
a467 2
		if (i >= 0)
		    return i;
d470 4
d476 1
a476 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d482 7
d490 1
a490 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d502 1
a502 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
a512 4
    case ',':
	return (STRLEN)PL_ofslen;
    case '\\':
	return (STRLEN)PL_orslen;
d541 1
a541 1
	sv_setiv(sv, (IV)(PL_debug & 32767));
d543 1
a543 1
	PL_yydebug = (PL_debug & 1);
d547 1
d549 7
a555 7
	{
	    char msg[256];
	    
	    sv_setnv(sv,(double)gMacPerl_OSErr);
	    sv_setpv(sv, gMacPerl_OSErr ? GetSysErrText(gMacPerl_OSErr, msg) : "");	
	}
#else	
d557 11
a567 11
	{
#	    include <descrip.h>
#	    include <starlet.h>
	    char msg[255];
	    $DESCRIPTOR(msgdsc,msg);
	    sv_setnv(sv,(NV) vaxc$errno);
	    if (sys$getmsg(vaxc$errno,&msgdsc.dsc$w_length,&msgdsc,0,0) & 1)
		sv_setpvn(sv,msgdsc.dsc$a_pointer,msgdsc.dsc$w_length);
	    else
		sv_setpv(sv,"");
	}
d570 12
a581 12
	if (!(_emx_env & 0x200)) {	/* Under DOS */
	    sv_setnv(sv, (NV)errno);
	    sv_setpv(sv, errno ? Strerror(errno) : "");
	} else {
	    if (errno != errno_isOS2) {
		int tmp = _syserrno();
		if (tmp)	/* 2nd call to _syserrno() makes it 0 */
		    Perl_rc = tmp;
	    }
	    sv_setnv(sv, (NV)Perl_rc);
	    sv_setpv(sv, os2error(Perl_rc));
	}
d584 14
a597 14
	{
	    DWORD dwErr = GetLastError();
	    sv_setnv(sv, (NV)dwErr);
	    if (dwErr)
	    {
		PerlProc_GetOSError(sv, dwErr);
	    }
	    else
		sv_setpv(sv, "");
	    SetLastError(dwErr);
	}
#else
	sv_setnv(sv, (NV)errno);
	sv_setpv(sv, errno ? Strerror(errno) : "");
d602 5
a606 2
	SvNOK_on(sv);	/* what a wonderful hack! */
	break;
d619 10
a628 2
    case '\017':		/* ^O */
	sv_setpv(sv, PL_osname);
d639 2
d644 1
d646 1
a646 1
 	sv_setnv(sv, PL_basetime);
d648 1
a648 1
	sv_setiv(sv, (IV)PL_basetime);
d650 4
a653 1
	break;
d657 1
a657 1
	else if (strEQ(mg->mg_ptr, "\027ARNING_BITS")) {
d665 1
a665 1
	    }    
d668 1
a668 1
	    }    
d671 1
a671 1
	else if (strEQ(mg->mg_ptr, "\027IDE_SYSTEM_CALLS"))
d676 1
a676 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d683 1
a683 1
	    paren = atoi(mg->mg_ptr);
d685 1
a685 1
	    if (paren <= rx->nparens &&
d696 1
a696 1
		    bool was_tainted;
d702 1
a702 1
		    if ((PL_curpm->op_pmdynflags & PMdf_UTF8) && !IN_BYTE)
d715 1
a715 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d722 8
d731 1
a731 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d740 1
a740 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d752 1
a752 1
	    sv_setiv(sv, (IV)IoLINES(GvIO(PL_last_in_gv)));
a801 1
	sv_setpvn(sv,PL_ofs,PL_ofslen);
d804 2
a805 1
	sv_setpvn(sv,PL_ors,PL_orslen);
d863 1
a863 1
#ifdef USE_THREADS
d867 1
a867 1
#endif /* USE_THREADS */
d878 1
a878 1
	(*uf->uf_val)(uf->uf_index, sv);
a887 1
    I32 i;
d911 1
a911 1
	    struct stat sbuf;
d939 2
a940 1
		struct stat st;
d993 1
a993 1
#   ifdef PERL_IMPLICIT_SYS
d995 8
a1002 20
#   else
#	ifdef WIN32
    char *envv = GetEnvironmentStrings();
    char *cur = envv;
    STRLEN len;
    while (*cur) {
	char *end = strchr(cur,'=');
	if (end && end != cur) {
	    *end = '\0';
	    my_setenv(cur,Nullch);
	    *end = '=';
	    cur = end + strlen(end+1)+2;
	}
	else if ((len = strlen(cur)))
	    cur += len+1;
    }
    FreeEnvironmentStrings(envv);
#	else
#if !defined(MACOS_TRADITIONAL)
#	    ifndef PERL_USE_SAFE_PUTENV
d1010 1
a1010 1
#	    endif /* PERL_USE_SAFE_PUTENV */
d1013 4
a1016 5

#endif /* !defined(MACOS_TRADITIONAL) */
#	endif /* WIN32 */
#   endif /* PERL_IMPLICIT_SYS */
#endif /* VMS */
d1020 11
d1042 8
a1049 2
    	    Sighandler_t sigstate = rsignal_state(i);

d1081 72
d1158 1
a1158 1
    SV** svp;
d1179 1
a1179 1
		Perl_warner(aTHX_ WARN_SIGNAL, "No such signal: SIG%s", s);
d1182 9
d1200 1
a1200 1
	    (void)rsignal(i, PL_sighandlerp);
d1207 5
a1211 1
	if (i)
d1213 2
a1214 1
	else
d1219 6
d1226 1
d1239 1
a1239 1
	    (void)rsignal(i, PL_sighandlerp);
d1245 1
a1266 1
    HE *entry;
d1270 7
a1276 9
	(void) hv_iterinit(hv);
	if (! SvTIED_mg((SV*)hv, 'P'))
	    i = HvKEYS(hv);
	else {
	    /*SUPPRESS 560*/
	    while ((entry = hv_iternext(hv))) {
		i++;
	    }
	}
d1290 1
a1290 1
}          
d1301 1
a1301 1
    if (n > 1) { 
d1308 1
a1308 1
	else if (mg->mg_type == 'p') {
d1369 1
a1369 1
{         
d1431 1
a1431 1
} 
d1447 1
a1447 1
	o->op_private = i;
d1469 1
a1469 1
    
d1471 1
a1471 1
	mg = mg_find(lsv, 'g');
d1493 1
a1493 1
    
d1495 1
a1495 1
	mg = mg_find(lsv, 'g');
d1499 2
a1500 2
	sv_magic(lsv, (SV*)0, 'g', Nullch, 0);
	mg = mg_find(lsv, 'g');
d1521 1
a1521 1
    else if (pos > len)
d1529 1
a1529 1
	
d1581 1
a1581 1
    if (offs > len)
d1583 1
a1583 1
    if (rem + offs > len)
d1606 1
a1606 1
    else if (SvUTF8(lsv)) {
d1720 1
a1720 1
    if (!LvTARGLEN(sv) || !(mg = mg_find(sv, 'y')))
d1789 1
a1789 1
    sv_unmagic(sv, 'B');
d1797 1
a1797 1
    sv_unmagic(sv, 'f');
d1808 1
a1808 1
	(*uf->uf_set)(uf->uf_index, sv);
d1848 1
a1848 1
	PL_minus_c = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1852 1
a1852 1
	PL_debug = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) | 0x80000000;
d1856 1
d1858 1
a1858 1
	gMacPerl_OSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1861 1
a1861 1
	set_vaxc_errno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1864 1
a1864 1
	SetLastError( SvIV(sv) );
d1866 5
a1870 3
#      ifndef OS2
	/* will anyone ever use this? */
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv), 4);
d1875 7
a1881 1
	break;
d1897 14
a1910 6
	if (PL_osname)
	    Safefree(PL_osname);
	if (SvOK(sv))
	    PL_osname = savepv(SvPV(sv,len));
	else
	    PL_osname = Nullch;
d1928 1
a1928 1
	        PL_dowarn = (PL_dowarn & ~G_WARN_ON) 
d1932 1
a1932 1
	else if (strEQ(mg->mg_ptr, "\027ARNING_BITS")) {
d1953 1
a1953 1
	            }	
d1966 2
a1967 2
	else if (strEQ(mg->mg_ptr, "\027IDE_SYSTEM_CALLS"))
	    PL_widesyscalls = SvTRUE(sv);
d1975 1
a1975 1
	    IoLINES(GvIOp(PL_last_in_gv)) = (long)SvIV(sv);
d1988 1
a1988 1
	IoPAGE_LEN(GvIOp(PL_defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1991 1
a1991 1
	IoLINES_LEFT(GvIOp(PL_defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1996 1
a1996 1
	IoPAGE(GvIOp(PL_defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d2001 2
a2019 2
	SvREFCNT_dec(PL_nrs);
	PL_nrs = newSVsv(sv);
d2021 1
a2021 1
	PL_rs = SvREFCNT_inc(PL_nrs);
d2024 2
a2025 2
	if (PL_ors)
	    Safefree(PL_ors);
d2027 1
a2027 2
	    s = SvPV(sv,PL_orslen);
	    PL_ors = savepvn(s,PL_orslen);
d2030 1
a2030 2
	    PL_ors = Nullch;
	    PL_orslen = 0;
d2034 8
a2041 3
	if (PL_ofs)
	    Safefree(PL_ofs);
	PL_ofs = savepv(SvPV(sv, PL_ofslen));
d2211 1
a2211 1
#   if __FreeBSD_version >= 410001
d2216 1
a2216 1
	    setproctitle("-%s", s, len + 1);
d2237 1
a2237 1
#endif 
d2247 6
a2252 5
	    if (PL_origenviron && (PL_origenviron[0] == s + 1
#ifdef OS2
				|| (PL_origenviron[0] == s + 9 && (s += 8))
#endif 
	       )) {
d2267 1
a2267 1
	if (i >= PL_origalen) {
d2279 2
a2280 3
	    while (++i < PL_origalen)
		*s++ = ' ';
	    s = PL_origargv[0]+i;
d2286 1
a2286 1
#ifdef USE_THREADS
d2290 1
a2290 1
#endif /* USE_THREADS */
d2295 1
a2295 1
#ifdef USE_THREADS
d2301 1
a2301 1
			  PTR2UV(thr), PTR2UV(sv));)
d2308 1
a2308 1
#endif /* USE_THREADS */
d2329 1
d2331 1
d2336 2
a2337 2
#if defined(WIN32) && defined(PERL_IMPLICIT_CONTEXT)
    dTHXoa(PL_curinterp);	/* fake TLS, because signals don't do TLS */
d2344 1
a2344 1
    SV *sv, *tSv = PL_Sv;
a2347 1
    I32 o_save_i = PL_savestack_ix;
a2349 4
#if defined(WIN32) && defined(PERL_IMPLICIT_CONTEXT)
    PERL_SET_THX(aTHXo);	/* fake TLS, see above */
#endif
    
d2359 5
a2363 3
    if (!PL_psig_ptr[sig])
	Perl_die(aTHX_ "Signal SIG%s received, but no signal handler set.\n",
	    PL_sig_name[sig]);
a2368 1
	o_save_i = PL_savestack_ix;
d2371 1
a2371 1
    if (flags & 4) 
d2380 1
a2380 1
    if (!SvROK(PL_psig_ptr[sig]) || !(cv = (CV*)SvRV(PL_psig_ptr[sig])) 
d2386 1
a2386 1
	    Perl_warner(aTHX_ WARN_SIGNAL, "SIG%s handler \"%s\" not defined.\n",
d2397 1
d2399 1
d2410 1
a2410 1
    call_sv((SV*)cv, G_DISCARD);
d2413 19
d2435 1
a2435 1
    if (flags & 4) 
d2437 1
a2437 1
    if (flags & 8) 
d2444 1
a2444 1
    
a2450 4
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

d2452 1
a2452 1
restore_magic(pTHXo_ void *p)
d2493 1
a2493 1
unwind_handler_stack(pTHXo_ void *p)
d2500 1
d2503 1
d2505 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d45 1
a45 1
    SAVEDESTRUCTOR_X(restore_magic, (void*)mgs_ix);
d120 1
a120 1
    restore_magic(aTHXo_ (void*)mgs_ix);
d153 1
a153 1
    restore_magic(aTHXo_ (void*)mgs_ix);
d181 1
a181 1
	    restore_magic(aTHXo_ (void*)mgs_ix);
d205 1
a205 1
	    restore_magic(aTHXo_ (void*)mgs_ix);
d248 1
a248 1
    restore_magic(aTHXo_ (void*)mgs_ix);
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a18 5
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
# include <unistd.h>
#endif

a41 1
    dTHR;
a92 1
    dTHR;
a134 1
    dTHR;
d287 2
a288 1
		     mg->mg_type == 'P' ? SvTIED_obj(sv, mg) : mg->mg_obj,
a333 1
    dTHR;
a348 1
    dTHR;
d373 8
a383 1
    dTHR;
a464 1
    dTHR;
d489 2
a490 2
	    sv_setnv(sv,(double)gLastMacOSErr);
	    sv_setpv(sv, gLastMacOSErr ? GetSysErrText(gLastMacOSErr, msg) : "");	
a560 1
	    dTHR;
d564 1
a564 3
		sv_setiv(sv, 1);
	    else
		sv_setiv(sv, 0);
d611 3
a883 1
    dTHR;
d902 1
a902 1
#if defined(VMS)
a923 5
#   else
#	ifdef __CYGWIN__
    I32 i;
    for (i = 0; environ[i]; i++)
       safesysfree(environ[i]);
d925 1
a934 1
#	endif /* __CYGWIN__ */
d938 1
a991 1
    dTHR;
a1252 1
    dTHR;
a1264 2
    else if (ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL, "Can't break at that line\n");
a1270 1
    dTHR;
a1277 1
    dTHR;
a1289 1
	    dTHR;
a1307 1
    dTHR;
d1396 2
d1403 2
d1412 20
a1431 2
    char *tmps = SvPV(sv,len);
    sv_insert(LvTARG(sv),LvTARGOFF(sv),LvTARGLEN(sv), tmps, len);
a1437 1
    dTHR;
a1445 1
    dTHR;
a1503 1
	    dTHR;		/* just for SvREFCNT_dec */
a1533 1
    dTHR;			/* just for SvREFCNT_inc and SvREFCNT_dec*/
a1656 1
    dTHR;
d1674 1
a1674 1
	gLastMacOSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1739 1
a1739 5
                if (isWARN_on(sv, WARN_ALL)) {
	            PL_compiling.cop_warnings = pWARN_ALL;
	            PL_dowarn |= G_WARN_ONCE ;
	        }	
		else {
d1742 1
d1744 4
a1747 2
		    for (i = 0 ; i < len ; ++i) 
		        accumulate += ptr[i] ;
d1750 4
d1762 1
d2002 24
a2095 1
    dTHR;
d2131 3
d2135 1
d2145 4
a2235 1
    dTHR;
a2276 1
    dTHR;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
d30 3
a36 5
#ifdef PERL_OBJECT

#define VTBL            this->*vtbl

#else
d40 1
d42 1
a42 6
typedef struct magic_state MGS;

static void restore_magic _((void *p));
#define VTBL			*vtbl

#endif
d45 1
a45 1
save_magic(MGS *mgs, SV *sv)
d47 2
d51 3
d56 1
a56 1
    SAVEDESTRUCTOR(restore_magic, mgs);
d63 4
a66 5
STATIC void
restore_magic(void *p)
{
    MGS* mgs = (MGS*)p;
    SV* sv = mgs->mgs_sv;
d68 2
a69 10
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv))
    {
	if (mgs->mgs_flags)
	    SvFLAGS(sv) |= mgs->mgs_flags;
	else
	    mg_magical(sv);
	if (SvGMAGICAL(sv))
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
    }
}
d72 1
a72 1
mg_magical(SV *sv)
d78 1
a78 1
	    if ((vtbl->svt_get != NULL) && !(mg->mg_flags & MGf_GSKIP))
d82 1
a82 1
	    if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)) || (vtbl->svt_clear != NULL))
d88 8
d97 1
a97 1
mg_get(SV *sv)
d99 2
a100 1
    MGS mgs;
d105 2
a106 2
    ENTER;
    save_magic(&mgs, sv);
d111 2
a112 2
	if (!(mg->mg_flags & MGf_GSKIP) && vtbl && (vtbl->svt_get != NULL)) {
	    (VTBL->svt_get)(sv, mg);
d116 1
a116 1
		mgs.mgs_flags = 0;
d127 1
a127 1
    LEAVE;
d131 8
d140 1
a140 1
mg_set(SV *sv)
d142 2
a143 1
    MGS mgs;
d147 2
a148 2
    ENTER;
    save_magic(&mgs, sv);
d155 1
a155 1
	    mgs.mgs_flags = 0;
d157 2
a158 2
	if (vtbl && (vtbl->svt_set != NULL))
	    (VTBL->svt_set)(sv, mg);
d161 1
a161 1
    LEAVE;
d165 8
d174 1
a174 1
mg_length(SV *sv)
d182 2
a183 2
	if (vtbl && (vtbl->svt_len != NULL)) {
	    MGS mgs;
d185 2
a186 2
	    ENTER;
	    save_magic(&mgs, sv);
d188 2
a189 2
	    len = (VTBL->svt_len)(sv, mg);
	    LEAVE;
d199 1
a199 1
mg_size(SV *sv)
d206 5
a210 3
	if (vtbl && (vtbl->svt_len != NULL)) {
	    MGS mgs;
	    ENTER;
d212 2
a213 2
	    len = (VTBL->svt_len)(sv, mg);
	    LEAVE;
d225 1
a225 1
	    croak("Size magic not implemented");
d231 8
d240 1
a240 1
mg_clear(SV *sv)
d242 1
a242 1
    MGS mgs;
d245 2
a246 2
    ENTER;
    save_magic(&mgs, sv);
d252 2
a253 2
	if (vtbl && (vtbl->svt_clear != NULL))
	    (VTBL->svt_clear)(sv, mg);
d256 1
a256 1
    LEAVE;
d260 8
d269 1
a269 1
mg_find(SV *sv, int type)
d279 8
d288 1
a288 1
mg_copy(SV *sv, SV *nsv, char *key, I32 klen)
d303 8
d312 1
a312 1
mg_free(SV *sv)
d319 2
a320 2
	if (vtbl && (vtbl->svt_free != NULL))
	    (VTBL->svt_free)(sv, mg);
d339 45
a383 1
magic_len(SV *sv, MAGIC *mg)
a386 1
    register char *s;
d389 1
a389 1
    char *t;
d395 1
d399 2
a400 2
		(s = rx->startp[paren]) &&
		(t = rx->endp[paren]))
d402 11
a412 1
		i = t - s;
d427 7
a433 4
	    if ((s = rx->subbeg) && rx->startp[0]) {
		i = rx->startp[0] - s;
		if (i >= 0)
		    return i;
d439 7
a445 4
	    if (rx->subend && (s = rx->endp[0])) {
		i = rx->subend - s;
		if (i >= 0)
		    return i;
d465 1
a465 1
magic_get(SV *sv, MAGIC *mg)
a471 1
    char *t;
d480 1
d483 3
d488 8
d502 1
a502 1
	    sv_setnv(sv,(double) vaxc$errno);
d511 1
a511 1
	    sv_setnv(sv, (double)errno);
d519 1
a519 1
	    sv_setnv(sv, (double)Perl_rc);
d526 1
a526 1
	    sv_setnv(sv, (double)dwErr);
d529 1
a529 9
#ifdef PERL_OBJECT
		char *sMsg;
		DWORD dwLen;
		PerlProc_GetSysMsg(sMsg, dwLen, dwErr);
		sv_setpvn(sv, sMsg, dwLen);
		PerlProc_FreeBuf(sMsg);
#else
		win32_str_os_error(sv, dwErr);
#endif
d536 1
a536 1
	sv_setnv(sv, (double)errno);
d541 1
d566 1
a566 1
		SvOK_off(sv);
d580 19
a598 2
    case '\027':		/* ^W */
	sv_setiv(sv, (IV)PL_dowarn);
d603 2
d612 2
a613 2
		(s = rx->startp[paren]) &&
		(t = rx->endp[paren]))
d615 2
a616 1
		i = t - s;
d624 5
a628 1
		    sv_setpvn(sv,s,i);
d647 2
a648 2
	    if ((s = rx->subbeg) && rx->startp[0]) {
		i = rx->startp[0] - s;
d656 3
a658 2
	    if (rx->subend && (s = rx->endp[0])) {
		i = rx->subend - s;
d727 1
a727 1
	sv_setnv(sv, (double)((errno == EVMSERR) ? vaxc$errno : errno));
d732 1
a732 1
	sv_setnv(sv, (double)errno);
d734 2
a735 1
	if (errno == errno_isOS2) sv_setpv(sv, os2error(Perl_rc));
d752 3
a754 1
	sv_setpvf(sv, "%Vd", (IV)PL_gid);
d758 3
a760 1
	sv_setpvf(sv, "%Vd", (IV)PL_egid);
d767 1
a767 1
		sv_catpvf(sv, " %Vd", (IV)gary[i]);
d770 1
a770 1
	SvIOK_on(sv);	/* what a wonderful hack! */
d774 1
d777 1
d788 1
a788 1
magic_getuvar(SV *sv, MAGIC *mg)
d798 1
a798 1
magic_setenv(SV *sv, MAGIC *mg)
d874 1
a874 1
magic_clearenv(SV *sv, MAGIC *mg)
d882 1
a882 1
magic_set_all_env(SV *sv, MAGIC *mg)
d885 1
a885 1
    die("Can't make list assignment to %%ENV on this system");
d893 1
a893 1
	while (entry = hv_iternext((HV*)sv)) {
d904 1
a904 1
magic_clear_all_env(SV *sv, MAGIC *mg)
d907 1
a907 1
    die("Can't make list assignment to %%ENV on this system");
d909 4
a912 1
#ifdef WIN32
d928 7
a934 1
#else
d938 1
a938 1
	New(901, environ, 1, char*);
d941 4
a944 1
	    Safefree(environ[i]);
d947 3
a949 2
#endif
#endif
d954 1
a954 1
magic_getsig(SV *sv, MAGIC *mg)
d961 2
a962 2
    	if(psig_ptr[i])
    	    sv_setsv(sv,psig_ptr[i]);
d971 1
a971 1
    	    psig_ptr[i] = SvREFCNT_inc(sv);
d978 1
a978 1
magic_clearsig(SV *sv, MAGIC *mg)
d985 3
a987 3
    	if(psig_ptr[i]) {
    	    SvREFCNT_dec(psig_ptr[i]);
    	    psig_ptr[i]=0;
d989 3
a991 3
    	if(psig_name[i]) {
    	    SvREFCNT_dec(psig_name[i]);
    	    psig_name[i]=0;
d998 1
a998 1
magic_setsig(SV *sv, MAGIC *mg)
d1004 1
a1004 1
    STRLEN n_a;
d1006 1
a1006 1
    s = MgPV(mg,n_a);
a1011 2
	else if (strEQ(s,"__PARSE__"))
	    svp = &PL_parsehook;
d1013 1
a1013 1
	    croak("No such hook: %s", s);
d1023 2
a1024 2
	    if (PL_dowarn || strEQ(s,"ALARM"))
		warn("No such signal: SIG%s", s);
d1027 3
a1029 3
	SvREFCNT_dec(psig_name[i]);
	SvREFCNT_dec(psig_ptr[i]);
	psig_ptr[i] = SvREFCNT_inc(sv);
d1031 2
a1032 2
	psig_name[i] = newSVpv(s, strlen(s));
	SvREADONLY_on(psig_name[i]);
d1041 1
a1041 1
    s = SvPV_force(sv,n_a);
d1061 1
a1061 1
	    sv_setpv(sv, form("main::%s", s));
d1071 1
a1071 1
magic_setisa(SV *sv, MAGIC *mg)
a1076 2
#ifdef OVERLOAD

d1078 1
a1078 1
magic_setamagic(SV *sv, MAGIC *mg)
a1084 1
#endif /* OVERLOAD */
d1087 1
a1087 1
magic_getnkeys(SV *sv, MAGIC *mg)
d1099 1
a1099 1
	    while (entry = hv_iternext(hv)) {
d1110 1
a1110 1
magic_setnkeys(SV *sv, MAGIC *mg)
d1120 1
a1120 1
magic_methcall(SV *sv, MAGIC *mg, char *meth, I32 flags, int n, SV *val)
d1130 1
a1130 1
		PUSHs(sv_2mortal(newSVpv(mg->mg_ptr, mg->mg_len)));
d1143 1
a1143 1
    return perl_call_method(meth, flags);
d1147 1
a1147 1
magic_methpack(SV *sv, MAGIC *mg, char *meth)
d1166 1
a1166 1
magic_getpack(SV *sv, MAGIC *mg)
d1175 1
a1175 1
magic_setpack(SV *sv, MAGIC *mg)
d1187 1
a1187 1
magic_clearpack(SV *sv, MAGIC *mg)
d1194 1
a1194 1
magic_sizepack(SV *sv, MAGIC *mg)
d1212 2
a1213 1
int magic_wipepack(SV *sv, MAGIC *mg)
d1222 1
a1222 1
    perl_call_method("CLEAR", G_SCALAR|G_DISCARD);
d1229 1
a1229 1
magic_nextpack(SV *sv, MAGIC *mg, SV *key)
d1232 1
a1232 1
    char *meth = SvOK(key) ? "NEXTKEY" : "FIRSTKEY";
d1244 1
a1244 1
    if (perl_call_method(meth, G_SCALAR))
d1254 1
a1254 1
magic_existspack(SV *sv, MAGIC *mg)
d1260 1
a1260 1
magic_setdbline(SV *sv, MAGIC *mg)
d1273 1
a1273 1
    if (svp && SvIOKp(*svp) && (o = (OP*)SvSTASH(*svp)))
d1275 2
a1276 2
    else
	warn("Can't break at that line\n");
d1281 1
a1281 1
magic_getarylen(SV *sv, MAGIC *mg)
d1289 1
a1289 1
magic_setarylen(SV *sv, MAGIC *mg)
d1297 1
a1297 1
magic_getpos(SV *sv, MAGIC *mg)
d1305 4
a1308 1
	    sv_setiv(sv, mg->mg_len + PL_curcop->cop_arybase);
d1317 1
a1317 1
magic_setpos(SV *sv, MAGIC *mg)
d1322 2
d1341 8
a1348 1
    WITH_THR(pos = SvIV(sv) - PL_curcop->cop_arybase);
d1356 7
d1370 1
a1370 1
magic_getglob(SV *sv, MAGIC *mg)
d1383 1
a1383 1
magic_setglob(SV *sv, MAGIC *mg)
d1404 1
a1404 1
magic_getsubstr(SV *sv, MAGIC *mg)
d1421 1
a1421 1
magic_setsubstr(SV *sv, MAGIC *mg)
d1430 1
a1430 1
magic_gettaint(SV *sv, MAGIC *mg)
d1434 1
a1434 1
	     (mg->mg_len & 2) && mg->mg_obj == sv);	/* kludge */
d1439 1
a1439 1
magic_settaint(SV *sv, MAGIC *mg)
d1456 1
a1456 1
magic_getvec(SV *sv, MAGIC *mg)
a1458 6
    unsigned char *s;
    unsigned long retnum;
    STRLEN lsvlen;
    I32 len;
    I32 offset;
    I32 size;
d1461 1
a1461 1
	SvOK_off(sv);
a1463 46
    s = (unsigned char *) SvPV(lsv, lsvlen);
    offset = LvTARGOFF(sv);
    size = LvTARGLEN(sv);
    len = (offset + size + 7) / 8;

    /* Copied from pp_vec() */

    if (len > lsvlen) {
	if (size <= 8)
	    retnum = 0;
	else {
	    offset >>= 3;
	    if (size == 16) {
		if (offset >= lsvlen)
		    retnum = 0;
		else
		    retnum = (unsigned long) s[offset] << 8;
	    }
	    else if (size == 32) {
		if (offset >= lsvlen)
		    retnum = 0;
		else if (offset + 1 >= lsvlen)
		    retnum = (unsigned long) s[offset] << 24;
		else if (offset + 2 >= lsvlen)
		    retnum = ((unsigned long) s[offset] << 24) +
			((unsigned long) s[offset + 1] << 16);
		else
		    retnum = ((unsigned long) s[offset] << 24) +
			((unsigned long) s[offset + 1] << 16) +
			(s[offset + 2] << 8);
	    }
	}
    }
    else if (size < 8)
	retnum = (s[offset >> 3] >> (offset & 7)) & ((1 << size) - 1);
    else {
	offset >>= 3;
	if (size == 8)
	    retnum = s[offset];
	else if (size == 16)
	    retnum = ((unsigned long) s[offset] << 8) + s[offset+1];
	else if (size == 32)
	    retnum = ((unsigned long) s[offset] << 24) +
		((unsigned long) s[offset + 1] << 16) +
		(s[offset + 2] << 8) + s[offset+3];
    }
d1465 1
a1465 1
    sv_setuv(sv, (UV)retnum);
d1470 1
a1470 1
magic_setvec(SV *sv, MAGIC *mg)
d1477 1
a1477 1
magic_getdefelem(SV *sv, MAGIC *mg)
d1517 1
a1517 1
magic_setdefelem(SV *sv, MAGIC *mg)
d1529 1
a1529 1
vivify_defelem(SV *sv)
d1539 1
d1550 2
a1551 4
	if (!value || value == &PL_sv_undef) {
	    STRLEN n_a;
	    croak(no_helem, SvPV(mg->mg_obj, n_a));
	}
d1560 1
a1560 1
		croak(no_aelem, (I32)LvTARGOFF(sv));
d1573 22
a1594 1
magic_setmglob(SV *sv, MAGIC *mg)
d1602 1
a1602 1
magic_setbm(SV *sv, MAGIC *mg)
d1610 1
a1610 1
magic_setfm(SV *sv, MAGIC *mg)
d1618 1
a1618 1
magic_setuvar(SV *sv, MAGIC *mg)
d1628 1
a1628 1
magic_freeregexp(SV *sv, MAGIC *mg)
d1637 1
a1637 1
magic_setcollxfrm(SV *sv, MAGIC *mg)
d1640 1
a1640 1
     * Ren Descartes said "I think not."
d1653 1
a1653 1
magic_set(SV *sv, MAGIC *mg)
d1666 1
d1672 4
a1675 1
#ifdef VMS
d1677 2
a1678 2
#else
#ifdef WIN32
d1680 2
a1681 1
#else
d1684 3
a1686 1
#endif
d1713 2
d1723 40
a1762 2
    case '\027':	/* ^W */
	PL_dowarn = (bool)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1767 1
a1767 1
		save_sptr((SV**)&PL_last_in_gv);
d1821 4
a1824 2
	if (SvOK(sv) || SvGMAGICAL(sv))
	    PL_ors = savepv(SvPV(sv,PL_orslen));
d1880 2
a1881 2
	    PL_uid = (I32)PerlProc_getuid();
	    croak("setruid() not implemented");
d1886 1
a1886 1
	PL_uid = (I32)PerlProc_getuid();
d1907 2
a1908 2
	    PL_euid = (I32)PerlProc_geteuid();
	    croak("seteuid() not implemented");
d1913 1
a1913 1
	PL_euid = (I32)PerlProc_geteuid();
d1934 2
a1935 2
	    PL_gid = (I32)PerlProc_getgid();
	    croak("setrgid() not implemented");
d1940 1
a1940 1
	PL_gid = (I32)PerlProc_getgid();
a1948 1
	    SET_NUMERIC_STANDARD();
d1951 1
a1951 1
	    PL_egid = I_V(atof(p));
d1959 1
a1959 1
		gary[i] = I_V(atof(p));
d1983 2
a1984 2
	    PL_egid = (I32)PerlProc_getegid();
	    croak("setegid() not implemented");
d1989 1
a1989 1
	PL_egid = (I32)PerlProc_getegid();
d1995 1
d2053 1
d2065 1
a2065 1
magic_mutexfree(SV *sv, MAGIC *mg)
d2068 3
a2070 2
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "0x%lx: magic_mutexfree 0x%lx\n",
			  (unsigned long)thr, (unsigned long)sv);)
d2072 1
a2072 1
	croak("panic: magic_mutexfree");
d2080 1
a2080 1
whichsig(char *sig)
d2084 1
a2084 1
    for (sigv = sig_name+1; *sigv; sigv++)
d2086 1
a2086 1
	    return sig_num[sigv - sig_name];
a2099 13
STATIC void
unwind_handler_stack(void *p)
{
    dTHR;
    U32 flags = *(U32*)p;

    if (flags & 1)
	PL_savestack_ix -= 5; /* Unprotect save in progress. */
    /* cxstack_ix-- Not needed, die already unwound it. */
    if (flags & 64)
	SvREFCNT_dec(sig_sv);
}

d2101 1
a2101 1
sighandler(int sig)
d2103 1
d2111 1
a2111 1
    I32 o_save_i = PL_savestack_ix, type;
d2123 3
a2125 3
    if (!psig_ptr[sig])
	die("Signal SIG%s received, but no signal handler set.\n",
	    sig_name[sig]);
d2132 1
a2132 1
	SAVEDESTRUCTOR(unwind_handler_stack, (void*)&flags);
d2143 1
a2143 1
    if (!SvROK(psig_ptr[sig]) || !(cv = (CV*)SvRV(psig_ptr[sig])) 
d2145 1
a2145 1
	cv = sv_2cv(psig_ptr[sig],&st,&gv,TRUE);
d2148 3
a2150 3
	if (PL_dowarn)
	    warn("SIG%s handler \"%s\" not defined.\n",
		sig_name[sig], (gv ? GvENAME(gv)
d2157 2
a2158 2
    if(psig_name[sig]) {
    	sv = SvREFCNT_inc(psig_name[sig]);
d2163 1
a2163 1
	sv_setpv(sv,sig_name[sig]);
d2171 1
a2171 1
    perl_call_sv((SV*)cv, G_DISCARD);
d2193 58
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d33 5
d45 1
d47 4
a50 4
static void
save_magic(mgs, sv)
MGS* mgs;
SV* sv;
d63 2
a64 3
static void
restore_magic(p)
void* p;
a79 1

d81 1
a81 2
mg_magical(sv)
SV* sv;
d87 1
a87 1
	    if (vtbl->svt_get && !(mg->mg_flags & MGf_GSKIP))
d91 1
a91 1
	    if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)) || vtbl->svt_clear)
d98 1
a98 2
mg_get(sv)
SV* sv;
d111 2
a112 2
	if (!(mg->mg_flags & MGf_GSKIP) && vtbl && vtbl->svt_get) {
	    (*vtbl->svt_get)(sv, mg);
d132 1
a132 2
mg_set(sv)
SV* sv;
d148 2
a149 2
	if (vtbl && vtbl->svt_set)
	    (*vtbl->svt_set)(sv, mg);
d157 1
a157 2
mg_len(sv)
SV* sv;
d165 1
a165 1
	if (vtbl && vtbl->svt_len) {
d171 1
a171 1
	    len = (*vtbl->svt_len)(sv, mg);
d181 31
d213 1
a213 2
mg_clear(sv)
SV* sv;
d225 2
a226 2
	if (vtbl && vtbl->svt_clear)
	    (*vtbl->svt_clear)(sv, mg);
d234 1
a234 3
mg_find(sv, type)
SV* sv;
int type;
d245 1
a245 5
mg_copy(sv, nsv, key, klen)
SV* sv;
SV* nsv;
char *key;
I32 klen;
d251 3
a253 1
	    sv_magic(nsv, mg->mg_obj, toLOWER(mg->mg_type), key, klen);
d261 1
a261 2
mg_free(sv)
SV* sv;
d268 2
a269 2
	if (vtbl && vtbl->svt_free)
	    (*vtbl->svt_free)(sv, mg);
d288 1
a288 3
magic_len(sv, mg)
SV *sv;
MAGIC *mg;
d290 1
d300 1
a300 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d314 1
a314 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d321 1
a321 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d330 1
a330 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d339 1
a339 1
	return (STRLEN)ofslen;
d341 1
a341 1
	return (STRLEN)orslen;
d344 4
a347 2
    if (!SvPOK(sv) && SvNIOK(sv))
	sv_2pv(sv, &na);
d354 1
a354 3
magic_get(sv, mg)
SV *sv;
MAGIC *mg;
d356 1
d365 4
a368 1
	sv_setsv(sv, bodytarget);
d371 1
a371 1
	sv_setiv(sv, (IV)(debug & 32767));
d392 5
a396 2
	    if (errno != errno_isOS2)
		Perl_rc = _syserrno();
d401 21
d426 1
d430 1
a430 1
	sv_setiv(sv, (IV)maxsysfd);
d433 1
a433 1
	sv_setiv(sv, (IV)hints);
d435 3
a437 3
    case '\t':			/* ^I */
	if (inplace)
	    sv_setpv(sv, inplace);
d439 1
a439 1
	    sv_setsv(sv, &sv_undef);
d442 1
a442 1
	sv_setpv(sv, osname);
d445 1
a445 1
	sv_setiv(sv, (IV)perldb);
d448 9
a456 6
	if (lex_state != LEX_NOTPARSING)
	    SvOK_off(sv);
	else if (in_eval)
	    sv_setiv(sv, 1);
	else
	    sv_setiv(sv, 0);
d460 1
a460 1
 	sv_setnv(sv, basetime);
d462 1
a462 1
	sv_setiv(sv, (IV)basetime);
d466 1
a466 1
	sv_setiv(sv, (IV)dowarn);
d470 6
a475 2
	if (curpm && (rx = curpm->op_pmregexp)) {
	    paren = atoi(GvENAME((GV*)mg->mg_obj));
d485 3
a487 3
		    if (tainting) {
			was_tainted = tainted;
			tainted = FALSE;
d490 2
a491 2
		    if (tainting)
			tainted = was_tainted || rx->exec_tainted;
d496 1
a496 1
	sv_setsv(sv,&sv_undef);
d499 1
a499 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d504 1
a504 1
	sv_setsv(sv,&sv_undef);
d507 1
a507 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d513 1
a513 1
	sv_setsv(sv,&sv_undef);
d516 1
a516 1
	if (curpm && (rx = curpm->op_pmregexp)) {
d522 1
a522 1
	sv_setsv(sv,&sv_undef);
d526 2
a527 2
	if (GvIO(last_in_gv)) {
	    sv_setiv(sv, (IV)IoLINES(GvIO(last_in_gv)));
d532 2
a533 1
	sv_setiv(sv, (IV)STATUS_CURRENT);
d535 2
a536 2
	LvTARGOFF(sv) = statusvalue;
	LvTARGLEN(sv) = statusvalue_vms;
d538 1
d541 1
a541 1
	s = IoTOP_NAME(GvIOp(defoutgv));
d545 1
a545 1
	    sv_setpv(sv,GvENAME(defoutgv));
d550 1
a550 1
	s = IoFMT_NAME(GvIOp(defoutgv));
d552 1
a552 1
	    s = GvENAME(defoutgv);
d557 1
a557 1
	sv_setiv(sv, (IV)IoPAGE_LEN(GvIOp(defoutgv)));
d560 1
a560 1
	sv_setiv(sv, (IV)IoLINES_LEFT(GvIOp(defoutgv)));
d563 1
a563 1
	sv_setiv(sv, (IV)IoPAGE(GvIOp(defoutgv)));
d571 1
a571 1
	sv_setiv(sv, (IV)curcop->cop_arybase);
d574 1
a574 1
	sv_setiv(sv, (IV)(IoFLAGS(GvIOp(defoutgv)) & IOf_FLUSH) != 0 );
d577 1
a577 1
	sv_setpvn(sv,ofs,ofslen);
d580 1
a580 1
	sv_setpvn(sv,ors,orslen);
d583 1
a583 1
	sv_setpv(sv,ofmt);
d604 1
a604 1
	sv_setiv(sv, (IV)uid);
d607 1
a607 1
	sv_setiv(sv, (IV)euid);
d610 2
a611 2
	sv_setiv(sv, (IV)gid);
	sv_setpvf(sv, "%Vd", (IV)gid);
d614 2
a615 2
	sv_setiv(sv, (IV)egid);
	sv_setpvf(sv, "%Vd", (IV)egid);
d631 5
d641 1
a641 3
magic_getuvar(sv, mg)
SV *sv;
MAGIC *mg;
d651 1
a651 3
magic_setenv(sv,mg)
SV* sv;
MAGIC* mg;
d667 1
a667 1
	if ((valp = hv_fetch(GvHVn(envgv), ptr, klen, FALSE)))
d672 1
a672 1
#if !defined(OS2) && !defined(AMIGAOS) && !defined(WIN32)
d675 1
a675 1
    if (tainting) {
d707 1
d709 1
a709 1
		s = delimcpy(tokenbuf, tokenbuf + sizeof tokenbuf,
d712 3
a714 3
		if (i >= sizeof tokenbuf   /* too long -- assume the worst */
		      || *tokenbuf != '/'
		      || (Stat(tokenbuf, &st) == 0 && (st.st_mode & 2)) ) {
d721 1
a721 1
#endif /* neither OS2 nor AMIGAOS nor WIN32 */
d727 1
a727 3
magic_clearenv(sv,mg)
SV* sv;
MAGIC* mg;
d729 2
a730 1
    my_setenv(MgPV(mg,na),Nullch);
d735 1
a735 3
magic_set_all_env(sv,mg)
SV* sv;
MAGIC* mg;
d740 2
a741 1
    if (localizing) {
d743 1
d749 1
a749 1
		      SvPV(hv_iterval((HV*)sv, entry), na));
d757 1
a757 3
magic_clear_all_env(sv,mg)
SV* sv;
MAGIC* mg;
d772 1
a772 1
	    cur += strlen(end+1)+1;
d781 1
a781 1
    if (environ == origenviron)
d794 1
a794 3
magic_getsig(sv,mg)
SV* sv;
MAGIC* mg;
d797 1
d799 1
a799 1
    i = whichsig(MgPV(mg,na));
d810 1
a810 1
    	    	sv_setsv(sv,&sv_undef);
d818 1
a818 3
magic_clearsig(sv,mg)
SV* sv;
MAGIC* mg;
d821 1
d823 1
a823 1
    i = whichsig(MgPV(mg,na));
d838 1
a838 3
magic_setsig(sv,mg)
SV* sv;
MAGIC* mg;
d840 1
d844 1
d846 1
a846 1
    s = MgPV(mg,na);
d849 1
a849 1
	    svp = &diehook;
d851 1
a851 1
	    svp = &warnhook;
d853 1
a853 1
	    svp = &parsehook;
d865 1
a865 1
	    if (dowarn || strEQ(s,"ALARM"))
d878 1
a878 1
	    (void)rsignal(i, sighandler);
d883 1
a883 1
    s = SvPV_force(sv,na);
d905 1
a905 1
	    (void)rsignal(i, sighandler);
d913 1
a913 3
magic_setisa(sv,mg)
SV* sv;
MAGIC* mg;
d915 1
a915 1
    sub_generation++;
d922 1
a922 3
magic_setamagic(sv,mg)
SV* sv;
MAGIC* mg;
d925 1
a925 1
    amagic_generation++;
d932 24
a955 3
magic_setnkeys(sv,mg)
SV* sv;
MAGIC* mg;
a958 1
	LvTARG(sv) = Nullsv;	/* Don't allow a ref to reassign this. */
d961 28
d991 2
a992 5
static int
magic_methpack(sv,mg,meth)
SV* sv;
MAGIC* mg;
char *meth;
d998 4
a1001 8
    PUSHMARK(sp);
    EXTEND(sp, 2);
    PUSHs(mg->mg_obj);
    if (mg->mg_ptr) {
	if (mg->mg_len >= 0)
	    PUSHs(sv_2mortal(newSVpv(mg->mg_ptr, mg->mg_len)));
	else if (mg->mg_len == HEf_SVKEY)
	    PUSHs((SV*)mg->mg_ptr);
a1002 6
    else if (mg->mg_type == 'p')
	PUSHs(sv_2mortal(newSViv(mg->mg_len)));
    PUTBACK;

    if (perl_call_method(meth, G_SCALAR))
	sv_setsv(sv, *stack_sp--);
d1004 1
d1011 1
a1011 3
magic_getpack(sv,mg)
SV* sv;
MAGIC* mg;
d1020 1
a1020 3
magic_setpack(sv,mg)
SV* sv;
MAGIC* mg;
d1023 5
a1027 17

    PUSHMARK(sp);
    EXTEND(sp, 3);
    PUSHs(mg->mg_obj);
    if (mg->mg_ptr) {
	if (mg->mg_len >= 0)
	    PUSHs(sv_2mortal(newSVpv(mg->mg_ptr, mg->mg_len)));
	else if (mg->mg_len == HEf_SVKEY)
	    PUSHs((SV*)mg->mg_ptr);
    }
    else if (mg->mg_type == 'p')
	PUSHs(sv_2mortal(newSViv(mg->mg_len)));
    PUSHs(sv);
    PUTBACK;

    perl_call_method("STORE", G_SCALAR|G_DISCARD);

d1032 1
a1032 3
magic_clearpack(sv,mg)
SV* sv;
MAGIC* mg;
d1037 21
a1057 3
int magic_wipepack(sv,mg)
SV* sv;
MAGIC* mg;
d1061 4
a1064 2
    PUSHMARK(sp);
    XPUSHs(mg->mg_obj);
a1065 1

d1067 2
a1068 1

d1073 1
a1073 4
magic_nextpack(sv,mg,key)
SV* sv;
MAGIC* mg;
SV* key;
d1080 4
a1083 3
    PUSHMARK(sp);
    EXTEND(sp, 2);
    PUSHs(mg->mg_obj);
d1089 1
a1089 1
	sv_setsv(key, *stack_sp--);
d1091 1
d1098 1
a1098 3
magic_existspack(sv,mg)
SV* sv;
MAGIC* mg;
d1104 1
a1104 3
magic_setdbline(sv,mg)
SV* sv;
MAGIC* mg;
d1106 1
d1111 1
d1113 1
a1113 1
    gv = DBline;
d1116 1
a1116 1
		     atoi(MgPV(mg,na)), FALSE);
d1125 1
a1125 3
magic_getarylen(sv,mg)
SV* sv;
MAGIC* mg;
d1127 2
a1128 1
    sv_setiv(sv, AvFILL((AV*)mg->mg_obj) + curcop->cop_arybase);
d1133 1
a1133 3
magic_setarylen(sv,mg)
SV* sv;
MAGIC* mg;
d1135 2
a1136 1
    av_fill((AV*)mg->mg_obj, SvIV(sv) - curcop->cop_arybase);
d1141 1
a1141 3
magic_getpos(sv,mg)
SV* sv;
MAGIC* mg;
d1148 2
a1149 1
	    sv_setiv(sv, mg->mg_len + curcop->cop_arybase);
d1158 1
a1158 3
magic_setpos(sv,mg)
SV* sv;
MAGIC* mg;
d1180 1
a1180 1
    pos = SvIV(sv) - curcop->cop_arybase;
d1195 1
a1195 3
magic_getglob(sv,mg)
SV* sv;
MAGIC* mg;
d1208 1
a1208 3
magic_setglob(sv,mg)
SV* sv;
MAGIC* mg;
d1212 1
d1216 1
a1216 1
    s = SvPV(sv, na);
d1229 18
a1246 3
magic_setsubstr(sv,mg)
SV* sv;
MAGIC* mg;
d1255 1
a1255 3
magic_gettaint(sv,mg)
SV* sv;
MAGIC* mg;
d1257 1
d1264 1
a1264 3
magic_settaint(sv,mg)
SV* sv;
MAGIC* mg;
d1266 3
a1268 2
    if (localizing) {
	if (localizing == 1)
d1273 1
a1273 1
    else if (tainted)
d1281 67
a1347 3
magic_setvec(sv,mg)
SV* sv;
MAGIC* mg;
d1354 1
a1354 3
magic_getdefelem(sv,mg)
SV* sv;
MAGIC* mg;
d1359 11
a1369 4
	    HV* hv = (HV*)LvTARG(sv);
	    HE* he = hv_fetch_ent(hv, mg->mg_obj, FALSE, 0);
	    if (he)
		targ = HeVAL(he);
d1376 2
a1377 1
	if (targ && targ != &sv_undef) {
d1389 1
a1389 1
    sv_setsv(sv, targ ? targ : &sv_undef);
d1394 1
a1394 3
magic_setdefelem(sv,mg)
SV* sv;
MAGIC* mg;
a1404 9
int
magic_freedefelem(sv,mg)
SV* sv;
MAGIC* mg;
{
    SvREFCNT_dec(LvTARG(sv));
    return 0;
}

d1406 1
a1406 2
vivify_defelem(sv)
SV* sv;
d1408 3
a1410 2
    MAGIC* mg;
    SV* value;
d1415 15
a1429 4
	HV* hv = (HV*)LvTARG(sv);
	HE* he = hv_fetch_ent(hv, mg->mg_obj, TRUE, 0);
	if (!he || (value = HeVAL(he)) == &sv_undef)
	    croak(no_helem, SvPV(mg->mg_obj, na));
d1437 1
a1437 1
	    if (!svp || (value = *svp) == &sv_undef)
d1451 1
a1451 3
magic_setmglob(sv,mg)
SV* sv;
MAGIC* mg;
d1459 1
a1459 3
magic_setbm(sv,mg)
SV* sv;
MAGIC* mg;
d1467 1
a1467 3
magic_setfm(sv,mg)
SV* sv;
MAGIC* mg;
d1475 1
a1475 3
magic_setuvar(sv,mg)
SV* sv;
MAGIC* mg;
d1484 8
d1494 1
a1494 3
magic_setcollxfrm(sv,mg)
SV* sv;
MAGIC* mg;
d1510 1
a1510 3
magic_set(sv,mg)
SV* sv;
MAGIC* mg;
d1512 1
d1518 4
a1521 1
	sv_setsv(bodytarget, sv);
d1524 1
a1524 1
	debug = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) | 0x80000000;
d1531 3
d1537 1
d1540 1
a1540 1
	maxsysfd = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1543 1
a1543 1
	hints = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1545 3
a1547 3
    case '\t':	/* ^I */
	if (inplace)
	    Safefree(inplace);
d1549 1
a1549 1
	    inplace = savepv(SvPV(sv,na));
d1551 1
a1551 1
	    inplace = Nullch;
d1554 2
a1555 2
	if (osname)
	    Safefree(osname);
d1557 1
a1557 1
	    osname = savepv(SvPV(sv,na));
d1559 1
a1559 1
	    osname = Nullch;
d1562 1
a1562 1
	perldb = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1566 1
a1566 1
	basetime = (Time_t)(SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv));
d1568 1
a1568 1
	basetime = (Time_t)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1572 1
a1572 1
	dowarn = (bool)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1575 3
a1577 3
	if (localizing) {
	    if (localizing == 1)
		save_sptr((SV**)&last_in_gv);
d1579 2
a1580 2
	else if (SvOK(sv) && GvIO(last_in_gv))
	    IoLINES(GvIOp(last_in_gv)) = (long)SvIV(sv);
d1583 3
a1585 3
	Safefree(IoTOP_NAME(GvIOp(defoutgv)));
	IoTOP_NAME(GvIOp(defoutgv)) = s = savepv(SvPV(sv,na));
	IoTOP_GV(GvIOp(defoutgv)) = gv_fetchpv(s,TRUE, SVt_PVIO);
d1588 3
a1590 3
	Safefree(IoFMT_NAME(GvIOp(defoutgv)));
	IoFMT_NAME(GvIOp(defoutgv)) = s = savepv(SvPV(sv,na));
	IoFMT_GV(GvIOp(defoutgv)) = gv_fetchpv(s,TRUE, SVt_PVIO);
d1593 1
a1593 1
	IoPAGE_LEN(GvIOp(defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1596 3
a1598 3
	IoLINES_LEFT(GvIOp(defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
	if (IoLINES_LEFT(GvIOp(defoutgv)) < 0L)
	    IoLINES_LEFT(GvIOp(defoutgv)) = 0L;
d1601 1
a1601 1
	IoPAGE(GvIOp(defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1605 1
a1605 1
	    IO *io = GvIOp(defoutgv);
d1620 1
a1620 1
	multiline = (i != 0);
d1623 4
a1626 4
	SvREFCNT_dec(nrs);
	nrs = newSVsv(sv);
	SvREFCNT_dec(rs);
	rs = SvREFCNT_inc(nrs);
d1629 2
a1630 2
	if (ors)
	    Safefree(ors);
d1632 1
a1632 1
	    ors = savepv(SvPV(sv,orslen));
d1634 2
a1635 2
	    ors = Nullch;
	    orslen = 0;
d1639 3
a1641 3
	if (ofs)
	    Safefree(ofs);
	ofs = savepv(SvPV(sv, ofslen));
d1644 3
a1646 3
	if (ofmt)
	    Safefree(ofmt);
	ofmt = savepv(SvPV(sv,na));
d1649 1
a1649 1
	compiling.cop_arybase = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1653 3
a1655 3
	if (localizing == 2) {
	    statusvalue = LvTARGOFF(sv);
	    statusvalue_vms = LvTARGLEN(sv);
d1667 1
a1667 1
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv),
d1671 3
a1673 3
	uid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (delaymagic) {
	    delaymagic |= DM_RUID;
d1677 1
a1677 1
	(void)setruid((Uid_t)uid);
d1680 1
a1680 1
	(void)setreuid((Uid_t)uid, (Uid_t)-1);
d1683 1
a1683 1
      (void)setresuid((Uid_t)uid, (Uid_t)-1, (Uid_t)-1);
d1685 2
a1686 2
	if (uid == euid)		/* special case $< = $> */
	    (void)setuid(uid);
d1688 1
a1688 1
	    uid = (I32)getuid();
d1694 2
a1695 2
	uid = (I32)getuid();
	tainting |= (uid && (euid != uid || egid != gid));
d1698 3
a1700 3
	euid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (delaymagic) {
	    delaymagic |= DM_EUID;
d1704 1
a1704 1
	(void)seteuid((Uid_t)euid);
d1707 1
a1707 1
	(void)setreuid((Uid_t)-1, (Uid_t)euid);
d1710 1
a1710 1
	(void)setresuid((Uid_t)-1, (Uid_t)euid, (Uid_t)-1);
d1712 2
a1713 2
	if (euid == uid)		/* special case $> = $< */
	    setuid(euid);
d1715 1
a1715 1
	    euid = (I32)geteuid();
d1721 2
a1722 2
	euid = (I32)geteuid();
	tainting |= (uid && (euid != uid || egid != gid));
d1725 3
a1727 3
	gid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (delaymagic) {
	    delaymagic |= DM_RGID;
d1731 1
a1731 1
	(void)setrgid((Gid_t)gid);
d1734 1
a1734 1
	(void)setregid((Gid_t)gid, (Gid_t)-1);
d1737 1
a1737 1
      (void)setresgid((Gid_t)gid, (Gid_t)-1, (Gid_t) 1);
d1739 2
a1740 2
	if (gid == egid)			/* special case $( = $) */
	    (void)setgid(gid);
d1742 1
a1742 1
	    gid = (I32)getgid();
d1748 2
a1749 2
	gid = (I32)getgid();
	tainting |= (uid && (euid != uid || egid != gid));
d1754 1
a1754 1
	    char *p = SvPV(sv, na);
d1760 1
a1760 1
	    egid = I_V(atof(p));
d1774 1
a1774 1
	egid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1776 2
a1777 2
	if (delaymagic) {
	    delaymagic |= DM_EGID;
d1781 1
a1781 1
	(void)setegid((Gid_t)egid);
d1784 1
a1784 1
	(void)setregid((Gid_t)-1, (Gid_t)egid);
d1787 1
a1787 1
	(void)setresgid((Gid_t)-1, (Gid_t)egid, (Gid_t)-1);
d1789 2
a1790 2
	if (egid == gid)			/* special case $) = $( */
	    (void)setgid(egid);
d1792 1
a1792 1
	    egid = (I32)getegid();
d1798 2
a1799 2
	egid = (I32)getegid();
	tainting |= (uid && (euid != uid || egid != gid));
d1802 1
a1802 1
	chopset = SvPV_force(sv,na);
d1805 2
a1806 2
	if (!origalen) {
	    s = origargv[0];
d1809 2
a1810 2
	    for (i = 1; i < origargc; i++) {
		if (origargv[i] == s + 1
d1812 1
a1812 1
		    || origargv[i] == s + 2
d1815 4
a1818 1
		    s += strlen(++s);	/* this one is ok too */
d1823 1
a1823 1
	    if (origenviron && (origenviron[0] == s + 1
d1825 1
a1825 1
				|| (origenviron[0] == s + 9 && (s += 8))
d1830 5
a1834 3
		for (i = 0; origenviron[i]; i++)
		    if (origenviron[i] == s + 1)
			s += strlen(++s);
d1838 1
a1838 1
	    origalen = s - origargv[0];
d1842 2
a1843 2
	if (i >= origalen) {
	    i = origalen;
d1846 2
a1847 2
	    Copy(s, origargv[0], i, char);
	    s = origargv[0]+i;
d1851 2
a1852 2
	    Copy(s, origargv[0], i, char);
	    s = origargv[0]+i;
d1854 1
a1854 1
	    while (++i < origalen)
d1856 3
a1858 3
	    s = origargv[0]+i;
	    for (i = 1; i < origargc; i++)
		origargv[i] = Nullch;
d1861 5
d1870 15
d1886 1
a1886 2
whichsig(sig)
char *sig;
d1906 2
a1907 3
static void
unwind_handler_stack(p)
    void *p;
d1909 1
d1913 1
a1913 1
	savestack_ix -= 5; /* Unprotect save in progress. */
d1920 1
a1920 2
sighandler(sig)
int sig;
d1923 1
a1923 1
    GV *gv;
d1925 3
a1927 4
    SV *sv, *tSv = Sv;
    CV *cv;
    AV *oldstack;
    OP *myop = op;
d1929 2
a1930 3
    I32 o_save_i = savestack_ix, type;
    CONTEXT *cx;
    XPV *tXpv = Xpv;
d1932 1
a1932 1
    if (savestack_ix + 15 <= savestack_max)
d1934 1
a1934 3
    if (cxstack_ix < cxstack_max - 2)
	flags |= 2;
    if (markstack_ptr < markstack_max - 2)
d1936 1
a1936 1
    if (retstack_ix < retstack_max - 2)
d1938 1
a1938 1
    if (scopestack_ix < scopestack_max - 3)
a1940 6
    if (flags & 2) {		/* POPBLOCK may decrease cxstack too early. */
	cxstack_ix++;		/* Protect from overwrite. */
	cx = &cxstack[cxstack_ix];
	type = cx->cx_type;		/* Can be during partial write. */
	cx->cx_type = CXt_NULL;		/* Make it safe for unwind. */
    }
d1948 2
a1949 2
	savestack_ix += 5;		/* Protect save in progress. */
	o_save_i = savestack_ix;
d1953 1
a1953 1
	markstack_ptr++;		/* Protect mark. */
d1955 2
a1956 2
	retstack_ix++;
	retstack[retstack_ix] = NULL;
d1959 1
a1959 1
	scopestack_ix += 1;
d1966 1
a1966 1
	if (dowarn)
d1968 5
a1972 2
		sig_name[sig], GvENAME(gv) );
	return;
a1974 5
    oldstack = curstack;
    if (curstack != signalstack)
	AvFILL(signalstack) = 0;
    SWITCHSTACK(curstack, signalstack);

d1983 3
a1985 1
    PUSHMARK(sp);
d1991 2
a1992 1
    SWITCHSTACK(signalstack, oldstack);
d1994 1
a1994 5
	savestack_ix -= 8; /* Unprotect save in progress. */
    if (flags & 2) {
	cxstack[cxstack_ix].cx_type = type;
	cxstack_ix -= 1;
    }
d1996 1
a1996 1
	markstack_ptr--;
d1998 1
a1998 1
	retstack_ix--;
d2000 1
a2000 1
	scopestack_ix -= 1;
d2003 1
a2003 1
    op = myop;			/* Apparently not needed... */
d2005 2
a2006 2
    Sv = tSv;			/* Restore global temporaries. */
    Xpv = tXpv;
d2009 2
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d18 1
a18 1
/* Omit -- it causes too much grief on mixed systems.
d22 6
a27 1
*/
d41 3
a43 2
static MGS *
save_magic(sv)
a45 2
    MGS* mgs;

a47 1
    mgs = (MGS*)safemalloc(sizeof(MGS));
a54 2

    return mgs;
d61 1
a61 1
    MGS *mgs = (MGS*)p;
a72 2

    Safefree(mgs);
d98 1
a98 1
    MGS* mgs;
d101 1
d104 1
a104 1
    mgs = save_magic(sv);
d112 3
a114 2
	    if (*mgp == mg && (mg->mg_flags & MGf_GSKIP))
		mgs->mgs_flags = 0;
d117 1
a117 1
	if (*mgp == mg)
d119 4
d133 1
a133 1
    MGS* mgs;
d138 1
a138 1
    mgs = save_magic(sv);
d145 1
a145 1
	    mgs->mgs_flags = 0;
d166 2
d169 1
a169 1
	    save_magic(sv);
d185 1
d189 1
a189 1
    save_magic(sv);
d221 1
a221 1
STRLEN klen;
d246 4
a249 1
	    Safefree(mg->mg_ptr);
d270 1
d276 1
a276 1
	if (curpm) {
d279 4
a282 4
	    if (curpm->op_pmregexp &&
	      paren <= curpm->op_pmregexp->nparens &&
	      (s = curpm->op_pmregexp->startp[paren]) &&
	      (t = curpm->op_pmregexp->endp[paren]) ) {
a288 1
	break;
d290 4
a293 5
	if (curpm) {
	    paren = curpm->op_pmregexp->lastparen;
	    if (!paren)
		return 0;
	    goto getparen;
a295 1
	break;
d297 3
a299 4
	if (curpm) {
	    if (curpm->op_pmregexp &&
	      (s = curpm->op_pmregexp->subbeg) ) {
		i = curpm->op_pmregexp->startp[0] - s;
d306 5
a310 4
	if (curpm) {
	    if (curpm->op_pmregexp &&
	      (s = curpm->op_pmregexp->endp[0]) ) {
		return (STRLEN) (curpm->op_pmregexp->subend - s);
d335 1
d343 1
a343 1
	sv_setiv(sv,(I32)(debug & 32767));
d352 1
a352 1
	    sv_setnv(sv,(double)vaxc$errno);
d359 12
a370 1
	sv_setnv(sv,(double)errno);
d373 1
d377 1
a377 1
	sv_setiv(sv,(I32)maxsysfd);
d380 1
a380 1
	sv_setiv(sv,(I32)hints);
d386 1
a386 1
	    sv_setsv(sv,&sv_undef);
d389 1
a389 1
	sv_setpv(sv,osname);
d392 9
a400 1
	sv_setiv(sv,(I32)perldb);
d403 5
a407 1
	sv_setiv(sv,(I32)basetime);
d410 1
a410 1
	sv_setiv(sv,(I32)dowarn);
d414 2
a415 2
	if (curpm) {
	    paren = atoi(GvENAME(mg->mg_obj));
d417 4
a420 4
	    if (curpm->op_pmregexp &&
	      paren <= curpm->op_pmregexp->nparens &&
	      (s = curpm->op_pmregexp->startp[paren]) &&
	      (t = curpm->op_pmregexp->endp[paren]) ) {
d422 1
d424 5
a428 1
		    MAGIC *tmg;
d430 2
a431 2
		    if (tainting && (tmg = mg_find(sv,'t')))
			tmg->mg_len = 0;	/* guarantee $1 untainted */
d439 2
a440 2
	if (curpm) {
	    paren = curpm->op_pmregexp->lastparen;
d447 4
a450 8
	if (curpm) {
	    if (curpm->op_pmregexp &&
	      (s = curpm->op_pmregexp->subbeg) ) {
		i = curpm->op_pmregexp->startp[0] - s;
		if (i >= 0) {
		    sv_setpvn(sv,s,i);
		    break;
		}
d456 4
a459 5
	if (curpm) {
	    if (curpm->op_pmregexp &&
	      (s = curpm->op_pmregexp->endp[0]) ) {
		sv_setpvn(sv,s, curpm->op_pmregexp->subend - s);
		break;
d467 1
a467 1
	    sv_setiv(sv,(I32)IoLINES(GvIO(last_in_gv)));
d472 5
a476 1
	sv_setiv(sv,(I32)statusvalue);
d495 1
a495 1
	sv_setiv(sv,(I32)IoPAGE_LEN(GvIOp(defoutgv)));
d498 1
a498 1
	sv_setiv(sv,(I32)IoLINES_LEFT(GvIOp(defoutgv)));
d501 1
a501 1
	sv_setiv(sv,(I32)IoPAGE(GvIOp(defoutgv)));
d509 1
a509 1
	sv_setiv(sv,(I32)curcop->cop_arybase);
d512 1
a512 1
	sv_setiv(sv, (IoFLAGS(GvIOp(defoutgv)) & IOf_FLUSH) != 0 );
d525 2
a526 1
	sv_setnv(sv,(double)((errno == EVMSERR) ? vaxc$errno : errno));
d528 6
a533 1
	sv_setnv(sv,(double)errno);
d536 3
d542 1
a542 1
	sv_setiv(sv,(I32)uid);
d545 1
a545 1
	sv_setiv(sv,(I32)euid);
d548 2
a549 2
	s = buf;
	(void)sprintf(s,"%d",(int)gid);
d552 2
a553 2
	s = buf;
	(void)sprintf(s,"%d",(int)egid);
a554 1
	while (*s) s++;
a555 3
#ifndef NGROUPS
#define NGROUPS 32
#endif
a557 1

d559 2
a560 4
	    while (--i >= 0) {
		(void)sprintf(s," %ld", (long)gary[i]);
		while (*s) s++;
	    }
d563 1
a563 1
	sv_setpv(sv,buf);
d591 2
a592 1
    STRLEN len;
d594 1
d596 3
a598 1
    my_setenv(mg->mg_ptr,s);
d603 3
a605 3
	SV **envsvp;
	if (envsvp = hv_fetch(GvHVn(envgv),mg->mg_ptr,mg->mg_len,FALSE))
	    s = SvPV(*envsvp,len);
d608 2
d613 28
a640 1
	if (s && strEQ(mg->mg_ptr,"PATH")) {
d644 3
a646 1
		s = cpytill(tokenbuf,s,strend,':',&i);
d648 3
a650 2
		if (*tokenbuf != '/'
		  || (Stat(tokenbuf,&statbuf) && (statbuf.st_mode & 2)) )
d652 2
d657 2
d667 1
a667 1
    my_setenv(mg->mg_ptr,Nullch);
d671 4
a674 9
#ifdef HAS_SIGACTION
/* set up reliable signal() clone */

typedef void (*Sigfunc) _((int));

static
Sigfunc rsignal(signo,handler)
int signo;
Sigfunc handler;
d676 13
a688 16
    struct sigaction act,oact;
    
    act.sa_handler = handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;
#ifdef SIGALRM    
    if (signo == SIGALRM) {
#else
    if (0) {
#endif        
#ifdef SA_INTERRUPT
	act.sa_flags |= SA_INTERRUPT;	/* SunOS */
#endif	
    } else {
#ifdef SA_RESTART
	act.sa_flags |= SA_RESTART;	/* SVR4, 4.3+BSD */
d690 1
a690 5
    }
    if (sigaction(signo, &act, &oact) < 0)
    	return(SIG_ERR);
    else
    	return(oact.sa_handler);
d693 7
d701 18
d720 6
a725 3
/* ah well, so much for reliability */

#define rsignal(x,y) signal(x,y)
d728 3
d732 45
d787 1
a787 1
    s = mg->mg_ptr;
d810 6
d819 1
a819 1
	    (void)rsignal(i,sighandler);
d827 1
a827 1
	    (void)rsignal(i,SIG_IGN);
d833 1
a833 1
	    (void)rsignal(i,SIG_DFL);
d838 7
a844 4
	if (!strchr(s,':') && !strchr(s,'\'')) {
	    sprintf(tokenbuf, "main::%s",s);
	    sv_setpv(sv,tokenbuf);
	}
d846 1
a846 1
	    (void)rsignal(i,sighandler);
d876 12
d901 6
a906 2
    if (mg->mg_ptr)
	PUSHs(sv_2mortal(newSVpv(mg->mg_ptr, mg->mg_len)));
d940 6
a945 2
    if (mg->mg_ptr)
	PUSHs(sv_2mortal(newSVpv(mg->mg_ptr, mg->mg_len)));
d1025 2
a1026 1
    svp = av_fetch(GvAV(gv),atoi(mg->mg_ptr), FALSE);
d1104 1
d1114 7
a1120 1
    gv_efullname(sv,((GV*)sv));/* a gv value, be nice */
d1141 1
a1141 1
	gp_free(sv);
a1142 6
    if (!GvAV(gv))
	gv_AVadd(gv);
    if (!GvHV(gv))
	gv_HVadd(gv);
    if (!GvIOp(gv))
	GvIOp(gv) = newIO();
d1162 2
a1163 4
    if (mg->mg_len & 1)
	tainted = TRUE;
    else if (mg->mg_len & 2 && mg->mg_obj == sv)	/* kludge */
	tainted = TRUE;
d1195 91
d1306 10
d1327 19
d1366 2
a1367 1
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv),4);		/* will anyone ever use this? */
d1393 1
a1393 8
	i = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (i != perldb) {
	    if (perldb)
		oldlastpm = curpm;
	    else
		curpm = oldlastpm;
	}
	perldb = i;
d1396 3
d1400 1
d1410 1
a1410 1
	else if (SvOK(sv))
d1435 12
a1446 3
	IoFLAGS(GvIOp(defoutgv)) &= ~IOf_FLUSH;
	if ((SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) != 0) {
	    IoFLAGS(GvIOp(defoutgv)) |= IOf_FLUSH;
d1462 6
a1467 1
	ors = savepv(SvPV(sv,orslen));
d1483 13
a1495 1
	statusvalue = FIXSTATUS(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1498 2
a1499 1
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv),SvIV(sv) == EVMSERR ? 4 : vaxc$errno);		/* will anyone ever use this? */
d1583 22
d1606 1
d1641 5
a1645 1
		if (origargv[i] == s + 1)
d1647 2
d1650 7
a1656 2
	    if (origenviron[0] == s + 1) {	/* can grab env area too? */
		my_setenv("NoNeSuCh", Nullch);
d1661 2
d1670 2
a1671 2
	    SvCUR_set(sv, i);
	    *SvEND(sv) = '\0';
d1673 2
d1711 15
d1733 1
a1733 1
    SV *sv;
d1736 46
a1781 1
    char *signame; 
a1782 19
#ifdef OS2		/* or anybody else who requires SIG_ACK */
    signal(sig, SIG_ACK);
#endif

    signame = sig_name[sig];
    cv = sv_2cv(*hv_fetch(GvHVn(siggv),signame,strlen(signame),
			  TRUE),
		&st, &gv, TRUE);
    if (!cv || !CvROOT(cv) &&
	*signame == 'C' && instr(signame,"LD")) {
	
	if (signame[1] == 'H')
	    cv = sv_2cv(*hv_fetch(GvHVn(siggv),"CLD",3,TRUE),
			&st, &gv, TRUE);
	else
	    cv = sv_2cv(*hv_fetch(GvHVn(siggv),"CHLD",4,TRUE),
			&st, &gv, TRUE);
	/* gag */
    }
d1786 1
a1786 1
		signame, GvENAME(gv) );
d1790 2
a1791 2
    oldstack = stack;
    if (stack != signalstack)
d1793 1
a1793 1
    SWITCHSTACK(stack, signalstack);
d1795 8
a1802 2
    sv = sv_newmortal();
    sv_setpv(sv,signame);
d1810 18
a1827 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 1
a18 1
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
d22 1
a22 6

#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#  ifndef NGROUPS
#    define NGROUPS 32
#  endif
#endif
a27 5
#ifdef PERL_OBJECT

#define VTBL            this->*vtbl

#else
a34 1
#define VTBL			*vtbl
d36 5
a40 1
#endif
a41 3
STATIC void
save_magic(MGS *mgs, SV *sv)
{
d44 1
d52 2
d56 3
a58 2
STATIC void
restore_magic(void *p)
d60 1
a60 1
    MGS* mgs = (MGS*)p;
d72 2
d76 1
d78 2
a79 1
mg_magical(SV *sv)
d85 1
a85 1
	    if ((vtbl->svt_get != NULL) && !(mg->mg_flags & MGf_GSKIP))
d89 1
a89 1
	    if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)) || (vtbl->svt_clear != NULL))
d96 2
a97 1
mg_get(SV *sv)
d99 1
a99 1
    MGS mgs;
a101 1
    int mgp_valid = 0;
d104 1
a104 1
    save_magic(&mgs, sv);
d109 2
a110 2
	if (!(mg->mg_flags & MGf_GSKIP) && vtbl && (vtbl->svt_get != NULL)) {
	    (VTBL->svt_get)(sv, mg);
d112 2
a113 3
	    if ((mg == (mgp_valid ? *mgp : SvMAGIC(sv))) &&
		  (mg->mg_flags & MGf_GSKIP))
		mgs.mgs_flags = 0;
d116 1
a116 1
	if (mg == (mgp_valid ? *mgp : SvMAGIC(sv))) {
a117 4
	    mgp_valid = 1;
	}
	else
	    mgp = &SvMAGIC(sv);	/* Re-establish pointer after sv_upgrade */
d125 2
a126 1
mg_set(SV *sv)
d128 1
a128 1
    MGS mgs;
d133 1
a133 1
    save_magic(&mgs, sv);
d140 1
a140 1
	    mgs.mgs_flags = 0;
d142 2
a143 2
	if (vtbl && (vtbl->svt_set != NULL))
	    (VTBL->svt_set)(sv, mg);
d151 2
a152 1
mg_length(SV *sv)
d160 1
a160 3
	if (vtbl && (vtbl->svt_len != NULL)) {
	    MGS mgs;

d162 1
a162 1
	    save_magic(&mgs, sv);
d164 1
a164 1
	    len = (VTBL->svt_len)(sv, mg);
a173 31
I32
mg_size(SV *sv)
{
    MAGIC* mg;
    I32 len;
    
    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	MGVTBL* vtbl = mg->mg_virtual;
	if (vtbl && (vtbl->svt_len != NULL)) {
	    MGS mgs;
	    ENTER;
	    /* omit MGf_GSKIP -- not changed here */
	    len = (VTBL->svt_len)(sv, mg);
	    LEAVE;
	    return len;
	}
    }

    switch(SvTYPE(sv)) {
	case SVt_PVAV:
	    len = AvFILLp((AV *) sv); /* Fallback to non-tied array */
	    return len;
	case SVt_PVHV:
	    /* FIXME */
	default:
	    croak("Size magic not implemented");
	    break;
    }
    return 0;
}

d175 2
a176 1
mg_clear(SV *sv)
a177 1
    MGS mgs;
d181 1
a181 1
    save_magic(&mgs, sv);
d187 2
a188 2
	if (vtbl && (vtbl->svt_clear != NULL))
	    (VTBL->svt_clear)(sv, mg);
d196 3
a198 1
mg_find(SV *sv, int type)
d209 5
a213 1
mg_copy(SV *sv, SV *nsv, char *key, I32 klen)
d219 1
a219 3
	    sv_magic(nsv,
		     mg->mg_type == 'P' ? SvTIED_obj(sv, mg) : mg->mg_obj,
		     toLOWER(mg->mg_type), key, klen);
d227 2
a228 1
mg_free(SV *sv)
d235 2
a236 2
	if (vtbl && (vtbl->svt_free != NULL))
	    (VTBL->svt_free)(sv, mg);
d238 1
a238 4
	    if (mg->mg_len >= 0)
		Safefree(mg->mg_ptr);
	    else if (mg->mg_len == HEf_SVKEY)
		SvREFCNT_dec((SV*)mg->mg_ptr);
d252 3
a254 1
magic_len(SV *sv, MAGIC *mg)
a255 1
    dTHR;
a258 1
    register REGEXP *rx;
d264 1
a264 1
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
d267 4
a270 4
	    if (paren <= rx->nparens &&
		(s = rx->startp[paren]) &&
		(t = rx->endp[paren]))
	    {
d277 1
d279 5
a283 4
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    paren = rx->lastparen;
	    if (paren)
		goto getparen;
d286 1
d288 4
a291 3
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    if ((s = rx->subbeg) && rx->startp[0]) {
		i = rx->startp[0] - s;
d298 4
a301 5
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    if (rx->subend && (s = rx->endp[0])) {
		i = rx->subend - s;
		if (i >= 0)
		    return i;
d306 1
a306 1
	return (STRLEN)PL_ofslen;
d308 1
a308 1
	return (STRLEN)PL_orslen;
d311 2
a312 4
    if (!SvPOK(sv) && SvNIOK(sv)) {
	STRLEN n_a;
	sv_2pv(sv, &n_a);
    }
d319 3
a321 1
magic_get(SV *sv, MAGIC *mg)
a322 1
    dTHR;
a325 1
    register REGEXP *rx;
d330 1
a330 4
	sv_setsv(sv, PL_bodytarget);
	break;
    case '\003':		/* ^C */
	sv_setiv(sv, (IV)PL_minus_c);
d333 1
a333 1
	sv_setiv(sv, (IV)(PL_debug & 32767));
d342 1
a342 1
	    sv_setnv(sv,(double) vaxc$errno);
d349 1
a349 36
#ifdef OS2
	if (!(_emx_env & 0x200)) {	/* Under DOS */
	    sv_setnv(sv, (double)errno);
	    sv_setpv(sv, errno ? Strerror(errno) : "");
	} else {
	    if (errno != errno_isOS2) {
		int tmp = _syserrno();
		if (tmp)	/* 2nd call to _syserrno() makes it 0 */
		    Perl_rc = tmp;
	    }
	    sv_setnv(sv, (double)Perl_rc);
	    sv_setpv(sv, os2error(Perl_rc));
	}
#else
#ifdef WIN32
	{
	    DWORD dwErr = GetLastError();
	    sv_setnv(sv, (double)dwErr);
	    if (dwErr)
	    {
#ifdef PERL_OBJECT
		char *sMsg;
		DWORD dwLen;
		PerlProc_GetSysMsg(sMsg, dwLen, dwErr);
		sv_setpvn(sv, sMsg, dwLen);
		PerlProc_FreeBuf(sMsg);
#else
		win32_str_os_error(sv, dwErr);
#endif
	    }
	    else
		sv_setpv(sv, "");
	    SetLastError(dwErr);
	}
#else
	sv_setnv(sv, (double)errno);
a351 2
#endif
#endif
d355 1
a355 1
	sv_setiv(sv, (IV)PL_maxsysfd);
d358 1
a358 1
	sv_setiv(sv, (IV)PL_hints);
d360 3
a362 3
    case '\011':		/* ^I */ /* NOT \t in EBCDIC */
	if (PL_inplace)
	    sv_setpv(sv, PL_inplace);
d364 1
a364 1
	    sv_setsv(sv, &PL_sv_undef);
d367 1
a367 1
	sv_setpv(sv, PL_osname);
d370 1
a370 12
	sv_setiv(sv, (IV)PL_perldb);
	break;
    case '\023':		/* ^S */
	{
	    dTHR;
	    if (PL_lex_state != LEX_NOTPARSING)
		SvOK_off(sv);
	    else if (PL_in_eval)
		sv_setiv(sv, 1);
	    else
		sv_setiv(sv, 0);
	}
d373 1
a373 5
#ifdef BIG_TIME
 	sv_setnv(sv, PL_basetime);
#else
	sv_setiv(sv, (IV)PL_basetime);
#endif
d376 1
a376 1
	sv_setiv(sv, (IV)PL_dowarn);
d380 2
a381 6
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    /*
	     * Pre-threads, this was paren = atoi(GvENAME((GV*)mg->mg_obj));
	     * XXX Does the new way break anything?
	     */
	    paren = atoi(mg->mg_ptr);
d383 4
a386 4
	    if (paren <= rx->nparens &&
		(s = rx->startp[paren]) &&
		(t = rx->endp[paren]))
	    {
a387 1
	      getrx:
d389 1
a389 5
		    bool was_tainted;
		    if (PL_tainting) {
			was_tainted = PL_tainted;
			PL_tainted = FALSE;
		    }
d391 2
a392 2
		    if (PL_tainting)
			PL_tainted = (was_tainted || RX_MATCH_TAINTED(rx));
d397 1
a397 1
	sv_setsv(sv,&PL_sv_undef);
d400 2
a401 2
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    paren = rx->lastparen;
d405 1
a405 1
	sv_setsv(sv,&PL_sv_undef);
d408 8
a415 4
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    if ((s = rx->subbeg) && rx->startp[0]) {
		i = rx->startp[0] - s;
		goto getrx;
d418 1
a418 1
	sv_setsv(sv,&PL_sv_undef);
d421 5
a425 4
	if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	    if (rx->subend && (s = rx->endp[0])) {
		i = rx->subend - s;
		goto getrx;
d428 1
a428 1
	sv_setsv(sv,&PL_sv_undef);
d432 2
a433 2
	if (GvIO(PL_last_in_gv)) {
	    sv_setiv(sv, (IV)IoLINES(GvIO(PL_last_in_gv)));
d438 1
a438 7
	{
	    sv_setiv(sv, (IV)STATUS_CURRENT);
#ifdef COMPLEX_STATUS
	    LvTARGOFF(sv) = PL_statusvalue;
	    LvTARGLEN(sv) = PL_statusvalue_vms;
#endif
	}
d441 1
a441 1
	s = IoTOP_NAME(GvIOp(PL_defoutgv));
d445 1
a445 1
	    sv_setpv(sv,GvENAME(PL_defoutgv));
d450 1
a450 1
	s = IoFMT_NAME(GvIOp(PL_defoutgv));
d452 1
a452 1
	    s = GvENAME(PL_defoutgv);
d457 1
a457 1
	sv_setiv(sv, (IV)IoPAGE_LEN(GvIOp(PL_defoutgv)));
d460 1
a460 1
	sv_setiv(sv, (IV)IoLINES_LEFT(GvIOp(PL_defoutgv)));
d463 1
a463 1
	sv_setiv(sv, (IV)IoPAGE(GvIOp(PL_defoutgv)));
d471 1
a471 1
	WITH_THR(sv_setiv(sv, (IV)PL_curcop->cop_arybase));
d474 1
a474 1
	sv_setiv(sv, (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0 );
d477 1
a477 1
	sv_setpvn(sv,PL_ofs,PL_ofslen);
d480 1
a480 1
	sv_setpvn(sv,PL_ors,PL_orslen);
d483 1
a483 1
	sv_setpv(sv,PL_ofmt);
d487 1
a487 2
	sv_setnv(sv, (double)((errno == EVMSERR) ? vaxc$errno : errno));
	sv_setpv(sv, errno ? Strerror(errno) : "");
d489 1
a489 6
	{
	int saveerrno = errno;
	sv_setnv(sv, (double)errno);
#ifdef OS2
	if (errno == errno_isOS2) sv_setpv(sv, os2error(Perl_rc));
	else
a491 3
	errno = saveerrno;
	}
#endif
d495 1
a495 1
	sv_setiv(sv, (IV)PL_uid);
d498 1
a498 1
	sv_setiv(sv, (IV)PL_euid);
d501 2
a502 2
	sv_setiv(sv, (IV)PL_gid);
	sv_setpvf(sv, "%Vd", (IV)PL_gid);
d505 2
a506 2
	sv_setiv(sv, (IV)PL_egid);
	sv_setpvf(sv, "%Vd", (IV)PL_egid);
d508 1
d510 3
d515 1
d517 4
a520 2
	    while (--i >= 0)
		sv_catpvf(sv, " %Vd", (IV)gary[i]);
d523 1
a523 1
	SvIOK_on(sv);	/* what a wonderful hack! */
a528 5
#ifdef USE_THREADS
    case '@@':
	sv_setsv(sv, thr->errsv);
	break;
#endif /* USE_THREADS */
d534 3
a536 1
magic_getuvar(SV *sv, MAGIC *mg)
d546 3
a548 1
magic_setenv(SV *sv, MAGIC *mg)
d551 1
a551 2
    char *ptr;
    STRLEN len, klen;
a552 1

d554 1
a554 3
    ptr = MgPV(mg,klen);
    my_setenv(ptr, s);

d559 3
a561 3
	SV **valp;
	if ((valp = hv_fetch(GvHVn(PL_envgv), ptr, klen, FALSE)))
	    s = SvPV(*valp, len);
a563 2

#if !defined(OS2) && !defined(AMIGAOS) && !defined(WIN32) && !defined(MSDOS)
d566 2
a567 29
    if (PL_tainting) {
	MgTAINTEDDIR_off(mg);
#ifdef VMS
	if (s && klen == 8 && strEQ(ptr, "DCL$PATH")) {
	    char pathbuf[256], eltbuf[256], *cp, *elt = s;
	    struct stat sbuf;
	    int i = 0, j = 0;

	    do {          /* DCL$PATH may be a search list */
		while (1) {   /* as may dev portion of any element */
		    if ( ((cp = strchr(elt,'[')) || (cp = strchr(elt,'<'))) ) {
			if ( *(cp+1) == '.' || *(cp+1) == '-' ||
			     cando_by_name(S_IWUSR,0,elt) ) {
			    MgTAINTEDDIR_on(mg);
			    return 0;
			}
		    }
		    if ((cp = strchr(elt, ':')) != Nullch)
			*cp = '\0';
		    if (my_trnlnm(elt, eltbuf, j++))
			elt = eltbuf;
		    else
			break;
		}
		j = 0;
	    } while (my_trnlnm(s, pathbuf, i++) && (elt = pathbuf));
	}
#endif /* VMS */
	if (s && klen == 4 && strEQ(ptr,"PATH")) {
d571 1
a571 4
		char tmpbuf[256];
		struct stat st;
		s = delimcpy(tmpbuf, tmpbuf + sizeof tmpbuf,
			     s, strend, ':', &i);
d573 2
a574 3
		if (i >= sizeof tmpbuf   /* too long -- assume the worst */
		      || *tmpbuf != '/'
		      || (PerlLIO_stat(tmpbuf, &st) == 0 && (st.st_mode & 2)) ) {
a575 2
		    return 0;
		}
a578 2
#endif /* neither OS2 nor AMIGAOS nor WIN32 nor MSDOS */

d583 3
a585 1
magic_clearenv(SV *sv, MAGIC *mg)
d587 1
a587 2
    STRLEN n_a;
    my_setenv(MgPV(mg,n_a),Nullch);
d591 9
a599 2
int
magic_set_all_env(SV *sv, MAGIC *mg)
d601 17
a617 14
#if defined(VMS)
    die("Can't make list assignment to %%ENV on this system");
#else
    dTHR;
    if (PL_localizing) {
	HE* entry;
	STRLEN n_a;
	magic_clear_all_env(sv,mg);
	hv_iterinit((HV*)sv);
	while (entry = hv_iternext((HV*)sv)) {
	    I32 keylen;
	    my_setenv(hv_iterkey(entry, &keylen),
		      SvPV(hv_iterval((HV*)sv, entry), n_a));
	}
d619 4
a622 2
#endif
    return 0;
a624 5
int
magic_clear_all_env(SV *sv, MAGIC *mg)
{
#if defined(VMS)
    die("Can't make list assignment to %%ENV on this system");
a625 18
#ifdef WIN32
    char *envv = GetEnvironmentStrings();
    char *cur = envv;
    STRLEN len;
    while (*cur) {
	char *end = strchr(cur,'=');
	if (end && end != cur) {
	    *end = '\0';
	    my_setenv(cur,Nullch);
	    *end = '=';
	    cur = end + strlen(end+1)+2;
	}
	else if ((len = strlen(cur)))
	    cur += len+1;
    }
    FreeEnvironmentStrings(envv);
#else
    I32 i;
d627 3
a629 6
    if (environ == PL_origenviron)
	New(901, environ, 1, char*);
    else
	for (i = 0; environ[i]; i++)
	    Safefree(environ[i]);
    environ[0] = Nullch;
a631 3
#endif
    return 0;
}
a632 43
int
magic_getsig(SV *sv, MAGIC *mg)
{
    I32 i;
    STRLEN n_a;
    /* Are we fetching a signal entry? */
    i = whichsig(MgPV(mg,n_a));
    if (i) {
    	if(psig_ptr[i])
    	    sv_setsv(sv,psig_ptr[i]);
    	else {
    	    Sighandler_t sigstate = rsignal_state(i);

    	    /* cache state so we don't fetch it again */
    	    if(sigstate == SIG_IGN)
    	    	sv_setpv(sv,"IGNORE");
    	    else
    	    	sv_setsv(sv,&PL_sv_undef);
    	    psig_ptr[i] = SvREFCNT_inc(sv);
    	    SvTEMP_off(sv);
    	}
    }
    return 0;
}
int
magic_clearsig(SV *sv, MAGIC *mg)
{
    I32 i;
    STRLEN n_a;
    /* Are we clearing a signal entry? */
    i = whichsig(MgPV(mg,n_a));
    if (i) {
    	if(psig_ptr[i]) {
    	    SvREFCNT_dec(psig_ptr[i]);
    	    psig_ptr[i]=0;
    	}
    	if(psig_name[i]) {
    	    SvREFCNT_dec(psig_name[i]);
    	    psig_name[i]=0;
    	}
    }
    return 0;
}
d635 3
a637 1
magic_setsig(SV *sv, MAGIC *mg)
a638 1
    dTHR;
a641 1
    STRLEN n_a;
d643 1
a643 1
    s = MgPV(mg,n_a);
d646 1
a646 1
	    svp = &PL_diehook;
d648 1
a648 1
	    svp = &PL_warnhook;
d650 1
a650 1
	    svp = &PL_parsehook;
d662 1
a662 1
	    if (PL_dowarn || strEQ(s,"ALARM"))
a665 6
	SvREFCNT_dec(psig_name[i]);
	SvREFCNT_dec(psig_ptr[i]);
	psig_ptr[i] = SvREFCNT_inc(sv);
	SvTEMP_off(sv); /* Make sure it doesn't go away on us */
	psig_name[i] = newSVpv(s, strlen(s));
	SvREADONLY_on(psig_name[i]);
d669 1
a669 1
	    (void)rsignal(i, PL_sighandlerp);
d674 1
a674 1
    s = SvPV_force(sv,n_a);
d677 1
a677 1
	    (void)rsignal(i, SIG_IGN);
d683 1
a683 1
	    (void)rsignal(i, SIG_DFL);
d688 4
a691 7
	/*
	 * We should warn if HINT_STRICT_REFS, but without
	 * access to a known hint bit in a known OP, we can't
	 * tell whether HINT_STRICT_REFS is in force or not.
	 */
	if (!strchr(s,':') && !strchr(s,'\''))
	    sv_setpv(sv, form("main::%s", s));
d693 1
a693 1
	    (void)rsignal(i, PL_sighandlerp);
d701 3
a703 1
magic_setisa(SV *sv, MAGIC *mg)
d705 1
a705 1
    PL_sub_generation++;
d712 3
a714 1
magic_setamagic(SV *sv, MAGIC *mg)
d717 1
a717 1
    PL_amagic_generation++;
d723 5
a727 62
int
magic_getnkeys(SV *sv, MAGIC *mg)
{
    HV *hv = (HV*)LvTARG(sv);
    HE *entry;
    I32 i = 0;

    if (hv) {
	(void) hv_iterinit(hv);
	if (! SvTIED_mg((SV*)hv, 'P'))
	    i = HvKEYS(hv);
	else {
	    /*SUPPRESS 560*/
	    while (entry = hv_iternext(hv)) {
		i++;
	    }
	}
    }

    sv_setiv(sv, (IV)i);
    return 0;
}

int
magic_setnkeys(SV *sv, MAGIC *mg)
{
    if (LvTARG(sv)) {
	hv_ksplit((HV*)LvTARG(sv), SvIV(sv));
    }
    return 0;
}          

/* caller is responsible for stack switching/cleanup */
STATIC int
magic_methcall(SV *sv, MAGIC *mg, char *meth, I32 flags, int n, SV *val)
{
    dSP;

    PUSHMARK(SP);
    EXTEND(SP, n);
    PUSHs(SvTIED_obj(sv, mg));
    if (n > 1) { 
	if (mg->mg_ptr) {
	    if (mg->mg_len >= 0)
		PUSHs(sv_2mortal(newSVpv(mg->mg_ptr, mg->mg_len)));
	    else if (mg->mg_len == HEf_SVKEY)
		PUSHs((SV*)mg->mg_ptr);
	}
	else if (mg->mg_type == 'p') {
	    PUSHs(sv_2mortal(newSViv(mg->mg_len)));
	}
    }
    if (n > 2) {
	PUSHs(val);
    }
    PUTBACK;

    return perl_call_method(meth, flags);
}

STATIC int
magic_methpack(SV *sv, MAGIC *mg, char *meth)
d733 8
a740 1
    PUSHSTACKi(PERLSI_MAGIC);
d742 2
a743 3
    if (magic_methcall(sv, mg, meth, G_SCALAR, 2, NULL)) {
	sv_setsv(sv, *PL_stack_sp--);
    }
a744 1
    POPSTACK;
d751 3
a753 1
magic_getpack(SV *sv, MAGIC *mg)
d762 3
a764 1
magic_setpack(SV *sv, MAGIC *mg)
d767 13
a779 5
    ENTER;
    PUSHSTACKi(PERLSI_MAGIC);
    magic_methcall(sv, mg, "STORE", G_SCALAR|G_DISCARD, 3, sv);
    POPSTACK;
    LEAVE;
d784 3
a786 1
magic_clearpack(SV *sv, MAGIC *mg)
d791 3
a793 21

U32
magic_sizepack(SV *sv, MAGIC *mg)
{         
    dSP;
    U32 retval = 0;

    ENTER;
    SAVETMPS;
    PUSHSTACKi(PERLSI_MAGIC);
    if (magic_methcall(sv, mg, "FETCHSIZE", G_SCALAR, 2, NULL)) {
	sv = *PL_stack_sp--;
	retval = (U32) SvIV(sv)-1;
    }
    POPSTACK;
    FREETMPS;
    LEAVE;
    return retval;
}

int magic_wipepack(SV *sv, MAGIC *mg)
d797 2
a798 4
    ENTER;
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    XPUSHs(SvTIED_obj(sv, mg));
d800 1
d802 1
a802 2
    POPSTACK;
    LEAVE;
d807 4
a810 1
magic_nextpack(SV *sv, MAGIC *mg, SV *key)
d817 3
a819 4
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    EXTEND(SP, 2);
    PUSHs(SvTIED_obj(sv, mg));
d825 1
a825 1
	sv_setsv(key, *PL_stack_sp--);
a826 1
    POPSTACK;
d833 3
a835 1
magic_existspack(SV *sv, MAGIC *mg)
d841 3
a843 1
magic_setdbline(SV *sv, MAGIC *mg)
a844 1
    dTHR;
a848 1
    STRLEN n_a;
d850 1
a850 1
    gv = PL_DBline;
d852 1
a852 2
    svp = av_fetch(GvAV(gv),
		     atoi(MgPV(mg,n_a)), FALSE);
d861 3
a863 1
magic_getarylen(SV *sv, MAGIC *mg)
d865 1
a865 2
    dTHR;
    sv_setiv(sv, AvFILL((AV*)mg->mg_obj) + PL_curcop->cop_arybase);
d870 3
a872 1
magic_setarylen(SV *sv, MAGIC *mg)
d874 1
a874 2
    dTHR;
    av_fill((AV*)mg->mg_obj, SvIV(sv) - PL_curcop->cop_arybase);
d879 3
a881 1
magic_getpos(SV *sv, MAGIC *mg)
d888 1
a888 2
	    dTHR;
	    sv_setiv(sv, mg->mg_len + PL_curcop->cop_arybase);
d897 3
a899 1
magic_setpos(SV *sv, MAGIC *mg)
d921 1
a921 1
    WITH_THR(pos = SvIV(sv) - PL_curcop->cop_arybase);
a929 1
    mg->mg_flags &= ~MGf_MINMATCH;
d935 3
a937 1
magic_getglob(SV *sv, MAGIC *mg)
d939 1
a939 7
    if (SvFAKE(sv)) {			/* FAKE globs can get coerced */
	SvFAKE_off(sv);
	gv_efullname3(sv,((GV*)sv), "*");
	SvFAKE_on(sv);
    }
    else
	gv_efullname3(sv,((GV*)sv), "*");	/* a gv value, be nice */
d944 3
a946 1
magic_setglob(SV *sv, MAGIC *mg)
a949 1
    STRLEN n_a;
d953 1
a953 1
    s = SvPV(sv, n_a);
d960 1
a960 1
	gp_free((GV*)sv);
d962 6
d972 3
a974 18
magic_getsubstr(SV *sv, MAGIC *mg)
{
    STRLEN len;
    SV *lsv = LvTARG(sv);
    char *tmps = SvPV(lsv,len);
    I32 offs = LvTARGOFF(sv);
    I32 rem = LvTARGLEN(sv);

    if (offs > len)
	offs = len;
    if (rem + offs > len)
	rem = len - offs;
    sv_setpvn(sv, tmps + offs, (STRLEN)rem);
    return 0;
}

int
magic_setsubstr(SV *sv, MAGIC *mg)
d983 3
a985 1
magic_gettaint(SV *sv, MAGIC *mg)
d987 4
a990 3
    dTHR;
    TAINT_IF((mg->mg_len & 1) ||
	     (mg->mg_len & 2) && mg->mg_obj == sv);	/* kludge */
d995 3
a997 1
magic_settaint(SV *sv, MAGIC *mg)
d999 2
a1000 3
    dTHR;
    if (PL_localizing) {
	if (PL_localizing == 1)
d1005 1
a1005 1
    else if (PL_tainted)
d1013 3
a1015 67
magic_getvec(SV *sv, MAGIC *mg)
{
    SV *lsv = LvTARG(sv);
    unsigned char *s;
    unsigned long retnum;
    STRLEN lsvlen;
    I32 len;
    I32 offset;
    I32 size;

    if (!lsv) {
	SvOK_off(sv);
	return 0;
    }
    s = (unsigned char *) SvPV(lsv, lsvlen);
    offset = LvTARGOFF(sv);
    size = LvTARGLEN(sv);
    len = (offset + size + 7) / 8;

    /* Copied from pp_vec() */

    if (len > lsvlen) {
	if (size <= 8)
	    retnum = 0;
	else {
	    offset >>= 3;
	    if (size == 16) {
		if (offset >= lsvlen)
		    retnum = 0;
		else
		    retnum = (unsigned long) s[offset] << 8;
	    }
	    else if (size == 32) {
		if (offset >= lsvlen)
		    retnum = 0;
		else if (offset + 1 >= lsvlen)
		    retnum = (unsigned long) s[offset] << 24;
		else if (offset + 2 >= lsvlen)
		    retnum = ((unsigned long) s[offset] << 24) +
			((unsigned long) s[offset + 1] << 16);
		else
		    retnum = ((unsigned long) s[offset] << 24) +
			((unsigned long) s[offset + 1] << 16) +
			(s[offset + 2] << 8);
	    }
	}
    }
    else if (size < 8)
	retnum = (s[offset >> 3] >> (offset & 7)) & ((1 << size) - 1);
    else {
	offset >>= 3;
	if (size == 8)
	    retnum = s[offset];
	else if (size == 16)
	    retnum = ((unsigned long) s[offset] << 8) + s[offset+1];
	else if (size == 32)
	    retnum = ((unsigned long) s[offset] << 24) +
		((unsigned long) s[offset + 1] << 16) +
		(s[offset + 2] << 8) + s[offset+3];
    }

    sv_setuv(sv, (UV)retnum);
    return 0;
}

int
magic_setvec(SV *sv, MAGIC *mg)
d1022 3
a1024 98
magic_getdefelem(SV *sv, MAGIC *mg)
{
    SV *targ = Nullsv;
    if (LvTARGLEN(sv)) {
	if (mg->mg_obj) {
	    SV *ahv = LvTARG(sv);
	    if (SvTYPE(ahv) == SVt_PVHV) {
		HE *he = hv_fetch_ent((HV*)ahv, mg->mg_obj, FALSE, 0);
		if (he)
		    targ = HeVAL(he);
	    }
	    else {
		SV **svp = avhv_fetch_ent((AV*)ahv, mg->mg_obj, FALSE, 0);
		if (svp)
		    targ = *svp;
	    }
	}
	else {
	    AV* av = (AV*)LvTARG(sv);
	    if ((I32)LvTARGOFF(sv) <= AvFILL(av))
		targ = AvARRAY(av)[LvTARGOFF(sv)];
	}
	if (targ && targ != &PL_sv_undef) {
	    dTHR;		/* just for SvREFCNT_dec */
	    /* somebody else defined it for us */
	    SvREFCNT_dec(LvTARG(sv));
	    LvTARG(sv) = SvREFCNT_inc(targ);
	    LvTARGLEN(sv) = 0;
	    SvREFCNT_dec(mg->mg_obj);
	    mg->mg_obj = Nullsv;
	    mg->mg_flags &= ~MGf_REFCOUNTED;
	}
    }
    else
	targ = LvTARG(sv);
    sv_setsv(sv, targ ? targ : &PL_sv_undef);
    return 0;
}

int
magic_setdefelem(SV *sv, MAGIC *mg)
{
    if (LvTARGLEN(sv))
	vivify_defelem(sv);
    if (LvTARG(sv)) {
	sv_setsv(LvTARG(sv), sv);
	SvSETMAGIC(LvTARG(sv));
    }
    return 0;
}

void
vivify_defelem(SV *sv)
{
    dTHR;			/* just for SvREFCNT_inc and SvREFCNT_dec*/
    MAGIC *mg;
    SV *value = Nullsv;

    if (!LvTARGLEN(sv) || !(mg = mg_find(sv, 'y')))
	return;
    if (mg->mg_obj) {
	SV *ahv = LvTARG(sv);
	if (SvTYPE(ahv) == SVt_PVHV) {
	    HE *he = hv_fetch_ent((HV*)ahv, mg->mg_obj, TRUE, 0);
	    if (he)
		value = HeVAL(he);
	}
	else {
	    SV **svp = avhv_fetch_ent((AV*)ahv, mg->mg_obj, TRUE, 0);
	    if (svp)
		value = *svp;
	}
	if (!value || value == &PL_sv_undef) {
	    STRLEN n_a;
	    croak(no_helem, SvPV(mg->mg_obj, n_a));
	}
    }
    else {
	AV* av = (AV*)LvTARG(sv);
	if ((I32)LvTARGLEN(sv) < 0 && (I32)LvTARGOFF(sv) > AvFILL(av))
	    LvTARG(sv) = Nullsv;	/* array can't be extended */
	else {
	    SV** svp = av_fetch(av, LvTARGOFF(sv), TRUE);
	    if (!svp || (value = *svp) == &PL_sv_undef)
		croak(no_aelem, (I32)LvTARGOFF(sv));
	}
    }
    (void)SvREFCNT_inc(value);
    SvREFCNT_dec(LvTARG(sv));
    LvTARG(sv) = value;
    LvTARGLEN(sv) = 0;
    SvREFCNT_dec(mg->mg_obj);
    mg->mg_obj = Nullsv;
    mg->mg_flags &= ~MGf_REFCOUNTED;
}

int
magic_setmglob(SV *sv, MAGIC *mg)
d1032 3
a1034 1
magic_setbm(SV *sv, MAGIC *mg)
d1042 3
a1044 9
magic_setfm(SV *sv, MAGIC *mg)
{
    sv_unmagic(sv, 'f');
    SvCOMPILED_off(sv);
    return 0;
}

int
magic_setuvar(SV *sv, MAGIC *mg)
d1054 3
a1056 1
magic_freeregexp(SV *sv, MAGIC *mg)
a1057 26
    regexp *re = (regexp *)mg->mg_obj;
    ReREFCNT_dec(re);
    return 0;
}

#ifdef USE_LOCALE_COLLATE
int
magic_setcollxfrm(SV *sv, MAGIC *mg)
{
    /*
     * Ren Descartes said "I think not."
     * and vanished with a faint plop.
     */
    if (mg->mg_ptr) {
	Safefree(mg->mg_ptr);
	mg->mg_ptr = NULL;
	mg->mg_len = -1;
    }
    return 0;
}
#endif /* USE_LOCALE_COLLATE */

int
magic_set(SV *sv, MAGIC *mg)
{
    dTHR;
d1063 1
a1063 4
	sv_setsv(PL_bodytarget, sv);
	break;
    case '\003':	/* ^C */
	PL_minus_c = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1066 1
a1066 1
	PL_debug = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) | 0x80000000;
d1073 1
a1073 6
#ifdef WIN32
	SetLastError( SvIV(sv) );
#else
	/* will anyone ever use this? */
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv), 4);
#endif
d1077 1
a1077 1
	PL_maxsysfd = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1080 1
a1080 1
	PL_hints = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1082 3
a1084 3
    case '\011':	/* ^I */ /* NOT \t in EBCDIC */
	if (PL_inplace)
	    Safefree(PL_inplace);
d1086 1
a1086 1
	    PL_inplace = savepv(SvPV(sv,len));
d1088 1
a1088 1
	    PL_inplace = Nullch;
d1091 2
a1092 2
	if (PL_osname)
	    Safefree(PL_osname);
d1094 1
a1094 1
	    PL_osname = savepv(SvPV(sv,len));
d1096 1
a1096 1
	    PL_osname = Nullch;
d1099 8
a1106 1
	PL_perldb = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1109 1
a1109 5
#ifdef BIG_TIME
	PL_basetime = (Time_t)(SvNOK(sv) ? SvNVX(sv) : sv_2nv(sv));
#else
	PL_basetime = (Time_t)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
#endif
d1112 1
a1112 1
	PL_dowarn = (bool)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1115 3
a1117 3
	if (PL_localizing) {
	    if (PL_localizing == 1)
		save_sptr((SV**)&PL_last_in_gv);
d1119 2
a1120 2
	else if (SvOK(sv) && GvIO(PL_last_in_gv))
	    IoLINES(GvIOp(PL_last_in_gv)) = (long)SvIV(sv);
d1123 3
a1125 3
	Safefree(IoTOP_NAME(GvIOp(PL_defoutgv)));
	IoTOP_NAME(GvIOp(PL_defoutgv)) = s = savepv(SvPV(sv,len));
	IoTOP_GV(GvIOp(PL_defoutgv)) = gv_fetchpv(s,TRUE, SVt_PVIO);
d1128 3
a1130 3
	Safefree(IoFMT_NAME(GvIOp(PL_defoutgv)));
	IoFMT_NAME(GvIOp(PL_defoutgv)) = s = savepv(SvPV(sv,len));
	IoFMT_GV(GvIOp(PL_defoutgv)) = gv_fetchpv(s,TRUE, SVt_PVIO);
d1133 1
a1133 1
	IoPAGE_LEN(GvIOp(PL_defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1136 3
a1138 3
	IoLINES_LEFT(GvIOp(PL_defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
	if (IoLINES_LEFT(GvIOp(PL_defoutgv)) < 0L)
	    IoLINES_LEFT(GvIOp(PL_defoutgv)) = 0L;
d1141 1
a1141 1
	IoPAGE(GvIOp(PL_defoutgv)) = (long)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1144 3
a1146 12
	{
	    IO *io = GvIOp(PL_defoutgv);
	    if ((SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) == 0)
		IoFLAGS(io) &= ~IOf_FLUSH;
	    else {
		if (!(IoFLAGS(io) & IOf_FLUSH)) {
		    PerlIO *ofp = IoOFP(io);
		    if (ofp)
			(void)PerlIO_flush(ofp);
		    IoFLAGS(io) |= IOf_FLUSH;
		}
	    }
d1151 1
a1151 1
	PL_multiline = (i != 0);
d1154 4
a1157 4
	SvREFCNT_dec(PL_nrs);
	PL_nrs = newSVsv(sv);
	SvREFCNT_dec(PL_rs);
	PL_rs = SvREFCNT_inc(PL_nrs);
d1160 3
a1162 8
	if (PL_ors)
	    Safefree(PL_ors);
	if (SvOK(sv) || SvGMAGICAL(sv))
	    PL_ors = savepv(SvPV(sv,PL_orslen));
	else {
	    PL_ors = Nullch;
	    PL_orslen = 0;
	}
d1165 3
a1167 3
	if (PL_ofs)
	    Safefree(PL_ofs);
	PL_ofs = savepv(SvPV(sv, PL_ofslen));
d1170 3
a1172 3
	if (PL_ofmt)
	    Safefree(PL_ofmt);
	PL_ofmt = savepv(SvPV(sv,len));
d1175 1
a1175 1
	PL_compiling.cop_arybase = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1178 1
a1178 13
#ifdef COMPLEX_STATUS
	if (PL_localizing == 2) {
	    PL_statusvalue = LvTARGOFF(sv);
	    PL_statusvalue_vms = LvTARGLEN(sv);
	}
	else
#endif
#ifdef VMSISH_STATUS
	if (VMSISH_STATUS)
	    STATUS_NATIVE_SET((U32)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)));
	else
#endif
	    STATUS_POSIX_SET(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1181 1
a1181 2
	SETERRNO(SvIOK(sv) ? SvIVX(sv) : SvOK(sv) ? sv_2iv(sv) : 0,
		 (SvIV(sv) == EVMSERR) ? 4 : vaxc$errno);
d1184 3
a1186 3
	PL_uid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_RUID;
d1190 1
a1190 1
	(void)setruid((Uid_t)PL_uid);
d1193 1
a1193 1
	(void)setreuid((Uid_t)PL_uid, (Uid_t)-1);
d1196 1
a1196 1
      (void)setresuid((Uid_t)PL_uid, (Uid_t)-1, (Uid_t)-1);
d1198 2
a1199 2
	if (PL_uid == PL_euid)		/* special case $< = $> */
	    (void)PerlProc_setuid(PL_uid);
d1201 1
a1201 1
	    PL_uid = (I32)PerlProc_getuid();
d1207 2
a1208 2
	PL_uid = (I32)PerlProc_getuid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d1211 3
a1213 3
	PL_euid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_EUID;
d1217 1
a1217 1
	(void)seteuid((Uid_t)PL_euid);
d1220 1
a1220 1
	(void)setreuid((Uid_t)-1, (Uid_t)PL_euid);
d1223 1
a1223 1
	(void)setresuid((Uid_t)-1, (Uid_t)PL_euid, (Uid_t)-1);
d1225 2
a1226 2
	if (PL_euid == PL_uid)		/* special case $> = $< */
	    PerlProc_setuid(PL_euid);
d1228 1
a1228 1
	    PL_euid = (I32)PerlProc_geteuid();
d1234 2
a1235 2
	PL_euid = (I32)PerlProc_geteuid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d1238 3
a1240 3
	PL_gid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_RGID;
d1244 1
a1244 1
	(void)setrgid((Gid_t)PL_gid);
d1247 1
a1247 1
	(void)setregid((Gid_t)PL_gid, (Gid_t)-1);
d1250 1
a1250 1
      (void)setresgid((Gid_t)PL_gid, (Gid_t)-1, (Gid_t) 1);
d1252 2
a1253 2
	if (PL_gid == PL_egid)			/* special case $( = $) */
	    (void)PerlProc_setgid(PL_gid);
d1255 1
a1255 1
	    PL_gid = (I32)PerlProc_getgid();
d1261 2
a1262 2
	PL_gid = (I32)PerlProc_getgid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d1265 3
a1267 26
#ifdef HAS_SETGROUPS
	{
	    char *p = SvPV(sv, len);
	    Groups_t gary[NGROUPS];

	    SET_NUMERIC_STANDARD();
	    while (isSPACE(*p))
		++p;
	    PL_egid = I_V(atof(p));
	    for (i = 0; i < NGROUPS; ++i) {
		while (*p && !isSPACE(*p))
		    ++p;
		while (isSPACE(*p))
		    ++p;
		if (!*p)
		    break;
		gary[i] = I_V(atof(p));
	    }
	    if (i)
		(void)setgroups(i, gary);
	}
#else  /* HAS_SETGROUPS */
	PL_egid = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
#endif /* HAS_SETGROUPS */
	if (PL_delaymagic) {
	    PL_delaymagic |= DM_EGID;
d1271 1
a1271 1
	(void)setegid((Gid_t)PL_egid);
d1274 1
a1274 1
	(void)setregid((Gid_t)-1, (Gid_t)PL_egid);
d1277 1
a1277 1
	(void)setresgid((Gid_t)-1, (Gid_t)PL_egid, (Gid_t)-1);
d1279 2
a1280 2
	if (PL_egid == PL_gid)			/* special case $) = $( */
	    (void)PerlProc_setgid(PL_egid);
d1282 1
a1282 1
	    PL_egid = (I32)PerlProc_getegid();
d1288 2
a1289 2
	PL_egid = (I32)PerlProc_getegid();
	PL_tainting |= (PL_uid && (PL_euid != PL_uid || PL_egid != PL_gid));
d1292 1
a1292 1
	PL_chopset = SvPV_force(sv,len);
d1295 2
a1296 2
	if (!PL_origalen) {
	    s = PL_origargv[0];
d1299 3
a1301 12
	    for (i = 1; i < PL_origargc; i++) {
		if (PL_origargv[i] == s + 1
#ifdef OS2
		    || PL_origargv[i] == s + 2
#endif 
		   )
		{
		    ++s;
		    s += strlen(s);	/* this one is ok too */
		}
		else
		    break;
d1303 2
a1304 7
	    /* can grab env area too? */
	    if (PL_origenviron && (PL_origenviron[0] == s + 1
#ifdef OS2
				|| (PL_origenviron[0] == s + 9 && (s += 8))
#endif 
	       )) {
		my_setenv("NoNe  SuCh", Nullch);
d1306 3
a1308 7
		for (i = 0; PL_origenviron[i]; i++)
		    if (PL_origenviron[i] == s + 1) {
			++s;
			s += strlen(s);
		    }
		    else
			break;
d1310 1
a1310 1
	    PL_origalen = s - PL_origargv[0];
d1314 5
a1318 7
	if (i >= PL_origalen) {
	    i = PL_origalen;
	    /* don't allow system to limit $0 seen by script */
	    /* SvCUR_set(sv, i); *SvEND(sv) = '\0'; */
	    Copy(s, PL_origargv[0], i, char);
	    s = PL_origargv[0]+i;
	    *s = '\0';
d1321 2
a1322 2
	    Copy(s, PL_origargv[0], i, char);
	    s = PL_origargv[0]+i;
d1324 1
a1324 1
	    while (++i < PL_origalen)
d1326 3
a1328 3
	    s = PL_origargv[0]+i;
	    for (i = 1; i < PL_origargc; i++)
		PL_origargv[i] = Nullch;
a1330 5
#ifdef USE_THREADS
    case '@@':
	sv_setsv(thr->errsv, sv);
	break;
#endif /* USE_THREADS */
a1334 15
#ifdef USE_THREADS
int
magic_mutexfree(SV *sv, MAGIC *mg)
{
    dTHR;
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "0x%lx: magic_mutexfree 0x%lx\n",
			  (unsigned long)thr, (unsigned long)sv);)
    if (MgOWNER(mg))
	croak("panic: magic_mutexfree");
    MUTEX_DESTROY(MgMUTEXP(mg));
    COND_DESTROY(MgCONDP(mg));
    return 0;
}
#endif /* USE_THREADS */

d1336 2
a1337 1
whichsig(char *sig)
a1354 15
static SV* sig_sv;

STATIC void
unwind_handler_stack(void *p)
{
    dTHR;
    U32 flags = *(U32*)p;

    if (flags & 1)
	PL_savestack_ix -= 5; /* Unprotect save in progress. */
    /* cxstack_ix-- Not needed, die already unwound it. */
    if (flags & 64)
	SvREFCNT_dec(sig_sv);
}

d1356 2
a1357 1
sighandler(int sig)
d1360 1
a1360 1
    GV *gv = Nullgv;
d1362 8
a1369 39
    SV *sv, *tSv = PL_Sv;
    CV *cv = Nullcv;
    OP *myop = PL_op;
    U32 flags = 0;
    I32 o_save_i = PL_savestack_ix, type;
    XPV *tXpv = PL_Xpv;
    
    if (PL_savestack_ix + 15 <= PL_savestack_max)
	flags |= 1;
    if (PL_markstack_ptr < PL_markstack_max - 2)
	flags |= 4;
    if (PL_retstack_ix < PL_retstack_max - 2)
	flags |= 8;
    if (PL_scopestack_ix < PL_scopestack_max - 3)
	flags |= 16;

    if (!psig_ptr[sig])
	die("Signal SIG%s received, but no signal handler set.\n",
	    sig_name[sig]);

    /* Max number of items pushed there is 3*n or 4. We cannot fix
       infinity, so we fix 4 (in fact 5): */
    if (flags & 1) {
	PL_savestack_ix += 5;		/* Protect save in progress. */
	o_save_i = PL_savestack_ix;
	SAVEDESTRUCTOR(unwind_handler_stack, (void*)&flags);
    }
    if (flags & 4) 
	PL_markstack_ptr++;		/* Protect mark. */
    if (flags & 8) {
	PL_retstack_ix++;
	PL_retstack[PL_retstack_ix] = NULL;
    }
    if (flags & 16)
	PL_scopestack_ix += 1;
    /* sv_2cv is too complicated, try a simpler variant first: */
    if (!SvROK(psig_ptr[sig]) || !(cv = (CV*)SvRV(psig_ptr[sig])) 
	|| SvTYPE(cv) != SVt_PVCV)
	cv = sv_2cv(psig_ptr[sig],&st,&gv,TRUE);
d1371 15
d1387 1
a1387 1
	if (PL_dowarn)
d1389 2
a1390 14
		sig_name[sig], (gv ? GvENAME(gv)
				: ((cv && CvGV(cv))
				   ? GvENAME(CvGV(cv))
				   : "__ANON__")));
	goto cleanup;
    }

    if(psig_name[sig]) {
    	sv = SvREFCNT_inc(psig_name[sig]);
	flags |= 64;
	sig_sv = sv;
    } else {
	sv = sv_newmortal();
	sv_setpv(sv,sig_name[sig]);
d1393 8
a1400 2
    PUSHSTACKi(PERLSI_SIGNAL);
    PUSHMARK(SP);
d1406 2
a1407 16
    POPSTACK;
cleanup:
    if (flags & 1)
	PL_savestack_ix -= 8; /* Unprotect save in progress. */
    if (flags & 4) 
	PL_markstack_ptr--;
    if (flags & 8) 
	PL_retstack_ix--;
    if (flags & 16)
	PL_scopestack_ix -= 1;
    if (flags & 64)
	SvREFCNT_dec(sv);
    PL_op = myop;			/* Apparently not needed... */
    
    PL_Sv = tSv;			/* Restore global temporaries. */
    PL_Xpv = tXpv;
a1409 2


@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_MG_C
a28 3
static void restore_magic(pTHXo_ void *p);
static void unwind_handler_stack(pTHXo_ void *p);

d33 5
a40 1
    I32 mgs_ss_ix;
d42 6
a47 1
/* MGS is typedef'ed to struct magic_state in perl.h */
d50 1
a50 1
S_save_magic(pTHX_ I32 mgs_ix, SV *sv)
a51 2
    dTHR;
    MGS* mgs;
a53 3
    SAVEDESTRUCTOR_X(restore_magic, (void*)mgs_ix);

    mgs = SSPTR(mgs_ix, MGS*);
d56 1
a56 1
    mgs->mgs_ss_ix = PL_savestack_ix;   /* points after the saved destructor */
d63 5
a67 2
/*
=for apidoc mg_magical
d69 10
a78 4
Turns on the magical status of an SV.  See C<sv_magic>.

=cut
*/
d81 1
a81 1
Perl_mg_magical(pTHX_ SV *sv)
d87 1
a87 1
	    if (vtbl->svt_get && !(mg->mg_flags & MGf_GSKIP))
d91 1
a91 1
	    if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)) || vtbl->svt_clear)
a96 8
/*
=for apidoc mg_get

Do magic after a value is retrieved from the SV.  See C<sv_magic>.

=cut
*/

d98 1
a98 1
Perl_mg_get(pTHX_ SV *sv)
d100 1
a100 2
    dTHR;
    I32 mgs_ix;
d105 2
a106 2
    mgs_ix = SSNEW(sizeof(MGS));
    save_magic(mgs_ix, sv);
d111 2
a112 2
	if (!(mg->mg_flags & MGf_GSKIP) && vtbl && vtbl->svt_get) {
	    CALL_FPTR(vtbl->svt_get)(aTHX_ sv, mg);
d116 1
a116 1
		(SSPTR(mgs_ix, MGS*))->mgs_flags = 0;
d127 1
a127 1
    restore_magic(aTHXo_ (void*)mgs_ix);
a130 8
/*
=for apidoc mg_set

Do magic after a value is assigned to the SV.  See C<sv_magic>.

=cut
*/

d132 1
a132 1
Perl_mg_set(pTHX_ SV *sv)
d134 1
a134 2
    dTHR;
    I32 mgs_ix;
d138 2
a139 2
    mgs_ix = SSNEW(sizeof(MGS));
    save_magic(mgs_ix, sv);
d146 1
a146 1
	    (SSPTR(mgs_ix, MGS*))->mgs_flags = 0;
d148 2
a149 2
	if (vtbl && vtbl->svt_set)
	    CALL_FPTR(vtbl->svt_set)(aTHX_ sv, mg);
d152 1
a152 1
    restore_magic(aTHXo_ (void*)mgs_ix);
a155 8
/*
=for apidoc mg_length

Report on the SV's length.  See C<sv_magic>.

=cut
*/

d157 1
a157 1
Perl_mg_length(pTHX_ SV *sv)
d165 2
a166 2
	if (vtbl && vtbl->svt_len) {
            I32 mgs_ix;
d168 2
a169 2
	    mgs_ix = SSNEW(sizeof(MGS));
	    save_magic(mgs_ix, sv);
d171 2
a172 2
	    len = CALL_FPTR(vtbl->svt_len)(aTHX_ sv, mg);
	    restore_magic(aTHXo_ (void*)mgs_ix);
d182 1
a182 1
Perl_mg_size(pTHX_ SV *sv)
d189 3
a191 5
	if (vtbl && vtbl->svt_len) {
            I32 mgs_ix;

	    mgs_ix = SSNEW(sizeof(MGS));
	    save_magic(mgs_ix, sv);
d193 2
a194 2
	    len = CALL_FPTR(vtbl->svt_len)(aTHX_ sv, mg);
	    restore_magic(aTHXo_ (void*)mgs_ix);
d206 1
a206 1
	    Perl_croak(aTHX_ "Size magic not implemented");
a211 8
/*
=for apidoc mg_clear

Clear something magical that the SV represents.  See C<sv_magic>.

=cut
*/

d213 1
a213 1
Perl_mg_clear(pTHX_ SV *sv)
d215 1
a215 1
    I32 mgs_ix;
d218 2
a219 2
    mgs_ix = SSNEW(sizeof(MGS));
    save_magic(mgs_ix, sv);
d225 2
a226 2
	if (vtbl && vtbl->svt_clear)
	    CALL_FPTR(vtbl->svt_clear)(aTHX_ sv, mg);
d229 1
a229 1
    restore_magic(aTHXo_ (void*)mgs_ix);
a232 8
/*
=for apidoc mg_find

Finds the magic pointer for type matching the SV.  See C<sv_magic>.

=cut
*/

d234 1
a234 1
Perl_mg_find(pTHX_ SV *sv, int type)
a243 8
/*
=for apidoc mg_copy

Copies the magic from one SV to another.  See C<sv_magic>.

=cut
*/

d245 1
a245 1
Perl_mg_copy(pTHX_ SV *sv, SV *nsv, const char *key, I32 klen)
a259 8
/*
=for apidoc mg_free

Free any magic storage used by the SV.  See C<sv_magic>.

=cut
*/

d261 1
a261 1
Perl_mg_free(pTHX_ SV *sv)
d268 2
a269 2
	if (vtbl && vtbl->svt_free)
	    CALL_FPTR(vtbl->svt_free)(aTHX_ sv, mg);
d288 1
a288 45
Perl_magic_regdata_cnt(pTHX_ SV *sv, MAGIC *mg)
{
    dTHR;
    register REGEXP *rx;

    if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	if (mg->mg_obj)		/* @@+ */
	    return rx->nparens;
	else			/* @@- */
	    return rx->lastparen;
    }
    
    return (U32)-1;
}

int
Perl_magic_regdatum_get(pTHX_ SV *sv, MAGIC *mg)
{
    dTHR;
    register I32 paren;
    register I32 s;
    register I32 i;
    register REGEXP *rx;
    I32 t;

    if (PL_curpm && (rx = PL_curpm->op_pmregexp)) {
	paren = mg->mg_len;
	if (paren < 0)
	    return 0;
	if (paren <= rx->nparens &&
	    (s = rx->startp[paren]) != -1 &&
	    (t = rx->endp[paren]) != -1)
	    {
		if (mg->mg_obj)		/* @@+ */
		    i = t;
		else			/* @@- */
		    i = s;
		sv_setiv(sv,i);
	    }
    }
    return 0;
}

U32
Perl_magic_len(pTHX_ SV *sv, MAGIC *mg)
d292 1
d295 1
a295 1
    I32 s1, t1;
a300 1

d304 2
a305 2
		(s1 = rx->startp[paren]) != -1 &&
		(t1 = rx->endp[paren]) != -1)
d307 1
a307 11
		i = t1 - s1;
	      getlen:
		if (i > 0 && (PL_curpm->op_pmdynflags & PMdf_UTF8) && !IN_BYTE) {
		    char *s = rx->subbeg + s1;
		    char *send = rx->subbeg + t1;
		    i = 0;
		    while (s < send) {
			s += UTF8SKIP(s);
			i++;
		    }
		}
d322 4
a325 7
	    if (rx->startp[0] != -1) {
		i = rx->startp[0];
		if (i > 0) {
		    s1 = 0;
		    t1 = i;
		    goto getlen;
		}
d331 4
a334 7
	    if (rx->endp[0] != -1) {
		i = rx->sublen - rx->endp[0];
		if (i > 0) {
		    s1 = rx->endp[0];
		    t1 = rx->sublen;
		    goto getlen;
		}
d354 1
a354 1
Perl_magic_get(pTHX_ SV *sv, MAGIC *mg)
d361 1
a369 1

a371 3
#if defined(YYDEBUG) && defined(DEBUGGING)
	PL_yydebug = (PL_debug & 1);
#endif
a373 8
#ifdef MACOS_TRADITIONAL
	{
	    char msg[256];
	    
	    sv_setnv(sv,(double)gLastMacOSErr);
	    sv_setpv(sv, gLastMacOSErr ? GetSysErrText(gLastMacOSErr, msg) : "");	
	}
#else	
d380 1
a380 1
	    sv_setnv(sv,(NV) vaxc$errno);
d389 1
a389 1
	    sv_setnv(sv, (NV)errno);
d397 1
a397 1
	    sv_setnv(sv, (NV)Perl_rc);
d404 1
a404 1
	    sv_setnv(sv, (NV)dwErr);
d407 9
a415 1
		PerlProc_GetOSError(sv, dwErr);
d422 1
a422 1
	sv_setnv(sv, (NV)errno);
a426 1
#endif
d451 1
a451 1
		(void)SvOK_off(sv);
d465 2
a466 19
    case '\027':		/* ^W  & $^WARNING_BITS & ^WIDE_SYSTEM_CALLS */
	if (*(mg->mg_ptr+1) == '\0')
	    sv_setiv(sv, (IV)((PL_dowarn & G_WARN_ON) ? TRUE : FALSE));
	else if (strEQ(mg->mg_ptr, "\027ARNING_BITS")) {
	    if (PL_compiling.cop_warnings == pWARN_NONE ||
	        PL_compiling.cop_warnings == pWARN_STD)
	    {
	        sv_setpvn(sv, WARN_NONEstring, WARNsize) ;
            }
            else if (PL_compiling.cop_warnings == pWARN_ALL) {
	        sv_setpvn(sv, WARN_ALLstring, WARNsize) ;
	    }    
            else {
	        sv_setsv(sv, PL_compiling.cop_warnings);
	    }    
	    SvPOK_only(sv);
	}
	else if (strEQ(mg->mg_ptr, "\027IDE_SYSTEM_CALLS"))
	    sv_setiv(sv, (IV)PL_widesyscalls);
a470 2
	    I32 s1, t1;

d478 2
a479 2
		(s1 = rx->startp[paren]) != -1 &&
		(t1 = rx->endp[paren]) != -1)
d481 1
a481 2
		i = t1 - s1;
		s = rx->subbeg + s1;
d489 1
a489 5
		    sv_setpvn(sv, s, i);
		    if ((PL_curpm->op_pmdynflags & PMdf_UTF8) && !IN_BYTE)
			SvUTF8_on(sv);
		    else
			SvUTF8_off(sv);
d508 2
a509 2
	    if ((s = rx->subbeg) && rx->startp[0] != -1) {
		i = rx->startp[0];
d517 2
a518 3
	    if (rx->subbeg && rx->endp[0] != -1) {
		s = rx->subbeg + rx->endp[0];
		i = rx->sublen - rx->endp[0];
d587 1
a587 1
	sv_setnv(sv, (NV)((errno == EVMSERR) ? vaxc$errno : errno));
d592 1
a592 1
	sv_setnv(sv, (NV)errno);
d594 1
a594 2
	if (errno == errno_isOS2 || errno == errno_isOS2_set)
	    sv_setpv(sv, os2error(Perl_rc));
d611 1
a611 3
#ifdef HAS_GETGROUPS
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, PL_gid);
#endif
d615 1
a615 3
#ifdef HAS_GETGROUPS
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, PL_egid);
#endif
d622 1
a622 1
		Perl_sv_catpvf(aTHX_ sv, " %"Gid_t_f, gary[i]);
d625 1
a625 1
	(void)SvIOK_on(sv);	/* what a wonderful hack! */
a628 1
#ifndef MACOS_TRADITIONAL
a630 1
#endif
d641 1
a641 1
Perl_magic_getuvar(pTHX_ SV *sv, MAGIC *mg)
d651 1
a651 1
Perl_magic_setenv(pTHX_ SV *sv, MAGIC *mg)
d727 1
a727 1
Perl_magic_clearenv(pTHX_ SV *sv, MAGIC *mg)
d735 1
a735 1
Perl_magic_set_all_env(pTHX_ SV *sv, MAGIC *mg)
d738 1
a738 1
    Perl_die(aTHX_ "Can't make list assignment to %%ENV on this system");
d746 1
a746 1
	while ((entry = hv_iternext((HV*)sv))) {
d757 1
a757 1
Perl_magic_clear_all_env(pTHX_ SV *sv, MAGIC *mg)
d760 1
a760 1
    Perl_die(aTHX_ "Can't make list assignment to %%ENV on this system");
d762 1
a762 4
#   ifdef PERL_IMPLICIT_SYS
    PerlEnv_clearenv();
#   else
#	ifdef WIN32
d778 1
a778 7
#   else
#	ifdef __CYGWIN__
    I32 i;
    for (i = 0; environ[i]; i++)
       safesysfree(environ[i]);
#	else
#	    ifndef PERL_USE_SAFE_PUTENV
d782 1
a782 1
	environ = (char**)safesysmalloc(sizeof(char*));
d785 1
a785 4
	    safesysfree(environ[i]);
#	    endif /* PERL_USE_SAFE_PUTENV */
#	endif /* __CYGWIN__ */

d788 2
a789 3
#	endif /* WIN32 */
#   endif /* PERL_IMPLICIT_SYS */
#endif /* VMS */
d794 1
a794 1
Perl_magic_getsig(pTHX_ SV *sv, MAGIC *mg)
d801 2
a802 2
    	if(PL_psig_ptr[i])
    	    sv_setsv(sv,PL_psig_ptr[i]);
d811 1
a811 1
    	    PL_psig_ptr[i] = SvREFCNT_inc(sv);
d818 1
a818 1
Perl_magic_clearsig(pTHX_ SV *sv, MAGIC *mg)
d825 3
a827 3
    	if(PL_psig_ptr[i]) {
    	    SvREFCNT_dec(PL_psig_ptr[i]);
    	    PL_psig_ptr[i]=0;
d829 3
a831 3
    	if(PL_psig_name[i]) {
    	    SvREFCNT_dec(PL_psig_name[i]);
    	    PL_psig_name[i]=0;
d838 1
a838 1
Perl_magic_setsig(pTHX_ SV *sv, MAGIC *mg)
d844 1
a844 1
    STRLEN len;
d846 1
a846 1
    s = MgPV(mg,len);
d852 2
d855 1
a855 1
	    Perl_croak(aTHX_ "No such hook: %s", s);
d865 2
a866 2
	    if (ckWARN(WARN_SIGNAL))
		Perl_warner(aTHX_ WARN_SIGNAL, "No such signal: SIG%s", s);
d869 3
a871 3
	SvREFCNT_dec(PL_psig_name[i]);
	SvREFCNT_dec(PL_psig_ptr[i]);
	PL_psig_ptr[i] = SvREFCNT_inc(sv);
d873 2
a874 2
	PL_psig_name[i] = newSVpvn(s, len);
	SvREADONLY_on(PL_psig_name[i]);
d883 1
a883 1
    s = SvPV_force(sv,len);
d903 1
a903 1
	    sv_insert(sv, 0, 0, "main::", 6);
d913 1
a913 1
Perl_magic_setisa(pTHX_ SV *sv, MAGIC *mg)
d919 2
d922 1
a922 1
Perl_magic_setamagic(pTHX_ SV *sv, MAGIC *mg)
d929 1
d932 1
a932 1
Perl_magic_getnkeys(pTHX_ SV *sv, MAGIC *mg)
d944 1
a944 1
	    while ((entry = hv_iternext(hv))) {
d955 1
a955 1
Perl_magic_setnkeys(pTHX_ SV *sv, MAGIC *mg)
d965 1
a965 1
S_magic_methcall(pTHX_ SV *sv, MAGIC *mg, char *meth, I32 flags, int n, SV *val)
d975 1
a975 1
		PUSHs(sv_2mortal(newSVpvn(mg->mg_ptr, mg->mg_len)));
d988 1
a988 1
    return call_method(meth, flags);
d992 1
a992 1
S_magic_methpack(pTHX_ SV *sv, MAGIC *mg, char *meth)
d1011 1
a1011 1
Perl_magic_getpack(pTHX_ SV *sv, MAGIC *mg)
d1020 1
a1020 1
Perl_magic_setpack(pTHX_ SV *sv, MAGIC *mg)
d1032 1
a1032 1
Perl_magic_clearpack(pTHX_ SV *sv, MAGIC *mg)
d1039 1
a1039 1
Perl_magic_sizepack(pTHX_ SV *sv, MAGIC *mg)
d1057 1
a1057 2
int
Perl_magic_wipepack(pTHX_ SV *sv, MAGIC *mg)
d1066 1
a1066 1
    call_method("CLEAR", G_SCALAR|G_DISCARD);
d1073 1
a1073 1
Perl_magic_nextpack(pTHX_ SV *sv, MAGIC *mg, SV *key)
d1076 1
a1076 1
    const char *meth = SvOK(key) ? "NEXTKEY" : "FIRSTKEY";
d1088 1
a1088 1
    if (call_method(meth, G_SCALAR))
d1098 1
a1098 1
Perl_magic_existspack(pTHX_ SV *sv, MAGIC *mg)
d1104 1
a1104 1
Perl_magic_setdbline(pTHX_ SV *sv, MAGIC *mg)
d1117 1
a1117 1
    if (svp && SvIOKp(*svp) && (o = INT2PTR(OP*,SvIVX(*svp))))
d1119 2
a1120 2
    else if (ckWARN_d(WARN_INTERNAL))
	Perl_warner(aTHX_ WARN_INTERNAL, "Can't break at that line\n");
d1125 1
a1125 1
Perl_magic_getarylen(pTHX_ SV *sv, MAGIC *mg)
d1133 1
a1133 1
Perl_magic_setarylen(pTHX_ SV *sv, MAGIC *mg)
d1141 1
a1141 1
Perl_magic_getpos(pTHX_ SV *sv, MAGIC *mg)
d1149 1
a1149 4
	    I32 i = mg->mg_len;
	    if (DO_UTF8(lsv))
		sv_pos_b2u(lsv, &i);
	    sv_setiv(sv, i + PL_curcop->cop_arybase);
d1158 1
a1158 1
Perl_magic_setpos(pTHX_ SV *sv, MAGIC *mg)
a1162 2
    STRLEN ulen = 0;
    dTHR;
d1180 1
a1180 8
    pos = SvIV(sv) - PL_curcop->cop_arybase;

    if (DO_UTF8(lsv)) {
	ulen = sv_len_utf8(lsv);
	if (ulen)
	    len = ulen;
    }

a1187 7

    if (ulen) {
	I32 p = pos;
	sv_pos_u2b(lsv, &p, 0);
	pos = p;
    }
	
d1195 1
a1195 1
Perl_magic_getglob(pTHX_ SV *sv, MAGIC *mg)
d1208 1
a1208 1
Perl_magic_setglob(pTHX_ SV *sv, MAGIC *mg)
d1229 1
a1229 1
Perl_magic_getsubstr(pTHX_ SV *sv, MAGIC *mg)
d1246 1
a1246 1
Perl_magic_setsubstr(pTHX_ SV *sv, MAGIC *mg)
d1255 1
a1255 1
Perl_magic_gettaint(pTHX_ SV *sv, MAGIC *mg)
d1259 1
a1259 1
	     ((mg->mg_len & 2) && mg->mg_obj == sv));	/* kludge */
d1264 1
a1264 1
Perl_magic_settaint(pTHX_ SV *sv, MAGIC *mg)
d1281 1
a1281 1
Perl_magic_getvec(pTHX_ SV *sv, MAGIC *mg)
d1284 6
d1292 1
a1292 1
	(void)SvOK_off(sv);
d1295 46
d1342 1
a1342 1
    sv_setuv(sv, do_vecget(lsv, LvTARGOFF(sv), LvTARGLEN(sv)));
d1347 1
a1347 1
Perl_magic_setvec(pTHX_ SV *sv, MAGIC *mg)
d1354 1
a1354 1
Perl_magic_getdefelem(pTHX_ SV *sv, MAGIC *mg)
d1394 1
a1394 1
Perl_magic_setdefelem(pTHX_ SV *sv, MAGIC *mg)
d1406 1
a1406 1
Perl_vivify_defelem(pTHX_ SV *sv)
a1415 1
	STRLEN n_a;
d1426 4
a1429 2
	if (!value || value == &PL_sv_undef)
	    Perl_croak(aTHX_ PL_no_helem, SvPV(mg->mg_obj, n_a));
d1438 1
a1438 1
		Perl_croak(aTHX_ PL_no_aelem, (I32)LvTARGOFF(sv));
d1451 1
a1451 22
Perl_magic_killbackrefs(pTHX_ SV *sv, MAGIC *mg)
{
    AV *av = (AV*)mg->mg_obj;
    SV **svp = AvARRAY(av);
    I32 i = AvFILLp(av);
    while (i >= 0) {
	if (svp[i] && svp[i] != &PL_sv_undef) {
	    if (!SvWEAKREF(svp[i]))
		Perl_croak(aTHX_ "panic: magic_killbackrefs");
	    /* XXX Should we check that it hasn't changed? */
	    SvRV(svp[i]) = 0;
	    (void)SvOK_off(svp[i]);
	    SvWEAKREF_off(svp[i]);
	    svp[i] = &PL_sv_undef;
	}
	i--;
    }
    return 0;
}

int
Perl_magic_setmglob(pTHX_ SV *sv, MAGIC *mg)
d1459 1
a1459 1
Perl_magic_setbm(pTHX_ SV *sv, MAGIC *mg)
d1467 1
a1467 1
Perl_magic_setfm(pTHX_ SV *sv, MAGIC *mg)
d1475 1
a1475 1
Perl_magic_setuvar(pTHX_ SV *sv, MAGIC *mg)
d1485 1
a1485 1
Perl_magic_freeregexp(pTHX_ SV *sv, MAGIC *mg)
d1494 1
a1494 1
Perl_magic_setcollxfrm(pTHX_ SV *sv, MAGIC *mg)
d1497 1
a1497 1
     * RenE<eacute> Descartes said "I think not."
d1510 1
a1510 1
Perl_magic_set(pTHX_ SV *sv, MAGIC *mg)
a1522 1

d1528 2
a1529 2
#ifdef MACOS_TRADITIONAL
	gLastMacOSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1531 1
a1531 4
#  ifdef VMS
	set_vaxc_errno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
#  else
#    ifdef WIN32
d1533 1
a1533 2
#    else
#      ifndef OS2
d1536 1
a1536 3
#      endif
#    endif
#  endif
a1562 2
	if (PL_perldb && !PL_DBsingle)
	    init_debugger();
d1571 2
a1572 40
    case '\027':	/* ^W & $^WARNING_BITS & ^WIDE_SYSTEM_CALLS */
	if (*(mg->mg_ptr+1) == '\0') {
	    if ( ! (PL_dowarn & G_WARN_ALL_MASK)) {
	        i = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
	        PL_dowarn = (PL_dowarn & ~G_WARN_ON) 
		    		| (i ? G_WARN_ON : G_WARN_OFF) ;
	    }
	}
	else if (strEQ(mg->mg_ptr, "\027ARNING_BITS")) {
	    if ( ! (PL_dowarn & G_WARN_ALL_MASK)) {
		if (!SvPOK(sv) && PL_localizing) {
	            sv_setpvn(sv, WARN_NONEstring, WARNsize);
	            PL_compiling.cop_warnings = pWARN_NONE;
		    break;
		}
                if (isWARN_on(sv, WARN_ALL)) {
	            PL_compiling.cop_warnings = pWARN_ALL;
	            PL_dowarn |= G_WARN_ONCE ;
	        }	
		else {
		    STRLEN len, i;
		    int accumulate = 0 ;
		    char * ptr = (char*)SvPV(sv, len) ;
		    for (i = 0 ; i < len ; ++i) 
		        accumulate += ptr[i] ;
		    if (!accumulate)
	                PL_compiling.cop_warnings = pWARN_NONE;
                    else {
	                if (specialWARN(PL_compiling.cop_warnings))
		            PL_compiling.cop_warnings = newSVsv(sv) ;
	                else
	                    sv_setsv(PL_compiling.cop_warnings, sv);
	                if (isWARN_on(PL_compiling.cop_warnings, WARN_ONCE))
	                    PL_dowarn |= G_WARN_ONCE ;
	            }
		}
	    }
	}
	else if (strEQ(mg->mg_ptr, "\027IDE_SYSTEM_CALLS"))
	    PL_widesyscalls = SvTRUE(sv);
d1577 1
a1577 1
		SAVESPTR(PL_last_in_gv);
d1631 2
a1632 4
	if (SvOK(sv) || SvGMAGICAL(sv)) {
	    s = SvPV(sv,PL_orslen);
	    PL_ors = savepvn(s,PL_orslen);
	}
d1688 2
a1689 2
	    PL_uid = PerlProc_getuid();
	    Perl_croak(aTHX_ "setruid() not implemented");
d1694 1
a1694 1
	PL_uid = PerlProc_getuid();
d1715 2
a1716 2
	    PL_euid = PerlProc_geteuid();
	    Perl_croak(aTHX_ "seteuid() not implemented");
d1721 1
a1721 1
	PL_euid = PerlProc_geteuid();
d1742 2
a1743 2
	    PL_gid = PerlProc_getgid();
	    Perl_croak(aTHX_ "setrgid() not implemented");
d1748 1
a1748 1
	PL_gid = PerlProc_getgid();
d1757 1
d1760 1
a1760 1
	    PL_egid = Atol(p);
d1768 1
a1768 1
		gary[i] = Atol(p);
d1792 2
a1793 2
	    PL_egid = PerlProc_getegid();
	    Perl_croak(aTHX_ "setegid() not implemented");
d1798 1
a1798 1
	PL_egid = PerlProc_getegid();
a1803 1
#ifndef MACOS_TRADITIONAL
a1860 1
#endif
d1872 1
a1872 1
Perl_magic_mutexfree(pTHX_ SV *sv, MAGIC *mg)
d1875 2
a1876 3
    DEBUG_S(PerlIO_printf(Perl_debug_log,
			  "0x%"UVxf": magic_mutexfree 0x%"UVxf"\n",
			  PTR2UV(thr), PTR2UV(sv));)
d1878 1
a1878 1
	Perl_croak(aTHX_ "panic: magic_mutexfree");
d1886 1
a1886 1
Perl_whichsig(pTHX_ char *sig)
d1890 1
a1890 1
    for (sigv = PL_sig_name+1; *sigv; sigv++)
d1892 1
a1892 1
	    return PL_sig_num[sigv - PL_sig_name];
d1906 13
d1920 1
a1920 1
Perl_sighandler(int sig)
a1921 1
    dTHX;
d1929 1
a1929 1
    I32 o_save_i = PL_savestack_ix;
d1941 3
a1943 3
    if (!PL_psig_ptr[sig])
	Perl_die(aTHX_ "Signal SIG%s received, but no signal handler set.\n",
	    PL_sig_name[sig]);
d1950 1
a1950 1
	SAVEDESTRUCTOR_X(unwind_handler_stack, (void*)&flags);
d1961 1
a1961 1
    if (!SvROK(PL_psig_ptr[sig]) || !(cv = (CV*)SvRV(PL_psig_ptr[sig])) 
d1963 1
a1963 1
	cv = sv_2cv(PL_psig_ptr[sig],&st,&gv,TRUE);
d1966 3
a1968 3
	if (ckWARN(WARN_SIGNAL))
	    Perl_warner(aTHX_ WARN_SIGNAL, "SIG%s handler \"%s\" not defined.\n",
		PL_sig_name[sig], (gv ? GvENAME(gv)
d1975 2
a1976 2
    if(PL_psig_name[sig]) {
    	sv = SvREFCNT_inc(PL_psig_name[sig]);
d1981 1
a1981 1
	sv_setpv(sv,PL_sig_name[sig]);
d1989 1
a1989 1
    call_sv((SV*)cv, G_DISCARD);
a2010 58
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

static void
restore_magic(pTHXo_ void *p)
{
    dTHR;
    MGS* mgs = SSPTR(PTR2IV(p), MGS*);
    SV* sv = mgs->mgs_sv;

    if (!sv)
        return;

    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv))
    {
	if (mgs->mgs_flags)
	    SvFLAGS(sv) |= mgs->mgs_flags;
	else
	    mg_magical(sv);
	if (SvGMAGICAL(sv))
	    SvFLAGS(sv) &= ~(SVf_IOK|SVf_NOK|SVf_POK);
    }

    mgs->mgs_sv = NULL;  /* mark the MGS structure as restored */

    /* If we're still on top of the stack, pop us off.  (That condition
     * will be satisfied if restore_magic was called explicitly, but *not*
     * if it's being called via leave_scope.)
     * The reason for doing this is that otherwise, things like sv_2cv()
     * may leave alloc gunk on the savestack, and some code
     * (e.g. sighandler) doesn't expect that...
     */
    if (PL_savestack_ix == mgs->mgs_ss_ix)
    {
	I32 popval = SSPOPINT;
        assert(popval == SAVEt_DESTRUCTOR_X);
        PL_savestack_ix -= 2;
	popval = SSPOPINT;
        assert(popval == SAVEt_ALLOC);
	popval = SSPOPINT;
        PL_savestack_ix -= popval;
    }

}

static void
unwind_handler_stack(pTHXo_ void *p)
{
    dTHR;
    U32 flags = *(U32*)p;

    if (flags & 1)
	PL_savestack_ix -= 5; /* Unprotect save in progress. */
    /* cxstack_ix-- Not needed, die already unwound it. */
    if (flags & 64)
	SvREFCNT_dec(sig_sv);
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d19 5
d47 1
d99 1
d142 1
d295 1
a295 2
		     mg->mg_type == 'P' ? SvTIED_obj(sv, mg) :
		     (mg->mg_type == 'D' && mg->mg_obj) ? sv : mg->mg_obj,
d341 1
d357 1
a381 8
int
Perl_magic_regdatum_set(pTHX_ SV *sv, MAGIC *mg)
{
    Perl_croak(aTHX_ PL_no_modify);
    /* NOT REACHED */
    return 0;
}

d385 1
d467 1
d492 2
a493 2
	    sv_setnv(sv,(double)gMacPerl_OSErr);
	    sv_setpv(sv, gMacPerl_OSErr ? GetSysErrText(gMacPerl_OSErr, msg) : "");	
d564 1
d568 3
a570 1
 		sv_setiv(sv, PL_in_eval & ~(EVAL_INREQUIRE));
a616 3
		if (!rx->subbeg)
		    break;

d887 1
d906 1
a906 1
#if defined(VMS) || defined(EPOC)
d928 5
a933 1
#if !defined(MACOS_TRADITIONAL)
d943 1
a946 1
#endif /* !defined(MACOS_TRADITIONAL) */
d1000 1
d1262 1
d1275 2
d1283 1
d1291 1
d1304 1
d1323 1
a1411 2
    if (SvUTF8(lsv))
	sv_pos_u2b(lsv, &offs, &rem);
a1416 2
    if (SvUTF8(lsv))
        SvUTF8_on(sv);
d1424 2
a1425 20
    char *tmps = SvPV(sv, len);
    SV *lsv = LvTARG(sv);
    I32 lvoff = LvTARGOFF(sv);
    I32 lvlen = LvTARGLEN(sv);

    if (DO_UTF8(sv)) {
	sv_utf8_upgrade(lsv);
 	sv_pos_u2b(lsv, &lvoff, &lvlen);
	sv_insert(lsv, lvoff, lvlen, tmps, len);
	SvUTF8_on(lsv);
    }
    else if (SvUTF8(lsv)) {
	sv_pos_u2b(lsv, &lvoff, &lvlen);
	tmps = (char*)bytes_to_utf8((U8*)tmps, &len);
	sv_insert(lsv, lvoff, lvlen, tmps, len);
	Safefree(tmps);
    }
    else
        sv_insert(lsv, lvoff, lvlen, tmps, len);

d1432 1
d1441 1
d1500 1
d1531 1
d1655 1
d1673 1
a1673 1
	gMacPerl_OSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1738 5
a1742 1
		{
a1744 1
		    int any_fatals = 0 ;
d1746 2
a1747 4
		    for (i = 0 ; i < len ; ++i) {
		        accumulate |= ptr[i] ;
		        any_fatals |= (ptr[i] & 0xAA) ;
		    }
a1749 4
		    else if (isWARN_on(sv, WARN_ALL) && !any_fatals) {
	                PL_compiling.cop_warnings = pWARN_ALL;
	                PL_dowarn |= G_WARN_ONCE ;
	            }	
a1757 1

a1996 24
#ifdef HAS_SETPROCTITLE
	/* The BSDs don't show the argv[] in ps(1) output, they
	 * show a string from the process struct and provide
	 * the setproctitle() routine to manipulate that. */
	{
	    s = SvPV(sv, len);
#   if __FreeBSD_version >= 410001
	    /* The leading "-" removes the "perl: " prefix,
	     * but not the "(perl) suffix from the ps(1)
	     * output, because that's what ps(1) shows if the
	     * argv[] is modified. */
	    setproctitle("-%s", s, len + 1);
#   else	/* old FreeBSDs, NetBSD, OpenBSD, anyBSD */
	    /* This doesn't really work if you assume that
	     * $0 = 'foobar'; will wipe out 'perl' from the $0
	     * because in ps(1) output the result will be like
	     * sprintf("perl: %s (perl)", s)
	     * I guess this is a security feature:
	     * one (a user process) cannot get rid of the original name.
	     * --jhi */
	    setproctitle("%s", s);
#   endif
	}
#endif
d2067 1
a2102 3
#if defined(WIN32) && defined(PERL_IMPLICIT_CONTEXT)
    dTHXoa(PL_curinterp);	/* fake TLS, because signals don't do TLS */
#else
a2103 1
#endif
a2112 4

#if defined(WIN32) && defined(PERL_IMPLICIT_CONTEXT)
    PERL_SET_THX(aTHXo);	/* fake TLS, see above */
#endif
d2200 1
d2242 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a14 4
/*
=head1 Magical Functions
*/

a22 3
#  ifdef I_GRP
#    include <grp.h>
#  endif
d25 2
a26 11
/* if you only have signal() and it resets on each signal, FAKE_PERSISTENT_SIGNAL_HANDLERS fixes */
#if !defined(HAS_SIGACTION) && defined(VMS)
#  define  FAKE_PERSISTENT_SIGNAL_HANDLERS
#endif
/* if we're doing kill() with sys$sigprc on VMS, FAKE_DEFAULT_SIGNAL_HANDLERS */
#if defined(KILL_BY_SIGPRC)
#  define  FAKE_DEFAULT_SIGNAL_HANDLERS
#endif

static void restore_magic(pTHX_ void *p);
static void unwind_handler_stack(pTHX_ void *p);
d45 1
a45 1
    SAVEDESTRUCTOR_X(restore_magic, INT2PTR(void*, (IV)mgs_ix));
d54 1
a54 1
    SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d93 4
a96 3
    int new = 0;
    MAGIC *newmg, *head, *cur, *mg;
    I32 mgs_ix = SSNEW(sizeof(MGS));
d98 1
d101 3
a103 8
    /* We must call svt_get(sv, mg) for each valid entry in the linked
       list of magic. svt_get() may delete the current entry, add new
       magic to the head of the list, or upgrade the SV. AMS 20010810 */

    newmg = cur = head = mg = SvMAGIC(sv);
    while (mg) {
	MGVTBL *vtbl = mg->mg_virtual;

d106 9
a114 22
	    /* Don't restore the flags for this entry if it was deleted. */
	    if (mg->mg_flags & MGf_GSKIP)
		(SSPTR(mgs_ix, MGS *))->mgs_flags = 0;
	}

	mg = mg->mg_moremagic;

	if (new) {
	    /* Have we finished with the new entries we saw? Start again
	       where we left off (unless there are more new entries). */
	    if (mg == head) {
		new  = 0;
		mg   = cur;
		head = newmg;
	    }
	}

	/* Were any new entries added? */
	if (!new && (newmg = SvMAGIC(sv)) != head) {
	    new = 1;
	    cur = mg;
	    mg  = newmg;
d116 2
d120 1
a120 1
    restore_magic(aTHX_ INT2PTR(void *, (IV)mgs_ix));
d153 1
a153 1
    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d169 1
d181 1
a181 1
	    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d186 1
a186 7
    if (DO_UTF8(sv))
    {
        U8 *s = (U8*)SvPV(sv, len);
        len = Perl_utf8_length(aTHX_ s, s + len);
    }
    else
        (void)SvPV(sv, len);
d195 1
a195 1

d205 1
a205 1
	    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
d243 1
a243 1

d248 1
a248 1
    restore_magic(aTHX_ INT2PTR(void*, (IV)mgs_ix));
a263 2
    if (!sv)
        return 0;
d285 1
a285 5
	MGVTBL* vtbl = mg->mg_virtual;
	if ((mg->mg_flags & MGf_COPY) && vtbl->svt_copy){
	    count += CALL_FPTR(vtbl->svt_copy)(aTHX_ sv, mg, nsv, key, klen);
	}
	else if (isUPPER(mg->mg_type)) {
d287 2
a288 3
		     mg->mg_type == PERL_MAGIC_tied ? SvTIED_obj(sv, mg) :
		     (mg->mg_type == PERL_MAGIC_regdata && mg->mg_obj)
							? sv : mg->mg_obj,
d314 2
a315 2
	if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
	    if (mg->mg_len > 0)
a318 1
	}
a326 1

d336 1
a336 1
    if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d342 1
a342 1

d355 1
a355 1
    if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d359 1
a359 1
	if (paren <= (I32)rx->nparens &&
d367 1
a367 8

		if (i > 0 && PL_reg_match_utf8) {
		    char *b = rx->subbeg;
		    if (b)
		        i = Perl_utf8_length(aTHX_ (U8*)b, (U8*)(b+i));
		}

		sv_setiv(sv, i);
d392 1
a392 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d394 1
a394 1
	    paren = atoi(mg->mg_ptr); /* $& is in [0] */
d396 1
a396 1
	    if (paren <= (I32)rx->nparens &&
d402 2
a403 2
		if (i > 0 && PL_reg_match_utf8) {
		    char *s    = rx->subbeg + s1;
d405 5
a409 4

                    i = t1 - s1;
		    if (is_utf8_string((U8*)s, i))
			i = Perl_utf8_length(aTHX_ (U8*)s, (U8*)send);
d411 2
a412 7
		if (i < 0)
		    Perl_croak(aTHX_ "panic: magic_len: %"IVdf, (IV)i);
		return i;
	    }
	    else {
		if (ckWARN(WARN_UNINITIALIZED))
		    report_uninit();
a414 4
	else {
	    if (ckWARN(WARN_UNINITIALIZED))
		report_uninit();
	}
d417 1
a417 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
a422 7
    case '\016': /* ^N */
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    paren = rx->lastcloseparen;
	    if (paren)
		goto getparen;
	}
	return 0;
d424 1
a424 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d436 1
a436 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d447 4
d479 1
a479 1
	sv_setiv(sv, (IV)(PL_debug & DEBUG_MASK));
d481 1
a481 1
	PL_yydebug = DEBUG_p_TEST;
a484 1
	 if (*(mg->mg_ptr+1) == '\0') {
d486 7
a492 7
	     {
		  char msg[256];

		  sv_setnv(sv,(double)gMacPerl_OSErr);
		  sv_setpv(sv, gMacPerl_OSErr ? GetSysErrText(gMacPerl_OSErr, msg) : "");
	     }
#else
d494 11
a504 11
	     {
#	          include <descrip.h>
#	          include <starlet.h>
		  char msg[255];
		  $DESCRIPTOR(msgdsc,msg);
		  sv_setnv(sv,(NV) vaxc$errno);
		  if (sys$getmsg(vaxc$errno,&msgdsc.dsc$w_length,&msgdsc,0,0) & 1)
		       sv_setpvn(sv,msgdsc.dsc$a_pointer,msgdsc.dsc$w_length);
		  else
		       sv_setpv(sv,"");
	     }
d507 12
a518 12
	     if (!(_emx_env & 0x200)) {	/* Under DOS */
		  sv_setnv(sv, (NV)errno);
		  sv_setpv(sv, errno ? Strerror(errno) : "");
	     } else {
		  if (errno != errno_isOS2) {
		       int tmp = _syserrno();
		       if (tmp)	/* 2nd call to _syserrno() makes it 0 */
			    Perl_rc = tmp;
		  }
		  sv_setnv(sv, (NV)Perl_rc);
		  sv_setpv(sv, os2error(Perl_rc));
	     }
d521 14
a534 14
	     {
		  DWORD dwErr = GetLastError();
		  sv_setnv(sv, (NV)dwErr);
		  if (dwErr)
		  {
		       PerlProc_GetOSError(sv, dwErr);
		  }
		  else
		       sv_setpv(sv, "");
		  SetLastError(dwErr);
	     }
#else
	     sv_setnv(sv, (NV)errno);
	     sv_setpv(sv, errno ? Strerror(errno) : "");
d539 2
a540 5
	     SvNOK_on(sv);	/* what a wonderful hack! */
	 }
	 else if (strEQ(mg->mg_ptr+1, "NCODING"))
	      sv_setsv(sv, PL_encoding);
	 break;
d553 2
a554 10
    case '\017':		/* ^O & ^OPEN */
	if (*(mg->mg_ptr+1) == '\0')
	    sv_setpv(sv, PL_osname);
	else if (strEQ(mg->mg_ptr, "\017PEN")) {
	    if (!PL_compiling.cop_io)
		sv_setsv(sv, &PL_sv_undef);
            else {
	        sv_setsv(sv, PL_compiling.cop_io);
	    }
	}
a564 2
	    else
		sv_setiv(sv, 0);
a567 1
        if (*(mg->mg_ptr+1) == '\0') {
d569 1
a569 1
            sv_setnv(sv, PL_basetime);
d571 1
a571 1
            sv_setiv(sv, (IV)PL_basetime);
d573 1
a573 4
        }
        else if (strEQ(mg->mg_ptr, "\024AINT"))
            sv_setiv(sv, PL_tainting);
        break;
d577 1
a577 1
	else if (strEQ(mg->mg_ptr+1, "ARNING_BITS")) {
d585 1
a585 1
	    }
d588 1
a588 1
	    }
d591 1
a591 1
	else if (strEQ(mg->mg_ptr+1, "IDE_SYSTEM_CALLS"))
d596 1
a596 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d603 1
a603 1
	    paren = atoi(mg->mg_ptr); /* $& is in [0] */
d605 1
a605 1
	    if (paren <= (I32)rx->nparens &&
d616 1
a616 1
		    bool was_tainted = FALSE;
d622 1
a622 1
                   if (PL_reg_match_utf8 && is_utf8_string((U8*)s, i))
d635 1
a635 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
a641 8
    case '\016':		/* ^N */
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
	    paren = rx->lastcloseparen;
	    if (paren)
		goto getparen;
	}
	sv_setsv(sv,&PL_sv_undef);
	break;
d643 1
a643 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d652 1
a652 1
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
d664 1
a664 1
	    sv_setiv(sv, (IV)IoLINES(GvIOp(PL_last_in_gv)));
d714 1
d717 1
a717 2
	if (PL_ors_sv)
	    sv_setpv(sv,SvPVX(PL_ors_sv));
d775 1
a775 1
#ifdef USE_5005THREADS
d779 1
a779 1
#endif /* USE_5005THREADS */
d790 1
a790 1
	(*uf->uf_val)(aTHX_ uf->uf_index, sv);
d800 1
d824 1
a824 1
	    Stat_t sbuf;
d852 1
a852 2
		Stat_t st;
		I32 i;
d905 1
a905 1
#  if defined(PERL_IMPLICIT_SYS) || defined(WIN32)
d907 20
a926 8
#  else
#    ifdef USE_ENVIRON_ARRAY
#      if defined(USE_ITHREADS)
    /* only the parent thread can clobber the process environment */
    if (PL_curinterp == aTHX)
#      endif
    {
#      ifndef PERL_USE_SAFE_PUTENV
d934 1
a934 1
#      endif /* PERL_USE_SAFE_PUTENV */
d937 5
a941 4
    }
#    endif /* USE_ENVIRON_ARRAY */
#   endif /* PERL_IMPLICIT_SYS || WIN32 */
#endif /* VMS || EPC */
a944 11
#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS)||defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
static int sig_handlers_initted = 0;
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
static int sig_ignoring[SIG_SIZE];      /* which signals we are ignoring */
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
static int sig_defaulting[SIG_SIZE];
#endif

#ifndef PERL_MICRO
d956 2
a957 8
    	    Sighandler_t sigstate;
    	    sigstate = rsignal_state(i);
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
    	    if (sig_handlers_initted && sig_ignoring[i]) sigstate = SIG_IGN;
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
    	    if (sig_handlers_initted && sig_defaulting[i]) sigstate = SIG_DFL;
#endif
a988 72
void
Perl_raise_signal(pTHX_ int sig)
{
    /* Set a flag to say this signal is pending */
    PL_psig_pend[sig]++;
    /* And one to say _a_ signal is pending */
    PL_sig_pending = 1;
}

Signal_t
Perl_csighandler(int sig)
{
#ifdef PERL_GET_SIG_CONTEXT
    dTHXa(PERL_GET_SIG_CONTEXT);
#else
    dTHX;
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
    (void) rsignal(sig, &Perl_csighandler);
    if (sig_ignoring[sig]) return;
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
    if (sig_defaulting[sig])
#ifdef KILL_BY_SIGPRC
            exit((Perl_sig_to_vmscondition(sig)&STS$M_COND_ID)|STS$K_SEVERE|STS$M_INHIB_MSG);
#else
            exit(1);
#endif
#endif

#ifdef PERL_OLD_SIGNALS
    /* Call the perl level handler now with risk we may be in malloc() etc. */
    (*PL_sighandlerp)(sig);
#else
    Perl_raise_signal(aTHX_ sig);
#endif
}

#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS) || defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
void
Perl_csighandler_init(void)
{
    int sig;
    if (sig_handlers_initted) return;

    for (sig = 1; sig < SIG_SIZE; sig++) {
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
        dTHX;
        sig_defaulting[sig] = 1;
        (void) rsignal(sig, &Perl_csighandler);
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
        sig_ignoring[sig] = 0;
#endif
    }
    sig_handlers_initted = 1;
}
#endif

void
Perl_despatch_signals(pTHX)
{
    int sig;
    PL_sig_pending = 0;
    for (sig = 1; sig < SIG_SIZE; sig++) {
	if (PL_psig_pend[sig]) {
	    PL_psig_pend[sig] = 0;
	    (*PL_sighandlerp)(sig);
	}
    }
}

d994 1
a994 1
    SV** svp = 0;
d1015 1
a1015 1
		Perl_warner(aTHX_ packWARN(WARN_SIGNAL), "No such signal: SIG%s", s);
a1017 9
#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS) || defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
	if (!sig_handlers_initted) Perl_csighandler_init();
#endif
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
	sig_ignoring[i] = 0;
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
	  sig_defaulting[i] = 0;
#endif
d1027 1
a1027 1
	    (void)rsignal(i, &Perl_csighandler);
d1034 1
a1034 5
	if (i) {
#ifdef FAKE_PERSISTENT_SIGNAL_HANDLERS
	    sig_ignoring[i] = 1;
	    (void)rsignal(i, &Perl_csighandler);
#else
d1036 1
a1036 2
#endif
	} else
a1040 6
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
	  {
	    sig_defaulting[i] = 1;
	    (void)rsignal(i, &Perl_csighandler);
	  }
#else
a1041 1
#endif
d1054 1
a1054 1
	    (void)rsignal(i, &Perl_csighandler);
a1059 1
#endif /* !PERL_MICRO */
d1081 1
d1085 9
a1093 7
         (void) hv_iterinit(hv);
         if (! SvTIED_mg((SV*)hv, PERL_MAGIC_tied))
	     i = HvKEYS(hv);
         else {
	     while (hv_iternext(hv))
	         i++;
         }
d1107 1
a1107 1
}
d1118 1
a1118 1
    if (n > 1) {
d1125 1
a1125 1
	else if (mg->mg_type == PERL_MAGIC_tiedelem) {
d1186 1
a1186 1
{
d1248 1
a1248 1
}
d1264 1
a1264 1
	o->op_private = (U8)i;
d1286 1
a1286 1

d1288 1
a1288 1
	mg = mg_find(lsv, PERL_MAGIC_regex_global);
d1310 1
a1310 1

d1312 1
a1312 1
	mg = mg_find(lsv, PERL_MAGIC_regex_global);
d1316 2
a1317 2
	sv_magic(lsv, (SV*)0, PERL_MAGIC_regex_global, Nullch, 0);
	mg = mg_find(lsv, PERL_MAGIC_regex_global);
d1338 1
a1338 1
    else if (pos > (SSize_t)len)
d1346 1
a1346 1

d1398 1
a1398 1
    if (offs > (I32)len)
d1400 1
a1400 1
    if (rem + offs > (I32)len)
d1423 1
a1423 1
    else if (lsv && SvUTF8(lsv)) {
d1537 1
a1537 1
    if (!LvTARGLEN(sv) || !(mg = mg_find(sv, PERL_MAGIC_defelem)))
d1606 1
a1606 1
    sv_unmagic(sv, PERL_MAGIC_bm);
d1614 1
a1614 1
    sv_unmagic(sv, PERL_MAGIC_fm);
d1625 1
a1625 1
	(*uf->uf_set)(aTHX_ uf->uf_index, sv);
d1665 1
a1665 1
	PL_minus_c = (bool)(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1669 1
a1669 1
	PL_debug = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) | DEBUG_TOP_FLAG;
a1672 1
	 if (*(mg->mg_ptr+1) == '\0') {
d1674 1
a1674 1
	      gMacPerl_OSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1677 1
a1677 1
	      set_vaxc_errno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1680 1
a1680 1
	      SetLastError( SvIV(sv) );
d1682 3
a1684 5
#      ifdef OS2
	      os2_setsyserrno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
#      else
	      /* will anyone ever use this? */
	      SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv), 4);
d1689 1
a1689 7
	 }
	 else if (strEQ(mg->mg_ptr+1, "NCODING")) {
	     if (PL_encoding)
	         sv_setsv(PL_encoding, sv);
	     else
	         PL_encoding = newSVsv(sv);
	 }
d1705 6
a1710 14
	if (*(mg->mg_ptr+1) == '\0') {
	    if (PL_osname)
		Safefree(PL_osname);
	    if (SvOK(sv))
		PL_osname = savepv(SvPV(sv,len));
	    else
		PL_osname = Nullch;
	}
	else if (strEQ(mg->mg_ptr, "\017PEN")) {
	    if (!PL_compiling.cop_io)
		PL_compiling.cop_io = newSVsv(sv);
	    else
		sv_setsv(PL_compiling.cop_io,sv);
	}
d1728 1
a1728 1
	        PL_dowarn = (PL_dowarn & ~G_WARN_ON)
d1732 1
a1732 1
	else if (strEQ(mg->mg_ptr+1, "ARNING_BITS")) {
d1753 1
a1753 1
	            }
d1766 2
a1767 2
	else if (strEQ(mg->mg_ptr+1, "IDE_SYSTEM_CALLS"))
	    PL_widesyscalls = (bool)SvTRUE(sv);
d1775 1
a1775 1
	    IoLINES(GvIOp(PL_last_in_gv)) = SvIV(sv);
d1788 1
a1788 1
	IoPAGE_LEN(GvIOp(PL_defoutgv)) = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1791 1
a1791 1
	IoLINES_LEFT(GvIOp(PL_defoutgv)) = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1796 1
a1796 1
	IoPAGE(GvIOp(PL_defoutgv)) = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
a1800 2
	    if(!io)
	      break;
d1818 2
d1821 1
a1821 1
	PL_rs = newSVsv(sv);
d1824 2
a1825 2
	if (PL_ors_sv)
	    SvREFCNT_dec(PL_ors_sv);
d1827 2
a1828 1
	    PL_ors_sv = newSVsv(sv);
d1831 2
a1832 1
	    PL_ors_sv = Nullsv;
d1836 3
a1838 8
	if (PL_ofs_sv)
	    SvREFCNT_dec(PL_ofs_sv);
	if (SvOK(sv) || SvGMAGICAL(sv)) {
	    PL_ofs_sv = newSVsv(sv);
	}
	else {
	    PL_ofs_sv = Nullsv;
	}
d2008 1
a2008 1
#   if __FreeBSD_version > 410001
d2013 1
a2013 1
	    setproctitle("-%s", s);
d2034 1
a2034 1
#endif
d2044 5
a2048 6
	    if (PL_origenviron
#ifdef USE_ITHREADS
		&& PL_curinterp == aTHX
#endif
		&& (PL_origenviron[0] == s + 1))
	    {
d2063 1
a2063 1
	if (i >= (I32)PL_origalen) {
d2075 3
a2077 2
	    while (++i < (I32)PL_origalen)
		*s++ = '\0';
d2083 1
a2083 1
#ifdef USE_5005THREADS
d2087 1
a2087 1
#endif /* USE_5005THREADS */
d2092 1
a2092 1
#ifdef USE_5005THREADS
d2098 1
a2098 1
			  PTR2UV(thr), PTR2UV(sv)));
d2105 1
a2105 1
#endif /* USE_5005THREADS */
a2125 1
#if !defined(PERL_IMPLICIT_CONTEXT)
a2126 1
#endif
d2131 2
a2132 2
#ifdef PERL_GET_SIG_CONTEXT
    dTHXa(PERL_GET_SIG_CONTEXT);
d2139 1
a2139 1
    SV *sv = Nullsv, *tSv = PL_Sv;
d2143 1
d2146 4
d2159 3
a2161 5
    if (!PL_psig_ptr[sig]) {
		PerlIO_printf(Perl_error_log, "Signal SIG%s received, but no signal handler set.\n",
				 PL_sig_name[sig]);
		exit(sig);
	}
d2167 1
d2170 1
a2170 1
    if (flags & 4)
d2179 1
a2179 1
    if (!SvROK(PL_psig_ptr[sig]) || !(cv = (CV*)SvRV(PL_psig_ptr[sig]))
d2185 1
a2185 1
	    Perl_warner(aTHX_ packWARN(WARN_SIGNAL), "SIG%s handler \"%s\" not defined.\n",
a2195 1
#if !defined(PERL_IMPLICIT_CONTEXT)
a2196 1
#endif
d2207 1
a2207 1
    call_sv((SV*)cv, G_DISCARD|G_EVAL);
a2209 19
    if (SvTRUE(ERRSV)) {
#ifndef PERL_MICRO
#ifdef HAS_SIGPROCMASK
	/* Handler "died", for example to get out of a restart-able read().
	 * Before we re-do that on its behalf re-enable the signal which was
	 * blocked by the system when we entered.
	 */
	sigset_t set;
	sigemptyset(&set);
	sigaddset(&set,sig);
	sigprocmask(SIG_UNBLOCK, &set, NULL);
#else
	/* Not clear if this will work */
	(void)rsignal(sig, SIG_IGN);
	(void)rsignal(sig, &Perl_csighandler);
#endif
#endif /* !PERL_MICRO */
	Perl_die(aTHX_ Nullformat);
    }
d2213 1
a2213 1
    if (flags & 4)
d2215 1
a2215 1
    if (flags & 8)
d2222 1
a2222 1

d2229 4
d2234 1
a2234 1
restore_magic(pTHX_ void *p)
d2275 1
a2275 1
unwind_handler_stack(pTHX_ void *p)
a2281 1
#if !defined(PERL_IMPLICIT_CONTEXT)
a2283 1
#endif
a2284 2


@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a31 6
#ifdef __hpux
#  include <sys/pstat.h>
#endif

Signal_t Perl_csighandler(int sig);

a43 8
#ifdef __Lynx__
/* Missing protos on LynxOS */
void setruid(uid_t id);
void seteuid(uid_t id);
void setrgid(uid_t id);
void setegid(uid_t id);
#endif

a124 10

	    /* guard against sv having been freed */
	    if (SvTYPE(sv) == SVTYPEMASK) {
		Perl_croak(aTHX_ "Tied variable freed while still in use");
	    }
	    /* guard against magic having been deleted - eg FETCH calling
	     * untie */
	    if (!SvMAGIC(sv))
		break;

d412 1
a412 1
		if (i > 0 && RX_MATCH_UTF8(rx)) {
d453 1
a453 1
		if (i > 0 && RX_MATCH_UTF8(rx)) {
d528 1
a528 1
    register char *s = NULL;
d634 1
a634 1
        if (*(mg->mg_ptr+1) == '\0') {
d652 1
a652 3
            sv_setiv(sv, PL_tainting
		    ? (PL_taint_warn || PL_unsafe ? -1 : 1)
		    : 0);
d654 1
a654 5
    case '\025':		/* $^UNICODE */
        if (strEQ(mg->mg_ptr, "\025NICODE"))
	    sv_setuv(sv, (UV) PL_unicode);
        break;
    case '\027':		/* ^W  & $^WARNING_BITS */
d671 2
d696 5
d702 1
a702 1
		    if (RX_MATCH_UTF8(rx) && is_utf8_string((U8*)s, i))
d706 2
a707 14
		    if (PL_tainting) {
			if (RX_MATCH_TAINTED(rx)) {
			    MAGIC* mg = SvMAGIC(sv);
			    MAGIC* mgt;
			    PL_tainted = 1;
			    SvMAGIC(sv) = mg->mg_moremagic;
			    SvTAINT(sv);
			    if ((mgt = SvMAGIC(sv))) {
				mg->mg_moremagic = mgt;
				SvMAGIC(sv) = mg;
			    }
			} else
			    SvTAINTED_off(sv);
		    }
d766 1
a766 2
	if (GvIOp(PL_defoutgv))
	    s = IoTOP_NAME(GvIOp(PL_defoutgv));
d775 1
a775 2
	if (GvIOp(PL_defoutgv))
	    s = IoFMT_NAME(GvIOp(PL_defoutgv));
d782 1
a782 2
	if (GvIOp(PL_defoutgv))
	    sv_setiv(sv, (IV)IoPAGE_LEN(GvIOp(PL_defoutgv)));
d785 1
a785 2
	if (GvIOp(PL_defoutgv))
	    sv_setiv(sv, (IV)IoLINES_LEFT(GvIOp(PL_defoutgv)));
d788 1
a788 2
	if (GvIOp(PL_defoutgv))
	    sv_setiv(sv, (IV)IoPAGE(GvIOp(PL_defoutgv)));
d799 1
a799 2
	if (GvIOp(PL_defoutgv))
	    sv_setiv(sv, (IV)(IoFLAGS(GvIOp(PL_defoutgv)) & IOf_FLUSH) != 0 );
d805 1
a805 1
	    sv_copypv(sv, PL_ors_sv);
a989 1
#ifndef PERL_MICRO
d1016 1
a1016 2
#endif /* VMS || EPOC */
#endif /* !PERL_MICRO */
a1030 8
#ifdef HAS_SIGPROCMASK
static void
restore_sigmask(pTHX_ SV *save_sv)
{
    sigset_t *ossetp = (sigset_t *) SvPV_nolen( save_sv );
    (void)sigprocmask(SIG_SETMASK, ossetp, (sigset_t *)0);
}
#endif
d1038 1
a1038 1
    if (i > 0) {
d1064 1
a1064 4
    /* XXX Some of this code was copied from Perl_magic_setsig. A little
     * refactoring might be in order.
     */
    register char *s;
d1066 11
a1076 56
    SV* to_dec;
    s = MgPV(mg,n_a);
    if (*s == '_') {
	SV** svp;
	if (strEQ(s,"__DIE__"))
	    svp = &PL_diehook;
	else if (strEQ(s,"__WARN__"))
	    svp = &PL_warnhook;
	else
	    Perl_croak(aTHX_ "No such hook: %s", s);
	if (*svp) {
	    to_dec = *svp;
	    *svp = 0;
    	    SvREFCNT_dec(to_dec);
	}
    }
    else {
	I32 i;
	/* Are we clearing a signal entry? */
	i = whichsig(s);
	if (i > 0) {
#ifdef HAS_SIGPROCMASK
	    sigset_t set, save;
	    SV* save_sv;
	    /* Avoid having the signal arrive at a bad time, if possible. */
	    sigemptyset(&set);
	    sigaddset(&set,i);
	    sigprocmask(SIG_BLOCK, &set, &save);
	    ENTER;
	    save_sv = newSVpv((char *)(&save), sizeof(sigset_t));
	    SAVEFREESV(save_sv);
	    SAVEDESTRUCTOR_X(restore_sigmask, save_sv);
#endif
	    PERL_ASYNC_CHECK();
#if defined(FAKE_PERSISTENT_SIGNAL_HANDLERS) || defined(FAKE_DEFAULT_SIGNAL_HANDLERS)
	    if (!sig_handlers_initted) Perl_csighandler_init();
#endif
#ifdef FAKE_DEFAULT_SIGNAL_HANDLERS
	    sig_defaulting[i] = 1;
	    (void)rsignal(i, PL_csighandlerp);
#else
	    (void)rsignal(i, SIG_DFL);
#endif
    	    if(PL_psig_name[i]) {
    		SvREFCNT_dec(PL_psig_name[i]);
    		PL_psig_name[i]=0;
    	    }
    	    if(PL_psig_ptr[i]) {
		to_dec=PL_psig_ptr[i];
    		PL_psig_ptr[i]=0;
		LEAVE;
    		SvREFCNT_dec(to_dec);
    	    }
	    else
		LEAVE;
	}
d1099 1
a1099 1
    (void) rsignal(sig, PL_csighandlerp);
d1110 7
a1116 6
   if (PL_signals & PERL_SIGNALS_UNSAFE_FLAG)
	/* Call the perl level handler now--
	 * with risk we may be in malloc() etc. */
	(*PL_sighandlerp)(sig);
   else
	Perl_raise_signal(aTHX_ sig);
d1130 1
a1130 1
        (void) rsignal(sig, PL_csighandlerp);
d1147 1
a1147 3
	    PERL_BLOCKSIG_ADD(set, sig);
 	    PL_psig_pend[sig] = 0;
	    PERL_BLOCKSIG_BLOCK(set);
a1148 1
	    PERL_BLOCKSIG_UNBLOCK(set);
a1158 5
    /* Need to be careful with SvREFCNT_dec(), because that can have side
     * effects (due to closures). We must make sure that the new disposition
     * is in place before it is called.
     */
    SV* to_dec = 0;
a1159 4
#ifdef HAS_SIGPROCMASK
    sigset_t set, save;
    SV* save_sv;
#endif
d1171 1
a1171 1
	    to_dec = *svp;
d1177 1
a1177 1
	if (i < 0) {
a1181 11
#ifdef HAS_SIGPROCMASK
	/* Avoid having the signal arrive at a bad time, if possible. */
	sigemptyset(&set);
	sigaddset(&set,i);
	sigprocmask(SIG_BLOCK, &set, &save);
	ENTER;
	save_sv = newSVpv((char *)(&save), sizeof(sigset_t));
	SAVEFREESV(save_sv);
	SAVEDESTRUCTOR_X(restore_sigmask, save_sv);
#endif
	PERL_ASYNC_CHECK();
d1189 1
a1189 1
	sig_defaulting[i] = 0;
d1192 1
a1192 1
	to_dec = PL_psig_ptr[i];
d1199 2
a1200 6
	if (i) {
	    (void)rsignal(i, PL_csighandlerp);
#ifdef HAS_SIGPROCMASK
	    LEAVE;
#endif
	}
a1202 2
	if(to_dec)
	    SvREFCNT_dec(to_dec);
d1210 1
a1210 1
	    (void)rsignal(i, PL_csighandlerp);
d1214 2
a1215 1
	}
d1222 1
a1222 1
	    (void)rsignal(i, PL_csighandlerp);
d1227 2
d1239 1
a1239 1
	    (void)rsignal(i, PL_csighandlerp);
a1242 6
#ifdef HAS_SIGPROCMASK
    if(i)
	LEAVE;
#endif
    if(to_dec)
	SvREFCNT_dec(to_dec);
d1342 1
a1344 1
    magic_methpack(sv,mg,"FETCH");
d1446 2
a1447 7
    if (svp && SvIOKp(*svp) && (o = INT2PTR(OP*,SvIVX(*svp)))) {
	/* set or clear breakpoint in the relevant control op */
	if (i)
	    o->op_flags |= OPf_SPECIAL;
	else
	    o->op_flags &= ~OPf_SPECIAL;
    }
a1774 1
    SvREFCNT_dec(av); /* remove extra count added by sv_add_backref() */
a1812 7
Perl_magic_setregexp(pTHX_ SV *sv, MAGIC *mg)
{
    sv_unmagic(sv, PERL_MAGIC_qr);
    return 0;
}

int
a1836 10
/* Just clear the UTF-8 cache data. */
int
Perl_magic_setutf8(pTHX_ SV *sv, MAGIC *mg)
{
     Safefree(mg->mg_ptr);	/* The mg_ptr holds the pos cache. */
     mg->mg_ptr = 0;
     mg->mg_len = -1; 		/* The mg_len holds the len cache. */
     return 0;
}

d1852 1
a1852 3
#ifdef DEBUGGING
	s = SvPV_nolen(sv);
	PL_debug = get_debug_opts(&s) | DEBUG_TOP_FLAG;
a1853 3
#else
	PL_debug = (SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv)) | DEBUG_TOP_FLAG;
#endif
d1856 1
a1856 1
	if (*(mg->mg_ptr+1) == '\0') {
d1858 1
a1858 1
	    gMacPerl_OSErr = SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv);
d1861 1
a1861 1
	    set_vaxc_errno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1864 1
a1864 1
	    SetLastError( SvIV(sv) );
d1867 1
a1867 1
	    os2_setsyserrno(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv));
d1869 2
a1870 2
	    /* will anyone ever use this? */
	    SETERRNO(SvIOK(sv) ? SvIVX(sv) : sv_2iv(sv), 4);
d1875 7
a1881 12
	}
	else if (strEQ(mg->mg_ptr+1, "NCODING")) {
	    if (PL_encoding)
		SvREFCNT_dec(PL_encoding);
	    if (SvOK(sv) || SvGMAGICAL(sv)) {
		PL_encoding = newSVsv(sv);
	    }
	    else {
		PL_encoding = Nullsv;
	    }
	}
	break;
d1924 1
a1924 1
    case '\027':	/* ^W & $^WARNING_BITS */
d1966 2
a2066 6
        {
#ifdef VMS
#   define PERL_VMS_BANG vaxc$errno
#else
#   define PERL_VMS_BANG 0
#endif
d2068 1
a2068 2
		 (SvIV(sv) == EVMSERR) ? 4 : PERL_VMS_BANG);
	}
d2085 1
a2085 6
	if (PL_uid == PL_euid) {		/* special case $< = $> */
#ifdef PERL_DARWIN
	    /* workaround for Darwin's setuid peculiarity, cf [perl #24122] */
	    if (PL_uid != 0 && PerlProc_getuid() == 0)
		(void)PerlProc_setuid(0);
#endif
d2087 1
a2087 1
	} else {
a2204 1
	LOCK_DOLLARZERO_MUTEX;
d2229 35
a2263 6
#if defined(__hpux) && defined(PSTAT_SETCMD)
	{
	     union pstun un;
	     s = SvPV(sv, len);
	     un.pst_command = s;
	     pstat(PSTAT_SETCMD, un, len, 0, 0);
a2264 2
#endif
	/* PL_origalen is set in perl_parse(). */
d2266 8
a2273 4
	if (len >= (STRLEN)PL_origalen) {
	    /* Longer than original, will be truncated. */
	    Copy(s, PL_origargv[0], PL_origalen, char);
	    PL_origargv[0][PL_origalen - 1] = 0;
d2276 5
a2280 10
	    /* Shorter than original, will be padded. */
	    Copy(s, PL_origargv[0], len, char);
	    PL_origargv[0][len] = 0;
	    memset(PL_origargv[0] + len + 1,
		   /* Is the space counterintuitive?  Yes.
		    * (You were expecting \0?)  
		    * Does it work?  Seems to.  (In Linux 2.4.20 at least.)
		    * --jhi */
		   (int)' ',
		   PL_origalen - len - 1);
d2282 1
a2282 1
		 PL_origargv[i] = 0;
a2283 1
	UNLOCK_DOLLARZERO_MUTEX;
d2315 1
a2315 1
    for (sigv = PL_sig_name; *sigv; sigv++)
d2326 1
a2326 1
    return -1;
d2427 1
a2427 1
	(void)rsignal(sig, PL_csighandlerp);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d382 1
a382 1
	    if (mg->mg_len > 0 || mg->mg_type == PERL_MAGIC_utf8)
d395 2
d398 1
d621 2
a622 6
	     {
		 int saveerrno = errno;
		 sv_setnv(sv, (NV)errno);
		 sv_setpv(sv, errno ? Strerror(errno) : "");
		 errno = saveerrno;
	     }
a1529 1

a1563 35
SV *
Perl_magic_scalarpack(pTHX_ HV *hv, MAGIC *mg)
{
    dSP;
    SV *retval = &PL_sv_undef;
    SV *tied = SvTIED_obj((SV*)hv, mg);
    HV *pkg = SvSTASH((SV*)SvRV(tied));
   
    if (!gv_fetchmethod_autoload(pkg, "SCALAR", FALSE)) {
        SV *key;
        if (HvEITER(hv))
            /* we are in an iteration so the hash cannot be empty */
            return &PL_sv_yes;
        /* no xhv_eiter so now use FIRSTKEY */
        key = sv_newmortal();
        magic_nextpack((SV*)hv, mg, key);
        HvEITER(hv) = NULL;     /* need to reset iterator */
        return SvOK(key) ? &PL_sv_yes : &PL_sv_no;
    }
   
    /* there is a SCALAR method that we can call */
    ENTER;
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    EXTEND(SP, 1);
    PUSHs(tied);
    PUTBACK;

    if (call_method("SCALAR", G_SCALAR))
        retval = *PL_stack_sp--; 
    POPSTACK;
    LEAVE;
    return retval;
}

d2078 1
a2078 2
	if ((PERLDB_SUB || PERLDB_LINE || PERLDB_SUBLINE)
		&& !PL_DBsingle)
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d646 1
a646 1
	if (*(mg->mg_ptr+1) == '\0') {
a647 2
	    SvTAINTED_off(sv);
	}
d1937 1
a1937 1
	if (svp[i]) {
d1944 1
a1944 1
	    svp[i] = Nullsv;
d2099 1
a2099 1
	    if (PL_osname) {
d2101 3
a2104 5
	    }
	    if (SvOK(sv)) {
		TAINT_PROPER("assigning to $^O");
		PL_osname = savepv(SvPV(sv,len));
	    }
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a17 18

"Magic" is special data attached to SV structures in order to give them
"magical" properties.  When any Perl code tries to read from, or assign to,
an SV marked as magical, it calls the 'get' or 'set' function associated
with that SV's magic. A get is called prior to reading an SV, in order to
give it a chance to update its internal value (get on $. writes the line
number of the last read filehandle into to the SV's IV slot), while
set is called after an SV has been written to, in order to allow it to make
use of its changed value (set on $/ copies the SV's new value to the
PL_rs global variable).

Magic is implemented as a linked list of MAGIC structures attached to the
SV. Each MAGIC struct holds the type of the magic, a pointer to an array
of functions that implement the get(), set(), length() etc functions,
plus space for some flags and pointers. For example, a tied variable has
a MAGIC structure that contains a pointer to the object associated with the
tie.

a126 12
    int was_temp = SvTEMP(sv);
    /* guard against sv having being freed midway by holding a private
       reference. */

    /* sv_2mortal has this side effect of turning on the TEMP flag, which can
       cause the SV's buffer to get stolen (and maybe other stuff).
       So restore it.
    */
    sv_2mortal(SvREFCNT_inc(sv));
    if (!was_temp) {
	SvTEMP_off(sv);
    }
d141 4
a175 6

    if (SvREFCNT(sv) == 1) {
	/* We hold the last reference to this SV, which implies that the
	   SV was deleted as a side effect of the routines we called.  */
	SvOK_off(sv);
    }
d664 1
a664 1
		SvOK_off(sv);
a1048 1
    if (!PL_use_safe_putenv) {
a1055 1
    }
d1655 1
a1655 1
    SvOK_off(sv);
d1823 1
a1823 1
	SvOK_off(sv);
d1944 1
a1944 1
	    SvOK_off(svp[i]);
d2047 1
a2047 1
	PL_debug = get_debug_opts_flags(&s, 0) | DEBUG_TOP_FLAG;
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006 by Larry Wall and others
d43 3
a50 6
#if defined(HAS_SETGROUPS)
#  ifndef NGROUPS
#    define NGROUPS 32
#  endif
#endif

d66 3
d94 1
a94 1
    SAVEDESTRUCTOR_X(S_restore_magic, INT2PTR(void*, (IV)mgs_ix));
d117 1
a117 1
    const MAGIC* mg;
d119 1
a119 1
	const MGVTBL* const vtbl = mg->mg_virtual;
d142 1
a142 3
    const I32 mgs_ix = SSNEW(sizeof(MGS));
    const bool was_temp = (bool)SvTEMP(sv);
    int have_new = 0;
d144 2
d166 1
a166 1
	const MGVTBL * const vtbl = mg->mg_virtual;
d183 1
a183 1
	if (have_new) {
d187 1
a187 1
		have_new = 0;
d194 2
a195 2
	if (!have_new && (newmg = SvMAGIC(sv)) != head) {
	    have_new = 1;
d201 1
a201 1
    restore_magic(INT2PTR(void *, (IV)mgs_ix));
d222 1
a222 1
    const I32 mgs_ix = SSNEW(sizeof(MGS));
d226 1
d230 1
a230 1
        const MGVTBL* vtbl = mg->mg_virtual;
d240 1
a240 1
    restore_magic(INT2PTR(void*, (IV)mgs_ix));
d259 1
a259 1
        const MGVTBL * const vtbl = mg->mg_virtual;
d261 3
a263 1
            const I32 mgs_ix = SSNEW(sizeof(MGS));
d267 1
a267 1
	    restore_magic(INT2PTR(void*, (IV)mgs_ix));
d272 4
a275 3
    if (DO_UTF8(sv)) {
        const U8 *s = (U8*)SvPV_const(sv, len);
        len = Perl_utf8_length(aTHX_ (U8*)s, (U8*)s + len);
d278 1
a278 1
        (void)SvPV_const(sv, len);
d286 1
d289 1
a289 1
        const MGVTBL* const vtbl = mg->mg_virtual;
d291 3
a293 2
            const I32 mgs_ix = SSNEW(sizeof(MGS));
            I32 len;
d297 1
a297 1
	    restore_magic(INT2PTR(void*, (IV)mgs_ix));
d304 2
a305 1
	    return AvFILLp((AV *) sv); /* Fallback to non-tied array */
d326 1
a326 1
    const I32 mgs_ix = SSNEW(sizeof(MGS));
d329 1
d333 1
a333 1
        const MGVTBL* const vtbl = mg->mg_virtual;
d340 1
a340 1
    restore_magic(INT2PTR(void*, (IV)mgs_ix));
d355 6
a360 6
    if (sv) {
        MAGIC *mg;
        for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
            if (mg->mg_type == type)
                return mg;
        }
d379 1
a379 1
        const MGVTBL* const vtbl = mg->mg_virtual;
d383 7
a389 12
	else {
	    const char type = mg->mg_type;
	    if (isUPPER(type)) {
		sv_magic(nsv,
		     (type == PERL_MAGIC_tied)
			? SvTIED_obj(sv, mg)
			: (type == PERL_MAGIC_regdata && mg->mg_obj)
			    ? sv
			    : mg->mg_obj,
		     toLOWER(type), key, klen);
		count++;
	    }
d409 1
a409 1
        const MGVTBL* const vtbl = mg->mg_virtual;
d423 1
a423 1
    SvMAGIC_set(sv, NULL);
d432 1
a432 2
    register const REGEXP *rx;
    PERL_UNUSED_ARG(sv);
d447 3
d451 1
d454 1
a454 3
        register const I32 paren = mg->mg_len;
        register I32 s;
        register I32 t;
a460 1
                register I32 i;
d467 1
a467 1
		    const char * const b = rx->subbeg;
a480 1
    PERL_UNUSED_ARG(sv); PERL_UNUSED_ARG(mg);
d482 2
a483 1
    NORETURN_FUNCTION_END;
d491 1
a491 1
    register const REGEXP *rx;
d508 2
a509 3
		    const char * const s = rx->subbeg + s1;
		    const U8 *ep;
		    STRLEN el;
d512 2
a513 2
		    if (is_utf8_string_loclen((U8*)s, i, &ep, &el))
			i = el;
d570 2
a571 1
	sv_2pv(sv, 0);
a577 11
#define SvRTRIM(sv) STMT_START { \
    if (SvPOK(sv)) { \
        STRLEN len = SvCUR(sv); \
        char * const p = SvPVX(sv); \
	while (len > 0 && isSPACE(p[len-1])) \
	   --len; \
	SvCUR_set(sv, len); \
	p[len] = '\0'; \
    } \
} STMT_END

a584 2
    const char * const remaining = mg->mg_ptr + 1;
    const char nextchar = *remaining;
d601 1
a601 1
	 if (nextchar == '\0') {
d620 1
a620 1
		       sv_setpvn(sv,"",0);
d629 1
a629 1
		       const int tmp = _syserrno();
d641 2
a642 1
		  if (dwErr) {
d646 1
a646 1
		       sv_setpvn(sv, "", 0);
d651 1
a651 1
		 const int saveerrno = errno;
a659 1
	     SvRTRIM(sv);
d662 1
a662 1
	 else if (strEQ(remaining, "NCODING"))
d678 1
a678 1
	if (nextchar == '\0') {
d682 1
a682 1
	else if (strEQ(remaining, "PEN")) {
d694 1
a694 1
	if (nextchar == '\0') {
d704 1
a704 1
	if (nextchar == '\0') {
d711 1
a711 1
	else if (strEQ(remaining, "AINT"))
d716 2
a717 2
    case '\025':		/* $^UNICODE, $^UTF8LOCALE */
	if (strEQ(remaining, "NICODE"))
a718 2
	else if (strEQ(remaining, "TF8LOCALE"))
	    sv_setuv(sv, (UV) PL_utf8locale);
d721 1
a721 1
	if (nextchar == '\0')
d723 4
a726 2
	else if (strEQ(remaining, "ARNING_BITS")) {
	    if (PL_compiling.cop_warnings == pWARN_NONE) {
d728 1
a728 8
	    }
	    else if (PL_compiling.cop_warnings == pWARN_STD) {
		sv_setpvn(
		    sv, 
		    (PL_dowarn & G_WARN_ON) ? WARN_ALLstring : WARN_NONEstring,
		    WARNsize
		);
	    }
d730 1
a730 10
		/* Get the bit mask for $warnings::Bits{all}, because
		 * it could have been extended by warnings::register */
		SV **bits_all;
		HV * const bits=get_hv("warnings::Bits", FALSE);
		if (bits && (bits_all=hv_fetch(bits, "all", 3, FALSE))) {
		    sv_setsv(sv, *bits_all);
		}
	        else {
		    sv_setpvn(sv, WARN_ALLstring, WARNsize) ;
		}
a759 2
		    int oldtainted = PL_tainted;
		    TAINT_NOT;
a760 1
		    PL_tainted = oldtainted;
d767 1
a767 1
			    MAGIC* const mg = SvMAGIC(sv);
d770 1
a770 1
			    SvMAGIC_set(sv, mg->mg_moremagic);
d774 1
a774 1
				SvMAGIC_set(sv, mg);
d821 1
d825 1
d853 1
d866 1
d893 1
a893 1
	const int saveerrno = errno;
a903 1
	SvRTRIM(sv);
d915 1
a915 1
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, (long unsigned int)PL_gid);
d921 1
a921 1
	Perl_sv_setpvf(aTHX_ sv, "%"Gid_t_f, (long unsigned int)PL_egid);
d926 4
a929 8
	    Groups_t *gary = NULL;
	    I32 num_groups = getgroups(0, gary);
            Newx(gary, num_groups, Groups_t);
            num_groups = getgroups(num_groups, gary);
	    while (--num_groups >= 0)
		Perl_sv_catpvf(aTHX_ sv, " %"Gid_t_f,
                    (long unsigned int)gary[num_groups]);
            Safefree(gary);
d952 1
a952 1
    struct ufuncs * const uf = (struct ufuncs *)mg->mg_ptr;
d962 2
a963 2
    const char *s;
    const char *ptr;
d966 3
a968 3
    s = SvPV_const(sv,len);
    ptr = MgPV_const(mg,klen);
    my_setenv((char *)ptr, (char *)s);
d976 1
a976 1
	    s = SvPV_const(*valp, len);
d987 1
a987 1
	    char pathbuf[256], eltbuf[256], *cp, *elt = (char *) s;
d1012 1
a1012 1
	    const char * const strend = s + len;
d1019 1
a1019 1
			     (char *) s, (char *) strend, ':', &i);
d1038 2
a1039 2
    PERL_UNUSED_ARG(sv);
    my_setenv((char *)MgPV_nolen_const(mg),Nullch);
d1051 2
a1052 1
	my_clearenv();
d1057 1
a1057 1
		      (char *)SvPV_nolen_const(hv_iterval((HV*)sv, entry)));
a1066 2
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
d1068 1
a1068 1
#if defined(VMS)
d1071 26
a1096 2
    my_clearenv();
#endif
d1102 1
a1102 1
static int PL_sig_handlers_initted = 0;
d1105 1
a1105 1
static int PL_sig_ignoring[SIG_SIZE];      /* which signals we are ignoring */
d1108 1
a1108 1
static int PL_sig_defaulting[SIG_SIZE];
d1116 1
a1116 1
    const sigset_t *ossetp = (const sigset_t *) SvPV_nolen_const( save_sv );
d1123 2
d1126 1
a1126 1
    const I32 i = whichsig((char *)MgPV_nolen_const(mg));
d1134 1
a1134 1
    	    if (PL_sig_handlers_initted && PL_sig_ignoring[i]) sigstate = SIG_IGN;
d1137 1
a1137 1
    	    if (PL_sig_handlers_initted && PL_sig_defaulting[i]) sigstate = SIG_DFL;
d1156 4
a1159 2
    register const char * const s = MgPV_nolen_const(mg);
    PERL_UNUSED_ARG(sv);
d1161 1
a1161 1
	SV** svp = 0;
d1168 2
a1169 2
	if (svp && *svp) {
            SV * const to_dec = *svp;
d1175 1
d1177 1
a1177 1
	const I32 i = whichsig((char *)s);
d1193 1
a1193 1
	    if (!PL_sig_handlers_initted) Perl_csighandler_init();
d1196 1
a1196 1
	    PL_sig_defaulting[i] = 1;
d1206 1
a1206 1
                SV *to_dec=PL_psig_ptr[i];
d1218 2
a1219 2
static void
S_raise_signal(pTHX_ int sig)
d1237 1
a1237 1
    if (PL_sig_ignoring[sig]) return;
d1240 1
a1240 1
    if (PL_sig_defaulting[sig])
d1252 1
a1252 1
	S_raise_signal(aTHX_ sig);
d1260 1
a1260 1
    if (PL_sig_handlers_initted) return;
d1265 1
a1265 1
        PL_sig_defaulting[sig] = 1;
d1269 1
a1269 1
        PL_sig_ignoring[sig] = 0;
d1272 1
a1272 1
    PL_sig_handlers_initted = 1;
d1295 1
d1309 1
a1309 1
    register const char *s = MgPV_const(mg,len);
d1324 2
a1325 2
	i = whichsig((char *)s);	/* ...no, a brick */
	if (i <= 0) {
d1342 1
a1342 1
	if (!PL_sig_handlers_initted) Perl_csighandler_init();
d1345 1
a1345 1
	PL_sig_ignoring[i] = 0;
d1348 1
a1348 1
	PL_sig_defaulting[i] = 0;
d1374 1
a1374 1
	    PL_sig_ignoring[i] = 1;
d1385 1
a1385 1
	    PL_sig_defaulting[i] = 1;
a1417 2
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
a1424 2
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
d1434 1
a1434 1
    HV * const hv = (HV*)LvTARG(sv);
a1435 1
    PERL_UNUSED_ARG(mg);
a1453 1
    PERL_UNUSED_ARG(mg);
d1462 1
a1462 1
S_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, const char *meth, I32 flags, int n, SV *val)
d1489 1
a1489 1
S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, const char *meth)
d1575 1
a1575 1
    const char * const meth = SvOK(key) ? "NEXTKEY" : "FIRSTKEY";
d1607 2
a1608 2
    SV * const tied = SvTIED_obj((SV*)hv, mg);
    HV * const pkg = SvSTASH((SV*)SvRV(tied));
d1612 1
a1612 1
        if (HvEITER_get(hv))
d1618 1
a1618 1
        HvEITER_set(hv, NULL);     /* need to reset iterator */
d1640 16
a1655 13
    GV * const gv = PL_DBline;
    const I32 i = SvTRUE(sv);
    SV ** const svp = av_fetch(GvAV(gv),
		     atoi(MgPV_nolen_const(mg)), FALSE);
    if (svp && SvIOKp(*svp)) {
	OP * const o = INT2PTR(OP*,SvIVX(*svp));
	if (o) {
	    /* set or clear breakpoint in the relevant control op */
	    if (i)
		o->op_flags |= OPf_SPECIAL;
	    else
		o->op_flags &= ~OPf_SPECIAL;
	}
d1663 1
a1663 6
    AV *obj = (AV*)mg->mg_obj;
    if (obj) {
	sv_setiv(sv, AvFILL(obj) + PL_curcop->cop_arybase);
    } else {
	SvOK_off(sv);
    }
d1670 1
a1670 8
    AV *obj = (AV*)mg->mg_obj;
    if (obj) {
	av_fill(obj, SvIV(sv) - PL_curcop->cop_arybase);
    } else {
	if (ckWARN(WARN_MISC))
	    Perl_warner(aTHX_ packWARN(WARN_MISC),
			"Attempt to set length of freed array");
    }
d1677 1
a1677 1
    SV* const lsv = LvTARG(sv);
d1696 1
a1696 1
    SV* const lsv = LvTARG(sv);
a1747 1
    PERL_UNUSED_ARG(mg);
a1763 1
    PERL_UNUSED_ARG(mg);
d1783 2
a1784 2
    SV * const lsv = LvTARG(sv);
    const char * const tmps = SvPV_const(lsv,len);
a1786 1
    PERL_UNUSED_ARG(mg);
d1804 2
a1805 2
    const char *tmps = SvPV_const(sv, len);
    SV * const lsv = LvTARG(sv);
a1807 1
    PERL_UNUSED_ARG(mg);
d1812 1
a1812 1
	sv_insert(lsv, lvoff, lvlen, (char *)tmps, len);
d1818 1
a1818 1
	sv_insert(lsv, lvoff, lvlen, (char *)tmps, len);
d1822 1
a1822 1
        sv_insert(lsv, lvoff, lvlen, (char *)tmps, len);
a1829 1
    PERL_UNUSED_ARG(sv);
a1837 1
    PERL_UNUSED_ARG(sv);
d1854 1
a1854 2
    SV * const lsv = LvTARG(sv);
    PERL_UNUSED_ARG(mg);
a1867 1
    PERL_UNUSED_ARG(mg);
d1878 1
a1878 1
	    SV * const ahv = LvTARG(sv);
d1880 1
a1880 1
		HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, FALSE, 0);
d1891 1
a1891 1
	    AV* const av = (AV*)LvTARG(sv);
a1913 1
    PERL_UNUSED_ARG(mg);
d1932 2
a1933 1
	SV * const ahv = LvTARG(sv);
d1935 1
a1935 1
	    HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, TRUE, 0);
d1945 1
a1945 1
	    Perl_croak(aTHX_ PL_no_helem_sv, mg->mg_obj);
d1948 1
a1948 1
	AV* const av = (AV*)LvTARG(sv);
d1952 1
a1952 1
	    SV** const svp = av_fetch(av, LvTARGOFF(sv), TRUE);
d1969 2
a1970 2
    AV * const av = (AV*)mg->mg_obj;
    SV ** const svp = AvARRAY(av);
a1971 2
    PERL_UNUSED_ARG(sv);

d1975 1
a1975 2
		Perl_croak(aTHX_ "panic: magic_killbackrefs (flags=%"UVxf")",
			   (UV)SvFLAGS(svp[i]));
d1977 1
a1977 1
	    SvRV_set(svp[i], 0);
a1998 1
    PERL_UNUSED_ARG(mg);
a2006 1
    PERL_UNUSED_ARG(mg);
d2015 1
a2015 1
    const struct ufuncs * const uf = (struct ufuncs *)mg->mg_ptr;
a2024 1
    PERL_UNUSED_ARG(mg);
d2032 1
a2032 3
    regexp * const re = (regexp *)mg->mg_obj;
    PERL_UNUSED_ARG(sv);

a2044 1
    PERL_UNUSED_ARG(sv);
a2057 1
    PERL_UNUSED_ARG(sv);
d2067 1
a2067 1
    register const char *s;
d2080 2
a2081 2
	s = SvPV_nolen_const(sv);
	PL_debug = get_debug_opts_flags((char **)&s, 0) | DEBUG_TOP_FLAG;
d2126 6
a2131 2
	Safefree(PL_inplace);
	PL_inplace = SvOK(sv) ? savesvpv(sv) : Nullch;
d2135 4
a2138 2
	    Safefree(PL_osname);
	    PL_osname = Nullch;
d2141 1
a2141 1
		PL_osname = savesvpv(sv);
d2153 2
a2154 1
	if (PL_perldb && !PL_DBsingle)
d2183 1
a2183 1
		    const char * const ptr = SvPV_const(sv, len) ;
d2217 1
a2217 1
	s = IoTOP_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
d2222 1
a2222 1
	s = IoFMT_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
d2238 1
a2238 1
	    IO * const io = GvIOp(PL_defoutgv);
d2284 1
a2284 1
	PL_ofmt = savesvpv(sv);
d2404 2
a2405 2
	    const char *p = SvPV_const(sv, len);
            Groups_t *gary = NULL;
d2407 14
a2420 20
            while (isSPACE(*p))
                ++p;
            PL_egid = Atol(p);
            for (i = 0; i < NGROUPS; ++i) {
                while (*p && !isSPACE(*p))
                    ++p;
                while (isSPACE(*p))
                    ++p;
                if (!*p)
                    break;
                if(!gary)
                    Newx(gary, i + 1, Groups_t);
                else
                    Renew(gary, i + 1, Groups_t);
                gary[i] = Atol(p);
            }
            if (i)
                (void)setgroups(i, gary);
            if (gary)
                Safefree(gary);
d2461 1
a2461 1
	    s = SvPV_const(sv, len);
d2483 2
a2484 2
	     s = SvPV_const(sv, len);
	     un.pst_command = (char *)s;
d2539 1
a2539 1
    register const char * const *sigv;
d2556 1
a2556 1
static SV* PL_sig_sv;
d2569 2
a2570 2
    SV *sv = Nullsv;
    SV * const tSv = PL_Sv;
d2574 1
a2574 1
    XPV * const tXpv = PL_Xpv;
d2595 1
a2595 1
	SAVEDESTRUCTOR_X(S_unwind_handler_stack, (void*)&flags);
d2607 1
a2607 2
	|| SvTYPE(cv) != SVt_PVCV) {
	HV *st;
a2608 1
    }
d2624 1
a2624 1
	PL_sig_sv = sv;
d2656 1
a2656 1
	Perl_die(aTHX_ Nullch);
d2678 1
a2678 1
S_restore_magic(pTHX_ const void *p)
d2680 2
a2681 2
    MGS* const mgs = SSPTR(PTR2IV(p), MGS*);
    SV* const sv = mgs->mgs_sv;
d2692 2
a2693 10
	if (SvGMAGICAL(sv)) {
	    /* downgrade public flags to private,
	       and discard any other private flags */

	    U32 public = SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK);
	    if (public) {
		SvFLAGS(sv) &= ~( public | SVp_IOK|SVp_NOK|SVp_POK );
		SvFLAGS(sv) |= ( public << PRIVSHIFT );
	    }
	}
d2719 1
a2719 1
S_unwind_handler_stack(pTHX_ const void *p)
d2721 1
a2721 1
    const U32 flags = *(const U32*)p;
d2728 1
a2728 1
	SvREFCNT_dec(PL_sig_sv);
d2732 1
a2732 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a57 3
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
Signal_t Perl_csighandler(int sig, siginfo_t *, void *);
#else
d59 8
a90 1
    dVAR;
a92 4
    /* Turning READONLY off for a copy-on-write scalar (including shared
       hash keys) is a bad idea.  */
    if (SvIsCOW(sv))
      sv_force_normal_flags(sv, 0);
d103 1
a103 4
    if (!(SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK))) {
	/* No public flags are set, so promote any private flags to public.  */
	SvFLAGS(sv) |= (SvFLAGS(sv) & (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
    }
a117 1
    PERL_UNUSED_CONTEXT;
a130 33

/* is this container magic (%ENV, $1 etc), or value magic (pos, taint etc)? */

STATIC bool
S_is_container_magic(const MAGIC *mg)
{
    switch (mg->mg_type) {
    case PERL_MAGIC_bm:
    case PERL_MAGIC_fm:
    case PERL_MAGIC_regex_global:
    case PERL_MAGIC_nkeys:
#ifdef USE_LOCALE_COLLATE
    case PERL_MAGIC_collxfrm:
#endif
    case PERL_MAGIC_qr:
    case PERL_MAGIC_taint:
    case PERL_MAGIC_vec:
    case PERL_MAGIC_vstring:
    case PERL_MAGIC_utf8:
    case PERL_MAGIC_substr:
    case PERL_MAGIC_defelem:
    case PERL_MAGIC_arylen:
    case PERL_MAGIC_pos:
    case PERL_MAGIC_backref:
    case PERL_MAGIC_arylen_p:
    case PERL_MAGIC_rhash:
    case PERL_MAGIC_symtab:
	return 0;
    default:
	return 1;
    }
}

a141 1
    dVAR;
d153 1
a153 1
    sv_2mortal(SvREFCNT_inc_simple_NN(sv));
a221 1
    dVAR;
a234 2
	if (PL_localizing == 2 && !S_is_container_magic(mg))
	    continue;
a253 1
    dVAR;
d271 1
a271 1
	len = utf8_length(s, s + len);
d345 1
a345 1
Perl_mg_find(pTHX_ const SV *sv, int type)
a346 1
    PERL_UNUSED_CONTEXT;
d354 1
a354 1
    return NULL;
d377 1
a377 1
	    if (isUPPER(type) && type != PERL_MAGIC_uvar) {
a392 38
=for apidoc mg_localize

Copy some of the magic from an existing SV to new localized version of
that SV. Container magic (eg %ENV, $1, tie) gets copied, value magic
doesn't (eg taint, pos).

=cut
*/

void
Perl_mg_localize(pTHX_ SV *sv, SV *nsv)
{
    dVAR;
    MAGIC *mg;
    for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	const MGVTBL* const vtbl = mg->mg_virtual;
	if (!S_is_container_magic(mg))
	    continue;
		
	if ((mg->mg_flags & MGf_LOCAL) && vtbl->svt_local)
	    (void)CALL_FPTR(vtbl->svt_local)(aTHX_ nsv, mg);
	else
	    sv_magicext(nsv, mg->mg_obj, mg->mg_type, vtbl,
			    mg->mg_ptr, mg->mg_len);

	/* container types should remain read-only across localization */
	SvFLAGS(nsv) |= SvREADONLY(sv);
    }

    if (SvTYPE(nsv) >= SVt_PVMG && SvMAGIC(nsv)) {
	SvFLAGS(nsv) |= SvMAGICAL(sv);
	PL_localizing = 1;
	SvSETMAGIC(nsv);
	PL_localizing = 0;
    }	    
}

/*
d429 1
a429 1
    dVAR;
d432 5
a436 17
    if (PL_curpm) {
	register const REGEXP * const rx = PM_GETRE(PL_curpm);
	if (rx) {
	    if (mg->mg_obj) {			/* @@+ */
		/* return the number possible */
		return rx->nparens;
	    } else {				/* @@- */
		I32 paren = rx->lastparen;

		/* return the last filled */
		while ( paren >= 0
			&& (rx->offs[paren].start == -1
			    || rx->offs[paren].end == -1) )
		    paren--;
		return (U32)paren;
	    }
	}
d445 1
a445 24
    dVAR;
    if (PL_curpm) {
	register const REGEXP * const rx = PM_GETRE(PL_curpm);
	if (rx) {
	    register const I32 paren = mg->mg_len;
	    register I32 s;
	    register I32 t;
	    if (paren < 0)
		return 0;
	    if (paren <= (I32)rx->nparens &&
		(s = rx->offs[paren].start) != -1 &&
		(t = rx->offs[paren].end) != -1)
		{
		    register I32 i;
		    if (mg->mg_obj)		/* @@+ */
			i = t;
		    else			/* @@- */
			i = s;

		    if (i > 0 && RX_MATCH_UTF8(rx)) {
			const char * const b = rx->subbeg;
			if (b)
			    i = utf8_length((U8*)b, (U8*)(b+i));
		    }
d447 20
a466 1
		    sv_setiv(sv, i);
d468 3
a470 1
	}
d478 1
a478 2
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
a485 1
    dVAR;
d488 2
a489 2
    register const REGEXP * rx;
    const char * const remaining = mg->mg_ptr + 1;
a491 27
    case '\020':		
      if (*remaining == '\0') { /* ^P */
          break;
      } else if (strEQ(remaining, "REMATCH")) { /* $^PREMATCH */
          goto do_prematch;
      } else if (strEQ(remaining, "OSTMATCH")) { /* $^POSTMATCH */
          goto do_postmatch;
      }
      break;
    case '\015': /* $^MATCH */
	if (strEQ(remaining, "ATCH")) {
        goto do_match;
    } else {
        break;
    }
    case '`':
      do_prematch:
      paren = RX_BUFF_IDX_PREMATCH;
      goto maybegetparen;
    case '\'':
      do_postmatch:
      paren = RX_BUFF_IDX_POSTMATCH;
      goto maybegetparen;
    case '&':
      do_match:
      paren = RX_BUFF_IDX_FULLMATCH;
      goto maybegetparen;
d493 1
a493 3
    case '5': case '6': case '7': case '8': case '9':
      paren = atoi(mg->mg_ptr);
    maybegetparen:
a494 2
      getparen:
        i = CALLREG_NUMBUF_LENGTH((REGEXP * const)rx, sv, paren);
d496 17
d516 2
a517 1
	} else {
d519 6
a524 2
		    report_uninit(sv);
		return 0;
d526 1
d541 24
a585 26
void
Perl_emulate_cop_io(pTHX_ const COP *const c, SV *const sv)
{
    if (!(CopHINTS_get(c) & (HINT_LEXICAL_IO_IN|HINT_LEXICAL_IO_OUT)))
	sv_setsv(sv, &PL_sv_undef);
    else {
	sv_setpvs(sv, "");
	SvUTF8_off(sv);
	if ((CopHINTS_get(c) & HINT_LEXICAL_IO_IN)) {
	    SV *const value = Perl_refcounted_he_fetch(aTHX_
						       c->cop_hints_hash,
						       0, "open<", 5, 0, 0);
	    assert(value);
	    sv_catsv(sv, value);
	}
	sv_catpvs(sv, "\0");
	if ((CopHINTS_get(c) & HINT_LEXICAL_IO_OUT)) {
	    SV *const value = Perl_refcounted_he_fetch(aTHX_
						       c->cop_hints_hash,
						       0, "open>", 5, 0, 0);
	    assert(value);
	    sv_catsv(sv, value);
	}
    }
}

a588 1
    dVAR;
d591 1
d600 2
a601 7
    case '\003':		/* ^C, ^CHILD_ERROR_NATIVE */
	if (nextchar == '\0') {
	    sv_setiv(sv, (IV)PL_minus_c);
	}
	else if (strEQ(remaining, "HILD_ERROR_NATIVE")) {
	    sv_setiv(sv, (IV)STATUS_NATIVE);
        }
d606 3
d612 1
a612 1
#if defined(MACOS_TRADITIONAL)
d619 2
a620 1
#elif defined(VMS)
d632 2
a633 1
#elif defined(OS2)
d646 2
a647 1
#elif defined(WIN32)
d649 1
a649 1
		  const DWORD dwErr = GetLastError();
d666 3
d682 4
a685 1
	sv_setpv(sv, PL_inplace); /* Will undefine sv if PL_inplace is NULL */
d693 5
a697 1
	    Perl_emulate_cop_io(aTHX_ &PL_compiling, sv);
d700 2
a701 8
    case '\020':		
	if (nextchar == '\0') {       /* ^P */
	    sv_setiv(sv, (IV)PL_perldb);
	} else if (strEQ(remaining, "REMATCH")) { /* $^PREMATCH */
	    goto do_prematch_fetch;
	} else if (strEQ(remaining, "OSTMATCH")) { /* $^POSTMATCH */
	    goto do_postmatch_fetch;
	}
d705 1
a705 1
	    if (PL_parser && PL_parser->lex_state != LEX_NOTPARSING)
d726 1
a726 1
    case '\025':		/* $^UNICODE, $^UTF8LOCALE, $^UTF8CACHE */
a730 2
	else if (strEQ(remaining, "TF8CACHE"))
	    sv_setiv(sv, (IV) PL_utf8cache);
d749 1
d751 2
a752 4
		if (bits) {
		    SV ** const bits_all = hv_fetchs(bits, "all", FALSE);
		    if (bits_all)
			sv_setsv(sv, *bits_all);
d759 1
a759 2
	        sv_setpvn(sv, (char *) (PL_compiling.cop_warnings + 1),
			  *PL_compiling.cop_warnings);
a763 2
    case '\015': /* $^MATCH */
	if (strEQ(remaining, "ATCH")) {
d766 44
a809 8
	    if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
		/*
		 * Pre-threads, this was paren = atoi(GvENAME((GV*)mg->mg_obj));
		 * XXX Does the new way break anything?
		 */
		paren = atoi(mg->mg_ptr); /* $& is in [0] */
		CALLREG_NUMBUF_FETCH(rx,paren,sv);
		break;
a810 1
	    sv_setsv(sv,&PL_sv_undef);
d812 1
d816 3
a818 4
	    if (rx->lastparen) {
	        CALLREG_NUMBUF_FETCH(rx,rx->lastparen,sv);
	        break;
	    }
d824 3
a826 5
	    if (rx->lastcloseparen) {
	        CALLREG_NUMBUF_FETCH(rx,rx->lastcloseparen,sv);
	        break;
	    }

a830 1
      do_prematch_fetch:
d832 4
a835 2
	    CALLREG_NUMBUF_FETCH(rx,-2,sv);
	    break;
a839 1
      do_postmatch_fetch:
d841 5
a845 2
	    CALLREG_NUMBUF_FETCH(rx,-1,sv);
	    break;
d870 1
a870 1
	    sv_catpvs(sv,"_TOP");
d897 1
a897 1
	sv_setiv(sv, (IV)CopARYBASE_get(PL_curcop));
d909 3
d940 3
d946 3
d953 1
a953 1
	    I32 i, num_groups = getgroups(0, gary);
d956 3
a958 2
	    for (i = 0; i < num_groups; i++)
		Perl_sv_catpvf(aTHX_ sv, " %"IVdf, (IV)gary[i]);
d961 1
d963 2
a964 1
#endif
d970 5
d992 7
a998 5
    dVAR;
    STRLEN len = 0, klen;
    const char *s = SvOK(sv) ? SvPV_const(sv,len) : "";
    const char * const ptr = MgPV_const(mg,klen);
    my_setenv(ptr, s);
d1004 3
a1006 3
	SV ** const valp = hv_fetch(GvHVn(PL_envgv), ptr, klen, FALSE);
	if (valp)
	    s = SvOK(*valp) ? SvPV_const(*valp, len) : "";
d1017 1
a1017 1
	    char pathbuf[256], eltbuf[256], *cp, *elt;
a1020 2
	    my_strlcpy(eltbuf, s, sizeof(eltbuf));
	    elt = eltbuf;
d1030 1
a1030 1
		    if ((cp = strchr(elt, ':')) != NULL)
a1047 5
#ifdef VMS  /* Hmm.  How do we get $Config{path_sep} from C? */
		const char path_sep = '|';
#else
		const char path_sep = ':';
#endif
d1049 1
a1049 1
			     s, strend, path_sep, &i);
d1051 2
a1052 6
		if (i >= (I32)sizeof tmpbuf   /* too long -- assume the worst */
#ifdef VMS
		      || !strchr(tmpbuf, ':') /* no colon thus no device name -- assume relative path */
#else
		      || *tmpbuf != '/'       /* no starting slash -- assume relative path */
#endif
d1069 1
a1069 1
    my_setenv(MgPV_nolen_const(mg),NULL);
a1075 2
    dVAR;
    PERL_UNUSED_ARG(mg);
d1086 1
a1086 1
		      SvPV_nolen_const(hv_iterval((HV*)sv, entry)));
a1095 1
    dVAR;
d1098 1
d1104 1
d1108 10
d1123 2
a1124 2
    const sigset_t * const ossetp = (const sigset_t *) SvPV_nolen_const( save_sv );
    (void)sigprocmask(SIG_SETMASK, ossetp, NULL);
a1129 1
    dVAR;
d1131 1
a1131 1
    const I32 i = whichsig(MgPV_nolen_const(mg));
d1136 2
a1137 1
	    Sighandler_t sigstate = rsignal_state(i);
d1139 1
a1139 2
	    if (PL_sig_handlers_initted && PL_sig_ignoring[i])
		sigstate = SIG_IGN;
d1142 1
a1142 2
	    if (PL_sig_handlers_initted && PL_sig_defaulting[i])
		sigstate = SIG_DFL;
d1145 2
a1146 2
    	    if(sigstate == (Sighandler_t) SIG_IGN)
    	    	sv_setpvs(sv,"IGNORE");
d1149 1
a1149 1
	    PL_psig_ptr[i] = SvREFCNT_inc_simple_NN(sv);
a1160 1
    dVAR;
d1164 1
a1164 1
	SV** svp = NULL;
d1167 1
a1167 1
	else if (strEQ(s,"__WARN__") && PL_warnhook != PERL_WARNHOOK_FATAL)
d1169 2
d1172 3
a1174 3
	    SV *const to_dec = *svp;
	    *svp = NULL;
	    SvREFCNT_dec(to_dec);
d1179 1
a1179 1
	const I32 i = whichsig(s);
d1189 1
a1189 1
	    save_sv = newSVpvn((char *)(&save), sizeof(sigset_t));
d1201 1
a1201 1
	    (void)rsignal(i, (Sighandler_t) SIG_DFL);
d1208 1
a1208 1
		SV * const to_dec=PL_psig_ptr[i];
a1219 17
/*
 * The signal handling nomenclature has gotten a bit confusing since the advent of
 * safe signals.  S_raise_signal only raises signals by analogy with what the 
 * underlying system's signal mechanism does.  It might be more proper to say that
 * it defers signals that have already been raised and caught.  
 *
 * PL_sig_pending and PL_psig_pend likewise do not track signals that are pending 
 * in the sense of being on the system's signal queue in between raising and delivery.  
 * They are only pending on Perl's deferral list, i.e., they track deferred signals 
 * awaiting delivery after the current Perl opcode completes and say nothing about
 * signals raised but not yet caught in the underlying signal implementation.
 */

#ifndef SIG_PENDING_DIE_COUNT
#  define SIG_PENDING_DIE_COUNT 120
#endif

a1222 1
    dVAR;
d1226 1
a1226 3
    if (++PL_sig_pending >= SIG_PENDING_DIE_COUNT)
	Perl_croak(aTHX_ "Maximal count of pending signals (%lu) exceeded",
		(unsigned long)SIG_PENDING_DIE_COUNT);
a1229 3
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
Perl_csighandler(int sig, siginfo_t *sip PERL_UNUSED_DECL, void *uap PERL_UNUSED_DECL)
#else
a1230 1
#endif
a1236 2
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#endif
d1249 1
a1249 13
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#endif
   if (
#ifdef SIGILL
	   sig == SIGILL ||
#endif
#ifdef SIGBUS
	   sig == SIGBUS ||
#endif
#ifdef SIGSEGV
	   sig == SIGSEGV ||
#endif
	   (PL_signals & PERL_SIGNALS_UNSAFE_FLAG))
a1251 3
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
	(*PL_sighandlerp)(sig, NULL, NULL);
#else
a1252 1
#endif
a1280 1
    dVAR;
a1287 3
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
	    (*PL_sighandlerp)(sig, NULL, NULL);
#else
a1288 1
#endif
a1296 1
    dVAR;
d1298 1
a1298 1
    SV** svp = NULL;
d1303 1
a1303 1
    SV* to_dec = NULL;
d1320 2
a1321 3
	    if (*svp != PERL_WARNHOOK_FATAL)
		to_dec = *svp;
	    *svp = NULL;
d1325 1
a1325 1
	i = whichsig(s);	/* ...no, a brick */
d1337 1
a1337 1
	save_sv = newSVpvn((char *)(&save), sizeof(sigset_t));
d1353 1
a1353 1
	PL_psig_ptr[i] = SvREFCNT_inc_simple_NN(sv);
d1366 1
a1366 1
	    *svp = SvREFCNT_inc_simple_NN(sv);
d1371 1
a1371 1
    s = SvOK(sv) ? SvPV_force(sv,len) : "DEFAULT";
d1378 1
a1378 1
	    (void)rsignal(i, (Sighandler_t) SIG_IGN);
d1390 1
a1390 1
	    (void)rsignal(i, (Sighandler_t) SIG_DFL);
d1400 1
a1400 1
	    Perl_sv_insert(aTHX_ sv, 0, 0, STR_WITH_LEN("main::"));
d1404 1
a1404 1
	    *svp = SvREFCNT_inc_simple_NN(sv);
a1418 2
    dVAR;
    HV* stash;
d1420 2
a1421 24

    /* Bail out if destruction is going on */
    if(PL_dirty) return 0;

    /* Skip _isaelem because _isa will handle it shortly */
    if (PL_delaymagic & DM_ARRAY && mg->mg_type == PERL_MAGIC_isaelem)
	return 0;

    /* XXX Once it's possible, we need to
       detect that our @@ISA is aliased in
       other stashes, and act on the stashes
       of all of the aliases */

    /* The first case occurs via setisa,
       the second via setisa_elem, which
       calls this same magic */
    stash = GvSTASH(
        SvTYPE(mg->mg_obj) == SVt_PVGV
            ? (GV*)mg->mg_obj
            : (GV*)SvMAGIC(mg->mg_obj)->mg_obj
    );

    mro_isa_changed_in(stash);

a1427 1
    dVAR;
d1430 1
a1470 1
    dVAR;
d1498 1
a1498 1
    dVAR; dSP;
d1526 1
a1526 1
    dVAR; dSP;
d1545 2
a1546 2
    dVAR; dSP;
    I32 retval = 0;
d1553 1
a1553 3
	retval = SvIV(sv)-1;
	if (retval < -1)
	    Perl_croak(aTHX_ "FETCHSIZE returned a negative value");
d1558 1
a1558 1
    return (U32) retval;
d1564 1
a1564 1
    dVAR; dSP;
d1581 1
a1581 1
    dVAR; dSP;
d1604 1
a1604 1
Perl_magic_existspack(pTHX_ SV *sv, const MAGIC *mg)
d1612 2
a1613 2
    dVAR; dSP;
    SV *retval;
a1638 2
    else
	retval = &PL_sv_undef;
a1646 1
    dVAR;
d1665 1
a1665 1
Perl_magic_getarylen(pTHX_ SV *sv, const MAGIC *mg)
d1667 1
a1667 2
    dVAR;
    const AV * const obj = (AV*)mg->mg_obj;
d1669 1
a1669 1
	sv_setiv(sv, AvFILL(obj) + CopARYBASE_get(PL_curcop));
d1679 1
a1679 2
    dVAR;
    AV * const obj = (AV*)mg->mg_obj;
d1681 1
a1681 1
	av_fill(obj, SvIV(sv) - CopARYBASE_get(PL_curcop));
a1690 22
Perl_magic_freearylen_p(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    PERL_UNUSED_ARG(sv);
    /* during global destruction, mg_obj may already have been freed */
    if (PL_in_clean_all)
	return 0;

    mg = mg_find (mg->mg_obj, PERL_MAGIC_arylen);

    if (mg) {
	/* arylen scalar holds a pointer back to the array, but doesn't own a
	   reference. Hence the we (the array) are about to go away with it
	   still pointing at us. Clear its pointer, else it would be pointing
	   at free memory. See the comment in sv_magic about reference loops,
	   and why it can't own a reference to us.  */
	mg->mg_obj = 0;
    }
    return 0;
}

int
a1692 1
    dVAR;
a1693 1
    PERL_UNUSED_ARG(mg);
d1696 3
a1698 3
	MAGIC * const found = mg_find(lsv, PERL_MAGIC_regex_global);
	if (found && found->mg_len >= 0) {
	    I32 i = found->mg_len;
d1701 1
a1701 1
	    sv_setiv(sv, i + CopARYBASE_get(PL_curcop));
a1711 1
    dVAR;
a1715 1
    MAGIC* found;
d1717 1
a1717 1
    PERL_UNUSED_ARG(mg);
d1720 2
a1721 4
	found = mg_find(lsv, PERL_MAGIC_regex_global);
    else
	found = NULL;
    if (!found) {
d1724 2
a1725 6
#ifdef PERL_OLD_COPY_ON_WRITE
    if (SvIsCOW(lsv))
        sv_force_normal_flags(lsv, 0);
#endif
	found = sv_magicext(lsv, NULL, PERL_MAGIC_regex_global, &PL_vtbl_mglob,
			    NULL, 0);
d1728 1
a1728 1
	found->mg_len = -1;
d1733 1
a1733 1
    pos = SvIV(sv) - CopARYBASE_get(PL_curcop);
d1755 2
a1756 2
    found->mg_len = pos;
    found->mg_flags &= ~MGf_MINMATCH;
d1762 14
d1778 1
d1780 1
a1782 2
    Perl_croak(aTHX_ "Perl_magic_setglob is dead code?");

d1785 4
a1788 6
    if (isGV_with_GP(sv)) {
	/* We're actually already a typeglob, so don't need the stuff below.
	 */
	return 0;
    }
    gv =  gv_fetchsv(sv, GV_ADD, SVt_PVGV);
a1821 1
    dVAR;
d1823 1
a1823 1
    const char * const tmps = SvPV_const(sv, len);
d1832 1
a1832 2
	sv_insert(lsv, lvoff, lvlen, tmps, len);
	LvTARGLEN(sv) = sv_len_utf8(sv);
a1835 1
	const char *utf8;
d1837 3
a1839 8
	LvTARGLEN(sv) = len;
	utf8 = (char*)bytes_to_utf8((U8*)tmps, &len);
	sv_insert(lsv, lvoff, lvlen, utf8, len);
	Safefree(utf8);
    }
    else {
	sv_insert(lsv, lvoff, lvlen, tmps, len);
	LvTARGLEN(sv) = len;
d1841 2
a1842 1

a1849 1
    dVAR;
d1851 2
a1852 1
    TAINT_IF((PL_localizing != 1) && (mg->mg_len & 1));
a1858 1
    dVAR;
d1860 7
a1866 2
    /* update taint status */
    if (PL_tainted)
d1879 1
a1879 3
    if (lsv)
	sv_setuv(sv, do_vecget(lsv, LvTARGOFF(sv), LvTARGLEN(sv)));
    else
d1881 2
d1884 1
d1899 1
a1899 2
    dVAR;
    SV *targ = NULL;
d1903 10
a1912 3
	    HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, FALSE, 0);
            if (he)
                targ = HeVAL(he);
d1919 1
a1919 1
	if (targ && (targ != &PL_sv_undef)) {
d1922 1
a1922 1
	    LvTARG(sv) = SvREFCNT_inc_simple_NN(targ);
d1925 1
a1925 1
	    mg->mg_obj = NULL;
a1950 1
    dVAR;
d1952 1
a1952 1
    SV *value = NULL;
d1958 10
a1967 3
	HE * const he = hv_fetch_ent((HV*)ahv, mg->mg_obj, TRUE, 0);
        if (he)
            value = HeVAL(he);
d1969 1
a1969 1
	    Perl_croak(aTHX_ PL_no_helem_sv, SVfARG(mg->mg_obj));
d1974 1
a1974 1
	    LvTARG(sv) = NULL;	/* array can't be extended */
d1976 1
a1976 1
	    SV* const * const svp = av_fetch(av, LvTARGOFF(sv), TRUE);
d1981 1
a1981 1
    SvREFCNT_inc_simple_void(value);
d1986 1
a1986 1
    mg->mg_obj = NULL;
d1993 20
a2012 1
    return Perl_sv_kill_backrefs(aTHX_ sv, (AV*)mg->mg_obj);
a2017 1
    PERL_UNUSED_CONTEXT;
a2027 1
    SvTAIL_off(sv);
a2061 1
    dVAR;
a2076 1
    PERL_UNUSED_CONTEXT;
a2090 1
    PERL_UNUSED_CONTEXT;
d2092 4
a2095 4
    Safefree(mg->mg_ptr);	/* The mg_ptr holds the pos cache. */
    mg->mg_ptr = NULL;
    mg->mg_len = -1;		/* The mg_len holds the len cache. */
    return 0;
a2100 1
    dVAR;
a2101 3
    register I32 paren;
    register const REGEXP * rx;
    const char * const remaining = mg->mg_ptr + 1;
a2103 1

a2104 30
    case '\015': /* $^MATCH */
      if (strEQ(remaining, "ATCH"))
          goto do_match;
    case '`': /* ${^PREMATCH} caught below */
      do_prematch:
      paren = RX_BUFF_IDX_PREMATCH;
      goto setparen;
    case '\'': /* ${^POSTMATCH} caught below */
      do_postmatch:
      paren = RX_BUFF_IDX_POSTMATCH;
      goto setparen;
    case '&':
      do_match:
      paren = RX_BUFF_IDX_FULLMATCH;
      goto setparen;
    case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      paren = atoi(mg->mg_ptr);
      setparen:
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
            CALLREG_NUMBUF_STORE((REGEXP * const)rx,paren,sv);
            break;
	} else {
            /* Croak with a READONLY error when a numbered match var is
             * set without a previous pattern match. Unless it's C<local $1>
             */
            if (!PL_localizing) {
                Perl_croak(aTHX_ PL_no_modify);
            }
        }
d2109 1
a2109 1
	PL_minus_c = (bool)SvIV(sv);
d2115 1
a2115 1
	PL_debug = get_debug_opts(&s, 0) | DEBUG_TOP_FLAG;
d2118 1
a2118 1
	PL_debug = (SvIV(sv)) | DEBUG_TOP_FLAG;
d2124 1
a2124 1
	    gMacPerl_OSErr = SvIV(sv);
d2127 1
a2127 1
	    set_vaxc_errno(SvIV(sv));
d2133 1
a2133 1
	    os2_setsyserrno(SvIV(sv));
d2136 1
a2136 1
	    SETERRNO(SvIV(sv), 4);
d2149 1
a2149 1
		PL_encoding = NULL;
d2154 1
a2154 1
	PL_maxsysfd = SvIV(sv);
d2157 1
a2157 1
	PL_hints = SvIV(sv);
d2161 1
a2161 1
	PL_inplace = SvOK(sv) ? savesvpv(sv) : NULL;
d2166 1
a2166 1
	    PL_osname = NULL;
d2173 4
a2176 27
	    STRLEN len;
	    const char *const start = SvPV(sv, len);
	    const char *out = (const char*)memchr(start, '\0', len);
	    SV *tmp;
	    struct refcounted_he *tmp_he;


	    PL_compiling.cop_hints |= HINT_LEXICAL_IO_IN | HINT_LEXICAL_IO_OUT;
	    PL_hints
		|= HINT_LOCALIZE_HH | HINT_LEXICAL_IO_IN | HINT_LEXICAL_IO_OUT;

	    /* Opening for input is more common than opening for output, so
	       ensure that hints for input are sooner on linked list.  */
	    tmp = sv_2mortal(out ? newSVpvn(out + 1, start + len - out - 1)
			     : newSVpvs(""));
	    SvFLAGS(tmp) |= SvUTF8(sv);

	    tmp_he
		= Perl_refcounted_he_new(aTHX_ PL_compiling.cop_hints_hash, 
					 sv_2mortal(newSVpvs("open>")), tmp);

	    /* The UTF-8 setting is carried over  */
	    sv_setpvn(tmp, start, out ? (STRLEN)(out - start) : len);

	    PL_compiling.cop_hints_hash
		= Perl_refcounted_he_new(aTHX_ tmp_he,
					 sv_2mortal(newSVpvs("open<")), tmp);
d2180 4
a2183 10
      if (*remaining == '\0') { /* ^P */
          PL_perldb = SvIV(sv);
          if (PL_perldb && !PL_DBsingle)
              init_debugger();
          break;
      } else if (strEQ(remaining, "REMATCH")) { /* $^PREMATCH */
          goto do_prematch;
      } else if (strEQ(remaining, "OSTMATCH")) { /* $^POSTMATCH */
          goto do_postmatch;
      }
d2188 1
a2188 1
	PL_basetime = (Time_t)SvIV(sv);
a2190 5
    case '\025':	/* ^UTF8CACHE */
	 if (strEQ(mg->mg_ptr+1, "TF8CACHE")) {
	     PL_utf8cache = (signed char) sv_2iv(sv);
	 }
	 break;
d2194 1
a2194 1
	        i = SvIV(sv);
d2215 3
a2217 10
		    if (!accumulate) {
		        if (!specialWARN(PL_compiling.cop_warnings))
			    PerlMemShared_free(PL_compiling.cop_warnings);
			PL_compiling.cop_warnings = pWARN_NONE;
		    }
		    /* Yuck. I can't see how to abstract this:  */
		    else if (isWARN_on(((STRLEN *)SvPV_nolen_const(sv)) - 1,
				       WARN_ALL) && !any_fatals) {
			if (!specialWARN(PL_compiling.cop_warnings))
			    PerlMemShared_free(PL_compiling.cop_warnings);
d2222 4
a2225 7
			STRLEN len;
			const char *const p = SvPV_const(sv, len);

			PL_compiling.cop_warnings
			    = Perl_new_warnings_bitfield(aTHX_ PL_compiling.cop_warnings,
							 p, len);

d2245 1
a2245 1
	IoTOP_GV(GvIOp(PL_defoutgv)) =  gv_fetchsv(sv, GV_ADD, SVt_PVIO);
d2250 1
a2250 1
	IoFMT_GV(GvIOp(PL_defoutgv)) =  gv_fetchsv(sv, GV_ADD, SVt_PVIO);
d2253 1
a2253 1
	IoPAGE_LEN(GvIOp(PL_defoutgv)) = (SvIV(sv));
d2256 1
a2256 1
	IoLINES_LEFT(GvIOp(PL_defoutgv)) = (SvIV(sv));
d2261 1
a2261 1
	IoPAGE(GvIOp(PL_defoutgv)) = (SvIV(sv));
d2268 1
a2268 1
	    if ((SvIV(sv)) == 0)
d2280 4
d2295 1
a2295 1
	    PL_ors_sv = NULL;
d2305 1
a2305 1
	    PL_ofs_sv = NULL;
d2308 5
d2314 1
a2314 1
	CopARYBASE_set(&PL_compiling, SvIV(sv));
d2326 1
a2326 1
	    STATUS_NATIVE_CHILD_SET((U32)SvIV(sv));
d2329 1
a2329 1
	    STATUS_UNIX_EXIT_SET(SvIV(sv));
d2343 1
a2343 1
	PL_uid = SvIV(sv);
d2375 1
a2375 1
	PL_euid = SvIV(sv);
d2402 1
a2402 1
	PL_gid = SvIV(sv);
d2452 2
a2453 1
	    Safefree(gary);
d2456 1
a2456 1
	PL_egid = SvIV(sv);
d2493 1
a2493 1
	if (PL_origalen != 1) {
d2512 3
a2514 2
#elif defined(__hpux) && defined(PSTAT_SETCMD)
	if (PL_origalen != 1) {
d2520 19
a2538 27
#else
	if (PL_origalen > 1) {
	    /* PL_origalen is set in perl_parse(). */
	    s = SvPV_force(sv,len);
	    if (len >= (STRLEN)PL_origalen-1) {
		/* Longer than original, will be truncated. We assume that
		 * PL_origalen bytes are available. */
		Copy(s, PL_origargv[0], PL_origalen-1, char);
	    }
	    else {
		/* Shorter than original, will be padded. */
#ifdef PERL_DARWIN
		/* Special case for Mac OS X: see [perl #38868] */
		const int pad = 0;
#else
		/* Is the space counterintuitive?  Yes.
		 * (You were expecting \0?)
		 * Does it work?  Seems to.  (In Linux 2.4.20 at least.)
		 * --jhi */
		const int pad = ' ';
#endif
		Copy(s, PL_origargv[0], len, char);
		PL_origargv[0][len] = 0;
		memset(PL_origargv[0] + len + 1,
		       pad,  PL_origalen - len - 1);
	    }
	    PL_origargv[0][PL_origalen-1] = 0;
d2540 1
a2540 1
		PL_origargv[i] = 0;
a2541 1
#endif
d2545 5
d2554 15
d2570 1
a2570 1
Perl_whichsig(pTHX_ const char *sig)
d2572 1
a2572 2
    register char* const* sigv;
    PERL_UNUSED_CONTEXT;
d2574 1
a2574 1
    for (sigv = (char* const*)PL_sig_name; *sigv; sigv++)
d2576 1
a2576 1
	    return PL_sig_num[sigv - (char* const*)PL_sig_name];
d2588 4
a2592 3
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
Perl_sighandler(int sig, siginfo_t *sip, void *uap PERL_UNUSED_DECL)
#else
a2593 1
#endif
d2601 2
a2602 2
    GV *gv = NULL;
    SV *sv = NULL;
d2604 1
a2604 1
    CV *cv = NULL;
d2613 2
d2632 4
d2642 1
a2642 1
	cv = sv_2cv(PL_psig_ptr[sig], &st, &gv, GV_ADD);
d2656 1
a2656 1
	sv = SvREFCNT_inc_NN(PL_psig_name[sig]);
a2668 28
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
    {
	 struct sigaction oact;

	 if (sigaction(sig, 0, &oact) == 0 && oact.sa_flags & SA_SIGINFO) {
	      if (sip) {
		   HV *sih = newHV();
		   SV *rv  = newRV_noinc((SV*)sih);
		   /* The siginfo fields signo, code, errno, pid, uid,
		    * addr, status, and band are defined by POSIX/SUSv3. */
		   (void)hv_stores(sih, "signo", newSViv(sip->si_signo));
		   (void)hv_stores(sih, "code", newSViv(sip->si_code));
#if 0 /* XXX TODO: Configure scan for the existence of these, but even that does not help if the SA_SIGINFO is not implemented according to the spec. */
		   hv_stores(sih, "errno",      newSViv(sip->si_errno));
		   hv_stores(sih, "status",     newSViv(sip->si_status));
		   hv_stores(sih, "uid",        newSViv(sip->si_uid));
		   hv_stores(sih, "pid",        newSViv(sip->si_pid));
		   hv_stores(sih, "addr",       newSVuv(PTR2UV(sip->si_addr)));
		   hv_stores(sih, "band",       newSViv(sip->si_band));
#endif
		   EXTEND(SP, 2);
		   PUSHs((SV*)rv);
		   PUSHs(newSVpvn((char *)sip, sizeof(*sip)));
	      }

	 }
    }
#endif
d2691 1
a2691 1
	Perl_die(aTHX_ NULL);
d2698 2
a2714 1
    dVAR;
a2722 7
#ifdef PERL_OLD_COPY_ON_WRITE
	/* While magic was saved (and off) sv_setsv may well have seen
	   this SV as a prime candidate for COW.  */
	if (SvIsCOW(sv))
	    sv_force_normal_flags(sv, 0);
#endif

d2731 4
a2734 4
	    const U32 pubflags = SvFLAGS(sv) & (SVf_IOK|SVf_NOK|SVf_POK);
	    if (pubflags) {
		SvFLAGS(sv) &= ~( pubflags | (SVp_IOK|SVp_NOK|SVp_POK) );
		SvFLAGS(sv) |= ( pubflags << PRIVSHIFT );
a2763 1
    dVAR;
d2768 1
a2772 56
}

/*
=for apidoc magic_sethint

Triggered by a store to %^H, records the key/value pair to
C<PL_compiling.cop_hints_hash>.  It is assumed that hints aren't storing
anything that would need a deep copy.  Maybe we should warn if we find a
reference.

=cut
*/
int
Perl_magic_sethint(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    SV *key = (mg->mg_len == HEf_SVKEY) ? (SV *)mg->mg_ptr
	: sv_2mortal(newSVpvn(mg->mg_ptr, mg->mg_len));

    /* mg->mg_obj isn't being used.  If needed, it would be possible to store
       an alternative leaf in there, with PL_compiling.cop_hints being used if
       it's NULL. If needed for threads, the alternative could lock a mutex,
       or take other more complex action.  */

    /* Something changed in %^H, so it will need to be restored on scope exit.
       Doing this here saves a lot of doing it manually in perl code (and
       forgetting to do it, and consequent subtle errors.  */
    PL_hints |= HINT_LOCALIZE_HH;
    PL_compiling.cop_hints_hash
	= Perl_refcounted_he_new(aTHX_ PL_compiling.cop_hints_hash, key, sv);
    return 0;
}

/*
=for apidoc magic_sethint

Triggered by a delete from %^H, records the key to
C<PL_compiling.cop_hints_hash>.

=cut
*/
int
Perl_magic_clearhint(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    PERL_UNUSED_ARG(sv);

    assert(mg->mg_len == HEf_SVKEY);

    PERL_UNUSED_ARG(sv);

    PL_hints |= HINT_LOCALIZE_HH;
    PL_compiling.cop_hints_hash
	= Perl_refcounted_he_new(aTHX_ PL_compiling.cop_hints_hash,
				 (SV *)mg->mg_ptr, &PL_sv_placeholder);
    return 0;
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 *  Sam sat on the ground and put his head in his hands.  'I wish I had never
 *  come here, and I don't want to see no more magic,' he said, and fell silent.
 *
 *     [p.363 of _The Lord of the Rings_, II/vii: "The Mirror of Galadriel"]
a87 3

    PERL_ARGS_ASSERT_SAVE_MAGIC;

a120 1
    PERL_ARGS_ASSERT_MG_MAGICAL;
d122 10
a131 15
    if ((mg = SvMAGIC(sv))) {
	SvRMAGICAL_off(sv);
	do {
	    const MGVTBL* const vtbl = mg->mg_virtual;
	    if (vtbl) {
		if (vtbl->svt_get && !(mg->mg_flags & MGf_GSKIP))
		    SvGMAGICAL_on(sv);
		if (vtbl->svt_set)
		    SvSMAGICAL_on(sv);
		if (vtbl->svt_clear)
		    SvRMAGICAL_on(sv);
	    }
	} while ((mg = mg->mg_moremagic));
	if (!(SvFLAGS(sv) & (SVs_GMG|SVs_SMG)))
	    SvRMAGICAL_on(sv);
a140 1
    assert(mg);
a186 2
    PERL_ARGS_ASSERT_MG_GET;

a264 2
    PERL_ARGS_ASSERT_MG_SET;

a298 2
    PERL_ARGS_ASSERT_MG_LENGTH;

d311 1
a311 3
    {
	/* You can't know whether it's UTF-8 until you get the string again...
	 */
d313 1
a313 4

	if (DO_UTF8(sv)) {
	    len = utf8_length(s, s + len);
	}
d315 2
a324 2
    PERL_ARGS_ASSERT_MG_SIZE;

d340 1
a340 1
	    return AvFILLp((const AV *) sv); /* Fallback to non-tied array */
a363 2
    PERL_ARGS_ASSERT_MG_CLEAR;

a412 3

    PERL_ARGS_ASSERT_MG_COPY;

a449 3

    PERL_ARGS_ASSERT_MG_LOCALIZE;

a485 3

    PERL_ARGS_ASSERT_MG_FREE;

d495 1
a495 1
		SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
a499 1
	SvMAGIC_set(sv, moremagic);
a501 1
    SvMAGICAL_off(sv);
a512 2
    PERL_ARGS_ASSERT_MAGIC_REGDATA_CNT;

d518 1
a518 1
		return RX_NPARENS(rx);
d520 1
a520 1
		I32 paren = RX_LASTPAREN(rx);
d524 2
a525 2
			&& (RX_OFFS(rx)[paren].start == -1
			    || RX_OFFS(rx)[paren].end == -1) )
a538 3

    PERL_ARGS_ASSERT_MAGIC_REGDATUM_GET;

d547 3
a549 3
	    if (paren <= (I32)RX_NPARENS(rx) &&
		(s = RX_OFFS(rx)[paren].start) != -1 &&
		(t = RX_OFFS(rx)[paren].end) != -1)
d558 1
a558 1
			const char * const b = RX_SUBBEG(rx);
a572 1
    PERL_ARGS_ASSERT_MAGIC_REGDATUM_SET;
d575 1
a575 1
    Perl_croak(aTHX_ "%s", PL_no_modify);
a587 2
    PERL_ARGS_ASSERT_MAGIC_LEN;

d634 1
a634 1
	    paren = RX_LASTPAREN(rx);
d641 1
a641 1
	    paren = RX_LASTCLOSEPAREN(rx);
a669 2
    PERL_ARGS_ASSERT_EMULATE_COP_IO;

a702 2
    PERL_ARGS_ASSERT_MAGIC_GET;

d738 1
a738 1
		       sv_setpvs(sv,"");
d761 1
a761 1
		       sv_setpvs(sv, "");
d766 1
a766 1
		 dSAVE_ERRNO;
d769 1
a769 1
		 RESTORE_ERRNO;
d853 1
a853 1
		HV * const bits=get_hv("warnings::Bits", 0);
d876 1
a876 1
		 * Pre-threads, this was paren = atoi(GvENAME((const GV *)mg->mg_obj));
d888 2
a889 2
	    if (RX_LASTPAREN(rx)) {
	        CALLREG_NUMBUF_FETCH(rx,RX_LASTPAREN(rx),sv);
d897 2
a898 2
	    if (RX_LASTCLOSEPAREN(rx)) {
	        CALLREG_NUMBUF_FETCH(rx,RX_LASTCLOSEPAREN(rx),sv);
a929 1
	    SvUPGRADE(sv, SVt_PVLV);
d987 1
a987 1
	dSAVE_ERRNO;
d995 1
a995 1
	RESTORE_ERRNO;
a1038 2
    PERL_ARGS_ASSERT_MAGIC_GETUVAR;

a1052 2
    PERL_ARGS_ASSERT_MAGIC_SETENV;

a1131 1
    PERL_ARGS_ASSERT_MAGIC_CLEARENV;
a1140 1
    PERL_ARGS_ASSERT_MAGIC_SET_ALL_ENV;
d1148 2
a1149 2
	hv_iterinit(MUTABLE_HV(sv));
	while ((entry = hv_iternext(MUTABLE_HV(sv)))) {
d1152 1
a1152 1
		      SvPV_nolen_const(hv_iterval(MUTABLE_HV(sv), entry)));
a1162 1
    PERL_ARGS_ASSERT_MAGIC_CLEAR_ALL_ENV;
a1187 3

    PERL_ARGS_ASSERT_MAGIC_GETSIG;

a1219 1
    PERL_ARGS_ASSERT_MAGIC_CLEARSIG;
d1276 29
d1317 2
d1331 3
a1333 1
    if (
d1351 2
a1352 13
    else {
	/* Set a flag to say this signal is pending, that is awaiting delivery after
	 * the current Perl opcode completes */
	PL_psig_pend[sig]++;

#ifndef SIG_PENDING_DIE_COUNT
#  define SIG_PENDING_DIE_COUNT 120
#endif
	/* And one to say _a_ signal is pending */
	if (++PL_sig_pending >= SIG_PENDING_DIE_COUNT)
	    Perl_croak(aTHX_ "Maximal count of pending signals (%lu) exceeded",
		       (unsigned long)SIG_PENDING_DIE_COUNT);
    }
d1413 1
a1414 3

    PERL_ARGS_ASSERT_MAGIC_SETSIG;

d1463 1
a1463 1
    if (isGV_with_GP(sv) || SvROK(sv)) {
d1505 1
a1505 2
	    Perl_sv_insert_flags(aTHX_ sv, 0, 0, STR_WITH_LEN("main::"),
				 SV_GMAGIC);
a1525 2

    PERL_ARGS_ASSERT_MAGIC_SETISA;
d1545 2
a1546 28
            ? (const GV *)mg->mg_obj
            : (const GV *)mg_find(mg->mg_obj, PERL_MAGIC_isa)->mg_obj
    );

    if (stash)
	mro_isa_changed_in(stash);

    return 0;
}

int
Perl_magic_clearisa(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;
    HV* stash;

    PERL_ARGS_ASSERT_MAGIC_CLEARISA;

    /* Bail out if destruction is going on */
    if(PL_dirty) return 0;

    av_clear(MUTABLE_AV(sv));

    /* XXX see comments in magic_setisa */
    stash = GvSTASH(
        SvTYPE(mg->mg_obj) == SVt_PVGV
            ? (const GV *)mg->mg_obj
            : (const GV *)mg_find(mg->mg_obj, PERL_MAGIC_isa)->mg_obj
d1549 1
a1549 2
    if (stash)
	mro_isa_changed_in(stash);
a1557 1
    PERL_ARGS_ASSERT_MAGIC_SETAMAGIC;
d1568 1
a1568 1
    HV * const hv = MUTABLE_HV(LvTARG(sv));
a1569 2

    PERL_ARGS_ASSERT_MAGIC_GETNKEYS;
d1574 1
a1574 1
         if (! SvTIED_mg((const SV *)hv, PERL_MAGIC_tied))
a1588 1
    PERL_ARGS_ASSERT_MAGIC_SETNKEYS;
d1591 1
a1591 1
	hv_ksplit(MUTABLE_HV(LvTARG(sv)), SvIV(sv));
a1602 2
    PERL_ARGS_ASSERT_MAGIC_METHCALL;

d1609 1
a1609 1
		mPUSHp(mg->mg_ptr, mg->mg_len);
d1611 1
a1611 1
		PUSHs(MUTABLE_SV(mg->mg_ptr));
d1614 1
a1614 1
	    mPUSHi(mg->mg_len);
a1629 2
    PERL_ARGS_ASSERT_MAGIC_METHPACK;

a1646 2
    PERL_ARGS_ASSERT_MAGIC_GETPACK;

a1656 3

    PERL_ARGS_ASSERT_MAGIC_SETPACK;

a1667 2
    PERL_ARGS_ASSERT_MAGIC_CLEARPACK;

a1677 2
    PERL_ARGS_ASSERT_MAGIC_SIZEPACK;

a1697 2
    PERL_ARGS_ASSERT_MAGIC_WIPEPACK;

a1715 2
    PERL_ARGS_ASSERT_MAGIC_NEXTPACK;

a1737 2
    PERL_ARGS_ASSERT_MAGIC_EXISTSPACK;

d1746 2
a1747 2
    SV * const tied = SvTIED_obj(MUTABLE_SV(hv), mg);
    HV * const pkg = SvSTASH((const SV *)SvRV(tied));
a1748 2
    PERL_ARGS_ASSERT_MAGIC_SCALARPACK;

d1756 1
a1756 1
        magic_nextpack(MUTABLE_SV(hv), mg, key);
a1785 3

    PERL_ARGS_ASSERT_MAGIC_SETDBLINE;

d1803 1
a1803 4
    const AV * const obj = MUTABLE_AV(mg->mg_obj);

    PERL_ARGS_ASSERT_MAGIC_GETARYLEN;

d1816 1
a1816 4
    AV * const obj = MUTABLE_AV(mg->mg_obj);

    PERL_ARGS_ASSERT_MAGIC_SETARYLEN;

a1830 2

    PERL_ARGS_ASSERT_MAGIC_FREEARYLEN_P;
a1831 1

a1853 2

    PERL_ARGS_ASSERT_MAGIC_GETPOS;
a1879 1
    PERL_ARGS_ASSERT_MAGIC_SETPOS;
d1931 24
a1961 2

    PERL_ARGS_ASSERT_MAGIC_GETSUBSTR;
a1984 2

    PERL_ARGS_ASSERT_MAGIC_SETSUBSTR;
a2014 2

    PERL_ARGS_ASSERT_MAGIC_GETTAINT;
a2015 1

a2023 2

    PERL_ARGS_ASSERT_MAGIC_SETTAINT;
a2024 1

a2036 2

    PERL_ARGS_ASSERT_MAGIC_GETVEC;
a2049 1
    PERL_ARGS_ASSERT_MAGIC_SETVEC;
a2059 3

    PERL_ARGS_ASSERT_MAGIC_GETDEFELEM;

d2063 1
a2063 1
	    HE * const he = hv_fetch_ent(MUTABLE_HV(ahv), mg->mg_obj, FALSE, 0);
d2068 1
a2068 1
	    AV *const av = MUTABLE_AV(LvTARG(sv));
a2090 1
    PERL_ARGS_ASSERT_MAGIC_SETDEFELEM;
a2107 2
    PERL_ARGS_ASSERT_VIVIFY_DEFELEM;

d2112 1
a2112 1
	HE * const he = hv_fetch_ent(MUTABLE_HV(ahv), mg->mg_obj, TRUE, 0);
d2119 1
a2119 1
	AV *const av = MUTABLE_AV(LvTARG(sv));
d2140 1
a2140 2
    PERL_ARGS_ASSERT_MAGIC_KILLBACKREFS;
    return Perl_sv_kill_backrefs(aTHX_ sv, MUTABLE_AV(mg->mg_obj));
a2145 1
    PERL_ARGS_ASSERT_MAGIC_SETMGLOB;
d2153 19
a2175 2
    PERL_ARGS_ASSERT_MAGIC_SETUVAR;

d2184 3
a2186 13
    const char type = mg->mg_type;

    PERL_ARGS_ASSERT_MAGIC_SETREGEXP;

    if (type == PERL_MAGIC_qr) {
    } else if (type == PERL_MAGIC_bm) {
	SvTAIL_off(sv);
	SvVALID_off(sv);
    } else {
	assert(type == PERL_MAGIC_fm);
	SvCOMPILED_off(sv);
    }
    return sv_unmagic(sv, type);
a2203 2
    PERL_ARGS_ASSERT_MAGIC_SETCOLLXFRM;

a2222 1
    PERL_ARGS_ASSERT_MAGIC_SETUTF8;
a2241 2
    PERL_ARGS_ASSERT_MAGIC_SET;

d2270 1
a2270 1
                Perl_croak(aTHX_ "%s", PL_no_modify);
d2354 3
a2356 3
	    tmp = out ? newSVpvn_flags(out + 1, start + len - out - 1,
				       SVs_TEMP | SvUTF8(sv))
		: newSVpvs_flags("", SVs_TEMP | SvUTF8(sv));
d2360 1
a2360 2
					 newSVpvs_flags("open>", SVs_TEMP),
					 tmp);
d2367 1
a2367 2
					 newSVpvs_flags("open<", SVs_TEMP),
					 tmp);
a2521 1
	    SvUPGRADE(sv, SVt_PVLV);
a2762 2

    PERL_ARGS_ASSERT_WHICHSIG;
d2824 1
a2824 1
    if (!SvROK(PL_psig_ptr[sig]) || !(cv = MUTABLE_CV(SvRV(PL_psig_ptr[sig])))
d2861 1
a2861 1
		   SV *rv  = newRV_noinc(MUTABLE_SV(sih));
d2875 2
a2876 2
		   PUSHs(rv);
		   mPUSHp((char *)sip, sizeof(*sip));
d2884 1
a2884 1
    call_sv(MUTABLE_SV(cv), G_DISCARD|G_EVAL);
a2985 2
    PERL_ARGS_ASSERT_UNWIND_HANDLER_STACK;

d3008 2
a3009 4
    SV *key = (mg->mg_len == HEf_SVKEY) ? MUTABLE_SV(mg->mg_ptr)
	: newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP);

    PERL_ARGS_ASSERT_MAGIC_SETHINT;
d3026 1
a3026 1
=for apidoc magic_clearhint
a3036 2

    PERL_ARGS_ASSERT_MAGIC_CLEARHINT;
d3046 1
a3046 1
				 MUTABLE_SV(mg->mg_ptr), &PL_sv_placeholder);
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d80 1
a81 2
    U32 mgs_magical;
    bool mgs_readonly;
d103 1
a103 2
    mgs->mgs_magical = SvMAGICAL(sv);
    mgs->mgs_readonly = SvREADONLY(sv) != 0;
a127 2

    SvMAGICAL_off(sv);
d129 1
d194 1
a194 1
    bool have_new = 0;
a218 1
	MAGIC * const nextmg = mg->mg_moremagic;	/* it may delete itself */
d225 1
a225 2
	    if (!SvMAGIC(sv)) {
		(SSPTR(mgs_ix, MGS *))->mgs_magical = 0; /* recalculate flags */
a226 1
	    }
d228 1
a228 1
	    /* recalculate flags if this entry was deleted. */
d230 1
a230 1
		(SSPTR(mgs_ix, MGS *))->mgs_magical = 0;
d233 1
a233 1
	mg = nextmg;
a249 1
	    (SSPTR(mgs_ix, MGS *))->mgs_magical = 0; /* recalculate flags */
d288 1
a288 1
	    (SSPTR(mgs_ix, MGS*))->mgs_magical = 0;
a385 1
    MAGIC *nextmg;
d391 1
a391 1
    for (mg = SvMAGIC(sv); mg; mg = nextmg) {
a394 2
	nextmg = mg->mg_moremagic; /* it may delete itself */

d466 3
a468 7
Copy some of the magic from an existing SV to new localized version of that
SV. Container magic (eg %ENV, $1, tie) gets copied, value magic doesn't (eg
taint, pos).

If setmagic is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. 'local $x = $y'),
and that will handle the magic.
d474 1
a474 1
Perl_mg_localize(pTHX_ SV *sv, SV *nsv, bool setmagic)
d498 3
a500 5
	if (setmagic) {
	    PL_localizing = 1;
	    SvSETMAGIC(nsv);
	    PL_localizing = 0;
	}
d769 8
a776 1
#if defined(VMS)
d1024 2
a1030 2
	{
	dSAVE_ERRNO;
d1033 1
d1035 2
a1037 1
#endif
a1043 2
	if (SvPOKp(sv))
	    SvPOK_on(sv);    /* may have got removed during taint processing */
d1046 1
a1046 1

d1075 1
d1078 1
d1243 1
a1243 1
    int i = (I16)mg->mg_private;
a1246 4
    if (!i) {
	mg->mg_private = i = whichsig(MgPV_nolen_const(mg));
    }

d1274 5
d1281 53
a1333 3

    magic_setsig(NULL, mg);
    return sv_unmagic(sv, mg->mg_type);
d1372 1
a1372 1
	 * with risk we may be in malloc() or being destructed etc. */
a1378 1
	if (!PL_psig_pend) return;
d1386 1
a1386 1
	/* Add one to say _a_ signal is pending */
a1434 1
/* sv of NULL signifies that we're acting as magic_clearsig.  */
d1458 1
a1458 7
	else if (strEQ(s,"__WARN__")
		 && (sv ? 1 : PL_warnhook != PERL_WARNHOOK_FATAL)) {
	    /* Merge the existing behaviours, which are as follows:
	       magic_setsig, we always set svp to &PL_warnhook
	       (hence we always change the warnings handler)
	       For magic_clearsig, we don't change the warnings handler if it's
	       set to the &PL_warnhook.  */
d1460 1
a1460 1
	} else if (sv)
d1463 1
a1463 1
	if (svp && *svp) {
d1470 1
a1470 5
	i = (I16)mg->mg_private;
	if (!i) {
	    i = whichsig(s);	/* ...no, a brick */
	    mg->mg_private = (U16)i;
	}
d1472 2
a1473 2
	    if (sv)
		Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL), "No such signal: SIG%s", s);
d1496 1
d1498 4
a1501 19
	if (sv) {
	    PL_psig_ptr[i] = SvREFCNT_inc_simple_NN(sv);
	    SvTEMP_off(sv); /* Make sure it doesn't go away on us */

	    /* Signals don't change name during the program's execution, so once
	       they're cached in the appropriate slot of PL_psig_name, they can
	       stay there.

	       Ideally we'd find some way of making SVs at (C) compile time, or
	       at least, doing most of the work.  */
	    if (!PL_psig_name[i]) {
		PL_psig_name[i] = newSVpvn(s, len);
		SvREADONLY_on(PL_psig_name[i]);
	    }
	} else {
	    SvREFCNT_dec(PL_psig_name[i]);
	    PL_psig_name[i] = NULL;
	    PL_psig_ptr[i] = NULL;
	}
d1503 1
a1503 1
    if (sv && (isGV_with_GP(sv) || SvROK(sv))) {
d1506 3
d1512 7
a1518 8
    } else {
	if (sv && SvOK(sv)) {
	    s = SvPV_force(sv, len);
	} else {
	    sv = NULL;
	}
	if (sv && strEQ(s,"IGNORE")) {
	    if (i) {
d1520 2
a1521 2
		PL_sig_ignoring[i] = 1;
		(void)rsignal(i, PL_csighandlerp);
d1523 1
a1523 1
		(void)rsignal(i, (Sighandler_t) SIG_IGN);
a1524 1
	    }
d1526 3
a1528 2
	else if (!sv || strEQ(s,"DEFAULT") || !len) {
	    if (i) {
d1530 4
a1533 2
		PL_sig_defaulting[i] = 1;
		(void)rsignal(i, PL_csighandlerp);
d1535 1
a1535 1
		(void)rsignal(i, (Sighandler_t) SIG_DFL);
a1536 16
	    }
	}
	else {
	    /*
	     * We should warn if HINT_STRICT_REFS, but without
	     * access to a known hint bit in a known OP, we can't
	     * tell whether HINT_STRICT_REFS is in force or not.
	     */
	    if (!strchr(s,':') && !strchr(s,'\''))
		Perl_sv_insert_flags(aTHX_ sv, 0, 0, STR_WITH_LEN("main::"),
				     SV_GMAGIC);
	    if (i)
		(void)rsignal(i, PL_csighandlerp);
	    else
		*svp = SvREFCNT_inc_simple_NN(sv);
	}
d1538 14
a1551 1

d1556 2
a1557 1
    SvREFCNT_dec(to_dec);
d1566 2
d1571 3
d1578 18
a1595 1
    return magic_clearisa(NULL, mg);
a1597 1
/* sv of NULL signifies that we're acting as magic_setisa.  */
d1609 1
a1609 2
    if (sv)
	av_clear(MUTABLE_AV(sv));
d1611 1
a1611 8
    /* XXX Once it's possible, we need to
       detect that our @@ISA is aliased in
       other stashes, and act on the stashes
       of all of the aliases */

    /* The first case occurs via setisa,
       the second via setisa_elem, which
       calls this same magic */
d1901 1
a1901 1
    AV * const obj = MUTABLE_AV(mg->mg_obj);
d1924 3
a1926 2
	Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
		       "Attempt to set length of freed array");
d2046 2
a2047 2
    STRLEN offs = LvTARGOFF(sv);
    STRLEN rem = LvTARGLEN(sv);
d2053 2
a2054 2
	offs = sv_pos_u2b_flags(lsv, offs, &rem, SV_CONST_RETURN);
    if (offs > len)
d2056 1
a2056 1
    if (rem > len - offs)
d2058 1
a2058 1
    sv_setpvn(sv, tmps + offs, rem);
d2071 2
a2072 2
    STRLEN lvoff = LvTARGOFF(sv);
    STRLEN lvlen = LvTARGLEN(sv);
d2079 1
a2079 1
	lvoff = sv_pos_u2b_flags(lsv, lvoff, &lvlen, SV_CONST_RETURN);
d2086 1
a2086 1
	lvoff = sv_pos_u2b_flags(lsv, lvoff, &lvlen, SV_CONST_RETURN);
d2097 1
d2255 1
a2255 2
    if (!isGV_with_GP(sv))
	SvSCREAM_off(sv);
d2289 11
d2389 1
a2389 2
	if (DEBUG_x_TEST || DEBUG_B_TEST)
	    dump_all_perl(!DEBUG_B_TEST);
d2396 4
a2399 1
#ifdef VMS
d2401 2
a2402 2
#else
#  ifdef WIN32
d2404 2
a2405 2
#  else
#    ifdef OS2
d2407 1
a2407 1
#    else
d2410 1
d2416 2
a2417 1
	    SvREFCNT_dec(PL_encoding);
d2450 1
d2454 2
a2455 1
	    PL_hints |= HINT_LEXICAL_IO_IN | HINT_LEXICAL_IO_OUT;
d2460 15
a2474 9
				       SvUTF8(sv))
		: newSVpvs_flags("", SvUTF8(sv));
	    (void)hv_stores(GvHV(PL_hintgv), "open>", tmp);
	    mg_set(tmp);

	    tmp = newSVpvn_flags(start, out ? (STRLEN)(out - start) : len,
				        SvUTF8(sv));
	    (void)hv_stores(GvHV(PL_hintgv), "open<", tmp);
	    mg_set(tmp);
d2604 2
a2605 1
	SvREFCNT_dec(PL_ors_sv);
d2613 10
a2743 8
#ifdef _SC_NGROUPS_MAX
           int maxgrp = sysconf(_SC_NGROUPS_MAX);

           if (maxgrp < 0)
               maxgrp = NGROUPS;
#else
           int maxgrp = NGROUPS;
#endif
d2748 1
a2748 1
            for (i = 0; i < maxgrp; ++i) {
d2796 1
d2862 1
d2941 6
a2946 5
	Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL), "SIG%s handler \"%s\" not defined.\n",
		       PL_sig_name[sig], (gv ? GvENAME(gv)
					  : ((cv && CvGV(cv))
					     ? GvENAME(CvGV(cv))
					     : "__ANON__")));
d3052 2
a3053 4
	if (mgs->mgs_readonly)
	    SvREADONLY_on(sv);
	if (mgs->mgs_magical)
	    SvFLAGS(sv) |= mgs->mgs_magical;
a3162 20
    return 0;
}

/*
=for apidoc magic_clearhints

Triggered by clearing %^H, resets C<PL_compiling.cop_hints_hash>.

=cut
*/
int
Perl_magic_clearhints(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_CLEARHINTS;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(mg);
    if (PL_compiling.cop_hints_hash) {
	Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
	PL_compiling.cop_hints_hash = NULL;
    }
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a59 4
#ifdef HAS_PRCTL_SET_NAME
#  include <sys/prctl.h>
#endif

a82 1
    bool mgs_bumped;
a90 1
    bool bumped = FALSE;
a93 11
    /* we shouldn't really be called here with RC==0, but it can sometimes
     * happen via mg_clear() (which also shouldn't be called when RC==0,
     * but it can happen). Handle this case gracefully(ish) by not RC++
     * and thus avoiding the resultant double free */
    if (SvREFCNT(sv) > 0) {
    /* guard against sv getting freed midway through the mg clearing,
     * by holding a private reference for the duration. */
	SvREFCNT_inc_simple_void_NN(sv);
	bumped = TRUE;
    }

a106 1
    mgs->mgs_bumped = bumped;
d149 34
d186 1
a186 1
Do magic before a value is retrieved from the SV.  See C<sv_magic>.
d196 1
d199 2
d204 8
a211 1
    if (PL_localizing == 1 && sv == DEFSV) return 0;
d225 1
a225 1
	    vtbl->svt_get(aTHX_ sv, mg);
d261 6
a287 2
    if (PL_localizing == 2 && sv == DEFSV) return 0;

d297 1
a297 2
	if (PL_localizing == 2
	    && PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type))
d300 1
a300 1
	    vtbl->svt_set(aTHX_ sv, mg);
d330 1
a330 1
	    len = vtbl->svt_len(aTHX_ sv, mg);
d362 1
a362 1
	    len = vtbl->svt_len(aTHX_ sv, mg);
d406 1
a406 1
	    vtbl->svt_clear(aTHX_ sv, mg);
a412 20
static MAGIC*
S_mg_findext_flags(pTHX_ const SV *sv, int type, const MGVTBL *vtbl, U32 flags)
{
    PERL_UNUSED_CONTEXT;

    assert(flags <= 1);

    if (sv) {
	MAGIC *mg;

	for (mg = SvMAGIC(sv); mg; mg = mg->mg_moremagic) {
	    if (mg->mg_type == type && (!flags || mg->mg_virtual == vtbl)) {
		return mg;
	    }
	}
    }

    return NULL;
}

d424 9
a432 16
    return S_mg_findext_flags(aTHX_ sv, type, NULL, 0);
}

/*
=for apidoc mg_findext

Finds the magic pointer of C<type> with the given C<vtbl> for the C<SV>.  See
C<sv_magicext>.

=cut
*/

MAGIC*
Perl_mg_findext(pTHX_ const SV *sv, int type, const MGVTBL *vtbl)
{
    return S_mg_findext_flags(aTHX_ sv, type, vtbl, 1);
d454 1
a454 1
	    count += vtbl->svt_copy(aTHX_ sv, mg, nsv, key, klen);
a494 3
    if (nsv == DEFSV)
	return;

d497 1
a497 1
	if (PERL_MAGIC_TYPE_IS_VALUE_MAGIC(mg->mg_type))
d501 1
a501 1
	    (void)vtbl->svt_local(aTHX_ nsv, mg);
d507 1
a507 1
	if (!SvIsCOW(sv)) SvFLAGS(nsv) |= SvREADONLY(sv);
a519 18
#define mg_free_struct(sv, mg) S_mg_free_struct(aTHX_ sv, mg)
static void
S_mg_free_struct(pTHX_ SV *sv, MAGIC *mg)
{
    const MGVTBL* const vtbl = mg->mg_virtual;
    if (vtbl && vtbl->svt_free)
	vtbl->svt_free(aTHX_ sv, mg);
    if (mg->mg_ptr && mg->mg_type != PERL_MAGIC_regex_global) {
	if (mg->mg_len > 0 || mg->mg_type == PERL_MAGIC_utf8)
	    Safefree(mg->mg_ptr);
	else if (mg->mg_len == HEf_SVKEY)
	    SvREFCNT_dec(MUTABLE_SV(mg->mg_ptr));
    }
    if (mg->mg_flags & MGf_REFCOUNTED)
	SvREFCNT_dec(mg->mg_obj);
    Safefree(mg);
}

d537 1
d539 11
a549 1
	mg_free_struct(sv, mg);
a556 33
/*
=for apidoc Am|void|mg_free_type|SV *sv|int how

Remove any magic of type I<how> from the SV I<sv>.  See L</sv_magic>.

=cut
*/

void
Perl_mg_free_type(pTHX_ SV *sv, int how)
{
    MAGIC *mg, *prevmg, *moremg;
    PERL_ARGS_ASSERT_MG_FREE_TYPE;
    for (prevmg = NULL, mg = SvMAGIC(sv); mg; prevmg = mg, mg = moremg) {
	MAGIC *newhead;
	moremg = mg->mg_moremagic;
	if (mg->mg_type == how) {
	    /* temporarily move to the head of the magic chain, in case
	       custom free code relies on this historical aspect of mg_free */
	    if (prevmg) {
		prevmg->mg_moremagic = moremg;
		mg->mg_moremagic = SvMAGIC(sv);
		SvMAGIC_set(sv, mg);
	    }
	    newhead = mg->mg_moremagic;
	    mg_free_struct(sv, mg);
	    SvMAGIC_set(sv, newhead);
	    mg = prevmg;
	}
    }
    mg_magical(sv);
}

d633 1
a633 1
    Perl_croak_no_modify(aTHX);
d738 3
a740 1
	    SV *const value = cop_hints_fetch_pvs(c, "open<", 0);
d746 3
a748 1
	    SV *const value = cop_hints_fetch_pvs(c, "open>", 0);
d760 1
a760 1
    register const char *s = NULL;
a769 2
	if (SvTAINTED(PL_bodytarget))
	    SvTAINTED_on(sv);
a837 6
    case '\007':		/* ^GLOBAL_PHASE */
	if (strEQ(remaining, "LOBAL_PHASE")) {
	    sv_setpvn(sv, PL_phase_names[PL_phase],
		      strlen(PL_phase_names[PL_phase]));
	}
	break;
d853 1
a853 1
    case '\020':
d901 5
a905 2
		sv_setsv(sv, &PL_sv_undef);
		break;
d995 1
a995 1
		s = IoTOP_NAME(GvIOp(PL_defoutgv));
d1011 1
a1011 1
	if (GvIO(PL_defoutgv))
d1015 1
a1015 1
	if (GvIO(PL_defoutgv))
d1019 1
a1019 1
	if (GvIO(PL_defoutgv))
d1027 1
a1027 1
	sv_setiv(sv, 0);
d1030 1
a1030 1
	if (GvIO(PL_defoutgv))
a1036 13
    case '$': /* $$ */
	{
	    IV const pid = (IV)PerlProc_getpid();
	    if (isGV(mg->mg_obj) || SvIV(mg->mg_obj) != pid) {
		/* never set manually, or at least not since last fork */
		sv_setiv(sv, pid);
		/* never unsafe, even if reading in a tainted expression */
		SvTAINTED_off(sv);
	    }
	    /* else a value has been assigned manually, so do nothing */
	}
	break;

d1060 1
a1060 1
	sv_setiv(sv, (IV)PerlProc_getuid());
d1063 1
a1063 1
	sv_setiv(sv, (IV)PerlProc_geteuid());
d1066 1
a1066 1
	sv_setiv(sv, (IV)PerlProc_getgid());
d1069 1
a1069 1
	sv_setiv(sv, (IV)PerlProc_getegid());
d1131 1
d1255 1
a1255 3
        STRLEN siglen;
        const char * sig = MgPV_const(mg, siglen);
        mg->mg_private = i = whichsig_pvn(sig, siglen);
d1286 1
a1370 8
#if defined HAS_SIGPROCMASK
static void
unblock_sigmask(pTHX_ void* newset)
{
    sigprocmask(SIG_UNBLOCK, (sigset_t*)newset, NULL);
}
#endif

d1379 1
a1379 23
	    dSAVE_ERRNO;
#ifdef HAS_SIGPROCMASK
	    /* From sigaction(2) (FreeBSD man page):
	     * | Signal routines normally execute with the signal that
	     * | caused their invocation blocked, but other signals may
	     * | yet occur.
	     * Emulation of this behavior (from within Perl) is enabled
	     * using sigprocmask
	     */
	    int was_blocked;
	    sigset_t newset, oldset;

	    sigemptyset(&newset);
	    sigaddset(&newset, sig);
	    sigprocmask(SIG_BLOCK, &newset, &oldset);
	    was_blocked = sigismember(&oldset, sig);
	    if (!was_blocked) {
		SV* save_sv = newSVpvn((char *)(&newset), sizeof(sigset_t));
		ENTER;
		SAVEFREESV(save_sv);
		SAVEDESTRUCTOR_X(unblock_sigmask, SvPV_nolen(save_sv));
	    }
#endif
d1381 1
d1387 1
a1387 5
#ifdef HAS_SIGPROCMASK
	    if (!was_blocked)
		LEAVE;
#endif
	    RESTORE_ERRNO;
d1414 1
a1414 1
        if (memEQs(s, len, "__DIE__"))
d1416 1
a1416 1
	else if (memEQs(s, len, "__WARN__")
d1424 2
a1425 5
        } else if (sv) {
            SV *tmp = sv_newmortal();
            Perl_croak(aTHX_ "No such hook: %s",
                                pv_pretty(tmp, s, len, 0, NULL, NULL, 0));
        }
d1436 1
a1436 1
	    i = whichsig_pvn(s, len);   /* ...no, a brick */
d1440 2
a1441 5
	    if (sv) {
                SV *tmp = sv_newmortal();
		Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL), "No such signal: SIG%s",
                                            pv_pretty(tmp, s, len, 0, NULL, NULL, 0));
            }
d1497 1
a1497 1
	if (sv && memEQs(s, len,"IGNORE")) {
d1507 1
a1507 1
	else if (!sv || memEQs(s, len,"DEFAULT") || !len) {
d1550 1
a1550 1
    if (PL_delaymagic & DM_ARRAY_ISA && mg->mg_type == PERL_MAGIC_isaelem)
d1566 1
a1566 1
    if(PL_phase == PERL_PHASE_DESTRUCT) return 0;
d1571 8
a1578 16
    if (SvTYPE(mg->mg_obj) != SVt_PVGV && SvSMAGICAL(mg->mg_obj))
	/* This occurs with setisa_elem magic, which calls this
	   same function. */
	mg = mg_find(mg->mg_obj, PERL_MAGIC_isa);

    if (SvTYPE(mg->mg_obj) == SVt_PVAV) { /* multiple stashes */
	SV **svp = AvARRAY((AV *)mg->mg_obj);
	I32 items = AvFILLp((AV *)mg->mg_obj) + 1;
	while (items--) {
	    stash = GvSTASH((GV *)*svp++);
	    if (stash && HvENAME(stash)) mro_isa_changed_in(stash);
	}

	return 0;
    }

d1580 3
a1582 1
        (const GV *)mg->mg_obj
d1585 1
a1585 3
    /* The stash may have been detached from the symbol table, so check its
       name before doing anything. */
    if (stash && HvENAME_get(stash))
d1615 1
a1615 1
	     i = HvUSEDKEYS(hv);
d1637 3
a1639 29
/*
=for apidoc magic_methcall

Invoke a magic method (like FETCH).

C<sv> and C<mg> are the tied thingy and the tie magic.

C<meth> is the name of the method to call.

C<argc> is the number of args (in addition to $self) to pass to the method.

The C<flags> can be:

    G_DISCARD     invoke method with G_DISCARD flag and don't
                  return a value
    G_UNDEF_FILL  fill the stack with argc pointers to
                  PL_sv_undef

The arguments themselves are any values following the C<flags> argument.

Returns the SV (if any) returned by the method, or NULL on failure.


=cut
*/

SV*
Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, const char *meth, U32 flags,
		    U32 argc, ...)
a1642 1
    SV* ret = NULL;
a1645 11
    ENTER;

    if (flags & G_WRITING_TO_STDERR) {
	SAVETMPS;

	save_re_context();
	SAVESPTR(PL_stderrgv);
	PL_stderrgv = NULL;
    }

    PUSHSTACKi(PERLSI_MAGIC);
d1647 1
a1647 2

    EXTEND(SP, argc+1);
d1649 13
a1661 14
    if (flags & G_UNDEF_FILL) {
	while (argc--) {
	    PUSHs(&PL_sv_undef);
	}
    } else if (argc > 0) {
	va_list args;
	va_start(args, argc);

	do {
	    SV *const sv = va_arg(args, SV *);
	    PUSHs(sv);
	} while (--argc);

	va_end(args);
a1663 16
    if (flags & G_DISCARD) {
	call_method(meth, G_SCALAR|G_DISCARD);
    }
    else {
	if (call_method(meth, G_SCALAR))
	    ret = *PL_stack_sp--;
    }
    POPSTACK;
    if (flags & G_WRITING_TO_STDERR)
	FREETMPS;
    LEAVE;
    return ret;
}


/* wrapper for magic_methcall that creates the first arg */
d1665 1
a1665 24
STATIC SV*
S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, const char *meth, U32 flags,
    int n, SV *val)
{
    dVAR;
    SV* arg1 = NULL;

    PERL_ARGS_ASSERT_MAGIC_METHCALL1;

    if (mg->mg_ptr) {
	if (mg->mg_len >= 0) {
	    arg1 = newSVpvn_flags(mg->mg_ptr, mg->mg_len, SVs_TEMP);
	}
	else if (mg->mg_len == HEf_SVKEY)
	    arg1 = MUTABLE_SV(mg->mg_ptr);
    }
    else if (mg->mg_type == PERL_MAGIC_tiedelem) {
	arg1 = newSViv((IV)(mg->mg_len));
	sv_2mortal(arg1);
    }
    if (!arg1) {
	return Perl_magic_methcall(aTHX_ sv, mg, meth, flags, n - 1, val);
    }
    return Perl_magic_methcall(aTHX_ sv, mg, meth, flags, n, arg1, val);
d1671 1
a1671 2
    dVAR;
    SV* ret;
d1675 11
a1685 3
    ret = magic_methcall1(sv, mg, meth, 0, 1, NULL);
    if (ret)
	sv_setsv(sv, ret);
d1694 1
a1694 1
    if (mg->mg_type == PERL_MAGIC_tiedelem)
d1703 1
a1703 3
    dVAR;
    MAGIC *tmg;
    SV    *val;
d1707 5
a1711 20
    /* in the code C<$tied{foo} = $val>, the "thing" that gets passed to
     * STORE() is not $val, but rather a PVLV (the sv in this call), whose
     * public flags indicate its value based on copying from $val. Doing
     * mg_set() on the PVLV temporarily does SvMAGICAL_off(), then calls us.
     * So STORE()'s $_[2] arg is a temporarily disarmed PVLV. This goes
     * wrong if $val happened to be tainted, as sv hasn't got magic
     * enabled, even though taint magic is in the chain. In which case,
     * fake up a temporary tainted value (this is easier than temporarily
     * re-enabling magic on sv). */

    if (PL_tainting && (tmg = mg_find(sv, PERL_MAGIC_taint))
	&& (tmg->mg_len & 1))
    {
	val = sv_mortalcopy(sv);
	SvTAINTED_on(val);
    }
    else
	val = sv;

    magic_methcall1(sv, mg, "STORE", G_DISCARD, 2, val);
a1719 1
    if (mg->mg_type == PERL_MAGIC_tiedscalar) return 0;
d1727 1
a1727 1
    dVAR;
a1728 1
    SV* retsv;
d1732 6
a1737 3
    retsv = magic_methcall1(sv, mg, "FETCHSIZE", 0, 1, NULL);
    if (retsv) {
	retval = SvIV(retsv)-1;
d1741 3
d1750 1
a1750 1
    dVAR;
d1754 9
a1762 1
    Perl_magic_methcall(aTHX_ sv, mg, "CLEAR", G_DISCARD, 0);
d1769 2
a1770 2
    dVAR;
    SV* ret;
d1774 16
a1789 4
    ret = SvOK(key) ? Perl_magic_methcall(aTHX_ sv, mg, "NEXTKEY", 0, 1, key)
	: Perl_magic_methcall(aTHX_ sv, mg, "FIRSTKEY", 0, 0);
    if (ret)
	sv_setsv(key,ret);
d1804 1
a1804 1
    dVAR;
d1824 10
a1833 2
    retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(hv), mg, "SCALAR", 0, 0);
    if (!retval)
d1835 2
d1873 1
a1873 1
	sv_setiv(sv, AvFILL(obj));
d1889 1
a1889 1
	av_fill(obj, SvIV(sv));
d1937 1
a1937 1
	    sv_setiv(sv, i);
d1978 1
a1978 1
    pos = SvIV(sv);
a2013 2
    const bool negoff = LvFLAGS(sv) & 1;
    const bool negrem = LvFLAGS(sv) & 2;
a2017 10
    if (!translate_substr_offsets(
	    SvUTF8(lsv) ? sv_len_utf8(lsv) : len,
	    negoff ? -(IV)offs : (IV)offs, !negoff,
	    negrem ? -(IV)rem  : (IV)rem,  !negrem, &offs, &rem
    )) {
	Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR), "substr outside of string");
	sv_setsv_nomg(sv, &PL_sv_undef);
	return 0;
    }

d2020 4
d2034 1
a2034 1
    STRLEN len, lsv_len, oldtarglen, newtarglen;
a2038 2
    const bool negoff = LvFLAGS(sv) & 1;
    const bool neglen = LvFLAGS(sv) & 2;
a2042 14
    SvGETMAGIC(lsv);
    if (SvROK(lsv))
	Perl_ck_warner(aTHX_ packWARN(WARN_SUBSTR),
			    "Attempt to use reference as lvalue in substr"
	);
    if (SvUTF8(lsv)) lsv_len = sv_len_utf8(lsv);
    else (void)SvPV_nomg(lsv,lsv_len);
    if (!translate_substr_offsets(
	    lsv_len,
	    negoff ? -(IV)lvoff : (IV)lvoff, !negoff,
	    neglen ? -(IV)lvlen : (IV)lvlen, !neglen, &lvoff, &lvlen
    ))
	Perl_croak(aTHX_ "substr outside of string");
    oldtarglen = lvlen;
d2046 2
a2047 2
	sv_insert_flags(lsv, lvoff, lvlen, tmps, len, 0);
	newtarglen = sv_len_utf8(sv);
d2053 1
a2053 1
	newtarglen = len;
d2055 1
a2055 1
	sv_insert_flags(lsv, lvoff, lvlen, utf8, len, 0);
d2059 2
a2060 2
	sv_insert_flags(lsv, lvoff, lvlen, tmps, len, 0);
	newtarglen = len;
a2061 2
    if (!neglen) LvTARGLEN(sv) = newtarglen;
    if (negoff)  LvTARGOFF(sv) += newtarglen - oldtarglen;
a2119 13
Perl_magic_setvstring(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_SETVSTRING;

    if (SvPOKp(sv)) {
	SV * const vecsv = sv_newmortal();
	scan_vstring(mg->mg_ptr, mg->mg_ptr + mg->mg_len, vecsv);
	if (sv_eq_flags(vecsv, sv, 0 /*nomg*/)) return 0;
    }
    return sv_unmagic(sv, mg->mg_type);
}

int
d2211 1
a2211 2
    Perl_sv_kill_backrefs(aTHX_ sv, MUTABLE_AV(mg->mg_obj));
    return 0;
a2218 1
    PERL_UNUSED_ARG(sv);
d2220 2
a2247 3
    } else if (type == PERL_MAGIC_study) {
	if (!isGV_with_GP(sv))
	    SvSCREAM_off(sv);
d2250 1
a2298 1
    MAGIC *tmg;
d2324 1
d2330 1
a2330 1
                Perl_croak_no_modify(aTHX);
a2332 1
        break;
a2334 15
	FmLINES(PL_bodytarget) = 0;
	if (SvPOK(PL_bodytarget)) {
	    char *s = SvPVX(PL_bodytarget);
	    while ( ((s = strchr(s, '\n'))) ) {
		FmLINES(PL_bodytarget)++;
		s++;
	    }
	}
	/* mg_set() has temporarily made sv non-magical */
	if (PL_tainting) {
	    if ((tmg = mg_find(sv,PERL_MAGIC_taint)) && tmg->mg_len & 1)
		SvTAINTED_on(PL_bodytarget);
	    else
		SvTAINTED_off(PL_bodytarget);
	}
d2337 1
a2337 1
	PL_minus_c = cBOOL(SvIV(sv));
a2430 1
      break;
d2453 3
a2455 2
		if (!SvPOK(sv)) {
	            PL_compiling.cop_warnings = pWARN_STD;
d2520 1
a2520 1
		IoLINES_LEFT(GvIOp(PL_defoutgv)) = 0L;
d2527 1
a2527 1
	    IO * const io = GvIO(PL_defoutgv);
d2556 1
a2556 2
	if (SvIV(sv) != 0)
	    Perl_croak(aTHX_ "Assigning non-zero to $[ is no longer possible");
d2586 1
a2586 3
	{
	const IV new_uid = SvIV(sv);
	PL_delaymagic_uid = new_uid;
d2592 1
a2592 1
	(void)setruid((Uid_t)new_uid);
d2595 1
a2595 1
	(void)setreuid((Uid_t)new_uid, (Uid_t)-1);
d2598 1
a2598 1
      (void)setresuid((Uid_t)new_uid, (Uid_t)-1, (Uid_t)-1);
d2600 1
a2600 1
	if (new_uid == PerlProc_geteuid()) {		/* special case $< = $> */
d2603 1
a2603 1
	    if (new_uid != 0 && PerlProc_getuid() == 0)
d2606 1
a2606 1
	    (void)PerlProc_setuid(new_uid);
d2608 1
d2614 2
a2616 1
	}
d2618 1
a2618 3
	{
	const UV new_euid = SvIV(sv);
	PL_delaymagic_euid = new_euid;
d2624 1
a2624 1
	(void)seteuid((Uid_t)new_euid);
d2627 1
a2627 1
	(void)setreuid((Uid_t)-1, (Uid_t)new_euid);
d2630 1
a2630 1
	(void)setresuid((Uid_t)-1, (Uid_t)new_euid, (Uid_t)-1);
d2632 2
a2633 2
	if (new_euid == PerlProc_getuid())		/* special case $> = $< */
	    PerlProc_setuid(new_euid);
d2635 1
d2641 2
a2643 1
	}
d2645 1
a2645 3
	{
	const UV new_gid = SvIV(sv);
	PL_delaymagic_gid = new_gid;
d2651 1
a2651 1
	(void)setrgid((Gid_t)new_gid);
d2654 1
a2654 1
	(void)setregid((Gid_t)new_gid, (Gid_t)-1);
d2657 1
a2657 1
      (void)setresgid((Gid_t)new_gid, (Gid_t)-1, (Gid_t) -1);
d2659 2
a2660 2
	if (new_gid == PerlProc_getegid())			/* special case $( = $) */
	    (void)PerlProc_setgid(new_gid);
d2662 1
d2668 2
a2670 1
	}
a2671 2
	{
	UV new_egid;
d2687 1
a2687 1
            new_egid = Atol(p);
d2706 1
a2706 1
	new_egid = SvIV(sv);
a2707 1
	PL_delaymagic_egid = new_egid;
d2713 1
a2713 1
	(void)setegid((Gid_t)new_egid);
d2716 1
a2716 1
	(void)setregid((Gid_t)-1, (Gid_t)new_egid);
d2719 1
a2719 1
	(void)setresgid((Gid_t)-1, (Gid_t)new_egid, (Gid_t)-1);
d2721 2
a2722 2
	if (new_egid == PerlProc_getgid())			/* special case $) = $( */
	    (void)PerlProc_setgid(new_egid);
d2724 1
d2730 2
a2732 1
	}
a2735 11
    case '$': /* $$ */
	/* Store the pid in mg->mg_obj so we can tell when a fork has
	   occurred.  mg->mg_obj points to *$ by default, so clear it. */
	if (isGV(mg->mg_obj)) {
	    if (mg->mg_flags & MGf_REFCOUNTED) /* probably never true */
		SvREFCNT_dec(mg->mg_obj);
	    mg->mg_flags |= MGf_REFCOUNTED;
	    mg->mg_obj = newSViv((IV)PerlProc_getpid());
	}
	else sv_setiv(mg->mg_obj, (IV)PerlProc_getpid());
	break;
a2796 7
#ifdef HAS_PRCTL_SET_NAME
	    /* Set the legacy process name in addition to the POSIX name on Linux */
	    if (prctl(PR_SET_NAME, (unsigned long)s, 0, 0, 0) != 0) {
		/* diag_listed_as: SKIPME */
		Perl_croak(aTHX_ "Can't set $0 with prctl(): %s", Strerror(errno));
	    }
#endif
d2806 1
a2806 20
Perl_whichsig_sv(pTHX_ SV *sigsv)
{
    const char *sigpv;
    STRLEN siglen;
    PERL_ARGS_ASSERT_WHICHSIG_SV;
    PERL_UNUSED_CONTEXT;
    sigpv = SvPV_const(sigsv, siglen);
    return whichsig_pvn(sigpv, siglen);
}

I32
Perl_whichsig_pv(pTHX_ const char *sig)
{
    PERL_ARGS_ASSERT_WHICHSIG_PV;
    PERL_UNUSED_CONTEXT;
    return whichsig_pvn(sig, strlen(sig));
}

I32
Perl_whichsig_pvn(pTHX_ const char *sig, STRLEN len)
d2810 1
a2810 1
    PERL_ARGS_ASSERT_WHICHSIG_PVN;
d2814 1
a2814 1
	if (strlen(*sigv) == len && memEQ(sig,*sigv, len))
d2817 1
a2817 1
    if (memEQs(sig, len, "CHLD"))
d2821 1
a2821 1
    if (memEQs(sig, len, "CLD"))
d2829 1
a2829 1
Perl_sighandler(int sig, siginfo_t *sip, void *uap)
a2846 1
    I32 old_ss_ix = PL_savestack_ix;
d2848 6
d2861 10
a2870 9
    if (PL_signals &  PERL_SIGNALS_UNSAFE_FLAG) {
	/* Max number of items pushed there is 3*n or 4. We cannot fix
	   infinity, so we fix 4 (in fact 5): */
	if (PL_savestack_ix + 15 <= PL_savestack_max) {
	    flags |= 1;
	    PL_savestack_ix += 5;		/* Protect save in progress. */
	    SAVEDESTRUCTOR_X(S_unwind_handler_stack, NULL);
	}
    }
d2887 9
a2895 10
    sv = PL_psig_name[sig]
	    ? SvREFCNT_inc_NN(PL_psig_name[sig])
	    : newSVpv(PL_sig_name[sig],0);
    flags |= 8;
    SAVEFREESV(sv);

    if (PL_signals &  PERL_SIGNALS_UNSAFE_FLAG) {
	/* make sure our assumption about the size of the SAVEs are correct:
	 * 3 for SAVEDESTRUCTOR_X, 2 for SAVEFREESV */
	assert(old_ss_ix + 2 + ((flags & 1) ? 3+5 : 0)  == PL_savestack_ix);
d2936 1
d2941 4
a2944 10
#ifdef HAS_SIGPROCMASK
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
       if (sip || uap)
#endif
	{
	    sigset_t set;
	    sigemptyset(&set);
	    sigaddset(&set,sig);
	    sigprocmask(SIG_UNBLOCK, &set, NULL);
	}
d2951 1
a2951 1
	die_sv(ERRSV);
d2954 7
a2960 3
    /* pop any of SAVEFREESV, SAVEDESTRUCTOR_X and "save in progress" */
    PL_savestack_ix = old_ss_ix;
    if (flags & 8)
a2975 1
    bool bumped;
a3006 1
    bumped = mgs->mgs_bumped;
d3018 1
a3018 1
	UV popval = SSPOPUV;
d3021 4
a3024 20
	popval = SSPOPUV;
        assert((popval & SAVE_MASK) == SAVEt_ALLOC);
        PL_savestack_ix -= popval >> SAVE_TIGHT_SHIFT;
    }
    if (bumped) {
	if (SvREFCNT(sv) == 1) {
	    /* We hold the last reference to this SV, which implies that the
	       SV was deleted as a side effect of the routines we called.
	       So artificially keep it alive a bit longer.
	       We avoid turning on the TEMP flag, which can cause the SV's
	       buffer to get stolen (and maybe other stuff). */
	    int was_temp = SvTEMP(sv);
	    sv_2mortal(sv);
	    if (!was_temp) {
		SvTEMP_off(sv);
	    }
	    SvOK_off(sv);
	}
	else
	    SvREFCNT_dec(sv); /* undo the inc in S_save_magic() */
d3026 1
a3028 5
/* clean up the mess created by Perl_sighandler().
 * Note that this is only called during an exit in a signal handler;
 * a die is trapped by the call_sv() and the SAVEDESTRUCTOR_X manually
 * skipped over. */

d3033 3
a3035 1
    PERL_UNUSED_ARG(p);
d3037 6
a3042 1
    PL_savestack_ix -= 5; /* Unprotect save in progress. */
d3073 2
a3074 2
    CopHINTHASH_set(&PL_compiling,
	cophh_store_sv(CopHINTHASH_get(&PL_compiling), key, 0, sv, 0));
d3099 3
a3101 3
    CopHINTHASH_set(&PL_compiling,
	cophh_delete_sv(CopHINTHASH_get(&PL_compiling),
				 MUTABLE_SV(mg->mg_ptr), 0, 0));
d3118 4
a3121 2
    cophh_free(CopHINTHASH_get(&PL_compiling));
    CopHINTHASH_set(&PL_compiling, cophh_new_empty());
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a78 1
 * Pre-magic setup and post-magic takedown.
a99 2
    assert(SvMAGICAL(sv));

d111 6
d122 1
a122 1
    mgs->mgs_readonly = SvREADONLY(sv) && !SvIsCOW(sv);
d127 5
a131 3
    /* Turning READONLY off for a copy-on-write scalar (including shared
       hash keys) is a bad idea.  */
    if (!SvIsCOW(sv)) SvREADONLY_off(sv);
d170 1
a170 2
Do magic before a value is retrieved from the SV.  The type of SV must
be >= SVt_PVMG. See C<sv_magic>.
a179 1
    bool saved = FALSE;
d187 2
a198 7

	    /* taint's mg get is so dumb it doesn't need flag saving */
	    if (!saved && mg->mg_type != PERL_MAGIC_taint) {
		save_magic(mgs_ix, sv);
		saved = TRUE;
	    }

a211 4
	else if (vtbl == &PL_vtbl_utf8) {
	    /* get-magic can reallocate the PV */
	    magic_setutf8(sv, mg);
	}
d234 1
a234 3
    if (saved)
	restore_magic(INT2PTR(void *, (IV)mgs_ix));

d281 1
a281 7
This function is deprecated.

It reports on the SV's length in bytes, calling length magic if available,
but does not set the UTF8 flag on the sv.  It will fall back to 'get'
magic if there is no 'length' magic, but with no indication as to
whether it called 'get' magic.  It assumes the sv is a PVMG or
higher.  Use sv_len() instead.
d307 9
a315 1
    (void)SvPV_const(sv, len);
d609 1
a609 1
	const REGEXP * const rx = PM_GETRE(PL_curpm);
a629 2
/* @@-, @@+ */

d638 1
a638 1
	const REGEXP * const rx = PM_GETRE(PL_curpm);
d640 3
a642 3
	    const I32 paren = mg->mg_len;
	    I32 s;
	    I32 t;
d649 1
a649 1
		    I32 i;
d658 1
a658 3
			    i = RX_SUBCOFFSET(rx) +
                                    utf8_length((U8*)b,
                                        (U8*)(b-RX_SUBOFFSET(rx)+i));
a667 2
/* @@-, @@+ */

d674 1
a674 1
    Perl_croak_no_modify();
d678 79
a791 5
#ifdef VMS
#include <descrip.h>
#include <starlet.h>
#endif

d796 3
a798 3
    I32 paren;
    const char *s = NULL;
    REGEXP *rx;
d806 1
a806 2
	if (SvOK(PL_bodytarget)) sv_copypv(sv, PL_bodytarget);
	else sv_setsv(sv, &PL_sv_undef);
d826 2
a888 14
    case '\014':		/* ^LAST_FH */
	if (strEQ(remaining, "AST_FH")) {
	    if (PL_last_in_gv) {
		assert(isGV_with_GP(PL_last_in_gv));
		SV_CHECK_THINKFIRST_COW_DROP(sv);
		prepare_SV_for_RV(sv);
		SvOK_off(sv);
		SvRV_set(sv, SvREFCNT_inc_simple_NN(PL_last_in_gv));
		SvROK_on(sv);
		sv_rvweaken(sv);
	    }
	    else sv_setsv_nomg(sv, NULL);
	}
	break;
d902 1
a902 3

            paren = RX_BUFF_IDX_CARET_PREMATCH;
	    goto do_numbuf_fetch;
d904 1
a904 2
            paren = RX_BUFF_IDX_CARET_POSTMATCH;
	    goto do_numbuf_fetch;
d926 2
a927 2
            sv_setiv(sv, TAINTING_get
		    ? (TAINT_WARN_get || PL_unsafe ? -1 : 1)
d952 9
a960 6
		HV * const bits = get_hv("warnings::Bits", 0);
		SV ** const bits_all = bits ? hv_fetchs(bits, "all", FALSE) : NULL;
		if (bits_all)
		    sv_copypv(sv, *bits_all);
	        else
		    sv_setpvn(sv, WARN_ALLstring, WARNsize);
d966 1
a970 4
            paren = RX_BUFF_IDX_CARET_FULLMATCH;
	    goto do_numbuf_fetch;
        }

d973 11
a983 11
        /*
         * Pre-threads, this was paren = atoi(GvENAME((const GV *)mg->mg_obj));
         * XXX Does the new way break anything?
         */
        paren = atoi(mg->mg_ptr); /* $& is in [0] */
      do_numbuf_fetch:
        if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
            CALLREG_NUMBUF_FETCH(rx,paren,sv);
            break;
        }
        sv_setsv(sv,&PL_sv_undef);
d987 4
a990 3
	    paren = RX_LASTPAREN(rx);
	    if (paren)
                goto do_numbuf_fetch;
d996 5
a1000 3
	    paren = RX_LASTCLOSEPAREN(rx);
	    if (paren)
                goto do_numbuf_fetch;
d1005 7
a1011 2
        paren = RX_BUFF_IDX_PREMATCH;
        goto do_numbuf_fetch;
d1013 7
a1019 2
        paren = RX_BUFF_IDX_POSTMATCH;
        goto do_numbuf_fetch;
a1077 2
	else
	    sv_setsv(sv, &PL_sv_undef);
d1106 2
d1162 3
a1164 2
    const char * const key = MgPV_const(mg,klen);
    const char *s = "";
a1167 15
    SvGETMAGIC(sv);
    if (SvOK(sv)) {
        /* defined environment variables are byte strings; unfortunately
           there is no SvPVbyte_force_nomg(), so we must do this piecewise */
        (void)SvPV_force_nomg_nolen(sv);
        sv_utf8_downgrade(sv, /* fail_ok */ TRUE);
        if (SvUTF8(sv)) {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), "Wide character in %s", "setenv");
            SvUTF8_off(sv);
        }
        s = SvPVX(sv);
        len = SvCUR(sv);
    }
    my_setenv(key, s); /* does the deed */

d1172 1
a1172 1
	SV ** const valp = hv_fetch(GvHVn(PL_envgv), key, klen, FALSE);
d1181 1
a1181 1
    if (TAINTING_get) {
d1184 1
a1184 1
	if (s && klen == 8 && strEQ(key, "DCL$PATH")) {
d1210 1
a1210 1
	if (s && klen == 4 && strEQ(key,"PATH")) {
d1497 1
a1497 1
    const char *s = MgPV_const(mg,len);
d1694 12
d1893 1
a1893 1
    if (TAINTING_get && (tmg = mg_find(sv, PERL_MAGIC_taint))
a2010 3
#ifdef PERL_DEBUG_READONLY_OPS
	    Slab_to_rw(OpSLAB(o));
#endif
a2015 3
#ifdef PERL_DEBUG_READONLY_OPS
	    Slab_to_ro(OpSLAB(o));
#endif
a2054 19
Perl_magic_cleararylen_p(pTHX_ SV *sv, MAGIC *mg)
{
    dVAR;

    PERL_ARGS_ASSERT_MAGIC_CLEARARYLEN_P;
    PERL_UNUSED_ARG(sv);

    /* Reset the iterator when the array is cleared */
#if IVSIZE == I32SIZE
    *((IV *) &(mg->mg_len)) = 0;
#else
    if (mg->mg_ptr)
        *((IV *) mg->mg_ptr) = 0;
#endif

    return 0;
}

int
a2110 1
    const char *s;
d2133 1
a2133 1
    s = SvPV_const(lsv, len);
d2138 1
a2138 1
	ulen = sv_or_pv_len_utf8(lsv, s, len);
d2152 3
a2154 1
	pos = sv_or_pv_pos_u2b(lsv, s, pos, 0);
d2178 1
a2178 1
	    SvUTF8(lsv) ? sv_or_pv_len_utf8(lsv, tmps, len) : len,
d2188 1
a2188 1
	offs = sv_or_pv_pos_u2b(lsv, tmps, offs, &rem);
d2215 2
a2216 2
    SvPV_force_nomg(lsv,lsv_len);
    if (SvUTF8(lsv)) lsv_len = sv_len_utf8_nomg(lsv);
d2225 1
a2225 1
	sv_utf8_upgrade_nomg(lsv);
d2228 1
a2228 1
	newtarglen = sv_or_pv_len_utf8(sv, tmps, len);
d2231 1
a2231 1
    else if (SvUTF8(lsv)) {
a2255 3
#ifdef NO_TAINT_SUPPORT
    PERL_UNUSED_ARG(mg);
#endif
d2270 1
a2270 1
    if (TAINT_get)
d2303 13
d2444 3
d2491 3
a2493 3
    const char *s;
    I32 paren;
    const REGEXP * rx;
a2521 1
      setparen_got_rx:
a2526 1
      croakparen:
d2528 1
a2528 1
                Perl_croak_no_modify();
d2533 1
a2533 2
	if (SvOK(sv)) sv_copypv(PL_bodytarget, sv);
	else SvOK_off(PL_bodytarget);
d2543 1
a2543 1
	if (TAINTING_get) {
a2600 4
    case '\016':	/* ^N */
	if (PL_curpm && (rx = PM_GETRE(PL_curpm))
	 && (paren = RX_LASTCLOSEPAREN(rx))) goto setparen_got_rx;
	goto croakparen;
d2762 1
a2762 1
	if (SvOK(sv)) {
d3061 1
a3061 1
    char* const* sigv;
a3100 1
    SV *errsv_save = NULL;
a3178 2
    errsv_save = newSVsv(ERRSV);

d3182 1
a3182 4
    {
	SV * const errsv = ERRSV;
	if (SvTRUE_NN(errsv)) {
	    SvREFCNT_dec(errsv_save);
d3190 1
a3190 1
	    if (sip || uap)
d3192 6
a3197 6
	    {
		sigset_t set;
		sigemptyset(&set);
		sigaddset(&set,sig);
		sigprocmask(SIG_UNBLOCK, &set, NULL);
	    }
d3199 3
a3201 3
	    /* Not clear if this will work */
	    (void)rsignal(sig, SIG_IGN);
	    (void)rsignal(sig, PL_csighandlerp);
d3204 1
a3204 6
	    die_sv(errsv);
	}
	else {
	    sv_setsv(errsv, errsv_save);
	    SvREFCNT_dec(errsv_save);
	}
a3205 1

d3230 2
a3231 2
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv)) {
	SvTEMP_off(sv); /* if it's still magical, this value isn't temporary */
d3238 1
d3245 10
d3283 1
d3285 4
a3288 1
	    SvTEMP_off(sv);
d3358 4
d3364 2
a3365 5
	mg->mg_len == HEf_SVKEY
	 ? cophh_delete_sv(CopHINTHASH_get(&PL_compiling),
				 MUTABLE_SV(mg->mg_ptr), 0, 0)
	 : cophh_delete_pvn(CopHINTHASH_get(&PL_compiling),
				 mg->mg_ptr, mg->mg_len, 0, 0));
a3386 20
int
Perl_magic_copycallchecker(pTHX_ SV *sv, MAGIC *mg, SV *nsv,
				 const char *name, I32 namlen)
{
    MAGIC *nmg;

    PERL_ARGS_ASSERT_MAGIC_COPYCALLCHECKER;
    PERL_UNUSED_ARG(sv);
    PERL_UNUSED_ARG(name);
    PERL_UNUSED_ARG(namlen);

    sv_magic(nsv, &PL_sv_undef, mg->mg_type, NULL, 0);
    nmg = mg_find(nsv, mg->mg_type);
    if (nmg->mg_flags & MGf_REFCOUNTED) SvREFCNT_dec(nmg->mg_obj);
    nmg->mg_ptr = mg->mg_ptr;
    nmg->mg_obj = SvREFCNT_inc_simple(mg->mg_obj);
    nmg->mg_flags |= MGf_REFCOUNTED;
    return 1;
}

d3391 1
a3391 1
 * indent-tabs-mode: nil
d3394 1
a3394 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d24 1
a24 1
with that SV's magic.  A get is called prior to reading an SV, in order to
d26 1
a26 1
number of the last read filehandle into the SV's IV slot), while
d32 1
a32 1
SV.  Each MAGIC struct holds the type of the magic, a pointer to an array
d34 1
a34 1
plus space for some flags and pointers.  For example, a tied variable has
d93 1
a93 1
S_save_magic_flags(pTHX_ I32 mgs_ix, SV *sv, U32 flags)
d99 1
a99 1
    PERL_ARGS_ASSERT_SAVE_MAGIC_FLAGS;
d119 1
a119 1
    mgs->mgs_readonly = SvREADONLY(sv) != 0;
d123 4
a126 2
    SvFLAGS(sv) &= ~flags;
    SvREADONLY_off(sv);
a128 2
#define save_magic(a,b) save_magic_flags(a,b,SVs_GMG|SVs_SMG|SVs_RMG)

d166 1
a166 1
be >= SVt_PVMG.  See C<sv_magic>.
d266 1
a266 1
    save_magic_flags(mgs_ix, sv, SVs_GMG|SVs_SMG); /* leave SVs_RMG on */
d289 3
a291 1
Reports on the SV's length in bytes, calling length magic if available,
a399 2
	assert(!(SvTYPE(sv) == SVt_PVAV && AvPAD_NAMELIST(sv)));

a438 15
MAGIC *
Perl_mg_find_mglob(pTHX_ SV *sv)
{
    PERL_ARGS_ASSERT_MG_FIND_MGLOB;
    if (SvTYPE(sv) == SVt_PVLV && LvTYPE(sv) == 'y') {
        /* This sv is only a delegate.  //g magic must be attached to
           its target. */
        vivify_defelem(sv);
        sv = LvTARG(sv);
    }
    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv))
        return S_mg_findext_flags(aTHX_ sv, PERL_MAGIC_regex_global, 0, 0);
    return NULL;
}

d481 1
a481 2
SV.  Container magic (eg %ENV, $1, tie)
gets copied, value magic doesn't (eg
d514 1
a514 1
	SvFLAGS(nsv) |= SvREADONLY(sv);
d649 2
a650 2
	    SSize_t s;
	    SSize_t t;
d657 1
a657 1
		    SSize_t i;
d663 1
a663 1
		    if (RX_MATCH_UTF8(rx)) {
d671 1
a671 2
		    sv_setuv(sv, i);
		    return 0;
a674 1
    sv_setsv(sv, NULL);
a724 41
STATIC void
S_fixup_errno_string(pTHX_ SV* sv)
{
    /* Do what is necessary to fixup the non-empty string in 'sv' for return to
     * Perl space. */

    PERL_ARGS_ASSERT_FIXUP_ERRNO_STRING;

    assert(SvOK(sv));

    if(strEQ(SvPVX(sv), "")) {
	sv_catpv(sv, UNKNOWN_ERRNO_MSG);
    }
#if 0
    /* This is disabled to get v5.20 out the door.  It means that $! behaves as
     * if in the scope of both 'use locale' and 'use bytes'.  This can cause
     * mixed encodings and double utf8 upgrading,  See towards the end of the
     * thread for [perl #119499] */
    else {

        /* In some locales the error string may come back as UTF-8, in which
         * case we should turn on that flag.  This didn't use to happen, and to
         * avoid any possible backward compatibility issues, we don't turn on
         * the flag unless we have to.  So the flag stays off for an entirely
         * ASCII string.  We assume that if the string looks like UTF-8, it
         * really is UTF-8:  "text in any other encoding that uses bytes with
         * the high bit set is extremely unlikely to pass a UTF-8 validity
         * test" (http://en.wikipedia.org/wiki/Charset_detection).  There is a
         * potential that we will get it wrong however, especially on short
         * error message text.  (If it turns out to be necessary, we could also
         * keep track if the current LC_MESSAGES locale is UTF-8) */
        if (! IN_BYTES  /* respect 'use bytes' */
            && ! is_ascii_string((U8*) SvPVX_const(sv), SvCUR(sv))
            && is_utf8_string((U8*) SvPVX_const(sv), SvCUR(sv)))
        {
            SvUTF8_on(sv);
        }
    }
#endif
}

d738 1
a738 1
    char nextchar;
a741 12
    if (!mg->mg_ptr) {
        paren = mg->mg_len;
        if (PL_curpm && (rx = PM_GETRE(PL_curpm))) {
          do_numbuf_fetch:
            CALLREG_NUMBUF_FETCH(rx,paren,sv);
        } else {
            sv_setsv(sv,&PL_sv_undef);
        }
        return 0;
    }

    nextchar = *remaining;
d762 11
a772 17
	 if (nextchar != '\0') {
            if (strEQ(remaining, "NCODING"))
                sv_setsv(sv, PL_encoding);
            break;
        }

#if defined(VMS) || defined(OS2) || defined(WIN32)
#   if defined(VMS)
        {
            char msg[255];
            $DESCRIPTOR(msgdsc,msg);
            sv_setnv(sv,(NV) vaxc$errno);
            if (sys$getmsg(vaxc$errno,&msgdsc.dsc$w_length,&msgdsc,0,0) & 1)
                sv_setpvn(sv,msgdsc.dsc$a_pointer,msgdsc.dsc$w_length);
            else
                sv_setpvs(sv,"");
        }
d774 30
a803 43
        if (!(_emx_env & 0x200)) {	/* Under DOS */
            sv_setnv(sv, (NV)errno);
            sv_setpv(sv, errno ? Strerror(errno) : "");
        } else {
            if (errno != errno_isOS2) {
                const int tmp = _syserrno();
                if (tmp)	/* 2nd call to _syserrno() makes it 0 */
                    Perl_rc = tmp;
            }
            sv_setnv(sv, (NV)Perl_rc);
            sv_setpv(sv, os2error(Perl_rc));
        }
        if (SvOK(sv) && strNE(SvPVX(sv), "")) {
            fixup_errno_string(sv);
        }
#   elif defined(WIN32)
        {
            const DWORD dwErr = GetLastError();
            sv_setnv(sv, (NV)dwErr);
            if (dwErr) {
                PerlProc_GetOSError(sv, dwErr);
                fixup_errno_string(sv);
            }
            else
                sv_setpvs(sv, "");
            SetLastError(dwErr);
        }
#   else
#   error Missing code for platform
#   endif
        SvRTRIM(sv);
        SvNOK_on(sv);	/* what a wonderful hack! */
	break;
#endif  /* End of platforms with special handling for $^E; others just fall
           through to $! */

    case '!':
	{
            dSAVE_ERRNO;
#ifdef VMS
            sv_setnv(sv, (NV)((errno == EVMSERR) ? vaxc$errno : errno));
#else
            sv_setnv(sv, (NV)errno);
d805 6
a810 25
#ifdef OS2
            if (errno == errno_isOS2 || errno == errno_isOS2_set)
                sv_setpv(sv, os2error(Perl_rc));
            else
#endif
            if (! errno) {
                sv_setpvs(sv, "");
            }
            else {

                /* Strerror can return NULL on some platforms, which will
                 * result in 'sv' not being considered SvOK.  The SvNOK_on()
                 * below will cause just the number part to be valid */
                sv_setpv(sv, Strerror(errno));
                if (SvOK(sv)) {
                    fixup_errno_string(sv);
                }
            }
            RESTORE_ERRNO;
	}

	SvRTRIM(sv);
	SvNOK_on(sv);	/* what a wonderful hack! */
	break;

d850 10
a859 1
        sv_setiv(sv, (IV)PL_perldb);
d862 1
a862 1
        {
d919 20
d955 6
d1034 21
d1056 1
a1056 1
        sv_setuid(sv, PerlProc_getuid());
d1059 1
a1059 1
        sv_setuid(sv, PerlProc_geteuid());
d1062 1
a1062 1
        sv_setgid(sv, PerlProc_getgid());
d1065 1
a1065 1
        sv_setgid(sv, PerlProc_getegid());
d1709 1
a1709 1
Perl_magic_methcall(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags,
d1750 1
a1750 1
	call_sv(meth, G_SCALAR|G_DISCARD|G_METHOD_NAMED);
d1753 1
a1753 1
	if (call_sv(meth, G_SCALAR|G_METHOD_NAMED))
d1763 1
d1767 1
a1767 1
S_magic_methcall1(pTHX_ SV *sv, const MAGIC *mg, SV *meth, U32 flags,
d1793 1
a1793 1
S_magic_methpack(pTHX_ SV *sv, const MAGIC *mg, SV *meth)
d1813 1
a1813 1
    magic_methpack(sv,mg,SV_CONST(FETCH));
d1845 1
a1845 1
    magic_methcall1(sv, mg, SV_CONST(STORE), G_DISCARD, 2, val);
d1855 1
a1855 1
    return magic_methpack(sv,mg,SV_CONST(DELETE));
d1868 1
a1868 1
    retsv = magic_methcall1(sv, mg, SV_CONST(FETCHSIZE), 0, 1, NULL);
d1884 1
a1884 1
    Perl_magic_methcall(aTHX_ sv, mg, SV_CONST(CLEAR), G_DISCARD, 0);
d1896 2
a1897 2
    ret = SvOK(key) ? Perl_magic_methcall(aTHX_ sv, mg, SV_CONST(NEXTKEY), 0, 1, key)
	: Perl_magic_methcall(aTHX_ sv, mg, SV_CONST(FIRSTKEY), 0, 0);
d1908 1
a1908 1
    return magic_methpack(sv,mg,SV_CONST(EXISTS));
d1934 1
a1934 1
    retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(hv), mg, SV_CONST(SCALAR), 0, 0);
d1944 4
a1947 1
    SV **svp;
a1950 11
    /* The magic ptr/len for the debugger's hash should always be an SV.  */
    if (UNLIKELY(mg->mg_len != HEf_SVKEY)) {
        Perl_croak(aTHX_ "panic: magic_setdbline len=%"IVdf", ptr='%s'",
                   (IV)mg->mg_len, mg->mg_ptr);
    }

    /* Use sv_2iv instead of SvIV() as the former generates smaller code, and
       setting/clearing debugger breakpoints is not a hot path.  */
    svp = av_fetch(MUTABLE_AV(mg->mg_obj),
		   sv_2iv(MUTABLE_SV((mg)->mg_ptr)), FALSE);

d1958 1
a1958 1
	    if (SvTRUE(sv))
d1981 1
a1981 1
	sv_setsv(sv, NULL);
a2051 1
    MAGIC * const found = mg_find_mglob(lsv);
d2056 7
a2062 5
    if (found && found->mg_len != -1) {
	    STRLEN i = found->mg_len;
	    if (found->mg_flags & MGf_BYTES && DO_UTF8(lsv))
		i = sv_pos_b2u_flags(lsv, i, SV_GMAGIC|SV_CONST_RETURN);
	    sv_setuv(sv, i);
d2064 1
d2066 1
a2066 1
    sv_setsv(sv,NULL);
d2084 4
a2087 1
    found = mg_find_mglob(lsv);
d2091 6
a2096 1
	found = sv_magicext_mglob(lsv);
d2120 4
d2125 1
a2125 1
    found->mg_flags &= ~(MGf_MINMATCH|MGf_BYTES);
d2255 4
a2258 1
    sv_setuv(sv, do_vecget(lsv, LvTARGOFF(sv), LvTARGLEN(sv)));
d2272 2
a2273 2
SV *
Perl_defelem_target(pTHX_ SV *sv, MAGIC *mg)
d2277 3
a2279 3
    PERL_ARGS_ASSERT_DEFELEM_TARGET;
    if (!mg) mg = mg_find(sv, PERL_MAGIC_defelem);
    assert(mg);
d2287 1
a2287 1
	else if (LvSTARGOFF(sv) >= 0) {
d2289 2
a2290 9
	    if (LvSTARGOFF(sv) <= AvFILL(av))
	    {
	      if (SvRMAGICAL(av)) {
		SV * const * const svp = av_fetch(av, LvSTARGOFF(sv), 0);
		targ = svp ? *svp : NULL;
	      }
	      else
		targ = AvARRAY(av)[LvSTARGOFF(sv)];
	    }
a2300 1
	return targ;
d2303 2
a2304 9
	return LvTARG(sv);
}

int
Perl_magic_getdefelem(pTHX_ SV *sv, MAGIC *mg)
{
    PERL_ARGS_ASSERT_MAGIC_GETDEFELEM;

    sv_setsv(sv, defelem_target(sv, mg));
a2340 2
    else if (LvSTARGOFF(sv) < 0)
	Perl_croak(aTHX_ PL_no_aelem, LvSTARGOFF(sv));
d2343 1
a2343 1
	if ((I32)LvTARGLEN(sv) < 0 && LvSTARGOFF(sv) > AvFILL(av))
d2346 3
a2348 3
	    SV* const * const svp = av_fetch(av, LvSTARGOFF(sv), TRUE);
	    if (!svp || !(value = *svp))
		Perl_croak(aTHX_ PL_no_aelem, LvSTARGOFF(sv));
d2448 1
d2455 20
a2474 2
    if (!mg->mg_ptr) {
        paren = mg->mg_len;
d2476 1
a2476 1
          setparen_got_rx:
d2482 1
a2482 1
          croakparen:
d2487 1
a2487 4
        return 0;
    }

    switch (*mg->mg_ptr) {
d2596 1
d2600 6
d2648 2
a2649 5
		    else if (isWARN_on(
                                ((STRLEN *)SvPV_nolen_const(sv)) - 1,
                                WARN_ALL)
                            && !any_fatals)
                    {
d2718 2
a2719 28
        {
            SV *tmpsv= sv;
            if (SvROK(sv)) {
                SV *referent= SvRV(sv);
                const char *reftype= sv_reftype(referent, 0);
                /* XXX: dodgy type check: This leaves me feeling dirty, but the alternative
                 * is to copy pretty much the entire sv_reftype() into this routine, or to do
                 * a full string comparison on the return of sv_reftype() both of which
                 * make me feel worse! NOTE, do not modify this comment without reviewing the
                 * corresponding comment in sv_reftype(). - Yves */
                if (reftype[0] == 'S' || reftype[0] == 'L') {
                    IV val= SvIV(referent);
                    if (val <= 0) {
                        tmpsv= &PL_sv_undef;
                        Perl_ck_warner(aTHX_ packWARN(WARN_DEPRECATED),
                            "Setting $/ to a reference to %s as a form of slurp is deprecated, treating as undef",
                            SvIV(SvRV(sv)) < 0 ? "a negative integer" : "zero"
                        );
                    }
                } else {
              /* diag_listed_as: Setting $/ to %s reference is forbidden */
                    Perl_croak(aTHX_ "Setting $/ to a%s %s reference is forbidden",
                                      *reftype == 'A' ? "n" : "", reftype);
                }
            }
            SvREFCNT_dec(PL_rs);
            PL_rs = newSVsv(tmpsv);
        }
a2756 4
#if defined(WIN32) && ! defined(UNDER_CE)
	SETERRNO(win32_get_errno(SvIOK(sv) ? SvIVX(sv) : SvOK(sv) ? sv_2iv(sv) : 0),
		 (SvIV(sv) == EVMSERR) ? 4 : PERL_VMS_BANG);
#else
a2758 1
#endif
d2763 1
a2763 2
        /* XXX $< currently silently ignores failures */
	const Uid_t new_uid = SvUID(sv);
d2770 1
a2770 1
	PERL_UNUSED_RESULT(setruid(new_uid));
d2773 1
a2773 1
        PERL_UNUSED_RESULT(setreuid(new_uid, (Uid_t)-1));
d2776 1
a2776 1
        PERL_UNUSED_RESULT(setresuid(new_uid, (Uid_t)-1, (Uid_t)-1));
d2782 1
a2782 1
                PERL_UNUSED_RESULT(PerlProc_setuid(0));
d2784 1
a2784 1
            PERL_UNUSED_RESULT(PerlProc_setuid(new_uid));
d2795 1
a2795 2
        /* XXX $> currently silently ignores failures */
	const Uid_t new_euid = SvUID(sv);
d2802 1
a2802 1
	PERL_UNUSED_RESULT(seteuid(new_euid));
d2805 1
a2805 1
	PERL_UNUSED_RESULT(setreuid((Uid_t)-1, new_euid));
d2808 1
a2808 1
	PERL_UNUSED_RESULT(setresuid((Uid_t)-1, new_euid, (Uid_t)-1));
d2811 1
a2811 1
	    PERL_UNUSED_RESULT(PerlProc_setuid(new_euid));
d2822 1
a2822 2
        /* XXX $( currently silently ignores failures */
	const Gid_t new_gid = SvGID(sv);
d2829 1
a2829 1
	PERL_UNUSED_RESULT(setrgid(new_gid));
d2832 1
a2832 1
	PERL_UNUSED_RESULT(setregid(new_gid, (Gid_t)-1));
d2835 1
a2835 1
        PERL_UNUSED_RESULT(setresgid(new_gid, (Gid_t)-1, (Gid_t) -1));
d2838 1
a2838 1
	    PERL_UNUSED_RESULT(PerlProc_setgid(new_gid));
d2849 1
a2849 2
        /* XXX $) currently silently ignores failures */
	Gid_t new_egid;
d2865 1
a2865 1
            new_egid = (Gid_t)Atol(p);
d2877 1
a2877 1
                gary[i] = (Groups_t)Atol(p);
d2880 1
a2880 1
                PERL_UNUSED_RESULT(setgroups(i, gary));
d2884 1
a2884 1
        new_egid = SvGID(sv);
d2892 1
a2892 1
	PERL_UNUSED_RESULT(setegid(new_egid));
d2895 1
a2895 1
	PERL_UNUSED_RESULT(setregid((Gid_t)-1, new_egid));
d2898 1
a2898 1
	PERL_UNUSED_RESULT(setresgid((Gid_t)-1, new_egid, (Gid_t)-1));
d2901 1
a2901 1
	    PERL_UNUSED_RESULT(PerlProc_setgid(new_egid));
d3183 1
a3183 1
	SvREFCNT_dec_NN(sv);
d3249 1
a3249 1
	    SvREFCNT_dec_NN(sv); /* undo the inc in S_save_magic() */
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@d2273 1
a2273 1
    TAINT_IF((PL_localizing != 1) && (mg->mg_len & 1) && IN_PERL_RUNTIME);
@


1.1.1.18
log
@Import perl-5.24.2
@
text
@d20 1
a37 2
=cut

d86 2
a87 1
    U32 mgs_flags;
d95 1
d118 2
a119 1
    mgs->mgs_flags = SvMAGICAL(sv) | SvREADONLY(sv);
d132 1
a132 1
Turns on the magical status of an SV.  See C<L</sv_magic>>.
d138 1
a138 1
Perl_mg_magical(SV *sv)
d142 1
d166 1
a166 1
be >= C<SVt_PVMG>.  See C<L</sv_magic>>.
d174 1
d206 1
a206 2
		/* recalculate flags */
		(SSPTR(mgs_ix, MGS *))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);
d212 1
a212 2
		(SSPTR(mgs_ix, MGS *))->mgs_flags &=
		     ~(SVs_GMG|SVs_SMG|SVs_RMG);
d236 1
a236 2
	    /* recalculate flags */
	    (SSPTR(mgs_ix, MGS *))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);
d249 1
a249 1
Do magic after a value is assigned to the SV.  See C<L</sv_magic>>.
d257 1
d273 1
a273 1
	    (SSPTR(mgs_ix, MGS*))->mgs_flags &= ~(SVs_GMG|SVs_SMG|SVs_RMG);
d290 1
a290 1
but does not set the UTF8 flag on C<sv>.  It will fall back to 'get'
d292 2
a293 2
whether it called 'get' magic.  It assumes C<sv> is a C<PVMG> or
higher.  Use C<sv_len()> instead.
d301 1
d350 1
a350 1

d352 1
a352 1
    NOT_REACHED; /* NOTREACHED */
d358 1
a358 1
Clear something magical that the SV represents.  See C<L</sv_magic>>.
d389 1
a389 1
S_mg_findext_flags(const SV *sv, int type, const MGVTBL *vtbl, U32 flags)
d391 2
d398 2
d413 1
a413 1
Finds the magic pointer for C<type> matching the SV.  See C<L</sv_magic>>.
d419 1
a419 1
Perl_mg_find(const SV *sv, int type)
d421 1
a421 1
    return S_mg_findext_flags(sv, type, NULL, 0);
d428 1
a428 1
C<L</sv_magicext>>.
d434 1
a434 1
Perl_mg_findext(const SV *sv, int type, const MGVTBL *vtbl)
d436 1
a436 1
    return S_mg_findext_flags(sv, type, vtbl, 1);
d450 1
a450 1
        return S_mg_findext_flags(sv, PERL_MAGIC_regex_global, 0, 0);
d457 1
a457 1
Copies the magic from one SV to another.  See C<L</sv_magic>>.
d496 3
a498 3
SV.  Container magic (I<e.g.>, C<%ENV>, C<$1>, C<tie>)
gets copied, value magic doesn't (I<e.g.>,
C<taint>, C<pos>).
d500 2
a501 2
If C<setmagic> is false then no set magic will be called on the new (empty) SV.
This typically means that assignment will soon follow (e.g. S<C<'local $x = $y'>>),
d510 1
d564 1
a564 1
Free any magic storage used by the SV.  See C<L</sv_magic>>.
d590 1
a590 1
Remove any magic of type C<how> from the SV C<sv>.  See L</sv_magic>.
d625 1
d657 2
a701 1
    PERL_UNUSED_CONTEXT;
d756 5
d765 6
a770 7
         * avoid as many possible backward compatibility issues as possible, we
         * don't turn on the flag unless we have to.  So the flag stays off for
         * an entirely invariant string.  We assume that if the string looks
         * like UTF-8, it really is UTF-8:  "text in any other encoding that
         * uses bytes with the high bit set is extremely unlikely to pass a
         * UTF-8 validity test"
         * (http://en.wikipedia.org/wiki/Charset_detection).  There is a
d775 1
a775 1
            && ! is_invariant_string((U8*) SvPVX_const(sv), SvCUR(sv))
d781 1
a781 40
}

SV*
Perl__get_encoding(pTHX)
{
    /* For core Perl use only: Returns the $^ENCODING or 'use encoding' in
     * effect; NULL if none.
     *
     * $^ENCODING maps to PL_encoding, and is the old way to do things, and is
     * retained for backwards compatibility.  Now, there is a shadow variable
     * ${^E_NCODING} set only by the encoding pragma, used to give this pragma
     * lexical scope, unlike the global scope it (shudder) used to have.  This
     * variable maps to PL_lex_encoding.  Again for backwards compatibility,
     * PL_encoding has precedence over PL_lex_encoding.  The hints hash is used
     * to determine if PL_lex_encoding is in scope, and hence valid.  The hints
     * hash only accepts simple values, so we can't put an Encode object into
     * it, so we put the object into the global, and put a simple boolean into
     * the hints hash giving whether the global is valid or not */

    dVAR;
    SV *is_encoding;

    if (PL_encoding) {
        return PL_encoding;
    }

    if (! PL_lex_encoding) {
        return NULL;
    }

    is_encoding = cop_hints_fetch_pvs(PL_curcop, "encoding", 0);
    if (   is_encoding
        && is_encoding != &PL_sv_placeholder
        && SvIOK(is_encoding)
        && SvIV(is_encoding))  /* non-zero mean valid */
    {
        return PL_lex_encoding;
    }

    return NULL;
d792 1
d835 1
a835 3
                sv_setsv(sv, _get_encoding());
            else if (strEQ(remaining, "_NCODING"))
                sv_setsv(sv, NULL);
d853 1
a853 1
            sv_setpv(sv, errno ? my_strerror(errno) : "");
d908 1
a908 1
                sv_setpv(sv, my_strerror(errno));
a1017 5
#ifdef WIN32
	else if (strEQ(remaining, "IN32_SLOPPY_STAT")) {
	    sv_setiv(sv, w32_sloppystat);
	}
#endif
d1080 1
d1123 6
a1128 9
	    I32 i;
            I32 num_groups = getgroups(0, gary);
            if (num_groups > 0) {
                Newx(gary, num_groups, Groups_t);
                num_groups = getgroups(num_groups, gary);
                for (i = 0; i < num_groups; i++)
                    Perl_sv_catpvf(aTHX_ sv, " %"IVdf, (IV)gary[i]);
                Safefree(gary);
            }
d1154 1
d1186 1
a1186 1
#if !defined(OS2) && !defined(WIN32) && !defined(MSDOS)
d1230 1
a1230 1
		s = delimcpy_no_escape(tmpbuf, tmpbuf + sizeof tmpbuf,
d1246 1
a1246 1
#endif /* neither OS2 nor WIN32 nor MSDOS */
d1263 1
d1286 1
d1310 1
a1366 8
#if defined(HAS_SIGACTION) && defined(SA_SIGINFO)
#if defined(__cplusplus) && defined(__GNUC__)
    /* g++ doesn't support PERL_UNUSED_DECL, so the sip and uap
     * parameters would be warned about. */
    PERL_UNUSED_ARG(sip);
    PERL_UNUSED_ARG(uap);
#endif
#endif
a1437 1
    PERL_UNUSED_CONTEXT;
d1445 1
d1647 1
d1662 1
d1664 1
a1677 1
    assert(mg);
d1755 1
a1755 1
Returns the SV (if any) returned by the method, or C<NULL> on failure.
d1765 1
d1784 1
a1784 3
    /* EXTEND() expects a signed argc; don't wrap when casting */
    assert(argc <= I32_MAX);
    EXTEND(SP, (I32)argc+1);
d1822 1
d1847 1
d1872 1
d1914 1
d1932 2
d1943 1
d1966 1
d1995 1
d2033 1
d2049 1
d2066 2
a2069 1
    PERL_UNUSED_CONTEXT;
d2085 2
d2110 1
d2131 1
d2211 1
d2265 2
d2280 2
d2318 1
d2383 1
d2502 1
a2502 59
Perl_magic_setlvref(pTHX_ SV *sv, MAGIC *mg)
{
    const char *bad = NULL;
    PERL_ARGS_ASSERT_MAGIC_SETLVREF;
    if (!SvROK(sv)) Perl_croak(aTHX_ "Assigned value is not a reference");
    switch (mg->mg_private & OPpLVREF_TYPE) {
    case OPpLVREF_SV:
	if (SvTYPE(SvRV(sv)) > SVt_PVLV)
	    bad = " SCALAR";
	break;
    case OPpLVREF_AV:
	if (SvTYPE(SvRV(sv)) != SVt_PVAV)
	    bad = "n ARRAY";
	break;
    case OPpLVREF_HV:
	if (SvTYPE(SvRV(sv)) != SVt_PVHV)
	    bad = " HASH";
	break;
    case OPpLVREF_CV:
	if (SvTYPE(SvRV(sv)) != SVt_PVCV)
	    bad = " CODE";
    }
    if (bad)
	/* diag_listed_as: Assigned value is not %s reference */
	Perl_croak(aTHX_ "Assigned value is not a%s reference", bad);
    switch (mg->mg_obj ? SvTYPE(mg->mg_obj) : 0) {
    case 0:
    {
	SV * const old = PAD_SV(mg->mg_len);
	PAD_SETSV(mg->mg_len, SvREFCNT_inc_NN(SvRV(sv)));
	SvREFCNT_dec(old);
	break;
    }
    case SVt_PVGV:
	gv_setref(mg->mg_obj, sv);
	SvSETMAGIC(mg->mg_obj);
	break;
    case SVt_PVAV:
	av_store((AV *)mg->mg_obj, SvIV((SV *)mg->mg_ptr),
		 SvREFCNT_inc_simple_NN(SvRV(sv)));
	break;
    case SVt_PVHV:
	(void)hv_store_ent((HV *)mg->mg_obj, (SV *)mg->mg_ptr,
                           SvREFCNT_inc_simple_NN(SvRV(sv)), 0);
    }
    if (mg->mg_flags & MGf_PERSIST)
	NOOP; /* This sv is in use as an iterator var and will be reused,
		 so we must leave the magic.  */
    else
	/* This sv could be returned by the assignment op, so clear the
	   magic, as lvrefs are an implementation detail that must not be
	   leaked to the user.  */
	sv_unmagic(sv, PERL_MAGIC_lvref);
    return 0;
}

static void
S_set_dollarzero(pTHX_ SV *sv)
    PERL_TSA_REQUIRES(PL_dollarzero_mutex)
a2503 1
#ifdef USE_ITHREADS
a2504 1
#endif
a2505 78
    STRLEN len;
#ifdef HAS_SETPROCTITLE
    /* The BSDs don't show the argv[] in ps(1) output, they
     * show a string from the process struct and provide
     * the setproctitle() routine to manipulate that. */
    if (PL_origalen != 1) {
        s = SvPV_const(sv, len);
#   if __FreeBSD_version > 410001
        /* The leading "-" removes the "perl: " prefix,
         * but not the "(perl) suffix from the ps(1)
         * output, because that's what ps(1) shows if the
         * argv[] is modified. */
        setproctitle("-%s", s);
#   else	/* old FreeBSDs, NetBSD, OpenBSD, anyBSD */
        /* This doesn't really work if you assume that
         * $0 = 'foobar'; will wipe out 'perl' from the $0
         * because in ps(1) output the result will be like
         * sprintf("perl: %s (perl)", s)
         * I guess this is a security feature:
         * one (a user process) cannot get rid of the original name.
         * --jhi */
        setproctitle("%s", s);
#   endif
    }
#elif defined(__hpux) && defined(PSTAT_SETCMD)
    if (PL_origalen != 1) {
        union pstun un;
        s = SvPV_const(sv, len);
        un.pst_command = (char *)s;
        pstat(PSTAT_SETCMD, un, len, 0, 0);
    }
#else
    if (PL_origalen > 1) {
        I32 i;
        /* PL_origalen is set in perl_parse(). */
        s = SvPV_force(sv,len);
        if (len >= (STRLEN)PL_origalen-1) {
            /* Longer than original, will be truncated. We assume that
             * PL_origalen bytes are available. */
            Copy(s, PL_origargv[0], PL_origalen-1, char);
        }
        else {
            /* Shorter than original, will be padded. */
#ifdef PERL_DARWIN
            /* Special case for Mac OS X: see [perl #38868] */
            const int pad = 0;
#else
            /* Is the space counterintuitive?  Yes.
             * (You were expecting \0?)
             * Does it work?  Seems to.  (In Linux 2.4.20 at least.)
             * --jhi */
            const int pad = ' ';
#endif
            Copy(s, PL_origargv[0], len, char);
            PL_origargv[0][len] = 0;
            memset(PL_origargv[0] + len + 1,
                   pad,  PL_origalen - len - 1);
        }
        PL_origargv[0][PL_origalen-1] = 0;
        for (i = 1; i < PL_origargc; i++)
            PL_origargv[i] = 0;
#ifdef HAS_PRCTL_SET_NAME
        /* Set the legacy process name in addition to the POSIX name on Linux */
        if (prctl(PR_SET_NAME, (unsigned long)s, 0, 0, 0) != 0) {
            /* diag_listed_as: SKIPME */
            Perl_croak(aTHX_ "Can't set $0 with prctl(): %s", Strerror(errno));
        }
#endif
    }
#endif
}

int
Perl_magic_set(pTHX_ SV *sv, MAGIC *mg)
{
#ifdef USE_ITHREADS
    dVAR;
#endif
d2557 4
a2560 6
        {
            const char *s = SvPV_nolen_const(sv);
            PL_debug = get_debug_opts(&s, 0) | DEBUG_TOP_FLAG;
            if (DEBUG_x_TEST || DEBUG_B_TEST)
                dump_all_perl(!DEBUG_B_TEST);
        }
d2582 9
a2590 37
	else {
            unsigned int offset = 1;
            bool lex = FALSE;

            /* It may be the shadow variable ${E_NCODING} which has lexical
             * scope.  See comments at Perl__get_encoding in this file */
            if (*(mg->mg_ptr + 1) == '_') {
                if (CopSTASH(PL_curcop) != get_hv("encoding::",0))
                    Perl_croak_no_modify();
                lex = TRUE;
                offset++;
            }
            if (strEQ(mg->mg_ptr + offset, "NCODING")) {
                if (lex) {  /* Use the shadow global */
                    SvREFCNT_dec(PL_lex_encoding);
                    if (SvOK(sv) || SvGMAGICAL(sv)) {
                        PL_lex_encoding = newSVsv(sv);
                    }
                    else {
                        PL_lex_encoding = NULL;
                    }
                }
                else { /* Use the regular global */
                    SvREFCNT_dec(PL_encoding);
                    if (SvOK(sv) || SvGMAGICAL(sv)) {
                        if (PL_localizing != 2) {
                            Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
                                          "Setting ${^ENCODING} is deprecated");
                        }
                        PL_encoding = newSVsv(sv);
                    }
                    else {
                        PL_encoding = NULL;
                    }
                }
            }
        }
a2709 5
#ifdef WIN32
	else if (strEQ(mg->mg_ptr+1, "IN32_SLOPPY_STAT")) {
	    w32_sloppystat = (bool)sv_true(sv);
	}
#endif
d2721 1
a2721 1
	IoTOP_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
d2726 1
a2726 1
	IoFMT_NAME(GvIOp(PL_defoutgv)) = savesvpv(sv);
d2772 1
a2772 1
                        Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
a2777 1
                    sv_setsv(sv, PL_rs);
a2922 6
/* (hv) best guess: maybe we'll need configure probes to do a better job,
 * but you can override it if you need to.
 */
#ifndef INVALID_GID
#define INVALID_GID ((Gid_t)-1)
#endif
a2928 2
            const char* endptr;
            UV uv;
d2940 1
a2940 6
            if (grok_atoUV(p, &uv, &endptr))
                new_egid = (Gid_t)uv;
            else {
                new_egid = INVALID_GID;
                endptr = NULL;
            }
d2942 2
a2943 3
                if (endptr == NULL)
                    break;
                p = endptr;
d2948 1
a2948 1
                if (!gary)
d2952 1
a2952 6
                if (grok_atoUV(p, &uv, &endptr))
                    gary[i] = (Groups_t)uv;
                else {
                    gary[i] = INVALID_GID;
                    endptr = NULL;
                }
d3001 68
a3068 1
        S_set_dollarzero(aTHX_ sv);
d3081 1
d3090 1
d3163 5
a3167 13
	const HEK * const hek = gv
			? GvENAME_HEK(gv)
			: cv && CvNAMED(cv)
			   ? CvNAME_HEK(cv)
			   : cv && CvGV(cv) ? GvENAME_HEK(CvGV(cv)) : NULL;
	if (hek)
	    Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
				"SIG%s handler \"%"HEKf"\" not defined.\n",
			         PL_sig_name[sig], HEKfARG(hek));
	     /* diag_listed_as: SIG%s handler "%s" not defined */
	else Perl_ck_warner(aTHX_ packWARN(WARN_SIGNAL),
			   "SIG%s handler \"__ANON__\" not defined.\n",
			    PL_sig_name[sig]);
d3198 7
a3204 21
#ifdef HAS_SIGINFO_SI_ERRNO
		   (void)hv_stores(sih, "errno",      newSViv(sip->si_errno));
#endif
#ifdef HAS_SIGINFO_SI_STATUS
		   (void)hv_stores(sih, "status",     newSViv(sip->si_status));
#endif
#ifdef HAS_SIGINFO_SI_UID
		   {
			SV *uid = newSV(0);
			sv_setuid(uid, sip->si_uid);
			(void)hv_stores(sih, "uid", uid);
		   }
#endif
#ifdef HAS_SIGINFO_SI_PID
		   (void)hv_stores(sih, "pid",        newSViv(sip->si_pid));
#endif
#ifdef HAS_SIGINFO_SI_ADDR
		   (void)hv_stores(sih, "addr",       newSVuv(PTR2UV(sip->si_addr)));
#endif
#ifdef HAS_SIGINFO_SI_BAND
		   (void)hv_stores(sih, "band",       newSViv(sip->si_band));
d3254 1
a3254 1
  cleanup:
d3270 1
d3280 10
a3289 2
	if (mgs->mgs_flags)
	    SvFLAGS(sv) |= mgs->mgs_flags;
d3336 1
d3345 1
a3345 1
Triggered by a store to C<%^H>, records the key/value pair to
d3355 1
d3378 1
a3378 1
Triggered by a delete from C<%^H>, records the key to
d3386 2
d3404 1
a3404 1
Triggered by clearing C<%^H>, resets C<PL_compiling.cop_hints_hash>.
a3431 1
    assert(nmg);
a3438 27
int
Perl_magic_setdebugvar(pTHX_ SV *sv, MAGIC *mg) {
    PERL_ARGS_ASSERT_MAGIC_SETDEBUGVAR;

#if DBVARMG_SINGLE != 0
    assert(mg->mg_private >= DBVARMG_SINGLE);
#endif
    assert(mg->mg_private < DBVARMG_COUNT);

    PL_DBcontrol[mg->mg_private] = SvIV_nomg(sv);

    return 1;
}

int
Perl_magic_getdebugvar(pTHX_ SV *sv, MAGIC *mg) {
    PERL_ARGS_ASSERT_MAGIC_GETDEBUGVAR;

#if DBVARMG_SINGLE != 0
    assert(mg->mg_private >= DBVARMG_SINGLE);
#endif
    assert(mg->mg_private < DBVARMG_COUNT);
    sv_setiv(sv, PL_DBcontrol[mg->mg_private]);

    return 0;
}

d3440 6
@


