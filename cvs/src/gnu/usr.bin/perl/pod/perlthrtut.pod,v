head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.3.0.2
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2015.04.25.19.14.48;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	XRK22kO4se3v2i2I;

1.12
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.47;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.17;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.11;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.15.21.30.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.09.18.10.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.03.03.02.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.26.18.32.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.04.29.22.41.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.31;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.24.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.06;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.24;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.22;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.18.02;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.24;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.53;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.12;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.26;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.08;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.15;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2015.04.25.19.10.45;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@=encoding utf8

=head1 NAME

perlthrtut - Tutorial on threads in Perl

=head1 DESCRIPTION

This tutorial describes the use of Perl interpreter threads (sometimes
referred to as I<ithreads>).  In this
model, each thread runs in its own Perl interpreter, and any data sharing
between threads must be explicit.  The user-level interface for I<ithreads>
uses the L<threads> class.

B<NOTE>: There was another older Perl threading flavor called the 5.005 model
that used the L<threads> class.  This old model was known to have problems, is
deprecated, and was removed for release 5.10.  You are
strongly encouraged to migrate any existing 5.005 threads code to the new
model as soon as possible.

You can see which (or neither) threading flavour you have by
running C<perl -V> and looking at the C<Platform> section.
If you have C<useithreads=define> you have ithreads, if you
have C<use5005threads=define> you have 5.005 threads.
If you have neither, you don't have any thread support built in.
If you have both, you are in trouble.

The L<threads> and L<threads::shared> modules are included in the core Perl
distribution.  Additionally, they are maintained as a separate modules on
CPAN, so you can check there for any updates.

=head1 What Is A Thread Anyway?

A thread is a flow of control through a program with a single
execution point.

Sounds an awful lot like a process, doesn't it? Well, it should.
Threads are one of the pieces of a process.  Every process has at least
one thread and, up until now, every process running Perl had only one
thread.  With 5.8, though, you can create extra threads.  We're going
to show you how, when, and why.

=head1 Threaded Program Models

There are three basic ways that you can structure a threaded
program.  Which model you choose depends on what you need your program
to do.  For many non-trivial threaded programs, you'll need to choose
different models for different pieces of your program.

=head2 Boss/Worker

The boss/worker model usually has one I<boss> thread and one or more
I<worker> threads.  The boss thread gathers or generates tasks that need
to be done, then parcels those tasks out to the appropriate worker
thread.

This model is common in GUI and server programs, where a main thread
waits for some event and then passes that event to the appropriate
worker threads for processing.  Once the event has been passed on, the
boss thread goes back to waiting for another event.

The boss thread does relatively little work.  While tasks aren't
necessarily performed faster than with any other method, it tends to
have the best user-response times.

=head2 Work Crew

In the work crew model, several threads are created that do
essentially the same thing to different pieces of data.  It closely
mirrors classical parallel processing and vector processors, where a
large array of processors do the exact same thing to many pieces of
data.

This model is particularly useful if the system running the program
will distribute multiple threads across different processors.  It can
also be useful in ray tracing or rendering engines, where the
individual threads can pass on interim results to give the user visual
feedback.

=head2 Pipeline

The pipeline model divides up a task into a series of steps, and
passes the results of one step on to the thread processing the
next.  Each thread does one thing to each piece of data and passes the
results to the next thread in line.

This model makes the most sense if you have multiple processors so two
or more threads will be executing in parallel, though it can often
make sense in other contexts as well.  It tends to keep the individual
tasks small and simple, as well as allowing some parts of the pipeline
to block (on I/O or system calls, for example) while other parts keep
going.  If you're running different parts of the pipeline on different
processors you may also take advantage of the caches on each
processor.

This model is also handy for a form of recursive programming where,
rather than having a subroutine call itself, it instead creates
another thread.  Prime and Fibonacci generators both map well to this
form of the pipeline model. (A version of a prime number generator is
presented later on.)

=head1 What kind of threads are Perl threads?

If you have experience with other thread implementations, you might
find that things aren't quite what you expect.  It's very important to
remember when dealing with Perl threads that I<Perl Threads Are Not X
Threads> for all values of X.  They aren't POSIX threads, or
DecThreads, or Java's Green threads, or Win32 threads.  There are
similarities, and the broad concepts are the same, but if you start
looking for implementation details you're going to be either
disappointed or confused.  Possibly both.

This is not to say that Perl threads are completely different from
everything that's ever come before. They're not.  Perl's threading
model owes a lot to other thread models, especially POSIX.  Just as
Perl is not C, though, Perl threads are not POSIX threads.  So if you
find yourself looking for mutexes, or thread priorities, it's time to
step back a bit and think about what you want to do and how Perl can
do it.

However, it is important to remember that Perl threads cannot magically
do things unless your operating system's threads allow it. So if your
system blocks the entire process on C<sleep()>, Perl usually will, as well.

B<Perl Threads Are Different.>

=head1 Thread-Safe Modules

The addition of threads has changed Perl's internals
substantially. There are implications for people who write
modules with XS code or external libraries. However, since Perl data is
not shared among threads by default, Perl modules stand a high chance of
being thread-safe or can be made thread-safe easily.  Modules that are not
tagged as thread-safe should be tested or code reviewed before being used
in production code.

Not all modules that you might use are thread-safe, and you should
always assume a module is unsafe unless the documentation says
otherwise.  This includes modules that are distributed as part of the
core.  Threads are a relatively new feature, and even some of the standard
modules aren't thread-safe.

Even if a module is thread-safe, it doesn't mean that the module is optimized
to work well with threads. A module could possibly be rewritten to utilize
the new features in threaded Perl to increase performance in a threaded
environment.

If you're using a module that's not thread-safe for some reason, you
can protect yourself by using it from one, and only one thread at all.
If you need multiple threads to access such a module, you can use semaphores and
lots of programming discipline to control access to it.  Semaphores
are covered in L</"Basic semaphores">.

See also L</"Thread-Safety of System Libraries">.

=head1 Thread Basics

The L<threads> module provides the basic functions you need to write
threaded programs.  In the following sections, we'll cover the basics,
showing you what you need to do to create a threaded program.   After
that, we'll go over some of the features of the L<threads> module that
make threaded programming easier.

=head2 Basic Thread Support

Thread support is a Perl compile-time option. It's something that's
turned on or off when Perl is built at your site, rather than when
your programs are compiled. If your Perl wasn't compiled with thread
support enabled, then any attempt to use threads will fail.

Your programs can use the Config module to check whether threads are
enabled. If your program can't run without them, you can say something
like:

    use Config;
    $Config{useithreads} or
        die('Recompile Perl with threads to run this program.');

A possibly-threaded program using a possibly-threaded module might
have code like this:

    use Config;
    use MyMod;

    BEGIN {
        if ($Config{useithreads}) {
            # We have threads
            require MyMod_threaded;
            import MyMod_threaded;
        } else {
            require MyMod_unthreaded;
            import MyMod_unthreaded;
        }
    }

Since code that runs both with and without threads is usually pretty
messy, it's best to isolate the thread-specific code in its own
module.  In our example above, that's what C<MyMod_threaded> is, and it's
only imported if we're running on a threaded Perl.

=head2 A Note about the Examples

In a real situation, care should be taken that all threads are finished
executing before the program exits.  That care has B<not> been taken in these
examples in the interest of simplicity.  Running these examples I<as is> will
produce error messages, usually caused by the fact that there are still
threads running when the program exits.  You should not be alarmed by this.

=head2 Creating Threads

The L<threads> module provides the tools you need to create new
threads.  Like any other module, you need to tell Perl that you want to use
it; C<use threads;> imports all the pieces you need to create basic
threads.

The simplest, most straightforward way to create a thread is with C<create()>:

    use threads;

    my $thr = threads->create(\&sub1);

    sub sub1 {
        print("In the thread\n");
    }

The C<create()> method takes a reference to a subroutine and creates a new
thread that starts executing in the referenced subroutine.  Control
then passes both to the subroutine and the caller.

If you need to, your program can pass parameters to the subroutine as
part of the thread startup.  Just include the list of parameters as
part of the C<threads-E<gt>create()> call, like this:

    use threads;

    my $Param3 = 'foo';
    my $thr1 = threads->create(\&sub1, 'Param 1', 'Param 2', $Param3);
    my @@ParamList = (42, 'Hello', 3.14);
    my $thr2 = threads->create(\&sub1, @@ParamList);
    my $thr3 = threads->create(\&sub1, qw(Param1 Param2 Param3));

    sub sub1 {
        my @@InboundParameters = @@_;
        print("In the thread\n");
        print('Got parameters >', join('<>',@@InboundParameters), "<\n");
    }

The last example illustrates another feature of threads.  You can spawn
off several threads using the same subroutine.  Each thread executes
the same subroutine, but in a separate thread with a separate
environment and potentially separate arguments.

C<new()> is a synonym for C<create()>.

=head2 Waiting For A Thread To Exit

Since threads are also subroutines, they can return values.  To wait
for a thread to exit and extract any values it might return, you can
use the C<join()> method:

    use threads;

    my ($thr) = threads->create(\&sub1);

    my @@ReturnData = $thr->join();
    print('Thread returned ', join(', ', @@ReturnData), "\n");

    sub sub1 { return ('Fifty-six', 'foo', 2); }

In the example above, the C<join()> method returns as soon as the thread
ends.  In addition to waiting for a thread to finish and gathering up
any values that the thread might have returned, C<join()> also performs
any OS cleanup necessary for the thread.  That cleanup might be
important, especially for long-running programs that spawn lots of
threads.  If you don't want the return values and don't want to wait
for the thread to finish, you should call the C<detach()> method
instead, as described next.

NOTE: In the example above, the thread returns a list, thus necessitating
that the thread creation call be made in list context (i.e., C<my ($thr)>).
See L<< threads/"$thr->join()" >> and L<threads/"THREAD CONTEXT"> for more
details on thread context and return values.

=head2 Ignoring A Thread

C<join()> does three things: it waits for a thread to exit, cleans up
after it, and returns any data the thread may have produced.  But what
if you're not interested in the thread's return values, and you don't
really care when the thread finishes? All you want is for the thread
to get cleaned up after when it's done.

In this case, you use the C<detach()> method.  Once a thread is detached,
it'll run until it's finished; then Perl will clean up after it
automatically.

    use threads;

    my $thr = threads->create(\&sub1);   # Spawn the thread

    $thr->detach();   # Now we officially don't care any more

    sleep(15);        # Let thread run for awhile

    sub sub1 {
        my $count = 0;
        while (1) {
            $count++;
            print("\$count is $count\n");
            sleep(1);
        }
    }

Once a thread is detached, it may not be joined, and any return data
that it might have produced (if it was done and waiting for a join) is
lost.

C<detach()> can also be called as a class method to allow a thread to
detach itself:

    use threads;

    my $thr = threads->create(\&sub1);

    sub sub1 {
        threads->detach();
        # Do more work
    }

=head2 Process and Thread Termination

With threads one must be careful to make sure they all have a chance to
run to completion, assuming that is what you want.

An action that terminates a process will terminate I<all> running
threads.  die() and exit() have this property,
and perl does an exit when the main thread exits,
perhaps implicitly by falling off the end of your code,
even if that's not what you want.

As an example of this case, this code prints the message
"Perl exited with active threads: 2 running and unjoined":

    use threads;
    my $thr1 = threads->new(\&thrsub, "test1");
    my $thr2 = threads->new(\&thrsub, "test2");
    sub thrsub {
       my ($message) = @@_;
       sleep 1;
       print "thread $message\n";
    }

But when the following lines are added at the end:

    $thr1->join();
    $thr2->join();

it prints two lines of output, a perhaps more useful outcome.

=head1 Threads And Data

Now that we've covered the basics of threads, it's time for our next
topic: Data.  Threading introduces a couple of complications to data
access that non-threaded programs never need to worry about.

=head2 Shared And Unshared Data

The biggest difference between Perl I<ithreads> and the old 5.005 style
threading, or for that matter, to most other threading systems out there,
is that by default, no data is shared. When a new Perl thread is created,
all the data associated with the current thread is copied to the new
thread, and is subsequently private to that new thread!
This is similar in feel to what happens when a Unix process forks,
except that in this case, the data is just copied to a different part of
memory within the same process rather than a real fork taking place.

To make use of threading, however, one usually wants the threads to share
at least some data between themselves. This is done with the
L<threads::shared> module and the C<:shared> attribute:

    use threads;
    use threads::shared;

    my $foo :shared = 1;
    my $bar = 1;
    threads->create(sub { $foo++; $bar++; })->join();

    print("$foo\n");  # Prints 2 since $foo is shared
    print("$bar\n");  # Prints 1 since $bar is not shared

In the case of a shared array, all the array's elements are shared, and for
a shared hash, all the keys and values are shared. This places
restrictions on what may be assigned to shared array and hash elements: only
simple values or references to shared variables are allowed - this is
so that a private variable can't accidentally become shared. A bad
assignment will cause the thread to die. For example:

    use threads;
    use threads::shared;

    my $var          = 1;
    my $svar :shared = 2;
    my %hash :shared;

    ... create some threads ...

    $hash{a} = 1;       # All threads see exists($hash{a})
                        # and $hash{a} == 1
    $hash{a} = $var;    # okay - copy-by-value: same effect as previous
    $hash{a} = $svar;   # okay - copy-by-value: same effect as previous
    $hash{a} = \$svar;  # okay - a reference to a shared variable
    $hash{a} = \$var;   # This will die
    delete($hash{a});   # okay - all threads will see !exists($hash{a})

Note that a shared variable guarantees that if two or more threads try to
modify it at the same time, the internal state of the variable will not
become corrupted. However, there are no guarantees beyond this, as
explained in the next section.

=head2 Thread Pitfalls: Races

While threads bring a new set of useful tools, they also bring a
number of pitfalls.  One pitfall is the race condition:

    use threads;
    use threads::shared;

    my $x :shared = 1;
    my $thr1 = threads->create(\&sub1);
    my $thr2 = threads->create(\&sub2);

    $thr1->join();
    $thr2->join();
    print("$x\n");

    sub sub1 { my $foo = $x; $x = $foo + 1; }
    sub sub2 { my $bar = $x; $x = $bar + 1; }

What do you think C<$x> will be? The answer, unfortunately, is I<it
depends>. Both C<sub1()> and C<sub2()> access the global variable C<$x>, once
to read and once to write.  Depending on factors ranging from your
thread implementation's scheduling algorithm to the phase of the moon,
C<$x> can be 2 or 3.

Race conditions are caused by unsynchronized access to shared
data.  Without explicit synchronization, there's no way to be sure that
nothing has happened to the shared data between the time you access it
and the time you update it.  Even this simple code fragment has the
possibility of error:

    use threads;
    my $x :shared = 2;
    my $y :shared;
    my $z :shared;
    my $thr1 = threads->create(sub { $y = $x; $x = $y + 1; });
    my $thr2 = threads->create(sub { $z = $x; $x = $z + 1; });
    $thr1->join();
    $thr2->join();

Two threads both access C<$x>.  Each thread can potentially be interrupted
at any point, or be executed in any order.  At the end, C<$x> could be 3
or 4, and both C<$y> and C<$z> could be 2 or 3.

Even C<$x += 5> or C<$x++> are not guaranteed to be atomic.

Whenever your program accesses data or resources that can be accessed
by other threads, you must take steps to coordinate access or risk
data inconsistency and race conditions. Note that Perl will protect its
internals from your race conditions, but it won't protect you from you.

=head1 Synchronization and control

Perl provides a number of mechanisms to coordinate the interactions
between themselves and their data, to avoid race conditions and the like.
Some of these are designed to resemble the common techniques used in thread
libraries such as C<pthreads>; others are Perl-specific. Often, the
standard techniques are clumsy and difficult to get right (such as
condition waits). Where possible, it is usually easier to use Perlish
techniques such as queues, which remove some of the hard work involved.

=head2 Controlling access: lock()

The C<lock()> function takes a shared variable and puts a lock on it.
No other thread may lock the variable until the variable is unlocked
by the thread holding the lock. Unlocking happens automatically
when the locking thread exits the block that contains the call to the
C<lock()> function.  Using C<lock()> is straightforward: This example has
several threads doing some calculations in parallel, and occasionally
updating a running total:

    use threads;
    use threads::shared;

    my $total :shared = 0;

    sub calc {
        while (1) {
            my $result;
            # (... do some calculations and set $result ...)
            {
                lock($total);  # Block until we obtain the lock
                $total += $result;
            } # Lock implicitly released at end of scope
            last if $result == 0;
        }
    }

    my $thr1 = threads->create(\&calc);
    my $thr2 = threads->create(\&calc);
    my $thr3 = threads->create(\&calc);
    $thr1->join();
    $thr2->join();
    $thr3->join();
    print("total=$total\n");

C<lock()> blocks the thread until the variable being locked is
available.  When C<lock()> returns, your thread can be sure that no other
thread can lock that variable until the block containing the
lock exits.

It's important to note that locks don't prevent access to the variable
in question, only lock attempts.  This is in keeping with Perl's
longstanding tradition of courteous programming, and the advisory file
locking that C<flock()> gives you.

You may lock arrays and hashes as well as scalars.  Locking an array,
though, will not block subsequent locks on array elements, just lock
attempts on the array itself.

Locks are recursive, which means it's okay for a thread to
lock a variable more than once.  The lock will last until the outermost
C<lock()> on the variable goes out of scope. For example:

    my $x :shared;
    doit();

    sub doit {
        {
            {
                lock($x); # Wait for lock
                lock($x); # NOOP - we already have the lock
                {
                    lock($x); # NOOP
                    {
                        lock($x); # NOOP
                        lockit_some_more();
                    }
                }
            } # *** Implicit unlock here ***
        }
    }

    sub lockit_some_more {
        lock($x); # NOOP
    } # Nothing happens here

Note that there is no C<unlock()> function - the only way to unlock a
variable is to allow it to go out of scope.

A lock can either be used to guard the data contained within the variable
being locked, or it can be used to guard something else, like a section
of code. In this latter case, the variable in question does not hold any
useful data, and exists only for the purpose of being locked. In this
respect, the variable behaves like the mutexes and basic semaphores of
traditional thread libraries.

=head2 A Thread Pitfall: Deadlocks

Locks are a handy tool to synchronize access to data, and using them
properly is the key to safe shared data.  Unfortunately, locks aren't
without their dangers, especially when multiple locks are involved.
Consider the following code:

    use threads;

    my $x :shared = 4;
    my $y :shared = 'foo';
    my $thr1 = threads->create(sub {
        lock($x);
        sleep(20);
        lock($y);
    });
    my $thr2 = threads->create(sub {
        lock($y);
        sleep(20);
        lock($x);
    });

This program will probably hang until you kill it.  The only way it
won't hang is if one of the two threads acquires both locks
first.  A guaranteed-to-hang version is more complicated, but the
principle is the same.

The first thread will grab a lock on C<$x>, then, after a pause during which
the second thread has probably had time to do some work, try to grab a
lock on C<$y>.  Meanwhile, the second thread grabs a lock on C<$y>, then later
tries to grab a lock on C<$x>.  The second lock attempt for both threads will
block, each waiting for the other to release its lock.

This condition is called a deadlock, and it occurs whenever two or
more threads are trying to get locks on resources that the others
own.  Each thread will block, waiting for the other to release a lock
on a resource.  That never happens, though, since the thread with the
resource is itself waiting for a lock to be released.

There are a number of ways to handle this sort of problem.  The best
way is to always have all threads acquire locks in the exact same
order.  If, for example, you lock variables C<$x>, C<$y>, and C<$z>, always lock
C<$x> before C<$y>, and C<$y> before C<$z>.  It's also best to hold on to locks for
as short a period of time to minimize the risks of deadlock.

The other synchronization primitives described below can suffer from
similar problems.

=head2 Queues: Passing Data Around

A queue is a special thread-safe object that lets you put data in one
end and take it out the other without having to worry about
synchronization issues.  They're pretty straightforward, and look like
this:

    use threads;
    use Thread::Queue;

    my $DataQueue = Thread::Queue->new();
    my $thr = threads->create(sub {
        while (my $DataElement = $DataQueue->dequeue()) {
            print("Popped $DataElement off the queue\n");
        }
    });

    $DataQueue->enqueue(12);
    $DataQueue->enqueue("A", "B", "C");
    sleep(10);
    $DataQueue->enqueue(undef);
    $thr->join();

You create the queue with C<Thread::Queue-E<gt>new()>.  Then you can
add lists of scalars onto the end with C<enqueue()>, and pop scalars off
the front of it with C<dequeue()>.  A queue has no fixed size, and can grow
as needed to hold everything pushed on to it.

If a queue is empty, C<dequeue()> blocks until another thread enqueues
something.  This makes queues ideal for event loops and other
communications between threads.

=head2 Semaphores: Synchronizing Data Access

Semaphores are a kind of generic locking mechanism. In their most basic
form, they behave very much like lockable scalars, except that they
can't hold data, and that they must be explicitly unlocked. In their
advanced form, they act like a kind of counter, and can allow multiple
threads to have the I<lock> at any one time.

=head2 Basic semaphores

Semaphores have two methods, C<down()> and C<up()>: C<down()> decrements the resource
count, while C<up()> increments it. Calls to C<down()> will block if the
semaphore's current count would decrement below zero.  This program
gives a quick demonstration:

    use threads;
    use Thread::Semaphore;

    my $semaphore = Thread::Semaphore->new();
    my $GlobalVariable :shared = 0;

    $thr1 = threads->create(\&sample_sub, 1);
    $thr2 = threads->create(\&sample_sub, 2);
    $thr3 = threads->create(\&sample_sub, 3);

    sub sample_sub {
        my $SubNumber = shift(@@_);
        my $TryCount = 10;
        my $LocalCopy;
        sleep(1);
        while ($TryCount--) {
            $semaphore->down();
            $LocalCopy = $GlobalVariable;
            print("$TryCount tries left for sub $SubNumber "
                 ."(\$GlobalVariable is $GlobalVariable)\n");
            sleep(2);
            $LocalCopy++;
            $GlobalVariable = $LocalCopy;
            $semaphore->up();
        }
    }

    $thr1->join();
    $thr2->join();
    $thr3->join();

The three invocations of the subroutine all operate in sync.  The
semaphore, though, makes sure that only one thread is accessing the
global variable at once.

=head2 Advanced Semaphores

By default, semaphores behave like locks, letting only one thread
C<down()> them at a time.  However, there are other uses for semaphores.

Each semaphore has a counter attached to it. By default, semaphores are
created with the counter set to one, C<down()> decrements the counter by
one, and C<up()> increments by one. However, we can override any or all
of these defaults simply by passing in different values:

    use threads;
    use Thread::Semaphore;

    my $semaphore = Thread::Semaphore->new(5);
                    # Creates a semaphore with the counter set to five

    my $thr1 = threads->create(\&sub1);
    my $thr2 = threads->create(\&sub1);

    sub sub1 {
        $semaphore->down(5); # Decrements the counter by five
        # Do stuff here
        $semaphore->up(5); # Increment the counter by five
    }

    $thr1->detach();
    $thr2->detach();

If C<down()> attempts to decrement the counter below zero, it blocks until
the counter is large enough.  Note that while a semaphore can be created
with a starting count of zero, any C<up()> or C<down()> always changes the
counter by at least one, and so C<< $semaphore->down(0) >> is the same as
C<< $semaphore->down(1) >>.

The question, of course, is why would you do something like this? Why
create a semaphore with a starting count that's not one, or why
decrement or increment it by more than one? The answer is resource
availability.  Many resources that you want to manage access for can be
safely used by more than one thread at once.

For example, let's take a GUI driven program.  It has a semaphore that
it uses to synchronize access to the display, so only one thread is
ever drawing at once.  Handy, but of course you don't want any thread
to start drawing until things are properly set up.  In this case, you
can create a semaphore with a counter set to zero, and up it when
things are ready for drawing.

Semaphores with counters greater than one are also useful for
establishing quotas.  Say, for example, that you have a number of
threads that can do I/O at once.  You don't want all the threads
reading or writing at once though, since that can potentially swamp
your I/O channels, or deplete your process's quota of filehandles.  You
can use a semaphore initialized to the number of concurrent I/O
requests (or open files) that you want at any one time, and have your
threads quietly block and unblock themselves.

Larger increments or decrements are handy in those cases where a
thread needs to check out or return a number of resources at once.

=head2 Waiting for a Condition

The functions C<cond_wait()> and C<cond_signal()>
can be used in conjunction with locks to notify
co-operating threads that a resource has become available. They are
very similar in use to the functions found in C<pthreads>. However
for most purposes, queues are simpler to use and more intuitive. See
L<threads::shared> for more details.

=head2 Giving up control

There are times when you may find it useful to have a thread
explicitly give up the CPU to another thread.  You may be doing something
processor-intensive and want to make sure that the user-interface thread
gets called frequently.  Regardless, there are times that you might want
a thread to give up the processor.

Perl's threading package provides the C<yield()> function that does
this. C<yield()> is pretty straightforward, and works like this:

    use threads;

    sub loop {
        my $thread = shift;
        my $foo = 50;
        while($foo--) { print("In thread $thread\n"); }
        threads->yield();
        $foo = 50;
        while($foo--) { print("In thread $thread\n"); }
    }

    my $thr1 = threads->create(\&loop, 'first');
    my $thr2 = threads->create(\&loop, 'second');
    my $thr3 = threads->create(\&loop, 'third');

It is important to remember that C<yield()> is only a hint to give up the CPU,
it depends on your hardware, OS and threading libraries what actually happens.
B<On many operating systems, yield() is a no-op.>  Therefore it is important
to note that one should not build the scheduling of the threads around
C<yield()> calls. It might work on your platform but it won't work on another
platform.

=head1 General Thread Utility Routines

We've covered the workhorse parts of Perl's threading package, and
with these tools you should be well on your way to writing threaded
code and packages.  There are a few useful little pieces that didn't
really fit in anyplace else.

=head2 What Thread Am I In?

The C<threads-E<gt>self()> class method provides your program with a way to
get an object representing the thread it's currently in.  You can use this
object in the same way as the ones returned from thread creation.

=head2 Thread IDs

C<tid()> is a thread object method that returns the thread ID of the
thread the object represents.  Thread IDs are integers, with the main
thread in a program being 0.  Currently Perl assigns a unique TID to
every thread ever created in your program, assigning the first thread
to be created a TID of 1, and increasing the TID by 1 for each new
thread that's created.  When used as a class method, C<threads-E<gt>tid()>
can be used by a thread to get its own TID.

=head2 Are These Threads The Same?

The C<equal()> method takes two thread objects and returns true
if the objects represent the same thread, and false if they don't.

Thread objects also have an overloaded C<==> comparison so that you can do
comparison on them as you would with normal objects.

=head2 What Threads Are Running?

C<threads-E<gt>list()> returns a list of thread objects, one for each thread
that's currently running and not detached.  Handy for a number of things,
including cleaning up at the end of your program (from the main Perl thread,
of course):

    # Loop through all the threads
    foreach my $thr (threads->list()) {
        $thr->join();
    }

If some threads have not finished running when the main Perl thread
ends, Perl will warn you about it and die, since it is impossible for Perl
to clean up itself while other threads are running.

NOTE:  The main Perl thread (thread 0) is in a I<detached> state, and so
does not appear in the list returned by C<threads-E<gt>list()>.

=head1 A Complete Example

Confused yet? It's time for an example program to show some of the
things we've covered.  This program finds prime numbers using threads.

   1 #!/usr/bin/perl
   2 # prime-pthread, courtesy of Tom Christiansen
   3
   4 use strict;
   5 use warnings;
   6
   7 use threads;
   8 use Thread::Queue;
   9
  10 sub check_num {
  11     my ($upstream, $cur_prime) = @@_;
  12     my $kid;
  13     my $downstream = Thread::Queue->new();
  14     while (my $num = $upstream->dequeue()) {
  15         next unless ($num % $cur_prime);
  16         if ($kid) {
  17             $downstream->enqueue($num);
  18         } else {
  19             print("Found prime: $num\n");
  20             $kid = threads->create(\&check_num, $downstream, $num);
  21             if (! $kid) {
  22                 warn("Sorry.  Ran out of threads.\n");
  23                 last;
  24             }
  25         }
  26     }
  27     if ($kid) {
  28         $downstream->enqueue(undef);
  29         $kid->join();
  30     }
  31 }
  32
  33 my $stream = Thread::Queue->new(3..1000, undef);
  34 check_num($stream, 2);

This program uses the pipeline model to generate prime numbers.  Each
thread in the pipeline has an input queue that feeds numbers to be
checked, a prime number that it's responsible for, and an output queue
into which it funnels numbers that have failed the check.  If the thread
has a number that's failed its check and there's no child thread, then
the thread must have found a new prime number.  In that case, a new
child thread is created for that prime and stuck on the end of the
pipeline.

This probably sounds a bit more confusing than it really is, so let's
go through this program piece by piece and see what it does.  (For
those of you who might be trying to remember exactly what a prime
number is, it's a number that's only evenly divisible by itself and 1.)

The bulk of the work is done by the C<check_num()> subroutine, which
takes a reference to its input queue and a prime number that it's
responsible for.  After pulling in the input queue and the prime that
the subroutine is checking (line 11), we create a new queue (line 13)
and reserve a scalar for the thread that we're likely to create later
(line 12).

The while loop from line 14 to line 26 grabs a scalar off the input
queue and checks against the prime this thread is responsible
for.  Line 15 checks to see if there's a remainder when we divide the
number to be checked by our prime.  If there is one, the number
must not be evenly divisible by our prime, so we need to either pass
it on to the next thread if we've created one (line 17) or create a
new thread if we haven't.

The new thread creation is line 20.  We pass on to it a reference to
the queue we've created, and the prime number we've found.  In lines 21
through 24, we check to make sure that our new thread got created, and
if not, we stop checking any remaining numbers in the queue.

Finally, once the loop terminates (because we got a 0 or C<undef> in the
queue, which serves as a note to terminate), we pass on the notice to our
child, and wait for it to exit if we've created a child (lines 27 and
30).

Meanwhile, back in the main thread, we first create a queue (line 33) and
queue up all the numbers from 3 to 1000 for checking, plus a termination
notice.  Then all we have to do to get the ball rolling is pass the queue
and the first prime to the C<check_num()> subroutine (line 34).

That's how it works.  It's pretty simple; as with many Perl programs,
the explanation is much longer than the program.

=head1 Different implementations of threads

Some background on thread implementations from the operating system
viewpoint.  There are three basic categories of threads: user-mode threads,
kernel threads, and multiprocessor kernel threads.

User-mode threads are threads that live entirely within a program and
its libraries.  In this model, the OS knows nothing about threads.  As
far as it's concerned, your process is just a process.

This is the easiest way to implement threads, and the way most OSes
start.  The big disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all do.  Typical blocking activities
include most system calls, most I/O, and things like C<sleep()>.

Kernel threads are the next step in thread evolution.  The OS knows
about kernel threads, and makes allowances for them.  The main
difference between a kernel thread and a user-mode thread is
blocking.  With kernel threads, things that block a single thread don't
block other threads.  This is not the case with user-mode threads,
where the kernel blocks at the process level and not the thread level.

This is a big step forward, and can give a threaded program quite a
performance boost over non-threaded programs.  Threads that block
performing I/O, for example, won't block threads that are doing other
things.  Each process still has only one thread running at once,
though, regardless of how many CPUs a system might have.

Since kernel threading can interrupt a thread at any time, they will
uncover some of the implicit locking assumptions you may make in your
program.  For example, something as simple as C<$x = $x + 2> can behave
unpredictably with kernel threads if C<$x> is visible to other
threads, as another thread may have changed C<$x> between the time it
was fetched on the right hand side and the time the new value is
stored.

Multiprocessor kernel threads are the final step in thread
support.  With multiprocessor kernel threads on a machine with multiple
CPUs, the OS may schedule two or more threads to run simultaneously on
different CPUs.

This can give a serious performance boost to your threaded program,
since more than one thread will be executing at the same time.  As a
tradeoff, though, any of those nagging synchronization issues that
might not have shown with basic kernel threads will appear with a
vengeance.

In addition to the different levels of OS involvement in threads,
different OSes (and different thread implementations for a particular
OS) allocate CPU cycles to threads in different ways.

Cooperative multitasking systems have running threads give up control
if one of two things happen.  If a thread calls a yield function, it
gives up control.  It also gives up control if the thread does
something that would cause it to block, such as perform I/O.  In a
cooperative multitasking implementation, one thread can starve all the
others for CPU time if it so chooses.

Preemptive multitasking systems interrupt threads at regular intervals
while the system decides which thread should run next.  In a preemptive
multitasking system, one thread usually won't monopolize the CPU.

On some systems, there can be cooperative and preemptive threads
running simultaneously. (Threads running with realtime priorities
often behave cooperatively, for example, while threads running at
normal priorities behave preemptively.)

Most modern operating systems support preemptive multitasking nowadays.

=head1 Performance considerations

The main thing to bear in mind when comparing Perl's I<ithreads> to other threading
models is the fact that for each new thread created, a complete copy of
all the variables and data of the parent thread has to be taken. Thus,
thread creation can be quite expensive, both in terms of memory usage and
time spent in creation. The ideal way to reduce these costs is to have a
relatively short number of long-lived threads, all created fairly early
on (before the base thread has accumulated too much data). Of course, this
may not always be possible, so compromises have to be made. However, after
a thread has been created, its performance and extra memory usage should
be little different than ordinary code.

Also note that under the current implementation, shared variables
use a little more memory and are a little slower than ordinary variables.

=head1 Process-scope Changes

Note that while threads themselves are separate execution threads and
Perl data is thread-private unless explicitly shared, the threads can
affect process-scope state, affecting all the threads.

The most common example of this is changing the current working
directory using C<chdir()>.  One thread calls C<chdir()>, and the working
directory of all the threads changes.

Even more drastic example of a process-scope change is C<chroot()>:
the root directory of all the threads changes, and no thread can
undo it (as opposed to C<chdir()>).

Further examples of process-scope changes include C<umask()> and
changing uids and gids.

Thinking of mixing C<fork()> and threads?  Please lie down and wait
until the feeling passes.  Be aware that the semantics of C<fork()> vary
between platforms.  For example, some Unix systems copy all the current
threads into the child process, while others only copy the thread that
called C<fork()>. You have been warned!

Similarly, mixing signals and threads may be problematic.
Implementations are platform-dependent, and even the POSIX
semantics may not be what you expect (and Perl doesn't even
give you the full POSIX API).  For example, there is no way to
guarantee that a signal sent to a multi-threaded Perl application
will get intercepted by any particular thread.  (However, a recently
added feature does provide the capability to send signals between
threads.  See L<threads/THREAD SIGNALLING> for more details.)

=head1 Thread-Safety of System Libraries

Whether various library calls are thread-safe is outside the control
of Perl.  Calls often suffering from not being thread-safe include:
C<localtime()>, C<gmtime()>,  functions fetching user, group and
network information (such as C<getgrent()>, C<gethostent()>,
C<getnetent()> and so on), C<readdir()>, C<rand()>, and C<srand()>. In
general, calls that depend on some global external state.

If the system Perl is compiled in has thread-safe variants of such
calls, they will be used.  Beyond that, Perl is at the mercy of
the thread-safety or -unsafety of the calls.  Please consult your
C library call documentation.

On some platforms the thread-safe library interfaces may fail if the
result buffer is too small (for example the user group databases may
be rather large, and the reentrant interfaces may have to carry around
a full snapshot of those databases).  Perl will start with a small
buffer, but keep retrying and growing the result buffer
until the result fits.  If this limitless growing sounds bad for
security or memory consumption reasons you can recompile Perl with
C<PERL_REENTRANT_MAXSIZE> defined to the maximum number of bytes you will
allow.

=head1 Conclusion

A complete thread tutorial could fill a book (and has, many times),
but with what we've covered in this introduction, you should be well
on your way to becoming a threaded Perl expert.

=head1 SEE ALSO

Annotated POD for L<threads>:
L<http://annocpan.org/?mode=search&field=Module&name=threads>

Latest version of L<threads> on CPAN:
L<http://search.cpan.org/search?module=threads>

Annotated POD for L<threads::shared>:
L<http://annocpan.org/?mode=search&field=Module&name=threads%3A%3Ashared>

Latest version of L<threads::shared> on CPAN:
L<http://search.cpan.org/search?module=threads%3A%3Ashared>

Perl threads mailing list:
L<http://lists.perl.org/list/ithreads.html>

=head1 Bibliography

Here's a short bibliography courtesy of JÃ¼rgen Christoffel:

=head2 Introductory Texts

Birrell, Andrew D. An Introduction to Programming with
Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report
#35 online as
ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf
(highly recommended)

Robbins, Kay. A., and Steven Robbins. Practical Unix Programming: A
Guide to Concurrency, Communication, and
Multithreading. Prentice-Hall, 1996.

Lewis, Bill, and Daniel J. Berg. Multithreaded Programming with
Pthreads. Prentice Hall, 1997, ISBN 0-13-443698-9 (a well-written
introduction to threads).

Nelson, Greg (editor). Systems Programming with Modula-3.  Prentice
Hall, 1991, ISBN 0-13-590464-1.

Nichols, Bradford, Dick Buttlar, and Jacqueline Proulx Farrell.
Pthreads Programming. O'Reilly & Associates, 1996, ISBN 156592-115-1
(covers POSIX threads).

=head2 OS-Related References

Boykin, Joseph, David Kirschen, Alan Langerman, and Susan
LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN
0-201-52739-1.

Tanenbaum, Andrew S. Distributed Operating Systems. Prentice Hall,
1995, ISBN 0-13-219908-4 (great textbook).

Silberschatz, Abraham, and Peter B. Galvin. Operating System Concepts,
4th ed. Addison-Wesley, 1995, ISBN 0-201-59292-4

=head2 Other References

Arnold, Ken and James Gosling. The Java Programming Language, 2nd
ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.

comp.programming.threads FAQ,
L<http://www.serpentine.com/~bos/threads-faq/>

Le Sergent, T. and B. Berthomieu. "Incremental MultiThreaded Garbage
Collection on Virtually Shared Memory Architectures" in Memory
Management: Proc. of the International Workshop IWMM 92, St. Malo,
France, September 1992, Yves Bekkers and Jacques Cohen, eds. Springer,
1992, ISBN 3540-55940-X (real-life thread applications).

Artur Bergman, "Where Wizards Fear To Tread", June 11, 2002,
L<http://www.perl.com/pub/a/2002/06/11/threads.html>

=head1 Acknowledgements

Thanks (in no particular order) to Chaim Frenkel, Steve Fink, Gurusamy
Sarathy, Ilya Zakharevich, Benjamin Sugars, JÃ¼rgen Christoffel, Joshua
Pritikin, and Alan Burlison, for their help in reality-checking and
polishing this article.  Big thanks to Tom Christiansen for his rewrite
of the prime number generator.

=head1 AUTHOR

Dan Sugalski E<lt>dan@@sidhe.org<gt>

Slightly modified by Arthur Bergman to fit the new thread model/module.

Reworked slightly by JÃ¶rg Walter E<lt>jwalt@@cpan.org<gt> to be more concise
about thread-safety of Perl code.

Rearranged slightly by Elizabeth Mattijsen E<lt>liz@@dijkmat.nl<gt> to put
less emphasis on yield().

=head1 Copyrights

The original version of this article originally appeared in The Perl
Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy
of Jon Orwant and The Perl Journal.  This document may be distributed
under the same terms as Perl itself.

=cut
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d305 1
a305 1
        $a = 0;
d307 2
a308 2
            $a++;
            print("\$a is $a\n");
d427 1
a427 1
    my $a :shared = 1;
d433 1
a433 1
    print("$a\n");
d435 2
a436 2
    sub sub1 { my $foo = $a; $a = $foo + 1; }
    sub sub2 { my $bar = $a; $a = $bar + 1; }
d438 2
a439 2
What do you think C<$a> will be? The answer, unfortunately, is I<it
depends>. Both C<sub1()> and C<sub2()> access the global variable C<$a>, once
d442 1
a442 1
C<$a> can be 2 or 3.
d451 5
a455 5
    my $a :shared = 2;
    my $b :shared;
    my $c :shared;
    my $thr1 = threads->create(sub { $b = $a; $a = $b + 1; });
    my $thr2 = threads->create(sub { $c = $a; $a = $c + 1; });
d459 3
a461 3
Two threads both access C<$a>.  Each thread can potentially be interrupted
at any point, or be executed in any order.  At the end, C<$a> could be 3
or 4, and both C<$b> and C<$c> could be 2 or 3.
d463 1
a463 1
Even C<$a += 5> or C<$a++> are not guaranteed to be atomic.
d575 2
a576 2
    my $a :shared = 4;
    my $b :shared = 'foo';
d578 1
a578 1
        lock($a);
d580 1
a580 1
        lock($b);
d583 1
a583 1
        lock($b);
d585 1
a585 1
        lock($a);
d593 1
a593 1
The first thread will grab a lock on C<$a>, then, after a pause during which
d595 2
a596 2
lock on C<$b>.  Meanwhile, the second thread grabs a lock on C<$b>, then later
tries to grab a lock on C<$a>.  The second lock attempt for both threads will
d607 2
a608 2
order.  If, for example, you lock variables C<$a>, C<$b>, and C<$c>, always lock
C<$a> before C<$b>, and C<$b> before C<$c>.  It's also best to hold on to locks for
d964 3
a966 3
program.  For example, something as simple as C<$a = $a + 2> can behave
unpredictably with kernel threads if C<$a> is visible to other
threads, as another thread may have changed C<$a> between the time it
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d176 2
a177 1
    $Config{useithreads} or die('Recompile Perl with threads to run this program.');
d245 1
a245 1
        print('Got parameters >', join('<>', @@InboundParameters), "<\n");
d406 2
a407 1
    $hash{a} = 1;       # All threads see exists($hash{a}) and $hash{a} == 1
d679 2
a680 1
            print("$TryCount tries left for sub $SubNumber (\$GlobalVariable is $GlobalVariable)\n");
d852 34
a885 34
     1 #!/usr/bin/perl
     2 # prime-pthread, courtesy of Tom Christiansen
     3
     4 use strict;
     5 use warnings;
     6
     7 use threads;
     8 use Thread::Queue;
     9
    10 sub check_num {
    11     my ($upstream, $cur_prime) = @@_;
    12     my $kid;
    13     my $downstream = Thread::Queue->new();
    14     while (my $num = $upstream->dequeue()) {
    15         next unless ($num % $cur_prime);
    16         if ($kid) {
    17             $downstream->enqueue($num);
    18         } else {
    19             print("Found prime: $num\n");
    20             $kid = threads->create(\&check_num, $downstream, $num);
    21             if (! $kid) {
    22                 warn("Sorry.  Ran out of threads.\n");
    23                 last;
    24             }
    25         }
    26     }
    27     if ($kid) {
    28         $downstream->enqueue(undef);
    29         $kid->join();
    30     }
    31 }
    32
    33 my $stream = Thread::Queue->new(3..1000, undef);
    34 check_num($stream, 2);
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d10 1
a10 1
referred to as I<ithreads>) that was first introduced in Perl 5.6.0.  In this
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d1 2
d16 1
a16 1
that used the L<Threads> class.  This old model was known to have problems, is
d1046 1
a1046 1
threads.  See L<threads/"THREAD SIGNALLING> for more details.)
d1083 1
a1083 1
Lastest version of L<threads> on CPAN:
d1089 1
a1089 1
Lastest version of L<threads::shared> on CPAN:
d1093 1
a1093 1
L<http://lists.cpan.org/showlist.cgi?name=iThreads>
@


1.8
log
@Merge in perl 5.10.1
@
text
@d112 1
a112 1
everything that's ever come before -- they're not.  Perl's threading
d164 1
a164 1
Thread support is a Perl compile-time option -- it's something that's
d278 1
a278 1
See L<threads/"$thr->join()"> and L<threads/"THREAD CONTEXT"> for more
d369 1
a369 1
This is similar in feel to what happens when a UNIX process forks,
d742 1
a742 1
your I/O channels, or deplete your process' quota of filehandles.  You
d1006 1
a1006 1
on -- before the base thread has accumulated too much data. Of course, this
d1033 1
a1033 1
between platforms.  For example, some UNIX systems copy all the current
d1052 2
a1053 3
C<getnetent()> and so on), C<readdir()>,
C<rand()>, and C<srand()> -- in general, calls that depend on some global
external state.
d1095 1
a1095 1
Here's a short bibliography courtesy of Jürgen Christoffel:
d1102 1
a1102 1
http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-035.html
d1152 1
a1152 1
Sarathy, Ilya Zakharevich, Benjamin Sugars, Jürgen Christoffel, Joshua
d1163 1
a1163 1
Reworked slightly by Jörg Walter E<lt>jwalt@@cpan.org<gt> to be more concise
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d351 2
a352 2
    $thr1->join;
    $thr2->join;
d427 2
a428 2
    $thr1->join;
    $thr2->join;
d452 2
a453 2
    $thr1->join;
    $thr2->join;
d856 25
a880 27
    10 my $stream = Thread::Queue->new();
    11 for my $i ( 3 .. 1000 ) {
    12     $stream->enqueue($i);
    13 }
    14 $stream->enqueue(undef);
    15
    16 threads->create(\&check_num, $stream, 2);
    17 $kid->join();
    18
    19 sub check_num {
    20     my ($upstream, $cur_prime) = @@_;
    21     my $kid;
    22     my $downstream = Thread::Queue->new();
    23     while (my $num = $upstream->dequeue()) {
    24         next unless ($num % $cur_prime);
    25         if ($kid) {
    26             $downstream->enqueue($num);
    27         } else {
    28             print("Found prime $num\n");
    29             $kid = threads->create(\&check_num, $downstream, $num);
    30         }
    31     }
    32     if ($kid) {
    33         $downstream->enqueue(undef);
    34         $kid->join();
    35     }
    36 }
d899 1
a899 1
the subroutine is checking (line 20), we create a new queue (line 22)
d901 1
a901 1
(line 21).
d903 1
a903 1
The while loop from lines 23 to line 31 grabs a scalar off the input
d905 1
a905 1
for.  Line 24 checks to see if there's a remainder when we divide the
d908 1
a908 1
it on to the next thread if we've created one (line 26) or create a
d911 4
a914 2
The new thread creation is line 29.  We pass on to it a reference to
the queue we've created, and the prime number we've found.
d918 2
a919 2
child and wait for it to exit if we've created a child (lines 32 and
35).
d921 4
a924 7
Meanwhile, back in the main thread, we first create a queue (line 10) and
queue up all the numbers from 3 to 1000 for checking (lines 11-13),
plus a termination notice (line 14).  Then we create the initial child
threads (line 16), passing it the queue and the first prime: 2.  Finally,
we wait for the first child thread to terminate (line 17).  Because a
child won't terminate until its child has terminated, we know that we're
done once we return from the C<join()>.
@


1.6
log
@merge in perl 5.8.8
@
text
@d3 1
a3 1
perlthrtut - tutorial on threads in Perl
d7 11
a17 10
B<NOTE>: this tutorial describes the new Perl threading flavour
introduced in Perl 5.6.0 called interpreter threads, or B<ithreads>
for short.  In this model each thread runs in its own Perl interpreter,
and any data sharing between threads must be explicit.

There is another older Perl threading flavour called the 5.005 model,
unsurprisingly for 5.005 versions of Perl.  The old model is known to
have problems, deprecated, and will probably be removed around release
5.10. You are strongly encouraged to migrate any existing 5.005
threads code to the new model as soon as possible.
d26 3
a28 9
The user-level interface to the 5.005 threads was via the L<Threads>
class, while ithreads uses the L<threads> class. Note the change in case.

=head1 Status

The ithreads code has been available since Perl 5.6.0, and is considered
stable. The user-level interface to ithreads (the L<threads> classes)
appeared in the 5.8.0 release, and as of this time is considered stable
although it should be treated with caution as with all new features.
d45 1
a45 1
to do.  For many non-trivial threaded programs you'll need to choose
d50 2
a51 2
The boss/worker model usually has one "boss" thread and one or more
"worker" threads.  The boss thread gathers or generates tasks that need
d104 2
a105 2
remember when dealing with Perl threads that Perl Threads Are Not X
Threads, for all values of X.  They aren't POSIX threads, or
d112 1
a112 1
everything that's ever come before--they're not.  Perl's threading
d119 3
a121 3
However it is important to remember that Perl threads cannot magically
do things unless your operating systems threads allows it. So if your
system blocks the entire process on sleep(), Perl usually will as well.
d123 1
a123 1
Perl Threads Are Different.
d129 1
a129 1
modules with XS code or external libraries. However, since perl data is
d138 1
a138 1
core.  Threads are a new feature, and even some of the standard
d156 2
a157 2
The core L<threads> module provides the basic functions you need to write
threaded programs.  In the following sections we'll cover the basics,
d164 1
a164 1
Thread support is a Perl compile-time option - it's something that's
d173 2
a174 1
    $Config{useithreads} or die "Recompile Perl with threads to run this program.";
d186 1
a186 1
           import MyMod_threaded;
d188 2
a189 2
           require MyMod_unthreaded;
           import MyMod_unthreaded;
d195 1
a195 1
module.  In our example above, that's what MyMod_threaded is, and it's
a199 2
Although thread support is considered to be stable, there are still a number
of quirks that may startle you when you try out any of the examples below.
d202 1
a202 1
examples in the interest of simplicity.  Running these examples "as is" will
a204 1
Future versions of Perl may fix this problem.
d208 1
a208 1
The L<threads> package provides the tools you need to create new
d210 1
a210 1
it; C<use threads> imports all the pieces you need to create basic
d213 1
a213 1
The simplest, most straightforward way to create a thread is with new():
d215 1
a215 1
    use threads; 
d217 1
a217 1
    $thr = threads->new(\&sub1);
d219 2
a220 2
    sub sub1 { 
        print "In the thread\n"; 
d223 2
a224 2
The new() method takes a reference to a subroutine and creates a new
thread, which starts executing in the referenced subroutine.  Control
d229 3
a231 1
part of the C<threads::new> call, like this:
d233 5
a237 1
    use threads; 
d239 4
a242 9
    $Param3 = "foo"; 
    $thr = threads->new(\&sub1, "Param 1", "Param 2", $Param3); 
    $thr = threads->new(\&sub1, @@ParamList); 
    $thr = threads->new(\&sub1, qw(Param1 Param2 Param3));

    sub sub1 { 
        my @@InboundParameters = @@_; 
        print "In the thread\n"; 
        print "got parameters >", join("<>", @@InboundParameters), "<\n"; 
a244 1

d250 1
a250 1
C<create()> is a synonym for C<new()>.
d256 1
a256 1
use the join() method:
d258 1
a258 1
    use threads; 
d260 1
a260 1
    $thr = threads->new(\&sub1);
d262 2
a263 2
    @@ReturnData = $thr->join; 
    print "Thread returned @@ReturnData"; 
d265 1
a265 1
    sub sub1 { return "Fifty-six", "foo", 2; }
d267 1
a267 1
In the example above, the join() method returns as soon as the thread
d269 1
a269 1
any values that the thread might have returned, join() also performs
d273 1
a273 1
for the thread to finish, you should call the detach() method
d276 5
d283 1
a283 1
join() does three things: it waits for a thread to exit, cleans up
d289 2
a290 2
In this case, you use the detach() method.  Once a thread is detached,
it'll run until it's finished, then Perl will clean up after it
d293 1
a293 1
    use threads; 
d295 1
a295 1
    $thr = threads->new(\&sub1); # Spawn the thread
d297 3
a299 1
    $thr->detach; # Now we officially don't care any more
d302 6
a307 6
        $a = 0; 
        while (1) { 
            $a++; 
            print "\$a is $a\n"; 
            sleep 1; 
        } 
d314 42
d359 1
a359 1
topic: data.  Threading introduces a couple of complications to data
d364 1
a364 1
The biggest difference between Perl ithreads and the old 5.005 style
d366 1
a366 1
is that by default, no data is shared. When a new perl thread is created,
d373 1
a373 1
To make use of threading however, one usually wants the threads to share
d375 1
a375 1
L<threads::shared> module and the C< : shared> attribute:
d380 1
a380 1
    my $foo : shared = 1;
d382 1
a382 1
    threads->new(sub { $foo++; $bar++ })->join;
d384 2
a385 2
    print "$foo\n";  #prints 2 since $foo is shared
    print "$bar\n";  #prints 1 since $bar is not shared
d397 3
a399 3
    my $var           = 1;
    my $svar : shared = 2;
    my %hash : shared;
d403 6
a408 6
    $hash{a} = 1;	# all threads see exists($hash{a}) and $hash{a} == 1
    $hash{a} = $var	# okay - copy-by-value: same effect as previous
    $hash{a} = $svar	# okay - copy-by-value: same effect as previous
    $hash{a} = \$svar	# okay - a reference to a shared variable
    $hash{a} = \$var	# This will die
    delete $hash{a}	# okay - all threads will see !exists($hash{a})
d420 1
a420 1
    use threads; 
d423 3
a425 3
    my $a : shared = 1; 
    $thr1 = threads->new(\&sub1); 
    $thr2 = threads->new(\&sub2); 
d429 1
a429 1
    print "$a\n";
d434 2
a435 2
What do you think $a will be? The answer, unfortunately, is "it
depends." Both sub1() and sub2() access the global variable $a, once
d438 1
a438 1
$a can be 2 or 3.
d446 5
a450 5
    use threads; 
    my $a : shared = 2;
    my $b : shared;
    my $c : shared;
    my $thr1 = threads->create(sub { $b = $a; $a = $b + 1; }); 
d455 3
a457 3
Two threads both access $a.  Each thread can potentially be interrupted
at any point, or be executed in any order.  At the end, $a could be 3
or 4, and both $b and $c could be 2 or 3.
d478 1
a478 1
The lock() function takes a shared variable and puts a lock on it.  
d481 2
a482 2
when the locking thread exits the outermost block that contains
C<lock()> function.  Using lock() is straightforward: this example has
d489 1
a489 1
    my $total : shared = 0;
d492 9
a500 9
	for (;;) {
	    my $result;
	    # (... do some calculations and set $result ...)
	    {
		lock($total); # block until we obtain the lock
		$total += $result;
	    } # lock implicitly released at end of scope
	    last if $result == 0;
	}
d503 11
a513 12
    my $thr1 = threads->new(\&calc);
    my $thr2 = threads->new(\&calc);
    my $thr3 = threads->new(\&calc);
    $thr1->join;
    $thr2->join;
    $thr3->join;
    print "total=$total\n";


lock() blocks the thread until the variable being locked is
available.  When lock() returns, your thread can be sure that no other
thread can lock that variable until the outermost block containing the
d519 1
a519 1
locking that flock() gives you.  
d527 1
a527 1
lock() on the variable goes out of scope. For example:
d529 1
a529 1
    my $x : shared;
d533 13
a545 13
	{
	    {
		lock($x); # wait for lock
		lock($x); # NOOP - we already have the lock
		{
		    lock($x); # NOOP
		    {
			lock($x); # NOOP
			lockit_some_more();
		    }
		}
	    } # *** implicit unlock here ***
	}
d549 2
a550 2
	lock($x); # NOOP
    } # nothing happens here
d552 2
a553 2
Note that there is no unlock() function - the only way to unlock a
variable is to allow it to go out of scope.  
d569 1
a569 1
    use threads; 
d571 11
a581 11
    my $a : shared = 4; 
    my $b : shared = "foo"; 
    my $thr1 = threads->new(sub { 
        lock($a); 
        sleep 20; 
        lock($b); 
    }); 
    my $thr2 = threads->new(sub { 
        lock($b); 
        sleep 20; 
        lock($a); 
d589 1
a589 1
The first thread will grab a lock on $a, then, after a pause during which
d591 2
a592 2
lock on $b.  Meanwhile, the second thread grabs a lock on $b, then later
tries to grab a lock on $a.  The second lock attempt for both threads will
d603 2
a604 2
order.  If, for example, you lock variables $a, $b, and $c, always lock
$a before $b, and $b before $c.  It's also best to hold on to locks for
d617 1
a617 1
    use threads; 
d620 10
a629 11
    my $DataQueue = Thread::Queue->new; 
    $thr = threads->new(sub { 
        while ($DataElement = $DataQueue->dequeue) { 
            print "Popped $DataElement off the queue\n";
        } 
    }); 

    $DataQueue->enqueue(12); 
    $DataQueue->enqueue("A", "B", "C"); 
    $DataQueue->enqueue(\$thr); 
    sleep 10; 
d631 1
a631 1
    $thr->join;
d633 3
a635 3
You create the queue with C<new Thread::Queue>.  Then you can
add lists of scalars onto the end with enqueue(), and pop scalars off
the front of it with dequeue().  A queue has no fixed size, and can grow
d638 1
a638 1
If a queue is empty, dequeue() blocks until another thread enqueues
d648 1
a648 1
threads to have the 'lock' at any one time.
d652 2
a653 2
Semaphores have two methods, down() and up(): down() decrements the resource
count, while up increments it. Calls to down() will block if the
d658 1
a658 1
    use Thread::Semaphore; 
d660 2
a661 2
    my $semaphore = new Thread::Semaphore; 
    my $GlobalVariable : shared = 0;
d663 18
a680 18
    $thr1 = new threads \&sample_sub, 1; 
    $thr2 = new threads \&sample_sub, 2; 
    $thr3 = new threads \&sample_sub, 3;

    sub sample_sub { 
        my $SubNumber = shift @@_; 
        my $TryCount = 10; 
        my $LocalCopy; 
        sleep 1; 
        while ($TryCount--) { 
            $semaphore->down; 
            $LocalCopy = $GlobalVariable; 
            print "$TryCount tries left for sub $SubNumber (\$GlobalVariable is $GlobalVariable)\n"; 
            sleep 2; 
            $LocalCopy++; 
            $GlobalVariable = $LocalCopy; 
            $semaphore->up; 
        } 
d683 3
a685 3
    $thr1->join;
    $thr2->join;
    $thr3->join;
d694 1
a694 1
down() them at a time.  However, there are other uses for semaphores.
d697 2
a698 2
created with the counter set to one, down() decrements the counter by
one, and up() increments by one. However, we can override any or all
d703 1
d707 2
a708 2
    $thr1 = threads->new(\&sub1);
    $thr2 = threads->new(\&sub1);
d716 2
a717 2
    $thr1->detach;
    $thr2->detach;
d719 1
a719 1
If down() attempts to decrement the counter below zero, it blocks until
d721 3
a723 3
with a starting count of zero, any up() or down() always changes the
counter by at least one, and so $semaphore->down(0) is the same as
$semaphore->down(1).
d727 1
a727 1
decrement/increment it by more than one? The answer is resource
d750 1
a750 1
=head2 cond_wait() and cond_signal()
d752 2
a753 1
These two functions can be used in conjunction with locks to notify
d767 2
a768 2
Perl's threading package provides the yield() function that does
this. yield() is pretty straightforward, and works like this:
d770 1
a770 1
    use threads; 
d773 6
a778 6
	    my $thread = shift;
	    my $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
	    threads->yield;
	    $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
d781 3
a783 3
    my $thread1 = threads->new(\&loop, 'first');
    my $thread2 = threads->new(\&loop, 'second');
    my $thread3 = threads->new(\&loop, 'third');
d785 1
a785 1
It is important to remember that yield() is only a hint to give up the CPU,
d789 1
a789 1
yield() calls. It might work on your platform but it won't work on another
d801 1
a801 1
The C<< threads->self >> class method provides your program with a way to
d807 1
a807 1
tid() is a thread object method that returns the thread ID of the
d809 1
a809 1
thread in a program being 0.  Currently Perl assigns a unique tid to
d811 3
a813 2
to be created a tid of 1, and increasing the tid by 1 for each new
thread that's created.
d817 1
a817 1
The equal() method takes two thread objects and returns true 
d820 1
a820 1
Thread objects also have an overloaded == comparison so that you can do
d825 1
a825 1
C<< threads->list >> returns a list of thread objects, one for each thread
d827 2
a828 1
including cleaning up at the end of your program:
d830 3
a832 6
    # Loop through all the threads 
    foreach $thr (threads->list) { 
        # Don't join the main thread or ourselves 
        if ($thr->tid && !threads::equal($thr, threads->self)) { 
            $thr->join; 
        } 
d837 4
a840 1
to clean up itself while other threads are running
d847 14
a860 14
    1  #!/usr/bin/perl -w
    2  # prime-pthread, courtesy of Tom Christiansen
    3
    4  use strict;
    5
    6  use threads;
    7  use Thread::Queue;
    8
    9  my $stream = new Thread::Queue;
    10 my $kid    = new threads(\&check_num, $stream, 2);
    11
    12 for my $i ( 3 .. 1000 ) {
    13     $stream->enqueue($i);
    14 } 
d862 2
a863 2
    16 $stream->enqueue(undef);
    17 $kid->join;
d868 3
a870 3
    22     my $downstream = new Thread::Queue;
    23     while (my $num = $upstream->dequeue) {
    24         next unless $num % $cur_prime;
d872 4
a875 4
    26            $downstream->enqueue($num);
    27          	} else {
    28            print "Found prime $num\n";
    29	              $kid = new threads(\&check_num, $downstream, $num);
d877 6
a882 4
    31     } 
    32     $downstream->enqueue(undef) if $kid;
    33     $kid->join		if $kid;
    34 }
d896 1
a896 1
number is, it's a number that's only evenly divisible by itself and 1)
d898 1
a898 1
The bulk of the work is done by the check_num() subroutine, which
d901 1
a901 1
the subroutine's checking (line 20), we create a new queue (line 22)
d907 2
a908 2
for.  Line 24 checks to see if there's a remainder when we modulo the
number to be checked against our prime.  If there is one, the number
d916 2
a917 2
Finally, once the loop terminates (because we got a 0 or undef in the
queue, which serves as a note to die), we pass on the notice to our
d919 1
a919 1
37).
d921 7
a927 6
Meanwhile, back in the main thread, we create a queue (line 9) and the
initial child thread (line 10), and pre-seed it with the first prime:
2.  Then we queue all the numbers from 3 to 1000 for checking (lines
12-14), then queue a die notice (line 16) and wait for the first child
thread to terminate (line 17).  Because a child won't die until its
child has died, we know that we're done once we return from the join.
d945 1
a945 1
include most system calls, most I/O, and things like sleep().
d963 2
a964 2
unpredictably with kernel threads if $a is visible to other
threads, as another thread may have changed $a between the time it
d1003 1
a1003 1
The main thing to bear in mind when comparing ithreads to other threading
d1005 1
a1005 1
all the variables and data of the parent thread has to be taken. Thus
d1009 1
a1009 1
on -  before the base thread has accumulated too much data. Of course, this
d1024 1
a1024 1
directory using chdir().  One thread calls chdir(), and the working
d1027 1
a1027 1
Even more drastic example of a process-scope change is chroot():
d1029 1
a1029 1
undo it (as opposed to chdir()).
d1031 2
a1032 2
Further examples of process-scope changes include umask() and
changing uids/gids.
d1034 2
a1035 2
Thinking of mixing fork() and threads?  Please lie down and wait
until the feeling passes.  Be aware that the semantics of fork() vary
d1038 1
a1038 1
called fork(). You have been warned!
d1040 1
a1040 1
Similarly, mixing signals and threads should not be attempted.
d1043 5
a1047 1
give you the full POSIX API).
d1053 4
a1056 2
localtime(), gmtime(), get{gr,host,net,proto,serv,pw}*(), readdir(),
rand(), and srand() -- in general, calls that depend on some global
d1071 1
a1071 1
PERL_REENTRANT_MAXSIZE defined to the maximum number of bytes you will
d1080 17
d1168 1
a1168 1
about thread-safety of perl code.
d1180 1
a1180 1
For more information please see L<threads> and L<threads::shared>.
@


1.5
log
@sync in-tree perl with 5.8.6
@
text
@d55 2
a56 2
The boss/worker model usually has one `boss' thread and one or more
`worker' threads.  The boss thread gathers or generates tasks that need
@


1.4
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d605 1
a605 1
form, they behave very much like lockable scalars, except that thay
@


1.3
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d988 4
a991 3
until the feeling passes-- but in case you really want to know,
the semantics is that fork() duplicates all the threads.
(In UNIX, at least, other platforms will do something different.)
@


1.2
log
@repeated words; millert ok ok
@
text
@a104 75
=head1 Native threads

There are several different ways to implement threads on a system.  How
threads are implemented depends both on the vendor and, in some cases,
the version of the operating system.  Often the first implementation
will be relatively simple, but later versions of the OS will be more
sophisticated.

While the information in this section is useful, it's not necessary,
so you can skip it if you don't feel up to it.

There are three basic categories of threads: user-mode threads, kernel
threads, and multiprocessor kernel threads.

User-mode threads are threads that live entirely within a program and
its libraries.  In this model, the OS knows nothing about threads.  As
far as it's concerned, your process is just a process.

This is the easiest way to implement threads, and the way most OSes
start.  The big disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all do.  Typical blocking activities
include most system calls, most I/O, and things like sleep().

Kernel threads are the next step in thread evolution.  The OS knows
about kernel threads, and makes allowances for them.  The main
difference between a kernel thread and a user-mode thread is
blocking.  With kernel threads, things that block a single thread don't
block other threads.  This is not the case with user-mode threads,
where the kernel blocks at the process level and not the thread level.

This is a big step forward, and can give a threaded program quite a
performance boost over non-threaded programs.  Threads that block
performing I/O, for example, won't block threads that are doing other
things.  Each process still has only one thread running at once,
though, regardless of how many CPUs a system might have.

Since kernel threading can interrupt a thread at any time, they will
uncover some of the implicit locking assumptions you may make in your
program.  For example, something as simple as C<$a = $a + 2> can behave
unpredictably with kernel threads if $a is visible to other
threads, as another thread may have changed $a between the time it
was fetched on the right hand side and the time the new value is
stored.

Multiprocessor kernel threads are the final step in thread
support.  With multiprocessor kernel threads on a machine with multiple
CPUs, the OS may schedule two or more threads to run simultaneously on
different CPUs.

This can give a serious performance boost to your threaded program,
since more than one thread will be executing at the same time.  As a
tradeoff, though, any of those nagging synchronization issues that
might not have shown with basic kernel threads will appear with a
vengeance.

In addition to the different levels of OS involvement in threads,
different OSes (and different thread implementations for a particular
OS) allocate CPU cycles to threads in different ways.

Cooperative multitasking systems have running threads give up control
if one of two things happen.  If a thread calls a yield function, it
gives up control.  It also gives up control if the thread does
something that would cause it to block, such as perform I/O.  In a
cooperative multitasking implementation, one thread can starve all the
others for CPU time if it so chooses.

Preemptive multitasking systems interrupt threads at regular intervals
while the system decides which thread should run next.  In a preemptive
multitasking system, one thread usually won't monopolize the CPU.

On some systems, there can be cooperative and preemptive threads
running simultaneously. (Threads running with realtime priorities
often behave cooperatively, for example, while threads running at
normal priorities behave preemptively.)

a258 33
=head2 Giving up control

There are times when you may find it useful to have a thread
explicitly give up the CPU to another thread.  Your threading package
might not support preemptive multitasking for threads, for example, or
you may be doing something processor-intensive and want to make sure
that the user-interface thread gets called frequently.  Regardless,
there are times that you might want a thread to give up the processor.

Perl's threading package provides the yield() function that does
this. yield() is pretty straightforward, and works like this:

    use threads; 

    sub loop {
	    my $thread = shift;
	    my $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
	    threads->yield;
	    $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
    }

    my $thread1 = threads->new(\&loop, 'first');
    my $thread2 = threads->new(\&loop, 'second');
    my $thread3 = threads->new(\&loop, 'third');

It is important to remember that yield() is only a hint to give up the CPU,
it depends on your hardware, OS and threading libraries what actually happens.
Therefore it is important to note that one should not build the scheduling of 
the threads around yield() calls. It might work on your platform but it won't
work on another platform.

a533 1
        threads->yield; 
a538 1
        threads->yield; 
d617 1
a617 1
    use threads qw(yield); 
a635 1
            yield; 
d717 33
d885 69
d1010 9
a1018 4
In some platforms the thread-safe interfaces may fail if the result
buffer is too small (for example getgrent() may return quite large
group member lists).  Perl will retry growing the result buffer
a few times, but only up to 64k (for safety reasons).
d1099 3
a1109 1

@


1.1
log
@Initial revision
@
text
@d7 27
a33 3
One of the most prominent new features of Perl 5.005 is the inclusion
of threads. Threads make a number of things a lot easier, and are a
very useful addition to your bag of programming tricks.
d41 1
a41 1
Threads are one of the pieces of a process. Every process has at least
d43 1
a43 1
thread. With 5.005, though, you can create extra threads. We're going
d49 2
a50 2
program. Which model you choose depends on what you need your program
to do. For many non-trivial threaded programs you'll need to choose
d56 1
a56 1
`worker' threads. The boss thread gathers or generates tasks that need
d62 1
a62 1
worker threads for processing. Once the event has been passed on, the
d65 1
a65 1
The boss thread does relatively little work. While tasks aren't
d72 1
a72 1
essentially the same thing to different pieces of data. It closely
d78 1
a78 1
will distribute multiple threads across different processors. It can
d87 1
a87 1
next. Each thread does one thing to each piece of data and passes the
d92 1
a92 1
make sense in other contexts as well. It tends to keep the individual
d95 1
a95 1
going. If you're running different parts of the pipeline on different
d101 1
a101 1
another thread. Prime and Fibonacci generators both map well to this
d107 1
a107 1
There are several different ways to implement threads on a system. How
d109 1
a109 1
the version of the operating system. Often the first implementation
d116 1
a116 1
There are three basic categories of threads-user-mode threads, kernel
d120 1
a120 1
its libraries. In this model, the OS knows nothing about threads. As
d124 2
a125 2
start. The big disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all do. Typical blocking activities
d128 1
a128 1
Kernel threads are the next step in thread evolution. The OS knows
d131 2
a132 2
blocking. With kernel threads, things that block a single thread don't
block other threads. This is not the case with user-mode threads,
d138 1
a138 1
things. Each process still has only one thread running at once,
d143 3
a145 3
program. For example, something as simple as C<$a = $a + 2> can behave
unpredictably with kernel threads if C<$a> is visible to other
threads, as another thread may have changed C<$a> between the time it
d149 2
a150 2
Multiprocessor Kernel Threads are the final step in thread
support. With multiprocessor kernel threads on a machine with multiple
d155 1
a155 1
since more than one thread will be executing at the same time. As a
d165 3
a167 3
if one of two things happen. If a thread calls a yield function, it
gives up control. It also gives up control if the thread does
something that would cause it to block, such as perform I/O. In a
d172 1
a172 1
while the system decides which thread should run next. In a preemptive
d180 1
a180 1
=head1 What kind of threads are perl threads?
d183 1
a183 1
find that things aren't quite what you expect. It's very important to
d186 1
a186 1
DecThreads, or Java's Green threads, or Win32 threads. There are
d189 1
a189 1
disappointed or confused. Possibly both.
d192 3
a194 3
everything that's ever come before--they're not. Perl's threading
model owes a lot to other thread models, especially POSIX. Just as
Perl is not C, though, Perl threads are not POSIX threads. So if you
d199 7
a205 1
=head1 Threadsafe Modules
d209 5
a213 4
modules--especially modules with XS code or external libraries. While
most modules won't encounter any problems, modules that aren't
explicitly tagged as thread-safe should be tested before being used in
production code.
d217 2
a218 2
otherwise. This includes modules that are distributed as part of the
core. Threads are a beta feature, and even some of the standard
d221 5
d227 6
a232 3
can protect yourself by using semaphores and lots of programming
discipline to control access to the module. Semaphores are covered
later in the article.  Perl Threads Are Different
d236 4
a239 4
The core Thread module provides the basic functions you need to write
threaded programs. In the following sections we'll cover the basics,
showing you what you need to do to create a threaded program. After
that, we'll go over some of the features of the Thread module that
d244 1
a244 1
Thread support is a Perl compile-time option-it's something that's
a248 7
Remember that the threading support in 5.005 is in beta release, and
should be treated as such. You should expect that it may not function
entirely properly, and the thread interface may well change some
before it is a fully supported, production release.  The beta version
shouldn't be used for mission-critical projects.  Having said that,
threaded Perl is pretty nifty, and worth a look.

d253 1
a253 1
  $Config{usethreads} or die "Recompile Perl with threads to run this program.";
d258 2
a259 2
    use Config; 
    use MyMod; 
d261 10
a270 8
    if ($Config{usethreads}) { 
        # We have threads 
        require MyMod_threaded; 
        import MyMod_threaded; 
    } else { 
        require MyMod_unthreaded; 
        import MyMod_unthreaded; 
    } 
d274 1
a274 1
module. In our example above, that's what MyMod_threaded is, and it's
d277 11
d290 3
a292 3
The Thread package provides the tools you need to create new
threads. Like any other module, you need to tell Perl you want to use
it; use Thread imports all the pieces you need to create basic
d295 1
a295 1
The simplest, straightforward way to create a thread is with new():
d297 1
a297 1
    use Thread; 
d299 1
a299 1
    $thr = new Thread \&sub1;
d306 1
a306 1
thread, which starts executing in the referenced subroutine. Control
d310 4
a313 2
part of the thread startup. Just include the list of parameters as
part of the C<Thread::new> call, like this:
a314 1
    use Thread; 
d316 3
a318 3
    $thr = new Thread \&sub1, "Param 1", "Param 2", $Param3; 
    $thr = new Thread \&sub1, @@ParamList; 
    $thr = new Thread \&sub1, qw(Param1 Param2 $Param3);
d327 2
a328 5
The subroutine runs like a normal Perl subroutine, and the call to new
Thread returns whatever the subroutine returns.

The last example illustrates another feature of threads. You can spawn
off several threads using the same subroutine. Each thread executes
d332 1
a332 27
The other way to spawn a new thread is with async(), which is a way to
spin off a chunk of code like eval(), but into its own thread:

    use Thread qw(async);

    $LineCount = 0; 

    $thr = async { 
        while(<>) {$LineCount++} 	 
        print "Got $LineCount lines\n";
    }; 

    print "Waiting for the linecount to end\n"; 
    $thr->join; 
    print "All done\n";

You'll notice we did a use Thread qw(async) in that example.  async is
not exported by default, so if you want it, you'll either need to
import it before you use it or fully qualify it as
Thread::async. You'll also note that there's a semicolon after the
closing brace. That's because async() treats the following block as an
anonymous subroutine, so the semicolon is necessary.

Like eval(), the code executes in the same context as it would if it
weren't spun off. Since both the code inside and after the async start
executing, you need to be careful with any shared resources. Locking
and other synchronization techniques are covered later.
d337 1
a337 1
explicitly give up the CPU to another thread. Your threading package
d339 2
a340 2
you may be doing something compute-intensive and want to make sure
that the user-interface thread gets called frequently. Regardless,
d346 20
a365 15
    use Thread qw(yield async); 
    async { 
        my $foo = 50; 
        while ($foo--) { print "first async\n" }
        yield; 
        $foo = 50; 
        while ($foo--) { print "first async\n" } 
    }; 
    async { 
        my $foo = 50; 
        while ($foo--) { print "second async\n" }
        yield; 
        $foo = 50; 
        while ($foo--) { print "second async\n" } 
    };
d369 5
a373 3
Since threads are also subroutines, they can return values. To wait
for a thread to exit and extract any scalars it might return, you can
use the join() method.
d375 1
a375 2
    use Thread; 
    $thr = new Thread \&sub1;
d383 1
a383 1
ends. In addition to waiting for a thread to finish and gathering up
d387 1
a387 1
threads. If you don't want the return values and don't want to wait
d389 1
a389 23
instead. detach() is covered later in the article.

=head2 Errors In Threads

So what happens when an error occurs in a thread? Any errors that
could be caught with eval() are postponed until the thread is
joined. If your program never joins, the errors appear when your
program exits.

Errors deferred until a join() can be caught with eval():

    use Thread qw(async); 
    $thr = async {$b = 3/0};   # Divide by zero error
    $foo = eval {$thr->join}; 
    if ($@@) { 
        print "died with error $@@\n"; 
    } else { 
        print "Hey, why aren't you dead?\n"; 
    }

eval() passes any results from the joined thread back unmodified, so
if you want the return value of the thread, this is your only chance
to get them.
d393 2
a394 2
join() does three things:it waits for a thread to exit, cleans up
after it, and returns any data the thread may have produced. But what
d399 1
a399 1
In this case, you use the detach() method. Once a thread is detached,
d403 3
a405 2
    use Thread; 
    $thr = new Thread \&sub1; # Spawn the thread
d409 1
a409 1
    sub sub1 { 
d418 2
a419 3

Once a thread is detached, it may not be joined, and any output that
it might have produced (if it was done and waiting for a join) is
d425 1
a425 1
topic: data. Threading introduces a couple of complications to data
d430 50
a479 13
The single most important thing to remember when using threads is that
all threads potentially have access to all the data anywhere in your
program. While this is true with a nonthreaded Perl program as well,
it's especially important to remember with a threaded program, since
more than one thread can be accessing this data at once.

Perl's scoping rules don't change because you're using threads.  If a
subroutine (or block, in the case of async()) could see a variable if
you weren't running with threads, it can see it if you are. This is
especially important for the subroutines that create, and makes my
variables even more important. Remember--if your variables aren't
lexically scoped (declared with C<my>) you're probably sharing it between
threads.
d481 1
a481 1
=head2 Thread Pitfall: Races
d484 4
a487 1
number of pitfalls. One pitfall is the race condition:
d489 3
a491 4
    use Thread; 
    $a = 1; 
    $thr1 = Thread->new(\&sub1); 
    $thr2 = Thread->new(\&sub2); 
d493 2
a494 1
    sleep 10; 
d497 2
a498 2
    sub sub1 { $foo = $a; $a = $foo + 1; }
    sub sub2 { $bar = $a; $a = $bar + 1; }
d502 1
a502 1
to read and once to write. Depending on factors ranging from your
d507 1
a507 1
data. Without explicit synchronization, there's no way to be sure that
d509 1
a509 1
and the time you update it. Even this simple code fragment has the
d512 8
a519 4
    use Thread qw(async); 
    $a = 2; 
    async{ $b = $a; $a = $b + 1; }; 
    async{ $c = $a; $a = $c + 1; };
d521 2
a522 2
Two threads both access $a. Each thread can potentially be interrupted
at any point, or be executed in any order. At the end, $a could be 3
d525 2
d529 12
a540 1
data corruption and race conditions.
d544 33
a576 28
The lock() function takes a variable (or subroutine, but we'll get to
that later) and puts a lock on it. No other thread may lock the
variable until the locking thread exits the innermost block containing
the lock. Using lock() is straightforward:

    use Thread qw(async); 
    $a = 4; 
    $thr1 = async { 
        $foo = 12; 
        { 
            lock ($a); # Block until we get access to $a 
            $b = $a; 
            $a = $b * $foo; 
        } 
        print "\$foo was $foo\n";
    }; 
    $thr2 = async { 
        $bar = 7; 
        { 
            lock ($a); # Block until we can get access to $a
            $c = $a; 
            $a = $c * $bar; 
        } 
        print "\$bar was $bar\n";
    }; 
    $thr1->join; 
    $thr2->join; 
    print "\$a is $a\n";
d579 2
a580 2
available. When lock() returns, your thread can be sure that no other
thread can lock that variable until the innermost block containing the
d584 1
a584 1
in question, only lock attempts. This is in keeping with Perl's
d586 1
a586 2
locking that flock() gives you. Locked subroutines behave differently,
however. We'll cover that later in the article.
d588 1
a588 1
You may lock arrays and hashes as well as scalars. Locking an array,
d592 49
a640 14
Finally, locks are recursive, which means it's okay for a thread to
lock a variable more than once. The lock will last until the outermost
lock() on the variable goes out of scope.

=head2 Thread Pitfall: Deadlocks

Locks are a handy tool to synchronize access to data. Using them
properly is the key to safe shared data. Unfortunately, locks aren't
without their dangers. Consider the following code:

    use Thread qw(async yield); 
    $a = 4; 
    $b = "foo"; 
    async { 
d642 1
a642 1
        yield; 
a643 3
        lock ($b); 
    }; 
    async { 
d645 4
a648 1
        yield; 
d650 2
a651 2
        lock ($a); 
    };
d653 3
a655 3
This program will probably hang until you kill it. The only way it
won't hang is if one of the two async() routines acquires both locks
first. A guaranteed-to-hang version is more complicated, but the
d658 5
a662 5
The first thread spawned by async() will grab a lock on $a then, a
second or two later, try to grab a lock on $b. Meanwhile, the second
thread grabs a lock on $b, then later tries to grab a lock on $a. The
second lock attempt for both threads will block, each waiting for the
other to release its lock.
d666 2
a667 2
own. Each thread will block, waiting for the other to release a lock
on a resource. That never happens, though, since the thread with the
d670 1
a670 1
There are a number of ways to handle this sort of problem. The best
d672 2
a673 2
order. If, for example, you lock variables $a, $b, and $c, always lock
$a before $b, and $b before $c. It's also best to hold on to locks for
d676 3
d683 1
a683 1
synchronization issues. They're pretty straightforward, and look like
d686 1
a686 1
    use Thread qw(async); 
d689 2
a690 2
    my $DataQueue = new Thread::Queue; 
    $thr = async { 
d694 1
a694 1
    }; 
d701 1
d703 4
a706 4
You create the queue with new Thread::Queue. Then you can add lists of
scalars onto the end with enqueue(), and pop scalars off the front of
it with dequeue(). A queue has no fixed size, and can grow as needed
to hold everything pushed on to it.
d709 1
a709 1
something. This makes queues ideal for event loops and other
a711 7
=head1 Threads And Code

In addition to providing thread-safe access to data via locks and
queues, threaded Perl also provides general-purpose semaphores for
coarser synchronization than locks provide and thread-safe access to
entire subroutines.

d714 11
a724 14
Semaphores are a kind of generic locking mechanism. Unlike lock, which
gets a lock on a particular scalar, Perl doesn't associate any
particular thing with a semaphore so you can use them to control
access to anything you like. In addition, semaphores can allow more
than one thread to access a resource at once, though by default
semaphores only allow one thread access at a time.

=over 4

=item Basic semaphores

Semaphores have two methods, down and up. down decrements the resource
count, while up increments it.  down calls will block if the
semaphore's current count would decrement below zero. This program
d727 1
a727 1
    use Thread qw(yield); 
d729 1
d731 1
a731 1
    $GlobalVariable = 0;
d733 3
a735 3
    $thr1 = new Thread \&sample_sub, 1; 
    $thr2 = new Thread \&sample_sub, 2; 
    $thr3 = new Thread \&sample_sub, 3;
d754 5
a758 1
The three invocations of the subroutine all operate in sync. The
d762 1
a762 1
=item Advanced Semaphores
d765 23
a787 1
down() them at a time. However, there are other uses for semaphores.
d789 5
a793 8
Each semaphore has a counter attached to it. down() decrements the
counter and up() increments the counter. By default, semaphores are
created with the counter set to one, down() decrements by one, and
up() increments by one. If down() attempts to decrement the counter
below zero, it blocks until the counter is large enough. Note that
while a semaphore can be created with a starting count of zero, any
up() or down() always changes the counter by at least
one. $semaphore->down(0) is the same as $semaphore->down(1).
d798 1
a798 1
availability. Many resources that you want to manage access for can be
d801 1
a801 1
For example, let's take a GUI driven program. It has a semaphore that
d803 2
a804 2
ever drawing at once. Handy, but of course you don't want any thread
to start drawing until things are properly set up. In this case, you
d809 2
a810 2
establishing quotas. Say, for example, that you have a number of
threads that can do I/O at once. You don't want all the threads
d812 1
a812 1
your I/O channels, or deplete your process' quota of filehandles. You
d820 1
a820 17
=back

=head2 Attributes: Restricting Access To Subroutines

In addition to synchronizing access to data or resources, you might
find it useful to synchronize access to subroutines. You may be
accessing a singular machine resource (perhaps a vector processor), or
find it easier to serialize calls to a particular subroutine than to
have a set of locks and sempahores.

One of the additions to Perl 5.005 is subroutine attributes. The
Thread package uses these to provide several flavors of
serialization. It's important to remember that these attributes are
used in the compilation phase of your program so you can't change a
subroutine's behavior while your program is actually running.

=head2 Subroutine Locks
d822 5
a826 130
The basic subroutine lock looks like this:

    sub test_sub { 
        use attrs qw(locked); 
    }

This ensures that only one thread will be executing this subroutine at
any one time. Once a thread calls this subroutine, any other thread
that calls it will block until the thread in the subroutine exits
it. A more elaborate example looks like this:

    use Thread qw(yield); 

    new Thread \&thread_sub, 1; 
    new Thread \&thread_sub, 2; 
    new Thread \&thread_sub, 3; 
    new Thread \&thread_sub, 4;

    sub sync_sub { 
        use attrs qw(locked); 
        my $CallingThread = shift @@_; 
        print "In sync_sub for thread $CallingThread\n";
        yield; 
        sleep 3; 
        print "Leaving sync_sub for thread $CallingThread\n"; 
    }

    sub thread_sub { 
        my $ThreadID = shift @@_; 
        print "Thread $ThreadID calling sync_sub\n";
        sync_sub($ThreadID); 
        print "$ThreadID is done with sync_sub\n"; 
    }

The use attrs qw(locked) locks sync_sub(), and if you run this, you
can see that only one thread is in it at any one time.

=head2 Methods

Locking an entire subroutine can sometimes be overkill, especially
when dealing with Perl objects. When calling a method for an object,
for example, you want to serialize calls to a method, so that only one
thread will be in the subroutine for a particular object, but threads
calling that subroutine for a different object aren't blocked. The
method attribute indicates whether the subroutine is really a method.

    use Thread;

    sub tester { 
        my $thrnum = shift @@_; 
        my $bar = new Foo; 
        foreach (1..10) { 	
            print "$thrnum calling per_object\n"; 
            $bar->per_object($thrnum); 	
            print "$thrnum out of per_object\n"; 
            yield; 
            print "$thrnum calling one_at_a_time\n";
            $bar->one_at_a_time($thrnum); 	
            print "$thrnum out of one_at_a_time\n"; 
            yield; 
        } 
    }

    foreach my $thrnum (1..10) { 
        new Thread \&tester, $thrnum; 
    }

    package Foo; 
    sub new { 
        my $class = shift @@_; 
        return bless [@@_], $class; 
    }

    sub per_object { 
        use attrs qw(locked method); 
        my ($class, $thrnum) = @@_; 
        print "In per_object for thread $thrnum\n"; 
        yield; 
        sleep 2; 
        print "Exiting per_object for thread $thrnum\n"; 
    }

    sub one_at_a_time { 
        use attrs qw(locked); 
        my ($class, $thrnum) = @@_; 
        print "In one_at_a_time for thread $thrnum\n";     
        yield; 
        sleep 2; 
        print "Exiting one_at_a_time for thread $thrnum\n"; 
    }

As you can see from the output (omitted for brevity; it's 800 lines)
all the threads can be in per_object() simultaneously, but only one
thread is ever in one_at_a_time() at once.

=head2 Locking A Subroutine

You can lock a subroutine as you would lock a variable. Subroutine
locks work the same as a C<use attrs qw(locked)> in the subroutine,
and block all access to the subroutine for other threads until the
lock goes out of scope. When the subroutine isn't locked, any number
of threads can be in it at once, and getting a lock on a subroutine
doesn't affect threads already in the subroutine. Getting a lock on a
subroutine looks like this:

    lock(\&sub_to_lock);

Simple enough. Unlike use attrs, which is a compile time option,
locking and unlocking a subroutine can be done at runtime at your
discretion. There is some runtime penalty to using lock(\&sub) instead
of use attrs qw(locked), so make sure you're choosing the proper
method to do the locking.

You'd choose lock(\&sub) when writing modules and code to run on both
threaded and unthreaded Perl, especially for code that will run on
5.004 or earlier Perls. In that case, it's useful to have subroutines
that should be serialized lock themselves if they're running threaded,
like so:

    package Foo; 
    use Config; 
    $Running_Threaded = 0;

    BEGIN { $Running_Threaded = $Config{'usethreads'} }

    sub sub1 { lock(\&sub1) if $Running_Threaded }


This way you can ensure single-threadedness regardless of which
version of Perl you're running.
d832 1
a832 1
code and packages. There are a few useful little pieces that didn't
d837 3
a839 3
The Thread->self method provides your program with a way to get an
object representing the thread it's currently in. You can use this
object in the same way as the ones returned from the thread creation.
d844 2
a845 2
thread the object represents. Thread IDs are integers, with the main
thread in a program being 0. Currently Perl assigns a unique tid to
d855 3
d860 3
a862 3
Thread->list returns a list of thread objects, one for each thread
that's currently running. Handy for a number of things, including
cleaning up at the end of your program:
d865 1
a865 1
    foreach $thr (Thread->list) { 
d867 1
a867 1
        if ($thr->tid && !Thread::equal($thr, Thread->self)) { 
d872 3
a874 3
The example above is just for illustration. It isn't strictly
necessary to join all the threads you create, since Perl detaches all
the threads before it exits.
d879 1
a879 1
things we've covered. This program finds prime numbers using threads.
d886 1
a886 1
    6  use Thread;
d890 1
a890 1
    10 my $kid    = new Thread(\&check_num, $stream, 2);
d897 1
a897 1
    17 $kid->join();
d909 1
a909 1
    29	              $kid = new Thread(\&check_num, $downstream, $num);
d913 1
a913 1
    33     $kid->join()		if $kid;
d916 1
a916 1
This program uses the pipeline model to generate prime numbers. Each
d919 1
a919 1
that it funnels numbers that have failed the check into. If the thread
d921 1
a921 1
the thread must have found a new prime number. In that case, a new
d925 1
a925 1
This probably sounds a bit more confusing than it really is, so lets
d932 1
a932 1
responsible for. After pulling in the input queue and the prime that
d939 2
a940 2
for. Line 24 checks to see if there's a remainder when we modulo the
number to be checked against our prime. If there is one, the number
d945 1
a945 1
The new thread creation is line 29. We pass on to it a reference to
d950 1
a950 1
child and wait for it to exit if we've created a child (Lines 32 and
d955 1
a955 1
2. Then we queue all the numbers from 3 to 1000 for checking (lines
d957 1
a957 1
thread to terminate (line 17). Because a child won't die until its
d960 1
a960 1
That's how it works. It's pretty simple; as with many Perl programs,
d963 61
d1027 2
a1028 4
but this should get you well on your way. The final authority on how
Perl's threads behave is the documention bundled with the Perl
distribution, but with what we've covered in this article, you should
be well on your way to becoming a threaded Perl expert.
d1039 2
a1040 2
http://www.research.digital.com/SRC/staff/birrell/bib.html (highly
recommended)
d1064 1
a1064 1
1995, ISBN 0-13-143934-0 (great textbook).
d1074 3
d1083 3
d1091 1
a1091 1
polishing this article. Big thanks to Tom Christiansen for his rewrite
d1096 6
a1101 1
Dan Sugalski E<lt>sugalskd@@ous.eduE<gt>
d1105 4
a1108 4
This article originally appeared in The Perl Journal #10, and is
copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and
The Perl Journal.  This document may be distributed under the same terms
as Perl itself.
d1110 1
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a6 8
    WARNING: Threading is an experimental feature.  Both the interface
    and implementation are subject to change drastically.  In fact, this
    documentation describes the flavor of threads that was in version
    5.005.  Perl 5.6.0 and later have the beginnings of support for
    interpreter threads, which (when finished) is expected to be
    significantly different from what is described here.  The information
    contained here may therefore soon be obsolete.  Use at your own risk!

d8 1
a8 1
of threads.  Threads make a number of things a lot easier, and are a
d17 1
a17 1
Threads are one of the pieces of a process.  Every process has at least
d19 1
a19 1
thread.  With 5.005, though, you can create extra threads.  We're going
d25 2
a26 2
program.  Which model you choose depends on what you need your program
to do.  For many non-trivial threaded programs you'll need to choose
d32 1
a32 1
`worker' threads.  The boss thread gathers or generates tasks that need
d38 1
a38 1
worker threads for processing.  Once the event has been passed on, the
d41 1
a41 1
The boss thread does relatively little work.  While tasks aren't
d48 1
a48 1
essentially the same thing to different pieces of data.  It closely
d54 1
a54 1
will distribute multiple threads across different processors.  It can
d63 1
a63 1
next.  Each thread does one thing to each piece of data and passes the
d68 1
a68 1
make sense in other contexts as well.  It tends to keep the individual
d71 1
a71 1
going.  If you're running different parts of the pipeline on different
d77 1
a77 1
another thread.  Prime and Fibonacci generators both map well to this
d83 1
a83 1
There are several different ways to implement threads on a system.  How
d85 1
a85 1
the version of the operating system.  Often the first implementation
d96 1
a96 1
its libraries.  In this model, the OS knows nothing about threads.  As
d100 2
a101 2
start.  The big disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all do.  Typical blocking activities
d104 1
a104 1
Kernel threads are the next step in thread evolution.  The OS knows
d107 2
a108 2
blocking.  With kernel threads, things that block a single thread don't
block other threads.  This is not the case with user-mode threads,
d114 1
a114 1
things.  Each process still has only one thread running at once,
d119 3
a121 3
program.  For example, something as simple as C<$a = $a + 2> can behave
unpredictably with kernel threads if $a is visible to other
threads, as another thread may have changed $a between the time it
d126 1
a126 1
support.  With multiprocessor kernel threads on a machine with multiple
d131 1
a131 1
since more than one thread will be executing at the same time.  As a
d141 3
a143 3
if one of two things happen.  If a thread calls a yield function, it
gives up control.  It also gives up control if the thread does
something that would cause it to block, such as perform I/O.  In a
d148 1
a148 1
while the system decides which thread should run next.  In a preemptive
d159 1
a159 1
find that things aren't quite what you expect.  It's very important to
d162 1
a162 1
DecThreads, or Java's Green threads, or Win32 threads.  There are
d165 1
a165 1
disappointed or confused.  Possibly both.
d168 3
a170 3
everything that's ever come before--they're not.  Perl's threading
model owes a lot to other thread models, especially POSIX.  Just as
Perl is not C, though, Perl threads are not POSIX threads.  So if you
d178 2
a179 2
substantially.  There are implications for people who write
modules--especially modules with XS code or external libraries.  While
d186 2
a187 2
otherwise.  This includes modules that are distributed as part of the
core.  Threads are a beta feature, and even some of the standard
d192 1
a192 1
discipline to control access to the module.  Semaphores are covered
d198 2
a199 2
threaded programs.  In the following sections we'll cover the basics,
showing you what you need to do to create a threaded program.   After
d211 1
a211 1
should be treated as such.   You should expect that it may not function
d240 1
a240 1
module.  In our example above, that's what MyMod_threaded is, and it's
d246 1
a246 1
threads.  Like any other module, you need to tell Perl you want to use
d261 1
a261 1
thread, which starts executing in the referenced subroutine.  Control
d265 1
a265 1
part of the thread startup.  Just include the list of parameters as
d284 2
a285 2
The last example illustrates another feature of threads.  You can spawn
off several threads using the same subroutine.  Each thread executes
d308 2
a309 2
Thread::async.  You'll also note that there's a semicolon after the
closing brace.  That's because async() treats the following block as an
d313 2
a314 2
weren't spun off.  Since both the code inside and after the async start
executing, you need to be careful with any shared resources.  Locking
d320 1
a320 1
explicitly give up the CPU to another thread.  Your threading package
d323 1
a323 1
that the user-interface thread gets called frequently.  Regardless,
d347 1
a347 1
Since threads are also subroutines, they can return values.  To wait
d360 1
a360 1
ends.  In addition to waiting for a thread to finish and gathering up
d364 1
a364 1
threads.  If you don't want the return values and don't want to wait
d372 1
a372 1
joined.  If your program never joins, the errors appear when your
d392 2
a393 2
join() does three things: it waits for a thread to exit, cleans up
after it, and returns any data the thread may have produced.  But what
d398 1
a398 1
In this case, you use the detach() method.  Once a thread is detached,
d424 1
a424 1
topic: data.  Threading introduces a couple of complications to data
d431 1
a431 1
program.  While this is true with a nonthreaded Perl program as well,
d437 5
a441 5
you weren't running with threads, it can see it if you are.  This is
especially important for the subroutines that create, and makes C<my>
variables even more important.  Remember--if your variables aren't
lexically scoped (declared with C<my>) you're probably sharing them
between threads.
d446 1
a446 1
number of pitfalls.  One pitfall is the race condition:
d461 1
a461 1
to read and once to write.  Depending on factors ranging from your
d466 1
a466 1
data.  Without explicit synchronization, there's no way to be sure that
d468 1
a468 1
and the time you update it.  Even this simple code fragment has the
d476 2
a477 2
Two threads both access $a.  Each thread can potentially be interrupted
at any point, or be executed in any order.  At the end, $a could be 3
d487 1
a487 1
that later) and puts a lock on it.  No other thread may lock the
d489 1
a489 1
the lock.  Using lock() is straightforward:
d516 1
a516 1
available.  When lock() returns, your thread can be sure that no other
d521 1
a521 1
in question, only lock attempts.  This is in keeping with Perl's
d523 2
a524 2
locking that flock() gives you.  Locked subroutines behave differently,
however.  We'll cover that later in the article.
d526 1
a526 1
You may lock arrays and hashes as well as scalars.  Locking an array,
d531 1
a531 1
lock a variable more than once.  The lock will last until the outermost
d536 3
a538 3
Locks are a handy tool to synchronize access to data.  Using them
properly is the key to safe shared data.  Unfortunately, locks aren't
without their dangers.  Consider the following code:
d556 1
a556 1
This program will probably hang until you kill it.  The only way it
d558 1
a558 1
first.  A guaranteed-to-hang version is more complicated, but the
d562 2
a563 2
second or two later, try to grab a lock on $b.  Meanwhile, the second
thread grabs a lock on $b, then later tries to grab a lock on $a.  The
d569 2
a570 2
own.  Each thread will block, waiting for the other to release a lock
on a resource.  That never happens, though, since the thread with the
d573 1
a573 1
There are a number of ways to handle this sort of problem.  The best
d575 2
a576 2
order.  If, for example, you lock variables $a, $b, and $c, always lock
$a before $b, and $b before $c.  It's also best to hold on to locks for
d583 1
a583 1
synchronization issues.  They're pretty straightforward, and look like
d602 1
a602 1
You create the queue with new Thread::Queue.  Then you can add lists of
d604 1
a604 1
it with dequeue().  A queue has no fixed size, and can grow as needed
d608 1
a608 1
something.  This makes queues ideal for event loops and other
d620 1
a620 1
Semaphores are a kind of generic locking mechanism.  Unlike lock, which
d623 1
a623 1
access to anything you like.  In addition, semaphores can allow more
d633 1
a633 1
semaphore's current count would decrement below zero.  This program
d662 1
a662 1
The three invocations of the subroutine all operate in sync.  The
d669 1
a669 1
down() them at a time.  However, there are other uses for semaphores.
d672 1
a672 1
counter and up() increments the counter.  By default, semaphores are
d674 2
a675 2
up() increments by one.  If down() attempts to decrement the counter
below zero, it blocks until the counter is large enough.  Note that
d683 1
a683 1
availability.  Many resources that you want to manage access for can be
d686 1
a686 1
For example, let's take a GUI driven program.  It has a semaphore that
d688 2
a689 2
ever drawing at once.  Handy, but of course you don't want any thread
to start drawing until things are properly set up.  In this case, you
d694 2
a695 2
establishing quotas.  Say, for example, that you have a number of
threads that can do I/O at once.  You don't want all the threads
d697 1
a697 1
your I/O channels, or deplete your process' quota of filehandles.  You
d710 1
a710 1
find it useful to synchronize access to subroutines.  You may be
d715 1
a715 1
One of the additions to Perl 5.005 is subroutine attributes.  The
d717 1
a717 1
serialization.  It's important to remember that these attributes are
d725 2
a726 1
    sub test_sub :locked { 
d730 1
a730 1
any one time.  Once a thread calls this subroutine, any other thread
d732 1
a732 1
it.  A more elaborate example looks like this:
d741 2
a742 1
    sub sync_sub :locked { 
d757 2
a758 2
The C<locked> attribute tells perl to lock sync_sub(), and if you run
this, you can see that only one thread is in it at any one time.
d763 1
a763 1
when dealing with Perl objects.  When calling a method for an object,
d766 1
a766 1
calling that subroutine for a different object aren't blocked.  The
d796 2
a797 1
    sub per_object :locked :method { 
d805 2
a806 1
    sub one_at_a_time :locked { 
d820 2
a821 2
You can lock a subroutine as you would lock a variable.  Subroutine locks
work the same as specifying a C<locked> attribute for the subroutine,
d823 1
a823 1
lock goes out of scope.  When the subroutine isn't locked, any number
d825 1
a825 1
doesn't affect threads already in the subroutine.  Getting a lock on a
d830 4
a833 4
Simple enough.  Unlike the C<locked> attribute, which is a compile time
option, locking and unlocking a subroutine can be done at runtime at your
discretion.  There is some runtime penalty to using lock(\&sub) instead
of the C<locked> attribute, so make sure you're choosing the proper
d838 1
a838 1
5.004 or earlier Perls.  In that case, it's useful to have subroutines
d858 1
a858 1
code and packages.  There are a few useful little pieces that didn't
d864 1
a864 1
object representing the thread it's currently in.  You can use this
d870 2
a871 2
thread the object represents.  Thread IDs are integers, with the main
thread in a program being 0.  Currently Perl assigns a unique tid to
d884 1
a884 1
that's currently running.  Handy for a number of things, including
d895 1
a895 1
The example above is just for illustration.  It isn't strictly
d902 1
a902 1
things we've covered.  This program finds prime numbers using threads.
d939 1
a939 1
This program uses the pipeline model to generate prime numbers.  Each
d942 1
a942 1
that it funnels numbers that have failed the check into.  If the thread
d944 1
a944 1
the thread must have found a new prime number.  In that case, a new
d955 1
a955 1
responsible for.  After pulling in the input queue and the prime that
d962 2
a963 2
for.  Line 24 checks to see if there's a remainder when we modulo the
number to be checked against our prime.  If there is one, the number
d968 1
a968 1
The new thread creation is line 29.  We pass on to it a reference to
d978 1
a978 1
2.  Then we queue all the numbers from 3 to 1000 for checking (lines
d980 1
a980 1
thread to terminate (line 17).  Because a child won't die until its
d983 1
a983 1
That's how it works.  It's pretty simple; as with many Perl programs,
d989 1
a989 1
but this should get you well on your way.  The final authority on how
d1049 1
a1049 1
polishing this article.  Big thanks to Tom Christiansen for his rewrite
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d721 1
a721 1
have a set of locks and semaphores.
d994 1
a994 1
Perl's threads behave is the documentation bundled with the Perl
d1032 1
a1032 1
1995, ISBN 0-13-219908-4 (great textbook).
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d7 11
a17 27
B<NOTE>: this tutorial describes the new Perl threading flavour
introduced in Perl 5.6.0 called interpreter threads, or B<ithreads>
for short.  In this model each thread runs in its own Perl interpreter,
and any data sharing between threads must be explicit.

There is another older Perl threading flavour called the 5.005 model,
unsurprisingly for 5.005 versions of Perl.  The old model is known to
have problems, deprecated, and will probably be removed around release
5.10. You are strongly encouraged to migrate any existing 5.005
threads code to the new model as soon as possible.

You can see which (or neither) threading flavour you have by
running C<perl -V> and looking at the C<Platform> section.
If you have C<useithreads=define> you have ithreads, if you
have C<use5005threads=define> you have 5.005 threads.
If you have neither, you don't have any thread support built in.
If you have both, you are in trouble.

The user-level interface to the 5.005 threads was via the L<Threads>
class, while ithreads uses the L<threads> class. Note the change in case.

=head1 Status

The ithreads code has been available since Perl 5.6.0, and is considered
stable. The user-level interface to ithreads (the L<threads> classes)
appeared in the 5.8.0 release, and as of this time is considered stable
although it should be treated with caution as with all new features.
d27 1
a27 1
thread.  With 5.8, though, you can create extra threads.  We're going
d100 1
a100 1
There are three basic categories of threads: user-mode threads, kernel
d133 1
a133 1
Multiprocessor kernel threads are the final step in thread
d164 1
a164 1
=head1 What kind of threads are Perl threads?
d183 1
a183 7
However it is important to remember that Perl threads cannot magically
do things unless your operating systems threads allows it. So if your
system blocks the entire process on sleep(), Perl usually will as well.

Perl Threads Are Different.

=head1 Thread-Safe Modules
d186 5
a190 6
substantially. There are implications for people who write
modules with XS code or external libraries. However, since perl data is
not shared among threads by default, Perl modules stand a high chance of
being thread-safe or can be made thread-safe easily.  Modules that are not
tagged as thread-safe should be tested or code reviewed before being used
in production code.
d195 1
a195 1
core.  Threads are a new feature, and even some of the standard
a197 5
Even if a module is thread-safe, it doesn't mean that the module is optimized
to work well with threads. A module could possibly be rewritten to utilize
the new features in threaded Perl to increase performance in a threaded
environment.

d199 3
a201 6
can protect yourself by using it from one, and only one thread at all.
If you need multiple threads to access such a module, you can use semaphores and
lots of programming discipline to control access to it.  Semaphores
are covered in L</"Basic semaphores">.

See also L</"Thread-Safety of System Libraries">.
d205 1
a205 1
The core L<threads> module provides the basic functions you need to write
d208 1
a208 1
that, we'll go over some of the features of the L<threads> module that
d213 1
a213 1
Thread support is a Perl compile-time option - it's something that's
d218 7
d229 1
a229 1
    $Config{useithreads} or die "Recompile Perl with threads to run this program.";
d234 2
a235 2
    use Config;
    use MyMod;
d237 8
a244 10
    BEGIN {
        if ($Config{useithreads}) {
            # We have threads
            require MyMod_threaded;
           import MyMod_threaded;
        } else {
           require MyMod_unthreaded;
           import MyMod_unthreaded;
        }
    }
a250 11
=head2 A Note about the Examples

Although thread support is considered to be stable, there are still a number
of quirks that may startle you when you try out any of the examples below.
In a real situation, care should be taken that all threads are finished
executing before the program exits.  That care has B<not> been taken in these
examples in the interest of simplicity.  Running these examples "as is" will
produce error messages, usually caused by the fact that there are still
threads running when the program exits.  You should not be alarmed by this.
Future versions of Perl may fix this problem.

d253 3
a255 3
The L<threads> package provides the tools you need to create new
threads.  Like any other module, you need to tell Perl that you want to use
it; C<use threads> imports all the pieces you need to create basic
d258 1
a258 1
The simplest, most straightforward way to create a thread is with new():
d260 1
a260 1
    use threads; 
d262 1
a262 1
    $thr = threads->new(\&sub1);
d274 1
a274 3
part of the C<threads::new> call, like this:

    use threads; 
d276 1
d278 3
a280 3
    $thr = threads->new(\&sub1, "Param 1", "Param 2", $Param3); 
    $thr = threads->new(\&sub1, @@ParamList); 
    $thr = threads->new(\&sub1, qw(Param1 Param2 Param3));
d289 3
d297 27
a323 1
C<create()> is a synonym for C<new()>.
d330 1
a330 1
you may be doing something processor-intensive and want to make sure
d337 15
a351 20
    use threads; 

    sub loop {
	    my $thread = shift;
	    my $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
	    threads->yield;
	    $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
    }

    my $thread1 = threads->new(\&loop, 'first');
    my $thread2 = threads->new(\&loop, 'second');
    my $thread3 = threads->new(\&loop, 'third');

It is important to remember that yield() is only a hint to give up the CPU,
it depends on your hardware, OS and threading libraries what actually happens.
Therefore it is important to note that one should not build the scheduling of 
the threads around yield() calls. It might work on your platform but it won't
work on another platform.
d356 2
a357 4
for a thread to exit and extract any values it might return, you can
use the join() method:

    use threads; 
d359 2
a360 1
    $thr = threads->new(\&sub1);
d374 23
a396 1
instead, as described next.
d410 2
a411 3
    use threads; 

    $thr = threads->new(\&sub1); # Spawn the thread
d415 1
a415 1
    sub sub1 {
d424 3
a426 2
Once a thread is detached, it may not be joined, and any return data
that it might have produced (if it was done and waiting for a join) is
d437 13
a449 50
The biggest difference between Perl ithreads and the old 5.005 style
threading, or for that matter, to most other threading systems out there,
is that by default, no data is shared. When a new perl thread is created,
all the data associated with the current thread is copied to the new
thread, and is subsequently private to that new thread!
This is similar in feel to what happens when a UNIX process forks,
except that in this case, the data is just copied to a different part of
memory within the same process rather than a real fork taking place.

To make use of threading however, one usually wants the threads to share
at least some data between themselves. This is done with the
L<threads::shared> module and the C< : shared> attribute:

    use threads;
    use threads::shared;

    my $foo : shared = 1;
    my $bar = 1;
    threads->new(sub { $foo++; $bar++ })->join;

    print "$foo\n";  #prints 2 since $foo is shared
    print "$bar\n";  #prints 1 since $bar is not shared

In the case of a shared array, all the array's elements are shared, and for
a shared hash, all the keys and values are shared. This places
restrictions on what may be assigned to shared array and hash elements: only
simple values or references to shared variables are allowed - this is
so that a private variable can't accidentally become shared. A bad
assignment will cause the thread to die. For example:

    use threads;
    use threads::shared;

    my $var           = 1;
    my $svar : shared = 2;
    my %hash : shared;

    ... create some threads ...

    $hash{a} = 1;	# all threads see exists($hash{a}) and $hash{a} == 1
    $hash{a} = $var	# okay - copy-by-value: same effect as previous
    $hash{a} = $svar	# okay - copy-by-value: same effect as previous
    $hash{a} = \$svar	# okay - a reference to a shared variable
    $hash{a} = \$var	# This will die
    delete $hash{a}	# okay - all threads will see !exists($hash{a})

Note that a shared variable guarantees that if two or more threads try to
modify it at the same time, the internal state of the variable will not
become corrupted. However, there are no guarantees beyond this, as
explained in the next section.
d451 1
a451 1
=head2 Thread Pitfalls: Races
d456 4
a459 2
    use threads; 
    use threads::shared;
d461 1
a461 6
    my $a : shared = 1; 
    $thr1 = threads->new(\&sub1); 
    $thr2 = threads->new(\&sub2); 

    $thr1->join;
    $thr2->join;
d464 2
a465 2
    sub sub1 { my $foo = $a; $a = $foo + 1; }
    sub sub2 { my $bar = $a; $a = $bar + 1; }
d479 4
a482 8
    use threads; 
    my $a : shared = 2;
    my $b : shared;
    my $c : shared;
    my $thr1 = threads->create(sub { $b = $a; $a = $b + 1; }); 
    my $thr2 = threads->create(sub { $c = $a; $a = $c + 1; });
    $thr1->join;
    $thr2->join;
a487 2
Even C<$a += 5> or C<$a++> are not guaranteed to be atomic.

d490 1
a490 12
data inconsistency and race conditions. Note that Perl will protect its
internals from your race conditions, but it won't protect you from you.

=head1 Synchronization and control

Perl provides a number of mechanisms to coordinate the interactions
between themselves and their data, to avoid race conditions and the like.
Some of these are designed to resemble the common techniques used in thread
libraries such as C<pthreads>; others are Perl-specific. Often, the
standard techniques are clumsy and difficult to get right (such as
condition waits). Where possible, it is usually easier to use Perlish
techniques such as queues, which remove some of the hard work involved.
d494 28
a521 33
The lock() function takes a shared variable and puts a lock on it.  
No other thread may lock the variable until the the variable is unlocked
by the thread holding the lock. Unlocking happens automatically
when the locking thread exits the outermost block that contains
C<lock()> function.  Using lock() is straightforward: this example has
several threads doing some calculations in parallel, and occasionally
updating a running total:

    use threads;
    use threads::shared;

    my $total : shared = 0;

    sub calc {
	for (;;) {
	    my $result;
	    # (... do some calculations and set $result ...)
	    {
		lock($total); # block until we obtain the lock
		$total += $result;
	    } # lock implicitly released at end of scope
	    last if $result == 0;
	}
    }

    my $thr1 = threads->new(\&calc);
    my $thr2 = threads->new(\&calc);
    my $thr3 = threads->new(\&calc);
    $thr1->join;
    $thr2->join;
    $thr3->join;
    print "total=$total\n";

d525 1
a525 1
thread can lock that variable until the outermost block containing the
d531 2
a532 1
locking that flock() gives you.  
d538 1
a538 1
Locks are recursive, which means it's okay for a thread to
d540 1
a540 4
lock() on the variable goes out of scope. For example:

    my $x : shared;
    doit();
d542 1
a542 15
    sub doit {
	{
	    {
		lock($x); # wait for lock
		lock($x); # NOOP - we already have the lock
		{
		    lock($x); # NOOP
		    {
			lock($x); # NOOP
			lockit_some_more();
		    }
		}
	    } # *** implicit unlock here ***
	}
    }
d544 1
a544 17
    sub lockit_some_more {
	lock($x); # NOOP
    } # nothing happens here

Note that there is no unlock() function - the only way to unlock a
variable is to allow it to go out of scope.  

A lock can either be used to guard the data contained within the variable
being locked, or it can be used to guard something else, like a section
of code. In this latter case, the variable in question does not hold any
useful data, and exists only for the purpose of being locked. In this
respect, the variable behaves like the mutexes and basic semaphores of
traditional thread libraries.

=head2 A Thread Pitfall: Deadlocks

Locks are a handy tool to synchronize access to data, and using them
d546 1
a546 4
without their dangers, especially when multiple locks are involved.
Consider the following code:

    use threads; 
d548 4
a551 3
    my $a : shared = 4; 
    my $b : shared = "foo"; 
    my $thr1 = threads->new(sub { 
d553 1
a553 1
        threads->yield; 
d555 3
d559 1
a559 4
    }); 
    my $thr2 = threads->new(sub { 
        lock($b); 
        threads->yield; 
d561 2
a562 2
        lock($a); 
    });
d565 1
a565 1
won't hang is if one of the two threads acquires both locks
d569 5
a573 5
The first thread will grab a lock on $a, then, after a pause during which
the second thread has probably had time to do some work, try to grab a
lock on $b.  Meanwhile, the second thread grabs a lock on $b, then later
tries to grab a lock on $a.  The second lock attempt for both threads will
block, each waiting for the other to release its lock.
a586 3
The other synchronization primitives described below can suffer from
similar problems.

d594 1
a594 1
    use threads; 
d597 2
a598 2
    my $DataQueue = Thread::Queue->new; 
    $thr = threads->new(sub { 
d602 1
a602 1
    }); 
a608 1
    $thr->join;
d610 4
a613 4
You create the queue with C<new Thread::Queue>.  Then you can
add lists of scalars onto the end with enqueue(), and pop scalars off
the front of it with dequeue().  A queue has no fixed size, and can grow
as needed to hold everything pushed on to it.
d619 7
d628 8
a635 5
Semaphores are a kind of generic locking mechanism. In their most basic
form, they behave very much like lockable scalars, except that thay
can't hold data, and that they must be explicitly unlocked. In their
advanced form, they act like a kind of counter, and can allow multiple
threads to have the 'lock' at any one time.
d637 1
a637 1
=head2 Basic semaphores
d639 2
a640 2
Semaphores have two methods, down() and up(): down() decrements the resource
count, while up increments it. Calls to down() will block if the
d644 1
a644 1
    use threads qw(yield); 
a645 1

d647 1
a647 1
    my $GlobalVariable : shared = 0;
d649 3
a651 3
    $thr1 = new threads \&sample_sub, 1; 
    $thr2 = new threads \&sample_sub, 2; 
    $thr3 = new threads \&sample_sub, 3;
a669 4
    $thr1->join;
    $thr2->join;
    $thr3->join;

d674 1
a674 1
=head2 Advanced Semaphores
d679 8
a686 27
Each semaphore has a counter attached to it. By default, semaphores are
created with the counter set to one, down() decrements the counter by
one, and up() increments by one. However, we can override any or all
of these defaults simply by passing in different values:

    use threads;
    use Thread::Semaphore;
    my $semaphore = Thread::Semaphore->new(5);
                    # Creates a semaphore with the counter set to five

    $thr1 = threads->new(\&sub1);
    $thr2 = threads->new(\&sub1);

    sub sub1 {
        $semaphore->down(5); # Decrements the counter by five
        # Do stuff here
        $semaphore->up(5); # Increment the counter by five
    }

    $thr1->detach;
    $thr2->detach;

If down() attempts to decrement the counter below zero, it blocks until
the counter is large enough.  Note that while a semaphore can be created
with a starting count of zero, any up() or down() always changes the
counter by at least one, and so $semaphore->down(0) is the same as
$semaphore->down(1).
d713 132
a844 1
=head2 cond_wait() and cond_signal()
d846 11
a856 5
These two functions can be used in conjunction with locks to notify
co-operating threads that a resource has become available. They are
very similar in use to the functions found in C<pthreads>. However
for most purposes, queues are simpler to use and more intuitive. See
L<threads::shared> for more details.
d867 3
a869 3
The C<< threads->self >> class method provides your program with a way to
get an object representing the thread it's currently in.  You can use this
object in the same way as the ones returned from thread creation.
a884 3
Thread objects also have an overloaded == comparison so that you can do
comparison on them as you would with normal objects.

d887 3
a889 3
C<< threads->list >> returns a list of thread objects, one for each thread
that's currently running and not detached.  Handy for a number of things,
including cleaning up at the end of your program:
d892 1
a892 1
    foreach $thr (threads->list) { 
d894 1
a894 1
        if ($thr->tid && !threads::equal($thr, threads->self)) { 
d899 3
a901 3
If some threads have not finished running when the main Perl thread
ends, Perl will warn you about it and die, since it is impossible for Perl
to clean up itself while other threads are running
d913 1
a913 1
    6  use threads;
d917 1
a917 1
    10 my $kid    = new threads(\&check_num, $stream, 2);
d924 1
a924 1
    17 $kid->join;
d936 1
a936 1
    29	              $kid = new threads(\&check_num, $downstream, $num);
d940 1
a940 1
    33     $kid->join		if $kid;
d946 1
a946 1
into which it funnels numbers that have failed the check.  If the thread
d952 1
a952 1
This probably sounds a bit more confusing than it really is, so let's
d977 1
a977 1
child and wait for it to exit if we've created a child (lines 32 and
a989 61
=head1 Performance considerations

The main thing to bear in mind when comparing ithreads to other threading
models is the fact that for each new thread created, a complete copy of
all the variables and data of the parent thread has to be taken. Thus
thread creation can be quite expensive, both in terms of memory usage and
time spent in creation. The ideal way to reduce these costs is to have a
relatively short number of long-lived threads, all created fairly early
on -  before the base thread has accumulated too much data. Of course, this
may not always be possible, so compromises have to be made. However, after
a thread has been created, its performance and extra memory usage should
be little different than ordinary code.

Also note that under the current implementation, shared variables
use a little more memory and are a little slower than ordinary variables.

=head1 Process-scope Changes

Note that while threads themselves are separate execution threads and
Perl data is thread-private unless explicitly shared, the threads can
affect process-scope state, affecting all the threads.

The most common example of this is changing the current working
directory using chdir().  One thread calls chdir(), and the working
directory of all the threads changes.

Even more drastic example of a process-scope change is chroot():
the root directory of all the threads changes, and no thread can
undo it (as opposed to chdir()).

Further examples of process-scope changes include umask() and
changing uids/gids.

Thinking of mixing fork() and threads?  Please lie down and wait
until the feeling passes-- but in case you really want to know,
the semantics is that fork() duplicates all the threads.
(In UNIX, at least, other platforms will do something different.)

Similarly, mixing signals and threads should not be attempted.
Implementations are platform-dependent, and even the POSIX
semantics may not be what you expect (and Perl doesn't even
give you the full POSIX API).

=head1 Thread-Safety of System Libraries

Whether various library calls are thread-safe is outside the control
of Perl.  Calls often suffering from not being thread-safe include:
localtime(), gmtime(), get{gr,host,net,proto,serv,pw}*(), readdir(),
rand(), and srand() -- in general, calls that depend on some global
external state.

If the system Perl is compiled in has thread-safe variants of such
calls, they will be used.  Beyond that, Perl is at the mercy of
the thread-safety or -unsafety of the calls.  Please consult your
C library call documentation.

In some platforms the thread-safe interfaces may fail if the result
buffer is too small (for example getgrent() may return quite large
group member lists).  Perl will retry growing the result buffer
a few times, but only up to 64k (for safety reasons).

d993 4
a996 2
but with what we've covered in this introduction, you should be well
on your way to becoming a threaded Perl expert.
d1007 2
a1008 2
http://gatekeeper.dec.com/pub/DEC/SRC/research-reports/abstracts/src-rr-035.html
(highly recommended)
a1041 3
comp.programming.threads FAQ,
L<http://www.serpentine.com/~bos/threads-faq/>

a1047 3
Artur Bergman, "Where Wizards Fear To Tread", June 11, 2002,
L<http://www.perl.com/pub/a/2002/06/11/threads.html>

d1058 1
a1058 6
Dan Sugalski E<lt>dan@@sidhe.org<gt>

Slightly modified by Arthur Bergman to fit the new thread model/module.

Reworked slightly by Jörg Walter E<lt>jwalt@@cpan.org<gt> to be more concise
about thread-safety of perl code.
d1062 4
a1065 4
The original version of this article originally appeared in The Perl
Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy
of Jon Orwant and The Perl Journal.  This document may be distributed
under the same terms as Perl itself.
a1066 1
For more information please see L<threads> and L<threads::shared>.
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d105 75
d334 33
d545 1
a545 1
No other thread may lock the variable until the variable is unlocked
d642 1
d648 1
d727 1
a727 1
    use threads;
d746 1
a827 33
=head2 Giving up control

There are times when you may find it useful to have a thread
explicitly give up the CPU to another thread.  You may be doing something
processor-intensive and want to make sure that the user-interface thread
gets called frequently.  Regardless, there are times that you might want
a thread to give up the processor.

Perl's threading package provides the yield() function that does
this. yield() is pretty straightforward, and works like this:

    use threads; 

    sub loop {
	    my $thread = shift;
	    my $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
	    threads->yield;
	    $foo = 50;
	    while($foo--) { print "in thread $thread\n" }
    }

    my $thread1 = threads->new(\&loop, 'first');
    my $thread2 = threads->new(\&loop, 'second');
    my $thread3 = threads->new(\&loop, 'third');

It is important to remember that yield() is only a hint to give up the CPU,
it depends on your hardware, OS and threading libraries what actually happens.
B<On many operating systems, yield() is a no-op.>  Therefore it is important
to note that one should not build the scheduling of the threads around
yield() calls. It might work on your platform but it won't work on another
platform.

a962 69
=head1 Different implementations of threads

Some background on thread implementations from the operating system
viewpoint.  There are three basic categories of threads: user-mode threads,
kernel threads, and multiprocessor kernel threads.

User-mode threads are threads that live entirely within a program and
its libraries.  In this model, the OS knows nothing about threads.  As
far as it's concerned, your process is just a process.

This is the easiest way to implement threads, and the way most OSes
start.  The big disadvantage is that, since the OS knows nothing about
threads, if one thread blocks they all do.  Typical blocking activities
include most system calls, most I/O, and things like sleep().

Kernel threads are the next step in thread evolution.  The OS knows
about kernel threads, and makes allowances for them.  The main
difference between a kernel thread and a user-mode thread is
blocking.  With kernel threads, things that block a single thread don't
block other threads.  This is not the case with user-mode threads,
where the kernel blocks at the process level and not the thread level.

This is a big step forward, and can give a threaded program quite a
performance boost over non-threaded programs.  Threads that block
performing I/O, for example, won't block threads that are doing other
things.  Each process still has only one thread running at once,
though, regardless of how many CPUs a system might have.

Since kernel threading can interrupt a thread at any time, they will
uncover some of the implicit locking assumptions you may make in your
program.  For example, something as simple as C<$a = $a + 2> can behave
unpredictably with kernel threads if $a is visible to other
threads, as another thread may have changed $a between the time it
was fetched on the right hand side and the time the new value is
stored.

Multiprocessor kernel threads are the final step in thread
support.  With multiprocessor kernel threads on a machine with multiple
CPUs, the OS may schedule two or more threads to run simultaneously on
different CPUs.

This can give a serious performance boost to your threaded program,
since more than one thread will be executing at the same time.  As a
tradeoff, though, any of those nagging synchronization issues that
might not have shown with basic kernel threads will appear with a
vengeance.

In addition to the different levels of OS involvement in threads,
different OSes (and different thread implementations for a particular
OS) allocate CPU cycles to threads in different ways.

Cooperative multitasking systems have running threads give up control
if one of two things happen.  If a thread calls a yield function, it
gives up control.  It also gives up control if the thread does
something that would cause it to block, such as perform I/O.  In a
cooperative multitasking implementation, one thread can starve all the
others for CPU time if it so chooses.

Preemptive multitasking systems interrupt threads at regular intervals
while the system decides which thread should run next.  In a preemptive
multitasking system, one thread usually won't monopolize the CPU.

On some systems, there can be cooperative and preemptive threads
running simultaneously. (Threads running with realtime priorities
often behave cooperatively, for example, while threads running at
normal priorities behave preemptively.)

Most modern operating systems support preemptive multitasking nowadays.

d1019 4
a1022 9
On some platforms the thread-safe library interfaces may fail if the
result buffer is too small (for example the user group databases may
be rather large, and the reentrant interfaces may have to carry around
a full snapshot of those databases).  Perl will start with a small
buffer, but keep retrying and growing the result buffer
until the result fits.  If this limitless growing sounds bad for
security or memory consumption reasons you can recompile Perl with
PERL_REENTRANT_MAXSIZE defined to the maximum number of bytes you will
allow.
a1102 3
Rearranged slightly by Elizabeth Mattijsen E<lt>liz@@dijkmat.nl<gt> to put
less emphasis on yield().

d1111 1
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d988 3
a990 4
until the feeling passes.  Be aware that the semantics of fork() vary
between platforms.  For example, some UNIX systems copy all the current
threads into the child process, while others only copy the thread that
called fork(). You have been warned!
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d605 1
a605 1
form, they behave very much like lockable scalars, except that they
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d55 2
a56 2
The boss/worker model usually has one "boss" thread and one or more
"worker" threads.  The boss thread gathers or generates tasks that need
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
perlthrtut - Tutorial on threads in Perl
d7 10
a16 11
This tutorial describes the use of Perl interpreter threads (sometimes
referred to as I<ithreads>) that was first introduced in Perl 5.6.0.  In this
model, each thread runs in its own Perl interpreter, and any data sharing
between threads must be explicit.  The user-level interface for I<ithreads>
uses the L<threads> class.

B<NOTE>: There was another older Perl threading flavor called the 5.005 model
that used the L<Threads> class.  This old model was known to have problems, is
deprecated, and was removed for release 5.10.  You are
strongly encouraged to migrate any existing 5.005 threads code to the new
model as soon as possible.
d25 9
a33 3
The L<threads> and L<threads::shared> modules are included in the core Perl
distribution.  Additionally, they are maintained as a separate modules on
CPAN, so you can check there for any updates.
d50 1
a50 1
to do.  For many non-trivial threaded programs, you'll need to choose
d55 2
a56 2
The boss/worker model usually has one I<boss> thread and one or more
I<worker> threads.  The boss thread gathers or generates tasks that need
d109 2
a110 2
remember when dealing with Perl threads that I<Perl Threads Are Not X
Threads> for all values of X.  They aren't POSIX threads, or
d117 1
a117 1
everything that's ever come before -- they're not.  Perl's threading
d124 3
a126 3
However, it is important to remember that Perl threads cannot magically
do things unless your operating system's threads allow it. So if your
system blocks the entire process on C<sleep()>, Perl usually will, as well.
d128 1
a128 1
B<Perl Threads Are Different.>
d134 1
a134 1
modules with XS code or external libraries. However, since Perl data is
d143 1
a143 1
core.  Threads are a relatively new feature, and even some of the standard
d161 2
a162 2
The L<threads> module provides the basic functions you need to write
threaded programs.  In the following sections, we'll cover the basics,
d169 1
a169 1
Thread support is a Perl compile-time option -- it's something that's
d178 1
a178 2
    use Config;
    $Config{useithreads} or die('Recompile Perl with threads to run this program.');
d190 1
a190 1
            import MyMod_threaded;
d192 2
a193 2
            require MyMod_unthreaded;
            import MyMod_unthreaded;
d199 1
a199 1
module.  In our example above, that's what C<MyMod_threaded> is, and it's
d204 2
d208 1
a208 1
examples in the interest of simplicity.  Running these examples I<as is> will
d211 1
d215 1
a215 1
The L<threads> module provides the tools you need to create new
d217 1
a217 1
it; C<use threads;> imports all the pieces you need to create basic
d220 1
a220 1
The simplest, most straightforward way to create a thread is with C<create()>:
d222 1
a222 1
    use threads;
d224 1
a224 1
    my $thr = threads->create(\&sub1);
d226 2
a227 2
    sub sub1 {
        print("In the thread\n");
d230 2
a231 2
The C<create()> method takes a reference to a subroutine and creates a new
thread that starts executing in the referenced subroutine.  Control
d236 1
a236 1
part of the C<threads-E<gt>create()> call, like this:
d238 1
a238 1
    use threads;
d240 10
a249 5
    my $Param3 = 'foo';
    my $thr1 = threads->create(\&sub1, 'Param 1', 'Param 2', $Param3);
    my @@ParamList = (42, 'Hello', 3.14);
    my $thr2 = threads->create(\&sub1, @@ParamList);
    my $thr3 = threads->create(\&sub1, qw(Param1 Param2 Param3));
a250 5
    sub sub1 {
        my @@InboundParameters = @@_;
        print("In the thread\n");
        print('Got parameters >', join('<>', @@InboundParameters), "<\n");
    }
d257 1
a257 1
C<new()> is a synonym for C<create()>.
d263 1
a263 1
use the C<join()> method:
d265 1
a265 1
    use threads;
d267 1
a267 1
    my ($thr) = threads->create(\&sub1);
d269 2
a270 2
    my @@ReturnData = $thr->join();
    print('Thread returned ', join(', ', @@ReturnData), "\n");
d272 1
a272 1
    sub sub1 { return ('Fifty-six', 'foo', 2); }
d274 1
a274 1
In the example above, the C<join()> method returns as soon as the thread
d276 1
a276 1
any values that the thread might have returned, C<join()> also performs
d280 1
a280 1
for the thread to finish, you should call the C<detach()> method
a282 5
NOTE: In the example above, the thread returns a list, thus necessitating
that the thread creation call be made in list context (i.e., C<my ($thr)>).
See L<threads/"$thr->join()"> and L<threads/"THREAD CONTEXT"> for more
details on thread context and return values.

d285 1
a285 1
C<join()> does three things: it waits for a thread to exit, cleans up
d291 2
a292 2
In this case, you use the C<detach()> method.  Once a thread is detached,
it'll run until it's finished; then Perl will clean up after it
d295 1
a295 1
    use threads;
d297 1
a297 1
    my $thr = threads->create(\&sub1);   # Spawn the thread
d299 1
a299 3
    $thr->detach();   # Now we officially don't care any more

    sleep(15);        # Let thread run for awhile
d302 6
a307 6
        $a = 0;
        while (1) {
            $a++;
            print("\$a is $a\n");
            sleep(1);
        }
a313 42
C<detach()> can also be called as a class method to allow a thread to
detach itself:

    use threads;

    my $thr = threads->create(\&sub1);

    sub sub1 {
        threads->detach();
        # Do more work
    }

=head2 Process and Thread Termination

With threads one must be careful to make sure they all have a chance to
run to completion, assuming that is what you want.

An action that terminates a process will terminate I<all> running
threads.  die() and exit() have this property,
and perl does an exit when the main thread exits,
perhaps implicitly by falling off the end of your code,
even if that's not what you want.

As an example of this case, this code prints the message
"Perl exited with active threads: 2 running and unjoined":

    use threads;
    my $thr1 = threads->new(\&thrsub, "test1");
    my $thr2 = threads->new(\&thrsub, "test2");
    sub thrsub {
       my ($message) = @@_;
       sleep 1;
       print "thread $message\n";
    }

But when the following lines are added at the end:

    $thr1->join;
    $thr2->join;

it prints two lines of output, a perhaps more useful outcome.

d317 1
a317 1
topic: Data.  Threading introduces a couple of complications to data
d322 1
a322 1
The biggest difference between Perl I<ithreads> and the old 5.005 style
d324 1
a324 1
is that by default, no data is shared. When a new Perl thread is created,
d331 1
a331 1
To make use of threading, however, one usually wants the threads to share
d333 1
a333 1
L<threads::shared> module and the C<:shared> attribute:
d338 1
a338 1
    my $foo :shared = 1;
d340 1
a340 1
    threads->create(sub { $foo++; $bar++; })->join();
d342 2
a343 2
    print("$foo\n");  # Prints 2 since $foo is shared
    print("$bar\n");  # Prints 1 since $bar is not shared
d355 3
a357 3
    my $var          = 1;
    my $svar :shared = 2;
    my %hash :shared;
d361 6
a366 6
    $hash{a} = 1;       # All threads see exists($hash{a}) and $hash{a} == 1
    $hash{a} = $var;    # okay - copy-by-value: same effect as previous
    $hash{a} = $svar;   # okay - copy-by-value: same effect as previous
    $hash{a} = \$svar;  # okay - a reference to a shared variable
    $hash{a} = \$var;   # This will die
    delete($hash{a});   # okay - all threads will see !exists($hash{a})
d378 1
a378 1
    use threads;
d381 3
a383 3
    my $a :shared = 1;
    my $thr1 = threads->create(\&sub1);
    my $thr2 = threads->create(\&sub2);
d387 1
a387 1
    print("$a\n");
d392 2
a393 2
What do you think C<$a> will be? The answer, unfortunately, is I<it
depends>. Both C<sub1()> and C<sub2()> access the global variable C<$a>, once
d396 1
a396 1
C<$a> can be 2 or 3.
d404 5
a408 5
    use threads;
    my $a :shared = 2;
    my $b :shared;
    my $c :shared;
    my $thr1 = threads->create(sub { $b = $a; $a = $b + 1; });
d413 3
a415 3
Two threads both access C<$a>.  Each thread can potentially be interrupted
at any point, or be executed in any order.  At the end, C<$a> could be 3
or 4, and both C<$b> and C<$c> could be 2 or 3.
d436 1
a436 1
The C<lock()> function takes a shared variable and puts a lock on it.
d439 2
a440 2
when the locking thread exits the block that contains the call to the
C<lock()> function.  Using C<lock()> is straightforward: This example has
d447 1
a447 1
    my $total :shared = 0;
d450 9
a458 9
        while (1) {
            my $result;
            # (... do some calculations and set $result ...)
            {
                lock($total);  # Block until we obtain the lock
                $total += $result;
            } # Lock implicitly released at end of scope
            last if $result == 0;
        }
d461 12
a472 11
    my $thr1 = threads->create(\&calc);
    my $thr2 = threads->create(\&calc);
    my $thr3 = threads->create(\&calc);
    $thr1->join();
    $thr2->join();
    $thr3->join();
    print("total=$total\n");

C<lock()> blocks the thread until the variable being locked is
available.  When C<lock()> returns, your thread can be sure that no other
thread can lock that variable until the block containing the
d478 1
a478 1
locking that C<flock()> gives you.
d486 1
a486 1
C<lock()> on the variable goes out of scope. For example:
d488 1
a488 1
    my $x :shared;
d492 13
a504 13
        {
            {
                lock($x); # Wait for lock
                lock($x); # NOOP - we already have the lock
                {
                    lock($x); # NOOP
                    {
                        lock($x); # NOOP
                        lockit_some_more();
                    }
                }
            } # *** Implicit unlock here ***
        }
d508 2
a509 2
        lock($x); # NOOP
    } # Nothing happens here
d511 2
a512 2
Note that there is no C<unlock()> function - the only way to unlock a
variable is to allow it to go out of scope.
d528 1
a528 1
    use threads;
d530 11
a540 11
    my $a :shared = 4;
    my $b :shared = 'foo';
    my $thr1 = threads->create(sub {
        lock($a);
        sleep(20);
        lock($b);
    });
    my $thr2 = threads->create(sub {
        lock($b);
        sleep(20);
        lock($a);
d548 1
a548 1
The first thread will grab a lock on C<$a>, then, after a pause during which
d550 2
a551 2
lock on C<$b>.  Meanwhile, the second thread grabs a lock on C<$b>, then later
tries to grab a lock on C<$a>.  The second lock attempt for both threads will
d562 2
a563 2
order.  If, for example, you lock variables C<$a>, C<$b>, and C<$c>, always lock
C<$a> before C<$b>, and C<$b> before C<$c>.  It's also best to hold on to locks for
d576 1
a576 1
    use threads;
d579 11
a589 10
    my $DataQueue = Thread::Queue->new();
    my $thr = threads->create(sub {
        while (my $DataElement = $DataQueue->dequeue()) {
            print("Popped $DataElement off the queue\n");
        }
    });

    $DataQueue->enqueue(12);
    $DataQueue->enqueue("A", "B", "C");
    sleep(10);
d591 1
a591 1
    $thr->join();
d593 3
a595 3
You create the queue with C<Thread::Queue-E<gt>new()>.  Then you can
add lists of scalars onto the end with C<enqueue()>, and pop scalars off
the front of it with C<dequeue()>.  A queue has no fixed size, and can grow
d598 1
a598 1
If a queue is empty, C<dequeue()> blocks until another thread enqueues
d608 1
a608 1
threads to have the I<lock> at any one time.
d612 2
a613 2
Semaphores have two methods, C<down()> and C<up()>: C<down()> decrements the resource
count, while C<up()> increments it. Calls to C<down()> will block if the
d618 1
a618 1
    use Thread::Semaphore;
d620 2
a621 2
    my $semaphore = Thread::Semaphore->new();
    my $GlobalVariable :shared = 0;
d623 18
a640 18
    $thr1 = threads->create(\&sample_sub, 1);
    $thr2 = threads->create(\&sample_sub, 2);
    $thr3 = threads->create(\&sample_sub, 3);

    sub sample_sub {
        my $SubNumber = shift(@@_);
        my $TryCount = 10;
        my $LocalCopy;
        sleep(1);
        while ($TryCount--) {
            $semaphore->down();
            $LocalCopy = $GlobalVariable;
            print("$TryCount tries left for sub $SubNumber (\$GlobalVariable is $GlobalVariable)\n");
            sleep(2);
            $LocalCopy++;
            $GlobalVariable = $LocalCopy;
            $semaphore->up();
        }
d643 3
a645 3
    $thr1->join();
    $thr2->join();
    $thr3->join();
d654 1
a654 1
C<down()> them at a time.  However, there are other uses for semaphores.
d657 2
a658 2
created with the counter set to one, C<down()> decrements the counter by
one, and C<up()> increments by one. However, we can override any or all
a662 1

d666 2
a667 2
    my $thr1 = threads->create(\&sub1);
    my $thr2 = threads->create(\&sub1);
d675 2
a676 2
    $thr1->detach();
    $thr2->detach();
d678 1
a678 1
If C<down()> attempts to decrement the counter below zero, it blocks until
d680 3
a682 3
with a starting count of zero, any C<up()> or C<down()> always changes the
counter by at least one, and so C<< $semaphore->down(0) >> is the same as
C<< $semaphore->down(1) >>.
d686 1
a686 1
decrement or increment it by more than one? The answer is resource
d709 1
a709 1
=head2 Waiting for a Condition
d711 1
a711 2
The functions C<cond_wait()> and C<cond_signal()>
can be used in conjunction with locks to notify
d725 2
a726 2
Perl's threading package provides the C<yield()> function that does
this. C<yield()> is pretty straightforward, and works like this:
d728 1
a728 1
    use threads;
d731 6
a736 6
        my $thread = shift;
        my $foo = 50;
        while($foo--) { print("In thread $thread\n"); }
        threads->yield();
        $foo = 50;
        while($foo--) { print("In thread $thread\n"); }
d739 3
a741 3
    my $thr1 = threads->create(\&loop, 'first');
    my $thr2 = threads->create(\&loop, 'second');
    my $thr3 = threads->create(\&loop, 'third');
d743 1
a743 1
It is important to remember that C<yield()> is only a hint to give up the CPU,
d747 1
a747 1
C<yield()> calls. It might work on your platform but it won't work on another
d759 1
a759 1
The C<threads-E<gt>self()> class method provides your program with a way to
d765 1
a765 1
C<tid()> is a thread object method that returns the thread ID of the
d767 1
a767 1
thread in a program being 0.  Currently Perl assigns a unique TID to
d769 2
a770 3
to be created a TID of 1, and increasing the TID by 1 for each new
thread that's created.  When used as a class method, C<threads-E<gt>tid()>
can be used by a thread to get its own TID.
d774 1
a774 1
The C<equal()> method takes two thread objects and returns true
d777 1
a777 1
Thread objects also have an overloaded C<==> comparison so that you can do
d782 1
a782 1
C<threads-E<gt>list()> returns a list of thread objects, one for each thread
d784 1
a784 2
including cleaning up at the end of your program (from the main Perl thread,
of course):
d786 6
a791 3
    # Loop through all the threads
    foreach my $thr (threads->list()) {
        $thr->join();
d796 1
a796 4
to clean up itself while other threads are running.

NOTE:  The main Perl thread (thread 0) is in a I<detached> state, and so
does not appear in the list returned by C<threads-E<gt>list()>.
d803 14
a816 14
     1 #!/usr/bin/perl
     2 # prime-pthread, courtesy of Tom Christiansen
     3
     4 use strict;
     5 use warnings;
     6
     7 use threads;
     8 use Thread::Queue;
     9
    10 my $stream = Thread::Queue->new();
    11 for my $i ( 3 .. 1000 ) {
    12     $stream->enqueue($i);
    13 }
    14 $stream->enqueue(undef);
d818 2
a819 2
    16 threads->create(\&check_num, $stream, 2);
    17 $kid->join();
d824 3
a826 3
    22     my $downstream = Thread::Queue->new();
    23     while (my $num = $upstream->dequeue()) {
    24         next unless ($num % $cur_prime);
d828 4
a831 4
    26             $downstream->enqueue($num);
    27         } else {
    28             print("Found prime $num\n");
    29             $kid = threads->create(\&check_num, $downstream, $num);
d833 4
a836 6
    31     }
    32     if ($kid) {
    33         $downstream->enqueue(undef);
    34         $kid->join();
    35     }
    36 }
d850 1
a850 1
number is, it's a number that's only evenly divisible by itself and 1.)
d852 1
a852 1
The bulk of the work is done by the C<check_num()> subroutine, which
d855 1
a855 1
the subroutine is checking (line 20), we create a new queue (line 22)
d861 2
a862 2
for.  Line 24 checks to see if there's a remainder when we divide the
number to be checked by our prime.  If there is one, the number
d870 2
a871 2
Finally, once the loop terminates (because we got a 0 or C<undef> in the
queue, which serves as a note to terminate), we pass on the notice to our
d873 1
a873 1
35).
d875 6
a880 7
Meanwhile, back in the main thread, we first create a queue (line 10) and
queue up all the numbers from 3 to 1000 for checking (lines 11-13),
plus a termination notice (line 14).  Then we create the initial child
threads (line 16), passing it the queue and the first prime: 2.  Finally,
we wait for the first child thread to terminate (line 17).  Because a
child won't terminate until its child has terminated, we know that we're
done once we return from the C<join()>.
d898 1
a898 1
include most system calls, most I/O, and things like C<sleep()>.
d916 2
a917 2
unpredictably with kernel threads if C<$a> is visible to other
threads, as another thread may have changed C<$a> between the time it
d956 1
a956 1
The main thing to bear in mind when comparing Perl's I<ithreads> to other threading
d958 1
a958 1
all the variables and data of the parent thread has to be taken. Thus,
d962 1
a962 1
on -- before the base thread has accumulated too much data. Of course, this
d977 1
a977 1
directory using C<chdir()>.  One thread calls C<chdir()>, and the working
d980 1
a980 1
Even more drastic example of a process-scope change is C<chroot()>:
d982 1
a982 1
undo it (as opposed to C<chdir()>).
d984 2
a985 2
Further examples of process-scope changes include C<umask()> and
changing uids and gids.
d987 2
a988 2
Thinking of mixing C<fork()> and threads?  Please lie down and wait
until the feeling passes.  Be aware that the semantics of C<fork()> vary
d991 1
a991 1
called C<fork()>. You have been warned!
d993 1
a993 1
Similarly, mixing signals and threads may be problematic.
d996 1
a996 5
give you the full POSIX API).  For example, there is no way to
guarantee that a signal sent to a multi-threaded Perl application
will get intercepted by any particular thread.  (However, a recently
added feature does provide the capability to send signals between
threads.  See L<threads/"THREAD SIGNALLING> for more details.)
d1002 2
a1003 4
C<localtime()>, C<gmtime()>,  functions fetching user, group and
network information (such as C<getgrent()>, C<gethostent()>,
C<getnetent()> and so on), C<readdir()>,
C<rand()>, and C<srand()> -- in general, calls that depend on some global
d1018 1
a1018 1
C<PERL_REENTRANT_MAXSIZE> defined to the maximum number of bytes you will
a1026 17
=head1 SEE ALSO

Annotated POD for L<threads>:
L<http://annocpan.org/?mode=search&field=Module&name=threads>

Lastest version of L<threads> on CPAN:
L<http://search.cpan.org/search?module=threads>

Annotated POD for L<threads::shared>:
L<http://annocpan.org/?mode=search&field=Module&name=threads%3A%3Ashared>

Lastest version of L<threads::shared> on CPAN:
L<http://search.cpan.org/search?module=threads%3A%3Ashared>

Perl threads mailing list:
L<http://lists.cpan.org/showlist.cgi?name=iThreads>

d1098 1
a1098 1
about thread-safety of Perl code.
d1110 1
a1110 1
=cut
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d351 2
a352 2
    $thr1->join();
    $thr2->join();
d427 2
a428 2
    $thr1->join();
    $thr2->join();
d452 2
a453 2
    $thr1->join();
    $thr2->join();
d856 27
a882 25
    10 sub check_num {
    11     my ($upstream, $cur_prime) = @@_;
    12     my $kid;
    13     my $downstream = Thread::Queue->new();
    14     while (my $num = $upstream->dequeue()) {
    15         next unless ($num % $cur_prime);
    16         if ($kid) {
    17             $downstream->enqueue($num);
    18         } else {
    19             print("Found prime: $num\n");
    20             $kid = threads->create(\&check_num, $downstream, $num);
    21             if (! $kid) {
    22                 warn("Sorry.  Ran out of threads.\n");
    23                 last;
    24             }
    25         }
    26     }
    27     if ($kid) {
    28         $downstream->enqueue(undef);
    29         $kid->join();
    30     }
    31 }
    32
    33 my $stream = Thread::Queue->new(3..1000, undef);
    34 check_num($stream, 2);
d901 1
a901 1
the subroutine is checking (line 11), we create a new queue (line 13)
d903 1
a903 1
(line 12).
d905 1
a905 1
The while loop from line 14 to line 26 grabs a scalar off the input
d907 1
a907 1
for.  Line 15 checks to see if there's a remainder when we divide the
d910 1
a910 1
it on to the next thread if we've created one (line 17) or create a
d913 2
a914 4
The new thread creation is line 20.  We pass on to it a reference to
the queue we've created, and the prime number we've found.  In lines 21
through 24, we check to make sure that our new thread got created, and
if not, we stop checking any remaining numbers in the queue.
d918 2
a919 2
child, and wait for it to exit if we've created a child (lines 27 and
30).
d921 7
a927 4
Meanwhile, back in the main thread, we first create a queue (line 33) and
queue up all the numbers from 3 to 1000 for checking, plus a termination
notice.  Then all we have to do to get the ball rolling is pass the queue
and the first prime to the C<check_num()> subroutine (line 34).
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d112 1
a112 1
everything that's ever come before. They're not.  Perl's threading
d164 1
a164 1
Thread support is a Perl compile-time option. It's something that's
d278 1
a278 1
See L<< threads/"$thr->join()" >> and L<threads/"THREAD CONTEXT"> for more
d369 1
a369 1
This is similar in feel to what happens when a Unix process forks,
d742 1
a742 1
your I/O channels, or deplete your process's quota of filehandles.  You
d1006 1
a1006 1
on (before the base thread has accumulated too much data). Of course, this
d1033 1
a1033 1
between platforms.  For example, some Unix systems copy all the current
d1052 3
a1054 2
C<getnetent()> and so on), C<readdir()>, C<rand()>, and C<srand()>. In
general, calls that depend on some global external state.
d1096 1
a1096 1
Here's a short bibliography courtesy of JÃ¼rgen Christoffel:
d1103 1
a1103 1
ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf
d1153 1
a1153 1
Sarathy, Ilya Zakharevich, Benjamin Sugars, JÃ¼rgen Christoffel, Joshua
d1164 1
a1164 1
Reworked slightly by JÃ¶rg Walter E<lt>jwalt@@cpan.org<gt> to be more concise
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a0 2
=encoding utf8

d14 1
a14 1
that used the L<threads> class.  This old model was known to have problems, is
d1044 1
a1044 1
threads.  See L<threads/THREAD SIGNALLING> for more details.)
d1081 1
a1081 1
Latest version of L<threads> on CPAN:
d1087 1
a1087 1
Latest version of L<threads::shared> on CPAN:
d1091 1
a1091 1
L<http://lists.perl.org/list/ithreads.html>
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d10 1
a10 1
referred to as I<ithreads>).  In this
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d176 1
a176 2
    $Config{useithreads} or
        die('Recompile Perl with threads to run this program.');
d244 1
a244 1
        print('Got parameters >', join('<>',@@InboundParameters), "<\n");
d405 1
a405 2
    $hash{a} = 1;       # All threads see exists($hash{a})
                        # and $hash{a} == 1
d677 1
a677 2
            print("$TryCount tries left for sub $SubNumber "
                 ."(\$GlobalVariable is $GlobalVariable)\n");
d849 34
a882 34
   1 #!/usr/bin/perl
   2 # prime-pthread, courtesy of Tom Christiansen
   3
   4 use strict;
   5 use warnings;
   6
   7 use threads;
   8 use Thread::Queue;
   9
  10 sub check_num {
  11     my ($upstream, $cur_prime) = @@_;
  12     my $kid;
  13     my $downstream = Thread::Queue->new();
  14     while (my $num = $upstream->dequeue()) {
  15         next unless ($num % $cur_prime);
  16         if ($kid) {
  17             $downstream->enqueue($num);
  18         } else {
  19             print("Found prime: $num\n");
  20             $kid = threads->create(\&check_num, $downstream, $num);
  21             if (! $kid) {
  22                 warn("Sorry.  Ran out of threads.\n");
  23                 last;
  24             }
  25         }
  26     }
  27     if ($kid) {
  28         $downstream->enqueue(undef);
  29         $kid->join();
  30     }
  31 }
  32
  33 my $stream = Thread::Queue->new(3..1000, undef);
  34 check_num($stream, 2);
@


1.1.1.15
log
@Import perl-5.20.2
@
text
@d305 1
a305 1
        my $count = 0;
d307 2
a308 2
            $count++;
            print("\$count is $count\n");
d427 1
a427 1
    my $x :shared = 1;
d433 1
a433 1
    print("$x\n");
d435 2
a436 2
    sub sub1 { my $foo = $x; $x = $foo + 1; }
    sub sub2 { my $bar = $x; $x = $bar + 1; }
d438 2
a439 2
What do you think C<$x> will be? The answer, unfortunately, is I<it
depends>. Both C<sub1()> and C<sub2()> access the global variable C<$x>, once
d442 1
a442 1
C<$x> can be 2 or 3.
d451 5
a455 5
    my $x :shared = 2;
    my $y :shared;
    my $z :shared;
    my $thr1 = threads->create(sub { $y = $x; $x = $y + 1; });
    my $thr2 = threads->create(sub { $z = $x; $x = $z + 1; });
d459 3
a461 3
Two threads both access C<$x>.  Each thread can potentially be interrupted
at any point, or be executed in any order.  At the end, C<$x> could be 3
or 4, and both C<$y> and C<$z> could be 2 or 3.
d463 1
a463 1
Even C<$x += 5> or C<$x++> are not guaranteed to be atomic.
d575 2
a576 2
    my $x :shared = 4;
    my $y :shared = 'foo';
d578 1
a578 1
        lock($x);
d580 1
a580 1
        lock($y);
d583 1
a583 1
        lock($y);
d585 1
a585 1
        lock($x);
d593 1
a593 1
The first thread will grab a lock on C<$x>, then, after a pause during which
d595 2
a596 2
lock on C<$y>.  Meanwhile, the second thread grabs a lock on C<$y>, then later
tries to grab a lock on C<$x>.  The second lock attempt for both threads will
d607 2
a608 2
order.  If, for example, you lock variables C<$x>, C<$y>, and C<$z>, always lock
C<$x> before C<$y>, and C<$y> before C<$z>.  It's also best to hold on to locks for
d964 3
a966 3
program.  For example, something as simple as C<$x = $x + 2> can behave
unpredictably with kernel threads if C<$x> is visible to other
threads, as another thread may have changed C<$x> between the time it
@


