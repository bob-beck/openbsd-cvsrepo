head	1.3;
access;
symbols
	PERL_5_24_2:1.1.1.9
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.04;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.31;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.15;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.34;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	1.1.1.9;
commitid	B31cAbBIXiCqnL97;

1.1.1.9
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@toke.c	AOK

    we seem to have lost a few ambiguous warnings!!

 
 		$a = <<;
 		Use of comma-less variable list is deprecated 
		(called 3 times via depcom)

     \1 better written as $1 
 	use warnings 'syntax' ;
 	s/(abc)/\1/;
 
     warn(warn_nosemi) 
     Semicolon seems to be missing
	$a = 1
	&time ;


     Reversed %c= operator 
	my $a =+ 2 ;
	$a =- 2 ;
	$a =* 2 ;
	$a =% 2 ;
	$a =& 2 ;
	$a =. 2 ;
	$a =^ 2 ;
	$a =| 2 ;
	$a =< 2 ;
	$a =/ 2 ;

     Multidimensional syntax %.*s not supported 
	my $a = $a[1,2] ;

     You need to quote \"%s\"" 
	sub fred {} ; $SIG{TERM} = fred;

     Can't use \\%c to mean $%c in expression 
	$_ = "ab" ; s/(ab)/\1/e;

     Unquoted string "abc" may clash with future reserved word at - line 3.
     warn(warn_reserved	
	$a = abc;

     Possible attempt to separate words with commas 
	@@a = qw(a, b, c) ;

     Possible attempt to put comments in qw() list 
	@@a = qw(a b # c) ;

     %s (...) interpreted as function 
	print ("")
	printf ("")
	sort ("")

     Ambiguous use of %c{%s%s} resolved to %c%s%s 
	$a = ${time[2]}
	$a = ${time{2}}


     Ambiguous use of %c{%s} resolved to %c%s
	$a = ${time}
	sub fred {} $a = ${fred}

     Misplaced _ in number 
	$a = 1_2;
	$a = 1_2345_6;

    Bareword \"%s\" refers to nonexistent package
	$a = FRED:: ;

    Ambiguous call resolved as CORE::%s(), qualify as such or use &
	sub time {} 
	my $a = time()

    Unrecognized escape \\%c passed through
        $a = "\m" ;

    Useless use of \\E.
        $a = "abcd\E" ;

    Postfix dereference is experimental

    %s number > %s non-portable
        my $a =  0b011111111111111111111111111111110 ;
        $a =  0b011111111111111111111111111111111 ;
        $a =  0b111111111111111111111111111111111 ;
        $a =  0x0fffffffe ;
        $a =  0x0ffffffff ;
        $a =  0x1ffffffff ;
        $a =  0037777777776 ;
        $a =  0037777777777 ;
        $a =  0047777777777 ;

    Integer overflow in binary number
        my $a =  0b011111111111111111111111111111110 ;
        $a =  0b011111111111111111111111111111111 ;
        $a =  0b111111111111111111111111111111111 ;
        $a =  0x0fffffffe ;
        $a =  0x0ffffffff ;
        $a =  0x1ffffffff ;
        $a =  0037777777776 ;
        $a =  0037777777777 ;
        $a =  0047777777777 ;

    dump() better written as CORE::dump()

    Use of /c modifier is meaningless without /g     

    Use of /c modifier is meaningless in s///

    Mandatory Warnings
    ------------------
    Use of "%s" without parentheses is ambiguous	[check_uni]
        rand + 4 

    Ambiguous use of -%s resolved as -&%s() 		[yylex]
        sub fred {} ; - fred ;

    Precedence problem: open %.*s should be open(%.*s)	[yylex]
    	open FOO || die;

    Operator or semicolon missing before %c%s		[yylex]
    Ambiguous use of %c resolved as operator %c
        *foo *foo

__END__
# toke.c 
format STDOUT =
@@<<<  @@|||  @@>>>  @@>>>
$a    $b    "abc" 'def'
.
no warnings 'deprecated' ;
format STDOUT =
@@<<<  @@|||  @@>>>  @@>>>
$a    $b    "abc" 'def'
.
EXPECT
Use of comma-less variable list is deprecated at - line 4.
Use of comma-less variable list is deprecated at - line 4.
Use of comma-less variable list is deprecated at - line 4.
########
# toke.c
$a = <<;

no warnings 'deprecated' ;
$a = <<;

EXPECT
Use of bare << to mean <<"" is deprecated at - line 2.
########
# toke.c
$a =~ m/$foo/eq;
$a =~ s/$foo/fool/seq;

EXPECT
OPTION fatal
Unknown regexp modifier "/e" at - line 2, near "=~ "
Unknown regexp modifier "/q" at - line 2, near "=~ "
Unknown regexp modifier "/q" at - line 3, near "=~ "
Execution of - aborted due to compilation errors.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
$a =~ m/$foo/e„Éçq;
$a =~ s/$foo/fool/se„Éçq;

EXPECT
OPTION fatal
Unknown regexp modifier "/e" at - line 4, near "=~ "
Unknown regexp modifier "/„Éç" at - line 4, near "=~ "
Unknown regexp modifier "/q" at - line 4, near "=~ "
Unknown regexp modifier "/„Éç" at - line 5, near "=~ "
Unknown regexp modifier "/q" at - line 5, near "=~ "
Execution of - aborted due to compilation errors.
########
# toke.c
use warnings 'syntax' ;
s/(abc)/\1/;
no warnings 'syntax' ;
s/(abc)/\1/;
EXPECT
\1 better written as $1 at - line 3.
########
# toke.c
use warnings 'semicolon' ;
$a = 1
&time ;
no warnings 'semicolon' ;
$a = 1
&time ;
EXPECT
Semicolon seems to be missing at - line 3.
########
# toke.c
use warnings 'syntax' ;
my $a =+ 2 ;
$a =- 2 ;
$a =* 2 ;
$a =% 2 ;
$a =& 2 ;
$a =. 2 ;
$a =^ 2 ;
$a =| 2 ;
$a =< 2 ;
$a =/ 2 ;
EXPECT
Reversed += operator at - line 3.
Reversed -= operator at - line 4.
Reversed *= operator at - line 5.
Reversed %= operator at - line 6.
Reversed &= operator at - line 7.
Reversed .= operator at - line 8.
Reversed ^= operator at - line 9.
Reversed |= operator at - line 10.
Reversed <= operator at - line 11.
syntax error at - line 8, near "=."
syntax error at - line 9, near "=^"
syntax error at - line 10, near "=|"
Unterminated <> operator at - line 11.
########
# toke.c
no warnings 'syntax' ;
my $a =+ 2 ;
$a =- 2 ;
$a =* 2 ;
$a =% 2 ;
$a =& 2 ;
$a =. 2 ;
$a =^ 2 ;
$a =| 2 ;
$a =< 2 ;
$a =/ 2 ;
EXPECT
syntax error at - line 8, near "=."
syntax error at - line 9, near "=^"
syntax error at - line 10, near "=|"
Unterminated <> operator at - line 11.
########
# toke.c
use warnings 'syntax' ;
my $a = $a[1,2] ;
no warnings 'syntax' ;
my $a = $a[1,2] ;
EXPECT
Multidimensional syntax $a[1,2] not supported at - line 3.
########
# toke.c
use warnings 'syntax' ;
sub fred {} ; $SIG{TERM} = fred;
no warnings 'syntax' ;
$SIG{TERM} = fred;
EXPECT
You need to quote "fred" at - line 3.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'syntax' ;
sub fr√®d {} ; $SIG{TERM} = fr√®d;
no warnings 'syntax' ;
$SIG{TERM} = fr√®d;
EXPECT
You need to quote "fr√®d" at - line 5.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'syntax' ;
sub „Åµ„Çå„Å© {} ; $SIG{TERM} = „Åµ„Çå„Å©;
no warnings 'syntax' ;
$SIG{TERM} = „Åµ„Çå„Å©;
EXPECT
You need to quote "„Åµ„Çå„Å©" at - line 5.
########
# toke.c
use warnings 'syntax' ;
$_ = "ab" ; 
s/(ab)/\1/e;
s//\(2)/e; # should be exempt
s/${\2}//; # same here
()="${\2}"; # metoo
no warnings 'syntax' ;
$_ = "ab" ; 
s/(ab)/\1/e;
EXPECT
Can't use \1 to mean $1 in expression at - line 4.
########
# toke.c
use warnings 'reserved' ;
$a = abc;
$a = { def

=> 1 };
no warnings 'reserved' ;
$a = abc;
EXPECT
Unquoted string "abc" may clash with future reserved word at - line 3.
########
# toke.c
use warnings 'qw' ;
@@a = qw(a, b, c) ;
no warnings 'qw' ;
@@a = qw(a, b, c) ;
EXPECT
Possible attempt to separate words with commas at - line 3.
########
# toke.c
use warnings 'qw' ;
@@a = qw(a b c # #) ;
no warnings 'qw' ;
@@a = qw(a b c # #) ;
EXPECT
Possible attempt to put comments in qw() list at - line 3.
########
# toke.c
use warnings 'qw' ;
@@a = qw(a, b, c # #) ;
no warnings 'qw' ;
@@a = qw(a, b, c # #) ;
EXPECT
Possible attempt to separate words with commas at - line 3.
Possible attempt to put comments in qw() list at - line 3.
########
# toke.c
use warnings 'syntax' ;
print ("");
print ("") and $x = 1;
print ("") or die;
print ("") // die;
print (1+2) * 3 if 0; # only this one should warn
print (1+2) if 0;
EXPECT
print (...) interpreted as function at - line 7.
########
# toke.c
no warnings 'syntax' ;
print ("")
EXPECT

########
# toke.c
use warnings 'syntax' ;
printf ("");
printf ("") . '';
EXPECT
printf (...) interpreted as function at - line 4.
########
# toke.c
no warnings 'syntax' ;
printf ("")
EXPECT

########
# toke.c
use warnings 'syntax' ;
sort ("");
sort ("") . '';
EXPECT
sort (...) interpreted as function at - line 4.
########
# toke.c
no warnings 'syntax' ;
sort ("")
EXPECT

########
# toke.c
use warnings 'ambiguous' ;
$a = ${time[2]};
no warnings 'ambiguous' ;
$a = ${time[2]};
EXPECT
Ambiguous use of ${time[...]} resolved to $time[...] at - line 3.
########
# toke.c
use warnings 'ambiguous' ;
$a = ${time{2}};
EXPECT
Ambiguous use of ${time{...}} resolved to $time{...} at - line 3.
########
# toke.c
use warnings 'ambiguous' ;
$a = ${

    time
        {2}
};
warn "after";
EXPECT
Ambiguous use of ${time{...}} resolved to $time{...} at - line 5.
after at - line 8.
########
# toke.c
use warnings 'ambiguous' ;
$a = ${

time[2]

};
$a = ${

time    
   [2]

};
warn "after";
EXPECT
Ambiguous use of ${time[...]} resolved to $time[...] at - line 5.
Ambiguous use of ${time[...]} resolved to $time[...] at - line 10.
after at - line 14.
########
# toke.c
no warnings 'ambiguous' ;
$a = ${time{2}};
EXPECT

########
# toke.c
use warnings 'ambiguous' ;
$a = ${time} ;
$a = @@{time} ;
$a = $#{time} ; # This one is special cased in toke.c
$a = %{time} ;
$a = *{time} ;
$a = defined &{time} ; # To avoid calling &::time
no warnings 'ambiguous' ;
$a = ${time} ;
$a = @@{time} ;
$a = $#{time} ; # This one is special cased in toke.c
$a = %{time} ;
$a = *{time} ;
$a = defined &{time} ; # To avoid calling &::time
EXPECT
Ambiguous use of ${time} resolved to $time at - line 3.
Ambiguous use of @@{time} resolved to @@time at - line 4.
Ambiguous use of @@{time} resolved to @@time at - line 5.
Ambiguous use of %{time} resolved to %time at - line 6.
Ambiguous use of *{time} resolved to *time at - line 7.
Ambiguous use of &{time} resolved to &time at - line 8.
########
# toke.c
use warnings 'ambiguous' ;
$a = ${
time
} ;
$a = @@{
time
} ;
$a = $#{
time
} ;
$a = %{
time
} ;
$a = *{
time
} ;
$a = defined &{
time


} ;
warn "last";
EXPECT
Ambiguous use of ${time} resolved to $time at - line 4.
Ambiguous use of @@{time} resolved to @@time at - line 7.
Ambiguous use of @@{time} resolved to @@time at - line 10.
Ambiguous use of %{time} resolved to %time at - line 13.
Ambiguous use of *{time} resolved to *time at - line 16.
Ambiguous use of &{time} resolved to &time at - line 19.
last at - line 23.
########
# toke.c
use warnings 'ambiguous' ;
sub fred {}
$a = ${fred} ;
no warnings 'ambiguous' ;
$a = ${fred} ;
EXPECT
Ambiguous use of ${fred} resolved to $fred at - line 4.
########
# toke.c
use warnings 'syntax' ;
$a = _123; print "$a\n";		#( 3	string)
$a = 1_23; print "$a\n";
$a = 12_3; print "$a\n";
$a = 123_; print "$a\n";		#  6
$a = _+123; print "$a\n";		#  7	string)
$a = +_123; print "$a\n";		#( 8	string)
$a = +1_23; print "$a\n";
$a = +12_3; print "$a\n";
$a = +123_; print "$a\n";		# 11
$a = _-123; print "$a\n";		#(12	string)
$a = -_123; print "$a\n";		#(13	string)
$a = -1_23; print "$a\n";
$a = -12_3; print "$a\n";
$a = -123_; print "$a\n";		# 16
$a = 123._456; print "$a\n";		# 17
$a = 123.4_56; print "$a\n";
$a = 123.45_6; print "$a\n";
$a = 123.456_; print "$a\n";		# 20
$a = +123._456; print "$a\n";		# 21
$a = +123.4_56; print "$a\n";	
$a = +123.45_6; print "$a\n";	
$a = +123.456_; print "$a\n";		# 24
$a = -123._456; print "$a\n";		# 25
$a = -123.4_56; print "$a\n";	
$a = -123.45_6; print "$a\n";
$a = -123.456_; print "$a\n";		# 28
$a = 123.456E_12; printf("%.0f\n", $a);	# 29
$a = 123.456E1_2; printf("%.0f\n", $a);
$a = 123.456E12_; printf("%.0f\n", $a);	# 31
$a = 123.456E_+12; printf("%.0f\n", $a);	# 32
$a = 123.456E+_12; printf("%.0f\n", $a);	# 33
$a = 123.456E+1_2; printf("%.0f\n", $a);
$a = 123.456E+12_; printf("%.0f\n", $a);	# 35
$a = 123.456E_-12; print "$a\n";	# 36
$a = 123.456E-_12; print "$a\n";	# 37
$a = 123.456E-1_2; print "$a\n";
$a = 123.456E-12_; print "$a\n";	# 39
$a = 1__23; print "$a\n";		# 40
$a = 12.3__4; print "$a\n";		# 41
$a = 12.34e1__2; printf("%.0f\n", $a);	# 42
no warnings 'syntax' ;
$a = _123; print "$a\n";
$a = 1_23; print "$a\n";
$a = 12_3; print "$a\n";
$a = 123_; print "$a\n";
$a = _+123; print "$a\n";
$a = +_123; print "$a\n";
$a = +1_23; print "$a\n";
$a = +12_3; print "$a\n";
$a = +123_; print "$a\n";
$a = _-123; print "$a\n";
$a = -_123; print "$a\n";
$a = -1_23; print "$a\n";
$a = -12_3; print "$a\n";
$a = -123_; print "$a\n";
$a = 123._456; print "$a\n";
$a = 123.4_56; print "$a\n";
$a = 123.45_6; print "$a\n";
$a = 123.456_; print "$a\n";
$a = +123._456; print "$a\n";
$a = +123.4_56; print "$a\n";
$a = +123.45_6; print "$a\n";
$a = +123.456_; print "$a\n";
$a = -123._456; print "$a\n";
$a = -123.4_56; print "$a\n";
$a = -123.45_6; print "$a\n";
$a = -123.456_; print "$a\n";
$a = 123.456E_12; printf("%.0f\n", $a);
$a = 123.456E1_2; printf("%.0f\n", $a);
$a = 123.456E12_; printf("%.0f\n", $a);
$a = 123.456E_+12; printf("%.0f\n", $a);
$a = 123.456E+_12; printf("%.0f\n", $a);
$a = 123.456E+1_2; printf("%.0f\n", $a);
$a = 123.456E+12_; printf("%.0f\n", $a);
$a = 123.456E_-12; print "$a\n";
$a = 123.456E-_12; print "$a\n";
$a = 123.456E-1_2; print "$a\n";
$a = 123.456E-12_; print "$a\n";
$a = 1__23; print "$a\n";
$a = 12.3__4; print "$a\n";
$a = 12.34e1__2; printf("%.0f\n", $a);
EXPECT
OPTIONS regex
Misplaced _ in number at - line 6.
Misplaced _ in number at - line 11.
Misplaced _ in number at - line 16.
Misplaced _ in number at - line 17.
Misplaced _ in number at - line 20.
Misplaced _ in number at - line 21.
Misplaced _ in number at - line 24.
Misplaced _ in number at - line 25.
Misplaced _ in number at - line 28.
Misplaced _ in number at - line 29.
Misplaced _ in number at - line 31.
Misplaced _ in number at - line 32.
Misplaced _ in number at - line 33.
Misplaced _ in number at - line 35.
Misplaced _ in number at - line 36.
Misplaced _ in number at - line 37.
Misplaced _ in number at - line 39.
Misplaced _ in number at - line 40.
Misplaced _ in number at - line 41.
Misplaced _ in number at - line 42.
_123
123
123
123
123
_123
123
123
123
-123
-_123
-123
-123
-123
123.456
123.456
123.456
123.456
123.456
123.456
123.456
123.456
-123.456
-123.456
-123.456
-123.456
123456000000000
123456000000000
123456000000000
123456000000000
123456000000000
123456000000000
123456000000000
1.23456e-0?10
1.23456e-0?10
1.23456e-0?10
1.23456e-0?10
123
12.34
12340000000000
_123
123
123
123
123
_123
123
123
123
-123
-_123
-123
-123
-123
123.456
123.456
123.456
123.456
123.456
123.456
123.456
123.456
-123.456
-123.456
-123.456
-123.456
123456000000000
123456000000000
123456000000000
123456000000000
123456000000000
123456000000000
123456000000000
1.23456e-0?10
1.23456e-0?10
1.23456e-0?10
1.23456e-0?10
123
12.34
12340000000000
########
# toke.c
use warnings 'bareword' ;
#line 25 "bar"
$a = FRED:: ;
no warnings 'bareword' ;
#line 25 "bar"
$a = FRED:: ;
EXPECT
Bareword "FRED::" refers to nonexistent package at bar line 25.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'bareword' ;
#line 25 "bar"
$a = FR√àD:: ;
no warnings 'bareword' ;
#line 25 "bar"
$a = FR√àD:: ;
EXPECT
Bareword "FR√àD::" refers to nonexistent package at bar line 25.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'bareword' ;
#line 25 "bar"
$a = œûœûœû:: ;
no warnings 'bareword' ;
#line 25 "bar"
$a = œûœûœû:: ;
EXPECT
Bareword "œûœûœû::" refers to nonexistent package at bar line 25.
########
# toke.c
use warnings 'ambiguous' ;
sub time {}
my $a = time() ;
no warnings 'ambiguous' ;
my $b = time() ;
EXPECT
Ambiguous call resolved as CORE::time(), qualify as such or use & at - line 4.
########
# toke.c
use warnings ;
eval <<'EOE';
#  line 30 "foo"
warn "yelp";
{
  $_ = " \x{123} " ;
}
EOE
EXPECT
yelp at foo line 30.
########
# toke.c
my $a = rand + 4 ;
$a = rand *^H ;
$a = rand $^H ;
EXPECT
Warning: Use of "rand" without parentheses is ambiguous at - line 2.
########
# toke.c
$^W = 0 ;
my $a = rand + 4 ;
{
    no warnings 'ambiguous' ;
    $a = rand + 4 ;
    use warnings 'ambiguous' ;
    $a = rand + 4 ;
}
$a = rand + 4 ;
EXPECT
Warning: Use of "rand" without parentheses is ambiguous at - line 3.
Warning: Use of "rand" without parentheses is ambiguous at - line 8.
Warning: Use of "rand" without parentheses is ambiguous at - line 10.
########
# [perl #97110]
sub myrand(;$) { }
sub whatever($) { }
my $a = myrand + 4 ;
my $b = whatever + 4 ;
EXPECT
Warning: Use of "myrand" without parentheses is ambiguous at - line 4.
########
# toke.c
use warnings "ambiguous";
print for keys %+; # should not warn
EXPECT
########
# toke.c [This does not warn any more.]
sub fred {};
-fred ;
sub hank : lvalue {$_}
--hank; # This should *not* warn [perl #77240]
EXPECT
########
# toke.c [This does not warn any more.]
$^W = 0 ;
sub fred {} ;
-fred ;
{
    no warnings 'ambiguous' ;
    -fred ;
    use warnings 'ambiguous' ;
    -fred ;
}
-fred ;
EXPECT
########
# toke.c [This does not warn any more.]
use utf8;
use open qw( :utf8 :std );
sub fr√®d {};
-fr√®d ;
EXPECT
########
# toke.c [This does not warn any more.]
$^W = 0 ;
use utf8;
use open qw( :utf8 :std );
sub fr√®d {} ;
-fr√®d ;
{
    no warnings 'ambiguous' ;
    -fr√®d ;
    use warnings 'ambiguous' ;
    -fr√®d ;
}
-fr√®d ;
EXPECT
########
# toke.c [This does not warn any more.]
use utf8;
use open qw( :utf8 :std );
sub ·íç·íò·íä {};
-·íç·íò·íä ;
EXPECT
########
# toke.c [This does not warn any more.]
$^W = 0 ;
use utf8;
use open qw( :utf8 :std );
sub ·íç·íò·íä {} ;
-·íç·íò·íä ;
{
    no warnings 'ambiguous' ;
    -·íç·íò·íä ;
    use warnings 'ambiguous' ;
    -·íç·íò·íä ;
}
-·íç·íò·íä ;
EXPECT
########
# toke.c
open FOO || time;
open local *FOO; # should be ok
EXPECT
Precedence problem: open FOO should be open(FOO) at - line 2.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
open F√í√í || time;
EXPECT
Precedence problem: open F√í√í should be open(F√í√í) at - line 4.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
open ·íçOO || time;
EXPECT
Precedence problem: open ·íçOO should be open(·íçOO) at - line 4.
########
# toke.c (and [perl #16184])
open FOO => "<&0"; close FOO;
EXPECT
########
# toke.c
$^W = 0 ;
open FOO || time;
{
    no warnings 'precedence' ;
    open FOO || time;
    use warnings 'precedence' ;
    open FOO || time;
}
open FOO || time;
open Foo::BAR; # this should not warn
EXPECT
Precedence problem: open FOO should be open(FOO) at - line 3.
Precedence problem: open FOO should be open(FOO) at - line 8.
Precedence problem: open FOO should be open(FOO) at - line 10.
########
# toke.c
$^W = 0 ;
use utf8;
use open qw( :utf8 :std );
open F√í√í || time;
{
    no warnings 'precedence' ;
    open F√í√í || time;
    use warnings 'precedence' ;
    open F√í√í || time;
}
open F√í√í || time;
EXPECT
Precedence problem: open F√í√í should be open(F√í√í) at - line 5.
Precedence problem: open F√í√í should be open(F√í√í) at - line 10.
Precedence problem: open F√í√í should be open(F√í√í) at - line 12.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
$^W = 0 ;
open ·íç√í√í || time;
{
    no warnings 'precedence' ;
    open ·íç√í√í || time;
    use warnings 'precedence' ;
    open ·íç√í√í || time;
}
open ·íç√í√í || time;
EXPECT
Precedence problem: open ·íç√í√í should be open(·íç√í√í) at - line 5.
Precedence problem: open ·íç√í√í should be open(·íç√í√í) at - line 10.
Precedence problem: open ·íç√í√í should be open(·íç√í√í) at - line 12.
########
# toke.c
$^W = 0 ;
*foo *foo ;
{
    no warnings 'ambiguous' ;
    *foo *foo ;
    use warnings 'ambiguous' ;
    *foo *foo ;
}
*foo *foo ;
# These should not warn [perl #117535]:
foo**foo ;
no warnings 'deprecated';
sort $*foo ;
sort $ *foo ;
EXPECT
Operator or semicolon missing before *foo at - line 3.
Ambiguous use of * resolved as operator * at - line 3.
Operator or semicolon missing before *foo at - line 8.
Ambiguous use of * resolved as operator * at - line 8.
Operator or semicolon missing before *foo at - line 10.
Ambiguous use of * resolved as operator * at - line 10.
########
# toke.c
$^W = 0 ;
%foo %foo ;
{
    no warnings 'ambiguous' ;
    %foo %foo ;
    use warnings 'ambiguous' ;
    %foo %foo ;
}
%foo %foo ;
# This should not produce ambiguity warnings [perl #117535]:
sort $%foo ;
sort $ %foo ;
EXPECT
Operator or semicolon missing before %foo at - line 3.
Ambiguous use of % resolved as operator % at - line 3.
Operator or semicolon missing before %foo at - line 8.
Ambiguous use of % resolved as operator % at - line 8.
Operator or semicolon missing before %foo at - line 10.
Ambiguous use of % resolved as operator % at - line 10.
Bareword found where operator expected at - line 12, near "$%foo"
	(Missing operator before foo?)
Bareword found where operator expected at - line 13, near "$ %foo"
	(Missing operator before foo?)
Illegal modulus zero at - line 3.
########
# toke.c
$^W = 0 ;
&foo &foo ;
{
    no warnings 'ambiguous' ;
    &foo &foo ;
    use warnings 'ambiguous' ;
    &foo &foo ;
}
&foo &foo ;
# These should not warn produce ambiguity warnings [perl #76910]:
foo&&foo ;
sort $&foo ;
sort $ &foo ;
EXPECT
Operator or semicolon missing before &foo at - line 3.
Ambiguous use of & resolved as operator & at - line 3.
Operator or semicolon missing before &foo at - line 8.
Ambiguous use of & resolved as operator & at - line 8.
Operator or semicolon missing before &foo at - line 10.
Ambiguous use of & resolved as operator & at - line 10.
Bareword found where operator expected at - line 13, near "$&foo"
	(Missing operator before foo?)
Bareword found where operator expected at - line 14, near "$ &foo"
	(Missing operator before foo?)
Undefined subroutine &main::foo called at - line 3.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
$^W = 0 ;
*ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
{
    no warnings 'ambiguous' ;
    *ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
    use warnings 'ambiguous' ;
    *ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
}
*ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
EXPECT
Operator or semicolon missing before *ÔΩÜÔΩèÔΩè at - line 5.
Ambiguous use of * resolved as operator * at - line 5.
Operator or semicolon missing before *ÔΩÜÔΩèÔΩè at - line 10.
Ambiguous use of * resolved as operator * at - line 10.
Operator or semicolon missing before *ÔΩÜÔΩèÔΩè at - line 12.
Ambiguous use of * resolved as operator * at - line 12.
########
# toke.c
use warnings 'misc' ;
my $a = "\m" ;
no warnings 'misc' ;
$a = "\m" ;
EXPECT
Unrecognized escape \m passed through at - line 3.
########
# toke.c
use warnings 'misc' ;
my $a = "abcd\E" ;
no warnings 'misc' ;
$a = "abcd\E" ;
EXPECT
Useless use of \E at - line 3.
########
# toke.c
use feature 'postderef_qq';
(\$_)->$*;
"$_->$*";
(\$_)->$*;
"$_->$*";
EXPECT
########
# toke.c
use warnings 'portable' ;
my $a =  0b011111111111111111111111111111110 ;
   $a =  0b011111111111111111111111111111111 ;
   $a =  0b111111111111111111111111111111111 ;
   $a =  0x0fffffffe ;
   $a =  0x0ffffffff ;
   $a =  0x1ffffffff ;
   $a =  0037777777776 ;
   $a =  0037777777777 ;
   $a =  0047777777777 ;
no warnings 'portable' ;
   $a =  0b011111111111111111111111111111110 ;
   $a =  0b011111111111111111111111111111111 ;
   $a =  0b111111111111111111111111111111111 ;
   $a =  0x0fffffffe ;
   $a =  0x0ffffffff ;
   $a =  0x1ffffffff ;
   $a =  0037777777776 ;
   $a =  0037777777777 ;
   $a =  0047777777777 ;
EXPECT
Binary number > 0b11111111111111111111111111111111 non-portable at - line 5.
Hexadecimal number > 0xffffffff non-portable at - line 8.
Octal number > 037777777777 non-portable at - line 11.
########
# toke.c
use warnings 'overflow' ;
my $a =  0b011111111111111111111111111111110 ;
   $a =  0b011111111111111111111111111111111 ;
   $a =  0b10000000000000000000000000000000000000000000000000000000000000000 ;
   $a =  0x0fffffffe ;
   $a =  0x0ffffffff ;
   $a =  0x10000000000000000 ;
   $a =  0037777777776 ;
   $a =  0037777777777 ;
   $a =  002000000000000000000000;
no warnings 'overflow' ;
   $a =  0b011111111111111111111111111111110 ;
   $a =  0b011111111111111111111111111111111 ;
   $a =  0b10000000000000000000000000000000000000000000000000000000000000000 ;
   $a =  0x0fffffffe ;
   $a =  0x0ffffffff ;
   $a =  0x10000000000000000 ;
   $a =  0037777777776 ;
   $a =  0037777777777 ;
   $a =  002000000000000000000000;
EXPECT
Integer overflow in binary number at - line 5.
Integer overflow in hexadecimal number at - line 8.
Integer overflow in octal number at - line 11.
########
# toke.c
BEGIN { $^C = 1; }
use warnings 'misc';
dump;
CORE::dump;
EXPECT
dump() better written as CORE::dump() at - line 4.
- syntax OK
########
# toke.c
use warnings 'misc';
use subs qw/dump/;
sub dump { print "no warning for overridden dump\n"; }
dump;
EXPECT
no warning for overridden dump
########
# toke.c
use warnings 'ambiguous';
"@@mjd_previously_unused_array";        
no warnings 'ambiguous';
"@@mjd_previously_unused_array2";        
EXPECT
Possible unintended interpolation of @@mjd_previously_unused_array in string at - line 3.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous';
"@@mjd_previously_unused_√†rray";        
no warnings 'ambiguous';
"@@mjd_previously_unused_√†rray2";        
EXPECT
Possible unintended interpolation of @@mjd_previously_unused_√†rray in string at - line 5.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous';
"@@mjd_previously_unused_„ÅÅrr„ÅÅy";        
no warnings 'ambiguous';
"@@mjd_previously_unused_„ÅÅrr„ÅÅy2";        
EXPECT
Possible unintended interpolation of @@mjd_previously_unused_„ÅÅrr„ÅÅy in string at - line 5.
########
# toke.c
# 20020328 mjd-perl-patch+@@plover.com at behest of jfriedl@@yahoo.com
use warnings 'regexp';
"foo" =~ /foo/c;
"foo" =~ /foo/cg;
no warnings 'regexp';
"foo" =~ /foo/c;
"foo" =~ /foo/cg;
EXPECT
Use of /c modifier is meaningless without /g at - line 4.
########
# toke.c
# 20020328 mjd-perl-patch+@@plover.com at behest of jfriedl@@yahoo.com
use warnings 'regexp';
$_ = "ab" ; 
s/ab/ab/c;
s/ab/ab/cg;
no warnings 'regexp';
s/ab/ab/c;
s/ab/ab/cg;
EXPECT
Use of /c modifier is meaningless in s/// at - line 5.
Use of /c modifier is meaningless in s/// at - line 6.
########
-wa
# toke.c
# 20020414 mjd-perl-patch+@@plover.com # -a flag should suppress these warnings
print "@@F\n";
EXPECT

########
-w
# toke.c
# 20020414 mjd-perl-patch+@@plover.com # -a flag should suppress these warnings
print "@@F\n";
EXPECT
Possible unintended interpolation of @@F in string at - line 4.
Name "main::F" used only once: possible typo at - line 4.
########
-wa
# toke.c
# 20020414 mjd-perl-patch+@@plover.com
EXPECT

########
# toke.c
# 20020414 mjd-perl-patch+@@plover.com
# In 5.7.3, this emitted "Possible unintended interpolation" warnings
use warnings 'ambiguous';
$s = "(@@-)(@@+)";
EXPECT

########
# toke.c
# mandatory warning
eval q/if ($a) { } elseif ($b) { }/;
no warnings "syntax";
eval q/if ($a) { } elseif ($b) { }/;
EXPECT
elseif should be elsif at (eval 1) line 1.
########
# toke.c
# mandatory warning
eval q/5 6/;
no warnings "syntax";
eval q/5 6/;
EXPECT
Number found where operator expected at (eval 1) line 1, near "5 6"
	(Missing operator before  6?)
########
# toke.c
use warnings "syntax"; no warnings "deprecated";
$_ = $a = 1;
$a !=~  /1/;
$a !=~ m#1#;
$a !=~/1/;
$a !=~ y/1//;
$a !=~ tr/1//;
$a !=~ s/1//;
$a != ~/1/;
no warnings "syntax";
$a !=~  /1/;
$a !=~ m#1#;
$a !=~/1/;
$a !=~ y/1//;
$a !=~ tr/1//;
$a !=~ s/1//;
EXPECT
!=~ should be !~ at - line 4.
!=~ should be !~ at - line 5.
!=~ should be !~ at - line 6.
!=~ should be !~ at - line 7.
!=~ should be !~ at - line 8.
!=~ should be !~ at - line 9.
########
# toke.c
our $foo :unique;
sub pam :locked;
sub glipp :locked {
}
sub whack_eth ($) : locked {
}
no warnings 'deprecated';
our $bar :unique;
sub zapeth :locked;
sub ker_plop :locked {
}
sub swa_a_p ($) : locked {
}
EXPECT
Use of :unique is deprecated at - line 2.
Use of :locked is deprecated at - line 3.
Use of :locked is deprecated at - line 4.
Use of :locked is deprecated at - line 6.
########
# toke.c
use warnings "syntax"; use feature 'lexical_subs';
sub proto_after_array(@@$);
sub proto_after_arref(\@@$);
sub proto_after_arref2(\[@@$]);
sub proto_after_arref3(\[@@$]_);
sub proto_after_hash(%$);
sub proto_after_hashref(\%$);
sub proto_after_hashref2(\[%$]);
sub underscore_last_pos($_);
sub underscore2($_;$);
sub underscore_fail($_$);
sub underscore_after_at(@@_);
our sub hour (@@$);
my sub migh (@@$);
use feature 'state';
state sub estate (@@$);
package other;
sub hour (@@$);
sub migh (@@$);
sub estate (@@$);
no warnings "syntax";
sub proto_after_array(@@$);
sub proto_after_hash(%$);
sub underscore_fail($_$);
EXPECT
Prototype after '@@' for main::proto_after_array : @@$ at - line 3.
Prototype after '%' for main::proto_after_hash : %$ at - line 7.
Illegal character after '_' in prototype for main::underscore_fail : $_$ at - line 12.
Prototype after '@@' for main::underscore_after_at : @@_ at - line 13.
The lexical_subs feature is experimental at - line 14.
Prototype after '@@' for hour : @@$ at - line 14.
The lexical_subs feature is experimental at - line 15.
Prototype after '@@' for migh : @@$ at - line 15.
The lexical_subs feature is experimental at - line 17.
Prototype after '@@' for estate : @@$ at - line 17.
Prototype after '@@' for hour : @@$ at - line 19.
Prototype after '@@' for migh : @@$ at - line 20.
Prototype after '@@' for estate : @@$ at - line 21.
########
# toke.c
use warnings "ambiguous";
"foo\nn" =~ /^foo$\n/;
"foo\nn" =~ /^foo${\}n/;
my $foo = qr/^foo$\n/;
my $bar = qr/^foo${\}n/;
no warnings "ambiguous";
"foo\nn" =~ /^foo$\n/;
"foo\nn" =~ /^foo${\}n/;
my $foo = qr/^foo$\n/;
my $bar = qr/^foo${\}n/;
EXPECT
Possible unintended interpolation of $\ in regex at - line 3.
Possible unintended interpolation of $\ in regex at - line 5.
########
# toke.c
use warnings 'syntax' ;
my $a = "\o";
my $a = "\o{";
my $a = "\o{}";
no warnings 'syntax' ;
my $a = "\o";
my $a = "\o{";
my $a = "\o{}";
EXPECT
Missing braces on \o{} at - line 3, within string
Missing right brace on \o{ at - line 4, within string
Number with no digits at - line 5, within string
BEGIN not safe after errors--compilation aborted at - line 6.
########
# toke.c
use warnings 'digit' ;
my $a = "\o{1238456}";
no warnings 'digit' ;
my $a = "\o{1238456}";
EXPECT
Non-octal character '8'.  Resolved as "\o{123}" at - line 3.
########
# toke.c
use warnings;
print ref ? "yes\n" : "no\n" foreach [], ''; # ? is unambiguosly an operator
EXPECT
yes
no
########
# toke .c
use warnings;
$a =~ ?rand?; # ? is not a regex match
EXPECT
syntax error at - line 3, near "=~ ?"
Execution of - aborted due to compilation errors.
########
# toke.c
BEGIN {
    if (ord('A') == 193) {
        print "SKIPPED\n# result varies depending on which ebcdic platform";
        exit 0;
    }
}
use warnings;
$a = "\c,";
$a = "\c`";
no warnings 'syntax';
$a = "\c,";
$a = "\c`";
EXPECT
"\c," is more clearly written simply as "l" at - line 9.
"\c`" is more clearly written simply as "\ " at - line 10.
########
# toke.c
BEGIN {
    if (ord('A') == 193) {
        print "SKIPPED\n# test is ASCII-specific";
        exit 0;
    }
}
use warnings;
my $a = "\c{ack}";
EXPECT
OPTION fatal
Use ";" instead of "\c{" at - line 9.
########
# toke.c
BEGIN {
    if (ord('A') == 65) {
        print "SKIPPED\n# test is EBCDIC-specific";
        exit 0;
    }
}
use warnings;
my $a = "\c{ack}";
EXPECT
OPTION fatal
Sequence "\c{" invalid at - line 9.
########
# toke.c
my $a = "\c√¢";
EXPECT
OPTION fatal
Character following "\c" must be printable ASCII at - line 2.
########
# toke.c
use warnings 'syntax' ;
my $a = qr/foo/du;
$a = qr/foo/lai;
$a = qr/foo/lil;
$a = qr/foo/aia;
$a = qr/foo/aaia;
no warnings 'syntax' ;
my $a = qr/foo/du;
EXPECT
Regexp modifiers "/d" and "/u" are mutually exclusive at - line 3, near "= "
Regexp modifiers "/l" and "/a" are mutually exclusive at - line 4, near "= "
Regexp modifier "/l" may not appear twice at - line 5, near "= "
Regexp modifier "/a" may appear a maximum of twice at - line 7, near "= "
BEGIN not safe after errors--compilation aborted at - line 8.
########
# toke.c
# [perl #4362]
eval "print q\xabfoo";
print "ok\n" if
    $@@ =~ /Can't find string terminator "\xab" anywhere before EOF/;
EXPECT
ok
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous' ;
sub fr√®d {}
$a = ${fr√®d} ;
no warnings 'ambiguous' ;
$a = ${fr√®d} ;
EXPECT
Ambiguous use of ${fr√®d} resolved to $fr√®d at - line 6.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous' ;
sub fÎ†è {}
$a = ${fÎ†è} ;
no warnings 'ambiguous' ;
$a = ${fÎ†è} ;
EXPECT
Ambiguous use of ${fÎ†è} resolved to $fÎ†è at - line 6.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings;
CORE::Î†è;
EXPECT
CORE::Î†è is not a keyword at - line 5.
########
# toke.c
# [perl #16249]
print '';
eval this_method_is_fake ();
EXPECT
Undefined subroutine &main::this_method_is_fake called at - line 4.
########
# toke.c
# [perl #107002] Erroneous ambiguity warnings
sub { # do not actually call require
  require a::b . 1; # These used to produce erroneous
  require a::b + 1; # ambiguity warnings.
}
EXPECT
########
# toke.c
# [perl #113094], [perl #119101], since reverted so no warnings generated
use warnings;
print "aa" =~ m{^a\{1,2\}$}, "A\n";
print "aa" =~ m{^a\x\{61\}$}, "B\n";
print "a\\x{6F}" =~ m{^a\\x\{6F\}$}, "C\n";
print "a\\o" =~ m{^a\\\x\{6F\}$}, "D\n";
print "a\\\\x{6F}" =~ m{^a\\\\x\{6F\}$}, "E\n";
print "a\\\\o"     =~ m{^a\\\\\x\{6F\}$}, "F\n";
print "aa" =~ m{^a{1,2}$}, "G\n";
print "aq" =~ m[^a\[a-z\]$], "H\n";
print "aq" =~ m(^a\(q\)$), "I\n";
EXPECT
Illegal hexadecimal digit '\' ignored at - line 5.
Illegal hexadecimal digit '\' ignored at - line 7.
Illegal hexadecimal digit '\' ignored at - line 9.
A
B
1C
D
1E
F
1G
H
I
########
# toke.c
#[perl #119123] disallow literal control character variables
*{
    Foo
}; # shouldn't warn on {\n, even though \n is a control character
EXPECT
########
# toke.c
# [perl #120288] -X at start of line gave spurious warning, where X is not
# a filetest operator
-a;
;-a;
EXPECT
########
# toke.c
# [perl #124113] Compile-time warning with UTF8 variable in array index
use warnings;
use utf8;
my $ùõÉ = 0;
my @@array = (0);
my $v = $array[ 0 + $ùõÉ ];
   $v = $array[ $ùõÉ + 0 ];
EXPECT
########
# toke.c
# Allow Unicode here doc boundaries
use warnings;
use utf8;
my $v = <<EnFra√ßais;
Comme ca!
EnFra√ßais
print $v;
EXPECT
Comme ca!
########
# toke.c
# Fix 'Use of "..." without parentheses is ambiguous' warning for
# Unicode function names.  If not under PERL_UNICODE, this will generate
# a "Wide character" warning
use utf8;
use warnings;
sub ùõÉ(;$) { return 0; }
my $v = ùõÉ - 5;
EXPECT
OPTION regex
(Wide character.*\n)?Warning: Use of "ùõÉ" without parentheses is ambiguous
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a152 26
eval "\$\cT";
eval "\${\7LOBAL_PHASE}";
eval "\${\cT}";
eval "\${\n\cT}";
eval "\${\cT\n}";
my $ret = eval "\${\n\cT\n}";
print "ok\n" if $ret == $^T;

no warnings 'deprecated' ;
eval "\$\cT";
eval "\${\7LOBAL_PHASE}";
eval "\${\cT}";
eval "\${\n\cT}";
eval "\${\cT\n}";
eval "\${\n\cT\n}";

EXPECT
Use of literal control characters in variable names is deprecated at (eval 1) line 1.
Use of literal control characters in variable names is deprecated at (eval 2) line 1.
Use of literal control characters in variable names is deprecated at (eval 3) line 1.
Use of literal control characters in variable names is deprecated at (eval 4) line 2.
Use of literal control characters in variable names is deprecated at (eval 5) line 1.
Use of literal control characters in variable names is deprecated at (eval 6) line 2.
ok
########
# toke.c
d760 1
a760 1
# toke.c
a765 1
Ambiguous use of -fred resolved as -&fred() at - line 3.
d767 1
a767 1
# toke.c
a778 3
Ambiguous use of -fred resolved as -&fred() at - line 4.
Ambiguous use of -fred resolved as -&fred() at - line 9.
Ambiguous use of -fred resolved as -&fred() at - line 11.
d780 1
a780 1
# toke.c
a785 1
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 5.
d787 1
a787 1
# toke.c
a800 3
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 6.
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 11.
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 13.
d802 1
a802 1
# toke.c
a807 1
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 5.
d809 1
a809 1
# toke.c
a822 3
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 6.
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 11.
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 13.
d1011 1
a1011 1
use feature 'postderef', 'postderef_qq';
a1013 1
no warnings 'experimental::postderef';
a1016 2
Postfix dereference is experimental at - line 3.
Postfix dereference is experimental at - line 4.
a1190 1
$a !=~ ?/?;
a1198 1
$a !=~ ?/?;
a1208 1
!=~ should be !~ at - line 10.
d1310 1
a1310 2
my $a = "foo";
print $a =~ ?f? ? "yes\n" : "no\n" foreach 0..2;
a1311 1
Use of ?PATTERN? without explicit operator is deprecated at - line 4.
d1314 7
a1320 1
no
d1323 6
d1336 15
a1350 2
"\c," is more clearly written simply as "l" at - line 3.
"\c`" is more clearly written simply as "\ " at - line 4.
d1353 6
d1363 1
a1363 1
Use ";" instead of "\c{" at - line 3.
d1441 24
a1464 39
# [perl #113094], [perl #119101]
print "aa" =~ m{^a\{1,2\}$}, "\n";
print "aa" =~ m{^a\x\{61\}$}, "\n";
print "a\\x{6F}" =~ m{^a\\x\{6F\}$}, "\n";
print "a\\o" =~ m{^a\\\x\{6F\}$}, "\n";
print "a\\\\x{6F}" =~ m{^a\\\\x\{6F\}$}, "\n";
print "a\\\\o"     =~ m{^a\\\\\x\{6F\}$}, "\n";
print "aa" =~ m{^a{1,2}$}, "\n";
print "aq" =~ m[^a\[a-z\]$], "\n";
print "aq" =~ m(^a\(q\)$), "\n";
no warnings 'deprecated';
print "aa" =~ m{^a\{1,2\}$}, "\n";
print "aa" =~ m{^a\x\{61\}$}, "\n";
print "a\\x{6F}" =~ m{^a\\x\{6F\}$}, "\n";
print "a\\o" =~ m{^a\\\x\{6f\}$}, "\n";
print "aq" =~ m[^a\[a-z\]$], "\n";
print "aq" =~ m(^a\(q\)$), "\n";
EXPECT
Useless use of '\'; doesn't escape metacharacter '{' at - line 3.
Useless use of '\'; doesn't escape metacharacter '{' at - line 4.
Useless use of '\'; doesn't escape metacharacter '{' at - line 6.
Useless use of '\'; doesn't escape metacharacter '{' at - line 8.
Useless use of '\'; doesn't escape metacharacter '[' at - line 10.
Useless use of '\'; doesn't escape metacharacter '(' at - line 11.
1
1
1
1
1
1
1
1
q
1
1
1
1
1
q
a1467 2
eval "\$\cQ = 25";
eval "\${ \cX } = 24";
a1471 2
Use of literal control characters in variable names is deprecated at (eval 1) line 1.
Use of literal control characters in variable names is deprecated at (eval 2) line 1.
d1503 2
a1504 1
# Unicode function names
d1510 2
a1511 1
Warning: Use of "ùõÉ" without parentheses is ambiguous at - line 7.
@


1.1
log
@Initial revision
@
text
@a37 4
     Scalar value %.*s better written as $%.*s" 
	@@a[3] = 2;
	@@a{3} = 2;

d79 5
a128 1
use warnings 'deprecated' ;
d139 3
a141 3
Use of comma-less variable list is deprecated at - line 5.
Use of comma-less variable list is deprecated at - line 5.
Use of comma-less variable list is deprecated at - line 5.
a143 1
use warnings 'deprecated' ;
d150 53
a202 1
Use of bare << to mean <<"" is deprecated at - line 3.
d284 2
d287 1
a287 2
@@a[3] = 2;
@@a{3} = 2;
d289 1
a289 2
@@a[3] = 2;
@@a{3} = 2;
d291 11
a301 2
Scalar value @@a[3] better written as $a[3] at - line 3.
Scalar value @@a{3} better written as $a{3} at - line 4.
d307 3
d337 9
a345 1
@@a = qw(a b #) ;
d347 1
a347 1
@@a = qw(a b #) ;
d349 1
d354 6
a359 1
print ("")
d361 1
a361 1
print (...) interpreted as function at - line 3.
d371 2
a372 1
printf ("")
d374 1
a374 1
printf (...) interpreted as function at - line 3.
d384 2
a385 1
sort ("")
d387 1
a387 1
sort (...) interpreted as function at - line 3.
d410 31
d449 5
d456 5
d463 37
d707 24
d753 2
d756 1
a756 1
Warning: Use of "rand" without parens is ambiguous at - line 2.
d769 16
a784 3
Warning: Use of "rand" without parens is ambiguous at - line 3.
Warning: Use of "rand" without parens is ambiguous at - line 8.
Warning: Use of "rand" without parens is ambiguous at - line 10.
d789 2
d811 52
d864 1
d869 18
d896 1
d904 34
d946 5
d960 73
d1041 19
d1123 1
a1123 1
sub dump { print "no warning for overriden dump\n"; }
d1126 1
a1126 1
no warning for overriden dump
d1132 1
a1132 1
"@@mjd_previously_unused_array";        
d1137 16
a1152 7
# The \q should warn, the \_ should NOT warn.
use warnings 'misc';
"foo" =~ /\q/;
"bar" =~ /\_/;
no warnings 'misc';
"foo" =~ /\q/;
"bar" =~ /\_/;
d1154 1
a1154 1
Unrecognized escape \q passed through at - line 4.
d1208 336
a1543 1

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d573 1
a573 1
Warning: Use of "rand" without parentheses is ambiguous at - line 2.
d586 3
a588 3
Warning: Use of "rand" without parentheses is ambiguous at - line 3.
Warning: Use of "rand" without parentheses is ambiguous at - line 8.
Warning: Use of "rand" without parentheses is ambiguous at - line 10.
a615 4
########
# toke.c (and [perl #16184])
open FOO => "<&0"; close FOO;
EXPECT
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a801 17
########
# toke.c
# mandatory warning
eval q/if ($a) { } elseif ($b) { }/;
no warnings "syntax";
eval q/if ($a) { } elseif ($b) { }/;
EXPECT
elseif should be elsif at (eval 1) line 1.
########
# toke.c
# mandatory warning
eval q/5 6/;
no warnings "syntax";
eval q/5 6/;
EXPECT
Number found where operator expected at (eval 1) line 1, near "5 6"
	(Missing operator before  6?)
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d282 1
a282 6
print ("");
print ("") and $x = 1;
print ("") or die;
print ("") // die;
print (1+2) * 3 if 0; # only this one should warn
print (1+2) if 0;
d284 1
a284 1
print (...) interpreted as function at - line 7.
d294 1
a294 2
printf ("");
printf ("") . '';
d296 1
a296 1
printf (...) interpreted as function at - line 4.
d306 1
a306 2
sort ("");
sort ("") . '';
d308 1
a308 1
sort (...) interpreted as function at - line 4.
a590 5
use warnings "ambiguous";
print for keys %+; # should not warn
EXPECT
########
# toke.c
d740 11
d819 1
a819 35
########
# toke.c
use warnings "syntax";
$_ = $a = 1;
$a !=~  /1/;
$a !=~ m#1#;
$a !=~/1/;
$a !=~ ?/?;
$a !=~ y/1//;
$a !=~ tr/1//;
$a !=~ s/1//;
$a != ~/1/;
no warnings "syntax";
$a !=~  /1/;
$a !=~ m#1#;
$a !=~/1/;
$a !=~ ?/?;
$a !=~ y/1//;
$a !=~ tr/1//;
$a !=~ s/1//;
EXPECT
!=~ should be !~ at - line 4.
!=~ should be !~ at - line 5.
!=~ should be !~ at - line 6.
!=~ should be !~ at - line 7.
!=~ should be !~ at - line 8.
!=~ should be !~ at - line 9.
!=~ should be !~ at - line 10.
########
# toke.c
our $foo :unique;
use warnings 'deprecated';
our $bar :unique;
EXPECT
Use of :unique is deprecated at - line 4.
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d128 1
d139 3
a141 3
Use of comma-less variable list is deprecated at - line 4.
Use of comma-less variable list is deprecated at - line 4.
Use of comma-less variable list is deprecated at - line 4.
d144 1
d151 1
a151 1
Use of bare << to mean <<"" is deprecated at - line 2.
d851 1
a851 6
sub pam :locked;
sub glipp :locked {
}
sub whack_eth ($) : locked {
}
no warnings 'deprecated';
a852 5
sub zapeth :locked;
sub ker_plop :locked {
}
sub swa_a_p ($) : locked {
}
d854 1
a854 101
Use of :unique is deprecated at - line 2.
Use of :locked is deprecated at - line 3.
Use of :locked is deprecated at - line 4.
Use of :locked is deprecated at - line 6.
########
# toke.c
use warnings "syntax";
sub proto_after_array(@@$);
sub proto_after_arref(\@@$);
sub proto_after_arref2(\[@@$]);
sub proto_after_arref3(\[@@$]_);
sub proto_after_hash(%$);
sub proto_after_hashref(\%$);
sub proto_after_hashref2(\[%$]);
sub underscore_last_pos($_);
sub underscore2($_;$);
sub underscore_fail($_$);
sub underscore_after_at(@@_);
no warnings "syntax";
sub proto_after_array(@@$);
sub proto_after_hash(%$);
sub underscore_fail($_$);
EXPECT
Prototype after '@@' for main::proto_after_array : @@$ at - line 3.
Prototype after '%' for main::proto_after_hash : %$ at - line 7.
Illegal character after '_' in prototype for main::underscore_fail : $_$ at - line 12.
Prototype after '@@' for main::underscore_after_at : @@_ at - line 13.
########
# toke.c
use warnings "ambiguous";
"foo\nn" =~ /^foo$\n/;
"foo\nn" =~ /^foo${\}n/;
my $foo = qr/^foo$\n/;
my $bar = qr/^foo${\}n/;
no warnings "ambiguous";
"foo\nn" =~ /^foo$\n/;
"foo\nn" =~ /^foo${\}n/;
my $foo = qr/^foo$\n/;
my $bar = qr/^foo${\}n/;
EXPECT
Possible unintended interpolation of $\ in regex at - line 3.
Possible unintended interpolation of $\ in regex at - line 5.
########
# toke.c
use feature 'state';
# This one is fine as an empty attribute list
my $holy_Einstein : = '';
# This one is deprecated
my $krunch := 4;
our $FWISK_FWISK_FWIZZACH_FWACH_ZACHITTY_ZICH_SHAZZATZ_FWISK := '';
state $thump := 'Trumpets';
# Lather rinse repeat in my usual obsessive style
my @@holy_perfect_pitch : = ();
my @@zok := ();
our @@GUKGUK := ();
# state @@widget_mark := ();
my %holy_seditives : = ();
my %bang := ();
our %GIGAZING := ();
# state %hex := ();
no warnings 'deprecated';
my $holy_giveaways : = '';
my $eee_yow := [];
our $TWOYYOYYOING_THUK_UGH := 1 == 1;
state $octothorn := 'Tinky Winky';
my @@holy_Taj_Mahal : = ();
my @@touche := ();
our @@PLAK_DAK_THUK_FRIT := ();
# state @@hash_mark := ();
my %holy_priceless_collection_of_Etruscan_snoods : = ();
my %wham_eth := ();
our %THWUK := ();
# state %octalthorpe := ();
use warnings;
my $holy_sewer_pipe : = '';
my $thunk := undef;
our $BLIT := time;
state $crunch := 'Laa Laa';
my @@glurpp := ();
my @@holy_harem : = ();
our @@FABADAP := ();
# state @@square := ();
my %holy_pin_cushions : = ();
my %swoosh := ();
our %RRRRR := ();
# state %scratchmark := ();
EXPECT
Use of := for an empty attribute list is deprecated at - line 6.
Use of := for an empty attribute list is deprecated at - line 7.
Use of := for an empty attribute list is deprecated at - line 8.
Use of := for an empty attribute list is deprecated at - line 11.
Use of := for an empty attribute list is deprecated at - line 12.
Use of := for an empty attribute list is deprecated at - line 15.
Use of := for an empty attribute list is deprecated at - line 16.
Use of := for an empty attribute list is deprecated at - line 33.
Use of := for an empty attribute list is deprecated at - line 34.
Use of := for an empty attribute list is deprecated at - line 35.
Use of := for an empty attribute list is deprecated at - line 36.
Use of := for an empty attribute list is deprecated at - line 38.
Use of := for an empty attribute list is deprecated at - line 41.
Use of := for an empty attribute list is deprecated at - line 42.
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a82 3
    Useless use of \\E.
        $a = "abcd\E" ;

a142 2
$a =~ m/$foo/sand $bar;
$a =~ s/$foo/fool/sand $bar;
a145 2
$a =~ m/$foo/sand $bar;
$a =~ s/$foo/fool/sand $bar;
d149 1
a149 3
Having no space between pattern and following word is deprecated at - line 2.
Having no space between pattern and following word is deprecated at - line 3.
Use of bare << to mean <<"" is deprecated at - line 4.
a230 20
use utf8;
use open qw( :utf8 :std );
use warnings 'syntax' ;
sub fr√®d {} ; $SIG{TERM} = fr√®d;
no warnings 'syntax' ;
$SIG{TERM} = fr√®d;
EXPECT
You need to quote "fr√®d" at - line 5.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'syntax' ;
sub „Åµ„Çå„Å© {} ; $SIG{TERM} = „Åµ„Çå„Å©;
no warnings 'syntax' ;
$SIG{TERM} = „Åµ„Çå„Å©;
EXPECT
You need to quote "„Åµ„Çå„Å©" at - line 5.
########
# toke.c
a241 26
use utf8;
use open qw( :utf8 :std );
use warnings 'syntax' ;
@@√†[3] = 2;
@@√†{3} = 2;
no warnings 'syntax' ;
@@√†[3] = 2;
@@√†{3} = 2;
EXPECT
Scalar value @@√†[3] better written as $√†[3] at - line 5.
Scalar value @@√†{3} better written as $√†{3} at - line 6.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'syntax' ;
@@„ÅÅ[3] = 2;
@@„ÅÅ{3} = 2;
no warnings 'syntax' ;
@@„ÅÅ[3] = 2;
@@„ÅÅ{3} = 2;
EXPECT
Scalar value @@„ÅÅ[3] better written as $„ÅÅ[3] at - line 5.
Scalar value @@„ÅÅ{3} better written as $„ÅÅ{3} at - line 6.
########
# toke.c
d272 1
a272 1
@@a = qw(a b c # #) ;
d274 1
a274 1
@@a = qw(a b c # #) ;
a278 9
use warnings 'qw' ;
@@a = qw(a, b, c # #) ;
no warnings 'qw' ;
@@a = qw(a, b, c # #) ;
EXPECT
Possible attempt to separate words with commas at - line 3.
Possible attempt to put comments in qw() list at - line 3.
########
# toke.c
a554 24
use utf8;
use open qw( :utf8 :std );
use warnings 'bareword' ;
#line 25 "bar"
$a = FR√àD:: ;
no warnings 'bareword' ;
#line 25 "bar"
$a = FR√àD:: ;
EXPECT
Bareword "FR√àD::" refers to nonexistent package at bar line 25.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'bareword' ;
#line 25 "bar"
$a = œûœûœû:: ;
no warnings 'bareword' ;
#line 25 "bar"
$a = œûœûœû:: ;
EXPECT
Bareword "œûœûœû::" refers to nonexistent package at bar line 25.
########
# toke.c
a594 8
# [perl #97110]
sub myrand(;$) { }
sub whatever($) { }
my $a = myrand + 4 ;
my $b = whatever + 4 ;
EXPECT
Warning: Use of "myrand" without parentheses is ambiguous at - line 4.
########
a622 52
use utf8;
use open qw( :utf8 :std );
sub fr√®d {};
-fr√®d ;
EXPECT
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 5.
########
# toke.c
$^W = 0 ;
use utf8;
use open qw( :utf8 :std );
sub fr√®d {} ;
-fr√®d ;
{
    no warnings 'ambiguous' ;
    -fr√®d ;
    use warnings 'ambiguous' ;
    -fr√®d ;
}
-fr√®d ;
EXPECT
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 6.
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 11.
Ambiguous use of -fr√®d resolved as -&fr√®d() at - line 13.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
sub ·íç·íò·íä {};
-·íç·íò·íä ;
EXPECT
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 5.
########
# toke.c
$^W = 0 ;
use utf8;
use open qw( :utf8 :std );
sub ·íç·íò·íä {} ;
-·íç·íò·íä ;
{
    no warnings 'ambiguous' ;
    -·íç·íò·íä ;
    use warnings 'ambiguous' ;
    -·íç·íò·íä ;
}
-·íç·íò·íä ;
EXPECT
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 6.
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 11.
Ambiguous use of -·íç·íò·íä resolved as -&·íç·íò·íä() at - line 13.
########
# toke.c
a623 1
open local *FOO; # should be ok
a626 14
# toke.c
use utf8;
use open qw( :utf8 :std );
open F√í√í || time;
EXPECT
Precedence problem: open F√í√í should be open(F√í√í) at - line 4.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
open ·íçOO || time;
EXPECT
Precedence problem: open ·íçOO should be open(·íçOO) at - line 4.
########
a640 1
open Foo::BAR; # this should not warn
a647 34
use utf8;
use open qw( :utf8 :std );
open F√í√í || time;
{
    no warnings 'precedence' ;
    open F√í√í || time;
    use warnings 'precedence' ;
    open F√í√í || time;
}
open F√í√í || time;
EXPECT
Precedence problem: open F√í√í should be open(F√í√í) at - line 5.
Precedence problem: open F√í√í should be open(F√í√í) at - line 10.
Precedence problem: open F√í√í should be open(F√í√í) at - line 12.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
$^W = 0 ;
open ·íç√í√í || time;
{
    no warnings 'precedence' ;
    open ·íç√í√í || time;
    use warnings 'precedence' ;
    open ·íç√í√í || time;
}
open ·íç√í√í || time;
EXPECT
Precedence problem: open ·íç√í√í should be open(·íç√í√í) at - line 5.
Precedence problem: open ·íç√í√í should be open(·íç√í√í) at - line 10.
Precedence problem: open ·íç√í√í should be open(·íç√í√í) at - line 12.
########
# toke.c
$^W = 0 ;
a664 20
use utf8;
use open qw( :utf8 :std );
$^W = 0 ;
*ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
{
    no warnings 'ambiguous' ;
    *ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
    use warnings 'ambiguous' ;
    *ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
}
*ÔΩÜÔΩèÔΩè *ÔΩÜÔΩèÔΩè ;
EXPECT
Operator or semicolon missing before *ÔΩÜÔΩèÔΩè at - line 5.
Ambiguous use of * resolved as operator * at - line 5.
Operator or semicolon missing before *ÔΩÜÔΩèÔΩè at - line 10.
Ambiguous use of * resolved as operator * at - line 10.
Operator or semicolon missing before *ÔΩÜÔΩèÔΩè at - line 12.
Ambiguous use of * resolved as operator * at - line 12.
########
# toke.c
a672 8
use warnings 'misc' ;
my $a = "abcd\E" ;
no warnings 'misc' ;
$a = "abcd\E" ;
EXPECT
Useless use of \E at - line 3.
########
# toke.c
d736 1
a736 1
sub dump { print "no warning for overridden dump\n"; }
d739 1
a739 1
no warning for overridden dump
d745 1
a745 1
"@@mjd_previously_unused_array2";        
a749 20
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous';
"@@mjd_previously_unused_√†rray";        
no warnings 'ambiguous';
"@@mjd_previously_unused_√†rray2";        
EXPECT
Possible unintended interpolation of @@mjd_previously_unused_√†rray in string at - line 5.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous';
"@@mjd_previously_unused_„ÅÅrr„ÅÅy";        
no warnings 'ambiguous';
"@@mjd_previously_unused_„ÅÅrr„ÅÅy2";        
EXPECT
Possible unintended interpolation of @@mjd_previously_unused_„ÅÅrr„ÅÅy in string at - line 5.
########
# toke.c
d906 16
a921 41
use warnings 'syntax' ;
my $a = "\o";
my $a = "\o{";
my $a = "\o{}";
no warnings 'syntax' ;
my $a = "\o";
my $a = "\o{";
my $a = "\o{}";
EXPECT
Missing braces on \o{} at - line 3, within string
Missing right brace on \o{ at - line 4, within string
Number with no digits at - line 5, within string
BEGIN not safe after errors--compilation aborted at - line 6.
########
# toke.c
use warnings 'digit' ;
my $a = "\o{1238456}";
no warnings 'digit' ;
my $a = "\o{1238456}";
EXPECT
Non-octal character '8'.  Resolved as "\o{123}" at - line 3.
########
# toke.c
use warnings;
my $a = "foo";
print $a =~ ?f? ? "yes\n" : "no\n" foreach 0..2;
EXPECT
Use of ?PATTERN? without explicit operator is deprecated at - line 4.
yes
no
no
########
# toke.c
use warnings;
my $a = "\c{ack}";
$a = "\c,";
$a = "\c`";
no warnings 'syntax';
$a = "\c{ack}";
$a = "\c,";
$a = "\c`";
d923 12
a934 55
EXPECT
"\c{" is deprecated and is more clearly written as ";" at - line 3.
"\c," is more clearly written simply as "l" at - line 4.
"\c`" is more clearly written simply as "\ " at - line 5.
"\c{" is deprecated and is more clearly written as ";" at - line 7.
########
# toke.c
use warnings 'syntax' ;
my $a = qr/foo/du;
$a = qr/foo/lai;
$a = qr/foo/lil;
$a = qr/foo/aia;
$a = qr/foo/aaia;
no warnings 'syntax' ;
my $a = qr/foo/du;
EXPECT
Regexp modifiers "/d" and "/u" are mutually exclusive at - line 3, near "= "
Regexp modifiers "/l" and "/a" are mutually exclusive at - line 4, near "= "
Regexp modifier "/l" may not appear twice at - line 5, near "= "
Regexp modifier "/a" may appear a maximum of twice at - line 7, near "= "
BEGIN not safe after errors--compilation aborted at - line 8.
########
# toke.c
# [perl #4362]
eval "print q\xabfoo";
print "ok\n" if
    $@@ =~ /Can't find string terminator "\xab" anywhere before EOF/;
EXPECT
ok
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous' ;
sub fr√®d {}
$a = ${fr√®d} ;
no warnings 'ambiguous' ;
$a = ${fr√®d} ;
EXPECT
Ambiguous use of ${fr√®d} resolved to $fr√®d at - line 6.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
use warnings 'ambiguous' ;
sub fÎ†è {}
$a = ${fÎ†è} ;
no warnings 'ambiguous' ;
$a = ${fÎ†è} ;
EXPECT
Ambiguous use of ${fÎ†è} resolved to $fÎ†è at - line 6.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
d936 27
a962 3
CORE::Î†è;
EXPECT
CORE::Î†è is not a keyword at - line 5.
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d146 2
d151 2
d156 3
a158 27
Use of bare << to mean <<"" is deprecated at - line 2.
########
# toke.c
$a =~ m/$foo/eq;
$a =~ s/$foo/fool/seq;

EXPECT
OPTION fatal
Unknown regexp modifier "/e" at - line 2, near "=~ "
Unknown regexp modifier "/q" at - line 2, near "=~ "
Unknown regexp modifier "/q" at - line 3, near "=~ "
Execution of - aborted due to compilation errors.
########
# toke.c
use utf8;
use open qw( :utf8 :std );
$a =~ m/$foo/e„Éçq;
$a =~ s/$foo/fool/se„Éçq;

EXPECT
OPTION fatal
Unknown regexp modifier "/e" at - line 4, near "=~ "
Unknown regexp modifier "/„Éç" at - line 4, near "=~ "
Unknown regexp modifier "/q" at - line 4, near "=~ "
Unknown regexp modifier "/„Éç" at - line 5, near "=~ "
Unknown regexp modifier "/q" at - line 5, near "=~ "
Execution of - aborted due to compilation errors.
a664 2
$a = rand *^H ;
$a = rand $^H ;
a698 2
sub hank : lvalue {$_}
--hank; # This should *not* warn [perl #77240]
d1066 1
a1066 1
use warnings "syntax"; no warnings "deprecated";
d1114 1
a1114 1
use warnings "syntax"; use feature 'lexical_subs';
a1125 8
our sub hour (@@$);
my sub migh (@@$);
use feature 'state';
state sub estate (@@$);
package other;
sub hour (@@$);
sub migh (@@$);
sub estate (@@$);
a1134 9
The lexical_subs feature is experimental at - line 14.
Prototype after '@@' for hour : @@$ at - line 14.
The lexical_subs feature is experimental at - line 15.
Prototype after '@@' for migh : @@$ at - line 15.
The lexical_subs feature is experimental at - line 17.
Prototype after '@@' for estate : @@$ at - line 17.
Prototype after '@@' for hour : @@$ at - line 19.
Prototype after '@@' for migh : @@$ at - line 20.
Prototype after '@@' for estate : @@$ at - line 21.
a1252 42
########
# toke.c
# [perl #16249]
print '';
eval this_method_is_fake ();
EXPECT
Undefined subroutine &main::this_method_is_fake called at - line 4.
########
# toke.c
# [perl #107002] Erroneous ambiguity warnings
sub { # do not actually call require
  require a::b . 1; # These used to produce erroneous
  require a::b + 1; # ambiguity warnings.
}
EXPECT
########
# toke.c
# [perl #113094]
print "aa" =~ m{^a\{1,2\}$}, "\n";
print "aa" =~ m{^a\x\{61\}$}, "\n";
print "aa" =~ m{^a{1,2}$}, "\n";
print "aq" =~ m[^a\[a-z\]$], "\n";
print "aq" =~ m(^a\(q\)$), "\n";
no warnings 'deprecated';
print "aa" =~ m{^a\{1,2\}$}, "\n";
print "aa" =~ m{^a\x\{61\}$}, "\n";
print "aq" =~ m[^a\[a-z\]$], "\n";
print "aq" =~ m(^a\(q\)$), "\n";
EXPECT
Useless use of '\'; doesn't escape metacharacter '{' at - line 3.
Useless use of '\'; doesn't escape metacharacter '{' at - line 4.
Useless use of '\'; doesn't escape metacharacter '[' at - line 6.
Useless use of '\'; doesn't escape metacharacter '(' at - line 7.
1
1
1
1
q
1
1
1
q
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@d38 4
a85 2
    Postfix dereference is experimental

a154 26
eval "\$\cT";
eval "\${\7LOBAL_PHASE}";
eval "\${\cT}";
eval "\${\n\cT}";
eval "\${\cT\n}";
my $ret = eval "\${\n\cT\n}";
print "ok\n" if $ret == $^T;

no warnings 'deprecated' ;
eval "\$\cT";
eval "\${\7LOBAL_PHASE}";
eval "\${\cT}";
eval "\${\n\cT}";
eval "\${\cT\n}";
eval "\${\n\cT\n}";

EXPECT
Use of literal control characters in variable names is deprecated at (eval 1) line 1.
Use of literal control characters in variable names is deprecated at (eval 2) line 1.
Use of literal control characters in variable names is deprecated at (eval 3) line 1.
Use of literal control characters in variable names is deprecated at (eval 4) line 2.
Use of literal control characters in variable names is deprecated at (eval 5) line 1.
Use of literal control characters in variable names is deprecated at (eval 6) line 2.
ok
########
# toke.c
d281 37
a319 3
s//\(2)/e; # should be exempt
s/${\2}//; # same here
()="${\2}"; # metoo
a419 31
use warnings 'ambiguous' ;
$a = ${

    time
        {2}
};
warn "after";
EXPECT
Ambiguous use of ${time{...}} resolved to $time{...} at - line 5.
after at - line 8.
########
# toke.c
use warnings 'ambiguous' ;
$a = ${

time[2]

};
$a = ${

time    
   [2]

};
warn "after";
EXPECT
Ambiguous use of ${time[...]} resolved to $time[...] at - line 5.
Ambiguous use of ${time[...]} resolved to $time[...] at - line 10.
after at - line 14.
########
# toke.c
a427 5
$a = @@{time} ;
$a = $#{time} ; # This one is special cased in toke.c
$a = %{time} ;
$a = *{time} ;
$a = defined &{time} ; # To avoid calling &::time
a429 5
$a = @@{time} ;
$a = $#{time} ; # This one is special cased in toke.c
$a = %{time} ;
$a = *{time} ;
$a = defined &{time} ; # To avoid calling &::time
a431 37
Ambiguous use of @@{time} resolved to @@time at - line 4.
Ambiguous use of @@{time} resolved to @@time at - line 5.
Ambiguous use of %{time} resolved to %time at - line 6.
Ambiguous use of *{time} resolved to *time at - line 7.
Ambiguous use of &{time} resolved to &time at - line 8.
########
# toke.c
use warnings 'ambiguous' ;
$a = ${
time
} ;
$a = @@{
time
} ;
$a = $#{
time
} ;
$a = %{
time
} ;
$a = *{
time
} ;
$a = defined &{
time


} ;
warn "last";
EXPECT
Ambiguous use of ${time} resolved to $time at - line 4.
Ambiguous use of @@{time} resolved to @@time at - line 7.
Ambiguous use of @@{time} resolved to @@time at - line 10.
Ambiguous use of %{time} resolved to %time at - line 13.
Ambiguous use of *{time} resolved to *time at - line 16.
Ambiguous use of &{time} resolved to &time at - line 19.
last at - line 23.
a877 5
# These should not warn [perl #117535]:
foo**foo ;
no warnings 'deprecated';
sort $*foo ;
sort $ *foo ;
a886 53
$^W = 0 ;
%foo %foo ;
{
    no warnings 'ambiguous' ;
    %foo %foo ;
    use warnings 'ambiguous' ;
    %foo %foo ;
}
%foo %foo ;
# This should not produce ambiguity warnings [perl #117535]:
sort $%foo ;
sort $ %foo ;
EXPECT
Operator or semicolon missing before %foo at - line 3.
Ambiguous use of % resolved as operator % at - line 3.
Operator or semicolon missing before %foo at - line 8.
Ambiguous use of % resolved as operator % at - line 8.
Operator or semicolon missing before %foo at - line 10.
Ambiguous use of % resolved as operator % at - line 10.
Bareword found where operator expected at - line 12, near "$%foo"
	(Missing operator before foo?)
Bareword found where operator expected at - line 13, near "$ %foo"
	(Missing operator before foo?)
Illegal modulus zero at - line 3.
########
# toke.c
$^W = 0 ;
&foo &foo ;
{
    no warnings 'ambiguous' ;
    &foo &foo ;
    use warnings 'ambiguous' ;
    &foo &foo ;
}
&foo &foo ;
# These should not warn produce ambiguity warnings [perl #76910]:
foo&&foo ;
sort $&foo ;
sort $ &foo ;
EXPECT
Operator or semicolon missing before &foo at - line 3.
Ambiguous use of & resolved as operator & at - line 3.
Operator or semicolon missing before &foo at - line 8.
Ambiguous use of & resolved as operator & at - line 8.
Operator or semicolon missing before &foo at - line 10.
Ambiguous use of & resolved as operator & at - line 10.
Bareword found where operator expected at - line 13, near "$&foo"
	(Missing operator before foo?)
Bareword found where operator expected at - line 14, near "$ &foo"
	(Missing operator before foo?)
Undefined subroutine &main::foo called at - line 3.
########
# toke.c
a922 11
use feature 'postderef', 'postderef_qq';
(\$_)->$*;
"$_->$*";
no warnings 'experimental::postderef';
(\$_)->$*;
"$_->$*";
EXPECT
Postfix dereference is experimental at - line 3.
Postfix dereference is experimental at - line 4.
########
# toke.c
d1227 1
d1231 1
d1234 1
d1236 4
a1239 15
"\c," is more clearly written simply as "l" at - line 3.
"\c`" is more clearly written simply as "\ " at - line 4.
########
# toke.c
use warnings;
my $a = "\c{ack}";
EXPECT
OPTION fatal
Use ";" instead of "\c{" at - line 3.
########
# toke.c
my $a = "\c√¢";
EXPECT
OPTION fatal
Character following "\c" must be printable ASCII at - line 2.
d1311 1
a1311 1
# [perl #113094], [perl #119101]
a1313 4
print "a\\x{6F}" =~ m{^a\\x\{6F\}$}, "\n";
print "a\\o" =~ m{^a\\\x\{6F\}$}, "\n";
print "a\\\\x{6F}" =~ m{^a\\\\x\{6F\}$}, "\n";
print "a\\\\o"     =~ m{^a\\\\\x\{6F\}$}, "\n";
a1319 2
print "a\\x{6F}" =~ m{^a\\x\{6F\}$}, "\n";
print "a\\o" =~ m{^a\\\x\{6f\}$}, "\n";
d1325 2
a1326 8
Useless use of '\'; doesn't escape metacharacter '{' at - line 6.
Useless use of '\'; doesn't escape metacharacter '{' at - line 8.
Useless use of '\'; doesn't escape metacharacter '[' at - line 10.
Useless use of '\'; doesn't escape metacharacter '(' at - line 11.
1
1
1
1
a1334 2
1
1
a1335 18
########
# toke.c
#[perl #119123] disallow literal control character variables
eval "\$\cQ = 25";
eval "\${ \cX } = 24";
*{
    Foo
}; # shouldn't warn on {\n, even though \n is a control character
EXPECT
Use of literal control characters in variable names is deprecated at (eval 1) line 1.
Use of literal control characters in variable names is deprecated at (eval 2) line 1.
########
# toke.c
# [perl #120288] -X at start of line gave spurious warning, where X is not
# a filetest operator
-a;
;-a;
EXPECT
@


1.1.1.9
log
@Import perl-5.24.2
@
text
@d153 26
d786 1
a786 1
# toke.c [This does not warn any more.]
d792 1
d794 1
a794 1
# toke.c [This does not warn any more.]
d806 3
d810 1
a810 1
# toke.c [This does not warn any more.]
d816 1
d818 1
a818 1
# toke.c [This does not warn any more.]
d832 3
d836 1
a836 1
# toke.c [This does not warn any more.]
d842 1
d844 1
a844 1
# toke.c [This does not warn any more.]
d858 3
d1049 1
a1049 1
use feature 'postderef_qq';
d1052 1
d1056 2
d1232 1
d1241 1
d1252 1
d1354 2
a1355 1
print ref ? "yes\n" : "no\n" foreach [], ''; # ? is unambiguosly an operator
d1357 1
d1360 1
a1360 7
########
# toke .c
use warnings;
$a =~ ?rand?; # ? is not a regex match
EXPECT
syntax error at - line 3, near "=~ ?"
Execution of - aborted due to compilation errors.
a1362 6
BEGIN {
    if (ord('A') == 193) {
        print "SKIPPED\n# result varies depending on which ebcdic platform";
        exit 0;
    }
}
d1370 2
a1371 2
"\c," is more clearly written simply as "l" at - line 9.
"\c`" is more clearly written simply as "\ " at - line 10.
a1373 6
BEGIN {
    if (ord('A') == 193) {
        print "SKIPPED\n# test is ASCII-specific";
        exit 0;
    }
}
d1378 1
a1378 14
Use ";" instead of "\c{" at - line 9.
########
# toke.c
BEGIN {
    if (ord('A') == 65) {
        print "SKIPPED\n# test is EBCDIC-specific";
        exit 0;
    }
}
use warnings;
my $a = "\c{ack}";
EXPECT
OPTION fatal
Sequence "\c{" invalid at - line 9.
d1456 39
a1494 24
# [perl #113094], [perl #119101], since reverted so no warnings generated
use warnings;
print "aa" =~ m{^a\{1,2\}$}, "A\n";
print "aa" =~ m{^a\x\{61\}$}, "B\n";
print "a\\x{6F}" =~ m{^a\\x\{6F\}$}, "C\n";
print "a\\o" =~ m{^a\\\x\{6F\}$}, "D\n";
print "a\\\\x{6F}" =~ m{^a\\\\x\{6F\}$}, "E\n";
print "a\\\\o"     =~ m{^a\\\\\x\{6F\}$}, "F\n";
print "aa" =~ m{^a{1,2}$}, "G\n";
print "aq" =~ m[^a\[a-z\]$], "H\n";
print "aq" =~ m(^a\(q\)$), "I\n";
EXPECT
Illegal hexadecimal digit '\' ignored at - line 5.
Illegal hexadecimal digit '\' ignored at - line 7.
Illegal hexadecimal digit '\' ignored at - line 9.
A
B
1C
D
1E
F
1G
H
I
d1498 2
d1504 2
a1512 33
########
# toke.c
# [perl #124113] Compile-time warning with UTF8 variable in array index
use warnings;
use utf8;
my $ùõÉ = 0;
my @@array = (0);
my $v = $array[ 0 + $ùõÉ ];
   $v = $array[ $ùõÉ + 0 ];
EXPECT
########
# toke.c
# Allow Unicode here doc boundaries
use warnings;
use utf8;
my $v = <<EnFra√ßais;
Comme ca!
EnFra√ßais
print $v;
EXPECT
Comme ca!
########
# toke.c
# Fix 'Use of "..." without parentheses is ambiguous' warning for
# Unicode function names.  If not under PERL_UNICODE, this will generate
# a "Wide character" warning
use utf8;
use warnings;
sub ùõÉ(;$) { return 0; }
my $v = ùõÉ - 5;
EXPECT
OPTION regex
(Wide character.*\n)?Warning: Use of "ùõÉ" without parentheses is ambiguous
@


