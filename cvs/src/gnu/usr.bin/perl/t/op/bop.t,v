head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.6
	OPENBSD_6_2_BASE:1.11
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.16
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.10
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.12
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.09.18.10.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.20;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.14;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.43;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.48.34;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2017.08.14.13.46.23;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

#
# test the bit operators '&', '|', '^', '~', '<<', and '>>'
#

use warnings;
no warnings 'deprecated';

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require "./test.pl"; require "./charset_tools.pl";
    require Config;
}

# Tests don't have names yet.
# If you find tests are failing, please try adding names to tests to track
# down where the failure is, and supply your new names as a patch.
# (Just-in-time test naming)
plan tests => 192 + (10*13*2) + 5 + 29;

# numerics
ok ((0xdead & 0xbeef) == 0x9ead);
ok ((0xdead | 0xbeef) == 0xfeef);
ok ((0xdead ^ 0xbeef) == 0x6042);
ok ((~0xdead & 0xbeef) == 0x2042);

# shifts
ok ((257 << 7) == 32896);
ok ((33023 >> 7) == 257);

# signed vs. unsigned
ok ((~0 > 0 && do { use integer; ~0 } == -1));

my $bits = 0;
for (my $i = ~0; $i; $i >>= 1) { ++$bits; }
my $cusp = 1 << ($bits - 1);


ok (($cusp & -1) > 0 && do { use integer; $cusp & -1 } < 0);
ok (($cusp | 1) > 0 && do { use integer; $cusp | 1 } < 0);
ok (($cusp ^ 1) > 0 && do { use integer; $cusp ^ 1 } < 0);
ok ((1 << ($bits - 1)) == $cusp &&
    do { use integer; 1 << ($bits - 1) } == -$cusp);
ok (($cusp >> 1) == ($cusp / 2) &&
    do { use integer; abs($cusp >> 1) } == ($cusp / 2));

$Aaz = chr(ord("A") & ord("z"));
$Aoz = chr(ord("A") | ord("z"));
$Axz = chr(ord("A") ^ ord("z"));

# short strings
is (("AAAAA" & "zzzzz"), ($Aaz x 5));
is (("AAAAA" | "zzzzz"), ($Aoz x 5));
is (("AAAAA" ^ "zzzzz"), ($Axz x 5));

# long strings
$foo = "A" x 150;
$bar = "z" x 75;
$zap = "A" x 75;
# & truncates
is (($foo & $bar), ($Aaz x 75 ));
# | does not truncate
is (($foo | $bar), ($Aoz x 75 . $zap));
# ^ does not truncate
is (($foo ^ $bar), ($Axz x 75 . $zap));

# string constants.  These tests expect the bit patterns of these strings in
# ASCII, so convert to that.
sub _and($) { $_[0] & native_to_uni("+0") }
sub _oar($) { $_[0] | native_to_uni("+0") }
sub _xor($) { $_[0] ^ native_to_uni("+0") }
is _and native_to_uni("waf"), native_to_uni('# '),  'str var & const str'; # [perl #20661]
is _and native_to_uni("waf"), native_to_uni('# '),  'str var & const str again'; # [perl #20661]
is _oar native_to_uni("yit"), native_to_uni('{yt'), 'str var | const str';
is _oar native_to_uni("yit"), native_to_uni('{yt'), 'str var | const str again';
is _xor native_to_uni("yit"), native_to_uni('RYt'), 'str var ^ const str';
is _xor native_to_uni("yit"), native_to_uni('RYt'), 'str var ^ const str again';

SKIP: {
    skip "Converting a numeric doesn't work with EBCDIC unlike the above tests",
         3 if $::IS_EBCDIC;
    is _and  0, '0',   'num var & const str';     # [perl #20661]
    is _oar  0, '0',   'num var | const str';
    is _xor  0, '0',   'num var ^ const str';
}

# But don’t mistake a COW for a constant when assigning to it
%h=(150=>1);
$i=(keys %h)[0];
$i |= 105;
is $i, 255, '[perl #108480] $cow |= number';
$i=(keys %h)[0];
$i &= 105;
is $i, 0, '[perl #108480] $cow &= number';
$i=(keys %h)[0];
$i ^= 105;
is $i, 255, '[perl #108480] $cow ^= number';

#
is ("ok \xFF\xFF\n" & "ok 19\n", "ok 19\n");
is ("ok 20\n" | "ok \0\0\n", "ok 20\n");
is ("o\000 \0001\000" ^ "\000k\0002\000\n", "ok 21\n");

#
is ("ok \x{FF}\x{FF}\n" & "ok 22\n", "ok 22\n");
is ("ok 23\n" | "ok \x{0}\x{0}\n", "ok 23\n");
is ("o\x{0} \x{0}4\x{0}" ^ "\x{0}k\x{0}2\x{0}\n", "ok 24\n");

#
is (sprintf("%vd", v4095 & v801), 801);
is (sprintf("%vd", v4095 | v801), 4095);
is (sprintf("%vd", v4095 ^ v801), 3294);

#
is (sprintf("%vd", v4095.801.4095 & v801.4095), '801.801');
is (sprintf("%vd", v4095.801.4095 | v801.4095), '4095.4095.4095');
is (sprintf("%vd", v801.4095 ^ v4095.801.4095), '3294.3294.4095');
#
is (sprintf("%vd", v120.300 & v200.400), '72.256');
is (sprintf("%vd", v120.300 | v200.400), '248.444');
is (sprintf("%vd", v120.300 ^ v200.400), '176.188');
#
{
    my $a = v120.300;
    my $b = v200.400;
    $a ^= $b;
    is (sprintf("%vd", $a), '176.188');
}
{
    my $a = v120.300;
    my $b = v200.400;
    $a |= $b;
    is (sprintf("%vd", $a), '248.444');
}

#
# UTF8 ~ behaviour
#

{
    my @@not36;

    for (0x100...0xFFF) {
    $a = ~(chr $_);
        push @@not36, sprintf("%#03X", $_)
            if $a ne chr(~$_) or length($a) != 1 or ~$a ne chr($_);
    }
    is (join (', ', @@not36), '');

    my @@not37;

    for my $i (0xEEE...0xF00) {
        for my $j (0x0..0x120) {
            $a = ~(chr ($i) . chr $j);
                push @@not37, sprintf("%#03X %#03X", $i, $j)
                    if $a ne chr(~$i).chr(~$j) or
                    length($a) != 2 or
                    ~$a ne chr($i).chr($j);
        }
    }
    is (join (', ', @@not37), '');

    is (~chr(~0), "\0");


    my @@not39;

    for my $i (0x100..0x120) {
        for my $j (0x100...0x120) {
            push @@not39, sprintf("%#03X %#03X", $i, $j)
                if ~(chr($i)|chr($j)) ne (~chr($i)&~chr($j));
        }
    }
    is (join (', ', @@not39), '');

    my @@not40;

    for my $i (0x100..0x120) {
        for my $j (0x100...0x120) {
            push @@not40, sprintf("%#03X %#03X", $i, $j)
                if ~(chr($i)&chr($j)) ne (~chr($i)|~chr($j));
        }
    }
    is (join (', ', @@not40), '');
}


# More variations on 19 and 22.
is ("ok \xFF\x{FF}\n" & "ok 41\n", "ok 41\n");
is ("ok \x{FF}\xFF\n" & "ok 42\n", "ok 42\n");

# Tests to see if you really can do casts negative floats to unsigned properly
$neg1 = -1.0;
ok (~ $neg1 == 0);
$neg7 = -7.0;
ok (~ $neg7 == 6);


# double magic tests

sub TIESCALAR { bless { value => $_[1], orig => $_[1] } }
sub STORE { $_[0]{store}++; $_[0]{value} = $_[1] }
sub FETCH { $_[0]{fetch}++; $_[0]{value} }
sub stores { tied($_[0])->{value} = tied($_[0])->{orig};
             delete(tied($_[0])->{store}) || 0 }
sub fetches { delete(tied($_[0])->{fetch}) || 0 }

# numeric double magic tests

tie $x, "main", 1;
tie $y, "main", 3;

is(($x | $y), 3);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x & $y), 1);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x ^ $y), 2);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x |= $y), 3);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x &= $y), 1);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x ^= $y), 2);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(~~$y, 3);
is(fetches($y), 1);
is(stores($y), 0);

{ use integer;

is(($x | $y), 3);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x & $y), 1);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x ^ $y), 2);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x |= $y), 3);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x &= $y), 1);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x ^= $y), 2);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(~$y, -4);
is(fetches($y), 1);
is(stores($y), 0);

} # end of use integer;

# stringwise double magic tests

tie $x, "main", "a";
tie $y, "main", "c";

is(($x | $y), ("a" | "c"));
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x & $y), ("a" & "c"));
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x ^ $y), ("a" ^ "c"));
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x |= $y), ("a" | "c"));
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x &= $y), ("a" & "c"));
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x ^= $y), ("a" ^ "c"));
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(~~$y, "c");
is(fetches($y), 1);
is(stores($y), 0);

$a = "\0\x{100}"; chop($a);
ok(utf8::is_utf8($a)); # make sure UTF8 flag is still there
$a = ~$a;
is($a, "\xFF", "~ works with utf-8");

# [rt.perl.org 33003]
# This would cause a segfault without malloc wrap
SKIP: {
  skip "No malloc wrap checks" unless $Config::Config{usemallocwrap};
  like( runperl(prog => 'eval q($#a>>=1); print 1'), qr/^1\n?/ );
}

# [perl #37616] Bug in &= (string) and/or m//
{
    $a = "aa";
    $a &= "a";
    ok($a =~ /a+$/, 'ASCII "a" is NUL-terminated');

    $b = "bb\x{100}";
    $b &= "b";
    ok($b =~ /b+$/, 'Unicode "b" is NUL-terminated');
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $c = $a | $b;
    is($c, chr(0x1FF) x 0xFF . chr(0x101) x 2);

    $c = $b | $a;
    is($c, chr(0x1FF) x 0xFF . chr(0x101) x 2);

    $c = $a & $b;
    is($c, chr(0x001) x 0x0FF);

    $c = $b & $a;
    is($c, chr(0x001) x 0x0FF);

    $c = $a ^ $b;
    is($c, chr(0x1FE) x 0x0FF . chr(0x101) x 2);

    $c = $b ^ $a;
    is($c, chr(0x1FE) x 0x0FF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $a |= $b;
    is($a, chr(0x1FF) x 0xFF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $b |= $a;
    is($b, chr(0x1FF) x 0xFF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $a &= $b;
    is($a, chr(0x001) x 0x0FF);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $b &= $a;
    is($b, chr(0x001) x 0x0FF);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $a ^= $b;
    is($a, chr(0x1FE) x 0x0FF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $b ^= $a;
    is($b, chr(0x1FE) x 0x0FF . chr(0x101) x 2);
}


# New string- and number-specific bitwise ops
{
  use feature "bitwise";
  no warnings "experimental::bitwise";
  is "22" & "66", 2,    'numeric & with strings';
  is "22" | "66", 86,   'numeric | with strings';
  is "22" ^ "66", 84,   'numeric ^ with strings';
  is ~"22" & 0xff, 233, 'numeric ~ with string';
  is 22 &. 66, 22,     '&. with numbers';
  is 22 |. 66, 66,     '|. with numbers';
  is 22 ^. 66, "\4\4", '^. with numbers';
  if ($::IS_EBCDIC) {
    # ord('2') is 0xF2 on EBCDIC
    is ~.22, "\x0d\x0d", '~. with number';
  }
  else {
    # ord('2') is 0x32 on ASCII
    is ~.22, "\xcd\xcd", '~. with number';
  }
  $_ = "22";
  is $_ &= "66", 2,  'numeric &= with strings';
  $_ = "22";
  is $_ |= "66", 86, 'numeric |= with strings';
  $_ = "22";
  is $_ ^= "66", 84, 'numeric ^= with strings';
  $_ = 22;
  is $_ &.= 66, 22,     '&.= with numbers';
  $_ = 22;
  is $_ |.= 66, 66,     '|.= with numbers';
  $_ = 22;
  is $_ ^.= 66, "\4\4", '^.= with numbers';

 # signed vs. unsigned
 ok ((~0 > 0 && do { use integer; ~0 } == -1));

 my $bits = 0;
 for (my $i = ~0; $i; $i >>= 1) { ++$bits; }
 my $cusp = 1 << ($bits - 1);

 ok (($cusp & -1) > 0 && do { use integer; $cusp & -1 } < 0);
 ok (($cusp | 1) > 0 && do { use integer; $cusp | 1 } < 0);
 ok (($cusp ^ 1) > 0 && do { use integer; $cusp ^ 1 } < 0);
 ok ((1 << ($bits - 1)) == $cusp &&
     do { use integer; 1 << ($bits - 1) } == -$cusp);
 ok (($cusp >> 1) == ($cusp / 2) &&
    do { use integer; abs($cusp >> 1) } == ($cusp / 2));
}

# ref tests

my %res;

for my $str ("x", "\x{100}") {
    for my $chr (qw/S A H G X ( * F/) {
        for my $op (qw/| & ^/) {
            my $co = ord $chr;
            my $so = ord $str;
            $res{"$chr$op$str"} = eval qq/chr($co $op $so)/;
        }
    }
    $res{"undef|$str"} = $str;
    $res{"undef&$str"} = "";
    $res{"undef^$str"} = $str;
}

sub PVBM () { "X" }
1 if index "foo", PVBM;

my $warn = 0;
local $^W = 1;
local $SIG{__WARN__} = sub { $warn++ };

sub is_first {
    my ($got, $orig, $op, $str, $name) = @@_;
    is(substr($got, 0, 1), $res{"$orig$op$str"}, $name);
}

for (
    # [object to test, first char of stringification, name]
    [undef,             "undef",    "undef"         ],
    [\1,                "S",        "scalar ref"    ],
    [[],                "A",        "array ref"     ],
    [{},                "H",        "hash ref"      ],
    [qr/x/,             "(",        "qr//"          ],
    [*foo,              "*",        "glob"          ],
    [\*foo,             "G",        "glob ref"      ],
    [PVBM,              "X",        "PVBM"          ],
    [\PVBM,             "S",        "PVBM ref"      ],
    [bless([], "Foo"),  "F",        "object"        ],
) {
    my ($val, $orig, $type) = @@$_;

    for (["x", "string"], ["\x{100}", "utf8"]) {
        my ($str, $desc) = @@$_;

        $warn = 0;

        is_first($val | $str, $orig, "|", $str, "$type | $desc");
        is_first($val & $str, $orig, "&", $str, "$type & $desc");
        is_first($val ^ $str, $orig, "^", $str, "$type ^ $desc");

        is_first($str | $val, $orig, "|", $str, "$desc | $type");
        is_first($str & $val, $orig, "&", $str, "$desc & $type");
        is_first($str ^ $val, $orig, "^", $str, "$desc ^ $type");

        my $new;
        ($new = $val) |= $str;
        is_first($new, $orig, "|", $str, "$type |= $desc");
        ($new = $val) &= $str;
        is_first($new, $orig, "&", $str, "$type &= $desc");
        ($new = $val) ^= $str;
        is_first($new, $orig, "^", $str, "$type ^= $desc");

        ($new = $str) |= $val;
        is_first($new, $orig, "|", $str, "$desc |= $type");
        ($new = $str) &= $val;
        is_first($new, $orig, "&", $str, "$desc &= $type");
        ($new = $str) ^= $val;
        is_first($new, $orig, "^", $str, "$desc ^= $type");

        if ($orig eq "undef") {
            # undef |= and undef ^= don't warn
            is($warn, 10, "no duplicate warnings");
        }
        else {
            is($warn, 0, "no warnings");
        }
    }
}

my $strval;

{
    package Bar;
    use overload q/""/ => sub { $strval };

    package Baz;
    use overload q/|/ => sub { "y" };
}

ok(!eval { 1 if bless([], "Bar") | "x"; 1 },"string overload can't use |");
like($@@, qr/no method found/,               "correct error");
is(eval { bless([], "Baz") | "x" }, "y",    "| overload works");

my $obj = bless [], "Bar";
$strval = "x";
eval { $obj |= "Q" };
$strval = "z";
is("$obj", "z", "|= doesn't break string overload");

# [perl #29070]
$^A .= new version ~$_ for eval sprintf('"\\x%02x"', 0xff - ord("1")),
                           $::IS_EBCDIC ? v13 : v205, # 255 - ord('2')
                           eval sprintf('"\\x%02x"', 0xff - ord("3"));
is $^A, "123", '~v0 clears vstring magic on retval';

{
    my $w = $Config::Config{ivsize} * 8;

    fail("unexpected w $w") unless $w == 32 || $w == 64;

    is(1 << 1, 2, "UV 1 left shift 1");
    is(1 >> 1, 0, "UV 1 right shift 1");

    is(0x7b << -4, 0x007, "UV left negative shift == right shift");
    is(0x7b >> -4, 0x7b0, "UV right negative shift == left shift");

    is(0x7b <<  0, 0x07b, "UV left  zero shift == identity");
    is(0x7b >>  0, 0x07b, "UV right zero shift == identity");

    is(0x0 << -1, 0x0, "zero left  negative shift == zero");
    is(0x0 >> -1, 0x0, "zero right negative shift == zero");

    cmp_ok(1 << $w - 1, '==', 2 ** ($w - 1), # not is() because NV stringify.
       "UV left $w - 1 shift == 2 ** ($w - 1)");
    is(1 << $w,     0, "UV left shift $w     == zero");
    is(1 << $w + 1, 0, "UV left shift $w + 1 == zero");

    is(1 >> $w - 1, 0, "UV right shift $w - 1 == zero");
    is(1 >> $w,     0, "UV right shift $w     == zero");
    is(1 >> $w + 1, 0, "UV right shift $w + 1 == zero");

    # Negative shiftees get promoted to UVs before shifting.  This is
    # not necessarily the ideal behavior, but that is what is happening.
    if ($w == 64) {
        no warnings "portable";
        no warnings "overflow"; # prevent compile-time warning for ivsize=4
        is(-1 << 1, 0xFFFF_FFFF_FFFF_FFFE,
           "neg UV (sic) left shift  = 0xFF..E");
        is(-1 >> 1, 0x7FFF_FFFF_FFFF_FFFF,
           "neg UV (sic) right right = 0x7F..F");
    } elsif ($w == 32) {
        no warnings "portable";
        is(-1 << 1, 0xFFFF_FFFE, "neg left shift  == 0xFF..E");
        is(-1 >> 1, 0x7FFF_FFFF, "neg right right == 0x7F..F");
    }

    {
        # 'use integer' means use IVs instead of UVs.
        use integer;

        # No surprises here.
        is(1 << 1, 2, "IV 1 left shift 1  == 2");
        is(1 >> 1, 0, "IV 1 right shift 1 == 0");

        # The left overshift should behave like without 'use integer',
        # that is, return zero.
        is(1 << $w,     0, "IV 1 left shift $w     == 0");
        is(1 << $w + 1, 0, "IV 1 left shift $w + 1 == 0");
        is(-1 << $w,     0, "IV -1 left shift $w     == 0");
        is(-1 << $w + 1, 0, "IV -1 left shift $w + 1 == 0");

        # Even for negative IVs, left shift is multiplication.
        # But right shift should display the stuckiness to -1.
        is(-1 <<      1, -2, "IV -1 left shift       1 == -2");
        is(-1 >>      1, -1, "IV -1 right shift      1 == -1");

        # As for UVs, negative shifting means the reverse shift.
        is(-1 <<     -1, -1, "IV -1 left shift      -1 == -1");
        is(-1 >>     -1, -2, "IV -1 right shift     -1 == -2");

        # Test also at and around wordsize, expect stuckiness to -1.
        is(-1 >> $w - 1, -1, "IV -1 right shift $w - 1 == -1");
        is(-1 >> $w,     -1, "IV -1 right shift $w     == -1");
        is(-1 >> $w + 1, -1, "IV -1 right shift $w + 1 == -1");
    }
}
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d7 3
d13 1
a13 1
    require "./test.pl";
d21 1
a21 1
plan tests => 174 + (10*13*2) + 5;
d69 19
a87 13
# string constants
sub _and($) { $_[0] & "+0" }
sub _oar($) { $_[0] | "+0" }
sub _xor($) { $_[0] ^ "+0" }
is _and "waf", '# ',  'str var & const str'; # These three
is _and  0,    '0',   'num var & const str';    # are from
is _and "waf", '# ',  'str var & const str again'; # [perl #20661]
is _oar "yit", '{yt', 'str var | const str';
is _oar  0,    '0',   'num var | const str';
is _oar "yit", '{yt', 'str var | const str again';
is _xor "yit", 'RYt', 'str var ^ const str';
is _xor  0,    '0',   'num var ^ const str';
is _xor "yit", 'RYt', 'str var ^ const str again';
d125 12
a136 8
my $a = v120.300;
my $b = v200.400;
$a ^= $b;
is (sprintf("%vd", $a), '176.188');
my $a = v120.300;
my $b = v200.400;
$a |= $b;
is (sprintf("%vd", $a), '248.444');
d142 2
a143 1
my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;
d145 6
a150 1
my @@not36;
d152 1
a152 12
for (0x100...0xFFF) {
  $a = ~(chr $_);
  if ($Is_EBCDIC) {
      push @@not36, sprintf("%#03X", $_)
          if $a ne chr(~$_) or length($a) != 1;
  }
  else {
      push @@not36, sprintf("%#03X", $_)
          if $a ne chr(~$_) or length($a) != 1 or ~$a ne chr($_);
  }
}
is (join (', ', @@not36), '');
d154 8
a161 9
my @@not37;

for my $i (0xEEE...0xF00) {
  for my $j (0x0..0x120) {
    $a = ~(chr ($i) . chr $j);
    if ($Is_EBCDIC) {
        push @@not37, sprintf("%#03X %#03X", $i, $j)
	    if $a ne chr(~$i).chr(~$j) or
	       length($a) != 2;
d163 1
a163 9
    else {
        push @@not37, sprintf("%#03X %#03X", $i, $j)
	    if $a ne chr(~$i).chr(~$j) or
	       length($a) != 2 or 
               ~$a ne chr($i).chr($j);
    }
  }
}
is (join (', ', @@not37), '');
d165 1
a165 4
SKIP: {
  skip "EBCDIC" if $Is_EBCDIC;
  is (~chr(~0), "\0");
}
d168 1
a168 1
my @@not39;
d170 5
a174 4
for my $i (0x100..0x120) {
    for my $j (0x100...0x120) {
	push @@not39, sprintf("%#03X %#03X", $i, $j)
	    if ~(chr($i)|chr($j)) ne (~chr($i)&~chr($j));
d176 1
a176 2
}
is (join (', ', @@not39), '');
d178 1
a178 1
my @@not40;
d180 5
a184 4
for my $i (0x100..0x120) {
    for my $j (0x100...0x120) {
	push @@not40, sprintf("%#03X %#03X", $i, $j)
	    if ~(chr($i)&chr($j)) ne (~chr($i)|~chr($j));
d186 1
a187 1
is (join (', ', @@not40), '');
d353 1
a353 1
  like( runperl(prog => 'eval q($#a>>=1); print 1'), "^1\n?" );
a437 4
# update to pp_complement() via Coverity
SKIP: {
  # UTF-EBCDIC is limited to 0x7fffffff and can't encode ~0.
  skip "EBCDIC" if $Is_EBCDIC;
d439 46
a484 20
  my $str = "\x{10000}\x{800}";
  # U+10000 is four bytes in UTF-8/UTF-EBCDIC.
  # U+0800 is three bytes in UTF-8/UTF-EBCDIC.

  no warnings "utf8";
  { use bytes; $str =~ s/\C\C\z//; }

  # it's really bogus that (~~malformed) is \0.
  my $ref = "\x{10000}\0";
  is(~~$str, $ref);

  # same test, but this time with a longer replacement string that
  # exercises a different branch in pp_subsr()

  $str = "\x{10000}\x{800}";
  { use bytes; $str =~ s/\C\C\z/\0\0\0/; }

  # it's also bogus that (~~malformed) is \0\0\0\0.
  my $ref = "\x{10000}\0\0\0\0";
  is(~~$str, $ref, "use bytes with long replacement");
d505 1
a505 1
index "foo", PVBM;
d579 1
a579 1
ok(!eval { bless([], "Bar") | "x"; 1 },     "string overload can't use |");
d590 3
a592 1
$^A .= new version ~$_ for "\xce", v205, "\xcc";
d594 72
@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@d18 1
a18 1
plan tests => 161 + (10*13*2) + 4;
d66 26
d456 10
d569 4
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d18 1
a18 1
plan tests => 161;
d431 102
@


1.7
log
@merge in perl 5.8.8
@
text
@d18 1
a18 1
plan tests => 49;
d178 143
d342 88
@


1.6
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d11 1
d18 1
a18 1
plan tests => 46;
d182 18
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 1
d13 5
a17 1
print "1..44\n";
d20 4
a23 4
print ((0xdead & 0xbeef) == 0x9ead ? "ok 1\n" : "not ok 1\n");
print ((0xdead | 0xbeef) == 0xfeef ? "ok 2\n" : "not ok 2\n");
print ((0xdead ^ 0xbeef) == 0x6042 ? "ok 3\n" : "not ok 3\n");
print ((~0xdead & 0xbeef) == 0x2042 ? "ok 4\n" : "not ok 4\n");
d26 2
a27 2
print ((257 << 7) == 32896 ? "ok 5\n" : "not ok 5\n");
print ((33023 >> 7) == 257 ? "ok 6\n" : "not ok 6\n");
d30 1
a30 2
print ((~0 > 0 && do { use integer; ~0 } == -1)
       ? "ok 7\n" : "not ok 7\n");
d36 8
a43 12
print ((($cusp & -1) > 0 && do { use integer; $cusp & -1 } < 0)
       ? "ok 8\n" : "not ok 8\n");
print ((($cusp | 1) > 0 && do { use integer; $cusp | 1 } < 0)
       ? "ok 9\n" : "not ok 9\n");
print ((($cusp ^ 1) > 0 && do { use integer; $cusp ^ 1 } < 0)
       ? "ok 10\n" : "not ok 10\n");
print (((1 << ($bits - 1)) == $cusp &&
	do { use integer; 1 << ($bits - 1) } == -$cusp)
       ? "ok 11\n" : "not ok 11\n");
print ((($cusp >> 1) == ($cusp / 2) &&
       do { use integer; abs($cusp >> 1) } == ($cusp / 2))
       ? "ok 12\n" : "not ok 12\n");
d50 3
a52 3
print (("AAAAA" & "zzzzz") eq ($Aaz x 5) ? "ok 13\n" : "not ok 13\n");
print (("AAAAA" | "zzzzz") eq ($Aoz x 5) ? "ok 14\n" : "not ok 14\n");
print (("AAAAA" ^ "zzzzz") eq ($Axz x 5) ? "ok 15\n" : "not ok 15\n");
d59 1
a59 1
print (($foo & $bar) eq ($Aaz x 75 ) ? "ok 16\n" : "not ok 16\n");
d61 1
a61 1
print (($foo | $bar) eq ($Aoz x 75 . $zap) ? "ok 17\n" : "not ok 17\n");
d63 1
a63 1
print (($foo ^ $bar) eq ($Axz x 75 . $zap) ? "ok 18\n" : "not ok 18\n");
d66 3
a68 3
print "ok \xFF\xFF\n" & "ok 19\n";
print "ok 20\n" | "ok \0\0\n";
print "o\000 \0001\000" ^ "\000k\0002\000\n";
d71 3
a73 3
print "ok \x{FF}\x{FF}\n" & "ok 22\n";
print "ok 23\n" | "ok \x{0}\x{0}\n";
print "o\x{0} \x{0}4\x{0}" ^ "\x{0}k\x{0}2\x{0}\n";
d76 3
a78 3
print "ok 25\n" if sprintf("%vd", v4095 & v801) eq 801;
print "ok 26\n" if sprintf("%vd", v4095 | v801) eq 4095;
print "ok 27\n" if sprintf("%vd", v4095 ^ v801) eq 3294;
d81 3
a83 3
print "ok 28\n" if sprintf("%vd", v4095.801.4095 & v801.4095) eq '801.801';
print "ok 29\n" if sprintf("%vd", v4095.801.4095 | v801.4095) eq '4095.4095.4095';
print "ok 30\n" if sprintf("%vd", v801.4095 ^ v4095.801.4095) eq '3294.3294.4095';
d85 3
a87 3
print "ok 31\n" if sprintf("%vd", v120.300 & v200.400) eq '72.256';
print "ok 32\n" if sprintf("%vd", v120.300 | v200.400) eq '248.444';
print "ok 33\n" if sprintf("%vd", v120.300 ^ v200.400) eq '176.188';
d92 1
a92 1
print "ok 34\n" if sprintf("%vd", $a) eq '176.188';
d96 1
a96 1
print "ok 35\n" if sprintf("%vd", $a) eq '248.444';
d117 1
a117 5
if (@@not36) {
    print "# test 36 failed\n";
    print "not ";
}
print "ok 36\n";
d137 5
a141 3
if (@@not37) {
    print "# test 37 failed\n";
    print "not ";
a142 1
print "ok 37\n";
a143 2
print "not " unless ~chr(~0) eq "\0" or $Is_EBCDIC;
print "ok 38\n";
d153 1
a153 5
if (@@not39) {
    print "# test 39 failed\n";
    print "not ";
}
print "ok 39\n";
d163 2
a164 5
if (@@not40) {
    print "# test 40 failed\n";
    print "not ";
}
print "ok 40\n";
d167 2
a168 2
print "ok \xFF\x{FF}\n" & "ok 41\n";
print "ok \x{FF}\xFF\n" & "ok 42\n";
d172 1
a172 1
print ((~ $neg1 == 0) ? "ok 43\n" : "not ok 43\n");
d174 7
a180 1
print ((~ $neg7 == 6) ? "ok 44\n" : "not ok 44\n");
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d102 2
d108 8
a115 2
  push @@not36, sprintf("%#03X", $_)
      if $a ne chr(~$_) or length($a) != 1 or ~$a ne chr($_);
d128 11
a138 4
    push @@not37, sprintf("%#03X %#03X", $i, $j)
	if $a ne chr(~$i).chr(~$j) or
	   length($a) != 2 or 
           ~$a ne chr($i).chr($j);
d147 1
a147 1
print "not " unless ~chr(~0) eq "\0";
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d9 1
a9 1
    unshift @@INC, '../lib';
d12 1
a12 1
print "1..30\n";
d42 1
a42 1
	do { use integer; $cusp >> 1 } == -($cusp / 2))
d84 88
@


1.2
log
@perl5.005_03 (stock)
@
text
@d9 1
a9 1
    @@INC = '../lib';
d12 1
a12 1
print "1..18\n";
d65 19
@


1.1
log
@perl 5.004_04
@
text
@d45 4
d50 3
a52 3
print (("AAAAA" & "zzzzz") eq '@@@@@@@@@@' ? "ok 13\n" : "not ok 13\n");
print (("AAAAA" | "zzzzz") eq '{{{{{' ? "ok 14\n" : "not ok 14\n");
print (("AAAAA" ^ "zzzzz") eq ';;;;;' ? "ok 15\n" : "not ok 15\n");
d57 8
a64 3
print (($foo & $bar) eq ('@@'x75 ) ? "ok 16\n" : "not ok 16\n");
print (($foo | $bar) eq ('{'x75 . 'A'x75) ? "ok 17\n" : "not ok 17\n");
print (($foo ^ $bar) eq (';'x75 . 'A'x75) ? "ok 18\n" : "not ok 18\n");
@


1.1.1.1
log
@perl5.005_03
@
text
@a44 4
$Aaz = chr(ord("A") & ord("z"));
$Aoz = chr(ord("A") | ord("z"));
$Axz = chr(ord("A") ^ ord("z"));

d46 3
a48 3
print (("AAAAA" & "zzzzz") eq ($Aaz x 5) ? "ok 13\n" : "not ok 13\n");
print (("AAAAA" | "zzzzz") eq ($Aoz x 5) ? "ok 14\n" : "not ok 14\n");
print (("AAAAA" ^ "zzzzz") eq ($Axz x 5) ? "ok 15\n" : "not ok 15\n");
d53 3
a55 8
$zap = "A" x 75;
# & truncates
print (($foo & $bar) eq ($Aaz x 75 ) ? "ok 16\n" : "not ok 16\n");
# | does not truncate
print (($foo | $bar) eq ($Aoz x 75 . $zap) ? "ok 17\n" : "not ok 17\n");
# ^ does not truncate
print (($foo ^ $bar) eq ($Axz x 75 . $zap) ? "ok 18\n" : "not ok 18\n");

@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d9 1
a9 1
    unshift @@INC, '../lib';
d12 1
a12 1
print "1..30\n";
a64 19
#
print "ok \xFF\xFF\n" & "ok 19\n";
print "ok 20\n" | "ok \0\0\n";
print "o\000 \0001\000" ^ "\000k\0002\000\n";

#
print "ok \x{FF}\x{FF}\n" & "ok 22\n";
print "ok 23\n" | "ok \x{0}\x{0}\n";
print "o\x{0} \x{0}4\x{0}" ^ "\x{0}k\x{0}2\x{0}\n";

#
print "ok 25\n" if sprintf("%vd", v4095 & v801) eq 801;
print "ok 26\n" if sprintf("%vd", v4095 | v801) eq 4095;
print "ok 27\n" if sprintf("%vd", v4095 ^ v801) eq 3294;

#
print "ok 28\n" if sprintf("%vd", v4095.801.4095 & v801.4095) eq '801.801';
print "ok 29\n" if sprintf("%vd", v4095.801.4095 | v801.4095) eq '4095.4095.4095';
print "ok 30\n" if sprintf("%vd", v801.4095 ^ v4095.801.4095) eq '3294.3294.4095';
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d9 1
a9 1
    @@INC = '../lib';
d12 1
a12 1
print "1..44\n";
d42 1
a42 1
       do { use integer; abs($cusp >> 1) } == ($cusp / 2))
a83 88
#
print "ok 31\n" if sprintf("%vd", v120.300 & v200.400) eq '72.256';
print "ok 32\n" if sprintf("%vd", v120.300 | v200.400) eq '248.444';
print "ok 33\n" if sprintf("%vd", v120.300 ^ v200.400) eq '176.188';
#
my $a = v120.300;
my $b = v200.400;
$a ^= $b;
print "ok 34\n" if sprintf("%vd", $a) eq '176.188';
my $a = v120.300;
my $b = v200.400;
$a |= $b;
print "ok 35\n" if sprintf("%vd", $a) eq '248.444';

#
# UTF8 ~ behaviour
#

my @@not36;

for (0x100...0xFFF) {
  $a = ~(chr $_);
  push @@not36, sprintf("%#03X", $_)
      if $a ne chr(~$_) or length($a) != 1 or ~$a ne chr($_);
}
if (@@not36) {
    print "# test 36 failed\n";
    print "not ";
}
print "ok 36\n";

my @@not37;

for my $i (0xEEE...0xF00) {
  for my $j (0x0..0x120) {
    $a = ~(chr ($i) . chr $j);
    push @@not37, sprintf("%#03X %#03X", $i, $j)
	if $a ne chr(~$i).chr(~$j) or
	   length($a) != 2 or 
           ~$a ne chr($i).chr($j);
  }
}
if (@@not37) {
    print "# test 37 failed\n";
    print "not ";
}
print "ok 37\n";

print "not " unless ~chr(~0) eq "\0";
print "ok 38\n";

my @@not39;

for my $i (0x100..0x120) {
    for my $j (0x100...0x120) {
	push @@not39, sprintf("%#03X %#03X", $i, $j)
	    if ~(chr($i)|chr($j)) ne (~chr($i)&~chr($j));
    }
}
if (@@not39) {
    print "# test 39 failed\n";
    print "not ";
}
print "ok 39\n";

my @@not40;

for my $i (0x100..0x120) {
    for my $j (0x100...0x120) {
	push @@not40, sprintf("%#03X %#03X", $i, $j)
	    if ~(chr($i)&chr($j)) ne (~chr($i)|~chr($j));
    }
}
if (@@not40) {
    print "# test 40 failed\n";
    print "not ";
}
print "ok 40\n";

# More variations on 19 and 22.
print "ok \xFF\x{FF}\n" & "ok 41\n";
print "ok \x{FF}\xFF\n" & "ok 42\n";

# Tests to see if you really can do casts negative floats to unsigned properly
$neg1 = -1.0;
print ((~ $neg1 == 0) ? "ok 43\n" : "not ok 43\n");
$neg7 = -7.0;
print ((~ $neg7 == 6) ? "ok 44\n" : "not ok 44\n");
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a101 2
my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;

d106 2
a107 8
  if ($Is_EBCDIC) {
      push @@not36, sprintf("%#03X", $_)
          if $a ne chr(~$_) or length($a) != 1;
  }
  else {
      push @@not36, sprintf("%#03X", $_)
          if $a ne chr(~$_) or length($a) != 1 or ~$a ne chr($_);
  }
d120 4
a123 11
    if ($Is_EBCDIC) {
        push @@not37, sprintf("%#03X %#03X", $i, $j)
	    if $a ne chr(~$i).chr(~$j) or
	       length($a) != 2;
    }
    else {
        push @@not37, sprintf("%#03X %#03X", $i, $j)
	    if $a ne chr(~$i).chr(~$j) or
	       length($a) != 2 or 
               ~$a ne chr($i).chr($j);
    }
d132 1
a132 1
print "not " unless ~chr(~0) eq "\0" or $Is_EBCDIC;
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@a9 1
    require "./test.pl";
d12 1
a12 5
# Tests don't have names yet.
# If you find tests are failing, please try adding names to tests to track
# down where the failure is, and supply your new names as a patch.
# (Just-in-time test naming)
plan tests => 46;
d15 4
a18 4
ok ((0xdead & 0xbeef) == 0x9ead);
ok ((0xdead | 0xbeef) == 0xfeef);
ok ((0xdead ^ 0xbeef) == 0x6042);
ok ((~0xdead & 0xbeef) == 0x2042);
d21 2
a22 2
ok ((257 << 7) == 32896);
ok ((33023 >> 7) == 257);
d25 2
a26 1
ok ((~0 > 0 && do { use integer; ~0 } == -1));
d32 12
a43 8

ok (($cusp & -1) > 0 && do { use integer; $cusp & -1 } < 0);
ok (($cusp | 1) > 0 && do { use integer; $cusp | 1 } < 0);
ok (($cusp ^ 1) > 0 && do { use integer; $cusp ^ 1 } < 0);
ok ((1 << ($bits - 1)) == $cusp &&
    do { use integer; 1 << ($bits - 1) } == -$cusp);
ok (($cusp >> 1) == ($cusp / 2) &&
    do { use integer; abs($cusp >> 1) } == ($cusp / 2));
d50 3
a52 3
is (("AAAAA" & "zzzzz"), ($Aaz x 5));
is (("AAAAA" | "zzzzz"), ($Aoz x 5));
is (("AAAAA" ^ "zzzzz"), ($Axz x 5));
d59 1
a59 1
is (($foo & $bar), ($Aaz x 75 ));
d61 1
a61 1
is (($foo | $bar), ($Aoz x 75 . $zap));
d63 1
a63 1
is (($foo ^ $bar), ($Axz x 75 . $zap));
d66 3
a68 3
is ("ok \xFF\xFF\n" & "ok 19\n", "ok 19\n");
is ("ok 20\n" | "ok \0\0\n", "ok 20\n");
is ("o\000 \0001\000" ^ "\000k\0002\000\n", "ok 21\n");
d71 3
a73 3
is ("ok \x{FF}\x{FF}\n" & "ok 22\n", "ok 22\n");
is ("ok 23\n" | "ok \x{0}\x{0}\n", "ok 23\n");
is ("o\x{0} \x{0}4\x{0}" ^ "\x{0}k\x{0}2\x{0}\n", "ok 24\n");
d76 3
a78 3
is (sprintf("%vd", v4095 & v801), 801);
is (sprintf("%vd", v4095 | v801), 4095);
is (sprintf("%vd", v4095 ^ v801), 3294);
d81 3
a83 3
is (sprintf("%vd", v4095.801.4095 & v801.4095), '801.801');
is (sprintf("%vd", v4095.801.4095 | v801.4095), '4095.4095.4095');
is (sprintf("%vd", v801.4095 ^ v4095.801.4095), '3294.3294.4095');
d85 3
a87 3
is (sprintf("%vd", v120.300 & v200.400), '72.256');
is (sprintf("%vd", v120.300 | v200.400), '248.444');
is (sprintf("%vd", v120.300 ^ v200.400), '176.188');
d92 1
a92 1
is (sprintf("%vd", $a), '176.188');
d96 1
a96 1
is (sprintf("%vd", $a), '248.444');
d117 5
a121 1
is (join (', ', @@not36), '');
d141 3
a143 5
is (join (', ', @@not37), '');

SKIP: {
  skip "EBCDIC" if $Is_EBCDIC;
  is (~chr(~0), "\0");
d145 1
d147 2
d158 5
a162 1
is (join (', ', @@not39), '');
d172 5
a176 2
is (join (', ', @@not40), '');

d179 2
a180 2
is ("ok \xFF\x{FF}\n" & "ok 41\n", "ok 41\n");
is ("ok \x{FF}\xFF\n" & "ok 42\n", "ok 42\n");
d184 1
a184 1
ok (~ $neg1 == 0);
d186 1
a186 7
ok (~ $neg7 == 6);


$a = "\0\x{100}"; chop($a);
ok(utf8::is_utf8($a)); # make sure UTF8 flag is still there
$a = ~$a;
is($a, "\xFF", "~ works with utf-8");
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@a10 1
    require Config;
d17 1
a17 1
plan tests => 49;
a180 18

# [rt.perl.org 33003]
# This would cause a segfault without malloc wrap
SKIP: {
  skip "No malloc wrap checks" unless $Config::Config{usemallocwrap};
  like( runperl(prog => 'eval q($#a>>=1); print 1'), "^1\n?" );
}

# [perl #37616] Bug in &= (string) and/or m//
{
    $a = "aa";
    $a &= "a";
    ok($a =~ /a+$/, 'ASCII "a" is NUL-terminated');

    $b = "bb\x{100}";
    $b &= "b";
    ok($b =~ /b+$/, 'Unicode "b" is NUL-terminated');
}
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d18 1
a18 1
plan tests => 161;
a177 143
# double magic tests

sub TIESCALAR { bless { value => $_[1], orig => $_[1] } }
sub STORE { $_[0]{store}++; $_[0]{value} = $_[1] }
sub FETCH { $_[0]{fetch}++; $_[0]{value} }
sub stores { tied($_[0])->{value} = tied($_[0])->{orig};
             delete(tied($_[0])->{store}) || 0 }
sub fetches { delete(tied($_[0])->{fetch}) || 0 }

# numeric double magic tests

tie $x, "main", 1;
tie $y, "main", 3;

is(($x | $y), 3);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x & $y), 1);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x ^ $y), 2);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x |= $y), 3);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x &= $y), 1);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x ^= $y), 2);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(~~$y, 3);
is(fetches($y), 1);
is(stores($y), 0);

{ use integer;

is(($x | $y), 3);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x & $y), 1);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x ^ $y), 2);
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x |= $y), 3);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x &= $y), 1);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x ^= $y), 2);
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(~$y, -4);
is(fetches($y), 1);
is(stores($y), 0);

} # end of use integer;

# stringwise double magic tests

tie $x, "main", "a";
tie $y, "main", "c";

is(($x | $y), ("a" | "c"));
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x & $y), ("a" & "c"));
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x ^ $y), ("a" ^ "c"));
is(fetches($x), 1);
is(fetches($y), 1);
is(stores($x), 0);
is(stores($y), 0);

is(($x |= $y), ("a" | "c"));
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x &= $y), ("a" & "c"));
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(($x ^= $y), ("a" ^ "c"));
is(fetches($x), 2);
is(fetches($y), 1);
is(stores($x), 1);
is(stores($y), 0);

is(~~$y, "c");
is(fetches($y), 1);
is(stores($y), 0);

a198 88
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $c = $a | $b;
    is($c, chr(0x1FF) x 0xFF . chr(0x101) x 2);

    $c = $b | $a;
    is($c, chr(0x1FF) x 0xFF . chr(0x101) x 2);

    $c = $a & $b;
    is($c, chr(0x001) x 0x0FF);

    $c = $b & $a;
    is($c, chr(0x001) x 0x0FF);

    $c = $a ^ $b;
    is($c, chr(0x1FE) x 0x0FF . chr(0x101) x 2);

    $c = $b ^ $a;
    is($c, chr(0x1FE) x 0x0FF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $a |= $b;
    is($a, chr(0x1FF) x 0xFF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $b |= $a;
    is($b, chr(0x1FF) x 0xFF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $a &= $b;
    is($a, chr(0x001) x 0x0FF);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $b &= $a;
    is($b, chr(0x001) x 0x0FF);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $a ^= $b;
    is($a, chr(0x1FE) x 0x0FF . chr(0x101) x 2);
}

{
    $a = chr(0x101) x 0x101;
    $b = chr(0x0FF) x 0x0FF;

    $b ^= $a;
    is($b, chr(0x1FE) x 0x0FF . chr(0x101) x 2);
}

# update to pp_complement() via Coverity
SKIP: {
  # UTF-EBCDIC is limited to 0x7fffffff and can't encode ~0.
  skip "EBCDIC" if $Is_EBCDIC;

  my $str = "\x{10000}\x{800}";
  # U+10000 is four bytes in UTF-8/UTF-EBCDIC.
  # U+0800 is three bytes in UTF-8/UTF-EBCDIC.

  no warnings "utf8";
  { use bytes; $str =~ s/\C\C\z//; }

  # it's really bogus that (~~malformed) is \0.
  my $ref = "\x{10000}\0";
  is(~~$str, $ref);
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d18 1
a18 1
plan tests => 161 + (10*13*2) + 4;
a430 102

# ref tests

my %res;

for my $str ("x", "\x{100}") {
    for my $chr (qw/S A H G X ( * F/) {
        for my $op (qw/| & ^/) {
            my $co = ord $chr;
            my $so = ord $str;
            $res{"$chr$op$str"} = eval qq/chr($co $op $so)/;
        }
    }
    $res{"undef|$str"} = $str;
    $res{"undef&$str"} = "";
    $res{"undef^$str"} = $str;
}

sub PVBM () { "X" }
index "foo", PVBM;

my $warn = 0;
local $^W = 1;
local $SIG{__WARN__} = sub { $warn++ };

sub is_first {
    my ($got, $orig, $op, $str, $name) = @@_;
    is(substr($got, 0, 1), $res{"$orig$op$str"}, $name);
}

for (
    # [object to test, first char of stringification, name]
    [undef,             "undef",    "undef"         ],
    [\1,                "S",        "scalar ref"    ],
    [[],                "A",        "array ref"     ],
    [{},                "H",        "hash ref"      ],
    [qr/x/,             "(",        "qr//"          ],
    [*foo,              "*",        "glob"          ],
    [\*foo,             "G",        "glob ref"      ],
    [PVBM,              "X",        "PVBM"          ],
    [\PVBM,             "S",        "PVBM ref"      ],
    [bless([], "Foo"),  "F",        "object"        ],
) {
    my ($val, $orig, $type) = @@$_;

    for (["x", "string"], ["\x{100}", "utf8"]) {
        my ($str, $desc) = @@$_;

        $warn = 0;

        is_first($val | $str, $orig, "|", $str, "$type | $desc");
        is_first($val & $str, $orig, "&", $str, "$type & $desc");
        is_first($val ^ $str, $orig, "^", $str, "$type ^ $desc");

        is_first($str | $val, $orig, "|", $str, "$desc | $type");
        is_first($str & $val, $orig, "&", $str, "$desc & $type");
        is_first($str ^ $val, $orig, "^", $str, "$desc ^ $type");

        my $new;
        ($new = $val) |= $str;
        is_first($new, $orig, "|", $str, "$type |= $desc");
        ($new = $val) &= $str;
        is_first($new, $orig, "&", $str, "$type &= $desc");
        ($new = $val) ^= $str;
        is_first($new, $orig, "^", $str, "$type ^= $desc");

        ($new = $str) |= $val;
        is_first($new, $orig, "|", $str, "$desc |= $type");
        ($new = $str) &= $val;
        is_first($new, $orig, "&", $str, "$desc &= $type");
        ($new = $str) ^= $val;
        is_first($new, $orig, "^", $str, "$desc ^= $type");

        if ($orig eq "undef") {
            # undef |= and undef ^= don't warn
            is($warn, 10, "no duplicate warnings");
        }
        else {
            is($warn, 0, "no warnings");
        }
    }
}

my $strval;

{
    package Bar;
    use overload q/""/ => sub { $strval };

    package Baz;
    use overload q/|/ => sub { "y" };
}

ok(!eval { bless([], "Bar") | "x"; 1 },     "string overload can't use |");
like($@@, qr/no method found/,               "correct error");
is(eval { bless([], "Baz") | "x" }, "y",    "| overload works");

my $obj = bless [], "Bar";
$strval = "x";
eval { $obj |= "Q" };
$strval = "z";
is("$obj", "z", "|= doesn't break string overload");
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d18 1
a18 1
plan tests => 174 + (10*13*2) + 5;
a65 26
# string constants
sub _and($) { $_[0] & "+0" }
sub _oar($) { $_[0] | "+0" }
sub _xor($) { $_[0] ^ "+0" }
is _and "waf", '# ',  'str var & const str'; # These three
is _and  0,    '0',   'num var & const str';    # are from
is _and "waf", '# ',  'str var & const str again'; # [perl #20661]
is _oar "yit", '{yt', 'str var | const str';
is _oar  0,    '0',   'num var | const str';
is _oar "yit", '{yt', 'str var | const str again';
is _xor "yit", 'RYt', 'str var ^ const str';
is _xor  0,    '0',   'num var ^ const str';
is _xor "yit", 'RYt', 'str var ^ const str again';

# But don’t mistake a COW for a constant when assigning to it
%h=(150=>1);
$i=(keys %h)[0];
$i |= 105;
is $i, 255, '[perl #108480] $cow |= number';
$i=(keys %h)[0];
$i &= 105;
is $i, 0, '[perl #108480] $cow &= number';
$i=(keys %h)[0];
$i ^= 105;
is $i, 255, '[perl #108480] $cow ^= number';

a429 10

  # same test, but this time with a longer replacement string that
  # exercises a different branch in pp_subsr()

  $str = "\x{10000}\x{800}";
  { use bytes; $str =~ s/\C\C\z/\0\0\0/; }

  # it's also bogus that (~~malformed) is \0\0\0\0.
  my $ref = "\x{10000}\0\0\0\0";
  is(~~$str, $ref, "use bytes with long replacement");
a532 4

# [perl #29070]
$^A .= new version ~$_ for "\xce", v205, "\xcc";
is $^A, "123", '~v0 clears vstring magic on retval';
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@a6 3
use warnings;
no warnings 'deprecated';

d10 1
a10 1
    require "./test.pl"; require "./charset_tools.pl";
d18 1
a18 1
plan tests => 192 + (10*13*2) + 5 + 29;
d66 13
a78 19
# string constants.  These tests expect the bit patterns of these strings in
# ASCII, so convert to that.
sub _and($) { $_[0] & native_to_uni("+0") }
sub _oar($) { $_[0] | native_to_uni("+0") }
sub _xor($) { $_[0] ^ native_to_uni("+0") }
is _and native_to_uni("waf"), native_to_uni('# '),  'str var & const str'; # [perl #20661]
is _and native_to_uni("waf"), native_to_uni('# '),  'str var & const str again'; # [perl #20661]
is _oar native_to_uni("yit"), native_to_uni('{yt'), 'str var | const str';
is _oar native_to_uni("yit"), native_to_uni('{yt'), 'str var | const str again';
is _xor native_to_uni("yit"), native_to_uni('RYt'), 'str var ^ const str';
is _xor native_to_uni("yit"), native_to_uni('RYt'), 'str var ^ const str again';

SKIP: {
    skip "Converting a numeric doesn't work with EBCDIC unlike the above tests",
         3 if $::IS_EBCDIC;
    is _and  0, '0',   'num var & const str';     # [perl #20661]
    is _oar  0, '0',   'num var | const str';
    is _xor  0, '0',   'num var ^ const str';
}
d116 8
a123 12
{
    my $a = v120.300;
    my $b = v200.400;
    $a ^= $b;
    is (sprintf("%vd", $a), '176.188');
}
{
    my $a = v120.300;
    my $b = v200.400;
    $a |= $b;
    is (sprintf("%vd", $a), '248.444');
}
d129 3
a131 2
{
    my @@not36;
d133 12
a144 6
    for (0x100...0xFFF) {
    $a = ~(chr $_);
        push @@not36, sprintf("%#03X", $_)
            if $a ne chr(~$_) or length($a) != 1 or ~$a ne chr($_);
    }
    is (join (', ', @@not36), '');
d146 1
a146 1
    my @@not37;
d148 13
a160 8
    for my $i (0xEEE...0xF00) {
        for my $j (0x0..0x120) {
            $a = ~(chr ($i) . chr $j);
                push @@not37, sprintf("%#03X %#03X", $i, $j)
                    if $a ne chr(~$i).chr(~$j) or
                    length($a) != 2 or
                    ~$a ne chr($i).chr($j);
        }
d162 3
a164 1
    is (join (', ', @@not37), '');
d166 4
a169 1
    is (~chr(~0), "\0");
d172 1
a172 1
    my @@not39;
d174 4
a177 5
    for my $i (0x100..0x120) {
        for my $j (0x100...0x120) {
            push @@not39, sprintf("%#03X %#03X", $i, $j)
                if ~(chr($i)|chr($j)) ne (~chr($i)&~chr($j));
        }
d179 2
a180 1
    is (join (', ', @@not39), '');
d182 1
a182 1
    my @@not40;
d184 4
a187 5
    for my $i (0x100..0x120) {
        for my $j (0x100...0x120) {
            push @@not40, sprintf("%#03X %#03X", $i, $j)
                if ~(chr($i)&chr($j)) ne (~chr($i)|~chr($j));
        }
a188 1
    is (join (', ', @@not40), '');
d190 1
d356 1
a356 1
  like( runperl(prog => 'eval q($#a>>=1); print 1'), qr/^1\n?/ );
d441 11
d453 13
a465 46
# New string- and number-specific bitwise ops
{
  use feature "bitwise";
  no warnings "experimental::bitwise";
  is "22" & "66", 2,    'numeric & with strings';
  is "22" | "66", 86,   'numeric | with strings';
  is "22" ^ "66", 84,   'numeric ^ with strings';
  is ~"22" & 0xff, 233, 'numeric ~ with string';
  is 22 &. 66, 22,     '&. with numbers';
  is 22 |. 66, 66,     '|. with numbers';
  is 22 ^. 66, "\4\4", '^. with numbers';
  if ($::IS_EBCDIC) {
    # ord('2') is 0xF2 on EBCDIC
    is ~.22, "\x0d\x0d", '~. with number';
  }
  else {
    # ord('2') is 0x32 on ASCII
    is ~.22, "\xcd\xcd", '~. with number';
  }
  $_ = "22";
  is $_ &= "66", 2,  'numeric &= with strings';
  $_ = "22";
  is $_ |= "66", 86, 'numeric |= with strings';
  $_ = "22";
  is $_ ^= "66", 84, 'numeric ^= with strings';
  $_ = 22;
  is $_ &.= 66, 22,     '&.= with numbers';
  $_ = 22;
  is $_ |.= 66, 66,     '|.= with numbers';
  $_ = 22;
  is $_ ^.= 66, "\4\4", '^.= with numbers';

 # signed vs. unsigned
 ok ((~0 > 0 && do { use integer; ~0 } == -1));

 my $bits = 0;
 for (my $i = ~0; $i; $i >>= 1) { ++$bits; }
 my $cusp = 1 << ($bits - 1);

 ok (($cusp & -1) > 0 && do { use integer; $cusp & -1 } < 0);
 ok (($cusp | 1) > 0 && do { use integer; $cusp | 1 } < 0);
 ok (($cusp ^ 1) > 0 && do { use integer; $cusp ^ 1 } < 0);
 ok ((1 << ($bits - 1)) == $cusp &&
     do { use integer; 1 << ($bits - 1) } == -$cusp);
 ok (($cusp >> 1) == ($cusp / 2) &&
    do { use integer; abs($cusp >> 1) } == ($cusp / 2));
d486 1
a486 1
1 if index "foo", PVBM;
d560 1
a560 1
ok(!eval { 1 if bless([], "Bar") | "x"; 1 },"string overload can't use |");
d571 1
a571 3
$^A .= new version ~$_ for eval sprintf('"\\x%02x"', 0xff - ord("1")),
                           $::IS_EBCDIC ? v13 : v205, # 255 - ord('2')
                           eval sprintf('"\\x%02x"', 0xff - ord("3"));
a572 72

{
    my $w = $Config::Config{ivsize} * 8;

    fail("unexpected w $w") unless $w == 32 || $w == 64;

    is(1 << 1, 2, "UV 1 left shift 1");
    is(1 >> 1, 0, "UV 1 right shift 1");

    is(0x7b << -4, 0x007, "UV left negative shift == right shift");
    is(0x7b >> -4, 0x7b0, "UV right negative shift == left shift");

    is(0x7b <<  0, 0x07b, "UV left  zero shift == identity");
    is(0x7b >>  0, 0x07b, "UV right zero shift == identity");

    is(0x0 << -1, 0x0, "zero left  negative shift == zero");
    is(0x0 >> -1, 0x0, "zero right negative shift == zero");

    cmp_ok(1 << $w - 1, '==', 2 ** ($w - 1), # not is() because NV stringify.
       "UV left $w - 1 shift == 2 ** ($w - 1)");
    is(1 << $w,     0, "UV left shift $w     == zero");
    is(1 << $w + 1, 0, "UV left shift $w + 1 == zero");

    is(1 >> $w - 1, 0, "UV right shift $w - 1 == zero");
    is(1 >> $w,     0, "UV right shift $w     == zero");
    is(1 >> $w + 1, 0, "UV right shift $w + 1 == zero");

    # Negative shiftees get promoted to UVs before shifting.  This is
    # not necessarily the ideal behavior, but that is what is happening.
    if ($w == 64) {
        no warnings "portable";
        no warnings "overflow"; # prevent compile-time warning for ivsize=4
        is(-1 << 1, 0xFFFF_FFFF_FFFF_FFFE,
           "neg UV (sic) left shift  = 0xFF..E");
        is(-1 >> 1, 0x7FFF_FFFF_FFFF_FFFF,
           "neg UV (sic) right right = 0x7F..F");
    } elsif ($w == 32) {
        no warnings "portable";
        is(-1 << 1, 0xFFFF_FFFE, "neg left shift  == 0xFF..E");
        is(-1 >> 1, 0x7FFF_FFFF, "neg right right == 0x7F..F");
    }

    {
        # 'use integer' means use IVs instead of UVs.
        use integer;

        # No surprises here.
        is(1 << 1, 2, "IV 1 left shift 1  == 2");
        is(1 >> 1, 0, "IV 1 right shift 1 == 0");

        # The left overshift should behave like without 'use integer',
        # that is, return zero.
        is(1 << $w,     0, "IV 1 left shift $w     == 0");
        is(1 << $w + 1, 0, "IV 1 left shift $w + 1 == 0");
        is(-1 << $w,     0, "IV -1 left shift $w     == 0");
        is(-1 << $w + 1, 0, "IV -1 left shift $w + 1 == 0");

        # Even for negative IVs, left shift is multiplication.
        # But right shift should display the stuckiness to -1.
        is(-1 <<      1, -2, "IV -1 left shift       1 == -2");
        is(-1 >>      1, -1, "IV -1 right shift      1 == -1");

        # As for UVs, negative shifting means the reverse shift.
        is(-1 <<     -1, -1, "IV -1 left shift      -1 == -1");
        is(-1 >>     -1, -2, "IV -1 right shift     -1 == -2");

        # Test also at and around wordsize, expect stuckiness to -1.
        is(-1 >> $w - 1, -1, "IV -1 right shift $w - 1 == -1");
        is(-1 >> $w,     -1, "IV -1 right shift $w     == -1");
        is(-1 >> $w + 1, -1, "IV -1 right shift $w + 1 == -1");
    }
}
@


