head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.27;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.19;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.48;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.24;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.23;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.45;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.00;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.35;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.10;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.17;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@perl 5.004_04
@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

#
# various typeglob tests
#

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
}

use warnings;

plan(tests => 276 );

# type coercion on assignment
$foo = 'foo';
$bar = *main::foo;
$bar = $foo;
is(ref(\$bar), 'SCALAR');
$foo = *main::bar;

# type coercion (not) on misc ops

ok($foo);
is(ref(\$foo), 'GLOB');

unlike ($foo, qr/abcd/);
is(ref(\$foo), 'GLOB');

is($foo, '*main::bar');
is(ref(\$foo), 'GLOB');

{
 no warnings;
 ${\*$foo} = undef;
 is(ref(\$foo), 'GLOB', 'no type coercion when assigning to *{} retval');
 $::{phake} = *bar;
 is(
   \$::{phake}, \*{"phake"},
   'symbolic *{} returns symtab entry when FAKE'
 );
 ${\*{"phake"}} = undef;
 is(
   ref(\$::{phake}), 'GLOB',
  'no type coercion when assigning to retval of symbolic *{}'
 );
 $::{phaque} = *bar;
 eval '
   is(
     \$::{phaque}, \*phaque,
     "compile-time *{} returns symtab entry when FAKE"
   );
   ${\*phaque} = undef;
 ';
 is(
   ref(\$::{phaque}), 'GLOB',
  'no type coercion when assigning to retval of compile-time *{}'
 );
}

# type coercion on substitutions that match
$a = *main::foo;
$b = $a;
$a =~ s/^X//;
is(ref(\$a), 'GLOB');
$a =~ s/^\*//;
is($a, 'main::foo');
is(ref(\$b), 'GLOB');

# typeglobs as lvalues
substr($foo, 0, 1) = "XXX";
is(ref(\$foo), 'SCALAR');
is($foo, 'XXXmain::bar');

# returning glob values
sub foo {
  local($bar) = *main::foo;
  $foo = *main::bar;
  return ($foo, $bar);
}

($fuu, $baa) = foo();
ok(defined $fuu);
is(ref(\$fuu), 'GLOB');


ok(defined $baa);
is(ref(\$baa), 'GLOB');

# nested package globs
# NOTE:  It's probably OK if these semantics change, because the
#        fact that %X::Y:: is stored in %X:: isn't documented.
#        (I hope.)

{ package Foo::Bar; no warnings 'once'; $test=1; }
ok(exists $Foo::{'Bar::'});
is($Foo::{'Bar::'}, '*Foo::Bar::');


# test undef operator clearing out entire glob
$foo = 'stuff';
@@foo = qw(more stuff);
%foo = qw(even more random stuff);
undef *foo;
is ($foo, undef);
is (scalar @@foo, 0);
is (scalar %foo, 0);

{
    # test warnings from assignment of undef to glob
    my $msg = '';
    local $SIG{__WARN__} = sub { $msg = $_[0] };
    use warnings;
    *foo = 'bar';
    is($msg, '');
    *foo = undef;
    like($msg, qr/Undefined value assigned to typeglob/);

    no warnings 'once';
    # test warnings for converting globs to other forms
    my $copy = *PWOMPF;
    foreach ($copy, *SKREEE) {
	$msg = '';
	my $victim = sprintf "%d", $_;
	like($msg, qr/Argument "\*main::[A-Z]{6}" isn't numeric in sprintf/,
	     "Warning on conversion to IV");
	is($victim, 0);

	$msg = '';
	$victim = sprintf "%u", $_;
	like($msg, qr/Argument "\*main::[A-Z]{6}" isn't numeric in sprintf/,
	     "Warning on conversion to UV");
	is($victim, 0);

	$msg = '';
	$victim = sprintf "%e", $_;
	like($msg, qr/Argument "\*main::[A-Z]{6}" isn't numeric in sprintf/,
	     "Warning on conversion to NV");
	like($victim, qr/^0\.0+E\+?00/i, "Expect floating point zero");

	$msg = '';
	$victim = sprintf "%s", $_;
	is($msg, '', "No warning on stringification");
	is($victim, '' . $_);
    }
}

my $test = curr_test();
# test *glob{THING} syntax
$x = "ok $test\n";
++$test;
@@x = ("ok $test\n");
++$test;
%x = ("ok $test" => "\n");
++$test;
sub x { "ok $test\n" }
print ${*x{SCALAR}}, @@{*x{ARRAY}}, %{*x{HASH}}, &{*x{CODE}};
# This needs to go here, after the print, as sub x will return the current
# value of test
++$test;
format x =
XXX This text isn't used. Should it be?
.
curr_test($test);

is (ref *x{FORMAT}, "FORMAT");
is ("@@{sub { *_{ARRAY} }->(1..3)}", "1 2 3",
    'returning *_{ARRAY} from sub');
*x = *STDOUT;
is (*{*x{GLOB}}, "*main::STDOUT");

{
    my $test = curr_test();

    print {*x{IO}} "ok $test\n";
    ++$test;

    my $warn;
    local $SIG{__WARN__} = sub {
	$warn .= $_[0];
    };
    my $val = *x{FILEHANDLE};

    # deprecation warning removed in v5.23 -- rjbs, 2015-12-31
    # https://rt.perl.org/Ticket/Display.html?id=127060
    print {*x{IO}} (! defined $warn
		    ? "ok $test\n" : "not ok $test\n");
    curr_test(++$test);
}

is *x{NAME}, 'x', '*foo{NAME}';
is *x{PACKAGE}, 'main', '*foo{PACKAGE}';
{ no warnings 'once'; *x = *Foo::y; }
is *x, '*Foo::y', 'glob stringifies as assignee after glob-to-glob assign';
is *x{NAME}, 'x', 'but *foo{NAME} still returns the original name';
is *x{PACKAGE}, 'main', 'and *foo{PACKAGE} the original package';

{
    # test if defined() doesn't create any new symbols

    my $a = "SYM000";
    ok(!defined *{$a});

    ok(!defined ${$a});
    ok(!defined *{$a});

    ok(!defined &{$a});
    ok(!defined *{$a});

    my $state = "not";
    *{$a} = sub { $state = "ok" };
    ok(defined &{$a});
    ok(defined *{$a});
    &{$a};
    is ($state, 'ok');
}

{
    # although it *should* if you're talking about magicals

    my $a = "]";
    ok(defined *{$a});
    ok(defined ${$a});

    $a = "1";
    "o" =~ /(o)/;
    ok(${$a});
    ok(defined *{$a});
    $a = "2";
    ok(!${$a});
    ok(defined *{$a});
    $a = "1x";
    ok(!defined ${$a});
    ok(!defined *{$a});
    $a = "11";
    "o" =~ /(((((((((((o)))))))))))/;
    ok(${$a});
    ok(defined *{$a});
}

# [ID 20010526.001] localized glob loses value when assigned to

$j=1; %j=(a=>1); @@j=(1); local *j=*j; *j = sub{};

is($j, 1);
is($j{a}, 1);
is($j[0], 1);

{
    # does pp_readline() handle glob-ness correctly?
    my $g = *foo;
    $g = <DATA>;
    is ($g, "Perl\n");
}

{
    my $w = '';
    local $SIG{__WARN__} = sub { $w = $_[0] };
    sub abc1 ();
    local *abc1 = sub { };
    is ($w, '');
    sub abc2 ();
    local *abc2;
    *abc2 = sub { };
    is ($w, '');
    sub abc3 ();
    *abc3 = sub { };
    like ($w, qr/Prototype mismatch/);
}

{
    # [17375] rcatline to formerly-defined undef was broken. Fixed in
    # do_readline by checking SvOK. AMS, 20020918
    my $x = "not ";
    $x  = undef;
    $x .= <DATA>;
    is ($x, "Rules\n");
}

{
    # test the assignment of a GLOB to an LVALUE
    my $e = '';
    local $SIG{__DIE__} = sub { $e = $_[0] };
    my %v;
    sub f { $_[0] = 0; $_[0] = "a"; $_[0] = *DATA }
    f($v{v});
    is ($v{v}, '*main::DATA');
    is (ref\$v{v}, 'GLOB', 'lvalue assignment preserves globs');
    my $x = readline $v{v};
    is ($x, "perl\n");
    is ($e, '', '__DIE__ handler never called');
}

{
    my $e = '';
    # GLOB assignment to tied element
    local $SIG{__DIE__} = sub { $e = $_[0] };
    sub T::TIEARRAY  { bless [] => "T" }
    sub T::STORE     { $_[0]->[ $_[1] ] = $_[2] }
    sub T::FETCH     { $_[0]->[ $_[1] ] }
    sub T::FETCHSIZE { @@{$_[0]} }
    tie my @@ary => "T";
    $ary[0] = *DATA;
    is ($ary[0], '*main::DATA');
    is (
      ref\tied(@@ary)->[0], 'GLOB',
     'tied elem assignment preserves globs'
    );
    is ($e, '', '__DIE__ handler not called');
    my $x = readline $ary[0];
    is($x, "rocks\n");
    is ($e, '', '__DIE__ handler never called');
}

{
    # Need some sort of die or warn to get the global destruction text if the
    # bug is still present
    my $output = runperl(prog => <<'EOPROG');
package M;
$| = 1;
sub DESTROY {eval {die qq{Farewell $_[0]}}; print $@@}
package main;

bless \$A::B, q{M};
*A:: = \*B::;
EOPROG
    like($output, qr/^Farewell M=SCALAR/, "DESTROY was called");
    unlike($output, qr/global destruction/,
           "unreferenced symbol tables should be cleaned up immediately");
}

# Possibly not the correct test file for these tests.
# There are certain space optimisations implemented via promotion rules to
# GVs

foreach (qw (oonk ga_shloip)) {
    ok(!exists $::{$_}, "no symbols of any sort to start with for $_");
}

# A string in place of the typeglob is promoted to the function prototype
$::{oonk} = "pie";
my $proto = eval 'prototype \&oonk';
die if $@@;
is ($proto, "pie", "String is promoted to prototype");


# A reference to a value is used to generate a constant subroutine
foreach my $value (3, "Perl rules", \42, qr/whatever/, [1,2,3], {1=>2},
		   \*STDIN, \&ok, \undef, *STDOUT) {
    delete $::{oonk};
    $::{oonk} = \$value;
    $proto = eval 'prototype \&oonk';
    die if $@@;
    is ($proto, '', "Prototype for a constant subroutine is empty");

    my $got = eval 'oonk';
    die if $@@;
    is (ref $got, ref $value, "Correct type of value (" . ref($value) . ")");
    is ($got, $value, "Value is correctly set");
}

delete $::{oonk};
$::{oonk} = \"Value";

*{"ga_shloip"} = \&{"oonk"};

is (ref $::{ga_shloip}, 'SCALAR', "Export of proxy constant as is");
is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'ga_shloip', "Value", "Constant has correct value");
is (ref $::{ga_shloip}, 'SCALAR',
    "Inlining of constant doesn't change representation");

delete $::{ga_shloip};

eval 'sub ga_shloip (); 1' or die $@@;
is ($::{ga_shloip}, '', "Prototype is stored as an empty string");

# Check that a prototype expands.
*{"ga_shloip"} = \&{"oonk"};

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'ga_shloip', "Value", "Constant has correct value");
is (ref \$::{ga_shloip}, 'GLOB', "Symbol table has full typeglob");


@@::zwot = ('Zwot!');

# Check that assignment to an existing typeglob works
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"zwot"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'zwot', "Value", "Constant has correct value");
is (ref \$::{zwot}, 'GLOB', "Symbol table has full typeglob");
is (join ('!', @@::zwot), 'Zwot!', "Existing array still in typeglob");

sub spritsits () {
    "Traditional";
}

# Check that assignment to an existing subroutine works
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"spritsits"} = \&{"oonk"};
  like($w, qr/^Constant subroutine main::spritsits redefined/,
       "Redefining a constant sub should warn");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'spritsits', "Value", "Constant has correct value");
is (ref \$::{spritsits}, 'GLOB', "Symbol table has full typeglob");

# Check that assignment to an existing typeglob works
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"plunk"} = [];
  *{"plunk"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'plunk', "Value", "Constant has correct value");
is (ref \$::{plunk}, 'GLOB', "Symbol table has full typeglob");

my $gr = eval '\*plunk' or die;

{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{$gr} = \&{"oonk"};
  is($w, '', "Redefining a constant sub to another constant sub with the same underlying value should not warn (It's just re-exporting, and that was always legal)");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'plunk', "Value", "Constant has correct value");
is (ref \$::{plunk}, 'GLOB', "Symbol table has full typeglob");

# Non-void context should defeat the optimisation, and will cause the original
# to be promoted (what change 26482 intended)
my $result;
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  $result = *{"awkkkkkk"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

is (ref \$result, 'GLOB',
    "Non void assignment should still return a typeglob");

is (ref \$::{oonk}, 'GLOB', "This export does affect original");
is (eval 'plunk', "Value", "Constant has correct value");
is (ref \$::{plunk}, 'GLOB', "Symbol table has full typeglob");

delete $::{oonk};
$::{oonk} = \"Value";

sub non_dangling {
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"zap"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

non_dangling();
is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'zap', "Value", "Constant has correct value");
is (ref $::{zap}, 'SCALAR', "Exported target is also a PCS");

sub dangling {
  local $SIG{__WARN__} = sub { die $_[0] };
  *{"biff"} = \&{"oonk"};
}

dangling();
is (ref \$::{oonk}, 'GLOB', "This export does affect original");
is (eval 'biff', "Value", "Constant has correct value");
is (ref \$::{biff}, 'GLOB', "Symbol table has full typeglob");

$::{yarrow} = [4,5,6];
is join("-", eval "yarrow()"), '4-5-6', 'array ref as stash elem';
is ref $::{yarrow}, "ARRAY", 'stash elem is still array ref after use';
is join("-", eval "&yarrow"), '4-5-6', 'calling const list with &';
is join("-", eval "&yarrow(1..10)"), '4-5-6', 'const list ignores & args';
is prototype "yarrow", "", 'const list has "" prototype';
is eval "yarrow", 3, 'const list in scalar cx returns length';

$::{borage} = \&ok;
eval 'borage("sub ref in stash")' or fail "sub ref in stash";

{
    use vars qw($glook $smek $foof);
    # Check reference assignment isn't affected by the SV type (bug #38439)
    $glook = 3;
    $smek = 4;
    $foof = "halt and cool down";

    my $rv = \*smek;
    is($glook, 3);
    *glook = $rv;
    is($glook, 4);

    my $pv = "";
    $pv = \*smek;
    is($foof, "halt and cool down");
    *foof = $pv;
    is($foof, 4);
}

format =
.

foreach my $value ({1=>2}, *STDOUT{IO}, *STDOUT{FORMAT}) {
    # *STDOUT{IO} returns a reference to a PVIO. As it's blessed, ref returns
    # IO::Handle, which isn't what we want.
    my $type = $value;
    $type =~ s/.*=//;
    $type =~ s/\(.*//;
    delete $::{oonk};
    $::{oonk} = $value;
    $proto = eval 'prototype \&oonk';
    like ($@@, qr/^Cannot convert a reference to $type to typeglob/,
	  "Cannot upgrade ref-to-$type to typeglob");
}

{
    no warnings qw(once uninitialized);
    my $g = \*clatter;
    my $r = eval {no strict; ${*{$g}{SCALAR}}};
    is ($@@, '', "PERL_DONT_CREATE_GVSV shouldn't affect thingy syntax");

    $g = \*vowm;
    $r = eval {use strict; ${*{$g}{SCALAR}}};
    is ($@@, '',
	"PERL_DONT_CREATE_GVSV shouldn't affect thingy syntax under strict");
}

{
    # Bug reported by broquaint on IRC
    *slosh::{HASH}->{ISA}=[];
    slosh->import;
    pass("gv_fetchmeth coped with the unexpected");

    # An audit found these:
    {
	package slosh;
	sub rip {
	    my $s = shift;
	    $s->SUPER::rip;
	}
    }
    eval {slosh->rip;};
    like ($@@, qr/^Can't locate object method "rip"/, "Even with SUPER");

    is(slosh->isa('swoosh'), '');

    $CORE::GLOBAL::{"lock"}=[];
    eval "no warnings; lock";
    like($@@, qr/^Not enough arguments for lock/,
       "Can't trip up general keyword overloading");

    $CORE::GLOBAL::{"readline"}=[];
    eval "<STDOUT> if 0";
    is($@@, '', "Can't trip up readline overloading");

    $CORE::GLOBAL::{"readpipe"}=[];
    eval "`` if 0";
    is($@@, '', "Can't trip up readpipe overloading");
}

{
    die if exists $::{BONK};
    $::{BONK} = \"powie";
    *{"BONK"} = \&{"BONK"};
    eval 'is(BONK(), "powie",
             "Assignment works when glob created midway (bug 45607)"); 1'
	or die $@@;
}

# For now these tests are here, but they would probably be better in a file for
# tests for croaks. (And in turn, that probably deserves to be in a different
# directory. Gerard Goossen has a point about the layout being unclear

sub coerce_integer {
    no warnings 'numeric';
    $_[0] |= 0;
}
sub coerce_number {
    no warnings 'numeric';
    $_[0] += 0;
}
sub coerce_string {
    $_[0] .= '';
}

foreach my $type (qw(integer number string)) {
    my $prog = "coerce_$type(*STDERR)";
    is (scalar eval "$prog; 1", undef, "$prog failed...");
    like ($@@, qr/Can't coerce GLOB to $type in/,
	  "with the correct error message");
}

# RT #65582 anonymous glob should be defined, and not coredump when
# stringified. The behaviours are:
#
#        defined($glob)    "$glob"                   $glob .= ...
# 5.8.8     false           "" with uninit warning   "" with uninit warning
# 5.10.0    true            (coredump)               (coredump)
# 5.1[24]   true            ""                       "" with uninit warning
# 5.16      true            "*__ANON__::..."         "*__ANON__::..."

{
    my $io_ref = *STDOUT{IO};
    my $glob = *$io_ref;
    ok(defined $glob, "RT #65582 anon glob should be defined");

    my $warn = '';
    local $SIG{__WARN__} = sub { $warn = $_[0] };
    use warnings;
    my $str = "$glob";
    is($warn, '', "RT #65582 anon glob stringification shouldn't warn");
    is($str,  '*__ANON__::__ANONIO__',
	"RT #65582/#96326 anon glob stringification");
}

# Another stringification bug: Test that recursion does not cause lexical
# handles to lose their names.
sub r {
    my @@output;
    @@output = r($_[0]-1) if $_[0];
    open my $fh, "TEST";
    push @@output, $$fh;
    close $fh;
    @@output;
}
is join(' ', r(4)),
  '*main::$fh *main::$fh *main::$fh *main::$fh *main::$fh',
  'recursion does not cause lex handles to lose their names';

# And sub cloning, too; not just recursion
my $close_over_me;
is join(' ', sub {
    () = $close_over_me;
    my @@output;
    @@output = CORE::__SUB__->($_[0]-1) if $_[0];
    open my $fh, "TEST";
    push @@output, $$fh;
    close $fh;
    @@output;
   }->(4)),
  '*main::$fh *main::$fh *main::$fh *main::$fh *main::$fh',
  'sub cloning does not cause lex handles to lose their names';

# [perl #71254] - Assigning a glob to a variable that has a current
# match position. (We are testing that Perl_magic_setmglob respects globs'
# special used of SvSCREAM.)
{
    $m = 2; $m=~s/./0/gems; $m= *STDERR;
    is(
        "$m", "*main::STDERR",
        '[perl #71254] assignment of globs to vars with pos'
    );
}

# [perl #72740] - indirect object syntax, heuristically imputed due to
# the non-existence of a function, should not cause a stash entry to be
# created for the non-existent function.
{
	package RT72740a;
	my $f = bless({}, RT72740b);
	sub s1 { s2 $f; }
	our $s4;
	sub s3 { s4 $f; }
}
{
	package RT72740b;
	sub s2 { "RT72740b::s2" }
	sub s4 { "RT72740b::s4" }
}
ok(exists($RT72740a::{s1}), "RT72740a::s1 exists");
ok(!exists($RT72740a::{s2}), "RT72740a::s2 does not exist");
ok(exists($RT72740a::{s3}), "RT72740a::s3 exists");
ok(exists($RT72740a::{s4}), "RT72740a::s4 exists");
is(RT72740a::s1(), "RT72740b::s2", "RT72740::s1 parsed correctly");
is(RT72740a::s3(), "RT72740b::s4", "RT72740::s3 parsed correctly");

# [perl #71686] Globs that are in symbol table can be un-globbed
$sym = undef;
$::{fake} = *sym;
is (eval 'local *::fake = \"chuck"; $fake', 'chuck',
	"Localized glob didn't coerce into a RV");
is ($@@, '', "Can localize FAKE glob that's present in stash");
is (scalar $::{fake}, "*main::sym",
	"Localized FAKE glob's value was correctly restored");

# [perl #1804] *$x assignment when $x is a copy of another glob
# And [perl #77508] (same thing with list assignment)
{
    no warnings 'once';
    my $x = *_random::glob_that_is_not_used_elsewhere;
    *$x = sub{};
    is(
      "$x", '*_random::glob_that_is_not_used_elsewhere',
      '[perl #1804] *$x assignment when $x is FAKE',
    );
    $x = *_random::glob_that_is_not_used_elsewhere;
    (my $dummy, *$x) = (undef,[]);
    is(
      "$x", '*_random::glob_that_is_not_used_elsewhere',
      '[perl #77508] *$x list assignment when $x is FAKE',
    ) or require Devel::Peek, Devel::Peek::Dump($x);
}

# [perl #76540]
# this caused panics or 'Attempt to free unreferenced scalar'
# (its a compile-time issue, so the die lets us skip the prints)
{
    my @@warnings;
    local $SIG{__WARN__} = sub { push @@warnings, @@_ };

    eval <<'EOF';
BEGIN { $::{FOO} = \'bar' }
die "made it";
print FOO, "\n";
print FOO, "\n";
EOF

    like($@@, qr/made it/, "#76540 - no panic");
    ok(!@@warnings, "#76540 - no 'Attempt to free unreferenced scalar'");
}

# [perl #77362] various bugs related to globs as PVLVs
{
 no warnings qw 'once void';
 my %h; # We pass a key of this hash to the subroutine to get a PVLV.
 sub { for(shift) {
  # Set up our glob-as-PVLV
  $_ = *hon;

  # Bad symbol for array
  ok eval{ @@$_; 1 }, 'PVLV glob slots can be autovivified' or diag $@@;

  # This should call TIEHANDLE, not TIESCALAR
  *thext::TIEHANDLE = sub{};
  ok eval{ tie *$_, 'thext'; 1 }, 'PVLV globs can be tied as handles'
   or diag $@@;

  # Assigning undef to the glob should not overwrite it...
  {
   my $w;
   local $SIG{__WARN__} = sub { $w = shift };
   *$_ = undef;
   is $_, "*main::hon", 'PVLV: assigning undef to the glob does nothing';
   like $w, qr\Undefined value assigned to typeglob\,
    'PVLV: assigning undef to the glob warns';
  }

  # Neither should reference assignment.
  *$_ = [];
  is $_, "*main::hon", "PVLV: arrayref assignment assigns to the AV slot";

  # Concatenation should still work.
  ok eval { $_ .= 'thlew' }, 'PVLV concatenation does not die' or diag $@@;
  is $_, '*main::honthlew', 'PVLV concatenation works';

  # And we should be able to overwrite it with a string, number, or refer-
  # ence, too, if we omit the *.
  $_ = *hon; $_ = 'tzor';
  is $_, 'tzor', 'PVLV: assigning a string over a glob';
  $_ = *hon; $_ = 23;
  is $_, 23, 'PVLV: assigning an integer over a glob';
  $_ = *hon; $_ = 23.23;
  is $_, 23.23, 'PVLV: assigning a float over a glob';
  $_ = *hon; $_ = \my $sthat;
  is $_, \$sthat, 'PVLV: assigning a reference over a glob';

  # This bug was found by code inspection. Could this ever happen in
  # real life? :-)
  # This duplicates a file handle, accessing it through a PVLV glob, the
  # glob having been removed from the symbol table, so a stringified form
  # of it does not work. This checks that sv_2io does not stringify a PVLV.
  $_ = *quin;
  open *quin, "test.pl"; # test.pl is as good a file as any
  delete $::{quin};
  ok eval { open my $zow, "<&", $_ }, 'PVLV: sv_2io stringifieth not'
   or diag $@@;

  # Similar tests to make sure sv_2cv etc. do not stringify.
  *$_ = sub { 1 };
  ok eval { &$_ }, "PVLV glob can be called as a sub" or diag $@@;
  *flelp = sub { 2 };
  $_ = 'flelp';
  is eval { &$_ }, 2, 'PVLV holding a string can be called as a sub'
   or diag $@@;

  # Coderef-to-glob assignment when the glob is no longer accessible
  # under its name: These tests are to make sure the OPpASSIGN_CV_TO_GV
  # optimisation takes PVLVs into account, which is why the RHSs have to be
  # named subs.
  use constant gheen => 'quare';
  $_ = *ming;
  delete $::{ming};
  *$_ = \&gheen;
  is eval { &$_ }, 'quare',
   'PVLV: constant assignment when the glob is detached from the symtab'
    or diag $@@;
  $_ = *bength;
  delete $::{bength};
  *gheck = sub { 'lon' };
  *$_ = \&gheck;
  is eval { &$_ }, 'lon',
   'PVLV: coderef assignment when the glob is detached from the symtab'
    or diag $@@;

SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load PerlIO::scalar", 1);
    # open should accept a PVLV as its first argument
    $_ = *hon;
    ok eval { open $_,'<', \my $thlext }, 'PVLV can be the first arg to open'
	or diag $@@;
  }

  # -t should not stringify
  $_ = *thlit; delete $::{thlit};
  *$_ = *STDOUT{IO};
  ok defined -t $_, 'PVLV: -t does not stringify';

  # neither should -T
  # but some systems donâ€™t support this on file handles
  my $pass;
  ok
    eval {
     open my $quile, "<", 'test.pl';
     $_ = *$quile;
     $pass = -T $_;
     1
    } ? $pass : $@@ =~ /not implemented on filehandles/,
   "PVLV: -T does not stringify";
  
  # Unopened file handle
  {
   my $w;
   local $SIG{__WARN__} = sub { $w .= shift };
   $_ = *vor;
   close $_;
   like $w, qr\unopened filehandle vor\,
    'PVLV globs get their names reported in unopened error messages';
  }

 }}->($h{k});
}

*aieee = 4;
pass('Can assign integers to typeglobs');
*aieee = 3.14;
pass('Can assign floats to typeglobs');
*aieee = 'pi';
pass('Can assign strings to typeglobs');

{
  package thrext;
  sub TIESCALAR{bless[]}
  sub STORE{ die "No!"}
  sub FETCH{ no warnings 'once'; *thrit }
  tie my $a, "thrext";
  () = "$a"; # do a fetch; now $a holds a glob
  eval { *$a = sub{} };
  untie $a;
  eval { $a = "bar" };
  ::is $a, "bar",
    "[perl #77812] Globs in tied scalars can be reified if STORE dies"
}

# These two crashed prior to 5.13.6. In 5.13.6 they were fatal errors. They
# were fixed in 5.13.7.
ok eval {
  my $glob = \*heen::ISA;
  delete $::{"heen::"};
  *$glob = *bar; 
}, "glob-to-*ISA assignment works when *ISA has lost its stash";
ok eval {
  my $glob = \*slare::ISA;
  delete $::{"slare::"};
  *$glob = []; 
}, "array-to-*ISA assignment works when *ISA has lost its stash";
# These two crashed in 5.13.6. They were likewise fixed in 5.13.7.
ok eval {
  sub greck;
  my $glob = do { no warnings "once"; \*phing::foo};
  delete $::{"phing::"};
  *$glob = *greck; 
}, "Assigning a glob-with-sub to a glob that has lost its stash works";
ok eval {
  sub pon::foo;
  my $glob = \*pon::foo;
  delete $::{"pon::"};
  *$glob = *foo; 
}, "Assigning a glob to a glob-with-sub that has lost its stash works";

{
  package Tie::Alias;
  sub TIESCALAR{ bless \\pop }
  sub FETCH { $${$_[0]} }
  sub STORE { $${$_[0]} = $_[1] }
  package main;
  tie my $alias, 'Tie::Alias', my $var;
  no warnings 'once';
  $var = *galobbe;
  {
    local *$alias = [];
    $var = 3;
    is $alias, 3, "[perl #77926] Glob reification during localisation";
  }
}

# This code causes gp_free to call a destructor when a glob is being
# restored on scope exit. The destructor used to see SVs with a refcount of
# zero inside the glob, which could result in crashes (though not in this
# test case, which just panics).
{
 no warnings 'once';
 my $survived;
 *Trit::DESTROY = sub {
   $thwext = 42;  # panic
   $survived = 1;
 };
 {
  local *thwext;
  $thwext = bless[],'Trit';
  ();
 }
 ok $survived,
  'no error when gp_free calls a destructor that assigns to the gv';
}

# This is a similar test, for destructors seeing a GV without a reference
# count on its gp.
sub undefine_me_if_you_dare {}
bless \&undefine_me_if_you_dare, "Undefiner";
sub Undefiner::DESTROY {
    undef *undefine_me_if_you_dare;
}
{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };
    undef *undefine_me_if_you_dare;
    is $w, undef,
      'undeffing a gv in DESTROY triggered by undeffing the same gv'
}

# [perl #121242]
# More gp_free madness.  gp_free could call a destructor that frees the gv
# whose gp is being freed.
sub Fred::AUTOLOAD { $Fred::AUTOLOAD }
undef *{"Fred::AUTOLOAD"};
pass 'no crash from gp_free triggering gv_try_downgrade';
sub _121242::DESTROY { delete $_121242::{$_[0][0]} };
${"_121242::foo"} = bless ["foo"], _121242::;
undef *{"_121242::foo"};
pass 'no crash from pp_undef/gp_free freeing the gv';
${"_121242::bar"} = bless ["bar"], _121242::;
*{"_121242::bar"} = "bar";
pass 'no crash from sv_setsv/gp_free freeing the gv';
${"_121242::baz"} = bless ["baz"], _121242::;
*{"_121242::baz"} = *foo;
pass 'no crash from glob_assign_glob/gp_free freeing the gv';
{
    my $foo;
    undef *_121242::DESTROY;
    *_121242::DESTROY = sub { undef $foo };
    my $set_up_foo = sub {
        # Make $$foo into a fake glob whose array slot holds a blessed
        # array that undefines $foo, freeing the fake glob.
        $foo = undef;
        $$foo = do {local *bar};
        *$$foo = bless [], _121242::;
    };
    &$set_up_foo;
    $$foo = 3;
    pass 'no crash from sv_setsv/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    utf8::encode $$foo;
    pass 'no crash from sv_utf8_encode/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    open BAR, "TEST";
    $$foo .= <BAR>;
    pass 'no crash from do_readline/sv_unglob/gp_free freeing the gv';
    close BAR;
    &$set_up_foo;
    $$foo .= 3;
    pass 'no crash from pp_concat/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    no warnings;
    $$foo++;
    pass 'no crash from sv_inc/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    $$foo--;
    pass 'no crash from sv_dec/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    undef $$foo;
    pass 'no crash from pp_undef/sv_unglob/gp_free freeing the gv';
    $foo = undef;
    $$foo = 3;
    $$foo =~ s/3/$$foo = do {local *bar}; *$$foo = bless [],_121242::; 4/e;
    pass 'no crash from pp_substcont/sv_unglob/gp_free freeing the gv';
}

# *{undef}
eval { *{my $undef} = 3 };
like $@@, qr/^Can't use an undefined value as a symbol reference at /,
  '*{ $undef } assignment';
eval { *{;undef} = 3 };
like $@@, qr/^Can't use an undefined value as a symbol reference at /,
  '*{ ;undef } assignment';

# [perl #99142] defined &{"foo"} when there is a constant stub
# If I break your module, you get to have it mentioned in Perl's tests. :-)
package HTTP::MobileAttribute::Plugin::Locator {
    use constant LOCATOR_GPS => 1;
    ::ok defined &{__PACKAGE__."::LOCATOR_GPS"},
        'defined &{"name of constant"}';
    ::ok Internals::SvREFCNT(${__PACKAGE__."::"}{LOCATOR_GPS}),
       "stash elem for slot is not freed prematurely";
}

# Check that constants promoted to CVs point to the right GVs when the name
# contains a null.
package lrcg {
  use constant x => 3;
  # These two lines abuse the optimisation that copies the scalar ref from
  # one stash element to another, to get a constant with a null in its name
  *{"yz\0a"} = \&{"x"};
  my $ref = \&{"yz\0a"};
  ::ok !exists $lrcg::{yz},
    'constants w/nulls in their names point 2 the right GVs when promoted';
}

{
  no warnings 'io';
  stat *{"try_downgrade"};
  -T _;
  $bang = $!;
  eval "*try_downgrade if 0";
  -T _;
  is "$!",$bang,
     'try_downgrade does not touch PL_statgv (last stat handle)';
  readline *{"try_downgrade2"};
  my $lastfh = "${^LAST_FH}";
  eval "*try_downgrade2 if 0";
  is ${^LAST_FH}, $lastfh, 'try_downgrade does not touch PL_last_in_gv';
}

is runperl(prog => '$s = STDERR; close $s; undef *$s;'
                  .'eval q-*STDERR if 0-; *$s = *STDOUT{IO}; warn'),
  "Warning: something's wrong at -e line 1.\n",
  "try_downgrade does not touch PL_stderrgv";

is runperl(prog =>
             'use constant foo=>1; BEGIN { $x = \&foo } undef &$x; $x->()',
           stderr=>1),
  "Undefined subroutine &main::foo called at -e line 1.\n",
  "gv_try_downgrade does not anonymise CVs referenced elsewhere";

SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load IO::File", 4);

package glob_constant_test {
  sub foo { 42 }
  use constant bar => *foo;
  BEGIN { undef *foo }
  ::is eval { bar->() }, eval { &{+bar} },
    'glob_constant->() is not mangled at compile time';
  ::is "$@@", "", 'no error from eval { &{+glob_constant} }';
  use constant quux => do {
    local *F;
    my $f = *F;
    *$f = *STDOUT{IO};
  };
  ::is eval { quux->autoflush; 420 }, 420,
    'glob_constant->method() works';
  ::is "$@@", "", 'no error from eval { glob_constant->method() }';
}

}

{
  my $free2;
  local $SIG{__WARN__} = sub { ++$free2 if shift =~ /Attempt to free/ };
  my $handleref;
  my $proxy = \$handleref;
  open $$proxy, "TEST";
  delete $::{*$handleref{NAME}};  # delete *main::_GEN_xxx
  undef $handleref;
  is $free2, undef,
    'no double free because of bad rv2gv/newGVgen refcounting';
}

# Look away, please.
# This violates perl's internal structures by fiddling with stashes in a
# way that should never happen, but perl should not start trying to free
# unallocated memory as a result.  There is no ok() or is() because the
# panic that used to occur only occurred during global destruction, and
# only with PERL_DESTRUCT_LEVEL=2.  (The panic itself was sufficient for
# the harness to consider this test script to have failed.)
$::{aoeuaoeuaoeaoeu} = __PACKAGE__; # cow
() = *{"aoeuaoeuaoeaoeu"};

$x = *_119051;
$y = \&$x;
undef $x;
eval { &$y };
pass "No crash due to CvGV(vivified stub) pointing to flattened glob copy";
# Not really supported, but this should not crash either:
$x = *_119051again;
delete $::{_119051again};
$::{_119051again} = $x;    # now we have a fake glob under the right name
$y = \&$x;                 # so when this tries to look up the right GV for
undef $::{_119051again};   # CvGV, it still gets a fake one
eval { $y->() };
pass "No crash due to CvGV pointing to glob copy in the stash";

# Aliasing should disable no-common-vars optimisation.
{
    *x = *y;
    $x = 3;
    ($x, my $z) = (1, $y);
    is $z, 3, 'list assignment after aliasing [perl #89646]';
}

# RT #125840: make sure *x = $x doesn't do bad things by freeing $x before
# it's assigned.

{
    $a_125840 = 1;
    $b_125840 = 2;
    $a_125840 = *b_125840;
    *a_125840 = $a_125840;
    is($a_125840, 2, 'RT #125840: *a = $a');

    $c_125840 = 1;
    $d_125840 = 2;
    *d_125840 = $d_125840 = *c_125840;
    is($d_125840, 1, 'RT #125840: *d=$d=*c');
    $c_125840 = $d_125840;
    is($c_125840, 1, 'RT #125840: $c=$d');
}


__END__
Perl
Rules
perl
rocks
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a8 1
    @@INC = '../lib';
d10 1
d15 1
a15 1
plan( tests => 271 );
d185 4
a188 1
    print {*x{IO}} ($warn =~ /is deprecated/
a205 12
    {
	no warnings 'deprecated';
	ok(!defined @@{$a});
    }
    ok(!defined *{$a});

    {
	no warnings 'deprecated';
	ok(!defined %{$a});
    }
    ok(!defined *{$a});

d496 3
d521 1
a521 1
foreach my $value ({1=>2}, *STDOUT{IO}, \&ok, *STDOUT{FORMAT}) {
d1072 34
d1129 27
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d15 1
a15 1
plan( tests => 245 );
d497 8
d527 1
a527 1
foreach my $value ([1,2,3], {1=>2}, *STDOUT{IO}, \&ok, *STDOUT{FORMAT}) {
d640 28
d950 72
d1052 26
d1087 14
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d15 1
a15 1
plan( tests => 239 );
d169 2
d190 6
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d10 1
d15 1
a15 2
require './test.pl';
plan( tests => 188 );
d17 1
a17 1
# type coersion on assignment
d24 1
a24 1
# type coersion (not) on misc ops
d35 29
a63 1
# type coersion on substitutions that match
d195 4
a198 1
    ok(!defined @@{$a});
d225 1
a226 1
    ok(defined *{$a});
d287 1
a287 1
    my $v;
d289 4
a292 3
    f($v);
    is ($v, '*main::DATA');
    my $x = <$v>;
d294 1
d298 1
a298 1
    $e = '';
d308 5
a312 1
    is ($e, '');
d315 1
d327 1
a327 1
bless \$A::B, 'M';
d374 1
a374 1
    "Inlining of constant doesn't change represenatation");
d574 1
a574 1
             "Assigment works when glob created midway (bug 45607)"); 1'
d601 1
a601 1
# RT #60954 anonymous glob should be defined, and not coredump when
d604 5
a608 4
#        defined($glob)    "$glob"
# 5.8.8     false           "" with uninit warning
# 5.10.0    true            (coredump)
# 5.12.0    true            ""
d613 1
a613 1
    ok(defined $glob, "RT #60954 anon glob should be defined");
d619 3
a621 2
    is($warn, '', "RT #60954 anon glob stringification shouln't warn");
    is($str,  '', "RT #60954 anon glob stringification should be empty");
d656 289
@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@d15 1
a15 1
plan( tests => 178 );
d170 4
a173 1
    ok(!defined %{$a});
d562 54
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d15 1
a15 1
plan( tests => 161 );
a379 1
my $result;
d384 2
a385 1
  $result = *{"plunk"} = \&{"oonk"};
a388 3
is (ref \$result, 'GLOB',
    "Non void assignment should still return a typeglob");

d398 1
a398 1
  $result = *{$gr} = \&{"oonk"};
d406 42
d536 24
@


1.7
log
@merge in perl 5.8.8
@
text
@d15 1
a15 1
plan( tests => 61 );
d92 28
d227 1
a227 1
    $SIG{__WARN__} = sub { $w = $_[0] };
d249 248
d500 2
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d10 1
a10 1
}   
d14 2
a15 1
print "1..48\n";
d21 1
a21 1
print ref(\$bar) eq 'SCALAR' ? "ok 1\n" : "not ok 1\n";
d26 2
a27 3
if ($foo) {
  print ref(\$foo) eq 'GLOB' ? "ok 2\n" : "not ok 2\n";
}
d29 2
a30 3
unless ($foo =~ /abcd/) {
  print ref(\$foo) eq 'GLOB' ? "ok 3\n" : "not ok 3\n";
}
d32 2
a33 3
if ($foo eq '*main::bar') {
  print ref(\$foo) eq 'GLOB' ? "ok 4\n" : "not ok 4\n";
}
d39 1
a39 1
print ref(\$a) eq 'GLOB' ? "ok 5\n" : "not ok 5\n";
d41 2
a42 2
print $a eq 'main::foo' ? "ok 6\n" : "not ok 6\n";
print ref(\$b) eq 'GLOB' ? "ok 7\n" : "not ok 7\n";
d46 2
a47 2
print ref(\$foo) eq 'SCALAR' ? "ok 8\n" : "not ok 8\n";
print $foo eq 'XXXmain::bar' ? "ok 9\n" : "not ok 9\n";
d57 3
a59 3
if (defined $fuu) {
  print ref(\$fuu) eq 'GLOB' ? "ok 10\n" : "not ok 10\n";
}
d61 2
a62 3
if (defined $baa) {
  print ref(\$baa) eq 'GLOB' ? "ok 11\n" : "not ok 11\n";
}
d70 3
a72 2
print exists $Foo::{'Bar::'} ? "ok 12\n" : "not ok 12\n";
print $Foo::{'Bar::'} eq '*Foo::Bar::' ? "ok 13\n" : "not ok 13\n";
d79 3
a81 1
print +($foo || @@foo || %foo) ? "not ok" : "ok", " 14\n";
a82 1
# test warnings from assignment of undef to glob
d84 2
a85 1
    my $msg;
d89 1
a89 1
    print $msg ? "not ok" : "ok", " 15\n";
d91 1
a91 1
    print $msg ? "ok" : "not ok", " 16\n";
d94 1
d96 7
a102 4
$x = "ok 17\n";
@@x = ("ok 18\n");
%x = ("ok 19" => "\n");
sub x { "ok 20\n" }
d104 3
d108 1
a108 1
ok 21
d110 3
a112 1
print ref *x{FORMAT} eq "FORMAT" ? "ok 21\n" : "not ok 21\n";
d114 1
a114 2
print *{*x{GLOB}} eq "*main::STDOUT" ? "ok 22\n" : "not ok 22\n";
print {*x{IO}} "ok 23\n";
d117 13
a129 7
	my $warn;
	local $SIG{__WARN__} = sub {
		$warn .= $_[0];
	};
	my $val = *x{FILEHANDLE};
	print {*x{IO}} ($warn =~ /is deprecated/ ? "ok 24\n" : "not ok 24\n");
	
a131 1
# test if defined() doesn't create any new symbols
d134 1
a134 1
    my $test = 24;
d137 1
a137 2
    print "not " if defined *{$a};
    ++$test; print "ok $test\n";
d139 2
a140 2
    print "not " if defined @@{$a} or defined *{$a};
    ++$test; print "ok $test\n";
d142 2
a143 2
    print "not " if defined %{$a} or defined *{$a};
    ++$test; print "ok $test\n";
d145 2
a146 2
    print "not " if defined ${$a} or defined *{$a};
    ++$test; print "ok $test\n";
d148 2
a149 2
    print "not " if defined &{$a} or defined *{$a};
    ++$test; print "ok $test\n";
d151 6
a156 3
    *{$a} = sub { print "ok $test\n" };
    print "not " unless defined &{$a} and defined *{$a};
    ++$test; &{$a};
a158 2
# although it *should* if you're talking about magicals

d160 1
a160 1
    my $test = 30;
d163 2
a164 4
    print "not " unless defined ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
d168 2
a169 4
    print "not " unless ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
d171 2
a172 4
    print "not " if ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
d174 2
a175 4
    print "not " if defined ${$a};
    ++$test; print "ok $test\n";
    print "not " if defined *{$a};
    ++$test; print "ok $test\n";
d178 2
a179 4
    print "not " unless ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
a181 1

d186 3
a188 5
print $j    == 1 ? "ok 41\n"  : "not ok 41\n";
print $j{a} == 1 ? "ok 42\n"  : "not ok 42\n";
print $j[0] == 1 ? "ok 43\n" : "not ok 43\n";

# does pp_readline() handle glob-ness correctly?
d191 1
d194 1
a194 1
    print $g;
d202 1
a202 1
    print $w eq '' ? "ok 45\n" : "not ok 45\n# $w";
d206 1
a206 1
    print $w eq '' ? "ok 46\n" : "not ok 46\n# $w";
d209 1
a209 1
    print $w =~ /Prototype mismatch/ ? "ok 47\n" : "not ok 47\n# $w";
d218 1
a218 1
    print $x;
d222 2
a223 2
ok 44
ok 48
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d14 1
a14 1
print "1..47\n";
d211 9
d222 1
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d14 1
a14 1
print "1..40\n";
d100 4
d105 12
a116 3
print *{*x{GLOB}} eq "*main::STDOUT" ? "ok 21\n" : "not ok 21\n";
print {*x{IO}} "ok 22\n";
print {*x{FILEHANDLE}} "ok 23\n";
d121 1
a121 1
    my $test = 23;
d147 1
a147 1
    my $test = 29;
d180 8
d196 15
d212 1
a212 1
ok 40
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d9 1
a9 1
    unshift @@INC, '../lib';
d14 1
a14 1
print "1..30\n";
d131 36
d176 1
a176 1
ok 30
@


1.2
log
@perl5.005_03 (stock)
@
text
@d7 8
a14 1
print "1..23\n";
d72 1
a72 1
{ package Foo::Bar }
d87 1
a87 1
    local $^W = 1;
d105 33
d139 2
@


1.1
log
@perl 5.004_04
@
text
@d7 1
a7 1
print "1..11\n";
d59 39
@


1.1.1.1
log
@perl5.005_03
@
text
@d7 1
a7 1
print "1..23\n";
a58 39

# nested package globs
# NOTE:  It's probably OK if these semantics change, because the
#        fact that %X::Y:: is stored in %X:: isn't documented.
#        (I hope.)

{ package Foo::Bar }
print exists $Foo::{'Bar::'} ? "ok 12\n" : "not ok 12\n";
print $Foo::{'Bar::'} eq '*Foo::Bar::' ? "ok 13\n" : "not ok 13\n";

# test undef operator clearing out entire glob
$foo = 'stuff';
@@foo = qw(more stuff);
%foo = qw(even more random stuff);
undef *foo;
print +($foo || @@foo || %foo) ? "not ok" : "ok", " 14\n";

# test warnings from assignment of undef to glob
{
    my $msg;
    local $SIG{__WARN__} = sub { $msg = $_[0] };
    local $^W = 1;
    *foo = 'bar';
    print $msg ? "not ok" : "ok", " 15\n";
    *foo = undef;
    print $msg ? "ok" : "not ok", " 16\n";
}

# test *glob{THING} syntax
$x = "ok 17\n";
@@x = ("ok 18\n");
%x = ("ok 19" => "\n");
sub x { "ok 20\n" }
print ${*x{SCALAR}}, @@{*x{ARRAY}}, %{*x{HASH}}, &{*x{CODE}};
*x = *STDOUT;
print *{*x{GLOB}} eq "*main::STDOUT" ? "ok 21\n" : "not ok 21\n";
print {*x{IO}} "ok 22\n";
print {*x{FILEHANDLE}} "ok 23\n";

@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d7 1
a7 8
BEGIN {
    chdir 't' if -d 't';
    unshift @@INC, '../lib';
}   

use warnings;

print "1..30\n";
d65 1
a65 1
{ package Foo::Bar; no warnings 'once'; $test=1; }
d80 1
a80 1
    use warnings;
a97 33
# test if defined() doesn't create any new symbols

{
    my $test = 23;

    my $a = "SYM000";
    print "not " if defined *{$a};
    ++$test; print "ok $test\n";

    print "not " if defined @@{$a} or defined *{$a};
    ++$test; print "ok $test\n";

    print "not " if defined %{$a} or defined *{$a};
    ++$test; print "ok $test\n";

    print "not " if defined ${$a} or defined *{$a};
    ++$test; print "ok $test\n";

    print "not " if defined &{$a} or defined *{$a};
    ++$test; print "ok $test\n";

    *{$a} = sub { print "ok $test\n" };
    print "not " unless defined &{$a} and defined *{$a};
    ++$test; &{$a};
}

# does pp_readline() handle glob-ness correctly?

{
    my $g = *foo;
    $g = <DATA>;
    print $g;
}
a98 2
__END__
ok 30
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d9 1
a9 1
    @@INC = '../lib';
d14 1
a14 1
print "1..40\n";
a130 36
# although it *should* if you're talking about magicals

{
    my $test = 29;

    my $a = "]";
    print "not " unless defined ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";

    $a = "1";
    "o" =~ /(o)/;
    print "not " unless ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
    $a = "2";
    print "not " if ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
    $a = "1x";
    print "not " if defined ${$a};
    ++$test; print "ok $test\n";
    print "not " if defined *{$a};
    ++$test; print "ok $test\n";
    $a = "11";
    "o" =~ /(((((((((((o)))))))))))/;
    print "not " unless ${$a};
    ++$test; print "ok $test\n";
    print "not " unless defined *{$a};
    ++$test; print "ok $test\n";
}


d140 1
a140 1
ok 40
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d14 1
a14 1
print "1..47\n";
a99 4
format x =
ok 21
.
print ref *x{FORMAT} eq "FORMAT" ? "ok 21\n" : "not ok 21\n";
d101 3
a103 12
print *{*x{GLOB}} eq "*main::STDOUT" ? "ok 22\n" : "not ok 22\n";
print {*x{IO}} "ok 23\n";

{
	my $warn;
	local $SIG{__WARN__} = sub {
		$warn .= $_[0];
	};
	my $val = *x{FILEHANDLE};
	print {*x{IO}} ($warn =~ /is deprecated/ ? "ok 24\n" : "not ok 24\n");
	
}
d108 1
a108 1
    my $test = 24;
d134 1
a134 1
    my $test = 30;
a166 8
# [ID 20010526.001] localized glob loses value when assigned to

$j=1; %j=(a=>1); @@j=(1); local *j=*j; *j = sub{};

print $j    == 1 ? "ok 41\n"  : "not ok 41\n";
print $j{a} == 1 ? "ok 42\n"  : "not ok 42\n";
print $j[0] == 1 ? "ok 43\n" : "not ok 43\n";

a174 15
{
    my $w = '';
    $SIG{__WARN__} = sub { $w = $_[0] };
    sub abc1 ();
    local *abc1 = sub { };
    print $w eq '' ? "ok 45\n" : "not ok 45\n# $w";
    sub abc2 ();
    local *abc2;
    *abc2 = sub { };
    print $w eq '' ? "ok 46\n" : "not ok 46\n# $w";
    sub abc3 ();
    *abc3 = sub { };
    print $w =~ /Prototype mismatch/ ? "ok 47\n" : "not ok 47\n# $w";
}

d176 1
a176 1
ok 44
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d14 1
a14 1
print "1..48\n";
a210 9
{
    # [17375] rcatline to formerly-defined undef was broken. Fixed in
    # do_readline by checking SvOK. AMS, 20020918
    my $x = "not ";
    $x  = undef;
    $x .= <DATA>;
    print $x;
}

a212 1
ok 48
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
}
d14 1
a14 2
require './test.pl';
plan( tests => 61 );
d20 1
a20 1
is(ref(\$bar), 'SCALAR');
d25 3
a27 2
ok($foo);
is(ref(\$foo), 'GLOB');
d29 3
a31 2
unlike ($foo, qr/abcd/);
is(ref(\$foo), 'GLOB');
d33 3
a35 2
is($foo, '*main::bar');
is(ref(\$foo), 'GLOB');
d41 1
a41 1
is(ref(\$a), 'GLOB');
d43 2
a44 2
is($a, 'main::foo');
is(ref(\$b), 'GLOB');
d48 2
a49 2
is(ref(\$foo), 'SCALAR');
is($foo, 'XXXmain::bar');
d59 3
a61 2
ok(defined $fuu);
is(ref(\$fuu), 'GLOB');
d63 3
a65 3

ok(defined $baa);
is(ref(\$baa), 'GLOB');
d73 2
a74 3
ok(exists $Foo::{'Bar::'});
is($Foo::{'Bar::'}, '*Foo::Bar::');

d81 1
a81 3
is ($foo, undef);
is (scalar @@foo, 0);
is (scalar %foo, 0);
d83 1
d85 1
a85 2
    # test warnings from assignment of undef to glob
    my $msg = '';
d89 1
a89 1
    is($msg, '');
d91 1
a91 1
    like($msg, qr/Undefined value assigned to typeglob/);
a93 1
my $test = curr_test();
d95 4
a98 7
$x = "ok $test\n";
++$test;
@@x = ("ok $test\n");
++$test;
%x = ("ok $test" => "\n");
++$test;
sub x { "ok $test\n" }
a99 3
# This needs to go here, after the print, as sub x will return the current
# value of test
++$test;
d101 1
a101 1
XXX This text isn't used. Should it be?
d103 1
a103 3
curr_test($test);

is (ref *x{FORMAT}, "FORMAT");
d105 2
a106 1
is (*{*x{GLOB}}, "*main::STDOUT");
d109 7
a115 13
    my $test = curr_test();

    print {*x{IO}} "ok $test\n";
    ++$test;

    my $warn;
    local $SIG{__WARN__} = sub {
	$warn .= $_[0];
    };
    my $val = *x{FILEHANDLE};
    print {*x{IO}} ($warn =~ /is deprecated/
		    ? "ok $test\n" : "not ok $test\n");
    curr_test(++$test);
d118 1
d121 1
a121 1
    # test if defined() doesn't create any new symbols
d124 2
a125 1
    ok(!defined *{$a});
d127 2
a128 2
    ok(!defined @@{$a});
    ok(!defined *{$a});
d130 2
a131 2
    ok(!defined %{$a});
    ok(!defined *{$a});
d133 2
a134 2
    ok(!defined ${$a});
    ok(!defined *{$a});
d136 2
a137 2
    ok(!defined &{$a});
    ok(!defined *{$a});
d139 3
a141 6
    my $state = "not";
    *{$a} = sub { $state = "ok" };
    ok(defined &{$a});
    ok(defined *{$a});
    &{$a};
    is ($state, 'ok');
d144 2
d147 1
a147 1
    # although it *should* if you're talking about magicals
d150 4
a153 2
    ok(defined ${$a});
    ok(defined *{$a});
d157 4
a160 2
    ok(${$a});
    ok(defined *{$a});
d162 4
a165 2
    ok(!${$a});
    ok(defined *{$a});
d167 4
a170 2
    ok(!defined ${$a});
    ok(!defined *{$a});
d173 4
a176 2
    ok(${$a});
    ok(defined *{$a});
d179 1
d184 5
a188 3
is($j, 1);
is($j{a}, 1);
is($j[0], 1);
a190 1
    # does pp_readline() handle glob-ness correctly?
d193 1
a193 1
    is ($g, "Perl\n");
d201 1
a201 1
    is ($w, '');
d205 1
a205 1
    is ($w, '');
d208 1
a208 1
    like ($w, qr/Prototype mismatch/);
d217 1
a217 1
    is ($x, "Rules\n");
d221 2
a222 2
Perl
Rules
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d15 1
a15 1
plan( tests => 161 );
a91 28

    no warnings 'once';
    # test warnings for converting globs to other forms
    my $copy = *PWOMPF;
    foreach ($copy, *SKREEE) {
	$msg = '';
	my $victim = sprintf "%d", $_;
	like($msg, qr/Argument "\*main::[A-Z]{6}" isn't numeric in sprintf/,
	     "Warning on conversion to IV");
	is($victim, 0);

	$msg = '';
	$victim = sprintf "%u", $_;
	like($msg, qr/Argument "\*main::[A-Z]{6}" isn't numeric in sprintf/,
	     "Warning on conversion to UV");
	is($victim, 0);

	$msg = '';
	$victim = sprintf "%e", $_;
	like($msg, qr/Argument "\*main::[A-Z]{6}" isn't numeric in sprintf/,
	     "Warning on conversion to NV");
	like($victim, qr/^0\.0+E\+?00/i, "Expect floating point zero");

	$msg = '';
	$victim = sprintf "%s", $_;
	is($msg, '', "No warning on stringification");
	is($victim, '' . $_);
    }
d199 1
a199 1
    local $SIG{__WARN__} = sub { $w = $_[0] };
a220 248
{
    # test the assignment of a GLOB to an LVALUE
    my $e = '';
    local $SIG{__DIE__} = sub { $e = $_[0] };
    my $v;
    sub f { $_[0] = 0; $_[0] = "a"; $_[0] = *DATA }
    f($v);
    is ($v, '*main::DATA');
    my $x = <$v>;
    is ($x, "perl\n");
}

{
    $e = '';
    # GLOB assignment to tied element
    local $SIG{__DIE__} = sub { $e = $_[0] };
    sub T::TIEARRAY  { bless [] => "T" }
    sub T::STORE     { $_[0]->[ $_[1] ] = $_[2] }
    sub T::FETCH     { $_[0]->[ $_[1] ] }
    sub T::FETCHSIZE { @@{$_[0]} }
    tie my @@ary => "T";
    $ary[0] = *DATA;
    is ($ary[0], '*main::DATA');
    is ($e, '');
    my $x = readline $ary[0];
    is($x, "rocks\n");
}

{
    # Need some sort of die or warn to get the global destruction text if the
    # bug is still present
    my $output = runperl(prog => <<'EOPROG');
package M;
$| = 1;
sub DESTROY {eval {die qq{Farewell $_[0]}}; print $@@}
package main;

bless \$A::B, 'M';
*A:: = \*B::;
EOPROG
    like($output, qr/^Farewell M=SCALAR/, "DESTROY was called");
    unlike($output, qr/global destruction/,
           "unreferenced symbol tables should be cleaned up immediately");
}

# Possibly not the correct test file for these tests.
# There are certain space optimisations implemented via promotion rules to
# GVs

foreach (qw (oonk ga_shloip)) {
    ok(!exists $::{$_}, "no symbols of any sort to start with for $_");
}

# A string in place of the typeglob is promoted to the function prototype
$::{oonk} = "pie";
my $proto = eval 'prototype \&oonk';
die if $@@;
is ($proto, "pie", "String is promoted to prototype");


# A reference to a value is used to generate a constant subroutine
foreach my $value (3, "Perl rules", \42, qr/whatever/, [1,2,3], {1=>2},
		   \*STDIN, \&ok, \undef, *STDOUT) {
    delete $::{oonk};
    $::{oonk} = \$value;
    $proto = eval 'prototype \&oonk';
    die if $@@;
    is ($proto, '', "Prototype for a constant subroutine is empty");

    my $got = eval 'oonk';
    die if $@@;
    is (ref $got, ref $value, "Correct type of value (" . ref($value) . ")");
    is ($got, $value, "Value is correctly set");
}

delete $::{oonk};
$::{oonk} = \"Value";

*{"ga_shloip"} = \&{"oonk"};

is (ref $::{ga_shloip}, 'SCALAR', "Export of proxy constant as is");
is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'ga_shloip', "Value", "Constant has correct value");
is (ref $::{ga_shloip}, 'SCALAR',
    "Inlining of constant doesn't change represenatation");

delete $::{ga_shloip};

eval 'sub ga_shloip (); 1' or die $@@;
is ($::{ga_shloip}, '', "Prototype is stored as an empty string");

# Check that a prototype expands.
*{"ga_shloip"} = \&{"oonk"};

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'ga_shloip', "Value", "Constant has correct value");
is (ref \$::{ga_shloip}, 'GLOB', "Symbol table has full typeglob");


@@::zwot = ('Zwot!');

# Check that assignment to an existing typeglob works
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"zwot"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'zwot', "Value", "Constant has correct value");
is (ref \$::{zwot}, 'GLOB', "Symbol table has full typeglob");
is (join ('!', @@::zwot), 'Zwot!', "Existing array still in typeglob");

sub spritsits () {
    "Traditional";
}

# Check that assignment to an existing subroutine works
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"spritsits"} = \&{"oonk"};
  like($w, qr/^Constant subroutine main::spritsits redefined/,
       "Redefining a constant sub should warn");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'spritsits', "Value", "Constant has correct value");
is (ref \$::{spritsits}, 'GLOB', "Symbol table has full typeglob");

my $result;
# Check that assignment to an existing typeglob works
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  $result = *{"plunk"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

is (ref \$result, 'GLOB',
    "Non void assignment should still return a typeglob");

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'plunk', "Value", "Constant has correct value");
is (ref \$::{plunk}, 'GLOB', "Symbol table has full typeglob");

my $gr = eval '\*plunk' or die;

{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  $result = *{$gr} = \&{"oonk"};
  is($w, '', "Redefining a constant sub to another constant sub with the same underlying value should not warn (It's just re-exporting, and that was always legal)");
}

is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'plunk', "Value", "Constant has correct value");
is (ref \$::{plunk}, 'GLOB', "Symbol table has full typeglob");

{
    use vars qw($glook $smek $foof);
    # Check reference assignment isn't affected by the SV type (bug #38439)
    $glook = 3;
    $smek = 4;
    $foof = "halt and cool down";

    my $rv = \*smek;
    is($glook, 3);
    *glook = $rv;
    is($glook, 4);

    my $pv = "";
    $pv = \*smek;
    is($foof, "halt and cool down");
    *foof = $pv;
    is($foof, 4);
}

format =
.

foreach my $value ([1,2,3], {1=>2}, *STDOUT{IO}, \&ok, *STDOUT{FORMAT}) {
    # *STDOUT{IO} returns a reference to a PVIO. As it's blessed, ref returns
    # IO::Handle, which isn't what we want.
    my $type = $value;
    $type =~ s/.*=//;
    $type =~ s/\(.*//;
    delete $::{oonk};
    $::{oonk} = $value;
    $proto = eval 'prototype \&oonk';
    like ($@@, qr/^Cannot convert a reference to $type to typeglob/,
	  "Cannot upgrade ref-to-$type to typeglob");
}

{
    no warnings qw(once uninitialized);
    my $g = \*clatter;
    my $r = eval {no strict; ${*{$g}{SCALAR}}};
    is ($@@, '', "PERL_DONT_CREATE_GVSV shouldn't affect thingy syntax");

    $g = \*vowm;
    $r = eval {use strict; ${*{$g}{SCALAR}}};
    is ($@@, '',
	"PERL_DONT_CREATE_GVSV shouldn't affect thingy syntax under strict");
}

{
    # Bug reported by broquaint on IRC
    *slosh::{HASH}->{ISA}=[];
    slosh->import;
    pass("gv_fetchmeth coped with the unexpected");

    # An audit found these:
    {
	package slosh;
	sub rip {
	    my $s = shift;
	    $s->SUPER::rip;
	}
    }
    eval {slosh->rip;};
    like ($@@, qr/^Can't locate object method "rip"/, "Even with SUPER");

    is(slosh->isa('swoosh'), '');

    $CORE::GLOBAL::{"lock"}=[];
    eval "no warnings; lock";
    like($@@, qr/^Not enough arguments for lock/,
       "Can't trip up general keyword overloading");

    $CORE::GLOBAL::{"readline"}=[];
    eval "<STDOUT> if 0";
    is($@@, '', "Can't trip up readline overloading");

    $CORE::GLOBAL::{"readpipe"}=[];
    eval "`` if 0";
    is($@@, '', "Can't trip up readpipe overloading");
}

{
    die if exists $::{BONK};
    $::{BONK} = \"powie";
    *{"BONK"} = \&{"BONK"};
    eval 'is(BONK(), "powie",
             "Assigment works when glob created midway (bug 45607)"); 1'
	or die $@@;
}
a223 2
perl
rocks
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d15 1
a15 1
plan( tests => 178 );
d380 1
d385 1
a385 2
  *{"plunk"} = [];
  *{"plunk"} = \&{"oonk"};
d389 3
d401 1
a401 1
  *{$gr} = \&{"oonk"};
a408 42
# Non-void context should defeat the optimisation, and will cause the original
# to be promoted (what change 26482 intended)
my $result;
{
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  $result = *{"awkkkkkk"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

is (ref \$result, 'GLOB',
    "Non void assignment should still return a typeglob");

is (ref \$::{oonk}, 'GLOB', "This export does affect original");
is (eval 'plunk', "Value", "Constant has correct value");
is (ref \$::{plunk}, 'GLOB', "Symbol table has full typeglob");

delete $::{oonk};
$::{oonk} = \"Value";

sub non_dangling {
  my $w = '';
  local $SIG{__WARN__} = sub { $w = $_[0] };
  *{"zap"} = \&{"oonk"};
  is($w, '', "Should be no warning");
}

non_dangling();
is (ref $::{oonk}, 'SCALAR', "Export doesn't affect original");
is (eval 'zap', "Value", "Constant has correct value");
is (ref $::{zap}, 'SCALAR', "Exported target is also a PCS");

sub dangling {
  local $SIG{__WARN__} = sub { die $_[0] };
  *{"biff"} = \&{"oonk"};
}

dangling();
is (ref \$::{oonk}, 'GLOB', "This export does affect original");
is (eval 'biff', "Value", "Constant has correct value");
is (ref \$::{biff}, 'GLOB', "Symbol table has full typeglob");

a496 24

# For now these tests are here, but they would probably be better in a file for
# tests for croaks. (And in turn, that probably deserves to be in a different
# directory. Gerard Goossen has a point about the layout being unclear

sub coerce_integer {
    no warnings 'numeric';
    $_[0] |= 0;
}
sub coerce_number {
    no warnings 'numeric';
    $_[0] += 0;
}
sub coerce_string {
    $_[0] .= '';
}

foreach my $type (qw(integer number string)) {
    my $prog = "coerce_$type(*STDERR)";
    is (scalar eval "$prog; 1", undef, "$prog failed...");
    like ($@@, qr/Can't coerce GLOB to $type in/,
	  "with the correct error message");
}

@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d15 1
a15 1
plan( tests => 188 );
d170 1
a170 4
    {
	no warnings 'deprecated';
	ok(!defined %{$a});
    }
a558 54

# RT #60954 anonymous glob should be defined, and not coredump when
# stringified. The behaviours are:
#
#        defined($glob)    "$glob"
# 5.8.8     false           "" with uninit warning
# 5.10.0    true            (coredump)
# 5.12.0    true            ""

{
    my $io_ref = *STDOUT{IO};
    my $glob = *$io_ref;
    ok(defined $glob, "RT #60954 anon glob should be defined");

    my $warn = '';
    local $SIG{__WARN__} = sub { $warn = $_[0] };
    use warnings;
    my $str = "$glob";
    is($warn, '', "RT #60954 anon glob stringification shouln't warn");
    is($str,  '', "RT #60954 anon glob stringification should be empty");
}

# [perl #71254] - Assigning a glob to a variable that has a current
# match position. (We are testing that Perl_magic_setmglob respects globs'
# special used of SvSCREAM.)
{
    $m = 2; $m=~s/./0/gems; $m= *STDERR;
    is(
        "$m", "*main::STDERR",
        '[perl #71254] assignment of globs to vars with pos'
    );
}

# [perl #72740] - indirect object syntax, heuristically imputed due to
# the non-existence of a function, should not cause a stash entry to be
# created for the non-existent function.
{
	package RT72740a;
	my $f = bless({}, RT72740b);
	sub s1 { s2 $f; }
	our $s4;
	sub s3 { s4 $f; }
}
{
	package RT72740b;
	sub s2 { "RT72740b::s2" }
	sub s4 { "RT72740b::s4" }
}
ok(exists($RT72740a::{s1}), "RT72740a::s1 exists");
ok(!exists($RT72740a::{s2}), "RT72740a::s2 does not exist");
ok(exists($RT72740a::{s3}), "RT72740a::s3 exists");
ok(exists($RT72740a::{s4}), "RT72740a::s4 exists");
is(RT72740a::s1(), "RT72740b::s2", "RT72740::s1 parsed correctly");
is(RT72740a::s3(), "RT72740b::s4", "RT72740::s3 parsed correctly");
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a9 1
    require './test.pl';
d14 2
a15 1
plan( tests => 239 );
d17 1
a17 1
# type coercion on assignment
d24 1
a24 1
# type coercion (not) on misc ops
d35 1
a35 29
{
 no warnings;
 ${\*$foo} = undef;
 is(ref(\$foo), 'GLOB', 'no type coercion when assigning to *{} retval');
 $::{phake} = *bar;
 is(
   \$::{phake}, \*{"phake"},
   'symbolic *{} returns symtab entry when FAKE'
 );
 ${\*{"phake"}} = undef;
 is(
   ref(\$::{phake}), 'GLOB',
  'no type coercion when assigning to retval of symbolic *{}'
 );
 $::{phaque} = *bar;
 eval '
   is(
     \$::{phaque}, \*phaque,
     "compile-time *{} returns symtab entry when FAKE"
   );
   ${\*phaque} = undef;
 ';
 is(
   ref(\$::{phaque}), 'GLOB',
  'no type coercion when assigning to retval of compile-time *{}'
 );
}

# type coercion on substitutions that match
d167 1
a167 4
    {
	no warnings 'deprecated';
	ok(!defined @@{$a});
    }
d194 1
a195 1
    ok(defined ${$a});
d256 1
a256 1
    my %v;
d258 3
a260 4
    f($v{v});
    is ($v{v}, '*main::DATA');
    is (ref\$v{v}, 'GLOB', 'lvalue assignment preserves globs');
    my $x = readline $v{v};
a261 1
    is ($e, '', '__DIE__ handler never called');
d265 1
a265 1
    my $e = '';
d275 1
a275 5
    is (
      ref\tied(@@ary)->[0], 'GLOB',
     'tied elem assignment preserves globs'
    );
    is ($e, '', '__DIE__ handler not called');
a277 1
    is ($e, '', '__DIE__ handler never called');
d289 1
a289 1
bless \$A::B, q{M};
d336 1
a336 1
    "Inlining of constant doesn't change representation");
d536 1
a536 1
             "Assignment works when glob created midway (bug 45607)"); 1'
d563 1
a563 1
# RT #65582 anonymous glob should be defined, and not coredump when
d566 4
a569 5
#        defined($glob)    "$glob"                   $glob .= ...
# 5.8.8     false           "" with uninit warning   "" with uninit warning
# 5.10.0    true            (coredump)               (coredump)
# 5.1[24]   true            ""                       "" with uninit warning
# 5.16      true            "*__ANON__::..."         "*__ANON__::..."
d574 1
a574 1
    ok(defined $glob, "RT #65582 anon glob should be defined");
d580 2
a581 3
    is($warn, '', "RT #65582 anon glob stringification shouldn't warn");
    is($str,  '*__ANON__::__ANONIO__',
	"RT #65582/#96326 anon glob stringification");
a615 289

# [perl #71686] Globs that are in symbol table can be un-globbed
$sym = undef;
$::{fake} = *sym;
is (eval 'local *::fake = \"chuck"; $fake', 'chuck',
	"Localized glob didn't coerce into a RV");
is ($@@, '', "Can localize FAKE glob that's present in stash");
is (scalar $::{fake}, "*main::sym",
	"Localized FAKE glob's value was correctly restored");

# [perl #1804] *$x assignment when $x is a copy of another glob
# And [perl #77508] (same thing with list assignment)
{
    no warnings 'once';
    my $x = *_random::glob_that_is_not_used_elsewhere;
    *$x = sub{};
    is(
      "$x", '*_random::glob_that_is_not_used_elsewhere',
      '[perl #1804] *$x assignment when $x is FAKE',
    );
    $x = *_random::glob_that_is_not_used_elsewhere;
    (my $dummy, *$x) = (undef,[]);
    is(
      "$x", '*_random::glob_that_is_not_used_elsewhere',
      '[perl #77508] *$x list assignment when $x is FAKE',
    ) or require Devel::Peek, Devel::Peek::Dump($x);
}

# [perl #76540]
# this caused panics or 'Attempt to free unreferenced scalar'
# (its a compile-time issue, so the die lets us skip the prints)
{
    my @@warnings;
    local $SIG{__WARN__} = sub { push @@warnings, @@_ };

    eval <<'EOF';
BEGIN { $::{FOO} = \'bar' }
die "made it";
print FOO, "\n";
print FOO, "\n";
EOF

    like($@@, qr/made it/, "#76540 - no panic");
    ok(!@@warnings, "#76540 - no 'Attempt to free unreferenced scalar'");
}

# [perl #77362] various bugs related to globs as PVLVs
{
 no warnings qw 'once void';
 my %h; # We pass a key of this hash to the subroutine to get a PVLV.
 sub { for(shift) {
  # Set up our glob-as-PVLV
  $_ = *hon;

  # Bad symbol for array
  ok eval{ @@$_; 1 }, 'PVLV glob slots can be autovivified' or diag $@@;

  # This should call TIEHANDLE, not TIESCALAR
  *thext::TIEHANDLE = sub{};
  ok eval{ tie *$_, 'thext'; 1 }, 'PVLV globs can be tied as handles'
   or diag $@@;

  # Assigning undef to the glob should not overwrite it...
  {
   my $w;
   local $SIG{__WARN__} = sub { $w = shift };
   *$_ = undef;
   is $_, "*main::hon", 'PVLV: assigning undef to the glob does nothing';
   like $w, qr\Undefined value assigned to typeglob\,
    'PVLV: assigning undef to the glob warns';
  }

  # Neither should reference assignment.
  *$_ = [];
  is $_, "*main::hon", "PVLV: arrayref assignment assigns to the AV slot";

  # Concatenation should still work.
  ok eval { $_ .= 'thlew' }, 'PVLV concatenation does not die' or diag $@@;
  is $_, '*main::honthlew', 'PVLV concatenation works';

  # And we should be able to overwrite it with a string, number, or refer-
  # ence, too, if we omit the *.
  $_ = *hon; $_ = 'tzor';
  is $_, 'tzor', 'PVLV: assigning a string over a glob';
  $_ = *hon; $_ = 23;
  is $_, 23, 'PVLV: assigning an integer over a glob';
  $_ = *hon; $_ = 23.23;
  is $_, 23.23, 'PVLV: assigning a float over a glob';
  $_ = *hon; $_ = \my $sthat;
  is $_, \$sthat, 'PVLV: assigning a reference over a glob';

  # This bug was found by code inspection. Could this ever happen in
  # real life? :-)
  # This duplicates a file handle, accessing it through a PVLV glob, the
  # glob having been removed from the symbol table, so a stringified form
  # of it does not work. This checks that sv_2io does not stringify a PVLV.
  $_ = *quin;
  open *quin, "test.pl"; # test.pl is as good a file as any
  delete $::{quin};
  ok eval { open my $zow, "<&", $_ }, 'PVLV: sv_2io stringifieth not'
   or diag $@@;

  # Similar tests to make sure sv_2cv etc. do not stringify.
  *$_ = sub { 1 };
  ok eval { &$_ }, "PVLV glob can be called as a sub" or diag $@@;
  *flelp = sub { 2 };
  $_ = 'flelp';
  is eval { &$_ }, 2, 'PVLV holding a string can be called as a sub'
   or diag $@@;

  # Coderef-to-glob assignment when the glob is no longer accessible
  # under its name: These tests are to make sure the OPpASSIGN_CV_TO_GV
  # optimisation takes PVLVs into account, which is why the RHSs have to be
  # named subs.
  use constant gheen => 'quare';
  $_ = *ming;
  delete $::{ming};
  *$_ = \&gheen;
  is eval { &$_ }, 'quare',
   'PVLV: constant assignment when the glob is detached from the symtab'
    or diag $@@;
  $_ = *bength;
  delete $::{bength};
  *gheck = sub { 'lon' };
  *$_ = \&gheck;
  is eval { &$_ }, 'lon',
   'PVLV: coderef assignment when the glob is detached from the symtab'
    or diag $@@;

SKIP: {
    skip_if_miniperl("no dynamic loading on miniperl, so can't load PerlIO::scalar", 1);
    # open should accept a PVLV as its first argument
    $_ = *hon;
    ok eval { open $_,'<', \my $thlext }, 'PVLV can be the first arg to open'
	or diag $@@;
  }

  # -t should not stringify
  $_ = *thlit; delete $::{thlit};
  *$_ = *STDOUT{IO};
  ok defined -t $_, 'PVLV: -t does not stringify';

  # neither should -T
  # but some systems donâ€™t support this on file handles
  my $pass;
  ok
    eval {
     open my $quile, "<", 'test.pl';
     $_ = *$quile;
     $pass = -T $_;
     1
    } ? $pass : $@@ =~ /not implemented on filehandles/,
   "PVLV: -T does not stringify";
  
  # Unopened file handle
  {
   my $w;
   local $SIG{__WARN__} = sub { $w .= shift };
   $_ = *vor;
   close $_;
   like $w, qr\unopened filehandle vor\,
    'PVLV globs get their names reported in unopened error messages';
  }

 }}->($h{k});
}

*aieee = 4;
pass('Can assign integers to typeglobs');
*aieee = 3.14;
pass('Can assign floats to typeglobs');
*aieee = 'pi';
pass('Can assign strings to typeglobs');

{
  package thrext;
  sub TIESCALAR{bless[]}
  sub STORE{ die "No!"}
  sub FETCH{ no warnings 'once'; *thrit }
  tie my $a, "thrext";
  () = "$a"; # do a fetch; now $a holds a glob
  eval { *$a = sub{} };
  untie $a;
  eval { $a = "bar" };
  ::is $a, "bar",
    "[perl #77812] Globs in tied scalars can be reified if STORE dies"
}

# These two crashed prior to 5.13.6. In 5.13.6 they were fatal errors. They
# were fixed in 5.13.7.
ok eval {
  my $glob = \*heen::ISA;
  delete $::{"heen::"};
  *$glob = *bar; 
}, "glob-to-*ISA assignment works when *ISA has lost its stash";
ok eval {
  my $glob = \*slare::ISA;
  delete $::{"slare::"};
  *$glob = []; 
}, "array-to-*ISA assignment works when *ISA has lost its stash";
# These two crashed in 5.13.6. They were likewise fixed in 5.13.7.
ok eval {
  sub greck;
  my $glob = do { no warnings "once"; \*phing::foo};
  delete $::{"phing::"};
  *$glob = *greck; 
}, "Assigning a glob-with-sub to a glob that has lost its stash works";
ok eval {
  sub pon::foo;
  my $glob = \*pon::foo;
  delete $::{"pon::"};
  *$glob = *foo; 
}, "Assigning a glob to a glob-with-sub that has lost its stash works";

{
  package Tie::Alias;
  sub TIESCALAR{ bless \\pop }
  sub FETCH { $${$_[0]} }
  sub STORE { $${$_[0]} = $_[1] }
  package main;
  tie my $alias, 'Tie::Alias', my $var;
  no warnings 'once';
  $var = *galobbe;
  {
    local *$alias = [];
    $var = 3;
    is $alias, 3, "[perl #77926] Glob reification during localisation";
  }
}

# This code causes gp_free to call a destructor when a glob is being
# restored on scope exit. The destructor used to see SVs with a refcount of
# zero inside the glob, which could result in crashes (though not in this
# test case, which just panics).
{
 no warnings 'once';
 my $survived;
 *Trit::DESTROY = sub {
   $thwext = 42;  # panic
   $survived = 1;
 };
 {
  local *thwext;
  $thwext = bless[],'Trit';
  ();
 }
 ok $survived,
  'no error when gp_free calls a destructor that assigns to the gv';
}

# *{undef}
eval { *{my $undef} = 3 };
like $@@, qr/^Can't use an undefined value as a symbol reference at /,
  '*{ $undef } assignment';
eval { *{;undef} = 3 };
like $@@, qr/^Can't use an undefined value as a symbol reference at /,
  '*{ ;undef } assignment';

# [perl #99142] defined &{"foo"} when there is a constant stub
# If I break your module, you get to have it mentioned in Perl's tests. :-)
package HTTP::MobileAttribute::Plugin::Locator {
    use constant LOCATOR_GPS => 1;
    ::ok defined &{__PACKAGE__."::LOCATOR_GPS"},
        'defined &{"name of constant"}';
    ::ok Internals::SvREFCNT(${__PACKAGE__."::"}{LOCATOR_GPS}),
       "stash elem for slot is not freed prematurely";
}

# Check that constants promoted to CVs point to the right GVs when the name
# contains a null.
package lrcg {
  use constant x => 3;
  # These two lines abuse the optimisation that copies the scalar ref from
  # one stash element to another, to get a constant with a null in its name
  *{"yz\0a"} = \&{"x"};
  my $ref = \&{"yz\0a"};
  ::ok !exists $lrcg::{yz},
    'constants w/nulls in their names point 2 the right GVs when promoted';
}

# Look away, please.
# This violates perl's internal structures by fiddling with stashes in a
# way that should never happen, but perl should not start trying to free
# unallocated memory as a result.  There is no ok() or is() because the
# panic that used to occur only occurred during global destruction, and
# only with PERL_DESTRUCT_LEVEL=2.  (The panic itself was sufficient for
# the harness to consider this test script to have failed.)
$::{aoeuaoeuaoeaoeu} = __PACKAGE__; # cow
() = *{"aoeuaoeuaoeaoeu"};
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d15 1
a15 1
plan( tests => 245 );
a168 2
is ("@@{sub { *_{ARRAY} }->(1..3)}", "1 2 3",
    'returning *_{ARRAY} from sub');
a187 6
is *x{NAME}, 'x', '*foo{NAME}';
is *x{PACKAGE}, 'main', '*foo{PACKAGE}';
{ no warnings 'once'; *x = *Foo::y; }
is *x, '*Foo::y', 'glob stringifies as assignee after glob-to-glob assign';
is *x{NAME}, 'x', 'but *foo{NAME} still returns the original name';
is *x{PACKAGE}, 'main', 'and *foo{PACKAGE} the original package';
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d15 1
a15 1
plan( tests => 271 );
a496 8
$::{yarrow} = [4,5,6];
is join("-", eval "yarrow()"), '4-5-6', 'array ref as stash elem';
is ref $::{yarrow}, "ARRAY", 'stash elem is still array ref after use';
is join("-", eval "&yarrow"), '4-5-6', 'calling const list with &';
is join("-", eval "&yarrow(1..10)"), '4-5-6', 'const list ignores & args';
is prototype "yarrow", "", 'const list has "" prototype';
is eval "yarrow", 3, 'const list in scalar cx returns length';

d519 1
a519 1
foreach my $value ({1=>2}, *STDOUT{IO}, \&ok, *STDOUT{FORMAT}) {
a631 28
# Another stringification bug: Test that recursion does not cause lexical
# handles to lose their names.
sub r {
    my @@output;
    @@output = r($_[0]-1) if $_[0];
    open my $fh, "TEST";
    push @@output, $$fh;
    close $fh;
    @@output;
}
is join(' ', r(4)),
  '*main::$fh *main::$fh *main::$fh *main::$fh *main::$fh',
  'recursion does not cause lex handles to lose their names';

# And sub cloning, too; not just recursion
my $close_over_me;
is join(' ', sub {
    () = $close_over_me;
    my @@output;
    @@output = CORE::__SUB__->($_[0]-1) if $_[0];
    open my $fh, "TEST";
    push @@output, $$fh;
    close $fh;
    @@output;
   }->(4)),
  '*main::$fh *main::$fh *main::$fh *main::$fh *main::$fh',
  'sub cloning does not cause lex handles to lose their names';

a913 72
# This is a similar test, for destructors seeing a GV without a reference
# count on its gp.
sub undefine_me_if_you_dare {}
bless \&undefine_me_if_you_dare, "Undefiner";
sub Undefiner::DESTROY {
    undef *undefine_me_if_you_dare;
}
{
    my $w;
    local $SIG{__WARN__} = sub { $w .= shift };
    undef *undefine_me_if_you_dare;
    is $w, undef,
      'undeffing a gv in DESTROY triggered by undeffing the same gv'
}

# [perl #121242]
# More gp_free madness.  gp_free could call a destructor that frees the gv
# whose gp is being freed.
sub Fred::AUTOLOAD { $Fred::AUTOLOAD }
undef *{"Fred::AUTOLOAD"};
pass 'no crash from gp_free triggering gv_try_downgrade';
sub _121242::DESTROY { delete $_121242::{$_[0][0]} };
${"_121242::foo"} = bless ["foo"], _121242::;
undef *{"_121242::foo"};
pass 'no crash from pp_undef/gp_free freeing the gv';
${"_121242::bar"} = bless ["bar"], _121242::;
*{"_121242::bar"} = "bar";
pass 'no crash from sv_setsv/gp_free freeing the gv';
${"_121242::baz"} = bless ["baz"], _121242::;
*{"_121242::baz"} = *foo;
pass 'no crash from glob_assign_glob/gp_free freeing the gv';
{
    my $foo;
    undef *_121242::DESTROY;
    *_121242::DESTROY = sub { undef $foo };
    my $set_up_foo = sub {
        # Make $$foo into a fake glob whose array slot holds a blessed
        # array that undefines $foo, freeing the fake glob.
        $foo = undef;
        $$foo = do {local *bar};
        *$$foo = bless [], _121242::;
    };
    &$set_up_foo;
    $$foo = 3;
    pass 'no crash from sv_setsv/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    utf8::encode $$foo;
    pass 'no crash from sv_utf8_encode/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    open BAR, "TEST";
    $$foo .= <BAR>;
    pass 'no crash from do_readline/sv_unglob/gp_free freeing the gv';
    close BAR;
    &$set_up_foo;
    $$foo .= 3;
    pass 'no crash from pp_concat/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    no warnings;
    $$foo++;
    pass 'no crash from sv_inc/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    $$foo--;
    pass 'no crash from sv_dec/sv_unglob/gp_free freeing the gv';
    &$set_up_foo;
    undef $$foo;
    pass 'no crash from pp_undef/sv_unglob/gp_free freeing the gv';
    $foo = undef;
    $$foo = 3;
    $$foo =~ s/3/$$foo = do {local *bar}; *$$foo = bless [],_121242::; 4/e;
    pass 'no crash from pp_substcont/sv_unglob/gp_free freeing the gv';
}

a943 26
{
  no warnings 'io';
  stat *{"try_downgrade"};
  -T _;
  $bang = $!;
  eval "*try_downgrade if 0";
  -T _;
  is "$!",$bang,
     'try_downgrade does not touch PL_statgv (last stat handle)';
  readline *{"try_downgrade2"};
  my $lastfh = "${^LAST_FH}";
  eval "*try_downgrade2 if 0";
  is ${^LAST_FH}, $lastfh, 'try_downgrade does not touch PL_last_in_gv';
}

is runperl(prog => '$s = STDERR; close $s; undef *$s;'
                  .'eval q-*STDERR if 0-; *$s = *STDOUT{IO}; warn'),
  "Warning: something's wrong at -e line 1.\n",
  "try_downgrade does not touch PL_stderrgv";

is runperl(prog =>
             'use constant foo=>1; BEGIN { $x = \&foo } undef &$x; $x->()',
           stderr=>1),
  "Undefined subroutine &main::foo called at -e line 1.\n",
  "gv_try_downgrade does not anonymise CVs referenced elsewhere";

a952 14

$x = *_119051;
$y = \&$x;
undef $x;
eval { &$y };
pass "No crash due to CvGV(vivified stub) pointing to flattened glob copy";
# Not really supported, but this should not crash either:
$x = *_119051again;
delete $::{_119051again};
$::{_119051again} = $x;    # now we have a fake glob under the right name
$y = \&$x;                 # so when this tries to look up the right GV for
undef $::{_119051again};   # CvGV, it still gets a fake one
eval { $y->() };
pass "No crash due to CvGV pointing to glob copy in the stash";
@


