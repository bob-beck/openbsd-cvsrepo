head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.2
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.8.0.10
	OPENBSD_6_0_BASE:1.1.1.8
	OPENBSD_5_9:1.1.1.8.0.4
	OPENBSD_5_9_BASE:1.1.1.8
	OPENBSD_5_8:1.1.1.8.0.6
	OPENBSD_5_8_BASE:1.1.1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.1.1.8.0.2
	OPENBSD_5_7_BASE:1.1.1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.1.1.7.0.8
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.20;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.32;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.49.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.17;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.36;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# This file is intentionally encoded in latin-1.
#
# Test uc(), lc(), fc(), ucfirst(), lcfirst(), quotemeta() etc

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
    require Config; import Config;
    skip_all_without_unicode_tables();
    require './charset_tools.pl';
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
}

use feature qw( fc );

plan tests => 139 + 4 * 256;

is(lc(undef),	   "", "lc(undef) is ''");
is(lcfirst(undef), "", "lcfirst(undef) is ''");
is(uc(undef),	   "", "uc(undef) is ''");
is(ucfirst(undef), "", "ucfirst(undef) is ''");

{
    no feature 'fc';
    is(CORE::fc(undef), "", "fc(undef) is ''");
    is(CORE::fc(''),    "", "fc('') is ''");

    local $@@;
    eval { fc("eeyup") };
    like($@@, qr/Undefined subroutine &main::fc/, "fc() throws an exception,");

    {
        use feature 'fc';
        local $@@;
        eval { fc("eeyup") };
        ok(!$@@, "...but works after requesting the feature");
    }
}

$a = "HELLO.* world";
$b = "hello.* WORLD";

is("\Q$a\E."      , "HELLO\\.\\*\\ world.", '\Q\E HELLO.* world');
is("\u$a"         , "HELLO\.\* world",      '\u');
is("\l$a"         , "hELLO\.\* world",      '\l');
is("\U$a"         , "HELLO\.\* WORLD",      '\U');
is("\L$a"         , "hello\.\* world",      '\L');
is("\F$a"         , "hello\.\* world",      '\F');

is(quotemeta($a)  , "HELLO\\.\\*\\ world",  'quotemeta');
is(ucfirst($a)    , "HELLO\.\* world",      'ucfirst');
is(lcfirst($a)    , "hELLO\.\* world",      'lcfirst');
is(uc($a)         , "HELLO\.\* WORLD",      'uc');
is(lc($a)         , "hello\.\* world",      'lc');
is(fc($a)         , "hello\.\* world",      'fc');

is("\Q$b\E."      , "hello\\.\\*\\ WORLD.", '\Q\E hello.* WORLD');
is("\u$b"         , "Hello\.\* WORLD",      '\u');
is("\l$b"         , "hello\.\* WORLD",      '\l');
is("\U$b"         , "HELLO\.\* WORLD",      '\U');
is("\L$b"         , "hello\.\* world",      '\L');
is("\F$b"         , "hello\.\* world",      '\F');

is(quotemeta($b)  , "hello\\.\\*\\ WORLD",  'quotemeta');
is(ucfirst($b)    , "Hello\.\* WORLD",      'ucfirst');
is(lcfirst($b)    , "hello\.\* WORLD",      'lcfirst');
is(uc($b)         , "HELLO\.\* WORLD",      'uc');
is(lc($b)         , "hello\.\* world",      'lc');
is(fc($b)         , "hello\.\* world",      'fc');

# \x{100} is LATIN CAPITAL LETTER A WITH MACRON; its bijective lowercase is
# \x{101}, LATIN SMALL LETTER A WITH MACRON.
# Which is also its foldcase.

$a = "\x{100}\x{101}Aa";
$b = "\x{101}\x{100}aA";

is("\Q$a\E."      , "\x{100}\x{101}Aa.", '\Q\E \x{100}\x{101}Aa');
is("\u$a"         , "\x{100}\x{101}Aa",  '\u');
is("\l$a"         , "\x{101}\x{101}Aa",  '\l');
is("\U$a"         , "\x{100}\x{100}AA",  '\U');
is("\L$a"         , "\x{101}\x{101}aa",  '\L');
is("\F$a"         , "\x{101}\x{101}aa",  '\F');

is(quotemeta($a)  , "\x{100}\x{101}Aa",  'quotemeta');
is(ucfirst($a)    , "\x{100}\x{101}Aa",  'ucfirst');
is(lcfirst($a)    , "\x{101}\x{101}Aa",  'lcfirst');
is(uc($a)         , "\x{100}\x{100}AA",  'uc');
is(lc($a)         , "\x{101}\x{101}aa",  'lc');
is(fc($a)         , "\x{101}\x{101}aa",  'fc');

is("\Q$b\E."      , "\x{101}\x{100}aA.", '\Q\E \x{101}\x{100}aA');
is("\u$b"         , "\x{100}\x{100}aA",  '\u');
is("\l$b"         , "\x{101}\x{100}aA",  '\l');
is("\U$b"         , "\x{100}\x{100}AA",  '\U');
is("\L$b"         , "\x{101}\x{101}aa",  '\L');
is("\F$b"         , "\x{101}\x{101}aa",  '\F');

is(quotemeta($b)  , "\x{101}\x{100}aA",  'quotemeta');
is(ucfirst($b)    , "\x{100}\x{100}aA",  'ucfirst');
is(lcfirst($b)    , "\x{101}\x{100}aA",  'lcfirst');
is(uc($b)         , "\x{100}\x{100}AA",  'uc');
is(lc($b)         , "\x{101}\x{101}aa",  'lc');
is(fc($b)         , "\x{101}\x{101}aa",  'fc');

my $sharp_s = uni_to_native("\x{DF}");
# \x{DF} is LATIN SMALL LETTER SHARP S, its uppercase is SS or \x{53}\x{53};
# \x{149} is LATIN SMALL LETTER N PRECEDED BY APOSTROPHE, its uppercase is
# \x{2BC}\x{E4} or MODIFIER LETTER APOSTROPHE and N.

is("\U${sharp_s}aB\x{149}cD", "SSAB\x{2BC}NCD", "multicharacter uppercase");

# The \x{DF} is its own lowercase, ditto for \x{149}.
# There are no single character -> multiple characters lowercase mappings.

is("\L${sharp_s}aB\x{149}cD", "${sharp_s}ab\x{149}cd",
       "multicharacter lowercase");

# \x{DF} is LATIN SMALL LETTER SHARP S, its foldcase is ss or \x{73}\x{73};
# \x{149} is LATIN SMALL LETTER N PRECEDED BY APOSTROPHE, its foldcase is
# \x{2BC}\x{6E} or MODIFIER LETTER APOSTROPHE and n.
# Note that is this further tested in t/uni/fold.t

is("\F${sharp_s}aB\x{149}cD", "ssab\x{2BC}ncd", "multicharacter foldcase");


# titlecase is used for \u / ucfirst.

# \x{587} is ARMENIAN SMALL LIGATURE ECH YIWN and its titlecase is
# \x{535}\x{582} ARMENIAN CAPITAL LETTER ECH + ARMENIAN SMALL LETTER YIWN
# while its lowercase is 
# \x{587} itself
# and its uppercase is
# \x{535}\x{552} ARMENIAN CAPITAL LETTER ECH + ARMENIAN CAPITAL LETTER YIWN
# The foldcase is \x{565}\x{582} ARMENIAN SMALL LETTER ECH + ARMENIAN SMALL LETTER YIWN

$a = "\x{587}";

is("\L\x{587}" , "\x{587}",        "ligature lowercase");
is("\u\x{587}" , "\x{535}\x{582}", "ligature titlecase");
is("\U\x{587}" , "\x{535}\x{552}", "ligature uppercase");
is("\F\x{587}" , "\x{565}\x{582}", "ligature foldcase");

# mktables had problems where many-to-one case mappings didn't work right.
# The lib/uni/fold.t should give the fourth folding, "casefolding", a good
# workout.
# \x{01C4} is LATIN CAPITAL LETTER DZ WITH CARON
# \x{01C5} is LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
# \x{01C6} is LATIN SMALL LETTER DZ WITH CARON
# \x{03A3} is GREEK CAPITAL LETTER SIGMA
# \x{03C2} is GREEK SMALL LETTER FINAL SIGMA
# \x{03C3} is GREEK SMALL LETTER SIGMA

is(lc("\x{1C4}") , "\x{1C6}",      "U+01C4 lc is U+01C6");
is(lc("\x{1C5}") , "\x{1C6}",      "U+01C5 lc is U+01C6, too");

is(ucfirst("\x{3C2}") , "\x{3A3}", "U+03C2 ucfirst is U+03A3");
is(ucfirst("\x{3C3}") , "\x{3A3}", "U+03C3 ucfirst is U+03A3, too");

is(uc("\x{1C5}") , "\x{1C4}",      "U+01C5 uc is U+01C4");
is(uc("\x{1C6}") , "\x{1C4}",      "U+01C6 uc is U+01C4, too");

# #18107: A host of bugs involving [ul]c{,first}. AMS 20021106
$a = "\x{3c3}foo.bar"; # \x{3c3} == GREEK SMALL LETTER SIGMA.
$b = "\x{3a3}FOO.BAR"; # \x{3a3} == GREEK CAPITAL LETTER SIGMA.

($c = $b) =~ s/(\w+)/lc($1)/ge;
is($c , $a, "Using s///e to change case.");

($c = $a) =~ s/(\p{IsWord}+)/uc($1)/ge;
is($c , $b, "Using s///e to change case.");

($c = $a) =~ s/(\p{IsWord}+)/fc($1)/ge;
is($c , $a, "Using s///e to foldcase.");

($c = $b) =~ s/(\p{IsWord}+)/lcfirst($1)/ge;
is($c , "\x{3c3}FOO.bAR", "Using s///e to change case.");

($c = $a) =~ s/(\p{IsWord}+)/ucfirst($1)/ge;
is($c , "\x{3a3}foo.Bar", "Using s///e to change case.");

# #18931: perl5.8.0 bug in \U..\E processing
# Test case from Nicholas Clark.
for my $a (0,1) {
    $_ = 'abcdefgh';
    $_ .= chr 256;
    chop;
    /(.*)/;
    is(uc($1), "ABCDEFGH", "[perl #18931]");
}

{
    foreach (0, 1) {
	$a = v10.v257;
	chop $a;
	$a =~ s/^(\s*)(\w*)/$1\u$2/;
	is($a, v10, "[perl #18857]");
    } 
}


# [perl #38619] Bug in lc and uc (interaction between UTF-8, substr, and lc/uc)

for ("a\x{100}", "xyz\x{100}") {
    is(substr(uc($_), 0), uc($_), "[perl #38619] uc");
}
for ("A\x{100}", "XYZ\x{100}") {
    is(substr(lc($_), 0), lc($_), "[perl #38619] lc");
}
for ("a\x{100}", "ßyz\x{100}") { # ß to Ss (different length)
    is(substr(ucfirst($_), 0), ucfirst($_), "[perl #38619] ucfirst");
}

#fc() didn't exist back then, but coverage is coverage.
for ("a\x{100}", "ßyz\x{100}", "xyz\x{100}", "XYZ\x{100}") { # ß to Ss (different length)
    is(substr(fc($_), 0), fc($_), "[perl #38619] fc");
}

# Related to [perl #38619]
# the original report concerns PERL_MAGIC_utf8.
# these cases concern PERL_MAGIC_regex_global.

for (map { $_ } "a\x{100}", "abc\x{100}", "\x{100}") {
    chop; # get ("a", "abc", "") in utf8
    my $return =  uc($_) =~ /\G(.?)/g;
    my $result = $return ? $1 : "not";
    my $expect = (uc($_) =~ /(.?)/g)[0];
    is($return, 1,       "[perl #38619]");
    is($result, $expect, "[perl #38619]");
}

for (map { $_ } "A\x{100}", "ABC\x{100}", "\x{100}") {
    chop; # get ("A", "ABC", "") in utf8
    my $return =  lc($_) =~ /\G(.?)/g;
    my $result = $return ? $1 : "not";
    my $expect = (lc($_) =~ /(.?)/g)[0];
    is($return, 1,       "[perl #38619]");
    is($result, $expect, "[perl #38619]");
}

for (map { $_ } "A\x{100}", "ABC\x{100}", "\x{100}") {
    chop; # get ("A", "ABC", "") in utf8
    my $return =  fc($_) =~ /\G(.?)/g;
    my $result = $return ? $1 : "not";
    my $expect = (fc($_) =~ /(.?)/g)[0];
    is($return, 1,       "[perl #38619]");
    is($result, $expect, "[perl #38619]");
}

for (1, 4, 9, 16, 25) {
    is(uc "\x{03B0}" x $_, "\x{3a5}\x{308}\x{301}" x $_,
       'uc U+03B0 grows threefold');

    is(lc "\x{0130}" x $_, "i\x{307}" x $_, 'lc U+0130 grows');

    is(fc "\x{03B0}" x $_, "\x{3C5}\x{308}\x{301}" x $_,
       'fc U+03B0 grows threefold');
}

# bug #43207
my $temp = "HellO";
for ("$temp") {
    lc $_;
    is($_, "HellO", '[perl #43207] lc($_) modifying $_');
}
for ("$temp") {
    fc $_;
    is($_, "HellO", '[perl #43207] fc($_) modifying $_');
}
for ("$temp") {
    uc $_;
    is($_, "HellO", '[perl #43207] uc($_) modifying $_');
}
for ("$temp") {
    ucfirst $_;
    is($_, "HellO", '[perl #43207] ucfirst($_) modifying $_');
}
for ("$temp") {
    lcfirst $_;
    is($_, "HellO", '[perl #43207] lcfirst($_) modifying $_');
}

# new in Unicode 5.1.0
is(lc("\x{1E9E}"), uni_to_native("\x{df}"), "lc(LATIN CAPITAL LETTER SHARP S)");

{
    use feature 'unicode_strings';
    use bytes;
    is(lc(uni_to_native("\xc0")), uni_to_native("\xc0"), "lc of above-ASCII Latin1 is itself under use bytes");
    is(lcfirst(uni_to_native("\xc0")), uni_to_native("\xc0"), "lcfirst of above-ASCII Latin1 is itself under use bytes");
    is(uc(uni_to_native("\xe0")), uni_to_native("\xe0"), "uc of above-ASCII Latin1 is itself under use bytes");
    is(ucfirst(uni_to_native("\xe0")), uni_to_native("\xe0"), "ucfirst of above-ASCII Latin1 is itself under use bytes");
}

# Brought up in ticket #117855: Constant folding applied to uc() should use
# the right set of hints.
fresh_perl_like(<<'constantfolding', qr/^(\d+),\1\z/, {},
    my $function = "uc";
    my $char = "\xff";
    {
        use feature 'unicode_strings';
        print ord uc($char), ",",
              ord eval "$function('$char')", "\n";
    }
constantfolding
    'folded uc() in string eval uses the right hints');

# In-place lc/uc should not corrupt string buffers when given a non-utf8-
# flagged thingy that stringifies to utf8
$h{k} = bless[], "\x{3b0}\x{3b0}\x{3b0}bcde"; # U+03B0 grows with uc()
   # using delete marks it as TEMP, so uc-in-place is permitted
like uc delete $h{k}, qr "^(?:\x{3a5}\x{308}\x{301}){3}BCDE=ARRAY\(.*\)",
    'uc(TEMP ref) does not produce a corrupt string';
$h{k} = bless[], "\x{130}bcde"; # U+0130 grows with lc()
   # using delete marks it as TEMP, so uc-in-place is permitted
like lc delete $h{k}, qr "^i\x{307}bcde=array\(.*\)",
    'lc(TEMP ref) does not produce a corrupt string';

# List::Util::first() etc sets $_ to an SvTEMP without raising its
# refcount.  This was causing lc() etc to unsafely modify in-place.
# see http://nntp.perl.org/group/perl.perl5.porters/228213

SKIP: {
    skip "no List::Util on miniperl", 5, if is_miniperl;
    require List::Util;
    my %hl = qw(a 1 b 2 c 3);
    my %hu = qw(A 1 B 2 C 3);
    my $x;
    $x = List::Util::first(sub { uc      $_ eq 'A' }, keys %hl);
    is($x, "a", "first { uc }");
    $x = List::Util::first(sub { ucfirst $_ eq 'A' }, keys %hl);
    is($x, "a", "first { ucfirst }");
    $x = List::Util::first(sub { lc      $_ eq 'a' }, keys %hu);
    is($x, "A", "first { lc }");
    $x = List::Util::first(sub { lcfirst $_ eq 'a' }, keys %hu);
    is($x, "A", "first { lcfirst }");
    $x = List::Util::first(sub { fc      $_ eq 'a' }, keys %hu);
    is($x, "A", "first { fc }");
}


my $utf8_locale = find_utf8_ctype_locale();

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 4*256 unless defined $utf8_locale;

    use feature qw( unicode_strings );

    no locale;

    my @@unicode_lc;
    my @@unicode_uc;
    my @@unicode_lcfirst;
    my @@unicode_ucfirst;

    # Get all the values outside of 'locale'
    for my $i (0 .. 255) {
        push @@unicode_lc, lc(chr $i);
        push @@unicode_uc, uc(chr $i);
        push @@unicode_lcfirst, lcfirst(chr $i);
        push @@unicode_ucfirst, ucfirst(chr $i);
    }

    use locale;
    setlocale(LC_CTYPE, $utf8_locale);

    for my $i (0 .. 255) {
        is(lc(chr $i), $unicode_lc[$i], "In a UTF-8 locale, lc(chr $i) is the same as official Unicode");
        is(uc(chr $i), $unicode_uc[$i], "In a UTF-8 locale, uc(chr $i) is the same as official Unicode");
        is(lcfirst(chr $i), $unicode_lcfirst[$i], "In a UTF-8 locale, lcfirst(chr $i) is the same as official Unicode");
        is(ucfirst(chr $i), $unicode_ucfirst[$i], "In a UTF-8 locale, ucfirst(chr $i) is the same as official Unicode");
    }
}
@


1.1
log
@Initial revision
@
text
@d3 15
a17 1
print "1..51\n";
d19 1
a19 1
my $test = 1;
d21 19
a39 13
sub ok {
    if ($_[0]) {
	if ($_[1]) {
	    print "ok $test - $_[1]\n";
	} else {
	    print "ok $test\n";
	}
    } else {
	if ($_[1]) {
	    print "not ok $test - $_[1]\n";
	} else {
	    print "not ok $test\n";
	}
a40 1
    $test++;
d46 27
a72 23
ok("\Q$a\E."      eq "HELLO\\.\\*\\ world.", '\Q\E HELLO.* world');
ok("\u$a"         eq "HELLO\.\* world",      '\u');
ok("\l$a"         eq "hELLO\.\* world",      '\l');
ok("\U$a"         eq "HELLO\.\* WORLD",      '\U');
ok("\L$a"         eq "hello\.\* world",      '\L');

ok(quotemeta($a)  eq "HELLO\\.\\*\\ world",  'quotemeta');
ok(ucfirst($a)    eq "HELLO\.\* world",      'ucfirst');
ok(lcfirst($a)    eq "hELLO\.\* world",      'lcfirst');
ok(uc($a)         eq "HELLO\.\* WORLD",      'uc');
ok(lc($a)         eq "hello\.\* world",      'lc');

ok("\Q$b\E."      eq "hello\\.\\*\\ WORLD.", '\Q\E hello.* WORLD');
ok("\u$b"         eq "Hello\.\* WORLD",      '\u');
ok("\l$b"         eq "hello\.\* WORLD",      '\l');
ok("\U$b"         eq "HELLO\.\* WORLD",      '\U');
ok("\L$b"         eq "hello\.\* world",      '\L');

ok(quotemeta($b)  eq "hello\\.\\*\\ WORLD",  'quotemeta');
ok(ucfirst($b)    eq "Hello\.\* WORLD",      'ucfirst');
ok(lcfirst($b)    eq "hello\.\* WORLD",      'lcfirst');
ok(uc($b)         eq "HELLO\.\* WORLD",      'uc');
ok(lc($b)         eq "hello\.\* world",      'lc');
d76 1
d81 27
a107 23
ok("\Q$a\E."      eq "\x{100}\x{101}Aa.", '\Q\E \x{100}\x{101}Aa');
ok("\u$a"         eq "\x{100}\x{101}Aa",  '\u');
ok("\l$a"         eq "\x{101}\x{101}Aa",  '\l');
ok("\U$a"         eq "\x{100}\x{100}AA",  '\U');
ok("\L$a"         eq "\x{101}\x{101}aa",  '\L');

ok(quotemeta($a)  eq "\x{100}\x{101}Aa",  'quotemeta');
ok(ucfirst($a)    eq "\x{100}\x{101}Aa",  'ucfirst');
ok(lcfirst($a)    eq "\x{101}\x{101}Aa",  'lcfirst');
ok(uc($a)         eq "\x{100}\x{100}AA",  'uc');
ok(lc($a)         eq "\x{101}\x{101}aa",  'lc');

ok("\Q$b\E."      eq "\x{101}\x{100}aA.", '\Q\E \x{101}\x{100}aA');
ok("\u$b"         eq "\x{100}\x{100}aA",  '\u');
ok("\l$b"         eq "\x{101}\x{100}aA",  '\l');
ok("\U$b"         eq "\x{100}\x{100}AA",  '\U');
ok("\L$b"         eq "\x{101}\x{101}aa",  '\L');

ok(quotemeta($b)  eq "\x{101}\x{100}aA",  'quotemeta');
ok(ucfirst($b)    eq "\x{100}\x{100}aA",  'ucfirst');
ok(lcfirst($b)    eq "\x{101}\x{100}aA",  'lcfirst');
ok(uc($b)         eq "\x{100}\x{100}AA",  'uc');
ok(lc($b)         eq "\x{101}\x{101}aa",  'lc');
d109 1
d114 1
a114 12
# In EBCDIC \x{DF} is LATIN SMALL LETTER Y WITH DIAERESIS,
# and it's uppercase is \x{178}, LATIN CAPITAL LETTER Y WITH DIAERESIS.

if (ord("A") == 193) { # EBCDIC
    ok("\U\x{DF}aB\x{149}cD" eq "\x{178}AB\x{2BC}NCD",
       "multicharacter uppercase");
} elsif (ord("A") == 65) {
    ok("\U\x{DF}aB\x{149}cD" eq "SSAB\x{2BC}NCD",
       "multicharacter uppercase");
} else {
    ok(0, "what is your encoding?");
}
d119 1
a119 2
if (ord("A") == 193) { # EBCDIC
    ok("\LaB\x{149}cD" eq "ab\x{149}cd",
d121 8
a128 6
} elsif (ord("A") == 65) {
    ok("\L\x{DF}aB\x{149}cD" eq "\x{DF}ab\x{149}cd",
       "multicharacter lowercase");
} else {
    ok(0, "what is your encoding?");
}
d138 1
d142 4
a145 3
ok("\L\x{587}" eq "\x{587}",        "ligature lowercase");
ok("\u\x{587}" eq "\x{535}\x{582}", "ligature titlecase");
ok("\U\x{587}" eq "\x{535}\x{552}", "ligature uppercase");
d148 1
a148 1
# The lib/unifold.t should give the fourth folding, "casefolding", a good
d150 106
d257 1
a257 2
ok(lc("\x{1C4}") eq "\x{1C6}",      "U+01C4 lc is U+01C6");
ok(lc("\x{1C5}") eq "\x{1C6}",      "U+01C5 lc is U+01C6, too");
d259 3
a261 2
ok(ucfirst("\x{3C2}") eq "\x{3A3}", "U+03C2 ucfirst is U+03A3");
ok(ucfirst("\x{3C3}") eq "\x{3A3}", "U+03C3 ucfirst is U+03A3, too");
d263 47
a309 2
ok(uc("\x{1C5}") eq "\x{1C4}",      "U+01C5 uc is U+01C4");
ok(uc("\x{1C6}") eq "\x{1C4}",      "U+01C6 uc is U+01C4, too");
d311 66
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d3 19
a21 4
BEGIN {
    chdir 't';
    @@INC = '../lib';
    require './test.pl';
a23 2
plan tests => 59;

d27 23
a49 23
is("\Q$a\E."      , "HELLO\\.\\*\\ world.", '\Q\E HELLO.* world');
is("\u$a"         , "HELLO\.\* world",      '\u');
is("\l$a"         , "hELLO\.\* world",      '\l');
is("\U$a"         , "HELLO\.\* WORLD",      '\U');
is("\L$a"         , "hello\.\* world",      '\L');

is(quotemeta($a)  , "HELLO\\.\\*\\ world",  'quotemeta');
is(ucfirst($a)    , "HELLO\.\* world",      'ucfirst');
is(lcfirst($a)    , "hELLO\.\* world",      'lcfirst');
is(uc($a)         , "HELLO\.\* WORLD",      'uc');
is(lc($a)         , "hello\.\* world",      'lc');

is("\Q$b\E."      , "hello\\.\\*\\ WORLD.", '\Q\E hello.* WORLD');
is("\u$b"         , "Hello\.\* WORLD",      '\u');
is("\l$b"         , "hello\.\* WORLD",      '\l');
is("\U$b"         , "HELLO\.\* WORLD",      '\U');
is("\L$b"         , "hello\.\* world",      '\L');

is(quotemeta($b)  , "hello\\.\\*\\ WORLD",  'quotemeta');
is(ucfirst($b)    , "Hello\.\* WORLD",      'ucfirst');
is(lcfirst($b)    , "hello\.\* WORLD",      'lcfirst');
is(uc($b)         , "HELLO\.\* WORLD",      'uc');
is(lc($b)         , "hello\.\* world",      'lc');
d57 23
a79 23
is("\Q$a\E."      , "\x{100}\x{101}Aa.", '\Q\E \x{100}\x{101}Aa');
is("\u$a"         , "\x{100}\x{101}Aa",  '\u');
is("\l$a"         , "\x{101}\x{101}Aa",  '\l');
is("\U$a"         , "\x{100}\x{100}AA",  '\U');
is("\L$a"         , "\x{101}\x{101}aa",  '\L');

is(quotemeta($a)  , "\x{100}\x{101}Aa",  'quotemeta');
is(ucfirst($a)    , "\x{100}\x{101}Aa",  'ucfirst');
is(lcfirst($a)    , "\x{101}\x{101}Aa",  'lcfirst');
is(uc($a)         , "\x{100}\x{100}AA",  'uc');
is(lc($a)         , "\x{101}\x{101}aa",  'lc');

is("\Q$b\E."      , "\x{101}\x{100}aA.", '\Q\E \x{101}\x{100}aA');
is("\u$b"         , "\x{100}\x{100}aA",  '\u');
is("\l$b"         , "\x{101}\x{100}aA",  '\l');
is("\U$b"         , "\x{100}\x{100}AA",  '\U');
is("\L$b"         , "\x{101}\x{101}aa",  '\L');

is(quotemeta($b)  , "\x{101}\x{100}aA",  'quotemeta');
is(ucfirst($b)    , "\x{100}\x{100}aA",  'ucfirst');
is(lcfirst($b)    , "\x{101}\x{100}aA",  'lcfirst');
is(uc($b)         , "\x{100}\x{100}AA",  'uc');
is(lc($b)         , "\x{101}\x{101}aa",  'lc');
d89 1
a89 1
    is("\U\x{DF}aB\x{149}cD" , "\x{178}AB\x{2BC}NCD",
d92 1
a92 1
    is("\U\x{DF}aB\x{149}cD" , "SSAB\x{2BC}NCD",
d95 1
a95 1
    fail("what is your encoding?");
d102 1
a102 1
    is("\LaB\x{149}cD" , "ab\x{149}cd",
d105 1
a105 1
    is("\L\x{DF}aB\x{149}cD" , "\x{DF}ab\x{149}cd",
d108 1
a108 1
    fail("what is your encoding?");
d122 3
a124 3
is("\L\x{587}" , "\x{587}",        "ligature lowercase");
is("\u\x{587}" , "\x{535}\x{582}", "ligature titlecase");
is("\U\x{587}" , "\x{535}\x{552}", "ligature uppercase");
d128 10
a137 42
# workout. 
# \x{01C4} is LATIN CAPITAL LETTER DZ WITH CARON
# \x{01C5} is LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON
# \x{01C6} is LATIN SMALL LETTER DZ WITH CARON
# \x{03A3} is GREEK CAPITAL LETTER SIGMA
# \x{03C2} is GREEK SMALL LETTER FINAL SIGMA
# \x{03C3} is GREEK SMALL LETTER SIGMA

is(lc("\x{1C4}") , "\x{1C6}",      "U+01C4 lc is U+01C6");
is(lc("\x{1C5}") , "\x{1C6}",      "U+01C5 lc is U+01C6, too");

is(ucfirst("\x{3C2}") , "\x{3A3}", "U+03C2 ucfirst is U+03A3");
is(ucfirst("\x{3C3}") , "\x{3A3}", "U+03C3 ucfirst is U+03A3, too");

is(uc("\x{1C5}") , "\x{1C4}",      "U+01C5 uc is U+01C4");
is(uc("\x{1C6}") , "\x{1C4}",      "U+01C6 uc is U+01C4, too");

# #18107: A host of bugs involving [ul]c{,first}. AMS 20021106
$a = "\x{3c3}foo.bar"; # \x{3c3} == GREEK SMALL LETTER SIGMA.
$b = "\x{3a3}FOO.BAR"; # \x{3a3} == GREEK CAPITAL LETTER SIGMA.

($c = $b) =~ s/(\w+)/lc($1)/ge;
is($c , $a, "Using s///e to change case.");

($c = $a) =~ s/(\w+)/uc($1)/ge;
is($c , $b, "Using s///e to change case.");

($c = $b) =~ s/(\w+)/lcfirst($1)/ge;
is($c , "\x{3c3}FOO.bAR", "Using s///e to change case.");

($c = $a) =~ s/(\w+)/ucfirst($1)/ge;
is($c , "\x{3a3}foo.Bar", "Using s///e to change case.");

# #18931: perl5.8.0 bug in \U..\E processing
# Test case from Nick Clark.
for my $a (0,1) {
    $_ = 'abcdefgh';
    $_ .= chr 256;
    chop;
    /(.*)/;
    is(uc($1), "ABCDEFGH", "[perl #18931]");
}
a138 9
{
    foreach (0, 1) {
	$a = v10.v257;
	chop $a;
	$a =~ s/^(\s*)(\w*)/$1\u$2/;
	is($a, v10, "[perl #18857]");
	$test++;
    } 
}
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d114 2
a115 2
# The lib/uni/fold.t should give the fourth folding, "casefolding", a good
# workout (one cannot directly get that from Perl). 
d149 1
a149 1
# Test case from Nicholas Clark.
d164 1
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
a9 1
plan tests => 88;
a164 49
}


# [perl #38619] Bug in lc and uc (interaction between UTF-8, substr, and lc/uc)

for ("a\x{100}", "xyz\x{100}") {
    is(substr(uc($_), 0), uc($_), "[perl #38619] uc");
}
for ("A\x{100}", "XYZ\x{100}") {
    is(substr(lc($_), 0), lc($_), "[perl #38619] lc");
}
for ("a\x{100}", "ßyz\x{100}") { # ß to Ss (different length)
    is(substr(ucfirst($_), 0), ucfirst($_), "[perl #38619] ucfirst");
}

# Related to [perl #38619]
# the original report concerns PERL_MAGIC_utf8.
# these cases concern PERL_MAGIC_regex_global.

for (map { $_ } "a\x{100}", "abc\x{100}", "\x{100}") {
    chop; # get ("a", "abc", "") in utf8
    my $return =  uc($_) =~ /\G(.?)/g;
    my $result = $return ? $1 : "not";
    my $expect = (uc($_) =~ /(.?)/g)[0];
    is($return, 1,       "[perl #38619]");
    is($result, $expect, "[perl #38619]");
}

for (map { $_ } "A\x{100}", "ABC\x{100}", "\x{100}") {
    chop; # get ("A", "ABC", "") in utf8
    my $return =  lc($_) =~ /\G(.?)/g;
    my $result = $return ? $1 : "not";
    my $expect = (lc($_) =~ /(.?)/g)[0];
    is($return, 1,       "[perl #38619]");
    is($result, $expect, "[perl #38619]");
}

for (1, 4, 9, 16, 25) {
    is(uc "\x{03B0}" x $_, "\x{3a5}\x{308}\x{301}" x $_,
       'uc U+03B0 grows threefold');

    is(lc "\x{0130}" x $_, "i\x{307}" x $_, 'lc U+0130 grows');
}

# bug #43207
my $temp = "Hello";
for ("$temp") {
    lc $_;
    is($_, "Hello");
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d9 1
a9 6
plan tests => 93;

is(lc(undef),	   "", "lc(undef) is ''");
is(lcfirst(undef), "", "lcfirst(undef) is ''");
is(uc(undef),	   "", "uc(undef) is ''");
is(ucfirst(undef), "", "ucfirst(undef) is ''");
a214 3

# new in Unicode 5.1.0
is(lc("\x{1E9E}"), "\x{df}", "lc(LATIN CAPITAL LETTER SHARP S)");
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d144 1
a144 1
($c = $a) =~ s/(\p{IsWord}+)/uc($1)/ge;
d147 1
a147 1
($c = $b) =~ s/(\p{IsWord}+)/lcfirst($1)/ge;
d150 1
a150 1
($c = $a) =~ s/(\p{IsWord}+)/ucfirst($1)/ge;
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a2 2
# This file is intentionally encoded in latin-1.

d9 1
a9 3
use feature qw( fc );

plan tests => 128;
a15 17
{
    no feature 'fc';
    is(CORE::fc(undef), "", "fc(undef) is ''");
    is(CORE::fc(''),    "", "fc('') is ''");

    local $@@;
    eval { fc("eeyup") };
    like($@@, qr/Undefined subroutine &main::fc/, "fc() throws an exception,");

    {
        use feature 'fc';
        local $@@;
        eval { fc("eeyup") };
        ok(!$@@, "...but works after requesting the feature");
    }
}

a23 1
is("\F$a"         , "hello\.\* world",      '\F');
a29 1
is(fc($a)         , "hello\.\* world",      'fc');
a35 1
is("\F$b"         , "hello\.\* world",      '\F');
a41 1
is(fc($b)         , "hello\.\* world",      'fc');
a44 1
# Which is also its foldcase.
a53 1
is("\F$a"         , "\x{101}\x{101}aa",  '\F');
a59 1
is(fc($a)         , "\x{101}\x{101}aa",  'fc');
a65 1
is("\F$b"         , "\x{101}\x{101}aa",  '\F');
a71 1
is(fc($b)         , "\x{101}\x{101}aa",  'fc');
d77 8
a84 1
is(latin1_to_native("\U\x{DF}aB\x{149}cD"), latin1_to_native("SSAB\x{2BC}NCD"),
d86 3
d93 5
a97 1
is(latin1_to_native("\L\x{DF}aB\x{149}cD"), latin1_to_native("\x{DF}ab\x{149}cd"),
d99 3
a101 9

# \x{DF} is LATIN SMALL LETTER SHARP S, its foldcase is ss or \x{73}\x{73};
# \x{149} is LATIN SMALL LETTER N PRECEDED BY APOSTROPHE, its foldcase is
# \x{2BC}\x{6E} or MODIFIER LETTER APOSTROPHE and n.
# Note that is this further tested in t/uni/fold.t

is(latin1_to_native("\F\x{DF}aB\x{149}cD"), latin1_to_native("ssab\x{2BC}ncd"),
       "multicharacter foldcase");

a110 1
# The foldcase is \x{565}\x{582} ARMENIAN SMALL LETTER ECH + ARMENIAN SMALL LETTER YIWN
a116 1
is("\F\x{587}" , "\x{565}\x{582}", "ligature foldcase");
d120 1
a120 1
# workout.
a146 3
($c = $a) =~ s/(\p{IsWord}+)/fc($1)/ge;
is($c , $a, "Using s///e to foldcase.");

a184 5
#fc() didn't exist back then, but coverage is coverage.
for ("a\x{100}", "ßyz\x{100}", "xyz\x{100}", "XYZ\x{100}") { # ß to Ss (different length)
    is(substr(fc($_), 0), fc($_), "[perl #38619] fc");
}

a206 9
for (map { $_ } "A\x{100}", "ABC\x{100}", "\x{100}") {
    chop; # get ("A", "ABC", "") in utf8
    my $return =  fc($_) =~ /\G(.?)/g;
    my $result = $return ? $1 : "not";
    my $expect = (fc($_) =~ /(.?)/g)[0];
    is($return, 1,       "[perl #38619]");
    is($result, $expect, "[perl #38619]");
}

a211 3

    is(fc "\x{03B0}" x $_, "\x{3C5}\x{308}\x{301}" x $_,
       'fc U+03B0 grows threefold');
a220 7
# bug #43207
my $temp = "Hello";
for ("$temp") {
    fc $_;
    is($_, "Hello");
}

a222 9

{
    use feature 'unicode_strings';
    use bytes;
    is(lc("\xc0"), "\xc0", "lc of above-ASCII Latin1 is itself under use bytes");
    is(lcfirst("\xc0"), "\xc0", "lcfirst of above-ASCII Latin1 is itself under use bytes");
    is(uc("\xe0"), "\xe0", "uc of above-ASCII Latin1 is itself under use bytes");
    is(ucfirst("\xe0"), "\xe0", "ucfirst of above-ASCII Latin1 is itself under use bytes");
}
@


1.1.1.8
log
@Import perl-5.20.1
@
text
@a7 1
    require Config; import Config;
a8 1
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
d13 1
a13 1
plan tests => 134 + 4 * 256;
d259 1
a259 1
my $temp = "HellO";
d262 1
a262 1
    is($_, "HellO", '[perl #43207] lc($_) modifying $_');
d264 3
d269 1
a269 13
    is($_, "HellO", '[perl #43207] fc($_) modifying $_');
}
for ("$temp") {
    uc $_;
    is($_, "HellO", '[perl #43207] uc($_) modifying $_');
}
for ("$temp") {
    ucfirst $_;
    is($_, "HellO", '[perl #43207] ucfirst($_) modifying $_');
}
for ("$temp") {
    lcfirst $_;
    is($_, "HellO", '[perl #43207] lcfirst($_) modifying $_');
a281 59
}

# Brought up in ticket #117855: Constant folding applied to uc() should use
# the right set of hints.
fresh_perl_like(<<'constantfolding', qr/^(\d+),\1\z/, {},
    my $function = "uc";
    my $char = "\xff";
    {
        use feature 'unicode_strings';
        print ord uc($char), ",",
              ord eval "$function('$char')", "\n";
    }
constantfolding
    'folded uc() in string eval uses the right hints');

# In-place lc/uc should not corrupt string buffers when given a non-utf8-
# flagged thingy that stringifies to utf8
$h{k} = bless[], "\x{3b0}\x{3b0}\x{3b0}bcde"; # U+03B0 grows with uc()
   # using delete marks it as TEMP, so uc-in-place is permitted
like uc delete $h{k}, qr "^(?:\x{3a5}\x{308}\x{301}){3}BCDE=ARRAY\(.*\)",
    'uc(TEMP ref) does not produce a corrupt string';
$h{k} = bless[], "\x{130}bcde"; # U+0130 grows with lc()
   # using delete marks it as TEMP, so uc-in-place is permitted
like lc delete $h{k}, qr "^i\x{307}bcde=array\(.*\)",
    'lc(TEMP ref) does not produce a corrupt string';


my $utf8_locale = find_utf8_ctype_locale();

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 4*256 unless defined $utf8_locale;

    use feature qw( unicode_strings );

    no locale;

    my @@unicode_lc;
    my @@unicode_uc;
    my @@unicode_lcfirst;
    my @@unicode_ucfirst;

    # Get all the values outside of 'locale'
    for my $i (0 .. 255) {
        push @@unicode_lc, lc(chr $i);
        push @@unicode_uc, uc(chr $i);
        push @@unicode_lcfirst, lcfirst(chr $i);
        push @@unicode_ucfirst, ucfirst(chr $i);
    }

    use if $Config{d_setlocale}, qw(POSIX locale_h);
    use locale;
    setlocale(LC_CTYPE, $utf8_locale);

    for my $i (0 .. 255) {
        is(lc(chr $i), $unicode_lc[$i], "In a UTF-8 locale, lc(chr $i) is the same as official Unicode");
        is(uc(chr $i), $unicode_uc[$i], "In a UTF-8 locale, uc(chr $i) is the same as official Unicode");
        is(lcfirst(chr $i), $unicode_lcfirst[$i], "In a UTF-8 locale, lcfirst(chr $i) is the same as official Unicode");
        is(ucfirst(chr $i), $unicode_ucfirst[$i], "In a UTF-8 locale, ucfirst(chr $i) is the same as official Unicode");
    }
@


