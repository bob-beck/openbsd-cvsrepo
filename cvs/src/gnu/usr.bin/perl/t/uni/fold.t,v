head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.2
	OPENBSD_6_2_BASE:1.8
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.14
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.12
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.10
	OPENBSD_5_0:1.1.1.2.0.8
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.6
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2015.04.25.19.26.23;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	3qGYFVvfrExB70FB;

1.6
date	2015.04.25.19.14.49;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	XRK22kO4se3v2i2I;

1.5
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	LnErp1MFKSuew5Fr;

1.4
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	QP75iYx42Uo7mMxO;

1.3
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.09.38;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.11.17.20.53.19;	author afresh1;	state Exp;
branches;
next	1.1.1.6;
commitid	B31cAbBIXiCqnL97;

1.1.1.6
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@use strict;
use warnings;

# re/fold_grind.t has more complex tests, but doesn't test every fold
# This file also tests the fc() keyword.

BEGIN {
    chdir 't' if -d 't';
    require './test.pl';
    set_up_inc('../lib');
    skip_all_without_unicode_tables();
    skip_all_if_miniperl("miniperl, no Unicode::Normalize");
    require Config; import Config;
    require './charset_tools.pl';
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
}

use feature 'unicode_strings';
use Unicode::UCD qw(all_casefolds);

binmode *STDOUT, ":utf8";

our $TODO;


plan("no_plan");
# Read in the official case folding definitions.
my $casefolds = all_casefolds();
my @@folds;
my @@CF;
my @@simple_folds;
my %reverse_fold;
use Unicode::UCD;
use charnames();

foreach my $decimal_code_point (sort { $a <=> $b } keys %$casefolds) {
    # We only use simple folds in fc(), since the regex engine uses full case
    # folding.

    my $name = charnames::viacode($decimal_code_point);
    my $type = $casefolds->{$decimal_code_point}{'status'};
    my $code = $casefolds->{$decimal_code_point}{'code'};
    my $simple = $casefolds->{$decimal_code_point}{'simple'};
    my $full = $casefolds->{$decimal_code_point}{'full'};

    if ($simple && $simple ne $full) { # If there is a distinction
        push @@simple_folds, [ $code, $simple, $type, $name ];
    }

    push @@CF, [ $code, $full, $type, $name ];

    # Get the inverse fold for single-char mappings.
    $reverse_fold{pack "W*", hex $simple} = pack "W*", $decimal_code_point if $simple;
}

foreach my $test_ref ( @@simple_folds ) {
    use feature 'fc';
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);

    my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
    {
        isnt(fc($c), $f, "$code - $name - $mapping - $type - Full casefolding, fc(\\x{$code}) ne $against");
        isnt("\F$c", $f, "$code - $name - $mapping - $type - Full casefolding, qq{\\F\\x{$code}} ne $against");
    }
}

foreach my $test_ref (@@CF) {
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
    my $f_length = length $f;
    foreach my $test (
            qq[":$c:" =~ /:$c:/],
            qq[":$c:" =~ /:$c:/i],
            qq[":$c:" =~ /:[_$c]:/], # Place two chars in [] so doesn't get
                                     # optimized to a non-charclass
            qq[":$c:" =~ /:[_$c]:/i],
            qq[":$c:" =~ /:$f:/i],
            qq[":$f:" =~ /:$c:/i],
    ) {
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }

    {
        # fc() tests
        my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
        is(CORE::fc($c), $f,
            "$code - $name - $mapping - $type - fc(\\x{$code}) eq $against");
        is("\F$c", $f, "$code - $name - $mapping - $type - qq{\\F\\x{$code}} eq $against");

        # And here we test bytes. For [A-Za-z0-9], the fold is the same as lc under
        # bytes. For everything else, it's the bytes that formed the original string.
        if ( $c =~ /[A-Za-z0-9]/ ) {
            use bytes;
            is(CORE::fc($c), lc($c), "$code - $name - fc and use bytes, ascii");
        } else {
            my $copy = "" . $c;
            utf8::encode($copy);
            is($copy, do { use bytes; CORE::fc($c) }, "$code - $name - fc and use bytes");
        }
    }
    # Certain tests weren't convenient to put in the list above since they are
    # TODO's in multi-character folds.
    if ($f_length == 1) {

        # The qq loses the utf8ness of ":$f:".  These tests are not about
        # finding bugs in utf8ness, so make sure it's utf8.
        my $test = qq[my \$s = ":$f:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
        $test = qq[":$c:" =~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
    else {

        # There are two classes of multi-char folds that need more work.  For
        # example,
        #   ":ÃŸ:" =~ /:[_s]{2}:/i
        #   ":ss:" =~ /:[_ÃŸ]:/i
        #
        # Some of the old tests for the second case happened to pass somewhat
        # coincidentally.  But none would pass if changed to this.
        #   ":SS:" =~ /:[_ÃŸ]:/i
        #
        # As the capital SS doesn't get folded.  When those pass, it means
        # that the code has been changed to take into account folding in the
        # string, and all should pass, capitalized or not (this wouldn't be
        # true for [^complemented character classes], for which the fold case
        # is better, but these aren't used in this .t currently.  So, what is
        # done is to essentially upper-case the string for this class (but use
        # the reverse fold not uc(), as that is more correct)
        my $u;
        for my $i (0 .. $f_length - 1) {
            my $cur_char = substr($f, $i, 1);
            $u .= $reverse_fold{$cur_char} || $cur_char;
        }
        my $test;

        # A multi-char fold should not match just one char;
        # e.g., ":ÃŸ:" !~ /:[_s]:/i
        $test = qq[":$c:" !~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        TODO: { # e.g., ":ÃŸ:" =~ /:[_s]{2}:/i
            local $TODO = 'Multi-char fold in [character class]';

            $test = qq[":$c:" =~ /:[_$f]{$f_length}:/i];
            ok eval $test, "$code - $name - $mapping - $type - $test";
        }

        # e.g., ":SS:" =~ /:[_ÃŸ]:/i now pass, so TODO has been removed, but
        # since they use '$u', they are left out of the main loop
        $test = qq[ my \$s = ":$u:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
}

{
    use utf8;
    use feature qw(fc);
    # These three come from the ICU project's test suite, more especifically
    # http://icu.sourcearchive.com/documentation/4.4~rc1-1/strcase_8cpp-source.html

    my $s = "A\N{U+00df}\N{U+00b5}\N{U+fb03}\N{U+1040C}\N{U+0130}\N{U+0131}";
    #\N{LATIN CAPITAL LETTER A}\N{LATIN SMALL LETTER SHARP S}\N{MICRO SIGN}\N{LATIN SMALL LIGATURE FFI}\N{DESERET CAPITAL LETTER AY}\N{LATIN CAPITAL LETTER I WITH DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    my $f = "ass\N{U+03bc}ffi\N{U+10434}i\N{U+0307}\N{U+0131}";
    #\N{LATIN SMALL LETTER A}\N{LATIN SMALL LETTER S}\N{LATIN SMALL LETTER S}\N{GREEK SMALL LETTER MU}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER I}\N{DESERET SMALL LETTER AY}\N{LATIN SMALL LETTER I}\N{COMBINING DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    is(fc($s), $f, "ICU's casefold test passes");
    is("\F$s", $f, "ICU's casefold test passes");

    is( fc("aBÄ°IÄ±ÏÃŸï¬ƒñŸ¿¿"), "abiÌ‡iÄ±Î²ssffiñŸ¿¿" );
    is( "\FaBÄ°IÄ±ÏÃŸï¬ƒñŸ¿¿", "abiÌ‡iÄ±Î²ssffiñŸ¿¿" );
#    TODO: {
#        local $::TODO = "turkic special cases";
#        is( fc "aBÄ°IÄ±ÏÃŸï¬ƒñŸ¿¿", "abiÄ±Ä±Î²ssffiñŸ¿¿" );
#    }

    # The next batch come from http://www.devdaily.com/java/jwarehouse/lucene/contrib/icu/src/test/org/apache/lucene/analysis/icu/TestICUFoldingFilter.java.shtml
    # Except the article got most casings wrong. Or maybe Lucene does.

    is( fc("This is a test"), "this is a test" );
    is( fc("RuÃŸ"), "russ"    );
    is( fc("ÎœÎ†ÎªÎŸÎ£"), "Î¼Î¬ÏŠÎ¿Ïƒ" );
    is( fc("ÎœÎ¬ÏŠÎ¿Ï‚"), "Î¼Î¬ÏŠÎ¿Ïƒ" );
    is( fc("ð–"), "ð¾"       );
    is( fc("r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9")),
           "r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9") );
    is( fc("re\x{0301}sume\x{0301}"), "re\x{301}sume\x{301}" );
    is( fc("ELÄ°F"), "eli\x{307}f" );
    is( fc("eli\x{307}f"), "eli\x{307}f");

    # This batch comes from
    # http://www.java2s.com/Open-Source/Java-Document/Internationalization-Localization/icu4j/com/ibm/icu/dev/test/lang/UCharacterCaseTest.java.htm
    # Which uses ICU as the backend.

    my @@folding_mixed = (
        uni_to_native("\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}"),
        "A" . uni_to_native("\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}"),
    );

    my @@folding_default = (
        uni_to_native("\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}"
    );

    my @@folding_exclude_turkic = (
        uni_to_native("\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
                         "ass\x{3bc}ffi\x{10434}i\x{131}",
    );

    is( fc($folding_mixed[1]), $folding_default[1] );

    is( fc($folding_mixed[0]), $folding_default[0] );

}

{
    use utf8;
    # Table stolen from tchrist's mail in
    # http://bugs.python.org/file23051/casing-tests.py
    # and http://98.245.80.27/tcpc/OSCON2011/case-test.python3
    # For reference, it's a longer version of what he posted here:
    # http://stackoverflow.com/questions/6991038/case-insensitive-storage-and-unicode-compatibility

    #Couple of repeats because I'm lazy, not tchrist's fault.

    #This should probably go in t/op/lc.t

    my @@test_table = (
# ORIG LC_SIMPLE TC_SIMPLE UC_SIMPLE LC_FULL TC_FULL UC_FULL FC_SIMPLE FC_TURKIC FC_FULL
[ 'Ã¾Ç½r rihtes', 'Ã¾Ç½r rihtes', 'ÃžÇ½r Rihtes', 'ÃžÇ¼R RIHTES', 'Ã¾Ç½r rihtes', 'ÃžÇ½r Rihtes', 'ÃžÇ¼R RIHTES', 'Ã¾Ç½r rihtes', 'Ã¾Ç½r rihtes', 'Ã¾Ç½r rihtes',  ],
[ 'duÈeÃ°lice', 'duÈeÃ°lice', 'DuÈeÃ°lice', 'DUÈœEÃLICE', 'duÈeÃ°lice', 'DuÈeÃ°lice', 'DUÈœEÃLICE', 'duÈeÃ°lice', 'duÈeÃ°lice', 'duÈeÃ°lice',  ],
[ 'Ã†var ArnfjÃ¶rÃ° Bjarmason', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã†var ArnfjÃ¶rÃ° Bjarmason', 'Ã†VAR ARNFJÃ–RÃ BJARMASON', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã†var ArnfjÃ¶rÃ° Bjarmason', 'Ã†VAR ARNFJÃ–RÃ BJARMASON', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã¦var arnfjÃ¶rÃ° bjarmason',  ],
[ 'ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ˜Ð Ð˜Ð›Ð›Ð˜Ð¦Ð', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ˜Ð Ð˜Ð›Ð›Ð˜Ð¦Ð', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°',  ],
[ 'Ä³', 'Ä³', 'Ä²', 'Ä²', 'Ä³', 'Ä²', 'Ä²', 'Ä³', 'Ä³', 'Ä³',  ],
[ 'Van DÄ³ke', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'van dÄ³ke', 'van dÄ³ke',  ],
[ 'VAN DÄ²KE', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'van dÄ³ke', 'van dÄ³ke',  ],
[ 'eï¬ƒcient', 'eï¬ƒcient', 'Eï¬ƒcient', 'Eï¬ƒCIENT', 'eï¬ƒcient', 'Eï¬ƒcient', 'EFFICIENT', 'eï¬ƒcient', 'efficient', 'efficient',  ],
[ 'ï¬‚our', 'ï¬‚our', 'ï¬‚our', 'ï¬‚OUR', 'ï¬‚our', 'Flour', 'FLOUR', 'ï¬‚our', 'flour', 'flour',  ],
[ 'ï¬‚our and water', 'ï¬‚our and water', 'ï¬‚our And Water', 'ï¬‚OUR AND WATER', 'ï¬‚our and water', 'Flour And Water', 'FLOUR AND WATER', 'ï¬‚our and water', 'flour and water', 'flour and water',  ],
[ 'Ç³ur', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç³ur', 'Ç³ur',  ],
[ 'Ç²ur', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç³ur', 'Ç³ur',  ],
[ 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç³ur', 'Ç³ur',  ],
[ 'Ç³ur mountain', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç³ur mountain', 'Ç³ur mountain',  ],
[ 'Ç²ur Mountain', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç³ur mountain', 'Ç³ur mountain',  ],
[ 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç³ur mountaÄ±n', 'Ç³ur mountain',  ],
[ 'poÅ¿t', 'poÅ¿t', 'PoÅ¿t', 'POST', 'poÅ¿t', 'PoÅ¿t', 'POST', 'post', 'post', 'post',  ],
[ 'poï¬…', 'poï¬…', 'Poï¬…', 'POï¬…', 'poï¬…', 'Poï¬…', 'POST', 'poï¬…', 'post', 'post',  ],
[ 'ï¬…op', 'ï¬…op', 'ï¬…op', 'ï¬…OP', 'ï¬…op', 'Stop', 'STOP', 'ï¬…op', 'stop', 'stop',  ],
[ 'tschÃ¼ÃŸ', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœÃŸ', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœSS', 'tschÃ¼ÃŸ', 'tschÃ¼ss', 'tschÃ¼ss',  ],
[ 'TSCHÃœáºž', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœáºž', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœáºž', 'tschÃ¼ÃŸ', 'tschÃ¼ss', 'tschÃ¼ss',  ],
[ 'weiÃŸ', 'weiÃŸ', 'WeiÃŸ', 'WEIÃŸ', 'weiÃŸ', 'WeiÃŸ', 'WEISS', 'weiÃŸ', 'weiss', 'weiss',  ],
[ 'WEIáºž', 'weiÃŸ', 'WeiÃŸ', 'WEIáºž', 'weiÃŸ', 'WeiÃŸ', 'WEIáºž', 'weiÃŸ', 'weÄ±ss', 'weiss',  ],
[ 'áºžIEW', 'ÃŸiew', 'áºžiew', 'áºžIEW', 'ÃŸiew', 'áºžiew', 'áºžIEW', 'ÃŸiew', 'ssÄ±ew', 'ssiew',  ],
[ 'Î±Ì€Í…', 'Î±Ì€Í…', 'Î‘Ì€Í…', 'Î‘Ì€Î™', 'Î±Ì€Í…', 'Î‘Ì€Í…', 'Î‘Ì€Î™', 'Î±Ì€Î¹', 'Î±Ì€Î¹', 'Î±Ì€Î¹',  ],
[ 'á¾ºÎ¹', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾²', 'á¾²', 'á¾²', 'á¾²', 'á¾²', 'á¾ºÍ…', 'á¾ºÎ™', 'á¾²', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾ºÍ…', 'á½°Í…', 'á¾ºÍ…', 'á¾ºÎ™', 'á½°Í…', 'á¾ºÍ…', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á¾² Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿', 'á¾² Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ', 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á¾ºÍ… Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿', 'á¾ºÎ™ Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ', 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿',  ],
[ 'Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ', 'Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ', 'Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿',  ],
[ 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»',  ],
[ 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»',  ],
[ 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»',  ],
[ 'henry â…·', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'henry â…·', 'henry â…·',  ],
[ 'Henry â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'henry â…·', 'henry â…·',  ],
[ 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'henry â…·', 'henry â…·',  ],
[ 'i work at â“š', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'i work at â“š', 'i work at â“š',  ],
[ 'I Work At â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'Ä± work at â“š', 'i work at â“š',  ],
[ 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'Ä± work at â“š', 'i work at â“š',  ],
[ 'istambul', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'istambul', 'istambul',  ],
[ 'iÌ‡stanbul', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'iÌ‡stanbul', 'iÌ‡stanbul',  ],
[ 'IÌ‡stanbul', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'Ä±Ì‡stanbul', 'iÌ‡stanbul',  ],
[ 'Ä°STANBUL', 'istanbul', 'Ä°stanbul', 'Ä°STANBUL', 'iÌ‡stanbul', 'Ä°stanbul', 'Ä°STANBUL', 'Ä°stanbul', 'istanbul', 'iÌ‡stanbul',  ],
[ 'ÏƒÏ„Î¹Î³Î¼Î±Ï‚', 'ÏƒÏ„Î¹Î³Î¼Î±Ï‚', 'Î£Ï„Î¹Î³Î¼Î±Ï‚', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ï‚', 'Î£Ï„Î¹Î³Î¼Î±Ï‚', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ',  ],
[ 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ',  ],
[ 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ',  ],
[ 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡',  ],
[ 'Æ¦á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡',  ],
[ 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡',  ],
[ 'Ô¦Ô§', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ 'Ô§Ô§', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ 'Ô¦Ô§', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ "Ã¾Ç½r rihtes", "Ã¾Ç½r rihtes", "ÃžÇ½r Rihtes", "ÃžÇ¼R RIHTES", "Ã¾Ç½r rihtes", "ÃžÇ½r Rihtes", "ÃžÇ¼R RIHTES", "Ã¾Ç½r rihtes", "Ã¾Ç½r rihtes", "Ã¾Ç½r rihtes",  ],
[ "duÈeÃ°lice", "duÈeÃ°lice", "DuÈeÃ°lice", "DUÈœEÃLICE", "duÈeÃ°lice", "DuÈeÃ°lice", "DUÈœEÃLICE", "duÈeÃ°lice", "duÈeÃ°lice", "duÈeÃ°lice",  ],
[ "Van DÄ³ke", "van dÄ³ke", "Van DÄ³ke", "VAN DÄ²KE", "van dÄ³ke", "Van DÄ³ke", "VAN DÄ²KE", "van dÄ³ke", "van dÄ³ke", "van dÄ³ke",  ],
[ "ï¬", "ï¬", "ï¬", "ï¬", "ï¬", "Fi", "FI", "ï¬", "fi", "fi",  ],
[ "ï¬lesystem", "ï¬lesystem", "ï¬lesystem", "ï¬LESYSTEM", "ï¬lesystem", "Filesystem", "FILESYSTEM", "ï¬lesystem", "filesystem", "filesystem",  ],
[ "eï¬ƒcient", "eï¬ƒcient", "Eï¬ƒcient", "Eï¬ƒCIENT", "eï¬ƒcient", "Eï¬ƒcient", "EFFICIENT", "eï¬ƒcient", "efficient", "efficient",  ],
[ "ï¬‚our and water", "ï¬‚our and water", "ï¬‚our And Water", "ï¬‚OUR AND WATER", "ï¬‚our and water", "Flour And Water", "FLOUR AND WATER", "ï¬‚our and water", "flour and water", "flour and water",  ],
[ "Ç³", "Ç³", "Ç²", "Ç±", "Ç³", "Ç²", "Ç±", "Ç³", "Ç³", "Ç³",  ],
[ "Ç³ur mountain", "Ç³ur mountain", "Ç²ur Mountain", "Ç±UR MOUNTAIN", "Ç³ur mountain", "Ç²ur Mountain", "Ç±UR MOUNTAIN", "Ç³ur mountain", "Ç³ur mountain", "Ç³ur mountain",  ],
[ "poÅ¿t", "poÅ¿t", "PoÅ¿t", "POST", "poÅ¿t", "PoÅ¿t", "POST", "post", "post", "post",  ],
[ "poï¬…", "poï¬…", "Poï¬…", "POï¬…", "poï¬…", "Poï¬…", "POST", "poï¬…", "post", "post",  ],
[ "ï¬…op", "ï¬…op", "ï¬…op", "ï¬…OP", "ï¬…op", "Stop", "STOP", "ï¬…op", "stop", "stop",  ],
[ "tschÃ¼ÃŸ", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœÃŸ", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœSS", "tschÃ¼ÃŸ", "tschÃ¼ss", "tschÃ¼ss",  ],
[ "TSCHÃœáºž", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœáºž", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœáºž", "tschÃ¼ÃŸ", "tschÃ¼ss", "tschÃ¼ss",  ],
[ "ruÃŸland", "ruÃŸland", "RuÃŸland", "RUÃŸLAND", "ruÃŸland", "RuÃŸland", "RUSSLAND", "ruÃŸland", "russland", "russland",  ],
[ "RUáºžLAND", "ruÃŸland", "RuÃŸland", "RUáºžLAND", "ruÃŸland", "RuÃŸland", "RUáºžLAND", "ruÃŸland", "russland", "russland",  ],
[ "weiÃŸ", "weiÃŸ", "WeiÃŸ", "WEIÃŸ", "weiÃŸ", "WeiÃŸ", "WEISS", "weiÃŸ", "weiss", "weiss",  ],
[ "WEIáºž", "weiÃŸ", "WeiÃŸ", "WEIáºž", "weiÃŸ", "WeiÃŸ", "WEIáºž", "weiÃŸ", "weÄ±ss", "weiss",  ],
[ "áºžIEW", "ÃŸiew", "áºžiew", "áºžIEW", "ÃŸiew", "áºžiew", "áºžIEW", "ÃŸiew", "ssÄ±ew", "ssiew",  ],
[ "Í…", "Í…", "Î™", "Î™", "Í…", "Î™", "Î™", "Î¹", "Î¹", "Î¹",  ],
[ "Î±Ì€Í…", "Î±Ì€Í…", "Î‘Ì€Í…", "Î‘Ì€Î™", "Î±Ì€Í…", "Î‘Ì€Í…", "Î‘Ì€Î™", "Î±Ì€Î¹", "Î±Ì€Î¹", "Î±Ì€Î¹",  ],
[ "á¾ºÎ¹", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾²", "á¾²", "á¾²", "á¾²", "á¾²", "á¾ºÍ…", "á¾ºÎ™", "á¾²", "á½°Î¹", "á½°Î¹",  ],
[ "á¾ºÍ…", "á½°Í…", "á¾ºÍ…", "á¾ºÎ™", "á½°Í…", "á¾ºÍ…", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á¾² Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿", "á¾² Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ", "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á¾ºÍ… Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿", "á¾ºÎ™ Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ", "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿",  ],
[ "Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ", "Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ", "Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿",  ],
[ "â…·", "â…·", "â…§", "â…§", "â…·", "â…§", "â…§", "â…·", "â…·", "â…·",  ],
[ "henry â…·", "henry â…·", "Henry â…§", "HENRY â…§", "henry â…·", "Henry â…§", "HENRY â…§", "henry â…·", "henry â…·", "henry â…·",  ],
[ "â“š", "â“š", "â“€", "â“€", "â“š", "â“€", "â“€", "â“š", "â“š", "â“š",  ],
[ "i work at â“š", "i work at â“š", "I Work At â“€", "I WORK AT â“€", "i work at â“š", "I Work At â“€", "I WORK AT â“€", "i work at â“š", "i work at â“š", "i work at â“š",  ],
[ "istambul", "istambul", "Istambul", "ISTAMBUL", "istambul", "Istambul", "ISTAMBUL", "istambul", "istambul", "istambul",  ],
[ "iÌ‡stanbul", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "iÌ‡stanbul", "iÌ‡stanbul",  ],
[ "IÌ‡stanbul", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "Ä±Ì‡stanbul", "iÌ‡stanbul",  ],
[ "Ä°STANBUL", "istanbul", "Ä°stanbul", "Ä°STANBUL", "iÌ‡stanbul", "Ä°stanbul", "Ä°STANBUL", "Ä°stanbul", "istanbul", "iÌ‡stanbul",  ],
[ "ÏƒÏ„Î¹Î³Î¼Î±Ï‚", "ÏƒÏ„Î¹Î³Î¼Î±Ï‚", "Î£Ï„Î¹Î³Î¼Î±Ï‚", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ï‚", "Î£Ï„Î¹Î³Î¼Î±Ï‚", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ",  ],
[ "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ",  ],
[ "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ",  ],
[ "Ê€á´€Ê€á´‡", "Ê€á´€Ê€á´‡", "Æ¦á´€Ê€á´‡", "Æ¦á´€Æ¦á´‡", "Ê€á´€Ê€á´‡", "Æ¦á´€Ê€á´‡", "Æ¦á´€Æ¦á´‡", "Ê€á´€Ê€á´‡", "Ê€á´€Ê€á´‡", "Ê€á´€Ê€á´‡",  ],
[ "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð‡ðð€ð¡ð‡ð“", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð‡ðð€ð¡ð‡ð“", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»",  ],
[ "Ô¦Ô§", "Ô§Ô§", "Ô¦Ô§", "Ô¦Ô¦", "Ô§Ô§", "Ô¦Ô§", "Ô¦Ô¦", "Ô§Ô§", "Ô§Ô§", "Ô§Ô§",  ],
[ "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "Õ„Õ¶ï¬”ï¬•ï¬–ï¬—", "Õ„Õ†Õ„ÔµÕ„Ô»ÕŽÕ†Õ„Ô½", "ï¬“ï¬”ï¬•ï¬–ï¬—", "Õ´Õ¶Õ´Õ¥Õ´Õ«Õ¾Õ¶Õ´Õ­", "Õ´Õ¶Õ´Õ¥Õ´Õ«Õ¾Õ¶Õ´Õ­",  ],
[ "Å‰ groot", "Å‰ groot", "Å‰ Groot", "Å‰ GROOT", "Å‰ groot", "Ê¼N Groot", "Ê¼N GROOT", "Å‰ groot", "Ê¼n groot", "Ê¼n groot",  ],
[ "áºš", "áºš", "áºš", "áºš", "áºš", "AÊ¾", "AÊ¾", "áºš", "aÊ¾", "aÊ¾",  ],
[ "ï¬€", "ï¬€", "ï¬€", "ï¬€", "ï¬€", "Ff", "FF", "ï¬€", "ff", "ff",  ],
[ "Ç°", "Ç°", "Ç°", "Ç°", "Ç°", "JÌŒ", "JÌŒ", "Ç°", "jÌŒ", "jÌŒ",  ],
[ "550 nm or â„«", "550 nm or Ã¥", "550 Nm Or â„«", "550 NM OR â„«", "550 nm or Ã¥", "550 Nm Or â„«", "550 NM OR â„«", "550 nm or Ã¥", "550 nm or Ã¥", "550 nm or Ã¥",  ],
);

    use feature qw(fc);

    for (@@test_table) {
        my ($simple_lc, $simple_tc, $simple_uc, $simple_fc) = @@{$_}[1, 2, 3, 7];
        my ($orig, $lower, $titlecase, $upper, $fc_turkic, $fc_full) = @@{$_}[0,4,5,6,8,9];

        if ($orig =~ /(\P{Assigned})/) {   # So can fail gracefully in earlier
                                           # Unicode versions
            fail(sprintf "because U+%04X is unassigned", ord($1));
            next;
        }
        is( fc($orig), $fc_full, "fc('$orig') returns '$fc_full'" );
        is( "\F$orig", $fc_full, '\F works' );
        is( lc($orig), $lower,   "lc('$orig') returns '$lower'" );
        is( "\L$orig", $lower,   '\L works' );
        is( uc($orig), $upper,   "uc('$orig') returns '$upper'" );
        is( "\U$orig", $upper,   '\U works' );
    }
}

{
    use feature qw(fc);
    package Eeyup  { use overload q{""} => sub { main::uni_to_native("\x{df}")   }, fallback => 1 }
    package Uunope { use overload q{""} => sub { "\x{30cb}" }, fallback => 1 }
    package Undef  { use overload q{""} => sub {   undef    }, fallback => 1 }

    my $obj = bless {}, "Eeyup";
    is(fc($obj), "ss", "fc() works on overloaded objects returning latin-1");
    $obj = bless {}, "Eeyup";
    is("\F$obj", "ss", '\F works on overloaded objects returning latin-1');

    $obj = bless {}, "Uunope";
    is(fc($obj), "\x{30cb}", "fc() works on overloaded objects returning UTF-8");
    $obj = bless {}, "Uunope";
    is("\F$obj", "\x{30cb}", '\F works on overloaded objects returning UTF-8');

    $obj = bless {}, "Undef";
    my $warnings;
    {
        no warnings;
        use warnings "uninitialized";
        local $SIG{__WARN__} = sub { $warnings++; like(shift, qr/Use of uninitialized value (?:\$obj )?in fc/) };
        fc(undef);
        fc($obj);
    }
    is( $warnings, 2, "correct number of warnings" );

    my $fetched = 0;
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; main::uni_to_native("\x{df}") } }

    tie my $x, "Derpy";

    is( fc($x), "ss", "fc() works on tied values" );
    is( $fetched, 1, "and only calls the magic once" );

}

{
    use feature qw( fc );
    my $troublesome1 = uni_to_native("\xdf") x 11; #SvLEN should be 12, SvCUR should be 11
                                    #So this should force fc() to grow the string.

    is( fc($troublesome1), "ss" x 11, "fc() grows the string" );

    my $troublesome2 = "abcdef:" . uni_to_native("\x{df}")
                     . ":fjksjs"; #SvLEN should be 16, SvCUR should be 15
    is( fc($troublesome2), "abcdef:ss:fjksjs", "fc() expands \\x{DF} in the middle of a string that needs to grow" );

    my $troublesome3 = ":" . uni_to_native("\x{df}") . ":";
    is( fc($troublesome3), ":ss:", "fc() expands \\x{DF} in the middle of a string" );


    my $troublesome4 = uni_to_native("\x{B5}"); #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8

    is( fc($troublesome4), "\x{3BC}", "fc() for a latin-1 \x{B5} returns UTF-8" );
    ok( !utf8::is_utf8($troublesome4), "fc() doesn't upgrade the original string" );


    my $troublesome5 = uni_to_native("\x{C9}") . "abda"
                     . uni_to_native("\x{B5}") . "aaf"
                     . uni_to_native("\x{C8}");  # Up until foldcasing \x{B5}, the string
                                                    # was in Latin-1. This tests that the
                                                    # results don't have illegal UTF-8
                                                    # (i.e. leftover latin-1) in them

    is( fc($troublesome5), uni_to_native("\x{E9}") . "abda\x{3BC}aaf"
                         . uni_to_native("\x{E8}") );
}


SKIP: {
    use feature qw( fc unicode_strings );

    skip "locales not available", 256 unless locales_enabled('LC_ALL');

    setlocale(&POSIX::LC_ALL, "C");

    # This tests both code paths in pp_fc

    for (0..0xff) {
        my $latin1 = chr;
        my $utf8   = $latin1;
        utf8::downgrade($latin1); #No-op, but doesn't hurt
        utf8::upgrade($utf8);
        is(fc($latin1), fc($utf8), "fc() gives the same results for \\x{$_} in Latin-1 and UTF-8 under unicode_strings");
        SKIP: {
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
            no feature 'unicode_strings';
            is(fc($latin1), lc($latin1), "under nothing, fc() for <256 is the same as lc");
        }
    }
}

my $utf8_locale = find_utf8_ctype_locale();

{
    use feature qw( fc );
    use locale;
    no warnings 'locale';   # Would otherwise warn
    is(fc("\x{1E9E}"), fc("\x{17F}\x{17F}"), 'fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")');
    use warnings 'locale';
    SKIP: {
        skip 'Can\'t find a UTF-8 locale', 1 unless defined $utf8_locale;
        setlocale(&LC_CTYPE, $utf8_locale);
        is(fc("\x{1E9E}"), "ss", 'fc("\x{1E9E}") eq "ss" in a UTF-8 locale)');
    }
}

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 256 unless defined $utf8_locale;

    use feature qw( fc unicode_strings );

    # Get the official fc values outside locale.
    no locale;
    my @@unicode_fc;
    for (0..0xff) {
        push @@unicode_fc, fc(chr);
    }

    # These should match the UTF-8 locale values
    setlocale(&LC_CTYPE, $utf8_locale);
    use locale;
    for (0..0xff) {
        is(fc(chr), $unicode_fc[$_], "In a UTF-8 locale, fc(chr $_) is the same as official Unicode");
    }
}


my $num_tests = curr_test() - 1;

plan($num_tests);
@


1.7
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d9 4
a12 1
    @@INC = '../lib';
d14 1
a14 1
    require './test.pl';
d53 1
a53 1
    $reverse_fold{pack "U0U*", hex $simple} = pack "U0U*", $decimal_code_point if $simple;
d59 3
a61 2
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);
d72 3
a74 2
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);
d191 2
a192 1
    is( fc("r\xe9sum\xe9"), "r\xe9sum\xe9" );
d202 2
a203 2
        "\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}",
        "A\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}",
d207 2
a208 2
        "\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}",
d212 2
a213 2
        "\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{131}",
d363 1
a363 1
    package Eeyup  { use overload q{""} => sub { "\x{df}"   }, fallback => 1 }
d389 1
a389 1
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; "\x{df}" } }
d400 1
a400 1
    my $troublesome1 = "\xdf" x 11; #SvLEN should be 12, SvCUR should be 11
d405 2
a406 1
    my $troublesome2 = "abcdef:\x{df}:fjksjs"; #SvLEN should be 16, SvCUR should be 15
d409 1
a409 1
    my $troublesome3 = ":\x{df}:";
d413 1
a413 1
    my $troublesome4 = "\x{B5}"; #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8
d419 3
a421 1
    my $troublesome5 = "\x{C9}abda\x{B5}aaf\x{C8}"; # Up until foldcasing \x{B5}, the string
d426 2
a427 1
    is( fc($troublesome5), "\x{E9}abda\x{3BC}aaf\x{E8}" );
d431 1
a431 1
{
d433 4
a436 2
    use if $Config{d_setlocale}, qw(POSIX locale_h);
    setlocale(&POSIX::LC_ALL, "C") if $Config{d_setlocale};
d447 2
a448 6
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
              BEGIN {
                  if($Config{d_setlocale}) {
                      require locale; import locale;
                  }
              }
d452 1
a452 7
        SKIP: {
            if (
                !$Config::Config{d_setlocale}
            || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
            ) {
                skip "no locale support", 2
            }
d464 1
d466 1
@


1.6
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
d444 7
a450 1
        {
@


1.5
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
d444 1
a444 7
        SKIP: {
            if (
                !$Config::Config{d_setlocale}
            || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
            ) {
                skip "no locale support", 2
            }
@


1.4
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
d444 7
a450 1
        {
@


1.3
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d12 1
d420 1
d423 2
d435 1
a435 1
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale}) || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/;
d444 1
a444 7
        SKIP: {
            if (
                !$Config::Config{d_setlocale}
            || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
            ) {
                skip "no locale support", 2
            }
d450 34
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d10 1
d15 1
d21 1
d24 2
a25 4
my $CF = '../lib/unicore/CaseFolding.txt';

die qq[$0: failed to open "$CF": $!\n] if ! open(my $fh, "<", $CF);

d29 15
a43 16
while (<$fh>) {
    # We only use 'S' in simple folded fc(), since the regex engine uses
    # 'F'ull case folding.  I is obsolete starting with Unicode 3.2, but
    # leaving it in does no harm, and allows backward compatibility
    next unless my ($code, $type, $mapping, $name) = $_ =~
            /^([0-9A-F]+); ([CFIS]); ((?:[0-9A-F]+)(?: [0-9A-F]+)*); \# (.+)/;

    # Convert any 0-255 range chars to native.
    $code = sprintf("%04X", ord_latin1_to_native(hex $code)) if hex $code < 0x100;
    $mapping = join " ", map { $_ =
                                sprintf("%04X", ord_latin1_to_native(hex $_)) }
                                                            split / /, $mapping;

    if ( $type eq "S" ) {
        push @@simple_folds, [$code, $mapping, $type, $name];
        next;
d46 1
a46 1
    push @@CF, [$code, $mapping, $type, $name];
d49 1
a49 1
    $reverse_fold{pack "U0U*", hex $mapping} = pack "U0U*", hex $code if $type ne 'F';
a51 2
close($fh) or die "$0 Couldn't close $CF";

d340 6
a345 1
        is( fc($orig), $fc_full, 'fc works' );
d347 1
a347 1
        is( lc($orig), $lower,   'lc works' );
d349 1
a349 1
        is( uc($orig), $upper,   'uc works' );
d431 10
a446 5
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
a453 2

die qq[$0: failed to find casefoldings from "$CF"\n] unless $num_tests > 0;
@


1.1
log
@Initial revision
@
text
@d1 6
d10 205
d217 120
a336 1
use File::Spec;
d338 10
a347 40
my $CF = File::Spec->catfile(File::Spec->catdir(File::Spec->updir,
					       "lib", "unicore"),
			    "CaseFolding.txt");

use constant EBCDIC => ord 'A' == 193;

if (open(CF, $CF)) {
    my @@CF;

    while (<CF>) {
	# Skip S since we are going for 'F'ull case folding
        if (/^([0-9A-F]+); ([CFI]); ((?:[0-9A-F]+)(?: [0-9A-F]+)*); \# (.+)/) {
	    next if EBCDIC && hex $1 < 0x100;
	    push @@CF, [$1, $2, $3, $4];
	}
    }

    close(CF);

    die qq[$0: failed to find casefoldings from "$CF"\n] unless @@CF;

    print "1..", scalar @@CF, "\n";

    my $i = 0;
    for my $cf (@@CF) {
	my ($code, $status, $mapping, $name) = @@$cf;
	$i++;
	my $a = pack("U0U*", hex $code);
	my $b = pack("U0U*", map { hex } split " ", $mapping);
	my $t0 = ":$a:" =~ /:$a:/    ? 1 : 0;
	my $t1 = ":$a:" =~ /:$a:/i   ? 1 : 0;
	my $t2 = ":$a:" =~ /:[$a]:/  ? 1 : 0;
	my $t3 = ":$a:" =~ /:[$a]:/i ? 1 : 0;
	my $t4 = ":$a:" =~ /:$b:/i   ? 1 : 0;
	my $t5 = ":$a:" =~ /:[$b]:/i ? 1 : 0;
	my $t6 = ":$b:" =~ /:$a:/i   ? 1 : 0;
	my $t7 = ":$b:" =~ /:[$a]:/i ? 1 : 0;
	print $t0 && $t1 && $t2 && $t3 && $t4 && $t5 && $t6 && $t7 ?
	    "ok $i \# - $code - $name - $mapping - $status\n" :
	    "not ok $i \# - $code - $name - $mapping - $status - $t0 $t1 $t2 $t3 $t4 $t5 $t6 $t7\n";
a348 2
} else {
    die qq[$0: failed to open "$CF": $!\n];
d350 100
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d18 1
a18 3
	# Skip S since we are going for 'F'ull case folding.  I is obsolete starting
	# with Unicode 3.2, but leaving it in does no harm, and allows backward
	# compatibility
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a0 6
use strict;
use warnings;

# re/fold_grind.t has more complex tests, but doesn't test every fold
# This file also tests the fc() keyword.

a3 205
    require './test.pl';
}

use feature 'unicode_strings';

binmode *STDOUT, ":utf8";

our $TODO;

plan("no_plan");
# Read in the official case folding definitions.
my $CF = '../lib/unicore/CaseFolding.txt';

die qq[$0: failed to open "$CF": $!\n] if ! open(my $fh, "<", $CF);

my @@CF;
my @@simple_folds;
my %reverse_fold;
while (<$fh>) {
    # We only use 'S' in simple folded fc(), since the regex engine uses
    # 'F'ull case folding.  I is obsolete starting with Unicode 3.2, but
    # leaving it in does no harm, and allows backward compatibility
    next unless my ($code, $type, $mapping, $name) = $_ =~
            /^([0-9A-F]+); ([CFIS]); ((?:[0-9A-F]+)(?: [0-9A-F]+)*); \# (.+)/;

    # Convert any 0-255 range chars to native.
    $code = sprintf("%04X", ord_latin1_to_native(hex $code)) if hex $code < 0x100;
    $mapping = join " ", map { $_ =
                                sprintf("%04X", ord_latin1_to_native(hex $_)) }
                                                            split / /, $mapping;

    if ( $type eq "S" ) {
        push @@simple_folds, [$code, $mapping, $type, $name];
        next;
    }

    push @@CF, [$code, $mapping, $type, $name];

    # Get the inverse fold for single-char mappings.
    $reverse_fold{pack "U0U*", hex $mapping} = pack "U0U*", hex $code if $type ne 'F';
}

close($fh) or die "$0 Couldn't close $CF";

foreach my $test_ref ( @@simple_folds ) {
    use feature 'fc';
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);

    my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
    {
        isnt(fc($c), $f, "$code - $name - $mapping - $type - Full casefolding, fc(\\x{$code}) ne $against");
        isnt("\F$c", $f, "$code - $name - $mapping - $type - Full casefolding, qq{\\F\\x{$code}} ne $against");
    }
}

foreach my $test_ref (@@CF) {
    my ($code, $mapping, $type, $name) = @@$test_ref;
    my $c = pack("U0U*", hex $code);
    my $f = pack("U0U*", map { hex } split " ", $mapping);
    my $f_length = length $f;
    foreach my $test (
            qq[":$c:" =~ /:$c:/],
            qq[":$c:" =~ /:$c:/i],
            qq[":$c:" =~ /:[_$c]:/], # Place two chars in [] so doesn't get
                                     # optimized to a non-charclass
            qq[":$c:" =~ /:[_$c]:/i],
            qq[":$c:" =~ /:$f:/i],
            qq[":$f:" =~ /:$c:/i],
    ) {
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }

    {
        # fc() tests
        my $against = join "", "qq{", map("\\x{$_}", split " ", $mapping), "}";
        is(CORE::fc($c), $f,
            "$code - $name - $mapping - $type - fc(\\x{$code}) eq $against");
        is("\F$c", $f, "$code - $name - $mapping - $type - qq{\\F\\x{$code}} eq $against");

        # And here we test bytes. For [A-Za-z0-9], the fold is the same as lc under
        # bytes. For everything else, it's the bytes that formed the original string.
        if ( $c =~ /[A-Za-z0-9]/ ) {
            use bytes;
            is(CORE::fc($c), lc($c), "$code - $name - fc and use bytes, ascii");
        } else {
            my $copy = "" . $c;
            utf8::encode($copy);
            is($copy, do { use bytes; CORE::fc($c) }, "$code - $name - fc and use bytes");
        }
    }
    # Certain tests weren't convenient to put in the list above since they are
    # TODO's in multi-character folds.
    if ($f_length == 1) {

        # The qq loses the utf8ness of ":$f:".  These tests are not about
        # finding bugs in utf8ness, so make sure it's utf8.
        my $test = qq[my \$s = ":$f:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
        $test = qq[":$c:" =~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
    else {

        # There are two classes of multi-char folds that need more work.  For
        # example,
        #   ":ÃŸ:" =~ /:[_s]{2}:/i
        #   ":ss:" =~ /:[_ÃŸ]:/i
        #
        # Some of the old tests for the second case happened to pass somewhat
        # coincidentally.  But none would pass if changed to this.
        #   ":SS:" =~ /:[_ÃŸ]:/i
        #
        # As the capital SS doesn't get folded.  When those pass, it means
        # that the code has been changed to take into account folding in the
        # string, and all should pass, capitalized or not (this wouldn't be
        # true for [^complemented character classes], for which the fold case
        # is better, but these aren't used in this .t currently.  So, what is
        # done is to essentially upper-case the string for this class (but use
        # the reverse fold not uc(), as that is more correct)
        my $u;
        for my $i (0 .. $f_length - 1) {
            my $cur_char = substr($f, $i, 1);
            $u .= $reverse_fold{$cur_char} || $cur_char;
        }
        my $test;

        # A multi-char fold should not match just one char;
        # e.g., ":ÃŸ:" !~ /:[_s]:/i
        $test = qq[":$c:" !~ /:[_$f]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";

        TODO: { # e.g., ":ÃŸ:" =~ /:[_s]{2}:/i
            local $TODO = 'Multi-char fold in [character class]';

            $test = qq[":$c:" =~ /:[_$f]{$f_length}:/i];
            ok eval $test, "$code - $name - $mapping - $type - $test";
        }

        # e.g., ":SS:" =~ /:[_ÃŸ]:/i now pass, so TODO has been removed, but
        # since they use '$u', they are left out of the main loop
        $test = qq[ my \$s = ":$u:"; utf8::upgrade(\$s); \$s =~ /:[_$c]:/i];
        ok eval $test, "$code - $name - $mapping - $type - $test";
    }
}

{
    use utf8;
    use feature qw(fc);
    # These three come from the ICU project's test suite, more especifically
    # http://icu.sourcearchive.com/documentation/4.4~rc1-1/strcase_8cpp-source.html

    my $s = "A\N{U+00df}\N{U+00b5}\N{U+fb03}\N{U+1040C}\N{U+0130}\N{U+0131}";
    #\N{LATIN CAPITAL LETTER A}\N{LATIN SMALL LETTER SHARP S}\N{MICRO SIGN}\N{LATIN SMALL LIGATURE FFI}\N{DESERET CAPITAL LETTER AY}\N{LATIN CAPITAL LETTER I WITH DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    my $f = "ass\N{U+03bc}ffi\N{U+10434}i\N{U+0307}\N{U+0131}";
    #\N{LATIN SMALL LETTER A}\N{LATIN SMALL LETTER S}\N{LATIN SMALL LETTER S}\N{GREEK SMALL LETTER MU}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER F}\N{LATIN SMALL LETTER I}\N{DESERET SMALL LETTER AY}\N{LATIN SMALL LETTER I}\N{COMBINING DOT ABOVE}\N{LATIN SMALL LETTER DOTLESS I}

    is(fc($s), $f, "ICU's casefold test passes");
    is("\F$s", $f, "ICU's casefold test passes");

    is( fc("aBÄ°IÄ±ÏÃŸï¬ƒñŸ¿¿"), "abiÌ‡iÄ±Î²ssffiñŸ¿¿" );
    is( "\FaBÄ°IÄ±ÏÃŸï¬ƒñŸ¿¿", "abiÌ‡iÄ±Î²ssffiñŸ¿¿" );
#    TODO: {
#        local $::TODO = "turkic special cases";
#        is( fc "aBÄ°IÄ±ÏÃŸï¬ƒñŸ¿¿", "abiÄ±Ä±Î²ssffiñŸ¿¿" );
#    }

    # The next batch come from http://www.devdaily.com/java/jwarehouse/lucene/contrib/icu/src/test/org/apache/lucene/analysis/icu/TestICUFoldingFilter.java.shtml
    # Except the article got most casings wrong. Or maybe Lucene does.

    is( fc("This is a test"), "this is a test" );
    is( fc("RuÃŸ"), "russ"    );
    is( fc("ÎœÎ†ÎªÎŸÎ£"), "Î¼Î¬ÏŠÎ¿Ïƒ" );
    is( fc("ÎœÎ¬ÏŠÎ¿Ï‚"), "Î¼Î¬ÏŠÎ¿Ïƒ" );
    is( fc("ð–"), "ð¾"       );
    is( fc("r\xe9sum\xe9"), "r\xe9sum\xe9" );
    is( fc("re\x{0301}sume\x{0301}"), "re\x{301}sume\x{301}" );
    is( fc("ELÄ°F"), "eli\x{307}f" );
    is( fc("eli\x{307}f"), "eli\x{307}f");

    # This batch comes from
    # http://www.java2s.com/Open-Source/Java-Document/Internationalization-Localization/icu4j/com/ibm/icu/dev/test/lang/UCharacterCaseTest.java.htm
    # Which uses ICU as the backend.

    my @@folding_mixed = (
        "\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}",
        "A\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}",
    );

    my @@folding_default = (
        "\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}",
    );

    my @@folding_exclude_turkic = (
        "\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}",
        "ass\x{3bc}ffi\x{10434}i\x{131}",
    );

    is( fc($folding_mixed[1]), $folding_default[1] );

    is( fc($folding_mixed[0]), $folding_default[0] );

d6 1
a6 120
{
    use utf8;
    # Table stolen from tchrist's mail in
    # http://bugs.python.org/file23051/casing-tests.py
    # and http://98.245.80.27/tcpc/OSCON2011/case-test.python3
    # For reference, it's a longer version of what he posted here:
    # http://stackoverflow.com/questions/6991038/case-insensitive-storage-and-unicode-compatibility

    #Couple of repeats because I'm lazy, not tchrist's fault.

    #This should probably go in t/op/lc.t

    my @@test_table = (
# ORIG LC_SIMPLE TC_SIMPLE UC_SIMPLE LC_FULL TC_FULL UC_FULL FC_SIMPLE FC_TURKIC FC_FULL
[ 'Ã¾Ç½r rihtes', 'Ã¾Ç½r rihtes', 'ÃžÇ½r Rihtes', 'ÃžÇ¼R RIHTES', 'Ã¾Ç½r rihtes', 'ÃžÇ½r Rihtes', 'ÃžÇ¼R RIHTES', 'Ã¾Ç½r rihtes', 'Ã¾Ç½r rihtes', 'Ã¾Ç½r rihtes',  ],
[ 'duÈeÃ°lice', 'duÈeÃ°lice', 'DuÈeÃ°lice', 'DUÈœEÃLICE', 'duÈeÃ°lice', 'DuÈeÃ°lice', 'DUÈœEÃLICE', 'duÈeÃ°lice', 'duÈeÃ°lice', 'duÈeÃ°lice',  ],
[ 'Ã†var ArnfjÃ¶rÃ° Bjarmason', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã†var ArnfjÃ¶rÃ° Bjarmason', 'Ã†VAR ARNFJÃ–RÃ BJARMASON', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã†var ArnfjÃ¶rÃ° Bjarmason', 'Ã†VAR ARNFJÃ–RÃ BJARMASON', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã¦var arnfjÃ¶rÃ° bjarmason', 'Ã¦var arnfjÃ¶rÃ° bjarmason',  ],
[ 'ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ˜Ð Ð˜Ð›Ð›Ð˜Ð¦Ð', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐšÐ˜Ð Ð˜Ð›Ð›Ð˜Ð¦Ð', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°', 'ÐºÐ¸Ñ€Ð¸Ð»Ð»Ð¸Ñ†Ð°',  ],
[ 'Ä³', 'Ä³', 'Ä²', 'Ä²', 'Ä³', 'Ä²', 'Ä²', 'Ä³', 'Ä³', 'Ä³',  ],
[ 'Van DÄ³ke', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'van dÄ³ke', 'van dÄ³ke',  ],
[ 'VAN DÄ²KE', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'Van DÄ³ke', 'VAN DÄ²KE', 'van dÄ³ke', 'van dÄ³ke', 'van dÄ³ke',  ],
[ 'eï¬ƒcient', 'eï¬ƒcient', 'Eï¬ƒcient', 'Eï¬ƒCIENT', 'eï¬ƒcient', 'Eï¬ƒcient', 'EFFICIENT', 'eï¬ƒcient', 'efficient', 'efficient',  ],
[ 'ï¬‚our', 'ï¬‚our', 'ï¬‚our', 'ï¬‚OUR', 'ï¬‚our', 'Flour', 'FLOUR', 'ï¬‚our', 'flour', 'flour',  ],
[ 'ï¬‚our and water', 'ï¬‚our and water', 'ï¬‚our And Water', 'ï¬‚OUR AND WATER', 'ï¬‚our and water', 'Flour And Water', 'FLOUR AND WATER', 'ï¬‚our and water', 'flour and water', 'flour and water',  ],
[ 'Ç³ur', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç³ur', 'Ç³ur',  ],
[ 'Ç²ur', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç³ur', 'Ç³ur',  ],
[ 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç²ur', 'Ç±UR', 'Ç³ur', 'Ç³ur', 'Ç³ur',  ],
[ 'Ç³ur mountain', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç³ur mountain', 'Ç³ur mountain',  ],
[ 'Ç²ur Mountain', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç³ur mountain', 'Ç³ur mountain',  ],
[ 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç²ur Mountain', 'Ç±UR MOUNTAIN', 'Ç³ur mountain', 'Ç³ur mountaÄ±n', 'Ç³ur mountain',  ],
[ 'poÅ¿t', 'poÅ¿t', 'PoÅ¿t', 'POST', 'poÅ¿t', 'PoÅ¿t', 'POST', 'post', 'post', 'post',  ],
[ 'poï¬…', 'poï¬…', 'Poï¬…', 'POï¬…', 'poï¬…', 'Poï¬…', 'POST', 'poï¬…', 'post', 'post',  ],
[ 'ï¬…op', 'ï¬…op', 'ï¬…op', 'ï¬…OP', 'ï¬…op', 'Stop', 'STOP', 'ï¬…op', 'stop', 'stop',  ],
[ 'tschÃ¼ÃŸ', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœÃŸ', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœSS', 'tschÃ¼ÃŸ', 'tschÃ¼ss', 'tschÃ¼ss',  ],
[ 'TSCHÃœáºž', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœáºž', 'tschÃ¼ÃŸ', 'TschÃ¼ÃŸ', 'TSCHÃœáºž', 'tschÃ¼ÃŸ', 'tschÃ¼ss', 'tschÃ¼ss',  ],
[ 'weiÃŸ', 'weiÃŸ', 'WeiÃŸ', 'WEIÃŸ', 'weiÃŸ', 'WeiÃŸ', 'WEISS', 'weiÃŸ', 'weiss', 'weiss',  ],
[ 'WEIáºž', 'weiÃŸ', 'WeiÃŸ', 'WEIáºž', 'weiÃŸ', 'WeiÃŸ', 'WEIáºž', 'weiÃŸ', 'weÄ±ss', 'weiss',  ],
[ 'áºžIEW', 'ÃŸiew', 'áºžiew', 'áºžIEW', 'ÃŸiew', 'áºžiew', 'áºžIEW', 'ÃŸiew', 'ssÄ±ew', 'ssiew',  ],
[ 'Î±Ì€Í…', 'Î±Ì€Í…', 'Î‘Ì€Í…', 'Î‘Ì€Î™', 'Î±Ì€Í…', 'Î‘Ì€Í…', 'Î‘Ì€Î™', 'Î±Ì€Î¹', 'Î±Ì€Î¹', 'Î±Ì€Î¹',  ],
[ 'á¾ºÎ¹', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾²', 'á¾²', 'á¾²', 'á¾²', 'á¾²', 'á¾ºÍ…', 'á¾ºÎ™', 'á¾²', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾ºÍ…', 'á½°Í…', 'á¾ºÍ…', 'á¾ºÎ™', 'á½°Í…', 'á¾ºÍ…', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á¾ºÎ¹', 'á¾ºÎ™', 'á½°Î¹', 'á½°Î¹', 'á½°Î¹',  ],
[ 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á¾² Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿', 'á¾² Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ', 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á¾ºÍ… Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿', 'á¾ºÎ™ Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ', 'á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿', 'á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿',  ],
[ 'Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ', 'Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿', 'Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ', 'Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿', 'Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿',  ],
[ 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»',  ],
[ 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»',  ],
[ 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð”ð‡ðð€ð¡ð‡ð“', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»', 'ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»',  ],
[ 'henry â…·', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'henry â…·', 'henry â…·',  ],
[ 'Henry â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'henry â…·', 'henry â…·',  ],
[ 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'Henry â…§', 'HENRY â…§', 'henry â…·', 'henry â…·', 'henry â…·',  ],
[ 'i work at â“š', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'i work at â“š', 'i work at â“š',  ],
[ 'I Work At â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'Ä± work at â“š', 'i work at â“š',  ],
[ 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'I Work At â“€', 'I WORK AT â“€', 'i work at â“š', 'Ä± work at â“š', 'i work at â“š',  ],
[ 'istambul', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'Istambul', 'ISTAMBUL', 'istambul', 'istambul', 'istambul',  ],
[ 'iÌ‡stanbul', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'iÌ‡stanbul', 'iÌ‡stanbul',  ],
[ 'IÌ‡stanbul', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'IÌ‡stanbul', 'IÌ‡STANBUL', 'iÌ‡stanbul', 'Ä±Ì‡stanbul', 'iÌ‡stanbul',  ],
[ 'Ä°STANBUL', 'istanbul', 'Ä°stanbul', 'Ä°STANBUL', 'iÌ‡stanbul', 'Ä°stanbul', 'Ä°STANBUL', 'Ä°stanbul', 'istanbul', 'iÌ‡stanbul',  ],
[ 'ÏƒÏ„Î¹Î³Î¼Î±Ï‚', 'ÏƒÏ„Î¹Î³Î¼Î±Ï‚', 'Î£Ï„Î¹Î³Î¼Î±Ï‚', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ï‚', 'Î£Ï„Î¹Î³Î¼Î±Ï‚', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ',  ],
[ 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ',  ],
[ 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'Î£Ï„Î¹Î³Î¼Î±Ïƒ', 'Î£Î¤Î™Î“ÎœÎ‘Î£', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ', 'ÏƒÏ„Î¹Î³Î¼Î±Ïƒ',  ],
[ 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡',  ],
[ 'Æ¦á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡',  ],
[ 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Æ¦á´€Ê€á´‡', 'Æ¦á´€Æ¦á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡', 'Ê€á´€Ê€á´‡',  ],
[ 'Ô¦Ô§', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ 'Ô§Ô§', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ 'Ô¦Ô§', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô¦Ô§', 'Ô¦Ô¦', 'Ô§Ô§', 'Ô§Ô§', 'Ô§Ô§',  ],
[ "Ã¾Ç½r rihtes", "Ã¾Ç½r rihtes", "ÃžÇ½r Rihtes", "ÃžÇ¼R RIHTES", "Ã¾Ç½r rihtes", "ÃžÇ½r Rihtes", "ÃžÇ¼R RIHTES", "Ã¾Ç½r rihtes", "Ã¾Ç½r rihtes", "Ã¾Ç½r rihtes",  ],
[ "duÈeÃ°lice", "duÈeÃ°lice", "DuÈeÃ°lice", "DUÈœEÃLICE", "duÈeÃ°lice", "DuÈeÃ°lice", "DUÈœEÃLICE", "duÈeÃ°lice", "duÈeÃ°lice", "duÈeÃ°lice",  ],
[ "Van DÄ³ke", "van dÄ³ke", "Van DÄ³ke", "VAN DÄ²KE", "van dÄ³ke", "Van DÄ³ke", "VAN DÄ²KE", "van dÄ³ke", "van dÄ³ke", "van dÄ³ke",  ],
[ "ï¬", "ï¬", "ï¬", "ï¬", "ï¬", "Fi", "FI", "ï¬", "fi", "fi",  ],
[ "ï¬lesystem", "ï¬lesystem", "ï¬lesystem", "ï¬LESYSTEM", "ï¬lesystem", "Filesystem", "FILESYSTEM", "ï¬lesystem", "filesystem", "filesystem",  ],
[ "eï¬ƒcient", "eï¬ƒcient", "Eï¬ƒcient", "Eï¬ƒCIENT", "eï¬ƒcient", "Eï¬ƒcient", "EFFICIENT", "eï¬ƒcient", "efficient", "efficient",  ],
[ "ï¬‚our and water", "ï¬‚our and water", "ï¬‚our And Water", "ï¬‚OUR AND WATER", "ï¬‚our and water", "Flour And Water", "FLOUR AND WATER", "ï¬‚our and water", "flour and water", "flour and water",  ],
[ "Ç³", "Ç³", "Ç²", "Ç±", "Ç³", "Ç²", "Ç±", "Ç³", "Ç³", "Ç³",  ],
[ "Ç³ur mountain", "Ç³ur mountain", "Ç²ur Mountain", "Ç±UR MOUNTAIN", "Ç³ur mountain", "Ç²ur Mountain", "Ç±UR MOUNTAIN", "Ç³ur mountain", "Ç³ur mountain", "Ç³ur mountain",  ],
[ "poÅ¿t", "poÅ¿t", "PoÅ¿t", "POST", "poÅ¿t", "PoÅ¿t", "POST", "post", "post", "post",  ],
[ "poï¬…", "poï¬…", "Poï¬…", "POï¬…", "poï¬…", "Poï¬…", "POST", "poï¬…", "post", "post",  ],
[ "ï¬…op", "ï¬…op", "ï¬…op", "ï¬…OP", "ï¬…op", "Stop", "STOP", "ï¬…op", "stop", "stop",  ],
[ "tschÃ¼ÃŸ", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœÃŸ", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœSS", "tschÃ¼ÃŸ", "tschÃ¼ss", "tschÃ¼ss",  ],
[ "TSCHÃœáºž", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœáºž", "tschÃ¼ÃŸ", "TschÃ¼ÃŸ", "TSCHÃœáºž", "tschÃ¼ÃŸ", "tschÃ¼ss", "tschÃ¼ss",  ],
[ "ruÃŸland", "ruÃŸland", "RuÃŸland", "RUÃŸLAND", "ruÃŸland", "RuÃŸland", "RUSSLAND", "ruÃŸland", "russland", "russland",  ],
[ "RUáºžLAND", "ruÃŸland", "RuÃŸland", "RUáºžLAND", "ruÃŸland", "RuÃŸland", "RUáºžLAND", "ruÃŸland", "russland", "russland",  ],
[ "weiÃŸ", "weiÃŸ", "WeiÃŸ", "WEIÃŸ", "weiÃŸ", "WeiÃŸ", "WEISS", "weiÃŸ", "weiss", "weiss",  ],
[ "WEIáºž", "weiÃŸ", "WeiÃŸ", "WEIáºž", "weiÃŸ", "WeiÃŸ", "WEIáºž", "weiÃŸ", "weÄ±ss", "weiss",  ],
[ "áºžIEW", "ÃŸiew", "áºžiew", "áºžIEW", "ÃŸiew", "áºžiew", "áºžIEW", "ÃŸiew", "ssÄ±ew", "ssiew",  ],
[ "Í…", "Í…", "Î™", "Î™", "Í…", "Î™", "Î™", "Î¹", "Î¹", "Î¹",  ],
[ "Î±Ì€Í…", "Î±Ì€Í…", "Î‘Ì€Í…", "Î‘Ì€Î™", "Î±Ì€Í…", "Î‘Ì€Í…", "Î‘Ì€Î™", "Î±Ì€Î¹", "Î±Ì€Î¹", "Î±Ì€Î¹",  ],
[ "á¾ºÎ¹", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾²", "á¾²", "á¾²", "á¾²", "á¾²", "á¾ºÍ…", "á¾ºÎ™", "á¾²", "á½°Î¹", "á½°Î¹",  ],
[ "á¾ºÍ…", "á½°Í…", "á¾ºÍ…", "á¾ºÎ™", "á½°Í…", "á¾ºÍ…", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á¾ºÎ¹", "á¾ºÎ™", "á½°Î¹", "á½°Î¹", "á½°Î¹",  ],
[ "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á¾² Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿", "á¾² Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ", "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á¾ºÍ… Î£Ï„Î¿ Î”Î¹Î¬Î¿Î»Î¿", "á¾ºÎ™ Î£Î¤ÎŸ Î”Î™Î†ÎŸÎ›ÎŸ", "á¾² ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿", "á½°Î¹ ÏƒÏ„Î¿ Î´Î¹Î¬Î¿Î»Î¿",  ],
[ "Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ", "Î±Ì€Í… ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Í… Î£Ï„Î¿ Î”Î¹Î±ÌÎ¿Î»Î¿", "Î‘Ì€Î™ Î£Î¤ÎŸ Î”Î™Î‘ÌÎŸÎ›ÎŸ", "Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿", "Î±Ì€Î¹ ÏƒÏ„Î¿ Î´Î¹Î±ÌÎ¿Î»Î¿",  ],
[ "â…·", "â…·", "â…§", "â…§", "â…·", "â…§", "â…§", "â…·", "â…·", "â…·",  ],
[ "henry â…·", "henry â…·", "Henry â…§", "HENRY â…§", "henry â…·", "Henry â…§", "HENRY â…§", "henry â…·", "henry â…·", "henry â…·",  ],
[ "â“š", "â“š", "â“€", "â“€", "â“š", "â“€", "â“€", "â“š", "â“š", "â“š",  ],
[ "i work at â“š", "i work at â“š", "I Work At â“€", "I WORK AT â“€", "i work at â“š", "I Work At â“€", "I WORK AT â“€", "i work at â“š", "i work at â“š", "i work at â“š",  ],
[ "istambul", "istambul", "Istambul", "ISTAMBUL", "istambul", "Istambul", "ISTAMBUL", "istambul", "istambul", "istambul",  ],
[ "iÌ‡stanbul", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "iÌ‡stanbul", "iÌ‡stanbul",  ],
[ "IÌ‡stanbul", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "IÌ‡stanbul", "IÌ‡STANBUL", "iÌ‡stanbul", "Ä±Ì‡stanbul", "iÌ‡stanbul",  ],
[ "Ä°STANBUL", "istanbul", "Ä°stanbul", "Ä°STANBUL", "iÌ‡stanbul", "Ä°stanbul", "Ä°STANBUL", "Ä°stanbul", "istanbul", "iÌ‡stanbul",  ],
[ "ÏƒÏ„Î¹Î³Î¼Î±Ï‚", "ÏƒÏ„Î¹Î³Î¼Î±Ï‚", "Î£Ï„Î¹Î³Î¼Î±Ï‚", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ï‚", "Î£Ï„Î¹Î³Î¼Î±Ï‚", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ",  ],
[ "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ",  ],
[ "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "Î£Ï„Î¹Î³Î¼Î±Ïƒ", "Î£Î¤Î™Î“ÎœÎ‘Î£", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ", "ÏƒÏ„Î¹Î³Î¼Î±Ïƒ",  ],
[ "Ê€á´€Ê€á´‡", "Ê€á´€Ê€á´‡", "Æ¦á´€Ê€á´‡", "Æ¦á´€Æ¦á´‡", "Ê€á´€Ê€á´‡", "Æ¦á´€Ê€á´‡", "Æ¦á´€Æ¦á´‡", "Ê€á´€Ê€á´‡", "Ê€á´€Ê€á´‡", "Ê€á´€Ê€á´‡",  ],
[ "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð‡ðð€ð¡ð‡ð“", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð”ð‡ðð€ð¡ð‡ð“", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»", "ð¼ð¯ð‘…ð¨ð‘‰ð¯ð»",  ],
[ "Ô¦Ô§", "Ô§Ô§", "Ô¦Ô§", "Ô¦Ô¦", "Ô§Ô§", "Ô¦Ô§", "Ô¦Ô¦", "Ô§Ô§", "Ô§Ô§", "Ô§Ô§",  ],
[ "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "ï¬“ï¬”ï¬•ï¬–ï¬—", "Õ„Õ¶ï¬”ï¬•ï¬–ï¬—", "Õ„Õ†Õ„ÔµÕ„Ô»ÕŽÕ†Õ„Ô½", "ï¬“ï¬”ï¬•ï¬–ï¬—", "Õ´Õ¶Õ´Õ¥Õ´Õ«Õ¾Õ¶Õ´Õ­", "Õ´Õ¶Õ´Õ¥Õ´Õ«Õ¾Õ¶Õ´Õ­",  ],
[ "Å‰ groot", "Å‰ groot", "Å‰ Groot", "Å‰ GROOT", "Å‰ groot", "Ê¼N Groot", "Ê¼N GROOT", "Å‰ groot", "Ê¼n groot", "Ê¼n groot",  ],
[ "áºš", "áºš", "áºš", "áºš", "áºš", "AÊ¾", "AÊ¾", "áºš", "aÊ¾", "aÊ¾",  ],
[ "ï¬€", "ï¬€", "ï¬€", "ï¬€", "ï¬€", "Ff", "FF", "ï¬€", "ff", "ff",  ],
[ "Ç°", "Ç°", "Ç°", "Ç°", "Ç°", "JÌŒ", "JÌŒ", "Ç°", "jÌŒ", "jÌŒ",  ],
[ "550 nm or â„«", "550 nm or Ã¥", "550 Nm Or â„«", "550 NM OR â„«", "550 nm or Ã¥", "550 Nm Or â„«", "550 NM OR â„«", "550 nm or Ã¥", "550 nm or Ã¥", "550 nm or Ã¥",  ],
);

    use feature qw(fc);
d8 42
a49 10
    for (@@test_table) {
        my ($simple_lc, $simple_tc, $simple_uc, $simple_fc) = @@{$_}[1, 2, 3, 7];
        my ($orig, $lower, $titlecase, $upper, $fc_turkic, $fc_full) = @@{$_}[0,4,5,6,8,9];

        is( fc($orig), $fc_full, 'fc works' );
        is( "\F$orig", $fc_full, '\F works' );
        is( lc($orig), $lower,   'lc works' );
        is( "\L$orig", $lower,   '\L works' );
        is( uc($orig), $upper,   'uc works' );
        is( "\U$orig", $upper,   '\U works' );
d51 2
a53 94

{
    use feature qw(fc);
    package Eeyup  { use overload q{""} => sub { "\x{df}"   }, fallback => 1 }
    package Uunope { use overload q{""} => sub { "\x{30cb}" }, fallback => 1 }
    package Undef  { use overload q{""} => sub {   undef    }, fallback => 1 }

    my $obj = bless {}, "Eeyup";
    is(fc($obj), "ss", "fc() works on overloaded objects returning latin-1");
    $obj = bless {}, "Eeyup";
    is("\F$obj", "ss", '\F works on overloaded objects returning latin-1');

    $obj = bless {}, "Uunope";
    is(fc($obj), "\x{30cb}", "fc() works on overloaded objects returning UTF-8");
    $obj = bless {}, "Uunope";
    is("\F$obj", "\x{30cb}", '\F works on overloaded objects returning UTF-8');

    $obj = bless {}, "Undef";
    my $warnings;
    {
        no warnings;
        use warnings "uninitialized";
        local $SIG{__WARN__} = sub { $warnings++; like(shift, qr/Use of uninitialized value (?:\$obj )?in fc/) };
        fc(undef);
        fc($obj);
    }
    is( $warnings, 2, "correct number of warnings" );

    my $fetched = 0;
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; "\x{df}" } }

    tie my $x, "Derpy";

    is( fc($x), "ss", "fc() works on tied values" );
    is( $fetched, 1, "and only calls the magic once" );

}

{
    use feature qw( fc );
    my $troublesome1 = "\xdf" x 11; #SvLEN should be 12, SvCUR should be 11
                                    #So this should force fc() to grow the string.

    is( fc($troublesome1), "ss" x 11, "fc() grows the string" );

    my $troublesome2 = "abcdef:\x{df}:fjksjs"; #SvLEN should be 16, SvCUR should be 15
    is( fc($troublesome2), "abcdef:ss:fjksjs", "fc() expands \\x{DF} in the middle of a string that needs to grow" );

    my $troublesome3 = ":\x{df}:";
    is( fc($troublesome3), ":ss:", "fc() expands \\x{DF} in the middle of a string" );


    my $troublesome4 = "\x{B5}"; #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8

    is( fc($troublesome4), "\x{3BC}", "fc() for a latin-1 \x{B5} returns UTF-8" );
    ok( !utf8::is_utf8($troublesome4), "fc() doesn't upgrade the original string" );


    my $troublesome5 = "\x{C9}abda\x{B5}aaf\x{C8}"; # Up until foldcasing \x{B5}, the string
                                                    # was in Latin-1. This tests that the
                                                    # results don't have illegal UTF-8
                                                    # (i.e. leftover latin-1) in them

    is( fc($troublesome5), "\x{E9}abda\x{3BC}aaf\x{E8}" );
}

{
    use feature qw( fc unicode_strings );

    # This tests both code paths in pp_fc

    for (0..0xff) {
        my $latin1 = chr;
        my $utf8   = $latin1;
        utf8::downgrade($latin1); #No-op, but doesn't hurt
        utf8::upgrade($utf8);
        is(fc($latin1), fc($utf8), "fc() gives the same results for \\x{$_} in Latin-1 and UTF-8 under unicode_strings");
        {
            use locale;
            is(fc($latin1), lc($latin1), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
            is(fc($utf8), lc($utf8), "use locale; fc(qq{\\x{$_}}), lc(qq{\\x{$_}}) when qq{\\x{$_}} is in latin-1");
        }
        {
            no feature 'unicode_strings';
            is(fc($latin1), lc($latin1), "under nothing, fc() for <256 is the same as lc");
        }
    }
}

my $num_tests = curr_test() - 1;

die qq[$0: failed to find casefoldings from "$CF"\n] unless $num_tests > 0;

plan($num_tests);
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a9 1
    require Config; import Config;
a13 1
use Unicode::UCD qw(all_casefolds);
a18 1

d21 4
a24 2
my $casefolds = all_casefolds();
my @@folds;
d28 16
a43 15
use Unicode::UCD;
use charnames();

foreach my $decimal_code_point (sort { $a <=> $b } keys %$casefolds) {
    # We only use simple folds in fc(), since the regex engine uses full case
    # folding.

    my $name = charnames::viacode($decimal_code_point);
    my $type = $casefolds->{$decimal_code_point}{'status'};
    my $code = $casefolds->{$decimal_code_point}{'code'};
    my $simple = $casefolds->{$decimal_code_point}{'simple'};
    my $full = $casefolds->{$decimal_code_point}{'full'};

    if ($simple && $simple ne $full) { # If there is a distinction
        push @@simple_folds, [ $code, $simple, $type, $name ];
d46 1
a46 1
    push @@CF, [ $code, $full, $type, $name ];
d49 1
a49 1
    $reverse_fold{pack "U0U*", hex $simple} = pack "U0U*", $decimal_code_point if $simple;
d52 2
d342 1
a342 6
        if ($orig =~ /(\P{Assigned})/) {   # So can fail gracefully in earlier
                                           # Unicode versions
            fail(sprintf "because U+%04X is unassigned", ord($1));
            next;
        }
        is( fc($orig), $fc_full, "fc('$orig') returns '$fc_full'" );
d344 1
a344 1
        is( lc($orig), $lower,   "lc('$orig') returns '$lower'" );
d346 1
a346 1
        is( uc($orig), $upper,   "uc('$orig') returns '$upper'" );
d427 2
a428 7
        SKIP: {
              skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
              BEGIN {
                  if($Config{d_setlocale}) {
                      require locale; import locale;
                  }
              }
d440 2
@


1.1.1.5
log
@Import perl-5.20.1
@
text
@a11 1
    require './loc_tools.pl';   # Contains find_utf8_ctype_locale()
a418 1

a420 2
    use if $Config{d_setlocale}, qw(POSIX locale_h);
    setlocale(&POSIX::LC_ALL, "C") if $Config{d_setlocale};
a445 34

my $utf8_locale = find_utf8_ctype_locale();

{
    use feature qw( fc );
    use locale;
    is(fc("\x{1E9E}"), fc("\x{17F}\x{17F}"), 'fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")');
    SKIP: {
        skip 'Can\'t find a UTF-8 locale', 1 unless defined $utf8_locale;
        setlocale(&LC_CTYPE, $utf8_locale);
        is(fc("\x{1E9E}"), "ss", 'fc("\x{1E9E}") eq "ss" in a UTF-8 locale)');
    }
}

SKIP: {
    skip 'Can\'t find a UTF-8 locale', 256 unless defined $utf8_locale;

    use feature qw( fc unicode_strings );

    # Get the official fc values outside locale.
    no locale;
    my @@unicode_fc;
    for (0..0xff) {
        push @@unicode_fc, fc(chr);
    }

    # These should match the UTF-8 locale values
    setlocale(&LC_CTYPE, $utf8_locale);
    use locale;
    for (0..0xff) {
        is(fc(chr), $unicode_fc[$_], "In a UTF-8 locale, fc(chr $_) is the same as official Unicode");
    }
}

@


1.1.1.6
log
@Import perl-5.24.2
@
text
@d9 2
a11 5
    set_up_inc('../lib');
    skip_all_without_unicode_tables();
    skip_all_if_miniperl("miniperl, no Unicode::Normalize");
    require Config; import Config;
    require './charset_tools.pl';
d50 1
a50 1
    $reverse_fold{pack "W*", hex $simple} = pack "W*", $decimal_code_point if $simple;
d56 2
a57 3
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
d68 2
a69 3
    my $c = pack("W*", hex $code);
    utf8::upgrade($c);
    my $f = pack("W*", map { hex } split " ", $mapping);
d186 1
a186 2
    is( fc("r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9")),
           "r" . uni_to_native("\xe9") . "sum" . uni_to_native("\xe9") );
d196 2
a197 2
        uni_to_native("\x{61}\x{42}\x{130}\x{49}\x{131}\x{3d0}\x{df}\x{fb03}"),
        "A" . uni_to_native("\x{df}\x{b5}\x{fb03}\x{1040C}\x{130}\x{131}"),
d201 2
a202 2
        uni_to_native("\x{61}\x{62}\x{69}\x{307}\x{69}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
        "ass\x{3bc}ffi\x{10434}i\x{307}\x{131}"
d206 2
a207 2
        uni_to_native("\x{61}\x{62}\x{69}\x{131}\x{131}\x{3b2}\x{73}\x{73}\x{66}\x{66}\x{69}"),
                         "ass\x{3bc}ffi\x{10434}i\x{131}",
d357 1
a357 1
    package Eeyup  { use overload q{""} => sub { main::uni_to_native("\x{df}")   }, fallback => 1 }
d383 1
a383 1
    package Derpy { sub TIESCALAR { bless {}, shift } sub FETCH { $fetched++; main::uni_to_native("\x{df}") } }
d394 1
a394 1
    my $troublesome1 = uni_to_native("\xdf") x 11; #SvLEN should be 12, SvCUR should be 11
d399 1
a399 2
    my $troublesome2 = "abcdef:" . uni_to_native("\x{df}")
                     . ":fjksjs"; #SvLEN should be 16, SvCUR should be 15
d402 1
a402 1
    my $troublesome3 = ":" . uni_to_native("\x{df}") . ":";
d406 1
a406 1
    my $troublesome4 = uni_to_native("\x{B5}"); #\N{MICRON SIGN} is latin-1, but its foldcase is in UTF-8
d412 1
a412 3
    my $troublesome5 = uni_to_native("\x{C9}") . "abda"
                     . uni_to_native("\x{B5}") . "aaf"
                     . uni_to_native("\x{C8}");  # Up until foldcasing \x{B5}, the string
d417 1
a417 2
    is( fc($troublesome5), uni_to_native("\x{E9}") . "abda\x{3BC}aaf"
                         . uni_to_native("\x{E8}") );
d421 1
a421 1
SKIP: {
d423 2
a424 4

    skip "locales not available", 256 unless locales_enabled('LC_ALL');

    setlocale(&POSIX::LC_ALL, "C");
d435 6
a440 2
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');
            use locale;
a455 1
    no warnings 'locale';   # Would otherwise warn
a456 1
    use warnings 'locale';
@


