head	1.21;
access;
symbols
	PERL_5_24_2:1.1.1.17
	OPENBSD_6_1:1.21.0.4
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	PERL_5_20_2:1.1.1.16
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.15.0.10
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.8
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.6
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.21
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.20;
commitid	cxJ08BvJA9Pt2PTM;

1.20
date	2016.07.03.01.07.49;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	GzHqjSTnBjdF7Wcw;

1.19
date	2015.04.25.19.14.38;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	XRK22kO4se3v2i2I;

1.18
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	QP75iYx42Uo7mMxO;

1.17
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.14.16.34.57;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.00;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.06.23.25.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.23;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.59;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.50;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.50;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.03;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.49;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.25;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.50;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.38;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.46;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.11;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.31;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.42;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2015.04.25.19.10.14;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.17
date	2017.08.14.13.45.31;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.21
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    toke.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *  'It all comes from here, the stench and the peril.'    --Frodo
 *
 *     [p.719 of _The Lord of the Rings_, IV/ix: "Shelob's Lair"]
 */

/*
 * This file is the lexer for Perl.  It's closely linked to the
 * parser, perly.y.
 *
 * The main routine is yylex(), which returns the next token.
 */

/*
=head1 Lexer interface
This is the lower layer of the Perl parser, managing characters and tokens.

=for apidoc AmU|yy_parser *|PL_parser

Pointer to a structure encapsulating the state of the parsing operation
currently in progress.  The pointer can be locally changed to perform
a nested parse without interfering with the state of an outer parse.
Individual members of C<PL_parser> have their own documentation.

=cut
*/

#include "EXTERN.h"
#define PERL_IN_TOKE_C
#include "perl.h"
#include "dquote_inline.h"

#define new_constant(a,b,c,d,e,f,g)	\
	S_new_constant(aTHX_ a,b,STR_WITH_LEN(c),d,e,f, g)

#define pl_yylval	(PL_parser->yylval)

/* XXX temporary backwards compatibility */
#define PL_lex_brackets		(PL_parser->lex_brackets)
#define PL_lex_allbrackets	(PL_parser->lex_allbrackets)
#define PL_lex_fakeeof		(PL_parser->lex_fakeeof)
#define PL_lex_brackstack	(PL_parser->lex_brackstack)
#define PL_lex_casemods		(PL_parser->lex_casemods)
#define PL_lex_casestack        (PL_parser->lex_casestack)
#define PL_lex_defer		(PL_parser->lex_defer)
#define PL_lex_dojoin		(PL_parser->lex_dojoin)
#define PL_lex_formbrack        (PL_parser->lex_formbrack)
#define PL_lex_inpat		(PL_parser->lex_inpat)
#define PL_lex_inwhat		(PL_parser->lex_inwhat)
#define PL_lex_op		(PL_parser->lex_op)
#define PL_lex_repl		(PL_parser->lex_repl)
#define PL_lex_starts		(PL_parser->lex_starts)
#define PL_lex_stuff		(PL_parser->lex_stuff)
#define PL_multi_start		(PL_parser->multi_start)
#define PL_multi_open		(PL_parser->multi_open)
#define PL_multi_close		(PL_parser->multi_close)
#define PL_preambled		(PL_parser->preambled)
#define PL_sublex_info		(PL_parser->sublex_info)
#define PL_linestr		(PL_parser->linestr)
#define PL_expect		(PL_parser->expect)
#define PL_copline		(PL_parser->copline)
#define PL_bufptr		(PL_parser->bufptr)
#define PL_oldbufptr		(PL_parser->oldbufptr)
#define PL_oldoldbufptr		(PL_parser->oldoldbufptr)
#define PL_linestart		(PL_parser->linestart)
#define PL_bufend		(PL_parser->bufend)
#define PL_last_uni		(PL_parser->last_uni)
#define PL_last_lop		(PL_parser->last_lop)
#define PL_last_lop_op		(PL_parser->last_lop_op)
#define PL_lex_state		(PL_parser->lex_state)
#define PL_rsfp			(PL_parser->rsfp)
#define PL_rsfp_filters		(PL_parser->rsfp_filters)
#define PL_in_my		(PL_parser->in_my)
#define PL_in_my_stash		(PL_parser->in_my_stash)
#define PL_tokenbuf		(PL_parser->tokenbuf)
#define PL_multi_end		(PL_parser->multi_end)
#define PL_error_count		(PL_parser->error_count)

#  define PL_nexttoke		(PL_parser->nexttoke)
#  define PL_nexttype		(PL_parser->nexttype)
#  define PL_nextval		(PL_parser->nextval)

static const char* const ident_too_long = "Identifier too long";

#  define NEXTVAL_NEXTTOKE PL_nextval[PL_nexttoke]

#define XENUMMASK  0x3f
#define XFAKEEOF   0x40
#define XFAKEBRACK 0x80

#ifdef USE_UTF8_SCRIPTS
#   define UTF cBOOL(!IN_BYTES)
#else
#   define UTF cBOOL((PL_linestr && DO_UTF8(PL_linestr)) || ( !(PL_parser->lex_flags & LEX_IGNORE_UTF8_HINTS) && (PL_hints & HINT_UTF8)))
#endif

/* The maximum number of characters preceding the unrecognized one to display */
#define UNRECOGNIZED_PRECEDE_COUNT 10

/* In variables named $^X, these are the legal values for X.
 * 1999-02-27 mjd-perl-patch@@plover.com */
#define isCONTROLVAR(x) (isUPPER(x) || strchr("[\\]^_?", (x)))

#define SPACE_OR_TAB(c) isBLANK_A(c)

#define HEXFP_PEEK(s)     \
    (((s[0] == '.') && \
      (isXDIGIT(s[1]) || isALPHA_FOLD_EQ(s[1], 'p'))) || \
     isALPHA_FOLD_EQ(s[0], 'p'))

/* LEX_* are values for PL_lex_state, the state of the lexer.
 * They are arranged oddly so that the guard on the switch statement
 * can get by with a single comparison (if the compiler is smart enough).
 *
 * These values refer to the various states within a sublex parse,
 * i.e. within a double quotish string
 */

/* #define LEX_NOTPARSING		11 is done in perl.h. */

#define LEX_NORMAL		10 /* normal code (ie not within "...")     */
#define LEX_INTERPNORMAL	 9 /* code within a string, eg "$foo[$x+1]" */
#define LEX_INTERPCASEMOD	 8 /* expecting a \U, \Q or \E etc          */
#define LEX_INTERPPUSH		 7 /* starting a new sublex parse level     */
#define LEX_INTERPSTART		 6 /* expecting the start of a $var         */

				   /* at end of code, eg "$x" followed by:  */
#define LEX_INTERPEND		 5 /* ... eg not one of [, { or ->          */
#define LEX_INTERPENDMAYBE	 4 /* ... eg one of [, { or ->              */

#define LEX_INTERPCONCAT	 3 /* expecting anything, eg at start of
				        string or after \E, $foo, etc       */
#define LEX_INTERPCONST		 2 /* NOT USED */
#define LEX_FORMLINE		 1 /* expecting a format line               */
#define LEX_KNOWNEXT		 0 /* next token known; just return it      */


#ifdef DEBUGGING
static const char* const lex_state_names[] = {
    "KNOWNEXT",
    "FORMLINE",
    "INTERPCONST",
    "INTERPCONCAT",
    "INTERPENDMAYBE",
    "INTERPEND",
    "INTERPSTART",
    "INTERPPUSH",
    "INTERPCASEMOD",
    "INTERPNORMAL",
    "NORMAL"
};
#endif

#include "keywords.h"

/* CLINE is a macro that ensures PL_copline has a sane value */

#define CLINE (PL_copline = (CopLINE(PL_curcop) < PL_copline ? CopLINE(PL_curcop) : PL_copline))

/*
 * Convenience functions to return different tokens and prime the
 * lexer for the next token.  They all take an argument.
 *
 * TOKEN        : generic token (used for '(', DOLSHARP, etc)
 * OPERATOR     : generic operator
 * AOPERATOR    : assignment operator
 * PREBLOCK     : beginning the block after an if, while, foreach, ...
 * PRETERMBLOCK : beginning a non-code-defining {} block (eg, hash ref)
 * PREREF       : *EXPR where EXPR is not a simple identifier
 * TERM         : expression term
 * POSTDEREF    : postfix dereference (->$* ->@@[...] etc.)
 * LOOPX        : loop exiting command (goto, last, dump, etc)
 * FTST         : file test operator
 * FUN0         : zero-argument function
 * FUN0OP       : zero-argument function, with its op created in this file
 * FUN1         : not used, except for not, which isn't a UNIOP
 * BOop         : bitwise or or xor
 * BAop         : bitwise and
 * BCop         : bitwise complement
 * SHop         : shift operator
 * PWop         : power operator
 * PMop         : pattern-matching operator
 * Aop          : addition-level operator
 * AopNOASSIGN  : addition-level operator that is never part of .=
 * Mop          : multiplication-level operator
 * Eop          : equality-testing operator
 * Rop          : relational operator <= != gt
 *
 * Also see LOP and lop() below.
 */

#ifdef DEBUGGING /* Serve -DT. */
#   define REPORT(retval) tokereport((I32)retval, &pl_yylval)
#else
#   define REPORT(retval) (retval)
#endif

#define TOKEN(retval) return ( PL_bufptr = s, REPORT(retval))
#define OPERATOR(retval) return (PL_expect = XTERM, PL_bufptr = s, REPORT(retval))
#define AOPERATOR(retval) return ao((PL_expect = XTERM, PL_bufptr = s, retval))
#define PREBLOCK(retval) return (PL_expect = XBLOCK,PL_bufptr = s, REPORT(retval))
#define PRETERMBLOCK(retval) return (PL_expect = XTERMBLOCK,PL_bufptr = s, REPORT(retval))
#define PREREF(retval) return (PL_expect = XREF,PL_bufptr = s, REPORT(retval))
#define TERM(retval) return (CLINE, PL_expect = XOPERATOR, PL_bufptr = s, REPORT(retval))
#define POSTDEREF(f) return (PL_bufptr = s, S_postderef(aTHX_ REPORT(f),s[1]))
#define LOOPX(f) return (PL_bufptr = force_word(s,WORD,TRUE,FALSE), \
			 pl_yylval.ival=f, \
			 PL_expect = PL_nexttoke ? XOPERATOR : XTERM, \
			 REPORT((int)LOOPEX))
#define FTST(f)  return (pl_yylval.ival=f, PL_expect=XTERMORDORDOR, PL_bufptr=s, REPORT((int)UNIOP))
#define FUN0(f)  return (pl_yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC0))
#define FUN0OP(f)  return (pl_yylval.opval=f, CLINE, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC0OP))
#define FUN1(f)  return (pl_yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC1))
#define BOop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)BITOROP))
#define BAop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)BITANDOP))
#define BCop(f) return pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr = s, \
		       REPORT('~')
#define SHop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)SHIFTOP))
#define PWop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)POWOP))
#define PMop(f)  return(pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MATCHOP))
#define Aop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)ADDOP))
#define AopNOASSIGN(f) return (pl_yylval.ival=f, PL_bufptr=s, REPORT((int)ADDOP))
#define Mop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)MULOP))
#define Eop(f)   return (pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)EQOP))
#define Rop(f)   return (pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)RELOP))

/* This bit of chicanery makes a unary function followed by
 * a parenthesis into a function with one argument, highest precedence.
 * The UNIDOR macro is for unary functions that can be followed by the //
 * operator (such as C<shift // 0>).
 */
#define UNI3(f,x,have_x) { \
	pl_yylval.ival = f; \
	if (have_x) PL_expect = x; \
	PL_bufptr = s; \
	PL_last_uni = PL_oldbufptr; \
	PL_last_lop_op = f; \
	if (*s == '(') \
	    return REPORT( (int)FUNC1 ); \
	s = skipspace(s); \
	return REPORT( *s=='(' ? (int)FUNC1 : (int)UNIOP ); \
	}
#define UNI(f)    UNI3(f,XTERM,1)
#define UNIDOR(f) UNI3(f,XTERMORDORDOR,1)
#define UNIPROTO(f,optional) { \
	if (optional) PL_last_uni = PL_oldbufptr; \
	OPERATOR(f); \
	}

#define UNIBRACK(f) UNI3(f,0,0)

/* grandfather return to old style */
#define OLDLOP(f) \
	do { \
	    if (!PL_lex_allbrackets && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC) \
		PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC; \
	    pl_yylval.ival = (f); \
	    PL_expect = XTERM; \
	    PL_bufptr = s; \
	    return (int)LSTOP; \
	} while(0)

#define COPLINE_INC_WITH_HERELINES		    \
    STMT_START {				     \
	CopLINE_inc(PL_curcop);			      \
	if (PL_parser->herelines)		       \
	    CopLINE(PL_curcop) += PL_parser->herelines, \
	    PL_parser->herelines = 0;			 \
    } STMT_END
/* Called after scan_str to update CopLINE(PL_curcop), but only when there
 * is no sublex_push to follow. */
#define COPLINE_SET_FROM_MULTI_END	      \
    STMT_START {			       \
	CopLINE_set(PL_curcop, PL_multi_end);	\
	if (PL_multi_end != PL_multi_start)	 \
	    PL_parser->herelines = 0;		  \
    } STMT_END


#ifdef DEBUGGING

/* how to interpret the pl_yylval associated with the token */
enum token_type {
    TOKENTYPE_NONE,
    TOKENTYPE_IVAL,
    TOKENTYPE_OPNUM, /* pl_yylval.ival contains an opcode number */
    TOKENTYPE_PVAL,
    TOKENTYPE_OPVAL
};

static struct debug_tokens {
    const int token;
    enum token_type type;
    const char *name;
} const debug_tokens[] =
{
    { ADDOP,		TOKENTYPE_OPNUM,	"ADDOP" },
    { ANDAND,		TOKENTYPE_NONE,		"ANDAND" },
    { ANDOP,		TOKENTYPE_NONE,		"ANDOP" },
    { ANONSUB,		TOKENTYPE_IVAL,		"ANONSUB" },
    { ARROW,		TOKENTYPE_NONE,		"ARROW" },
    { ASSIGNOP,		TOKENTYPE_OPNUM,	"ASSIGNOP" },
    { BITANDOP,		TOKENTYPE_OPNUM,	"BITANDOP" },
    { BITOROP,		TOKENTYPE_OPNUM,	"BITOROP" },
    { COLONATTR,	TOKENTYPE_NONE,		"COLONATTR" },
    { CONTINUE,		TOKENTYPE_NONE,		"CONTINUE" },
    { DEFAULT,		TOKENTYPE_NONE,		"DEFAULT" },
    { DO,		TOKENTYPE_NONE,		"DO" },
    { DOLSHARP,		TOKENTYPE_NONE,		"DOLSHARP" },
    { DORDOR,		TOKENTYPE_NONE,		"DORDOR" },
    { DOROP,		TOKENTYPE_OPNUM,	"DOROP" },
    { DOTDOT,		TOKENTYPE_IVAL,		"DOTDOT" },
    { ELSE,		TOKENTYPE_NONE,		"ELSE" },
    { ELSIF,		TOKENTYPE_IVAL,		"ELSIF" },
    { EQOP,		TOKENTYPE_OPNUM,	"EQOP" },
    { FOR,		TOKENTYPE_IVAL,		"FOR" },
    { FORMAT,		TOKENTYPE_NONE,		"FORMAT" },
    { FORMLBRACK,	TOKENTYPE_NONE,		"FORMLBRACK" },
    { FORMRBRACK,	TOKENTYPE_NONE,		"FORMRBRACK" },
    { FUNC,		TOKENTYPE_OPNUM,	"FUNC" },
    { FUNC0,		TOKENTYPE_OPNUM,	"FUNC0" },
    { FUNC0OP,		TOKENTYPE_OPVAL,	"FUNC0OP" },
    { FUNC0SUB,		TOKENTYPE_OPVAL,	"FUNC0SUB" },
    { FUNC1,		TOKENTYPE_OPNUM,	"FUNC1" },
    { FUNCMETH,		TOKENTYPE_OPVAL,	"FUNCMETH" },
    { GIVEN,		TOKENTYPE_IVAL,		"GIVEN" },
    { HASHBRACK,	TOKENTYPE_NONE,		"HASHBRACK" },
    { IF,		TOKENTYPE_IVAL,		"IF" },
    { LABEL,		TOKENTYPE_PVAL,		"LABEL" },
    { LOCAL,		TOKENTYPE_IVAL,		"LOCAL" },
    { LOOPEX,		TOKENTYPE_OPNUM,	"LOOPEX" },
    { LSTOP,		TOKENTYPE_OPNUM,	"LSTOP" },
    { LSTOPSUB,		TOKENTYPE_OPVAL,	"LSTOPSUB" },
    { MATCHOP,		TOKENTYPE_OPNUM,	"MATCHOP" },
    { METHOD,		TOKENTYPE_OPVAL,	"METHOD" },
    { MULOP,		TOKENTYPE_OPNUM,	"MULOP" },
    { MY,		TOKENTYPE_IVAL,		"MY" },
    { NOAMP,		TOKENTYPE_NONE,		"NOAMP" },
    { NOTOP,		TOKENTYPE_NONE,		"NOTOP" },
    { OROP,		TOKENTYPE_IVAL,		"OROP" },
    { OROR,		TOKENTYPE_NONE,		"OROR" },
    { PACKAGE,		TOKENTYPE_NONE,		"PACKAGE" },
    { PLUGEXPR,		TOKENTYPE_OPVAL,	"PLUGEXPR" },
    { PLUGSTMT,		TOKENTYPE_OPVAL,	"PLUGSTMT" },
    { PMFUNC,		TOKENTYPE_OPVAL,	"PMFUNC" },
    { POSTJOIN,		TOKENTYPE_NONE,		"POSTJOIN" },
    { POSTDEC,		TOKENTYPE_NONE,		"POSTDEC" },
    { POSTINC,		TOKENTYPE_NONE,		"POSTINC" },
    { POWOP,		TOKENTYPE_OPNUM,	"POWOP" },
    { PREDEC,		TOKENTYPE_NONE,		"PREDEC" },
    { PREINC,		TOKENTYPE_NONE,		"PREINC" },
    { PRIVATEREF,	TOKENTYPE_OPVAL,	"PRIVATEREF" },
    { QWLIST,		TOKENTYPE_OPVAL,	"QWLIST" },
    { REFGEN,		TOKENTYPE_NONE,		"REFGEN" },
    { RELOP,		TOKENTYPE_OPNUM,	"RELOP" },
    { REQUIRE,		TOKENTYPE_NONE,		"REQUIRE" },
    { SHIFTOP,		TOKENTYPE_OPNUM,	"SHIFTOP" },
    { SUB,		TOKENTYPE_NONE,		"SUB" },
    { THING,		TOKENTYPE_OPVAL,	"THING" },
    { UMINUS,		TOKENTYPE_NONE,		"UMINUS" },
    { UNIOP,		TOKENTYPE_OPNUM,	"UNIOP" },
    { UNIOPSUB,		TOKENTYPE_OPVAL,	"UNIOPSUB" },
    { UNLESS,		TOKENTYPE_IVAL,		"UNLESS" },
    { UNTIL,		TOKENTYPE_IVAL,		"UNTIL" },
    { USE,		TOKENTYPE_IVAL,		"USE" },
    { WHEN,		TOKENTYPE_IVAL,		"WHEN" },
    { WHILE,		TOKENTYPE_IVAL,		"WHILE" },
    { WORD,		TOKENTYPE_OPVAL,	"WORD" },
    { YADAYADA,		TOKENTYPE_IVAL,		"YADAYADA" },
    { 0,		TOKENTYPE_NONE,		NULL }
};

/* dump the returned token in rv, plus any optional arg in pl_yylval */

STATIC int
S_tokereport(pTHX_ I32 rv, const YYSTYPE* lvalp)
{
    PERL_ARGS_ASSERT_TOKEREPORT;

    if (DEBUG_T_TEST) {
	const char *name = NULL;
	enum token_type type = TOKENTYPE_NONE;
	const struct debug_tokens *p;
	SV* const report = newSVpvs("<== ");

	for (p = debug_tokens; p->token; p++) {
	    if (p->token == (int)rv) {
		name = p->name;
		type = p->type;
		break;
	    }
	}
	if (name)
	    Perl_sv_catpv(aTHX_ report, name);
	else if (isGRAPH(rv))
	{
	    Perl_sv_catpvf(aTHX_ report, "'%c'", (char)rv);
	    if ((char)rv == 'p')
		sv_catpvs(report, " (pending identifier)");
	}
	else if (!rv)
	    sv_catpvs(report, "EOF");
	else
	    Perl_sv_catpvf(aTHX_ report, "?? %"IVdf, (IV)rv);
	switch (type) {
	case TOKENTYPE_NONE:
	    break;
	case TOKENTYPE_IVAL:
	    Perl_sv_catpvf(aTHX_ report, "(ival=%"IVdf")", (IV)lvalp->ival);
	    break;
	case TOKENTYPE_OPNUM:
	    Perl_sv_catpvf(aTHX_ report, "(ival=op_%s)",
				    PL_op_name[lvalp->ival]);
	    break;
	case TOKENTYPE_PVAL:
	    Perl_sv_catpvf(aTHX_ report, "(pval=\"%s\")", lvalp->pval);
	    break;
	case TOKENTYPE_OPVAL:
	    if (lvalp->opval) {
		Perl_sv_catpvf(aTHX_ report, "(opval=op_%s)",
				    PL_op_name[lvalp->opval->op_type]);
		if (lvalp->opval->op_type == OP_CONST) {
		    Perl_sv_catpvf(aTHX_ report, " %s",
			SvPEEK(cSVOPx_sv(lvalp->opval)));
		}

	    }
	    else
		sv_catpvs(report, "(opval=null)");
	    break;
	}
        PerlIO_printf(Perl_debug_log, "### %s\n\n", SvPV_nolen_const(report));
    };
    return (int)rv;
}


/* print the buffer with suitable escapes */

STATIC void
S_printbuf(pTHX_ const char *const fmt, const char *const s)
{
    SV* const tmp = newSVpvs("");

    PERL_ARGS_ASSERT_PRINTBUF;

    GCC_DIAG_IGNORE(-Wformat-nonliteral); /* fmt checked by caller */
    PerlIO_printf(Perl_debug_log, fmt, pv_display(tmp, s, strlen(s), 0, 60));
    GCC_DIAG_RESTORE;
    SvREFCNT_dec(tmp);
}

#endif

static int
S_deprecate_commaless_var_list(pTHX) {
    PL_expect = XTERM;
    deprecate("comma-less variable list");
    return REPORT(','); /* grandfather non-comma-format format */
}

/*
 * S_ao
 *
 * This subroutine looks for an '=' next to the operator that has just been
 * parsed and turns it into an ASSIGNOP if it finds one.
 */

STATIC int
S_ao(pTHX_ int toketype)
{
    if (*PL_bufptr == '=') {
	PL_bufptr++;
	if (toketype == ANDAND)
	    pl_yylval.ival = OP_ANDASSIGN;
	else if (toketype == OROR)
	    pl_yylval.ival = OP_ORASSIGN;
	else if (toketype == DORDOR)
	    pl_yylval.ival = OP_DORASSIGN;
	toketype = ASSIGNOP;
    }
    return REPORT(toketype);
}

/*
 * S_no_op
 * When Perl expects an operator and finds something else, no_op
 * prints the warning.  It always prints "<something> found where
 * operator expected.  It prints "Missing semicolon on previous line?"
 * if the surprise occurs at the start of the line.  "do you need to
 * predeclare ..." is printed out for code like "sub bar; foo bar $x"
 * where the compiler doesn't know if foo is a method call or a function.
 * It prints "Missing operator before end of line" if there's nothing
 * after the missing operator, or "... before <...>" if there is something
 * after the missing operator.
 *
 * PL_bufptr is expected to point to the start of the thing that was found,
 * and s after the next token or partial token.
 */

STATIC void
S_no_op(pTHX_ const char *const what, char *s)
{
    char * const oldbp = PL_bufptr;
    const bool is_first = (PL_oldbufptr == PL_linestart);

    PERL_ARGS_ASSERT_NO_OP;

    if (!s)
	s = oldbp;
    else
	PL_bufptr = s;
    yywarn(Perl_form(aTHX_ "%s found where operator expected", what), UTF ? SVf_UTF8 : 0);
    if (ckWARN_d(WARN_SYNTAX)) {
	if (is_first)
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		    "\t(Missing semicolon on previous line?)\n");
	else if (PL_oldoldbufptr && isIDFIRST_lazy_if(PL_oldoldbufptr,UTF)) {
	    const char *t;
	    for (t = PL_oldoldbufptr; (isWORDCHAR_lazy_if(t,UTF) || *t == ':');
                                                            t += UTF ? UTF8SKIP(t) : 1)
		NOOP;
	    if (t < PL_bufptr && isSPACE(*t))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"\t(Do you need to predeclare %"UTF8f"?)\n",
		      UTF8fARG(UTF, t - PL_oldoldbufptr, PL_oldoldbufptr));
	}
	else {
	    assert(s >= oldbp);
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		    "\t(Missing operator before %"UTF8f"?)\n",
		     UTF8fARG(UTF, s - oldbp, oldbp));
	}
    }
    PL_bufptr = oldbp;
}

/*
 * S_missingterm
 * Complain about missing quote/regexp/heredoc terminator.
 * If it's called with NULL then it cauterizes the line buffer.
 * If we're in a delimited string and the delimiter is a control
 * character, it's reformatted into a two-char sequence like ^C.
 * This is fatal.
 */

STATIC void
S_missingterm(pTHX_ char *s)
{
    char tmpbuf[3];
    char q;
    if (s) {
	char * const nl = strrchr(s,'\n');
	if (nl)
	    *nl = '\0';
    }
    else if ((U8) PL_multi_close < 32) {
	*tmpbuf = '^';
	tmpbuf[1] = (char)toCTRL(PL_multi_close);
	tmpbuf[2] = '\0';
	s = tmpbuf;
    }
    else {
	*tmpbuf = (char)PL_multi_close;
	tmpbuf[1] = '\0';
	s = tmpbuf;
    }
    q = strchr(s,'"') ? '\'' : '"';
    Perl_croak(aTHX_ "Can't find string terminator %c%s%c anywhere before EOF",q,s,q);
}

#include "feature.h"

/*
 * Check whether the named feature is enabled.
 */
bool
Perl_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen)
{
    char he_name[8 + MAX_FEATURE_LEN] = "feature_";

    PERL_ARGS_ASSERT_FEATURE_IS_ENABLED;

    assert(CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM);

    if (namelen > MAX_FEATURE_LEN)
	return FALSE;
    memcpy(&he_name[8], name, namelen);

    return cBOOL(cop_hints_fetch_pvn(PL_curcop, he_name, 8 + namelen, 0,
				     REFCOUNTED_HE_EXISTS));
}

/*
 * experimental text filters for win32 carriage-returns, utf16-to-utf8 and
 * utf16-to-utf8-reversed.
 */

#ifdef PERL_CR_FILTER
static void
strip_return(SV *sv)
{
    const char *s = SvPVX_const(sv);
    const char * const e = s + SvCUR(sv);

    PERL_ARGS_ASSERT_STRIP_RETURN;

    /* outer loop optimized to do nothing if there are no CR-LFs */
    while (s < e) {
	if (*s++ == '\r' && *s == '\n') {
	    /* hit a CR-LF, need to copy the rest */
	    char *d = s - 1;
	    *d++ = *s++;
	    while (s < e) {
		if (*s == '\r' && s[1] == '\n')
		    s++;
		*d++ = *s++;
	    }
	    SvCUR(sv) -= s - d;
	    return;
	}
    }
}

STATIC I32
S_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen)
{
    const I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count > 0 && !maxlen)
	strip_return(sv);
    return count;
}
#endif

/*
=for apidoc Amx|void|lex_start|SV *line|PerlIO *rsfp|U32 flags

Creates and initialises a new lexer/parser state object, supplying
a context in which to lex and parse from a new source of Perl code.
A pointer to the new state object is placed in L</PL_parser>.  An entry
is made on the save stack so that upon unwinding the new state object
will be destroyed and the former value of L</PL_parser> will be restored.
Nothing else need be done to clean up the parsing context.

The code to be parsed comes from C<line> and C<rsfp>.  C<line>, if
non-null, provides a string (in SV form) containing code to be parsed.
A copy of the string is made, so subsequent modification of C<line>
does not affect parsing.  C<rsfp>, if non-null, provides an input stream
from which code will be read to be parsed.  If both are non-null, the
code in C<line> comes first and must consist of complete lines of input,
and C<rsfp> supplies the remainder of the source.

The C<flags> parameter is reserved for future use.  Currently it is only
used by perl internally, so extensions should always pass zero.

=cut
*/

/* LEX_START_SAME_FILTER indicates that this is not a new file, so it
   can share filters with the current parser.
   LEX_START_DONT_CLOSE indicates that the file handle wasn't opened by the
   caller, hence isn't owned by the parser, so shouldn't be closed on parser
   destruction. This is used to handle the case of defaulting to reading the
   script from the standard input because no filename was given on the command
   line (without getting confused by situation where STDIN has been closed, so
   the script handle is opened on fd 0)  */

void
Perl_lex_start(pTHX_ SV *line, PerlIO *rsfp, U32 flags)
{
    const char *s = NULL;
    yy_parser *parser, *oparser;
    if (flags && flags & ~LEX_START_FLAGS)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_start");

    /* create and initialise a parser */

    Newxz(parser, 1, yy_parser);
    parser->old_parser = oparser = PL_parser;
    PL_parser = parser;

    parser->stack = NULL;
    parser->ps = NULL;
    parser->stack_size = 0;

    /* on scope exit, free this parser and restore any outer one */
    SAVEPARSER(parser);
    parser->saved_curcop = PL_curcop;

    /* initialise lexer state */

    parser->nexttoke = 0;
    parser->error_count = oparser ? oparser->error_count : 0;
    parser->copline = parser->preambling = NOLINE;
    parser->lex_state = LEX_NORMAL;
    parser->expect = XSTATE;
    parser->rsfp = rsfp;
    parser->rsfp_filters =
      !(flags & LEX_START_SAME_FILTER) || !oparser
        ? NULL
        : MUTABLE_AV(SvREFCNT_inc(
            oparser->rsfp_filters
             ? oparser->rsfp_filters
             : (oparser->rsfp_filters = newAV())
          ));

    Newx(parser->lex_brackstack, 120, char);
    Newx(parser->lex_casestack, 12, char);
    *parser->lex_casestack = '\0';
    Newxz(parser->lex_shared, 1, LEXSHARED);

    if (line) {
	STRLEN len;
	s = SvPV_const(line, len);
	parser->linestr = flags & LEX_START_COPIED
			    ? SvREFCNT_inc_simple_NN(line)
			    : newSVpvn_flags(s, len, SvUTF8(line));
	sv_catpvn(parser->linestr, "\n;", rsfp ? 1 : 2);
    } else {
	parser->linestr = newSVpvn("\n;", rsfp ? 1 : 2);
    }
    parser->oldoldbufptr =
	parser->oldbufptr =
	parser->bufptr =
	parser->linestart = SvPVX(parser->linestr);
    parser->bufend = parser->bufptr + SvCUR(parser->linestr);
    parser->last_lop = parser->last_uni = NULL;

    STATIC_ASSERT_STMT(FITS_IN_8_BITS(LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
                                                        |LEX_DONT_CLOSE_RSFP));
    parser->lex_flags = (U8) (flags & (LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
                                                        |LEX_DONT_CLOSE_RSFP));

    parser->in_pod = parser->filtered = 0;
}


/* delete a parser object */

void
Perl_parser_free(pTHX_  const yy_parser *parser)
{
    PERL_ARGS_ASSERT_PARSER_FREE;

    PL_curcop = parser->saved_curcop;
    SvREFCNT_dec(parser->linestr);

    if (PL_parser->lex_flags & LEX_DONT_CLOSE_RSFP)
	PerlIO_clearerr(parser->rsfp);
    else if (parser->rsfp && (!parser->old_parser
          || (parser->old_parser && parser->rsfp != parser->old_parser->rsfp)))
	PerlIO_close(parser->rsfp);
    SvREFCNT_dec(parser->rsfp_filters);
    SvREFCNT_dec(parser->lex_stuff);
    SvREFCNT_dec(parser->sublex_info.repl);

    Safefree(parser->lex_brackstack);
    Safefree(parser->lex_casestack);
    Safefree(parser->lex_shared);
    PL_parser = parser->old_parser;
    Safefree(parser);
}

void
Perl_parser_free_nexttoke_ops(pTHX_  yy_parser *parser, OPSLAB *slab)
{
    I32 nexttoke = parser->nexttoke;
    PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS;
    while (nexttoke--) {
	if (S_is_opval_token(parser->nexttype[nexttoke] & 0xffff)
	 && parser->nextval[nexttoke].opval
	 && parser->nextval[nexttoke].opval->op_slabbed
	 && OpSLAB(parser->nextval[nexttoke].opval) == slab) {
	    op_free(parser->nextval[nexttoke].opval);
	    parser->nextval[nexttoke].opval = NULL;
	}
    }
}


/*
=for apidoc AmxU|SV *|PL_parser-E<gt>linestr

Buffer scalar containing the chunk currently under consideration of the
text currently being lexed.  This is always a plain string scalar (for
which C<SvPOK> is true).  It is not intended to be used as a scalar by
normal scalar means; instead refer to the buffer directly by the pointer
variables described below.

The lexer maintains various C<char*> pointers to things in the
C<PL_parser-E<gt>linestr> buffer.  If C<PL_parser-E<gt>linestr> is ever
reallocated, all of these pointers must be updated.  Don't attempt to
do this manually, but rather use L</lex_grow_linestr> if you need to
reallocate the buffer.

The content of the text chunk in the buffer is commonly exactly one
complete line of input, up to and including a newline terminator,
but there are situations where it is otherwise.  The octets of the
buffer may be intended to be interpreted as either UTF-8 or Latin-1.
The function L</lex_bufutf8> tells you which.  Do not use the C<SvUTF8>
flag on this scalar, which may disagree with it.

For direct examination of the buffer, the variable
L</PL_parser-E<gt>bufend> points to the end of the buffer.  The current
lexing position is pointed to by L</PL_parser-E<gt>bufptr>.  Direct use
of these pointers is usually preferable to examination of the scalar
through normal scalar means.

=for apidoc AmxU|char *|PL_parser-E<gt>bufend

Direct pointer to the end of the chunk of text currently being lexed, the
end of the lexer buffer.  This is equal to C<SvPVX(PL_parser-E<gt>linestr)
+ SvCUR(PL_parser-E<gt>linestr)>.  A C<NUL> character (zero octet) is
always located at the end of the buffer, and does not count as part of
the buffer's contents.

=for apidoc AmxU|char *|PL_parser-E<gt>bufptr

Points to the current position of lexing inside the lexer buffer.
Characters around this point may be freely examined, within
the range delimited by C<SvPVX(L</PL_parser-E<gt>linestr>)> and
L</PL_parser-E<gt>bufend>.  The octets of the buffer may be intended to be
interpreted as either UTF-8 or Latin-1, as indicated by L</lex_bufutf8>.

Lexing code (whether in the Perl core or not) moves this pointer past
the characters that it consumes.  It is also expected to perform some
bookkeeping whenever a newline character is consumed.  This movement
can be more conveniently performed by the function L</lex_read_to>,
which handles newlines appropriately.

Interpretation of the buffer's octets can be abstracted out by
using the slightly higher-level functions L</lex_peek_unichar> and
L</lex_read_unichar>.

=for apidoc AmxU|char *|PL_parser-E<gt>linestart

Points to the start of the current line inside the lexer buffer.
This is useful for indicating at which column an error occurred, and
not much else.  This must be updated by any lexing code that consumes
a newline; the function L</lex_read_to> handles this detail.

=cut
*/

/*
=for apidoc Amx|bool|lex_bufutf8

Indicates whether the octets in the lexer buffer
(L</PL_parser-E<gt>linestr>) should be interpreted as the UTF-8 encoding
of Unicode characters.  If not, they should be interpreted as Latin-1
characters.  This is analogous to the C<SvUTF8> flag for scalars.

In UTF-8 mode, it is not guaranteed that the lexer buffer actually
contains valid UTF-8.  Lexing code must be robust in the face of invalid
encoding.

The actual C<SvUTF8> flag of the L</PL_parser-E<gt>linestr> scalar
is significant, but not the whole story regarding the input character
encoding.  Normally, when a file is being read, the scalar contains octets
and its C<SvUTF8> flag is off, but the octets should be interpreted as
UTF-8 if the C<use utf8> pragma is in effect.  During a string eval,
however, the scalar may have the C<SvUTF8> flag on, and in this case its
octets should be interpreted as UTF-8 unless the C<use bytes> pragma
is in effect.  This logic may change in the future; use this function
instead of implementing the logic yourself.

=cut
*/

bool
Perl_lex_bufutf8(pTHX)
{
    return UTF;
}

/*
=for apidoc Amx|char *|lex_grow_linestr|STRLEN len

Reallocates the lexer buffer (L</PL_parser-E<gt>linestr>) to accommodate
at least C<len> octets (including terminating C<NUL>).  Returns a
pointer to the reallocated buffer.  This is necessary before making
any direct modification of the buffer that would increase its length.
L</lex_stuff_pvn> provides a more convenient way to insert text into
the buffer.

Do not use C<SvGROW> or C<sv_grow> directly on C<PL_parser-E<gt>linestr>;
this function updates all of the lexer's variables that point directly
into the buffer.

=cut
*/

char *
Perl_lex_grow_linestr(pTHX_ STRLEN len)
{
    SV *linestr;
    char *buf;
    STRLEN bufend_pos, bufptr_pos, oldbufptr_pos, oldoldbufptr_pos;
    STRLEN linestart_pos, last_uni_pos, last_lop_pos, re_eval_start_pos;
    linestr = PL_parser->linestr;
    buf = SvPVX(linestr);
    if (len <= SvLEN(linestr))
	return buf;
    bufend_pos = PL_parser->bufend - buf;
    bufptr_pos = PL_parser->bufptr - buf;
    oldbufptr_pos = PL_parser->oldbufptr - buf;
    oldoldbufptr_pos = PL_parser->oldoldbufptr - buf;
    linestart_pos = PL_parser->linestart - buf;
    last_uni_pos = PL_parser->last_uni ? PL_parser->last_uni - buf : 0;
    last_lop_pos = PL_parser->last_lop ? PL_parser->last_lop - buf : 0;
    re_eval_start_pos = PL_parser->lex_shared->re_eval_start ?
                            PL_parser->lex_shared->re_eval_start - buf : 0;

    buf = sv_grow(linestr, len);

    PL_parser->bufend = buf + bufend_pos;
    PL_parser->bufptr = buf + bufptr_pos;
    PL_parser->oldbufptr = buf + oldbufptr_pos;
    PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
    PL_parser->linestart = buf + linestart_pos;
    if (PL_parser->last_uni)
	PL_parser->last_uni = buf + last_uni_pos;
    if (PL_parser->last_lop)
	PL_parser->last_lop = buf + last_lop_pos;
    if (PL_parser->lex_shared->re_eval_start)
        PL_parser->lex_shared->re_eval_start  = buf + re_eval_start_pos;
    return buf;
}

/*
=for apidoc Amx|void|lex_stuff_pvn|const char *pv|STRLEN len|U32 flags

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is represented by C<len> octets starting
at C<pv>.  These octets are interpreted as either UTF-8 or Latin-1,
according to whether the C<LEX_STUFF_UTF8> flag is set in C<flags>.
The characters are recoded for the lexer buffer, according to how the
buffer is currently being interpreted (L</lex_bufutf8>).  If a string
to be inserted is available as a Perl scalar, the L</lex_stuff_sv>
function is more convenient.

=cut
*/

void
Perl_lex_stuff_pvn(pTHX_ const char *pv, STRLEN len, U32 flags)
{
    dVAR;
    char *bufptr;
    PERL_ARGS_ASSERT_LEX_STUFF_PVN;
    if (flags & ~(LEX_STUFF_UTF8))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_stuff_pvn");
    if (UTF) {
	if (flags & LEX_STUFF_UTF8) {
	    goto plain_copy;
	} else {
	    STRLEN highhalf = 0;    /* Count of variants */
	    const char *p, *e = pv+len;
	    for (p = pv; p != e; p++) {
		if (! UTF8_IS_INVARIANT(*p)) {
                    highhalf++;
                }
            }
	    if (!highhalf)
		goto plain_copy;
	    lex_grow_linestr(SvCUR(PL_parser->linestr)+1+len+highhalf);
	    bufptr = PL_parser->bufptr;
	    Move(bufptr, bufptr+len+highhalf, PL_parser->bufend+1-bufptr, char);
	    SvCUR_set(PL_parser->linestr,
	    	SvCUR(PL_parser->linestr) + len+highhalf);
	    PL_parser->bufend += len+highhalf;
	    for (p = pv; p != e; p++) {
		U8 c = (U8)*p;
		if (! UTF8_IS_INVARIANT(c)) {
		    *bufptr++ = UTF8_TWO_BYTE_HI(c);
		    *bufptr++ = UTF8_TWO_BYTE_LO(c);
		} else {
		    *bufptr++ = (char)c;
		}
	    }
	}
    } else {
	if (flags & LEX_STUFF_UTF8) {
	    STRLEN highhalf = 0;
	    const char *p, *e = pv+len;
	    for (p = pv; p != e; p++) {
		U8 c = (U8)*p;
		if (UTF8_IS_ABOVE_LATIN1(c)) {
		    Perl_croak(aTHX_ "Lexing code attempted to stuff "
				"non-Latin-1 character into Latin-1 input");
		} else if (UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(p, e)) {
		    p++;
		    highhalf++;
		} else if (! UTF8_IS_INVARIANT(c)) {
		    /* malformed UTF-8 */
		    ENTER;
		    SAVESPTR(PL_warnhook);
		    PL_warnhook = PERL_WARNHOOK_FATAL;
		    utf8n_to_uvchr((U8*)p, e-p, NULL, 0);
		    LEAVE;
		}
	    }
	    if (!highhalf)
		goto plain_copy;
	    lex_grow_linestr(SvCUR(PL_parser->linestr)+1+len-highhalf);
	    bufptr = PL_parser->bufptr;
	    Move(bufptr, bufptr+len-highhalf, PL_parser->bufend+1-bufptr, char);
	    SvCUR_set(PL_parser->linestr,
	    	SvCUR(PL_parser->linestr) + len-highhalf);
	    PL_parser->bufend += len-highhalf;
	    p = pv;
	    while (p < e) {
		if (UTF8_IS_INVARIANT(*p)) {
		    *bufptr++ = *p;
                    p++;
		}
		else {
                    assert(p < e -1 );
		    *bufptr++ = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
		    p += 2;
                }
	    }
	} else {
	  plain_copy:
	    lex_grow_linestr(SvCUR(PL_parser->linestr)+1+len);
	    bufptr = PL_parser->bufptr;
	    Move(bufptr, bufptr+len, PL_parser->bufend+1-bufptr, char);
	    SvCUR_set(PL_parser->linestr, SvCUR(PL_parser->linestr) + len);
	    PL_parser->bufend += len;
	    Copy(pv, bufptr, len, char);
	}
    }
}

/*
=for apidoc Amx|void|lex_stuff_pv|const char *pv|U32 flags

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is represented by octets starting at C<pv>
and continuing to the first nul.  These octets are interpreted as either
UTF-8 or Latin-1, according to whether the C<LEX_STUFF_UTF8> flag is set
in C<flags>.  The characters are recoded for the lexer buffer, according
to how the buffer is currently being interpreted (L</lex_bufutf8>).
If it is not convenient to nul-terminate a string to be inserted, the
L</lex_stuff_pvn> function is more appropriate.

=cut
*/

void
Perl_lex_stuff_pv(pTHX_ const char *pv, U32 flags)
{
    PERL_ARGS_ASSERT_LEX_STUFF_PV;
    lex_stuff_pvn(pv, strlen(pv), flags);
}

/*
=for apidoc Amx|void|lex_stuff_sv|SV *sv|U32 flags

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is the string value of C<sv>.  The characters
are recoded for the lexer buffer, according to how the buffer is currently
being interpreted (L</lex_bufutf8>).  If a string to be inserted is
not already a Perl scalar, the L</lex_stuff_pvn> function avoids the
need to construct a scalar.

=cut
*/

void
Perl_lex_stuff_sv(pTHX_ SV *sv, U32 flags)
{
    char *pv;
    STRLEN len;
    PERL_ARGS_ASSERT_LEX_STUFF_SV;
    if (flags)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_stuff_sv");
    pv = SvPV(sv, len);
    lex_stuff_pvn(pv, len, flags | (SvUTF8(sv) ? LEX_STUFF_UTF8 : 0));
}

/*
=for apidoc Amx|void|lex_unstuff|char *ptr

Discards text about to be lexed, from L</PL_parser-E<gt>bufptr> up to
C<ptr>.  Text following C<ptr> will be moved, and the buffer shortened.
This hides the discarded text from any lexing code that runs later,
as if the text had never appeared.

This is not the normal way to consume lexed text.  For that, use
L</lex_read_to>.

=cut
*/

void
Perl_lex_unstuff(pTHX_ char *ptr)
{
    char *buf, *bufend;
    STRLEN unstuff_len;
    PERL_ARGS_ASSERT_LEX_UNSTUFF;
    buf = PL_parser->bufptr;
    if (ptr < buf)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_unstuff");
    if (ptr == buf)
	return;
    bufend = PL_parser->bufend;
    if (ptr > bufend)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_unstuff");
    unstuff_len = ptr - buf;
    Move(ptr, buf, bufend+1-ptr, char);
    SvCUR_set(PL_parser->linestr, SvCUR(PL_parser->linestr) - unstuff_len);
    PL_parser->bufend = bufend - unstuff_len;
}

/*
=for apidoc Amx|void|lex_read_to|char *ptr

Consume text in the lexer buffer, from L</PL_parser-E<gt>bufptr> up
to C<ptr>.  This advances L</PL_parser-E<gt>bufptr> to match C<ptr>,
performing the correct bookkeeping whenever a newline character is passed.
This is the normal way to consume lexed text.

Interpretation of the buffer's octets can be abstracted out by
using the slightly higher-level functions L</lex_peek_unichar> and
L</lex_read_unichar>.

=cut
*/

void
Perl_lex_read_to(pTHX_ char *ptr)
{
    char *s;
    PERL_ARGS_ASSERT_LEX_READ_TO;
    s = PL_parser->bufptr;
    if (ptr < s || ptr > PL_parser->bufend)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_read_to");
    for (; s != ptr; s++)
	if (*s == '\n') {
	    COPLINE_INC_WITH_HERELINES;
	    PL_parser->linestart = s+1;
	}
    PL_parser->bufptr = ptr;
}

/*
=for apidoc Amx|void|lex_discard_to|char *ptr

Discards the first part of the L</PL_parser-E<gt>linestr> buffer,
up to C<ptr>.  The remaining content of the buffer will be moved, and
all pointers into the buffer updated appropriately.  C<ptr> must not
be later in the buffer than the position of L</PL_parser-E<gt>bufptr>:
it is not permitted to discard text that has yet to be lexed.

Normally it is not necessarily to do this directly, because it suffices to
use the implicit discarding behaviour of L</lex_next_chunk> and things
based on it.  However, if a token stretches across multiple lines,
and the lexing code has kept multiple lines of text in the buffer for
that purpose, then after completion of the token it would be wise to
explicitly discard the now-unneeded earlier lines, to avoid future
multi-line tokens growing the buffer without bound.

=cut
*/

void
Perl_lex_discard_to(pTHX_ char *ptr)
{
    char *buf;
    STRLEN discard_len;
    PERL_ARGS_ASSERT_LEX_DISCARD_TO;
    buf = SvPVX(PL_parser->linestr);
    if (ptr < buf)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_discard_to");
    if (ptr == buf)
	return;
    if (ptr > PL_parser->bufptr)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_discard_to");
    discard_len = ptr - buf;
    if (PL_parser->oldbufptr < ptr)
	PL_parser->oldbufptr = ptr;
    if (PL_parser->oldoldbufptr < ptr)
	PL_parser->oldoldbufptr = ptr;
    if (PL_parser->last_uni && PL_parser->last_uni < ptr)
	PL_parser->last_uni = NULL;
    if (PL_parser->last_lop && PL_parser->last_lop < ptr)
	PL_parser->last_lop = NULL;
    Move(ptr, buf, PL_parser->bufend+1-ptr, char);
    SvCUR_set(PL_parser->linestr, SvCUR(PL_parser->linestr) - discard_len);
    PL_parser->bufend -= discard_len;
    PL_parser->bufptr -= discard_len;
    PL_parser->oldbufptr -= discard_len;
    PL_parser->oldoldbufptr -= discard_len;
    if (PL_parser->last_uni)
	PL_parser->last_uni -= discard_len;
    if (PL_parser->last_lop)
	PL_parser->last_lop -= discard_len;
}

/*
=for apidoc Amx|bool|lex_next_chunk|U32 flags

Reads in the next chunk of text to be lexed, appending it to
L</PL_parser-E<gt>linestr>.  This should be called when lexing code has
looked to the end of the current chunk and wants to know more.  It is
usual, but not necessary, for lexing to have consumed the entirety of
the current chunk at this time.

If L</PL_parser-E<gt>bufptr> is pointing to the very end of the current
chunk (i.e., the current chunk has been entirely consumed), normally the
current chunk will be discarded at the same time that the new chunk is
read in.  If C<flags> has the C<LEX_KEEP_PREVIOUS> bit set, the current chunk
will not be discarded.  If the current chunk has not been entirely
consumed, then it will not be discarded regardless of the flag.

Returns true if some new text was added to the buffer, or false if the
buffer has reached the end of the input text.

=cut
*/

#define LEX_FAKE_EOF 0x80000000
#define LEX_NO_TERM  0x40000000 /* here-doc */

bool
Perl_lex_next_chunk(pTHX_ U32 flags)
{
    SV *linestr;
    char *buf;
    STRLEN old_bufend_pos, new_bufend_pos;
    STRLEN bufptr_pos, oldbufptr_pos, oldoldbufptr_pos;
    STRLEN linestart_pos, last_uni_pos, last_lop_pos;
    bool got_some_for_debugger = 0;
    bool got_some;
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_FAKE_EOF|LEX_NO_TERM))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_next_chunk");
    if (!(flags & LEX_NO_TERM) && PL_lex_inwhat)
	return FALSE;
    linestr = PL_parser->linestr;
    buf = SvPVX(linestr);
    if (!(flags & LEX_KEEP_PREVIOUS)
          && PL_parser->bufptr == PL_parser->bufend)
    {
	old_bufend_pos = bufptr_pos = oldbufptr_pos = oldoldbufptr_pos = 0;
	linestart_pos = 0;
	if (PL_parser->last_uni != PL_parser->bufend)
	    PL_parser->last_uni = NULL;
	if (PL_parser->last_lop != PL_parser->bufend)
	    PL_parser->last_lop = NULL;
	last_uni_pos = last_lop_pos = 0;
	*buf = 0;
	SvCUR(linestr) = 0;
    } else {
	old_bufend_pos = PL_parser->bufend - buf;
	bufptr_pos = PL_parser->bufptr - buf;
	oldbufptr_pos = PL_parser->oldbufptr - buf;
	oldoldbufptr_pos = PL_parser->oldoldbufptr - buf;
	linestart_pos = PL_parser->linestart - buf;
	last_uni_pos = PL_parser->last_uni ? PL_parser->last_uni - buf : 0;
	last_lop_pos = PL_parser->last_lop ? PL_parser->last_lop - buf : 0;
    }
    if (flags & LEX_FAKE_EOF) {
	goto eof;
    } else if (!PL_parser->rsfp && !PL_parser->filtered) {
	got_some = 0;
    } else if (filter_gets(linestr, old_bufend_pos)) {
	got_some = 1;
	got_some_for_debugger = 1;
    } else if (flags & LEX_NO_TERM) {
	got_some = 0;
    } else {
	if (!SvPOK(linestr))   /* can get undefined by filter_gets */
	    sv_setpvs(linestr, "");
	eof:
	/* End of real input.  Close filehandle (unless it was STDIN),
	 * then add implicit termination.
	 */
	if (PL_parser->lex_flags & LEX_DONT_CLOSE_RSFP)
	    PerlIO_clearerr(PL_parser->rsfp);
	else if (PL_parser->rsfp)
	    (void)PerlIO_close(PL_parser->rsfp);
	PL_parser->rsfp = NULL;
	PL_parser->in_pod = PL_parser->filtered = 0;
	if (!PL_in_eval && PL_minus_p) {
	    sv_catpvs(linestr,
		/*{*/";}continue{print or die qq(-p destination: $!\\n);}");
	    PL_minus_n = PL_minus_p = 0;
	} else if (!PL_in_eval && PL_minus_n) {
	    sv_catpvs(linestr, /*{*/";}");
	    PL_minus_n = 0;
	} else
	    sv_catpvs(linestr, ";");
	got_some = 1;
    }
    buf = SvPVX(linestr);
    new_bufend_pos = SvCUR(linestr);
    PL_parser->bufend = buf + new_bufend_pos;
    PL_parser->bufptr = buf + bufptr_pos;
    PL_parser->oldbufptr = buf + oldbufptr_pos;
    PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
    PL_parser->linestart = buf + linestart_pos;
    if (PL_parser->last_uni)
	PL_parser->last_uni = buf + last_uni_pos;
    if (PL_parser->last_lop)
	PL_parser->last_lop = buf + last_lop_pos;
    if (PL_parser->preambling != NOLINE) {
	CopLINE_set(PL_curcop, PL_parser->preambling + 1);
	PL_parser->preambling = NOLINE;
    }
    if (   got_some_for_debugger
        && PERLDB_LINE_OR_SAVESRC
        && PL_curstash != PL_debstash)
    {
	/* debugger active and we're not compiling the debugger code,
	 * so store the line into the debugger's array of lines
	 */
	update_debugger_info(NULL, buf+old_bufend_pos,
	    new_bufend_pos-old_bufend_pos);
    }
    return got_some;
}

/*
=for apidoc Amx|I32|lex_peek_unichar|U32 flags

Looks ahead one (Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the next character,
or -1 if lexing has reached the end of the input text.  To consume the
peeked character, use L</lex_read_unichar>.

If the next character is in (or extends into) the next chunk of input
text, the next chunk will be read in.  Normally the current chunk will be
discarded at the same time, but if C<flags> has the C<LEX_KEEP_PREVIOUS>
bit set, then the current chunk will not be discarded.

If the input is being interpreted as UTF-8 and a UTF-8 encoding error
is encountered, an exception is generated.

=cut
*/

I32
Perl_lex_peek_unichar(pTHX_ U32 flags)
{
    dVAR;
    char *s, *bufend;
    if (flags & ~(LEX_KEEP_PREVIOUS))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_peek_unichar");
    s = PL_parser->bufptr;
    bufend = PL_parser->bufend;
    if (UTF) {
	U8 head;
	I32 unichar;
	STRLEN len, retlen;
	if (s == bufend) {
	    if (!lex_next_chunk(flags))
		return -1;
	    s = PL_parser->bufptr;
	    bufend = PL_parser->bufend;
	}
	head = (U8)*s;
	if (UTF8_IS_INVARIANT(head))
	    return head;
	if (UTF8_IS_START(head)) {
	    len = UTF8SKIP(&head);
	    while ((STRLEN)(bufend-s) < len) {
		if (!lex_next_chunk(flags | LEX_KEEP_PREVIOUS))
		    break;
		s = PL_parser->bufptr;
		bufend = PL_parser->bufend;
	    }
	}
	unichar = utf8n_to_uvchr((U8*)s, bufend-s, &retlen, UTF8_CHECK_ONLY);
	if (retlen == (STRLEN)-1) {
	    /* malformed UTF-8 */
	    ENTER;
	    SAVESPTR(PL_warnhook);
	    PL_warnhook = PERL_WARNHOOK_FATAL;
	    utf8n_to_uvchr((U8*)s, bufend-s, NULL, 0);
	    LEAVE;
	}
	return unichar;
    } else {
	if (s == bufend) {
	    if (!lex_next_chunk(flags))
		return -1;
	    s = PL_parser->bufptr;
	}
	return (U8)*s;
    }
}

/*
=for apidoc Amx|I32|lex_read_unichar|U32 flags

Reads the next (Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the character read,
and moves L</PL_parser-E<gt>bufptr> past the character, or returns -1
if lexing has reached the end of the input text.  To non-destructively
examine the next character, use L</lex_peek_unichar> instead.

If the next character is in (or extends into) the next chunk of input
text, the next chunk will be read in.  Normally the current chunk will be
discarded at the same time, but if C<flags> has the C<LEX_KEEP_PREVIOUS>
bit set, then the current chunk will not be discarded.

If the input is being interpreted as UTF-8 and a UTF-8 encoding error
is encountered, an exception is generated.

=cut
*/

I32
Perl_lex_read_unichar(pTHX_ U32 flags)
{
    I32 c;
    if (flags & ~(LEX_KEEP_PREVIOUS))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_read_unichar");
    c = lex_peek_unichar(flags);
    if (c != -1) {
	if (c == '\n')
	    COPLINE_INC_WITH_HERELINES;
	if (UTF)
	    PL_parser->bufptr += UTF8SKIP(PL_parser->bufptr);
	else
	    ++(PL_parser->bufptr);
    }
    return c;
}

/*
=for apidoc Amx|void|lex_read_space|U32 flags

Reads optional spaces, in Perl style, in the text currently being
lexed.  The spaces may include ordinary whitespace characters and
Perl-style comments.  C<#line> directives are processed if encountered.
L</PL_parser-E<gt>bufptr> is moved past the spaces, so that it points
at a non-space character (or the end of the input text).

If spaces extend into the next chunk of input text, the next chunk will
be read in.  Normally the current chunk will be discarded at the same
time, but if C<flags> has the C<LEX_KEEP_PREVIOUS> bit set, then the current
chunk will not be discarded.

=cut
*/

#define LEX_NO_INCLINE    0x40000000
#define LEX_NO_NEXT_CHUNK 0x80000000

void
Perl_lex_read_space(pTHX_ U32 flags)
{
    char *s, *bufend;
    const bool can_incline = !(flags & LEX_NO_INCLINE);
    bool need_incline = 0;
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_NO_NEXT_CHUNK|LEX_NO_INCLINE))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_read_space");
    s = PL_parser->bufptr;
    bufend = PL_parser->bufend;
    while (1) {
	char c = *s;
	if (c == '#') {
	    do {
		c = *++s;
	    } while (!(c == '\n' || (c == 0 && s == bufend)));
	} else if (c == '\n') {
	    s++;
	    if (can_incline) {
		PL_parser->linestart = s;
		if (s == bufend)
		    need_incline = 1;
		else
		    incline(s);
	    }
	} else if (isSPACE(c)) {
	    s++;
	} else if (c == 0 && s == bufend) {
	    bool got_more;
	    line_t l;
	    if (flags & LEX_NO_NEXT_CHUNK)
		break;
	    PL_parser->bufptr = s;
	    l = CopLINE(PL_curcop);
	    CopLINE(PL_curcop) += PL_parser->herelines + 1;
	    got_more = lex_next_chunk(flags);
	    CopLINE_set(PL_curcop, l);
	    s = PL_parser->bufptr;
	    bufend = PL_parser->bufend;
	    if (!got_more)
		break;
	    if (can_incline && need_incline && PL_parser->rsfp) {
		incline(s);
		need_incline = 0;
	    }
	} else if (!c) {
	    s++;
	} else {
	    break;
	}
    }
    PL_parser->bufptr = s;
}

/*

=for apidoc EXMp|bool|validate_proto|SV *name|SV *proto|bool warn

This function performs syntax checking on a prototype, C<proto>.
If C<warn> is true, any illegal characters or mismatched brackets
will trigger illegalproto warnings, declaring that they were
detected in the prototype for C<name>.

The return value is C<true> if this is a valid prototype, and
C<false> if it is not, regardless of whether C<warn> was C<true> or
C<false>.

Note that C<NULL> is a valid C<proto> and will always return C<true>.

=cut

 */

bool
Perl_validate_proto(pTHX_ SV *name, SV *proto, bool warn)
{
    STRLEN len, origlen;
    char *p = proto ? SvPV(proto, len) : NULL;
    bool bad_proto = FALSE;
    bool in_brackets = FALSE;
    bool after_slash = FALSE;
    char greedy_proto = ' ';
    bool proto_after_greedy_proto = FALSE;
    bool must_be_last = FALSE;
    bool underscore = FALSE;
    bool bad_proto_after_underscore = FALSE;

    PERL_ARGS_ASSERT_VALIDATE_PROTO;

    if (!proto)
	return TRUE;

    origlen = len;
    for (; len--; p++) {
	if (!isSPACE(*p)) {
	    if (must_be_last)
		proto_after_greedy_proto = TRUE;
	    if (underscore) {
		if (!strchr(";@@%", *p))
		    bad_proto_after_underscore = TRUE;
		underscore = FALSE;
	    }
	    if (!strchr("$@@%*;[]&\\_+", *p) || *p == '\0') {
		bad_proto = TRUE;
	    }
	    else {
		if (*p == '[')
		    in_brackets = TRUE;
		else if (*p == ']')
		    in_brackets = FALSE;
		else if ((*p == '@@' || *p == '%')
                         && !after_slash
                         && !in_brackets )
                {
		    must_be_last = TRUE;
		    greedy_proto = *p;
		}
		else if (*p == '_')
		    underscore = TRUE;
	    }
	    if (*p == '\\')
		after_slash = TRUE;
	    else
		after_slash = FALSE;
	}
    }

    if (warn) {
	SV *tmpsv = newSVpvs_flags("", SVs_TEMP);
	p -= origlen;
	p = SvUTF8(proto)
	    ? sv_uni_display(tmpsv, newSVpvn_flags(p, origlen, SVs_TEMP | SVf_UTF8),
	                     origlen, UNI_DISPLAY_ISPRINT)
	    : pv_pretty(tmpsv, p, origlen, 60, NULL, NULL, PERL_PV_ESCAPE_NONASCII);

	if (proto_after_greedy_proto)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Prototype after '%c' for %"SVf" : %s",
			greedy_proto, SVfARG(name), p);
	if (in_brackets)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Missing ']' in prototype for %"SVf" : %s",
			SVfARG(name), p);
	if (bad_proto)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Illegal character in prototype for %"SVf" : %s",
			SVfARG(name), p);
	if (bad_proto_after_underscore)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Illegal character after '_' in prototype for %"SVf" : %s",
			SVfARG(name), p);
    }

    return (! (proto_after_greedy_proto || bad_proto) );
}

/*
 * S_incline
 * This subroutine has nothing to do with tilting, whether at windmills
 * or pinball tables.  Its name is short for "increment line".  It
 * increments the current line number in CopLINE(PL_curcop) and checks
 * to see whether the line starts with a comment of the form
 *    # line 500 "foo.pm"
 * If so, it sets the current line number and file to the values in the comment.
 */

STATIC void
S_incline(pTHX_ const char *s)
{
    const char *t;
    const char *n;
    const char *e;
    line_t line_num;
    UV uv;

    PERL_ARGS_ASSERT_INCLINE;

    COPLINE_INC_WITH_HERELINES;
    if (!PL_rsfp && !PL_parser->filtered && PL_lex_state == LEX_NORMAL
     && s+1 == PL_bufend && *s == ';') {
	/* fake newline in string eval */
	CopLINE_dec(PL_curcop);
	return;
    }
    if (*s++ != '#')
	return;
    while (SPACE_OR_TAB(*s))
	s++;
    if (strnEQ(s, "line", 4))
	s += 4;
    else
	return;
    if (SPACE_OR_TAB(*s))
	s++;
    else
	return;
    while (SPACE_OR_TAB(*s))
	s++;
    if (!isDIGIT(*s))
	return;

    n = s;
    while (isDIGIT(*s))
	s++;
    if (!SPACE_OR_TAB(*s) && *s != '\r' && *s != '\n' && *s != '\0')
	return;
    while (SPACE_OR_TAB(*s))
	s++;
    if (*s == '"' && (t = strchr(s+1, '"'))) {
	s++;
	e = t + 1;
    }
    else {
	t = s;
	while (*t && !isSPACE(*t))
	    t++;
	e = t;
    }
    while (SPACE_OR_TAB(*e) || *e == '\r' || *e == '\f')
	e++;
    if (*e != '\n' && *e != '\0')
	return;		/* false alarm */

    if (!grok_atoUV(n, &uv, &e))
        return;
    line_num = ((line_t)uv) - 1;

    if (t - s > 0) {
	const STRLEN len = t - s;

	if (!PL_rsfp && !PL_parser->filtered) {
	    /* must copy *{"::_<(eval N)[oldfilename:L]"}
	     * to *{"::_<newfilename"} */
	    /* However, the long form of evals is only turned on by the
	       debugger - usually they're "(eval %lu)" */
	    GV * const cfgv = CopFILEGV(PL_curcop);
	    if (cfgv) {
		char smallbuf[128];
		STRLEN tmplen2 = len;
		char *tmpbuf2;
		GV *gv2;

		if (tmplen2 + 2 <= sizeof smallbuf)
		    tmpbuf2 = smallbuf;
		else
		    Newx(tmpbuf2, tmplen2 + 2, char);

		tmpbuf2[0] = '_';
		tmpbuf2[1] = '<';

		memcpy(tmpbuf2 + 2, s, tmplen2);
		tmplen2 += 2;

		gv2 = *(GV**)hv_fetch(PL_defstash, tmpbuf2, tmplen2, TRUE);
		if (!isGV(gv2)) {
		    gv_init(gv2, PL_defstash, tmpbuf2, tmplen2, FALSE);
		    /* adjust ${"::_<newfilename"} to store the new file name */
		    GvSV(gv2) = newSVpvn(tmpbuf2 + 2, tmplen2 - 2);
		    /* The line number may differ. If that is the case,
		       alias the saved lines that are in the array.
		       Otherwise alias the whole array. */
		    if (CopLINE(PL_curcop) == line_num) {
			GvHV(gv2) = MUTABLE_HV(SvREFCNT_inc(GvHV(cfgv)));
			GvAV(gv2) = MUTABLE_AV(SvREFCNT_inc(GvAV(cfgv)));
		    }
		    else if (GvAV(cfgv)) {
			AV * const av = GvAV(cfgv);
			const I32 start = CopLINE(PL_curcop)+1;
			I32 items = AvFILLp(av) - start;
			if (items > 0) {
			    AV * const av2 = GvAVn(gv2);
			    SV **svp = AvARRAY(av) + start;
			    I32 l = (I32)line_num+1;
			    while (items--)
				av_store(av2, l++, SvREFCNT_inc(*svp++));
			}
		    }
		}

		if (tmpbuf2 != smallbuf) Safefree(tmpbuf2);
	    }
	}
	CopFILE_free(PL_curcop);
	CopFILE_setn(PL_curcop, s, len);
    }
    CopLINE_set(PL_curcop, line_num);
}

#define skipspace(s) skipspace_flags(s, 0)


STATIC void
S_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len)
{
    AV *av = CopFILEAVx(PL_curcop);
    if (av) {
	SV * sv;
	if (PL_parser->preambling == NOLINE) sv = newSV_type(SVt_PVMG);
	else {
	    sv = *av_fetch(av, 0, 1);
	    SvUPGRADE(sv, SVt_PVMG);
	}
	if (!SvPOK(sv)) sv_setpvs(sv,"");
	if (orig_sv)
	    sv_catsv(sv, orig_sv);
	else
	    sv_catpvn(sv, buf, len);
	if (!SvIOK(sv)) {
	    (void)SvIOK_on(sv);
	    SvIV_set(sv, 0);
	}
	if (PL_parser->preambling == NOLINE)
	    av_store(av, CopLINE(PL_curcop), sv);
    }
}

/*
 * S_skipspace
 * Called to gobble the appropriate amount and type of whitespace.
 * Skips comments as well.
 */

STATIC char *
S_skipspace_flags(pTHX_ char *s, U32 flags)
{
    PERL_ARGS_ASSERT_SKIPSPACE_FLAGS;
    if (PL_lex_formbrack && PL_lex_brackets <= PL_lex_formbrack) {
	while (s < PL_bufend && (SPACE_OR_TAB(*s) || !*s))
	    s++;
    } else {
	STRLEN bufptr_pos = PL_bufptr - SvPVX(PL_linestr);
	PL_bufptr = s;
	lex_read_space(flags | LEX_KEEP_PREVIOUS |
		(PL_lex_inwhat || PL_lex_state == LEX_FORMLINE ?
		    LEX_NO_NEXT_CHUNK : 0));
	s = PL_bufptr;
	PL_bufptr = SvPVX(PL_linestr) + bufptr_pos;
	if (PL_linestart > PL_bufptr)
	    PL_bufptr = PL_linestart;
	return s;
    }
    return s;
}

/*
 * S_check_uni
 * Check the unary operators to ensure there's no ambiguity in how they're
 * used.  An ambiguous piece of code would be:
 *     rand + 5
 * This doesn't mean rand() + 5.  Because rand() is a unary operator,
 * the +5 is its argument.
 */

STATIC void
S_check_uni(pTHX)
{
    const char *s;
    const char *t;

    if (PL_oldoldbufptr != PL_last_uni)
	return;
    while (isSPACE(*PL_last_uni))
	PL_last_uni++;
    s = PL_last_uni;
    while (isWORDCHAR_lazy_if(s,UTF) || *s == '-')
	s += UTF ? UTF8SKIP(s) : 1;
    if ((t = strchr(s, '(')) && t < PL_bufptr)
	return;

    Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
		     "Warning: Use of \"%"UTF8f"\" without parentheses is ambiguous",
		     UTF8fARG(UTF, (int)(s - PL_last_uni), PL_last_uni));
}

/*
 * LOP : macro to build a list operator.  Its behaviour has been replaced
 * with a subroutine, S_lop() for which LOP is just another name.
 */

#define LOP(f,x) return lop(f,x,s)

/*
 * S_lop
 * Build a list operator (or something that might be one).  The rules:
 *  - if we have a next token, then it's a list operator (no parens) for
 *    which the next token has already been parsed; e.g.,
 *       sort foo @@args
 *       sort foo (@@args)
 *  - if the next thing is an opening paren, then it's a function
 *  - else it's a list operator
 */

STATIC I32
S_lop(pTHX_ I32 f, int x, char *s)
{
    PERL_ARGS_ASSERT_LOP;

    pl_yylval.ival = f;
    CLINE;
    PL_bufptr = s;
    PL_last_lop = PL_oldbufptr;
    PL_last_lop_op = (OPCODE)f;
    if (PL_nexttoke)
	goto lstop;
    PL_expect = x;
    if (*s == '(')
	return REPORT(FUNC);
    s = skipspace(s);
    if (*s == '(')
	return REPORT(FUNC);
    else {
	lstop:
	if (!PL_lex_allbrackets && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
	    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
	return REPORT(LSTOP);
    }
}

/*
 * S_force_next
 * When the lexer realizes it knows the next token (for instance,
 * it is reordering tokens for the parser) then it can call S_force_next
 * to know what token to return the next time the lexer is called.  Caller
 * will need to set PL_nextval[] and possibly PL_expect to ensure
 * the lexer handles the token correctly.
 */

STATIC void
S_force_next(pTHX_ I32 type)
{
#ifdef DEBUGGING
    if (DEBUG_T_TEST) {
        PerlIO_printf(Perl_debug_log, "### forced token:\n");
	tokereport(type, &NEXTVAL_NEXTTOKE);
    }
#endif
    assert(PL_nexttoke < C_ARRAY_LENGTH(PL_nexttype));
    PL_nexttype[PL_nexttoke] = type;
    PL_nexttoke++;
    if (PL_lex_state != LEX_KNOWNEXT) {
	PL_lex_defer = PL_lex_state;
	PL_lex_state = LEX_KNOWNEXT;
    }
}

/*
 * S_postderef
 *
 * This subroutine handles postfix deref syntax after the arrow has already
 * been emitted.  @@* $* etc. are emitted as two separate token right here.
 * @@[ @@{ %[ %{ *{ are emitted also as two tokens, but this function emits
 * only the first, leaving yylex to find the next.
 */

static int
S_postderef(pTHX_ int const funny, char const next)
{
    assert(funny == DOLSHARP || strchr("$@@%&*", funny));
    assert(strchr("*[{", next));
    if (next == '*') {
	PL_expect = XOPERATOR;
	if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets) {
	    assert('@@' == funny || '$' == funny || DOLSHARP == funny);
	    PL_lex_state = LEX_INTERPEND;
	    force_next(POSTJOIN);
	}
	force_next(next);
	PL_bufptr+=2;
    }
    else {
	if ('@@' == funny && PL_lex_state == LEX_INTERPNORMAL
	 && !PL_lex_brackets)
	    PL_lex_dojoin = 2;
	PL_expect = XOPERATOR;
	PL_bufptr++;
    }
    return funny;
}

void
Perl_yyunlex(pTHX)
{
    int yyc = PL_parser->yychar;
    if (yyc != YYEMPTY) {
	if (yyc) {
	    NEXTVAL_NEXTTOKE = PL_parser->yylval;
	    if (yyc == '{'/*}*/ || yyc == HASHBRACK || yyc == '['/*]*/) {
		PL_lex_allbrackets--;
		PL_lex_brackets--;
		yyc |= (3<<24) | (PL_lex_brackstack[PL_lex_brackets] << 16);
	    } else if (yyc == '('/*)*/) {
		PL_lex_allbrackets--;
		yyc |= (2<<24);
	    }
	    force_next(yyc);
	}
	PL_parser->yychar = YYEMPTY;
    }
}

STATIC SV *
S_newSV_maybe_utf8(pTHX_ const char *const start, STRLEN len)
{
    SV * const sv = newSVpvn_utf8(start, len,
				  !IN_BYTES
				  && UTF
				  && !is_invariant_string((const U8*)start, len)
				  && is_utf8_string((const U8*)start, len));
    return sv;
}

/*
 * S_force_word
 * When the lexer knows the next thing is a word (for instance, it has
 * just seen -> and it knows that the next char is a word char, then
 * it calls S_force_word to stick the next word into the PL_nexttoke/val
 * lookahead.
 *
 * Arguments:
 *   char *start : buffer position (must be within PL_linestr)
 *   int token   : PL_next* will be this type of bare word (e.g., METHOD,WORD)
 *   int check_keyword : if true, Perl checks to make sure the word isn't
 *       a keyword (do this if the word is a label, e.g. goto FOO)
 *   int allow_pack : if true, : characters will also be allowed (require,
 *       use, etc. do this)
 */

STATIC char *
S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack)
{
    char *s;
    STRLEN len;

    PERL_ARGS_ASSERT_FORCE_WORD;

    start = skipspace(start);
    s = start;
    if (isIDFIRST_lazy_if(s,UTF)
        || (allow_pack && *s == ':') )
    {
	s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, allow_pack, &len);
	if (check_keyword) {
	  char *s2 = PL_tokenbuf;
	  STRLEN len2 = len;
	  if (allow_pack && len > 6 && strnEQ(s2, "CORE::", 6))
	    s2 += 6, len2 -= 6;
	  if (keyword(s2, len2, 0))
	    return start;
	}
	if (token == METHOD) {
	    s = skipspace(s);
	    if (*s == '(')
		PL_expect = XTERM;
	    else {
		PL_expect = XOPERATOR;
	    }
	}
	NEXTVAL_NEXTTOKE.opval
	    = (OP*)newSVOP(OP_CONST,0,
			   S_newSV_maybe_utf8(aTHX_ PL_tokenbuf, len));
	NEXTVAL_NEXTTOKE.opval->op_private |= OPpCONST_BARE;
	force_next(token);
    }
    return s;
}

/*
 * S_force_ident
 * Called when the lexer wants $foo *foo &foo etc, but the program
 * text only contains the "foo" portion.  The first argument is a pointer
 * to the "foo", and the second argument is the type symbol to prefix.
 * Forces the next token to be a "WORD".
 * Creates the symbol if it didn't already exist (via gv_fetchpv()).
 */

STATIC void
S_force_ident(pTHX_ const char *s, int kind)
{
    PERL_ARGS_ASSERT_FORCE_IDENT;

    if (s[0]) {
	const STRLEN len = s[1] ? strlen(s) : 1; /* s = "\"" see yylex */
	OP* const o = (OP*)newSVOP(OP_CONST, 0, newSVpvn_flags(s, len,
                                                                UTF ? SVf_UTF8 : 0));
	NEXTVAL_NEXTTOKE.opval = o;
	force_next(WORD);
	if (kind) {
	    o->op_private = OPpCONST_ENTERED;
	    /* XXX see note in pp_entereval() for why we forgo typo
	       warnings if the symbol must be introduced in an eval.
	       GSAR 96-10-12 */
	    gv_fetchpvn_flags(s, len,
			      (PL_in_eval ? GV_ADDMULTI
			      : GV_ADD) | ( UTF ? SVf_UTF8 : 0 ),
			      kind == '$' ? SVt_PV :
			      kind == '@@' ? SVt_PVAV :
			      kind == '%' ? SVt_PVHV :
			      SVt_PVGV
			      );
	}
    }
}

static void
S_force_ident_maybe_lex(pTHX_ char pit)
{
    NEXTVAL_NEXTTOKE.ival = pit;
    force_next('p');
}

NV
Perl_str_to_version(pTHX_ SV *sv)
{
    NV retval = 0.0;
    NV nshift = 1.0;
    STRLEN len;
    const char *start = SvPV_const(sv,len);
    const char * const end = start + len;
    const bool utf = SvUTF8(sv) ? TRUE : FALSE;

    PERL_ARGS_ASSERT_STR_TO_VERSION;

    while (start < end) {
	STRLEN skip;
	UV n;
	if (utf)
	    n = utf8n_to_uvchr((U8*)start, len, &skip, 0);
	else {
	    n = *(U8*)start;
	    skip = 1;
	}
	retval += ((NV)n)/nshift;
	start += skip;
	nshift *= 1000;
    }
    return retval;
}

/*
 * S_force_version
 * Forces the next token to be a version number.
 * If the next token appears to be an invalid version number, (e.g. "v2b"),
 * and if "guessing" is TRUE, then no new token is created (and the caller
 * must use an alternative parsing method).
 */

STATIC char *
S_force_version(pTHX_ char *s, int guessing)
{
    OP *version = NULL;
    char *d;

    PERL_ARGS_ASSERT_FORCE_VERSION;

    s = skipspace(s);

    d = s;
    if (*d == 'v')
	d++;
    if (isDIGIT(*d)) {
	while (isDIGIT(*d) || *d == '_' || *d == '.')
	    d++;
        if (*d == ';' || isSPACE(*d) || *d == '{' || *d == '}' || !*d) {
	    SV *ver;
            s = scan_num(s, &pl_yylval);
            version = pl_yylval.opval;
	    ver = cSVOPx(version)->op_sv;
	    if (SvPOK(ver) && !SvNIOK(ver)) {
		SvUPGRADE(ver, SVt_PVNV);
		SvNV_set(ver, str_to_version(ver));
		SvNOK_on(ver);		/* hint that it is a version */
	    }
        }
	else if (guessing) {
	    return s;
	}
    }

    /* NOTE: The parser sees the package name and the VERSION swapped */
    NEXTVAL_NEXTTOKE.opval = version;
    force_next(WORD);

    return s;
}

/*
 * S_force_strict_version
 * Forces the next token to be a version number using strict syntax rules.
 */

STATIC char *
S_force_strict_version(pTHX_ char *s)
{
    OP *version = NULL;
    const char *errstr = NULL;

    PERL_ARGS_ASSERT_FORCE_STRICT_VERSION;

    while (isSPACE(*s)) /* leading whitespace */
	s++;

    if (is_STRICT_VERSION(s,&errstr)) {
	SV *ver = newSV(0);
	s = (char *)scan_version(s, ver, 0);
	version = newSVOP(OP_CONST, 0, ver);
    }
    else if ((*s != ';' && *s != '{' && *s != '}' )
             && (s = skipspace(s), (*s != ';' && *s != '{' && *s != '}' )))
    {
	PL_bufptr = s;
	if (errstr)
	    yyerror(errstr); /* version required */
	return s;
    }

    /* NOTE: The parser sees the package name and the VERSION swapped */
    NEXTVAL_NEXTTOKE.opval = version;
    force_next(WORD);

    return s;
}

/*
 * S_tokeq
 * Tokenize a quoted string passed in as an SV.  It finds the next
 * chunk, up to end of string or a backslash.  It may make a new
 * SV containing that chunk (if HINT_NEW_STRING is on).  It also
 * turns \\ into \.
 */

STATIC SV *
S_tokeq(pTHX_ SV *sv)
{
    char *s;
    char *send;
    char *d;
    SV *pv = sv;

    PERL_ARGS_ASSERT_TOKEQ;

    assert (SvPOK(sv));
    assert (SvLEN(sv));
    assert (!SvIsCOW(sv));
    if (SvTYPE(sv) >= SVt_PVIV && SvIVX(sv) == -1) /* <<'heredoc' */
	goto finish;
    s = SvPVX(sv);
    send = SvEND(sv);
    /* This is relying on the SV being "well formed" with a trailing '\0'  */
    while (s < send && !(*s == '\\' && s[1] == '\\'))
	s++;
    if (s == send)
	goto finish;
    d = s;
    if ( PL_hints & HINT_NEW_STRING ) {
	pv = newSVpvn_flags(SvPVX_const(pv), SvCUR(sv),
			    SVs_TEMP | SvUTF8(sv));
    }
    while (s < send) {
	if (*s == '\\') {
	    if (s + 1 < send && (s[1] == '\\'))
		s++;		/* all that, just for this */
	}
	*d++ = *s++;
    }
    *d = '\0';
    SvCUR_set(sv, d - SvPVX_const(sv));
  finish:
    if ( PL_hints & HINT_NEW_STRING )
       return new_constant(NULL, 0, "q", sv, pv, "q", 1);
    return sv;
}

/*
 * Now come three functions related to double-quote context,
 * S_sublex_start, S_sublex_push, and S_sublex_done.  They're used when
 * converting things like "\u\Lgnat" into ucfirst(lc("gnat")).  They
 * interact with PL_lex_state, and create fake ( ... ) argument lists
 * to handle functions and concatenation.
 * For example,
 *   "foo\lbar"
 * is tokenised as
 *    stringify ( const[foo] concat lcfirst ( const[bar] ) )
 */

/*
 * S_sublex_start
 * Assumes that pl_yylval.ival is the op we're creating (e.g. OP_LCFIRST).
 *
 * Pattern matching will set PL_lex_op to the pattern-matching op to
 * make (we return THING if pl_yylval.ival is OP_NULL, PMFUNC otherwise).
 *
 * OP_CONST and OP_READLINE are easy--just make the new op and return.
 *
 * Everything else becomes a FUNC.
 *
 * Sets PL_lex_state to LEX_INTERPPUSH unless (ival was OP_NULL or we
 * had an OP_CONST or OP_READLINE).  This just sets us up for a
 * call to S_sublex_push().
 */

STATIC I32
S_sublex_start(pTHX)
{
    const I32 op_type = pl_yylval.ival;

    if (op_type == OP_NULL) {
	pl_yylval.opval = PL_lex_op;
	PL_lex_op = NULL;
	return THING;
    }
    if (op_type == OP_CONST) {
	SV *sv = PL_lex_stuff;
	PL_lex_stuff = NULL;
	sv = tokeq(sv);

	if (SvTYPE(sv) == SVt_PVIV) {
	    /* Overloaded constants, nothing fancy: Convert to SVt_PV: */
	    STRLEN len;
	    const char * const p = SvPV_const(sv, len);
	    SV * const nsv = newSVpvn_flags(p, len, SvUTF8(sv));
	    SvREFCNT_dec(sv);
	    sv = nsv;
	}
	pl_yylval.opval = (OP*)newSVOP(op_type, 0, sv);
	return THING;
    }

    PL_sublex_info.super_state = PL_lex_state;
    PL_sublex_info.sub_inwhat = (U16)op_type;
    PL_sublex_info.sub_op = PL_lex_op;
    PL_lex_state = LEX_INTERPPUSH;

    PL_expect = XTERM;
    if (PL_lex_op) {
	pl_yylval.opval = PL_lex_op;
	PL_lex_op = NULL;
	return PMFUNC;
    }
    else
	return FUNC;
}

/*
 * S_sublex_push
 * Create a new scope to save the lexing state.  The scope will be
 * ended in S_sublex_done.  Returns a '(', starting the function arguments
 * to the uc, lc, etc. found before.
 * Sets PL_lex_state to LEX_INTERPCONCAT.
 */

STATIC I32
S_sublex_push(pTHX)
{
    LEXSHARED *shared;
    const bool is_heredoc = PL_multi_close == '<';
    ENTER;

    PL_lex_state = PL_sublex_info.super_state;
    SAVEI8(PL_lex_dojoin);
    SAVEI32(PL_lex_brackets);
    SAVEI32(PL_lex_allbrackets);
    SAVEI32(PL_lex_formbrack);
    SAVEI8(PL_lex_fakeeof);
    SAVEI32(PL_lex_casemods);
    SAVEI32(PL_lex_starts);
    SAVEI8(PL_lex_state);
    SAVEI8(PL_lex_defer);
    SAVESPTR(PL_lex_repl);
    SAVEVPTR(PL_lex_inpat);
    SAVEI16(PL_lex_inwhat);
    if (is_heredoc)
    {
	SAVECOPLINE(PL_curcop);
	SAVEI32(PL_multi_end);
	SAVEI32(PL_parser->herelines);
	PL_parser->herelines = 0;
    }
    SAVEI8(PL_multi_close);
    SAVEPPTR(PL_bufptr);
    SAVEPPTR(PL_bufend);
    SAVEPPTR(PL_oldbufptr);
    SAVEPPTR(PL_oldoldbufptr);
    SAVEPPTR(PL_last_lop);
    SAVEPPTR(PL_last_uni);
    SAVEPPTR(PL_linestart);
    SAVESPTR(PL_linestr);
    SAVEGENERICPV(PL_lex_brackstack);
    SAVEGENERICPV(PL_lex_casestack);
    SAVEGENERICPV(PL_parser->lex_shared);
    SAVEBOOL(PL_parser->lex_re_reparsing);
    SAVEI32(PL_copline);

    /* The here-doc parser needs to be able to peek into outer lexing
       scopes to find the body of the here-doc.  So we put PL_linestr and
       PL_bufptr into lex_shared, to share those values.
     */
    PL_parser->lex_shared->ls_linestr = PL_linestr;
    PL_parser->lex_shared->ls_bufptr  = PL_bufptr;

    PL_linestr = PL_lex_stuff;
    PL_lex_repl = PL_sublex_info.repl;
    PL_lex_stuff = NULL;
    PL_sublex_info.repl = NULL;

    /* Arrange for PL_lex_stuff to be freed on scope exit, in case it gets
       set for an inner quote-like operator and then an error causes scope-
       popping.  We must not have a PL_lex_stuff value left dangling, as
       that breaks assumptions elsewhere.  See bug #123617.  */
    SAVEGENERICSV(PL_lex_stuff);
    SAVEGENERICSV(PL_sublex_info.repl);

    PL_bufend = PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart
	= SvPVX(PL_linestr);
    PL_bufend += SvCUR(PL_linestr);
    PL_last_lop = PL_last_uni = NULL;
    SAVEFREESV(PL_linestr);
    if (PL_lex_repl) SAVEFREESV(PL_lex_repl);

    PL_lex_dojoin = FALSE;
    PL_lex_brackets = PL_lex_formbrack = 0;
    PL_lex_allbrackets = 0;
    PL_lex_fakeeof = LEX_FAKEEOF_NEVER;
    Newx(PL_lex_brackstack, 120, char);
    Newx(PL_lex_casestack, 12, char);
    PL_lex_casemods = 0;
    *PL_lex_casestack = '\0';
    PL_lex_starts = 0;
    PL_lex_state = LEX_INTERPCONCAT;
    if (is_heredoc)
	CopLINE_set(PL_curcop, (line_t)PL_multi_start);
    PL_copline = NOLINE;
    
    Newxz(shared, 1, LEXSHARED);
    shared->ls_prev = PL_parser->lex_shared;
    PL_parser->lex_shared = shared;

    PL_lex_inwhat = PL_sublex_info.sub_inwhat;
    if (PL_lex_inwhat == OP_TRANSR) PL_lex_inwhat = OP_TRANS;
    if (PL_lex_inwhat == OP_MATCH || PL_lex_inwhat == OP_QR || PL_lex_inwhat == OP_SUBST)
	PL_lex_inpat = PL_sublex_info.sub_op;
    else
	PL_lex_inpat = NULL;

    PL_parser->lex_re_reparsing = cBOOL(PL_in_eval & EVAL_RE_REPARSING);
    PL_in_eval &= ~EVAL_RE_REPARSING;

    return '(';
}

/*
 * S_sublex_done
 * Restores lexer state after a S_sublex_push.
 */

STATIC I32
S_sublex_done(pTHX)
{
    if (!PL_lex_starts++) {
	SV * const sv = newSVpvs("");
	if (SvUTF8(PL_linestr))
	    SvUTF8_on(sv);
	PL_expect = XOPERATOR;
	pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
	return THING;
    }

    if (PL_lex_casemods) {		/* oops, we've got some unbalanced parens */
	PL_lex_state = LEX_INTERPCASEMOD;
	return yylex();
    }

    /* Is there a right-hand side to take care of? (s//RHS/ or tr//RHS/) */
    assert(PL_lex_inwhat != OP_TRANSR);
    if (PL_lex_repl) {
	assert (PL_lex_inwhat == OP_SUBST || PL_lex_inwhat == OP_TRANS);
	PL_linestr = PL_lex_repl;
	PL_lex_inpat = 0;
	PL_bufend = PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart = SvPVX(PL_linestr);
	PL_bufend += SvCUR(PL_linestr);
	PL_last_lop = PL_last_uni = NULL;
	PL_lex_dojoin = FALSE;
	PL_lex_brackets = 0;
	PL_lex_allbrackets = 0;
	PL_lex_fakeeof = LEX_FAKEEOF_NEVER;
	PL_lex_casemods = 0;
	*PL_lex_casestack = '\0';
	PL_lex_starts = 0;
	if (SvEVALED(PL_lex_repl)) {
	    PL_lex_state = LEX_INTERPNORMAL;
	    PL_lex_starts++;
	    /*	we don't clear PL_lex_repl here, so that we can check later
		whether this is an evalled subst; that means we rely on the
		logic to ensure sublex_done() is called again only via the
		branch (in yylex()) that clears PL_lex_repl, else we'll loop */
	}
	else {
	    PL_lex_state = LEX_INTERPCONCAT;
	    PL_lex_repl = NULL;
	}
	if (SvTYPE(PL_linestr) >= SVt_PVNV) {
	    CopLINE(PL_curcop) +=
		((XPVNV*)SvANY(PL_linestr))->xnv_u.xpad_cop_seq.xlow
		 + PL_parser->herelines;
	    PL_parser->herelines = 0;
	}
	return '/';
    }
    else {
	const line_t l = CopLINE(PL_curcop);
	LEAVE;
	if (PL_multi_close == '<')
	    PL_parser->herelines += l - PL_multi_end;
	PL_bufend = SvPVX(PL_linestr);
	PL_bufend += SvCUR(PL_linestr);
	PL_expect = XOPERATOR;
	return ')';
    }
}

PERL_STATIC_INLINE SV*
S_get_and_check_backslash_N_name(pTHX_ const char* s, const char* const e)
{
    /* <s> points to first character of interior of \N{}, <e> to one beyond the
     * interior, hence to the "}".  Finds what the name resolves to, returning
     * an SV* containing it; NULL if no valid one found */

    SV* res = newSVpvn_flags(s, e - s, UTF ? SVf_UTF8 : 0);

    HV * table;
    SV **cvp;
    SV *cv;
    SV *rv;
    HV *stash;
    const U8* first_bad_char_loc;
    const char* backslash_ptr = s - 3; /* Points to the <\> of \N{... */

    PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME;

    if (!SvCUR(res)) {
        Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
                       "Unknown charname '' is deprecated");
        return res;
    }

    if (UTF && ! is_utf8_string_loc((U8 *) backslash_ptr,
                                     e - backslash_ptr,
                                     &first_bad_char_loc))
    {
        /* If warnings are on, this will print a more detailed analysis of what
         * is wrong than the error message below */
        utf8n_to_uvchr(first_bad_char_loc,
                       e - ((char *) first_bad_char_loc),
                       NULL, 0);

        /* We deliberately don't try to print the malformed character, which
         * might not print very well; it also may be just the first of many
         * malformations, so don't print what comes after it */
        yyerror_pv(Perl_form(aTHX_
            "Malformed UTF-8 character immediately after '%.*s'",
            (int) (first_bad_char_loc - (U8 *) backslash_ptr), backslash_ptr),
                   SVf_UTF8);
	return NULL;
    }

    res = new_constant( NULL, 0, "charnames", res, NULL, backslash_ptr,
                        /* include the <}> */
                        e - backslash_ptr + 1);
    if (! SvPOK(res)) {
        SvREFCNT_dec_NN(res);
        return NULL;
    }

    /* See if the charnames handler is the Perl core's, and if so, we can skip
     * the validation needed for a user-supplied one, as Perl's does its own
     * validation. */
    table = GvHV(PL_hintgv);		 /* ^H */
    cvp = hv_fetchs(table, "charnames", FALSE);
    if (cvp && (cv = *cvp) && SvROK(cv) && (rv = SvRV(cv),
        SvTYPE(rv) == SVt_PVCV) && ((stash = CvSTASH(rv)) != NULL))
    {
        const char * const name = HvNAME(stash);
        if (HvNAMELEN(stash) == sizeof("_charnames")-1
         && strEQ(name, "_charnames")) {
           return res;
       }
    }

    /* Here, it isn't Perl's charname handler.  We can't rely on a
     * user-supplied handler to validate the input name.  For non-ut8 input,
     * look to see that the first character is legal.  Then loop through the
     * rest checking that each is a continuation */

    /* This code makes the reasonable assumption that the only Latin1-range
     * characters that begin a character name alias are alphabetic, otherwise
     * would have to create a isCHARNAME_BEGIN macro */

    if (! UTF) {
        if (! isALPHAU(*s)) {
            goto bad_charname;
        }
        s++;
        while (s < e) {
            if (! isCHARNAME_CONT(*s)) {
                goto bad_charname;
            }
	    if (*s == ' ' && *(s-1) == ' ') {
                goto multi_spaces;
            }
	    if ((U8) *s == NBSP_NATIVE && ckWARN_d(WARN_DEPRECATED)) {
                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                           "NO-BREAK SPACE in a charnames "
                           "alias definition is deprecated");
            }
            s++;
        }
    }
    else {
        /* Similarly for utf8.  For invariants can check directly; for other
         * Latin1, can calculate their code point and check; otherwise  use a
         * swash */
        if (UTF8_IS_INVARIANT(*s)) {
            if (! isALPHAU(*s)) {
                goto bad_charname;
            }
            s++;
        } else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
            if (! isALPHAU(EIGHT_BIT_UTF8_TO_NATIVE(*s, *(s+1)))) {
                goto bad_charname;
            }
            s += 2;
        }
        else {
            if (! PL_utf8_charname_begin) {
                U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
                PL_utf8_charname_begin = _core_swash_init("utf8",
                                                        "_Perl_Charname_Begin",
                                                        &PL_sv_undef,
                                                        1, 0, NULL, &flags);
            }
            if (! swash_fetch(PL_utf8_charname_begin, (U8 *) s, TRUE)) {
                goto bad_charname;
            }
            s += UTF8SKIP(s);
        }

        while (s < e) {
            if (UTF8_IS_INVARIANT(*s)) {
                if (! isCHARNAME_CONT(*s)) {
                    goto bad_charname;
                }
                if (*s == ' ' && *(s-1) == ' ') {
                    goto multi_spaces;
                }
                s++;
            }
            else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
                if (! isCHARNAME_CONT(EIGHT_BIT_UTF8_TO_NATIVE(*s, *(s+1))))
                {
                    goto bad_charname;
                }
                if (*s == *NBSP_UTF8
                    && *(s+1) == *(NBSP_UTF8+1)
                    && ckWARN_d(WARN_DEPRECATED))
                {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                "NO-BREAK SPACE in a charnames "
                                "alias definition is deprecated");
                }
                s += 2;
            }
            else {
                if (! PL_utf8_charname_continue) {
                    U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
                    PL_utf8_charname_continue = _core_swash_init("utf8",
                                                "_Perl_Charname_Continue",
                                                &PL_sv_undef,
                                                1, 0, NULL, &flags);
                }
                if (! swash_fetch(PL_utf8_charname_continue, (U8 *) s, TRUE)) {
                    goto bad_charname;
                }
                s += UTF8SKIP(s);
            }
        }
    }
    if (*(s-1) == ' ') {
        yyerror_pv(
            Perl_form(aTHX_
            "charnames alias definitions may not contain trailing "
            "white-space; marked by <-- HERE in %.*s<-- HERE %.*s",
            (int)(s - backslash_ptr + 1), backslash_ptr,
            (int)(e - s + 1), s + 1
            ),
        UTF ? SVf_UTF8 : 0);
        return NULL;
    }

    if (SvUTF8(res)) { /* Don't accept malformed input */
        const U8* first_bad_char_loc;
        STRLEN len;
        const char* const str = SvPV_const(res, len);
        if (! is_utf8_string_loc((U8 *) str, len, &first_bad_char_loc)) {
            /* If warnings are on, this will print a more detailed analysis of
             * what is wrong than the error message below */
            utf8n_to_uvchr(first_bad_char_loc,
                           (char *) first_bad_char_loc - str,
                           NULL, 0);

            /* We deliberately don't try to print the malformed character,
             * which might not print very well; it also may be just the first
             * of many malformations, so don't print what comes after it */
            yyerror_pv(
              Perl_form(aTHX_
                "Malformed UTF-8 returned by %.*s immediately after '%.*s'",
                 (int) (e - backslash_ptr + 1), backslash_ptr,
                 (int) ((char *) first_bad_char_loc - str), str
              ),
              SVf_UTF8);
            return NULL;
        }
    }

    return res;

  bad_charname: {

        /* The final %.*s makes sure that should the trailing NUL be missing
         * that this print won't run off the end of the string */
        yyerror_pv(
          Perl_form(aTHX_
            "Invalid character in \\N{...}; marked by <-- HERE in %.*s<-- HERE %.*s",
            (int)(s - backslash_ptr + 1), backslash_ptr,
            (int)(e - s + 1), s + 1
          ),
          UTF ? SVf_UTF8 : 0);
        return NULL;
    }

  multi_spaces:
        yyerror_pv(
          Perl_form(aTHX_
            "charnames alias definitions may not contain a sequence of "
            "multiple spaces; marked by <-- HERE in %.*s<-- HERE %.*s",
            (int)(s - backslash_ptr + 1), backslash_ptr,
            (int)(e - s + 1), s + 1
          ),
          UTF ? SVf_UTF8 : 0);
        return NULL;
}

/*
  scan_const

  Extracts the next constant part of a pattern, double-quoted string,
  or transliteration.  This is terrifying code.

  For example, in parsing the double-quoted string "ab\x63$d", it would
  stop at the '$' and return an OP_CONST containing 'abc'.

  It looks at PL_lex_inwhat and PL_lex_inpat to find out whether it's
  processing a pattern (PL_lex_inpat is true), a transliteration
  (PL_lex_inwhat == OP_TRANS is true), or a double-quoted string.

  Returns a pointer to the character scanned up to. If this is
  advanced from the start pointer supplied (i.e. if anything was
  successfully parsed), will leave an OP_CONST for the substring scanned
  in pl_yylval. Caller must intuit reason for not parsing further
  by looking at the next characters herself.

  In patterns:
    expand:
      \N{FOO}  => \N{U+hex_for_character_FOO}
      (if FOO expands to multiple characters, expands to \N{U+xx.XX.yy ...})

    pass through:
	all other \-char, including \N and \N{ apart from \N{ABC}

    stops on:
	@@ and $ where it appears to be a var, but not for $ as tail anchor
        \l \L \u \U \Q \E
	(?{  or  (??{

  In transliterations:
    characters are VERY literal, except for - not at the start or end
    of the string, which indicates a range. If the range is in bytes,
    scan_const expands the range to the full set of intermediate
    characters. If the range is in utf8, the hyphen is replaced with
    a certain range mark which will be handled by pmtrans() in op.c.

  In double-quoted strings:
    backslashes:
      double-quoted style: \r and \n
      constants: \x31, etc.
      deprecated backrefs: \1 (in substitution replacements)
      case and quoting: \U \Q \E
    stops on @@ and $

  scan_const does *not* construct ops to handle interpolated strings.
  It stops processing as soon as it finds an embedded $ or @@ variable
  and leaves it to the caller to work out what's going on.

  embedded arrays (whether in pattern or not) could be:
      @@foo, @@::foo, @@'foo, @@{foo}, @@$foo, @@+, @@-.

  $ in double-quoted strings must be the symbol of an embedded scalar.

  $ in pattern could be $foo or could be tail anchor.  Assumption:
  it's a tail anchor if $ is the last thing in the string, or if it's
  followed by one of "()| \r\n\t"

  \1 (backreferences) are turned into $1 in substitutions

  The structure of the code is
      while (there's a character to process) {
	  handle transliteration ranges
	  skip regexp comments /(?#comment)/ and codes /(?{code})/
	  skip #-initiated comments in //x patterns
	  check for embedded arrays
	  check for embedded scalars
	  if (backslash) {
	      deprecate \1 in substitution replacements
	      handle string-changing backslashes \l \U \Q \E, etc.
	      switch (what was escaped) {
		  handle \- in a transliteration (becomes a literal -)
		  if a pattern and not \N{, go treat as regular character
		  handle \132 (octal characters)
		  handle \x15 and \x{1234} (hex characters)
		  handle \N{name} (named characters, also \N{3,5} in a pattern)
		  handle \cV (control characters)
		  handle printf-style backslashes (\f, \r, \n, etc)
	      } (end switch)
	      continue
	  } (end if backslash)
          handle regular character
    } (end while character to read)
		
*/

STATIC char *
S_scan_const(pTHX_ char *start)
{
    char *send = PL_bufend;		/* end of the constant */
    SV *sv = newSV(send - start);       /* sv for the constant.  See note below
                                           on sizing. */
    char *s = start;			/* start of the constant */
    char *d = SvPVX(sv);		/* destination for copies */
    bool dorange = FALSE;               /* are we in a translit range? */
    bool didrange = FALSE;              /* did we just finish a range? */
    bool in_charclass = FALSE;          /* within /[...]/ */
    bool has_utf8 = FALSE;              /* Output constant is UTF8 */
    bool  this_utf8 = cBOOL(UTF);       /* Is the source string assumed to be
                                           UTF8?  But, this can show as true
                                           when the source isn't utf8, as for
                                           example when it is entirely composed
                                           of hex constants */
    SV *res;		                /* result from charnames */
    STRLEN offset_to_max;   /* The offset in the output to where the range
                               high-end character is temporarily placed */

    /* Note on sizing:  The scanned constant is placed into sv, which is
     * initialized by newSV() assuming one byte of output for every byte of
     * input.  This routine expects newSV() to allocate an extra byte for a
     * trailing NUL, which this routine will append if it gets to the end of
     * the input.  There may be more bytes of input than output (eg., \N{LATIN
     * CAPITAL LETTER A}), or more output than input if the constant ends up
     * recoded to utf8, but each time a construct is found that might increase
     * the needed size, SvGROW() is called.  Its size parameter each time is
     * based on the best guess estimate at the time, namely the length used so
     * far, plus the length the current construct will occupy, plus room for
     * the trailing NUL, plus one byte for every input byte still unscanned */ 

    UV uv = UV_MAX; /* Initialize to weird value to try to catch any uses
                       before set */
#ifdef EBCDIC
    int backslash_N = 0;            /* ? was the character from \N{} */
    int non_portable_endpoint = 0;  /* ? In a range is an endpoint
                                       platform-specific like \x65 */
#endif

    PERL_ARGS_ASSERT_SCAN_CONST;

    assert(PL_lex_inwhat != OP_TRANSR);
    if (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op) {
	/* If we are doing a trans and we know we want UTF8 set expectation */
	has_utf8   = PL_sublex_info.sub_op->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF);
	this_utf8  = PL_sublex_info.sub_op->op_private & (PL_lex_repl ? OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF);
    }

    /* Protect sv from errors and fatal warnings. */
    ENTER_with_name("scan_const");
    SAVEFREESV(sv);

    while (s < send
           || dorange   /* Handle tr/// range at right edge of input */
    ) {

        /* get transliterations out of the way (they're most literal) */
	if (PL_lex_inwhat == OP_TRANS) {

            /* But there isn't any special handling necessary unless there is a
             * range, so for most cases we just drop down and handle the value
             * as any other.  There are two exceptions.
             *
             * 1.  A minus sign indicates that we are actually going to have
             *     a range.  In this case, skip the '-', set a flag, then drop
             *     down to handle what should be the end range value.
             * 2.  After we've handled that value, the next time through, that
             *     flag is set and we fix up the range.
             *
             * Ranges entirely within Latin1 are expanded out entirely, in
             * order to avoid the significant overhead of making a swash.
             * Ranges that extend above Latin1 have to have a swash, so there
             * is no advantage to abbreviate them here, so they are stored here
             * as Min, ILLEGAL_UTF8_BYTE, Max.  The illegal byte signifies a
             * hyphen without any possible ambiguity.  On EBCDIC machines, if
             * the range is expressed as Unicode, the Latin1 portion is
             * expanded out even if the entire range extends above Latin1.
             * This is because each code point in it has to be processed here
             * individually to get its native translation */

	    if (! dorange) {

                /* Here, we don't think we're in a range.  If we've processed
                 * at least one character, then see if this next one is a '-',
                 * indicating the previous one was the start of a range.  But
                 * don't bother if we're too close to the end for the minus to
                 * mean that. */
                if (*s != '-' || s >= send - 1 || s == start) {

                    /* A regular character.  Process like any other, but first
                     * clear any flags */
                    didrange = FALSE;
                    dorange = FALSE;
#ifdef EBCDIC
                    non_portable_endpoint = 0;
                    backslash_N = 0;
#endif
                    /* Drops down to generic code to process current byte */
                }
                else {
                    if (didrange) { /* Something like y/A-C-Z// */
                        Perl_croak(aTHX_ "Ambiguous range in transliteration operator");
                    }

                    dorange = TRUE;

                    s++;    /* Skip past the minus */

                    /* d now points to where the end-range character will be
                     * placed.  Save it so won't have to go finding it later,
                     * and drop down to get that character.  (Actually we
                     * instead save the offset, to handle the case where a
                     * realloc in the meantime could change the actual
                     * pointer).  We'll finish processing the range the next
                     * time through the loop */
                    offset_to_max = d - SvPVX_const(sv);
                }
            }  /* End of not a range */
            else {
                /* Here we have parsed a range.  Now must handle it.  At this
                 * point:
                 * 'sv' is a SV* that contains the output string we are
                 *      constructing.  The final two characters in that string
                 *      are the range start and range end, in order.
                 * 'd'  points to just beyond the range end in the 'sv' string,
                 *      where we would next place something
                 * 'offset_to_max' is the offset in 'sv' at which the character
                 *      before 'd' begins.
                 */
                const char * max_ptr = SvPVX_const(sv) + offset_to_max;
                const char * min_ptr;
                IV range_min;
		IV range_max;	/* last character in range */
                STRLEN save_offset;
                STRLEN grow;
#ifndef EBCDIC  /* Not meaningful except in EBCDIC, so initialize to false */
                const bool convert_unicode = FALSE;
                const IV real_range_max = 0;
#else
                bool convert_unicode;
                IV real_range_max = 0;
#endif

                /* Get the range-ends code point values. */
                if (has_utf8) {
                    /* We know the utf8 is valid, because we just constructed
                     * it ourselves in previous loop iterations */
                    min_ptr = (char*) utf8_hop( (U8*) max_ptr, -1);
                    range_min = valid_utf8_to_uvchr( (U8*) min_ptr, NULL);
                    range_max = valid_utf8_to_uvchr( (U8*) max_ptr, NULL);
                }
                else {
                    min_ptr = max_ptr - 1;
                    range_min = * (U8*) min_ptr;
                    range_max = * (U8*) max_ptr;
                }

#ifdef EBCDIC
                /* On EBCDIC platforms, we may have to deal with portable
                 * ranges.  These happen if at least one range endpoint is a
                 * Unicode value (\N{...}), or if the range is a subset of
                 * [A-Z] or [a-z], and both ends are literal characters,
                 * like 'A', and not like \x{C1} */
                if ((convert_unicode
                     = cBOOL(backslash_N)   /* \N{} forces Unicode, hence
                                               portable range */
                      || (   ! non_portable_endpoint
                          && ((  isLOWER_A(range_min) && isLOWER_A(range_max))
                             || (isUPPER_A(range_min) && isUPPER_A(range_max))))
                )) {

                    /* Special handling is needed for these portable ranges.
                     * They are defined to all be in Unicode terms, which
                     * include all Unicode code points between the end points.
                     * Convert to Unicode to get the Unicode range.  Later we
                     * will convert each code point in the range back to
                     * native.  */
                    range_min = NATIVE_TO_UNI(range_min);
                    range_max = NATIVE_TO_UNI(range_max);
                }
#endif

                if (range_min > range_max) {
                    if (convert_unicode) {
                        /* Need to convert back to native for meaningful
                         * messages for this platform */
                        range_min = UNI_TO_NATIVE(range_min);
                        range_max = UNI_TO_NATIVE(range_max);
                    }

                    /* Use the characters themselves for the error message if
                     * ASCII printables; otherwise some visible representation
                     * of them */
                    if (isPRINT_A(range_min) && isPRINT_A(range_max)) {
                        Perl_croak(aTHX_
			 "Invalid range \"%c-%c\" in transliteration operator",
			 (char)range_min, (char)range_max);
                    }
                    else if (convert_unicode) {
                        /* diag_listed_as: Invalid range "%s" in transliteration operator */
                        Perl_croak(aTHX_
			       "Invalid range \"\\N{U+%04"UVXf"}-\\N{U+%04"UVXf"}\""
                               " in transliteration operator",
			       range_min, range_max);
                    }
                    else {
                        /* diag_listed_as: Invalid range "%s" in transliteration operator */
                        Perl_croak(aTHX_
			       "Invalid range \"\\x{%04"UVXf"}-\\x{%04"UVXf"}\""
                               " in transliteration operator",
			       range_min, range_max);
                    }
                }

		if (has_utf8) {

                    /* We try to avoid creating a swash.  If the upper end of
                     * this range is below 256, this range won't force a swash;
                     * otherwise it does force a swash, and as long as we have
                     * to have one, we might as well not expand things out.
                     * But if it's EBCDIC, we may have to look at each
                     * character below 256 if we have to convert to/from
                     * Unicode values */
                    if (range_max > 255
#ifdef EBCDIC
		        && (range_min > 255 || ! convert_unicode)
#endif
                    ) {
                        /* Move the high character one byte to the right; then
                         * insert between it and the range begin, an illegal
                         * byte which serves to indicate this is a range (using
                         * a '-' could be ambiguous). */
                        char *e = d++;
                        while (e-- > max_ptr) {
                            *(e + 1) = *e;
                        }
                        *(e + 1) = (char) ILLEGAL_UTF8_BYTE;
                        goto range_done;
                    }

                    /* Here, we're going to expand out the range.  For EBCDIC
                     * the range can extend above 255 (not so in ASCII), so
                     * for EBCDIC, split it into the parts above and below
                     * 255/256 */
#ifdef EBCDIC
                    if (range_max > 255) {
                        real_range_max = range_max;
                        range_max = 255;
                    }
#endif
		}

                /* Here we need to expand out the string to contain each
                 * character in the range.  Grow the output to handle this */

                save_offset  = min_ptr - SvPVX_const(sv);

                /* The base growth is the number of code points in the range */
                grow = range_max - range_min + 1;
                if (has_utf8) {

                    /* But if the output is UTF-8, some of those characters may
                     * need two bytes (since the maximum range value here is
                     * 255, the max bytes per character is two).  On ASCII
                     * platforms, it's not much trouble to get an accurate
                     * count of what's needed.  But on EBCDIC, the ones that
                     * need 2 bytes are scattered around, so just use a worst
                     * case value instead of calculating for that platform.  */
#ifdef EBCDIC
                    grow *= 2;
#else
                    /* Only those above 127 require 2 bytes.  This may be
                     * everything in the range, or not */
                    if (range_min > 127) {
                        grow *= 2;
                    }
                    else if (range_max > 127) {
                        grow += range_max - 127;
                    }
#endif
                }

                /* Subtract 3 for the bytes that were already accounted for
                 * (min, max, and the hyphen) */
                SvGROW(sv, SvLEN(sv) + grow - 3);
		d = SvPVX(sv) + save_offset;	/* refresh d after realloc */

                /* Here, we expand out the range.  On ASCII platforms, the
                 * compiler should optimize out the 'convert_unicode==TRUE'
                 * portion of this */
                if (convert_unicode) {
                    IV i;

                    /* Recall that the min and max are now in Unicode terms, so
                     * we have to convert each character to its native
                     * equivalent */
                    if (has_utf8) {
                        for (i = range_min; i <= range_max; i++) {
                            append_utf8_from_native_byte(LATIN1_TO_NATIVE((U8) i),
                                                         (U8 **) &d);
                        }
                    }
                    else {
                        for (i = range_min; i <= range_max; i++) {
                            *d++ = (char)LATIN1_TO_NATIVE((U8) i);
                        }
		    }
		}
                else {
                    IV i;

                    /* Here, no conversions are necessary, which means that the
                     * first character in the range is already in 'd' and
                     * valid, so we can skip overwriting it */
                    if (has_utf8) {
                        d += UTF8SKIP(d);
                        for (i = range_min + 1; i <= range_max; i++) {
                            append_utf8_from_native_byte((U8) i, (U8 **) &d);
                        }
                    }
                    else {
                        d++;
                        for (i = range_min + 1; i <= range_max; i++) {
                            *d++ = (char)i;
                        }
		    }
		}

                /* (Compilers should optimize this out for non-EBCDIC).  If the
                 * original range extended above 255, add in that portion */
                if (real_range_max) {
                    *d++ = (char) UTF8_TWO_BYTE_HI(0x100);
                    *d++ = (char) UTF8_TWO_BYTE_LO(0x100);
                    if (real_range_max > 0x101)
                        *d++ = (char) ILLEGAL_UTF8_BYTE;
                    if (real_range_max > 0x100)
                        d = (char*)uvchr_to_utf8((U8*)d, real_range_max);
                }

              range_done:
		/* mark the range as done, and continue */
		didrange = TRUE;
		dorange = FALSE;
#ifdef EBCDIC
		non_portable_endpoint = 0;
                backslash_N = 0;
#endif
		continue;
	    } /* End of is a range */
        } /* End of transliteration.  Joins main code after these else's */
	else if (*s == '[' && PL_lex_inpat && !in_charclass) {
	    char *s1 = s-1;
	    int esc = 0;
	    while (s1 >= start && *s1-- == '\\')
		esc = !esc;
	    if (!esc)
		in_charclass = TRUE;
	}

	else if (*s == ']' && PL_lex_inpat &&  in_charclass) {
	    char *s1 = s-1;
	    int esc = 0;
	    while (s1 >= start && *s1-- == '\\')
		esc = !esc;
	    if (!esc)
		in_charclass = FALSE;
	}

	/* skip for regexp comments /(?#comment)/, except for the last
	 * char, which will be done separately.
	 * Stop on (?{..}) and friends */

	else if (*s == '(' && PL_lex_inpat && s[1] == '?' && !in_charclass) {
	    if (s[2] == '#') {
		while (s+1 < send && *s != ')')
		    *d++ = *s++;
	    }
	    else if (!PL_lex_casemods
                     && (    s[2] == '{' /* This should match regcomp.c */
		         || (s[2] == '?' && s[3] == '{')))
	    {
		break;
	    }
	}

	/* likewise skip #-initiated comments in //x patterns */
	else if (*s == '#'
                 && PL_lex_inpat
                 && !in_charclass
                 && ((PMOP*)PL_lex_inpat)->op_pmflags & RXf_PMf_EXTENDED)
        {
	    while (s+1 < send && *s != '\n')
		*d++ = *s++;
	}

	/* no further processing of single-quoted regex */
	else if (PL_lex_inpat && SvIVX(PL_linestr) == '\'')
	    goto default_action;

	/* check for embedded arrays
	   (@@foo, @@::foo, @@'foo, @@{foo}, @@$foo, @@+, @@-)
	   */
	else if (*s == '@@' && s[1]) {
	    if (UTF ? isIDFIRST_utf8((U8*)s+1) : isWORDCHAR_A(s[1]))
		break;
	    if (strchr(":'{$", s[1]))
		break;
	    if (!PL_lex_inpat && (s[1] == '+' || s[1] == '-'))
		break; /* in regexp, neither @@+ nor @@- are interpolated */
	}

	/* check for embedded scalars.  only stop if we're sure it's a
	   variable.
        */
	else if (*s == '$') {
	    if (!PL_lex_inpat)	/* not a regexp, so $ must be var */
		break;
	    if (s + 1 < send && !strchr("()| \r\n\t", s[1])) {
		if (s[1] == '\\') {
		    Perl_ck_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
				   "Possible unintended interpolation of $\\ in regex");
		}
		break;		/* in regexp, $ might be tail anchor */
            }
	}

	/* End of else if chain - OP_TRANS rejoin rest */

	/* backslashes */
	if (*s == '\\' && s+1 < send) {
	    char* e;	/* Can be used for ending '}', etc. */

	    s++;

	    /* warn on \1 - \9 in substitution replacements, but note that \11
	     * is an octal; and \19 is \1 followed by '9' */
	    if (PL_lex_inwhat == OP_SUBST
                && !PL_lex_inpat
                && isDIGIT(*s)
                && *s != '0'
                && !isDIGIT(s[1]))
	    {
		/* diag_listed_as: \%d better written as $%d */
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "\\%c better written as $%c", *s, *s);
		*--s = '$';
		break;
	    }

	    /* string-change backslash escapes */
	    if (PL_lex_inwhat != OP_TRANS && *s && strchr("lLuUEQF", *s)) {
		--s;
		break;
	    }
	    /* In a pattern, process \N, but skip any other backslash escapes.
	     * This is because we don't want to translate an escape sequence
	     * into a meta symbol and have the regex compiler use the meta
	     * symbol meaning, e.g. \x{2E} would be confused with a dot.  But
	     * in spite of this, we do have to process \N here while the proper
	     * charnames handler is in scope.  See bugs #56444 and #62056.
             *
	     * There is a complication because \N in a pattern may also stand
	     * for 'match a non-nl', and not mean a charname, in which case its
	     * processing should be deferred to the regex compiler.  To be a
	     * charname it must be followed immediately by a '{', and not look
	     * like \N followed by a curly quantifier, i.e., not something like
	     * \N{3,}.  regcurly returns a boolean indicating if it is a legal
	     * quantifier */
	    else if (PL_lex_inpat
		    && (*s != 'N'
			|| s[1] != '{'
			|| regcurly(s + 1)))
	    {
		*d++ = '\\';
		goto default_action;
	    }

	    switch (*s) {
	    default:
	        {
		    if ((isALPHANUMERIC(*s)))
			Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
				       "Unrecognized escape \\%c passed through",
				       *s);
		    /* default action is to copy the quoted character */
		    goto default_action;
		}

	    /* eg. \132 indicates the octal constant 0132 */
	    case '0': case '1': case '2': case '3':
	    case '4': case '5': case '6': case '7':
		{
                    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
                    STRLEN len = 3;
		    uv = grok_oct(s, &len, &flags, NULL);
		    s += len;
                    if (len < 3 && s < send && isDIGIT(*s)
                        && ckWARN(WARN_MISC))
                    {
                        Perl_warner(aTHX_ packWARN(WARN_MISC),
                                    "%s", form_short_octal_warning(s, len));
                    }
		}
		goto NUM_ESCAPE_INSERT;

	    /* eg. \o{24} indicates the octal constant \024 */
	    case 'o':
		{
		    const char* error;

		    bool valid = grok_bslash_o(&s, &uv, &error,
                                               TRUE, /* Output warning */
                                               FALSE, /* Not strict */
                                               TRUE, /* Output warnings for
                                                         non-portables */
                                               UTF);
		    if (! valid) {
			yyerror(error);
			continue;
		    }
		    goto NUM_ESCAPE_INSERT;
		}

	    /* eg. \x24 indicates the hex constant 0x24 */
	    case 'x':
		{
		    const char* error;

		    bool valid = grok_bslash_x(&s, &uv, &error,
                                               TRUE, /* Output warning */
                                               FALSE, /* Not strict */
                                               TRUE,  /* Output warnings for
                                                         non-portables */
                                               UTF);
		    if (! valid) {
			yyerror(error);
			continue;
		    }
		}

	      NUM_ESCAPE_INSERT:
		/* Insert oct or hex escaped character. */
		
		/* Here uv is the ordinal of the next character being added */
		if (UVCHR_IS_INVARIANT(uv)) {
		    *d++ = (char) uv;
		}
		else {
		    if (!has_utf8 && uv > 255) {
			/* Might need to recode whatever we have accumulated so
			 * far if it contains any chars variant in utf8 or
			 * utf-ebcdic. */
			  
			SvCUR_set(sv, d - SvPVX_const(sv));
			SvPOK_on(sv);
			*d = '\0';
			/* See Note on sizing above.  */
			sv_utf8_upgrade_flags_grow(
                                       sv,
                                       SV_GMAGIC|SV_FORCE_UTF8_UPGRADE
                                                  /* Above-latin1 in string
                                                   * implies no encoding */
                                                  |SV_UTF8_NO_ENCODING,
                                       UVCHR_SKIP(uv) + (STRLEN)(send - s) + 1);
			d = SvPVX(sv) + SvCUR(sv);
			has_utf8 = TRUE;
                    }

                    if (has_utf8) {
                       /* Usually, there will already be enough room in 'sv'
                        * since such escapes are likely longer than any UTF-8
                        * sequence they can end up as.  This isn't the case on
                        * EBCDIC where \x{40000000} contains 12 bytes, and the
                        * UTF-8 for it contains 14.  And, we have to allow for
                        * a trailing NUL.  It probably can't happen on ASCII
                        * platforms, but be safe */
                        const STRLEN needed = d - SvPVX(sv) + UVCHR_SKIP(uv)
                                            + 1;
                        if (UNLIKELY(needed > SvLEN(sv))) {
                            SvCUR_set(sv, d - SvPVX_const(sv));
                            d = sv_grow(sv, needed) + SvCUR(sv);
                        }

		        d = (char*)uvchr_to_utf8((U8*)d, uv);
			if (PL_lex_inwhat == OP_TRANS
                            && PL_sublex_info.sub_op)
                        {
			    PL_sublex_info.sub_op->op_private |=
				(PL_lex_repl ? OPpTRANS_FROM_UTF
					     : OPpTRANS_TO_UTF);
			}
                    }
		    else {
		        *d++ = (char)uv;
		    }
		}
#ifdef EBCDIC
                non_portable_endpoint++;
#endif
		continue;

 	    case 'N':
                /* In a non-pattern \N must be like \N{U+0041}, or it can be a
                 * named character, like \N{LATIN SMALL LETTER A}, or a named
                 * sequence, like \N{LATIN CAPITAL LETTER A WITH MACRON AND
                 * GRAVE} (except y/// can't handle the latter, croaking).  For
                 * convenience all three forms are referred to as "named
                 * characters" below.
                 *
                 * For patterns, \N also can mean to match a non-newline.  Code
                 * before this 'switch' statement should already have handled
                 * this situation, and hence this code only has to deal with
                 * the named character cases.
                 *
                 * For non-patterns, the named characters are converted to
                 * their string equivalents.  In patterns, named characters are
                 * not converted to their ultimate forms for the same reasons
                 * that other escapes aren't.  Instead, they are converted to
                 * the \N{U+...} form to get the value from the charnames that
                 * is in effect right now, while preserving the fact that it
                 * was a named character, so that the regex compiler knows
                 * this.
                 *
		 * The structure of this section of code (besides checking for
		 * errors and upgrading to utf8) is:
                 *    If the named character is of the form \N{U+...}, pass it
                 *      through if a pattern; otherwise convert the code point
                 *      to utf8
                 *    Otherwise must be some \N{NAME}: convert to
                 *      \N{U+c1.c2...} if a pattern; otherwise convert to utf8
                 *
                 * Transliteration is an exception.  The conversion to utf8 is
                 * only done if the code point requires it to be representable.
                 *
                 * Here, 's' points to the 'N'; the test below is guaranteed to
		 * succeed if we are being called on a pattern, as we already
                 * know from a test above that the next character is a '{'.  A
                 * non-pattern \N must mean 'named character', which requires
                 * braces */
		s++;
		if (*s != '{') {
		    yyerror("Missing braces on \\N{}"); 
		    continue;
		}
		s++;

		/* If there is no matching '}', it is an error. */
		if (! (e = strchr(s, '}'))) {
		    if (! PL_lex_inpat) {
			yyerror("Missing right brace on \\N{}");
		    } else {
			yyerror("Missing right brace on \\N{} or unescaped left brace after \\N");
		    }
		    continue;
		}

		/* Here it looks like a named character */

		if (*s == 'U' && s[1] == '+') { /* \N{U+...} */
		    s += 2;	    /* Skip to next char after the 'U+' */
		    if (PL_lex_inpat) {

                        /* In patterns, we can have \N{U+xxxx.yyyy.zzzz...} */
                        /* Check the syntax.  */
                        const char *orig_s;
                        orig_s = s - 5;
                        if (!isXDIGIT(*s)) {
                          bad_NU:
                            yyerror(
                                "Invalid hexadecimal number in \\N{U+...}"
                            );
                            s = e + 1;
                            continue;
                        }
                        while (++s < e) {
                            if (isXDIGIT(*s))
                                continue;
                            else if ((*s == '.' || *s == '_')
                                  && isXDIGIT(s[1]))
                                continue;
                            goto bad_NU;
                        }

                        /* Pass everything through unchanged.
                         * +1 is for the '}' */
                        Copy(orig_s, d, e - orig_s + 1, char);
                        d += e - orig_s + 1;
		    }
		    else {  /* Not a pattern: convert the hex to string */
                        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
				| PERL_SCAN_SILENT_ILLDIGIT
				| PERL_SCAN_DISALLOW_PREFIX;
                        STRLEN len = e - s;
                        uv = grok_hex(s, &len, &flags, NULL);
                        if (len == 0 || (len != (STRLEN)(e - s)))
                            goto bad_NU;

                         /* For non-tr///, if the destination is not in utf8,
                          * unconditionally recode it to be so.  This is
                          * because \N{} implies Unicode semantics, and scalars
                          * have to be in utf8 to guarantee those semantics.
                          * tr/// doesn't care about Unicode rules, so no need
                          * there to upgrade to UTF-8 for small enough code
                          * points */
			if (! has_utf8 && (   uv > 0xFF
                                           || PL_lex_inwhat != OP_TRANS))
                        {
			    SvCUR_set(sv, d - SvPVX_const(sv));
			    SvPOK_on(sv);
			    *d = '\0';
			    /* See Note on sizing above.  */
			    sv_utf8_upgrade_flags_grow(
                                    sv,
                                    SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
				    UVCHR_SKIP(uv) + (STRLEN)(send - e) + 1);
			    d = SvPVX(sv) + SvCUR(sv);
			    has_utf8 = TRUE;
			}

                        /* Add the (Unicode) code point to the output. */
			if (OFFUNI_IS_INVARIANT(uv)) {
			    *d++ = (char) LATIN1_TO_NATIVE(uv);
			}
			else {
                            d = (char*) uvoffuni_to_utf8_flags((U8*)d, uv, 0);
                        }
		    }
		}
		else /* Here is \N{NAME} but not \N{U+...}. */
                     if ((res = get_and_check_backslash_N_name(s, e)))
                {
                    STRLEN len;
                    const char *str = SvPV_const(res, len);
                    if (PL_lex_inpat) {

			if (! len) { /* The name resolved to an empty string */
			    Copy("\\N{}", d, 4, char);
			    d += 4;
			}
			else {
			    /* In order to not lose information for the regex
			    * compiler, pass the result in the specially made
			    * syntax: \N{U+c1.c2.c3...}, where c1 etc. are
			    * the code points in hex of each character
			    * returned by charnames */

			    const char *str_end = str + len;
			    const STRLEN off = d - SvPVX_const(sv);

                            if (! SvUTF8(res)) {
                                /* For the non-UTF-8 case, we can determine the
                                 * exact length needed without having to parse
                                 * through the string.  Each character takes up
                                 * 2 hex digits plus either a trailing dot or
                                 * the "}" */
                                const char initial_text[] = "\\N{U+";
                                const STRLEN initial_len = sizeof(initial_text)
                                                           - 1;
                                d = off + SvGROW(sv, off
                                                    + 3 * len

                                                    /* +1 for trailing NUL */
                                                    + initial_len + 1

                                                    + (STRLEN)(send - e));
                                Copy(initial_text, d, initial_len, char);
                                d += initial_len;
                                while (str < str_end) {
                                    char hex_string[4];
                                    int len =
                                        my_snprintf(hex_string,
                                                  sizeof(hex_string),
                                                  "%02X.",

                                                  /* The regex compiler is
                                                   * expecting Unicode, not
                                                   * native */
                                                  NATIVE_TO_LATIN1(*str));
                                    PERL_MY_SNPRINTF_POST_GUARD(len,
                                                           sizeof(hex_string));
                                    Copy(hex_string, d, 3, char);
                                    d += 3;
                                    str++;
                                }
                                d--;    /* Below, we will overwrite the final
                                           dot with a right brace */
                            }
                            else {
                                STRLEN char_length; /* cur char's byte length */

                                /* and the number of bytes after this is
                                 * translated into hex digits */
                                STRLEN output_length;

                                /* 2 hex per byte; 2 chars for '\N'; 2 chars
                                 * for max('U+', '.'); and 1 for NUL */
                                char hex_string[2 * UTF8_MAXBYTES + 5];

                                /* Get the first character of the result. */
                                U32 uv = utf8n_to_uvchr((U8 *) str,
                                                        len,
                                                        &char_length,
                                                        UTF8_ALLOW_ANYUV);
                                /* Convert first code point to Unicode hex,
                                 * including the boiler plate before it. */
                                output_length =
                                    my_snprintf(hex_string, sizeof(hex_string),
                                             "\\N{U+%X",
                                             (unsigned int) NATIVE_TO_UNI(uv));

                                /* Make sure there is enough space to hold it */
                                d = off + SvGROW(sv, off
                                                    + output_length
                                                    + (STRLEN)(send - e)
                                                    + 2);	/* '}' + NUL */
                                /* And output it */
                                Copy(hex_string, d, output_length, char);
                                d += output_length;

                                /* For each subsequent character, append dot and
                                * its Unicode code point in hex */
                                while ((str += char_length) < str_end) {
                                    const STRLEN off = d - SvPVX_const(sv);
                                    U32 uv = utf8n_to_uvchr((U8 *) str,
                                                            str_end - str,
                                                            &char_length,
                                                            UTF8_ALLOW_ANYUV);
                                    output_length =
                                        my_snprintf(hex_string,
                                             sizeof(hex_string),
                                             ".%X",
                                             (unsigned int) NATIVE_TO_UNI(uv));

                                    d = off + SvGROW(sv, off
                                                        + output_length
                                                        + (STRLEN)(send - e)
                                                        + 2);	/* '}' +  NUL */
                                    Copy(hex_string, d, output_length, char);
                                    d += output_length;
                                }
			    }

			    *d++ = '}';	/* Done.  Add the trailing brace */
			}
		    }
		    else { /* Here, not in a pattern.  Convert the name to a
			    * string. */

                        if (PL_lex_inwhat == OP_TRANS) {
                            str = SvPV_const(res, len);
                            if (len > ((SvUTF8(res))
                                       ? UTF8SKIP(str)
                                       : 1U))
                            {
                                yyerror(Perl_form(aTHX_
                                    "%.*s must not be a named sequence"
                                    " in transliteration operator",
                                        /*  +1 to include the "}" */
                                    (int) (e + 1 - start), start));
                                goto end_backslash_N;
                            }
                        }
                        else if (! SvUTF8(res)) {
                            /* Make sure \N{} return is UTF-8.  This is because
                            * \N{} implies Unicode semantics, and scalars have to
                            * be in utf8 to guarantee those semantics; but not
                            * needed in tr/// */
                            sv_utf8_upgrade_flags(res, SV_UTF8_NO_ENCODING);
                            str = SvPV_const(res, len);
                        }

                         /* Upgrade destination to be utf8 if this new
                          * component is */
			if (! has_utf8 && SvUTF8(res)) {
			    SvCUR_set(sv, d - SvPVX_const(sv));
			    SvPOK_on(sv);
			    *d = '\0';
			    /* See Note on sizing above.  */
			    sv_utf8_upgrade_flags_grow(sv,
						SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
						len + (STRLEN)(send - s) + 1);
			    d = SvPVX(sv) + SvCUR(sv);
			    has_utf8 = TRUE;
			} else if (len > (STRLEN)(e - s + 4)) { /* I _guess_ 4 is \N{} --jhi */

			    /* See Note on sizing above.  (NOTE: SvCUR() is not
			     * set correctly here). */
			    const STRLEN off = d - SvPVX_const(sv);
			    d = off + SvGROW(sv, off + len + (STRLEN)(send - s) + 1);
			}
			Copy(str, d, len, char);
			d += len;
		    }

		    SvREFCNT_dec(res);

		} /* End \N{NAME} */

              end_backslash_N:
#ifdef EBCDIC
                backslash_N++; /* \N{} is defined to be Unicode */
#endif
		s = e + 1;  /* Point to just after the '}' */
		continue;

	    /* \c is a control character */
	    case 'c':
		s++;
		if (s < send) {
		    *d++ = grok_bslash_c(*s++, 1);
		}
		else {
		    yyerror("Missing control char name in \\c");
		}
#ifdef EBCDIC
                non_portable_endpoint++;
#endif
		continue;

	    /* printf-style backslashes, formfeeds, newlines, etc */
	    case 'b':
		*d++ = '\b';
		break;
	    case 'n':
		*d++ = '\n';
		break;
	    case 'r':
		*d++ = '\r';
		break;
	    case 'f':
		*d++ = '\f';
		break;
	    case 't':
		*d++ = '\t';
		break;
	    case 'e':
		*d++ = ESC_NATIVE;
		break;
	    case 'a':
		*d++ = '\a';
		break;
	    } /* end switch */

	    s++;
	    continue;
	} /* end if (backslash) */

    default_action:
	/* If we started with encoded form, or already know we want it,
	   then encode the next character */
	if (! NATIVE_BYTE_IS_INVARIANT((U8)(*s)) && (this_utf8 || has_utf8)) {
	    STRLEN len  = 1;

	    /* One might think that it is wasted effort in the case of the
	     * source being utf8 (this_utf8 == TRUE) to take the next character
	     * in the source, convert it to an unsigned value, and then convert
	     * it back again.  But the source has not been validated here.  The
	     * routine that does the conversion checks for errors like
	     * malformed utf8 */

	    const UV nextuv   = (this_utf8)
                                ? utf8n_to_uvchr((U8*)s, send - s, &len, 0)
                                : (UV) ((U8) *s);
	    const STRLEN need = UVCHR_SKIP(nextuv);
	    if (!has_utf8) {
		SvCUR_set(sv, d - SvPVX_const(sv));
		SvPOK_on(sv);
		*d = '\0';
		/* See Note on sizing above.  */
		sv_utf8_upgrade_flags_grow(sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					need + (STRLEN)(send - s) + 1);
		d = SvPVX(sv) + SvCUR(sv);
		has_utf8 = TRUE;
	    } else if (need > len) {
		/* encoded value larger than old, may need extra space (NOTE:
		 * SvCUR() is not set correctly here).   See Note on sizing
		 * above.  */
		const STRLEN off = d - SvPVX_const(sv);
		d = SvGROW(sv, off + need + (STRLEN)(send - s) + 1) + off;
	    }
	    s += len;

	    d = (char*)uvchr_to_utf8((U8*)d, nextuv);
	}
	else {
	    *d++ = *s++;
	}
    } /* while loop to process each character */

    /* terminate the string and set up the sv */
    *d = '\0';
    SvCUR_set(sv, d - SvPVX_const(sv));
    if (SvCUR(sv) >= SvLEN(sv))
	Perl_croak(aTHX_ "panic: constant overflowed allocated space, %"UVuf
		   " >= %"UVuf, (UV)SvCUR(sv), (UV)SvLEN(sv));

    SvPOK_on(sv);
    if (IN_ENCODING && !has_utf8) {
	sv_recode_to_utf8(sv, _get_encoding());
	if (SvUTF8(sv))
	    has_utf8 = TRUE;
    }
    if (has_utf8) {
	SvUTF8_on(sv);
	if (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op) {
	    PL_sublex_info.sub_op->op_private |=
		    (PL_lex_repl ? OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF);
	}
    }

    /* shrink the sv if we allocated more than we used */
    if (SvCUR(sv) + 5 < SvLEN(sv)) {
	SvPV_shrink_to_cur(sv);
    }

    /* return the substring (via pl_yylval) only if we parsed anything */
    if (s > start) {
	char *s2 = start;
	for (; s2 < s; s2++) {
	    if (*s2 == '\n')
		COPLINE_INC_WITH_HERELINES;
	}
	SvREFCNT_inc_simple_void_NN(sv);
	if (   (PL_hints & ( PL_lex_inpat ? HINT_NEW_RE : HINT_NEW_STRING ))
            && ! PL_parser->lex_re_reparsing)
        {
	    const char *const key = PL_lex_inpat ? "qr" : "q";
	    const STRLEN keylen = PL_lex_inpat ? 2 : 1;
	    const char *type;
	    STRLEN typelen;

	    if (PL_lex_inwhat == OP_TRANS) {
		type = "tr";
		typelen = 2;
	    } else if (PL_lex_inwhat == OP_SUBST && !PL_lex_inpat) {
		type = "s";
		typelen = 1;
	    } else if (PL_lex_inpat && SvIVX(PL_linestr) == '\'') {
		type = "q";
		typelen = 1;
	    } else  {
		type = "qq";
		typelen = 2;
	    }

	    sv = S_new_constant(aTHX_ start, s - start, key, keylen, sv, NULL,
				type, typelen);
	}
	pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
    }
    LEAVE_with_name("scan_const");
    return s;
}

/* S_intuit_more
 * Returns TRUE if there's more to the expression (e.g., a subscript),
 * FALSE otherwise.
 *
 * It deals with "$foo[3]" and /$foo[3]/ and /$foo[0123456789$]+/
 *
 * ->[ and ->{ return TRUE
 * ->$* ->$#* ->@@* ->@@[ ->@@{ return TRUE if postderef_qq is enabled
 * { and [ outside a pattern are always subscripts, so return TRUE
 * if we're outside a pattern and it's not { or [, then return FALSE
 * if we're in a pattern and the first char is a {
 *   {4,5} (any digits around the comma) returns FALSE
 * if we're in a pattern and the first char is a [
 *   [] returns FALSE
 *   [SOMETHING] has a funky algorithm to decide whether it's a
 *      character class or not.  It has to deal with things like
 *      /$foo[-3]/ and /$foo[$bar]/ as well as /$foo[$\d]+/
 * anything else returns TRUE
 */

/* This is the one truly awful dwimmer necessary to conflate C and sed. */

STATIC int
S_intuit_more(pTHX_ char *s)
{
    PERL_ARGS_ASSERT_INTUIT_MORE;

    if (PL_lex_brackets)
	return TRUE;
    if (*s == '-' && s[1] == '>' && (s[2] == '[' || s[2] == '{'))
	return TRUE;
    if (*s == '-' && s[1] == '>'
     && FEATURE_POSTDEREF_QQ_IS_ENABLED
     && ( (s[2] == '$' && (s[3] == '*' || (s[3] == '#' && s[4] == '*')))
	||(s[2] == '@@' && strchr("*[{",s[3])) ))
	return TRUE;
    if (*s != '{' && *s != '[')
	return FALSE;
    if (!PL_lex_inpat)
	return TRUE;

    /* In a pattern, so maybe we have {n,m}. */
    if (*s == '{') {
	if (regcurly(s)) {
	    return FALSE;
	}
	return TRUE;
    }

    /* On the other hand, maybe we have a character class */

    s++;
    if (*s == ']' || *s == '^')
	return FALSE;
    else {
        /* this is terrifying, and it works */
	int weight;
	char seen[256];
	const char * const send = strchr(s,']');
	unsigned char un_char, last_un_char;
	char tmpbuf[sizeof PL_tokenbuf * 4];

	if (!send)		/* has to be an expression */
	    return TRUE;
	weight = 2;		/* let's weigh the evidence */

	if (*s == '$')
	    weight -= 3;
	else if (isDIGIT(*s)) {
	    if (s[1] != ']') {
		if (isDIGIT(s[1]) && s[2] == ']')
		    weight -= 10;
	    }
	    else
		weight -= 100;
	}
	Zero(seen,256,char);
	un_char = 255;
	for (; s < send; s++) {
	    last_un_char = un_char;
	    un_char = (unsigned char)*s;
	    switch (*s) {
	    case '@@':
	    case '&':
	    case '$':
		weight -= seen[un_char] * 10;
		if (isWORDCHAR_lazy_if(s+1,UTF)) {
		    int len;
                    char *tmp = PL_bufend;
                    PL_bufend = (char*)send;
                    scan_ident(s, tmpbuf, sizeof tmpbuf, FALSE);
                    PL_bufend = tmp;
		    len = (int)strlen(tmpbuf);
		    if (len > 1 && gv_fetchpvn_flags(tmpbuf, len,
                                                    UTF ? SVf_UTF8 : 0, SVt_PV))
			weight -= 100;
		    else
			weight -= 10;
		}
		else if (*s == '$'
                         && s[1]
                         && strchr("[#!%*<>()-=",s[1]))
                {
		    if (/*{*/ strchr("])} =",s[2]))
			weight -= 10;
		    else
			weight -= 1;
		}
		break;
	    case '\\':
		un_char = 254;
		if (s[1]) {
		    if (strchr("wds]",s[1]))
			weight += 100;
		    else if (seen[(U8)'\''] || seen[(U8)'"'])
			weight += 1;
		    else if (strchr("rnftbxcav",s[1]))
			weight += 40;
		    else if (isDIGIT(s[1])) {
			weight += 40;
			while (s[1] && isDIGIT(s[1]))
			    s++;
		    }
		}
		else
		    weight += 100;
		break;
	    case '-':
		if (s[1] == '\\')
		    weight += 50;
		if (strchr("aA01! ",last_un_char))
		    weight += 30;
		if (strchr("zZ79~",s[1]))
		    weight += 30;
		if (last_un_char == 255 && (isDIGIT(s[1]) || s[1] == '$'))
		    weight -= 5;	/* cope with negative subscript */
		break;
	    default:
		if (!isWORDCHAR(last_un_char)
		    && !(last_un_char == '$' || last_un_char == '@@'
			 || last_un_char == '&')
		    && isALPHA(*s) && s[1] && isALPHA(s[1])) {
		    char *d = s;
		    while (isALPHA(*s))
			s++;
		    if (keyword(d, s - d, 0))
			weight -= 150;
		}
		if (un_char == last_un_char + 1)
		    weight += 5;
		weight -= seen[un_char];
		break;
	    }
	    seen[un_char]++;
	}
	if (weight >= 0)	/* probably a character class */
	    return FALSE;
    }

    return TRUE;
}

/*
 * S_intuit_method
 *
 * Does all the checking to disambiguate
 *   foo bar
 * between foo(bar) and bar->foo.  Returns 0 if not a method, otherwise
 * FUNCMETH (bar->foo(args)) or METHOD (bar->foo args).
 *
 * First argument is the stuff after the first token, e.g. "bar".
 *
 * Not a method if foo is a filehandle.
 * Not a method if foo is a subroutine prototyped to take a filehandle.
 * Not a method if it's really "Foo $bar"
 * Method if it's "foo $bar"
 * Not a method if it's really "print foo $bar"
 * Method if it's really "foo package::" (interpreted as package->foo)
 * Not a method if bar is known to be a subroutine ("sub bar; foo bar")
 * Not a method if bar is a filehandle or package, but is quoted with
 *   =>
 */

STATIC int
S_intuit_method(pTHX_ char *start, SV *ioname, CV *cv)
{
    char *s = start + (*start == '$');
    char tmpbuf[sizeof PL_tokenbuf];
    STRLEN len;
    GV* indirgv;
	/* Mustn't actually add anything to a symbol table.
	   But also don't want to "initialise" any placeholder
	   constants that might already be there into full
	   blown PVGVs with attached PVCV.  */
    GV * const gv =
	ioname ? gv_fetchsv(ioname, GV_NOADD_NOINIT, SVt_PVCV) : NULL;

    PERL_ARGS_ASSERT_INTUIT_METHOD;

    if (gv && SvTYPE(gv) == SVt_PVGV && GvIO(gv))
	    return 0;
    if (cv && SvPOK(cv)) {
	const char *proto = CvPROTO(cv);
	if (proto) {
	    while (*proto && (isSPACE(*proto) || *proto == ';'))
		proto++;
	    if (*proto == '*')
		return 0;
	}
    }

    if (*start == '$') {
	if (cv || PL_last_lop_op == OP_PRINT || PL_last_lop_op == OP_SAY
            || isUPPER(*PL_tokenbuf))
	    return 0;
	s = skipspace(s);
	PL_bufptr = start;
	PL_expect = XREF;
	return *s == '(' ? FUNCMETH : METHOD;
    }

    s = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
    /* start is the beginning of the possible filehandle/object,
     * and s is the end of it
     * tmpbuf is a copy of it (but with single quotes as double colons)
     */

    if (!keyword(tmpbuf, len, 0)) {
	if (len > 2 && tmpbuf[len - 2] == ':' && tmpbuf[len - 1] == ':') {
	    len -= 2;
	    tmpbuf[len] = '\0';
	    goto bare_package;
	}
	indirgv = gv_fetchpvn_flags(tmpbuf, len, ( UTF ? SVf_UTF8 : 0 ), SVt_PVCV);
	if (indirgv && GvCVu(indirgv))
	    return 0;
	/* filehandle or package name makes it a method */
	if (!cv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, UTF ? SVf_UTF8 : 0)) {
	    s = skipspace(s);
	    if ((PL_bufend - s) >= 2 && *s == '=' && *(s+1) == '>')
		return 0;	/* no assumptions -- "=>" quotes bareword */
      bare_package:
	    NEXTVAL_NEXTTOKE.opval = (OP*)newSVOP(OP_CONST, 0,
						  S_newSV_maybe_utf8(aTHX_ tmpbuf, len));
	    NEXTVAL_NEXTTOKE.opval->op_private = OPpCONST_BARE;
	    PL_expect = XTERM;
	    force_next(WORD);
	    PL_bufptr = s;
	    return *s == '(' ? FUNCMETH : METHOD;
	}
    }
    return 0;
}

/* Encoded script support. filter_add() effectively inserts a
 * 'pre-processing' function into the current source input stream.
 * Note that the filter function only applies to the current source file
 * (e.g., it will not affect files 'require'd or 'use'd by this one).
 *
 * The datasv parameter (which may be NULL) can be used to pass
 * private data to this instance of the filter. The filter function
 * can recover the SV using the FILTER_DATA macro and use it to
 * store private buffers and state information.
 *
 * The supplied datasv parameter is upgraded to a PVIO type
 * and the IoDIRP/IoANY field is used to store the function pointer,
 * and IOf_FAKE_DIRP is enabled on datasv to mark this as such.
 * Note that IoTOP_NAME, IoFMT_NAME, IoBOTTOM_NAME, if set for
 * private use must be set using malloc'd pointers.
 */

SV *
Perl_filter_add(pTHX_ filter_t funcp, SV *datasv)
{
    if (!funcp)
	return NULL;

    if (!PL_parser)
	return NULL;

    if (PL_parser->lex_flags & LEX_IGNORE_UTF8_HINTS)
	Perl_croak(aTHX_ "Source filters apply only to byte streams");

    if (!PL_rsfp_filters)
	PL_rsfp_filters = newAV();
    if (!datasv)
	datasv = newSV(0);
    SvUPGRADE(datasv, SVt_PVIO);
    IoANY(datasv) = FPTR2DPTR(void *, funcp); /* stash funcp into spare field */
    IoFLAGS(datasv) |= IOf_FAKE_DIRP;
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_add func %p (%s)\n",
			  FPTR2DPTR(void *, IoANY(datasv)),
			  SvPV_nolen(datasv)));
    av_unshift(PL_rsfp_filters, 1);
    av_store(PL_rsfp_filters, 0, datasv) ;
    if (
	!PL_parser->filtered
     && PL_parser->lex_flags & LEX_EVALBYTES
     && PL_bufptr < PL_bufend
    ) {
	const char *s = PL_bufptr;
	while (s < PL_bufend) {
	    if (*s == '\n') {
		SV *linestr = PL_parser->linestr;
		char *buf = SvPVX(linestr);
		STRLEN const bufptr_pos = PL_parser->bufptr - buf;
		STRLEN const oldbufptr_pos = PL_parser->oldbufptr - buf;
		STRLEN const oldoldbufptr_pos=PL_parser->oldoldbufptr-buf;
		STRLEN const linestart_pos = PL_parser->linestart - buf;
		STRLEN const last_uni_pos =
		    PL_parser->last_uni ? PL_parser->last_uni - buf : 0;
		STRLEN const last_lop_pos =
		    PL_parser->last_lop ? PL_parser->last_lop - buf : 0;
		av_push(PL_rsfp_filters, linestr);
		PL_parser->linestr = 
		    newSVpvn(SvPVX(linestr), ++s-SvPVX(linestr));
		buf = SvPVX(PL_parser->linestr);
		PL_parser->bufend = buf + SvCUR(PL_parser->linestr);
		PL_parser->bufptr = buf + bufptr_pos;
		PL_parser->oldbufptr = buf + oldbufptr_pos;
		PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
		PL_parser->linestart = buf + linestart_pos;
		if (PL_parser->last_uni)
		    PL_parser->last_uni = buf + last_uni_pos;
		if (PL_parser->last_lop)
		    PL_parser->last_lop = buf + last_lop_pos;
		SvLEN(linestr) = SvCUR(linestr);
		SvCUR(linestr) = s-SvPVX(linestr);
		PL_parser->filtered = 1;
		break;
	    }
	    s++;
	}
    }
    return(datasv);
}


/* Delete most recently added instance of this filter function.	*/
void
Perl_filter_del(pTHX_ filter_t funcp)
{
    SV *datasv;

    PERL_ARGS_ASSERT_FILTER_DEL;

#ifdef DEBUGGING
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p",
			  FPTR2DPTR(void*, funcp)));
#endif
    if (!PL_parser || !PL_rsfp_filters || AvFILLp(PL_rsfp_filters)<0)
	return;
    /* if filter is on top of stack (usual case) just pop it off */
    datasv = FILTER_DATA(AvFILLp(PL_rsfp_filters));
    if (IoANY(datasv) == FPTR2DPTR(void *, funcp)) {
	sv_free(av_pop(PL_rsfp_filters));

        return;
    }
    /* we need to search for the correct entry and clear it	*/
    Perl_die(aTHX_ "filter_del can only delete in reverse order (currently)");
}


/* Invoke the idxth filter function for the current rsfp.	 */
/* maxlen 0 = read one text line */
I32
Perl_filter_read(pTHX_ int idx, SV *buf_sv, int maxlen)
{
    filter_t funcp;
    SV *datasv = NULL;
    /* This API is bad. It should have been using unsigned int for maxlen.
       Not sure if we want to change the API, but if not we should sanity
       check the value here.  */
    unsigned int correct_length = maxlen < 0 ?  PERL_INT_MAX : maxlen;

    PERL_ARGS_ASSERT_FILTER_READ;

    if (!PL_parser || !PL_rsfp_filters)
	return -1;
    if (idx > AvFILLp(PL_rsfp_filters)) {       /* Any more filters?	*/
	/* Provide a default input filter to make life easy.	*/
	/* Note that we append to the line. This is handy.	*/
	DEBUG_P(PerlIO_printf(Perl_debug_log,
			      "filter_read %d: from rsfp\n", idx));
	if (correct_length) {
 	    /* Want a block */
	    int len ;
	    const int old_len = SvCUR(buf_sv);

	    /* ensure buf_sv is large enough */
	    SvGROW(buf_sv, (STRLEN)(old_len + correct_length + 1)) ;
	    if ((len = PerlIO_read(PL_rsfp, SvPVX(buf_sv) + old_len,
				   correct_length)) <= 0) {
		if (PerlIO_error(PL_rsfp))
	            return -1;		/* error */
	        else
		    return 0 ;		/* end of file */
	    }
	    SvCUR_set(buf_sv, old_len + len) ;
	    SvPVX(buf_sv)[old_len + len] = '\0';
	} else {
	    /* Want a line */
            if (sv_gets(buf_sv, PL_rsfp, SvCUR(buf_sv)) == NULL) {
		if (PerlIO_error(PL_rsfp))
	            return -1;		/* error */
	        else
		    return 0 ;		/* end of file */
	    }
	}
	return SvCUR(buf_sv);
    }
    /* Skip this filter slot if filter has been deleted	*/
    if ( (datasv = FILTER_DATA(idx)) == &PL_sv_undef) {
	DEBUG_P(PerlIO_printf(Perl_debug_log,
			      "filter_read %d: skipped (filter deleted)\n",
			      idx));
	return FILTER_READ(idx+1, buf_sv, correct_length); /* recurse */
    }
    if (SvTYPE(datasv) != SVt_PVIO) {
	if (correct_length) {
 	    /* Want a block */
	    const STRLEN remainder = SvLEN(datasv) - SvCUR(datasv);
	    if (!remainder) return 0; /* eof */
	    if (correct_length > remainder) correct_length = remainder;
	    sv_catpvn(buf_sv, SvEND(datasv), correct_length);
	    SvCUR_set(datasv, SvCUR(datasv) + correct_length);
	} else {
	    /* Want a line */
	    const char *s = SvEND(datasv);
	    const char *send = SvPVX(datasv) + SvLEN(datasv);
	    while (s < send) {
		if (*s == '\n') {
		    s++;
		    break;
		}
		s++;
	    }
	    if (s == send) return 0; /* eof */
	    sv_catpvn(buf_sv, SvEND(datasv), s-SvEND(datasv));
	    SvCUR_set(datasv, s-SvPVX(datasv));
	}
	return SvCUR(buf_sv);
    }
    /* Get function pointer hidden within datasv	*/
    funcp = DPTR2FPTR(filter_t, IoANY(datasv));
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "filter_read %d: via function %p (%s)\n",
			  idx, (void*)datasv, SvPV_nolen_const(datasv)));
    /* Call function. The function is expected to 	*/
    /* call "FILTER_READ(idx+1, buf_sv)" first.		*/
    /* Return: <0:error, =0:eof, >0:not eof 		*/
    return (*funcp)(aTHX_ idx, buf_sv, correct_length);
}

STATIC char *
S_filter_gets(pTHX_ SV *sv, STRLEN append)
{
    PERL_ARGS_ASSERT_FILTER_GETS;

#ifdef PERL_CR_FILTER
    if (!PL_rsfp_filters) {
	filter_add(S_cr_textfilter,NULL);
    }
#endif
    if (PL_rsfp_filters) {
	if (!append)
            SvCUR_set(sv, 0);	/* start with empty line	*/
        if (FILTER_READ(0, sv, 0) > 0)
            return ( SvPVX(sv) ) ;
        else
	    return NULL ;
    }
    else
        return (sv_gets(sv, PL_rsfp, append));
}

STATIC HV *
S_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)
{
    GV *gv;

    PERL_ARGS_ASSERT_FIND_IN_MY_STASH;

    if (len == 11 && *pkgname == '_' && strEQ(pkgname, "__PACKAGE__"))
        return PL_curstash;

    if (len > 2
        && (pkgname[len - 2] == ':' && pkgname[len - 1] == ':')
        && (gv = gv_fetchpvn_flags(pkgname,
                                   len,
                                   ( UTF ? SVf_UTF8 : 0 ), SVt_PVHV)))
    {
        return GvHV(gv);			/* Foo:: */
    }

    /* use constant CLASS => 'MyClass' */
    gv = gv_fetchpvn_flags(pkgname, len, UTF ? SVf_UTF8 : 0, SVt_PVCV);
    if (gv && GvCV(gv)) {
	SV * const sv = cv_const_sv(GvCV(gv));
	if (sv)
	    return gv_stashsv(sv, 0);
    }

    return gv_stashpvn(pkgname, len, UTF ? SVf_UTF8 : 0);
}


STATIC char *
S_tokenize_use(pTHX_ int is_use, char *s) {
    PERL_ARGS_ASSERT_TOKENIZE_USE;

    if (PL_expect != XSTATE)
	yyerror(Perl_form(aTHX_ "\"%s\" not allowed in expression",
		    is_use ? "use" : "no"));
    PL_expect = XTERM;
    s = skipspace(s);
    if (isDIGIT(*s) || (*s == 'v' && isDIGIT(s[1]))) {
	s = force_version(s, TRUE);
	if (*s == ';' || *s == '}'
		|| (s = skipspace(s), (*s == ';' || *s == '}'))) {
	    NEXTVAL_NEXTTOKE.opval = NULL;
	    force_next(WORD);
	}
	else if (*s == 'v') {
	    s = force_word(s,WORD,FALSE,TRUE);
	    s = force_version(s, FALSE);
	}
    }
    else {
	s = force_word(s,WORD,FALSE,TRUE);
	s = force_version(s, FALSE);
    }
    pl_yylval.ival = is_use;
    return s;
}
#ifdef DEBUGGING
    static const char* const exp_name[] =
	{ "OPERATOR", "TERM", "REF", "STATE", "BLOCK", "ATTRBLOCK",
	  "ATTRTERM", "TERMBLOCK", "XBLOCKTERM", "POSTDEREF",
	  "TERMORDORDOR"
	};
#endif

#define word_takes_any_delimeter(p,l) S_word_takes_any_delimeter(p,l)
STATIC bool
S_word_takes_any_delimeter(char *p, STRLEN len)
{
    return (len == 1 && strchr("msyq", p[0]))
            || (len == 2
                && ((p[0] == 't' && p[1] == 'r')
                    || (p[0] == 'q' && strchr("qwxr", p[1]))));
}

static void
S_check_scalar_slice(pTHX_ char *s)
{
    s++;
    while (*s == ' ' || *s == '\t') s++;
    if (*s == 'q' && s[1] == 'w'
     && !isWORDCHAR_lazy_if(s+2,UTF))
	return;
    while (*s && (isWORDCHAR_lazy_if(s,UTF) || strchr(" \t$#+-'\"", *s)))
	s += UTF ? UTF8SKIP(s) : 1;
    if (*s == '}' || *s == ']')
	pl_yylval.ival = OPpSLICEWARNING;
}

/*
  yylex

  Works out what to call the token just pulled out of the input
  stream.  The yacc parser takes care of taking the ops we return and
  stitching them into a tree.

  Returns:
    The type of the next token

  Structure:
      Switch based on the current state:
	  - if we already built the token before, use it
	  - if we have a case modifier in a string, deal with that
	  - handle other cases of interpolation inside a string
	  - scan the next line if we are inside a format
      In the normal state switch on the next character:
	  - default:
	    if alphabetic, go to key lookup
	    unrecoginized character - croak
	  - 0/4/26: handle end-of-line or EOF
	  - cases for whitespace
	  - \n and #: handle comments and line numbers
	  - various operators, brackets and sigils
	  - numbers
	  - quotes
	  - 'v': vstrings (or go to key lookup)
	  - 'x' repetition operator (or go to key lookup)
	  - other ASCII alphanumerics (key lookup begins here):
	      word before => ?
	      keyword plugin
	      scan built-in keyword (but do nothing with it yet)
	      check for statement label
	      check for lexical subs
		  goto just_a_word if there is one
	      see whether built-in keyword is overridden
	      switch on keyword number:
		  - default: just_a_word:
		      not a built-in keyword; handle bareword lookup
		      disambiguate between method and sub call
		      fall back to bareword
		  - cases for built-in keywords
*/


int
Perl_yylex(pTHX)
{
    dVAR;
    char *s = PL_bufptr;
    char *d;
    STRLEN len;
    bool bof = FALSE;
    const bool saw_infix_sigil = cBOOL(PL_parser->saw_infix_sigil);
    U8 formbrack = 0;
    U32 fake_eof = 0;

    /* orig_keyword, gvp, and gv are initialized here because
     * jump to the label just_a_word_zero can bypass their
     * initialization later. */
    I32 orig_keyword = 0;
    GV *gv = NULL;
    GV **gvp = NULL;

    DEBUG_T( {
	SV* tmp = newSVpvs("");
	PerlIO_printf(Perl_debug_log, "### %"IVdf":LEX_%s/X%s %s\n",
	    (IV)CopLINE(PL_curcop),
	    lex_state_names[PL_lex_state],
	    exp_name[PL_expect],
	    pv_display(tmp, s, strlen(s), 0, 60));
	SvREFCNT_dec(tmp);
    } );

    /* when we've already built the next token, just pull it out of the queue */
    if (PL_nexttoke) {
	PL_nexttoke--;
	pl_yylval = PL_nextval[PL_nexttoke];
	if (!PL_nexttoke) {
	    PL_lex_state = PL_lex_defer;
	    PL_lex_defer = LEX_NORMAL;
	}
	{
	    I32 next_type;
	    next_type = PL_nexttype[PL_nexttoke];
	    if (next_type & (7<<24)) {
		if (next_type & (1<<24)) {
		    if (PL_lex_brackets > 100)
			Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
		    PL_lex_brackstack[PL_lex_brackets++] =
			(char) ((next_type >> 16) & 0xff);
		}
		if (next_type & (2<<24))
		    PL_lex_allbrackets++;
		if (next_type & (4<<24))
		    PL_lex_allbrackets--;
		next_type &= 0xffff;
	    }
	    return REPORT(next_type == 'p' ? pending_ident() : next_type);
	}
    }

    switch (PL_lex_state) {
    case LEX_NORMAL:
    case LEX_INTERPNORMAL:
	break;

    /* interpolated case modifiers like \L \U, including \Q and \E.
       when we get here, PL_bufptr is at the \
    */
    case LEX_INTERPCASEMOD:
#ifdef DEBUGGING
	if (PL_bufptr != PL_bufend && *PL_bufptr != '\\')
	    Perl_croak(aTHX_
		       "panic: INTERPCASEMOD bufptr=%p, bufend=%p, *bufptr=%u",
		       PL_bufptr, PL_bufend, *PL_bufptr);
#endif
	/* handle \E or end of string */
       	if (PL_bufptr == PL_bufend || PL_bufptr[1] == 'E') {
	    /* if at a \E */
	    if (PL_lex_casemods) {
		const char oldmod = PL_lex_casestack[--PL_lex_casemods];
		PL_lex_casestack[PL_lex_casemods] = '\0';

		if (PL_bufptr != PL_bufend
		    && (oldmod == 'L' || oldmod == 'U' || oldmod == 'Q'
                        || oldmod == 'F')) {
		    PL_bufptr += 2;
		    PL_lex_state = LEX_INTERPCONCAT;
		}
		PL_lex_allbrackets--;
		return REPORT(')');
	    }
            else if ( PL_bufptr != PL_bufend && PL_bufptr[1] == 'E' ) {
               /* Got an unpaired \E */
               Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
                        "Useless use of \\E");
            }
	    if (PL_bufptr != PL_bufend)
		PL_bufptr += 2;
	    PL_lex_state = LEX_INTERPCONCAT;
	    return yylex();
	}
	else {
	    DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Saw case modifier\n"); });
	    s = PL_bufptr + 1;
	    if (s[1] == '\\' && s[2] == 'E') {
	        PL_bufptr = s + 3;
		PL_lex_state = LEX_INTERPCONCAT;
		return yylex();
	    }
	    else {
		I32 tmp;
                if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
                    tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
		if ((*s == 'L' || *s == 'U' || *s == 'F')
                    && (strchr(PL_lex_casestack, 'L')
                        || strchr(PL_lex_casestack, 'U')
                        || strchr(PL_lex_casestack, 'F')))
                {
		    PL_lex_casestack[--PL_lex_casemods] = '\0';
		    PL_lex_allbrackets--;
		    return REPORT(')');
		}
		if (PL_lex_casemods > 10)
		    Renew(PL_lex_casestack, PL_lex_casemods + 2, char);
		PL_lex_casestack[PL_lex_casemods++] = *s;
		PL_lex_casestack[PL_lex_casemods] = '\0';
		PL_lex_state = LEX_INTERPCONCAT;
		NEXTVAL_NEXTTOKE.ival = 0;
		force_next((2<<24)|'(');
		if (*s == 'l')
		    NEXTVAL_NEXTTOKE.ival = OP_LCFIRST;
		else if (*s == 'u')
		    NEXTVAL_NEXTTOKE.ival = OP_UCFIRST;
		else if (*s == 'L')
		    NEXTVAL_NEXTTOKE.ival = OP_LC;
		else if (*s == 'U')
		    NEXTVAL_NEXTTOKE.ival = OP_UC;
		else if (*s == 'Q')
		    NEXTVAL_NEXTTOKE.ival = OP_QUOTEMETA;
                else if (*s == 'F')
		    NEXTVAL_NEXTTOKE.ival = OP_FC;
		else
		    Perl_croak(aTHX_ "panic: yylex, *s=%u", *s);
		PL_bufptr = s + 1;
	    }
	    force_next(FUNC);
	    if (PL_lex_starts) {
		s = PL_bufptr;
		PL_lex_starts = 0;
		/* commas only at base level: /$a\Ub$c/ => ($a,uc(b.$c)) */
		if (PL_lex_casemods == 1 && PL_lex_inpat)
		    TOKEN(',');
		else
		    AopNOASSIGN(OP_CONCAT);
	    }
	    else
		return yylex();
	}

    case LEX_INTERPPUSH:
        return REPORT(sublex_push());

    case LEX_INTERPSTART:
	if (PL_bufptr == PL_bufend)
	    return REPORT(sublex_done());
	DEBUG_T({ if(*PL_bufptr != '(') PerlIO_printf(Perl_debug_log,
              "### Interpolated variable\n"); });
	PL_expect = XTERM;
        /* for /@@a/, we leave the joining for the regex engine to do
         * (unless we're within \Q etc) */
	PL_lex_dojoin = (*PL_bufptr == '@@'
                            && (!PL_lex_inpat || PL_lex_casemods));
	PL_lex_state = LEX_INTERPNORMAL;
	if (PL_lex_dojoin) {
	    NEXTVAL_NEXTTOKE.ival = 0;
	    force_next(',');
	    force_ident("\"", '$');
	    NEXTVAL_NEXTTOKE.ival = 0;
	    force_next('$');
	    NEXTVAL_NEXTTOKE.ival = 0;
	    force_next((2<<24)|'(');
	    NEXTVAL_NEXTTOKE.ival = OP_JOIN;	/* emulate join($", ...) */
	    force_next(FUNC);
	}
	/* Convert (?{...}) and friends to 'do {...}' */
	if (PL_lex_inpat && *PL_bufptr == '(') {
	    PL_parser->lex_shared->re_eval_start = PL_bufptr;
	    PL_bufptr += 2;
	    if (*PL_bufptr != '{')
		PL_bufptr++;
	    PL_expect = XTERMBLOCK;
	    force_next(DO);
	}

	if (PL_lex_starts++) {
	    s = PL_bufptr;
	    /* commas only at base level: /$a\Ub$c/ => ($a,uc(b.$c)) */
	    if (!PL_lex_casemods && PL_lex_inpat)
		TOKEN(',');
	    else
		AopNOASSIGN(OP_CONCAT);
	}
	return yylex();

    case LEX_INTERPENDMAYBE:
	if (intuit_more(PL_bufptr)) {
	    PL_lex_state = LEX_INTERPNORMAL;	/* false alarm, more expr */
	    break;
	}
	/* FALLTHROUGH */

    case LEX_INTERPEND:
	/* Treat state as LEX_NORMAL if we have no inner lexing scope.
	   XXX This hack can be removed if we stop setting PL_lex_state to
	   LEX_KNOWNEXT, as can the hack under LEX_INTREPCONCAT below.  */
	if (UNLIKELY(!PL_lex_inwhat)) {
	    PL_lex_state = LEX_NORMAL;
	    break;
	}

	if (PL_lex_dojoin) {
	    const U8 dojoin_was = PL_lex_dojoin;
	    PL_lex_dojoin = FALSE;
	    PL_lex_state = LEX_INTERPCONCAT;
	    PL_lex_allbrackets--;
	    return REPORT(dojoin_was == 1 ? ')' : POSTJOIN);
	}
	if (PL_lex_inwhat == OP_SUBST && PL_linestr == PL_lex_repl
	    && SvEVALED(PL_lex_repl))
	{
	    if (PL_bufptr != PL_bufend)
		Perl_croak(aTHX_ "Bad evalled substitution pattern");
	    PL_lex_repl = NULL;
	}
	/* Paranoia.  re_eval_start is adjusted when S_scan_heredoc sets
	   re_eval_str.  If the here-doc bodys length equals the previous
	   value of re_eval_start, re_eval_start will now be null.  So
	   check re_eval_str as well. */
	if (PL_parser->lex_shared->re_eval_start
	 || PL_parser->lex_shared->re_eval_str) {
	    SV *sv;
	    if (*PL_bufptr != ')')
		Perl_croak(aTHX_ "Sequence (?{...}) not terminated with ')'");
	    PL_bufptr++;
	    /* having compiled a (?{..}) expression, return the original
	     * text too, as a const */
	    if (PL_parser->lex_shared->re_eval_str) {
		sv = PL_parser->lex_shared->re_eval_str;
		PL_parser->lex_shared->re_eval_str = NULL;
		SvCUR_set(sv,
			 PL_bufptr - PL_parser->lex_shared->re_eval_start);
		SvPV_shrink_to_cur(sv);
	    }
	    else sv = newSVpvn(PL_parser->lex_shared->re_eval_start,
			 PL_bufptr - PL_parser->lex_shared->re_eval_start);
	    NEXTVAL_NEXTTOKE.opval =
		    (OP*)newSVOP(OP_CONST, 0,
				 sv);
	    force_next(THING);
	    PL_parser->lex_shared->re_eval_start = NULL;
	    PL_expect = XTERM;
	    return REPORT(',');
	}

	/* FALLTHROUGH */
    case LEX_INTERPCONCAT:
#ifdef DEBUGGING
	if (PL_lex_brackets)
	    Perl_croak(aTHX_ "panic: INTERPCONCAT, lex_brackets=%ld",
		       (long) PL_lex_brackets);
#endif
	/* Treat state as LEX_NORMAL when not in an inner lexing scope.
	   XXX This hack can be removed if we stop setting PL_lex_state to
	   LEX_KNOWNEXT.  */
	if (UNLIKELY(!PL_lex_inwhat)) {
	    PL_lex_state = LEX_NORMAL;
	    break;
	}

	if (PL_bufptr == PL_bufend)
	    return REPORT(sublex_done());

	/* m'foo' still needs to be parsed for possible (?{...}) */
	if (SvIVX(PL_linestr) == '\'' && !PL_lex_inpat) {
	    SV *sv = newSVsv(PL_linestr);
	    sv = tokeq(sv);
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
	    s = PL_bufend;
	}
	else {
	    s = scan_const(PL_bufptr);
	    if (*s == '\\')
		PL_lex_state = LEX_INTERPCASEMOD;
	    else
		PL_lex_state = LEX_INTERPSTART;
	}

	if (s != PL_bufptr) {
	    NEXTVAL_NEXTTOKE = pl_yylval;
	    PL_expect = XTERM;
	    force_next(THING);
	    if (PL_lex_starts++) {
		/* commas only at base level: /$a\Ub$c/ => ($a,uc(b.$c)) */
		if (!PL_lex_casemods && PL_lex_inpat)
		    TOKEN(',');
		else
		    AopNOASSIGN(OP_CONCAT);
	    }
	    else {
		PL_bufptr = s;
		return yylex();
	    }
	}

	return yylex();
    case LEX_FORMLINE:
	s = scan_formline(PL_bufptr);
	if (!PL_lex_formbrack)
	{
	    formbrack = 1;
	    goto rightbracket;
	}
	PL_bufptr = s;
	return yylex();
    }

    /* We really do *not* want PL_linestr ever becoming a COW. */
    assert (!SvIsCOW(PL_linestr));
    s = PL_bufptr;
    PL_oldoldbufptr = PL_oldbufptr;
    PL_oldbufptr = s;
    PL_parser->saw_infix_sigil = 0;

  retry:
    switch (*s) {
    default:
	if (UTF) {
            if (! isUTF8_CHAR((U8 *) s, (U8 *) PL_bufend)) {
                ENTER;
                SAVESPTR(PL_warnhook);
                PL_warnhook = PERL_WARNHOOK_FATAL;
                utf8n_to_uvchr((U8*)s, PL_bufend-s, NULL, 0);
                LEAVE;
            }
            if (isIDFIRST_utf8((U8*)s)) {
                goto keylookup;
            }
        }
        else if (isALNUMC(*s)) {
	    goto keylookup;
	}
    {
        SV *dsv = newSVpvs_flags("", SVs_TEMP);
        const char *c = UTF ? sv_uni_display(dsv, newSVpvn_flags(s,
                                                    UTF8SKIP(s),
                                                    SVs_TEMP | SVf_UTF8),
                                            10, UNI_DISPLAY_ISPRINT)
                            : Perl_form(aTHX_ "\\x%02X", (unsigned char)*s);
        len = UTF ? Perl_utf8_length(aTHX_ (U8 *) PL_linestart, (U8 *) s) : (STRLEN) (s - PL_linestart);
        if (len > UNRECOGNIZED_PRECEDE_COUNT) {
            d = UTF ? (char *) utf8_hop((U8 *) s, -UNRECOGNIZED_PRECEDE_COUNT) : s - UNRECOGNIZED_PRECEDE_COUNT;
        } else {
            d = PL_linestart;
        }
        Perl_croak(aTHX_  "Unrecognized character %s; marked by <-- HERE after %"UTF8f"<-- HERE near column %d", c,
                          UTF8fARG(UTF, (s - d), d),
                         (int) len + 1);
    }
    case 4:
    case 26:
	goto fake_eof;			/* emulate EOF on ^D or ^Z */
    case 0:
	if ((!PL_rsfp || PL_lex_inwhat)
	 && (!PL_parser->filtered || s+1 < PL_bufend)) {
	    PL_last_uni = 0;
	    PL_last_lop = 0;
	    if (PL_lex_brackets
                && PL_lex_brackstack[PL_lex_brackets-1] != XFAKEEOF)
            {
		yyerror((const char *)
			(PL_lex_formbrack
			 ? "Format not terminated"
			 : "Missing right curly or square bracket"));
	    }
            DEBUG_T( { PerlIO_printf(Perl_debug_log,
                        "### Tokener got EOF\n");
            } );
	    TOKEN(0);
	}
	if (s++ < PL_bufend)
	    goto retry;			/* ignore stray nulls */
	PL_last_uni = 0;
	PL_last_lop = 0;
	if (!PL_in_eval && !PL_preambled) {
	    PL_preambled = TRUE;
	    if (PL_perldb) {
		/* Generate a string of Perl code to load the debugger.
		 * If PERL5DB is set, it will return the contents of that,
		 * otherwise a compile-time require of perl5db.pl.  */

		const char * const pdb = PerlEnv_getenv("PERL5DB");

		if (pdb) {
		    sv_setpv(PL_linestr, pdb);
		    sv_catpvs(PL_linestr,";");
		} else {
		    SETERRNO(0,SS_NORMAL);
		    sv_setpvs(PL_linestr, "BEGIN { require 'perl5db.pl' };");
		}
		PL_parser->preambling = CopLINE(PL_curcop);
	    } else
		sv_setpvs(PL_linestr,"");
	    if (PL_preambleav) {
		SV **svp = AvARRAY(PL_preambleav);
		SV **const end = svp + AvFILLp(PL_preambleav);
		while(svp <= end) {
		    sv_catsv(PL_linestr, *svp);
		    ++svp;
		    sv_catpvs(PL_linestr, ";");
		}
		sv_free(MUTABLE_SV(PL_preambleav));
		PL_preambleav = NULL;
	    }
	    if (PL_minus_E)
		sv_catpvs(PL_linestr,
			  "use feature ':5." STRINGIFY(PERL_VERSION) "';");
	    if (PL_minus_n || PL_minus_p) {
		sv_catpvs(PL_linestr, "LINE: while (<>) {"/*}*/);
		if (PL_minus_l)
		    sv_catpvs(PL_linestr,"chomp;");
		if (PL_minus_a) {
		    if (PL_minus_F) {
			if ((*PL_splitstr == '/' || *PL_splitstr == '\''
			     || *PL_splitstr == '"')
			      && strchr(PL_splitstr + 1, *PL_splitstr))
			    Perl_sv_catpvf(aTHX_ PL_linestr, "our @@F=split(%s);", PL_splitstr);
			else {
			    /* "q\0${splitstr}\0" is legal perl. Yes, even NUL
			       bytes can be used as quoting characters.  :-) */
			    const char *splits = PL_splitstr;
			    sv_catpvs(PL_linestr, "our @@F=split(q\0");
			    do {
				/* Need to \ \s  */
				if (*splits == '\\')
				    sv_catpvn(PL_linestr, splits, 1);
				sv_catpvn(PL_linestr, splits, 1);
			    } while (*splits++);
			    /* This loop will embed the trailing NUL of
			       PL_linestr as the last thing it does before
			       terminating.  */
			    sv_catpvs(PL_linestr, ");");
			}
		    }
		    else
		        sv_catpvs(PL_linestr,"our @@F=split(' ');");
		}
	    }
	    sv_catpvs(PL_linestr, "\n");
	    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
	    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	    PL_last_lop = PL_last_uni = NULL;
	    if (PERLDB_LINE_OR_SAVESRC && PL_curstash != PL_debstash)
		update_debugger_info(PL_linestr, NULL, 0);
	    goto retry;
	}
	do {
	    fake_eof = 0;
	    bof = PL_rsfp ? TRUE : FALSE;
	    if (0) {
	      fake_eof:
		fake_eof = LEX_FAKE_EOF;
	    }
	    PL_bufptr = PL_bufend;
	    COPLINE_INC_WITH_HERELINES;
	    if (!lex_next_chunk(fake_eof)) {
		CopLINE_dec(PL_curcop);
		s = PL_bufptr;
		TOKEN(';');	/* not infinite loop because rsfp is NULL now */
	    }
	    CopLINE_dec(PL_curcop);
	    s = PL_bufptr;
	    /* If it looks like the start of a BOM or raw UTF-16,
	     * check if it in fact is. */
	    if (bof && PL_rsfp
                && (*s == 0
                    || *(U8*)s == BOM_UTF8_FIRST_BYTE
                        || *(U8*)s >= 0xFE
                        || s[1] == 0))
            {
		Off_t offset = (IV)PerlIO_tell(PL_rsfp);
		bof = (offset == (Off_t)SvCUR(PL_linestr));
#if defined(PERLIO_USING_CRLF) && defined(PERL_TEXTMODE_SCRIPTS)
		/* offset may include swallowed CR */
		if (!bof)
		    bof = (offset == (Off_t)SvCUR(PL_linestr)+1);
#endif
		if (bof) {
		    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
		    s = swallow_bom((U8*)s);
		}
	    }
	    if (PL_parser->in_pod) {
		/* Incest with pod. */
		if (*s == '=' && strnEQ(s, "=cut", 4) && !isALPHA(s[4])) {
		    sv_setpvs(PL_linestr, "");
		    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
		    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
		    PL_last_lop = PL_last_uni = NULL;
		    PL_parser->in_pod = 0;
		}
	    }
	    if (PL_rsfp || PL_parser->filtered)
		incline(s);
	} while (PL_parser->in_pod);
	PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = s;
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	PL_last_lop = PL_last_uni = NULL;
	if (CopLINE(PL_curcop) == 1) {
	    while (s < PL_bufend && isSPACE(*s))
		s++;
	    if (*s == ':' && s[1] != ':') /* for csh execing sh scripts */
		s++;
	    d = NULL;
	    if (!PL_in_eval) {
		if (*s == '#' && *(s+1) == '!')
		    d = s + 2;
#ifdef ALTERNATE_SHEBANG
		else {
		    static char const as[] = ALTERNATE_SHEBANG;
		    if (*s == as[0] && strnEQ(s, as, sizeof(as) - 1))
			d = s + (sizeof(as) - 1);
		}
#endif /* ALTERNATE_SHEBANG */
	    }
	    if (d) {
		char *ipath;
		char *ipathend;

		while (isSPACE(*d))
		    d++;
		ipath = d;
		while (*d && !isSPACE(*d))
		    d++;
		ipathend = d;

#ifdef ARG_ZERO_IS_SCRIPT
		if (ipathend > ipath) {
		    /*
		     * HP-UX (at least) sets argv[0] to the script name,
		     * which makes $^X incorrect.  And Digital UNIX and Linux,
		     * at least, set argv[0] to the basename of the Perl
		     * interpreter. So, having found "#!", we'll set it right.
		     */
                    SV* copfilesv = CopFILESV(PL_curcop);
                    if (copfilesv) {
                        SV * const x =
                            GvSV(gv_fetchpvs("\030", GV_ADD|GV_NOTQUAL,
                                             SVt_PV)); /* $^X */
                        assert(SvPOK(x) || SvGMAGICAL(x));
                        if (sv_eq(x, copfilesv)) {
                            sv_setpvn(x, ipath, ipathend - ipath);
                            SvSETMAGIC(x);
                        }
                        else {
                            STRLEN blen;
                            STRLEN llen;
                            const char *bstart = SvPV_const(copfilesv, blen);
                            const char * const lstart = SvPV_const(x, llen);
                            if (llen < blen) {
                                bstart += blen - llen;
                                if (strnEQ(bstart, lstart, llen) &&	bstart[-1] == '/') {
                                    sv_setpvn(x, ipath, ipathend - ipath);
                                    SvSETMAGIC(x);
                                }
                            }
			}
                    }
                    else {
                        /* Anything to do if no copfilesv? */
		    }
		    TAINT_NOT;	/* $^X is always tainted, but that's OK */
		}
#endif /* ARG_ZERO_IS_SCRIPT */

		/*
		 * Look for options.
		 */
		d = instr(s,"perl -");
		if (!d) {
		    d = instr(s,"perl");
#if defined(DOSISH)
		    /* avoid getting into infinite loops when shebang
		     * line contains "Perl" rather than "perl" */
		    if (!d) {
			for (d = ipathend-4; d >= ipath; --d) {
			    if (isALPHA_FOLD_EQ(*d, 'p')
				&& !ibcmp(d, "perl", 4))
			    {
				break;
			    }
			}
			if (d < ipath)
			    d = NULL;
		    }
#endif
		}
#ifdef ALTERNATE_SHEBANG
		/*
		 * If the ALTERNATE_SHEBANG on this system starts with a
		 * character that can be part of a Perl expression, then if
		 * we see it but not "perl", we're probably looking at the
		 * start of Perl code, not a request to hand off to some
		 * other interpreter.  Similarly, if "perl" is there, but
		 * not in the first 'word' of the line, we assume the line
		 * contains the start of the Perl program.
		 */
		if (d && *s != '#') {
		    const char *c = ipath;
		    while (*c && !strchr("; \t\r\n\f\v#", *c))
			c++;
		    if (c < d)
			d = NULL;	/* "perl" not in first word; ignore */
		    else
			*s = '#';	/* Don't try to parse shebang line */
		}
#endif /* ALTERNATE_SHEBANG */
		if (!d
                    && *s == '#'
                    && ipathend > ipath
                    && !PL_minus_c
                    && !instr(s,"indir")
                    && instr(PL_origargv[0],"perl"))
		{
		    dVAR;
		    char **newargv;

		    *ipathend = '\0';
		    s = ipathend + 1;
		    while (s < PL_bufend && isSPACE(*s))
			s++;
		    if (s < PL_bufend) {
			Newx(newargv,PL_origargc+3,char*);
			newargv[1] = s;
			while (s < PL_bufend && !isSPACE(*s))
			    s++;
			*s = '\0';
			Copy(PL_origargv+1, newargv+2, PL_origargc+1, char*);
		    }
		    else
			newargv = PL_origargv;
		    newargv[0] = ipath;
		    PERL_FPU_PRE_EXEC
		    PerlProc_execv(ipath, EXEC_ARGV_CAST(newargv));
		    PERL_FPU_POST_EXEC
		    Perl_croak(aTHX_ "Can't exec %s", ipath);
		}
		if (d) {
		    while (*d && !isSPACE(*d))
			d++;
		    while (SPACE_OR_TAB(*d))
			d++;

		    if (*d++ == '-') {
			const bool switches_done = PL_doswitches;
			const U32 oldpdb = PL_perldb;
			const bool oldn = PL_minus_n;
			const bool oldp = PL_minus_p;
			const char *d1 = d;

			do {
			    bool baduni = FALSE;
			    if (*d1 == 'C') {
				const char *d2 = d1 + 1;
				if (parse_unicode_opts((const char **)&d2)
				    != PL_unicode)
				    baduni = TRUE;
			    }
			    if (baduni || isALPHA_FOLD_EQ(*d1, 'M')) {
				const char * const m = d1;
				while (*d1 && !isSPACE(*d1))
				    d1++;
				Perl_croak(aTHX_ "Too late for \"-%.*s\" option",
				      (int)(d1 - m), m);
			    }
			    d1 = moreswitches(d1);
			} while (d1);
			if (PL_doswitches && !switches_done) {
			    int argc = PL_origargc;
			    char **argv = PL_origargv;
			    do {
				argc--,argv++;
			    } while (argc && argv[0][0] == '-' && argv[0][1]);
			    init_argv_symbols(argc,argv);
			}
			if (   (PERLDB_LINE_OR_SAVESRC && !oldpdb)
                            || ((PL_minus_n || PL_minus_p) && !(oldn || oldp)))
			      /* if we have already added "LINE: while (<>) {",
			         we must not do it again */
			{
			    sv_setpvs(PL_linestr, "");
			    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
			    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
			    PL_last_lop = PL_last_uni = NULL;
			    PL_preambled = FALSE;
			    if (PERLDB_LINE_OR_SAVESRC)
				(void)gv_fetchfile(PL_origfilename);
			    goto retry;
			}
		    }
		}
	    }
	}
	if (PL_lex_formbrack && PL_lex_brackets <= PL_lex_formbrack) {
	    PL_lex_state = LEX_FORMLINE;
	    force_next(FORMRBRACK);
	    TOKEN(';');
	}
	goto retry;
    case '\r':
#ifdef PERL_STRICT_CR
	Perl_warn(aTHX_ "Illegal character \\%03o (carriage return)", '\r');
	Perl_croak(aTHX_
      "\t(Maybe you didn't strip carriage returns after a network transfer?)\n");
#endif
    case ' ': case '\t': case '\f': case '\v':
	s++;
	goto retry;
    case '#':
    case '\n':
	if (PL_lex_state != LEX_NORMAL
            || (PL_in_eval && !PL_rsfp && !PL_parser->filtered))
        {
            const bool in_comment = *s == '#';
	    if (*s == '#' && s == PL_linestart && PL_in_eval
	     && !PL_rsfp && !PL_parser->filtered) {
		/* handle eval qq[#line 1 "foo"\n ...] */
		CopLINE_dec(PL_curcop);
		incline(s);
	    }
            d = s;
            while (d < PL_bufend && *d != '\n')
                d++;
            if (d < PL_bufend)
                d++;
            else if (d > PL_bufend)
                /* Found by Ilya: feed random input to Perl. */
                Perl_croak(aTHX_ "panic: input overflow, %p > %p",
                           d, PL_bufend);
            s = d;
            if (in_comment && d == PL_bufend
                && PL_lex_state == LEX_INTERPNORMAL
                && PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
                && SvEVALED(PL_lex_repl) && d[-1] == '}') s--;
            else
                incline(s);
	    if (PL_lex_formbrack && PL_lex_brackets <= PL_lex_formbrack) {
		PL_lex_state = LEX_FORMLINE;
		force_next(FORMRBRACK);
		TOKEN(';');
	    }
	}
	else {
            while (s < PL_bufend && *s != '\n')
                s++;
            if (s < PL_bufend)
                {
                    s++;
                    if (s < PL_bufend)
                        incline(s);
                }
            else if (s > PL_bufend)
                /* Found by Ilya: feed random input to Perl. */
                Perl_croak(aTHX_ "panic: input overflow");
	}
	goto retry;
    case '-':
	if (s[1] && isALPHA(s[1]) && !isWORDCHAR(s[2])) {
	    I32 ftst = 0;
	    char tmp;

	    s++;
	    PL_bufptr = s;
	    tmp = *s++;

	    while (s < PL_bufend && SPACE_OR_TAB(*s))
		s++;

	    if (strnEQ(s,"=>",2)) {
		s = force_word(PL_bufptr,WORD,FALSE,FALSE);
		DEBUG_T( { printbuf("### Saw unary minus before =>, forcing word %s\n", s); } );
		OPERATOR('-');		/* unary minus */
	    }
	    switch (tmp) {
	    case 'r': ftst = OP_FTEREAD;	break;
	    case 'w': ftst = OP_FTEWRITE;	break;
	    case 'x': ftst = OP_FTEEXEC;	break;
	    case 'o': ftst = OP_FTEOWNED;	break;
	    case 'R': ftst = OP_FTRREAD;	break;
	    case 'W': ftst = OP_FTRWRITE;	break;
	    case 'X': ftst = OP_FTREXEC;	break;
	    case 'O': ftst = OP_FTROWNED;	break;
	    case 'e': ftst = OP_FTIS;		break;
	    case 'z': ftst = OP_FTZERO;		break;
	    case 's': ftst = OP_FTSIZE;		break;
	    case 'f': ftst = OP_FTFILE;		break;
	    case 'd': ftst = OP_FTDIR;		break;
	    case 'l': ftst = OP_FTLINK;		break;
	    case 'p': ftst = OP_FTPIPE;		break;
	    case 'S': ftst = OP_FTSOCK;		break;
	    case 'u': ftst = OP_FTSUID;		break;
	    case 'g': ftst = OP_FTSGID;		break;
	    case 'k': ftst = OP_FTSVTX;		break;
	    case 'b': ftst = OP_FTBLK;		break;
	    case 'c': ftst = OP_FTCHR;		break;
	    case 't': ftst = OP_FTTTY;		break;
	    case 'T': ftst = OP_FTTEXT;		break;
	    case 'B': ftst = OP_FTBINARY;	break;
	    case 'M': case 'A': case 'C':
		gv_fetchpvs("\024", GV_ADD|GV_NOTQUAL, SVt_PV);
		switch (tmp) {
		case 'M': ftst = OP_FTMTIME;	break;
		case 'A': ftst = OP_FTATIME;	break;
		case 'C': ftst = OP_FTCTIME;	break;
		default:			break;
		}
		break;
	    default:
		break;
	    }
	    if (ftst) {
                PL_last_uni = PL_oldbufptr;
		PL_last_lop_op = (OPCODE)ftst;
		DEBUG_T( { PerlIO_printf(Perl_debug_log,
                        "### Saw file test %c\n", (int)tmp);
		} );
		FTST(ftst);
	    }
	    else {
		/* Assume it was a minus followed by a one-letter named
		 * subroutine call (or a -bareword), then. */
		DEBUG_T( { PerlIO_printf(Perl_debug_log,
			"### '-%c' looked like a file test but was not\n",
			(int) tmp);
		} );
		s = --PL_bufptr;
	    }
	}
	{
	    const char tmp = *s++;
	    if (*s == tmp) {
		s++;
		if (PL_expect == XOPERATOR)
		    TERM(POSTDEC);
		else
		    OPERATOR(PREDEC);
	    }
	    else if (*s == '>') {
		s++;
		s = skipspace(s);
		if (((*s == '$' || *s == '&') && s[1] == '*')
		  ||(*s == '$' && s[1] == '#' && s[2] == '*')
		  ||((*s == '@@' || *s == '%') && strchr("*[{", s[1]))
		  ||(*s == '*' && (s[1] == '*' || s[1] == '{'))
		 )
		{
		    PL_expect = XPOSTDEREF;
		    TOKEN(ARROW);
		}
		if (isIDFIRST_lazy_if(s,UTF)) {
		    s = force_word(s,METHOD,FALSE,TRUE);
		    TOKEN(ARROW);
		}
		else if (*s == '$')
		    OPERATOR(ARROW);
		else
		    TERM(ARROW);
	    }
	    if (PL_expect == XOPERATOR) {
		if (*s == '='
                    && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
		    s--;
		    TOKEN(0);
		}
		Aop(OP_SUBTRACT);
	    }
	    else {
		if (isSPACE(*s) || !isSPACE(*PL_bufptr))
		    check_uni();
		OPERATOR('-');		/* unary minus */
	    }
	}

    case '+':
	{
	    const char tmp = *s++;
	    if (*s == tmp) {
		s++;
		if (PL_expect == XOPERATOR)
		    TERM(POSTINC);
		else
		    OPERATOR(PREINC);
	    }
	    if (PL_expect == XOPERATOR) {
		if (*s == '='
                    && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
		    s--;
		    TOKEN(0);
		}
		Aop(OP_ADD);
	    }
	    else {
		if (isSPACE(*s) || !isSPACE(*PL_bufptr))
		    check_uni();
		OPERATOR('+');
	    }
	}

    case '*':
	if (PL_expect == XPOSTDEREF) POSTDEREF('*');
	if (PL_expect != XOPERATOR) {
	    s = scan_ident(s, PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
	    PL_expect = XOPERATOR;
	    force_ident(PL_tokenbuf, '*');
	    if (!*PL_tokenbuf)
		PREREF('*');
	    TERM('*');
	}
	s++;
	if (*s == '*') {
	    s++;
	    if (*s == '=' && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
		s -= 2;
		TOKEN(0);
	    }
	    PWop(OP_POW);
	}
	if (*s == '='
            && !PL_lex_allbrackets
            && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
        {
	    s--;
	    TOKEN(0);
	}
	PL_parser->saw_infix_sigil = 1;
	Mop(OP_MULTIPLY);

    case '%':
    {
	if (PL_expect == XOPERATOR) {
	    if (s[1] == '='
                && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
		TOKEN(0);
            }
	    ++s;
	    PL_parser->saw_infix_sigil = 1;
	    Mop(OP_MODULO);
	}
	else if (PL_expect == XPOSTDEREF) POSTDEREF('%');
	PL_tokenbuf[0] = '%';
	s = scan_ident(s, PL_tokenbuf + 1,
		sizeof PL_tokenbuf - 1, FALSE);
	pl_yylval.ival = 0;
	if (!PL_tokenbuf[1]) {
	    PREREF('%');
	}
	if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop) && intuit_more(s)) {
	    if (*s == '[')
		PL_tokenbuf[0] = '@@';
	}
	PL_expect = XOPERATOR;
	force_ident_maybe_lex('%');
	TERM('%');
    }
    case '^':
	d = s;
	bof = FEATURE_BITWISE_IS_ENABLED;
	if (bof && s[1] == '.')
	    s++;
	if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		(s[1] == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_BITWISE))
	{
	    s = d;
	    TOKEN(0);
	}
	s++;
	BOop(bof ? d == s-2 ? OP_SBIT_XOR : OP_NBIT_XOR : OP_BIT_XOR);
    case '[':
	if (PL_lex_brackets > 100)
	    Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
	PL_lex_brackstack[PL_lex_brackets++] = 0;
	PL_lex_allbrackets++;
	{
	    const char tmp = *s++;
	    OPERATOR(tmp);
	}
    case '~':
	if (s[1] == '~'
	    && (PL_expect == XOPERATOR || PL_expect == XTERMORDORDOR))
	{
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		TOKEN(0);
	    s += 2;
            Perl_ck_warner_d(aTHX_
                packWARN(WARN_EXPERIMENTAL__SMARTMATCH),
                "Smartmatch is experimental");
	    Eop(OP_SMARTMATCH);
	}
	s++;
	if ((bof = FEATURE_BITWISE_IS_ENABLED) && *s == '.') {
	    s++;
	    BCop(OP_SCOMPLEMENT);
	}
	BCop(bof ? OP_NCOMPLEMENT : OP_COMPLEMENT);
    case ',':
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMMA)
	    TOKEN(0);
	s++;
	OPERATOR(',');
    case ':':
	if (s[1] == ':') {
	    len = 0;
	    goto just_a_word_zero_gv;
	}
	s++;
        {
        OP *attrs;

	switch (PL_expect) {
	case XOPERATOR:
	    if (!PL_in_my || PL_lex_state != LEX_NORMAL)
		break;
	    PL_bufptr = s;	/* update in case we back off */
	    if (*s == '=') {
		Perl_croak(aTHX_
			   "Use of := for an empty attribute list is not allowed");
	    }
	    goto grabattrs;
	case XATTRBLOCK:
	    PL_expect = XBLOCK;
	    goto grabattrs;
	case XATTRTERM:
	    PL_expect = XTERMBLOCK;
	 grabattrs:
	    s = skipspace(s);
	    attrs = NULL;
	    while (isIDFIRST_lazy_if(s,UTF)) {
		I32 tmp;
		SV *sv;
		d = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &len);
		if (isLOWER(*s) && (tmp = keyword(PL_tokenbuf, len, 0))) {
		    if (tmp < 0) tmp = -tmp;
		    switch (tmp) {
		    case KEY_or:
		    case KEY_and:
		    case KEY_for:
		    case KEY_foreach:
		    case KEY_unless:
		    case KEY_if:
		    case KEY_while:
		    case KEY_until:
			goto got_attrs;
		    default:
			break;
		    }
		}
		sv = newSVpvn_flags(s, len, UTF ? SVf_UTF8 : 0);
		if (*d == '(') {
		    d = scan_str(d,TRUE,TRUE,FALSE,NULL);
		    COPLINE_SET_FROM_MULTI_END;
		    if (!d) {
			/* MUST advance bufptr here to avoid bogus
			   "at end of line" context messages from yyerror().
			 */
			PL_bufptr = s + len;
			yyerror("Unterminated attribute parameter in attribute list");
			if (attrs)
			    op_free(attrs);
			sv_free(sv);
			return REPORT(0);	/* EOF indicator */
		    }
		}
		if (PL_lex_stuff) {
		    sv_catsv(sv, PL_lex_stuff);
		    attrs = op_append_elem(OP_LIST, attrs,
					newSVOP(OP_CONST, 0, sv));
		    SvREFCNT_dec_NN(PL_lex_stuff);
		    PL_lex_stuff = NULL;
		}
		else {
		    if (len == 6 && strnEQ(SvPVX(sv), "unique", len)) {
			sv_free(sv);
			if (PL_in_my == KEY_our) {
			    deprecate(":unique");
			}
			else
			    Perl_croak(aTHX_ "The 'unique' attribute may only be applied to 'our' variables");
		    }

		    /* NOTE: any CV attrs applied here need to be part of
		       the CVf_BUILTIN_ATTRS define in cv.h! */
		    else if (!PL_in_my && len == 6 && strnEQ(SvPVX(sv), "lvalue", len)) {
			sv_free(sv);
			CvLVALUE_on(PL_compcv);
		    }
		    else if (!PL_in_my && len == 6 && strnEQ(SvPVX(sv), "locked", len)) {
			sv_free(sv);
			deprecate(":locked");
		    }
		    else if (!PL_in_my && len == 6 && strnEQ(SvPVX(sv), "method", len)) {
			sv_free(sv);
			CvMETHOD_on(PL_compcv);
		    }
		    else if (!PL_in_my && len == 5
			  && strnEQ(SvPVX(sv), "const", len))
		    {
			sv_free(sv);
			Perl_ck_warner_d(aTHX_
			    packWARN(WARN_EXPERIMENTAL__CONST_ATTR),
			   ":const is experimental"
			);
			CvANONCONST_on(PL_compcv);
			if (!CvANON(PL_compcv))
			    yyerror(":const is not permitted on named "
				    "subroutines");
		    }
		    /* After we've set the flags, it could be argued that
		       we don't need to do the attributes.pm-based setting
		       process, and shouldn't bother appending recognized
		       flags.  To experiment with that, uncomment the
		       following "else".  (Note that's already been
		       uncommented.  That keeps the above-applied built-in
		       attributes from being intercepted (and possibly
		       rejected) by a package's attribute routines, but is
		       justified by the performance win for the common case
		       of applying only built-in attributes.) */
		    else
		        attrs = op_append_elem(OP_LIST, attrs,
					    newSVOP(OP_CONST, 0,
					      	    sv));
		}
		s = skipspace(d);
		if (*s == ':' && s[1] != ':')
		    s = skipspace(s+1);
		else if (s == d)
		    break;	/* require real whitespace or :'s */
		/* XXX losing whitespace on sequential attributes here */
	    }
	    {
		if (*s != ';'
                    && *s != '}'
                    && !(PL_expect == XOPERATOR
			 ? (*s == '=' ||  *s == ')')
			 : (*s == '{' ||  *s == '(')))
                {
		    const char q = ((*s == '\'') ? '"' : '\'');
		    /* If here for an expression, and parsed no attrs, back
		       off. */
		    if (PL_expect == XOPERATOR && !attrs) {
			s = PL_bufptr;
			break;
		    }
		    /* MUST advance bufptr here to avoid bogus "at end of line"
		       context messages from yyerror().
		    */
		    PL_bufptr = s;
		    yyerror( (const char *)
			     (*s
			      ? Perl_form(aTHX_ "Invalid separator character "
					  "%c%c%c in attribute list", q, *s, q)
			      : "Unterminated attribute list" ) );
		    if (attrs)
			op_free(attrs);
		    OPERATOR(':');
		}
	    }
	got_attrs:
	    if (attrs) {
		NEXTVAL_NEXTTOKE.opval = attrs;
		force_next(THING);
	    }
	    TOKEN(COLONATTR);
	}
	}
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_CLOSING) {
	    s--;
	    TOKEN(0);
	}
	PL_lex_allbrackets--;
	OPERATOR(':');
    case '(':
	s++;
	if (PL_last_lop == PL_oldoldbufptr || PL_last_uni == PL_oldoldbufptr)
	    PL_oldbufptr = PL_oldoldbufptr;		/* allow print(STDOUT 123) */
	else
	    PL_expect = XTERM;
	s = skipspace(s);
	PL_lex_allbrackets++;
	TOKEN('(');
    case ';':
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
	    TOKEN(0);
	CLINE;
	s++;
	PL_expect = XSTATE;
	TOKEN(';');
    case ')':
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_CLOSING)
	    TOKEN(0);
	s++;
	PL_lex_allbrackets--;
	s = skipspace(s);
	if (*s == '{')
	    PREBLOCK(')');
	TERM(')');
    case ']':
	if (PL_lex_brackets && PL_lex_brackstack[PL_lex_brackets-1] == XFAKEEOF)
	    TOKEN(0);
	s++;
	if (PL_lex_brackets <= 0)
	    /* diag_listed_as: Unmatched right %s bracket */
	    yyerror("Unmatched right square bracket");
	else
	    --PL_lex_brackets;
	PL_lex_allbrackets--;
	if (PL_lex_state == LEX_INTERPNORMAL) {
	    if (PL_lex_brackets == 0) {
		if (*s == '-' && s[1] == '>')
		    PL_lex_state = LEX_INTERPENDMAYBE;
		else if (*s != '[' && *s != '{')
		    PL_lex_state = LEX_INTERPEND;
	    }
	}
	TERM(']');
    case '{':
	s++;
      leftbracket:
	if (PL_lex_brackets > 100) {
	    Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
	}
	switch (PL_expect) {
	case XTERM:
	case XTERMORDORDOR:
	    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
	    PL_lex_allbrackets++;
	    OPERATOR(HASHBRACK);
	case XOPERATOR:
	    while (s < PL_bufend && SPACE_OR_TAB(*s))
		s++;
	    d = s;
	    PL_tokenbuf[0] = '\0';
	    if (d < PL_bufend && *d == '-') {
		PL_tokenbuf[0] = '-';
		d++;
		while (d < PL_bufend && SPACE_OR_TAB(*d))
		    d++;
	    }
	    if (d < PL_bufend && isIDFIRST_lazy_if(d,UTF)) {
		d = scan_word(d, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1,
			      FALSE, &len);
		while (d < PL_bufend && SPACE_OR_TAB(*d))
		    d++;
		if (*d == '}') {
		    const char minus = (PL_tokenbuf[0] == '-');
		    s = force_word(s + minus, WORD, FALSE, TRUE);
		    if (minus)
			force_next('-');
		}
	    }
	    /* FALLTHROUGH */
	case XATTRTERM:
	case XTERMBLOCK:
	    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
	    PL_lex_allbrackets++;
	    PL_expect = XSTATE;
	    break;
	case XATTRBLOCK:
	case XBLOCK:
	    PL_lex_brackstack[PL_lex_brackets++] = XSTATE;
	    PL_lex_allbrackets++;
	    PL_expect = XSTATE;
	    break;
	case XBLOCKTERM:
	    PL_lex_brackstack[PL_lex_brackets++] = XTERM;
	    PL_lex_allbrackets++;
	    PL_expect = XSTATE;
	    break;
	default: {
		const char *t;
		if (PL_oldoldbufptr == PL_last_lop)
		    PL_lex_brackstack[PL_lex_brackets++] = XTERM;
		else
		    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
		PL_lex_allbrackets++;
		s = skipspace(s);
		if (*s == '}') {
		    if (PL_expect == XREF && PL_lex_state == LEX_INTERPNORMAL) {
			PL_expect = XTERM;
			/* This hack is to get the ${} in the message. */
			PL_bufptr = s+1;
			yyerror("syntax error");
			break;
		    }
		    OPERATOR(HASHBRACK);
		}
		if (PL_expect == XREF && PL_oldoldbufptr != PL_last_lop) {
		    /* ${...} or @@{...} etc., but not print {...}
		     * Skip the disambiguation and treat this as a block.
		     */
		    goto block_expectation;
		}
		/* This hack serves to disambiguate a pair of curlies
		 * as being a block or an anon hash.  Normally, expectation
		 * determines that, but in cases where we're not in a
		 * position to expect anything in particular (like inside
		 * eval"") we have to resolve the ambiguity.  This code
		 * covers the case where the first term in the curlies is a
		 * quoted string.  Most other cases need to be explicitly
		 * disambiguated by prepending a "+" before the opening
		 * curly in order to force resolution as an anon hash.
		 *
		 * XXX should probably propagate the outer expectation
		 * into eval"" to rely less on this hack, but that could
		 * potentially break current behavior of eval"".
		 * GSAR 97-07-21
		 */
		t = s;
		if (*s == '\'' || *s == '"' || *s == '`') {
		    /* common case: get past first string, handling escapes */
		    for (t++; t < PL_bufend && *t != *s;)
			if (*t++ == '\\')
			    t++;
		    t++;
		}
		else if (*s == 'q') {
		    if (++t < PL_bufend
			&& (!isWORDCHAR(*t)
			    || ((*t == 'q' || *t == 'x') && ++t < PL_bufend
				&& !isWORDCHAR(*t))))
		    {
			/* skip q//-like construct */
			const char *tmps;
			char open, close, term;
			I32 brackets = 1;

			while (t < PL_bufend && isSPACE(*t))
			    t++;
			/* check for q => */
			if (t+1 < PL_bufend && t[0] == '=' && t[1] == '>') {
			    OPERATOR(HASHBRACK);
			}
			term = *t;
			open = term;
			if (term && (tmps = strchr("([{< )]}> )]}>",term)))
			    term = tmps[5];
			close = term;
			if (open == close)
			    for (t++; t < PL_bufend; t++) {
				if (*t == '\\' && t+1 < PL_bufend && open != '\\')
				    t++;
				else if (*t == open)
				    break;
			    }
			else {
			    for (t++; t < PL_bufend; t++) {
				if (*t == '\\' && t+1 < PL_bufend)
				    t++;
				else if (*t == close && --brackets <= 0)
				    break;
				else if (*t == open)
				    brackets++;
			    }
			}
			t++;
		    }
		    else
			/* skip plain q word */
			while (t < PL_bufend && isWORDCHAR_lazy_if(t,UTF))
			    t += UTF ? UTF8SKIP(t) : 1;
		}
		else if (isWORDCHAR_lazy_if(t,UTF)) {
		    t += UTF ? UTF8SKIP(t) : 1;
		    while (t < PL_bufend && isWORDCHAR_lazy_if(t,UTF))
			t += UTF ? UTF8SKIP(t) : 1;
		}
		while (t < PL_bufend && isSPACE(*t))
		    t++;
		/* if comma follows first term, call it an anon hash */
		/* XXX it could be a comma expression with loop modifiers */
		if (t < PL_bufend && ((*t == ',' && (*s == 'q' || !isLOWER(*s)))
				   || (*t == '=' && t[1] == '>')))
		    OPERATOR(HASHBRACK);
		if (PL_expect == XREF)
		{
		  block_expectation:
		    /* If there is an opening brace or 'sub:', treat it
		       as a term to make ${{...}}{k} and &{sub:attr...}
		       dwim.  Otherwise, treat it as a statement, so
		       map {no strict; ...} works.
		     */
		    s = skipspace(s);
		    if (*s == '{') {
			PL_expect = XTERM;
			break;
		    }
		    if (strnEQ(s, "sub", 3)) {
			d = s + 3;
			d = skipspace(d);
			if (*d == ':') {
			    PL_expect = XTERM;
			    break;
			}
		    }
		    PL_expect = XSTATE;
		}
		else {
		    PL_lex_brackstack[PL_lex_brackets-1] = XSTATE;
		    PL_expect = XSTATE;
		}
	    }
	    break;
	}
	pl_yylval.ival = CopLINE(PL_curcop);
	PL_copline = NOLINE;   /* invalidate current command line number */
	TOKEN(formbrack ? '=' : '{');
    case '}':
	if (PL_lex_brackets && PL_lex_brackstack[PL_lex_brackets-1] == XFAKEEOF)
	    TOKEN(0);
      rightbracket:
	s++;
	if (PL_lex_brackets <= 0)
	    /* diag_listed_as: Unmatched right %s bracket */
	    yyerror("Unmatched right curly bracket");
	else
	    PL_expect = (expectation)PL_lex_brackstack[--PL_lex_brackets];
	PL_lex_allbrackets--;
	if (PL_lex_state == LEX_INTERPNORMAL) {
	    if (PL_lex_brackets == 0) {
		if (PL_expect & XFAKEBRACK) {
		    PL_expect &= XENUMMASK;
		    PL_lex_state = LEX_INTERPEND;
		    PL_bufptr = s;
		    return yylex();	/* ignore fake brackets */
		}
		if (PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
		 && SvEVALED(PL_lex_repl))
		    PL_lex_state = LEX_INTERPEND;
		else if (*s == '-' && s[1] == '>')
		    PL_lex_state = LEX_INTERPENDMAYBE;
		else if (*s != '[' && *s != '{')
		    PL_lex_state = LEX_INTERPEND;
	    }
	}
	if (PL_expect & XFAKEBRACK) {
	    PL_expect &= XENUMMASK;
	    PL_bufptr = s;
	    return yylex();		/* ignore fake brackets */
	}
	force_next(formbrack ? '.' : '}');
	if (formbrack) LEAVE;
	if (formbrack == 2) { /* means . where arguments were expected */
	    force_next(';');
	    TOKEN(FORMRBRACK);
	}
	TOKEN(';');
    case '&':
	if (PL_expect == XPOSTDEREF) POSTDEREF('&');
	s++;
	if (*s++ == '&') {
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_LOGIC)) {
		s -= 2;
		TOKEN(0);
	    }
	    AOPERATOR(ANDAND);
	}
	s--;
	if (PL_expect == XOPERATOR) {
	    if (PL_bufptr == PL_linestart && ckWARN(WARN_SEMICOLON)
		&& isIDFIRST_lazy_if(s,UTF))
	    {
		CopLINE_dec(PL_curcop);
		Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), "%s", PL_warn_nosemi);
		CopLINE_inc(PL_curcop);
	    }
	    d = s;
	    if ((bof = FEATURE_BITWISE_IS_ENABLED) && *s == '.')
		s++;
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_BITWISE)) {
		s = d;
		s--;
		TOKEN(0);
	    }
	    if (d == s) {
		PL_parser->saw_infix_sigil = 1;
		BAop(bof ? OP_NBIT_AND : OP_BIT_AND);
	    }
	    else
		BAop(OP_SBIT_AND);
	}

	PL_tokenbuf[0] = '&';
	s = scan_ident(s - 1, PL_tokenbuf + 1,
		       sizeof PL_tokenbuf - 1, TRUE);
	pl_yylval.ival = (OPpENTERSUB_AMPER<<8);
	if (PL_tokenbuf[1]) {
	    force_ident_maybe_lex('&');
	}
	else
	    PREREF('&');
	TERM('&');

    case '|':
	s++;
	if (*s++ == '|') {
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_LOGIC)) {
		s -= 2;
		TOKEN(0);
	    }
	    AOPERATOR(OROR);
	}
	s--;
	d = s;
	if ((bof = FEATURE_BITWISE_IS_ENABLED) && *s == '.')
	    s++;
	if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		(*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_BITWISE)) {
	    s = d - 1;
	    TOKEN(0);
	}
	BOop(bof ? s == d ? OP_NBIT_OR : OP_SBIT_OR : OP_BIT_OR);
    case '=':
	s++;
	{
	    const char tmp = *s++;
	    if (tmp == '=') {
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
		    s -= 2;
		    TOKEN(0);
		}
		Eop(OP_EQ);
	    }
	    if (tmp == '>') {
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMMA)
                {
		    s -= 2;
		    TOKEN(0);
		}
		OPERATOR(',');
	    }
	    if (tmp == '~')
		PMop(OP_MATCH);
	    if (tmp && isSPACE(*s) && ckWARN(WARN_SYNTAX)
		&& strchr("+-*/%.^&|<",tmp))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			    "Reversed %c= operator",(int)tmp);
	    s--;
	    if (PL_expect == XSTATE
                && isALPHA(tmp)
                && (s == PL_linestart+1 || s[-2] == '\n') )
            {
                if ((PL_in_eval && !PL_rsfp && !PL_parser->filtered)
                    || PL_lex_state != LEX_NORMAL) {
                    d = PL_bufend;
                    while (s < d) {
                        if (*s++ == '\n') {
                            incline(s);
                            if (strnEQ(s,"=cut",4)) {
                                s = strchr(s,'\n');
                                if (s)
                                    s++;
                                else
                                    s = d;
                                incline(s);
                                goto retry;
                            }
                        }
                    }
                    goto retry;
                }
                s = PL_bufend;
                PL_parser->in_pod = 1;
                goto retry;
            }
	}
	if (PL_expect == XBLOCK) {
	    const char *t = s;
#ifdef PERL_STRICT_CR
	    while (SPACE_OR_TAB(*t))
#else
	    while (SPACE_OR_TAB(*t) || *t == '\r')
#endif
		t++;
	    if (*t == '\n' || *t == '#') {
		formbrack = 1;
		ENTER;
		SAVEI8(PL_parser->form_lex_state);
		SAVEI32(PL_lex_formbrack);
		PL_parser->form_lex_state = PL_lex_state;
		PL_lex_formbrack = PL_lex_brackets + 1;
		goto leftbracket;
	    }
	}
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
	    s--;
	    TOKEN(0);
	}
	pl_yylval.ival = 0;
	OPERATOR(ASSIGNOP);
    case '!':
	s++;
	{
	    const char tmp = *s++;
	    if (tmp == '=') {
		/* was this !=~ where !~ was meant?
		 * warn on m:!=~\s+([/?]|[msy]\W|tr\W): */

		if (*s == '~' && ckWARN(WARN_SYNTAX)) {
		    const char *t = s+1;

		    while (t < PL_bufend && isSPACE(*t))
			++t;

		    if (*t == '/' || *t == '?'
                        || ((*t == 'm' || *t == 's' || *t == 'y')
			    && !isWORDCHAR(t[1]))
                        || (*t == 't' && t[1] == 'r' && !isWORDCHAR(t[2])))
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "!=~ should be !~");
		}
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
		    s -= 2;
		    TOKEN(0);
		}
		Eop(OP_NE);
	    }
	    if (tmp == '~')
		PMop(OP_NOT);
	}
	s--;
	OPERATOR('!');
    case '<':
	if (PL_expect != XOPERATOR) {
	    if (s[1] != '<' && !strchr(s,'>'))
		check_uni();
	    if (s[1] == '<' && s[2] != '>')
		s = scan_heredoc(s);
	    else
		s = scan_inputsymbol(s);
	    PL_expect = XOPERATOR;
	    TOKEN(sublex_start());
	}
	s++;
	{
	    char tmp = *s++;
	    if (tmp == '<') {
		if (*s == '=' && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
		    s -= 2;
		    TOKEN(0);
		}
		SHop(OP_LEFT_SHIFT);
	    }
	    if (tmp == '=') {
		tmp = *s++;
		if (tmp == '>') {
		    if (!PL_lex_allbrackets
                        && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                    {
			s -= 3;
			TOKEN(0);
		    }
		    Eop(OP_NCMP);
		}
		s--;
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
		    s -= 2;
		    TOKEN(0);
		}
		Rop(OP_LE);
	    }
	}
	s--;
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
	    s--;
	    TOKEN(0);
	}
	Rop(OP_LT);
    case '>':
	s++;
	{
	    const char tmp = *s++;
	    if (tmp == '>') {
		if (*s == '=' && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
		    s -= 2;
		    TOKEN(0);
		}
		SHop(OP_RIGHT_SHIFT);
	    }
	    else if (tmp == '=') {
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
		    s -= 2;
		    TOKEN(0);
		}
		Rop(OP_GE);
	    }
	}
	s--;
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
	    s--;
	    TOKEN(0);
	}
	Rop(OP_GT);

    case '$':
	CLINE;

	if (PL_expect == XOPERATOR) {
	    if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack) {
		return deprecate_commaless_var_list();
	    }
	}
	else if (PL_expect == XPOSTDEREF) {
	    if (s[1] == '#') {
		s++;
		POSTDEREF(DOLSHARP);
	    }
	    POSTDEREF('$');
	}

	if (s[1] == '#' && (isIDFIRST_lazy_if(s+2,UTF) || strchr("{$:+-@@", s[2]))) {
	    PL_tokenbuf[0] = '@@';
	    s = scan_ident(s + 1, PL_tokenbuf + 1,
			   sizeof PL_tokenbuf - 1, FALSE);
            if (PL_expect == XOPERATOR) {
                d = s;
                if (PL_bufptr > s) {
                    d = PL_bufptr-1;
                    PL_bufptr = PL_oldbufptr;
                }
		no_op("Array length", d);
            }
	    if (!PL_tokenbuf[1])
		PREREF(DOLSHARP);
	    PL_expect = XOPERATOR;
	    force_ident_maybe_lex('#');
	    TOKEN(DOLSHARP);
	}

	PL_tokenbuf[0] = '$';
	s = scan_ident(s, PL_tokenbuf + 1,
		       sizeof PL_tokenbuf - 1, FALSE);
	if (PL_expect == XOPERATOR) {
	    d = s;
	    if (PL_bufptr > s) {
		d = PL_bufptr-1;
		PL_bufptr = PL_oldbufptr;
	    }
	    no_op("Scalar", d);
	}
	if (!PL_tokenbuf[1]) {
	    if (s == PL_bufend)
		yyerror("Final $ should be \\$ or $name");
	    PREREF('$');
	}

	d = s;
	{
	    const char tmp = *s;
	    if (PL_lex_state == LEX_NORMAL || PL_lex_brackets)
		s = skipspace(s);

	    if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop)
		&& intuit_more(s)) {
		if (*s == '[') {
		    PL_tokenbuf[0] = '@@';
		    if (ckWARN(WARN_SYNTAX)) {
			char *t = s+1;

			while (isSPACE(*t) || isWORDCHAR_lazy_if(t,UTF) || *t == '$')
			    t += UTF ? UTF8SKIP(t) : 1;
			if (*t++ == ',') {
			    PL_bufptr = skipspace(PL_bufptr); /* XXX can realloc */
			    while (t < PL_bufend && *t != ']')
				t++;
			    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
					"Multidimensional syntax %"UTF8f" not supported",
                                        UTF8fARG(UTF,(int)((t - PL_bufptr) + 1), PL_bufptr));
			}
		    }
		}
		else if (*s == '{') {
		    char *t;
		    PL_tokenbuf[0] = '%';
		    if (strEQ(PL_tokenbuf+1, "SIG")  && ckWARN(WARN_SYNTAX)
			&& (t = strchr(s, '}')) && (t = strchr(t, '=')))
			{
			    char tmpbuf[sizeof PL_tokenbuf];
			    do {
				t++;
			    } while (isSPACE(*t));
			    if (isIDFIRST_lazy_if(t,UTF)) {
				STRLEN len;
				t = scan_word(t, tmpbuf, sizeof tmpbuf, TRUE,
					      &len);
				while (isSPACE(*t))
				    t++;
				if (*t == ';'
                                       && get_cvn_flags(tmpbuf, len, UTF ? SVf_UTF8 : 0))
				    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
					"You need to quote \"%"UTF8f"\"",
					 UTF8fARG(UTF, len, tmpbuf));
			    }
			}
		}
	    }

	    PL_expect = XOPERATOR;
	    if (PL_lex_state == LEX_NORMAL && isSPACE((char)tmp)) {
		const bool islop = (PL_last_lop == PL_oldoldbufptr);
		if (!islop || PL_last_lop_op == OP_GREPSTART)
		    PL_expect = XOPERATOR;
		else if (strchr("$@@\"'`q", *s))
		    PL_expect = XTERM;		/* e.g. print $fh "foo" */
		else if (strchr("&*<%", *s) && isIDFIRST_lazy_if(s+1,UTF))
		    PL_expect = XTERM;		/* e.g. print $fh &sub */
		else if (isIDFIRST_lazy_if(s,UTF)) {
		    char tmpbuf[sizeof PL_tokenbuf];
		    int t2;
		    scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
		    if ((t2 = keyword(tmpbuf, len, 0))) {
			/* binary operators exclude handle interpretations */
			switch (t2) {
			case -KEY_x:
			case -KEY_eq:
			case -KEY_ne:
			case -KEY_gt:
			case -KEY_lt:
			case -KEY_ge:
			case -KEY_le:
			case -KEY_cmp:
			    break;
			default:
			    PL_expect = XTERM;	/* e.g. print $fh length() */
			    break;
			}
		    }
		    else {
			PL_expect = XTERM;	/* e.g. print $fh subr() */
		    }
		}
		else if (isDIGIT(*s))
		    PL_expect = XTERM;		/* e.g. print $fh 3 */
		else if (*s == '.' && isDIGIT(s[1]))
		    PL_expect = XTERM;		/* e.g. print $fh .3 */
		else if ((*s == '?' || *s == '-' || *s == '+')
			 && !isSPACE(s[1]) && s[1] != '=')
		    PL_expect = XTERM;		/* e.g. print $fh -1 */
		else if (*s == '/' && !isSPACE(s[1]) && s[1] != '='
			 && s[1] != '/')
		    PL_expect = XTERM;		/* e.g. print $fh /.../
						   XXX except DORDOR operator
						*/
		else if (*s == '<' && s[1] == '<' && !isSPACE(s[2])
			 && s[2] != '=')
		    PL_expect = XTERM;		/* print $fh <<"EOF" */
	    }
	}
	force_ident_maybe_lex('$');
	TOKEN('$');

    case '@@':
        if (PL_expect == XPOSTDEREF)
            POSTDEREF('@@');
	PL_tokenbuf[0] = '@@';
	s = scan_ident(s, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, FALSE);
	if (PL_expect == XOPERATOR) {
            d = s;
            if (PL_bufptr > s) {
                d = PL_bufptr-1;
                PL_bufptr = PL_oldbufptr;
            }
	    no_op("Array", d);
        }
	pl_yylval.ival = 0;
	if (!PL_tokenbuf[1]) {
	    PREREF('@@');
	}
	if (PL_lex_state == LEX_NORMAL)
	    s = skipspace(s);
	if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop) && intuit_more(s)) {
	    if (*s == '{')
		PL_tokenbuf[0] = '%';

	    /* Warn about @@ where they meant $. */
	    if (*s == '[' || *s == '{') {
		if (ckWARN(WARN_SYNTAX)) {
		    S_check_scalar_slice(aTHX_ s);
		}
	    }
	}
	PL_expect = XOPERATOR;
	force_ident_maybe_lex('@@');
	TERM('@@');

     case '/':			/* may be division, defined-or, or pattern */
	if ((PL_expect == XOPERATOR || PL_expect == XTERMORDORDOR) && s[1] == '/') {
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (s[2] == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_LOGIC))
		TOKEN(0);
	    s += 2;
	    AOPERATOR(DORDOR);
	}
	else if (PL_expect == XOPERATOR) {
	    s++;
	    if (*s == '=' && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
		s--;
		TOKEN(0);
	    }
	    Mop(OP_DIVIDE);
        }
	else {
	    /* Disable warning on "study /blah/" */
	    if (PL_oldoldbufptr == PL_last_uni
	     && (*PL_last_uni != 's' || s - PL_last_uni < 5
	         || memNE(PL_last_uni, "study", 5)
	         || isWORDCHAR_lazy_if(PL_last_uni+5,UTF)
	     ))
	        check_uni();
	    s = scan_pat(s,OP_MATCH);
	    TERM(sublex_start());
	}

     case '?':			/* conditional */
	s++;
	if (!PL_lex_allbrackets
            && PL_lex_fakeeof >= LEX_FAKEEOF_IFELSE)
        {
	    s--;
	    TOKEN(0);
	}
	PL_lex_allbrackets++;
	OPERATOR('?');

    case '.':
	if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack
#ifdef PERL_STRICT_CR
	    && s[1] == '\n'
#else
	    && (s[1] == '\n' || (s[1] == '\r' && s[2] == '\n'))
#endif
	    && (s == PL_linestart || s[-1] == '\n') )
	{
	    PL_expect = XSTATE;
	    formbrack = 2; /* dot seen where arguments expected */
	    goto rightbracket;
	}
	if (PL_expect == XSTATE && s[1] == '.' && s[2] == '.') {
	    s += 3;
	    OPERATOR(YADAYADA);
	}
	if (PL_expect == XOPERATOR || !isDIGIT(s[1])) {
	    char tmp = *s++;
	    if (*s == tmp) {
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_RANGE)
                {
		    s--;
		    TOKEN(0);
		}
		s++;
		if (*s == tmp) {
		    s++;
		    pl_yylval.ival = OPf_SPECIAL;
		}
		else
		    pl_yylval.ival = 0;
		OPERATOR(DOTDOT);
	    }
	    if (*s == '=' && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
		s--;
		TOKEN(0);
	    }
	    Aop(OP_CONCAT);
	}
	/* FALLTHROUGH */
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
	s = scan_num(s, &pl_yylval);
	DEBUG_T( { printbuf("### Saw number in %s\n", s); } );
	if (PL_expect == XOPERATOR)
	    no_op("Number",s);
	TERM(THING);

    case '\'':
	s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	if (!s)
	    missingterm(NULL);
	COPLINE_SET_FROM_MULTI_END;
	DEBUG_T( { printbuf("### Saw string before %s\n", s); } );
	if (PL_expect == XOPERATOR) {
	    if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack) {
		return deprecate_commaless_var_list();
	    }
	    else
		no_op("String",s);
	}
	pl_yylval.ival = OP_CONST;
	TERM(sublex_start());

    case '"':
	s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	DEBUG_T( {
	    if (s)
		printbuf("### Saw string before %s\n", s);
	    else
		PerlIO_printf(Perl_debug_log,
			     "### Saw unterminated string\n");
	} );
	if (PL_expect == XOPERATOR) {
	    if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack) {
		return deprecate_commaless_var_list();
	    }
	    else
		no_op("String",s);
	}
	if (!s)
	    missingterm(NULL);
	pl_yylval.ival = OP_CONST;
	/* FIXME. I think that this can be const if char *d is replaced by
	   more localised variables.  */
	for (d = SvPV(PL_lex_stuff, len); len; len--, d++) {
	    if (*d == '$' || *d == '@@' || *d == '\\' || !UTF8_IS_INVARIANT((U8)*d)) {
		pl_yylval.ival = OP_STRINGIFY;
		break;
	    }
	}
	if (pl_yylval.ival == OP_CONST)
	    COPLINE_SET_FROM_MULTI_END;
	TERM(sublex_start());

    case '`':
	s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	DEBUG_T( {
            if (s)
                printbuf("### Saw backtick string before %s\n", s);
            else
		PerlIO_printf(Perl_debug_log,
			     "### Saw unterminated backtick string\n");
        } );
	if (PL_expect == XOPERATOR)
	    no_op("Backticks",s);
	if (!s)
	    missingterm(NULL);
	pl_yylval.ival = OP_BACKTICK;
	TERM(sublex_start());

    case '\\':
	s++;
	if (PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
	 && isDIGIT(*s))
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),"Can't use \\%c to mean $%c in expression",
			   *s, *s);
	if (PL_expect == XOPERATOR)
	    no_op("Backslash",s);
	OPERATOR(REFGEN);

    case 'v':
	if (isDIGIT(s[1]) && PL_expect != XOPERATOR) {
	    char *start = s + 2;
	    while (isDIGIT(*start) || *start == '_')
		start++;
	    if (*start == '.' && isDIGIT(start[1])) {
		s = scan_num(s, &pl_yylval);
		TERM(THING);
	    }
	    else if ((*start == ':' && start[1] == ':')
		  || (PL_expect == XSTATE && *start == ':'))
		goto keylookup;
	    else if (PL_expect == XSTATE) {
		d = start;
		while (d < PL_bufend && isSPACE(*d)) d++;
		if (*d == ':') goto keylookup;
	    }
	    /* avoid v123abc() or $h{v1}, allow C<print v10;> */
	    if (!isALPHA(*start) && (PL_expect == XTERM
			|| PL_expect == XREF || PL_expect == XSTATE
			|| PL_expect == XTERMORDORDOR)) {
		GV *const gv = gv_fetchpvn_flags(s, start - s,
                                                    UTF ? SVf_UTF8 : 0, SVt_PVCV);
		if (!gv) {
		    s = scan_num(s, &pl_yylval);
		    TERM(THING);
		}
	    }
	}
	goto keylookup;
    case 'x':
	if (isDIGIT(s[1]) && PL_expect == XOPERATOR) {
	    s++;
	    Mop(OP_REPEAT);
	}
	goto keylookup;

    case '_':
    case 'a': case 'A':
    case 'b': case 'B':
    case 'c': case 'C':
    case 'd': case 'D':
    case 'e': case 'E':
    case 'f': case 'F':
    case 'g': case 'G':
    case 'h': case 'H':
    case 'i': case 'I':
    case 'j': case 'J':
    case 'k': case 'K':
    case 'l': case 'L':
    case 'm': case 'M':
    case 'n': case 'N':
    case 'o': case 'O':
    case 'p': case 'P':
    case 'q': case 'Q':
    case 'r': case 'R':
    case 's': case 'S':
    case 't': case 'T':
    case 'u': case 'U':
	      case 'V':
    case 'w': case 'W':
	      case 'X':
    case 'y': case 'Y':
    case 'z': case 'Z':

      keylookup: {
	bool anydelim;
	bool lex;
	I32 tmp;
	SV *sv;
	CV *cv;
	PADOFFSET off;
	OP *rv2cv_op;

	lex = FALSE;
	orig_keyword = 0;
	off = 0;
	sv = NULL;
	cv = NULL;
	gv = NULL;
	gvp = NULL;
	rv2cv_op = NULL;

	PL_bufptr = s;
	s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &len);

	/* Some keywords can be followed by any delimiter, including ':' */
	anydelim = word_takes_any_delimeter(PL_tokenbuf, len);

	/* x::* is just a word, unless x is "CORE" */
	if (!anydelim && *s == ':' && s[1] == ':') {
	    if (strEQ(PL_tokenbuf, "CORE")) goto case_KEY_CORE;
	    goto just_a_word;
	}

	d = s;
	while (d < PL_bufend && isSPACE(*d))
		d++;	/* no comments skipped here, or s### is misparsed */

	/* Is this a word before a => operator? */
	if (*d == '=' && d[1] == '>') {
	  fat_arrow:
	    CLINE;
	    pl_yylval.opval
		= (OP*)newSVOP(OP_CONST, 0,
			       S_newSV_maybe_utf8(aTHX_ PL_tokenbuf, len));
	    pl_yylval.opval->op_private = OPpCONST_BARE;
	    TERM(WORD);
	}

	/* Check for plugged-in keyword */
	{
	    OP *o;
	    int result;
	    char *saved_bufptr = PL_bufptr;
	    PL_bufptr = s;
	    result = PL_keyword_plugin(aTHX_ PL_tokenbuf, len, &o);
	    s = PL_bufptr;
	    if (result == KEYWORD_PLUGIN_DECLINE) {
		/* not a plugged-in keyword */
		PL_bufptr = saved_bufptr;
	    } else if (result == KEYWORD_PLUGIN_STMT) {
		pl_yylval.opval = o;
		CLINE;
		if (!PL_nexttoke) PL_expect = XSTATE;
		return REPORT(PLUGSTMT);
	    } else if (result == KEYWORD_PLUGIN_EXPR) {
		pl_yylval.opval = o;
		CLINE;
		if (!PL_nexttoke) PL_expect = XOPERATOR;
		return REPORT(PLUGEXPR);
	    } else {
		Perl_croak(aTHX_ "Bad plugin affecting keyword '%s'",
					PL_tokenbuf);
	    }
	}

	/* Check for built-in keyword */
	tmp = keyword(PL_tokenbuf, len, 0);

	/* Is this a label? */
	if (!anydelim && PL_expect == XSTATE
	      && d < PL_bufend && *d == ':' && *(d + 1) != ':') {
	    s = d + 1;
	    pl_yylval.pval = savepvn(PL_tokenbuf, len+1);
	    pl_yylval.pval[len] = '\0';
	    pl_yylval.pval[len+1] = UTF ? 1 : 0;
	    CLINE;
	    TOKEN(LABEL);
	}

	/* Check for lexical sub */
	if (PL_expect != XOPERATOR) {
	    char tmpbuf[sizeof PL_tokenbuf + 1];
	    *tmpbuf = '&';
	    Copy(PL_tokenbuf, tmpbuf+1, len, char);
	    off = pad_findmy_pvn(tmpbuf, len+1, 0);
	    if (off != NOT_IN_PAD) {
		assert(off); /* we assume this is boolean-true below */
		if (PAD_COMPNAME_FLAGS_isOUR(off)) {
		    HV *  const stash = PAD_COMPNAME_OURSTASH(off);
		    HEK * const stashname = HvNAME_HEK(stash);
		    sv = newSVhek(stashname);
                    sv_catpvs(sv, "::");
                    sv_catpvn_flags(sv, PL_tokenbuf, len,
				    (UTF ? SV_CATUTF8 : SV_CATBYTES));
		    gv = gv_fetchsv(sv, GV_NOADD_NOINIT | SvUTF8(sv),
				    SVt_PVCV);
		    off = 0;
		    if (!gv) {
			sv_free(sv);
			sv = NULL;
			goto just_a_word;
		    }
		}
		else {
		    rv2cv_op = newOP(OP_PADANY, 0);
		    rv2cv_op->op_targ = off;
		    cv = find_lexical_cv(off);
		}
		lex = TRUE;
		goto just_a_word;
	    }
	    off = 0;
	}

	if (tmp < 0) {			/* second-class keyword? */
	    GV *ogv = NULL;	/* override (winner) */
	    GV *hgv = NULL;	/* hidden (loser) */
	    if (PL_expect != XOPERATOR && (*s != ':' || s[1] != ':')) {
		CV *cv;
		if ((gv = gv_fetchpvn_flags(PL_tokenbuf, len,
					    (UTF ? SVf_UTF8 : 0)|GV_NOTQUAL,
					    SVt_PVCV))
                    && (cv = GvCVu(gv)))
		{
		    if (GvIMPORTED_CV(gv))
			ogv = gv;
		    else if (! CvMETHOD(cv))
			hgv = gv;
		}
		if (!ogv
                    && (gvp = (GV**)hv_fetch(PL_globalstash, PL_tokenbuf,
                                                              len, FALSE))
                    && (gv = *gvp)
                    && (isGV_with_GP(gv)
			? GvCVu(gv) && GvIMPORTED_CV(gv)
			:   SvPCS_IMPORTED(gv)
			&& (gv_init(gv, PL_globalstash, PL_tokenbuf,
                                                                 len, 0), 1)))
		{
		    ogv = gv;
		}
	    }
	    if (ogv) {
		orig_keyword = tmp;
		tmp = 0;		/* overridden by import or by GLOBAL */
	    }
	    else if (gv && !gvp
		     && -tmp==KEY_lock	/* XXX generalizable kludge */
		     && GvCVu(gv))
	    {
		tmp = 0;		/* any sub overrides "weak" keyword */
	    }
	    else {			/* no override */
		tmp = -tmp;
		if (tmp == KEY_dump) {
		    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
				   "dump() better written as CORE::dump()");
		}
		gv = NULL;
		gvp = 0;
		if (hgv && tmp != KEY_x)	/* never ambiguous */
		    Perl_ck_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
				   "Ambiguous call resolved as CORE::%s(), "
				   "qualify as such or use &",
				   GvENAME(hgv));
	    }
	}

	if (tmp && tmp != KEY___DATA__ && tmp != KEY___END__
	 && (!anydelim || *s != '#')) {
	    /* no override, and not s### either; skipspace is safe here
	     * check for => on following line */
	    bool arrow;
	    STRLEN bufoff = PL_bufptr - SvPVX(PL_linestr);
	    STRLEN   soff = s         - SvPVX(PL_linestr);
	    s = skipspace_flags(s, LEX_NO_INCLINE);
	    arrow = *s == '=' && s[1] == '>';
	    PL_bufptr = SvPVX(PL_linestr) + bufoff;
	    s         = SvPVX(PL_linestr) +   soff;
	    if (arrow)
		goto fat_arrow;
	}

      reserved_word:
	switch (tmp) {

	default:			/* not a keyword */
	    /* Trade off - by using this evil construction we can pull the
	       variable gv into the block labelled keylookup. If not, then
	       we have to give it function scope so that the goto from the
	       earlier ':' case doesn't bypass the initialisation.  */
	    if (0) {
	    just_a_word_zero_gv:
		sv = NULL;
		cv = NULL;
		gv = NULL;
		gvp = NULL;
		rv2cv_op = NULL;
		orig_keyword = 0;
		lex = 0;
		off = 0;
	    }
	  just_a_word: {
		int pkgname = 0;
		const char lastchar = (PL_bufptr == PL_oldoldbufptr ? 0 : PL_bufptr[-1]);
		bool safebw;


		/* Get the rest if it looks like a package qualifier */

		if (*s == '\'' || (*s == ':' && s[1] == ':')) {
		    STRLEN morelen;
		    s = scan_word(s, PL_tokenbuf + len, sizeof PL_tokenbuf - len,
				  TRUE, &morelen);
		    if (!morelen)
			Perl_croak(aTHX_ "Bad name after %"UTF8f"%s",
				UTF8fARG(UTF, len, PL_tokenbuf),
				*s == '\'' ? "'" : "::");
		    len += morelen;
		    pkgname = 1;
		}

		if (PL_expect == XOPERATOR) {
		    if (PL_bufptr == PL_linestart) {
			CopLINE_dec(PL_curcop);
			Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), "%s", PL_warn_nosemi);
			CopLINE_inc(PL_curcop);
		    }
		    else
			no_op("Bareword",s);
		}

		/* See if the name is "Foo::",
		   in which case Foo is a bareword
		   (and a package name). */

		if (len > 2
                    && PL_tokenbuf[len - 2] == ':'
                    && PL_tokenbuf[len - 1] == ':')
		{
		    if (ckWARN(WARN_BAREWORD)
			&& ! gv_fetchpvn_flags(PL_tokenbuf, len, UTF ? SVf_UTF8 : 0, SVt_PVHV))
			Perl_warner(aTHX_ packWARN(WARN_BAREWORD),
		  	  "Bareword \"%"UTF8f"\" refers to nonexistent package",
			   UTF8fARG(UTF, len, PL_tokenbuf));
		    len -= 2;
		    PL_tokenbuf[len] = '\0';
		    gv = NULL;
		    gvp = 0;
		    safebw = TRUE;
		}
		else {
		    safebw = FALSE;
		}

		/* if we saw a global override before, get the right name */

		if (!sv)
		  sv = S_newSV_maybe_utf8(aTHX_ PL_tokenbuf,
						len);
		if (gvp) {
		    SV * const tmp_sv = sv;
		    sv = newSVpvs("CORE::GLOBAL::");
		    sv_catsv(sv, tmp_sv);
		    SvREFCNT_dec(tmp_sv);
		}


		/* Presume this is going to be a bareword of some sort. */
		CLINE;
		pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
		pl_yylval.opval->op_private = OPpCONST_BARE;

		/* And if "Foo::", then that's what it certainly is. */
		if (safebw)
		    goto safe_bareword;

		if (!off)
		{
		    OP *const_op = newSVOP(OP_CONST, 0, SvREFCNT_inc_NN(sv));
		    const_op->op_private = OPpCONST_BARE;
		    rv2cv_op =
			newCVREF(OPpMAY_RETURN_CONSTANT<<8, const_op);
		    cv = lex
			? isGV(gv)
			    ? GvCV(gv)
			    : SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV
				? (CV *)SvRV(gv)
				: ((CV *)gv)
			: rv2cv_op_cv(rv2cv_op, RV2CVOPCV_RETURN_STUB);
		}

		/* Use this var to track whether intuit_method has been
		   called.  intuit_method returns 0 or > 255.  */
		tmp = 1;

		/* See if it's the indirect object for a list operator. */

		if (PL_oldoldbufptr
                    && PL_oldoldbufptr < PL_bufptr
                    && (PL_oldoldbufptr == PL_last_lop
		        || PL_oldoldbufptr == PL_last_uni)
                    && /* NO SKIPSPACE BEFORE HERE! */
		       (PL_expect == XREF
                        || ((PL_opargs[PL_last_lop_op] >> OASHIFT)& 7)
                                                               == OA_FILEREF))
		{
		    bool immediate_paren = *s == '(';

		    /* (Now we can afford to cross potential line boundary.) */
		    s = skipspace(s);

		    /* Two barewords in a row may indicate method call. */

		    if ((isIDFIRST_lazy_if(s,UTF) || *s == '$')
                        && (tmp = intuit_method(s, lex ? NULL : sv, cv)))
                    {
			goto method;
		    }

		    /* If not a declared subroutine, it's an indirect object. */
		    /* (But it's an indir obj regardless for sort.) */
		    /* Also, if "_" follows a filetest operator, it's a bareword */

		    if (
			( !immediate_paren && (PL_last_lop_op == OP_SORT
                         || (!cv
                             && (PL_last_lop_op != OP_MAPSTART
                                 && PL_last_lop_op != OP_GREPSTART))))
		       || (PL_tokenbuf[0] == '_' && PL_tokenbuf[1] == '\0'
			    && ((PL_opargs[PL_last_lop_op] & OA_CLASS_MASK)
                                                            == OA_FILESTATOP))
		       )
		    {
			PL_expect = (PL_last_lop == PL_oldoldbufptr) ? XTERM : XOPERATOR;
			goto bareword;
		    }
		}

		PL_expect = XOPERATOR;
		s = skipspace(s);

		/* Is this a word before a => operator? */
		if (*s == '=' && s[1] == '>' && !pkgname) {
		    op_free(rv2cv_op);
		    CLINE;
		    if (gvp || (lex && !off)) {
			assert (cSVOPx(pl_yylval.opval)->op_sv == sv);
			/* This is our own scalar, created a few lines
			   above, so this is safe. */
			SvREADONLY_off(sv);
			sv_setpv(sv, PL_tokenbuf);
			if (UTF && !IN_BYTES
			 && is_utf8_string((U8*)PL_tokenbuf, len))
			      SvUTF8_on(sv);
			SvREADONLY_on(sv);
		    }
		    TERM(WORD);
		}

		/* If followed by a paren, it's certainly a subroutine. */
		if (*s == '(') {
		    CLINE;
		    if (cv) {
			d = s + 1;
			while (SPACE_OR_TAB(*d))
			    d++;
			if (*d == ')' && (sv = cv_const_sv_or_av(cv))) {
			    s = d + 1;
			    goto its_constant;
			}
		    }
		    NEXTVAL_NEXTTOKE.opval =
			off ? rv2cv_op : pl_yylval.opval;
		    if (off)
			 op_free(pl_yylval.opval), force_next(PRIVATEREF);
		    else op_free(rv2cv_op),	   force_next(WORD);
		    pl_yylval.ival = 0;
		    TOKEN('&');
		}

		/* If followed by var or block, call it a method (unless sub) */

		if ((*s == '$' || *s == '{') && !cv) {
		    op_free(rv2cv_op);
		    PL_last_lop = PL_oldbufptr;
		    PL_last_lop_op = OP_METHOD;
		    if (!PL_lex_allbrackets
                        && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                    {
			PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
                    }
		    PL_expect = XBLOCKTERM;
		    PL_bufptr = s;
		    return REPORT(METHOD);
		}

		/* If followed by a bareword, see if it looks like indir obj. */

		if (tmp == 1 && !orig_keyword
			&& (isIDFIRST_lazy_if(s,UTF) || *s == '$')
			&& (tmp = intuit_method(s, lex ? NULL : sv, cv))) {
		  method:
		    if (lex && !off) {
			assert(cSVOPx(pl_yylval.opval)->op_sv == sv);
			SvREADONLY_off(sv);
			sv_setpvn(sv, PL_tokenbuf, len);
			if (UTF && !IN_BYTES
			 && is_utf8_string((U8*)PL_tokenbuf, len))
			    SvUTF8_on (sv);
			else SvUTF8_off(sv);
		    }
		    op_free(rv2cv_op);
		    if (tmp == METHOD && !PL_lex_allbrackets
                        && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                    {
			PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
                    }
		    return REPORT(tmp);
		}

		/* Not a method, so call it a subroutine (if defined) */

		if (cv) {
		    /* Check for a constant sub */
		    if ((sv = cv_const_sv_or_av(cv))) {
		  its_constant:
			op_free(rv2cv_op);
			SvREFCNT_dec(((SVOP*)pl_yylval.opval)->op_sv);
			((SVOP*)pl_yylval.opval)->op_sv = SvREFCNT_inc_simple(sv);
			if (SvTYPE(sv) == SVt_PVAV)
			    pl_yylval.opval = newUNOP(OP_RV2AV, OPf_PARENS,
						      pl_yylval.opval);
			else {
			    pl_yylval.opval->op_private = 0;
			    pl_yylval.opval->op_folded = 1;
			    pl_yylval.opval->op_flags |= OPf_SPECIAL;
			}
			TOKEN(WORD);
		    }

		    op_free(pl_yylval.opval);
		    pl_yylval.opval =
			off ? (OP *)newCVREF(0, rv2cv_op) : rv2cv_op;
		    pl_yylval.opval->op_private |= OPpENTERSUB_NOPAREN;
		    PL_last_lop = PL_oldbufptr;
		    PL_last_lop_op = OP_ENTERSUB;
		    /* Is there a prototype? */
		    if (
			SvPOK(cv))
		    {
			STRLEN protolen = CvPROTOLEN(cv);
			const char *proto = CvPROTO(cv);
			bool optional;
			proto = S_strip_spaces(aTHX_ proto, &protolen);
			if (!protolen)
			    TERM(FUNC0SUB);
			if ((optional = *proto == ';'))
			  do
			    proto++;
			  while (*proto == ';');
			if (
			    (
			        (
			            *proto == '$' || *proto == '_'
			         || *proto == '*' || *proto == '+'
			        )
			     && proto[1] == '\0'
			    )
			 || (
			     *proto == '\\' && proto[1] && proto[2] == '\0'
			    )
			)
			    UNIPROTO(UNIOPSUB,optional);
			if (*proto == '\\' && proto[1] == '[') {
			    const char *p = proto + 2;
			    while(*p && *p != ']')
				++p;
			    if(*p == ']' && !p[1])
				UNIPROTO(UNIOPSUB,optional);
			}
			if (*proto == '&' && *s == '{') {
			    if (PL_curstash)
				sv_setpvs(PL_subname, "__ANON__");
			    else
				sv_setpvs(PL_subname, "__ANON__::__ANON__");
			    if (!PL_lex_allbrackets
                                && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                            {
				PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
                            }
			    PREBLOCK(LSTOPSUB);
			}
		    }
		    NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
		    PL_expect = XTERM;
		    force_next(off ? PRIVATEREF : WORD);
		    if (!PL_lex_allbrackets
                        && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                    {
			PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
                    }
		    TOKEN(NOAMP);
		}

		/* Call it a bare word */

		if (PL_hints & HINT_STRICT_SUBS)
		    pl_yylval.opval->op_private |= OPpCONST_STRICT;
		else {
		bareword:
		    /* after "print" and similar functions (corresponding to
		     * "F? L" in opcode.pl), whatever wasn't already parsed as
		     * a filehandle should be subject to "strict subs".
		     * Likewise for the optional indirect-object argument to system
		     * or exec, which can't be a bareword */
		    if ((PL_last_lop_op == OP_PRINT
			    || PL_last_lop_op == OP_PRTF
			    || PL_last_lop_op == OP_SAY
			    || PL_last_lop_op == OP_SYSTEM
			    || PL_last_lop_op == OP_EXEC)
			    && (PL_hints & HINT_STRICT_SUBS))
			pl_yylval.opval->op_private |= OPpCONST_STRICT;
		    if (lastchar != '-') {
			if (ckWARN(WARN_RESERVED)) {
			    d = PL_tokenbuf;
			    while (isLOWER(*d))
				d++;
			    if (!*d && !gv_stashpv(PL_tokenbuf, UTF ? SVf_UTF8 : 0))
                            {
                                /* PL_warn_reserved is constant */
                                GCC_DIAG_IGNORE(-Wformat-nonliteral);
				Perl_warner(aTHX_ packWARN(WARN_RESERVED), PL_warn_reserved,
				       PL_tokenbuf);
                                GCC_DIAG_RESTORE;
                            }
			}
		    }
		}
		op_free(rv2cv_op);

	    safe_bareword:
		if ((lastchar == '*' || lastchar == '%' || lastchar == '&')
		 && saw_infix_sigil) {
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
				     "Operator or semicolon missing before %c%"UTF8f,
				     lastchar,
				     UTF8fARG(UTF, strlen(PL_tokenbuf),
					      PL_tokenbuf));
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
				     "Ambiguous use of %c resolved as operator %c",
				     lastchar, lastchar);
		}
		TOKEN(WORD);
	    }

	case KEY___FILE__:
	    FUN0OP(
		(OP*)newSVOP(OP_CONST, 0, newSVpv(CopFILE(PL_curcop),0))
	    );

	case KEY___LINE__:
	    FUN0OP(
        	(OP*)newSVOP(OP_CONST, 0,
		    Perl_newSVpvf(aTHX_ "%"IVdf, (IV)CopLINE(PL_curcop)))
	    );

	case KEY___PACKAGE__:
	    FUN0OP(
		(OP*)newSVOP(OP_CONST, 0,
					(PL_curstash
					 ? newSVhek(HvNAME_HEK(PL_curstash))
					 : &PL_sv_undef))
	    );

	case KEY___DATA__:
	case KEY___END__: {
	    GV *gv;
	    if (PL_rsfp && (!PL_in_eval || PL_tokenbuf[2] == 'D')) {
		HV * const stash = PL_tokenbuf[2] == 'D' && PL_curstash
					? PL_curstash
					: PL_defstash;
		gv = (GV *)*hv_fetchs(stash, "DATA", 1);
		if (!isGV(gv))
		    gv_init(gv,stash,"DATA",4,0);
		GvMULTI_on(gv);
		if (!GvIO(gv))
		    GvIOp(gv) = newIO();
		IoIFP(GvIOp(gv)) = PL_rsfp;
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
		{
		    const int fd = PerlIO_fileno(PL_rsfp);
                    if (fd >= 3) {
                        fcntl(fd,F_SETFD, FD_CLOEXEC);
                    }
		}
#endif
		/* Mark this internal pseudo-handle as clean */
		IoFLAGS(GvIOp(gv)) |= IOf_UNTAINT;
		if ((PerlIO*)PL_rsfp == PerlIO_stdin())
		    IoTYPE(GvIOp(gv)) = IoTYPE_STD;
		else
		    IoTYPE(GvIOp(gv)) = IoTYPE_RDONLY;
#if defined(WIN32) && !defined(PERL_TEXTMODE_SCRIPTS)
		/* if the script was opened in binmode, we need to revert
		 * it to text mode for compatibility; but only iff it has CRs
		 * XXX this is a questionable hack at best. */
		if (PL_bufend-PL_bufptr > 2
		    && PL_bufend[-1] == '\n' && PL_bufend[-2] == '\r')
		{
		    Off_t loc = 0;
		    if (IoTYPE(GvIOp(gv)) == IoTYPE_RDONLY) {
			loc = PerlIO_tell(PL_rsfp);
			(void)PerlIO_seek(PL_rsfp, 0L, 0);
		    }
#ifdef NETWARE
			if (PerlLIO_setmode(PL_rsfp, O_TEXT) != -1) {
#else
		    if (PerlLIO_setmode(PerlIO_fileno(PL_rsfp), O_TEXT) != -1) {
#endif	/* NETWARE */
			if (loc > 0)
			    PerlIO_seek(PL_rsfp, loc, 0);
		    }
		}
#endif
#ifdef PERLIO_LAYERS
		if (!IN_BYTES) {
		    if (UTF)
			PerlIO_apply_layers(aTHX_ PL_rsfp, NULL, ":utf8");
		    else if (IN_ENCODING) {
			SV *name;
			dSP;
			ENTER;
			SAVETMPS;
			PUSHMARK(sp);
			XPUSHs(_get_encoding());
			PUTBACK;
			call_method("name", G_SCALAR);
			SPAGAIN;
			name = POPs;
			PUTBACK;
			PerlIO_apply_layers(aTHX_ PL_rsfp, NULL,
					    Perl_form(aTHX_ ":encoding(%"SVf")",
						      SVfARG(name)));
			FREETMPS;
			LEAVE;
		    }
		}
#endif
		PL_rsfp = NULL;
	    }
	    goto fake_eof;
	}

	case KEY___SUB__:
	    FUN0OP(CvCLONE(PL_compcv)
			? newOP(OP_RUNCV, 0)
			: newPVOP(OP_RUNCV,0,NULL));

	case KEY_AUTOLOAD:
	case KEY_DESTROY:
	case KEY_BEGIN:
	case KEY_UNITCHECK:
	case KEY_CHECK:
	case KEY_INIT:
	case KEY_END:
	    if (PL_expect == XSTATE) {
		s = PL_bufptr;
		goto really_sub;
	    }
	    goto just_a_word;

	case_KEY_CORE:
	    {
		STRLEN olen = len;
		d = s;
		s += 2;
		s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &len);
		if ((*s == ':' && s[1] == ':')
		 || (!(tmp = keyword(PL_tokenbuf, len, 1)) && *s == '\''))
		{
		    s = d;
		    len = olen;
		    Copy(PL_bufptr, PL_tokenbuf, olen, char);
		    goto just_a_word;
		}
		if (!tmp)
		    Perl_croak(aTHX_ "CORE::%"UTF8f" is not a keyword",
				      UTF8fARG(UTF, len, PL_tokenbuf));
		if (tmp < 0)
		    tmp = -tmp;
		else if (tmp == KEY_require || tmp == KEY_do
		      || tmp == KEY_glob)
		    /* that's a way to remember we saw "CORE::" */
		    orig_keyword = tmp;
		goto reserved_word;
	    }

	case KEY_abs:
	    UNI(OP_ABS);

	case KEY_alarm:
	    UNI(OP_ALARM);

	case KEY_accept:
	    LOP(OP_ACCEPT,XTERM);

	case KEY_and:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_LOWLOGIC)
		return REPORT(0);
	    OPERATOR(ANDOP);

	case KEY_atan2:
	    LOP(OP_ATAN2,XTERM);

	case KEY_bind:
	    LOP(OP_BIND,XTERM);

	case KEY_binmode:
	    LOP(OP_BINMODE,XTERM);

	case KEY_bless:
	    LOP(OP_BLESS,XTERM);

	case KEY_break:
	    FUN0(OP_BREAK);

	case KEY_chop:
	    UNI(OP_CHOP);

	case KEY_continue:
		    /* We have to disambiguate the two senses of
		      "continue". If the next token is a '{' then
		      treat it as the start of a continue block;
		      otherwise treat it as a control operator.
		     */
		    s = skipspace(s);
		    if (*s == '{')
	    PREBLOCK(CONTINUE);
		    else
			FUN0(OP_CONTINUE);

	case KEY_chdir:
	    /* may use HOME */
	    (void)gv_fetchpvs("ENV", GV_ADD|GV_NOTQUAL, SVt_PVHV);
	    UNI(OP_CHDIR);

	case KEY_close:
	    UNI(OP_CLOSE);

	case KEY_closedir:
	    UNI(OP_CLOSEDIR);

	case KEY_cmp:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Eop(OP_SCMP);

	case KEY_caller:
	    UNI(OP_CALLER);

	case KEY_crypt:
#ifdef FCRYPT
	    if (!PL_cryptseen) {
		PL_cryptseen = TRUE;
		init_des();
	    }
#endif
	    LOP(OP_CRYPT,XTERM);

	case KEY_chmod:
	    LOP(OP_CHMOD,XTERM);

	case KEY_chown:
	    LOP(OP_CHOWN,XTERM);

	case KEY_connect:
	    LOP(OP_CONNECT,XTERM);

	case KEY_chr:
	    UNI(OP_CHR);

	case KEY_cos:
	    UNI(OP_COS);

	case KEY_chroot:
	    UNI(OP_CHROOT);

	case KEY_default:
	    PREBLOCK(DEFAULT);

	case KEY_do:
	    s = skipspace(s);
	    if (*s == '{')
		PRETERMBLOCK(DO);
	    if (*s != '\'') {
		*PL_tokenbuf = '&';
		d = scan_word(s, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1,
			      1, &len);
		if (len && (len != 4 || strNE(PL_tokenbuf+1, "CORE"))
		 && !keyword(PL_tokenbuf + 1, len, 0)) {
		    d = skipspace(d);
		    if (*d == '(') {
			force_ident_maybe_lex('&');
			s = d;
		    }
		}
	    }
	    if (orig_keyword == KEY_do) {
		orig_keyword = 0;
		pl_yylval.ival = 1;
	    }
	    else
		pl_yylval.ival = 0;
	    OPERATOR(DO);

	case KEY_die:
	    PL_hints |= HINT_BLOCK_SCOPE;
	    LOP(OP_DIE,XTERM);

	case KEY_defined:
	    UNI(OP_DEFINED);

	case KEY_delete:
	    UNI(OP_DELETE);

	case KEY_dbmopen:
	    Perl_populate_isa(aTHX_ STR_WITH_LEN("AnyDBM_File::ISA"),
			      STR_WITH_LEN("NDBM_File::"),
			      STR_WITH_LEN("DB_File::"),
			      STR_WITH_LEN("GDBM_File::"),
			      STR_WITH_LEN("SDBM_File::"),
			      STR_WITH_LEN("ODBM_File::"),
			      NULL);
	    LOP(OP_DBMOPEN,XTERM);

	case KEY_dbmclose:
	    UNI(OP_DBMCLOSE);

	case KEY_dump:
	    LOOPX(OP_DUMP);

	case KEY_else:
	    PREBLOCK(ELSE);

	case KEY_elsif:
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(ELSIF);

	case KEY_eq:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Eop(OP_SEQ);

	case KEY_exists:
	    UNI(OP_EXISTS);
	
	case KEY_exit:
	    UNI(OP_EXIT);

	case KEY_eval:
	    s = skipspace(s);
	    if (*s == '{') { /* block eval */
		PL_expect = XTERMBLOCK;
		UNIBRACK(OP_ENTERTRY);
	    }
	    else { /* string eval */
		PL_expect = XTERM;
		UNIBRACK(OP_ENTEREVAL);
	    }

	case KEY_evalbytes:
	    PL_expect = XTERM;
	    UNIBRACK(-OP_ENTEREVAL);

	case KEY_eof:
	    UNI(OP_EOF);

	case KEY_exp:
	    UNI(OP_EXP);

	case KEY_each:
	    UNI(OP_EACH);

	case KEY_exec:
	    LOP(OP_EXEC,XREF);

	case KEY_endhostent:
	    FUN0(OP_EHOSTENT);

	case KEY_endnetent:
	    FUN0(OP_ENETENT);

	case KEY_endservent:
	    FUN0(OP_ESERVENT);

	case KEY_endprotoent:
	    FUN0(OP_EPROTOENT);

	case KEY_endpwent:
	    FUN0(OP_EPWENT);

	case KEY_endgrent:
	    FUN0(OP_EGRENT);

	case KEY_for:
	case KEY_foreach:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
	    pl_yylval.ival = CopLINE(PL_curcop);
	    s = skipspace(s);
	    if (PL_expect == XSTATE && isIDFIRST_lazy_if(s,UTF)) {
		char *p = s;

		if ((PL_bufend - p) >= 3
                    && strnEQ(p, "my", 2) && isSPACE(*(p + 2)))
                {
		    p += 2;
                }
		else if ((PL_bufend - p) >= 4
                         && strnEQ(p, "our", 3) && isSPACE(*(p + 3)))
		    p += 3;
		p = skipspace(p);
                /* skip optional package name, as in "for my abc $x (..)" */
		if (isIDFIRST_lazy_if(p,UTF)) {
		    p = scan_word(p, PL_tokenbuf, sizeof PL_tokenbuf, TRUE, &len);
		    p = skipspace(p);
		}
		if (*p != '$')
		    Perl_croak(aTHX_ "Missing $ on loop variable");
	    }
	    OPERATOR(FOR);

	case KEY_formline:
	    LOP(OP_FORMLINE,XTERM);

	case KEY_fork:
	    FUN0(OP_FORK);

	case KEY_fc:
	    UNI(OP_FC);

	case KEY_fcntl:
	    LOP(OP_FCNTL,XTERM);

	case KEY_fileno:
	    UNI(OP_FILENO);

	case KEY_flock:
	    LOP(OP_FLOCK,XTERM);

	case KEY_gt:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Rop(OP_SGT);

	case KEY_ge:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Rop(OP_SGE);

	case KEY_grep:
	    LOP(OP_GREPSTART, XREF);

	case KEY_goto:
	    LOOPX(OP_GOTO);

	case KEY_gmtime:
	    UNI(OP_GMTIME);

	case KEY_getc:
	    UNIDOR(OP_GETC);

	case KEY_getppid:
	    FUN0(OP_GETPPID);

	case KEY_getpgrp:
	    UNI(OP_GETPGRP);

	case KEY_getpriority:
	    LOP(OP_GETPRIORITY,XTERM);

	case KEY_getprotobyname:
	    UNI(OP_GPBYNAME);

	case KEY_getprotobynumber:
	    LOP(OP_GPBYNUMBER,XTERM);

	case KEY_getprotoent:
	    FUN0(OP_GPROTOENT);

	case KEY_getpwent:
	    FUN0(OP_GPWENT);

	case KEY_getpwnam:
	    UNI(OP_GPWNAM);

	case KEY_getpwuid:
	    UNI(OP_GPWUID);

	case KEY_getpeername:
	    UNI(OP_GETPEERNAME);

	case KEY_gethostbyname:
	    UNI(OP_GHBYNAME);

	case KEY_gethostbyaddr:
	    LOP(OP_GHBYADDR,XTERM);

	case KEY_gethostent:
	    FUN0(OP_GHOSTENT);

	case KEY_getnetbyname:
	    UNI(OP_GNBYNAME);

	case KEY_getnetbyaddr:
	    LOP(OP_GNBYADDR,XTERM);

	case KEY_getnetent:
	    FUN0(OP_GNETENT);

	case KEY_getservbyname:
	    LOP(OP_GSBYNAME,XTERM);

	case KEY_getservbyport:
	    LOP(OP_GSBYPORT,XTERM);

	case KEY_getservent:
	    FUN0(OP_GSERVENT);

	case KEY_getsockname:
	    UNI(OP_GETSOCKNAME);

	case KEY_getsockopt:
	    LOP(OP_GSOCKOPT,XTERM);

	case KEY_getgrent:
	    FUN0(OP_GGRENT);

	case KEY_getgrnam:
	    UNI(OP_GGRNAM);

	case KEY_getgrgid:
	    UNI(OP_GGRGID);

	case KEY_getlogin:
	    FUN0(OP_GETLOGIN);

	case KEY_given:
	    pl_yylval.ival = CopLINE(PL_curcop);
            Perl_ck_warner_d(aTHX_
                packWARN(WARN_EXPERIMENTAL__SMARTMATCH),
                "given is experimental");
	    OPERATOR(GIVEN);

	case KEY_glob:
	    LOP(
	     orig_keyword==KEY_glob ? -OP_GLOB : OP_GLOB,
	     XTERM
	    );

	case KEY_hex:
	    UNI(OP_HEX);

	case KEY_if:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(IF);

	case KEY_index:
	    LOP(OP_INDEX,XTERM);

	case KEY_int:
	    UNI(OP_INT);

	case KEY_ioctl:
	    LOP(OP_IOCTL,XTERM);

	case KEY_join:
	    LOP(OP_JOIN,XTERM);

	case KEY_keys:
	    UNI(OP_KEYS);

	case KEY_kill:
	    LOP(OP_KILL,XTERM);

	case KEY_last:
	    LOOPX(OP_LAST);
	
	case KEY_lc:
	    UNI(OP_LC);

	case KEY_lcfirst:
	    UNI(OP_LCFIRST);

	case KEY_local:
	    pl_yylval.ival = 0;
	    OPERATOR(LOCAL);

	case KEY_length:
	    UNI(OP_LENGTH);

	case KEY_lt:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Rop(OP_SLT);

	case KEY_le:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Rop(OP_SLE);

	case KEY_localtime:
	    UNI(OP_LOCALTIME);

	case KEY_log:
	    UNI(OP_LOG);

	case KEY_link:
	    LOP(OP_LINK,XTERM);

	case KEY_listen:
	    LOP(OP_LISTEN,XTERM);

	case KEY_lock:
	    UNI(OP_LOCK);

	case KEY_lstat:
	    UNI(OP_LSTAT);

	case KEY_m:
	    s = scan_pat(s,OP_MATCH);
	    TERM(sublex_start());

	case KEY_map:
	    LOP(OP_MAPSTART, XREF);

	case KEY_mkdir:
	    LOP(OP_MKDIR,XTERM);

	case KEY_msgctl:
	    LOP(OP_MSGCTL,XTERM);

	case KEY_msgget:
	    LOP(OP_MSGGET,XTERM);

	case KEY_msgrcv:
	    LOP(OP_MSGRCV,XTERM);

	case KEY_msgsnd:
	    LOP(OP_MSGSND,XTERM);

	case KEY_our:
	case KEY_my:
	case KEY_state:
	    if (PL_in_my) {
	        yyerror(Perl_form(aTHX_
	                          "Can't redeclare \"%s\" in \"%s\"",
	                           tmp      == KEY_my    ? "my" :
	                           tmp      == KEY_state ? "state" : "our",
	                           PL_in_my == KEY_my    ? "my" :
	                           PL_in_my == KEY_state ? "state" : "our"));
	    }
	    PL_in_my = (U16)tmp;
	    s = skipspace(s);
	    if (isIDFIRST_lazy_if(s,UTF)) {
		s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, TRUE, &len);
		if (len == 3 && strnEQ(PL_tokenbuf, "sub", 3))
		{
		    if (!FEATURE_LEXSUBS_IS_ENABLED)
			Perl_croak(aTHX_
				  "Experimental \"%s\" subs not enabled",
				   tmp == KEY_my    ? "my"    :
				   tmp == KEY_state ? "state" : "our");
		    Perl_ck_warner_d(aTHX_
			packWARN(WARN_EXPERIMENTAL__LEXICAL_SUBS),
			"The lexical_subs feature is experimental");
		    goto really_sub;
		}
		PL_in_my_stash = find_in_my_stash(PL_tokenbuf, len);
		if (!PL_in_my_stash) {
		    char tmpbuf[1024];
                    int len;
		    PL_bufptr = s;
		    len = my_snprintf(tmpbuf, sizeof(tmpbuf), "No such class %.1000s", PL_tokenbuf);
                    PERL_MY_SNPRINTF_POST_GUARD(len, sizeof(tmpbuf));
		    yyerror_pv(tmpbuf, UTF ? SVf_UTF8 : 0);
		}
	    }
	    pl_yylval.ival = 1;
	    OPERATOR(MY);

	case KEY_next:
	    LOOPX(OP_NEXT);

	case KEY_ne:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
	    Eop(OP_SNE);

	case KEY_no:
	    s = tokenize_use(0, s);
	    TOKEN(USE);

	case KEY_not:
	    if (*s == '(' || (s = skipspace(s), *s == '('))
		FUN1(OP_NOT);
	    else {
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                {
		    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
                }
		OPERATOR(NOTOP);
	    }

	case KEY_open:
	    s = skipspace(s);
	    if (isIDFIRST_lazy_if(s,UTF)) {
          const char *t;
          d = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE,
              &len);
		for (t=d; isSPACE(*t);)
		    t++;
		if ( *t && strchr("|&*+-=!?:.", *t) && ckWARN_d(WARN_PRECEDENCE)
		    /* [perl #16184] */
		    && !(t[0] == '=' && t[1] == '>')
		    && !(t[0] == ':' && t[1] == ':')
		    && !keyword(s, d-s, 0)
		) {
		    Perl_warner(aTHX_ packWARN(WARN_PRECEDENCE),
		       "Precedence problem: open %"UTF8f" should be open(%"UTF8f")",
			UTF8fARG(UTF, d-s, s), UTF8fARG(UTF, d-s, s));
		}
	    }
	    LOP(OP_OPEN,XTERM);

	case KEY_or:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_LOWLOGIC)
		return REPORT(0);
	    pl_yylval.ival = OP_OR;
	    OPERATOR(OROP);

	case KEY_ord:
	    UNI(OP_ORD);

	case KEY_oct:
	    UNI(OP_OCT);

	case KEY_opendir:
	    LOP(OP_OPEN_DIR,XTERM);

	case KEY_print:
	    checkcomma(s,PL_tokenbuf,"filehandle");
	    LOP(OP_PRINT,XREF);

	case KEY_printf:
	    checkcomma(s,PL_tokenbuf,"filehandle");
	    LOP(OP_PRTF,XREF);

	case KEY_prototype:
	    UNI(OP_PROTOTYPE);

	case KEY_push:
	    LOP(OP_PUSH,XTERM);

	case KEY_pop:
	    UNIDOR(OP_POP);

	case KEY_pos:
	    UNIDOR(OP_POS);
	
	case KEY_pack:
	    LOP(OP_PACK,XTERM);

	case KEY_package:
	    s = force_word(s,WORD,FALSE,TRUE);
	    s = skipspace(s);
	    s = force_strict_version(s);
	    PREBLOCK(PACKAGE);

	case KEY_pipe:
	    LOP(OP_PIPE_OP,XTERM);

	case KEY_q:
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	    if (!s)
		missingterm(NULL);
	    COPLINE_SET_FROM_MULTI_END;
	    pl_yylval.ival = OP_CONST;
	    TERM(sublex_start());

	case KEY_quotemeta:
	    UNI(OP_QUOTEMETA);

	case KEY_qw: {
	    OP *words = NULL;
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	    if (!s)
		missingterm(NULL);
	    COPLINE_SET_FROM_MULTI_END;
	    PL_expect = XOPERATOR;
	    if (SvCUR(PL_lex_stuff)) {
		int warned_comma = !ckWARN(WARN_QW);
		int warned_comment = warned_comma;
		d = SvPV_force(PL_lex_stuff, len);
		while (len) {
		    for (; isSPACE(*d) && len; --len, ++d)
			/**/;
		    if (len) {
			SV *sv;
			const char *b = d;
			if (!warned_comma || !warned_comment) {
			    for (; !isSPACE(*d) && len; --len, ++d) {
				if (!warned_comma && *d == ',') {
				    Perl_warner(aTHX_ packWARN(WARN_QW),
					"Possible attempt to separate words with commas");
				    ++warned_comma;
				}
				else if (!warned_comment && *d == '#') {
				    Perl_warner(aTHX_ packWARN(WARN_QW),
					"Possible attempt to put comments in qw() list");
				    ++warned_comment;
				}
			    }
			}
			else {
			    for (; !isSPACE(*d) && len; --len, ++d)
				/**/;
			}
			sv = newSVpvn_utf8(b, d-b, DO_UTF8(PL_lex_stuff));
			words = op_append_elem(OP_LIST, words,
					    newSVOP(OP_CONST, 0, tokeq(sv)));
		    }
		}
	    }
	    if (!words)
		words = newNULLLIST();
	    SvREFCNT_dec_NN(PL_lex_stuff);
	    PL_lex_stuff = NULL;
	    PL_expect = XOPERATOR;
	    pl_yylval.opval = sawparens(words);
	    TOKEN(QWLIST);
	}

	case KEY_qq:
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	    if (!s)
		missingterm(NULL);
	    pl_yylval.ival = OP_STRINGIFY;
	    if (SvIVX(PL_lex_stuff) == '\'')
		SvIV_set(PL_lex_stuff, 0);	/* qq'$foo' should interpolate */
	    TERM(sublex_start());

	case KEY_qr:
	    s = scan_pat(s,OP_QR);
	    TERM(sublex_start());

	case KEY_qx:
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	    if (!s)
		missingterm(NULL);
	    pl_yylval.ival = OP_BACKTICK;
	    TERM(sublex_start());

	case KEY_return:
	    OLDLOP(OP_RETURN);

	case KEY_require:
	    s = skipspace(s);
	    if (isDIGIT(*s)) {
		s = force_version(s, FALSE);
	    }
	    else if (*s != 'v' || !isDIGIT(s[1])
		    || (s = force_version(s, TRUE), *s == 'v'))
	    {
		*PL_tokenbuf = '\0';
		s = force_word(s,WORD,TRUE,TRUE);
		if (isIDFIRST_lazy_if(PL_tokenbuf,UTF))
		    gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf),
                                GV_ADD | (UTF ? SVf_UTF8 : 0));
		else if (*s == '<')
		    yyerror("<> at require-statement should be quotes");
	    }
	    if (orig_keyword == KEY_require) {
		orig_keyword = 0;
		pl_yylval.ival = 1;
	    }
	    else 
		pl_yylval.ival = 0;
	    PL_expect = PL_nexttoke ? XOPERATOR : XTERM;
	    PL_bufptr = s;
	    PL_last_uni = PL_oldbufptr;
	    PL_last_lop_op = OP_REQUIRE;
	    s = skipspace(s);
	    return REPORT( (int)REQUIRE );

	case KEY_reset:
	    UNI(OP_RESET);

	case KEY_redo:
	    LOOPX(OP_REDO);

	case KEY_rename:
	    LOP(OP_RENAME,XTERM);

	case KEY_rand:
	    UNI(OP_RAND);

	case KEY_rmdir:
	    UNI(OP_RMDIR);

	case KEY_rindex:
	    LOP(OP_RINDEX,XTERM);

	case KEY_read:
	    LOP(OP_READ,XTERM);

	case KEY_readdir:
	    UNI(OP_READDIR);

	case KEY_readline:
	    UNIDOR(OP_READLINE);

	case KEY_readpipe:
	    UNIDOR(OP_BACKTICK);

	case KEY_rewinddir:
	    UNI(OP_REWINDDIR);

	case KEY_recv:
	    LOP(OP_RECV,XTERM);

	case KEY_reverse:
	    LOP(OP_REVERSE,XTERM);

	case KEY_readlink:
	    UNIDOR(OP_READLINK);

	case KEY_ref:
	    UNI(OP_REF);

	case KEY_s:
	    s = scan_subst(s);
	    if (pl_yylval.opval)
		TERM(sublex_start());
	    else
		TOKEN(1);	/* force error */

	case KEY_say:
	    checkcomma(s,PL_tokenbuf,"filehandle");
	    LOP(OP_SAY,XREF);

	case KEY_chomp:
	    UNI(OP_CHOMP);
	
	case KEY_scalar:
	    UNI(OP_SCALAR);

	case KEY_select:
	    LOP(OP_SELECT,XTERM);

	case KEY_seek:
	    LOP(OP_SEEK,XTERM);

	case KEY_semctl:
	    LOP(OP_SEMCTL,XTERM);

	case KEY_semget:
	    LOP(OP_SEMGET,XTERM);

	case KEY_semop:
	    LOP(OP_SEMOP,XTERM);

	case KEY_send:
	    LOP(OP_SEND,XTERM);

	case KEY_setpgrp:
	    LOP(OP_SETPGRP,XTERM);

	case KEY_setpriority:
	    LOP(OP_SETPRIORITY,XTERM);

	case KEY_sethostent:
	    UNI(OP_SHOSTENT);

	case KEY_setnetent:
	    UNI(OP_SNETENT);

	case KEY_setservent:
	    UNI(OP_SSERVENT);

	case KEY_setprotoent:
	    UNI(OP_SPROTOENT);

	case KEY_setpwent:
	    FUN0(OP_SPWENT);

	case KEY_setgrent:
	    FUN0(OP_SGRENT);

	case KEY_seekdir:
	    LOP(OP_SEEKDIR,XTERM);

	case KEY_setsockopt:
	    LOP(OP_SSOCKOPT,XTERM);

	case KEY_shift:
	    UNIDOR(OP_SHIFT);

	case KEY_shmctl:
	    LOP(OP_SHMCTL,XTERM);

	case KEY_shmget:
	    LOP(OP_SHMGET,XTERM);

	case KEY_shmread:
	    LOP(OP_SHMREAD,XTERM);

	case KEY_shmwrite:
	    LOP(OP_SHMWRITE,XTERM);

	case KEY_shutdown:
	    LOP(OP_SHUTDOWN,XTERM);

	case KEY_sin:
	    UNI(OP_SIN);

	case KEY_sleep:
	    UNI(OP_SLEEP);

	case KEY_socket:
	    LOP(OP_SOCKET,XTERM);

	case KEY_socketpair:
	    LOP(OP_SOCKPAIR,XTERM);

	case KEY_sort:
	    checkcomma(s,PL_tokenbuf,"subroutine name");
	    s = skipspace(s);
	    PL_expect = XTERM;
	    s = force_word(s,WORD,TRUE,TRUE);
	    LOP(OP_SORT,XREF);

	case KEY_split:
	    LOP(OP_SPLIT,XTERM);

	case KEY_sprintf:
	    LOP(OP_SPRINTF,XTERM);

	case KEY_splice:
	    LOP(OP_SPLICE,XTERM);

	case KEY_sqrt:
	    UNI(OP_SQRT);

	case KEY_srand:
	    UNI(OP_SRAND);

	case KEY_stat:
	    UNI(OP_STAT);

	case KEY_study:
	    UNI(OP_STUDY);

	case KEY_substr:
	    LOP(OP_SUBSTR,XTERM);

	case KEY_format:
	case KEY_sub:
	  really_sub:
	    {
		char * const tmpbuf = PL_tokenbuf + 1;
		expectation attrful;
		bool have_name, have_proto;
		const int key = tmp;
                SV *format_name = NULL;

		d = s;
		s = skipspace(s);

		if (isIDFIRST_lazy_if(s,UTF)
                    || *s == '\''
                    || (*s == ':' && s[1] == ':'))
		{

		    PL_expect = XBLOCK;
		    attrful = XATTRBLOCK;
		    d = scan_word(s, tmpbuf, sizeof PL_tokenbuf - 1, TRUE,
				  &len);
                    if (key == KEY_format)
			format_name = S_newSV_maybe_utf8(aTHX_ s, d - s);
		    *PL_tokenbuf = '&';
		    if (memchr(tmpbuf, ':', len) || key != KEY_sub
		     || pad_findmy_pvn(
			    PL_tokenbuf, len + 1, 0
			) != NOT_IN_PAD)
			sv_setpvn(PL_subname, tmpbuf, len);
		    else {
			sv_setsv(PL_subname,PL_curstname);
			sv_catpvs(PL_subname,"::");
			sv_catpvn(PL_subname,tmpbuf,len);
		    }
                    if (SvUTF8(PL_linestr))
                        SvUTF8_on(PL_subname);
		    have_name = TRUE;


		    s = skipspace(d);
		}
		else {
		    if (key == KEY_my || key == KEY_our || key==KEY_state)
		    {
			*d = '\0';
			/* diag_listed_as: Missing name in "%s sub" */
			Perl_croak(aTHX_
				  "Missing name in \"%s\"", PL_bufptr);
		    }
		    PL_expect = XTERMBLOCK;
		    attrful = XATTRTERM;
		    sv_setpvs(PL_subname,"?");
		    have_name = FALSE;
		}

		if (key == KEY_format) {
		    if (format_name) {
                        NEXTVAL_NEXTTOKE.opval
                            = (OP*)newSVOP(OP_CONST,0, format_name);
                        NEXTVAL_NEXTTOKE.opval->op_private |= OPpCONST_BARE;
                        force_next(WORD);
                    }
		    PREBLOCK(FORMAT);
		}

		/* Look for a prototype */
		if (*s == '(' && !FEATURE_SIGNATURES_IS_ENABLED) {
		    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
		    COPLINE_SET_FROM_MULTI_END;
		    if (!s)
			Perl_croak(aTHX_ "Prototype not terminated");
		    (void)validate_proto(PL_subname, PL_lex_stuff, ckWARN(WARN_ILLEGALPROTO));
		    have_proto = TRUE;

		    s = skipspace(s);
		}
		else
		    have_proto = FALSE;

		if (*s == ':' && s[1] != ':')
		    PL_expect = attrful;
		else if ((*s != '{' && *s != '(') && key != KEY_format) {
                    assert(key == KEY_sub || key == KEY_AUTOLOAD ||
                           key == KEY_DESTROY || key == KEY_BEGIN ||
                           key == KEY_UNITCHECK || key == KEY_CHECK ||
                           key == KEY_INIT || key == KEY_END ||
                           key == KEY_my || key == KEY_state ||
                           key == KEY_our);
		    if (!have_name)
			Perl_croak(aTHX_ "Illegal declaration of anonymous subroutine");
		    else if (*s != ';' && *s != '}')
			Perl_croak(aTHX_ "Illegal declaration of subroutine %"SVf, SVfARG(PL_subname));
		}

		if (have_proto) {
		    NEXTVAL_NEXTTOKE.opval =
			(OP*)newSVOP(OP_CONST, 0, PL_lex_stuff);
		    PL_lex_stuff = NULL;
		    force_next(THING);
		}
		if (!have_name) {
		    if (PL_curstash)
			sv_setpvs(PL_subname, "__ANON__");
		    else
			sv_setpvs(PL_subname, "__ANON__::__ANON__");
		    TOKEN(ANONSUB);
		}
		force_ident_maybe_lex('&');
		TOKEN(SUB);
	    }

	case KEY_system:
	    LOP(OP_SYSTEM,XREF);

	case KEY_symlink:
	    LOP(OP_SYMLINK,XTERM);

	case KEY_syscall:
	    LOP(OP_SYSCALL,XTERM);

	case KEY_sysopen:
	    LOP(OP_SYSOPEN,XTERM);

	case KEY_sysseek:
	    LOP(OP_SYSSEEK,XTERM);

	case KEY_sysread:
	    LOP(OP_SYSREAD,XTERM);

	case KEY_syswrite:
	    LOP(OP_SYSWRITE,XTERM);

	case KEY_tr:
	case KEY_y:
	    s = scan_trans(s);
	    TERM(sublex_start());

	case KEY_tell:
	    UNI(OP_TELL);

	case KEY_telldir:
	    UNI(OP_TELLDIR);

	case KEY_tie:
	    LOP(OP_TIE,XTERM);

	case KEY_tied:
	    UNI(OP_TIED);

	case KEY_time:
	    FUN0(OP_TIME);

	case KEY_times:
	    FUN0(OP_TMS);

	case KEY_truncate:
	    LOP(OP_TRUNCATE,XTERM);

	case KEY_uc:
	    UNI(OP_UC);

	case KEY_ucfirst:
	    UNI(OP_UCFIRST);

	case KEY_untie:
	    UNI(OP_UNTIE);

	case KEY_until:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(UNTIL);

	case KEY_unless:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(UNLESS);

	case KEY_unlink:
	    LOP(OP_UNLINK,XTERM);

	case KEY_undef:
	    UNIDOR(OP_UNDEF);

	case KEY_unpack:
	    LOP(OP_UNPACK,XTERM);

	case KEY_utime:
	    LOP(OP_UTIME,XTERM);

	case KEY_umask:
	    UNIDOR(OP_UMASK);

	case KEY_unshift:
	    LOP(OP_UNSHIFT,XTERM);

	case KEY_use:
	    s = tokenize_use(1, s);
	    TOKEN(USE);

	case KEY_values:
	    UNI(OP_VALUES);

	case KEY_vec:
	    LOP(OP_VEC,XTERM);

	case KEY_when:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
	    pl_yylval.ival = CopLINE(PL_curcop);
            Perl_ck_warner_d(aTHX_
                packWARN(WARN_EXPERIMENTAL__SMARTMATCH),
                "when is experimental");
	    OPERATOR(WHEN);

	case KEY_while:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(WHILE);

	case KEY_warn:
	    PL_hints |= HINT_BLOCK_SCOPE;
	    LOP(OP_WARN,XTERM);

	case KEY_wait:
	    FUN0(OP_WAIT);

	case KEY_waitpid:
	    LOP(OP_WAITPID,XTERM);

	case KEY_wantarray:
	    FUN0(OP_WANTARRAY);

	case KEY_write:
            /* Make sure $^L is defined. 0x0C is CTRL-L on ASCII platforms, and
             * we use the same number on EBCDIC */
	    gv_fetchpvs("\x0C", GV_ADD|GV_NOTQUAL, SVt_PV);
	    UNI(OP_ENTERWRITE);

	case KEY_x:
	    if (PL_expect == XOPERATOR) {
		if (*s == '=' && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
		    return REPORT(0);
                }
		Mop(OP_REPEAT);
	    }
	    check_uni();
	    goto just_a_word;

	case KEY_xor:
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_LOWLOGIC)
		return REPORT(0);
	    pl_yylval.ival = OP_XOR;
	    OPERATOR(OROP);
	}
    }}
}

/*
  S_pending_ident

  Looks up an identifier in the pad or in a package

  Returns:
    PRIVATEREF if this is a lexical name.
    WORD       if this belongs to a package.

  Structure:
      if we're in a my declaration
	  croak if they tried to say my($foo::bar)
	  build the ops for a my() declaration
      if it's an access to a my() variable
	  build ops for access to a my() variable
      if in a dq string, and they've said @@foo and we can't find @@foo
	  warn
      build ops for a bareword
*/

static int
S_pending_ident(pTHX)
{
    PADOFFSET tmp = 0;
    const char pit = (char)pl_yylval.ival;
    const STRLEN tokenbuf_len = strlen(PL_tokenbuf);
    /* All routes through this function want to know if there is a colon.  */
    const char *const has_colon = (const char*) memchr (PL_tokenbuf, ':', tokenbuf_len);

    DEBUG_T({ PerlIO_printf(Perl_debug_log,
          "### Pending identifier '%s'\n", PL_tokenbuf); });

    /* if we're in a my(), we can't allow dynamics here.
       $foo'bar has already been turned into $foo::bar, so
       just check for colons.

       if it's a legal name, the OP is a PADANY.
    */
    if (PL_in_my) {
        if (PL_in_my == KEY_our) {	/* "our" is merely analogous to "my" */
            if (has_colon)
                yyerror_pv(Perl_form(aTHX_ "No package name allowed for "
                                  "variable %s in \"our\"",
                                  PL_tokenbuf), UTF ? SVf_UTF8 : 0);
            tmp = allocmy(PL_tokenbuf, tokenbuf_len, UTF ? SVf_UTF8 : 0);
        }
        else {
            if (has_colon) {
                /* "my" variable %s can't be in a package */
                /* PL_no_myglob is constant */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
                yyerror_pv(Perl_form(aTHX_ PL_no_myglob,
                            PL_in_my == KEY_my ? "my" : "state",
                            *PL_tokenbuf == '&' ? "subroutin" : "variabl",
                            PL_tokenbuf),
                            UTF ? SVf_UTF8 : 0);
                GCC_DIAG_RESTORE;
            }

            pl_yylval.opval = newOP(OP_PADANY, 0);
            pl_yylval.opval->op_targ = allocmy(PL_tokenbuf, tokenbuf_len,
                                                        UTF ? SVf_UTF8 : 0);
	    return PRIVATEREF;
        }
    }

    /*
       build the ops for accesses to a my() variable.
    */

    if (!has_colon) {
	if (!PL_in_my)
	    tmp = pad_findmy_pvn(PL_tokenbuf, tokenbuf_len,
                                 0);
        if (tmp != NOT_IN_PAD) {
            /* might be an "our" variable" */
            if (PAD_COMPNAME_FLAGS_isOUR(tmp)) {
                /* build ops for a bareword */
		HV *  const stash = PAD_COMPNAME_OURSTASH(tmp);
		HEK * const stashname = HvNAME_HEK(stash);
		SV *  const sym = newSVhek(stashname);
                sv_catpvs(sym, "::");
                sv_catpvn_flags(sym, PL_tokenbuf+1, tokenbuf_len - 1, (UTF ? SV_CATUTF8 : SV_CATBYTES ));
                pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sym);
                pl_yylval.opval->op_private = OPpCONST_ENTERED;
                if (pit != '&')
                  gv_fetchsv(sym,
                    GV_ADDMULTI,
                    ((PL_tokenbuf[0] == '$') ? SVt_PV
                     : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
                     : SVt_PVHV));
                return WORD;
            }

            pl_yylval.opval = newOP(OP_PADANY, 0);
            pl_yylval.opval->op_targ = tmp;
            return PRIVATEREF;
        }
    }

    /*
       Whine if they've said @@foo in a doublequoted string,
       and @@foo isn't a variable we can find in the symbol
       table.
    */
    if (ckWARN(WARN_AMBIGUOUS)
        && pit == '@@'
        && PL_lex_state != LEX_NORMAL
        && !PL_lex_brackets)
    {
        GV *const gv = gv_fetchpvn_flags(PL_tokenbuf + 1, tokenbuf_len - 1,
                                        ( UTF ? SVf_UTF8 : 0 ), SVt_PVAV);
        if ((!gv || ((PL_tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
		/* DO NOT warn for @@- and @@+ */
		&& !( PL_tokenbuf[2] == '\0'
                      && ( PL_tokenbuf[1] == '-' || PL_tokenbuf[1] == '+' ))
	   )
        {
            /* Downgraded from fatal to warning 20000522 mjd */
            Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
			"Possible unintended interpolation of %"UTF8f
			" in string",
			UTF8fARG(UTF, tokenbuf_len, PL_tokenbuf));
        }
    }

    /* build ops for a bareword */
    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
				   newSVpvn_flags(PL_tokenbuf + 1,
						      tokenbuf_len - 1,
                                                      UTF ? SVf_UTF8 : 0 ));
    pl_yylval.opval->op_private = OPpCONST_ENTERED;
    if (pit != '&')
	gv_fetchpvn_flags(PL_tokenbuf+1, tokenbuf_len - 1,
		     (PL_in_eval ? GV_ADDMULTI : GV_ADD)
                     | ( UTF ? SVf_UTF8 : 0 ),
		     ((PL_tokenbuf[0] == '$') ? SVt_PV
		      : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
		      : SVt_PVHV));
    return WORD;
}

STATIC void
S_checkcomma(pTHX_ const char *s, const char *name, const char *what)
{
    PERL_ARGS_ASSERT_CHECKCOMMA;

    if (*s == ' ' && s[1] == '(') {	/* XXX gotta be a better way */
	if (ckWARN(WARN_SYNTAX)) {
	    int level = 1;
	    const char *w;
	    for (w = s+2; *w && level; w++) {
		if (*w == '(')
		    ++level;
		else if (*w == ')')
		    --level;
	    }
	    while (isSPACE(*w))
		++w;
	    /* the list of chars below is for end of statements or
	     * block / parens, boolean operators (&&, ||, //) and branch
	     * constructs (or, and, if, until, unless, while, err, for).
	     * Not a very solid hack... */
	    if (!*w || !strchr(";&/|})]oaiuwef!=", *w))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			    "%s (...) interpreted as function",name);
	}
    }
    while (s < PL_bufend && isSPACE(*s))
	s++;
    if (*s == '(')
	s++;
    while (s < PL_bufend && isSPACE(*s))
	s++;
    if (isIDFIRST_lazy_if(s,UTF)) {
	const char * const w = s;
        s += UTF ? UTF8SKIP(s) : 1;
	while (isWORDCHAR_lazy_if(s,UTF))
	    s += UTF ? UTF8SKIP(s) : 1;
	while (s < PL_bufend && isSPACE(*s))
	    s++;
	if (*s == ',') {
	    GV* gv;
	    PADOFFSET off;
	    if (keyword(w, s - w, 0))
		return;

	    gv = gv_fetchpvn_flags(w, s - w, ( UTF ? SVf_UTF8 : 0 ), SVt_PVCV);
	    if (gv && GvCVu(gv))
		return;
	    if (s - w <= 254) {
		char tmpbuf[256];
		Copy(w, tmpbuf+1, s - w, char);
		*tmpbuf = '&';
		off = pad_findmy_pvn(tmpbuf, s-w+1, 0);
		if (off != NOT_IN_PAD) return;
	    }
	    Perl_croak(aTHX_ "No comma allowed after %s", what);
	}
    }
}

/* S_new_constant(): do any overload::constant lookup.

   Either returns sv, or mortalizes/frees sv and returns a new SV*.
   Best used as sv=new_constant(..., sv, ...).
   If s, pv are NULL, calls subroutine with one argument,
   and <type> is used with error messages only.
   <type> is assumed to be well formed UTF-8 */

STATIC SV *
S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen,
	       SV *sv, SV *pv, const char *type, STRLEN typelen)
{
    dSP;
    HV * table = GvHV(PL_hintgv);		 /* ^H */
    SV *res;
    SV *errsv = NULL;
    SV **cvp;
    SV *cv, *typesv;
    const char *why1 = "", *why2 = "", *why3 = "";

    PERL_ARGS_ASSERT_NEW_CONSTANT;
    /* We assume that this is true: */
    if (*key == 'c') { assert (strEQ(key, "charnames")); }
    assert(type || s);

    /* charnames doesn't work well if there have been errors found */
    if (PL_error_count > 0 && *key == 'c')
    {
	SvREFCNT_dec_NN(sv);
	return &PL_sv_undef;
    }

    sv_2mortal(sv);			/* Parent created it permanently */
    if (!table
	|| ! (PL_hints & HINT_LOCALIZE_HH)
	|| ! (cvp = hv_fetch(table, key, keylen, FALSE))
	|| ! SvOK(*cvp))
    {
	char *msg;
	
	/* Here haven't found what we're looking for.  If it is charnames,
	 * perhaps it needs to be loaded.  Try doing that before giving up */
	if (*key == 'c') {
	    Perl_load_module(aTHX_
		            0,
			    newSVpvs("_charnames"),
			     /* version parameter; no need to specify it, as if
			      * we get too early a version, will fail anyway,
			      * not being able to find '_charnames' */
			    NULL,
			    newSVpvs(":full"),
			    newSVpvs(":short"),
			    NULL);
            assert(sp == PL_stack_sp);
	    table = GvHV(PL_hintgv);
	    if (table
		&& (PL_hints & HINT_LOCALIZE_HH)
		&& (cvp = hv_fetch(table, key, keylen, FALSE))
		&& SvOK(*cvp))
	    {
		goto now_ok;
	    }
	}
	if (!table || !(PL_hints & HINT_LOCALIZE_HH)) {
	    msg = Perl_form(aTHX_
			       "Constant(%.*s) unknown",
				(int)(type ? typelen : len),
				(type ? type: s));
	}
	else {
            why1 = "$^H{";
            why2 = key;
            why3 = "} is not defined";
        report:
            if (*key == 'c') {
                msg = Perl_form(aTHX_
                            /* The +3 is for '\N{'; -4 for that, plus '}' */
                            "Unknown charname '%.*s'", (int)typelen - 4, type + 3
                      );
            }
            else {
                msg = Perl_form(aTHX_ "Constant(%.*s): %s%s%s",
                                    (int)(type ? typelen : len),
                                    (type ? type: s), why1, why2, why3);
            }
        }
	yyerror_pv(msg, UTF ? SVf_UTF8 : 0);
  	return SvREFCNT_inc_simple_NN(sv);
    }
  now_ok:
    cv = *cvp;
    if (!pv && s)
  	pv = newSVpvn_flags(s, len, SVs_TEMP);
    if (type && pv)
  	typesv = newSVpvn_flags(type, typelen, SVs_TEMP);
    else
  	typesv = &PL_sv_undef;

    PUSHSTACKi(PERLSI_OVERLOAD);
    ENTER ;
    SAVETMPS;

    PUSHMARK(SP) ;
    EXTEND(sp, 3);
    if (pv)
 	PUSHs(pv);
    PUSHs(sv);
    if (pv)
 	PUSHs(typesv);
    PUTBACK;
    call_sv(cv, G_SCALAR | ( PL_in_eval ? 0 : G_EVAL));

    SPAGAIN ;

    /* Check the eval first */
    if (!PL_in_eval && ((errsv = ERRSV), SvTRUE_NN(errsv))) {
	STRLEN errlen;
	const char * errstr;
	sv_catpvs(errsv, "Propagated");
	errstr = SvPV_const(errsv, errlen);
	yyerror_pvn(errstr, errlen, 0); /* Duplicates the message inside eval */
	(void)POPs;
	res = SvREFCNT_inc_simple_NN(sv);
    }
    else {
 	res = POPs;
	SvREFCNT_inc_simple_void_NN(res);
    }

    PUTBACK ;
    FREETMPS ;
    LEAVE ;
    POPSTACK;

    if (!SvOK(res)) {
 	why1 = "Call to &{$^H{";
 	why2 = key;
 	why3 = "}} did not return a defined value";
 	sv = res;
	(void)sv_2mortal(sv);
 	goto report;
    }

    return res;
}

PERL_STATIC_INLINE void
S_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8) {
    PERL_ARGS_ASSERT_PARSE_IDENT;

    for (;;) {
        if (*d >= e)
            Perl_croak(aTHX_ "%s", ident_too_long);
        if (is_utf8 && isIDFIRST_utf8((U8*)*s)) {
             /* The UTF-8 case must come first, otherwise things
             * like c\N{COMBINING TILDE} would start failing, as the
             * isWORDCHAR_A case below would gobble the 'c' up.
             */

            char *t = *s + UTF8SKIP(*s);
            while (isIDCONT_utf8((U8*)t))
                t += UTF8SKIP(t);
            if (*d + (t - *s) > e)
                Perl_croak(aTHX_ "%s", ident_too_long);
            Copy(*s, *d, t - *s, char);
            *d += t - *s;
            *s = t;
        }
        else if ( isWORDCHAR_A(**s) ) {
            do {
                *(*d)++ = *(*s)++;
            } while (isWORDCHAR_A(**s) && *d < e);
        }
        else if (allow_package && **s == '\'' && isIDFIRST_lazy_if(*s+1,is_utf8)) {
            *(*d)++ = ':';
            *(*d)++ = ':';
            (*s)++;
        }
        else if (allow_package && **s == ':' && (*s)[1] == ':'
           /* Disallow things like Foo::$bar. For the curious, this is
            * the code path that triggers the "Bad name after" warning
            * when looking for barewords.
            */
           && (*s)[2] != '$') {
            *(*d)++ = *(*s)++;
            *(*d)++ = *(*s)++;
        }
        else
            break;
    }
    return;
}

/* Returns a NUL terminated string, with the length of the string written to
   *slp
   */
STATIC char *
S_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
{
    char *d = dest;
    char * const e = d + destlen - 3;  /* two-character token, ending NUL */
    bool is_utf8 = cBOOL(UTF);

    PERL_ARGS_ASSERT_SCAN_WORD;

    parse_ident(&s, &d, e, allow_package, is_utf8);
    *d = '\0';
    *slp = d - dest;
    return s;
}

/* Is the byte 'd' a legal single character identifier name?  'u' is true
 * iff Unicode semantics are to be used.  The legal ones are any of:
 *  a) all ASCII characters except:
 *          1) control and space-type ones, like NUL, SOH, \t, and SPACE;
 *          2) '{'
 *     The final case currently doesn't get this far in the program, so we
 *     don't test for it.  If that were to change, it would be ok to allow it.
 *  c) When not under Unicode rules, any upper Latin1 character
 *  d) Otherwise, when unicode rules are used, all XIDS characters.
 *
 *      Because all ASCII characters have the same representation whether
 *      encoded in UTF-8 or not, we can use the foo_A macros below and '\0' and
 *      '{' without knowing if is UTF-8 or not.
 * EBCDIC already uses the rules that ASCII platforms will use after the
 * deprecation cycle; see comment below about the deprecation. */
#ifdef EBCDIC
#   define VALID_LEN_ONE_IDENT(s, is_utf8)                                    \
    (isGRAPH_A(*(s)) || ((is_utf8)                                            \
                         ? isIDFIRST_utf8((U8*) (s))                          \
                         : (isGRAPH_L1(*s)                                    \
                            && LIKELY((U8) *(s) != LATIN1_TO_NATIVE(0xAD)))))
#else
#   define VALID_LEN_ONE_IDENT(s, is_utf8)                                    \
    (isGRAPH_A(*(s)) || ((is_utf8)                                            \
                         ? isIDFIRST_utf8((U8*) (s))                          \
                         : ! isASCII_utf8((U8*) (s))))
#endif

STATIC char *
S_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni)
{
    I32 herelines = PL_parser->herelines;
    SSize_t bracket = -1;
    char funny = *s++;
    char *d = dest;
    char * const e = d + destlen - 3;    /* two-character token, ending NUL */
    bool is_utf8 = cBOOL(UTF);
    I32 orig_copline = 0, tmp_copline = 0;

    PERL_ARGS_ASSERT_SCAN_IDENT;

    if (isSPACE(*s) || !*s)
	s = skipspace(s);
    if (isDIGIT(*s)) {
	while (isDIGIT(*s)) {
	    if (d >= e)
		Perl_croak(aTHX_ "%s", ident_too_long);
	    *d++ = *s++;
	}
    }
    else {  /* See if it is a "normal" identifier */
        parse_ident(&s, &d, e, 1, is_utf8);
    }
    *d = '\0';
    d = dest;
    if (*d) {
        /* Either a digit variable, or parse_ident() found an identifier
           (anything valid as a bareword), so job done and return.  */
	if (PL_lex_state != LEX_NORMAL)
	    PL_lex_state = LEX_INTERPENDMAYBE;
	return s;
    }

    /* Here, it is not a run-of-the-mill identifier name */

    if (*s == '$' && s[1]
        && (isIDFIRST_lazy_if(s+1,is_utf8)
            || isDIGIT_A((U8)s[1])
            || s[1] == '$'
            || s[1] == '{'
            || strnEQ(s+1,"::",2)) )
    {
        /* Dereferencing a value in a scalar variable.
           The alternatives are different syntaxes for a scalar variable.
           Using ' as a leading package separator isn't allowed. :: is.   */
	return s;
    }
    /* Handle the opening { of @@{...}, &{...}, *{...}, %{...}, ${...}  */
    if (*s == '{') {
	bracket = s - SvPVX(PL_linestr);
	s++;
	orig_copline = CopLINE(PL_curcop);
        if (s < PL_bufend && isSPACE(*s)) {
            s = skipspace(s);
        }
    }
    if ((s <= PL_bufend - (is_utf8)
                          ? UTF8SKIP(s)
                          : 1)
        && VALID_LEN_ONE_IDENT(s, is_utf8))
    {
        /* Deprecate all non-graphic characters.  Include SHY as a non-graphic,
         * because often it has no graphic representation.  (We can't get to
         * here with SHY when 'is_utf8' is true, so no need to include a UTF-8
         * test for it.) */
        if ((is_utf8)
            ? ! isGRAPH_utf8( (U8*) s)
            : (! isGRAPH_L1( (U8) *s)
               || UNLIKELY((U8) *(s) == LATIN1_TO_NATIVE(0xAD))))
        {
            deprecate("literal non-graphic characters in variable names");
        }

        if (is_utf8) {
            const STRLEN skip = UTF8SKIP(s);
            STRLEN i;
            d[skip] = '\0';
            for ( i = 0; i < skip; i++ )
                d[i] = *s++;
        }
        else {
            *d = *s++;
            d[1] = '\0';
        }
    }
    /* Convert $^F, ${^F} and the ^F of ${^FOO} to control characters */
    if (*d == '^' && *s && isCONTROLVAR(*s)) {
	*d = toCTRL(*s);
	s++;
    }
    /* Warn about ambiguous code after unary operators if {...} notation isn't
       used.  There's no difference in ambiguity; it's merely a heuristic
       about when not to warn.  */
    else if (ck_uni && bracket == -1)
	check_uni();
    if (bracket != -1) {
        /* If we were processing {...} notation then...  */
	if (isIDFIRST_lazy_if(d,is_utf8)) {
            /* if it starts as a valid identifier, assume that it is one.
               (the later check for } being at the expected point will trap
               cases where this doesn't pan out.)  */
            d += is_utf8 ? UTF8SKIP(d) : 1;
            parse_ident(&s, &d, e, 1, is_utf8);
	    *d = '\0';
            tmp_copline = CopLINE(PL_curcop);
            if (s < PL_bufend && isSPACE(*s)) {
                s = skipspace(s);
            }
	    if ((*s == '[' || (*s == '{' && strNE(dest, "sub")))) {
                /* ${foo[0]} and ${foo{bar}} notation.  */
		if (ckWARN(WARN_AMBIGUOUS) && keyword(dest, d - dest, 0)) {
		    const char * const brack =
			(const char *)
			((*s == '[') ? "[...]" : "{...}");
                    orig_copline = CopLINE(PL_curcop);
                    CopLINE_set(PL_curcop, tmp_copline);
   /* diag_listed_as: Ambiguous use of %c{%s[...]} resolved to %c%s[...] */
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
			"Ambiguous use of %c{%s%s} resolved to %c%s%s",
			funny, dest, brack, funny, dest, brack);
                    CopLINE_set(PL_curcop, orig_copline);
		}
		bracket++;
		PL_lex_brackstack[PL_lex_brackets++] = (char)(XOPERATOR | XFAKEBRACK);
		PL_lex_allbrackets++;
		return s;
	    }
	}
	/* Handle extended ${^Foo} variables
	 * 1999-02-27 mjd-perl-patch@@plover.com */
	else if (! isPRINT(*d) /* isCNTRL(d), plus all non-ASCII */
		 && isWORDCHAR(*s))
	{
	    d++;
	    while (isWORDCHAR(*s) && d < e) {
		*d++ = *s++;
	    }
	    if (d >= e)
		Perl_croak(aTHX_ "%s", ident_too_long);
	    *d = '\0';
	}

        if ( !tmp_copline )
            tmp_copline = CopLINE(PL_curcop);
        if (s < PL_bufend && isSPACE(*s)) {
            s = skipspace(s);
        }
	    
        /* Expect to find a closing } after consuming any trailing whitespace.
         */
	if (*s == '}') {
	    s++;
	    if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets) {
		PL_lex_state = LEX_INTERPEND;
		PL_expect = XREF;
	    }
	    if (PL_lex_state == LEX_NORMAL) {
		if (ckWARN(WARN_AMBIGUOUS)
                    && (keyword(dest, d - dest, 0)
		        || get_cvn_flags(dest, d - dest, is_utf8
                           ? SVf_UTF8
                           : 0)))
		{
                    SV *tmp = newSVpvn_flags( dest, d - dest,
                                        SVs_TEMP | (is_utf8 ? SVf_UTF8 : 0) );
		    if (funny == '#')
			funny = '@@';
                    orig_copline = CopLINE(PL_curcop);
                    CopLINE_set(PL_curcop, tmp_copline);
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
			"Ambiguous use of %c{%"SVf"} resolved to %c%"SVf,
			funny, SVfARG(tmp), funny, SVfARG(tmp));
                    CopLINE_set(PL_curcop, orig_copline);
		}
	    }
	}
	else {
            /* Didn't find the closing } at the point we expected, so restore
               state such that the next thing to process is the opening { and */
	    s = SvPVX(PL_linestr) + bracket; /* let the parser handle it */
            CopLINE_set(PL_curcop, orig_copline);
            PL_parser->herelines = herelines;
	    *dest = '\0';
	}
    }
    else if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets && !intuit_more(s))
	PL_lex_state = LEX_INTERPEND;
    return s;
}

static bool
S_pmflag(pTHX_ const char* const valid_flags, U32 * pmfl, char** s, char* charset, unsigned int * x_mod_count) {

    /* Adds, subtracts to/from 'pmfl' based on the next regex modifier flag
     * found in the parse starting at 's', based on the subset that are valid
     * in this context input to this routine in 'valid_flags'. Advances s.
     * Returns TRUE if the input should be treated as a valid flag, so the next
     * char may be as well; otherwise FALSE. 'charset' should point to a NUL
     * upon first call on the current regex.  This routine will set it to any
     * charset modifier found.  The caller shouldn't change it.  This way,
     * another charset modifier encountered in the parse can be detected as an
     * error, as we have decided to allow only one */

    const char c = **s;
    STRLEN charlen = UTF ? UTF8SKIP(*s) : 1;

    if ( charlen != 1 || ! strchr(valid_flags, c) ) {
        if (isWORDCHAR_lazy_if(*s, UTF)) {
            yyerror_pv(Perl_form(aTHX_ "Unknown regexp modifier \"/%.*s\"", (int)charlen, *s),
                       UTF ? SVf_UTF8 : 0);
            (*s) += charlen;
            /* Pretend that it worked, so will continue processing before
             * dieing */
            return TRUE;
        }
        return FALSE;
    }

    switch (c) {

        CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl, *x_mod_count);
        case GLOBAL_PAT_MOD:      *pmfl |= PMf_GLOBAL; break;
        case CONTINUE_PAT_MOD:    *pmfl |= PMf_CONTINUE; break;
        case ONCE_PAT_MOD:        *pmfl |= PMf_KEEP; break;
        case KEEPCOPY_PAT_MOD:    *pmfl |= RXf_PMf_KEEPCOPY; break;
        case NONDESTRUCT_PAT_MOD: *pmfl |= PMf_NONDESTRUCT; break;
	case LOCALE_PAT_MOD:
	    if (*charset) {
		goto multiple_charsets;
	    }
	    set_regex_charset(pmfl, REGEX_LOCALE_CHARSET);
	    *charset = c;
	    break;
	case UNICODE_PAT_MOD:
	    if (*charset) {
		goto multiple_charsets;
	    }
	    set_regex_charset(pmfl, REGEX_UNICODE_CHARSET);
	    *charset = c;
	    break;
	case ASCII_RESTRICT_PAT_MOD:
	    if (! *charset) {
		set_regex_charset(pmfl, REGEX_ASCII_RESTRICTED_CHARSET);
	    }
	    else {

		/* Error if previous modifier wasn't an 'a', but if it was, see
		 * if, and accept, a second occurrence (only) */
		if (*charset != 'a'
		    || get_regex_charset(*pmfl)
			!= REGEX_ASCII_RESTRICTED_CHARSET)
		{
			goto multiple_charsets;
		}
		set_regex_charset(pmfl, REGEX_ASCII_MORE_RESTRICTED_CHARSET);
	    }
	    *charset = c;
	    break;
	case DEPENDS_PAT_MOD:
	    if (*charset) {
		goto multiple_charsets;
	    }
	    set_regex_charset(pmfl, REGEX_DEPENDS_CHARSET);
	    *charset = c;
	    break;
    }

    (*s)++;
    return TRUE;

    multiple_charsets:
	if (*charset != c) {
	    yyerror(Perl_form(aTHX_ "Regexp modifiers \"/%c\" and \"/%c\" are mutually exclusive", *charset, c));
	}
	else if (c == 'a') {
  /* diag_listed_as: Regexp modifier "/%c" may appear a maximum of twice */
	    yyerror("Regexp modifier \"/a\" may appear a maximum of twice");
	}
	else {
	    yyerror(Perl_form(aTHX_ "Regexp modifier \"/%c\" may not appear twice", c));
	}

	/* Pretend that it worked, so will continue processing before dieing */
	(*s)++;
	return TRUE;
}

STATIC char *
S_scan_pat(pTHX_ char *start, I32 type)
{
    PMOP *pm;
    char *s;
    const char * const valid_flags =
	(const char *)((type == OP_QR) ? QR_PAT_MODS : M_PAT_MODS);
    char charset = '\0';    /* character set modifier */
    unsigned int x_mod_count = 0;

    PERL_ARGS_ASSERT_SCAN_PAT;

    s = scan_str(start,TRUE,FALSE, (PL_in_eval & EVAL_RE_REPARSING), NULL);
    if (!s)
	Perl_croak(aTHX_ "Search pattern not terminated");

    pm = (PMOP*)newPMOP(type, 0);
    if (PL_multi_open == '?') {
	/* This is the only point in the code that sets PMf_ONCE:  */
	pm->op_pmflags |= PMf_ONCE;

	/* Hence it's safe to do this bit of PMOP book-keeping here, which
	   allows us to restrict the list needed by reset to just the ??
	   matches.  */
	assert(type != OP_TRANS);
	if (PL_curstash) {
	    MAGIC *mg = mg_find((const SV *)PL_curstash, PERL_MAGIC_symtab);
	    U32 elements;
	    if (!mg) {
		mg = sv_magicext(MUTABLE_SV(PL_curstash), 0, PERL_MAGIC_symtab, 0, 0,
				 0);
	    }
	    elements = mg->mg_len / sizeof(PMOP**);
	    Renewc(mg->mg_ptr, elements + 1, PMOP*, char);
	    ((PMOP**)mg->mg_ptr) [elements++] = pm;
	    mg->mg_len = elements * sizeof(PMOP**);
	    PmopSTASH_set(pm,PL_curstash);
	}
    }

    /* if qr/...(?{..}).../, then need to parse the pattern within a new
     * anon CV. False positives like qr/[(?{]/ are harmless */

    if (type == OP_QR) {
	STRLEN len;
	char *e, *p = SvPV(PL_lex_stuff, len);
	e = p + len;
	for (; p < e; p++) {
	    if (p[0] == '(' && p[1] == '?'
		&& (p[2] == '{' || (p[2] == '?' && p[3] == '{')))
	    {
		pm->op_pmflags |= PMf_HAS_CV;
		break;
	    }
	}
	pm->op_pmflags |= PMf_IS_QR;
    }

    while (*s && S_pmflag(aTHX_ valid_flags, &(pm->op_pmflags),
                                &s, &charset, &x_mod_count))
    {};
    /* issue a warning if /c is specified,but /g is not */
    if ((pm->op_pmflags & PMf_CONTINUE) && !(pm->op_pmflags & PMf_GLOBAL))
    {
        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), 
		       "Use of /c modifier is meaningless without /g" );
    }

    STD_PMMOD_FLAGS_PARSE_X_WARN(x_mod_count);

    PL_lex_op = (OP*)pm;
    pl_yylval.ival = OP_MATCH;
    return s;
}

STATIC char *
S_scan_subst(pTHX_ char *start)
{
    char *s;
    PMOP *pm;
    I32 first_start;
    line_t first_line;
    I32 es = 0;
    char charset = '\0';    /* character set modifier */
    unsigned int x_mod_count = 0;
    char *t;

    PERL_ARGS_ASSERT_SCAN_SUBST;

    pl_yylval.ival = OP_NULL;

    s = scan_str(start, TRUE, FALSE, FALSE, &t);

    if (!s)
	Perl_croak(aTHX_ "Substitution pattern not terminated");

    s = t;

    first_start = PL_multi_start;
    first_line = CopLINE(PL_curcop);
    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
    if (!s) {
	SvREFCNT_dec_NN(PL_lex_stuff);
	PL_lex_stuff = NULL;
	Perl_croak(aTHX_ "Substitution replacement not terminated");
    }
    PL_multi_start = first_start;	/* so whole substitution is taken together */

    pm = (PMOP*)newPMOP(OP_SUBST, 0);


    while (*s) {
	if (*s == EXEC_PAT_MOD) {
	    s++;
	    es++;
	}
	else if (! S_pmflag(aTHX_ S_PAT_MODS, &(pm->op_pmflags),
                                  &s, &charset, &x_mod_count))
	{
	    break;
	}
    }

    STD_PMMOD_FLAGS_PARSE_X_WARN(x_mod_count);

    if ((pm->op_pmflags & PMf_CONTINUE)) {
        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), "Use of /c modifier is meaningless in s///" );
    }

    if (es) {
	SV * const repl = newSVpvs("");

	PL_multi_end = 0;
	pm->op_pmflags |= PMf_EVAL;
	while (es-- > 0) {
	    if (es)
		sv_catpvs(repl, "eval ");
	    else
		sv_catpvs(repl, "do ");
	}
	sv_catpvs(repl, "{");
	sv_catsv(repl, PL_sublex_info.repl);
	sv_catpvs(repl, "}");
	SvEVALED_on(repl);
	SvREFCNT_dec(PL_sublex_info.repl);
	PL_sublex_info.repl = repl;
    }
    if (CopLINE(PL_curcop) != first_line) {
	sv_upgrade(PL_sublex_info.repl, SVt_PVNV);
	((XPVNV*)SvANY(PL_sublex_info.repl))->xnv_u.xpad_cop_seq.xlow =
	    CopLINE(PL_curcop) - first_line;
	CopLINE_set(PL_curcop, first_line);
    }

    PL_lex_op = (OP*)pm;
    pl_yylval.ival = OP_SUBST;
    return s;
}

STATIC char *
S_scan_trans(pTHX_ char *start)
{
    char* s;
    OP *o;
    U8 squash;
    U8 del;
    U8 complement;
    bool nondestruct = 0;
    char *t;

    PERL_ARGS_ASSERT_SCAN_TRANS;

    pl_yylval.ival = OP_NULL;

    s = scan_str(start,FALSE,FALSE,FALSE,&t);
    if (!s)
	Perl_croak(aTHX_ "Transliteration pattern not terminated");

    s = t;

    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
    if (!s) {
	SvREFCNT_dec_NN(PL_lex_stuff);
	PL_lex_stuff = NULL;
	Perl_croak(aTHX_ "Transliteration replacement not terminated");
    }

    complement = del = squash = 0;
    while (1) {
	switch (*s) {
	case 'c':
	    complement = OPpTRANS_COMPLEMENT;
	    break;
	case 'd':
	    del = OPpTRANS_DELETE;
	    break;
	case 's':
	    squash = OPpTRANS_SQUASH;
	    break;
	case 'r':
	    nondestruct = 1;
	    break;
	default:
	    goto no_more;
	}
	s++;
    }
  no_more:

    o = newPVOP(nondestruct ? OP_TRANSR : OP_TRANS, 0, (char*)NULL);
    o->op_private &= ~OPpTRANS_ALL;
    o->op_private |= del|squash|complement|
      (DO_UTF8(PL_lex_stuff)? OPpTRANS_FROM_UTF : 0)|
      (DO_UTF8(PL_sublex_info.repl) ? OPpTRANS_TO_UTF   : 0);

    PL_lex_op = o;
    pl_yylval.ival = nondestruct ? OP_TRANSR : OP_TRANS;


    return s;
}

/* scan_heredoc
   Takes a pointer to the first < in <<FOO.
   Returns a pointer to the byte following <<FOO.

   This function scans a heredoc, which involves different methods
   depending on whether we are in a string eval, quoted construct, etc.
   This is because PL_linestr could containing a single line of input, or
   a whole string being evalled, or the contents of the current quote-
   like operator.

   The two basic methods are:
    - Steal lines from the input stream
    - Scan the heredoc in PL_linestr and remove it therefrom

   In a file scope or filtered eval, the first method is used; in a
   string eval, the second.

   In a quote-like operator, we have to choose between the two,
   depending on where we can find a newline.  We peek into outer lex-
   ing scopes until we find one with a newline in it.  If we reach the
   outermost lexing scope and it is a file, we use the stream method.
   Otherwise it is treated as an eval.
*/

STATIC char *
S_scan_heredoc(pTHX_ char *s)
{
    I32 op_type = OP_SCALAR;
    I32 len;
    SV *tmpstr;
    char term;
    char *d;
    char *e;
    char *peek;
    const bool infile = PL_rsfp || PL_parser->filtered;
    const line_t origline = CopLINE(PL_curcop);
    LEXSHARED *shared = PL_parser->lex_shared;

    PERL_ARGS_ASSERT_SCAN_HEREDOC;

    s += 2;
    d = PL_tokenbuf + 1;
    e = PL_tokenbuf + sizeof PL_tokenbuf - 1;
    *PL_tokenbuf = '\n';
    peek = s;
    while (SPACE_OR_TAB(*peek))
	peek++;
    if (*peek == '`' || *peek == '\'' || *peek =='"') {
	s = peek;
	term = *s++;
	s = delimcpy(d, e, s, PL_bufend, term, &len);
	if (s == PL_bufend)
	    Perl_croak(aTHX_ "Unterminated delimiter for here document");
	d += len;
	s++;
    }
    else {
	if (*s == '\\')
            /* <<\FOO is equivalent to <<'FOO' */
	    s++, term = '\'';
	else
	    term = '"';
	if (!isWORDCHAR_lazy_if(s,UTF))
	    deprecate("bare << to mean <<\"\"");
	peek = s;
	while (isWORDCHAR_lazy_if(peek,UTF)) {
	    peek += UTF ? UTF8SKIP(peek) : 1;
	}
	len = (peek - s >= e - d) ? (e - d) : (peek - s);
	Copy(s, d, len, char);
	s += len;
	d += len;
    }
    if (d >= PL_tokenbuf + sizeof PL_tokenbuf - 1)
	Perl_croak(aTHX_ "Delimiter for here document is too long");
    *d++ = '\n';
    *d = '\0';
    len = d - PL_tokenbuf;

#ifndef PERL_STRICT_CR
    d = strchr(s, '\r');
    if (d) {
	char * const olds = s;
	s = d;
	while (s < PL_bufend) {
	    if (*s == '\r') {
		*d++ = '\n';
		if (*++s == '\n')
		    s++;
	    }
	    else if (*s == '\n' && s[1] == '\r') {	/* \015\013 on a mac? */
		*d++ = *s++;
		s++;
	    }
	    else
		*d++ = *s++;
	}
	*d = '\0';
	PL_bufend = d;
	SvCUR_set(PL_linestr, PL_bufend - SvPVX_const(PL_linestr));
	s = olds;
    }
#endif

    tmpstr = newSV_type(SVt_PVIV);
    SvGROW(tmpstr, 80);
    if (term == '\'') {
	op_type = OP_CONST;
	SvIV_set(tmpstr, -1);
    }
    else if (term == '`') {
	op_type = OP_BACKTICK;
	SvIV_set(tmpstr, '\\');
    }

    PL_multi_start = origline + 1 + PL_parser->herelines;
    PL_multi_open = PL_multi_close = '<';
    /* inside a string eval or quote-like operator */
    if (!infile || PL_lex_inwhat) {
	SV *linestr;
	char *bufend;
	char * const olds = s;
	PERL_CONTEXT * const cx = CX_CUR();
	/* These two fields are not set until an inner lexing scope is
	   entered.  But we need them set here. */
	shared->ls_bufptr  = s;
	shared->ls_linestr = PL_linestr;
	if (PL_lex_inwhat)
	  /* Look for a newline.  If the current buffer does not have one,
	     peek into the line buffer of the parent lexing scope, going
 	     up as many levels as necessary to find one with a newline
	     after bufptr.
	   */
	  while (!(s = (char *)memchr(
		    (void *)shared->ls_bufptr, '\n',
		    SvEND(shared->ls_linestr)-shared->ls_bufptr
		))) {
	    shared = shared->ls_prev;
	    /* shared is only null if we have gone beyond the outermost
	       lexing scope.  In a file, we will have broken out of the
	       loop in the previous iteration.  In an eval, the string buf-
	       fer ends with "\n;", so the while condition above will have
	       evaluated to false.  So shared can never be null.  Or so you
	       might think.  Odd syntax errors like s;@@{<<; can gobble up
	       the implicit semicolon at the end of a flie, causing the
	       file handle to be closed even when we are not in a string
	       eval.  So shared may be null in that case.  */
	    if (UNLIKELY(!shared))
		goto interminable;
	    /* A LEXSHARED struct with a null ls_prev pointer is the outer-
	       most lexing scope.  In a file, shared->ls_linestr at that
	       level is just one line, so there is no body to steal. */
	    if (infile && !shared->ls_prev) {
		s = olds;
		goto streaming;
	    }
	  }
	else {	/* eval or we've already hit EOF */
	    s = (char*)memchr((void*)s, '\n', PL_bufend - s);
	    if (!s)
                goto interminable;
	}
	linestr = shared->ls_linestr;
	bufend = SvEND(linestr);
	d = s;
	while (s < bufend - len + 1
               && memNE(s,PL_tokenbuf,len) )
        {
	    if (*s++ == '\n')
		++PL_parser->herelines;
	}
	if (s >= bufend - len + 1) {
	    goto interminable;
	}
	sv_setpvn(tmpstr,d+1,s-d);
	s += len - 1;
	/* the preceding stmt passes a newline */
	PL_parser->herelines++;

	/* s now points to the newline after the heredoc terminator.
	   d points to the newline before the body of the heredoc.
	 */

	/* We are going to modify linestr in place here, so set
	   aside copies of the string if necessary for re-evals or
	   (caller $n)[6]. */
	/* See the Paranoia note in case LEX_INTERPEND in yylex, for why we
	   check shared->re_eval_str. */
	if (shared->re_eval_start || shared->re_eval_str) {
	    /* Set aside the rest of the regexp */
	    if (!shared->re_eval_str)
		shared->re_eval_str =
		       newSVpvn(shared->re_eval_start,
				bufend - shared->re_eval_start);
	    shared->re_eval_start -= s-d;
	}
	if (cxstack_ix >= 0
            && CxTYPE(cx) == CXt_EVAL
            && CxOLD_OP_TYPE(cx) == OP_ENTEREVAL
            && cx->blk_eval.cur_text == linestr)
        {
	    cx->blk_eval.cur_text = newSVsv(linestr);
	    SvSCREAM_on(cx->blk_eval.cur_text);
	}
	/* Copy everything from s onwards back to d. */
	Move(s,d,bufend-s + 1,char);
	SvCUR_set(linestr, SvCUR(linestr) - (s-d));
	/* Setting PL_bufend only applies when we have not dug deeper
	   into other scopes, because sublex_done sets PL_bufend to
	   SvEND(PL_linestr). */
	if (shared == PL_parser->lex_shared) PL_bufend = SvEND(linestr);
	s = olds;
    }
    else
    {
      SV *linestr_save;
      char *oldbufptr_save;
     streaming:
      sv_setpvs(tmpstr,"");   /* avoid "uninitialized" warning */
      term = PL_tokenbuf[1];
      len--;
      linestr_save = PL_linestr; /* must restore this afterwards */
      d = s;			 /* and this */
      oldbufptr_save = PL_oldbufptr;
      PL_linestr = newSVpvs("");
      PL_bufend = SvPVX(PL_linestr);
      while (1) {
	PL_bufptr = PL_bufend;
	CopLINE_set(PL_curcop,
		    origline + 1 + PL_parser->herelines);
	if (!lex_next_chunk(LEX_NO_TERM)
	 && (!SvCUR(tmpstr) || SvEND(tmpstr)[-1] != '\n')) {
	    /* Simply freeing linestr_save might seem simpler here, as it
	       does not matter what PL_linestr points to, since we are
	       about to croak; but in a quote-like op, linestr_save
	       will have been prospectively freed already, via
	       SAVEFREESV(PL_linestr) in sublex_push, so its easier to
	       restore PL_linestr. */
	    SvREFCNT_dec_NN(PL_linestr);
	    PL_linestr = linestr_save;
            PL_oldbufptr = oldbufptr_save;
	    goto interminable;
	}
	CopLINE_set(PL_curcop, origline);
	if (!SvCUR(PL_linestr) || PL_bufend[-1] != '\n') {
            s = lex_grow_linestr(SvLEN(PL_linestr) + 3);
            /* ^That should be enough to avoid this needing to grow:  */
	    sv_catpvs(PL_linestr, "\n\0");
            assert(s == SvPVX(PL_linestr));
            PL_bufend = SvEND(PL_linestr);
	}
	s = PL_bufptr;
	PL_parser->herelines++;
	PL_last_lop = PL_last_uni = NULL;
#ifndef PERL_STRICT_CR
	if (PL_bufend - PL_linestart >= 2) {
	    if (   (PL_bufend[-2] == '\r' && PL_bufend[-1] == '\n')
                || (PL_bufend[-2] == '\n' && PL_bufend[-1] == '\r'))
	    {
		PL_bufend[-2] = '\n';
		PL_bufend--;
		SvCUR_set(PL_linestr, PL_bufend - SvPVX_const(PL_linestr));
	    }
	    else if (PL_bufend[-1] == '\r')
		PL_bufend[-1] = '\n';
	}
	else if (PL_bufend - PL_linestart == 1 && PL_bufend[-1] == '\r')
	    PL_bufend[-1] = '\n';
#endif
	if (*s == term && PL_bufend-s >= len
	 && memEQ(s,PL_tokenbuf + 1,len)) {
	    SvREFCNT_dec(PL_linestr);
	    PL_linestr = linestr_save;
	    PL_linestart = SvPVX(linestr_save);
	    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
            PL_oldbufptr = oldbufptr_save;
	    s = d;
	    break;
	}
	else {
	    sv_catsv(tmpstr,PL_linestr);
	}
      }
    }
    PL_multi_end = origline + PL_parser->herelines;
    if (SvCUR(tmpstr) + 5 < SvLEN(tmpstr)) {
	SvPV_shrink_to_cur(tmpstr);
    }
    if (!IN_BYTES) {
	if (UTF && is_utf8_string((U8*)SvPVX_const(tmpstr), SvCUR(tmpstr)))
	    SvUTF8_on(tmpstr);
	else if (IN_ENCODING)
	    sv_recode_to_utf8(tmpstr, _get_encoding());
    }
    PL_lex_stuff = tmpstr;
    pl_yylval.ival = op_type;
    return s;

  interminable:
    SvREFCNT_dec(tmpstr);
    CopLINE_set(PL_curcop, origline);
    missingterm(PL_tokenbuf + 1);
}

/* scan_inputsymbol
   takes: current position in input buffer
   returns: new position in input buffer
   side-effects: pl_yylval and lex_op are set.

   This code handles:

   <>		read from ARGV
   <<>>		read from ARGV without magic open
   <FH> 	read from filehandle
   <pkg::FH>	read from package qualified filehandle
   <pkg'FH>	read from package qualified filehandle
   <$fh>	read from filehandle in $fh
   <*.h>	filename glob

*/

STATIC char *
S_scan_inputsymbol(pTHX_ char *start)
{
    char *s = start;		/* current position in buffer */
    char *end;
    I32 len;
    bool nomagicopen = FALSE;
    char *d = PL_tokenbuf;					/* start of temp holding space */
    const char * const e = PL_tokenbuf + sizeof PL_tokenbuf;	/* end of temp holding space */

    PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL;

    end = strchr(s, '\n');
    if (!end)
	end = PL_bufend;
    if (s[1] == '<' && s[2] == '>' && s[3] == '>') {
        nomagicopen = TRUE;
        *d = '\0';
        len = 0;
        s += 3;
    }
    else
        s = delimcpy(d, e, s + 1, end, '>', &len);	/* extract until > */

    /* die if we didn't have space for the contents of the <>,
       or if it didn't end, or if we see a newline
    */

    if (len >= (I32)sizeof PL_tokenbuf)
	Perl_croak(aTHX_ "Excessively long <> operator");
    if (s >= end)
	Perl_croak(aTHX_ "Unterminated <> operator");

    s++;

    /* check for <$fh>
       Remember, only scalar variables are interpreted as filehandles by
       this code.  Anything more complex (e.g., <$fh{$num}>) will be
       treated as a glob() call.
       This code makes use of the fact that except for the $ at the front,
       a scalar variable and a filehandle look the same.
    */
    if (*d == '$' && d[1]) d++;

    /* allow <Pkg'VALUE> or <Pkg::VALUE> */
    while (*d && (isWORDCHAR_lazy_if(d,UTF) || *d == '\'' || *d == ':'))
	d += UTF ? UTF8SKIP(d) : 1;

    /* If we've tried to read what we allow filehandles to look like, and
       there's still text left, then it must be a glob() and not a getline.
       Use scan_str to pull out the stuff between the <> and treat it
       as nothing more than a string.
    */

    if (d - PL_tokenbuf != len) {
	pl_yylval.ival = OP_GLOB;
	s = scan_str(start,FALSE,FALSE,FALSE,NULL);
	if (!s)
	   Perl_croak(aTHX_ "Glob not terminated");
	return s;
    }
    else {
	bool readline_overriden = FALSE;
	GV *gv_readline;
    	/* we're in a filehandle read situation */
	d = PL_tokenbuf;

	/* turn <> into <ARGV> */
	if (!len)
	    Copy("ARGV",d,5,char);

	/* Check whether readline() is overriden */
	if ((gv_readline = gv_override("readline",8)))
	    readline_overriden = TRUE;

	/* if <$fh>, create the ops to turn the variable into a
	   filehandle
	*/
	if (*d == '$') {
	    /* try to find it in the pad for this block, otherwise find
	       add symbol table ops
	    */
	    const PADOFFSET tmp = pad_findmy_pvn(d, len, 0);
	    if (tmp != NOT_IN_PAD) {
		if (PAD_COMPNAME_FLAGS_isOUR(tmp)) {
		    HV * const stash = PAD_COMPNAME_OURSTASH(tmp);
		    HEK * const stashname = HvNAME_HEK(stash);
		    SV * const sym = sv_2mortal(newSVhek(stashname));
		    sv_catpvs(sym, "::");
		    sv_catpv(sym, d+1);
		    d = SvPVX(sym);
		    goto intro_sym;
		}
		else {
		    OP * const o = newOP(OP_PADSV, 0);
		    o->op_targ = tmp;
		    PL_lex_op = readline_overriden
			? (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
				op_append_elem(OP_LIST, o,
				    newCVREF(0, newGVOP(OP_GV,0,gv_readline))))
			: (OP*)newUNOP(OP_READLINE, 0, o);
		}
	    }
	    else {
		GV *gv;
		++d;
              intro_sym:
		gv = gv_fetchpv(d,
				GV_ADDMULTI | ( UTF ? SVf_UTF8 : 0 ),
				SVt_PV);
		PL_lex_op = readline_overriden
		    ? (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
			    op_append_elem(OP_LIST,
				newUNOP(OP_RV2SV, 0, newGVOP(OP_GV, 0, gv)),
				newCVREF(0, newGVOP(OP_GV, 0, gv_readline))))
		    : (OP*)newUNOP(OP_READLINE, 0,
			    newUNOP(OP_RV2SV, 0,
				newGVOP(OP_GV, 0, gv)));
	    }
	    /* we created the ops in PL_lex_op, so make pl_yylval.ival a null op */
	    pl_yylval.ival = OP_NULL;
	}

	/* If it's none of the above, it must be a literal filehandle
	   (<Foo::BAR> or <FOO>) so build a simple readline OP */
	else {
	    GV * const gv = gv_fetchpv(d, GV_ADD | ( UTF ? SVf_UTF8 : 0 ), SVt_PVIO);
	    PL_lex_op = readline_overriden
		? (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
			op_append_elem(OP_LIST,
			    newGVOP(OP_GV, 0, gv),
			    newCVREF(0, newGVOP(OP_GV, 0, gv_readline))))
		: (OP*)newUNOP(OP_READLINE, nomagicopen ? OPf_SPECIAL : 0, newGVOP(OP_GV, 0, gv));
	    pl_yylval.ival = OP_NULL;
	}
    }

    return s;
}


/* scan_str
   takes:
	start			position in buffer
        keep_bracketed_quoted   preserve \ quoting of embedded delimiters, but
                                only if they are of the open/close form
	keep_delims		preserve the delimiters around the string
	re_reparse		compiling a run-time /(?{})/:
				   collapse // to /,  and skip encoding src
	delimp			if non-null, this is set to the position of
				the closing delimiter, or just after it if
				the closing and opening delimiters differ
				(i.e., the opening delimiter of a substitu-
				tion replacement)
   returns: position to continue reading from buffer
   side-effects: multi_start, multi_close, lex_repl or lex_stuff, and
   	updates the read buffer.

   This subroutine pulls a string out of the input.  It is called for:
   	q		single quotes		q(literal text)
	'		single quotes		'literal text'
	qq		double quotes		qq(interpolate $here please)
	"		double quotes		"interpolate $here please"
	qx		backticks		qx(/bin/ls -l)
	`		backticks		`/bin/ls -l`
	qw		quote words		@@EXPORT_OK = qw( func() $spam )
	m//		regexp match		m/this/
	s///		regexp substitute	s/this/that/
	tr///		string transliterate	tr/this/that/
	y///		string transliterate	y/this/that/
	($*@@)		sub prototypes		sub foo ($)
	(stuff)		sub attr parameters	sub foo : attr(stuff)
	<>		readline or globs	<FOO>, <>, <$fh>, or <*.c>
	
   In most of these cases (all but <>, patterns and transliterate)
   yylex() calls scan_str().  m// makes yylex() call scan_pat() which
   calls scan_str().  s/// makes yylex() call scan_subst() which calls
   scan_str().  tr/// and y/// make yylex() call scan_trans() which
   calls scan_str().

   It skips whitespace before the string starts, and treats the first
   character as the delimiter.  If the delimiter is one of ([{< then
   the corresponding "close" character )]}> is used as the closing
   delimiter.  It allows quoting of delimiters, and if the string has
   balanced delimiters ([{<>}]) it allows nesting.

   On success, the SV with the resulting string is put into lex_stuff or,
   if that is already non-NULL, into lex_repl. The second case occurs only
   when parsing the RHS of the special constructs s/// and tr/// (y///).
   For convenience, the terminating delimiter character is stuffed into
   SvIVX of the SV.
*/

STATIC char *
S_scan_str(pTHX_ char *start, int keep_bracketed_quoted, int keep_delims, int re_reparse,
		 char **delimp
    )
{
    SV *sv;			/* scalar value: string */
    const char *tmps;		/* temp string, used for delimiter matching */
    char *s = start;		/* current position in the buffer */
    char term;			/* terminating character */
    char *to;			/* current position in the sv's data */
    I32 brackets = 1;		/* bracket nesting level */
    bool has_utf8 = FALSE;	/* is there any utf8 content? */
    I32 termcode;		/* terminating char. code */
    U8 termstr[UTF8_MAXBYTES];	/* terminating string */
    STRLEN termlen;		/* length of terminating string */
    int last_off = 0;		/* last position for nesting bracket */
    line_t herelines;

    PERL_ARGS_ASSERT_SCAN_STR;

    /* skip space before the delimiter */
    if (isSPACE(*s)) {
	s = skipspace(s);
    }

    /* mark where we are, in case we need to report errors */
    CLINE;

    /* after skipping whitespace, the next character is the terminator */
    term = *s;
    if (!UTF) {
	termcode = termstr[0] = term;
	termlen = 1;
    }
    else {
	termcode = utf8_to_uvchr_buf((U8*)s, (U8*)PL_bufend, &termlen);
	Copy(s, termstr, termlen, U8);
	if (!UTF8_IS_INVARIANT(term))
	    has_utf8 = TRUE;
    }

    /* mark where we are */
    PL_multi_start = CopLINE(PL_curcop);
    PL_multi_open = term;
    herelines = PL_parser->herelines;

    /* find corresponding closing delimiter */
    if (term && (tmps = strchr("([{< )]}> )]}>",term)))
	termcode = termstr[0] = term = tmps[5];

    PL_multi_close = term;

    if (PL_multi_open == PL_multi_close) {
        keep_bracketed_quoted = FALSE;
    }

    /* create a new SV to hold the contents.  79 is the SV's initial length.
       What a random number. */
    sv = newSV_type(SVt_PVIV);
    SvGROW(sv, 80);
    SvIV_set(sv, termcode);
    (void)SvPOK_only(sv);		/* validate pointer */

    /* move past delimiter and try to read a complete string */
    if (keep_delims)
	sv_catpvn(sv, s, termlen);
    s += termlen;
    for (;;) {
	if (IN_ENCODING && !UTF && !re_reparse) {
	    bool cont = TRUE;

	    while (cont) {
		int offset = s - SvPVX_const(PL_linestr);
		const bool found = sv_cat_decode(sv, _get_encoding(), PL_linestr,
					   &offset, (char*)termstr, termlen);
		const char *ns;
		char *svlast;

		if (SvIsCOW(PL_linestr)) {
		    STRLEN bufend_pos, bufptr_pos, oldbufptr_pos;
		    STRLEN oldoldbufptr_pos, linestart_pos, last_uni_pos;
		    STRLEN last_lop_pos, re_eval_start_pos, s_pos;
		    char *buf = SvPVX(PL_linestr);
		    bufend_pos = PL_parser->bufend - buf;
		    bufptr_pos = PL_parser->bufptr - buf;
		    oldbufptr_pos = PL_parser->oldbufptr - buf;
		    oldoldbufptr_pos = PL_parser->oldoldbufptr - buf;
		    linestart_pos = PL_parser->linestart - buf;
		    last_uni_pos = PL_parser->last_uni
			? PL_parser->last_uni - buf
			: 0;
		    last_lop_pos = PL_parser->last_lop
			? PL_parser->last_lop - buf
			: 0;
		    re_eval_start_pos =
			PL_parser->lex_shared->re_eval_start ?
                            PL_parser->lex_shared->re_eval_start - buf : 0;
		    s_pos = s - buf;

		    sv_force_normal(PL_linestr);

		    buf = SvPVX(PL_linestr);
		    PL_parser->bufend = buf + bufend_pos;
		    PL_parser->bufptr = buf + bufptr_pos;
		    PL_parser->oldbufptr = buf + oldbufptr_pos;
		    PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
		    PL_parser->linestart = buf + linestart_pos;
		    if (PL_parser->last_uni)
			PL_parser->last_uni = buf + last_uni_pos;
		    if (PL_parser->last_lop)
			PL_parser->last_lop = buf + last_lop_pos;
		    if (PL_parser->lex_shared->re_eval_start)
		        PL_parser->lex_shared->re_eval_start  =
			    buf + re_eval_start_pos;
		    s = buf + s_pos;
		}
		ns = SvPVX_const(PL_linestr) + offset;
		svlast = SvEND(sv) - 1;

		for (; s < ns; s++) {
		    if (*s == '\n' && !PL_rsfp && !PL_parser->filtered)
			COPLINE_INC_WITH_HERELINES;
		}
		if (!found)
		    goto read_more_line;
		else {
		    /* handle quoted delimiters */
		    if (SvCUR(sv) > 1 && *(svlast-1) == '\\') {
			const char *t;
			for (t = svlast-2; t >= SvPVX_const(sv) && *t == '\\';)
			    t--;
			if ((svlast-1 - t) % 2) {
			    if (!keep_bracketed_quoted) {
				*(svlast-1) = term;
				*svlast = '\0';
				SvCUR_set(sv, SvCUR(sv) - 1);
			    }
			    continue;
			}
		    }
		    if (PL_multi_open == PL_multi_close) {
			cont = FALSE;
		    }
		    else {
			const char *t;
			char *w;
			for (t = w = SvPVX(sv)+last_off; t < svlast; w++, t++) {
			    /* At here, all closes are "was quoted" one,
			       so we don't check PL_multi_close. */
			    if (*t == '\\') {
				if (!keep_bracketed_quoted && *(t+1) == PL_multi_open)
				    t++;
				else
				    *w++ = *t++;
			    }
			    else if (*t == PL_multi_open)
				brackets++;

			    *w = *t;
			}
			if (w < t) {
			    *w++ = term;
			    *w = '\0';
			    SvCUR_set(sv, w - SvPVX_const(sv));
			}
			last_off = w - SvPVX(sv);
			if (--brackets <= 0)
			    cont = FALSE;
		    }
		}
	    }
	    if (!keep_delims) {
		SvCUR_set(sv, SvCUR(sv) - 1);
		*SvEND(sv) = '\0';
	    }
	    break;
	}

    	/* extend sv if need be */
	SvGROW(sv, SvCUR(sv) + (PL_bufend - s) + 1);
	/* set 'to' to the next character in the sv's string */
	to = SvPVX(sv)+SvCUR(sv);

	/* if open delimiter is the close delimiter read unbridle */
	if (PL_multi_open == PL_multi_close) {
	    for (; s < PL_bufend; s++,to++) {
	    	/* embedded newlines increment the current line number */
		if (*s == '\n' && !PL_rsfp && !PL_parser->filtered)
		    COPLINE_INC_WITH_HERELINES;
		/* handle quoted delimiters */
		if (*s == '\\' && s+1 < PL_bufend && term != '\\') {
		    if (!keep_bracketed_quoted
		        && (s[1] == term
			    || (re_reparse && s[1] == '\\'))
		    )
			s++;
		    else /* any other quotes are simply copied straight through */
			*to++ = *s++;
		}
		/* terminate when run out of buffer (the for() condition), or
		   have found the terminator */
		else if (*s == term) {
		    if (termlen == 1)
			break;
		    if (s+termlen <= PL_bufend && memEQ(s, (char*)termstr, termlen))
			break;
		}
		else if (!has_utf8 && !UTF8_IS_INVARIANT((U8)*s) && UTF)
		    has_utf8 = TRUE;
		*to = *s;
	    }
	}
	
	/* if the terminator isn't the same as the start character (e.g.,
	   matched brackets), we have to allow more in the quoting, and
	   be prepared for nested brackets.
	*/
	else {
	    /* read until we run out of string, or we find the terminator */
	    for (; s < PL_bufend; s++,to++) {
	    	/* embedded newlines increment the line count */
		if (*s == '\n' && !PL_rsfp && !PL_parser->filtered)
		    COPLINE_INC_WITH_HERELINES;
		/* backslashes can escape the open or closing characters */
		if (*s == '\\' && s+1 < PL_bufend) {
		    if (!keep_bracketed_quoted
                       && ((s[1] == PL_multi_open) || (s[1] == PL_multi_close)))
                    {
			s++;
                    }
		    else
			*to++ = *s++;
                }
		/* allow nested opens and closes */
		else if (*s == PL_multi_close && --brackets <= 0)
		    break;
		else if (*s == PL_multi_open)
		    brackets++;
		else if (!has_utf8 && !UTF8_IS_INVARIANT((U8)*s) && UTF)
		    has_utf8 = TRUE;
		*to = *s;
	    }
	}
	/* terminate the copied string and update the sv's end-of-string */
	*to = '\0';
	SvCUR_set(sv, to - SvPVX_const(sv));

	/*
	 * this next chunk reads more into the buffer if we're not done yet
	 */

  	if (s < PL_bufend)
	    break;		/* handle case where we are done yet :-) */

#ifndef PERL_STRICT_CR
	if (to - SvPVX_const(sv) >= 2) {
	    if (   (to[-2] == '\r' && to[-1] == '\n')
                || (to[-2] == '\n' && to[-1] == '\r'))
	    {
		to[-2] = '\n';
		to--;
		SvCUR_set(sv, to - SvPVX_const(sv));
	    }
	    else if (to[-1] == '\r')
		to[-1] = '\n';
	}
	else if (to - SvPVX_const(sv) == 1 && to[-1] == '\r')
	    to[-1] = '\n';
#endif
	
     read_more_line:
	/* if we're out of file, or a read fails, bail and reset the current
	   line marker so we can report where the unterminated string began
	*/
	COPLINE_INC_WITH_HERELINES;
	PL_bufptr = PL_bufend;
	if (!lex_next_chunk(0)) {
	    sv_free(sv);
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
	    return NULL;
	}
	s = PL_bufptr;
    }

    /* at this point, we have successfully read the delimited string */

    if (!IN_ENCODING || UTF || re_reparse) {

	if (keep_delims)
	    sv_catpvn(sv, s, termlen);
	s += termlen;
    }
    if (has_utf8 || (IN_ENCODING && !re_reparse))
	SvUTF8_on(sv);

    PL_multi_end = CopLINE(PL_curcop);
    CopLINE_set(PL_curcop, PL_multi_start);
    PL_parser->herelines = herelines;

    /* if we allocated too much space, give some back */
    if (SvCUR(sv) + 5 < SvLEN(sv)) {
	SvLEN_set(sv, SvCUR(sv) + 1);
	SvPV_renew(sv, SvLEN(sv));
    }

    /* decide whether this is the first or second quoted string we've read
       for this op
    */

    if (PL_lex_stuff)
	PL_sublex_info.repl = sv;
    else
	PL_lex_stuff = sv;
    if (delimp) *delimp = PL_multi_open == PL_multi_close ? s-termlen : s;
    return s;
}

/*
  scan_num
  takes: pointer to position in buffer
  returns: pointer to new position in buffer
  side-effects: builds ops for the constant in pl_yylval.op

  Read a number in any of the formats that Perl accepts:

  \d(_?\d)*(\.(\d(_?\d)*)?)?[Ee][\+\-]?(\d(_?\d)*)	12 12.34 12.
  \.\d(_?\d)*[Ee][\+\-]?(\d(_?\d)*)			.34
  0b[01](_?[01])*                                       binary integers
  0[0-7](_?[0-7])*                                      octal integers
  0x[0-9A-Fa-f](_?[0-9A-Fa-f])*                         hexadecimal integers
  0x[0-9A-Fa-f](_?[0-9A-Fa-f])*(?:\.\d*)?p[+-]?[0-9]+   hexadecimal floats

  Like most scan_ routines, it uses the PL_tokenbuf buffer to hold the
  thing it reads.

  If it reads a number without a decimal point or an exponent, it will
  try converting the number to an integer and see if it can do so
  without loss of precision.
*/

char *
Perl_scan_num(pTHX_ const char *start, YYSTYPE* lvalp)
{
    const char *s = start;	/* current position in buffer */
    char *d;			/* destination in temp buffer */
    char *e;			/* end of temp buffer */
    NV nv;				/* number read, as a double */
    SV *sv = NULL;			/* place to put the converted number */
    bool floatit;			/* boolean: int or float? */
    const char *lastub = NULL;		/* position of last underbar */
    static const char* const number_too_long = "Number too long";
    /* Hexadecimal floating point.
     *
     * In many places (where we have quads and NV is IEEE 754 double)
     * we can fit the mantissa bits of a NV into an unsigned quad.
     * (Note that UVs might not be quads even when we have quads.)
     * This will not work everywhere, though (either no quads, or
     * using long doubles), in which case we have to resort to NV,
     * which will probably mean horrible loss of precision due to
     * multiple fp operations. */
    bool hexfp = FALSE;
    int total_bits = 0;
    int significant_bits = 0;
#if NVSIZE == 8 && defined(HAS_QUAD) && defined(Uquad_t)
#  define HEXFP_UQUAD
    Uquad_t hexfp_uquad = 0;
    int hexfp_frac_bits = 0;
#else
#  define HEXFP_NV
    NV hexfp_nv = 0.0;
#endif
    NV hexfp_mult = 1.0;
    UV high_non_zero = 0; /* highest digit */
    int non_zero_integer_digits = 0;

    PERL_ARGS_ASSERT_SCAN_NUM;

    /* We use the first character to decide what type of number this is */

    switch (*s) {
    default:
	Perl_croak(aTHX_ "panic: scan_num, *s=%d", *s);

    /* if it starts with a 0, it could be an octal number, a decimal in
       0.13 disguise, or a hexadecimal number, or a binary number. */
    case '0':
	{
	  /* variables:
	     u		holds the "number so far"
	     shift	the power of 2 of the base
			(hex == 4, octal == 3, binary == 1)
	     overflowed	was the number more than we can hold?

	     Shift is used when we add a digit.  It also serves as an "are
	     we in octal/hex/binary?" indicator to disallow hex characters
	     when in octal mode.
	   */
	    NV n = 0.0;
	    UV u = 0;
	    I32 shift;
	    bool overflowed = FALSE;
	    bool just_zero  = TRUE;	/* just plain 0 or binary number? */
	    static const NV nvshift[5] = { 1.0, 2.0, 4.0, 8.0, 16.0 };
	    static const char* const bases[5] =
	      { "", "binary", "", "octal", "hexadecimal" };
	    static const char* const Bases[5] =
	      { "", "Binary", "", "Octal", "Hexadecimal" };
	    static const char* const maxima[5] =
	      { "",
		"0b11111111111111111111111111111111",
		"",
		"037777777777",
		"0xffffffff" };
	    const char *base, *Base, *max;

	    /* check for hex */
	    if (isALPHA_FOLD_EQ(s[1], 'x')) {
		shift = 4;
		s += 2;
		just_zero = FALSE;
	    } else if (isALPHA_FOLD_EQ(s[1], 'b')) {
		shift = 1;
		s += 2;
		just_zero = FALSE;
	    }
	    /* check for a decimal in disguise */
	    else if (s[1] == '.' || isALPHA_FOLD_EQ(s[1], 'e'))
		goto decimal;
	    /* so it must be octal */
	    else {
		shift = 3;
		s++;
	    }

	    if (*s == '_') {
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
	       lastub = s++;
	    }

	    base = bases[shift];
	    Base = Bases[shift];
	    max  = maxima[shift];

	    /* read the rest of the number */
	    for (;;) {
		/* x is used in the overflow test,
		   b is the digit we're adding on. */
		UV x, b;

		switch (*s) {

		/* if we don't mention it, we're done */
		default:
		    goto out;

		/* _ are ignored -- but warned about if consecutive */
		case '_':
		    if (lastub && s == lastub + 1)
		        Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				       "Misplaced _ in number");
		    lastub = s++;
		    break;

		/* 8 and 9 are not octal */
		case '8': case '9':
		    if (shift == 3)
			yyerror(Perl_form(aTHX_ "Illegal octal digit '%c'", *s));
		    /* FALLTHROUGH */

	        /* octal digits */
		case '2': case '3': case '4':
		case '5': case '6': case '7':
		    if (shift == 1)
			yyerror(Perl_form(aTHX_ "Illegal binary digit '%c'", *s));
		    /* FALLTHROUGH */

		case '0': case '1':
		    b = *s++ & 15;		/* ASCII digit -> value of digit */
		    goto digit;

	        /* hex digits */
		case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
		case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
		    /* make sure they said 0x */
		    if (shift != 4)
			goto out;
		    b = (*s++ & 7) + 9;

		    /* Prepare to put the digit we have onto the end
		       of the number so far.  We check for overflows.
		    */

		  digit:
		    just_zero = FALSE;
		    if (!overflowed) {
			x = u << shift;	/* make room for the digit */

                        total_bits += shift;

			if ((x >> shift) != u
			    && !(PL_hints & HINT_NEW_BINARY)) {
			    overflowed = TRUE;
			    n = (NV) u;
			    Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
					     "Integer overflow in %s number",
					     base);
			} else
			    u = x | b;		/* add the digit to the end */
		    }
		    if (overflowed) {
			n *= nvshift[shift];
			/* If an NV has not enough bits in its
			 * mantissa to represent an UV this summing of
			 * small low-order numbers is a waste of time
			 * (because the NV cannot preserve the
			 * low-order bits anyway): we could just
			 * remember when did we overflow and in the
			 * end just multiply n by the right
			 * amount. */
			n += (NV) b;
		    }

                    if (high_non_zero == 0 && b > 0)
                        high_non_zero = b;

                    if (high_non_zero)
                        non_zero_integer_digits++;

                    /* this could be hexfp, but peek ahead
                     * to avoid matching ".." */
                    if (UNLIKELY(HEXFP_PEEK(s))) {
                        goto out;
                    }

		    break;
		}
	    }

	  /* if we get here, we had success: make a scalar value from
	     the number.
	  */
	  out:

	    /* final misplaced underbar check */
	    if (s[-1] == '_') {
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
	    }

            if (UNLIKELY(HEXFP_PEEK(s))) {
                /* Do sloppy (on the underbars) but quick detection
                 * (and value construction) for hexfp, the decimal
                 * detection will shortly be more thorough with the
                 * underbar checks. */
                const char* h = s;
                significant_bits = non_zero_integer_digits * shift;
#ifdef HEXFP_UQUAD
                hexfp_uquad = u;
#else /* HEXFP_NV */
                hexfp_nv = u;
#endif
                /* Ignore the leading zero bits of
                 * the high (first) non-zero digit. */
                if (high_non_zero) {
                    if (high_non_zero < 0x8)
                        significant_bits--;
                    if (high_non_zero < 0x4)
                        significant_bits--;
                    if (high_non_zero < 0x2)
                        significant_bits--;
                }

                if (*h == '.') {
#ifdef HEXFP_NV
                    NV nv_mult = 1.0;
#endif
                    bool accumulate = TRUE;
                    for (h++; (isXDIGIT(*h) || *h == '_'); h++) {
                        if (isXDIGIT(*h)) {
                            U8 b = XDIGIT_VALUE(*h);
                            significant_bits += shift;
#ifdef HEXFP_UQUAD
                            if (accumulate) {
                                if (significant_bits < NV_MANT_DIG) {
                                    /* We are in the long "run" of xdigits,
                                     * accumulate the full four bits. */
                                    hexfp_uquad <<= shift;
                                    hexfp_uquad |= b;
                                    hexfp_frac_bits += shift;
                                } else {
                                    /* We are at a hexdigit either at,
                                     * or straddling, the edge of mantissa.
                                     * We will try grabbing as many as
                                     * possible bits. */
                                    int tail =
                                      significant_bits - NV_MANT_DIG;
                                    if (tail <= 0)
                                       tail += shift;
                                    hexfp_uquad <<= tail;
                                    hexfp_uquad |= b >> (shift - tail);
                                    hexfp_frac_bits += tail;

                                    /* Ignore the trailing zero bits
                                     * of the last non-zero xdigit.
                                     *
                                     * The assumption here is that if
                                     * one has input of e.g. the xdigit
                                     * eight (0x8), there is only one
                                     * bit being input, not the full
                                     * four bits.  Conversely, if one
                                     * specifies a zero xdigit, the
                                     * assumption is that one really
                                     * wants all those bits to be zero. */
                                    if (b) {
                                        if ((b & 0x1) == 0x0) {
                                            significant_bits--;
                                            if ((b & 0x2) == 0x0) {
                                                significant_bits--;
                                                if ((b & 0x4) == 0x0) {
                                                    significant_bits--;
                                                }
                                            }
                                        }
                                    }

                                    accumulate = FALSE;
                                }
                            } else {
                                /* Keep skipping the xdigits, and
                                 * accumulating the significant bits,
                                 * but do not shift the uquad
                                 * (which would catastrophically drop
                                 * high-order bits) or accumulate the
                                 * xdigits anymore. */
                            }
#else /* HEXFP_NV */
                            if (accumulate) {
                                nv_mult /= 16.0;
                                if (nv_mult > 0.0)
                                    hexfp_nv += b * nv_mult;
                                else
                                    accumulate = FALSE;
                            }
#endif
                        }
                        if (significant_bits >= NV_MANT_DIG)
                            accumulate = FALSE;
                    }
                }

                if ((total_bits > 0 || significant_bits > 0) &&
                    isALPHA_FOLD_EQ(*h, 'p')) {
                    bool negexp = FALSE;
                    h++;
                    if (*h == '+')
                        h++;
                    else if (*h == '-') {
                        negexp = TRUE;
                        h++;
                    }
                    if (isDIGIT(*h)) {
                        I32 hexfp_exp = 0;
                        while (isDIGIT(*h) || *h == '_') {
                            if (isDIGIT(*h)) {
                                hexfp_exp *= 10;
                                hexfp_exp += *h - '0';
#ifdef NV_MIN_EXP
                                if (negexp
                                    && -hexfp_exp < NV_MIN_EXP - 1) {
                                    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                                   "Hexadecimal float: exponent underflow");
                                    break;
                                }
#endif
#ifdef NV_MAX_EXP
                                if (!negexp
                                    && hexfp_exp > NV_MAX_EXP - 1) {
                                    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                                   "Hexadecimal float: exponent overflow");
                                    break;
                                }
#endif
                            }
                            h++;
                        }
                        if (negexp)
                            hexfp_exp = -hexfp_exp;
#ifdef HEXFP_UQUAD
                        hexfp_exp -= hexfp_frac_bits;
#endif
                        hexfp_mult = pow(2.0, hexfp_exp);
                        hexfp = TRUE;
                        goto decimal;
                    }
                }
            }

	    if (overflowed) {
		if (n > 4294967295.0)
		    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
				   "%s number > %s non-portable",
				   Base, max);
		sv = newSVnv(n);
	    }
	    else {
#if UVSIZE > 4
		if (u > 0xffffffff)
		    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
				   "%s number > %s non-portable",
				   Base, max);
#endif
		sv = newSVuv(u);
	    }
	    if (just_zero && (PL_hints & HINT_NEW_INTEGER))
		sv = new_constant(start, s - start, "integer",
				  sv, NULL, NULL, 0);
	    else if (PL_hints & HINT_NEW_BINARY)
		sv = new_constant(start, s - start, "binary", sv, NULL, NULL, 0);
	}
	break;

    /*
      handle decimal numbers.
      we're also sent here when we read a 0 as the first digit
    */
    case '1': case '2': case '3': case '4': case '5':
    case '6': case '7': case '8': case '9': case '.':
      decimal:
	d = PL_tokenbuf;
	e = PL_tokenbuf + sizeof PL_tokenbuf - 6; /* room for various punctuation */
        floatit = FALSE;
        if (hexfp) {
            floatit = TRUE;
            *d++ = '0';
            *d++ = 'x';
            s = start + 2;
        }

	/* read next group of digits and _ and copy into d */
	while (isDIGIT(*s)
               || *s == '_'
               || UNLIKELY(hexfp && isXDIGIT(*s)))
        {
	    /* skip underscores, checking for misplaced ones
	       if -w is on
	    */
	    if (*s == '_') {
		if (lastub && s == lastub + 1)
		    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Misplaced _ in number");
		lastub = s++;
	    }
	    else {
	        /* check for end of fixed-length buffer */
		if (d >= e)
		    Perl_croak(aTHX_ "%s", number_too_long);
		/* if we're ok, copy the character */
		*d++ = *s++;
	    }
	}

	/* final misplaced underbar check */
	if (lastub && s == lastub + 1) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
	}

	/* read a decimal portion if there is one.  avoid
	   3..5 being interpreted as the number 3. followed
	   by .5
	*/
	if (*s == '.' && s[1] != '.') {
	    floatit = TRUE;
	    *d++ = *s++;

	    if (*s == '_') {
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
		lastub = s;
	    }

	    /* copy, ignoring underbars, until we run out of digits.
	    */
	    for (; isDIGIT(*s)
                   || *s == '_'
                   || UNLIKELY(hexfp && isXDIGIT(*s));
                 s++)
            {
	        /* fixed length buffer check */
		if (d >= e)
		    Perl_croak(aTHX_ "%s", number_too_long);
		if (*s == '_') {
		   if (lastub && s == lastub + 1)
		       Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				      "Misplaced _ in number");
		   lastub = s;
		}
		else
		    *d++ = *s;
	    }
	    /* fractional part ending in underbar? */
	    if (s[-1] == '_') {
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
	    }
	    if (*s == '.' && isDIGIT(s[1])) {
		/* oops, it's really a v-string, but without the "v" */
		s = start;
		goto vstring;
	    }
	}

	/* read exponent part, if present */
	if ((isALPHA_FOLD_EQ(*s, 'e')
              || UNLIKELY(hexfp && isALPHA_FOLD_EQ(*s, 'p')))
            && strchr("+-0123456789_", s[1]))
        {
            floatit = TRUE;

	    /* regardless of whether user said 3E5 or 3e5, use lower 'e',
               ditto for p (hexfloats) */
            if ((isALPHA_FOLD_EQ(*s, 'e'))) {
		/* At least some Mach atof()s don't grok 'E' */
                *d++ = 'e';
            }
            else if (UNLIKELY(hexfp && (isALPHA_FOLD_EQ(*s, 'p')))) {
                *d++ = 'p';
            }

	    s++;


	    /* stray preinitial _ */
	    if (*s == '_') {
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
	        lastub = s++;
	    }

	    /* allow positive or negative exponent */
	    if (*s == '+' || *s == '-')
		*d++ = *s++;

	    /* stray initial _ */
	    if (*s == '_') {
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
	        lastub = s++;
	    }

	    /* read digits of exponent */
	    while (isDIGIT(*s) || *s == '_') {
	        if (isDIGIT(*s)) {
		    if (d >= e)
		        Perl_croak(aTHX_ "%s", number_too_long);
		    *d++ = *s++;
		}
		else {
		   if (((lastub && s == lastub + 1)
                        || (!isDIGIT(s[1]) && s[1] != '_')))
		       Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				      "Misplaced _ in number");
		   lastub = s++;
		}
	    }
	}


	/*
           We try to do an integer conversion first if no characters
           indicating "float" have been found.
	 */

	if (!floatit) {
    	    UV uv;
	    const int flags = grok_number (PL_tokenbuf, d - PL_tokenbuf, &uv);

            if (flags == IS_NUMBER_IN_UV) {
              if (uv <= IV_MAX)
		sv = newSViv(uv); /* Prefer IVs over UVs. */
              else
	    	sv = newSVuv(uv);
            } else if (flags == (IS_NUMBER_IN_UV | IS_NUMBER_NEG)) {
              if (uv <= (UV) IV_MIN)
                sv = newSViv(-(IV)uv);
              else
	    	floatit = TRUE;
            } else
              floatit = TRUE;
        }
	if (floatit) {
            STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD();
	    /* terminate the string */
	    *d = '\0';
            if (UNLIKELY(hexfp)) {
#  ifdef NV_MANT_DIG
                if (significant_bits > NV_MANT_DIG)
                    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                   "Hexadecimal float: mantissa overflow");
#  endif
#ifdef HEXFP_UQUAD
                nv = hexfp_uquad * hexfp_mult;
#else /* HEXFP_NV */
                nv = hexfp_nv * hexfp_mult;
#endif
            } else {
                nv = Atof(PL_tokenbuf);
            }
            RESTORE_LC_NUMERIC_UNDERLYING();
            sv = newSVnv(nv);
	}

	if ( floatit
	     ? (PL_hints & HINT_NEW_FLOAT) : (PL_hints & HINT_NEW_INTEGER) ) {
	    const char *const key = floatit ? "float" : "integer";
	    const STRLEN keylen = floatit ? 5 : 7;
	    sv = S_new_constant(aTHX_ PL_tokenbuf, d - PL_tokenbuf,
				key, keylen, sv, NULL, NULL, 0);
	}
	break;

    /* if it starts with a v, it could be a v-string */
    case 'v':
    vstring:
		sv = newSV(5); /* preallocate storage space */
		ENTER_with_name("scan_vstring");
		SAVEFREESV(sv);
		s = scan_vstring(s, PL_bufend, sv);
		SvREFCNT_inc_simple_void_NN(sv);
		LEAVE_with_name("scan_vstring");
	break;
    }

    /* make the op for the constant and return */

    if (sv)
	lvalp->opval = newSVOP(OP_CONST, 0, sv);
    else
	lvalp->opval = NULL;

    return (char *)s;
}

STATIC char *
S_scan_formline(pTHX_ char *s)
{
    char *eol;
    char *t;
    SV * const stuff = newSVpvs("");
    bool needargs = FALSE;
    bool eofmt = FALSE;

    PERL_ARGS_ASSERT_SCAN_FORMLINE;

    while (!needargs) {
	if (*s == '.') {
	    t = s+1;
#ifdef PERL_STRICT_CR
	    while (SPACE_OR_TAB(*t))
		t++;
#else
	    while (SPACE_OR_TAB(*t) || *t == '\r')
		t++;
#endif
	    if (*t == '\n' || t == PL_bufend) {
	        eofmt = TRUE;
		break;
            }
	}
	eol = (char *) memchr(s,'\n',PL_bufend-s);
	if (!eol++)
		eol = PL_bufend;
	if (*s != '#') {
	    for (t = s; t < eol; t++) {
		if (*t == '~' && t[1] == '~' && SvCUR(stuff)) {
		    needargs = FALSE;
		    goto enough;	/* ~~ must be first line in formline */
		}
		if (*t == '@@' || *t == '^')
		    needargs = TRUE;
	    }
	    if (eol > s) {
	        sv_catpvn(stuff, s, eol-s);
#ifndef PERL_STRICT_CR
		if (eol-s > 1 && eol[-2] == '\r' && eol[-1] == '\n') {
		    char *end = SvPVX(stuff) + SvCUR(stuff);
		    end[-2] = '\n';
		    end[-1] = '\0';
		    SvCUR_set(stuff, SvCUR(stuff) - 1);
		}
#endif
	    }
	    else
	      break;
	}
	s = (char*)eol;
	if ((PL_rsfp || PL_parser->filtered)
	 && PL_parser->form_lex_state == LEX_NORMAL) {
	    bool got_some;
	    PL_bufptr = PL_bufend;
	    COPLINE_INC_WITH_HERELINES;
	    got_some = lex_next_chunk(0);
	    CopLINE_dec(PL_curcop);
	    s = PL_bufptr;
	    if (!got_some)
		break;
	}
	incline(s);
    }
  enough:
    if (!SvCUR(stuff) || needargs)
	PL_lex_state = PL_parser->form_lex_state;
    if (SvCUR(stuff)) {
	PL_expect = XSTATE;
	if (needargs) {
	    const char *s2 = s;
	    while (*s2 == '\r' || *s2 == ' ' || *s2 == '\t' || *s2 == '\f'
		|| *s2 == '\v')
		s2++;
	    if (*s2 == '{') {
		PL_expect = XTERMBLOCK;
		NEXTVAL_NEXTTOKE.ival = 0;
		force_next(DO);
	    }
	    NEXTVAL_NEXTTOKE.ival = 0;
	    force_next(FORMLBRACK);
	}
	if (!IN_BYTES) {
	    if (UTF && is_utf8_string((U8*)SvPVX_const(stuff), SvCUR(stuff)))
		SvUTF8_on(stuff);
	    else if (IN_ENCODING)
		sv_recode_to_utf8(stuff, _get_encoding());
	}
	NEXTVAL_NEXTTOKE.opval = (OP*)newSVOP(OP_CONST, 0, stuff);
	force_next(THING);
    }
    else {
	SvREFCNT_dec(stuff);
	if (eofmt)
	    PL_lex_formbrack = 0;
    }
    return s;
}

I32
Perl_start_subparse(pTHX_ I32 is_format, U32 flags)
{
    const I32 oldsavestack_ix = PL_savestack_ix;
    CV* const outsidecv = PL_compcv;

    SAVEI32(PL_subline);
    save_item(PL_subname);
    SAVESPTR(PL_compcv);

    PL_compcv = MUTABLE_CV(newSV_type(is_format ? SVt_PVFM : SVt_PVCV));
    CvFLAGS(PL_compcv) |= flags;

    PL_subline = CopLINE(PL_curcop);
    CvPADLIST(PL_compcv) = pad_new(padnew_SAVE|padnew_SAVESUB);
    CvOUTSIDE(PL_compcv) = MUTABLE_CV(SvREFCNT_inc_simple(outsidecv));
    CvOUTSIDE_SEQ(PL_compcv) = PL_cop_seqmax;
    if (outsidecv && CvPADLIST(outsidecv))
	CvPADLIST(PL_compcv)->xpadl_outid = CvPADLIST(outsidecv)->xpadl_id;

    return oldsavestack_ix;
}

static int
S_yywarn(pTHX_ const char *const s, U32 flags)
{
    PERL_ARGS_ASSERT_YYWARN;

    PL_in_eval |= EVAL_WARNONLY;
    yyerror_pv(s, flags);
    return 0;
}

int
Perl_yyerror(pTHX_ const char *const s)
{
    PERL_ARGS_ASSERT_YYERROR;
    return yyerror_pvn(s, strlen(s), 0);
}

int
Perl_yyerror_pv(pTHX_ const char *const s, U32 flags)
{
    PERL_ARGS_ASSERT_YYERROR_PV;
    return yyerror_pvn(s, strlen(s), flags);
}

int
Perl_yyerror_pvn(pTHX_ const char *const s, STRLEN len, U32 flags)
{
    const char *context = NULL;
    int contlen = -1;
    SV *msg;
    SV * const where_sv = newSVpvs_flags("", SVs_TEMP);
    int yychar  = PL_parser->yychar;

    PERL_ARGS_ASSERT_YYERROR_PVN;

    if (!yychar || (yychar == ';' && !PL_rsfp))
	sv_catpvs(where_sv, "at EOF");
    else if (   PL_oldoldbufptr
             && PL_bufptr > PL_oldoldbufptr
             && PL_bufptr - PL_oldoldbufptr < 200
             && PL_oldoldbufptr != PL_oldbufptr
             && PL_oldbufptr != PL_bufptr)
    {
	/*
		Only for NetWare:
		The code below is removed for NetWare because it abends/crashes on NetWare
		when the script has error such as not having the closing quotes like:
		    if ($var eq "value)
		Checking of white spaces is anyway done in NetWare code.
	*/
#ifndef NETWARE
	while (isSPACE(*PL_oldoldbufptr))
	    PL_oldoldbufptr++;
#endif
	context = PL_oldoldbufptr;
	contlen = PL_bufptr - PL_oldoldbufptr;
    }
    else if (  PL_oldbufptr
            && PL_bufptr > PL_oldbufptr
            && PL_bufptr - PL_oldbufptr < 200
            && PL_oldbufptr != PL_bufptr) {
	/*
		Only for NetWare:
		The code below is removed for NetWare because it abends/crashes on NetWare
		when the script has error such as not having the closing quotes like:
		    if ($var eq "value)
		Checking of white spaces is anyway done in NetWare code.
	*/
#ifndef NETWARE
	while (isSPACE(*PL_oldbufptr))
	    PL_oldbufptr++;
#endif
	context = PL_oldbufptr;
	contlen = PL_bufptr - PL_oldbufptr;
    }
    else if (yychar > 255)
	sv_catpvs(where_sv, "next token ???");
    else if (yychar == YYEMPTY) {
	if (    PL_lex_state == LEX_NORMAL
            || (PL_lex_state == LEX_KNOWNEXT && PL_lex_defer == LEX_NORMAL))
	    sv_catpvs(where_sv, "at end of line");
	else if (PL_lex_inpat)
	    sv_catpvs(where_sv, "within pattern");
	else
	    sv_catpvs(where_sv, "within string");
    }
    else {
	sv_catpvs(where_sv, "next char ");
	if (yychar < 32)
	    Perl_sv_catpvf(aTHX_ where_sv, "^%c", toCTRL(yychar));
	else if (isPRINT_LC(yychar)) {
	    const char string = yychar;
	    sv_catpvn(where_sv, &string, 1);
	}
	else
	    Perl_sv_catpvf(aTHX_ where_sv, "\\%03o", yychar & 255);
    }
    msg = newSVpvn_flags(s, len, (flags & SVf_UTF8) | SVs_TEMP);
    Perl_sv_catpvf(aTHX_ msg, " at %s line %"IVdf", ",
        OutCopFILE(PL_curcop),
        (IV)(PL_parser->preambling == NOLINE
               ? CopLINE(PL_curcop)
               : PL_parser->preambling));
    if (context)
	Perl_sv_catpvf(aTHX_ msg, "near \"%"UTF8f"\"\n",
			     UTF8fARG(UTF, contlen, context));
    else
	Perl_sv_catpvf(aTHX_ msg, "%"SVf"\n", SVfARG(where_sv));
    if (PL_multi_start < PL_multi_end && (U32)(CopLINE(PL_curcop) - PL_multi_end) <= 1) {
        Perl_sv_catpvf(aTHX_ msg,
        "  (Might be a runaway multi-line %c%c string starting on line %"IVdf")\n",
                (int)PL_multi_open,(int)PL_multi_close,(IV)PL_multi_start);
        PL_multi_end = 0;
    }
    if (PL_in_eval & EVAL_WARNONLY) {
	PL_in_eval &= ~EVAL_WARNONLY;
	Perl_ck_warner_d(aTHX_ packWARN(WARN_SYNTAX), "%"SVf, SVfARG(msg));
    }
    else
	qerror(msg);
    if (PL_error_count >= 10) {
	SV * errsv;
	if (PL_in_eval && ((errsv = ERRSV), SvCUR(errsv)))
	    Perl_croak(aTHX_ "%"SVf"%s has too many errors.\n",
		       SVfARG(errsv), OutCopFILE(PL_curcop));
	else
	    Perl_croak(aTHX_ "%s has too many errors.\n",
            OutCopFILE(PL_curcop));
    }
    PL_in_my = 0;
    PL_in_my_stash = NULL;
    return 0;
}

STATIC char*
S_swallow_bom(pTHX_ U8 *s)
{
    const STRLEN slen = SvCUR(PL_linestr);

    PERL_ARGS_ASSERT_SWALLOW_BOM;

    switch (s[0]) {
    case 0xFF:
	if (s[1] == 0xFE) {
	    /* UTF-16 little-endian? (or UTF-32LE?) */
	    if (s[2] == 0 && s[3] == 0)  /* UTF-32 little-endian */
		/* diag_listed_as: Unsupported script encoding %s */
		Perl_croak(aTHX_ "Unsupported script encoding UTF-32LE");
#ifndef PERL_NO_UTF16_FILTER
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16LE script encoding (BOM)\n");
	    s += 2;
	    if (PL_bufend > (char*)s) {
		s = add_utf16_textfilter(s, TRUE);
	    }
#else
	    /* diag_listed_as: Unsupported script encoding %s */
	    Perl_croak(aTHX_ "Unsupported script encoding UTF-16LE");
#endif
	}
	break;
    case 0xFE:
	if (s[1] == 0xFF) {   /* UTF-16 big-endian? */
#ifndef PERL_NO_UTF16_FILTER
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16BE script encoding (BOM)\n");
	    s += 2;
	    if (PL_bufend > (char *)s) {
		s = add_utf16_textfilter(s, FALSE);
	    }
#else
	    /* diag_listed_as: Unsupported script encoding %s */
	    Perl_croak(aTHX_ "Unsupported script encoding UTF-16BE");
#endif
	}
	break;
    case BOM_UTF8_FIRST_BYTE: {
        const STRLEN len = sizeof(BOM_UTF8_TAIL) - 1; /* Exclude trailing NUL */
        if (slen > len && memEQ(s+1, BOM_UTF8_TAIL, len)) {
            if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-8 script encoding (BOM)\n");
            s += len + 1;                      /* UTF-8 */
        }
        break;
    }
    case 0:
	if (slen > 3) {
	     if (s[1] == 0) {
		  if (s[2] == 0xFE && s[3] == 0xFF) {
		       /* UTF-32 big-endian */
		       /* diag_listed_as: Unsupported script encoding %s */
		       Perl_croak(aTHX_ "Unsupported script encoding UTF-32BE");
		  }
	     }
	     else if (s[2] == 0 && s[3] != 0) {
		  /* Leading bytes
		   * 00 xx 00 xx
		   * are a good indicator of UTF-16BE. */
#ifndef PERL_NO_UTF16_FILTER
		  if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16BE script encoding (no BOM)\n");
		  s = add_utf16_textfilter(s, FALSE);
#else
		  /* diag_listed_as: Unsupported script encoding %s */
		  Perl_croak(aTHX_ "Unsupported script encoding UTF-16BE");
#endif
	     }
	}
        break;

    default:
	 if (slen > 3 && s[1] == 0 && s[2] != 0 && s[3] == 0) {
		  /* Leading bytes
		   * xx 00 xx 00
		   * are a good indicator of UTF-16LE. */
#ifndef PERL_NO_UTF16_FILTER
	      if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16LE script encoding (no BOM)\n");
	      s = add_utf16_textfilter(s, TRUE);
#else
	      /* diag_listed_as: Unsupported script encoding %s */
	      Perl_croak(aTHX_ "Unsupported script encoding UTF-16LE");
#endif
	 }
    }
    return (char*)s;
}


#ifndef PERL_NO_UTF16_FILTER
static I32
S_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
{
    SV *const filter = FILTER_DATA(idx);
    /* We re-use this each time round, throwing the contents away before we
       return.  */
    SV *const utf16_buffer = MUTABLE_SV(IoTOP_GV(filter));
    SV *const utf8_buffer = filter;
    IV status = IoPAGE(filter);
    const bool reverse = cBOOL(IoLINES(filter));
    I32 retval;

    PERL_ARGS_ASSERT_UTF16_TEXTFILTER;

    /* As we're automatically added, at the lowest level, and hence only called
       from this file, we can be sure that we're not called in block mode. Hence
       don't bother writing code to deal with block mode.  */
    if (maxlen) {
	Perl_croak(aTHX_ "panic: utf16_textfilter called in block mode (for %d characters)", maxlen);
    }
    if (status < 0) {
	Perl_croak(aTHX_ "panic: utf16_textfilter called after error (status=%"IVdf")", status);
    }
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "utf16_textfilter(%p,%ce): idx=%d maxlen=%d status=%"IVdf" utf16=%"UVuf" utf8=%"UVuf"\n",
			  FPTR2DPTR(void *, S_utf16_textfilter),
			  reverse ? 'l' : 'b', idx, maxlen, status,
			  (UV)SvCUR(utf16_buffer), (UV)SvCUR(utf8_buffer)));

    while (1) {
	STRLEN chars;
	STRLEN have;
	I32 newlen;
	U8 *end;
	/* First, look in our buffer of existing UTF-8 data:  */
	char *nl = (char *)memchr(SvPVX(utf8_buffer), '\n', SvCUR(utf8_buffer));

	if (nl) {
	    ++nl;
	} else if (status == 0) {
	    /* EOF */
	    IoPAGE(filter) = 0;
	    nl = SvEND(utf8_buffer);
	}
	if (nl) {
	    STRLEN got = nl - SvPVX(utf8_buffer);
	    /* Did we have anything to append?  */
	    retval = got != 0;
	    sv_catpvn(sv, SvPVX(utf8_buffer), got);
	    /* Everything else in this code works just fine if SVp_POK isn't
	       set.  This, however, needs it, and we need it to work, else
	       we loop infinitely because the buffer is never consumed.  */
	    sv_chop(utf8_buffer, nl);
	    break;
	}

	/* OK, not a complete line there, so need to read some more UTF-16.
	   Read an extra octect if the buffer currently has an odd number. */
	while (1) {
	    if (status <= 0)
		break;
	    if (SvCUR(utf16_buffer) >= 2) {
		/* Location of the high octet of the last complete code point.
		   Gosh, UTF-16 is a pain. All the benefits of variable length,
		   *coupled* with all the benefits of partial reads and
		   endianness.  */
		const U8 *const last_hi = (U8*)SvPVX(utf16_buffer)
		    + ((SvCUR(utf16_buffer) & ~1) - (reverse ? 1 : 2));

		if (*last_hi < 0xd8 || *last_hi > 0xdb) {
		    break;
		}

		/* We have the first half of a surrogate. Read more.  */
		DEBUG_P(PerlIO_printf(Perl_debug_log, "utf16_textfilter partial surrogate detected at %p\n", last_hi));
	    }

	    status = FILTER_READ(idx + 1, utf16_buffer,
				 160 + (SvCUR(utf16_buffer) & 1));
	    DEBUG_P(PerlIO_printf(Perl_debug_log, "utf16_textfilter status=%"IVdf" SvCUR(sv)=%"UVuf"\n", status, (UV)SvCUR(utf16_buffer)));
	    DEBUG_P({ sv_dump(utf16_buffer); sv_dump(utf8_buffer);});
	    if (status < 0) {
		/* Error */
		IoPAGE(filter) = status;
		return status;
	    }
	}

	chars = SvCUR(utf16_buffer) >> 1;
	have = SvCUR(utf8_buffer);
	SvGROW(utf8_buffer, have + chars * 3 + 1);

	if (reverse) {
	    end = utf16_to_utf8_reversed((U8*)SvPVX(utf16_buffer),
					 (U8*)SvPVX_const(utf8_buffer) + have,
					 chars * 2, &newlen);
	} else {
	    end = utf16_to_utf8((U8*)SvPVX(utf16_buffer),
				(U8*)SvPVX_const(utf8_buffer) + have,
				chars * 2, &newlen);
	}
	SvCUR_set(utf8_buffer, have + newlen);
	*end = '\0';

	/* No need to keep this SV "well-formed" with a '\0' after the end, as
	   it's private to us, and utf16_to_utf8{,reversed} take a
	   (pointer,length) pair, rather than a NUL-terminated string.  */
	if(SvCUR(utf16_buffer) & 1) {
	    *SvPVX(utf16_buffer) = SvEND(utf16_buffer)[-1];
	    SvCUR_set(utf16_buffer, 1);
	} else {
	    SvCUR_set(utf16_buffer, 0);
	}
    }
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "utf16_textfilter: returns, status=%"IVdf" utf16=%"UVuf" utf8=%"UVuf"\n",
			  status,
			  (UV)SvCUR(utf16_buffer), (UV)SvCUR(utf8_buffer)));
    DEBUG_P({ sv_dump(utf8_buffer); sv_dump(sv);});
    return retval;
}

static U8 *
S_add_utf16_textfilter(pTHX_ U8 *const s, bool reversed)
{
    SV *filter = filter_add(S_utf16_textfilter, NULL);

    PERL_ARGS_ASSERT_ADD_UTF16_TEXTFILTER;

    IoTOP_GV(filter) = MUTABLE_GV(newSVpvn((char *)s, PL_bufend - (char*)s));
    sv_setpvs(filter, "");
    IoLINES(filter) = reversed;
    IoPAGE(filter) = 1; /* Not EOF */

    /* Sadly, we have to return a valid pointer, come what may, so we have to
       ignore any error return from this.  */
    SvCUR_set(PL_linestr, 0);
    if (FILTER_READ(0, PL_linestr, 0)) {
	SvUTF8_on(PL_linestr);
    } else {
	SvUTF8_on(PL_linestr);
    }
    PL_bufend = SvEND(PL_linestr);
    return (U8*)SvPVX(PL_linestr);
}
#endif

/*
Returns a pointer to the next character after the parsed
vstring, as well as updating the passed in sv.

Function must be called like

	sv = sv_2mortal(newSV(5));
	s = scan_vstring(s,e,sv);

where s and e are the start and end of the string.
The sv should already be large enough to store the vstring
passed in, for performance reasons.

This function may croak if fatal warnings are enabled in the
calling scope, hence the sv_2mortal in the example (to prevent
a leak).  Make sure to do SvREFCNT_inc afterwards if you use
sv_2mortal.

*/

char *
Perl_scan_vstring(pTHX_ const char *s, const char *const e, SV *sv)
{
    const char *pos = s;
    const char *start = s;

    PERL_ARGS_ASSERT_SCAN_VSTRING;

    if (*pos == 'v') pos++;  /* get past 'v' */
    while (pos < e && (isDIGIT(*pos) || *pos == '_'))
	pos++;
    if ( *pos != '.') {
	/* this may not be a v-string if followed by => */
	const char *next = pos;
	while (next < e && isSPACE(*next))
	    ++next;
	if ((e - next) >= 2 && *next == '=' && next[1] == '>' ) {
	    /* return string not v-string */
	    sv_setpvn(sv,(char *)s,pos-s);
	    return (char *)pos;
	}
    }

    if (!isALPHA(*pos)) {
	U8 tmpbuf[UTF8_MAXBYTES+1];

	if (*s == 'v')
	    s++;  /* get past 'v' */

	sv_setpvs(sv, "");

	for (;;) {
	    /* this is atoi() that tolerates underscores */
	    U8 *tmpend;
	    UV rev = 0;
	    const char *end = pos;
	    UV mult = 1;
	    while (--end >= s) {
		if (*end != '_') {
		    const UV orev = rev;
		    rev += (*end - '0') * mult;
		    mult *= 10;
		    if (orev > rev)
			/* diag_listed_as: Integer overflow in %s number */
			Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
					 "Integer overflow in decimal number");
		}
	    }

	    /* Append native character for the rev point */
	    tmpend = uvchr_to_utf8(tmpbuf, rev);
	    sv_catpvn(sv, (const char*)tmpbuf, tmpend - tmpbuf);
	    if (!UVCHR_IS_INVARIANT(rev))
		 SvUTF8_on(sv);
	    if (pos + 1 < e && *pos == '.' && isDIGIT(pos[1]))
		 s = ++pos;
	    else {
		 s = pos;
		 break;
	    }
	    while (pos < e && (isDIGIT(*pos) || *pos == '_'))
		 pos++;
	}
	SvPOK_on(sv);
	sv_magic(sv,NULL,PERL_MAGIC_vstring,(const char*)start, pos-start);
	SvRMAGICAL_on(sv);
    }
    return (char *)s;
}

int
Perl_keyword_plugin_standard(pTHX_
	char *keyword_ptr, STRLEN keyword_len, OP **op_ptr)
{
    PERL_ARGS_ASSERT_KEYWORD_PLUGIN_STANDARD;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(keyword_ptr);
    PERL_UNUSED_ARG(keyword_len);
    PERL_UNUSED_ARG(op_ptr);
    return KEYWORD_PLUGIN_DECLINE;
}

#define parse_recdescent(g,p) S_parse_recdescent(aTHX_ g,p)
static void
S_parse_recdescent(pTHX_ int gramtype, I32 fakeeof)
{
    SAVEI32(PL_lex_brackets);
    if (PL_lex_brackets > 100)
	Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
    PL_lex_brackstack[PL_lex_brackets++] = XFAKEEOF;
    SAVEI32(PL_lex_allbrackets);
    PL_lex_allbrackets = 0;
    SAVEI8(PL_lex_fakeeof);
    PL_lex_fakeeof = (U8)fakeeof;
    if(yyparse(gramtype) && !PL_parser->error_count)
	qerror(Perl_mess(aTHX_ "Parse error"));
}

#define parse_recdescent_for_op(g,p) S_parse_recdescent_for_op(aTHX_ g,p)
static OP *
S_parse_recdescent_for_op(pTHX_ int gramtype, I32 fakeeof)
{
    OP *o;
    ENTER;
    SAVEVPTR(PL_eval_root);
    PL_eval_root = NULL;
    parse_recdescent(gramtype, fakeeof);
    o = PL_eval_root;
    LEAVE;
    return o;
}

#define parse_expr(p,f) S_parse_expr(aTHX_ p,f)
static OP *
S_parse_expr(pTHX_ I32 fakeeof, U32 flags)
{
    OP *exprop;
    if (flags & ~PARSE_OPTIONAL)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_expr");
    exprop = parse_recdescent_for_op(GRAMEXPR, fakeeof);
    if (!exprop && !(flags & PARSE_OPTIONAL)) {
	if (!PL_parser->error_count)
	    qerror(Perl_mess(aTHX_ "Parse error"));
	exprop = newOP(OP_NULL, 0);
    }
    return exprop;
}

/*
=for apidoc Amx|OP *|parse_arithexpr|U32 flags

Parse a Perl arithmetic expression.  This may contain operators of precedence
down to the bit shift operators.  The expression must be followed (and thus
terminated) either by a comparison or lower-precedence operator or by
something that would normally terminate an expression such as semicolon.
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_arithexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_COMPARE, flags);
}

/*
=for apidoc Amx|OP *|parse_termexpr|U32 flags

Parse a Perl term expression.  This may contain operators of precedence
down to the assignment operators.  The expression must be followed (and thus
terminated) either by a comma or lower-precedence operator or by
something that would normally terminate an expression such as semicolon.
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_termexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_COMMA, flags);
}

/*
=for apidoc Amx|OP *|parse_listexpr|U32 flags

Parse a Perl list expression.  This may contain operators of precedence
down to the comma operator.  The expression must be followed (and thus
terminated) either by a low-precedence logic operator such as C<or> or by
something that would normally terminate an expression such as semicolon.
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_listexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_LOWLOGIC, flags);
}

/*
=for apidoc Amx|OP *|parse_fullexpr|U32 flags

Parse a single complete Perl expression.  This allows the full
expression grammar, including the lowest-precedence operators such
as C<or>.  The expression must be followed (and thus terminated) by a
token that an expression would normally be terminated by: end-of-file,
closing bracketing punctuation, semicolon, or one of the keywords that
signals a postfix expression-statement modifier.  If C<flags> has the
C<PARSE_OPTIONAL> bit set, then the expression is optional, otherwise it is
mandatory.  It is up to the caller to ensure that the dynamic parser
state (L</PL_parser> et al) is correctly set to reflect the source of
the code to be parsed and the lexical context for the expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_fullexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_NONEXPR, flags);
}

/*
=for apidoc Amx|OP *|parse_block|U32 flags

Parse a single complete Perl code block.  This consists of an opening
brace, a sequence of statements, and a closing brace.  The block
constitutes a lexical scope, so C<my> variables and various compile-time
effects can be contained within it.  It is up to the caller to ensure
that the dynamic parser state (L</PL_parser> et al) is correctly set to
reflect the source of the code to be parsed and the lexical context for
the statement.

The op tree representing the code block is returned.  This is always a
real op, never a null pointer.  It will normally be a C<lineseq> list,
including C<nextstate> or equivalent ops.  No ops to construct any kind
of runtime scope are included by virtue of it being a block.

If an error occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.
Some compilation errors, however, will throw an exception immediately.

The C<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_block(pTHX_ U32 flags)
{
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_block");
    return parse_recdescent_for_op(GRAMBLOCK, LEX_FAKEEOF_NEVER);
}

/*
=for apidoc Amx|OP *|parse_barestmt|U32 flags

Parse a single unadorned Perl statement.  This may be a normal imperative
statement or a declaration that has compile-time effect.  It does not
include any label or other affixture.  It is up to the caller to ensure
that the dynamic parser state (L</PL_parser> et al) is correctly set to
reflect the source of the code to be parsed and the lexical context for
the statement.

The op tree representing the statement is returned.  This may be a
null pointer if the statement is null, for example if it was actually
a subroutine definition (which has compile-time side effects).  If not
null, it will be ops directly implementing the statement, suitable to
pass to L</newSTATEOP>.  It will not normally include a C<nextstate> or
equivalent op (except for those embedded in a scope contained entirely
within the statement).

If an error occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.
Some compilation errors, however, will throw an exception immediately.

The C<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_barestmt(pTHX_ U32 flags)
{
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_barestmt");
    return parse_recdescent_for_op(GRAMBARESTMT, LEX_FAKEEOF_NEVER);
}

/*
=for apidoc Amx|SV *|parse_label|U32 flags

Parse a single label, possibly optional, of the type that may prefix a
Perl statement.  It is up to the caller to ensure that the dynamic parser
state (L</PL_parser> et al) is correctly set to reflect the source of
the code to be parsed.  If C<flags> has the C<PARSE_OPTIONAL> bit set, then the
label is optional, otherwise it is mandatory.

The name of the label is returned in the form of a fresh scalar.  If an
optional label is absent, a null pointer is returned.

If an error occurs in parsing, which can only occur if the label is
mandatory, a valid label is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.

=cut
*/

SV *
Perl_parse_label(pTHX_ U32 flags)
{
    if (flags & ~PARSE_OPTIONAL)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_label");
    if (PL_lex_state == LEX_KNOWNEXT) {
	PL_parser->yychar = yylex();
	if (PL_parser->yychar == LABEL) {
	    char * const lpv = pl_yylval.pval;
	    STRLEN llen = strlen(lpv);
	    PL_parser->yychar = YYEMPTY;
	    return newSVpvn_flags(lpv, llen, lpv[llen+1] ? SVf_UTF8 : 0);
	} else {
	    yyunlex();
	    goto no_label;
	}
    } else {
	char *s, *t;
	STRLEN wlen, bufptr_pos;
	lex_read_space(0);
	t = s = PL_bufptr;
        if (!isIDFIRST_lazy_if(s, UTF))
	    goto no_label;
	t = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &wlen);
	if (word_takes_any_delimeter(s, wlen))
	    goto no_label;
	bufptr_pos = s - SvPVX(PL_linestr);
	PL_bufptr = t;
	lex_read_space(LEX_KEEP_PREVIOUS);
	t = PL_bufptr;
	s = SvPVX(PL_linestr) + bufptr_pos;
	if (t[0] == ':' && t[1] != ':') {
	    PL_oldoldbufptr = PL_oldbufptr;
	    PL_oldbufptr = s;
	    PL_bufptr = t+1;
	    return newSVpvn_flags(s, wlen, UTF ? SVf_UTF8 : 0);
	} else {
	    PL_bufptr = s;
	    no_label:
	    if (flags & PARSE_OPTIONAL) {
		return NULL;
	    } else {
		qerror(Perl_mess(aTHX_ "Parse error"));
		return newSVpvs("x");
	    }
	}
    }
}

/*
=for apidoc Amx|OP *|parse_fullstmt|U32 flags

Parse a single complete Perl statement.  This may be a normal imperative
statement or a declaration that has compile-time effect, and may include
optional labels.  It is up to the caller to ensure that the dynamic
parser state (L</PL_parser> et al) is correctly set to reflect the source
of the code to be parsed and the lexical context for the statement.

The op tree representing the statement is returned.  This may be a
null pointer if the statement is null, for example if it was actually
a subroutine definition (which has compile-time side effects).  If not
null, it will be the result of a L</newSTATEOP> call, normally including
a C<nextstate> or equivalent op.

If an error occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.
Some compilation errors, however, will throw an exception immediately.

The C<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_fullstmt(pTHX_ U32 flags)
{
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_fullstmt");
    return parse_recdescent_for_op(GRAMFULLSTMT, LEX_FAKEEOF_NEVER);
}

/*
=for apidoc Amx|OP *|parse_stmtseq|U32 flags

Parse a sequence of zero or more Perl statements.  These may be normal
imperative statements, including optional labels, or declarations
that have compile-time effect, or any mixture thereof.  The statement
sequence ends when a closing brace or end-of-file is encountered in a
place where a new statement could have validly started.  It is up to
the caller to ensure that the dynamic parser state (L</PL_parser> et al)
is correctly set to reflect the source of the code to be parsed and the
lexical context for the statements.

The op tree representing the statement sequence is returned.  This may
be a null pointer if the statements were all null, for example if there
were no statements or if there were only subroutine definitions (which
have compile-time side effects).  If not null, it will be a C<lineseq>
list, normally including C<nextstate> or equivalent ops.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

The C<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_stmtseq(pTHX_ U32 flags)
{
    OP *stmtseqop;
    I32 c;
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_stmtseq");
    stmtseqop = parse_recdescent_for_op(GRAMSTMTSEQ, LEX_FAKEEOF_CLOSING);
    c = lex_peek_unichar(0);
    if (c != -1 && c != /*{*/'}')
	qerror(Perl_mess(aTHX_ "Parse error"));
    return stmtseqop;
}

#define lex_token_boundary() S_lex_token_boundary(aTHX)
static void
S_lex_token_boundary(pTHX)
{
    PL_oldoldbufptr = PL_oldbufptr;
    PL_oldbufptr = PL_bufptr;
}

#define parse_opt_lexvar() S_parse_opt_lexvar(aTHX)
static OP *
S_parse_opt_lexvar(pTHX)
{
    I32 sigil, c;
    char *s, *d;
    OP *var;
    lex_token_boundary();
    sigil = lex_read_unichar(0);
    if (lex_peek_unichar(0) == '#') {
	qerror(Perl_mess(aTHX_ "Parse error"));
	return NULL;
    }
    lex_read_space(0);
    c = lex_peek_unichar(0);
    if (c == -1 || !(UTF ? isIDFIRST_uni(c) : isIDFIRST_A(c)))
	return NULL;
    s = PL_bufptr;
    d = PL_tokenbuf + 1;
    PL_tokenbuf[0] = (char)sigil;
    parse_ident(&s, &d, PL_tokenbuf + sizeof(PL_tokenbuf) - 1, 0, cBOOL(UTF));
    PL_bufptr = s;
    if (d == PL_tokenbuf+1)
	return NULL;
    var = newOP(sigil == '$' ? OP_PADSV : sigil == '@@' ? OP_PADAV : OP_PADHV,
		OPf_MOD | (OPpLVAL_INTRO<<8));
    var->op_targ = allocmy(PL_tokenbuf, d - PL_tokenbuf, UTF ? SVf_UTF8 : 0);
    return var;
}

OP *
Perl_parse_subsignature(pTHX)
{
    I32 c;
    int prev_type = 0, pos = 0, min_arity = 0, max_arity = 0;
    OP *initops = NULL;
    lex_read_space(0);
    c = lex_peek_unichar(0);
    while (c != /*(*/')') {
	switch (c) {
	    case '$': {
		OP *var, *expr;
		if (prev_type == 2)
		    qerror(Perl_mess(aTHX_ "Slurpy parameter not last"));
		var = parse_opt_lexvar();
		expr = var ?
		    newBINOP(OP_AELEM, 0,
			ref(newUNOP(OP_RV2AV, 0, newGVOP(OP_GV, 0, PL_defgv)),
			    OP_RV2AV),
			newSVOP(OP_CONST, 0, newSViv(pos))) :
		    NULL;
		lex_read_space(0);
		c = lex_peek_unichar(0);
		if (c == '=') {
		    lex_token_boundary();
		    lex_read_unichar(0);
		    lex_read_space(0);
		    c = lex_peek_unichar(0);
		    if (c == ',' || c == /*(*/')') {
			if (var)
			    qerror(Perl_mess(aTHX_ "Optional parameter "
				    "lacks default expression"));
		    } else {
			OP *defexpr = parse_termexpr(0);
			if (defexpr->op_type == OP_UNDEF
                            && !(defexpr->op_flags & OPf_KIDS))
                        {
			    op_free(defexpr);
			} else {
			    OP *ifop = 
				newBINOP(OP_GE, 0,
				    scalar(newUNOP(OP_RV2AV, 0,
					    newGVOP(OP_GV, 0, PL_defgv))),
				    newSVOP(OP_CONST, 0, newSViv(pos+1)));
			    expr = var ?
				newCONDOP(0, ifop, expr, defexpr) :
				newLOGOP(OP_OR, 0, ifop, defexpr);
			}
		    }
		    prev_type = 1;
		} else {
		    if (prev_type == 1)
			qerror(Perl_mess(aTHX_ "Mandatory parameter "
				"follows optional parameter"));
		    prev_type = 0;
		    min_arity = pos + 1;
		}
		if (var) expr = newASSIGNOP(OPf_STACKED, var, 0, expr);
		if (expr)
		    initops = op_append_list(OP_LINESEQ, initops,
				newSTATEOP(0, NULL, expr));
		max_arity = ++pos;
	    } break;
	    case '@@':
	    case '%': {
		OP *var;
		if (prev_type == 2)
		    qerror(Perl_mess(aTHX_ "Slurpy parameter not last"));
		var = parse_opt_lexvar();
		if (c == '%') {
		    OP *chkop = newLOGOP((pos & 1) ? OP_OR : OP_AND, 0,
			    newBINOP(OP_BIT_AND, 0,
				scalar(newUNOP(OP_RV2AV, 0,
				    newGVOP(OP_GV, 0, PL_defgv))),
				newSVOP(OP_CONST, 0, newSViv(1))),
		            op_convert_list(OP_DIE, 0,
		                op_convert_list(OP_SPRINTF, 0,
		                    op_append_list(OP_LIST,
		                        newSVOP(OP_CONST, 0,
		                            newSVpvs("Odd name/value argument for subroutine at %s line %d.\n")),
		                        newSLICEOP(0,
		                            op_append_list(OP_LIST,
		                                newSVOP(OP_CONST, 0, newSViv(1)),
		                                newSVOP(OP_CONST, 0, newSViv(2))),
		                            newOP(OP_CALLER, 0))))));
		    if (pos != min_arity)
			chkop = newLOGOP(OP_AND, 0,
				    newBINOP(OP_GT, 0,
					scalar(newUNOP(OP_RV2AV, 0,
					    newGVOP(OP_GV, 0, PL_defgv))),
					newSVOP(OP_CONST, 0, newSViv(pos))),
				    chkop);
		    initops = op_append_list(OP_LINESEQ,
				newSTATEOP(0, NULL, chkop),
				initops);
		}
		if (var) {
		    OP *slice = pos ?
			op_prepend_elem(OP_ASLICE,
			    newOP(OP_PUSHMARK, 0),
			    newLISTOP(OP_ASLICE, 0,
				list(newRANGE(0,
				    newSVOP(OP_CONST, 0, newSViv(pos)),
				    newUNOP(OP_AV2ARYLEN, 0,
					ref(newUNOP(OP_RV2AV, 0,
						newGVOP(OP_GV, 0, PL_defgv)),
					    OP_AV2ARYLEN)))),
				ref(newUNOP(OP_RV2AV, 0,
					newGVOP(OP_GV, 0, PL_defgv)),
				    OP_ASLICE))) :
			newUNOP(OP_RV2AV, 0, newGVOP(OP_GV, 0, PL_defgv));
		    initops = op_append_list(OP_LINESEQ, initops,
			newSTATEOP(0, NULL,
			    newASSIGNOP(OPf_STACKED, var, 0, slice)));
		}
		prev_type = 2;
		max_arity = -1;
	    } break;
	    default:
		parse_error:
		qerror(Perl_mess(aTHX_ "Parse error"));
		return NULL;
	}
	lex_read_space(0);
	c = lex_peek_unichar(0);
	switch (c) {
	    case /*(*/')': break;
	    case ',':
		do {
		    lex_token_boundary();
		    lex_read_unichar(0);
		    lex_read_space(0);
		    c = lex_peek_unichar(0);
		} while (c == ',');
		break;
	    default:
		goto parse_error;
	}
    }
    if (min_arity != 0) {
	initops = op_append_list(OP_LINESEQ,
	    newSTATEOP(0, NULL,
		newLOGOP(OP_OR, 0,
		    newBINOP(OP_GE, 0,
			scalar(newUNOP(OP_RV2AV, 0,
			    newGVOP(OP_GV, 0, PL_defgv))),
			newSVOP(OP_CONST, 0, newSViv(min_arity))),
		    op_convert_list(OP_DIE, 0,
		        op_convert_list(OP_SPRINTF, 0,
		            op_append_list(OP_LIST,
		                newSVOP(OP_CONST, 0,
		                    newSVpvs("Too few arguments for subroutine at %s line %d.\n")),
		                newSLICEOP(0,
		                    op_append_list(OP_LIST,
		                        newSVOP(OP_CONST, 0, newSViv(1)),
		                        newSVOP(OP_CONST, 0, newSViv(2))),
		                    newOP(OP_CALLER, 0))))))),
	    initops);
    }
    if (max_arity != -1) {
	initops = op_append_list(OP_LINESEQ,
	    newSTATEOP(0, NULL,
		newLOGOP(OP_OR, 0,
		    newBINOP(OP_LE, 0,
			scalar(newUNOP(OP_RV2AV, 0,
			    newGVOP(OP_GV, 0, PL_defgv))),
			newSVOP(OP_CONST, 0, newSViv(max_arity))),
		    op_convert_list(OP_DIE, 0,
		        op_convert_list(OP_SPRINTF, 0,
		            op_append_list(OP_LIST,
		                newSVOP(OP_CONST, 0,
		                    newSVpvs("Too many arguments for subroutine at %s line %d.\n")),
		                newSLICEOP(0,
		                    op_append_list(OP_LIST,
		                        newSVOP(OP_CONST, 0, newSViv(1)),
		                        newSVOP(OP_CONST, 0, newSViv(2))),
		                    newOP(OP_CALLER, 0))))))),
	    initops);
    }
    return initops;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.20
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@a25 1

d41 1
a41 1
#include "dquote_static.c"
a56 1
#define PL_lex_expect		(PL_parser->lex_expect)
a88 17
#ifdef PERL_MAD
#  define PL_endwhite		(PL_parser->endwhite)
#  define PL_faketokens		(PL_parser->faketokens)
#  define PL_lasttoke		(PL_parser->lasttoke)
#  define PL_nextwhite		(PL_parser->nextwhite)
#  define PL_realtokenstart	(PL_parser->realtokenstart)
#  define PL_skipwhite		(PL_parser->skipwhite)
#  define PL_thisclose		(PL_parser->thisclose)
#  define PL_thismad		(PL_parser->thismad)
#  define PL_thisopen		(PL_parser->thisopen)
#  define PL_thisstuff		(PL_parser->thisstuff)
#  define PL_thistoken		(PL_parser->thistoken)
#  define PL_thiswhite		(PL_parser->thiswhite)
#  define PL_thiswhite		(PL_parser->thiswhite)
#  define PL_nexttoke		(PL_parser->nexttoke)
#  define PL_curforce		(PL_parser->curforce)
#else
a91 1
#endif
a94 5
#ifdef PERL_MAD
#  define CURMAD(slot,sv) if (PL_madskills) { curmad(slot,sv); sv = 0; }
#  define NEXTVAL_NEXTTOKE PL_nexttoke[PL_curforce].next_val
#else
#  define CURMAD(slot,sv)
a95 1
#endif
d102 1
a102 1
#   define UTF (!IN_BYTES)
d104 1
a104 1
#   define UTF ((PL_linestr && DO_UTF8(PL_linestr)) || ( !(PL_parser->lex_flags & LEX_IGNORE_UTF8_HINTS) && (PL_hints & HINT_UTF8)))
d116 5
a169 12
#ifdef PERL_MAD
#  define SKIPSPACE0(s) skipspace0(s)
#  define SKIPSPACE1(s) skipspace1(s)
#  define SKIPSPACE2(s,tsv) skipspace2(s,&tsv)
#  define PEEKSPACE(s) skipspace2(s,0)
#else
#  define SKIPSPACE0(s) skipspace(s)
#  define SKIPSPACE1(s) skipspace(s)
#  define SKIPSPACE2(s,tsv) skipspace(s)
#  define PEEKSPACE(s) skipspace(s)
#endif

d189 1
d194 1
d210 1
a210 1
#define AOPERATOR(retval) return ao((PL_expect = XTERM, PL_bufptr = s, REPORT(retval)))
d216 4
a219 1
#define LOOPX(f) return (pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)LOOPEX))
d224 6
a229 4
#define BOop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITOROP)))
#define BAop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITANDOP)))
#define SHop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)SHIFTOP)))
#define PWop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)POWOP)))
d231 3
a233 2
#define Aop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)ADDOP)))
#define Mop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MULOP)))
d250 1
a250 1
	s = PEEKSPACE(s); \
a352 1
    { PEG,		TOKENTYPE_NONE,		"PEG" },
a387 2
    dVAR;

d405 1
a405 1
	else if ((char)rv > ' ' && (char)rv <= '~')
d475 2
a476 2
 * This subroutine detects &&=, ||=, and //= and turns an ANDAND, OROR or DORDOR
 * into an OP_ANDASSIGN, OP_ORASSIGN, or OP_DORASSIGN
a481 1
    dVAR;
d492 1
a492 1
    return toketype;
d506 3
a513 1
    dVAR;
a559 1
    dVAR;
a589 1
    dVAR;
d655 1
a655 1
The code to be parsed comes from I<line> and I<rsfp>.  I<line>, if
d657 2
a658 2
A copy of the string is made, so subsequent modification of I<line>
does not affect parsing.  I<rsfp>, if non-null, provides an input stream
d660 2
a661 2
code in I<line> comes first and must consist of complete lines of input,
and I<rsfp> supplies the remainder of the source.
d663 1
a663 1
The I<flags> parameter is reserved for future use.  Currently it is only
a680 1
    dVAR;
a701 3
#ifdef PERL_MAD
    parser->curforce = -1;
#else
a702 1
#endif
d739 1
a739 1
    assert(FITS_IN_8_BITS(LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
d760 2
a761 2
    else if (parser->rsfp && (!parser->old_parser ||
		(parser->old_parser && parser->rsfp != parser->old_parser->rsfp)))
a776 3
#ifdef PERL_MAD
    I32 nexttoke = parser->lasttoke;
#else
a777 1
#endif
a779 10
#ifdef PERL_MAD
	if (S_is_opval_token(parser->nexttoke[nexttoke].next_type
				& 0xffff)
	 && parser->nexttoke[nexttoke].next_val.opval
	 && parser->nexttoke[nexttoke].next_val.opval->op_slabbed
	 && OpSLAB(parser->nexttoke[nexttoke].next_val.opval) == slab) {
		op_free(parser->nexttoke[nexttoke].next_val.opval);
		parser->nexttoke[nexttoke].next_val.opval = NULL;
	}
#else
a786 1
#endif
d890 1
a890 1
at least I<len> octets (including terminating C<NUL>).  Returns a
d951 3
a953 3
The string to be inserted is represented by I<len> octets starting
at I<pv>.  These octets are interpreted as either UTF-8 or Latin-1,
according to whether the C<LEX_STUFF_UTF8> flag is set in I<flags>.
d1036 1
a1036 1
		    *bufptr++ = TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1));
d1063 1
a1063 1
The string to be inserted is represented by octets starting at I<pv>
d1066 1
a1066 1
in I<flags>.  The characters are recoded for the lexer buffer, according
d1092 1
a1092 1
The string to be inserted is the string value of I<sv>.  The characters
d1117 1
a1117 1
I<ptr>.  Text following I<ptr> will be moved, and the buffer shortened.
d1151 1
a1151 1
to I<ptr>.  This advances L</PL_parser-E<gt>bufptr> to match I<ptr>,
d1182 2
a1183 2
up to I<ptr>.  The remaining content of the buffer will be moved, and
all pointers into the buffer updated appropriately.  I<ptr> must not
d1244 1
a1244 1
read in.  If I<flags> includes C<LEX_KEEP_PREVIOUS>, the current chunk
d1273 3
a1275 2
    if (!(flags & LEX_KEEP_PREVIOUS) &&
	    PL_parser->bufptr == PL_parser->bufend) {
a1315 4
#ifdef PERL_MAD
	if (PL_madskills && !PL_in_eval && (PL_minus_p || PL_minus_n))
	    PL_faketokens = 1;
#endif
d1342 4
a1345 2
    if (got_some_for_debugger && (PERLDB_LINE || PERLDB_SAVESRC) &&
	    PL_curstash != PL_debstash) {
d1365 2
a1366 2
discarded at the same time, but if I<flags> includes C<LEX_KEEP_PREVIOUS>
then the current chunk will not be discarded.
d1436 2
a1437 2
discarded at the same time, but if I<flags> includes C<LEX_KEEP_PREVIOUS>
then the current chunk will not be discarded.
d1474 1
a1474 1
time, but if I<flags> includes C<LEX_KEEP_PREVIOUS> then the current
a1490 8
#ifdef PERL_MAD
    if (PL_skipwhite) {
	sv_free(PL_skipwhite);
	PL_skipwhite = NULL;
    }
    if (PL_madskills)
	PL_skipwhite = newSVpvs("");
#endif /* PERL_MAD */
a1512 4
#ifdef PERL_MAD
	    if (PL_madskills)
		sv_catpvn(PL_skipwhite, PL_parser->bufptr, s-PL_parser->bufptr);
#endif /* PERL_MAD */
d1528 2
a1533 4
#ifdef PERL_MAD
    if (PL_madskills)
	sv_catpvn(PL_skipwhite, PL_parser->bufptr, s-PL_parser->bufptr);
#endif /* PERL_MAD */
d1593 4
a1596 3
		else if ((*p == '@@' || *p == '%') &&
		    !after_slash &&
		    !in_brackets ) {
a1651 1
    dVAR;
d1656 1
d1697 1
a1697 1
	while (!isSPACE(*t))
d1706 3
a1708 1
    line_num = atoi(n)-1;
a1772 79
#ifdef PERL_MAD
/* skip space before PL_thistoken */

STATIC char *
S_skipspace0(pTHX_ char *s)
{
    PERL_ARGS_ASSERT_SKIPSPACE0;

    s = skipspace(s);
    if (!PL_madskills)
	return s;
    if (PL_skipwhite) {
	if (!PL_thiswhite)
	    PL_thiswhite = newSVpvs("");
	sv_catsv(PL_thiswhite, PL_skipwhite);
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
    PL_realtokenstart = s - SvPVX(PL_linestr);
    return s;
}

/* skip space after PL_thistoken */

STATIC char *
S_skipspace1(pTHX_ char *s)
{
    const char *start = s;
    I32 startoff = start - SvPVX(PL_linestr);

    PERL_ARGS_ASSERT_SKIPSPACE1;

    s = skipspace(s);
    if (!PL_madskills)
	return s;
    start = SvPVX(PL_linestr) + startoff;
    if (!PL_thistoken && PL_realtokenstart >= 0) {
	const char * const tstart = SvPVX(PL_linestr) + PL_realtokenstart;
	PL_thistoken = newSVpvn(tstart, start - tstart);
    }
    PL_realtokenstart = -1;
    if (PL_skipwhite) {
	if (!PL_nextwhite)
	    PL_nextwhite = newSVpvs("");
	sv_catsv(PL_nextwhite, PL_skipwhite);
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
    return s;
}

STATIC char *
S_skipspace2(pTHX_ char *s, SV **svp)
{
    char *start;
    const I32 startoff = s - SvPVX(PL_linestr);

    PERL_ARGS_ASSERT_SKIPSPACE2;

    s = skipspace(s);
    if (!PL_madskills || !svp)
	return s;
    start = SvPVX(PL_linestr) + startoff;
    if (!PL_thistoken && PL_realtokenstart >= 0) {
	char * const tstart = SvPVX(PL_linestr) + PL_realtokenstart;
	PL_thistoken = newSVpvn(tstart, start - tstart);
	PL_realtokenstart = -1;
    }
    if (PL_skipwhite) {
	if (!*svp)
	    *svp = newSVpvs("");
	sv_setsv(*svp, PL_skipwhite);
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
    
    return s;
}
#endif
a1807 3
#ifdef PERL_MAD
    char *start = s;
#endif /* PERL_MAD */
a1808 6
#ifdef PERL_MAD
    if (PL_skipwhite) {
	sv_free(PL_skipwhite);
	PL_skipwhite = NULL;
    }
#endif /* PERL_MAD */
d1810 1
a1810 1
	while (s < PL_bufend && SPACE_OR_TAB(*s))
a1823 4
#ifdef PERL_MAD
    if (PL_madskills)
	PL_skipwhite = newSVpvn(start, s-start);
#endif /* PERL_MAD */
a1838 1
    dVAR;
d1853 2
a1854 2
		     "Warning: Use of \"%.*s\" without parentheses is ambiguous",
		     (int)(s - PL_last_uni), PL_last_uni);
d1867 4
a1870 1
 *  - if we have a next token, then it's a list operator [why?]
a1877 2
    dVAR;

a1881 1
    PL_expect = x;
a1884 4
#ifdef PERL_MAD
    if (PL_lasttoke)
	goto lstop;
#else
d1887 1
a1887 1
#endif
d1890 1
a1890 1
    s = PEEKSPACE(s);
a1900 70
#ifdef PERL_MAD
 /*
 * S_start_force
 * Sets up for an eventual force_next().  start_force(0) basically does
 * an unshift, while start_force(-1) does a push.  yylex removes items
 * on the "pop" end.
 */

STATIC void
S_start_force(pTHX_ int where)
{
    int i;

    if (where < 0)	/* so people can duplicate start_force(PL_curforce) */
	where = PL_lasttoke;
    assert(PL_curforce < 0 || PL_curforce == where);
    if (PL_curforce != where) {
	for (i = PL_lasttoke; i > where; --i) {
	    PL_nexttoke[i] = PL_nexttoke[i-1];
	}
	PL_lasttoke++;
    }
    if (PL_curforce < 0)	/* in case of duplicate start_force() */
	Zero(&PL_nexttoke[where], 1, NEXTTOKE);
    PL_curforce = where;
    if (PL_nextwhite) {
	if (PL_madskills)
	    curmad('^', newSVpvs(""));
	CURMAD('_', PL_nextwhite);
    }
}

STATIC void
S_curmad(pTHX_ char slot, SV *sv)
{
    MADPROP **where;

    if (!sv)
	return;
    if (PL_curforce < 0)
	where = &PL_thismad;
    else
	where = &PL_nexttoke[PL_curforce].next_mad;

    if (PL_faketokens)
	sv_setpvs(sv, "");
    else {
	if (!IN_BYTES) {
	    if (UTF && is_utf8_string((U8*)SvPVX(sv), SvCUR(sv)))
		SvUTF8_on(sv);
	    else if (PL_encoding) {
		sv_recode_to_utf8(sv, PL_encoding);
	    }
	}
    }

    /* keep a slot open for the head of the list? */
    if (slot != '_' && *where && (*where)->mad_key == '^') {
	(*where)->mad_key = slot;
	sv_free(MUTABLE_SV(((*where)->mad_val)));
	(*where)->mad_val = (void*)sv;
    }
    else
	addmad(newMADsv(slot, sv), where, 0);
}
#else
#  define start_force(where)    NOOP
#  define curmad(slot, sv)      NOOP
#endif

d1906 2
a1907 2
 * will need to set PL_nextval[] (or PL_nexttoke[].next_val with PERL_MAD),
 * and possibly PL_expect to ensure the lexer handles the token correctly.
a1912 1
    dVAR;
d1919 1
a1919 10
#ifdef PERL_MAD
    if (PL_curforce < 0)
	start_force(PL_lasttoke);
    PL_nexttoke[PL_curforce].next_type = type;
    if (PL_lex_state != LEX_KNOWNEXT)
 	PL_lex_defer = PL_lex_state;
    PL_lex_state = LEX_KNOWNEXT;
    PL_lex_expect = PL_expect;
    PL_curforce = -1;
#else
a1923 1
	PL_lex_expect = PL_expect;
a1925 1
#endif
a1939 1
    dVAR;
a1946 1
	    start_force(PL_curforce);
a1948 1
	start_force(PL_curforce);
a1967 1
	    start_force(-1);
a1985 1
    dVAR;
d1989 1
a1989 1
				  && !is_ascii_string((const U8*)start, len)
a2007 1
 *   int allow_initial_tick : used by the "sub" lexer only.
a2012 1
    dVAR;
d2018 1
a2018 1
    start = SKIPSPACE1(start);
d2020 2
a2021 2
    if (isIDFIRST_lazy_if(s,UTF) ||
	(allow_pack && *s == ':') )
a2031 3
	start_force(PL_curforce);
	if (PL_madskills)
	    curmad('X', newSVpvn(start,s-start));
d2033 1
a2033 1
	    s = SKIPSPACE1(s);
a2039 2
	if (PL_madskills)
	    curmad('g', newSVpvs( "forced" ));
a2060 2
    dVAR;

a2066 1
	start_force(PL_curforce);
d2075 1
a2075 1
			      (PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL)
a2088 1
    start_force(PL_curforce);
a2131 1
    dVAR;
a2133 3
#ifdef PERL_MAD
    I32 startoff = s - SvPVX(PL_linestr);
#endif
d2137 1
a2137 1
    s = SKIPSPACE1(s);
a2144 6
#ifdef PERL_MAD
	if (PL_madskills) {
	    start_force(PL_curforce);
	    curmad('X', newSVpvn(s,d-s));
	}
#endif
a2156 7
#ifdef PERL_MAD
	    if (PL_madskills) {
		sv_free(PL_nextwhite);	/* let next token collect whitespace */
		PL_nextwhite = 0;
		s = SvPVX(PL_linestr) + startoff;
	    }
#endif
a2160 7
#ifdef PERL_MAD
    if (PL_madskills && !version) {
	sv_free(PL_nextwhite);	/* let next token collect whitespace */
	PL_nextwhite = 0;
	s = SvPVX(PL_linestr) + startoff;
    }
#endif
a2161 1
    start_force(PL_curforce);
a2175 1
    dVAR;
a2176 3
#ifdef PERL_MAD
    I32 startoff = s - SvPVX(PL_linestr);
#endif
d2189 2
a2190 2
    else if ( (*s != ';' && *s != '{' && *s != '}' ) &&
	    (s = SKIPSPACE1(s), (*s != ';' && *s != '{' && *s != '}' )))
a2197 7
#ifdef PERL_MAD
    if (PL_madskills && !version) {
	sv_free(PL_nextwhite);	/* let next token collect whitespace */
	PL_nextwhite = 0;
	s = SvPVX(PL_linestr) + startoff;
    }
#endif
a2198 1
    start_force(PL_curforce);
a2215 1
    dVAR;
a2285 1
    dVAR;
d2294 3
a2296 1
	SV *sv = tokeq(PL_lex_stuff);
a2306 1
	PL_lex_stuff = NULL;
a2335 1
    dVAR;
d2349 1
d2387 7
a2439 1
    dVAR;
d2488 1
a2488 1
	return ',';
a2491 14
#ifdef PERL_MAD
	if (PL_madskills) {
	    if (PL_thiswhite) {
		if (!PL_endwhite)
		    PL_endwhite = newSVpvs("");
		sv_catsv(PL_endwhite, PL_thiswhite);
		PL_thiswhite = 0;
	    }
	    if (PL_thistoken)
		sv_setpvs(PL_thistoken,"");
	    else
		PL_realtokenstart = -1;
	}
#endif
d2521 6
d2540 1
a2540 1
        yyerror(Perl_form(aTHX_
d2542 2
a2543 1
            (int) (first_bad_char_loc - (U8 *) backslash_ptr), backslash_ptr));
d2575 3
a2577 2
    /* This code needs to be sync'ed with a regex in _charnames.pm which does
     * the same thing */
d2588 4
a2591 1
	    if (*s == ' ' && *(s-1) == ' ' && ckWARN_d(WARN_DEPRECATED)) {
d2593 1
a2593 1
                           "A sequence of multiple spaces in a charnames "
a2597 5
        if (*(s-1) == ' ' && ckWARN_d(WARN_DEPRECATED)) {
            Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                        "Trailing white-space in a charnames alias "
                        "definition is deprecated");
        }
d2609 1
a2609 1
            if (! isALPHAU(TWO_BYTE_UTF8_TO_NATIVE(*s, *(s+1)))) {
d2633 2
a2634 5
                if (*s == ' ' && *(s-1) == ' '
                 && ckWARN_d(WARN_DEPRECATED)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                               "A sequence of multiple spaces in a charnam"
                               "es alias definition is deprecated");
d2639 1
a2639 1
                if (! isCHARNAME_CONT(TWO_BYTE_UTF8_TO_NATIVE(*s, *(s+1))))
d2643 8
d2667 11
a2677 5
        if (*(s-1) == ' ' && ckWARN_d(WARN_DEPRECATED)) {
            Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                       "Trailing white-space in a charnames alias "
                       "definition is deprecated");
        }
a2707 1
        int bad_char_size = ((UTF) ? UTF8SKIP(s) : 1);
d2714 2
a2715 2
            (int)(s - backslash_ptr + bad_char_size), backslash_ptr,
            (int)(e - s + bad_char_size), s + bad_char_size
d2720 11
a2764 1

a2823 1
    dVAR;
d2825 2
a2826 2
    SV *sv = newSV(send - start);		/* sv for the constant.  See
						   note below on sizing. */
d2829 9
a2837 10
    bool dorange = FALSE;			/* are we in a translit range? */
    bool didrange = FALSE;		        /* did we just finish a range? */
    bool in_charclass = FALSE;			/* within /[...]/ */
    bool has_utf8 = FALSE;			/* Output constant is UTF8 */
    bool  this_utf8 = cBOOL(UTF);		/* Is the source string assumed
						   to be UTF8?  But, this can
						   show as true when the source
						   isn't utf8, as for example
						   when it is entirely composed
						   of hex constants */
d2839 2
d2857 3
a2859 2
    UV literal_endpoint = 0;
    bool native_range = TRUE; /* turned to FALSE if the first endpoint is Unicode. */
d2875 3
a2877 1
    while (s < send || dorange) {
a2880 5
	    /* expand a range A-Z to the full set of characters.  AIE! */
	    if (dorange) {
		I32 i;				/* current expanded character */
		I32 min;			/* first character in range */
		I32 max;			/* last character in range */
d2882 34
d2917 47
a2963 1
		UV uvmax = 0;
d2966 14
a2979 1
		if (has_utf8
d2981 22
a3002 1
		    && !native_range
a3003 11
                ) {
		    char * const c = (char*)utf8_hop((U8*)d, -1);
		    char *e = d++;
		    while (e-- > c)
			*(e + 1) = *e;
		    *c = (char) ILLEGAL_UTF8_BYTE;
		    /* mark the range as done, and continue */
		    dorange = FALSE;
		    didrange = TRUE;
		    continue;
		}
d3005 42
a3046 1
		i = d - SvPVX_const(sv);		/* remember current offset */
d3048 1
a3048 9
                SvGROW(sv,
		       SvLEN(sv) + (has_utf8 ?
				    (512 - UTF_CONTINUATION_MARK +
				     UNISKIP(0x100))
				    : 256));
                /* How many two-byte within 0..255: 128 in UTF-8,
		 * 96 in UTF-8-mod. */
#else
		SvGROW(sv, SvLEN(sv) + 256);	/* never more than 256 chars in a range */
d3050 17
a3066 1
		d = SvPVX(sv) + i;		/* refresh d after realloc */
d3068 14
d3083 8
a3090 20
                    int j;
                    for (j = 0; j <= 1; j++) {
                        char * const c = (char*)utf8_hop((U8*)d, -1);
                        const UV uv    = utf8n_to_uvchr((U8*)c, d - c, NULL, 0);
                        if (j)
                            min = (U8)uv;
                        else if (uv < 256)
                            max = (U8)uv;
                        else {
                            max = (U8)0xff; /* only to \xff */
                            uvmax = uv; /* \x{100} to uvmax */
                        }
                        d = c; /* eat endpoint chars */
                     }
                }
               else {
#endif
		   d -= 2;		/* eat the first char and the - */
		   min = (U8)*d;	/* first char in range */
		   max = (U8)d[1];	/* last char in range  */
d3092 10
a3101 1
	       }
a3102 5

                if (min > max) {
		    Perl_croak(aTHX_
			       "Invalid range \"%c-%c\" in transliteration operator",
			       (char)min, (char)max);
d3105 24
a3128 8
#ifdef EBCDIC
		if (literal_endpoint == 2 &&
		    ((isLOWER_A(min) && isLOWER_A(max)) ||
		     (isUPPER_A(min) && isUPPER_A(max))))
                {
                    for (i = min; i <= max; i++) {
                        if (isALPHA_A(i))
                            *d++ = i;
d3131 10
a3140 6
		else
#endif
		    for (i = min; i <= max; i++)
#ifdef EBCDIC
                        if (has_utf8) {
                            append_utf8_from_native_byte(i, &d);
d3142 4
a3145 2
                        else
#endif
d3147 10
a3156 5
 
#ifdef EBCDIC
                if (uvmax) {
                    d = (char*)uvchr_to_utf8((U8*)d, 0x100);
                    if (uvmax > 0x101)
d3158 2
a3159 2
                    if (uvmax > 0x100)
                        d = (char*)uvchr_to_utf8((U8*)d, uvmax);
a3160 1
#endif
d3162 1
d3164 1
a3165 1
		didrange = TRUE;
d3167 2
a3168 1
		literal_endpoint = 0;
d3171 2
a3172 30
	    }

	    /* range begins (ignore - as first or last char) */
	    else if (*s == '-' && s+1 < send  && s != start) {
		if (didrange) {
		    Perl_croak(aTHX_ "Ambiguous range in transliteration operator");
		}
		if (has_utf8
#ifdef EBCDIC
		    && !native_range
#endif
		    ) {
		    *d++ = (char) ILLEGAL_UTF8_BYTE;	/* use illegal utf8 byte--see pmtrans */
		    s++;
		    continue;
		}
		dorange = TRUE;
		s++;
	    }
	    else {
		didrange = FALSE;
#ifdef EBCDIC
		literal_endpoint = 0;
		native_range = TRUE;
#endif
	    }
	}

	/* if we get here, we're not doing a transliteration */

d3200 3
a3202 3
	    else if (!PL_lex_casemods &&
		     (    s[2] == '{' /* This should match regcomp.c */
		      || (s[2] == '?' && s[3] == '{')))
d3209 5
a3213 2
	else if (*s == '#' && PL_lex_inpat && !in_charclass &&
	  ((PMOP*)PL_lex_inpat)->op_pmflags & RXf_PMf_EXTENDED) {
d3226 1
a3226 1
	    if (isWORDCHAR_lazy_if(s+1,UTF))
d3259 5
a3263 2
	    if (PL_lex_inwhat == OP_SUBST && !PL_lex_inpat &&
		isDIGIT(*s) && *s != '0' && !isDIGIT(s[1]))
d3282 1
d3293 1
a3293 1
			|| regcurly(s + 1, FALSE)))
a3299 8

	    /* quoted - in transliterations */
	    case '-':
		if (PL_lex_inwhat == OP_TRANS) {
		    *d++ = *s++;
		    continue;
		}
		/* FALL THROUGH */
d3363 1
a3363 4
		/* Insert oct or hex escaped character.  There will always be
		 * enough room in sv since such escapes will be longer than any
		 * UTF-8 sequence they can end up as, except if they force us
		 * to recode the rest of the string into utf8 */
d3366 4
a3369 1
		if (!UVCHR_IS_INVARIANT(uv)) {
d3379 7
a3385 3
			sv_utf8_upgrade_flags_grow(sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					UNISKIP(uv) + (STRLEN)(send - s) + 1);
d3391 14
d3406 3
a3408 2
			if (PL_lex_inwhat == OP_TRANS &&
			    PL_sublex_info.sub_op) {
a3412 4
#ifdef EBCDIC
			if (uv > 255 && !dorange)
			    native_range = FALSE;
#endif
d3418 3
a3420 3
		else {
		    *d++ = (char) uv;
		}
d3424 22
a3445 12
		/* In a non-pattern \N must be a named character, like \N{LATIN
		 * SMALL LETTER A} or \N{U+0041}.  For patterns, it also can
		 * mean to match a non-newline.  For non-patterns, named
		 * characters are converted to their string equivalents. In
		 * patterns, named characters are not converted to their
		 * ultimate forms for the same reasons that other escapes
		 * aren't.  Instead, they are converted to the \N{U+...} form
		 * to get the value from the charnames that is in effect right
		 * now, while preserving the fact that it was a named character
		 * so that the regex compiler knows this */

		/* The structure of this section of code (besides checking for
d3447 14
a3460 12
		 *  Further disambiguate between the two meanings of \N, and if
		 *	not a charname, go process it elsewhere
		 *  If of form \N{U+...}, pass it through if a pattern;
		 *	otherwise convert to utf8
		 *  Otherwise must be \N{NAME}: convert to \N{U+c1.c2...} if a
		 *  pattern; otherwise convert to utf8 */

		/* Here, s points to the 'N'; the test below is guaranteed to
		 * succeed if we are being called on a pattern as we already
		 * know from a test above that the next character is a '{'.
		 * On a non-pattern \N must mean 'named sequence, which
		 * requires braces */
a3480 6
		    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
				| PERL_SCAN_DISALLOW_PREFIX;
		    STRLEN len;

		    /* For \N{U+...}, the '...' is a unicode value even on
		     * EBCDIC machines */
d3482 1
a3482 7
		    len = e - s;
		    uv = grok_hex(s, &len, &flags, NULL);
		    if (len == 0 || len != (STRLEN)(e - s)) {
			yyerror("Invalid hexadecimal number in \\N{U+...}");
			s = e + 1;
			continue;
		    }
d3484 20
a3503 1
		    if (PL_lex_inpat) {
d3505 4
a3508 16
			/* On non-EBCDIC platforms, pass through to the regex
			 * compiler unchanged.  The reason we evaluated the
			 * number above is to make sure there wasn't a syntax
			 * error.  But on EBCDIC we convert to native so
			 * downstream code can continue to assume it's native
			 */
			s -= 5;	    /* Include the '\N{U+' */
#ifdef EBCDIC
			d += my_snprintf(d, e - s + 1 + 1,  /* includes the }
							       and the \0 */
				    "\\N{U+%X}",
				    (unsigned int) UNI_TO_NATIVE(uv));
#else
			Copy(s, d, e - s + 1, char);	/* 1 = include the } */
			d += e - s + 1;
#endif
d3511 18
a3528 6

			 /* If destination is not in utf8, unconditionally
			  * recode it to be so.  This is because \N{} implies
			  * Unicode semantics, and scalars have to be in utf8
			  * to guarantee those semantics */
			if (! has_utf8) {
d3534 3
a3536 3
					sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					UNISKIP(uv) + (STRLEN)(send - e) + 1);
d3542 1
a3542 1
			if (UNI_IS_INVARIANT(uv)) {
d3577 3
d3582 4
a3585 2
                                                    + 6 /* For the "\N{U+", and
                                                           trailing NUL */
d3587 2
a3588 2
                                Copy("\\N{U+", d, 5, char);
                                d += 5;
d3591 11
a3601 2
                                    my_snprintf(hex_string, sizeof(hex_string),
                                                "%02X.", (U8) *str);
d3606 1
a3606 1
                                d--;    /* We will overwrite below the final
d3625 2
a3626 2
                                /* Convert first code point to hex, including
                                 * the boiler plate before it. */
d3629 2
a3630 2
                                                "\\N{U+%X",
                                                (unsigned int) uv);
d3642 1
a3642 1
                                * its ordinal in hex */
d3651 3
a3653 3
                                                    sizeof(hex_string),
                                                    ".%X",
                                                    (unsigned int) uv);
d3670 26
a3695 5
			 /* If destination is not in utf8, unconditionally
			  * recode it to be so.  This is because \N{} implies
			  * Unicode semantics, and scalars have to be in utf8
			  * to guarantee those semantics */
			if (! has_utf8) {
d3719 2
d3722 1
a3722 2
		if (!dorange) 
		    native_range = FALSE; /* \N{} is defined to be Unicode */
d3736 3
d3758 1
a3758 1
		*d++ = ASCII_TO_NATIVE('\033');
a3767 4
#ifdef EBCDIC
	else
	    literal_endpoint++;
#endif
a3774 1

d3785 1
a3785 1
	    const STRLEN need = UNISKIP(nextuv);
a3805 4
#ifdef EBCDIC
	    if (uv > 255 && !dorange)
		native_range = FALSE;
#endif
d3820 2
a3821 2
    if (PL_encoding && !has_utf8) {
	sv_recode_to_utf8(sv, PL_encoding);
a3901 2
    dVAR;

d3920 1
a3920 1
	if (regcurly(s, FALSE)) {
d3976 4
a3979 2
		else if (*s == '$' && s[1] &&
		  strchr("[#!%*<>()-=",s[1])) {
d4061 1
a4061 1
S_intuit_method(pTHX_ char *start, GV *gv, CV *cv)
a4062 1
    dVAR;
d4067 6
a4072 3
#ifdef PERL_MAD
    int soff;
#endif
d4089 2
a4090 2
	if (cv || PL_last_lop_op == OP_PRINT || PL_last_lop_op == OP_SAY ||
		isUPPER(*PL_tokenbuf))
d4092 1
a4092 7
#ifdef PERL_MAD
	len = start - SvPVX(PL_linestr);
#endif
	s = PEEKSPACE(s);
#ifdef PERL_MAD
	start = SvPVX(PL_linestr) + len;
#endif
a4107 3
#ifdef PERL_MAD
	    soff = s - SvPVX(PL_linestr);
#endif
d4115 1
a4115 4
#ifdef PERL_MAD
	    soff = s - SvPVX(PL_linestr);
#endif
	    s = PEEKSPACE(s);
a4118 1
	    start_force(PL_curforce);
a4121 3
	    if (PL_madskills)
		curmad('X', newSVpvn_flags(start,SvPVX(PL_linestr) + soff - start,
                                                            ( UTF ? SVf_UTF8 : 0 )));
a4124 3
#ifdef PERL_MAD
	    PL_bufptr = SvPVX(PL_linestr) + soff; /* restart before space */
#endif
a4150 1
    dVAR;
a4218 1
    dVAR;
a4245 1
    dVAR;
a4334 2
    dVAR;

a4356 1
    dVAR;
d4364 5
a4368 3
    if (len > 2 &&
        (pkgname[len - 2] == ':' && pkgname[len - 1] == ':') &&
        (gv = gv_fetchpvn_flags(pkgname, len, ( UTF ? SVf_UTF8 : 0 ), SVt_PVHV)))
d4378 1
a4378 1
            pkgname = SvPV_const(sv, len);
a4383 180
#ifdef PERL_MAD 
 /*
 * Perl_madlex
 * The intent of this yylex wrapper is to minimize the changes to the
 * tokener when we aren't interested in collecting madprops.  It remains
 * to be seen how successful this strategy will be...
 */

int
Perl_madlex(pTHX)
{
    int optype;
    char *s = PL_bufptr;

    /* make sure PL_thiswhite is initialized */
    PL_thiswhite = 0;
    PL_thismad = 0;

    /* previous token ate up our whitespace? */
    if (!PL_lasttoke && PL_nextwhite) {
	PL_thiswhite = PL_nextwhite;
	PL_nextwhite = 0;
    }

    /* isolate the token, and figure out where it is without whitespace */
    PL_realtokenstart = -1;
    PL_thistoken = 0;
    optype = yylex();
    s = PL_bufptr;
    assert(PL_curforce < 0);

    if (!PL_thismad || PL_thismad->mad_key == '^') {	/* not forced already? */
	if (!PL_thistoken) {
	    if (PL_realtokenstart < 0 || !CopLINE(PL_curcop))
		PL_thistoken = newSVpvs("");
	    else {
		char * const tstart = SvPVX(PL_linestr) + PL_realtokenstart;
		PL_thistoken = newSVpvn(tstart, s - tstart);
	    }
	}
	if (PL_thismad)	/* install head */
	    CURMAD('X', PL_thistoken);
    }

    /* last whitespace of a sublex? */
    if (optype == ')' && PL_endwhite) {
	CURMAD('X', PL_endwhite);
    }

    if (!PL_thismad) {

	/* if no whitespace and we're at EOF, bail.  Otherwise fake EOF below. */
	if (!PL_thiswhite && !PL_endwhite && !optype) {
	    sv_free(PL_thistoken);
	    PL_thistoken = 0;
	    return 0;
	}

	/* put off final whitespace till peg */
	if (optype == ';' && !PL_rsfp && !PL_parser->filtered) {
	    PL_nextwhite = PL_thiswhite;
	    PL_thiswhite = 0;
	}
	else if (PL_thisopen) {
	    CURMAD('q', PL_thisopen);
	    if (PL_thistoken)
		sv_free(PL_thistoken);
	    PL_thistoken = 0;
	}
	else {
	    /* Store actual token text as madprop X */
	    CURMAD('X', PL_thistoken);
	}

	if (PL_thiswhite) {
	    /* add preceding whitespace as madprop _ */
	    CURMAD('_', PL_thiswhite);
	}

	if (PL_thisstuff) {
	    /* add quoted material as madprop = */
	    CURMAD('=', PL_thisstuff);
	}

	if (PL_thisclose) {
	    /* add terminating quote as madprop Q */
	    CURMAD('Q', PL_thisclose);
	}
    }

    /* special processing based on optype */

    switch (optype) {

    /* opval doesn't need a TOKEN since it can already store mp */
    case WORD:
    case METHOD:
    case FUNCMETH:
    case THING:
    case PMFUNC:
    case PRIVATEREF:
    case FUNC0SUB:
    case UNIOPSUB:
    case LSTOPSUB:
	if (pl_yylval.opval)
	    append_madprops(PL_thismad, pl_yylval.opval, 0);
	PL_thismad = 0;
	return optype;

    /* fake EOF */
    case 0:
	optype = PEG;
	if (PL_endwhite) {
	    addmad(newMADsv('p', PL_endwhite), &PL_thismad, 0);
	    PL_endwhite = 0;
	}
	break;

    /* pval */
    case LABEL:
	break;

    case ']':
    case '}':
	if (PL_faketokens)
	    break;
	/* remember any fake bracket that lexer is about to discard */ 
	if (PL_lex_brackets == 1 &&
	    ((expectation)PL_lex_brackstack[0] & XFAKEBRACK))
	{
	    s = PL_bufptr;
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
		s++;
	    if (*s == '}') {
		PL_thiswhite = newSVpvn(PL_bufptr, ++s - PL_bufptr);
		addmad(newMADsv('#', PL_thiswhite), &PL_thismad, 0);
		PL_thiswhite = 0;
		PL_bufptr = s - 1;
		break;	/* don't bother looking for trailing comment */
	    }
	    else
		s = PL_bufptr;
	}
	if (optype == ']')
	    break;
	/* FALLTHROUGH */

    /* attach a trailing comment to its statement instead of next token */
    case ';':
	if (PL_faketokens)
	    break;
	if (PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == optype) {
	    s = PL_bufptr;
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
		s++;
	    if (*s == '\n' || *s == '#') {
		while (s < PL_bufend && *s != '\n')
		    s++;
		if (s < PL_bufend)
		    s++;
		PL_thiswhite = newSVpvn(PL_bufptr, s - PL_bufptr);
		addmad(newMADsv('#', PL_thiswhite), &PL_thismad, 0);
		PL_thiswhite = 0;
		PL_bufptr = s;
	    }
	}
	break;

    /* ival */
    default:
	break;

    }

    /* Create new token struct.  Note: opvals return early above. */
    pl_yylval.tkval = newTOKEN(optype, pl_yylval, PL_thismad);
    PL_thismad = 0;
    return optype;
}
#endif
a4386 2
    dVAR;

d4393 1
a4393 1
    s = SKIPSPACE1(s);
d4397 1
a4397 2
		|| (s = SKIPSPACE1(s), (*s == ';' || *s == '}'))) {
	    start_force(PL_curforce);
d4416 2
a4417 1
	  "ATTRTERM", "TERMBLOCK", "POSTDEREF", "TERMORDORDOR"
d4425 4
a4428 4
    return (len == 1 && strchr("msyq", p[0])) ||
	   (len == 2 && (
	    (p[0] == 't' && p[1] == 'r') ||
	    (p[0] == 'q' && strchr("qwxr", p[1]))));
a4518 5
    switch (PL_lex_state) {
    case LEX_NORMAL:
    case LEX_INTERPNORMAL:
	break;

d4520 1
a4520 22
    case LEX_KNOWNEXT:
#ifdef PERL_MAD
	PL_lasttoke--;
	pl_yylval = PL_nexttoke[PL_lasttoke].next_val;
	if (PL_madskills) {
	    PL_thismad = PL_nexttoke[PL_lasttoke].next_mad;
	    PL_nexttoke[PL_lasttoke].next_mad = 0;
	    if (PL_thismad && PL_thismad->mad_key == '_') {
		PL_thiswhite = MUTABLE_SV(PL_thismad->mad_val);
		PL_thismad->mad_val = 0;
		mad_free(PL_thismad);
		PL_thismad = 0;
	    }
	}
	if (!PL_lasttoke) {
	    PL_lex_state = PL_lex_defer;
  	    PL_expect = PL_lex_expect;
  	    PL_lex_defer = LEX_NORMAL;
	    if (!PL_nexttoke[PL_lasttoke].next_type)
		return yylex();
  	}
#else
a4524 1
	    PL_expect = PL_lex_expect;
a4526 1
#endif
a4528 3
#ifdef PERL_MAD
	    next_type = PL_nexttoke[PL_lasttoke].next_type;
#else
a4529 1
#endif
d4545 6
a4573 4
#ifdef PERL_MAD
		    if (PL_madskills)
			PL_thistoken = newSVpvs("\\E");
#endif
a4582 11
#ifdef PERL_MAD
	    while (PL_bufptr != PL_bufend &&
	      PL_bufptr[0] == '\\' && PL_bufptr[1] == 'E') {
		if (PL_madskills) {
		  if (!PL_thiswhite)
		    PL_thiswhite = newSVpvs("");
		  sv_catpvn(PL_thiswhite, PL_bufptr, 2);
		}
		PL_bufptr += 2;
	    }
#else
a4584 1
#endif
a4592 7
#ifdef PERL_MAD
		if (PL_madskills) {
		  if (!PL_thiswhite)
		    PL_thiswhite = newSVpvs("");
		  sv_catpvn(PL_thiswhite, PL_bufptr, 4);
		}
#endif
d4599 4
a4602 5
		if (!PL_madskills) /* when just compiling don't need correct */
		    if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
			tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
		if ((*s == 'L' || *s == 'U' || *s == 'F') &&
		    (strchr(PL_lex_casestack, 'L')
d4604 2
a4605 1
                        || strchr(PL_lex_casestack, 'F'))) {
a4614 1
		start_force(PL_curforce);
a4616 1
		start_force(PL_curforce);
a4630 7
		if (PL_madskills) {
		    SV* const tmpsv = newSVpvs("\\ ");
		    /* replace the space with the character we want to escape
		     */
		    SvPVX(tmpsv)[1] = *s;
		    curmad('_', tmpsv);
		}
a4636 7
#ifdef PERL_MAD
		if (PL_madskills) {
		    if (PL_thistoken)
			sv_free(PL_thistoken);
		    PL_thistoken = newSVpvs("");
		}
#endif
d4639 1
a4639 1
		    OPERATOR(',');
d4641 1
a4641 1
		    Aop(OP_CONCAT);
a4661 1
	    start_force(PL_curforce);
a4663 1
	    start_force(PL_curforce);
a4664 1
	    start_force(PL_curforce);
a4666 1
	    start_force(PL_curforce);
a4668 1
	    start_force(PL_curforce);
a4677 2
	    start_force(PL_curforce);
	    /* XXX probably need a CURMAD(something) here */
a4683 7
#ifdef PERL_MAD
	    if (PL_madskills) {
		if (PL_thistoken)
		    sv_free(PL_thistoken);
		PL_thistoken = newSVpvs("");
	    }
#endif
d4686 1
a4686 1
		OPERATOR(',');
d4688 1
a4688 1
		Aop(OP_CONCAT);
d4697 1
a4697 1
	/* FALL THROUGH */
d4700 8
a4711 7
#ifdef PERL_MAD
	    if (PL_madskills) {
		if (PL_thistoken)
		    sv_free(PL_thistoken);
		PL_thistoken = newSVpvs("");
	    }
#endif
a4742 2
	    start_force(PL_curforce);
	    /* XXX probably need a CURMAD(something) here */
d4759 8
a4785 4
	    start_force(PL_curforce);
	    if (PL_madskills) {
		curmad('X', newSVpvn(PL_bufptr,s-PL_bufptr));
	    }
a4789 7
#ifdef PERL_MAD
		if (PL_madskills) {
		    if (PL_thistoken)
			sv_free(PL_thistoken);
		    PL_thistoken = newSVpvs("");
		}
#endif
d4792 1
a4792 1
		    OPERATOR(',');
d4794 1
a4794 1
		    Aop(OP_CONCAT);
a4821 7
#ifdef PERL_MAD
    if (PL_thistoken) {
	sv_free(PL_thistoken);
	PL_thistoken = 0;
    }
    PL_realtokenstart = s - SvPVX(PL_linestr);	/* assume but undo on ws */
#endif
d4824 13
a4836 1
	if (UTF ? isIDFIRST_utf8((U8*)s) : isALNUMC(*s))
d4838 2
a4839 1
	{
d4848 1
a4848 1
            d = UTF ? (char *) Perl_utf8_hop(aTHX_ (U8 *) s, -UNRECOGNIZED_PRECEDE_COUNT) : s - UNRECOGNIZED_PRECEDE_COUNT;
a4859 4
#ifdef PERL_MAD
	if (PL_madskills)
	    PL_faketokens = 0;
#endif
d4864 3
a4866 2
	    if (PL_lex_brackets &&
		    PL_lex_brackstack[PL_lex_brackets-1] != XFAKEEOF) {
a4882 4
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_faketokens = 1;
#endif
d4949 1
a4949 1
	    if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
a4967 4
#ifdef PERL_MAD
	    if (!PL_rsfp)
		PL_realtokenstart = -1;
#endif
d4971 6
a4976 5
	    if (bof && PL_rsfp &&
		     (*s == 0 ||
		      *(U8*)s == BOM_UTF8_FIRST_BYTE ||
		      *(U8*)s >= 0xFE ||
		      s[1] == 0)) {
a4990 4
#ifdef PERL_MAD
		if (PL_madskills)
		    sv_catsv(PL_thiswhite, PL_linestr);
#endif
a5009 4
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_thiswhite = newSVpvn(PL_linestart, s - PL_linestart);
#endif
d5041 22
a5062 18
		    SV * const x = GvSV(gv_fetchpvs("\030", GV_ADD|GV_NOTQUAL,
						    SVt_PV)); /* $^X */
		    assert(SvPOK(x) || SvGMAGICAL(x));
		    if (sv_eq(x, CopFILESV(PL_curcop))) {
			sv_setpvn(x, ipath, ipathend - ipath);
			SvSETMAGIC(x);
		    }
		    else {
			STRLEN blen;
			STRLEN llen;
			const char *bstart = SvPV_const(CopFILESV(PL_curcop),blen);
			const char * const lstart = SvPV_const(x,llen);
			if (llen < blen) {
			    bstart += blen - llen;
			    if (strnEQ(bstart, lstart, llen) &&	bstart[-1] == '/') {
				sv_setpvn(x, ipath, ipathend - ipath);
				SvSETMAGIC(x);
			    }
d5064 3
d5083 1
a5083 1
			    if ((*d == 'p' || *d == 'P')
d5114 6
a5119 6
		if (!d &&
		    *s == '#' &&
		    ipathend > ipath &&
		    !PL_minus_c &&
		    !instr(s,"indir") &&
		    instr(PL_origargv[0],"perl"))
d5165 1
a5165 1
			    if (baduni || *d1 == 'M' || *d1 == 'm') {
d5182 2
a5183 2
			if (((PERLDB_LINE || PERLDB_SAVESRC) && !oldpdb) ||
			    ((PL_minus_n || PL_minus_p) && !(oldn || oldp)))
d5192 1
a5192 1
			    if (PERLDB_LINE || PERLDB_SAVESRC)
a5201 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = 0;
d5212 1
a5212 9
    case ' ': case '\t': case '\f': case 013:
#ifdef PERL_MAD
	PL_realtokenstart = -1;
	if (PL_madskills) {
	  if (!PL_thiswhite)
	    PL_thiswhite = newSVpvs("");
	  sv_catpvn(PL_thiswhite, s, 1);
	}
#endif
d5217 4
a5220 7
#ifdef PERL_MAD
	PL_realtokenstart = -1;
	if (PL_madskills)
	    PL_faketokens = 0;
#endif
	if (PL_lex_state != LEX_NORMAL ||
	     (PL_in_eval && !PL_rsfp && !PL_parser->filtered)) {
d5227 16
a5242 26
	    if (PL_madskills && !PL_lex_formbrack && !PL_in_eval) {
		s = SKIPSPACE0(s);
		if (!PL_in_eval || PL_rsfp || PL_parser->filtered)
		    incline(s);
	    }
	    else {
		const bool in_comment = *s == '#';
		d = s;
		while (d < PL_bufend && *d != '\n')
		    d++;
		if (d < PL_bufend)
		    d++;
		else if (d > PL_bufend) /* Found by Ilya: feed random input to Perl. */
		    Perl_croak(aTHX_ "panic: input overflow, %p > %p",
			       d, PL_bufend);
#ifdef PERL_MAD
		if (PL_madskills)
		    PL_thiswhite = newSVpvn(s, d - s);
#endif
		s = d;
		if (in_comment && d == PL_bufend
		 && PL_lex_state == LEX_INTERPNORMAL
		 && PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
		 && SvEVALED(PL_lex_repl) && d[-1] == '}') s--;
		else incline(s);
	    }
a5244 2
		start_force(PL_curforce);
		NEXTVAL_NEXTTOKE.ival = 0;
d5250 11
a5260 34
#ifdef PERL_MAD
	    if (PL_madskills && CopLINE(PL_curcop) >= 1 && !PL_lex_formbrack) {
		if (CopLINE(PL_curcop) == 1 && s[0] == '#' && s[1] == '!') {
		    PL_faketokens = 0;
		    s = SKIPSPACE0(s);
		    TOKEN(PEG);	/* make sure any #! line is accessible */
		}
		s = SKIPSPACE0(s);
	    }
	    else {
#endif
		    if (PL_madskills) d = s;
		    while (s < PL_bufend && *s != '\n')
			s++;
		    if (s < PL_bufend)
		    {
			s++;
			if (s < PL_bufend)
			    incline(s);
		    }
		    else if (s > PL_bufend) /* Found by Ilya: feed random input to Perl. */
		      Perl_croak(aTHX_ "panic: input overflow");
#ifdef PERL_MAD
		    if (PL_madskills && CopLINE(PL_curcop) >= 1) {
			if (!PL_thiswhite)
			    PL_thiswhite = newSVpvs("");
			if (CopLINE(PL_curcop) == 1) {
			    sv_setpvs(PL_thiswhite, "");
			    PL_faketokens = 0;
			}
			sv_catpvn(PL_thiswhite, d, s - d);
		    }
	    }
#endif
d5346 2
a5347 3
		s = SKIPSPACE1(s);
		if (FEATURE_POSTDEREF_IS_ENABLED && (
		    ((*s == '$' || *s == '&') && s[1] == '*')
d5351 1
a5351 1
		 ))
a5352 4
		    Perl_ck_warner_d(aTHX_
			packWARN(WARN_EXPERIMENTAL__POSTDEREF),
			"Postfix dereference is experimental"
		    );
d5366 4
a5369 2
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d5393 4
a5396 2
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d5422 3
a5424 2
	    if (*s == '=' && !PL_lex_allbrackets &&
		    PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d5430 4
a5433 2
	if (*s == '=' && !PL_lex_allbrackets &&
		PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d5443 4
a5446 2
	    if (s[1] == '=' && !PL_lex_allbrackets &&
		    PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
d5448 1
d5470 4
d5476 2
d5479 1
d5481 1
a5481 1
	BOop(OP_BIT_XOR);
d5504 5
a5508 1
	OPERATOR('~');
d5520 3
a5523 4
	    OP *attrs;
#ifdef PERL_MAD
	    I32 stuffstart;
#endif
d5539 1
a5539 4
#ifdef PERL_MAD
	    stuffstart = s - SvPVX(PL_linestr) - 1;
#endif
	    s = PEEKSPACE(s);
d5563 1
a5563 1
		    d = scan_str(d,TRUE,TRUE,FALSE,FALSE,NULL);
d5581 1
a5581 1
		    SvREFCNT_dec(PL_lex_stuff);
d5608 13
d5636 1
a5636 1
		s = PEEKSPACE(d);
d5638 1
a5638 1
		    s = PEEKSPACE(s+1);
d5644 6
a5649 4
		if (*s != ';' && *s != '}' &&
		    !(PL_expect == XOPERATOR
			? (*s == '=' ||  *s == ')')
			: (*s == '{' ||  *s == '('))) {
a5672 1
		start_force(PL_curforce);
a5673 1
		CURMAD('_', PL_nextwhite);
a5675 6
#ifdef PERL_MAD
	    if (PL_madskills) {
		PL_thistoken = newSVpvn(SvPVX(PL_linestr) + stuffstart,
				     (s - SvPVX(PL_linestr)) - stuffstart);
	    }
#endif
d5678 1
d5691 1
a5691 1
	s = SKIPSPACE1(s);
d5699 2
a5700 1
	OPERATOR(';');
d5706 1
a5706 1
	s = SKIPSPACE1(s);
d5764 7
a5770 1
	    /* FALL THROUGH */
d5777 2
a5778 3
	case XATTRTERM:
	case XTERMBLOCK:
	    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d5789 1
a5789 1
		s = SKIPSPACE1(s);
d5800 6
d5825 1
a5825 1
			if (*t++ == '\\' && (*t == '\\' || *t == *s))
d5873 1
a5873 1
			     t += UTF8SKIP(t);
d5876 1
a5876 1
		    t += UTF8SKIP(t);
d5878 1
a5878 1
			 t += UTF8SKIP(t);
d5888 22
a5909 1
		    PL_expect = XTERM;
d5918 1
a5918 2
	if (isSPACE(*s) || *s == '#')
	    PL_copline = NOLINE;   /* invalidate current command line number */
a5936 7
#if 0
		    if (PL_madskills) {
			if (!PL_thiswhite)
			    PL_thiswhite = newSVpvs("");
			sv_catpvs(PL_thiswhite,"}");
		    }
#endif
a5952 5
	start_force(PL_curforce);
	if (PL_madskills) {
	    curmad('X', newSVpvn(s-1,1));
	    CURMAD('_', PL_thiswhite);
	}
a5954 4
#ifdef PERL_MAD
	if (PL_madskills && !PL_thistoken)
	    PL_thistoken = newSVpvs("");
#endif
a5955 1
	    start_force(PL_curforce);
d5980 3
d5985 1
d5989 6
a5994 2
	    PL_parser->saw_infix_sigil = 1;
	    BAop(OP_BIT_AND);
d6000 1
a6001 1
	    PL_expect = XOPERATOR;
a6005 1
	pl_yylval.ival = (OPpENTERSUB_AMPER<<8);
d6019 3
d6024 1
a6024 1
	    s--;
d6027 1
a6027 1
	BOop(OP_BIT_OR);
d6033 3
a6035 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
d6042 3
a6044 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMMA) {
d6057 27
a6083 34
	    if (PL_expect == XSTATE && isALPHA(tmp) &&
		(s == PL_linestart+1 || s[-2] == '\n') )
		{
		    if ((PL_in_eval && !PL_rsfp && !PL_parser->filtered)
			|| PL_lex_state != LEX_NORMAL) {
			d = PL_bufend;
			while (s < d) {
			    if (*s++ == '\n') {
				incline(s);
				if (strnEQ(s,"=cut",4)) {
				    s = strchr(s,'\n');
				    if (s)
					s++;
				    else
					s = d;
				    incline(s);
				    goto retry;
				}
			    }
			}
			goto retry;
		    }
#ifdef PERL_MAD
		    if (PL_madskills) {
			if (!PL_thiswhite)
			    PL_thiswhite = newSVpvs("");
			sv_catpvn(PL_thiswhite, PL_linestart,
				  PL_bufend - PL_linestart);
		    }
#endif
		    s = PL_bufend;
		    PL_parser->in_pod = 1;
		    goto retry;
		}
d6123 4
a6126 4
		    if (*t == '/' || *t == '?' ||
			((*t == 'm' || *t == 's' || *t == 'y')
			 && !isWORDCHAR(t[1])) ||
			(*t == 't' && t[1] == 'r' && !isWORDCHAR(t[2])))
d6130 3
a6132 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
d6147 1
a6147 1
	    if (s[1] == '<')
d6158 3
a6160 2
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d6169 3
a6171 2
		    if (!PL_lex_allbrackets &&
			    PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
d6178 3
a6180 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
d6198 3
a6200 2
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d6207 3
a6209 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
d6243 8
a6250 2
	    if (PL_expect == XOPERATOR)
		no_op("Array length", s);
d6261 8
a6268 2
	if (PL_expect == XOPERATOR)
	    no_op("Scalar", s);
d6279 1
a6279 1
		s = SKIPSPACE1(s);
d6291 1
a6291 1
			    PL_bufptr = PEEKSPACE(PL_bufptr); /* XXX can realloc */
d6295 2
a6296 2
					"Multidimensional syntax %.*s not supported",
				    (int)((t - PL_bufptr) + 1), PL_bufptr);
d6381 2
a6382 3
	if (PL_expect == XOPERATOR)
	    no_op("Array", s);
	else if (PL_expect == XPOSTDEREF) POSTDEREF('@@');
d6385 8
d6398 1
a6398 1
	    s = SKIPSPACE1(s);
d6415 1
a6415 1
	if (PL_expect == XTERMORDORDOR && s[1] == '/') {
d6422 32
a6453 48
     case '?':			/* may either be conditional or pattern */
	if (PL_expect == XOPERATOR) {
	     char tmp = *s++;
	     if(tmp == '?') {
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_IFELSE) {
		    s--;
		    TOKEN(0);
		}
		PL_lex_allbrackets++;
		OPERATOR('?');
	     }
             else {
	         tmp = *s++;
	         if(tmp == '/') {
	             /* A // operator. */
		    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
			    (*s == '=' ? LEX_FAKEEOF_ASSIGN :
					    LEX_FAKEEOF_LOGIC)) {
			s -= 2;
			TOKEN(0);
		    }
	            AOPERATOR(DORDOR);
	         }
	         else {
	             s--;
		     if (*s == '=' && !PL_lex_allbrackets &&
			     PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
			 s--;
			 TOKEN(0);
		     }
	             Mop(OP_DIVIDE);
	         }
	     }
	 }
	 else {
	     /* Disable warning on "study /blah/" */
	     if (PL_oldoldbufptr == PL_last_uni
	      && (*PL_last_uni != 's' || s - PL_last_uni < 5
	          || memNE(PL_last_uni, "study", 5)
	          || isWORDCHAR_lazy_if(PL_last_uni+5,UTF)
	      ))
	         check_uni();
	     if (*s == '?')
		 deprecate("?PATTERN? without explicit operator");
	     s = scan_pat(s,OP_MATCH);
	     TERM(sublex_start());
	 }
d6475 3
a6477 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_RANGE) {
d6490 3
a6492 2
	    if (*s == '=' && !PL_lex_allbrackets &&
		    PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
d6498 1
a6498 1
	/* FALL THROUGH */
d6508 1
a6508 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d6524 1
a6524 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d6555 8
a6562 2
	s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
	DEBUG_T( { printbuf("### Saw backtick string before %s\n", s); } );
d6704 1
a6704 1
		PL_expect = XSTATE;
d6709 1
a6709 1
		PL_expect = XOPERATOR;
d6736 1
a6736 1
	    off = pad_findmy_pvn(tmpbuf, len+1, UTF ? SVf_UTF8 : 0);
d6773 2
a6774 2
					    SVt_PVCV)) &&
		    (cv = GvCVu(gv)))
d6781 9
a6789 10
		if (!ogv &&
		    (gvp = (GV**)hv_fetch(PL_globalstash, PL_tokenbuf,
					  len, FALSE)) &&
		    (gv = *gvp) && (
			isGV_with_GP(gv)
			    ? GvCVu(gv) && GvIMPORTED_CV(gv)
			    :   SvPCS_IMPORTED(gv)
			     && (gv_init(gv, PL_globalstash, PL_tokenbuf,
					 len, 0), 1)
		   ))
d6857 1
a6857 7
		const char penultchar =
		    lastchar && PL_bufptr - 2 >= PL_linestart
			 ? PL_bufptr[-2]
			 : 0;
#ifdef PERL_MAD
		SV *nextPL_nextwhite = 0;
#endif
d6884 1
a6884 2
		/* Look for a subroutine with this name in current package,
		   unless this is a lexical sub, or name is "Foo::",
d6888 3
a6890 2
		if (len > 2 && !PL_madskills &&
		    PL_tokenbuf[len - 2] == ':' && PL_tokenbuf[len - 1] == ':')
d6901 1
d6904 1
a6904 10
		    if (!lex && !gv) {
			/* Mustn't actually add anything to a symbol table.
			   But also don't want to "initialise" any placeholder
			   constants that might already be there into full
			   blown PVGVs with attached PVCV.  */
			gv = gv_fetchpvn_flags(PL_tokenbuf, len,
					       GV_NOADD_NOINIT | ( UTF ? SVf_UTF8 : 0 ),
					       SVt_PVCV);
		    }
		    len = 0;
d6911 1
a6911 1
		    len ? len : strlen(PL_tokenbuf));
a6918 7
#ifdef PERL_MAD
		if (PL_madskills && !PL_thistoken) {
		    char *start = SvPVX(PL_linestr) + PL_realtokenstart;
		    PL_thistoken = newSVpvn(start,s - start);
		    PL_realtokenstart = s - SvPVX(PL_linestr);
		}
#endif
d6926 1
a6926 1
		if (len)
d6933 9
a6941 2
		    rv2cv_op = newCVREF(0, const_op);
		    cv = lex ? GvCV(gv) : rv2cv_op_cv(rv2cv_op, 0);
d6944 4
d6950 8
a6957 7
		if (PL_oldoldbufptr &&
		    PL_oldoldbufptr < PL_bufptr &&
		    (PL_oldoldbufptr == PL_last_lop
		     || PL_oldoldbufptr == PL_last_uni) &&
		    /* NO SKIPSPACE BEFORE HERE! */
		    (PL_expect == XREF ||
		     ((PL_opargs[PL_last_lop_op] >> OASHIFT)& 7) == OA_FILEREF))
d6962 1
a6962 4
		    s = SKIPSPACE2(s,nextPL_nextwhite);
#ifdef PERL_MAD
		    PL_nextwhite = nextPL_nextwhite;	/* assume no & deception */
#endif
d6966 4
a6969 7
		    if ((isIDFIRST_lazy_if(s,UTF) || *s == '$') &&
			(tmp = intuit_method(s, gv, cv))) {
			op_free(rv2cv_op);
			if (tmp == METHOD && !PL_lex_allbrackets &&
				PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
			return REPORT(tmp);
d6977 4
a6980 4
			( !immediate_paren && (PL_last_lop_op == OP_SORT ||
                         (!cv &&
                        (PL_last_lop_op != OP_MAPSTART &&
			 PL_last_lop_op != OP_GREPSTART))))
d6982 2
a6983 1
			    && ((PL_opargs[PL_last_lop_op] & OA_CLASS_MASK) == OA_FILESTATOP))
a6991 5
#ifdef PERL_MAD
		if (isSPACE(*s))
		    s = SKIPSPACE2(s,nextPL_nextwhite);
		PL_nextwhite = nextPL_nextwhite;
#else
a6992 1
#endif
d6998 11
a7008 7
		    /* This is our own scalar, created a few lines above,
		       so this is safe. */
		    SvREADONLY_off(cSVOPx(pl_yylval.opval)->op_sv);
		    sv_setpv(((SVOP*)pl_yylval.opval)->op_sv, PL_tokenbuf);
		    if (UTF && !IN_BYTES && is_utf8_string((U8*)PL_tokenbuf, len))
		      SvUTF8_on(((SVOP*)pl_yylval.opval)->op_sv);
		    SvREADONLY_on(cSVOPx(pl_yylval.opval)->op_sv);
a7023 7
#ifdef PERL_MAD
		    if (PL_madskills) {
			PL_nextwhite = PL_thiswhite;
			PL_thiswhite = 0;
		    }
		    start_force(PL_curforce);
#endif
a7025 8
		    PL_expect = XOPERATOR;
#ifdef PERL_MAD
		    if (PL_madskills) {
			PL_nextwhite = nextPL_nextwhite;
			curmad('X', PL_thistoken);
			PL_thistoken = newSVpvs("");
		    }
#endif
d7039 3
a7041 2
		    if (!PL_lex_allbrackets &&
			    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
d7043 4
a7046 1
		    PREBLOCK(METHOD);
d7051 1
a7051 1
		if (!orig_keyword
d7053 11
a7063 1
			&& (tmp = intuit_method(s, gv, cv))) {
d7065 3
a7067 2
		    if (tmp == METHOD && !PL_lex_allbrackets &&
			    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
d7069 1
a7075 7
		    if (lastchar == '-' && penultchar != '-') {
			const STRLEN l = len ? len : strlen(PL_tokenbuf);
 			Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
			    "Ambiguous use of -%"UTF8f" resolved as -&%"UTF8f"()",
			     UTF8fARG(UTF, l, PL_tokenbuf),
			     UTF8fARG(UTF, l, PL_tokenbuf));
                    }
a7100 3
#ifdef PERL_MAD
			cv &&
#endif
d7138 3
a7140 2
			    if (!PL_lex_allbrackets &&
				    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
d7142 1
a7145 65
#ifdef PERL_MAD
		    {
			if (PL_madskills) {
			    PL_nextwhite = PL_thiswhite;
			    PL_thiswhite = 0;
			}
			start_force(PL_curforce);
			NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
			PL_expect = XTERM;
			if (PL_madskills) {
			    PL_nextwhite = nextPL_nextwhite;
			    curmad('X', PL_thistoken);
			    PL_thistoken = newSVpvs("");
			}
			force_next(off ? PRIVATEREF : WORD);
			if (!PL_lex_allbrackets &&
				PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
			TOKEN(NOAMP);
		    }
		}

		/* Guess harder when madskills require "best effort". */
		if (PL_madskills && (!gv || !GvCVu(gv))) {
		    int probable_sub = 0;
		    if (strchr("\"'`$@@%0123456789!*+{[<", *s))
			probable_sub = 1;
		    else if (isALPHA(*s)) {
			char tmpbuf[1024];
			STRLEN tmplen;
			d = s;
			d = scan_word(d, tmpbuf, sizeof tmpbuf, TRUE, &tmplen);
			if (!keyword(tmpbuf, tmplen, 0))
			    probable_sub = 1;
			else {
			    while (d < PL_bufend && isSPACE(*d))
				d++;
			    if (*d == '=' && d[1] == '>')
				probable_sub = 1;
			}
		    }
		    if (probable_sub) {
			gv = gv_fetchpv(PL_tokenbuf, GV_ADD | ( UTF ? SVf_UTF8 : 0 ),
                                        SVt_PVCV);
			op_free(pl_yylval.opval);
			pl_yylval.opval =
			    off ? (OP *)newCVREF(0, rv2cv_op) : rv2cv_op;
			pl_yylval.opval->op_private |= OPpENTERSUB_NOPAREN;
			PL_last_lop = PL_oldbufptr;
			PL_last_lop_op = OP_ENTERSUB;
			PL_nextwhite = PL_thiswhite;
			PL_thiswhite = 0;
			start_force(PL_curforce);
			NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
			PL_expect = XTERM;
			PL_nextwhite = nextPL_nextwhite;
			curmad('X', PL_thistoken);
			PL_thistoken = newSVpvs("");
			force_next(off ? PRIVATEREF : WORD);
			if (!PL_lex_allbrackets &&
				PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
			TOKEN(NOAMP);
		    }
#else
d7149 3
a7151 2
		    if (!PL_lex_allbrackets &&
			    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
d7153 1
a7154 1
#endif
d7241 1
a7241 1
#if defined(HAS_FCNTL) && defined(F_SETFD)
d7244 3
a7246 1
		    fcntl(fd,F_SETFD,fd >= 3);
d7281 1
a7281 1
		    else if (PL_encoding) {
d7287 1
a7287 1
			XPUSHs(PL_encoding);
a7300 15
#ifdef PERL_MAD
		if (PL_madskills) {
		    if (PL_realtokenstart >= 0) {
			char *tstart = SvPVX(PL_linestr) + PL_realtokenstart;
			if (!PL_endwhite)
			    PL_endwhite = newSVpvs("");
			sv_catsv(PL_endwhite, PL_thiswhite);
			PL_thiswhite = 0;
			sv_catpvn(PL_endwhite, tstart, PL_bufend - tstart);
			PL_realtokenstart = -1;
		    }
		    while ((s = filter_gets(PL_endwhite, SvCUR(PL_endwhite)))
			   != NULL) ;
		}
#endif
d7307 3
a7309 1
	    FUN0OP(newPVOP(OP_RUNCV,0,NULL));
d7444 1
a7444 1
	    s = SKIPSPACE1(s);
d7453 1
a7453 1
		    d = SKIPSPACE1(d);
a7491 2
	    PL_expect = XOPERATOR;
	    s = force_word(s,WORD,TRUE,FALSE);
a7509 2
	    if (PL_madskills)
		UNI(OP_INT);
d7513 1
a7513 1
	    s = SKIPSPACE1(s);
d7562 1
a7562 1
	    s = SKIPSPACE1(s);
a7564 3
#ifdef PERL_MAD
		int soff = s - SvPVX(PL_linestr); /* for skipspace realloc */
#endif
d7566 3
a7568 2
		if ((PL_bufend - p) >= 3 &&
		    strnEQ(p, "my", 2) && isSPACE(*(p + 2)))
d7570 3
a7572 2
		else if ((PL_bufend - p) >= 4 &&
		    strnEQ(p, "our", 3) && isSPACE(*(p + 3)))
d7574 1
a7574 1
		p = PEEKSPACE(p);
d7578 1
a7578 1
		    p = PEEKSPACE(p);
a7581 3
#ifdef PERL_MAD
		s = SvPVX(PL_linestr) + soff;
#endif
a7616 2
	    PL_expect = XOPERATOR;
	    s = force_word(s,WORD,TRUE,FALSE);
a7740 2
	    PL_expect = XOPERATOR;
	    s = force_word(s,WORD,TRUE,FALSE);
d7809 8
d7818 1
a7818 1
	    s = SKIPSPACE1(s);
a7819 3
#ifdef PERL_MAD
		char* start = s;
#endif
d7836 1
d7838 2
a7839 1
		    my_snprintf(tmpbuf, sizeof(tmpbuf), "No such class %.1000s", PL_tokenbuf);
a7841 7
#ifdef PERL_MAD
		if (PL_madskills) {	/* just add type to declarator token */
		    sv_catsv(PL_thistoken, PL_nextwhite);
		    PL_nextwhite = 0;
		    sv_catpvn(PL_thistoken, start, s - start);
		}
#endif
a7846 2
	    PL_expect = XOPERATOR;
	    s = force_word(s,WORD,TRUE,FALSE);
d7856 1
a7856 1
	    TERM(USE);
d7859 1
a7859 1
	    if (*s == '(' || (s = SKIPSPACE1(s), *s == '('))
d7862 3
a7864 2
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
d7866 1
d7871 1
a7871 1
	    s = SKIPSPACE1(s);
d7931 1
a7931 1
	    s = SKIPSPACE1(s);
d7933 1
a7933 2
	    PL_lex_expect = XBLOCK;
	    OPERATOR(PACKAGE);
d7939 1
a7939 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d7951 1
a7951 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d7992 2
a7993 4
	    if (PL_lex_stuff) {
		SvREFCNT_dec(PL_lex_stuff);
		PL_lex_stuff = NULL;
	    }
d8000 1
a8000 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d8013 1
a8013 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d8023 1
a8023 2
	    s = SKIPSPACE1(s);
	    PL_expect = XOPERATOR;
d8036 1
a8036 1
		    yyerror("<> should be quotes");
d8044 1
a8044 1
	    PL_expect = XTERM;
a8054 2
	    PL_expect = XOPERATOR;
	    s = force_word(s,WORD,TRUE,FALSE);
d8193 1
a8193 1
	    s = SKIPSPACE1(s);
a8229 1
#ifndef PERL_MAD
a8230 10
#endif

#ifdef PERL_MAD
		SV *tmpwhite = 0;

		char *tstart = SvPVX(PL_linestr) + PL_realtokenstart;
		SV *subtoken = PL_madskills
		   ? newSVpvn_flags(tstart, s - tstart, SvUTF8(PL_linestr))
		   : NULL;
		PL_thistoken = 0;
a8232 3
		s = SKIPSPACE2(s,tmpwhite);
#else
		d = s;
a8233 1
#endif
d8235 3
a8237 2
		if (isIDFIRST_lazy_if(s,UTF) || *s == '\'' ||
		    (*s == ':' && s[1] == ':'))
a8238 3
#ifdef PERL_MAD
		    SV *nametoke = NULL;
#endif
a8243 4
#ifdef PERL_MAD
		    if (PL_madskills)
			nametoke = newSVpvn_flags(s, d - s, SvUTF8(PL_linestr));
#else
a8245 1
#endif
d8249 1
a8249 1
			    PL_tokenbuf, len + 1, UTF ? SVf_UTF8 : 0
a8261 8
#ifdef PERL_MAD
		    start_force(0);
		    CURMAD('X', nametoke);
		    CURMAD('_', tmpwhite);
		    force_ident_maybe_lex('&');

		    s = SKIPSPACE2(d,tmpwhite);
#else
a8262 1
#endif
a8278 4
#ifdef PERL_MAD
		    PL_thistoken = subtoken;
		    s = d;
#else
a8279 1
                        start_force(PL_curforce);
a8284 1
#endif
d8290 1
a8290 1
		    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
a8296 13
#ifdef PERL_MAD
		    start_force(0);
		    CURMAD('q', PL_thisopen);
		    CURMAD('_', tmpwhite);
		    CURMAD('=', PL_thisstuff);
		    CURMAD('Q', PL_thisclose);
		    NEXTVAL_NEXTTOKE.opval =
			(OP*)newSVOP(OP_CONST, 0, PL_lex_stuff);
		    PL_lex_stuff = NULL;
		    force_next(THING);

		    s = SKIPSPACE2(s,tmpwhite);
#else
a8297 1
#endif
d8304 7
a8310 1
		else if ((*s != '{' && *s != '(') && key == KEY_sub) {
a8316 12
#ifdef PERL_MAD
		start_force(0);
		if (tmpwhite) {
		    if (PL_madskills)
			curmad('^', newSVpvs(""));
		    CURMAD('_', tmpwhite);
		}
		force_next(0);

		PL_thistoken = subtoken;
                PERL_UNUSED_VAR(have_proto);
#else
a8322 1
#endif
a8329 1
#ifndef PERL_MAD
a8330 1
#endif
d8422 1
a8422 1
	    OPERATOR(USE);
d8466 3
a8468 2
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
d8470 1
a8507 1
    dVAR;
d8533 1
d8537 3
a8539 1
			    PL_in_my == KEY_my ? "my" : "state", PL_tokenbuf),
d8558 1
a8558 1
                                    UTF ? SVf_UTF8 : 0);
d8572 1
a8572 4
                    (PL_in_eval
                        ? (GV_ADDMULTI | GV_ADDINEVAL)
                        : GV_ADDMULTI
                    ),
d8590 5
a8594 2
    if (ckWARN(WARN_AMBIGUOUS) &&
	pit == '@@' && PL_lex_state != LEX_NORMAL && !PL_lex_brackets) {
d8599 2
a8600 2
		&& !( PL_tokenbuf[2] == '\0' &&
		    ( PL_tokenbuf[1] == '-' || PL_tokenbuf[1] == '+' ))
d8619 1
a8619 1
		     (PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : GV_ADD)
a8629 2
    dVAR;

d8668 1
d8675 7
d8699 1
a8699 1
    dVAR; dSP;
d8776 1
a8776 1
now_ok:
a8834 1
    dVAR;
a8885 1
    dVAR;
d8898 28
a8928 1
    dVAR;
d8939 2
a8940 2
    if (isSPACE(*s))
	s = PEEKSPACE(s);
d8948 1
a8948 1
    else {
d8960 9
a8968 6
    if (*s == '$' && s[1] &&
      (isIDFIRST_lazy_if(s+1,is_utf8)
         || isDIGIT_A((U8)s[1])
         || s[1] == '$'
         || s[1] == '{'
         || strnEQ(s+1,"::",2)) )
d8981 1
a8981 1
            s = PEEKSPACE(s);
d8984 4
a8987 19

/* Is the byte 'd' a legal single character identifier name?  'u' is true
 * iff Unicode semantics are to be used.  The legal ones are any of:
 *  a) ASCII digits
 *  b) ASCII punctuation
 *  c) When not under Unicode rules, any upper Latin1 character
 *  d) \c?, \c\, \c^, \c_, and \cA..\cZ, minus the ones that have traditionally
 *     been matched by \s on ASCII platforms.  That is: \c?, plus 1-32, minus
 *     the \s ones. */
#define VALID_LEN_ONE_IDENT(d, u) (isPUNCT_A((U8)(d))                       \
                                   || isDIGIT_A((U8)(d))                    \
                                   || (!(u) && !isASCII((U8)(d)))           \
                                   || ((((U8)(d)) < 32)                     \
                                       && (((((U8)(d)) >= 14)               \
                                           || (((U8)(d)) <= 8 && (d) != 0) \
                                           || (((U8)(d)) == 13))))          \
                                   || (((U8)(d)) == toCTRL('?')))
    if (s < PL_bufend
        && (isIDFIRST_lazy_if(s, is_utf8) || VALID_LEN_ONE_IDENT(*s, is_utf8)))
d8989 10
a8998 2
        if ( isCNTRL_A((U8)*s) ) {
            deprecate("literal control characters in variable names");
d9000 1
a9000 1
        
d9029 2
a9030 2
        d += is_utf8 ? UTF8SKIP(d) : 1;
        parse_ident(&s, &d, e, 1, is_utf8);
d9034 1
a9034 1
                s = PEEKSPACE(s);
d9073 1
a9073 1
            s = PEEKSPACE(s);
d9085 5
a9089 3
		if (ckWARN(WARN_AMBIGUOUS) &&
		    (keyword(dest, d - dest, 0)
		     || get_cvn_flags(dest, d - dest, is_utf8 ? SVf_UTF8 : 0)))
d9092 1
a9092 1
                                            SVs_TEMP | (is_utf8 ? SVf_UTF8 : 0) );
d9099 1
a9099 1
			funny, tmp, funny, tmp);
d9119 1
a9119 1
S_pmflag(pTHX_ const char* const valid_flags, U32 * pmfl, char** s, char* charset) {
d9121 6
a9126 6
    /* Adds, subtracts to/from 'pmfl' based on regex modifier flags found in
     * the parse starting at 's', based on the subset that are valid in this
     * context input to this routine in 'valid_flags'. Advances s.  Returns
     * TRUE if the input should be treated as a valid flag, so the next char
     * may be as well; otherwise FALSE. 'charset' should point to a NUL upon
     * first call on the current regex.  This routine will set it to any
d9148 1
a9148 1
        CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl);
a9217 1
    dVAR;
d9223 1
a9223 3
#ifdef PERL_MAD
    char *modstart;
#endif
d9227 3
a9229 11
    s = scan_str(start,!!PL_madskills,FALSE, (PL_in_eval & EVAL_RE_REPARSING),
                       TRUE /* look for escaped bracketed metas */, NULL);

    if (!s) {
	const char * const delimiter = skipspace(start);
	Perl_croak(aTHX_
		   (const char *)
		   (*delimiter == '?'
		    ? "Search pattern not terminated or ternary operator parsed as search pattern"
		    : "Search pattern not terminated" ));
    }
a9253 3
#ifdef PERL_MAD
    modstart = s;
#endif
d9273 3
a9275 7
    while (*s && S_pmflag(aTHX_ valid_flags, &(pm->op_pmflags), &s, &charset)) {};
#ifdef PERL_MAD
    if (PL_madskills && modstart != s) {
	SV* tmptoken = newSVpvn(modstart, s - modstart);
	append_madprops(newMADPROP('m', MAD_SV, tmptoken, 0), (OP*)pm, 0);
    }
#endif
d9283 2
a9292 1
    dVAR;
d9299 1
a9299 3
#ifdef PERL_MAD
    char *modstart;
#endif
d9306 1
a9306 2
    s = scan_str(start,!!PL_madskills,FALSE,FALSE,
                 TRUE /* look for escaped bracketed metas */, &t);
a9311 9
#ifdef PERL_MAD
    if (PL_madskills) {
	CURMAD('q', PL_thisopen);
	CURMAD('_', PL_thiswhite);
	CURMAD('E', PL_thisstuff);
	CURMAD('Q', PL_thisclose);
	PL_realtokenstart = s - SvPVX(PL_linestr);
    }
#endif
d9315 1
a9315 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d9317 2
a9318 4
	if (PL_lex_stuff) {
	    SvREFCNT_dec(PL_lex_stuff);
	    PL_lex_stuff = NULL;
	}
a9324 8
#ifdef PERL_MAD
    if (PL_madskills) {
	CURMAD('z', PL_thisopen);
	CURMAD('R', PL_thisstuff);
	CURMAD('Z', PL_thisclose);
    }
    modstart = s;
#endif
d9331 2
a9332 1
	else if (! S_pmflag(aTHX_ S_PAT_MODS, &(pm->op_pmflags), &s, &charset))
d9338 2
a9339 8
#ifdef PERL_MAD
    if (PL_madskills) {
	if (modstart != s)
	    curmad('m', newSVpvn(modstart, s - modstart));
	append_madprops(PL_thismad, (OP*)pm, 0);
	PL_thismad = 0;
    }
#endif
a9376 1
    dVAR;
a9382 3
#ifdef PERL_MAD
    char *modstart;
#endif
d9389 1
a9389 1
    s = scan_str(start,!!PL_madskills,FALSE,FALSE,FALSE,&t);
a9393 9
#ifdef PERL_MAD
    if (PL_madskills) {
	CURMAD('q', PL_thisopen);
	CURMAD('_', PL_thiswhite);
	CURMAD('E', PL_thisstuff);
	CURMAD('Q', PL_thisclose);
	PL_realtokenstart = s - SvPVX(PL_linestr);
    }
#endif
d9395 1
a9395 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d9397 2
a9398 4
	if (PL_lex_stuff) {
	    SvREFCNT_dec(PL_lex_stuff);
	    PL_lex_stuff = NULL;
	}
a9400 5
    if (PL_madskills) {
	CURMAD('z', PL_thisopen);
	CURMAD('R', PL_thisstuff);
	CURMAD('Z', PL_thisclose);
    }
a9402 3
#ifdef PERL_MAD
    modstart = s;
#endif
a9432 8
#ifdef PERL_MAD
    if (PL_madskills) {
	if (modstart != s)
	    curmad('m', newSVpvn(modstart, s - modstart));
	append_madprops(PL_thismad, o, 0);
	PL_thismad = 0;
    }
#endif
a9463 1
    dVAR;
a9473 6
#ifdef PERL_MAD
    I32 stuffstart = s - SvPVX(PL_linestr);
    char *tstart;
 
    PL_realtokenstart = -1;
#endif
a9515 9
#ifdef PERL_MAD
    if (PL_madskills) {
	tstart = PL_tokenbuf + 1;
	PL_thisclose = newSVpvn(tstart, len - 1);
	tstart = SvPVX(PL_linestr) + stuffstart;
	PL_thisopen = newSVpvn(tstart, s - tstart);
	stuffstart = s - SvPVX(PL_linestr);
    }
#endif
a9539 11
#ifdef PERL_MAD
    if (PL_madskills) {
	tstart = SvPVX(PL_linestr) + stuffstart;
	if (PL_thisstuff)
	    sv_catpvn(PL_thisstuff, tstart, s - tstart);
	else
	    PL_thisstuff = newSVpvn(tstart, s - tstart);
    }

    stuffstart = s - SvPVX(PL_linestr);
#endif
d9559 1
a9559 1
	PERL_CONTEXT * const cx = &cxstack[cxstack_ix];
d9579 7
a9585 2
	       evaluated to false.  So shared can never be null. */
	    assert(shared);
d9594 1
a9594 1
	else {	/* eval */
d9596 2
a9597 1
	    assert(s);
d9602 3
a9604 2
	while (s < bufend - len + 1 &&
          memNE(s,PL_tokenbuf,len) ) {
a9611 9
#ifdef PERL_MAD
	if (PL_madskills) {
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, d + 1, s - d);
	    else
		PL_thisstuff = newSVpvn(d + 1, s - d);
	    stuffstart = s - SvPVX(PL_linestr);
	}
#endif
d9633 4
a9636 3
	if (cxstack_ix >= 0 && CxTYPE(cx) == CXt_EVAL &&
            CxOLD_OP_TYPE(cx) == OP_ENTEREVAL &&
            cx->blk_eval.cur_text == linestr)
d9653 1
d9660 1
a9663 9
#ifdef PERL_MAD
	if (PL_madskills) {
	    tstart = SvPVX(PL_linestr) + stuffstart;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, PL_bufend - tstart);
	    else
		PL_thisstuff = newSVpvn(tstart, PL_bufend - tstart);
	}
#endif
d9669 9
a9677 1
	    SvREFCNT_dec(linestr_save);
a9688 3
#ifdef PERL_MAD
	stuffstart = s - SvPVX(PL_linestr);
#endif
d9693 2
a9694 2
	    if ((PL_bufend[-2] == '\r' && PL_bufend[-1] == '\n') ||
		(PL_bufend[-2] == '\n' && PL_bufend[-1] == '\r'))
d9706 2
a9707 1
	if (*s == term && memEQ(s,PL_tokenbuf + 1,len)) {
d9712 1
d9728 2
a9729 2
	else if (PL_encoding)
	    sv_recode_to_utf8(tmpstr, PL_encoding);
d9749 1
a9760 1
    dVAR;
d9764 1
d9773 8
a9780 1
    s = delimcpy(d, e, s + 1, end, '>', &len);	/* extract until > */
d9814 1
a9814 1
	s = scan_str(start,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
a9829 1
	gv_readline = gv_fetchpvs("readline", GV_NOTQUAL, SVt_PVCV);
d9840 1
a9840 1
	    const PADOFFSET tmp = pad_findmy_pvn(d, len, UTF ? SVf_UTF8 : 0);
d9864 1
a9864 1
intro_sym:
d9866 1
a9866 3
				(PL_in_eval
				 ? (GV_ADDMULTI | GV_ADDINEVAL)
				 : GV_ADDMULTI) | ( UTF ? SVf_UTF8 : 0 ),
a9876 2
	    if (!readline_overriden)
		PL_lex_op->op_flags |= OPf_SPECIAL;
d9890 1
a9890 1
		: (OP*)newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, gv));
d9902 2
a9903 1
	keep_quoted		preserve \ on the embedded delimiter(s)
a9906 3
	deprecate_escaped_meta	issue a deprecation warning for cer-
				tain paired metacharacters that appear
				escaped within it
d9952 2
a9953 2
S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims, int re_reparse,
		 bool deprecate_escaped_meta, char **delimp
a9955 1
    dVAR;
a9966 1
    char *escaped_open = NULL;
a9967 4
#ifdef PERL_MAD
    int stuffstart;
    char *tstart;
#endif
d9973 1
a9973 1
	s = PEEKSPACE(s);
a9975 8
#ifdef PERL_MAD
    if (PL_realtokenstart >= 0) {
	stuffstart = PL_realtokenstart;
	PL_realtokenstart = -1;
    }
    else
	stuffstart = start - SvPVX(PL_linestr);
#endif
d10003 2
a10004 10
    /* A warning is raised if the input parameter requires it for escaped (by a
     * backslash) paired metacharacters {} [] and () when the delimiters are
     * those same characters, and the backslash is ineffective.  This doesn't
     * happen for <>, as they aren't metas. */
    if (deprecate_escaped_meta
        && (PL_multi_open == PL_multi_close
            || PL_multi_open == '<'
            || ! ckWARN_d(WARN_DEPRECATED)))
    {
        deprecate_escaped_meta = FALSE;
a10017 7
#ifdef PERL_MAD
    tstart = SvPVX(PL_linestr) + stuffstart;
    if (PL_madskills && !PL_thisopen && !keep_delims) {
	PL_thisopen = newSVpvn(tstart, s - tstart);
	stuffstart = s - SvPVX(PL_linestr);
    }
#endif
d10019 1
a10019 1
	if (PL_encoding && !UTF && !re_reparse) {
d10024 1
a10024 1
		const bool found = sv_cat_decode(sv, PL_encoding, PL_linestr,
d10083 1
a10083 1
			    if (!keep_quoted) {
d10101 1
a10101 1
				if (!keep_quoted && *(t+1) == PL_multi_open)
d10142 1
a10142 1
		    if (!keep_quoted
d10147 1
a10147 2
		    /* any other quotes are simply copied straight through */
		    else
d10176 2
a10177 2
		    if (!keep_quoted &&
			((s[1] == PL_multi_open) || (s[1] == PL_multi_close)))
a10179 48

                        /* Here, 'deprecate_escaped_meta' is true iff the
                         * delimiters are paired metacharacters, and 's' points
                         * to an occurrence of one of them within the string,
                         * which was preceded by a backslash.  If this is a
                         * context where the delimiter is also a metacharacter,
                         * the backslash is useless, and deprecated.  () and []
                         * are meta in any context. {} are meta only when
                         * appearing in a quantifier or in things like '\p{'
                         * (but '\\p{' isn't meta).  They also aren't meta
                         * unless there is a matching closed, escaped char
                         * later on within the string.  If 's' points to an
                         * open, set a flag; if to a close, test that flag, and
                         * raise a warning if it was set */

			if (deprecate_escaped_meta) {
                            if (*s == PL_multi_open) {
                                if (*s != '{') {
                                    escaped_open = s;
                                }
                                     /* Look for a closing '\}' */
                                else if (regcurly(s, TRUE)) {
                                    escaped_open = s;
                                }
                                     /* Look for e.g.  '\x{' */
                                else if (s - start > 2
                                         && _generic_isCC(*(s-2),
                                             _CC_BACKSLASH_FOO_LBRACE_IS_META))
                                { /* Exclude '\\x', '\\\\x', etc. */
                                    char *lookbehind = s - 4;
                                    bool is_meta = TRUE;
                                    while (lookbehind >= start
                                           && *lookbehind == '\\')
                                    {
                                        is_meta = ! is_meta;
                                        lookbehind--;
                                    }
                                    if (is_meta) {
                                        escaped_open = s;
                                    }
                                }
                            }
                            else if (escaped_open) {
                                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                    "Useless use of '\\'; doesn't escape metacharacter '%c'", PL_multi_open);
                                escaped_open = NULL;
                            }
                        }
d10183 1
a10183 1
		}
d10207 2
a10208 2
	    if ((to[-2] == '\r' && to[-1] == '\n') ||
		(to[-2] == '\n' && to[-1] == '\r'))
a10224 9
#ifdef PERL_MAD
	if (PL_madskills) {
	    char * const tstart = SvPVX(PL_linestr) + stuffstart;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, PL_bufend - tstart);
	    else
		PL_thisstuff = newSVpvn(tstart, PL_bufend - tstart);
	}
#endif
a10232 3
#ifdef PERL_MAD
	stuffstart = 0;
#endif
d10237 1
a10237 13
    if (!PL_encoding || UTF || re_reparse) {
#ifdef PERL_MAD
	if (PL_madskills) {
	    char * const tstart = SvPVX(PL_linestr) + stuffstart;
	    const int len = s - tstart;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, len);
	    else
		PL_thisstuff = newSVpvn(tstart, len);
	    if (!PL_thisclose && !keep_delims)
		PL_thisclose = newSVpvn(s,termlen);
	}
#endif
d10243 1
a10243 15
#ifdef PERL_MAD
    else {
	if (PL_madskills) {
	    char * const tstart = SvPVX(PL_linestr) + stuffstart;
	    const int len = s - tstart - termlen;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, len);
	    else
		PL_thisstuff = newSVpvn(tstart, len);
	    if (!PL_thisclose && !keep_delims)
		PL_thisclose = newSVpvn(s - termlen,termlen);
	}
    }
#endif
    if (has_utf8 || (PL_encoding && !re_reparse))
d10278 4
a10281 3
  0b[01](_?[01])*
  0[0-7](_?[0-7])*
  0x[0-9A-Fa-f](_?[0-9A-Fa-f])*
a10293 1
    dVAR;
d10302 23
d10367 1
a10367 1
	    if (s[1] == 'x' || s[1] == 'X') {
d10371 1
a10371 1
	    } else if (s[1] == 'b' || s[1] == 'B') {
d10377 1
a10377 1
	    else if (s[1] == '.' || s[1] == 'e' || s[1] == 'E')
d10419 1
a10419 1
		    /* FALL THROUGH */
d10426 1
a10426 1
		    /* FALL THROUGH */
d10449 2
d10473 13
d10500 148
d10681 7
a10687 1
	floatit = FALSE;
d10690 4
a10693 1
	while (isDIGIT(*s) || *s == '_') {
d10733 5
a10737 1
	    for (; isDIGIT(*s) || *s == '_'; s++) {
d10763 16
a10778 2
	if ((*s == 'e' || *s == 'E') && strchr("+-0123456789_", s[1])) {
	    floatit = TRUE;
a10780 2
	    /* regardless of whether user said 3E5 or 3e5, use lower 'e' */
	    *d++ = 'e';		/* At least some Mach atof()s don't grok 'E' */
d10808 2
a10809 2
		   if (((lastub && s == lastub + 1) ||
			(!isDIGIT(s[1]) && s[1] != '_')))
d10841 1
a10841 1
            STORE_NUMERIC_LOCAL_SET_STANDARD();
d10844 16
a10859 3
	    nv = Atof(PL_tokenbuf);
            RESTORE_NUMERIC_LOCAL();
	    sv = newSVnv(nv);
d10873 1
a10873 1
vstring:
a10895 1
    dVAR;
a10900 9
#ifdef PERL_MAD
    char *tokenstart = s;
    SV* savewhite = NULL;

    if (PL_madskills) {
	savewhite = PL_thiswhite;
	PL_thiswhite = 0;
    }
#endif
a10948 8
#ifdef PERL_MAD
	    if (PL_madskills) {
		if (PL_thistoken)
		    sv_catpvn(PL_thistoken, tokenstart, PL_bufend - tokenstart);
		else
		    PL_thistoken = newSVpvn(tokenstart, PL_bufend - tokenstart);
	    }
#endif
a10953 3
#ifdef PERL_MAD
	    tokenstart = PL_bufptr;
#endif
d10967 1
a10967 1
		|| *s2 == 013)
a10969 1
		start_force(PL_curforce);
a10973 1
	    start_force(PL_curforce);
d10980 2
a10981 2
	    else if (PL_encoding)
		sv_recode_to_utf8(stuff, PL_encoding);
a10982 1
	start_force(PL_curforce);
a10990 9
#ifdef PERL_MAD
    if (PL_madskills) {
	if (PL_thistoken)
	    sv_catpvn(PL_thistoken, tokenstart, s - tokenstart);
	else
	    PL_thistoken = newSVpvn(tokenstart, s - tokenstart);
	PL_thiswhite = savewhite;
    }
#endif
a10996 1
    dVAR;
d11012 1
a11012 2
	CvPADLIST(PL_compcv)->xpadl_outid =
	    PadlistNAMES(CvPADLIST(outsidecv));
a11019 2
    dVAR;

a11023 1
    PL_in_eval &= ~EVAL_WARNONLY;
a11043 1
    dVAR;
d11054 6
a11059 3
    else if (PL_oldoldbufptr && PL_bufptr > PL_oldoldbufptr &&
      PL_bufptr - PL_oldoldbufptr < 200 && PL_oldoldbufptr != PL_oldbufptr &&
      PL_oldbufptr != PL_bufptr) {
d11074 4
a11077 2
    else if (PL_oldbufptr && PL_bufptr > PL_oldbufptr &&
      PL_bufptr - PL_oldbufptr < 200 && PL_oldbufptr != PL_bufptr) {
d11094 3
a11096 3
    else if (yychar == -2) { /* YYEMPTY */
	if (PL_lex_state == LEX_NORMAL ||
	   (PL_lex_state == LEX_KNOWNEXT && PL_lex_defer == LEX_NORMAL))
d11132 1
a11153 1
    dVAR;
d11221 1
a11244 1
    dVAR;
a11411 1
    dVAR;
d11457 1
a11457 4
#ifdef EBCDIC
	    if (rev > 0x7FFFFFFF)
		 Perl_croak(aTHX_ "In EBCDIC the v-string components cannot exceed 2147483647");
#endif
d11544 1
a11544 1
If I<flags> includes C<PARSE_OPTIONAL> then the expression is optional,
d11576 1
a11576 1
If I<flags> includes C<PARSE_OPTIONAL> then the expression is optional,
d11608 1
a11608 1
If I<flags> includes C<PARSE_OPTIONAL> then the expression is optional,
d11641 2
a11642 2
signals a postfix expression-statement modifier.  If I<flags> includes
C<PARSE_OPTIONAL> then the expression is optional, otherwise it is
d11688 1
a11688 1
The I<flags> parameter is reserved for future use, and must always
d11726 1
a11726 1
The I<flags> parameter is reserved for future use, and must always
d11746 1
a11746 1
the code to be parsed.  If I<flags> includes C<PARSE_OPTIONAL> then the
d11830 1
a11830 1
The I<flags> parameter is reserved for future use, and must always
d11868 1
a11868 1
The I<flags> parameter is reserved for future use, and must always
a11919 1
    *d = 0;
d11960 3
a11962 2
			if (defexpr->op_type == OP_UNDEF &&
				!(defexpr->op_flags & OPf_KIDS)) {
d12001 10
a12010 4
			    newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
				newSVOP(OP_CONST, 0,
				    newSVpvs("Odd name/value argument "
					"for subroutine"))));
d12073 10
a12082 3
		    newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
			newSVOP(OP_CONST, 0,
			    newSVpvs("Too few arguments for subroutine"))))),
d12093 10
a12102 3
		    newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
			newSVOP(OP_CONST, 0,
			    newSVpvs("Too many arguments for subroutine"))))),
a12108 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.19
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d1304 1
a1304 1
#define LEX_NO_TERM  0x40000000
d1318 2
d1965 1
a1965 1
		(PL_sublex_info.sub_inwhat || PL_lex_state == LEX_FORMLINE ?
d2002 1
a2002 1
	s++;
a2799 1
	PL_sublex_info.sub_inwhat = 0;
d5201 2
a5202 1
	if (!PL_rsfp && (!PL_parser->filtered || s+1 < PL_bufend)) {
d6112 1
d6627 1
a6627 1
			    t++;
d10066 8
a10073 4
	for (; isWORDCHAR_lazy_if(s,UTF); s++) {
	    if (d < e)
		*d++ = *s;
	}
@


1.18
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d2271 1
d2273 2
a2274 2
	    s2 += 6, len -= 6;
	  if (keyword(s2, len, 0))
d4075 1
a4075 1
		    char *d = tmpbuf;
d4077 2
a4078 3
			*d++ = *s++;
		    *d = '\0';
		    if (keyword(tmpbuf, d - tmpbuf, 0))
@


1.17
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d140 1
a140 1
#define SPACE_OR_TAB(c) ((c)==' '||(c)=='\t')
a184 4
#ifdef ff_next
#undef ff_next
#endif

a188 3
#ifdef CLINE
#undef CLINE
#endif
d214 1
d246 1
d301 11
a311 3
	if (PL_parser->lex_shared->herelines)	       \
	    CopLINE(PL_curcop) += PL_parser->lex_shared->herelines, \
	    PL_parser->lex_shared->herelines = 0;		     \
d382 1
d434 1
d436 3
d485 1
d487 1
d562 2
a563 3
			"\t(Do you need to predeclare %"SVf"?)\n",
		    SVfARG(newSVpvn_flags(PL_oldoldbufptr, (STRLEN)(t - PL_oldoldbufptr),
                                   SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d568 2
a569 3
		    "\t(Missing operator before %"SVf"?)\n",
                    SVfARG(newSVpvn_flags(oldbp, (STRLEN)(s - oldbp),
                                    SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d595 1
a595 1
    else if (isCNTRL(PL_multi_close)) {
d738 1
a738 1
    parser->copline = NOLINE;
d762 1
a762 1
	sv_catpvs(parser->linestr, "\n;");
d764 1
a764 1
	parser->linestr = newSVpvs("\n;");
d772 5
a776 2
    parser->lex_flags = flags & (LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
				 |LEX_DONT_CLOSE_RSFP);
d872 1
a872 1
+ SvCUR(PL_parser-E<gt>linestr)>.  A NUL character (zero octet) is
d939 1
a939 1
at least I<len> octets (including terminating NUL).  Returns a
d1065 1
a1065 1
		    utf8n_to_uvuni((U8*)p, e-p, NULL, 0);
d1085 1
a1085 1
		    *bufptr++ = TWO_BYTE_UTF8_TO_UNI(*p, *(p+1));
d1388 4
d1453 1
a1453 1
	unichar = utf8n_to_uvuni((U8*)s, bufend-s, &retlen, UTF8_CHECK_ONLY);
d1459 1
a1459 1
	    utf8n_to_uvuni((U8*)s, bufend-s, NULL, 0);
d1528 1
d1535 1
d1537 1
a1537 1
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_NO_NEXT_CHUNK))
d1557 7
a1563 5
	    PL_parser->linestart = s;
	    if (s == bufend)
		need_incline = 1;
	    else
		incline(s);
d1568 1
d1576 2
a1577 1
	    COPLINE_INC_WITH_HERELINES;
d1579 1
a1579 1
	    CopLINE_dec(PL_curcop);
d1584 1
a1584 1
	    if (need_incline && PL_parser->rsfp) {
d1600 101
a1770 11
	SV *const temp_sv = CopFILESV(PL_curcop);
	const char *cf;
	STRLEN tmplen;

	if (temp_sv) {
	    cf = SvPVX(temp_sv);
	    tmplen = SvCUR(temp_sv);
	} else {
	    cf = NULL;
	    tmplen = 0;
	}
d1777 4
a1780 14
	    char smallbuf[128];
	    char *tmpbuf;
	    GV **gvp;
	    STRLEN tmplen2 = len;
	    if (tmplen + 2 <= sizeof smallbuf)
		tmpbuf = smallbuf;
	    else
		Newx(tmpbuf, tmplen + 2, char);
	    tmpbuf[0] = '_';
	    tmpbuf[1] = '<';
	    memcpy(tmpbuf + 2, cf, tmplen);
	    tmplen += 2;
	    gvp = (GV**)hv_fetch(PL_defstash, tmpbuf, tmplen, FALSE);
	    if (gvp) {
d1789 2
a1790 6
		if (tmpbuf2 != smallbuf || tmpbuf != smallbuf) {
		    /* Either they malloc'd it, or we malloc'd it,
		       so no prefix is present in ours.  */
		    tmpbuf2[0] = '_';
		    tmpbuf2[1] = '<';
		}
d1804 2
a1805 2
			GvHV(gv2) = MUTABLE_HV(SvREFCNT_inc(GvHV(*gvp)));
			GvAV(gv2) = MUTABLE_AV(SvREFCNT_inc(GvAV(*gvp)));
d1807 2
a1808 2
		    else if (GvAV(*gvp)) {
			AV * const av = GvAV(*gvp);
a1822 1
	    if (tmpbuf != smallbuf) Safefree(tmpbuf);
d1830 2
a1886 1
    const I32 bufptroff = PL_bufptr - SvPVX(PL_linestr);
a1891 1
    PL_bufptr = SvPVX(PL_linestr) + bufptroff;
d1917 7
a1923 1
	SV * const sv = newSV_type(SVt_PVMG);
d1925 1
a1925 1
	    sv_setsv(sv, orig_sv);
d1927 7
a1933 4
	    sv_setpvn(sv, buf, len);
	(void)SvIOK_on(sv);
	SvIV_set(sv, 0);
	av_store(av, (I32)CopLINE(PL_curcop), sv);
d1944 1
a1944 1
S_skipspace(pTHX_ char *s)
d1949 1
a1949 1
    PERL_ARGS_ASSERT_SKIPSPACE;
d1962 1
a1962 1
	lex_read_space(LEX_KEEP_PREVIOUS |
d2166 37
d2255 1
a2255 1
S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack, int allow_initial_tick)
d2266 1
a2266 2
	(allow_pack && *s == ':') ||
	(allow_initial_tick && *s == '\'') )
d2269 5
a2273 1
	if (check_keyword && keyword(PL_tokenbuf, len, 0))
d2275 1
a2409 4
#ifdef USE_LOCALE_NUMERIC
	    char *loc = savepv(setlocale(LC_NUMERIC, NULL));
	    setlocale(LC_NUMERIC, "C");
#endif
a2410 4
#ifdef USE_LOCALE_NUMERIC
	    setlocale(LC_NUMERIC, loc);
	    Safefree(loc);
#endif
a2509 1
    STRLEN len = 0;
d2514 4
a2517 1
    if (!SvLEN(sv))
d2519 2
a2520 5

    s = SvPV_force(sv, len);
    if (SvTYPE(sv) >= SVt_PVIV && SvIVX(sv) == -1)
	goto finish;
    send = s + len;
d2528 2
a2529 1
	pv = newSVpvn_flags(SvPVX_const(pv), len, SVs_TEMP | SvUTF8(sv));
d2585 1
a2585 1
    if (op_type == OP_CONST || op_type == OP_READLINE) {
a2597 11
	/* Allow <FH> // "foo" */
	if (op_type == OP_READLINE)
	    PL_expect = XTERMORDORDOR;
	return THING;
    }
    else if (op_type == OP_BACKTICK && PL_lex_op) {
	/* readpipe() vas overriden */
	cSVOPx(cLISTOPx(cUNOPx(PL_lex_op)->op_first)->op_first->op_sibling)->op_sv = tokeq(PL_lex_stuff);
	pl_yylval.opval = PL_lex_op;
	PL_lex_op = NULL;
	PL_lex_stuff = NULL;
d2629 1
d2633 1
a2633 1
    SAVEBOOL(PL_lex_dojoin);
d2644 8
a2651 1
    SAVECOPLINE(PL_curcop);
d2664 1
d2695 3
a2697 1
    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
d2741 2
a2742 1
    if (PL_lex_repl && (PL_lex_inwhat == OP_SUBST || PL_lex_inwhat == OP_TRANS)) {
d2767 6
d2776 1
d2792 2
d2827 1
a2827 1
        utf8n_to_uvuni(first_bad_char_loc,
d2853 2
a2854 2
    if (cvp && (cv = *cvp) && SvROK(cv) && ((rv = SvRV(cv)) != NULL)
        && SvTYPE(rv) == SVt_PVCV && ((stash = CvSTASH(rv)) != NULL))
d2857 2
a2858 1
        if strEQ(name, "_charnames") {
d2880 4
a2883 2
	    if (*s == ' ' && *(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
                Perl_warn(aTHX_ "A sequence of multiple spaces in a charnames alias definition is deprecated");
d2887 4
a2890 2
        if (*(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
            Perl_warn(aTHX_ "Trailing white-space in a charnames alias definition is deprecated");
d2903 1
a2903 1
            if (! isALPHAU(UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(*s, *(s+1))))) {
d2927 5
a2931 2
                if (*s == ' ' && *(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
                    Perl_warn(aTHX_ "A sequence of multiple spaces in a charnames alias definition is deprecated");
d2936 1
a2936 2
                if (! isCHARNAME_CONT(UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(*s,
                                                                    *(s+1)))))
d2956 4
a2959 2
        if (*(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
            Perl_warn(aTHX_ "Trailing white-space in a charnames alias definition is deprecated");
d2970 1
a2970 1
            utf8n_to_uvuni(first_bad_char_loc,
d3171 1
a3171 1
		    *c = (char)UTF_TO_NATIVE(0xff);
d3225 6
a3230 10
		    ((isLOWER(min) && isLOWER(max)) ||
		     (isUPPER(min) && isUPPER(max)))) {
		    if (isLOWER(min)) {
			for (i = min; i <= max; i++)
			    if (isLOWER(i))
				*d++ = NATIVE_TO_NEED(has_utf8,i);
		    } else {
			for (i = min; i <= max; i++)
			    if (isUPPER(i))
				*d++ = NATIVE_TO_NEED(has_utf8,i);
d3238 1
a3238 7
                            const U8 ch = (U8)NATIVE_TO_UTF(i);
                            if (UNI_IS_INVARIANT(ch))
                                *d++ = (U8)i;
                            else {
                                *d++ = (U8)UTF8_EIGHT_BIT_HI(ch);
                                *d++ = (U8)UTF8_EIGHT_BIT_LO(ch);
                            }
d3248 1
a3248 1
                        *d++ = (char)UTF_TO_NATIVE(0xff);
d3273 1
a3273 1
		    *d++ = (char)UTF_TO_NATIVE(0xff);	/* use illegal utf8 byte--see pmtrans */
d3316 1
a3316 1
		    *d++ = NATIVE_TO_NEED(has_utf8,*s++);
d3327 1
a3327 1
	else if (*s == '#' && PL_lex_inpat &&
d3329 2
a3330 15
	    while (s+1 < send && *s != '\n') {
                /* for maint-5.18, half-fix #-in-charclass bug:
                 *   *do* recognise codeblocks: /[#](?{})/
                 *   *don't* recognise interpolated vars: /[#$x]/
                 */
                if (in_charclass && !PL_lex_casemods && s+3 < send &&
		     s[0] == '(' &&
		     s[1] == '?' &&
		     (    s[2] == '{'
		      || (s[2] == '?' && s[3] == '{')))
                    break;
		*d++ = NATIVE_TO_NEED(has_utf8,*s++);
            }
            if (s+ 1 < send && *s != '\n')
                break; /* we stopped on (?{}), not EOL */
d3377 1
d3406 1
a3406 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\\');
d3435 1
a3435 1
		    uv = NATIVE_TO_UNI(grok_oct(s, &len, &flags, NULL));
d3487 2
a3488 3
		/* Here uv is the ordinal of the next character being added in
		 * unicode (converted from native). */
		if (!UNI_IS_INVARIANT(uv)) {
d3506 1
a3506 1
		        d = (char*)uvuni_to_utf8((U8*)d, uv);
a3538 10
		/* This section of code doesn't generally use the
		 * NATIVE_TO_NEED() macro to transform the input.  I (khw) did
		 * a close examination of this macro and determined it is a
		 * no-op except on utfebcdic variant characters.  Every
		 * character generated by this that would normally need to be
		 * enclosed by this macro is invariant, so the macro is not
		 * needed, and would complicate use of copy().  XXX There are
		 * other parts of this file where the macro is used
		 * inconsistently, but are saved by it being a no-op */

d3565 1
a3565 1
			yyerror("Missing right brace on \\N{} or unescaped left brace after \\N.");
d3626 1
a3626 1
			/* Add the string to the output */
d3628 1
a3628 1
			    *d++ = (char) uv;
d3630 3
a3632 1
			else d = (char*)uvuni_to_utf8((U8*)d, uv);
d3692 1
a3692 1
                                U32 uv = utf8n_to_uvuni((U8 *) str,
d3697 1
a3697 4
                                 * the boiler plate before it.  For all these,
                                 * we convert to native format so that
                                 * downstream code can continue to assume the
                                 * input is native */
d3700 2
a3701 2
                                            "\\N{U+%X",
                                            (unsigned int) UNI_TO_NATIVE(uv));
d3716 1
a3716 1
                                    U32 uv = utf8n_to_uvuni((U8 *) str,
d3722 3
a3724 3
                                            sizeof(hex_string),
                                            ".%X",
                                            (unsigned int) UNI_TO_NATIVE(uv));
d3780 1
a3780 1
		    *d++ = grok_bslash_c(*s++, has_utf8, 1);
d3789 1
a3789 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\b');
d3792 1
a3792 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\n');
d3795 1
a3795 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\r');
d3798 1
a3798 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\f');
d3801 1
a3801 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\t');
d3804 1
a3804 1
		*d++ = ASCII_TO_NEED(has_utf8,'\033');
d3807 1
a3807 1
		*d++ = ASCII_TO_NEED(has_utf8,'\007');
d3822 1
a3822 1
	if (! NATIVE_IS_INVARIANT((U8)(*s)) && (this_utf8 || has_utf8)) {
d3833 4
a3836 2
	    const UV nextuv   = (this_utf8) ? utf8n_to_uvchr((U8*)s, send - s, &len, 0) : (UV) ((U8) *s);
	    const STRLEN need = UNISKIP(NATIVE_TO_UNI(nextuv));
d3863 1
a3863 1
	    *d++ = NATIVE_TO_NEED(has_utf8,*s++);
d3894 6
a3899 1
    if (s > PL_bufptr) {
d3939 1
d3965 5
d4022 4
a4025 1
		    scan_ident(s, send, tmpbuf, sizeof tmpbuf, FALSE);
d4133 7
a4139 7
		const char *proto = CvPROTO(cv);
		if (proto) {
		    if (*proto == ';')
			proto++;
		    if (*proto == '*')
			return 0;
		}
a4140 5
    s = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
    /* start is the beginning of the possible filehandle/object,
     * and s is the end of it
     * tmpbuf is a copy of it
     */
d4157 7
d4327 1
a4327 8
    unsigned int correct_length
	= maxlen < 0 ?
#ifdef PERL_MICRO
	0x7FFFFFFF
#else
	INT_MAX
#endif
	: maxlen;
a4460 25
/*
 * S_readpipe_override
 * Check whether readpipe() is overridden, and generates the appropriate
 * optree, provided sublex_start() is called afterwards.
 */
STATIC void
S_readpipe_override(pTHX)
{
    GV **gvp;
    GV *gv_readpipe = gv_fetchpvs("readpipe", GV_NOTQUAL, SVt_PVCV);
    pl_yylval.ival = OP_BACKTICK;
    if ((gv_readpipe
		&& GvCVu(gv_readpipe) && GvIMPORTED_CV(gv_readpipe))
	    ||
	    ((gvp = (GV**)hv_fetchs(PL_globalstash, "readpipe", FALSE))
	     && (gv_readpipe = *gvp) && isGV_with_GP(gv_readpipe)
	     && GvCVu(gv_readpipe) && GvIMPORTED_CV(gv_readpipe)))
    {
	PL_lex_op = (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
	    op_append_elem(OP_LIST,
		newSVOP(OP_CONST, 0, &PL_sv_undef), /* value will be read later */
		newCVREF(0, newGVOP(OP_GV, 0, gv_readpipe))));
    }
}

d4662 1
a4662 1
	    s = force_word(s,WORD,FALSE,TRUE,FALSE);
d4667 1
a4667 1
	s = force_word(s,WORD,FALSE,TRUE,FALSE);
d4676 1
a4676 1
	  "ATTRTERM", "TERMBLOCK", "TERMORDORDOR"
d4690 14
a4748 3
#ifdef __SC__
#pragma segment Perl_yylex
#endif
d4757 1
d4779 2
a4780 3
#ifdef COMMENTARY
    case LEX_NORMAL:		/* Some compilers will produce faster */
    case LEX_INTERPNORMAL:	/* code if we comment these out. */
a4781 1
#endif
d5039 1
d5050 1
a5050 1
	    return REPORT(')');
d5156 2
d5161 1
d5177 1
a5177 1
        const char *c = UTF ? savepv(sv_uni_display(dsv, newSVpvn_flags(s,
d5180 1
a5180 1
                                            10, UNI_DISPLAY_ISPRINT))
d5187 4
a5190 6
        }	
        *s = '\0';
        sv_setpv(dsv, d);
        if (UTF)
            SvUTF8_on(dsv);
        Perl_croak(aTHX_  "Unrecognized character %s; marked by <-- HERE after %"SVf"<-- HERE near column %d", c, SVfARG(dsv), (int) len + 1);
d5239 1
d5319 1
a5319 1
		      *(U8*)s == 0xEF ||
d5631 11
a5641 7
/*		if (PL_madskills && PL_lex_formbrack) { */
		    d = s;
		    while (d < PL_bufend && *d != '\n')
			d++;
		    if (d < PL_bufend)
			d++;
		    else if (d > PL_bufend) /* Found by Ilya: feed random input to Perl. */
d5643 1
d5651 1
a5651 1
			sv_catpvn(PL_thiswhite, s, d - s);
a5652 4
		    s = d;
/*		}
		*s = '\0';
		PL_bufend = s; */
a5653 3
#else
	    *s = '\0';
	    PL_bufend = s;
d5670 1
a5670 1
		s = force_word(PL_bufptr,WORD,FALSE,FALSE,FALSE);
a5673 1
	    PL_last_uni = PL_oldbufptr;
d5712 1
d5741 14
d5756 1
a5756 1
		    s = force_word(s,METHOD,FALSE,TRUE,FALSE);
d5805 1
d5807 1
a5807 1
	    s = scan_ident(s, PL_bufend, PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
d5829 1
d5833 1
d5839 1
d5842 1
d5844 1
a5844 1
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1,
d5846 1
d5850 4
d5857 1
a5857 1

d5945 2
a5946 1
		    d = scan_str(d,TRUE,TRUE,FALSE, FALSE);
d6013 4
a6016 4
		const char tmp
		    = (PL_expect == XOPERATOR ? '=' : '{'); /*'}(' for vi */
		if (*s != ';' && *s != '}' && *s != tmp
		    && (tmp != '=' || *s != ')')) {
d6020 1
a6020 1
		    if (tmp == '=' && !attrs) {
d6088 1
d6131 1
a6131 1
		    s = force_word(s + minus, WORD, FALSE, TRUE, FALSE);
d6267 1
d6319 1
d6343 1
d6348 1
a6348 1
	s = scan_ident(s - 1, PL_bufend, PL_tokenbuf + 1,
d6578 7
d6588 1
a6588 1
	    s = scan_ident(s + 1, PL_bufend, PL_tokenbuf + 1,
d6600 1
a6600 1
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1,
d6654 2
a6655 3
						"You need to quote \"%"SVf"\"",
						  SVfARG(newSVpvn_flags(tmpbuf, len, 
                                                    SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d6718 1
d6720 2
a6721 1
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, FALSE);
d6734 1
a6734 14
		    const char *t = s + 1;
		    while (*t && (isWORDCHAR_lazy_if(t,UTF) || strchr(" \t$#+-'\"", *t)))
			t += UTF ? UTF8SKIP(t) : 1;
		    if (*t == '}' || *t == ']') {
			t++;
			PL_bufptr = PEEKSPACE(PL_bufptr); /* XXX can realloc */
       /* diag_listed_as: Scalar value @@%s[%s] better written as $%s[%s] */
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			    "Scalar value %"SVf" better written as $%"SVf,
			    SVfARG(newSVpvn_flags(PL_bufptr, (STRLEN)(t-PL_bufptr),
                                                SVs_TEMP | (UTF ? SVf_UTF8 : 0 ))),
                            SVfARG(newSVpvn_flags(PL_bufptr+1, (STRLEN)(t-PL_bufptr-1),
                                                SVs_TEMP | (UTF ? SVf_UTF8 : 0 ))));
		    }
d6850 4
a6853 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
a6861 2
	if (!s)
	    missingterm(NULL);
d6866 8
a6873 2
	s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
	DEBUG_T( { printbuf("### Saw string before %s\n", s); } );
d6892 2
d6897 1
a6897 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d6903 1
a6903 1
	readpipe_override();
d6908 2
a6909 1
	if (PL_lex_inwhat && isDIGIT(*s))
d7006 2
a7007 1
	if (!anydelim && *s == ':' && s[1] == ':' && strNE(PL_tokenbuf, "CORE"))
d7009 1
d7017 1
d7108 2
a7109 1
                                            UTF ? SVf_UTF8 : 0, SVt_PVCV)) &&
d7119 8
a7126 3
                                            UTF ? -(I32)len : (I32)len, FALSE)) &&
		    (gv = *gvp) && isGV_with_GP(gv) &&
		    GvCVu(gv) && GvIMPORTED_CV(gv))
d7149 1
a7149 1
		if (hgv && tmp != KEY_x && tmp != KEY_CORE)	/* never ambiguous */
d7157 15
d7210 2
a7211 3
			Perl_croak(aTHX_ "Bad name after %"SVf"%s",
                                        SVfARG(newSVpvn_flags(PL_tokenbuf, len,
                                            (UTF ? SVf_UTF8 : 0) | SVs_TEMP )),
d7238 2
a7239 3
		  	    "Bareword \"%"SVf"\" refers to nonexistent package",
			     SVfARG(newSVpvn_flags(PL_tokenbuf, len,
                                        (UTF ? SVf_UTF8 : 0) | SVs_TEMP)));
d7355 3
d7361 1
d7372 1
a7372 1
			if (*d == ')' && (sv = cv_const_sv(cv))) {
d7429 1
a7429 1
                        const SV *tmpsv = newSVpvn_flags( PL_tokenbuf, len ? len : strlen(PL_tokenbuf), (UTF ? SVf_UTF8 : 0) | SVs_TEMP );
d7431 3
a7433 2
				"Ambiguous use of -%"SVf" resolved as -&%"SVf"()",
				SVfARG(tmpsv), SVfARG(tmpsv));
d7436 1
a7436 1
		    if ((sv = cv_const_sv(cv))) {
d7441 8
a7448 2
			pl_yylval.opval->op_private = OPpCONST_FOLDED;
			pl_yylval.opval->op_flags |= OPf_SPECIAL;
d7468 1
d7605 3
d7610 2
d7618 2
a7619 1
		if ((lastchar == '*' || lastchar == '%' || lastchar == '&')) {
d7621 4
a7624 4
				     "Operator or semicolon missing before %c%"SVf,
				     lastchar, SVfARG(newSVpvn_flags(PL_tokenbuf,
                                                    strlen(PL_tokenbuf),
                                                    SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d7655 6
a7660 15
		const char *pname = "main";
		STRLEN plen = 4;
		U32 putf8 = 0;
		if (PL_tokenbuf[2] == 'D')
		{
		    HV * const stash =
			PL_curstash ? PL_curstash : PL_defstash;
		    pname = HvNAME_get(stash);
		    plen  = HvNAMELEN (stash);
		    if(HvNAMEUTF8(stash)) putf8 = SVf_UTF8;
		}
		gv = gv_fetchpvn_flags(
			Perl_form(aTHX_ "%*s::DATA", (int)plen, pname),
			plen+6, GV_ADD|putf8, SVt_PVIO
		);
a7708 1
			EXTEND(SP, 1);
d7759 2
a7760 2
	case KEY_CORE:
	    if (*s == ':' && s[1] == ':') {
d7774 2
a7775 3
		    Perl_croak(aTHX_ "CORE::%"SVf" is not a keyword",
                                    SVfARG(newSVpvn_flags(PL_tokenbuf, len,
                                                (UTF ? SVf_UTF8 : 0) | SVs_TEMP)));
a7783 1
	    goto just_a_word;
d7886 2
a7887 1
		if (len && !keyword(PL_tokenbuf + 1, len, 0)) {
d7928 1
a7928 1
	    s = force_word(s,WORD,TRUE,FALSE,FALSE);
d8015 1
d8017 1
a8017 2
		    p = scan_ident(p, PL_bufend,
			PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
d8061 1
a8061 1
	    s = force_word(s,WORD,TRUE,FALSE,FALSE);
d8154 1
a8154 1
	     orig_keyword==KEY_glob ? (orig_keyword=0, -OP_GLOB) : OP_GLOB,
d8187 1
a8187 1
	    s = force_word(s,WORD,TRUE,FALSE,FALSE);
d8295 1
a8295 1
	    s = force_word(s,WORD,TRUE,FALSE,FALSE);
a8330 2
		    SV *tmpsv = newSVpvn_flags(s, (STRLEN)(d-s),
                                                SVs_TEMP | (UTF ? SVf_UTF8 : 0));
d8332 2
a8333 2
			   "Precedence problem: open %"SVf" should be open(%"SVf")",
			    SVfARG(tmpsv), SVfARG(tmpsv));
d8377 1
a8377 1
	    s = force_word(s,WORD,FALSE,TRUE,FALSE);
d8387 1
a8387 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d8390 1
d8399 1
a8399 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d8402 1
d8450 1
a8450 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d8463 1
a8463 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d8466 1
a8466 1
	    readpipe_override();
d8482 1
a8482 1
		s = force_word(s,WORD,TRUE,TRUE,FALSE);
d8507 1
a8507 1
	    s = force_word(s,WORD,TRUE,FALSE,FALSE);
d8648 1
a8648 1
	    s = force_word(s,WORD,TRUE,TRUE,FALSE);
a8679 1
		SSize_t tboffset = 0;
d8683 3
a8711 2
		    /* remember buffer pos'n for later force_word */
		    tboffset = s - PL_oldbufptr;
d8717 3
a8765 1
                    PERL_UNUSED_VAR(tboffset);
d8767 7
a8773 3
		    if (have_name)
			(void) force_word(PL_oldbufptr + tboffset, WORD,
					  FALSE, TRUE, TRUE);
d8779 3
a8781 13
		if (*s == '(') {
		    char *p;
		    bool bad_proto = FALSE;
		    bool in_brackets = FALSE;
		    char greedy_proto = ' ';
		    bool proto_after_greedy_proto = FALSE;
		    bool must_be_last = FALSE;
		    bool underscore = FALSE;
		    bool seen_underscore = FALSE;
		    const bool warnillegalproto = ckWARN(WARN_ILLEGALPROTO);
                    STRLEN tmplen;

		    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d8784 1
a8784 58
		    /* strip spaces and check for bad characters */
		    d = SvPV(PL_lex_stuff, tmplen);
		    tmp = 0;
		    for (p = d; tmplen; tmplen--, ++p) {
			if (!isSPACE(*p)) {
                            d[tmp++] = *p;

			    if (warnillegalproto) {
				if (must_be_last)
				    proto_after_greedy_proto = TRUE;
				if (!strchr("$@@%*;[]&\\_+", *p) || *p == '\0') {
				    bad_proto = TRUE;
				}
				else {
				    if ( underscore ) {
					if ( !strchr(";@@%", *p) )
					    bad_proto = TRUE;
					underscore = FALSE;
				    }
				    if ( *p == '[' ) {
					in_brackets = TRUE;
				    }
				    else if ( *p == ']' ) {
					in_brackets = FALSE;
				    }
				    else if ( (*p == '@@' || *p == '%') &&
					 ( tmp < 2 || d[tmp-2] != '\\' ) &&
					 !in_brackets ) {
					must_be_last = TRUE;
					greedy_proto = *p;
				    }
				    else if ( *p == '_' ) {
					underscore = seen_underscore = TRUE;
				    }
				}
			    }
			}
		    }
                    d[tmp] = '\0';
		    if (proto_after_greedy_proto)
			Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
				    "Prototype after '%c' for %"SVf" : %s",
				    greedy_proto, SVfARG(PL_subname), d);
		    if (bad_proto) {
                        SV *dsv = newSVpvs_flags("", SVs_TEMP);
			Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
				    "Illegal character %sin prototype for %"SVf" : %s",
				    seen_underscore ? "after '_' " : "",
				    SVfARG(PL_subname),
                                    SvUTF8(PL_lex_stuff)
                                        ? sv_uni_display(dsv,
                                            newSVpvn_flags(d, tmp, SVs_TEMP | SVf_UTF8),
                                            tmp,
                                            UNI_DISPLAY_ISPRINT)
                                        : pv_pretty(dsv, d, tmp, 60, NULL, NULL,
                                            PERL_PV_ESCAPE_NONASCII));
                    }
                    SvCUR_set(PL_lex_stuff, tmp);
d8808 1
a8808 1
		else if (*s != '{' && key == KEY_sub) {
d8972 3
a8974 11
#ifdef EBCDIC
	{
	    char ctl_l[2];
	    ctl_l[0] = toCTRL('L');
	    ctl_l[1] = '\0';
	    gv_fetchpvn_flags(ctl_l, 1, GV_ADD|GV_NOTQUAL, SVt_PV);
	}
#else
	    /* Make sure $^L is defined */
	    gv_fetchpvs("\f", GV_ADD|GV_NOTQUAL, SVt_PV);
#endif
a8994 3
#ifdef __SC__
#pragma segment Main
#endif
d9044 3
a9046 1
            if (has_colon)
d9050 2
d9114 3
a9116 3
			"Possible unintended interpolation of %"SVf" in string",
			SVfARG(newSVpvn_flags(PL_tokenbuf, tokenbuf_len,
                                        SVs_TEMP | ( UTF ? SVf_UTF8 : 0 ))));
d9243 1
a9243 1
	    SPAGAIN;
d9404 1
a9404 1
S_scan_ident(pTHX_ char *s, const char *send, char *dest, STRLEN destlen, I32 ck_uni)
d9407 2
a9408 1
    char *bracket = NULL;
d9413 1
d9432 2
d9445 3
d9450 1
d9452 1
a9452 1
	bracket = s;
d9454 4
a9457 2
	while (s < send && SPACE_OR_TAB(*s))
	   s++;
d9460 18
a9477 6
#define VALID_LEN_ONE_IDENT(d, u)     (isPUNCT_A((U8)*(d))     \
                                        || isCNTRL_A((U8)*(d)) \
                                        || isDIGIT_A((U8)*(d)) \
                                        || (!(u) && !UTF8_IS_INVARIANT((U8)*(d))))
    if (s < send
        && (isIDFIRST_lazy_if(s, is_utf8) || VALID_LEN_ONE_IDENT(s, is_utf8)))
d9479 4
d9495 1
d9500 4
a9503 1
    else if (ck_uni && !bracket)
d9505 2
a9506 1
    if (bracket) {
d9508 3
d9514 4
a9517 2
	    while (s < send && SPACE_OR_TAB(*s))
		s++;
d9519 1
d9524 2
d9530 1
d9540 1
a9540 1
	else if (!isWORDCHAR(*d) && !isPRINT(*d) /* isCTRL(d) */
d9552 8
a9559 3
        while (s < send && SPACE_OR_TAB(*s))
	    s++;

d9575 2
d9580 1
d9585 5
a9589 1
	    s = bracket;		/* let the parser handle it */
d9683 1
d9711 1
a9711 1
                       TRUE /* look for escaped bracketed metas */ );
d9793 1
d9799 1
d9806 1
a9806 1
                 TRUE /* look for escaped bracketed metas */ );
d9811 1
a9811 2
    if (s[-1] == PL_multi_open)
	s--;
d9823 2
a9824 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d9886 6
d9911 1
d9917 1
a9917 1
    s = scan_str(start,!!PL_madskills,FALSE,FALSE, FALSE);
d9921 1
a9921 2
    if (s[-1] == PL_multi_open)
	s--;
d9932 1
a9932 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d10028 1
d10130 1
a10130 1
    PL_multi_start = CopLINE(PL_curcop) + 1;
d10156 1
a10156 1
	       fer ends with "\n;", so the while condition below will have
d10177 1
a10177 1
		++shared->herelines;
d10194 1
a10194 1
	shared->herelines++;
d10252 1
a10252 1
		    PL_multi_start + shared->herelines);
d10258 1
a10258 1
	CopLINE_set(PL_curcop, (line_t)PL_multi_start - 1);
d10260 2
a10261 1
	    lex_grow_linestr(SvCUR(PL_linestr) + 2);
d10263 2
d10270 1
a10270 1
	shared->herelines++;
d10300 1
a10300 1
    PL_multi_end = CopLINE(PL_curcop);
d10316 1
a10316 1
    CopLINE_set(PL_curcop, (line_t)PL_multi_start - 1);
d10385 1
a10385 1
	s = scan_str(start,!!PL_madskills,FALSE,FALSE, FALSE);
a10392 1
	GV **gvp;
d10402 1
a10402 6
	if ((gv_readline
		&& GvCVu(gv_readline) && GvIMPORTED_CV(gv_readline))
		||
		((gvp = (GV**)hv_fetchs(PL_globalstash, "readline", FALSE))
		 && (gv_readline = *gvp) && isGV_with_GP(gv_readline)
		&& GvCVu(gv_readline) && GvIMPORTED_CV(gv_readline)))
d10476 14
a10489 5
   takes: start position in buffer
	  keep_quoted preserve \ on the embedded delimiter(s)
	  keep_delims preserve the delimiters around the string
	  re_reparse  compiling a run-time /(?{})/:
			collapse // to /,  and skip encoding src
d10531 1
a10531 3
        bool deprecate_escaped_meta /* Should we issue a deprecation warning
                                       for certain paired metacharacters that
                                       appear escaped within it */
d10547 1
d10587 1
d10601 2
a10602 2
            || ! ckWARN_d(WARN_DEPRECATED)
            || PL_multi_open == '<'))
d10633 43
a10675 2
		const char * const ns = SvPVX_const(PL_linestr) + offset;
		char * const svlast = SvEND(sv) - 1;
d10796 6
a10801 5
                         * appearing in a quantifier or in things like '\p{'.
                         * They also aren't meta unless there is a matching
                         * closed, escaped char later on within the string.
                         * If 's' points to an open, set a flag; if to a close,
                         * test that flag, and raise a warning if it was set */
d10808 2
a10809 7
                                else if (regcurly(s,
                                                  TRUE /* Look for a closing
                                                          '\}' */)
                                         || (s - start > 2  /* Look for e.g.
                                                               '\x{' */
                                             && _generic_isCC(*(s-2), _CC_BACKSLASH_FOO_LBRACE_IS_META)))
                                {
d10812 17
d10941 2
d10958 1
d11324 1
d11328 1
d11456 10
a11521 3
#ifdef __SC__
#pragma segment Perl_yylex
#endif
d11620 4
a11623 1
        OutCopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
d11625 2
a11626 3
	Perl_sv_catpvf(aTHX_ msg, "near \"%"SVf"\"\n",
                            SVfARG(newSVpvn_flags(context, contlen,
                                        SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
a11652 3
#ifdef __SC__
#pragma segment Main
#endif
d11695 8
a11702 6
    case 0xEF:
	if (slen > 2 && s[1] == 0xBB && s[2] == 0xBF) {
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-8 script encoding (BOM)\n");
	    s += 3;                      /* UTF-8 */
	}
	break;
a11724 8
#ifdef EBCDIC
    case 0xDD:
        if (slen > 3 && s[1] == 0x73 && s[2] == 0x66 && s[3] == 0x73) {
            if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-8 script encoding (BOM)\n");
            s += 4;                      /* UTF-8 */
        }
        break;
#endif
d11969 1
a11969 1
	    if (!UNI_IS_INVARIANT(NATIVE_TO_UNI(rev)))
d12394 200
@


1.16
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a68 1
#define PL_pending_ident        (PL_parser->pending_ident)
d113 1
a113 6
/* This can't be done with embed.fnc, because struct yy_parser contains a
   member named pending_ident, which clashes with the generated #define  */
static int
S_pending_ident(pTHX);

static const char ident_too_long[] = "Identifier too long";
d145 3
d272 1
a272 1
#define UNI2(f,x) { \
d274 1
a274 1
	PL_expect = x; \
d283 2
a284 2
#define UNI(f)    UNI2(f,XTERM)
#define UNIDOR(f) UNI2(f,XTERMORDORDOR)
d290 1
a290 9
#define UNIBRACK(f) { \
	pl_yylval.ival = f; \
	PL_bufptr = s; \
	PL_last_uni = PL_oldbufptr; \
	if (*s == '(') \
	    return REPORT( (int)FUNC1 ); \
	s = PEEKSPACE(s); \
	return REPORT( (*s == '(') ? (int)FUNC1 : (int)UNIOP ); \
	}
d303 9
d320 1
a320 2
    TOKENTYPE_OPVAL,
    TOKENTYPE_GVVAL
d350 2
d361 1
a361 1
    { LABEL,		TOKENTYPE_OPVAL,	"LABEL" },
a369 1
    { MYSUB,		TOKENTYPE_NONE,		"MYSUB" },
d375 1
d385 1
d388 1
d429 1
a429 1
	else if ((char)rv > ' ' && (char)rv < '~')
a436 1
	case TOKENTYPE_GVVAL: /* doesn't appear to be used */
d547 1
a547 1
	    for (t = PL_oldoldbufptr; (isALNUM_lazy_if(t,UTF) || *t == ':');
d634 2
a635 2
    register const char *s = SvPVX_const(sv);
    register const char * const e = s + SvCUR(sv);
d643 1
a643 1
	    register char *d = s - 1;
d746 1
d754 1
a754 2
	if (!len || s[len-1] != ';')
	    sv_catpvs(parser->linestr, "\n;");
d787 2
d792 1
d797 31
d947 1
a947 1
    STRLEN linestart_pos, last_uni_pos, last_lop_pos;
d959 3
d963 1
d973 2
d1012 1
a1012 1
	    STRLEN highhalf = 0;
d1014 5
a1018 2
	    for (p = pv; p != e; p++)
		highhalf += !!(((U8)*p) & 0x80);
d1029 3
a1031 3
		if (c & 0x80) {
		    *bufptr++ = (char)(0xc0 | (c >> 6));
		    *bufptr++ = (char)(0x80 | (c & 0x3f));
d1043 1
a1043 1
		if (c >= 0xc4) {
d1046 1
a1046 2
		} else if (c >= 0xc2 && p+1 != e &&
			    (((U8)p[1]) & 0xc0) == 0x80) {
d1049 1
a1049 1
		} else if (c >= 0x80) {
d1066 5
a1070 7
	    for (p = pv; p != e; p++) {
		U8 c = (U8)*p;
		if (c & 0x80) {
		    *bufptr++ = (char)(((c & 0x3) << 6) | (p[1] & 0x3f));
		    p++;
		} else {
		    *bufptr++ = (char)c;
d1072 5
d1079 1
a1079 1
	    plain_copy:
d1210 1
a1210 1
	    CopLINE_inc(PL_curcop);
d1293 1
d1305 1
a1305 1
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_FAKE_EOF))
d1336 2
d1427 1
a1427 1
	if (!(head & 0x80))
d1429 2
a1430 2
	if (head & 0x40) {
	    len = PL_utf8skip[head];
d1487 1
a1487 1
	    CopLINE_inc(PL_curcop);
d1556 1
a1556 1
	    CopLINE_inc(PL_curcop);
d1599 7
a1605 1
    CopLINE_inc(PL_curcop);
d1738 1
a1738 1
S_skipspace0(pTHX_ register char *s)
d1759 1
a1759 1
S_skipspace1(pTHX_ register char *s)
d1786 1
a1786 1
S_skipspace2(pTHX_ register char *s, SV **svp)
d1839 1
a1839 1
S_skipspace(pTHX_ register char *s)
d1894 1
a1894 1
    while (isALNUM_lazy_if(s,UTF) || *s == '-')
d2113 1
a2113 1
S_force_word(pTHX_ register char *start, int token, int check_keyword, int allow_pack, int allow_initial_tick)
d2116 1
a2116 1
    register char *s;
d2162 1
a2162 1
S_force_ident(pTHX_ register const char *s, int kind)
d2168 2
a2169 2
    if (*s) {
	const STRLEN len = strlen(s);
d2192 8
d2369 3
a2371 3
    register char *s;
    register char *send;
    register char *d;
d2414 4
a2417 8
 * They assume that whoever calls them will be setting up a fake
 * join call, because each subthing puts a ',' after it.  This lets
 *   "lower \luPpEr"
 * become
 *  join($, , 'lower ', lcfirst( 'uPpEr', ) ,)
 *
 * (I'm not sure whether the spurious commas at the end of lcfirst's
 * arguments and join's arguments are created or not).
d2440 1
a2440 1
    register const I32 op_type = pl_yylval.ival;
d2501 1
d2508 1
d2513 1
d2527 9
d2538 1
d2540 1
d2547 1
d2550 1
a2550 1
    PL_lex_brackets = 0;
d2560 4
d2572 3
a2608 1
	SAVEFREESV(PL_linestr);
d2654 195
d2852 5
a2856 2
  Extracts a pattern, double-quoted string, or transliteration.  This
  is terrifying code.
d2864 1
a2864 1
  successfully parsed), will leave an OP for the substring scanned
d2869 12
a2880 4
    backslashes:
      constants: \N{NAME} only
      case and quoting: \U \Q \E
    stops on @@ and $, but not for $ as tail anchor
d2910 1
a2910 1
  \1 (backreferences) are turned into $1
d2942 1
a2942 1
    register char *send = PL_bufend;		/* end of the constant */
d2945 2
a2946 2
    register char *s = start;			/* start of the constant */
    register char *d = SvPVX(sv);		/* destination for copies */
d2949 1
d2957 1
d2971 2
a2972 1
    UV uv;
d2987 3
d3009 1
a3009 1
		    ) {
d3144 23
a3166 3
	/* skip for regexp comments /(?#comment)/ and code /(?{code})/,
	   except for the last char, which will be done separately. */
	else if (*s == '(' && PL_lex_inpat && s[1] == '?') {
d3171 3
a3173 2
	    else if (s[2] == '{' /* This should match regcomp.c */
		    || (s[2] == '?' && s[3] == '{'))
d3175 1
a3175 17
		I32 count = 1;
		char *regparse = s + (s[2] == '{' ? 3 : 4);
		char c;

		while (count && (c = *regparse)) {
		    if (c == '\\' && regparse[1])
			regparse++;
		    else if (c == '{')
			count++;
		    else if (c == '}')
			count--;
		    regparse++;
		}
		if (*regparse != ')')
		    regparse--;		/* Leave one char for continuation. */
		while (s < regparse)
		    *d++ = NATIVE_TO_NEED(has_utf8,*s++);
d3182 11
a3192 1
	    while (s+1 < send && *s != '\n')
d3194 3
d3199 4
d3207 1
a3207 1
	    if (isALNUM_lazy_if(s+1,UTF))
d3269 1
a3269 1
			|| regcurly(s + 1)))
d3286 1
a3286 1
		    if ((isALPHA(*s) || isDIGIT(*s)))
d3298 1
a3298 1
                    I32 flags = 0;
d3302 6
a3313 1
		    STRLEN len;
d3316 6
a3321 2
		    bool valid = grok_bslash_o(s, &uv, &len, &error, 1);
		    s += len;
d3331 2
a3332 6
		++s;
		if (*s == '{') {
		    char* const e = strchr(s, '}');
                    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES |
                      PERL_SCAN_DISALLOW_PREFIX;
		    STRLEN len;
d3334 8
a3341 3
                    ++s;
		    if (!e) {
			yyerror("Missing right brace on \\x{}");
a3343 11
                    len = e - s;
		    uv = NATIVE_TO_UNI(grok_hex(s, &len, &flags, NULL));
		    s = e + 1;
		}
		else {
		    {
			STRLEN len = 2;
                        I32 flags = PERL_SCAN_DISALLOW_PREFIX;
			uv = NATIVE_TO_UNI(grok_hex(s, &len, &flags, NULL));
			s += len;
		    }
a3447 25
		if (PL_lex_inpat) {

		    /* XXX This block is temporary code.  \N{} implies that the
		     * pattern is to have Unicode semantics, and therefore
		     * currently has to be encoded in utf8.  By putting it in
		     * utf8 now, we save a whole pass in the regular expression
		     * compiler.  Once that code is changed so Unicode
		     * semantics doesn't necessarily have to be in utf8, this
		     * block should be removed.  However, the code that parses
		     * the output of this would have to be changed to not
		     * necessarily expect utf8 */
		    if (!has_utf8) {
			SvCUR_set(sv, d - SvPVX_const(sv));
			SvPOK_on(sv);
			*d = '\0';
			/* See Note on sizing above.  */
			sv_utf8_upgrade_flags_grow(sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					/* 5 = '\N{' + cur char + NUL */
					(STRLEN)(send - s) + 5);
			d = SvPVX(sv) + SvCUR(sv);
			has_utf8 = TRUE;
		    }
		}

d3509 6
a3514 26
		else { /* Here is \N{NAME} but not \N{U+...}. */

		    SV *res;		/* result from charnames */
		    const char *str;    /* the string in 'res' */
		    STRLEN len;		/* its length */

		    /* Get the value for NAME */
		    res = newSVpvn(s, e - s);
		    res = new_constant( NULL, 0, "charnames",
					/* includes all of: \N{...} */
					res, NULL, s - 3, e - s + 4 );

		    /* Most likely res will be in utf8 already since the
		     * standard charnames uses pack U, but a custom translator
		     * can leave it otherwise, so make sure.  XXX This can be
		     * revisited to not have charnames use utf8 for characters
		     * that don't need it when regexes don't have to be in utf8
		     * for Unicode semantics.  If doing so, remember EBCDIC */
		    sv_utf8_upgrade(res);
		    str = SvPV_const(res, len);

		    /* Don't accept malformed input */
		    if (! is_utf8_string((U8 *) str, len)) {
			yyerror("Malformed UTF-8 returned by \\N");
		    }
		    else if (PL_lex_inpat) {
a3527 4
			    STRLEN char_length;	    /* cur char's byte length */
			    STRLEN output_length;   /* and the number of bytes
						       after this is translated
						       into hex digits */
d3530 26
a3555 19
			    /* 2 hex per byte; 2 chars for '\N'; 2 chars for
			     * max('U+', '.'); and 1 for NUL */
			    char hex_string[2 * UTF8_MAXBYTES + 5];

			    /* Get the first character of the result. */
			    U32 uv = utf8n_to_uvuni((U8 *) str,
						    len,
						    &char_length,
						    UTF8_ALLOW_ANYUV);

			    /* The call to is_utf8_string() above hopefully
			     * guarantees that there won't be an error.  But
			     * it's easy here to make sure.  The function just
			     * above warns and returns 0 if invalid utf8, but
			     * it can also return 0 if the input is validly a
			     * NUL. Disambiguate */
			    if (uv == 0 && NATIVE_TO_ASCII(*str) != '\0') {
				uv = UNICODE_REPLACEMENT;
			    }
d3557 53
a3609 41
			    /* Convert first code point to hex, including the
			     * boiler plate before it.  For all these, we
			     * convert to native format so that downstream code
			     * can continue to assume the input is native */
			    output_length =
				my_snprintf(hex_string, sizeof(hex_string),
					    "\\N{U+%X",
					    (unsigned int) UNI_TO_NATIVE(uv));

			    /* Make sure there is enough space to hold it */
			    d = off + SvGROW(sv, off
						 + output_length
						 + (STRLEN)(send - e)
						 + 2);	/* '}' + NUL */
			    /* And output it */
			    Copy(hex_string, d, output_length, char);
			    d += output_length;

			    /* For each subsequent character, append dot and
			     * its ordinal in hex */
			    while ((str += char_length) < str_end) {
				const STRLEN off = d - SvPVX_const(sv);
				U32 uv = utf8n_to_uvuni((U8 *) str,
							str_end - str,
							&char_length,
							UTF8_ALLOW_ANYUV);
				if (uv == 0 && NATIVE_TO_ASCII(*str) != '\0') {
				    uv = UNICODE_REPLACEMENT;
				}

				output_length =
				    my_snprintf(hex_string, sizeof(hex_string),
					    ".%X",
					    (unsigned int) UNI_TO_NATIVE(uv));

				d = off + SvGROW(sv, off
						     + output_length
						     + (STRLEN)(send - e)
						     + 2);	/* '}' +  NUL */
				Copy(hex_string, d, output_length, char);
				d += output_length;
d3642 1
a3644 60
		    /* Deprecate non-approved name syntax */
		    if (ckWARN_d(WARN_DEPRECATED)) {
			bool problematic = FALSE;
			char* i = s;

			/* For non-ut8 input, look to see that the first
			 * character is an alpha, then loop through the rest
			 * checking that each is a continuation */
			if (! this_utf8) {
			    if (! isALPHAU(*i)) problematic = TRUE;
			    else for (i = s + 1; i < e; i++) {
				if (isCHARNAME_CONT(*i)) continue;
				problematic = TRUE;
				break;
			    }
			}
			else {
			    /* Similarly for utf8.  For invariants can check
			     * directly.  We accept anything above the latin1
			     * range because it is immaterial to Perl if it is
			     * correct or not, and is expensive to check.  But
			     * it is fairly easy in the latin1 range to convert
			     * the variants into a single character and check
			     * those */
			    if (UTF8_IS_INVARIANT(*i)) {
				if (! isALPHAU(*i)) problematic = TRUE;
			    } else if (UTF8_IS_DOWNGRADEABLE_START(*i)) {
				if (! isALPHAU(UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(*i,
									    *(i+1)))))
				{
				    problematic = TRUE;
				}
			    }
			    if (! problematic) for (i = s + UTF8SKIP(s);
						    i < e;
						    i+= UTF8SKIP(i))
			    {
				if (UTF8_IS_INVARIANT(*i)) {
				    if (isCHARNAME_CONT(*i)) continue;
				} else if (! UTF8_IS_DOWNGRADEABLE_START(*i)) {
				    continue;
				} else if (isCHARNAME_CONT(
					    UNI_TO_NATIVE(
					    TWO_BYTE_UTF8_TO_UNI(*i, *(i+1)))))
				{
				    continue;
				}
				problematic = TRUE;
				break;
			    }
			}
			if (problematic) {
			    /* The e-i passed to the final %.*s makes sure that
			     * should the trailing NUL be missing that this
			     * print won't run off the end of the string */
			    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
					"Deprecated character in \\N{...}; marked by <-- HERE  in \\N{%.*s<-- HERE %.*s",
					(int)(i - s + 1), s, (int)(e - i), i + 1);
			}
		    }
d3770 4
a3773 1
	if ( PL_hints & ( PL_lex_inpat ? HINT_NEW_RE : HINT_NEW_STRING ) ) {
d3785 3
d3797 2
a3798 2
    } else
	SvREFCNT_dec(sv);
d3824 1
a3824 1
S_intuit_more(pTHX_ register char *s)
d3841 1
a3841 1
	if (regcurly(s)) {
d3854 1
a3854 1
	int weight = 2;		/* let's weigh the evidence */
a3855 1
	unsigned char un_char = 255, last_un_char;
d3857 1
d3862 1
a3863 1
	Zero(seen,256,char);
d3874 2
d3884 1
a3884 1
		if (isALNUM_lazy_if(s+1,UTF)) {
d3931 1
a3931 1
		if (!isALNUM(last_un_char)
d3966 1
a3966 1
 * Not a method if bar is a filehandle.
d3991 1
a3991 2
    if (gv) {
	if (SvTYPE(gv) == SVt_PVGV && GvIO(gv))
d3993 1
a3993 2
	if (cv) {
	    if (SvPOK(cv)) {
a4000 3
	    }
	} else
	    gv = NULL;
d4009 1
a4009 1
	if (gv || PL_last_lop_op == OP_PRINT || PL_last_lop_op == OP_SAY ||
d4036 1
a4036 1
	if (!gv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, UTF ? SVf_UTF8 : 0)) {
d4275 1
a4275 1
S_filter_gets(pTHX_ register SV *sv, STRLEN append)
a4369 4
    /* just do what yylex would do on pending identifier; leave PL_thiswhite alone */
    if (PL_lex_state != LEX_KNOWNEXT && PL_pending_ident)
        return S_pending_ident(aTHX);

a4455 1
    case LABEL:
d4470 4
d4542 1
d4589 1
a4589 1
    PRIVATEREF
d4592 31
a4622 12
      if read an identifier
          if we're in a my declaration
	      croak if they tried to say my($foo::bar)
	      build the ops for a my() declaration
	  if it's an access to a my() variable
	      are we in a sort block?
	          croak if my($a); $a <=> $b
	      build ops for access to a my() variable
	  if in a dq string, and they've said @@foo and we can't find @@foo
	      croak
	  build ops for a bareword
      if we already built the token before, use it.
d4633 2
a4634 2
    register char *s = PL_bufptr;
    register char *d;
d4637 1
a4655 5
    /* check if there's an identifier for us to look at */
    if (PL_lex_state != LEX_KNOWNEXT && PL_pending_ident)
        return REPORT(S_pending_ident(aTHX));

    /* no identifier pending identification */
d4715 1
a4715 6
#ifdef PERL_MAD
	    /* FIXME - can these be merged?  */
	    return next_type;
#else
	    return REPORT(next_type);
#endif
d4756 2
a4757 1
		if (!PL_thiswhite)
d4759 2
a4760 1
		sv_catpvn(PL_thiswhite, PL_bufptr, 2);
d4776 2
a4777 1
		if (!PL_thiswhite)
d4779 2
a4780 1
		sv_catpvn(PL_thiswhite, PL_bufptr, 4);
d4858 1
a4858 1
	DEBUG_T({ PerlIO_printf(Perl_debug_log,
d4861 4
a4864 1
	PL_lex_dojoin = (*PL_bufptr == '@@');
d4882 12
d4939 32
d4981 2
a4982 1
	if (SvIVX(PL_linestr) == '\'') {
d4984 1
a4984 4
	    if (!PL_lex_inpat)
		sv = tokeq(sv);
	    else if ( PL_hints & HINT_NEW_RE )
		sv = new_constant(NULL, 0, "qr", sv, sv, "q", 1);
a5025 1
	PL_lex_state = LEX_NORMAL;
d5028 2
d5031 3
a5033 1
	OPERATOR(';');
d5050 1
a5050 1
	if (isIDFIRST_lazy_if(s,UTF))
d5181 1
a5181 1
	    CopLINE_inc(PL_curcop);
a5424 1
	    PL_bufptr = s;
d5426 4
a5429 1
	    return yylex();
d5441 2
a5442 1
	if (!PL_thiswhite)
d5444 2
a5445 1
	sv_catpvn(PL_thiswhite, s, 1);
d5470 1
d5484 5
a5488 1
		incline(s);
a5490 1
		PL_bufptr = s;
d5492 4
a5495 1
		return yylex();
d5538 1
a5538 1
	if (s[1] && isALPHA(s[1]) && !isALNUM(s[2])) {
d5710 2
a5711 1
	PL_pending_ident = '%';
d5736 3
d5801 1
a5801 1
		    d = scan_str(d,TRUE,TRUE);
d5957 1
a5958 1
	s++;
d5964 1
a5964 8
	    if (PL_lex_formbrack) {
		s--;
		PRETERMBLOCK(DO);
	    }
	    if (PL_oldoldbufptr == PL_last_lop)
		PL_lex_brackstack[PL_lex_brackets++] = XTERM;
	    else
		PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d6046 1
a6046 1
			&& (!isALNUM(*t)
d6048 1
a6048 1
				&& !isALNUM(*t))))
d6087 1
a6087 1
			while (t < PL_bufend && isALNUM_lazy_if(t,UTF))
d6090 1
a6090 1
		else if (isALNUM_lazy_if(t,UTF)) {
d6092 1
a6092 1
		    while (t < PL_bufend && isALNUM_lazy_if(t,UTF))
d6114 1
a6114 1
	TOKEN('{');
a6124 2
	if (PL_lex_brackets < PL_lex_formbrack && PL_lex_state != LEX_INTERPNORMAL)
	    PL_lex_formbrack = 0;
d6140 4
a6143 1
		if (*s == '-' && s[1] == '>')
d6159 2
a6160 1
	force_next('}');
d6162 1
a6162 1
	if (!PL_thistoken)
d6165 5
d6198 4
a6201 2
	s = scan_ident(s - 1, PL_bufend, PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
	if (*PL_tokenbuf) {
d6203 1
a6203 1
	    force_ident(PL_tokenbuf, '&');
d6257 2
a6258 1
		    if (PL_in_eval && !PL_rsfp && !PL_parser->filtered) {
d6289 1
a6289 1
	if (PL_lex_brackets < PL_lex_formbrack) {
d6298 6
a6303 2
		s--;
		PL_expect = XBLOCK;
d6329 2
a6330 2
			 && !isALNUM(t[1])) ||
			(*t == 't' && t[1] == 'r' && !isALNUM(t[2])))
d6354 2
a6355 1
	    TERM(sublex_start());
d6439 1
a6439 1
	    PL_pending_ident = '#';
d6467 1
a6467 1
			while (isSPACE(*t) || isALNUM_lazy_if(t,UTF) || *t == '$')
d6557 1
a6557 1
	PL_pending_ident = '$';
d6578 1
a6578 1
		    while (*t && (isALNUM_lazy_if(t,UTF) || strchr(" \t$#+-'\"", *t)))
d6594 2
a6595 1
	PL_pending_ident = '@@';
d6646 1
a6646 1
	          || isALNUM_lazy_if(PL_last_uni+5,UTF)
a6663 1
	    PL_lex_formbrack = 0;
d6665 1
d6706 1
a6706 1
	s = scan_str(s,!!PL_madskills,FALSE);
d6721 1
a6721 1
	s = scan_str(s,!!PL_madskills,FALSE);
d6744 1
a6744 1
	s = scan_str(s,!!PL_madskills,FALSE);
d6771 8
d6780 1
a6780 1
	    else if (!isALPHA(*start) && (PL_expect == XTERM
d6829 1
d6831 4
d6836 1
d6838 3
d6843 1
d6903 3
a6905 3
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
                                            newSVpvn_flags(PL_tokenbuf,
                                                        len, UTF ? SVf_UTF8 : 0));
d6910 35
d7004 2
d7008 1
d7010 2
a7013 1
		SV *sv;
d7016 4
a7019 2
		OP *rv2cv_op;
		CV *cv;
d7051 2
a7052 1
		   unless name is "Foo::", in which case Foo is a bareword
d7070 1
a7070 1
		    if (!gv) {
d7084 2
a7085 1
		sv = S_newSV_maybe_utf8(aTHX_ PL_tokenbuf,
d7111 1
d7116 1
a7117 1
		cv = rv2cv_op_cv(rv2cv_op, 0);
d7204 2
a7205 1
		    NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
d7214 3
a7216 2
		    op_free(rv2cv_op);
		    force_next(WORD);
d7248 1
a7248 1
		    if (lastchar == '-') {
d7260 1
a7260 1
			pl_yylval.opval->op_private = 0;
d7266 2
a7267 1
		    pl_yylval.opval = rv2cv_op;
d7332 1
a7332 1
			force_next(WORD);
d7363 2
a7364 1
			pl_yylval.opval = rv2cv_op;
d7376 1
a7376 1
			force_next(WORD);
d7385 1
a7385 1
		    force_next(WORD);
d7577 2
a7579 1
		d = s;
d7581 9
a7589 1
		if (!(tmp = keyword(PL_tokenbuf, len, 1)))
d7700 12
a7711 2
	    if (*s != '\'')
		s = force_word(s,WORD,TRUE,TRUE,FALSE);
d7744 1
d7877 1
d7964 3
d8003 1
d8081 9
d8091 1
d8111 1
d8122 1
a8122 1
	    OPERATOR(USE);
d8137 3
a8139 9
		const char *t;
		for (d = s; isALNUM_lazy_if(d,UTF);) {
		    d += UTF ? UTF8SKIP(d) : 1;
                    if (UTF) {
                        while (UTF8_IS_CONTINUED(*d) && is_utf8_mark((U8*)d)) {
                            d += UTF ? UTF8SKIP(d) : 1;
                        }
                    }
                }
d8206 1
a8206 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d8217 1
a8217 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d8267 1
a8267 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d8280 1
a8280 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d8291 1
d8323 1
d8496 1
a8496 1
		char tmpbuf[sizeof PL_tokenbuf];
d8506 3
a8508 1
		SV *subtoken = newSVpvn_flags(tstart, s - tstart, SvUTF8(PL_linestr));
d8514 1
d8529 2
a8530 1
		    d = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
d8535 5
a8539 1
		    if (memchr(tmpbuf, ':', len))
d8550 1
a8551 1

d8555 1
a8555 2
		    (void) force_word(PL_oldbufptr + tboffset, WORD,
				      FALSE, TRUE, TRUE);
d8563 7
a8569 2
		    if (key == KEY_my)
			Perl_croak(aTHX_ "Missing name in \"my sub\"");
a8576 2
		    if (*s == '=')
			PL_lex_formbrack = PL_lex_brackets + 1;
d8580 1
d8586 1
a8586 1
		    OPERATOR(FORMAT);
d8602 1
a8602 1
		    s = scan_str(s,!!PL_madskills,FALSE);
d8703 1
d8720 1
a8720 2
		(void) force_word(PL_oldbufptr + tboffset, WORD,
				  FALSE, TRUE, TRUE);
a8721 2
		if (key == KEY_my)
		    TOKEN(MYSUB);
d8747 1
d8825 3
a8877 4

	case KEY_y:
	    s = scan_trans(s);
	    TERM(sublex_start());
d8885 20
a8908 1
    register char *d;
d8910 1
a8910 2
    /* pit holds the identifier we read and pending_ident is reset */
    char pit = PL_pending_ident;
a8913 1
    PL_pending_ident = 0;
a8914 1
    /* PL_realtokenstart = realtokenend = PL_bufptr - SvPVX(PL_linestr); */
d8941 1
a8941 1
            return PRIVATEREF;
a8946 8

       Deny my($a) or my($b) in a sort block, *if* $a or $b is
       then used in a comparison.  This catches most, but not
       all cases.  For instance, it catches
           sort { my($a); $a <=> $b }
       but not
           sort { my($a); $a < $b ? -1 : $a == $b ? 0 : 1; }
       (although why you'd do that is anyone's guess).
d8964 2
a8965 1
                gv_fetchsv(sym,
a8975 17
            /* if it's a sort block and they're naming $a or $b */
            if (PL_last_lop_op == OP_SORT &&
                PL_tokenbuf[0] == '$' &&
                (PL_tokenbuf[1] == 'a' || PL_tokenbuf[1] == 'b')
                && !PL_tokenbuf[2])
            {
                for (d = PL_in_eval ? PL_oldoldbufptr : PL_linestart;
                     d < PL_bufend && *d != '\n';
                     d++)
                {
                    if (strnEQ(d,"<=>",3) || strnEQ(d,"cmp",3)) {
                        Perl_croak(aTHX_ "Can't use \"my %s\" in sort comparison",
                              PL_tokenbuf);
                    }
                }
            }

d9006 2
a9007 1
    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpvn_flags(PL_tokenbuf + 1,
d9011 2
a9012 1
    gv_fetchpvn_flags(PL_tokenbuf+1, tokenbuf_len - 1,
d9058 1
a9058 1
	while (isALNUM_lazy_if(s,UTF))
d9075 3
a9077 1
/* Either returns sv, or mortalizes sv and returns a new SV*.
d9080 2
a9081 1
   and type is used with error messages only. */
d9090 1
d9096 3
d9101 3
a9103 1
    if (PL_error_count > 0 && strEQ(key,"charnames"))
d9105 1
d9107 1
d9113 1
a9113 1
	SV *msg;
d9117 1
a9117 1
	if (strEQ(key,"charnames")) {
d9139 4
a9142 2
	    msg = Perl_newSVpvf(aTHX_
			    "Constant(%s) unknown", (type ? type: "undef"));
d9145 18
a9162 10
	why1 = "$^H{";
	why2 = key;
	why3 = "} is not defined";
    report:
	msg = Perl_newSVpvf(aTHX_ "Constant(%s): %s%s%s",
			    (type ? type: "undef"), why1, why2, why3);
	}
	yyerror(SvPVX_const(msg));
 	SvREFCNT_dec(msg);
  	return sv;
a9164 1
    sv_2mortal(sv);			/* Parent created it permanently */
d9190 6
a9195 3
    if (!PL_in_eval && SvTRUE(ERRSV)) {
 	sv_catpvs(ERRSV, "Propagated");
	yyerror(SvPV_nolen_const(ERRSV)); /* Duplicates the message inside eval */
d9197 1
a9197 1
	res = SvREFCNT_inc_simple(sv);
d9201 1
a9201 1
	SvREFCNT_inc_simple_void(res);
d9214 1
d9221 48
d9273 1
a9273 1
S_scan_word(pTHX_ register char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
d9276 3
a9278 2
    register char *d = dest;
    register char * const e = d + destlen - 3;  /* two-character token, ending NUL */
d9282 4
a9285 32
    for (;;) {
	if (d >= e)
	    Perl_croak(aTHX_ ident_too_long);
	if (isALNUM(*s) || (!UTF && isALNUMC_L1(*s)))	/* UTF handled below */
	    *d++ = *s++;
	else if (allow_package && (*s == '\'') && isIDFIRST_lazy_if(s+1,UTF)) {
	    *d++ = ':';
	    *d++ = ':';
	    s++;
	}
	else if (allow_package && (s[0] == ':') && (s[1] == ':') && (s[2] != '$')) {
	    *d++ = *s++;
	    *d++ = *s++;
	}
	else if (UTF && UTF8_IS_START(*s) && isALNUM_utf8((U8*)s)) {
	    char *t = s + UTF8SKIP(s);
	    size_t len;
	    while (UTF8_IS_CONTINUED(*t) && is_utf8_mark((U8*)t))
		t += UTF8SKIP(t);
	    len = t - s;
	    if (d + len > e)
		Perl_croak(aTHX_ ident_too_long);
	    Copy(s, d, len, char);
	    d += len;
	    s = t;
	}
	else {
	    *d = '\0';
	    *slp = d - dest;
	    return s;
	}
    }
d9289 1
a9289 1
S_scan_ident(pTHX_ register char *s, register const char *send, char *dest, STRLEN destlen, I32 ck_uni)
d9294 3
a9296 2
    register char *d = dest;
    register char * const e = d + destlen - 3;    /* two-character token, ending NUL */
d9305 1
a9305 1
		Perl_croak(aTHX_ ident_too_long);
d9310 1
a9310 27
	for (;;) {
	    if (d >= e)
		Perl_croak(aTHX_ ident_too_long);
	    if (isALNUM(*s))	/* UTF handled below */
		*d++ = *s++;
	    else if (*s == '\'' && isIDFIRST_lazy_if(s+1,UTF)) {
		*d++ = ':';
		*d++ = ':';
		s++;
	    }
	    else if (*s == ':' && s[1] == ':') {
		*d++ = *s++;
		*d++ = *s++;
	    }
	    else if (UTF && UTF8_IS_START(*s) && isALNUM_utf8((U8*)s)) {
		char *t = s + UTF8SKIP(s);
		while (UTF8_IS_CONTINUED(*t) && is_utf8_mark((U8*)t))
		    t += UTF8SKIP(t);
		if (d + (t - s) > e)
		    Perl_croak(aTHX_ ident_too_long);
		Copy(s, d, t - s, char);
		d += t - s;
		s = t;
	    }
	    else
		break;
	}
d9320 5
a9324 1
	(isALNUM_lazy_if(s+1,UTF) || s[1] == '$' || s[1] == '{' || strnEQ(s+1,"::",2)) )
d9331 2
d9334 9
a9342 4
    else if (ck_uni)
	check_uni();
    if (s < send) {
        if (UTF) {
d9358 2
d9361 3
a9363 28
	if (isSPACE(s[-1])) {
	    while (s < send) {
		const char ch = *s++;
		if (!SPACE_OR_TAB(ch)) {
		    *d = ch;
		    break;
		}
	    }
	}
	if (isIDFIRST_lazy_if(d,UTF)) {
	    d += UTF8SKIP(d);
	    if (UTF) {
		char *end = s;
		while ((end < send && isALNUM_lazy_if(end,UTF)) || *end == ':') {
		    end += UTF8SKIP(end);
		    while (end < send && UTF8_IS_CONTINUED(*end) && is_utf8_mark((U8*)end))
			end += UTF8SKIP(end);
		}
		Copy(s, d, end - s, char);
		d += end - s;
		s = end;
	    }
	    else {
		while ((isALNUM(*s) || *s == ':') && d < e)
		    *d++ = *s++;
		if (d >= e)
		    Perl_croak(aTHX_ ident_too_long);
	    }
d9385 2
a9386 2
	else if (!isALNUM(*d) && !isPRINT(*d) /* isCTRL(d) */
		 && isALNUM(*s))
d9389 1
a9389 1
	    while (isALNUM(*s) && d < e) {
d9393 1
a9393 1
		Perl_croak(aTHX_ ident_too_long);
d9396 4
d9409 1
a9409 1
		     || get_cvn_flags(dest, d - dest, UTF ? SVf_UTF8 : 0)))
d9412 1
a9412 1
                                            SVs_TEMP | (UTF ? SVf_UTF8 : 0) );
d9437 6
a9442 6
     * TRUE if the input was a valid flag, so the next char may be as well;
     * otherwise FALSE. 'charset' should point to a NUL upon first call on the
     * current regex.  This routine will set it to any charset modifier found.
     * The caller shouldn't change it.  This way, another charset modifier
     * encountered in the parse can be detected as an error, as we have decided
     * allow only one */
d9445 1
d9447 8
a9454 3
    if (! strchr(valid_flags, c)) {
        if (isALNUM(c)) {
	    goto deprecate;
a9467 28

	    /* In 5.14, qr//lt is legal but deprecated; the 't' means they
	     * can't be regex modifiers.
	     * In 5.14, s///le is legal and ambiguous.  Try to disambiguate as
	     * much as easily done.  s///lei, for example, has to mean regex
	     * modifiers if it's not an error (as does any word character
	     * following the 'e').  Otherwise, we resolve to the backwards-
	     * compatible, but less likely 's/// le ...', i.e. as meaning
	     * less-than-or-equal.  The reason it's not likely is that s//
	     * returns a number for code in the field (/r returns a string, but
	     * that wasn't added until the 5.13 series), and so '<=' should be
	     * used for comparing, not 'le'. */
	    if (*((*s) + 1) == 't') {
		goto deprecate;
	    }
	    else if (*((*s) + 1) == 'e' && ! isALNUM(*((*s) + 2))) {

		/* 'e' is valid only for substitutes, s///e.  If it is not
		 * valid in the current context, then 'm//le' must mean the
		 * comparison operator, so use the regular deprecation message.
		 */
		if (! strchr(valid_flags, 'e')) {
		    goto deprecate;
		}
		Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
		    "Ambiguous use of 's//le...' resolved as 's// le...'; Rewrite as 's//el' if you meant 'use locale rules and evaluate rhs as an expression'.  In Perl 5.18, it will be resolved the other way");
		return FALSE;
	    }
a9474 5
	    /* In 5.14, qr//unless and qr//until are legal but deprecated; the
	     * 'n' means they can't be regex modifiers */
	    if (*((*s) + 1) == 'n') {
		goto deprecate;
	    }
a9481 6
	    /* In 5.14, qr//and is legal but deprecated; the 'n' means they
	     * can't be regex modifiers */
	    if (*((*s) + 1) == 'n') {
		goto deprecate;
	    }

a9510 5
    deprecate:
	Perl_ck_warner_d(aTHX_ packWARN(WARN_SYNTAX),
	    "Having no space between pattern and following word is deprecated");
        return FALSE;

d9532 1
a9532 1
    char *s = scan_str(start,!!PL_madskills,FALSE);
d9542 3
d9580 19
d9623 1
a9623 1
    register PMOP *pm;
d9635 2
a9636 1
    s = scan_str(start,!!PL_madskills,FALSE);
d9654 1
a9654 1
    s = scan_str(s,!!PL_madskills,FALSE);
a9700 2
	PL_sublex_info.super_bufptr = s;
	PL_sublex_info.super_bufend = PL_bufend;
d9710 1
a9710 3
	sv_catsv(repl, PL_lex_repl);
	if (strchr(SvPVX(PL_lex_repl), '#'))
	    sv_catpvs(repl, "\n");
d9713 2
a9714 2
	SvREFCNT_dec(PL_lex_repl);
	PL_lex_repl = repl;
d9726 1
a9726 1
    register char* s;
d9740 1
a9740 1
    s = scan_str(start,!!PL_madskills,FALSE);
d9756 1
a9756 1
    s = scan_str(s,!!PL_madskills,FALSE);
d9799 1
a9799 1
      (DO_UTF8(PL_lex_repl) ? OPpTRANS_TO_UTF   : 0);
d9816 24
d9841 1
a9841 1
S_scan_heredoc(pTHX_ register char *s)
a9843 1
    SV *herewas;
d9848 2
a9849 3
    const char *found_newline;
    register char *d;
    register char *e;
d9851 2
a9852 2
    const int outer = (PL_rsfp || PL_parser->filtered)
		   && !(PL_lex_inwhat == OP_SCALAR);
d9863 1
a9863 1
    d = PL_tokenbuf;
d9865 1
a9865 2
    if (!outer)
	*d++ = '\n';
d9873 2
d9876 1
a9876 2
	if (s < PL_bufend)
	    s++;
d9880 1
d9884 1
a9884 1
	if (!isALNUM_lazy_if(s,UTF))
d9886 1
a9886 1
	for (; isALNUM_lazy_if(s,UTF); s++) {
d9899 2
a9900 2
	tstart = PL_tokenbuf + !outer;
	PL_thisclose = newSVpvn(tstart, len - !outer);
a9930 14
    found_newline = 0;
#endif
    if ( outer || !(found_newline = (char*)memchr((void*)s, '\n', PL_bufend - s)) ) {
        herewas = newSVpvn(s,PL_bufend-s);
    }
    else {
#ifdef PERL_MAD
        herewas = newSVpvn(s-1,found_newline-s+1);
#else
        s--;
        herewas = newSVpvn(s,found_newline-s);
#endif
    }
#ifdef PERL_MAD
a9937 2
#endif
    s += SvCUR(herewas);
a9938 1
#ifdef PERL_MAD
a9939 3

    if (found_newline)
	s--;
d9953 1
a9953 2
    CLINE;
    PL_multi_start = CopLINE(PL_curcop);
d9955 38
a9992 18
    term = *PL_tokenbuf;
    if (PL_lex_inwhat == OP_SUBST && PL_in_eval && !PL_rsfp
     && !PL_parser->filtered) {
	char * const bufptr = PL_sublex_info.super_bufptr;
	char * const bufend = PL_sublex_info.super_bufend;
	char * const olds = s - SvCUR(herewas);
	s = strchr(bufptr, '\n');
	if (!s)
	    s = bufend;
	d = s;
	while (s < bufend &&
	  (*s != term || memNE(s,PL_tokenbuf,len)) ) {
	    if (*s++ == '\n')
		CopLINE_inc(PL_curcop);
	}
	if (s >= bufend) {
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
	    missingterm(PL_tokenbuf);
d9994 2
a9995 10
	sv_setpvn(herewas,bufptr,d-bufptr+1);
	sv_setpvn(tmpstr,d+1,s-d);
	s += len - 1;
	sv_catpvn(herewas,s,bufend-s);
	Copy(SvPVX_const(herewas),bufptr,SvCUR(herewas) + 1,char);

	s = olds;
	goto retval;
    }
    else if (!outer) {
d9997 2
a9998 2
	while (s < PL_bufend &&
	  (*s != term || memNE(s,PL_tokenbuf,len)) ) {
d10000 1
a10000 1
		CopLINE_inc(PL_curcop);
d10002 2
a10003 3
	if (s >= PL_bufend) {
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
	    missingterm(PL_tokenbuf);
d10016 6
a10021 1
	CopLINE_inc(PL_curcop);	/* the preceding stmt passes a newline */
d10023 28
a10050 5
	sv_catpvn(herewas,s,PL_bufend-s);
	sv_setsv(PL_linestr,herewas);
	PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = s = PL_linestart = SvPVX(PL_linestr);
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	PL_last_lop = PL_last_uni = NULL;
d10053 11
a10063 2
	sv_setpvs(tmpstr,"");   /* avoid "uninitialized" warning */
    while (s >= PL_bufend) {	/* multiple line string? */
d10073 12
a10084 5
	PL_bufptr = s;
	CopLINE_inc(PL_curcop);
	if (!outer || !lex_next_chunk(0)) {
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
	    missingterm(PL_tokenbuf);
a10085 1
	CopLINE_dec(PL_curcop);
d10090 1
a10090 2
	CopLINE_inc(PL_curcop);
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
d10107 4
a10110 5
	if (*s == term && memEQ(s,PL_tokenbuf,len)) {
	    STRLEN off = PL_bufend - 1 - SvPVX_const(PL_linestr);
	    *(SvPVX(PL_linestr) + off ) = ' ';
	    lex_grow_linestr(SvCUR(PL_linestr) + SvCUR(herewas) + 1);
	    sv_catsv(PL_linestr,herewas);
d10112 2
a10113 1
	    s = SvPVX(PL_linestr) + off; /* In case PV of PL_linestr moved. */
a10115 1
	    s = PL_bufend;
d10118 1
a10119 2
    s++;
retval:
a10123 1
    SvREFCNT_dec(herewas);
d10133 5
d10160 1
a10160 1
    register char *s = start;		/* current position in buffer */
d10194 1
a10194 1
    while (*d && (isALNUM_lazy_if(d,UTF) || *d == '\'' || *d == ':'))
d10205 1
a10205 1
	s = scan_str(start,!!PL_madskills,FALSE);
d10305 2
d10347 19
a10365 14
S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims)
{
    dVAR;
    SV *sv;				/* scalar value: string */
    const char *tmps;			/* temp string, used for delimiter matching */
    register char *s = start;		/* current position in the buffer */
    register char term;			/* terminating character */
    register char *to;			/* current position in the sv's data */
    I32 brackets = 1;			/* bracket nesting level */
    bool has_utf8 = FALSE;		/* is there any utf8 content? */
    I32 termcode;			/* terminating char. code */
    U8 termstr[UTF8_MAXBYTES];		/* terminating string */
    STRLEN termlen;			/* length of terminating string */
    int last_off = 0;			/* last position for nesting bracket */
d10412 12
d10437 1
a10437 1
    if (!PL_thisopen && !keep_delims) {
d10443 1
a10443 1
	if (PL_encoding && !UTF) {
d10455 1
a10455 1
			CopLINE_inc(PL_curcop);
d10522 1
a10522 1
		    CopLINE_inc(PL_curcop);
d10525 4
a10528 1
		    if (!keep_quoted && s[1] == term)
d10530 1
a10530 1
		/* any other quotes are simply copied straight through */
d10557 1
a10557 1
		    CopLINE_inc(PL_curcop);
d10562 1
d10564 36
d10653 1
a10653 1
	CopLINE_inc(PL_curcop);
d10668 1
a10668 1
    if (!PL_encoding || UTF) {
d10700 1
a10700 1
    if (has_utf8 || PL_encoding)
d10716 1
a10716 1
	PL_lex_repl = sv;
d10748 3
a10750 3
    register const char *s = start;	/* current position in buffer */
    register char *d;			/* destination in temp buffer */
    register char *e;			/* end of temp buffer */
d10755 1
a10755 1
    static char const number_too_long[] = "Number too long";
d10965 1
a10965 1
		    Perl_croak(aTHX_ number_too_long);
d10995 1
a10995 1
		    Perl_croak(aTHX_ number_too_long);
d11047 1
a11047 1
		        Perl_croak(aTHX_ number_too_long);
d11103 2
d11106 2
d11122 1
a11122 1
S_scan_formline(pTHX_ register char *s)
d11125 2
a11126 2
    register char *eol;
    register char *t;
d11157 2
a11158 3
	if (PL_in_eval && !PL_rsfp && !PL_parser->filtered) {
	    eol = (char *) memchr(s,'\n',PL_bufend-s);
	    if (!eol++)
a11159 3
	}
	else
	    eol = PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
d11184 2
a11185 1
	if (PL_rsfp || PL_parser->filtered) {
d11196 1
a11196 1
	    CopLINE_inc(PL_curcop);
d11209 2
d11212 1
a11212 1
	PL_expect = XTERM;
a11213 1
	    PL_lex_state = LEX_NORMAL;
d11216 1
a11216 1
	    force_next(',');
a11217 2
	else
	    PL_lex_state = LEX_FORMLINE;
a11226 3
	start_force(PL_curforce);
	NEXTVAL_NEXTTOKE.ival = OP_FORMLINE;
	force_next(LSTOP);
a11231 1
	PL_bufptr = s;
a11251 3
    if (PL_compcv) {
	assert(SvTYPE(PL_compcv) == SVt_PVCV);
    }
d11263 3
a11308 1
    U32 is_utf8 = flags & SVf_UTF8;
d11369 1
a11369 1
    msg = sv_2mortal(newSVpvn_flags(s, len, is_utf8));
d11390 2
a11391 1
	if (PL_in_eval && SvCUR(ERRSV))
d11393 1
a11393 1
		       SVfARG(ERRSV), OutCopFILE(PL_curcop));
d11657 1
a11657 1
	sv = newSV(5);
d11664 5
d12034 2
a12035 1
	    SV *lsv;
d12037 1
a12037 3
	    lsv = newSV_type(SVt_PV);
	    sv_copypv(lsv, cSVOPx(pl_yylval.opval)->op_sv);
	    return lsv;
a12153 17
void
Perl_munge_qwlist_to_paren_list(pTHX_ OP *qwlist)
{
    PERL_ARGS_ASSERT_MUNGE_QWLIST_TO_PAREN_LIST;
    deprecate("qw(...) as parentheses");
    force_next((4<<24)|')');
    if (qwlist->op_type == OP_STUB) {
	op_free(qwlist);
    }
    else {
	start_force(PL_curforce);
	NEXTVAL_NEXTTOKE.opval = qwlist;
	force_next(THING);
    }
    force_next((2<<24)|'(');
}

d12158 1
a12158 1
 * indent-tabs-mode: t
d12161 1
a12161 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.15
log
@merge in perl 5.12.2 plus local changes
@
text
@d42 1
a48 3
/* YYINITDEPTH -- initial size of the parser's stacks.  */
#define YYINITDEPTH 200

d51 2
d129 3
a131 2
#define XFAKEBRACK 128
#define XENUMMASK 127
d136 1
a136 1
#   define UTF ((PL_linestr && DO_UTF8(PL_linestr)) || (PL_hints & HINT_UTF8))
d227 1
d258 1
d288 4
d304 9
a312 1
#define OLDLOP(f) return(pl_yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LSTOP)
d355 1
d362 1
a362 1
    { LABEL,		TOKENTYPE_PVAL,		"LABEL" },
d540 1
a540 1
    yywarn(Perl_form(aTHX_ "%s found where operator expected", what));
d547 2
a548 1
	    for (t = PL_oldoldbufptr; (isALNUM_lazy_if(t,UTF) || *t == ':'); t++)
d552 3
a554 2
			"\t(Do you need to predeclare %.*s?)\n",
		    (int)(t - PL_oldoldbufptr), PL_oldoldbufptr);
d559 3
a561 1
		    "\t(Missing operator before %.*s?)\n", (int)(s - oldbp), oldbp);
d602 1
a602 5
#define FEATURE_IS_ENABLED(name)				        \
	((0 != (PL_hints & HINT_LOCALIZE_HH))				\
	    && S_feature_is_enabled(aTHX_ STR_WITH_LEN(name)))
/* The longest string we pass in.  */
#define MAX_FEATURE_LEN (sizeof("unicode_strings")-1)
a604 1
 * S_feature_is_enabled
d607 2
a608 2
STATIC bool
S_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen)
a610 1
    HV * const hinthv = GvHV(PL_hintgv);
d615 4
a618 1
    assert(namelen <= MAX_FEATURE_LEN);
d621 2
a622 1
    return (hinthv && hv_exists(hinthv, he_name, 8 + namelen));
d666 17
d684 2
d687 11
a697 13
/*
 * Perl_lex_start
 *
 * Create a parser object and initialise its parser and lexer fields
 *
 * rsfp       is the opened file handle to read from (if any),
 *
 * line       holds any initial content already read from the file (or in
 *            the case of no file, such as an eval, the whole contents);
 *
 * new_filter indicates that this is a new file and it shouldn't inherit
 *            the filters from the current parser (ie require).
 */
d700 1
a700 1
Perl_lex_start(pTHX_ SV *line, PerlIO *rsfp, bool new_filter)
a703 1
    STRLEN len;
d705 2
d714 3
a716 7
    Newx(parser->stack, YYINITDEPTH, yy_stack_frame);
    parser->ps = parser->stack;
    parser->stack_size = YYINITDEPTH;

    parser->stack->state = 0;
    parser->yyerrstatus = 0;
    parser->yychar = YYEMPTY;		/* Cause a token to be read.  */
d734 8
a741 2
    parser->rsfp_filters = (new_filter || !oparser) ? newAV()
		: MUTABLE_AV(SvREFCNT_inc(oparser->rsfp_filters));
d748 1
d750 5
a755 4
	len = 0;
    }

    if (!len) {
a756 8
    } else if (SvREADONLY(line) || s[len-1] != ';') {
	parser->linestr = newSVsv(line);
	if (s[len-1] != ';')
	    sv_catpvs(parser->linestr, "\n;");
    } else {
	SvTEMP_off(line);
	SvREFCNT_inc_simple_void_NN(line);
	parser->linestr = line;
d764 4
d781 1
a781 1
    if (parser->rsfp == PerlIO_stdin())
a787 1
    Safefree(parser->stack);
a795 13
 * Perl_lex_end
 * Finalizer for lexing operations.  Must be called when the parser is
 * done with the lexer.
 */

void
Perl_lex_end(pTHX)
{
    dVAR;
    PL_doextract = FALSE;
}

/*
d939 1
a939 1
=for apidoc Amx|void|lex_stuff_pvn|char *pv|STRLEN len|U32 flags
d954 1
a954 1
to be interpreted is available as a Perl scalar, the L</lex_stuff_sv>
d961 1
a961 1
Perl_lex_stuff_pvn(pTHX_ char *pv, STRLEN len, U32 flags)
d973 1
a973 1
	    char *p, *e = pv+len;
d997 1
a997 1
	    char *p, *e = pv+len;
d1046 29
d1087 1
a1087 1
being interpreted (L</lex_bufutf8>).  If a string to be interpreted is
d1183 1
a1183 1
and the lexing code has kept multiple lines of text in the buffer fof
d1285 1
a1285 1
    } else if (!PL_parser->rsfp) {
d1297 1
a1297 1
	if ((PerlIO*)PL_parser->rsfp == PerlIO_stdin())
d1302 1
a1302 1
	PL_doextract = FALSE;
d1440 4
a1443 1
	PL_parser->bufptr += UTF8SKIP(PL_parser->bufptr);
d1547 1
d1591 2
a1594 1
#ifndef USE_ITHREADS
d1607 1
a1607 1
	if (tmplen > 7 && strnEQ(cf, "(eval ", 6)) {
d1649 19
a1667 2
		    GvHV(gv2) = MUTABLE_HV(SvREFCNT_inc(GvHV(*gvp)));
		    GvAV(gv2) = MUTABLE_AV(SvREFCNT_inc(GvAV(*gvp)));
a1673 1
#endif
d1677 1
a1677 1
    CopLINE_set(PL_curcop, atoi(n)-1);
d1880 1
a1880 1
 	return REPORT(LSTOP);
d1883 1
a1883 1
	return REPORT(LSTOP);
d1890 4
a1893 1
    else
d1895 1
d2007 22
d2116 2
a2117 1
	OP* const o = (OP*)newSVOP(OP_CONST, 0, newSVpvn(s, len));
d2127 2
a2128 2
			      PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL)
			      : GV_ADD,
d2200 1
a2200 1
        if (*d == ';' || isSPACE(*d) || *d == '}' || !*d) {
d2203 2
a2204 1
	    char *loc = setlocale(LC_NUMERIC, "C");
d2209 1
d2271 3
a2273 1
    else if ( (*s != ';' && *s != '}' ) && (s = SKIPSPACE1(s), (*s != ';' && *s !='}' ))) {
d2322 2
a2323 1
    while (s < send && *s != '\\')
d2448 2
d2478 2
d2489 1
d2522 1
d2532 2
d2664 2
a2665 2
    I32  has_utf8 = FALSE;			/* Output constant is UTF8 */
    I32  this_utf8 = UTF;			/* Is the source string assumed
d2692 1
d2885 1
a2885 1
	  ((PMOP*)PL_lex_inpat)->op_pmflags & PMf_EXTENDED) {
d2925 2
a2926 1
	    /* deprecate \1 in strings and substitution replacements */
d2936 1
a2936 1
	    if (PL_lex_inwhat != OP_TRANS && *s && strchr("lLuUEQ", *s)) {
d2981 1
a2981 1
	    /* eg. \132 indicates the octal constant 0x132 */
d2992 15
d3099 3
a3101 3
		 * needed, and would complicate use of copy(). There are other
		 * parts of this file where the macro is used inconsistently,
		 * but are saved by it being a no-op */
d3144 3
a3146 1
		     * block should be removed */
d3179 6
a3184 3
			/* Pass through to the regex compiler unchanged.  The
			 * reason we evaluated the number above is to make sure
			 * there wasn't a syntax error. */
d3186 6
d3194 1
d3288 7
a3294 4
			     * boiler plate before it */
			    snprintf(hex_string, sizeof(hex_string),
				     "\\N{U+%X", (unsigned int) uv);
			    output_length = strlen(hex_string);
d3317 4
a3320 3
				snprintf(hex_string, sizeof(hex_string),
					".%X", (unsigned int) uv);
				output_length = strlen(hex_string);
d3389 1
a3389 1
				if (! isALPHAU(UNI_TO_NATIVE(UTF8_ACCUMULATE(*i,
d3405 1
a3405 1
					    UTF8_ACCUMULATE(*i, *(i+1)))))
d3414 3
a3416 4
			    char *string;
			    Newx(string, e - i + 1, char);
			    Copy(i, string, e - i, char);
			    string[e - i] = '\0';
d3418 2
a3419 3
				"Deprecated character(s) in \\N{...} starting at '%s'",
				string);
			    Safefree(string);
d3434 1
a3434 6
		    U8 c = *s++;
#ifdef EBCDIC
		    if (isLOWER(c))
			c = toUPPER(c);
#endif
		    *d++ = NATIVE_TO_NEED(has_utf8,toCTRL(c));
d3523 2
a3524 1
	Perl_croak(aTHX_ "panic: constant overflowed allocated space");
d3612 1
a3612 10
	s++;
	if (!isDIGIT(*s))
	    return TRUE;
	while (isDIGIT(*s))
	    s++;
	if (*s == ',')
	    s++;
	while (isDIGIT(*s))
	    s++;
	if (*s == '}')
d3614 1
a3615 1
	
d3657 2
a3658 1
		    if (len > 1 && gv_fetchpvn_flags(tmpbuf, len, 0, SVt_PV))
d3765 1
a3765 1
		const char *proto = SvPVX_const(cv);
d3806 1
a3806 1
	indirgv = gv_fetchpvn_flags(tmpbuf, len, 0, SVt_PVCV);
d3810 1
a3810 1
	if (!gv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, 0)) {
d3816 1
a3816 1
		return 0;	/* no assumptions -- "=>" quotes bearword */
d3823 2
a3824 1
		curmad('X', newSVpvn(start,SvPVX(PL_linestr) + soff - start));
d3864 3
d3879 39
a3939 2
	IoFLAGS(datasv) &= ~IOf_FAKE_DIRP;
	IoANY(datasv) = (void *)NULL;
d3960 1
a3960 1
    const unsigned int correct_length
d4012 25
d4085 1
a4085 1
        (gv = gv_fetchpvn_flags(pkgname, len, 0, SVt_PVHV)))
d4091 1
a4091 1
    gv = gv_fetchpvn_flags(pkgname, len, 0, SVt_PVCV);
d4098 1
a4098 1
    return gv_stashpvn(pkgname, len, 0);
d4103 1
a4103 1
 * Check whether readpipe() is overriden, and generates the appropriate
d4120 1
a4120 1
	    append_elem(OP_LIST,
d4145 1
a4145 1
    if (PL_pending_ident)
d4189 1
a4189 1
	if (optype == ';' && !PL_rsfp) {
d4234 1
a4294 4
    /* pval */
    case LABEL:
	break;

d4345 10
d4411 1
a4411 1
    if (PL_pending_ident)
d4454 20
d4475 2
a4476 2
	/* FIXME - can these be merged?  */
	return(PL_nexttoke[PL_lasttoke].next_type);
d4478 1
a4478 1
	return REPORT(PL_nexttype[PL_nexttoke]);
d4480 1
d4488 3
a4490 1
	    Perl_croak(aTHX_ "panic: INTERPCASEMOD");
d4500 2
a4501 1
		    && (oldmod == 'L' || oldmod == 'U' || oldmod == 'Q')) {
d4509 1
d4512 5
d4551 4
a4554 2
		if ((*s == 'L' || *s == 'U') &&
		    (strchr(PL_lex_casestack, 'L') || strchr(PL_lex_casestack, 'U'))) {
d4556 1
d4566 1
a4566 1
		force_next('(');
d4578 2
d4581 1
a4581 1
		    Perl_croak(aTHX_ "panic: yylex");
d4634 1
a4634 1
	    force_next('(');
d4674 1
d4688 2
a4689 1
	    Perl_croak(aTHX_ "panic: INTERPCONCAT");
d4765 6
a4770 1
        unsigned char c = *s;
d4778 4
a4781 1
        Perl_croak(aTHX_ "Unrecognized character \\x%02X; marked by <-- HERE after %s<-- HERE near column %d", c, d, (int) len + 1);
d4791 1
a4791 1
	if (!PL_rsfp) {
d4794 2
a4795 1
	    if (PL_lex_brackets) {
d4912 7
a4918 1
		bof = PerlIO_tell(PL_rsfp) == (Off_t)SvCUR(PL_linestr);
d4924 1
a4924 1
	    if (PL_doextract) {
d4935 1
a4935 1
		    PL_doextract = FALSE;
d4938 1
a4938 1
	    if (PL_rsfp)
d4940 1
a4940 1
	} while (PL_doextract);
d5164 4
a5167 2
	if (PL_lex_state != LEX_NORMAL || (PL_in_eval && !PL_rsfp)) {
	    if (*s == '#' && s == PL_linestart && PL_in_eval && !PL_rsfp) {
d5174 1
a5174 1
		if (!PL_in_eval || PL_rsfp)
d5184 2
a5185 1
		  Perl_croak(aTHX_ "panic: input overflow");
d5331 6
a5336 1
	    if (PL_expect == XOPERATOR)
d5338 1
d5356 6
a5361 1
	    if (PL_expect == XOPERATOR)
d5363 1
d5383 5
d5390 5
d5399 3
d5415 3
d5421 4
a5424 1
	PL_lex_brackets++;
d5433 2
d5438 2
d5441 4
a5444 4
	{
	    const char tmp = *s++;
	    OPERATOR(tmp);
	}
d5461 2
a5462 1
		deprecate(":= for an empty attribute list");
d5496 1
a5496 1
		sv = newSVpvn(s, len);
d5513 1
a5513 1
		    attrs = append_elem(OP_LIST, attrs,
d5553 1
a5553 1
		        attrs = append_elem(OP_LIST, attrs,
d5605 5
d5618 1
d5621 2
d5624 2
a5625 4
	{
	    const char tmp = *s++;
	    OPERATOR(tmp);
	}
d5627 8
a5634 7
	{
	    const char tmp = *s++;
	    s = SKIPSPACE1(s);
	    if (*s == '{')
		PREBLOCK(tmp);
	    TERM(tmp);
	}
d5636 2
d5643 1
d5669 1
d5698 1
d5704 1
d5713 1
d5820 2
d5828 1
d5870 6
a5875 1
	if (*s++ == '&')
d5877 1
d5887 5
d5907 6
a5912 1
	if (*s++ == '|')
d5914 1
d5916 5
d5926 6
a5931 1
	    if (tmp == '=')
d5933 7
a5939 1
	    if (tmp == '>')
d5941 1
d5952 1
a5952 1
		    if (PL_in_eval && !PL_rsfp) {
d5979 1
a5979 1
		    PL_doextract = TRUE;
d5997 4
d6024 5
d6049 6
a6054 1
	    if (tmp == '<')
d6056 1
d6059 6
a6064 1
		if (tmp == '>')
d6066 1
d6068 5
d6077 4
d6086 6
a6091 1
	    if (tmp == '>')
d6093 7
a6099 1
	    else if (tmp == '=')
d6101 1
d6104 4
d6119 1
a6119 1
	if (s[1] == '#' && (isIDFIRST_lazy_if(s+2,UTF) || strchr("{$:+-", s[2]))) {
a6142 8
	/* This kludge not intended to be bulletproof. */
	if (PL_tokenbuf[1] == '[' && !PL_tokenbuf[2]) {
	    pl_yylval.opval = newSVOP(OP_CONST, 0,
				   newSViv(CopARYBASE_get(&PL_compiling)));
	    pl_yylval.opval->op_private = OPpCONST_ARYBASE;
	    TERM(THING);
	}

d6184 2
a6185 1
				if (*t == ';' && get_cvn_flags(tmpbuf, len, 0))
d6187 3
a6189 2
						"You need to quote \"%s\"",
						tmpbuf);
d6268 1
a6268 1
			t++;
d6272 1
d6274 5
a6278 3
			    "Scalar value %.*s better written as $%.*s",
			    (int)(t-PL_bufptr), PL_bufptr,
			    (int)(t-PL_bufptr-1), PL_bufptr+1);
d6288 3
d6298 6
d6310 6
d6320 5
d6337 2
d6363 5
d6377 5
d6463 2
a6464 1
		GV *const gv = gv_fetchpvn_flags(s, start - s, 0, SVt_PVCV);
d6519 1
a6519 4
	anydelim = ((len == 1 && strchr("msyq", PL_tokenbuf[0])) ||
	       (len == 2 && ((PL_tokenbuf[0] == 't' && PL_tokenbuf[1] == 'r') ||
			     (PL_tokenbuf[0] == 'q' &&
			      strchr("qwxr", PL_tokenbuf[1])))));
d6545 1
a6545 1
	    result = CALL_FPTR(PL_keyword_plugin)(aTHX_ PL_tokenbuf, len, &o);
d6573 3
a6575 1
	    pl_yylval.pval = CopLABEL_alloc(PL_tokenbuf);
d6585 2
a6586 1
		if ((gv = gv_fetchpvn_flags(PL_tokenbuf, len, 0, SVt_PVCV)) &&
d6595 2
a6596 1
		    (gvp = (GV**)hv_fetch(PL_globalstash,PL_tokenbuf,len,FALSE)) &&
d6623 3
a6625 2
				   "Ambiguous call resolved as CORE::%s(), %s",
				   GvENAME(hgv), "qualify as such or use &");
d6661 3
a6663 1
			Perl_croak(aTHX_ "Bad name after %s%s", PL_tokenbuf,
d6680 1
a6680 1
		   unless name is "Foo::", in which case Foo is a bearword
d6687 1
a6687 1
			&& ! gv_fetchpvn_flags(PL_tokenbuf, len, 0, SVt_PVHV))
d6689 3
a6691 2
		  	    "Bareword \"%s\" refers to nonexistent package",
			     PL_tokenbuf);
d6704 2
a6705 1
					       GV_NOADD_NOINIT, SVt_PVCV);
d6712 2
d6715 1
d6717 2
a6718 7
		    sv_catpv(sv,PL_tokenbuf);
		}
		else {
		    /* If len is 0, newSVpv does strlen(), which is correct.
		       If len is non-zero, then it will be the true length,
		       and so the scalar will be created correctly.  */
		    sv = newSVpv(PL_tokenbuf,len);
d6720 1
a6729 1

a6732 4
		/* UTF-8 package name? */
		if (UTF && !IN_BYTES &&
		    is_utf8_string((U8*)SvPVX_const(sv), SvCUR(sv)))
		    SvUTF8_on(sv);
a6734 1

a6737 1
		cv = NULL;
d6739 1
a6739 1
		    OP *const_op = newSVOP(OP_CONST, 0, SvREFCNT_inc(sv));
d6743 1
a6743 17
		if (rv2cv_op->op_type == OP_RV2CV &&
			(rv2cv_op->op_flags & OPf_KIDS)) {
		    OP *rv_op = cUNOPx(rv2cv_op)->op_first;
		    switch (rv_op->op_type) {
			case OP_CONST: {
			    SV *sv = cSVOPx_sv(rv_op);
			    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV)
				cv = (CV*)SvRV(sv);
			} break;
			case OP_GV: {
			    GV *gv = cGVOPx_gv(rv_op);
			    CV *maybe_cv = GvCVu(gv);
			    if (maybe_cv && SvTYPE((SV*)maybe_cv) == SVt_PVCV)
				cv = maybe_cv;
			} break;
		    }
		}
d6768 3
d6851 3
d6863 3
d6872 6
a6877 4
		    if (lastchar == '-')
			Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
					 "Ambiguous use of -%s resolved as -&%s()",
					 PL_tokenbuf, PL_tokenbuf);
d6885 1
d6901 3
a6903 2
			STRLEN protolen;
			const char *proto = SvPV_const(MUTABLE_SV(cv), protolen);
d6906 2
a6907 3
			if ((*proto == '$' || *proto == '_') && proto[1] == '\0')
			    OPERATOR(UNIOPSUB);
			while (*proto == ';')
d6909 21
d6935 3
d6956 3
d6983 2
a6984 1
			gv = gv_fetchpv(PL_tokenbuf, GV_ADD, SVt_PVCV);
d6999 3
d7008 3
d7038 1
a7038 1
			    if (!*d && !gv_stashpv(PL_tokenbuf, 0))
d7049 4
a7052 2
				     "Operator or semicolon missing before %c%s",
				     lastchar, PL_tokenbuf);
d7061 3
a7063 3
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
					newSVpv(CopFILE(PL_curcop),0));
	    TERM(THING);
d7066 4
a7069 3
            pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
                                    Perl_newSVpvf(aTHX_ "%"IVdf, (IV)CopLINE(PL_curcop)));
	    TERM(THING);
d7072 2
a7073 1
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d7076 2
a7077 2
					 : &PL_sv_undef));
	    TERM(THING);
d7084 2
d7087 11
a7097 3
		    pname = HvNAME_get(PL_curstash ? PL_curstash : PL_defstash);
		gv = gv_fetchpv(Perl_form(aTHX_ "%s::DATA", pname), GV_ADD,
				SVt_PVIO);
a7130 6
#ifdef PERLIO_IS_STDIO /* really? */
#  if defined(__BORLANDC__)
			/* XXX see note in do_binmode() */
			((FILE*)PL_rsfp)->flags &= ~_F_BIN;
#  endif
#endif
d7181 3
d7202 4
a7205 2
		if (!(tmp = keyword(PL_tokenbuf, len, 0)))
		    Perl_croak(aTHX_ "CORE::%s is not a keyword", PL_tokenbuf);
d7208 2
a7209 1
		else if (tmp == KEY_require || tmp == KEY_do)
d7226 2
a7248 6
	    /* When 'use switch' is in effect, continue has a dual
	       life as a control operator. */
	    {
		if (!FEATURE_IS_ENABLED("switch"))
		    PREBLOCK(CONTINUE);
		else {
a7258 2
		}
	    }
d7272 2
d7334 7
a7340 1
	    gv_fetchpvs("AnyDBM_File::ISA", GV_ADDMULTI, SVt_PVAV);
d7358 2
d7381 4
d7417 2
d7453 3
d7466 2
d7471 2
d7568 4
a7571 1
	    LOP(OP_GLOB,XTERM);
d7577 2
d7618 2
d7623 2
d7684 1
a7684 1
		    yyerror(tmpbuf);
d7702 2
d7713 4
a7716 1
	    else
d7718 1
d7724 8
a7731 2
		for (d = s; isALNUM_lazy_if(d,UTF);)
		    d++;
d7737 2
d7740 2
a7741 1
		    int parms_len = (int)(d-s);
d7743 2
a7744 2
			   "Precedence problem: open %.*s should be open(%.*s)",
			    parms_len, s, parms_len, s);
d7750 2
d7791 1
d7807 2
a7808 1
	case KEY_qw:
a7812 1
	    force_next(')');
d7814 2
a7815 2
		OP *words = NULL;
		int warned = 0;
d7823 1
a7823 1
			if (!warned && ckWARN(WARN_QW)) {
d7825 1
a7825 1
				if (*d == ',') {
d7828 1
a7828 1
				    ++warned;
d7830 1
a7830 1
				else if (*d == '#') {
d7833 1
a7833 1
				    ++warned;
d7842 1
a7842 1
			words = append_elem(OP_LIST, words,
a7845 5
		if (words) {
		    start_force(PL_curforce);
		    NEXTVAL_NEXTTOKE.opval = words;
		    force_next(THING);
		}
d7847 2
d7853 4
a7856 2
	    PL_expect = XTERM;
	    TOKEN('(');
d7864 1
a7864 1
		SvIV_set(PL_lex_stuff, 0);	/* qq'$foo' should intepolate */
d7892 2
a7893 1
		    gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf), GV_ADD);
a8053 2
	    if (*s == ';' || *s == ')')		/* probably a close */
		Perl_croak(aTHX_ "sort is now a reserved word");
d8096 1
a8096 1
		SV *subtoken = newSVpvn(tstart, s - tstart);
d8119 1
a8119 1
			nametoke = newSVpvn(s, d - s);
d8128 2
d8179 1
d8185 1
a8185 1
		    d = SvPVX(PL_lex_stuff);
d8187 1
a8187 1
		    for (p = d; *p; ++p) {
d8189 1
a8189 1
			    d[tmp++] = *p;
d8194 1
a8194 1
				if (!strchr("$@@%*;[]&\\_", *p)) {
d8199 1
a8199 1
					if ( *p != ';' )
d8222 1
a8222 1
		    d[tmp] = '\0';
d8227 2
a8228 1
		    if (bad_proto)
d8232 10
a8241 2
				    SVfARG(PL_subname), d);
		    SvCUR_set(PL_lex_stuff, tmp);
d8362 2
d8368 2
d8402 2
d8408 2
d8441 4
a8444 1
	    if (PL_expect == XOPERATOR)
d8446 1
d8451 2
d8492 1
a8492 1
                yyerror(Perl_form(aTHX_ "No package name allowed for "
d8494 2
a8495 2
                                  PL_tokenbuf));
            tmp = allocmy(PL_tokenbuf, tokenbuf_len, 0);
d8499 3
a8501 2
                yyerror(Perl_form(aTHX_ PL_no_myglob,
			    PL_in_my == KEY_my ? "my" : "state", PL_tokenbuf));
d8504 2
a8505 1
            pl_yylval.opval->op_targ = allocmy(PL_tokenbuf, tokenbuf_len, 0);
d8524 2
a8525 1
	    tmp = pad_findmy(PL_tokenbuf, tokenbuf_len, 0);
d8534 1
a8534 1
                sv_catpvn(sym, PL_tokenbuf+1, tokenbuf_len - 1);
d8578 2
a8579 2
        GV *const gv = gv_fetchpvn_flags(PL_tokenbuf + 1, tokenbuf_len - 1, 0,
					 SVt_PVAV);
d8588 3
a8590 2
			"Possible unintended interpolation of %s in string",
			PL_tokenbuf);
d8595 3
a8597 2
    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpvn(PL_tokenbuf + 1,
						      tokenbuf_len - 1));
d8599 6
a8604 22
    gv_fetchpvn_flags(
	    PL_tokenbuf + 1, tokenbuf_len - 1,
	    /* If the identifier refers to a stash, don't autovivify it.
	     * Change 24660 had the side effect of causing symbol table
	     * hashes to always be defined, even if they were freshly
	     * created and the only reference in the entire program was
	     * the single statement with the defined %foo::bar:: test.
	     * It appears that all code in the wild doing this actually
	     * wants to know whether sub-packages have been loaded, so
	     * by avoiding auto-vivifying symbol tables, we ensure that
	     * defined %foo::bar:: continues to be false, and the existing
	     * tests still give the expected answers, even though what
	     * they're actually testing has now changed subtly.
	     */
	    (*PL_tokenbuf == '%'
	     && *(d = PL_tokenbuf + tokenbuf_len - 1) == ':'
	     && d[-1] == ':'
	     ? 0
	     : PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : GV_ADD),
	    ((PL_tokenbuf[0] == '$') ? SVt_PV
	     : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
	     : SVt_PVHV));
d8608 2
a8609 6
/*
 *  The following code was generated by perl_keyword.pl.
 */

I32
Perl_keyword (pTHX_ const char *name, I32 len, bool all_keywords)
d8613 1
a8613 1
    PERL_ARGS_ASSERT_KEYWORD;
d8615 7
a8621 3396
  switch (len)
  {
    case 1: /* 5 tokens of length 1 */
      switch (name[0])
      {
        case 'm':
          {                                       /* m          */
            return KEY_m;
          }

        case 'q':
          {                                       /* q          */
            return KEY_q;
          }

        case 's':
          {                                       /* s          */
            return KEY_s;
          }

        case 'x':
          {                                       /* x          */
            return -KEY_x;
          }

        case 'y':
          {                                       /* y          */
            return KEY_y;
          }

        default:
          goto unknown;
      }

    case 2: /* 18 tokens of length 2 */
      switch (name[0])
      {
        case 'd':
          if (name[1] == 'o')
          {                                       /* do         */
            return KEY_do;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'q')
          {                                       /* eq         */
            return -KEY_eq;
          }

          goto unknown;

        case 'g':
          switch (name[1])
          {
            case 'e':
              {                                   /* ge         */
                return -KEY_ge;
              }

            case 't':
              {                                   /* gt         */
                return -KEY_gt;
              }

            default:
              goto unknown;
          }

        case 'i':
          if (name[1] == 'f')
          {                                       /* if         */
            return KEY_if;
          }

          goto unknown;

        case 'l':
          switch (name[1])
          {
            case 'c':
              {                                   /* lc         */
                return -KEY_lc;
              }

            case 'e':
              {                                   /* le         */
                return -KEY_le;
              }

            case 't':
              {                                   /* lt         */
                return -KEY_lt;
              }

            default:
              goto unknown;
          }

        case 'm':
          if (name[1] == 'y')
          {                                       /* my         */
            return KEY_my;
          }

          goto unknown;

        case 'n':
          switch (name[1])
          {
            case 'e':
              {                                   /* ne         */
                return -KEY_ne;
              }

            case 'o':
              {                                   /* no         */
                return KEY_no;
              }

            default:
              goto unknown;
          }

        case 'o':
          if (name[1] == 'r')
          {                                       /* or         */
            return -KEY_or;
          }

          goto unknown;

        case 'q':
          switch (name[1])
          {
            case 'q':
              {                                   /* qq         */
                return KEY_qq;
              }

            case 'r':
              {                                   /* qr         */
                return KEY_qr;
              }

            case 'w':
              {                                   /* qw         */
                return KEY_qw;
              }

            case 'x':
              {                                   /* qx         */
                return KEY_qx;
              }

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'r')
          {                                       /* tr         */
            return KEY_tr;
          }

          goto unknown;

        case 'u':
          if (name[1] == 'c')
          {                                       /* uc         */
            return -KEY_uc;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 3: /* 29 tokens of length 3 */
      switch (name[0])
      {
        case 'E':
          if (name[1] == 'N' &&
              name[2] == 'D')
          {                                       /* END        */
            return KEY_END;
          }

          goto unknown;

        case 'a':
          switch (name[1])
          {
            case 'b':
              if (name[2] == 's')
              {                                   /* abs        */
                return -KEY_abs;
              }

              goto unknown;

            case 'n':
              if (name[2] == 'd')
              {                                   /* and        */
                return -KEY_and;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'c':
          switch (name[1])
          {
            case 'h':
              if (name[2] == 'r')
              {                                   /* chr        */
                return -KEY_chr;
              }

              goto unknown;

            case 'm':
              if (name[2] == 'p')
              {                                   /* cmp        */
                return -KEY_cmp;
              }

              goto unknown;

            case 'o':
              if (name[2] == 's')
              {                                   /* cos        */
                return -KEY_cos;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'd':
          if (name[1] == 'i' &&
              name[2] == 'e')
          {                                       /* die        */
            return -KEY_die;
          }

          goto unknown;

        case 'e':
          switch (name[1])
          {
            case 'o':
              if (name[2] == 'f')
              {                                   /* eof        */
                return -KEY_eof;
              }

              goto unknown;

            case 'x':
              if (name[2] == 'p')
              {                                   /* exp        */
                return -KEY_exp;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r')
          {                                       /* for        */
            return KEY_for;
          }

          goto unknown;

        case 'h':
          if (name[1] == 'e' &&
              name[2] == 'x')
          {                                       /* hex        */
            return -KEY_hex;
          }

          goto unknown;

        case 'i':
          if (name[1] == 'n' &&
              name[2] == 't')
          {                                       /* int        */
            return -KEY_int;
          }

          goto unknown;

        case 'l':
          if (name[1] == 'o' &&
              name[2] == 'g')
          {                                       /* log        */
            return -KEY_log;
          }

          goto unknown;

        case 'm':
          if (name[1] == 'a' &&
              name[2] == 'p')
          {                                       /* map        */
            return KEY_map;
          }

          goto unknown;

        case 'n':
          if (name[1] == 'o' &&
              name[2] == 't')
          {                                       /* not        */
            return -KEY_not;
          }

          goto unknown;

        case 'o':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 't')
              {                                   /* oct        */
                return -KEY_oct;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'd')
              {                                   /* ord        */
                return -KEY_ord;
              }

              goto unknown;

            case 'u':
              if (name[2] == 'r')
              {                                   /* our        */
                return KEY_our;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'p':
          if (name[1] == 'o')
          {
            switch (name[2])
            {
              case 'p':
                {                                 /* pop        */
                  return -KEY_pop;
                }

              case 's':
                {                                 /* pos        */
                  return KEY_pos;
                }

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e' &&
              name[2] == 'f')
          {                                       /* ref        */
            return -KEY_ref;
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'y')
              {                                   /* say        */
                return (all_keywords || FEATURE_IS_ENABLED("say") ? KEY_say : 0);
              }

              goto unknown;

            case 'i':
              if (name[2] == 'n')
              {                                   /* sin        */
                return -KEY_sin;
              }

              goto unknown;

            case 'u':
              if (name[2] == 'b')
              {                                   /* sub        */
                return KEY_sub;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'i' &&
              name[2] == 'e')
          {                                       /* tie        */
            return KEY_tie;
          }

          goto unknown;

        case 'u':
          if (name[1] == 's' &&
              name[2] == 'e')
          {                                       /* use        */
            return KEY_use;
          }

          goto unknown;

        case 'v':
          if (name[1] == 'e' &&
              name[2] == 'c')
          {                                       /* vec        */
            return -KEY_vec;
          }

          goto unknown;

        case 'x':
          if (name[1] == 'o' &&
              name[2] == 'r')
          {                                       /* xor        */
            return -KEY_xor;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 4: /* 41 tokens of length 4 */
      switch (name[0])
      {
        case 'C':
          if (name[1] == 'O' &&
              name[2] == 'R' &&
              name[3] == 'E')
          {                                       /* CORE       */
            return -KEY_CORE;
          }

          goto unknown;

        case 'I':
          if (name[1] == 'N' &&
              name[2] == 'I' &&
              name[3] == 'T')
          {                                       /* INIT       */
            return KEY_INIT;
          }

          goto unknown;

        case 'b':
          if (name[1] == 'i' &&
              name[2] == 'n' &&
              name[3] == 'd')
          {                                       /* bind       */
            return -KEY_bind;
          }

          goto unknown;

        case 'c':
          if (name[1] == 'h' &&
              name[2] == 'o' &&
              name[3] == 'p')
          {                                       /* chop       */
            return -KEY_chop;
          }

          goto unknown;

        case 'd':
          if (name[1] == 'u' &&
              name[2] == 'm' &&
              name[3] == 'p')
          {                                       /* dump       */
            return -KEY_dump;
          }

          goto unknown;

        case 'e':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'c' &&
                  name[3] == 'h')
              {                                   /* each       */
                return -KEY_each;
              }

              goto unknown;

            case 'l':
              if (name[2] == 's' &&
                  name[3] == 'e')
              {                                   /* else       */
                return KEY_else;
              }

              goto unknown;

            case 'v':
              if (name[2] == 'a' &&
                  name[3] == 'l')
              {                                   /* eval       */
                return KEY_eval;
              }

              goto unknown;

            case 'x':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'c')
                  {                               /* exec       */
                    return -KEY_exec;
                  }

                  goto unknown;

                case 'i':
                  if (name[3] == 't')
                  {                               /* exit       */
                    return -KEY_exit;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r' &&
              name[3] == 'k')
          {                                       /* fork       */
            return -KEY_fork;
          }

          goto unknown;

        case 'g':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 't' &&
                  name[3] == 'c')
              {                                   /* getc       */
                return -KEY_getc;
              }

              goto unknown;

            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 'b')
              {                                   /* glob       */
                return KEY_glob;
              }

              goto unknown;

            case 'o':
              if (name[2] == 't' &&
                  name[3] == 'o')
              {                                   /* goto       */
                return KEY_goto;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'e' &&
                  name[3] == 'p')
              {                                   /* grep       */
                return KEY_grep;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'j':
          if (name[1] == 'o' &&
              name[2] == 'i' &&
              name[3] == 'n')
          {                                       /* join       */
            return -KEY_join;
          }

          goto unknown;

        case 'k':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'y' &&
                  name[3] == 's')
              {                                   /* keys       */
                return -KEY_keys;
              }

              goto unknown;

            case 'i':
              if (name[2] == 'l' &&
                  name[3] == 'l')
              {                                   /* kill       */
                return -KEY_kill;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'l':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 's' &&
                  name[3] == 't')
              {                                   /* last       */
                return KEY_last;
              }

              goto unknown;

            case 'i':
              if (name[2] == 'n' &&
                  name[3] == 'k')
              {                                   /* link       */
                return -KEY_link;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'k')
              {                                   /* lock       */
                return -KEY_lock;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'n':
          if (name[1] == 'e' &&
              name[2] == 'x' &&
              name[3] == 't')
          {                                       /* next       */
            return KEY_next;
          }

          goto unknown;

        case 'o':
          if (name[1] == 'p' &&
              name[2] == 'e' &&
              name[3] == 'n')
          {                                       /* open       */
            return -KEY_open;
          }

          goto unknown;

        case 'p':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'c' &&
                  name[3] == 'k')
              {                                   /* pack       */
                return -KEY_pack;
              }

              goto unknown;

            case 'i':
              if (name[2] == 'p' &&
                  name[3] == 'e')
              {                                   /* pipe       */
                return -KEY_pipe;
              }

              goto unknown;

            case 'u':
              if (name[2] == 's' &&
                  name[3] == 'h')
              {                                   /* push       */
                return -KEY_push;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'r':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'n' &&
                  name[3] == 'd')
              {                                   /* rand       */
                return -KEY_rand;
              }

              goto unknown;

            case 'e':
              switch (name[2])
              {
                case 'a':
                  if (name[3] == 'd')
                  {                               /* read       */
                    return -KEY_read;
                  }

                  goto unknown;

                case 'c':
                  if (name[3] == 'v')
                  {                               /* recv       */
                    return -KEY_recv;
                  }

                  goto unknown;

                case 'd':
                  if (name[3] == 'o')
                  {                               /* redo       */
                    return KEY_redo;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 's':
          switch (name[1])
          {
            case 'e':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'k')
                  {                               /* seek       */
                    return -KEY_seek;
                  }

                  goto unknown;

                case 'n':
                  if (name[3] == 'd')
                  {                               /* send       */
                    return -KEY_send;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'o':
              if (name[2] == 'r' &&
                  name[3] == 't')
              {                                   /* sort       */
                return KEY_sort;
              }

              goto unknown;

            case 'q':
              if (name[2] == 'r' &&
                  name[3] == 't')
              {                                   /* sqrt       */
                return -KEY_sqrt;
              }

              goto unknown;

            case 't':
              if (name[2] == 'a' &&
                  name[3] == 't')
              {                                   /* stat       */
                return -KEY_stat;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'l' &&
                  name[3] == 'l')
              {                                   /* tell       */
                return -KEY_tell;
              }

              goto unknown;

            case 'i':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'd')
                  {                               /* tied       */
                    return KEY_tied;
                  }

                  goto unknown;

                case 'm':
                  if (name[3] == 'e')
                  {                               /* time       */
                    return -KEY_time;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 'w':
          switch (name[1])
          {
            case 'a':
              switch (name[2])
              {
                case 'i':
                  if (name[3] == 't')
                  {                               /* wait       */
                    return -KEY_wait;
                  }

                  goto unknown;

                case 'r':
                  if (name[3] == 'n')
                  {                               /* warn       */
                    return -KEY_warn;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'h':
              if (name[2] == 'e' &&
                  name[3] == 'n')
              {                                   /* when       */
                return (all_keywords || FEATURE_IS_ENABLED("switch") ? KEY_when : 0);
              }

              goto unknown;

            default:
              goto unknown;
          }

        default:
          goto unknown;
      }

    case 5: /* 39 tokens of length 5 */
      switch (name[0])
      {
        case 'B':
          if (name[1] == 'E' &&
              name[2] == 'G' &&
              name[3] == 'I' &&
              name[4] == 'N')
          {                                       /* BEGIN      */
            return KEY_BEGIN;
          }

          goto unknown;

        case 'C':
          if (name[1] == 'H' &&
              name[2] == 'E' &&
              name[3] == 'C' &&
              name[4] == 'K')
          {                                       /* CHECK      */
            return KEY_CHECK;
          }

          goto unknown;

        case 'a':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 'a' &&
                  name[3] == 'r' &&
                  name[4] == 'm')
              {                                   /* alarm      */
                return -KEY_alarm;
              }

              goto unknown;

            case 't':
              if (name[2] == 'a' &&
                  name[3] == 'n' &&
                  name[4] == '2')
              {                                   /* atan2      */
                return -KEY_atan2;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'b':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 'e' &&
                  name[3] == 's' &&
                  name[4] == 's')
              {                                   /* bless      */
                return -KEY_bless;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'e' &&
                  name[3] == 'a' &&
                  name[4] == 'k')
              {                                   /* break      */
                return (all_keywords || FEATURE_IS_ENABLED("switch") ? -KEY_break : 0);
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'c':
          switch (name[1])
          {
            case 'h':
              switch (name[2])
              {
                case 'd':
                  if (name[3] == 'i' &&
                      name[4] == 'r')
                  {                               /* chdir      */
                    return -KEY_chdir;
                  }

                  goto unknown;

                case 'm':
                  if (name[3] == 'o' &&
                      name[4] == 'd')
                  {                               /* chmod      */
                    return -KEY_chmod;
                  }

                  goto unknown;

                case 'o':
                  switch (name[3])
                  {
                    case 'm':
                      if (name[4] == 'p')
                      {                           /* chomp      */
                        return -KEY_chomp;
                      }

                      goto unknown;

                    case 'w':
                      if (name[4] == 'n')
                      {                           /* chown      */
                        return -KEY_chown;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }

                default:
                  goto unknown;
              }

            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 's' &&
                  name[4] == 'e')
              {                                   /* close      */
                return -KEY_close;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'y' &&
                  name[3] == 'p' &&
                  name[4] == 't')
              {                                   /* crypt      */
                return -KEY_crypt;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'e':
          if (name[1] == 'l' &&
              name[2] == 's' &&
              name[3] == 'i' &&
              name[4] == 'f')
          {                                       /* elsif      */
            return KEY_elsif;
          }

          goto unknown;

        case 'f':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 'n' &&
                  name[3] == 't' &&
                  name[4] == 'l')
              {                                   /* fcntl      */
                return -KEY_fcntl;
              }

              goto unknown;

            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 'c' &&
                  name[4] == 'k')
              {                                   /* flock      */
                return -KEY_flock;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'g':
          if (name[1] == 'i' &&
              name[2] == 'v' &&
              name[3] == 'e' &&
              name[4] == 'n')
          {                                       /* given      */
            return (all_keywords || FEATURE_IS_ENABLED("switch") ? KEY_given : 0);
          }

          goto unknown;

        case 'i':
          switch (name[1])
          {
            case 'n':
              if (name[2] == 'd' &&
                  name[3] == 'e' &&
                  name[4] == 'x')
              {                                   /* index      */
                return -KEY_index;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 't' &&
                  name[4] == 'l')
              {                                   /* ioctl      */
                return -KEY_ioctl;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'l':
          switch (name[1])
          {
            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'a' &&
                  name[4] == 'l')
              {                                   /* local      */
                return KEY_local;
              }

              goto unknown;

            case 's':
              if (name[2] == 't' &&
                  name[3] == 'a' &&
                  name[4] == 't')
              {                                   /* lstat      */
                return -KEY_lstat;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'm':
          if (name[1] == 'k' &&
              name[2] == 'd' &&
              name[3] == 'i' &&
              name[4] == 'r')
          {                                       /* mkdir      */
            return -KEY_mkdir;
          }

          goto unknown;

        case 'p':
          if (name[1] == 'r' &&
              name[2] == 'i' &&
              name[3] == 'n' &&
              name[4] == 't')
          {                                       /* print      */
            return KEY_print;
          }

          goto unknown;

        case 'r':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 's' &&
                  name[3] == 'e' &&
                  name[4] == 't')
              {                                   /* reset      */
                return -KEY_reset;
              }

              goto unknown;

            case 'm':
              if (name[2] == 'd' &&
                  name[3] == 'i' &&
                  name[4] == 'r')
              {                                   /* rmdir      */
                return -KEY_rmdir;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 's':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'm' &&
                  name[3] == 'o' &&
                  name[4] == 'p')
              {                                   /* semop      */
                return -KEY_semop;
              }

              goto unknown;

            case 'h':
              if (name[2] == 'i' &&
                  name[3] == 'f' &&
                  name[4] == 't')
              {                                   /* shift      */
                return -KEY_shift;
              }

              goto unknown;

            case 'l':
              if (name[2] == 'e' &&
                  name[3] == 'e' &&
                  name[4] == 'p')
              {                                   /* sleep      */
                return -KEY_sleep;
              }

              goto unknown;

            case 'p':
              if (name[2] == 'l' &&
                  name[3] == 'i' &&
                  name[4] == 't')
              {                                   /* split      */
                return KEY_split;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'a' &&
                  name[3] == 'n' &&
                  name[4] == 'd')
              {                                   /* srand      */
                return -KEY_srand;
              }

              goto unknown;

            case 't':
              switch (name[2])
              {
                case 'a':
                  if (name[3] == 't' &&
                      name[4] == 'e')
                  {                               /* state      */
                    return (all_keywords || FEATURE_IS_ENABLED("state") ? KEY_state : 0);
                  }

                  goto unknown;

                case 'u':
                  if (name[3] == 'd' &&
                      name[4] == 'y')
                  {                               /* study      */
                    return KEY_study;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'i' &&
              name[2] == 'm' &&
              name[3] == 'e' &&
              name[4] == 's')
          {                                       /* times      */
            return -KEY_times;
          }

          goto unknown;

        case 'u':
          switch (name[1])
          {
            case 'm':
              if (name[2] == 'a' &&
                  name[3] == 's' &&
                  name[4] == 'k')
              {                                   /* umask      */
                return -KEY_umask;
              }

              goto unknown;

            case 'n':
              switch (name[2])
              {
                case 'd':
                  if (name[3] == 'e' &&
                      name[4] == 'f')
                  {                               /* undef      */
                    return KEY_undef;
                  }

                  goto unknown;

                case 't':
                  if (name[3] == 'i')
                  {
                    switch (name[4])
                    {
                      case 'e':
                        {                         /* untie      */
                          return KEY_untie;
                        }

                      case 'l':
                        {                         /* until      */
                          return KEY_until;
                        }

                      default:
                        goto unknown;
                    }
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 't':
              if (name[2] == 'i' &&
                  name[3] == 'm' &&
                  name[4] == 'e')
              {                                   /* utime      */
                return -KEY_utime;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'w':
          switch (name[1])
          {
            case 'h':
              if (name[2] == 'i' &&
                  name[3] == 'l' &&
                  name[4] == 'e')
              {                                   /* while      */
                return KEY_while;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'i' &&
                  name[3] == 't' &&
                  name[4] == 'e')
              {                                   /* write      */
                return -KEY_write;
              }

              goto unknown;

            default:
              goto unknown;
          }

        default:
          goto unknown;
      }

    case 6: /* 33 tokens of length 6 */
      switch (name[0])
      {
        case 'a':
          if (name[1] == 'c' &&
              name[2] == 'c' &&
              name[3] == 'e' &&
              name[4] == 'p' &&
              name[5] == 't')
          {                                       /* accept     */
            return -KEY_accept;
          }

          goto unknown;

        case 'c':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'l' &&
                  name[3] == 'l' &&
                  name[4] == 'e' &&
                  name[5] == 'r')
              {                                   /* caller     */
                return -KEY_caller;
              }

              goto unknown;

            case 'h':
              if (name[2] == 'r' &&
                  name[3] == 'o' &&
                  name[4] == 'o' &&
                  name[5] == 't')
              {                                   /* chroot     */
                return -KEY_chroot;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'd':
          if (name[1] == 'e' &&
              name[2] == 'l' &&
              name[3] == 'e' &&
              name[4] == 't' &&
              name[5] == 'e')
          {                                       /* delete     */
            return KEY_delete;
          }

          goto unknown;

        case 'e':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 's' &&
                  name[3] == 'e' &&
                  name[4] == 'i' &&
                  name[5] == 'f')
              {                                   /* elseif     */
                  Perl_ck_warner_d(aTHX_ packWARN(WARN_SYNTAX), "elseif should be elsif");
              }

              goto unknown;

            case 'x':
              if (name[2] == 'i' &&
                  name[3] == 's' &&
                  name[4] == 't' &&
                  name[5] == 's')
              {                                   /* exists     */
                return KEY_exists;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'f':
          switch (name[1])
          {
            case 'i':
              if (name[2] == 'l' &&
                  name[3] == 'e' &&
                  name[4] == 'n' &&
                  name[5] == 'o')
              {                                   /* fileno     */
                return -KEY_fileno;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'r' &&
                  name[3] == 'm' &&
                  name[4] == 'a' &&
                  name[5] == 't')
              {                                   /* format     */
                return KEY_format;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'g':
          if (name[1] == 'm' &&
              name[2] == 't' &&
              name[3] == 'i' &&
              name[4] == 'm' &&
              name[5] == 'e')
          {                                       /* gmtime     */
            return -KEY_gmtime;
          }

          goto unknown;

        case 'l':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'n' &&
                  name[3] == 'g' &&
                  name[4] == 't' &&
                  name[5] == 'h')
              {                                   /* length     */
                return -KEY_length;
              }

              goto unknown;

            case 'i':
              if (name[2] == 's' &&
                  name[3] == 't' &&
                  name[4] == 'e' &&
                  name[5] == 'n')
              {                                   /* listen     */
                return -KEY_listen;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'm':
          if (name[1] == 's' &&
              name[2] == 'g')
          {
            switch (name[3])
            {
              case 'c':
                if (name[4] == 't' &&
                    name[5] == 'l')
                {                                 /* msgctl     */
                  return -KEY_msgctl;
                }

                goto unknown;

              case 'g':
                if (name[4] == 'e' &&
                    name[5] == 't')
                {                                 /* msgget     */
                  return -KEY_msgget;
                }

                goto unknown;

              case 'r':
                if (name[4] == 'c' &&
                    name[5] == 'v')
                {                                 /* msgrcv     */
                  return -KEY_msgrcv;
                }

                goto unknown;

              case 's':
                if (name[4] == 'n' &&
                    name[5] == 'd')
                {                                 /* msgsnd     */
                  return -KEY_msgsnd;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'p':
          if (name[1] == 'r' &&
              name[2] == 'i' &&
              name[3] == 'n' &&
              name[4] == 't' &&
              name[5] == 'f')
          {                                       /* printf     */
            return KEY_printf;
          }

          goto unknown;

        case 'r':
          switch (name[1])
          {
            case 'e':
              switch (name[2])
              {
                case 'n':
                  if (name[3] == 'a' &&
                      name[4] == 'm' &&
                      name[5] == 'e')
                  {                               /* rename     */
                    return -KEY_rename;
                  }

                  goto unknown;

                case 't':
                  if (name[3] == 'u' &&
                      name[4] == 'r' &&
                      name[5] == 'n')
                  {                               /* return     */
                    return KEY_return;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'i':
              if (name[2] == 'n' &&
                  name[3] == 'd' &&
                  name[4] == 'e' &&
                  name[5] == 'x')
              {                                   /* rindex     */
                return -KEY_rindex;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 's':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 'a' &&
                  name[3] == 'l' &&
                  name[4] == 'a' &&
                  name[5] == 'r')
              {                                   /* scalar     */
                return KEY_scalar;
              }

              goto unknown;

            case 'e':
              switch (name[2])
              {
                case 'l':
                  if (name[3] == 'e' &&
                      name[4] == 'c' &&
                      name[5] == 't')
                  {                               /* select     */
                    return -KEY_select;
                  }

                  goto unknown;

                case 'm':
                  switch (name[3])
                  {
                    case 'c':
                      if (name[4] == 't' &&
                          name[5] == 'l')
                      {                           /* semctl     */
                        return -KEY_semctl;
                      }

                      goto unknown;

                    case 'g':
                      if (name[4] == 'e' &&
                          name[5] == 't')
                      {                           /* semget     */
                        return -KEY_semget;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }

                default:
                  goto unknown;
              }

            case 'h':
              if (name[2] == 'm')
              {
                switch (name[3])
                {
                  case 'c':
                    if (name[4] == 't' &&
                        name[5] == 'l')
                    {                             /* shmctl     */
                      return -KEY_shmctl;
                    }

                    goto unknown;

                  case 'g':
                    if (name[4] == 'e' &&
                        name[5] == 't')
                    {                             /* shmget     */
                      return -KEY_shmget;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'k' &&
                  name[4] == 'e' &&
                  name[5] == 't')
              {                                   /* socket     */
                return -KEY_socket;
              }

              goto unknown;

            case 'p':
              if (name[2] == 'l' &&
                  name[3] == 'i' &&
                  name[4] == 'c' &&
                  name[5] == 'e')
              {                                   /* splice     */
                return -KEY_splice;
              }

              goto unknown;

            case 'u':
              if (name[2] == 'b' &&
                  name[3] == 's' &&
                  name[4] == 't' &&
                  name[5] == 'r')
              {                                   /* substr     */
                return -KEY_substr;
              }

              goto unknown;

            case 'y':
              if (name[2] == 's' &&
                  name[3] == 't' &&
                  name[4] == 'e' &&
                  name[5] == 'm')
              {                                   /* system     */
                return -KEY_system;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'u':
          if (name[1] == 'n')
          {
            switch (name[2])
            {
              case 'l':
                switch (name[3])
                {
                  case 'e':
                    if (name[4] == 's' &&
                        name[5] == 's')
                    {                             /* unless     */
                      return KEY_unless;
                    }

                    goto unknown;

                  case 'i':
                    if (name[4] == 'n' &&
                        name[5] == 'k')
                    {                             /* unlink     */
                      return -KEY_unlink;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }

              case 'p':
                if (name[3] == 'a' &&
                    name[4] == 'c' &&
                    name[5] == 'k')
                {                                 /* unpack     */
                  return -KEY_unpack;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'v':
          if (name[1] == 'a' &&
              name[2] == 'l' &&
              name[3] == 'u' &&
              name[4] == 'e' &&
              name[5] == 's')
          {                                       /* values     */
            return -KEY_values;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 7: /* 29 tokens of length 7 */
      switch (name[0])
      {
        case 'D':
          if (name[1] == 'E' &&
              name[2] == 'S' &&
              name[3] == 'T' &&
              name[4] == 'R' &&
              name[5] == 'O' &&
              name[6] == 'Y')
          {                                       /* DESTROY    */
            return KEY_DESTROY;
          }

          goto unknown;

        case '_':
          if (name[1] == '_' &&
              name[2] == 'E' &&
              name[3] == 'N' &&
              name[4] == 'D' &&
              name[5] == '_' &&
              name[6] == '_')
          {                                       /* __END__    */
            return KEY___END__;
          }

          goto unknown;

        case 'b':
          if (name[1] == 'i' &&
              name[2] == 'n' &&
              name[3] == 'm' &&
              name[4] == 'o' &&
              name[5] == 'd' &&
              name[6] == 'e')
          {                                       /* binmode    */
            return -KEY_binmode;
          }

          goto unknown;

        case 'c':
          if (name[1] == 'o' &&
              name[2] == 'n' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 'c' &&
              name[6] == 't')
          {                                       /* connect    */
            return -KEY_connect;
          }

          goto unknown;

        case 'd':
          switch (name[1])
          {
            case 'b':
              if (name[2] == 'm' &&
                  name[3] == 'o' &&
                  name[4] == 'p' &&
                  name[5] == 'e' &&
                  name[6] == 'n')
              {                                   /* dbmopen    */
                return -KEY_dbmopen;
              }

              goto unknown;

            case 'e':
              if (name[2] == 'f')
              {
                switch (name[3])
                {
                  case 'a':
                    if (name[4] == 'u' &&
                        name[5] == 'l' &&
                        name[6] == 't')
                    {                             /* default    */
                      return (all_keywords || FEATURE_IS_ENABLED("switch") ? KEY_default : 0);
                    }

                    goto unknown;

                  case 'i':
                    if (name[4] == 'n' &&
                        name[5] == 'e' &&
                        name[6] == 'd')
                    {                             /* defined    */
                      return KEY_defined;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r' &&
              name[3] == 'e' &&
              name[4] == 'a' &&
              name[5] == 'c' &&
              name[6] == 'h')
          {                                       /* foreach    */
            return KEY_foreach;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'p')
          {
            switch (name[4])
            {
              case 'g':
                if (name[5] == 'r' &&
                    name[6] == 'p')
                {                                 /* getpgrp    */
                  return -KEY_getpgrp;
                }

                goto unknown;

              case 'p':
                if (name[5] == 'i' &&
                    name[6] == 'd')
                {                                 /* getppid    */
                  return -KEY_getppid;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'l':
          if (name[1] == 'c' &&
              name[2] == 'f' &&
              name[3] == 'i' &&
              name[4] == 'r' &&
              name[5] == 's' &&
              name[6] == 't')
          {                                       /* lcfirst    */
            return -KEY_lcfirst;
          }

          goto unknown;

        case 'o':
          if (name[1] == 'p' &&
              name[2] == 'e' &&
              name[3] == 'n' &&
              name[4] == 'd' &&
              name[5] == 'i' &&
              name[6] == 'r')
          {                                       /* opendir    */
            return -KEY_opendir;
          }

          goto unknown;

        case 'p':
          if (name[1] == 'a' &&
              name[2] == 'c' &&
              name[3] == 'k' &&
              name[4] == 'a' &&
              name[5] == 'g' &&
              name[6] == 'e')
          {                                       /* package    */
            return KEY_package;
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e')
          {
            switch (name[2])
            {
              case 'a':
                if (name[3] == 'd' &&
                    name[4] == 'd' &&
                    name[5] == 'i' &&
                    name[6] == 'r')
                {                                 /* readdir    */
                  return -KEY_readdir;
                }

                goto unknown;

              case 'q':
                if (name[3] == 'u' &&
                    name[4] == 'i' &&
                    name[5] == 'r' &&
                    name[6] == 'e')
                {                                 /* require    */
                  return KEY_require;
                }

                goto unknown;

              case 'v':
                if (name[3] == 'e' &&
                    name[4] == 'r' &&
                    name[5] == 's' &&
                    name[6] == 'e')
                {                                 /* reverse    */
                  return -KEY_reverse;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'e':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'k' &&
                      name[4] == 'd' &&
                      name[5] == 'i' &&
                      name[6] == 'r')
                  {                               /* seekdir    */
                    return -KEY_seekdir;
                  }

                  goto unknown;

                case 't':
                  if (name[3] == 'p' &&
                      name[4] == 'g' &&
                      name[5] == 'r' &&
                      name[6] == 'p')
                  {                               /* setpgrp    */
                    return -KEY_setpgrp;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'h':
              if (name[2] == 'm' &&
                  name[3] == 'r' &&
                  name[4] == 'e' &&
                  name[5] == 'a' &&
                  name[6] == 'd')
              {                                   /* shmread    */
                return -KEY_shmread;
              }

              goto unknown;

            case 'p':
              if (name[2] == 'r' &&
                  name[3] == 'i' &&
                  name[4] == 'n' &&
                  name[5] == 't' &&
                  name[6] == 'f')
              {                                   /* sprintf    */
                return -KEY_sprintf;
              }

              goto unknown;

            case 'y':
              switch (name[2])
              {
                case 'm':
                  if (name[3] == 'l' &&
                      name[4] == 'i' &&
                      name[5] == 'n' &&
                      name[6] == 'k')
                  {                               /* symlink    */
                    return -KEY_symlink;
                  }

                  goto unknown;

                case 's':
                  switch (name[3])
                  {
                    case 'c':
                      if (name[4] == 'a' &&
                          name[5] == 'l' &&
                          name[6] == 'l')
                      {                           /* syscall    */
                        return -KEY_syscall;
                      }

                      goto unknown;

                    case 'o':
                      if (name[4] == 'p' &&
                          name[5] == 'e' &&
                          name[6] == 'n')
                      {                           /* sysopen    */
                        return -KEY_sysopen;
                      }

                      goto unknown;

                    case 'r':
                      if (name[4] == 'e' &&
                          name[5] == 'a' &&
                          name[6] == 'd')
                      {                           /* sysread    */
                        return -KEY_sysread;
                      }

                      goto unknown;

                    case 's':
                      if (name[4] == 'e' &&
                          name[5] == 'e' &&
                          name[6] == 'k')
                      {                           /* sysseek    */
                        return -KEY_sysseek;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'e' &&
              name[2] == 'l' &&
              name[3] == 'l' &&
              name[4] == 'd' &&
              name[5] == 'i' &&
              name[6] == 'r')
          {                                       /* telldir    */
            return -KEY_telldir;
          }

          goto unknown;

        case 'u':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 'f' &&
                  name[3] == 'i' &&
                  name[4] == 'r' &&
                  name[5] == 's' &&
                  name[6] == 't')
              {                                   /* ucfirst    */
                return -KEY_ucfirst;
              }

              goto unknown;

            case 'n':
              if (name[2] == 's' &&
                  name[3] == 'h' &&
                  name[4] == 'i' &&
                  name[5] == 'f' &&
                  name[6] == 't')
              {                                   /* unshift    */
                return -KEY_unshift;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'w':
          if (name[1] == 'a' &&
              name[2] == 'i' &&
              name[3] == 't' &&
              name[4] == 'p' &&
              name[5] == 'i' &&
              name[6] == 'd')
          {                                       /* waitpid    */
            return -KEY_waitpid;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 8: /* 26 tokens of length 8 */
      switch (name[0])
      {
        case 'A':
          if (name[1] == 'U' &&
              name[2] == 'T' &&
              name[3] == 'O' &&
              name[4] == 'L' &&
              name[5] == 'O' &&
              name[6] == 'A' &&
              name[7] == 'D')
          {                                       /* AUTOLOAD   */
            return KEY_AUTOLOAD;
          }

          goto unknown;

        case '_':
          if (name[1] == '_')
          {
            switch (name[2])
            {
              case 'D':
                if (name[3] == 'A' &&
                    name[4] == 'T' &&
                    name[5] == 'A' &&
                    name[6] == '_' &&
                    name[7] == '_')
                {                                 /* __DATA__   */
                  return KEY___DATA__;
                }

                goto unknown;

              case 'F':
                if (name[3] == 'I' &&
                    name[4] == 'L' &&
                    name[5] == 'E' &&
                    name[6] == '_' &&
                    name[7] == '_')
                {                                 /* __FILE__   */
                  return -KEY___FILE__;
                }

                goto unknown;

              case 'L':
                if (name[3] == 'I' &&
                    name[4] == 'N' &&
                    name[5] == 'E' &&
                    name[6] == '_' &&
                    name[7] == '_')
                {                                 /* __LINE__   */
                  return -KEY___LINE__;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'c':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 's' &&
                  name[4] == 'e' &&
                  name[5] == 'd' &&
                  name[6] == 'i' &&
                  name[7] == 'r')
              {                                   /* closedir   */
                return -KEY_closedir;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'n' &&
                  name[3] == 't' &&
                  name[4] == 'i' &&
                  name[5] == 'n' &&
                  name[6] == 'u' &&
                  name[7] == 'e')
              {                                   /* continue   */
                return -KEY_continue;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'd':
          if (name[1] == 'b' &&
              name[2] == 'm' &&
              name[3] == 'c' &&
              name[4] == 'l' &&
              name[5] == 'o' &&
              name[6] == 's' &&
              name[7] == 'e')
          {                                       /* dbmclose   */
            return -KEY_dbmclose;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd')
          {
            switch (name[3])
            {
              case 'g':
                if (name[4] == 'r' &&
                    name[5] == 'e' &&
                    name[6] == 'n' &&
                    name[7] == 't')
                {                                 /* endgrent   */
                  return -KEY_endgrent;
                }

                goto unknown;

              case 'p':
                if (name[4] == 'w' &&
                    name[5] == 'e' &&
                    name[6] == 'n' &&
                    name[7] == 't')
                {                                 /* endpwent   */
                  return -KEY_endpwent;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r' &&
              name[3] == 'm' &&
              name[4] == 'l' &&
              name[5] == 'i' &&
              name[6] == 'n' &&
              name[7] == 'e')
          {                                       /* formline   */
            return -KEY_formline;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't')
          {
            switch (name[3])
            {
              case 'g':
                if (name[4] == 'r')
                {
                  switch (name[5])
                  {
                    case 'e':
                      if (name[6] == 'n' &&
                          name[7] == 't')
                      {                           /* getgrent   */
                        return -KEY_getgrent;
                      }

                      goto unknown;

                    case 'g':
                      if (name[6] == 'i' &&
                          name[7] == 'd')
                      {                           /* getgrgid   */
                        return -KEY_getgrgid;
                      }

                      goto unknown;

                    case 'n':
                      if (name[6] == 'a' &&
                          name[7] == 'm')
                      {                           /* getgrnam   */
                        return -KEY_getgrnam;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }
                }

                goto unknown;

              case 'l':
                if (name[4] == 'o' &&
                    name[5] == 'g' &&
                    name[6] == 'i' &&
                    name[7] == 'n')
                {                                 /* getlogin   */
                  return -KEY_getlogin;
                }

                goto unknown;

              case 'p':
                if (name[4] == 'w')
                {
                  switch (name[5])
                  {
                    case 'e':
                      if (name[6] == 'n' &&
                          name[7] == 't')
                      {                           /* getpwent   */
                        return -KEY_getpwent;
                      }

                      goto unknown;

                    case 'n':
                      if (name[6] == 'a' &&
                          name[7] == 'm')
                      {                           /* getpwnam   */
                        return -KEY_getpwnam;
                      }

                      goto unknown;

                    case 'u':
                      if (name[6] == 'i' &&
                          name[7] == 'd')
                      {                           /* getpwuid   */
                        return -KEY_getpwuid;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e' &&
              name[2] == 'a' &&
              name[3] == 'd')
          {
            switch (name[4])
            {
              case 'l':
                if (name[5] == 'i' &&
                    name[6] == 'n')
                {
                  switch (name[7])
                  {
                    case 'e':
                      {                           /* readline   */
                        return -KEY_readline;
                      }

                    case 'k':
                      {                           /* readlink   */
                        return -KEY_readlink;
                      }

                    default:
                      goto unknown;
                  }
                }

                goto unknown;

              case 'p':
                if (name[5] == 'i' &&
                    name[6] == 'p' &&
                    name[7] == 'e')
                {                                 /* readpipe   */
                  return -KEY_readpipe;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 't')
              {
                switch (name[3])
                {
                  case 'g':
                    if (name[4] == 'r' &&
                        name[5] == 'e' &&
                        name[6] == 'n' &&
                        name[7] == 't')
                    {                             /* setgrent   */
                      return -KEY_setgrent;
                    }

                    goto unknown;

                  case 'p':
                    if (name[4] == 'w' &&
                        name[5] == 'e' &&
                        name[6] == 'n' &&
                        name[7] == 't')
                    {                             /* setpwent   */
                      return -KEY_setpwent;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            case 'h':
              switch (name[2])
              {
                case 'm':
                  if (name[3] == 'w' &&
                      name[4] == 'r' &&
                      name[5] == 'i' &&
                      name[6] == 't' &&
                      name[7] == 'e')
                  {                               /* shmwrite   */
                    return -KEY_shmwrite;
                  }

                  goto unknown;

                case 'u':
                  if (name[3] == 't' &&
                      name[4] == 'd' &&
                      name[5] == 'o' &&
                      name[6] == 'w' &&
                      name[7] == 'n')
                  {                               /* shutdown   */
                    return -KEY_shutdown;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'y':
              if (name[2] == 's' &&
                  name[3] == 'w' &&
                  name[4] == 'r' &&
                  name[5] == 'i' &&
                  name[6] == 't' &&
                  name[7] == 'e')
              {                                   /* syswrite   */
                return -KEY_syswrite;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'r' &&
              name[2] == 'u' &&
              name[3] == 'n' &&
              name[4] == 'c' &&
              name[5] == 'a' &&
              name[6] == 't' &&
              name[7] == 'e')
          {                                       /* truncate   */
            return -KEY_truncate;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 9: /* 9 tokens of length 9 */
      switch (name[0])
      {
        case 'U':
          if (name[1] == 'N' &&
              name[2] == 'I' &&
              name[3] == 'T' &&
              name[4] == 'C' &&
              name[5] == 'H' &&
              name[6] == 'E' &&
              name[7] == 'C' &&
              name[8] == 'K')
          {                                       /* UNITCHECK  */
            return KEY_UNITCHECK;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 't' &&
              name[6] == 'e' &&
              name[7] == 'n' &&
              name[8] == 't')
          {                                       /* endnetent  */
            return -KEY_endnetent;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 't' &&
              name[6] == 'e' &&
              name[7] == 'n' &&
              name[8] == 't')
          {                                       /* getnetent  */
            return -KEY_getnetent;
          }

          goto unknown;

        case 'l':
          if (name[1] == 'o' &&
              name[2] == 'c' &&
              name[3] == 'a' &&
              name[4] == 'l' &&
              name[5] == 't' &&
              name[6] == 'i' &&
              name[7] == 'm' &&
              name[8] == 'e')
          {                                       /* localtime  */
            return -KEY_localtime;
          }

          goto unknown;

        case 'p':
          if (name[1] == 'r' &&
              name[2] == 'o' &&
              name[3] == 't' &&
              name[4] == 'o' &&
              name[5] == 't' &&
              name[6] == 'y' &&
              name[7] == 'p' &&
              name[8] == 'e')
          {                                       /* prototype  */
            return KEY_prototype;
          }

          goto unknown;

        case 'q':
          if (name[1] == 'u' &&
              name[2] == 'o' &&
              name[3] == 't' &&
              name[4] == 'e' &&
              name[5] == 'm' &&
              name[6] == 'e' &&
              name[7] == 't' &&
              name[8] == 'a')
          {                                       /* quotemeta  */
            return -KEY_quotemeta;
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e' &&
              name[2] == 'w' &&
              name[3] == 'i' &&
              name[4] == 'n' &&
              name[5] == 'd' &&
              name[6] == 'd' &&
              name[7] == 'i' &&
              name[8] == 'r')
          {                                       /* rewinddir  */
            return -KEY_rewinddir;
          }

          goto unknown;

        case 's':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 't' &&
              name[6] == 'e' &&
              name[7] == 'n' &&
              name[8] == 't')
          {                                       /* setnetent  */
            return -KEY_setnetent;
          }

          goto unknown;

        case 'w':
          if (name[1] == 'a' &&
              name[2] == 'n' &&
              name[3] == 't' &&
              name[4] == 'a' &&
              name[5] == 'r' &&
              name[6] == 'r' &&
              name[7] == 'a' &&
              name[8] == 'y')
          {                                       /* wantarray  */
            return -KEY_wantarray;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 10: /* 9 tokens of length 10 */
      switch (name[0])
      {
        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd')
          {
            switch (name[3])
            {
              case 'h':
                if (name[4] == 'o' &&
                    name[5] == 's' &&
                    name[6] == 't' &&
                    name[7] == 'e' &&
                    name[8] == 'n' &&
                    name[9] == 't')
                {                                 /* endhostent */
                  return -KEY_endhostent;
                }

                goto unknown;

              case 's':
                if (name[4] == 'e' &&
                    name[5] == 'r' &&
                    name[6] == 'v' &&
                    name[7] == 'e' &&
                    name[8] == 'n' &&
                    name[9] == 't')
                {                                 /* endservent */
                  return -KEY_endservent;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't')
          {
            switch (name[3])
            {
              case 'h':
                if (name[4] == 'o' &&
                    name[5] == 's' &&
                    name[6] == 't' &&
                    name[7] == 'e' &&
                    name[8] == 'n' &&
                    name[9] == 't')
                {                                 /* gethostent */
                  return -KEY_gethostent;
                }

                goto unknown;

              case 's':
                switch (name[4])
                {
                  case 'e':
                    if (name[5] == 'r' &&
                        name[6] == 'v' &&
                        name[7] == 'e' &&
                        name[8] == 'n' &&
                        name[9] == 't')
                    {                             /* getservent */
                      return -KEY_getservent;
                    }

                    goto unknown;

                  case 'o':
                    if (name[5] == 'c' &&
                        name[6] == 'k' &&
                        name[7] == 'o' &&
                        name[8] == 'p' &&
                        name[9] == 't')
                    {                             /* getsockopt */
                      return -KEY_getsockopt;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 't')
              {
                switch (name[3])
                {
                  case 'h':
                    if (name[4] == 'o' &&
                        name[5] == 's' &&
                        name[6] == 't' &&
                        name[7] == 'e' &&
                        name[8] == 'n' &&
                        name[9] == 't')
                    {                             /* sethostent */
                      return -KEY_sethostent;
                    }

                    goto unknown;

                  case 's':
                    switch (name[4])
                    {
                      case 'e':
                        if (name[5] == 'r' &&
                            name[6] == 'v' &&
                            name[7] == 'e' &&
                            name[8] == 'n' &&
                            name[9] == 't')
                        {                         /* setservent */
                          return -KEY_setservent;
                        }

                        goto unknown;

                      case 'o':
                        if (name[5] == 'c' &&
                            name[6] == 'k' &&
                            name[7] == 'o' &&
                            name[8] == 'p' &&
                            name[9] == 't')
                        {                         /* setsockopt */
                          return -KEY_setsockopt;
                        }

                        goto unknown;

                      default:
                        goto unknown;
                    }

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'k' &&
                  name[4] == 'e' &&
                  name[5] == 't' &&
                  name[6] == 'p' &&
                  name[7] == 'a' &&
                  name[8] == 'i' &&
                  name[9] == 'r')
              {                                   /* socketpair */
                return -KEY_socketpair;
              }

              goto unknown;

            default:
              goto unknown;
          }

        default:
          goto unknown;
      }

    case 11: /* 8 tokens of length 11 */
      switch (name[0])
      {
        case '_':
          if (name[1] == '_' &&
              name[2] == 'P' &&
              name[3] == 'A' &&
              name[4] == 'C' &&
              name[5] == 'K' &&
              name[6] == 'A' &&
              name[7] == 'G' &&
              name[8] == 'E' &&
              name[9] == '_' &&
              name[10] == '_')
          {                                       /* __PACKAGE__ */
            return -KEY___PACKAGE__;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd' &&
              name[3] == 'p' &&
              name[4] == 'r' &&
              name[5] == 'o' &&
              name[6] == 't' &&
              name[7] == 'o' &&
              name[8] == 'e' &&
              name[9] == 'n' &&
              name[10] == 't')
          {                                       /* endprotoent */
            return -KEY_endprotoent;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't')
          {
            switch (name[3])
            {
              case 'p':
                switch (name[4])
                {
                  case 'e':
                    if (name[5] == 'e' &&
                        name[6] == 'r' &&
                        name[7] == 'n' &&
                        name[8] == 'a' &&
                        name[9] == 'm' &&
                        name[10] == 'e')
                    {                             /* getpeername */
                      return -KEY_getpeername;
                    }

                    goto unknown;

                  case 'r':
                    switch (name[5])
                    {
                      case 'i':
                        if (name[6] == 'o' &&
                            name[7] == 'r' &&
                            name[8] == 'i' &&
                            name[9] == 't' &&
                            name[10] == 'y')
                        {                         /* getpriority */
                          return -KEY_getpriority;
                        }

                        goto unknown;

                      case 'o':
                        if (name[6] == 't' &&
                            name[7] == 'o' &&
                            name[8] == 'e' &&
                            name[9] == 'n' &&
                            name[10] == 't')
                        {                         /* getprotoent */
                          return -KEY_getprotoent;
                        }

                        goto unknown;

                      default:
                        goto unknown;
                    }

                  default:
                    goto unknown;
                }

              case 's':
                if (name[4] == 'o' &&
                    name[5] == 'c' &&
                    name[6] == 'k' &&
                    name[7] == 'n' &&
                    name[8] == 'a' &&
                    name[9] == 'm' &&
                    name[10] == 'e')
                {                                 /* getsockname */
                  return -KEY_getsockname;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'p' &&
              name[4] == 'r')
          {
            switch (name[5])
            {
              case 'i':
                if (name[6] == 'o' &&
                    name[7] == 'r' &&
                    name[8] == 'i' &&
                    name[9] == 't' &&
                    name[10] == 'y')
                {                                 /* setpriority */
                  return -KEY_setpriority;
                }

                goto unknown;

              case 'o':
                if (name[6] == 't' &&
                    name[7] == 'o' &&
                    name[8] == 'e' &&
                    name[9] == 'n' &&
                    name[10] == 't')
                {                                 /* setprotoent */
                  return -KEY_setprotoent;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 12: /* 2 tokens of length 12 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't' &&
          name[3] == 'n' &&
          name[4] == 'e' &&
          name[5] == 't' &&
          name[6] == 'b' &&
          name[7] == 'y')
      {
        switch (name[8])
        {
          case 'a':
            if (name[9] == 'd' &&
                name[10] == 'd' &&
                name[11] == 'r')
            {                                     /* getnetbyaddr */
              return -KEY_getnetbyaddr;
            }

            goto unknown;

          case 'n':
            if (name[9] == 'a' &&
                name[10] == 'm' &&
                name[11] == 'e')
            {                                     /* getnetbyname */
              return -KEY_getnetbyname;
            }

            goto unknown;

          default:
            goto unknown;
        }
      }

      goto unknown;

    case 13: /* 4 tokens of length 13 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't')
      {
        switch (name[3])
        {
          case 'h':
            if (name[4] == 'o' &&
                name[5] == 's' &&
                name[6] == 't' &&
                name[7] == 'b' &&
                name[8] == 'y')
            {
              switch (name[9])
              {
                case 'a':
                  if (name[10] == 'd' &&
                      name[11] == 'd' &&
                      name[12] == 'r')
                  {                               /* gethostbyaddr */
                    return -KEY_gethostbyaddr;
                  }

                  goto unknown;

                case 'n':
                  if (name[10] == 'a' &&
                      name[11] == 'm' &&
                      name[12] == 'e')
                  {                               /* gethostbyname */
                    return -KEY_gethostbyname;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }
            }

            goto unknown;

          case 's':
            if (name[4] == 'e' &&
                name[5] == 'r' &&
                name[6] == 'v' &&
                name[7] == 'b' &&
                name[8] == 'y')
            {
              switch (name[9])
              {
                case 'n':
                  if (name[10] == 'a' &&
                      name[11] == 'm' &&
                      name[12] == 'e')
                  {                               /* getservbyname */
                    return -KEY_getservbyname;
                  }

                  goto unknown;

                case 'p':
                  if (name[10] == 'o' &&
                      name[11] == 'r' &&
                      name[12] == 't')
                  {                               /* getservbyport */
                    return -KEY_getservbyport;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }
            }

            goto unknown;

          default:
            goto unknown;
        }
      }

      goto unknown;

    case 14: /* 1 tokens of length 14 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't' &&
          name[3] == 'p' &&
          name[4] == 'r' &&
          name[5] == 'o' &&
          name[6] == 't' &&
          name[7] == 'o' &&
          name[8] == 'b' &&
          name[9] == 'y' &&
          name[10] == 'n' &&
          name[11] == 'a' &&
          name[12] == 'm' &&
          name[13] == 'e')
      {                                           /* getprotobyname */
        return -KEY_getprotobyname;
      }

      goto unknown;

    case 16: /* 1 tokens of length 16 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't' &&
          name[3] == 'p' &&
          name[4] == 'r' &&
          name[5] == 'o' &&
          name[6] == 't' &&
          name[7] == 'o' &&
          name[8] == 'b' &&
          name[9] == 'y' &&
          name[10] == 'n' &&
          name[11] == 'u' &&
          name[12] == 'm' &&
          name[13] == 'b' &&
          name[14] == 'e' &&
          name[15] == 'r')
      {                                           /* getprotobynumber */
        return -KEY_getprotobynumber;
      }

      goto unknown;

    default:
      goto unknown;
  }

unknown:
  return 0;
}

STATIC void
S_checkcomma(pTHX_ const char *s, const char *name, const char *what)
{
    dVAR;

    PERL_ARGS_ASSERT_CHECKCOMMA;

    if (*s == ' ' && s[1] == '(') {	/* XXX gotta be a better way */
	if (ckWARN(WARN_SYNTAX)) {
	    int level = 1;
	    const char *w;
	    for (w = s+2; *w && level; w++) {
		if (*w == '(')
		    ++level;
d8643 2
a8644 1
	const char * const w = s++;
d8646 1
a8646 1
	    s++;
d8654 1
a8654 1
	    gv = gv_fetchpvn_flags(w, s - w, 0, SVt_PVCV);
d8672 1
a8672 1
    HV * const table = GvHV(PL_hintgv);		 /* ^H */
d8680 9
a8688 1
    if (!table || !(PL_hints & HINT_LOCALIZE_HH)) {
d8691 31
a8721 14
	why2 = (const char *)
	    (strEQ(key,"charnames")
	     ? "(possibly a missing \"use charnames ...\")"
	     : "");
	msg = Perl_newSVpvf(aTHX_ "Constant(%s) unknown: %s",
			    (type ? type: "undef"), why2);

	/* This is convoluted and evil ("goto considered harmful")
	 * but I do not understand the intricacies of all the different
	 * failure modes of %^H in here.  The goal here is to make
	 * the most probable error message user-friendly. --jhi */

	goto msgdone;

d8725 1
a8725 1
    msgdone:
d8730 1
a8730 12

    /* charnames doesn't work well if there have been errors found */
    if (PL_error_count > 0 && strEQ(key,"charnames"))
	return &PL_sv_undef;

    cvp = hv_fetch(table, key, keylen, FALSE);
    if (!cvp || !SvOK(*cvp)) {
	why1 = "$^H{";
	why2 = key;
	why3 = "} is not defined";
	goto report;
    }
d8799 1
a8799 1
	if (isALNUM(*s))	/* UTF handled below */
d8897 13
a8909 3
    if (s < send)
	*d = *s++;
    d[1] = '\0';
d8925 1
a8925 1
	    d++;
d8951 1
d8958 1
d8984 1
a8984 1
		     || get_cvn_flags(dest, d - dest, 0)))
d8986 2
d8991 2
a8992 2
			"Ambiguous use of %c{%s} resolved to %c%s",
			funny, dest, funny, dest);
d9006 20
a9025 8
static U32
S_pmflag(U32 pmfl, const char ch) {
    switch (ch) {
	CASE_STD_PMMOD_FLAGS_PARSE_SET(&pmfl);
    case GLOBAL_PAT_MOD:    pmfl |= PMf_GLOBAL; break;
    case CONTINUE_PAT_MOD:  pmfl |= PMf_CONTINUE; break;
    case ONCE_PAT_MOD:      pmfl |= PMf_KEEP; break;
    case KEEPCOPY_PAT_MOD:  pmfl |= PMf_KEEPCOPY; break;
a9026 2
    return pmfl;
}
d9028 61
a9088 4
void
Perl_pmflag(pTHX_ U32* pmfl, int ch)
{
    PERL_ARGS_ASSERT_PMFLAG;
d9090 4
a9093 2
    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
		     "Perl_pmflag() is deprecated, and will be removed from the XS API");
d9095 19
a9113 2
    if (ch<256) {
	*pmfl = S_pmflag(*pmfl, (char)ch);
d9115 23
d9148 1
d9190 1
a9190 2
    while (*s && strchr(valid_flags, *s))
	pm->op_pmflags = S_pmflag(pm->op_pmflags, *s++);
d9213 1
a9213 1
    register char *s;
d9217 1
d9270 2
a9271 3
	else if (strchr(S_PAT_MODS, *s))
	    pm->op_pmflags = S_pmflag(pm->op_pmflags, *s++);
	else
d9273 1
a9321 1
    short *tbl;
d9325 1
d9379 3
d9389 1
a9389 2
    tbl = (short *)PerlMemShared_calloc(complement&&!del?258:256, sizeof(short));
    o = newPVOP(OP_TRANS, 0, (char*)tbl);
d9396 1
a9396 1
    pl_yylval.ival = OP_TRANS;
d9423 2
a9424 1
    const int outer = (PL_rsfp && !(PL_lex_inwhat == OP_SCALAR));
d9548 2
a9549 1
    if (PL_lex_inwhat == OP_SUBST && PL_in_eval && !PL_rsfp) {
d9649 1
d9732 1
a9732 1
	d++;
d9775 1
a9775 1
	    const PADOFFSET tmp = pad_findmy(d, len, 0);
d9791 1
a9791 1
				append_elem(OP_LIST, o,
d9803 1
a9803 1
				 : GV_ADDMULTI),
d9807 1
a9807 1
			    append_elem(OP_LIST,
d9823 1
a9823 1
	    GV * const gv = gv_fetchpv(d, GV_ADD, SVt_PVIO);
d9826 1
a9826 1
			append_elem(OP_LIST,
d9926 1
a9926 1
	termcode = utf8_to_uvchr((U8*)s, &termlen);
d9972 1
a9972 1
		    if (*s == '\n' && !PL_rsfp)
d10039 1
a10039 1
		if (*s == '\n' && !PL_rsfp)
d10071 1
a10071 1
		if (*s == '\n' && !PL_rsfp)
d10241 1
a10241 1
      Perl_croak(aTHX_ "panic: scan_num");
d10276 1
a10276 1
	    if (s[1] == 'x') {
d10280 1
a10280 1
	    } else if (s[1] == 'b') {
a10393 1
	    sv = newSV(0);
d10399 1
a10399 1
		sv_setnv(sv, n);
d10408 1
a10408 1
		sv_setuv(sv, u);
a10538 3
	/* make an sv from the string */
	sv = newSV(0);

d10550 1
a10550 1
		sv_setiv(sv, uv); /* Prefer IVs over UVs. */
d10552 1
a10552 1
	    	sv_setuv(sv, uv);
d10555 1
a10555 1
                sv_setiv(sv, -(IV)uv);
d10565 1
a10565 1
	    sv_setnv(sv, nv);
d10631 1
a10631 1
	if (PL_in_eval && !PL_rsfp) {
d10662 1
a10662 1
	if (PL_rsfp) {
d10756 1
a10756 1
S_yywarn(pTHX_ const char *const s)
d10763 1
a10763 1
    yyerror(s);
d10771 14
a10785 1
    const char *where = NULL;
d10789 1
d10791 1
d10793 1
a10793 1
    PERL_ARGS_ASSERT_YYERROR;
d10796 1
a10796 1
	where = "at EOF";
d10831 1
a10831 1
	where = "next token ???";
d10835 1
a10835 1
	    where = "at end of line";
d10837 1
a10837 1
	    where = "within pattern";
d10839 1
a10839 1
	    where = "within string";
d10842 1
a10842 1
	SV * const where_sv = newSVpvs_flags("next char ", SVs_TEMP);
a10850 1
	where = SvPVX_const(where_sv);
d10852 1
a10852 1
    msg = sv_2mortal(newSVpv(s, 0));
d10856 3
a10858 1
	Perl_sv_catpvf(aTHX_ msg, "near \"%.*s\"\n", contlen, context);
d10860 1
a10860 1
	Perl_sv_catpvf(aTHX_ msg, "%s\n", where);
d10901 1
d10910 1
d10924 1
d10940 1
d10952 1
d10975 1
d10995 1
a10995 1
    const bool reverse = (bool) IoLINES(filter);
d10998 2
d11113 2
d11192 1
d11232 415
@


1.14
log
@Merge in perl 5.10.1
@
text
@d24 15
d114 2
a119 6
static const char commaless_variable_list[] = "comma-less variable list";

#ifndef PERL_NO_UTF16_FILTER
static I32 utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen);
static I32 utf16rev_textfilter(pTHX_ int idx, SV *sv, int maxlen);
#endif
d138 3
a144 4
/* On MacOS, respect nonbreaking spaces */
#ifdef MACOS_TRADITIONAL
#define SPACE_OR_TAB(c) ((c)==' '||(c)=='\312'||(c)=='\t')
#else
a145 1
#endif
d361 2
d384 1
d455 1
a455 1
S_printbuf(pTHX_ const char* fmt, const char* s)
d467 7
d512 1
a512 1
S_no_op(pTHX_ const char *what, char *s)
d586 1
a586 1
#define MAX_FEATURE_LEN (sizeof("switch")-1)
d593 1
a593 1
S_feature_is_enabled(pTHX_ const char *name, STRLEN namelen)
a607 31
 * Perl_deprecate
 */

void
Perl_deprecate(pTHX_ const char *s)
{
    PERL_ARGS_ASSERT_DEPRECATE;

    if (ckWARN(WARN_DEPRECATED))
	Perl_warner(aTHX_ packWARN(WARN_DEPRECATED), "Use of %s is deprecated", s);
}

void
Perl_deprecate_old(pTHX_ const char *s)
{
    /* This function should NOT be called for any new deprecated warnings */
    /* Use Perl_deprecate instead                                         */
    /*                                                                    */
    /* It is here to maintain backward compatibility with the pre-5.8     */
    /* warnings category hierarchy. The "deprecated" category used to     */
    /* live under the "syntax" category. It is now a top-level category   */
    /* in its own right.                                                  */

    PERL_ARGS_ASSERT_DEPRECATE_OLD;

    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
			"Use of %s is deprecated", s);
}

/*
d774 703
d1517 2
d1691 1
a1691 1
S_update_debugger_info(pTHX_ SV *orig_sv, const char *buf, STRLEN len)
a1714 1
    dVAR;
d1716 2
a1717 3
    int curoff;
    int startoff = s - SvPVX(PL_linestr);

d1719 1
a1719 1

d1722 1
a1722 1
	PL_skipwhite = 0;
d1724 1
a1724 3
#endif
    PERL_ARGS_ASSERT_SKIPSPACE;

d1728 10
a1737 3
#ifdef PERL_MAD
	goto done;
#else
a1738 138
#endif
    }
    for (;;) {
	STRLEN prevlen;
	SSize_t oldprevlen, oldoldprevlen;
	SSize_t oldloplen = 0, oldunilen = 0;
	while (s < PL_bufend && isSPACE(*s)) {
	    if (*s++ == '\n' && PL_in_eval && !PL_rsfp)
		incline(s);
	}

	/* comment */
	if (s < PL_bufend && *s == '#') {
	    while (s < PL_bufend && *s != '\n')
		s++;
	    if (s < PL_bufend) {
		s++;
		if (PL_in_eval && !PL_rsfp) {
		    incline(s);
		    continue;
		}
	    }
	}

	/* only continue to recharge the buffer if we're at the end
	 * of the buffer, we're not reading from a source filter, and
	 * we're in normal lexing mode
	 */
	if (s < PL_bufend || !PL_rsfp || PL_sublex_info.sub_inwhat ||
		PL_lex_state == LEX_FORMLINE)
#ifdef PERL_MAD
	    goto done;
#else
	    return s;
#endif

	/* try to recharge the buffer */
#ifdef PERL_MAD
	curoff = s - SvPVX(PL_linestr);
#endif

	if ((s = filter_gets(PL_linestr, PL_rsfp,
			     (prevlen = SvCUR(PL_linestr)))) == NULL)
	{
#ifdef PERL_MAD
	    if (PL_madskills && curoff != startoff) {
		if (!PL_skipwhite)
		    PL_skipwhite = newSVpvs("");
		sv_catpvn(PL_skipwhite, SvPVX(PL_linestr) + startoff,
					curoff - startoff);
	    }

	    /* mustn't throw out old stuff yet if madpropping */
	    SvCUR(PL_linestr) = curoff;
	    s = SvPVX(PL_linestr) + curoff;
	    *s = 0;
	    if (curoff && s[-1] == '\n')
		s[-1] = ' ';
#endif

	    /* end of file.  Add on the -p or -n magic */
	    /* XXX these shouldn't really be added here, can't set PL_faketokens */
	    if (PL_minus_p) {
#ifdef PERL_MAD
		sv_catpvs(PL_linestr,
			 ";}continue{print or die qq(-p destination: $!\\n);}");
#else
		sv_setpvs(PL_linestr,
			 ";}continue{print or die qq(-p destination: $!\\n);}");
#endif
		PL_minus_n = PL_minus_p = 0;
	    }
	    else if (PL_minus_n) {
#ifdef PERL_MAD
		sv_catpvs(PL_linestr, ";}");
#else
		sv_setpvs(PL_linestr, ";}");
#endif
		PL_minus_n = 0;
	    }
	    else
#ifdef PERL_MAD
		sv_catpvs(PL_linestr,";");
#else
		sv_setpvs(PL_linestr,";");
#endif

	    /* reset variables for next time we lex */
	    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = s = PL_linestart
		= SvPVX(PL_linestr)
#ifdef PERL_MAD
		+ curoff
#endif
		;
	    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	    PL_last_lop = PL_last_uni = NULL;

	    /* Close the filehandle.  Could be from -P preprocessor,
	     * STDIN, or a regular file.  If we were reading code from
	     * STDIN (because the commandline held no -e or filename)
	     * then we don't close it, we reset it so the code can
	     * read from STDIN too.
	     */

	    if (PL_preprocess && !PL_in_eval)
		(void)PerlProc_pclose(PL_rsfp);
	    else if ((PerlIO*)PL_rsfp == PerlIO_stdin())
		PerlIO_clearerr(PL_rsfp);
	    else
		(void)PerlIO_close(PL_rsfp);
	    PL_rsfp = NULL;
	    return s;
	}

	/* not at end of file, so we only read another line */
	/* make corresponding updates to old pointers, for yyerror() */
	oldprevlen = PL_oldbufptr - PL_bufend;
	oldoldprevlen = PL_oldoldbufptr - PL_bufend;
	if (PL_last_uni)
	    oldunilen = PL_last_uni - PL_bufend;
	if (PL_last_lop)
	    oldloplen = PL_last_lop - PL_bufend;
	PL_linestart = PL_bufptr = s + prevlen;
	PL_bufend = s + SvCUR(PL_linestr);
	s = PL_bufptr;
	PL_oldbufptr = s + oldprevlen;
	PL_oldoldbufptr = s + oldoldprevlen;
	if (PL_last_uni)
	    PL_last_uni = s + oldunilen;
	if (PL_last_lop)
	    PL_last_lop = s + oldloplen;
	incline(s);

	/* debugger active and we're not compiling the debugger code,
	 * so store the line into the debugger's array of lines
	 */
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
	    update_debugger_info(NULL, PL_bufptr, PL_bufend - PL_bufptr);
a1739 1

d1741 3
a1743 9
  done:
    if (PL_madskills) {
	if (!PL_skipwhite)
	    PL_skipwhite = newSVpvs("");
	curoff = s - SvPVX(PL_linestr);
	if (curoff - startoff)
	    sv_catpvn(PL_skipwhite, SvPVX(PL_linestr) + startoff,
				curoff - startoff);
    }
a1744 1
#endif
d1773 3
a1775 5
    if (ckWARN_d(WARN_AMBIGUOUS)){
        Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
		   "Warning: Use of \"%.*s\" without parentheses is ambiguous",
		   (int)(s - PL_last_uni), PL_last_uni);
    }
d1932 1
a1932 1
S_newSV_maybe_utf8(pTHX_ const char *start, STRLEN len)
d1936 3
a1938 1
				  UTF && !IN_BYTES
d2103 3
d2107 3
d2117 38
a2154 2
        }
	else if (guessing) {
d2156 1
a2156 5
	    if (PL_madskills) {
		sv_free(PL_nextwhite);	/* let next token collect whitespace */
		PL_nextwhite = 0;
		s = SvPVX(PL_linestr) + startoff;
	    }
d2158 17
a2174 2
	    return s;
	}
d2481 1
a2481 4
      double-quoted style: \r and \n
      regexp special ones: \D \s
      constants: \x31
      backrefs: \1
d2495 1
a2495 1
      constants: \x31
a2522 1
	      leave intact backslashes from leaveit (below)
d2527 1
d2530 1
a2530 1
		  handle \N{name} (named characters)
d2588 1
d2795 5
a2799 1
	    if (s + 1 < send && !strchr("()| \r\n\t", s[1]))
d2801 1
d2808 2
d2816 1
a2816 2
		if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "\\%c better written as $%c", *s, *s);
d2826 18
a2843 2
	    /* skip any other backslash escapes in a pattern */
	    else if (PL_lex_inpat) {
a2847 1
	    /* if we get here, it's either a quoted -, or a digit */
d2859 4
a2862 5
		    if ((isALPHA(*s) || isDIGIT(*s)) &&
			ckWARN(WARN_MISC))
			Perl_warner(aTHX_ packWARN(WARN_MISC),
				    "Unrecognized escape \\%c passed through",
				    *s);
d2906 4
a2909 4
		/* Insert oct, hex, or \N{U+...} escaped character.  There will
		 * always be enough room in sv since such escapes will be
		 * longer than any UTF-8 sequence they can end up as, except if
		 * they force us to recode the rest of the string into utf8 */
d2912 1
a2912 3
		 * unicode (converted from native).  (It has to be done before
		 * here because \N is interpreted as unicode, and oct and hex
		 * as native.) */
a2921 1
			sv_utf8_upgrade(sv);
d2923 3
a2925 1
			SvGROW(sv, SvCUR(sv) + UNISKIP(uv) + (STRLEN)(send - s) + 1);
a2951 2
	    /* \N{LATIN SMALL LETTER A} is a named character, and so is
	     * \N{U+0041} */
d2953 41
a2993 6
 		++s;
 		if (*s == '{') {
 		    char* e = strchr(s, '}');
 		    SV *res;
 		    STRLEN len;
 		    const char *str;
d2995 3
a2997 1
 		    if (!e) {
d2999 2
a3000 2
			e = s - 1;
			goto cont_scan;
d3002 4
a3005 30
		    if (e > s + 2 && s[1] == 'U' && s[2] == '+') {
			/* \N{U+...} The ... is a unicode value even on EBCDIC
			 * machines */
		        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES |
			  PERL_SCAN_DISALLOW_PREFIX;
		        s += 3;
			len = e - s;
			uv = grok_hex(s, &len, &flags, NULL);
			if ( e > s && len != (STRLEN)(e - s) ) {
			    uv = 0xFFFD;
			}
			s = e + 1;
			goto NUM_ESCAPE_INSERT;
		    }
		    res = newSVpvn(s + 1, e - s - 1);
		    res = new_constant( NULL, 0, "charnames",
					res, NULL, s - 2, e - s + 3 );
		    if (has_utf8)
			sv_utf8_upgrade(res);
		    str = SvPV_const(res,len);
#ifdef EBCDIC_NEVER_MIND
		    /* charnames uses pack U and that has been
		     * recently changed to do the below uni->native
		     * mapping, so this would be redundant (and wrong,
		     * the code point would be doubly converted).
		     * But leave this in just in case the pack U change
		     * gets revoked, but the semantics is still
		     * desireable for charnames. --jhi */
		    {
			 UV uv = utf8_to_uvchr((const U8*)str, 0);
d3007 1
a3007 2
			 if (uv < 0x100) {
			      U8 tmpbuf[UTF8_MAXBYTES+1], *d;
d3009 8
a3016 9
			      d = uvchr_to_utf8(tmpbuf, UNI_TO_NATIVE(uv));
			      sv_setpvn(res, (char *)tmpbuf, d - tmpbuf);
			      str = SvPV_const(res, len);
			 }
		    }
#endif
		    /* If destination is not in utf8 but this new character is,
		     * recode the dest to utf8 */
		    if (!has_utf8 && SvUTF8(res)) {
a3019 1
			sv_utf8_upgrade(sv);
d3021 4
a3024 1
			SvGROW(sv, SvCUR(sv) + len + (STRLEN)(send - s) + 1);
d3027 157
a3183 1
		    } else if (len > (STRLEN)(e - s + 4)) { /* I _guess_ 4 is \N{} --jhi */
d3185 93
a3277 4
			/* See Note on sizing above.  (NOTE: SvCUR() is not set
			 * correctly here). */
			const STRLEN off = d - SvPVX_const(sv);
			d = SvGROW(sv, off + len + (STRLEN)(send - s) + 1) + off;
d3279 1
d3281 2
a3282 2
		    if (!dorange)
			native_range = FALSE; /* \N{} is guessed to be Unicode */
d3284 1
a3284 8
		    Copy(str, d, len, char);
		    d += len;
		    SvREFCNT_dec(res);
		  cont_scan:
		    s = e + 1;
		}
		else
		    yyerror("Missing braces on \\N{}");
a3354 2
		sv_utf8_upgrade(sv);

d3356 3
a3358 1
		SvGROW(sv, SvCUR(sv) + need + (STRLEN)(send - s) + 1);
d3689 1
a3689 1
						   newSVpvn(tmpbuf,len));
d3812 1
a3812 1
	    SvGROW(buf_sv, (STRLEN)(old_len + correct_length)) ;
d3821 1
d3852 1
a3852 1
S_filter_gets(pTHX_ register SV *sv, register PerlIO *fp, STRLEN append)
d3872 1
a3872 1
        return (sv_gets(sv, fp, append));
d4126 2
a4127 1
	if (*s == ';' || (s = SKIPSPACE1(s), *s == ';')) {
d4188 1
d4523 11
a4533 2
	len = UTF ? Perl_utf8_length(aTHX_ (U8 *) PL_linestart, (U8 *) s) : (STRLEN) (s - PL_linestart);
	Perl_croak(aTHX_ "Unrecognized character \\x%02X in column %d", *s & 255, (int) len + 1);
d4597 1
a4597 1
		sv_catpvs(PL_linestr, "LINE: while (<>) {");
d4636 1
d4638 1
a4638 1
	    if ((s = filter_gets(PL_linestr, PL_rsfp, 0)) == NULL) {
d4640 10
d4651 1
d4654 1
a4654 30
		if (PL_rsfp) {
		    if (PL_preprocess && !PL_in_eval)
			(void)PerlProc_pclose(PL_rsfp);
		    else if ((PerlIO *)PL_rsfp == PerlIO_stdin())
			PerlIO_clearerr(PL_rsfp);
		    else
			(void)PerlIO_close(PL_rsfp);
		    PL_rsfp = NULL;
		    PL_doextract = FALSE;
		}
		if (!PL_in_eval && (PL_minus_n || PL_minus_p)) {
#ifdef PERL_MAD
		    if (PL_madskills)
			PL_faketokens = 1;
#endif
		    if (PL_minus_p)
			sv_setpvs(PL_linestr, ";}continue{print;}");
		    else
			sv_setpvs(PL_linestr, ";}");
		    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
		    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
		    PL_last_lop = PL_last_uni = NULL;
		    PL_minus_n = PL_minus_p = 0;
		    goto retry;
		}
		PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
		PL_last_lop = PL_last_uni = NULL;
		sv_setpvs(PL_linestr,"");
		TOKEN(';');	/* not infinite loop because rsfp is NULL now */
	    }
d4657 1
a4657 1
	    else if (bof &&
a4661 21
#ifdef PERLIO_IS_STDIO
#  ifdef __GNU_LIBRARY__
#    if __GNU_LIBRARY__ == 1 /* Linux glibc5 */
#      define FTELL_FOR_PIPE_IS_BROKEN
#    endif
#  else
#    ifdef __GLIBC__
#      if __GLIBC__ == 1 /* maybe some glibc5 release had it like this? */
#        define FTELL_FOR_PIPE_IS_BROKEN
#      endif
#    endif
#  endif
#endif
#ifdef FTELL_FOR_PIPE_IS_BROKEN
		/* This loses the possibility to detect the bof
		 * situation on perl -P when the libc5 is being used.
		 * Workaround?  Maybe attach some extra state to PL_rsfp?
		 */
		if (!PL_preprocess)
		    bof = PerlIO_tell(PL_rsfp) == SvCUR(PL_linestr);
#else
a4662 1
#endif
d4682 2
a4683 1
	    incline(s);
a4685 2
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
	    update_debugger_info(PL_linestr, NULL, 0);
a4793 1
#ifndef MACOS_TRADITIONAL
d4809 1
a4809 1
			Newxz(newargv,PL_origargc+3,char*);
a4823 1
#endif
a4892 3
#ifdef MACOS_TRADITIONAL
    case '\312':
#endif
d5166 3
d5191 1
a5226 5
#ifdef USE_ITHREADS
			    GvUNIQUE_on(cGVOPx_gv(pl_yylval.opval));
#else
			    /* skip to avoid loading attributes.pm */
#endif
d5241 1
a5241 1
			CvLOCKED_on(PL_compcv);
d5723 1
a5723 3
		PL_expect = XTERM;
		deprecate_old(commaless_variable_list);
		return REPORT(','); /* grandfather non-comma-format format */
d5762 1
a5762 1
	    if (PL_lex_state == LEX_NORMAL)
d5903 1
a5903 1
	 if(PL_expect == XOPERATOR) {
d5906 1
a5906 1
    	          OPERATOR('?');
d5945 4
a5960 2
	    if (PL_expect != XOPERATOR)
		check_uni();
d5977 1
a5977 3
		PL_expect = XTERM;
		deprecate_old(commaless_variable_list);
		return REPORT(','); /* grandfather non-comma-format format */
d5992 1
a5992 3
		PL_expect = XTERM;
		deprecate_old(commaless_variable_list);
		return REPORT(','); /* grandfather non-comma-format format */
d6022 3
a6024 3
	if (PL_lex_inwhat && isDIGIT(*s) && ckWARN(WARN_SYNTAX))
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),"Can't use \\%c to mean $%c in expression",
			*s, *s);
d6086 1
d6097 1
a6097 1
	tmp = ((len == 1 && strchr("msyq", PL_tokenbuf[0])) ||
d6103 1
a6103 1
	if (!tmp && *s == ':' && s[1] == ':' && strNE(PL_tokenbuf, "CORE"))
a6109 12
	/* Is this a label? */
	if (!tmp && PL_expect == XSTATE
	      && d < PL_bufend && *d == ':' && *(d + 1) != ':') {
	    s = d + 1;
	    pl_yylval.pval = CopLABEL_alloc(PL_tokenbuf);
	    CLINE;
	    TOKEN(LABEL);
	}

	/* Check for keywords */
	tmp = keyword(PL_tokenbuf, len, 0);

d6120 39
d6192 3
a6194 3
		if (tmp == KEY_dump && ckWARN(WARN_MISC)) {
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
			    "dump() better written as CORE::dump()");
d6198 4
a6201 5
		if (hgv && tmp != KEY_x && tmp != KEY_CORE
			&& ckWARN(WARN_AMBIGUOUS))	/* never ambiguous */
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
		    	"Ambiguous call resolved as CORE::%s(), %s",
			 GvENAME(hgv), "qualify as such or use &");
d6223 1
d6317 23
a6339 13
		/* Do the explicit type check so that we don't need to force
		   the initialisation of the symbol table to have a real GV.
		   Beware - gv may not really be a PVGV, cv may not really be
		   a PVCV, (because of the space optimisations that gv_init
		   understands) But they're true if for this symbol there is
		   respectively a typeglob and a subroutine.
		*/
		cv = gv ? ((SvTYPE(gv) == SVt_PVGV)
		    /* Real typeglob, so get the real subroutine: */
			   ? GvCVu(gv)
		    /* A proxy for a subroutine in this package? */
			   : SvOK(gv) ? MUTABLE_CV(gv) : NULL)
		    : NULL;
d6362 2
a6363 1
			(tmp = intuit_method(s, gv, cv)))
d6365 1
d6373 1
a6373 1
                         ((!gv || !cv) &&
d6396 1
d6411 1
a6411 1
			if (*d == ')' && (sv = gv_const_sv(gv))) {
d6432 1
d6440 2
a6441 1
		if ((*s == '$' || *s == '{') && (!gv || !cv)) {
d6451 2
a6452 1
			&& (tmp = intuit_method(s, gv, cv)))
d6454 1
d6459 4
a6462 4
		    if (lastchar == '-' && ckWARN_d(WARN_AMBIGUOUS))
			Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
				"Ambiguous use of -%s resolved as -&%s()",
				PL_tokenbuf, PL_tokenbuf);
d6464 1
a6464 1
		    if ((sv = gv_const_sv(gv))) {
d6466 1
a6472 9
		    /* Resolve to GV now. */
		    if (SvTYPE(gv) != SVt_PVGV) {
			gv = gv_fetchpv(PL_tokenbuf, 0, SVt_PVCV);
			assert (SvTYPE(gv) == SVt_PVGV);
			/* cv must have been some sort of placeholder, so
			   now needs replacing with a real code reference.  */
			cv = GvCV(gv);
		    }

d6474 1
a6474 1
		    pl_yylval.opval = newCVREF(0, newGVOP(OP_GV, 0, gv));
d6542 1
a6542 1
			pl_yylval.opval = newCVREF(0, newGVOP(OP_GV, 0, gv));
d6571 12
d6594 1
d6597 7
a6603 8
		if ((lastchar == '*' || lastchar == '%' || lastchar == '&')
		    && ckWARN_d(WARN_AMBIGUOUS)) {
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
		  	"Operator or semicolon missing before %c%s",
			lastchar, PL_tokenbuf);
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
			"Ambiguous use of %c resolved as operator %c",
			lastchar, lastchar);
d6646 1
a6646 3
		if (PL_preprocess)
		    IoTYPE(GvIOp(gv)) = IoTYPE_PIPE;
		else if ((PerlIO*)PL_rsfp == PerlIO_stdin())
d6714 2
a6715 2
		    while ((s = filter_gets(PL_endwhite, PL_rsfp,
				 SvCUR(PL_endwhite))) != NULL) ;
d6904 8
a6911 2
	    PL_expect = (*s == '{') ? XTERMBLOCK : XTERM;
	    UNIBRACK(OP_ENTEREVAL);
d7282 2
d7664 7
a7670 1
		    const bool warnsyntax = ckWARN(WARN_SYNTAX);
d7681 30
a7710 2
			    if (warnsyntax && !strchr("$@@%*;[]&\\_", *p))
				bad_proto = TRUE;
d7714 4
d7719 3
a7721 2
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "Illegal character in prototype for %"SVf" : %s",
d7750 1
a7750 1
		    else if (*s != ';')
d7963 1
a7963 1
            tmp = allocmy(PL_tokenbuf);
d7971 1
a7971 1
            pl_yylval.opval->op_targ = allocmy(PL_tokenbuf);
d7990 1
a7990 1
	    tmp = pad_findmy(PL_tokenbuf);
d8041 2
a8042 1
    if (pit == '@@' && PL_lex_state != LEX_NORMAL && !PL_lex_brackets) {
a8045 1
		&& ckWARN(WARN_AMBIGUOUS)
d8053 2
a8054 2
                        "Possible unintended interpolation of %s in string",
                         PL_tokenbuf);
d9595 1
a9595 2
                if(ckWARN_d(WARN_SYNTAX))
                  Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "elseif should be elsif");
d11576 5
d11694 1
a11694 1
    register char * const e = d + destlen + 3;    /* two-character token, ending NUL */
d11849 12
d11866 3
a11868 1
    PERL_UNUSED_CONTEXT;
d11870 1
a11870 8
        char c = (char)ch;
        switch (c) {
            CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl);
            case GLOBAL_PAT_MOD:    *pmfl |= PMf_GLOBAL; break;
            case CONTINUE_PAT_MOD:  *pmfl |= PMf_CONTINUE; break;
            case ONCE_PAT_MOD:      *pmfl |= PMf_KEEP; break;
            case KEEPCOPY_PAT_MOD:  *pmfl |= PMf_KEEPCOPY; break;
        }
d11924 1
a11924 1
	pmflag(&pm->op_pmflags,*s++);
d11932 1
a11932 2
    if ((pm->op_pmflags & PMf_CONTINUE) && !(pm->op_pmflags & PMf_GLOBAL)
	    && ckWARN(WARN_REGEXP))
d11934 2
a11935 2
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), 
            "Use of /c modifier is meaningless without /g" );
d12004 1
a12004 1
	    pmflag(&pm->op_pmflags,*s++);
d12017 2
a12018 2
    if ((pm->op_pmflags & PMf_CONTINUE) && ckWARN(WARN_REGEXP)) {
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), "Use of /c modifier is meaningless in s///" );
d12186 1
a12186 1
	    deprecate_old("bare << to mean <<\"\"");
d12346 3
a12348 2
	if (!outer ||
	 !(PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = filter_gets(PL_linestr, PL_rsfp, 0))) {
d12352 2
a12374 2
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
	    update_debugger_info(PL_linestr, NULL, 0);
d12503 1
a12503 1
	    const PADOFFSET tmp = pad_findmy(d);
d12859 3
a12861 2
	if (!PL_rsfp ||
	 !(PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = filter_gets(PL_linestr, PL_rsfp, 0))) {
d12866 1
a12869 10
	/* we read a line, so increment our line counter */
	CopLINE_inc(PL_curcop);

	/* update debugger info */
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
	    update_debugger_info(PL_linestr, NULL, 0);

	/* having changed the buffer, we must update PL_bufend */
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	PL_last_lop = PL_last_uni = NULL;
d13023 1
a13023 2
	       if (ckWARN(WARN_SYNTAX))
		   Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
d13046 3
a13048 3
		    if (lastub && s == lastub + 1 && ckWARN(WARN_SYNTAX))
		        Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "Misplaced _ in number");
d13090 3
a13092 4
			    if (ckWARN_d(WARN_OVERFLOW))
				Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
					    "Integer overflow in %s number",
					    base);
d13119 1
a13119 2
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
d13124 4
a13127 4
		if (n > 4294967295.0 && ckWARN(WARN_PORTABLE))
		    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
				"%s number > %s non-portable",
				Base, max);
d13132 4
a13135 4
		if (u > 0xffffffff && ckWARN(WARN_PORTABLE))
		    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
				"%s number > %s non-portable",
				Base, max);
d13164 3
a13166 3
		if (lastub && s == lastub + 1 && ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
d13180 1
a13180 2
	    if (ckWARN(WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
d13192 2
a13193 3
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
d13204 3
a13206 3
		   if (lastub && s == lastub + 1 && ckWARN(WARN_SYNTAX))
		       Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Misplaced _ in number");
d13214 2
a13215 3
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
d13234 2
a13235 3
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
d13245 2
a13246 3
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
d13259 3
a13261 4
			(!isDIGIT(s[1]) && s[1] != '_'))
	   	    && ckWARN(WARN_SYNTAX))
		       Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Misplaced _ in number");
d13395 1
d13404 5
a13408 1
	    s = filter_gets(PL_linestr, PL_rsfp, 0);
d13410 1
a13410 3
	    tokenstart = PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = SvPVX(PL_linestr);
#else
	    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = SvPVX(PL_linestr);
d13412 1
a13412 4
	    PL_bufend = PL_bufptr + SvCUR(PL_linestr);
	    PL_last_lop = PL_last_uni = NULL;
	    if (!s) {
		s = PL_bufptr;
a13413 1
	    }
d13487 2
a13488 2
int
Perl_yywarn(pTHX_ const char *s)
d13501 1
a13501 1
Perl_yyerror(pTHX_ const char *s)
d13584 1
a13584 2
	if (ckWARN_d(WARN_SYNTAX))
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "%"SVf, SVfARG(msg));
d13615 1
a13615 1
	    /* UTF-16 little-endian? (or UTF32-LE?) */
d13617 1
a13617 1
		Perl_croak(aTHX_ "Unsupported script encoding UTF32-LE");
d13619 1
a13619 1
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF16-LE script encoding (BOM)\n");
a13620 1
	utf16le:
d13622 1
a13622 22
		U8 *news;
		I32 newlen;

		filter_add(utf16rev_textfilter, NULL);
		Newx(news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
		utf16_to_utf8_reversed(s, news,
				       PL_bufend - (char*)s - 1,
				       &newlen);
		sv_setpvn(PL_linestr, (const char*)news, newlen);
#ifdef PERL_MAD
		s = (U8*)SvPVX(PL_linestr);
  		Copy(news, s, newlen, U8);
		s[newlen] = '\0';
#endif
		Safefree(news);
		SvUTF8_on(PL_linestr);
		s = (U8*)SvPVX(PL_linestr);
#ifdef PERL_MAD
		/* FIXME - is this a general bug fix?  */
		s[newlen] = '\0';
#endif
		PL_bufend = SvPVX(PL_linestr) + newlen;
d13625 1
a13625 1
	    Perl_croak(aTHX_ "Unsupported script encoding UTF16-LE");
a13633 1
	utf16be:
d13635 1
a13635 13
		U8 *news;
		I32 newlen;

		filter_add(utf16_textfilter, NULL);
		Newx(news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
		utf16_to_utf8(s, news,
			      PL_bufend - (char*)s,
			      &newlen);
		sv_setpvn(PL_linestr, (const char*)news, newlen);
		Safefree(news);
		SvUTF8_on(PL_linestr);
		s = (U8*)SvPVX(PL_linestr);
		PL_bufend = SvPVX(PL_linestr) + newlen;
d13638 1
a13638 1
	    Perl_croak(aTHX_ "Unsupported script encoding UTF16-BE");
d13653 1
a13653 1
		       Perl_croak(aTHX_ "Unsupported script encoding UTF32-BE");
d13660 1
d13662 4
a13665 1
		  goto utf16be;
d13682 1
d13684 4
a13687 1
	      goto utf16le;
d13696 1
a13696 1
utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
d13699 18
a13716 2
    const STRLEN old = SvCUR(sv);
    const I32 count = FILTER_READ(idx+1, sv, maxlen);
d13718 8
a13725 5
			  "utf16_textfilter(%p): %d %d (%d)\n",
			  FPTR2DPTR(void *, utf16_textfilter),
			  idx, maxlen, (int) count));
    if (count) {
	U8* tmps;
d13727 80
a13806 5
	Newx(tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	Copy(SvPVX_const(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX_const(sv) + old, tmps + old,
		      SvCUR(sv) - old, &newlen);
	sv_usepvn(sv, (char*)tmps, (STRLEN)newlen + old);
d13808 6
a13813 2
    DEBUG_P({sv_dump(sv);});
    return SvCUR(sv);
d13816 2
a13817 2
static I32
utf16rev_textfilter(pTHX_ int idx, SV *sv, int maxlen)
d13819 14
a13832 15
    dVAR;
    const STRLEN old = SvCUR(sv);
    const I32 count = FILTER_READ(idx+1, sv, maxlen);
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "utf16rev_textfilter(%p): %d %d (%d)\n",
			  FPTR2DPTR(void *, utf16rev_textfilter),
			  idx, maxlen, (int) count));
    if (count) {
	U8* tmps;
	I32 newlen;
	Newx(tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	Copy(SvPVX_const(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX_const(sv) + old, tmps + old,
		      SvCUR(sv) - old, &newlen);
	sv_usepvn(sv, (char*)tmps, (STRLEN)newlen + old);
d13834 2
a13835 2
    DEBUG_P({ sv_dump(sv); });
    return count;
d13855 1
a13855 1
Perl_scan_vstring(pTHX_ const char *s, const char *e, SV *sv)
d13897 3
a13899 3
		    if (orev > rev && ckWARN_d(WARN_OVERFLOW))
			Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
				    "Integer overflow in decimal number");
d13925 12
@


1.13
log
@- fix for pr 6196 from upstream git

ok millert@@
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 3
a14 1
 *   "It all comes from here, the stench and the peril."  --Frodo
d232 1
a232 1
#   define REPORT(retval) tokereport((I32)retval)
d379 1
a379 1
S_tokereport(pTHX_ I32 rv)
d382 3
d411 1
a411 1
	    Perl_sv_catpvf(aTHX_ report, "(ival=%"IVdf")", (IV)pl_yylval.ival);
d415 1
a415 1
				    PL_op_name[pl_yylval.ival]);
d418 1
a418 1
	    Perl_sv_catpvf(aTHX_ report, "(pval=\"%s\")", pl_yylval.pval);
d421 1
a421 1
	    if (pl_yylval.opval) {
d423 2
a424 2
				    PL_op_name[pl_yylval.opval->op_type]);
		if (pl_yylval.opval->op_type == OP_CONST) {
d426 1
a426 1
			SvPEEK(cSVOPx_sv(pl_yylval.opval)));
d446 3
d499 2
d548 1
a548 7
    else if (
#ifdef EBCDIC
	iscntrl(PL_multi_close)
#else
	PL_multi_close < 32 || PL_multi_close == 127
#endif
	) {
d579 3
d595 2
d612 2
d630 3
d715 1
a715 1
		: (AV*)SvREFCNT_inc(oparser->rsfp_filters);
d752 2
d759 2
a760 2
    else if (parser->rsfp && parser->old_parser
			  && parser->rsfp != parser->old_parser->rsfp)
d803 2
d900 2
a901 2
		    GvHV(gv2) = (HV*)SvREFCNT_inc(GvHV(*gvp));
		    GvAV(gv2) = (AV*)SvREFCNT_inc(GvAV(*gvp));
d921 2
d945 2
d973 2
d1027 2
d1034 1
d1117 1
a1117 1
		sv_catpvn(PL_linestr, ";}", 2);
d1119 1
a1119 1
		sv_setpvn(PL_linestr, ";}", 2);
d1125 1
a1125 1
		sv_catpvn(PL_linestr,";", 1);
d1127 1
a1127 1
		sv_setpvn(PL_linestr,";", 1);
d1179 1
a1179 1
	if (PERLDB_LINE && PL_curstash != PL_debstash)
d1249 3
d1319 1
a1319 1
	sv_setpvn(sv, "", 0);
d1333 1
a1333 1
	sv_free((SV*)((*where)->mad_val));
d1357 6
d1387 3
a1389 3
    SV * const sv = newSVpvn(start,len);
    if (UTF && !IN_BYTES && is_utf8_string((const U8*)start, len))
	SvUTF8_on(sv);
d1417 2
d1463 3
d1498 3
d1535 2
d1607 2
d1622 1
a1622 3
	pv = sv_2mortal(newSVpvn(SvPVX_const(pv), len));
	if (SvUTF8(sv))
	    SvUTF8_on(pv);
d1689 1
a1689 3
	    SV * const nsv = newSVpvn(p, len);
	    if (SvUTF8(sv))
		SvUTF8_on(nsv);
d1846 1
a1846 1
		sv_setpvn(PL_thistoken,"",0);
d1934 1
d1936 1
d1946 2
a1947 1
    SV *sv = newSV(send - start);		/* sv for the constant */
d1953 19
a1971 1
    I32  this_utf8 = UTF;			/* The source string is assumed to be UTF8 */
d1978 2
d2246 1
a2246 1
	    /* \132 indicates an octal constant */
d2252 1
a2252 1
		    uv = grok_oct(s, &len, &flags, NULL);
d2257 1
a2257 1
	    /* \x24 indicates a hex constant */
d2272 1
a2272 1
		    uv = grok_hex(s, &len, &flags, NULL);
d2279 1
a2279 1
			uv = grok_hex(s, &len, &flags, NULL);
d2285 4
a2288 4
		/* Insert oct or hex escaped character.
		 * There will always enough room in sv since such
		 * escapes will be longer than any UTF-8 sequence
		 * they can end up as. */
d2290 5
a2294 4
		/* We need to map to chars to ASCII before doing the tests
		   to cover EBCDIC
		*/
		if (!UNI_IS_INVARIANT(NATIVE_TO_UNI(uv))) {
d2296 12
a2307 33
		        /* Might need to recode whatever we have
			 * accumulated so far if it contains any
			 * hibit chars.
			 *
			 * (Can't we keep track of that and avoid
			 *  this rescan? --jhi)
			 */
			int hicount = 0;
			U8 *c;
			for (c = (U8 *) SvPVX(sv); c < (U8 *)d; c++) {
			    if (!NATIVE_IS_INVARIANT(*c)) {
			        hicount++;
			    }
			}
			if (hicount) {
			    const STRLEN offset = d - SvPVX_const(sv);
			    U8 *src, *dst;
			    d = SvGROW(sv, SvLEN(sv) + hicount + 1) + offset;
			    src = (U8 *)d - 1;
			    dst = src+hicount;
			    d  += hicount;
			    while (src >= (const U8 *)SvPVX_const(sv)) {
			        if (!NATIVE_IS_INVARIANT(*src)) {
				    const U8 ch = NATIVE_TO_ASCII(*src);
				    *dst-- = (U8)UTF8_EIGHT_BIT_LO(ch);
				    *dst-- = (U8)UTF8_EIGHT_BIT_HI(ch);
			        }
			        else {
				    *dst-- = *src;
			        }
				src--;
			    }
                        }
d2310 2
a2311 3
                    if (has_utf8 || uv > 255) {
		        d = (char*)uvchr_to_utf8((U8*)d, uv);
			has_utf8 = TRUE;
d2332 2
a2333 1
 	    /* \N{LATIN SMALL LETTER A} is a named character */
d2348 2
a2349 1
		        /* \N{U+...} */
d2387 2
d2390 1
a2390 2
			const char * const ostart = SvPVX_const(sv);
			SvCUR_set(sv, d - ostart);
d2394 2
a2395 2
			/* this just broke our allocation above... */
			SvGROW(sv, (STRLEN)(send - start));
d2398 1
a2398 3
		    }
		    if (len > (STRLEN)(e - s + 4)) { /* I _guess_ 4 is \N{} --jhi */
			const char * const odest = SvPVX_const(sv);
d2400 4
a2403 2
			SvGROW(sv, (SvLEN(sv) + len - (e - s + 4)));
			d = SvPVX(sv) + (d - odest);
d2468 3
a2470 3
	/* If we started with encoded form, or already know we want it
	   and then encode the next character */
	if ((has_utf8 || this_utf8) && !NATIVE_IS_INVARIANT((U8)(*s))) {
d2472 9
d2483 14
a2496 3
	    s += len;
	    if (need > len) {
		/* encoded value larger than old, need extra space (NOTE: SvCUR() not set here) */
d2498 1
a2498 1
		d = SvGROW(sv, SvLEN(sv) + (need-len)) + off;
d2500 2
a2502 1
	    has_utf8 = TRUE;
d2591 3
d2759 2
d2887 2
d2929 2
d2986 3
d3012 2
d3248 3
d3357 1
a3357 1
		PL_thiswhite = (SV*)PL_thismad->mad_val;
d3710 1
a3710 1
		sv_free((SV*)PL_preambleav);
d3713 3
a3746 2
	    if (PL_minus_E)
		sv_catpvs(PL_linestr,"use feature ':5.10';");
d3751 1
a3751 1
	    if (PERLDB_LINE && PL_curstash != PL_debstash)
d3789 1
a3789 1
		sv_setpvn(PL_linestr,"",0);
d3834 1
a3834 1
		    sv_setpvn(PL_linestr, "", 0);
d3844 1
a3844 1
	if (PERLDB_LINE && PL_curstash != PL_debstash)
d4000 8
a4007 1
			    if (*d1 == 'M' || *d1 == 'm' || *d1 == 'C') {
d4024 1
a4024 1
			if ((PERLDB_LINE && !oldpdb) ||
d4029 1
a4029 1
			    sv_setpvn(PL_linestr, "", 0);
d4034 1
a4034 1
			    if (PERLDB_LINE)
d4128 1
a4128 1
			    sv_setpvn(PL_thiswhite, "", 0);
d4300 4
a4303 1
	/* FALL THROUGH */
d4695 1
a4695 1
			sv_catpvn(PL_thiswhite,"}",1);
d4732 1
a4732 1
		Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), PL_warn_nosemi);
d5388 1
a5388 1
			Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), PL_warn_nosemi);
d5470 1
a5470 1
			   : SvOK(gv) ? (CV *) gv : NULL)
d5619 1
a5619 1
			const char *proto = SvPV_const((SV*)cv, protolen);
d6448 1
a6448 3
			sv = newSVpvn(b, d-b);
			if (DO_UTF8(PL_lex_stuff))
			    SvUTF8_on(sv);
d6718 1
a6718 1
		    SV *nametoke;
d6757 1
a6757 1
		    sv_setpvn(PL_subname,"?",1);
d7171 3
d10562 2
d10626 2
d10663 1
a10663 1
  	pv = sv_2mortal(newSVpvn(s, len));
d10665 1
a10665 1
  	typesv = sv_2mortal(newSVpvn(type, typelen));
d10722 3
d10768 2
d10924 2
d10951 1
d10972 1
a10972 1
	    MAGIC *mg = mg_find((SV*)PL_curstash, PERL_MAGIC_symtab);
d10975 1
a10975 1
		mg = sv_magicext((SV*)PL_curstash, 0, PERL_MAGIC_symtab, 0, 0,
d11021 2
d11122 3
a11124 3
    I32 squash;
    I32 del;
    I32 complement;
d11129 2
d11228 2
d11401 1
a11401 1
	sv_setpvn(tmpstr,"",0);   /* avoid "uninitialized" warning */
d11438 1
a11438 1
	if (PERLDB_LINE && PL_curstash != PL_debstash)
a11492 1

d11496 2
d11694 2
d11937 1
a11937 1
	if (PERLDB_LINE && PL_curstash != PL_debstash)
d12036 2
d12420 2
a12421 2
    SV* savewhite;
    
d12428 2
d12556 1
a12556 1
    PL_compcv = (CV*)newSV_type(is_format ? SVt_PVFM : SVt_PVCV);
d12561 1
a12561 1
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc_simple(outsidecv);
d12574 3
d12593 2
d12642 1
a12642 1
	SV * const where_sv = sv_2mortal(newSVpvs("next char "));
d12693 3
d12874 3
d12898 1
a12898 1
	sv_setpvn(sv, "", 0);
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d695 1
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d26 2
a27 2
#define yychar	PL_yychar
#define yylval	PL_yylval
d29 73
a101 6
static const char ident_too_long[] =
  "Identifier too long";
static const char c_without_g[] =
  "Use of /c modifier is meaningless without /g";
static const char c_in_subst[] =
  "Use of /c modifier is meaningless in s///";
a102 1
static void restore_rsfp(pTHX_ void *f);
d108 8
a179 16
#ifdef USE_PURE_BISON
#  ifndef YYMAXLEVEL
#    define YYMAXLEVEL 100
#  endif
YYSTYPE* yylval_pointer[YYMAXLEVEL];
int* yychar_pointer[YYMAXLEVEL];
int yyactlevel = -1;
#  undef yylval
#  undef yychar
#  define yylval (*yylval_pointer[yyactlevel])
#  define yychar (*yychar_pointer[yyactlevel])
#  define PERL_YYLEX_PARAM yylval_pointer[yyactlevel],yychar_pointer[yyactlevel]
#  undef yylex
#  define yylex()      Perl_yylex_r(aTHX_ yylval_pointer[yyactlevel],yychar_pointer[yyactlevel])
#endif

d189 12
d230 1
a230 1
#   define REPORT(retval) tokereport(s,(int)retval)
d242 13
a254 13
#define LOOPX(f) return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)LOOPEX))
#define FTST(f)  return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)UNIOP))
#define FUN0(f)  return (yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC0))
#define FUN1(f)  return (yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC1))
#define BOop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITOROP)))
#define BAop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITANDOP)))
#define SHop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)SHIFTOP)))
#define PWop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)POWOP)))
#define PMop(f)  return(yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MATCHOP))
#define Aop(f)   return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)ADDOP)))
#define Mop(f)   return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MULOP)))
#define Eop(f)   return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)EQOP))
#define Rop(f)   return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)RELOP))
d258 2
d261 3
a263 3
#define UNI(f) { \
	yylval.ival = f; \
	PL_expect = XTERM; \
d269 1
a269 1
	s = skipspace(s); \
d272 2
d276 1
a276 1
	yylval.ival = f; \
d281 1
a281 1
	s = skipspace(s); \
d286 1
a286 1
#define OLDLOP(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LSTOP)
d290 1
a290 1
/* how to interpret the yylval associated with the token */
d294 1
a294 1
    TOKENTYPE_OPNUM, /* yylval.ival contains an opcode number */
d300 5
a304 2
static struct debug_tokens { const int token, type; const char *name; }
  const debug_tokens[] =
d316 1
d319 2
d332 1
d368 1
d371 1
a371 1
    { 0,		TOKENTYPE_NONE,		0 }
d374 1
a374 1
/* dump the returned token in rv, plus any optional arg in yylval */
d377 1
a377 1
S_tokereport(pTHX_ const char* s, I32 rv)
d379 1
d381 1
a381 1
	const char *name = Nullch;
d384 1
a384 1
	SV* const report = newSVpvn("<== ", 4);
d394 1
a394 1
	    Perl_sv_catpvf(aTHX_ report, "%s", name);
d398 1
a398 1
	    Perl_sv_catpvf(aTHX_ report, "EOF");
d406 1
a406 1
	    Perl_sv_catpvf(aTHX_ report, "(ival=%"IVdf")", yylval.ival);
d410 1
a410 1
				    PL_op_name[yylval.ival]);
d413 1
a413 1
	    Perl_sv_catpvf(aTHX_ report, "(pval=\"%s\")", yylval.pval);
d416 1
a416 1
	    if (yylval.opval) {
d418 2
a419 2
				    PL_op_name[yylval.opval->op_type]);
		if (yylval.opval->op_type == OP_CONST) {
d421 1
a421 1
			SvPEEK(cSVOPx_sv(yylval.opval)));
d426 1
a426 1
		Perl_sv_catpv(aTHX_ report, "(opval=null)");
d440 2
a441 3
    SV* tmp = newSVpvn("", 0);
    PerlIO_printf(Perl_debug_log, fmt,
		  pv_display(tmp, (char *)s, strlen(s), 0, 60));
d450 2
a451 2
 * This subroutine detects &&= and ||= and turns an ANDAND or OROR
 * into an OP_ANDASSIGN or OP_ORASSIGN
d457 1
d461 1
a461 1
	    yylval.ival = OP_ANDASSIGN;
d463 3
a465 1
	    yylval.ival = OP_ORASSIGN;
d487 1
d502 2
a503 1
	    for (t = PL_oldoldbufptr; *t && (isALNUM_lazy_if(t,UTF) || *t == ':'); t++) ;
d521 1
a521 1
 * If it's called with (char *)NULL then it cauterizes the line buffer.
d530 1
d559 22
d586 1
a586 1
Perl_deprecate(pTHX_ char *s)
d593 1
a593 1
Perl_deprecate_old(pTHX_ char *s)
a608 11
 * depcom
 * Deprecate a comma-less variable list.
 */

STATIC void
S_depcom(pTHX)
{
    deprecate_old("comma-less variable list");
}

/*
d646 2
d650 10
a659 2
 * Initialize variables.  Uses the Perl save_stack to save its state (for
 * recursive calls to the parser).
d663 1
a663 1
Perl_lex_start(pTHX_ SV *line)
d665 2
a666 1
    const char *s;
d668 3
d672 80
a751 64
    SAVEI32(PL_lex_dojoin);
    SAVEI32(PL_lex_brackets);
    SAVEI32(PL_lex_casemods);
    SAVEI32(PL_lex_starts);
    SAVEI32(PL_lex_state);
    SAVEVPTR(PL_lex_inpat);
    SAVEI32(PL_lex_inwhat);
    if (PL_lex_state == LEX_KNOWNEXT) {
	I32 toke = PL_nexttoke;
	while (--toke >= 0) {
	    SAVEI32(PL_nexttype[toke]);
	    SAVEVPTR(PL_nextval[toke]);
	}
	SAVEI32(PL_nexttoke);
    }
    SAVECOPLINE(PL_curcop);
    SAVEPPTR(PL_bufptr);
    SAVEPPTR(PL_bufend);
    SAVEPPTR(PL_oldbufptr);
    SAVEPPTR(PL_oldoldbufptr);
    SAVEPPTR(PL_last_lop);
    SAVEPPTR(PL_last_uni);
    SAVEPPTR(PL_linestart);
    SAVESPTR(PL_linestr);
    SAVEGENERICPV(PL_lex_brackstack);
    SAVEGENERICPV(PL_lex_casestack);
    SAVEDESTRUCTOR_X(restore_rsfp, PL_rsfp);
    SAVESPTR(PL_lex_stuff);
    SAVEI32(PL_lex_defer);
    SAVEI32(PL_sublex_info.sub_inwhat);
    SAVESPTR(PL_lex_repl);
    SAVEINT(PL_expect);
    SAVEINT(PL_lex_expect);

    PL_lex_state = LEX_NORMAL;
    PL_lex_defer = 0;
    PL_expect = XSTATE;
    PL_lex_brackets = 0;
    Newx(PL_lex_brackstack, 120, char);
    Newx(PL_lex_casestack, 12, char);
    PL_lex_casemods = 0;
    *PL_lex_casestack = '\0';
    PL_lex_dojoin = 0;
    PL_lex_starts = 0;
    PL_lex_stuff = Nullsv;
    PL_lex_repl = Nullsv;
    PL_lex_inpat = 0;
    PL_nexttoke = 0;
    PL_lex_inwhat = 0;
    PL_sublex_info.sub_inwhat = 0;
    PL_linestr = line;
    if (SvREADONLY(PL_linestr))
	PL_linestr = sv_2mortal(newSVsv(PL_linestr));
    s = SvPV_const(PL_linestr, len);
    if (!len || s[len-1] != ';') {
	if (!(SvFLAGS(PL_linestr) & SVs_TEMP))
	    PL_linestr = sv_2mortal(newSVsv(PL_linestr));
	sv_catpvn(PL_linestr, "\n;", 2);
    }
    SvTEMP_off(PL_linestr);
    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = SvPVX(PL_linestr);
    PL_bufend = PL_bufptr + SvCUR(PL_linestr);
    PL_last_lop = PL_last_uni = Nullch;
    PL_rsfp = 0;
d754 1
d764 1
d779 1
a779 1
S_incline(pTHX_ char *s)
d781 4
a784 4
    char *t;
    char *n;
    char *e;
    char ch;
d789 2
a790 1
    while (SPACE_OR_TAB(*s)) s++;
d799 2
a800 1
    while (SPACE_OR_TAB(*s)) s++;
d803 1
d814 3
a816 1
	for (t = s; !isSPACE(*t); t++) ;
a823 2
    ch = *t;
    *t = '\0';
d825 1
d827 13
a839 2
	const char *cf = CopFILE(PL_curcop);
	if (cf && strlen(cf) > 7 && strnEQ(cf, "(eval ", 6)) {
d842 7
a848 6
	    char smallbuf[256], smallbuf2[256];
	    char *tmpbuf, *tmpbuf2;
	    GV **gvp, *gv2;
	    STRLEN tmplen = strlen(cf);
	    STRLEN tmplen2 = strlen(s);
	    if (tmplen + 3 < sizeof smallbuf)
d851 5
a855 10
		Newx(tmpbuf, tmplen + 3, char);
	    if (tmplen2 + 3 < sizeof smallbuf2)
		tmpbuf2 = smallbuf2;
	    else
		Newx(tmpbuf2, tmplen2 + 3, char);
	    tmpbuf[0] = tmpbuf2[0] = '_';
	    tmpbuf[1] = tmpbuf2[1] = '<';
	    memcpy(tmpbuf + 2, cf, ++tmplen);
	    memcpy(tmpbuf2 + 2, s, ++tmplen2);
	    ++tmplen; ++tmplen2;
d858 18
d877 1
a877 1
		if (!isGV(gv2))
d879 7
a885 4
		/* adjust ${"::_<newfilename"} to store the new file name */
		GvSV(gv2) = newSVpvn(tmpbuf2 + 2, tmplen2 - 2);
		GvHV(gv2) = (HV*)SvREFCNT_inc(GvHV(*gvp));
		GvAV(gv2) = (AV*)SvREFCNT_inc(GvAV(*gvp));
a887 1
	    if (tmpbuf2 != smallbuf2) Safefree(tmpbuf2);
d891 1
a891 1
	CopFILE_set(PL_curcop, s);
a892 1
    *t = ch;
d896 92
d997 11
d1011 3
d1015 1
d1045 3
d1049 1
d1052 4
d1057 1
a1057 1
			     (prevlen = SvCUR(PL_linestr)))) == Nullch)
d1059 16
d1076 1
d1078 5
a1082 1
		sv_setpv(PL_linestr,
d1084 1
d1088 3
d1092 1
d1096 3
d1100 1
d1104 5
a1108 1
		= SvPVX(PL_linestr);
d1110 1
a1110 1
	    PL_last_lop = PL_last_uni = Nullch;
d1125 1
a1125 1
	    PL_rsfp = Nullfp;
d1151 3
a1153 2
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
	    SV * const sv = NEWSV(85,0);
d1155 9
a1163 6
	    sv_upgrade(sv, SVt_PVMG);
	    sv_setpvn(sv,PL_bufptr,PL_bufend-PL_bufptr);
            (void)SvIOK_on(sv);
            SvIV_set(sv, 0);
	    av_store(CopFILEAV(PL_curcop),(I32)CopLINE(PL_curcop),sv);
	}
d1165 2
d1181 3
a1183 2
    char *s;
    char *t;
d1189 3
a1191 1
    for (s = PL_last_uni; isALNUM_lazy_if(s,UTF) || *s == '-'; s++) ;
d1194 1
a1195 2
	const char ch = *s;
        *s = '\0';
d1197 2
a1198 3
		   "Warning: Use of \"%s\" without parentheses is ambiguous",
		   PL_last_uni);
        *s = ch;
d1220 2
a1221 1
    yylval.ival = f;
d1227 4
d1233 1
d1236 1
a1236 1
    s = skipspace(s);
d1243 70
d1318 2
a1319 2
 * will need to set PL_nextval[], and possibly PL_expect to ensure the lexer
 * handles the token correctly.
d1325 11
d1343 11
d1360 2
a1361 1
 * it calls S_force_word to stick the next word into the PL_next lookahead.
d1365 1
a1365 1
 *   int token   : PL_next will be this type of bare word (e.g., METHOD,WORD)
d1376 1
d1380 1
a1380 1
    start = skipspace(start);
d1387 1
a1387 1
	if (check_keyword && keyword(PL_tokenbuf, len))
d1389 3
d1393 1
a1393 1
	    s = skipspace(s);
d1400 6
a1405 4
	PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST,0, newSVpv(PL_tokenbuf,0));
	PL_nextval[PL_nexttoke].opval->op_private |= OPpCONST_BARE;
	if (UTF && !IN_BYTES && is_utf8_string((U8*)PL_tokenbuf, len))
	    SvUTF8_on(((SVOP*)PL_nextval[PL_nexttoke].opval)->op_sv);
d1423 6
a1428 3
    if (s && *s) {
	OP* const o = (OP*)newSVOP(OP_CONST, 0, newSVpv(s,0));
	PL_nextval[PL_nexttoke].opval = o;
d1435 6
a1440 4
	    gv_fetchpv(s, PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : TRUE,
		kind == '$' ? SVt_PV :
		kind == '@@' ? SVt_PVAV :
		kind == '%' ? SVt_PVHV :
d1442 1
a1442 1
		);
d1483 2
a1484 1
    OP *version = Nullop;
d1486 3
d1490 1
a1490 1
    s = skipspace(s);
d1498 6
d1506 2
a1507 2
            s = scan_num(s, &yylval);
            version = yylval.opval;
d1510 1
a1510 1
		(void)SvUPGRADE(ver, SVt_PVNV);
d1515 8
a1522 1
	else if (guessing)
d1524 1
d1527 7
d1535 2
a1536 1
    PL_nextval[PL_nexttoke].opval = version;
d1553 1
d1588 1
a1588 1
       return new_constant(NULL, 0, "q", sv, pv, "q");
d1610 1
a1610 1
 * Assumes that yylval.ival is the op we're creating (e.g. OP_LCFIRST).
d1613 1
a1613 1
 * make (we return THING if yylval.ival is OP_NULL, PMFUNC otherwise).
d1627 2
a1628 1
    register const I32 op_type = yylval.ival;
d1631 2
a1632 2
	yylval.opval = PL_lex_op;
	PL_lex_op = Nullop;
d1641 1
a1641 1
	    const char *p = SvPV_const(sv, len);
d1648 13
a1660 2
	yylval.opval = (OP*)newSVOP(op_type, 0, sv);
	PL_lex_stuff = Nullsv;
d1665 1
a1665 1
    PL_sublex_info.sub_inwhat = op_type;
d1671 2
a1672 2
	yylval.opval = PL_lex_op;
	PL_lex_op = Nullop;
d1690 1
d1694 1
a1694 1
    SAVEI32(PL_lex_dojoin);
d1698 1
a1698 1
    SAVEI32(PL_lex_state);
d1700 1
a1700 1
    SAVEI32(PL_lex_inwhat);
d1714 1
a1714 1
    PL_lex_stuff = Nullsv;
d1719 1
a1719 1
    PL_last_lop = PL_last_uni = Nullch;
d1736 1
a1736 1
	PL_lex_inpat = Nullop;
d1749 1
d1751 1
a1751 1
	SV * const sv = newSVpvn("",0);
d1755 1
a1755 1
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
d1770 1
a1770 1
	PL_last_lop = PL_last_uni = Nullch;
d1787 1
a1787 1
	    PL_lex_repl = Nullsv;
d1792 14
d1821 1
a1821 1
  It looks at lex_inwhat and PL_lex_inpat to find out whether it's
d1823 1
a1823 1
  (lex_inwhat & OP_TRANS is true), or a double-quoted string.
d1825 2
a1826 2
  Returns a pointer to the character scanned up to. Iff this is
  advanced from the start pointer supplied (ie if anything was
d1828 1
a1828 1
  in yylval. Caller must intuit reason for not parsing further
d1835 2
a1836 2
      constants: \x3
      backrefs: \1 (deprecated in substitution replacements)
d1842 4
a1845 2
    of the string, which indicates a range.  scan_const expands the
    range to the full set of intermediate characters.
d1850 2
a1851 2
      constants: \x3
      backrefs: \1 (deprecated)
d1859 4
a1862 1
  @@ in pattern could be: @@foo, @@{foo}, @@$foo, @@'foo, @@::foo.
d1866 1
a1866 1
  followed by one of ")| \n\t"
d1872 4
a1875 4
          handle transliteration ranges
	  skip regexp comments
	  skip # initiated comments in //x patterns
	  check for embedded @@foo
d1878 2
a1879 2
	      leave intact backslashes from leave (below)
	      deprecate \1 in strings and sub replacements
d1882 6
a1887 5
	          handle - in a transliteration (becomes a literal -)
		  handle \132 octal characters
		  handle 0x15 hex characters
		  handle \cV (control V)
		  handle printf backslashes (\f, \r, \n, etc)
d1897 1
d1899 1
a1899 1
    SV *sv = NEWSV(93, send - start);		/* sv for the constant */
d1909 1
a1911 5
    const char *leaveit =	/* set of acceptably-backslashed characters */
	PL_lex_inpat
	    ? "\\.^$@@AGZdDwWsSbBpPXC+*?|()-nrtfeaxz0123456789[{]} \t\n\r\f\v#"
	    : "";

d1928 9
a1936 1
		if (has_utf8) {
d1949 9
d1959 1
d1961 25
a1985 4
		d -= 2;				/* eat the first char and the - */

		min = (U8)*d;			/* first char in range */
		max = (U8)d[1];			/* last char in range  */
d2010 23
a2032 1
			*d++ = (char)i;
d2048 5
a2052 1
		if (has_utf8) {
d2064 1
d2079 1
a2079 1
		     || ((s[2] == 'p' || s[2] == '?') && s[3] == '{'))
d2111 8
a2118 3
	else if (*s == '@@' && s[1]
		 && (isALNUM_lazy_if(s+1,UTF) || strchr(":'{$+-", s[1])))
	    break;
a2135 7
	    /* some backslashes we leave behind */
	    if (*leaveit && *s && strchr(leaveit, *s)) {
		*d++ = NATIVE_TO_NEED(has_utf8,'\\');
		*d++ = NATIVE_TO_NEED(has_utf8,*s++);
		continue;
	    }

d2151 5
d2169 1
a2169 2
		    if (isALNUM(*s) &&
			*s != '_' &&
d2172 2
a2173 2
			       "Unrecognized escape \\%c passed through",
			       *s);
d2271 4
d2306 3
d2313 2
a2314 2
		    res = new_constant( Nullch, 0, "charnames",
					res, Nullsv, "\\N{...}" );
d2355 4
d2422 2
a2423 2
	    const UV uv       = (this_utf8) ? utf8n_to_uvchr((U8*)s, send - s, &len, 0) : (UV) ((U8) *s);
	    const STRLEN need = UNISKIP(NATIVE_TO_UNI(uv));
d2430 1
a2430 1
	    d = (char*)uvchr_to_utf8((U8*)d, uv);
d2432 4
d2467 1
a2467 1
    /* return the substring (via yylval) only if we parsed anything */
d2469 21
a2489 9
	if ( PL_hints & ( PL_lex_inpat ? HINT_NEW_RE : HINT_NEW_STRING ) )
	    sv = new_constant(start, s - start, (PL_lex_inpat ? "qr" : "q"),
			      sv, Nullsv,
			      ( PL_lex_inwhat == OP_TRANS
				? "tr"
				: ( (PL_lex_inwhat == OP_SUBST && !PL_lex_inpat)
				    ? "s"
				    : "qq")));
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
d2519 1
d2582 1
d2584 2
a2585 1
		    if ((int)strlen(tmpbuf) > 1 && gv_fetchpv(tmpbuf,FALSE, SVt_PV))
d2603 1
a2603 1
		    else if (seen['\''] || seen['"'])
d2635 1
a2635 1
		    if (keyword(tmpbuf, d - tmpbuf))
d2674 1
a2674 1
S_intuit_method(pTHX_ char *start, GV *gv)
d2676 1
d2681 3
d2686 1
a2686 2
	CV *cv;
	if (GvIO(gv))
d2688 9
a2696 7
	if ((cv = GvCVu(gv))) {
	    const char *proto = SvPVX_const(cv);
	    if (proto) {
		if (*proto == ';')
		    proto++;
		if (*proto == '*')
		    return 0;
d2699 1
a2699 1
	    gv = 0;
d2708 2
a2709 1
	if (gv || PL_last_lop_op == OP_PRINT || isUPPER(*PL_tokenbuf))
d2711 7
a2717 1
	s = skipspace(s);
d2722 1
a2722 1
    if (!keyword(tmpbuf, len)) {
d2726 3
d2731 1
a2731 1
	indirgv = gv_fetchpv(tmpbuf, FALSE, SVt_PVCV);
d2735 5
a2739 2
	if (!gv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, FALSE)) {
	    s = skipspace(s);
d2743 2
a2744 1
	    PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0,
d2746 3
a2748 1
	    PL_nextval[PL_nexttoke].opval->op_private = OPpCONST_BARE;
d2752 3
a2760 22
/*
 * S_incl_perldb
 * Return a string of Perl code to load the debugger.  If PERL5DB
 * is set, it will return the contents of that, otherwise a
 * compile-time require of perl5db.pl.
 */

STATIC const char*
S_incl_perldb(pTHX)
{
    if (PL_perldb) {
	const char * const pdb = PerlEnv_getenv("PERL5DB");

	if (pdb)
	    return pdb;
	SETERRNO(0,SS_NORMAL);
	return "BEGIN { require 'perl5db.pl' }";
    }
    return "";
}


d2781 1
d2783 4
a2786 1
	return Nullsv;
d2791 2
a2792 2
	datasv = NEWSV(255,0);
    (void)SvUPGRADE(datasv, SVt_PVIO);
d2796 2
a2797 1
			  IoANY(datasv), SvPV_nolen(datasv)));
d2808 1
d2812 2
a2813 1
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p", FPTR2DPTR(XPVIO *, funcp)));
d2815 1
a2815 1
    if (!PL_rsfp_filters || AvFILLp(PL_rsfp_filters)<0)
d2836 1
d2839 11
d2851 1
a2851 1
    if (!PL_rsfp_filters)
d2858 1
a2858 1
	if (maxlen) {
d2864 3
a2866 2
	    SvGROW(buf_sv, (STRLEN)(old_len + maxlen)) ;
	    if ((len = PerlIO_read(PL_rsfp, SvPVX(buf_sv) + old_len, maxlen)) <= 0){
d2889 1
a2889 1
	return FILTER_READ(idx+1, buf_sv, maxlen); /* recurse */
d2895 1
a2895 1
			  idx, datasv, SvPV_nolen_const(datasv)));
d2899 1
a2899 1
    return (*funcp)(aTHX_ idx, buf_sv, maxlen);
d2905 1
d2917 1
a2917 1
	    return Nullch ;
d2924 1
a2924 1
S_find_in_my_stash(pTHX_ const char *pkgname, I32 len)
d2926 1
d2934 1
a2934 1
        (gv = gv_fetchpv(pkgname, FALSE, SVt_PVHV)))
d2940 211
a3150 5
    if ((gv = gv_fetchpv(pkgname, FALSE, SVt_PVCV))) {
        SV *sv;
        if (GvCV(gv) && (sv = cv_const_sv(GvCV(gv)))) {
            pkgname = SvPV_nolen_const(sv);
        }
d3153 4
a3156 1
    return gv_stashpv(pkgname, FALSE);
d3158 1
d3160 26
d3189 1
a3189 1
	  "ATTRTERM", "TERMBLOCK"
a3217 20
#ifdef USE_PURE_BISON
int
Perl_yylex_r(pTHX_ YYSTYPE *lvalp, int *lcharp)
{
    int r;

    yyactlevel++;
    yylval_pointer[yyactlevel] = lvalp;
    yychar_pointer[yyactlevel] = lcharp;
    if (yyactlevel >= YYMAXLEVEL)
	Perl_croak(aTHX_ "panic: YYMAXLEVEL");

    r = Perl_yylex(aTHX);

    if (yyactlevel > 0)
       yyactlevel--;

    return r;
}
#endif
d3225 1
a3227 1
    register I32 tmp;
a3228 2
    GV *gv = Nullgv;
    GV **gvp = 0;
d3230 4
d3235 2
d3239 1
a3239 1
	SV* tmp = newSVpvn("", 0);
d3262 21
d3284 1
a3284 1
	yylval = PL_nextval[PL_nexttoke];
d3290 5
d3296 1
d3317 4
d3324 9
d3335 1
d3344 5
d3354 4
a3357 2
	        if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
		    tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
d3368 2
a3369 1
		PL_nextval[PL_nexttoke].ival = 0;
d3371 1
d3373 1
a3373 1
		    PL_nextval[PL_nexttoke].ival = OP_LCFIRST;
d3375 1
a3375 1
		    PL_nextval[PL_nexttoke].ival = OP_UCFIRST;
d3377 1
a3377 1
		    PL_nextval[PL_nexttoke].ival = OP_LC;
d3379 1
a3379 1
		    PL_nextval[PL_nexttoke].ival = OP_UC;
d3381 1
a3381 1
		    PL_nextval[PL_nexttoke].ival = OP_QUOTEMETA;
d3384 7
d3397 12
a3408 1
		Aop(OP_CONCAT);
d3426 2
a3427 1
	    PL_nextval[PL_nexttoke].ival = 0;
d3429 1
a3429 5
#ifdef USE_5005THREADS
	    PL_nextval[PL_nexttoke].opval = newOP(OP_THREADSV, 0);
	    PL_nextval[PL_nexttoke].opval->op_targ = find_threadsv("\"");
	    force_next(PRIVATEREF);
#else
d3431 2
a3432 2
#endif /* USE_5005THREADS */
	    PL_nextval[PL_nexttoke].ival = 0;
d3434 2
a3435 1
	    PL_nextval[PL_nexttoke].ival = 0;
d3437 2
a3438 1
	    PL_nextval[PL_nexttoke].ival = OP_JOIN;	/* emulate join($", ...) */
d3443 12
a3454 1
	    Aop(OP_CONCAT);
d3469 7
d3483 1
a3483 1
	    PL_lex_repl = Nullsv;
d3499 2
a3500 2
		sv = new_constant(NULL, 0, "qr", sv, sv, "q");
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
d3512 5
a3516 1
	    PL_nextval[PL_nexttoke] = yylval;
d3519 14
a3532 2
	    if (PL_lex_starts++)
		Aop(OP_CONCAT);
d3553 7
d3564 2
a3565 1
	Perl_croak(aTHX_ "Unrecognized character \\x%02X", *s & 255);
d3570 4
d3578 4
a3581 4
 	        if (PL_lex_formbrack)
		    yyerror("Format not terminated");
                else
		    yyerror("Missing right curly or square bracket");
d3594 27
a3620 9
	    sv_setpv(PL_linestr,incl_perldb());
	    if (SvCUR(PL_linestr))
		sv_catpvn(PL_linestr,";", 1);
	    if (PL_preambleav){
		while(AvFILLp(PL_preambleav) >= 0) {
		    SV *tmpsv = av_shift(PL_preambleav);
		    sv_catsv(PL_linestr, tmpsv);
		    sv_catpvn(PL_linestr, ";", 1);
		    sv_free(tmpsv);
d3626 1
a3626 1
		sv_catpv(PL_linestr, "LINE: while (<>) {");
d3628 1
a3628 1
		    sv_catpv(PL_linestr,"chomp;");
a3637 3
			    /* The count here deliberately includes the NUL
			       that terminates the C string constant.  This
			       embeds the opening NUL into the string.  */
d3639 1
a3639 1
			    sv_catpvn(PL_linestr, "our @@F=split(q", 15);
d3649 1
a3649 1
			    sv_catpvn(PL_linestr, ");", 2);
d3653 1
a3653 1
		        sv_catpv(PL_linestr,"our @@F=split(' ');");
d3656 3
a3658 1
	    sv_catpvn(PL_linestr, "\n", 1);
d3661 3
a3663 10
	    PL_last_lop = PL_last_uni = Nullch;
	    if (PERLDB_LINE && PL_curstash != PL_debstash) {
		SV * const sv = NEWSV(85,0);

		sv_upgrade(sv, SVt_PVMG);
		sv_setsv(sv,PL_linestr);
                (void)SvIOK_on(sv);
                SvIV_set(sv, 0);
		av_store(CopFILEAV(PL_curcop),(I32)CopLINE(PL_curcop),sv);
	    }
d3668 1
a3668 1
	    if ((s = filter_gets(PL_linestr, PL_rsfp, 0)) == Nullch) {
d3670 3
d3680 1
a3680 1
		    PL_rsfp = Nullfp;
d3684 8
a3691 2
		    sv_setpv(PL_linestr,PL_minus_p
			     ? ";}continue{print;}" : ";}");
d3694 1
a3694 1
		    PL_last_lop = PL_last_uni = Nullch;
d3699 1
a3699 1
		PL_last_lop = PL_last_uni = Nullch;
d3740 5
a3744 1
		if (*s == '=' && strnEQ(s, "=cut", 4)) {
d3748 1
a3748 1
		    PL_last_lop = PL_last_uni = Nullch;
d3755 2
a3756 9
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
	    SV * const sv = NEWSV(85,0);

	    sv_upgrade(sv, SVt_PVMG);
	    sv_setsv(sv,PL_linestr);
            (void)SvIOK_on(sv);
            SvIV_set(sv, 0);
	    av_store(CopFILEAV(PL_curcop),(I32)CopLINE(PL_curcop),sv);
	}
d3758 1
a3758 1
	PL_last_lop = PL_last_uni = Nullch;
d3764 5
a3768 1
	    d = Nullch;
d3799 2
a3800 1
		    SV * const x = GvSV(gv_fetchpv("\030", TRUE, SVt_PV)); /* $^X */
d3841 1
a3841 1
			    d = Nullch;
d3860 1
a3860 1
			d = Nullch;	/* "perl" not in first word; ignore */
d3873 2
a3874 1
				    char **newargv;
d3898 4
a3901 6
		    const U32 oldpdb = PL_perldb;
		    const bool oldn = PL_minus_n;
		    const bool oldp = PL_minus_p;

		    while (*d && !isSPACE(*d)) d++;
		    while (SPACE_OR_TAB(*d)) d++;
d3905 5
d3911 4
a3914 3
			    if (*d == 'M' || *d == 'm') {
				const char * const m = d;
				while (*d && !isSPACE(*d)) d++;
d3916 1
a3916 1
				      (int)(d - m), m);
d3918 2
a3919 2
			    d = moreswitches(d);
			} while (d);
d3936 1
a3936 1
			    PL_last_lop = PL_last_uni = Nullch;
a3941 8
			if (PL_doswitches && !switches_done) {
			    int argc = PL_origargc;
			    char **argv = PL_origargv;
			    do {
				argc--,argv++;
			    } while (argc && argv[0][0] == '-' && argv[0][1]);
			    init_argv_symbols(argc,argv);
			}
d3962 6
d3972 5
d3983 20
a4002 8
	    d = PL_bufend;
	    while (s < d && *s != '\n')
		s++;
	    if (s < d)
		s++;
	    else if (s > d) /* Found by Ilya: feed random input to Perl. */
	      Perl_croak(aTHX_ "panic: input overflow");
	    incline(s);
d4010 33
d4045 1
d4051 1
d4062 1
a4062 3
                DEBUG_T( { S_printbuf(aTHX_
			"### Saw unary minus before =>, forcing word %s\n", s);
                } );
d4092 1
a4092 1
		gv_fetchpv("\024",TRUE, SVt_PV);
d4120 21
a4140 3
	tmp = *s++;
	if (*s == tmp) {
	    s++;
d4142 5
a4146 10
		TERM(POSTDEC);
	    else
		OPERATOR(PREDEC);
	}
	else if (*s == '>') {
	    s++;
	    s = skipspace(s);
	    if (isIDFIRST_lazy_if(s,UTF)) {
		s = force_word(s,METHOD,FALSE,TRUE,FALSE);
		TOKEN(ARROW);
a4147 11
	    else if (*s == '$')
		OPERATOR(ARROW);
	    else
		TERM(ARROW);
	}
	if (PL_expect == XOPERATOR)
	    Aop(OP_SUBTRACT);
	else {
	    if (isSPACE(*s) || !isSPACE(*PL_bufptr))
		check_uni();
	    OPERATOR('-');		/* unary minus */
d4151 9
a4159 3
	tmp = *s++;
	if (*s == tmp) {
	    s++;
d4161 6
a4166 10
		TERM(POSTINC);
	    else
		OPERATOR(PREINC);
	}
	if (PL_expect == XOPERATOR)
	    Aop(OP_ADD);
	else {
	    if (isSPACE(*s) || !isSPACE(*PL_bufptr))
		check_uni();
	    OPERATOR('+');
d4191 2
a4192 1
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, TRUE);
d4206 6
d4213 4
a4216 2
	tmp = *s++;
	OPERATOR(tmp);
d4220 1
a4220 1
	    goto just_a_word;
d4225 3
d4239 5
a4243 2
	    s = skipspace(s);
	    attrs = Nullop;
d4245 2
d4248 1
a4248 1
		if (isLOWER(*s) && (tmp = keyword(PL_tokenbuf, len))) {
d4263 1
d4274 1
a4278 1
		    SV *sv = newSVpvn(s, len);
d4283 1
a4283 1
		    PL_lex_stuff = Nullsv;
d4286 3
a4288 2
		    if (len == 6 && strnEQ(s, "unique", len)) {
			if (PL_in_my == KEY_our)
d4290 1
a4290 1
			    GvUNIQUE_on(cGVOPx_gv(yylval.opval));
d4292 1
a4292 1
			    ; /* skip to avoid loading attributes.pm */
d4294 2
d4302 2
a4303 1
		    else if (!PL_in_my && len == 6 && strnEQ(s, "lvalue", len))
d4305 3
a4307 1
		    else if (!PL_in_my && len == 6 && strnEQ(s, "locked", len))
d4309 3
a4311 1
		    else if (!PL_in_my && len == 6 && strnEQ(s, "method", len))
d4313 1
d4327 1
a4327 1
					      	    newSVpvn(s, len)));
d4329 1
a4329 1
		s = skipspace(d);
d4331 1
a4331 1
		    s = skipspace(s+1);
d4334 1
d4336 24
a4359 7
	    tmp = (PL_expect == XOPERATOR ? '=' : '{'); /*'}(' for vi */
	    if (*s != ';' && *s != '}' && *s != tmp && (tmp != '=' || *s != ')')) {
		const char q = ((*s == '\'') ? '"' : '\'');
		/* If here for an expression, and parsed no attrs, back off. */
		if (tmp == '=' && !attrs) {
		    s = PL_bufptr;
		    break;
a4360 12
		/* MUST advance bufptr here to avoid bogus "at end of line"
		   context messages from yyerror().
		 */
		PL_bufptr = s;
		if (!*s)
		    yyerror("Unterminated attribute list");
		else
		    yyerror(Perl_form(aTHX_ "Invalid separator character %c%c%c in attribute list",
				      q, *s, q));
		if (attrs)
		    op_free(attrs);
		OPERATOR(':');
d4364 3
a4366 1
		PL_nextval[PL_nexttoke].opval = attrs;
d4369 6
d4384 1
a4384 1
	s = skipspace(s);
d4388 4
a4391 2
	tmp = *s++;
	OPERATOR(tmp);
d4393 7
a4399 5
	tmp = *s++;
	s = skipspace(s);
	if (*s == '{')
	    PREBLOCK(tmp);
	TERM(tmp);
d4408 3
a4410 1
		if (*s != '[' && *s != '{' && (*s != '-' || s[1] != '>'))
d4472 1
a4472 1
		s = skipspace(s);
d4573 1
a4573 1
	yylval.ival = CopLINE(PL_curcop);
d4592 7
d4612 5
d4618 4
d4625 1
a4625 2
	tmp = *s++;
	if (tmp == '&')
d4646 1
a4646 1
	yylval.ival = (OPpENTERSUB_AMPER<<8);
d4651 1
a4651 2
	tmp = *s++;
	if (tmp == '|')
d4657 14
a4670 11
	tmp = *s++;
	if (tmp == '=')
	    Eop(OP_EQ);
	if (tmp == '>')
	    OPERATOR(',');
	if (tmp == '~')
	    PMop(OP_MATCH);
	if (tmp && isSPACE(*s) && ckWARN(WARN_SYNTAX) && strchr("+-*/%.^&|<",tmp))
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Reversed %c= operator",(int)tmp);
	s--;
	if (PL_expect == XSTATE && isALPHA(tmp) &&
d4672 16
a4687 14
	{
	    if (PL_in_eval && !PL_rsfp) {
		d = PL_bufend;
		while (s < d) {
		    if (*s++ == '\n') {
			incline(s);
			if (strnEQ(s,"=cut",4)) {
			    s = strchr(s,'\n');
			    if (s)
				s++;
			    else
				s = d;
			    incline(s);
			    goto retry;
d4689 1
d4691 11
a4702 5
		goto retry;
	    }
	    s = PL_bufend;
	    PL_doextract = TRUE;
	    goto retry;
d4705 1
a4705 1
	    const char *t;
d4707 1
a4707 1
	    for (t = s; SPACE_OR_TAB(*t); t++) ;
d4709 1
a4709 1
	    for (t = s; SPACE_OR_TAB(*t) || *t == '\r'; t++) ;
d4711 1
d4718 1
a4718 1
	yylval.ival = 0;
d4722 24
a4745 5
	tmp = *s++;
	if (tmp == '=')
	    Eop(OP_NE);
	if (tmp == '~')
	    PMop(OP_NOT);
d4759 11
a4769 9
	tmp = *s++;
	if (tmp == '<')
	    SHop(OP_LEFT_SHIFT);
	if (tmp == '=') {
	    tmp = *s++;
	    if (tmp == '>')
		Eop(OP_NCMP);
	    s--;
	    Rop(OP_LE);
d4775 7
a4781 5
	tmp = *s++;
	if (tmp == '>')
	    SHop(OP_RIGHT_SHIFT);
	if (tmp == '=')
	    Rop(OP_GE);
d4791 1
a4791 1
		depcom();
d4822 3
a4824 3
	    yylval.opval = newSVOP(OP_CONST, 0,
				   newSViv(PL_compiling.cop_arybase));
	    yylval.opval->op_private = OPpCONST_ARYBASE;
d4829 11
a4839 3
	tmp = (I32)*s;
	if (PL_lex_state == LEX_NORMAL)
	    s = skipspace(s);
d4841 1
a4841 11
	if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop) && intuit_more(s)) {
	    if (*s == '[') {
		PL_tokenbuf[0] = '@@';
		if (ckWARN(WARN_SYNTAX)) {
		    char *t;
		    for(t = s + 1;
			isSPACE(*t) || isALNUM_lazy_if(t,UTF) || *t == '$';
			t++) ;
		    if (*t++ == ',') {
			PL_bufptr = skipspace(PL_bufptr);
			while (t < PL_bufend && *t != ']')
d4843 8
a4850 3
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Multidimensional syntax %.*s not supported",
			     	(t - PL_bufptr) + 1, PL_bufptr);
d4853 23
d4877 11
a4887 6
	    else if (*s == '{') {
		char *t;
		PL_tokenbuf[0] = '%';
		if (strEQ(PL_tokenbuf+1, "SIG")  && ckWARN(WARN_SYNTAX)
		    && (t = strchr(s, '}')) && (t = strchr(t, '=')))
		{
d4889 18
a4906 8
		    for (t++; isSPACE(*t); t++) ;
		    if (isIDFIRST_lazy_if(t,UTF)) {
		        STRLEN len;
			t = scan_word(t, tmpbuf, sizeof tmpbuf, TRUE, &len);
		        for (; isSPACE(*t); t++) ;
			if (*t == ';' && get_cv(tmpbuf, FALSE))
			    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"You need to quote \"%s\"", tmpbuf);
d4908 2
a4909 31
		}
	    }
	}

	PL_expect = XOPERATOR;
	if (PL_lex_state == LEX_NORMAL && isSPACE((char)tmp)) {
	    const bool islop = (PL_last_lop == PL_oldoldbufptr);
	    if (!islop || PL_last_lop_op == OP_GREPSTART)
		PL_expect = XOPERATOR;
	    else if (strchr("$@@\"'`q", *s))
		PL_expect = XTERM;		/* e.g. print $fh "foo" */
	    else if (strchr("&*<%", *s) && isIDFIRST_lazy_if(s+1,UTF))
		PL_expect = XTERM;		/* e.g. print $fh &sub */
	    else if (isIDFIRST_lazy_if(s,UTF)) {
		char tmpbuf[sizeof PL_tokenbuf];
		scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
		if ((tmp = keyword(tmpbuf, len))) {
		    /* binary operators exclude handle interpretations */
		    switch (tmp) {
		    case -KEY_x:
		    case -KEY_eq:
		    case -KEY_ne:
		    case -KEY_gt:
		    case -KEY_lt:
		    case -KEY_ge:
		    case -KEY_le:
		    case -KEY_cmp:
			break;
		    default:
			PL_expect = XTERM;	/* e.g. print $fh length() */
			break;
d4912 15
a4926 3
		else {
		    PL_expect = XTERM;		/* e.g. print $fh subr() */
		}
a4927 9
	    else if (isDIGIT(*s))
		PL_expect = XTERM;		/* e.g. print $fh 3 */
	    else if (*s == '.' && isDIGIT(s[1]))
		PL_expect = XTERM;		/* e.g. print $fh .3 */
	    else if ((*s == '?' || *s == '-' || *s == '+')
		     && !isSPACE(s[1]) && s[1] != '=')
		PL_expect = XTERM;		/* e.g. print $fh -1 */
	    else if (*s == '<' && s[1] == '<' && !isSPACE(s[2]) && s[2] != '=')
		PL_expect = XTERM;		/* print $fh <<"EOF" */
d4941 1
a4941 1
	    s = skipspace(s);
d4954 1
a4954 1
			PL_bufptr = skipspace(PL_bufptr);
d4957 2
a4958 1
			    t-PL_bufptr, PL_bufptr, t-PL_bufptr-1, PL_bufptr+1);
d4966 4
a4969 11
    case '/':			/* may either be division or pattern */
    case '?':			/* may either be conditional or pattern */
	if (PL_expect != XOPERATOR) {
	    /* Disable warning on "study /blah/" */
	    if (PL_oldoldbufptr == PL_last_uni
		&& (*PL_last_uni != 's' || s - PL_last_uni < 5
		    || memNE(PL_last_uni, "study", 5)
		    || isALNUM_lazy_if(PL_last_uni+5,UTF)))
		check_uni();
	    s = scan_pat(s,OP_MATCH);
	    TERM(sublex_start());
d4971 29
a4999 4
	tmp = *s++;
	if (tmp == '/')
	    Mop(OP_DIVIDE);
	OPERATOR(tmp);
d5015 1
a5015 1
	    tmp = *s++;
d5020 1
a5020 1
		    yylval.ival = OPf_SPECIAL;
d5023 1
a5023 1
		    yylval.ival = 0;
d5033 2
a5034 2
	s = scan_num(s, &yylval);
	DEBUG_T( { S_printbuf(aTHX_ "### Saw number in %s\n", s); } );
d5040 2
a5041 2
	s = scan_str(s,FALSE,FALSE);
	DEBUG_T( { S_printbuf(aTHX_ "### Saw string before %s\n", s); } );
d5045 1
a5045 1
		depcom();
d5052 2
a5053 2
	    missingterm((char*)0);
	yylval.ival = OP_CONST;
d5057 2
a5058 2
	s = scan_str(s,FALSE,FALSE);
	DEBUG_T( { S_printbuf(aTHX_ "### Saw string before %s\n", s); } );
d5062 1
a5062 1
		depcom();
d5069 2
a5070 2
	    missingterm((char*)0);
	yylval.ival = OP_CONST;
d5075 1
a5075 1
		yylval.ival = OP_STRINGIFY;
d5082 2
a5083 2
	s = scan_str(s,FALSE,FALSE);
	DEBUG_T( { S_printbuf(aTHX_ "### Saw backtick string before %s\n", s); } );
d5087 2
a5088 3
	    missingterm((char*)0);
	yylval.ival = OP_BACKTICK;
	set_csh();
d5106 1
a5106 1
		s = scan_num(s, &yylval);
d5110 4
a5113 6
	    else if (!isALPHA(*start) && (PL_expect == XTERM || PL_expect == XREF || PL_expect == XSTATE)) {
		const char c = *start;
		GV *gv;
		*start = '\0';
		gv = gv_fetchpv(s, FALSE, SVt_PVCV);
		*start = c;
d5115 1
a5115 1
		    s = scan_num(s, &yylval);
d5157 2
d5160 2
a5161 2
	gv = Nullgv;
	gvp = 0;
d5184 1
a5184 1
	    yylval.pval = savepv(PL_tokenbuf);
d5190 1
a5190 1
	tmp = keyword(PL_tokenbuf, len);
d5195 4
a5198 4
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(PL_tokenbuf,0));
	    yylval.opval->op_private = OPpCONST_BARE;
	    if (UTF && !IN_BYTES && is_utf8_string((U8*)PL_tokenbuf, len))
	      SvUTF8_on(((SVOP*)yylval.opval)->op_sv);
d5203 2
a5204 2
	    GV *ogv = Nullgv;	/* override (winner) */
	    GV *hgv = Nullgv;	/* hidden (loser) */
d5207 1
a5207 1
		if ((gv = gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVCV)) &&
d5217 1
a5217 1
		    (gv = *gvp) != (GV*)&PL_sv_undef &&
d5229 1
a5229 2
		     && GvCVu(gv)
		     && !hv_fetch(GvHVn(PL_incgv), "Thread.pm", 9, FALSE))
d5239 1
a5239 1
		gv = Nullgv;
d5253 10
d5267 5
d5300 1
a5300 1
		if (len > 2 &&
d5303 2
a5304 1
		    if (ckWARN(WARN_BAREWORD) && ! gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVHV))
d5310 1
a5310 1
		    gv = Nullgv;
d5314 8
a5322 2
		    if (!gv)
			gv = gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVCV);
d5328 1
a5328 1
		    sv = newSVpvn("CORE::GLOBAL::",14);
d5337 7
d5348 2
a5349 2
		yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
		yylval.opval->op_private = OPpCONST_BARE;
d5360 14
d5387 4
a5390 1
		    s = skipspace(s);
d5394 2
a5395 1
		    if ((isIDFIRST_lazy_if(s,UTF) || *s == '$') && (tmp=intuit_method(s,gv)))
d5400 1
d5402 3
a5404 2
		    if ( !immediate_paren && (PL_last_lop_op == OP_SORT ||
                         ((!gv || !GvCVu(gv)) &&
d5407 3
d5417 5
d5423 1
d5428 1
a5428 1
		    sv_setpv(((SVOP*)yylval.opval)->op_sv, PL_tokenbuf);
d5430 1
a5430 1
		      SvUTF8_on(((SVOP*)yylval.opval)->op_sv);
d5437 5
a5441 3
		    if (gv && GvCVu(gv)) {
			for (d = s + 1; SPACE_OR_TAB(*d); d++) ;
			if (*d == ')' && (sv = cv_const_sv(GvCV(gv)))) {
d5446 8
a5453 1
		    PL_nextval[PL_nexttoke].opval = yylval.opval;
d5455 7
d5463 1
a5463 1
		    yylval.ival = 0;
d5469 1
a5469 1
		if ((*s == '$' || *s == '{') && (!gv || !GvCVu(gv))) {
d5479 1
a5479 1
			&& (tmp = intuit_method(s,gv)))
d5484 1
a5484 2
		if (gv && GvCVu(gv)) {
		    CV* cv;
d5490 1
a5490 2
		    cv = GvCV(gv);
		    if ((sv = cv_const_sv(cv))) {
d5492 3
a5494 3
			SvREFCNT_dec(((SVOP*)yylval.opval)->op_sv);
			((SVOP*)yylval.opval)->op_sv = SvREFCNT_inc(sv);
			yylval.opval->op_private = 0;
d5499 11
a5509 3
		    op_free(yylval.opval);
		    yylval.opval = newCVREF(0, newGVOP(OP_GV, 0, gv));
		    yylval.opval->op_private |= OPpENTERSUB_NOPAREN;
d5513 9
a5521 4
		    if (SvPOK(cv)) {
			STRLEN len;
			const char *proto = SvPV_const((SV*)cv, len);
			if (!len)
d5523 1
a5523 1
			if (*proto == '$' && proto[1] == '\0')
d5528 4
a5531 2
			    sv_setpv(PL_subname, PL_curstash ?
					"__ANON__" : "__ANON__::__ANON__");
d5535 58
a5592 1
		    PL_nextval[PL_nexttoke].opval = yylval.opval;
d5596 1
d5602 1
a5602 1
		    yylval.opval->op_private |= OPpCONST_STRICT;
d5607 4
a5610 2
			    for (d = PL_tokenbuf; *d && isLOWER(*d); d++) ;
			    if (!*d && !gv_stashpv(PL_tokenbuf,FALSE))
d5631 1
a5631 1
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d5636 1
a5636 1
            yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d5641 1
a5641 1
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d5643 1
a5643 1
					 ? newSVpv(HvNAME_get(PL_curstash), 0)
d5654 2
a5655 1
		gv = gv_fetchpv(Perl_form(aTHX_ "%s::DATA", pname), TRUE, SVt_PVIO);
d5721 1
a5721 1
						      name));
d5727 16
a5742 1
		PL_rsfp = Nullfp;
d5750 1
d5765 1
a5765 1
		if (!(tmp = keyword(PL_tokenbuf, len)))
d5769 3
d5800 3
d5807 13
d5821 4
d5827 2
a5828 1
	    (void)gv_fetchpv("ENV",TRUE, SVt_PVHV);	/* may use HOME */
d5870 3
d5874 1
a5874 1
	    s = skipspace(s);
d5879 6
d5898 1
a5898 1
	    gv_fetchpv("AnyDBM_File::ISA", GV_ADDMULTI, SVt_PVAV);
d5912 1
a5912 1
	    yylval.ival = CopLINE(PL_curcop);
d5922 2
d5927 1
a5927 1
	    s = skipspace(s);
a5940 1
	    set_csh();
d5963 2
a5964 2
	    yylval.ival = CopLINE(PL_curcop);
	    s = skipspace(s);
d5967 4
d5977 1
a5977 1
		p = skipspace(p);
d5981 1
a5981 1
		    p = skipspace(p);
d5985 3
d6023 1
a6023 1
	    UNI(OP_GETC);
d6100 4
a6104 1
	    set_csh();
d6111 1
a6111 1
	    yylval.ival = CopLINE(PL_curcop);
d6143 1
a6143 1
	    yylval.ival = 0;
d6197 3
a6199 2
	    PL_in_my = tmp;
	    s = skipspace(s);
d6201 3
d6211 1
a6211 1
		    sprintf(tmpbuf, "No such class %.1000s", PL_tokenbuf);
d6214 7
d6222 1
a6222 1
	    yylval.ival = 1;
d6233 1
a6233 5
	    if (PL_expect != XSTATE)
		yyerror("\"no\" not allowed in expression");
	    s = force_word(s,WORD,FALSE,TRUE,FALSE);
	    s = force_version(s, FALSE);
	    yylval.ival = 0;
d6237 1
a6237 1
	    if (*s == '(' || (s = skipspace(s), *s == '('))
d6243 1
a6243 1
	    s = skipspace(s);
d6246 4
a6249 2
		for (d = s; isALNUM_lazy_if(d,UTF); d++) ;
		for (t=d; *t && isSPACE(*t); t++) ;
d6254 1
a6254 1
		    int len = (int)(d-s);
d6257 1
a6257 1
			    len, s, len, s);
d6263 1
a6263 1
	    yylval.ival = OP_OR;
d6290 1
a6290 1
	    UNI(OP_POP);
d6293 1
a6293 1
	    UNI(OP_POS);
d6306 1
a6306 1
	    s = scan_str(s,FALSE,FALSE);
d6308 2
a6309 2
		missingterm((char*)0);
	    yylval.ival = OP_CONST;
d6316 1
a6316 1
	    s = scan_str(s,FALSE,FALSE);
d6318 1
a6318 1
		missingterm((char*)0);
d6322 1
a6322 1
		OP *words = Nullop;
d6326 2
a6327 2
		    SV *sv;
		    for (; isSPACE(*d) && len; --len, ++d) ;
d6329 1
d6346 2
a6347 1
			    for (; !isSPACE(*d) && len; --len, ++d) ;
d6357 2
a6358 1
		    PL_nextval[PL_nexttoke].opval = words;
d6364 1
a6364 1
		PL_lex_stuff = Nullsv;
d6370 1
a6370 1
	    s = scan_str(s,FALSE,FALSE);
d6372 2
a6373 2
		missingterm((char*)0);
	    yylval.ival = OP_STRINGIFY;
d6383 1
a6383 1
	    s = scan_str(s,FALSE,FALSE);
d6385 2
a6386 3
		missingterm((char*)0);
	    yylval.ival = OP_BACKTICK;
	    set_csh();
d6393 1
a6393 1
	    s = skipspace(s);
d6403 1
a6403 1
		    gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf), TRUE);
d6407 12
a6418 1
	    UNI(OP_REQUIRE);
d6446 1
a6446 2
	    set_csh();
	    UNI(OP_READLINE);
d6449 1
a6449 2
	    set_csh();
	    UNI(OP_BACKTICK);
d6461 1
a6461 1
	    UNI(OP_READLINK);
d6468 1
a6468 1
	    if (yylval.opval)
d6473 4
d6532 1
a6532 1
	    UNI(OP_SHIFT);
d6563 1
a6563 1
	    s = skipspace(s);
d6601 1
a6601 1
		bool have_name, have_proto, bad_proto;
d6604 10
d6615 1
d6620 4
d6629 6
a6634 2
		    if (strchr(tmpbuf, ':'))
			sv_setpv(PL_subname, tmpbuf);
d6637 1
a6637 1
			sv_catpvn(PL_subname,"::",2);
d6640 12
d6653 1
a6653 1
		    have_name = TRUE;
d6667 4
d6674 1
d6681 2
d6684 1
a6684 1
		    s = scan_str(s,FALSE,FALSE);
a6689 1
		    bad_proto = FALSE;
d6693 1
a6693 1
			    if (!strchr("$@@%*;[]&\\", *p))
d6698 1
a6698 1
		    if (bad_proto && ckWARN(WARN_SYNTAX))
d6701 1
a6701 1
				    PL_subname, d);
d6705 13
d6719 1
d6730 1
a6730 1
			Perl_croak(aTHX_ "Illegal declaration of subroutine %"SVf, PL_subname);
d6733 11
d6745 1
a6745 1
		    PL_nextval[PL_nexttoke].opval =
d6747 1
a6747 1
		    PL_lex_stuff = Nullsv;
d6750 1
d6752 4
a6755 2
		    sv_setpv(PL_subname,
			PL_curstash ? "__ANON__" : "__ANON__::__ANON__");
d6758 1
d6761 1
a6767 1
	    set_csh();
d6823 1
a6823 1
	    yylval.ival = CopLINE(PL_curcop);
d6827 1
a6827 1
	    yylval.ival = CopLINE(PL_curcop);
d6834 1
a6834 1
	    UNI(OP_UNDEF);
d6843 1
a6843 1
	    UNI(OP_UMASK);
d6849 1
a6849 19
	    if (PL_expect != XSTATE)
		yyerror("\"use\" not allowed in expression");
	    s = skipspace(s);
	    if (isDIGIT(*s) || (*s == 'v' && isDIGIT(s[1]))) {
		s = force_version(s, TRUE);
		if (*s == ';' || (s = skipspace(s), *s == ';')) {
		    PL_nextval[PL_nexttoke].opval = Nullop;
		    force_next(WORD);
		}
		else if (*s == 'v') {
		    s = force_word(s,WORD,FALSE,TRUE,FALSE);
		    s = force_version(s, FALSE);
		}
	    }
	    else {
		s = force_word(s,WORD,FALSE,TRUE,FALSE);
		s = force_version(s, FALSE);
	    }
	    yylval.ival = 1;
d6858 4
d6863 1
a6863 1
	    yylval.ival = CopLINE(PL_curcop);
d6885 1
a6885 1
	    gv_fetchpv(ctl_l,TRUE, SVt_PV);
d6888 2
a6889 1
	    gv_fetchpv("\f",TRUE, SVt_PV);      /* Make sure $^L is defined */
d6900 1
a6900 1
	    yylval.ival = OP_XOR;
d6916 1
d6918 1
a6918 1
    register I32 tmp = 0;
d6921 3
d6926 1
d6938 1
a6938 1
            if (strchr(PL_tokenbuf,':'))
d6945 3
a6947 2
            if (strchr(PL_tokenbuf,':'))
                yyerror(Perl_form(aTHX_ PL_no_myglob,PL_tokenbuf));
d6949 2
a6950 2
            yylval.opval = newOP(OP_PADANY, 0);
            yylval.opval->op_targ = allocmy(PL_tokenbuf);
d6967 1
a6967 12
    if (!strchr(PL_tokenbuf,':')) {
#ifdef USE_5005THREADS
        /* Check for single character per-thread SVs */
        if (PL_tokenbuf[0] == '$' && PL_tokenbuf[2] == '\0'
            && !isALPHA(PL_tokenbuf[1]) /* Rule out obvious non-threadsvs */
            && (tmp = find_threadsv(&PL_tokenbuf[1])) != NOT_IN_PAD)
        {
            yylval.opval = newOP(OP_THREADSV, 0);
            yylval.opval->op_targ = tmp;
            return PRIVATEREF;
        }
#endif /* USE_5005THREADS */
d6972 1
a6972 1
            if (PAD_COMPNAME_FLAGS(tmp) & SVpad_OUR) {
d6974 8
a6981 7
                SV * const sym
		  = newSVpv(HvNAME_get(PAD_COMPNAME_OURSTASH(tmp)), 0);
                sv_catpvn(sym, "::", 2);
                sv_catpv(sym, PL_tokenbuf+1);
                yylval.opval = (OP*)newSVOP(OP_CONST, 0, sym);
                yylval.opval->op_private = OPpCONST_ENTERED;
                gv_fetchpv(SvPVX(sym),
d7009 2
a7010 2
            yylval.opval = newOP(OP_PADANY, 0);
            yylval.opval->op_targ = tmp;
d7021 2
a7022 1
        GV *gv = gv_fetchpv(PL_tokenbuf+1, FALSE, SVt_PVAV);
d7024 5
a7028 1
             && ckWARN(WARN_AMBIGUOUS))
d7038 25
a7062 6
    yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(PL_tokenbuf+1, 0));
    yylval.opval->op_private = OPpCONST_ENTERED;
    gv_fetchpv(PL_tokenbuf+1, PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : TRUE,
               ((PL_tokenbuf[0] == '$') ? SVt_PV
                : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
                : SVt_PVHV));
d7071 1
a7071 1
Perl_keyword (pTHX_ char *name, I32 len)
d7073 1
d7254 1
a7254 1
    case 3: /* 27 tokens of length 3 */
d7471 8
d7539 1
a7539 1
    case 4: /* 40 tokens of length 4 */
d7969 1
a7969 1
          if (name[1] == 'a')
d7971 18
a7988 7
            switch (name[2])
            {
              case 'i':
                if (name[3] == 't')
                {                                 /* wait       */
                  return -KEY_wait;
                }
d7990 3
a7992 1
                goto unknown;
d7994 6
a7999 5
              case 'r':
                if (name[3] == 'n')
                {                                 /* warn       */
                  return -KEY_warn;
                }
d8001 1
a8001 1
                goto unknown;
d8003 2
a8004 3
              default:
                goto unknown;
            }
a8006 2
          goto unknown;

d8011 1
a8011 1
    case 5: /* 36 tokens of length 5 */
d8064 24
a8087 6
          if (name[1] == 'l' &&
              name[2] == 'e' &&
              name[3] == 's' &&
              name[4] == 's')
          {                                       /* bless      */
            return -KEY_bless;
a8089 2
          goto unknown;

d8203 11
d8371 22
a8392 5
              if (name[2] == 'u' &&
                  name[3] == 'd' &&
                  name[4] == 'y')
              {                                   /* study      */
                return KEY_study;
a8394 2
              goto unknown;

d8965 1
a8965 1
    case 7: /* 28 tokens of length 7 */
d9036 27
a9062 7
              if (name[2] == 'f' &&
                  name[3] == 'i' &&
                  name[4] == 'n' &&
                  name[5] == 'e' &&
                  name[6] == 'd')
              {                                   /* defined    */
                return KEY_defined;
d9799 1
a9799 1
    case 9: /* 8 tokens of length 9 */
d9802 15
d10458 1
a10458 1
S_checkcomma(pTHX_ register char *s, const char *name, const char *what)
d10460 1
a10460 1
    const char *w;
d10465 1
d10472 7
a10478 3
	    if (*w)
		for (; *w && isSPACE(*w); w++) ;
	    if (!*w || !strchr(";|})]oaiuw!=", *w))	/* an advisory hack only... */
d10490 1
a10490 1
	w = s++;
d10496 6
a10501 5
	    int kw;
	    *s = '\0'; /* XXX If we didn't do this, we could const a lot of toke.c */
	    kw = keyword((char *)w, s - w) || get_cv(w, FALSE) != 0;
	    *s = ',';
	    if (kw)
d10514 2
a10515 2
S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, SV *sv, SV *pv,
	       const char *type)
d10517 1
a10517 1
    dSP;
d10527 4
a10530 3
	why2 = strEQ(key,"charnames")
	       ? "(possibly a missing \"use charnames ...\")"
	       : "";
d10545 1
a10545 1
	yyerror((char *)SvPVX_const(msg));
d10549 1
a10549 1
    cvp = hv_fetch(table, key, strlen(key), FALSE);
d10561 1
a10561 1
  	typesv = sv_2mortal(newSVpv(type, 0));
d10583 2
a10584 2
 	sv_catpv(ERRSV, "Propagated");
	yyerror((char *)SvPV_nolen_const(ERRSV)); /* Duplicates the message inside eval */
d10586 1
a10586 1
 	res = SvREFCNT_inc(sv);
d10590 1
a10590 1
 	(void)SvREFCNT_inc(res);
d10609 3
d10615 1
d10623 1
a10623 1
	else if (*s == '\'' && allow_package && isIDFIRST_lazy_if(s+1,UTF)) {
d10628 1
a10628 1
	else if (*s == ':' && s[1] == ':' && allow_package && s[2] != '$') {
d10634 1
d10637 2
a10638 1
	    if (d + (t - s) > e)
d10640 2
a10641 2
	    Copy(s, d, t - s, char);
	    d += t - s;
d10655 2
a10656 3
    register char *d;
    register char *e;
    char *bracket = Nullch;
d10658 2
d10662 1
a10662 3
	s = skipspace(s);
    d = dest;
    e = d + destlen - 3;	/* two-character token, ending NUL */
d10737 9
a10745 9
		e = s;
		while ((e < send && isALNUM_lazy_if(e,UTF)) || *e == ':') {
		    e += UTF8SKIP(e);
		    while (e < send && UTF8_IS_CONTINUED(*e) && is_utf8_mark((U8*)e))
			e += UTF8SKIP(e);
		}
		Copy(s, d, e - s, char);
		d += e - s;
		s = e;
d10754 2
a10755 1
	    while (s < send && SPACE_OR_TAB(*s)) s++;
d10757 4
a10760 2
		if (ckWARN(WARN_AMBIGUOUS) && keyword(dest, d - dest)) {
		    const char *brack = *s == '[' ? "[...]" : "{...}";
a10788 2
	    if (funny == '#')
		funny = '@@';
d10791 2
a10792 1
		    (keyword(dest, d - dest) || get_cv(dest, FALSE)))
d10794 2
d10815 11
a10825 14
    if (ch == 'i')
	*pmfl |= PMf_FOLD;
    else if (ch == 'g')
	*pmfl |= PMf_GLOBAL;
    else if (ch == 'c')
	*pmfl |= PMf_CONTINUE;
    else if (ch == 'o')
	*pmfl |= PMf_KEEP;
    else if (ch == 'm')
	*pmfl |= PMf_MULTILINE;
    else if (ch == 's')
	*pmfl |= PMf_SINGLELINE;
    else if (ch == 'x')
	*pmfl |= PMf_EXTENDED;
d10831 1
d10833 7
a10839 1
    char *s = scan_str(start,FALSE,FALSE);
d10842 6
a10847 4
	char * const delimiter = skipspace(start);
	Perl_croak(aTHX_ *delimiter == '?'
		   ? "Search pattern not terminated or ternary operator parsed as search pattern"
		   : "Search pattern not terminated" );
d10851 2
a10852 1
    if (PL_multi_open == '?')
d10854 28
a10881 7
    if(type == OP_QR) {
	while (*s && strchr("iomsx", *s))
	    pmflag(&pm->op_pmflags,*s++);
    }
    else {
	while (*s && strchr("iogcmsx", *s))
	    pmflag(&pm->op_pmflags,*s++);
d10883 1
d10888 2
a10889 1
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), c_without_g);
a10891 2
    pm->op_pmpermflags = pm->op_pmflags;

d10893 1
a10893 1
    yylval.ival = OP_MATCH;
d10900 1
d10905 3
d10909 1
a10909 1
    yylval.ival = OP_NULL;
d10911 1
a10911 1
    s = scan_str(start,FALSE,FALSE);
d10918 9
d10929 1
a10929 1
    s = scan_str(s,FALSE,FALSE);
d10933 1
a10933 1
	    PL_lex_stuff = Nullsv;
d10940 10
d10951 1
a10951 1
	if (*s == 'e') {
d10955 1
a10955 1
	else if (strchr("iogcmsx", *s))
d10961 10
a10970 4
    /* /c is not meaningful with s/// */
    if ((pm->op_pmflags & PMf_CONTINUE) && ckWARN(WARN_REGEXP))
    {
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), c_in_subst);
d10974 2
a10975 1
	SV *repl;
d10980 7
a10986 4
	repl = newSVpvn("",0);
	while (es-- > 0)
	    sv_catpv(repl, es ? "eval " : "do ");
	sv_catpvn(repl, "{ ", 2);
d10988 3
a10990 1
	sv_catpvn(repl, " };", 2);
a10995 1
    pm->op_pmpermflags = pm->op_pmflags;
d10997 1
a10997 1
    yylval.ival = OP_SUBST;
d11004 1
d11011 3
d11015 1
a11015 1
    yylval.ival = OP_NULL;
d11017 1
a11017 1
    s = scan_str(start,FALSE,FALSE);
d11020 1
d11023 9
d11033 1
a11033 1
    s = scan_str(s,FALSE,FALSE);
d11037 1
a11037 1
	    PL_lex_stuff = Nullsv;
d11041 5
d11048 3
d11069 1
a11069 1
    Newx(tbl, complement&&!del?258:256, short);
d11071 2
a11072 1
    o->op_private = del|squash|complement|
d11077 11
a11087 1
    yylval.ival = OP_TRANS;
d11094 1
a11099 1
    const char newline[] = "\n";
d11105 6
d11117 3
a11119 1
    for (peek = s; SPACE_OR_TAB(*peek); peek++) ;
d11145 10
d11179 4
a11182 1
    if ( outer || !(found_newline = ninstr(s,PL_bufend,newline,newline+1)) ) {
d11186 3
d11191 1
d11193 9
d11204 9
a11212 2
    tmpstr = NEWSV(87,79);
    sv_upgrade(tmpstr, SVt_PVIV);
d11227 2
a11228 2
	char *bufptr = PL_sublex_info.super_bufptr;
	char *bufend = PL_sublex_info.super_bufend;
d11264 9
d11280 1
a11280 1
	PL_last_lop = PL_last_uni = Nullch;
d11285 9
d11299 3
d11304 1
a11304 1
	PL_last_lop = PL_last_uni = Nullch;
d11320 2
a11321 9
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
	    SV *sv = NEWSV(88,0);

	    sv_upgrade(sv, SVt_PVMG);
	    sv_setsv(sv,PL_linestr);
            (void)SvIOK_on(sv);
            SvIV_set(sv, 0);
	    av_store(CopFILEAV(PL_curcop), (I32)CopLINE(PL_curcop),sv);
	}
d11348 1
a11348 1
    yylval.ival = op_type;
d11355 1
a11355 1
   side-effects: yylval and lex_op are set.
d11371 1
a11372 2
    register char *d;
    const char *e;
d11376 3
a11378 2
    d = PL_tokenbuf;			/* start of temp holding space */
    e = PL_tokenbuf + sizeof PL_tokenbuf;	/* end of temp holding space */
d11382 1
a11382 1
    s = delimcpy(d, (char *)e, s + 1, end, '>', &len);	/* extract until > */
d11388 1
a11388 1
    if (len >= sizeof PL_tokenbuf)
d11415 2
a11416 3
	yylval.ival = OP_GLOB;
	set_csh();
	s = scan_str(start,FALSE,FALSE);
d11423 1
a11423 1
	GV *gv_readline = Nullgv;
d11433 2
a11434 1
	if (((gv_readline = gv_fetchpv("readline", FALSE, SVt_PVCV))
d11437 2
a11438 2
		((gvp = (GV**)hv_fetch(PL_globalstash, "readline", 8, FALSE))
		&& (gv_readline = *gvp) != (GV*)&PL_sv_undef
a11445 2
	    I32 tmp;

d11449 7
a11455 5
	    if ((tmp = pad_findmy(d)) != NOT_IN_PAD) {
		if (PAD_COMPNAME_FLAGS(tmp) & SVpad_OUR) {
		    SV *sym = sv_2mortal(
			    newSVpv(HvNAME_get(PAD_COMPNAME_OURSTASH(tmp)),0));
		    sv_catpvn(sym, "::", 2);
d11461 1
a11461 1
		    OP *o = newOP(OP_PADSV, 0);
d11490 2
a11491 2
	    /* we created the ops in PL_lex_op, so make yylval.ival a null op */
	    yylval.ival = OP_NULL;
d11497 1
a11497 1
	    GV *gv = gv_fetchpv(d,TRUE, SVt_PVIO);
d11504 1
a11504 1
	    yylval.ival = OP_NULL;
d11558 1
d11560 1
a11560 1
    char *tmps;				/* temp string, used for delimiter matching */
d11569 5
a11573 1
    char *last = NULL;			/* last position for nesting bracket */
d11576 3
a11578 2
    if (isSPACE(*s))
	s = skipspace(s);
d11580 8
d11614 4
a11617 4
    /* create a new SV to hold the contents.  87 is leak category, I'm
       assuming.  79 is the SV's initial length.  What a random number. */
    sv = NEWSV(87,79);
    sv_upgrade(sv, SVt_PVIV);
d11625 7
d11640 2
a11641 2
		const char *ns = SvPVX_const(PL_linestr) + offset;
		char *svlast = SvEND(sv) - 1;
d11670 1
a11670 3
			if (!last)
			    last = SvPVX(sv);
			for (t = w = last; t < svlast; w++, t++) {
d11689 1
a11689 1
			last = w;
d11794 9
d11807 1
a11807 1
	    return Nullch;
d11809 3
d11816 2
a11817 9
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
	    SV *sv = NEWSV(88,0);

	    sv_upgrade(sv, SVt_PVMG);
	    sv_setsv(sv,PL_linestr);
            (void)SvIOK_on(sv);
            SvIV_set(sv, 0);
	    av_store(CopFILEAV(PL_curcop), (I32)CopLINE(PL_curcop), sv);
	}
d11821 1
a11821 1
	PL_last_lop = PL_last_uni = Nullch;
d11827 13
d11844 14
d11884 1
a11884 1
  side-effects: builds ops for the constant in yylval.op
d11903 1
a11903 1
Perl_scan_num(pTHX_ char *start, YYSTYPE* lvalp)
d11905 1
d11910 1
a11910 1
    SV *sv = Nullsv;			/* place to put the converted number */
d11912 1
a11912 1
    const char *lastub = 0;		/* position of last underbar */
d12075 1
a12075 1
	    sv = NEWSV(92,0);
d12094 1
a12094 1
				  sv, Nullsv, NULL);
d12096 1
a12096 1
		sv = new_constant(start, s - start, "binary", sv, Nullsv, NULL);
d12228 1
a12228 1
	sv = NEWSV(92,0);
d12237 1
a12237 1
            int flags = grok_number (PL_tokenbuf, d - PL_tokenbuf, &uv);
d12259 7
a12265 5
	if ( floatit ? (PL_hints & HINT_NEW_FLOAT) :
	               (PL_hints & HINT_NEW_INTEGER) )
	    sv = new_constant(PL_tokenbuf, d - PL_tokenbuf,
			      (floatit ? "float" : "integer"),
			      sv, Nullsv, NULL);
d12271 2
a12272 5
		sv = NEWSV(92,5); /* preallocate storage space */
		s = scan_vstring((char *)s,sv);
		DEBUG_T( { PerlIO_printf(Perl_debug_log,
		  "### Saw v-string before '%s'\n", s);
		} ); 
d12281 1
a12281 1
	lvalp->opval = Nullop;
d12289 1
d12292 1
a12292 1
    SV *stuff = newSVpvn("",0);
d12295 9
d12307 1
d12309 2
a12310 1
	    for (t = s+1;SPACE_OR_TAB(*t); t++) ;
d12312 2
a12313 1
	    for (t = s+1;SPACE_OR_TAB(*t) || *t == '\r'; t++) ;
d12352 8
d12361 3
d12365 1
d12367 1
a12367 1
	    PL_last_lop = PL_last_uni = Nullch;
d12380 2
a12381 1
	    PL_nextval[PL_nexttoke].ival = 0;
d12392 2
a12393 1
	PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, stuff);
d12395 2
a12396 1
	PL_nextval[PL_nexttoke].ival = OP_FORMLINE;
d12405 9
a12416 9
STATIC void
S_set_csh(pTHX)
{
#ifdef CSH
    if (!PL_cshlen)
	PL_cshlen = strlen(PL_cshname);
#endif
}

d12420 1
d12422 1
a12422 1
    CV* outsidecv = PL_compcv;
d12431 1
a12431 2
    PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)PL_compcv, is_format ? SVt_PVFM : SVt_PVCV);
d12436 1
a12436 1
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc(outsidecv);
a12437 5
#ifdef USE_5005THREADS
    CvOWNER(PL_compcv) = 0;
    New(666, CvMUTEXP(PL_compcv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(PL_compcv));
#endif /* USE_5005THREADS */
d12446 1
a12446 1
Perl_yywarn(pTHX_ char *s)
d12448 1
d12456 1
a12456 1
Perl_yyerror(pTHX_ char *s)
d12458 1
d12463 1
d12502 1
a12502 6
#ifdef USE_PURE_BISON
/*  GNU Bison sets the value -2 */
    else if (yychar == -2) {
#else
    else if ((yychar & 127) == 127) {
#endif
d12512 1
a12512 1
	SV *where_sv = sv_2mortal(newSVpvn("next char ", 10));
d12515 4
a12518 2
	else if (isPRINT_LC(yychar))
	    Perl_sv_catpvf(aTHX_ where_sv, "%c", yychar);
d12536 4
a12539 2
    if (PL_in_eval & EVAL_WARNONLY && ckWARN_d(WARN_SYNTAX))
	Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "%"SVf, msg);
d12545 1
a12545 1
            ERRSV, OutCopFILE(PL_curcop));
d12551 1
a12551 1
    PL_in_my_stash = Nullhv;
d12561 1
d12583 5
d12591 4
d12650 9
a12670 16
/*
 * restore_rsfp
 * Restore a source filter.
 */

static void
restore_rsfp(pTHX_ void *f)
{
    PerlIO *fp = (PerlIO*)f;

    if (PL_rsfp == PerlIO_stdin())
	PerlIO_clearerr(PL_rsfp);
    else if (PL_rsfp && (PL_rsfp != fp))
	PerlIO_close(PL_rsfp);
    PL_rsfp = fp;
}
d12676 1
d12681 2
a12682 1
			  utf16_textfilter, idx, maxlen, (int) count));
d12699 1
d12704 2
a12705 1
			  utf16rev_textfilter, idx, maxlen, (int) count));
d12726 2
a12727 2
	sv = NEWSV(92,5);
	s = scan_vstring(s,sv);
d12729 1
d12736 1
a12736 1
Perl_scan_vstring(pTHX_ char *s, SV *sv)
d12738 1
d12742 1
a12742 1
    while (pos < PL_bufend && (isDIGIT(*pos) || *pos == '_'))
d12747 1
a12747 1
	while (next < PL_bufend && isSPACE(*next))
d12749 1
a12749 1
	if ((PL_bufend - next) >= 2 && *next == '=' && next[1] == '>' ) {
a12756 1
	UV rev;
a12757 1
	U8 *tmpend;
d12759 2
a12760 1
	if (*s == 'v') s++;  /* get past 'v' */
d12765 8
a12772 10
	    rev = 0;
	    {
		/* this is atoi() that tolerates underscores */
		const char *end = pos;
		UV mult = 1;
		while (--end >= s) {
		    UV orev;
		    if (*end == '_')
			continue;
		    orev = rev;
d12789 2
a12790 2
	    if (pos + 1 < PL_bufend && *pos == '.' && isDIGIT(pos[1]))
		 s = (char *)++pos;
d12792 1
a12792 1
		 s = (char *)pos;
d12795 1
a12795 1
	    while (pos < PL_bufend && (isDIGIT(*pos) || *pos == '_'))
@


1.10
log
@Add a missing check for NULL before dereferencing a buf pointer in
perl's yyerror().  Fixes a transient core dump on syntax error uncovered
by random malloc() return addresses.  Sent upstream via perlbug.
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d29 6
a34 3
static char ident_too_long[] = "Identifier too long";
static char c_without_g[] = "Use of /c modifier is meaningless without /g";
static char c_in_subst[] = "Use of /c modifier is meaningless in s///";
d69 32
a100 11
#define LEX_NORMAL		10
#define LEX_INTERPNORMAL	 9
#define LEX_INTERPCASEMOD	 8
#define LEX_INTERPPUSH		 7
#define LEX_INTERPSTART		 6
#define LEX_INTERPEND		 5
#define LEX_INTERPENDMAYBE	 4
#define LEX_INTERPCONCAT	 3
#define LEX_INTERPCONST		 2
#define LEX_FORMLINE		 1
#define LEX_KNOWNEXT		 0
a158 2
/* Note that REPORT() and REPORT2() will be expressions that supply
 * their own trailing comma, not suitable for statements as such. */
d160 1
a160 2
#   define REPORT(x,retval) tokereport(x,s,(int)retval),
#   define REPORT2(x,retval) tokereport(x,s, yylval.ival),
d162 1
a162 2
#   define REPORT(x,retval)
#   define REPORT2(x,retval)
d165 20
a184 20
#define TOKEN(retval) return (REPORT2("token",retval) PL_bufptr = s,(int)retval)
#define OPERATOR(retval) return (REPORT2("operator",retval) PL_expect = XTERM, PL_bufptr = s,(int)retval)
#define AOPERATOR(retval) return ao((REPORT2("aop",retval) PL_expect = XTERM, PL_bufptr = s,(int)retval))
#define PREBLOCK(retval) return (REPORT2("preblock",retval) PL_expect = XBLOCK,PL_bufptr = s,(int)retval)
#define PRETERMBLOCK(retval) return (REPORT2("pretermblock",retval) PL_expect = XTERMBLOCK,PL_bufptr = s,(int)retval)
#define PREREF(retval) return (REPORT2("preref",retval) PL_expect = XREF,PL_bufptr = s,(int)retval)
#define TERM(retval) return (CLINE, REPORT2("term",retval) PL_expect = XOPERATOR, PL_bufptr = s,(int)retval)
#define LOOPX(f) return(yylval.ival=f, REPORT("loopx",f) PL_expect = XTERM,PL_bufptr = s,(int)LOOPEX)
#define FTST(f) return(yylval.ival=f, REPORT("ftst",f) PL_expect = XTERM,PL_bufptr = s,(int)UNIOP)
#define FUN0(f) return(yylval.ival = f, REPORT("fun0",f) PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC0)
#define FUN1(f) return(yylval.ival = f, REPORT("fun1",f) PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC1)
#define BOop(f) return ao((yylval.ival=f, REPORT("bitorop",f) PL_expect = XTERM,PL_bufptr = s,(int)BITOROP))
#define BAop(f) return ao((yylval.ival=f, REPORT("bitandop",f) PL_expect = XTERM,PL_bufptr = s,(int)BITANDOP))
#define SHop(f) return ao((yylval.ival=f, REPORT("shiftop",f) PL_expect = XTERM,PL_bufptr = s,(int)SHIFTOP))
#define PWop(f) return ao((yylval.ival=f, REPORT("powop",f) PL_expect = XTERM,PL_bufptr = s,(int)POWOP))
#define PMop(f) return(yylval.ival=f, REPORT("matchop",f) PL_expect = XTERM,PL_bufptr = s,(int)MATCHOP)
#define Aop(f) return ao((yylval.ival=f, REPORT("add",f) PL_expect = XTERM,PL_bufptr = s,(int)ADDOP))
#define Mop(f) return ao((yylval.ival=f, REPORT("mul",f) PL_expect = XTERM,PL_bufptr = s,(int)MULOP))
#define Eop(f) return(yylval.ival=f, REPORT("eq",f) PL_expect = XTERM,PL_bufptr = s,(int)EQOP)
#define Rop(f) return(yylval.ival=f, REPORT("rel",f) PL_expect = XTERM,PL_bufptr = s,(int)RELOP)
d189 21
a209 13
#define UNI(f) return(yylval.ival = f, \
	REPORT("uni",f) \
	PL_expect = XTERM, \
	PL_bufptr = s, \
	PL_last_uni = PL_oldbufptr, \
	PL_last_lop_op = f, \
	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )

#define UNIBRACK(f) return(yylval.ival = f, \
        REPORT("uni",f) \
	PL_bufptr = s, \
	PL_last_uni = PL_oldbufptr, \
	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )
d216 138
d355 1
a355 1
S_tokereport(pTHX_ char *thing, char* s, I32 rv)
d357 4
a360 13
    DEBUG_T({
        SV* report = newSVpv(thing, 0);
        Perl_sv_catpvf(aTHX_ report, ":line %d:%"IVdf":", CopLINE(PL_curcop),
		(IV)rv);

        if (s - PL_bufptr > 0)
            sv_catpvn(report, PL_bufptr, s - PL_bufptr);
        else {
            if (PL_oldbufptr && *PL_oldbufptr)
                sv_catpv(report, PL_tokenbuf);
        }
        PerlIO_printf(Perl_debug_log, "### %s\n", SvPV_nolen(report));
    });
d400 1
a400 1
S_no_op(pTHX_ char *what, char *s)
d402 2
a403 2
    char *oldbp = PL_bufptr;
    bool is_first = (PL_oldbufptr == PL_linestart);
d415 1
a415 1
	    char *t;
d420 1
a420 1
		    t - PL_oldoldbufptr, PL_oldoldbufptr);
d425 1
a425 1
		    "\t(Missing operator before %.*s?)\n", s - oldbp, oldbp);
d446 1
a446 1
	char *nl = strrchr(s,'\n');
d458 1
a458 2
	tmpbuf[1] = toCTRL(PL_multi_close);
	s = "\\n";
d494 1
a494 1
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX), 
d518 2
a519 2
    register char *s = SvPVX(sv);
    register char *e = s + SvCUR(sv);
d540 1
a540 1
    I32 count = FILTER_READ(idx+1, sv, maxlen);
d556 1
a556 1
    char *s;
d597 2
a598 2
    New(899, PL_lex_brackstack, 120, char);
    New(899, PL_lex_casestack, 12, char);
d612 1
a612 1
    s = SvPV(PL_linestr, len);
d691 37
d784 3
a786 5
	    if (PL_minus_n || PL_minus_p) {
		sv_setpv(PL_linestr,PL_minus_p ?
			 ";}continue{print or die qq(-p destination: $!\\n)" :
			 "");
		sv_catpv(PL_linestr,";}");
d789 4
d794 1
a794 1
		sv_setpv(PL_linestr,";");
d842 1
a842 1
	    SV *sv = NEWSV(85,0);
d847 1
a847 1
            SvIVX(sv) = 0;
d876 1
a876 1
        char ch = *s;
a904 1
    REPORT("lop", f)
d910 1
a910 1
	return LSTOP;
d912 1
a912 1
	return FUNC;
d915 1
a915 1
	return FUNC;
d917 1
a917 1
	return LSTOP;
d999 1
a999 1
S_force_ident(pTHX_ register char *s, int kind)
d1002 1
a1002 1
	OP* o = (OP*)newSVOP(OP_CONST, 0, newSVpv(s,0));
d1026 3
a1028 3
    char *start = SvPVx(sv,len);
    bool utf = SvUTF8(sv) ? TRUE : FALSE;
    char *end = start + len;
d1074 1
a1074 1
		SvNVX(ver) = str_to_version(ver);
d1119 1
a1119 1
	pv = sv_2mortal(newSVpvn(SvPVX(pv), len));
d1131 1
a1131 1
    SvCUR_set(sv, d - SvPVX(sv));
d1173 1
a1173 1
    register I32 op_type = yylval.ival;
d1186 2
a1187 5
	    char *p;
	    SV *nsv;

	    p = SvPV(sv, len);
	    nsv = newSVpvn(p, len);
d1257 2
a1258 2
    New(899, PL_lex_brackstack, 120, char);
    New(899, PL_lex_casestack, 12, char);
d1283 1
a1283 1
	SV *sv = newSVpvn("",0);
d1418 3
d1444 1
a1444 1
		    char *c = (char*)utf8_hop((U8*)d, -1);
d1455 1
a1455 1
		i = d - SvPVX(sv);		/* remember current offset */
d1470 3
a1472 2
		if ((isLOWER(min) && isLOWER(max)) ||
		    (isUPPER(min) && isUPPER(max))) {
d1491 3
d1512 3
d1615 3
a1617 3
		    if (ckWARN(WARN_MISC) &&
			isALNUM(*s) && 
			*s != '_')
d1640 1
a1640 1
		    char* e = strchr(s, '}');
d1689 1
a1689 1
			    STRLEN offset = d - SvPVX(sv);
d1695 1
a1695 1
			    while (src >= (U8 *)SvPVX(sv)) {
d1697 1
a1697 1
				    U8 ch = NATIVE_TO_ASCII(*src);
d1735 1
a1735 1
 		    char *str;
d1757 1
a1757 1
		    str = SvPV(res,len);
d1767 1
a1767 1
			 UV uv = utf8_to_uvchr((U8*)str, 0);
d1770 1
a1770 1
			      U8 tmpbuf[UTF8_MAXLEN+1], *d;
d1774 1
a1774 1
			      str = SvPV(res, len);
d1779 1
a1779 1
			char *ostart = SvPVX(sv);
d1790 1
a1790 1
			char *odest = SvPVX(sv);
d1848 4
d1858 2
a1859 2
	    UV uv       = (this_utf8) ? utf8n_to_uvchr((U8*)s, send - s, &len, 0) : (UV) ((U8) *s);
	    STRLEN need = UNISKIP(NATIVE_TO_UNI(uv));
d1863 1
a1863 1
		STRLEN off = d - SvPVX(sv);
d1876 1
a1876 1
    SvCUR_set(sv, d - SvPVX(sv));
d1896 1
a1896 2
	SvLEN_set(sv, SvCUR(sv) + 1);
	Renew(SvPVX(sv), SvLEN(sv), char);
d1975 1
a1975 1
	char *send = strchr(s,']');
d2044 4
a2047 2
		if (!isALNUM(last_un_char) && !strchr("$@@&",last_un_char) &&
			isALPHA(*s) && s[1] && isALPHA(s[1])) {
d2103 1
a2103 1
	    char *proto = SvPVX(cv);
d2161 1
a2161 1
STATIC char*
d2165 1
a2165 1
	char *pdb = PerlEnv_getenv("PERL5DB");
d2203 2
a2204 3
    if (!SvUPGRADE(datasv, SVt_PVIO))
        Perl_die(aTHX_ "Can't upgrade filter_add data to SVt_PVIO");
    IoANY(datasv) = (void *)funcp; /* stash funcp into spare field */
d2207 1
a2207 1
			  (void*)funcp, SvPV_nolen(datasv)));
d2219 4
a2222 1
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p", (void*)funcp));
d2227 1
a2227 1
    if (IoANY(datasv) == (void *)funcp) {
d2257 1
a2257 1
	    int old_len = SvCUR(buf_sv) ;
d2287 1
a2287 1
    funcp = (filter_t)IoANY(datasv);
d2290 1
a2290 1
			  idx, (void*)funcp, SvPV_nolen(datasv)));
d2318 1
a2318 1
S_find_in_my_stash(pTHX_ char *pkgname, I32 len)
d2336 1
a2336 1
            pkgname = SvPV_nolen(sv);
d2344 1
a2344 1
    static char* exp_name[] =
d2402 1
a2402 1
    register char *s;
d2411 9
d2422 1
a2422 1
        return S_pending_ident(aTHX);
d2442 1
a2442 5
	DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Next token after '%s' was known, type %"IVdf"\n", PL_bufptr,
              (IV)PL_nexttype[PL_nexttoke]); });

	return(PL_nexttype[PL_nexttoke]);
a2453 2
	    char oldmod;

d2456 1
a2456 1
		oldmod = PL_lex_casestack[--PL_lex_casemods];
d2459 2
a2460 1
		if (PL_bufptr != PL_bufend && strchr("LUQ", oldmod)) {
d2464 1
a2464 1
		return ')';
d2473 1
a2473 1
              "### Saw case modifier at '%s'\n", PL_bufptr); });
d2483 1
a2483 1
		if (strchr("LU", *s) &&
d2486 1
a2486 1
		    return ')';
d2520 1
a2520 1
        return sublex_push();
d2524 1
a2524 1
	    return sublex_done();
d2526 1
a2526 1
              "### Interpolated variable at '%s'\n", PL_bufptr); });
d2564 1
a2564 1
	    return ')';
d2580 1
a2580 1
	    return sublex_done();
a2622 4
    DEBUG_T( {
	PerlIO_printf(Perl_debug_log, "### Tokener expecting %s at %s\n",
		      exp_name[PL_expect], s);
    } );
d2656 1
a2656 1
		sv_catpv(PL_linestr,";");
d2661 1
a2661 1
		    sv_catpv(PL_linestr, ";");
d2673 2
a2674 1
			if (strchr("/'\"", *PL_splitstr)
d2678 17
a2694 12
			    char delim;
			    s = "'~#\200\1'"; /* surely one char is unused...*/
			    while (s[1] && strchr(PL_splitstr, *s))  s++;
			    delim = *s;
			    Perl_sv_catpvf(aTHX_ PL_linestr, "our @@F=split(%s%c",
				      "q" + (delim == '\''), delim);
			    for (s = PL_splitstr; *s; s++) {
				if (*s == '\\')
				    sv_catpvn(PL_linestr, "\\", 1);
				sv_catpvn(PL_linestr, s, 1);
			    }
			    Perl_sv_catpvf(aTHX_ PL_linestr, "%c);", delim);
d2701 1
a2701 1
	    sv_catpv(PL_linestr, "\n");
d2706 1
a2706 1
		SV *sv = NEWSV(85,0);
d2711 1
a2711 1
                SvIVX(sv) = 0;
d2731 2
a2732 2
		    sv_setpv(PL_linestr,PL_minus_p ? ";}continue{print" : "");
		    sv_catpv(PL_linestr,";}");
d2741 1
a2741 1
		sv_setpv(PL_linestr,"");
d2782 1
a2782 1
		    sv_setpv(PL_linestr, "");
d2793 1
a2793 1
	    SV *sv = NEWSV(85,0);
d2798 1
a2798 1
            SvIVX(sv) = 0;
d2814 1
a2814 1
		    static char as[] = ALTERNATE_SHEBANG;
d2839 1
a2839 1
		    SV *x = GvSV(gv_fetchpv("\030", TRUE, SVt_PV)); /* $^X */
d2848 2
a2849 2
			char *bstart = SvPV(CopFILESV(PL_curcop),blen);
			char *lstart = SvPV(x,llen);
d2895 1
a2895 1
		    char *c = ipath;
d2912 1
a2912 1
		    char **newargv;
d2919 1
a2919 1
			Newz(899,newargv,PL_origargc+3,char*);
d2936 3
a2938 3
		    U32 oldpdb = PL_perldb;
		    bool oldn = PL_minus_n;
		    bool oldp = PL_minus_p;
d2944 1
a2944 1
			bool switches_done = PL_doswitches;
d2947 1
a2947 1
				char *m = d;
d2967 1
a2967 1
			    sv_setpv(PL_linestr, "");
d3046 2
a3047 2
                DEBUG_T( { PerlIO_printf(Perl_debug_log,
                            "### Saw unary minus before =>, forcing word '%s'\n", s);
d3092 1
a3092 1
                        "### Saw file test %c\n", (int)ftst);
d3101 1
a3101 1
			tmp);
d3238 1
a3238 1
			return 0;	/* EOF indicator */
d3257 1
a3257 1
			else 
d3292 1
a3292 1
		char q = ((*s == '\'') ? '"' : '\'');
d3384 1
a3384 1
		    char minus = (PL_tokenbuf[0] == '-');
d3402 1
a3402 1
		char *t;
d3425 1
a3425 1
		 * disambiguated by prepending a `+' before the opening
d3448 1
a3448 1
			char *tmps;
d3549 2
a3550 2
	    if (ckWARN(WARN_SEMICOLON)
		&& isIDFIRST_lazy_if(s,UTF) && PL_bufptr == PL_linestart)
d3585 1
a3585 1
	if (ckWARN(WARN_SYNTAX) && tmp && isSPACE(*s) && strchr("+-*/%.^&|<",tmp))
d3614 1
a3614 1
	    char *t;
d3677 1
a3677 1
		return ','; /* grandfather non-comma-format format */
a3718 1
	    char *t;
d3722 1
d3737 1
d3739 2
a3740 2
		if (ckWARN(WARN_SYNTAX) && strEQ(PL_tokenbuf+1, "SIG") &&
		    (t = strchr(s, '}')) && (t = strchr(t, '=')))
a3742 1
		    STRLEN len;
d3745 1
d3758 1
a3758 1
	    bool islop = (PL_last_lop == PL_oldoldbufptr);
d3793 2
a3794 1
	    else if (strchr("/?-+", *s) && !isSPACE(s[1]) && s[1] != '=')
d3817 3
a3819 3
	    if (ckWARN(WARN_SYNTAX)) {
		if (*s == '[' || *s == '{') {
		    char *t = s + 1;
d3885 1
a3885 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw number before '%s'\n", s);
        } );
d3892 1
a3892 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw string before '%s'\n", s);
        } );
d3897 1
a3897 1
		return ',';	/* grandfather non-comma-format format */
d3909 1
a3909 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw string before '%s'\n", s);
        } );
d3914 1
a3914 1
		return ',';	/* grandfather non-comma-format format */
d3922 2
d3934 1
a3934 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw backtick string before '%s'\n", s);
        } );
d3945 1
a3945 1
	if (ckWARN(WARN_SYNTAX) && PL_lex_inwhat && isDIGIT(*s))
d3954 1
a3954 3
	    char *start = s;
	    start++;
	    start++;
d3963 1
a3963 1
		char c = *start;
d4094 2
a4095 2
		if (ckWARN(WARN_AMBIGUOUS) && hgv
		    && tmp != KEY_x && tmp != KEY_CORE)	/* never ambiguous */
d4109 1
a4109 1
		char lastchar = (PL_bufptr == PL_oldoldbufptr ? 0 : PL_bufptr[-1]);
d4162 6
a4167 2
		else
		    sv = newSVpv(PL_tokenbuf,0);
d4176 1
a4176 1
		    is_utf8_string((U8*)SvPVX(sv), SvCUR(sv)))
d4202 1
a4202 1
			return tmp;
d4259 1
a4259 1
		    return tmp;
d4288 1
a4288 1
			char *proto = SvPV((SV*)cv, len);
d4291 1
a4291 1
			if (strEQ(proto, "$"))
d4296 1
a4296 1
			    sv_setpv(PL_subname, PL_curstash ? 
d4313 2
a4314 2
		    if (ckWARN(WARN_RESERVED)) {
			if (lastchar != '-') {
d4324 2
a4325 1
		if (lastchar && strchr("*%&", lastchar) && ckWARN_d(WARN_AMBIGUOUS)) {
d4349 1
a4349 1
					 ? newSVsv(PL_curstname)
a4355 2

	    /*SUPPRESS 560*/
d4357 1
a4357 1
		char *pname = "main";
d4359 1
a4359 1
		    pname = HvNAME(PL_curstash ? PL_curstash : PL_defstash);
d4367 1
a4367 1
		    int fd = PerlIO_fileno(PL_rsfp);
d4424 1
a4424 1
			PerlIO_apply_layers(aTHX_ PL_rsfp, NULL, 
d4883 1
a4883 1
		char *t;
d4890 1
d4893 1
a4893 1
			    d - s, s, d - s, s);
d4955 1
d4965 1
a4965 1
			char *b = d;
d5008 1
a5008 1
		SvIVX(PL_lex_stuff) = 0;	/* qq'$foo' should intepolate */
d5223 1
a5223 1
		int key = tmp;
d5250 1
a5250 1
		    sv_setpv(PL_subname,"?");
d5286 1
a5286 1
		    SvCUR(PL_lex_stuff) = tmp;
d5491 1
a5491 1
          "### Tokener saw identifier '%s'\n", PL_tokenbuf); });
d5547 2
a5548 1
                SV *sym = newSVpv(HvNAME(PAD_COMPNAME_OURSTASH(tmp)), 0);
d5614 4
d5619 1
a5619 1
Perl_keyword(pTHX_ register char *d, I32 len)
d5621 3286
a8906 601
    switch (*d) {
    case '_':
	if (d[1] == '_') {
	    if (strEQ(d,"__FILE__"))		return -KEY___FILE__;
	    if (strEQ(d,"__LINE__"))		return -KEY___LINE__;
	    if (strEQ(d,"__PACKAGE__"))		return -KEY___PACKAGE__;
	    if (strEQ(d,"__DATA__"))		return KEY___DATA__;
	    if (strEQ(d,"__END__"))		return KEY___END__;
	}
	break;
    case 'A':
	if (strEQ(d,"AUTOLOAD"))		return KEY_AUTOLOAD;
	break;
    case 'a':
	switch (len) {
	case 3:
	    if (strEQ(d,"and"))			return -KEY_and;
	    if (strEQ(d,"abs"))			return -KEY_abs;
	    break;
	case 5:
	    if (strEQ(d,"alarm"))		return -KEY_alarm;
	    if (strEQ(d,"atan2"))		return -KEY_atan2;
	    break;
	case 6:
	    if (strEQ(d,"accept"))		return -KEY_accept;
	    break;
	}
	break;
    case 'B':
	if (strEQ(d,"BEGIN"))			return KEY_BEGIN;
	break;
    case 'b':
	if (strEQ(d,"bless"))			return -KEY_bless;
	if (strEQ(d,"bind"))			return -KEY_bind;
	if (strEQ(d,"binmode"))			return -KEY_binmode;
	break;
    case 'C':
	if (strEQ(d,"CORE"))			return -KEY_CORE;
	if (strEQ(d,"CHECK"))			return KEY_CHECK;
	break;
    case 'c':
	switch (len) {
	case 3:
	    if (strEQ(d,"cmp"))			return -KEY_cmp;
	    if (strEQ(d,"chr"))			return -KEY_chr;
	    if (strEQ(d,"cos"))			return -KEY_cos;
	    break;
	case 4:
	    if (strEQ(d,"chop"))		return -KEY_chop;
	    break;
	case 5:
	    if (strEQ(d,"close"))		return -KEY_close;
	    if (strEQ(d,"chdir"))		return -KEY_chdir;
	    if (strEQ(d,"chomp"))		return -KEY_chomp;
	    if (strEQ(d,"chmod"))		return -KEY_chmod;
	    if (strEQ(d,"chown"))		return -KEY_chown;
	    if (strEQ(d,"crypt"))		return -KEY_crypt;
	    break;
	case 6:
	    if (strEQ(d,"chroot"))		return -KEY_chroot;
	    if (strEQ(d,"caller"))		return -KEY_caller;
	    break;
	case 7:
	    if (strEQ(d,"connect"))		return -KEY_connect;
	    break;
	case 8:
	    if (strEQ(d,"closedir"))		return -KEY_closedir;
	    if (strEQ(d,"continue"))		return -KEY_continue;
	    break;
	}
	break;
    case 'D':
	if (strEQ(d,"DESTROY"))			return KEY_DESTROY;
	break;
    case 'd':
	switch (len) {
	case 2:
	    if (strEQ(d,"do"))			return KEY_do;
	    break;
	case 3:
	    if (strEQ(d,"die"))			return -KEY_die;
	    break;
	case 4:
	    if (strEQ(d,"dump"))		return -KEY_dump;
	    break;
	case 6:
	    if (strEQ(d,"delete"))		return KEY_delete;
	    break;
	case 7:
	    if (strEQ(d,"defined"))		return KEY_defined;
	    if (strEQ(d,"dbmopen"))		return -KEY_dbmopen;
	    break;
	case 8:
	    if (strEQ(d,"dbmclose"))		return -KEY_dbmclose;
	    break;
	}
	break;
    case 'E':
	if (strEQ(d,"END"))			return KEY_END;
	break;
    case 'e':
	switch (len) {
	case 2:
	    if (strEQ(d,"eq"))			return -KEY_eq;
	    break;
	case 3:
	    if (strEQ(d,"eof"))			return -KEY_eof;
	    if (strEQ(d,"exp"))			return -KEY_exp;
	    break;
	case 4:
	    if (strEQ(d,"else"))		return KEY_else;
	    if (strEQ(d,"exit"))		return -KEY_exit;
	    if (strEQ(d,"eval"))		return KEY_eval;
	    if (strEQ(d,"exec"))		return -KEY_exec;
           if (strEQ(d,"each"))                return -KEY_each;
	    break;
	case 5:
	    if (strEQ(d,"elsif"))		return KEY_elsif;
	    break;
	case 6:
	    if (strEQ(d,"exists"))		return KEY_exists;
	    if (strEQ(d,"elseif") && ckWARN_d(WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"elseif should be elsif");
	    break;
	case 8:
	    if (strEQ(d,"endgrent"))		return -KEY_endgrent;
	    if (strEQ(d,"endpwent"))		return -KEY_endpwent;
	    break;
	case 9:
	    if (strEQ(d,"endnetent"))		return -KEY_endnetent;
	    break;
	case 10:
	    if (strEQ(d,"endhostent"))		return -KEY_endhostent;
	    if (strEQ(d,"endservent"))		return -KEY_endservent;
	    break;
	case 11:
	    if (strEQ(d,"endprotoent"))		return -KEY_endprotoent;
	    break;
	}
	break;
    case 'f':
	switch (len) {
	case 3:
	    if (strEQ(d,"for"))			return KEY_for;
	    break;
	case 4:
	    if (strEQ(d,"fork"))		return -KEY_fork;
	    break;
	case 5:
	    if (strEQ(d,"fcntl"))		return -KEY_fcntl;
	    if (strEQ(d,"flock"))		return -KEY_flock;
	    break;
	case 6:
	    if (strEQ(d,"format"))		return KEY_format;
	    if (strEQ(d,"fileno"))		return -KEY_fileno;
	    break;
	case 7:
	    if (strEQ(d,"foreach"))		return KEY_foreach;
	    break;
	case 8:
	    if (strEQ(d,"formline"))		return -KEY_formline;
	    break;
	}
	break;
    case 'g':
	if (strnEQ(d,"get",3)) {
	    d += 3;
	    if (*d == 'p') {
		switch (len) {
		case 7:
		    if (strEQ(d,"ppid"))	return -KEY_getppid;
		    if (strEQ(d,"pgrp"))	return -KEY_getpgrp;
		    break;
		case 8:
		    if (strEQ(d,"pwent"))	return -KEY_getpwent;
		    if (strEQ(d,"pwnam"))	return -KEY_getpwnam;
		    if (strEQ(d,"pwuid"))	return -KEY_getpwuid;
		    break;
		case 11:
		    if (strEQ(d,"peername"))	return -KEY_getpeername;
		    if (strEQ(d,"protoent"))	return -KEY_getprotoent;
		    if (strEQ(d,"priority"))	return -KEY_getpriority;
		    break;
		case 14:
		    if (strEQ(d,"protobyname"))	return -KEY_getprotobyname;
		    break;
		case 16:
		    if (strEQ(d,"protobynumber"))return -KEY_getprotobynumber;
		    break;
		}
	    }
	    else if (*d == 'h') {
		if (strEQ(d,"hostbyname"))	return -KEY_gethostbyname;
		if (strEQ(d,"hostbyaddr"))	return -KEY_gethostbyaddr;
		if (strEQ(d,"hostent"))		return -KEY_gethostent;
	    }
	    else if (*d == 'n') {
		if (strEQ(d,"netbyname"))	return -KEY_getnetbyname;
		if (strEQ(d,"netbyaddr"))	return -KEY_getnetbyaddr;
		if (strEQ(d,"netent"))		return -KEY_getnetent;
	    }
	    else if (*d == 's') {
		if (strEQ(d,"servbyname"))	return -KEY_getservbyname;
		if (strEQ(d,"servbyport"))	return -KEY_getservbyport;
		if (strEQ(d,"servent"))		return -KEY_getservent;
		if (strEQ(d,"sockname"))	return -KEY_getsockname;
		if (strEQ(d,"sockopt"))		return -KEY_getsockopt;
	    }
	    else if (*d == 'g') {
		if (strEQ(d,"grent"))		return -KEY_getgrent;
		if (strEQ(d,"grnam"))		return -KEY_getgrnam;
		if (strEQ(d,"grgid"))		return -KEY_getgrgid;
	    }
	    else if (*d == 'l') {
		if (strEQ(d,"login"))		return -KEY_getlogin;
	    }
	    else if (strEQ(d,"c"))		return -KEY_getc;
	    break;
	}
	switch (len) {
	case 2:
	    if (strEQ(d,"gt"))			return -KEY_gt;
	    if (strEQ(d,"ge"))			return -KEY_ge;
	    break;
	case 4:
	    if (strEQ(d,"grep"))		return KEY_grep;
	    if (strEQ(d,"goto"))		return KEY_goto;
	    if (strEQ(d,"glob"))		return KEY_glob;
	    break;
	case 6:
	    if (strEQ(d,"gmtime"))		return -KEY_gmtime;
	    break;
	}
	break;
    case 'h':
	if (strEQ(d,"hex"))			return -KEY_hex;
	break;
    case 'I':
	if (strEQ(d,"INIT"))			return KEY_INIT;
	break;
    case 'i':
	switch (len) {
	case 2:
	    if (strEQ(d,"if"))			return KEY_if;
	    break;
	case 3:
	    if (strEQ(d,"int"))			return -KEY_int;
	    break;
	case 5:
	    if (strEQ(d,"index"))		return -KEY_index;
	    if (strEQ(d,"ioctl"))		return -KEY_ioctl;
	    break;
	}
	break;
    case 'j':
	if (strEQ(d,"join"))			return -KEY_join;
	break;
    case 'k':
	if (len == 4) {
           if (strEQ(d,"keys"))                return -KEY_keys;
	    if (strEQ(d,"kill"))		return -KEY_kill;
	}
	break;
    case 'l':
	switch (len) {
	case 2:
	    if (strEQ(d,"lt"))			return -KEY_lt;
	    if (strEQ(d,"le"))			return -KEY_le;
	    if (strEQ(d,"lc"))			return -KEY_lc;
	    break;
	case 3:
	    if (strEQ(d,"log"))			return -KEY_log;
	    break;
	case 4:
	    if (strEQ(d,"last"))		return KEY_last;
	    if (strEQ(d,"link"))		return -KEY_link;
	    if (strEQ(d,"lock"))		return -KEY_lock;
	    break;
	case 5:
	    if (strEQ(d,"local"))		return KEY_local;
	    if (strEQ(d,"lstat"))		return -KEY_lstat;
	    break;
	case 6:
	    if (strEQ(d,"length"))		return -KEY_length;
	    if (strEQ(d,"listen"))		return -KEY_listen;
	    break;
	case 7:
	    if (strEQ(d,"lcfirst"))		return -KEY_lcfirst;
	    break;
	case 9:
	    if (strEQ(d,"localtime"))		return -KEY_localtime;
	    break;
	}
	break;
    case 'm':
	switch (len) {
	case 1:					return KEY_m;
	case 2:
	    if (strEQ(d,"my"))			return KEY_my;
	    break;
	case 3:
	    if (strEQ(d,"map"))			return KEY_map;
	    break;
	case 5:
	    if (strEQ(d,"mkdir"))		return -KEY_mkdir;
	    break;
	case 6:
	    if (strEQ(d,"msgctl"))		return -KEY_msgctl;
	    if (strEQ(d,"msgget"))		return -KEY_msgget;
	    if (strEQ(d,"msgrcv"))		return -KEY_msgrcv;
	    if (strEQ(d,"msgsnd"))		return -KEY_msgsnd;
	    break;
	}
	break;
    case 'n':
	if (strEQ(d,"next"))			return KEY_next;
	if (strEQ(d,"ne"))			return -KEY_ne;
	if (strEQ(d,"not"))			return -KEY_not;
	if (strEQ(d,"no"))			return KEY_no;
	break;
    case 'o':
	switch (len) {
	case 2:
	    if (strEQ(d,"or"))			return -KEY_or;
	    break;
	case 3:
	    if (strEQ(d,"ord"))			return -KEY_ord;
	    if (strEQ(d,"oct"))			return -KEY_oct;
	    if (strEQ(d,"our"))			return KEY_our;
	    break;
	case 4:
	    if (strEQ(d,"open"))		return -KEY_open;
	    break;
	case 7:
	    if (strEQ(d,"opendir"))		return -KEY_opendir;
	    break;
	}
	break;
    case 'p':
	switch (len) {
	case 3:
           if (strEQ(d,"pop"))                 return -KEY_pop;
	    if (strEQ(d,"pos"))			return KEY_pos;
	    break;
	case 4:
           if (strEQ(d,"push"))                return -KEY_push;
	    if (strEQ(d,"pack"))		return -KEY_pack;
	    if (strEQ(d,"pipe"))		return -KEY_pipe;
	    break;
	case 5:
	    if (strEQ(d,"print"))		return KEY_print;
	    break;
	case 6:
	    if (strEQ(d,"printf"))		return KEY_printf;
	    break;
	case 7:
	    if (strEQ(d,"package"))		return KEY_package;
	    break;
	case 9:
	    if (strEQ(d,"prototype"))		return KEY_prototype;
	}
	break;
    case 'q':
	if (len <= 2) {
	    if (strEQ(d,"q"))			return KEY_q;
	    if (strEQ(d,"qr"))			return KEY_qr;
	    if (strEQ(d,"qq"))			return KEY_qq;
	    if (strEQ(d,"qw"))			return KEY_qw;
	    if (strEQ(d,"qx"))			return KEY_qx;
	}
	else if (strEQ(d,"quotemeta"))		return -KEY_quotemeta;
	break;
    case 'r':
	switch (len) {
	case 3:
	    if (strEQ(d,"ref"))			return -KEY_ref;
	    break;
	case 4:
	    if (strEQ(d,"read"))		return -KEY_read;
	    if (strEQ(d,"rand"))		return -KEY_rand;
	    if (strEQ(d,"recv"))		return -KEY_recv;
	    if (strEQ(d,"redo"))		return KEY_redo;
	    break;
	case 5:
	    if (strEQ(d,"rmdir"))		return -KEY_rmdir;
	    if (strEQ(d,"reset"))		return -KEY_reset;
	    break;
	case 6:
	    if (strEQ(d,"return"))		return KEY_return;
	    if (strEQ(d,"rename"))		return -KEY_rename;
	    if (strEQ(d,"rindex"))		return -KEY_rindex;
	    break;
	case 7:
	    if (strEQ(d,"require"))		return KEY_require;
	    if (strEQ(d,"reverse"))		return -KEY_reverse;
	    if (strEQ(d,"readdir"))		return -KEY_readdir;
	    break;
	case 8:
	    if (strEQ(d,"readlink"))		return -KEY_readlink;
	    if (strEQ(d,"readline"))		return -KEY_readline;
	    if (strEQ(d,"readpipe"))		return -KEY_readpipe;
	    break;
	case 9:
	    if (strEQ(d,"rewinddir"))		return -KEY_rewinddir;
	    break;
	}
	break;
    case 's':
	switch (d[1]) {
	case 0:					return KEY_s;
	case 'c':
	    if (strEQ(d,"scalar"))		return KEY_scalar;
	    break;
	case 'e':
	    switch (len) {
	    case 4:
		if (strEQ(d,"seek"))		return -KEY_seek;
		if (strEQ(d,"send"))		return -KEY_send;
		break;
	    case 5:
		if (strEQ(d,"semop"))		return -KEY_semop;
		break;
	    case 6:
		if (strEQ(d,"select"))		return -KEY_select;
		if (strEQ(d,"semctl"))		return -KEY_semctl;
		if (strEQ(d,"semget"))		return -KEY_semget;
		break;
	    case 7:
		if (strEQ(d,"setpgrp"))		return -KEY_setpgrp;
		if (strEQ(d,"seekdir"))		return -KEY_seekdir;
		break;
	    case 8:
		if (strEQ(d,"setpwent"))	return -KEY_setpwent;
		if (strEQ(d,"setgrent"))	return -KEY_setgrent;
		break;
	    case 9:
		if (strEQ(d,"setnetent"))	return -KEY_setnetent;
		break;
	    case 10:
		if (strEQ(d,"setsockopt"))	return -KEY_setsockopt;
		if (strEQ(d,"sethostent"))	return -KEY_sethostent;
		if (strEQ(d,"setservent"))	return -KEY_setservent;
		break;
	    case 11:
		if (strEQ(d,"setpriority"))	return -KEY_setpriority;
		if (strEQ(d,"setprotoent"))	return -KEY_setprotoent;
		break;
	    }
	    break;
	case 'h':
	    switch (len) {
	    case 5:
               if (strEQ(d,"shift"))           return -KEY_shift;
		break;
	    case 6:
		if (strEQ(d,"shmctl"))		return -KEY_shmctl;
		if (strEQ(d,"shmget"))		return -KEY_shmget;
		break;
	    case 7:
		if (strEQ(d,"shmread"))		return -KEY_shmread;
		break;
	    case 8:
		if (strEQ(d,"shmwrite"))	return -KEY_shmwrite;
		if (strEQ(d,"shutdown"))	return -KEY_shutdown;
		break;
	    }
	    break;
	case 'i':
	    if (strEQ(d,"sin"))			return -KEY_sin;
	    break;
	case 'l':
	    if (strEQ(d,"sleep"))		return -KEY_sleep;
	    break;
	case 'o':
	    if (strEQ(d,"sort"))		return KEY_sort;
	    if (strEQ(d,"socket"))		return -KEY_socket;
	    if (strEQ(d,"socketpair"))		return -KEY_socketpair;
	    break;
	case 'p':
	    if (strEQ(d,"split"))		return KEY_split;
	    if (strEQ(d,"sprintf"))		return -KEY_sprintf;
           if (strEQ(d,"splice"))              return -KEY_splice;
	    break;
	case 'q':
	    if (strEQ(d,"sqrt"))		return -KEY_sqrt;
	    break;
	case 'r':
	    if (strEQ(d,"srand"))		return -KEY_srand;
	    break;
	case 't':
	    if (strEQ(d,"stat"))		return -KEY_stat;
	    if (strEQ(d,"study"))		return KEY_study;
	    break;
	case 'u':
	    if (strEQ(d,"substr"))		return -KEY_substr;
	    if (strEQ(d,"sub"))			return KEY_sub;
	    break;
	case 'y':
	    switch (len) {
	    case 6:
		if (strEQ(d,"system"))		return -KEY_system;
		break;
	    case 7:
		if (strEQ(d,"symlink"))		return -KEY_symlink;
		if (strEQ(d,"syscall"))		return -KEY_syscall;
		if (strEQ(d,"sysopen"))		return -KEY_sysopen;
		if (strEQ(d,"sysread"))		return -KEY_sysread;
		if (strEQ(d,"sysseek"))		return -KEY_sysseek;
		break;
	    case 8:
		if (strEQ(d,"syswrite"))	return -KEY_syswrite;
		break;
	    }
	    break;
	}
	break;
    case 't':
	switch (len) {
	case 2:
	    if (strEQ(d,"tr"))			return KEY_tr;
	    break;
	case 3:
	    if (strEQ(d,"tie"))			return KEY_tie;
	    break;
	case 4:
	    if (strEQ(d,"tell"))		return -KEY_tell;
	    if (strEQ(d,"tied"))		return KEY_tied;
	    if (strEQ(d,"time"))		return -KEY_time;
	    break;
	case 5:
	    if (strEQ(d,"times"))		return -KEY_times;
	    break;
	case 7:
	    if (strEQ(d,"telldir"))		return -KEY_telldir;
	    break;
	case 8:
	    if (strEQ(d,"truncate"))		return -KEY_truncate;
	    break;
	}
	break;
    case 'u':
	switch (len) {
	case 2:
	    if (strEQ(d,"uc"))			return -KEY_uc;
	    break;
	case 3:
	    if (strEQ(d,"use"))			return KEY_use;
	    break;
	case 5:
	    if (strEQ(d,"undef"))		return KEY_undef;
	    if (strEQ(d,"until"))		return KEY_until;
	    if (strEQ(d,"untie"))		return KEY_untie;
	    if (strEQ(d,"utime"))		return -KEY_utime;
	    if (strEQ(d,"umask"))		return -KEY_umask;
	    break;
	case 6:
	    if (strEQ(d,"unless"))		return KEY_unless;
	    if (strEQ(d,"unpack"))		return -KEY_unpack;
	    if (strEQ(d,"unlink"))		return -KEY_unlink;
	    break;
	case 7:
           if (strEQ(d,"unshift"))             return -KEY_unshift;
	    if (strEQ(d,"ucfirst"))		return -KEY_ucfirst;
	    break;
	}
	break;
    case 'v':
	if (strEQ(d,"values"))			return -KEY_values;
	if (strEQ(d,"vec"))			return -KEY_vec;
	break;
    case 'w':
	switch (len) {
	case 4:
	    if (strEQ(d,"warn"))		return -KEY_warn;
	    if (strEQ(d,"wait"))		return -KEY_wait;
	    break;
	case 5:
	    if (strEQ(d,"while"))		return KEY_while;
	    if (strEQ(d,"write"))		return -KEY_write;
	    break;
	case 7:
	    if (strEQ(d,"waitpid"))		return -KEY_waitpid;
	    break;
	case 9:
	    if (strEQ(d,"wantarray"))		return -KEY_wantarray;
	    break;
	}
	break;
    case 'x':
	if (len == 1)				return -KEY_x;
	if (strEQ(d,"xor"))			return -KEY_xor;
	break;
    case 'y':
	if (len == 1)				return KEY_y;
	break;
    case 'z':
	break;
    }
    return 0;
}
d8909 1
a8909 1
S_checkcomma(pTHX_ register char *s, char *name, char *what)
d8911 1
a8911 1
    char *w;
d8943 2
a8944 2
	    *s = '\0';
	    kw = keyword(w, s - w) || get_cv(w, FALSE) != 0;
d8959 1
a8959 1
S_new_constant(pTHX_ char *s, STRLEN len, const char *key, SV *sv, SV *pv,
d8963 1
a8963 1
    HV *table = GvHV(PL_hintgv);		 /* ^H */
d8967 1
a8967 1
    const char *why1, *why2, *why3;
d8989 1
a8989 1
	yyerror(SvPVX(msg));
a9026 1
	STRLEN n_a;
d9028 1
a9028 1
	yyerror(SvPV(ERRSV, n_a)); /* Duplicates the message inside eval */
d9057 1
a9057 1
    register char *e = d + destlen - 3;  /* two-character token, ending NUL */
d9091 1
a9091 1
S_scan_ident(pTHX_ register char *s, register char *send, char *dest, STRLEN destlen, I32 ck_uni)
d9095 1
a9095 1
    char *bracket = 0;
d9146 1
a9146 1
	(isALNUM_lazy_if(s+1,UTF) || strchr("${", s[1]) || strnEQ(s+1,"::",2)) )
d9166 1
a9166 1
		char ch = *s++;
d9270 1
a9270 1
    char *s;
d9272 6
a9277 3
    s = scan_str(start,FALSE,FALSE);
    if (!s)
	Perl_croak(aTHX_ "Search pattern not terminated");
d9291 2
a9292 2
    if (ckWARN(WARN_REGEXP) && 
        (pm->op_pmflags & PMf_CONTINUE) && !(pm->op_pmflags & PMf_GLOBAL))
d9346 1
a9346 1
    if (ckWARN(WARN_REGEXP) && (pm->op_pmflags & PMf_CONTINUE))
d9402 3
a9404 2
    while (strchr("cds", *s)) {
	if (*s == 'c')
d9406 2
a9407 1
	else if (*s == 'd')
d9409 2
a9410 1
	else if (*s == 's')
d9412 4
d9418 1
d9420 1
a9420 1
    New(803, tbl, complement&&!del?258:256, short);
d9439 2
d9444 1
a9444 1
    int outer = (PL_rsfp && !(PL_lex_inwhat == OP_SCALAR));
d9452 1
a9452 1
    if (*peek && strchr("`'\"",*peek)) {
d9480 1
a9480 1
	char *olds = s;
d9497 1
a9497 1
	SvCUR_set(PL_linestr, PL_bufend - SvPVX(PL_linestr));
d9501 7
a9507 5
    d = "\n";
    if (outer || !(d=ninstr(s,PL_bufend,d,d+1)))
	herewas = newSVpvn(s,PL_bufend-s);
    else
	s--, herewas = newSVpvn(s,d-s);
d9514 1
a9514 1
	SvIVX(tmpstr) = -1;
d9518 1
a9518 1
	SvIVX(tmpstr) = '\\';
d9528 1
a9528 1
	char *olds = s - SvCUR(herewas);
d9546 1
a9546 1
	Copy(SvPVX(herewas),bufptr,SvCUR(herewas) + 1,char);
d9590 1
a9590 1
		SvCUR_set(PL_linestr, PL_bufend - SvPVX(PL_linestr));
d9604 1
a9604 1
            SvIVX(sv) = 0;
d9608 1
a9608 1
	    STRLEN off = PL_bufend - 1 - SvPVX(PL_linestr);
d9623 1
a9623 2
	SvLEN_set(tmpstr, SvCUR(tmpstr) + 1);
	Renew(SvPVX(tmpstr), SvLEN(tmpstr), char);
d9627 1
a9627 1
	if (UTF && is_utf8_string((U8*)SvPVX(tmpstr), SvCUR(tmpstr)))
d9658 1
a9658 1
    register char *e;
d9667 1
a9667 1
    s = delimcpy(d, e, s + 1, end, '>', &len);	/* extract until > */
d9739 1
a9739 1
			    newSVpv(HvNAME(PAD_COMPNAME_OURSTASH(tmp)),0));
d9851 1
a9851 1
    U8 termstr[UTF8_MAXLEN];		/* terminating string */
d9889 1
a9889 1
    SvIVX(sv) = termcode;
d9901 2
a9902 2
		int offset = s - SvPVX(PL_linestr);
		bool found = sv_cat_decode(sv, PL_encoding, PL_linestr,
d9904 1
a9904 1
		char *ns = SvPVX(PL_linestr) + offset;
d9916 2
a9917 2
			char *t;
			for (t = svlast-2; t >= SvPVX(sv) && *t == '\\';)
d9932 2
a9933 1
			char *t, *w;
d9936 1
a9936 1
			for (w = t = last; t < svlast; w++, t++) {
d9953 1
a9953 1
			    SvCUR_set(sv, w - SvPVX(sv));
d10031 1
a10031 1
	SvCUR_set(sv, to - SvPVX(sv));
d10041 1
a10041 1
	if (to - SvPVX(sv) >= 2) {
d10047 1
a10047 1
		SvCUR_set(sv, to - SvPVX(sv));
d10052 1
a10052 1
	else if (to - SvPVX(sv) == 1 && to[-1] == '\r')
d10076 1
a10076 1
            SvIVX(sv) = 0;
d10100 1
a10100 1
	Renew(SvPVX(sv), SvLEN(sv), char);
d10139 1
a10139 1
    register char *s = start;		/* current position in buffer */
d10145 2
a10146 2
    char *lastub = 0;			/* position of last underbar */
    static char number_too_long[] = "Number too long";
d10173 12
a10184 11
	    static NV nvshift[5] = { 1.0, 2.0, 4.0, 8.0, 16.0 };
	    static char* bases[5] = { "", "binary", "", "octal",
				      "hexadecimal" };
	    static char* Bases[5] = { "", "Binary", "", "Octal",
				      "Hexadecimal" };
	    static char *maxima[5] = { "",
				       "0b11111111111111111111111111111111",
				       "",
				       "037777777777",
				       "0xffffffff" };
	    char *base, *Base, *max;
d10230 1
a10230 1
		    if (ckWARN(WARN_SYNTAX) && lastub && s == lastub + 1)
d10310 1
a10310 1
		if (ckWARN(WARN_PORTABLE) && n > 4294967295.0)
d10318 1
a10318 1
		if (ckWARN(WARN_PORTABLE) && u > 0xffffffff)
d10326 1
a10326 1
		sv = new_constant(start, s - start, "integer", 
d10350 1
a10350 1
		if (ckWARN(WARN_SYNTAX) && lastub && s == lastub + 1)
d10392 1
a10392 1
		   if (ckWARN(WARN_SYNTAX) && lastub && s == lastub + 1)
d10414 1
a10414 1
	if (*s && strchr("eE",*s) && strchr("+-0123456789_", s[1])) {
d10449 3
a10451 3
		   if (ckWARN(WARN_SYNTAX) &&
		       ((lastub && s == lastub + 1) ||
			(!isDIGIT(s[1]) && s[1] != '_')))
d10503 1
a10503 1
		s = scan_vstring(s,sv);
d10517 1
a10517 1
    return s;
a10530 1
	    /*SUPPRESS 530*/
d10542 1
a10542 1
	    eol = memchr(s,'\n',PL_bufend-s);
d10564 1
a10564 1
		    SvCUR(stuff)--;
d10571 1
a10571 1
	s = eol;
d10595 1
a10595 1
	    if (UTF && is_utf8_string((U8*)SvPVX(stuff), SvCUR(stuff)))
d10626 1
a10626 1
    I32 oldsavestack_ix = PL_savestack_ix;
d10668 2
a10669 2
    char *where = NULL;
    char *context = NULL;
d10732 1
a10732 1
	where = SvPVX(where_sv);
d10770 1
a10770 2
    STRLEN slen;
    slen = SvCUR(PL_linestr);
d10786 1
a10786 1
		New(898, news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
d10812 1
a10812 1
		New(898, news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
d10882 2
a10883 2
    STRLEN old = SvCUR(sv);
    I32 count = FILTER_READ(idx+1, sv, maxlen);
d10886 1
a10886 1
			  utf16_textfilter, idx, maxlen, count));
d10890 3
a10892 3
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	Copy(SvPVX(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX(sv) + old, tmps + old,
d10903 2
a10904 2
    STRLEN old = SvCUR(sv);
    I32 count = FILTER_READ(idx+1, sv, maxlen);
d10907 1
a10907 1
			  utf16rev_textfilter, idx, maxlen, count));
d10911 3
a10913 3
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	Copy(SvPVX(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX(sv) + old, tmps + old,
d10939 2
a10940 2
    char *pos = s;
    char *start = s;
d10946 1
a10946 1
	char *next = pos;
d10952 1
a10952 1
	    return pos;
d10958 1
a10958 1
	U8 tmpbuf[UTF8_MAXLEN+1];
d10969 1
a10969 1
		char *end = pos;
d10993 1
a10993 1
		 s = ++pos;
d10995 1
a10995 1
		 s = pos;
d11005 1
a11005 1
    return s;
d11008 9
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d7758 3
a7760 2
    else if (PL_bufptr > PL_oldoldbufptr && PL_bufptr - PL_oldoldbufptr < 200 &&
      PL_oldoldbufptr != PL_oldbufptr && PL_oldbufptr != PL_bufptr) {
d7775 2
a7776 2
    else if (PL_bufptr > PL_oldbufptr && PL_bufptr - PL_oldbufptr < 200 &&
      PL_oldbufptr != PL_bufptr) {
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d2031 2
a2032 1
/* Invoke the n'th filter function for the current rsfp.	 */
a2034 3


               		/* 0 = read one text line */
d2041 1
a2041 1
    if (idx > AvFILLp(PL_rsfp_filters)){       /* Any more filters?	*/
d2072 1
a2072 1
    if ( (datasv = FILTER_DATA(idx)) == &PL_sv_undef){
a2097 1

d6629 1
a6629 1
	(void)strcpy(bufptr,SvPVX(herewas));
d6691 2
a6692 2
	    s = PL_bufend - 1;
	    *s = ' ';
d6695 1
d6800 1
a6800 1
	    (void)strcpy(d,"ARGV");
d7255 1
d7272 1
d7276 1
d7348 1
d7407 4
a7410 1
	    if (PL_hints & HINT_NEW_BINARY)
d7870 3
a7872 4
		PL_bufend =
		     (char*)utf16_to_utf8_reversed(s, news,
						   PL_bufend - (char*)s - 1,
						   &newlen);
d7896 3
a7898 4
		PL_bufend =
		     (char*)utf16_to_utf8(s, news,
					  PL_bufend - (char*)s,
					  &newlen);
d7965 1
d7967 3
a7971 1
	U8* tend;
d7974 4
a7977 6
	if (!*SvPV_nolen(sv))
	/* Game over, but don't feed an odd-length string to utf16_to_utf8 */
	return count;

	tend = utf16_to_utf8((U8*)SvPVX(sv), tmps, SvCUR(sv), &newlen);
	sv_usepvn(sv, (char*)tmps, tend - tmps);
d7979 2
a7980 1
    return count;
d7986 1
d7988 3
a7992 1
	U8* tend;
a7993 4
	if (!*SvPV_nolen(sv))
	/* Game over, but don't feed an odd-length string to utf16_to_utf8 */
	return count;

d7995 4
a7998 2
	tend = utf16_to_utf8_reversed((U8*)SvPVX(sv), tmps, SvCUR(sv), &newlen);
	sv_usepvn(sv, (char*)tmps, tend - tmps);
d8000 1
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d253 17
a269 12
    if (is_first)
	Perl_warn(aTHX_ "\t(Missing semicolon on previous line?)\n");
    else if (PL_oldoldbufptr && isIDFIRST_lazy_if(PL_oldoldbufptr,UTF)) {
	char *t;
	for (t = PL_oldoldbufptr; *t && (isALNUM_lazy_if(t,UTF) || *t == ':'); t++) ;
	if (t < PL_bufptr && isSPACE(*t))
	    Perl_warn(aTHX_ "\t(Do you need to predeclare %.*s?)\n",
		t - PL_oldoldbufptr, PL_oldoldbufptr);
    }
    else {
	assert(s >= oldbp);
	Perl_warn(aTHX_ "\t(Missing operator before %.*s?)\n", s - oldbp, oldbp);
d1230 1
a1230 1
	    ? "\\.^$@@AGZdDwWsSbBpPXC+*?|()-nrtfeaxcz0123456789[{]} \t\n\r\f\v#"
d2432 6
a2437 2
	    if (PL_lex_brackets)
		yyerror("Missing right curly or square bracket");
d2533 7
a2539 2
	    /* if it looks like the start of a BOM, check if it in fact is */
	    else if (bof && (!*s || *(U8*)s == 0xEF || *(U8*)s >= 0xFE)) {
d3039 11
d3052 1
a3052 1
		    if (!PL_in_my && len == 6 && strnEQ(s, "lvalue", len))
a3057 7
		    else if (PL_in_my == KEY_our && len == 6 &&
			     strnEQ(s, "unique", len))
#ifdef USE_ITHREADS
			GvUNIQUE_on(cGVOPx_gv(yylval.opval));
#else
			; /* skip that case to avoid loading attributes.pm */
#endif
d4677 2
a4678 2
		t = skipspace(d);
		if (strchr("|&*+-=!?:.", *t) && ckWARN_d(WARN_PRECEDENCE)
d5086 6
a5091 2
		else if (!have_name && *s != '{' && key == KEY_sub)
		    Perl_croak(aTHX_ "Illegal declaration of anonymous subroutine");
d5527 3
a5529 1
	    if (strEQ(d,"elseif")) Perl_warn(aTHX_ "elseif should be elsif");
d7604 1
d7607 1
a7607 1
	if (*s == '.' || *s == /*{*/'}') {
d7614 2
a7615 1
	    if (*t == '\n' || t == PL_bufend)
d7617 1
d7620 1
a7620 1
	    eol = strchr(s,'\n');
a7656 1
		yyerror("Format not terminated");
d7685 2
a7686 1
	PL_lex_formbrack = 0;
d7824 2
a7825 2
    if (PL_in_eval & EVAL_WARNONLY)
	Perl_warn(aTHX_ "%"SVf, msg);
d7849 1
a7849 1
    switch (*s) {
d7852 1
a7852 1
	    /* UTF-16 little-endian */
d7854 1
a7854 1
		Perl_croak(aTHX_ "Unsupported script encoding");
d7856 1
a7856 1
	    DEBUG_p(PerlIO_printf(Perl_debug_log, "UTF-LE script encoding\n"));
d7858 1
d7865 8
a7872 5
		PL_bufend = (char*)utf16_to_utf8_reversed(s, news,
						 PL_bufend - (char*)s - 1,
						 &newlen);
		Copy(news, s, newlen, U8);
		SvCUR_set(PL_linestr, newlen);
a7873 2
		news[newlen++] = '\0';
		Safefree(news);
d7876 1
a7876 1
	    Perl_croak(aTHX_ "Unsupported script encoding");
d7881 1
a7881 1
	if (s[1] == 0xFF) {   /* UTF-16 big-endian */
d7883 1
a7883 1
	    DEBUG_p(PerlIO_printf(Perl_debug_log, "UTF-16BE script encoding\n"));
d7885 1
d7892 8
a7899 5
		PL_bufend = (char*)utf16_to_utf8(s, news,
						 PL_bufend - (char*)s,
						 &newlen);
		Copy(news, s, newlen, U8);
		SvCUR_set(PL_linestr, newlen);
a7900 2
		news[newlen++] = '\0';
		Safefree(news);
d7903 1
a7903 1
	    Perl_croak(aTHX_ "Unsupported script encoding");
d7909 1
a7909 1
	    DEBUG_p(PerlIO_printf(Perl_debug_log, "UTF-8 script encoding\n"));
d7914 14
a7927 4
	if (slen > 3 && s[1] == 0 &&  /* UTF-32 big-endian */
	    s[2] == 0xFE && s[3] == 0xFF)
	{
	    Perl_croak(aTHX_ "Unsupported script encoding");
d7929 8
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d422 2
a423 2
    SAVEPPTR(PL_lex_brackstack);
    SAVEPPTR(PL_lex_casestack);
a437 2
    SAVEFREEPV(PL_lex_brackstack);
    SAVEFREEPV(PL_lex_casestack);
d679 1
a679 1
		   "Warning: Use of \"%s\" without parens is ambiguous",
d783 2
d1047 2
a1048 2
    SAVEPPTR(PL_lex_brackstack);
    SAVEPPTR(PL_lex_casestack);
a1062 2
    SAVEFREEPV(PL_lex_brackstack);
    SAVEFREEPV(PL_lex_casestack);
d1266 1
a1266 1
			       "Invalid [] range \"%c-%c\" in transliteration operator",
d1318 1
a1318 1
		while (s < send && *s != ')')
d1337 1
a1337 1
		if (*regparse != ')') {
a1338 2
		    yyerror("Sequence (?{...}) not terminated or not {}-balanced");
		}
d1602 1
a1602 1
		{
d1610 3
d1668 1
a1668 1
      Perl_croak(aTHX_ "panic: constant overflowed allocated space");
d1672 3
a1674 2
        sv_recode_to_utf8(sv, PL_encoding);
        has_utf8 = TRUE;
d1679 1
a1679 1
		PL_sublex_info.sub_op->op_private |=
d1958 1
a1958 1
	SETERRNO(0,SS$_NORMAL);
d2199 1
d2261 4
a2264 7
	    if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
		tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
	    if (strchr("LU", *s) &&
		(strchr(PL_lex_casestack, 'L') || strchr(PL_lex_casestack, 'U')))
	    {
		PL_lex_casestack[--PL_lex_casemods] = '\0';
		return ')';
d2266 28
a2293 6
	    if (PL_lex_casemods > 10) {
		char* newlb = Renew(PL_lex_casestack, PL_lex_casemods + 2, char);
		if (newlb != PL_lex_casestack) {
		    SAVEFREEPV(newlb);
		    PL_lex_casestack = newlb;
		}
a2294 18
	    PL_lex_casestack[PL_lex_casemods++] = *s;
	    PL_lex_casestack[PL_lex_casemods] = '\0';
	    PL_lex_state = LEX_INTERPCONCAT;
	    PL_nextval[PL_nexttoke].ival = 0;
	    force_next('(');
	    if (*s == 'l')
		PL_nextval[PL_nexttoke].ival = OP_LCFIRST;
	    else if (*s == 'u')
		PL_nextval[PL_nexttoke].ival = OP_UCFIRST;
	    else if (*s == 'L')
		PL_nextval[PL_nexttoke].ival = OP_LC;
	    else if (*s == 'U')
		PL_nextval[PL_nexttoke].ival = OP_UC;
	    else if (*s == 'Q')
		PL_nextval[PL_nexttoke].ival = OP_QUOTEMETA;
	    else
		Perl_croak(aTHX_ "panic: yylex");
	    PL_bufptr = s + 1;
d2704 1
d2706 1
d2729 8
d2875 2
a2876 2
			"### %c looked like a file test but was not\n",
			(int)ftst);
d2878 1
a2878 1
		s -= 2;
a2949 2
	    if (s == PL_bufend)
		yyerror("Final % should be \\% or %name");
a3032 1
#ifdef USE_ITHREADS
d3035 1
d3037 2
d3062 1
a3062 1
	    if (*s != ';' && *s != tmp && (tmp != '=' || *s != ')')) {
d3096 1
d3125 1
a3125 5
	    char* newlb = Renew(PL_lex_brackstack, PL_lex_brackets + 1, char);
	    if (newlb != PL_lex_brackstack) {
		SAVEFREEPV(newlb);
		PL_lex_brackstack = newlb;
	    }
d3218 1
d3225 4
d3241 1
a3241 1
			else
d3250 2
d3253 4
a3256 1
		    t++;
d3556 1
a3556 3
		    GV *gv = gv_fetchpv(tmpbuf, FALSE, SVt_PVCV);
		    if (gv && GvCVu(gv))
			PL_expect = XTERM;	/* e.g. print $fh subr() */
a3576 2
	    if (s == PL_bufend)
		yyerror("Final @@ should be \\@@ or @@name");
d3655 1
a3655 1
                    "### Saw number in '%s'\n", s);
d3788 1
d3853 1
d4029 3
a4031 1
		if ((isIDFIRST_lazy_if(s,UTF) || *s == '$') && (tmp = intuit_method(s,gv)))
d4066 2
d4182 23
a4204 2
		if (UTF && !IN_BYTES)
		    PerlIO_apply_layers(aTHX_ PL_rsfp, NULL, ":utf8");
d4660 4
a4663 1
		if (strchr("|&*+-=!?:.", *t) && ckWARN_d(WARN_PRECEDENCE))
d4666 2
a4667 1
			    d-s,s, d-s,s);
d5056 2
a5057 2
				    "Illegal character in prototype for %s : %s",
				    SvPVX(PL_subname), d);
d5068 2
d5253 1
a5253 1
    register I32 tmp;
d5273 1
a5273 1
            tmp = pad_allocmy(PL_tokenbuf);
d5280 1
a5280 1
            yylval.opval->op_targ = pad_allocmy(PL_tokenbuf);
d5309 3
a5311 2
        if ((tmp = pad_findmy(PL_tokenbuf)) != NOT_IN_PAD) {
            SV *namesv = AvARRAY(PL_comppad_name)[tmp];
d5313 1
a5313 1
            if (SvFLAGS(namesv) & SVpad_OUR) {
d5315 1
a5315 1
                SV *sym = newSVpv(HvNAME(GvSTASH(namesv)),0);
d6298 1
a6298 1
	    if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets)
d6300 2
d6688 6
a6693 2
    if (UTF && !IN_BYTES && is_utf8_string((U8*)SvPVX(tmpstr), SvCUR(tmpstr)))
	SvUTF8_on(tmpstr);
d6799 3
a6801 3
		SV *namesv = AvARRAY(PL_comppad_name)[tmp];
		if (SvFLAGS(namesv) & SVpad_OUR) {
		    SV *sym = sv_2mortal(newSVpv(HvNAME(GvSTASH(namesv)),0));
d6912 4
d6926 10
a6935 2
    if (!UTF8_IS_INVARIANT((U8)term) && UTF)
	has_utf8 = TRUE;
d6943 2
a6944 1
	term = tmps[5];
d6951 1
a6951 1
    SvIVX(sv) = term;
d6956 2
a6957 2
	sv_catpvn(sv, s, 1);
    s++;
d6959 70
d7050 6
a7055 2
		else if (*s == term)
		    break;
d7117 1
d7148 6
a7153 3
    if (keep_delims)
	sv_catpvn(sv, s, 1);
    if (has_utf8)
d7155 1
a7156 1
    s++;
d7556 4
a7559 1
		s = new_vstring(s,sv);
d7646 6
a7678 1
    AV* comppadlist;
a7684 3
    SAVEI32(PL_padix);
    SAVECOMPPAD();
    SAVESPTR(PL_comppad_name);
a7685 4
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);
    SAVEI32(PL_pad_reset_pending);
a7690 7
    PL_comppad = newAV();
    av_push(PL_comppad, Nullsv);
    PL_curpad = AvARRAY(PL_comppad);
    PL_comppad_name = newAV();
    PL_comppad_name_fill = 0;
    PL_min_intro_pending = 0;
    PL_padix = 0;
d7692 1
a7692 12
#ifdef USE_5005THREADS
    av_store(PL_comppad_name, 0, newSVpvn("@@_", 2));
    PL_curpad[0] = (SV*)newAV();
    SvPADMY_on(PL_curpad[0]);	/* XXX Needed? */
#endif /* USE_5005THREADS */

    comppadlist = newAV();
    AvREAL_off(comppadlist);
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);

    CvPADLIST(PL_compcv) = comppadlist;
d7694 1
d7948 86
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d29 2
d32 1
a32 1
static void restore_rsfp(pTHXo_ void *f);
d34 2
a35 2
static I32 utf16_textfilter(pTHXo_ int idx, SV *sv, int maxlen);
static I32 utf16rev_textfilter(pTHXo_ int idx, SV *sv, int maxlen);
d41 5
a45 2
/*#define UTF (SvUTF8(PL_linestr) && !(PL_hints & HINT_BYTE))*/
#define UTF (PL_hints & HINT_UTF8)
d47 1
a47 1
/* In variables name $^X, these are the legal values for X.
d134 30
a163 20
#define TOKEN(retval) return (PL_bufptr = s,(int)retval)
#define OPERATOR(retval) return (PL_expect = XTERM,PL_bufptr = s,(int)retval)
#define AOPERATOR(retval) return ao((PL_expect = XTERM,PL_bufptr = s,(int)retval))
#define PREBLOCK(retval) return (PL_expect = XBLOCK,PL_bufptr = s,(int)retval)
#define PRETERMBLOCK(retval) return (PL_expect = XTERMBLOCK,PL_bufptr = s,(int)retval)
#define PREREF(retval) return (PL_expect = XREF,PL_bufptr = s,(int)retval)
#define TERM(retval) return (CLINE, PL_expect = XOPERATOR,PL_bufptr = s,(int)retval)
#define LOOPX(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LOOPEX)
#define FTST(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)UNIOP)
#define FUN0(f) return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC0)
#define FUN1(f) return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC1)
#define BOop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITOROP))
#define BAop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITANDOP))
#define SHop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)SHIFTOP))
#define PWop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)POWOP))
#define PMop(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MATCHOP)
#define Aop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)ADDOP))
#define Mop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MULOP))
#define Eop(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)EQOP)
#define Rop(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)RELOP)
d169 1
d177 1
d185 22
d301 1
a301 1
	*tmpbuf = PL_multi_close;
d317 17
a333 1
	Perl_warner(aTHX_ WARN_DEPRECATED, "Use of %s is deprecated", s);
d344 1
a344 1
    deprecate("comma-less variable list");
d453 1
a453 1
    if (len && s[len-1] != ';') {
a461 2
    SvREFCNT_dec(PL_rs);
    PL_rs = newSVpvn("\n", 1);
d531 1
a531 5
#ifdef USE_ITHREADS
	Safefree(CopFILE(PL_curcop));
#else
	SvREFCNT_dec(CopFILEGV(PL_curcop));
#endif
d555 1
a555 1
	SSize_t oldloplen, oldunilen;
d647 2
d679 1
a679 1
        Perl_warner(aTHX_ WARN_AMBIGUOUS,
a685 29
/* workaround to replace the UNI() macro with a function.  Only the
 * hints/uts.sh file mentions this.  Other comments elsewhere in the
 * source indicate Microport Unix might need it too.
 */

#ifdef CRIPPLED_CC

#undef UNI
#define UNI(f) return uni(f,s)

STATIC int
S_uni(pTHX_ I32 f, char *s)
{
    yylval.ival = f;
    PL_expect = XTERM;
    PL_bufptr = s;
    PL_last_uni = PL_oldbufptr;
    PL_last_lop_op = f;
    if (*s == '(')
	return FUNC1;
    s = skipspace(s);
    if (*s == '(')
	return FUNC1;
    else
	return UNIOP;
}

#endif /* CRIPPLED_CC */

d706 1
d710 1
a710 1
    PL_last_lop_op = f;
d833 1
a833 1
	    n = utf8_to_uv((U8*)start, len, &skip, 0);
d848 3
d854 1
a854 1
S_force_version(pTHX_ char *s)
d865 2
a866 1
        for (; isDIGIT(*d) || *d == '_' || *d == '.'; d++);
d878 2
d886 1
a886 1
    return (s);
d918 1
a918 1
    if ( PL_hints & HINT_NEW_STRING )
d920 3
d1039 1
d1068 1
a1068 1
    CopLINE_set(PL_curcop, PL_multi_start);
d1180 1
a1180 1
  @@ in pattern could be: @@foo, @@{foo}, @@$foo, @@'foo, @@:foo.
d1219 3
a1221 1
    bool has_utf8 = FALSE;			/* embedded \x{} */
a1223 7
    I32 utf = (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op)
	? (PL_sublex_info.sub_op->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF))
	: UTF;
    I32 this_utf8 = (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op)
	? (PL_sublex_info.sub_op->op_private & (PL_lex_repl ?
						OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF))
	: UTF;
d1229 7
d1245 12
d1265 7
a1271 1
#ifndef ASCIIish
d1277 1
a1277 1
				*d++ = i;
d1281 1
a1281 1
				*d++ = i;
d1287 1
a1287 1
			*d++ = i;
d1291 1
d1297 5
a1301 2
		if (utf) {
		    *d++ = (char)0xff;	/* use illegal utf8 byte--see pmtrans */
d1308 3
d1320 1
a1320 1
		    *d++ = *s++;
d1343 1
a1343 1
		    *d++ = *s++;
d1351 1
a1351 1
		*d++ = *s++;
d1354 3
a1356 1
	/* check for embedded arrays (@@foo, @@:foo, @@'foo, @@{foo}, @@$foo) */
d1358 1
a1358 1
		 && (isALNUM_lazy_if(s+1,UTF) || strchr(":'{$", s[1])))
d1367 1
a1367 1
	    if (s + 1 < send && !strchr("()| \n\t", s[1]))
d1371 2
a1374 2
	    bool to_be_utf8 = FALSE;

d1379 2
a1380 2
		*d++ = '\\';
		*d++ = *s++;
d1389 1
a1389 1
		    Perl_warner(aTHX_ WARN_SYNTAX, "\\%c better written as $%c", *s, *s);
d1412 4
a1415 2
		    if (ckWARN(WARN_MISC) && isALPHA(*s))
			Perl_warner(aTHX_ WARN_MISC, 
d1426 3
a1428 2
		    STRLEN len = 0;	/* disallow underscores */
		    uv = (UV)scan_oct(s, 3, &len);
d1438 5
d1445 1
a1445 6
			e = s;
		    }
		    else {
			STRLEN len = 1;		/* allow underscores */
			uv = (UV)scan_hex(s + 1, e - s - 1, &len);
			to_be_utf8 = TRUE;
d1447 2
d1453 3
a1455 2
			STRLEN len = 0;		/* disallow underscores */
			uv = (UV)scan_hex(s, 2, &len);
d1463 1
a1463 1
		 * escapes will be longer than any UT-F8 sequence
a1464 5

		/* This spot is wrong for EBCDIC.  Characters like
		 * the lowercase letters and digits are >127 in EBCDIC,
		 * so here they would need to be mapped to the Unicode
		 * repertoire.   --jhi */
d1466 5
a1470 2
		if (uv > 127) {
		    if (!has_utf8 && (to_be_utf8 || uv > 255)) {
d1478 4
a1481 5
		        int hicount = 0;
			char *c;

			for (c = SvPVX(sv); c < d; c++) {
			    if (UTF8_IS_CONTINUED(*c))
d1483 1
d1486 11
a1496 15
			    char *old_pvx = SvPVX(sv);
			    char *src, *dst;
			  
			    d = SvGROW(sv,
				       SvCUR(sv) + hicount + 1) +
				         (d - old_pvx);

			    src = d - 1;
			    d += hicount;
			    dst = d - 1;

			    while (src < dst) {
			        if (UTF8_IS_CONTINUED(*src)) {
 				    *dst-- = UTF8_EIGHT_BIT_LO(*src);
 				    *dst-- = UTF8_EIGHT_BIT_HI(*src--);
d1499 1
a1499 1
				    *dst-- = *src--;
d1501 1
d1506 2
a1507 2
		    if (to_be_utf8 || has_utf8 || uv > 255) {
		        d = (char*)uv_to_utf8((U8*)d, uv);
a1513 1
			    utf = TRUE;
d1521 1
a1521 1
		    *d++ = (char)uv;
d1525 1
a1525 1
 	    /* \N{latin small letter a} is a named character */
d1539 10
d1555 20
d1582 1
a1582 1
			SvGROW(sv, send - start);
d1586 1
a1586 1
		    if (len > e - s + 4) {
d1589 1
a1589 1
			SvGROW(sv, (SvCUR(sv) + len - (e - s + 4)));
a1604 7
#ifdef EBCDIC
		*d = *s++;
		if (isLOWER(*d))
		   *d = toUPPER(*d);
		*d = toCTRL(*d);
		d++;
#else
d1607 5
a1611 1
		    *d++ = toCTRL(c);
a1612 1
#endif
d1617 1
a1617 1
		*d++ = '\b';
d1620 1
a1620 1
		*d++ = '\n';
d1623 1
a1623 1
		*d++ = '\r';
d1626 1
a1626 1
		*d++ = '\f';
d1629 1
a1629 1
		*d++ = '\t';
a1630 1
#ifdef EBCDIC
d1632 1
a1632 1
		*d++ = '\047';  /* CP 1047 */
d1635 1
a1635 1
		*d++ = '\057';  /* CP 1047 */
a1636 8
#else
	    case 'e':
		*d++ = '\033';
		break;
	    case 'a':
		*d++ = '\007';
		break;
#endif
d1644 18
a1661 27
       if (UTF8_IS_CONTINUED(*s) && (this_utf8 || has_utf8)) {
           STRLEN len = (STRLEN) -1;
           UV uv;
           if (this_utf8) {
               uv = utf8_to_uv((U8*)s, send - s, &len, 0);
           }
           if (len == (STRLEN)-1) {
               /* Illegal UTF8 (a high-bit byte), make it valid. */
               char *old_pvx = SvPVX(sv);
               /* need space for one extra char (NOTE: SvCUR() not set here) */
               d = SvGROW(sv, SvLEN(sv) + 1) + (d - old_pvx);
               d = (char*)uv_to_utf8((U8*)d, (U8)*s++);
           }
           else {
               while (len--)
                   *d++ = *s++;
           }
           has_utf8 = TRUE;
	   if (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op) {
	       PL_sublex_info.sub_op->op_private |=
		   (PL_lex_repl ? OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF);
	       utf = TRUE;
	   }
           continue;
       }

       *d++ = *s++;
d1667 3
d1671 5
a1675 1
    if (has_utf8)
d1677 5
d1873 1
a1873 1
 * Not a method if bar is known to be a subroutne ("sub bar; foo bar")
d1996 1
a1996 1
			  funcp, SvPV_nolen(datasv)));
d2008 1
a2008 1
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p", funcp));
d2048 1
a2048 1
	    SvGROW(buf_sv, old_len + maxlen) ;
d2078 1
a2078 1
			  idx, funcp, SvPV_nolen(datasv)));
d2082 1
a2082 1
    return (*funcp)(aTHXo_ idx, buf_sv, maxlen);
d2178 2
a2179 1
    yyactlevel--;
d2200 2
a2201 126
    if (PL_pending_ident) {
        /* pit holds the identifier we read and pending_ident is reset */
	char pit = PL_pending_ident;
	PL_pending_ident = 0;

	DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Tokener saw identifier '%s'\n", PL_tokenbuf); })

	/* if we're in a my(), we can't allow dynamics here.
	   $foo'bar has already been turned into $foo::bar, so
	   just check for colons.

	   if it's a legal name, the OP is a PADANY.
	*/
	if (PL_in_my) {
	    if (PL_in_my == KEY_our) {	/* "our" is merely analogous to "my" */
		if (strchr(PL_tokenbuf,':'))
		    yyerror(Perl_form(aTHX_ "No package name allowed for "
				      "variable %s in \"our\"",
				      PL_tokenbuf));
		tmp = pad_allocmy(PL_tokenbuf);
	    }
	    else {
		if (strchr(PL_tokenbuf,':'))
		    yyerror(Perl_form(aTHX_ PL_no_myglob,PL_tokenbuf));

		yylval.opval = newOP(OP_PADANY, 0);
		yylval.opval->op_targ = pad_allocmy(PL_tokenbuf);
		return PRIVATEREF;
	    }
	}

	/*
	   build the ops for accesses to a my() variable.

	   Deny my($a) or my($b) in a sort block, *if* $a or $b is
	   then used in a comparison.  This catches most, but not
	   all cases.  For instance, it catches
	       sort { my($a); $a <=> $b }
	   but not
	       sort { my($a); $a < $b ? -1 : $a == $b ? 0 : 1; }
	   (although why you'd do that is anyone's guess).
	*/

	if (!strchr(PL_tokenbuf,':')) {
#ifdef USE_THREADS
	    /* Check for single character per-thread SVs */
	    if (PL_tokenbuf[0] == '$' && PL_tokenbuf[2] == '\0'
		&& !isALPHA(PL_tokenbuf[1]) /* Rule out obvious non-threadsvs */
		&& (tmp = find_threadsv(&PL_tokenbuf[1])) != NOT_IN_PAD)
	    {
		yylval.opval = newOP(OP_THREADSV, 0);
		yylval.opval->op_targ = tmp;
		return PRIVATEREF;
	    }
#endif /* USE_THREADS */
	    if ((tmp = pad_findmy(PL_tokenbuf)) != NOT_IN_PAD) {
		SV *namesv = AvARRAY(PL_comppad_name)[tmp];
		/* might be an "our" variable" */
		if (SvFLAGS(namesv) & SVpad_OUR) {
		    /* build ops for a bareword */
		    SV *sym = newSVpv(HvNAME(GvSTASH(namesv)),0);
		    sv_catpvn(sym, "::", 2);
		    sv_catpv(sym, PL_tokenbuf+1);
		    yylval.opval = (OP*)newSVOP(OP_CONST, 0, sym);
		    yylval.opval->op_private = OPpCONST_ENTERED;
		    gv_fetchpv(SvPVX(sym),
			(PL_in_eval
			    ? (GV_ADDMULTI | GV_ADDINEVAL)
			    : TRUE
			),
			((PL_tokenbuf[0] == '$') ? SVt_PV
			 : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
			 : SVt_PVHV));
		    return WORD;
		}

		/* if it's a sort block and they're naming $a or $b */
		if (PL_last_lop_op == OP_SORT &&
		    PL_tokenbuf[0] == '$' &&
		    (PL_tokenbuf[1] == 'a' || PL_tokenbuf[1] == 'b')
		    && !PL_tokenbuf[2])
		{
		    for (d = PL_in_eval ? PL_oldoldbufptr : PL_linestart;
			 d < PL_bufend && *d != '\n';
			 d++)
		    {
			if (strnEQ(d,"<=>",3) || strnEQ(d,"cmp",3)) {
			    Perl_croak(aTHX_ "Can't use \"my %s\" in sort comparison",
				  PL_tokenbuf);
			}
		    }
		}

		yylval.opval = newOP(OP_PADANY, 0);
		yylval.opval->op_targ = tmp;
		return PRIVATEREF;
	    }
	}

	/*
	   Whine if they've said @@foo in a doublequoted string,
	   and @@foo isn't a variable we can find in the symbol
	   table.
	*/
	if (pit == '@@' && PL_lex_state != LEX_NORMAL && !PL_lex_brackets) {
	    GV *gv = gv_fetchpv(PL_tokenbuf+1, FALSE, SVt_PVAV);
	    if ((!gv || ((PL_tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
		 && ckWARN(WARN_AMBIGUOUS))
	    {
                /* Downgraded from fatal to warning 20000522 mjd */
		Perl_warner(aTHX_ WARN_AMBIGUOUS,
			    "Possible unintended interpolation of %s in string",
			     PL_tokenbuf);
	    }
	}

	/* build ops for a bareword */
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(PL_tokenbuf+1, 0));
	yylval.opval->op_private = OPpCONST_ENTERED;
	gv_fetchpv(PL_tokenbuf+1, PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : TRUE,
		   ((PL_tokenbuf[0] == '$') ? SVt_PV
		    : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
		    : SVt_PVHV));
	return WORD;
    }
d2223 1
a2223 1
              (IV)PL_nexttype[PL_nexttoke]); })
d2257 1
a2257 1
              "### Saw case modifier at '%s'\n", PL_bufptr); })
d2260 1
a2260 1
		tmp = *s, *s = s[2], s[2] = tmp;	/* misordered... */
d2309 1
a2309 1
              "### Interpolated variable at '%s'\n", PL_bufptr); })
d2316 1
a2316 1
#ifdef USE_THREADS
d2322 1
a2322 1
#endif /* USE_THREADS */
d2409 1
a2409 1
    } )
d2428 1
a2428 1
            } )
a2454 3
		    GV* gv = gv_fetchpv("::F", TRUE, SVt_PVAV);
		    if (gv)
			GvIMPORTED_AV_on(gv);
d2458 1
a2458 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "@@F=split(%s);", PL_splitstr);
d2464 1
a2464 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "@@F=split(%s%c",
d2475 1
a2475 1
		        sv_catpv(PL_linestr,"@@F=split(' ');");
d2487 2
d2544 1
a2544 1
		bof = PerlIO_tell(PL_rsfp) == SvCUR(PL_linestr);
a2551 3
		if (*s == '#' && s[1] == '!' && instr(s,"perl"))
		    PL_doextract = FALSE;

d2569 2
d2611 1
a2611 1
		    SV *x = GvSV(gv_fetchpv("\030", TRUE, SVt_PV));
d2617 13
d2714 1
d2738 8
d2781 2
d2810 1
a2810 1
                } )
a2848 1
		Perl_croak(aTHX_ "Unrecognized file test: -%c", (int)tmp);
d2851 16
a2866 5
	    PL_last_lop_op = ftst;
	    DEBUG_T( { PerlIO_printf(Perl_debug_log,
				     "### Saw file test %c\n", (int)ftst);
	    } )
	    FTST(ftst);
d3014 2
d3022 5
d3030 8
a3037 3
		       flags. To experiment with that, uncomment the
		       following "else": */
		    /* else */
a3146 3
		    if (UTF && !IN_BYTE && is_utf8_string((U8*)PL_tokenbuf, 0) &&
			PL_nextval[PL_nexttoke-1].opval)
		      SvUTF8_on(((SVOP*)PL_nextval[PL_nexttoke-1].opval)->op_sv);
d3169 8
a3176 1
		if (*s == '}')
d3178 1
d3304 1
a3304 1
		Perl_warner(aTHX_ WARN_SEMICOLON, PL_warn_nosemi);
d3337 1
a3337 1
	    Perl_warner(aTHX_ WARN_SYNTAX, "Reversed %c= operator",(int)tmp);
d3481 1
a3481 1
			Perl_warner(aTHX_ WARN_SYNTAX,
d3499 1
a3499 1
			    Perl_warner(aTHX_ WARN_SYNTAX,
d3578 1
a3578 1
			Perl_warner(aTHX_ WARN_SYNTAX,
d3640 1
a3640 1
        } )
d3649 1
a3649 1
        } )
d3668 1
a3668 1
        } )
d3682 1
a3682 1
	    if (*d == '$' || *d == '@@' || *d == '\\' || UTF8_IS_CONTINUED(*d)) {
d3693 1
a3693 1
        } )
d3705 1
a3705 1
	    Perl_warner(aTHX_ WARN_SYNTAX,"Can't use \\%c to mean $%c in expression",
d3723 1
a3723 1
	    else if (!isALPHA(*start) && (PL_expect == XTERM || PL_expect == XREF)) {
d3809 1
a3809 1
	    if (UTF && !IN_BYTE && is_utf8_string((U8*)PL_tokenbuf, len))
d3847 4
d3855 1
a3855 1
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
d3867 1
d3880 1
d3886 1
a3886 1
			Perl_warner(aTHX_ WARN_SEMICOLON, PL_warn_nosemi);
d3901 1
a3901 1
			Perl_warner(aTHX_ WARN_BAREWORD,
d3929 4
d3962 2
a3963 2
		    if ((PL_last_lop_op == OP_SORT ||
                         (!immediate_paren && (!gv || !GvCVu(gv)))) &&
d3965 1
a3965 1
			 PL_last_lop_op != OP_GREPSTART))
a3971 1

d3976 1
a3976 1
		if (*s == '=' && s[1] == '>') {
d3979 1
a3979 1
		    if (UTF && !IN_BYTE && is_utf8_string((U8*)PL_tokenbuf, len))
d4019 1
a4019 1
			Perl_warner(aTHX_ WARN_AMBIGUOUS,
d4047 2
a4048 1
			    sv_setpv(PL_subname,"__ANON__");
d4067 2
a4068 2
			    if (!*d)
				Perl_warner(aTHX_ WARN_RESERVED, PL_warn_reserved,
d4076 1
a4076 1
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
d4079 1
a4079 1
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
d4143 3
d4147 3
a4149 1
#if defined(__BORLANDC__)
d4152 1
d4159 4
a4248 6
	    if (ckWARN(WARN_CHMOD)) {
		for (d = s; d < PL_bufend && (isSPACE(*d) || *d == '('); d++) ;
		if (*d != '0' && isDIGIT(*d))
		    Perl_warner(aTHX_ WARN_CHMOD,
		    		"chmod() mode argument is missing initial 0");
	    }
d4271 1
a4271 1
		s = force_word(s,WORD,FALSE,TRUE,FALSE);
d4601 1
a4601 1
	    s = force_version(s);
d4618 1
a4618 1
		    Perl_warner(aTHX_ WARN_PRECEDENCE,
d4694 1
a4694 1
				    Perl_warner(aTHX_ WARN_QW,
d4699 1
a4699 1
				    Perl_warner(aTHX_ WARN_QW,
d4753 2
a4754 2
	    if (isDIGIT(*s) || (*s == 'v' && isDIGIT(s[1]))) {
		s = force_version(s);
d4756 3
a4758 1
	    else {
d4945 1
a4945 1
		SSize_t tboffset;
d4947 1
a4947 1
		bool have_name, have_proto;
d4995 1
a4995 1
		    /* strip spaces */
d4998 1
d5000 1
a5000 1
			if (!isSPACE(*p))
d5002 3
d5007 4
d5029 2
a5030 1
		    sv_setpv(PL_subname,"__ANON__");
a5116 6
	    if (ckWARN(WARN_UMASK)) {
		for (d = s; d < PL_bufend && (isSPACE(*d) || *d == '('); d++) ;
		if (*d != '0' && isDIGIT(*d))
		    Perl_warner(aTHX_ WARN_UMASK,
		    		"umask: argument is missing initial 0");
	    }
d5127 1
a5127 1
		s = force_version(s);
d5132 4
d5139 1
a5139 1
		s = force_version(s);
d5170 3
a5172 4
	    static char ctl_l[2];

	    if (ctl_l[0] == '\0')
 		ctl_l[0] = toCTRL('L');
d5200 131
a5431 1
	if (strEQ(d,"EQ")) { deprecate(d);	return -KEY_eq;}
a5496 6
    case 'G':
	if (len == 2) {
	    if (strEQ(d,"GT")) { deprecate(d);	return -KEY_gt;}
	    if (strEQ(d,"GE")) { deprecate(d);	return -KEY_ge;}
	}
	break;
a5595 6
    case 'L':
	if (len == 2) {
	    if (strEQ(d,"LT")) { deprecate(d);	return -KEY_lt;}
	    if (strEQ(d,"LE")) { deprecate(d);	return -KEY_le;}
	}
	break;
a5646 3
    case 'N':
	if (strEQ(d,"NE")) { deprecate(d);	return -KEY_ne;}
	break;
d5726 1
a5726 1
	    if (strEQ(d,"require"))		return -KEY_require;
d5951 1
a5951 1
		Perl_warner(aTHX_ WARN_SYNTAX,
d6224 1
a6224 1
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
d6256 1
a6256 1
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
d6273 1
a6273 1
Perl_pmflag(pTHX_ U16 *pmfl, int ch)
d6312 7
d6367 6
a6404 2
    I32 utf8;
    I32 count = 0;
a6422 3
    New(803,tbl,256,short);
    o = newPVOP(OP_TRANS, 0, (char*)tbl);

d6433 3
d6478 1
a6478 1
	    deprecate("bare << to mean <<\"\"");
d6549 1
a6549 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d6569 1
a6569 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d6587 1
a6587 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d6613 2
d6636 1
a6636 1
    if (UTF && !IN_BYTE && is_utf8_string((U8*)SvPVX(tmpstr), SvCUR(tmpstr)))
d6714 3
d6724 9
d6743 17
a6759 3
		OP *o = newOP(OP_PADSV, 0);
		o->op_targ = tmp;
		PL_lex_op = (OP*)newUNOP(OP_READLINE, 0, o);
d6762 16
a6777 4
		GV *gv = gv_fetchpv(d+1,TRUE, SVt_PV);
		PL_lex_op = (OP*)newUNOP(OP_READLINE, 0,
					    newUNOP(OP_RV2SV, 0,
						newGVOP(OP_GV, 0, gv)));
d6779 2
a6780 1
	    PL_lex_op->op_flags |= OPf_SPECIAL;
d6789 6
a6794 1
	    PL_lex_op = (OP*)newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, gv));
d6866 1
a6866 1
    if (UTF8_IS_CONTINUED(term) && UTF)
d6913 1
a6913 1
		else if (!has_utf8 && UTF8_IS_CONTINUED(*s) && UTF)
d6942 1
a6942 1
		else if (!has_utf8 && UTF8_IS_CONTINUED(*s) && UTF)
d6980 1
a6980 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d6992 2
d7036 5
a7040 5
  0(x[0-7A-F]+)|([0-7]+)|(b[01])
  [\d_]+(\.[\d_]*)?[Ee](\d+)

  Underbars (_) are allowed in decimal numbers.  If -w is on,
  underbars before a decimal point must be at three digit intervals.
d7110 1
a7110 1
	    else
d7112 9
d7138 1
a7138 1
		/* _ are ignored */
d7140 4
a7143 1
		    s++;
d7184 1
a7184 1
				Perl_warner(aTHX_ WARN_OVERFLOW,
d7210 7
d7220 1
a7220 1
		    Perl_warner(aTHX_ WARN_PORTABLE,
d7228 1
a7228 1
		    Perl_warner(aTHX_ WARN_PORTABLE,
d7256 4
a7259 3
		if (ckWARN(WARN_SYNTAX) && lastub && s - lastub != 3)
		    Perl_warner(aTHX_ WARN_SYNTAX, "Misplaced _ in number");
		lastub = ++s;
d7271 1
a7271 1
	if (lastub && s - lastub != 3) {
d7273 1
a7273 1
		Perl_warner(aTHX_ WARN_SYNTAX, "Misplaced _ in number");
d7284 8
a7291 2
	    /* copy, ignoring underbars, until we run out of
	       digits.  Note: no misplaced underbar checks!
d7297 7
a7303 1
		if (*s != '_')
d7306 6
d7314 1
a7314 1
		s = start - 1;
d7320 1
a7320 1
	if (*s && strchr("eE",*s) && strchr("+-0123456789",s[1])) {
d7327 8
d7339 23
a7361 5
	    /* read digits of exponent (no underbars :-) */
	    while (isDIGIT(*s)) {
		if (d >= e)
		    Perl_croak(aTHX_ number_too_long);
		*d++ = *s++;
a7364 2
	/* terminate the string */
	*d = '\0';
a7368 2
#if defined(Strtol) && defined(Strtoul)

d7370 2
a7371 3
	   strtol/strtoll sets errno to ERANGE if the number is too big
	   for an integer. We try to do an integer conversion first
	   if no characters indicating "float" have been found.
a7374 1
    	    IV iv;
d7376 4
a7379 10
	    errno = 0;
	    if (*PL_tokenbuf == '-')
		iv = Strtol(PL_tokenbuf, (char**)NULL, 10);
	    else
		uv = Strtoul(PL_tokenbuf, (char**)NULL, 10);
	    if (errno)
	    	floatit = TRUE; /* Probably just too large. */
	    else if (*PL_tokenbuf == '-')
	    	sv_setiv(sv, iv);
	    else if (uv <= IV_MAX)
d7381 1
a7381 1
	    else
d7383 8
a7390 1
	}
d7392 2
a7396 3
#else
	/*
	   No working strtou?ll?.
a7397 46
	   Unfortunately atol() doesn't do range checks (returning
	   LONG_MIN/LONG_MAX, and setting errno to ERANGE on overflows)
	   everywhere [1], so we cannot use use atol() (or atoll()).
	   If we could, they would be used, as Atol(), very much like
	   Strtol() and Strtoul() are used above.

	   [1] XXX Configure test needed to check for atol()
	           (and atoll()) overflow behaviour XXX

	   --jhi

	   We need to do this the hard way.  */

	nv = Atof(PL_tokenbuf);

	/* See if we can make do with an integer value without loss of
	   precision.  We use U_V to cast to a UV, because some
	   compilers have issues.  Then we try casting it back and see
	   if it was the same [1].  We only do this if we know we
	   specifically read an integer.  If floatit is true, then we
	   don't need to do the conversion at all.

	   [1] Note that this is lossy if our NVs cannot preserve our
	   UVs.  There are metaconfig defines NV_PRESERVES_UV (a boolean)
	   and NV_PRESERVES_UV_BITS (a number), but in general we really
	   do hope all such potentially lossy platforms have strtou?ll?
	   to do a lossless IV/UV conversion.

	   Maybe could do some tricks with DBL_DIG, LDBL_DIG and
	   DBL_MANT_DIG and LDBL_MANT_DIG (these are already available
	   as NV_DIG and NV_MANT_DIG)?
	
	   --jhi
	   */
	{
	    UV uv = U_V(nv);
	    if (!floatit && (NV)uv == nv) {
		if (uv <= IV_MAX)
		    sv_setiv(sv, uv); /* Prefer IVs over UVs. */
		else
		    sv_setuv(sv, uv);
	    }
	    else
		sv_setnv(sv, nv);
	}
#endif
d7408 2
a7409 57
	{
	    char *pos = s;
	    pos++;
	    while (isDIGIT(*pos) || *pos == '_')
		pos++;
	    if (!isALPHA(*pos)) {
		UV rev;
		U8 tmpbuf[UTF8_MAXLEN+1];
		U8 *tmpend;
		bool utf8 = FALSE;
		s++;				/* get past 'v' */

		sv = NEWSV(92,5);
		sv_setpvn(sv, "", 0);

		for (;;) {
		    if (*s == '0' && isDIGIT(s[1]))
			yyerror("Octal number in vector unsupported");
		    rev = 0;
		    {
			/* this is atoi() that tolerates underscores */
			char *end = pos;
			UV mult = 1;
			while (--end >= s) {
			    UV orev;
			    if (*end == '_')
				continue;
			    orev = rev;
			    rev += (*end - '0') * mult;
			    mult *= 10;
			    if (orev > rev && ckWARN_d(WARN_OVERFLOW))
				Perl_warner(aTHX_ WARN_OVERFLOW,
					    "Integer overflow in decimal number");
			}
		    }
		    tmpend = uv_to_utf8(tmpbuf, rev);
		    utf8 = utf8 || rev > 127;
		    sv_catpvn(sv, (const char*)tmpbuf, tmpend - tmpbuf);
		    if (*pos == '.' && isDIGIT(pos[1]))
			s = ++pos;
		    else {
			s = pos;
			break;
		    }
		    while (isDIGIT(*pos) || *pos == '_')
			pos++;
		}

		SvPOK_on(sv);
		SvREADONLY_on(sv);
		if (utf8) {
		    SvUTF8_on(sv);
		    if (!UTF||IN_BYTE)
		      sv_utf8_downgrade(sv, TRUE);
		}
	    }
	}
d7458 2
a7459 1
	    sv_catpvn(stuff, s, eol-s);
d7461 7
a7467 5
	    if (eol-s > 1 && eol[-2] == '\r' && eol[-1] == '\n') {
		char *end = SvPVX(stuff) + SvCUR(stuff);
		end[-2] = '\n';
		end[-1] = '\0';
		SvCUR(stuff)--;
d7469 2
a7470 1
#endif
d7551 1
a7551 1
#ifdef USE_THREADS
d7555 1
a7555 1
#endif /* USE_THREADS */
d7564 1
a7564 1
#ifdef USE_THREADS
d7568 1
a7568 1
#endif /* USE_THREADS */
d7597 8
d7607 1
d7613 8
d7623 1
d7655 1
a7655 1
		   CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
d7673 1
a7673 1
		       ERRSV, CopFILE(PL_curcop));
d7676 1
a7676 1
		       CopFILE(PL_curcop));
a7719 1

a7744 1

a7760 4
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

d7767 1
a7767 1
restore_rsfp(pTHXo_ void *f)
d7780 1
a7780 1
utf16_textfilter(pTHXo_ int idx, SV *sv, int maxlen)
d7799 1
a7799 1
utf16rev_textfilter(pTHXo_ int idx, SV *sv, int maxlen)
d7817 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d16 1
a16 1
 * parser, perly.y.  
d31 4
d42 1
a42 1
/* In variables name $^X, these are the legal values for X.  
d46 7
a71 6
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#  include <unistd.h> /* Needed for execv() */
#endif


d77 6
a82 2
YYSTYPE* yylval_pointer = NULL;
int* yychar_pointer = NULL;
d85 3
a87 3
#  define yylval (*yylval_pointer)
#  define yychar (*yychar_pointer)
#  define PERL_YYLEX_PARAM yylval_pointer,yychar_pointer
d89 1
a89 1
#  define yylex()	Perl_yylex(aTHX_ yylval_pointer, yychar_pointer)
d124 1
a124 1
 * Rop        : relational operator <= != gt
d210 1
a210 2
    else {
	assert(s >= oldbp);
a211 1
    }
d222 2
a223 1
    else
d225 1
a276 1
    dTHR;
a329 30
#if 0
STATIC I32
S_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
{
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count) {
	U8* tmps;
	U8* tend;
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	tend = utf16_to_utf8((U16*)SvPVX(sv), tmps, SvCUR(sv));
	sv_usepvn(sv, (char*)tmps, tend - tmps);
    }
    return count;
}

STATIC I32
S_utf16rev_textfilter(pTHX_ int idx, SV *sv, int maxlen)
{
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count) {
	U8* tmps;
	U8* tend;
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	tend = utf16_to_utf8_reversed((U16*)SvPVX(sv), tmps, SvCUR(sv));
	sv_usepvn(sv, (char*)tmps, tend - tmps);
    }
    return count;
}
#endif

a338 1
    dTHR;
a355 1
	PL_nexttoke = 0;
d362 2
d391 1
d406 1
a436 1
    dTHR;
d445 1
a445 1
    while (*s == ' ' || *s == '\t') s++;
d450 1
a450 1
    if (*s == ' ' || *s == '\t')
d452 1
a452 1
    else 
d454 1
a454 1
    while (*s == ' ' || *s == '\t') s++;
d460 1
a460 1
    while (*s == ' ' || *s == '\t')
d470 1
a470 1
    while (*e == ' ' || *e == '\t' || *e == '\r' || *e == '\f')
d477 6
a482 1
    if (t - s > 0)
d484 1
a497 1
    dTHR;
d499 1
a499 1
	while (s < PL_bufend && (*s == ' ' || *s == '\t'))
d552 1
a616 1
    dTHR;
d628 2
a629 2
        Perl_warner(aTHX_ WARN_AMBIGUOUS, 
		   "Warning: Use of \"%s\" without parens is ambiguous", 
a681 1
    dTHR;
d708 1
a708 1
STATIC void 
d741 1
a741 1
    
a782 1
	    dTHR;		/* just for in_eval */
d804 1
a804 1
    bool utf = SvUTF8(sv);
d807 1
a807 1
	I32 skip;
d810 1
a810 1
	    n = utf8_to_uv((U8*)start, &skip);
d822 1
a822 1
/* 
d842 1
a842 1
            s = scan_num(s);
d855 1
a855 1
    force_next(WORD); 
d881 1
a881 1
    if (SvIVX(sv) == -1)
d959 2
d963 1
a963 1
	} 
a994 1
    dTHR;
d1009 2
d1022 1
d1055 3
d1059 1
a1059 1
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpvn("",0));
d1074 1
d1175 1
a1175 1
		  
d1186 1
a1186 2
    bool has_utf = FALSE;			/* embedded \x{} */
    I32 len;					/* ? */
d1192 1
a1192 1
    I32 thisutf = (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op)
d1272 1
a1272 1
		    else if (c == '{') 
d1274 1
a1274 1
		    else if (c == '}') 
a1308 19
	/* (now in tr/// code again) */

	if (*s & 0x80 && thisutf) {
	   (void)utf8_to_uv((U8*)s, &len);
	   if (len == 1) {
	       /* illegal UTF8, make it valid */
	       char *old_pvx = SvPVX(sv);
	       /* need space for one extra char (NOTE: SvCUR() not set here) */
	       d = SvGROW(sv, SvLEN(sv) + 1) + (d - old_pvx);
	       d = (char*)uv_to_utf8((U8*)d, (U8)*s++);
	   }
	   else {
	       while (len--)
		   *d++ = *s++;
	   }
	   has_utf = TRUE;
	   continue;
	}

d1311 2
a1325 1
		dTHR;			/* only for ckWARN */
a1349 1
		    dTHR;
d1355 1
a1355 2
		    *d++ = *s++;
		    continue;
d1361 5
a1365 2
		uv = (UV)scan_oct(s, 3, &len);
		s += len;
d1377 6
a1382 2
                    uv = (UV)scan_hex(s + 1, e - s - 1, &len);
                    s = e + 1;
d1385 5
a1389 2
		    uv = (UV)scan_hex(s, 2, &len);
		    s += len;
d1394 9
a1402 3
		 * There will always enough room in sv since such escapes will
		 * be longer than any utf8 sequence they can end up as
		 */
d1404 7
a1410 3
		    if (!thisutf && !has_utf && uv > 255) {
		        /* might need to recode whatever we have accumulated so far
			 * if it contains any hibit chars
d1414 1
d1416 1
a1416 1
			    if (*c & 0x80)
d1422 4
a1425 1
			    d = SvGROW(sv, SvCUR(sv) + hicount + 1) + (d - old_pvx);
d1432 3
a1434 4
			        if (*src & 0x80) {
				    dst--;
				    uv_to_utf8((U8*)dst, (U8)*src--);
				    dst--;
d1443 1
a1443 1
                    if (thisutf || uv > 255) {
d1445 8
a1452 1
			has_utf = TRUE;
d1471 1
a1471 1
 
d1478 1
a1478 1
		    res = new_constant( Nullch, 0, "charnames", 
d1480 2
d1483 1
a1483 1
		    if (!has_utf && SvUTF8(res)) {
d1487 1
d1489 2
d1492 1
a1492 1
			has_utf = TRUE;
d1517 2
a1518 1
		*d++ = toCTRL(*d); 
d1520 4
a1523 2
		len = *s++;
		*d++ = toCTRL(len);
d1564 28
a1591 1
	*d++ = *s++;
d1598 1
a1598 1
    if (has_utf)
d1610 1
a1610 1
	    sv = new_constant(start, s - start, (PL_lex_inpat ? "qr" : "q"), 
d1612 1
a1612 1
			      ( PL_lex_inwhat == OP_TRANS 
d1883 1
a1883 1
 * 'pre-processing' function into the current source input stream. 
d1893 1
a1893 1
 * and the IoDIRP field is used to store the function pointer,
d1911 1
a1911 1
    IoDIRP(datasv) = (DIR*)funcp; /* stash funcp into spare field */
d1919 1
a1919 1
 
d1931 1
a1931 1
    if (IoDIRP(datasv) == (DIR*)funcp) {
d1933 1
a1933 1
	IoDIRP(datasv) = (DIR*)NULL;
d1946 2
a1947 2
            
               
d1960 1
a1960 1
	if (maxlen) { 
d1993 1
a1993 1
    funcp = (filter_t)IoDIRP(datasv);
d2024 25
d2082 23
a2105 3
#ifdef USE_PURE_BISON
Perl_yylex(pTHX_ YYSTYPE *lvalp, int *lcharp)
#else
a2106 1
#endif
a2107 1
    dTHR;
d2114 1
a2114 5

#ifdef USE_PURE_BISON
    yylval_pointer = lvalp;
    yychar_pointer = lcharp;
#endif
d2122 3
d2149 1
a2149 1
	/* 
d2224 8
a2231 3
	    if (!gv || ((PL_tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
		yyerror(Perl_form(aTHX_ "In string, %s now must be written as \\%s",
			     PL_tokenbuf, PL_tokenbuf));
d2262 4
d2297 2
d2349 2
d2447 1
a2447 1
    DEBUG_p( {
d2467 3
d2525 1
d2536 1
d2554 1
d2559 1
d2563 30
d2602 1
d2617 1
d2706 1
d2731 1
a2731 1
		    PerlProc_execv(ipath, newargv);
d2734 1
d2741 1
a2741 1
		    while (*d == ' ' || *d == '\t') d++;
d2761 1
d2780 1
a2780 1
	Perl_croak(aTHX_ 
d2784 3
d2792 5
d2816 2
d2822 1
a2822 1
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
d2827 3
a2832 1
	    PL_last_lop_op = OP_FTEREAD;	/* good enough */
d2834 33
a2866 27
	    case 'r': FTST(OP_FTEREAD);
	    case 'w': FTST(OP_FTEWRITE);
	    case 'x': FTST(OP_FTEEXEC);
	    case 'o': FTST(OP_FTEOWNED);
	    case 'R': FTST(OP_FTRREAD);
	    case 'W': FTST(OP_FTRWRITE);
	    case 'X': FTST(OP_FTREXEC);
	    case 'O': FTST(OP_FTROWNED);
	    case 'e': FTST(OP_FTIS);
	    case 'z': FTST(OP_FTZERO);
	    case 's': FTST(OP_FTSIZE);
	    case 'f': FTST(OP_FTFILE);
	    case 'd': FTST(OP_FTDIR);
	    case 'l': FTST(OP_FTLINK);
	    case 'p': FTST(OP_FTPIPE);
	    case 'S': FTST(OP_FTSOCK);
	    case 'u': FTST(OP_FTSUID);
	    case 'g': FTST(OP_FTSGID);
	    case 'k': FTST(OP_FTSVTX);
	    case 'b': FTST(OP_FTBLK);
	    case 'c': FTST(OP_FTCHR);
	    case 't': FTST(OP_FTTTY);
	    case 'T': FTST(OP_FTTEXT);
	    case 'B': FTST(OP_FTBINARY);
	    case 'M': gv_fetchpv("\024",TRUE, SVt_PV); FTST(OP_FTMTIME);
	    case 'A': gv_fetchpv("\024",TRUE, SVt_PV); FTST(OP_FTATIME);
	    case 'C': gv_fetchpv("\024",TRUE, SVt_PV); FTST(OP_FTCTIME);
d2871 5
a3003 4
			if (PL_lex_stuff) {
			    SvREFCNT_dec(PL_lex_stuff);
			    PL_lex_stuff = Nullsv;
			}
d3023 15
a3037 3
		    attrs = append_elem(OP_LIST, attrs,
					newSVOP(OP_CONST, 0,
						newSVpvn(s, len)));
d3082 1
a3082 2
	if (CopLINE(PL_curcop) < PL_copline)
	    PL_copline = CopLINE(PL_curcop);
d3126 1
a3126 1
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
d3133 1
a3133 1
		while (d < PL_bufend && (*d == ' ' || *d == '\t'))
d3139 1
a3139 1
		while (d < PL_bufend && (*d == ' ' || *d == '\t'))
d3144 3
d3262 1
a3262 1
	if (PL_lex_brackets < PL_lex_formbrack)
d3359 1
a3359 1
	    for (t = s; *t == ' ' || *t == '\t'; t++) ;
d3361 1
a3361 1
	    for (t = s; *t == ' ' || *t == '\t' || *t == '\r'; t++) ;
d3584 2
a3585 2
	    if (PL_oldoldbufptr == PL_last_uni 
		&& (*PL_last_uni != 's' || s - PL_last_uni < 5 
d3629 4
a3632 1
	s = scan_num(s);
d3639 3
d3658 3
d3674 1
a3674 1
	    if (*d == '$' || *d == '@@' || *d == '\\' || *d & 0x80) {
d3683 3
d3711 1
a3711 1
		s = scan_num(s);
d3722 1
a3722 1
		    s = scan_num(s);
d3797 1
a3797 1
	if (strnEQ(d,"=>",2)) {
d3801 2
d3887 1
a3887 1
			Perl_warner(aTHX_ WARN_BAREWORD, 
a3953 1
		/* If followed by a paren, it's certainly a subroutine. */
d3957 11
d3971 1
a3971 1
			for (d = s + 1; *d == ' ' || *d == '\t'; d++) ;
d4108 1
a4108 1
		    IoTYPE(GvIOp(gv)) = '|';
d4110 1
a4110 1
		    IoTYPE(GvIOp(gv)) = '-';
d4112 1
a4112 1
		    IoTYPE(GvIOp(gv)) = '<';
d4121 1
a4121 1
		    if (IoTYPE(GvIOp(gv)) == '<') {
d4128 1
a4128 1
			((FILE*)PL_rsfp)->flags |= _F_BIN;
d4285 1
a4285 1
	    
d4489 1
a4489 1
	    
d4557 1
a4557 1
		PL_in_my_stash = gv_stashpv(PL_tokenbuf, FALSE);
d4634 1
a4634 1
	    
d4665 1
d4686 3
d4690 1
a4690 1
					    newSVOP(OP_CONST, 0, newSVpvn(b, d-b)));
d4698 1
a4698 1
	    if (PL_lex_stuff)
d4700 2
a4701 1
	    PL_lex_stuff = Nullsv;
d4801 1
a4801 1
	    
d4969 1
a4969 4
		    if (!s) {
			if (PL_lex_stuff)
			    SvREFCNT_dec(PL_lex_stuff);
			PL_lex_stuff = Nullsv;
a4970 1
		    }
d5086 1
a5086 1
		if (*d != '0' && isDIGIT(*d)) 
d5141 1
a5141 1
	    if (ctl_l[0] == '\0') 
d5166 3
d5221 1
a5221 1
	    if (strEQ(d,"chop"))		return KEY_chop;
d5226 1
a5226 1
	    if (strEQ(d,"chomp"))		return KEY_chomp;
d5288 1
a5288 1
	    if (strEQ(d,"each"))		return KEY_each;
d5438 1
a5438 1
	    if (strEQ(d,"keys"))		return KEY_keys;
d5529 1
a5529 1
	    if (strEQ(d,"pop"))			return KEY_pop;
d5533 1
a5533 1
	    if (strEQ(d,"push"))		return KEY_push;
d5640 1
a5640 1
		if (strEQ(d,"shift"))		return KEY_shift;
d5669 1
a5669 1
	    if (strEQ(d,"splice"))		return KEY_splice;
d5749 1
a5749 1
	    if (strEQ(d,"unshift"))		return KEY_unshift;
a5794 1
	dTHR;				/* only for ckWARN */
d5849 1
a5849 1
    
a5852 1
	why1 = "%^H is not consistent";
d5854 1
a5854 1
	       ? " (missing \"use charnames ...\"?)"
d5856 10
a5865 1
	why3 = "";
d5867 1
a5867 1
	msg = Perl_newSVpvf(aTHX_ "constant(%s): %s%s%s", 
d5869 1
d5889 1
a5889 1
    
d5893 1
a5893 1
    
d5895 1
a5895 1
    EXTEND(sp, 4);
a5900 1
    PUSHs(cv);
d5903 1
a5903 1
    
d5905 1
a5905 1
    
d5918 1
a5918 1
    
d5923 1
a5923 1
    
d5934 1
a5934 1
  
d5954 1
a5954 1
	else if (UTF && *(U8*)s >= 0xc0 && isALNUM_utf8((U8*)s)) {
d5956 1
a5956 1
	    while (*t & 0x80 && is_utf8_mark((U8*)t))
d6006 1
a6006 1
	    else if (UTF && *(U8*)s >= 0xc0 && isALNUM_utf8((U8*)s)) {
d6008 1
a6008 1
		while (*t & 0x80 && is_utf8_mark((U8*)t))
d6049 1
a6049 1
		if (ch != ' ' && ch != '\t') {
d6061 1
a6061 1
		    while (e < send && *e & 0x80 && is_utf8_mark((U8*)e))
d6075 1
a6075 1
	    while (s < send && (*s == ' ' || *s == '\t')) s++;
a6076 1
		dTHR;			/* only for ckWARN */
d6087 2
a6088 2
	} 
	/* Handle extended ${^Foo} variables 
a6107 1
		dTHR;			/* only for ckWARN */
d6153 1
a6153 4
    if (!s) {
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
a6154 1
    }
d6186 1
a6186 4
    if (!s) {
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
a6187 1
    }
d6195 1
a6195 1
	if (PL_lex_stuff)
d6197 2
a6198 4
	PL_lex_stuff = Nullsv;
	if (PL_lex_repl)
	    SvREFCNT_dec(PL_lex_repl);
	PL_lex_repl = Nullsv;
d6253 1
a6253 4
    if (!s) {
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
a6254 1
    }
d6260 1
a6260 1
	if (PL_lex_stuff)
d6262 2
a6263 4
	PL_lex_stuff = Nullsv;
	if (PL_lex_repl)
	    SvREFCNT_dec(PL_lex_repl);
	PL_lex_repl = Nullsv;
d6267 2
a6268 9
    if (UTF) {
	o = newSVOP(OP_TRANS, 0, 0);
	utf8 = OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF;
    }
    else {
	New(803,tbl,256,short);
	o = newPVOP(OP_TRANS, 0, (char*)tbl);
	utf8 = 0;
    }
d6271 1
a6271 1
    while (strchr("cdsCU", *s)) {
a6277 18
	else {
	    switch (count++) {
	    case 0:
		if (*s == 'C')
		    utf8 &= ~OPpTRANS_FROM_UTF;
		else
		    utf8 |= OPpTRANS_FROM_UTF;
		break;
	    case 1:
		if (*s == 'C')
		    utf8 &= ~OPpTRANS_TO_UTF;
		else
		    utf8 |= OPpTRANS_TO_UTF;
		break;
	    default: 
		Perl_croak(aTHX_ "Too many /C and /U options");
	    }
	}
d6280 3
a6282 1
    o->op_private = del|squash|complement|utf8;
a6291 1
    dTHR;
d6307 1
a6307 1
    for (peek = s; *peek == ' ' || *peek == '\t'; peek++) ;
d6424 1
d6436 1
d6478 2
d6630 1
a6630 1
      
d6637 5
a6641 5
   The lexer always reads these strings into lex_stuff, except in the
   case of the operators which take *two* arguments (s/// and tr///)
   when it checks to see if lex_stuff is full (presumably with the 1st
   arg to s or tr) and if so puts the string into lex_repl.

a6646 1
    dTHR;
d6653 1
a6653 1
    bool has_utf = FALSE;		/* is there any utf8 content? */
d6664 2
a6665 2
    if ((term & 0x80) && UTF)
	has_utf = TRUE;
d6711 2
a6712 2
		else if (!has_utf && (*s & 0x80) && UTF)
		    has_utf = TRUE;
d6740 2
a6741 2
		else if (!has_utf && (*s & 0x80) && UTF)
		    has_utf = TRUE;
d6795 1
d6797 1
a6797 1
    
d6802 1
a6802 1
    if (has_utf)
d6816 1
a6816 1
    
d6845 1
a6845 1
  
d6847 1
a6847 1
Perl_scan_num(pTHX_ char *start)
d6852 1
a6852 1
    NV value;				/* number read, as a double */
d6863 1
a6863 1
      
a6877 1
    	    dTHR;
a6964 1
			    dTHR;
a6995 1
		dTHR;
a7003 1
		dTHR;
d7029 1
a7029 1
	    /* skip underscores, checking for misplaced ones 
a7032 1
		dTHR;			/* only for ckWARN */
a7047 1
	    dTHR;
d7103 1
a7103 3
	/* unfortunately this monster needs to be on one line or
	   makedepend will be confused. */
#if (defined(USE_64_BIT_INT) && (!defined(HAS_STRTOLL)|| !defined(HAS_STRTOULL))) || (!defined(USE_64_BIT_INT) && (!defined(HAS_STRTOL) || !defined(HAS_STRTOUL)))
a7105 29
	   No working strto[u]l[l]. Since atoi() doesn't do range checks,
	   we need to do this the hard way.
	 */

	value = Atof(PL_tokenbuf);

	/* 
	   See if we can make do with an integer value without loss of
	   precision.  We use I_V to cast to an int, because some
	   compilers have issues.  Then we try casting it back and see
	   if it was the same.  We only do this if we know we
	   specifically read an integer.

	   Note: if floatit is true, then we don't need to do the
	   conversion at all.
	*/
	{
	    UV tryuv = U_V(value);
	    if (!floatit && (NV)tryuv == value) {
		if (tryuv <= IV_MAX)
		    sv_setiv(sv, (IV)tryuv);
		else
		    sv_setuv(sv, tryuv);
	    }
	    else
		sv_setnv(sv, value);
	}
#else
	/*
d7120 1
a7120 1
	    	floatit = TRUE; /* probably just too large */
d7123 2
d7129 51
a7179 2
	    value = Atof(PL_tokenbuf);
	    sv_setnv(sv, value);
d7184 1
a7184 1
	    sv = new_constant(PL_tokenbuf, d - PL_tokenbuf, 
d7199 1
a7199 1
		U8 tmpbuf[UTF8_MAXLEN];
d7244 2
a7245 1
		    sv_utf8_downgrade(sv, TRUE);
d7255 1
a7255 1
	yylval.opval = newSVOP(OP_CONST, 0, sv);
d7257 1
a7257 1
	yylval.opval = Nullop;
a7264 1
    dTHR;
d7271 1
a7271 1
	if (*s == '.' || *s == '}') {
d7274 1
a7274 1
	    for (t = s+1;*t == ' ' || *t == '\t'; t++) ;
d7276 1
a7276 1
	    for (t = s+1;*t == ' ' || *t == '\t' || *t == '\r'; t++) ;
d7312 1
a7355 1
    dTHR;
d7408 3
a7413 1
    dTHR;
a7422 1
    dTHR;
d7489 1
a7489 1
	    Perl_croak(aTHX_ "%_%s has too many errors.\n",
d7499 64
d7564 15
d7600 40
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d14 7
d22 1
d25 2
a26 43
#ifndef PERL_OBJECT
static void check_uni _((void));
static void  force_next _((I32 type));
static char *force_version _((char *start));
static char *force_word _((char *start, int token, int check_keyword, int allow_pack, int allow_tick));
static SV *tokeq _((SV *sv));
static char *scan_const _((char *start));
static char *scan_formline _((char *s));
static char *scan_heredoc _((char *s));
static char *scan_ident _((char *s, char *send, char *dest, STRLEN destlen,
			   I32 ck_uni));
static char *scan_inputsymbol _((char *start));
static char *scan_pat _((char *start, I32 type));
static char *scan_str _((char *start));
static char *scan_subst _((char *start));
static char *scan_trans _((char *start));
static char *scan_word _((char *s, char *dest, STRLEN destlen,
			  int allow_package, STRLEN *slp));
static char *skipspace _((char *s));
static void checkcomma _((char *s, char *name, char *what));
static void force_ident _((char *s, int kind));
static void incline _((char *s));
static int intuit_method _((char *s, GV *gv));
static int intuit_more _((char *s));
static I32 lop _((I32 f, expectation x, char *s));
static void missingterm _((char *s));
static void no_op _((char *what, char *s));
static void set_csh _((void));
static I32 sublex_done _((void));
static I32 sublex_push _((void));
static I32 sublex_start _((void));
#ifdef CRIPPLED_CC
static int uni _((I32 f, char *s));
#endif
static char * filter_gets _((SV *sv, PerlIO *fp, STRLEN append));
static void restore_rsfp _((void *f));
static SV *new_constant _((char *s, STRLEN len, char *key, SV *sv, SV *pv, char *type));
static void restore_expect _((void *e));
static void restore_lex_expect _((void *e));

static char *PL_super_bufptr;
static char *PL_super_bufend;
#endif /* PERL_OBJECT */
d30 14
a43 1
/* The following are arranged oddly so that the guard on the switch statement
a60 7
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif

d71 12
d85 2
d90 29
a118 1
#define CLINE (PL_copline = (PL_curcop->cop_line < PL_copline ? PL_curcop->cop_line : PL_copline))
d159 7
d167 1
a167 1
ao(int toketype)
d180 13
d194 1
a194 1
no_op(char *what, char *s)
d199 7
a205 2
    PL_bufptr = s;
    yywarn(form("%s found where operator expected", what));
d207 2
a208 2
	warn("\t(Missing semicolon on previous line?)\n");
    else if (PL_oldoldbufptr && isIDFIRST(*PL_oldoldbufptr)) {
d210 1
a210 1
	for (t = PL_oldoldbufptr; *t && (isALNUM(*t) || *t == ':'); t++) ;
d212 1
a212 1
	    warn("\t(Do you need to predeclare %.*s?)\n",
a213 1

d216 1
a216 1
	warn("\t(Missing operator before %.*s?)\n", s - oldbp, oldbp);
d220 9
d230 1
a230 1
missingterm(char *s)
d258 1
a258 1
    croak("Can't find string terminator %c%s%c anywhere before EOF",q,s,q);
d261 4
d266 1
a266 1
deprecate(char *s)
d268 3
a270 2
    if (PL_dowarn)
	warn("Use of %s is deprecated", s);
d273 5
d279 1
a279 1
depcom(void)
d284 52
a335 1
#ifdef WIN32
d338 1
a338 1
win32_textfilter(int idx, SV *sv, int maxlen)
d340 9
a348 4
 I32 count = FILTER_READ(idx+1, sv, maxlen);
 if (count > 0 && !maxlen)
  win32_strip_return(sv);
 return count;
d352 5
d359 1
a359 1
lex_start(SV *line)
a366 1
    SAVEI32(PL_lex_fakebrack);
d370 1
a370 1
    SAVESPTR(PL_lex_inpat);
d372 10
a381 1
    SAVEI16(PL_curcop->cop_line);
d390 1
a390 1
    SAVEDESTRUCTOR(restore_rsfp, PL_rsfp);
d393 1
d395 2
a396 2
    SAVEDESTRUCTOR(restore_expect, PL_tokenbuf + PL_expect); /* encode as pointer */
    SAVEDESTRUCTOR(restore_lex_expect, PL_tokenbuf + PL_expect);
a401 1
    PL_lex_fakebrack = 0;
d414 1
d428 1
a428 1
    PL_rs = newSVpv("\n", 1);
d432 6
d439 1
a439 1
lex_end(void)
d444 9
a452 25
STATIC void
restore_rsfp(void *f)
{
    PerlIO *fp = (PerlIO*)f;

    if (PL_rsfp == PerlIO_stdin())
	PerlIO_clearerr(PL_rsfp);
    else if (PL_rsfp && (PL_rsfp != fp))
	PerlIO_close(PL_rsfp);
    PL_rsfp = fp;
}

STATIC void
restore_expect(void *e)
{
    /* a safe way to store a small integer in a pointer */
    PL_expect = (expectation)((char *)e - PL_tokenbuf);
}

STATIC void
restore_lex_expect(void *e)
{
    /* a safe way to store a small integer in a pointer */
    PL_lex_expect = (expectation)((char *)e - PL_tokenbuf);
}
d455 1
a455 1
incline(char *s)
d460 1
a461 1
    int sawline = 0;
d463 1
a463 1
    PL_curcop->cop_line++;
d467 9
a475 4
    if (strnEQ(s, "line ", 5)) {
	s += 5;
	sawline = 1;
    }
d483 1
a483 1
    if (*s == '"' && (t = strchr(s+1, '"')))
d485 2
a487 2
	if (!sawline)
	    return;		/* false alarm */
d489 1
d491 5
d499 1
a499 3
	PL_curcop->cop_filegv = gv_fetchfile(s);
    else
	PL_curcop->cop_filegv = gv_fetchfile(PL_origfilename);
d501 1
a501 1
    PL_curcop->cop_line = atoi(n)-1;
d504 6
d511 1
a511 1
skipspace(register char *s)
d521 2
d527 2
d540 7
a546 1
	if (s < PL_bufend || !PL_rsfp || PL_lex_state != LEX_NORMAL)
d548 6
a553 1
	if ((s = filter_gets(PL_linestr, PL_rsfp, (prevlen = SvCUR(PL_linestr)))) == Nullch) {
d563 4
a566 1
	    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = s = PL_linestart = SvPVX(PL_linestr);
d568 8
d585 9
d597 6
d604 4
d613 1
a613 1
	    av_store(GvAV(PL_curcop->cop_filegv),(I32)PL_curcop->cop_line,sv);
d618 9
d628 2
a629 1
check_uni(void) {
a630 1
    char ch;
d632 1
d638 1
a638 1
    for (s = PL_last_uni; isALNUM(*s) || *s == '-'; s++) ;
d641 8
a648 4
    ch = *s;
    *s = '\0';
    warn("Warning: Use of \"%s\" without parens is ambiguous", PL_last_uni);
    *s = ch;
d651 5
d662 1
a662 1
uni(I32 f, char *s)
d680 5
d687 8
d696 1
a696 1
lop(I32 f, expectation x, char *s)
d716 9
d726 1
a726 1
force_next(I32 type)
d737 16
d754 1
a754 1
force_word(register char *start, int token, int check_keyword, int allow_pack, int allow_initial_tick)
d761 1
a761 1
    if (isIDFIRST(*s) ||
a773 2
		force_next(')');
		force_next('(');
d783 9
d793 1
a793 1
force_ident(register char *s, int kind)
d815 30
d846 1
a846 1
force_version(char *s)
d849 1
d853 7
a859 7
    /* default VERSION number -- GBARR */

    if(isDIGIT(*s)) {
        char *d;
        int c;
        for( d=s, c = 1; isDIGIT(*d) || *d == '_' || (*d == '.' && c--); d++);
        if((*d == ';' || isSPACE(*d)) && *(skipspace(d)) != ',') {
a860 1
            /* real VERSION number -- GBARR */
d862 6
d878 8
d887 1
a887 1
tokeq(SV *sv)
d908 1
a908 1
	pv = sv_2mortal(newSVpv(SvPVX(pv), len));
d924 32
d957 1
a957 1
sublex_start(void)
d976 1
a976 1
	    nsv = newSVpv(p, len);
d1000 8
d1009 1
a1009 1
sublex_push(void)
a1016 1
    SAVEI32(PL_lex_fakebrack);
d1020 1
a1020 1
    SAVESPTR(PL_lex_inpat);
d1022 1
a1022 1
    SAVEI16(PL_curcop->cop_line);
d1034 2
a1035 1
    PL_bufend = PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart = SvPVX(PL_linestr);
a1040 1
    PL_lex_fakebrack = 0;
d1049 1
a1049 1
    PL_curcop->cop_line = PL_multi_start;
d1060 5
d1066 1
a1066 1
sublex_done(void)
d1070 1
a1070 1
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv("",0));
d1079 1
a1079 1
    /* Is there a right-hand side to take care of? */
a1087 1
	PL_lex_fakebrack = 0;
d1091 1
a1091 1
	if (SvCOMPILED(PL_lex_repl)) {
d1094 4
d1099 1
a1099 1
	else
d1101 2
a1102 1
	PL_lex_repl = Nullsv;
d1110 1
d1189 1
a1189 1
scan_const(char *start)
d1196 1
d1198 1
d1200 8
a1207 2
    /* leaveit is the set of acceptably-backslashed characters */
    char *leaveit =
d1209 1
a1209 1
	    ? "\\.^$@@AGZdDwWsSbB+*?|()-nrtfeaxcz0123456789[{]} \t\n\r\f\v#"
d1222 2
a1223 2
		SvGROW(sv, SvLEN(sv) + 256);	/* expand the sv -- there'll never be more'n 256 chars in a range for it to grow by */
		d = SvPVX(sv) + i;		/* restore d after the grow potentially has changed the ptr */
d1254 5
d1266 2
a1267 1
	/* skip for regexp comments /(?#comment)/ */
d1272 4
a1275 1
	    } else if (s[2] == '{') {	/* This should march regcomp.c */
d1277 1
a1277 1
		char *regparse = s + 3;
d1289 2
a1290 3
		if (*regparse == ')')
		    regparse++;
		else
d1292 2
a1293 1
		while (s < regparse && *s != ')')
d1306 2
a1307 1
	else if (*s == '@@' && s[1] && (isALNUM(s[1]) || strchr(":'{$", s[1])))
d1320 19
d1344 1
a1344 1
	    if (*s && strchr(leaveit, *s)) {
d1354 3
a1356 2
		if (PL_dowarn)
		    warn("\\%c better written as $%c", *s, *s);
a1376 1
	    /* default action is to copy the quoted character */
d1378 10
a1387 2
		*d++ = *s++;
		continue;
d1392 1
a1392 1
		*d++ = scan_oct(s, 3, &len);
d1394 1
a1394 1
		continue;
d1398 106
a1503 2
		*d++ = scan_hex(++s, 2, &len);
		s += len;
d1536 8
d1550 1
d1564 2
d1589 19
d1609 1
d1611 1
a1611 1
intuit_more(register char *s)
d1645 1
d1674 1
a1674 1
		if (isALNUM(s[1])) {
d1741 21
d1763 1
a1763 1
intuit_method(char *start, GV *gv)
d1786 5
d1815 1
a1815 1
						   newSVpv(tmpbuf,0));
d1826 7
d1834 1
a1834 1
incl_perldb(void)
d1859 2
a1860 1
 * and the IoDIRP field is used to store the function pointer.
a1863 3
#ifndef PERL_OBJECT
static int filter_debug = 0;
#endif
d1866 1
a1866 1
filter_add(filter_t funcp, SV *datasv)
d1868 3
a1870 4
    if (!funcp){ /* temporary handy debugging hack to be deleted */
	filter_debug = atoi((char*)datasv);
	return NULL;
    }
d1876 1
a1876 1
        die("Can't upgrade filter_add data to SVt_PVIO");
d1878 3
a1880 4
    if (filter_debug) {
	STRLEN n_a;
	warn("filter_add func %p (%s)", funcp, SvPV(datasv,n_a));
    }
d1889 1
a1889 1
filter_del(filter_t funcp)
d1891 2
a1892 2
    if (filter_debug)
	warn("filter_del func %p", funcp);
d1896 4
a1899 1
    if (IoDIRP(FILTER_DATA(AvFILLp(PL_rsfp_filters))) == (DIR*)funcp){
d1905 1
a1905 1
    die("filter_del can only delete in reverse order (currently)");
d1911 1
a1911 1
filter_read(int idx, SV *buf_sv, int maxlen)
d1924 2
a1925 2
	if (filter_debug)
	    warn("filter_read %d: from rsfp\n", idx);
d1953 3
a1955 2
	if (filter_debug)
	    warn("filter_read %d: skipped (filter deleted)\n", idx);
d1960 3
a1962 5
    if (filter_debug) {
	STRLEN n_a;
	warn("filter_read %d: via function %p (%s)\n",
		idx, funcp, SvPV(datasv,n_a));
    }
d1966 1
a1966 1
    return (*funcp)(PERL_OBJECT_THIS_ idx, buf_sv, maxlen);
d1970 1
a1970 1
filter_gets(register SV *sv, register PerlIO *fp, STRLEN append)
d1972 1
a1972 1
#ifdef WIN32FILTER
d1974 1
a1974 1
	filter_add(win32_textfilter,NULL);
d1993 3
a1995 1
	{ "OPERATOR", "TERM", "REF", "STATE", "BLOCK", "TERMBLOCK" };
a1997 2
EXT int yychar;		/* last token */

d2024 5
a2028 1
yylex(void)
d2038 5
d2056 10
a2065 2
	    if (strchr(PL_tokenbuf,':'))
		croak(no_myglob,PL_tokenbuf);
d2067 4
a2070 3
	    yylval.opval = newOP(OP_PADANY, 0);
	    yylval.opval->op_targ = pad_allocmy(PL_tokenbuf);
	    return PRIVATEREF;
d2098 20
d2129 1
a2129 1
			    croak("Can't use \"my %s\" in sort comparison",
d2149 1
a2149 1
		yyerror(form("In string, %s now must be written as \\%s",
d2172 1
a2172 1
    /* when we're already built the next token, just pull it out the queue */
d2189 1
a2189 1
	    croak("panic: INTERPCASEMOD");
d2244 1
a2244 1
		croak("panic: yylex");
d2301 7
d2312 1
a2312 1
	    croak("panic: INTERPCONCAT");
d2359 2
a2360 1
	PerlIO_printf(PerlIO_stderr(), "### Tokener expecting %s at %s\n", exp_name[PL_expect], s);
d2366 3
a2368 1
	croak("Unrecognized character \\%03o", *s & 255);
d2377 1
a2377 1
		yyerror("Missing right bracket");
d2410 1
a2410 1
			    sv_catpvf(PL_linestr, "@@F=split(%s);", PL_splitstr);
d2416 1
a2416 1
			    sv_catpvf(PL_linestr, "@@F=split(%s%c",
d2423 1
a2423 1
			    sv_catpvf(PL_linestr, "%c);", delim);
d2438 1
a2438 1
		av_store(GvAV(PL_curcop->cop_filegv),(I32)PL_curcop->cop_line,sv);
d2487 1
a2487 1
	    av_store(GvAV(PL_curcop->cop_filegv),(I32)PL_curcop->cop_line,sv);
d2490 1
a2490 1
	if (PL_curcop->cop_line == 1) {
d2528 1
a2528 1
		    if (sv_eq(x, GvSV(PL_curcop->cop_filegv))) {
d2540 1
a2540 1
		if (!d)
d2542 16
d2603 1
a2603 1
		    croak("Can't exec %s", ipath);
d2618 1
a2618 1
				croak("Too late for \"-%.*s\" option",
d2623 2
a2624 2
			if (PERLDB_LINE && !oldpdb ||
			    ( PL_minus_n || PL_minus_p ) && !(oldn || oldp) )
d2648 3
a2650 3
	warn("Illegal character \\%03o (carriage return)", '\r');
	croak(
      "(Maybe you didn't strip carriage returns after a network transfer?)\n");
d2719 1
a2719 1
		croak("Unrecognized file test: -%c", (int)tmp);
d2734 1
a2734 1
	    if (isIDFIRST(*s)) {
d2815 96
d2920 2
a2921 2
	if (PL_curcop->cop_line < PL_copline)
	    PL_copline = PL_curcop->cop_line;
d2933 1
a2933 1
	    yyerror("Unmatched right bracket");
d2975 1
a2975 1
	    if (d < PL_bufend && isIDFIRST(*d)) {
d2988 1
d2993 1
d3034 2
a3035 1
				&& !isALNUM(*t)))) {
d3066 4
a3069 2
		else if (isALPHA(*s)) {
		    for (t++; t < PL_bufend && isALNUM(*t); t++) ;
d3087 1
a3087 1
	yylval.ival = PL_curcop->cop_line;
d3095 1
a3095 1
	    yyerror("Unmatched right bracket");
d3102 2
a3103 1
		if (PL_lex_fakebrack) {
d3106 1
a3106 1
		    return yylex();		/* ignore fake brackets */
d3114 2
a3115 1
	if (PL_lex_brackets < PL_lex_fakebrack) {
a3116 1
	    PL_lex_fakebrack = 0;
d3128 6
a3133 4
	    if (PL_dowarn && isALPHA(*s) && PL_bufptr == PL_linestart) {
		PL_curcop->cop_line--;
		warn(warn_nosemi);
		PL_curcop->cop_line++;
d3164 2
a3165 2
	if (PL_dowarn && tmp && isSPACE(*s) && strchr("+-*/%.^&|<",tmp))
	    warn("Reversed %c= operator",(int)tmp);
d3260 4
a3263 1
	if (s[1] == '#' && (isALPHA(s[2]) || strchr("_{$:", s[2]))) {
d3265 1
a3265 4
		no_op("Array length", PL_bufptr);
	    PL_tokenbuf[0] = '@@';
	    s = scan_ident(s + 1, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1,
			   FALSE);
d3273 3
d3277 1
a3277 3
	    no_op("Scalar", PL_bufptr);
	PL_tokenbuf[0] = '$';
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, FALSE);
d3287 1
a3287 1
				   newSViv((IV)PL_compiling.cop_arybase));
d3293 1
d3301 1
a3301 1
		if (PL_dowarn) {
d3303 1
a3303 1
			isSPACE(*t) || isALNUM(*t) || *t == '$';
d3309 3
a3311 2
			warn("Multidimensional syntax %.*s not supported",
			     (t - PL_bufptr) + 1, PL_bufptr);
d3317 1
a3317 1
		if (PL_dowarn && strEQ(PL_tokenbuf+1, "SIG") &&
d3323 1
a3323 1
		    if (isIDFIRST(*t)) {
d3326 3
a3328 2
			if (*t == ';' && perl_get_cv(tmpbuf, FALSE))
			    warn("You need to quote \"%s\"", tmpbuf);
d3335 1
a3335 1
	if (PL_lex_state == LEX_NORMAL && isSPACE(*d)) {
d3341 1
a3341 1
	    else if (strchr("&*<%", *s) && isIDFIRST(s[1]))
d3343 1
a3343 1
	    else if (isIDFIRST(*s)) {
d3346 1
a3346 1
		if (tmp = keyword(tmpbuf, len)) {
d3398 1
a3398 1
	    if (PL_dowarn) {
d3401 1
a3401 1
		    while (*t && (isALNUM(*t) || strchr(" \t$#+-'\"", *t)))
d3406 2
a3407 1
			warn("Scalar value %.*s better written as $%.*s",
d3422 2
a3423 1
		    || memNE(PL_last_uni, "study", 5) || isALNUM(PL_last_uni[5])))
d3471 1
a3471 1
	s = scan_str(s);
d3487 1
a3487 1
	s = scan_str(s);
d3501 1
a3501 1
	    if (*d == '$' || *d == '@@' || *d == '\\') {
d3509 1
a3509 1
	s = scan_str(s);
d3520 3
a3522 2
	if (PL_dowarn && PL_lex_inwhat && isDIGIT(*s))
	    warn("Can't use \\%c to mean $%c in expression", *s, *s);
d3527 25
d3581 1
a3581 1
    case 'v': case 'V':
a3587 1
	STRLEN n_a;
d3595 4
a3598 4
	tmp = (len == 1 && strchr("msyq", PL_tokenbuf[0]) ||
	       len == 2 && ((PL_tokenbuf[0] == 't' && PL_tokenbuf[1] == 'r') ||
			    (PL_tokenbuf[0] == 'q' &&
			     strchr("qwxr", PL_tokenbuf[1]))));
d3654 1
d3663 4
a3666 3
		if (PL_dowarn && hgv
		    && tmp != KEY_x && tmp != KEY_CORE) /* never ambiguous */
		    warn("Ambiguous call resolved as CORE::%s(), %s",
d3681 1
a3681 1
		if (*s == '\'' || *s == ':' && s[1] == ':') {
d3686 1
a3686 1
			croak("Bad name after %s%s", PL_tokenbuf,
d3693 3
a3695 3
			PL_curcop->cop_line--;
			warn(warn_nosemi);
			PL_curcop->cop_line++;
d3708 3
a3710 2
		    if (PL_dowarn && ! gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVHV))
			warn("Bareword \"%s\" refers to nonexistent package",
d3726 1
a3726 1
		    sv = newSVpv("CORE::GLOBAL::",14);
d3747 2
a3748 1
		    (PL_oldoldbufptr == PL_last_lop || PL_oldoldbufptr == PL_last_uni) &&
d3750 2
a3751 5
		    (PL_expect == XREF 
		     || ((opargs[PL_last_lop_op] >> OASHIFT)& 7) == OA_FILEREF
		     || (PL_last_lop_op == OP_ENTERSUB 
			 && PL_last_proto 
			 && PL_last_proto[PL_last_proto[0] == ';' ? 1 : 0] == '*')) )
d3760 1
a3760 1
		    if ((isALPHA(*s) || *s == '$') && (tmp=intuit_method(s,gv)))
d3767 4
a3770 2
                         (!immediate_paren && (!gv || !GvCVu(gv))) ) &&
                        (PL_last_lop_op != OP_MAPSTART && PL_last_lop_op != OP_GREPSTART)){
a3782 3
			CV *cv;
			if ((cv = GvCV(gv)) && SvPOK(cv))
			    PL_last_proto = SvPV((SV*)cv, n_a);
d3784 1
a3784 1
			if (*d == ')' && (sv = cv_const_sv(cv))) {
a3792 1
		    PL_last_lop_op = OP_ENTERSUB;
d3806 1
a3806 1
		if ((isALPHA(*s) || *s == '$') && (tmp = intuit_method(s,gv)))
d3813 3
a3815 2
		    if (lastchar == '-')
			warn("Ambiguous use of -%s resolved as -&%s()",
a3816 2
		    PL_last_lop = PL_oldbufptr;
		    PL_last_lop_op = OP_ENTERSUB;
d3830 2
d3836 1
a3836 1
			PL_last_proto = SvPV((SV*)cv, len);
d3839 1
a3839 1
			if (strEQ(PL_last_proto, "$"))
d3841 1
a3841 1
			if (*PL_last_proto == '&' && *s == '{') {
d3845 1
a3845 2
		    } else
			PL_last_proto = NULL;
a3851 17
		if (PL_hints & HINT_STRICT_SUBS &&
		    lastchar != '-' &&
		    strnNE(s,"->",2) &&
		    PL_last_lop_op != OP_TRUNCATE &&  /* S/F prototype in opcode.pl */
		    PL_last_lop_op != OP_ACCEPT &&
		    PL_last_lop_op != OP_PIPE_OP &&
		    PL_last_lop_op != OP_SOCKPAIR &&
		    !(PL_last_lop_op == OP_ENTERSUB 
			 && PL_last_proto 
			 && PL_last_proto[PL_last_proto[0] == ';' ? 1 : 0] == '*'))
		{
		    warn(
		     "Bareword \"%s\" not allowed while \"strict subs\" in use",
			PL_tokenbuf);
		    ++PL_error_count;
		}

d3854 11
a3864 6
	    bareword:
		if (PL_dowarn) {
		    if (lastchar != '-') {
			for (d = PL_tokenbuf; *d && isLOWER(*d); d++) ;
			if (!*d)
			    warn(warn_reserved, PL_tokenbuf);
d3869 3
a3871 2
		if (lastchar && strchr("*%&", lastchar)) {
		    warn("Operator or semicolon missing before %c%s",
d3873 2
a3874 1
		    warn("Ambiguous use of %c resolved as operator %c",
d3882 1
a3882 1
					newSVsv(GvSV(PL_curcop->cop_filegv)));
d3886 2
a3887 2
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0,
				    newSVpvf("%ld", (long)PL_curcop->cop_line));
d3906 1
a3906 1
		gv = gv_fetchpv(form("%s::DATA", pname), TRUE, SVt_PVIO);
d3925 22
d3955 2
a3957 1
	case KEY_INIT:
d3969 2
a3970 1
		tmp = keyword(PL_tokenbuf, len);
d3996 1
a3996 1
	    UNI(OP_BINMODE);
d4025 2
a4026 1
	    if (!PL_cryptseen++)
d4028 1
d4033 1
a4033 1
	    if (PL_dowarn) {
d4036 2
a4037 1
		    yywarn("chmod: mode argument is missing initial 0");
d4089 1
a4089 1
	    yylval.ival = PL_curcop->cop_line;
d4139 1
a4139 1
	    yylval.ival = PL_curcop->cop_line;
d4141 1
a4141 1
	    if (PL_expect == XSTATE && isIDFIRST(*s)) {
d4146 3
d4150 7
a4156 2
		if (isIDFIRST(*p))
		    croak("Missing $ on loop variable");
d4182 1
a4182 1
	    LOP(OP_GREPSTART, *s == '(' ? XTERM : XREF);
d4277 1
a4277 1
	    yylval.ival = PL_curcop->cop_line;
d4309 1
d4344 2
a4345 2
	    LOP(OP_MAPSTART,XREF);
	    
d4361 1
d4363 1
a4363 1
	    PL_in_my = TRUE;
d4365 1
a4365 1
	    if (isIDFIRST(*s)) {
d4367 2
d4377 1
d4396 4
a4399 1
	    OPERATOR(NOTOP);
d4403 1
a4403 1
	    if (isIDFIRST(*s)) {
d4405 1
a4405 1
		for (d = s; isALNUM(*d); d++) ;
d4407 4
a4410 3
		if (strchr("|&*+-=!?:.", *t))
		    warn("Precedence problem: open %.*s should be open(%.*s)",
			d-s,s, d-s,s);
d4458 1
a4458 1
	    s = scan_str(s);
d4468 1
a4468 1
	    s = scan_str(s);
d4471 4
a4474 1
	    if (PL_dowarn && SvLEN(PL_lex_stuff)) {
d4476 23
a4498 8
		for (; len; --len, ++d) {
		    if (*d == ',') {
			warn("Possible attempt to separate words with commas");
			break;
		    }
		    if (*d == '#') {
			warn("Possible attempt to put comments in qw() list");
			break;
d4500 4
d4506 2
a4507 2
	    force_next(')');
	    PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, tokeq(PL_lex_stuff));
a4508 7
	    force_next(THING);
	    force_next(',');
	    PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(" ",1));
	    force_next(THING);
	    force_next('(');
	    yylval.ival = OP_SPLIT;
	    CLINE;
d4510 1
a4510 4
	    PL_bufptr = s;
	    PL_last_lop = PL_oldbufptr;
	    PL_last_lop_op = OP_SPLIT;
	    return FUNC;
d4513 1
a4513 1
	    s = scan_str(s);
d4526 1
a4526 1
	    s = scan_str(s);
d4537 12
a4548 6
	    *PL_tokenbuf = '\0';
	    s = force_word(s,WORD,TRUE,TRUE,FALSE);
	    if (isIDFIRST(*PL_tokenbuf))
		gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf), TRUE);
	    else if (*s == '<')
		yyerror("<> should be quotes");
d4694 1
a4694 1
		croak("sort is now a reserved word");
a4717 1
	    PL_sawstudy++;
d4726 8
a4733 1
	    s = skipspace(s);
d4735 18
a4752 6
	    if (isIDFIRST(*s) || *s == '\'' || *s == ':') {
		char tmpbuf[sizeof PL_tokenbuf];
		PL_expect = XBLOCK;
		d = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
		if (strchr(tmpbuf, ':'))
		    sv_setpv(PL_subname, tmpbuf);
d4754 40
a4793 3
		    sv_setsv(PL_subname,PL_curstname);
		    sv_catpvn(PL_subname,"::",2);
		    sv_catpvn(PL_subname,tmpbuf,len);
d4795 2
a4796 7
		s = force_word(s,WORD,FALSE,TRUE,TRUE);
		s = skipspace(s);
	    }
	    else {
		PL_expect = XTERMBLOCK;
		sv_setpv(PL_subname,"?");
	    }
d4798 2
a4799 6
	    if (tmp == KEY_format) {
		s = skipspace(s);
		if (*s == '=')
		    PL_lex_formbrack = PL_lex_brackets + 1;
		OPERATOR(FORMAT);
	    }
d4801 3
a4803 8
	    /* Look for a prototype */
	    if (*s == '(') {
		char *p;

		s = scan_str(s);
		if (!s) {
		    if (PL_lex_stuff)
			SvREFCNT_dec(PL_lex_stuff);
d4805 1
a4805 1
		    croak("Prototype not terminated");
d4807 9
a4815 26
		/* strip spaces */
		d = SvPVX(PL_lex_stuff);
		tmp = 0;
		for (p = d; *p; ++p) {
		    if (!isSPACE(*p))
			d[tmp++] = *p;
		}
		d[tmp] = '\0';
		SvCUR(PL_lex_stuff) = tmp;

		PL_nexttoke++;
		PL_nextval[1] = PL_nextval[0];
		PL_nexttype[1] = PL_nexttype[0];
		PL_nextval[0].opval = (OP*)newSVOP(OP_CONST, 0, PL_lex_stuff);
		PL_nexttype[0] = THING;
		if (PL_nexttoke == 1) {
		    PL_lex_defer = PL_lex_state;
		    PL_lex_expect = PL_expect;
		    PL_lex_state = LEX_KNOWNEXT;
		}
		PL_lex_stuff = Nullsv;
	    }

	    if (*SvPV(PL_subname,n_a) == '?') {
		sv_setpv(PL_subname,"__ANON__");
		TOKEN(ANONSUB);
a4816 1
	    PREBLOCK(SUB);
d4875 1
a4875 1
	    yylval.ival = PL_curcop->cop_line;
d4879 1
a4879 1
	    yylval.ival = PL_curcop->cop_line;
d4895 1
a4895 1
	    if (PL_dowarn) {
d4897 3
a4899 2
		if (*d != '0' && isDIGIT(*d))
		    yywarn("umask: argument is missing initial 0");
d4910 1
a4910 1
	    if(isDIGIT(*s)) {
d4912 1
a4912 1
		if(*s == ';' || (s = skipspace(s), *s == ';')) {
a4927 1
	    PL_sawvec = TRUE;
d4931 1
a4931 1
	    yylval.ival = PL_curcop->cop_line;
d4979 1
a4979 1
keyword(register char *d, I32 len)
d5019 1
d5103 1
a5103 1
	    if (strEQ(d,"elseif")) warn("elseif should be elsif");
d5324 1
a5324 2
	    if (strEQ(d,"our")) { deprecate("reserved word \"our\"");
						return 0;}
d5598 1
a5598 1
checkcomma(register char *s, char *name, char *what)
d5602 16
a5617 12
    if (PL_dowarn && *s == ' ' && s[1] == '(') {	/* XXX gotta be a better way */
	int level = 1;
	for (w = s+2; *w && level; w++) {
	    if (*w == '(')
		++level;
	    else if (*w == ')')
		--level;
	}
	if (*w)
	    for (; *w && isSPACE(*w); w++) ;
	if (!*w || !strchr(";|})]oaiuw!=", *w))	/* an advisory hack only... */
	    warn("%s (...) interpreted as function",name);
d5625 1
a5625 1
    if (isIDFIRST(*s)) {
d5627 1
a5627 1
	while (isALNUM(*s))
d5634 1
a5634 1
	    kw = keyword(w, s - w) || perl_get_cv(w, FALSE) != 0;
d5638 1
a5638 1
	    croak("No comma allowed after %s", what);
d5643 5
d5649 2
a5650 1
new_constant(char *s, STRLEN len, char *key, SV *sv, SV *pv, char *type) 
a5653 1
    BINOP myop;
a5654 1
    bool oldcatch = CATCH_GET;
d5657 16
a5672 5
    char buf[128];
	    
    if (!table) {
	yyerror("%^H is not defined");
	return sv;
d5676 4
a5679 3
	sprintf(buf,"$^H{%s} is not defined", key);
	yyerror(buf);
	return sv;
d5683 4
a5686 4
    if (!pv)
	pv = sv_2mortal(newSVpv(s, len));
    if (type)
	typesv = sv_2mortal(newSVpv(type, 0));
d5688 2
a5689 7
	typesv = &PL_sv_undef;
    CATCH_SET(TRUE);
    Zero(&myop, 1, BINOP);
    myop.op_last = (OP *) &myop;
    myop.op_next = Nullop;
    myop.op_flags = OPf_WANT_SCALAR | OPf_STACKED;

d5691 4
a5694 8
    ENTER;
    SAVEOP();
    PL_op = (OP *) &myop;
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	PL_op->op_private |= OPpENTERSUB_DB;
    PUTBACK;
    pp_pushmark(ARGS);

d5696 2
a5697 1
    PUSHs(pv);
d5699 2
a5700 1
    PUSHs(typesv);
d5703 20
a5722 9

    if (PL_op = pp_entersub(ARGS))
      CALLRUNOPS();
    LEAVE;
    SPAGAIN;

    res = POPs;
    PUTBACK;
    CATCH_SET(oldcatch);
d5724 1
a5724 1

d5726 5
a5730 2
	sprintf(buf,"Call to &{$^H{%s}} did not return a defined value", key);
	yyerror(buf);
d5732 2
a5733 1
    return SvREFCNT_inc(res);
d5735 1
a5735 1

d5737 1
a5737 1
scan_word(register char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
d5743 2
a5744 2
	    croak(ident_too_long);
	if (isALNUM(*s))
d5746 1
a5746 1
	else if (*s == '\'' && allow_package && isIDFIRST(s[1])) {
d5755 10
d5774 1
a5774 1
scan_ident(register char *s, register char *send, char *dest, STRLEN destlen, I32 ck_uni)
a5780 2
    if (PL_lex_brackets == 0)
	PL_lex_fakebrack = 0;
d5788 1
a5788 1
		croak(ident_too_long);
d5795 2
a5796 2
		croak(ident_too_long);
	    if (isALNUM(*s))
d5798 1
a5798 1
	    else if (*s == '\'' && isIDFIRST(s[1])) {
d5807 10
d5829 1
a5829 1
      (isALNUM(s[1]) || strchr("${", s[1]) || strnEQ(s+1,"::",2)) )
d5831 1
a5831 4
	if (isDIGIT(s[1]) && PL_lex_state == LEX_INTERPNORMAL)
	    deprecate("\"$$<digit>\" to mean \"${$}<digit>\"");
	else
	    return s;
d5842 1
a5842 1
    if (*d == '^' && *s && (isUPPER(*s) || strchr("[\\]^_?", *s))) {
d5856 1
a5856 1
	if (isIDFIRST(*d)) {
d5858 17
a5874 2
	    while (isALNUM(*s) || *s == ':')
		*d++ = *s++;
d5878 5
a5882 3
		if (PL_dowarn && keyword(dest, d - dest)) {
		    char *brack = *s == '[' ? "[...]" : "{...}";
		    warn("Ambiguous use of %c{%s%s} resolved to %c%s%s",
a5884 1
		PL_lex_fakebrack = PL_lex_brackets+1;
d5886 1
a5886 1
		PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d5889 13
d5909 10
a5918 4
	    if (PL_dowarn && PL_lex_state == LEX_NORMAL &&
	      (keyword(dest, d - dest) || perl_get_cv(dest, FALSE)))
		warn("Ambiguous use of %c{%s} resolved to %c%s",
		    funny, dest, funny, dest);
d5930 2
a5931 1
void pmflag(U16 *pmfl, int ch)
d5950 1
a5950 1
scan_pat(char *start, I32 type)
d5955 1
a5955 1
    s = scan_str(start);
d5960 1
a5960 1
	croak("Search pattern not terminated");
d5982 1
a5982 1
scan_subst(char *start)
d5991 1
a5991 1
    s = scan_str(start);
d5997 1
a5997 1
	croak("Substitution pattern not terminated");
d6004 1
a6004 1
    s = scan_str(s);
d6012 1
a6012 1
	croak("Substitution replacement not terminated");
d6030 2
a6031 2
	PL_super_bufptr = s;
	PL_super_bufend = PL_bufend;
d6034 1
a6034 1
	repl = newSVpv("",0);
d6040 1
a6040 1
	SvCOMPILED_on(repl);
d6052 1
a6052 1
scan_trans(char *start)
d6058 1
a6058 1
    I32 Delete;
d6060 2
d6065 1
a6065 1
    s = scan_str(start);
d6070 1
a6070 1
	croak("Transliteration pattern not terminated");
d6075 1
a6075 1
    s = scan_str(s);
d6083 1
a6083 1
	croak("Transliteration replacement not terminated");
d6086 9
a6094 2
    New(803,tbl,256,short);
    o = newPVOP(OP_TRANS, 0, (char*)tbl);
d6096 2
a6097 2
    complement = Delete = squash = 0;
    while (*s == 'c' || *s == 'd' || *s == 's') {
d6101 2
a6102 2
	    Delete = OPpTRANS_DELETE;
	else
d6104 18
d6124 1
a6124 1
    o->op_private = Delete|squash|complement;
d6132 1
a6132 1
scan_heredoc(register char *s)
d6164 1
a6164 1
	if (!isALNUM(*s))
d6166 1
a6166 1
	for (; isALNUM(*s); s++) {
d6172 1
a6172 1
	croak("Delimiter for here document is too long");
d6202 1
a6202 1
	herewas = newSVpv(s,PL_bufend-s);
d6204 1
a6204 1
	s--, herewas = newSVpv(s,d-s);
d6219 1
a6219 1
    PL_multi_start = PL_curcop->cop_line;
d6223 2
a6224 2
	char *bufptr = PL_super_bufptr;
	char *bufend = PL_super_bufend;
d6233 1
a6233 1
		PL_curcop->cop_line++;
d6236 1
a6236 1
	    PL_curcop->cop_line = PL_multi_start;
d6253 1
a6253 1
		PL_curcop->cop_line++;
d6256 1
a6256 1
	    PL_curcop->cop_line = PL_multi_start;
d6261 1
a6261 1
	PL_curcop->cop_line++;	/* the preceding stmt passes a newline */
d6273 1
a6273 1
	    PL_curcop->cop_line = PL_multi_start;
d6276 1
a6276 1
	PL_curcop->cop_line++;
d6298 1
a6298 2
	    av_store(GvAV(PL_curcop->cop_filegv),
	      (I32)PL_curcop->cop_line,sv);
d6313 1
a6313 1
    PL_multi_end = PL_curcop->cop_line;
d6341 1
a6341 1
scan_inputsymbol(char *start)
d6346 1
d6351 4
a6354 1
    s = delimcpy(d, e, s + 1, PL_bufend, '>', &len);	/* extract until > */
d6357 1
a6357 1
       or if it didn't end
d6361 3
a6363 3
	croak("Excessively long <> operator");
    if (s >= PL_bufend)
	croak("Unterminated <> operator");
d6377 1
a6377 1
    while (*d && (isALNUM(*d) || *d == '\'' || *d == ':'))
d6389 1
a6389 1
	s = scan_str(start);
d6391 1
a6391 1
	   croak("Glob not terminated");
d6414 1
a6414 1
		PL_lex_op = (OP*)newUNOP(OP_READLINE, 0, newUNOP(OP_RV2GV, 0, o));
a6418 1
					newUNOP(OP_RV2GV, 0,
d6420 1
a6420 1
						newGVOP(OP_GV, 0, gv))));
d6422 2
a6423 1
	    /* we created the ops in lex_op, so make yylval.ival a null op */
d6442 2
d6461 1
d6484 1
a6484 1
scan_str(char *start)
d6493 1
d6504 3
d6508 1
a6508 1
    PL_multi_start = PL_curcop->cop_line;
d6524 2
d6532 1
a6532 1
	
d6538 1
a6538 1
		    PL_curcop->cop_line++;
d6541 1
a6541 1
		    if (s[1] == term)
d6551 2
d6566 1
a6566 1
		    PL_curcop->cop_line++;
d6569 2
a6570 1
		    if ((s[1] == PL_multi_open) || (s[1] == PL_multi_close))
d6580 2
d6593 2
a6594 1
  	if (s < PL_bufend) break;	/* handle case where we are done yet :-) */
d6618 1
a6618 1
	    PL_curcop->cop_line = PL_multi_start;
d6622 2
a6623 2
	PL_curcop->cop_line++;
	
d6630 1
a6630 2
	    av_store(GvAV(PL_curcop->cop_filegv),
	      (I32)PL_curcop->cop_line, sv);
d6632 1
a6632 1
	
d6639 5
a6643 1
    PL_multi_end = PL_curcop->cop_line;
d6671 1
a6671 1
  0(x[0-7A-F]+)|([0-7]+)
d6686 1
a6686 1
scan_num(char *start)
d6691 3
a6693 4
    I32 tryiv;				/* used to see if it can be an int */
    double value;			/* number read, as a double */
    SV *sv;				/* place to put the converted number */
    I32 floatit;			/* boolean: int or float? */
d6701 1
a6701 1
      croak("panic: scan_num");
d6704 1
a6704 2
       0.13 disguise, or a hexadecimal number.
    */
d6709 2
a6710 1
	     shift	the power of 2 of the base (hex == 4, octal == 3)
d6714 2
a6715 2
	     we in octal or hex?" indicator to disallow hex characters when
	     in octal mode.
d6717 3
a6719 1
	    UV u;
d6722 11
d6738 3
d6743 1
a6743 1
	    else if (s[1] == '.')
a6747 1
	    u = 0;
d6749 5
a6753 1
	    /* read the rest of the octal number */
d6755 3
a6757 1
		UV n, b;	/* n is used in the overflow test, b is the digit we're adding on */
d6772 2
a6773 2
		    if (shift != 4)
			yyerror("Illegal octal digit");
d6777 1
a6777 1
		case '0': case '1': case '2': case '3': case '4':
d6779 5
d6800 26
a6825 6
		    n = u << shift;	/* make room for the digit */
		    if (!overflowed && (n >> shift) != u
			&& !(PL_hints & HINT_NEW_BINARY)) {
			warn("Integer overflow in %s number",
			     (shift == 4) ? "hex" : "octal");
			overflowed = TRUE;
a6826 1
		    u = n | b;		/* add the digit to the end */
d6836 19
a6854 2
	    sv_setuv(sv, u);
	    if ( PL_hints & HINT_NEW_BINARY)
d6876 3
a6878 2
		if (PL_dowarn && lastub && s - lastub != 3)
		    warn("Misplaced _ in number");
d6884 1
a6884 1
		    croak(number_too_long);
d6891 5
a6895 2
	if (PL_dowarn && lastub && s - lastub != 3)
	    warn("Misplaced _ in number");
d6911 1
a6911 1
		    croak(number_too_long);
d6915 5
d6937 1
a6937 1
		    croak(number_too_long);
d6947 11
a6957 3
	/* reset numeric locale in case we were earlier left in Swaziland */
	SET_NUMERIC_STANDARD();
	value = atof(PL_tokenbuf);
d6969 35
a7003 4
	tryiv = I_V(value);
	if (!floatit && (double)tryiv == value)
	    sv_setiv(sv, tryiv);
	else
d7005 4
a7008 1
	if ( floatit ? (PL_hints & HINT_NEW_FLOAT) : (PL_hints & HINT_NEW_INTEGER) )
d7010 63
a7072 1
			      (floatit ? "float" : "integer"), sv, Nullsv, NULL);
d7078 4
a7081 1
    yylval.opval = newSVOP(OP_CONST, 0, sv);
d7087 1
a7087 1
scan_formline(register char *s)
d7092 1
a7092 1
    SV *stuff = newSVpv("",0);
d7123 8
d7169 1
a7169 1
set_csh(void)
d7178 1
a7178 1
start_subparse(I32 is_format, U32 flags)
d7188 1
a7188 1
    save_I32(&PL_subline);
d7191 1
a7191 2
    SAVESPTR(PL_curpad);
    SAVESPTR(PL_comppad);
d7210 1
a7210 1
    PL_subline = PL_curcop->cop_line;
d7212 1
a7212 1
    av_store(PL_comppad_name, 0, newSVpv("@@_", 2));
d7234 1
a7234 1
yywarn(char *s)
d7237 1
a7237 2
    --PL_error_count;
    PL_in_eval |= 2;
d7239 1
a7239 1
    PL_in_eval &= ~2;
d7244 1
a7244 1
yyerror(char *s)
d7270 4
d7275 1
d7285 1
a7285 1
	SV *where_sv = sv_2mortal(newSVpv("next char ", 0));
d7287 1
a7287 1
	    sv_catpvf(where_sv, "^%c", toCTRL(yychar));
d7289 1
a7289 1
	    sv_catpvf(where_sv, "%c", yychar);
d7291 1
a7291 1
	    sv_catpvf(where_sv, "\\%03o", yychar & 255);
d7295 2
a7296 2
    sv_catpvf(msg, " at %_ line %ld, ",
	      GvSV(PL_curcop->cop_filegv), (long)PL_curcop->cop_line);
d7298 1
a7298 1
	sv_catpvf(msg, "near \"%.*s\"\n", contlen, context);
d7300 5
a7304 5
	sv_catpvf(msg, "%s\n", where);
    if (PL_multi_start < PL_multi_end && (U32)(PL_curcop->cop_line - PL_multi_end) <= 1) {
	sv_catpvf(msg,
	"  (Might be a runaway multi-line %c%c string starting on line %ld)\n",
		(int)PL_multi_open,(int)PL_multi_close,(long)PL_multi_start);
d7307 2
a7308 4
    if (PL_in_eval & 2)
	warn("%_", msg);
    else if (PL_in_eval)
	sv_catsv(ERRSV, msg);
d7310 9
a7318 3
	PerlIO_write(PerlIO_stderr(), SvPVX(msg), SvCUR(msg));
    if (++PL_error_count >= 10)
	croak("%_ has too many errors.\n", GvSV(PL_curcop->cop_filegv));
d7325 20
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d17 1
d22 1
a22 1
static SV *q _((SV *sv));
d29 1
a29 1
static char *scan_pat _((char *start));
d53 7
a62 10
static char *linestart;		/* beg. of most recently read line */

static char pending_ident;	/* pending identifier lookup */

static struct {
    I32 super_state;	/* lexer state to save */
    I32 sub_inwhat;	/* "lex_inwhat" to use */
    OP *sub_op;		/* "lex_op" to use */
} sublex_info;

d103 1
a103 1
#define CLINE (copline = (curcop->cop_line < copline ? curcop->cop_line : copline))
d105 20
a124 20
#define TOKEN(retval) return (bufptr = s,(int)retval)
#define OPERATOR(retval) return (expect = XTERM,bufptr = s,(int)retval)
#define AOPERATOR(retval) return ao((expect = XTERM,bufptr = s,(int)retval))
#define PREBLOCK(retval) return (expect = XBLOCK,bufptr = s,(int)retval)
#define PRETERMBLOCK(retval) return (expect = XTERMBLOCK,bufptr = s,(int)retval)
#define PREREF(retval) return (expect = XREF,bufptr = s,(int)retval)
#define TERM(retval) return (CLINE, expect = XOPERATOR,bufptr = s,(int)retval)
#define LOOPX(f) return(yylval.ival=f,expect = XTERM,bufptr = s,(int)LOOPEX)
#define FTST(f) return(yylval.ival=f,expect = XTERM,bufptr = s,(int)UNIOP)
#define FUN0(f) return(yylval.ival = f,expect = XOPERATOR,bufptr = s,(int)FUNC0)
#define FUN1(f) return(yylval.ival = f,expect = XOPERATOR,bufptr = s,(int)FUNC1)
#define BOop(f) return ao((yylval.ival=f,expect = XTERM,bufptr = s,(int)BITOROP))
#define BAop(f) return ao((yylval.ival=f,expect = XTERM,bufptr = s,(int)BITANDOP))
#define SHop(f) return ao((yylval.ival=f,expect = XTERM,bufptr = s,(int)SHIFTOP))
#define PWop(f) return ao((yylval.ival=f,expect = XTERM,bufptr = s,(int)POWOP))
#define PMop(f) return(yylval.ival=f,expect = XTERM,bufptr = s,(int)MATCHOP)
#define Aop(f) return ao((yylval.ival=f,expect = XTERM,bufptr = s,(int)ADDOP))
#define Mop(f) return ao((yylval.ival=f,expect = XTERM,bufptr = s,(int)MULOP))
#define Eop(f) return(yylval.ival=f,expect = XTERM,bufptr = s,(int)EQOP)
#define Rop(f) return(yylval.ival=f,expect = XTERM,bufptr = s,(int)RELOP)
d130 4
a133 4
	expect = XTERM, \
	bufptr = s, \
	last_uni = oldbufptr, \
	last_lop_op = f, \
d137 2
a138 2
	bufptr = s, \
	last_uni = oldbufptr, \
d142 1
a142 1
#define OLDLOP(f) return(yylval.ival=f,expect = XTERM,bufptr = s,(int)LSTOP)
d144 2
a145 3
static int
ao(toketype)
int toketype;
d147 2
a148 2
    if (*bufptr == '=') {
	bufptr++;
d158 2
a159 4
static void
no_op(what, s)
char *what;
char *s;
d161 2
a162 2
    char *oldbp = bufptr;
    bool is_first = (oldbufptr == linestart);
d164 1
a164 1
    bufptr = s;
d168 1
a168 1
    else if (oldoldbufptr && isIDFIRST(*oldoldbufptr)) {
d170 2
a171 2
	for (t = oldoldbufptr; *t && (isALNUM(*t) || *t == ':'); t++) ;
	if (t < bufptr && isSPACE(*t))
d173 1
a173 1
		t - oldoldbufptr, oldoldbufptr);
d178 1
a178 1
    bufptr = oldbp;
d181 2
a182 3
static void
missingterm(s)
char *s;
d191 7
a197 1
    else if (multi_close < 32 || multi_close == 127) {
d199 1
a199 1
	tmpbuf[1] = toCTRL(multi_close);
d205 1
a205 1
	*tmpbuf = multi_close;
d214 1
a214 2
deprecate(s)
char *s;
d216 1
a216 1
    if (dowarn)
d220 2
a221 2
static void
depcom()
d226 13
d240 1
a240 2
lex_start(line)
SV *line;
d242 1
d246 45
a290 44
    SAVEI32(lex_dojoin);
    SAVEI32(lex_brackets);
    SAVEI32(lex_fakebrack);
    SAVEI32(lex_casemods);
    SAVEI32(lex_starts);
    SAVEI32(lex_state);
    SAVESPTR(lex_inpat);
    SAVEI32(lex_inwhat);
    SAVEI16(curcop->cop_line);
    SAVEPPTR(bufptr);
    SAVEPPTR(bufend);
    SAVEPPTR(oldbufptr);
    SAVEPPTR(oldoldbufptr);
    SAVEPPTR(linestart);
    SAVESPTR(linestr);
    SAVEPPTR(lex_brackstack);
    SAVEPPTR(lex_casestack);
    SAVEDESTRUCTOR(restore_rsfp, rsfp);

    lex_state = LEX_NORMAL;
    lex_defer = 0;
    expect = XSTATE;
    lex_brackets = 0;
    lex_fakebrack = 0;
    New(899, lex_brackstack, 120, char);
    New(899, lex_casestack, 12, char);
    SAVEFREEPV(lex_brackstack);
    SAVEFREEPV(lex_casestack);
    lex_casemods = 0;
    *lex_casestack = '\0';
    lex_dojoin = 0;
    lex_starts = 0;
    if (lex_stuff)
	SvREFCNT_dec(lex_stuff);
    lex_stuff = Nullsv;
    if (lex_repl)
	SvREFCNT_dec(lex_repl);
    lex_repl = Nullsv;
    lex_inpat = 0;
    lex_inwhat = 0;
    linestr = line;
    if (SvREADONLY(linestr))
	linestr = sv_2mortal(newSVsv(linestr));
    s = SvPV(linestr, len);
d292 10
a301 10
	if (!(SvFLAGS(linestr) & SVs_TEMP))
	    linestr = sv_2mortal(newSVsv(linestr));
	sv_catpvn(linestr, "\n;", 2);
    }
    SvTEMP_off(linestr);
    oldoldbufptr = oldbufptr = bufptr = linestart = SvPVX(linestr);
    bufend = bufptr + SvCUR(linestr);
    SvREFCNT_dec(rs);
    rs = newSVpv("\n", 1);
    rsfp = 0;
d305 1
a305 1
lex_end()
d307 1
a307 1
    doextract = FALSE;
d310 2
a311 3
static void
restore_rsfp(f)
void *f;
d315 19
a333 5
    if (rsfp == PerlIO_stdin())
	PerlIO_clearerr(rsfp);
    else if (rsfp && (rsfp != fp))
	PerlIO_close(rsfp);
    rsfp = fp;
d336 2
a337 3
static void
incline(s)
char *s;
d339 1
d345 1
a345 1
    curcop->cop_line++;
d370 1
a370 1
	curcop->cop_filegv = gv_fetchfile(s);
d372 1
a372 1
	curcop->cop_filegv = gv_fetchfile(origfilename);
d374 1
a374 1
    curcop->cop_line = atoi(n)-1;
d377 2
a378 3
static char *
skipspace(s)
register char *s;
d380 3
a382 2
    if (lex_formbrack && lex_brackets <= lex_formbrack) {
	while (s < bufend && (*s == ' ' || *s == '\t'))
d388 6
a393 4
	while (s < bufend && isSPACE(*s))
	    s++;
	if (s < bufend && *s == '#') {
	    while (s < bufend && *s != '\n')
d395 1
a395 1
	    if (s < bufend)
d397 5
d403 1
a403 1
	if (s < bufend || !rsfp || lex_state != LEX_NORMAL)
d405 3
a407 3
	if ((s = filter_gets(linestr, rsfp, (prevlen = SvCUR(linestr)))) == Nullch) {
	    if (minus_n || minus_p) {
		sv_setpv(linestr,minus_p ?
d410 2
a411 2
		sv_catpv(linestr,";}");
		minus_n = minus_p = 0;
d414 7
a420 7
		sv_setpv(linestr,";");
	    oldoldbufptr = oldbufptr = bufptr = s = linestart = SvPVX(linestr);
	    bufend = SvPVX(linestr) + SvCUR(linestr);
	    if (preprocess && !in_eval)
		(void)my_pclose(rsfp);
	    else if ((PerlIO*)rsfp == PerlIO_stdin())
		PerlIO_clearerr(rsfp);
d422 2
a423 4
		(void)PerlIO_close(rsfp);
	    if (e_fp == rsfp)
		e_fp = Nullfp;
	    rsfp = Nullfp;
d426 3
a428 3
	linestart = bufptr = s + prevlen;
	bufend = s + SvCUR(linestr);
	s = bufptr;
d430 1
a430 1
	if (PERLDB_LINE && curstash != debstash) {
d434 2
a435 2
	    sv_setpvn(sv,bufptr,bufend-bufptr);
	    av_store(GvAV(curcop->cop_filegv),(I32)curcop->cop_line,sv);
d440 2
a441 2
static void
check_uni() {
d446 1
a446 1
    if (oldoldbufptr != last_uni)
d448 4
a451 4
    while (isSPACE(*last_uni))
	last_uni++;
    for (s = last_uni; isALNUM(*s) || *s == '-'; s++) ;
    if ((t = strchr(s, '(')) && t < bufptr)
d455 1
a455 1
    warn("Warning: Use of \"%s\" without parens is ambiguous", last_uni);
d464 2
a465 4
static int
uni(f,s)
I32 f;
char *s;
d468 4
a471 4
    expect = XTERM;
    bufptr = s;
    last_uni = oldbufptr;
    last_lop_op = f;
d485 2
a486 10
static I32
lop
#ifdef CAN_PROTOTYPE
   (I32 f, expectation x, char *s)
#else
   (f,x,s)
I32 f;
expectation x;
char *s;
#endif /* CAN_PROTOTYPE */
d488 1
d491 5
a495 5
    expect = x;
    bufptr = s;
    last_lop = oldbufptr;
    last_lop_op = f;
    if (nexttoke)
d506 9
a514 10
static void 
force_next(type)
I32 type;
{
    nexttype[nexttoke] = type;
    nexttoke++;
    if (lex_state != LEX_KNOWNEXT) {
	lex_defer = lex_state;
	lex_expect = expect;
	lex_state = LEX_KNOWNEXT;
d518 2
a519 7
static char *
force_word(start,token,check_keyword,allow_pack,allow_tick)
register char *start;
int token;
int check_keyword;
int allow_pack;
int allow_tick;
d528 1
a528 1
	(allow_tick && *s == '\'') )
d530 2
a531 2
	s = scan_word(s, tokenbuf, sizeof tokenbuf, allow_pack, &len);
	if (check_keyword && keyword(tokenbuf, len))
d536 1
a536 1
		expect = XTERM;
d538 1
a538 1
		expect = XOPERATOR;
d543 2
a544 2
	nextval[nexttoke].opval = (OP*)newSVOP(OP_CONST,0, newSVpv(tokenbuf,0));
	nextval[nexttoke].opval->op_private |= OPpCONST_BARE;
d550 2
a551 4
static void
force_ident(s, kind)
register char *s;
int kind;
d554 2
a555 2
	OP* op = (OP*)newSVOP(OP_CONST, 0, newSVpv(s,0));
	nextval[nexttoke].opval = op;
d558 2
a559 1
	    op->op_private = OPpCONST_ENTERED;
d563 1
a563 1
	    gv_fetchpv(s, in_eval ? GV_ADDMULTI : TRUE,
d573 2
a574 3
static char *
force_version(s)
char *s;
d594 1
a594 1
    nextval[nexttoke].opval = version;
d600 2
a601 3
static SV *
q(sv)
SV *sv;
d606 2
a607 1
    STRLEN len;
d610 1
a610 1
	return sv;
d614 1
a614 1
	return sv;
d619 1
a619 1
	return sv;
d621 2
d632 3
a634 1

d638 2
a639 2
static I32
sublex_start()
d644 2
a645 2
	yylval.opval = lex_op;
	lex_op = Nullop;
d649 15
a663 6
	SV *sv = q(lex_stuff);
	STRLEN len;
	char *p = SvPV(sv, len);
	yylval.opval = (OP*)newSVOP(op_type, 0, newSVpv(p, len));
	SvREFCNT_dec(sv);
	lex_stuff = Nullsv;
d667 9
a675 9
    sublex_info.super_state = lex_state;
    sublex_info.sub_inwhat = op_type;
    sublex_info.sub_op = lex_op;
    lex_state = LEX_INTERPPUSH;

    expect = XTERM;
    if (lex_op) {
	yylval.opval = lex_op;
	lex_op = Nullop;
d682 2
a683 2
static I32
sublex_push()
d685 2
a686 1
    push_scope();
d688 41
a728 41
    lex_state = sublex_info.super_state;
    SAVEI32(lex_dojoin);
    SAVEI32(lex_brackets);
    SAVEI32(lex_fakebrack);
    SAVEI32(lex_casemods);
    SAVEI32(lex_starts);
    SAVEI32(lex_state);
    SAVESPTR(lex_inpat);
    SAVEI32(lex_inwhat);
    SAVEI16(curcop->cop_line);
    SAVEPPTR(bufptr);
    SAVEPPTR(oldbufptr);
    SAVEPPTR(oldoldbufptr);
    SAVEPPTR(linestart);
    SAVESPTR(linestr);
    SAVEPPTR(lex_brackstack);
    SAVEPPTR(lex_casestack);

    linestr = lex_stuff;
    lex_stuff = Nullsv;

    bufend = bufptr = oldbufptr = oldoldbufptr = linestart = SvPVX(linestr);
    bufend += SvCUR(linestr);
    SAVEFREESV(linestr);

    lex_dojoin = FALSE;
    lex_brackets = 0;
    lex_fakebrack = 0;
    New(899, lex_brackstack, 120, char);
    New(899, lex_casestack, 12, char);
    SAVEFREEPV(lex_brackstack);
    SAVEFREEPV(lex_casestack);
    lex_casemods = 0;
    *lex_casestack = '\0';
    lex_starts = 0;
    lex_state = LEX_INTERPCONCAT;
    curcop->cop_line = multi_start;

    lex_inwhat = sublex_info.sub_inwhat;
    if (lex_inwhat == OP_MATCH || lex_inwhat == OP_SUBST)
	lex_inpat = sublex_info.sub_op;
d730 1
a730 1
	lex_inpat = Nullop;
d735 2
a736 2
static I32
sublex_done()
d738 2
a739 2
    if (!lex_starts++) {
	expect = XOPERATOR;
d744 2
a745 2
    if (lex_casemods) {		/* oops, we've got some unbalanced parens */
	lex_state = LEX_INTERPCASEMOD;
d750 15
a764 15
    if (lex_repl && (lex_inwhat == OP_SUBST || lex_inwhat == OP_TRANS)) {
	linestr = lex_repl;
	lex_inpat = 0;
	bufend = bufptr = oldbufptr = oldoldbufptr = linestart = SvPVX(linestr);
	bufend += SvCUR(linestr);
	SAVEFREESV(linestr);
	lex_dojoin = FALSE;
	lex_brackets = 0;
	lex_fakebrack = 0;
	lex_casemods = 0;
	*lex_casestack = '\0';
	lex_starts = 0;
	if (SvCOMPILED(lex_repl)) {
	    lex_state = LEX_INTERPNORMAL;
	    lex_starts++;
d767 2
a768 2
	    lex_state = LEX_INTERPCONCAT;
	lex_repl = Nullsv;
d772 4
a775 4
	pop_scope();
	bufend = SvPVX(linestr);
	bufend += SvCUR(linestr);
	expect = XOPERATOR;
d780 88
a867 16
static char *
scan_const(start)
char *start;
{
    register char *send = bufend;
    SV *sv = NEWSV(93, send - start);
    register char *s = start;
    register char *d = SvPVX(sv);
    bool dorange = FALSE;
    I32 len;
    char *leave =
	lex_inpat
	    ? "\\.^$@@AGZdDwWsSbB+*?|()-nrtfeaxc0123456789[{]} \t\n\r\f\v#"
	    : (lex_inwhat & OP_TRANS)
		? ""
		: "";
d870 3
a872 1
	if (lex_inwhat == OP_TRANS) {
d874 31
a904 9
		I32 i;
		I32 max;
		i = d - SvPVX(sv);
		SvGROW(sv, SvLEN(sv) + 256);
		d = SvPVX(sv) + i;
		d -= 2;
		max = (U8)d[1];
		for (i = (U8)*d; i <= max; i++)
		    *d++ = i;
d908 2
d915 29
a943 3
	else if (*s == '(' && lex_inpat && s[1] == '?' && s[2] == '#') {
	    while (s < send && *s != ')')
		*d++ = *s++;
d945 4
a948 2
	else if (*s == '#' && lex_inpat &&
	  ((PMOP*)lex_inpat)->op_pmflags & PMf_EXTENDED) {
d952 2
d956 4
d961 1
a961 1
	    if (!lex_inpat)	/* not a regexp, so $ must be var */
d963 1
a963 1
	    if (s + 1 < send && !strchr(")| \n\t", s[1]))
d966 2
d970 3
a972 1
	    if (*s && strchr(leave, *s)) {
d977 3
a979 1
	    if (lex_inwhat == OP_SUBST && !lex_inpat &&
d982 1
a982 1
		if (dowarn)
d987 3
a989 1
	    if (lex_inwhat != OP_TRANS && *s && strchr("lLuUEQ", *s)) {
d993 2
d996 2
d999 1
a999 1
		if (lex_inwhat == OP_TRANS) {
d1004 1
d1008 2
d1015 2
d1021 2
d1025 6
d1033 1
d1035 2
d1058 2
a1059 1
	    }
d1062 2
a1063 1
	}
d1065 3
a1067 1
    }
d1072 1
d1077 11
a1087 1
    if (s > bufptr)
d1089 1
a1089 1
    else
d1095 2
a1096 3
static int
intuit_more(s)
register char *s;
d1098 1
a1098 1
    if (lex_brackets)
d1104 1
a1104 1
    if (!lex_inpat)
d1132 1
a1132 1
	unsigned char un_char = 0, last_un_char;
d1134 1
a1134 1
	char tmpbuf[sizeof tokenbuf * 4];
d1198 2
d1225 2
a1226 4
static int
intuit_method(start,gv)
char *start;
GV *gv;
d1229 1
a1229 1
    char tmpbuf[sizeof tokenbuf];
d1234 1
d1237 9
a1245 1
	if (!GvCVu(gv))
d1250 1
a1250 1
	if (gv || last_lop_op == OP_PRINT || isUPPER(*tokenbuf))
d1253 2
a1254 2
	bufptr = start;
	expect = XREF;
d1258 6
a1263 1
	indirgv = gv_fetchpv(tmpbuf,FALSE, SVt_PVCV);
d1269 1
a1269 1
	    if ((bufend - s) >= 2 && *s == '=' && *(s+1) == '>')
d1271 5
a1275 6
	    nextval[nexttoke].opval =
		(OP*)newSVOP(OP_CONST, 0,
			    newSVpv(tmpbuf,0));
	    nextval[nexttoke].opval->op_private =
		OPpCONST_BARE;
	    expect = XTERM;
d1277 1
a1277 1
	    bufptr = s;
d1284 2
a1285 2
static char*
incl_perldb()
d1287 2
a1288 2
    if (perldb) {
	char *pdb = getenv("PERL5DB");
d1292 1
d1314 1
d1316 1
d1319 1
a1319 3
filter_add(funcp, datasv)
    filter_t funcp;
    SV *datasv;
d1325 2
a1326 2
    if (!rsfp_filters)
	rsfp_filters = newAV();
d1328 1
a1328 1
	datasv = newSV(0);
d1332 6
a1337 4
    if (filter_debug)
	warn("filter_add func %p (%s)", funcp, SvPV(datasv,na));
    av_unshift(rsfp_filters, 1);
    av_store(rsfp_filters, 0, datasv) ;
d1344 1
a1344 2
filter_del(funcp)
    filter_t funcp;
d1348 1
a1348 1
    if (!rsfp_filters || AvFILL(rsfp_filters)<0)
d1351 2
a1352 3
    if (IoDIRP(FILTER_DATA(0)) == (void*)funcp){
	/* sv_free(av_pop(rsfp_filters)); */
	sv_free(av_shift(rsfp_filters));
d1363 4
a1366 4
filter_read(idx, buf_sv, maxlen)
    int idx;
    SV *buf_sv;
    int maxlen;		/* 0 = read one text line */
d1371 1
a1371 1
    if (!rsfp_filters)
d1373 1
a1373 1
    if (idx > AvFILL(rsfp_filters)){       /* Any more filters?	*/
d1385 2
a1386 2
	    if ((len = PerlIO_read(rsfp, SvPVX(buf_sv) + old_len, maxlen)) <= 0){
		if (PerlIO_error(rsfp))
d1394 2
a1395 2
            if (sv_gets(buf_sv, rsfp, SvCUR(buf_sv)) == NULL) {
		if (PerlIO_error(rsfp))
d1404 1
a1404 1
    if ( (datasv = FILTER_DATA(idx)) == &sv_undef){
d1411 2
a1412 1
    if (filter_debug)
d1414 2
a1415 1
		idx, funcp, SvPV(datasv,na));
d1419 1
a1419 1
    return (*funcp)(idx, buf_sv, maxlen);
d1422 2
a1423 5
static char *
filter_gets(sv,fp, append)
register SV *sv;
register PerlIO *fp;
STRLEN append;
d1425 6
a1430 1
    if (rsfp_filters) {
d1439 1
a1439 1
    else 
a1440 1
    
d1451 25
d1477 1
a1477 1
yylex()
d1479 1
d1484 18
a1502 7
    if (pending_ident) {
	char pit = pending_ident;
	pending_ident = 0;

	if (in_my) {
	    if (strchr(tokenbuf,':'))
		croak(no_myglob,tokenbuf);
d1504 1
a1504 1
	    yylval.opval->op_targ = pad_allocmy(tokenbuf);
d1508 18
a1525 5
	if (!strchr(tokenbuf,':') && (tmp = pad_findmy(tokenbuf))) {
	    if (last_lop_op == OP_SORT &&
		tokenbuf[0] == '$' &&
		(tokenbuf[1] == 'a' || tokenbuf[1] == 'b')
		&& !tokenbuf[2])
d1527 11
a1537 3
		for (d = in_eval ? oldoldbufptr : linestart;
		     d < bufend && *d != '\n';
		     d++)
d1539 8
a1546 3
		    if (strnEQ(d,"<=>",3) || strnEQ(d,"cmp",3)) {
			croak("Can't use \"my %s\" in sort comparison",
			      tokenbuf);
d1549 4
a1553 4

	    yylval.opval = newOP(OP_PADANY, 0);
	    yylval.opval->op_targ = tmp;
	    return PRIVATEREF;
d1556 8
a1563 4
	/* Force them to make up their mind on "@@foo". */
	if (pit == '@@' && lex_state != LEX_NORMAL && !lex_brackets) {
	    GV *gv = gv_fetchpv(tokenbuf+1, FALSE, SVt_PVAV);
	    if (!gv || ((tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
d1565 1
a1565 1
			     tokenbuf, tokenbuf));
d1568 2
a1569 1
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(tokenbuf+1, 0));
d1571 3
a1573 3
	gv_fetchpv(tokenbuf+1, in_eval ? GV_ADDMULTI : TRUE,
		   ((tokenbuf[0] == '$') ? SVt_PV
		    : (tokenbuf[0] == '@@') ? SVt_PVAV
d1578 3
a1580 1
    switch (lex_state) {
d1587 1
d1589 12
a1600 9
	nexttoke--;
	yylval = nextval[nexttoke];
	if (!nexttoke) {
	    lex_state = lex_defer;
	    expect = lex_expect;
	    lex_defer = LEX_NORMAL;
	}
	return(nexttype[nexttoke]);

d1603 1
a1603 1
	if (bufptr != bufend && *bufptr != '\\')
d1606 2
a1607 1
	if (bufptr == bufend || bufptr[1] == 'E') {
d1609 9
a1617 6
	    if (lex_casemods) {
		oldmod = lex_casestack[--lex_casemods];
		lex_casestack[lex_casemods] = '\0';
		if (bufptr != bufend && strchr("LUQ", oldmod)) {
		    bufptr += 2;
		    lex_state = LEX_INTERPCONCAT;
d1621 3
a1623 3
	    if (bufptr != bufend)
		bufptr += 2;
	    lex_state = LEX_INTERPCONCAT;
d1627 1
a1627 1
	    s = bufptr + 1;
d1631 1
a1631 1
		(strchr(lex_casestack, 'L') || strchr(lex_casestack, 'U')))
d1633 1
a1633 1
		lex_casestack[--lex_casemods] = '\0';
d1636 3
a1638 3
	    if (lex_casemods > 10) {
		char* newlb = Renew(lex_casestack, lex_casemods + 2, char);
		if (newlb != lex_casestack) {
d1640 1
a1640 1
		    lex_casestack = newlb;
d1643 4
a1646 4
	    lex_casestack[lex_casemods++] = *s;
	    lex_casestack[lex_casemods] = '\0';
	    lex_state = LEX_INTERPCONCAT;
	    nextval[nexttoke].ival = 0;
d1649 1
a1649 1
		nextval[nexttoke].ival = OP_LCFIRST;
d1651 1
a1651 1
		nextval[nexttoke].ival = OP_UCFIRST;
d1653 1
a1653 1
		nextval[nexttoke].ival = OP_LC;
d1655 1
a1655 1
		nextval[nexttoke].ival = OP_UC;
d1657 1
a1657 1
		nextval[nexttoke].ival = OP_QUOTEMETA;
d1660 1
a1660 1
	    bufptr = s + 1;
d1662 3
a1664 3
	    if (lex_starts) {
		s = bufptr;
		lex_starts = 0;
d1675 1
a1675 1
	if (bufptr == bufend)
d1677 5
a1681 5
	expect = XTERM;
	lex_dojoin = (*bufptr == '@@');
	lex_state = LEX_INTERPNORMAL;
	if (lex_dojoin) {
	    nextval[nexttoke].ival = 0;
d1683 5
d1689 2
a1690 1
	    nextval[nexttoke].ival = 0;
d1692 1
a1692 1
	    nextval[nexttoke].ival = 0;
d1694 1
a1694 1
	    nextval[nexttoke].ival = OP_JOIN;	/* emulate join($", ...) */
d1697 2
a1698 2
	if (lex_starts++) {
	    s = bufptr;
d1704 2
a1705 2
	if (intuit_more(bufptr)) {
	    lex_state = LEX_INTERPNORMAL;	/* false alarm, more expr */
d1711 3
a1713 3
	if (lex_dojoin) {
	    lex_dojoin = FALSE;
	    lex_state = LEX_INTERPCONCAT;
d1719 1
a1719 1
	if (lex_brackets)
d1722 1
a1722 1
	if (bufptr == bufend)
d1725 6
a1730 4
	if (SvIVX(linestr) == '\'') {
	    SV *sv = newSVsv(linestr);
	    if (!lex_inpat)
		sv = q(sv);
d1732 1
a1732 1
	    s = bufend;
d1735 1
a1735 1
	    s = scan_const(bufptr);
d1737 1
a1737 1
		lex_state = LEX_INTERPCASEMOD;
d1739 1
a1739 1
		lex_state = LEX_INTERPSTART;
d1742 3
a1744 3
	if (s != bufptr) {
	    nextval[nexttoke] = yylval;
	    expect = XTERM;
d1746 1
a1746 1
	    if (lex_starts++)
d1749 1
a1749 1
		bufptr = s;
d1756 3
a1758 3
	lex_state = LEX_NORMAL;
	s = scan_formline(bufptr);
	if (!lex_formbrack)
d1763 3
a1765 3
    s = bufptr;
    oldoldbufptr = oldbufptr;
    oldbufptr = s;
d1767 1
a1767 1
	PerlIO_printf(PerlIO_stderr(), "### Tokener expecting %s at %s\n", exp_name[expect], s);
d1778 4
a1781 4
	if (!rsfp) {
	    last_uni = 0;
	    last_lop = 0;
	    if (lex_brackets)
d1785 1
a1785 1
	if (s++ < bufend)
d1787 12
a1798 12
	last_uni = 0;
	last_lop = 0;
	if (!in_eval && !preambled) {
	    preambled = TRUE;
	    sv_setpv(linestr,incl_perldb());
	    if (SvCUR(linestr))
		sv_catpv(linestr,";");
	    if (preambleav){
		while(AvFILL(preambleav) >= 0) {
		    SV *tmpsv = av_shift(preambleav);
		    sv_catsv(linestr, tmpsv);
		    sv_catpv(linestr, ";");
d1801 2
a1802 2
		sv_free((SV*)preambleav);
		preambleav = NULL;
d1804 5
a1808 5
	    if (minus_n || minus_p) {
		sv_catpv(linestr, "LINE: while (<>) {");
		if (minus_l)
		    sv_catpv(linestr,"chomp;");
		if (minus_a) {
d1812 4
a1815 4
		    if (minus_F) {
			if (strchr("/'\"", *splitstr)
			      && strchr(splitstr + 1, *splitstr))
			    sv_catpvf(linestr, "@@F=split(%s);", splitstr);
d1819 1
a1819 1
			    while (s[1] && strchr(splitstr, *s))  s++;
d1821 1
a1821 1
			    sv_catpvf(linestr, "@@F=split(%s%c",
d1823 1
a1823 1
			    for (s = splitstr; *s; s++) {
d1825 2
a1826 2
				    sv_catpvn(linestr, "\\", 1);
				sv_catpvn(linestr, s, 1);
d1828 1
a1828 1
			    sv_catpvf(linestr, "%c);", delim);
d1832 1
a1832 1
		        sv_catpv(linestr,"@@F=split(' ');");
d1835 4
a1838 4
	    sv_catpv(linestr, "\n");
	    oldoldbufptr = oldbufptr = s = linestart = SvPVX(linestr);
	    bufend = SvPVX(linestr) + SvCUR(linestr);
	    if (PERLDB_LINE && curstash != debstash) {
d1842 2
a1843 2
		sv_setsv(sv,linestr);
		av_store(GvAV(curcop->cop_filegv),(I32)curcop->cop_line,sv);
d1848 1
a1848 1
	    if ((s = filter_gets(linestr, rsfp, 0)) == Nullch) {
d1850 5
a1854 5
		if (rsfp) {
		    if (preprocess && !in_eval)
			(void)my_pclose(rsfp);
		    else if ((PerlIO *)rsfp == PerlIO_stdin())
			PerlIO_clearerr(rsfp);
d1856 10
a1865 11
			(void)PerlIO_close(rsfp);
		    if (e_fp == rsfp)
			e_fp = Nullfp;
		    rsfp = Nullfp;
		}
		if (!in_eval && (minus_n || minus_p)) {
		    sv_setpv(linestr,minus_p ? ";}continue{print" : "");
		    sv_catpv(linestr,";}");
		    oldoldbufptr = oldbufptr = s = linestart = SvPVX(linestr);
		    bufend = SvPVX(linestr) + SvCUR(linestr);
		    minus_n = minus_p = 0;
d1868 2
a1869 2
		oldoldbufptr = oldbufptr = s = linestart = SvPVX(linestr);
		sv_setpv(linestr,"");
d1872 1
a1872 1
	    if (doextract) {
d1874 1
a1874 1
		    doextract = FALSE;
d1878 4
a1881 4
		    sv_setpv(linestr, "");
		    oldoldbufptr = oldbufptr = s = linestart = SvPVX(linestr);
		    bufend = SvPVX(linestr) + SvCUR(linestr);
		    doextract = FALSE;
d1885 3
a1887 3
	} while (doextract);
	oldoldbufptr = oldbufptr = bufptr = linestart = s;
	if (PERLDB_LINE && curstash != debstash) {
d1891 2
a1892 2
	    sv_setsv(sv,linestr);
	    av_store(GvAV(curcop->cop_filegv),(I32)curcop->cop_line,sv);
d1894 3
a1896 3
	bufend = SvPVX(linestr) + SvCUR(linestr);
	if (curcop->cop_line == 1) {
	    while (s < bufend && isSPACE(*s))
d1901 1
a1901 1
	    if (!in_eval) {
d1933 1
a1933 1
		    if (sv_eq(x, GvSV(curcop->cop_filegv))) {
d1970 1
a1970 1
		    !minus_c &&
d1972 1
a1972 1
		    instr(origargv[0],"perl"))
d1978 1
a1978 1
		    while (s < bufend && isSPACE(*s))
d1980 2
a1981 2
		    if (s < bufend) {
			Newz(899,newargv,origargc+3,char*);
d1983 1
a1983 1
			while (s < bufend && !isSPACE(*s))
d1986 1
a1986 1
			Copy(origargv+1, newargv+2, origargc+1, char*);
d1989 1
a1989 1
			newargv = origargv;
d1991 1
a1991 1
		    execv(ipath, newargv);
d1995 3
a1997 3
		    U32 oldpdb = perldb;
		    bool oldn = minus_n;
		    bool oldp = minus_p;
d2013 1
a2013 1
			    ( minus_n || minus_p ) && !(oldn || oldp) )
d2017 4
a2020 4
			    sv_setpv(linestr, "");
			    oldoldbufptr = oldbufptr = s = linestart = SvPVX(linestr);
			    bufend = SvPVX(linestr) + SvCUR(linestr);
			    preambled = FALSE;
d2022 1
a2022 1
				(void)gv_fetchfile(origfilename);
d2029 3
a2031 3
	if (lex_formbrack && lex_brackets <= lex_formbrack) {
	    bufptr = s;
	    lex_state = LEX_FORMLINE;
d2036 1
d2040 1
d2046 2
a2047 2
	if (lex_state != LEX_NORMAL || (in_eval && !rsfp)) {
	    d = bufend;
d2053 3
a2055 3
	    if (lex_formbrack && lex_brackets <= lex_formbrack) {
		bufptr = s;
		lex_state = LEX_FORMLINE;
d2061 1
a2061 1
	    bufend = s;
d2067 1
a2067 1
	    bufptr = s;
d2070 1
a2070 1
	    while (s < bufend && (*s == ' ' || *s == '\t'))
d2074 1
a2074 4
		if (dowarn)
		    warn("Ambiguous use of -%c => resolved to \"-%c\" =>",
			(int)tmp, (int)tmp);
		s = force_word(bufptr,WORD,FALSE,FALSE,FALSE);
d2077 2
a2078 2
	    last_uni = oldbufptr;
	    last_lop_op = OP_FTEREAD;	/* good enough */
d2115 1
a2115 1
	    if (expect == XOPERATOR)
d2132 1
a2132 1
	if (expect == XOPERATOR)
d2135 1
a2135 1
	    if (isSPACE(*s) || !isSPACE(*bufptr))
d2144 1
a2144 1
	    if (expect == XOPERATOR)
d2149 1
a2149 1
	if (expect == XOPERATOR)
d2152 1
a2152 1
	    if (isSPACE(*s) || !isSPACE(*bufptr))
d2158 5
a2162 5
	if (expect != XOPERATOR) {
	    s = scan_ident(s, bufend, tokenbuf, sizeof tokenbuf, TRUE);
	    expect = XOPERATOR;
	    force_ident(tokenbuf, '*');
	    if (!*tokenbuf)
d2174 1
a2174 1
	if (expect == XOPERATOR) {
d2178 4
a2181 4
	tokenbuf[0] = '%';
	s = scan_ident(s, bufend, tokenbuf + 1, sizeof tokenbuf - 1, TRUE);
	if (!tokenbuf[1]) {
	    if (s == bufend)
d2185 1
a2185 1
	pending_ident = '%';
d2192 1
a2192 1
	lex_brackets++;
d2207 2
a2208 2
	if (last_lop == oldoldbufptr || last_uni == oldoldbufptr)
	    oldbufptr = oldoldbufptr;		/* allow print(STDOUT 123) */
d2210 1
a2210 1
	    expect = XTERM;
d2213 2
a2214 2
	if (curcop->cop_line < copline)
	    copline = curcop->cop_line;
d2225 1
a2225 1
	if (lex_brackets <= 0)
d2228 3
a2230 3
	    --lex_brackets;
	if (lex_state == LEX_INTERPNORMAL) {
	    if (lex_brackets == 0) {
d2232 1
a2232 1
		    lex_state = LEX_INTERPEND;
d2239 3
a2241 3
	if (lex_brackets > 100) {
	    char* newlb = Renew(lex_brackstack, lex_brackets + 1, char);
	    if (newlb != lex_brackstack) {
d2243 1
a2243 1
		lex_brackstack = newlb;
d2246 1
a2246 1
	switch (expect) {
d2248 1
a2248 1
	    if (lex_formbrack) {
d2252 2
a2253 2
	    if (oldoldbufptr == last_lop)
		lex_brackstack[lex_brackets++] = XTERM;
d2255 1
a2255 1
		lex_brackstack[lex_brackets++] = XOPERATOR;
d2258 1
a2258 1
	    while (s < bufend && (*s == ' ' || *s == '\t'))
d2261 3
a2263 3
	    tokenbuf[0] = '\0';
	    if (d < bufend && *d == '-') {
		tokenbuf[0] = '-';
d2265 1
a2265 1
		while (d < bufend && (*d == ' ' || *d == '\t'))
d2268 2
a2269 2
	    if (d < bufend && isIDFIRST(*d)) {
		d = scan_word(d, tokenbuf + 1, sizeof tokenbuf - 1,
d2271 1
a2271 1
		while (d < bufend && (*d == ' ' || *d == '\t'))
d2274 1
a2274 7
		    char minus = (tokenbuf[0] == '-');
		    if (dowarn &&
			(keyword(tokenbuf + 1, len) ||
			 (minus && len == 1 && isALPHA(tokenbuf[1])) ||
			 perl_get_cv(tokenbuf + 1, FALSE) ))
			warn("Ambiguous use of {%s} resolved to {\"%s\"}",
			     tokenbuf + !minus, tokenbuf + !minus);
d2282 2
a2283 2
	    lex_brackstack[lex_brackets++] = XSTATE;
	    expect = XSTATE;
d2286 2
a2287 2
	    lex_brackstack[lex_brackets++] = XOPERATOR;
	    expect = XSTATE;
d2291 2
a2292 2
		if (oldoldbufptr == last_lop)
		    lex_brackstack[lex_brackets++] = XTERM;
d2294 1
a2294 1
		    lex_brackstack[lex_brackets++] = XOPERATOR;
d2316 1
a2316 1
		    for (t++; t < bufend && *t != *s;)
d2322 1
a2322 1
		    if (++t < bufend
d2324 1
a2324 1
			    || ((*t == 'q' || *t == 'x') && ++t < bufend
d2330 1
a2330 1
			while (t < bufend && isSPACE(*t))
d2338 2
a2339 2
			    for (t++; t < bufend; t++) {
				if (*t == '\\' && t+1 < bufend && open != '\\')
d2345 2
a2346 2
			    for (t++; t < bufend; t++) {
				if (*t == '\\' && t+1 < bufend)
d2357 1
a2357 1
		    for (t++; t < bufend && isALNUM(*t); t++) ;
d2359 1
a2359 1
		while (t < bufend && isSPACE(*t))
d2363 1
a2363 1
		if (t < bufend && ((*t == ',' && (*s == 'q' || !isLOWER(*s)))
d2366 2
a2367 2
		if (expect == XREF)
		    expect = XTERM;
d2369 2
a2370 2
		    lex_brackstack[lex_brackets-1] = XSTATE;
		    expect = XSTATE;
d2375 1
a2375 1
	yylval.ival = curcop->cop_line;
d2377 1
a2377 1
	    copline = NOLINE;   /* invalidate current command line number */
d2382 1
a2382 1
	if (lex_brackets <= 0)
d2385 8
a2392 8
	    expect = (expectation)lex_brackstack[--lex_brackets];
	if (lex_brackets < lex_formbrack)
	    lex_formbrack = 0;
	if (lex_state == LEX_INTERPNORMAL) {
	    if (lex_brackets == 0) {
		if (lex_fakebrack) {
		    lex_state = LEX_INTERPEND;
		    bufptr = s;
d2396 1
a2396 1
		    lex_state = LEX_INTERPENDMAYBE;
d2398 1
a2398 1
		    lex_state = LEX_INTERPEND;
d2401 3
a2403 3
	if (lex_brackets < lex_fakebrack) {
	    bufptr = s;
	    lex_fakebrack = 0;
d2414 3
a2416 3
	if (expect == XOPERATOR) {
	    if (dowarn && isALPHA(*s) && bufptr == linestart) {
		curcop->cop_line--;
d2418 1
a2418 1
		curcop->cop_line++;
d2423 4
a2426 4
	s = scan_ident(s - 1, bufend, tokenbuf, sizeof tokenbuf, TRUE);
	if (*tokenbuf) {
	    expect = XOPERATOR;
	    force_ident(tokenbuf, '&');
d2449 1
a2449 1
	if (dowarn && tmp && isSPACE(*s) && strchr("+-*/%.^&|<",tmp))
d2452 2
a2453 2
	if (expect == XSTATE && isALPHA(tmp) &&
		(s == linestart+1 || s[-2] == '\n') )
d2455 2
a2456 2
	    if (in_eval && !rsfp) {
		d = bufend;
d2473 2
a2474 2
	    s = bufend;
	    doextract = TRUE;
d2477 1
a2477 1
	if (lex_brackets < lex_formbrack) {
d2479 1
d2481 3
d2486 1
a2486 1
		expect = XBLOCK;
d2502 1
a2502 1
	if (expect != XOPERATOR) {
d2537 3
a2539 3
	if (expect == XOPERATOR) {
	    if (lex_formbrack && lex_brackets == lex_formbrack) {
		expect = XTERM;
d2546 4
a2549 4
	    if (expect == XOPERATOR)
		no_op("Array length", bufptr);
	    tokenbuf[0] = '@@';
	    s = scan_ident(s + 1, bufend, tokenbuf + 1, sizeof tokenbuf - 1,
d2551 1
a2551 1
	    if (!tokenbuf[1])
d2553 2
a2554 2
	    expect = XOPERATOR;
	    pending_ident = '#';
d2558 6
a2563 6
	if (expect == XOPERATOR)
	    no_op("Scalar", bufptr);
	tokenbuf[0] = '$';
	s = scan_ident(s, bufend, tokenbuf + 1, sizeof tokenbuf - 1, FALSE);
	if (!tokenbuf[1]) {
	    if (s == bufend)
d2569 1
a2569 1
	if (tokenbuf[1] == '[' && !tokenbuf[2]) {
d2571 1
a2571 1
				   newSViv((IV)compiling.cop_arybase));
d2577 1
a2577 1
	if (lex_state == LEX_NORMAL)
d2580 1
a2580 1
	if ((expect != XREF || oldoldbufptr == last_lop) && intuit_more(s)) {
d2583 2
a2584 2
		tokenbuf[0] = '@@';
		if (dowarn) {
d2589 2
a2590 2
			bufptr = skipspace(bufptr);
			while (t < bufend && *t != ']')
d2593 1
a2593 1
			     (t - bufptr) + 1, bufptr);
d2598 2
a2599 2
		tokenbuf[0] = '%';
		if (dowarn && strEQ(tokenbuf+1, "SIG") &&
d2602 1
a2602 1
		    char tmpbuf[sizeof tokenbuf];
d2607 2
a2608 1
			if (*t != '(' && perl_get_cv(tmpbuf, FALSE))
d2615 5
a2619 5
	expect = XOPERATOR;
	if (lex_state == LEX_NORMAL && isSPACE(*d)) {
	    bool islop = (last_lop == oldoldbufptr);
	    if (!islop || last_lop_op == OP_GREPSTART)
		expect = XOPERATOR;
d2621 1
a2621 1
		expect = XTERM;		/* e.g. print $fh "foo" */
d2623 1
a2623 1
		expect = XTERM;		/* e.g. print $fh &sub */
d2625 1
a2625 1
		char tmpbuf[sizeof tokenbuf];
d2640 1
a2640 1
			expect = XTERM;	/* e.g. print $fh length() */
d2647 1
a2647 1
			expect = XTERM;	/* e.g. print $fh subr() */
d2651 1
a2651 1
		expect = XTERM;		/* e.g. print $fh 3 */
d2653 5
a2657 5
		expect = XTERM;		/* e.g. print $fh .3 */
	    else if (strchr("/?-+", *s) && !isSPACE(s[1]))
		expect = XTERM;		/* e.g. print $fh -1 */
	    else if (*s == '<' && s[1] == '<' && !isSPACE(s[2]))
		expect = XTERM;		/* print $fh <<"EOF" */
d2659 1
a2659 1
	pending_ident = '$';
d2663 1
a2663 1
	if (expect == XOPERATOR)
d2665 4
a2668 4
	tokenbuf[0] = '@@';
	s = scan_ident(s, bufend, tokenbuf + 1, sizeof tokenbuf - 1, FALSE);
	if (!tokenbuf[1]) {
	    if (s == bufend)
d2672 1
a2672 1
	if (lex_state == LEX_NORMAL)
d2674 1
a2674 1
	if ((expect != XREF || oldoldbufptr == last_lop) && intuit_more(s)) {
d2676 1
a2676 1
		tokenbuf[0] = '%';
d2679 1
a2679 1
	    if (dowarn) {
d2686 1
a2686 1
			bufptr = skipspace(bufptr);
d2688 1
a2688 1
			    t-bufptr, bufptr, t-bufptr-1, bufptr+1);
d2693 1
a2693 1
	pending_ident = '@@';
d2698 7
a2704 3
	if (expect != XOPERATOR) {
	    check_uni();
	    s = scan_pat(s);
d2713 10
a2722 4
	if (lex_formbrack && lex_brackets == lex_formbrack && s[1] == '\n' &&
		(s == linestart || s[-1] == '\n') ) {
	    lex_formbrack = 0;
	    expect = XSTATE;
d2725 1
a2725 1
	if (expect == XOPERATOR || !isDIGIT(s[1])) {
d2737 1
a2737 1
	    if (expect != XOPERATOR)
d2745 1
a2745 1
	if (expect == XOPERATOR)
d2751 3
a2753 3
	if (expect == XOPERATOR) {
	    if (lex_formbrack && lex_brackets == lex_formbrack) {
		expect = XTERM;
d2767 3
a2769 3
	if (expect == XOPERATOR) {
	    if (lex_formbrack && lex_brackets == lex_formbrack) {
		expect = XTERM;
d2779 1
a2779 1
	for (d = SvPV(lex_stuff, len); len; len--, d++) {
d2789 1
a2789 1
	if (expect == XOPERATOR)
d2799 1
a2799 1
	if (dowarn && lex_inwhat && isDIGIT(*s))
d2801 1
a2801 1
	if (expect == XOPERATOR)
d2806 1
a2806 1
	if (isDIGIT(s[1]) && expect == XOPERATOR) {
d2840 7
a2846 3
      keylookup:
	bufptr = s;
	s = scan_word(s, tokenbuf, sizeof tokenbuf, FALSE, &len);
d2849 4
a2852 4
	tmp = (len == 1 && strchr("msyq", tokenbuf[0]) ||
	       len == 2 && ((tokenbuf[0] == 't' && tokenbuf[1] == 'r') ||
			    (tokenbuf[0] == 'q' &&
			     strchr("qwx", tokenbuf[1]))));
d2855 1
a2855 1
	if (!tmp && *s == ':' && s[1] == ':' && strNE(tokenbuf, "CORE"))
d2859 1
a2859 1
	while (d < bufend && isSPACE(*d))
d2863 2
a2864 2
	if (!tmp && expect == XSTATE
	      && d < bufend && *d == ':' && *(d + 1) != ':') {
d2866 1
a2866 1
	    yylval.pval = savepv(tokenbuf);
d2872 1
a2872 1
	tmp = keyword(tokenbuf, len);
d2877 1
a2877 4
	    if (dowarn && (tmp || perl_get_cv(tokenbuf, FALSE)))
		warn("Ambiguous use of %s => resolved to \"%s\" =>",
			tokenbuf, tokenbuf);
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(tokenbuf,0));
d2883 26
a2908 5
	    GV* gv;
	    if (expect != XOPERATOR &&
		(*s != ':' || s[1] != ':') &&
		(gv = gv_fetchpv(tokenbuf, FALSE, SVt_PVCV)) &&
		GvIMPORTED_CV(gv))
d2910 1
a2910 1
		tmp = 0;
d2912 1
a2912 1
	    else
d2914 7
a2927 1
		GV *gv;
d2929 1
a2929 1
		char lastchar = (bufptr == oldoldbufptr ? 0 : bufptr[-1]);
d2934 7
a2940 4
		    s = scan_word(s, tokenbuf + len, sizeof tokenbuf - len,
				  TRUE, &len);
		    if (!len)
			croak("Bad name after %s::", tokenbuf);
d2943 3
a2945 3
		if (expect == XOPERATOR) {
		    if (bufptr == linestart) {
			curcop->cop_line--;
d2947 1
a2947 1
			curcop->cop_line++;
d2953 3
a2955 1
		/* Look for a subroutine with this name in current package. */
d2957 25
a2981 1
		gv = gv_fetchpv(tokenbuf,FALSE, SVt_PVCV);
d2986 1
a2986 1
		yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(tokenbuf,0));
d2989 5
d2996 3
a2998 3
		if (oldoldbufptr &&
		    oldoldbufptr < bufptr &&
		    (oldoldbufptr == last_lop || oldoldbufptr == last_uni) &&
d3000 5
a3004 2
		    (expect == XREF ||
		     (opargs[last_lop_op] >> OASHIFT & 7) == OA_FILEREF) )
d3019 1
a3019 1
		    if ((last_lop_op == OP_SORT ||
d3021 2
a3022 2
                        (last_lop_op != OP_MAPSTART && last_lop_op != OP_GREPSTART)){
			expect = (last_lop == oldoldbufptr) ? XTERM : XOPERATOR;
d3029 1
a3029 1
		expect = XOPERATOR;
d3034 3
d3038 1
a3038 1
			if (*d == ')' && (sv = cv_const_sv(GvCV(gv)))) {
d3043 2
a3044 2
		    nextval[nexttoke].opval = yylval.opval;
		    expect = XOPERATOR;
d3047 1
d3054 2
a3055 2
		    last_lop = oldbufptr;
		    last_lop_op = OP_METHOD;
d3070 3
a3072 3
				tokenbuf, tokenbuf);
		    last_lop = oldbufptr;
		    last_lop_op = OP_ENTERSUB;
d3086 1
d3090 1
a3090 1
			char *proto = SvPV((SV*)cv, len);
d3093 1
a3093 1
			if (strEQ(proto, "$"))
d3095 2
a3096 2
			if (*proto == '&' && *s == '{') {
			    sv_setpv(subname,"__ANON__");
d3099 4
a3102 3
		    }
		    nextval[nexttoke].opval = yylval.opval;
		    expect = XTERM;
d3107 1
a3107 1
		if (hints & HINT_STRICT_SUBS &&
d3110 7
a3116 4
		    last_lop_op != OP_TRUNCATE &&  /* S/F prototype in opcode.pl */
		    last_lop_op != OP_ACCEPT &&
		    last_lop_op != OP_PIPE_OP &&
		    last_lop_op != OP_SOCKPAIR)
d3120 2
a3121 2
			tokenbuf);
		    ++error_count;
d3127 1
a3127 1
		if (dowarn) {
d3129 1
a3129 1
			for (d = tokenbuf; *d && isLOWER(*d); d++) ;
d3131 1
a3131 1
			    warn(warn_reserved, tokenbuf);
d3134 2
d3138 1
a3138 1
			lastchar, tokenbuf);
d3147 1
a3147 1
					newSVsv(GvSV(curcop->cop_filegv)));
d3152 1
a3152 1
				    newSVpvf("%ld", (long)curcop->cop_line));
d3157 3
a3159 3
					(curstash
					 ? newSVsv(curstname)
					 : &sv_undef));
d3167 1
a3167 1
	    if (rsfp && (!in_eval || tokenbuf[2] == 'D')) {
d3169 2
a3170 2
		if (tokenbuf[2] == 'D')
		    pname = HvNAME(curstash ? curstash : defstash);
d3175 1
a3175 1
		IoIFP(GvIOp(gv)) = rsfp;
d3178 1
a3178 1
		    int fd = PerlIO_fileno(rsfp);
d3184 1
a3184 1
		if (preprocess)
d3186 1
a3186 1
		else if ((PerlIO*)rsfp == PerlIO_stdin())
d3190 1
a3190 1
		rsfp = Nullfp;
d3199 3
a3201 2
	    if (expect == XSTATE) {
		s = bufptr;
d3210 2
a3211 2
		s = scan_word(s, tokenbuf, sizeof tokenbuf, FALSE, &len);
		tmp = keyword(tokenbuf, len);
d3266 1
a3266 1
	    if (!cryptseen++)
d3272 2
a3273 2
	    if (dowarn) {
		for (d = s; d < bufend && (isSPACE(*d) || *d == '('); d++) ;
d3303 1
a3303 1
	    hints |= HINT_BLOCK_SCOPE;
d3327 1
a3327 1
	    yylval.ival = curcop->cop_line;
d3341 1
a3341 1
	    expect = (*s == '{') ? XTERMBLOCK : XTERM;
d3377 1
a3377 1
	    yylval.ival = curcop->cop_line;
d3379 1
a3379 1
	    if (isIDFIRST(*s)) {
d3381 1
a3381 1
		if ((bufend - p) >= 3 &&
d3507 1
a3507 1
	    yylval.ival = curcop->cop_line;
d3562 3
d3569 1
a3569 1
	    s = scan_pat(s);
d3591 12
a3602 1
	    in_my = TRUE;
d3613 1
a3613 1
	    if (expect != XSTATE)
d3649 1
a3649 1
	    checkcomma(s,tokenbuf,"filehandle");
d3653 1
a3653 1
	    checkcomma(s,tokenbuf,"filehandle");
d3692 2
a3693 2
	    if (dowarn && SvLEN(lex_stuff)) {
		d = SvPV_force(lex_stuff, len);
d3706 2
a3707 2
	    nextval[nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, q(lex_stuff));
	    lex_stuff = Nullsv;
d3710 1
a3710 1
	    nextval[nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(" ",1));
d3715 4
a3718 4
	    expect = XTERM;
	    bufptr = s;
	    last_lop = oldbufptr;
	    last_lop_op = OP_SPLIT;
d3726 6
a3731 2
	    if (SvIVX(lex_stuff) == '\'')
		SvIVX(lex_stuff) = 0;	/* qq'$foo' should intepolate */
d3746 1
a3746 1
	    *tokenbuf = '\0';
d3748 2
a3749 2
	    if (isIDFIRST(*tokenbuf))
		gv_stashpvn(tokenbuf, strlen(tokenbuf), TRUE);
d3894 1
a3894 1
	    checkcomma(s,tokenbuf,"subroutine name");
d3898 2
a3899 2
	    expect = XTERM;
	    s = force_word(s,WORD,TRUE,TRUE,TRUE);
d3921 1
a3921 1
	    sawstudy++;
d3933 2
a3934 2
		char tmpbuf[sizeof tokenbuf];
		expect = XBLOCK;
d3937 1
a3937 1
		    sv_setpv(subname, tmpbuf);
d3939 3
a3941 3
		    sv_setsv(subname,curstname);
		    sv_catpvn(subname,"::",2);
		    sv_catpvn(subname,tmpbuf,len);
d3947 2
a3948 2
		expect = XTERMBLOCK;
		sv_setpv(subname,"?");
d3954 1
a3954 1
		    lex_formbrack = lex_brackets + 1;
d3964 3
a3966 3
		    if (lex_stuff)
			SvREFCNT_dec(lex_stuff);
		    lex_stuff = Nullsv;
d3970 1
a3970 1
		d = SvPVX(lex_stuff);
d3977 1
a3977 1
		SvCUR(lex_stuff) = tmp;
d3979 9
a3987 9
		nexttoke++;
		nextval[1] = nextval[0];
		nexttype[1] = nexttype[0];
		nextval[0].opval = (OP*)newSVOP(OP_CONST, 0, lex_stuff);
		nexttype[0] = THING;
		if (nexttoke == 1) {
		    lex_defer = lex_state;
		    lex_expect = expect;
		    lex_state = LEX_KNOWNEXT;
d3989 1
a3989 1
		lex_stuff = Nullsv;
d3992 2
a3993 2
	    if (*SvPV(subname,na) == '?') {
		sv_setpv(subname,"__ANON__");
d4055 1
a4055 1
	    yylval.ival = curcop->cop_line;
d4059 1
a4059 1
	    yylval.ival = curcop->cop_line;
d4075 2
a4076 2
	    if (dowarn) {
		for (d = s; d < bufend && (isSPACE(*d) || *d == '('); d++) ;
d4086 1
a4086 1
	    if (expect != XSTATE)
d4092 1
a4092 1
		    nextval[nexttoke].opval = Nullop;
d4107 1
a4107 1
	    sawvec = TRUE;
d4111 1
a4111 1
	    yylval.ival = curcop->cop_line;
d4115 1
a4115 1
	    hints |= HINT_BLOCK_SCOPE;
d4128 11
a4138 1
	    gv_fetchpv("\f",TRUE, SVt_PV);	/* Make sure $^L is defined */
d4142 1
a4142 1
	    if (expect == XOPERATOR)
d4155 1
a4155 1
    }
d4159 1
a4159 3
keyword(d, len)
register char *d;
I32 len;
d4403 3
d4448 1
d4503 2
d4541 1
d4777 2
a4778 5
static void
checkcomma(s,name,what)
register char *s;
char *name;
char *what;
d4782 1
a4782 1
    if (dowarn && *s == ' ' && s[1] == '(') {	/* XXX gotta be a better way */
d4795 1
a4795 1
    while (s < bufend && isSPACE(*s))
d4799 1
a4799 1
    while (s < bufend && isSPACE(*s))
d4805 1
a4805 1
	while (s < bufend && isSPACE(*s))
d4819 71
a4889 7
static char *
scan_word(s, dest, destlen, allow_package, slp)
register char *s;
char *dest;
STRLEN destlen;
int allow_package;
STRLEN *slp;
d4903 1
a4903 1
	else if (*s == ':' && s[1] == ':' && allow_package && isIDFIRST(s[2])) {
d4915 2
a4916 7
static char *
scan_ident(s, send, dest, destlen, ck_uni)
register char *s;
register char *send;
char *dest;
STRLEN destlen;
I32 ck_uni;
d4923 2
a4924 2
    if (lex_brackets == 0)
	lex_fakebrack = 0;
d4958 2
a4959 2
	if (lex_state != LEX_NORMAL)
	    lex_state = LEX_INTERPENDMAYBE;
d4965 1
a4965 1
	if (isDIGIT(s[1]) && lex_state == LEX_INTERPNORMAL)
d5000 1
a5000 1
		if (dowarn && keyword(dest, d - dest)) {
d5005 1
a5005 1
		lex_fakebrack = lex_brackets+1;
d5007 1
a5007 1
		lex_brackstack[lex_brackets++] = XOPERATOR;
d5013 2
a5014 2
	    if (lex_state == LEX_INTERPNORMAL && !lex_brackets)
		lex_state = LEX_INTERPEND;
d5017 1
a5017 1
	    if (dowarn && lex_state == LEX_NORMAL &&
d5027 2
a5028 2
    else if (lex_state == LEX_INTERPNORMAL && !lex_brackets && !intuit_more(s))
	lex_state = LEX_INTERPEND;
d5032 1
a5032 3
void pmflag(pmfl,ch)
U16* pmfl;
int ch;
d5050 2
a5051 3
static char *
scan_pat(start)
char *start;
d5058 3
a5060 3
	if (lex_stuff)
	    SvREFCNT_dec(lex_stuff);
	lex_stuff = Nullsv;
d5064 2
a5065 2
    pm = (PMOP*)newPMOP(OP_MATCH, 0);
    if (multi_open == '?')
d5067 8
a5074 2
    while (*s && strchr("iogcmsx", *s))
	pmflag(&pm->op_pmflags,*s++);
d5077 1
a5077 1
    lex_op = (OP*)pm;
d5082 2
a5083 3
static char *
scan_subst(start)
char *start;
d5095 3
a5097 3
	if (lex_stuff)
	    SvREFCNT_dec(lex_stuff);
	lex_stuff = Nullsv;
d5101 1
a5101 1
    if (s[-1] == multi_open)
d5104 1
a5104 1
    first_start = multi_start;
d5107 6
a5112 6
	if (lex_stuff)
	    SvREFCNT_dec(lex_stuff);
	lex_stuff = Nullsv;
	if (lex_repl)
	    SvREFCNT_dec(lex_repl);
	lex_repl = Nullsv;
d5115 1
a5115 1
    multi_start = first_start;	/* so whole substitution is taken together */
d5118 1
a5118 1
    while (*s && strchr("iogcmsex", *s)) {
d5123 2
d5126 1
a5126 1
	    pmflag(&pm->op_pmflags,*s++);
d5131 3
d5139 1
a5139 1
	sv_catsv(repl, lex_repl);
d5142 2
a5143 2
	SvREFCNT_dec(lex_repl);
	lex_repl = repl;
d5147 1
a5147 1
    lex_op = (OP*)pm;
d5152 2
a5153 43
void
hoistmust(pm)
register PMOP *pm;
{
    if (!pm->op_pmshort && pm->op_pmregexp->regstart &&
	(!pm->op_pmregexp->regmust || pm->op_pmregexp->reganch & ROPT_ANCH)
       ) {
	if (!(pm->op_pmregexp->reganch & ROPT_ANCH))
	    pm->op_pmflags |= PMf_SCANFIRST;
	pm->op_pmshort = SvREFCNT_inc(pm->op_pmregexp->regstart);
	pm->op_pmslen = SvCUR(pm->op_pmshort);
    }
    else if (pm->op_pmregexp->regmust) {/* is there a better short-circuit? */
	if (pm->op_pmshort &&
	  sv_eq(pm->op_pmshort,pm->op_pmregexp->regmust))
	{
	    if (pm->op_pmflags & PMf_SCANFIRST) {
		SvREFCNT_dec(pm->op_pmshort);
		pm->op_pmshort = Nullsv;
	    }
	    else {
		SvREFCNT_dec(pm->op_pmregexp->regmust);
		pm->op_pmregexp->regmust = Nullsv;
		return;
	    }
	}
	/* promote the better string */
	if ((!pm->op_pmshort &&
	     !(pm->op_pmregexp->reganch & ROPT_ANCH_GPOS)) ||
	    ((pm->op_pmflags & PMf_SCANFIRST) &&
	     (SvCUR(pm->op_pmshort) < SvCUR(pm->op_pmregexp->regmust)))) {
	    SvREFCNT_dec(pm->op_pmshort);		/* ok if null */
	    pm->op_pmshort = pm->op_pmregexp->regmust;
	    pm->op_pmslen = SvCUR(pm->op_pmshort);
	    pm->op_pmregexp->regmust = Nullsv;
	    pm->op_pmflags |= PMf_SCANFIRST;
	}
    }
}

static char *
scan_trans(start)
char *start;
d5156 1
a5156 1
    OP *op;
d5159 1
a5159 1
    I32 delete;
d5166 4
a5169 4
	if (lex_stuff)
	    SvREFCNT_dec(lex_stuff);
	lex_stuff = Nullsv;
	croak("Translation pattern not terminated");
d5171 1
a5171 1
    if (s[-1] == multi_open)
d5176 7
a5182 7
	if (lex_stuff)
	    SvREFCNT_dec(lex_stuff);
	lex_stuff = Nullsv;
	if (lex_repl)
	    SvREFCNT_dec(lex_repl);
	lex_repl = Nullsv;
	croak("Translation replacement not terminated");
d5186 1
a5186 1
    op = newPVOP(OP_TRANS, 0, (char*)tbl);
d5188 1
a5188 1
    complement = delete = squash = 0;
d5193 1
a5193 1
	    delete = OPpTRANS_DELETE;
d5198 1
a5198 1
    op->op_private = delete|squash|complement;
d5200 1
a5200 1
    lex_op = op;
d5205 2
a5206 3
static char *
scan_heredoc(s)
register char *s;
d5208 1
d5217 1
a5217 1
    int outer = (rsfp && !lex_inwhat);
d5220 2
a5221 2
    d = tokenbuf;
    e = tokenbuf + sizeof tokenbuf - 1;
d5228 1
a5228 1
	s = delimcpy(d, e, s, bufend, term, &len);
d5230 1
a5230 1
	if (s < bufend)
d5245 1
a5245 1
    if (d >= tokenbuf + sizeof tokenbuf - 1)
d5249 25
a5273 1
    len = d - tokenbuf;
d5275 2
a5276 2
    if (outer || !(d=ninstr(s,bufend,d,d+1)))
	herewas = newSVpv(s,bufend-s);
d5281 1
a5281 1
    tmpstr = NEWSV(87,80);
d5293 10
a5302 4
    multi_start = curcop->cop_line;
    multi_open = multi_close = '<';
    term = *tokenbuf;
    if (!outer) {
d5305 1
a5305 1
	  (*s != term || memNE(s,tokenbuf,len)) ) {
d5307 1
a5307 1
		curcop->cop_line++;
d5310 2
a5311 2
	    curcop->cop_line = multi_start;
	    missingterm(tokenbuf);
d5313 1
d5317 24
a5340 3
	sv_setsv(linestr,herewas);
	oldoldbufptr = oldbufptr = bufptr = s = linestart = SvPVX(linestr);
	bufend = SvPVX(linestr) + SvCUR(linestr);
d5344 1
a5344 1
    while (s >= bufend) {	/* multiple line string? */
d5346 17
a5362 3
	 !(oldoldbufptr = oldbufptr = s = linestart = filter_gets(linestr, rsfp, 0))) {
	    curcop->cop_line = multi_start;
	    missingterm(tokenbuf);
d5364 4
a5367 2
	curcop->cop_line++;
	if (PERLDB_LINE && curstash != debstash) {
d5371 6
a5376 7
	    sv_setsv(sv,linestr);
	    av_store(GvAV(curcop->cop_filegv),
	      (I32)curcop->cop_line,sv);
	}
	bufend = SvPVX(linestr) + SvCUR(linestr);
	if (*s == term && memEQ(s,tokenbuf,len)) {
	    s = bufend - 1;
d5378 2
a5379 2
	    sv_catsv(linestr,herewas);
	    bufend = SvPVX(linestr) + SvCUR(linestr);
d5382 2
a5383 2
	    s = bufend;
	    sv_catsv(tmpstr,linestr);
a5385 1
    multi_end = curcop->cop_line;
d5387 2
d5394 1
a5394 1
    lex_stuff = tmpstr;
d5399 18
a5416 3
static char *
scan_inputsymbol(start)
char *start;
d5418 1
a5418 1
    register char *s = start;
d5423 9
a5431 4
    d = tokenbuf;
    e = tokenbuf + sizeof tokenbuf;
    s = delimcpy(d, e, s + 1, bufend, '>', &len);
    if (len >= sizeof tokenbuf)
d5433 1
a5433 1
    if (s >= bufend)
d5435 1
d5437 8
d5446 2
d5450 8
a5457 1
    if (d - tokenbuf != len) {
d5462 1
a5462 1
	    croak("Glob not terminated");
d5466 4
a5469 1
	d = tokenbuf;
d5472 4
d5478 8
a5485 4
	    if (tmp = pad_findmy(d)) {
		OP *op = newOP(OP_PADSV, 0);
		op->op_targ = tmp;
		lex_op = (OP*)newUNOP(OP_READLINE, 0, newUNOP(OP_RV2GV, 0, op));
d5489 1
a5489 1
		lex_op = (OP*)newUNOP(OP_READLINE, 0,
d5494 1
d5497 3
d5502 1
a5502 1
	    lex_op = (OP*)newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, gv));
d5506 1
a5509 10
static char *
scan_str(start)
char *start;
{
    SV *sv;
    char *tmps;
    register char *s = start;
    register char term;
    register char *to;
    I32 brackets = 1;
d5511 52
d5565 2
d5568 2
d5571 5
a5575 2
    multi_start = curcop->cop_line;
    multi_open = term;
d5578 1
a5578 1
    multi_close = term;
d5580 3
a5582 1
    sv = NEWSV(87,80);
d5586 2
d5590 3
a5592 1
	SvGROW(sv, SvCUR(sv) + (bufend - s) + 1);
d5594 9
a5602 5
	if (multi_open == multi_close) {
	    for (; s < bufend; s++,to++) {
		if (*s == '\n' && !rsfp)
		    curcop->cop_line++;
		if (*s == '\\' && s+1 < bufend && term != '\\') {
d5605 1
d5609 2
d5616 5
d5622 8
a5629 5
	    for (; s < bufend; s++,to++) {
		if (*s == '\n' && !rsfp)
		    curcop->cop_line++;
		if (*s == '\\' && s+1 < bufend) {
		    if ((s[1] == multi_open) || (s[1] == multi_close))
d5634 2
a5635 1
		else if (*s == multi_close && --brackets <= 0)
d5637 1
a5637 1
		else if (*s == multi_open)
d5642 1
d5646 27
a5672 4
    if (s < bufend) break;	/* string ends on this line? */

	if (!rsfp ||
	 !(oldoldbufptr = oldbufptr = s = linestart = filter_gets(linestr, rsfp, 0))) {
d5674 1
a5674 1
	    curcop->cop_line = multi_start;
d5677 5
a5681 2
	curcop->cop_line++;
	if (PERLDB_LINE && curstash != debstash) {
d5685 3
a5687 3
	    sv_setsv(sv,linestr);
	    av_store(GvAV(curcop->cop_filegv),
	      (I32)curcop->cop_line, sv);
d5689 3
a5691 1
	bufend = SvPVX(linestr) + SvCUR(linestr);
d5693 4
a5696 1
    multi_end = curcop->cop_line;
d5698 2
d5704 7
a5710 2
    if (lex_stuff)
	lex_repl = sv;
d5712 1
a5712 1
	lex_stuff = sv;
d5716 22
d5739 1
a5739 2
scan_num(start)
char *start;
d5741 8
a5748 8
    register char *s = start;
    register char *d;
    register char *e;
    I32 tryiv;
    double value;
    SV *sv;
    I32 floatit;
    char *lastub = 0;
d5751 2
d5755 5
a5759 1
	croak("panic: scan_num");
d5762 9
d5775 1
d5780 1
d5783 1
d5787 2
d5790 1
a5790 1
		UV n, b;
d5793 2
d5797 2
d5802 2
d5808 2
d5812 1
a5812 1
		    b = *s++ & 15;
d5814 2
d5818 1
d5822 5
d5828 3
a5830 2
		    n = u << shift;
		    if (!overflowed && (n >> shift) != u) {
d5835 1
a5835 1
		    u = n | b;
d5839 4
d5846 2
d5850 5
d5858 2
a5859 2
	d = tokenbuf;
	e = tokenbuf + sizeof tokenbuf - 6; /* room for various punctuation */
d5861 2
d5864 3
d5868 1
a5868 1
		if (dowarn && lastub && s - lastub != 3)
d5873 1
d5876 1
d5880 3
a5882 1
	if (dowarn && lastub && s - lastub != 3)
d5884 5
d5892 4
d5897 1
d5904 2
d5909 2
d5912 2
d5916 2
d5924 2
d5927 2
d5930 1
d5932 12
a5943 1
	value = atof(tokenbuf);
d5949 3
d5955 2
d5962 2
a5963 3
static char *
scan_formline(s)
register char *s;
d5965 1
d5974 6
a5979 2
	    for (t = s+1; *t == ' ' || *t == '\t'; t++) ;
	    if (*t == '\n')
d5982 1
a5982 1
	if (in_eval && !rsfp) {
d5985 1
a5985 1
		eol = bufend;
d5988 1
a5988 1
	    eol = bufend = SvPVX(linestr) + SvCUR(linestr);
d6001 4
a6004 4
	if (rsfp) {
	    s = filter_gets(linestr, rsfp, 0);
	    oldoldbufptr = oldbufptr = bufptr = linestart = SvPVX(linestr);
	    bufend = bufptr + SvCUR(linestr);
d6006 1
a6006 1
		s = bufptr;
d6015 1
a6015 1
	expect = XTERM;
d6017 2
a6018 2
	    lex_state = LEX_NORMAL;
	    nextval[nexttoke].ival = 0;
d6022 2
a6023 2
	    lex_state = LEX_FORMLINE;
	nextval[nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, stuff);
d6025 1
a6025 1
	nextval[nexttoke].ival = OP_FORMLINE;
d6030 2
a6031 2
	lex_formbrack = 0;
	bufptr = s;
d6036 2
a6037 2
static void
set_csh()
d6040 2
a6041 2
    if (!cshlen)
	cshlen = strlen(cshname);
d6046 1
a6046 3
start_subparse(is_format, flags)
I32 is_format;
U32 flags;
d6048 3
a6050 2
    I32 oldsavestack_ix = savestack_ix;
    CV* outsidecv = compcv;
d6053 2
a6054 2
    if (compcv) {
	assert(SvTYPE(compcv) == SVt_PVCV);
d6056 29
a6084 24
    save_I32(&subline);
    save_item(subname);
    SAVEI32(padix);
    SAVESPTR(curpad);
    SAVESPTR(comppad);
    SAVESPTR(comppad_name);
    SAVESPTR(compcv);
    SAVEI32(comppad_name_fill);
    SAVEI32(min_intro_pending);
    SAVEI32(max_intro_pending);
    SAVEI32(pad_reset_pending);

    compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)compcv, is_format ? SVt_PVFM : SVt_PVCV);
    CvFLAGS(compcv) |= flags;

    comppad = newAV();
    comppad_name = newAV();
    comppad_name_fill = 0;
    min_intro_pending = 0;
    av_push(comppad, Nullsv);
    curpad = AvARRAY(comppad);
    padix = 0;
    subline = curcop->cop_line;
d6088 2
a6089 2
    av_store(comppadlist, 0, (SV*)comppad_name);
    av_store(comppadlist, 1, (SV*)comppad);
d6091 7
a6097 2
    CvPADLIST(compcv) = comppadlist;
    CvOUTSIDE(compcv) = (CV*)SvREFCNT_inc((SV*)outsidecv);
d6103 1
a6103 2
yywarn(s)
char *s;
d6105 3
a6107 2
    --error_count;
    in_eval |= 2;
d6109 1
a6109 1
    in_eval &= ~2;
d6114 1
a6114 2
yyerror(s)
char *s;
d6116 1
d6122 1
a6122 1
    if (!yychar || (yychar == ';' && !rsfp))
d6124 13
a6136 13
    else if (bufptr > oldoldbufptr && bufptr - oldoldbufptr < 200 &&
      oldoldbufptr != oldbufptr && oldbufptr != bufptr) {
	while (isSPACE(*oldoldbufptr))
	    oldoldbufptr++;
	context = oldoldbufptr;
	contlen = bufptr - oldoldbufptr;
    }
    else if (bufptr > oldbufptr && bufptr - oldbufptr < 200 &&
      oldbufptr != bufptr) {
	while (isSPACE(*oldbufptr))
	    oldbufptr++;
	context = oldbufptr;
	contlen = bufptr - oldbufptr;
d6141 2
a6142 2
	if (lex_state == LEX_NORMAL ||
	   (lex_state == LEX_KNOWNEXT && lex_defer == LEX_NORMAL))
d6144 1
a6144 1
	else if (lex_inpat)
d6161 1
a6161 1
	      GvSV(curcop->cop_filegv), (long)curcop->cop_line);
d6166 1
a6166 1
    if (multi_start < multi_end && (U32)(curcop->cop_line - multi_end) <= 1) {
d6169 2
a6170 2
		(int)multi_open,(int)multi_close,(long)multi_start);
        multi_end = 0;
d6172 1
a6172 1
    if (in_eval & 2)
d6174 2
a6175 2
    else if (in_eval)
	sv_catsv(GvSV(errgv), msg);
d6178 4
a6181 3
    if (++error_count >= 10)
	croak("%_ has too many errors.\n", GvSV(curcop->cop_filegv));
    in_my = 0;
d6184 2
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d19 1
d25 2
a26 1
static char *scan_ident _((char *s, char *send, char *dest, I32 ck_uni));
d32 2
a33 1
static char *scan_word _((char *s, char *dest, int allow_package, STRLEN *slp));
d45 1
d50 1
a50 1
static char * filter_gets _((SV *sv, FILE *fp));
d53 12
d69 13
a81 10
#define LEX_NORMAL		9
#define LEX_INTERPNORMAL	8
#define LEX_INTERPCASEMOD	7
#define LEX_INTERPSTART		6
#define LEX_INTERPEND		5
#define LEX_INTERPENDMAYBE	4
#define LEX_INTERPCONCAT	3
#define LEX_INTERPCONST		2
#define LEX_FORMLINE		1
#define LEX_KNOWNEXT		0
d90 6
a165 1
    char tmpbuf[128];
d167 2
a168 1
    bool is_first = (oldbufptr == SvPVX(linestr));
d170 1
a170 2
    sprintf(tmpbuf, "%s found where operator expected", what);
    yywarn(tmpbuf);
d199 1
a199 1
	tmpbuf[1] = multi_close ^ 64;
d234 6
a239 6
    SAVEINT(lex_dojoin);
    SAVEINT(lex_brackets);
    SAVEINT(lex_fakebrack);
    SAVEINT(lex_casemods);
    SAVEINT(lex_starts);
    SAVEINT(lex_state);
d241 2
a242 2
    SAVEINT(lex_inwhat);
    SAVEINT(curcop->cop_line);
d247 1
d284 1
a284 1
    oldoldbufptr = oldbufptr = bufptr = SvPVX(linestr);
d294 1
d301 1
a301 1
    FILE *fp = (FILE*)f;
d303 2
a304 2
    if (rsfp == stdin)
	clearerr(rsfp);
d306 1
a306 1
	fclose(rsfp);
d361 1
d372 1
a372 1
	if ((s = filter_gets(linestr, rsfp)) == Nullch) {
d374 3
a376 1
		sv_setpv(linestr,minus_p ? ";}continue{print" : "");
d382 1
a382 1
	    oldoldbufptr = oldbufptr = bufptr = s = SvPVX(linestr);
d386 2
a387 2
	    else if ((FILE*)rsfp == stdin)
		clearerr(stdin);
d389 3
a391 1
		(void)fclose(rsfp);
d395 3
a397 2
	oldoldbufptr = oldbufptr = bufptr = s;
	bufend = bufptr + SvCUR(linestr);
d399 1
a399 1
	if (perldb && curstash != debstash) {
d403 1
a403 1
	    sv_setsv(sv,linestr);
d457 5
a461 1
lop(f,x,s)
d465 1
d514 1
a514 1
	s = scan_word(s, tokenbuf, allow_pack, &len);
d545 4
a548 1
	    gv_fetchpv(s, TRUE,
d558 28
d631 5
a635 1
	yylval.opval = (OP*)newSVOP(op_type, 0, q(lex_stuff));
d640 18
d659 8
a666 6
    SAVEINT(lex_dojoin);
    SAVEINT(lex_brackets);
    SAVEINT(lex_fakebrack);
    SAVEINT(lex_casemods);
    SAVEINT(lex_starts);
    SAVEINT(lex_state);
d668 2
a669 2
    SAVEINT(lex_inwhat);
    SAVEINT(curcop->cop_line);
d673 1
d681 1
a681 1
    bufend = bufptr = oldbufptr = oldoldbufptr = SvPVX(linestr);
d698 3
a700 3
    lex_inwhat = op_type;
    if (op_type == OP_MATCH || op_type == OP_SUBST)
	lex_inpat = lex_op;
d702 1
a702 1
	lex_inpat = 0;
d704 1
a704 9
    expect = XTERM;
    force_next('(');
    if (lex_op) {
	yylval.opval = lex_op;
	lex_op = Nullop;
	return PMFUNC;
    }
    else
	return FUNC;
d725 1
a725 1
	bufend = bufptr = oldbufptr = oldoldbufptr = SvPVX(linestr);
d846 2
a847 4
		*d = *s++;
		if (isLOWER(*d))
		    *d = toUPPER(*d);
		*d++ ^= 64;
d932 1
a932 1
	char tmpbuf[512];
d957 1
a957 1
		    scan_ident(s,send,tmpbuf,FALSE);
d1027 1
a1027 1
    char tmpbuf[1024];
d1034 1
a1034 1
	if (!GvCV(gv))
d1037 1
a1037 1
    s = scan_word(s, tmpbuf, TRUE, &len);
d1048 1
a1048 1
	if (indirgv && GvCV(indirgv))
d1051 1
a1051 1
	if (!gv || GvIO(indirgv) || gv_stashpv(tmpbuf, FALSE)) {
d1053 2
d1117 1
a1117 1
	warn("filter_add func %lx (%s)", funcp, SvPV(datasv,na));
d1130 1
a1130 1
	warn("filter_del func %lx", funcp);
d1169 2
a1170 2
	    if ((len = fread(SvPVX(buf_sv) + old_len, 1, maxlen, rsfp)) <= 0){
		if (ferror(rsfp))
d1179 1
a1179 1
		if (ferror(rsfp))
d1196 1
a1196 1
	warn("filter_read %d: via function %lx (%s)\n",
d1205 1
a1205 1
filter_gets(sv,fp)
d1207 2
a1208 1
register FILE *fp;
d1212 2
a1213 1
        SvCUR_set(sv, 0);	/* start with empty line	*/
d1220 1
a1220 1
        return (sv_gets(sv, fp, 0)) ;
d1230 1
a1230 1
extern int yychar;		/* last token */
d1240 51
d1340 1
a1340 1
		char* newlb = (char*)realloc(lex_casestack, lex_casemods + 2);
d1374 3
d1398 1
a1398 3
	else
	    return yylex();
	break;
d1462 1
a1462 1
	fprintf(stderr,"### Tokener expecting %s at %s\n", exp_name[expect], s);
d1468 1
a1468 2
	warn("Unrecognized character \\%03o ignored", *s++ & 255);
	goto retry;
d1474 2
d1503 22
a1524 10
		if (minus_a){
		    if (minus_F){
		      char tmpbuf1[50];
		      if ( splitstr[0] == '/' || 
		           splitstr[0] == '\'' || 
		           splitstr[0] == '"' )
			    sprintf( tmpbuf1, "@@F=split(%s);", splitstr );
		        else
			    sprintf( tmpbuf1, "@@F=split('%s');", splitstr );
		        sv_catpv(linestr,tmpbuf1);
d1531 1
a1531 1
	    oldoldbufptr = oldbufptr = s = SvPVX(linestr);
d1533 1
a1533 1
	    if (perldb && curstash != debstash) {
d1543 1
a1543 1
	    if ((s = filter_gets(linestr, rsfp)) == Nullch) {
d1548 2
a1549 2
		    else if ((FILE*)rsfp == stdin)
			clearerr(stdin);
d1551 3
a1553 1
			(void)fclose(rsfp);
d1559 1
a1559 1
		    oldoldbufptr = oldbufptr = s = SvPVX(linestr);
d1564 1
a1564 1
		oldoldbufptr = oldbufptr = s = SvPVX(linestr);
d1575 1
a1575 1
		    oldoldbufptr = oldbufptr = s = SvPVX(linestr);
d1582 2
a1583 2
	oldoldbufptr = oldbufptr = bufptr = s;
	if (perldb && curstash != debstash) {
d1596 44
a1639 1
	    if (!in_eval && *s == '#' && s[1] == '!') {
d1643 20
d1664 2
a1670 1
		    char *cmd;
d1672 2
a1673 7
		    s += 2;
		    if (*s == ' ')
			s++;
		    cmd = s;
		    while (s < bufend && !isSPACE(*s))
			s++;
		    *s++ = '\0';
d1686 3
a1688 3
		    newargv[0] = cmd;
		    execv(cmd,newargv);
		    croak("Can't exec %s", cmd);
d1691 3
a1693 3
		    int oldpdb = perldb;
		    int oldn = minus_n;
		    int oldp = minus_p;
d1696 1
a1696 1
		    while (*d == ' ') d++;
d1699 10
a1708 2
			while (d = moreswitches(d)) ;
			if (perldb && !oldpdb ||
d1714 1
a1714 1
			    oldoldbufptr = oldbufptr = s = SvPVX(linestr);
d1717 1
a1717 1
			    if (perldb)
d1731 5
a1735 1
    case ' ': case '\t': case '\f': case '\r': case 013:
d1770 1
a1770 1
			tmp, tmp);
d1805 1
a1805 1
		croak("Unrecognized file test: -%c", tmp);
d1856 1
a1856 1
	    s = scan_ident(s, bufend, tokenbuf, TRUE);
d1871 10
a1880 26
	if (expect != XOPERATOR) {
	    s = scan_ident(s, bufend, tokenbuf + 1, TRUE);
	    if (tokenbuf[1]) {
		expect = XOPERATOR;
		tokenbuf[0] = '%';
		if (in_my) {
		    if (strchr(tokenbuf,':'))
			croak(no_myglob,tokenbuf);
		    nextval[nexttoke].opval = newOP(OP_PADANY, 0);
		    nextval[nexttoke].opval->op_targ = pad_allocmy(tokenbuf);
		    force_next(PRIVATEREF);
		    TERM('%');
		}
		if (!strchr(tokenbuf,':')) {
		    if (tmp = pad_findmy(tokenbuf)) {
			nextval[nexttoke].opval = newOP(OP_PADANY, 0);
			nextval[nexttoke].opval->op_targ = tmp;
			force_next(PRIVATEREF);
			TERM('%');
		    }
		}
		force_ident(tokenbuf + 1, *tokenbuf);
	    }
	    else
		PREREF('%');
	    TERM('%');
d1882 2
a1883 2
	++s;
	Mop(OP_MODULO);
d1937 1
a1937 1
	    char* newlb = (char*)realloc(lex_brackstack, lex_brackets + 1);
a1953 1
	    break;
d1957 11
a1967 2
	    if (s < bufend && isALPHA(*s)) {
		d = scan_word(s, tokenbuf, FALSE, &len);
d1971 1
d1973 3
a1975 2
		      (keyword(tokenbuf, len) ||
		       perl_get_cv(tokenbuf, FALSE) ))
d1977 4
a1980 2
			    tokenbuf, tokenbuf);
		    s = force_word(s,WORD,FALSE,TRUE,FALSE);
d2001 22
a2022 2
		if (isALPHA(*s)) {
		    for (t = s; t < bufend && isALNUM(*t); t++) ;
d2024 37
a2060 4
		else if (*s == '\'' || *s == '"') {
		    t = strchr(s+1,*s);
		    if (!t++)
			t = s;
a2061 2
		else
		    t = s;
d2064 4
a2067 1
		if ((*t == ',' && !isLOWER(*s)) || (*t == '=' && t[1] == '>'))
d2098 3
a2100 1
		if (*s != '[' && *s != '{' && (*s != '-' || s[1] != '>'))
d2118 1
a2118 1
	    if (dowarn && isALPHA(*s) && bufptr == SvPVX(linestr)) {
d2126 1
a2126 1
	s = scan_ident(s-1, bufend, tokenbuf, TRUE);
d2153 1
a2153 1
	    warn("Reversed %c= operator",tmp);
d2156 1
a2156 1
		(s == SvPVX(linestr)+1 || s[-2] == '\n') )
d2234 7
a2240 10
	if (s[1] == '#'  && (isALPHA(s[2]) || strchr("_{$:", s[2]))) {
	    s = scan_ident(s+1, bufend, tokenbuf+1, FALSE);
	    if (expect == XOPERATOR) {
		if (lex_formbrack && lex_brackets == lex_formbrack) {
		    expect = XTERM;
		    depcom();
		    return ','; /* grandfather non-comma-format format */
		}
		else
		    no_op("Array length",s);
d2242 9
a2250 1
	    else if (!tokenbuf[1])
a2251 10
	    if (!strchr(tokenbuf+1,':')) {
		tokenbuf[0] = '@@';
		if (tmp = pad_findmy(tokenbuf)) {
		    nextval[nexttoke].opval = newOP(OP_PADANY, 0);
		    nextval[nexttoke].opval->op_targ = tmp;
		    expect = XOPERATOR;
		    force_next(PRIVATEREF);
		    TOKEN(DOLSHARP);
		}
	    }
d2253 1
a2253 1
	    force_ident(tokenbuf+1, *tokenbuf);
d2256 17
a2272 9
	s = scan_ident(s, bufend, tokenbuf+1, FALSE);
	if (expect == XOPERATOR) {
	    if (lex_formbrack && lex_brackets == lex_formbrack) {
		expect = XTERM;
		depcom();
		return ',';	/* grandfather non-comma-format format */
	    }
	    else
		no_op("Scalar",s);
a2273 2
	if (tokenbuf[1]) {
	    expectation oldexpect = expect;
d2275 12
a2286 12
	    /* This kludge not intended to be bulletproof. */
	    if (tokenbuf[1] == '[' && !tokenbuf[2]) {
		yylval.opval = newSVOP(OP_CONST, 0,
					newSViv((IV)compiling.cop_arybase));
		yylval.opval->op_private = OPpCONST_ARYBASE;
		TERM(THING);
	    }
	    tokenbuf[0] = '$';
	    if (dowarn) {
		char *t;
		if (*s == '[' && oldexpect != XREF) {
		    for (t = s+1; isSPACE(*t) || isALNUM(*t) || *t == '$'; t++) ;
d2289 2
a2290 1
			while (t < bufend && *t != ']') t++;
d2292 1
a2292 1
			    t-bufptr+1, bufptr);
d2295 7
a2301 3
		if (*s == '{' && strEQ(tokenbuf, "$SIG") &&
		  (t = strchr(s,'}')) && (t = strchr(t,'='))) {
		    char tmpbuf[1024];
d2305 1
a2305 1
			t = scan_word(t, tmpbuf, TRUE, &len);
d2311 29
a2339 33
	    expect = XOPERATOR;
	    if (lex_state == LEX_NORMAL && isSPACE(*s)) {
		bool islop = (last_lop == oldoldbufptr);
		s = skipspace(s);
		if (!islop || last_lop_op == OP_GREPSTART)
		    expect = XOPERATOR;
		else if (strchr("$@@\"'`q", *s))
		    expect = XTERM;		/* e.g. print $fh "foo" */
		else if (strchr("&*<%", *s) && isIDFIRST(s[1]))
		    expect = XTERM;		/* e.g. print $fh &sub */
		else if (isDIGIT(*s))
		    expect = XTERM;		/* e.g. print $fh 3 */
		else if (*s == '.' && isDIGIT(s[1]))
		    expect = XTERM;		/* e.g. print $fh .3 */
		else if (strchr("/?-+", *s) && !isSPACE(s[1]))
		    expect = XTERM;		/* e.g. print $fh -1 */
		else if (*s == '<' && s[1] == '<' && !isSPACE(s[2]))
		    expect = XTERM;		/* print $fh <<"EOF" */
	    }
	    if (in_my) {
		if (strchr(tokenbuf,':'))
		    croak(no_myglob,tokenbuf);
		nextval[nexttoke].opval = newOP(OP_PADANY, 0);
		nextval[nexttoke].opval->op_targ = pad_allocmy(tokenbuf);
		force_next(PRIVATEREF);
	    }
	    else if (!strchr(tokenbuf,':')) {
		if (oldexpect != XREF || oldoldbufptr == last_lop) {
		    if (intuit_more(s)) {
			if (*s == '[')
			    tokenbuf[0] = '@@';
			else if (*s == '{')
			    tokenbuf[0] = '%';
d2342 4
a2345 17
		if (tmp = pad_findmy(tokenbuf)) {
		    if (!tokenbuf[2] && *tokenbuf =='$' &&
			tokenbuf[1] <= 'b' && tokenbuf[1] >= 'a')
		    {
			for (d = in_eval ? oldoldbufptr : SvPVX(linestr);
			    d < bufend && *d != '\n';
			    d++)
			{
			    if (strnEQ(d,"<=>",3) || strnEQ(d,"cmp",3)) {
			        croak("Can't use \"my %s\" in sort comparison",
				    tokenbuf);
			    }
			}
		    }
		    nextval[nexttoke].opval = newOP(OP_PADANY, 0);
		    nextval[nexttoke].opval->op_targ = tmp;
		    force_next(PRIVATEREF);
a2346 2
		else
		    force_ident(tokenbuf+1, *tokenbuf);
d2348 8
a2355 7
	    else
		force_ident(tokenbuf+1, *tokenbuf);
	}
	else {
	    if (s == bufend)
		yyerror("Final $ should be \\$ or $name");
	    PREREF('$');
d2357 1
a2360 1
	s = scan_ident(s, bufend, tokenbuf+1, FALSE);
d2362 13
a2374 38
	    no_op("Array",s);
	if (tokenbuf[1]) {
	    GV* gv;

	    tokenbuf[0] = '@@';
	    expect = XOPERATOR;
	    if (in_my) {
		if (strchr(tokenbuf,':'))
		    croak(no_myglob,tokenbuf);
		nextval[nexttoke].opval = newOP(OP_PADANY, 0);
		nextval[nexttoke].opval->op_targ = pad_allocmy(tokenbuf);
		force_next(PRIVATEREF);
		TERM('@@');
	    }
	    else if (!strchr(tokenbuf,':')) {
		if (intuit_more(s)) {
		    if (*s == '{')
			tokenbuf[0] = '%';
		}
		if (tmp = pad_findmy(tokenbuf)) {
		    nextval[nexttoke].opval = newOP(OP_PADANY, 0);
		    nextval[nexttoke].opval->op_targ = tmp;
		    force_next(PRIVATEREF);
		    TERM('@@');
		}
	    }

	    /* Force them to make up their mind on "@@foo". */
	    if (lex_state != LEX_NORMAL && !lex_brackets &&
		    ( !(gv = gv_fetchpv(tokenbuf+1, FALSE, SVt_PVAV)) ||
		      (*tokenbuf == '@@'
			? !GvAV(gv)
			: !GvHV(gv) )))
	    {
		char tmpbuf[1024];
		sprintf(tmpbuf, "Literal @@%s now requires backslash",tokenbuf+1);
		yyerror(tmpbuf);
	    }
a2389 6
	    force_ident(tokenbuf+1, *tokenbuf);
	}
	else {
	    if (s == bufend)
		yyerror("Final @@ should be \\@@ or @@name");
	    PREREF('@@');
d2391 1
d2408 1
a2408 1
		(s == SvPVX(linestr) || s[-1] == '\n') ) {
d2530 10
a2539 3
	s = scan_word(s, tokenbuf, FALSE, &len);
	
	if (*s == ':' && s[1] == ':' && strNE(tokenbuf, "CORE"))
d2542 14
a2558 3
	d = s;
	while (d < bufend && (*d == ' ' || *d == '\t'))
		d++;	/* no comments skipped here, or s### is misparsed */
d2588 1
d2594 2
a2595 1
		    s = scan_word(s, tokenbuf + len, TRUE, &len);
d2600 2
a2601 13
		/* Do special processing at start of statement. */

		if (expect == XSTATE) {
		    while (isSPACE(*s)) s++;
		    if (*s == ':') {	/* It's a label. */
			yylval.pval = savepv(tokenbuf);
			s++;
			CLINE;
			TOKEN(LABEL);
		    }
		}
		else if (expect == XOPERATOR) {
		    if (bufptr == SvPVX(linestr)) {
d2607 1
a2607 1
			no_op("Bare word",s);
d2643 1
a2643 1
                         (!immediate_paren && (!gv || !GvCV(gv))) ) &&
d2656 7
d2672 1
a2672 1
		if ((*s == '$' || *s == '{') && (!gv || !GvCV(gv))) {
d2685 2
a2686 9
		if (gv && GvCV(gv)) {
		    CV* cv = GvCV(gv);
		    if (*s == '(') {
			nextval[nexttoke].opval = yylval.opval;
			expect = XTERM;
			force_next(WORD);
			yylval.ival = 0;
			TOKEN('&');
		    }
d2692 10
d2727 1
d2757 5
d2763 9
a2771 6
	case KEY___FILE__: {
	    if (tokenbuf[2] == 'L')
		(void)sprintf(tokenbuf,"%ld",(long)curcop->cop_line);
	    else
		strcpy(tokenbuf, SvPVX(GvSV(curcop->cop_filegv)));
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(tokenbuf,0));
a2772 1
	}
a2779 1
		char dname[256];
d2783 1
a2783 2
		sprintf(dname,"%s::DATA", pname);
		gv = gv_fetchpv(dname,TRUE, SVt_PVIO);
d2790 1
a2790 1
		    int fd = fileno(rsfp);
d2794 2
d2798 1
a2798 1
		else if ((FILE*)rsfp == stdin)
d2821 1
a2821 1
		s = scan_word(s, tokenbuf, FALSE, &len);
d2989 10
a2998 4
	    while (s < bufend && isSPACE(*s))
		s++;
	    if (isIDFIRST(*s))
		croak("Missing $ on loop variable");
d3057 1
a3057 1
	    FUN1(OP_GPWNAM);
d3060 1
a3060 1
	    FUN1(OP_GPWUID);
d3102 1
a3102 1
	    FUN1(OP_GGRNAM);
d3105 1
a3105 1
	    FUN1(OP_GGRGID);
a3149 1
	    yylval.ival = 0;
d3200 1
a3200 2
	    yylval.ival = 1;
	    OPERATOR(LOCAL);
d3213 1
d3289 13
d3342 1
a3342 1
		gv_stashpv(tokenbuf, TRUE);
d3433 1
a3433 1
	    FUN1(OP_SHOSTENT);
d3436 1
a3436 1
	    FUN1(OP_SNETENT);
d3439 1
a3439 1
	    FUN1(OP_SSERVENT);
d3442 1
a3442 1
	    FUN1(OP_SPROTOENT);
d3526 1
a3526 1
		char tmpbuf[128];
d3528 1
a3528 1
		d = scan_word(s, tmpbuf, TRUE, &len);
d3553 2
d3562 10
d3604 3
d3681 12
a3692 1
	    s = force_word(s,WORD,FALSE,TRUE,FALSE);
d3749 1
d3751 1
a3751 1
	    if (strEQ(d,"__FILE__"))		return -KEY___FILE__;
d3978 1
a3978 1
	    if (strEQ(d,"glob"))		return -KEY_glob;
d4257 2
d4261 1
a4261 2
		if (strEQ(d,"symlink"))		return -KEY_symlink;
		if (strEQ(d,"syscall"))		return -KEY_syscall;
d4373 1
a4373 1
	if (!*w || !strchr(";|})]oa!=", *w))	/* an advisory hack only... */
d4401 1
a4401 1
scan_word(s, dest, allow_package, slp)
d4404 1
d4409 1
d4411 2
d4433 1
a4433 1
scan_ident(s,send,dest,ck_uni)
d4437 1
d4441 1
d4450 1
d4452 3
a4454 1
	while (isDIGIT(*s))
d4456 1
d4460 2
d4485 7
a4491 2
      (isALPHA(s[1]) || strchr("$_{", s[1]) || strnEQ(s+1,"::",2)) )
	return s;
d4502 2
a4503 1
	*d = *s++ ^ 64;
d4507 7
a4513 2
	    while (s < send && (*s == ' ' || *s == '\t')) s++;
	    *d = *s;
d4515 1
a4515 1
	if (isALPHA(*d) || *d == '_') {
d4521 1
a4521 1
	    if ((*s == '[' || *s == '{')) {
d4539 1
a4539 1
	    if (dowarn &&
d4558 1
a4558 2
    if (ch == 'i') {
	sawi = TRUE;
a4559 1
    }
d4562 2
d4588 1
d4592 1
a4592 2

    while (*s && strchr("iogmsx", *s))
d4594 1
a4595 1
    pm->op_pmpermflags = pm->op_pmflags;
d4607 1
d4624 1
d4635 1
d4638 1
a4638 1
    while (*s && strchr("iogmsex", *s)) {
a4675 2
	else if (pm->op_pmflags & PMf_FOLD)
	    return;
d4693 5
a4697 3
	if (!pm->op_pmshort ||	/* promote the better string */
	  ((pm->op_pmflags & PMf_SCANFIRST) &&
	   (SvCUR(pm->op_pmshort) < SvCUR(pm->op_pmregexp->regmust)) )){
d4771 1
d4773 1
d4777 2
a4778 1
    if (!rsfp)
d4784 2
a4785 1
	s = cpytill(d,s,bufend,term,&len);
a4787 1
	d += len;
d4796 7
a4802 3
	while (isALNUM(*s))
	    *d++ = *s++;
    }				/* assuming tokenbuf won't clobber */
d4807 1
a4807 1
    if (rsfp || !(d=ninstr(s,bufend,d,d+1)))
d4828 1
a4828 1
    if (!rsfp) {
d4831 1
a4831 1
	  (*s != term || bcmp(s,tokenbuf,len) != 0) ) {
d4843 1
a4843 1
	oldoldbufptr = oldbufptr = bufptr = s = SvPVX(linestr);
d4849 2
a4850 2
	if (!rsfp ||
	 !(oldoldbufptr = oldbufptr = s = filter_gets(linestr, rsfp))) {
d4855 1
a4855 1
	if (perldb && curstash != debstash) {
d4864 1
a4864 1
	if (*s == term && bcmp(s,tokenbuf,len) == 0) {
d4893 1
d4897 5
a4901 4
    s = cpytill(d, s+1, bufend, '>', &len);
    if (s < bufend)
	s++;
    else
d4903 1
a4903 1

d4992 2
a4993 2
		if (*s == '\\' && s+1 < bufend && term != '\\') {
		    if (s[1] == term)
d4998 1
a4998 1
		else if (*s == term && --brackets <= 0)
d5011 1
a5011 1
	 !(oldoldbufptr = oldbufptr = s = filter_gets(linestr, rsfp))) {
d5017 1
a5017 1
	if (perldb && curstash != debstash) {
d5046 2
a5047 1
    I32 tryi32;
d5052 1
d5059 1
a5059 1
	    U32 i;
d5061 1
d5071 1
a5071 1
	    i = 0;
d5073 2
d5087 2
a5088 3
		    i <<= shift;
		    i += *s++ & 15;
		    break;
d5093 9
a5101 2
		    i <<= 4;
		    i += (*s++ & 7) + 9;
d5107 1
a5107 5
	    tryi32 = i;
	    if (tryi32 == i && tryi32 >= 0)
		sv_setiv(sv,tryi32);
	    else
		sv_setnv(sv,(double)i);
d5114 1
d5122 3
a5124 1
	    else
d5126 1
d5133 5
a5137 5
	    while (isDIGIT(*s) || *s == '_') {
		if (*s == '_')
		    s++;
		else
		    *d++ = *s++;
d5146 3
a5148 1
	    while (isDIGIT(*s))
d5150 1
d5154 1
d5156 3
a5158 3
	tryi32 = I_32(value);
	if (!floatit && (double)tryi32 == value)
	    sv_setiv(sv,tryi32);
d5160 1
a5160 1
	    sv_setnv(sv,value);
d5205 2
a5206 2
	    s = filter_gets(linestr, rsfp);
	    oldoldbufptr = oldbufptr = bufptr = SvPVX(linestr);
d5248 4
a5251 2
int
start_subparse()
d5253 1
a5253 1
    int oldsavestack_ix = savestack_ix;
d5262 1
a5262 1
    SAVEINT(padix);
d5267 4
a5270 4
    SAVEINT(comppad_name_fill);
    SAVEINT(min_intro_pending);
    SAVEINT(max_intro_pending);
    SAVEINT(pad_reset_pending);
d5273 2
a5274 1
    sv_upgrade((SV *)compcv, SVt_PVCV);
d5311 8
a5318 4
    char tmpbuf[258];
    char *tname = tmpbuf;

    if (bufptr > oldoldbufptr && bufptr - oldoldbufptr < 200 &&
d5322 2
a5323 1
	sprintf(tname,"near \"%.*s\"",bufptr - oldoldbufptr, oldoldbufptr);
d5329 2
a5330 1
	sprintf(tname,"near \"%.*s\"",bufptr - oldbufptr, oldbufptr);
d5333 1
a5333 3
	tname = "next token ???";
    else if (!yychar || (yychar == ';' && !rsfp))
	(void)strcpy(tname,"at EOF");
d5337 1
a5337 1
	    (void)strcpy(tname,"at end of line");
d5339 10
a5348 1
	    (void)strcpy(tname,"within pattern");
d5350 2
a5351 1
	    (void)strcpy(tname,"within string");
d5353 5
a5357 2
    else if (yychar < 32)
	(void)sprintf(tname,"next char ^%c",yychar+64);
d5359 5
a5363 7
	(void)sprintf(tname,"next char %c",yychar);
    (void)sprintf(buf, "%s at %s line %d, %s\n",
      s,SvPVX(GvSV(curcop->cop_filegv)),curcop->cop_line,tname);
    if (curcop->cop_line == multi_end && multi_start < multi_end) {
	sprintf(buf+strlen(buf),
	  "  (Might be a runaway multi-line %c%c string starting on line %ld)\n",
	  multi_open,multi_close,(long)multi_start);
d5367 1
a5367 1
	warn("%s",buf);
d5369 1
a5369 1
	sv_catpv(GvSV(errgv),buf);
d5371 1
a5371 1
	fputs(buf,stderr);
d5373 1
a5373 2
	croak("%s has too many errors.\n",
	SvPVX(GvSV(curcop->cop_filegv)));
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a16 1
#ifndef PERL_OBJECT
a18 1
static char *force_version _((char *start));
d20 1
a20 1
static SV *tokeq _((SV *sv));
d24 1
a24 2
static char *scan_ident _((char *s, char *send, char *dest, STRLEN destlen,
			   I32 ck_uni));
d26 1
a26 1
static char *scan_pat _((char *start, I32 type));
d30 1
a30 2
static char *scan_word _((char *s, char *dest, STRLEN destlen,
			  int allow_package, STRLEN *slp));
a41 1
static I32 sublex_push _((void));
d46 1
a46 1
static char * filter_gets _((SV *sv, PerlIO *fp, STRLEN append));
a47 9
static SV *new_constant _((char *s, STRLEN len, char *key, SV *sv, SV *pv, char *type));
static void restore_expect _((void *e));
static void restore_lex_expect _((void *e));

static char *PL_super_bufptr;
static char *PL_super_bufend;
#endif /* PERL_OBJECT */

static char ident_too_long[] = "Identifier too long";
d53 10
a62 13
/* #define LEX_NOTPARSING		11 is done in perl.h. */

#define LEX_NORMAL		10
#define LEX_INTERPNORMAL	 9
#define LEX_INTERPCASEMOD	 8
#define LEX_INTERPPUSH		 7
#define LEX_INTERPSTART		 6
#define LEX_INTERPEND		 5
#define LEX_INTERPENDMAYBE	 4
#define LEX_INTERPCONCAT	 3
#define LEX_INTERPCONST		 2
#define LEX_FORMLINE		 1
#define LEX_KNOWNEXT		 0
a70 6
/* XXX If this causes problems, set i_unistd=undef in the hint file.  */
#ifdef I_UNISTD
#  include <unistd.h> /* Needed for execv() */
#endif


d80 1
a80 1
#define CLINE (PL_copline = (PL_curcop->cop_line < PL_copline ? PL_curcop->cop_line : PL_copline))
d82 20
a101 20
#define TOKEN(retval) return (PL_bufptr = s,(int)retval)
#define OPERATOR(retval) return (PL_expect = XTERM,PL_bufptr = s,(int)retval)
#define AOPERATOR(retval) return ao((PL_expect = XTERM,PL_bufptr = s,(int)retval))
#define PREBLOCK(retval) return (PL_expect = XBLOCK,PL_bufptr = s,(int)retval)
#define PRETERMBLOCK(retval) return (PL_expect = XTERMBLOCK,PL_bufptr = s,(int)retval)
#define PREREF(retval) return (PL_expect = XREF,PL_bufptr = s,(int)retval)
#define TERM(retval) return (CLINE, PL_expect = XOPERATOR,PL_bufptr = s,(int)retval)
#define LOOPX(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LOOPEX)
#define FTST(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)UNIOP)
#define FUN0(f) return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC0)
#define FUN1(f) return(yylval.ival = f,PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC1)
#define BOop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITOROP))
#define BAop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)BITANDOP))
#define SHop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)SHIFTOP))
#define PWop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)POWOP))
#define PMop(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MATCHOP)
#define Aop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)ADDOP))
#define Mop(f) return ao((yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)MULOP))
#define Eop(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)EQOP)
#define Rop(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)RELOP)
d107 4
a110 4
	PL_expect = XTERM, \
	PL_bufptr = s, \
	PL_last_uni = PL_oldbufptr, \
	PL_last_lop_op = f, \
d114 2
a115 2
	PL_bufptr = s, \
	PL_last_uni = PL_oldbufptr, \
d119 1
a119 1
#define OLDLOP(f) return(yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LSTOP)
d121 3
a123 2
STATIC int
ao(int toketype)
d125 2
a126 2
    if (*PL_bufptr == '=') {
	PL_bufptr++;
d136 11
a146 8
STATIC void
no_op(char *what, char *s)
{
    char *oldbp = PL_bufptr;
    bool is_first = (PL_oldbufptr == PL_linestart);

    PL_bufptr = s;
    yywarn(form("%s found where operator expected", what));
d149 1
a149 1
    else if (PL_oldoldbufptr && isIDFIRST(*PL_oldoldbufptr)) {
d151 2
a152 2
	for (t = PL_oldoldbufptr; *t && (isALNUM(*t) || *t == ':'); t++) ;
	if (t < PL_bufptr && isSPACE(*t))
d154 1
a154 1
		t - PL_oldoldbufptr, PL_oldoldbufptr);
d159 1
a159 1
    PL_bufptr = oldbp;
d162 3
a164 2
STATIC void
missingterm(char *s)
d173 1
a173 7
    else if (
#ifdef EBCDIC
	iscntrl(PL_multi_close)
#else
	PL_multi_close < 32 || PL_multi_close == 127
#endif
	) {
d175 1
a175 1
	tmpbuf[1] = toCTRL(PL_multi_close);
d181 1
a181 1
	*tmpbuf = PL_multi_close;
d190 2
a191 1
deprecate(char *s)
d193 1
a193 1
    if (PL_dowarn)
d197 2
a198 2
STATIC void
depcom(void)
a202 13
#ifdef WIN32

STATIC I32
win32_textfilter(int idx, SV *sv, int maxlen)
{
 I32 count = FILTER_READ(idx+1, sv, maxlen);
 if (count > 0 && !maxlen)
  win32_strip_return(sv);
 return count;
}
#endif


d204 2
a205 1
lex_start(SV *line)
a206 1
    dTHR;
d210 43
a252 45
    SAVEI32(PL_lex_dojoin);
    SAVEI32(PL_lex_brackets);
    SAVEI32(PL_lex_fakebrack);
    SAVEI32(PL_lex_casemods);
    SAVEI32(PL_lex_starts);
    SAVEI32(PL_lex_state);
    SAVESPTR(PL_lex_inpat);
    SAVEI32(PL_lex_inwhat);
    SAVEI16(PL_curcop->cop_line);
    SAVEPPTR(PL_bufptr);
    SAVEPPTR(PL_bufend);
    SAVEPPTR(PL_oldbufptr);
    SAVEPPTR(PL_oldoldbufptr);
    SAVEPPTR(PL_linestart);
    SAVESPTR(PL_linestr);
    SAVEPPTR(PL_lex_brackstack);
    SAVEPPTR(PL_lex_casestack);
    SAVEDESTRUCTOR(restore_rsfp, PL_rsfp);
    SAVESPTR(PL_lex_stuff);
    SAVEI32(PL_lex_defer);
    SAVESPTR(PL_lex_repl);
    SAVEDESTRUCTOR(restore_expect, PL_tokenbuf + PL_expect); /* encode as pointer */
    SAVEDESTRUCTOR(restore_lex_expect, PL_tokenbuf + PL_expect);

    PL_lex_state = LEX_NORMAL;
    PL_lex_defer = 0;
    PL_expect = XSTATE;
    PL_lex_brackets = 0;
    PL_lex_fakebrack = 0;
    New(899, PL_lex_brackstack, 120, char);
    New(899, PL_lex_casestack, 12, char);
    SAVEFREEPV(PL_lex_brackstack);
    SAVEFREEPV(PL_lex_casestack);
    PL_lex_casemods = 0;
    *PL_lex_casestack = '\0';
    PL_lex_dojoin = 0;
    PL_lex_starts = 0;
    PL_lex_stuff = Nullsv;
    PL_lex_repl = Nullsv;
    PL_lex_inpat = 0;
    PL_lex_inwhat = 0;
    PL_linestr = line;
    if (SvREADONLY(PL_linestr))
	PL_linestr = sv_2mortal(newSVsv(PL_linestr));
    s = SvPV(PL_linestr, len);
d254 10
a263 10
	if (!(SvFLAGS(PL_linestr) & SVs_TEMP))
	    PL_linestr = sv_2mortal(newSVsv(PL_linestr));
	sv_catpvn(PL_linestr, "\n;", 2);
    }
    SvTEMP_off(PL_linestr);
    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = SvPVX(PL_linestr);
    PL_bufend = PL_bufptr + SvCUR(PL_linestr);
    SvREFCNT_dec(PL_rs);
    PL_rs = newSVpv("\n", 1);
    PL_rsfp = 0;
d267 1
a267 7
lex_end(void)
{
    PL_doextract = FALSE;
}

STATIC void
restore_rsfp(void *f)
a268 7
    PerlIO *fp = (PerlIO*)f;

    if (PL_rsfp == PerlIO_stdin())
	PerlIO_clearerr(PL_rsfp);
    else if (PL_rsfp && (PL_rsfp != fp))
	PerlIO_close(PL_rsfp);
    PL_rsfp = fp;
d271 3
a273 2
STATIC void
restore_expect(void *e)
d275 1
a275 3
    /* a safe way to store a small integer in a pointer */
    PL_expect = (expectation)((char *)e - PL_tokenbuf);
}
d277 5
a281 5
STATIC void
restore_lex_expect(void *e)
{
    /* a safe way to store a small integer in a pointer */
    PL_lex_expect = (expectation)((char *)e - PL_tokenbuf);
d284 3
a286 2
STATIC void
incline(char *s)
a287 1
    dTHR;
d293 1
a293 1
    PL_curcop->cop_line++;
d318 1
a318 1
	PL_curcop->cop_filegv = gv_fetchfile(s);
d320 1
a320 1
	PL_curcop->cop_filegv = gv_fetchfile(PL_origfilename);
d322 1
a322 1
    PL_curcop->cop_line = atoi(n)-1;
d325 3
a327 2
STATIC char *
skipspace(register char *s)
d329 2
a330 3
    dTHR;
    if (PL_lex_formbrack && PL_lex_brackets <= PL_lex_formbrack) {
	while (s < PL_bufend && (*s == ' ' || *s == '\t'))
d335 4
a338 7
	STRLEN prevlen;
	while (s < PL_bufend && isSPACE(*s)) {
	    if (*s++ == '\n' && PL_in_eval && !PL_rsfp)
		incline(s);
	}
	if (s < PL_bufend && *s == '#') {
	    while (s < PL_bufend && *s != '\n')
d340 1
a340 1
	    if (s < PL_bufend) {
a341 5
		if (PL_in_eval && !PL_rsfp) {
		    incline(s);
		    continue;
		}
	    }
d343 1
a343 1
	if (s < PL_bufend || !PL_rsfp || PL_lex_state != LEX_NORMAL)
d345 5
a349 7
	if ((s = filter_gets(PL_linestr, PL_rsfp, (prevlen = SvCUR(PL_linestr)))) == Nullch) {
	    if (PL_minus_n || PL_minus_p) {
		sv_setpv(PL_linestr,PL_minus_p ?
			 ";}continue{print or die qq(-p destination: $!\\n)" :
			 "");
		sv_catpv(PL_linestr,";}");
		PL_minus_n = PL_minus_p = 0;
d352 7
a358 7
		sv_setpv(PL_linestr,";");
	    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = s = PL_linestart = SvPVX(PL_linestr);
	    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	    if (PL_preprocess && !PL_in_eval)
		(void)PerlProc_pclose(PL_rsfp);
	    else if ((PerlIO*)PL_rsfp == PerlIO_stdin())
		PerlIO_clearerr(PL_rsfp);
d360 2
a361 2
		(void)PerlIO_close(PL_rsfp);
	    PL_rsfp = Nullfp;
d364 2
a365 3
	PL_linestart = PL_bufptr = s + prevlen;
	PL_bufend = s + SvCUR(PL_linestr);
	s = PL_bufptr;
d367 1
a367 1
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
d371 2
a372 2
	    sv_setpvn(sv,PL_bufptr,PL_bufend-PL_bufptr);
	    av_store(GvAV(PL_curcop->cop_filegv),(I32)PL_curcop->cop_line,sv);
d377 2
a378 2
STATIC void
check_uni(void) {
d383 1
a383 1
    if (PL_oldoldbufptr != PL_last_uni)
d385 4
a388 4
    while (isSPACE(*PL_last_uni))
	PL_last_uni++;
    for (s = PL_last_uni; isALNUM(*s) || *s == '-'; s++) ;
    if ((t = strchr(s, '(')) && t < PL_bufptr)
d392 1
a392 1
    warn("Warning: Use of \"%s\" without parens is ambiguous", PL_last_uni);
d401 4
a404 2
STATIC int
uni(I32 f, char *s)
d407 4
a410 4
    PL_expect = XTERM;
    PL_bufptr = s;
    PL_last_uni = PL_oldbufptr;
    PL_last_lop_op = f;
d424 5
a428 2
STATIC I32
lop(I32 f, expectation x, char *s)
a429 1
    dTHR;
d432 5
a436 5
    PL_expect = x;
    PL_bufptr = s;
    PL_last_lop = PL_oldbufptr;
    PL_last_lop_op = f;
    if (PL_nexttoke)
d447 10
a456 9
STATIC void 
force_next(I32 type)
{
    PL_nexttype[PL_nexttoke] = type;
    PL_nexttoke++;
    if (PL_lex_state != LEX_KNOWNEXT) {
	PL_lex_defer = PL_lex_state;
	PL_lex_expect = PL_expect;
	PL_lex_state = LEX_KNOWNEXT;
d460 7
a466 2
STATIC char *
force_word(register char *start, int token, int check_keyword, int allow_pack, int allow_initial_tick)
d475 1
a475 1
	(allow_initial_tick && *s == '\'') )
d477 2
a478 2
	s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, allow_pack, &len);
	if (check_keyword && keyword(PL_tokenbuf, len))
d483 1
a483 1
		PL_expect = XTERM;
d485 1
a485 1
		PL_expect = XOPERATOR;
d490 2
a491 2
	PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST,0, newSVpv(PL_tokenbuf,0));
	PL_nextval[PL_nexttoke].opval->op_private |= OPpCONST_BARE;
d497 4
a500 2
STATIC void
force_ident(register char *s, int kind)
d503 2
a504 2
	OP* o = (OP*)newSVOP(OP_CONST, 0, newSVpv(s,0));
	PL_nextval[PL_nexttoke].opval = o;
d507 2
a508 6
	    dTHR;		/* just for in_eval */
	    o->op_private = OPpCONST_ENTERED;
	    /* XXX see note in pp_entereval() for why we forgo typo
	       warnings if the symbol must be introduced in an eval.
	       GSAR 96-10-12 */
	    gv_fetchpv(s, PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : TRUE,
d518 3
a520 29
STATIC char *
force_version(char *s)
{
    OP *version = Nullop;

    s = skipspace(s);

    /* default VERSION number -- GBARR */

    if(isDIGIT(*s)) {
        char *d;
        int c;
        for( d=s, c = 1; isDIGIT(*d) || *d == '_' || (*d == '.' && c--); d++);
        if((*d == ';' || isSPACE(*d)) && *(skipspace(d)) != ',') {
            s = scan_num(s);
            /* real VERSION number -- GBARR */
            version = yylval.opval;
        }
    }

    /* NOTE: The parser sees the package name and the VERSION swapped */
    PL_nextval[PL_nexttoke].opval = version;
    force_next(WORD); 

    return (s);
}

STATIC SV *
tokeq(SV *sv)
d525 1
a525 2
    STRLEN len = 0;
    SV *pv = sv;
d528 1
a528 1
	goto finish;
d532 1
a532 1
	goto finish;
d537 1
a537 1
	goto finish;
a538 2
    if ( PL_hints & HINT_NEW_STRING )
	pv = sv_2mortal(newSVpv(SvPVX(pv), len));
d548 1
a548 3
  finish:
    if ( PL_hints & HINT_NEW_STRING )
       return new_constant(NULL, 0, "q", sv, pv, "q");
d552 2
a553 2
STATIC I32
sublex_start(void)
d558 2
a559 2
	yylval.opval = PL_lex_op;
	PL_lex_op = Nullop;
d563 2
a564 15
	SV *sv = tokeq(PL_lex_stuff);

	if (SvTYPE(sv) == SVt_PVIV) {
	    /* Overloaded constants, nothing fancy: Convert to SVt_PV: */
	    STRLEN len;
	    char *p;
	    SV *nsv;

	    p = SvPV(sv, len);
	    nsv = newSVpv(p, len);
	    SvREFCNT_dec(sv);
	    sv = nsv;
	} 
	yylval.opval = (OP*)newSVOP(op_type, 0, sv);
	PL_lex_stuff = Nullsv;
d568 48
a615 9
    PL_sublex_info.super_state = PL_lex_state;
    PL_sublex_info.sub_inwhat = op_type;
    PL_sublex_info.sub_op = PL_lex_op;
    PL_lex_state = LEX_INTERPPUSH;

    PL_expect = XTERM;
    if (PL_lex_op) {
	yylval.opval = PL_lex_op;
	PL_lex_op = Nullop;
d622 2
a623 55
STATIC I32
sublex_push(void)
{
    dTHR;
    ENTER;

    PL_lex_state = PL_sublex_info.super_state;
    SAVEI32(PL_lex_dojoin);
    SAVEI32(PL_lex_brackets);
    SAVEI32(PL_lex_fakebrack);
    SAVEI32(PL_lex_casemods);
    SAVEI32(PL_lex_starts);
    SAVEI32(PL_lex_state);
    SAVESPTR(PL_lex_inpat);
    SAVEI32(PL_lex_inwhat);
    SAVEI16(PL_curcop->cop_line);
    SAVEPPTR(PL_bufptr);
    SAVEPPTR(PL_oldbufptr);
    SAVEPPTR(PL_oldoldbufptr);
    SAVEPPTR(PL_linestart);
    SAVESPTR(PL_linestr);
    SAVEPPTR(PL_lex_brackstack);
    SAVEPPTR(PL_lex_casestack);

    PL_linestr = PL_lex_stuff;
    PL_lex_stuff = Nullsv;

    PL_bufend = PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart = SvPVX(PL_linestr);
    PL_bufend += SvCUR(PL_linestr);
    SAVEFREESV(PL_linestr);

    PL_lex_dojoin = FALSE;
    PL_lex_brackets = 0;
    PL_lex_fakebrack = 0;
    New(899, PL_lex_brackstack, 120, char);
    New(899, PL_lex_casestack, 12, char);
    SAVEFREEPV(PL_lex_brackstack);
    SAVEFREEPV(PL_lex_casestack);
    PL_lex_casemods = 0;
    *PL_lex_casestack = '\0';
    PL_lex_starts = 0;
    PL_lex_state = LEX_INTERPCONCAT;
    PL_curcop->cop_line = PL_multi_start;

    PL_lex_inwhat = PL_sublex_info.sub_inwhat;
    if (PL_lex_inwhat == OP_MATCH || PL_lex_inwhat == OP_QR || PL_lex_inwhat == OP_SUBST)
	PL_lex_inpat = PL_sublex_info.sub_op;
    else
	PL_lex_inpat = Nullop;

    return '(';
}

STATIC I32
sublex_done(void)
d625 2
a626 2
    if (!PL_lex_starts++) {
	PL_expect = XOPERATOR;
d631 2
a632 2
    if (PL_lex_casemods) {		/* oops, we've got some unbalanced parens */
	PL_lex_state = LEX_INTERPCASEMOD;
d637 15
a651 15
    if (PL_lex_repl && (PL_lex_inwhat == OP_SUBST || PL_lex_inwhat == OP_TRANS)) {
	PL_linestr = PL_lex_repl;
	PL_lex_inpat = 0;
	PL_bufend = PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart = SvPVX(PL_linestr);
	PL_bufend += SvCUR(PL_linestr);
	SAVEFREESV(PL_linestr);
	PL_lex_dojoin = FALSE;
	PL_lex_brackets = 0;
	PL_lex_fakebrack = 0;
	PL_lex_casemods = 0;
	*PL_lex_casestack = '\0';
	PL_lex_starts = 0;
	if (SvCOMPILED(PL_lex_repl)) {
	    PL_lex_state = LEX_INTERPNORMAL;
	    PL_lex_starts++;
d654 2
a655 2
	    PL_lex_state = LEX_INTERPCONCAT;
	PL_lex_repl = Nullsv;
d659 4
a662 4
	LEAVE;
	PL_bufend = SvPVX(PL_linestr);
	PL_bufend += SvCUR(PL_linestr);
	PL_expect = XOPERATOR;
d667 16
a682 88
/*
  scan_const

  Extracts a pattern, double-quoted string, or transliteration.  This
  is terrifying code.

  It looks at lex_inwhat and PL_lex_inpat to find out whether it's
  processing a pattern (PL_lex_inpat is true), a transliteration
  (lex_inwhat & OP_TRANS is true), or a double-quoted string.

  Returns a pointer to the character scanned up to. Iff this is
  advanced from the start pointer supplied (ie if anything was
  successfully parsed), will leave an OP for the substring scanned
  in yylval. Caller must intuit reason for not parsing further
  by looking at the next characters herself.

  In patterns:
    backslashes:
      double-quoted style: \r and \n
      regexp special ones: \D \s
      constants: \x3
      backrefs: \1 (deprecated in substitution replacements)
      case and quoting: \U \Q \E
    stops on @@ and $, but not for $ as tail anchor

  In transliterations:
    characters are VERY literal, except for - not at the start or end
    of the string, which indicates a range.  scan_const expands the
    range to the full set of intermediate characters.

  In double-quoted strings:
    backslashes:
      double-quoted style: \r and \n
      constants: \x3
      backrefs: \1 (deprecated)
      case and quoting: \U \Q \E
    stops on @@ and $

  scan_const does *not* construct ops to handle interpolated strings.
  It stops processing as soon as it finds an embedded $ or @@ variable
  and leaves it to the caller to work out what's going on.

  @@ in pattern could be: @@foo, @@{foo}, @@$foo, @@'foo, @@:foo.

  $ in pattern could be $foo or could be tail anchor.  Assumption:
  it's a tail anchor if $ is the last thing in the string, or if it's
  followed by one of ")| \n\t"

  \1 (backreferences) are turned into $1

  The structure of the code is
      while (there's a character to process) {
          handle transliteration ranges
	  skip regexp comments
	  skip # initiated comments in //x patterns
	  check for embedded @@foo
	  check for embedded scalars
	  if (backslash) {
	      leave intact backslashes from leave (below)
	      deprecate \1 in strings and sub replacements
	      handle string-changing backslashes \l \U \Q \E, etc.
	      switch (what was escaped) {
	          handle - in a transliteration (becomes a literal -)
		  handle \132 octal characters
		  handle 0x15 hex characters
		  handle \cV (control V)
		  handle printf backslashes (\f, \r, \n, etc)
	      } (end switch)
	  } (end if backslash)
    } (end while character to read)
		  
*/

STATIC char *
scan_const(char *start)
{
    register char *send = PL_bufend;		/* end of the constant */
    SV *sv = NEWSV(93, send - start);		/* sv for the constant */
    register char *s = start;			/* start of the constant */
    register char *d = SvPVX(sv);		/* destination for copies */
    bool dorange = FALSE;			/* are we in a translit range? */
    I32 len;					/* ? */

    /* leaveit is the set of acceptably-backslashed characters */
    char *leaveit =
	PL_lex_inpat
	    ? "\\.^$@@AGZdDwWsSbB+*?|()-nrtfeaxcz0123456789[{]} \t\n\r\f\v#"
	    : "";
d685 1
a685 3
        /* get transliterations out of the way (they're most literal) */
	if (PL_lex_inwhat == OP_TRANS) {
	    /* expand a range A-Z to the full set of characters.  AIE! */
d687 9
a695 31
		I32 i;				/* current expanded character */
		I32 min;			/* first character in range */
		I32 max;			/* last character in range */

		i = d - SvPVX(sv);		/* remember current offset */
		SvGROW(sv, SvLEN(sv) + 256);	/* expand the sv -- there'll never be more'n 256 chars in a range for it to grow by */
		d = SvPVX(sv) + i;		/* restore d after the grow potentially has changed the ptr */
		d -= 2;				/* eat the first char and the - */

		min = (U8)*d;			/* first char in range */
		max = (U8)d[1];			/* last char in range  */

#ifndef ASCIIish
		if ((isLOWER(min) && isLOWER(max)) ||
		    (isUPPER(min) && isUPPER(max))) {
		    if (isLOWER(min)) {
			for (i = min; i <= max; i++)
			    if (isLOWER(i))
				*d++ = i;
		    } else {
			for (i = min; i <= max; i++)
			    if (isUPPER(i))
				*d++ = i;
		    }
		}
		else
#endif
		    for (i = min; i <= max; i++)
			*d++ = i;

		/* mark the range as done, and continue */
a698 2

	    /* range begins (ignore - as first or last char) */
d704 3
a706 29

	/* if we get here, we're not doing a transliteration */

	/* skip for regexp comments /(?#comment)/ */
	else if (*s == '(' && PL_lex_inpat && s[1] == '?') {
	    if (s[2] == '#') {
		while (s < send && *s != ')')
		    *d++ = *s++;
	    } else if (s[2] == '{') {	/* This should march regcomp.c */
		I32 count = 1;
		char *regparse = s + 3;
		char c;

		while (count && (c = *regparse)) {
		    if (c == '\\' && regparse[1])
			regparse++;
		    else if (c == '{') 
			count++;
		    else if (c == '}') 
			count--;
		    regparse++;
		}
		if (*regparse == ')')
		    regparse++;
		else
		    yyerror("Sequence (?{...}) not terminated or not {}-balanced");
		while (s < regparse && *s != ')')
		    *d++ = *s++;
	    }
d708 2
a709 4

	/* likewise skip #-initiated comments in //x patterns */
	else if (*s == '#' && PL_lex_inpat &&
	  ((PMOP*)PL_lex_inpat)->op_pmflags & PMf_EXTENDED) {
a712 2

	/* check for embedded arrays (@@foo, @@:foo, @@'foo, @@{foo}, @@$foo) */
a714 4

	/* check for embedded scalars.  only stop if we're sure it's a
	   variable.
        */
d716 1
a716 1
	    if (!PL_lex_inpat)	/* not a regexp, so $ must be var */
d718 1
a718 1
	    if (s + 1 < send && !strchr("()| \n\t", s[1]))
a720 2

	/* backslashes */
d723 1
a723 3

	    /* some backslashes we leave behind */
	    if (*s && strchr(leaveit, *s)) {
d728 1
a728 3

	    /* deprecate \1 in strings and substitution replacements */
	    if (PL_lex_inwhat == OP_SUBST && !PL_lex_inpat &&
d731 1
a731 1
		if (PL_dowarn)
d736 1
a736 3

	    /* string-change backslash escapes */
	    if (PL_lex_inwhat != OP_TRANS && *s && strchr("lLuUEQ", *s)) {
a739 2

	    /* if we get here, it's either a quoted -, or a digit */
a740 2

	    /* quoted - in transliterations */
d742 1
a742 1
		if (PL_lex_inwhat == OP_TRANS) {
a746 1
	    /* default action is to copy the quoted character */
a749 2

	    /* \132 indicates an octal constant */
a754 2

	    /* \x24 indicates a hex constant */
a758 2

	    /* \c is a control character */
a760 1
#ifdef EBCDIC
d763 2
a764 6
		   *d = toUPPER(*d);
		*d++ = toCTRL(*d); 
#else
		len = *s++;
		*d++ = toCTRL(len);
#endif
a765 2

	    /* printf-style backslashes, formfeeds, newlines, etc */
d787 1
a787 2
	    } /* end switch */

d790 1
a790 2
	} /* end if (backslash) */

d792 1
a792 3
    } /* while loop to process each character */

    /* terminate the string and set up the sv */
a796 1
    /* shrink the sv if we allocated more than we used */
d801 1
a801 11

    /* return the substring (via yylval) only if we parsed anything */
    if (s > PL_bufptr) {
	if ( PL_hints & ( PL_lex_inpat ? HINT_NEW_RE : HINT_NEW_STRING ) )
	    sv = new_constant(start, s - start, (PL_lex_inpat ? "qr" : "q"), 
			      sv, Nullsv,
			      ( PL_lex_inwhat == OP_TRANS 
				? "tr"
				: ( (PL_lex_inwhat == OP_SUBST && !PL_lex_inpat)
				    ? "s"
				    : "qq")));
d803 1
a803 1
    } else
d809 3
a811 2
STATIC int
intuit_more(register char *s)
d813 1
a813 1
    if (PL_lex_brackets)
d819 1
a819 1
    if (!PL_lex_inpat)
d847 1
a847 1
	unsigned char un_char = 255, last_un_char;
d849 1
a849 1
	char tmpbuf[sizeof PL_tokenbuf * 4];
d874 1
a874 1
		    scan_ident(s, send, tmpbuf, sizeof tmpbuf, FALSE);
a912 2
		if (last_un_char == 255 && (isDIGIT(s[1]) || s[1] == '$'))
		    weight -= 5;	/* cope with negative subscript */
d938 4
a941 2
STATIC int
intuit_method(char *start, GV *gv)
d944 1
a944 1
    char tmpbuf[sizeof PL_tokenbuf];
a948 1
	CV *cv;
d951 1
a951 9
	if ((cv = GvCVu(gv))) {
	    char *proto = SvPVX(cv);
	    if (proto) {
		if (*proto == ';')
		    proto++;
		if (*proto == '*')
		    return 0;
	    }
	} else
d954 1
a954 1
    s = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
d956 1
a956 1
	if (gv || PL_last_lop_op == OP_PRINT || isUPPER(*PL_tokenbuf))
d959 2
a960 2
	PL_bufptr = start;
	PL_expect = XREF;
d964 2
a965 7
	if (len > 2 && tmpbuf[len - 2] == ':' && tmpbuf[len - 1] == ':') {
	    len -= 2;
	    tmpbuf[len] = '\0';
	    goto bare_package;
	}
	indirgv = gv_fetchpv(tmpbuf, FALSE, SVt_PVCV);
	if (indirgv && GvCVu(indirgv))
d968 1
a968 1
	if (!gv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, FALSE)) {
d970 6
a975 7
	    if ((PL_bufend - s) >= 2 && *s == '=' && *(s+1) == '>')
		return 0;	/* no assumptions -- "=>" quotes bearword */
      bare_package:
	    PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0,
						   newSVpv(tmpbuf,0));
	    PL_nextval[PL_nexttoke].opval->op_private = OPpCONST_BARE;
	    PL_expect = XTERM;
d977 1
a977 1
	    PL_bufptr = s;
d984 2
a985 2
STATIC char*
incl_perldb(void)
d987 2
a988 2
    if (PL_perldb) {
	char *pdb = PerlEnv_getenv("PERL5DB");
a991 1
	SETERRNO(0,SS$_NORMAL);
a1012 1
#ifndef PERL_OBJECT
a1013 1
#endif
d1016 3
a1018 1
filter_add(filter_t funcp, SV *datasv)
d1024 2
a1025 2
    if (!PL_rsfp_filters)
	PL_rsfp_filters = newAV();
d1027 1
a1027 1
	datasv = NEWSV(255,0);
d1031 4
a1034 6
    if (filter_debug) {
	STRLEN n_a;
	warn("filter_add func %p (%s)", funcp, SvPV(datasv,n_a));
    }
    av_unshift(PL_rsfp_filters, 1);
    av_store(PL_rsfp_filters, 0, datasv) ;
d1041 2
a1042 1
filter_del(filter_t funcp)
d1045 2
a1046 2
	warn("filter_del func %p", funcp);
    if (!PL_rsfp_filters || AvFILLp(PL_rsfp_filters)<0)
d1049 3
a1051 2
    if (IoDIRP(FILTER_DATA(AvFILLp(PL_rsfp_filters))) == (DIR*)funcp){
	sv_free(av_pop(PL_rsfp_filters));
d1062 4
a1065 4
filter_read(int idx, SV *buf_sv, int maxlen)
            
               
               		/* 0 = read one text line */
d1070 1
a1070 1
    if (!PL_rsfp_filters)
d1072 1
a1072 1
    if (idx > AvFILLp(PL_rsfp_filters)){       /* Any more filters?	*/
d1084 2
a1085 2
	    if ((len = PerlIO_read(PL_rsfp, SvPVX(buf_sv) + old_len, maxlen)) <= 0){
		if (PerlIO_error(PL_rsfp))
d1093 2
a1094 2
            if (sv_gets(buf_sv, PL_rsfp, SvCUR(buf_sv)) == NULL) {
		if (PerlIO_error(PL_rsfp))
d1103 1
a1103 1
    if ( (datasv = FILTER_DATA(idx)) == &PL_sv_undef){
d1110 3
a1112 5
    if (filter_debug) {
	STRLEN n_a;
	warn("filter_read %d: via function %p (%s)\n",
		idx, funcp, SvPV(datasv,n_a));
    }
d1116 1
a1116 1
    return (*funcp)(PERL_OBJECT_THIS_ idx, buf_sv, maxlen);
d1119 4
a1122 2
STATIC char *
filter_gets(register SV *sv, register PerlIO *fp, STRLEN append)
d1124 1
a1124 6
#ifdef WIN32FILTER
    if (!PL_rsfp_filters) {
	filter_add(win32_textfilter,NULL);
    }
#endif
    if (PL_rsfp_filters) {
d1126 1
a1126 2
	if (!append)
            SvCUR_set(sv, 0);	/* start with empty line	*/
d1132 3
a1134 2
    else
        return (sv_gets(sv, fp, append));
d1143 1
a1143 26
EXT int yychar;		/* last token */

/*
  yylex

  Works out what to call the token just pulled out of the input
  stream.  The yacc parser takes care of taking the ops we return and
  stitching them into a tree.

  Returns:
    PRIVATEREF

  Structure:
      if read an identifier
          if we're in a my declaration
	      croak if they tried to say my($foo::bar)
	      build the ops for a my() declaration
	  if it's an access to a my() variable
	      are we in a sort block?
	          croak if my($a); $a <=> $b
	      build ops for access to a my() variable
	  if in a dq string, and they've said @@foo and we can't find @@foo
	      croak
	  build ops for a bareword
      if we already built the token before, use it.
*/
d1146 1
a1146 1
yylex(void)
a1147 1
    dTHR;
a1151 71
    GV *gv = Nullgv;
    GV **gvp = 0;

    /* check if there's an identifier for us to look at */
    if (PL_pending_ident) {
        /* pit holds the identifier we read and pending_ident is reset */
	char pit = PL_pending_ident;
	PL_pending_ident = 0;

	/* if we're in a my(), we can't allow dynamics here.
	   $foo'bar has already been turned into $foo::bar, so
	   just check for colons.

	   if it's a legal name, the OP is a PADANY.
	*/
	if (PL_in_my) {
	    if (strchr(PL_tokenbuf,':'))
		croak(no_myglob,PL_tokenbuf);

	    yylval.opval = newOP(OP_PADANY, 0);
	    yylval.opval->op_targ = pad_allocmy(PL_tokenbuf);
	    return PRIVATEREF;
	}

	/* 
	   build the ops for accesses to a my() variable.

	   Deny my($a) or my($b) in a sort block, *if* $a or $b is
	   then used in a comparison.  This catches most, but not
	   all cases.  For instance, it catches
	       sort { my($a); $a <=> $b }
	   but not
	       sort { my($a); $a < $b ? -1 : $a == $b ? 0 : 1; }
	   (although why you'd do that is anyone's guess).
	*/

	if (!strchr(PL_tokenbuf,':')) {
#ifdef USE_THREADS
	    /* Check for single character per-thread SVs */
	    if (PL_tokenbuf[0] == '$' && PL_tokenbuf[2] == '\0'
		&& !isALPHA(PL_tokenbuf[1]) /* Rule out obvious non-threadsvs */
		&& (tmp = find_threadsv(&PL_tokenbuf[1])) != NOT_IN_PAD)
	    {
		yylval.opval = newOP(OP_THREADSV, 0);
		yylval.opval->op_targ = tmp;
		return PRIVATEREF;
	    }
#endif /* USE_THREADS */
	    if ((tmp = pad_findmy(PL_tokenbuf)) != NOT_IN_PAD) {
		/* if it's a sort block and they're naming $a or $b */
		if (PL_last_lop_op == OP_SORT &&
		    PL_tokenbuf[0] == '$' &&
		    (PL_tokenbuf[1] == 'a' || PL_tokenbuf[1] == 'b')
		    && !PL_tokenbuf[2])
		{
		    for (d = PL_in_eval ? PL_oldoldbufptr : PL_linestart;
			 d < PL_bufend && *d != '\n';
			 d++)
		    {
			if (strnEQ(d,"<=>",3) || strnEQ(d,"cmp",3)) {
			    croak("Can't use \"my %s\" in sort comparison",
				  PL_tokenbuf);
			}
		    }
		}

		yylval.opval = newOP(OP_PADANY, 0);
		yylval.opval->op_targ = tmp;
		return PRIVATEREF;
	    }
	}
d1153 1
a1153 25
	/*
	   Whine if they've said @@foo in a doublequoted string,
	   and @@foo isn't a variable we can find in the symbol
	   table.
	*/
	if (pit == '@@' && PL_lex_state != LEX_NORMAL && !PL_lex_brackets) {
	    GV *gv = gv_fetchpv(PL_tokenbuf+1, FALSE, SVt_PVAV);
	    if (!gv || ((PL_tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
		yyerror(form("In string, %s now must be written as \\%s",
			     PL_tokenbuf, PL_tokenbuf));
	}

	/* build ops for a bareword */
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(PL_tokenbuf+1, 0));
	yylval.opval->op_private = OPpCONST_ENTERED;
	gv_fetchpv(PL_tokenbuf+1, PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : TRUE,
		   ((PL_tokenbuf[0] == '$') ? SVt_PV
		    : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
		    : SVt_PVHV));
	return WORD;
    }

    /* no identifier pending identification */

    switch (PL_lex_state) {
a1159 1
    /* when we're already built the next token, just pull it out the queue */
d1161 9
a1169 12
	PL_nexttoke--;
	yylval = PL_nextval[PL_nexttoke];
	if (!PL_nexttoke) {
	    PL_lex_state = PL_lex_defer;
	    PL_expect = PL_lex_expect;
	    PL_lex_defer = LEX_NORMAL;
	}
	return(PL_nexttype[PL_nexttoke]);

    /* interpolated case modifiers like \L \U, including \Q and \E.
       when we get here, PL_bufptr is at the \
    */
d1172 1
a1172 1
	if (PL_bufptr != PL_bufend && *PL_bufptr != '\\')
d1175 1
a1175 2
	/* handle \E or end of string */
       	if (PL_bufptr == PL_bufend || PL_bufptr[1] == 'E') {
d1177 6
a1182 9

	    /* if at a \E */
	    if (PL_lex_casemods) {
		oldmod = PL_lex_casestack[--PL_lex_casemods];
		PL_lex_casestack[PL_lex_casemods] = '\0';

		if (PL_bufptr != PL_bufend && strchr("LUQ", oldmod)) {
		    PL_bufptr += 2;
		    PL_lex_state = LEX_INTERPCONCAT;
d1186 3
a1188 3
	    if (PL_bufptr != PL_bufend)
		PL_bufptr += 2;
	    PL_lex_state = LEX_INTERPCONCAT;
d1192 1
a1192 1
	    s = PL_bufptr + 1;
d1196 1
a1196 1
		(strchr(PL_lex_casestack, 'L') || strchr(PL_lex_casestack, 'U')))
d1198 1
a1198 1
		PL_lex_casestack[--PL_lex_casemods] = '\0';
d1201 3
a1203 3
	    if (PL_lex_casemods > 10) {
		char* newlb = Renew(PL_lex_casestack, PL_lex_casemods + 2, char);
		if (newlb != PL_lex_casestack) {
d1205 1
a1205 1
		    PL_lex_casestack = newlb;
d1208 4
a1211 4
	    PL_lex_casestack[PL_lex_casemods++] = *s;
	    PL_lex_casestack[PL_lex_casemods] = '\0';
	    PL_lex_state = LEX_INTERPCONCAT;
	    PL_nextval[PL_nexttoke].ival = 0;
d1214 1
a1214 1
		PL_nextval[PL_nexttoke].ival = OP_LCFIRST;
d1216 1
a1216 1
		PL_nextval[PL_nexttoke].ival = OP_UCFIRST;
d1218 1
a1218 1
		PL_nextval[PL_nexttoke].ival = OP_LC;
d1220 1
a1220 1
		PL_nextval[PL_nexttoke].ival = OP_UC;
d1222 1
a1222 1
		PL_nextval[PL_nexttoke].ival = OP_QUOTEMETA;
d1225 1
a1225 1
	    PL_bufptr = s + 1;
d1227 3
a1229 3
	    if (PL_lex_starts) {
		s = PL_bufptr;
		PL_lex_starts = 0;
a1235 3
    case LEX_INTERPPUSH:
        return sublex_push();

d1237 1
a1237 1
	if (PL_bufptr == PL_bufend)
d1239 5
a1243 5
	PL_expect = XTERM;
	PL_lex_dojoin = (*PL_bufptr == '@@');
	PL_lex_state = LEX_INTERPNORMAL;
	if (PL_lex_dojoin) {
	    PL_nextval[PL_nexttoke].ival = 0;
a1244 5
#ifdef USE_THREADS
	    PL_nextval[PL_nexttoke].opval = newOP(OP_THREADSV, 0);
	    PL_nextval[PL_nexttoke].opval->op_targ = find_threadsv("\"");
	    force_next(PRIVATEREF);
#else
d1246 1
a1246 2
#endif /* USE_THREADS */
	    PL_nextval[PL_nexttoke].ival = 0;
d1248 1
a1248 1
	    PL_nextval[PL_nexttoke].ival = 0;
d1250 1
a1250 1
	    PL_nextval[PL_nexttoke].ival = OP_JOIN;	/* emulate join($", ...) */
d1253 2
a1254 2
	if (PL_lex_starts++) {
	    s = PL_bufptr;
d1257 3
a1259 1
	return yylex();
d1262 2
a1263 2
	if (intuit_more(PL_bufptr)) {
	    PL_lex_state = LEX_INTERPNORMAL;	/* false alarm, more expr */
d1269 3
a1271 3
	if (PL_lex_dojoin) {
	    PL_lex_dojoin = FALSE;
	    PL_lex_state = LEX_INTERPCONCAT;
d1277 1
a1277 1
	if (PL_lex_brackets)
d1280 1
a1280 1
	if (PL_bufptr == PL_bufend)
d1283 4
a1286 6
	if (SvIVX(PL_linestr) == '\'') {
	    SV *sv = newSVsv(PL_linestr);
	    if (!PL_lex_inpat)
		sv = tokeq(sv);
	    else if ( PL_hints & HINT_NEW_RE )
		sv = new_constant(NULL, 0, "qr", sv, sv, "q");
d1288 1
a1288 1
	    s = PL_bufend;
d1291 1
a1291 1
	    s = scan_const(PL_bufptr);
d1293 1
a1293 1
		PL_lex_state = LEX_INTERPCASEMOD;
d1295 1
a1295 1
		PL_lex_state = LEX_INTERPSTART;
d1298 3
a1300 3
	if (s != PL_bufptr) {
	    PL_nextval[PL_nexttoke] = yylval;
	    PL_expect = XTERM;
d1302 1
a1302 1
	    if (PL_lex_starts++)
d1305 1
a1305 1
		PL_bufptr = s;
d1312 3
a1314 3
	PL_lex_state = LEX_NORMAL;
	s = scan_formline(PL_bufptr);
	if (!PL_lex_formbrack)
d1319 3
a1321 3
    s = PL_bufptr;
    PL_oldoldbufptr = PL_oldbufptr;
    PL_oldbufptr = s;
d1323 1
a1323 1
	PerlIO_printf(PerlIO_stderr(), "### Tokener expecting %s at %s\n", exp_name[PL_expect], s);
d1329 2
a1330 1
	croak("Unrecognized character \\%03o", *s & 255);
d1335 2
a1336 4
	if (!PL_rsfp) {
	    PL_last_uni = 0;
	    PL_last_lop = 0;
	    if (PL_lex_brackets)
d1340 1
a1340 1
	if (s++ < PL_bufend)
d1342 12
a1353 12
	PL_last_uni = 0;
	PL_last_lop = 0;
	if (!PL_in_eval && !PL_preambled) {
	    PL_preambled = TRUE;
	    sv_setpv(PL_linestr,incl_perldb());
	    if (SvCUR(PL_linestr))
		sv_catpv(PL_linestr,";");
	    if (PL_preambleav){
		while(AvFILLp(PL_preambleav) >= 0) {
		    SV *tmpsv = av_shift(PL_preambleav);
		    sv_catsv(PL_linestr, tmpsv);
		    sv_catpv(PL_linestr, ";");
d1356 2
a1357 2
		sv_free((SV*)PL_preambleav);
		PL_preambleav = NULL;
d1359 14
a1372 26
	    if (PL_minus_n || PL_minus_p) {
		sv_catpv(PL_linestr, "LINE: while (<>) {");
		if (PL_minus_l)
		    sv_catpv(PL_linestr,"chomp;");
		if (PL_minus_a) {
		    GV* gv = gv_fetchpv("::F", TRUE, SVt_PVAV);
		    if (gv)
			GvIMPORTED_AV_on(gv);
		    if (PL_minus_F) {
			if (strchr("/'\"", *PL_splitstr)
			      && strchr(PL_splitstr + 1, *PL_splitstr))
			    sv_catpvf(PL_linestr, "@@F=split(%s);", PL_splitstr);
			else {
			    char delim;
			    s = "'~#\200\1'"; /* surely one char is unused...*/
			    while (s[1] && strchr(PL_splitstr, *s))  s++;
			    delim = *s;
			    sv_catpvf(PL_linestr, "@@F=split(%s%c",
				      "q" + (delim == '\''), delim);
			    for (s = PL_splitstr; *s; s++) {
				if (*s == '\\')
				    sv_catpvn(PL_linestr, "\\", 1);
				sv_catpvn(PL_linestr, s, 1);
			    }
			    sv_catpvf(PL_linestr, "%c);", delim);
			}
d1375 1
a1375 1
		        sv_catpv(PL_linestr,"@@F=split(' ');");
d1378 4
a1381 4
	    sv_catpv(PL_linestr, "\n");
	    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
	    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	    if (PERLDB_LINE && PL_curstash != PL_debstash) {
d1385 2
a1386 2
		sv_setsv(sv,PL_linestr);
		av_store(GvAV(PL_curcop->cop_filegv),(I32)PL_curcop->cop_line,sv);
d1391 1
a1391 1
	    if ((s = filter_gets(PL_linestr, PL_rsfp, 0)) == Nullch) {
d1393 5
a1397 5
		if (PL_rsfp) {
		    if (PL_preprocess && !PL_in_eval)
			(void)PerlProc_pclose(PL_rsfp);
		    else if ((PerlIO *)PL_rsfp == PerlIO_stdin())
			PerlIO_clearerr(PL_rsfp);
d1399 9
a1407 10
			(void)PerlIO_close(PL_rsfp);
		    PL_rsfp = Nullfp;
		    PL_doextract = FALSE;
		}
		if (!PL_in_eval && (PL_minus_n || PL_minus_p)) {
		    sv_setpv(PL_linestr,PL_minus_p ? ";}continue{print" : "");
		    sv_catpv(PL_linestr,";}");
		    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
		    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
		    PL_minus_n = PL_minus_p = 0;
d1410 2
a1411 2
		PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
		sv_setpv(PL_linestr,"");
d1414 1
a1414 1
	    if (PL_doextract) {
d1416 1
a1416 1
		    PL_doextract = FALSE;
d1420 4
a1423 4
		    sv_setpv(PL_linestr, "");
		    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
		    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
		    PL_doextract = FALSE;
d1427 3
a1429 3
	} while (PL_doextract);
	PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = s;
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
d1433 2
a1434 2
	    sv_setsv(sv,PL_linestr);
	    av_store(GvAV(PL_curcop->cop_filegv),(I32)PL_curcop->cop_line,sv);
d1436 3
a1438 3
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
	if (PL_curcop->cop_line == 1) {
	    while (s < PL_bufend && isSPACE(*s))
d1442 1
a1442 44
	    d = Nullch;
	    if (!PL_in_eval) {
		if (*s == '#' && *(s+1) == '!')
		    d = s + 2;
#ifdef ALTERNATE_SHEBANG
		else {
		    static char as[] = ALTERNATE_SHEBANG;
		    if (*s == as[0] && strnEQ(s, as, sizeof(as) - 1))
			d = s + (sizeof(as) - 1);
		}
#endif /* ALTERNATE_SHEBANG */
	    }
	    if (d) {
		char *ipath;
		char *ipathend;

		while (isSPACE(*d))
		    d++;
		ipath = d;
		while (*d && !isSPACE(*d))
		    d++;
		ipathend = d;

#ifdef ARG_ZERO_IS_SCRIPT
		if (ipathend > ipath) {
		    /*
		     * HP-UX (at least) sets argv[0] to the script name,
		     * which makes $^X incorrect.  And Digital UNIX and Linux,
		     * at least, set argv[0] to the basename of the Perl
		     * interpreter. So, having found "#!", we'll set it right.
		     */
		    SV *x = GvSV(gv_fetchpv("\030", TRUE, SVt_PV));
		    assert(SvPOK(x) || SvGMAGICAL(x));
		    if (sv_eq(x, GvSV(PL_curcop->cop_filegv))) {
			sv_setpvn(x, ipath, ipathend - ipath);
			SvSETMAGIC(x);
		    }
		    TAINT_NOT;	/* $^X is always tainted, but that's OK */
		}
#endif /* ARG_ZERO_IS_SCRIPT */

		/*
		 * Look for options.
		 */
a1445 20
#ifdef ALTERNATE_SHEBANG
		/*
		 * If the ALTERNATE_SHEBANG on this system starts with a
		 * character that can be part of a Perl expression, then if
		 * we see it but not "perl", we're probably looking at the
		 * start of Perl code, not a request to hand off to some
		 * other interpreter.  Similarly, if "perl" is there, but
		 * not in the first 'word' of the line, we assume the line
		 * contains the start of the Perl program.
		 */
		if (d && *s != '#') {
		    char *c = ipath;
		    while (*c && !strchr("; \t\r\n\f\v#", *c))
			c++;
		    if (c < d)
			d = Nullch;	/* "perl" not in first word; ignore */
		    else
			*s = '#';	/* Don't try to parse shebang line */
		}
#endif /* ALTERNATE_SHEBANG */
d1447 1
a1447 3
		    *s == '#' &&
		    ipathend > ipath &&
		    !PL_minus_c &&
d1449 1
a1449 1
		    instr(PL_origargv[0],"perl"))
d1452 1
d1454 2
a1455 3
		    *ipathend = '\0';
		    s = ipathend + 1;
		    while (s < PL_bufend && isSPACE(*s))
d1457 8
a1464 2
		    if (s < PL_bufend) {
			Newz(899,newargv,PL_origargc+3,char*);
d1466 1
a1466 1
			while (s < PL_bufend && !isSPACE(*s))
d1469 1
a1469 1
			Copy(PL_origargv+1, newargv+2, PL_origargc+1, char*);
d1472 4
a1475 4
			newargv = PL_origargv;
		    newargv[0] = ipath;
		    PerlProc_execv(ipath, newargv);
		    croak("Can't exec %s", ipath);
d1478 3
a1480 3
		    U32 oldpdb = PL_perldb;
		    bool oldn = PL_minus_n;
		    bool oldp = PL_minus_p;
d1483 1
a1483 1
		    while (*d == ' ' || *d == '\t') d++;
d1486 3
a1488 11
			do {
			    if (*d == 'M' || *d == 'm') {
				char *m = d;
				while (*d && !isSPACE(*d)) d++;
				croak("Too late for \"-%.*s\" option",
				      (int)(d - m), m);
			    }
			    d = moreswitches(d);
			} while (d);
			if (PERLDB_LINE && !oldpdb ||
			    ( PL_minus_n || PL_minus_p ) && !(oldn || oldp) )
d1492 6
a1497 6
			    sv_setpv(PL_linestr, "");
			    PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = SvPVX(PL_linestr);
			    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
			    PL_preambled = FALSE;
			    if (PERLDB_LINE)
				(void)gv_fetchfile(PL_origfilename);
d1504 3
a1506 3
	if (PL_lex_formbrack && PL_lex_brackets <= PL_lex_formbrack) {
	    PL_bufptr = s;
	    PL_lex_state = LEX_FORMLINE;
d1510 1
a1510 7
    case '\r':
#ifdef PERL_STRICT_CR
	warn("Illegal character \\%03o (carriage return)", '\r');
	croak(
      "(Maybe you didn't strip carriage returns after a network transfer?)\n");
#endif
    case ' ': case '\t': case '\f': case 013:
d1515 2
a1516 2
	if (PL_lex_state != LEX_NORMAL || (PL_in_eval && !PL_rsfp)) {
	    d = PL_bufend;
d1522 3
a1524 3
	    if (PL_lex_formbrack && PL_lex_brackets <= PL_lex_formbrack) {
		PL_bufptr = s;
		PL_lex_state = LEX_FORMLINE;
d1530 1
a1530 1
	    PL_bufend = s;
d1536 1
a1536 1
	    PL_bufptr = s;
d1539 1
a1539 1
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
d1543 4
a1546 1
		s = force_word(PL_bufptr,WORD,FALSE,FALSE,FALSE);
d1549 2
a1550 2
	    PL_last_uni = PL_oldbufptr;
	    PL_last_lop_op = OP_FTEREAD;	/* good enough */
d1580 1
a1580 1
		croak("Unrecognized file test: -%c", (int)tmp);
d1587 1
a1587 1
	    if (PL_expect == XOPERATOR)
d1604 1
a1604 1
	if (PL_expect == XOPERATOR)
d1607 1
a1607 1
	    if (isSPACE(*s) || !isSPACE(*PL_bufptr))
d1616 1
a1616 1
	    if (PL_expect == XOPERATOR)
d1621 1
a1621 1
	if (PL_expect == XOPERATOR)
d1624 1
a1624 1
	    if (isSPACE(*s) || !isSPACE(*PL_bufptr))
d1630 5
a1634 5
	if (PL_expect != XOPERATOR) {
	    s = scan_ident(s, PL_bufend, PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
	    PL_expect = XOPERATOR;
	    force_ident(PL_tokenbuf, '*');
	    if (!*PL_tokenbuf)
d1646 26
a1671 10
	if (PL_expect == XOPERATOR) {
	    ++s;
	    Mop(OP_MODULO);
	}
	PL_tokenbuf[0] = '%';
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, TRUE);
	if (!PL_tokenbuf[1]) {
	    if (s == PL_bufend)
		yyerror("Final % should be \\% or %name");
	    PREREF('%');
d1673 2
a1674 2
	PL_pending_ident = '%';
	TERM('%');
d1680 1
a1680 1
	PL_lex_brackets++;
d1695 2
a1696 2
	if (PL_last_lop == PL_oldoldbufptr || PL_last_uni == PL_oldoldbufptr)
	    PL_oldbufptr = PL_oldoldbufptr;		/* allow print(STDOUT 123) */
d1698 1
a1698 1
	    PL_expect = XTERM;
d1701 2
a1702 2
	if (PL_curcop->cop_line < PL_copline)
	    PL_copline = PL_curcop->cop_line;
d1713 1
a1713 1
	if (PL_lex_brackets <= 0)
d1716 3
a1718 3
	    --PL_lex_brackets;
	if (PL_lex_state == LEX_INTERPNORMAL) {
	    if (PL_lex_brackets == 0) {
d1720 1
a1720 1
		    PL_lex_state = LEX_INTERPEND;
d1727 3
a1729 3
	if (PL_lex_brackets > 100) {
	    char* newlb = Renew(PL_lex_brackstack, PL_lex_brackets + 1, char);
	    if (newlb != PL_lex_brackstack) {
d1731 1
a1731 1
		PL_lex_brackstack = newlb;
d1734 1
a1734 1
	switch (PL_expect) {
d1736 1
a1736 1
	    if (PL_lex_formbrack) {
d1740 2
a1741 2
	    if (PL_oldoldbufptr == PL_last_lop)
		PL_lex_brackstack[PL_lex_brackets++] = XTERM;
d1743 1
a1743 1
		PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d1745 1
d1747 1
a1747 1
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
d1749 3
a1751 12
	    d = s;
	    PL_tokenbuf[0] = '\0';
	    if (d < PL_bufend && *d == '-') {
		PL_tokenbuf[0] = '-';
		d++;
		while (d < PL_bufend && (*d == ' ' || *d == '\t'))
		    d++;
	    }
	    if (d < PL_bufend && isIDFIRST(*d)) {
		d = scan_word(d, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1,
			      FALSE, &len);
		while (d < PL_bufend && (*d == ' ' || *d == '\t'))
d1754 6
a1759 4
		    char minus = (PL_tokenbuf[0] == '-');
		    s = force_word(s + minus, WORD, FALSE, TRUE, FALSE);
		    if (minus)
			force_next('-');
d1764 2
a1765 2
	    PL_lex_brackstack[PL_lex_brackets++] = XSTATE;
	    PL_expect = XSTATE;
d1768 2
a1769 2
	    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
	    PL_expect = XSTATE;
d1773 2
a1774 2
		if (PL_oldoldbufptr == PL_last_lop)
		    PL_lex_brackstack[PL_lex_brackets++] = XTERM;
d1776 1
a1776 1
		    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d1780 2
a1781 22
		/* This hack serves to disambiguate a pair of curlies
		 * as being a block or an anon hash.  Normally, expectation
		 * determines that, but in cases where we're not in a
		 * position to expect anything in particular (like inside
		 * eval"") we have to resolve the ambiguity.  This code
		 * covers the case where the first term in the curlies is a
		 * quoted string.  Most other cases need to be explicitly
		 * disambiguated by prepending a `+' before the opening
		 * curly in order to force resolution as an anon hash.
		 *
		 * XXX should probably propagate the outer expectation
		 * into eval"" to rely less on this hack, but that could
		 * potentially break current behavior of eval"".
		 * GSAR 97-07-21
		 */
		t = s;
		if (*s == '\'' || *s == '"' || *s == '`') {
		    /* common case: get past first string, handling escapes */
		    for (t++; t < PL_bufend && *t != *s;)
			if (*t++ == '\\' && (*t == '\\' || *t == *s))
			    t++;
		    t++;
d1783 4
a1786 34
		else if (*s == 'q') {
		    if (++t < PL_bufend
			&& (!isALNUM(*t)
			    || ((*t == 'q' || *t == 'x') && ++t < PL_bufend
				&& !isALNUM(*t)))) {
			char *tmps;
			char open, close, term;
			I32 brackets = 1;

			while (t < PL_bufend && isSPACE(*t))
			    t++;
			term = *t;
			open = term;
			if (term && (tmps = strchr("([{< )]}> )]}>",term)))
			    term = tmps[5];
			close = term;
			if (open == close)
			    for (t++; t < PL_bufend; t++) {
				if (*t == '\\' && t+1 < PL_bufend && open != '\\')
				    t++;
				else if (*t == open)
				    break;
			    }
			else
			    for (t++; t < PL_bufend; t++) {
				if (*t == '\\' && t+1 < PL_bufend)
				    t++;
				else if (*t == close && --brackets <= 0)
				    break;
				else if (*t == open)
				    brackets++;
			    }
		    }
		    t++;
d1788 3
a1790 4
		else if (isALPHA(*s)) {
		    for (t++; t < PL_bufend && isALNUM(*t); t++) ;
		}
		while (t < PL_bufend && isSPACE(*t))
d1792 1
a1792 4
		/* if comma follows first term, call it an anon hash */
		/* XXX it could be a comma expression with loop modifiers */
		if (t < PL_bufend && ((*t == ',' && (*s == 'q' || !isLOWER(*s)))
				   || (*t == '=' && t[1] == '>')))
d1794 2
a1795 2
		if (PL_expect == XREF)
		    PL_expect = XTERM;
d1797 2
a1798 2
		    PL_lex_brackstack[PL_lex_brackets-1] = XSTATE;
		    PL_expect = XSTATE;
d1803 1
a1803 1
	yylval.ival = PL_curcop->cop_line;
d1805 1
a1805 1
	    PL_copline = NOLINE;   /* invalidate current command line number */
d1810 1
a1810 1
	if (PL_lex_brackets <= 0)
d1813 8
a1820 8
	    PL_expect = (expectation)PL_lex_brackstack[--PL_lex_brackets];
	if (PL_lex_brackets < PL_lex_formbrack)
	    PL_lex_formbrack = 0;
	if (PL_lex_state == LEX_INTERPNORMAL) {
	    if (PL_lex_brackets == 0) {
		if (PL_lex_fakebrack) {
		    PL_lex_state = LEX_INTERPEND;
		    PL_bufptr = s;
d1823 2
a1824 4
		if (*s == '-' && s[1] == '>')
		    PL_lex_state = LEX_INTERPENDMAYBE;
		else if (*s != '[' && *s != '{')
		    PL_lex_state = LEX_INTERPEND;
d1827 3
a1829 3
	if (PL_lex_brackets < PL_lex_fakebrack) {
	    PL_bufptr = s;
	    PL_lex_fakebrack = 0;
d1840 3
a1842 3
	if (PL_expect == XOPERATOR) {
	    if (PL_dowarn && isALPHA(*s) && PL_bufptr == PL_linestart) {
		PL_curcop->cop_line--;
d1844 1
a1844 1
		PL_curcop->cop_line++;
d1849 4
a1852 4
	s = scan_ident(s - 1, PL_bufend, PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
	if (*PL_tokenbuf) {
	    PL_expect = XOPERATOR;
	    force_ident(PL_tokenbuf, '&');
d1875 2
a1876 2
	if (PL_dowarn && tmp && isSPACE(*s) && strchr("+-*/%.^&|<",tmp))
	    warn("Reversed %c= operator",(int)tmp);
d1878 2
a1879 2
	if (PL_expect == XSTATE && isALPHA(tmp) &&
		(s == PL_linestart+1 || s[-2] == '\n') )
d1881 2
a1882 2
	    if (PL_in_eval && !PL_rsfp) {
		d = PL_bufend;
d1899 2
a1900 2
	    s = PL_bufend;
	    PL_doextract = TRUE;
d1903 1
a1903 1
	if (PL_lex_brackets < PL_lex_formbrack) {
a1904 1
#ifdef PERL_STRICT_CR
a1905 3
#else
	    for (t = s; *t == ' ' || *t == '\t' || *t == '\r'; t++) ;
#endif
d1908 1
a1908 1
		PL_expect = XBLOCK;
d1924 1
a1924 1
	if (PL_expect != XOPERATOR) {
d1957 10
a1966 7
	CLINE;

	if (PL_expect == XOPERATOR) {
	    if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack) {
		PL_expect = XTERM;
		depcom();
		return ','; /* grandfather non-comma-format format */
d1968 1
a1968 9
	}

	if (s[1] == '#' && (isALPHA(s[2]) || strchr("_{$:", s[2]))) {
	    if (PL_expect == XOPERATOR)
		no_op("Array length", PL_bufptr);
	    PL_tokenbuf[0] = '@@';
	    s = scan_ident(s + 1, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1,
			   FALSE);
	    if (!PL_tokenbuf[1])
d1970 12
a1981 2
	    PL_expect = XOPERATOR;
	    PL_pending_ident = '#';
d1984 9
a1992 9

	if (PL_expect == XOPERATOR)
	    no_op("Scalar", PL_bufptr);
	PL_tokenbuf[0] = '$';
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, FALSE);
	if (!PL_tokenbuf[1]) {
	    if (s == PL_bufend)
		yyerror("Final $ should be \\$ or $name");
	    PREREF('$');
d1994 2
d1997 12
a2008 20
	/* This kludge not intended to be bulletproof. */
	if (PL_tokenbuf[1] == '[' && !PL_tokenbuf[2]) {
	    yylval.opval = newSVOP(OP_CONST, 0,
				   newSViv((IV)PL_compiling.cop_arybase));
	    yylval.opval->op_private = OPpCONST_ARYBASE;
	    TERM(THING);
	}

	d = s;
	if (PL_lex_state == LEX_NORMAL)
	    s = skipspace(s);

	if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop) && intuit_more(s)) {
	    char *t;
	    if (*s == '[') {
		PL_tokenbuf[0] = '@@';
		if (PL_dowarn) {
		    for(t = s + 1;
			isSPACE(*t) || isALNUM(*t) || *t == '$';
			t++) ;
d2010 2
a2011 3
			PL_bufptr = skipspace(PL_bufptr);
			while (t < PL_bufend && *t != ']')
			    t++;
d2013 1
a2013 1
			     (t - PL_bufptr) + 1, PL_bufptr);
d2016 3
a2018 7
	    }
	    else if (*s == '{') {
		PL_tokenbuf[0] = '%';
		if (PL_dowarn && strEQ(PL_tokenbuf+1, "SIG") &&
		    (t = strchr(s, '}')) && (t = strchr(t, '=')))
		{
		    char tmpbuf[sizeof PL_tokenbuf];
d2022 2
a2023 3
			t = scan_word(t, tmpbuf, sizeof tmpbuf, TRUE, &len);
		        for (; isSPACE(*t); t++) ;
			if (*t == ';' && perl_get_cv(tmpbuf, FALSE))
d2028 33
a2060 29
	}

	PL_expect = XOPERATOR;
	if (PL_lex_state == LEX_NORMAL && isSPACE(*d)) {
	    bool islop = (PL_last_lop == PL_oldoldbufptr);
	    if (!islop || PL_last_lop_op == OP_GREPSTART)
		PL_expect = XOPERATOR;
	    else if (strchr("$@@\"'`q", *s))
		PL_expect = XTERM;		/* e.g. print $fh "foo" */
	    else if (strchr("&*<%", *s) && isIDFIRST(s[1]))
		PL_expect = XTERM;		/* e.g. print $fh &sub */
	    else if (isIDFIRST(*s)) {
		char tmpbuf[sizeof PL_tokenbuf];
		scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
		if (tmp = keyword(tmpbuf, len)) {
		    /* binary operators exclude handle interpretations */
		    switch (tmp) {
		    case -KEY_x:
		    case -KEY_eq:
		    case -KEY_ne:
		    case -KEY_gt:
		    case -KEY_lt:
		    case -KEY_ge:
		    case -KEY_le:
		    case -KEY_cmp:
			break;
		    default:
			PL_expect = XTERM;	/* e.g. print $fh length() */
			break;
d2063 17
a2079 4
		else {
		    GV *gv = gv_fetchpv(tmpbuf, FALSE, SVt_PVCV);
		    if (gv && GvCVu(gv))
			PL_expect = XTERM;	/* e.g. print $fh subr() */
d2081 2
d2084 7
a2090 8
	    else if (isDIGIT(*s))
		PL_expect = XTERM;		/* e.g. print $fh 3 */
	    else if (*s == '.' && isDIGIT(s[1]))
		PL_expect = XTERM;		/* e.g. print $fh .3 */
	    else if (strchr("/?-+", *s) && !isSPACE(s[1]) && s[1] != '=')
		PL_expect = XTERM;		/* e.g. print $fh -1 */
	    else if (*s == '<' && s[1] == '<' && !isSPACE(s[2]) && s[2] != '=')
		PL_expect = XTERM;		/* print $fh <<"EOF" */
a2091 1
	PL_pending_ident = '$';
d2095 40
a2134 14
	if (PL_expect == XOPERATOR)
	    no_op("Array", s);
	PL_tokenbuf[0] = '@@';
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, FALSE);
	if (!PL_tokenbuf[1]) {
	    if (s == PL_bufend)
		yyerror("Final @@ should be \\@@ or @@name");
	    PREREF('@@');
	}
	if (PL_lex_state == LEX_NORMAL)
	    s = skipspace(s);
	if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop) && intuit_more(s)) {
	    if (*s == '{')
		PL_tokenbuf[0] = '%';
d2137 1
a2137 1
	    if (PL_dowarn) {
d2144 1
a2144 1
			PL_bufptr = skipspace(PL_bufptr);
d2146 1
a2146 1
			    t-PL_bufptr, PL_bufptr, t-PL_bufptr-1, PL_bufptr+1);
d2150 6
a2156 1
	PL_pending_ident = '@@';
d2161 3
a2163 7
	if (PL_expect != XOPERATOR) {
	    /* Disable warning on "study /blah/" */
	    if (PL_oldoldbufptr == PL_last_uni 
		&& (*PL_last_uni != 's' || s - PL_last_uni < 5 
		    || memNE(PL_last_uni, "study", 5) || isALNUM(PL_last_uni[5])))
		check_uni();
	    s = scan_pat(s,OP_MATCH);
d2172 4
a2175 10
	if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack
#ifdef PERL_STRICT_CR
	    && s[1] == '\n'
#else
	    && (s[1] == '\n' || (s[1] == '\r' && s[2] == '\n'))
#endif
	    && (s == PL_linestart || s[-1] == '\n') )
	{
	    PL_lex_formbrack = 0;
	    PL_expect = XSTATE;
d2178 1
a2178 1
	if (PL_expect == XOPERATOR || !isDIGIT(s[1])) {
d2190 1
a2190 1
	    if (PL_expect != XOPERATOR)
d2198 1
a2198 1
	if (PL_expect == XOPERATOR)
d2204 3
a2206 3
	if (PL_expect == XOPERATOR) {
	    if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack) {
		PL_expect = XTERM;
d2220 3
a2222 3
	if (PL_expect == XOPERATOR) {
	    if (PL_lex_formbrack && PL_lex_brackets == PL_lex_formbrack) {
		PL_expect = XTERM;
d2232 1
a2232 1
	for (d = SvPV(PL_lex_stuff, len); len; len--, d++) {
d2242 1
a2242 1
	if (PL_expect == XOPERATOR)
d2252 1
a2252 1
	if (PL_dowarn && PL_lex_inwhat && isDIGIT(*s))
d2254 1
a2254 1
	if (PL_expect == XOPERATOR)
d2259 1
a2259 1
	if (isDIGIT(s[1]) && PL_expect == XOPERATOR) {
d2293 6
a2298 13
      keylookup: {
	STRLEN n_a;
	gv = Nullgv;
	gvp = 0;

	PL_bufptr = s;
	s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &len);

	/* Some keywords can be followed by any delimiter, including ':' */
	tmp = (len == 1 && strchr("msyq", PL_tokenbuf[0]) ||
	       len == 2 && ((PL_tokenbuf[0] == 't' && PL_tokenbuf[1] == 'r') ||
			    (PL_tokenbuf[0] == 'q' &&
			     strchr("qwxr", PL_tokenbuf[1]))));
d2300 1
a2300 3
	/* x::* is just a word, unless x is "CORE" */
	if (!tmp && *s == ':' && s[1] == ':' && strNE(PL_tokenbuf, "CORE"))
	    goto just_a_word;
d2302 1
d2304 1
a2304 1
	while (d < PL_bufend && isSPACE(*d))
a2305 14

	/* Is this a label? */
	if (!tmp && PL_expect == XSTATE
	      && d < PL_bufend && *d == ':' && *(d + 1) != ':') {
	    s = d + 1;
	    yylval.pval = savepv(PL_tokenbuf);
	    CLINE;
	    TOKEN(LABEL);
	}

	/* Check for keywords */
	tmp = keyword(PL_tokenbuf, len);

	/* Is this a word before a => operator? */
d2308 4
a2311 1
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(PL_tokenbuf,0));
d2317 5
a2321 26
	    GV *ogv = Nullgv;	/* override (winner) */
	    GV *hgv = Nullgv;	/* hidden (loser) */
	    if (PL_expect != XOPERATOR && (*s != ':' || s[1] != ':')) {
		CV *cv;
		if ((gv = gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVCV)) &&
		    (cv = GvCVu(gv)))
		{
		    if (GvIMPORTED_CV(gv))
			ogv = gv;
		    else if (! CvMETHOD(cv))
			hgv = gv;
		}
		if (!ogv &&
		    (gvp = (GV**)hv_fetch(PL_globalstash,PL_tokenbuf,len,FALSE)) &&
		    (gv = *gvp) != (GV*)&PL_sv_undef &&
		    GvCVu(gv) && GvIMPORTED_CV(gv))
		{
		    ogv = gv;
		}
	    }
	    if (ogv) {
		tmp = 0;		/* overridden by import or by GLOBAL */
	    }
	    else if (gv && !gvp
		     && -tmp==KEY_lock	/* XXX generalizable kludge */
		     && !hv_fetch(GvHVn(PL_incgv), "Thread.pm", 9, FALSE))
d2323 1
a2323 1
		tmp = 0;		/* any sub overrides "weak" keyword */
d2325 1
a2325 1
	    else {			/* no override */
a2326 7
		gv = Nullgv;
		gvp = 0;
		if (PL_dowarn && hgv
		    && tmp != KEY_x && tmp != KEY_CORE) /* never ambiguous */
		    warn("Ambiguous call resolved as CORE::%s(), %s",
			 GvENAME(hgv), "qualify as such or use &");
	    }
d2334 2
a2335 2
		SV *sv;
		char lastchar = (PL_bufptr == PL_oldoldbufptr ? 0 : PL_bufptr[-1]);
d2340 3
a2342 7
		    STRLEN morelen;
		    s = scan_word(s, PL_tokenbuf + len, sizeof PL_tokenbuf - len,
				  TRUE, &morelen);
		    if (!morelen)
			croak("Bad name after %s%s", PL_tokenbuf,
				*s == '\'' ? "'" : "::");
		    len += morelen;
d2345 14
a2358 3
		if (PL_expect == XOPERATOR) {
		    if (PL_bufptr == PL_linestart) {
			PL_curcop->cop_line--;
d2360 1
a2360 1
			PL_curcop->cop_line++;
d2363 1
a2363 22
			no_op("Bareword",s);
		}

		/* Look for a subroutine with this name in current package,
		   unless name is "Foo::", in which case Foo is a bearword
		   (and a package name). */

		if (len > 2 &&
		    PL_tokenbuf[len - 2] == ':' && PL_tokenbuf[len - 1] == ':')
		{
		    if (PL_dowarn && ! gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVHV))
			warn("Bareword \"%s\" refers to nonexistent package",
			     PL_tokenbuf);
		    len -= 2;
		    PL_tokenbuf[len] = '\0';
		    gv = Nullgv;
		    gvp = 0;
		}
		else {
		    len = 0;
		    if (!gv)
			gv = gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVCV);
d2366 1
a2366 1
		/* if we saw a global override before, get the right name */
d2368 1
a2368 6
		if (gvp) {
		    sv = newSVpv("CORE::GLOBAL::",14);
		    sv_catpv(sv,PL_tokenbuf);
		}
		else
		    sv = newSVpv(PL_tokenbuf,0);
d2373 1
a2373 1
		yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
a2375 5
		/* And if "Foo::", then that's what it certainly is. */

		if (len)
		    goto safe_bareword;

d2378 3
a2380 3
		if (PL_oldoldbufptr &&
		    PL_oldoldbufptr < PL_bufptr &&
		    (PL_oldoldbufptr == PL_last_lop || PL_oldoldbufptr == PL_last_uni) &&
d2382 2
a2383 5
		    (PL_expect == XREF 
		     || ((opargs[PL_last_lop_op] >> OASHIFT)& 7) == OA_FILEREF
		     || (PL_last_lop_op == OP_ENTERSUB 
			 && PL_last_proto 
			 && PL_last_proto[PL_last_proto[0] == ';' ? 1 : 0] == '*')) )
d2398 4
a2401 4
		    if ((PL_last_lop_op == OP_SORT ||
                         (!immediate_paren && (!gv || !GvCVu(gv))) ) &&
                        (PL_last_lop_op != OP_MAPSTART && PL_last_lop_op != OP_GREPSTART)){
			PL_expect = (PL_last_lop == PL_oldoldbufptr) ? XTERM : XOPERATOR;
d2408 1
a2408 1
		PL_expect = XOPERATOR;
d2412 2
a2413 12
		    if (gv && GvCVu(gv)) {
			CV *cv;
			if ((cv = GvCV(gv)) && SvPOK(cv))
			    PL_last_proto = SvPV((SV*)cv, n_a);
			for (d = s + 1; *d == ' ' || *d == '\t'; d++) ;
			if (*d == ')' && (sv = cv_const_sv(cv))) {
			    s = d + 1;
			    goto its_constant;
			}
		    }
		    PL_nextval[PL_nexttoke].opval = yylval.opval;
		    PL_expect = XOPERATOR;
a2415 1
		    PL_last_lop_op = OP_ENTERSUB;
d2421 3
a2423 3
		if ((*s == '$' || *s == '{') && (!gv || !GvCVu(gv))) {
		    PL_last_lop = PL_oldbufptr;
		    PL_last_lop_op = OP_METHOD;
d2434 9
a2442 2
		if (gv && GvCVu(gv)) {
		    CV* cv;
d2445 3
a2447 13
				PL_tokenbuf, PL_tokenbuf);
		    PL_last_lop = PL_oldbufptr;
		    PL_last_lop_op = OP_ENTERSUB;
		    /* Check for a constant sub */
		    cv = GvCV(gv);
		    if ((sv = cv_const_sv(cv))) {
		  its_constant:
			SvREFCNT_dec(((SVOP*)yylval.opval)->op_sv);
			((SVOP*)yylval.opval)->op_sv = SvREFCNT_inc(sv);
			yylval.opval->op_private = 0;
			TOKEN(WORD);
		    }

a2450 1
		    PL_last_lop_op = OP_ENTERSUB;
d2454 1
a2454 1
			PL_last_proto = SvPV((SV*)cv, len);
d2457 1
a2457 1
			if (strEQ(PL_last_proto, "$"))
d2459 2
a2460 2
			if (*PL_last_proto == '&' && *s == '{') {
			    sv_setpv(PL_subname,"__ANON__");
d2463 3
a2465 4
		    } else
			PL_last_proto = NULL;
		    PL_nextval[PL_nexttoke].opval = yylval.opval;
		    PL_expect = XTERM;
d2470 1
a2470 1
		if (PL_hints & HINT_STRICT_SUBS &&
d2473 3
a2475 7
		    PL_last_lop_op != OP_TRUNCATE &&  /* S/F prototype in opcode.pl */
		    PL_last_lop_op != OP_ACCEPT &&
		    PL_last_lop_op != OP_PIPE_OP &&
		    PL_last_lop_op != OP_SOCKPAIR &&
		    !(PL_last_lop_op == OP_ENTERSUB 
			 && PL_last_proto 
			 && PL_last_proto[PL_last_proto[0] == ';' ? 1 : 0] == '*'))
d2479 2
a2480 2
			PL_tokenbuf);
		    ++PL_error_count;
d2486 1
a2486 1
		if (PL_dowarn) {
d2488 1
a2488 1
			for (d = PL_tokenbuf; *d && isLOWER(*d); d++) ;
d2490 1
a2490 1
			    warn(warn_reserved, PL_tokenbuf);
a2492 2

	    safe_bareword:
d2495 1
a2495 1
			lastchar, PL_tokenbuf);
a2501 5
	case KEY___FILE__:
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0,
					newSVsv(GvSV(PL_curcop->cop_filegv)));
	    TERM(THING);

d2503 6
a2508 9
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0,
				    newSVpvf("%ld", (long)PL_curcop->cop_line));
	    TERM(THING);

	case KEY___PACKAGE__:
	    yylval.opval = (OP*)newSVOP(OP_CONST, 0,
					(PL_curstash
					 ? newSVsv(PL_curstname)
					 : &PL_sv_undef));
d2510 1
d2517 2
a2518 1
	    if (PL_rsfp && (!PL_in_eval || PL_tokenbuf[2] == 'D')) {
d2520 4
a2523 3
		if (PL_tokenbuf[2] == 'D')
		    pname = HvNAME(PL_curstash ? PL_curstash : PL_defstash);
		gv = gv_fetchpv(form("%s::DATA", pname), TRUE, SVt_PVIO);
d2527 1
a2527 1
		IoIFP(GvIOp(gv)) = PL_rsfp;
d2530 1
a2530 1
		    int fd = PerlIO_fileno(PL_rsfp);
d2534 1
a2534 3
		/* Mark this internal pseudo-handle as clean */
		IoFLAGS(GvIOp(gv)) |= IOf_UNTAINT;
		if (PL_preprocess)
d2536 1
a2536 1
		else if ((PerlIO*)PL_rsfp == PerlIO_stdin())
d2540 1
a2540 1
		PL_rsfp = Nullfp;
d2549 2
a2550 3
	case KEY_INIT:
	    if (PL_expect == XSTATE) {
		s = PL_bufptr;
d2559 2
a2560 2
		s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &len);
		tmp = keyword(PL_tokenbuf, len);
d2615 1
a2615 1
	    if (!PL_cryptseen++)
d2621 2
a2622 2
	    if (PL_dowarn) {
		for (d = s; d < PL_bufend && (isSPACE(*d) || *d == '('); d++) ;
d2652 1
a2652 1
	    PL_hints |= HINT_BLOCK_SCOPE;
d2676 1
a2676 1
	    yylval.ival = PL_curcop->cop_line;
d2690 1
a2690 1
	    PL_expect = (*s == '{') ? XTERMBLOCK : XTERM;
d2726 5
a2730 11
	    yylval.ival = PL_curcop->cop_line;
	    s = skipspace(s);
	    if (PL_expect == XSTATE && isIDFIRST(*s)) {
		char *p = s;
		if ((PL_bufend - p) >= 3 &&
		    strnEQ(p, "my", 2) && isSPACE(*(p + 2)))
		    p += 2;
		p = skipspace(p);
		if (isIDFIRST(*p))
		    croak("Missing $ on loop variable");
	    }
d2789 1
a2789 1
	    UNI(OP_GPWNAM);
d2792 1
a2792 1
	    UNI(OP_GPWUID);
d2834 1
a2834 1
	    UNI(OP_GGRNAM);
d2837 1
a2837 1
	    UNI(OP_GGRGID);
d2850 1
a2850 1
	    yylval.ival = PL_curcop->cop_line;
d2882 1
a2905 3
	case KEY_lock:
	    UNI(OP_LOCK);

d2910 1
a2910 1
	    s = scan_pat(s,OP_MATCH);
d2932 3
a2934 13
	    PL_in_my = TRUE;
	    s = skipspace(s);
	    if (isIDFIRST(*s)) {
		s = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, TRUE, &len);
		PL_in_my_stash = gv_stashpv(PL_tokenbuf, FALSE);
		if (!PL_in_my_stash) {
		    char tmpbuf[1024];
		    PL_bufptr = s;
		    sprintf(tmpbuf, "No such class %.1000s", PL_tokenbuf);
		    yyerror(tmpbuf);
		}
	    }
	    OPERATOR(MY);
d2944 1
a2944 1
	    if (PL_expect != XSTATE)
a2946 1
	    s = force_version(s);
d2979 1
a2979 1
	    checkcomma(s,PL_tokenbuf,"filehandle");
d2983 1
a2983 1
	    checkcomma(s,PL_tokenbuf,"filehandle");
a3021 13
	    if (PL_dowarn && SvLEN(PL_lex_stuff)) {
		d = SvPV_force(PL_lex_stuff, len);
		for (; len; --len, ++d) {
		    if (*d == ',') {
			warn("Possible attempt to separate words with commas");
			break;
		    }
		    if (*d == '#') {
			warn("Possible attempt to put comments in qw() list");
			break;
		    }
		}
	    }
d3023 2
a3024 2
	    PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, tokeq(PL_lex_stuff));
	    PL_lex_stuff = Nullsv;
d3027 1
a3027 1
	    PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(" ",1));
d3032 4
a3035 4
	    PL_expect = XTERM;
	    PL_bufptr = s;
	    PL_last_lop = PL_oldbufptr;
	    PL_last_lop_op = OP_SPLIT;
d3043 2
a3044 6
	    if (SvIVX(PL_lex_stuff) == '\'')
		SvIVX(PL_lex_stuff) = 0;	/* qq'$foo' should intepolate */
	    TERM(sublex_start());

	case KEY_qr:
	    s = scan_pat(s,OP_QR);
d3059 1
a3059 1
	    *PL_tokenbuf = '\0';
d3061 2
a3062 2
	    if (isIDFIRST(*PL_tokenbuf))
		gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf), TRUE);
d3153 1
a3153 1
	    UNI(OP_SHOSTENT);
d3156 1
a3156 1
	    UNI(OP_SNETENT);
d3159 1
a3159 1
	    UNI(OP_SSERVENT);
d3162 1
a3162 1
	    UNI(OP_SPROTOENT);
d3207 1
a3207 1
	    checkcomma(s,PL_tokenbuf,"subroutine name");
d3211 2
a3212 2
	    PL_expect = XTERM;
	    s = force_word(s,WORD,TRUE,TRUE,FALSE);
d3234 1
a3234 1
	    PL_sawstudy++;
d3246 3
a3248 3
		char tmpbuf[sizeof PL_tokenbuf];
		PL_expect = XBLOCK;
		d = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
d3250 1
a3250 1
		    sv_setpv(PL_subname, tmpbuf);
d3252 3
a3254 3
		    sv_setsv(PL_subname,PL_curstname);
		    sv_catpvn(PL_subname,"::",2);
		    sv_catpvn(PL_subname,tmpbuf,len);
d3260 2
a3261 2
		PL_expect = XTERMBLOCK;
		sv_setpv(PL_subname,"?");
d3267 1
a3267 1
		    PL_lex_formbrack = PL_lex_brackets + 1;
a3272 2
		char *p;

d3275 3
a3277 3
		    if (PL_lex_stuff)
			SvREFCNT_dec(PL_lex_stuff);
		    PL_lex_stuff = Nullsv;
d3280 9
a3288 19
		/* strip spaces */
		d = SvPVX(PL_lex_stuff);
		tmp = 0;
		for (p = d; *p; ++p) {
		    if (!isSPACE(*p))
			d[tmp++] = *p;
		}
		d[tmp] = '\0';
		SvCUR(PL_lex_stuff) = tmp;

		PL_nexttoke++;
		PL_nextval[1] = PL_nextval[0];
		PL_nexttype[1] = PL_nexttype[0];
		PL_nextval[0].opval = (OP*)newSVOP(OP_CONST, 0, PL_lex_stuff);
		PL_nexttype[0] = THING;
		if (PL_nexttoke == 1) {
		    PL_lex_defer = PL_lex_state;
		    PL_lex_expect = PL_expect;
		    PL_lex_state = LEX_KNOWNEXT;
d3290 1
a3290 1
		PL_lex_stuff = Nullsv;
d3293 2
a3294 2
	    if (*SvPV(PL_subname,n_a) == '?') {
		sv_setpv(PL_subname,"__ANON__");
a3311 3
	case KEY_sysseek:
	    LOP(OP_SYSSEEK,XTERM);

d3353 1
a3353 1
	    yylval.ival = PL_curcop->cop_line;
d3357 1
a3357 1
	    yylval.ival = PL_curcop->cop_line;
d3373 2
a3374 2
	    if (PL_dowarn) {
		for (d = s; d < PL_bufend && (isSPACE(*d) || *d == '('); d++) ;
d3384 1
a3384 1
	    if (PL_expect != XSTATE)
d3386 1
a3386 12
	    s = skipspace(s);
	    if(isDIGIT(*s)) {
		s = force_version(s);
		if(*s == ';' || (s = skipspace(s), *s == ';')) {
		    PL_nextval[PL_nexttoke].opval = Nullop;
		    force_next(WORD);
		}
	    }
	    else {
		s = force_word(s,WORD,FALSE,TRUE,FALSE);
		s = force_version(s);
	    }
d3394 1
a3394 1
	    PL_sawvec = TRUE;
d3398 1
a3398 1
	    yylval.ival = PL_curcop->cop_line;
d3402 1
a3402 1
	    PL_hints |= HINT_BLOCK_SCOPE;
d3415 1
a3415 11
#ifdef EBCDIC
	{
	    static char ctl_l[2];

	    if (ctl_l[0] == '\0') 
 		ctl_l[0] = toCTRL('L');
	    gv_fetchpv(ctl_l,TRUE, SVt_PV);
	}
#else
	    gv_fetchpv("\f",TRUE, SVt_PV);      /* Make sure $^L is defined */
#endif
d3419 1
a3419 1
	    if (PL_expect == XOPERATOR)
d3432 1
a3432 1
    }}
d3436 3
a3438 1
keyword(register char *d, I32 len)
d3443 1
a3444 2
	    if (strEQ(d,"__LINE__"))		return -KEY___LINE__;
	    if (strEQ(d,"__PACKAGE__"))		return -KEY___PACKAGE__;
d3671 1
a3671 1
	    if (strEQ(d,"glob"))		return KEY_glob;
a3680 3
    case 'I':
	if (strEQ(d,"INIT"))			return KEY_INIT;
	break;
a3722 1
	    if (strEQ(d,"lock"))		return -KEY_lock;
a3776 2
	    if (strEQ(d,"our")) { deprecate("reserved word \"our\"");
						return 0;}
a3812 1
	    if (strEQ(d,"qr"))			return KEY_qr;
d3950 2
a3953 3
		if (strEQ(d,"sysopen"))		return -KEY_sysopen;
		if (strEQ(d,"sysread"))		return -KEY_sysread;
		if (strEQ(d,"sysseek"))		return -KEY_sysseek;
d4047 5
a4051 2
STATIC void
checkcomma(register char *s, char *name, char *what)
d4055 1
a4055 1
    if (PL_dowarn && *s == ' ' && s[1] == '(') {	/* XXX gotta be a better way */
d4065 1
a4065 1
	if (!*w || !strchr(";|})]oaiuw!=", *w))	/* an advisory hack only... */
d4068 1
a4068 1
    while (s < PL_bufend && isSPACE(*s))
d4072 1
a4072 1
    while (s < PL_bufend && isSPACE(*s))
d4078 1
a4078 1
	while (s < PL_bufend && isSPACE(*s))
d4092 6
a4097 71
STATIC SV *
new_constant(char *s, STRLEN len, char *key, SV *sv, SV *pv, char *type) 
{
    dSP;
    HV *table = GvHV(PL_hintgv);		 /* ^H */
    BINOP myop;
    SV *res;
    bool oldcatch = CATCH_GET;
    SV **cvp;
    SV *cv, *typesv;
    char buf[128];
	    
    if (!table) {
	yyerror("%^H is not defined");
	return sv;
    }
    cvp = hv_fetch(table, key, strlen(key), FALSE);
    if (!cvp || !SvOK(*cvp)) {
	sprintf(buf,"$^H{%s} is not defined", key);
	yyerror(buf);
	return sv;
    }
    sv_2mortal(sv);			/* Parent created it permanently */
    cv = *cvp;
    if (!pv)
	pv = sv_2mortal(newSVpv(s, len));
    if (type)
	typesv = sv_2mortal(newSVpv(type, 0));
    else
	typesv = &PL_sv_undef;
    CATCH_SET(TRUE);
    Zero(&myop, 1, BINOP);
    myop.op_last = (OP *) &myop;
    myop.op_next = Nullop;
    myop.op_flags = OPf_WANT_SCALAR | OPf_STACKED;

    PUSHSTACKi(PERLSI_OVERLOAD);
    ENTER;
    SAVEOP();
    PL_op = (OP *) &myop;
    if (PERLDB_SUB && PL_curstash != PL_debstash)
	PL_op->op_private |= OPpENTERSUB_DB;
    PUTBACK;
    pp_pushmark(ARGS);

    EXTEND(sp, 4);
    PUSHs(pv);
    PUSHs(sv);
    PUSHs(typesv);
    PUSHs(cv);
    PUTBACK;

    if (PL_op = pp_entersub(ARGS))
      CALLRUNOPS();
    LEAVE;
    SPAGAIN;

    res = POPs;
    PUTBACK;
    CATCH_SET(oldcatch);
    POPSTACK;

    if (!SvOK(res)) {
	sprintf(buf,"Call to &{$^H{%s}} did not return a defined value", key);
	yyerror(buf);
    }
    return SvREFCNT_inc(res);
}

STATIC char *
scan_word(register char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
a4099 1
    register char *e = d + destlen - 3;  /* two-character token, ending NUL */
a4100 2
	if (d >= e)
	    croak(ident_too_long);
d4108 1
a4108 1
	else if (*s == ':' && s[1] == ':' && allow_package && s[2] != '$') {
d4120 6
a4125 2
STATIC char *
scan_ident(register char *s, register char *send, char *dest, STRLEN destlen, I32 ck_uni)
a4127 1
    register char *e;
d4131 2
a4132 2
    if (PL_lex_brackets == 0)
	PL_lex_fakebrack = 0;
a4135 1
    e = d + destlen - 3;	/* two-character token, ending NUL */
d4137 1
a4137 3
	while (isDIGIT(*s)) {
	    if (d >= e)
		croak(ident_too_long);
a4138 1
	}
a4141 2
	    if (d >= e)
		croak(ident_too_long);
d4160 2
a4161 2
	if (PL_lex_state != LEX_NORMAL)
	    PL_lex_state = LEX_INTERPENDMAYBE;
d4165 2
a4166 7
      (isALNUM(s[1]) || strchr("${", s[1]) || strnEQ(s+1,"::",2)) )
    {
	if (isDIGIT(s[1]) && PL_lex_state == LEX_INTERPNORMAL)
	    deprecate("\"$$<digit>\" to mean \"${$}<digit>\"");
	else
	    return s;
    }
d4177 1
a4177 2
	*d = toCTRL(*s);
	s++;
d4181 2
a4182 7
	    while (s < send) {
		char ch = *s++;
		if (ch != ' ' && ch != '\t') {
		    *d = ch;
		    break;
		}
	    }
d4184 1
a4184 1
	if (isIDFIRST(*d)) {
d4190 2
a4191 2
	    if ((*s == '[' || (*s == '{' && strNE(dest, "sub")))) {
		if (PL_dowarn && keyword(dest, d - dest)) {
d4196 1
a4196 1
		PL_lex_fakebrack = PL_lex_brackets+1;
d4198 1
a4198 1
		PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d4204 2
a4205 2
	    if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets)
		PL_lex_state = LEX_INTERPEND;
d4208 1
a4208 1
	    if (PL_dowarn && PL_lex_state == LEX_NORMAL &&
d4218 2
a4219 2
    else if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets && !intuit_more(s))
	PL_lex_state = LEX_INTERPEND;
d4223 3
a4225 1
void pmflag(U16 *pmfl, int ch)
d4227 2
a4228 1
    if (ch == 'i')
d4230 1
a4232 2
    else if (ch == 'c')
	*pmfl |= PMf_CONTINUE;
d4243 3
a4245 2
STATIC char *
scan_pat(char *start, I32 type)
d4252 3
a4254 3
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
d4257 6
a4263 11
    pm = (PMOP*)newPMOP(type, 0);
    if (PL_multi_open == '?')
	pm->op_pmflags |= PMf_ONCE;
    if(type == OP_QR) {
	while (*s && strchr("iomsx", *s))
	    pmflag(&pm->op_pmflags,*s++);
    }
    else {
	while (*s && strchr("iogcmsx", *s))
	    pmflag(&pm->op_pmflags,*s++);
    }
d4265 1
a4265 2

    PL_lex_op = (OP*)pm;
d4270 3
a4272 2
STATIC char *
scan_subst(char *start)
a4275 1
    I32 first_start;
d4283 3
a4285 3
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
d4289 1
a4289 1
    if (s[-1] == PL_multi_open)
a4291 1
    first_start = PL_multi_start;
d4294 6
a4299 6
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
	if (PL_lex_repl)
	    SvREFCNT_dec(PL_lex_repl);
	PL_lex_repl = Nullsv;
a4301 1
    PL_multi_start = first_start;	/* so whole substitution is taken together */
d4304 1
a4304 1
    while (*s) {
d4309 1
a4309 1
	else if (strchr("iogcmsx", *s))
a4310 2
	else
	    break;
a4314 3
	PL_super_bufptr = s;
	PL_super_bufend = PL_bufend;
	PL_multi_end = 0;
d4320 1
a4320 1
	sv_catsv(repl, PL_lex_repl);
d4323 2
a4324 2
	SvREFCNT_dec(PL_lex_repl);
	PL_lex_repl = repl;
d4328 1
a4328 1
    PL_lex_op = (OP*)pm;
d4333 43
a4375 2
STATIC char *
scan_trans(char *start)
d4378 1
a4378 1
    OP *o;
d4381 1
a4381 1
    I32 Delete;
d4388 4
a4391 4
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
	croak("Transliteration pattern not terminated");
d4393 1
a4393 1
    if (s[-1] == PL_multi_open)
d4398 7
a4404 7
	if (PL_lex_stuff)
	    SvREFCNT_dec(PL_lex_stuff);
	PL_lex_stuff = Nullsv;
	if (PL_lex_repl)
	    SvREFCNT_dec(PL_lex_repl);
	PL_lex_repl = Nullsv;
	croak("Transliteration replacement not terminated");
d4408 1
a4408 1
    o = newPVOP(OP_TRANS, 0, (char*)tbl);
d4410 1
a4410 1
    complement = Delete = squash = 0;
d4415 1
a4415 1
	    Delete = OPpTRANS_DELETE;
d4420 1
a4420 1
    o->op_private = Delete|squash|complement;
d4422 1
a4422 1
    PL_lex_op = o;
d4427 3
a4429 2
STATIC char *
scan_heredoc(register char *s)
a4430 1
    dTHR;
a4436 1
    register char *e;
a4437 1
    int outer = (PL_rsfp && !(PL_lex_inwhat == OP_SCALAR));
d4440 2
a4441 3
    d = PL_tokenbuf;
    e = PL_tokenbuf + sizeof PL_tokenbuf - 1;
    if (!outer)
d4447 3
a4449 1
	s = delimcpy(d, e, s, PL_bufend, term, &len);
a4450 2
	if (s < PL_bufend)
	    s++;
d4459 3
a4461 7
	for (; isALNUM(*s); s++) {
	    if (d < e)
		*d++ = *s;
	}
    }
    if (d >= PL_tokenbuf + sizeof PL_tokenbuf - 1)
	croak("Delimiter for here document is too long");
d4464 1
a4464 25
    len = d - PL_tokenbuf;
#ifndef PERL_STRICT_CR
    d = strchr(s, '\r');
    if (d) {
	char *olds = s;
	s = d;
	while (s < PL_bufend) {
	    if (*s == '\r') {
		*d++ = '\n';
		if (*++s == '\n')
		    s++;
	    }
	    else if (*s == '\n' && s[1] == '\r') {	/* \015\013 on a mac? */
		*d++ = *s++;
		s++;
	    }
	    else
		*d++ = *s++;
	}
	*d = '\0';
	PL_bufend = d;
	SvCUR_set(PL_linestr, PL_bufend - SvPVX(PL_linestr));
	s = olds;
    }
#endif
d4466 2
a4467 2
    if (outer || !(d=ninstr(s,PL_bufend,d,d+1)))
	herewas = newSVpv(s,PL_bufend-s);
d4472 1
a4472 1
    tmpstr = NEWSV(87,79);
d4484 4
a4487 10
    PL_multi_start = PL_curcop->cop_line;
    PL_multi_open = PL_multi_close = '<';
    term = *PL_tokenbuf;
    if (PL_lex_inwhat == OP_SUBST && PL_in_eval && !PL_rsfp) {
	char *bufptr = PL_super_bufptr;
	char *bufend = PL_super_bufend;
	char *olds = s - SvCUR(herewas);
	s = strchr(bufptr, '\n');
	if (!s)
	    s = bufend;
d4490 1
a4490 1
	  (*s != term || memNE(s,PL_tokenbuf,len)) ) {
d4492 1
a4492 1
		PL_curcop->cop_line++;
d4495 2
a4496 2
	    PL_curcop->cop_line = PL_multi_start;
	    missingterm(PL_tokenbuf);
a4497 1
	sv_setpvn(herewas,bufptr,d-bufptr+1);
d4501 3
a4503 24
	(void)strcpy(bufptr,SvPVX(herewas));

	s = olds;
	goto retval;
    }
    else if (!outer) {
	d = s;
	while (s < PL_bufend &&
	  (*s != term || memNE(s,PL_tokenbuf,len)) ) {
	    if (*s++ == '\n')
		PL_curcop->cop_line++;
	}
	if (s >= PL_bufend) {
	    PL_curcop->cop_line = PL_multi_start;
	    missingterm(PL_tokenbuf);
	}
	sv_setpvn(tmpstr,d+1,s-d);
	s += len - 1;
	PL_curcop->cop_line++;	/* the preceding stmt passes a newline */

	sv_catpvn(herewas,s,PL_bufend-s);
	sv_setsv(PL_linestr,herewas);
	PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = s = PL_linestart = SvPVX(PL_linestr);
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
d4507 5
a4511 19
    while (s >= PL_bufend) {	/* multiple line string? */
	if (!outer ||
	 !(PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = filter_gets(PL_linestr, PL_rsfp, 0))) {
	    PL_curcop->cop_line = PL_multi_start;
	    missingterm(PL_tokenbuf);
	}
	PL_curcop->cop_line++;
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
#ifndef PERL_STRICT_CR
	if (PL_bufend - PL_linestart >= 2) {
	    if ((PL_bufend[-2] == '\r' && PL_bufend[-1] == '\n') ||
		(PL_bufend[-2] == '\n' && PL_bufend[-1] == '\r'))
	    {
		PL_bufend[-2] = '\n';
		PL_bufend--;
		SvCUR_set(PL_linestr, PL_bufend - SvPVX(PL_linestr));
	    }
	    else if (PL_bufend[-1] == '\r')
		PL_bufend[-1] = '\n';
d4513 2
a4514 4
	else if (PL_bufend - PL_linestart == 1 && PL_bufend[-1] == '\r')
	    PL_bufend[-1] = '\n';
#endif
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
d4518 7
a4524 6
	    sv_setsv(sv,PL_linestr);
	    av_store(GvAV(PL_curcop->cop_filegv),
	      (I32)PL_curcop->cop_line,sv);
	}
	if (*s == term && memEQ(s,PL_tokenbuf,len)) {
	    s = PL_bufend - 1;
d4526 2
a4527 2
	    sv_catsv(PL_linestr,herewas);
	    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
d4530 2
a4531 2
	    s = PL_bufend;
	    sv_catsv(tmpstr,PL_linestr);
d4534 1
a4535 2
retval:
    PL_multi_end = PL_curcop->cop_line;
d4541 1
a4541 1
    PL_lex_stuff = tmpstr;
d4546 3
a4548 18
/* scan_inputsymbol
   takes: current position in input buffer
   returns: new position in input buffer
   side-effects: yylval and lex_op are set.

   This code handles:

   <>		read from ARGV
   <FH> 	read from filehandle
   <pkg::FH>	read from package qualified filehandle
   <pkg'FH>	read from package qualified filehandle
   <$fh>	read from filehandle in $fh
   <*.h>	filename glob

*/

STATIC char *
scan_inputsymbol(char *start)
d4550 1
a4550 1
    register char *s = start;		/* current position in buffer */
a4551 1
    register char *e;
d4554 5
a4558 11
    d = PL_tokenbuf;			/* start of temp holding space */
    e = PL_tokenbuf + sizeof PL_tokenbuf;	/* end of temp holding space */
    s = delimcpy(d, e, s + 1, PL_bufend, '>', &len);	/* extract until > */

    /* die if we didn't have space for the contents of the <>,
       or if it didn't end
    */

    if (len >= sizeof PL_tokenbuf)
	croak("Excessively long <> operator");
    if (s >= PL_bufend)
a4560 9
    s++;

    /* check for <$fh>
       Remember, only scalar variables are interpreted as filehandles by
       this code.  Anything more complex (e.g., <$fh{$num}>) will be
       treated as a glob() call.
       This code makes use of the fact that except for the $ at the front,
       a scalar variable and a filehandle look the same.
    */
a4561 2

    /* allow <Pkg'VALUE> or <Pkg::VALUE> */
d4564 1
a4564 8

    /* If we've tried to read what we allow filehandles to look like, and
       there's still text left, then it must be a glob() and not a getline.
       Use scan_str to pull out the stuff between the <> and treat it
       as nothing more than a string.
    */

    if (d - PL_tokenbuf != len) {
d4569 1
a4569 1
	   croak("Glob not terminated");
d4573 1
a4573 4
    	/* we're in a filehandle read situation */
	d = PL_tokenbuf;

	/* turn <> into <ARGV> */
a4575 4

	/* if <$fh>, create the ops to turn the variable into a
	   filehandle
	*/
d4578 4
a4581 8

	    /* try to find it in the pad for this block, otherwise find
	       add symbol table ops
	    */
	    if ((tmp = pad_findmy(d)) != NOT_IN_PAD) {
		OP *o = newOP(OP_PADSV, 0);
		o->op_targ = tmp;
		PL_lex_op = (OP*)newUNOP(OP_READLINE, 0, newUNOP(OP_RV2GV, 0, o));
d4585 1
a4585 1
		PL_lex_op = (OP*)newUNOP(OP_READLINE, 0,
a4589 1
	    /* we created the ops in lex_op, so make yylval.ival a null op */
a4591 3

	/* If it's none of the above, it must be a literal filehandle
	   (<Foo::BAR> or <FOO>) so build a simple readline OP */
d4594 1
a4594 1
	    PL_lex_op = (OP*)newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, gv));
a4597 1

d4601 10
a4611 52
/* scan_str
   takes: start position in buffer
   returns: position to continue reading from buffer
   side-effects: multi_start, multi_close, lex_repl or lex_stuff, and
   	updates the read buffer.

   This subroutine pulls a string out of the input.  It is called for:
   	q		single quotes		q(literal text)
	'		single quotes		'literal text'
	qq		double quotes		qq(interpolate $here please)
	"		double quotes		"interpolate $here please"
	qx		backticks		qx(/bin/ls -l)
	`		backticks		`/bin/ls -l`
	qw		quote words		@@EXPORT_OK = qw( func() $spam )
	m//		regexp match		m/this/
	s///		regexp substitute	s/this/that/
	tr///		string transliterate	tr/this/that/
	y///		string transliterate	y/this/that/
	($*@@)		sub prototypes		sub foo ($)
	<>		readline or globs	<FOO>, <>, <$fh>, or <*.c>
	
   In most of these cases (all but <>, patterns and transliterate)
   yylex() calls scan_str().  m// makes yylex() call scan_pat() which
   calls scan_str().  s/// makes yylex() call scan_subst() which calls
   scan_str().  tr/// and y/// make yylex() call scan_trans() which
   calls scan_str().
      
   It skips whitespace before the string starts, and treats the first
   character as the delimiter.  If the delimiter is one of ([{< then
   the corresponding "close" character )]}> is used as the closing
   delimiter.  It allows quoting of delimiters, and if the string has
   balanced delimiters ([{<>}]) it allows nesting.

   The lexer always reads these strings into lex_stuff, except in the
   case of the operators which take *two* arguments (s/// and tr///)
   when it checks to see if lex_stuff is full (presumably with the 1st
   arg to s or tr) and if so puts the string into lex_repl.

*/

STATIC char *
scan_str(char *start)
{
    dTHR;
    SV *sv;				/* scalar value: string */
    char *tmps;				/* temp string, used for delimiter matching */
    register char *s = start;		/* current position in the buffer */
    register char term;			/* terminating character */
    register char *to;			/* current position in the sv's data */
    I32 brackets = 1;			/* bracket nesting level */

    /* skip space before the delimiter */
a4613 2

    /* mark where we are, in case we need to report errors */
a4614 2

    /* after skipping whitespace, the next character is the terminator */
d4616 2
a4617 5
    /* mark where we are */
    PL_multi_start = PL_curcop->cop_line;
    PL_multi_open = term;

    /* find corresponding closing delimiter */
d4620 1
a4620 1
    PL_multi_close = term;
d4622 1
a4622 3
    /* create a new SV to hold the contents.  87 is leak category, I'm
       assuming.  79 is the SV's initial length.  What a random number. */
    sv = NEWSV(87,79);
a4625 2

    /* move past delimiter and try to read a complete string */
d4628 1
a4628 3
    	/* extend sv if need be */
	SvGROW(sv, SvCUR(sv) + (PL_bufend - s) + 1);
	/* set 'to' to the next character in the sv's string */
d4630 5
a4634 9
	
	/* if open delimiter is the close delimiter read unbridle */
	if (PL_multi_open == PL_multi_close) {
	    for (; s < PL_bufend; s++,to++) {
	    	/* embedded newlines increment the current line number */
		if (*s == '\n' && !PL_rsfp)
		    PL_curcop->cop_line++;
		/* handle quoted delimiters */
		if (*s == '\\' && s+1 < PL_bufend && term != '\\') {
a4636 1
		/* any other quotes are simply copied straight through */
a4639 2
		/* terminate when run out of buffer (the for() condition), or
		   have found the terminator */
a4644 5
	
	/* if the terminator isn't the same as the start character (e.g.,
	   matched brackets), we have to allow more in the quoting, and
	   be prepared for nested brackets.
	*/
d4646 5
a4650 8
	    /* read until we run out of string, or we find the terminator */
	    for (; s < PL_bufend; s++,to++) {
	    	/* embedded newlines increment the line count */
		if (*s == '\n' && !PL_rsfp)
		    PL_curcop->cop_line++;
		/* backslashes can escape the open or closing characters */
		if (*s == '\\' && s+1 < PL_bufend) {
		    if ((s[1] == PL_multi_open) || (s[1] == PL_multi_close))
d4655 1
a4655 2
		/* allow nested opens and closes */
		else if (*s == PL_multi_close && --brackets <= 0)
d4657 1
a4657 1
		else if (*s == PL_multi_open)
a4661 1
	/* terminate the copied string and update the sv's end-of-string */
d4665 4
a4668 27
	/*
	 * this next chunk reads more into the buffer if we're not done yet
	 */

  	if (s < PL_bufend) break;	/* handle case where we are done yet :-) */

#ifndef PERL_STRICT_CR
	if (to - SvPVX(sv) >= 2) {
	    if ((to[-2] == '\r' && to[-1] == '\n') ||
		(to[-2] == '\n' && to[-1] == '\r'))
	    {
		to[-2] = '\n';
		to--;
		SvCUR_set(sv, to - SvPVX(sv));
	    }
	    else if (to[-1] == '\r')
		to[-1] = '\n';
	}
	else if (to - SvPVX(sv) == 1 && to[-1] == '\r')
	    to[-1] = '\n';
#endif
	
	/* if we're out of file, or a read fails, bail and reset the current
	   line marker so we can report where the unterminated string began
	*/
	if (!PL_rsfp ||
	 !(PL_oldoldbufptr = PL_oldbufptr = s = PL_linestart = filter_gets(PL_linestr, PL_rsfp, 0))) {
d4670 1
a4670 1
	    PL_curcop->cop_line = PL_multi_start;
d4673 2
a4674 5
	/* we read a line, so increment our line counter */
	PL_curcop->cop_line++;
	
	/* update debugger info */
	if (PERLDB_LINE && PL_curstash != PL_debstash) {
d4678 3
a4680 3
	    sv_setsv(sv,PL_linestr);
	    av_store(GvAV(PL_curcop->cop_filegv),
	      (I32)PL_curcop->cop_line, sv);
d4682 1
a4682 3
	
	/* having changed the buffer, we must update PL_bufend */
	PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
d4684 1
a4684 4
    
    /* at this point, we have successfully read the delimited string */

    PL_multi_end = PL_curcop->cop_line;
a4685 2

    /* if we allocated too much space, give some back */
d4690 2
a4691 7

    /* decide whether this is the first or second quoted string we've read
       for this op
    */
    
    if (PL_lex_stuff)
	PL_lex_repl = sv;
d4693 1
a4693 1
	PL_lex_stuff = sv;
a4696 22
/*
  scan_num
  takes: pointer to position in buffer
  returns: pointer to new position in buffer
  side-effects: builds ops for the constant in yylval.op

  Read a number in any of the formats that Perl accepts:

  0(x[0-7A-F]+)|([0-7]+)
  [\d_]+(\.[\d_]*)?[Ee](\d+)

  Underbars (_) are allowed in decimal numbers.  If -w is on,
  underbars before a decimal point must be at three digit intervals.

  Like most scan_ routines, it uses the PL_tokenbuf buffer to hold the
  thing it reads.

  If it reads a number without a decimal point or an exponent, it will
  try converting the number to an integer and see if it can do so
  without loss of precision.
*/
  
d4698 2
a4699 1
scan_num(char *start)
d4701 7
a4707 11
    register char *s = start;		/* current position in buffer */
    register char *d;			/* destination in temp buffer */
    register char *e;			/* end of temp buffer */
    I32 tryiv;				/* used to see if it can be an int */
    double value;			/* number read, as a double */
    SV *sv;				/* place to put the converted number */
    I32 floatit;			/* boolean: int or float? */
    char *lastub = 0;			/* position of last underbar */
    static char number_too_long[] = "Number too long";

    /* We use the first character to decide what type of number this is */
d4711 1
a4711 5
      croak("panic: scan_num");
      
    /* if it starts with a 0, it could be an octal number, a decimal in
       0.13 disguise, or a hexadecimal number.
    */
d4714 1
a4714 10
	  /* variables:
	     u		holds the "number so far"
	     shift	the power of 2 of the base (hex == 4, octal == 3)
	     overflowed	was the number more than we can hold?

	     Shift is used when we add a digit.  It also serves as an "are
	     we in octal or hex?" indicator to disallow hex characters when
	     in octal mode.
	   */
	    UV u;
a4715 1
	    bool overflowed = FALSE;
a4716 1
	    /* check for hex */
a4720 1
	    /* check for a decimal in disguise */
a4722 1
	    /* so it must be octal */
d4725 1
a4725 3
	    u = 0;

	    /* read the rest of the octal number */
a4726 2
		UV n, b;	/* n is used in the overflow test, b is the digit we're adding on */

a4727 2

		/* if we don't mention it, we're done */
a4729 2

		/* _ are ignored */
a4732 2

		/* 8 and 9 are not octal */
a4736 2

	        /* octal digits */
d4739 3
a4741 4
		    b = *s++ & 15;		/* ASCII digit -> value of digit */
		    goto digit;

	        /* hex digits */
a4743 1
		    /* make sure they said 0x */
d4746 2
a4747 15
		    b = (*s++ & 7) + 9;

		    /* Prepare to put the digit we have onto the end
		       of the number so far.  We check for overflows.
		    */

		  digit:
		    n = u << shift;	/* make room for the digit */
		    if (!overflowed && (n >> shift) != u
			&& !(PL_hints & HINT_NEW_BINARY)) {
			warn("Integer overflow in %s number",
			     (shift == 4) ? "hex" : "octal");
			overflowed = TRUE;
		    }
		    u = n | b;		/* add the digit to the end */
a4750 4

	  /* if we get here, we had success: make a scalar value from
	     the number.
	  */
d4753 5
a4757 3
	    sv_setuv(sv, u);
	    if ( PL_hints & HINT_NEW_BINARY)
		sv = new_constant(start, s - start, "binary", sv, Nullsv, NULL);
a4759 5

    /*
      handle decimal numbers.
      we're also sent here when we read a 0 as the first digit
    */
d4763 1
a4763 2
	d = PL_tokenbuf;
	e = PL_tokenbuf + sizeof PL_tokenbuf - 6; /* room for various punctuation */
a4764 2

	/* read next group of digits and _ and copy into d */
a4765 3
	    /* skip underscores, checking for misplaced ones 
	       if -w is on
	    */
d4767 1
a4767 1
		if (PL_dowarn && lastub && s - lastub != 3)
d4771 1
a4771 5
	    else {
	        /* check for end of fixed-length buffer */
		if (d >= e)
		    croak(number_too_long);
		/* if we're ok, copy the character */
a4772 1
	    }
d4774 1
a4774 3

	/* final misplaced underbar check */
	if (PL_dowarn && lastub && s - lastub != 3)
a4775 5

	/* read a decimal portion if there is one.  avoid
	   3..5 being interpreted as the number 3. followed
	   by .5
	*/
d4779 5
a4783 10

	    /* copy, ignoring underbars, until we run out of
	       digits.  Note: no misplaced underbar checks!
	    */
	    for (; isDIGIT(*s) || *s == '_'; s++) {
	        /* fixed length buffer check */
		if (d >= e)
		    croak(number_too_long);
		if (*s != '_')
		    *d++ = *s;
a4785 2

	/* read exponent part, if present */
a4788 2

	    /* regardless of whether user said 3E5 or 3e5, use lower 'e' */
a4789 2

	    /* allow positive or negative exponent */
d4792 1
a4792 5

	    /* read digits of exponent (no underbars :-) */
	    while (isDIGIT(*s)) {
		if (d >= e)
		    croak(number_too_long);
a4793 1
	    }
a4794 2

	/* terminate the string */
a4795 2

	/* make an sv from the string */
d4797 4
a4800 17
	/* reset numeric locale in case we were earlier left in Swaziland */
	SET_NUMERIC_STANDARD();
	value = atof(PL_tokenbuf);

	/* 
	   See if we can make do with an integer value without loss of
	   precision.  We use I_V to cast to an int, because some
	   compilers have issues.  Then we try casting it back and see
	   if it was the same.  We only do this if we know we
	   specifically read an integer.

	   Note: if floatit is true, then we don't need to do the
	   conversion at all.
	*/
	tryiv = I_V(value);
	if (!floatit && (double)tryiv == value)
	    sv_setiv(sv, tryiv);
d4802 1
a4802 4
	    sv_setnv(sv, value);
	if ( floatit ? (PL_hints & HINT_NEW_FLOAT) : (PL_hints & HINT_NEW_INTEGER) )
	    sv = new_constant(PL_tokenbuf, d - PL_tokenbuf, 
			      (floatit ? "float" : "integer"), sv, Nullsv, NULL);
a4805 2
    /* make the op for the constant and return */

d4811 3
a4813 2
STATIC char *
scan_formline(register char *s)
a4814 1
    dTHR;
d4823 2
a4824 6
#ifdef PERL_STRICT_CR
	    for (t = s+1;*t == ' ' || *t == '\t'; t++) ;
#else
	    for (t = s+1;*t == ' ' || *t == '\t' || *t == '\r'; t++) ;
#endif
	    if (*t == '\n' || t == PL_bufend)
d4827 1
a4827 1
	if (PL_in_eval && !PL_rsfp) {
d4830 1
a4830 1
		eol = PL_bufend;
d4833 1
a4833 1
	    eol = PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
d4846 4
a4849 4
	if (PL_rsfp) {
	    s = filter_gets(PL_linestr, PL_rsfp, 0);
	    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = SvPVX(PL_linestr);
	    PL_bufend = PL_bufptr + SvCUR(PL_linestr);
d4851 1
a4851 1
		s = PL_bufptr;
d4860 1
a4860 1
	PL_expect = XTERM;
d4862 2
a4863 2
	    PL_lex_state = LEX_NORMAL;
	    PL_nextval[PL_nexttoke].ival = 0;
d4867 2
a4868 2
	    PL_lex_state = LEX_FORMLINE;
	PL_nextval[PL_nexttoke].opval = (OP*)newSVOP(OP_CONST, 0, stuff);
d4870 1
a4870 1
	PL_nextval[PL_nexttoke].ival = OP_FORMLINE;
d4875 2
a4876 2
	PL_lex_formbrack = 0;
	PL_bufptr = s;
d4881 2
a4882 2
STATIC void
set_csh(void)
d4885 2
a4886 2
    if (!PL_cshlen)
	PL_cshlen = strlen(PL_cshname);
d4890 2
a4891 2
I32
start_subparse(I32 is_format, U32 flags)
d4893 2
a4894 3
    dTHR;
    I32 oldsavestack_ix = PL_savestack_ix;
    CV* outsidecv = PL_compcv;
d4897 2
a4898 2
    if (PL_compcv) {
	assert(SvTYPE(PL_compcv) == SVt_PVCV);
d4900 23
a4922 29
    save_I32(&PL_subline);
    save_item(PL_subname);
    SAVEI32(PL_padix);
    SAVESPTR(PL_curpad);
    SAVESPTR(PL_comppad);
    SAVESPTR(PL_comppad_name);
    SAVESPTR(PL_compcv);
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);
    SAVEI32(PL_pad_reset_pending);

    PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)PL_compcv, is_format ? SVt_PVFM : SVt_PVCV);
    CvFLAGS(PL_compcv) |= flags;

    PL_comppad = newAV();
    av_push(PL_comppad, Nullsv);
    PL_curpad = AvARRAY(PL_comppad);
    PL_comppad_name = newAV();
    PL_comppad_name_fill = 0;
    PL_min_intro_pending = 0;
    PL_padix = 0;
    PL_subline = PL_curcop->cop_line;
#ifdef USE_THREADS
    av_store(PL_comppad_name, 0, newSVpv("@@_", 2));
    PL_curpad[0] = (SV*)newAV();
    SvPADMY_on(PL_curpad[0]);	/* XXX Needed? */
#endif /* USE_THREADS */
d4926 2
a4927 2
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
d4929 2
a4930 7
    CvPADLIST(PL_compcv) = comppadlist;
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc(outsidecv);
#ifdef USE_THREADS
    CvOWNER(PL_compcv) = 0;
    New(666, CvMUTEXP(PL_compcv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(PL_compcv));
#endif /* USE_THREADS */
d4936 2
a4937 1
yywarn(char *s)
d4939 2
a4940 3
    dTHR;
    --PL_error_count;
    PL_in_eval |= 2;
d4942 1
a4942 1
    PL_in_eval &= ~2;
d4947 2
a4948 1
yyerror(char *s)
d4950 14
a4963 21
    dTHR;
    char *where = NULL;
    char *context = NULL;
    int contlen = -1;
    SV *msg;

    if (!yychar || (yychar == ';' && !PL_rsfp))
	where = "at EOF";
    else if (PL_bufptr > PL_oldoldbufptr && PL_bufptr - PL_oldoldbufptr < 200 &&
      PL_oldoldbufptr != PL_oldbufptr && PL_oldbufptr != PL_bufptr) {
	while (isSPACE(*PL_oldoldbufptr))
	    PL_oldoldbufptr++;
	context = PL_oldoldbufptr;
	contlen = PL_bufptr - PL_oldoldbufptr;
    }
    else if (PL_bufptr > PL_oldbufptr && PL_bufptr - PL_oldbufptr < 200 &&
      PL_oldbufptr != PL_bufptr) {
	while (isSPACE(*PL_oldbufptr))
	    PL_oldbufptr++;
	context = PL_oldbufptr;
	contlen = PL_bufptr - PL_oldbufptr;
d4966 3
a4968 1
	where = "next token ???";
d4970 5
a4974 5
	if (PL_lex_state == LEX_NORMAL ||
	   (PL_lex_state == LEX_KNOWNEXT && PL_lex_defer == LEX_NORMAL))
	    where = "at end of line";
	else if (PL_lex_inpat)
	    where = "within pattern";
d4976 1
a4976 1
	    where = "within string";
d4978 2
a4979 15
    else {
	SV *where_sv = sv_2mortal(newSVpv("next char ", 0));
	if (yychar < 32)
	    sv_catpvf(where_sv, "^%c", toCTRL(yychar));
	else if (isPRINT_LC(yychar))
	    sv_catpvf(where_sv, "%c", yychar);
	else
	    sv_catpvf(where_sv, "\\%03o", yychar & 255);
	where = SvPVX(where_sv);
    }
    msg = sv_2mortal(newSVpv(s, 0));
    sv_catpvf(msg, " at %_ line %ld, ",
	      GvSV(PL_curcop->cop_filegv), (long)PL_curcop->cop_line);
    if (context)
	sv_catpvf(msg, "near \"%.*s\"\n", contlen, context);
d4981 13
a4993 11
	sv_catpvf(msg, "%s\n", where);
    if (PL_multi_start < PL_multi_end && (U32)(PL_curcop->cop_line - PL_multi_end) <= 1) {
	sv_catpvf(msg,
	"  (Might be a runaway multi-line %c%c string starting on line %ld)\n",
		(int)PL_multi_open,(int)PL_multi_close,(long)PL_multi_start);
        PL_multi_end = 0;
    }
    if (PL_in_eval & 2)
	warn("%_", msg);
    else if (PL_in_eval)
	sv_catsv(ERRSV, msg);
d4995 5
a4999 5
	PerlIO_write(PerlIO_stderr(), SvPVX(msg), SvCUR(msg));
    if (++PL_error_count >= 10)
	croak("%_ has too many errors.\n", GvSV(PL_curcop->cop_filegv));
    PL_in_my = 0;
    PL_in_my_stash = Nullhv;
a5001 2


@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a13 7
/*
 * This file is the lexer for Perl.  It's closely linked to the
 * parser, perly.y.  
 *
 * The main routine is yylex(), which returns the next token.
 */

a14 1
#define PERL_IN_TOKE_C
d17 43
a59 2
#define yychar	PL_yychar
#define yylval	PL_yylval
d63 1
a63 14
static void restore_rsfp(pTHXo_ void *f);

#define XFAKEBRACK 128
#define XENUMMASK 127

/*#define UTF (SvUTF8(PL_linestr) && !(PL_hints & HINT_BYTE))*/
#define UTF (PL_hints & HINT_UTF8)

/* In variables name $^X, these are the legal values for X.  
 * 1999-02-27 mjd-perl-patch@@plover.com */
#define isCONTROLVAR(x) (isUPPER(x) || strchr("[\\]^_?", (x)))

/* LEX_* are values for PL_lex_state, the state of the lexer.
 * They are arranged oddly so that the guard on the switch statement
d81 7
a97 12
#ifdef USE_PURE_BISON
YYSTYPE* yylval_pointer = NULL;
int* yychar_pointer = NULL;
#  undef yylval
#  undef yychar
#  define yylval (*yylval_pointer)
#  define yychar (*yychar_pointer)
#  define PERL_YYLEX_PARAM yylval_pointer,yychar_pointer
#  undef yylex
#  define yylex()	Perl_yylex(aTHX_ yylval_pointer, yychar_pointer)
#endif

a99 2
/* CLINE is a macro that ensures PL_copline has a sane value */

d103 1
a103 29
#define CLINE (PL_copline = (CopLINE(PL_curcop) < PL_copline ? CopLINE(PL_curcop) : PL_copline))

/*
 * Convenience functions to return different tokens and prime the
 * lexer for the next token.  They all take an argument.
 *
 * TOKEN        : generic token (used for '(', DOLSHARP, etc)
 * OPERATOR     : generic operator
 * AOPERATOR    : assignment operator
 * PREBLOCK     : beginning the block after an if, while, foreach, ...
 * PRETERMBLOCK : beginning a non-code-defining {} block (eg, hash ref)
 * PREREF       : *EXPR where EXPR is not a simple identifier
 * TERM         : expression term
 * LOOPX        : loop exiting command (goto, last, dump, etc)
 * FTST         : file test operator
 * FUN0         : zero-argument function
 * FUN1         : not used, except for not, which isn't a UNIOP
 * BOop         : bitwise or or xor
 * BAop         : bitwise and
 * SHop         : shift operator
 * PWop         : power operator
 * PMop         : pattern-matching operator
 * Aop          : addition-level operator
 * Mop          : multiplication-level operator
 * Eop          : equality-testing operator
 * Rop        : relational operator <= != gt
 *
 * Also see LOP and lop() below.
 */
a143 7
/*
 * S_ao
 *
 * This subroutine detects &&= and ||= and turns an ANDAND or OROR
 * into an OP_ANDASSIGN or OP_ORASSIGN
 */

d145 1
a145 1
S_ao(pTHX_ int toketype)
a157 13
/*
 * S_no_op
 * When Perl expects an operator and finds something else, no_op
 * prints the warning.  It always prints "<something> found where
 * operator expected.  It prints "Missing semicolon on previous line?"
 * if the surprise occurs at the start of the line.  "do you need to
 * predeclare ..." is printed out for code like "sub bar; foo bar $x"
 * where the compiler doesn't know if foo is a method call or a function.
 * It prints "Missing operator before end of line" if there's nothing
 * after the missing operator, or "... before <...>" if there is something
 * after the missing operator.
 */

d159 1
a159 1
S_no_op(pTHX_ char *what, char *s)
d164 2
a165 7
    if (!s)
	s = oldbp;
    else {
	assert(s >= oldbp);
	PL_bufptr = s;
    }
    yywarn(Perl_form(aTHX_ "%s found where operator expected", what));
d167 2
a168 2
	Perl_warn(aTHX_ "\t(Missing semicolon on previous line?)\n");
    else if (PL_oldoldbufptr && isIDFIRST_lazy_if(PL_oldoldbufptr,UTF)) {
d170 1
a170 1
	for (t = PL_oldoldbufptr; *t && (isALNUM_lazy_if(t,UTF) || *t == ':'); t++) ;
d172 1
a172 1
	    Perl_warn(aTHX_ "\t(Do you need to predeclare %.*s?)\n",
d174 1
d177 1
a177 1
	Perl_warn(aTHX_ "\t(Missing operator before %.*s?)\n", s - oldbp, oldbp);
a180 9
/*
 * S_missingterm
 * Complain about missing quote/regexp/heredoc terminator.
 * If it's called with (char *)NULL then it cauterizes the line buffer.
 * If we're in a delimited string and the delimiter is a control
 * character, it's reformatted into a two-char sequence like ^C.
 * This is fatal.
 */

d182 1
a182 1
S_missingterm(pTHX_ char *s)
d210 1
a210 1
    Perl_croak(aTHX_ "Can't find string terminator %c%s%c anywhere before EOF",q,s,q);
a212 4
/*
 * Perl_deprecate
 */

d214 1
a214 1
Perl_deprecate(pTHX_ char *s)
d216 2
a217 3
    dTHR;
    if (ckWARN(WARN_DEPRECATED))
	Perl_warner(aTHX_ WARN_DEPRECATED, "Use of %s is deprecated", s);
a219 5
/*
 * depcom
 * Deprecate a comma-less variable list.
 */

d221 1
a221 1
S_depcom(pTHX)
d226 1
a226 52
/*
 * experimental text filters for win32 carriage-returns, utf16-to-utf8 and
 * utf16-to-utf8-reversed.
 */

#ifdef PERL_CR_FILTER
static void
strip_return(SV *sv)
{
    register char *s = SvPVX(sv);
    register char *e = s + SvCUR(sv);
    /* outer loop optimized to do nothing if there are no CR-LFs */
    while (s < e) {
	if (*s++ == '\r' && *s == '\n') {
	    /* hit a CR-LF, need to copy the rest */
	    register char *d = s - 1;
	    *d++ = *s++;
	    while (s < e) {
		if (*s == '\r' && s[1] == '\n')
		    s++;
		*d++ = *s++;
	    }
	    SvCUR(sv) -= s - d;
	    return;
	}
    }
}

STATIC I32
S_cr_textfilter(pTHX_ int idx, SV *sv, int maxlen)
{
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count > 0 && !maxlen)
	strip_return(sv);
    return count;
}
#endif

#if 0
STATIC I32
S_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
{
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count) {
	U8* tmps;
	U8* tend;
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	tend = utf16_to_utf8((U16*)SvPVX(sv), tmps, SvCUR(sv));
	sv_usepvn(sv, (char*)tmps, tend - tmps);
    }
    return count;
}
d229 1
a229 1
S_utf16rev_textfilter(pTHX_ int idx, SV *sv, int maxlen)
d231 4
a234 9
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count) {
	U8* tmps;
	U8* tend;
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	tend = utf16_to_utf8_reversed((U16*)SvPVX(sv), tmps, SvCUR(sv));
	sv_usepvn(sv, (char*)tmps, tend - tmps);
    }
    return count;
a237 5
/*
 * Perl_lex_start
 * Initialize variables.  Uses the Perl save_stack to save its state (for
 * recursive calls to the parser).
 */
d240 1
a240 1
Perl_lex_start(pTHX_ SV *line)
d248 1
d252 1
a252 1
    SAVEVPTR(PL_lex_inpat);
d254 1
a254 10
    if (PL_lex_state == LEX_KNOWNEXT) {
	I32 toke = PL_nexttoke;
	while (--toke >= 0) {
	    SAVEI32(PL_nexttype[toke]);
	    SAVEVPTR(PL_nextval[toke]);
	}
	SAVEI32(PL_nexttoke);
	PL_nexttoke = 0;
    }
    SAVECOPLINE(PL_curcop);
d263 1
a263 1
    SAVEDESTRUCTOR_X(restore_rsfp, PL_rsfp);
a265 1
    SAVEI32(PL_sublex_info.sub_inwhat);
d267 2
a268 2
    SAVEINT(PL_expect);
    SAVEINT(PL_lex_expect);
d274 1
a286 1
    PL_sublex_info.sub_inwhat = 0;
d300 1
a300 1
    PL_rs = newSVpvn("\n", 1);
a303 6
/*
 * Perl_lex_end
 * Finalizer for lexing operations.  Must be called when the parser is
 * done with the lexer.
 */

d305 1
a305 1
Perl_lex_end(pTHX)
d310 25
a334 9
/*
 * S_incline
 * This subroutine has nothing to do with tilting, whether at windmills
 * or pinball tables.  Its name is short for "increment line".  It
 * increments the current line number in CopLINE(PL_curcop) and checks
 * to see whether the line starts with a comment of the form
 *    # line 500 "foo.pm"
 * If so, it sets the current line number and file to the values in the comment.
 */
d337 1
a337 1
S_incline(pTHX_ char *s)
a341 1
    char *e;
d343 1
d345 1
a345 1
    CopLINE_inc(PL_curcop);
d349 4
a352 9
    if (strnEQ(s, "line", 4))
	s += 4;
    else
	return;
    if (*s == ' ' || *s == '\t')
	s++;
    else 
	return;
    while (*s == ' ' || *s == '\t') s++;
d360 1
a360 1
    if (*s == '"' && (t = strchr(s+1, '"'))) {
a361 2
	e = t + 1;
    }
d363 2
a365 1
	e = t;
a366 5
    while (*e == ' ' || *e == '\t' || *e == '\r' || *e == '\f')
	e++;
    if (*e != '\n' && *e != '\0')
	return;		/* false alarm */

d370 3
a372 1
	CopFILE_set(PL_curcop, s);
d374 1
a374 1
    CopLINE_set(PL_curcop, atoi(n)-1);
a376 6
/*
 * S_skipspace
 * Called to gobble the appropriate amount and type of whitespace.
 * Skips comments as well.
 */

d378 1
a378 1
S_skipspace(pTHX_ register char *s)
a387 2
	SSize_t oldprevlen, oldoldprevlen;
	SSize_t oldloplen, oldunilen;
a391 2

	/* comment */
d403 1
a403 7

	/* only continue to recharge the buffer if we're at the end
	 * of the buffer, we're not reading from a source filter, and
	 * we're in normal lexing mode
	 */
	if (s < PL_bufend || !PL_rsfp || PL_sublex_info.sub_inwhat ||
		PL_lex_state == LEX_FORMLINE)
d405 1
a405 6

	/* try to recharge the buffer */
	if ((s = filter_gets(PL_linestr, PL_rsfp,
			     (prevlen = SvCUR(PL_linestr)))) == Nullch)
	{
	    /* end of file.  Add on the -p or -n magic */
d415 1
a415 4

	    /* reset variables for next time we lex */
	    PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = s = PL_linestart
		= SvPVX(PL_linestr);
a416 8

	    /* Close the filehandle.  Could be from -P preprocessor,
	     * STDIN, or a regular file.  If we were reading code from
	     * STDIN (because the commandline held no -e or filename)
	     * then we don't close it, we reset it so the code can
	     * read from STDIN too.
	     */

a425 9

	/* not at end of file, so we only read another line */
	/* make corresponding updates to old pointers, for yyerror() */
	oldprevlen = PL_oldbufptr - PL_bufend;
	oldoldprevlen = PL_oldoldbufptr - PL_bufend;
	if (PL_last_uni)
	    oldunilen = PL_last_uni - PL_bufend;
	if (PL_last_lop)
	    oldloplen = PL_last_lop - PL_bufend;
a428 6
	PL_oldbufptr = s + oldprevlen;
	PL_oldoldbufptr = s + oldoldprevlen;
	if (PL_last_uni)
	    PL_last_uni = s + oldunilen;
	if (PL_last_lop)
	    PL_last_lop = s + oldloplen;
a429 4

	/* debugger active and we're not compiling the debugger code,
	 * so store the line into the debugger's array of lines
	 */
d435 1
a435 1
	    av_store(CopFILEAV(PL_curcop),(I32)CopLINE(PL_curcop),sv);
a439 9
/*
 * S_check_uni
 * Check the unary operators to ensure there's no ambiguity in how they're
 * used.  An ambiguous piece of code would be:
 *     rand + 5
 * This doesn't mean rand() + 5.  Because rand() is a unary operator,
 * the +5 is its argument.
 */

d441 1
a441 2
S_check_uni(pTHX)
{
d443 1
a444 1
    dTHR;
d450 1
a450 1
    for (s = PL_last_uni; isALNUM_lazy_if(s,UTF) || *s == '-'; s++) ;
d453 4
a456 8
    if (ckWARN_d(WARN_AMBIGUOUS)){
        char ch = *s;
        *s = '\0';
        Perl_warner(aTHX_ WARN_AMBIGUOUS, 
		   "Warning: Use of \"%s\" without parens is ambiguous", 
		   PL_last_uni);
        *s = ch;
    }
a458 5
/* workaround to replace the UNI() macro with a function.  Only the
 * hints/uts.sh file mentions this.  Other comments elsewhere in the
 * source indicate Microport Unix might need it too.
 */

d465 1
a465 1
S_uni(pTHX_ I32 f, char *s)
a482 5
/*
 * LOP : macro to build a list operator.  Its behaviour has been replaced
 * with a subroutine, S_lop() for which LOP is just another name.
 */

a484 8
/*
 * S_lop
 * Build a list operator (or something that might be one).  The rules:
 *  - if we have a next token, then it's a list operator [why?]
 *  - if the next thing is an opening paren, then it's a function
 *  - else it's a list operator
 */

d486 1
a486 1
S_lop(pTHX_ I32 f, int x, char *s)
a505 9
/*
 * S_force_next
 * When the lexer realizes it knows the next token (for instance,
 * it is reordering tokens for the parser) then it can call S_force_next
 * to know what token to return the next time the lexer is called.  Caller
 * will need to set PL_nextval[], and possibly PL_expect to ensure the lexer
 * handles the token correctly.
 */

d507 1
a507 1
S_force_next(pTHX_ I32 type)
a517 16
/*
 * S_force_word
 * When the lexer knows the next thing is a word (for instance, it has
 * just seen -> and it knows that the next char is a word char, then
 * it calls S_force_word to stick the next word into the PL_next lookahead.
 *
 * Arguments:
 *   char *start : buffer position (must be within PL_linestr)
 *   int token   : PL_next will be this type of bare word (e.g., METHOD,WORD)
 *   int check_keyword : if true, Perl checks to make sure the word isn't
 *       a keyword (do this if the word is a label, e.g. goto FOO)
 *   int allow_pack : if true, : characters will also be allowed (require,
 *       use, etc. do this)
 *   int allow_initial_tick : used by the "sub" lexer only.
 */

d519 1
a519 1
S_force_word(pTHX_ register char *start, int token, int check_keyword, int allow_pack, int allow_initial_tick)
d526 1
a526 1
    if (isIDFIRST_lazy_if(s,UTF) ||
d539 2
a549 9
/*
 * S_force_ident
 * Called when the lexer wants $foo *foo &foo etc, but the program
 * text only contains the "foo" portion.  The first argument is a pointer
 * to the "foo", and the second argument is the type symbol to prefix.
 * Forces the next token to be a "WORD".
 * Creates the symbol if it didn't already exist (via gv_fetchpv()).
 */

d551 1
a551 1
S_force_ident(pTHX_ register char *s, int kind)
a572 30
NV
Perl_str_to_version(pTHX_ SV *sv)
{
    NV retval = 0.0;
    NV nshift = 1.0;
    STRLEN len;
    char *start = SvPVx(sv,len);
    bool utf = SvUTF8(sv);
    char *end = start + len;
    while (start < end) {
	I32 skip;
	UV n;
	if (utf)
	    n = utf8_to_uv((U8*)start, &skip);
	else {
	    n = *(U8*)start;
	    skip = 1;
	}
	retval += ((NV)n)/nshift;
	start += skip;
	nshift *= 1000;
    }
    return retval;
}

/* 
 * S_force_version
 * Forces the next token to be a version number.
 */

d574 1
a574 1
S_force_version(pTHX_ char *s)
a576 1
    char *d;
d580 7
a586 7
    d = s;
    if (*d == 'v')
	d++;
    if (isDIGIT(*d)) {
        for (; isDIGIT(*d) || *d == '_' || *d == '.'; d++);
        if (*d == ';' || isSPACE(*d) || *d == '}' || !*d) {
	    SV *ver;
d588 1
a589 6
	    ver = cSVOPx(version)->op_sv;
	    if (SvPOK(ver) && !SvNIOK(ver)) {
		(void)SvUPGRADE(ver, SVt_PVNV);
		SvNVX(ver) = str_to_version(ver);
		SvNOK_on(ver);		/* hint that it is a version */
	    }
a599 8
/*
 * S_tokeq
 * Tokenize a quoted string passed in as an SV.  It finds the next
 * chunk, up to end of string or a backslash.  It may make a new
 * SV containing that chunk (if HINT_NEW_STRING is on).  It also
 * turns \\ into \.
 */

d601 1
a601 1
S_tokeq(pTHX_ SV *sv)
d622 1
a622 1
	pv = sv_2mortal(newSVpvn(SvPVX(pv), len));
a637 32
/*
 * Now come three functions related to double-quote context,
 * S_sublex_start, S_sublex_push, and S_sublex_done.  They're used when
 * converting things like "\u\Lgnat" into ucfirst(lc("gnat")).  They
 * interact with PL_lex_state, and create fake ( ... ) argument lists
 * to handle functions and concatenation.
 * They assume that whoever calls them will be setting up a fake
 * join call, because each subthing puts a ',' after it.  This lets
 *   "lower \luPpEr"
 * become
 *  join($, , 'lower ', lcfirst( 'uPpEr', ) ,)
 *
 * (I'm not sure whether the spurious commas at the end of lcfirst's
 * arguments and join's arguments are created or not).
 */

/*
 * S_sublex_start
 * Assumes that yylval.ival is the op we're creating (e.g. OP_LCFIRST).
 *
 * Pattern matching will set PL_lex_op to the pattern-matching op to
 * make (we return THING if yylval.ival is OP_NULL, PMFUNC otherwise).
 *
 * OP_CONST and OP_READLINE are easy--just make the new op and return.
 *
 * Everything else becomes a FUNC.
 *
 * Sets PL_lex_state to LEX_INTERPPUSH unless (ival was OP_NULL or we
 * had an OP_CONST or OP_READLINE).  This just sets us up for a
 * call to S_sublex_push().
 */

d639 1
a639 1
S_sublex_start(pTHX)
d658 1
a658 1
	    nsv = newSVpvn(p, len);
a681 8
/*
 * S_sublex_push
 * Create a new scope to save the lexing state.  The scope will be
 * ended in S_sublex_done.  Returns a '(', starting the function arguments
 * to the uc, lc, etc. found before.
 * Sets PL_lex_state to LEX_INTERPCONCAT.
 */

d683 1
a683 1
S_sublex_push(pTHX)
d691 1
d695 1
a695 1
    SAVEVPTR(PL_lex_inpat);
d697 1
a697 1
    SAVECOPLINE(PL_curcop);
d709 1
a709 2
    PL_bufend = PL_bufptr = PL_oldbufptr = PL_oldoldbufptr = PL_linestart
	= SvPVX(PL_linestr);
d715 1
d724 1
a724 1
    CopLINE_set(PL_curcop, PL_multi_start);
a734 5
/*
 * S_sublex_done
 * Restores lexer state after a S_sublex_push.
 */

d736 1
a736 1
S_sublex_done(pTHX)
d740 1
a740 1
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpvn("",0));
d749 1
a749 1
    /* Is there a right-hand side to take care of? (s//RHS/ or tr//RHS/) */
d758 1
d762 1
a762 1
	if (SvEVALED(PL_lex_repl)) {
a764 4
	    /*	we don't clear PL_lex_repl here, so that we can check later
		whether this is an evalled subst; that means we rely on the
		logic to ensure sublex_done() is called again only via the
		branch (in yylex()) that clears PL_lex_repl, else we'll loop */
d766 1
a766 1
	else {
d768 1
a768 2
	    PL_lex_repl = Nullsv;
	}
a775 1
	PL_sublex_info.sub_inwhat = 0;
d854 1
a854 1
S_scan_const(pTHX_ char *start)
a860 1
    bool has_utf = FALSE;			/* embedded \x{} */
a861 1
    UV uv;
d863 2
a864 8
    I32 utf = (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op)
	? (PL_sublex_info.sub_op->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF))
	: UTF;
    I32 thisutf = (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op)
	? (PL_sublex_info.sub_op->op_private & (PL_lex_repl ?
						OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF))
	: UTF;
    const char *leaveit =	/* set of acceptably-backslashed characters */
d866 1
a866 1
	    ? "\\.^$@@AGZdDwWsSbBpPXC+*?|()-nrtfeaxcz0123456789[{]} \t\n\r\f\v#"
d879 2
a880 2
		SvGROW(sv, SvLEN(sv) + 256);	/* never more than 256 chars in a range */
		d = SvPVX(sv) + i;		/* refresh d after realloc */
a910 5
		if (utf) {
		    *d++ = (char)0xff;	/* use illegal utf8 byte--see pmtrans */
		    s++;
		    continue;
		}
d918 1
a918 2
	/* skip for regexp comments /(?#comment)/ and code /(?{code})/,
	   except for the last char, which will be done separately. */
d923 1
a923 4
	    }
	    else if (s[2] == '{' /* This should match regcomp.c */
		     || ((s[2] == 'p' || s[2] == '?') && s[3] == '{'))
	    {
d925 1
a925 1
		char *regparse = s + (s[2] == '{' ? 3 : 4);
d937 3
a939 2
		if (*regparse != ')') {
		    regparse--;		/* Leave one char for continuation. */
d941 1
a941 2
		}
		while (s < regparse)
d954 1
a954 2
	else if (*s == '@@' && s[1]
		 && (isALNUM_lazy_if(s+1,UTF) || strchr(":'{$", s[1])))
a966 19
	/* (now in tr/// code again) */

	if (*s & 0x80 && thisutf) {
	   (void)utf8_to_uv((U8*)s, &len);
	   if (len == 1) {
	       /* illegal UTF8, make it valid */
	       char *old_pvx = SvPVX(sv);
	       /* need space for one extra char (NOTE: SvCUR() not set here) */
	       d = SvGROW(sv, SvLEN(sv) + 1) + (d - old_pvx);
	       d = (char*)uv_to_utf8((U8*)d, (U8)*s++);
	   }
	   else {
	       while (len--)
		   *d++ = *s++;
	   }
	   has_utf = TRUE;
	   continue;
	}

d972 1
a972 1
	    if (*leaveit && *s && strchr(leaveit, *s)) {
d982 2
a983 3
		dTHR;			/* only for ckWARN */
		if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ WARN_SYNTAX, "\\%c better written as $%c", *s, *s);
d1004 1
d1006 2
a1007 10
	        {
		    dTHR;
		    if (ckWARN(WARN_MISC) && isALPHA(*s))
			Perl_warner(aTHX_ WARN_MISC, 
			       "Unrecognized escape \\%c passed through",
			       *s);
		    /* default action is to copy the quoted character */
		    *d++ = *s++;
		    continue;
		}
d1012 1
a1012 1
		uv = (UV)scan_oct(s, 3, &len);
d1014 1
a1014 1
		goto NUM_ESCAPE_INSERT;
d1018 2
a1019 106
		++s;
		if (*s == '{') {
		    char* e = strchr(s, '}');
		    if (!e) {
			yyerror("Missing right brace on \\x{}");
			e = s;
		    }
                    uv = (UV)scan_hex(s + 1, e - s - 1, &len);
                    s = e + 1;
		}
		else {
		    uv = (UV)scan_hex(s, 2, &len);
		    s += len;
		}

	      NUM_ESCAPE_INSERT:
		/* Insert oct or hex escaped character.
		 * There will always enough room in sv since such escapes will
		 * be longer than any utf8 sequence they can end up as
		 */
		if (uv > 127) {
		    if (!thisutf && !has_utf && uv > 255) {
		        /* might need to recode whatever we have accumulated so far
			 * if it contains any hibit chars
			 */
		        int hicount = 0;
			char *c;
			for (c = SvPVX(sv); c < d; c++) {
			    if (*c & 0x80)
			        hicount++;
			}
			if (hicount) {
			    char *old_pvx = SvPVX(sv);
			    char *src, *dst;
			    d = SvGROW(sv, SvCUR(sv) + hicount + 1) + (d - old_pvx);

			    src = d - 1;
			    d += hicount;
			    dst = d - 1;

			    while (src < dst) {
			        if (*src & 0x80) {
				    dst--;
				    uv_to_utf8((U8*)dst, (U8)*src--);
				    dst--;
			        }
			        else {
				    *dst-- = *src--;
			        }
			    }
                        }
                    }

                    if (thisutf || uv > 255) {
		        d = (char*)uv_to_utf8((U8*)d, uv);
			has_utf = TRUE;
                    }
		    else {
		        *d++ = (char)uv;
		    }
		}
		else {
		    *d++ = (char)uv;
		}
		continue;

 	    /* \N{latin small letter a} is a named character */
 	    case 'N':
 		++s;
 		if (*s == '{') {
 		    char* e = strchr(s, '}');
 		    SV *res;
 		    STRLEN len;
 		    char *str;
 
 		    if (!e) {
			yyerror("Missing right brace on \\N{}");
			e = s - 1;
			goto cont_scan;
		    }
		    res = newSVpvn(s + 1, e - s - 1);
		    res = new_constant( Nullch, 0, "charnames", 
					res, Nullsv, "\\N{...}" );
		    str = SvPV(res,len);
		    if (!has_utf && SvUTF8(res)) {
			char *ostart = SvPVX(sv);
			SvCUR_set(sv, d - ostart);
			SvPOK_on(sv);
			sv_utf8_upgrade(sv);
			d = SvPVX(sv) + SvCUR(sv);
			has_utf = TRUE;
		    }
		    if (len > e - s + 4) {
			char *odest = SvPVX(sv);

			SvGROW(sv, (SvCUR(sv) + len - (e - s + 4)));
			d = SvPVX(sv) + (d - odest);
		    }
		    Copy(str, d, len, char);
		    d += len;
		    SvREFCNT_dec(res);
		  cont_scan:
		    s = e + 1;
		}
		else
		    yyerror("Missing braces on \\N{}");
a1051 8
#ifdef EBCDIC
	    case 'e':
		*d++ = '\047';  /* CP 1047 */
		break;
	    case 'a':
		*d++ = '\057';  /* CP 1047 */
		break;
#else
a1057 1
#endif
a1070 2
    if (has_utf)
	SvUTF8_on(sv);
a1093 19
/* S_intuit_more
 * Returns TRUE if there's more to the expression (e.g., a subscript),
 * FALSE otherwise.
 *
 * It deals with "$foo[3]" and /$foo[3]/ and /$foo[0123456789$]+/
 *
 * ->[ and ->{ return TRUE
 * { and [ outside a pattern are always subscripts, so return TRUE
 * if we're outside a pattern and it's not { or [, then return FALSE
 * if we're in a pattern and the first char is a {
 *   {4,5} (any digits around the comma) returns FALSE
 * if we're in a pattern and the first char is a [
 *   [] returns FALSE
 *   [SOMETHING] has a funky algorithm to decide whether it's a
 *      character class or not.  It has to deal with things like
 *      /$foo[-3]/ and /$foo[$bar]/ as well as /$foo[$\d]+/
 * anything else returns TRUE
 */

a1094 1

d1096 1
a1096 1
S_intuit_more(pTHX_ register char *s)
a1129 1
        /* this is terrifying, and it works */
d1158 1
a1158 1
		if (isALNUM_lazy_if(s+1,UTF)) {
a1224 21
/*
 * S_intuit_method
 *
 * Does all the checking to disambiguate
 *   foo bar
 * between foo(bar) and bar->foo.  Returns 0 if not a method, otherwise
 * FUNCMETH (bar->foo(args)) or METHOD (bar->foo args).
 *
 * First argument is the stuff after the first token, e.g. "bar".
 *
 * Not a method if bar is a filehandle.
 * Not a method if foo is a subroutine prototyped to take a filehandle.
 * Not a method if it's really "Foo $bar"
 * Method if it's "foo $bar"
 * Not a method if it's really "print foo $bar"
 * Method if it's really "foo package::" (interpreted as package->foo)
 * Not a method if bar is known to be a subroutne ("sub bar; foo bar")
 * Not a method if bar is a filehandle or package, but is quoted with
 *   =>
 */

d1226 1
a1226 1
S_intuit_method(pTHX_ char *start, GV *gv)
a1248 5
    /* start is the beginning of the possible filehandle/object,
     * and s is the end of it
     * tmpbuf is a copy of it
     */

d1273 1
a1273 1
						   newSVpvn(tmpbuf,len));
a1283 7
/*
 * S_incl_perldb
 * Return a string of Perl code to load the debugger.  If PERL5DB
 * is set, it will return the contents of that, otherwise a
 * compile-time require of perl5db.pl.
 */

d1285 1
a1285 1
S_incl_perldb(pTHX)
d1310 1
a1310 2
 * and the IoDIRP field is used to store the function pointer,
 * and IOf_FAKE_DIRP is enabled on datasv to mark this as such.
d1314 3
d1319 1
a1319 1
Perl_filter_add(pTHX_ filter_t funcp, SV *datasv)
d1321 4
a1324 3
    if (!funcp)
	return Nullsv;

d1330 1
a1330 1
        Perl_die(aTHX_ "Can't upgrade filter_add data to SVt_PVIO");
d1332 4
a1335 3
    IoFLAGS(datasv) |= IOf_FAKE_DIRP;
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_add func %p (%s)\n",
			  funcp, SvPV_nolen(datasv)));
d1344 1
a1344 1
Perl_filter_del(pTHX_ filter_t funcp)
d1346 2
a1347 2
    SV *datasv;
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p", funcp));
d1351 1
a1351 4
    datasv = FILTER_DATA(AvFILLp(PL_rsfp_filters));
    if (IoDIRP(datasv) == (DIR*)funcp) {
	IoFLAGS(datasv) &= ~IOf_FAKE_DIRP;
	IoDIRP(datasv) = (DIR*)NULL;
d1357 1
a1357 1
    Perl_die(aTHX_ "filter_del can only delete in reverse order (currently)");
d1363 1
a1363 1
Perl_filter_read(pTHX_ int idx, SV *buf_sv, int maxlen)
d1376 2
a1377 2
	DEBUG_P(PerlIO_printf(Perl_debug_log,
			      "filter_read %d: from rsfp\n", idx));
d1405 2
a1406 3
	DEBUG_P(PerlIO_printf(Perl_debug_log,
			      "filter_read %d: skipped (filter deleted)\n",
			      idx));
d1411 5
a1415 3
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "filter_read %d: via function %p (%s)\n",
			  idx, funcp, SvPV_nolen(datasv)));
d1419 1
a1419 1
    return (*funcp)(aTHXo_ idx, buf_sv, maxlen);
d1423 1
a1423 1
S_filter_gets(pTHX_ register SV *sv, register PerlIO *fp, STRLEN append)
d1425 1
a1425 1
#ifdef PERL_CR_FILTER
d1427 1
a1427 1
	filter_add(S_cr_textfilter,NULL);
d1446 1
a1446 3
	{ "OPERATOR", "TERM", "REF", "STATE", "BLOCK", "ATTRBLOCK",
	  "ATTRTERM", "TERMBLOCK"
	};
d1449 2
d1477 1
a1477 5
#ifdef USE_PURE_BISON
Perl_yylex(pTHX_ YYSTYPE *lvalp, int *lcharp)
#else
Perl_yylex(pTHX)
#endif
a1486 5
#ifdef USE_PURE_BISON
    yylval_pointer = lvalp;
    yychar_pointer = lcharp;
#endif

d1500 2
a1501 10
	    if (PL_in_my == KEY_our) {	/* "our" is merely analogous to "my" */
		if (strchr(PL_tokenbuf,':'))
		    yyerror(Perl_form(aTHX_ "No package name allowed for "
				      "variable %s in \"our\"",
				      PL_tokenbuf));
		tmp = pad_allocmy(PL_tokenbuf);
	    }
	    else {
		if (strchr(PL_tokenbuf,':'))
		    yyerror(Perl_form(aTHX_ PL_no_myglob,PL_tokenbuf));
d1503 3
a1505 4
		yylval.opval = newOP(OP_PADANY, 0);
		yylval.opval->op_targ = pad_allocmy(PL_tokenbuf);
		return PRIVATEREF;
	    }
a1532 20
		SV *namesv = AvARRAY(PL_comppad_name)[tmp];
		/* might be an "our" variable" */
		if (SvFLAGS(namesv) & SVpad_OUR) {
		    /* build ops for a bareword */
		    SV *sym = newSVpv(HvNAME(GvSTASH(namesv)),0);
		    sv_catpvn(sym, "::", 2);
		    sv_catpv(sym, PL_tokenbuf+1);
		    yylval.opval = (OP*)newSVOP(OP_CONST, 0, sym);
		    yylval.opval->op_private = OPpCONST_ENTERED;
		    gv_fetchpv(SvPVX(sym),
			(PL_in_eval
			    ? (GV_ADDMULTI | GV_ADDINEVAL)
			    : TRUE
			),
			((PL_tokenbuf[0] == '$') ? SVt_PV
			 : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
			 : SVt_PVHV));
		    return WORD;
		}

d1544 1
a1544 1
			    Perl_croak(aTHX_ "Can't use \"my %s\" in sort comparison",
d1564 1
a1564 1
		yyerror(Perl_form(aTHX_ "In string, %s now must be written as \\%s",
d1587 1
a1587 1
    /* when we've already built the next token, just pull it out of the queue */
d1604 1
a1604 1
	    Perl_croak(aTHX_ "panic: INTERPCASEMOD");
d1659 1
a1659 1
		Perl_croak(aTHX_ "panic: yylex");
a1715 7
	if (PL_lex_inwhat == OP_SUBST && PL_linestr == PL_lex_repl
	    && SvEVALED(PL_lex_repl))
	{
	    if (PL_bufptr != PL_bufend)
		Perl_croak(aTHX_ "Bad evalled substitution pattern");
	    PL_lex_repl = Nullsv;
	}
d1720 1
a1720 1
	    Perl_croak(aTHX_ "panic: INTERPCONCAT");
d1767 1
a1767 2
	PerlIO_printf(Perl_debug_log, "### Tokener expecting %s at %s\n",
		      exp_name[PL_expect], s);
d1773 1
a1773 3
	if (isIDFIRST_lazy_if(s,UTF))
	    goto keylookup;
	Perl_croak(aTHX_ "Unrecognized character \\x%02X", *s & 255);
d1782 1
a1782 1
		yyerror("Missing right curly or square bracket");
d1815 1
a1815 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "@@F=split(%s);", PL_splitstr);
d1821 1
a1821 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "@@F=split(%s%c",
d1828 1
a1828 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "%c);", delim);
d1843 1
a1843 1
		av_store(CopFILEAV(PL_curcop),(I32)CopLINE(PL_curcop),sv);
d1892 1
a1892 1
	    av_store(CopFILEAV(PL_curcop),(I32)CopLINE(PL_curcop),sv);
d1895 1
a1895 1
	if (CopLINE(PL_curcop) == 1) {
d1933 1
a1933 1
		    if (sv_eq(x, CopFILESV(PL_curcop))) {
d1945 1
a1945 1
		if (!d) {
a1946 16
#if defined(DOSISH)
		    /* avoid getting into infinite loops when shebang
		     * line contains "Perl" rather than "perl" */
		    if (!d) {
			for (d = ipathend-4; d >= ipath; --d) {
			    if ((*d == 'p' || *d == 'P')
				&& !ibcmp(d, "perl", 4))
			    {
				break;
			    }
			}
			if (d < ipath)
			    d = Nullch;
		    }
#endif
		}
d1992 1
a1992 1
		    Perl_croak(aTHX_ "Can't exec %s", ipath);
d2007 1
a2007 1
				Perl_croak(aTHX_ "Too late for \"-%.*s\" option",
d2012 2
a2013 2
			if ((PERLDB_LINE && !oldpdb) ||
			    ((PL_minus_n || PL_minus_p) && !(oldn || oldp)))
d2037 3
a2039 3
	Perl_warn(aTHX_ "Illegal character \\%03o (carriage return)", '\r');
	Perl_croak(aTHX_ 
      "\t(Maybe you didn't strip carriage returns after a network transfer?)\n");
d2108 1
a2108 1
		Perl_croak(aTHX_ "Unrecognized file test: -%c", (int)tmp);
d2123 1
a2123 1
	    if (isIDFIRST_lazy_if(s,UTF)) {
a2203 96
	switch (PL_expect) {
	    OP *attrs;
	case XOPERATOR:
	    if (!PL_in_my || PL_lex_state != LEX_NORMAL)
		break;
	    PL_bufptr = s;	/* update in case we back off */
	    goto grabattrs;
	case XATTRBLOCK:
	    PL_expect = XBLOCK;
	    goto grabattrs;
	case XATTRTERM:
	    PL_expect = XTERMBLOCK;
	 grabattrs:
	    s = skipspace(s);
	    attrs = Nullop;
	    while (isIDFIRST_lazy_if(s,UTF)) {
		d = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &len);
		if (isLOWER(*s) && (tmp = keyword(PL_tokenbuf, len))) {
		    if (tmp < 0) tmp = -tmp;
		    switch (tmp) {
		    case KEY_or:
		    case KEY_and:
		    case KEY_for:
		    case KEY_unless:
		    case KEY_if:
		    case KEY_while:
		    case KEY_until:
			goto got_attrs;
		    default:
			break;
		    }
		}
		if (*d == '(') {
		    d = scan_str(d,TRUE,TRUE);
		    if (!d) {
			if (PL_lex_stuff) {
			    SvREFCNT_dec(PL_lex_stuff);
			    PL_lex_stuff = Nullsv;
			}
			/* MUST advance bufptr here to avoid bogus
			   "at end of line" context messages from yyerror().
			 */
			PL_bufptr = s + len;
			yyerror("Unterminated attribute parameter in attribute list");
			if (attrs)
			    op_free(attrs);
			return 0;	/* EOF indicator */
		    }
		}
		if (PL_lex_stuff) {
		    SV *sv = newSVpvn(s, len);
		    sv_catsv(sv, PL_lex_stuff);
		    attrs = append_elem(OP_LIST, attrs,
					newSVOP(OP_CONST, 0, sv));
		    SvREFCNT_dec(PL_lex_stuff);
		    PL_lex_stuff = Nullsv;
		}
		else {
		    attrs = append_elem(OP_LIST, attrs,
					newSVOP(OP_CONST, 0,
						newSVpvn(s, len)));
		}
		s = skipspace(d);
		if (*s == ':' && s[1] != ':')
		    s = skipspace(s+1);
		else if (s == d)
		    break;	/* require real whitespace or :'s */
	    }
	    tmp = (PL_expect == XOPERATOR ? '=' : '{'); /*'}(' for vi */
	    if (*s != ';' && *s != tmp && (tmp != '=' || *s != ')')) {
		char q = ((*s == '\'') ? '"' : '\'');
		/* If here for an expression, and parsed no attrs, back off. */
		if (tmp == '=' && !attrs) {
		    s = PL_bufptr;
		    break;
		}
		/* MUST advance bufptr here to avoid bogus "at end of line"
		   context messages from yyerror().
		 */
		PL_bufptr = s;
		if (!*s)
		    yyerror("Unterminated attribute list");
		else
		    yyerror(Perl_form(aTHX_ "Invalid separator character %c%c%c in attribute list",
				      q, *s, q));
		if (attrs)
		    op_free(attrs);
		OPERATOR(':');
	    }
	got_attrs:
	    if (attrs) {
		PL_nextval[PL_nexttoke].opval = attrs;
		force_next(THING);
	    }
	    TOKEN(COLONATTR);
	}
d2213 2
a2214 2
	if (CopLINE(PL_curcop) < PL_copline)
	    PL_copline = CopLINE(PL_curcop);
d2226 1
a2226 1
	    yyerror("Unmatched right square bracket");
d2268 1
a2268 1
	    if (d < PL_bufend && isIDFIRST_lazy_if(d,UTF)) {
a2280 1
	case XATTRBLOCK:
a2284 1
	case XATTRTERM:
d2325 1
a2325 2
				&& !isALNUM(*t))))
		    {
d2356 2
a2357 4
		else if (isALNUM_lazy_if(t,UTF)) {
		    t += UTF8SKIP(t);
		    while (t < PL_bufend && isALNUM_lazy_if(t,UTF))
			 t += UTF8SKIP(t);
d2375 1
a2375 1
	yylval.ival = CopLINE(PL_curcop);
d2383 1
a2383 1
	    yyerror("Unmatched right curly bracket");
d2390 1
a2390 2
		if (PL_expect & XFAKEBRACK) {
		    PL_expect &= XENUMMASK;
d2393 1
a2393 1
		    return yylex();	/* ignore fake brackets */
d2401 1
a2401 2
	if (PL_expect & XFAKEBRACK) {
	    PL_expect &= XENUMMASK;
d2403 1
d2415 4
a2418 6
	    if (ckWARN(WARN_SEMICOLON)
		&& isIDFIRST_lazy_if(s,UTF) && PL_bufptr == PL_linestart)
	    {
		CopLINE_dec(PL_curcop);
		Perl_warner(aTHX_ WARN_SEMICOLON, PL_warn_nosemi);
		CopLINE_inc(PL_curcop);
d2449 2
a2450 2
	if (ckWARN(WARN_SYNTAX) && tmp && isSPACE(*s) && strchr("+-*/%.^&|<",tmp))
	    Perl_warner(aTHX_ WARN_SYNTAX, "Reversed %c= operator",(int)tmp);
d2545 3
a2547 1
	if (s[1] == '#' && (isIDFIRST_lazy_if(s+2,UTF) || strchr("{$:+-", s[2]))) {
d2549 2
a2550 4
	    s = scan_ident(s + 1, PL_bufend, PL_tokenbuf + 1,
			   sizeof PL_tokenbuf - 1, FALSE);
	    if (PL_expect == XOPERATOR)
		no_op("Array length", s);
d2558 2
d2561 1
a2561 4
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1,
		       sizeof PL_tokenbuf - 1, FALSE);
	if (PL_expect == XOPERATOR)
	    no_op("Scalar", s);
d2571 1
a2571 1
				   newSViv(PL_compiling.cop_arybase));
a2576 1
	tmp = (I32)*s;
d2584 1
a2584 1
		if (ckWARN(WARN_SYNTAX)) {
d2586 1
a2586 1
			isSPACE(*t) || isALNUM_lazy_if(t,UTF) || *t == '$';
d2592 2
a2593 3
			Perl_warner(aTHX_ WARN_SYNTAX,
				"Multidimensional syntax %.*s not supported",
			     	(t - PL_bufptr) + 1, PL_bufptr);
d2599 1
a2599 1
		if (ckWARN(WARN_SYNTAX) && strEQ(PL_tokenbuf+1, "SIG") &&
d2605 1
a2605 1
		    if (isIDFIRST_lazy_if(t,UTF)) {
d2608 2
a2609 3
			if (*t == ';' && get_cv(tmpbuf, FALSE))
			    Perl_warner(aTHX_ WARN_SYNTAX,
				"You need to quote \"%s\"", tmpbuf);
d2616 1
a2616 1
	if (PL_lex_state == LEX_NORMAL && isSPACE((char)tmp)) {
d2622 1
a2622 1
	    else if (strchr("&*<%", *s) && isIDFIRST_lazy_if(s+1,UTF))
d2624 1
a2624 1
	    else if (isIDFIRST_lazy_if(s,UTF)) {
d2627 1
a2627 1
		if ((tmp = keyword(tmpbuf, len))) {
d2679 1
a2679 1
	    if (ckWARN(WARN_SYNTAX)) {
d2682 1
a2682 1
		    while (*t && (isALNUM_lazy_if(t,UTF) || strchr(" \t$#+-'\"", *t)))
d2687 1
a2687 2
			Perl_warner(aTHX_ WARN_SYNTAX,
			    "Scalar value %.*s better written as $%.*s",
d2702 1
a2702 2
		    || memNE(PL_last_uni, "study", 5)
		    || isALNUM_lazy_if(PL_last_uni+5,UTF)))
d2750 1
a2750 1
	s = scan_str(s,FALSE,FALSE);
d2766 1
a2766 1
	s = scan_str(s,FALSE,FALSE);
d2780 1
a2780 1
	    if (*d == '$' || *d == '@@' || *d == '\\' || *d & 0x80) {
d2788 1
a2788 1
	s = scan_str(s,FALSE,FALSE);
d2799 2
a2800 3
	if (ckWARN(WARN_SYNTAX) && PL_lex_inwhat && isDIGIT(*s))
	    Perl_warner(aTHX_ WARN_SYNTAX,"Can't use \\%c to mean $%c in expression",
			*s, *s);
a2804 25
    case 'v':
	if (isDIGIT(s[1]) && PL_expect != XOPERATOR) {
	    char *start = s;
	    start++;
	    start++;
	    while (isDIGIT(*start) || *start == '_')
		start++;
	    if (*start == '.' && isDIGIT(start[1])) {
		s = scan_num(s);
		TERM(THING);
	    }
	    /* avoid v123abc() or $h{v1}, allow C<print v10;> */
	    else if (!isALPHA(*start) && (PL_expect == XTERM || PL_expect == XREF)) {
		char c = *start;
		GV *gv;
		*start = '\0';
		gv = gv_fetchpv(s, FALSE, SVt_PVCV);
		*start = c;
		if (!gv) {
		    s = scan_num(s);
		    TERM(THING);
		}
	    }
	}
	goto keylookup;
d2834 1
a2834 1
	      case 'V':
d2841 1
d2849 4
a2852 4
	tmp = ((len == 1 && strchr("msyq", PL_tokenbuf[0])) ||
	       (len == 2 && ((PL_tokenbuf[0] == 't' && PL_tokenbuf[1] == 'r') ||
			     (PL_tokenbuf[0] == 'q' &&
			      strchr("qwxr", PL_tokenbuf[1])))));
a2907 1
		     && GvCVu(gv)
d2916 3
a2918 4
		if (ckWARN(WARN_AMBIGUOUS) && hgv
		    && tmp != KEY_x && tmp != KEY_CORE)	/* never ambiguous */
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
		    	"Ambiguous call resolved as CORE::%s(), %s",
d2933 1
a2933 1
		if (*s == '\'' || (*s == ':' && s[1] == ':')) {
d2938 1
a2938 1
			Perl_croak(aTHX_ "Bad name after %s%s", PL_tokenbuf,
d2945 3
a2947 3
			CopLINE_dec(PL_curcop);
			Perl_warner(aTHX_ WARN_SEMICOLON, PL_warn_nosemi);
			CopLINE_inc(PL_curcop);
d2960 2
a2961 3
		    if (ckWARN(WARN_BAREWORD) && ! gv_fetchpv(PL_tokenbuf, FALSE, SVt_PVHV))
			Perl_warner(aTHX_ WARN_BAREWORD, 
		  	    "Bareword \"%s\" refers to nonexistent package",
d2977 1
a2977 1
		    sv = newSVpvn("CORE::GLOBAL::",14);
d2998 1
a2998 2
		    (PL_oldoldbufptr == PL_last_lop
		     || PL_oldoldbufptr == PL_last_uni) &&
d3000 5
a3004 2
		    (PL_expect == XREF ||
		     ((PL_opargs[PL_last_lop_op] >> OASHIFT)& 7) == OA_FILEREF))
d3013 1
a3013 1
		    if ((isIDFIRST_lazy_if(s,UTF) || *s == '$') && (tmp=intuit_method(s,gv)))
d3020 2
a3021 4
                         (!immediate_paren && (!gv || !GvCVu(gv)))) &&
                        (PL_last_lop_op != OP_MAPSTART &&
			 PL_last_lop_op != OP_GREPSTART))
		    {
d3034 3
d3038 1
a3038 1
			if (*d == ')' && (sv = cv_const_sv(GvCV(gv)))) {
d3047 1
d3061 1
a3061 1
		if ((isIDFIRST_lazy_if(s,UTF) || *s == '$') && (tmp = intuit_method(s,gv)))
d3068 2
a3069 3
		    if (lastchar == '-' && ckWARN_d(WARN_AMBIGUOUS))
			Perl_warner(aTHX_ WARN_AMBIGUOUS,
				"Ambiguous use of -%s resolved as -&%s()",
d3071 2
a3085 2
		    yylval.opval->op_private |= OPpENTERSUB_NOPAREN;
		    PL_last_lop = PL_oldbufptr;
d3090 1
a3090 1
			char *proto = SvPV((SV*)cv, len);
d3093 1
a3093 1
			if (strEQ(proto, "$"))
d3095 1
a3095 1
			if (*proto == '&' && *s == '{') {
d3099 2
a3100 1
		    }
d3107 17
d3126 6
a3131 11
		if (PL_hints & HINT_STRICT_SUBS)
		    yylval.opval->op_private |= OPpCONST_STRICT;
		else {
		bareword:
		    if (ckWARN(WARN_RESERVED)) {
			if (lastchar != '-') {
			    for (d = PL_tokenbuf; *d && isLOWER(*d); d++) ;
			    if (!*d)
				Perl_warner(aTHX_ WARN_RESERVED, PL_warn_reserved,
				       PL_tokenbuf);
			}
d3136 2
a3137 3
		if (lastchar && strchr("*%&", lastchar) && ckWARN_d(WARN_AMBIGUOUS)) {
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
		  	"Operator or semicolon missing before %c%s",
d3139 1
a3139 2
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
			"Ambiguous use of %c resolved as operator %c",
d3147 1
a3147 1
					newSVpv(CopFILE(PL_curcop),0));
d3151 2
a3152 2
            yylval.opval = (OP*)newSVOP(OP_CONST, 0,
                                    Perl_newSVpvf(aTHX_ "%"IVdf, (IV)CopLINE(PL_curcop)));
d3171 1
a3171 1
		gv = gv_fetchpv(Perl_form(aTHX_ "%s::DATA", pname), TRUE, SVt_PVIO);
a3189 22
#if defined(WIN32) && !defined(PERL_TEXTMODE_SCRIPTS)
		/* if the script was opened in binmode, we need to revert
		 * it to text mode for compatibility; but only iff it has CRs
		 * XXX this is a questionable hack at best. */
		if (PL_bufend-PL_bufptr > 2
		    && PL_bufend[-1] == '\n' && PL_bufend[-2] == '\r')
		{
		    Off_t loc = 0;
		    if (IoTYPE(GvIOp(gv)) == '<') {
			loc = PerlIO_tell(PL_rsfp);
			(void)PerlIO_seek(PL_rsfp, 0L, 0);
		    }
		    if (PerlLIO_setmode(PerlIO_fileno(PL_rsfp), O_TEXT) != -1) {
#if defined(__BORLANDC__)
			/* XXX see note in do_binmode() */
			((FILE*)PL_rsfp)->flags |= _F_BIN;
#endif
			if (loc > 0)
			    PerlIO_seek(PL_rsfp, loc, 0);
		    }
		}
#endif
d3198 1
a3198 1
	case KEY_CHECK:
a3199 1
	case KEY_END:
d3211 1
a3211 2
		if (!(tmp = keyword(PL_tokenbuf, len)))
		    Perl_croak(aTHX_ "CORE::%s is not a keyword", PL_tokenbuf);
d3237 1
a3237 1
	    LOP(OP_BINMODE,XTERM);
d3266 1
a3266 2
	    if (!PL_cryptseen) {
		PL_cryptseen = TRUE;
a3267 1
	    }
d3272 1
a3272 1
	    if (ckWARN(WARN_CHMOD)) {
d3275 1
a3275 2
		    Perl_warner(aTHX_ WARN_CHMOD,
		    		"chmod() mode argument is missing initial 0");
d3327 1
a3327 1
	    yylval.ival = CopLINE(PL_curcop);
d3377 1
a3377 1
	    yylval.ival = CopLINE(PL_curcop);
d3379 1
a3379 1
	    if (PL_expect == XSTATE && isIDFIRST_lazy_if(s,UTF)) {
a3383 3
		else if ((PL_bufend - p) >= 4 &&
		    strnEQ(p, "our", 3) && isSPACE(*(p + 3)))
		    p += 3;
d3385 2
a3386 7
		if (isIDFIRST_lazy_if(p,UTF)) {
		    p = scan_ident(p, PL_bufend,
			PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
		    p = skipspace(p);
		}
		if (*p != '$')
		    Perl_croak(aTHX_ "Missing $ on loop variable");
d3412 1
a3412 1
	    LOP(OP_GREPSTART, XREF);
d3507 1
a3507 1
	    yylval.ival = CopLINE(PL_curcop);
a3538 1
	    yylval.ival = 0;
d3573 2
a3574 2
	    LOP(OP_MAPSTART, XREF);

a3589 1
	case KEY_our:
d3591 1
a3591 1
	    PL_in_my = tmp;
d3593 1
a3593 1
	    if (isIDFIRST_lazy_if(s,UTF)) {
a3594 2
		if (len == 3 && strnEQ(PL_tokenbuf, "sub", 3))
		    goto really_sub;
a3602 1
	    yylval.ival = 1;
d3621 1
a3621 4
	    if (*s == '(' || (s = skipspace(s), *s == '('))
		FUN1(OP_NOT);
	    else
		OPERATOR(NOTOP);
d3625 1
a3625 1
	    if (isIDFIRST_lazy_if(s,UTF)) {
d3627 1
a3627 1
		for (d = s; isALNUM_lazy_if(d,UTF); d++) ;
d3629 3
a3631 4
		if (strchr("|&*+-=!?:.", *t) && ckWARN_d(WARN_PRECEDENCE))
		    Perl_warner(aTHX_ WARN_PRECEDENCE,
			   "Precedence problem: open %.*s should be open(%.*s)",
			    d-s,s, d-s,s);
d3679 1
a3679 1
	    s = scan_str(s,FALSE,FALSE);
d3689 1
a3689 1
	    s = scan_str(s,FALSE,FALSE);
d3692 1
a3692 4
	    force_next(')');
	    if (SvCUR(PL_lex_stuff)) {
		OP *words = Nullop;
		int warned = 0;
d3694 8
a3701 23
		while (len) {
		    for (; isSPACE(*d) && len; --len, ++d) ;
		    if (len) {
			char *b = d;
			if (!warned && ckWARN(WARN_QW)) {
			    for (; !isSPACE(*d) && len; --len, ++d) {
				if (*d == ',') {
				    Perl_warner(aTHX_ WARN_QW,
					"Possible attempt to separate words with commas");
				    ++warned;
				}
				else if (*d == '#') {
				    Perl_warner(aTHX_ WARN_QW,
					"Possible attempt to put comments in qw() list");
				    ++warned;
				}
			    }
			}
			else {
			    for (; !isSPACE(*d) && len; --len, ++d) ;
			}
			words = append_elem(OP_LIST, words,
					    newSVOP(OP_CONST, 0, newSVpvn(b, d-b)));
a3703 4
		if (words) {
		    PL_nextval[PL_nexttoke].opval = words;
		    force_next(THING);
		}
d3705 2
a3706 2
	    if (PL_lex_stuff)
		SvREFCNT_dec(PL_lex_stuff);
d3708 7
d3716 4
a3719 1
	    TOKEN('(');
d3722 1
a3722 1
	    s = scan_str(s,FALSE,FALSE);
d3735 1
a3735 1
	    s = scan_str(s,FALSE,FALSE);
d3746 6
a3751 12
	    s = skipspace(s);
	    if (isDIGIT(*s) || (*s == 'v' && isDIGIT(s[1]))) {
		s = force_version(s);
	    }
	    else {
		*PL_tokenbuf = '\0';
		s = force_word(s,WORD,TRUE,TRUE,FALSE);
		if (isIDFIRST_lazy_if(PL_tokenbuf,UTF))
		    gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf), TRUE);
		else if (*s == '<')
		    yyerror("<> should be quotes");
	    }
d3897 1
a3897 1
		Perl_croak(aTHX_ "sort is now a reserved word");
d3921 1
d3930 3
a3932 1
	    {
d3934 4
a3937 25
		SSize_t tboffset;
		expectation attrful;
		bool have_name, have_proto;
		int key = tmp;

		s = skipspace(s);

		if (isIDFIRST_lazy_if(s,UTF) || *s == '\'' ||
		    (*s == ':' && s[1] == ':'))
		{
		    PL_expect = XBLOCK;
		    attrful = XATTRBLOCK;
		    /* remember buffer pos'n for later force_word */
		    tboffset = s - PL_oldbufptr;
		    d = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
		    if (strchr(tmpbuf, ':'))
			sv_setpv(PL_subname, tmpbuf);
		    else {
			sv_setsv(PL_subname,PL_curstname);
			sv_catpvn(PL_subname,"::",2);
			sv_catpvn(PL_subname,tmpbuf,len);
		    }
		    s = skipspace(d);
		    have_name = TRUE;
		}
d3939 3
a3941 15
		    if (key == KEY_my)
			Perl_croak(aTHX_ "Missing name in \"my sub\"");
		    PL_expect = XTERMBLOCK;
		    attrful = XATTRTERM;
		    sv_setpv(PL_subname,"?");
		    have_name = FALSE;
		}

		if (key == KEY_format) {
		    if (*s == '=')
			PL_lex_formbrack = PL_lex_brackets + 1;
		    if (have_name)
			(void) force_word(PL_oldbufptr + tboffset, WORD,
					  FALSE, TRUE, TRUE);
		    OPERATOR(FORMAT);
d3943 7
d3951 6
a3956 29
		/* Look for a prototype */
		if (*s == '(') {
		    char *p;

		    s = scan_str(s,FALSE,FALSE);
		    if (!s) {
			if (PL_lex_stuff)
			    SvREFCNT_dec(PL_lex_stuff);
			PL_lex_stuff = Nullsv;
			Perl_croak(aTHX_ "Prototype not terminated");
		    }
		    /* strip spaces */
		    d = SvPVX(PL_lex_stuff);
		    tmp = 0;
		    for (p = d; *p; ++p) {
			if (!isSPACE(*p))
			    d[tmp++] = *p;
		    }
		    d[tmp] = '\0';
		    SvCUR(PL_lex_stuff) = tmp;
		    have_proto = TRUE;

		    s = skipspace(s);
		}
		else
		    have_proto = FALSE;

		if (*s == ':' && s[1] != ':')
		    PL_expect = attrful;
d3958 8
a3965 3
		if (have_proto) {
		    PL_nextval[PL_nexttoke].opval =
			(OP*)newSVOP(OP_CONST, 0, PL_lex_stuff);
d3967 1
a3967 1
		    force_next(THING);
d3969 26
a3994 9
		if (!have_name) {
		    sv_setpv(PL_subname,"__ANON__");
		    TOKEN(ANONSUB);
		}
		(void) force_word(PL_oldbufptr + tboffset, WORD,
				  FALSE, TRUE, TRUE);
		if (key == KEY_my)
		    TOKEN(MYSUB);
		TOKEN(SUB);
d3996 1
d4055 1
a4055 1
	    yylval.ival = CopLINE(PL_curcop);
d4059 1
a4059 1
	    yylval.ival = CopLINE(PL_curcop);
d4075 1
a4075 1
	    if (ckWARN(WARN_UMASK)) {
d4077 2
a4078 3
		if (*d != '0' && isDIGIT(*d)) 
		    Perl_warner(aTHX_ WARN_UMASK,
		    		"umask: argument is missing initial 0");
d4089 1
a4089 1
	    if (isDIGIT(*s) || (*s == 'v' && isDIGIT(s[1]))) {
d4091 1
a4091 1
		if (*s == ';' || (s = skipspace(s), *s == ';')) {
d4107 1
d4111 1
a4111 1
	    yylval.ival = CopLINE(PL_curcop);
d4159 1
a4159 1
Perl_keyword(pTHX_ register char *d, I32 len)
a4198 1
	if (strEQ(d,"CHECK"))			return KEY_CHECK;
d4282 1
a4282 1
	    if (strEQ(d,"elseif")) Perl_warn(aTHX_ "elseif should be elsif");
d4503 2
a4504 1
	    if (strEQ(d,"our"))			return KEY_our;
d4778 1
a4778 1
S_checkcomma(pTHX_ register char *s, char *name, char *what)
d4782 12
a4793 16
    if (*s == ' ' && s[1] == '(') {	/* XXX gotta be a better way */
	dTHR;				/* only for ckWARN */
	if (ckWARN(WARN_SYNTAX)) {
	    int level = 1;
	    for (w = s+2; *w && level; w++) {
		if (*w == '(')
		    ++level;
		else if (*w == ')')
		    --level;
	    }
	    if (*w)
		for (; *w && isSPACE(*w); w++) ;
	    if (!*w || !strchr(";|})]oaiuw!=", *w))	/* an advisory hack only... */
		Perl_warner(aTHX_ WARN_SYNTAX,
			    "%s (...) interpreted as function",name);
	}
d4801 1
a4801 1
    if (isIDFIRST_lazy_if(s,UTF)) {
d4803 1
a4803 1
	while (isALNUM_lazy_if(s,UTF))
d4810 1
a4810 1
	    kw = keyword(w, s - w) || get_cv(w, FALSE) != 0;
d4814 1
a4814 1
	    Perl_croak(aTHX_ "No comma allowed after %s", what);
a4818 5
/* Either returns sv, or mortalizes sv and returns a new SV*.
   Best used as sv=new_constant(..., sv, ...).
   If s, pv are NULL, calls subroutine with one argument,
   and type is used with error messages only. */

d4820 1
a4820 2
S_new_constant(pTHX_ char *s, STRLEN len, const char *key, SV *sv, SV *pv,
	       const char *type)
d4824 1
d4826 1
d4829 5
a4833 16
    const char *why1, *why2, *why3;
    
    if (!table || !(PL_hints & HINT_LOCALIZE_HH)) {
	SV *msg;
	
	why1 = "%^H is not consistent";
	why2 = strEQ(key,"charnames")
	       ? " (missing \"use charnames ...\"?)"
	       : "";
	why3 = "";
    report:
	msg = Perl_newSVpvf(aTHX_ "constant(%s): %s%s%s", 
			    (type ? type: "undef"), why1, why2, why3);
	yyerror(SvPVX(msg));
 	SvREFCNT_dec(msg);
  	return sv;
d4837 3
a4839 4
	why1 = "$^H{";
	why2 = key;
	why3 = "} is not defined";
	goto report;
d4843 4
a4846 4
    if (!pv && s)
  	pv = sv_2mortal(newSVpvn(s, len));
    if (type && pv)
  	typesv = sv_2mortal(newSVpv(type, 0));
d4848 7
a4854 2
  	typesv = &PL_sv_undef;
    
d4856 8
a4863 4
    ENTER ;
    SAVETMPS;
    
    PUSHMARK(SP) ;
d4865 1
a4865 2
    if (pv)
 	PUSHs(pv);
d4867 1
a4867 2
    if (pv)
 	PUSHs(typesv);
d4870 9
a4878 20
    call_sv(cv, G_SCALAR | ( PL_in_eval ? 0 : G_EVAL));
    
    SPAGAIN ;
    
    /* Check the eval first */
    if (!PL_in_eval && SvTRUE(ERRSV)) {
	STRLEN n_a;
 	sv_catpv(ERRSV, "Propagated");
	yyerror(SvPV(ERRSV, n_a)); /* Duplicates the message inside eval */
	(void)POPs;
 	res = SvREFCNT_inc(sv);
    }
    else {
 	res = POPs;
 	(void)SvREFCNT_inc(res);
    }
    
    PUTBACK ;
    FREETMPS ;
    LEAVE ;
d4880 1
a4880 1
    
d4882 2
a4883 5
 	why1 = "Call to &{$^H{";
 	why2 = key;
 	why3 = "}} did not return a defined value";
 	sv = res;
 	goto report;
d4885 2
a4887 3
    return res;
}
  
d4889 1
a4889 1
S_scan_word(pTHX_ register char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
d4895 2
a4896 2
	    Perl_croak(aTHX_ ident_too_long);
	if (isALNUM(*s))	/* UTF handled below */
d4898 1
a4898 1
	else if (*s == '\'' && allow_package && isIDFIRST_lazy_if(s+1,UTF)) {
a4906 10
	else if (UTF && *(U8*)s >= 0xc0 && isALNUM_utf8((U8*)s)) {
	    char *t = s + UTF8SKIP(s);
	    while (*t & 0x80 && is_utf8_mark((U8*)t))
		t += UTF8SKIP(t);
	    if (d + (t - s) > e)
		Perl_croak(aTHX_ ident_too_long);
	    Copy(s, d, t - s, char);
	    d += t - s;
	    s = t;
	}
d4916 1
a4916 1
S_scan_ident(pTHX_ register char *s, register char *send, char *dest, STRLEN destlen, I32 ck_uni)
d4923 2
d4932 1
a4932 1
		Perl_croak(aTHX_ ident_too_long);
d4939 2
a4940 2
		Perl_croak(aTHX_ ident_too_long);
	    if (isALNUM(*s))	/* UTF handled below */
d4942 1
a4942 1
	    else if (*s == '\'' && isIDFIRST_lazy_if(s+1,UTF)) {
a4950 10
	    else if (UTF && *(U8*)s >= 0xc0 && isALNUM_utf8((U8*)s)) {
		char *t = s + UTF8SKIP(s);
		while (*t & 0x80 && is_utf8_mark((U8*)t))
		    t += UTF8SKIP(t);
		if (d + (t - s) > e)
		    Perl_croak(aTHX_ ident_too_long);
		Copy(s, d, t - s, char);
		d += t - s;
		s = t;
	    }
d4963 1
a4963 1
	(isALNUM_lazy_if(s+1,UTF) || strchr("${", s[1]) || strnEQ(s+1,"::",2)) )
d4965 4
a4968 1
	return s;
d4979 1
a4979 1
    if (*d == '^' && *s && isCONTROLVAR(*s)) {
d4993 1
a4993 1
	if (isIDFIRST_lazy_if(d,UTF)) {
d4995 2
a4996 17
	    if (UTF) {
		e = s;
		while ((e < send && isALNUM_lazy_if(e,UTF)) || *e == ':') {
		    e += UTF8SKIP(e);
		    while (e < send && *e & 0x80 && is_utf8_mark((U8*)e))
			e += UTF8SKIP(e);
		}
		Copy(s, d, e - s, char);
		d += e - s;
		s = e;
	    }
	    else {
		while ((isALNUM(*s) || *s == ':') && d < e)
		    *d++ = *s++;
		if (d >= e)
		    Perl_croak(aTHX_ ident_too_long);
	    }
d5000 3
a5002 5
		dTHR;			/* only for ckWARN */
		if (ckWARN(WARN_AMBIGUOUS) && keyword(dest, d - dest)) {
		    const char *brack = *s == '[' ? "[...]" : "{...}";
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
			"Ambiguous use of %c{%s%s} resolved to %c%s%s",
d5005 1
d5007 1
a5007 1
		PL_lex_brackstack[PL_lex_brackets++] = (char)(XOPERATOR | XFAKEBRACK);
a5009 13
	} 
	/* Handle extended ${^Foo} variables 
	 * 1999-02-27 mjd-perl-patch@@plover.com */
	else if (!isALNUM(*d) && !isPRINT(*d) /* isCTRL(d) */
		 && isALNUM(*s))
	{
	    d++;
	    while (isALNUM(*s) && d < e) {
		*d++ = *s++;
	    }
	    if (d >= e)
		Perl_croak(aTHX_ ident_too_long);
	    *d = '\0';
d5017 4
a5020 10
	    if (PL_lex_state == LEX_NORMAL) {
		dTHR;			/* only for ckWARN */
		if (ckWARN(WARN_AMBIGUOUS) &&
		    (keyword(dest, d - dest) || get_cv(dest, FALSE)))
		{
		    Perl_warner(aTHX_ WARN_AMBIGUOUS,
			"Ambiguous use of %c{%s} resolved to %c%s",
			funny, dest, funny, dest);
		}
	    }
d5032 1
a5032 2
void
Perl_pmflag(pTHX_ U16 *pmfl, int ch)
d5051 1
a5051 1
S_scan_pat(pTHX_ char *start, I32 type)
d5056 1
a5056 1
    s = scan_str(start,FALSE,FALSE);
d5061 1
a5061 1
	Perl_croak(aTHX_ "Search pattern not terminated");
d5083 1
a5083 1
S_scan_subst(pTHX_ char *start)
d5092 1
a5092 1
    s = scan_str(start,FALSE,FALSE);
d5098 1
a5098 1
	Perl_croak(aTHX_ "Substitution pattern not terminated");
d5105 1
a5105 1
    s = scan_str(s,FALSE,FALSE);
d5113 1
a5113 1
	Perl_croak(aTHX_ "Substitution replacement not terminated");
d5131 2
a5132 2
	PL_sublex_info.super_bufptr = s;
	PL_sublex_info.super_bufend = PL_bufend;
d5135 1
a5135 1
	repl = newSVpvn("",0);
d5141 1
a5141 1
	SvEVALED_on(repl);
d5153 1
a5153 1
S_scan_trans(pTHX_ char *start)
d5159 1
a5159 1
    I32 del;
a5160 2
    I32 utf8;
    I32 count = 0;
d5164 1
a5164 1
    s = scan_str(start,FALSE,FALSE);
d5169 1
a5169 1
	Perl_croak(aTHX_ "Transliteration pattern not terminated");
d5174 1
a5174 1
    s = scan_str(s,FALSE,FALSE);
d5182 1
a5182 1
	Perl_croak(aTHX_ "Transliteration replacement not terminated");
d5185 2
a5186 9
    if (UTF) {
	o = newSVOP(OP_TRANS, 0, 0);
	utf8 = OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF;
    }
    else {
	New(803,tbl,256,short);
	o = newPVOP(OP_TRANS, 0, (char*)tbl);
	utf8 = 0;
    }
d5188 2
a5189 2
    complement = del = squash = 0;
    while (strchr("cdsCU", *s)) {
d5193 2
a5194 2
	    del = OPpTRANS_DELETE;
	else if (*s == 's')
a5195 18
	else {
	    switch (count++) {
	    case 0:
		if (*s == 'C')
		    utf8 &= ~OPpTRANS_FROM_UTF;
		else
		    utf8 |= OPpTRANS_FROM_UTF;
		break;
	    case 1:
		if (*s == 'C')
		    utf8 &= ~OPpTRANS_TO_UTF;
		else
		    utf8 |= OPpTRANS_TO_UTF;
		break;
	    default: 
		Perl_croak(aTHX_ "Too many /C and /U options");
	    }
	}
d5198 1
a5198 1
    o->op_private = del|squash|complement|utf8;
d5206 1
a5206 1
S_scan_heredoc(pTHX_ register char *s)
d5238 1
a5238 1
	if (!isALNUM_lazy_if(s,UTF))
d5240 1
a5240 1
	for (; isALNUM_lazy_if(s,UTF); s++) {
d5246 1
a5246 1
	Perl_croak(aTHX_ "Delimiter for here document is too long");
d5276 1
a5276 1
	herewas = newSVpvn(s,PL_bufend-s);
d5278 1
a5278 1
	s--, herewas = newSVpvn(s,d-s);
d5293 1
a5293 1
    PL_multi_start = CopLINE(PL_curcop);
d5297 2
a5298 2
	char *bufptr = PL_sublex_info.super_bufptr;
	char *bufend = PL_sublex_info.super_bufend;
d5307 1
a5307 1
		CopLINE_inc(PL_curcop);
d5310 1
a5310 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d5327 1
a5327 1
		CopLINE_inc(PL_curcop);
d5330 1
a5330 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d5335 1
a5335 1
	CopLINE_inc(PL_curcop);	/* the preceding stmt passes a newline */
d5347 1
a5347 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d5350 1
a5350 1
	CopLINE_inc(PL_curcop);
d5372 2
a5373 1
	    av_store(CopFILEAV(PL_curcop), (I32)CopLINE(PL_curcop),sv);
d5388 1
a5388 1
    PL_multi_end = CopLINE(PL_curcop);
d5416 1
a5416 1
S_scan_inputsymbol(pTHX_ char *start)
a5420 1
    char *end;
d5425 1
a5425 4
    end = strchr(s, '\n');
    if (!end)
	end = PL_bufend;
    s = delimcpy(d, e, s + 1, end, '>', &len);	/* extract until > */
d5428 1
a5428 1
       or if it didn't end, or if we see a newline
d5432 3
a5434 3
	Perl_croak(aTHX_ "Excessively long <> operator");
    if (s >= end)
	Perl_croak(aTHX_ "Unterminated <> operator");
d5448 1
a5448 1
    while (*d && (isALNUM_lazy_if(d,UTF) || *d == '\'' || *d == ':'))
d5460 1
a5460 1
	s = scan_str(start,FALSE,FALSE);
d5462 1
a5462 1
	   Perl_croak(aTHX_ "Glob not terminated");
d5485 1
a5485 1
		PL_lex_op = (OP*)newUNOP(OP_READLINE, 0, o);
d5490 1
d5492 1
a5492 1
						newGVOP(OP_GV, 0, gv)));
d5494 1
a5494 2
	    PL_lex_op->op_flags |= OPf_SPECIAL;
	    /* we created the ops in PL_lex_op, so make yylval.ival a null op */
a5512 2
	  keep_quoted preserve \ on the embedded delimiter(s)
	  keep_delims preserve the delimiters around the string
a5529 1
	(stuff)		sub attr parameters	sub foo : attr(stuff)
d5552 1
a5552 1
S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims)
a5560 1
    bool has_utf = FALSE;		/* is there any utf8 content? */
a5570 3
    if ((term & 0x80) && UTF)
	has_utf = TRUE;

d5572 1
a5572 1
    PL_multi_start = CopLINE(PL_curcop);
a5587 2
    if (keep_delims)
	sv_catpvn(sv, s, 1);
d5594 1
a5594 1

d5600 1
a5600 1
		    CopLINE_inc(PL_curcop);
d5603 1
a5603 1
		    if (!keep_quoted && s[1] == term)
a5612 2
		else if (!has_utf && (*s & 0x80) && UTF)
		    has_utf = TRUE;
d5626 1
a5626 1
		    CopLINE_inc(PL_curcop);
d5629 1
a5629 2
		    if (!keep_quoted &&
			((s[1] == PL_multi_open) || (s[1] == PL_multi_close)))
a5638 2
		else if (!has_utf && (*s & 0x80) && UTF)
		    has_utf = TRUE;
d5650 1
a5650 2
  	if (s < PL_bufend)
	    break;		/* handle case where we are done yet :-) */
d5674 1
a5674 1
	    CopLINE_set(PL_curcop, PL_multi_start);
d5678 2
a5679 2
	CopLINE_inc(PL_curcop);

d5686 2
a5687 1
	    av_store(CopFILEAV(PL_curcop), (I32)CopLINE(PL_curcop), sv);
d5689 1
a5689 1

d5696 1
a5696 5
    if (keep_delims)
	sv_catpvn(sv, s, 1);
    if (has_utf)
	SvUTF8_on(sv);
    PL_multi_end = CopLINE(PL_curcop);
d5724 1
a5724 1
  0(x[0-7A-F]+)|([0-7]+)|(b[01])
d5739 1
a5739 1
Perl_scan_num(pTHX_ char *start)
d5744 4
a5747 3
    NV value;				/* number read, as a double */
    SV *sv = Nullsv;			/* place to put the converted number */
    bool floatit;			/* boolean: int or float? */
d5755 1
a5755 1
      Perl_croak(aTHX_ "panic: scan_num");
d5758 2
a5759 1
       0.13 disguise, or a hexadecimal number, or a binary number. */
d5764 1
a5764 2
	     shift	the power of 2 of the base
			(hex == 4, octal == 3, binary == 1)
d5768 2
a5769 2
	     we in octal/hex/binary?" indicator to disallow hex characters
	     when in octal mode.
d5771 1
a5771 3
    	    dTHR;
	    NV n = 0.0;
	    UV u = 0;
a5773 11
	    static NV nvshift[5] = { 1.0, 2.0, 4.0, 8.0, 16.0 };
	    static char* bases[5] = { "", "binary", "", "octal",
				      "hexadecimal" };
	    static char* Bases[5] = { "", "Binary", "", "Octal",
				      "Hexadecimal" };
	    static char *maxima[5] = { "",
				       "0b11111111111111111111111111111111",
				       "",
				       "037777777777",
				       "0xffffffff" };
	    char *base, *Base, *max;
a5778 3
	    } else if (s[1] == 'b') {
		shift = 1;
		s += 2;
d5781 1
a5781 1
	    else if (s[1] == '.' || s[1] == 'e' || s[1] == 'E')
d5786 1
d5788 1
a5788 5
	    base = bases[shift];
	    Base = Bases[shift];
	    max  = maxima[shift];

	    /* read the rest of the number */
d5790 1
a5790 3
		/* x is used in the overflow test,
		   b is the digit we're adding on. */
		UV x, b;
d5805 2
a5806 2
		    if (shift == 3)
			yyerror(Perl_form(aTHX_ "Illegal octal digit '%c'", *s));
d5810 1
a5810 1
		case '2': case '3': case '4':
a5811 5
		    if (shift == 1)
			yyerror(Perl_form(aTHX_ "Illegal binary digit '%c'", *s));
		    /* FALL THROUGH */

		case '0': case '1':
d5828 6
a5833 26
		    if (!overflowed) {
			x = u << shift;	/* make room for the digit */

			if ((x >> shift) != u
			    && !(PL_hints & HINT_NEW_BINARY)) {
			    dTHR;
			    overflowed = TRUE;
			    n = (NV) u;
			    if (ckWARN_d(WARN_OVERFLOW))
				Perl_warner(aTHX_ WARN_OVERFLOW,
					    "Integer overflow in %s number",
					    base);
			} else
			    u = x | b;		/* add the digit to the end */
		    }
		    if (overflowed) {
			n *= nvshift[shift];
			/* If an NV has not enough bits in its
			 * mantissa to represent an UV this summing of
			 * small low-order numbers is a waste of time
			 * (because the NV cannot preserve the
			 * low-order bits anyway): we could just
			 * remember when did we overflow and in the
			 * end just multiply n by the right
			 * amount. */
			n += (NV) b;
d5835 1
d5845 2
a5846 19
	    if (overflowed) {
		dTHR;
		if (ckWARN(WARN_PORTABLE) && n > 4294967295.0)
		    Perl_warner(aTHX_ WARN_PORTABLE,
				"%s number > %s non-portable",
				Base, max);
		sv_setnv(sv, n);
	    }
	    else {
#if UVSIZE > 4
		dTHR;
		if (ckWARN(WARN_PORTABLE) && u > 0xffffffff)
		    Perl_warner(aTHX_ WARN_PORTABLE,
				"%s number > %s non-portable",
				Base, max);
#endif
		sv_setuv(sv, u);
	    }
	    if (PL_hints & HINT_NEW_BINARY)
d5868 2
a5869 3
		dTHR;			/* only for ckWARN */
		if (ckWARN(WARN_SYNTAX) && lastub && s - lastub != 3)
		    Perl_warner(aTHX_ WARN_SYNTAX, "Misplaced _ in number");
d5875 1
a5875 1
		    Perl_croak(aTHX_ number_too_long);
d5882 2
a5883 5
	if (lastub && s - lastub != 3) {
	    dTHR;
	    if (ckWARN(WARN_SYNTAX))
		Perl_warner(aTHX_ WARN_SYNTAX, "Misplaced _ in number");
	}
d5899 1
a5899 1
		    Perl_croak(aTHX_ number_too_long);
a5902 5
	    if (*s == '.' && isDIGIT(s[1])) {
		/* oops, it's really a v-string, but without the "v" */
		s = start - 1;
		goto vstring;
	    }
d5920 1
a5920 1
		    Perl_croak(aTHX_ number_too_long);
d5930 3
a5932 11

	/* unfortunately this monster needs to be on one line or
	   makedepend will be confused. */
#if (defined(USE_64_BIT_INT) && (!defined(HAS_STRTOLL)|| !defined(HAS_STRTOULL))) || (!defined(USE_64_BIT_INT) && (!defined(HAS_STRTOL) || !defined(HAS_STRTOUL)))

	/*
	   No working strto[u]l[l]. Since atoi() doesn't do range checks,
	   we need to do this the hard way.
	 */

	value = Atof(PL_tokenbuf);
d5944 4
a5947 35
	{
	    UV tryuv = U_V(value);
	    if (!floatit && (NV)tryuv == value) {
		if (tryuv <= IV_MAX)
		    sv_setiv(sv, (IV)tryuv);
		else
		    sv_setuv(sv, tryuv);
	    }
	    else
		sv_setnv(sv, value);
	}
#else
	/*
	   strtol/strtoll sets errno to ERANGE if the number is too big
	   for an integer. We try to do an integer conversion first
	   if no characters indicating "float" have been found.
	 */

	if (!floatit) {
    	    IV iv;
    	    UV uv;
	    errno = 0;
	    if (*PL_tokenbuf == '-')
		iv = Strtol(PL_tokenbuf, (char**)NULL, 10);
	    else
		uv = Strtoul(PL_tokenbuf, (char**)NULL, 10);
	    if (errno)
	    	floatit = TRUE; /* probably just too large */
	    else if (*PL_tokenbuf == '-')
	    	sv_setiv(sv, iv);
	    else
	    	sv_setuv(sv, uv);
	}
	if (floatit) {
	    value = Atof(PL_tokenbuf);
d5949 1
a5949 4
	}
#endif
	if ( floatit ? (PL_hints & HINT_NEW_FLOAT) :
	               (PL_hints & HINT_NEW_INTEGER) )
d5951 1
a5951 63
			      (floatit ? "float" : "integer"),
			      sv, Nullsv, NULL);
	break;

    /* if it starts with a v, it could be a v-string */
    case 'v':
vstring:
	{
	    char *pos = s;
	    pos++;
	    while (isDIGIT(*pos) || *pos == '_')
		pos++;
	    if (!isALPHA(*pos)) {
		UV rev;
		U8 tmpbuf[UTF8_MAXLEN];
		U8 *tmpend;
		bool utf8 = FALSE;
		s++;				/* get past 'v' */

		sv = NEWSV(92,5);
		sv_setpvn(sv, "", 0);

		for (;;) {
		    if (*s == '0' && isDIGIT(s[1]))
			yyerror("Octal number in vector unsupported");
		    rev = 0;
		    {
			/* this is atoi() that tolerates underscores */
			char *end = pos;
			UV mult = 1;
			while (--end >= s) {
			    UV orev;
			    if (*end == '_')
				continue;
			    orev = rev;
			    rev += (*end - '0') * mult;
			    mult *= 10;
			    if (orev > rev && ckWARN_d(WARN_OVERFLOW))
				Perl_warner(aTHX_ WARN_OVERFLOW,
					    "Integer overflow in decimal number");
			}
		    }
		    tmpend = uv_to_utf8(tmpbuf, rev);
		    utf8 = utf8 || rev > 127;
		    sv_catpvn(sv, (const char*)tmpbuf, tmpend - tmpbuf);
		    if (*pos == '.' && isDIGIT(pos[1]))
			s = ++pos;
		    else {
			s = pos;
			break;
		    }
		    while (isDIGIT(*pos) || *pos == '_')
			pos++;
		}

		SvPOK_on(sv);
		SvREADONLY_on(sv);
		if (utf8) {
		    SvUTF8_on(sv);
		    sv_utf8_downgrade(sv, TRUE);
		}
	    }
	}
d5957 1
a5957 4
    if (sv)
	yylval.opval = newSVOP(OP_CONST, 0, sv);
    else
	yylval.opval = Nullop;
d5963 1
a5963 1
S_scan_formline(pTHX_ register char *s)
d5968 1
a5968 1
    SV *stuff = newSVpvn("",0);
a5998 8
#ifndef PERL_STRICT_CR
	    if (eol-s > 1 && eol[-2] == '\r' && eol[-1] == '\n') {
		char *end = SvPVX(stuff) + SvCUR(stuff);
		end[-2] = '\n';
		end[-1] = '\0';
		SvCUR(stuff)--;
	    }
#endif
d6037 1
a6037 1
S_set_csh(pTHX)
d6046 1
a6046 1
Perl_start_subparse(pTHX_ I32 is_format, U32 flags)
d6056 1
a6056 1
    SAVEI32(PL_subline);
d6059 2
a6060 1
    SAVECOMPPAD();
d6079 1
a6079 1
    PL_subline = CopLINE(PL_curcop);
d6081 1
a6081 1
    av_store(PL_comppad_name, 0, newSVpvn("@@_", 2));
d6103 1
a6103 1
Perl_yywarn(pTHX_ char *s)
d6106 2
a6107 1
    PL_in_eval |= EVAL_WARNONLY;
d6109 1
a6109 1
    PL_in_eval &= ~EVAL_WARNONLY;
d6114 1
a6114 1
Perl_yyerror(pTHX_ char *s)
a6139 4
#ifdef USE_PURE_BISON
/*  GNU Bison sets the value -2 */
    else if (yychar == -2) {
#else
a6140 1
#endif
d6150 1
a6150 1
	SV *where_sv = sv_2mortal(newSVpvn("next char ", 10));
d6152 1
a6152 1
	    Perl_sv_catpvf(aTHX_ where_sv, "^%c", toCTRL(yychar));
d6154 1
a6154 1
	    Perl_sv_catpvf(aTHX_ where_sv, "%c", yychar);
d6156 1
a6156 1
	    Perl_sv_catpvf(aTHX_ where_sv, "\\%03o", yychar & 255);
d6160 2
a6161 2
    Perl_sv_catpvf(aTHX_ msg, " at %s line %"IVdf", ",
		   CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
d6163 1
a6163 1
	Perl_sv_catpvf(aTHX_ msg, "near \"%.*s\"\n", contlen, context);
d6165 5
a6169 5
	Perl_sv_catpvf(aTHX_ msg, "%s\n", where);
    if (PL_multi_start < PL_multi_end && (U32)(CopLINE(PL_curcop) - PL_multi_end) <= 1) {
        Perl_sv_catpvf(aTHX_ msg,
        "  (Might be a runaway multi-line %c%c string starting on line %"IVdf")\n",
                (int)PL_multi_open,(int)PL_multi_close,(IV)PL_multi_start);
d6172 4
a6175 2
    if (PL_in_eval & EVAL_WARNONLY)
	Perl_warn(aTHX_ "%"SVf, msg);
d6177 3
a6179 9
	qerror(msg);
    if (PL_error_count >= 10) {
	if (PL_in_eval && SvCUR(ERRSV))
	    Perl_croak(aTHX_ "%_%s has too many errors.\n",
		       ERRSV, CopFILE(PL_curcop));
	else
	    Perl_croak(aTHX_ "%s has too many errors.\n",
		       CopFILE(PL_curcop));
    }
a6185 20
#ifdef PERL_OBJECT
#include "XSUB.h"
#endif

/*
 * restore_rsfp
 * Restore a source filter.
 */

static void
restore_rsfp(pTHXo_ void *f)
{
    PerlIO *fp = (PerlIO*)f;

    if (PL_rsfp == PerlIO_stdin())
	PerlIO_clearerr(PL_rsfp);
    else if (PL_rsfp && (PL_rsfp != fp))
	PerlIO_close(PL_rsfp);
    PL_rsfp = fp;
}
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d16 1
a16 1
 * parser, perly.y.
a30 4
#ifndef PERL_NO_UTF16_FILTER
static I32 utf16_textfilter(pTHXo_ int idx, SV *sv, int maxlen);
static I32 utf16rev_textfilter(pTHXo_ int idx, SV *sv, int maxlen);
#endif
d38 1
a38 1
/* In variables name $^X, these are the legal values for X.
a41 7
/* On MacOS, respect nonbreaking spaces */
#ifdef MACOS_TRADITIONAL
#define SPACE_OR_TAB(c) ((c)==' '||(c)=='\312'||(c)=='\t')
#else
#define SPACE_OR_TAB(c) ((c)==' '||(c)=='\t')
#endif

d61 6
d72 2
a73 6
#  ifndef YYMAXLEVEL
#    define YYMAXLEVEL 100
#  endif
YYSTYPE* yylval_pointer[YYMAXLEVEL];
int* yychar_pointer[YYMAXLEVEL];
int yyactlevel = -1;
d76 3
a78 3
#  define yylval (*yylval_pointer[yyactlevel])
#  define yychar (*yychar_pointer[yyactlevel])
#  define PERL_YYLEX_PARAM yylval_pointer[yyactlevel],yychar_pointer[yyactlevel]
d80 1
a80 1
#  define yylex()      Perl_yylex_r(aTHX_ yylval_pointer[yyactlevel],yychar_pointer[yyactlevel])
d115 1
a115 1
 * Rop          : relational operator <= != gt
d201 2
a202 1
    else
d204 1
d215 1
a215 2
    else {
	assert(s >= oldbp);
a216 1
    }
d268 1
d322 30
d361 1
d379 1
a385 2
    SAVEPPTR(PL_last_lop);
    SAVEPPTR(PL_last_uni);
a412 1
    PL_nexttoke = 0;
a426 1
    PL_last_lop = PL_last_uni = Nullch;
d457 1
d466 1
a466 1
    while (SPACE_OR_TAB(*s)) s++;
d471 1
a471 1
    if (SPACE_OR_TAB(*s))
d473 1
a473 1
    else
d475 1
a475 1
    while (SPACE_OR_TAB(*s)) s++;
d481 1
a481 1
    while (SPACE_OR_TAB(*s))
d491 1
a491 1
    while (SPACE_OR_TAB(*e) || *e == '\r' || *e == '\f')
d498 1
a498 6
    if (t - s > 0) {
#ifdef USE_ITHREADS
	Safefree(CopFILE(PL_curcop));
#else
	SvREFCNT_dec(CopFILEGV(PL_curcop));
#endif
a499 1
    }
d513 1
d515 1
a515 1
	while (s < PL_bufend && SPACE_OR_TAB(*s))
a567 1
	    PL_last_lop = PL_last_uni = Nullch;
d632 1
d644 2
a645 2
        Perl_warner(aTHX_ WARN_AMBIGUOUS,
		   "Warning: Use of \"%s\" without parens is ambiguous",
d698 1
d725 1
a725 1
STATIC void
d758 1
a758 1

d800 1
d822 1
a822 1
    bool utf = SvUTF8(sv) ? TRUE : FALSE;
d825 1
a825 1
	STRLEN skip;
d828 1
a828 1
	    n = utf8_to_uv((U8*)start, len, &skip, 0);
d840 1
a840 1
/*
d860 1
a860 1
            s = scan_num(s, &yylval);
d873 1
a873 1
    force_next(WORD);
d899 1
a899 1
    if (SvTYPE(sv) >= SVt_PVIV && SvIVX(sv) == -1)
a976 2
	    if (SvUTF8(sv))
		SvUTF8_on(nsv);
d979 1
a979 1
	}
d1011 1
a1025 2
    SAVEPPTR(PL_last_lop);
    SAVEPPTR(PL_last_uni);
a1036 1
    PL_last_lop = PL_last_uni = Nullch;
a1068 3
	SV *sv = newSVpvn("",0);
	if (SvUTF8(PL_linestr))
	    SvUTF8_on(sv);
d1070 1
a1070 1
	yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
a1084 1
	PL_last_lop = PL_last_uni = Nullch;
d1185 1
a1185 1
		
d1196 2
a1197 1
    bool has_utf8 = FALSE;			/* embedded \x{} */
d1203 1
a1203 1
    I32 this_utf8 = (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op)
d1283 1
a1283 1
		    else if (c == '{')
d1285 1
a1285 1
		    else if (c == '}')
d1320 19
a1340 2
	    bool to_be_utf8 = FALSE;

d1354 1
d1379 1
d1385 2
a1386 1
		    goto default_action;
d1392 2
a1393 5
		{
		    STRLEN len = 0;	/* disallow underscores */
		    uv = (UV)scan_oct(s, 3, &len);
		    s += len;
		}
d1405 2
a1406 6
		    else {
			STRLEN len = 1;		/* allow underscores */
			uv = (UV)scan_hex(s + 1, e - s - 1, &len);
			to_be_utf8 = TRUE;
		    }
		    s = e + 1;
d1409 2
a1410 5
		    {
			STRLEN len = 0;		/* disallow underscores */
			uv = (UV)scan_hex(s, 2, &len);
			s += len;
		    }
d1415 3
a1417 9
		 * There will always enough room in sv since such
		 * escapes will be longer than any UT-F8 sequence
		 * they can end up as. */

		/* This spot is wrong for EBCDIC.  Characters like
		 * the lowercase letters and digits are >127 in EBCDIC,
		 * so here they would need to be mapped to the Unicode
		 * repertoire.   --jhi */
		
d1419 3
a1421 7
		    if (!has_utf8 && (to_be_utf8 || uv > 255)) {
		        /* Might need to recode whatever we have
			 * accumulated so far if it contains any
			 * hibit chars.
			 *
			 * (Can't we keep track of that and avoid
			 *  this rescan? --jhi)
a1424 1

d1426 1
a1426 1
			    if (UTF8_IS_CONTINUED(*c))
d1432 1
a1432 4
			  
			    d = SvGROW(sv,
				       SvCUR(sv) + hicount + 1) +
				         (d - old_pvx);
d1439 4
a1442 3
			        if (UTF8_IS_CONTINUED(*src)) {
 				    *dst-- = UTF8_EIGHT_BIT_LO(*src);
 				    *dst-- = UTF8_EIGHT_BIT_HI(*src--);
d1451 1
a1451 1
		    if (to_be_utf8 || has_utf8 || uv > 255) {
d1453 1
a1453 8
			has_utf8 = TRUE;
			if (PL_lex_inwhat == OP_TRANS &&
			    PL_sublex_info.sub_op) {
			    PL_sublex_info.sub_op->op_private |=
				(PL_lex_repl ? OPpTRANS_FROM_UTF
					     : OPpTRANS_TO_UTF);
			    utf = TRUE;
			}
d1472 1
a1472 1

d1479 1
a1479 1
		    res = new_constant( Nullch, 0, "charnames",
a1480 2
		    if (has_utf8)
			sv_utf8_upgrade(res);
d1482 1
a1482 1
		    if (!has_utf8 && SvUTF8(res)) {
a1485 1
			*d = '\0';
a1486 2
			/* this just broke our allocation above... */
			SvGROW(sv, send - start);
d1488 1
a1488 1
			has_utf8 = TRUE;
d1513 1
a1513 2
		*d = toCTRL(*d);
		d++;
d1515 2
a1516 4
		{
		    U8 c = *s++;
		    *d++ = toCTRL(c);
		}
d1557 1
a1557 28
    default_action:
       if (UTF8_IS_CONTINUED(*s) && (this_utf8 || has_utf8)) {
           STRLEN len = (STRLEN) -1;
           UV uv;
           if (this_utf8) {
               uv = utf8_to_uv((U8*)s, send - s, &len, 0);
           }
           if (len == (STRLEN)-1) {
               /* Illegal UTF8 (a high-bit byte), make it valid. */
               char *old_pvx = SvPVX(sv);
               /* need space for one extra char (NOTE: SvCUR() not set here) */
               d = SvGROW(sv, SvLEN(sv) + 1) + (d - old_pvx);
               d = (char*)uv_to_utf8((U8*)d, (U8)*s++);
           }
           else {
               while (len--)
                   *d++ = *s++;
           }
           has_utf8 = TRUE;
	   if (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op) {
	       PL_sublex_info.sub_op->op_private |=
		   (PL_lex_repl ? OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF);
	       utf = TRUE;
	   }
           continue;
       }

       *d++ = *s++;
d1564 1
a1564 1
    if (has_utf8)
d1576 1
a1576 1
	    sv = new_constant(start, s - start, (PL_lex_inpat ? "qr" : "q"),
d1578 1
a1578 1
			      ( PL_lex_inwhat == OP_TRANS
d1849 1
a1849 1
 * 'pre-processing' function into the current source input stream.
d1859 1
a1859 1
 * and the IoDIRP/IoANY field is used to store the function pointer,
d1877 1
a1877 1
    IoANY(datasv) = (void *)funcp; /* stash funcp into spare field */
d1885 1
a1885 1

d1897 1
a1897 1
    if (IoANY(datasv) == (void *)funcp) {
d1899 1
a1899 1
	IoANY(datasv) = (void *)NULL;
d1912 2
a1913 2


d1926 1
a1926 1
	if (maxlen) {
d1959 1
a1959 1
    funcp = (filter_t)IoANY(datasv);
a1989 25
STATIC HV *
S_find_in_my_stash(pTHX_ char *pkgname, I32 len)
{
    GV *gv;

    if (len == 11 && *pkgname == '_' && strEQ(pkgname, "__PACKAGE__"))
        return PL_curstash;

    if (len > 2 &&
        (pkgname[len - 2] == ':' && pkgname[len - 1] == ':') &&
        (gv = gv_fetchpv(pkgname, FALSE, SVt_PVHV)))
    {
        return GvHV(gv);			/* Foo:: */
    }

    /* use constant CLASS => 'MyClass' */
    if ((gv = gv_fetchpv(pkgname, FALSE, SVt_PVCV))) {
        SV *sv;
        if (GvCV(gv) && (sv = cv_const_sv(GvCV(gv)))) {
            pkgname = SvPV_nolen(sv);
        }
    }

    return gv_stashpv(pkgname, FALSE);
}
d2023 1
d2025 3
a2027 21
int
Perl_yylex_r(pTHX_ YYSTYPE *lvalp, int *lcharp)
{
    int r;

    yyactlevel++;
    yylval_pointer[yyactlevel] = lvalp;
    yychar_pointer[yyactlevel] = lcharp;
    if (yyactlevel >= YYMAXLEVEL)
	Perl_croak(aTHX_ "panic: YYMAXLEVEL");

    r = Perl_yylex(aTHX);

    yyactlevel--;

    return r;
}
#endif

#ifdef __SC__
#pragma segment Perl_yylex
a2028 2
int
Perl_yylex(pTHX)
d2030 1
d2037 5
a2041 1
    bool bof = FALSE;
a2048 3
	DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Tokener saw identifier '%s'\n", PL_tokenbuf); })

d2073 1
a2073 1
	/*
d2148 3
a2150 8
	    if ((!gv || ((PL_tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
		 && ckWARN(WARN_AMBIGUOUS))
	    {
                /* Downgraded from fatal to warning 20000522 mjd */
		Perl_warner(aTHX_ WARN_AMBIGUOUS,
			    "Possible unintended interpolation of %s in string",
			     PL_tokenbuf);
	    }
a2180 4
	DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Next token after '%s' was known, type %"IVdf"\n", PL_bufptr,
              (IV)PL_nexttype[PL_nexttoke]); })

a2211 2
	    DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Saw case modifier at '%s'\n", PL_bufptr); })
a2261 2
	DEBUG_T({ PerlIO_printf(Perl_debug_log,
              "### Interpolated variable at '%s'\n", PL_bufptr); })
d2358 1
a2358 1
    DEBUG_T( {
a2377 3
            DEBUG_T( { PerlIO_printf(Perl_debug_log,
                        "### Tokener got EOF\n");
            } )
a2432 1
	    PL_last_lop = PL_last_uni = Nullch;
a2442 1
	    bof = PL_rsfp ? TRUE : FALSE;
a2459 1
		    PL_last_lop = PL_last_uni = Nullch;
a2463 1
		PL_last_lop = PL_last_uni = Nullch;
a2466 30
	    /* if it looks like the start of a BOM, check if it in fact is */
	    else if (bof && (!*s || *(U8*)s == 0xEF || *(U8*)s >= 0xFE)) {
#ifdef PERLIO_IS_STDIO
#  ifdef __GNU_LIBRARY__
#    if __GNU_LIBRARY__ == 1 /* Linux glibc5 */
#      define FTELL_FOR_PIPE_IS_BROKEN
#    endif
#  else
#    ifdef __GLIBC__
#      if __GLIBC__ == 1 /* maybe some glibc5 release had it like this? */
#        define FTELL_FOR_PIPE_IS_BROKEN
#      endif
#    endif
#  endif
#endif
#ifdef FTELL_FOR_PIPE_IS_BROKEN
		/* This loses the possibility to detect the bof
		 * situation on perl -P when the libc5 is being used.
		 * Workaround?  Maybe attach some extra state to PL_rsfp?
		 */
		if (!PL_preprocess)
		    bof = PerlIO_tell(PL_rsfp) == SvCUR(PL_linestr);
#else
		bof = PerlIO_tell(PL_rsfp) == SvCUR(PL_linestr);
#endif
		if (bof) {
		    PL_bufend = SvPVX(PL_linestr) + SvCUR(PL_linestr);
		    s = swallow_bom((U8*)s);
		}
	    }
a2475 1
		    PL_last_lop = PL_last_uni = Nullch;
a2489 1
	PL_last_lop = PL_last_uni = Nullch;
a2577 1
#ifndef MACOS_TRADITIONAL
d2602 1
a2602 1
		    PerlProc_execv(ipath, EXEC_ARGV_CAST(newargv));
a2604 1
#endif
d2611 1
a2611 1
		    while (SPACE_OR_TAB(*d)) d++;
a2630 1
			    PL_last_lop = PL_last_uni = Nullch;
d2649 1
a2649 1
	Perl_croak(aTHX_
a2652 3
#ifdef MACOS_TRADITIONAL
    case '\312':
#endif
a2657 5
	    if (*s == '#' && s == PL_linestart && PL_in_eval && !PL_rsfp) {
		/* handle eval qq[#line 1 "foo"\n ...] */
		CopLINE_dec(PL_curcop);
		incline(s);
	    }
a2676 2
	    I32 ftst = 0;

d2681 1
a2681 1
	    while (s < PL_bufend && SPACE_OR_TAB(*s))
a2685 3
                DEBUG_T( { PerlIO_printf(Perl_debug_log,
                            "### Saw unary minus before =>, forcing word '%s'\n", s);
                } )
d2689 1
d2691 27
a2717 33
	    case 'r': ftst = OP_FTEREAD;	break;
	    case 'w': ftst = OP_FTEWRITE;	break;
	    case 'x': ftst = OP_FTEEXEC;	break;
	    case 'o': ftst = OP_FTEOWNED;	break;
	    case 'R': ftst = OP_FTRREAD;	break;
	    case 'W': ftst = OP_FTRWRITE;	break;
	    case 'X': ftst = OP_FTREXEC;	break;
	    case 'O': ftst = OP_FTROWNED;	break;
	    case 'e': ftst = OP_FTIS;		break;
	    case 'z': ftst = OP_FTZERO;		break;
	    case 's': ftst = OP_FTSIZE;		break;
	    case 'f': ftst = OP_FTFILE;		break;
	    case 'd': ftst = OP_FTDIR;		break;
	    case 'l': ftst = OP_FTLINK;		break;
	    case 'p': ftst = OP_FTPIPE;		break;
	    case 'S': ftst = OP_FTSOCK;		break;
	    case 'u': ftst = OP_FTSUID;		break;
	    case 'g': ftst = OP_FTSGID;		break;
	    case 'k': ftst = OP_FTSVTX;		break;
	    case 'b': ftst = OP_FTBLK;		break;
	    case 'c': ftst = OP_FTCHR;		break;
	    case 't': ftst = OP_FTTTY;		break;
	    case 'T': ftst = OP_FTTEXT;		break;
	    case 'B': ftst = OP_FTBINARY;	break;
	    case 'M': case 'A': case 'C':
		gv_fetchpv("\024",TRUE, SVt_PV);
		switch (tmp) {
		case 'M': ftst = OP_FTMTIME;	break;
		case 'A': ftst = OP_FTATIME;	break;
		case 'C': ftst = OP_FTCTIME;	break;
		default:			break;
		}
		break;
a2721 5
	    PL_last_lop_op = ftst;
	    DEBUG_T( { PerlIO_printf(Perl_debug_log,
				     "### Saw file test %c\n", (int)ftst);
	    } )
	    FTST(ftst);
d2850 4
d2873 3
a2875 15
		    if (!PL_in_my && len == 6 && strnEQ(s, "lvalue", len))
			CvLVALUE_on(PL_compcv);
		    else if (!PL_in_my && len == 6 && strnEQ(s, "locked", len))
			CvLOCKED_on(PL_compcv);
		    else if (!PL_in_my && len == 6 && strnEQ(s, "method", len))
			CvMETHOD_on(PL_compcv);
		    /* After we've set the flags, it could be argued that
		       we don't need to do the attributes.pm-based setting
		       process, and shouldn't bother appending recognized
		       flags. To experiment with that, uncomment the
		       following "else": */
		    /* else */
		        attrs = append_elem(OP_LIST, attrs,
					    newSVOP(OP_CONST, 0,
					      	    newSVpvn(s, len)));
d2920 2
a2921 1
	CLINE;
d2965 1
a2965 1
	    while (s < PL_bufend && SPACE_OR_TAB(*s))
d2972 1
a2972 1
		while (d < PL_bufend && SPACE_OR_TAB(*d))
d2978 1
a2978 1
		while (d < PL_bufend && SPACE_OR_TAB(*d))
a2982 3
		    if (UTF && !IN_BYTE && is_utf8_string((U8*)PL_tokenbuf, 0) &&
			PL_nextval[PL_nexttoke-1].opval)
		      SvUTF8_on(((SVOP*)PL_nextval[PL_nexttoke-1].opval)->op_sv);
d3098 1
a3098 1
	if (PL_lex_brackets < PL_lex_formbrack && PL_lex_state != LEX_INTERPNORMAL)
d3195 1
a3195 1
	    for (t = s; SPACE_OR_TAB(*t); t++) ;
d3197 1
a3197 1
	    for (t = s; SPACE_OR_TAB(*t) || *t == '\r'; t++) ;
d3420 2
a3421 2
	    if (PL_oldoldbufptr == PL_last_uni
		&& (*PL_last_uni != 's' || s - PL_last_uni < 5
d3465 1
a3465 4
	s = scan_num(s, &yylval);
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw number in '%s'\n", s);
        } )
a3471 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw string before '%s'\n", s);
        } )
a3487 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw string before '%s'\n", s);
        } )
d3501 1
a3501 1
	    if (*d == '$' || *d == '@@' || *d == '\\' || UTF8_IS_CONTINUED(*d)) {
a3509 3
        DEBUG_T( { PerlIO_printf(Perl_debug_log,
                    "### Saw backtick string before '%s'\n", s);
        } )
d3535 1
a3535 1
		s = scan_num(s, &yylval);
d3546 1
a3546 1
		    s = scan_num(s, &yylval);
d3621 1
a3621 1
	if (*d == '=' && d[1] == '>') {
a3624 2
	    if (UTF && !IN_BYTE && is_utf8_string((U8*)PL_tokenbuf, len))
	      SvUTF8_on(((SVOP*)yylval.opval)->op_sv);
d3709 1
a3709 1
			Perl_warner(aTHX_ WARN_BAREWORD,
d3776 1
a3779 11

		/* Is this a word before a => operator? */
		if (*s == '=' && s[1] == '>') {
		    CLINE;
		    sv_setpv(((SVOP*)yylval.opval)->op_sv, PL_tokenbuf);
		    if (UTF && !IN_BYTE && is_utf8_string((U8*)PL_tokenbuf, len))
		      SvUTF8_on(((SVOP*)yylval.opval)->op_sv);
		    TERM(WORD);
		}

		/* If followed by a paren, it's certainly a subroutine. */
d3783 1
a3783 1
			for (d = s + 1; SPACE_OR_TAB(*d); d++) ;
d3920 1
a3920 1
		    IoTYPE(GvIOp(gv)) = IoTYPE_PIPE;
d3922 1
a3922 1
		    IoTYPE(GvIOp(gv)) = IoTYPE_STD;
d3924 1
a3924 1
		    IoTYPE(GvIOp(gv)) = IoTYPE_RDONLY;
d3933 1
a3933 1
		    if (IoTYPE(GvIOp(gv)) == IoTYPE_RDONLY) {
d3940 1
a3940 1
			((FILE*)PL_rsfp)->flags &= ~_F_BIN;
d4097 1
a4097 1
	
d4301 1
a4301 1
	
d4369 1
a4369 1
		PL_in_my_stash = find_in_my_stash(PL_tokenbuf, len);
d4446 1
a4446 1
	
a4476 1
		    SV *sv;
a4496 3
			sv = newSVpvn(b, d-b);
			if (DO_UTF8(PL_lex_stuff))
			    SvUTF8_on(sv);
d4498 1
a4498 1
					    newSVOP(OP_CONST, 0, tokeq(sv)));
d4506 1
a4506 1
	    if (PL_lex_stuff) {
d4508 1
a4508 2
		PL_lex_stuff = Nullsv;
	    }
d4608 1
a4608 1
	
d4776 4
a4779 1
		    if (!s)
d4781 1
d4897 1
a4897 1
		if (*d != '0' && isDIGIT(*d))
d4952 1
a4952 1
	    if (ctl_l[0] == '\0')
a4976 3
#ifdef __SC__
#pragma segment Main
#endif
d5029 1
a5029 1
	    if (strEQ(d,"chop"))		return -KEY_chop;
d5034 1
a5034 1
	    if (strEQ(d,"chomp"))		return -KEY_chomp;
d5096 1
a5096 1
           if (strEQ(d,"each"))                return -KEY_each;
d5246 1
a5246 1
           if (strEQ(d,"keys"))                return -KEY_keys;
d5337 1
a5337 1
           if (strEQ(d,"pop"))                 return -KEY_pop;
d5341 1
a5341 1
           if (strEQ(d,"push"))                return -KEY_push;
d5448 1
a5448 1
               if (strEQ(d,"shift"))           return -KEY_shift;
d5477 1
a5477 1
           if (strEQ(d,"splice"))              return -KEY_splice;
d5557 1
a5557 1
           if (strEQ(d,"unshift"))             return -KEY_unshift;
d5603 1
d5658 1
a5658 1

d5662 1
d5664 1
a5664 1
	       ? "(possibly a missing \"use charnames ...\")"
d5666 1
a5666 10
	msg = Perl_newSVpvf(aTHX_ "Constant(%s) unknown: %s",
			    (type ? type: "undef"), why2);

	/* This is convoluted and evil ("goto considered harmful")
	 * but I do not understand the intricacies of all the different
	 * failure modes of %^H in here.  The goal here is to make
	 * the most probable error message user-friendly. --jhi */

	goto msgdone;

d5668 1
a5668 1
	msg = Perl_newSVpvf(aTHX_ "Constant(%s): %s%s%s",
a5669 1
    msgdone:
d5689 1
a5689 1

d5693 1
a5693 1

d5695 1
a5695 1
    EXTEND(sp, 3);
d5701 1
d5704 1
a5704 1

d5706 1
a5706 1

d5719 1
a5719 1

d5724 1
a5724 1

d5735 1
a5735 1

d5755 1
a5755 1
	else if (UTF && UTF8_IS_START(*s) && isALNUM_utf8((U8*)s)) {
d5757 1
a5757 1
	    while (UTF8_IS_CONTINUED(*t) && is_utf8_mark((U8*)t))
d5807 1
a5807 1
	    else if (UTF && UTF8_IS_START(*s) && isALNUM_utf8((U8*)s)) {
d5809 1
a5809 1
		while (UTF8_IS_CONTINUED(*t) && is_utf8_mark((U8*)t))
d5850 1
a5850 1
		if (!SPACE_OR_TAB(ch)) {
d5862 1
a5862 1
		    while (e < send && UTF8_IS_CONTINUED(*e) && is_utf8_mark((U8*)e))
d5876 1
a5876 1
	    while (s < send && SPACE_OR_TAB(*s)) s++;
d5878 1
d5889 2
a5890 2
	}
	/* Handle extended ${^Foo} variables
d5910 1
d5956 4
a5959 1
    if (!s)
d5961 1
d5993 4
a5996 1
    if (!s)
d5998 1
d6006 1
a6006 1
	if (PL_lex_stuff) {
d6008 4
a6011 2
	    PL_lex_stuff = Nullsv;
	}
d6066 4
a6069 1
    if (!s)
d6071 1
d6077 1
a6077 1
	if (PL_lex_stuff) {
d6079 4
a6082 2
	    PL_lex_stuff = Nullsv;
	}
d6086 9
a6094 2
    New(803,tbl,256,short);
    o = newPVOP(OP_TRANS, 0, (char*)tbl);
d6097 1
a6097 1
    while (strchr("cds", *s)) {
d6104 18
d6124 1
a6124 3
    o->op_private = del|squash|complement|
      (DO_UTF8(PL_lex_stuff)? OPpTRANS_FROM_UTF : 0)|
      (DO_UTF8(PL_lex_repl) ? OPpTRANS_TO_UTF   : 0);
d6134 1
d6150 1
a6150 1
    for (peek = s; SPACE_OR_TAB(*peek); peek++) ;
a6266 1
	PL_last_lop = PL_last_uni = Nullch;
a6277 1
	PL_last_lop = PL_last_uni = Nullch;
a6318 2
    if (UTF && !IN_BYTE && is_utf8_string((U8*)SvPVX(tmpstr), SvCUR(tmpstr)))
	SvUTF8_on(tmpstr);
d6469 1
a6469 1

d6476 5
a6480 5
   On success, the SV with the resulting string is put into lex_stuff or,
   if that is already non-NULL, into lex_repl. The second case occurs only
   when parsing the RHS of the special constructs s/// and tr/// (y///).
   For convenience, the terminating delimiter character is stuffed into
   SvIVX of the SV.
d6486 1
d6493 1
a6493 1
    bool has_utf8 = FALSE;		/* is there any utf8 content? */
d6504 2
a6505 2
    if (UTF8_IS_CONTINUED(term) && UTF)
	has_utf8 = TRUE;
d6551 2
a6552 2
		else if (!has_utf8 && UTF8_IS_CONTINUED(*s) && UTF)
		    has_utf8 = TRUE;
d6580 2
a6581 2
		else if (!has_utf8 && UTF8_IS_CONTINUED(*s) && UTF)
		    has_utf8 = TRUE;
a6634 1
	PL_last_lop = PL_last_uni = Nullch;
d6636 1
a6636 1

d6641 1
a6641 1
    if (has_utf8)
d6655 1
a6655 1

d6684 1
a6684 1

d6686 1
a6686 1
Perl_scan_num(pTHX_ char *start, YYSTYPE* lvalp)
d6691 1
a6691 1
    NV nv;				/* number read, as a double */
d6702 1
a6702 1

d6717 1
d6805 1
d6837 1
d6846 1
d6872 1
a6872 1
	    /* skip underscores, checking for misplaced ones
d6876 1
d6892 1
d6948 3
a6950 1
#if defined(Strtol) && defined(Strtoul)
d6953 29
d6996 1
a6996 1
	    	floatit = TRUE; /* Probably just too large. */
a6998 2
	    else if (uv <= IV_MAX)
		sv_setiv(sv, uv); /* Prefer IVs over UVs. */
d7003 2
a7004 51
	    nv = Atof(PL_tokenbuf);
	    sv_setnv(sv, nv);
	}
#else
	/*
	   No working strtou?ll?.

	   Unfortunately atol() doesn't do range checks (returning
	   LONG_MIN/LONG_MAX, and setting errno to ERANGE on overflows)
	   everywhere [1], so we cannot use use atol() (or atoll()).
	   If we could, they would be used, as Atol(), very much like
	   Strtol() and Strtoul() are used above.

	   [1] XXX Configure test needed to check for atol()
	           (and atoll()) overflow behaviour XXX

	   --jhi

	   We need to do this the hard way.  */

	nv = Atof(PL_tokenbuf);

	/* See if we can make do with an integer value without loss of
	   precision.  We use U_V to cast to a UV, because some
	   compilers have issues.  Then we try casting it back and see
	   if it was the same [1].  We only do this if we know we
	   specifically read an integer.  If floatit is true, then we
	   don't need to do the conversion at all.

	   [1] Note that this is lossy if our NVs cannot preserve our
	   UVs.  There are metaconfig defines NV_PRESERVES_UV (a boolean)
	   and NV_PRESERVES_UV_BITS (a number), but in general we really
	   do hope all such potentially lossy platforms have strtou?ll?
	   to do a lossless IV/UV conversion.

	   Maybe could do some tricks with DBL_DIG, LDBL_DIG and
	   DBL_MANT_DIG and LDBL_MANT_DIG (these are already available
	   as NV_DIG and NV_MANT_DIG)?
	
	   --jhi
	   */
	{
	    UV uv = U_V(nv);
	    if (!floatit && (NV)uv == nv) {
		if (uv <= IV_MAX)
		    sv_setiv(sv, uv); /* Prefer IVs over UVs. */
		else
		    sv_setuv(sv, uv);
	    }
	    else
		sv_setnv(sv, nv);
d7009 1
a7009 1
	    sv = new_constant(PL_tokenbuf, d - PL_tokenbuf,
d7024 1
a7024 1
		U8 tmpbuf[UTF8_MAXLEN+1];
d7069 1
a7069 2
		    if (!UTF||IN_BYTE)
		      sv_utf8_downgrade(sv, TRUE);
d7079 1
a7079 1
	lvalp->opval = newSVOP(OP_CONST, 0, sv);
d7081 1
a7081 1
	lvalp->opval = Nullop;
d7089 1
d7096 1
a7096 1
	if (*s == '.' || *s == /*{*/'}') {
d7099 1
a7099 1
	    for (t = s+1;SPACE_OR_TAB(*t); t++) ;
d7101 1
a7101 1
	    for (t = s+1;SPACE_OR_TAB(*t) || *t == '\r'; t++) ;
a7136 1
	    PL_last_lop = PL_last_uni = Nullch;
d7180 1
a7232 3
#ifdef __SC__
#pragma segment Perl_yylex
#endif
d7236 1
d7246 1
d7313 1
a7313 1
	    Perl_croak(aTHX_ "%"SVf"%s has too many errors.\n",
a7322 64
#ifdef __SC__
#pragma segment Main
#endif

STATIC char*
S_swallow_bom(pTHX_ U8 *s)
{
    STRLEN slen;
    slen = SvCUR(PL_linestr);
    switch (*s) {
    case 0xFF:
	if (s[1] == 0xFE) {
	    /* UTF-16 little-endian */
	    if (s[2] == 0 && s[3] == 0)  /* UTF-32 little-endian */
		Perl_croak(aTHX_ "Unsupported script encoding");
#ifndef PERL_NO_UTF16_FILTER
	    DEBUG_p(PerlIO_printf(Perl_debug_log, "UTF-LE script encoding\n"));
	    s += 2;
	    if (PL_bufend > (char*)s) {
		U8 *news;
		I32 newlen;

		filter_add(utf16rev_textfilter, NULL);
		New(898, news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
		PL_bufend = (char*)utf16_to_utf8_reversed(s, news,
						 PL_bufend - (char*)s - 1,
						 &newlen);
		Copy(news, s, newlen, U8);
		SvCUR_set(PL_linestr, newlen);
		PL_bufend = SvPVX(PL_linestr) + newlen;
		news[newlen++] = '\0';
		Safefree(news);
	    }
#else
	    Perl_croak(aTHX_ "Unsupported script encoding");
#endif
	}
	break;

    case 0xFE:
	if (s[1] == 0xFF) {   /* UTF-16 big-endian */
#ifndef PERL_NO_UTF16_FILTER
	    DEBUG_p(PerlIO_printf(Perl_debug_log, "UTF-16BE script encoding\n"));
	    s += 2;
	    if (PL_bufend > (char *)s) {
		U8 *news;
		I32 newlen;

		filter_add(utf16_textfilter, NULL);
		New(898, news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
		PL_bufend = (char*)utf16_to_utf8(s, news,
						 PL_bufend - (char*)s,
						 &newlen);
		Copy(news, s, newlen, U8);
		SvCUR_set(PL_linestr, newlen);
		PL_bufend = SvPVX(PL_linestr) + newlen;
		news[newlen++] = '\0';
		Safefree(news);
	    }
#else
	    Perl_croak(aTHX_ "Unsupported script encoding");
#endif
	}
	break;
a7323 15
    case 0xEF:
	if (slen > 2 && s[1] == 0xBB && s[2] == 0xBF) {
	    DEBUG_p(PerlIO_printf(Perl_debug_log, "UTF-8 script encoding\n"));
	    s += 3;                      /* UTF-8 */
	}
	break;
    case 0:
	if (slen > 3 && s[1] == 0 &&  /* UTF-32 big-endian */
	    s[2] == 0xFE && s[3] == 0xFF)
	{
	    Perl_croak(aTHX_ "Unsupported script encoding");
	}
    }
    return (char*)s;
}
a7344 40

#ifndef PERL_NO_UTF16_FILTER
static I32
utf16_textfilter(pTHXo_ int idx, SV *sv, int maxlen)
{
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count) {
	U8* tmps;
	U8* tend;
	I32 newlen;
	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	if (!*SvPV_nolen(sv))
	/* Game over, but don't feed an odd-length string to utf16_to_utf8 */
	return count;

	tend = utf16_to_utf8((U8*)SvPVX(sv), tmps, SvCUR(sv), &newlen);
	sv_usepvn(sv, (char*)tmps, tend - tmps);
    }
    return count;
}

static I32
utf16rev_textfilter(pTHXo_ int idx, SV *sv, int maxlen)
{
    I32 count = FILTER_READ(idx+1, sv, maxlen);
    if (count) {
	U8* tmps;
	U8* tend;
	I32 newlen;
	if (!*SvPV_nolen(sv))
	/* Game over, but don't feed an odd-length string to utf16_to_utf8 */
	return count;

	New(898, tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	tend = utf16_to_utf8_reversed((U8*)SvPVX(sv), tmps, SvCUR(sv), &newlen);
	sv_usepvn(sv, (char*)tmps, tend - tmps);
    }
    return count;
}
#endif
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a28 2
static char c_without_g[] = "Use of /c modifier is meaningless without /g";
static char c_in_subst[] = "Use of /c modifier is meaningless in s///";
d30 1
a30 1
static void restore_rsfp(pTHX_ void *f);
d32 2
a33 2
static I32 utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen);
static I32 utf16rev_textfilter(pTHX_ int idx, SV *sv, int maxlen);
d39 2
a40 5
#ifdef USE_UTF8_SCRIPTS
#   define UTF (!IN_BYTES)
#else
#   define UTF ((PL_linestr && DO_UTF8(PL_linestr)) || (PL_hints & HINT_UTF8))
#endif
d42 1
a42 1
/* In variables named $^X, these are the legal values for X.
d129 20
a148 30
/* Note that REPORT() and REPORT2() will be expressions that supply
 * their own trailing comma, not suitable for statements as such. */
#ifdef DEBUGGING /* Serve -DT. */
#   define REPORT(x,retval) tokereport(x,s,(int)retval),
#   define REPORT2(x,retval) tokereport(x,s, yylval.ival),
#else
#   define REPORT(x,retval)
#   define REPORT2(x,retval)
#endif

#define TOKEN(retval) return (REPORT2("token",retval) PL_bufptr = s,(int)retval)
#define OPERATOR(retval) return (REPORT2("operator",retval) PL_expect = XTERM, PL_bufptr = s,(int)retval)
#define AOPERATOR(retval) return ao((REPORT2("aop",retval) PL_expect = XTERM, PL_bufptr = s,(int)retval))
#define PREBLOCK(retval) return (REPORT2("preblock",retval) PL_expect = XBLOCK,PL_bufptr = s,(int)retval)
#define PRETERMBLOCK(retval) return (REPORT2("pretermblock",retval) PL_expect = XTERMBLOCK,PL_bufptr = s,(int)retval)
#define PREREF(retval) return (REPORT2("preref",retval) PL_expect = XREF,PL_bufptr = s,(int)retval)
#define TERM(retval) return (CLINE, REPORT2("term",retval) PL_expect = XOPERATOR, PL_bufptr = s,(int)retval)
#define LOOPX(f) return(yylval.ival=f, REPORT("loopx",f) PL_expect = XTERM,PL_bufptr = s,(int)LOOPEX)
#define FTST(f) return(yylval.ival=f, REPORT("ftst",f) PL_expect = XTERM,PL_bufptr = s,(int)UNIOP)
#define FUN0(f) return(yylval.ival = f, REPORT("fun0",f) PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC0)
#define FUN1(f) return(yylval.ival = f, REPORT("fun1",f) PL_expect = XOPERATOR,PL_bufptr = s,(int)FUNC1)
#define BOop(f) return ao((yylval.ival=f, REPORT("bitorop",f) PL_expect = XTERM,PL_bufptr = s,(int)BITOROP))
#define BAop(f) return ao((yylval.ival=f, REPORT("bitandop",f) PL_expect = XTERM,PL_bufptr = s,(int)BITANDOP))
#define SHop(f) return ao((yylval.ival=f, REPORT("shiftop",f) PL_expect = XTERM,PL_bufptr = s,(int)SHIFTOP))
#define PWop(f) return ao((yylval.ival=f, REPORT("powop",f) PL_expect = XTERM,PL_bufptr = s,(int)POWOP))
#define PMop(f) return(yylval.ival=f, REPORT("matchop",f) PL_expect = XTERM,PL_bufptr = s,(int)MATCHOP)
#define Aop(f) return ao((yylval.ival=f, REPORT("add",f) PL_expect = XTERM,PL_bufptr = s,(int)ADDOP))
#define Mop(f) return ao((yylval.ival=f, REPORT("mul",f) PL_expect = XTERM,PL_bufptr = s,(int)MULOP))
#define Eop(f) return(yylval.ival=f, REPORT("eq",f) PL_expect = XTERM,PL_bufptr = s,(int)EQOP)
#define Rop(f) return(yylval.ival=f, REPORT("rel",f) PL_expect = XTERM,PL_bufptr = s,(int)RELOP)
a153 1
	REPORT("uni",f) \
a160 1
        REPORT("uni",f) \
a167 22
#ifdef DEBUGGING

STATIC void
S_tokereport(pTHX_ char *thing, char* s, I32 rv)
{
    DEBUG_T({
        SV* report = newSVpv(thing, 0);
        Perl_sv_catpvf(aTHX_ report, ":line %d:%"IVdf":", CopLINE(PL_curcop),
		(IV)rv);

        if (s - PL_bufptr > 0)
            sv_catpvn(report, PL_bufptr, s - PL_bufptr);
        else {
            if (PL_oldbufptr && *PL_oldbufptr)
                sv_catpv(report, PL_tokenbuf);
        }
        PerlIO_printf(Perl_debug_log, "### %s\n", SvPV_nolen(report));
    });
}

#endif

d262 1
a262 1
	*tmpbuf = (char)PL_multi_close;
d278 1
a278 17
	Perl_warner(aTHX_ packWARN(WARN_DEPRECATED), "Use of %s is deprecated", s);
}

void
Perl_deprecate_old(pTHX_ char *s)
{
    /* This function should NOT be called for any new deprecated warnings */
    /* Use Perl_deprecate instead                                         */
    /*                                                                    */
    /* It is here to maintain backward compatibility with the pre-5.8     */
    /* warnings category hierarchy. The "deprecated" category used to     */
    /* live under the "syntax" category. It is now a top-level category   */
    /* in its own right.                                                  */

    if (ckWARN2(WARN_DEPRECATED, WARN_SYNTAX))
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX), 
			"Use of %s is deprecated", s);
d289 1
a289 1
    deprecate_old("comma-less variable list");
d398 1
a398 1
    if (!len || s[len-1] != ';') {
d407 2
d478 5
a482 1
	CopFILE_free(PL_curcop);
d506 1
a506 1
	SSize_t oldloplen = 0, oldunilen = 0;
a597 2
            (void)SvIOK_on(sv);
            SvIVX(sv) = 0;
d628 1
a628 1
        Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
d635 29
a683 1
    REPORT("lop", f)
d687 1
a687 1
    PL_last_lop_op = (OPCODE)f;
d810 1
a810 1
	    n = utf8n_to_uvchr((U8*)start, len, &skip, 0);
a824 3
 * If the next token appears to be an invalid version number, (e.g. "v2b"),
 * and if "guessing" is TRUE, then no new token is created (and the caller
 * must use an alternative parsing method).
d828 1
a828 1
S_force_version(pTHX_ char *s, int guessing)
d839 1
a839 2
	while (isDIGIT(*d) || *d == '_' || *d == '.')
	    d++;
a850 2
	else if (guessing)
	    return s;
d857 1
a857 1
    return s;
d889 1
a889 1
    if ( PL_hints & HINT_NEW_STRING ) {
a890 3
	if (SvUTF8(sv))
	    SvUTF8_on(pv);
    }
a1006 1
    SAVEPPTR(PL_bufend);
d1035 1
a1035 1
    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
d1147 1
a1147 1
  @@ in pattern could be: @@foo, @@{foo}, @@$foo, @@'foo, @@::foo.
d1186 1
a1186 3
    bool didrange = FALSE;		        /* did we just finish a range? */
    I32  has_utf8 = FALSE;			/* Output constant is UTF8 */
    I32  this_utf8 = UTF;			/* The source string is assumed to be UTF8 */
d1189 7
a1200 7
    if (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op) {
	/* If we are doing a trans and we know we want UTF8 set expectation */
	has_utf8   = PL_sublex_info.sub_op->op_private & (OPpTRANS_FROM_UTF|OPpTRANS_TO_UTF);
	this_utf8  = PL_sublex_info.sub_op->op_private & (PL_lex_repl ? OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF);
    }


a1209 12
		if (has_utf8) {
		    char *c = (char*)utf8_hop((U8*)d, -1);
		    char *e = d++;
		    while (e-- > c)
			*(e + 1) = *e;
		    *c = (char)UTF_TO_NATIVE(0xff);
		    /* mark the range as done, and continue */
		    dorange = FALSE;
		    didrange = TRUE;
		    continue;
		}

d1218 1
a1218 7
                if (min > max) {
		    Perl_croak(aTHX_
			       "Invalid [] range \"%c-%c\" in transliteration operator",
			       (char)min, (char)max);
                }

#ifdef EBCDIC
d1224 1
a1224 1
				*d++ = NATIVE_TO_NEED(has_utf8,i);
d1228 1
a1228 1
				*d++ = NATIVE_TO_NEED(has_utf8,i);
d1234 1
a1234 1
			*d++ = (char)i;
a1237 1
		didrange = TRUE;
d1243 2
a1244 5
		if (didrange) {
		    Perl_croak(aTHX_ "Ambiguous range in transliteration operator");
		}
		if (has_utf8) {
		    *d++ = (char)UTF_TO_NATIVE(0xff);	/* use illegal utf8 byte--see pmtrans */
a1250 3
	    else {
		didrange = FALSE;
	    }
d1260 1
a1260 1
		    *d++ = NATIVE_TO_NEED(has_utf8,*s++);
d1283 1
a1283 1
		    *d++ = NATIVE_TO_NEED(has_utf8,*s++);
d1291 1
a1291 1
		*d++ = NATIVE_TO_NEED(has_utf8,*s++);
d1294 1
a1294 3
	/* check for embedded arrays
	   (@@foo, @@::foo, @@'foo, @@{foo}, @@$foo, @@+, @@-)
	   */
d1296 1
a1296 1
		 && (isALNUM_lazy_if(s+1,UTF) || strchr(":'{$+-", s[1])))
d1305 1
a1305 1
	    if (s + 1 < send && !strchr("()| \r\n\t", s[1]))
a1308 2
	/* End of else if chain - OP_TRANS rejoin rest */

d1311 2
d1317 2
a1318 2
		*d++ = NATIVE_TO_NEED(has_utf8,'\\');
		*d++ = NATIVE_TO_NEED(has_utf8,*s++);
d1327 1
a1327 1
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "\\%c better written as $%c", *s, *s);
d1350 2
a1351 4
		    if (ckWARN(WARN_MISC) &&
			isALNUM(*s) && 
			*s != '_')
			Perl_warner(aTHX_ packWARN(WARN_MISC),
d1362 2
a1363 3
                    I32 flags = 0;
                    STRLEN len = 3;
		    uv = grok_oct(s, &len, &flags, NULL);
a1372 5
                    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES |
                      PERL_SCAN_DISALLOW_PREFIX;
		    STRLEN len;

                    ++s;
d1375 6
a1380 1
			continue;
a1381 2
                    len = e - s;
		    uv = grok_hex(s, &len, &flags, NULL);
d1386 2
a1387 3
			STRLEN len = 2;
                        I32 flags = PERL_SCAN_DISALLOW_PREFIX;
			uv = grok_hex(s, &len, &flags, NULL);
d1395 1
a1395 1
		 * escapes will be longer than any UTF-8 sequence
d1397 5
d1403 2
a1404 5
		/* We need to map to chars to ASCII before doing the tests
		   to cover EBCDIC
		*/
		if (!UNI_IS_INVARIANT(NATIVE_TO_UNI(uv))) {
		    if (!has_utf8 && uv > 255) {
d1412 5
a1416 4
			int hicount = 0;
			U8 *c;
			for (c = (U8 *) SvPVX(sv); c < (U8 *)d; c++) {
			    if (!NATIVE_IS_INVARIANT(*c)) {
a1417 1
			    }
d1420 15
a1434 11
			    STRLEN offset = d - SvPVX(sv);
			    U8 *src, *dst;
			    d = SvGROW(sv, SvLEN(sv) + hicount + 1) + offset;
			    src = (U8 *)d - 1;
			    dst = src+hicount;
			    d  += hicount;
			    while (src >= (U8 *)SvPVX(sv)) {
			        if (!NATIVE_IS_INVARIANT(*src)) {
				    U8 ch = NATIVE_TO_ASCII(*src);
				    *dst-- = (U8)UTF8_EIGHT_BIT_LO(ch);
				    *dst-- = (U8)UTF8_EIGHT_BIT_HI(ch);
d1437 1
a1437 1
				    *dst-- = *src;
a1438 1
				src--;
d1443 2
a1444 2
                    if (has_utf8 || uv > 255) {
		        d = (char*)uvchr_to_utf8((U8*)d, uv);
d1451 1
d1459 1
a1459 1
		    *d++ = (char) uv;
d1463 1
a1463 1
 	    /* \N{LATIN SMALL LETTER A} is a named character */
a1476 10
		    if (e > s + 2 && s[1] == 'U' && s[2] == '+') {
		        /* \N{U+...} */
		        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES |
			  PERL_SCAN_DISALLOW_PREFIX;
		        s += 3;
			len = e - s;
			uv = grok_hex(s, &len, &flags, NULL);
			s = e + 1;
			goto NUM_ESCAPE_INSERT;
		    }
a1482 20
#ifdef EBCDIC_NEVER_MIND
		    /* charnames uses pack U and that has been
		     * recently changed to do the below uni->native
		     * mapping, so this would be redundant (and wrong,
		     * the code point would be doubly converted).
		     * But leave this in just in case the pack U change
		     * gets revoked, but the semantics is still
		     * desireable for charnames. --jhi */
		    {
			 UV uv = utf8_to_uvchr((U8*)str, 0);

			 if (uv < 0x100) {
			      U8 tmpbuf[UTF8_MAXLEN+1], *d;

			      d = uvchr_to_utf8(tmpbuf, UNI_TO_NATIVE(uv));
			      sv_setpvn(res, (char *)tmpbuf, d - tmpbuf);
			      str = SvPV(res, len);
			 }
		    }
#endif
d1490 1
a1490 1
			SvGROW(sv, (STRLEN)(send - start));
d1494 1
a1494 1
		    if (len > (STRLEN)(e - s + 4)) { /* I _guess_ 4 is \N{} --jhi */
d1497 1
a1497 1
			SvGROW(sv, (SvLEN(sv) + len - (e - s + 4)));
d1513 7
d1522 2
a1523 3
#ifdef EBCDIC
		    if (isLOWER(c))
			c = toUPPER(c);
a1524 2
		    *d++ = NATIVE_TO_NEED(has_utf8,toCTRL(c));
		}
d1529 1
a1529 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\b');
d1532 1
a1532 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\n');
d1535 1
a1535 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\r');
d1538 1
a1538 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\f');
d1541 1
a1541 1
		*d++ = NATIVE_TO_NEED(has_utf8,'\t');
d1543 1
d1545 1
a1545 1
		*d++ = ASCII_TO_NEED(has_utf8,'\033');
d1548 1
a1548 1
		*d++ = ASCII_TO_NEED(has_utf8,'\007');
d1550 8
d1565 27
a1591 18
	/* If we started with encoded form, or already know we want it
	   and then encode the next character */
	if ((has_utf8 || this_utf8) && !NATIVE_IS_INVARIANT((U8)(*s))) {
	    STRLEN len  = 1;
	    UV uv       = (this_utf8) ? utf8n_to_uvchr((U8*)s, send - s, &len, 0) : (UV) ((U8) *s);
	    STRLEN need = UNISKIP(NATIVE_TO_UNI(uv));
	    s += len;
	    if (need > len) {
		/* encoded value larger than old, need extra space (NOTE: SvCUR() not set here) */
		STRLEN off = d - SvPVX(sv);
		d = SvGROW(sv, SvLEN(sv) + (need-len)) + off;
	    }
	    d = (char*)uvchr_to_utf8((U8*)d, uv);
	    has_utf8 = TRUE;
	}
	else {
	    *d++ = NATIVE_TO_NEED(has_utf8,*s++);
	}
a1596 3
    if (SvCUR(sv) >= SvLEN(sv))
      Perl_croak(aTHX_ "panic: constant overflowed allocated space");

d1598 1
a1598 5
    if (PL_encoding && !has_utf8) {
        sv_recode_to_utf8(sv, PL_encoding);
        has_utf8 = TRUE;
    }
    if (has_utf8) {
a1599 5
	if (PL_lex_inwhat == OP_TRANS && PL_sublex_info.sub_op) {
		PL_sublex_info.sub_op->op_private |=
		    (PL_lex_repl ? OPpTRANS_FROM_UTF : OPpTRANS_TO_UTF);
	}
    }
d1791 1
a1791 1
 * Not a method if bar is known to be a subroutine ("sub bar; foo bar")
d1914 1
a1914 1
			  (void*)funcp, SvPV_nolen(datasv)));
d1926 1
a1926 1
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p", (void*)funcp));
d1966 1
a1966 1
	    SvGROW(buf_sv, (STRLEN)(old_len + maxlen)) ;
d1996 1
a1996 1
			  idx, (void*)funcp, SvPV_nolen(datasv)));
d2000 1
a2000 1
    return (*funcp)(aTHX_ idx, buf_sv, maxlen);
d2096 1
a2096 2
    if (yyactlevel > 0)
       yyactlevel--;
d2117 126
a2242 2
    if (PL_pending_ident)
        return S_pending_ident(aTHX);
d2264 1
a2264 1
              (IV)PL_nexttype[PL_nexttoke]); });
d2298 1
a2298 1
              "### Saw case modifier at '%s'\n", PL_bufptr); });
d2301 1
a2301 1
		tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
d2350 1
a2350 1
              "### Interpolated variable at '%s'\n", PL_bufptr); });
d2357 1
a2357 1
#ifdef USE_5005THREADS
d2363 1
a2363 1
#endif /* USE_5005THREADS */
d2450 1
a2450 1
    } );
d2469 1
a2469 1
            } );
d2496 3
d2502 1
a2502 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "our @@F=split(%s);", PL_splitstr);
d2508 1
a2508 1
			    Perl_sv_catpvf(aTHX_ PL_linestr, "our @@F=split(%s%c",
d2519 1
a2519 1
		        sv_catpv(PL_linestr,"our @@F=split(' ');");
a2530 2
                (void)SvIOK_on(sv);
                SvIVX(sv) = 0;
d2586 1
a2586 1
		bof = PerlIO_tell(PL_rsfp) == (Off_t)SvCUR(PL_linestr);
d2594 3
a2613 2
            (void)SvIOK_on(sv);
            SvIVX(sv) = 0;
d2654 1
a2654 1
		    SV *x = GvSV(gv_fetchpv("\030", TRUE, SVt_PV)); /* $^X */
a2659 13
		    else {
			STRLEN blen;
			STRLEN llen;
			char *bstart = SvPV(CopFILESV(PL_curcop),blen);
			char *lstart = SvPV(x,llen);
			if (llen < blen) {
			    bstart += blen - llen;
			    if (strnEQ(bstart, lstart, llen) &&	bstart[-1] == '/') {
				sv_setpvn(x, ipath, ipathend - ipath);
				SvSETMAGIC(x);
			    }
			}
		    }
a2743 1
			bool switches_done = PL_doswitches;
a2766 8
			if (PL_doswitches && !switches_done) {
			    int argc = PL_origargc;
			    char **argv = PL_origargv;
			    do {
				argc--,argv++;
			    } while (argc && argv[0][0] == '-' && argv[0][1]);
			    init_argv_symbols(argc,argv);
			}
a2801 2
	    else if (s > d) /* Found by Ilya: feed random input to Perl. */
	      Perl_croak(aTHX_ "panic: input overflow");
d2829 1
a2829 1
                } );
d2868 1
d2871 5
a2875 16
	    if (ftst) {
		PL_last_lop_op = (OPCODE)ftst;
		DEBUG_T( { PerlIO_printf(Perl_debug_log,
                        "### Saw file test %c\n", (int)ftst);
		} );
		FTST(ftst);
	    }
	    else {
		/* Assume it was a minus followed by a one-letter named
		 * subroutine call (or a -bareword), then. */
		DEBUG_T( { PerlIO_printf(Perl_debug_log,
			"### %c looked like a file test but was not\n",
			(int)ftst);
		} );
		s -= 2;
	    }
a3022 2
		    /* NOTE: any CV attrs applied here need to be part of
		       the CVf_BUILTIN_ATTRS define in cv.h! */
a3028 5
#ifdef USE_ITHREADS
		    else if (PL_in_my == KEY_our && len == 6 &&
			     strnEQ(s, "unique", len))
			GvUNIQUE_on(cGVOPx_gv(yylval.opval));
#endif
d3032 3
a3034 8
		       flags.  To experiment with that, uncomment the
		       following "else".  (Note that's already been
		       uncommented.  That keeps the above-applied built-in
		       attributes from being intercepted (and possibly
		       rejected) by a package's attribute routines, but is
		       justified by the performance win for the common case
		       of applying only built-in attributes.) */
		    else
d3144 3
d3169 1
a3169 8
		if (*s == '}') {
		    if (PL_expect == XREF && PL_lex_state == LEX_INTERPNORMAL) {
			PL_expect = XTERM;
			/* This hack is to get the ${} in the message. */
			PL_bufptr = s+1;
			yyerror("syntax error");
			break;
		    }
a3170 1
		}
d3296 1
a3296 1
		Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), PL_warn_nosemi);
d3329 1
a3329 1
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Reversed %c= operator",(int)tmp);
d3473 1
a3473 1
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
d3491 1
a3491 1
			    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
d3570 1
a3570 1
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
d3632 1
a3632 1
        } );
d3641 1
a3641 1
        } );
d3660 1
a3660 1
        } );
d3674 1
a3674 1
	    if (*d == '$' || *d == '@@' || *d == '\\' || !UTF8_IS_INVARIANT((U8)*d)) {
d3685 1
a3685 1
        } );
d3697 1
a3697 1
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),"Can't use \\%c to mean $%c in expression",
d3715 1
a3715 1
	    else if (!isALPHA(*start) && (PL_expect == XTERM || PL_expect == XREF || PL_expect == XSTATE)) {
d3801 1
a3801 1
	    if (UTF && !IN_BYTES && is_utf8_string((U8*)PL_tokenbuf, len))
a3838 4
		if (tmp == KEY_dump && ckWARN(WARN_MISC)) {
		    Perl_warner(aTHX_ packWARN(WARN_MISC),
			    "dump() better written as CORE::dump()");
		}
d3843 1
a3843 1
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
a3854 1
		int pkgname = 0;
a3866 1
		    pkgname = 1;
d3872 1
a3872 1
			Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), PL_warn_nosemi);
d3887 1
a3887 1
			Perl_warner(aTHX_ packWARN(WARN_BAREWORD),
a3914 4
		/* UTF-8 package name? */
		if (UTF && !IN_BYTES &&
		    is_utf8_string((U8*)SvPVX(sv), SvCUR(sv)))
		    SvUTF8_on(sv);
d3944 2
a3945 2
		    if ( !immediate_paren && (PL_last_lop_op == OP_SORT ||
                         ((!gv || !GvCVu(gv)) &&
d3947 1
a3947 1
			 PL_last_lop_op != OP_GREPSTART))))
d3954 1
d3959 1
a3959 1
		if (*s == '=' && s[1] == '>' && !pkgname) {
d3962 1
a3962 1
		    if (UTF && !IN_BYTES && is_utf8_string((U8*)PL_tokenbuf, len))
d4002 1
a4002 1
			Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
d4030 1
a4030 2
			    sv_setpv(PL_subname, PL_curstash ? 
					"__ANON__" : "__ANON__::__ANON__");
d4049 2
a4050 2
			    if (!*d && !gv_stashpv(PL_tokenbuf,FALSE))
				Perl_warner(aTHX_ packWARN(WARN_RESERVED), PL_warn_reserved,
d4058 1
a4058 1
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
d4061 1
a4061 1
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
a4124 3
#ifdef NETWARE
			if (PerlLIO_setmode(PL_rsfp, O_TEXT) != -1) {
#else
d4126 1
a4126 3
#endif	/* NETWARE */
#ifdef PERLIO_IS_STDIO /* really? */
#  if defined(__BORLANDC__)
a4128 1
#  endif
a4134 4
#ifdef PERLIO_LAYERS
		if (UTF && !IN_BYTES)
		    PerlIO_apply_layers(aTHX_ PL_rsfp, NULL, ":utf8");
#endif
d4221 6
d4249 1
a4249 1
		s = force_word(s,WORD,TRUE,TRUE,FALSE);
d4579 1
a4579 1
	    s = force_version(s, FALSE);
d4596 1
a4596 1
		    Perl_warner(aTHX_ packWARN(WARN_PRECEDENCE),
d4672 1
a4672 1
				    Perl_warner(aTHX_ packWARN(WARN_QW),
d4677 1
a4677 1
				    Perl_warner(aTHX_ packWARN(WARN_QW),
d4731 2
a4732 2
	    if (isDIGIT(*s)) {
		s = force_version(s, FALSE);
d4734 1
a4734 3
	    else if (*s != 'v' || !isDIGIT(s[1])
		    || (s = force_version(s, TRUE), *s == 'v'))
	    {
d4921 1
a4921 1
		SSize_t tboffset = 0;
d4923 1
a4923 1
		bool have_name, have_proto, bad_proto;
d4971 1
a4971 1
		    /* strip spaces and check for bad characters */
a4973 1
		    bad_proto = FALSE;
d4975 1
a4975 1
			if (!isSPACE(*p)) {
a4976 3
			    if (!strchr("$@@%*;[]&\\", *p))
				bad_proto = TRUE;
			}
a4978 4
		    if (bad_proto && ckWARN(WARN_SYNTAX))
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "Illegal character in prototype for %s : %s",
				    SvPVX(PL_subname), d);
d4997 1
a4997 2
		    sv_setpv(PL_subname,
			PL_curstash ? "__ANON__" : "__ANON__::__ANON__");
d5084 6
d5100 1
a5100 1
		s = force_version(s, TRUE);
a5104 4
		else if (*s == 'v') {
		    s = force_word(s,WORD,FALSE,TRUE,FALSE);
		    s = force_version(s, FALSE);
		}
d5108 1
a5108 1
		s = force_version(s, FALSE);
d5139 4
a5142 3
	    char ctl_l[2];
	    ctl_l[0] = toCTRL('L');
	    ctl_l[1] = '\0';
a5169 131
static int
S_pending_ident(pTHX)
{
    register char *d;
    register I32 tmp;
    /* pit holds the identifier we read and pending_ident is reset */
    char pit = PL_pending_ident;
    PL_pending_ident = 0;

    DEBUG_T({ PerlIO_printf(Perl_debug_log,
          "### Tokener saw identifier '%s'\n", PL_tokenbuf); });

    /* if we're in a my(), we can't allow dynamics here.
       $foo'bar has already been turned into $foo::bar, so
       just check for colons.

       if it's a legal name, the OP is a PADANY.
    */
    if (PL_in_my) {
        if (PL_in_my == KEY_our) {	/* "our" is merely analogous to "my" */
            if (strchr(PL_tokenbuf,':'))
                yyerror(Perl_form(aTHX_ "No package name allowed for "
                                  "variable %s in \"our\"",
                                  PL_tokenbuf));
            tmp = pad_allocmy(PL_tokenbuf);
        }
        else {
            if (strchr(PL_tokenbuf,':'))
                yyerror(Perl_form(aTHX_ PL_no_myglob,PL_tokenbuf));

            yylval.opval = newOP(OP_PADANY, 0);
            yylval.opval->op_targ = pad_allocmy(PL_tokenbuf);
            return PRIVATEREF;
        }
    }

    /*
       build the ops for accesses to a my() variable.

       Deny my($a) or my($b) in a sort block, *if* $a or $b is
       then used in a comparison.  This catches most, but not
       all cases.  For instance, it catches
           sort { my($a); $a <=> $b }
       but not
           sort { my($a); $a < $b ? -1 : $a == $b ? 0 : 1; }
       (although why you'd do that is anyone's guess).
    */

    if (!strchr(PL_tokenbuf,':')) {
#ifdef USE_5005THREADS
        /* Check for single character per-thread SVs */
        if (PL_tokenbuf[0] == '$' && PL_tokenbuf[2] == '\0'
            && !isALPHA(PL_tokenbuf[1]) /* Rule out obvious non-threadsvs */
            && (tmp = find_threadsv(&PL_tokenbuf[1])) != NOT_IN_PAD)
        {
            yylval.opval = newOP(OP_THREADSV, 0);
            yylval.opval->op_targ = tmp;
            return PRIVATEREF;
        }
#endif /* USE_5005THREADS */
        if ((tmp = pad_findmy(PL_tokenbuf)) != NOT_IN_PAD) {
            SV *namesv = AvARRAY(PL_comppad_name)[tmp];
            /* might be an "our" variable" */
            if (SvFLAGS(namesv) & SVpad_OUR) {
                /* build ops for a bareword */
                SV *sym = newSVpv(HvNAME(GvSTASH(namesv)),0);
                sv_catpvn(sym, "::", 2);
                sv_catpv(sym, PL_tokenbuf+1);
                yylval.opval = (OP*)newSVOP(OP_CONST, 0, sym);
                yylval.opval->op_private = OPpCONST_ENTERED;
                gv_fetchpv(SvPVX(sym),
                    (PL_in_eval
                        ? (GV_ADDMULTI | GV_ADDINEVAL)
                        : GV_ADDMULTI
                    ),
                    ((PL_tokenbuf[0] == '$') ? SVt_PV
                     : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
                     : SVt_PVHV));
                return WORD;
            }

            /* if it's a sort block and they're naming $a or $b */
            if (PL_last_lop_op == OP_SORT &&
                PL_tokenbuf[0] == '$' &&
                (PL_tokenbuf[1] == 'a' || PL_tokenbuf[1] == 'b')
                && !PL_tokenbuf[2])
            {
                for (d = PL_in_eval ? PL_oldoldbufptr : PL_linestart;
                     d < PL_bufend && *d != '\n';
                     d++)
                {
                    if (strnEQ(d,"<=>",3) || strnEQ(d,"cmp",3)) {
                        Perl_croak(aTHX_ "Can't use \"my %s\" in sort comparison",
                              PL_tokenbuf);
                    }
                }
            }

            yylval.opval = newOP(OP_PADANY, 0);
            yylval.opval->op_targ = tmp;
            return PRIVATEREF;
        }
    }

    /*
       Whine if they've said @@foo in a doublequoted string,
       and @@foo isn't a variable we can find in the symbol
       table.
    */
    if (pit == '@@' && PL_lex_state != LEX_NORMAL && !PL_lex_brackets) {
        GV *gv = gv_fetchpv(PL_tokenbuf+1, FALSE, SVt_PVAV);
        if ((!gv || ((PL_tokenbuf[0] == '@@') ? !GvAV(gv) : !GvHV(gv)))
             && ckWARN(WARN_AMBIGUOUS))
        {
            /* Downgraded from fatal to warning 20000522 mjd */
            Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
                        "Possible unintended interpolation of %s in string",
                         PL_tokenbuf);
        }
    }

    /* build ops for a bareword */
    yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpv(PL_tokenbuf+1, 0));
    yylval.opval->op_private = OPpCONST_ENTERED;
    gv_fetchpv(PL_tokenbuf+1, PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : TRUE,
               ((PL_tokenbuf[0] == '$') ? SVt_PV
                : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
                : SVt_PVHV));
    return WORD;
}

d5271 1
d5337 6
d5442 6
d5499 3
d5581 1
a5581 1
	    if (strEQ(d,"require"))		return KEY_require;
d5806 1
a5806 1
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
d6079 1
a6079 1
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
d6111 1
a6111 1
		    Perl_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
d6128 1
a6128 1
Perl_pmflag(pTHX_ U32* pmfl, int ch)
a6166 7
    /* issue a warning if /c is specified,but /g is not */
    if (ckWARN(WARN_REGEXP) && 
        (pm->op_pmflags & PMf_CONTINUE) && !(pm->op_pmflags & PMf_GLOBAL))
    {
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), c_without_g);
    }

a6214 6
    /* /c is not meaningful with s/// */
    if (ckWARN(WARN_REGEXP) && (pm->op_pmflags & PMf_CONTINUE))
    {
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), c_in_subst);
    }

d6247 2
d6267 3
a6279 3

    New(803, tbl, complement&&!del?258:256, short);
    o = newPVOP(OP_TRANS, 0, (char*)tbl);
d6322 1
a6322 1
	    deprecate_old("bare << to mean <<\"\"");
d6393 1
a6393 1
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
d6413 1
a6413 1
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
d6431 1
a6431 1
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
a6456 2
            (void)SvIOK_on(sv);
            SvIVX(sv) = 0;
d6478 1
a6478 1
    if (UTF && !IN_BYTES && is_utf8_string((U8*)SvPVX(tmpstr), SvCUR(tmpstr)))
a6555 3
	bool readline_overriden = FALSE;
	GV *gv_readline = Nullgv;
	GV **gvp;
a6562 9
	/* Check whether readline() is overriden */
	if (((gv_readline = gv_fetchpv("readline", FALSE, SVt_PVCV))
		&& GvCVu(gv_readline) && GvIMPORTED_CV(gv_readline))
		||
		((gvp = (GV**)hv_fetch(PL_globalstash, "readline", 8, FALSE))
		&& (gv_readline = *gvp) != (GV*)&PL_sv_undef
		&& GvCVu(gv_readline) && GvIMPORTED_CV(gv_readline)))
	    readline_overriden = TRUE;

d6573 3
a6575 17
		SV *namesv = AvARRAY(PL_comppad_name)[tmp];
		if (SvFLAGS(namesv) & SVpad_OUR) {
		    SV *sym = sv_2mortal(newSVpv(HvNAME(GvSTASH(namesv)),0));
		    sv_catpvn(sym, "::", 2);
		    sv_catpv(sym, d+1);
		    d = SvPVX(sym);
		    goto intro_sym;
		}
		else {
		    OP *o = newOP(OP_PADSV, 0);
		    o->op_targ = tmp;
		    PL_lex_op = readline_overriden
			? (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
				append_elem(OP_LIST, o,
				    newCVREF(0, newGVOP(OP_GV,0,gv_readline))))
			: (OP*)newUNOP(OP_READLINE, 0, o);
		}
d6578 4
a6581 16
		GV *gv;
		++d;
intro_sym:
		gv = gv_fetchpv(d,
				(PL_in_eval
				 ? (GV_ADDMULTI | GV_ADDINEVAL)
				 : GV_ADDMULTI),
				SVt_PV);
		PL_lex_op = readline_overriden
		    ? (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
			    append_elem(OP_LIST,
				newUNOP(OP_RV2SV, 0, newGVOP(OP_GV, 0, gv)),
				newCVREF(0, newGVOP(OP_GV, 0, gv_readline))))
		    : (OP*)newUNOP(OP_READLINE, 0,
			    newUNOP(OP_RV2SV, 0,
				newGVOP(OP_GV, 0, gv)));
d6583 1
a6583 2
	    if (!readline_overriden)
		PL_lex_op->op_flags |= OPf_SPECIAL;
d6592 1
a6592 6
	    PL_lex_op = readline_overriden
		? (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
			append_elem(OP_LIST,
			    newGVOP(OP_GV, 0, gv),
			    newCVREF(0, newGVOP(OP_GV, 0, gv_readline))))
		: (OP*)newUNOP(OP_READLINE, 0, newGVOP(OP_GV, 0, gv));
d6664 1
a6664 1
    if (!UTF8_IS_INVARIANT((U8)term) && UTF)
d6711 1
a6711 1
		else if (!has_utf8 && !UTF8_IS_INVARIANT((U8)*s) && UTF)
d6740 1
a6740 1
		else if (!has_utf8 && !UTF8_IS_INVARIANT((U8)*s) && UTF)
d6778 1
a6778 1
	    CopLINE_set(PL_curcop, (line_t)PL_multi_start);
a6789 2
            (void)SvIOK_on(sv);
            SvIVX(sv) = 0;
d6832 5
a6836 5
  \d(_?\d)*(\.(\d(_?\d)*)?)?[Ee][\+\-]?(\d(_?\d)*)	12 12.34 12.
  \.\d(_?\d)*[Ee][\+\-]?(\d(_?\d)*)			.34
  0b[01](_?[01])*
  0[0-7](_?[0-7])*
  0x[0-9A-Fa-f](_?[0-9A-Fa-f])*
d6906 1
a6906 1
	    else {
a6907 9
		s++;
	    }

	    if (*s == '_') {
	       if (ckWARN(WARN_SYNTAX))
		   Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
	       lastub = s++;
	    }
d6925 1
a6925 1
		/* _ are ignored -- but warned about if consecutive */
d6927 1
a6927 4
		    if (ckWARN(WARN_SYNTAX) && lastub && s == lastub + 1)
		        Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "Misplaced _ in number");
		    lastub = s++;
d6968 1
a6968 1
				Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
a6993 7

	    /* final misplaced underbar check */
	    if (s[-1] == '_') {
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
	    }

d6997 1
a6997 1
		    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
d7005 1
a7005 1
		    Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
d7033 3
a7035 4
		if (ckWARN(WARN_SYNTAX) && lastub && s == lastub + 1)
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
		lastub = s++;
d7047 1
a7047 1
	if (lastub && s == lastub + 1) {
d7049 1
a7049 1
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
d7060 2
a7061 8
	    if (*s == '_') {
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
		lastub = s;
	    }

	    /* copy, ignoring underbars, until we run out of digits.
d7067 1
a7067 7
		if (*s == '_') {
		   if (ckWARN(WARN_SYNTAX) && lastub && s == lastub + 1)
		       Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Misplaced _ in number");
		   lastub = s;
		}
		else
a7069 6
	    /* fractional part ending in underbar? */
	    if (s[-1] == '_') {
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
	    }
d7072 1
a7072 1
		s = start;
d7078 1
a7078 1
	if (*s && strchr("eE",*s) && strchr("+-0123456789_", s[1])) {
a7084 8
	    /* stray preinitial _ */
	    if (*s == '_') {
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
	        lastub = s++;
	    }

d7089 5
a7093 23
	    /* stray initial _ */
	    if (*s == '_') {
	        if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				"Misplaced _ in number");
	        lastub = s++;
	    }

	    /* read digits of exponent */
	    while (isDIGIT(*s) || *s == '_') {
	        if (isDIGIT(*s)) {
		    if (d >= e)
		        Perl_croak(aTHX_ number_too_long);
		    *d++ = *s++;
		}
		else {
		   if (ckWARN(WARN_SYNTAX) &&
		       ((lastub && s == lastub + 1) ||
			(!isDIGIT(s[1]) && s[1] != '_')))
		       Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Misplaced _ in number");
		   lastub = s++;
		}
d7097 2
d7103 2
d7106 3
a7108 2
           We try to do an integer conversion first if no characters
           indicating "float" have been found.
d7112 1
d7114 10
a7123 4
            int flags = grok_number (PL_tokenbuf, d - PL_tokenbuf, &uv);

            if (flags == IS_NUMBER_IN_UV) {
              if (uv <= IV_MAX)
d7125 1
a7125 1
              else
d7127 1
a7127 8
            } else if (flags == (IS_NUMBER_IN_UV | IS_NUMBER_NEG)) {
              if (uv <= (UV) IV_MIN)
                sv_setiv(sv, -(IV)uv);
              else
	    	floatit = TRUE;
            } else
              floatit = TRUE;
        }
a7128 2
	    /* terminate the string */
	    *d = '\0';
d7132 3
d7136 46
d7192 57
a7248 2
		sv = NEWSV(92,5); /* preallocate storage space */
		s = new_vstring(s,sv);
d7297 1
a7297 2
	    if (eol > s) {
	        sv_catpvn(stuff, s, eol-s);
d7299 6
a7304 6
		if (eol-s > 1 && eol[-2] == '\r' && eol[-1] == '\n') {
		    char *end = SvPVX(stuff) + SvCUR(stuff);
		    end[-2] = '\n';
		    end[-1] = '\0';
		    SvCUR(stuff)--;
		}
a7305 3
	    }
	    else
	      break;
d7386 1
a7386 1
#ifdef USE_5005THREADS
d7390 1
a7390 1
#endif /* USE_5005THREADS */
d7399 1
a7399 1
#ifdef USE_5005THREADS
d7403 1
a7403 1
#endif /* USE_5005THREADS */
a7431 8
	/*
		Only for NetWare:
		The code below is removed for NetWare because it abends/crashes on NetWare
		when the script has error such as not having the closing quotes like:
		    if ($var eq "value)
		Checking of white spaces is anyway done in NetWare code.
	*/
#ifndef NETWARE
a7433 1
#endif
a7438 8
	/*
		Only for NetWare:
		The code below is removed for NetWare because it abends/crashes on NetWare
		when the script has error such as not having the closing quotes like:
		    if ($var eq "value)
		Checking of white spaces is anyway done in NetWare code.
	*/
#ifndef NETWARE
a7440 1
#endif
d7472 1
a7472 1
        OutCopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
d7490 1
a7490 1
            ERRSV, OutCopFILE(PL_curcop));
d7493 1
a7493 1
            OutCopFILE(PL_curcop));
d7537 1
d7563 1
d7580 4
d7590 1
a7590 1
restore_rsfp(pTHX_ void *f)
d7603 1
a7603 1
utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
d7622 1
a7622 1
utf16rev_textfilter(pTHX_ int idx, SV *sv, int maxlen)
a7639 1

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d421 2
a422 2
    SAVEGENERICPV(PL_lex_brackstack);
    SAVEGENERICPV(PL_lex_casestack);
d437 2
d680 1
a680 1
		   "Warning: Use of \"%s\" without parentheses is ambiguous",
a783 2
	if (UTF && !IN_BYTES && is_utf8_string((U8*)PL_tokenbuf, len))
	    SvUTF8_on(((SVOP*)PL_nextval[PL_nexttoke].opval)->op_sv);
d1046 2
a1047 2
    SAVEGENERICPV(PL_lex_brackstack);
    SAVEGENERICPV(PL_lex_casestack);
d1062 2
d1267 1
a1267 1
			       "Invalid range \"%c-%c\" in transliteration operator",
d1319 1
a1319 1
		while (s+1 < send && *s != ')')
d1338 1
a1338 1
		if (*regparse != ')')
d1340 2
d1605 1
a1605 1
		if (s < send) {
a1612 3
		else {
		    yyerror("Missing control char name in \\c");
		}
d1668 1
a1668 1
	Perl_croak(aTHX_ "panic: constant overflowed allocated space");
d1672 2
a1673 3
	sv_recode_to_utf8(sv, PL_encoding);
	if (SvUTF8(sv))
	    has_utf8 = TRUE;
d1678 1
a1678 1
	    PL_sublex_info.sub_op->op_private |=
d1957 1
a1957 1
	SETERRNO(0,SS_NORMAL);
a2197 1
    I32 orig_keyword = 0;
d2259 7
a2265 4
	    if (s[1] == '\\' && s[2] == 'E') {
	        PL_bufptr = s + 3;
		PL_lex_state = LEX_INTERPCONCAT;
		return yylex();
d2267 6
a2272 28
	    else {
	        if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
		    tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
		if (strchr("LU", *s) &&
		    (strchr(PL_lex_casestack, 'L') || strchr(PL_lex_casestack, 'U'))) {
		    PL_lex_casestack[--PL_lex_casemods] = '\0';
		    return ')';
		}
		if (PL_lex_casemods > 10)
		    Renew(PL_lex_casestack, PL_lex_casemods + 2, char);
		PL_lex_casestack[PL_lex_casemods++] = *s;
		PL_lex_casestack[PL_lex_casemods] = '\0';
		PL_lex_state = LEX_INTERPCONCAT;
		PL_nextval[PL_nexttoke].ival = 0;
		force_next('(');
		if (*s == 'l')
		    PL_nextval[PL_nexttoke].ival = OP_LCFIRST;
		else if (*s == 'u')
		    PL_nextval[PL_nexttoke].ival = OP_UCFIRST;
		else if (*s == 'L')
		    PL_nextval[PL_nexttoke].ival = OP_LC;
		else if (*s == 'U')
		    PL_nextval[PL_nexttoke].ival = OP_UC;
		else if (*s == 'Q')
		    PL_nextval[PL_nexttoke].ival = OP_QUOTEMETA;
		else
		    Perl_croak(aTHX_ "panic: yylex");
		PL_bufptr = s + 1;
d2274 18
a2700 1
		    PERL_FPU_PRE_EXEC
a2701 1
		    PERL_FPU_POST_EXEC
a2723 8
			if (PL_doswitches && !switches_done) {
			    int argc = PL_origargc;
			    char **argv = PL_origargv;
			    do {
				argc--,argv++;
			    } while (argc && argv[0][0] == '-' && argv[0][1]);
			    init_argv_symbols(argc,argv);
			}
d2862 2
a2863 2
			"### '-%c' looked like a file test but was not\n",
			tmp);
d2865 1
a2865 1
		s = --PL_bufptr;
d2937 2
d3022 1
a3024 1
#ifdef USE_ITHREADS
a3025 2
#else
			; /* skip that case to avoid loading attributes.pm */
d3049 1
a3049 1
	    if (*s != ';' && *s != '}' && *s != tmp && (tmp != '=' || *s != ')')) {
a3082 1
	s = skipspace(s);
d3111 5
a3115 1
	    Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
a3207 1
			/* skip q//-like construct */
a3213 4
			/* check for q => */
			if (t+1 < PL_bufend && t[0] == '=' && t[1] == '>') {
			    OPERATOR(HASHBRACK);
			}
d3226 1
a3226 1
			else {
a3234 2
			}
			t++;
d3236 1
a3236 4
		    else
			/* skip plain q word */
			while (t < PL_bufend && isALNUM_lazy_if(t,UTF))
			     t += UTF8SKIP(t);
d3536 3
a3538 1
		    PL_expect = XTERM;		/* e.g. print $fh subr() */
d3559 2
d3639 1
a3639 1
                    "### Saw number before '%s'\n", s);
a3771 1
	orig_keyword = 0;
a3835 1
		orig_keyword = tmp;
d4011 1
a4011 3
		if (!orig_keyword
			&& (isIDFIRST_lazy_if(s,UTF) || *s == '$')
			&& (tmp = intuit_method(s,gv)))
a4045 2
			while (*proto == ';')
			    proto++;
d4160 2
a4161 23
		if (!IN_BYTES) {
		    if (UTF)
			PerlIO_apply_layers(aTHX_ PL_rsfp, NULL, ":utf8");
		    else if (PL_encoding) {
			SV *name;
			dSP;
			ENTER;
			SAVETMPS;
			PUSHMARK(sp);
			EXTEND(SP, 1);
			XPUSHs(PL_encoding);
			PUTBACK;
			call_method("name", G_SCALAR);
			SPAGAIN;
			name = POPs;
			PUTBACK;
			PerlIO_apply_layers(aTHX_ PL_rsfp, NULL, 
					    Perl_form(aTHX_ ":encoding(%"SVf")",
						      name));
			FREETMPS;
			LEAVE;
		    }
		}
d4617 1
a4617 4
		if (strchr("|&*+-=!?:.", *t) && ckWARN_d(WARN_PRECEDENCE)
		    /* [perl #16184] */
		    && !(t[0] == '=' && t[1] == '>')
		) {
d4620 1
a4620 2
			    d - s, s, d - s, s);
		}
d5009 2
a5010 2
				    "Illegal character in prototype for %"SVf" : %s",
				    PL_subname, d);
a5020 2
		else if (!have_name && *s != '{' && key == KEY_sub)
		    Perl_croak(aTHX_ "Illegal declaration of anonymous subroutine");
d5204 1
a5204 1
    register I32 tmp = 0;
d5224 1
a5224 1
            tmp = allocmy(PL_tokenbuf);
d5231 1
a5231 1
            yylval.opval->op_targ = allocmy(PL_tokenbuf);
d5260 2
a5261 3
	if (!PL_in_my)
	    tmp = pad_findmy(PL_tokenbuf);
        if (tmp != NOT_IN_PAD) {
d5263 1
a5263 1
            if (PAD_COMPNAME_FLAGS(tmp) & SVpad_OUR) {
d5265 1
a5265 1
                SV *sym = newSVpv(HvNAME(PAD_COMPNAME_OURSTASH(tmp)), 0);
d6248 1
a6248 1
	    if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets) {
a6249 2
		PL_expect = XREF;
	    }
d6636 2
a6637 6
    if (!IN_BYTES) {
	if (UTF && is_utf8_string((U8*)SvPVX(tmpstr), SvCUR(tmpstr)))
	    SvUTF8_on(tmpstr);
	else if (PL_encoding)
	    sv_recode_to_utf8(tmpstr, PL_encoding);
    }
d6743 3
a6745 3
		if (PAD_COMPNAME_FLAGS(tmp) & SVpad_OUR) {
		    SV *sym = sv_2mortal(
			    newSVpv(HvNAME(PAD_COMPNAME_OURSTASH(tmp)),0));
a6855 4
    I32 termcode;			/* terminating char. code */
    U8 termstr[UTF8_MAXLEN];		/* terminating string */
    STRLEN termlen;			/* length of terminating string */
    char *last = NULL;			/* last position for nesting bracket */
d6866 2
a6867 10
    if (!UTF) {
	termcode = termstr[0] = term;
	termlen = 1;
    }
    else {
	termcode = utf8_to_uvchr((U8*)s, &termlen);
	Copy(s, termstr, termlen, U8);
	if (!UTF8_IS_INVARIANT(term))
	    has_utf8 = TRUE;
    }
d6875 1
a6875 2
	termcode = termstr[0] = term = tmps[5];

d6882 1
a6882 1
    SvIVX(sv) = termcode;
d6887 2
a6888 2
	sv_catpvn(sv, s, termlen);
    s += termlen;
a6889 70
	if (PL_encoding && !UTF) {
	    bool cont = TRUE;

	    while (cont) {
		int offset = s - SvPVX(PL_linestr);
		bool found = sv_cat_decode(sv, PL_encoding, PL_linestr,
					   &offset, (char*)termstr, termlen);
		char *ns = SvPVX(PL_linestr) + offset;
		char *svlast = SvEND(sv) - 1;

		for (; s < ns; s++) {
		    if (*s == '\n' && !PL_rsfp)
			CopLINE_inc(PL_curcop);
		}
		if (!found)
		    goto read_more_line;
		else {
		    /* handle quoted delimiters */
		    if (SvCUR(sv) > 1 && *(svlast-1) == '\\') {
			char *t;
			for (t = svlast-2; t >= SvPVX(sv) && *t == '\\';)
			    t--;
			if ((svlast-1 - t) % 2) {
			    if (!keep_quoted) {
				*(svlast-1) = term;
				*svlast = '\0';
				SvCUR_set(sv, SvCUR(sv) - 1);
			    }
			    continue;
			}
		    }
		    if (PL_multi_open == PL_multi_close) {
			cont = FALSE;
		    }
		    else {
			char *t, *w;
			if (!last)
			    last = SvPVX(sv);
			for (w = t = last; t < svlast; w++, t++) {
			    /* At here, all closes are "was quoted" one,
			       so we don't check PL_multi_close. */
			    if (*t == '\\') {
				if (!keep_quoted && *(t+1) == PL_multi_open)
				    t++;
				else
				    *w++ = *t++;
			    }
			    else if (*t == PL_multi_open)
				brackets++;

			    *w = *t;
			}
			if (w < t) {
			    *w++ = term;
			    *w = '\0';
			    SvCUR_set(sv, w - SvPVX(sv));
			}
			last = w;
			if (--brackets <= 0)
			    cont = FALSE;
		    }
		}
	    }
	    if (!keep_delims) {
		SvCUR_set(sv, SvCUR(sv) - 1);
		*SvEND(sv) = '\0';
	    }
	    break;
	}

d6911 2
a6912 6
		else if (*s == term) {
		    if (termlen == 1)
			break;
		    if (s+termlen <= PL_bufend && memEQ(s, (char*)termstr, termlen))
			break;
		}
a6973 1
     read_more_line:
d7004 3
a7006 6
    if (!PL_encoding || UTF) {
	if (keep_delims)
	    sv_catpvn(sv, s, termlen);
	s += termlen;
    }
    if (has_utf8 || PL_encoding)
a7007 1

d7009 1
d7409 1
a7409 4
		s = scan_vstring(s,sv);
		DEBUG_T( { PerlIO_printf(Perl_debug_log,
		  "### Saw v-string before '%s'\n", s);
		} ); 
a7495 6
	if (!IN_BYTES) {
	    if (UTF && is_utf8_string((U8*)SvPVX(stuff), SvCUR(stuff)))
		SvUTF8_on(stuff);
	    else if (PL_encoding)
		sv_recode_to_utf8(stuff, PL_encoding);
	}
d7523 1
d7530 3
d7534 4
d7543 7
d7551 12
a7562 1
    CvPADLIST(PL_compcv) = pad_new(padnew_SAVE|padnew_SAVESUB);
a7563 1
    CvOUTSIDE_SEQ(PL_compcv) = PL_cop_seqmax;
a7816 86

/*
Returns a pointer to the next character after the parsed
vstring, as well as updating the passed in sv.

Function must be called like

	sv = NEWSV(92,5);
	s = scan_vstring(s,sv);

The sv should already be large enough to store the vstring
passed in, for performance reasons.

*/

char *
Perl_scan_vstring(pTHX_ char *s, SV *sv)
{
    char *pos = s;
    char *start = s;
    if (*pos == 'v') pos++;  /* get past 'v' */
    while (pos < PL_bufend && (isDIGIT(*pos) || *pos == '_'))
	pos++;
    if ( *pos != '.') {
	/* this may not be a v-string if followed by => */
	char *next = pos;
	while (next < PL_bufend && isSPACE(*next))
	    ++next;
	if ((PL_bufend - next) >= 2 && *next == '=' && next[1] == '>' ) {
	    /* return string not v-string */
	    sv_setpvn(sv,(char *)s,pos-s);
	    return pos;
	}
    }

    if (!isALPHA(*pos)) {
	UV rev;
	U8 tmpbuf[UTF8_MAXLEN+1];
	U8 *tmpend;

	if (*s == 'v') s++;  /* get past 'v' */

	sv_setpvn(sv, "", 0);

	for (;;) {
	    rev = 0;
	    {
		/* this is atoi() that tolerates underscores */
		char *end = pos;
		UV mult = 1;
		while (--end >= s) {
		    UV orev;
		    if (*end == '_')
			continue;
		    orev = rev;
		    rev += (*end - '0') * mult;
		    mult *= 10;
		    if (orev > rev && ckWARN_d(WARN_OVERFLOW))
			Perl_warner(aTHX_ packWARN(WARN_OVERFLOW),
				    "Integer overflow in decimal number");
		}
	    }
#ifdef EBCDIC
	    if (rev > 0x7FFFFFFF)
		 Perl_croak(aTHX_ "In EBCDIC the v-string components cannot exceed 2147483647");
#endif
	    /* Append native character for the rev point */
	    tmpend = uvchr_to_utf8(tmpbuf, rev);
	    sv_catpvn(sv, (const char*)tmpbuf, tmpend - tmpbuf);
	    if (!UNI_IS_INVARIANT(NATIVE_TO_UNI(rev)))
		 SvUTF8_on(sv);
	    if (pos + 1 < PL_bufend && *pos == '.' && isDIGIT(pos[1]))
		 s = ++pos;
	    else {
		 s = pos;
		 break;
	    }
	    while (pos < PL_bufend && (isDIGIT(*pos) || *pos == '_'))
		 pos++;
	}
	SvPOK_on(sv);
	sv_magic(sv,NULL,PERL_MAGIC_vstring,(const char*)start, pos-start);
	SvRMAGICAL_on(sv);
    }
    return s;
}
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d253 12
a264 17
    if (ckWARN_d(WARN_SYNTAX)) {
	if (is_first)
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		    "\t(Missing semicolon on previous line?)\n");
	else if (PL_oldoldbufptr && isIDFIRST_lazy_if(PL_oldoldbufptr,UTF)) {
	    char *t;
	    for (t = PL_oldoldbufptr; *t && (isALNUM_lazy_if(t,UTF) || *t == ':'); t++) ;
	    if (t < PL_bufptr && isSPACE(*t))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"\t(Do you need to predeclare %.*s?)\n",
		    t - PL_oldoldbufptr, PL_oldoldbufptr);
	}
	else {
	    assert(s >= oldbp);
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
		    "\t(Missing operator before %.*s?)\n", s - oldbp, oldbp);
	}
d1225 1
a1225 1
	    ? "\\.^$@@AGZdDwWsSbBpPXC+*?|()-nrtfeaxz0123456789[{]} \t\n\r\f\v#"
d2427 2
a2428 6
	    if (PL_lex_brackets) {
 	        if (PL_lex_formbrack)
		    yyerror("Format not terminated");
                else
		    yyerror("Missing right curly or square bracket");
	    }
d2524 2
a2525 7
	    /* If it looks like the start of a BOM or raw UTF-16,
	     * check if it in fact is. */
	    else if (bof &&
		     (*s == 0 ||
		      *(U8*)s == 0xEF ||
		      *(U8*)s >= 0xFE ||
		      s[1] == 0)) {
a3024 11
		    if (len == 6 && strnEQ(s, "unique", len)) {
			if (PL_in_my == KEY_our)
#ifdef USE_ITHREADS
			    GvUNIQUE_on(cGVOPx_gv(yylval.opval));
#else
			    ; /* skip to avoid loading attributes.pm */
#endif
			else 
			    Perl_croak(aTHX_ "The 'unique' attribute may only be applied to 'our' variables");
		    }

d3027 1
a3027 1
		    else if (!PL_in_my && len == 6 && strnEQ(s, "lvalue", len))
d3033 7
d4659 2
a4660 2
		for (t=d; *t && isSPACE(*t); t++) ;
		if ( *t && strchr("|&*+-=!?:.", *t) && ckWARN_d(WARN_PRECEDENCE)
d5068 2
a5069 6
		else if (*s != '{' && key == KEY_sub) {
		    if (!have_name)
			Perl_croak(aTHX_ "Illegal declaration of anonymous subroutine");
		    else if (*s != ';')
			Perl_croak(aTHX_ "Illegal declaration of subroutine %"SVf, PL_subname);
		}
d5505 1
a5505 3
	    if (strEQ(d,"elseif") && ckWARN_d(WARN_SYNTAX))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			"elseif should be elsif");
a7579 1
    bool eofmt = FALSE;
d7582 1
a7582 1
	if (*s == '.') {
d7589 1
a7589 2
	    if (*t == '\n' || t == PL_bufend) {
	        eofmt = TRUE;
a7590 1
            }
d7593 1
a7593 1
	    eol = memchr(s,'\n',PL_bufend-s);
d7630 1
d7659 1
a7659 2
	if (eofmt)
	    PL_lex_formbrack = 0;
d7797 2
a7798 2
    if (PL_in_eval & EVAL_WARNONLY && ckWARN_d(WARN_SYNTAX))
	Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "%"SVf, msg);
d7822 1
a7822 1
    switch (s[0]) {
d7825 1
a7825 1
	    /* UTF-16 little-endian? (or UTF32-LE?) */
d7827 1
a7827 1
		Perl_croak(aTHX_ "Unsupported script encoding UTF32-LE");
d7829 1
a7829 1
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF16-LE script encoding (BOM)\n");
a7830 1
	utf16le:
d7837 7
a7843 5
		PL_bufend =
		     (char*)utf16_to_utf8_reversed(s, news,
						   PL_bufend - (char*)s - 1,
						   &newlen);
		sv_setpvn(PL_linestr, (const char*)news, newlen);
a7844 3
		SvUTF8_on(PL_linestr);
		s = (U8*)SvPVX(PL_linestr);
		PL_bufend = SvPVX(PL_linestr) + newlen;
d7847 1
a7847 1
	    Perl_croak(aTHX_ "Unsupported script encoding UTF16-LE");
d7852 1
a7852 1
	if (s[1] == 0xFF) {   /* UTF-16 big-endian? */
d7854 1
a7854 1
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16BE script encoding (BOM)\n");
a7855 1
	utf16be:
d7862 7
a7868 5
		PL_bufend =
		     (char*)utf16_to_utf8(s, news,
					  PL_bufend - (char*)s,
					  &newlen);
		sv_setpvn(PL_linestr, (const char*)news, newlen);
a7869 3
		SvUTF8_on(PL_linestr);
		s = (U8*)SvPVX(PL_linestr);
		PL_bufend = SvPVX(PL_linestr) + newlen;
d7872 1
a7872 1
	    Perl_croak(aTHX_ "Unsupported script encoding UTF16-BE");
d7878 1
a7878 1
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-8 script encoding (BOM)\n");
d7883 4
a7886 14
	if (slen > 3) {
	     if (s[1] == 0) {
		  if (s[2] == 0xFE && s[3] == 0xFF) {
		       /* UTF-32 big-endian */
		       Perl_croak(aTHX_ "Unsupported script encoding UTF32-BE");
		  }
	     }
	     else if (s[2] == 0 && s[3] != 0) {
		  /* Leading bytes
		   * 00 xx 00 xx
		   * are a good indicator of UTF-16BE. */
		  if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16BE script encoding (no BOM)\n");
		  goto utf16be;
	     }
a7887 8
    default:
	 if (slen > 3 && s[1] == 0 && s[2] != 0 && s[3] == 0) {
		  /* Leading bytes
		   * xx 00 xx 00
		   * are a good indicator of UTF-16LE. */
	      if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16LE script encoding (no BOM)\n");
	      goto utf16le;
	 }
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d2031 1
a2031 2
/* Invoke the idxth filter function for the current rsfp.	 */
/* maxlen 0 = read one text line */
d2034 3
d2043 1
a2043 1
    if (idx > AvFILLp(PL_rsfp_filters)) {       /* Any more filters?	*/
d2074 1
a2074 1
    if ( (datasv = FILTER_DATA(idx)) == &PL_sv_undef) {
d2100 1
d6632 1
a6632 1
	Copy(SvPVX(herewas),bufptr,SvCUR(herewas) + 1,char);
d6694 2
a6695 2
	    STRLEN off = PL_bufend - 1 - SvPVX(PL_linestr);
	    *(SvPVX(PL_linestr) + off ) = ' ';
a6697 1
	    s = SvPVX(PL_linestr) + off; /* In case PV of PL_linestr moved. */
d6802 1
a6802 1
	    Copy("ARGV",d,5,char);
a7256 1
	    bool just_zero  = TRUE;	/* just plain 0 or binary number? */
a7272 1
		just_zero = FALSE;
a7275 1
		just_zero = FALSE;
a7346 1
		    just_zero = FALSE;
d7405 1
a7405 4
	    if (just_zero && (PL_hints & HINT_NEW_INTEGER))
		sv = new_constant(start, s - start, "integer", 
				  sv, Nullsv, NULL);
	    else if (PL_hints & HINT_NEW_BINARY)
d7865 4
a7868 3
		utf16_to_utf8_reversed(s, news,
				       PL_bufend - (char*)s - 1,
				       &newlen);
d7892 4
a7895 3
		utf16_to_utf8(s, news,
			      PL_bufend - (char*)s,
			      &newlen);
a7961 1
    STRLEN old = SvCUR(sv);
a7962 3
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "utf16_textfilter(%p): %d %d (%d)\n",
			  utf16_textfilter, idx, maxlen, count));
d7965 1
d7968 6
a7973 4
	Copy(SvPVX(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX(sv) + old, tmps + old,
		      SvCUR(sv) - old, &newlen);
	sv_usepvn(sv, (char*)tmps, (STRLEN)newlen + old);
d7975 1
a7975 2
    DEBUG_P({sv_dump(sv);});
    return SvCUR(sv);
a7980 1
    STRLEN old = SvCUR(sv);
a7981 3
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "utf16rev_textfilter(%p): %d %d (%d)\n",
			  utf16rev_textfilter, idx, maxlen, count));
d7984 1
d7986 4
d7991 2
a7992 4
	Copy(SvPVX(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX(sv) + old, tmps + old,
		      SvCUR(sv) - old, &newlen);
	sv_usepvn(sv, (char*)tmps, (STRLEN)newlen + old);
a7993 1
    DEBUG_P({ sv_dump(sv); });
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d29 3
a31 6
static const char ident_too_long[] =
  "Identifier too long";
static const char c_without_g[] =
  "Use of /c modifier is meaningless without /g";
static const char c_in_subst[] =
  "Use of /c modifier is meaningless in s///";
d66 11
a76 32
#define LEX_NORMAL		10 /* normal code (ie not within "...")     */
#define LEX_INTERPNORMAL	 9 /* code within a string, eg "$foo[$x+1]" */
#define LEX_INTERPCASEMOD	 8 /* expecting a \U, \Q or \E etc          */
#define LEX_INTERPPUSH		 7 /* starting a new sublex parse level     */
#define LEX_INTERPSTART		 6 /* expecting the start of a $var         */

				   /* at end of code, eg "$x" followed by:  */
#define LEX_INTERPEND		 5 /* ... eg not one of [, { or ->          */
#define LEX_INTERPENDMAYBE	 4 /* ... eg one of [, { or ->              */

#define LEX_INTERPCONCAT	 3 /* expecting anything, eg at start of
				        string or after \E, $foo, etc       */
#define LEX_INTERPCONST		 2 /* NOT USED */
#define LEX_FORMLINE		 1 /* expecting a format line               */
#define LEX_KNOWNEXT		 0 /* next token known; just return it      */


#ifdef DEBUGGING
static const char* const lex_state_names[] = {
    "KNOWNEXT",
    "FORMLINE",
    "INTERPCONST",
    "INTERPCONCAT",
    "INTERPENDMAYBE",
    "INTERPEND",
    "INTERPSTART",
    "INTERPPUSH",
    "INTERPCASEMOD",
    "INTERPNORMAL",
    "NORMAL"
};
#endif
d135 2
d138 2
a139 1
#   define REPORT(retval) tokereport(s,(int)retval)
d141 2
a142 1
#   define REPORT(retval) (retval)
d145 20
a164 20
#define TOKEN(retval) return ( PL_bufptr = s, REPORT(retval))
#define OPERATOR(retval) return (PL_expect = XTERM, PL_bufptr = s, REPORT(retval))
#define AOPERATOR(retval) return ao((PL_expect = XTERM, PL_bufptr = s, REPORT(retval)))
#define PREBLOCK(retval) return (PL_expect = XBLOCK,PL_bufptr = s, REPORT(retval))
#define PRETERMBLOCK(retval) return (PL_expect = XTERMBLOCK,PL_bufptr = s, REPORT(retval))
#define PREREF(retval) return (PL_expect = XREF,PL_bufptr = s, REPORT(retval))
#define TERM(retval) return (CLINE, PL_expect = XOPERATOR, PL_bufptr = s, REPORT(retval))
#define LOOPX(f) return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)LOOPEX))
#define FTST(f)  return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)UNIOP))
#define FUN0(f)  return (yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC0))
#define FUN1(f)  return (yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC1))
#define BOop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITOROP)))
#define BAop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITANDOP)))
#define SHop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)SHIFTOP)))
#define PWop(f)  return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)POWOP)))
#define PMop(f)  return(yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MATCHOP))
#define Aop(f)   return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)ADDOP)))
#define Mop(f)   return ao((yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MULOP)))
#define Eop(f)   return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)EQOP))
#define Rop(f)   return (yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)RELOP))
d169 13
a181 21
#define UNI(f) { \
	yylval.ival = f; \
	PL_expect = XTERM; \
	PL_bufptr = s; \
	PL_last_uni = PL_oldbufptr; \
	PL_last_lop_op = f; \
	if (*s == '(') \
	    return REPORT( (int)FUNC1 ); \
	s = skipspace(s); \
	return REPORT( *s=='(' ? (int)FUNC1 : (int)UNIOP ); \
	}

#define UNIBRACK(f) { \
	yylval.ival = f; \
	PL_bufptr = s; \
	PL_last_uni = PL_oldbufptr; \
	if (*s == '(') \
	    return REPORT( (int)FUNC1 ); \
	s = skipspace(s); \
	return REPORT( (*s == '(') ? (int)FUNC1 : (int)UNIOP ); \
	}
d188 2
a189 80
/* how to interpret the yylval associated with the token */
enum token_type {
    TOKENTYPE_NONE,
    TOKENTYPE_IVAL,
    TOKENTYPE_OPNUM, /* yylval.ival contains an opcode number */
    TOKENTYPE_PVAL,
    TOKENTYPE_OPVAL,
    TOKENTYPE_GVVAL
};

static struct debug_tokens { const int token, type; const char *name; }
  const debug_tokens[] =
{
    { ADDOP,		TOKENTYPE_OPNUM,	"ADDOP" },
    { ANDAND,		TOKENTYPE_NONE,		"ANDAND" },
    { ANDOP,		TOKENTYPE_NONE,		"ANDOP" },
    { ANONSUB,		TOKENTYPE_IVAL,		"ANONSUB" },
    { ARROW,		TOKENTYPE_NONE,		"ARROW" },
    { ASSIGNOP,		TOKENTYPE_OPNUM,	"ASSIGNOP" },
    { BITANDOP,		TOKENTYPE_OPNUM,	"BITANDOP" },
    { BITOROP,		TOKENTYPE_OPNUM,	"BITOROP" },
    { COLONATTR,	TOKENTYPE_NONE,		"COLONATTR" },
    { CONTINUE,		TOKENTYPE_NONE,		"CONTINUE" },
    { DO,		TOKENTYPE_NONE,		"DO" },
    { DOLSHARP,		TOKENTYPE_NONE,		"DOLSHARP" },
    { DOTDOT,		TOKENTYPE_IVAL,		"DOTDOT" },
    { ELSE,		TOKENTYPE_NONE,		"ELSE" },
    { ELSIF,		TOKENTYPE_IVAL,		"ELSIF" },
    { EQOP,		TOKENTYPE_OPNUM,	"EQOP" },
    { FOR,		TOKENTYPE_IVAL,		"FOR" },
    { FORMAT,		TOKENTYPE_NONE,		"FORMAT" },
    { FUNC,		TOKENTYPE_OPNUM,	"FUNC" },
    { FUNC0,		TOKENTYPE_OPNUM,	"FUNC0" },
    { FUNC0SUB,		TOKENTYPE_OPVAL,	"FUNC0SUB" },
    { FUNC1,		TOKENTYPE_OPNUM,	"FUNC1" },
    { FUNCMETH,		TOKENTYPE_OPVAL,	"FUNCMETH" },
    { HASHBRACK,	TOKENTYPE_NONE,		"HASHBRACK" },
    { IF,		TOKENTYPE_IVAL,		"IF" },
    { LABEL,		TOKENTYPE_PVAL,		"LABEL" },
    { LOCAL,		TOKENTYPE_IVAL,		"LOCAL" },
    { LOOPEX,		TOKENTYPE_OPNUM,	"LOOPEX" },
    { LSTOP,		TOKENTYPE_OPNUM,	"LSTOP" },
    { LSTOPSUB,		TOKENTYPE_OPVAL,	"LSTOPSUB" },
    { MATCHOP,		TOKENTYPE_OPNUM,	"MATCHOP" },
    { METHOD,		TOKENTYPE_OPVAL,	"METHOD" },
    { MULOP,		TOKENTYPE_OPNUM,	"MULOP" },
    { MY,		TOKENTYPE_IVAL,		"MY" },
    { MYSUB,		TOKENTYPE_NONE,		"MYSUB" },
    { NOAMP,		TOKENTYPE_NONE,		"NOAMP" },
    { NOTOP,		TOKENTYPE_NONE,		"NOTOP" },
    { OROP,		TOKENTYPE_IVAL,		"OROP" },
    { OROR,		TOKENTYPE_NONE,		"OROR" },
    { PACKAGE,		TOKENTYPE_NONE,		"PACKAGE" },
    { PMFUNC,		TOKENTYPE_OPVAL,	"PMFUNC" },
    { POSTDEC,		TOKENTYPE_NONE,		"POSTDEC" },
    { POSTINC,		TOKENTYPE_NONE,		"POSTINC" },
    { POWOP,		TOKENTYPE_OPNUM,	"POWOP" },
    { PREDEC,		TOKENTYPE_NONE,		"PREDEC" },
    { PREINC,		TOKENTYPE_NONE,		"PREINC" },
    { PRIVATEREF,	TOKENTYPE_OPVAL,	"PRIVATEREF" },
    { REFGEN,		TOKENTYPE_NONE,		"REFGEN" },
    { RELOP,		TOKENTYPE_OPNUM,	"RELOP" },
    { SHIFTOP,		TOKENTYPE_OPNUM,	"SHIFTOP" },
    { SUB,		TOKENTYPE_NONE,		"SUB" },
    { THING,		TOKENTYPE_OPVAL,	"THING" },
    { UMINUS,		TOKENTYPE_NONE,		"UMINUS" },
    { UNIOP,		TOKENTYPE_OPNUM,	"UNIOP" },
    { UNIOPSUB,		TOKENTYPE_OPVAL,	"UNIOPSUB" },
    { UNLESS,		TOKENTYPE_IVAL,		"UNLESS" },
    { UNTIL,		TOKENTYPE_IVAL,		"UNTIL" },
    { USE,		TOKENTYPE_IVAL,		"USE" },
    { WHILE,		TOKENTYPE_IVAL,		"WHILE" },
    { WORD,		TOKENTYPE_OPVAL,	"WORD" },
    { 0,		TOKENTYPE_NONE,		0 }
};

/* dump the returned token in rv, plus any optional arg in yylval */

STATIC int
S_tokereport(pTHX_ const char* s, I32 rv)
d191 4
a194 43
    if (DEBUG_T_TEST) {
	const char *name = Nullch;
	enum token_type type = TOKENTYPE_NONE;
	const struct debug_tokens *p;
	SV* const report = newSVpvn("<== ", 4);

	for (p = debug_tokens; p->token; p++) {
	    if (p->token == (int)rv) {
		name = p->name;
		type = p->type;
		break;
	    }
	}
	if (name)
	    Perl_sv_catpvf(aTHX_ report, "%s", name);
	else if ((char)rv > ' ' && (char)rv < '~')
	    Perl_sv_catpvf(aTHX_ report, "'%c'", (char)rv);
	else if (!rv)
	    Perl_sv_catpvf(aTHX_ report, "EOF");
	else
	    Perl_sv_catpvf(aTHX_ report, "?? %"IVdf, (IV)rv);
	switch (type) {
	case TOKENTYPE_NONE:
	case TOKENTYPE_GVVAL: /* doesn't appear to be used */
	    break;
	case TOKENTYPE_IVAL:
	    Perl_sv_catpvf(aTHX_ report, "(ival=%"IVdf")", yylval.ival);
	    break;
	case TOKENTYPE_OPNUM:
	    Perl_sv_catpvf(aTHX_ report, "(ival=op_%s)",
				    PL_op_name[yylval.ival]);
	    break;
	case TOKENTYPE_PVAL:
	    Perl_sv_catpvf(aTHX_ report, "(pval=\"%s\")", yylval.pval);
	    break;
	case TOKENTYPE_OPVAL:
	    if (yylval.opval) {
		Perl_sv_catpvf(aTHX_ report, "(opval=op_%s)",
				    PL_op_name[yylval.opval->op_type]);
		if (yylval.opval->op_type == OP_CONST) {
		    Perl_sv_catpvf(aTHX_ report, " %s",
			SvPEEK(cSVOPx_sv(yylval.opval)));
		}
d196 8
a203 20
	    }
	    else
		Perl_sv_catpv(aTHX_ report, "(opval=null)");
	    break;
	}
        PerlIO_printf(Perl_debug_log, "### %s\n\n", SvPV_nolen_const(report));
    };
    return (int)rv;
}


/* print the buffer with suitable escapes */

STATIC void
S_printbuf(pTHX_ const char* fmt, const char* s)
{
    SV* tmp = newSVpvn("", 0);
    PerlIO_printf(Perl_debug_log, fmt,
		  pv_display(tmp, (char *)s, strlen(s), 0, 60));
    SvREFCNT_dec(tmp);
d243 1
a243 1
S_no_op(pTHX_ const char *what, char *s)
d245 2
a246 2
    char * const oldbp = PL_bufptr;
    const bool is_first = (PL_oldbufptr == PL_linestart);
d258 1
a258 1
	    const char *t;
d263 1
a263 1
		    (int)(t - PL_oldoldbufptr), PL_oldoldbufptr);
d268 1
a268 1
		    "\t(Missing operator before %.*s?)\n", (int)(s - oldbp), oldbp);
d289 1
a289 1
	char * const nl = strrchr(s,'\n');
d301 2
a302 1
	tmpbuf[1] = (char)toCTRL(PL_multi_close);
d338 1
a338 1
	Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED, WARN_SYNTAX),
d362 2
a363 2
    register const char *s = SvPVX_const(sv);
    register const char * const e = s + SvCUR(sv);
d384 1
a384 1
    const I32 count = FILTER_READ(idx+1, sv, maxlen);
d400 1
a400 1
    const char *s;
d441 2
a442 2
    Newx(PL_lex_brackstack, 120, char);
    Newx(PL_lex_casestack, 12, char);
d456 1
a456 1
    s = SvPV_const(PL_linestr, len);
a534 37
#ifndef USE_ITHREADS
	const char *cf = CopFILE(PL_curcop);
	if (cf && strlen(cf) > 7 && strnEQ(cf, "(eval ", 6)) {
	    /* must copy *{"::_<(eval N)[oldfilename:L]"}
	     * to *{"::_<newfilename"} */
	    char smallbuf[256], smallbuf2[256];
	    char *tmpbuf, *tmpbuf2;
	    GV **gvp, *gv2;
	    STRLEN tmplen = strlen(cf);
	    STRLEN tmplen2 = strlen(s);
	    if (tmplen + 3 < sizeof smallbuf)
		tmpbuf = smallbuf;
	    else
		Newx(tmpbuf, tmplen + 3, char);
	    if (tmplen2 + 3 < sizeof smallbuf2)
		tmpbuf2 = smallbuf2;
	    else
		Newx(tmpbuf2, tmplen2 + 3, char);
	    tmpbuf[0] = tmpbuf2[0] = '_';
	    tmpbuf[1] = tmpbuf2[1] = '<';
	    memcpy(tmpbuf + 2, cf, ++tmplen);
	    memcpy(tmpbuf2 + 2, s, ++tmplen2);
	    ++tmplen; ++tmplen2;
	    gvp = (GV**)hv_fetch(PL_defstash, tmpbuf, tmplen, FALSE);
	    if (gvp) {
		gv2 = *(GV**)hv_fetch(PL_defstash, tmpbuf2, tmplen2, TRUE);
		if (!isGV(gv2))
		    gv_init(gv2, PL_defstash, tmpbuf2, tmplen2, FALSE);
		/* adjust ${"::_<newfilename"} to store the new file name */
		GvSV(gv2) = newSVpvn(tmpbuf2 + 2, tmplen2 - 2);
		GvHV(gv2) = (HV*)SvREFCNT_inc(GvHV(*gvp));
		GvAV(gv2) = (AV*)SvREFCNT_inc(GvAV(*gvp));
	    }
	    if (tmpbuf != smallbuf) Safefree(tmpbuf);
	    if (tmpbuf2 != smallbuf2) Safefree(tmpbuf2);
	}
#endif
d591 5
a595 3
	    if (PL_minus_p) {
		sv_setpv(PL_linestr,
			 ";}continue{print or die qq(-p destination: $!\\n);}");
a597 4
	    else if (PL_minus_n) {
		sv_setpvn(PL_linestr, ";}", 2);
		PL_minus_n = 0;
	    }
d599 1
a599 1
		sv_setpvn(PL_linestr,";", 1);
d647 1
a647 1
	    SV * const sv = NEWSV(85,0);
d652 1
a652 1
            SvIV_set(sv, 0);
d681 1
a681 1
	const char ch = *s;
d710 1
d716 1
a716 1
	return REPORT(LSTOP);
d718 1
a718 1
	return REPORT(FUNC);
d721 1
a721 1
	return REPORT(FUNC);
d723 1
a723 1
	return REPORT(LSTOP);
d805 1
a805 1
S_force_ident(pTHX_ register const char *s, int kind)
d808 1
a808 1
	OP* const o = (OP*)newSVOP(OP_CONST, 0, newSVpv(s,0));
d832 3
a834 3
    const char *start = SvPV_const(sv,len);
    const char * const end = start + len;
    const bool utf = SvUTF8(sv) ? TRUE : FALSE;
d880 1
a880 1
		SvNV_set(ver, str_to_version(ver));
d925 1
a925 1
	pv = sv_2mortal(newSVpvn(SvPVX_const(pv), len));
d937 1
a937 1
    SvCUR_set(sv, d - SvPVX_const(sv));
d979 1
a979 1
    register const I32 op_type = yylval.ival;
d992 5
a996 2
	    const char *p = SvPV_const(sv, len);
	    SV * const nsv = newSVpvn(p, len);
d1066 2
a1067 2
    Newx(PL_lex_brackstack, 120, char);
    Newx(PL_lex_casestack, 12, char);
d1092 1
a1092 1
	SV * const sv = newSVpvn("",0);
a1226 3
#ifdef EBCDIC
    UV literal_endpoint = 0;
#endif
d1250 1
a1250 1
		    char * const c = (char*)utf8_hop((U8*)d, -1);
d1261 1
a1261 1
		i = d - SvPVX_const(sv);		/* remember current offset */
d1276 2
a1277 3
		if (literal_endpoint == 2 &&
		    ((isLOWER(min) && isLOWER(max)) ||
		     (isUPPER(min) && isUPPER(max)))) {
a1295 3
#ifdef EBCDIC
		literal_endpoint = 0;
#endif
a1313 3
#ifdef EBCDIC
		literal_endpoint = 0;
#endif
d1414 3
a1416 3
		    if (isALNUM(*s) &&
			*s != '_' &&
			ckWARN(WARN_MISC))
d1439 1
a1439 1
		    char* const e = strchr(s, '}');
d1488 1
a1488 1
			    const STRLEN offset = d - SvPVX_const(sv);
d1494 1
a1494 1
			    while (src >= (const U8 *)SvPVX_const(sv)) {
d1496 1
a1496 1
				    const U8 ch = NATIVE_TO_ASCII(*src);
d1534 1
a1534 1
 		    const char *str;
d1556 1
a1556 1
		    str = SvPV_const(res,len);
d1566 1
a1566 1
			 UV uv = utf8_to_uvchr((const U8*)str, 0);
d1569 1
a1569 1
			      U8 tmpbuf[UTF8_MAXBYTES+1], *d;
d1573 1
a1573 1
			      str = SvPV_const(res, len);
d1578 1
a1578 1
			const char * const ostart = SvPVX_const(sv);
d1589 1
a1589 1
			const char * const odest = SvPVX_const(sv);
a1646 4
#ifdef EBCDIC
	else
	    literal_endpoint++;
#endif
d1653 2
a1654 2
	    const UV uv       = (this_utf8) ? utf8n_to_uvchr((U8*)s, send - s, &len, 0) : (UV) ((U8) *s);
	    const STRLEN need = UNISKIP(NATIVE_TO_UNI(uv));
d1658 1
a1658 1
		const STRLEN off = d - SvPVX_const(sv);
d1671 1
a1671 1
    SvCUR_set(sv, d - SvPVX_const(sv));
d1691 2
a1692 1
	SvPV_shrink_to_cur(sv);
d1771 1
a1771 1
	const char * const send = strchr(s,']');
d1840 2
a1841 4
		if (!isALNUM(last_un_char)
		    && !(last_un_char == '$' || last_un_char == '@@'
			 || last_un_char == '&')
		    && isALPHA(*s) && s[1] && isALPHA(s[1])) {
d1897 1
a1897 1
	    const char *proto = SvPVX_const(cv);
d1955 1
a1955 1
STATIC const char*
d1959 1
a1959 1
	const char * const pdb = PerlEnv_getenv("PERL5DB");
d1997 3
a1999 2
    (void)SvUPGRADE(datasv, SVt_PVIO);
    IoANY(datasv) = FPTR2DPTR(void *, funcp); /* stash funcp into spare field */
d2002 1
a2002 1
			  IoANY(datasv), SvPV_nolen(datasv)));
d2014 1
a2014 4

#ifdef DEBUGGING
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p", FPTR2DPTR(XPVIO *, funcp)));
#endif
d2019 1
a2019 1
    if (IoANY(datasv) == FPTR2DPTR(void *, funcp)) {
d2049 1
a2049 1
	    const int old_len = SvCUR(buf_sv);
d2079 1
a2079 1
    funcp = DPTR2FPTR(filter_t, IoANY(datasv));
d2082 1
a2082 1
			  idx, datasv, SvPV_nolen_const(datasv)));
d2110 1
a2110 1
S_find_in_my_stash(pTHX_ const char *pkgname, I32 len)
d2128 1
a2128 1
            pkgname = SvPV_nolen_const(sv);
d2136 1
a2136 1
    static const char* const exp_name[] =
d2194 1
a2194 1
    register char *s = PL_bufptr;
a2202 9
    DEBUG_T( {
	SV* tmp = newSVpvn("", 0);
	PerlIO_printf(Perl_debug_log, "### %"IVdf":LEX_%s/X%s %s\n",
	    (IV)CopLINE(PL_curcop),
	    lex_state_names[PL_lex_state],
	    exp_name[PL_expect],
	    pv_display(tmp, s, strlen(s), 0, 60));
	SvREFCNT_dec(tmp);
    } );
d2205 1
a2205 1
        return REPORT(S_pending_ident(aTHX));
d2225 5
a2229 1
	return REPORT(PL_nexttype[PL_nexttoke]);
d2241 2
d2245 1
a2245 1
		const char oldmod = PL_lex_casestack[--PL_lex_casemods];
d2248 1
a2248 2
		if (PL_bufptr != PL_bufend
		    && (oldmod == 'L' || oldmod == 'U' || oldmod == 'Q')) {
d2252 1
a2252 1
		return REPORT(')');
d2261 1
a2261 1
              "### Saw case modifier\n"); });
d2271 1
a2271 1
		if ((*s == 'L' || *s == 'U') &&
d2274 1
a2274 1
		    return REPORT(')');
d2308 1
a2308 1
        return REPORT(sublex_push());
d2312 1
a2312 1
	    return REPORT(sublex_done());
d2314 1
a2314 1
              "### Interpolated variable\n"); });
d2352 1
a2352 1
	    return REPORT(')');
d2368 1
a2368 1
	    return REPORT(sublex_done());
d2411 4
d2448 1
a2448 1
		sv_catpvn(PL_linestr,";", 1);
d2453 1
a2453 1
		    sv_catpvn(PL_linestr, ";", 1);
d2465 1
a2465 2
			if ((*PL_splitstr == '/' || *PL_splitstr == '\''
			     || *PL_splitstr == '"')
d2469 12
a2480 17
			    /* "q\0${splitstr}\0" is legal perl. Yes, even NUL
			       bytes can be used as quoting characters.  :-) */
			    /* The count here deliberately includes the NUL
			       that terminates the C string constant.  This
			       embeds the opening NUL into the string.  */
			    const char *splits = PL_splitstr;
			    sv_catpvn(PL_linestr, "our @@F=split(q", 15);
			    do {
				/* Need to \ \s  */
				if (*splits == '\\')
				    sv_catpvn(PL_linestr, splits, 1);
				sv_catpvn(PL_linestr, splits, 1);
			    } while (*splits++);
			    /* This loop will embed the trailing NUL of
			       PL_linestr as the last thing it does before
			       terminating.  */
			    sv_catpvn(PL_linestr, ");", 2);
d2487 1
a2487 1
	    sv_catpvn(PL_linestr, "\n", 1);
d2492 1
a2492 1
		SV * const sv = NEWSV(85,0);
d2497 1
a2497 1
                SvIV_set(sv, 0);
d2517 2
a2518 2
		    sv_setpv(PL_linestr,PL_minus_p
			     ? ";}continue{print;}" : ";}");
d2527 1
a2527 1
		sv_setpvn(PL_linestr,"",0);
d2568 1
a2568 1
		    sv_setpvn(PL_linestr, "", 0);
d2579 1
a2579 1
	    SV * const sv = NEWSV(85,0);
d2584 1
a2584 1
            SvIV_set(sv, 0);
d2600 1
a2600 1
		    static char const as[] = ALTERNATE_SHEBANG;
d2625 1
a2625 1
		    SV * const x = GvSV(gv_fetchpv("\030", TRUE, SVt_PV)); /* $^X */
d2634 2
a2635 2
			const char *bstart = SvPV_const(CopFILESV(PL_curcop),blen);
			const char * const lstart = SvPV_const(x,llen);
d2681 1
a2681 1
		    const char *c = ipath;
d2698 1
a2698 1
				    char **newargv;
d2705 1
a2705 1
			Newxz(newargv,PL_origargc+3,char*);
d2722 3
a2724 3
		    const U32 oldpdb = PL_perldb;
		    const bool oldn = PL_minus_n;
		    const bool oldp = PL_minus_p;
d2730 1
a2730 1
			const bool switches_done = PL_doswitches;
d2733 1
a2733 1
				const char * const m = d;
d2753 1
a2753 1
			    sv_setpvn(PL_linestr, "", 0);
d2832 2
a2833 2
                DEBUG_T( { S_printbuf(aTHX_
			"### Saw unary minus before =>, forcing word %s\n", s);
d2878 1
a2878 1
                        "### Saw file test %c\n", (int)tmp);
d2887 1
a2887 1
			(int) tmp);
d3024 1
a3024 1
			return REPORT(0);	/* EOF indicator */
d3043 1
a3043 1
			else
d3078 1
a3078 1
		const char q = ((*s == '\'') ? '"' : '\'');
d3170 1
a3170 1
		    const char minus = (PL_tokenbuf[0] == '-');
d3188 1
a3188 1
		const char *t;
d3211 1
a3211 1
		 * disambiguated by prepending a "+" before the opening
d3234 1
a3234 1
			const char *tmps;
d3335 2
a3336 2
	    if (PL_bufptr == PL_linestart && ckWARN(WARN_SEMICOLON)
		&& isIDFIRST_lazy_if(s,UTF))
d3371 1
a3371 1
	if (tmp && isSPACE(*s) && ckWARN(WARN_SYNTAX) && strchr("+-*/%.^&|<",tmp))
d3400 1
a3400 1
	    const char *t;
d3463 1
a3463 1
		return REPORT(','); /* grandfather non-comma-format format */
d3505 1
a3508 1
		    char *t;
a3522 1
		char *t;
d3524 2
a3525 2
		if (strEQ(PL_tokenbuf+1, "SIG")  && ckWARN(WARN_SYNTAX)
		    && (t = strchr(s, '}')) && (t = strchr(t, '=')))
d3528 1
a3530 1
		        STRLEN len;
d3543 1
a3543 1
	    const bool islop = (PL_last_lop == PL_oldoldbufptr);
d3578 1
a3578 2
	    else if ((*s == '?' || *s == '-' || *s == '+')
		     && !isSPACE(s[1]) && s[1] != '=')
d3601 3
a3603 3
	    if (*s == '[' || *s == '{') {
		if (ckWARN(WARN_SYNTAX)) {
		    const char *t = s + 1;
d3669 3
a3671 1
	DEBUG_T( { S_printbuf(aTHX_ "### Saw number in %s\n", s); } );
d3678 3
a3680 1
	DEBUG_T( { S_printbuf(aTHX_ "### Saw string before %s\n", s); } );
d3685 1
a3685 1
		return REPORT(','); /* grandfather non-comma-format format */
d3697 3
a3699 1
	DEBUG_T( { S_printbuf(aTHX_ "### Saw string before %s\n", s); } );
d3704 1
a3704 1
		return REPORT(','); /* grandfather non-comma-format format */
a3711 2
	/* FIXME. I think that this can be const if char *d is replaced by
	   more localised variables.  */
d3722 3
a3724 1
	DEBUG_T( { S_printbuf(aTHX_ "### Saw backtick string before %s\n", s); } );
d3735 1
a3735 1
	if (PL_lex_inwhat && isDIGIT(*s) && ckWARN(WARN_SYNTAX))
d3744 3
a3746 1
	    char *start = s + 2;
d3755 1
a3755 1
		const char c = *start;
d3886 2
a3887 2
		if (hgv && tmp != KEY_x && tmp != KEY_CORE
			&& ckWARN(WARN_AMBIGUOUS))	/* never ambiguous */
d3901 1
a3901 1
		const char lastchar = (PL_bufptr == PL_oldoldbufptr ? 0 : PL_bufptr[-1]);
d3954 2
a3955 6
		else {
		    /* If len is 0, newSVpv does strlen(), which is correct.
		       If len is non-zero, then it will be the true length,
		       and so the scalar will be created correctly.  */
		    sv = newSVpv(PL_tokenbuf,len);
		}
d3964 1
a3964 1
		    is_utf8_string((U8*)SvPVX_const(sv), SvCUR(sv)))
d3990 1
a3990 1
			return REPORT(tmp);
d4047 1
a4047 1
		    return REPORT(tmp);
d4076 1
a4076 1
			const char *proto = SvPV_const((SV*)cv, len);
d4079 1
a4079 1
			if (*proto == '$' && proto[1] == '\0')
d4084 1
a4084 1
			    sv_setpv(PL_subname, PL_curstash ?
d4101 2
a4102 2
		    if (lastchar != '-') {
			if (ckWARN(WARN_RESERVED)) {
d4112 1
a4112 2
		if ((lastchar == '*' || lastchar == '%' || lastchar == '&')
		    && ckWARN_d(WARN_AMBIGUOUS)) {
d4136 1
a4136 1
					 ? newSVpv(HvNAME_get(PL_curstash), 0)
d4143 2
d4146 1
a4146 1
		const char *pname = "main";
d4148 1
a4148 1
		    pname = HvNAME_get(PL_curstash ? PL_curstash : PL_defstash);
d4156 1
a4156 1
		    const int fd = PerlIO_fileno(PL_rsfp);
d4213 1
a4213 1
			PerlIO_apply_layers(aTHX_ PL_rsfp, NULL,
d4672 1
a4672 1
		const char *t;
a4678 1
		    int len = (int)(d-s);
d4681 1
a4681 1
			    len, s, len, s);
a4742 1
	    PL_expect = XOPERATOR;
d4752 1
a4752 1
			const char *b = d;
d4795 1
a4795 1
		SvIV_set(PL_lex_stuff, 0);	/* qq'$foo' should intepolate */
d5010 1
a5010 1
		const int key = tmp;
d5037 1
a5037 1
		    sv_setpvn(PL_subname,"?",1);
d5073 1
a5073 1
		    SvCUR_set(PL_lex_stuff, tmp);
d5278 1
a5278 1
          "### Pending identifier '%s'\n", PL_tokenbuf); });
d5334 1
a5334 2
                SV * const sym
		  = newSVpv(HvNAME_get(PAD_COMPNAME_OURSTASH(tmp)), 0);
a5399 4
/*
 *  The following code was generated by perl_keyword.pl.
 */

d5401 1
a5401 1
Perl_keyword (pTHX_ char *name, I32 len)
d5403 601
a6003 372
  switch (len)
  {
    case 1: /* 5 tokens of length 1 */
      switch (name[0])
      {
        case 'm':
          {                                       /* m          */
            return KEY_m;
          }

        case 'q':
          {                                       /* q          */
            return KEY_q;
          }

        case 's':
          {                                       /* s          */
            return KEY_s;
          }

        case 'x':
          {                                       /* x          */
            return -KEY_x;
          }

        case 'y':
          {                                       /* y          */
            return KEY_y;
          }

        default:
          goto unknown;
      }

    case 2: /* 18 tokens of length 2 */
      switch (name[0])
      {
        case 'd':
          if (name[1] == 'o')
          {                                       /* do         */
            return KEY_do;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'q')
          {                                       /* eq         */
            return -KEY_eq;
          }

          goto unknown;

        case 'g':
          switch (name[1])
          {
            case 'e':
              {                                   /* ge         */
                return -KEY_ge;
              }

            case 't':
              {                                   /* gt         */
                return -KEY_gt;
              }

            default:
              goto unknown;
          }

        case 'i':
          if (name[1] == 'f')
          {                                       /* if         */
            return KEY_if;
          }

          goto unknown;

        case 'l':
          switch (name[1])
          {
            case 'c':
              {                                   /* lc         */
                return -KEY_lc;
              }

            case 'e':
              {                                   /* le         */
                return -KEY_le;
              }

            case 't':
              {                                   /* lt         */
                return -KEY_lt;
              }

            default:
              goto unknown;
          }

        case 'm':
          if (name[1] == 'y')
          {                                       /* my         */
            return KEY_my;
          }

          goto unknown;

        case 'n':
          switch (name[1])
          {
            case 'e':
              {                                   /* ne         */
                return -KEY_ne;
              }

            case 'o':
              {                                   /* no         */
                return KEY_no;
              }

            default:
              goto unknown;
          }

        case 'o':
          if (name[1] == 'r')
          {                                       /* or         */
            return -KEY_or;
          }

          goto unknown;

        case 'q':
          switch (name[1])
          {
            case 'q':
              {                                   /* qq         */
                return KEY_qq;
              }

            case 'r':
              {                                   /* qr         */
                return KEY_qr;
              }

            case 'w':
              {                                   /* qw         */
                return KEY_qw;
              }

            case 'x':
              {                                   /* qx         */
                return KEY_qx;
              }

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'r')
          {                                       /* tr         */
            return KEY_tr;
          }

          goto unknown;

        case 'u':
          if (name[1] == 'c')
          {                                       /* uc         */
            return -KEY_uc;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 3: /* 27 tokens of length 3 */
      switch (name[0])
      {
        case 'E':
          if (name[1] == 'N' &&
              name[2] == 'D')
          {                                       /* END        */
            return KEY_END;
          }

          goto unknown;

        case 'a':
          switch (name[1])
          {
            case 'b':
              if (name[2] == 's')
              {                                   /* abs        */
                return -KEY_abs;
              }

              goto unknown;

            case 'n':
              if (name[2] == 'd')
              {                                   /* and        */
                return -KEY_and;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'c':
          switch (name[1])
          {
            case 'h':
              if (name[2] == 'r')
              {                                   /* chr        */
                return -KEY_chr;
              }

              goto unknown;

            case 'm':
              if (name[2] == 'p')
              {                                   /* cmp        */
                return -KEY_cmp;
              }

              goto unknown;

            case 'o':
              if (name[2] == 's')
              {                                   /* cos        */
                return -KEY_cos;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'd':
          if (name[1] == 'i' &&
              name[2] == 'e')
          {                                       /* die        */
            return -KEY_die;
          }

          goto unknown;

        case 'e':
          switch (name[1])
          {
            case 'o':
              if (name[2] == 'f')
              {                                   /* eof        */
                return -KEY_eof;
              }

              goto unknown;

            case 'x':
              if (name[2] == 'p')
              {                                   /* exp        */
                return -KEY_exp;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r')
          {                                       /* for        */
            return KEY_for;
          }

          goto unknown;

        case 'h':
          if (name[1] == 'e' &&
              name[2] == 'x')
          {                                       /* hex        */
            return -KEY_hex;
          }

          goto unknown;

        case 'i':
          if (name[1] == 'n' &&
              name[2] == 't')
          {                                       /* int        */
            return -KEY_int;
          }

          goto unknown;

        case 'l':
          if (name[1] == 'o' &&
              name[2] == 'g')
          {                                       /* log        */
            return -KEY_log;
          }

          goto unknown;

        case 'm':
          if (name[1] == 'a' &&
              name[2] == 'p')
          {                                       /* map        */
            return KEY_map;
          }

          goto unknown;

        case 'n':
          if (name[1] == 'o' &&
              name[2] == 't')
          {                                       /* not        */
            return -KEY_not;
          }

          goto unknown;

        case 'o':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 't')
              {                                   /* oct        */
                return -KEY_oct;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'd')
              {                                   /* ord        */
                return -KEY_ord;
              }

              goto unknown;

            case 'u':
              if (name[2] == 'r')
              {                                   /* our        */
                return KEY_our;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'p':
          if (name[1] == 'o')
          {
            switch (name[2])
            {
              case 'p':
                {                                 /* pop        */
                  return -KEY_pop;
                }
d6005 2
a6006 2916
              case 's':
                {                                 /* pos        */
                  return KEY_pos;
                }

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e' &&
              name[2] == 'f')
          {                                       /* ref        */
            return -KEY_ref;
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'i':
              if (name[2] == 'n')
              {                                   /* sin        */
                return -KEY_sin;
              }

              goto unknown;

            case 'u':
              if (name[2] == 'b')
              {                                   /* sub        */
                return KEY_sub;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'i' &&
              name[2] == 'e')
          {                                       /* tie        */
            return KEY_tie;
          }

          goto unknown;

        case 'u':
          if (name[1] == 's' &&
              name[2] == 'e')
          {                                       /* use        */
            return KEY_use;
          }

          goto unknown;

        case 'v':
          if (name[1] == 'e' &&
              name[2] == 'c')
          {                                       /* vec        */
            return -KEY_vec;
          }

          goto unknown;

        case 'x':
          if (name[1] == 'o' &&
              name[2] == 'r')
          {                                       /* xor        */
            return -KEY_xor;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 4: /* 40 tokens of length 4 */
      switch (name[0])
      {
        case 'C':
          if (name[1] == 'O' &&
              name[2] == 'R' &&
              name[3] == 'E')
          {                                       /* CORE       */
            return -KEY_CORE;
          }

          goto unknown;

        case 'I':
          if (name[1] == 'N' &&
              name[2] == 'I' &&
              name[3] == 'T')
          {                                       /* INIT       */
            return KEY_INIT;
          }

          goto unknown;

        case 'b':
          if (name[1] == 'i' &&
              name[2] == 'n' &&
              name[3] == 'd')
          {                                       /* bind       */
            return -KEY_bind;
          }

          goto unknown;

        case 'c':
          if (name[1] == 'h' &&
              name[2] == 'o' &&
              name[3] == 'p')
          {                                       /* chop       */
            return -KEY_chop;
          }

          goto unknown;

        case 'd':
          if (name[1] == 'u' &&
              name[2] == 'm' &&
              name[3] == 'p')
          {                                       /* dump       */
            return -KEY_dump;
          }

          goto unknown;

        case 'e':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'c' &&
                  name[3] == 'h')
              {                                   /* each       */
                return -KEY_each;
              }

              goto unknown;

            case 'l':
              if (name[2] == 's' &&
                  name[3] == 'e')
              {                                   /* else       */
                return KEY_else;
              }

              goto unknown;

            case 'v':
              if (name[2] == 'a' &&
                  name[3] == 'l')
              {                                   /* eval       */
                return KEY_eval;
              }

              goto unknown;

            case 'x':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'c')
                  {                               /* exec       */
                    return -KEY_exec;
                  }

                  goto unknown;

                case 'i':
                  if (name[3] == 't')
                  {                               /* exit       */
                    return -KEY_exit;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r' &&
              name[3] == 'k')
          {                                       /* fork       */
            return -KEY_fork;
          }

          goto unknown;

        case 'g':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 't' &&
                  name[3] == 'c')
              {                                   /* getc       */
                return -KEY_getc;
              }

              goto unknown;

            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 'b')
              {                                   /* glob       */
                return KEY_glob;
              }

              goto unknown;

            case 'o':
              if (name[2] == 't' &&
                  name[3] == 'o')
              {                                   /* goto       */
                return KEY_goto;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'e' &&
                  name[3] == 'p')
              {                                   /* grep       */
                return KEY_grep;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'j':
          if (name[1] == 'o' &&
              name[2] == 'i' &&
              name[3] == 'n')
          {                                       /* join       */
            return -KEY_join;
          }

          goto unknown;

        case 'k':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'y' &&
                  name[3] == 's')
              {                                   /* keys       */
                return -KEY_keys;
              }

              goto unknown;

            case 'i':
              if (name[2] == 'l' &&
                  name[3] == 'l')
              {                                   /* kill       */
                return -KEY_kill;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'l':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 's' &&
                  name[3] == 't')
              {                                   /* last       */
                return KEY_last;
              }

              goto unknown;

            case 'i':
              if (name[2] == 'n' &&
                  name[3] == 'k')
              {                                   /* link       */
                return -KEY_link;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'k')
              {                                   /* lock       */
                return -KEY_lock;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'n':
          if (name[1] == 'e' &&
              name[2] == 'x' &&
              name[3] == 't')
          {                                       /* next       */
            return KEY_next;
          }

          goto unknown;

        case 'o':
          if (name[1] == 'p' &&
              name[2] == 'e' &&
              name[3] == 'n')
          {                                       /* open       */
            return -KEY_open;
          }

          goto unknown;

        case 'p':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'c' &&
                  name[3] == 'k')
              {                                   /* pack       */
                return -KEY_pack;
              }

              goto unknown;

            case 'i':
              if (name[2] == 'p' &&
                  name[3] == 'e')
              {                                   /* pipe       */
                return -KEY_pipe;
              }

              goto unknown;

            case 'u':
              if (name[2] == 's' &&
                  name[3] == 'h')
              {                                   /* push       */
                return -KEY_push;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'r':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'n' &&
                  name[3] == 'd')
              {                                   /* rand       */
                return -KEY_rand;
              }

              goto unknown;

            case 'e':
              switch (name[2])
              {
                case 'a':
                  if (name[3] == 'd')
                  {                               /* read       */
                    return -KEY_read;
                  }

                  goto unknown;

                case 'c':
                  if (name[3] == 'v')
                  {                               /* recv       */
                    return -KEY_recv;
                  }

                  goto unknown;

                case 'd':
                  if (name[3] == 'o')
                  {                               /* redo       */
                    return KEY_redo;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 's':
          switch (name[1])
          {
            case 'e':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'k')
                  {                               /* seek       */
                    return -KEY_seek;
                  }

                  goto unknown;

                case 'n':
                  if (name[3] == 'd')
                  {                               /* send       */
                    return -KEY_send;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'o':
              if (name[2] == 'r' &&
                  name[3] == 't')
              {                                   /* sort       */
                return KEY_sort;
              }

              goto unknown;

            case 'q':
              if (name[2] == 'r' &&
                  name[3] == 't')
              {                                   /* sqrt       */
                return -KEY_sqrt;
              }

              goto unknown;

            case 't':
              if (name[2] == 'a' &&
                  name[3] == 't')
              {                                   /* stat       */
                return -KEY_stat;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'l' &&
                  name[3] == 'l')
              {                                   /* tell       */
                return -KEY_tell;
              }

              goto unknown;

            case 'i':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'd')
                  {                               /* tied       */
                    return KEY_tied;
                  }

                  goto unknown;

                case 'm':
                  if (name[3] == 'e')
                  {                               /* time       */
                    return -KEY_time;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 'w':
          if (name[1] == 'a')
          {
            switch (name[2])
            {
              case 'i':
                if (name[3] == 't')
                {                                 /* wait       */
                  return -KEY_wait;
                }

                goto unknown;

              case 'r':
                if (name[3] == 'n')
                {                                 /* warn       */
                  return -KEY_warn;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 5: /* 36 tokens of length 5 */
      switch (name[0])
      {
        case 'B':
          if (name[1] == 'E' &&
              name[2] == 'G' &&
              name[3] == 'I' &&
              name[4] == 'N')
          {                                       /* BEGIN      */
            return KEY_BEGIN;
          }

          goto unknown;

        case 'C':
          if (name[1] == 'H' &&
              name[2] == 'E' &&
              name[3] == 'C' &&
              name[4] == 'K')
          {                                       /* CHECK      */
            return KEY_CHECK;
          }

          goto unknown;

        case 'a':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 'a' &&
                  name[3] == 'r' &&
                  name[4] == 'm')
              {                                   /* alarm      */
                return -KEY_alarm;
              }

              goto unknown;

            case 't':
              if (name[2] == 'a' &&
                  name[3] == 'n' &&
                  name[4] == '2')
              {                                   /* atan2      */
                return -KEY_atan2;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'b':
          if (name[1] == 'l' &&
              name[2] == 'e' &&
              name[3] == 's' &&
              name[4] == 's')
          {                                       /* bless      */
            return -KEY_bless;
          }

          goto unknown;

        case 'c':
          switch (name[1])
          {
            case 'h':
              switch (name[2])
              {
                case 'd':
                  if (name[3] == 'i' &&
                      name[4] == 'r')
                  {                               /* chdir      */
                    return -KEY_chdir;
                  }

                  goto unknown;

                case 'm':
                  if (name[3] == 'o' &&
                      name[4] == 'd')
                  {                               /* chmod      */
                    return -KEY_chmod;
                  }

                  goto unknown;

                case 'o':
                  switch (name[3])
                  {
                    case 'm':
                      if (name[4] == 'p')
                      {                           /* chomp      */
                        return -KEY_chomp;
                      }

                      goto unknown;

                    case 'w':
                      if (name[4] == 'n')
                      {                           /* chown      */
                        return -KEY_chown;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }

                default:
                  goto unknown;
              }

            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 's' &&
                  name[4] == 'e')
              {                                   /* close      */
                return -KEY_close;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'y' &&
                  name[3] == 'p' &&
                  name[4] == 't')
              {                                   /* crypt      */
                return -KEY_crypt;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'e':
          if (name[1] == 'l' &&
              name[2] == 's' &&
              name[3] == 'i' &&
              name[4] == 'f')
          {                                       /* elsif      */
            return KEY_elsif;
          }

          goto unknown;

        case 'f':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 'n' &&
                  name[3] == 't' &&
                  name[4] == 'l')
              {                                   /* fcntl      */
                return -KEY_fcntl;
              }

              goto unknown;

            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 'c' &&
                  name[4] == 'k')
              {                                   /* flock      */
                return -KEY_flock;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'i':
          switch (name[1])
          {
            case 'n':
              if (name[2] == 'd' &&
                  name[3] == 'e' &&
                  name[4] == 'x')
              {                                   /* index      */
                return -KEY_index;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 't' &&
                  name[4] == 'l')
              {                                   /* ioctl      */
                return -KEY_ioctl;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'l':
          switch (name[1])
          {
            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'a' &&
                  name[4] == 'l')
              {                                   /* local      */
                return KEY_local;
              }

              goto unknown;

            case 's':
              if (name[2] == 't' &&
                  name[3] == 'a' &&
                  name[4] == 't')
              {                                   /* lstat      */
                return -KEY_lstat;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'm':
          if (name[1] == 'k' &&
              name[2] == 'd' &&
              name[3] == 'i' &&
              name[4] == 'r')
          {                                       /* mkdir      */
            return -KEY_mkdir;
          }

          goto unknown;

        case 'p':
          if (name[1] == 'r' &&
              name[2] == 'i' &&
              name[3] == 'n' &&
              name[4] == 't')
          {                                       /* print      */
            return KEY_print;
          }

          goto unknown;

        case 'r':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 's' &&
                  name[3] == 'e' &&
                  name[4] == 't')
              {                                   /* reset      */
                return -KEY_reset;
              }

              goto unknown;

            case 'm':
              if (name[2] == 'd' &&
                  name[3] == 'i' &&
                  name[4] == 'r')
              {                                   /* rmdir      */
                return -KEY_rmdir;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 's':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'm' &&
                  name[3] == 'o' &&
                  name[4] == 'p')
              {                                   /* semop      */
                return -KEY_semop;
              }

              goto unknown;

            case 'h':
              if (name[2] == 'i' &&
                  name[3] == 'f' &&
                  name[4] == 't')
              {                                   /* shift      */
                return -KEY_shift;
              }

              goto unknown;

            case 'l':
              if (name[2] == 'e' &&
                  name[3] == 'e' &&
                  name[4] == 'p')
              {                                   /* sleep      */
                return -KEY_sleep;
              }

              goto unknown;

            case 'p':
              if (name[2] == 'l' &&
                  name[3] == 'i' &&
                  name[4] == 't')
              {                                   /* split      */
                return KEY_split;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'a' &&
                  name[3] == 'n' &&
                  name[4] == 'd')
              {                                   /* srand      */
                return -KEY_srand;
              }

              goto unknown;

            case 't':
              if (name[2] == 'u' &&
                  name[3] == 'd' &&
                  name[4] == 'y')
              {                                   /* study      */
                return KEY_study;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'i' &&
              name[2] == 'm' &&
              name[3] == 'e' &&
              name[4] == 's')
          {                                       /* times      */
            return -KEY_times;
          }

          goto unknown;

        case 'u':
          switch (name[1])
          {
            case 'm':
              if (name[2] == 'a' &&
                  name[3] == 's' &&
                  name[4] == 'k')
              {                                   /* umask      */
                return -KEY_umask;
              }

              goto unknown;

            case 'n':
              switch (name[2])
              {
                case 'd':
                  if (name[3] == 'e' &&
                      name[4] == 'f')
                  {                               /* undef      */
                    return KEY_undef;
                  }

                  goto unknown;

                case 't':
                  if (name[3] == 'i')
                  {
                    switch (name[4])
                    {
                      case 'e':
                        {                         /* untie      */
                          return KEY_untie;
                        }

                      case 'l':
                        {                         /* until      */
                          return KEY_until;
                        }

                      default:
                        goto unknown;
                    }
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 't':
              if (name[2] == 'i' &&
                  name[3] == 'm' &&
                  name[4] == 'e')
              {                                   /* utime      */
                return -KEY_utime;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'w':
          switch (name[1])
          {
            case 'h':
              if (name[2] == 'i' &&
                  name[3] == 'l' &&
                  name[4] == 'e')
              {                                   /* while      */
                return KEY_while;
              }

              goto unknown;

            case 'r':
              if (name[2] == 'i' &&
                  name[3] == 't' &&
                  name[4] == 'e')
              {                                   /* write      */
                return -KEY_write;
              }

              goto unknown;

            default:
              goto unknown;
          }

        default:
          goto unknown;
      }

    case 6: /* 33 tokens of length 6 */
      switch (name[0])
      {
        case 'a':
          if (name[1] == 'c' &&
              name[2] == 'c' &&
              name[3] == 'e' &&
              name[4] == 'p' &&
              name[5] == 't')
          {                                       /* accept     */
            return -KEY_accept;
          }

          goto unknown;

        case 'c':
          switch (name[1])
          {
            case 'a':
              if (name[2] == 'l' &&
                  name[3] == 'l' &&
                  name[4] == 'e' &&
                  name[5] == 'r')
              {                                   /* caller     */
                return -KEY_caller;
              }

              goto unknown;

            case 'h':
              if (name[2] == 'r' &&
                  name[3] == 'o' &&
                  name[4] == 'o' &&
                  name[5] == 't')
              {                                   /* chroot     */
                return -KEY_chroot;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'd':
          if (name[1] == 'e' &&
              name[2] == 'l' &&
              name[3] == 'e' &&
              name[4] == 't' &&
              name[5] == 'e')
          {                                       /* delete     */
            return KEY_delete;
          }

          goto unknown;

        case 'e':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 's' &&
                  name[3] == 'e' &&
                  name[4] == 'i' &&
                  name[5] == 'f')
              {                                   /* elseif     */
                if(ckWARN_d(WARN_SYNTAX))
                  Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "elseif should be elsif");
              }

              goto unknown;

            case 'x':
              if (name[2] == 'i' &&
                  name[3] == 's' &&
                  name[4] == 't' &&
                  name[5] == 's')
              {                                   /* exists     */
                return KEY_exists;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'f':
          switch (name[1])
          {
            case 'i':
              if (name[2] == 'l' &&
                  name[3] == 'e' &&
                  name[4] == 'n' &&
                  name[5] == 'o')
              {                                   /* fileno     */
                return -KEY_fileno;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'r' &&
                  name[3] == 'm' &&
                  name[4] == 'a' &&
                  name[5] == 't')
              {                                   /* format     */
                return KEY_format;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'g':
          if (name[1] == 'm' &&
              name[2] == 't' &&
              name[3] == 'i' &&
              name[4] == 'm' &&
              name[5] == 'e')
          {                                       /* gmtime     */
            return -KEY_gmtime;
          }

          goto unknown;

        case 'l':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 'n' &&
                  name[3] == 'g' &&
                  name[4] == 't' &&
                  name[5] == 'h')
              {                                   /* length     */
                return -KEY_length;
              }

              goto unknown;

            case 'i':
              if (name[2] == 's' &&
                  name[3] == 't' &&
                  name[4] == 'e' &&
                  name[5] == 'n')
              {                                   /* listen     */
                return -KEY_listen;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'm':
          if (name[1] == 's' &&
              name[2] == 'g')
          {
            switch (name[3])
            {
              case 'c':
                if (name[4] == 't' &&
                    name[5] == 'l')
                {                                 /* msgctl     */
                  return -KEY_msgctl;
                }

                goto unknown;

              case 'g':
                if (name[4] == 'e' &&
                    name[5] == 't')
                {                                 /* msgget     */
                  return -KEY_msgget;
                }

                goto unknown;

              case 'r':
                if (name[4] == 'c' &&
                    name[5] == 'v')
                {                                 /* msgrcv     */
                  return -KEY_msgrcv;
                }

                goto unknown;

              case 's':
                if (name[4] == 'n' &&
                    name[5] == 'd')
                {                                 /* msgsnd     */
                  return -KEY_msgsnd;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'p':
          if (name[1] == 'r' &&
              name[2] == 'i' &&
              name[3] == 'n' &&
              name[4] == 't' &&
              name[5] == 'f')
          {                                       /* printf     */
            return KEY_printf;
          }

          goto unknown;

        case 'r':
          switch (name[1])
          {
            case 'e':
              switch (name[2])
              {
                case 'n':
                  if (name[3] == 'a' &&
                      name[4] == 'm' &&
                      name[5] == 'e')
                  {                               /* rename     */
                    return -KEY_rename;
                  }

                  goto unknown;

                case 't':
                  if (name[3] == 'u' &&
                      name[4] == 'r' &&
                      name[5] == 'n')
                  {                               /* return     */
                    return KEY_return;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'i':
              if (name[2] == 'n' &&
                  name[3] == 'd' &&
                  name[4] == 'e' &&
                  name[5] == 'x')
              {                                   /* rindex     */
                return -KEY_rindex;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 's':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 'a' &&
                  name[3] == 'l' &&
                  name[4] == 'a' &&
                  name[5] == 'r')
              {                                   /* scalar     */
                return KEY_scalar;
              }

              goto unknown;

            case 'e':
              switch (name[2])
              {
                case 'l':
                  if (name[3] == 'e' &&
                      name[4] == 'c' &&
                      name[5] == 't')
                  {                               /* select     */
                    return -KEY_select;
                  }

                  goto unknown;

                case 'm':
                  switch (name[3])
                  {
                    case 'c':
                      if (name[4] == 't' &&
                          name[5] == 'l')
                      {                           /* semctl     */
                        return -KEY_semctl;
                      }

                      goto unknown;

                    case 'g':
                      if (name[4] == 'e' &&
                          name[5] == 't')
                      {                           /* semget     */
                        return -KEY_semget;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }

                default:
                  goto unknown;
              }

            case 'h':
              if (name[2] == 'm')
              {
                switch (name[3])
                {
                  case 'c':
                    if (name[4] == 't' &&
                        name[5] == 'l')
                    {                             /* shmctl     */
                      return -KEY_shmctl;
                    }

                    goto unknown;

                  case 'g':
                    if (name[4] == 'e' &&
                        name[5] == 't')
                    {                             /* shmget     */
                      return -KEY_shmget;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'k' &&
                  name[4] == 'e' &&
                  name[5] == 't')
              {                                   /* socket     */
                return -KEY_socket;
              }

              goto unknown;

            case 'p':
              if (name[2] == 'l' &&
                  name[3] == 'i' &&
                  name[4] == 'c' &&
                  name[5] == 'e')
              {                                   /* splice     */
                return -KEY_splice;
              }

              goto unknown;

            case 'u':
              if (name[2] == 'b' &&
                  name[3] == 's' &&
                  name[4] == 't' &&
                  name[5] == 'r')
              {                                   /* substr     */
                return -KEY_substr;
              }

              goto unknown;

            case 'y':
              if (name[2] == 's' &&
                  name[3] == 't' &&
                  name[4] == 'e' &&
                  name[5] == 'm')
              {                                   /* system     */
                return -KEY_system;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'u':
          if (name[1] == 'n')
          {
            switch (name[2])
            {
              case 'l':
                switch (name[3])
                {
                  case 'e':
                    if (name[4] == 's' &&
                        name[5] == 's')
                    {                             /* unless     */
                      return KEY_unless;
                    }

                    goto unknown;

                  case 'i':
                    if (name[4] == 'n' &&
                        name[5] == 'k')
                    {                             /* unlink     */
                      return -KEY_unlink;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }

              case 'p':
                if (name[3] == 'a' &&
                    name[4] == 'c' &&
                    name[5] == 'k')
                {                                 /* unpack     */
                  return -KEY_unpack;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'v':
          if (name[1] == 'a' &&
              name[2] == 'l' &&
              name[3] == 'u' &&
              name[4] == 'e' &&
              name[5] == 's')
          {                                       /* values     */
            return -KEY_values;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 7: /* 28 tokens of length 7 */
      switch (name[0])
      {
        case 'D':
          if (name[1] == 'E' &&
              name[2] == 'S' &&
              name[3] == 'T' &&
              name[4] == 'R' &&
              name[5] == 'O' &&
              name[6] == 'Y')
          {                                       /* DESTROY    */
            return KEY_DESTROY;
          }

          goto unknown;

        case '_':
          if (name[1] == '_' &&
              name[2] == 'E' &&
              name[3] == 'N' &&
              name[4] == 'D' &&
              name[5] == '_' &&
              name[6] == '_')
          {                                       /* __END__    */
            return KEY___END__;
          }

          goto unknown;

        case 'b':
          if (name[1] == 'i' &&
              name[2] == 'n' &&
              name[3] == 'm' &&
              name[4] == 'o' &&
              name[5] == 'd' &&
              name[6] == 'e')
          {                                       /* binmode    */
            return -KEY_binmode;
          }

          goto unknown;

        case 'c':
          if (name[1] == 'o' &&
              name[2] == 'n' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 'c' &&
              name[6] == 't')
          {                                       /* connect    */
            return -KEY_connect;
          }

          goto unknown;

        case 'd':
          switch (name[1])
          {
            case 'b':
              if (name[2] == 'm' &&
                  name[3] == 'o' &&
                  name[4] == 'p' &&
                  name[5] == 'e' &&
                  name[6] == 'n')
              {                                   /* dbmopen    */
                return -KEY_dbmopen;
              }

              goto unknown;

            case 'e':
              if (name[2] == 'f' &&
                  name[3] == 'i' &&
                  name[4] == 'n' &&
                  name[5] == 'e' &&
                  name[6] == 'd')
              {                                   /* defined    */
                return KEY_defined;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r' &&
              name[3] == 'e' &&
              name[4] == 'a' &&
              name[5] == 'c' &&
              name[6] == 'h')
          {                                       /* foreach    */
            return KEY_foreach;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'p')
          {
            switch (name[4])
            {
              case 'g':
                if (name[5] == 'r' &&
                    name[6] == 'p')
                {                                 /* getpgrp    */
                  return -KEY_getpgrp;
                }

                goto unknown;

              case 'p':
                if (name[5] == 'i' &&
                    name[6] == 'd')
                {                                 /* getppid    */
                  return -KEY_getppid;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'l':
          if (name[1] == 'c' &&
              name[2] == 'f' &&
              name[3] == 'i' &&
              name[4] == 'r' &&
              name[5] == 's' &&
              name[6] == 't')
          {                                       /* lcfirst    */
            return -KEY_lcfirst;
          }

          goto unknown;

        case 'o':
          if (name[1] == 'p' &&
              name[2] == 'e' &&
              name[3] == 'n' &&
              name[4] == 'd' &&
              name[5] == 'i' &&
              name[6] == 'r')
          {                                       /* opendir    */
            return -KEY_opendir;
          }

          goto unknown;

        case 'p':
          if (name[1] == 'a' &&
              name[2] == 'c' &&
              name[3] == 'k' &&
              name[4] == 'a' &&
              name[5] == 'g' &&
              name[6] == 'e')
          {                                       /* package    */
            return KEY_package;
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e')
          {
            switch (name[2])
            {
              case 'a':
                if (name[3] == 'd' &&
                    name[4] == 'd' &&
                    name[5] == 'i' &&
                    name[6] == 'r')
                {                                 /* readdir    */
                  return -KEY_readdir;
                }

                goto unknown;

              case 'q':
                if (name[3] == 'u' &&
                    name[4] == 'i' &&
                    name[5] == 'r' &&
                    name[6] == 'e')
                {                                 /* require    */
                  return KEY_require;
                }

                goto unknown;

              case 'v':
                if (name[3] == 'e' &&
                    name[4] == 'r' &&
                    name[5] == 's' &&
                    name[6] == 'e')
                {                                 /* reverse    */
                  return -KEY_reverse;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'e':
              switch (name[2])
              {
                case 'e':
                  if (name[3] == 'k' &&
                      name[4] == 'd' &&
                      name[5] == 'i' &&
                      name[6] == 'r')
                  {                               /* seekdir    */
                    return -KEY_seekdir;
                  }

                  goto unknown;

                case 't':
                  if (name[3] == 'p' &&
                      name[4] == 'g' &&
                      name[5] == 'r' &&
                      name[6] == 'p')
                  {                               /* setpgrp    */
                    return -KEY_setpgrp;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'h':
              if (name[2] == 'm' &&
                  name[3] == 'r' &&
                  name[4] == 'e' &&
                  name[5] == 'a' &&
                  name[6] == 'd')
              {                                   /* shmread    */
                return -KEY_shmread;
              }

              goto unknown;

            case 'p':
              if (name[2] == 'r' &&
                  name[3] == 'i' &&
                  name[4] == 'n' &&
                  name[5] == 't' &&
                  name[6] == 'f')
              {                                   /* sprintf    */
                return -KEY_sprintf;
              }

              goto unknown;

            case 'y':
              switch (name[2])
              {
                case 'm':
                  if (name[3] == 'l' &&
                      name[4] == 'i' &&
                      name[5] == 'n' &&
                      name[6] == 'k')
                  {                               /* symlink    */
                    return -KEY_symlink;
                  }

                  goto unknown;

                case 's':
                  switch (name[3])
                  {
                    case 'c':
                      if (name[4] == 'a' &&
                          name[5] == 'l' &&
                          name[6] == 'l')
                      {                           /* syscall    */
                        return -KEY_syscall;
                      }

                      goto unknown;

                    case 'o':
                      if (name[4] == 'p' &&
                          name[5] == 'e' &&
                          name[6] == 'n')
                      {                           /* sysopen    */
                        return -KEY_sysopen;
                      }

                      goto unknown;

                    case 'r':
                      if (name[4] == 'e' &&
                          name[5] == 'a' &&
                          name[6] == 'd')
                      {                           /* sysread    */
                        return -KEY_sysread;
                      }

                      goto unknown;

                    case 's':
                      if (name[4] == 'e' &&
                          name[5] == 'e' &&
                          name[6] == 'k')
                      {                           /* sysseek    */
                        return -KEY_sysseek;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }

                default:
                  goto unknown;
              }

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'e' &&
              name[2] == 'l' &&
              name[3] == 'l' &&
              name[4] == 'd' &&
              name[5] == 'i' &&
              name[6] == 'r')
          {                                       /* telldir    */
            return -KEY_telldir;
          }

          goto unknown;

        case 'u':
          switch (name[1])
          {
            case 'c':
              if (name[2] == 'f' &&
                  name[3] == 'i' &&
                  name[4] == 'r' &&
                  name[5] == 's' &&
                  name[6] == 't')
              {                                   /* ucfirst    */
                return -KEY_ucfirst;
              }

              goto unknown;

            case 'n':
              if (name[2] == 's' &&
                  name[3] == 'h' &&
                  name[4] == 'i' &&
                  name[5] == 'f' &&
                  name[6] == 't')
              {                                   /* unshift    */
                return -KEY_unshift;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'w':
          if (name[1] == 'a' &&
              name[2] == 'i' &&
              name[3] == 't' &&
              name[4] == 'p' &&
              name[5] == 'i' &&
              name[6] == 'd')
          {                                       /* waitpid    */
            return -KEY_waitpid;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 8: /* 26 tokens of length 8 */
      switch (name[0])
      {
        case 'A':
          if (name[1] == 'U' &&
              name[2] == 'T' &&
              name[3] == 'O' &&
              name[4] == 'L' &&
              name[5] == 'O' &&
              name[6] == 'A' &&
              name[7] == 'D')
          {                                       /* AUTOLOAD   */
            return KEY_AUTOLOAD;
          }

          goto unknown;

        case '_':
          if (name[1] == '_')
          {
            switch (name[2])
            {
              case 'D':
                if (name[3] == 'A' &&
                    name[4] == 'T' &&
                    name[5] == 'A' &&
                    name[6] == '_' &&
                    name[7] == '_')
                {                                 /* __DATA__   */
                  return KEY___DATA__;
                }

                goto unknown;

              case 'F':
                if (name[3] == 'I' &&
                    name[4] == 'L' &&
                    name[5] == 'E' &&
                    name[6] == '_' &&
                    name[7] == '_')
                {                                 /* __FILE__   */
                  return -KEY___FILE__;
                }

                goto unknown;

              case 'L':
                if (name[3] == 'I' &&
                    name[4] == 'N' &&
                    name[5] == 'E' &&
                    name[6] == '_' &&
                    name[7] == '_')
                {                                 /* __LINE__   */
                  return -KEY___LINE__;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'c':
          switch (name[1])
          {
            case 'l':
              if (name[2] == 'o' &&
                  name[3] == 's' &&
                  name[4] == 'e' &&
                  name[5] == 'd' &&
                  name[6] == 'i' &&
                  name[7] == 'r')
              {                                   /* closedir   */
                return -KEY_closedir;
              }

              goto unknown;

            case 'o':
              if (name[2] == 'n' &&
                  name[3] == 't' &&
                  name[4] == 'i' &&
                  name[5] == 'n' &&
                  name[6] == 'u' &&
                  name[7] == 'e')
              {                                   /* continue   */
                return -KEY_continue;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 'd':
          if (name[1] == 'b' &&
              name[2] == 'm' &&
              name[3] == 'c' &&
              name[4] == 'l' &&
              name[5] == 'o' &&
              name[6] == 's' &&
              name[7] == 'e')
          {                                       /* dbmclose   */
            return -KEY_dbmclose;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd')
          {
            switch (name[3])
            {
              case 'g':
                if (name[4] == 'r' &&
                    name[5] == 'e' &&
                    name[6] == 'n' &&
                    name[7] == 't')
                {                                 /* endgrent   */
                  return -KEY_endgrent;
                }

                goto unknown;

              case 'p':
                if (name[4] == 'w' &&
                    name[5] == 'e' &&
                    name[6] == 'n' &&
                    name[7] == 't')
                {                                 /* endpwent   */
                  return -KEY_endpwent;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'f':
          if (name[1] == 'o' &&
              name[2] == 'r' &&
              name[3] == 'm' &&
              name[4] == 'l' &&
              name[5] == 'i' &&
              name[6] == 'n' &&
              name[7] == 'e')
          {                                       /* formline   */
            return -KEY_formline;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't')
          {
            switch (name[3])
            {
              case 'g':
                if (name[4] == 'r')
                {
                  switch (name[5])
                  {
                    case 'e':
                      if (name[6] == 'n' &&
                          name[7] == 't')
                      {                           /* getgrent   */
                        return -KEY_getgrent;
                      }

                      goto unknown;

                    case 'g':
                      if (name[6] == 'i' &&
                          name[7] == 'd')
                      {                           /* getgrgid   */
                        return -KEY_getgrgid;
                      }

                      goto unknown;

                    case 'n':
                      if (name[6] == 'a' &&
                          name[7] == 'm')
                      {                           /* getgrnam   */
                        return -KEY_getgrnam;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }
                }

                goto unknown;

              case 'l':
                if (name[4] == 'o' &&
                    name[5] == 'g' &&
                    name[6] == 'i' &&
                    name[7] == 'n')
                {                                 /* getlogin   */
                  return -KEY_getlogin;
                }

                goto unknown;

              case 'p':
                if (name[4] == 'w')
                {
                  switch (name[5])
                  {
                    case 'e':
                      if (name[6] == 'n' &&
                          name[7] == 't')
                      {                           /* getpwent   */
                        return -KEY_getpwent;
                      }

                      goto unknown;

                    case 'n':
                      if (name[6] == 'a' &&
                          name[7] == 'm')
                      {                           /* getpwnam   */
                        return -KEY_getpwnam;
                      }

                      goto unknown;

                    case 'u':
                      if (name[6] == 'i' &&
                          name[7] == 'd')
                      {                           /* getpwuid   */
                        return -KEY_getpwuid;
                      }

                      goto unknown;

                    default:
                      goto unknown;
                  }
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e' &&
              name[2] == 'a' &&
              name[3] == 'd')
          {
            switch (name[4])
            {
              case 'l':
                if (name[5] == 'i' &&
                    name[6] == 'n')
                {
                  switch (name[7])
                  {
                    case 'e':
                      {                           /* readline   */
                        return -KEY_readline;
                      }

                    case 'k':
                      {                           /* readlink   */
                        return -KEY_readlink;
                      }

                    default:
                      goto unknown;
                  }
                }

                goto unknown;

              case 'p':
                if (name[5] == 'i' &&
                    name[6] == 'p' &&
                    name[7] == 'e')
                {                                 /* readpipe   */
                  return -KEY_readpipe;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 't')
              {
                switch (name[3])
                {
                  case 'g':
                    if (name[4] == 'r' &&
                        name[5] == 'e' &&
                        name[6] == 'n' &&
                        name[7] == 't')
                    {                             /* setgrent   */
                      return -KEY_setgrent;
                    }

                    goto unknown;

                  case 'p':
                    if (name[4] == 'w' &&
                        name[5] == 'e' &&
                        name[6] == 'n' &&
                        name[7] == 't')
                    {                             /* setpwent   */
                      return -KEY_setpwent;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            case 'h':
              switch (name[2])
              {
                case 'm':
                  if (name[3] == 'w' &&
                      name[4] == 'r' &&
                      name[5] == 'i' &&
                      name[6] == 't' &&
                      name[7] == 'e')
                  {                               /* shmwrite   */
                    return -KEY_shmwrite;
                  }

                  goto unknown;

                case 'u':
                  if (name[3] == 't' &&
                      name[4] == 'd' &&
                      name[5] == 'o' &&
                      name[6] == 'w' &&
                      name[7] == 'n')
                  {                               /* shutdown   */
                    return -KEY_shutdown;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }

            case 'y':
              if (name[2] == 's' &&
                  name[3] == 'w' &&
                  name[4] == 'r' &&
                  name[5] == 'i' &&
                  name[6] == 't' &&
                  name[7] == 'e')
              {                                   /* syswrite   */
                return -KEY_syswrite;
              }

              goto unknown;

            default:
              goto unknown;
          }

        case 't':
          if (name[1] == 'r' &&
              name[2] == 'u' &&
              name[3] == 'n' &&
              name[4] == 'c' &&
              name[5] == 'a' &&
              name[6] == 't' &&
              name[7] == 'e')
          {                                       /* truncate   */
            return -KEY_truncate;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 9: /* 8 tokens of length 9 */
      switch (name[0])
      {
        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 't' &&
              name[6] == 'e' &&
              name[7] == 'n' &&
              name[8] == 't')
          {                                       /* endnetent  */
            return -KEY_endnetent;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 't' &&
              name[6] == 'e' &&
              name[7] == 'n' &&
              name[8] == 't')
          {                                       /* getnetent  */
            return -KEY_getnetent;
          }

          goto unknown;

        case 'l':
          if (name[1] == 'o' &&
              name[2] == 'c' &&
              name[3] == 'a' &&
              name[4] == 'l' &&
              name[5] == 't' &&
              name[6] == 'i' &&
              name[7] == 'm' &&
              name[8] == 'e')
          {                                       /* localtime  */
            return -KEY_localtime;
          }

          goto unknown;

        case 'p':
          if (name[1] == 'r' &&
              name[2] == 'o' &&
              name[3] == 't' &&
              name[4] == 'o' &&
              name[5] == 't' &&
              name[6] == 'y' &&
              name[7] == 'p' &&
              name[8] == 'e')
          {                                       /* prototype  */
            return KEY_prototype;
          }

          goto unknown;

        case 'q':
          if (name[1] == 'u' &&
              name[2] == 'o' &&
              name[3] == 't' &&
              name[4] == 'e' &&
              name[5] == 'm' &&
              name[6] == 'e' &&
              name[7] == 't' &&
              name[8] == 'a')
          {                                       /* quotemeta  */
            return -KEY_quotemeta;
          }

          goto unknown;

        case 'r':
          if (name[1] == 'e' &&
              name[2] == 'w' &&
              name[3] == 'i' &&
              name[4] == 'n' &&
              name[5] == 'd' &&
              name[6] == 'd' &&
              name[7] == 'i' &&
              name[8] == 'r')
          {                                       /* rewinddir  */
            return -KEY_rewinddir;
          }

          goto unknown;

        case 's':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'n' &&
              name[4] == 'e' &&
              name[5] == 't' &&
              name[6] == 'e' &&
              name[7] == 'n' &&
              name[8] == 't')
          {                                       /* setnetent  */
            return -KEY_setnetent;
          }

          goto unknown;

        case 'w':
          if (name[1] == 'a' &&
              name[2] == 'n' &&
              name[3] == 't' &&
              name[4] == 'a' &&
              name[5] == 'r' &&
              name[6] == 'r' &&
              name[7] == 'a' &&
              name[8] == 'y')
          {                                       /* wantarray  */
            return -KEY_wantarray;
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 10: /* 9 tokens of length 10 */
      switch (name[0])
      {
        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd')
          {
            switch (name[3])
            {
              case 'h':
                if (name[4] == 'o' &&
                    name[5] == 's' &&
                    name[6] == 't' &&
                    name[7] == 'e' &&
                    name[8] == 'n' &&
                    name[9] == 't')
                {                                 /* endhostent */
                  return -KEY_endhostent;
                }

                goto unknown;

              case 's':
                if (name[4] == 'e' &&
                    name[5] == 'r' &&
                    name[6] == 'v' &&
                    name[7] == 'e' &&
                    name[8] == 'n' &&
                    name[9] == 't')
                {                                 /* endservent */
                  return -KEY_endservent;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't')
          {
            switch (name[3])
            {
              case 'h':
                if (name[4] == 'o' &&
                    name[5] == 's' &&
                    name[6] == 't' &&
                    name[7] == 'e' &&
                    name[8] == 'n' &&
                    name[9] == 't')
                {                                 /* gethostent */
                  return -KEY_gethostent;
                }

                goto unknown;

              case 's':
                switch (name[4])
                {
                  case 'e':
                    if (name[5] == 'r' &&
                        name[6] == 'v' &&
                        name[7] == 'e' &&
                        name[8] == 'n' &&
                        name[9] == 't')
                    {                             /* getservent */
                      return -KEY_getservent;
                    }

                    goto unknown;

                  case 'o':
                    if (name[5] == 'c' &&
                        name[6] == 'k' &&
                        name[7] == 'o' &&
                        name[8] == 'p' &&
                        name[9] == 't')
                    {                             /* getsockopt */
                      return -KEY_getsockopt;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          switch (name[1])
          {
            case 'e':
              if (name[2] == 't')
              {
                switch (name[3])
                {
                  case 'h':
                    if (name[4] == 'o' &&
                        name[5] == 's' &&
                        name[6] == 't' &&
                        name[7] == 'e' &&
                        name[8] == 'n' &&
                        name[9] == 't')
                    {                             /* sethostent */
                      return -KEY_sethostent;
                    }

                    goto unknown;

                  case 's':
                    switch (name[4])
                    {
                      case 'e':
                        if (name[5] == 'r' &&
                            name[6] == 'v' &&
                            name[7] == 'e' &&
                            name[8] == 'n' &&
                            name[9] == 't')
                        {                         /* setservent */
                          return -KEY_setservent;
                        }

                        goto unknown;

                      case 'o':
                        if (name[5] == 'c' &&
                            name[6] == 'k' &&
                            name[7] == 'o' &&
                            name[8] == 'p' &&
                            name[9] == 't')
                        {                         /* setsockopt */
                          return -KEY_setsockopt;
                        }

                        goto unknown;

                      default:
                        goto unknown;
                    }

                  default:
                    goto unknown;
                }
              }

              goto unknown;

            case 'o':
              if (name[2] == 'c' &&
                  name[3] == 'k' &&
                  name[4] == 'e' &&
                  name[5] == 't' &&
                  name[6] == 'p' &&
                  name[7] == 'a' &&
                  name[8] == 'i' &&
                  name[9] == 'r')
              {                                   /* socketpair */
                return -KEY_socketpair;
              }

              goto unknown;

            default:
              goto unknown;
          }

        default:
          goto unknown;
      }

    case 11: /* 8 tokens of length 11 */
      switch (name[0])
      {
        case '_':
          if (name[1] == '_' &&
              name[2] == 'P' &&
              name[3] == 'A' &&
              name[4] == 'C' &&
              name[5] == 'K' &&
              name[6] == 'A' &&
              name[7] == 'G' &&
              name[8] == 'E' &&
              name[9] == '_' &&
              name[10] == '_')
          {                                       /* __PACKAGE__ */
            return -KEY___PACKAGE__;
          }

          goto unknown;

        case 'e':
          if (name[1] == 'n' &&
              name[2] == 'd' &&
              name[3] == 'p' &&
              name[4] == 'r' &&
              name[5] == 'o' &&
              name[6] == 't' &&
              name[7] == 'o' &&
              name[8] == 'e' &&
              name[9] == 'n' &&
              name[10] == 't')
          {                                       /* endprotoent */
            return -KEY_endprotoent;
          }

          goto unknown;

        case 'g':
          if (name[1] == 'e' &&
              name[2] == 't')
          {
            switch (name[3])
            {
              case 'p':
                switch (name[4])
                {
                  case 'e':
                    if (name[5] == 'e' &&
                        name[6] == 'r' &&
                        name[7] == 'n' &&
                        name[8] == 'a' &&
                        name[9] == 'm' &&
                        name[10] == 'e')
                    {                             /* getpeername */
                      return -KEY_getpeername;
                    }

                    goto unknown;

                  case 'r':
                    switch (name[5])
                    {
                      case 'i':
                        if (name[6] == 'o' &&
                            name[7] == 'r' &&
                            name[8] == 'i' &&
                            name[9] == 't' &&
                            name[10] == 'y')
                        {                         /* getpriority */
                          return -KEY_getpriority;
                        }

                        goto unknown;

                      case 'o':
                        if (name[6] == 't' &&
                            name[7] == 'o' &&
                            name[8] == 'e' &&
                            name[9] == 'n' &&
                            name[10] == 't')
                        {                         /* getprotoent */
                          return -KEY_getprotoent;
                        }

                        goto unknown;

                      default:
                        goto unknown;
                    }

                  default:
                    goto unknown;
                }

              case 's':
                if (name[4] == 'o' &&
                    name[5] == 'c' &&
                    name[6] == 'k' &&
                    name[7] == 'n' &&
                    name[8] == 'a' &&
                    name[9] == 'm' &&
                    name[10] == 'e')
                {                                 /* getsockname */
                  return -KEY_getsockname;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        case 's':
          if (name[1] == 'e' &&
              name[2] == 't' &&
              name[3] == 'p' &&
              name[4] == 'r')
          {
            switch (name[5])
            {
              case 'i':
                if (name[6] == 'o' &&
                    name[7] == 'r' &&
                    name[8] == 'i' &&
                    name[9] == 't' &&
                    name[10] == 'y')
                {                                 /* setpriority */
                  return -KEY_setpriority;
                }

                goto unknown;

              case 'o':
                if (name[6] == 't' &&
                    name[7] == 'o' &&
                    name[8] == 'e' &&
                    name[9] == 'n' &&
                    name[10] == 't')
                {                                 /* setprotoent */
                  return -KEY_setprotoent;
                }

                goto unknown;

              default:
                goto unknown;
            }
          }

          goto unknown;

        default:
          goto unknown;
      }

    case 12: /* 2 tokens of length 12 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't' &&
          name[3] == 'n' &&
          name[4] == 'e' &&
          name[5] == 't' &&
          name[6] == 'b' &&
          name[7] == 'y')
      {
        switch (name[8])
        {
          case 'a':
            if (name[9] == 'd' &&
                name[10] == 'd' &&
                name[11] == 'r')
            {                                     /* getnetbyaddr */
              return -KEY_getnetbyaddr;
            }

            goto unknown;

          case 'n':
            if (name[9] == 'a' &&
                name[10] == 'm' &&
                name[11] == 'e')
            {                                     /* getnetbyname */
              return -KEY_getnetbyname;
            }

            goto unknown;

          default:
            goto unknown;
        }
      }

      goto unknown;

    case 13: /* 4 tokens of length 13 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't')
      {
        switch (name[3])
        {
          case 'h':
            if (name[4] == 'o' &&
                name[5] == 's' &&
                name[6] == 't' &&
                name[7] == 'b' &&
                name[8] == 'y')
            {
              switch (name[9])
              {
                case 'a':
                  if (name[10] == 'd' &&
                      name[11] == 'd' &&
                      name[12] == 'r')
                  {                               /* gethostbyaddr */
                    return -KEY_gethostbyaddr;
                  }

                  goto unknown;

                case 'n':
                  if (name[10] == 'a' &&
                      name[11] == 'm' &&
                      name[12] == 'e')
                  {                               /* gethostbyname */
                    return -KEY_gethostbyname;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }
            }

            goto unknown;

          case 's':
            if (name[4] == 'e' &&
                name[5] == 'r' &&
                name[6] == 'v' &&
                name[7] == 'b' &&
                name[8] == 'y')
            {
              switch (name[9])
              {
                case 'n':
                  if (name[10] == 'a' &&
                      name[11] == 'm' &&
                      name[12] == 'e')
                  {                               /* getservbyname */
                    return -KEY_getservbyname;
                  }

                  goto unknown;

                case 'p':
                  if (name[10] == 'o' &&
                      name[11] == 'r' &&
                      name[12] == 't')
                  {                               /* getservbyport */
                    return -KEY_getservbyport;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }
            }

            goto unknown;

          default:
            goto unknown;
        }
      }

      goto unknown;

    case 14: /* 1 tokens of length 14 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't' &&
          name[3] == 'p' &&
          name[4] == 'r' &&
          name[5] == 'o' &&
          name[6] == 't' &&
          name[7] == 'o' &&
          name[8] == 'b' &&
          name[9] == 'y' &&
          name[10] == 'n' &&
          name[11] == 'a' &&
          name[12] == 'm' &&
          name[13] == 'e')
      {                                           /* getprotobyname */
        return -KEY_getprotobyname;
      }

      goto unknown;

    case 16: /* 1 tokens of length 16 */
      if (name[0] == 'g' &&
          name[1] == 'e' &&
          name[2] == 't' &&
          name[3] == 'p' &&
          name[4] == 'r' &&
          name[5] == 'o' &&
          name[6] == 't' &&
          name[7] == 'o' &&
          name[8] == 'b' &&
          name[9] == 'y' &&
          name[10] == 'n' &&
          name[11] == 'u' &&
          name[12] == 'm' &&
          name[13] == 'b' &&
          name[14] == 'e' &&
          name[15] == 'r')
      {                                           /* getprotobynumber */
        return -KEY_getprotobynumber;
      }

      goto unknown;

    default:
      goto unknown;
  }

unknown:
  return 0;
}

STATIC void
S_checkcomma(pTHX_ register char *s, const char *name, const char *what)
d6008 1
a6008 1
    const char *w;
d6040 2
a6041 2
	    *s = '\0'; /* XXX If we didn't do this, we could const a lot of toke.c */
	    kw = keyword((char *)w, s - w) || get_cv(w, FALSE) != 0;
d6056 1
a6056 1
S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, SV *sv, SV *pv,
d6060 1
a6060 1
    HV * const table = GvHV(PL_hintgv);		 /* ^H */
d6064 1
a6064 1
    const char *why1 = "", *why2 = "", *why3 = "";
d6086 1
a6086 1
	yyerror((char *)SvPVX_const(msg));
d6124 1
d6126 1
a6126 1
	yyerror((char *)SvPV_nolen_const(ERRSV)); /* Duplicates the message inside eval */
d6155 1
a6155 1
    register char * const e = d + destlen - 3;  /* two-character token, ending NUL */
d6189 1
a6189 1
S_scan_ident(pTHX_ register char *s, register const char *send, char *dest, STRLEN destlen, I32 ck_uni)
d6193 1
a6193 1
    char *bracket = Nullch;
d6244 1
a6244 1
	(isALNUM_lazy_if(s+1,UTF) || s[1] == '$' || s[1] == '{' || strnEQ(s+1,"::",2)) )
d6264 1
a6264 1
		const char ch = *s++;
d6368 1
a6368 1
    char *s = scan_str(start,FALSE,FALSE);
d6370 3
a6372 6
    if (!s) {
	char * const delimiter = skipspace(start);
	Perl_croak(aTHX_ *delimiter == '?'
		   ? "Search pattern not terminated or ternary operator parsed as search pattern"
		   : "Search pattern not terminated" );
    }
d6386 2
a6387 2
    if ((pm->op_pmflags & PMf_CONTINUE) && !(pm->op_pmflags & PMf_GLOBAL)
	    && ckWARN(WARN_REGEXP))
d6441 1
a6441 1
    if ((pm->op_pmflags & PMf_CONTINUE) && ckWARN(WARN_REGEXP))
d6497 2
a6498 3
    while (1) {
	switch (*s) {
	case 'c':
d6500 1
a6500 2
	    break;
	case 'd':
d6502 1
a6502 2
	    break;
	case 's':
a6503 4
	    break;
	default:
	    goto no_more;
	}
a6505 1
  no_more:
d6507 1
a6507 1
    Newx(tbl, complement&&!del?258:256, short);
a6525 2
    const char newline[] = "\n";
    const char *found_newline;
d6529 1
a6529 1
    const int outer = (PL_rsfp && !(PL_lex_inwhat == OP_SCALAR));
d6537 1
a6537 1
    if (*peek == '`' || *peek == '\'' || *peek =='"') {
d6565 1
a6565 1
	char * const olds = s;
d6582 1
a6582 1
	SvCUR_set(PL_linestr, PL_bufend - SvPVX_const(PL_linestr));
d6586 5
a6590 7
    if ( outer || !(found_newline = ninstr(s,PL_bufend,newline,newline+1)) ) {
        herewas = newSVpvn(s,PL_bufend-s);
    }
    else {
        s--;
        herewas = newSVpvn(s,found_newline-s);
    }
d6597 1
a6597 1
	SvIV_set(tmpstr, -1);
d6601 1
a6601 1
	SvIV_set(tmpstr, '\\');
d6611 1
a6611 1
	char * const olds = s - SvCUR(herewas);
d6629 1
a6629 1
	Copy(SvPVX_const(herewas),bufptr,SvCUR(herewas) + 1,char);
d6673 1
a6673 1
		SvCUR_set(PL_linestr, PL_bufend - SvPVX_const(PL_linestr));
d6687 1
a6687 1
            SvIV_set(sv, 0);
d6691 1
a6691 1
	    STRLEN off = PL_bufend - 1 - SvPVX_const(PL_linestr);
d6706 2
a6707 1
	SvPV_shrink_to_cur(tmpstr);
d6711 1
a6711 1
	if (UTF && is_utf8_string((U8*)SvPVX_const(tmpstr), SvCUR(tmpstr)))
d6742 1
a6742 1
    const char *e;
d6751 1
a6751 1
    s = delimcpy(d, (char *)e, s + 1, end, '>', &len);	/* extract until > */
d6823 1
a6823 1
			    newSVpv(HvNAME_get(PAD_COMPNAME_OURSTASH(tmp)),0));
d6935 1
a6935 1
    U8 termstr[UTF8_MAXBYTES];		/* terminating string */
d6973 1
a6973 1
    SvIV_set(sv, termcode);
d6985 2
a6986 2
		int offset = s - SvPVX_const(PL_linestr);
		const bool found = sv_cat_decode(sv, PL_encoding, PL_linestr,
d6988 1
a6988 1
		const char *ns = SvPVX_const(PL_linestr) + offset;
d7000 2
a7001 2
			const char *t;
			for (t = svlast-2; t >= SvPVX_const(sv) && *t == '\\';)
d7016 1
a7016 2
			const char *t;
			char *w;
d7019 1
a7019 1
			for (t = w = last; t < svlast; w++, t++) {
d7036 1
a7036 1
			    SvCUR_set(sv, w - SvPVX_const(sv));
d7114 1
a7114 1
	SvCUR_set(sv, to - SvPVX_const(sv));
d7124 1
a7124 1
	if (to - SvPVX_const(sv) >= 2) {
d7130 1
a7130 1
		SvCUR_set(sv, to - SvPVX_const(sv));
d7135 1
a7135 1
	else if (to - SvPVX_const(sv) == 1 && to[-1] == '\r')
d7159 1
a7159 1
            SvIV_set(sv, 0);
d7183 1
a7183 1
	SvPV_renew(sv, SvLEN(sv));
d7222 1
a7222 1
    register const char *s = start;	/* current position in buffer */
d7228 2
a7229 2
    const char *lastub = 0;		/* position of last underbar */
    static char const number_too_long[] = "Number too long";
d7256 11
a7266 12
	    static const NV nvshift[5] = { 1.0, 2.0, 4.0, 8.0, 16.0 };
	    static const char* const bases[5] =
	      { "", "binary", "", "octal", "hexadecimal" };
	    static const char* const Bases[5] =
	      { "", "Binary", "", "Octal", "Hexadecimal" };
	    static const char* const maxima[5] =
	      { "",
		"0b11111111111111111111111111111111",
		"",
		"037777777777",
		"0xffffffff" };
	    const char *base, *Base, *max;
d7312 1
a7312 1
		    if (lastub && s == lastub + 1 && ckWARN(WARN_SYNTAX))
d7392 1
a7392 1
		if (n > 4294967295.0 && ckWARN(WARN_PORTABLE))
d7400 1
a7400 1
		if (u > 0xffffffff && ckWARN(WARN_PORTABLE))
d7408 1
a7408 1
		sv = new_constant(start, s - start, "integer",
d7432 1
a7432 1
		if (lastub && s == lastub + 1 && ckWARN(WARN_SYNTAX))
d7474 1
a7474 1
		   if (lastub && s == lastub + 1 && ckWARN(WARN_SYNTAX))
d7496 1
a7496 1
	if ((*s == 'e' || *s == 'E') && strchr("+-0123456789_", s[1])) {
d7531 3
a7533 3
		   if (((lastub && s == lastub + 1) ||
			(!isDIGIT(s[1]) && s[1] != '_'))
	   	    && ckWARN(WARN_SYNTAX))
d7585 1
a7585 1
		s = scan_vstring((char *)s,sv);
d7599 1
a7599 1
    return (char *)s;
d7613 1
d7625 1
a7625 1
	    eol = (char *) memchr(s,'\n',PL_bufend-s);
d7647 1
a7647 1
		    SvCUR_set(stuff, SvCUR(stuff) - 1);
d7654 1
a7654 1
	s = (char*)eol;
d7678 1
a7678 1
	    if (UTF && is_utf8_string((U8*)SvPVX_const(stuff), SvCUR(stuff)))
d7709 1
a7709 1
    const I32 oldsavestack_ix = PL_savestack_ix;
d7751 2
a7752 2
    const char *where = NULL;
    const char *context = NULL;
d7758 2
a7759 3
    else if (PL_oldoldbufptr && PL_bufptr > PL_oldoldbufptr &&
      PL_bufptr - PL_oldoldbufptr < 200 && PL_oldoldbufptr != PL_oldbufptr &&
      PL_oldbufptr != PL_bufptr) {
d7774 2
a7775 2
    else if (PL_oldbufptr && PL_bufptr > PL_oldbufptr &&
      PL_bufptr - PL_oldbufptr < 200 && PL_oldbufptr != PL_bufptr) {
d7814 1
a7814 1
	where = SvPVX_const(where_sv);
d7852 2
a7853 1
    const STRLEN slen = SvCUR(PL_linestr);
d7869 1
a7869 1
		Newx(news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
d7895 1
a7895 1
		Newx(news, (PL_bufend - (char*)s) * 3 / 2 + 1, U8);
d7965 2
a7966 2
    const STRLEN old = SvCUR(sv);
    const I32 count = FILTER_READ(idx+1, sv, maxlen);
d7969 1
a7969 1
			  utf16_textfilter, idx, maxlen, (int) count));
d7973 3
a7975 3
	Newx(tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	Copy(SvPVX_const(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX_const(sv) + old, tmps + old,
d7986 2
a7987 2
    const STRLEN old = SvCUR(sv);
    const I32 count = FILTER_READ(idx+1, sv, maxlen);
d7990 1
a7990 1
			  utf16rev_textfilter, idx, maxlen, (int) count));
d7994 3
a7996 3
	Newx(tmps, SvCUR(sv) * 3 / 2 + 1, U8);
	Copy(SvPVX_const(sv), tmps, old, char);
	utf16_to_utf8((U8*)SvPVX_const(sv) + old, tmps + old,
d8022 2
a8023 2
    const char *pos = s;
    const char *start = s;
d8029 1
a8029 1
	const char *next = pos;
d8035 1
a8035 1
	    return (char *)pos;
d8041 1
a8041 1
	U8 tmpbuf[UTF8_MAXBYTES+1];
d8052 1
a8052 1
		const char *end = pos;
d8076 1
a8076 1
		 s = (char *)++pos;
d8078 1
a8078 1
		 s = (char *)pos;
d8088 1
a8088 1
    return (char *)s;
a8090 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d26 2
a27 2
#define new_constant(a,b,c,d,e,f,g)	\
	S_new_constant(aTHX_ a,b,STR_WITH_LEN(c),d,e,f, g)
d29 6
a34 73
#define pl_yylval	(PL_parser->yylval)

/* YYINITDEPTH -- initial size of the parser's stacks.  */
#define YYINITDEPTH 200

/* XXX temporary backwards compatibility */
#define PL_lex_brackets		(PL_parser->lex_brackets)
#define PL_lex_brackstack	(PL_parser->lex_brackstack)
#define PL_lex_casemods		(PL_parser->lex_casemods)
#define PL_lex_casestack        (PL_parser->lex_casestack)
#define PL_lex_defer		(PL_parser->lex_defer)
#define PL_lex_dojoin		(PL_parser->lex_dojoin)
#define PL_lex_expect		(PL_parser->lex_expect)
#define PL_lex_formbrack        (PL_parser->lex_formbrack)
#define PL_lex_inpat		(PL_parser->lex_inpat)
#define PL_lex_inwhat		(PL_parser->lex_inwhat)
#define PL_lex_op		(PL_parser->lex_op)
#define PL_lex_repl		(PL_parser->lex_repl)
#define PL_lex_starts		(PL_parser->lex_starts)
#define PL_lex_stuff		(PL_parser->lex_stuff)
#define PL_multi_start		(PL_parser->multi_start)
#define PL_multi_open		(PL_parser->multi_open)
#define PL_multi_close		(PL_parser->multi_close)
#define PL_pending_ident        (PL_parser->pending_ident)
#define PL_preambled		(PL_parser->preambled)
#define PL_sublex_info		(PL_parser->sublex_info)
#define PL_linestr		(PL_parser->linestr)
#define PL_expect		(PL_parser->expect)
#define PL_copline		(PL_parser->copline)
#define PL_bufptr		(PL_parser->bufptr)
#define PL_oldbufptr		(PL_parser->oldbufptr)
#define PL_oldoldbufptr		(PL_parser->oldoldbufptr)
#define PL_linestart		(PL_parser->linestart)
#define PL_bufend		(PL_parser->bufend)
#define PL_last_uni		(PL_parser->last_uni)
#define PL_last_lop		(PL_parser->last_lop)
#define PL_last_lop_op		(PL_parser->last_lop_op)
#define PL_lex_state		(PL_parser->lex_state)
#define PL_rsfp			(PL_parser->rsfp)
#define PL_rsfp_filters		(PL_parser->rsfp_filters)
#define PL_in_my		(PL_parser->in_my)
#define PL_in_my_stash		(PL_parser->in_my_stash)
#define PL_tokenbuf		(PL_parser->tokenbuf)
#define PL_multi_end		(PL_parser->multi_end)
#define PL_error_count		(PL_parser->error_count)

#ifdef PERL_MAD
#  define PL_endwhite		(PL_parser->endwhite)
#  define PL_faketokens		(PL_parser->faketokens)
#  define PL_lasttoke		(PL_parser->lasttoke)
#  define PL_nextwhite		(PL_parser->nextwhite)
#  define PL_realtokenstart	(PL_parser->realtokenstart)
#  define PL_skipwhite		(PL_parser->skipwhite)
#  define PL_thisclose		(PL_parser->thisclose)
#  define PL_thismad		(PL_parser->thismad)
#  define PL_thisopen		(PL_parser->thisopen)
#  define PL_thisstuff		(PL_parser->thisstuff)
#  define PL_thistoken		(PL_parser->thistoken)
#  define PL_thiswhite		(PL_parser->thiswhite)
#  define PL_thiswhite		(PL_parser->thiswhite)
#  define PL_nexttoke		(PL_parser->nexttoke)
#  define PL_curforce		(PL_parser->curforce)
#else
#  define PL_nexttoke		(PL_parser->nexttoke)
#  define PL_nexttype		(PL_parser->nexttype)
#  define PL_nextval		(PL_parser->nextval)
#endif

static int
S_pending_ident(pTHX);

static const char ident_too_long[] = "Identifier too long";
static const char commaless_variable_list[] = "comma-less variable list";
d36 1
a41 8
#ifdef PERL_MAD
#  define CURMAD(slot,sv) if (PL_madskills) { curmad(slot,sv); sv = 0; }
#  define NEXTVAL_NEXTTOKE PL_nexttoke[PL_curforce].next_val
#else
#  define CURMAD(slot,sv)
#  define NEXTVAL_NEXTTOKE PL_nextval[PL_nexttoke]
#endif

d106 16
a130 12
#ifdef PERL_MAD
#  define SKIPSPACE0(s) skipspace0(s)
#  define SKIPSPACE1(s) skipspace1(s)
#  define SKIPSPACE2(s,tsv) skipspace2(s,&tsv)
#  define PEEKSPACE(s) skipspace2(s,0)
#else
#  define SKIPSPACE0(s) skipspace(s)
#  define SKIPSPACE1(s) skipspace(s)
#  define SKIPSPACE2(s,tsv) skipspace(s)
#  define PEEKSPACE(s) skipspace(s)
#endif

d160 1
a160 1
#   define REPORT(retval) tokereport((I32)retval)
d172 13
a184 13
#define LOOPX(f) return (pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)LOOPEX))
#define FTST(f)  return (pl_yylval.ival=f, PL_expect=XTERMORDORDOR, PL_bufptr=s, REPORT((int)UNIOP))
#define FUN0(f)  return (pl_yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC0))
#define FUN1(f)  return (pl_yylval.ival=f, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC1))
#define BOop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITOROP)))
#define BAop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)BITANDOP)))
#define SHop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)SHIFTOP)))
#define PWop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)POWOP)))
#define PMop(f)  return(pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MATCHOP))
#define Aop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)ADDOP)))
#define Mop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)MULOP)))
#define Eop(f)   return (pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)EQOP))
#define Rop(f)   return (pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, REPORT((int)RELOP))
a187 2
 * The UNIDOR macro is for unary functions that can be followed by the //
 * operator (such as C<shift // 0>).
d189 3
a191 3
#define UNI2(f,x) { \
	pl_yylval.ival = f; \
	PL_expect = x; \
d197 1
a197 1
	s = PEEKSPACE(s); \
a199 2
#define UNI(f)    UNI2(f,XTERM)
#define UNIDOR(f) UNI2(f,XTERMORDORDOR)
d202 1
a202 1
	pl_yylval.ival = f; \
d207 1
a207 1
	s = PEEKSPACE(s); \
d212 1
a212 1
#define OLDLOP(f) return(pl_yylval.ival=f,PL_expect = XTERM,PL_bufptr = s,(int)LSTOP)
d216 1
a216 1
/* how to interpret the pl_yylval associated with the token */
d220 1
a220 1
    TOKENTYPE_OPNUM, /* pl_yylval.ival contains an opcode number */
d226 2
a227 5
static struct debug_tokens {
    const int token;
    enum token_type type;
    const char *name;
} const debug_tokens[] =
a238 1
    { DEFAULT,		TOKENTYPE_NONE,		"DEFAULT" },
a240 2
    { DORDOR,		TOKENTYPE_NONE,		"DORDOR" },
    { DOROP,		TOKENTYPE_OPNUM,	"DOROP" },
a251 1
    { GIVEN,		TOKENTYPE_IVAL,		"GIVEN" },
a286 1
    { WHEN,		TOKENTYPE_IVAL,		"WHEN" },
d289 1
a289 1
    { 0,		TOKENTYPE_NONE,		NULL }
d292 1
a292 1
/* dump the returned token in rv, plus any optional arg in pl_yylval */
d295 1
a295 1
S_tokereport(pTHX_ I32 rv)
a296 1
    dVAR;
d298 1
a298 1
	const char *name = NULL;
d301 1
a301 1
	SV* const report = newSVpvs("<== ");
d311 1
a311 1
	    Perl_sv_catpv(aTHX_ report, name);
d315 1
a315 1
	    sv_catpvs(report, "EOF");
d323 1
a323 1
	    Perl_sv_catpvf(aTHX_ report, "(ival=%"IVdf")", (IV)pl_yylval.ival);
d327 1
a327 1
				    PL_op_name[pl_yylval.ival]);
d330 1
a330 1
	    Perl_sv_catpvf(aTHX_ report, "(pval=\"%s\")", pl_yylval.pval);
d333 1
a333 1
	    if (pl_yylval.opval) {
d335 2
a336 2
				    PL_op_name[pl_yylval.opval->op_type]);
		if (pl_yylval.opval->op_type == OP_CONST) {
d338 1
a338 1
			SvPEEK(cSVOPx_sv(pl_yylval.opval)));
d343 1
a343 1
		sv_catpvs(report, "(opval=null)");
d357 3
a359 2
    SV* const tmp = newSVpvs("");
    PerlIO_printf(Perl_debug_log, fmt, pv_display(tmp, s, strlen(s), 0, 60));
d368 2
a369 2
 * This subroutine detects &&=, ||=, and //= and turns an ANDAND, OROR or DORDOR
 * into an OP_ANDASSIGN, OP_ORASSIGN, or OP_DORASSIGN
a374 1
    dVAR;
d378 1
a378 1
	    pl_yylval.ival = OP_ANDASSIGN;
d380 1
a380 3
	    pl_yylval.ival = OP_ORASSIGN;
	else if (toketype == DORDOR)
	    pl_yylval.ival = OP_DORASSIGN;
a401 1
    dVAR;
d416 1
a416 2
	    for (t = PL_oldoldbufptr; (isALNUM_lazy_if(t,UTF) || *t == ':'); t++)
		NOOP;
d434 1
a434 1
 * If it's called with NULL then it cauterizes the line buffer.
a442 1
    dVAR;
a470 22
#define FEATURE_IS_ENABLED(name)				        \
	((0 != (PL_hints & HINT_LOCALIZE_HH))				\
	    && S_feature_is_enabled(aTHX_ STR_WITH_LEN(name)))
/* The longest string we pass in.  */
#define MAX_FEATURE_LEN (sizeof("switch")-1)

/*
 * S_feature_is_enabled
 * Check whether the named feature is enabled.
 */
STATIC bool
S_feature_is_enabled(pTHX_ const char *name, STRLEN namelen)
{
    dVAR;
    HV * const hinthv = GvHV(PL_hintgv);
    char he_name[8 + MAX_FEATURE_LEN] = "feature_";
    assert(namelen <= MAX_FEATURE_LEN);
    memcpy(&he_name[8], name, namelen);

    return (hinthv && hv_exists(hinthv, he_name, 8 + namelen));
}

d476 1
a476 1
Perl_deprecate(pTHX_ const char *s)
d483 1
a483 1
Perl_deprecate_old(pTHX_ const char *s)
d499 11
a546 2


d549 2
a550 10
 *
 * Create a parser object and initialise its parser and lexer fields
 *
 * rsfp       is the opened file handle to read from (if any),
 *
 * line       holds any initial content already read from the file (or in
 *            the case of no file, such as an eval, the whole contents);
 *
 * new_filter indicates that this is a new file and it shouldn't inherit
 *            the filters from the current parser (ie require).
d554 1
a554 1
Perl_lex_start(pTHX_ SV *line, PerlIO *rsfp, bool new_filter)
d556 1
a556 2
    dVAR;
    const char *s = NULL;
a557 1
    yy_parser *parser, *oparser;
d559 64
a622 82
    /* create and initialise a parser */

    Newxz(parser, 1, yy_parser);
    parser->old_parser = oparser = PL_parser;
    PL_parser = parser;

    Newx(parser->stack, YYINITDEPTH, yy_stack_frame);
    parser->ps = parser->stack;
    parser->stack_size = YYINITDEPTH;

    parser->stack->state = 0;
    parser->yyerrstatus = 0;
    parser->yychar = YYEMPTY;		/* Cause a token to be read.  */

    /* on scope exit, free this parser and restore any outer one */
    SAVEPARSER(parser);
    parser->saved_curcop = PL_curcop;

    /* initialise lexer state */

#ifdef PERL_MAD
    parser->curforce = -1;
#else
    parser->nexttoke = 0;
#endif
    parser->copline = NOLINE;
    parser->lex_state = LEX_NORMAL;
    parser->expect = XSTATE;
    parser->rsfp = rsfp;
    parser->rsfp_filters = (new_filter || !oparser) ? newAV()
		: (AV*)SvREFCNT_inc(oparser->rsfp_filters);

    Newx(parser->lex_brackstack, 120, char);
    Newx(parser->lex_casestack, 12, char);
    *parser->lex_casestack = '\0';

    if (line) {
	s = SvPV_const(line, len);
    } else {
	len = 0;
    }

    if (!len) {
	parser->linestr = newSVpvs("\n;");
    } else if (SvREADONLY(line) || s[len-1] != ';') {
	parser->linestr = newSVsv(line);
	if (s[len-1] != ';')
	    sv_catpvs(parser->linestr, "\n;");
    } else {
	SvTEMP_off(line);
	SvREFCNT_inc_simple_void_NN(line);
	parser->linestr = line;
    }
    parser->oldoldbufptr =
	parser->oldbufptr =
	parser->bufptr =
	parser->linestart = SvPVX(parser->linestr);
    parser->bufend = parser->bufptr + SvCUR(parser->linestr);
    parser->last_lop = parser->last_uni = NULL;
}


/* delete a parser object */

void
Perl_parser_free(pTHX_  const yy_parser *parser)
{
    PL_curcop = parser->saved_curcop;
    SvREFCNT_dec(parser->linestr);

    if (parser->rsfp == PerlIO_stdin())
	PerlIO_clearerr(parser->rsfp);
    else if (parser->rsfp && parser->old_parser
			  && parser->rsfp != parser->old_parser->rsfp)
	PerlIO_close(parser->rsfp);
    SvREFCNT_dec(parser->rsfp_filters);

    Safefree(parser->stack);
    Safefree(parser->lex_brackstack);
    Safefree(parser->lex_casestack);
    PL_parser = parser->old_parser;
    Safefree(parser);
a624 1

a633 1
    dVAR;
d648 1
a648 1
S_incline(pTHX_ const char *s)
d650 4
a653 4
    dVAR;
    const char *t;
    const char *n;
    const char *e;
d658 1
a658 2
    while (SPACE_OR_TAB(*s))
	s++;
d667 1
a667 2
    while (SPACE_OR_TAB(*s))
	s++;
a669 1

d680 1
a680 3
	t = s;
	while (!isSPACE(*t))
	    t++;
d688 2
a690 1
	const STRLEN len = t - s;
d692 2
a693 13
	SV *const temp_sv = CopFILESV(PL_curcop);
	const char *cf;
	STRLEN tmplen;

	if (temp_sv) {
	    cf = SvPVX(temp_sv);
	    tmplen = SvCUR(temp_sv);
	} else {
	    cf = NULL;
	    tmplen = 0;
	}

	if (tmplen > 7 && strnEQ(cf, "(eval ", 6)) {
d696 6
a701 7
	    /* However, the long form of evals is only turned on by the
	       debugger - usually they're "(eval %lu)" */
	    char smallbuf[128];
	    char *tmpbuf;
	    GV **gvp;
	    STRLEN tmplen2 = len;
	    if (tmplen + 2 <= sizeof smallbuf)
d704 10
a713 5
		Newx(tmpbuf, tmplen + 2, char);
	    tmpbuf[0] = '_';
	    tmpbuf[1] = '<';
	    memcpy(tmpbuf + 2, cf, tmplen);
	    tmplen += 2;
a715 18
		char *tmpbuf2;
		GV *gv2;

		if (tmplen2 + 2 <= sizeof smallbuf)
		    tmpbuf2 = smallbuf;
		else
		    Newx(tmpbuf2, tmplen2 + 2, char);

		if (tmpbuf2 != smallbuf || tmpbuf != smallbuf) {
		    /* Either they malloc'd it, or we malloc'd it,
		       so no prefix is present in ours.  */
		    tmpbuf2[0] = '_';
		    tmpbuf2[1] = '<';
		}

		memcpy(tmpbuf2 + 2, s, tmplen2);
		tmplen2 += 2;

d717 1
a717 1
		if (!isGV(gv2)) {
d719 4
a722 7
		    /* adjust ${"::_<newfilename"} to store the new file name */
		    GvSV(gv2) = newSVpvn(tmpbuf2 + 2, tmplen2 - 2);
		    GvHV(gv2) = (HV*)SvREFCNT_inc(GvHV(*gvp));
		    GvAV(gv2) = (AV*)SvREFCNT_inc(GvAV(*gvp));
		}

		if (tmpbuf2 != smallbuf) Safefree(tmpbuf2);
d725 1
d729 1
a729 1
	CopFILE_setn(PL_curcop, s, len);
d731 1
a734 92
#ifdef PERL_MAD
/* skip space before PL_thistoken */

STATIC char *
S_skipspace0(pTHX_ register char *s)
{
    s = skipspace(s);
    if (!PL_madskills)
	return s;
    if (PL_skipwhite) {
	if (!PL_thiswhite)
	    PL_thiswhite = newSVpvs("");
	sv_catsv(PL_thiswhite, PL_skipwhite);
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
    PL_realtokenstart = s - SvPVX(PL_linestr);
    return s;
}

/* skip space after PL_thistoken */

STATIC char *
S_skipspace1(pTHX_ register char *s)
{
    const char *start = s;
    I32 startoff = start - SvPVX(PL_linestr);

    s = skipspace(s);
    if (!PL_madskills)
	return s;
    start = SvPVX(PL_linestr) + startoff;
    if (!PL_thistoken && PL_realtokenstart >= 0) {
	const char * const tstart = SvPVX(PL_linestr) + PL_realtokenstart;
	PL_thistoken = newSVpvn(tstart, start - tstart);
    }
    PL_realtokenstart = -1;
    if (PL_skipwhite) {
	if (!PL_nextwhite)
	    PL_nextwhite = newSVpvs("");
	sv_catsv(PL_nextwhite, PL_skipwhite);
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
    return s;
}

STATIC char *
S_skipspace2(pTHX_ register char *s, SV **svp)
{
    char *start;
    const I32 bufptroff = PL_bufptr - SvPVX(PL_linestr);
    const I32 startoff = s - SvPVX(PL_linestr);

    s = skipspace(s);
    PL_bufptr = SvPVX(PL_linestr) + bufptroff;
    if (!PL_madskills || !svp)
	return s;
    start = SvPVX(PL_linestr) + startoff;
    if (!PL_thistoken && PL_realtokenstart >= 0) {
	char * const tstart = SvPVX(PL_linestr) + PL_realtokenstart;
	PL_thistoken = newSVpvn(tstart, start - tstart);
	PL_realtokenstart = -1;
    }
    if (PL_skipwhite) {
	if (!*svp)
	    *svp = newSVpvs("");
	sv_setsv(*svp, PL_skipwhite);
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
    
    return s;
}
#endif

STATIC void
S_update_debugger_info(pTHX_ SV *orig_sv, const char *buf, STRLEN len)
{
    AV *av = CopFILEAVx(PL_curcop);
    if (av) {
	SV * const sv = newSV_type(SVt_PVMG);
	if (orig_sv)
	    sv_setsv(sv, orig_sv);
	else
	    sv_setpvn(sv, buf, len);
	(void)SvIOK_on(sv);
	SvIV_set(sv, 0);
	av_store(av, (I32)CopLINE(PL_curcop), sv);
    }
}

a743 11
    dVAR;
#ifdef PERL_MAD
    int curoff;
    int startoff = s - SvPVX(PL_linestr);

    if (PL_skipwhite) {
	sv_free(PL_skipwhite);
	PL_skipwhite = 0;
    }
#endif

a746 3
#ifdef PERL_MAD
	goto done;
#else
a747 1
#endif
a776 3
#ifdef PERL_MAD
	    goto done;
#else
a777 1
#endif
a779 4
#ifdef PERL_MAD
	curoff = s - SvPVX(PL_linestr);
#endif

d781 1
a781 1
			     (prevlen = SvCUR(PL_linestr)))) == NULL)
a782 16
#ifdef PERL_MAD
	    if (PL_madskills && curoff != startoff) {
		if (!PL_skipwhite)
		    PL_skipwhite = newSVpvs("");
		sv_catpvn(PL_skipwhite, SvPVX(PL_linestr) + startoff,
					curoff - startoff);
	    }

	    /* mustn't throw out old stuff yet if madpropping */
	    SvCUR(PL_linestr) = curoff;
	    s = SvPVX(PL_linestr) + curoff;
	    *s = 0;
	    if (curoff && s[-1] == '\n')
		s[-1] = ' ';
#endif

a783 1
	    /* XXX these shouldn't really be added here, can't set PL_faketokens */
d785 1
a785 2
#ifdef PERL_MAD
		sv_catpvs(PL_linestr,
a786 4
#else
		sv_setpvs(PL_linestr,
			 ";}continue{print or die qq(-p destination: $!\\n);}");
#endif
a789 3
#ifdef PERL_MAD
		sv_catpvn(PL_linestr, ";}", 2);
#else
a790 1
#endif
a793 3
#ifdef PERL_MAD
		sv_catpvn(PL_linestr,";", 1);
#else
a794 1
#endif
d798 1
a798 5
		= SvPVX(PL_linestr)
#ifdef PERL_MAD
		+ curoff
#endif
		;
d800 1
a800 1
	    PL_last_lop = PL_last_uni = NULL;
d815 1
a815 1
	    PL_rsfp = NULL;
d841 2
a842 3
	if (PERLDB_LINE && PL_curstash != PL_debstash)
	    update_debugger_info(NULL, PL_bufptr, PL_bufend - PL_bufptr);
    }
d844 6
a849 9
#ifdef PERL_MAD
  done:
    if (PL_madskills) {
	if (!PL_skipwhite)
	    PL_skipwhite = newSVpvs("");
	curoff = s - SvPVX(PL_linestr);
	if (curoff - startoff)
	    sv_catpvn(PL_skipwhite, SvPVX(PL_linestr) + startoff,
				curoff - startoff);
a850 2
    return s;
#endif
d865 2
a866 3
    dVAR;
    const char *s;
    const char *t;
d872 1
a872 3
    s = PL_last_uni;
    while (isALNUM_lazy_if(s,UTF) || *s == '-')
	s++;
a874 1

d876 2
d879 3
a881 2
		   "Warning: Use of \"%.*s\" without parentheses is ambiguous",
		   (int)(s - PL_last_uni), PL_last_uni);
d903 1
a903 2
    dVAR;
    pl_yylval.ival = f;
a908 4
#ifdef PERL_MAD
    if (PL_lasttoke)
 	return REPORT(LSTOP);
#else
a910 1
#endif
d913 1
a913 1
    s = PEEKSPACE(s);
a919 70
#ifdef PERL_MAD
 /*
 * S_start_force
 * Sets up for an eventual force_next().  start_force(0) basically does
 * an unshift, while start_force(-1) does a push.  yylex removes items
 * on the "pop" end.
 */

STATIC void
S_start_force(pTHX_ int where)
{
    int i;

    if (where < 0)	/* so people can duplicate start_force(PL_curforce) */
	where = PL_lasttoke;
    assert(PL_curforce < 0 || PL_curforce == where);
    if (PL_curforce != where) {
	for (i = PL_lasttoke; i > where; --i) {
	    PL_nexttoke[i] = PL_nexttoke[i-1];
	}
	PL_lasttoke++;
    }
    if (PL_curforce < 0)	/* in case of duplicate start_force() */
	Zero(&PL_nexttoke[where], 1, NEXTTOKE);
    PL_curforce = where;
    if (PL_nextwhite) {
	if (PL_madskills)
	    curmad('^', newSVpvs(""));
	CURMAD('_', PL_nextwhite);
    }
}

STATIC void
S_curmad(pTHX_ char slot, SV *sv)
{
    MADPROP **where;

    if (!sv)
	return;
    if (PL_curforce < 0)
	where = &PL_thismad;
    else
	where = &PL_nexttoke[PL_curforce].next_mad;

    if (PL_faketokens)
	sv_setpvn(sv, "", 0);
    else {
	if (!IN_BYTES) {
	    if (UTF && is_utf8_string((U8*)SvPVX(sv), SvCUR(sv)))
		SvUTF8_on(sv);
	    else if (PL_encoding) {
		sv_recode_to_utf8(sv, PL_encoding);
	    }
	}
    }

    /* keep a slot open for the head of the list? */
    if (slot != '_' && *where && (*where)->mad_key == '^') {
	(*where)->mad_key = slot;
	sv_free((SV*)((*where)->mad_val));
	(*where)->mad_val = (void*)sv;
    }
    else
	addmad(newMADsv(slot, sv), where, 0);
}
#else
#  define start_force(where)    NOOP
#  define curmad(slot, sv)      NOOP
#endif

d925 2
a926 2
 * will need to set PL_nextval[] (or PL_nexttoke[].next_val with PERL_MAD),
 * and possibly PL_expect to ensure the lexer handles the token correctly.
a931 11
    dVAR;
#ifdef PERL_MAD
    if (PL_curforce < 0)
	start_force(PL_lasttoke);
    PL_nexttoke[PL_curforce].next_type = type;
    if (PL_lex_state != LEX_KNOWNEXT)
 	PL_lex_defer = PL_lex_state;
    PL_lex_state = LEX_KNOWNEXT;
    PL_lex_expect = PL_expect;
    PL_curforce = -1;
#else
a938 11
#endif
}

STATIC SV *
S_newSV_maybe_utf8(pTHX_ const char *start, STRLEN len)
{
    dVAR;
    SV * const sv = newSVpvn(start,len);
    if (UTF && !IN_BYTES && is_utf8_string((const U8*)start, len))
	SvUTF8_on(sv);
    return sv;
d945 1
a945 2
 * it calls S_force_word to stick the next word into the PL_nexttoke/val
 * lookahead.
d949 1
a949 1
 *   int token   : PL_next* will be this type of bare word (e.g., METHOD,WORD)
a959 1
    dVAR;
d963 1
a963 1
    start = SKIPSPACE1(start);
d970 1
a970 1
	if (check_keyword && keyword(PL_tokenbuf, len, 0))
a971 3
	start_force(PL_curforce);
	if (PL_madskills)
	    curmad('X', newSVpvn(start,s-start));
d973 1
a973 1
	    s = SKIPSPACE1(s);
d980 4
a983 6
	if (PL_madskills)
	    curmad('g', newSVpvs( "forced" ));
	NEXTVAL_NEXTTOKE.opval
	    = (OP*)newSVOP(OP_CONST,0,
			   S_newSV_maybe_utf8(aTHX_ PL_tokenbuf, len));
	NEXTVAL_NEXTTOKE.opval->op_private |= OPpCONST_BARE;
d1001 3
a1003 6
    dVAR;
    if (*s) {
	const STRLEN len = strlen(s);
	OP* const o = (OP*)newSVOP(OP_CONST, 0, newSVpvn(s, len));
	start_force(PL_curforce);
	NEXTVAL_NEXTTOKE.opval = o;
d1010 4
a1013 6
	    gv_fetchpvn_flags(s, len,
			      PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL)
			      : GV_ADD,
			      kind == '$' ? SVt_PV :
			      kind == '@@' ? SVt_PVAV :
			      kind == '%' ? SVt_PVHV :
d1015 1
a1015 1
			      );
d1056 1
a1056 2
    dVAR;
    OP *version = NULL;
a1057 3
#ifdef PERL_MAD
    I32 startoff = s - SvPVX(PL_linestr);
#endif
d1059 1
a1059 1
    s = SKIPSPACE1(s);
a1066 6
#ifdef PERL_MAD
	if (PL_madskills) {
	    start_force(PL_curforce);
	    curmad('X', newSVpvn(s,d-s));
	}
#endif
d1069 2
a1070 2
            s = scan_num(s, &pl_yylval);
            version = pl_yylval.opval;
d1073 1
a1073 1
		SvUPGRADE(ver, SVt_PVNV);
d1078 1
a1078 8
	else if (guessing) {
#ifdef PERL_MAD
	    if (PL_madskills) {
		sv_free(PL_nextwhite);	/* let next token collect whitespace */
		PL_nextwhite = 0;
		s = SvPVX(PL_linestr) + startoff;
	    }
#endif
a1079 1
	}
a1081 7
#ifdef PERL_MAD
    if (PL_madskills && !version) {
	sv_free(PL_nextwhite);	/* let next token collect whitespace */
	PL_nextwhite = 0;
	s = SvPVX(PL_linestr) + startoff;
    }
#endif
d1083 1
a1083 2
    start_force(PL_curforce);
    NEXTVAL_NEXTTOKE.opval = version;
a1099 1
    dVAR;
d1134 1
a1134 1
       return new_constant(NULL, 0, "q", sv, pv, "q", 1);
d1156 1
a1156 1
 * Assumes that pl_yylval.ival is the op we're creating (e.g. OP_LCFIRST).
d1159 1
a1159 1
 * make (we return THING if pl_yylval.ival is OP_NULL, PMFUNC otherwise).
d1173 1
a1173 2
    dVAR;
    register const I32 op_type = pl_yylval.ival;
d1176 2
a1177 2
	pl_yylval.opval = PL_lex_op;
	PL_lex_op = NULL;
d1186 1
a1186 1
	    const char * const p = SvPV_const(sv, len);
d1193 2
a1194 13
	pl_yylval.opval = (OP*)newSVOP(op_type, 0, sv);
	PL_lex_stuff = NULL;
	/* Allow <FH> // "foo" */
	if (op_type == OP_READLINE)
	    PL_expect = XTERMORDORDOR;
	return THING;
    }
    else if (op_type == OP_BACKTICK && PL_lex_op) {
	/* readpipe() vas overriden */
	cSVOPx(cLISTOPx(cUNOPx(PL_lex_op)->op_first)->op_first->op_sibling)->op_sv = tokeq(PL_lex_stuff);
	pl_yylval.opval = PL_lex_op;
	PL_lex_op = NULL;
	PL_lex_stuff = NULL;
d1199 1
a1199 1
    PL_sublex_info.sub_inwhat = (U16)op_type;
d1205 2
a1206 2
	pl_yylval.opval = PL_lex_op;
	PL_lex_op = NULL;
a1223 1
    dVAR;
d1227 1
a1227 1
    SAVEBOOL(PL_lex_dojoin);
d1231 1
a1231 1
    SAVEI8(PL_lex_state);
d1233 1
a1233 1
    SAVEI16(PL_lex_inwhat);
d1247 1
a1247 1
    PL_lex_stuff = NULL;
d1252 1
a1252 1
    PL_last_lop = PL_last_uni = NULL;
d1269 1
a1269 1
	PL_lex_inpat = NULL;
a1281 1
    dVAR;
d1283 1
a1283 1
	SV * const sv = newSVpvs("");
d1287 1
a1287 1
	pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
d1302 1
a1302 1
	PL_last_lop = PL_last_uni = NULL;
d1319 1
a1319 1
	    PL_lex_repl = NULL;
a1323 14
#ifdef PERL_MAD
	if (PL_madskills) {
	    if (PL_thiswhite) {
		if (!PL_endwhite)
		    PL_endwhite = newSVpvs("");
		sv_catsv(PL_endwhite, PL_thiswhite);
		PL_thiswhite = 0;
	    }
	    if (PL_thistoken)
		sv_setpvn(PL_thistoken,"",0);
	    else
		PL_realtokenstart = -1;
	}
#endif
d1339 1
a1339 1
  It looks at PL_lex_inwhat and PL_lex_inpat to find out whether it's
d1341 1
a1341 1
  (PL_lex_inwhat == OP_TRANS is true), or a double-quoted string.
d1343 2
a1344 2
  Returns a pointer to the character scanned up to. If this is
  advanced from the start pointer supplied (i.e. if anything was
d1346 1
a1346 1
  in pl_yylval. Caller must intuit reason for not parsing further
d1353 2
a1354 2
      constants: \x31
      backrefs: \1
d1360 2
a1361 4
    of the string, which indicates a range. If the range is in bytes,
    scan_const expands the range to the full set of intermediate
    characters. If the range is in utf8, the hyphen is replaced with
    a certain range mark which will be handled by pmtrans() in op.c.
d1366 2
a1367 2
      constants: \x31
      deprecated backrefs: \1 (in substitution replacements)
d1375 1
a1375 4
  embedded arrays (whether in pattern or not) could be:
      @@foo, @@::foo, @@'foo, @@{foo}, @@$foo, @@+, @@-.

  $ in double-quoted strings must be the symbol of an embedded scalar.
d1379 1
a1379 1
  followed by one of "()| \r\n\t"
d1385 4
a1388 4
	  handle transliteration ranges
	  skip regexp comments /(?#comment)/ and codes /(?{code})/
	  skip #-initiated comments in //x patterns
	  check for embedded arrays
d1391 2
a1392 2
	      leave intact backslashes from leaveit (below)
	      deprecate \1 in substitution replacements
d1395 5
a1399 6
		  handle \- in a transliteration (becomes a literal -)
		  handle \132 (octal characters)
		  handle \x15 and \x{1234} (hex characters)
		  handle \N{name} (named characters)
		  handle \cV (control characters)
		  handle printf-style backslashes (\f, \r, \n, etc)
a1408 1
    dVAR;
d1410 1
a1410 1
    SV *sv = newSV(send - start);		/* sv for the constant */
a1419 1
    bool native_range = TRUE; /* turned to FALSE if the first endpoint is Unicode. */
d1422 5
d1443 1
a1443 9
#ifdef EBCDIC
		UV uvmax = 0;
#endif

		if (has_utf8
#ifdef EBCDIC
		    && !native_range
#endif
		    ) {
a1455 9
#ifdef EBCDIC
                SvGROW(sv,
		       SvLEN(sv) + (has_utf8 ?
				    (512 - UTF_CONTINUATION_MARK +
				     UNISKIP(0x100))
				    : 256));
                /* How many two-byte within 0..255: 128 in UTF-8,
		 * 96 in UTF-8-mod. */
#else
a1456 1
#endif
d1458 4
a1461 25
#ifdef EBCDIC
                if (has_utf8) {
                    int j;
                    for (j = 0; j <= 1; j++) {
                        char * const c = (char*)utf8_hop((U8*)d, -1);
                        const UV uv    = utf8n_to_uvchr((U8*)c, d - c, NULL, 0);
                        if (j)
                            min = (U8)uv;
                        else if (uv < 256)
                            max = (U8)uv;
                        else {
                            max = (U8)0xff; /* only to \xff */
                            uvmax = uv; /* \x{100} to uvmax */
                        }
                        d = c; /* eat endpoint chars */
                     }
                }
               else {
#endif
		   d -= 2;		/* eat the first char and the - */
		   min = (U8)*d;	/* first char in range */
		   max = (U8)d[1];	/* last char in range  */
#ifdef EBCDIC
	       }
#endif
d1486 1
a1486 23
#ifdef EBCDIC
                        if (has_utf8) {
                            const U8 ch = (U8)NATIVE_TO_UTF(i);
                            if (UNI_IS_INVARIANT(ch))
                                *d++ = (U8)i;
                            else {
                                *d++ = (U8)UTF8_EIGHT_BIT_HI(ch);
                                *d++ = (U8)UTF8_EIGHT_BIT_LO(ch);
                            }
                        }
                        else
#endif
                            *d++ = (char)i;
 
#ifdef EBCDIC
                if (uvmax) {
                    d = (char*)uvchr_to_utf8((U8*)d, 0x100);
                    if (uvmax > 0x101)
                        *d++ = (char)UTF_TO_NATIVE(0xff);
                    if (uvmax > 0x100)
                        d = (char*)uvchr_to_utf8((U8*)d, uvmax);
                }
#endif
d1502 1
a1502 5
		if (has_utf8
#ifdef EBCDIC
		    && !native_range
#endif
		    ) {
a1513 1
		native_range = TRUE;
d1528 1
a1528 1
		    || (s[2] == '?' && s[3] == '{'))
d1560 3
a1562 8
	else if (*s == '@@' && s[1]) {
	    if (isALNUM_lazy_if(s+1,UTF))
		break;
	    if (strchr(":'{$", s[1]))
		break;
	    if (!PL_lex_inpat && (s[1] == '+' || s[1] == '-'))
		break; /* in regexp, neither @@+ nor @@- are interpolated */
	}
d1580 7
a1601 5
	    /* skip any other backslash escapes in a pattern */
	    else if (PL_lex_inpat) {
		*d++ = NATIVE_TO_NEED(has_utf8,'\\');
		goto default_action;
	    }
d1615 2
a1616 1
		    if ((isALPHA(*s) || isDIGIT(*s)) &&
d1619 2
a1620 2
				    "Unrecognized escape \\%c passed through",
				    *s);
a1717 4
#ifdef EBCDIC
			if (uv > 255 && !dorange)
			    native_range = FALSE;
#endif
a1748 3
			if ( e > s && len != (STRLEN)(e - s) ) {
			    uv = 0xFFFD;
			}
d1753 2
a1754 2
		    res = new_constant( NULL, 0, "charnames",
					res, NULL, s - 2, e - s + 3 );
a1794 4
#ifdef EBCDIC
		    if (!dorange)
			native_range = FALSE; /* \N{} is guessed to be Unicode */
#endif
d1858 2
a1859 2
	    const UV nextuv   = (this_utf8) ? utf8n_to_uvchr((U8*)s, send - s, &len, 0) : (UV) ((U8) *s);
	    const STRLEN need = UNISKIP(NATIVE_TO_UNI(nextuv));
d1866 1
a1866 1
	    d = (char*)uvchr_to_utf8((U8*)d, nextuv);
a1867 4
#ifdef EBCDIC
	    if (uv > 255 && !dorange)
		native_range = FALSE;
#endif
d1899 1
a1899 1
    /* return the substring (via pl_yylval) only if we parsed anything */
d1901 9
a1909 21
	if ( PL_hints & ( PL_lex_inpat ? HINT_NEW_RE : HINT_NEW_STRING ) ) {
	    const char *const key = PL_lex_inpat ? "qr" : "q";
	    const STRLEN keylen = PL_lex_inpat ? 2 : 1;
	    const char *type;
	    STRLEN typelen;

	    if (PL_lex_inwhat == OP_TRANS) {
		type = "tr";
		typelen = 2;
	    } else if (PL_lex_inwhat == OP_SUBST && !PL_lex_inpat) {
		type = "s";
		typelen = 1;
	    } else  {
		type = "qq";
		typelen = 2;
	    }

	    sv = S_new_constant(aTHX_ start, s - start, key, keylen, sv, NULL,
				type, typelen);
	}
	pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
a1938 1
    dVAR;
a2000 1
		    int len;
d2002 1
a2002 2
		    len = (int)strlen(tmpbuf);
		    if (len > 1 && gv_fetchpvn_flags(tmpbuf, len, 0, SVt_PV))
d2020 1
a2020 1
		    else if (seen[(U8)'\''] || seen[(U8)'"'])
d2052 1
a2052 1
		    if (keyword(tmpbuf, d - tmpbuf, 0))
d2091 1
a2091 1
S_intuit_method(pTHX_ char *start, GV *gv, CV *cv)
a2092 1
    dVAR;
a2096 3
#ifdef PERL_MAD
    int soff;
#endif
d2099 2
a2100 1
	if (SvTYPE(gv) == SVt_PVGV && GvIO(gv))
d2102 7
a2108 9
	if (cv) {
	    if (SvPOK(cv)) {
		const char *proto = SvPVX_const(cv);
		if (proto) {
		    if (*proto == ';')
			proto++;
		    if (*proto == '*')
			return 0;
		}
d2111 1
a2111 1
	    gv = NULL;
d2120 1
a2120 2
	if (gv || PL_last_lop_op == OP_PRINT || PL_last_lop_op == OP_SAY ||
		isUPPER(*PL_tokenbuf))
d2122 1
a2122 7
#ifdef PERL_MAD
	len = start - SvPVX(PL_linestr);
#endif
	s = PEEKSPACE(s);
#ifdef PERL_MAD
	start = SvPVX(PL_linestr) + len;
#endif
d2127 1
a2127 1
    if (!keyword(tmpbuf, len, 0)) {
a2130 3
#ifdef PERL_MAD
	    soff = s - SvPVX(PL_linestr);
#endif
d2133 1
a2133 1
	indirgv = gv_fetchpvn_flags(tmpbuf, len, 0, SVt_PVCV);
d2137 2
a2138 5
	if (!gv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, 0)) {
#ifdef PERL_MAD
	    soff = s - SvPVX(PL_linestr);
#endif
	    s = PEEKSPACE(s);
d2142 1
a2142 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.opval = (OP*)newSVOP(OP_CONST, 0,
d2144 1
a2144 3
	    NEXTVAL_NEXTTOKE.opval->op_private = OPpCONST_BARE;
	    if (PL_madskills)
		curmad('X', newSVpvn(start,SvPVX(PL_linestr) + soff - start));
a2147 3
#ifdef PERL_MAD
	    PL_bufptr = SvPVX(PL_linestr) + soff; /* restart before space */
#endif
d2154 22
a2195 1
    dVAR;
d2197 1
a2197 4
	return NULL;

    if (!PL_parser)
	return NULL;
d2202 2
a2203 2
	datasv = newSV(0);
    SvUPGRADE(datasv, SVt_PVIO);
d2207 1
a2207 2
			  FPTR2DPTR(void *, IoANY(datasv)),
			  SvPV_nolen(datasv)));
a2217 1
    dVAR;
d2221 1
a2221 2
    DEBUG_P(PerlIO_printf(Perl_debug_log, "filter_del func %p",
			  FPTR2DPTR(void*, funcp)));
d2223 1
a2223 1
    if (!PL_parser || !PL_rsfp_filters || AvFILLp(PL_rsfp_filters)<0)
a2243 1
    dVAR;
a2245 11
    /* This API is bad. It should have been using unsigned int for maxlen.
       Not sure if we want to change the API, but if not we should sanity
       check the value here.  */
    const unsigned int correct_length
	= maxlen < 0 ?
#ifdef PERL_MICRO
	0x7FFFFFFF
#else
	INT_MAX
#endif
	: maxlen;
d2247 1
a2247 1
    if (!PL_parser || !PL_rsfp_filters)
d2254 1
a2254 1
	if (correct_length) {
d2260 2
a2261 3
	    SvGROW(buf_sv, (STRLEN)(old_len + correct_length)) ;
	    if ((len = PerlIO_read(PL_rsfp, SvPVX(buf_sv) + old_len,
				   correct_length)) <= 0) {
d2284 1
a2284 1
	return FILTER_READ(idx+1, buf_sv, correct_length); /* recurse */
d2290 1
a2290 1
			  idx, (void*)datasv, SvPV_nolen_const(datasv)));
d2294 1
a2294 1
    return (*funcp)(aTHX_ idx, buf_sv, correct_length);
a2299 1
    dVAR;
d2311 1
a2311 1
	    return NULL ;
d2318 1
a2318 1
S_find_in_my_stash(pTHX_ const char *pkgname, STRLEN len)
a2319 1
    dVAR;
d2327 1
a2327 1
        (gv = gv_fetchpvn_flags(pkgname, len, 0, SVt_PVHV)))
d2333 5
a2337 211
    gv = gv_fetchpvn_flags(pkgname, len, 0, SVt_PVCV);
    if (gv && GvCV(gv)) {
	SV * const sv = cv_const_sv(GvCV(gv));
	if (sv)
            pkgname = SvPV_const(sv, len);
    }

    return gv_stashpvn(pkgname, len, 0);
}

/*
 * S_readpipe_override
 * Check whether readpipe() is overriden, and generates the appropriate
 * optree, provided sublex_start() is called afterwards.
 */
STATIC void
S_readpipe_override(pTHX)
{
    GV **gvp;
    GV *gv_readpipe = gv_fetchpvs("readpipe", GV_NOTQUAL, SVt_PVCV);
    pl_yylval.ival = OP_BACKTICK;
    if ((gv_readpipe
		&& GvCVu(gv_readpipe) && GvIMPORTED_CV(gv_readpipe))
	    ||
	    ((gvp = (GV**)hv_fetchs(PL_globalstash, "readpipe", FALSE))
	     && (gv_readpipe = *gvp) && isGV_with_GP(gv_readpipe)
	     && GvCVu(gv_readpipe) && GvIMPORTED_CV(gv_readpipe)))
    {
	PL_lex_op = (OP*)newUNOP(OP_ENTERSUB, OPf_STACKED,
	    append_elem(OP_LIST,
		newSVOP(OP_CONST, 0, &PL_sv_undef), /* value will be read later */
		newCVREF(0, newGVOP(OP_GV, 0, gv_readpipe))));
    }
}

#ifdef PERL_MAD 
 /*
 * Perl_madlex
 * The intent of this yylex wrapper is to minimize the changes to the
 * tokener when we aren't interested in collecting madprops.  It remains
 * to be seen how successful this strategy will be...
 */

int
Perl_madlex(pTHX)
{
    int optype;
    char *s = PL_bufptr;

    /* make sure PL_thiswhite is initialized */
    PL_thiswhite = 0;
    PL_thismad = 0;

    /* just do what yylex would do on pending identifier; leave PL_thiswhite alone */
    if (PL_pending_ident)
        return S_pending_ident(aTHX);

    /* previous token ate up our whitespace? */
    if (!PL_lasttoke && PL_nextwhite) {
	PL_thiswhite = PL_nextwhite;
	PL_nextwhite = 0;
    }

    /* isolate the token, and figure out where it is without whitespace */
    PL_realtokenstart = -1;
    PL_thistoken = 0;
    optype = yylex();
    s = PL_bufptr;
    assert(PL_curforce < 0);

    if (!PL_thismad || PL_thismad->mad_key == '^') {	/* not forced already? */
	if (!PL_thistoken) {
	    if (PL_realtokenstart < 0 || !CopLINE(PL_curcop))
		PL_thistoken = newSVpvs("");
	    else {
		char * const tstart = SvPVX(PL_linestr) + PL_realtokenstart;
		PL_thistoken = newSVpvn(tstart, s - tstart);
	    }
	}
	if (PL_thismad)	/* install head */
	    CURMAD('X', PL_thistoken);
    }

    /* last whitespace of a sublex? */
    if (optype == ')' && PL_endwhite) {
	CURMAD('X', PL_endwhite);
    }

    if (!PL_thismad) {

	/* if no whitespace and we're at EOF, bail.  Otherwise fake EOF below. */
	if (!PL_thiswhite && !PL_endwhite && !optype) {
	    sv_free(PL_thistoken);
	    PL_thistoken = 0;
	    return 0;
	}

	/* put off final whitespace till peg */
	if (optype == ';' && !PL_rsfp) {
	    PL_nextwhite = PL_thiswhite;
	    PL_thiswhite = 0;
	}
	else if (PL_thisopen) {
	    CURMAD('q', PL_thisopen);
	    if (PL_thistoken)
		sv_free(PL_thistoken);
	    PL_thistoken = 0;
	}
	else {
	    /* Store actual token text as madprop X */
	    CURMAD('X', PL_thistoken);
	}

	if (PL_thiswhite) {
	    /* add preceding whitespace as madprop _ */
	    CURMAD('_', PL_thiswhite);
	}

	if (PL_thisstuff) {
	    /* add quoted material as madprop = */
	    CURMAD('=', PL_thisstuff);
	}

	if (PL_thisclose) {
	    /* add terminating quote as madprop Q */
	    CURMAD('Q', PL_thisclose);
	}
    }

    /* special processing based on optype */

    switch (optype) {

    /* opval doesn't need a TOKEN since it can already store mp */
    case WORD:
    case METHOD:
    case FUNCMETH:
    case THING:
    case PMFUNC:
    case PRIVATEREF:
    case FUNC0SUB:
    case UNIOPSUB:
    case LSTOPSUB:
	if (pl_yylval.opval)
	    append_madprops(PL_thismad, pl_yylval.opval, 0);
	PL_thismad = 0;
	return optype;

    /* fake EOF */
    case 0:
	optype = PEG;
	if (PL_endwhite) {
	    addmad(newMADsv('p', PL_endwhite), &PL_thismad, 0);
	    PL_endwhite = 0;
	}
	break;

    case ']':
    case '}':
	if (PL_faketokens)
	    break;
	/* remember any fake bracket that lexer is about to discard */ 
	if (PL_lex_brackets == 1 &&
	    ((expectation)PL_lex_brackstack[0] & XFAKEBRACK))
	{
	    s = PL_bufptr;
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
		s++;
	    if (*s == '}') {
		PL_thiswhite = newSVpvn(PL_bufptr, ++s - PL_bufptr);
		addmad(newMADsv('#', PL_thiswhite), &PL_thismad, 0);
		PL_thiswhite = 0;
		PL_bufptr = s - 1;
		break;	/* don't bother looking for trailing comment */
	    }
	    else
		s = PL_bufptr;
	}
	if (optype == ']')
	    break;
	/* FALLTHROUGH */

    /* attach a trailing comment to its statement instead of next token */
    case ';':
	if (PL_faketokens)
	    break;
	if (PL_bufptr > PL_oldbufptr && PL_bufptr[-1] == optype) {
	    s = PL_bufptr;
	    while (s < PL_bufend && (*s == ' ' || *s == '\t'))
		s++;
	    if (*s == '\n' || *s == '#') {
		while (s < PL_bufend && *s != '\n')
		    s++;
		if (s < PL_bufend)
		    s++;
		PL_thiswhite = newSVpvn(PL_bufptr, s - PL_bufptr);
		addmad(newMADsv('#', PL_thiswhite), &PL_thismad, 0);
		PL_thiswhite = 0;
		PL_bufptr = s;
	    }
	}
	break;

    /* pval */
    case LABEL:
	break;

    /* ival */
    default:
	break;

d2340 1
a2340 4
    /* Create new token struct.  Note: opvals return early above. */
    pl_yylval.tkval = newTOKEN(optype, pl_yylval, PL_thismad);
    PL_thismad = 0;
    return optype;
a2341 1
#endif
a2342 26
STATIC char *
S_tokenize_use(pTHX_ int is_use, char *s) {
    dVAR;
    if (PL_expect != XSTATE)
	yyerror(Perl_form(aTHX_ "\"%s\" not allowed in expression",
		    is_use ? "use" : "no"));
    s = SKIPSPACE1(s);
    if (isDIGIT(*s) || (*s == 'v' && isDIGIT(s[1]))) {
	s = force_version(s, TRUE);
	if (*s == ';' || (s = SKIPSPACE1(s), *s == ';')) {
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.opval = NULL;
	    force_next(WORD);
	}
	else if (*s == 'v') {
	    s = force_word(s,WORD,FALSE,TRUE,FALSE);
	    s = force_version(s, FALSE);
	}
    }
    else {
	s = force_word(s,WORD,FALSE,TRUE,FALSE);
	s = force_version(s, FALSE);
    }
    pl_yylval.ival = is_use;
    return s;
}
d2346 1
a2346 1
	  "ATTRTERM", "TERMBLOCK", "TERMORDORDOR"
d2375 20
a2401 1
    dVAR;
d2404 1
d2406 2
a2408 4

    /* orig_keyword, gvp, and gv are initialized here because
     * jump to the label just_a_word_zero can bypass their
     * initialization later. */
a2409 2
    GV *gv = NULL;
    GV **gvp = NULL;
d2412 1
a2412 1
	SV* tmp = newSVpvs("");
a2434 21
#ifdef PERL_MAD
	PL_lasttoke--;
	pl_yylval = PL_nexttoke[PL_lasttoke].next_val;
	if (PL_madskills) {
	    PL_thismad = PL_nexttoke[PL_lasttoke].next_mad;
	    PL_nexttoke[PL_lasttoke].next_mad = 0;
	    if (PL_thismad && PL_thismad->mad_key == '_') {
		PL_thiswhite = (SV*)PL_thismad->mad_val;
		PL_thismad->mad_val = 0;
		mad_free(PL_thismad);
		PL_thismad = 0;
	    }
	}
	if (!PL_lasttoke) {
	    PL_lex_state = PL_lex_defer;
  	    PL_expect = PL_lex_expect;
  	    PL_lex_defer = LEX_NORMAL;
	    if (!PL_nexttoke[PL_lasttoke].next_type)
		return yylex();
  	}
#else
d2436 1
a2436 1
	pl_yylval = PL_nextval[PL_nexttoke];
a2441 5
#endif
#ifdef PERL_MAD
	/* FIXME - can these be merged?  */
	return(PL_nexttoke[PL_lasttoke].next_type);
#else
a2442 1
#endif
a2462 4
#ifdef PERL_MAD
		    if (PL_madskills)
			PL_thistoken = newSVpvs("\\E");
#endif
a2465 9
#ifdef PERL_MAD
	    while (PL_bufptr != PL_bufend &&
	      PL_bufptr[0] == '\\' && PL_bufptr[1] == 'E') {
		if (!PL_thiswhite)
		    PL_thiswhite = newSVpvs("");
		sv_catpvn(PL_thiswhite, PL_bufptr, 2);
		PL_bufptr += 2;
	    }
#else
a2467 1
#endif
a2475 5
#ifdef PERL_MAD
		if (!PL_thiswhite)
		    PL_thiswhite = newSVpvs("");
		sv_catpvn(PL_thiswhite, PL_bufptr, 4);
#endif
d2481 2
a2482 4
		I32 tmp;
		if (!PL_madskills) /* when just compiling don't need correct */
		    if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
			tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
d2493 1
a2493 2
		start_force(PL_curforce);
		NEXTVAL_NEXTTOKE.ival = 0;
a2494 1
		start_force(PL_curforce);
d2496 1
a2496 1
		    NEXTVAL_NEXTTOKE.ival = OP_LCFIRST;
d2498 1
a2498 1
		    NEXTVAL_NEXTTOKE.ival = OP_UCFIRST;
d2500 1
a2500 1
		    NEXTVAL_NEXTTOKE.ival = OP_LC;
d2502 1
a2502 1
		    NEXTVAL_NEXTTOKE.ival = OP_UC;
d2504 1
a2504 1
		    NEXTVAL_NEXTTOKE.ival = OP_QUOTEMETA;
a2506 7
		if (PL_madskills) {
		    SV* const tmpsv = newSVpvs("\\ ");
		    /* replace the space with the character we want to escape
		     */
		    SvPVX(tmpsv)[1] = *s;
		    curmad('_', tmpsv);
		}
d2513 1
a2513 12
#ifdef PERL_MAD
		if (PL_madskills) {
		    if (PL_thistoken)
			sv_free(PL_thistoken);
		    PL_thistoken = newSVpvs("");
		}
#endif
		/* commas only at base level: /$a\Ub$c/ => ($a,uc(b.$c)) */
		if (PL_lex_casemods == 1 && PL_lex_inpat)
		    OPERATOR(',');
		else
		    Aop(OP_CONCAT);
d2531 1
a2531 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = 0;
d2533 5
a2537 1
	    start_force(PL_curforce);
d2539 2
a2540 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = 0;
d2542 1
a2542 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = 0;
d2544 1
a2544 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = OP_JOIN;	/* emulate join($", ...) */
d2549 1
a2549 12
#ifdef PERL_MAD
	    if (PL_madskills) {
		if (PL_thistoken)
		    sv_free(PL_thistoken);
		PL_thistoken = newSVpvs("");
	    }
#endif
	    /* commas only at base level: /$a\Ub$c/ => ($a,uc(b.$c)) */
	    if (!PL_lex_casemods && PL_lex_inpat)
		OPERATOR(',');
	    else
		Aop(OP_CONCAT);
a2563 7
#ifdef PERL_MAD
	    if (PL_madskills) {
		if (PL_thistoken)
		    sv_free(PL_thistoken);
		PL_thistoken = newSVpvs("");
	    }
#endif
d2571 1
a2571 1
	    PL_lex_repl = NULL;
d2587 2
a2588 2
		sv = new_constant(NULL, 0, "qr", sv, sv, "q", 1);
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
d2600 1
a2600 5
	    start_force(PL_curforce);
	    if (PL_madskills) {
		curmad('X', newSVpvn(PL_bufptr,s-PL_bufptr));
	    }
	    NEXTVAL_NEXTTOKE = pl_yylval;
d2603 2
a2604 14
	    if (PL_lex_starts++) {
#ifdef PERL_MAD
		if (PL_madskills) {
		    if (PL_thistoken)
			sv_free(PL_thistoken);
		    PL_thistoken = newSVpvs("");
		}
#endif
		/* commas only at base level: /$a\Ub$c/ => ($a,uc(b.$c)) */
		if (!PL_lex_casemods && PL_lex_inpat)
		    OPERATOR(',');
		else
		    Aop(OP_CONCAT);
	    }
a2624 7
#ifdef PERL_MAD
    if (PL_thistoken) {
	sv_free(PL_thistoken);
	PL_thistoken = 0;
    }
    PL_realtokenstart = s - SvPVX(PL_linestr);	/* assume but undo on ws */
#endif
d2629 1
a2629 2
	len = UTF ? Perl_utf8_length(aTHX_ (U8 *) PL_linestart, (U8 *) s) : (STRLEN) (s - PL_linestart);
	Perl_croak(aTHX_ "Unrecognized character \\x%02X in column %d", *s & 255, (int) len + 1);
a2633 4
#ifdef PERL_MAD
	if (PL_madskills)
	    PL_faketokens = 0;
#endif
d2638 4
a2641 4
		yyerror((const char *)
			(PL_lex_formbrack
			 ? "Format not terminated"
			 : "Missing right curly or square bracket"));
d2654 9
a2662 27
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_faketokens = 1;
#endif
	    if (PL_perldb) {
		/* Generate a string of Perl code to load the debugger.
		 * If PERL5DB is set, it will return the contents of that,
		 * otherwise a compile-time require of perl5db.pl.  */

		const char * const pdb = PerlEnv_getenv("PERL5DB");

		if (pdb) {
		    sv_setpv(PL_linestr, pdb);
		    sv_catpvs(PL_linestr,";");
		} else {
		    SETERRNO(0,SS_NORMAL);
		    sv_setpvs(PL_linestr, "BEGIN { require 'perl5db.pl' };");
		}
	    } else
		sv_setpvs(PL_linestr,"");
	    if (PL_preambleav) {
		SV **svp = AvARRAY(PL_preambleav);
		SV **const end = svp + AvFILLp(PL_preambleav);
		while(svp <= end) {
		    sv_catsv(PL_linestr, *svp);
		    ++svp;
		    sv_catpvs(PL_linestr, ";");
d2668 1
a2668 1
		sv_catpvs(PL_linestr, "LINE: while (<>) {");
d2670 1
a2670 1
		    sv_catpvs(PL_linestr,"chomp;");
d2680 3
d2684 1
a2684 1
			    sv_catpvs(PL_linestr, "our @@F=split(q\0");
d2694 1
a2694 1
			    sv_catpvs(PL_linestr, ");");
d2698 1
a2698 1
		        sv_catpvs(PL_linestr,"our @@F=split(' ');");
d2701 1
a2701 3
	    if (PL_minus_E)
		sv_catpvs(PL_linestr,"use feature ':5.10';");
	    sv_catpvs(PL_linestr, "\n");
d2704 10
a2713 3
	    PL_last_lop = PL_last_uni = NULL;
	    if (PERLDB_LINE && PL_curstash != PL_debstash)
		update_debugger_info(PL_linestr, NULL, 0);
d2718 1
a2718 1
	    if ((s = filter_gets(PL_linestr, PL_rsfp, 0)) == NULL) {
a2719 3
#ifdef PERL_MAD
		PL_realtokenstart = -1;
#endif
d2727 1
a2727 1
		    PL_rsfp = NULL;
d2731 2
a2732 8
#ifdef PERL_MAD
		    if (PL_madskills)
			PL_faketokens = 1;
#endif
		    if (PL_minus_p)
			sv_setpvs(PL_linestr, ";}continue{print;}");
		    else
			sv_setpvs(PL_linestr, ";}");
d2735 1
a2735 1
		    PL_last_lop = PL_last_uni = NULL;
d2740 1
a2740 1
		PL_last_lop = PL_last_uni = NULL;
d2781 1
a2781 5
#ifdef PERL_MAD
		if (PL_madskills)
		    sv_catsv(PL_thiswhite, PL_linestr);
#endif
		if (*s == '=' && strnEQ(s, "=cut", 4) && !isALPHA(s[4])) {
d2785 1
a2785 1
		    PL_last_lop = PL_last_uni = NULL;
d2792 9
a2800 2
	if (PERLDB_LINE && PL_curstash != PL_debstash)
	    update_debugger_info(PL_linestr, NULL, 0);
d2802 1
a2802 1
	PL_last_lop = PL_last_uni = NULL;
d2808 1
a2808 5
#ifdef PERL_MAD
	    if (PL_madskills)
		PL_thiswhite = newSVpvn(PL_linestart, s - PL_linestart);
#endif
	    d = NULL;
d2839 1
a2839 2
		    SV * const x = GvSV(gv_fetchpvs("\030", GV_ADD|GV_NOTQUAL,
						    SVt_PV)); /* $^X */
d2880 1
a2880 1
			    d = NULL;
d2899 1
a2899 1
			d = NULL;	/* "perl" not in first word; ignore */
d2912 1
a2912 2
		    dVAR;
		    char **newargv;
d2936 6
a2941 4
		    while (*d && !isSPACE(*d))
			d++;
		    while (SPACE_OR_TAB(*d))
			d++;
a2944 5
			const U32 oldpdb = PL_perldb;
			const bool oldn = PL_minus_n;
			const bool oldp = PL_minus_p;
			const char *d1 = d;

d2946 3
a2948 4
			    if (*d1 == 'M' || *d1 == 'm' || *d1 == 'C') {
				const char * const m = d1;
				while (*d1 && !isSPACE(*d1))
				    d1++;
d2950 1
a2950 1
				      (int)(d1 - m), m);
d2952 2
a2953 2
			    d1 = moreswitches(d1);
			} while (d1);
d2970 1
a2970 1
			    PL_last_lop = PL_last_uni = NULL;
d2976 8
a3003 6
#ifdef PERL_MAD
	PL_realtokenstart = -1;
	if (!PL_thiswhite)
	    PL_thiswhite = newSVpvs("");
	sv_catpvn(PL_thiswhite, s, 1);
#endif
a3007 5
#ifdef PERL_MAD
	PL_realtokenstart = -1;
	if (PL_madskills)
	    PL_faketokens = 0;
#endif
d3014 8
a3021 20
	    if (PL_madskills && !PL_lex_formbrack && !PL_in_eval) {
		s = SKIPSPACE0(s);
		if (!PL_in_eval || PL_rsfp)
		    incline(s);
	    }
	    else {
		d = s;
		while (d < PL_bufend && *d != '\n')
		    d++;
		if (d < PL_bufend)
		    d++;
		else if (d > PL_bufend) /* Found by Ilya: feed random input to Perl. */
		  Perl_croak(aTHX_ "panic: input overflow");
#ifdef PERL_MAD
		if (PL_madskills)
		    PL_thiswhite = newSVpvn(s, d - s);
#endif
		s = d;
		incline(s);
	    }
a3028 33
#ifdef PERL_MAD
	    if (PL_madskills && CopLINE(PL_curcop) >= 1 && !PL_lex_formbrack) {
		if (CopLINE(PL_curcop) == 1 && s[0] == '#' && s[1] == '!') {
		    PL_faketokens = 0;
		    s = SKIPSPACE0(s);
		    TOKEN(PEG);	/* make sure any #! line is accessible */
		}
		s = SKIPSPACE0(s);
	    }
	    else {
/*		if (PL_madskills && PL_lex_formbrack) { */
		    d = s;
		    while (d < PL_bufend && *d != '\n')
			d++;
		    if (d < PL_bufend)
			d++;
		    else if (d > PL_bufend) /* Found by Ilya: feed random input to Perl. */
		      Perl_croak(aTHX_ "panic: input overflow");
		    if (PL_madskills && CopLINE(PL_curcop) >= 1) {
			if (!PL_thiswhite)
			    PL_thiswhite = newSVpvs("");
			if (CopLINE(PL_curcop) == 1) {
			    sv_setpvn(PL_thiswhite, "", 0);
			    PL_faketokens = 0;
			}
			sv_catpvn(PL_thiswhite, s, d - s);
		    }
		    s = d;
/*		}
		*s = '\0';
		PL_bufend = s; */
	    }
#else
a3030 1
#endif
a3035 1
	    char tmp;
d3046 3
a3048 1
		DEBUG_T( { printbuf("### Saw unary minus before =>, forcing word %s\n", s); } );
d3078 1
a3078 1
		gv_fetchpvs("\024", GV_ADD|GV_NOTQUAL, SVt_PV);
d3106 14
a3119 27
	{
	    const char tmp = *s++;
	    if (*s == tmp) {
		s++;
		if (PL_expect == XOPERATOR)
		    TERM(POSTDEC);
		else
		    OPERATOR(PREDEC);
	    }
	    else if (*s == '>') {
		s++;
		s = SKIPSPACE1(s);
		if (isIDFIRST_lazy_if(s,UTF)) {
		    s = force_word(s,METHOD,FALSE,TRUE,FALSE);
		    TOKEN(ARROW);
		}
		else if (*s == '$')
		    OPERATOR(ARROW);
		else
		    TERM(ARROW);
	    }
	    if (PL_expect == XOPERATOR)
		Aop(OP_SUBTRACT);
	    else {
		if (isSPACE(*s) || !isSPACE(*PL_bufptr))
		    check_uni();
		OPERATOR('-');		/* unary minus */
d3121 11
d3135 3
a3137 9
	{
	    const char tmp = *s++;
	    if (*s == tmp) {
		s++;
		if (PL_expect == XOPERATOR)
		    TERM(POSTINC);
		else
		    OPERATOR(PREINC);
	    }
d3139 10
a3148 6
		Aop(OP_ADD);
	    else {
		if (isSPACE(*s) || !isSPACE(*PL_bufptr))
		    check_uni();
		OPERATOR('+');
	    }
d3173 1
a3173 2
	s = scan_ident(s, PL_bufend, PL_tokenbuf + 1,
		sizeof PL_tokenbuf - 1, FALSE);
a3186 6
	if (s[1] == '~'
	    && (PL_expect == XOPERATOR || PL_expect == XTERMORDORDOR))
	{
	    s += 2;
	    Eop(OP_SMARTMATCH);
	}
d3188 2
a3189 4
	{
	    const char tmp = *s++;
	    OPERATOR(tmp);
	}
d3193 1
a3193 1
	    goto just_a_word_zero_gv;
a3197 3
#ifdef PERL_MAD
	    I32 stuffstart;
#endif
d3209 2
a3210 5
#ifdef PERL_MAD
	    stuffstart = s - SvPVX(PL_linestr) - 1;
#endif
	    s = PEEKSPACE(s);
	    attrs = NULL;
a3211 2
		I32 tmp;
		SV *sv;
d3213 1
a3213 1
		if (isLOWER(*s) && (tmp = keyword(PL_tokenbuf, len, 0))) {
a3227 1
		sv = newSVpvn(s, len);
a3237 1
			sv_free(sv);
d3242 1
d3247 1
a3247 1
		    PL_lex_stuff = NULL;
d3250 2
a3251 3
		    if (len == 6 && strnEQ(SvPVX(sv), "unique", len)) {
			sv_free(sv);
			if (PL_in_my == KEY_our) {
d3253 1
a3253 1
			    GvUNIQUE_on(cGVOPx_gv(pl_yylval.opval));
d3255 1
a3255 1
			    /* skip to avoid loading attributes.pm */
a3256 2
			    deprecate(":unique");
			}
d3263 1
a3263 2
		    else if (!PL_in_my && len == 6 && strnEQ(SvPVX(sv), "lvalue", len)) {
			sv_free(sv);
d3265 1
a3265 3
		    }
		    else if (!PL_in_my && len == 6 && strnEQ(SvPVX(sv), "locked", len)) {
			sv_free(sv);
d3267 1
a3267 3
		    }
		    else if (!PL_in_my && len == 6 && strnEQ(SvPVX(sv), "method", len)) {
			sv_free(sv);
a3268 1
		    }
d3282 1
a3282 1
					      	    sv));
d3284 1
a3284 1
		s = PEEKSPACE(d);
d3286 1
a3286 1
		    s = PEEKSPACE(s+1);
a3288 1
		/* XXX losing whitespace on sequential attributes here */
d3290 7
a3296 24
	    {
		const char tmp
		    = (PL_expect == XOPERATOR ? '=' : '{'); /*'}(' for vi */
		if (*s != ';' && *s != '}' && *s != tmp
		    && (tmp != '=' || *s != ')')) {
		    const char q = ((*s == '\'') ? '"' : '\'');
		    /* If here for an expression, and parsed no attrs, back
		       off. */
		    if (tmp == '=' && !attrs) {
			s = PL_bufptr;
			break;
		    }
		    /* MUST advance bufptr here to avoid bogus "at end of line"
		       context messages from yyerror().
		    */
		    PL_bufptr = s;
		    yyerror( (const char *)
			     (*s
			      ? Perl_form(aTHX_ "Invalid separator character "
					  "%c%c%c in attribute list", q, *s, q)
			      : "Unterminated attribute list" ) );
		    if (attrs)
			op_free(attrs);
		    OPERATOR(':');
d3298 12
d3313 1
a3313 3
		start_force(PL_curforce);
		NEXTVAL_NEXTTOKE.opval = attrs;
		CURMAD('_', PL_nextwhite);
a3315 6
#ifdef PERL_MAD
	    if (PL_madskills) {
		PL_thistoken = newSVpvn(SvPVX(PL_linestr) + stuffstart,
				     (s - SvPVX(PL_linestr)) - stuffstart);
	    }
#endif
d3325 1
a3325 1
	s = SKIPSPACE1(s);
d3329 2
a3330 4
	{
	    const char tmp = *s++;
	    OPERATOR(tmp);
	}
d3332 5
a3336 7
	{
	    const char tmp = *s++;
	    s = SKIPSPACE1(s);
	    if (*s == '{')
		PREBLOCK(tmp);
	    TERM(tmp);
	}
d3345 1
a3345 3
		if (*s == '-' && s[1] == '>')
		    PL_lex_state = LEX_INTERPENDMAYBE;
		else if (*s != '[' && *s != '{')
d3407 1
a3407 1
		s = SKIPSPACE1(s);
d3508 1
a3508 1
	pl_yylval.ival = CopLINE(PL_curcop);
a3526 7
#if 0
		    if (PL_madskills) {
			if (!PL_thiswhite)
			    PL_thiswhite = newSVpvs("");
			sv_catpvn(PL_thiswhite,"}",1);
		    }
#endif
a3539 5
	start_force(PL_curforce);
	if (PL_madskills) {
	    curmad('X', newSVpvn(s-1,1));
	    CURMAD('_', PL_thiswhite);
	}
a3540 4
#ifdef PERL_MAD
	if (!PL_thistoken)
	    PL_thistoken = newSVpvs("");
#endif
d3544 2
a3545 1
	if (*s++ == '&')
d3566 1
a3566 1
	pl_yylval.ival = (OPpENTERSUB_AMPER<<8);
d3571 2
a3572 1
	if (*s++ == '|')
d3578 12
d3591 13
a3603 30
	    const char tmp = *s++;
	    if (tmp == '=')
		Eop(OP_EQ);
	    if (tmp == '>')
		OPERATOR(',');
	    if (tmp == '~')
		PMop(OP_MATCH);
	    if (tmp && isSPACE(*s) && ckWARN(WARN_SYNTAX)
		&& strchr("+-*/%.^&|<",tmp))
		Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
			    "Reversed %c= operator",(int)tmp);
	    s--;
	    if (PL_expect == XSTATE && isALPHA(tmp) &&
		(s == PL_linestart+1 || s[-2] == '\n') )
		{
		    if (PL_in_eval && !PL_rsfp) {
			d = PL_bufend;
			while (s < d) {
			    if (*s++ == '\n') {
				incline(s);
				if (strnEQ(s,"=cut",4)) {
				    s = strchr(s,'\n');
				    if (s)
					s++;
				    else
					s = d;
				    incline(s);
				    goto retry;
				}
			    }
a3604 1
			goto retry;
a3605 11
#ifdef PERL_MAD
		    if (PL_madskills) {
			if (!PL_thiswhite)
			    PL_thiswhite = newSVpvs("");
			sv_catpvn(PL_thiswhite, PL_linestart,
				  PL_bufend - PL_linestart);
		    }
#endif
		    s = PL_bufend;
		    PL_doextract = TRUE;
		    goto retry;
d3607 5
d3614 1
a3614 1
	    const char *t = s;
d3616 1
a3616 1
	    while (SPACE_OR_TAB(*t))
d3618 1
a3618 1
	    while (SPACE_OR_TAB(*t) || *t == '\r')
a3619 1
		t++;
d3626 1
a3626 1
	pl_yylval.ival = 0;
d3630 5
a3634 24
	{
	    const char tmp = *s++;
	    if (tmp == '=') {
		/* was this !=~ where !~ was meant?
		 * warn on m:!=~\s+([/?]|[msy]\W|tr\W): */

		if (*s == '~' && ckWARN(WARN_SYNTAX)) {
		    const char *t = s+1;

		    while (t < PL_bufend && isSPACE(*t))
			++t;

		    if (*t == '/' || *t == '?' ||
			((*t == 'm' || *t == 's' || *t == 'y')
			 && !isALNUM(t[1])) ||
			(*t == 't' && t[1] == 'r' && !isALNUM(t[2])))
			Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
				    "!=~ should be !~");
		}
		Eop(OP_NE);
	    }
	    if (tmp == '~')
		PMop(OP_NOT);
	}
d3648 9
a3656 11
	{
	    char tmp = *s++;
	    if (tmp == '<')
		SHop(OP_LEFT_SHIFT);
	    if (tmp == '=') {
		tmp = *s++;
		if (tmp == '>')
		    Eop(OP_NCMP);
		s--;
		Rop(OP_LE);
	    }
d3662 5
a3666 7
	{
	    const char tmp = *s++;
	    if (tmp == '>')
		SHop(OP_RIGHT_SHIFT);
	    else if (tmp == '=')
		Rop(OP_GE);
	}
d3676 1
a3676 1
		deprecate_old(commaless_variable_list);
d3707 3
a3709 3
	    pl_yylval.opval = newSVOP(OP_CONST, 0,
				   newSViv(CopARYBASE_get(&PL_compiling)));
	    pl_yylval.opval->op_private = OPpCONST_ARYBASE;
d3714 3
a3716 11
	{
	    const char tmp = *s;
	    if (PL_lex_state == LEX_NORMAL)
		s = SKIPSPACE1(s);

	    if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop)
		&& intuit_more(s)) {
		if (*s == '[') {
		    PL_tokenbuf[0] = '@@';
		    if (ckWARN(WARN_SYNTAX)) {
			char *t = s+1;
d3718 11
a3728 1
			while (isSPACE(*t) || isALNUM_lazy_if(t,UTF) || *t == '$')
d3730 19
a3748 4
			if (*t++ == ',') {
			    PL_bufptr = PEEKSPACE(PL_bufptr); /* XXX can realloc */
			    while (t < PL_bufend && *t != ']')
				t++;
d3750 1
a3750 3
					"Multidimensional syntax %.*s not supported",
				    (int)((t - PL_bufptr) + 1), PL_bufptr);
			}
a3752 23
		else if (*s == '{') {
		    char *t;
		    PL_tokenbuf[0] = '%';
		    if (strEQ(PL_tokenbuf+1, "SIG")  && ckWARN(WARN_SYNTAX)
			&& (t = strchr(s, '}')) && (t = strchr(t, '=')))
			{
			    char tmpbuf[sizeof PL_tokenbuf];
			    do {
				t++;
			    } while (isSPACE(*t));
			    if (isIDFIRST_lazy_if(t,UTF)) {
				STRLEN len;
				t = scan_word(t, tmpbuf, sizeof tmpbuf, TRUE,
					      &len);
				while (isSPACE(*t))
				    t++;
				if (*t == ';' && get_cvn_flags(tmpbuf, len, 0))
				    Perl_warner(aTHX_ packWARN(WARN_SYNTAX),
						"You need to quote \"%s\"",
						tmpbuf);
			    }
			}
		}
d3754 1
d3756 27
a3782 32
	    PL_expect = XOPERATOR;
	    if (PL_lex_state == LEX_NORMAL && isSPACE((char)tmp)) {
		const bool islop = (PL_last_lop == PL_oldoldbufptr);
		if (!islop || PL_last_lop_op == OP_GREPSTART)
		    PL_expect = XOPERATOR;
		else if (strchr("$@@\"'`q", *s))
		    PL_expect = XTERM;		/* e.g. print $fh "foo" */
		else if (strchr("&*<%", *s) && isIDFIRST_lazy_if(s+1,UTF))
		    PL_expect = XTERM;		/* e.g. print $fh &sub */
		else if (isIDFIRST_lazy_if(s,UTF)) {
		    char tmpbuf[sizeof PL_tokenbuf];
		    int t2;
		    scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
		    if ((t2 = keyword(tmpbuf, len, 0))) {
			/* binary operators exclude handle interpretations */
			switch (t2) {
			case -KEY_x:
			case -KEY_eq:
			case -KEY_ne:
			case -KEY_gt:
			case -KEY_lt:
			case -KEY_ge:
			case -KEY_le:
			case -KEY_cmp:
			    break;
			default:
			    PL_expect = XTERM;	/* e.g. print $fh length() */
			    break;
			}
		    }
		    else {
			PL_expect = XTERM;	/* e.g. print $fh subr() */
d3785 3
a3787 15
		else if (isDIGIT(*s))
		    PL_expect = XTERM;		/* e.g. print $fh 3 */
		else if (*s == '.' && isDIGIT(s[1]))
		    PL_expect = XTERM;		/* e.g. print $fh .3 */
		else if ((*s == '?' || *s == '-' || *s == '+')
			 && !isSPACE(s[1]) && s[1] != '=')
		    PL_expect = XTERM;		/* e.g. print $fh -1 */
		else if (*s == '/' && !isSPACE(s[1]) && s[1] != '='
			 && s[1] != '/')
		    PL_expect = XTERM;		/* e.g. print $fh /.../
						   XXX except DORDOR operator
						*/
		else if (*s == '<' && s[1] == '<' && !isSPACE(s[2])
			 && s[2] != '=')
		    PL_expect = XTERM;		/* print $fh <<"EOF" */
d3789 9
d3811 1
a3811 1
	    s = SKIPSPACE1(s);
d3824 1
a3824 1
			PL_bufptr = PEEKSPACE(PL_bufptr); /* XXX can realloc */
d3827 1
a3827 2
			    (int)(t-PL_bufptr), PL_bufptr,
			    (int)(t-PL_bufptr-1), PL_bufptr+1);
d3835 11
a3845 4
     case '/':			/* may be division, defined-or, or pattern */
	if (PL_expect == XTERMORDORDOR && s[1] == '/') {
	    s += 2;
	    AOPERATOR(DORDOR);
d3847 4
a3850 29
     case '?':			/* may either be conditional or pattern */
	 if(PL_expect == XOPERATOR) {
	     char tmp = *s++;
	     if(tmp == '?') {
    	          OPERATOR('?');
	     }
             else {
	         tmp = *s++;
	         if(tmp == '/') {
	             /* A // operator. */
	            AOPERATOR(DORDOR);
	         }
	         else {
	             s--;
	             Mop(OP_DIVIDE);
	         }
	     }
	 }
	 else {
	     /* Disable warning on "study /blah/" */
	     if (PL_oldoldbufptr == PL_last_uni
	      && (*PL_last_uni != 's' || s - PL_last_uni < 5
	          || memNE(PL_last_uni, "study", 5)
	          || isALNUM_lazy_if(PL_last_uni+5,UTF)
	      ))
	         check_uni();
	     s = scan_pat(s,OP_MATCH);
	     TERM(sublex_start());
	 }
d3866 1
a3866 1
	    char tmp = *s++;
d3871 1
a3871 1
		    pl_yylval.ival = OPf_SPECIAL;
d3874 1
a3874 1
		    pl_yylval.ival = 0;
d3884 2
a3885 2
	s = scan_num(s, &pl_yylval);
	DEBUG_T( { printbuf("### Saw number in %s\n", s); } );
d3891 2
a3892 2
	s = scan_str(s,!!PL_madskills,FALSE);
	DEBUG_T( { printbuf("### Saw string before %s\n", s); } );
d3896 1
a3896 1
		deprecate_old(commaless_variable_list);
d3903 2
a3904 2
	    missingterm(NULL);
	pl_yylval.ival = OP_CONST;
d3908 2
a3909 2
	s = scan_str(s,!!PL_madskills,FALSE);
	DEBUG_T( { printbuf("### Saw string before %s\n", s); } );
d3913 1
a3913 1
		deprecate_old(commaless_variable_list);
d3920 2
a3921 2
	    missingterm(NULL);
	pl_yylval.ival = OP_CONST;
d3926 1
a3926 1
		pl_yylval.ival = OP_STRINGIFY;
d3933 2
a3934 2
	s = scan_str(s,!!PL_madskills,FALSE);
	DEBUG_T( { printbuf("### Saw backtick string before %s\n", s); } );
d3938 3
a3940 2
	    missingterm(NULL);
	readpipe_override();
d3958 1
a3958 1
		s = scan_num(s, &pl_yylval);
d3962 6
a3967 4
	    else if (!isALPHA(*start) && (PL_expect == XTERM
			|| PL_expect == XREF || PL_expect == XSTATE
			|| PL_expect == XTERMORDORDOR)) {
		GV *const gv = gv_fetchpvn_flags(s, start - s, 0, SVt_PVCV);
d3969 1
a3969 1
		    s = scan_num(s, &pl_yylval);
a4010 2
	I32 tmp;

d4012 2
a4013 2
	gv = NULL;
	gvp = NULL;
d4036 1
a4036 1
	    pl_yylval.pval = CopLABEL_alloc(PL_tokenbuf);
d4042 1
a4042 1
	tmp = keyword(PL_tokenbuf, len, 0);
d4047 4
a4050 4
	    pl_yylval.opval
		= (OP*)newSVOP(OP_CONST, 0,
			       S_newSV_maybe_utf8(aTHX_ PL_tokenbuf, len));
	    pl_yylval.opval->op_private = OPpCONST_BARE;
d4055 2
a4056 2
	    GV *ogv = NULL;	/* override (winner) */
	    GV *hgv = NULL;	/* hidden (loser) */
d4059 1
a4059 1
		if ((gv = gv_fetchpvn_flags(PL_tokenbuf, len, 0, SVt_PVCV)) &&
d4069 1
a4069 1
		    (gv = *gvp) && isGV_with_GP(gv) &&
d4081 2
a4082 1
		     && GvCVu(gv))
d4092 1
a4092 1
		gv = NULL;
a4105 10
	    /* Trade off - by using this evil construction we can pull the
	       variable gv into the block labelled keylookup. If not, then
	       we have to give it function scope so that the goto from the
	       earlier ':' case doesn't bypass the initialisation.  */
	    if (0) {
	    just_a_word_zero_gv:
		gv = NULL;
		gvp = NULL;
		orig_keyword = 0;
	    }
a4109 5
		CV *cv;
#ifdef PERL_MAD
		SV *nextPL_nextwhite = 0;
#endif

d4138 1
a4138 1
		if (len > 2 && !PL_madskills &&
d4141 1
a4141 2
		    if (ckWARN(WARN_BAREWORD)
			&& ! gv_fetchpvn_flags(PL_tokenbuf, len, 0, SVt_PVHV))
d4147 1
a4147 1
		    gv = NULL;
a4150 8
		    if (!gv) {
			/* Mustn't actually add anything to a symbol table.
			   But also don't want to "initialise" any placeholder
			   constants that might already be there into full
			   blown PVGVs with attached PVCV.  */
			gv = gv_fetchpvn_flags(PL_tokenbuf, len,
					       GV_NOADD_NOINIT, SVt_PVCV);
		    }
d4152 2
d4159 1
a4159 1
		    sv = newSVpvs("CORE::GLOBAL::");
a4167 7
#ifdef PERL_MAD
		if (PL_madskills && !PL_thistoken) {
		    char *start = SvPVX(PL_linestr) + PL_realtokenstart;
		    PL_thistoken = newSVpvn(start,s - start);
		    PL_realtokenstart = s - SvPVX(PL_linestr);
		}
#endif
d4172 2
a4173 2
		pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sv);
		pl_yylval.opval->op_private = OPpCONST_BARE;
a4183 14
		/* Do the explicit type check so that we don't need to force
		   the initialisation of the symbol table to have a real GV.
		   Beware - gv may not really be a PVGV, cv may not really be
		   a PVCV, (because of the space optimisations that gv_init
		   understands) But they're true if for this symbol there is
		   respectively a typeglob and a subroutine.
		*/
		cv = gv ? ((SvTYPE(gv) == SVt_PVGV)
		    /* Real typeglob, so get the real subroutine: */
			   ? GvCVu(gv)
		    /* A proxy for a subroutine in this package? */
			   : SvOK(gv) ? (CV *) gv : NULL)
		    : NULL;

d4197 1
a4197 4
		    s = SKIPSPACE2(s,nextPL_nextwhite);
#ifdef PERL_MAD
		    PL_nextwhite = nextPL_nextwhite;	/* assume no & deception */
#endif
d4201 1
a4201 2
		    if ((isIDFIRST_lazy_if(s,UTF) || *s == '$') &&
			(tmp = intuit_method(s, gv, cv)))
a4205 1
		    /* Also, if "_" follows a filetest operator, it's a bareword */
d4207 2
a4208 3
		    if (
			( !immediate_paren && (PL_last_lop_op == OP_SORT ||
                         ((!gv || !cv) &&
a4210 3
		       || (PL_tokenbuf[0] == '_' && PL_tokenbuf[1] == '\0'
			    && ((PL_opargs[PL_last_lop_op] & OA_CLASS_MASK) == OA_FILESTATOP))
		       )
a4217 5
#ifdef PERL_MAD
		if (isSPACE(*s))
		    s = SKIPSPACE2(s,nextPL_nextwhite);
		PL_nextwhite = nextPL_nextwhite;
#else
a4218 1
#endif
d4223 1
a4223 1
		    sv_setpv(((SVOP*)pl_yylval.opval)->op_sv, PL_tokenbuf);
d4225 1
a4225 1
		      SvUTF8_on(((SVOP*)pl_yylval.opval)->op_sv);
d4232 3
a4234 5
		    if (cv) {
			d = s + 1;
			while (SPACE_OR_TAB(*d))
			    d++;
			if (*d == ')' && (sv = gv_const_sv(gv))) {
d4239 1
a4239 8
#ifdef PERL_MAD
		    if (PL_madskills) {
			PL_nextwhite = PL_thiswhite;
			PL_thiswhite = 0;
		    }
		    start_force(PL_curforce);
#endif
		    NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
a4240 7
#ifdef PERL_MAD
		    if (PL_madskills) {
			PL_nextwhite = nextPL_nextwhite;
			curmad('X', PL_thistoken);
			PL_thistoken = newSVpvs("");
		    }
#endif
d4242 1
a4242 1
		    pl_yylval.ival = 0;
d4248 1
a4248 1
		if ((*s == '$' || *s == '{') && (!gv || !cv)) {
d4258 1
a4258 1
			&& (tmp = intuit_method(s, gv, cv)))
d4263 2
a4264 1
		if (cv) {
d4270 2
a4271 1
		    if ((sv = gv_const_sv(gv))) {
d4273 3
a4275 3
			SvREFCNT_dec(((SVOP*)pl_yylval.opval)->op_sv);
			((SVOP*)pl_yylval.opval)->op_sv = SvREFCNT_inc_simple(sv);
			pl_yylval.opval->op_private = 0;
d4280 3
a4282 11
		    if (SvTYPE(gv) != SVt_PVGV) {
			gv = gv_fetchpv(PL_tokenbuf, 0, SVt_PVCV);
			assert (SvTYPE(gv) == SVt_PVGV);
			/* cv must have been some sort of placeholder, so
			   now needs replacing with a real code reference.  */
			cv = GvCV(gv);
		    }

		    op_free(pl_yylval.opval);
		    pl_yylval.opval = newCVREF(0, newGVOP(OP_GV, 0, gv));
		    pl_yylval.opval->op_private |= OPpENTERSUB_NOPAREN;
d4286 4
a4289 9
		    if (
#ifdef PERL_MAD
			cv &&
#endif
			SvPOK(cv))
		    {
			STRLEN protolen;
			const char *proto = SvPV_const((SV*)cv, protolen);
			if (!protolen)
d4291 1
a4291 1
			if ((*proto == '$' || *proto == '_') && proto[1] == '\0')
d4296 2
a4297 4
			    if (PL_curstash)
				sv_setpvs(PL_subname, "__ANON__");
			    else
				sv_setpvs(PL_subname, "__ANON__::__ANON__");
d4301 1
a4301 58
#ifdef PERL_MAD
		    {
			if (PL_madskills) {
			    PL_nextwhite = PL_thiswhite;
			    PL_thiswhite = 0;
			}
			start_force(PL_curforce);
			NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
			PL_expect = XTERM;
			if (PL_madskills) {
			    PL_nextwhite = nextPL_nextwhite;
			    curmad('X', PL_thistoken);
			    PL_thistoken = newSVpvs("");
			}
			force_next(WORD);
			TOKEN(NOAMP);
		    }
		}

		/* Guess harder when madskills require "best effort". */
		if (PL_madskills && (!gv || !GvCVu(gv))) {
		    int probable_sub = 0;
		    if (strchr("\"'`$@@%0123456789!*+{[<", *s))
			probable_sub = 1;
		    else if (isALPHA(*s)) {
			char tmpbuf[1024];
			STRLEN tmplen;
			d = s;
			d = scan_word(d, tmpbuf, sizeof tmpbuf, TRUE, &tmplen);
			if (!keyword(tmpbuf, tmplen, 0))
			    probable_sub = 1;
			else {
			    while (d < PL_bufend && isSPACE(*d))
				d++;
			    if (*d == '=' && d[1] == '>')
				probable_sub = 1;
			}
		    }
		    if (probable_sub) {
			gv = gv_fetchpv(PL_tokenbuf, GV_ADD, SVt_PVCV);
			op_free(pl_yylval.opval);
			pl_yylval.opval = newCVREF(0, newGVOP(OP_GV, 0, gv));
			pl_yylval.opval->op_private |= OPpENTERSUB_NOPAREN;
			PL_last_lop = PL_oldbufptr;
			PL_last_lop_op = OP_ENTERSUB;
			PL_nextwhite = PL_thiswhite;
			PL_thiswhite = 0;
			start_force(PL_curforce);
			NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
			PL_expect = XTERM;
			PL_nextwhite = nextPL_nextwhite;
			curmad('X', PL_thistoken);
			PL_thistoken = newSVpvs("");
			force_next(WORD);
			TOKEN(NOAMP);
		    }
#else
		    NEXTVAL_NEXTTOKE.opval = pl_yylval.opval;
a4304 1
#endif
d4310 1
a4310 1
		    pl_yylval.opval->op_private |= OPpCONST_STRICT;
d4315 2
a4316 4
			    d = PL_tokenbuf;
			    while (isLOWER(*d))
				d++;
			    if (!*d && !gv_stashpv(PL_tokenbuf, 0))
d4337 1
a4337 1
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d4342 1
a4342 1
            pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d4347 1
a4347 1
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
d4349 1
a4349 1
					 ? newSVhek(HvNAME_HEK(PL_curstash))
d4360 1
a4360 2
		gv = gv_fetchpv(Perl_form(aTHX_ "%s::DATA", pname), GV_ADD,
				SVt_PVIO);
d4426 1
a4426 1
						      SVfARG(name)));
d4432 1
a4432 16
#ifdef PERL_MAD
		if (PL_madskills) {
		    if (PL_realtokenstart >= 0) {
			char *tstart = SvPVX(PL_linestr) + PL_realtokenstart;
			if (!PL_endwhite)
			    PL_endwhite = newSVpvs("");
			sv_catsv(PL_endwhite, PL_thiswhite);
			PL_thiswhite = 0;
			sv_catpvn(PL_endwhite, tstart, PL_bufend - tstart);
			PL_realtokenstart = -1;
		    }
		    while ((s = filter_gets(PL_endwhite, PL_rsfp,
				 SvCUR(PL_endwhite))) != NULL) ;
		}
#endif
		PL_rsfp = NULL;
a4439 1
	case KEY_UNITCHECK:
d4454 1
a4454 1
		if (!(tmp = keyword(PL_tokenbuf, len, 0)))
a4457 3
		else if (tmp == KEY_require || tmp == KEY_do)
		    /* that's a way to remember we saw "CORE::" */
		    orig_keyword = tmp;
a4485 3
	case KEY_break:
	    FUN0(OP_BREAK);

a4489 13
	    /* When 'use switch' is in effect, continue has a dual
	       life as a control operator. */
	    {
		if (!FEATURE_IS_ENABLED("switch"))
		    PREBLOCK(CONTINUE);
		else {
		    /* We have to disambiguate the two senses of
		      "continue". If the next token is a '{' then
		      treat it as the start of a continue block;
		      otherwise treat it as a control operator.
		     */
		    s = skipspace(s);
		    if (*s == '{')
a4490 4
		    else
			FUN0(OP_CONTINUE);
		}
	    }
d4493 1
a4493 2
	    /* may use HOME */
	    (void)gv_fetchpvs("ENV", GV_ADD|GV_NOTQUAL, SVt_PVHV);
a4534 3
	case KEY_default:
	    PREBLOCK(DEFAULT);

d4536 1
a4536 1
	    s = SKIPSPACE1(s);
a4540 6
	    if (orig_keyword == KEY_do) {
		orig_keyword = 0;
		pl_yylval.ival = 1;
	    }
	    else
		pl_yylval.ival = 0;
d4554 1
a4554 1
	    gv_fetchpvs("AnyDBM_File::ISA", GV_ADDMULTI, SVt_PVAV);
d4568 1
a4568 1
	    pl_yylval.ival = CopLINE(PL_curcop);
a4577 2
	    if (PL_madskills)
		UNI(OP_INT);
d4581 1
a4581 1
	    s = SKIPSPACE1(s);
d4595 1
d4618 2
a4619 2
	    pl_yylval.ival = CopLINE(PL_curcop);
	    s = SKIPSPACE1(s);
a4621 4
#ifdef PERL_MAD
		int soff = s - SvPVX(PL_linestr); /* for skipspace realloc */
#endif

d4628 1
a4628 1
		p = PEEKSPACE(p);
d4632 1
a4632 1
		    p = PEEKSPACE(p);
a4635 3
#ifdef PERL_MAD
		s = SvPVX(PL_linestr) + soff;
#endif
d4671 1
a4671 1
	    UNIDOR(OP_GETC);
a4747 4
	case KEY_given:
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(GIVEN);

d4749 1
d4756 1
a4756 1
	    pl_yylval.ival = CopLINE(PL_curcop);
d4788 1
a4788 1
	    pl_yylval.ival = 0;
d4842 2
a4843 3
	case KEY_state:
	    PL_in_my = (U16)tmp;
	    s = SKIPSPACE1(s);
a4844 3
#ifdef PERL_MAD
		char* start = s;
#endif
d4852 1
a4852 1
		    my_snprintf(tmpbuf, sizeof(tmpbuf), "No such class %.1000s", PL_tokenbuf);
a4854 7
#ifdef PERL_MAD
		if (PL_madskills) {	/* just add type to declarator token */
		    sv_catsv(PL_thistoken, PL_nextwhite);
		    PL_nextwhite = 0;
		    sv_catpvn(PL_thistoken, start, s - start);
		}
#endif
d4856 1
a4856 1
	    pl_yylval.ival = 1;
d4867 5
a4871 1
	    s = tokenize_use(0, s);
d4875 1
a4875 1
	    if (*s == '(' || (s = SKIPSPACE1(s), *s == '('))
d4881 1
a4881 1
	    s = SKIPSPACE1(s);
d4884 2
a4885 4
		for (d = s; isALNUM_lazy_if(d,UTF);)
		    d++;
		for (t=d; isSPACE(*t);)
		    t++;
d4890 1
a4890 1
		    int parms_len = (int)(d-s);
d4893 1
a4893 1
			    parms_len, s, parms_len, s);
d4899 1
a4899 1
	    pl_yylval.ival = OP_OR;
d4926 1
a4926 1
	    UNIDOR(OP_POP);
d4929 1
a4929 1
	    UNIDOR(OP_POS);
d4942 1
a4942 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d4944 2
a4945 2
		missingterm(NULL);
	    pl_yylval.ival = OP_CONST;
d4952 1
a4952 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d4954 1
a4954 1
		missingterm(NULL);
d4958 1
a4958 1
		OP *words = NULL;
d4962 2
a4963 2
		    for (; isSPACE(*d) && len; --len, ++d)
			/**/;
a4964 1
			SV *sv;
d4981 1
a4981 2
			    for (; !isSPACE(*d) && len; --len, ++d)
				/**/;
d4991 1
a4991 2
		    start_force(PL_curforce);
		    NEXTVAL_NEXTTOKE.opval = words;
d4997 1
a4997 1
		PL_lex_stuff = NULL;
d5003 1
a5003 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d5005 2
a5006 2
		missingterm(NULL);
	    pl_yylval.ival = OP_STRINGIFY;
d5016 1
a5016 1
	    s = scan_str(s,!!PL_madskills,FALSE);
d5018 3
a5020 2
		missingterm(NULL);
	    readpipe_override();
d5027 1
a5027 1
	    s = SKIPSPACE1(s);
d5037 1
a5037 1
		    gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf), GV_ADD);
d5041 1
a5041 12
	    if (orig_keyword == KEY_require) {
		orig_keyword = 0;
		pl_yylval.ival = 1;
	    }
	    else 
		pl_yylval.ival = 0;
	    PL_expect = XTERM;
	    PL_bufptr = s;
	    PL_last_uni = PL_oldbufptr;
	    PL_last_lop_op = OP_REQUIRE;
	    s = skipspace(s);
	    return REPORT( (int)REQUIRE );
d5069 2
a5070 1
	    UNIDOR(OP_READLINE);
d5073 2
a5074 1
	    UNIDOR(OP_BACKTICK);
d5086 1
a5086 1
	    UNIDOR(OP_READLINK);
d5093 1
a5093 1
	    if (pl_yylval.opval)
a5097 4
	case KEY_say:
	    checkcomma(s,PL_tokenbuf,"filehandle");
	    LOP(OP_SAY,XREF);

d5153 1
a5153 1
	    UNIDOR(OP_SHIFT);
d5184 1
a5184 1
	    s = SKIPSPACE1(s);
d5222 1
a5222 1
		bool have_name, have_proto;
a5224 10
#ifdef PERL_MAD
		SV *tmpwhite = 0;

		char *tstart = SvPVX(PL_linestr) + PL_realtokenstart;
		SV *subtoken = newSVpvn(tstart, s - tstart);
		PL_thistoken = 0;

		d = s;
		s = SKIPSPACE2(s,tmpwhite);
#else
a5225 1
#endif
a5229 4
#ifdef PERL_MAD
		    SV *nametoke;
#endif

d5235 2
a5236 6
#ifdef PERL_MAD
		    if (PL_madskills)
			nametoke = newSVpvn(s, d - s);
#endif
		    if (memchr(tmpbuf, ':', len))
			sv_setpvn(PL_subname, tmpbuf, len);
d5239 1
a5239 1
			sv_catpvs(PL_subname,"::");
d5242 1
a5243 13

#ifdef PERL_MAD

		    start_force(0);
		    CURMAD('X', nametoke);
		    CURMAD('_', tmpwhite);
		    (void) force_word(PL_oldbufptr + tboffset, WORD,
				      FALSE, TRUE, TRUE);

		    s = SKIPSPACE2(d,tmpwhite);
#else
		    s = skipspace(d);
#endif
a5256 4
#ifdef PERL_MAD
		    PL_thistoken = subtoken;
		    s = d;
#else
a5259 1
#endif
a5265 2
		    bool bad_proto = FALSE;
		    const bool warnsyntax = ckWARN(WARN_SYNTAX);
d5267 1
a5267 1
		    s = scan_str(s,!!PL_madskills,FALSE);
d5273 1
d5277 1
a5277 1
			    if (warnsyntax && !strchr("$@@%*;[]&\\_", *p))
d5282 1
a5282 1
		    if (bad_proto)
d5285 1
a5285 1
				    SVfARG(PL_subname), d);
a5288 13
#ifdef PERL_MAD
		    start_force(0);
		    CURMAD('q', PL_thisopen);
		    CURMAD('_', tmpwhite);
		    CURMAD('=', PL_thisstuff);
		    CURMAD('Q', PL_thisclose);
		    NEXTVAL_NEXTTOKE.opval =
			(OP*)newSVOP(OP_CONST, 0, PL_lex_stuff);
		    PL_lex_stuff = NULL;
		    force_next(THING);

		    s = SKIPSPACE2(s,tmpwhite);
#else
a5289 1
#endif
d5300 1
a5300 1
			Perl_croak(aTHX_ "Illegal declaration of subroutine %"SVf, SVfARG(PL_subname));
a5302 11
#ifdef PERL_MAD
		start_force(0);
		if (tmpwhite) {
		    if (PL_madskills)
			curmad('^', newSVpvs(""));
		    CURMAD('_', tmpwhite);
		}
		force_next(0);

		PL_thistoken = subtoken;
#else
d5304 1
a5304 1
		    NEXTVAL_NEXTTOKE.opval =
d5306 1
a5306 1
		    PL_lex_stuff = NULL;
a5308 1
#endif
d5310 2
a5311 4
		    if (PL_curstash)
			sv_setpvs(PL_subname, "__ANON__");
		    else
			sv_setpvs(PL_subname, "__ANON__::__ANON__");
a5313 1
#ifndef PERL_MAD
a5315 1
#endif
d5322 1
d5378 1
a5378 1
	    pl_yylval.ival = CopLINE(PL_curcop);
d5382 1
a5382 1
	    pl_yylval.ival = CopLINE(PL_curcop);
d5389 1
a5389 1
	    UNIDOR(OP_UNDEF);
d5398 1
a5398 1
	    UNIDOR(OP_UMASK);
d5402 21
a5422 3

	case KEY_use:
	    s = tokenize_use(1, s);
a5430 4
	case KEY_when:
	    pl_yylval.ival = CopLINE(PL_curcop);
	    OPERATOR(WHEN);

d5432 1
a5432 1
	    pl_yylval.ival = CopLINE(PL_curcop);
d5454 1
a5454 1
	    gv_fetchpvn_flags(ctl_l, 1, GV_ADD|GV_NOTQUAL, SVt_PV);
d5457 1
a5457 2
	    /* Make sure $^L is defined */
	    gv_fetchpvs("\f", GV_ADD|GV_NOTQUAL, SVt_PV);
d5468 1
a5468 1
	    pl_yylval.ival = OP_XOR;
a5483 1
    dVAR;
d5485 1
a5485 1
    PADOFFSET tmp = 0;
a5487 3
    const STRLEN tokenbuf_len = strlen(PL_tokenbuf);
    /* All routes through this function want to know if there is a colon.  */
    const char *const has_colon = (const char*) memchr (PL_tokenbuf, ':', tokenbuf_len);
a5489 1
    /* PL_realtokenstart = realtokenend = PL_bufptr - SvPVX(PL_linestr); */
d5501 1
a5501 1
            if (has_colon)
d5508 2
a5509 3
            if (has_colon)
                yyerror(Perl_form(aTHX_ PL_no_myglob,
			    PL_in_my == KEY_my ? "my" : "state", PL_tokenbuf));
d5511 2
a5512 2
            pl_yylval.opval = newOP(OP_PADANY, 0);
            pl_yylval.opval->op_targ = allocmy(PL_tokenbuf);
d5529 12
a5540 1
    if (!has_colon) {
d5545 1
a5545 1
            if (PAD_COMPNAME_FLAGS_isOUR(tmp)) {
d5547 7
a5553 8
		HV *  const stash = PAD_COMPNAME_OURSTASH(tmp);
		HEK * const stashname = HvNAME_HEK(stash);
		SV *  const sym = newSVhek(stashname);
                sv_catpvs(sym, "::");
                sv_catpvn(sym, PL_tokenbuf+1, tokenbuf_len - 1);
                pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, sym);
                pl_yylval.opval->op_private = OPpCONST_ENTERED;
                gv_fetchsv(sym,
d5581 2
a5582 2
            pl_yylval.opval = newOP(OP_PADANY, 0);
            pl_yylval.opval->op_targ = tmp;
d5593 1
a5593 2
        GV *const gv = gv_fetchpvn_flags(PL_tokenbuf + 1, tokenbuf_len - 1, 0,
					 SVt_PVAV);
d5595 1
a5595 5
		&& ckWARN(WARN_AMBIGUOUS)
		/* DO NOT warn for @@- and @@+ */
		&& !( PL_tokenbuf[2] == '\0' &&
		    ( PL_tokenbuf[1] == '-' || PL_tokenbuf[1] == '+' ))
	   )
d5605 6
a5610 25
    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpvn(PL_tokenbuf + 1,
						      tokenbuf_len - 1));
    pl_yylval.opval->op_private = OPpCONST_ENTERED;
    gv_fetchpvn_flags(
	    PL_tokenbuf + 1, tokenbuf_len - 1,
	    /* If the identifier refers to a stash, don't autovivify it.
	     * Change 24660 had the side effect of causing symbol table
	     * hashes to always be defined, even if they were freshly
	     * created and the only reference in the entire program was
	     * the single statement with the defined %foo::bar:: test.
	     * It appears that all code in the wild doing this actually
	     * wants to know whether sub-packages have been loaded, so
	     * by avoiding auto-vivifying symbol tables, we ensure that
	     * defined %foo::bar:: continues to be false, and the existing
	     * tests still give the expected answers, even though what
	     * they're actually testing has now changed subtly.
	     */
	    (*PL_tokenbuf == '%'
	     && *(d = PL_tokenbuf + tokenbuf_len - 1) == ':'
	     && d[-1] == ':'
	     ? 0
	     : PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : GV_ADD),
	    ((PL_tokenbuf[0] == '$') ? SVt_PV
	     : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
	     : SVt_PVHV));
d5619 1
a5619 1
Perl_keyword (pTHX_ const char *name, I32 len, bool all_keywords)
a5620 1
    dVAR;
d5801 1
a5801 1
    case 3: /* 29 tokens of length 3 */
a6017 8
            case 'a':
              if (name[2] == 'y')
              {                                   /* say        */
                return (all_keywords || FEATURE_IS_ENABLED("say") ? KEY_say : 0);
              }

              goto unknown;

d6078 1
a6078 1
    case 4: /* 41 tokens of length 4 */
d6508 1
a6508 1
          switch (name[1])
d6510 7
a6516 8
            case 'a':
              switch (name[2])
              {
                case 'i':
                  if (name[3] == 't')
                  {                               /* wait       */
                    return -KEY_wait;
                  }
d6518 1
a6518 1
                  goto unknown;
d6520 5
a6524 5
                case 'r':
                  if (name[3] == 'n')
                  {                               /* warn       */
                    return -KEY_warn;
                  }
d6526 1
a6526 1
                  goto unknown;
d6528 4
a6531 3
                default:
                  goto unknown;
              }
d6533 1
a6533 12
            case 'h':
              if (name[2] == 'e' &&
                  name[3] == 'n')
              {                                   /* when       */
                return (all_keywords || FEATURE_IS_ENABLED("switch") ? KEY_when : 0);
              }

              goto unknown;

            default:
              goto unknown;
          }
d6539 1
a6539 1
    case 5: /* 39 tokens of length 5 */
d6592 7
a6598 9
          switch (name[1])
          {
            case 'l':
              if (name[2] == 'e' &&
                  name[3] == 's' &&
                  name[4] == 's')
              {                                   /* bless      */
                return -KEY_bless;
              }
d6600 1
a6600 15
              goto unknown;

            case 'r':
              if (name[2] == 'e' &&
                  name[3] == 'a' &&
                  name[4] == 'k')
              {                                   /* break      */
                return (all_keywords || FEATURE_IS_ENABLED("switch") ? -KEY_break : 0);
              }

              goto unknown;

            default:
              goto unknown;
          }
a6714 11
        case 'g':
          if (name[1] == 'i' &&
              name[2] == 'v' &&
              name[3] == 'e' &&
              name[4] == 'n')
          {                                       /* given      */
            return (all_keywords || FEATURE_IS_ENABLED("switch") ? KEY_given : 0);
          }

          goto unknown;

d6872 6
a6877 8
              switch (name[2])
              {
                case 'a':
                  if (name[3] == 't' &&
                      name[4] == 'e')
                  {                               /* state      */
                    return (all_keywords || FEATURE_IS_ENABLED("state") ? KEY_state : 0);
                  }
d6879 1
a6879 14
                  goto unknown;

                case 'u':
                  if (name[3] == 'd' &&
                      name[4] == 'y')
                  {                               /* study      */
                    return KEY_study;
                  }

                  goto unknown;

                default:
                  goto unknown;
              }
d7451 1
a7451 1
    case 7: /* 29 tokens of length 7 */
d7522 7
a7528 27
              if (name[2] == 'f')
              {
                switch (name[3])
                {
                  case 'a':
                    if (name[4] == 'u' &&
                        name[5] == 'l' &&
                        name[6] == 't')
                    {                             /* default    */
                      return (all_keywords || FEATURE_IS_ENABLED("switch") ? KEY_default : 0);
                    }

                    goto unknown;

                  case 'i':
                    if (name[4] == 'n' &&
                        name[5] == 'e' &&
                        name[6] == 'd')
                    {                             /* defined    */
                      return KEY_defined;
                    }

                    goto unknown;

                  default:
                    goto unknown;
                }
d8265 1
a8265 1
    case 9: /* 9 tokens of length 9 */
a8267 15
        case 'U':
          if (name[1] == 'N' &&
              name[2] == 'I' &&
              name[3] == 'T' &&
              name[4] == 'C' &&
              name[5] == 'H' &&
              name[6] == 'E' &&
              name[7] == 'C' &&
              name[8] == 'K')
          {                                       /* UNITCHECK  */
            return KEY_UNITCHECK;
          }

          goto unknown;

d8909 1
a8909 1
S_checkcomma(pTHX_ const char *s, const char *name, const char *what)
d8911 1
a8911 1
    dVAR;
a8915 1
	    const char *w;
d8922 3
a8924 7
	    while (isSPACE(*w))
		++w;
	    /* the list of chars below is for end of statements or
	     * block / parens, boolean operators (&&, ||, //) and branch
	     * constructs (or, and, if, until, unless, while, err, for).
	     * Not a very solid hack... */
	    if (!*w || !strchr(";&/|})]oaiuwef!=", *w))
d8936 1
a8936 1
	const char * const w = s++;
d8942 5
a8946 6
	    GV* gv;
	    if (keyword(w, s - w, 0))
		return;

	    gv = gv_fetchpvn_flags(w, s - w, 0, SVt_PVCV);
	    if (gv && GvCVu(gv))
d8959 2
a8960 2
S_new_constant(pTHX_ const char *s, STRLEN len, const char *key, STRLEN keylen,
	       SV *sv, SV *pv, const char *type, STRLEN typelen)
d8962 1
a8962 1
    dVAR; dSP;
d8972 3
a8974 4
	why2 = (const char *)
	    (strEQ(key,"charnames")
	     ? "(possibly a missing \"use charnames ...\")"
	     : "");
d8989 1
a8989 1
	yyerror(SvPVX_const(msg));
d8993 1
a8993 1
    cvp = hv_fetch(table, key, keylen, FALSE);
d9005 1
a9005 1
  	typesv = sv_2mortal(newSVpvn(type, typelen));
d9027 2
a9028 2
 	sv_catpvs(ERRSV, "Propagated");
	yyerror(SvPV_nolen_const(ERRSV)); /* Duplicates the message inside eval */
d9030 1
a9030 1
	res = SvREFCNT_inc_simple(sv);
d9034 1
a9034 1
	SvREFCNT_inc_simple_void(res);
a9052 3
/* Returns a NUL terminated string, with the length of the string written to
   *slp
   */
a9055 1
    dVAR;
d9063 1
a9063 1
	else if (allow_package && (*s == '\'') && isIDFIRST_lazy_if(s+1,UTF)) {
d9068 1
a9068 1
	else if (allow_package && (s[0] == ':') && (s[1] == ':') && (s[2] != '$')) {
a9073 1
	    size_t len;
d9076 1
a9076 2
	    len = t - s;
	    if (d + len > e)
d9078 2
a9079 2
	    Copy(s, d, len, char);
	    d += len;
d9093 3
a9095 2
    dVAR;
    char *bracket = NULL;
a9096 2
    register char *d = dest;
    register char * const e = d + destlen + 3;    /* two-character token, ending NUL */
d9099 3
a9101 1
	s = PEEKSPACE(s);
d9176 9
a9184 9
		char *end = s;
		while ((end < send && isALNUM_lazy_if(end,UTF)) || *end == ':') {
		    end += UTF8SKIP(end);
		    while (end < send && UTF8_IS_CONTINUED(*end) && is_utf8_mark((U8*)end))
			end += UTF8SKIP(end);
		}
		Copy(s, d, end - s, char);
		d += end - s;
		s = end;
d9193 1
a9193 2
	    while (s < send && SPACE_OR_TAB(*s))
		s++;
d9195 2
a9196 4
		if (ckWARN(WARN_AMBIGUOUS) && keyword(dest, d - dest, 0)) {
		    const char * const brack =
			(const char *)
			((*s == '[') ? "[...]" : "{...}");
d9225 2
d9229 1
a9229 2
		    (keyword(dest, d - dest, 0)
		     || get_cvn_flags(dest, d - dest, 0)))
a9230 2
		    if (funny == '#')
			funny = '@@';
d9250 14
a9263 11
    PERL_UNUSED_CONTEXT;
    if (ch<256) {
        char c = (char)ch;
        switch (c) {
            CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl);
            case GLOBAL_PAT_MOD:    *pmfl |= PMf_GLOBAL; break;
            case CONTINUE_PAT_MOD:  *pmfl |= PMf_CONTINUE; break;
            case ONCE_PAT_MOD:      *pmfl |= PMf_KEEP; break;
            case KEEPCOPY_PAT_MOD:  *pmfl |= PMf_KEEPCOPY; break;
        }
    }
a9268 1
    dVAR;
d9270 1
a9270 7
    char *s = scan_str(start,!!PL_madskills,FALSE);
    const char * const valid_flags =
	(const char *)((type == OP_QR) ? QR_PAT_MODS : M_PAT_MODS);
#ifdef PERL_MAD
    char *modstart;
#endif

d9273 4
a9276 6
	const char * const delimiter = skipspace(start);
	Perl_croak(aTHX_
		   (const char *)
		   (*delimiter == '?'
		    ? "Search pattern not terminated or ternary operator parsed as search pattern"
		    : "Search pattern not terminated" ));
d9280 1
a9280 2
    if (PL_multi_open == '?') {
	/* This is the only point in the code that sets PMf_ONCE:  */
d9282 7
a9288 28

	/* Hence it's safe to do this bit of PMOP book-keeping here, which
	   allows us to restrict the list needed by reset to just the ??
	   matches.  */
	assert(type != OP_TRANS);
	if (PL_curstash) {
	    MAGIC *mg = mg_find((SV*)PL_curstash, PERL_MAGIC_symtab);
	    U32 elements;
	    if (!mg) {
		mg = sv_magicext((SV*)PL_curstash, 0, PERL_MAGIC_symtab, 0, 0,
				 0);
	    }
	    elements = mg->mg_len / sizeof(PMOP**);
	    Renewc(mg->mg_ptr, elements + 1, PMOP*, char);
	    ((PMOP**)mg->mg_ptr) [elements++] = pm;
	    mg->mg_len = elements * sizeof(PMOP**);
	    PmopSTASH_set(pm,PL_curstash);
	}
    }
#ifdef PERL_MAD
    modstart = s;
#endif
    while (*s && strchr(valid_flags, *s))
	pmflag(&pm->op_pmflags,*s++);
#ifdef PERL_MAD
    if (PL_madskills && modstart != s) {
	SV* tmptoken = newSVpvn(modstart, s - modstart);
	append_madprops(newMADPROP('m', MAD_SV, tmptoken, 0), (OP*)pm, 0);
a9289 1
#endif
d9294 1
a9294 2
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), 
            "Use of /c modifier is meaningless without /g" );
d9297 2
d9300 1
a9300 1
    pl_yylval.ival = OP_MATCH;
a9306 1
    dVAR;
a9310 3
#ifdef PERL_MAD
    char *modstart;
#endif
d9312 1
a9312 1
    pl_yylval.ival = OP_NULL;
d9314 1
a9314 1
    s = scan_str(start,!!PL_madskills,FALSE);
a9320 9
#ifdef PERL_MAD
    if (PL_madskills) {
	CURMAD('q', PL_thisopen);
	CURMAD('_', PL_thiswhite);
	CURMAD('E', PL_thisstuff);
	CURMAD('Q', PL_thisclose);
	PL_realtokenstart = s - SvPVX(PL_linestr);
    }
#endif
d9323 1
a9323 1
    s = scan_str(s,!!PL_madskills,FALSE);
d9327 1
a9327 1
	    PL_lex_stuff = NULL;
a9333 10

#ifdef PERL_MAD
    if (PL_madskills) {
	CURMAD('z', PL_thisopen);
	CURMAD('R', PL_thisstuff);
	CURMAD('Z', PL_thisclose);
    }
    modstart = s;
#endif

d9335 1
a9335 1
	if (*s == EXEC_PAT_MOD) {
d9339 1
a9339 1
	else if (strchr(S_PAT_MODS, *s))
d9345 4
a9348 10
#ifdef PERL_MAD
    if (PL_madskills) {
	if (modstart != s)
	    curmad('m', newSVpvn(modstart, s - modstart));
	append_madprops(PL_thismad, (OP*)pm, 0);
	PL_thismad = 0;
    }
#endif
    if ((pm->op_pmflags & PMf_CONTINUE) && ckWARN(WARN_REGEXP)) {
        Perl_warner(aTHX_ packWARN(WARN_REGEXP), "Use of /c modifier is meaningless in s///" );
d9352 1
a9352 2
	SV * const repl = newSVpvs("");

d9357 4
a9360 7
	while (es-- > 0) {
	    if (es)
		sv_catpvs(repl, "eval ");
	    else
		sv_catpvs(repl, "do ");
	}
	sv_catpvs(repl, "{");
d9362 1
a9362 3
	if (strchr(SvPVX(PL_lex_repl), '#'))
	    sv_catpvs(repl, "\n");
	sv_catpvs(repl, "}");
d9368 1
d9370 1
a9370 1
    pl_yylval.ival = OP_SUBST;
a9376 1
    dVAR;
a9382 3
#ifdef PERL_MAD
    char *modstart;
#endif
d9384 1
a9384 1
    pl_yylval.ival = OP_NULL;
d9386 1
a9386 1
    s = scan_str(start,!!PL_madskills,FALSE);
a9388 1

a9390 9
#ifdef PERL_MAD
    if (PL_madskills) {
	CURMAD('q', PL_thisopen);
	CURMAD('_', PL_thiswhite);
	CURMAD('E', PL_thisstuff);
	CURMAD('Q', PL_thisclose);
	PL_realtokenstart = s - SvPVX(PL_linestr);
    }
#endif
d9392 1
a9392 1
    s = scan_str(s,!!PL_madskills,FALSE);
d9396 1
a9396 1
	    PL_lex_stuff = NULL;
a9399 5
    if (PL_madskills) {
	CURMAD('z', PL_thisopen);
	CURMAD('R', PL_thisstuff);
	CURMAD('Z', PL_thisclose);
    }
a9401 3
#ifdef PERL_MAD
    modstart = s;
#endif
d9420 1
a9420 1
    tbl = (short *)PerlMemShared_calloc(complement&&!del?258:256, sizeof(short));
d9422 1
a9422 2
    o->op_private &= ~OPpTRANS_ALL;
    o->op_private |= del|squash|complement|
d9427 1
a9427 11
    pl_yylval.ival = OP_TRANS;

#ifdef PERL_MAD
    if (PL_madskills) {
	if (modstart != s)
	    curmad('m', newSVpvn(modstart, s - modstart));
	append_madprops(PL_thismad, o, 0);
	PL_thismad = 0;
    }
#endif

a9433 1
    dVAR;
d9439 1
a9444 6
#ifdef PERL_MAD
    I32 stuffstart = s - SvPVX(PL_linestr);
    char *tstart;
 
    PL_realtokenstart = -1;
#endif
d9451 1
a9451 3
    peek = s;
    while (SPACE_OR_TAB(*peek))
	peek++;
a9476 10

#ifdef PERL_MAD
    if (PL_madskills) {
	tstart = PL_tokenbuf + !outer;
	PL_thisclose = newSVpvn(tstart, len - !outer);
	tstart = SvPVX(PL_linestr) + stuffstart;
	PL_thisopen = newSVpvn(tstart, s - tstart);
	stuffstart = s - SvPVX(PL_linestr);
    }
#endif
d9501 1
a9501 4
#ifdef PERL_MAD
    found_newline = 0;
#endif
    if ( outer || !(found_newline = (char*)memchr((void*)s, '\n', PL_bufend - s)) ) {
a9504 3
#ifdef PERL_MAD
        herewas = newSVpvn(s-1,found_newline-s+1);
#else
a9506 1
#endif
a9507 9
#ifdef PERL_MAD
    if (PL_madskills) {
	tstart = SvPVX(PL_linestr) + stuffstart;
	if (PL_thisstuff)
	    sv_catpvn(PL_thisstuff, tstart, s - tstart);
	else
	    PL_thisstuff = newSVpvn(tstart, s - tstart);
    }
#endif
d9510 2
a9511 9
#ifdef PERL_MAD
    stuffstart = s - SvPVX(PL_linestr);

    if (found_newline)
	s--;
#endif

    tmpstr = newSV_type(SVt_PVIV);
    SvGROW(tmpstr, 80);
d9526 2
a9527 2
	char * const bufptr = PL_sublex_info.super_bufptr;
	char * const bufend = PL_sublex_info.super_bufend;
a9562 9
#ifdef PERL_MAD
	if (PL_madskills) {
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, d + 1, s - d);
	    else
		PL_thisstuff = newSVpvn(d + 1, s - d);
	    stuffstart = s - SvPVX(PL_linestr);
	}
#endif
d9570 1
a9570 1
	PL_last_lop = PL_last_uni = NULL;
a9574 9
#ifdef PERL_MAD
	if (PL_madskills) {
	    tstart = SvPVX(PL_linestr) + stuffstart;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, PL_bufend - tstart);
	    else
		PL_thisstuff = newSVpvn(tstart, PL_bufend - tstart);
	}
#endif
a9579 3
#ifdef PERL_MAD
	stuffstart = s - SvPVX(PL_linestr);
#endif
d9582 1
a9582 1
	PL_last_lop = PL_last_uni = NULL;
d9598 9
a9606 2
	if (PERLDB_LINE && PL_curstash != PL_debstash)
	    update_debugger_info(PL_linestr, NULL, 0);
d9633 1
a9633 1
    pl_yylval.ival = op_type;
d9640 1
a9640 1
   side-effects: pl_yylval and lex_op are set.
a9655 1
    dVAR;
d9657 2
d9662 2
a9663 3
    char *d = PL_tokenbuf;					/* start of temp holding space */
    const char * const e = PL_tokenbuf + sizeof PL_tokenbuf;	/* end of temp holding space */

d9667 1
a9667 1
    s = delimcpy(d, e, s + 1, end, '>', &len);	/* extract until > */
d9673 1
a9673 1
    if (len >= (I32)sizeof PL_tokenbuf)
d9700 3
a9702 2
	pl_yylval.ival = OP_GLOB;
	s = scan_str(start,!!PL_madskills,FALSE);
d9709 1
a9709 1
	GV *gv_readline;
d9719 1
a9719 2
	gv_readline = gv_fetchpvs("readline", GV_NOTQUAL, SVt_PVCV);
	if ((gv_readline
d9722 2
a9723 2
		((gvp = (GV**)hv_fetchs(PL_globalstash, "readline", FALSE))
		 && (gv_readline = *gvp) && isGV_with_GP(gv_readline)
d9731 2
d9736 5
a9740 7
	    const PADOFFSET tmp = pad_findmy(d);
	    if (tmp != NOT_IN_PAD) {
		if (PAD_COMPNAME_FLAGS_isOUR(tmp)) {
		    HV * const stash = PAD_COMPNAME_OURSTASH(tmp);
		    HEK * const stashname = HvNAME_HEK(stash);
		    SV * const sym = sv_2mortal(newSVhek(stashname));
		    sv_catpvs(sym, "::");
d9746 1
a9746 1
		    OP * const o = newOP(OP_PADSV, 0);
d9775 2
a9776 2
	    /* we created the ops in PL_lex_op, so make pl_yylval.ival a null op */
	    pl_yylval.ival = OP_NULL;
d9782 1
a9782 1
	    GV * const gv = gv_fetchpv(d, GV_ADD, SVt_PVIO);
d9789 1
a9789 1
	    pl_yylval.ival = OP_NULL;
a9842 1
    dVAR;
d9844 1
a9844 1
    const char *tmps;			/* temp string, used for delimiter matching */
d9853 1
a9853 5
    int last_off = 0;			/* last position for nesting bracket */
#ifdef PERL_MAD
    int stuffstart;
    char *tstart;
#endif
d9856 2
a9857 3
    if (isSPACE(*s)) {
	s = PEEKSPACE(s);
    }
a9858 8
#ifdef PERL_MAD
    if (PL_realtokenstart >= 0) {
	stuffstart = PL_realtokenstart;
	PL_realtokenstart = -1;
    }
    else
	stuffstart = start - SvPVX(PL_linestr);
#endif
d9885 4
a9888 4
    /* create a new SV to hold the contents.  79 is the SV's initial length.
       What a random number. */
    sv = newSV_type(SVt_PVIV);
    SvGROW(sv, 80);
a9895 7
#ifdef PERL_MAD
    tstart = SvPVX(PL_linestr) + stuffstart;
    if (!PL_thisopen && !keep_delims) {
	PL_thisopen = newSVpvn(tstart, s - tstart);
	stuffstart = s - SvPVX(PL_linestr);
    }
#endif
d9904 2
a9905 2
		const char * const ns = SvPVX_const(PL_linestr) + offset;
		char * const svlast = SvEND(sv) - 1;
d9934 3
a9936 1
			for (t = w = SvPVX(sv)+last_off; t < svlast; w++, t++) {
d9955 1
a9955 1
			last_off = w - SvPVX(sv);
a10059 9
#ifdef PERL_MAD
	if (PL_madskills) {
	    char * const tstart = SvPVX(PL_linestr) + stuffstart;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, PL_bufend - tstart);
	    else
		PL_thisstuff = newSVpvn(tstart, PL_bufend - tstart);
	}
#endif
d10064 1
a10064 1
	    return NULL;
a10065 3
#ifdef PERL_MAD
	stuffstart = 0;
#endif
d10070 9
a10078 2
	if (PERLDB_LINE && PL_curstash != PL_debstash)
	    update_debugger_info(PL_linestr, NULL, 0);
d10082 1
a10082 1
	PL_last_lop = PL_last_uni = NULL;
a10087 13
#ifdef PERL_MAD
	if (PL_madskills) {
	    char * const tstart = SvPVX(PL_linestr) + stuffstart;
	    const int len = s - tstart;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, len);
	    else
		PL_thisstuff = newSVpvn(tstart, len);
	    if (!PL_thisclose && !keep_delims)
		PL_thisclose = newSVpvn(s,termlen);
	}
#endif

a10091 14
#ifdef PERL_MAD
    else {
	if (PL_madskills) {
	    char * const tstart = SvPVX(PL_linestr) + stuffstart;
	    const int len = s - tstart - termlen;
	    if (PL_thisstuff)
		sv_catpvn(PL_thisstuff, tstart, len);
	    else
		PL_thisstuff = newSVpvn(tstart, len);
	    if (!PL_thisclose && !keep_delims)
		PL_thisclose = newSVpvn(s - termlen,termlen);
	}
    }
#endif
d10118 1
a10118 1
  side-effects: builds ops for the constant in pl_yylval.op
d10137 1
a10137 1
Perl_scan_num(pTHX_ const char *start, YYSTYPE* lvalp)
a10138 1
    dVAR;
d10143 1
a10143 1
    SV *sv = NULL;			/* place to put the converted number */
d10145 1
a10145 1
    const char *lastub = NULL;		/* position of last underbar */
d10308 1
a10308 1
	    sv = newSV(0);
d10327 1
a10327 1
				  sv, NULL, NULL, 0);
d10329 1
a10329 1
		sv = new_constant(start, s - start, "binary", sv, NULL, NULL, 0);
d10461 1
a10461 1
	sv = newSV(0);
d10470 1
a10470 1
	    const int flags = grok_number (PL_tokenbuf, d - PL_tokenbuf, &uv);
d10492 5
a10496 7
	if ( floatit
	     ? (PL_hints & HINT_NEW_FLOAT) : (PL_hints & HINT_NEW_INTEGER) ) {
	    const char *const key = floatit ? "float" : "integer";
	    const STRLEN keylen = floatit ? 5 : 7;
	    sv = S_new_constant(aTHX_ PL_tokenbuf, d - PL_tokenbuf,
				key, keylen, sv, NULL, NULL, 0);
	}
d10502 5
a10506 2
		sv = newSV(5); /* preallocate storage space */
		s = scan_vstring(s, PL_bufend, sv);
d10515 1
a10515 1
	lvalp->opval = NULL;
a10522 1
    dVAR;
d10525 1
a10525 1
    SV * const stuff = newSVpvs("");
a10527 9
#ifdef PERL_MAD
    char *tokenstart = s;
    SV* savewhite;
    
    if (PL_madskills) {
	savewhite = PL_thiswhite;
	PL_thiswhite = 0;
    }
#endif
a10530 1
	    t = s+1;
d10532 1
a10532 2
	    while (SPACE_OR_TAB(*t))
		t++;
d10534 1
a10534 2
	    while (SPACE_OR_TAB(*t) || *t == '\r')
		t++;
a10572 8
#ifdef PERL_MAD
	    if (PL_madskills) {
		if (PL_thistoken)
		    sv_catpvn(PL_thistoken, tokenstart, PL_bufend - tokenstart);
		else
		    PL_thistoken = newSVpvn(tokenstart, PL_bufend - tokenstart);
	    }
#endif
a10573 3
#ifdef PERL_MAD
	    tokenstart = PL_oldoldbufptr = PL_oldbufptr = PL_bufptr = PL_linestart = SvPVX(PL_linestr);
#else
a10574 1
#endif
d10576 1
a10576 1
	    PL_last_lop = PL_last_uni = NULL;
d10589 1
a10589 2
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = 0;
d10600 1
a10600 2
	start_force(PL_curforce);
	NEXTVAL_NEXTTOKE.opval = (OP*)newSVOP(OP_CONST, 0, stuff);
d10602 1
a10602 2
	start_force(PL_curforce);
	NEXTVAL_NEXTTOKE.ival = OP_FORMLINE;
d10611 9
a10619 8
#ifdef PERL_MAD
    if (PL_madskills) {
	if (PL_thistoken)
	    sv_catpvn(PL_thistoken, tokenstart, s - tokenstart);
	else
	    PL_thistoken = newSVpvn(tokenstart, s - tokenstart);
	PL_thiswhite = savewhite;
    }
a10620 1
    return s;
a10625 1
    dVAR;
d10627 1
a10627 1
    CV* const outsidecv = PL_compcv;
d10636 2
a10637 1
    PL_compcv = (CV*)newSV_type(is_format ? SVt_PVFM : SVt_PVCV);
d10642 1
a10642 1
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc_simple(outsidecv);
d10644 5
d10657 1
a10657 1
Perl_yywarn(pTHX_ const char *s)
a10658 1
    dVAR;
d10666 1
a10666 1
Perl_yyerror(pTHX_ const char *s)
a10667 1
    dVAR;
a10671 1
    int yychar  = PL_parser->yychar;
d10710 6
a10715 1
    else if (yychar == -2) { /* YYEMPTY */
d10725 1
a10725 1
	SV * const where_sv = sv_2mortal(newSVpvs("next char "));
d10728 2
a10729 4
	else if (isPRINT_LC(yychar)) {
	    const char string = yychar;
	    sv_catpvn(where_sv, &string, 1);
	}
d10747 2
a10748 4
    if (PL_in_eval & EVAL_WARNONLY) {
	if (ckWARN_d(WARN_SYNTAX))
	    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "%"SVf, SVfARG(msg));
    }
d10754 1
a10754 1
		       SVfARG(ERRSV), OutCopFILE(PL_curcop));
d10760 1
a10760 1
    PL_in_my_stash = NULL;
a10769 1
    dVAR;
a10790 5
#ifdef PERL_MAD
		s = (U8*)SvPVX(PL_linestr);
  		Copy(news, s, newlen, U8);
		s[newlen] = '\0';
#endif
a10793 4
#ifdef PERL_MAD
		/* FIXME - is this a general bug fix?  */
		s[newlen] = '\0';
#endif
a10848 9
#ifdef EBCDIC
    case 0xDD:
        if (slen > 3 && s[1] == 0x73 && s[2] == 0x66 && s[3] == 0x73) {
            if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-8 script encoding (BOM)\n");
            s += 4;                      /* UTF-8 */
        }
        break;
#endif

d10861 16
a10881 1
    dVAR;
d10886 1
a10886 2
			  FPTR2DPTR(void *, utf16_textfilter),
			  idx, maxlen, (int) count));
a10902 1
    dVAR;
d10907 1
a10907 2
			  FPTR2DPTR(void *, utf16rev_textfilter),
			  idx, maxlen, (int) count));
d10928 2
a10929 2
	sv = newSV(5);
	s = scan_vstring(s,e,sv);
a10930 1
where s and e are the start and end of the string.
d10937 1
a10937 1
Perl_scan_vstring(pTHX_ const char *s, const char *e, SV *sv)
a10938 1
    dVAR;
d10942 1
a10942 1
    while (pos < e && (isDIGIT(*pos) || *pos == '_'))
d10947 1
a10947 1
	while (next < e && isSPACE(*next))
d10949 1
a10949 1
	if ((e - next) >= 2 && *next == '=' && next[1] == '>' ) {
d10957 1
d10959 1
d10961 1
a10961 2
	if (*s == 'v')
	    s++;  /* get past 'v' */
d10966 10
a10975 8
	    /* this is atoi() that tolerates underscores */
	    U8 *tmpend;
	    UV rev = 0;
	    const char *end = pos;
	    UV mult = 1;
	    while (--end >= s) {
		if (*end != '_') {
		    const UV orev = rev;
d10992 2
a10993 2
	    if (pos + 1 < e && *pos == '.' && isDIGIT(pos[1]))
		 s = ++pos;
d10995 1
a10995 1
		 s = pos;
d10998 1
a10998 1
	    while (pos < e && (isDIGIT(*pos) || *pos == '_'))
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 1
a12 3
 *  'It all comes from here, the stench and the peril.'    --Frodo
 *
 *     [p.719 of _The Lord of the Rings_, IV/ix: "Shelob's Lair"]
d230 1
a230 1
#   define REPORT(retval) tokereport((I32)retval, &pl_yylval)
d377 1
a377 1
S_tokereport(pTHX_ I32 rv, const YYSTYPE* lvalp)
a379 3

    PERL_ARGS_ASSERT_TOKEREPORT;

d406 1
a406 1
	    Perl_sv_catpvf(aTHX_ report, "(ival=%"IVdf")", (IV)lvalp->ival);
d410 1
a410 1
				    PL_op_name[lvalp->ival]);
d413 1
a413 1
	    Perl_sv_catpvf(aTHX_ report, "(pval=\"%s\")", lvalp->pval);
d416 1
a416 1
	    if (lvalp->opval) {
d418 2
a419 2
				    PL_op_name[lvalp->opval->op_type]);
		if (lvalp->opval->op_type == OP_CONST) {
d421 1
a421 1
			SvPEEK(cSVOPx_sv(lvalp->opval)));
a440 3

    PERL_ARGS_ASSERT_PRINTBUF;

a490 2
    PERL_ARGS_ASSERT_NO_OP;

d538 7
a544 1
    else if (isCNTRL(PL_multi_close)) {
a574 3

    PERL_ARGS_ASSERT_FEATURE_IS_ENABLED;

a587 2
    PERL_ARGS_ASSERT_DEPRECATE;

a602 2
    PERL_ARGS_ASSERT_DEPRECATE_OLD;

a618 3

    PERL_ARGS_ASSERT_STRIP_RETURN;

a694 1
    parser->error_count = oparser ? oparser->error_count : 0;
d700 1
a700 1
		: MUTABLE_AV(SvREFCNT_inc(oparser->rsfp_filters));
a736 2
    PERL_ARGS_ASSERT_PARSER_FREE;

d742 2
a743 2
    else if (parser->rsfp && (!parser->old_parser ||
		(parser->old_parser && parser->rsfp != parser->old_parser->rsfp)))
a785 2
    PERL_ARGS_ASSERT_INCLINE;

d881 2
a882 2
		    GvHV(gv2) = MUTABLE_HV(SvREFCNT_inc(GvHV(*gvp)));
		    GvAV(gv2) = MUTABLE_AV(SvREFCNT_inc(GvAV(*gvp)));
a901 2
    PERL_ARGS_ASSERT_SKIPSPACE0;

a923 2
    PERL_ARGS_ASSERT_SKIPSPACE1;

a949 2
    PERL_ARGS_ASSERT_SKIPSPACE2;

a1001 2
    PERL_ARGS_ASSERT_SKIPSPACE;

a1006 1
    PERL_ARGS_ASSERT_SKIPSPACE;
d1089 1
a1089 1
		sv_catpvs(PL_linestr, ";}");
d1091 1
a1091 1
		sv_setpvs(PL_linestr, ";}");
d1097 1
a1097 1
		sv_catpvs(PL_linestr,";");
d1099 1
a1099 1
		sv_setpvs(PL_linestr,";");
d1151 1
a1151 1
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
a1220 3

    PERL_ARGS_ASSERT_LOP;

d1288 1
a1288 1
	sv_setpvs(sv, "");
d1302 1
a1302 1
	sv_free(MUTABLE_SV(((*where)->mad_val)));
a1325 6
#ifdef DEBUGGING
    if (DEBUG_T_TEST) {
        PerlIO_printf(Perl_debug_log, "### forced token:\n");
	tokereport(type, &NEXTVAL_NEXTTOKE);
    }
#endif
d1350 3
a1352 3
    SV * const sv = newSVpvn_utf8(start, len,
				  UTF && !IN_BYTES
				  && is_utf8_string((const U8*)start, len));
a1379 2
    PERL_ARGS_ASSERT_FORCE_WORD;

a1423 3

    PERL_ARGS_ASSERT_FORCE_IDENT;

a1455 3

    PERL_ARGS_ASSERT_STR_TO_VERSION;

a1489 2
    PERL_ARGS_ASSERT_FORCE_VERSION;

a1559 2
    PERL_ARGS_ASSERT_TOKEQ;

d1573 3
a1575 1
	pv = newSVpvn_flags(SvPVX_const(pv), len, SVs_TEMP | SvUTF8(sv));
d1642 3
a1644 1
	    SV * const nsv = newSVpvn_flags(p, len, SvUTF8(sv));
d1801 1
a1801 1
		sv_setpvs(PL_thistoken,"");
a1888 1
	      continue
a1889 1
          handle regular character
d1899 1
a1899 2
    SV *sv = newSV(send - start);		/* sv for the constant.  See
						   note below on sizing. */
d1905 1
a1905 19
    I32  this_utf8 = UTF;			/* Is the source string assumed
						   to be UTF8?  But, this can
						   show as true when the source
						   isn't utf8, as for example
						   when it is entirely composed
						   of hex constants */

    /* Note on sizing:  The scanned constant is placed into sv, which is
     * initialized by newSV() assuming one byte of output for every byte of
     * input.  This routine expects newSV() to allocate an extra byte for a
     * trailing NUL, which this routine will append if it gets to the end of
     * the input.  There may be more bytes of input than output (eg., \N{LATIN
     * CAPITAL LETTER A}), or more output than input if the constant ends up
     * recoded to utf8, but each time a construct is found that might increase
     * the needed size, SvGROW() is called.  Its size parameter each time is
     * based on the best guess estimate at the time, namely the length used so
     * far, plus the length the current construct will occupy, plus room for
     * the trailing NUL, plus one byte for every input byte still unscanned */ 

a1911 2
    PERL_ARGS_ASSERT_SCAN_CONST;

d2178 1
a2178 1
	    /* eg. \132 indicates the octal constant 0x132 */
d2184 1
a2184 1
		    uv = NATIVE_TO_UNI(grok_oct(s, &len, &flags, NULL));
d2189 1
a2189 1
	    /* eg. \x24 indicates the hex constant 0x24 */
d2204 1
a2204 1
		    uv = NATIVE_TO_UNI(grok_hex(s, &len, &flags, NULL));
d2211 1
a2211 1
			uv = NATIVE_TO_UNI(grok_hex(s, &len, &flags, NULL));
d2217 4
a2220 4
		/* Insert oct, hex, or \N{U+...} escaped character.  There will
		 * always be enough room in sv since such escapes will be
		 * longer than any UTF-8 sequence they can end up as, except if
		 * they force us to recode the rest of the string into utf8 */
d2222 4
a2225 5
		/* Here uv is the ordinal of the next character being added in
		 * unicode (converted from native).  (It has to be done before
		 * here because \N is interpreted as unicode, and oct and hex
		 * as native.) */
		if (!UNI_IS_INVARIANT(uv)) {
d2227 33
a2259 12
			/* Might need to recode whatever we have accumulated so
			 * far if it contains any chars variant in utf8 or
			 * utf-ebcdic. */
			  
			SvCUR_set(sv, d - SvPVX_const(sv));
			SvPOK_on(sv);
			*d = '\0';
			sv_utf8_upgrade(sv);
			/* See Note on sizing above.  */
			SvGROW(sv, SvCUR(sv) + UNISKIP(uv) + (STRLEN)(send - s) + 1);
			d = SvPVX(sv) + SvCUR(sv);
			has_utf8 = TRUE;
d2262 3
a2264 2
                    if (has_utf8) {
		        d = (char*)uvuni_to_utf8((U8*)d, uv);
d2285 1
a2285 2
	    /* \N{LATIN SMALL LETTER A} is a named character, and so is
	     * \N{U+0041} */
d2300 1
a2300 2
			/* \N{U+...} The ... is a unicode value even on EBCDIC
			 * machines */
a2337 2
		    /* If destination is not in utf8 but this new character is,
		     * recode the dest to utf8 */
d2339 2
a2340 1
			SvCUR_set(sv, d - SvPVX_const(sv));
d2344 2
a2345 2
			/* See Note on sizing above.  */
			SvGROW(sv, SvCUR(sv) + len + (STRLEN)(send - s) + 1);
d2348 3
a2350 1
		    } else if (len > (STRLEN)(e - s + 4)) { /* I _guess_ 4 is \N{} --jhi */
d2352 2
a2353 4
			/* See Note on sizing above.  (NOTE: SvCUR() is not set
			 * correctly here). */
			const STRLEN off = d - SvPVX_const(sv);
			d = SvGROW(sv, off + len + (STRLEN)(send - s) + 1) + off;
d2418 3
a2420 3
	/* If we started with encoded form, or already know we want it,
	   then encode the next character */
	if (! NATIVE_IS_INVARIANT((U8)(*s)) && (this_utf8 || has_utf8)) {
a2421 9


	    /* One might think that it is wasted effort in the case of the
	     * source being utf8 (this_utf8 == TRUE) to take the next character
	     * in the source, convert it to an unsigned value, and then convert
	     * it back again.  But the source has not been validated here.  The
	     * routine that does the conversion checks for errors like
	     * malformed utf8 */

d2424 3
a2426 14
	    if (!has_utf8) {
		SvCUR_set(sv, d - SvPVX_const(sv));
		SvPOK_on(sv);
		*d = '\0';
		sv_utf8_upgrade(sv);

		/* See Note on sizing above.  */
		SvGROW(sv, SvCUR(sv) + need + (STRLEN)(send - s) + 1);
		d = SvPVX(sv) + SvCUR(sv);
		has_utf8 = TRUE;
	    } else if (need > len) {
		/* encoded value larger than old, may need extra space (NOTE:
		 * SvCUR() is not set correctly here).   See Note on sizing
		 * above.  */
d2428 1
a2428 1
		d = SvGROW(sv, off + need + (STRLEN)(send - s) + 1) + off;
a2429 2
	    s += len;

d2431 1
a2519 3

    PERL_ARGS_ASSERT_INTUIT_MORE;

a2684 2
    PERL_ARGS_ASSERT_INTUIT_METHOD;

a2810 2
    PERL_ARGS_ASSERT_FILTER_DEL;

a2850 2
    PERL_ARGS_ASSERT_FILTER_READ;

a2905 3

    PERL_ARGS_ASSERT_FILTER_GETS;

a2928 2
    PERL_ARGS_ASSERT_FIND_IN_MY_STASH;

a3162 3

    PERL_ARGS_ASSERT_TOKENIZE_USE;

d3269 1
a3269 1
		PL_thiswhite = MUTABLE_SV(PL_thismad->mad_val);
d3622 1
a3622 1
		sv_free(MUTABLE_SV(PL_preambleav));
a3624 3
	    if (PL_minus_E)
		sv_catpvs(PL_linestr,
			  "use feature ':5." STRINGIFY(PERL_VERSION) "';");
d3656 2
d3662 1
a3662 1
	    if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
d3700 1
a3700 1
		sv_setpvs(PL_linestr,"");
d3745 1
a3745 1
		    sv_setpvs(PL_linestr, "");
d3755 1
a3755 1
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
d3911 1
a3911 8
			    bool baduni = FALSE;
			    if (*d1 == 'C') {
				const char *d2 = d1 + 1;
				if (parse_unicode_opts((const char **)&d2)
				    != PL_unicode)
				    baduni = TRUE;
			    }
			    if (baduni || *d1 == 'M' || *d1 == 'm') {
d3928 1
a3928 1
			if (((PERLDB_LINE || PERLDB_SAVESRC) && !oldpdb) ||
d3933 1
a3933 1
			    sv_setpvs(PL_linestr, "");
d3938 1
a3938 1
			    if (PERLDB_LINE || PERLDB_SAVESRC)
d4032 1
a4032 1
			    sv_setpvs(PL_thiswhite, "");
d4204 1
a4204 4
	{
	    const char tmp = *s++;
	    OPERATOR(tmp);
	}
d4596 1
a4596 1
			sv_catpvs(PL_thiswhite,"}");
d4633 1
a4633 1
		Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), "%s", PL_warn_nosemi);
d5289 1
a5289 1
			Perl_warner(aTHX_ packWARN(WARN_SEMICOLON), "%s", PL_warn_nosemi);
d5371 1
a5371 1
			   : SvOK(gv) ? MUTABLE_CV(gv) : NULL)
d5520 1
a5520 1
			const char *proto = SvPV_const(MUTABLE_SV(cv), protolen);
d6349 3
a6351 1
			sv = newSVpvn_utf8(b, d-b, DO_UTF8(PL_lex_stuff));
d6621 1
a6621 1
		    SV *nametoke = NULL;
d6660 1
a6660 1
		    sv_setpvs(PL_subname,"?");
a7073 3

    PERL_ARGS_ASSERT_KEYWORD;

a10461 2
    PERL_ARGS_ASSERT_CHECKCOMMA;

a10523 2
    PERL_ARGS_ASSERT_NEW_CONSTANT;

d10559 1
a10559 1
  	pv = newSVpvn_flags(s, len, SVs_TEMP);
d10561 1
a10561 1
  	typesv = newSVpvn_flags(type, typelen, SVs_TEMP);
a10617 3

    PERL_ARGS_ASSERT_SCAN_WORD;

a10660 2
    PERL_ARGS_ASSERT_SCAN_IDENT;

a10814 2
    PERL_ARGS_ASSERT_PMFLAG;

a10839 1
    PERL_ARGS_ASSERT_SCAN_PAT;
d10860 1
a10860 1
	    MAGIC *mg = mg_find((const SV *)PL_curstash, PERL_MAGIC_symtab);
d10863 1
a10863 1
		mg = sv_magicext(MUTABLE_SV(PL_curstash), 0, PERL_MAGIC_symtab, 0, 0,
a10908 2
    PERL_ARGS_ASSERT_SCAN_SUBST;

d11008 3
a11010 3
    U8 squash;
    U8 del;
    U8 complement;
a11014 2
    PERL_ARGS_ASSERT_SCAN_TRANS;

a11111 2
    PERL_ARGS_ASSERT_SCAN_HEREDOC;

d11283 1
a11283 1
	sv_setpvs(tmpstr,"");   /* avoid "uninitialized" warning */
d11320 1
a11320 1
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
d11375 1
a11378 2
    PERL_ARGS_ASSERT_SCAN_INPUTSYMBOL;

a11574 2
    PERL_ARGS_ASSERT_SCAN_STR;

d11816 1
a11816 1
	if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
a11914 2
    PERL_ARGS_ASSERT_SCAN_NUM;

d12297 2
a12298 2
    SV* savewhite = NULL;

a12304 2
    PERL_ARGS_ASSERT_SCAN_FORMLINE;

d12431 1
a12431 1
    PL_compcv = MUTABLE_CV(newSV_type(is_format ? SVt_PVFM : SVt_PVCV));
d12436 1
a12436 1
    CvOUTSIDE(PL_compcv) = MUTABLE_CV(SvREFCNT_inc_simple(outsidecv));
a12448 3

    PERL_ARGS_ASSERT_YYWARN;

a12464 2
    PERL_ARGS_ASSERT_YYERROR;

d12512 1
a12512 1
	SV * const where_sv = newSVpvs_flags("next char ", SVs_TEMP);
a12562 3

    PERL_ARGS_ASSERT_SWALLOW_BOM;

a12740 3

    PERL_ARGS_ASSERT_SCAN_VSTRING;

d12762 1
a12762 1
	sv_setpvs(sv, "");
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a23 15
/*
=head1 Lexer interface

This is the lower layer of the Perl parser, managing characters and tokens.

=for apidoc AmU|yy_parser *|PL_parser

Pointer to a structure encapsulating the state of the parsing operation
currently in progress.  The pointer can be locally changed to perform
a nested parse without interfering with the state of an outer parse.
Individual members of C<PL_parser> have their own documentation.

=cut
*/

a98 2
/* This can't be done with embed.fnc, because struct yy_parser contains a
   member named pending_ident, which clashes with the generated #define  */
d103 6
a126 3
/* The maximum number of characters preceding the unrecognized one to display */
#define UNRECOGNIZED_PRECEDE_COUNT 10

d131 4
d136 1
a351 2
    { PLUGEXPR,		TOKENTYPE_OPVAL,	"PLUGEXPR" },
    { PLUGSTMT,		TOKENTYPE_OPVAL,	"PLUGSTMT" },
a372 1
    { YADAYADA,		TOKENTYPE_IVAL,		"YADAYADA" },
d443 1
a443 1
S_printbuf(pTHX_ const char *const fmt, const char *const s)
a454 7
static int
S_deprecate_commaless_var_list(pTHX) {
    PL_expect = XTERM;
    deprecate("comma-less variable list");
    return REPORT(','); /* grandfather non-comma-format format */
}

d493 1
a493 1
S_no_op(pTHX_ const char *const what, char *s)
d567 1
a567 1
#define MAX_FEATURE_LEN (sizeof("unicode_strings")-1)
d574 1
a574 1
S_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen)
d589 31
a785 703
=for apidoc AmxU|SV *|PL_parser-E<gt>linestr

Buffer scalar containing the chunk currently under consideration of the
text currently being lexed.  This is always a plain string scalar (for
which C<SvPOK> is true).  It is not intended to be used as a scalar by
normal scalar means; instead refer to the buffer directly by the pointer
variables described below.

The lexer maintains various C<char*> pointers to things in the
C<PL_parser-E<gt>linestr> buffer.  If C<PL_parser-E<gt>linestr> is ever
reallocated, all of these pointers must be updated.  Don't attempt to
do this manually, but rather use L</lex_grow_linestr> if you need to
reallocate the buffer.

The content of the text chunk in the buffer is commonly exactly one
complete line of input, up to and including a newline terminator,
but there are situations where it is otherwise.  The octets of the
buffer may be intended to be interpreted as either UTF-8 or Latin-1.
The function L</lex_bufutf8> tells you which.  Do not use the C<SvUTF8>
flag on this scalar, which may disagree with it.

For direct examination of the buffer, the variable
L</PL_parser-E<gt>bufend> points to the end of the buffer.  The current
lexing position is pointed to by L</PL_parser-E<gt>bufptr>.  Direct use
of these pointers is usually preferable to examination of the scalar
through normal scalar means.

=for apidoc AmxU|char *|PL_parser-E<gt>bufend

Direct pointer to the end of the chunk of text currently being lexed, the
end of the lexer buffer.  This is equal to C<SvPVX(PL_parser-E<gt>linestr)
+ SvCUR(PL_parser-E<gt>linestr)>.  A NUL character (zero octet) is
always located at the end of the buffer, and does not count as part of
the buffer's contents.

=for apidoc AmxU|char *|PL_parser-E<gt>bufptr

Points to the current position of lexing inside the lexer buffer.
Characters around this point may be freely examined, within
the range delimited by C<SvPVX(L</PL_parser-E<gt>linestr>)> and
L</PL_parser-E<gt>bufend>.  The octets of the buffer may be intended to be
interpreted as either UTF-8 or Latin-1, as indicated by L</lex_bufutf8>.

Lexing code (whether in the Perl core or not) moves this pointer past
the characters that it consumes.  It is also expected to perform some
bookkeeping whenever a newline character is consumed.  This movement
can be more conveniently performed by the function L</lex_read_to>,
which handles newlines appropriately.

Interpretation of the buffer's octets can be abstracted out by
using the slightly higher-level functions L</lex_peek_unichar> and
L</lex_read_unichar>.

=for apidoc AmxU|char *|PL_parser-E<gt>linestart

Points to the start of the current line inside the lexer buffer.
This is useful for indicating at which column an error occurred, and
not much else.  This must be updated by any lexing code that consumes
a newline; the function L</lex_read_to> handles this detail.

=cut
*/

/*
=for apidoc Amx|bool|lex_bufutf8

Indicates whether the octets in the lexer buffer
(L</PL_parser-E<gt>linestr>) should be interpreted as the UTF-8 encoding
of Unicode characters.  If not, they should be interpreted as Latin-1
characters.  This is analogous to the C<SvUTF8> flag for scalars.

In UTF-8 mode, it is not guaranteed that the lexer buffer actually
contains valid UTF-8.  Lexing code must be robust in the face of invalid
encoding.

The actual C<SvUTF8> flag of the L</PL_parser-E<gt>linestr> scalar
is significant, but not the whole story regarding the input character
encoding.  Normally, when a file is being read, the scalar contains octets
and its C<SvUTF8> flag is off, but the octets should be interpreted as
UTF-8 if the C<use utf8> pragma is in effect.  During a string eval,
however, the scalar may have the C<SvUTF8> flag on, and in this case its
octets should be interpreted as UTF-8 unless the C<use bytes> pragma
is in effect.  This logic may change in the future; use this function
instead of implementing the logic yourself.

=cut
*/

bool
Perl_lex_bufutf8(pTHX)
{
    return UTF;
}

/*
=for apidoc Amx|char *|lex_grow_linestr|STRLEN len

Reallocates the lexer buffer (L</PL_parser-E<gt>linestr>) to accommodate
at least I<len> octets (including terminating NUL).  Returns a
pointer to the reallocated buffer.  This is necessary before making
any direct modification of the buffer that would increase its length.
L</lex_stuff_pvn> provides a more convenient way to insert text into
the buffer.

Do not use C<SvGROW> or C<sv_grow> directly on C<PL_parser-E<gt>linestr>;
this function updates all of the lexer's variables that point directly
into the buffer.

=cut
*/

char *
Perl_lex_grow_linestr(pTHX_ STRLEN len)
{
    SV *linestr;
    char *buf;
    STRLEN bufend_pos, bufptr_pos, oldbufptr_pos, oldoldbufptr_pos;
    STRLEN linestart_pos, last_uni_pos, last_lop_pos;
    linestr = PL_parser->linestr;
    buf = SvPVX(linestr);
    if (len <= SvLEN(linestr))
	return buf;
    bufend_pos = PL_parser->bufend - buf;
    bufptr_pos = PL_parser->bufptr - buf;
    oldbufptr_pos = PL_parser->oldbufptr - buf;
    oldoldbufptr_pos = PL_parser->oldoldbufptr - buf;
    linestart_pos = PL_parser->linestart - buf;
    last_uni_pos = PL_parser->last_uni ? PL_parser->last_uni - buf : 0;
    last_lop_pos = PL_parser->last_lop ? PL_parser->last_lop - buf : 0;
    buf = sv_grow(linestr, len);
    PL_parser->bufend = buf + bufend_pos;
    PL_parser->bufptr = buf + bufptr_pos;
    PL_parser->oldbufptr = buf + oldbufptr_pos;
    PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
    PL_parser->linestart = buf + linestart_pos;
    if (PL_parser->last_uni)
	PL_parser->last_uni = buf + last_uni_pos;
    if (PL_parser->last_lop)
	PL_parser->last_lop = buf + last_lop_pos;
    return buf;
}

/*
=for apidoc Amx|void|lex_stuff_pvn|char *pv|STRLEN len|U32 flags

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is represented by I<len> octets starting
at I<pv>.  These octets are interpreted as either UTF-8 or Latin-1,
according to whether the C<LEX_STUFF_UTF8> flag is set in I<flags>.
The characters are recoded for the lexer buffer, according to how the
buffer is currently being interpreted (L</lex_bufutf8>).  If a string
to be interpreted is available as a Perl scalar, the L</lex_stuff_sv>
function is more convenient.

=cut
*/

void
Perl_lex_stuff_pvn(pTHX_ char *pv, STRLEN len, U32 flags)
{
    dVAR;
    char *bufptr;
    PERL_ARGS_ASSERT_LEX_STUFF_PVN;
    if (flags & ~(LEX_STUFF_UTF8))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_stuff_pvn");
    if (UTF) {
	if (flags & LEX_STUFF_UTF8) {
	    goto plain_copy;
	} else {
	    STRLEN highhalf = 0;
	    char *p, *e = pv+len;
	    for (p = pv; p != e; p++)
		highhalf += !!(((U8)*p) & 0x80);
	    if (!highhalf)
		goto plain_copy;
	    lex_grow_linestr(SvCUR(PL_parser->linestr)+1+len+highhalf);
	    bufptr = PL_parser->bufptr;
	    Move(bufptr, bufptr+len+highhalf, PL_parser->bufend+1-bufptr, char);
	    SvCUR_set(PL_parser->linestr,
	    	SvCUR(PL_parser->linestr) + len+highhalf);
	    PL_parser->bufend += len+highhalf;
	    for (p = pv; p != e; p++) {
		U8 c = (U8)*p;
		if (c & 0x80) {
		    *bufptr++ = (char)(0xc0 | (c >> 6));
		    *bufptr++ = (char)(0x80 | (c & 0x3f));
		} else {
		    *bufptr++ = (char)c;
		}
	    }
	}
    } else {
	if (flags & LEX_STUFF_UTF8) {
	    STRLEN highhalf = 0;
	    char *p, *e = pv+len;
	    for (p = pv; p != e; p++) {
		U8 c = (U8)*p;
		if (c >= 0xc4) {
		    Perl_croak(aTHX_ "Lexing code attempted to stuff "
				"non-Latin-1 character into Latin-1 input");
		} else if (c >= 0xc2 && p+1 != e &&
			    (((U8)p[1]) & 0xc0) == 0x80) {
		    p++;
		    highhalf++;
		} else if (c >= 0x80) {
		    /* malformed UTF-8 */
		    ENTER;
		    SAVESPTR(PL_warnhook);
		    PL_warnhook = PERL_WARNHOOK_FATAL;
		    utf8n_to_uvuni((U8*)p, e-p, NULL, 0);
		    LEAVE;
		}
	    }
	    if (!highhalf)
		goto plain_copy;
	    lex_grow_linestr(SvCUR(PL_parser->linestr)+1+len-highhalf);
	    bufptr = PL_parser->bufptr;
	    Move(bufptr, bufptr+len-highhalf, PL_parser->bufend+1-bufptr, char);
	    SvCUR_set(PL_parser->linestr,
	    	SvCUR(PL_parser->linestr) + len-highhalf);
	    PL_parser->bufend += len-highhalf;
	    for (p = pv; p != e; p++) {
		U8 c = (U8)*p;
		if (c & 0x80) {
		    *bufptr++ = (char)(((c & 0x3) << 6) | (p[1] & 0x3f));
		    p++;
		} else {
		    *bufptr++ = (char)c;
		}
	    }
	} else {
	    plain_copy:
	    lex_grow_linestr(SvCUR(PL_parser->linestr)+1+len);
	    bufptr = PL_parser->bufptr;
	    Move(bufptr, bufptr+len, PL_parser->bufend+1-bufptr, char);
	    SvCUR_set(PL_parser->linestr, SvCUR(PL_parser->linestr) + len);
	    PL_parser->bufend += len;
	    Copy(pv, bufptr, len, char);
	}
    }
}

/*
=for apidoc Amx|void|lex_stuff_sv|SV *sv|U32 flags

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is the string value of I<sv>.  The characters
are recoded for the lexer buffer, according to how the buffer is currently
being interpreted (L</lex_bufutf8>).  If a string to be interpreted is
not already a Perl scalar, the L</lex_stuff_pvn> function avoids the
need to construct a scalar.

=cut
*/

void
Perl_lex_stuff_sv(pTHX_ SV *sv, U32 flags)
{
    char *pv;
    STRLEN len;
    PERL_ARGS_ASSERT_LEX_STUFF_SV;
    if (flags)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_stuff_sv");
    pv = SvPV(sv, len);
    lex_stuff_pvn(pv, len, flags | (SvUTF8(sv) ? LEX_STUFF_UTF8 : 0));
}

/*
=for apidoc Amx|void|lex_unstuff|char *ptr

Discards text about to be lexed, from L</PL_parser-E<gt>bufptr> up to
I<ptr>.  Text following I<ptr> will be moved, and the buffer shortened.
This hides the discarded text from any lexing code that runs later,
as if the text had never appeared.

This is not the normal way to consume lexed text.  For that, use
L</lex_read_to>.

=cut
*/

void
Perl_lex_unstuff(pTHX_ char *ptr)
{
    char *buf, *bufend;
    STRLEN unstuff_len;
    PERL_ARGS_ASSERT_LEX_UNSTUFF;
    buf = PL_parser->bufptr;
    if (ptr < buf)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_unstuff");
    if (ptr == buf)
	return;
    bufend = PL_parser->bufend;
    if (ptr > bufend)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_unstuff");
    unstuff_len = ptr - buf;
    Move(ptr, buf, bufend+1-ptr, char);
    SvCUR_set(PL_parser->linestr, SvCUR(PL_parser->linestr) - unstuff_len);
    PL_parser->bufend = bufend - unstuff_len;
}

/*
=for apidoc Amx|void|lex_read_to|char *ptr

Consume text in the lexer buffer, from L</PL_parser-E<gt>bufptr> up
to I<ptr>.  This advances L</PL_parser-E<gt>bufptr> to match I<ptr>,
performing the correct bookkeeping whenever a newline character is passed.
This is the normal way to consume lexed text.

Interpretation of the buffer's octets can be abstracted out by
using the slightly higher-level functions L</lex_peek_unichar> and
L</lex_read_unichar>.

=cut
*/

void
Perl_lex_read_to(pTHX_ char *ptr)
{
    char *s;
    PERL_ARGS_ASSERT_LEX_READ_TO;
    s = PL_parser->bufptr;
    if (ptr < s || ptr > PL_parser->bufend)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_read_to");
    for (; s != ptr; s++)
	if (*s == '\n') {
	    CopLINE_inc(PL_curcop);
	    PL_parser->linestart = s+1;
	}
    PL_parser->bufptr = ptr;
}

/*
=for apidoc Amx|void|lex_discard_to|char *ptr

Discards the first part of the L</PL_parser-E<gt>linestr> buffer,
up to I<ptr>.  The remaining content of the buffer will be moved, and
all pointers into the buffer updated appropriately.  I<ptr> must not
be later in the buffer than the position of L</PL_parser-E<gt>bufptr>:
it is not permitted to discard text that has yet to be lexed.

Normally it is not necessarily to do this directly, because it suffices to
use the implicit discarding behaviour of L</lex_next_chunk> and things
based on it.  However, if a token stretches across multiple lines,
and the lexing code has kept multiple lines of text in the buffer fof
that purpose, then after completion of the token it would be wise to
explicitly discard the now-unneeded earlier lines, to avoid future
multi-line tokens growing the buffer without bound.

=cut
*/

void
Perl_lex_discard_to(pTHX_ char *ptr)
{
    char *buf;
    STRLEN discard_len;
    PERL_ARGS_ASSERT_LEX_DISCARD_TO;
    buf = SvPVX(PL_parser->linestr);
    if (ptr < buf)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_discard_to");
    if (ptr == buf)
	return;
    if (ptr > PL_parser->bufptr)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_discard_to");
    discard_len = ptr - buf;
    if (PL_parser->oldbufptr < ptr)
	PL_parser->oldbufptr = ptr;
    if (PL_parser->oldoldbufptr < ptr)
	PL_parser->oldoldbufptr = ptr;
    if (PL_parser->last_uni && PL_parser->last_uni < ptr)
	PL_parser->last_uni = NULL;
    if (PL_parser->last_lop && PL_parser->last_lop < ptr)
	PL_parser->last_lop = NULL;
    Move(ptr, buf, PL_parser->bufend+1-ptr, char);
    SvCUR_set(PL_parser->linestr, SvCUR(PL_parser->linestr) - discard_len);
    PL_parser->bufend -= discard_len;
    PL_parser->bufptr -= discard_len;
    PL_parser->oldbufptr -= discard_len;
    PL_parser->oldoldbufptr -= discard_len;
    if (PL_parser->last_uni)
	PL_parser->last_uni -= discard_len;
    if (PL_parser->last_lop)
	PL_parser->last_lop -= discard_len;
}

/*
=for apidoc Amx|bool|lex_next_chunk|U32 flags

Reads in the next chunk of text to be lexed, appending it to
L</PL_parser-E<gt>linestr>.  This should be called when lexing code has
looked to the end of the current chunk and wants to know more.  It is
usual, but not necessary, for lexing to have consumed the entirety of
the current chunk at this time.

If L</PL_parser-E<gt>bufptr> is pointing to the very end of the current
chunk (i.e., the current chunk has been entirely consumed), normally the
current chunk will be discarded at the same time that the new chunk is
read in.  If I<flags> includes C<LEX_KEEP_PREVIOUS>, the current chunk
will not be discarded.  If the current chunk has not been entirely
consumed, then it will not be discarded regardless of the flag.

Returns true if some new text was added to the buffer, or false if the
buffer has reached the end of the input text.

=cut
*/

#define LEX_FAKE_EOF 0x80000000

bool
Perl_lex_next_chunk(pTHX_ U32 flags)
{
    SV *linestr;
    char *buf;
    STRLEN old_bufend_pos, new_bufend_pos;
    STRLEN bufptr_pos, oldbufptr_pos, oldoldbufptr_pos;
    STRLEN linestart_pos, last_uni_pos, last_lop_pos;
    bool got_some_for_debugger = 0;
    bool got_some;
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_FAKE_EOF))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_next_chunk");
    linestr = PL_parser->linestr;
    buf = SvPVX(linestr);
    if (!(flags & LEX_KEEP_PREVIOUS) &&
	    PL_parser->bufptr == PL_parser->bufend) {
	old_bufend_pos = bufptr_pos = oldbufptr_pos = oldoldbufptr_pos = 0;
	linestart_pos = 0;
	if (PL_parser->last_uni != PL_parser->bufend)
	    PL_parser->last_uni = NULL;
	if (PL_parser->last_lop != PL_parser->bufend)
	    PL_parser->last_lop = NULL;
	last_uni_pos = last_lop_pos = 0;
	*buf = 0;
	SvCUR(linestr) = 0;
    } else {
	old_bufend_pos = PL_parser->bufend - buf;
	bufptr_pos = PL_parser->bufptr - buf;
	oldbufptr_pos = PL_parser->oldbufptr - buf;
	oldoldbufptr_pos = PL_parser->oldoldbufptr - buf;
	linestart_pos = PL_parser->linestart - buf;
	last_uni_pos = PL_parser->last_uni ? PL_parser->last_uni - buf : 0;
	last_lop_pos = PL_parser->last_lop ? PL_parser->last_lop - buf : 0;
    }
    if (flags & LEX_FAKE_EOF) {
	goto eof;
    } else if (!PL_parser->rsfp) {
	got_some = 0;
    } else if (filter_gets(linestr, old_bufend_pos)) {
	got_some = 1;
	got_some_for_debugger = 1;
    } else {
	if (!SvPOK(linestr))   /* can get undefined by filter_gets */
	    sv_setpvs(linestr, "");
	eof:
	/* End of real input.  Close filehandle (unless it was STDIN),
	 * then add implicit termination.
	 */
	if ((PerlIO*)PL_parser->rsfp == PerlIO_stdin())
	    PerlIO_clearerr(PL_parser->rsfp);
	else if (PL_parser->rsfp)
	    (void)PerlIO_close(PL_parser->rsfp);
	PL_parser->rsfp = NULL;
	PL_doextract = FALSE;
#ifdef PERL_MAD
	if (PL_madskills && !PL_in_eval && (PL_minus_p || PL_minus_n))
	    PL_faketokens = 1;
#endif
	if (!PL_in_eval && PL_minus_p) {
	    sv_catpvs(linestr,
		/*{*/";}continue{print or die qq(-p destination: $!\\n);}");
	    PL_minus_n = PL_minus_p = 0;
	} else if (!PL_in_eval && PL_minus_n) {
	    sv_catpvs(linestr, /*{*/";}");
	    PL_minus_n = 0;
	} else
	    sv_catpvs(linestr, ";");
	got_some = 1;
    }
    buf = SvPVX(linestr);
    new_bufend_pos = SvCUR(linestr);
    PL_parser->bufend = buf + new_bufend_pos;
    PL_parser->bufptr = buf + bufptr_pos;
    PL_parser->oldbufptr = buf + oldbufptr_pos;
    PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
    PL_parser->linestart = buf + linestart_pos;
    if (PL_parser->last_uni)
	PL_parser->last_uni = buf + last_uni_pos;
    if (PL_parser->last_lop)
	PL_parser->last_lop = buf + last_lop_pos;
    if (got_some_for_debugger && (PERLDB_LINE || PERLDB_SAVESRC) &&
	    PL_curstash != PL_debstash) {
	/* debugger active and we're not compiling the debugger code,
	 * so store the line into the debugger's array of lines
	 */
	update_debugger_info(NULL, buf+old_bufend_pos,
	    new_bufend_pos-old_bufend_pos);
    }
    return got_some;
}

/*
=for apidoc Amx|I32|lex_peek_unichar|U32 flags

Looks ahead one (Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the next character,
or -1 if lexing has reached the end of the input text.  To consume the
peeked character, use L</lex_read_unichar>.

If the next character is in (or extends into) the next chunk of input
text, the next chunk will be read in.  Normally the current chunk will be
discarded at the same time, but if I<flags> includes C<LEX_KEEP_PREVIOUS>
then the current chunk will not be discarded.

If the input is being interpreted as UTF-8 and a UTF-8 encoding error
is encountered, an exception is generated.

=cut
*/

I32
Perl_lex_peek_unichar(pTHX_ U32 flags)
{
    dVAR;
    char *s, *bufend;
    if (flags & ~(LEX_KEEP_PREVIOUS))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_peek_unichar");
    s = PL_parser->bufptr;
    bufend = PL_parser->bufend;
    if (UTF) {
	U8 head;
	I32 unichar;
	STRLEN len, retlen;
	if (s == bufend) {
	    if (!lex_next_chunk(flags))
		return -1;
	    s = PL_parser->bufptr;
	    bufend = PL_parser->bufend;
	}
	head = (U8)*s;
	if (!(head & 0x80))
	    return head;
	if (head & 0x40) {
	    len = PL_utf8skip[head];
	    while ((STRLEN)(bufend-s) < len) {
		if (!lex_next_chunk(flags | LEX_KEEP_PREVIOUS))
		    break;
		s = PL_parser->bufptr;
		bufend = PL_parser->bufend;
	    }
	}
	unichar = utf8n_to_uvuni((U8*)s, bufend-s, &retlen, UTF8_CHECK_ONLY);
	if (retlen == (STRLEN)-1) {
	    /* malformed UTF-8 */
	    ENTER;
	    SAVESPTR(PL_warnhook);
	    PL_warnhook = PERL_WARNHOOK_FATAL;
	    utf8n_to_uvuni((U8*)s, bufend-s, NULL, 0);
	    LEAVE;
	}
	return unichar;
    } else {
	if (s == bufend) {
	    if (!lex_next_chunk(flags))
		return -1;
	    s = PL_parser->bufptr;
	}
	return (U8)*s;
    }
}

/*
=for apidoc Amx|I32|lex_read_unichar|U32 flags

Reads the next (Unicode) character in the text currently being lexed.
Returns the codepoint (unsigned integer value) of the character read,
and moves L</PL_parser-E<gt>bufptr> past the character, or returns -1
if lexing has reached the end of the input text.  To non-destructively
examine the next character, use L</lex_peek_unichar> instead.

If the next character is in (or extends into) the next chunk of input
text, the next chunk will be read in.  Normally the current chunk will be
discarded at the same time, but if I<flags> includes C<LEX_KEEP_PREVIOUS>
then the current chunk will not be discarded.

If the input is being interpreted as UTF-8 and a UTF-8 encoding error
is encountered, an exception is generated.

=cut
*/

I32
Perl_lex_read_unichar(pTHX_ U32 flags)
{
    I32 c;
    if (flags & ~(LEX_KEEP_PREVIOUS))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_read_unichar");
    c = lex_peek_unichar(flags);
    if (c != -1) {
	if (c == '\n')
	    CopLINE_inc(PL_curcop);
	PL_parser->bufptr += UTF8SKIP(PL_parser->bufptr);
    }
    return c;
}

/*
=for apidoc Amx|void|lex_read_space|U32 flags

Reads optional spaces, in Perl style, in the text currently being
lexed.  The spaces may include ordinary whitespace characters and
Perl-style comments.  C<#line> directives are processed if encountered.
L</PL_parser-E<gt>bufptr> is moved past the spaces, so that it points
at a non-space character (or the end of the input text).

If spaces extend into the next chunk of input text, the next chunk will
be read in.  Normally the current chunk will be discarded at the same
time, but if I<flags> includes C<LEX_KEEP_PREVIOUS> then the current
chunk will not be discarded.

=cut
*/

#define LEX_NO_NEXT_CHUNK 0x80000000

void
Perl_lex_read_space(pTHX_ U32 flags)
{
    char *s, *bufend;
    bool need_incline = 0;
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_NO_NEXT_CHUNK))
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_read_space");
#ifdef PERL_MAD
    if (PL_skipwhite) {
	sv_free(PL_skipwhite);
	PL_skipwhite = NULL;
    }
    if (PL_madskills)
	PL_skipwhite = newSVpvs("");
#endif /* PERL_MAD */
    s = PL_parser->bufptr;
    bufend = PL_parser->bufend;
    while (1) {
	char c = *s;
	if (c == '#') {
	    do {
		c = *++s;
	    } while (!(c == '\n' || (c == 0 && s == bufend)));
	} else if (c == '\n') {
	    s++;
	    PL_parser->linestart = s;
	    if (s == bufend)
		need_incline = 1;
	    else
		incline(s);
	} else if (isSPACE(c)) {
	    s++;
	} else if (c == 0 && s == bufend) {
	    bool got_more;
#ifdef PERL_MAD
	    if (PL_madskills)
		sv_catpvn(PL_skipwhite, PL_parser->bufptr, s-PL_parser->bufptr);
#endif /* PERL_MAD */
	    if (flags & LEX_NO_NEXT_CHUNK)
		break;
	    PL_parser->bufptr = s;
	    CopLINE_inc(PL_curcop);
	    got_more = lex_next_chunk(flags);
	    CopLINE_dec(PL_curcop);
	    s = PL_parser->bufptr;
	    bufend = PL_parser->bufend;
	    if (!got_more)
		break;
	    if (need_incline && PL_parser->rsfp) {
		incline(s);
		need_incline = 0;
	    }
	} else {
	    break;
	}
    }
#ifdef PERL_MAD
    if (PL_madskills)
	sv_catpvn(PL_skipwhite, PL_parser->bufptr, s-PL_parser->bufptr);
#endif /* PERL_MAD */
    PL_parser->bufptr = s;
}

/*
a825 2
    if (!SPACE_OR_TAB(*s) && *s != '\r' && *s != '\n' && *s != '\0')
	return;
d998 1
a998 1
S_update_debugger_info(pTHX_ SV *orig_sv, const char *const buf, STRLEN len)
d1022 1
d1024 3
a1026 2
    char *start = s;
#endif /* PERL_MAD */
d1028 1
a1028 1
#ifdef PERL_MAD
d1031 1
a1031 1
	PL_skipwhite = NULL;
d1033 3
a1035 1
#endif /* PERL_MAD */
d1039 128
a1166 6
    } else {
	STRLEN bufptr_pos = PL_bufptr - SvPVX(PL_linestr);
	PL_bufptr = s;
	lex_read_space(LEX_KEEP_PREVIOUS |
		(PL_sublex_info.sub_inwhat || PL_lex_state == LEX_FORMLINE ?
		    LEX_NO_NEXT_CHUNK : 0));
d1168 13
a1180 4
	PL_bufptr = SvPVX(PL_linestr) + bufptr_pos;
	if (PL_linestart > PL_bufptr)
	    PL_bufptr = PL_linestart;
	return s;
d1182 1
d1184 9
a1192 3
    if (PL_madskills)
	PL_skipwhite = newSVpvn(start, s-start);
#endif /* PERL_MAD */
d1194 1
d1223 5
a1227 3
    Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
		     "Warning: Use of \"%.*s\" without parentheses is ambiguous",
		     (int)(s - PL_last_uni), PL_last_uni);
d1384 1
a1384 1
S_newSV_maybe_utf8(pTHX_ const char *const start, STRLEN len)
d1388 1
a1388 3
				  !IN_BYTES
				  && UTF
				  && !is_ascii_string((const U8*)start, len)
a1552 3
#ifdef USE_LOCALE_NUMERIC
	    char *loc = setlocale(LC_NUMERIC, "C");
#endif
a1553 3
#ifdef USE_LOCALE_NUMERIC
	    setlocale(LC_NUMERIC, loc);
#endif
d1564 5
a1568 37
	    if (PL_madskills) {
		sv_free(PL_nextwhite);	/* let next token collect whitespace */
		PL_nextwhite = 0;
		s = SvPVX(PL_linestr) + startoff;
	    }
#endif
	    return s;
	}
    }

#ifdef PERL_MAD
    if (PL_madskills && !version) {
	sv_free(PL_nextwhite);	/* let next token collect whitespace */
	PL_nextwhite = 0;
	s = SvPVX(PL_linestr) + startoff;
    }
#endif
    /* NOTE: The parser sees the package name and the VERSION swapped */
    start_force(PL_curforce);
    NEXTVAL_NEXTTOKE.opval = version;
    force_next(WORD);

    return s;
}

/*
 * S_force_strict_version
 * Forces the next token to be a version number using strict syntax rules.
 */

STATIC char *
S_force_strict_version(pTHX_ char *s)
{
    dVAR;
    OP *version = NULL;
#ifdef PERL_MAD
    I32 startoff = s - SvPVX(PL_linestr);
d1570 2
a1571 17
    const char *errstr = NULL;

    PERL_ARGS_ASSERT_FORCE_STRICT_VERSION;

    while (isSPACE(*s)) /* leading whitespace */
	s++;

    if (is_STRICT_VERSION(s,&errstr)) {
	SV *ver = newSV(0);
	s = (char *)scan_version(s, ver, 0);
	version = newSVOP(OP_CONST, 0, ver);
    }
    else if ( (*s != ';' && *s != '}' ) && (s = SKIPSPACE1(s), (*s != ';' && *s !='}' ))) {
	PL_bufptr = s;
	if (errstr)
	    yyerror(errstr); /* version required */
	return s;
d1878 4
a1881 1
      constants: \N{NAME} only
d1895 1
a1895 1
      constants: \x31, etc.
d1923 1
a1927 1
		  if a pattern and not \N{, go treat as regular character
d1930 1
a1930 1
		  handle \N{name} (named characters, also \N{3,5} in a pattern)
a1987 1

d2194 1
a2194 5
	    if (s + 1 < send && !strchr("()| \r\n\t", s[1])) {
		if (s[1] == '\\') {
		    Perl_ck_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
				   "Possible unintended interpolation of $\\ in regex");
		}
a2195 1
            }
a2201 2
	    char* e;	/* Can be used for ending '}', etc. */

d2208 2
a2209 1
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "\\%c better written as $%c", *s, *s);
d2219 2
a2220 18
	    /* In a pattern, process \N, but skip any other backslash escapes.
	     * This is because we don't want to translate an escape sequence
	     * into a meta symbol and have the regex compiler use the meta
	     * symbol meaning, e.g. \x{2E} would be confused with a dot.  But
	     * in spite of this, we do have to process \N here while the proper
	     * charnames handler is in scope.  See bugs #56444 and #62056.
	     * There is a complication because \N in a pattern may also stand
	     * for 'match a non-nl', and not mean a charname, in which case its
	     * processing should be deferred to the regex compiler.  To be a
	     * charname it must be followed immediately by a '{', and not look
	     * like \N followed by a curly quantifier, i.e., not something like
	     * \N{3,}.  regcurly returns a boolean indicating if it is a legal
	     * quantifier */
	    else if (PL_lex_inpat
		    && (*s != 'N'
			|| s[1] != '{'
			|| regcurly(s + 1)))
	    {
d2225 1
d2237 5
a2241 4
		    if ((isALPHA(*s) || isDIGIT(*s)))
			Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
				       "Unrecognized escape \\%c passed through",
				       *s);
d2285 4
a2288 4
		/* Insert oct or hex escaped character.  There will always be
		 * enough room in sv since such escapes will be longer than any
		 * UTF-8 sequence they can end up as, except if they force us
		 * to recode the rest of the string into utf8 */
d2291 3
a2293 1
		 * unicode (converted from native). */
d2303 1
d2305 1
a2305 3
			sv_utf8_upgrade_flags_grow(sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					UNISKIP(uv) + (STRLEN)(send - s) + 1);
d2332 2
d2335 6
a2340 41
		/* In a non-pattern \N must be a named character, like \N{LATIN
		 * SMALL LETTER A} or \N{U+0041}.  For patterns, it also can
		 * mean to match a non-newline.  For non-patterns, named
		 * characters are converted to their string equivalents. In
		 * patterns, named characters are not converted to their
		 * ultimate forms for the same reasons that other escapes
		 * aren't.  Instead, they are converted to the \N{U+...} form
		 * to get the value from the charnames that is in effect right
		 * now, while preserving the fact that it was a named character
		 * so that the regex compiler knows this */

		/* This section of code doesn't generally use the
		 * NATIVE_TO_NEED() macro to transform the input.  I (khw) did
		 * a close examination of this macro and determined it is a
		 * no-op except on utfebcdic variant characters.  Every
		 * character generated by this that would normally need to be
		 * enclosed by this macro is invariant, so the macro is not
		 * needed, and would complicate use of copy(). There are other
		 * parts of this file where the macro is used inconsistently,
		 * but are saved by it being a no-op */

		/* The structure of this section of code (besides checking for
		 * errors and upgrading to utf8) is:
		 *  Further disambiguate between the two meanings of \N, and if
		 *	not a charname, go process it elsewhere
		 *  If of form \N{U+...}, pass it through if a pattern;
		 *	otherwise convert to utf8
		 *  Otherwise must be \N{NAME}: convert to \N{U+c1.c2...} if a
		 *  pattern; otherwise convert to utf8 */

		/* Here, s points to the 'N'; the test below is guaranteed to
		 * succeed if we are being called on a pattern as we already
		 * know from a test above that the next character is a '{'.
		 * On a non-pattern \N must mean 'named sequence, which
		 * requires braces */
		s++;
		if (*s != '{') {
		    yyerror("Missing braces on \\N{}"); 
		    continue;
		}
		s++;
d2342 1
a2342 3
		/* If there is no matching '}', it is an error. */
		if (! (e = strchr(s, '}'))) {
		    if (! PL_lex_inpat) {
d2344 16
a2359 2
		    } else {
			yyerror("Missing right brace on \\N{} or unescaped left brace after \\N.");
d2361 16
a2376 2
		    continue;
		}
d2378 2
a2379 1
		/* Here it looks like a named character */
d2381 9
a2389 10
		if (PL_lex_inpat) {

		    /* XXX This block is temporary code.  \N{} implies that the
		     * pattern is to have Unicode semantics, and therefore
		     * currently has to be encoded in utf8.  By putting it in
		     * utf8 now, we save a whole pass in the regular expression
		     * compiler.  Once that code is changed so Unicode
		     * semantics doesn't necessarily have to be in utf8, this
		     * block should be removed */
		    if (!has_utf8) {
d2393 1
d2395 1
a2395 4
			sv_utf8_upgrade_flags_grow(sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					/* 5 = '\N{' + cur char + NUL */
					(STRLEN)(send - s) + 5);
d2398 1
a2398 155
		    }
		}

		if (*s == 'U' && s[1] == '+') { /* \N{U+...} */
		    I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
				| PERL_SCAN_DISALLOW_PREFIX;
		    STRLEN len;

		    /* For \N{U+...}, the '...' is a unicode value even on
		     * EBCDIC machines */
		    s += 2;	    /* Skip to next char after the 'U+' */
		    len = e - s;
		    uv = grok_hex(s, &len, &flags, NULL);
		    if (len == 0 || len != (STRLEN)(e - s)) {
			yyerror("Invalid hexadecimal number in \\N{U+...}");
			s = e + 1;
			continue;
		    }

		    if (PL_lex_inpat) {

			/* Pass through to the regex compiler unchanged.  The
			 * reason we evaluated the number above is to make sure
			 * there wasn't a syntax error. */
			s -= 5;	    /* Include the '\N{U+' */
			Copy(s, d, e - s + 1, char);	/* 1 = include the } */
			d += e - s + 1;
		    }
		    else {  /* Not a pattern: convert the hex to string */

			 /* If destination is not in utf8, unconditionally
			  * recode it to be so.  This is because \N{} implies
			  * Unicode semantics, and scalars have to be in utf8
			  * to guarantee those semantics */
			if (! has_utf8) {
			    SvCUR_set(sv, d - SvPVX_const(sv));
			    SvPOK_on(sv);
			    *d = '\0';
			    /* See Note on sizing above.  */
			    sv_utf8_upgrade_flags_grow(
					sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					UNISKIP(uv) + (STRLEN)(send - e) + 1);
			    d = SvPVX(sv) + SvCUR(sv);
			    has_utf8 = TRUE;
			}

			/* Add the string to the output */
			if (UNI_IS_INVARIANT(uv)) {
			    *d++ = (char) uv;
			}
			else d = (char*)uvuni_to_utf8((U8*)d, uv);
		    }
		}
		else { /* Here is \N{NAME} but not \N{U+...}. */

		    SV *res;		/* result from charnames */
		    const char *str;    /* the string in 'res' */
		    STRLEN len;		/* its length */

		    /* Get the value for NAME */
		    res = newSVpvn(s, e - s);
		    res = new_constant( NULL, 0, "charnames",
					/* includes all of: \N{...} */
					res, NULL, s - 3, e - s + 4 );

		    /* Most likely res will be in utf8 already since the
		     * standard charnames uses pack U, but a custom translator
		     * can leave it otherwise, so make sure.  XXX This can be
		     * revisited to not have charnames use utf8 for characters
		     * that don't need it when regexes don't have to be in utf8
		     * for Unicode semantics.  If doing so, remember EBCDIC */
		    sv_utf8_upgrade(res);
		    str = SvPV_const(res, len);

		    /* Don't accept malformed input */
		    if (! is_utf8_string((U8 *) str, len)) {
			yyerror("Malformed UTF-8 returned by \\N");
		    }
		    else if (PL_lex_inpat) {

			if (! len) { /* The name resolved to an empty string */
			    Copy("\\N{}", d, 4, char);
			    d += 4;
			}
			else {
			    /* In order to not lose information for the regex
			    * compiler, pass the result in the specially made
			    * syntax: \N{U+c1.c2.c3...}, where c1 etc. are
			    * the code points in hex of each character
			    * returned by charnames */

			    const char *str_end = str + len;
			    STRLEN char_length;	    /* cur char's byte length */
			    STRLEN output_length;   /* and the number of bytes
						       after this is translated
						       into hex digits */
			    const STRLEN off = d - SvPVX_const(sv);

			    /* 2 hex per byte; 2 chars for '\N'; 2 chars for
			     * max('U+', '.'); and 1 for NUL */
			    char hex_string[2 * UTF8_MAXBYTES + 5];

			    /* Get the first character of the result. */
			    U32 uv = utf8n_to_uvuni((U8 *) str,
						    len,
						    &char_length,
						    UTF8_ALLOW_ANYUV);

			    /* The call to is_utf8_string() above hopefully
			     * guarantees that there won't be an error.  But
			     * it's easy here to make sure.  The function just
			     * above warns and returns 0 if invalid utf8, but
			     * it can also return 0 if the input is validly a
			     * NUL. Disambiguate */
			    if (uv == 0 && NATIVE_TO_ASCII(*str) != '\0') {
				uv = UNICODE_REPLACEMENT;
			    }

			    /* Convert first code point to hex, including the
			     * boiler plate before it */
			    sprintf(hex_string, "\\N{U+%X", (unsigned int) uv);
			    output_length = strlen(hex_string);

			    /* Make sure there is enough space to hold it */
			    d = off + SvGROW(sv, off
						 + output_length
						 + (STRLEN)(send - e)
						 + 2);	/* '}' + NUL */
			    /* And output it */
			    Copy(hex_string, d, output_length, char);
			    d += output_length;

			    /* For each subsequent character, append dot and
			     * its ordinal in hex */
			    while ((str += char_length) < str_end) {
				const STRLEN off = d - SvPVX_const(sv);
				U32 uv = utf8n_to_uvuni((U8 *) str,
							str_end - str,
							&char_length,
							UTF8_ALLOW_ANYUV);
				if (uv == 0 && NATIVE_TO_ASCII(*str) != '\0') {
				    uv = UNICODE_REPLACEMENT;
				}

				sprintf(hex_string, ".%X", (unsigned int) uv);
				output_length = strlen(hex_string);

				d = off + SvGROW(sv, off
						     + output_length
						     + (STRLEN)(send - e)
						     + 2);	/* '}' +  NUL */
				Copy(hex_string, d, output_length, char);
				d += output_length;
			    }
d2400 4
a2403 93
			    *d++ = '}';	/* Done.  Add the trailing brace */
			}
		    }
		    else { /* Here, not in a pattern.  Convert the name to a
			    * string. */

			 /* If destination is not in utf8, unconditionally
			  * recode it to be so.  This is because \N{} implies
			  * Unicode semantics, and scalars have to be in utf8
			  * to guarantee those semantics */
			if (! has_utf8) {
			    SvCUR_set(sv, d - SvPVX_const(sv));
			    SvPOK_on(sv);
			    *d = '\0';
			    /* See Note on sizing above.  */
			    sv_utf8_upgrade_flags_grow(sv,
						SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
						len + (STRLEN)(send - s) + 1);
			    d = SvPVX(sv) + SvCUR(sv);
			    has_utf8 = TRUE;
			} else if (len > (STRLEN)(e - s + 4)) { /* I _guess_ 4 is \N{} --jhi */

			    /* See Note on sizing above.  (NOTE: SvCUR() is not
			     * set correctly here). */
			    const STRLEN off = d - SvPVX_const(sv);
			    d = off + SvGROW(sv, off + len + (STRLEN)(send - s) + 1);
			}
			Copy(str, d, len, char);
			d += len;
		    }
		    SvREFCNT_dec(res);

		    /* Deprecate non-approved name syntax */
		    if (ckWARN_d(WARN_DEPRECATED)) {
			bool problematic = FALSE;
			char* i = s;

			/* For non-ut8 input, look to see that the first
			 * character is an alpha, then loop through the rest
			 * checking that each is a continuation */
			if (! this_utf8) {
			    if (! isALPHAU(*i)) problematic = TRUE;
			    else for (i = s + 1; i < e; i++) {
				if (isCHARNAME_CONT(*i)) continue;
				problematic = TRUE;
				break;
			    }
			}
			else {
			    /* Similarly for utf8.  For invariants can check
			     * directly.  We accept anything above the latin1
			     * range because it is immaterial to Perl if it is
			     * correct or not, and is expensive to check.  But
			     * it is fairly easy in the latin1 range to convert
			     * the variants into a single character and check
			     * those */
			    if (UTF8_IS_INVARIANT(*i)) {
				if (! isALPHAU(*i)) problematic = TRUE;
			    } else if (UTF8_IS_DOWNGRADEABLE_START(*i)) {
				if (! isALPHAU(UNI_TO_NATIVE(UTF8_ACCUMULATE(*i,
									    *(i+1)))))
				{
				    problematic = TRUE;
				}
			    }
			    if (! problematic) for (i = s + UTF8SKIP(s);
						    i < e;
						    i+= UTF8SKIP(i))
			    {
				if (UTF8_IS_INVARIANT(*i)) {
				    if (isCHARNAME_CONT(*i)) continue;
				} else if (! UTF8_IS_DOWNGRADEABLE_START(*i)) {
				    continue;
				} else if (isCHARNAME_CONT(
					    UNI_TO_NATIVE(
					    UTF8_ACCUMULATE(*i, *(i+1)))))
				{
				    continue;
				}
				problematic = TRUE;
				break;
			    }
			}
			if (problematic) {
			    char *string;
			    Newx(string, e - i + 1, char);
			    Copy(i, string, e - i, char);
			    string[e - i] = '\0';
			    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
				"Deprecated character(s) in \\N{...} starting at '%s'",
				string);
			    Safefree(string);
			}
a2404 1
		} /* End \N{NAME} */
d2406 2
a2407 2
		if (!dorange) 
		    native_range = FALSE; /* \N{} is defined to be Unicode */
d2409 8
a2416 1
		s = e + 1;  /* Point to just after the '}' */
d2487 2
d2490 1
a2490 3
		sv_utf8_upgrade_flags_grow(sv,
					SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
					need + (STRLEN)(send - s) + 1);
d2821 1
a2821 1
						  S_newSV_maybe_utf8(aTHX_ tmpbuf, len));
d2944 1
a2944 1
	    SvGROW(buf_sv, (STRLEN)(old_len + correct_length + 1)) ;
a2952 1
	    SvPVX(buf_sv)[old_len + len] = '\0';
d2983 1
a2983 1
S_filter_gets(pTHX_ register SV *sv, STRLEN append)
d3003 1
a3003 1
        return (sv_gets(sv, PL_rsfp, append));
d3257 1
a3257 2
	if (*s == ';' || *s == '}'
		|| (s = SKIPSPACE1(s), (*s == ';' || *s == '}'))) {
a3317 1
    U32 fake_eof = 0;
d3652 2
a3653 11
	{
        unsigned char c = *s;
        len = UTF ? Perl_utf8_length(aTHX_ (U8 *) PL_linestart, (U8 *) s) : (STRLEN) (s - PL_linestart);
        if (len > UNRECOGNIZED_PRECEDE_COUNT) {
            d = UTF ? (char *) Perl_utf8_hop(aTHX_ (U8 *) s, -UNRECOGNIZED_PRECEDE_COUNT) : s - UNRECOGNIZED_PRECEDE_COUNT;
        } else {
            d = PL_linestart;
        }	
        *s = '\0';
        Perl_croak(aTHX_ "Unrecognized character \\x%02X; marked by <-- HERE after %s<-- HERE near column %d", c, d, (int) len + 1);
    }
d3717 1
a3717 1
		sv_catpvs(PL_linestr, "LINE: while (<>) {"/*}*/);
a3755 1
	    fake_eof = 0;
d3757 1
a3757 1
	    if (0) {
a3758 10
		fake_eof = LEX_FAKE_EOF;
	    }
	    PL_bufptr = PL_bufend;
	    CopLINE_inc(PL_curcop);
	    if (!lex_next_chunk(fake_eof)) {
		CopLINE_dec(PL_curcop);
		s = PL_bufptr;
		TOKEN(';');	/* not infinite loop because rsfp is NULL now */
	    }
	    CopLINE_dec(PL_curcop);
a3759 1
	    if (!PL_rsfp)
d3762 30
a3791 1
	    s = PL_bufptr;
d3794 1
a3794 1
	    if (bof && PL_rsfp &&
d3799 21
d3821 1
d3841 1
a3841 2
	    if (PL_rsfp)
		incline(s);
d3844 2
d3954 1
d3970 1
a3970 1
			Newx(newargv,PL_origargc+3,char*);
d3985 1
d4055 3
a4330 3
	    if (*s == '=') {
		deprecate(":= for an empty attribute list");
	    }
a4352 1
		    case KEY_foreach:
d4388 5
d4407 1
a4407 1
			deprecate(":locked");
d4889 3
a4891 1
		return deprecate_commaless_var_list();
d4930 1
a4930 1
	    if (PL_lex_state == LEX_NORMAL || PL_lex_brackets)
d5071 1
a5071 1
	if (PL_expect == XOPERATOR) {
d5074 1
a5074 1
		OPERATOR('?');
a5112 4
	if (PL_expect == XSTATE && s[1] == '.' && s[2] == '.') {
	    s += 3;
	    OPERATOR(YADAYADA);
	}
d5125 2
d5143 3
a5145 1
		return deprecate_commaless_var_list();
d5160 3
a5162 1
		return deprecate_commaless_var_list();
d5192 3
a5194 3
	if (PL_lex_inwhat && isDIGIT(*s))
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),"Can't use \\%c to mean $%c in expression",
			   *s, *s);
a5255 1
	bool anydelim;
d5266 1
a5266 1
	anydelim = ((len == 1 && strchr("msyq", PL_tokenbuf[0])) ||
d5272 1
a5272 1
	if (!anydelim && *s == ':' && s[1] == ':' && strNE(PL_tokenbuf, "CORE"))
d5279 12
a5300 39
	/* Check for plugged-in keyword */
	{
	    OP *o;
	    int result;
	    char *saved_bufptr = PL_bufptr;
	    PL_bufptr = s;
	    result = CALL_FPTR(PL_keyword_plugin)(aTHX_ PL_tokenbuf, len, &o);
	    s = PL_bufptr;
	    if (result == KEYWORD_PLUGIN_DECLINE) {
		/* not a plugged-in keyword */
		PL_bufptr = saved_bufptr;
	    } else if (result == KEYWORD_PLUGIN_STMT) {
		pl_yylval.opval = o;
		CLINE;
		PL_expect = XSTATE;
		return REPORT(PLUGSTMT);
	    } else if (result == KEYWORD_PLUGIN_EXPR) {
		pl_yylval.opval = o;
		CLINE;
		PL_expect = XOPERATOR;
		return REPORT(PLUGEXPR);
	    } else {
		Perl_croak(aTHX_ "Bad plugin affecting keyword '%s'",
					PL_tokenbuf);
	    }
	}

	/* Check for built-in keyword */
	tmp = keyword(PL_tokenbuf, len, 0);

	/* Is this a label? */
	if (!anydelim && PL_expect == XSTATE
	      && d < PL_bufend && *d == ':' && *(d + 1) != ':') {
	    s = d + 1;
	    pl_yylval.pval = CopLABEL_alloc(PL_tokenbuf);
	    CLINE;
	    TOKEN(LABEL);
	}

d5334 3
a5336 3
		if (tmp == KEY_dump) {
		    Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
				   "dump() better written as CORE::dump()");
d5340 5
a5344 4
		if (hgv && tmp != KEY_x && tmp != KEY_CORE)	/* never ambiguous */
		    Perl_ck_warner(aTHX_ packWARN(WARN_AMBIGUOUS),
				   "Ambiguous call resolved as CORE::%s(), %s",
				   GvENAME(hgv), "qualify as such or use &");
a5365 1
		OP *rv2cv_op;
d5459 13
a5471 23
		cv = NULL;
		{
		    OP *const_op = newSVOP(OP_CONST, 0, SvREFCNT_inc(sv));
		    const_op->op_private = OPpCONST_BARE;
		    rv2cv_op = newCVREF(0, const_op);
		}
		if (rv2cv_op->op_type == OP_RV2CV &&
			(rv2cv_op->op_flags & OPf_KIDS)) {
		    OP *rv_op = cUNOPx(rv2cv_op)->op_first;
		    switch (rv_op->op_type) {
			case OP_CONST: {
			    SV *sv = cSVOPx_sv(rv_op);
			    if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV)
				cv = (CV*)SvRV(sv);
			} break;
			case OP_GV: {
			    GV *gv = cGVOPx_gv(rv_op);
			    CV *maybe_cv = GvCVu(gv);
			    if (maybe_cv && SvTYPE((SV*)maybe_cv) == SVt_PVCV)
				cv = maybe_cv;
			} break;
		    }
		}
d5494 1
a5494 2
			(tmp = intuit_method(s, gv, cv))) {
			op_free(rv2cv_op);
a5495 1
		    }
d5503 1
a5503 1
                         (!cv &&
a5525 1
		    op_free(rv2cv_op);
d5540 1
a5540 1
			if (*d == ')' && (sv = cv_const_sv(cv))) {
a5560 1
		    op_free(rv2cv_op);
d5568 1
a5568 2
		if ((*s == '$' || *s == '{') && !cv) {
		    op_free(rv2cv_op);
d5578 1
a5578 2
			&& (tmp = intuit_method(s, gv, cv))) {
		    op_free(rv2cv_op);
a5579 1
		}
d5584 4
a5587 4
		    if (lastchar == '-')
			Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
					 "Ambiguous use of -%s resolved as -&%s()",
					 PL_tokenbuf, PL_tokenbuf);
d5589 1
a5589 1
		    if ((sv = cv_const_sv(cv))) {
a5590 1
			op_free(rv2cv_op);
d5597 9
d5607 1
a5607 1
		    pl_yylval.opval = rv2cv_op;
d5675 1
a5675 1
			pl_yylval.opval = rv2cv_op;
a5703 12
		    /* after "print" and similar functions (corresponding to
		     * "F? L" in opcode.pl), whatever wasn't already parsed as
		     * a filehandle should be subject to "strict subs".
		     * Likewise for the optional indirect-object argument to system
		     * or exec, which can't be a bareword */
		    if ((PL_last_lop_op == OP_PRINT
			    || PL_last_lop_op == OP_PRTF
			    || PL_last_lop_op == OP_SAY
			    || PL_last_lop_op == OP_SYSTEM
			    || PL_last_lop_op == OP_EXEC)
			    && (PL_hints & HINT_STRICT_SUBS))
			pl_yylval.opval->op_private |= OPpCONST_STRICT;
a5714 1
		op_free(rv2cv_op);
d5717 8
a5724 7
		if ((lastchar == '*' || lastchar == '%' || lastchar == '&')) {
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
				     "Operator or semicolon missing before %c%s",
				     lastchar, PL_tokenbuf);
		    Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
				     "Ambiguous use of %c resolved as operator %c",
				     lastchar, lastchar);
d5767 3
a5769 1
		if ((PerlIO*)PL_rsfp == PerlIO_stdin())
d5837 2
a5838 2
		    while ((s = filter_gets(PL_endwhite, SvCUR(PL_endwhite)))
			   != NULL) ;
d6027 2
a6028 8
	    if (*s == '{') { /* block eval */
		PL_expect = XTERMBLOCK;
		UNIBRACK(OP_ENTERTRY);
	    }
	    else { /* string eval */
		PL_expect = XTERM;
		UNIBRACK(OP_ENTEREVAL);
	    }
a6398 2
	    s = SKIPSPACE1(s);
	    s = force_strict_version(s);
d6779 1
a6779 7
		    bool in_brackets = FALSE;
		    char greedy_proto = ' ';
		    bool proto_after_greedy_proto = FALSE;
		    bool must_be_last = FALSE;
		    bool underscore = FALSE;
		    bool seen_underscore = FALSE;
		    const bool warnillegalproto = ckWARN(WARN_ILLEGALPROTO);
d6790 2
a6791 30

			    if (warnillegalproto) {
				if (must_be_last)
				    proto_after_greedy_proto = TRUE;
				if (!strchr("$@@%*;[]&\\_", *p)) {
				    bad_proto = TRUE;
				}
				else {
				    if ( underscore ) {
					if ( *p != ';' )
					    bad_proto = TRUE;
					underscore = FALSE;
				    }
				    if ( *p == '[' ) {
					in_brackets = TRUE;
				    }
				    else if ( *p == ']' ) {
					in_brackets = FALSE;
				    }
				    else if ( (*p == '@@' || *p == '%') &&
					 ( tmp < 2 || d[tmp-2] != '\\' ) &&
					 !in_brackets ) {
					must_be_last = TRUE;
					greedy_proto = *p;
				    }
				    else if ( *p == '_' ) {
					underscore = seen_underscore = TRUE;
				    }
				}
			    }
a6794 4
		    if (proto_after_greedy_proto)
			Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
				    "Prototype after '%c' for %"SVf" : %s",
				    greedy_proto, SVfARG(PL_subname), d);
d6796 2
a6797 3
			Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
				    "Illegal character %sin prototype for %"SVf" : %s",
				    seen_underscore ? "after '_' " : "",
d6826 1
a6826 1
		    else if (*s != ';' && *s != '}')
d7039 1
a7039 1
            tmp = allocmy(PL_tokenbuf, tokenbuf_len, 0);
d7047 1
a7047 1
            pl_yylval.opval->op_targ = allocmy(PL_tokenbuf, tokenbuf_len, 0);
d7066 1
a7066 1
	    tmp = pad_findmy(PL_tokenbuf, tokenbuf_len, 0);
d7117 1
a7117 2
    if (ckWARN(WARN_AMBIGUOUS) &&
	pit == '@@' && PL_lex_state != LEX_NORMAL && !PL_lex_brackets) {
d7121 1
d7129 2
a7130 2
			"Possible unintended interpolation of %s in string",
			PL_tokenbuf);
d8671 2
a8672 1
                  Perl_ck_warner_d(aTHX_ packWARN(WARN_SYNTAX), "elseif should be elsif");
a10652 5

    /* charnames doesn't work well if there have been errors found */
    if (PL_error_count > 0 && strEQ(key,"charnames"))
	return &PL_sv_undef;

d10766 1
a10766 1
    register char * const e = d + destlen - 3;    /* two-character token, ending NUL */
a10920 12
static U32
S_pmflag(U32 pmfl, const char ch) {
    switch (ch) {
	CASE_STD_PMMOD_FLAGS_PARSE_SET(&pmfl);
    case GLOBAL_PAT_MOD:    pmfl |= PMf_GLOBAL; break;
    case CONTINUE_PAT_MOD:  pmfl |= PMf_CONTINUE; break;
    case ONCE_PAT_MOD:      pmfl |= PMf_KEEP; break;
    case KEEPCOPY_PAT_MOD:  pmfl |= PMf_KEEPCOPY; break;
    }
    return pmfl;
}

d10926 1
a10926 3
    Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
		     "Perl_pmflag() is deprecated, and will be removed from the XS API");

d10928 8
a10935 1
	*pmfl = S_pmflag(*pmfl, (char)ch);
d10989 1
a10989 1
	pm->op_pmflags = S_pmflag(pm->op_pmflags, *s++);
d10997 2
a10998 1
    if ((pm->op_pmflags & PMf_CONTINUE) && !(pm->op_pmflags & PMf_GLOBAL))
d11000 2
a11001 2
        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), 
		       "Use of /c modifier is meaningless without /g" );
d11070 1
a11070 1
	    pm->op_pmflags = S_pmflag(pm->op_pmflags, *s++);
d11083 2
a11084 2
    if ((pm->op_pmflags & PMf_CONTINUE)) {
        Perl_ck_warner(aTHX_ packWARN(WARN_REGEXP), "Use of /c modifier is meaningless in s///" );
d11252 1
a11252 1
	    deprecate("bare << to mean <<\"\"");
d11412 2
a11413 3
	PL_bufptr = s;
	CopLINE_inc(PL_curcop);
	if (!outer || !lex_next_chunk(0)) {
a11416 2
	CopLINE_dec(PL_curcop);
	s = PL_bufptr;
d11438 2
d11568 1
a11568 1
	    const PADOFFSET tmp = pad_findmy(d, len, 0);
d11924 2
a11925 3
	CopLINE_inc(PL_curcop);
	PL_bufptr = PL_bufend;
	if (!lex_next_chunk(0)) {
a11929 1
	s = PL_bufptr;
d11933 10
d12096 2
a12097 1
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
d12120 3
a12122 3
		    if (lastub && s == lastub + 1)
		        Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				       "Misplaced _ in number");
d12164 4
a12167 3
			    Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
					     "Integer overflow in %s number",
					     base);
d12194 2
a12195 1
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
d12200 4
a12203 4
		if (n > 4294967295.0)
		    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
				   "%s number > %s non-portable",
				   Base, max);
d12208 4
a12211 4
		if (u > 0xffffffff)
		    Perl_ck_warner(aTHX_ packWARN(WARN_PORTABLE),
				   "%s number > %s non-portable",
				   Base, max);
d12240 3
a12242 3
		if (lastub && s == lastub + 1)
		    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				   "Misplaced _ in number");
d12256 2
a12257 1
	    Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Misplaced _ in number");
d12269 3
a12271 2
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
d12282 3
a12284 3
		   if (lastub && s == lastub + 1)
		       Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				      "Misplaced _ in number");
d12292 3
a12294 2
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
d12313 3
a12315 2
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
d12325 3
a12327 2
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
			       "Misplaced _ in number");
d12340 4
a12343 3
			(!isDIGIT(s[1]) && s[1] != '_')))
		       Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX),
				      "Misplaced _ in number");
a12476 1
	    bool got_some;
d12485 1
a12485 5
	    PL_bufptr = PL_bufend;
	    CopLINE_inc(PL_curcop);
	    got_some = lex_next_chunk(0);
	    CopLINE_dec(PL_curcop);
	    s = PL_bufptr;
d12487 3
a12489 1
	    tokenstart = PL_bufptr;
d12491 4
a12494 1
	    if (!got_some)
d12496 1
d12570 2
a12571 2
static int
S_yywarn(pTHX_ const char *const s)
d12584 1
a12584 1
Perl_yyerror(pTHX_ const char *const s)
d12667 2
a12668 1
	Perl_ck_warner_d(aTHX_ packWARN(WARN_SYNTAX), "%"SVf, SVfARG(msg));
d12699 1
a12699 1
	    /* UTF-16 little-endian? (or UTF-32LE?) */
d12701 1
a12701 1
		Perl_croak(aTHX_ "Unsupported script encoding UTF-32LE");
d12703 1
a12703 1
	    if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-16LE script encoding (BOM)\n");
d12705 1
d12707 22
a12728 1
		s = add_utf16_textfilter(s, TRUE);
d12731 1
a12731 1
	    Perl_croak(aTHX_ "Unsupported script encoding UTF-16LE");
d12740 1
d12742 13
a12754 1
		s = add_utf16_textfilter(s, FALSE);
d12757 1
a12757 1
	    Perl_croak(aTHX_ "Unsupported script encoding UTF-16BE");
d12772 1
a12772 1
		       Perl_croak(aTHX_ "Unsupported script encoding UTF-32BE");
a12778 1
#ifndef PERL_NO_UTF16_FILTER
d12780 1
a12780 4
		  s = add_utf16_textfilter(s, FALSE);
#else
		  Perl_croak(aTHX_ "Unsupported script encoding UTF-16BE");
#endif
a12796 1
#ifndef PERL_NO_UTF16_FILTER
d12798 1
a12798 4
	      s = add_utf16_textfilter(s, TRUE);
#else
	      Perl_croak(aTHX_ "Unsupported script encoding UTF-16LE");
#endif
d12807 1
a12807 1
S_utf16_textfilter(pTHX_ int idx, SV *sv, int maxlen)
d12810 2
a12811 18
    SV *const filter = FILTER_DATA(idx);
    /* We re-use this each time round, throwing the contents away before we
       return.  */
    SV *const utf16_buffer = MUTABLE_SV(IoTOP_GV(filter));
    SV *const utf8_buffer = filter;
    IV status = IoPAGE(filter);
    const bool reverse = (bool) IoLINES(filter);
    I32 retval;

    /* As we're automatically added, at the lowest level, and hence only called
       from this file, we can be sure that we're not called in block mode. Hence
       don't bother writing code to deal with block mode.  */
    if (maxlen) {
	Perl_croak(aTHX_ "panic: utf16_textfilter called in block mode (for %d characters)", maxlen);
    }
    if (status < 0) {
	Perl_croak(aTHX_ "panic: utf16_textfilter called after error (status=%"IVdf")", status);
    }
d12813 5
a12817 8
			  "utf16_textfilter(%p,%ce): idx=%d maxlen=%d status=%"IVdf" utf16=%"UVuf" utf8=%"UVuf"\n",
			  FPTR2DPTR(void *, S_utf16_textfilter),
			  reverse ? 'l' : 'b', idx, maxlen, status,
			  (UV)SvCUR(utf16_buffer), (UV)SvCUR(utf8_buffer)));

    while (1) {
	STRLEN chars;
	STRLEN have;
d12819 5
a12823 80
	U8 *end;
	/* First, look in our buffer of existing UTF-8 data:  */
	char *nl = (char *)memchr(SvPVX(utf8_buffer), '\n', SvCUR(utf8_buffer));

	if (nl) {
	    ++nl;
	} else if (status == 0) {
	    /* EOF */
	    IoPAGE(filter) = 0;
	    nl = SvEND(utf8_buffer);
	}
	if (nl) {
	    STRLEN got = nl - SvPVX(utf8_buffer);
	    /* Did we have anything to append?  */
	    retval = got != 0;
	    sv_catpvn(sv, SvPVX(utf8_buffer), got);
	    /* Everything else in this code works just fine if SVp_POK isn't
	       set.  This, however, needs it, and we need it to work, else
	       we loop infinitely because the buffer is never consumed.  */
	    sv_chop(utf8_buffer, nl);
	    break;
	}

	/* OK, not a complete line there, so need to read some more UTF-16.
	   Read an extra octect if the buffer currently has an odd number. */
	while (1) {
	    if (status <= 0)
		break;
	    if (SvCUR(utf16_buffer) >= 2) {
		/* Location of the high octet of the last complete code point.
		   Gosh, UTF-16 is a pain. All the benefits of variable length,
		   *coupled* with all the benefits of partial reads and
		   endianness.  */
		const U8 *const last_hi = (U8*)SvPVX(utf16_buffer)
		    + ((SvCUR(utf16_buffer) & ~1) - (reverse ? 1 : 2));

		if (*last_hi < 0xd8 || *last_hi > 0xdb) {
		    break;
		}

		/* We have the first half of a surrogate. Read more.  */
		DEBUG_P(PerlIO_printf(Perl_debug_log, "utf16_textfilter partial surrogate detected at %p\n", last_hi));
	    }

	    status = FILTER_READ(idx + 1, utf16_buffer,
				 160 + (SvCUR(utf16_buffer) & 1));
	    DEBUG_P(PerlIO_printf(Perl_debug_log, "utf16_textfilter status=%"IVdf" SvCUR(sv)=%"UVuf"\n", status, (UV)SvCUR(utf16_buffer)));
	    DEBUG_P({ sv_dump(utf16_buffer); sv_dump(utf8_buffer);});
	    if (status < 0) {
		/* Error */
		IoPAGE(filter) = status;
		return status;
	    }
	}

	chars = SvCUR(utf16_buffer) >> 1;
	have = SvCUR(utf8_buffer);
	SvGROW(utf8_buffer, have + chars * 3 + 1);

	if (reverse) {
	    end = utf16_to_utf8_reversed((U8*)SvPVX(utf16_buffer),
					 (U8*)SvPVX_const(utf8_buffer) + have,
					 chars * 2, &newlen);
	} else {
	    end = utf16_to_utf8((U8*)SvPVX(utf16_buffer),
				(U8*)SvPVX_const(utf8_buffer) + have,
				chars * 2, &newlen);
	}
	SvCUR_set(utf8_buffer, have + newlen);
	*end = '\0';

	/* No need to keep this SV "well-formed" with a '\0' after the end, as
	   it's private to us, and utf16_to_utf8{,reversed} take a
	   (pointer,length) pair, rather than a NUL-terminated string.  */
	if(SvCUR(utf16_buffer) & 1) {
	    *SvPVX(utf16_buffer) = SvEND(utf16_buffer)[-1];
	    SvCUR_set(utf16_buffer, 1);
	} else {
	    SvCUR_set(utf16_buffer, 0);
	}
d12825 2
a12826 6
    DEBUG_P(PerlIO_printf(Perl_debug_log,
			  "utf16_textfilter: returns, status=%"IVdf" utf16=%"UVuf" utf8=%"UVuf"\n",
			  status,
			  (UV)SvCUR(utf16_buffer), (UV)SvCUR(utf8_buffer)));
    DEBUG_P({ sv_dump(utf8_buffer); sv_dump(sv);});
    return retval;
d12829 2
a12830 2
static U8 *
S_add_utf16_textfilter(pTHX_ U8 *const s, bool reversed)
d12832 15
a12846 14
    SV *filter = filter_add(S_utf16_textfilter, NULL);

    IoTOP_GV(filter) = MUTABLE_GV(newSVpvn((char *)s, PL_bufend - (char*)s));
    sv_setpvs(filter, "");
    IoLINES(filter) = reversed;
    IoPAGE(filter) = 1; /* Not EOF */

    /* Sadly, we have to return a valid pointer, come what may, so we have to
       ignore any error return from this.  */
    SvCUR_set(PL_linestr, 0);
    if (FILTER_READ(0, PL_linestr, 0)) {
	SvUTF8_on(PL_linestr);
    } else {
	SvUTF8_on(PL_linestr);
d12848 2
a12849 2
    PL_bufend = SvEND(PL_linestr);
    return (U8*)SvPVX(PL_linestr);
d12869 1
a12869 1
Perl_scan_vstring(pTHX_ const char *s, const char *const e, SV *sv)
d12911 3
a12913 3
		    if (orev > rev)
			Perl_ck_warner_d(aTHX_ packWARN(WARN_OVERFLOW),
					 "Integer overflow in decimal number");
a12938 12
}

int
Perl_keyword_plugin_standard(pTHX_
	char *keyword_ptr, STRLEN keyword_len, OP **op_ptr)
{
    PERL_ARGS_ASSERT_KEYWORD_PLUGIN_STANDARD;
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(keyword_ptr);
    PERL_UNUSED_ARG(keyword_len);
    PERL_UNUSED_ARG(op_ptr);
    return KEYWORD_PLUGIN_DECLINE;
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a41 1
#include "dquote_static.c"
d48 3
a52 2
#define PL_lex_allbrackets	(PL_parser->lex_allbrackets)
#define PL_lex_fakeeof		(PL_parser->lex_fakeeof)
d129 2
a130 3
#define XENUMMASK  0x3f
#define XFAKEEOF   0x40
#define XFAKEBRACK 0x80
d135 1
a135 1
#   define UTF ((PL_linestr && DO_UTF8(PL_linestr)) || ( !(PL_parser->lex_flags & LEX_IGNORE_UTF8_HINTS) && (PL_hints & HINT_UTF8)))
a225 1
 * FUN0OP       : zero-argument function, with its op created in this file
a255 1
#define FUN0OP(f)  return (pl_yylval.opval=f, CLINE, PL_expect=XOPERATOR, PL_bufptr=s, REPORT((int)FUNC0OP))
a284 4
#define UNIPROTO(f,optional) { \
	if (optional) PL_last_uni = PL_oldbufptr; \
	OPERATOR(f); \
	}
d297 1
a297 9
#define OLDLOP(f) \
	do { \
	    if (!PL_lex_allbrackets && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC) \
		PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC; \
	    pl_yylval.ival = (f); \
	    PL_expect = XTERM; \
	    PL_bufptr = s; \
	    return (int)LSTOP; \
	} while(0)
a339 1
    { FUNC0OP,		TOKENTYPE_OPVAL,	"FUNC0OP" },
d346 1
a346 1
    { LABEL,		TOKENTYPE_OPVAL,	"LABEL" },
d524 1
a524 1
    yywarn(Perl_form(aTHX_ "%s found where operator expected", what), UTF ? SVf_UTF8 : 0);
d531 1
a531 2
	    for (t = PL_oldoldbufptr; (isALNUM_lazy_if(t,UTF) || *t == ':');
                                                            t += UTF ? UTF8SKIP(t) : 1)
d535 2
a536 3
			"\t(Do you need to predeclare %"SVf"?)\n",
		    SVfARG(newSVpvn_flags(PL_oldoldbufptr, (STRLEN)(t - PL_oldoldbufptr),
                                   SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d541 1
a541 3
		    "\t(Missing operator before %"SVf"?)\n",
                    SVfARG(newSVpvn_flags(oldbp, (STRLEN)(s - oldbp),
                                    SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d582 5
a586 1
#include "feature.h"
d589 1
d592 2
a593 2
bool
Perl_feature_is_enabled(pTHX_ const char *const name, STRLEN namelen)
d596 1
d601 1
a601 4
    assert(CURRENT_FEATURE_BUNDLE == FEATURE_BUNDLE_CUSTOM);

    if (namelen > MAX_FEATURE_LEN)
	return FALSE;
d604 1
a604 2
    return cBOOL(cop_hints_fetch_pvn(PL_curcop, he_name, 8 + namelen, 0,
				     REFCOUNTED_HE_EXISTS));
a647 2
/*
=for apidoc Amx|void|lex_start|SV *line|PerlIO *rsfp|U32 flags
a648 14
Creates and initialises a new lexer/parser state object, supplying
a context in which to lex and parse from a new source of Perl code.
A pointer to the new state object is placed in L</PL_parser>.  An entry
is made on the save stack so that upon unwinding the new state object
will be destroyed and the former value of L</PL_parser> will be restored.
Nothing else need be done to clean up the parsing context.

The code to be parsed comes from I<line> and I<rsfp>.  I<line>, if
non-null, provides a string (in SV form) containing code to be parsed.
A copy of the string is made, so subsequent modification of I<line>
does not affect parsing.  I<rsfp>, if non-null, provides an input stream
from which code will be read to be parsed.  If both are non-null, the
code in I<line> comes first and must consist of complete lines of input,
and I<rsfp> supplies the remainder of the source.
d650 13
a662 14
The I<flags> parameter is reserved for future use.  Currently it is only
used by perl internally, so extensions should always pass zero.

=cut
*/

/* LEX_START_SAME_FILTER indicates that this is not a new file, so it
   can share filters with the current parser.
   LEX_START_DONT_CLOSE indicates that the file handle wasn't opened by the
   caller, hence isn't owned by the parser, so shouldn't be closed on parser
   destruction. This is used to handle the case of defaulting to reading the
   script from the standard input because no filename was given on the command
   line (without getting confused by situation where STDIN has been closed, so
   the script handle is opened on fd 0)  */
d665 1
a665 1
Perl_lex_start(pTHX_ SV *line, PerlIO *rsfp, U32 flags)
d669 1
a670 2
    if (flags && flags & ~LEX_START_FLAGS)
	Perl_croak(aTHX_ "Lexing code internal error (%s)", "lex_start");
d678 7
a684 3
    parser->stack = NULL;
    parser->ps = NULL;
    parser->stack_size = 0;
d702 2
a703 8
    parser->rsfp_filters =
      !(flags & LEX_START_SAME_FILTER) || !oparser
        ? NULL
        : MUTABLE_AV(SvREFCNT_inc(
            oparser->rsfp_filters
             ? oparser->rsfp_filters
             : (oparser->rsfp_filters = newAV())
          ));
a709 1
	STRLEN len;
d711 9
a719 4
	parser->linestr = flags & LEX_START_COPIED
			    ? SvREFCNT_inc_simple_NN(line)
			    : newSVpvn_flags(s, len, SvUTF8(line));
	if (!len || s[len-1] != ';')
d722 3
a724 1
	parser->linestr = newSVpvs("\n;");
a731 4
    parser->lex_flags = flags & (LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
				 |LEX_DONT_CLOSE_RSFP);

    parser->in_pod = parser->filtered = 0;
d745 1
a745 1
    if (PL_parser->lex_flags & LEX_DONT_CLOSE_RSFP)
d752 1
d761 13
d917 1
a917 1
=for apidoc Amx|void|lex_stuff_pvn|const char *pv|STRLEN len|U32 flags
d932 1
a932 1
to be inserted is available as a Perl scalar, the L</lex_stuff_sv>
d939 1
a939 1
Perl_lex_stuff_pvn(pTHX_ const char *pv, STRLEN len, U32 flags)
d951 1
a951 1
	    const char *p, *e = pv+len;
d975 1
a975 1
	    const char *p, *e = pv+len;
a1023 29
=for apidoc Amx|void|lex_stuff_pv|const char *pv|U32 flags

Insert characters into the lexer buffer (L</PL_parser-E<gt>linestr>),
immediately after the current lexing point (L</PL_parser-E<gt>bufptr>),
reallocating the buffer if necessary.  This means that lexing code that
runs later will see the characters as if they had appeared in the input.
It is not recommended to do this as part of normal parsing, and most
uses of this facility run the risk of the inserted characters being
interpreted in an unintended manner.

The string to be inserted is represented by octets starting at I<pv>
and continuing to the first nul.  These octets are interpreted as either
UTF-8 or Latin-1, according to whether the C<LEX_STUFF_UTF8> flag is set
in I<flags>.  The characters are recoded for the lexer buffer, according
to how the buffer is currently being interpreted (L</lex_bufutf8>).
If it is not convenient to nul-terminate a string to be inserted, the
L</lex_stuff_pvn> function is more appropriate.

=cut
*/

void
Perl_lex_stuff_pv(pTHX_ const char *pv, U32 flags)
{
    PERL_ARGS_ASSERT_LEX_STUFF_PV;
    lex_stuff_pvn(pv, strlen(pv), flags);
}

/*
d1036 1
a1036 1
being interpreted (L</lex_bufutf8>).  If a string to be inserted is
d1132 1
a1132 1
and the lexing code has kept multiple lines of text in the buffer for
d1234 1
a1234 1
    } else if (!PL_parser->rsfp && !PL_parser->filtered) {
d1246 1
a1246 1
	if (PL_parser->lex_flags & LEX_DONT_CLOSE_RSFP)
d1251 1
a1251 1
	PL_parser->in_pod = PL_parser->filtered = 0;
d1389 1
a1389 4
	if (UTF)
	    PL_parser->bufptr += UTF8SKIP(PL_parser->bufptr);
	else
	    ++(PL_parser->bufptr);
a1492 1
    line_t line_num;
a1535 2
    line_num = atoi(n)-1;

d1538 1
d1551 1
a1551 1
	if (!PL_rsfp && !PL_parser->filtered) {
d1593 2
a1594 19
		    /* The line number may differ. If that is the case,
		       alias the saved lines that are in the array.
		       Otherwise alias the whole array. */
		    if (CopLINE(PL_curcop) == line_num) {
			GvHV(gv2) = MUTABLE_HV(SvREFCNT_inc(GvHV(*gvp)));
			GvAV(gv2) = MUTABLE_AV(SvREFCNT_inc(GvAV(*gvp)));
		    }
		    else if (GvAV(*gvp)) {
			AV * const av = GvAV(*gvp);
			const I32 start = CopLINE(PL_curcop)+1;
			I32 items = AvFILLp(av) - start;
			if (items > 0) {
			    AV * const av2 = GvAVn(gv2);
			    SV **svp = AvARRAY(av) + start;
			    I32 l = (I32)line_num+1;
			    while (items--)
				av_store(av2, l++, SvREFCNT_inc(*svp++));
			}
		    }
d1601 1
d1605 1
a1605 1
    CopLINE_set(PL_curcop, line_num);
d1808 1
a1808 1
	goto lstop;
d1811 1
a1811 1
	goto lstop;
d1818 1
a1818 4
    else {
	lstop:
	if (!PL_lex_allbrackets && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
	    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
a1819 1
    }
a1930 22
void
Perl_yyunlex(pTHX)
{
    int yyc = PL_parser->yychar;
    if (yyc != YYEMPTY) {
	if (yyc) {
	    start_force(-1);
	    NEXTVAL_NEXTTOKE = PL_parser->yylval;
	    if (yyc == '{'/*}*/ || yyc == HASHBRACK || yyc == '['/*]*/) {
		PL_lex_allbrackets--;
		PL_lex_brackets--;
		yyc |= (3<<24) | (PL_lex_brackstack[PL_lex_brackets] << 16);
	    } else if (yyc == '('/*)*/) {
		PL_lex_allbrackets--;
		yyc |= (2<<24);
	    }
	    force_next(yyc);
	}
	PL_parser->yychar = YYEMPTY;
    }
}

d2018 1
a2018 2
	OP* const o = (OP*)newSVOP(OP_CONST, 0, newSVpvn_flags(s, len,
                                                                UTF ? SVf_UTF8 : 0));
d2028 2
a2029 2
			      (PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL)
			      : GV_ADD) | ( UTF ? SVf_UTF8 : 0 ),
d2101 1
a2101 1
        if (*d == ';' || isSPACE(*d) || *d == '{' || *d == '}' || !*d) {
d2104 1
a2104 2
	    char *loc = savepv(setlocale(LC_NUMERIC, NULL));
	    setlocale(LC_NUMERIC, "C");
a2108 1
	    Safefree(loc);
d2170 1
a2170 3
    else if ( (*s != ';' && *s != '{' && *s != '}' ) &&
	    (s = SKIPSPACE1(s), (*s != ';' && *s != '{' && *s != '}' )))
    {
d2219 1
a2219 2
    /* This is relying on the SV being "well formed" with a trailing '\0'  */
    while (s < send && !(*s == '\\' && s[1] == '\\'))
a2343 2
    SAVEI32(PL_lex_allbrackets);
    SAVEI8(PL_lex_fakeeof);
a2371 2
    PL_lex_allbrackets = 0;
    PL_lex_fakeeof = LEX_FAKEEOF_NEVER;
a2380 1
    if (PL_lex_inwhat == OP_TRANSR) PL_lex_inwhat = OP_TRANS;
a2412 1
    assert(PL_lex_inwhat != OP_TRANSR);
a2421 2
	PL_lex_allbrackets = 0;
	PL_lex_fakeeof = LEX_FAKEEOF_NEVER;
d2552 2
a2553 2
    bool has_utf8 = FALSE;			/* Output constant is UTF8 */
    bool  this_utf8 = cBOOL(UTF);		/* Is the source string assumed
a2579 1
    assert(PL_lex_inwhat != OP_TRANSR);
d2772 1
a2772 1
	  ((PMOP*)PL_lex_inpat)->op_pmflags & RXf_PMf_EXTENDED) {
d2812 1
a2812 2
	    /* warn on \1 - \9 in substitution replacements, but note that \11
	     * is an octal; and \19 is \1 followed by '9' */
d2822 1
a2822 1
	    if (PL_lex_inwhat != OP_TRANS && *s && strchr("lLuUEQF", *s)) {
d2867 1
a2867 1
	    /* eg. \132 indicates the octal constant 0132 */
a2877 15
	    /* eg. \o{24} indicates the octal constant \024 */
	    case 'o':
		{
		    STRLEN len;
		    const char* error;

		    bool valid = grok_bslash_o(s, &uv, &len, &error, 1);
		    s += len;
		    if (! valid) {
			yyerror(error);
			continue;
		    }
		    goto NUM_ESCAPE_INSERT;
		}

d2970 3
a2972 3
		 * needed, and would complicate use of copy().  XXX There are
		 * other parts of this file where the macro is used
		 * inconsistently, but are saved by it being a no-op */
d3015 1
a3015 3
		     * block should be removed.  However, the code that parses
		     * the output of this would have to be changed to not
		     * necessarily expect utf8 */
d3048 3
a3050 6
			/* On non-EBCDIC platforms, pass through to the regex
			 * compiler unchanged.  The reason we evaluated the
			 * number above is to make sure there wasn't a syntax
			 * error.  But on EBCDIC we convert to native so
			 * downstream code can continue to assume it's native
			 */
a3051 6
#ifdef EBCDIC
			d += my_snprintf(d, e - s + 1 + 1,  /* includes the }
							       and the \0 */
				    "\\N{U+%X}",
				    (unsigned int) UNI_TO_NATIVE(uv));
#else
a3053 1
#endif
d3147 3
a3149 7
			     * boiler plate before it.  For all these, we
			     * convert to native format so that downstream code
			     * can continue to assume the input is native */
			    output_length =
				my_snprintf(hex_string, sizeof(hex_string),
					    "\\N{U+%X",
					    (unsigned int) UNI_TO_NATIVE(uv));
d3172 2
a3173 4
				output_length =
				    my_snprintf(hex_string, sizeof(hex_string),
					    ".%X",
					    (unsigned int) UNI_TO_NATIVE(uv));
d3242 1
a3242 1
				if (! isALPHAU(UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(*i,
d3258 1
a3258 1
					    TWO_BYTE_UTF8_TO_UNI(*i, *(i+1)))))
d3267 4
a3270 3
			    /* The e-i passed to the final %.*s makes sure that
			     * should the trailing NUL be missing that this
			     * print won't run off the end of the string */
d3272 3
a3274 2
					"Deprecated character in \\N{...}; marked by <-- HERE  in \\N{%.*s<-- HERE %.*s",
					(int)(i - s + 1), s, (int)(e - i), i + 1);
d3289 6
a3294 1
		    *d++ = grok_bslash_c(*s++, has_utf8, 1);
d3383 1
a3383 2
	Perl_croak(aTHX_ "panic: constant overflowed allocated space, %"UVuf
		   " >= %"UVuf, (UV)SvCUR(sv), (UV)SvLEN(sv));
d3471 10
a3480 1
	if (regcurly(s)) {
a3481 1
	}
d3483 1
d3525 1
a3525 2
		    if (len > 1 && gv_fetchpvn_flags(tmpbuf, len,
                                                    UTF ? SVf_UTF8 : 0, SVt_PV))
d3632 1
a3632 1
		const char *proto = CvPROTO(cv);
d3673 1
a3673 1
	indirgv = gv_fetchpvn_flags(tmpbuf, len, ( UTF ? SVf_UTF8 : 0 ), SVt_PVCV);
d3677 1
a3677 1
	if (!gv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, UTF ? SVf_UTF8 : 0)) {
d3683 1
a3683 1
		return 0;	/* no assumptions -- "=>" quotes bareword */
d3690 1
a3690 2
		curmad('X', newSVpvn_flags(start,SvPVX(PL_linestr) + soff - start,
                                                            ( UTF ? SVf_UTF8 : 0 )));
a3729 3
    if (PL_parser->lex_flags & LEX_IGNORE_UTF8_HINTS)
	Perl_croak(aTHX_ "Source filters apply only to byte streams");

a3741 39
    if (
	!PL_parser->filtered
     && PL_parser->lex_flags & LEX_EVALBYTES
     && PL_bufptr < PL_bufend
    ) {
	const char *s = PL_bufptr;
	while (s < PL_bufend) {
	    if (*s == '\n') {
		SV *linestr = PL_parser->linestr;
		char *buf = SvPVX(linestr);
		STRLEN const bufptr_pos = PL_parser->bufptr - buf;
		STRLEN const oldbufptr_pos = PL_parser->oldbufptr - buf;
		STRLEN const oldoldbufptr_pos=PL_parser->oldoldbufptr-buf;
		STRLEN const linestart_pos = PL_parser->linestart - buf;
		STRLEN const last_uni_pos =
		    PL_parser->last_uni ? PL_parser->last_uni - buf : 0;
		STRLEN const last_lop_pos =
		    PL_parser->last_lop ? PL_parser->last_lop - buf : 0;
		av_push(PL_rsfp_filters, linestr);
		PL_parser->linestr = 
		    newSVpvn(SvPVX(linestr), ++s-SvPVX(linestr));
		buf = SvPVX(PL_parser->linestr);
		PL_parser->bufend = buf + SvCUR(PL_parser->linestr);
		PL_parser->bufptr = buf + bufptr_pos;
		PL_parser->oldbufptr = buf + oldbufptr_pos;
		PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
		PL_parser->linestart = buf + linestart_pos;
		if (PL_parser->last_uni)
		    PL_parser->last_uni = buf + last_uni_pos;
		if (PL_parser->last_lop)
		    PL_parser->last_lop = buf + last_lop_pos;
		SvLEN(linestr) = SvCUR(linestr);
		SvCUR(linestr) = s-SvPVX(linestr);
		PL_parser->filtered = 1;
		break;
	    }
	    s++;
	}
    }
d3764 2
d3786 1
a3786 1
    unsigned int correct_length
a3837 25
    if (SvTYPE(datasv) != SVt_PVIO) {
	if (correct_length) {
 	    /* Want a block */
	    const STRLEN remainder = SvLEN(datasv) - SvCUR(datasv);
	    if (!remainder) return 0; /* eof */
	    if (correct_length > remainder) correct_length = remainder;
	    sv_catpvn(buf_sv, SvEND(datasv), correct_length);
	    SvCUR_set(datasv, SvCUR(datasv) + correct_length);
	} else {
	    /* Want a line */
	    const char *s = SvEND(datasv);
	    const char *send = SvPVX(datasv) + SvLEN(datasv);
	    while (s < send) {
		if (*s == '\n') {
		    s++;
		    break;
		}
		s++;
	    }
	    if (s == send) return 0; /* eof */
	    sv_catpvn(buf_sv, SvEND(datasv), s-SvEND(datasv));
	    SvCUR_set(datasv, s-SvPVX(datasv));
	}
	return SvCUR(buf_sv);
    }
d3886 1
a3886 1
        (gv = gv_fetchpvn_flags(pkgname, len, ( UTF ? SVf_UTF8 : 0 ), SVt_PVHV)))
d3892 1
a3892 1
    gv = gv_fetchpvn_flags(pkgname, len, UTF ? SVf_UTF8 : 0, SVt_PVCV);
d3899 1
a3899 1
    return gv_stashpvn(pkgname, len, UTF ? SVf_UTF8 : 0);
d3904 1
a3904 1
 * Check whether readpipe() is overridden, and generates the appropriate
d3921 1
a3921 1
	    op_append_elem(OP_LIST,
d3946 1
a3946 1
    if (PL_lex_state != LEX_KNOWNEXT && PL_pending_ident)
d3990 1
a3990 1
	if (optype == ';' && !PL_rsfp && !PL_parser->filtered) {
a4034 1
    case LABEL:
d4095 4
a4148 10
#define word_takes_any_delimeter(p,l) S_word_takes_any_delimeter(p,l)
STATIC bool
S_word_takes_any_delimeter(char *p, STRLEN len)
{
    return (len == 1 && strchr("msyq", p[0])) ||
	   (len == 2 && (
	    (p[0] == 't' && p[1] == 'r') ||
	    (p[0] == 'q' && strchr("qwxr", p[1]))));
}

d4205 1
a4205 1
    if (PL_lex_state != LEX_KNOWNEXT && PL_pending_ident)
a4247 20
	{
	    I32 next_type;
#ifdef PERL_MAD
	    next_type = PL_nexttoke[PL_lasttoke].next_type;
#else
	    next_type = PL_nexttype[PL_nexttoke];
#endif
	    if (next_type & (7<<24)) {
		if (next_type & (1<<24)) {
		    if (PL_lex_brackets > 100)
			Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
		    PL_lex_brackstack[PL_lex_brackets++] =
			(char) ((next_type >> 16) & 0xff);
		}
		if (next_type & (2<<24))
		    PL_lex_allbrackets++;
		if (next_type & (4<<24))
		    PL_lex_allbrackets--;
		next_type &= 0xffff;
	    }
d4249 2
a4250 2
	    /* FIXME - can these be merged?  */
	    return next_type;
d4252 1
a4252 1
	    return REPORT(next_type);
a4253 1
	}
d4261 1
a4261 3
	    Perl_croak(aTHX_
		       "panic: INTERPCASEMOD bufptr=%p, bufend=%p, *bufptr=%u",
		       PL_bufptr, PL_bufend, *PL_bufptr);
d4271 1
a4271 2
		    && (oldmod == 'L' || oldmod == 'U' || oldmod == 'Q'
                        || oldmod == 'F')) {
a4278 1
		PL_lex_allbrackets--;
a4280 5
            else if ( PL_bufptr != PL_bufend && PL_bufptr[1] == 'E' ) {
               /* Got an unpaired \E */
               Perl_ck_warner(aTHX_ packWARN(WARN_MISC),
                        "Useless use of \\E");
            }
d4315 2
a4316 4
		if ((*s == 'L' || *s == 'U' || *s == 'F') &&
		    (strchr(PL_lex_casestack, 'L')
                        || strchr(PL_lex_casestack, 'U')
                        || strchr(PL_lex_casestack, 'F'))) {
a4317 1
		    PL_lex_allbrackets--;
d4327 1
a4327 1
		force_next((2<<24)|'(');
a4338 2
                else if (*s == 'F')
		    NEXTVAL_NEXTTOKE.ival = OP_FC;
d4340 1
a4340 1
		    Perl_croak(aTHX_ "panic: yylex, *s=%u", *s);
d4393 1
a4393 1
	    force_next((2<<24)|'(');
a4432 1
	    PL_lex_allbrackets--;
d4446 1
a4446 2
	    Perl_croak(aTHX_ "panic: INTERPCONCAT, lex_brackets=%ld",
		       (long) PL_lex_brackets);
d4522 1
a4522 6
        SV *dsv = newSVpvs_flags("", SVs_TEMP);
        const char *c = UTF ? savepv(sv_uni_display(dsv, newSVpvn_flags(s,
                                                    UTF8SKIP(s),
                                                    SVs_TEMP | SVf_UTF8),
                                            10, UNI_DISPLAY_ISPRINT))
                            : Perl_form(aTHX_ "\\x%02X", (unsigned char)*s);
d4530 1
a4530 4
        sv_setpv(dsv, d);
        if (UTF)
            SvUTF8_on(dsv);
        Perl_croak(aTHX_  "Unrecognized character %s; marked by <-- HERE after %"SVf"<-- HERE near column %d", c, SVfARG(dsv), (int) len + 1);
d4540 1
a4540 1
	if (!PL_rsfp && (!PL_parser->filtered || s+1 < PL_bufend)) {
d4543 1
a4543 2
	    if (PL_lex_brackets &&
		    PL_lex_brackstack[PL_lex_brackets-1] != XFAKEEOF) {
d4660 1
a4660 7
		Off_t offset = (IV)PerlIO_tell(PL_rsfp);
		bof = (offset == (Off_t)SvCUR(PL_linestr));
#if defined(PERLIO_USING_CRLF) && defined(PERL_TEXTMODE_SCRIPTS)
		/* offset may include swallowed CR */
		if (!bof)
		    bof = (offset == (Off_t)SvCUR(PL_linestr)+1);
#endif
d4666 1
a4666 1
	    if (PL_parser->in_pod) {
d4677 1
a4677 1
		    PL_parser->in_pod = 0;
d4680 1
a4680 1
	    if (PL_rsfp || PL_parser->filtered)
d4682 1
a4682 1
	} while (PL_parser->in_pod);
d4906 2
a4907 4
	if (PL_lex_state != LEX_NORMAL ||
	     (PL_in_eval && !PL_rsfp && !PL_parser->filtered)) {
	    if (*s == '#' && s == PL_linestart && PL_in_eval
	     && !PL_rsfp && !PL_parser->filtered) {
d4914 1
a4914 1
		if (!PL_in_eval || PL_rsfp || PL_parser->filtered)
d4924 1
a4924 2
		    Perl_croak(aTHX_ "panic: input overflow, %p > %p",
			       d, PL_bufend);
d5070 1
a5070 6
	    if (PL_expect == XOPERATOR) {
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
		    s--;
		    TOKEN(0);
		}
a5071 1
	    }
d5089 1
a5089 6
	    if (PL_expect == XOPERATOR) {
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
		    s--;
		    TOKEN(0);
		}
a5090 1
	    }
a5109 5
	    if (*s == '=' && !PL_lex_allbrackets &&
		    PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
		s -= 2;
		TOKEN(0);
	    }
a5111 5
	if (*s == '=' && !PL_lex_allbrackets &&
		PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
	    s--;
	    TOKEN(0);
	}
a5115 3
	    if (s[1] == '=' && !PL_lex_allbrackets &&
		    PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
		TOKEN(0);
a5128 3
	if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		(s[1] == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_BITWISE))
	    TOKEN(0);
d5132 1
a5132 4
	if (PL_lex_brackets > 100)
	    Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
	PL_lex_brackstack[PL_lex_brackets++] = 0;
	PL_lex_allbrackets++;
a5140 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		TOKEN(0);
a5143 2
	s++;
	OPERATOR('~');
d5145 4
a5148 4
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMMA)
	    TOKEN(0);
	s++;
	OPERATOR(',');
d5165 1
a5165 2
		Perl_croak(aTHX_
			   "Use of := for an empty attribute list is not allowed");
d5199 1
a5199 1
		sv = newSVpvn_flags(s, len, UTF ? SVf_UTF8 : 0);
d5216 1
a5216 1
		    attrs = op_append_elem(OP_LIST, attrs,
d5256 1
a5256 1
		        attrs = op_append_elem(OP_LIST, attrs,
a5307 5
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_CLOSING) {
	    s--;
	    TOKEN(0);
	}
	PL_lex_allbrackets--;
a5315 1
	PL_lex_allbrackets++;
a5317 2
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
	    TOKEN(0);
d5319 4
a5322 2
	s++;
	OPERATOR(';');
d5324 7
a5330 8
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_CLOSING)
	    TOKEN(0);
	s++;
	PL_lex_allbrackets--;
	s = SKIPSPACE1(s);
	if (*s == '{')
	    PREBLOCK(')');
	TERM(')');
a5331 2
	if (PL_lex_brackets && PL_lex_brackstack[PL_lex_brackets-1] == XFAKEEOF)
	    TOKEN(0);
a5336 1
	PL_lex_allbrackets--;
a5361 1
	    PL_lex_allbrackets++;
a5389 1
	    PL_lex_allbrackets++;
a5394 1
	    PL_lex_allbrackets++;
a5402 1
		PL_lex_allbrackets++;
a5508 2
	if (PL_lex_brackets && PL_lex_brackstack[PL_lex_brackets-1] == XFAKEEOF)
	    TOKEN(0);
a5514 1
	PL_lex_allbrackets--;
d5556 1
a5556 6
	if (*s++ == '&') {
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_LOGIC)) {
		s -= 2;
		TOKEN(0);
	    }
a5557 1
	}
a5566 5
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_BITWISE)) {
		s--;
		TOKEN(0);
	    }
d5582 1
a5582 6
	if (*s++ == '|') {
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_LOGIC)) {
		s -= 2;
		TOKEN(0);
	    }
a5583 1
	}
a5584 5
	if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		(*s == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_BITWISE)) {
	    s--;
	    TOKEN(0);
	}
d5590 1
a5590 6
	    if (tmp == '=') {
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
		    s -= 2;
		    TOKEN(0);
		}
d5592 1
a5592 7
	    }
	    if (tmp == '>') {
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMMA) {
		    s -= 2;
		    TOKEN(0);
		}
a5593 1
	    }
d5604 1
a5604 1
		    if (PL_in_eval && !PL_rsfp && !PL_parser->filtered) {
d5631 1
a5631 1
		    PL_parser->in_pod = 1;
a5648 4
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
	    s--;
	    TOKEN(0);
	}
a5671 5
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
		    s -= 2;
		    TOKEN(0);
		}
d5692 1
a5692 6
	    if (tmp == '<') {
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
		    s -= 2;
		    TOKEN(0);
		}
a5693 1
	    }
d5696 1
a5696 6
		if (tmp == '>') {
		    if (!PL_lex_allbrackets &&
			    PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
			s -= 3;
			TOKEN(0);
		    }
a5697 1
		}
a5698 5
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
		    s -= 2;
		    TOKEN(0);
		}
a5702 4
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
	    s--;
	    TOKEN(0);
	}
d5708 1
a5708 6
	    if (tmp == '>') {
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
		    s -= 2;
		    TOKEN(0);
		}
d5710 1
a5710 7
	    }
	    else if (tmp == '=') {
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
		    s -= 2;
		    TOKEN(0);
		}
a5711 1
	    }
a5713 4
	if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE) {
	    s--;
	    TOKEN(0);
	}
d5725 1
a5725 1
	if (s[1] == '#' && (isIDFIRST_lazy_if(s+2,UTF) || strchr("{$:+-@@", s[2]))) {
d5749 8
d5798 1
a5798 2
				if (*t == ';'
                                       && get_cvn_flags(tmpbuf, len, UTF ? SVf_UTF8 : 0))
d5800 2
a5801 3
						"You need to quote \"%"SVf"\"",
						  SVfARG(newSVpvn_flags(tmpbuf, len, 
                                                    SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d5880 1
a5880 1
			t += UTF ? UTF8SKIP(t) : 1;
a5883 1
       /* diag_listed_as: Scalar value @@%s[%s] better written as $%s[%s] */
d5885 3
a5887 5
			    "Scalar value %"SVf" better written as $%"SVf,
			    SVfARG(newSVpvn_flags(PL_bufptr, (STRLEN)(t-PL_bufptr),
                                                SVs_TEMP | (UTF ? SVf_UTF8 : 0 ))),
                            SVfARG(newSVpvn_flags(PL_bufptr+1, (STRLEN)(t-PL_bufptr-1),
                                                SVs_TEMP | (UTF ? SVf_UTF8 : 0 ))));
a5896 3
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
		    (s[2] == '=' ? LEX_FAKEEOF_ASSIGN : LEX_FAKEEOF_LOGIC))
		TOKEN(0);
a5903 6
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_IFELSE) {
		    s--;
		    TOKEN(0);
		}
		PL_lex_allbrackets++;
a5909 6
		    if (!PL_lex_allbrackets && PL_lex_fakeeof >=
			    (*s == '=' ? LEX_FAKEEOF_ASSIGN :
					    LEX_FAKEEOF_LOGIC)) {
			s -= 2;
			TOKEN(0);
		    }
a5913 5
		     if (*s == '=' && !PL_lex_allbrackets &&
			     PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
			 s--;
			 TOKEN(0);
		     }
a5925 2
	     if (*s == '?')
		 deprecate("?PATTERN? without explicit operator");
a5949 5
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_RANGE) {
		    s--;
		    TOKEN(0);
		}
a5958 5
	    if (*s == '=' && !PL_lex_allbrackets &&
		    PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN) {
		s--;
		TOKEN(0);
	    }
d6040 1
a6040 2
		GV *const gv = gv_fetchpvn_flags(s, start - s,
                                                    UTF ? SVf_UTF8 : 0, SVt_PVCV);
d6095 4
a6098 1
	anydelim = word_takes_any_delimeter(PL_tokenbuf, len);
d6124 1
a6124 1
	    result = PL_keyword_plugin(aTHX_ PL_tokenbuf, len, &o);
d6152 1
a6152 3
	    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
                                            newSVpvn_flags(PL_tokenbuf,
                                                        len, UTF ? SVf_UTF8 : 0));
d6162 1
a6162 2
		if ((gv = gv_fetchpvn_flags(PL_tokenbuf, len,
                                            UTF ? SVf_UTF8 : 0, SVt_PVCV)) &&
d6171 1
a6171 2
		    (gvp = (GV**)hv_fetch(PL_globalstash, PL_tokenbuf,
                                            UTF ? -(I32)len : (I32)len, FALSE)) &&
d6198 2
a6199 3
				   "Ambiguous call resolved as CORE::%s(), "
				   "qualify as such or use &",
				   GvENAME(hgv));
d6235 1
a6235 3
			Perl_croak(aTHX_ "Bad name after %"SVf"%s",
                                        SVfARG(newSVpvn_flags(PL_tokenbuf, len,
                                            (UTF ? SVf_UTF8 : 0) | SVs_TEMP )),
d6252 1
a6252 1
		   unless name is "Foo::", in which case Foo is a bareword
d6259 1
a6259 1
			&& ! gv_fetchpvn_flags(PL_tokenbuf, len, UTF ? SVf_UTF8 : 0, SVt_PVHV))
d6261 2
a6262 3
		  	    "Bareword \"%"SVf"\" refers to nonexistent package",
			     SVfARG(newSVpvn_flags(PL_tokenbuf, len,
                                        (UTF ? SVf_UTF8 : 0) | SVs_TEMP)));
d6275 1
a6275 2
					       GV_NOADD_NOINIT | ( UTF ? SVf_UTF8 : 0 ),
					       SVt_PVCV);
a6281 2
		sv = S_newSV_maybe_utf8(aTHX_ PL_tokenbuf,
		    len ? len : strlen(PL_tokenbuf));
a6282 1
		    SV * const tmp_sv = sv;
d6284 7
a6290 2
		    sv_catsv(sv, tmp_sv);
		    SvREFCNT_dec(tmp_sv);
a6291 1

d6301 1
d6305 4
d6311 1
d6315 1
d6317 1
a6317 1
		    OP *const_op = newSVOP(OP_CONST, 0, SvREFCNT_inc_NN(sv));
d6321 17
a6337 1
		cv = rv2cv_op_cv(rv2cv_op, 0);
a6361 3
			if (tmp == METHOD && !PL_lex_allbrackets &&
				PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
a6441 3
		    if (!PL_lex_allbrackets &&
			    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
a6450 3
		    if (tmp == METHOD && !PL_lex_allbrackets &&
			    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
d6457 4
a6460 6
		    if (lastchar == '-') {
                        const SV *tmpsv = newSVpvn_flags( PL_tokenbuf, len ? len : strlen(PL_tokenbuf), (UTF ? SVf_UTF8 : 0) | SVs_TEMP );
 			Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
				"Ambiguous use of -%"SVf" resolved as -&%"SVf"()",
				SVfARG(tmpsv), SVfARG(tmpsv));
                    }
a6467 1
			pl_yylval.opval->op_flags |= OPf_SPECIAL;
d6483 2
a6484 3
			STRLEN protolen = CvPROTOLEN(cv);
			const char *proto = CvPROTO(cv);
			bool optional;
d6487 3
a6489 2
			if ((optional = *proto == ';'))
			  do
a6490 21
			  while (*proto == ';');
			if (
			    (
			        (
			            *proto == '$' || *proto == '_'
			         || *proto == '*' || *proto == '+'
			        )
			     && proto[1] == '\0'
			    )
			 || (
			     *proto == '\\' && proto[1] && proto[2] == '\0'
			    )
			)
			    UNIPROTO(UNIOPSUB,optional);
			if (*proto == '\\' && proto[1] == '[') {
			    const char *p = proto + 2;
			    while(*p && *p != ']')
				++p;
			    if(*p == ']' && !p[1])
				UNIPROTO(UNIOPSUB,optional);
			}
a6495 3
			    if (!PL_lex_allbrackets &&
				    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
				PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
a6513 3
			if (!PL_lex_allbrackets &&
				PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
d6538 1
a6538 2
			gv = gv_fetchpv(PL_tokenbuf, GV_ADD | ( UTF ? SVf_UTF8 : 0 ),
                                        SVt_PVCV);
a6552 3
			if (!PL_lex_allbrackets &&
				PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
a6558 3
		    if (!PL_lex_allbrackets &&
			    PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
			PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
d6586 1
a6586 1
			    if (!*d && !gv_stashpv(PL_tokenbuf, UTF ? SVf_UTF8 : 0))
d6597 2
a6598 4
				     "Operator or semicolon missing before %c%"SVf,
				     lastchar, SVfARG(newSVpvn_flags(PL_tokenbuf,
                                                    strlen(PL_tokenbuf),
                                                    SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d6607 3
a6609 3
	    FUN0OP(
		(OP*)newSVOP(OP_CONST, 0, newSVpv(CopFILE(PL_curcop),0))
	    );
d6612 3
a6614 4
	    FUN0OP(
        	(OP*)newSVOP(OP_CONST, 0,
		    Perl_newSVpvf(aTHX_ "%"IVdf, (IV)CopLINE(PL_curcop)))
	    );
d6617 1
a6617 2
	    FUN0OP(
		(OP*)newSVOP(OP_CONST, 0,
d6620 2
a6621 2
					 : &PL_sv_undef))
	    );
a6627 2
		STRLEN plen = 4;
		U32 putf8 = 0;
d6629 3
a6631 11
		{
		    HV * const stash =
			PL_curstash ? PL_curstash : PL_defstash;
		    pname = HvNAME_get(stash);
		    plen  = HvNAMELEN (stash);
		    if(HvNAMEUTF8(stash)) putf8 = SVf_UTF8;
		}
		gv = gv_fetchpvn_flags(
			Perl_form(aTHX_ "%*s::DATA", (int)plen, pname),
			plen+6, GV_ADD|putf8, SVt_PVIO
		);
d6665 6
a6720 3
	case KEY___SUB__:
	    FUN0OP(newPVOP(OP_RUNCV,0,NULL));

d6739 2
a6740 4
		if (!(tmp = keyword(PL_tokenbuf, len, 1)))
		    Perl_croak(aTHX_ "CORE::%"SVf" is not a keyword",
                                    SVfARG(newSVpvn_flags(PL_tokenbuf, len,
                                                (UTF ? SVf_UTF8 : 0) | SVs_TEMP)));
d6743 1
a6743 2
		else if (tmp == KEY_require || tmp == KEY_do
		      || tmp == KEY_glob)
a6759 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_LOWLOGIC)
		return REPORT(0);
d6781 6
d6797 2
a6811 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
d6872 1
a6872 7
	    Perl_populate_isa(aTHX_ STR_WITH_LEN("AnyDBM_File::ISA"),
			      STR_WITH_LEN("NDBM_File::"),
			      STR_WITH_LEN("DB_File::"),
			      STR_WITH_LEN("GDBM_File::"),
			      STR_WITH_LEN("SDBM_File::"),
			      STR_WITH_LEN("ODBM_File::"),
			      NULL);
a6889 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
a6910 4
	case KEY_evalbytes:
	    PL_expect = XTERM;
	    UNIBRACK(-OP_ENTEREVAL);

a6942 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
a6976 3
	case KEY_fc:
	    UNI(OP_FC);

a6986 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
a6989 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
d7085 1
a7085 4
	    LOP(
	     orig_keyword==KEY_glob ? (orig_keyword=0, -OP_GLOB) : OP_GLOB,
	     XTERM
	    );
a7090 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
a7129 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
a7132 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
d7192 1
a7192 1
		    yyerror_pv(tmpbuf, UTF ? SVf_UTF8 : 0);
a7209 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
		return REPORT(0);
d7219 1
a7219 4
	    else {
		if (!PL_lex_allbrackets &&
			PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
		    PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
a7220 1
	    }
d7226 2
a7227 8
		for (d = s; isALNUM_lazy_if(d,UTF);) {
		    d += UTF ? UTF8SKIP(d) : 1;
                    if (UTF) {
                        while (UTF8_IS_CONTINUED(*d) && is_utf8_mark((U8*)d)) {
                            d += UTF ? UTF8SKIP(d) : 1;
                        }
                    }
                }
a7232 2
		    && !(t[0] == ':' && t[1] == ':')
		    && !keyword(s, d-s, 0)
d7234 1
a7234 2
		    SV *tmpsv = newSVpvn_flags(s, (STRLEN)(d-s),
                                                SVs_TEMP | (UTF ? SVf_UTF8 : 0));
d7236 2
a7237 2
			   "Precedence problem: open %"SVf" should be open(%"SVf")",
			    SVfARG(tmpsv), SVfARG(tmpsv));
a7242 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_LOWLOGIC)
		return REPORT(0);
a7281 1
	    PL_lex_expect = XBLOCK;
d7297 1
a7297 2
	case KEY_qw: {
	    OP *words = NULL;
d7302 1
d7304 2
a7305 2
		int warned_comma = !ckWARN(WARN_QW);
		int warned_comment = warned_comma;
d7313 1
a7313 1
			if (!warned_comma || !warned_comment) {
d7315 1
a7315 1
				if (!warned_comma && *d == ',') {
d7318 1
a7318 1
				    ++warned_comma;
d7320 1
a7320 1
				else if (!warned_comment && *d == '#') {
d7323 1
a7323 1
				    ++warned_comment;
d7332 1
a7332 1
			words = op_append_elem(OP_LIST, words,
d7336 5
a7341 2
	    if (!words)
		words = newNULLLIST();
d7346 2
a7347 4
	    PL_expect = XOPERATOR;
	    pl_yylval.opval = sawparens(words);
	    TOKEN(QWLIST);
	}
d7355 1
a7355 1
		SvIV_set(PL_lex_stuff, 0);	/* qq'$foo' should interpolate */
d7383 1
a7383 2
		    gv_stashpvn(PL_tokenbuf, strlen(PL_tokenbuf),
                                GV_ADD | (UTF ? SVf_UTF8 : 0));
d7544 2
d7588 1
a7588 1
		SV *subtoken = newSVpvn_flags(tstart, s - tstart, SvUTF8(PL_linestr));
d7611 1
a7611 1
			nametoke = newSVpvn_flags(s, d - s, SvUTF8(PL_linestr));
a7619 2
                    if (SvUTF8(PL_linestr))
                        SvUTF8_on(PL_subname);
a7668 1
                    STRLEN tmplen;
d7674 1
a7674 1
		    d = SvPV(PL_lex_stuff, tmplen);
d7676 1
a7676 1
		    for (p = d; tmplen; tmplen--, ++p) {
d7678 1
a7678 1
                            d[tmp++] = *p;
d7683 1
a7683 1
				if (!strchr("$@@%*;[]&\\_+", *p) || *p == '\0') {
d7688 1
a7688 1
					if ( !strchr(";@@%", *p) )
d7711 1
a7711 1
                    d[tmp] = '\0';
d7716 1
a7716 2
		    if (bad_proto) {
                        SV *dsv = newSVpvs_flags("", SVs_TEMP);
d7720 2
a7721 10
				    SVfARG(PL_subname),
                                    SvUTF8(PL_lex_stuff)
                                        ? sv_uni_display(dsv,
                                            newSVpvn_flags(d, tmp, SVs_TEMP | SVf_UTF8),
                                            tmp,
                                            UNI_DISPLAY_ISPRINT)
                                        : pv_pretty(dsv, d, tmp, 60, NULL, NULL,
                                            PERL_PV_ESCAPE_NONASCII));
                    }
                    SvCUR_set(PL_lex_stuff, tmp);
a7841 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
a7845 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
a7877 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
a7881 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_NONEXPR)
		return REPORT(0);
d7913 1
a7913 4
	    if (PL_expect == XOPERATOR) {
		if (*s == '=' && !PL_lex_allbrackets &&
			PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
		    return REPORT(0);
a7914 1
	    }
a7918 2
	    if (!PL_lex_allbrackets && PL_lex_fakeeof >= LEX_FAKEEOF_LOWLOGIC)
		return REPORT(0);
d7958 1
a7958 1
                yyerror_pv(Perl_form(aTHX_ "No package name allowed for "
d7960 2
a7961 2
                                  PL_tokenbuf), UTF ? SVf_UTF8 : 0);
            tmp = allocmy(PL_tokenbuf, tokenbuf_len, UTF ? SVf_UTF8 : 0);
d7965 2
a7966 3
                yyerror_pv(Perl_form(aTHX_ PL_no_myglob,
			    PL_in_my == KEY_my ? "my" : "state", PL_tokenbuf),
                            UTF ? SVf_UTF8 : 0);
d7969 1
a7969 2
            pl_yylval.opval->op_targ = allocmy(PL_tokenbuf, tokenbuf_len,
                                                        UTF ? SVf_UTF8 : 0);
d7988 1
a7988 2
	    tmp = pad_findmy_pvn(PL_tokenbuf, tokenbuf_len,
                                    UTF ? SVf_UTF8 : 0);
d7997 1
a7997 1
                sv_catpvn_flags(sym, PL_tokenbuf+1, tokenbuf_len - 1, (UTF ? SV_CATUTF8 : SV_CATBYTES ));
d8041 2
a8042 2
        GV *const gv = gv_fetchpvn_flags(PL_tokenbuf + 1, tokenbuf_len - 1,
                                        ( UTF ? SVf_UTF8 : 0 ), SVt_PVAV);
d8051 2
a8052 3
			"Possible unintended interpolation of %"SVf" in string",
			SVfARG(newSVpvn_flags(PL_tokenbuf, tokenbuf_len,
                                        SVs_TEMP | ( UTF ? SVf_UTF8 : 0 ))));
d8057 2
a8058 3
    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0, newSVpvn_flags(PL_tokenbuf + 1,
						      tokenbuf_len - 1,
                                                      UTF ? SVf_UTF8 : 0 ));
d8060 22
a8081 6
    gv_fetchpvn_flags(PL_tokenbuf+1, tokenbuf_len - 1,
		     (PL_in_eval ? (GV_ADDMULTI | GV_ADDINEVAL) : GV_ADD)
                     | ( UTF ? SVf_UTF8 : 0 ),
		     ((PL_tokenbuf[0] == '$') ? SVt_PV
		      : (PL_tokenbuf[0] == '@@') ? SVt_PVAV
		      : SVt_PVHV));
d8085 6
a8090 2
STATIC void
S_checkcomma(pTHX_ const char *s, const char *name, const char *what)
d8094 3390
a11483 1
    PERL_ARGS_ASSERT_CHECKCOMMA;
d11513 1
a11513 2
	const char * const w = s;
        s += UTF ? UTF8SKIP(s) : 1;
d11515 1
a11515 1
	    s += UTF ? UTF8SKIP(s) : 1;
d11523 1
a11523 1
	    gv = gv_fetchpvn_flags(w, s - w, ( UTF ? SVf_UTF8 : 0 ), SVt_PVCV);
d11541 1
a11541 1
    HV * table = GvHV(PL_hintgv);		 /* ^H */
d11549 1
a11549 9
    /* charnames doesn't work well if there have been errors found */
    if (PL_error_count > 0 && strEQ(key,"charnames"))
	return &PL_sv_undef;

    if (!table
	|| ! (PL_hints & HINT_LOCALIZE_HH)
	|| ! (cvp = hv_fetch(table, key, keylen, FALSE))
	|| ! SvOK(*cvp))
    {
d11552 14
a11565 31
	/* Here haven't found what we're looking for.  If it is charnames,
	 * perhaps it needs to be loaded.  Try doing that before giving up */
	if (strEQ(key,"charnames")) {
	    Perl_load_module(aTHX_
		            0,
			    newSVpvs("_charnames"),
			     /* version parameter; no need to specify it, as if
			      * we get too early a version, will fail anyway,
			      * not being able to find '_charnames' */
			    NULL,
			    newSVpvs(":full"),
			    newSVpvs(":short"),
			    NULL);
	    SPAGAIN;
	    table = GvHV(PL_hintgv);
	    if (table
		&& (PL_hints & HINT_LOCALIZE_HH)
		&& (cvp = hv_fetch(table, key, keylen, FALSE))
		&& SvOK(*cvp))
	    {
		goto now_ok;
	    }
	}
	if (!table || !(PL_hints & HINT_LOCALIZE_HH)) {
	    msg = Perl_newSVpvf(aTHX_
			    "Constant(%s) unknown", (type ? type: "undef"));
	}
	else {
	why1 = "$^H{";
	why2 = key;
	why3 = "} is not defined";
d11569 1
a11569 1
	}
d11574 12
a11585 1
now_ok:
d11654 1
a11654 1
	if (isALNUM(*s) || (!UTF && isALNUMC_L1(*s)))	/* UTF handled below */
d11752 3
a11754 13
    if (s < send) {
        if (UTF) {
            const STRLEN skip = UTF8SKIP(s);
            STRLEN i;
            d[skip] = '\0';
            for ( i = 0; i < skip; i++ )
                d[i] = *s++;
        }
        else {
            *d = *s++;
            d[1] = '\0';
        }
    }
d11770 1
a11770 1
	    d += UTF8SKIP(d);
a11795 1
   /* diag_listed_as: Ambiguous use of %c{%s[...]} resolved to %c%s[...] */
a11801 1
		PL_lex_allbrackets++;
d11827 1
a11827 1
		     || get_cvn_flags(dest, d - dest, UTF ? SVf_UTF8 : 0)))
a11828 2
                    SV *tmp = newSVpvn_flags( dest, d - dest,
                                            SVs_TEMP | (UTF ? SVf_UTF8 : 0) );
d11832 2
a11833 2
			"Ambiguous use of %c{%"SVf"} resolved to %c%"SVf,
			funny, tmp, funny, tmp);
d11847 8
a11854 20
static bool
S_pmflag(pTHX_ const char* const valid_flags, U32 * pmfl, char** s, char* charset) {

    /* Adds, subtracts to/from 'pmfl' based on regex modifier flags found in
     * the parse starting at 's', based on the subset that are valid in this
     * context input to this routine in 'valid_flags'. Advances s.  Returns
     * TRUE if the input was a valid flag, so the next char may be as well;
     * otherwise FALSE. 'charset' should point to a NUL upon first call on the
     * current regex.  This routine will set it to any charset modifier found.
     * The caller shouldn't change it.  This way, another charset modifier
     * encountered in the parse can be detected as an error, as we have decided
     * allow only one */

    const char c = **s;

    if (! strchr(valid_flags, c)) {
        if (isALNUM(c)) {
	    goto deprecate;
        }
        return FALSE;
d11856 2
d11859 4
a11862 1
    switch (c) {
d11864 2
a11865 64
        CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl);
        case GLOBAL_PAT_MOD:      *pmfl |= PMf_GLOBAL; break;
        case CONTINUE_PAT_MOD:    *pmfl |= PMf_CONTINUE; break;
        case ONCE_PAT_MOD:        *pmfl |= PMf_KEEP; break;
        case KEEPCOPY_PAT_MOD:    *pmfl |= RXf_PMf_KEEPCOPY; break;
        case NONDESTRUCT_PAT_MOD: *pmfl |= PMf_NONDESTRUCT; break;
	case LOCALE_PAT_MOD:

	    /* In 5.14, qr//lt is legal but deprecated; the 't' means they
	     * can't be regex modifiers.
	     * In 5.14, s///le is legal and ambiguous.  Try to disambiguate as
	     * much as easily done.  s///lei, for example, has to mean regex
	     * modifiers if it's not an error (as does any word character
	     * following the 'e').  Otherwise, we resolve to the backwards-
	     * compatible, but less likely 's/// le ...', i.e. as meaning
	     * less-than-or-equal.  The reason it's not likely is that s//
	     * returns a number for code in the field (/r returns a string, but
	     * that wasn't added until the 5.13 series), and so '<=' should be
	     * used for comparing, not 'le'. */
	    if (*((*s) + 1) == 't') {
		goto deprecate;
	    }
	    else if (*((*s) + 1) == 'e' && ! isALNUM(*((*s) + 2))) {

		/* 'e' is valid only for substitutes, s///e.  If it is not
		 * valid in the current context, then 'm//le' must mean the
		 * comparison operator, so use the regular deprecation message.
		 */
		if (! strchr(valid_flags, 'e')) {
		    goto deprecate;
		}
		Perl_ck_warner_d(aTHX_ packWARN(WARN_AMBIGUOUS),
		    "Ambiguous use of 's//le...' resolved as 's// le...'; Rewrite as 's//el' if you meant 'use locale rules and evaluate rhs as an expression'.  In Perl 5.18, it will be resolved the other way");
		return FALSE;
	    }
	    if (*charset) {
		goto multiple_charsets;
	    }
	    set_regex_charset(pmfl, REGEX_LOCALE_CHARSET);
	    *charset = c;
	    break;
	case UNICODE_PAT_MOD:
	    /* In 5.14, qr//unless and qr//until are legal but deprecated; the
	     * 'n' means they can't be regex modifiers */
	    if (*((*s) + 1) == 'n') {
		goto deprecate;
	    }
	    if (*charset) {
		goto multiple_charsets;
	    }
	    set_regex_charset(pmfl, REGEX_UNICODE_CHARSET);
	    *charset = c;
	    break;
	case ASCII_RESTRICT_PAT_MOD:
	    /* In 5.14, qr//and is legal but deprecated; the 'n' means they
	     * can't be regex modifiers */
	    if (*((*s) + 1) == 'n') {
		goto deprecate;
	    }

	    if (! *charset) {
		set_regex_charset(pmfl, REGEX_ASCII_RESTRICTED_CHARSET);
	    }
	    else {
d11867 2
a11868 19
		/* Error if previous modifier wasn't an 'a', but if it was, see
		 * if, and accept, a second occurrence (only) */
		if (*charset != 'a'
		    || get_regex_charset(*pmfl)
			!= REGEX_ASCII_RESTRICTED_CHARSET)
		{
			goto multiple_charsets;
		}
		set_regex_charset(pmfl, REGEX_ASCII_MORE_RESTRICTED_CHARSET);
	    }
	    *charset = c;
	    break;
	case DEPENDS_PAT_MOD:
	    if (*charset) {
		goto multiple_charsets;
	    }
	    set_regex_charset(pmfl, REGEX_DEPENDS_CHARSET);
	    *charset = c;
	    break;
a11869 23

    (*s)++;
    return TRUE;

    deprecate:
	Perl_ck_warner_d(aTHX_ packWARN(WARN_SYNTAX),
	    "Having no space between pattern and following word is deprecated");
        return FALSE;

    multiple_charsets:
	if (*charset != c) {
	    yyerror(Perl_form(aTHX_ "Regexp modifiers \"/%c\" and \"/%c\" are mutually exclusive", *charset, c));
	}
	else if (c == 'a') {
	    yyerror("Regexp modifier \"/a\" may appear a maximum of twice");
	}
	else {
	    yyerror(Perl_form(aTHX_ "Regexp modifier \"/%c\" may not appear twice", c));
	}

	/* Pretend that it worked, so will continue processing before dieing */
	(*s)++;
	return TRUE;
a11879 1
    char charset = '\0';    /* character set modifier */
d11921 2
a11922 1
    while (*s && S_pmflag(aTHX_ valid_flags, &(pm->op_pmflags), &s, &charset)) {};
d11945 1
a11945 1
    char *s;
a11948 1
    char charset = '\0';    /* character set modifier */
d12001 3
a12003 2
	else if (! S_pmflag(aTHX_ S_PAT_MODS, &(pm->op_pmflags), &s, &charset))
	{
a12004 1
	}
d12053 1
a12056 1
    bool nondestruct = 0;
a12109 3
	case 'r':
	    nondestruct = 1;
	    break;
d12117 2
a12118 1
    o = newPVOP(nondestruct ? OP_TRANSR : OP_TRANS, 0, (char*)NULL);
d12125 1
a12125 1
    pl_yylval.ival = nondestruct ? OP_TRANSR : OP_TRANS;
d12152 1
a12152 2
    const int outer = (PL_rsfp || PL_parser->filtered)
		   && !(PL_lex_inwhat == OP_SCALAR);
d12276 1
a12276 2
    if (PL_lex_inwhat == OP_SUBST && PL_in_eval && !PL_rsfp
     && !PL_parser->filtered) {
a12375 1
	    lex_grow_linestr(SvCUR(PL_linestr) + SvCUR(herewas) + 1);
d12458 1
a12458 1
	d += UTF ? UTF8SKIP(d) : 1;
d12501 1
a12501 1
	    const PADOFFSET tmp = pad_findmy_pvn(d, len, UTF ? SVf_UTF8 : 0);
d12517 1
a12517 1
				op_append_elem(OP_LIST, o,
d12529 1
a12529 1
				 : GV_ADDMULTI) | ( UTF ? SVf_UTF8 : 0 ),
d12533 1
a12533 1
			    op_append_elem(OP_LIST,
d12549 1
a12549 1
	    GV * const gv = gv_fetchpv(d, GV_ADD | ( UTF ? SVf_UTF8 : 0 ), SVt_PVIO);
d12552 1
a12552 1
			op_append_elem(OP_LIST,
d12652 1
a12652 1
	termcode = utf8_to_uvchr_buf((U8*)s, (U8*)PL_bufend, &termlen);
d12698 1
a12698 1
		    if (*s == '\n' && !PL_rsfp && !PL_parser->filtered)
d12765 1
a12765 1
		if (*s == '\n' && !PL_rsfp && !PL_parser->filtered)
d12797 1
a12797 1
		if (*s == '\n' && !PL_rsfp && !PL_parser->filtered)
d12967 1
a12967 1
	Perl_croak(aTHX_ "panic: scan_num, *s=%d", *s);
d13002 1
a13002 1
	    if (s[1] == 'x' || s[1] == 'X') {
d13006 1
a13006 1
	    } else if (s[1] == 'b' || s[1] == 'B') {
d13120 1
d13126 1
a13126 1
		sv = newSVnv(n);
d13135 1
a13135 1
		sv = newSVuv(u);
d13266 3
d13280 1
a13280 1
		sv = newSViv(uv); /* Prefer IVs over UVs. */
d13282 1
a13282 1
	    	sv = newSVuv(uv);
d13285 1
a13285 1
                sv = newSViv(-(IV)uv);
d13295 1
a13295 1
	    sv = newSVnv(nv);
d13361 1
a13361 1
	if (PL_in_eval && !PL_rsfp && !PL_parser->filtered) {
d13392 1
a13392 1
	if (PL_rsfp || PL_parser->filtered) {
d13486 1
a13486 1
S_yywarn(pTHX_ const char *const s, U32 flags)
d13493 1
a13493 1
    yyerror_pv(s, flags);
a13500 14
    PERL_ARGS_ASSERT_YYERROR;
    return yyerror_pvn(s, strlen(s), 0);
}

int
Perl_yyerror_pv(pTHX_ const char *const s, U32 flags)
{
    PERL_ARGS_ASSERT_YYERROR_PV;
    return yyerror_pvn(s, strlen(s), flags);
}

int
Perl_yyerror_pvn(pTHX_ const char *const s, STRLEN len, U32 flags)
{
d13502 1
a13505 1
    SV * const where_sv = newSVpvs_flags("", SVs_TEMP);
a13506 1
    U32 is_utf8 = flags & SVf_UTF8;
d13508 1
a13508 1
    PERL_ARGS_ASSERT_YYERROR_PVN;
d13511 1
a13511 1
	sv_catpvs(where_sv, "at EOF");
d13546 1
a13546 1
	sv_catpvs(where_sv, "next token ???");
d13550 1
a13550 1
	    sv_catpvs(where_sv, "at end of line");
d13552 1
a13552 1
	    sv_catpvs(where_sv, "within pattern");
d13554 1
a13554 1
	    sv_catpvs(where_sv, "within string");
d13557 1
a13557 1
	sv_catpvs(where_sv, "next char ");
d13566 1
d13568 1
a13568 1
    msg = sv_2mortal(newSVpvn_flags(s, len, is_utf8));
d13572 1
a13572 3
	Perl_sv_catpvf(aTHX_ msg, "near \"%"SVf"\"\n",
                            SVfARG(newSVpvn_flags(context, contlen,
                                        SVs_TEMP | (UTF ? SVf_UTF8 : 0))));
d13574 1
a13574 1
	Perl_sv_catpvf(aTHX_ msg, "%"SVf"\n", SVfARG(where_sv));
a13614 1
		/* diag_listed_as: Unsupported script encoding %s */
a13622 1
	    /* diag_listed_as: Unsupported script encoding %s */
a13635 1
	    /* diag_listed_as: Unsupported script encoding %s */
a13650 1
		       /* diag_listed_as: Unsupported script encoding %s */
a13661 1
		  /* diag_listed_as: Unsupported script encoding %s */
a13683 1
	      /* diag_listed_as: Unsupported script encoding %s */
d13703 1
a13703 1
    const bool reverse = cBOOL(IoLINES(filter));
a13705 2
    PERL_ARGS_ASSERT_UTF16_TEXTFILTER;

a13818 2
    PERL_ARGS_ASSERT_ADD_UTF16_TEXTFILTER;

a13895 1
			/* diag_listed_as: Integer overflow in %s number */
a13934 415
}

#define parse_recdescent(g,p) S_parse_recdescent(aTHX_ g,p)
static void
S_parse_recdescent(pTHX_ int gramtype, I32 fakeeof)
{
    SAVEI32(PL_lex_brackets);
    if (PL_lex_brackets > 100)
	Renew(PL_lex_brackstack, PL_lex_brackets + 10, char);
    PL_lex_brackstack[PL_lex_brackets++] = XFAKEEOF;
    SAVEI32(PL_lex_allbrackets);
    PL_lex_allbrackets = 0;
    SAVEI8(PL_lex_fakeeof);
    PL_lex_fakeeof = (U8)fakeeof;
    if(yyparse(gramtype) && !PL_parser->error_count)
	qerror(Perl_mess(aTHX_ "Parse error"));
}

#define parse_recdescent_for_op(g,p) S_parse_recdescent_for_op(aTHX_ g,p)
static OP *
S_parse_recdescent_for_op(pTHX_ int gramtype, I32 fakeeof)
{
    OP *o;
    ENTER;
    SAVEVPTR(PL_eval_root);
    PL_eval_root = NULL;
    parse_recdescent(gramtype, fakeeof);
    o = PL_eval_root;
    LEAVE;
    return o;
}

#define parse_expr(p,f) S_parse_expr(aTHX_ p,f)
static OP *
S_parse_expr(pTHX_ I32 fakeeof, U32 flags)
{
    OP *exprop;
    if (flags & ~PARSE_OPTIONAL)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_expr");
    exprop = parse_recdescent_for_op(GRAMEXPR, fakeeof);
    if (!exprop && !(flags & PARSE_OPTIONAL)) {
	if (!PL_parser->error_count)
	    qerror(Perl_mess(aTHX_ "Parse error"));
	exprop = newOP(OP_NULL, 0);
    }
    return exprop;
}

/*
=for apidoc Amx|OP *|parse_arithexpr|U32 flags

Parse a Perl arithmetic expression.  This may contain operators of precedence
down to the bit shift operators.  The expression must be followed (and thus
terminated) either by a comparison or lower-precedence operator or by
something that would normally terminate an expression such as semicolon.
If I<flags> includes C<PARSE_OPTIONAL> then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_arithexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_COMPARE, flags);
}

/*
=for apidoc Amx|OP *|parse_termexpr|U32 flags

Parse a Perl term expression.  This may contain operators of precedence
down to the assignment operators.  The expression must be followed (and thus
terminated) either by a comma or lower-precedence operator or by
something that would normally terminate an expression such as semicolon.
If I<flags> includes C<PARSE_OPTIONAL> then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_termexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_COMMA, flags);
}

/*
=for apidoc Amx|OP *|parse_listexpr|U32 flags

Parse a Perl list expression.  This may contain operators of precedence
down to the comma operator.  The expression must be followed (and thus
terminated) either by a low-precedence logic operator such as C<or> or by
something that would normally terminate an expression such as semicolon.
If I<flags> includes C<PARSE_OPTIONAL> then the expression is optional,
otherwise it is mandatory.  It is up to the caller to ensure that the
dynamic parser state (L</PL_parser> et al) is correctly set to reflect
the source of the code to be parsed and the lexical context for the
expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_listexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_LOWLOGIC, flags);
}

/*
=for apidoc Amx|OP *|parse_fullexpr|U32 flags

Parse a single complete Perl expression.  This allows the full
expression grammar, including the lowest-precedence operators such
as C<or>.  The expression must be followed (and thus terminated) by a
token that an expression would normally be terminated by: end-of-file,
closing bracketing punctuation, semicolon, or one of the keywords that
signals a postfix expression-statement modifier.  If I<flags> includes
C<PARSE_OPTIONAL> then the expression is optional, otherwise it is
mandatory.  It is up to the caller to ensure that the dynamic parser
state (L</PL_parser> et al) is correctly set to reflect the source of
the code to be parsed and the lexical context for the expression.

The op tree representing the expression is returned.  If an optional
expression is absent, a null pointer is returned, otherwise the pointer
will be non-null.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

=cut
*/

OP *
Perl_parse_fullexpr(pTHX_ U32 flags)
{
    return parse_expr(LEX_FAKEEOF_NONEXPR, flags);
}

/*
=for apidoc Amx|OP *|parse_block|U32 flags

Parse a single complete Perl code block.  This consists of an opening
brace, a sequence of statements, and a closing brace.  The block
constitutes a lexical scope, so C<my> variables and various compile-time
effects can be contained within it.  It is up to the caller to ensure
that the dynamic parser state (L</PL_parser> et al) is correctly set to
reflect the source of the code to be parsed and the lexical context for
the statement.

The op tree representing the code block is returned.  This is always a
real op, never a null pointer.  It will normally be a C<lineseq> list,
including C<nextstate> or equivalent ops.  No ops to construct any kind
of runtime scope are included by virtue of it being a block.

If an error occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.
Some compilation errors, however, will throw an exception immediately.

The I<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_block(pTHX_ U32 flags)
{
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_block");
    return parse_recdescent_for_op(GRAMBLOCK, LEX_FAKEEOF_NEVER);
}

/*
=for apidoc Amx|OP *|parse_barestmt|U32 flags

Parse a single unadorned Perl statement.  This may be a normal imperative
statement or a declaration that has compile-time effect.  It does not
include any label or other affixture.  It is up to the caller to ensure
that the dynamic parser state (L</PL_parser> et al) is correctly set to
reflect the source of the code to be parsed and the lexical context for
the statement.

The op tree representing the statement is returned.  This may be a
null pointer if the statement is null, for example if it was actually
a subroutine definition (which has compile-time side effects).  If not
null, it will be ops directly implementing the statement, suitable to
pass to L</newSTATEOP>.  It will not normally include a C<nextstate> or
equivalent op (except for those embedded in a scope contained entirely
within the statement).

If an error occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.
Some compilation errors, however, will throw an exception immediately.

The I<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_barestmt(pTHX_ U32 flags)
{
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_barestmt");
    return parse_recdescent_for_op(GRAMBARESTMT, LEX_FAKEEOF_NEVER);
}

/*
=for apidoc Amx|SV *|parse_label|U32 flags

Parse a single label, possibly optional, of the type that may prefix a
Perl statement.  It is up to the caller to ensure that the dynamic parser
state (L</PL_parser> et al) is correctly set to reflect the source of
the code to be parsed.  If I<flags> includes C<PARSE_OPTIONAL> then the
label is optional, otherwise it is mandatory.

The name of the label is returned in the form of a fresh scalar.  If an
optional label is absent, a null pointer is returned.

If an error occurs in parsing, which can only occur if the label is
mandatory, a valid label is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.

=cut
*/

SV *
Perl_parse_label(pTHX_ U32 flags)
{
    if (flags & ~PARSE_OPTIONAL)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_label");
    if (PL_lex_state == LEX_KNOWNEXT) {
	PL_parser->yychar = yylex();
	if (PL_parser->yychar == LABEL) {
	    SV *lsv;
	    PL_parser->yychar = YYEMPTY;
	    lsv = newSV_type(SVt_PV);
	    sv_copypv(lsv, cSVOPx(pl_yylval.opval)->op_sv);
	    return lsv;
	} else {
	    yyunlex();
	    goto no_label;
	}
    } else {
	char *s, *t;
	STRLEN wlen, bufptr_pos;
	lex_read_space(0);
	t = s = PL_bufptr;
        if (!isIDFIRST_lazy_if(s, UTF))
	    goto no_label;
	t = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE, &wlen);
	if (word_takes_any_delimeter(s, wlen))
	    goto no_label;
	bufptr_pos = s - SvPVX(PL_linestr);
	PL_bufptr = t;
	lex_read_space(LEX_KEEP_PREVIOUS);
	t = PL_bufptr;
	s = SvPVX(PL_linestr) + bufptr_pos;
	if (t[0] == ':' && t[1] != ':') {
	    PL_oldoldbufptr = PL_oldbufptr;
	    PL_oldbufptr = s;
	    PL_bufptr = t+1;
	    return newSVpvn_flags(s, wlen, UTF ? SVf_UTF8 : 0);
	} else {
	    PL_bufptr = s;
	    no_label:
	    if (flags & PARSE_OPTIONAL) {
		return NULL;
	    } else {
		qerror(Perl_mess(aTHX_ "Parse error"));
		return newSVpvs("x");
	    }
	}
    }
}

/*
=for apidoc Amx|OP *|parse_fullstmt|U32 flags

Parse a single complete Perl statement.  This may be a normal imperative
statement or a declaration that has compile-time effect, and may include
optional labels.  It is up to the caller to ensure that the dynamic
parser state (L</PL_parser> et al) is correctly set to reflect the source
of the code to be parsed and the lexical context for the statement.

The op tree representing the statement is returned.  This may be a
null pointer if the statement is null, for example if it was actually
a subroutine definition (which has compile-time side effects).  If not
null, it will be the result of a L</newSTATEOP> call, normally including
a C<nextstate> or equivalent op.

If an error occurs in parsing or compilation, in most cases a valid op
tree (most likely null) is returned anyway.  The error is reflected in
the parser state, normally resulting in a single exception at the top
level of parsing which covers all the compilation errors that occurred.
Some compilation errors, however, will throw an exception immediately.

The I<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_fullstmt(pTHX_ U32 flags)
{
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_fullstmt");
    return parse_recdescent_for_op(GRAMFULLSTMT, LEX_FAKEEOF_NEVER);
}

/*
=for apidoc Amx|OP *|parse_stmtseq|U32 flags

Parse a sequence of zero or more Perl statements.  These may be normal
imperative statements, including optional labels, or declarations
that have compile-time effect, or any mixture thereof.  The statement
sequence ends when a closing brace or end-of-file is encountered in a
place where a new statement could have validly started.  It is up to
the caller to ensure that the dynamic parser state (L</PL_parser> et al)
is correctly set to reflect the source of the code to be parsed and the
lexical context for the statements.

The op tree representing the statement sequence is returned.  This may
be a null pointer if the statements were all null, for example if there
were no statements or if there were only subroutine definitions (which
have compile-time side effects).  If not null, it will be a C<lineseq>
list, normally including C<nextstate> or equivalent ops.

If an error occurs in parsing or compilation, in most cases a valid op
tree is returned anyway.  The error is reflected in the parser state,
normally resulting in a single exception at the top level of parsing
which covers all the compilation errors that occurred.  Some compilation
errors, however, will throw an exception immediately.

The I<flags> parameter is reserved for future use, and must always
be zero.

=cut
*/

OP *
Perl_parse_stmtseq(pTHX_ U32 flags)
{
    OP *stmtseqop;
    I32 c;
    if (flags)
	Perl_croak(aTHX_ "Parsing code internal error (%s)", "parse_stmtseq");
    stmtseqop = parse_recdescent_for_op(GRAMSTMTSEQ, LEX_FAKEEOF_CLOSING);
    c = lex_peek_unichar(0);
    if (c != -1 && c != /*{*/'}')
	qerror(Perl_mess(aTHX_ "Parse error"));
    return stmtseqop;
}

void
Perl_munge_qwlist_to_paren_list(pTHX_ OP *qwlist)
{
    PERL_ARGS_ASSERT_MUNGE_QWLIST_TO_PAREN_LIST;
    deprecate("qw(...) as parentheses");
    force_next((4<<24)|')');
    if (qwlist->op_type == OP_STUB) {
	op_free(qwlist);
    }
    else {
	start_force(PL_curforce);
	NEXTVAL_NEXTTOKE.opval = qwlist;
	force_next(THING);
    }
    force_next((2<<24)|'(');
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d69 1
d114 6
a119 1
static const char* const ident_too_long = "Identifier too long";
a150 3
 *
 * These values refer to the various states within a sublex parse,
 * i.e. within a double quotish string
d275 1
a275 1
#define UNI3(f,x,have_x) { \
d277 1
a277 1
	if (have_x) PL_expect = x; \
d286 2
a287 2
#define UNI(f)    UNI3(f,XTERM,1)
#define UNIDOR(f) UNI3(f,XTERMORDORDOR,1)
d293 9
a301 1
#define UNIBRACK(f) UNI3(f,0,0)
a313 9
#define COPLINE_INC_WITH_HERELINES		    \
    STMT_START {				     \
	CopLINE_inc(PL_curcop);			      \
	if (PL_parser->lex_shared->herelines)	       \
	    CopLINE(PL_curcop) += PL_parser->lex_shared->herelines, \
	    PL_parser->lex_shared->herelines = 0;		     \
    } STMT_END


d322 2
a323 1
    TOKENTYPE_OPVAL
a352 2
    { FORMLBRACK,	TOKENTYPE_NONE,		"FORMLBRACK" },
    { FORMRBRACK,	TOKENTYPE_NONE,		"FORMRBRACK" },
d362 1
a362 1
    { LABEL,		TOKENTYPE_PVAL,		"LABEL" },
d371 1
a376 1
    { PEG,		TOKENTYPE_NONE,		"PEG" },
a385 1
    { QWLIST,		TOKENTYPE_OPVAL,	"QWLIST" },
a387 1
    { REQUIRE,		TOKENTYPE_NONE,		"REQUIRE" },
d428 1
a428 1
	else if ((char)rv > ' ' && (char)rv <= '~')
d436 1
d547 1
a547 1
	    for (t = PL_oldoldbufptr; (isWORDCHAR_lazy_if(t,UTF) || *t == ':');
d634 2
a635 2
    const char *s = SvPVX_const(sv);
    const char * const e = s + SvCUR(sv);
d643 1
a643 1
	    char *d = s - 1;
a745 1
    Newxz(parser->lex_shared, 1, LEXSHARED);
d753 2
a754 1
	sv_catpvs(parser->linestr, "\n;");
a786 2
    SvREFCNT_dec(parser->lex_stuff);
    SvREFCNT_dec(parser->sublex_info.repl);
a789 1
    Safefree(parser->lex_shared);
a793 31
void
Perl_parser_free_nexttoke_ops(pTHX_  yy_parser *parser, OPSLAB *slab)
{
#ifdef PERL_MAD
    I32 nexttoke = parser->lasttoke;
#else
    I32 nexttoke = parser->nexttoke;
#endif
    PERL_ARGS_ASSERT_PARSER_FREE_NEXTTOKE_OPS;
    while (nexttoke--) {
#ifdef PERL_MAD
	if (S_is_opval_token(parser->nexttoke[nexttoke].next_type
				& 0xffff)
	 && parser->nexttoke[nexttoke].next_val.opval
	 && parser->nexttoke[nexttoke].next_val.opval->op_slabbed
	 && OpSLAB(parser->nexttoke[nexttoke].next_val.opval) == slab) {
		op_free(parser->nexttoke[nexttoke].next_val.opval);
		parser->nexttoke[nexttoke].next_val.opval = NULL;
	}
#else
	if (S_is_opval_token(parser->nexttype[nexttoke] & 0xffff)
	 && parser->nextval[nexttoke].opval
	 && parser->nextval[nexttoke].opval->op_slabbed
	 && OpSLAB(parser->nextval[nexttoke].opval) == slab) {
	    op_free(parser->nextval[nexttoke].opval);
	    parser->nextval[nexttoke].opval = NULL;
	}
#endif
    }
}

d913 1
a913 1
    STRLEN linestart_pos, last_uni_pos, last_lop_pos, re_eval_start_pos;
a924 3
    re_eval_start_pos = PL_parser->lex_shared->re_eval_start ?
                            PL_parser->lex_shared->re_eval_start - buf : 0;

a925 1

a934 2
    if (PL_parser->lex_shared->re_eval_start)
        PL_parser->lex_shared->re_eval_start  = buf + re_eval_start_pos;
d972 1
a972 1
	    STRLEN highhalf = 0;    /* Count of variants */
d974 2
a975 5
	    for (p = pv; p != e; p++) {
		if (! UTF8_IS_INVARIANT(*p)) {
                    highhalf++;
                }
            }
d986 3
a988 3
		if (! UTF8_IS_INVARIANT(c)) {
		    *bufptr++ = UTF8_TWO_BYTE_HI(c);
		    *bufptr++ = UTF8_TWO_BYTE_LO(c);
d1000 1
a1000 1
		if (UTF8_IS_ABOVE_LATIN1(c)) {
d1003 2
a1004 1
		} else if (UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(p, e)) {
d1007 1
a1007 1
		} else if (! UTF8_IS_INVARIANT(c)) {
d1024 7
a1030 5
	    p = pv;
	    while (p < e) {
		if (UTF8_IS_INVARIANT(*p)) {
		    *bufptr++ = *p;
                    p++;
a1031 5
		else {
                    assert(p < e -1 );
		    *bufptr++ = TWO_BYTE_UTF8_TO_UNI(*p, *(p+1));
		    p += 2;
                }
d1034 1
a1034 1
	  plain_copy:
d1165 1
a1165 1
	    COPLINE_INC_WITH_HERELINES;
a1247 1
#define LEX_NO_TERM  0x40000000
d1259 1
a1259 1
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_FAKE_EOF|LEX_NO_TERM))
a1289 2
    } else if (flags & LEX_NO_TERM) {
	got_some = 0;
d1379 1
a1379 1
	if (UTF8_IS_INVARIANT(head))
d1381 2
a1382 2
	if (UTF8_IS_START(head)) {
	    len = UTF8SKIP(&head);
d1439 1
a1439 1
	    COPLINE_INC_WITH_HERELINES;
d1508 1
a1508 1
	    COPLINE_INC_WITH_HERELINES;
d1551 1
a1551 7
    COPLINE_INC_WITH_HERELINES;
    if (!PL_rsfp && !PL_parser->filtered && PL_lex_state == LEX_NORMAL
     && s+1 == PL_bufend && *s == ';') {
	/* fake newline in string eval */
	CopLINE_dec(PL_curcop);
	return;
    }
d1684 1
a1684 1
S_skipspace0(pTHX_ char *s)
d1705 1
a1705 1
S_skipspace1(pTHX_ char *s)
d1732 1
a1732 1
S_skipspace2(pTHX_ char *s, SV **svp)
d1785 1
a1785 1
S_skipspace(pTHX_ char *s)
d1840 1
a1840 1
    while (isWORDCHAR_lazy_if(s,UTF) || *s == '-')
d2059 1
a2059 1
S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack, int allow_initial_tick)
d2062 1
a2062 1
    char *s;
d2108 1
a2108 1
S_force_ident(pTHX_ const char *s, int kind)
d2114 2
a2115 2
    if (s[0]) {
	const STRLEN len = s[1] ? strlen(s) : 1; /* s = "\"" see yylex */
a2137 8
static void
S_force_ident_maybe_lex(pTHX_ char pit)
{
    start_force(PL_curforce);
    NEXTVAL_NEXTTOKE.ival = pit;
    force_next('p');
}

d2307 3
a2309 3
    char *s;
    char *send;
    char *d;
d2352 8
a2359 4
 * For example,
 *   "foo\lbar"
 * is tokenised as
 *    stringify ( const[foo] concat lcfirst ( const[bar] ) )
d2382 1
a2382 1
    const I32 op_type = pl_yylval.ival;
a2442 1
    LEXSHARED *shared;
a2448 1
    SAVEI32(PL_lex_formbrack);
a2452 1
    SAVESPTR(PL_lex_repl);
a2465 9
    SAVEGENERICPV(PL_parser->lex_shared);
    SAVEBOOL(PL_parser->lex_re_reparsing);

    /* The here-doc parser needs to be able to peek into outer lexing
       scopes to find the body of the here-doc.  So we put PL_linestr and
       PL_bufptr into lex_shared, to share those values.
     */
    PL_parser->lex_shared->ls_linestr = PL_linestr;
    PL_parser->lex_shared->ls_bufptr  = PL_bufptr;
a2467 1
    PL_lex_repl = PL_sublex_info.repl;
a2468 1
    PL_sublex_info.repl = NULL;
a2474 1
    if (PL_lex_repl) SAVEFREESV(PL_lex_repl);
d2477 1
a2477 1
    PL_lex_brackets = PL_lex_formbrack = 0;
a2486 4
    
    Newxz(shared, 1, LEXSHARED);
    shared->ls_prev = PL_parser->lex_shared;
    PL_parser->lex_shared = shared;
a2494 3
    PL_parser->lex_re_reparsing = cBOOL(PL_in_eval & EVAL_RE_REPARSING);
    PL_in_eval &= ~EVAL_RE_REPARSING;

d2529 1
a2574 195
PERL_STATIC_INLINE SV*
S_get_and_check_backslash_N_name(pTHX_ const char* s, const char* const e)
{
    /* <s> points to first character of interior of \N{}, <e> to one beyond the
     * interior, hence to the "}".  Finds what the name resolves to, returning
     * an SV* containing it; NULL if no valid one found */

    SV* res = newSVpvn_flags(s, e - s, UTF ? SVf_UTF8 : 0);

    HV * table;
    SV **cvp;
    SV *cv;
    SV *rv;
    HV *stash;
    const U8* first_bad_char_loc;
    const char* backslash_ptr = s - 3; /* Points to the <\> of \N{... */

    PERL_ARGS_ASSERT_GET_AND_CHECK_BACKSLASH_N_NAME;

    if (UTF && ! is_utf8_string_loc((U8 *) backslash_ptr,
                                     e - backslash_ptr,
                                     &first_bad_char_loc))
    {
        /* If warnings are on, this will print a more detailed analysis of what
         * is wrong than the error message below */
        utf8n_to_uvuni(first_bad_char_loc,
                       e - ((char *) first_bad_char_loc),
                       NULL, 0);

        /* We deliberately don't try to print the malformed character, which
         * might not print very well; it also may be just the first of many
         * malformations, so don't print what comes after it */
        yyerror(Perl_form(aTHX_
            "Malformed UTF-8 character immediately after '%.*s'",
            (int) (first_bad_char_loc - (U8 *) backslash_ptr), backslash_ptr));
	return NULL;
    }

    res = new_constant( NULL, 0, "charnames", res, NULL, backslash_ptr,
                        /* include the <}> */
                        e - backslash_ptr + 1);
    if (! SvPOK(res)) {
        SvREFCNT_dec_NN(res);
        return NULL;
    }

    /* See if the charnames handler is the Perl core's, and if so, we can skip
     * the validation needed for a user-supplied one, as Perl's does its own
     * validation. */
    table = GvHV(PL_hintgv);		 /* ^H */
    cvp = hv_fetchs(table, "charnames", FALSE);
    if (cvp && (cv = *cvp) && SvROK(cv) && ((rv = SvRV(cv)) != NULL)
        && SvTYPE(rv) == SVt_PVCV && ((stash = CvSTASH(rv)) != NULL))
    {
        const char * const name = HvNAME(stash);
        if strEQ(name, "_charnames") {
           return res;
       }
    }

    /* Here, it isn't Perl's charname handler.  We can't rely on a
     * user-supplied handler to validate the input name.  For non-ut8 input,
     * look to see that the first character is legal.  Then loop through the
     * rest checking that each is a continuation */

    /* This code needs to be sync'ed with a regex in _charnames.pm which does
     * the same thing */

    if (! UTF) {
        if (! isALPHAU(*s)) {
            goto bad_charname;
        }
        s++;
        while (s < e) {
            if (! isCHARNAME_CONT(*s)) {
                goto bad_charname;
            }
	    if (*s == ' ' && *(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
                Perl_warn(aTHX_ "A sequence of multiple spaces in a charnames alias definition is deprecated");
            }
            s++;
        }
        if (*(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
            Perl_warn(aTHX_ "Trailing white-space in a charnames alias definition is deprecated");
        }
    }
    else {
        /* Similarly for utf8.  For invariants can check directly; for other
         * Latin1, can calculate their code point and check; otherwise  use a
         * swash */
        if (UTF8_IS_INVARIANT(*s)) {
            if (! isALPHAU(*s)) {
                goto bad_charname;
            }
            s++;
        } else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
            if (! isALPHAU(UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(*s, *(s+1))))) {
                goto bad_charname;
            }
            s += 2;
        }
        else {
            if (! PL_utf8_charname_begin) {
                U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
                PL_utf8_charname_begin = _core_swash_init("utf8",
                                                        "_Perl_Charname_Begin",
                                                        &PL_sv_undef,
                                                        1, 0, NULL, &flags);
            }
            if (! swash_fetch(PL_utf8_charname_begin, (U8 *) s, TRUE)) {
                goto bad_charname;
            }
            s += UTF8SKIP(s);
        }

        while (s < e) {
            if (UTF8_IS_INVARIANT(*s)) {
                if (! isCHARNAME_CONT(*s)) {
                    goto bad_charname;
                }
                if (*s == ' ' && *(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
                    Perl_warn(aTHX_ "A sequence of multiple spaces in a charnames alias definition is deprecated");
                }
                s++;
            }
            else if (UTF8_IS_DOWNGRADEABLE_START(*s)) {
                if (! isCHARNAME_CONT(UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(*s,
                                                                    *(s+1)))))
                {
                    goto bad_charname;
                }
                s += 2;
            }
            else {
                if (! PL_utf8_charname_continue) {
                    U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
                    PL_utf8_charname_continue = _core_swash_init("utf8",
                                                "_Perl_Charname_Continue",
                                                &PL_sv_undef,
                                                1, 0, NULL, &flags);
                }
                if (! swash_fetch(PL_utf8_charname_continue, (U8 *) s, TRUE)) {
                    goto bad_charname;
                }
                s += UTF8SKIP(s);
            }
        }
        if (*(s-1) == ' ' && ckWARN(WARN_DEPRECATED)) {
            Perl_warn(aTHX_ "Trailing white-space in a charnames alias definition is deprecated");
        }
    }

    if (SvUTF8(res)) { /* Don't accept malformed input */
        const U8* first_bad_char_loc;
        STRLEN len;
        const char* const str = SvPV_const(res, len);
        if (! is_utf8_string_loc((U8 *) str, len, &first_bad_char_loc)) {
            /* If warnings are on, this will print a more detailed analysis of
             * what is wrong than the error message below */
            utf8n_to_uvuni(first_bad_char_loc,
                           (char *) first_bad_char_loc - str,
                           NULL, 0);

            /* We deliberately don't try to print the malformed character,
             * which might not print very well; it also may be just the first
             * of many malformations, so don't print what comes after it */
            yyerror_pv(
              Perl_form(aTHX_
                "Malformed UTF-8 returned by %.*s immediately after '%.*s'",
                 (int) (e - backslash_ptr + 1), backslash_ptr,
                 (int) ((char *) first_bad_char_loc - str), str
              ),
              SVf_UTF8);
            return NULL;
        }
    }

    return res;

  bad_charname: {
        int bad_char_size = ((UTF) ? UTF8SKIP(s) : 1);

        /* The final %.*s makes sure that should the trailing NUL be missing
         * that this print won't run off the end of the string */
        yyerror_pv(
          Perl_form(aTHX_
            "Invalid character in \\N{...}; marked by <-- HERE in %.*s<-- HERE %.*s",
            (int)(s - backslash_ptr + bad_char_size), backslash_ptr,
            (int)(e - s + bad_char_size), s + bad_char_size
          ),
          UTF ? SVf_UTF8 : 0);
        return NULL;
    }
}

d2578 2
a2579 5
  Extracts the next constant part of a pattern, double-quoted string,
  or transliteration.  This is terrifying code.

  For example, in parsing the double-quoted string "ab\x63$d", it would
  stop at the '$' and return an OP_CONST containing 'abc'.
d2587 1
a2587 1
  successfully parsed), will leave an OP_CONST for the substring scanned
d2592 4
a2595 12
    expand:
      \N{FOO}  => \N{U+hex_for_character_FOO}
      (if FOO expands to multiple characters, expands to \N{U+xx.XX.yy ...})

    pass through:
	all other \-char, including \N and \N{ apart from \N{ABC}

    stops on:
	@@ and $ where it appears to be a var, but not for $ as tail anchor
        \l \L \u \U \Q \E
	(?{  or  (??{

d2625 1
a2625 1
  \1 (backreferences) are turned into $1 in substitutions
d2657 1
a2657 1
    char *send = PL_bufend;		/* end of the constant */
d2660 2
a2661 2
    char *s = start;			/* start of the constant */
    char *d = SvPVX(sv);		/* destination for copies */
a2663 1
    bool in_charclass = FALSE;			/* within /[...]/ */
a2670 1
    SV *res;		                /* result from charnames */
d2684 1
a2684 2
    UV uv = UV_MAX; /* Initialize to weird value to try to catch any uses
                       before set */
a2698 3
    /* Protect sv from errors and fatal warnings. */
    ENTER_with_name("scan_const");
    SAVEFREESV(sv);
d2718 1
a2718 1
                ) {
d2853 3
a2855 23
	else if (*s == '[' && PL_lex_inpat && !in_charclass) {
	    char *s1 = s-1;
	    int esc = 0;
	    while (s1 >= start && *s1-- == '\\')
		esc = !esc;
	    if (!esc)
		in_charclass = TRUE;
	}

	else if (*s == ']' && PL_lex_inpat &&  in_charclass) {
	    char *s1 = s-1;
	    int esc = 0;
	    while (s1 >= start && *s1-- == '\\')
		esc = !esc;
	    if (!esc)
		in_charclass = FALSE;
	}

	/* skip for regexp comments /(?#comment)/, except for the last
	 * char, which will be done separately.
	 * Stop on (?{..}) and friends */

	else if (*s == '(' && PL_lex_inpat && s[1] == '?' && !in_charclass) {
d2860 2
a2861 3
	    else if (!PL_lex_casemods &&
		     (    s[2] == '{' /* This should match regcomp.c */
		      || (s[2] == '?' && s[3] == '{')))
d2863 17
a2879 1
		break;
d2886 1
a2886 11
	    while (s+1 < send && *s != '\n') {
                /* for maint-5.18, half-fix #-in-charclass bug:
                 *   *do* recognise codeblocks: /[#](?{})/
                 *   *don't* recognise interpolated vars: /[#$x]/
                 */
                if (in_charclass && !PL_lex_casemods && s+3 < send &&
		     s[0] == '(' &&
		     s[1] == '?' &&
		     (    s[2] == '{'
		      || (s[2] == '?' && s[3] == '{')))
                    break;
a2887 3
            }
            if (s+ 1 < send && *s != '\n')
                break; /* we stopped on (?{}), not EOL */
a2889 4
	/* no further processing of single-quoted regex */
	else if (PL_lex_inpat && SvIVX(PL_linestr) == '\'')
	    goto default_action;

d2894 1
a2894 1
	    if (isWORDCHAR_lazy_if(s+1,UTF))
d2956 1
a2956 1
			|| regcurly(s + 1, FALSE)))
d2973 1
a2973 1
		    if ((isALPHANUMERIC(*s)))
d2985 1
a2985 1
                    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
a2988 6
                    if (len < 3 && s < send && isDIGIT(*s)
                        && ckWARN(WARN_MISC))
                    {
                        Perl_warner(aTHX_ packWARN(WARN_MISC),
                                    "%s", form_short_octal_warning(s, len));
                    }
d2995 1
d2998 2
a2999 6
		    bool valid = grok_bslash_o(&s, &uv, &error,
                                               TRUE, /* Output warning */
                                               FALSE, /* Not strict */
                                               TRUE, /* Output warnings for
                                                         non-portables */
                                               UTF);
d3009 6
a3014 2
		{
		    const char* error;
d3016 3
a3018 8
		    bool valid = grok_bslash_x(&s, &uv, &error,
                                               TRUE, /* Output warning */
                                               FALSE, /* Not strict */
                                               TRUE,  /* Output warnings for
                                                         non-portables */
                                               UTF);
		    if (! valid) {
			yyerror(error);
d3021 11
d3136 25
d3222 26
a3247 6
		else /* Here is \N{NAME} but not \N{U+...}. */
                     if ((res = get_and_check_backslash_N_name(s, e)))
                {
                    STRLEN len;
                    const char *str = SvPV_const(res, len);
                    if (PL_lex_inpat) {
d3261 4
d3267 49
a3315 26
                            if (! SvUTF8(res)) {
                                /* For the non-UTF-8 case, we can determine the
                                 * exact length needed without having to parse
                                 * through the string.  Each character takes up
                                 * 2 hex digits plus either a trailing dot or
                                 * the "}" */
                                d = off + SvGROW(sv, off
                                                    + 3 * len
                                                    + 6 /* For the "\N{U+", and
                                                           trailing NUL */
                                                    + (STRLEN)(send - e));
                                Copy("\\N{U+", d, 5, char);
                                d += 5;
                                while (str < str_end) {
                                    char hex_string[4];
                                    my_snprintf(hex_string, sizeof(hex_string),
                                                "%02X.", (U8) *str);
                                    Copy(hex_string, d, 3, char);
                                    d += 3;
                                    str++;
                                }
                                d--;    /* We will overwrite below the final
                                           dot with a right brace */
                            }
                            else {
                                STRLEN char_length; /* cur char's byte length */
d3317 11
a3327 53
                                /* and the number of bytes after this is
                                 * translated into hex digits */
                                STRLEN output_length;

                                /* 2 hex per byte; 2 chars for '\N'; 2 chars
                                 * for max('U+', '.'); and 1 for NUL */
                                char hex_string[2 * UTF8_MAXBYTES + 5];

                                /* Get the first character of the result. */
                                U32 uv = utf8n_to_uvuni((U8 *) str,
                                                        len,
                                                        &char_length,
                                                        UTF8_ALLOW_ANYUV);
                                /* Convert first code point to hex, including
                                 * the boiler plate before it.  For all these,
                                 * we convert to native format so that
                                 * downstream code can continue to assume the
                                 * input is native */
                                output_length =
                                    my_snprintf(hex_string, sizeof(hex_string),
                                            "\\N{U+%X",
                                            (unsigned int) UNI_TO_NATIVE(uv));

                                /* Make sure there is enough space to hold it */
                                d = off + SvGROW(sv, off
                                                    + output_length
                                                    + (STRLEN)(send - e)
                                                    + 2);	/* '}' + NUL */
                                /* And output it */
                                Copy(hex_string, d, output_length, char);
                                d += output_length;

                                /* For each subsequent character, append dot and
                                * its ordinal in hex */
                                while ((str += char_length) < str_end) {
                                    const STRLEN off = d - SvPVX_const(sv);
                                    U32 uv = utf8n_to_uvuni((U8 *) str,
                                                            str_end - str,
                                                            &char_length,
                                                            UTF8_ALLOW_ANYUV);
                                    output_length =
                                        my_snprintf(hex_string,
                                            sizeof(hex_string),
                                            ".%X",
                                            (unsigned int) UNI_TO_NATIVE(uv));

                                    d = off + SvGROW(sv, off
                                                        + output_length
                                                        + (STRLEN)(send - e)
                                                        + 2);	/* '}' +  NUL */
                                    Copy(hex_string, d, output_length, char);
                                    d += output_length;
                                }
a3359 1

d3362 60
d3547 1
a3547 4
	SvREFCNT_inc_simple_void_NN(sv);
	if (   (PL_hints & ( PL_lex_inpat ? HINT_NEW_RE : HINT_NEW_STRING ))
            && ! PL_parser->lex_re_reparsing)
        {
a3558 3
	    } else if (PL_lex_inpat && SvIVX(PL_linestr) == '\'') {
		type = "q";
		typelen = 1;
d3568 2
a3569 2
    }
    LEAVE_with_name("scan_const");
d3595 1
a3595 1
S_intuit_more(pTHX_ char *s)
d3612 1
a3612 1
	if (regcurly(s, FALSE)) {
d3625 1
a3625 1
	int weight;
d3627 1
a3628 1
	unsigned char un_char, last_un_char;
a3632 1
	weight = 2;		/* let's weigh the evidence */
d3634 1
a3644 2
	Zero(seen,256,char);
	un_char = 255;
d3653 1
a3653 1
		if (isWORDCHAR_lazy_if(s+1,UTF)) {
d3700 1
a3700 1
		if (!isWORDCHAR(last_un_char)
d3735 1
a3735 1
 * Not a method if foo is a filehandle.
d3760 2
a3761 1
    if (gv && SvTYPE(gv) == SVt_PVGV && GvIO(gv))
d3763 2
a3764 1
    if (cv && SvPOK(cv)) {
d3772 3
d3783 1
a3783 1
	if (cv || PL_last_lop_op == OP_PRINT || PL_last_lop_op == OP_SAY ||
d3810 1
a3810 1
	if (!cv || GvIO(indirgv) || gv_stashpvn(tmpbuf, len, UTF ? SVf_UTF8 : 0)) {
d4049 1
a4049 1
S_filter_gets(pTHX_ SV *sv, STRLEN append)
d4144 4
d4234 1
a4248 4
    /* pval */
    case LABEL:
	break;

a4316 1
    PL_expect = XTERM;
d4363 1
a4363 1
    The type of the next token
d4366 12
a4377 31
      Switch based on the current state:
	  - if we already built the token before, use it
	  - if we have a case modifier in a string, deal with that
	  - handle other cases of interpolation inside a string
	  - scan the next line if we are inside a format
      In the normal state switch on the next character:
	  - default:
	    if alphabetic, go to key lookup
	    unrecoginized character - croak
	  - 0/4/26: handle end-of-line or EOF
	  - cases for whitespace
	  - \n and #: handle comments and line numbers
	  - various operators, brackets and sigils
	  - numbers
	  - quotes
	  - 'v': vstrings (or go to key lookup)
	  - 'x' repetition operator (or go to key lookup)
	  - other ASCII alphanumerics (key lookup begins here):
	      word before => ?
	      keyword plugin
	      scan built-in keyword (but do nothing with it yet)
	      check for statement label
	      check for lexical subs
		  goto just_a_word if there is one
	      see whether built-in keyword is overridden
	      switch on keyword number:
		  - default: just_a_word:
		      not a built-in keyword; handle bareword lookup
		      disambiguate between method and sub call
		      fall back to bareword
		  - cases for built-in keywords
d4388 2
a4389 2
    char *s = PL_bufptr;
    char *d;
a4391 1
    U8 formbrack = 0;
d4410 5
d4474 6
a4479 1
	    return REPORT(next_type == 'p' ? pending_ident() : next_type);
d4520 1
a4520 2
		if (PL_madskills) {
		  if (!PL_thiswhite)
d4522 1
a4522 2
		  sv_catpvn(PL_thiswhite, PL_bufptr, 2);
		}
d4538 1
a4538 2
		if (PL_madskills) {
		  if (!PL_thiswhite)
d4540 1
a4540 2
		  sv_catpvn(PL_thiswhite, PL_bufptr, 4);
		}
d4618 1
a4618 1
	DEBUG_T({ if(*PL_bufptr != '(') PerlIO_printf(Perl_debug_log,
d4621 1
a4621 4
        /* for /@@a/, we leave the joining for the regex engine to do
         * (unless we're within \Q etc) */
	PL_lex_dojoin = (*PL_bufptr == '@@'
                            && (!PL_lex_inpat || PL_lex_casemods));
a4638 12
	/* Convert (?{...}) and friends to 'do {...}' */
	if (PL_lex_inpat && *PL_bufptr == '(') {
	    PL_parser->lex_shared->re_eval_start = PL_bufptr;
	    PL_bufptr += 2;
	    if (*PL_bufptr != '{')
		PL_bufptr++;
	    start_force(PL_curforce);
	    /* XXX probably need a CURMAD(something) here */
	    PL_expect = XTERMBLOCK;
	    force_next(DO);
	}

a4683 32
	/* Paranoia.  re_eval_start is adjusted when S_scan_heredoc sets
	   re_eval_str.  If the here-doc bodys length equals the previous
	   value of re_eval_start, re_eval_start will now be null.  So
	   check re_eval_str as well. */
	if (PL_parser->lex_shared->re_eval_start
	 || PL_parser->lex_shared->re_eval_str) {
	    SV *sv;
	    if (*PL_bufptr != ')')
		Perl_croak(aTHX_ "Sequence (?{...}) not terminated with ')'");
	    PL_bufptr++;
	    /* having compiled a (?{..}) expression, return the original
	     * text too, as a const */
	    if (PL_parser->lex_shared->re_eval_str) {
		sv = PL_parser->lex_shared->re_eval_str;
		PL_parser->lex_shared->re_eval_str = NULL;
		SvCUR_set(sv,
			 PL_bufptr - PL_parser->lex_shared->re_eval_start);
		SvPV_shrink_to_cur(sv);
	    }
	    else sv = newSVpvn(PL_parser->lex_shared->re_eval_start,
			 PL_bufptr - PL_parser->lex_shared->re_eval_start);
	    start_force(PL_curforce);
	    /* XXX probably need a CURMAD(something) here */
	    NEXTVAL_NEXTTOKE.opval =
		    (OP*)newSVOP(OP_CONST, 0,
				 sv);
	    force_next(THING);
	    PL_parser->lex_shared->re_eval_start = NULL;
	    PL_expect = XTERM;
	    return REPORT(',');
	}

d4694 1
a4694 2
	/* m'foo' still needs to be parsed for possible (?{...}) */
	if (SvIVX(PL_linestr) == '\'' && !PL_lex_inpat) {
d4696 4
a4699 1
	    sv = tokeq(sv);
d4741 1
a4743 2
	{
	    formbrack = 1;
d4745 1
a4745 3
	}
	PL_bufptr = s;
	return yylex();
d4762 1
a4762 1
	if (UTF ? isIDFIRST_utf8((U8*)s) : isALNUMC(*s))
d4893 1
a4893 1
	    COPLINE_INC_WITH_HERELINES;
d5137 1
d5139 1
a5139 4
	    start_force(PL_curforce);
	    NEXTVAL_NEXTTOKE.ival = 0;
	    force_next(FORMRBRACK);
	    TOKEN(';');
d5151 1
a5151 2
	if (PL_madskills) {
	  if (!PL_thiswhite)
d5153 1
a5153 2
	  sv_catpvn(PL_thiswhite, s, 1);
	}
a5177 1
		const bool in_comment = *s == '#';
d5191 1
a5191 5
		if (in_comment && d == PL_bufend
		 && PL_lex_state == LEX_INTERPNORMAL
		 && PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
		 && SvEVALED(PL_lex_repl) && d[-1] == '}') s--;
		else incline(s);
d5194 1
d5196 1
a5196 4
		start_force(PL_curforce);
		NEXTVAL_NEXTTOKE.ival = 0;
		force_next(FORMRBRACK);
		TOKEN(';');
d5239 1
a5239 1
	if (s[1] && isALPHA(s[1]) && !isWORDCHAR(s[2])) {
d5411 1
a5411 2
	PL_expect = XOPERATOR;
	force_ident_maybe_lex('%');
a5435 3
            Perl_ck_warner_d(aTHX_
                packWARN(WARN_EXPERIMENTAL__SMARTMATCH),
                "Smartmatch is experimental");
d5498 1
a5498 1
		    d = scan_str(d,TRUE,TRUE,FALSE, FALSE);
d5654 1
a5655 1
      leftbracket:
d5661 8
a5668 1
	    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
d5750 1
a5750 1
			&& (!isWORDCHAR(*t)
d5752 1
a5752 1
				&& !isWORDCHAR(*t))))
d5791 1
a5791 1
			while (t < PL_bufend && isWORDCHAR_lazy_if(t,UTF))
d5794 1
a5794 1
		else if (isWORDCHAR_lazy_if(t,UTF)) {
d5796 1
a5796 1
		    while (t < PL_bufend && isWORDCHAR_lazy_if(t,UTF))
d5818 1
a5818 1
	TOKEN(formbrack ? '=' : '{');
d5829 2
d5846 1
a5846 4
		if (PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
		 && SvEVALED(PL_lex_repl))
		    PL_lex_state = LEX_INTERPEND;
		else if (*s == '-' && s[1] == '>')
d5862 1
a5862 2
	force_next(formbrack ? '.' : '}');
	if (formbrack) LEAVE;
d5864 1
a5864 1
	if (PL_madskills && !PL_thistoken)
a5866 5
	if (formbrack == 2) { /* means . where arguments were expected */
	    start_force(PL_curforce);
	    force_next(';');
	    TOKEN(FORMRBRACK);
	}
d5895 2
a5896 4
	PL_tokenbuf[0] = '&';
	s = scan_ident(s - 1, PL_bufend, PL_tokenbuf + 1,
		       sizeof PL_tokenbuf - 1, TRUE);
	if (PL_tokenbuf[1]) {
d5898 1
a5898 1
	    force_ident_maybe_lex('&');
d5952 1
a5952 2
		    if ((PL_in_eval && !PL_rsfp && !PL_parser->filtered)
			|| PL_lex_state != LEX_NORMAL) {
d5983 1
a5983 1
	if (PL_expect == XBLOCK) {
d5992 2
a5993 6
		formbrack = 1;
		ENTER;
		SAVEI8(PL_parser->form_lex_state);
		SAVEI32(PL_lex_formbrack);
		PL_parser->form_lex_state = PL_lex_state;
		PL_lex_formbrack = PL_lex_brackets + 1;
d6019 2
a6020 2
			 && !isWORDCHAR(t[1])) ||
			(*t == 't' && t[1] == 'r' && !isWORDCHAR(t[2])))
d6044 1
a6044 2
	    PL_expect = XOPERATOR;
	    TOKEN(sublex_start());
d6128 1
a6128 1
	    force_ident_maybe_lex('#');
d6156 1
a6156 1
			while (isSPACE(*t) || isWORDCHAR_lazy_if(t,UTF) || *t == '$')
d6246 1
a6246 1
	force_ident_maybe_lex('$');
d6267 1
a6267 1
		    while (*t && (isWORDCHAR_lazy_if(t,UTF) || strchr(" \t$#+-'\"", *t)))
d6283 1
a6283 2
	PL_expect = XOPERATOR;
	force_ident_maybe_lex('@@');
d6334 1
a6334 1
	          || isWORDCHAR_lazy_if(PL_last_uni+5,UTF)
d6352 1
a6353 1
	    formbrack = 2; /* dot seen where arguments expected */
d6394 1
a6394 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d6409 1
a6409 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d6432 1
a6432 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
a6458 8
	    else if ((*start == ':' && start[1] == ':')
		  || (PL_expect == XSTATE && *start == ':'))
		goto keylookup;
	    else if (PL_expect == XSTATE) {
		d = start;
		while (d < PL_bufend && isSPACE(*d)) d++;
		if (*d == ':') goto keylookup;
	    }
d6460 1
a6460 1
	    if (!isALPHA(*start) && (PL_expect == XTERM
a6508 1
	bool lex;
a6509 4
	SV *sv;
	CV *cv;
	PADOFFSET off;
	OP *rv2cv_op;
a6510 1
	lex = FALSE;
a6511 3
	off = 0;
	sv = NULL;
	cv = NULL;
a6513 1
	rv2cv_op = NULL;
d6573 3
a6575 3
	    pl_yylval.pval = savepvn(PL_tokenbuf, len+1);
	    pl_yylval.pval[len] = '\0';
	    pl_yylval.pval[len+1] = UTF ? 1 : 0;
a6579 35
	/* Check for lexical sub */
	if (PL_expect != XOPERATOR) {
	    char tmpbuf[sizeof PL_tokenbuf + 1];
	    *tmpbuf = '&';
	    Copy(PL_tokenbuf, tmpbuf+1, len, char);
	    off = pad_findmy_pvn(tmpbuf, len+1, UTF ? SVf_UTF8 : 0);
	    if (off != NOT_IN_PAD) {
		assert(off); /* we assume this is boolean-true below */
		if (PAD_COMPNAME_FLAGS_isOUR(off)) {
		    HV *  const stash = PAD_COMPNAME_OURSTASH(off);
		    HEK * const stashname = HvNAME_HEK(stash);
		    sv = newSVhek(stashname);
                    sv_catpvs(sv, "::");
                    sv_catpvn_flags(sv, PL_tokenbuf, len,
				    (UTF ? SV_CATUTF8 : SV_CATBYTES));
		    gv = gv_fetchsv(sv, GV_NOADD_NOINIT | SvUTF8(sv),
				    SVt_PVCV);
		    off = 0;
		    if (!gv) {
			sv_free(sv);
			sv = NULL;
			goto just_a_word;
		    }
		}
		else {
		    rv2cv_op = newOP(OP_PADANY, 0);
		    rv2cv_op->op_targ = off;
		    cv = find_lexical_cv(off);
		}
		lex = TRUE;
		goto just_a_word;
	    }
	    off = 0;
	}

a6638 2
		sv = NULL;
		cv = NULL;
a6640 1
		rv2cv_op = NULL;
a6641 2
		lex = 0;
		off = 0;
d6644 1
d6647 2
a6648 4
		const char penultchar =
		    lastchar && PL_bufptr - 2 >= PL_linestart
			 ? PL_bufptr[-2]
			 : 0;
d6680 1
a6680 2
		   unless this is a lexical sub, or name is "Foo::",
		   in which case Foo is a bareword
d6698 1
a6698 1
		    if (!lex && !gv) {
d6712 1
a6712 2
		if (!sv)
		  sv = S_newSV_maybe_utf8(aTHX_ PL_tokenbuf,
a6737 1
		if (!off)
a6741 1
		    cv = lex ? GvCV(gv) : rv2cv_op_cv(rv2cv_op, 0);
d6743 1
d6830 1
a6830 2
		    NEXTVAL_NEXTTOKE.opval =
			off ? rv2cv_op : pl_yylval.opval;
d6839 2
a6840 3
		    if (off)
			 op_free(pl_yylval.opval), force_next(PRIVATEREF);
		    else op_free(rv2cv_op),	   force_next(WORD);
d6872 1
a6872 1
		    if (lastchar == '-' && penultchar != '-') {
d6884 1
a6884 1
			pl_yylval.opval->op_private = OPpCONST_FOLDED;
d6890 1
a6890 2
		    pl_yylval.opval =
			off ? (OP *)newCVREF(0, rv2cv_op) : rv2cv_op;
d6955 1
a6955 1
			force_next(off ? PRIVATEREF : WORD);
d6986 1
a6986 2
			pl_yylval.opval =
			    off ? (OP *)newCVREF(0, rv2cv_op) : rv2cv_op;
d6998 1
a6998 1
			force_next(off ? PRIVATEREF : WORD);
d7007 1
a7007 1
		    force_next(off ? PRIVATEREF : WORD);
d7199 1
a7199 1
		STRLEN olen = len;
a7200 1
		s += 2;
d7202 1
a7202 9
		if ((*s == ':' && s[1] == ':')
		 || (!(tmp = keyword(PL_tokenbuf, len, 1)) && *s == '\''))
		{
		    s = d;
		    len = olen;
		    Copy(PL_bufptr, PL_tokenbuf, olen, char);
		    goto just_a_word;
		}
		if (!tmp)
d7313 2
a7314 12
	    if (*s != '\'') {
		*PL_tokenbuf = '&';
		d = scan_word(s, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1,
			      1, &len);
		if (len && !keyword(PL_tokenbuf + 1, len, 0)) {
		    d = SKIPSPACE1(d);
		    if (*d == '(') {
			force_ident_maybe_lex('&');
			s = d;
		    }
		}
	    }
a7346 1
	    PL_expect = XOPERATOR;
a7478 1
	    PL_expect = XOPERATOR;
a7564 3
            Perl_ck_warner_d(aTHX_
                packWARN(WARN_EXPERIMENTAL__SMARTMATCH),
                "given is experimental");
a7600 1
	    PL_expect = XOPERATOR;
a7677 9
		{
		    if (!FEATURE_LEXSUBS_IS_ENABLED)
			Perl_croak(aTHX_
				  "Experimental \"%s\" subs not enabled",
				   tmp == KEY_my    ? "my"    :
				   tmp == KEY_state ? "state" : "our");
		    Perl_ck_warner_d(aTHX_
			packWARN(WARN_EXPERIMENTAL__LEXICAL_SUBS),
			"The lexical_subs feature is experimental");
a7678 1
		}
a7697 1
	    PL_expect = XOPERATOR;
d7708 1
a7708 1
	    TERM(USE);
d7723 9
a7731 3
          const char *t;
          d = scan_word(s, PL_tokenbuf, sizeof PL_tokenbuf, FALSE,
              &len);
d7798 1
a7798 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d7809 1
a7809 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d7859 1
a7859 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d7872 1
a7872 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
a7882 1
	    PL_expect = XOPERATOR;
a7913 1
	    PL_expect = XOPERATOR;
d8086 1
a8086 1
		char * const tmpbuf = PL_tokenbuf + 1;
d8096 1
a8096 3
		SV *subtoken = PL_madskills
		   ? newSVpvn_flags(tstart, s - tstart, SvUTF8(PL_linestr))
		   : NULL;
a8101 1
		d = s;
d8116 1
a8116 2
		    d = scan_word(s, tmpbuf, sizeof PL_tokenbuf - 1, TRUE,
				  &len);
d8121 1
a8121 5
		    *PL_tokenbuf = '&';
		    if (memchr(tmpbuf, ':', len) || key != KEY_sub
		     || pad_findmy_pvn(
			    PL_tokenbuf, len + 1, UTF ? SVf_UTF8 : 0
			) != NOT_IN_PAD)
d8132 1
a8133 1
#ifdef PERL_MAD
d8137 2
a8138 1
		    force_ident_maybe_lex('&');
d8146 2
a8147 7
		    if (key == KEY_my || key == KEY_our || key==KEY_state)
		    {
			*d = '\0';
			/* diag_listed_as: Missing name in "%s sub" */
			Perl_croak(aTHX_
				  "Missing name in \"%s\"", PL_bufptr);
		    }
d8155 2
a8159 1
                    PERL_UNUSED_VAR(tboffset);
d8165 1
a8165 1
		    PREBLOCK(FORMAT);
d8181 1
a8181 1
		    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
a8281 1
                PERL_UNUSED_VAR(have_proto);
d8298 2
a8299 1
		force_ident_maybe_lex('&');
d8301 2
a8327 1
	case KEY_y:
a8404 3
            Perl_ck_warner_d(aTHX_
                packWARN(WARN_EXPERIMENTAL__SMARTMATCH),
                "when is experimental");
d8455 4
a8465 20
/*
  S_pending_ident

  Looks up an identifier in the pad or in a package

  Returns:
    PRIVATEREF if this is a lexical name.
    WORD       if this belongs to a package.

  Structure:
      if we're in a my declaration
	  croak if they tried to say my($foo::bar)
	  build the ops for a my() declaration
      if it's an access to a my() variable
	  build ops for access to a my() variable
      if in a dq string, and they've said @@foo and we can't find @@foo
	  warn
      build ops for a bareword
*/

d8470 1
d8472 2
a8473 1
    const char pit = (char)pl_yylval.ival;
d8477 1
d8479 1
d8506 1
a8506 1
	    return PRIVATEREF;
d8512 8
d8537 1
a8537 2
                if (pit != '&')
                  gv_fetchsv(sym,
d8548 17
d8595 1
a8595 2
    pl_yylval.opval = (OP*)newSVOP(OP_CONST, 0,
				   newSVpvn_flags(PL_tokenbuf + 1,
d8599 1
a8599 2
    if (pit != '&')
	gv_fetchpvn_flags(PL_tokenbuf+1, tokenbuf_len - 1,
d8645 1
a8645 1
	while (isWORDCHAR_lazy_if(s,UTF))
d8662 1
a8662 3
/* S_new_constant(): do any overload::constant lookup.

   Either returns sv, or mortalizes/frees sv and returns a new SV*.
d8665 1
a8665 2
   and <type> is used with error messages only.
   <type> is assumed to be well formed UTF-8 */
a8673 1
    SV *errsv = NULL;
a8678 3
    /* We assume that this is true: */
    if (*key == 'c') { assert (strEQ(key, "charnames")); }
    assert(type || s);
d8681 1
a8681 3
    if (PL_error_count > 0 && *key == 'c')
    {
	SvREFCNT_dec_NN(sv);
a8682 1
    }
a8683 1
    sv_2mortal(sv);			/* Parent created it permanently */
d8689 1
a8689 1
	char *msg;
d8693 1
a8693 1
	if (*key == 'c') {
d8715 2
a8716 4
	    msg = Perl_form(aTHX_
			       "Constant(%.*s) unknown",
				(int)(type ? typelen : len),
				(type ? type: s));
d8719 10
a8728 18
            why1 = "$^H{";
            why2 = key;
            why3 = "} is not defined";
        report:
            if (*key == 'c') {
                msg = Perl_form(aTHX_
                            /* The +3 is for '\N{'; -4 for that, plus '}' */
                            "Unknown charname '%.*s'", (int)typelen - 4, type + 3
                      );
            }
            else {
                msg = Perl_form(aTHX_ "Constant(%.*s): %s%s%s",
                                    (int)(type ? typelen : len),
                                    (type ? type: s), why1, why2, why3);
            }
        }
	yyerror_pv(msg, UTF ? SVf_UTF8 : 0);
  	return SvREFCNT_inc_simple_NN(sv);
d8731 1
d8757 3
a8759 6
    if (!PL_in_eval && ((errsv = ERRSV), SvTRUE_NN(errsv))) {
	STRLEN errlen;
	const char * errstr;
	sv_catpvs(errsv, "Propagated");
	errstr = SvPV_const(errsv, errlen);
	yyerror_pvn(errstr, errlen, 0); /* Duplicates the message inside eval */
d8761 1
a8761 1
	res = SvREFCNT_inc_simple_NN(sv);
d8765 1
a8765 1
	SvREFCNT_inc_simple_void_NN(res);
a8777 1
	(void)sv_2mortal(sv);
a8783 48
PERL_STATIC_INLINE void
S_parse_ident(pTHX_ char **s, char **d, char * const e, int allow_package, bool is_utf8) {
    dVAR;
    PERL_ARGS_ASSERT_PARSE_IDENT;

    for (;;) {
        if (*d >= e)
            Perl_croak(aTHX_ "%s", ident_too_long);
        if (is_utf8 && isIDFIRST_utf8((U8*)*s)) {
             /* The UTF-8 case must come first, otherwise things
             * like c\N{COMBINING TILDE} would start failing, as the
             * isWORDCHAR_A case below would gobble the 'c' up.
             */

            char *t = *s + UTF8SKIP(*s);
            while (isIDCONT_utf8((U8*)t))
                t += UTF8SKIP(t);
            if (*d + (t - *s) > e)
                Perl_croak(aTHX_ "%s", ident_too_long);
            Copy(*s, *d, t - *s, char);
            *d += t - *s;
            *s = t;
        }
        else if ( isWORDCHAR_A(**s) ) {
            do {
                *(*d)++ = *(*s)++;
            } while (isWORDCHAR_A(**s) && *d < e);
        }
        else if (allow_package && **s == '\'' && isIDFIRST_lazy_if(*s+1,is_utf8)) {
            *(*d)++ = ':';
            *(*d)++ = ':';
            (*s)++;
        }
        else if (allow_package && **s == ':' && (*s)[1] == ':'
           /* Disallow things like Foo::$bar. For the curious, this is
            * the code path that triggers the "Bad name after" warning
            * when looking for barewords.
            */
           && (*s)[2] != '$') {
            *(*d)++ = *(*s)++;
            *(*d)++ = *(*s)++;
        }
        else
            break;
    }
    return;
}

d8788 1
a8788 1
S_scan_word(pTHX_ char *s, char *dest, STRLEN destlen, int allow_package, STRLEN *slp)
d8791 2
a8792 3
    char *d = dest;
    char * const e = d + destlen - 3;  /* two-character token, ending NUL */
    bool is_utf8 = cBOOL(UTF);
d8796 32
a8827 4
    parse_ident(&s, &d, e, allow_package, is_utf8);
    *d = '\0';
    *slp = d - dest;
    return s;
d8831 1
a8831 1
S_scan_ident(pTHX_ char *s, const char *send, char *dest, STRLEN destlen, I32 ck_uni)
d8836 2
a8837 3
    char *d = dest;
    char * const e = d + destlen - 3;    /* two-character token, ending NUL */
    bool is_utf8 = cBOOL(UTF);
d8846 1
a8846 1
		Perl_croak(aTHX_ "%s", ident_too_long);
d8851 27
a8877 1
        parse_ident(&s, &d, e, 1, is_utf8);
d8887 1
a8887 5
      (isIDFIRST_lazy_if(s+1,is_utf8)
         || isDIGIT_A((U8)s[1])
         || s[1] == '$'
         || s[1] == '{'
         || strnEQ(s+1,"::",2)) )
a8893 2
	while (s < send && SPACE_OR_TAB(*s))
	   s++;
d8895 4
a8898 9

#define VALID_LEN_ONE_IDENT(d, u)     (isPUNCT_A((U8)*(d))     \
                                        || isCNTRL_A((U8)*(d)) \
                                        || isDIGIT_A((U8)*(d)) \
                                        || (!(u) && !UTF8_IS_INVARIANT((U8)*(d))))
    if (s < send
        && (isIDFIRST_lazy_if(s, is_utf8) || VALID_LEN_ONE_IDENT(s, is_utf8)))
    {
        if (is_utf8) {
a8913 2
    else if (ck_uni && !bracket)
	check_uni();
d8915 28
a8942 3
	if (isIDFIRST_lazy_if(d,is_utf8)) {
        d += is_utf8 ? UTF8SKIP(d) : 1;
        parse_ident(&s, &d, e, 1, is_utf8);
d8964 2
a8965 2
	else if (!isWORDCHAR(*d) && !isPRINT(*d) /* isCTRL(d) */
		 && isWORDCHAR(*s))
d8968 1
a8968 1
	    while (isWORDCHAR(*s) && d < e) {
d8972 1
a8972 1
		Perl_croak(aTHX_ "%s", ident_too_long);
a8974 4

        while (s < send && SPACE_OR_TAB(*s))
	    s++;

d8984 1
a8984 1
		     || get_cvn_flags(dest, d - dest, is_utf8 ? SVf_UTF8 : 0)))
d8987 1
a8987 1
                                            SVs_TEMP | (is_utf8 ? SVf_UTF8 : 0) );
d9012 6
a9017 6
     * TRUE if the input should be treated as a valid flag, so the next char
     * may be as well; otherwise FALSE. 'charset' should point to a NUL upon
     * first call on the current regex.  This routine will set it to any
     * charset modifier found.  The caller shouldn't change it.  This way,
     * another charset modifier encountered in the parse can be detected as an
     * error, as we have decided to allow only one */
a9019 1
    STRLEN charlen = UTF ? UTF8SKIP(*s) : 1;
d9021 3
a9023 8
    if ( charlen != 1 || ! strchr(valid_flags, c) ) {
        if (isWORDCHAR_lazy_if(*s, UTF)) {
            yyerror_pv(Perl_form(aTHX_ "Unknown regexp modifier \"/%.*s\"", (int)charlen, *s),
                       UTF ? SVf_UTF8 : 0);
            (*s) += charlen;
            /* Pretend that it worked, so will continue processing before
             * dieing */
            return TRUE;
d9037 28
d9072 5
d9084 6
d9119 5
d9145 1
a9145 1
    char *s;
a9154 3
    s = scan_str(start,!!PL_madskills,FALSE, (PL_in_eval & EVAL_RE_REPARSING),
                       TRUE /* look for escaped bracketed metas */ );

a9189 19

    /* if qr/...(?{..}).../, then need to parse the pattern within a new
     * anon CV. False positives like qr/[(?{]/ are harmless */

    if (type == OP_QR) {
	STRLEN len;
	char *e, *p = SvPV(PL_lex_stuff, len);
	e = p + len;
	for (; p < e; p++) {
	    if (p[0] == '(' && p[1] == '?'
		&& (p[2] == '{' || (p[2] == '?' && p[3] == '{')))
	    {
		pm->op_pmflags |= PMf_HAS_CV;
		break;
	    }
	}
	pm->op_pmflags |= PMf_IS_QR;
    }

d9214 1
a9214 1
    PMOP *pm;
d9226 1
a9226 2
    s = scan_str(start,!!PL_madskills,FALSE,FALSE,
                 TRUE /* look for escaped bracketed metas */ );
d9244 1
a9244 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d9291 2
d9302 3
a9304 1
	sv_catsv(repl, PL_sublex_info.repl);
d9307 2
a9308 2
	SvREFCNT_dec(PL_sublex_info.repl);
	PL_sublex_info.repl = repl;
d9320 1
a9320 1
    char* s;
d9334 1
a9334 1
    s = scan_str(start,!!PL_madskills,FALSE,FALSE, FALSE);
d9350 1
a9350 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE, FALSE);
d9393 1
a9393 1
      (DO_UTF8(PL_sublex_info.repl) ? OPpTRANS_TO_UTF   : 0);
a9409 24
/* scan_heredoc
   Takes a pointer to the first < in <<FOO.
   Returns a pointer to the byte following <<FOO.

   This function scans a heredoc, which involves different methods
   depending on whether we are in a string eval, quoted construct, etc.
   This is because PL_linestr could containing a single line of input, or
   a whole string being evalled, or the contents of the current quote-
   like operator.

   The two basic methods are:
    - Steal lines from the input stream
    - Scan the heredoc in PL_linestr and remove it therefrom

   In a file scope or filtered eval, the first method is used; in a
   string eval, the second.

   In a quote-like operator, we have to choose between the two,
   depending on where we can find a newline.  We peek into outer lex-
   ing scopes until we find one with a newline in it.  If we reach the
   outermost lexing scope and it is a file, we use the stream method.
   Otherwise it is treated as an eval.
*/

d9411 1
a9411 1
S_scan_heredoc(pTHX_ char *s)
d9414 1
d9419 3
a9421 2
    char *d;
    char *e;
d9423 2
a9424 2
    const bool infile = PL_rsfp || PL_parser->filtered;
    LEXSHARED *shared = PL_parser->lex_shared;
d9435 1
a9435 1
    d = PL_tokenbuf + 1;
d9437 2
a9438 1
    *PL_tokenbuf = '\n';
a9445 2
	if (s == PL_bufend)
	    Perl_croak(aTHX_ "Unterminated delimiter for here document");
d9447 2
a9448 1
	s++;
a9451 1
            /* <<\FOO is equivalent to <<'FOO' */
d9455 1
a9455 1
	if (!isWORDCHAR_lazy_if(s,UTF))
d9457 1
a9457 1
	for (; isWORDCHAR_lazy_if(s,UTF); s++) {
d9470 2
a9471 2
	tstart = PL_tokenbuf + 1;
	PL_thisclose = newSVpvn(tstart, len - 1);
d9502 14
d9523 2
d9526 1
d9528 3
d9544 2
a9545 1
    PL_multi_start = CopLINE(PL_curcop) + 1;
d9547 18
a9564 38
    /* inside a string eval or quote-like operator */
    if (!infile || PL_lex_inwhat) {
	SV *linestr;
	char *bufend;
	char * const olds = s;
	PERL_CONTEXT * const cx = &cxstack[cxstack_ix];
	/* These two fields are not set until an inner lexing scope is
	   entered.  But we need them set here. */
	shared->ls_bufptr  = s;
	shared->ls_linestr = PL_linestr;
	if (PL_lex_inwhat)
	  /* Look for a newline.  If the current buffer does not have one,
	     peek into the line buffer of the parent lexing scope, going
 	     up as many levels as necessary to find one with a newline
	     after bufptr.
	   */
	  while (!(s = (char *)memchr(
		    (void *)shared->ls_bufptr, '\n',
		    SvEND(shared->ls_linestr)-shared->ls_bufptr
		))) {
	    shared = shared->ls_prev;
	    /* shared is only null if we have gone beyond the outermost
	       lexing scope.  In a file, we will have broken out of the
	       loop in the previous iteration.  In an eval, the string buf-
	       fer ends with "\n;", so the while condition below will have
	       evaluated to false.  So shared can never be null. */
	    assert(shared);
	    /* A LEXSHARED struct with a null ls_prev pointer is the outer-
	       most lexing scope.  In a file, shared->ls_linestr at that
	       level is just one line, so there is no body to steal. */
	    if (infile && !shared->ls_prev) {
		s = olds;
		goto streaming;
	    }
	  }
	else {	/* eval */
	    s = (char*)memchr((void*)s, '\n', PL_bufend - s);
	    assert(s);
d9566 10
a9575 2
	linestr = shared->ls_linestr;
	bufend = SvEND(linestr);
d9577 2
a9578 2
	while (s < bufend - len + 1 &&
          memNE(s,PL_tokenbuf,len) ) {
d9580 1
a9580 1
		++shared->herelines;
d9582 3
a9584 2
	if (s >= bufend - len + 1) {
	    goto interminable;
d9597 1
a9597 2
	/* the preceding stmt passes a newline */
	shared->herelines++;
d9599 5
a9603 32
	/* s now points to the newline after the heredoc terminator.
	   d points to the newline before the body of the heredoc.
	 */

	/* We are going to modify linestr in place here, so set
	   aside copies of the string if necessary for re-evals or
	   (caller $n)[6]. */
	/* See the Paranoia note in case LEX_INTERPEND in yylex, for why we
	   check shared->re_eval_str. */
	if (shared->re_eval_start || shared->re_eval_str) {
	    /* Set aside the rest of the regexp */
	    if (!shared->re_eval_str)
		shared->re_eval_str =
		       newSVpvn(shared->re_eval_start,
				bufend - shared->re_eval_start);
	    shared->re_eval_start -= s-d;
	}
	if (cxstack_ix >= 0 && CxTYPE(cx) == CXt_EVAL &&
            CxOLD_OP_TYPE(cx) == OP_ENTEREVAL &&
            cx->blk_eval.cur_text == linestr)
        {
	    cx->blk_eval.cur_text = newSVsv(linestr);
	    SvSCREAM_on(cx->blk_eval.cur_text);
	}
	/* Copy everything from s onwards back to d. */
	Move(s,d,bufend-s + 1,char);
	SvCUR_set(linestr, SvCUR(linestr) - (s-d));
	/* Setting PL_bufend only applies when we have not dug deeper
	   into other scopes, because sublex_done sets PL_bufend to
	   SvEND(PL_linestr). */
	if (shared == PL_parser->lex_shared) PL_bufend = SvEND(linestr);
	s = olds;
d9606 2
a9607 11
    {
      SV *linestr_save;
     streaming:
      sv_setpvs(tmpstr,"");   /* avoid "uninitialized" warning */
      term = PL_tokenbuf[1];
      len--;
      linestr_save = PL_linestr; /* must restore this afterwards */
      d = s;			 /* and this */
      PL_linestr = newSVpvs("");
      PL_bufend = SvPVX(PL_linestr);
      while (1) {
d9617 5
a9621 12
	PL_bufptr = PL_bufend;
	CopLINE_set(PL_curcop,
		    PL_multi_start + shared->herelines);
	if (!lex_next_chunk(LEX_NO_TERM)
	 && (!SvCUR(tmpstr) || SvEND(tmpstr)[-1] != '\n')) {
	    SvREFCNT_dec(linestr_save);
	    goto interminable;
	}
	CopLINE_set(PL_curcop, (line_t)PL_multi_start - 1);
	if (!SvCUR(PL_linestr) || PL_bufend[-1] != '\n') {
	    lex_grow_linestr(SvCUR(PL_linestr) + 2);
	    sv_catpvs(PL_linestr, "\n\0");
d9623 1
d9628 2
a9629 1
	shared->herelines++;
d9646 5
a9650 4
	if (*s == term && memEQ(s,PL_tokenbuf + 1,len)) {
	    SvREFCNT_dec(PL_linestr);
	    PL_linestr = linestr_save;
	    PL_linestart = SvPVX(linestr_save);
d9652 1
a9652 2
	    s = d;
	    break;
d9655 1
a9657 1
      }
d9659 2
d9665 1
a9674 5

  interminable:
    SvREFCNT_dec(tmpstr);
    CopLINE_set(PL_curcop, (line_t)PL_multi_start - 1);
    missingterm(PL_tokenbuf + 1);
d9697 1
a9697 1
    char *s = start;		/* current position in buffer */
d9731 1
a9731 1
    while (*d && (isWORDCHAR_lazy_if(d,UTF) || *d == '\'' || *d == ':'))
d9742 1
a9742 1
	s = scan_str(start,!!PL_madskills,FALSE,FALSE, FALSE);
a9841 2
	  re_reparse  compiling a run-time /(?{})/:
			collapse // to /,  and skip encoding src
d9882 14
a9895 19
S_scan_str(pTHX_ char *start, int keep_quoted, int keep_delims, int re_reparse,
        bool deprecate_escaped_meta /* Should we issue a deprecation warning
                                       for certain paired metacharacters that
                                       appear escaped within it */
    )
{
    dVAR;
    SV *sv;			/* scalar value: string */
    const char *tmps;		/* temp string, used for delimiter matching */
    char *s = start;		/* current position in the buffer */
    char term;			/* terminating character */
    char *to;			/* current position in the sv's data */
    I32 brackets = 1;		/* bracket nesting level */
    bool has_utf8 = FALSE;	/* is there any utf8 content? */
    I32 termcode;		/* terminating char. code */
    U8 termstr[UTF8_MAXBYTES];	/* terminating string */
    STRLEN termlen;		/* length of terminating string */
    int last_off = 0;		/* last position for nesting bracket */
    char *escaped_open = NULL;
a9941 12
    /* A warning is raised if the input parameter requires it for escaped (by a
     * backslash) paired metacharacters {} [] and () when the delimiters are
     * those same characters, and the backslash is ineffective.  This doesn't
     * happen for <>, as they aren't metas. */
    if (deprecate_escaped_meta
        && (PL_multi_open == PL_multi_close
            || ! ckWARN_d(WARN_DEPRECATED)
            || PL_multi_open == '<'))
    {
        deprecate_escaped_meta = FALSE;
    }

d9955 1
a9955 1
    if (PL_madskills && !PL_thisopen && !keep_delims) {
d9961 1
a9961 1
	if (PL_encoding && !UTF && !re_reparse) {
d9973 1
a9973 1
			COPLINE_INC_WITH_HERELINES;
d10040 1
a10040 1
		    COPLINE_INC_WITH_HERELINES;
d10043 1
a10043 4
		    if (!keep_quoted
		        && (s[1] == term
			    || (re_reparse && s[1] == '\\'))
		    )
d10045 1
a10045 1
		    /* any other quotes are simply copied straight through */
d10072 1
a10072 1
		    COPLINE_INC_WITH_HERELINES;
a10076 1
                    {
a10077 36

                        /* Here, 'deprecate_escaped_meta' is true iff the
                         * delimiters are paired metacharacters, and 's' points
                         * to an occurrence of one of them within the string,
                         * which was preceded by a backslash.  If this is a
                         * context where the delimiter is also a metacharacter,
                         * the backslash is useless, and deprecated.  () and []
                         * are meta in any context. {} are meta only when
                         * appearing in a quantifier or in things like '\p{'.
                         * They also aren't meta unless there is a matching
                         * closed, escaped char later on within the string.
                         * If 's' points to an open, set a flag; if to a close,
                         * test that flag, and raise a warning if it was set */

			if (deprecate_escaped_meta) {
                            if (*s == PL_multi_open) {
                                if (*s != '{') {
                                    escaped_open = s;
                                }
                                else if (regcurly(s,
                                                  TRUE /* Look for a closing
                                                          '\}' */)
                                         || (s - start > 2  /* Look for e.g.
                                                               '\x{' */
                                             && _generic_isCC(*(s-2), _CC_BACKSLASH_FOO_LBRACE_IS_META)))
                                {
                                    escaped_open = s;
                                }
                            }
                            else if (escaped_open) {
                                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                    "Useless use of '\\'; doesn't escape metacharacter '%c'", PL_multi_open);
                                escaped_open = NULL;
                            }
                        }
                    }
d10131 1
a10131 1
	COPLINE_INC_WITH_HERELINES;
d10146 1
a10146 1
    if (!PL_encoding || UTF || re_reparse) {
d10178 1
a10178 1
    if (has_utf8 || (PL_encoding && !re_reparse))
d10194 1
a10194 1
	PL_sublex_info.repl = sv;
d10226 3
a10228 3
    const char *s = start;	/* current position in buffer */
    char *d;			/* destination in temp buffer */
    char *e;			/* end of temp buffer */
d10233 1
a10233 1
    static const char* const number_too_long = "Number too long";
d10443 1
a10443 1
		    Perl_croak(aTHX_ "%s", number_too_long);
d10473 1
a10473 1
		    Perl_croak(aTHX_ "%s", number_too_long);
d10525 1
a10525 1
		        Perl_croak(aTHX_ "%s", number_too_long);
a10580 2
		ENTER_with_name("scan_vstring");
		SAVEFREESV(sv);
a10581 2
		SvREFCNT_inc_simple_void_NN(sv);
		LEAVE_with_name("scan_vstring");
d10596 1
a10596 1
S_scan_formline(pTHX_ char *s)
d10599 2
a10600 2
    char *eol;
    char *t;
d10631 3
a10633 2
	eol = (char *) memchr(s,'\n',PL_bufend-s);
	if (!eol++)
d10635 3
d10662 1
a10662 2
	if ((PL_rsfp || PL_parser->filtered)
	 && PL_parser->form_lex_state == LEX_NORMAL) {
d10673 1
a10673 1
	    COPLINE_INC_WITH_HERELINES;
a10685 2
    if (!SvCUR(stuff) || needargs)
	PL_lex_state = PL_parser->form_lex_state;
d10687 1
a10687 1
	PL_expect = XSTATE;
d10689 1
d10692 1
a10692 1
	    force_next(FORMLBRACK);
d10694 2
d10705 3
d10713 1
d10734 3
a10747 3
    if (outsidecv && CvPADLIST(outsidecv))
	CvPADLIST(PL_compcv)->xpadl_outid =
	    PadlistNAMES(CvPADLIST(outsidecv));
d10791 1
d10852 1
a10852 1
    msg = newSVpvn_flags(s, len, (flags & SVf_UTF8) | SVs_TEMP);
d10873 1
a10873 2
	SV * errsv;
	if (PL_in_eval && ((errsv = ERRSV), SvCUR(errsv)))
d10875 1
a10875 1
		       SVfARG(errsv), OutCopFILE(PL_curcop));
d11139 1
a11139 1
	sv = sv_2mortal(newSV(5));
a11145 5
This function may croak if fatal warnings are enabled in the
calling scope, hence the sv_2mortal in the example (to prevent
a leak).  Make sure to do SvREFCNT_inc afterwards if you use
sv_2mortal.

d11511 1
a11511 2
	    char * const lpv = pl_yylval.pval;
	    STRLEN llen = strlen(lpv);
d11513 3
a11515 1
	    return newSVpvn_flags(lpv, llen, lpv[llen+1] ? SVf_UTF8 : 0);
d11632 17
d11653 1
a11653 1
 * indent-tabs-mode: nil
d11656 1
a11656 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d140 1
a140 1
#define SPACE_OR_TAB(c) isBLANK_A(c)
d185 4
d193 3
a220 1
 * POSTDEREF    : postfix dereference (->$* ->@@[...] etc.)
a251 1
#define POSTDEREF(f) return (PL_bufptr = s, S_postderef(aTHX_ REPORT(f),s[1]))
d306 3
a308 11
	if (PL_parser->herelines)		       \
	    CopLINE(PL_curcop) += PL_parser->herelines, \
	    PL_parser->herelines = 0;			 \
    } STMT_END
/* Called after scan_str to update CopLINE(PL_curcop), but only when there
 * is no sublex_push to follow. */
#define COPLINE_SET_FROM_MULTI_END	      \
    STMT_START {			       \
	CopLINE_set(PL_curcop, PL_multi_end);	\
	if (PL_multi_end != PL_multi_start)	 \
	    PL_parser->herelines = 0;		  \
a378 1
    { POSTJOIN,		TOKENTYPE_NONE,		"POSTJOIN" },
a429 1
	{
a430 3
	    if ((char)rv == 'p')
		sv_catpvs(report, " (pending identifier)");
	}
a476 1
    GCC_DIAG_IGNORE(-Wformat-nonliteral); /* fmt checked by caller */
a477 1
    GCC_DIAG_RESTORE;
d552 3
a554 2
			"\t(Do you need to predeclare %"UTF8f"?)\n",
		      UTF8fARG(UTF, t - PL_oldoldbufptr, PL_oldoldbufptr));
d559 3
a561 2
		    "\t(Missing operator before %"UTF8f"?)\n",
		     UTF8fARG(UTF, s - oldbp, oldbp));
d587 1
a587 1
    else if ((U8) PL_multi_close < 32) {
d730 1
a730 1
    parser->copline = parser->preambling = NOLINE;
d754 1
a754 1
	sv_catpvn(parser->linestr, "\n;", rsfp ? 1 : 2);
d756 1
a756 1
	parser->linestr = newSVpvn("\n;", rsfp ? 1 : 2);
d764 2
a765 5

    assert(FITS_IN_8_BITS(LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
                                                        |LEX_DONT_CLOSE_RSFP));
    parser->lex_flags = (U8) (flags & (LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
                                                        |LEX_DONT_CLOSE_RSFP));
d861 1
a861 1
+ SvCUR(PL_parser-E<gt>linestr)>.  A C<NUL> character (zero octet) is
d928 1
a928 1
at least I<len> octets (including terminating C<NUL>).  Returns a
d1054 1
a1054 1
		    utf8n_to_uvchr((U8*)p, e-p, NULL, 0);
d1074 1
a1074 1
		    *bufptr++ = TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1));
a1376 4
    if (PL_parser->preambling != NOLINE) {
	CopLINE_set(PL_curcop, PL_parser->preambling + 1);
	PL_parser->preambling = NOLINE;
    }
d1438 1
a1438 1
	unichar = utf8n_to_uvchr((U8*)s, bufend-s, &retlen, UTF8_CHECK_ONLY);
d1444 1
a1444 1
	    utf8n_to_uvchr((U8*)s, bufend-s, NULL, 0);
a1512 1
#define LEX_NO_INCLINE    0x40000000
a1518 1
    const bool can_incline = !(flags & LEX_NO_INCLINE);
d1520 1
a1520 1
    if (flags & ~(LEX_KEEP_PREVIOUS|LEX_NO_NEXT_CHUNK|LEX_NO_INCLINE))
d1540 5
a1544 7
	    if (can_incline) {
		PL_parser->linestart = s;
		if (s == bufend)
		    need_incline = 1;
		else
		    incline(s);
	    }
a1548 1
	    line_t l;
d1556 1
a1556 2
	    l = CopLINE(PL_curcop);
	    CopLINE(PL_curcop) += PL_parser->herelines + 1;
d1558 1
a1558 1
	    CopLINE_set(PL_curcop, l);
d1563 1
a1563 1
	    if (can_incline && need_incline && PL_parser->rsfp) {
a1578 101

=for apidoc EXMp|bool|validate_proto|SV *name|SV *proto|bool warn

This function performs syntax checking on a prototype, C<proto>.
If C<warn> is true, any illegal characters or mismatched brackets
will trigger illegalproto warnings, declaring that they were
detected in the prototype for C<name>.

The return value is C<true> if this is a valid prototype, and
C<false> if it is not, regardless of whether C<warn> was C<true> or
C<false>.

Note that C<NULL> is a valid C<proto> and will always return C<true>.

=cut

 */

bool
Perl_validate_proto(pTHX_ SV *name, SV *proto, bool warn)
{
    STRLEN len, origlen;
    char *p = proto ? SvPV(proto, len) : NULL;
    bool bad_proto = FALSE;
    bool in_brackets = FALSE;
    bool after_slash = FALSE;
    char greedy_proto = ' ';
    bool proto_after_greedy_proto = FALSE;
    bool must_be_last = FALSE;
    bool underscore = FALSE;
    bool bad_proto_after_underscore = FALSE;

    PERL_ARGS_ASSERT_VALIDATE_PROTO;

    if (!proto)
	return TRUE;

    origlen = len;
    for (; len--; p++) {
	if (!isSPACE(*p)) {
	    if (must_be_last)
		proto_after_greedy_proto = TRUE;
	    if (underscore) {
		if (!strchr(";@@%", *p))
		    bad_proto_after_underscore = TRUE;
		underscore = FALSE;
	    }
	    if (!strchr("$@@%*;[]&\\_+", *p) || *p == '\0') {
		bad_proto = TRUE;
	    }
	    else {
		if (*p == '[')
		    in_brackets = TRUE;
		else if (*p == ']')
		    in_brackets = FALSE;
		else if ((*p == '@@' || *p == '%') &&
		    !after_slash &&
		    !in_brackets ) {
		    must_be_last = TRUE;
		    greedy_proto = *p;
		}
		else if (*p == '_')
		    underscore = TRUE;
	    }
	    if (*p == '\\')
		after_slash = TRUE;
	    else
		after_slash = FALSE;
	}
    }

    if (warn) {
	SV *tmpsv = newSVpvs_flags("", SVs_TEMP);
	p -= origlen;
	p = SvUTF8(proto)
	    ? sv_uni_display(tmpsv, newSVpvn_flags(p, origlen, SVs_TEMP | SVf_UTF8),
	                     origlen, UNI_DISPLAY_ISPRINT)
	    : pv_pretty(tmpsv, p, origlen, 60, NULL, NULL, PERL_PV_ESCAPE_NONASCII);

	if (proto_after_greedy_proto)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Prototype after '%c' for %"SVf" : %s",
			greedy_proto, SVfARG(name), p);
	if (in_brackets)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Missing ']' in prototype for %"SVf" : %s",
			SVfARG(name), p);
	if (bad_proto)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Illegal character in prototype for %"SVf" : %s",
			SVfARG(name), p);
	if (bad_proto_after_underscore)
	    Perl_warner(aTHX_ packWARN(WARN_ILLEGALPROTO),
			"Illegal character after '_' in prototype for %"SVf" : %s",
			SVfARG(name), p);
    }

    return (! (proto_after_greedy_proto || bad_proto) );
}

/*
d1649 11
d1666 14
a1679 4
	    GV * const cfgv = CopFILEGV(PL_curcop);
	    if (cfgv) {
		char smallbuf[128];
		STRLEN tmplen2 = len;
d1688 6
a1693 2
		tmpbuf2[0] = '_';
		tmpbuf2[1] = '<';
d1707 2
a1708 2
			GvHV(gv2) = MUTABLE_HV(SvREFCNT_inc(GvHV(cfgv)));
			GvAV(gv2) = MUTABLE_AV(SvREFCNT_inc(GvAV(cfgv)));
d1710 2
a1711 2
		    else if (GvAV(cfgv)) {
			AV * const av = GvAV(cfgv);
d1726 1
a1733 2
#define skipspace(s) skipspace_flags(s, 0)

d1789 1
d1795 1
d1821 1
a1821 7
	SV * sv;
	if (PL_parser->preambling == NOLINE) sv = newSV_type(SVt_PVMG);
	else {
	    sv = *av_fetch(av, 0, 1);
	    SvUPGRADE(sv, SVt_PVMG);
	}
	if (!SvPOK(sv)) sv_setpvs(sv,"");
d1823 1
a1823 1
	    sv_catsv(sv, orig_sv);
d1825 4
a1828 7
	    sv_catpvn(sv, buf, len);
	if (!SvIOK(sv)) {
	    (void)SvIOK_on(sv);
	    SvIV_set(sv, 0);
	}
	if (PL_parser->preambling == NOLINE)
	    av_store(av, CopLINE(PL_curcop), sv);
d1839 1
a1839 1
S_skipspace_flags(pTHX_ char *s, U32 flags)
d1844 1
a1844 1
    PERL_ARGS_ASSERT_SKIPSPACE_FLAGS;
d1857 1
a1857 1
	lex_read_space(flags | LEX_KEEP_PREVIOUS |
a2060 37
/*
 * S_postderef
 *
 * This subroutine handles postfix deref syntax after the arrow has already
 * been emitted.  @@* $* etc. are emitted as two separate token right here.
 * @@[ @@{ %[ %{ *{ are emitted also as two tokens, but this function emits
 * only the first, leaving yylex to find the next.
 */

static int
S_postderef(pTHX_ int const funny, char const next)
{
    dVAR;
    assert(funny == DOLSHARP || strchr("$@@%&*", funny));
    assert(strchr("*[{", next));
    if (next == '*') {
	PL_expect = XOPERATOR;
	if (PL_lex_state == LEX_INTERPNORMAL && !PL_lex_brackets) {
	    assert('@@' == funny || '$' == funny || DOLSHARP == funny);
	    PL_lex_state = LEX_INTERPEND;
	    start_force(PL_curforce);
	    force_next(POSTJOIN);
	}
	start_force(PL_curforce);
	force_next(next);
	PL_bufptr+=2;
    }
    else {
	if ('@@' == funny && PL_lex_state == LEX_INTERPNORMAL
	 && !PL_lex_brackets)
	    PL_lex_dojoin = 2;
	PL_expect = XOPERATOR;
	PL_bufptr++;
    }
    return funny;
}

d2113 1
a2113 1
S_force_word(pTHX_ char *start, int token, int check_keyword, int allow_pack)
d2124 2
a2125 1
	(allow_pack && *s == ':') )
d2128 1
a2128 5
	if (check_keyword) {
	  char *s2 = PL_tokenbuf;
	  if (allow_pack && len > 6 && strnEQ(s2, "CORE::", 6))
	    s2 += 6, len -= 6;
	  if (keyword(s2, len, 0))
a2129 1
	}
d2264 4
d2269 4
d2372 1
d2377 1
a2377 4
    assert (SvPOK(sv));
    assert (SvLEN(sv));
    assert (!SvIsCOW(sv));
    if (SvTYPE(sv) >= SVt_PVIV && SvIVX(sv) == -1) /* <<'heredoc' */
d2379 5
a2383 2
    s = SvPVX(sv);
    send = SvEND(sv);
d2391 1
a2391 2
	pv = newSVpvn_flags(SvPVX_const(pv), SvCUR(sv),
			    SVs_TEMP | SvUTF8(sv));
d2447 1
a2447 1
    if (op_type == OP_CONST) {
d2460 11
a2501 1
    const bool is_heredoc = PL_multi_close == '<';
d2505 1
a2505 1
    SAVEI8(PL_lex_dojoin);
d2516 1
a2516 8
    if (is_heredoc)
    {
	SAVECOPLINE(PL_curcop);
	SAVEI32(PL_multi_end);
	SAVEI32(PL_parser->herelines);
	PL_parser->herelines = 0;
    }
    SAVEI8(PL_multi_close);
a2528 1
    SAVEI32(PL_copline);
d2559 1
a2559 3
    if (is_heredoc)
	CopLINE_set(PL_curcop, (line_t)PL_multi_start);
    PL_copline = NOLINE;
d2603 1
a2603 2
    if (PL_lex_repl) {
	assert (PL_lex_inwhat == OP_SUBST || PL_lex_inwhat == OP_TRANS);
a2627 6
	if (SvTYPE(PL_linestr) >= SVt_PVNV) {
	    CopLINE(PL_curcop) +=
		((XPVNV*)SvANY(PL_linestr))->xnv_u.xpad_cop_seq.xlow
		 + PL_parser->herelines;
	    PL_parser->herelines = 0;
	}
a2630 1
	const line_t l = CopLINE(PL_curcop);
a2645 2
	if (PL_multi_close == '<')
	    PL_parser->herelines += l - PL_multi_end;
d2679 1
a2679 1
        utf8n_to_uvchr(first_bad_char_loc,
d2705 2
a2706 2
    if (cvp && (cv = *cvp) && SvROK(cv) && (rv = SvRV(cv),
        SvTYPE(rv) == SVt_PVCV) && ((stash = CvSTASH(rv)) != NULL))
d2709 1
a2709 2
        if (HvNAMELEN(stash) == sizeof("_charnames")-1
         && strEQ(name, "_charnames")) {
d2731 2
a2732 4
	    if (*s == ' ' && *(s-1) == ' ' && ckWARN_d(WARN_DEPRECATED)) {
                Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                           "A sequence of multiple spaces in a charnames "
                           "alias definition is deprecated");
d2736 2
a2737 4
        if (*(s-1) == ' ' && ckWARN_d(WARN_DEPRECATED)) {
            Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                        "Trailing white-space in a charnames alias "
                        "definition is deprecated");
d2750 1
a2750 1
            if (! isALPHAU(TWO_BYTE_UTF8_TO_NATIVE(*s, *(s+1)))) {
d2774 2
a2775 5
                if (*s == ' ' && *(s-1) == ' '
                 && ckWARN_d(WARN_DEPRECATED)) {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                               "A sequence of multiple spaces in a charnam"
                               "es alias definition is deprecated");
d2780 2
a2781 1
                if (! isCHARNAME_CONT(TWO_BYTE_UTF8_TO_NATIVE(*s, *(s+1))))
d2801 2
a2802 4
        if (*(s-1) == ' ' && ckWARN_d(WARN_DEPRECATED)) {
            Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                       "Trailing white-space in a charnames alias "
                       "definition is deprecated");
d2813 1
a2813 1
            utf8n_to_uvchr(first_bad_char_loc,
d3014 1
a3014 1
		    *c = (char) ILLEGAL_UTF8_BYTE;
d3068 10
a3077 6
		    ((isLOWER_A(min) && isLOWER_A(max)) ||
		     (isUPPER_A(min) && isUPPER_A(max))))
                {
                    for (i = min; i <= max; i++) {
                        if (isALPHA_A(i))
                            *d++ = i;
d3085 7
a3091 1
                            append_utf8_from_native_byte(i, &d);
d3101 1
a3101 1
                        *d++ = (char) ILLEGAL_UTF8_BYTE;
d3126 1
a3126 1
		    *d++ = (char) ILLEGAL_UTF8_BYTE;	/* use illegal utf8 byte--see pmtrans */
d3169 1
a3169 1
		    *d++ = *s++;
d3180 1
a3180 1
	else if (*s == '#' && PL_lex_inpat && !in_charclass &&
d3182 15
a3196 2
	    while (s+1 < send && *s != '\n')
		*d++ = *s++;
a3242 1
		/* diag_listed_as: \%d better written as $%d */
d3271 1
a3271 1
		*d++ = '\\';
d3300 1
a3300 1
		    uv = grok_oct(s, &len, &flags, NULL);
d3352 3
a3354 2
		/* Here uv is the ordinal of the next character being added */
		if (!UVCHR_IS_INVARIANT(uv)) {
d3372 1
a3372 1
		        d = (char*)uvchr_to_utf8((U8*)d, uv);
d3405 10
d3441 1
a3441 1
			yyerror("Missing right brace on \\N{} or unescaped left brace after \\N");
d3502 1
a3502 1
                        /* Add the (Unicode) code point to the output. */
d3504 1
a3504 1
			    *d++ = (char) LATIN1_TO_NATIVE(uv);
d3506 1
a3506 3
			else {
                            d = (char*) uvoffuni_to_utf8_flags((U8*)d, uv, 0);
                        }
d3566 1
a3566 1
                                U32 uv = utf8n_to_uvchr((U8 *) str,
d3571 4
a3574 1
                                 * the boiler plate before it. */
d3577 2
a3578 2
                                                "\\N{U+%X",
                                                (unsigned int) uv);
d3593 1
a3593 1
                                    U32 uv = utf8n_to_uvchr((U8 *) str,
d3599 3
a3601 3
                                                    sizeof(hex_string),
                                                    ".%X",
                                                    (unsigned int) uv);
d3657 1
a3657 1
		    *d++ = grok_bslash_c(*s++, 1);
d3666 1
a3666 1
		*d++ = '\b';
d3669 1
a3669 1
		*d++ = '\n';
d3672 1
a3672 1
		*d++ = '\r';
d3675 1
a3675 1
		*d++ = '\f';
d3678 1
a3678 1
		*d++ = '\t';
d3681 1
a3681 1
		*d++ = ASCII_TO_NATIVE('\033');
d3684 1
a3684 1
		*d++ = '\a';
d3699 1
a3699 1
	if (! NATIVE_BYTE_IS_INVARIANT((U8)(*s)) && (this_utf8 || has_utf8)) {
d3710 2
a3711 4
	    const UV nextuv   = (this_utf8)
                                ? utf8n_to_uvchr((U8*)s, send - s, &len, 0)
                                : (UV) ((U8) *s);
	    const STRLEN need = UNISKIP(nextuv);
d3738 1
a3738 1
	    *d++ = *s++;
d3769 1
a3769 6
    if (s > start) {
	char *s2 = start;
	for (; s2 < s; s2++) {
	    if (*s2 == '\n')
		COPLINE_INC_WITH_HERELINES;
	}
a3808 1
 * ->$* ->$#* ->@@* ->@@[ ->@@{ return TRUE if postderef_qq is enabled
a3833 5
    if (*s == '-' && s[1] == '>'
     && FEATURE_POSTDEREF_QQ_IS_ENABLED
     && ( (s[2] == '$' && (s[3] == '*' || (s[3] == '#' && s[4] == '*')))
	||(s[2] == '@@' && strchr("*[{",s[3])) ))
	return TRUE;
d3886 1
a3886 4
                    char *tmp = PL_bufend;
                    PL_bufend = (char*)send;
                    scan_ident(s, tmpbuf, sizeof tmpbuf, FALSE);
                    PL_bufend = tmp;
d3994 7
a4000 7
	const char *proto = CvPROTO(cv);
	if (proto) {
	    while (*proto && (isSPACE(*proto) || *proto == ';'))
		proto++;
	    if (*proto == '*')
		return 0;
	}
d4002 5
a4022 7

    s = scan_word(s, tmpbuf, sizeof tmpbuf, TRUE, &len);
    /* start is the beginning of the possible filehandle/object,
     * and s is the end of it
     * tmpbuf is a copy of it (but with single quotes as double colons)
     */

d4186 8
a4193 1
    unsigned int correct_length = maxlen < 0 ?  PERL_INT_MAX : maxlen;
d4327 25
d4553 1
a4553 1
	    s = force_word(s,WORD,FALSE,TRUE);
d4558 1
a4558 1
	s = force_word(s,WORD,FALSE,TRUE);
d4567 1
a4567 1
	  "ATTRTERM", "TERMBLOCK", "POSTDEREF", "TERMORDORDOR"
a4580 14
static void
S_check_scalar_slice(pTHX_ char *s)
{
    s++;
    while (*s == ' ' || *s == '\t') s++;
    if (*s == 'q' && s[1] == 'w'
     && !isWORDCHAR_lazy_if(s+2,UTF))
	return;
    while (*s && (isWORDCHAR_lazy_if(s,UTF) || strchr(" \t$#+-'\"", *s)))
	s += UTF ? UTF8SKIP(s) : 1;
    if (*s == '}' || *s == ']')
	pl_yylval.ival = OPpSLICEWARNING;
}

d4626 3
a4636 1
    const bool saw_infix_sigil = cBOOL(PL_parser->saw_infix_sigil);
d4658 3
a4660 2
    case LEX_NORMAL:
    case LEX_INTERPNORMAL:
d4662 1
a4919 1
	    const U8 dojoin_was = PL_lex_dojoin;
d4930 1
a4930 1
	    return REPORT(dojoin_was == 1 ? ')' : POSTJOIN);
a5035 2
    /* We really do *not* want PL_linestr ever becoming a COW. */
    assert (!SvIsCOW(PL_linestr));
a5038 1
    PL_parser->saw_infix_sigil = 0;
d5054 1
a5054 1
        const char *c = UTF ? sv_uni_display(dsv, newSVpvn_flags(s,
d5057 1
a5057 1
                                            10, UNI_DISPLAY_ISPRINT)
d5064 6
a5069 4
        }
        Perl_croak(aTHX_  "Unrecognized character %s; marked by <-- HERE after %"UTF8f"<-- HERE near column %d", c,
                          UTF8fARG(UTF, (s - d), d),
                         (int) len + 1);
a5117 1
		PL_parser->preambling = CopLINE(PL_curcop);
d5197 1
a5197 1
		      *(U8*)s == BOM_UTF8_FIRST_BYTE ||
d5509 7
a5515 11
#endif
		    if (PL_madskills) d = s;
		    while (s < PL_bufend && *s != '\n')
			s++;
		    if (s < PL_bufend)
		    {
			s++;
			if (s < PL_bufend)
			    incline(s);
		    }
		    else if (s > PL_bufend) /* Found by Ilya: feed random input to Perl. */
a5516 1
#ifdef PERL_MAD
d5524 1
a5524 1
			sv_catpvn(PL_thiswhite, d, s - d);
d5526 4
d5531 3
d5550 1
a5550 1
		s = force_word(PL_bufptr,WORD,FALSE,FALSE);
d5554 1
a5592 1
                PL_last_uni = PL_oldbufptr;
a5620 14
		if (FEATURE_POSTDEREF_IS_ENABLED && (
		    ((*s == '$' || *s == '&') && s[1] == '*')
		  ||(*s == '$' && s[1] == '#' && s[2] == '*')
		  ||((*s == '@@' || *s == '%') && strchr("*[{", s[1]))
		  ||(*s == '*' && (s[1] == '*' || s[1] == '{'))
		 ))
		{
		    Perl_ck_warner_d(aTHX_
			packWARN(WARN_EXPERIMENTAL__POSTDEREF),
			"Postfix dereference is experimental"
		    );
		    PL_expect = XPOSTDEREF;
		    TOKEN(ARROW);
		}
d5622 1
a5622 1
		    s = force_word(s,METHOD,FALSE,TRUE);
a5670 1
	if (PL_expect == XPOSTDEREF) POSTDEREF('*');
d5672 1
a5672 1
	    s = scan_ident(s, PL_tokenbuf, sizeof PL_tokenbuf, TRUE);
a5693 1
	PL_parser->saw_infix_sigil = 1;
a5696 1
    {
a5701 1
	    PL_parser->saw_infix_sigil = 1;
a5703 1
	else if (PL_expect == XPOSTDEREF) POSTDEREF('%');
d5705 1
a5705 1
	s = scan_ident(s, PL_tokenbuf + 1,
a5706 1
	pl_yylval.ival = 0;
a5709 4
	if ((PL_expect != XREF || PL_oldoldbufptr == PL_last_lop) && intuit_more(s)) {
	    if (*s == '[')
		PL_tokenbuf[0] = '@@';
	}
d5713 1
a5713 1
    }
d5801 1
a5801 2
		    d = scan_str(d,TRUE,TRUE,FALSE,FALSE,NULL);
		    COPLINE_SET_FROM_MULTI_END;
d5868 4
a5871 4
		if (*s != ';' && *s != '}' &&
		    !(PL_expect == XOPERATOR
			? (*s == '=' ||  *s == ')')
			: (*s == '{' ||  *s == '('))) {
d5875 1
a5875 1
		    if (PL_expect == XOPERATOR && !attrs) {
a5942 1
	    /* diag_listed_as: Unmatched right %s bracket */
d5985 1
a5985 1
		    s = force_word(s + minus, WORD, FALSE, TRUE);
a6120 1
	    /* diag_listed_as: Unmatched right %s bracket */
a6171 1
	if (PL_expect == XPOSTDEREF) POSTDEREF('&');
a6194 1
	    PL_parser->saw_infix_sigil = 1;
d6199 1
a6199 1
	s = scan_ident(s - 1, PL_tokenbuf + 1,
a6428 7
	else if (PL_expect == XPOSTDEREF) {
	    if (s[1] == '#') {
		s++;
		POSTDEREF(DOLSHARP);
	    }
	    POSTDEREF('$');
	}
d6432 1
a6432 1
	    s = scan_ident(s + 1, PL_tokenbuf + 1,
d6444 1
a6444 1
	s = scan_ident(s, PL_tokenbuf + 1,
d6498 3
a6500 2
					"You need to quote \"%"UTF8f"\"",
					 UTF8fARG(UTF, len, tmpbuf));
a6562 1
	else if (PL_expect == XPOSTDEREF) POSTDEREF('@@');
d6564 1
a6564 2
	s = scan_ident(s, PL_tokenbuf + 1, sizeof PL_tokenbuf - 1, FALSE);
	pl_yylval.ival = 0;
d6577 14
a6590 1
		    S_check_scalar_slice(aTHX_ s);
d6706 1
a6706 4
	s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
	if (!s)
	    missingterm(NULL);
	COPLINE_SET_FROM_MULTI_END;
d6715 2
d6721 2
a6722 8
	s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
	DEBUG_T( {
	    if (s)
		printbuf("### Saw string before %s\n", s);
	    else
		PerlIO_printf(Perl_debug_log,
			     "### Saw unterminated string\n");
	} );
a6740 2
	if (pl_yylval.ival == OP_CONST)
	    COPLINE_SET_FROM_MULTI_END;
d6744 1
a6744 1
	s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d6750 1
a6750 1
	pl_yylval.ival = OP_BACKTICK;
d6755 1
a6755 2
	if (PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
	 && isDIGIT(*s))
d6852 1
a6852 2
	if (!anydelim && *s == ':' && s[1] == ':') {
	    if (strEQ(PL_tokenbuf, "CORE")) goto case_KEY_CORE;
a6853 1
	}
a6860 1
	  fat_arrow:
d6951 1
a6951 2
					    (UTF ? SVf_UTF8 : 0)|GV_NOTQUAL,
					    SVt_PVCV)) &&
d6961 3
a6963 8
					  len, FALSE)) &&
		    (gv = *gvp) && (
			isGV_with_GP(gv)
			    ? GvCVu(gv) && GvIMPORTED_CV(gv)
			    :   SvPCS_IMPORTED(gv)
			     && (gv_init(gv, PL_globalstash, PL_tokenbuf,
					 len, 0), 1)
		   ))
d6986 1
a6986 1
		if (hgv && tmp != KEY_x)	/* never ambiguous */
a6993 15
	if (tmp && tmp != KEY___DATA__ && tmp != KEY___END__
	 && (!anydelim || *s != '#')) {
	    /* no override, and not s### either; skipspace is safe here
	     * check for => on following line */
	    bool arrow;
	    STRLEN bufoff = PL_bufptr - SvPVX(PL_linestr);
	    STRLEN   soff = s         - SvPVX(PL_linestr);
	    s = skipspace_flags(s, LEX_NO_INCLINE);
	    arrow = *s == '=' && s[1] == '>';
	    PL_bufptr = SvPVX(PL_linestr) + bufoff;
	    s         = SvPVX(PL_linestr) +   soff;
	    if (arrow)
		goto fat_arrow;
	}

d7032 3
a7034 2
			Perl_croak(aTHX_ "Bad name after %"UTF8f"%s",
				UTF8fARG(UTF, len, PL_tokenbuf),
d7061 3
a7063 2
		  	  "Bareword \"%"UTF8f"\" refers to nonexistent package",
			   UTF8fARG(UTF, len, PL_tokenbuf));
a7178 3
		    /* This is our own scalar, created a few lines above,
		       so this is safe. */
		    SvREADONLY_off(cSVOPx(pl_yylval.opval)->op_sv);
a7181 1
		    SvREADONLY_on(cSVOPx(pl_yylval.opval)->op_sv);
d7192 1
a7192 1
			if (*d == ')' && (sv = cv_const_sv_or_av(cv))) {
d7249 1
a7249 1
			const STRLEN l = len ? len : strlen(PL_tokenbuf);
d7251 2
a7252 3
			    "Ambiguous use of -%"UTF8f" resolved as -&%"UTF8f"()",
			     UTF8fARG(UTF, l, PL_tokenbuf),
			     UTF8fARG(UTF, l, PL_tokenbuf));
d7255 1
a7255 1
		    if ((sv = cv_const_sv_or_av(cv))) {
d7260 2
a7261 8
			if (SvTYPE(sv) == SVt_PVAV)
			    pl_yylval.opval = newUNOP(OP_RV2AV, OPf_PARENS,
						      pl_yylval.opval);
			else {
			    pl_yylval.opval->op_private = 0;
			    pl_yylval.opval->op_folded = 1;
			    pl_yylval.opval->op_flags |= OPf_SPECIAL;
			}
a7280 1
			proto = S_strip_spaces(aTHX_ proto, &protolen);
a7416 3
                            {
                                /* PL_warn_reserved is constant */
                                GCC_DIAG_IGNORE(-Wformat-nonliteral);
a7418 2
                                GCC_DIAG_RESTORE;
                            }
d7425 1
a7425 2
		if ((lastchar == '*' || lastchar == '%' || lastchar == '&')
		 && saw_infix_sigil) {
d7427 4
a7430 4
				     "Operator or semicolon missing before %c%"UTF8f,
				     lastchar,
				     UTF8fARG(UTF, strlen(PL_tokenbuf),
					      PL_tokenbuf));
d7461 15
a7475 6
		HV * const stash = PL_tokenbuf[2] == 'D' && PL_curstash
					? PL_curstash
					: PL_defstash;
		gv = (GV *)*hv_fetchs(stash, "DATA", 1);
		if (!isGV(gv))
		    gv_init(gv,stash,"DATA",4,0);
d7524 1
d7575 2
a7576 2
	case_KEY_CORE:
	    {
d7590 3
a7592 2
		    Perl_croak(aTHX_ "CORE::%"UTF8f" is not a keyword",
				      UTF8fARG(UTF, len, PL_tokenbuf));
d7601 1
d7704 1
a7704 2
		if (len && (len != 4 || strNE(PL_tokenbuf+1, "CORE"))
		 && !keyword(PL_tokenbuf + 1, len, 0)) {
d7745 1
a7745 1
	    s = force_word(s,WORD,TRUE,FALSE);
a7831 1
                /* skip optional package name, as in "for my abc $x (..)" */
d7833 2
a7834 1
		    p = scan_word(p, PL_tokenbuf, sizeof PL_tokenbuf, TRUE, &len);
d7878 1
a7878 1
	    s = force_word(s,WORD,TRUE,FALSE);
d7971 1
a7971 1
	     orig_keyword==KEY_glob ? -OP_GLOB : OP_GLOB,
d8004 1
a8004 1
	    s = force_word(s,WORD,TRUE,FALSE);
d8112 1
a8112 1
	    s = force_word(s,WORD,TRUE,FALSE);
d8148 2
d8151 2
a8152 2
		       "Precedence problem: open %"UTF8f" should be open(%"UTF8f")",
			UTF8fARG(UTF, d-s, s), UTF8fARG(UTF, d-s, s));
d8196 1
a8196 1
	    s = force_word(s,WORD,FALSE,TRUE);
d8206 1
a8206 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
a8208 1
	    COPLINE_SET_FROM_MULTI_END;
d8217 1
a8217 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
a8219 1
	    COPLINE_SET_FROM_MULTI_END;
d8267 1
a8267 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d8280 1
a8280 1
	    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d8283 1
a8283 1
	    pl_yylval.ival = OP_BACKTICK;
d8299 1
a8299 1
		s = force_word(s,WORD,TRUE,TRUE);
d8324 1
a8324 1
	    s = force_word(s,WORD,TRUE,FALSE);
d8465 1
a8465 1
	    s = force_word(s,WORD,TRUE,TRUE);
d8497 1
a8500 3
#ifndef PERL_MAD
                SV *format_name = NULL;
#endif
d8527 2
a8533 3
#else
                    if (key == KEY_format)
			format_name = S_newSV_maybe_utf8(aTHX_ s, d - s);
d8580 1
d8582 3
a8584 7
		    if (format_name) {
                        start_force(PL_curforce);
                        NEXTVAL_NEXTTOKE.opval
                            = (OP*)newSVOP(OP_CONST,0, format_name);
                        NEXTVAL_NEXTTOKE.opval->op_private |= OPpCONST_BARE;
                        force_next(WORD);
                    }
d8590 13
a8602 3
		if (*s == '(' && !FEATURE_SIGNATURES_IS_ENABLED) {
		    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
		    COPLINE_SET_FROM_MULTI_END;
d8605 58
a8662 1
		    (void)validate_proto(PL_subname, PL_lex_stuff, ckWARN(WARN_ILLEGALPROTO));
d8686 1
a8686 1
		else if ((*s != '{' && *s != '(') && key == KEY_sub) {
d8850 11
a8860 3
            /* Make sure $^L is defined. 0x0C is CTRL-L on ASCII platforms, and
             * we use the same number on EBCDIC */
	    gv_fetchpvs("\x0C", GV_ADD|GV_NOTQUAL, SVt_PV);
d8881 3
d8933 1
a8933 3
            if (has_colon) {
                /* PL_no_myglob is constant */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
a8936 2
                GCC_DIAG_RESTORE;
            }
d8999 3
a9001 3
			"Possible unintended interpolation of %"UTF8f
			" in string",
			UTF8fARG(UTF, tokenbuf_len, PL_tokenbuf));
d9128 1
a9128 1
            assert(sp == PL_stack_sp);
d9289 1
a9289 1
S_scan_ident(pTHX_ char *s, char *dest, STRLEN destlen, I32 ck_uni)
d9292 1
a9292 2
    I32 herelines = PL_parser->herelines;
    SSize_t bracket = -1;
a9296 1
    I32 orig_copline = 0, tmp_copline = 0;
a9314 2
        /* Either a digit variable, or parse_ident() found an identifier
           (anything valid as a bareword), so job done and return.  */
a9325 3
        /* Dereferencing a value in a scalar variable.
           The alternatives are different syntaxes for a scalar variable.
           Using ' as a leading package separator isn't allowed. :: is.   */
a9327 1
    /* Handle the opening { of @@{...}, &{...}, *{...}, %{...}, ${...}  */
d9329 1
a9329 1
	bracket = s - SvPVX(PL_linestr);
d9331 2
a9332 4
	orig_copline = CopLINE(PL_curcop);
        if (s < PL_bufend && isSPACE(*s)) {
            s = PEEKSPACE(s);
        }
d9335 6
a9340 18
/* Is the byte 'd' a legal single character identifier name?  'u' is true
 * iff Unicode semantics are to be used.  The legal ones are any of:
 *  a) ASCII digits
 *  b) ASCII punctuation
 *  c) When not under Unicode rules, any upper Latin1 character
 *  d) \c?, \c\, \c^, \c_, and \cA..\cZ, minus the ones that have traditionally
 *     been matched by \s on ASCII platforms.  That is: \c?, plus 1-32, minus
 *     the \s ones. */
#define VALID_LEN_ONE_IDENT(d, u) (isPUNCT_A((U8)(d))                       \
                                   || isDIGIT_A((U8)(d))                    \
                                   || (!(u) && !isASCII((U8)(d)))           \
                                   || ((((U8)(d)) < 32)                     \
                                       && (((((U8)(d)) >= 14)               \
                                           || (((U8)(d)) <= 8 && (d) != 0) \
                                           || (((U8)(d)) == 13))))          \
                                   || (((U8)(d)) == toCTRL('?')))
    if (s < PL_bufend
        && (isIDFIRST_lazy_if(s, is_utf8) || VALID_LEN_ONE_IDENT(*s, is_utf8)))
a9341 4
        if ( isCNTRL_A((U8)*s) ) {
            deprecate("literal control characters in variable names");
        }
        
a9353 1
    /* Convert $^F, ${^F} and the ^F of ${^FOO} to control characters */
d9358 1
a9358 4
    /* Warn about ambiguous code after unary operators if {...} notation isn't
       used.  There's no difference in ambiguity; it's merely a heuristic
       about when not to warn.  */
    else if (ck_uni && bracket == -1)
d9360 1
a9360 2
    if (bracket != -1) {
        /* If we were processing {...} notation then...  */
a9361 3
            /* if it starts as a valid identifier, assume that it is one.
               (the later check for } being at the expected point will trap
               cases where this doesn't pan out.)  */
d9365 2
a9366 4
            tmp_copline = CopLINE(PL_curcop);
            if (s < PL_bufend && isSPACE(*s)) {
                s = PEEKSPACE(s);
            }
a9367 1
                /* ${foo[0]} and ${foo{bar}} notation.  */
a9371 2
                    orig_copline = CopLINE(PL_curcop);
                    CopLINE_set(PL_curcop, tmp_copline);
a9375 1
                    CopLINE_set(PL_curcop, orig_copline);
d9385 1
a9385 1
	else if (! isPRINT(*d) /* isCNTRL(d), plus all non-ASCII */
d9397 3
a9399 8
        if ( !tmp_copline )
            tmp_copline = CopLINE(PL_curcop);
        if (s < PL_bufend && isSPACE(*s)) {
            s = PEEKSPACE(s);
        }
	    
        /* Expect to find a closing } after consuming any trailing whitespace.
         */
a9414 2
                    orig_copline = CopLINE(PL_curcop);
                    CopLINE_set(PL_curcop, tmp_copline);
a9417 1
                    CopLINE_set(PL_curcop, orig_copline);
d9422 1
a9422 5
            /* Didn't find the closing } at the point we expected, so restore
               state such that the next thing to process is the opening { and */
	    s = SvPVX(PL_linestr) + bracket; /* let the parser handle it */
            CopLINE_set(PL_curcop, orig_copline);
            PL_parser->herelines = herelines;
a9515 1
  /* diag_listed_as: Regexp modifier "/%c" may appear a maximum of twice */
d9543 1
a9543 1
                       TRUE /* look for escaped bracketed metas */, NULL);
a9624 1
    line_t first_line;
a9629 1
    char *t;
d9636 1
a9636 1
                 TRUE /* look for escaped bracketed metas */, &t);
d9641 2
a9642 1
    s = t;
d9654 1
a9654 2
    first_line = CopLINE(PL_curcop);
    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
a9715 6
    if (CopLINE(PL_curcop) != first_line) {
	sv_upgrade(PL_sublex_info.repl, SVt_PVNV);
	((XPVNV*)SvANY(PL_sublex_info.repl))->xnv_u.xpad_cop_seq.xlow =
	    CopLINE(PL_curcop) - first_line;
	CopLINE_set(PL_curcop, first_line);
    }
a9734 1
    char *t;
d9740 1
a9740 1
    s = scan_str(start,!!PL_madskills,FALSE,FALSE,FALSE,&t);
d9744 2
a9745 1
    s = t;
d9756 1
a9756 1
    s = scan_str(s,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
a9851 1
    const line_t origline = CopLINE(PL_curcop);
d9953 1
a9953 1
    PL_multi_start = origline + 1 + PL_parser->herelines;
d9979 1
a9979 1
	       fer ends with "\n;", so the while condition above will have
d10000 1
a10000 1
		++PL_parser->herelines;
d10017 1
a10017 1
	PL_parser->herelines++;
d10075 1
a10075 1
		    origline + 1 + PL_parser->herelines);
d10081 1
a10081 1
	CopLINE_set(PL_curcop, origline);
d10083 1
a10083 2
            s = lex_grow_linestr(SvLEN(PL_linestr) + 3);
            /* ^That should be enough to avoid this needing to grow:  */
a10084 2
            assert(s == SvPVX(PL_linestr));
            PL_bufend = SvEND(PL_linestr);
d10090 1
a10090 1
	PL_parser->herelines++;
d10120 1
a10120 1
    PL_multi_end = origline + PL_parser->herelines;
d10136 1
a10136 1
    CopLINE_set(PL_curcop, origline);
d10205 1
a10205 1
	s = scan_str(start,!!PL_madskills,FALSE,FALSE,FALSE,NULL);
d10213 1
d10223 6
a10228 1
	if ((gv_readline = gv_override("readline",8)))
d10302 5
a10306 14
   takes:
	start			position in buffer
	keep_quoted		preserve \ on the embedded delimiter(s)
	keep_delims		preserve the delimiters around the string
	re_reparse		compiling a run-time /(?{})/:
				   collapse // to /,  and skip encoding src
	deprecate_escaped_meta	issue a deprecation warning for cer-
				tain paired metacharacters that appear
				escaped within it
	delimp			if non-null, this is set to the position of
				the closing delimiter, or just after it if
				the closing and opening delimiters differ
				(i.e., the opening delimiter of a substitu-
				tion replacement)
d10348 3
a10350 1
		 bool deprecate_escaped_meta, char **delimp
a10365 1
    line_t herelines;
a10404 1
    herelines = PL_parser->herelines;
d10418 2
a10419 2
            || PL_multi_open == '<'
            || ! ckWARN_d(WARN_DEPRECATED)))
d10450 2
a10451 43
		const char *ns;
		char *svlast;

		if (SvIsCOW(PL_linestr)) {
		    STRLEN bufend_pos, bufptr_pos, oldbufptr_pos;
		    STRLEN oldoldbufptr_pos, linestart_pos, last_uni_pos;
		    STRLEN last_lop_pos, re_eval_start_pos, s_pos;
		    char *buf = SvPVX(PL_linestr);
		    bufend_pos = PL_parser->bufend - buf;
		    bufptr_pos = PL_parser->bufptr - buf;
		    oldbufptr_pos = PL_parser->oldbufptr - buf;
		    oldoldbufptr_pos = PL_parser->oldoldbufptr - buf;
		    linestart_pos = PL_parser->linestart - buf;
		    last_uni_pos = PL_parser->last_uni
			? PL_parser->last_uni - buf
			: 0;
		    last_lop_pos = PL_parser->last_lop
			? PL_parser->last_lop - buf
			: 0;
		    re_eval_start_pos =
			PL_parser->lex_shared->re_eval_start ?
                            PL_parser->lex_shared->re_eval_start - buf : 0;
		    s_pos = s - buf;

		    sv_force_normal(PL_linestr);

		    buf = SvPVX(PL_linestr);
		    PL_parser->bufend = buf + bufend_pos;
		    PL_parser->bufptr = buf + bufptr_pos;
		    PL_parser->oldbufptr = buf + oldbufptr_pos;
		    PL_parser->oldoldbufptr = buf + oldoldbufptr_pos;
		    PL_parser->linestart = buf + linestart_pos;
		    if (PL_parser->last_uni)
			PL_parser->last_uni = buf + last_uni_pos;
		    if (PL_parser->last_lop)
			PL_parser->last_lop = buf + last_lop_pos;
		    if (PL_parser->lex_shared->re_eval_start)
		        PL_parser->lex_shared->re_eval_start  =
			    buf + re_eval_start_pos;
		    s = buf + s_pos;
		}
		ns = SvPVX_const(PL_linestr) + offset;
		svlast = SvEND(sv) - 1;
d10572 5
a10576 6
                         * appearing in a quantifier or in things like '\p{'
                         * (but '\\p{' isn't meta).  They also aren't meta
                         * unless there is a matching closed, escaped char
                         * later on within the string.  If 's' points to an
                         * open, set a flag; if to a close, test that flag, and
                         * raise a warning if it was set */
d10583 7
a10589 2
                                     /* Look for a closing '\}' */
                                else if (regcurly(s, TRUE)) {
a10591 17
                                     /* Look for e.g.  '\x{' */
                                else if (s - start > 2
                                         && _generic_isCC(*(s-2),
                                             _CC_BACKSLASH_FOO_LBRACE_IS_META))
                                { /* Exclude '\\x', '\\\\x', etc. */
                                    char *lookbehind = s - 4;
                                    bool is_meta = TRUE;
                                    while (lookbehind >= start
                                           && *lookbehind == '\\')
                                    {
                                        is_meta = ! is_meta;
                                        lookbehind--;
                                    }
                                    if (is_meta) {
                                        escaped_open = s;
                                    }
                                }
a10703 2
    CopLINE_set(PL_curcop, PL_multi_start);
    PL_parser->herelines = herelines;
a10718 1
    if (delimp) *delimp = PL_multi_open == PL_multi_close ? s-termlen : s;
a11083 1
            STORE_NUMERIC_LOCAL_SET_STANDARD();
a11086 1
            RESTORE_NUMERIC_LOCAL();
a11213 10
	    const char *s2 = s;
	    while (*s2 == '\r' || *s2 == ' ' || *s2 == '\t' || *s2 == '\f'
		|| *s2 == 013)
		s2++;
	    if (*s2 == '{') {
		start_force(PL_curforce);
		PL_expect = XTERMBLOCK;
		NEXTVAL_NEXTTOKE.ival = 0;
		force_next(DO);
	    }
d11270 3
d11371 1
a11371 4
        OutCopFILE(PL_curcop),
        (IV)(PL_parser->preambling == NOLINE
               ? CopLINE(PL_curcop)
               : PL_parser->preambling));
d11373 3
a11375 2
	Perl_sv_catpvf(aTHX_ msg, "near \"%"UTF8f"\"\n",
			     UTF8fARG(UTF, contlen, context));
d11402 3
d11447 6
a11452 8
    case BOM_UTF8_FIRST_BYTE: {
        const STRLEN len = sizeof(BOM_UTF8_TAIL) - 1; /* Exclude trailing NUL */
        if (slen > len && memEQ(s+1, BOM_UTF8_TAIL, len)) {
            if (DEBUG_p_TEST || DEBUG_T_TEST) PerlIO_printf(Perl_debug_log, "UTF-8 script encoding (BOM)\n");
            s += len + 1;                      /* UTF-8 */
        }
        break;
    }
d11475 8
d11727 1
a11727 1
	    if (!UVCHR_IS_INVARIANT(rev))
a12151 200
}

#define lex_token_boundary() S_lex_token_boundary(aTHX)
static void
S_lex_token_boundary(pTHX)
{
    PL_oldoldbufptr = PL_oldbufptr;
    PL_oldbufptr = PL_bufptr;
}

#define parse_opt_lexvar() S_parse_opt_lexvar(aTHX)
static OP *
S_parse_opt_lexvar(pTHX)
{
    I32 sigil, c;
    char *s, *d;
    OP *var;
    lex_token_boundary();
    sigil = lex_read_unichar(0);
    if (lex_peek_unichar(0) == '#') {
	qerror(Perl_mess(aTHX_ "Parse error"));
	return NULL;
    }
    lex_read_space(0);
    c = lex_peek_unichar(0);
    if (c == -1 || !(UTF ? isIDFIRST_uni(c) : isIDFIRST_A(c)))
	return NULL;
    s = PL_bufptr;
    d = PL_tokenbuf + 1;
    PL_tokenbuf[0] = (char)sigil;
    parse_ident(&s, &d, PL_tokenbuf + sizeof(PL_tokenbuf) - 1, 0, cBOOL(UTF));
    PL_bufptr = s;
    if (d == PL_tokenbuf+1)
	return NULL;
    *d = 0;
    var = newOP(sigil == '$' ? OP_PADSV : sigil == '@@' ? OP_PADAV : OP_PADHV,
		OPf_MOD | (OPpLVAL_INTRO<<8));
    var->op_targ = allocmy(PL_tokenbuf, d - PL_tokenbuf, UTF ? SVf_UTF8 : 0);
    return var;
}

OP *
Perl_parse_subsignature(pTHX)
{
    I32 c;
    int prev_type = 0, pos = 0, min_arity = 0, max_arity = 0;
    OP *initops = NULL;
    lex_read_space(0);
    c = lex_peek_unichar(0);
    while (c != /*(*/')') {
	switch (c) {
	    case '$': {
		OP *var, *expr;
		if (prev_type == 2)
		    qerror(Perl_mess(aTHX_ "Slurpy parameter not last"));
		var = parse_opt_lexvar();
		expr = var ?
		    newBINOP(OP_AELEM, 0,
			ref(newUNOP(OP_RV2AV, 0, newGVOP(OP_GV, 0, PL_defgv)),
			    OP_RV2AV),
			newSVOP(OP_CONST, 0, newSViv(pos))) :
		    NULL;
		lex_read_space(0);
		c = lex_peek_unichar(0);
		if (c == '=') {
		    lex_token_boundary();
		    lex_read_unichar(0);
		    lex_read_space(0);
		    c = lex_peek_unichar(0);
		    if (c == ',' || c == /*(*/')') {
			if (var)
			    qerror(Perl_mess(aTHX_ "Optional parameter "
				    "lacks default expression"));
		    } else {
			OP *defexpr = parse_termexpr(0);
			if (defexpr->op_type == OP_UNDEF &&
				!(defexpr->op_flags & OPf_KIDS)) {
			    op_free(defexpr);
			} else {
			    OP *ifop = 
				newBINOP(OP_GE, 0,
				    scalar(newUNOP(OP_RV2AV, 0,
					    newGVOP(OP_GV, 0, PL_defgv))),
				    newSVOP(OP_CONST, 0, newSViv(pos+1)));
			    expr = var ?
				newCONDOP(0, ifop, expr, defexpr) :
				newLOGOP(OP_OR, 0, ifop, defexpr);
			}
		    }
		    prev_type = 1;
		} else {
		    if (prev_type == 1)
			qerror(Perl_mess(aTHX_ "Mandatory parameter "
				"follows optional parameter"));
		    prev_type = 0;
		    min_arity = pos + 1;
		}
		if (var) expr = newASSIGNOP(OPf_STACKED, var, 0, expr);
		if (expr)
		    initops = op_append_list(OP_LINESEQ, initops,
				newSTATEOP(0, NULL, expr));
		max_arity = ++pos;
	    } break;
	    case '@@':
	    case '%': {
		OP *var;
		if (prev_type == 2)
		    qerror(Perl_mess(aTHX_ "Slurpy parameter not last"));
		var = parse_opt_lexvar();
		if (c == '%') {
		    OP *chkop = newLOGOP((pos & 1) ? OP_OR : OP_AND, 0,
			    newBINOP(OP_BIT_AND, 0,
				scalar(newUNOP(OP_RV2AV, 0,
				    newGVOP(OP_GV, 0, PL_defgv))),
				newSVOP(OP_CONST, 0, newSViv(1))),
			    newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
				newSVOP(OP_CONST, 0,
				    newSVpvs("Odd name/value argument "
					"for subroutine"))));
		    if (pos != min_arity)
			chkop = newLOGOP(OP_AND, 0,
				    newBINOP(OP_GT, 0,
					scalar(newUNOP(OP_RV2AV, 0,
					    newGVOP(OP_GV, 0, PL_defgv))),
					newSVOP(OP_CONST, 0, newSViv(pos))),
				    chkop);
		    initops = op_append_list(OP_LINESEQ,
				newSTATEOP(0, NULL, chkop),
				initops);
		}
		if (var) {
		    OP *slice = pos ?
			op_prepend_elem(OP_ASLICE,
			    newOP(OP_PUSHMARK, 0),
			    newLISTOP(OP_ASLICE, 0,
				list(newRANGE(0,
				    newSVOP(OP_CONST, 0, newSViv(pos)),
				    newUNOP(OP_AV2ARYLEN, 0,
					ref(newUNOP(OP_RV2AV, 0,
						newGVOP(OP_GV, 0, PL_defgv)),
					    OP_AV2ARYLEN)))),
				ref(newUNOP(OP_RV2AV, 0,
					newGVOP(OP_GV, 0, PL_defgv)),
				    OP_ASLICE))) :
			newUNOP(OP_RV2AV, 0, newGVOP(OP_GV, 0, PL_defgv));
		    initops = op_append_list(OP_LINESEQ, initops,
			newSTATEOP(0, NULL,
			    newASSIGNOP(OPf_STACKED, var, 0, slice)));
		}
		prev_type = 2;
		max_arity = -1;
	    } break;
	    default:
		parse_error:
		qerror(Perl_mess(aTHX_ "Parse error"));
		return NULL;
	}
	lex_read_space(0);
	c = lex_peek_unichar(0);
	switch (c) {
	    case /*(*/')': break;
	    case ',':
		do {
		    lex_token_boundary();
		    lex_read_unichar(0);
		    lex_read_space(0);
		    c = lex_peek_unichar(0);
		} while (c == ',');
		break;
	    default:
		goto parse_error;
	}
    }
    if (min_arity != 0) {
	initops = op_append_list(OP_LINESEQ,
	    newSTATEOP(0, NULL,
		newLOGOP(OP_OR, 0,
		    newBINOP(OP_GE, 0,
			scalar(newUNOP(OP_RV2AV, 0,
			    newGVOP(OP_GV, 0, PL_defgv))),
			newSVOP(OP_CONST, 0, newSViv(min_arity))),
		    newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
			newSVOP(OP_CONST, 0,
			    newSVpvs("Too few arguments for subroutine"))))),
	    initops);
    }
    if (max_arity != -1) {
	initops = op_append_list(OP_LINESEQ,
	    newSTATEOP(0, NULL,
		newLOGOP(OP_OR, 0,
		    newBINOP(OP_LE, 0,
			scalar(newUNOP(OP_RV2AV, 0,
			    newGVOP(OP_GV, 0, PL_defgv))),
			newSVOP(OP_CONST, 0, newSViv(max_arity))),
		    newLISTOP(OP_DIE, 0, newOP(OP_PUSHMARK, 0),
			newSVOP(OP_CONST, 0,
			    newSVpvs("Too many arguments for subroutine"))))),
	    initops);
    }
    return initops;
@


1.1.1.16
log
@Import perl-5.20.2
@
text
@a2270 1
	  STRLEN len2 = len;
d2272 2
a2273 2
	    s2 += 6, len2 -= 6;
	  if (keyword(s2, len2, 0))
d4074 1
a4074 1
		    char *d = s;
d4076 3
a4078 2
			s++;
		    if (keyword(d, s - d, 0))
@


1.1.1.17
log
@Import perl-5.24.2
@
text
@d26 1
d42 1
a42 1
#include "dquote_inline.h"
d58 1
d91 17
d111 1
d115 5
d121 1
d128 1
a128 1
#   define UTF cBOOL(!IN_BYTES)
d130 1
a130 1
#   define UTF cBOOL((PL_linestr && DO_UTF8(PL_linestr)) || ( !(PL_parser->lex_flags & LEX_IGNORE_UTF8_HINTS) && (PL_hints & HINT_UTF8)))
a141 5
#define HEXFP_PEEK(s)     \
    (((s[0] == '.') && \
      (isXDIGIT(s[1]) || isALPHA_FOLD_EQ(s[1], 'p'))) || \
     isALPHA_FOLD_EQ(s[0], 'p'))

d191 12
a221 1
 * BCop         : bitwise complement
a225 1
 * AopNOASSIGN  : addition-level operator that is never part of .=
d241 1
a241 1
#define AOPERATOR(retval) return ao((PL_expect = XTERM, PL_bufptr = s, retval))
d247 1
a247 4
#define LOOPX(f) return (PL_bufptr = force_word(s,WORD,TRUE,FALSE), \
			 pl_yylval.ival=f, \
			 PL_expect = PL_nexttoke ? XOPERATOR : XTERM, \
			 REPORT((int)LOOPEX))
d252 4
a255 6
#define BOop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)BITOROP))
#define BAop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)BITANDOP))
#define BCop(f) return pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr = s, \
		       REPORT('~')
#define SHop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)SHIFTOP))
#define PWop(f)  return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)POWOP))
d257 2
a258 3
#define Aop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)ADDOP))
#define AopNOASSIGN(f) return (pl_yylval.ival=f, PL_bufptr=s, REPORT((int)ADDOP))
#define Mop(f)   return ao((pl_yylval.ival=f, PL_expect=XTERM, PL_bufptr=s, (int)MULOP))
d275 1
a275 1
	s = skipspace(s); \
d378 1
d414 2
d433 1
a433 1
	else if (isGRAPH(rv))
d503 2
a504 2
 * This subroutine looks for an '=' next to the operator that has just been
 * parsed and turns it into an ASSIGNOP if it finds one.
d510 1
d521 1
a521 1
    return REPORT(toketype);
a534 3
 *
 * PL_bufptr is expected to point to the start of the thing that was found,
 * and s after the next token or partial token.
d540 1
d587 1
d618 1
d684 1
a684 1
The code to be parsed comes from C<line> and C<rsfp>.  C<line>, if
d686 2
a687 2
A copy of the string is made, so subsequent modification of C<line>
does not affect parsing.  C<rsfp>, if non-null, provides an input stream
d689 2
a690 2
code in C<line> comes first and must consist of complete lines of input,
and C<rsfp> supplies the remainder of the source.
d692 1
a692 1
The C<flags> parameter is reserved for future use.  Currently it is only
d710 1
d732 3
d736 1
d773 1
a773 1
    STATIC_ASSERT_STMT(FITS_IN_8_BITS(LEX_IGNORE_UTF8_HINTS|LEX_EVALBYTES
d794 2
a795 2
    else if (parser->rsfp && (!parser->old_parser
          || (parser->old_parser && parser->rsfp != parser->old_parser->rsfp)))
d811 3
d815 1
d818 10
d835 1
d939 1
a939 1
at least C<len> octets (including terminating C<NUL>).  Returns a
d1000 3
a1002 3
The string to be inserted is represented by C<len> octets starting
at C<pv>.  These octets are interpreted as either UTF-8 or Latin-1,
according to whether the C<LEX_STUFF_UTF8> flag is set in C<flags>.
d1085 1
a1085 1
		    *bufptr++ = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
d1112 1
a1112 1
The string to be inserted is represented by octets starting at C<pv>
d1115 1
a1115 1
in C<flags>.  The characters are recoded for the lexer buffer, according
d1141 1
a1141 1
The string to be inserted is the string value of C<sv>.  The characters
d1166 1
a1166 1
C<ptr>.  Text following C<ptr> will be moved, and the buffer shortened.
d1200 1
a1200 1
to C<ptr>.  This advances L</PL_parser-E<gt>bufptr> to match C<ptr>,
d1231 2
a1232 2
up to C<ptr>.  The remaining content of the buffer will be moved, and
all pointers into the buffer updated appropriately.  C<ptr> must not
d1293 1
a1293 1
read in.  If C<flags> has the C<LEX_KEEP_PREVIOUS> bit set, the current chunk
d1304 1
a1304 1
#define LEX_NO_TERM  0x40000000 /* here-doc */
a1317 2
    if (!(flags & LEX_NO_TERM) && PL_lex_inwhat)
	return FALSE;
d1320 2
a1321 3
    if (!(flags & LEX_KEEP_PREVIOUS)
          && PL_parser->bufptr == PL_parser->bufend)
    {
d1362 4
d1392 2
a1393 4
    if (   got_some_for_debugger
        && PERLDB_LINE_OR_SAVESRC
        && PL_curstash != PL_debstash)
    {
d1413 2
a1414 2
discarded at the same time, but if C<flags> has the C<LEX_KEEP_PREVIOUS>
bit set, then the current chunk will not be discarded.
d1484 2
a1485 2
discarded at the same time, but if C<flags> has the C<LEX_KEEP_PREVIOUS>
bit set, then the current chunk will not be discarded.
d1522 1
a1522 1
time, but if C<flags> has the C<LEX_KEEP_PREVIOUS> bit set, then the current
d1539 8
d1569 4
a1587 2
	} else if (!c) {
	    s++;
d1592 4
d1655 3
a1657 4
		else if ((*p == '@@' || *p == '%')
                         && !after_slash
                         && !in_brackets )
                {
d1713 1
a1717 1
    UV uv;
d1758 1
a1758 1
	while (*t && !isSPACE(*t))
d1767 1
a1767 3
    if (!grok_atoUV(n, &uv, &e))
        return;
    line_num = ((line_t)uv) - 1;
d1832 79
d1946 3
d1950 6
d1957 1
a1957 1
	while (s < PL_bufend && (SPACE_OR_TAB(*s) || !*s))
d1963 1
a1963 1
		(PL_lex_inwhat || PL_lex_state == LEX_FORMLINE ?
d1971 4
d1990 1
d2000 1
a2000 1
	s += UTF ? UTF8SKIP(s) : 1;
d2005 2
a2006 2
		     "Warning: Use of \"%"UTF8f"\" without parentheses is ambiguous",
		     UTF8fARG(UTF, (int)(s - PL_last_uni), PL_last_uni));
d2019 1
a2019 4
 *  - if we have a next token, then it's a list operator (no parens) for
 *    which the next token has already been parsed; e.g.,
 *       sort foo @@args
 *       sort foo (@@args)
d2027 2
d2033 1
d2037 4
d2043 1
a2043 1
    PL_expect = x;
d2046 1
a2046 1
    s = skipspace(s);
d2057 70
d2132 2
a2133 2
 * will need to set PL_nextval[] and possibly PL_expect to ensure
 * the lexer handles the token correctly.
d2139 1
d2146 10
a2155 1
    assert(PL_nexttoke < C_ARRAY_LENGTH(PL_nexttype));
d2160 1
d2163 1
d2178 1
d2186 1
d2189 1
d2209 1
d2228 1
d2232 1
a2232 1
				  && !is_invariant_string((const U8*)start, len)
d2251 1
d2257 1
d2263 1
a2263 1
    start = skipspace(start);
d2265 2
a2266 2
    if (isIDFIRST_lazy_if(s,UTF)
        || (allow_pack && *s == ':') )
d2277 3
d2281 1
a2281 1
	    s = skipspace(s);
d2288 2
d2311 2
d2319 1
d2328 1
a2328 1
			      (PL_in_eval ? GV_ADDMULTI
d2342 1
d2386 1
d2389 3
d2395 1
a2395 1
    s = skipspace(s);
d2403 6
d2421 7
d2432 7
d2440 1
d2455 1
d2457 3
d2472 2
a2473 2
    else if ((*s != ';' && *s != '{' && *s != '}' )
             && (s = skipspace(s), (*s != ';' && *s != '{' && *s != '}' )))
d2481 7
d2489 1
d2507 1
d2578 1
d2587 1
a2587 3
	SV *sv = PL_lex_stuff;
	PL_lex_stuff = NULL;
	sv = tokeq(sv);
d2598 1
d2628 1
a2641 1
    SAVEI8(PL_lex_defer);
a2678 7
    /* Arrange for PL_lex_stuff to be freed on scope exit, in case it gets
       set for an inner quote-like operator and then an error causes scope-
       popping.  We must not have a PL_lex_stuff value left dangling, as
       that breaks assumptions elsewhere.  See bug #123617.  */
    SAVEGENERICSV(PL_lex_stuff);
    SAVEGENERICSV(PL_sublex_info.repl);

d2725 1
d2774 1
a2774 1
	return '/';
d2778 14
d2798 1
a2821 6
    if (!SvCUR(res)) {
        Perl_ck_warner_d(aTHX_ packWARN(WARN_DEPRECATED),
                       "Unknown charname '' is deprecated");
        return res;
    }

d2835 1
a2835 1
        yyerror_pv(Perl_form(aTHX_
d2837 1
a2837 2
            (int) (first_bad_char_loc - (U8 *) backslash_ptr), backslash_ptr),
                   SVf_UTF8);
d2869 2
a2870 3
    /* This code makes the reasonable assumption that the only Latin1-range
     * characters that begin a character name alias are alphabetic, otherwise
     * would have to create a isCHARNAME_BEGIN macro */
d2881 1
a2881 4
	    if (*s == ' ' && *(s-1) == ' ') {
                goto multi_spaces;
            }
	    if ((U8) *s == NBSP_NATIVE && ckWARN_d(WARN_DEPRECATED)) {
d2883 1
a2883 1
                           "NO-BREAK SPACE in a charnames "
d2888 5
d2904 1
a2904 1
            if (! isALPHAU(EIGHT_BIT_UTF8_TO_NATIVE(*s, *(s+1)))) {
d2928 5
a2932 2
                if (*s == ' ' && *(s-1) == ' ') {
                    goto multi_spaces;
d2937 1
a2937 1
                if (! isCHARNAME_CONT(EIGHT_BIT_UTF8_TO_NATIVE(*s, *(s+1))))
a2940 8
                if (*s == *NBSP_UTF8
                    && *(s+1) == *(NBSP_UTF8+1)
                    && ckWARN_d(WARN_DEPRECATED))
                {
                    Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                "NO-BREAK SPACE in a charnames "
                                "alias definition is deprecated");
                }
d2957 5
a2961 11
    }
    if (*(s-1) == ' ') {
        yyerror_pv(
            Perl_form(aTHX_
            "charnames alias definitions may not contain trailing "
            "white-space; marked by <-- HERE in %.*s<-- HERE %.*s",
            (int)(s - backslash_ptr + 1), backslash_ptr,
            (int)(e - s + 1), s + 1
            ),
        UTF ? SVf_UTF8 : 0);
        return NULL;
d2992 1
d2999 2
a3000 2
            (int)(s - backslash_ptr + 1), backslash_ptr,
            (int)(e - s + 1), s + 1
a3004 11

  multi_spaces:
        yyerror_pv(
          Perl_form(aTHX_
            "charnames alias definitions may not contain a sequence of "
            "multiple spaces; marked by <-- HERE in %.*s<-- HERE %.*s",
            (int)(s - backslash_ptr + 1), backslash_ptr,
            (int)(e - s + 1), s + 1
          ),
          UTF ? SVf_UTF8 : 0);
        return NULL;
d3039 1
d3099 1
d3101 2
a3102 2
    SV *sv = newSV(send - start);       /* sv for the constant.  See note below
                                           on sizing. */
d3105 10
a3114 9
    bool dorange = FALSE;               /* are we in a translit range? */
    bool didrange = FALSE;              /* did we just finish a range? */
    bool in_charclass = FALSE;          /* within /[...]/ */
    bool has_utf8 = FALSE;              /* Output constant is UTF8 */
    bool  this_utf8 = cBOOL(UTF);       /* Is the source string assumed to be
                                           UTF8?  But, this can show as true
                                           when the source isn't utf8, as for
                                           example when it is entirely composed
                                           of hex constants */
a3115 2
    STRLEN offset_to_max;   /* The offset in the output to where the range
                               high-end character is temporarily placed */
d3132 2
a3133 3
    int backslash_N = 0;            /* ? was the character from \N{} */
    int non_portable_endpoint = 0;  /* ? In a range is an endpoint
                                       platform-specific like \x65 */
d3149 1
a3149 3
    while (s < send
           || dorange   /* Handle tr/// range at right edge of input */
    ) {
d3153 5
a3158 34
            /* But there isn't any special handling necessary unless there is a
             * range, so for most cases we just drop down and handle the value
             * as any other.  There are two exceptions.
             *
             * 1.  A minus sign indicates that we are actually going to have
             *     a range.  In this case, skip the '-', set a flag, then drop
             *     down to handle what should be the end range value.
             * 2.  After we've handled that value, the next time through, that
             *     flag is set and we fix up the range.
             *
             * Ranges entirely within Latin1 are expanded out entirely, in
             * order to avoid the significant overhead of making a swash.
             * Ranges that extend above Latin1 have to have a swash, so there
             * is no advantage to abbreviate them here, so they are stored here
             * as Min, ILLEGAL_UTF8_BYTE, Max.  The illegal byte signifies a
             * hyphen without any possible ambiguity.  On EBCDIC machines, if
             * the range is expressed as Unicode, the Latin1 portion is
             * expanded out even if the entire range extends above Latin1.
             * This is because each code point in it has to be processed here
             * individually to get its native translation */

	    if (! dorange) {

                /* Here, we don't think we're in a range.  If we've processed
                 * at least one character, then see if this next one is a '-',
                 * indicating the previous one was the start of a range.  But
                 * don't bother if we're too close to the end for the minus to
                 * mean that. */
                if (*s != '-' || s >= send - 1 || s == start) {

                    /* A regular character.  Process like any other, but first
                     * clear any flags */
                    didrange = FALSE;
                    dorange = FALSE;
d3160 1
a3160 2
                    non_portable_endpoint = 0;
                    backslash_N = 0;
a3161 6
                    /* Drops down to generic code to process current byte */
                }
                else {
                    if (didrange) { /* Something like y/A-C-Z// */
                        Perl_croak(aTHX_ "Ambiguous range in transliteration operator");
                    }
d3163 15
a3177 1
                    dorange = TRUE;
d3179 9
a3187 32
                    s++;    /* Skip past the minus */

                    /* d now points to where the end-range character will be
                     * placed.  Save it so won't have to go finding it later,
                     * and drop down to get that character.  (Actually we
                     * instead save the offset, to handle the case where a
                     * realloc in the meantime could change the actual
                     * pointer).  We'll finish processing the range the next
                     * time through the loop */
                    offset_to_max = d - SvPVX_const(sv);
                }
            }  /* End of not a range */
            else {
                /* Here we have parsed a range.  Now must handle it.  At this
                 * point:
                 * 'sv' is a SV* that contains the output string we are
                 *      constructing.  The final two characters in that string
                 *      are the range start and range end, in order.
                 * 'd'  points to just beyond the range end in the 'sv' string,
                 *      where we would next place something
                 * 'offset_to_max' is the offset in 'sv' at which the character
                 *      before 'd' begins.
                 */
                const char * max_ptr = SvPVX_const(sv) + offset_to_max;
                const char * min_ptr;
                IV range_min;
		IV range_max;	/* last character in range */
                STRLEN save_offset;
                STRLEN grow;
#ifndef EBCDIC  /* Not meaningful except in EBCDIC, so initialize to false */
                const bool convert_unicode = FALSE;
                const IV real_range_max = 0;
d3189 1
a3189 2
                bool convert_unicode;
                IV real_range_max = 0;
d3191 2
a3192 2

                /* Get the range-ends code point values. */
d3194 14
a3207 5
                    /* We know the utf8 is valid, because we just constructed
                     * it ourselves in previous loop iterations */
                    min_ptr = (char*) utf8_hop( (U8*) max_ptr, -1);
                    range_min = valid_utf8_to_uvchr( (U8*) min_ptr, NULL);
                    range_max = valid_utf8_to_uvchr( (U8*) max_ptr, NULL);
d3209 5
a3213 6
                else {
                    min_ptr = max_ptr - 1;
                    range_min = * (U8*) min_ptr;
                    range_max = * (U8*) max_ptr;
                }

d3215 1
a3215 22
                /* On EBCDIC platforms, we may have to deal with portable
                 * ranges.  These happen if at least one range endpoint is a
                 * Unicode value (\N{...}), or if the range is a subset of
                 * [A-Z] or [a-z], and both ends are literal characters,
                 * like 'A', and not like \x{C1} */
                if ((convert_unicode
                     = cBOOL(backslash_N)   /* \N{} forces Unicode, hence
                                               portable range */
                      || (   ! non_portable_endpoint
                          && ((  isLOWER_A(range_min) && isLOWER_A(range_max))
                             || (isUPPER_A(range_min) && isUPPER_A(range_max))))
                )) {

                    /* Special handling is needed for these portable ranges.
                     * They are defined to all be in Unicode terms, which
                     * include all Unicode code points between the end points.
                     * Convert to Unicode to get the Unicode range.  Later we
                     * will convert each code point in the range back to
                     * native.  */
                    range_min = NATIVE_TO_UNI(range_min);
                    range_max = NATIVE_TO_UNI(range_max);
                }
d3218 4
a3221 30
                if (range_min > range_max) {
                    if (convert_unicode) {
                        /* Need to convert back to native for meaningful
                         * messages for this platform */
                        range_min = UNI_TO_NATIVE(range_min);
                        range_max = UNI_TO_NATIVE(range_max);
                    }

                    /* Use the characters themselves for the error message if
                     * ASCII printables; otherwise some visible representation
                     * of them */
                    if (isPRINT_A(range_min) && isPRINT_A(range_max)) {
                        Perl_croak(aTHX_
			 "Invalid range \"%c-%c\" in transliteration operator",
			 (char)range_min, (char)range_max);
                    }
                    else if (convert_unicode) {
                        /* diag_listed_as: Invalid range "%s" in transliteration operator */
                        Perl_croak(aTHX_
			       "Invalid range \"\\N{U+%04"UVXf"}-\\N{U+%04"UVXf"}\""
                               " in transliteration operator",
			       range_min, range_max);
                    }
                    else {
                        /* diag_listed_as: Invalid range "%s" in transliteration operator */
                        Perl_croak(aTHX_
			       "Invalid range \"\\x{%04"UVXf"}-\\x{%04"UVXf"}\""
                               " in transliteration operator",
			       range_min, range_max);
                    }
a3223 10
		if (has_utf8) {

                    /* We try to avoid creating a swash.  If the upper end of
                     * this range is below 256, this range won't force a swash;
                     * otherwise it does force a swash, and as long as we have
                     * to have one, we might as well not expand things out.
                     * But if it's EBCDIC, we may have to look at each
                     * character below 256 if we have to convert to/from
                     * Unicode values */
                    if (range_max > 255
d3225 10
a3234 1
		        && (range_min > 255 || ! convert_unicode)
d3236 4
a3239 8
                    ) {
                        /* Move the high character one byte to the right; then
                         * insert between it and the range begin, an illegal
                         * byte which serves to indicate this is a range (using
                         * a '-' could be ambiguous). */
                        char *e = d++;
                        while (e-- > max_ptr) {
                            *(e + 1) = *e;
d3241 4
a3244 8
                        *(e + 1) = (char) ILLEGAL_UTF8_BYTE;
                        goto range_done;
                    }

                    /* Here, we're going to expand out the range.  For EBCDIC
                     * the range can extend above 255 (not so in ASCII), so
                     * for EBCDIC, split it into the parts above and below
                     * 255/256 */
d3246 7
a3252 4
                    if (range_max > 255) {
                        real_range_max = range_max;
                        range_max = 255;
                    }
a3253 1
		}
d3255 3
a3257 16
                /* Here we need to expand out the string to contain each
                 * character in the range.  Grow the output to handle this */

                save_offset  = min_ptr - SvPVX_const(sv);

                /* The base growth is the number of code points in the range */
                grow = range_max - range_min + 1;
                if (has_utf8) {

                    /* But if the output is UTF-8, some of those characters may
                     * need two bytes (since the maximum range value here is
                     * 255, the max bytes per character is two).  On ASCII
                     * platforms, it's not much trouble to get an accurate
                     * count of what's needed.  But on EBCDIC, the ones that
                     * need 2 bytes are scattered around, so just use a worst
                     * case value instead of calculating for that platform.  */
d3259 1
a3259 10
                    grow *= 2;
#else
                    /* Only those above 127 require 2 bytes.  This may be
                     * everything in the range, or not */
                    if (range_min > 127) {
                        grow *= 2;
                    }
                    else if (range_max > 127) {
                        grow += range_max - 127;
                    }
d3261 2
a3262 1
                }
d3264 4
a3267 25
                /* Subtract 3 for the bytes that were already accounted for
                 * (min, max, and the hyphen) */
                SvGROW(sv, SvLEN(sv) + grow - 3);
		d = SvPVX(sv) + save_offset;	/* refresh d after realloc */

                /* Here, we expand out the range.  On ASCII platforms, the
                 * compiler should optimize out the 'convert_unicode==TRUE'
                 * portion of this */
                if (convert_unicode) {
                    IV i;

                    /* Recall that the min and max are now in Unicode terms, so
                     * we have to convert each character to its native
                     * equivalent */
                    if (has_utf8) {
                        for (i = range_min; i <= range_max; i++) {
                            append_utf8_from_native_byte(LATIN1_TO_NATIVE((U8) i),
                                                         (U8 **) &d);
                        }
                    }
                    else {
                        for (i = range_min; i <= range_max; i++) {
                            *d++ = (char)LATIN1_TO_NATIVE((U8) i);
                        }
		    }
d3269 8
a3276 18
                else {
                    IV i;

                    /* Here, no conversions are necessary, which means that the
                     * first character in the range is already in 'd' and
                     * valid, so we can skip overwriting it */
                    if (has_utf8) {
                        d += UTF8SKIP(d);
                        for (i = range_min + 1; i <= range_max; i++) {
                            append_utf8_from_native_byte((U8) i, (U8 **) &d);
                        }
                    }
                    else {
                        d++;
                        for (i = range_min + 1; i <= range_max; i++) {
                            *d++ = (char)i;
                        }
		    }
d3278 11
d3290 1
a3290 10
                /* (Compilers should optimize this out for non-EBCDIC).  If the
                 * original range extended above 255, add in that portion */
                if (real_range_max) {
                    *d++ = (char) UTF8_TWO_BYTE_HI(0x100);
                    *d++ = (char) UTF8_TWO_BYTE_LO(0x100);
                    if (real_range_max > 0x101)
                        *d++ = (char) ILLEGAL_UTF8_BYTE;
                    if (real_range_max > 0x100)
                        d = (char*)uvchr_to_utf8((U8*)d, real_range_max);
                }
a3291 11
              range_done:
		/* mark the range as done, and continue */
		didrange = TRUE;
		dorange = FALSE;
#ifdef EBCDIC
		non_portable_endpoint = 0;
                backslash_N = 0;
#endif
		continue;
	    } /* End of is a range */
        } /* End of transliteration.  Joins main code after these else's */
d3319 3
a3321 3
	    else if (!PL_lex_casemods
                     && (    s[2] == '{' /* This should match regcomp.c */
		         || (s[2] == '?' && s[3] == '{')))
d3328 2
a3329 5
	else if (*s == '#'
                 && PL_lex_inpat
                 && !in_charclass
                 && ((PMOP*)PL_lex_inpat)->op_pmflags & RXf_PMf_EXTENDED)
        {
d3342 1
a3342 1
	    if (UTF ? isIDFIRST_utf8((U8*)s+1) : isWORDCHAR_A(s[1]))
d3375 2
a3376 5
	    if (PL_lex_inwhat == OP_SUBST
                && !PL_lex_inpat
                && isDIGIT(*s)
                && *s != '0'
                && !isDIGIT(s[1]))
a3394 1
             *
d3405 1
a3405 1
			|| regcurly(s + 1)))
d3412 8
d3483 4
a3486 1
		/* Insert oct or hex escaped character. */
d3489 1
a3489 4
		if (UVCHR_IS_INVARIANT(uv)) {
		    *d++ = (char) uv;
		}
		else {
d3499 3
a3501 7
			sv_utf8_upgrade_flags_grow(
                                       sv,
                                       SV_GMAGIC|SV_FORCE_UTF8_UPGRADE
                                                  /* Above-latin1 in string
                                                   * implies no encoding */
                                                  |SV_UTF8_NO_ENCODING,
                                       UVCHR_SKIP(uv) + (STRLEN)(send - s) + 1);
a3506 14
                       /* Usually, there will already be enough room in 'sv'
                        * since such escapes are likely longer than any UTF-8
                        * sequence they can end up as.  This isn't the case on
                        * EBCDIC where \x{40000000} contains 12 bytes, and the
                        * UTF-8 for it contains 14.  And, we have to allow for
                        * a trailing NUL.  It probably can't happen on ASCII
                        * platforms, but be safe */
                        const STRLEN needed = d - SvPVX(sv) + UVCHR_SKIP(uv)
                                            + 1;
                        if (UNLIKELY(needed > SvLEN(sv))) {
                            SvCUR_set(sv, d - SvPVX_const(sv));
                            d = sv_grow(sv, needed) + SvCUR(sv);
                        }

d3508 2
a3509 3
			if (PL_lex_inwhat == OP_TRANS
                            && PL_sublex_info.sub_op)
                        {
d3514 4
d3523 3
a3525 3
#ifdef EBCDIC
                non_portable_endpoint++;
#endif
d3529 12
a3540 22
                /* In a non-pattern \N must be like \N{U+0041}, or it can be a
                 * named character, like \N{LATIN SMALL LETTER A}, or a named
                 * sequence, like \N{LATIN CAPITAL LETTER A WITH MACRON AND
                 * GRAVE} (except y/// can't handle the latter, croaking).  For
                 * convenience all three forms are referred to as "named
                 * characters" below.
                 *
                 * For patterns, \N also can mean to match a non-newline.  Code
                 * before this 'switch' statement should already have handled
                 * this situation, and hence this code only has to deal with
                 * the named character cases.
                 *
                 * For non-patterns, the named characters are converted to
                 * their string equivalents.  In patterns, named characters are
                 * not converted to their ultimate forms for the same reasons
                 * that other escapes aren't.  Instead, they are converted to
                 * the \N{U+...} form to get the value from the charnames that
                 * is in effect right now, while preserving the fact that it
                 * was a named character, so that the regex compiler knows
                 * this.
                 *
		 * The structure of this section of code (besides checking for
d3542 12
a3553 14
                 *    If the named character is of the form \N{U+...}, pass it
                 *      through if a pattern; otherwise convert the code point
                 *      to utf8
                 *    Otherwise must be some \N{NAME}: convert to
                 *      \N{U+c1.c2...} if a pattern; otherwise convert to utf8
                 *
                 * Transliteration is an exception.  The conversion to utf8 is
                 * only done if the code point requires it to be representable.
                 *
                 * Here, 's' points to the 'N'; the test below is guaranteed to
		 * succeed if we are being called on a pattern, as we already
                 * know from a test above that the next character is a '{'.  A
                 * non-pattern \N must mean 'named character', which requires
                 * braces */
d3574 6
d3581 8
d3591 16
a3606 25
                        /* In patterns, we can have \N{U+xxxx.yyyy.zzzz...} */
                        /* Check the syntax.  */
                        const char *orig_s;
                        orig_s = s - 5;
                        if (!isXDIGIT(*s)) {
                          bad_NU:
                            yyerror(
                                "Invalid hexadecimal number in \\N{U+...}"
                            );
                            s = e + 1;
                            continue;
                        }
                        while (++s < e) {
                            if (isXDIGIT(*s))
                                continue;
                            else if ((*s == '.' || *s == '_')
                                  && isXDIGIT(s[1]))
                                continue;
                            goto bad_NU;
                        }

                        /* Pass everything through unchanged.
                         * +1 is for the '}' */
                        Copy(orig_s, d, e - orig_s + 1, char);
                        d += e - orig_s + 1;
d3609 6
a3614 18
                        I32 flags = PERL_SCAN_ALLOW_UNDERSCORES
				| PERL_SCAN_SILENT_ILLDIGIT
				| PERL_SCAN_DISALLOW_PREFIX;
                        STRLEN len = e - s;
                        uv = grok_hex(s, &len, &flags, NULL);
                        if (len == 0 || (len != (STRLEN)(e - s)))
                            goto bad_NU;

                         /* For non-tr///, if the destination is not in utf8,
                          * unconditionally recode it to be so.  This is
                          * because \N{} implies Unicode semantics, and scalars
                          * have to be in utf8 to guarantee those semantics.
                          * tr/// doesn't care about Unicode rules, so no need
                          * there to upgrade to UTF-8 for small enough code
                          * points */
			if (! has_utf8 && (   uv > 0xFF
                                           || PL_lex_inwhat != OP_TRANS))
                        {
d3620 3
a3622 3
                                    sv,
                                    SV_GMAGIC|SV_FORCE_UTF8_UPGRADE,
				    UVCHR_SKIP(uv) + (STRLEN)(send - e) + 1);
d3628 1
a3628 1
			if (OFFUNI_IS_INVARIANT(uv)) {
a3662 3
                                const char initial_text[] = "\\N{U+";
                                const STRLEN initial_len = sizeof(initial_text)
                                                           - 1;
d3665 2
a3666 4

                                                    /* +1 for trailing NUL */
                                                    + initial_len + 1

d3668 2
a3669 2
                                Copy(initial_text, d, initial_len, char);
                                d += initial_len;
d3672 2
a3673 11
                                    int len =
                                        my_snprintf(hex_string,
                                                  sizeof(hex_string),
                                                  "%02X.",

                                                  /* The regex compiler is
                                                   * expecting Unicode, not
                                                   * native */
                                                  NATIVE_TO_LATIN1(*str));
                                    PERL_MY_SNPRINTF_POST_GUARD(len,
                                                           sizeof(hex_string));
d3678 1
a3678 1
                                d--;    /* Below, we will overwrite the final
d3697 2
a3698 2
                                /* Convert first code point to Unicode hex,
                                 * including the boiler plate before it. */
d3701 2
a3702 2
                                             "\\N{U+%X",
                                             (unsigned int) NATIVE_TO_UNI(uv));
d3714 1
a3714 1
                                * its Unicode code point in hex */
d3723 3
a3725 3
                                             sizeof(hex_string),
                                             ".%X",
                                             (unsigned int) NATIVE_TO_UNI(uv));
d3742 5
a3746 26
                        if (PL_lex_inwhat == OP_TRANS) {
                            str = SvPV_const(res, len);
                            if (len > ((SvUTF8(res))
                                       ? UTF8SKIP(str)
                                       : 1U))
                            {
                                yyerror(Perl_form(aTHX_
                                    "%.*s must not be a named sequence"
                                    " in transliteration operator",
                                        /*  +1 to include the "}" */
                                    (int) (e + 1 - start), start));
                                goto end_backslash_N;
                            }
                        }
                        else if (! SvUTF8(res)) {
                            /* Make sure \N{} return is UTF-8.  This is because
                            * \N{} implies Unicode semantics, and scalars have to
                            * be in utf8 to guarantee those semantics; but not
                            * needed in tr/// */
                            sv_utf8_upgrade_flags(res, SV_UTF8_NO_ENCODING);
                            str = SvPV_const(res, len);
                        }

                         /* Upgrade destination to be utf8 if this new
                          * component is */
			if (! has_utf8 && SvUTF8(res)) {
a3769 2

              end_backslash_N:
d3771 2
a3772 1
                backslash_N++; /* \N{} is defined to be Unicode */
a3785 3
#ifdef EBCDIC
                non_portable_endpoint++;
#endif
d3805 1
a3805 1
		*d++ = ESC_NATIVE;
d3815 4
d3826 1
d3837 1
a3837 1
	    const STRLEN need = UVCHR_SKIP(nextuv);
d3858 4
d3876 2
a3877 2
    if (IN_ENCODING && !has_utf8) {
	sv_recode_to_utf8(sv, _get_encoding());
d3958 2
d3978 1
a3978 1
	if (regcurly(s)) {
d4034 2
a4035 4
		else if (*s == '$'
                         && s[1]
                         && strchr("[#!%*<>()-=",s[1]))
                {
d4117 1
a4117 1
S_intuit_method(pTHX_ char *start, SV *ioname, CV *cv)
d4119 1
d4124 3
a4126 6
	/* Mustn't actually add anything to a symbol table.
	   But also don't want to "initialise" any placeholder
	   constants that might already be there into full
	   blown PVGVs with attached PVCV.  */
    GV * const gv =
	ioname ? gv_fetchsv(ioname, GV_NOADD_NOINIT, SVt_PVCV) : NULL;
d4143 2
a4144 2
	if (cv || PL_last_lop_op == OP_PRINT || PL_last_lop_op == OP_SAY
            || isUPPER(*PL_tokenbuf))
d4146 7
a4152 1
	s = skipspace(s);
d4168 3
d4178 4
a4181 1
	    s = skipspace(s);
d4185 1
d4189 3
d4195 3
d4224 1
d4293 1
d4321 1
d4411 2
d4435 1
d4443 3
a4445 5
    if (len > 2
        && (pkgname[len - 2] == ':' && pkgname[len - 1] == ':')
        && (gv = gv_fetchpvn_flags(pkgname,
                                   len,
                                   ( UTF ? SVf_UTF8 : 0 ), SVt_PVHV)))
d4455 1
a4455 1
	    return gv_stashsv(sv, 0);
d4461 180
d4644 2
d4652 1
a4652 1
    s = skipspace(s);
d4656 2
a4657 1
		|| (s = skipspace(s), (*s == ';' || *s == '}'))) {
d4676 1
a4676 2
	  "ATTRTERM", "TERMBLOCK", "XBLOCKTERM", "POSTDEREF",
	  "TERMORDORDOR"
d4684 4
a4687 4
    return (len == 1 && strchr("msyq", p[0]))
            || (len == 2
                && ((p[0] == 't' && p[1] == 'r')
                    || (p[0] == 'q' && strchr("qwxr", p[1]))));
d4778 5
d4784 22
a4805 1
    if (PL_nexttoke) {
d4810 1
d4813 1
d4816 3
d4820 1
a4835 6
    }

    switch (PL_lex_state) {
    case LEX_NORMAL:
    case LEX_INTERPNORMAL:
	break;
d4859 4
d4872 11
d4885 1
d4894 7
d4907 5
a4911 4
                if (strnEQ(s, "L\\u", 3) || strnEQ(s, "U\\l", 3))
                    tmp = *s, *s = s[2], s[2] = (char)tmp;	/* misordered... */
		if ((*s == 'L' || *s == 'U' || *s == 'F')
                    && (strchr(PL_lex_casestack, 'L')
d4913 1
a4913 2
                        || strchr(PL_lex_casestack, 'F')))
                {
d4923 1
d4926 1
d4941 7
d4954 7
d4963 1
a4963 1
		    TOKEN(',');
d4965 1
a4965 1
		    AopNOASSIGN(OP_CONCAT);
d4986 1
d4989 1
d4991 1
d4994 1
d4997 1
d5007 2
d5015 7
d5024 1
a5024 1
		TOKEN(',');
d5026 1
a5026 1
		AopNOASSIGN(OP_CONCAT);
d5035 1
a5035 1
	/* FALLTHROUGH */
a5037 8
	/* Treat state as LEX_NORMAL if we have no inner lexing scope.
	   XXX This hack can be removed if we stop setting PL_lex_state to
	   LEX_KNOWNEXT, as can the hack under LEX_INTREPCONCAT below.  */
	if (UNLIKELY(!PL_lex_inwhat)) {
	    PL_lex_state = LEX_NORMAL;
	    break;
	}

d5042 7
d5080 2
a5097 8
	/* Treat state as LEX_NORMAL when not in an inner lexing scope.
	   XXX This hack can be removed if we stop setting PL_lex_state to
	   LEX_KNOWNEXT.  */
	if (UNLIKELY(!PL_lex_inwhat)) {
	    PL_lex_state = LEX_NORMAL;
	    break;
	}

d5117 4
d5125 7
d5134 1
a5134 1
		    TOKEN(',');
d5136 1
a5136 1
		    AopNOASSIGN(OP_CONCAT);
d5164 7
d5173 1
a5173 13
	if (UTF) {
            if (! isUTF8_CHAR((U8 *) s, (U8 *) PL_bufend)) {
                ENTER;
                SAVESPTR(PL_warnhook);
                PL_warnhook = PERL_WARNHOOK_FATAL;
                utf8n_to_uvchr((U8*)s, PL_bufend-s, NULL, 0);
                LEAVE;
            }
            if (isIDFIRST_utf8((U8*)s)) {
                goto keylookup;
            }
        }
        else if (isALNUMC(*s)) {
d5175 1
a5175 2
	}
    {
d5184 1
a5184 1
            d = UTF ? (char *) utf8_hop((U8 *) s, -UNRECOGNIZED_PRECEDE_COUNT) : s - UNRECOGNIZED_PRECEDE_COUNT;
d5196 5
a5200 2
	if ((!PL_rsfp || PL_lex_inwhat)
	 && (!PL_parser->filtered || s+1 < PL_bufend)) {
d5203 2
a5204 3
	    if (PL_lex_brackets
                && PL_lex_brackstack[PL_lex_brackets-1] != XFAKEEOF)
            {
d5221 4
d5291 1
a5291 1
	    if (PERLDB_LINE_OR_SAVESRC && PL_curstash != PL_debstash)
d5310 4
d5317 5
a5321 6
	    if (bof && PL_rsfp
                && (*s == 0
                    || *(U8*)s == BOM_UTF8_FIRST_BYTE
                        || *(U8*)s >= 0xFE
                        || s[1] == 0))
            {
d5336 4
d5359 4
d5394 18
a5411 22
                    SV* copfilesv = CopFILESV(PL_curcop);
                    if (copfilesv) {
                        SV * const x =
                            GvSV(gv_fetchpvs("\030", GV_ADD|GV_NOTQUAL,
                                             SVt_PV)); /* $^X */
                        assert(SvPOK(x) || SvGMAGICAL(x));
                        if (sv_eq(x, copfilesv)) {
                            sv_setpvn(x, ipath, ipathend - ipath);
                            SvSETMAGIC(x);
                        }
                        else {
                            STRLEN blen;
                            STRLEN llen;
                            const char *bstart = SvPV_const(copfilesv, blen);
                            const char * const lstart = SvPV_const(x, llen);
                            if (llen < blen) {
                                bstart += blen - llen;
                                if (strnEQ(bstart, lstart, llen) &&	bstart[-1] == '/') {
                                    sv_setpvn(x, ipath, ipathend - ipath);
                                    SvSETMAGIC(x);
                                }
                            }
a5412 3
                    }
                    else {
                        /* Anything to do if no copfilesv? */
d5429 1
a5429 1
			    if (isALPHA_FOLD_EQ(*d, 'p')
d5460 6
a5465 6
		if (!d
                    && *s == '#'
                    && ipathend > ipath
                    && !PL_minus_c
                    && !instr(s,"indir")
                    && instr(PL_origargv[0],"perl"))
d5511 1
a5511 1
			    if (baduni || isALPHA_FOLD_EQ(*d1, 'M')) {
d5528 2
a5529 2
			if (   (PERLDB_LINE_OR_SAVESRC && !oldpdb)
                            || ((PL_minus_n || PL_minus_p) && !(oldn || oldp)))
d5538 1
a5538 1
			    if (PERLDB_LINE_OR_SAVESRC)
d5548 2
d5560 9
a5568 1
    case ' ': case '\t': case '\f': case '\v':
d5573 7
a5579 4
	if (PL_lex_state != LEX_NORMAL
            || (PL_in_eval && !PL_rsfp && !PL_parser->filtered))
        {
            const bool in_comment = *s == '#';
d5586 26
a5611 16
            d = s;
            while (d < PL_bufend && *d != '\n')
                d++;
            if (d < PL_bufend)
                d++;
            else if (d > PL_bufend)
                /* Found by Ilya: feed random input to Perl. */
                Perl_croak(aTHX_ "panic: input overflow, %p > %p",
                           d, PL_bufend);
            s = d;
            if (in_comment && d == PL_bufend
                && PL_lex_state == LEX_INTERPNORMAL
                && PL_lex_inwhat == OP_SUBST && PL_lex_repl == PL_linestr
                && SvEVALED(PL_lex_repl) && d[-1] == '}') s--;
            else
                incline(s);
d5614 2
d5621 34
a5654 11
            while (s < PL_bufend && *s != '\n')
                s++;
            if (s < PL_bufend)
                {
                    s++;
                    if (s < PL_bufend)
                        incline(s);
                }
            else if (s > PL_bufend)
                /* Found by Ilya: feed random input to Perl. */
                Perl_croak(aTHX_ "panic: input overflow");
d5740 3
a5742 2
		s = skipspace(s);
		if (((*s == '$' || *s == '&') && s[1] == '*')
d5746 1
a5746 1
		 )
d5748 4
d5765 2
a5766 4
		if (*s == '='
                    && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
d5790 2
a5791 4
		if (*s == '='
                    && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
d5817 2
a5818 3
	    if (*s == '=' && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
d5824 2
a5825 4
	if (*s == '='
            && !PL_lex_allbrackets
            && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
        {
d5835 2
a5836 4
	    if (s[1] == '='
                && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
a5837 1
            }
a5858 4
	d = s;
	bof = FEATURE_BITWISE_IS_ENABLED;
	if (bof && s[1] == '.')
	    s++;
a5860 2
	{
	    s = d;
a5861 1
	}
d5863 1
a5863 1
	BOop(bof ? d == s-2 ? OP_SBIT_XOR : OP_NBIT_XOR : OP_BIT_XOR);
d5886 1
a5886 5
	if ((bof = FEATURE_BITWISE_IS_ENABLED) && *s == '.') {
	    s++;
	    BCop(OP_SCOMPLEMENT);
	}
	BCop(bof ? OP_NCOMPLEMENT : OP_COMPLEMENT);
a5897 3
        {
        OP *attrs;

d5899 4
d5918 4
a5921 1
	    s = skipspace(s);
d5945 1
a5945 1
		    d = scan_str(d,TRUE,TRUE,FALSE,NULL);
d5963 1
a5963 1
		    SvREFCNT_dec_NN(PL_lex_stuff);
a5989 13
		    else if (!PL_in_my && len == 5
			  && strnEQ(SvPVX(sv), "const", len))
		    {
			sv_free(sv);
			Perl_ck_warner_d(aTHX_
			    packWARN(WARN_EXPERIMENTAL__CONST_ATTR),
			   ":const is experimental"
			);
			CvANONCONST_on(PL_compcv);
			if (!CvANON(PL_compcv))
			    yyerror(":const is not permitted on named "
				    "subroutines");
		    }
d6005 1
a6005 1
		s = skipspace(d);
d6007 1
a6007 1
		    s = skipspace(s+1);
d6013 4
a6016 6
		if (*s != ';'
                    && *s != '}'
                    && !(PL_expect == XOPERATOR
			 ? (*s == '=' ||  *s == ')')
			 : (*s == '{' ||  *s == '(')))
                {
d6040 1
d6042 1
d6045 6
a6052 1
	}
d6065 1
a6065 1
	s = skipspace(s);
d6073 1
a6073 2
	PL_expect = XSTATE;
	TOKEN(';');
d6079 1
a6079 1
	s = skipspace(s);
a6109 1
	case XTERMORDORDOR:
d6136 1
a6136 7
	    /* FALLTHROUGH */
	case XATTRTERM:
	case XTERMBLOCK:
	    PL_lex_brackstack[PL_lex_brackets++] = XOPERATOR;
	    PL_lex_allbrackets++;
	    PL_expect = XSTATE;
	    break;
d6143 3
a6145 2
	case XBLOCKTERM:
	    PL_lex_brackstack[PL_lex_brackets++] = XTERM;
d6156 1
a6156 1
		s = skipspace(s);
a6166 6
		if (PL_expect == XREF && PL_oldoldbufptr != PL_last_lop) {
		    /* ${...} or @@{...} etc., but not print {...}
		     * Skip the disambiguation and treat this as a block.
		     */
		    goto block_expectation;
		}
d6186 1
a6186 1
			if (*t++ == '\\')
d6234 1
a6234 1
			    t += UTF ? UTF8SKIP(t) : 1;
d6237 1
a6237 1
		    t += UTF ? UTF8SKIP(t) : 1;
d6239 1
a6239 1
			t += UTF ? UTF8SKIP(t) : 1;
d6249 1
a6249 22
		{
		  block_expectation:
		    /* If there is an opening brace or 'sub:', treat it
		       as a term to make ${{...}}{k} and &{sub:attr...}
		       dwim.  Otherwise, treat it as a statement, so
		       map {no strict; ...} works.
		     */
		    s = skipspace(s);
		    if (*s == '{') {
			PL_expect = XTERM;
			break;
		    }
		    if (strnEQ(s, "sub", 3)) {
			d = s + 3;
			d = skipspace(d);
			if (*d == ':') {
			    PL_expect = XTERM;
			    break;
			}
		    }
		    PL_expect = XSTATE;
		}
d6258 2
a6259 1
	PL_copline = NOLINE;   /* invalidate current command line number */
d6278 7
d6301 5
d6308 4
d6313 1
a6337 3
	    d = s;
	    if ((bof = FEATURE_BITWISE_IS_ENABLED) && *s == '.')
		s++;
a6339 1
		s = d;
d6343 2
a6344 6
	    if (d == s) {
		PL_parser->saw_infix_sigil = 1;
		BAop(bof ? OP_NBIT_AND : OP_BIT_AND);
	    }
	    else
		BAop(OP_SBIT_AND);
a6349 1
	pl_yylval.ival = (OPpENTERSUB_AMPER<<8);
d6351 1
d6356 1
a6369 3
	d = s;
	if ((bof = FEATURE_BITWISE_IS_ENABLED) && *s == '.')
	    s++;
d6372 1
a6372 1
	    s = d - 1;
d6375 1
a6375 1
	BOop(bof ? s == d ? OP_NBIT_OR : OP_SBIT_OR : OP_BIT_OR);
d6381 2
a6382 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
d6389 2
a6390 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMMA)
                {
d6403 34
a6436 27
	    if (PL_expect == XSTATE
                && isALPHA(tmp)
                && (s == PL_linestart+1 || s[-2] == '\n') )
            {
                if ((PL_in_eval && !PL_rsfp && !PL_parser->filtered)
                    || PL_lex_state != LEX_NORMAL) {
                    d = PL_bufend;
                    while (s < d) {
                        if (*s++ == '\n') {
                            incline(s);
                            if (strnEQ(s,"=cut",4)) {
                                s = strchr(s,'\n');
                                if (s)
                                    s++;
                                else
                                    s = d;
                                incline(s);
                                goto retry;
                            }
                        }
                    }
                    goto retry;
                }
                s = PL_bufend;
                PL_parser->in_pod = 1;
                goto retry;
            }
d6476 4
a6479 4
		    if (*t == '/' || *t == '?'
                        || ((*t == 'm' || *t == 's' || *t == 'y')
			    && !isWORDCHAR(t[1]))
                        || (*t == 't' && t[1] == 'r' && !isWORDCHAR(t[2])))
d6483 2
a6484 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
d6499 1
a6499 1
	    if (s[1] == '<' && s[2] != '>')
d6510 2
a6511 3
		if (*s == '=' && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
d6520 2
a6521 3
		    if (!PL_lex_allbrackets
                        && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                    {
d6528 2
a6529 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
d6547 2
a6548 3
		if (*s == '=' && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
d6555 2
a6556 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_COMPARE)
                {
d6590 2
a6591 8
            if (PL_expect == XOPERATOR) {
                d = s;
                if (PL_bufptr > s) {
                    d = PL_bufptr-1;
                    PL_bufptr = PL_oldbufptr;
                }
		no_op("Array length", d);
            }
d6602 2
a6603 8
	if (PL_expect == XOPERATOR) {
	    d = s;
	    if (PL_bufptr > s) {
		d = PL_bufptr-1;
		PL_bufptr = PL_oldbufptr;
	    }
	    no_op("Scalar", d);
	}
d6614 1
a6614 1
		s = skipspace(s);
d6624 1
a6624 1
			    t += UTF ? UTF8SKIP(t) : 1;
d6626 1
a6626 1
			    PL_bufptr = skipspace(PL_bufptr); /* XXX can realloc */
d6630 2
a6631 2
					"Multidimensional syntax %"UTF8f" not supported",
                                        UTF8fARG(UTF,(int)((t - PL_bufptr) + 1), PL_bufptr));
d6716 3
a6718 2
        if (PL_expect == XPOSTDEREF)
            POSTDEREF('@@');
a6720 8
	if (PL_expect == XOPERATOR) {
            d = s;
            if (PL_bufptr > s) {
                d = PL_bufptr-1;
                PL_bufptr = PL_oldbufptr;
            }
	    no_op("Array", d);
        }
d6726 1
a6726 1
	    s = skipspace(s);
d6743 1
a6743 1
	if ((PL_expect == XOPERATOR || PL_expect == XTERMORDORDOR) && s[1] == '/') {
d6750 48
a6797 32
	else if (PL_expect == XOPERATOR) {
	    s++;
	    if (*s == '=' && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
		s--;
		TOKEN(0);
	    }
	    Mop(OP_DIVIDE);
        }
	else {
	    /* Disable warning on "study /blah/" */
	    if (PL_oldoldbufptr == PL_last_uni
	     && (*PL_last_uni != 's' || s - PL_last_uni < 5
	         || memNE(PL_last_uni, "study", 5)
	         || isWORDCHAR_lazy_if(PL_last_uni+5,UTF)
	     ))
	        check_uni();
	    s = scan_pat(s,OP_MATCH);
	    TERM(sublex_start());
	}

     case '?':			/* conditional */
	s++;
	if (!PL_lex_allbrackets
            && PL_lex_fakeeof >= LEX_FAKEEOF_IFELSE)
        {
	    s--;
	    TOKEN(0);
	}
	PL_lex_allbrackets++;
	OPERATOR('?');
d6819 2
a6820 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_RANGE)
                {
d6833 2
a6834 3
	    if (*s == '=' && !PL_lex_allbrackets
                && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
            {
d6840 1
a6840 1
	/* FALLTHROUGH */
d6850 1
a6850 1
	s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d6866 1
a6866 1
	s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d6897 2
a6898 8
	s = scan_str(s,FALSE,FALSE,FALSE,NULL);
	DEBUG_T( {
            if (s)
                printbuf("### Saw backtick string before %s\n", s);
            else
		PerlIO_printf(Perl_debug_log,
			     "### Saw unterminated backtick string\n");
        } );
d7040 1
a7040 1
		if (!PL_nexttoke) PL_expect = XSTATE;
d7045 1
a7045 1
		if (!PL_nexttoke) PL_expect = XOPERATOR;
d7072 1
a7072 1
	    off = pad_findmy_pvn(tmpbuf, len+1, 0);
d7109 2
a7110 2
					    SVt_PVCV))
                    && (cv = GvCVu(gv)))
d7117 10
a7126 9
		if (!ogv
                    && (gvp = (GV**)hv_fetch(PL_globalstash, PL_tokenbuf,
                                                              len, FALSE))
                    && (gv = *gvp)
                    && (isGV_with_GP(gv)
			? GvCVu(gv) && GvIMPORTED_CV(gv)
			:   SvPCS_IMPORTED(gv)
			&& (gv_init(gv, PL_globalstash, PL_tokenbuf,
                                                                 len, 0), 1)))
d7194 7
a7200 1
		bool safebw;
d7227 2
a7228 1
		/* See if the name is "Foo::",
d7232 2
a7233 3
		if (len > 2
                    && PL_tokenbuf[len - 2] == ':'
                    && PL_tokenbuf[len - 1] == ':')
a7243 1
		    safebw = TRUE;
d7246 10
a7255 1
		    safebw = FALSE;
d7262 1
a7262 1
						len);
d7270 7
d7284 1
a7284 1
		if (safebw)
d7291 2
a7292 9
		    rv2cv_op =
			newCVREF(OPpMAY_RETURN_CONSTANT<<8, const_op);
		    cv = lex
			? isGV(gv)
			    ? GvCV(gv)
			    : SvROK(gv) && SvTYPE(SvRV(gv)) == SVt_PVCV
				? (CV *)SvRV(gv)
				: ((CV *)gv)
			: rv2cv_op_cv(rv2cv_op, RV2CVOPCV_RETURN_STUB);
a7294 4
		/* Use this var to track whether intuit_method has been
		   called.  intuit_method returns 0 or > 255.  */
		tmp = 1;

d7297 7
a7303 8
		if (PL_oldoldbufptr
                    && PL_oldoldbufptr < PL_bufptr
                    && (PL_oldoldbufptr == PL_last_lop
		        || PL_oldoldbufptr == PL_last_uni)
                    && /* NO SKIPSPACE BEFORE HERE! */
		       (PL_expect == XREF
                        || ((PL_opargs[PL_last_lop_op] >> OASHIFT)& 7)
                                                               == OA_FILEREF))
d7308 4
a7311 1
		    s = skipspace(s);
d7315 7
a7321 4
		    if ((isIDFIRST_lazy_if(s,UTF) || *s == '$')
                        && (tmp = intuit_method(s, lex ? NULL : sv, cv)))
                    {
			goto method;
d7329 4
a7332 4
			( !immediate_paren && (PL_last_lop_op == OP_SORT
                         || (!cv
                             && (PL_last_lop_op != OP_MAPSTART
                                 && PL_last_lop_op != OP_GREPSTART))))
d7334 1
a7334 2
			    && ((PL_opargs[PL_last_lop_op] & OA_CLASS_MASK)
                                                            == OA_FILESTATOP))
d7343 5
d7349 1
d7355 7
a7361 11
		    if (gvp || (lex && !off)) {
			assert (cSVOPx(pl_yylval.opval)->op_sv == sv);
			/* This is our own scalar, created a few lines
			   above, so this is safe. */
			SvREADONLY_off(sv);
			sv_setpv(sv, PL_tokenbuf);
			if (UTF && !IN_BYTES
			 && is_utf8_string((U8*)PL_tokenbuf, len))
			      SvUTF8_on(sv);
			SvREADONLY_on(sv);
		    }
d7377 7
d7386 8
d7407 2
a7408 3
		    if (!PL_lex_allbrackets
                        && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                    {
d7410 1
a7410 4
                    }
		    PL_expect = XBLOCKTERM;
		    PL_bufptr = s;
		    return REPORT(METHOD);
d7415 1
a7415 1
		if (tmp == 1 && !orig_keyword
d7417 1
a7417 11
			&& (tmp = intuit_method(s, lex ? NULL : sv, cv))) {
		  method:
		    if (lex && !off) {
			assert(cSVOPx(pl_yylval.opval)->op_sv == sv);
			SvREADONLY_off(sv);
			sv_setpvn(sv, PL_tokenbuf, len);
			if (UTF && !IN_BYTES
			 && is_utf8_string((U8*)PL_tokenbuf, len))
			    SvUTF8_on (sv);
			else SvUTF8_off(sv);
		    }
d7419 2
a7420 3
		    if (tmp == METHOD && !PL_lex_allbrackets
                        && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                    {
a7421 1
                    }
d7428 7
d7460 3
d7495 74
a7568 12
			if (*proto == '&' && *s == '{') {
			    if (PL_curstash)
				sv_setpvs(PL_subname, "__ANON__");
			    else
				sv_setpvs(PL_subname, "__ANON__::__ANON__");
			    if (!PL_lex_allbrackets
                                && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                            {
				PL_lex_fakeeof = LEX_FAKEEOF_LOWLOGIC;
                            }
			    PREBLOCK(LSTOPSUB);
			}
d7570 1
d7574 2
a7575 3
		    if (!PL_lex_allbrackets
                        && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                    {
a7576 1
                    }
d7578 1
d7665 1
a7665 1
#if defined(HAS_FCNTL) && defined(F_SETFD) && defined(FD_CLOEXEC)
d7668 1
a7668 3
                    if (fd >= 3) {
                        fcntl(fd,F_SETFD, FD_CLOEXEC);
                    }
d7703 1
a7703 1
		    else if (IN_ENCODING) {
d7709 1
a7709 1
			XPUSHs(_get_encoding());
d7723 15
d7744 1
a7744 3
	    FUN0OP(CvCLONE(PL_compcv)
			? newOP(OP_RUNCV, 0)
			: newPVOP(OP_RUNCV,0,NULL));
d7879 1
a7879 1
	    s = skipspace(s);
d7888 1
a7888 1
		    d = skipspace(d);
d7927 2
d7947 2
d7952 1
a7952 1
	    s = skipspace(s);
d8001 1
a8001 1
	    s = skipspace(s);
d8004 3
d8008 2
a8009 3
		if ((PL_bufend - p) >= 3
                    && strnEQ(p, "my", 2) && isSPACE(*(p + 2)))
                {
d8011 2
a8012 3
                }
		else if ((PL_bufend - p) >= 4
                         && strnEQ(p, "our", 3) && isSPACE(*(p + 3)))
d8014 1
a8014 1
		p = skipspace(p);
d8018 1
a8018 1
		    p = skipspace(p);
d8022 3
d8060 2
d8186 2
a8255 8
	    if (PL_in_my) {
	        yyerror(Perl_form(aTHX_
	                          "Can't redeclare \"%s\" in \"%s\"",
	                           tmp      == KEY_my    ? "my" :
	                           tmp      == KEY_state ? "state" : "our",
	                           PL_in_my == KEY_my    ? "my" :
	                           PL_in_my == KEY_state ? "state" : "our"));
	    }
d8257 1
a8257 1
	    s = skipspace(s);
d8259 3
a8277 1
                    int len;
d8279 1
a8279 2
		    len = my_snprintf(tmpbuf, sizeof(tmpbuf), "No such class %.1000s", PL_tokenbuf);
                    PERL_MY_SNPRINTF_POST_GUARD(len, sizeof(tmpbuf));
d8282 7
d8294 2
d8305 1
a8305 1
	    TOKEN(USE);
d8308 1
a8308 1
	    if (*s == '(' || (s = skipspace(s), *s == '('))
d8311 2
a8312 3
		if (!PL_lex_allbrackets
                    && PL_lex_fakeeof > LEX_FAKEEOF_LOWLOGIC)
                {
a8313 1
                }
d8318 1
a8318 1
	    s = skipspace(s);
d8378 1
a8378 1
	    s = skipspace(s);
d8380 2
a8381 1
	    PREBLOCK(PACKAGE);
d8387 1
a8387 1
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d8399 1
a8399 1
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d8440 4
a8443 2
	    SvREFCNT_dec_NN(PL_lex_stuff);
	    PL_lex_stuff = NULL;
d8450 1
a8450 1
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d8463 1
a8463 1
	    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d8473 2
a8474 1
	    s = skipspace(s);
d8487 1
a8487 1
		    yyerror("<> at require-statement should be quotes");
d8495 1
a8495 1
	    PL_expect = PL_nexttoke ? XOPERATOR : XTERM;
d8506 2
d8646 1
a8646 1
	    s = skipspace(s);
d8683 1
d8685 1
d8687 12
d8701 1
d8703 2
a8704 3
		if (isIDFIRST_lazy_if(s,UTF)
                    || *s == '\''
                    || (*s == ':' && s[1] == ':'))
d8706 3
d8714 4
d8720 1
d8724 1
a8724 1
			    PL_tokenbuf, len + 1, 0
d8737 8
d8746 1
d8763 4
d8768 1
d8774 1
d8780 1
a8780 1
		    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d8787 13
d8801 1
d8808 1
a8808 7
		else if ((*s != '{' && *s != '(') && key != KEY_format) {
                    assert(key == KEY_sub || key == KEY_AUTOLOAD ||
                           key == KEY_DESTROY || key == KEY_BEGIN ||
                           key == KEY_UNITCHECK || key == KEY_CHECK ||
                           key == KEY_INIT || key == KEY_END ||
                           key == KEY_my || key == KEY_state ||
                           key == KEY_our);
d8815 12
d8833 1
d8841 1
d8843 1
d8935 1
a8935 1
	    TOKEN(USE);
d8979 2
a8980 3
		if (*s == '=' && !PL_lex_allbrackets
                    && PL_lex_fakeeof >= LEX_FAKEEOF_ASSIGN)
                {
a8981 1
                }
d9019 1
a9044 1
                /* "my" variable %s can't be in a package */
d9048 1
a9048 3
                            PL_in_my == KEY_my ? "my" : "state",
                            *PL_tokenbuf == '&' ? "subroutin" : "variabl",
                            PL_tokenbuf),
d9067 1
a9067 1
                                 0);
d9081 4
a9084 1
                    GV_ADDMULTI,
d9102 2
a9103 5
    if (ckWARN(WARN_AMBIGUOUS)
        && pit == '@@'
        && PL_lex_state != LEX_NORMAL
        && !PL_lex_brackets)
    {
d9108 2
a9109 2
		&& !( PL_tokenbuf[2] == '\0'
                      && ( PL_tokenbuf[1] == '-' || PL_tokenbuf[1] == '+' ))
d9128 1
a9128 1
		     (PL_in_eval ? GV_ADDMULTI : GV_ADD)
d9139 2
a9178 1
	    PADOFFSET off;
a9184 7
	    if (s - w <= 254) {
		char tmpbuf[256];
		Copy(w, tmpbuf+1, s - w, char);
		*tmpbuf = '&';
		off = pad_findmy_pvn(tmpbuf, s-w+1, 0);
		if (off != NOT_IN_PAD) return;
	    }
d9202 1
a9202 1
    dSP;
d9279 1
a9279 1
  now_ok:
d9338 1
d9390 1
a9402 28
/* Is the byte 'd' a legal single character identifier name?  'u' is true
 * iff Unicode semantics are to be used.  The legal ones are any of:
 *  a) all ASCII characters except:
 *          1) control and space-type ones, like NUL, SOH, \t, and SPACE;
 *          2) '{'
 *     The final case currently doesn't get this far in the program, so we
 *     don't test for it.  If that were to change, it would be ok to allow it.
 *  c) When not under Unicode rules, any upper Latin1 character
 *  d) Otherwise, when unicode rules are used, all XIDS characters.
 *
 *      Because all ASCII characters have the same representation whether
 *      encoded in UTF-8 or not, we can use the foo_A macros below and '\0' and
 *      '{' without knowing if is UTF-8 or not.
 * EBCDIC already uses the rules that ASCII platforms will use after the
 * deprecation cycle; see comment below about the deprecation. */
#ifdef EBCDIC
#   define VALID_LEN_ONE_IDENT(s, is_utf8)                                    \
    (isGRAPH_A(*(s)) || ((is_utf8)                                            \
                         ? isIDFIRST_utf8((U8*) (s))                          \
                         : (isGRAPH_L1(*s)                                    \
                            && LIKELY((U8) *(s) != LATIN1_TO_NATIVE(0xAD)))))
#else
#   define VALID_LEN_ONE_IDENT(s, is_utf8)                                    \
    (isGRAPH_A(*(s)) || ((is_utf8)                                            \
                         ? isIDFIRST_utf8((U8*) (s))                          \
                         : ! isASCII_utf8((U8*) (s))))
#endif

d9406 1
d9417 2
a9418 2
    if (isSPACE(*s) || !*s)
	s = skipspace(s);
d9426 1
a9426 1
    else {  /* See if it is a "normal" identifier */
d9438 6
a9443 9

    /* Here, it is not a run-of-the-mill identifier name */

    if (*s == '$' && s[1]
        && (isIDFIRST_lazy_if(s+1,is_utf8)
            || isDIGIT_A((U8)s[1])
            || s[1] == '$'
            || s[1] == '{'
            || strnEQ(s+1,"::",2)) )
d9456 1
a9456 1
            s = skipspace(s);
d9459 19
a9477 4
    if ((s <= PL_bufend - (is_utf8)
                          ? UTF8SKIP(s)
                          : 1)
        && VALID_LEN_ONE_IDENT(s, is_utf8))
d9479 2
a9480 10
        /* Deprecate all non-graphic characters.  Include SHY as a non-graphic,
         * because often it has no graphic representation.  (We can't get to
         * here with SHY when 'is_utf8' is true, so no need to include a UTF-8
         * test for it.) */
        if ((is_utf8)
            ? ! isGRAPH_utf8( (U8*) s)
            : (! isGRAPH_L1( (U8) *s)
               || UNLIKELY((U8) *(s) == LATIN1_TO_NATIVE(0xAD))))
        {
            deprecate("literal non-graphic characters in variable names");
d9482 1
a9482 1

d9511 2
a9512 2
            d += is_utf8 ? UTF8SKIP(d) : 1;
            parse_ident(&s, &d, e, 1, is_utf8);
d9516 1
a9516 1
                s = skipspace(s);
d9555 1
a9555 1
            s = skipspace(s);
d9567 3
a9569 5
		if (ckWARN(WARN_AMBIGUOUS)
                    && (keyword(dest, d - dest, 0)
		        || get_cvn_flags(dest, d - dest, is_utf8
                           ? SVf_UTF8
                           : 0)))
d9572 1
a9572 1
                                        SVs_TEMP | (is_utf8 ? SVf_UTF8 : 0) );
d9579 1
a9579 1
			funny, SVfARG(tmp), funny, SVfARG(tmp));
d9599 1
a9599 1
S_pmflag(pTHX_ const char* const valid_flags, U32 * pmfl, char** s, char* charset, unsigned int * x_mod_count) {
d9601 6
a9606 6
    /* Adds, subtracts to/from 'pmfl' based on the next regex modifier flag
     * found in the parse starting at 's', based on the subset that are valid
     * in this context input to this routine in 'valid_flags'. Advances s.
     * Returns TRUE if the input should be treated as a valid flag, so the next
     * char may be as well; otherwise FALSE. 'charset' should point to a NUL
     * upon first call on the current regex.  This routine will set it to any
d9628 1
a9628 1
        CASE_STD_PMMOD_FLAGS_PARSE_SET(pmfl, *x_mod_count);
d9698 1
d9704 3
a9706 1
    unsigned int x_mod_count = 0;
d9710 11
a9720 3
    s = scan_str(start,TRUE,FALSE, (PL_in_eval & EVAL_RE_REPARSING), NULL);
    if (!s)
	Perl_croak(aTHX_ "Search pattern not terminated");
d9745 3
d9767 7
a9773 3
    while (*s && S_pmflag(aTHX_ valid_flags, &(pm->op_pmflags),
                                &s, &charset, &x_mod_count))
    {};
a9780 2
    STD_PMMOD_FLAGS_PARSE_X_WARN(x_mod_count);

d9789 1
d9796 3
a9798 1
    unsigned int x_mod_count = 0;
d9805 2
a9806 1
    s = scan_str(start, TRUE, FALSE, FALSE, &t);
d9812 9
d9824 1
a9824 1
    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d9826 4
a9829 2
	SvREFCNT_dec_NN(PL_lex_stuff);
	PL_lex_stuff = NULL;
d9836 8
d9850 1
a9850 2
	else if (! S_pmflag(aTHX_ S_PAT_MODS, &(pm->op_pmflags),
                                  &s, &charset, &x_mod_count))
d9856 8
a9863 2
    STD_PMMOD_FLAGS_PARSE_X_WARN(x_mod_count);

d9901 1
d9908 3
d9917 1
a9917 1
    s = scan_str(start,FALSE,FALSE,FALSE,&t);
d9922 9
d9932 1
a9932 1
    s = scan_str(s,FALSE,FALSE,FALSE,NULL);
d9934 4
a9937 2
	SvREFCNT_dec_NN(PL_lex_stuff);
	PL_lex_stuff = NULL;
d9940 5
d9947 3
d9980 8
d10019 1
d10030 6
d10063 4
a10066 8
	peek = s;
	while (isWORDCHAR_lazy_if(peek,UTF)) {
	    peek += UTF ? UTF8SKIP(peek) : 1;
	}
	len = (peek - s >= e - d) ? (e - d) : (peek - s);
	Copy(s, d, len, char);
	s += len;
	d += len;
d10074 9
d10107 11
d10137 1
a10137 1
	PERL_CONTEXT * const cx = CX_CUR();
d10157 2
a10158 7
	       evaluated to false.  So shared can never be null.  Or so you
	       might think.  Odd syntax errors like s;@@{<<; can gobble up
	       the implicit semicolon at the end of a flie, causing the
	       file handle to be closed even when we are not in a string
	       eval.  So shared may be null in that case.  */
	    if (UNLIKELY(!shared))
		goto interminable;
d10167 1
a10167 1
	else {	/* eval or we've already hit EOF */
d10169 1
a10169 2
	    if (!s)
                goto interminable;
d10174 2
a10175 3
	while (s < bufend - len + 1
               && memNE(s,PL_tokenbuf,len) )
        {
d10183 9
d10213 3
a10215 4
	if (cxstack_ix >= 0
            && CxTYPE(cx) == CXt_EVAL
            && CxOLD_OP_TYPE(cx) == OP_ENTEREVAL
            && cx->blk_eval.cur_text == linestr)
a10231 1
      char *oldbufptr_save;
a10237 1
      oldbufptr_save = PL_oldbufptr;
d10241 9
d10255 1
a10255 9
	    /* Simply freeing linestr_save might seem simpler here, as it
	       does not matter what PL_linestr points to, since we are
	       about to croak; but in a quote-like op, linestr_save
	       will have been prospectively freed already, via
	       SAVEFREESV(PL_linestr) in sublex_push, so its easier to
	       restore PL_linestr. */
	    SvREFCNT_dec_NN(PL_linestr);
	    PL_linestr = linestr_save;
            PL_oldbufptr = oldbufptr_save;
d10267 3
d10274 2
a10275 2
	    if (   (PL_bufend[-2] == '\r' && PL_bufend[-1] == '\n')
                || (PL_bufend[-2] == '\n' && PL_bufend[-1] == '\r'))
d10287 1
a10287 2
	if (*s == term && PL_bufend-s >= len
	 && memEQ(s,PL_tokenbuf + 1,len)) {
a10291 1
            PL_oldbufptr = oldbufptr_save;
d10307 2
a10308 2
	else if (IN_ENCODING)
	    sv_recode_to_utf8(tmpstr, _get_encoding());
a10327 1
   <<>>		read from ARGV without magic open
d10339 1
a10342 1
    bool nomagicopen = FALSE;
d10351 1
a10351 8
    if (s[1] == '<' && s[2] == '>' && s[3] == '>') {
        nomagicopen = TRUE;
        *d = '\0';
        len = 0;
        s += 3;
    }
    else
        s = delimcpy(d, e, s + 1, end, '>', &len);	/* extract until > */
d10385 1
a10385 1
	s = scan_str(start,FALSE,FALSE,FALSE,NULL);
d10401 1
d10412 1
a10412 1
	    const PADOFFSET tmp = pad_findmy_pvn(d, len, 0);
d10436 1
a10436 1
              intro_sym:
d10438 3
a10440 1
				GV_ADDMULTI | ( UTF ? SVf_UTF8 : 0 ),
d10451 2
d10466 1
a10466 1
		: (OP*)newUNOP(OP_READLINE, nomagicopen ? OPf_SPECIAL : 0, newGVOP(OP_GV, 0, gv));
d10478 1
a10478 2
        keep_bracketed_quoted   preserve \ quoting of embedded delimiters, but
                                only if they are of the open/close form
d10482 3
d10530 2
a10531 2
S_scan_str(pTHX_ char *start, int keep_bracketed_quoted, int keep_delims, int re_reparse,
		 char **delimp
d10534 1
d10546 1
d10548 4
d10557 1
a10557 1
	s = skipspace(s);
d10560 8
d10595 10
a10604 2
    if (PL_multi_open == PL_multi_close) {
        keep_bracketed_quoted = FALSE;
d10618 7
d10626 1
a10626 1
	if (IN_ENCODING && !UTF && !re_reparse) {
d10631 1
a10631 1
		const bool found = sv_cat_decode(sv, _get_encoding(), PL_linestr,
d10690 1
a10690 1
			    if (!keep_bracketed_quoted) {
d10708 1
a10708 1
				if (!keep_bracketed_quoted && *(t+1) == PL_multi_open)
d10749 1
a10749 1
		    if (!keep_bracketed_quoted
d10754 2
a10755 1
		    else /* any other quotes are simply copied straight through */
d10784 2
a10785 2
		    if (!keep_bracketed_quoted
                       && ((s[1] == PL_multi_open) || (s[1] == PL_multi_close)))
d10788 48
d10839 1
a10839 1
                }
d10863 2
a10864 2
	    if (   (to[-2] == '\r' && to[-1] == '\n')
                || (to[-2] == '\n' && to[-1] == '\r'))
d10881 9
d10898 3
d10905 13
a10917 1
    if (!IN_ENCODING || UTF || re_reparse) {
d10923 15
a10937 1
    if (has_utf8 || (IN_ENCODING && !re_reparse))
d10972 3
a10974 4
  0b[01](_?[01])*                                       binary integers
  0[0-7](_?[0-7])*                                      octal integers
  0x[0-9A-Fa-f](_?[0-9A-Fa-f])*                         hexadecimal integers
  0x[0-9A-Fa-f](_?[0-9A-Fa-f])*(?:\.\d*)?p[+-]?[0-9]+   hexadecimal floats
d10987 1
a10995 23
    /* Hexadecimal floating point.
     *
     * In many places (where we have quads and NV is IEEE 754 double)
     * we can fit the mantissa bits of a NV into an unsigned quad.
     * (Note that UVs might not be quads even when we have quads.)
     * This will not work everywhere, though (either no quads, or
     * using long doubles), in which case we have to resort to NV,
     * which will probably mean horrible loss of precision due to
     * multiple fp operations. */
    bool hexfp = FALSE;
    int total_bits = 0;
    int significant_bits = 0;
#if NVSIZE == 8 && defined(HAS_QUAD) && defined(Uquad_t)
#  define HEXFP_UQUAD
    Uquad_t hexfp_uquad = 0;
    int hexfp_frac_bits = 0;
#else
#  define HEXFP_NV
    NV hexfp_nv = 0.0;
#endif
    NV hexfp_mult = 1.0;
    UV high_non_zero = 0; /* highest digit */
    int non_zero_integer_digits = 0;
d11038 1
a11038 1
	    if (isALPHA_FOLD_EQ(s[1], 'x')) {
d11042 1
a11042 1
	    } else if (isALPHA_FOLD_EQ(s[1], 'b')) {
d11048 1
a11048 1
	    else if (s[1] == '.' || isALPHA_FOLD_EQ(s[1], 'e'))
d11090 1
a11090 1
		    /* FALLTHROUGH */
d11097 1
a11097 1
		    /* FALLTHROUGH */
a11119 2
                        total_bits += shift;

a11141 13

                    if (high_non_zero == 0 && b > 0)
                        high_non_zero = b;

                    if (high_non_zero)
                        non_zero_integer_digits++;

                    /* this could be hexfp, but peek ahead
                     * to avoid matching ".." */
                    if (UNLIKELY(HEXFP_PEEK(s))) {
                        goto out;
                    }

a11155 148
            if (UNLIKELY(HEXFP_PEEK(s))) {
                /* Do sloppy (on the underbars) but quick detection
                 * (and value construction) for hexfp, the decimal
                 * detection will shortly be more thorough with the
                 * underbar checks. */
                const char* h = s;
                significant_bits = non_zero_integer_digits * shift;
#ifdef HEXFP_UQUAD
                hexfp_uquad = u;
#else /* HEXFP_NV */
                hexfp_nv = u;
#endif
                /* Ignore the leading zero bits of
                 * the high (first) non-zero digit. */
                if (high_non_zero) {
                    if (high_non_zero < 0x8)
                        significant_bits--;
                    if (high_non_zero < 0x4)
                        significant_bits--;
                    if (high_non_zero < 0x2)
                        significant_bits--;
                }

                if (*h == '.') {
#ifdef HEXFP_NV
                    NV nv_mult = 1.0;
#endif
                    bool accumulate = TRUE;
                    for (h++; (isXDIGIT(*h) || *h == '_'); h++) {
                        if (isXDIGIT(*h)) {
                            U8 b = XDIGIT_VALUE(*h);
                            significant_bits += shift;
#ifdef HEXFP_UQUAD
                            if (accumulate) {
                                if (significant_bits < NV_MANT_DIG) {
                                    /* We are in the long "run" of xdigits,
                                     * accumulate the full four bits. */
                                    hexfp_uquad <<= shift;
                                    hexfp_uquad |= b;
                                    hexfp_frac_bits += shift;
                                } else {
                                    /* We are at a hexdigit either at,
                                     * or straddling, the edge of mantissa.
                                     * We will try grabbing as many as
                                     * possible bits. */
                                    int tail =
                                      significant_bits - NV_MANT_DIG;
                                    if (tail <= 0)
                                       tail += shift;
                                    hexfp_uquad <<= tail;
                                    hexfp_uquad |= b >> (shift - tail);
                                    hexfp_frac_bits += tail;

                                    /* Ignore the trailing zero bits
                                     * of the last non-zero xdigit.
                                     *
                                     * The assumption here is that if
                                     * one has input of e.g. the xdigit
                                     * eight (0x8), there is only one
                                     * bit being input, not the full
                                     * four bits.  Conversely, if one
                                     * specifies a zero xdigit, the
                                     * assumption is that one really
                                     * wants all those bits to be zero. */
                                    if (b) {
                                        if ((b & 0x1) == 0x0) {
                                            significant_bits--;
                                            if ((b & 0x2) == 0x0) {
                                                significant_bits--;
                                                if ((b & 0x4) == 0x0) {
                                                    significant_bits--;
                                                }
                                            }
                                        }
                                    }

                                    accumulate = FALSE;
                                }
                            } else {
                                /* Keep skipping the xdigits, and
                                 * accumulating the significant bits,
                                 * but do not shift the uquad
                                 * (which would catastrophically drop
                                 * high-order bits) or accumulate the
                                 * xdigits anymore. */
                            }
#else /* HEXFP_NV */
                            if (accumulate) {
                                nv_mult /= 16.0;
                                if (nv_mult > 0.0)
                                    hexfp_nv += b * nv_mult;
                                else
                                    accumulate = FALSE;
                            }
#endif
                        }
                        if (significant_bits >= NV_MANT_DIG)
                            accumulate = FALSE;
                    }
                }

                if ((total_bits > 0 || significant_bits > 0) &&
                    isALPHA_FOLD_EQ(*h, 'p')) {
                    bool negexp = FALSE;
                    h++;
                    if (*h == '+')
                        h++;
                    else if (*h == '-') {
                        negexp = TRUE;
                        h++;
                    }
                    if (isDIGIT(*h)) {
                        I32 hexfp_exp = 0;
                        while (isDIGIT(*h) || *h == '_') {
                            if (isDIGIT(*h)) {
                                hexfp_exp *= 10;
                                hexfp_exp += *h - '0';
#ifdef NV_MIN_EXP
                                if (negexp
                                    && -hexfp_exp < NV_MIN_EXP - 1) {
                                    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                                   "Hexadecimal float: exponent underflow");
                                    break;
                                }
#endif
#ifdef NV_MAX_EXP
                                if (!negexp
                                    && hexfp_exp > NV_MAX_EXP - 1) {
                                    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                                   "Hexadecimal float: exponent overflow");
                                    break;
                                }
#endif
                            }
                            h++;
                        }
                        if (negexp)
                            hexfp_exp = -hexfp_exp;
#ifdef HEXFP_UQUAD
                        hexfp_exp -= hexfp_frac_bits;
#endif
                        hexfp_mult = pow(2.0, hexfp_exp);
                        hexfp = TRUE;
                        goto decimal;
                    }
                }
            }

d11189 1
a11189 7
        floatit = FALSE;
        if (hexfp) {
            floatit = TRUE;
            *d++ = '0';
            *d++ = 'x';
            s = start + 2;
        }
d11192 1
a11192 4
	while (isDIGIT(*s)
               || *s == '_'
               || UNLIKELY(hexfp && isXDIGIT(*s)))
        {
d11232 1
a11232 5
	    for (; isDIGIT(*s)
                   || *s == '_'
                   || UNLIKELY(hexfp && isXDIGIT(*s));
                 s++)
            {
d11258 2
a11259 16
	if ((isALPHA_FOLD_EQ(*s, 'e')
              || UNLIKELY(hexfp && isALPHA_FOLD_EQ(*s, 'p')))
            && strchr("+-0123456789_", s[1]))
        {
            floatit = TRUE;

	    /* regardless of whether user said 3E5 or 3e5, use lower 'e',
               ditto for p (hexfloats) */
            if ((isALPHA_FOLD_EQ(*s, 'e'))) {
		/* At least some Mach atof()s don't grok 'E' */
                *d++ = 'e';
            }
            else if (UNLIKELY(hexfp && (isALPHA_FOLD_EQ(*s, 'p')))) {
                *d++ = 'p';
            }

d11262 2
d11291 2
a11292 2
		   if (((lastub && s == lastub + 1)
                        || (!isDIGIT(s[1]) && s[1] != '_')))
d11324 1
a11324 1
            STORE_LC_NUMERIC_UNDERLYING_SET_STANDARD();
d11327 3
a11329 16
            if (UNLIKELY(hexfp)) {
#  ifdef NV_MANT_DIG
                if (significant_bits > NV_MANT_DIG)
                    Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
                                   "Hexadecimal float: mantissa overflow");
#  endif
#ifdef HEXFP_UQUAD
                nv = hexfp_uquad * hexfp_mult;
#else /* HEXFP_NV */
                nv = hexfp_nv * hexfp_mult;
#endif
            } else {
                nv = Atof(PL_tokenbuf);
            }
            RESTORE_LC_NUMERIC_UNDERLYING();
            sv = newSVnv(nv);
d11343 1
a11343 1
    vstring:
d11366 1
d11372 9
d11429 8
d11442 3
d11458 1
a11458 1
		|| *s2 == '\v')
d11461 1
d11466 1
d11473 2
a11474 2
	    else if (IN_ENCODING)
		sv_recode_to_utf8(stuff, _get_encoding());
d11476 1
d11485 9
d11500 1
d11516 2
a11517 1
	CvPADLIST(PL_compcv)->xpadl_outid = CvPADLIST(outsidecv)->xpadl_id;
d11525 2
d11531 1
d11552 1
d11563 3
a11565 6
    else if (   PL_oldoldbufptr
             && PL_bufptr > PL_oldoldbufptr
             && PL_bufptr - PL_oldoldbufptr < 200
             && PL_oldoldbufptr != PL_oldbufptr
             && PL_oldbufptr != PL_bufptr)
    {
d11580 2
a11581 4
    else if (  PL_oldbufptr
            && PL_bufptr > PL_oldbufptr
            && PL_bufptr - PL_oldbufptr < 200
            && PL_oldbufptr != PL_bufptr) {
d11598 3
a11600 3
    else if (yychar == YYEMPTY) {
	if (    PL_lex_state == LEX_NORMAL
            || (PL_lex_state == LEX_KNOWNEXT && PL_lex_defer == LEX_NORMAL))
a11635 1
	PL_in_eval &= ~EVAL_WARNONLY;
d11657 1
a11724 1
        break;
d11748 1
d11916 1
d11962 4
a11965 1

d12052 1
a12052 1
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
d12084 1
a12084 1
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
d12116 1
a12116 1
If C<flags> has the C<PARSE_OPTIONAL> bit set, then the expression is optional,
d12149 2
a12150 2
signals a postfix expression-statement modifier.  If C<flags> has the
C<PARSE_OPTIONAL> bit set, then the expression is optional, otherwise it is
d12196 1
a12196 1
The C<flags> parameter is reserved for future use, and must always
d12234 1
a12234 1
The C<flags> parameter is reserved for future use, and must always
d12254 1
a12254 1
the code to be parsed.  If C<flags> has the C<PARSE_OPTIONAL> bit set, then the
d12338 1
a12338 1
The C<flags> parameter is reserved for future use, and must always
d12376 1
a12376 1
The C<flags> parameter is reserved for future use, and must always
d12428 1
d12469 2
a12470 3
			if (defexpr->op_type == OP_UNDEF
                            && !(defexpr->op_flags & OPf_KIDS))
                        {
d12509 4
a12512 10
		            op_convert_list(OP_DIE, 0,
		                op_convert_list(OP_SPRINTF, 0,
		                    op_append_list(OP_LIST,
		                        newSVOP(OP_CONST, 0,
		                            newSVpvs("Odd name/value argument for subroutine at %s line %d.\n")),
		                        newSLICEOP(0,
		                            op_append_list(OP_LIST,
		                                newSVOP(OP_CONST, 0, newSViv(1)),
		                                newSVOP(OP_CONST, 0, newSViv(2))),
		                            newOP(OP_CALLER, 0))))));
d12575 3
a12577 10
		    op_convert_list(OP_DIE, 0,
		        op_convert_list(OP_SPRINTF, 0,
		            op_append_list(OP_LIST,
		                newSVOP(OP_CONST, 0,
		                    newSVpvs("Too few arguments for subroutine at %s line %d.\n")),
		                newSLICEOP(0,
		                    op_append_list(OP_LIST,
		                        newSVOP(OP_CONST, 0, newSViv(1)),
		                        newSVOP(OP_CONST, 0, newSViv(2))),
		                    newOP(OP_CALLER, 0))))))),
d12588 3
a12590 10
		    op_convert_list(OP_DIE, 0,
		        op_convert_list(OP_SPRINTF, 0,
		            op_append_list(OP_LIST,
		                newSVOP(OP_CONST, 0,
		                    newSVpvs("Too many arguments for subroutine at %s line %d.\n")),
		                newSLICEOP(0,
		                    op_append_list(OP_LIST,
		                        newSVOP(OP_CONST, 0, newSViv(1)),
		                        newSVOP(OP_CONST, 0, newSViv(2))),
		                    newOP(OP_CALLER, 0))))))),
d12597 6
@


