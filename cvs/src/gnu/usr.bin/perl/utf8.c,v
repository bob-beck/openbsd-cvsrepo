head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.14.0.8
	OPENBSD_6_0_BASE:1.1.1.14
	OPENBSD_5_9:1.1.1.14.0.2
	OPENBSD_5_9_BASE:1.1.1.14
	OPENBSD_5_8:1.1.1.14.0.4
	OPENBSD_5_8_BASE:1.1.1.14
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.1.1.13.0.2
	OPENBSD_5_7_BASE:1.1.1.13
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.1.1.12.0.4
	OPENBSD_5_6_BASE:1.1.1.12
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.11.0.6
	OPENBSD_5_5_BASE:1.1.1.11
	OPENBSD_5_4:1.1.1.11.0.2
	OPENBSD_5_4_BASE:1.1.1.11
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.1.1.10.0.10
	OPENBSD_5_3_BASE:1.1.1.10
	OPENBSD_5_2:1.1.1.10.0.8
	OPENBSD_5_2_BASE:1.1.1.10
	OPENBSD_5_1_BASE:1.1.1.10
	OPENBSD_5_1:1.1.1.10.0.6
	OPENBSD_5_0:1.1.1.10.0.4
	OPENBSD_5_0_BASE:1.1.1.10
	OPENBSD_4_9:1.1.1.10.0.2
	OPENBSD_4_9_BASE:1.1.1.10
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.2
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.54;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.08.50;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.08.50;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.22.26;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.52;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.39;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.45.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.16.39;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.48;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.11;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.06.42;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.14;
commitid	B31cAbBIXiCqnL97;

1.1.1.14
date	2015.04.25.19.10.14;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.15
date	2017.08.14.13.45.31;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    utf8.c
 *
 *    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * 'What a fix!' said Sam.  'That's the one place in all the lands we've ever
 *  heard of that we don't want to see any closer; and that's the one place
 *  we're trying to get to!  And that's just where we can't get, nohow.'
 *
 *     [p.603 of _The Lord of the Rings_, IV/I: "The Taming of Sméagol"]
 *
 * 'Well do I understand your speech,' he answered in the same language;
 * 'yet few strangers do so.  Why then do you not speak in the Common Tongue,
 *  as is the custom in the West, if you wish to be answered?'
 *                           --Gandalf, addressing Théoden's door wardens
 *
 *     [p.508 of _The Lord of the Rings_, III/vi: "The King of the Golden Hall"]
 *
 * ...the travellers perceived that the floor was paved with stones of many
 * hues; branching runes and strange devices intertwined beneath their feet.
 *
 *     [p.512 of _The Lord of the Rings_, III/vi: "The King of the Golden Hall"]
 */

#include "EXTERN.h"
#define PERL_IN_UTF8_C
#include "perl.h"
#include "invlist_inline.h"

static const char unees[] =
    "Malformed UTF-8 character (unexpected end of string)";
static const char cp_above_legal_max[] =
 "Use of code point 0x%"UVXf" is deprecated; the permissible max is 0x%"UVXf"";

#define MAX_NON_DEPRECATED_CP ((UV) (IV_MAX))

/*
=head1 Unicode Support
These are various utility functions for manipulating UTF8-encoded
strings.  For the uninitiated, this is a method of representing arbitrary
Unicode characters as a variable number of bytes, in such a way that
characters in the ASCII range are unmodified, and a zero byte never appears
within non-zero characters.

=cut
*/

/*
=for apidoc is_invariant_string

Returns true iff the first C<len> bytes of the string C<s> are the same
regardless of the UTF-8 encoding of the string (or UTF-EBCDIC encoding on
EBCDIC machines).  That is, if they are UTF-8 invariant.  On ASCII-ish
machines, all the ASCII characters and only the ASCII characters fit this
definition.  On EBCDIC machines, the ASCII-range characters are invariant, but
so also are the C1 controls and C<\c?> (which isn't in the ASCII range on
EBCDIC).

If C<len> is 0, it will be calculated using C<strlen(s)>, (which means if you
use this option, that C<s> can't have embedded C<NUL> characters and has to
have a terminating C<NUL> byte).

See also L</is_utf8_string>(), L</is_utf8_string_loclen>(), and L</is_utf8_string_loc>().

=cut
*/

bool
Perl_is_invariant_string(const U8 *s, STRLEN len)
{
    const U8* const send = s + (len ? len : strlen((const char *)s));
    const U8* x = s;

    PERL_ARGS_ASSERT_IS_INVARIANT_STRING;

    for (; x < send; ++x) {
	if (!UTF8_IS_INVARIANT(*x))
	    break;
    }

    return x == send;
}

/*
=for apidoc uvoffuni_to_utf8_flags

THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
Instead, B<Almost all code should use L</uvchr_to_utf8> or
L</uvchr_to_utf8_flags>>.

This function is like them, but the input is a strict Unicode
(as opposed to native) code point.  Only in very rare circumstances should code
not be using the native code point.

For details, see the description for L</uvchr_to_utf8_flags>.

=cut
*/

#define HANDLE_UNICODE_SURROGATE(uv, flags)                         \
    STMT_START {                                                    \
        if (flags & UNICODE_WARN_SURROGATE) {                       \
            Perl_ck_warner_d(aTHX_ packWARN(WARN_SURROGATE),        \
                                "UTF-16 surrogate U+%04"UVXf, uv);  \
        }                                                           \
        if (flags & UNICODE_DISALLOW_SURROGATE) {                   \
            return NULL;                                            \
        }                                                           \
    } STMT_END;

#define HANDLE_UNICODE_NONCHAR(uv, flags)                           \
    STMT_START {                                                    \
        if (flags & UNICODE_WARN_NONCHAR) {                         \
            Perl_ck_warner_d(aTHX_ packWARN(WARN_NONCHAR),          \
		 "Unicode non-character U+%04"UVXf" is not "        \
                 "recommended for open interchange", uv);           \
        }                                                           \
        if (flags & UNICODE_DISALLOW_NONCHAR) {                     \
            return NULL;                                            \
        }                                                           \
    } STMT_END;

/*  Use shorter names internally in this file */
#define SHIFT   UTF_ACCUMULATION_SHIFT
#undef  MARK
#define MARK    UTF_CONTINUATION_MARK
#define MASK    UTF_CONTINUATION_MASK

U8 *
Perl_uvoffuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
{
    PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS;

    if (OFFUNI_IS_INVARIANT(uv)) {
	*d++ = LATIN1_TO_NATIVE(uv);
	return d;
    }

    if (uv <= MAX_UTF8_TWO_BYTE) {
        *d++ = I8_TO_NATIVE_UTF8(( uv >> SHIFT) | UTF_START_MARK(2));
        *d++ = I8_TO_NATIVE_UTF8(( uv           & MASK) |   MARK);
        return d;
    }

    /* Not 2-byte; test for and handle 3-byte result.   In the test immediately
     * below, the 16 is for start bytes E0-EF (which are all the possible ones
     * for 3 byte characters).  The 2 is for 2 continuation bytes; these each
     * contribute SHIFT bits.  This yields 0x4000 on EBCDIC platforms, 0x1_0000
     * on ASCII; so 3 bytes covers the range 0x400-0x3FFF on EBCDIC;
     * 0x800-0xFFFF on ASCII */
    if (uv < (16 * (1U << (2 * SHIFT)))) {
	*d++ = I8_TO_NATIVE_UTF8(( uv >> ((3 - 1) * SHIFT)) | UTF_START_MARK(3));
	*d++ = I8_TO_NATIVE_UTF8(((uv >> ((2 - 1) * SHIFT)) & MASK) |   MARK);
	*d++ = I8_TO_NATIVE_UTF8(( uv  /* (1 - 1) */        & MASK) |   MARK);

#ifndef EBCDIC  /* These problematic code points are 4 bytes on EBCDIC, so
                   aren't tested here */
        /* The most likely code points in this range are below the surrogates.
         * Do an extra test to quickly exclude those. */
        if (UNLIKELY(uv >= UNICODE_SURROGATE_FIRST)) {
            if (UNLIKELY(   UNICODE_IS_32_CONTIGUOUS_NONCHARS(uv)
                         || UNICODE_IS_END_PLANE_NONCHAR_GIVEN_NOT_SUPER(uv)))
            {
                HANDLE_UNICODE_NONCHAR(uv, flags);
            }
            else if (UNLIKELY(UNICODE_IS_SURROGATE(uv))) {
                HANDLE_UNICODE_SURROGATE(uv, flags);
            }
        }
#endif
	return d;
    }

    /* Not 3-byte; that means the code point is at least 0x1_0000 on ASCII
     * platforms, and 0x4000 on EBCDIC.  There are problematic cases that can
     * happen starting with 4-byte characters on ASCII platforms.  We unify the
     * code for these with EBCDIC, even though some of them require 5-bytes on
     * those, because khw believes the code saving is worth the very slight
     * performance hit on these high EBCDIC code points. */

    if (UNLIKELY(UNICODE_IS_SUPER(uv))) {
        if (   UNLIKELY(uv > MAX_NON_DEPRECATED_CP)
            && ckWARN_d(WARN_DEPRECATED))
        {
            Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                        cp_above_legal_max, uv, MAX_NON_DEPRECATED_CP);
        }
        if (   (flags & UNICODE_WARN_SUPER)
            || (   UNICODE_IS_ABOVE_31_BIT(uv)
                && (flags & UNICODE_WARN_ABOVE_31_BIT)))
        {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_NON_UNICODE),

              /* Choose the more dire applicable warning */
              (UNICODE_IS_ABOVE_31_BIT(uv))
              ? "Code point 0x%"UVXf" is not Unicode, and not portable"
              : "Code point 0x%"UVXf" is not Unicode, may not be portable",
             uv);
        }
        if (flags & UNICODE_DISALLOW_SUPER
            || (   UNICODE_IS_ABOVE_31_BIT(uv)
                && (flags & UNICODE_DISALLOW_ABOVE_31_BIT)))
        {
            return NULL;
        }
    }
    else if (UNLIKELY(UNICODE_IS_END_PLANE_NONCHAR_GIVEN_NOT_SUPER(uv))) {
        HANDLE_UNICODE_NONCHAR(uv, flags);
    }

    /* Test for and handle 4-byte result.   In the test immediately below, the
     * 8 is for start bytes F0-F7 (which are all the possible ones for 4 byte
     * characters).  The 3 is for 3 continuation bytes; these each contribute
     * SHIFT bits.  This yields 0x4_0000 on EBCDIC platforms, 0x20_0000 on
     * ASCII, so 4 bytes covers the range 0x4000-0x3_FFFF on EBCDIC;
     * 0x1_0000-0x1F_FFFF on ASCII */
    if (uv < (8 * (1U << (3 * SHIFT)))) {
	*d++ = I8_TO_NATIVE_UTF8(( uv >> ((4 - 1) * SHIFT)) | UTF_START_MARK(4));
	*d++ = I8_TO_NATIVE_UTF8(((uv >> ((3 - 1) * SHIFT)) & MASK) |   MARK);
	*d++ = I8_TO_NATIVE_UTF8(((uv >> ((2 - 1) * SHIFT)) & MASK) |   MARK);
	*d++ = I8_TO_NATIVE_UTF8(( uv  /* (1 - 1) */        & MASK) |   MARK);

#ifdef EBCDIC   /* These were handled on ASCII platforms in the code for 3-byte
                   characters.  The end-plane non-characters for EBCDIC were
                   handled just above */
        if (UNLIKELY(UNICODE_IS_32_CONTIGUOUS_NONCHARS(uv))) {
            HANDLE_UNICODE_NONCHAR(uv, flags);
        }
        else if (UNLIKELY(UNICODE_IS_SURROGATE(uv))) {
            HANDLE_UNICODE_SURROGATE(uv, flags);
        }
#endif

	return d;
    }

    /* Not 4-byte; that means the code point is at least 0x20_0000 on ASCII
     * platforms, and 0x4000 on EBCDIC.  At this point we switch to a loop
     * format.  The unrolled version above turns out to not save all that much
     * time, and at these high code points (well above the legal Unicode range
     * on ASCII platforms, and well above anything in common use in EBCDIC),
     * khw believes that less code outweighs slight performance gains. */

    {
	STRLEN len  = OFFUNISKIP(uv);
	U8 *p = d+len-1;
	while (p > d) {
	    *p-- = I8_TO_NATIVE_UTF8((uv & UTF_CONTINUATION_MASK) | UTF_CONTINUATION_MARK);
	    uv >>= UTF_ACCUMULATION_SHIFT;
	}
	*p = I8_TO_NATIVE_UTF8((uv & UTF_START_MASK(len)) | UTF_START_MARK(len));
	return d+len;
    }
}

/*
=for apidoc uvchr_to_utf8

Adds the UTF-8 representation of the native code point C<uv> to the end
of the string C<d>; C<d> should have at least C<UVCHR_SKIP(uv)+1> (up to
C<UTF8_MAXBYTES+1>) free bytes available.  The return value is the pointer to
the byte after the end of the new character.  In other words,

    d = uvchr_to_utf8(d, uv);

is the recommended wide native character-aware way of saying

    *(d++) = uv;

This function accepts any UV as input, but very high code points (above
C<IV_MAX> on the platform)  will raise a deprecation warning.  This is
typically 0x7FFF_FFFF in a 32-bit word.

It is possible to forbid or warn on non-Unicode code points, or those that may
be problematic by using L</uvchr_to_utf8_flags>.

=cut
*/

/* This is also a macro */
PERL_CALLCONV U8*       Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv);

U8 *
Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv)
{
    return uvchr_to_utf8(d, uv);
}

/*
=for apidoc uvchr_to_utf8_flags

Adds the UTF-8 representation of the native code point C<uv> to the end
of the string C<d>; C<d> should have at least C<UVCHR_SKIP(uv)+1> (up to
C<UTF8_MAXBYTES+1>) free bytes available.  The return value is the pointer to
the byte after the end of the new character.  In other words,

    d = uvchr_to_utf8_flags(d, uv, flags);

or, in most cases,

    d = uvchr_to_utf8_flags(d, uv, 0);

This is the Unicode-aware way of saying

    *(d++) = uv;

If C<flags> is 0, this function accepts any UV as input, but very high code
points (above C<IV_MAX> for the platform)  will raise a deprecation warning.
This is typically 0x7FFF_FFFF in a 32-bit word.

Specifying C<flags> can further restrict what is allowed and not warned on, as
follows:

If C<uv> is a Unicode surrogate code point and C<UNICODE_WARN_SURROGATE> is set,
the function will raise a warning, provided UTF8 warnings are enabled.  If
instead C<UNICODE_DISALLOW_SURROGATE> is set, the function will fail and return
NULL.  If both flags are set, the function will both warn and return NULL.

Similarly, the C<UNICODE_WARN_NONCHAR> and C<UNICODE_DISALLOW_NONCHAR> flags
affect how the function handles a Unicode non-character.

And likewise, the C<UNICODE_WARN_SUPER> and C<UNICODE_DISALLOW_SUPER> flags
affect the handling of code points that are above the Unicode maximum of
0x10FFFF.  Languages other than Perl may not be able to accept files that
contain these.

The flag C<UNICODE_WARN_ILLEGAL_INTERCHANGE> selects all three of
the above WARN flags; and C<UNICODE_DISALLOW_ILLEGAL_INTERCHANGE> selects all
three DISALLOW flags.

Code points above 0x7FFF_FFFF (2**31 - 1) were never specified in any standard,
so using them is more problematic than other above-Unicode code points.  Perl
invented an extension to UTF-8 to represent the ones above 2**36-1, so it is
likely that non-Perl languages will not be able to read files that contain
these that written by the perl interpreter; nor would Perl understand files
written by something that uses a different extension.  For these reasons, there
is a separate set of flags that can warn and/or disallow these extremely high
code points, even if other above-Unicode ones are accepted.  These are the
C<UNICODE_WARN_ABOVE_31_BIT> and C<UNICODE_DISALLOW_ABOVE_31_BIT> flags.  These
are entirely independent from the deprecation warning for code points above
C<IV_MAX>.  On 32-bit machines, it will eventually be forbidden to have any
code point that needs more than 31 bits to represent.  When that happens,
effectively the C<UNICODE_DISALLOW_ABOVE_31_BIT> flag will always be set on
32-bit machines.  (Of course C<UNICODE_DISALLOW_SUPER> will treat all
above-Unicode code points, including these, as malformations; and
C<UNICODE_WARN_SUPER> warns on these.)

On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing
extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower
than on ASCII.  Prior to that, code points 2**31 and higher were simply
unrepresentable, and a different, incompatible method was used to represent
code points between 2**30 and 2**31 - 1.  The flags C<UNICODE_WARN_ABOVE_31_BIT>
and C<UNICODE_DISALLOW_ABOVE_31_BIT> have the same function as on ASCII
platforms, warning and disallowing 2**31 and higher.

=cut
*/

/* This is also a macro */
PERL_CALLCONV U8*       Perl_uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags);

U8 *
Perl_uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
{
    return uvchr_to_utf8_flags(d, uv, flags);
}

/*
=for apidoc is_utf8_string

Returns true if the first C<len> bytes of string C<s> form a valid
UTF-8 string, false otherwise.  If C<len> is 0, it will be calculated
using C<strlen(s)> (which means if you use this option, that C<s> can't have
embedded C<NUL> characters and has to have a terminating C<NUL> byte).  Note
that all characters being ASCII constitute 'a valid UTF-8 string'.

See also L</is_invariant_string>(), L</is_utf8_string_loclen>(), and L</is_utf8_string_loc>().

=cut
*/

bool
Perl_is_utf8_string(const U8 *s, STRLEN len)
{
    const U8* const send = s + (len ? len : strlen((const char *)s));
    const U8* x = s;

    PERL_ARGS_ASSERT_IS_UTF8_STRING;

    while (x < send) {
        STRLEN len = isUTF8_CHAR(x, send);
        if (UNLIKELY(! len)) {
            return FALSE;
        }
        x += len;
    }

    return TRUE;
}

/*
Implemented as a macro in utf8.h

=for apidoc is_utf8_string_loc

Like L</is_utf8_string> but stores the location of the failure (in the
case of "utf8ness failure") or the location C<s>+C<len> (in the case of
"utf8ness success") in the C<ep>.

See also L</is_utf8_string_loclen>() and L</is_utf8_string>().

=for apidoc is_utf8_string_loclen

Like L</is_utf8_string>() but stores the location of the failure (in the
case of "utf8ness failure") or the location C<s>+C<len> (in the case of
"utf8ness success") in the C<ep>, and the number of UTF-8
encoded characters in the C<el>.

See also L</is_utf8_string_loc>() and L</is_utf8_string>().

=cut
*/

bool
Perl_is_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el)
{
    const U8* const send = s + (len ? len : strlen((const char *)s));
    const U8* x = s;
    STRLEN outlen = 0;

    PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN;

    while (x < send) {
        STRLEN len = isUTF8_CHAR(x, send);
        if (UNLIKELY(! len)) {
            goto out;
        }
        x += len;
        outlen++;
    }

 out:
    if (el)
        *el = outlen;

    if (ep)
        *ep = x;
    return (x == send);
}

/*

=for apidoc utf8n_to_uvchr

THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
Most code should use L</utf8_to_uvchr_buf>() rather than call this directly.

Bottom level UTF-8 decode routine.
Returns the native code point value of the first character in the string C<s>,
which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than
C<curlen> bytes; C<*retlen> (if C<retlen> isn't NULL) will be set to
the length, in bytes, of that character.

The value of C<flags> determines the behavior when C<s> does not point to a
well-formed UTF-8 character.  If C<flags> is 0, when a malformation is found,
zero is returned and C<*retlen> is set so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.

Various ALLOW flags can be set in C<flags> to allow (and not warn on)
individual types of malformations, such as the sequence being overlong (that
is, when there is a shorter sequence that can express the same code point;
overlong sequences are expressly forbidden in the UTF-8 standard due to
potential security issues).  Another malformation example is the first byte of
a character not being a legal first byte.  See F<utf8.h> for the list of such
flags.  For allowed 0 length strings, this function returns 0; for allowed
overlong sequences, the computed code point is returned; for all other allowed
malformations, the Unicode REPLACEMENT CHARACTER is returned, as these have no
determinable reasonable value.

The C<UTF8_CHECK_ONLY> flag overrides the behavior when a non-allowed (by other
flags) malformation is found.  If this flag is set, the routine assumes that
the caller will raise a warning, and this function will silently just set
C<retlen> to C<-1> (cast to C<STRLEN>) and return zero.

Note that this API requires disambiguation between successful decoding a C<NUL>
character, and an error return (unless the C<UTF8_CHECK_ONLY> flag is set), as
in both cases, 0 is returned.  To disambiguate, upon a zero return, see if the
first byte of C<s> is 0 as well.  If so, the input was a C<NUL>; if not, the
input had an error.

Certain code points are considered problematic.  These are Unicode surrogates,
Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF.
By default these are considered regular code points, but certain situations
warrant special handling for them.  If C<flags> contains
C<UTF8_DISALLOW_ILLEGAL_INTERCHANGE>, all three classes are treated as
malformations and handled as such.  The flags C<UTF8_DISALLOW_SURROGATE>,
C<UTF8_DISALLOW_NONCHAR>, and C<UTF8_DISALLOW_SUPER> (meaning above the legal
Unicode maximum) can be set to disallow these categories individually.

The flags C<UTF8_WARN_ILLEGAL_INTERCHANGE>, C<UTF8_WARN_SURROGATE>,
C<UTF8_WARN_NONCHAR>, and C<UTF8_WARN_SUPER> will cause warning messages to be
raised for their respective categories, but otherwise the code points are
considered valid (not malformations).  To get a category to both be treated as
a malformation and raise a warning, specify both the WARN and DISALLOW flags.
(But note that warnings are not raised if lexically disabled nor if
C<UTF8_CHECK_ONLY> is also specified.)

It is now deprecated to have very high code points (above C<IV_MAX> on the
platforms) and this function will raise a deprecation warning for these (unless
such warnings are turned off).  This value, is typically 0x7FFF_FFFF (2**31 -1)
in a 32-bit word.

Code points above 0x7FFF_FFFF (2**31 - 1) were never specified in any standard,
so using them is more problematic than other above-Unicode code points.  Perl
invented an extension to UTF-8 to represent the ones above 2**36-1, so it is
likely that non-Perl languages will not be able to read files that contain
these that written by the perl interpreter; nor would Perl understand files
written by something that uses a different extension.  For these reasons, there
is a separate set of flags that can warn and/or disallow these extremely high
code points, even if other above-Unicode ones are accepted.  These are the
C<UTF8_WARN_ABOVE_31_BIT> and C<UTF8_DISALLOW_ABOVE_31_BIT> flags.  These
are entirely independent from the deprecation warning for code points above
C<IV_MAX>.  On 32-bit machines, it will eventually be forbidden to have any
code point that needs more than 31 bits to represent.  When that happens,
effectively the C<UTF8_DISALLOW_ABOVE_31_BIT> flag will always be set on
32-bit machines.  (Of course C<UTF8_DISALLOW_SUPER> will treat all
above-Unicode code points, including these, as malformations; and
C<UTF8_WARN_SUPER> warns on these.)

On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing
extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower
than on ASCII.  Prior to that, code points 2**31 and higher were simply
unrepresentable, and a different, incompatible method was used to represent
code points between 2**30 and 2**31 - 1.  The flags C<UTF8_WARN_ABOVE_31_BIT>
and C<UTF8_DISALLOW_ABOVE_31_BIT> have the same function as on ASCII
platforms, warning and disallowing 2**31 and higher.

All other code points corresponding to Unicode characters, including private
use and those yet to be assigned, are never considered malformed and never
warn.

=cut
*/

UV
Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
{
    const U8 * const s0 = s;
    U8 overflow_byte = '\0';	/* Save byte in case of overflow */
    U8 * send;
    UV uv = *s;
    STRLEN expectlen;
    SV* sv = NULL;
    UV outlier_ret = 0;	/* return value when input is in error or problematic
			 */
    UV pack_warn = 0;	/* Save result of packWARN() for later */
    bool unexpected_non_continuation = FALSE;
    bool overflowed = FALSE;
    bool do_overlong_test = TRUE;   /* May have to skip this test */

    const char* const malformed_text = "Malformed UTF-8 character";

    PERL_ARGS_ASSERT_UTF8N_TO_UVCHR;

    /* The order of malformation tests here is important.  We should consume as
     * few bytes as possible in order to not skip any valid character.  This is
     * required by the Unicode Standard (section 3.9 of Unicode 6.0); see also
     * http://unicode.org/reports/tr36 for more discussion as to why.  For
     * example, once we've done a UTF8SKIP, we can tell the expected number of
     * bytes, and could fail right off the bat if the input parameters indicate
     * that there are too few available.  But it could be that just that first
     * byte is garbled, and the intended character occupies fewer bytes.  If we
     * blindly assumed that the first byte is correct, and skipped based on
     * that number, we could skip over a valid input character.  So instead, we
     * always examine the sequence byte-by-byte.
     *
     * We also should not consume too few bytes, otherwise someone could inject
     * things.  For example, an input could be deliberately designed to
     * overflow, and if this code bailed out immediately upon discovering that,
     * returning to the caller C<*retlen> pointing to the very next byte (one
     * which is actually part of of the overflowing sequence), that could look
     * legitimate to the caller, which could discard the initial partial
     * sequence and process the rest, inappropriately */

    /* Zero length strings, if allowed, of necessity are zero */
    if (UNLIKELY(curlen == 0)) {
	if (retlen) {
	    *retlen = 0;
	}

	if (flags & UTF8_ALLOW_EMPTY) {
	    return 0;
	}
	if (! (flags & UTF8_CHECK_ONLY)) {
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (empty string)", malformed_text));
	}
	goto malformed;
    }

    expectlen = UTF8SKIP(s);

    /* A well-formed UTF-8 character, as the vast majority of calls to this
     * function will be for, has this expected length.  For efficiency, set
     * things up here to return it.  It will be overriden only in those rare
     * cases where a malformation is found */
    if (retlen) {
	*retlen = expectlen;
    }

    /* An invariant is trivially well-formed */
    if (UTF8_IS_INVARIANT(uv)) {
	return uv;
    }

    /* A continuation character can't start a valid sequence */
    if (UNLIKELY(UTF8_IS_CONTINUATION(uv))) {
	if (flags & UTF8_ALLOW_CONTINUATION) {
	    if (retlen) {
		*retlen = 1;
	    }
	    return UNICODE_REPLACEMENT;
	}

	if (! (flags & UTF8_CHECK_ONLY)) {
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (unexpected continuation byte 0x%02x, with no preceding start byte)", malformed_text, *s0));
	}
	curlen = 1;
	goto malformed;
    }

    /* Here is not a continuation byte, nor an invariant.  The only thing left
     * is a start byte (possibly for an overlong) */

#ifdef EBCDIC
    uv = NATIVE_UTF8_TO_I8(uv);
#endif

    /* Remove the leading bits that indicate the number of bytes in the
     * character's whole UTF-8 sequence, leaving just the bits that are part of
     * the value */
    uv &= UTF_START_MASK(expectlen);

    /* Now, loop through the remaining bytes in the character's sequence,
     * accumulating each into the working value as we go.  Be sure to not look
     * past the end of the input string */
    send =  (U8*) s0 + ((expectlen <= curlen) ? expectlen : curlen);

    for (s = s0 + 1; s < send; s++) {
	if (LIKELY(UTF8_IS_CONTINUATION(*s))) {
	    if (uv & UTF_ACCUMULATION_OVERFLOW_MASK) {

		/* The original implementors viewed this malformation as more
		 * serious than the others (though I, khw, don't understand
		 * why, since other malformations also give very very wrong
		 * results), so there is no way to turn off checking for it.
		 * Set a flag, but keep going in the loop, so that we absorb
		 * the rest of the bytes that comprise the character. */
		overflowed = TRUE;
		overflow_byte = *s; /* Save for warning message's use */
	    }
	    uv = UTF8_ACCUMULATE(uv, *s);
	}
	else {
	    /* Here, found a non-continuation before processing all expected
	     * bytes.  This byte begins a new character, so quit, even if
	     * allowing this malformation. */
	    unexpected_non_continuation = TRUE;
	    break;
	}
    } /* End of loop through the character's bytes */

    /* Save how many bytes were actually in the character */
    curlen = s - s0;

    /* The loop above finds two types of malformations: non-continuation and/or
     * overflow.  The non-continuation malformation is really a too-short
     * malformation, as it means that the current character ended before it was
     * expected to (being terminated prematurely by the beginning of the next
     * character, whereas in the too-short malformation there just are too few
     * bytes available to hold the character.  In both cases, the check below
     * that we have found the expected number of bytes would fail if executed.)
     * Thus the non-continuation malformation is really unnecessary, being a
     * subset of the too-short malformation.  But there may be existing
     * applications that are expecting the non-continuation type, so we retain
     * it, and return it in preference to the too-short malformation.  (If this
     * code were being written from scratch, the two types might be collapsed
     * into one.)  I, khw, am also giving priority to returning the
     * non-continuation and too-short malformations over overflow when multiple
     * ones are present.  I don't know of any real reason to prefer one over
     * the other, except that it seems to me that multiple-byte errors trumps
     * errors from a single byte */
    if (UNLIKELY(unexpected_non_continuation)) {
	if (!(flags & UTF8_ALLOW_NON_CONTINUATION)) {
	    if (! (flags & UTF8_CHECK_ONLY)) {
		if (curlen == 1) {
		    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (unexpected non-continuation byte 0x%02x, immediately after start byte 0x%02x)", malformed_text, *s, *s0));
		}
		else {
		    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (unexpected non-continuation byte 0x%02x, %d bytes after start byte 0x%02x, expected %d bytes)", malformed_text, *s, (int) curlen, *s0, (int)expectlen));
		}
	    }
	    goto malformed;
	}
	uv = UNICODE_REPLACEMENT;

	/* Skip testing for overlongs, as the REPLACEMENT may not be the same
	 * as what the original expectations were. */
	do_overlong_test = FALSE;
	if (retlen) {
	    *retlen = curlen;
	}
    }
    else if (UNLIKELY(curlen < expectlen)) {
	if (! (flags & UTF8_ALLOW_SHORT)) {
	    if (! (flags & UTF8_CHECK_ONLY)) {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (%d byte%s, need %d, after start byte 0x%02x)", malformed_text, (int)curlen, curlen == 1 ? "" : "s", (int)expectlen, *s0));
	    }
	    goto malformed;
	}
	uv = UNICODE_REPLACEMENT;
	do_overlong_test = FALSE;
	if (retlen) {
	    *retlen = curlen;
	}
    }

    if (UNLIKELY(overflowed)) {
	sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (overflow at byte 0x%02x, after start byte 0x%02x)", malformed_text, overflow_byte, *s0));
	goto malformed;
    }

    if (do_overlong_test
	&& expectlen > (STRLEN) OFFUNISKIP(uv)
	&& ! (flags & UTF8_ALLOW_LONG))
    {
	/* The overlong malformation has lower precedence than the others.
	 * Note that if this malformation is allowed, we return the actual
	 * value, instead of the replacement character.  This is because this
	 * value is actually well-defined. */
	if (! (flags & UTF8_CHECK_ONLY)) {
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (%d byte%s, need %d, after start byte 0x%02x)", malformed_text, (int)expectlen, expectlen == 1 ? "": "s", OFFUNISKIP(uv), *s0));
	}
	goto malformed;
    }

    /* Here, the input is considered to be well-formed, but it still could be a
     * problematic code point that is not allowed by the input parameters. */
    if (uv >= UNICODE_SURROGATE_FIRST /* isn't problematic if < this */
	&& ((flags & ( UTF8_DISALLOW_NONCHAR
                      |UTF8_DISALLOW_SURROGATE
                      |UTF8_DISALLOW_SUPER
                      |UTF8_DISALLOW_ABOVE_31_BIT
	              |UTF8_WARN_NONCHAR
                      |UTF8_WARN_SURROGATE
                      |UTF8_WARN_SUPER
                      |UTF8_WARN_ABOVE_31_BIT))
            || (   UNLIKELY(uv > MAX_NON_DEPRECATED_CP)
                && ckWARN_d(WARN_DEPRECATED))))
    {
	if (UNICODE_IS_SURROGATE(uv)) {

            /* By adding UTF8_CHECK_ONLY to the test, we avoid unnecessary
             * generation of the sv, since no warnings are raised under CHECK */
	    if ((flags & (UTF8_WARN_SURROGATE|UTF8_CHECK_ONLY)) == UTF8_WARN_SURROGATE
		&& ckWARN_d(WARN_SURROGATE))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "UTF-16 surrogate U+%04"UVXf"", uv));
		pack_warn = packWARN(WARN_SURROGATE);
	    }
	    if (flags & UTF8_DISALLOW_SURROGATE) {
		goto disallowed;
	    }
	}
	else if ((uv > PERL_UNICODE_MAX)) {
	    if ((flags & (UTF8_WARN_SUPER|UTF8_CHECK_ONLY)) == UTF8_WARN_SUPER
                && ckWARN_d(WARN_NON_UNICODE))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_
                   "Code point 0x%04"UVXf" is not Unicode, may not be portable",
                   uv));
		pack_warn = packWARN(WARN_NON_UNICODE);
	    }

            /* The maximum code point ever specified by a standard was
             * 2**31 - 1.  Anything larger than that is a Perl extension that
             * very well may not be understood by other applications (including
             * earlier perl versions on EBCDIC platforms).  On ASCII platforms,
             * these code points are indicated by the first UTF-8 byte being
             * 0xFE or 0xFF.  We test for these after the regular SUPER ones,
             * and before possibly bailing out, so that the slightly more dire
             * warning will override the regular one. */
            if (
#ifndef EBCDIC
                (*s0 & 0xFE) == 0xFE	/* matches both FE, FF */
#else
                 /* The I8 for 2**31 (U+80000000) is
                  *   \xFF\xA0\xA0\xA0\xA0\xA0\xA0\xA2\xA0\xA0\xA0\xA0\xA0\xA0
                  * and it turns out that on all EBCDIC pages recognized that
                  * the UTF-EBCDIC for that code point is
                  *   \xFE\x41\x41\x41\x41\x41\x41\x43\x41\x41\x41\x41\x41\x41
                  * For the next lower code point, the 1047 UTF-EBCDIC is
                  *   \xFE\x41\x41\x41\x41\x41\x41\x42\x73\x73\x73\x73\x73\x73
                  * The other code pages differ only in the bytes following
                  * \x42.  Thus the following works (the minimum continuation
                  * byte is \x41). */
                *s0 == 0xFE && send - s0 > 7 && (   s0[1] > 0x41
                                                 || s0[2] > 0x41
                                                 || s0[3] > 0x41
                                                 || s0[4] > 0x41
                                                 || s0[5] > 0x41
                                                 || s0[6] > 0x41
                                                 || s0[7] > 0x42)
#endif
                && (flags & (UTF8_WARN_ABOVE_31_BIT|UTF8_WARN_SUPER
                            |UTF8_DISALLOW_ABOVE_31_BIT)))
            {
                if (  ! (flags & UTF8_CHECK_ONLY)
                    &&  (flags & (UTF8_WARN_ABOVE_31_BIT|UTF8_WARN_SUPER))
                    &&  ckWARN_d(WARN_UTF8))
                {
                    sv = sv_2mortal(Perl_newSVpvf(aTHX_
                        "Code point 0x%"UVXf" is not Unicode, and not portable",
                        uv));
                    pack_warn = packWARN(WARN_UTF8);
                }
                if (flags & UTF8_DISALLOW_ABOVE_31_BIT) {
                    goto disallowed;
                }
            }

	    if (flags & UTF8_DISALLOW_SUPER) {
		goto disallowed;
	    }

            /* The deprecated warning overrides any non-deprecated one */
            if (UNLIKELY(uv > MAX_NON_DEPRECATED_CP) && ckWARN_d(WARN_DEPRECATED))
            {
                sv = sv_2mortal(Perl_newSVpvf(aTHX_ cp_above_legal_max,
                                              uv, MAX_NON_DEPRECATED_CP));
                pack_warn = packWARN(WARN_DEPRECATED);
            }
	}
	else if (UNICODE_IS_NONCHAR(uv)) {
	    if ((flags & (UTF8_WARN_NONCHAR|UTF8_CHECK_ONLY)) == UTF8_WARN_NONCHAR
		&& ckWARN_d(WARN_NONCHAR))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "Unicode non-character U+%04"UVXf" is not recommended for open interchange", uv));
		pack_warn = packWARN(WARN_NONCHAR);
	    }
	    if (flags & UTF8_DISALLOW_NONCHAR) {
		goto disallowed;
	    }
	}

	if (sv) {
            outlier_ret = uv;   /* Note we don't bother to convert to native,
                                   as all the outlier code points are the same
                                   in both ASCII and EBCDIC */
	    goto do_warn;
	}

	/* Here, this is not considered a malformed character, so drop through
	 * to return it */
    }

    return UNI_TO_NATIVE(uv);

    /* There are three cases which get to beyond this point.  In all 3 cases:
     * <sv>	    if not null points to a string to print as a warning.
     * <curlen>	    is what <*retlen> should be set to if UTF8_CHECK_ONLY isn't
     *		    set.
     * <outlier_ret> is what return value to use if UTF8_CHECK_ONLY isn't set.
     *		    This is done by initializing it to 0, and changing it only
     *		    for case 1).
     * The 3 cases are:
     * 1)   The input is valid but problematic, and to be warned about.  The
     *	    return value is the resultant code point; <*retlen> is set to
     *	    <curlen>, the number of bytes that comprise the code point.
     *	    <pack_warn> contains the result of packWARN() for the warning
     *	    types.  The entry point for this case is the label <do_warn>;
     * 2)   The input is a valid code point but disallowed by the parameters to
     *	    this function.  The return value is 0.  If UTF8_CHECK_ONLY is set,
     *	    <*relen> is -1; otherwise it is <curlen>, the number of bytes that
     *	    comprise the code point.  <pack_warn> contains the result of
     *	    packWARN() for the warning types.  The entry point for this case is
     *	    the label <disallowed>.
     * 3)   The input is malformed.  The return value is 0.  If UTF8_CHECK_ONLY
     *	    is set, <*relen> is -1; otherwise it is <curlen>, the number of
     *	    bytes that comprise the malformation.  All such malformations are
     *	    assumed to be warning type <utf8>.  The entry point for this case
     *	    is the label <malformed>.
     */

  malformed:

    if (sv && ckWARN_d(WARN_UTF8)) {
	pack_warn = packWARN(WARN_UTF8);
    }

  disallowed:

    if (flags & UTF8_CHECK_ONLY) {
	if (retlen)
	    *retlen = ((STRLEN) -1);
	return 0;
    }

  do_warn:

    if (pack_warn) {	/* <pack_warn> was initialized to 0, and changed only
			   if warnings are to be raised. */
	const char * const string = SvPVX_const(sv);

	if (PL_op)
	    Perl_warner(aTHX_ pack_warn, "%s in %s", string,  OP_DESC(PL_op));
	else
	    Perl_warner(aTHX_ pack_warn, "%s", string);
    }

    if (retlen) {
	*retlen = curlen;
    }

    return outlier_ret;
}

/*
=for apidoc utf8_to_uvchr_buf

Returns the native code point of the first character in the string C<s> which
is assumed to be in UTF-8 encoding; C<send> points to 1 beyond the end of C<s>.
C<*retlen> will be set to the length, in bytes, of that character.

If C<s> does not point to a well-formed UTF-8 character and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
C<NULL>) to -1.  If those warnings are off, the computed value, if well-defined
(or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and
C<*retlen> is set (if C<retlen> isn't C<NULL>) so that (S<C<s> + C<*retlen>>) is
the next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is
returned.

Code points above the platform's C<IV_MAX> will raise a deprecation warning,
unless those are turned off.

=cut
*/


UV
Perl_utf8_to_uvchr_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
{
    assert(s < send);

    return utf8n_to_uvchr(s, send - s, retlen,
			  ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
}

/* Like L</utf8_to_uvchr_buf>(), but should only be called when it is known that
 * there are no malformations in the input UTF-8 string C<s>.  surrogates,
 * non-character code points, and non-Unicode code points are allowed. */

UV
Perl_valid_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
{
    UV expectlen = UTF8SKIP(s);
    const U8* send = s + expectlen;
    UV uv = *s;

    PERL_ARGS_ASSERT_VALID_UTF8_TO_UVCHR;
    PERL_UNUSED_CONTEXT;

    if (retlen) {
        *retlen = expectlen;
    }

    /* An invariant is trivially returned */
    if (expectlen == 1) {
	return uv;
    }

#ifdef EBCDIC
    uv = NATIVE_UTF8_TO_I8(uv);
#endif

    /* Remove the leading bits that indicate the number of bytes, leaving just
     * the bits that are part of the value */
    uv &= UTF_START_MASK(expectlen);

    /* Now, loop through the remaining bytes, accumulating each into the
     * working total as we go.  (I khw tried unrolling the loop for up to 4
     * bytes, but there was no performance improvement) */
    for (++s; s < send; s++) {
        uv = UTF8_ACCUMULATE(uv, *s);
    }

    return UNI_TO_NATIVE(uv);

}

/*
=for apidoc utf8_to_uvuni_buf

Only in very rare circumstances should code need to be dealing in Unicode
(as opposed to native) code points.  In those few cases, use
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|/utf8_to_uvchr_buf>> instead.

Returns the Unicode (not-native) code point of the first character in the
string C<s> which
is assumed to be in UTF-8 encoding; C<send> points to 1 beyond the end of C<s>.
C<retlen> will be set to the length, in bytes, of that character.

If C<s> does not point to a well-formed UTF-8 character and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.

Code points above the platform's C<IV_MAX> will raise a deprecation warning,
unless those are turned off.

=cut
*/

UV
Perl_utf8_to_uvuni_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVUNI_BUF;

    assert(send > s);

    /* Call the low level routine asking for checks */
    return NATIVE_TO_UNI(Perl_utf8n_to_uvchr(aTHX_ s, send -s, retlen,
			       ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY));
}

/*
=for apidoc utf8_length

Return the length of the UTF-8 char encoded string C<s> in characters.
Stops at C<e> (inclusive).  If C<e E<lt> s> or if the scan would end
up past C<e>, croaks.

=cut
*/

STRLEN
Perl_utf8_length(pTHX_ const U8 *s, const U8 *e)
{
    STRLEN len = 0;

    PERL_ARGS_ASSERT_UTF8_LENGTH;

    /* Note: cannot use UTF8_IS_...() too eagerly here since e.g.
     * the bitops (especially ~) can create illegal UTF-8.
     * In other words: in Perl UTF-8 is not just for Unicode. */

    if (e < s)
	goto warn_and_return;
    while (s < e) {
        s += UTF8SKIP(s);
	len++;
    }

    if (e != s) {
	len--;
        warn_and_return:
	if (PL_op)
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
			     "%s in %s", unees, OP_DESC(PL_op));
	else
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), "%s", unees);
    }

    return len;
}

/*
=for apidoc utf8_distance

Returns the number of UTF-8 characters between the UTF-8 pointers C<a>
and C<b>.

WARNING: use only if you *know* that the pointers point inside the
same UTF-8 buffer.

=cut
*/

IV
Perl_utf8_distance(pTHX_ const U8 *a, const U8 *b)
{
    PERL_ARGS_ASSERT_UTF8_DISTANCE;

    return (a < b) ? -1 * (IV) utf8_length(a, b) : (IV) utf8_length(b, a);
}

/*
=for apidoc utf8_hop

Return the UTF-8 pointer C<s> displaced by C<off> characters, either
forward or backward.

WARNING: do not use the following unless you *know* C<off> is within
the UTF-8 data pointed to by C<s> *and* that on entry C<s> is aligned
on the first byte of character or just after the last byte of a character.

=cut
*/

U8 *
Perl_utf8_hop(const U8 *s, SSize_t off)
{
    PERL_ARGS_ASSERT_UTF8_HOP;

    /* Note: cannot use UTF8_IS_...() too eagerly here since e.g
     * the bitops (especially ~) can create illegal UTF-8.
     * In other words: in Perl UTF-8 is not just for Unicode. */

    if (off >= 0) {
	while (off--)
	    s += UTF8SKIP(s);
    }
    else {
	while (off++) {
	    s--;
	    while (UTF8_IS_CONTINUATION(*s))
		s--;
	}
    }
    return (U8 *)s;
}

/*
=for apidoc bytes_cmp_utf8

Compares the sequence of characters (stored as octets) in C<b>, C<blen> with the
sequence of characters (stored as UTF-8)
in C<u>, C<ulen>.  Returns 0 if they are
equal, -1 or -2 if the first string is less than the second string, +1 or +2
if the first string is greater than the second string.

-1 or +1 is returned if the shorter string was identical to the start of the
longer string.  -2 or +2 is returned if
there was a difference between characters
within the strings.

=cut
*/

int
Perl_bytes_cmp_utf8(pTHX_ const U8 *b, STRLEN blen, const U8 *u, STRLEN ulen)
{
    const U8 *const bend = b + blen;
    const U8 *const uend = u + ulen;

    PERL_ARGS_ASSERT_BYTES_CMP_UTF8;

    while (b < bend && u < uend) {
        U8 c = *u++;
	if (!UTF8_IS_INVARIANT(c)) {
	    if (UTF8_IS_DOWNGRADEABLE_START(c)) {
		if (u < uend) {
		    U8 c1 = *u++;
		    if (UTF8_IS_CONTINUATION(c1)) {
			c = EIGHT_BIT_UTF8_TO_NATIVE(c, c1);
		    } else {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
					 "Malformed UTF-8 character "
					 "(unexpected non-continuation byte 0x%02x"
					 ", immediately after start byte 0x%02x)"
					 /* Dear diag.t, it's in the pod.  */
					 "%s%s", c1, c,
					 PL_op ? " in " : "",
					 PL_op ? OP_DESC(PL_op) : "");
			return -2;
		    }
		} else {
		    if (PL_op)
			Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
					 "%s in %s", unees, OP_DESC(PL_op));
		    else
			Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), "%s", unees);
		    return -2; /* Really want to return undef :-)  */
		}
	    } else {
		return -2;
	    }
	}
	if (*b != c) {
	    return *b < c ? -2 : +2;
	}
	++b;
    }

    if (b == bend && u == uend)
	return 0;

    return b < bend ? +1 : -1;
}

/*
=for apidoc utf8_to_bytes

Converts a string C<s> of length C<len> from UTF-8 into native byte encoding.
Unlike L</bytes_to_utf8>, this over-writes the original string, and
updates C<len> to contain the new length.
Returns zero on failure, setting C<len> to -1.

If you need a copy of the string, see L</bytes_from_utf8>.

=cut
*/

U8 *
Perl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *len)
{
    U8 * const save = s;
    U8 * const send = s + *len;
    U8 *d;

    PERL_ARGS_ASSERT_UTF8_TO_BYTES;
    PERL_UNUSED_CONTEXT;

    /* ensure valid UTF-8 and chars < 256 before updating string */
    while (s < send) {
        if (! UTF8_IS_INVARIANT(*s)) {
            if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(s, send)) {
                *len = ((STRLEN) -1);
                return 0;
            }
            s++;
        }
        s++;
    }

    d = s = save;
    while (s < send) {
	U8 c = *s++;
	if (! UTF8_IS_INVARIANT(c)) {
	    /* Then it is two-byte encoded */
	    c = EIGHT_BIT_UTF8_TO_NATIVE(c, *s);
            s++;
	}
	*d++ = c;
    }
    *d = '\0';
    *len = d - save;
    return save;
}

/*
=for apidoc bytes_from_utf8

Converts a string C<s> of length C<len> from UTF-8 into native byte encoding.
Unlike L</utf8_to_bytes> but like L</bytes_to_utf8>, returns a pointer to
the newly-created string, and updates C<len> to contain the new
length.  Returns the original string if no conversion occurs, C<len>
is unchanged.  Do nothing if C<is_utf8> points to 0.  Sets C<is_utf8> to
0 if C<s> is converted or consisted entirely of characters that are invariant
in UTF-8 (i.e., US-ASCII on non-EBCDIC machines).

=cut
*/

U8 *
Perl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *len, bool *is_utf8)
{
    U8 *d;
    const U8 *start = s;
    const U8 *send;
    I32 count = 0;

    PERL_ARGS_ASSERT_BYTES_FROM_UTF8;
    PERL_UNUSED_CONTEXT;
    if (!*is_utf8)
        return (U8 *)start;

    /* ensure valid UTF-8 and chars < 256 before converting string */
    for (send = s + *len; s < send;) {
        if (! UTF8_IS_INVARIANT(*s)) {
            if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(s, send)) {
                return (U8 *)start;
            }
            count++;
            s++;
	}
        s++;
    }

    *is_utf8 = FALSE;

    Newx(d, (*len) - count + 1, U8);
    s = start; start = d;
    while (s < send) {
	U8 c = *s++;
	if (! UTF8_IS_INVARIANT(c)) {
	    /* Then it is two-byte encoded */
	    c = EIGHT_BIT_UTF8_TO_NATIVE(c, *s);
            s++;
	}
	*d++ = c;
    }
    *d = '\0';
    *len = d - start;
    return (U8 *)start;
}

/*
=for apidoc bytes_to_utf8

Converts a string C<s> of length C<len> bytes from the native encoding into
UTF-8.
Returns a pointer to the newly-created string, and sets C<len> to
reflect the new length in bytes.

A C<NUL> character will be written after the end of the string.

If you want to convert to UTF-8 from encodings other than
the native (Latin1 or EBCDIC),
see L</sv_recode_to_utf8>().

=cut
*/

/* This logic is duplicated in sv_catpvn_flags, so any bug fixes will
   likewise need duplication. */

U8*
Perl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *len)
{
    const U8 * const send = s + (*len);
    U8 *d;
    U8 *dst;

    PERL_ARGS_ASSERT_BYTES_TO_UTF8;
    PERL_UNUSED_CONTEXT;

    Newx(d, (*len) * 2 + 1, U8);
    dst = d;

    while (s < send) {
        append_utf8_from_native_byte(*s, &d);
        s++;
    }
    *d = '\0';
    *len = d-dst;
    return dst;
}

/*
 * Convert native (big-endian) or reversed (little-endian) UTF-16 to UTF-8.
 *
 * Destination must be pre-extended to 3/2 source.  Do not use in-place.
 * We optimize for native, for obvious reasons. */

U8*
Perl_utf16_to_utf8(pTHX_ U8* p, U8* d, I32 bytelen, I32 *newlen)
{
    U8* pend;
    U8* dstart = d;

    PERL_ARGS_ASSERT_UTF16_TO_UTF8;

    if (bytelen & 1)
	Perl_croak(aTHX_ "panic: utf16_to_utf8: odd bytelen %"UVuf, (UV)bytelen);

    pend = p + bytelen;

    while (p < pend) {
	UV uv = (p[0] << 8) + p[1]; /* UTF-16BE */
	p += 2;
	if (OFFUNI_IS_INVARIANT(uv)) {
	    *d++ = LATIN1_TO_NATIVE((U8) uv);
	    continue;
	}
	if (uv <= MAX_UTF8_TWO_BYTE) {
	    *d++ = UTF8_TWO_BYTE_HI(UNI_TO_NATIVE(uv));
	    *d++ = UTF8_TWO_BYTE_LO(UNI_TO_NATIVE(uv));
	    continue;
	}
#define FIRST_HIGH_SURROGATE UNICODE_SURROGATE_FIRST
#define LAST_HIGH_SURROGATE  0xDBFF
#define FIRST_LOW_SURROGATE  0xDC00
#define LAST_LOW_SURROGATE   UNICODE_SURROGATE_LAST

        /* This assumes that most uses will be in the first Unicode plane, not
         * needing surrogates */
	if (UNLIKELY(uv >= UNICODE_SURROGATE_FIRST
                  && uv <= UNICODE_SURROGATE_LAST))
        {
            if (UNLIKELY(p >= pend) || UNLIKELY(uv > LAST_HIGH_SURROGATE)) {
                Perl_croak(aTHX_ "Malformed UTF-16 surrogate");
            }
	    else {
		UV low = (p[0] << 8) + p[1];
		if (   UNLIKELY(low < FIRST_LOW_SURROGATE)
                    || UNLIKELY(low > LAST_LOW_SURROGATE))
                {
		    Perl_croak(aTHX_ "Malformed UTF-16 surrogate");
                }
		p += 2;
		uv = ((uv - FIRST_HIGH_SURROGATE) << 10)
                                       + (low - FIRST_LOW_SURROGATE) + 0x10000;
	    }
	}
#ifdef EBCDIC
        d = uvoffuni_to_utf8_flags(d, uv, 0);
#else
	if (uv < 0x10000) {
	    *d++ = (U8)(( uv >> 12)         | 0xe0);
	    *d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	    *d++ = (U8)(( uv        & 0x3f) | 0x80);
	    continue;
	}
	else {
	    *d++ = (U8)(( uv >> 18)         | 0xf0);
	    *d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	    *d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	    *d++ = (U8)(( uv        & 0x3f) | 0x80);
	    continue;
	}
#endif
    }
    *newlen = d - dstart;
    return d;
}

/* Note: this one is slightly destructive of the source. */

U8*
Perl_utf16_to_utf8_reversed(pTHX_ U8* p, U8* d, I32 bytelen, I32 *newlen)
{
    U8* s = (U8*)p;
    U8* const send = s + bytelen;

    PERL_ARGS_ASSERT_UTF16_TO_UTF8_REVERSED;

    if (bytelen & 1)
	Perl_croak(aTHX_ "panic: utf16_to_utf8_reversed: odd bytelen %"UVuf,
		   (UV)bytelen);

    while (s < send) {
	const U8 tmp = s[0];
	s[0] = s[1];
	s[1] = tmp;
	s += 2;
    }
    return utf16_to_utf8(p, d, bytelen, newlen);
}

bool
Perl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_FOO(classnum, tmpbuf);
}

/* Internal function so we can deprecate the external one, and call
   this one from other deprecated functions in this file */

bool
Perl__is_utf8_idstart(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT__IS_UTF8_IDSTART;

    if (*p == '_')
	return TRUE;
    return is_utf8_common(p, &PL_utf8_idstart, "IdStart", NULL);
}

bool
Perl__is_uni_perl_idcont(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_perl_idcont(tmpbuf);
}

bool
Perl__is_uni_perl_idstart(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_perl_idstart(tmpbuf);
}

UV
Perl__to_upper_title_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp, const char S_or_s)
{
    /* We have the latin1-range values compiled into the core, so just use
     * those, converting the result to UTF-8.  The only difference between upper
     * and title case in this range is that LATIN_SMALL_LETTER_SHARP_S is
     * either "SS" or "Ss".  Which one to use is passed into the routine in
     * 'S_or_s' to avoid a test */

    UV converted = toUPPER_LATIN1_MOD(c);

    PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1;

    assert(S_or_s == 'S' || S_or_s == 's');

    if (UVCHR_IS_INVARIANT(converted)) { /* No difference between the two for
					     characters in this range */
	*p = (U8) converted;
	*lenp = 1;
	return converted;
    }

    /* toUPPER_LATIN1_MOD gives the correct results except for three outliers,
     * which it maps to one of them, so as to only have to have one check for
     * it in the main case */
    if (UNLIKELY(converted == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
	switch (c) {
	    case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
		converted = LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS;
		break;
	    case MICRO_SIGN:
		converted = GREEK_CAPITAL_LETTER_MU;
		break;
#if    UNICODE_MAJOR_VERSION > 2                                        \
   || (UNICODE_MAJOR_VERSION == 2 && UNICODE_DOT_VERSION >= 1           \
                                  && UNICODE_DOT_DOT_VERSION >= 8)
	    case LATIN_SMALL_LETTER_SHARP_S:
		*(p)++ = 'S';
		*p = S_or_s;
		*lenp = 2;
		return 'S';
#endif
	    default:
		Perl_croak(aTHX_ "panic: to_upper_title_latin1 did not expect '%c' to map to '%c'", c, LATIN_SMALL_LETTER_Y_WITH_DIAERESIS);
		NOT_REACHED; /* NOTREACHED */
	}
    }

    *(p)++ = UTF8_TWO_BYTE_HI(converted);
    *p = UTF8_TWO_BYTE_LO(converted);
    *lenp = 2;

    return converted;
}

/* Call the function to convert a UTF-8 encoded character to the specified case.
 * Note that there may be more than one character in the result.
 * INP is a pointer to the first byte of the input character
 * OUTP will be set to the first byte of the string of changed characters.  It
 *	needs to have space for UTF8_MAXBYTES_CASE+1 bytes
 * LENP will be set to the length in bytes of the string of changed characters
 *
 * The functions return the ordinal of the first character in the string of OUTP */
#define CALL_UPPER_CASE(uv, s, d, lenp) _to_utf8_case(uv, s, d, lenp, &PL_utf8_toupper, "ToUc", "")
#define CALL_TITLE_CASE(uv, s, d, lenp) _to_utf8_case(uv, s, d, lenp, &PL_utf8_totitle, "ToTc", "")
#define CALL_LOWER_CASE(uv, s, d, lenp) _to_utf8_case(uv, s, d, lenp, &PL_utf8_tolower, "ToLc", "")

/* This additionally has the input parameter 'specials', which if non-zero will
 * cause this to use the specials hash for folding (meaning get full case
 * folding); otherwise, when zero, this implies a simple case fold */
#define CALL_FOLD_CASE(uv, s, d, lenp, specials) _to_utf8_case(uv, s, d, lenp, &PL_utf8_tofold, "ToCf", (specials) ? "" : NULL)

UV
Perl_to_uni_upper(pTHX_ UV c, U8* p, STRLEN *lenp)
{
    /* Convert the Unicode character whose ordinal is <c> to its uppercase
     * version and store that in UTF-8 in <p> and its length in bytes in <lenp>.
     * Note that the <p> needs to be at least UTF8_MAXBYTES_CASE+1 bytes since
     * the changed version may be longer than the original character.
     *
     * The ordinal of the first character of the changed version is returned
     * (but note, as explained above, that there may be more.) */

    PERL_ARGS_ASSERT_TO_UNI_UPPER;

    if (c < 256) {
	return _to_upper_title_latin1((U8) c, p, lenp, 'S');
    }

    uvchr_to_utf8(p, c);
    return CALL_UPPER_CASE(c, p, p, lenp);
}

UV
Perl_to_uni_title(pTHX_ UV c, U8* p, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UNI_TITLE;

    if (c < 256) {
	return _to_upper_title_latin1((U8) c, p, lenp, 's');
    }

    uvchr_to_utf8(p, c);
    return CALL_TITLE_CASE(c, p, p, lenp);
}

STATIC U8
S_to_lower_latin1(const U8 c, U8* p, STRLEN *lenp)
{
    /* We have the latin1-range values compiled into the core, so just use
     * those, converting the result to UTF-8.  Since the result is always just
     * one character, we allow <p> to be NULL */

    U8 converted = toLOWER_LATIN1(c);

    if (p != NULL) {
	if (NATIVE_BYTE_IS_INVARIANT(converted)) {
	    *p = converted;
	    *lenp = 1;
	}
	else {
            /* Result is known to always be < 256, so can use the EIGHT_BIT
             * macros */
	    *p = UTF8_EIGHT_BIT_HI(converted);
	    *(p+1) = UTF8_EIGHT_BIT_LO(converted);
	    *lenp = 2;
	}
    }
    return converted;
}

UV
Perl_to_uni_lower(pTHX_ UV c, U8* p, STRLEN *lenp)
{
    PERL_ARGS_ASSERT_TO_UNI_LOWER;

    if (c < 256) {
	return to_lower_latin1((U8) c, p, lenp);
    }

    uvchr_to_utf8(p, c);
    return CALL_LOWER_CASE(c, p, p, lenp);
}

UV
Perl__to_fold_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp, const unsigned int flags)
{
    /* Corresponds to to_lower_latin1(); <flags> bits meanings:
     *	    FOLD_FLAGS_NOMIX_ASCII iff non-ASCII to ASCII folds are prohibited
     *	    FOLD_FLAGS_FULL  iff full folding is to be used;
     *
     *	Not to be used for locale folds
     */

    UV converted;

    PERL_ARGS_ASSERT__TO_FOLD_LATIN1;
    PERL_UNUSED_CONTEXT;

    assert (! (flags & FOLD_FLAGS_LOCALE));

    if (UNLIKELY(c == MICRO_SIGN)) {
	converted = GREEK_SMALL_LETTER_MU;
    }
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
    else if (   (flags & FOLD_FLAGS_FULL)
             && UNLIKELY(c == LATIN_SMALL_LETTER_SHARP_S))
    {
        /* If can't cross 127/128 boundary, can't return "ss"; instead return
         * two U+017F characters, as fc("\df") should eq fc("\x{17f}\x{17f}")
         * under those circumstances. */
        if (flags & FOLD_FLAGS_NOMIX_ASCII) {
            *lenp = 2 * sizeof(LATIN_SMALL_LETTER_LONG_S_UTF8) - 2;
            Copy(LATIN_SMALL_LETTER_LONG_S_UTF8 LATIN_SMALL_LETTER_LONG_S_UTF8,
                 p, *lenp, U8);
            return LATIN_SMALL_LETTER_LONG_S;
        }
        else {
            *(p)++ = 's';
            *p = 's';
            *lenp = 2;
            return 's';
        }
    }
#endif
    else { /* In this range the fold of all other characters is their lower
              case */
	converted = toLOWER_LATIN1(c);
    }

    if (UVCHR_IS_INVARIANT(converted)) {
	*p = (U8) converted;
	*lenp = 1;
    }
    else {
	*(p)++ = UTF8_TWO_BYTE_HI(converted);
	*p = UTF8_TWO_BYTE_LO(converted);
	*lenp = 2;
    }

    return converted;
}

UV
Perl__to_uni_fold_flags(pTHX_ UV c, U8* p, STRLEN *lenp, U8 flags)
{

    /* Not currently externally documented, and subject to change
     *  <flags> bits meanings:
     *	    FOLD_FLAGS_FULL  iff full folding is to be used;
     *	    FOLD_FLAGS_LOCALE is set iff the rules from the current underlying
     *	                      locale are to be used.
     *	    FOLD_FLAGS_NOMIX_ASCII iff non-ASCII to ASCII folds are prohibited
     */

    PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS;

    if (flags & FOLD_FLAGS_LOCALE) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags &= ~FOLD_FLAGS_LOCALE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
            goto needs_full_generality;
        }
    }

    if (c < 256) {
        return _to_fold_latin1((U8) c, p, lenp,
			    flags & (FOLD_FLAGS_FULL | FOLD_FLAGS_NOMIX_ASCII));
    }

    /* Here, above 255.  If no special needs, just use the macro */
    if ( ! (flags & (FOLD_FLAGS_LOCALE|FOLD_FLAGS_NOMIX_ASCII))) {
	uvchr_to_utf8(p, c);
	return CALL_FOLD_CASE(c, p, p, lenp, flags & FOLD_FLAGS_FULL);
    }
    else {  /* Otherwise, _to_utf8_fold_flags has the intelligence to deal with
	       the special flags. */
	U8 utf8_c[UTF8_MAXBYTES + 1];

      needs_full_generality:
	uvchr_to_utf8(utf8_c, c);
	return _to_utf8_fold_flags(utf8_c, p, lenp, flags);
    }
}

PERL_STATIC_INLINE bool
S_is_utf8_common(pTHX_ const U8 *const p, SV **swash,
		 const char *const swashname, SV* const invlist)
{
    /* returns a boolean giving whether or not the UTF8-encoded character that
     * starts at <p> is in the swash indicated by <swashname>.  <swash>
     * contains a pointer to where the swash indicated by <swashname>
     * is to be stored; which this routine will do, so that future calls will
     * look at <*swash> and only generate a swash if it is not null.  <invlist>
     * is NULL or an inversion list that defines the swash.  If not null, it
     * saves time during initialization of the swash.
     *
     * Note that it is assumed that the buffer length of <p> is enough to
     * contain all the bytes that comprise the character.  Thus, <*p> should
     * have been checked before this call for mal-formedness enough to assure
     * that. */

    PERL_ARGS_ASSERT_IS_UTF8_COMMON;

    /* The API should have included a length for the UTF-8 character in <p>,
     * but it doesn't.  We therefore assume that p has been validated at least
     * as far as there being enough bytes available in it to accommodate the
     * character without reading beyond the end, and pass that number on to the
     * validating routine */
    if (! isUTF8_CHAR(p, p + UTF8SKIP(p))) {
        if (ckWARN_d(WARN_UTF8)) {
            Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED,WARN_UTF8),
		    "Passing malformed UTF-8 to \"%s\" is deprecated", swashname);
            if (ckWARN(WARN_UTF8)) {    /* This will output details as to the
                                           what the malformation is */
                utf8_to_uvchr_buf(p, p + UTF8SKIP(p), NULL);
            }
        }
        return FALSE;
    }
    if (!*swash) {
        U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
        *swash = _core_swash_init("utf8",

                                  /* Only use the name if there is no inversion
                                   * list; otherwise will go out to disk */
                                  (invlist) ? "" : swashname,

                                  &PL_sv_undef, 1, 0, invlist, &flags);
    }

    return swash_fetch(*swash, p, TRUE) != 0;
}

bool
Perl__is_utf8_FOO(pTHX_ const U8 classnum, const U8 *p)
{
    PERL_ARGS_ASSERT__IS_UTF8_FOO;

    assert(classnum < _FIRST_NON_SWASH_CC);

    return is_utf8_common(p,
                          &PL_utf8_swash_ptrs[classnum],
                          swash_property_names[classnum],
                          PL_XPosix_ptrs[classnum]);
}

bool
Perl__is_utf8_perl_idstart(pTHX_ const U8 *p)
{
    SV* invlist = NULL;

    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART;

    if (! PL_utf8_perl_idstart) {
        invlist = _new_invlist_C_array(_Perl_IDStart_invlist);
    }
    return is_utf8_common(p, &PL_utf8_perl_idstart, "_Perl_IDStart", invlist);
}

bool
Perl__is_utf8_xidstart(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT__IS_UTF8_XIDSTART;

    if (*p == '_')
	return TRUE;
    return is_utf8_common(p, &PL_utf8_xidstart, "XIdStart", NULL);
}

bool
Perl__is_utf8_perl_idcont(pTHX_ const U8 *p)
{
    SV* invlist = NULL;

    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT;

    if (! PL_utf8_perl_idcont) {
        invlist = _new_invlist_C_array(_Perl_IDCont_invlist);
    }
    return is_utf8_common(p, &PL_utf8_perl_idcont, "_Perl_IDCont", invlist);
}

bool
Perl__is_utf8_idcont(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT__IS_UTF8_IDCONT;

    return is_utf8_common(p, &PL_utf8_idcont, "IdContinue", NULL);
}

bool
Perl__is_utf8_xidcont(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT__IS_UTF8_XIDCONT;

    return is_utf8_common(p, &PL_utf8_idcont, "XIdContinue", NULL);
}

bool
Perl__is_utf8_mark(pTHX_ const U8 *p)
{
    PERL_ARGS_ASSERT__IS_UTF8_MARK;

    return is_utf8_common(p, &PL_utf8_mark, "IsM", NULL);
}

/*
=for apidoc to_utf8_case

Instead use the appropriate one of L</toUPPER_utf8>,
L</toTITLE_utf8>,
L</toLOWER_utf8>,
or L</toFOLD_utf8>.

C<p> contains the pointer to the UTF-8 string encoding
the character that is being converted.  This routine assumes that the character
at C<p> is well-formed.

C<ustrp> is a pointer to the character buffer to put the
conversion result to.  C<lenp> is a pointer to the length
of the result.

C<swashp> is a pointer to the swash to use.

Both the special and normal mappings are stored in F<lib/unicore/To/Foo.pl>,
and loaded by C<SWASHNEW>, using F<lib/utf8_heavy.pl>.  C<special> (usually,
but not always, a multicharacter mapping), is tried first.

C<special> is a string, normally C<NULL> or C<"">.  C<NULL> means to not use
any special mappings; C<""> means to use the special mappings.  Values other
than these two are treated as the name of the hash containing the special
mappings, like C<"utf8::ToSpecLower">.

C<normal> is a string like C<"ToLower"> which means the swash
C<%utf8::ToLower>.

Code points above the platform's C<IV_MAX> will raise a deprecation warning,
unless those are turned off.

=cut */

UV
Perl_to_utf8_case(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp,
			SV **swashp, const char *normal, const char *special)
{
    PERL_ARGS_ASSERT_TO_UTF8_CASE;

    return _to_utf8_case(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp, swashp, normal, special);
}

    /* change namve uv1 to 'from' */
STATIC UV
S__to_utf8_case(pTHX_ const UV uv1, const U8 *p, U8* ustrp, STRLEN *lenp,
		SV **swashp, const char *normal, const char *special)
{
    STRLEN len = 0;

    PERL_ARGS_ASSERT__TO_UTF8_CASE;

    /* For code points that don't change case, we already know that the output
     * of this function is the unchanged input, so we can skip doing look-ups
     * for them.  Unfortunately the case-changing code points are scattered
     * around.  But there are some long consecutive ranges where there are no
     * case changing code points.  By adding tests, we can eliminate the lookup
     * for all the ones in such ranges.  This is currently done here only for
     * just a few cases where the scripts are in common use in modern commerce
     * (and scripts adjacent to those which can be included without additional
     * tests). */

    if (uv1 >= 0x0590) {
        /* This keeps from needing further processing the code points most
         * likely to be used in the following non-cased scripts: Hebrew,
         * Arabic, Syriac, Thaana, NKo, Samaritan, Mandaic, Devanagari,
         * Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada,
         * Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar */
        if (uv1 < 0x10A0) {
            goto cases_to_self;
        }

        /* The following largish code point ranges also don't have case
         * changes, but khw didn't think they warranted extra tests to speed
         * them up (which would slightly slow down everything else above them):
         * 1100..139F   Hangul Jamo, Ethiopic
         * 1400..1CFF   Unified Canadian Aboriginal Syllabics, Ogham, Runic,
         *              Tagalog, Hanunoo, Buhid, Tagbanwa, Khmer, Mongolian,
         *              Limbu, Tai Le, New Tai Lue, Buginese, Tai Tham,
         *              Combining Diacritical Marks Extended, Balinese,
         *              Sundanese, Batak, Lepcha, Ol Chiki
         * 2000..206F   General Punctuation
         */

        if (uv1 >= 0x2D30) {

            /* This keeps the from needing further processing the code points
             * most likely to be used in the following non-cased major scripts:
             * CJK, Katakana, Hiragana, plus some less-likely scripts.
             *
             * (0x2D30 above might have to be changed to 2F00 in the unlikely
             * event that Unicode eventually allocates the unused block as of
             * v8.0 2FE0..2FEF to code points that are cased.  khw has verified
             * that the test suite will start having failures to alert you
             * should that happen) */
            if (uv1 < 0xA640) {
                goto cases_to_self;
            }

            if (uv1 >= 0xAC00) {
                if (UNLIKELY(UNICODE_IS_SURROGATE(uv1))) {
                    if (ckWARN_d(WARN_SURROGATE)) {
                        const char* desc = (PL_op) ? OP_DESC(PL_op) : normal;
                        Perl_warner(aTHX_ packWARN(WARN_SURROGATE),
                            "Operation \"%s\" returns its argument for UTF-16 surrogate U+%04"UVXf"", desc, uv1);
                    }
                    goto cases_to_self;
                }

                /* AC00..FAFF Catches Hangul syllables and private use, plus
                 * some others */
                if (uv1 < 0xFB00) {
                    goto cases_to_self;

                }

                if (UNLIKELY(UNICODE_IS_SUPER(uv1))) {
                    if (   UNLIKELY(uv1 > MAX_NON_DEPRECATED_CP)
                        && ckWARN_d(WARN_DEPRECATED))
                    {
                        Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                cp_above_legal_max, uv1, MAX_NON_DEPRECATED_CP);
                    }
                    if (ckWARN_d(WARN_NON_UNICODE)) {
                        const char* desc = (PL_op) ? OP_DESC(PL_op) : normal;
                        Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
                            "Operation \"%s\" returns its argument for non-Unicode code point 0x%04"UVXf"", desc, uv1);
                    }
                    goto cases_to_self;
                }
#ifdef HIGHEST_CASE_CHANGING_CP_FOR_USE_ONLY_BY_UTF8_DOT_C
                if (UNLIKELY(uv1
                    > HIGHEST_CASE_CHANGING_CP_FOR_USE_ONLY_BY_UTF8_DOT_C))
                {

                    /* As of this writing, this means we avoid swash creation
                     * for anything beyond low Plane 1 */
                    goto cases_to_self;
                }
#endif
            }
        }

	/* Note that non-characters are perfectly legal, so no warning should
         * be given.  There are so few of them, that it isn't worth the extra
         * tests to avoid swash creation */
    }

    if (!*swashp) /* load on-demand */
         *swashp = _core_swash_init("utf8", normal, &PL_sv_undef, 4, 0, NULL, NULL);

    if (special) {
         /* It might be "special" (sometimes, but not always,
	  * a multicharacter mapping) */
         HV *hv = NULL;
	 SV **svp;

	 /* If passed in the specials name, use that; otherwise use any
	  * given in the swash */
         if (*special != '\0') {
            hv = get_hv(special, 0);
        }
        else {
            svp = hv_fetchs(MUTABLE_HV(SvRV(*swashp)), "SPECIALS", 0);
            if (svp) {
                hv = MUTABLE_HV(SvRV(*svp));
            }
        }

	 if (hv
             && (svp = hv_fetch(hv, (const char*)p, UVCHR_SKIP(uv1), FALSE))
             && (*svp))
         {
	     const char *s;

	      s = SvPV_const(*svp, len);
	      if (len == 1)
                  /* EIGHTBIT */
		   len = uvchr_to_utf8(ustrp, *(U8*)s) - ustrp;
	      else {
		   Copy(s, ustrp, len, U8);
	      }
	 }
    }

    if (!len && *swashp) {
	const UV uv2 = swash_fetch(*swashp, p, TRUE /* => is UTF-8 */);

	 if (uv2) {
	      /* It was "normal" (a single character mapping). */
	      len = uvchr_to_utf8(ustrp, uv2) - ustrp;
	 }
    }

    if (len) {
        if (lenp) {
            *lenp = len;
        }
        return valid_utf8_to_uvchr(ustrp, 0);
    }

    /* Here, there was no mapping defined, which means that the code point maps
     * to itself.  Return the inputs */
  cases_to_self:
    len = UTF8SKIP(p);
    if (p != ustrp) {   /* Don't copy onto itself */
        Copy(p, ustrp, len, U8);
    }

    if (lenp)
	 *lenp = len;

    return uv1;

}

STATIC UV
S_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)
{
    /* This is called when changing the case of a UTF-8-encoded character above
     * the Latin1 range, and the operation is in a non-UTF-8 locale.  If the
     * result contains a character that crosses the 255/256 boundary, disallow
     * the change, and return the original code point.  See L<perlfunc/lc> for
     * why;
     *
     * p	points to the original string whose case was changed; assumed
     *          by this routine to be well-formed
     * result	the code point of the first character in the changed-case string
     * ustrp	points to the changed-case string (<result> represents its first char)
     * lenp	points to the length of <ustrp> */

    UV original;    /* To store the first code point of <p> */

    PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING;

    assert(UTF8_IS_ABOVE_LATIN1(*p));

    /* We know immediately if the first character in the string crosses the
     * boundary, so can skip */
    if (result > 255) {

	/* Look at every character in the result; if any cross the
	* boundary, the whole thing is disallowed */
	U8* s = ustrp + UTF8SKIP(ustrp);
	U8* e = ustrp + *lenp;
	while (s < e) {
	    if (! UTF8_IS_ABOVE_LATIN1(*s)) {
		goto bad_crossing;
	    }
	    s += UTF8SKIP(s);
	}

        /* Here, no characters crossed, result is ok as-is, but we warn. */
        _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(p, p + UTF8SKIP(p));
	return result;
    }

  bad_crossing:

    /* Failed, have to return the original */
    original = valid_utf8_to_uvchr(p, lenp);

    /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
    Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                           "Can't do %s(\"\\x{%"UVXf"}\") on non-UTF-8 locale; "
                           "resolved to \"\\x{%"UVXf"}\".",
                           OP_DESC(PL_op),
                           original,
                           original);
    Copy(p, ustrp, *lenp, char);
    return original;
}

/*
=for apidoc to_utf8_upper

Instead use L</toUPPER_utf8>.

=cut */

/* Not currently externally documented, and subject to change:
 * <flags> is set iff iff the rules from the current underlying locale are to
 *         be used. */

UV
Perl__to_utf8_upper_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
{
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS;

    if (flags) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags = FALSE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
    }

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags) {
	    result = toUPPER_LC(*p);
	}
	else {
	    return _to_upper_title_latin1(*p, ustrp, lenp, 'S');
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags) {
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toUPPER_LC(c);
	}
	else {
	    return _to_upper_title_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
				          ustrp, lenp, 'S');
	}
    }
    else {  /* UTF-8, ord above 255 */
	result = CALL_UPPER_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp);

	if (flags) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}
	return result;
    }

    /* Here, used locale rules.  Convert back to UTF-8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
	*lenp = 2;
    }

    return result;
}

/*
=for apidoc to_utf8_title

Instead use L</toTITLE_utf8>.

=cut */

/* Not currently externally documented, and subject to change:
 * <flags> is set iff the rules from the current underlying locale are to be
 *         used.  Since titlecase is not defined in POSIX, for other than a
 *         UTF-8 locale, uppercase is used instead for code points < 256.
 */

UV
Perl__to_utf8_title_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
{
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS;

    if (flags) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags = FALSE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
    }

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags) {
	    result = toUPPER_LC(*p);
	}
	else {
	    return _to_upper_title_latin1(*p, ustrp, lenp, 's');
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags) {
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toUPPER_LC(c);
	}
	else {
	    return _to_upper_title_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
				          ustrp, lenp, 's');
	}
    }
    else {  /* UTF-8, ord above 255 */
	result = CALL_TITLE_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp);

	if (flags) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}
	return result;
    }

    /* Here, used locale rules.  Convert back to UTF-8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
	*lenp = 2;
    }

    return result;
}

/*
=for apidoc to_utf8_lower

Instead use L</toLOWER_utf8>.

=cut */

/* Not currently externally documented, and subject to change:
 * <flags> is set iff iff the rules from the current underlying locale are to
 *         be used.
 */

UV
Perl__to_utf8_lower_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
{
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS;

    if (flags) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags = FALSE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
    }

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags) {
	    result = toLOWER_LC(*p);
	}
	else {
	    return to_lower_latin1(*p, ustrp, lenp);
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags) {
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toLOWER_LC(c);
	}
	else {
	    return to_lower_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
		                   ustrp, lenp);
	}
    }
    else {  /* UTF-8, ord above 255 */
	result = CALL_LOWER_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp);

	if (flags) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}

	return result;
    }

    /* Here, used locale rules.  Convert back to UTF-8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
	*lenp = 2;
    }

    return result;
}

/*
=for apidoc to_utf8_fold

Instead use L</toFOLD_utf8>.

=cut */

/* Not currently externally documented, and subject to change,
 * in <flags>
 *	bit FOLD_FLAGS_LOCALE is set iff the rules from the current underlying
 *	                      locale are to be used.
 *      bit FOLD_FLAGS_FULL   is set iff full case folds are to be used;
 *			      otherwise simple folds
 *      bit FOLD_FLAGS_NOMIX_ASCII is set iff folds of non-ASCII to ASCII are
 *			      prohibited
 */

UV
Perl__to_utf8_fold_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, U8 flags)
{
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS;

    /* These are mutually exclusive */
    assert (! ((flags & FOLD_FLAGS_LOCALE) && (flags & FOLD_FLAGS_NOMIX_ASCII)));

    assert(p != ustrp); /* Otherwise overwrites */

    if (flags & FOLD_FLAGS_LOCALE) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags &= ~FOLD_FLAGS_LOCALE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
    }

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags & FOLD_FLAGS_LOCALE) {
	    result = toFOLD_LC(*p);
	}
	else {
	    return _to_fold_latin1(*p, ustrp, lenp,
                            flags & (FOLD_FLAGS_FULL | FOLD_FLAGS_NOMIX_ASCII));
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags & FOLD_FLAGS_LOCALE) {
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toFOLD_LC(c);
	}
	else {
	    return _to_fold_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
                            ustrp, lenp,
                            flags & (FOLD_FLAGS_FULL | FOLD_FLAGS_NOMIX_ASCII));
	}
    }
    else {  /* UTF-8, ord above 255 */
	result = CALL_FOLD_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp, flags & FOLD_FLAGS_FULL);

	if (flags & FOLD_FLAGS_LOCALE) {

#           define LONG_S_T      LATIN_SMALL_LIGATURE_LONG_S_T_UTF8
            const unsigned int long_s_t_len    = sizeof(LONG_S_T) - 1;

#         ifdef LATIN_CAPITAL_LETTER_SHARP_S_UTF8
#           define CAP_SHARP_S   LATIN_CAPITAL_LETTER_SHARP_S_UTF8

            const unsigned int cap_sharp_s_len = sizeof(CAP_SHARP_S) - 1;

            /* Special case these two characters, as what normally gets
             * returned under locale doesn't work */
            if (UTF8SKIP(p) == cap_sharp_s_len
                && memEQ((char *) p, CAP_SHARP_S, cap_sharp_s_len))
            {
                /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                              "Can't do fc(\"\\x{1E9E}\") on non-UTF-8 locale; "
                              "resolved to \"\\x{17F}\\x{17F}\".");
                goto return_long_s;
            }
            else
#endif
                 if (UTF8SKIP(p) == long_s_t_len
                     && memEQ((char *) p, LONG_S_T, long_s_t_len))
            {
                /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                              "Can't do fc(\"\\x{FB05}\") on non-UTF-8 locale; "
                              "resolved to \"\\x{FB06}\".");
                goto return_ligature_st;
            }

#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1
#           define DOTTED_I   LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_UTF8

            /* And special case this on this Unicode version only, for the same
             * reaons the other two are special cased.  They would cross the
             * 255/256 boundary which is forbidden under /l, and so the code
             * wouldn't catch that they are equivalent (which they are only in
             * this release) */
            else if (UTF8SKIP(p) == sizeof(DOTTED_I) - 1
                     && memEQ((char *) p, DOTTED_I, sizeof(DOTTED_I) - 1))
            {
                /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                              "Can't do fc(\"\\x{0130}\") on non-UTF-8 locale; "
                              "resolved to \"\\x{0131}\".");
                goto return_dotless_i;
            }
#endif

	    return check_locale_boundary_crossing(p, result, ustrp, lenp);
	}
	else if (! (flags & FOLD_FLAGS_NOMIX_ASCII)) {
	    return result;
	}
	else {
	    /* This is called when changing the case of a UTF-8-encoded
             * character above the ASCII range, and the result should not
             * contain an ASCII character. */

	    UV original;    /* To store the first code point of <p> */

	    /* Look at every character in the result; if any cross the
	    * boundary, the whole thing is disallowed */
	    U8* s = ustrp;
	    U8* e = ustrp + *lenp;
	    while (s < e) {
		if (isASCII(*s)) {
		    /* Crossed, have to return the original */
		    original = valid_utf8_to_uvchr(p, lenp);

                    /* But in these instances, there is an alternative we can
                     * return that is valid */
                    if (original == LATIN_SMALL_LETTER_SHARP_S
#ifdef LATIN_CAPITAL_LETTER_SHARP_S /* not defined in early Unicode releases */
                        || original == LATIN_CAPITAL_LETTER_SHARP_S
#endif
                    ) {
                        goto return_long_s;
                    }
                    else if (original == LATIN_SMALL_LIGATURE_LONG_S_T) {
                        goto return_ligature_st;
                    }
#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1

                    else if (original == LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE) {
                        goto return_dotless_i;
                    }
#endif
		    Copy(p, ustrp, *lenp, char);
		    return original;
		}
		s += UTF8SKIP(s);
	    }

	    /* Here, no characters crossed, result is ok as-is */
	    return result;
	}
    }

    /* Here, used locale rules.  Convert back to UTF-8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
	*lenp = 2;
    }

    return result;

  return_long_s:
    /* Certain folds to 'ss' are prohibited by the options, but they do allow
     * folds to a string of two of these characters.  By returning this
     * instead, then, e.g.,
     *      fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")
     * works. */

    *lenp = 2 * sizeof(LATIN_SMALL_LETTER_LONG_S_UTF8) - 2;
    Copy(LATIN_SMALL_LETTER_LONG_S_UTF8 LATIN_SMALL_LETTER_LONG_S_UTF8,
        ustrp, *lenp, U8);
    return LATIN_SMALL_LETTER_LONG_S;

  return_ligature_st:
    /* Two folds to 'st' are prohibited by the options; instead we pick one and
     * have the other one fold to it */

    *lenp = sizeof(LATIN_SMALL_LIGATURE_ST_UTF8) - 1;
    Copy(LATIN_SMALL_LIGATURE_ST_UTF8, ustrp, *lenp, U8);
    return LATIN_SMALL_LIGATURE_ST;

#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1

  return_dotless_i:
    *lenp = sizeof(LATIN_SMALL_LETTER_DOTLESS_I_UTF8) - 1;
    Copy(LATIN_SMALL_LETTER_DOTLESS_I_UTF8, ustrp, *lenp, U8);
    return LATIN_SMALL_LETTER_DOTLESS_I;

#endif

}

/* Note:
 * Returns a "swash" which is a hash described in utf8.c:Perl_swash_fetch().
 * C<pkg> is a pointer to a package name for SWASHNEW, should be "utf8".
 * For other parameters, see utf8::SWASHNEW in lib/utf8_heavy.pl.
 */

SV*
Perl_swash_init(pTHX_ const char* pkg, const char* name, SV *listsv, I32 minbits, I32 none)
{
    PERL_ARGS_ASSERT_SWASH_INIT;

    /* Returns a copy of a swash initiated by the called function.  This is the
     * public interface, and returning a copy prevents others from doing
     * mischief on the original */

    return newSVsv(_core_swash_init(pkg, name, listsv, minbits, none, NULL, NULL));
}

SV*
Perl__core_swash_init(pTHX_ const char* pkg, const char* name, SV *listsv, I32 minbits, I32 none, SV* invlist, U8* const flags_p)
{

    /*NOTE NOTE NOTE - If you want to use "return" in this routine you MUST
     * use the following define */

#define CORE_SWASH_INIT_RETURN(x)   \
    PL_curpm= old_PL_curpm;         \
    return x

    /* Initialize and return a swash, creating it if necessary.  It does this
     * by calling utf8_heavy.pl in the general case.  The returned value may be
     * the swash's inversion list instead if the input parameters allow it.
     * Which is returned should be immaterial to callers, as the only
     * operations permitted on a swash, swash_fetch(), _get_swash_invlist(),
     * and swash_to_invlist() handle both these transparently.
     *
     * This interface should only be used by functions that won't destroy or
     * adversely change the swash, as doing so affects all other uses of the
     * swash in the program; the general public should use 'Perl_swash_init'
     * instead.
     *
     * pkg  is the name of the package that <name> should be in.
     * name is the name of the swash to find.  Typically it is a Unicode
     *	    property name, including user-defined ones
     * listsv is a string to initialize the swash with.  It must be of the form
     *	    documented as the subroutine return value in
     *	    L<perlunicode/User-Defined Character Properties>
     * minbits is the number of bits required to represent each data element.
     *	    It is '1' for binary properties.
     * none I (khw) do not understand this one, but it is used only in tr///.
     * invlist is an inversion list to initialize the swash with (or NULL)
     * flags_p if non-NULL is the address of various input and output flag bits
     *      to the routine, as follows:  ('I' means is input to the routine;
     *      'O' means output from the routine.  Only flags marked O are
     *      meaningful on return.)
     *  _CORE_SWASH_INIT_USER_DEFINED_PROPERTY indicates if the swash
     *      came from a user-defined property.  (I O)
     *  _CORE_SWASH_INIT_RETURN_IF_UNDEF indicates that instead of croaking
     *      when the swash cannot be located, to simply return NULL. (I)
     *  _CORE_SWASH_INIT_ACCEPT_INVLIST indicates that the caller will accept a
     *      return of an inversion list instead of a swash hash if this routine
     *      thinks that would result in faster execution of swash_fetch() later
     *      on. (I)
     *
     * Thus there are three possible inputs to find the swash: <name>,
     * <listsv>, and <invlist>.  At least one must be specified.  The result
     * will be the union of the specified ones, although <listsv>'s various
     * actions can intersect, etc. what <name> gives.  To avoid going out to
     * disk at all, <invlist> should specify completely what the swash should
     * have, and <listsv> should be &PL_sv_undef and <name> should be "".
     *
     * <invlist> is only valid for binary properties */

    PMOP *old_PL_curpm= PL_curpm; /* save away the old PL_curpm */

    SV* retval = &PL_sv_undef;
    HV* swash_hv = NULL;
    const int invlist_swash_boundary =
        (flags_p && *flags_p & _CORE_SWASH_INIT_ACCEPT_INVLIST)
        ? 512    /* Based on some benchmarking, but not extensive, see commit
                    message */
        : -1;   /* Never return just an inversion list */

    assert(listsv != &PL_sv_undef || strNE(name, "") || invlist);
    assert(! invlist || minbits == 1);

    PL_curpm= NULL; /* reset PL_curpm so that we dont get confused between the regex
                       that triggered the swash init and the swash init perl logic itself.
                       See perl #122747 */

    /* If data was passed in to go out to utf8_heavy to find the swash of, do
     * so */
    if (listsv != &PL_sv_undef || strNE(name, "")) {
	dSP;
	const size_t pkg_len = strlen(pkg);
	const size_t name_len = strlen(name);
	HV * const stash = gv_stashpvn(pkg, pkg_len, 0);
	SV* errsv_save;
	GV *method;

	PERL_ARGS_ASSERT__CORE_SWASH_INIT;

	PUSHSTACKi(PERLSI_MAGIC);
	ENTER;
	SAVEHINTS();
	save_re_context();
	/* We might get here via a subroutine signature which uses a utf8
	 * parameter name, at which point PL_subname will have been set
	 * but not yet used. */
	save_item(PL_subname);
	if (PL_parser && PL_parser->error_count)
	    SAVEI8(PL_parser->error_count), PL_parser->error_count = 0;
	method = gv_fetchmeth(stash, "SWASHNEW", 8, -1);
	if (!method) {	/* demand load UTF-8 */
	    ENTER;
	    if ((errsv_save = GvSV(PL_errgv))) SAVEFREESV(errsv_save);
	    GvSV(PL_errgv) = NULL;
#ifndef NO_TAINT_SUPPORT
	    /* It is assumed that callers of this routine are not passing in
	     * any user derived data.  */
	    /* Need to do this after save_re_context() as it will set
	     * PL_tainted to 1 while saving $1 etc (see the code after getrx:
	     * in Perl_magic_get).  Even line to create errsv_save can turn on
	     * PL_tainted.  */
	    SAVEBOOL(TAINT_get);
	    TAINT_NOT;
#endif
	    Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, newSVpvn(pkg,pkg_len),
			     NULL);
	    {
		/* Not ERRSV, as there is no need to vivify a scalar we are
		   about to discard. */
		SV * const errsv = GvSV(PL_errgv);
		if (!SvTRUE(errsv)) {
		    GvSV(PL_errgv) = SvREFCNT_inc_simple(errsv_save);
		    SvREFCNT_dec(errsv);
		}
	    }
	    LEAVE;
	}
	SPAGAIN;
	PUSHMARK(SP);
	EXTEND(SP,5);
	mPUSHp(pkg, pkg_len);
	mPUSHp(name, name_len);
	PUSHs(listsv);
	mPUSHi(minbits);
	mPUSHi(none);
	PUTBACK;
	if ((errsv_save = GvSV(PL_errgv))) SAVEFREESV(errsv_save);
	GvSV(PL_errgv) = NULL;
	/* If we already have a pointer to the method, no need to use
	 * call_method() to repeat the lookup.  */
	if (method
            ? call_sv(MUTABLE_SV(method), G_SCALAR)
	    : call_sv(newSVpvs_flags("SWASHNEW", SVs_TEMP), G_SCALAR | G_METHOD))
	{
	    retval = *PL_stack_sp--;
	    SvREFCNT_inc(retval);
	}
	{
	    /* Not ERRSV.  See above. */
	    SV * const errsv = GvSV(PL_errgv);
	    if (!SvTRUE(errsv)) {
		GvSV(PL_errgv) = SvREFCNT_inc_simple(errsv_save);
		SvREFCNT_dec(errsv);
	    }
	}
	LEAVE;
	POPSTACK;
	if (IN_PERL_COMPILETIME) {
	    CopHINTS_set(PL_curcop, PL_hints);
	}
	if (!SvROK(retval) || SvTYPE(SvRV(retval)) != SVt_PVHV) {
	    if (SvPOK(retval)) {

		/* If caller wants to handle missing properties, let them */
		if (flags_p && *flags_p & _CORE_SWASH_INIT_RETURN_IF_UNDEF) {
                    CORE_SWASH_INIT_RETURN(NULL);
		}
		Perl_croak(aTHX_
			   "Can't find Unicode property definition \"%"SVf"\"",
			   SVfARG(retval));
                NOT_REACHED; /* NOTREACHED */
            }
	}
    } /* End of calling the module to find the swash */

    /* If this operation fetched a swash, and we will need it later, get it */
    if (retval != &PL_sv_undef
        && (minbits == 1 || (flags_p
                            && ! (*flags_p
                                  & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY))))
    {
        swash_hv = MUTABLE_HV(SvRV(retval));

        /* If we don't already know that there is a user-defined component to
         * this swash, and the user has indicated they wish to know if there is
         * one (by passing <flags_p>), find out */
        if (flags_p && ! (*flags_p & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)) {
            SV** user_defined = hv_fetchs(swash_hv, "USER_DEFINED", FALSE);
            if (user_defined && SvUV(*user_defined)) {
                *flags_p |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
            }
        }
    }

    /* Make sure there is an inversion list for binary properties */
    if (minbits == 1) {
	SV** swash_invlistsvp = NULL;
	SV* swash_invlist = NULL;
	bool invlist_in_swash_is_valid = FALSE;
	bool swash_invlist_unclaimed = FALSE; /* whether swash_invlist has
					    an unclaimed reference count */

        /* If this operation fetched a swash, get its already existing
         * inversion list, or create one for it */

        if (swash_hv) {
	    swash_invlistsvp = hv_fetchs(swash_hv, "V", FALSE);
	    if (swash_invlistsvp) {
		swash_invlist = *swash_invlistsvp;
		invlist_in_swash_is_valid = TRUE;
	    }
	    else {
		swash_invlist = _swash_to_invlist(retval);
		swash_invlist_unclaimed = TRUE;
	    }
	}

	/* If an inversion list was passed in, have to include it */
	if (invlist) {

            /* Any fetched swash will by now have an inversion list in it;
             * otherwise <swash_invlist>  will be NULL, indicating that we
             * didn't fetch a swash */
	    if (swash_invlist) {

		/* Add the passed-in inversion list, which invalidates the one
		 * already stored in the swash */
		invlist_in_swash_is_valid = FALSE;
		_invlist_union(invlist, swash_invlist, &swash_invlist);
	    }
	    else {

                /* Here, there is no swash already.  Set up a minimal one, if
                 * we are going to return a swash */
                if ((int) _invlist_len(invlist) > invlist_swash_boundary) {
                    swash_hv = newHV();
                    retval = newRV_noinc(MUTABLE_SV(swash_hv));
                }
		swash_invlist = invlist;
	    }
	}

        /* Here, we have computed the union of all the passed-in data.  It may
         * be that there was an inversion list in the swash which didn't get
         * touched; otherwise save the computed one */
	if (! invlist_in_swash_is_valid
            && (int) _invlist_len(swash_invlist) > invlist_swash_boundary)
        {
	    if (! hv_stores(MUTABLE_HV(SvRV(retval)), "V", swash_invlist))
            {
		Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
	    }
	    /* We just stole a reference count. */
	    if (swash_invlist_unclaimed) swash_invlist_unclaimed = FALSE;
	    else SvREFCNT_inc_simple_void_NN(swash_invlist);
	}

        SvREADONLY_on(swash_invlist);

        /* Use the inversion list stand-alone if small enough */
        if ((int) _invlist_len(swash_invlist) <= invlist_swash_boundary) {
	    SvREFCNT_dec(retval);
	    if (!swash_invlist_unclaimed)
		SvREFCNT_inc_simple_void_NN(swash_invlist);
            retval = newRV_noinc(swash_invlist);
        }
    }

    CORE_SWASH_INIT_RETURN(retval);
#undef CORE_SWASH_INIT_RETURN
}


/* This API is wrong for special case conversions since we may need to
 * return several Unicode characters for a single Unicode character
 * (see lib/unicore/SpecCase.txt) The SWASHGET in lib/utf8_heavy.pl is
 * the lower-level routine, and it is similarly broken for returning
 * multiple values.  --jhi
 * For those, you should use S__to_utf8_case() instead */
/* Now SWASHGET is recasted into S_swatch_get in this file. */

/* Note:
 * Returns the value of property/mapping C<swash> for the first character
 * of the string C<ptr>. If C<do_utf8> is true, the string C<ptr> is
 * assumed to be in well-formed UTF-8. If C<do_utf8> is false, the string C<ptr>
 * is assumed to be in native 8-bit encoding. Caches the swatch in C<swash>.
 *
 * A "swash" is a hash which contains initially the keys/values set up by
 * SWASHNEW.  The purpose is to be able to completely represent a Unicode
 * property for all possible code points.  Things are stored in a compact form
 * (see utf8_heavy.pl) so that calculation is required to find the actual
 * property value for a given code point.  As code points are looked up, new
 * key/value pairs are added to the hash, so that the calculation doesn't have
 * to ever be re-done.  Further, each calculation is done, not just for the
 * desired one, but for a whole block of code points adjacent to that one.
 * For binary properties on ASCII machines, the block is usually for 64 code
 * points, starting with a code point evenly divisible by 64.  Thus if the
 * property value for code point 257 is requested, the code goes out and
 * calculates the property values for all 64 code points between 256 and 319,
 * and stores these as a single 64-bit long bit vector, called a "swatch",
 * under the key for code point 256.  The key is the UTF-8 encoding for code
 * point 256, minus the final byte.  Thus, if the length of the UTF-8 encoding
 * for a code point is 13 bytes, the key will be 12 bytes long.  If the value
 * for code point 258 is then requested, this code realizes that it would be
 * stored under the key for 256, and would find that value and extract the
 * relevant bit, offset from 256.
 *
 * Non-binary properties are stored in as many bits as necessary to represent
 * their values (32 currently, though the code is more general than that), not
 * as single bits, but the principal is the same: the value for each key is a
 * vector that encompasses the property values for all code points whose UTF-8
 * representations are represented by the key.  That is, for all code points
 * whose UTF-8 representations are length N bytes, and the key is the first N-1
 * bytes of that.
 */
UV
Perl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8)
{
    HV *const hv = MUTABLE_HV(SvRV(swash));
    U32 klen;
    U32 off;
    STRLEN slen = 0;
    STRLEN needents;
    const U8 *tmps = NULL;
    SV *swatch;
    const U8 c = *ptr;

    PERL_ARGS_ASSERT_SWASH_FETCH;

    /* If it really isn't a hash, it isn't really swash; must be an inversion
     * list */
    if (SvTYPE(hv) != SVt_PVHV) {
        return _invlist_contains_cp((SV*)hv,
                                    (do_utf8)
                                     ? valid_utf8_to_uvchr(ptr, NULL)
                                     : c);
    }

    /* We store the values in a "swatch" which is a vec() value in a swash
     * hash.  Code points 0-255 are a single vec() stored with key length
     * (klen) 0.  All other code points have a UTF-8 representation
     * 0xAA..0xYY,0xZZ.  A vec() is constructed containing all of them which
     * share 0xAA..0xYY, which is the key in the hash to that vec.  So the key
     * length for them is the length of the encoded char - 1.  ptr[klen] is the
     * final byte in the sequence representing the character */
    if (!do_utf8 || UTF8_IS_INVARIANT(c)) {
        klen = 0;
	needents = 256;
        off = c;
    }
    else if (UTF8_IS_DOWNGRADEABLE_START(c)) {
        klen = 0;
	needents = 256;
        off = EIGHT_BIT_UTF8_TO_NATIVE(c, *(ptr + 1));
    }
    else {
        klen = UTF8SKIP(ptr) - 1;

        /* Each vec() stores 2**UTF_ACCUMULATION_SHIFT values.  The offset into
         * the vec is the final byte in the sequence.  (In EBCDIC this is
         * converted to I8 to get consecutive values.)  To help you visualize
         * all this:
         *                       Straight 1047   After final byte
         *             UTF-8      UTF-EBCDIC     I8 transform
         *  U+0400:  \xD0\x80    \xB8\x41\x41    \xB8\x41\xA0
         *  U+0401:  \xD0\x81    \xB8\x41\x42    \xB8\x41\xA1
         *    ...
         *  U+0409:  \xD0\x89    \xB8\x41\x4A    \xB8\x41\xA9
         *  U+040A:  \xD0\x8A    \xB8\x41\x51    \xB8\x41\xAA
         *    ...
         *  U+0412:  \xD0\x92    \xB8\x41\x59    \xB8\x41\xB2
         *  U+0413:  \xD0\x93    \xB8\x41\x62    \xB8\x41\xB3
         *    ...
         *  U+041B:  \xD0\x9B    \xB8\x41\x6A    \xB8\x41\xBB
         *  U+041C:  \xD0\x9C    \xB8\x41\x70    \xB8\x41\xBC
         *    ...
         *  U+041F:  \xD0\x9F    \xB8\x41\x73    \xB8\x41\xBF
         *  U+0420:  \xD0\xA0    \xB8\x42\x41    \xB8\x42\x41
         *
         * (There are no discontinuities in the elided (...) entries.)
         * The UTF-8 key for these 33 code points is '\xD0' (which also is the
         * key for the next 31, up through U+043F, whose UTF-8 final byte is
         * \xBF).  Thus in UTF-8, each key is for a vec() for 64 code points.
         * The final UTF-8 byte, which ranges between \x80 and \xBF, is an
         * index into the vec() swatch (after subtracting 0x80, which we
         * actually do with an '&').
         * In UTF-EBCDIC, each key is for a 32 code point vec().  The first 32
         * code points above have key '\xB8\x41'. The final UTF-EBCDIC byte has
         * dicontinuities which go away by transforming it into I8, and we
         * effectively subtract 0xA0 to get the index. */
	needents = (1 << UTF_ACCUMULATION_SHIFT);
	off      = NATIVE_UTF8_TO_I8(ptr[klen]) & UTF_CONTINUATION_MASK;
    }

    /*
     * This single-entry cache saves about 1/3 of the UTF-8 overhead in test
     * suite.  (That is, only 7-8% overall over just a hash cache.  Still,
     * it's nothing to sniff at.)  Pity we usually come through at least
     * two function calls to get here...
     *
     * NB: this code assumes that swatches are never modified, once generated!
     */

    if (hv   == PL_last_swash_hv &&
	klen == PL_last_swash_klen &&
	(!klen || memEQ((char *)ptr, (char *)PL_last_swash_key, klen)) )
    {
	tmps = PL_last_swash_tmps;
	slen = PL_last_swash_slen;
    }
    else {
	/* Try our second-level swatch cache, kept in a hash. */
	SV** svp = hv_fetch(hv, (const char*)ptr, klen, FALSE);

	/* If not cached, generate it via swatch_get */
	if (!svp || !SvPOK(*svp)
		 || !(tmps = (const U8*)SvPV_const(*svp, slen)))
        {
            if (klen) {
                const UV code_point = valid_utf8_to_uvchr(ptr, NULL);
                swatch = swatch_get(swash,
                                    code_point & ~((UV)needents - 1),
				    needents);
            }
            else {  /* For the first 256 code points, the swatch has a key of
                       length 0 */
                swatch = swatch_get(swash, 0, needents);
            }

	    if (IN_PERL_COMPILETIME)
		CopHINTS_set(PL_curcop, PL_hints);

	    svp = hv_store(hv, (const char *)ptr, klen, swatch, 0);

	    if (!svp || !(tmps = (U8*)SvPV(*svp, slen))
		     || (slen << 3) < needents)
		Perl_croak(aTHX_ "panic: swash_fetch got improper swatch, "
			   "svp=%p, tmps=%p, slen=%"UVuf", needents=%"UVuf,
			   svp, tmps, (UV)slen, (UV)needents);
	}

	PL_last_swash_hv = hv;
	assert(klen <= sizeof(PL_last_swash_key));
	PL_last_swash_klen = (U8)klen;
	/* FIXME change interpvar.h?  */
	PL_last_swash_tmps = (U8 *) tmps;
	PL_last_swash_slen = slen;
	if (klen)
	    Copy(ptr, PL_last_swash_key, klen, U8);
    }

    switch ((int)((slen << 3) / needents)) {
    case 1:
	return ((UV) tmps[off >> 3] & (1 << (off & 7))) != 0;
    case 8:
	return ((UV) tmps[off]);
    case 16:
	off <<= 1;
	return
            ((UV) tmps[off    ] << 8) +
            ((UV) tmps[off + 1]);
    case 32:
	off <<= 2;
	return
            ((UV) tmps[off    ] << 24) +
            ((UV) tmps[off + 1] << 16) +
            ((UV) tmps[off + 2] <<  8) +
            ((UV) tmps[off + 3]);
    }
    Perl_croak(aTHX_ "panic: swash_fetch got swatch of unexpected bit width, "
	       "slen=%"UVuf", needents=%"UVuf, (UV)slen, (UV)needents);
    NORETURN_FUNCTION_END;
}

/* Read a single line of the main body of the swash input text.  These are of
 * the form:
 * 0053	0056	0073
 * where each number is hex.  The first two numbers form the minimum and
 * maximum of a range, and the third is the value associated with the range.
 * Not all swashes should have a third number
 *
 * On input: l	  points to the beginning of the line to be examined; it points
 *		  to somewhere in the string of the whole input text, and is
 *		  terminated by a \n or the null string terminator.
 *	     lend   points to the null terminator of that string
 *	     wants_value    is non-zero if the swash expects a third number
 *	     typestr is the name of the swash's mapping, like 'ToLower'
 * On output: *min, *max, and *val are set to the values read from the line.
 *	      returns a pointer just beyond the line examined.  If there was no
 *	      valid min number on the line, returns lend+1
 */

STATIC U8*
S_swash_scan_list_line(pTHX_ U8* l, U8* const lend, UV* min, UV* max, UV* val,
			     const bool wants_value, const U8* const typestr)
{
    const int  typeto  = typestr[0] == 'T' && typestr[1] == 'o';
    STRLEN numlen;	    /* Length of the number */
    I32 flags = PERL_SCAN_SILENT_ILLDIGIT
		| PERL_SCAN_DISALLOW_PREFIX
		| PERL_SCAN_SILENT_NON_PORTABLE;

    /* nl points to the next \n in the scan */
    U8* const nl = (U8*)memchr(l, '\n', lend - l);

    PERL_ARGS_ASSERT_SWASH_SCAN_LIST_LINE;

    /* Get the first number on the line: the range minimum */
    numlen = lend - l;
    *min = grok_hex((char *)l, &numlen, &flags, NULL);
    *max = *min;    /* So can never return without setting max */
    if (numlen)	    /* If found a hex number, position past it */
	l += numlen;
    else if (nl) {	    /* Else, go handle next line, if any */
	return nl + 1;	/* 1 is length of "\n" */
    }
    else {		/* Else, no next line */
	return lend + 1;	/* to LIST's end at which \n is not found */
    }

    /* The max range value follows, separated by a BLANK */
    if (isBLANK(*l)) {
	++l;
	flags = PERL_SCAN_SILENT_ILLDIGIT
		| PERL_SCAN_DISALLOW_PREFIX
		| PERL_SCAN_SILENT_NON_PORTABLE;
	numlen = lend - l;
	*max = grok_hex((char *)l, &numlen, &flags, NULL);
	if (numlen)
	    l += numlen;
	else    /* If no value here, it is a single element range */
	    *max = *min;

	/* Non-binary tables have a third entry: what the first element of the
	 * range maps to.  The map for those currently read here is in hex */
	if (wants_value) {
	    if (isBLANK(*l)) {
		++l;
                flags = PERL_SCAN_SILENT_ILLDIGIT
                    | PERL_SCAN_DISALLOW_PREFIX
                    | PERL_SCAN_SILENT_NON_PORTABLE;
                numlen = lend - l;
                *val = grok_hex((char *)l, &numlen, &flags, NULL);
                if (numlen)
                    l += numlen;
                else
                    *val = 0;
	    }
	    else {
		*val = 0;
		if (typeto) {
		    /* diag_listed_as: To%s: illegal mapping '%s' */
		    Perl_croak(aTHX_ "%s: illegal mapping '%s'",
				     typestr, l);
		}
	    }
	}
	else
	    *val = 0; /* bits == 1, then any val should be ignored */
    }
    else { /* Nothing following range min, should be single element with no
	      mapping expected */
	if (wants_value) {
	    *val = 0;
	    if (typeto) {
		/* diag_listed_as: To%s: illegal mapping '%s' */
		Perl_croak(aTHX_ "%s: illegal mapping '%s'", typestr, l);
	    }
	}
	else
	    *val = 0; /* bits == 1, then val should be ignored */
    }

    /* Position to next line if any, or EOF */
    if (nl)
	l = nl + 1;
    else
	l = lend;

    return l;
}

/* Note:
 * Returns a swatch (a bit vector string) for a code point sequence
 * that starts from the value C<start> and comprises the number C<span>.
 * A C<swash> must be an object created by SWASHNEW (see lib/utf8_heavy.pl).
 * Should be used via swash_fetch, which will cache the swatch in C<swash>.
 */
STATIC SV*
S_swatch_get(pTHX_ SV* swash, UV start, UV span)
{
    SV *swatch;
    U8 *l, *lend, *x, *xend, *s, *send;
    STRLEN lcur, xcur, scur;
    HV *const hv = MUTABLE_HV(SvRV(swash));
    SV** const invlistsvp = hv_fetchs(hv, "V", FALSE);

    SV** listsvp = NULL; /* The string containing the main body of the table */
    SV** extssvp = NULL;
    SV** invert_it_svp = NULL;
    U8* typestr = NULL;
    STRLEN bits;
    STRLEN octets; /* if bits == 1, then octets == 0 */
    UV  none;
    UV  end = start + span;

    if (invlistsvp == NULL) {
        SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);
        SV** const nonesvp = hv_fetchs(hv, "NONE", FALSE);
        SV** const typesvp = hv_fetchs(hv, "TYPE", FALSE);
        extssvp = hv_fetchs(hv, "EXTRAS", FALSE);
        listsvp = hv_fetchs(hv, "LIST", FALSE);
        invert_it_svp = hv_fetchs(hv, "INVERT_IT", FALSE);

	bits  = SvUV(*bitssvp);
	none  = SvUV(*nonesvp);
	typestr = (U8*)SvPV_nolen(*typesvp);
    }
    else {
	bits = 1;
	none = 0;
    }
    octets = bits >> 3; /* if bits == 1, then octets == 0 */

    PERL_ARGS_ASSERT_SWATCH_GET;

    if (bits != 1 && bits != 8 && bits != 16 && bits != 32) {
	Perl_croak(aTHX_ "panic: swatch_get doesn't expect bits %"UVuf,
						 (UV)bits);
    }

    /* If overflowed, use the max possible */
    if (end < start) {
	end = UV_MAX;
	span = end - start;
    }

    /* create and initialize $swatch */
    scur   = octets ? (span * octets) : (span + 7) / 8;
    swatch = newSV(scur);
    SvPOK_on(swatch);
    s = (U8*)SvPVX(swatch);
    if (octets && none) {
	const U8* const e = s + scur;
	while (s < e) {
	    if (bits == 8)
		*s++ = (U8)(none & 0xff);
	    else if (bits == 16) {
		*s++ = (U8)((none >>  8) & 0xff);
		*s++ = (U8)( none        & 0xff);
	    }
	    else if (bits == 32) {
		*s++ = (U8)((none >> 24) & 0xff);
		*s++ = (U8)((none >> 16) & 0xff);
		*s++ = (U8)((none >>  8) & 0xff);
		*s++ = (U8)( none        & 0xff);
	    }
	}
	*s = '\0';
    }
    else {
	(void)memzero((U8*)s, scur + 1);
    }
    SvCUR_set(swatch, scur);
    s = (U8*)SvPVX(swatch);

    if (invlistsvp) {	/* If has an inversion list set up use that */
	_invlist_populate_swatch(*invlistsvp, start, end, s);
        return swatch;
    }

    /* read $swash->{LIST} */
    l = (U8*)SvPV(*listsvp, lcur);
    lend = l + lcur;
    while (l < lend) {
	UV min, max, val, upper;
	l = swash_scan_list_line(l, lend, &min, &max, &val,
                                                        cBOOL(octets), typestr);
	if (l > lend) {
	    break;
	}

	/* If looking for something beyond this range, go try the next one */
	if (max < start)
	    continue;

	/* <end> is generally 1 beyond where we want to set things, but at the
	 * platform's infinity, where we can't go any higher, we want to
	 * include the code point at <end> */
        upper = (max < end)
                ? max
                : (max != UV_MAX || end != UV_MAX)
                  ? end - 1
                  : end;

	if (octets) {
	    UV key;
	    if (min < start) {
		if (!none || val < none) {
		    val += start - min;
		}
		min = start;
	    }
	    for (key = min; key <= upper; key++) {
		STRLEN offset;
		/* offset must be non-negative (start <= min <= key < end) */
		offset = octets * (key - start);
		if (bits == 8)
		    s[offset] = (U8)(val & 0xff);
		else if (bits == 16) {
		    s[offset    ] = (U8)((val >>  8) & 0xff);
		    s[offset + 1] = (U8)( val        & 0xff);
		}
		else if (bits == 32) {
		    s[offset    ] = (U8)((val >> 24) & 0xff);
		    s[offset + 1] = (U8)((val >> 16) & 0xff);
		    s[offset + 2] = (U8)((val >>  8) & 0xff);
		    s[offset + 3] = (U8)( val        & 0xff);
		}

		if (!none || val < none)
		    ++val;
	    }
	}
	else { /* bits == 1, then val should be ignored */
	    UV key;
	    if (min < start)
		min = start;

	    for (key = min; key <= upper; key++) {
		const STRLEN offset = (STRLEN)(key - start);
		s[offset >> 3] |= 1 << (offset & 7);
	    }
	}
    } /* while */

    /* Invert if the data says it should be.  Assumes that bits == 1 */
    if (invert_it_svp && SvUV(*invert_it_svp)) {

	/* Unicode properties should come with all bits above PERL_UNICODE_MAX
	 * be 0, and their inversion should also be 0, as we don't succeed any
	 * Unicode property matches for non-Unicode code points */
	if (start <= PERL_UNICODE_MAX) {

	    /* The code below assumes that we never cross the
	     * Unicode/above-Unicode boundary in a range, as otherwise we would
	     * have to figure out where to stop flipping the bits.  Since this
	     * boundary is divisible by a large power of 2, and swatches comes
	     * in small powers of 2, this should be a valid assumption */
	    assert(start + span - 1 <= PERL_UNICODE_MAX);

	    send = s + scur;
	    while (s < send) {
		*s = ~(*s);
		s++;
	    }
	}
    }

    /* read $swash->{EXTRAS}
     * This code also copied to swash_to_invlist() below */
    x = (U8*)SvPV(*extssvp, xcur);
    xend = x + xcur;
    while (x < xend) {
	STRLEN namelen;
	U8 *namestr;
	SV** othersvp;
	HV* otherhv;
	STRLEN otherbits;
	SV **otherbitssvp, *other;
	U8 *s, *o, *nl;
	STRLEN slen, olen;

	const U8 opc = *x++;
	if (opc == '\n')
	    continue;

	nl = (U8*)memchr(x, '\n', xend - x);

	if (opc != '-' && opc != '+' && opc != '!' && opc != '&') {
	    if (nl) {
		x = nl + 1; /* 1 is length of "\n" */
		continue;
	    }
	    else {
		x = xend; /* to EXTRAS' end at which \n is not found */
		break;
	    }
	}

	namestr = x;
	if (nl) {
	    namelen = nl - namestr;
	    x = nl + 1;
	}
	else {
	    namelen = xend - namestr;
	    x = xend;
	}

	othersvp = hv_fetch(hv, (char *)namestr, namelen, FALSE);
	otherhv = MUTABLE_HV(SvRV(*othersvp));
	otherbitssvp = hv_fetchs(otherhv, "BITS", FALSE);
	otherbits = (STRLEN)SvUV(*otherbitssvp);
	if (bits < otherbits)
	    Perl_croak(aTHX_ "panic: swatch_get found swatch size mismatch, "
		       "bits=%"UVuf", otherbits=%"UVuf, (UV)bits, (UV)otherbits);

	/* The "other" swatch must be destroyed after. */
	other = swatch_get(*othersvp, start, span);
	o = (U8*)SvPV(other, olen);

	if (!olen)
	    Perl_croak(aTHX_ "panic: swatch_get got improper swatch");

	s = (U8*)SvPV(swatch, slen);
	if (bits == 1 && otherbits == 1) {
	    if (slen != olen)
		Perl_croak(aTHX_ "panic: swatch_get found swatch length "
			   "mismatch, slen=%"UVuf", olen=%"UVuf,
			   (UV)slen, (UV)olen);

	    switch (opc) {
	    case '+':
		while (slen--)
		    *s++ |= *o++;
		break;
	    case '!':
		while (slen--)
		    *s++ |= ~*o++;
		break;
	    case '-':
		while (slen--)
		    *s++ &= ~*o++;
		break;
	    case '&':
		while (slen--)
		    *s++ &= *o++;
		break;
	    default:
		break;
	    }
	}
	else {
	    STRLEN otheroctets = otherbits >> 3;
	    STRLEN offset = 0;
	    U8* const send = s + slen;

	    while (s < send) {
		UV otherval = 0;

		if (otherbits == 1) {
		    otherval = (o[offset >> 3] >> (offset & 7)) & 1;
		    ++offset;
		}
		else {
		    STRLEN vlen = otheroctets;
		    otherval = *o++;
		    while (--vlen) {
			otherval <<= 8;
			otherval |= *o++;
		    }
		}

		if (opc == '+' && otherval)
		    NOOP;   /* replace with otherval */
		else if (opc == '!' && !otherval)
		    otherval = 1;
		else if (opc == '-' && otherval)
		    otherval = 0;
		else if (opc == '&' && !otherval)
		    otherval = 0;
		else {
		    s += octets; /* no replacement */
		    continue;
		}

		if (bits == 8)
		    *s++ = (U8)( otherval & 0xff);
		else if (bits == 16) {
		    *s++ = (U8)((otherval >>  8) & 0xff);
		    *s++ = (U8)( otherval        & 0xff);
		}
		else if (bits == 32) {
		    *s++ = (U8)((otherval >> 24) & 0xff);
		    *s++ = (U8)((otherval >> 16) & 0xff);
		    *s++ = (U8)((otherval >>  8) & 0xff);
		    *s++ = (U8)( otherval        & 0xff);
		}
	    }
	}
	sv_free(other); /* through with it! */
    } /* while */
    return swatch;
}

HV*
Perl__swash_inversion_hash(pTHX_ SV* const swash)
{

   /* Subject to change or removal.  For use only in regcomp.c and regexec.c
    * Can't be used on a property that is subject to user override, as it
    * relies on the value of SPECIALS in the swash which would be set by
    * utf8_heavy.pl to the hash in the non-overriden file, and hence is not set
    * for overridden properties
    *
    * Returns a hash which is the inversion and closure of a swash mapping.
    * For example, consider the input lines:
    * 004B		006B
    * 004C		006C
    * 212A		006B
    *
    * The returned hash would have two keys, the UTF-8 for 006B and the UTF-8 for
    * 006C.  The value for each key is an array.  For 006C, the array would
    * have two elements, the UTF-8 for itself, and for 004C.  For 006B, there
    * would be three elements in its array, the UTF-8 for 006B, 004B and 212A.
    *
    * Note that there are no elements in the hash for 004B, 004C, 212A.  The
    * keys are only code points that are folded-to, so it isn't a full closure.
    *
    * Essentially, for any code point, it gives all the code points that map to
    * it, or the list of 'froms' for that point.
    *
    * Currently it ignores any additions or deletions from other swashes,
    * looking at just the main body of the swash, and if there are SPECIALS
    * in the swash, at that hash
    *
    * The specials hash can be extra code points, and most likely consists of
    * maps from single code points to multiple ones (each expressed as a string
    * of UTF-8 characters).   This function currently returns only 1-1 mappings.
    * However consider this possible input in the specials hash:
    * "\xEF\xAC\x85" => "\x{0073}\x{0074}",         # U+FB05 => 0073 0074
    * "\xEF\xAC\x86" => "\x{0073}\x{0074}",         # U+FB06 => 0073 0074
    *
    * Both FB05 and FB06 map to the same multi-char sequence, which we don't
    * currently handle.  But it also means that FB05 and FB06 are equivalent in
    * a 1-1 mapping which we should handle, and this relationship may not be in
    * the main table.  Therefore this function examines all the multi-char
    * sequences and adds the 1-1 mappings that come out of that.
    *
    * XXX This function was originally intended to be multipurpose, but its
    * only use is quite likely to remain for constructing the inversion of
    * the CaseFolding (//i) property.  If it were more general purpose for
    * regex patterns, it would have to do the FB05/FB06 game for simple folds,
    * because certain folds are prohibited under /iaa and /il.  As an example,
    * in Unicode 3.0.1 both U+0130 and U+0131 fold to 'i', and hence are both
    * equivalent under /i.  But under /iaa and /il, the folds to 'i' are
    * prohibited, so we would not figure out that they fold to each other.
    * Code could be written to automatically figure this out, similar to the
    * code that does this for multi-character folds, but this is the only case
    * where something like this is ever likely to happen, as all the single
    * char folds to the 0-255 range are now quite settled.  Instead there is a
    * little special code that is compiled only for this Unicode version.  This
    * is smaller and didn't require much coding time to do.  But this makes
    * this routine strongly tied to being used just for CaseFolding.  If ever
    * it should be generalized, this would have to be fixed */

    U8 *l, *lend;
    STRLEN lcur;
    HV *const hv = MUTABLE_HV(SvRV(swash));

    /* The string containing the main body of the table.  This will have its
     * assertion fail if the swash has been converted to its inversion list */
    SV** const listsvp = hv_fetchs(hv, "LIST", FALSE);

    SV** const typesvp = hv_fetchs(hv, "TYPE", FALSE);
    SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);
    SV** const nonesvp = hv_fetchs(hv, "NONE", FALSE);
    /*SV** const extssvp = hv_fetchs(hv, "EXTRAS", FALSE);*/
    const U8* const typestr = (U8*)SvPV_nolen(*typesvp);
    const STRLEN bits  = SvUV(*bitssvp);
    const STRLEN octets = bits >> 3; /* if bits == 1, then octets == 0 */
    const UV     none  = SvUV(*nonesvp);
    SV **specials_p = hv_fetchs(hv, "SPECIALS", 0);

    HV* ret = newHV();

    PERL_ARGS_ASSERT__SWASH_INVERSION_HASH;

    /* Must have at least 8 bits to get the mappings */
    if (bits != 8 && bits != 16 && bits != 32) {
	Perl_croak(aTHX_ "panic: swash_inversion_hash doesn't expect bits %"UVuf,
						 (UV)bits);
    }

    if (specials_p) { /* It might be "special" (sometimes, but not always, a
			mapping to more than one character */

	/* Construct an inverse mapping hash for the specials */
	HV * const specials_hv = MUTABLE_HV(SvRV(*specials_p));
	HV * specials_inverse = newHV();
	char *char_from; /* the lhs of the map */
	I32 from_len;   /* its byte length */
	char *char_to;  /* the rhs of the map */
	I32 to_len;	/* its byte length */
	SV *sv_to;	/* and in a sv */
	AV* from_list;  /* list of things that map to each 'to' */

	hv_iterinit(specials_hv);

	/* The keys are the characters (in UTF-8) that map to the corresponding
	 * UTF-8 string value.  Iterate through the list creating the inverse
	 * list. */
	while ((sv_to = hv_iternextsv(specials_hv, &char_from, &from_len))) {
	    SV** listp;
	    if (! SvPOK(sv_to)) {
		Perl_croak(aTHX_ "panic: value returned from hv_iternextsv() "
			   "unexpectedly is not a string, flags=%lu",
			   (unsigned long)SvFLAGS(sv_to));
	    }
	    /*DEBUG_U(PerlIO_printf(Perl_debug_log, "Found mapping from %"UVXf", First char of to is %"UVXf"\n", valid_utf8_to_uvchr((U8*) char_from, 0), valid_utf8_to_uvchr((U8*) SvPVX(sv_to), 0)));*/

	    /* Each key in the inverse list is a mapped-to value, and the key's
	     * hash value is a list of the strings (each in UTF-8) that map to
	     * it.  Those strings are all one character long */
	    if ((listp = hv_fetch(specials_inverse,
				    SvPVX(sv_to),
				    SvCUR(sv_to), 0)))
	    {
		from_list = (AV*) *listp;
	    }
	    else { /* No entry yet for it: create one */
		from_list = newAV();
		if (! hv_store(specials_inverse,
				SvPVX(sv_to),
				SvCUR(sv_to),
				(SV*) from_list, 0))
		{
		    Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
		}
	    }

	    /* Here have the list associated with this 'to' (perhaps newly
	     * created and empty).  Just add to it.  Note that we ASSUME that
	     * the input is guaranteed to not have duplications, so we don't
	     * check for that.  Duplications just slow down execution time. */
	    av_push(from_list, newSVpvn_utf8(char_from, from_len, TRUE));
	}

	/* Here, 'specials_inverse' contains the inverse mapping.  Go through
	 * it looking for cases like the FB05/FB06 examples above.  There would
	 * be an entry in the hash like
	*	'st' => [ FB05, FB06 ]
	* In this example we will create two lists that get stored in the
	* returned hash, 'ret':
	*	FB05 => [ FB05, FB06 ]
	*	FB06 => [ FB05, FB06 ]
	*
	* Note that there is nothing to do if the array only has one element.
	* (In the normal 1-1 case handled below, we don't have to worry about
	* two lists, as everything gets tied to the single list that is
	* generated for the single character 'to'.  But here, we are omitting
	* that list, ('st' in the example), so must have multiple lists.) */
	while ((from_list = (AV *) hv_iternextsv(specials_inverse,
						 &char_to, &to_len)))
	{
	    if (av_tindex_nomg(from_list) > 0) {
		SSize_t i;

		/* We iterate over all combinations of i,j to place each code
		 * point on each list */
		for (i = 0; i <= av_tindex_nomg(from_list); i++) {
		    SSize_t j;
		    AV* i_list = newAV();
		    SV** entryp = av_fetch(from_list, i, FALSE);
		    if (entryp == NULL) {
			Perl_croak(aTHX_ "panic: av_fetch() unexpectedly failed");
		    }
		    if (hv_fetch(ret, SvPVX(*entryp), SvCUR(*entryp), FALSE)) {
			Perl_croak(aTHX_ "panic: unexpected entry for %s", SvPVX(*entryp));
		    }
		    if (! hv_store(ret, SvPVX(*entryp), SvCUR(*entryp),
				   (SV*) i_list, FALSE))
		    {
			Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
		    }

		    /* For DEBUG_U: UV u = valid_utf8_to_uvchr((U8*) SvPVX(*entryp), 0);*/
		    for (j = 0; j <= av_tindex_nomg(from_list); j++) {
			entryp = av_fetch(from_list, j, FALSE);
			if (entryp == NULL) {
			    Perl_croak(aTHX_ "panic: av_fetch() unexpectedly failed");
			}

			/* When i==j this adds itself to the list */
			av_push(i_list, newSVuv(utf8_to_uvchr_buf(
					(U8*) SvPVX(*entryp),
					(U8*) SvPVX(*entryp) + SvCUR(*entryp),
					0)));
			/*DEBUG_U(PerlIO_printf(Perl_debug_log, "%s: %d: Adding %"UVXf" to list for %"UVXf"\n", __FILE__, __LINE__, valid_utf8_to_uvchr((U8*) SvPVX(*entryp), 0), u));*/
		    }
		}
	    }
	}
	SvREFCNT_dec(specials_inverse); /* done with it */
    } /* End of specials */

    /* read $swash->{LIST} */

#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1

    /* For this version only U+130 and U+131 are equivalent under qr//i.  Add a
     * rule so that things work under /iaa and /il */

    SV * mod_listsv = sv_mortalcopy(*listsvp);
    sv_catpv(mod_listsv, "130\t130\t131\n");
    l = (U8*)SvPV(mod_listsv, lcur);

#else

    l = (U8*)SvPV(*listsvp, lcur);

#endif

    lend = l + lcur;

    /* Go through each input line */
    while (l < lend) {
	UV min, max, val;
	UV inverse;
	l = swash_scan_list_line(l, lend, &min, &max, &val,
                                                     cBOOL(octets), typestr);
	if (l > lend) {
	    break;
	}

	/* Each element in the range is to be inverted */
	for (inverse = min; inverse <= max; inverse++) {
	    AV* list;
	    SV** listp;
	    IV i;
	    bool found_key = FALSE;
	    bool found_inverse = FALSE;

	    /* The key is the inverse mapping */
	    char key[UTF8_MAXBYTES+1];
	    char* key_end = (char *) uvchr_to_utf8((U8*) key, val);
	    STRLEN key_len = key_end - key;

	    /* Get the list for the map */
	    if ((listp = hv_fetch(ret, key, key_len, FALSE))) {
		list = (AV*) *listp;
	    }
	    else { /* No entry yet for it: create one */
		list = newAV();
		if (! hv_store(ret, key, key_len, (SV*) list, FALSE)) {
		    Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
		}
	    }

	    /* Look through list to see if this inverse mapping already is
	     * listed, or if there is a mapping to itself already */
	    for (i = 0; i <= av_tindex_nomg(list); i++) {
		SV** entryp = av_fetch(list, i, FALSE);
		SV* entry;
		UV uv;
		if (entryp == NULL) {
		    Perl_croak(aTHX_ "panic: av_fetch() unexpectedly failed");
		}
		entry = *entryp;
		uv = SvUV(entry);
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "list for %"UVXf" contains %"UVXf"\n", val, uv));*/
		if (uv == val) {
		    found_key = TRUE;
		}
		if (uv == inverse) {
		    found_inverse = TRUE;
		}

		/* No need to continue searching if found everything we are
		 * looking for */
		if (found_key && found_inverse) {
		    break;
		}
	    }

	    /* Make sure there is a mapping to itself on the list */
	    if (! found_key) {
		av_push(list, newSVuv(val));
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "%s: %d: Adding %"UVXf" to list for %"UVXf"\n", __FILE__, __LINE__, val, val));*/
	    }


	    /* Simply add the value to the list */
	    if (! found_inverse) {
		av_push(list, newSVuv(inverse));
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "%s: %d: Adding %"UVXf" to list for %"UVXf"\n", __FILE__, __LINE__, inverse, val));*/
	    }

	    /* swatch_get() increments the value of val for each element in the
	     * range.  That makes more compact tables possible.  You can
	     * express the capitalization, for example, of all consecutive
	     * letters with a single line: 0061\t007A\t0041 This maps 0061 to
	     * 0041, 0062 to 0042, etc.  I (khw) have never understood 'none',
	     * and it's not documented; it appears to be used only in
	     * implementing tr//; I copied the semantics from swatch_get(), just
	     * in case */
	    if (!none || val < none) {
		++val;
	    }
	}
    }

    return ret;
}

SV*
Perl__swash_to_invlist(pTHX_ SV* const swash)
{

   /* Subject to change or removal.  For use only in one place in regcomp.c.
    * Ownership is given to one reference count in the returned SV* */

    U8 *l, *lend;
    char *loc;
    STRLEN lcur;
    HV *const hv = MUTABLE_HV(SvRV(swash));
    UV elements = 0;    /* Number of elements in the inversion list */
    U8 empty[] = "";
    SV** listsvp;
    SV** typesvp;
    SV** bitssvp;
    SV** extssvp;
    SV** invert_it_svp;

    U8* typestr;
    STRLEN bits;
    STRLEN octets; /* if bits == 1, then octets == 0 */
    U8 *x, *xend;
    STRLEN xcur;

    SV* invlist;

    PERL_ARGS_ASSERT__SWASH_TO_INVLIST;

    /* If not a hash, it must be the swash's inversion list instead */
    if (SvTYPE(hv) != SVt_PVHV) {
        return SvREFCNT_inc_simple_NN((SV*) hv);
    }

    /* The string containing the main body of the table */
    listsvp = hv_fetchs(hv, "LIST", FALSE);
    typesvp = hv_fetchs(hv, "TYPE", FALSE);
    bitssvp = hv_fetchs(hv, "BITS", FALSE);
    extssvp = hv_fetchs(hv, "EXTRAS", FALSE);
    invert_it_svp = hv_fetchs(hv, "INVERT_IT", FALSE);

    typestr = (U8*)SvPV_nolen(*typesvp);
    bits  = SvUV(*bitssvp);
    octets = bits >> 3; /* if bits == 1, then octets == 0 */

    /* read $swash->{LIST} */
    if (SvPOK(*listsvp)) {
	l = (U8*)SvPV(*listsvp, lcur);
    }
    else {
	/* LIST legitimately doesn't contain a string during compilation phases
	 * of Perl itself, before the Unicode tables are generated.  In this
	 * case, just fake things up by creating an empty list */
	l = empty;
	lcur = 0;
    }
    loc = (char *) l;
    lend = l + lcur;

    if (*l == 'V') {    /*  Inversion list format */
        const char *after_atou = (char *) lend;
        UV element0;
        UV* other_elements_ptr;

        /* The first number is a count of the rest */
        l++;
        if (!grok_atoUV((const char *)l, &elements, &after_atou)) {
            Perl_croak(aTHX_ "panic: Expecting a valid count of elements at start of inversion list");
        }
        if (elements == 0) {
            invlist = _new_invlist(0);
        }
        else {
            while (isSPACE(*l)) l++;
            l = (U8 *) after_atou;

            /* Get the 0th element, which is needed to setup the inversion list */
            while (isSPACE(*l)) l++;
            if (!grok_atoUV((const char *)l, &element0, &after_atou)) {
                Perl_croak(aTHX_ "panic: Expecting a valid 0th element for inversion list");
            }
            l = (U8 *) after_atou;
            invlist = _setup_canned_invlist(elements, element0, &other_elements_ptr);
            elements--;

            /* Then just populate the rest of the input */
            while (elements-- > 0) {
                if (l > lend) {
                    Perl_croak(aTHX_ "panic: Expecting %"UVuf" more elements than available", elements);
                }
                while (isSPACE(*l)) l++;
                if (!grok_atoUV((const char *)l, other_elements_ptr++, &after_atou)) {
                    Perl_croak(aTHX_ "panic: Expecting a valid element in inversion list");
                }
                l = (U8 *) after_atou;
            }
        }
    }
    else {

        /* Scan the input to count the number of lines to preallocate array
         * size based on worst possible case, which is each line in the input
         * creates 2 elements in the inversion list: 1) the beginning of a
         * range in the list; 2) the beginning of a range not in the list.  */
        while ((loc = (strchr(loc, '\n'))) != NULL) {
            elements += 2;
            loc++;
        }

        /* If the ending is somehow corrupt and isn't a new line, add another
         * element for the final range that isn't in the inversion list */
        if (! (*lend == '\n'
            || (*lend == '\0' && (lcur == 0 || *(lend - 1) == '\n'))))
        {
            elements++;
        }

        invlist = _new_invlist(elements);

        /* Now go through the input again, adding each range to the list */
        while (l < lend) {
            UV start, end;
            UV val;		/* Not used by this function */

            l = swash_scan_list_line(l, lend, &start, &end, &val,
                                                        cBOOL(octets), typestr);

            if (l > lend) {
                break;
            }

            invlist = _add_range_to_invlist(invlist, start, end);
        }
    }

    /* Invert if the data says it should be */
    if (invert_it_svp && SvUV(*invert_it_svp)) {
	_invlist_invert(invlist);
    }

    /* This code is copied from swatch_get()
     * read $swash->{EXTRAS} */
    x = (U8*)SvPV(*extssvp, xcur);
    xend = x + xcur;
    while (x < xend) {
	STRLEN namelen;
	U8 *namestr;
	SV** othersvp;
	HV* otherhv;
	STRLEN otherbits;
	SV **otherbitssvp, *other;
	U8 *nl;

	const U8 opc = *x++;
	if (opc == '\n')
	    continue;

	nl = (U8*)memchr(x, '\n', xend - x);

	if (opc != '-' && opc != '+' && opc != '!' && opc != '&') {
	    if (nl) {
		x = nl + 1; /* 1 is length of "\n" */
		continue;
	    }
	    else {
		x = xend; /* to EXTRAS' end at which \n is not found */
		break;
	    }
	}

	namestr = x;
	if (nl) {
	    namelen = nl - namestr;
	    x = nl + 1;
	}
	else {
	    namelen = xend - namestr;
	    x = xend;
	}

	othersvp = hv_fetch(hv, (char *)namestr, namelen, FALSE);
	otherhv = MUTABLE_HV(SvRV(*othersvp));
	otherbitssvp = hv_fetchs(otherhv, "BITS", FALSE);
	otherbits = (STRLEN)SvUV(*otherbitssvp);

	if (bits != otherbits || bits != 1) {
	    Perl_croak(aTHX_ "panic: _swash_to_invlist only operates on boolean "
		       "properties, bits=%"UVuf", otherbits=%"UVuf,
		       (UV)bits, (UV)otherbits);
	}

	/* The "other" swatch must be destroyed after. */
	other = _swash_to_invlist((SV *)*othersvp);

	/* End of code copied from swatch_get() */
	switch (opc) {
	case '+':
	    _invlist_union(invlist, other, &invlist);
	    break;
	case '!':
            _invlist_union_maybe_complement_2nd(invlist, other, TRUE, &invlist);
	    break;
	case '-':
	    _invlist_subtract(invlist, other, &invlist);
	    break;
	case '&':
	    _invlist_intersection(invlist, other, &invlist);
	    break;
	default:
	    break;
	}
	sv_free(other); /* through with it! */
    }

    SvREADONLY_on(invlist);
    return invlist;
}

SV*
Perl__get_swash_invlist(pTHX_ SV* const swash)
{
    SV** ptr;

    PERL_ARGS_ASSERT__GET_SWASH_INVLIST;

    if (! SvROK(swash)) {
        return NULL;
    }

    /* If it really isn't a hash, it isn't really swash; must be an inversion
     * list */
    if (SvTYPE(SvRV(swash)) != SVt_PVHV) {
        return SvRV(swash);
    }

    ptr = hv_fetchs(MUTABLE_HV(SvRV(swash)), "V", FALSE);
    if (! ptr) {
        return NULL;
    }

    return *ptr;
}

bool
Perl_check_utf8_print(pTHX_ const U8* s, const STRLEN len)
{
    /* May change: warns if surrogates, non-character code points, or
     * non-Unicode code points are in s which has length len bytes.  Returns
     * TRUE if none found; FALSE otherwise.  The only other validity check is
     * to make sure that this won't exceed the string's length.
     *
     * Code points above the platform's C<IV_MAX> will raise a deprecation
     * warning, unless those are turned off.  */

    const U8* const e = s + len;
    bool ok = TRUE;

    PERL_ARGS_ASSERT_CHECK_UTF8_PRINT;

    while (s < e) {
	if (UTF8SKIP(s) > len) {
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
			   "%s in %s", unees, PL_op ? OP_DESC(PL_op) : "print");
	    return FALSE;
	}
	if (UNLIKELY(isUTF8_POSSIBLY_PROBLEMATIC(*s))) {
	    STRLEN char_len;
	    if (UTF8_IS_SUPER(s, e)) {
                if (   ckWARN_d(WARN_NON_UNICODE)
                    || (   ckWARN_d(WARN_DEPRECATED)
#if defined(UV_IS_QUAD)
                        /* 2**63 and up meet these conditions provided we have
                         * a 64-bit word. */
#   ifdef EBCDIC
                        && *s == 0xFE && e - s >= UTF8_MAXBYTES
                        && s[1] >= 0x49
#   else
                        && *s == 0xFF && e -s >= UTF8_MAXBYTES
                        && s[2] >= 0x88
#   endif
#else   /* Below is 32-bit words */
                        /* 2**31 and above meet these conditions on all EBCDIC
                         * pages recognized for 32-bit platforms */
#   ifdef EBCDIC
                        && *s == 0xFE && e - s >= UTF8_MAXBYTES
                        && s[6] >= 0x43
#   else
                        && *s >= 0xFE
#   endif
#endif
                )) {
                    /* A side effect of this function will be to warn */
                    (void) utf8n_to_uvchr(s, e - s, &char_len, UTF8_WARN_SUPER);
                    ok = FALSE;
                }
	    }
	    else if (UTF8_IS_SURROGATE(s, e)) {
		if (ckWARN_d(WARN_SURROGATE)) {
                    /* This has a different warning than the one the called
                     * function would output, so can't just call it, unlike we
                     * do for the non-chars and above-unicodes */
		    UV uv = utf8_to_uvchr_buf(s, e, &char_len);
		    Perl_warner(aTHX_ packWARN(WARN_SURROGATE),
			"Unicode surrogate U+%04"UVXf" is illegal in UTF-8", uv);
		    ok = FALSE;
		}
	    }
	    else if ((UTF8_IS_NONCHAR(s, e)) && (ckWARN_d(WARN_NONCHAR))) {
                /* A side effect of this function will be to warn */
                (void) utf8n_to_uvchr(s, e - s, &char_len, UTF8_WARN_NONCHAR);
		ok = FALSE;
	    }
	}
	s += UTF8SKIP(s);
    }

    return ok;
}

/*
=for apidoc pv_uni_display

Build to the scalar C<dsv> a displayable version of the string C<spv>,
length C<len>, the displayable version being at most C<pvlim> bytes long
(if longer, the rest is truncated and C<"..."> will be appended).

The C<flags> argument can have C<UNI_DISPLAY_ISPRINT> set to display
C<isPRINT()>able characters as themselves, C<UNI_DISPLAY_BACKSLASH>
to display the C<\\[nrfta\\]> as the backslashed versions (like C<"\n">)
(C<UNI_DISPLAY_BACKSLASH> is preferred over C<UNI_DISPLAY_ISPRINT> for C<"\\">).
C<UNI_DISPLAY_QQ> (and its alias C<UNI_DISPLAY_REGEX>) have both
C<UNI_DISPLAY_BACKSLASH> and C<UNI_DISPLAY_ISPRINT> turned on.

The pointer to the PV of the C<dsv> is returned.

See also L</sv_uni_display>.

=cut */
char *
Perl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags)
{
    int truncated = 0;
    const char *s, *e;

    PERL_ARGS_ASSERT_PV_UNI_DISPLAY;

    sv_setpvs(dsv, "");
    SvUTF8_off(dsv);
    for (s = (const char *)spv, e = s + len; s < e; s += UTF8SKIP(s)) {
	 UV u;
	  /* This serves double duty as a flag and a character to print after
	     a \ when flags & UNI_DISPLAY_BACKSLASH is true.
	  */
	 char ok = 0;

	 if (pvlim && SvCUR(dsv) >= pvlim) {
	      truncated++;
	      break;
	 }
	 u = utf8_to_uvchr_buf((U8*)s, (U8*)e, 0);
	 if (u < 256) {
	     const unsigned char c = (unsigned char)u & 0xFF;
	     if (flags & UNI_DISPLAY_BACKSLASH) {
	         switch (c) {
		 case '\n':
		     ok = 'n'; break;
		 case '\r':
		     ok = 'r'; break;
		 case '\t':
		     ok = 't'; break;
		 case '\f':
		     ok = 'f'; break;
		 case '\a':
		     ok = 'a'; break;
		 case '\\':
		     ok = '\\'; break;
		 default: break;
		 }
		 if (ok) {
		     const char string = ok;
		     sv_catpvs(dsv, "\\");
		     sv_catpvn(dsv, &string, 1);
		 }
	     }
	     /* isPRINT() is the locale-blind version. */
	     if (!ok && (flags & UNI_DISPLAY_ISPRINT) && isPRINT(c)) {
		 const char string = c;
		 sv_catpvn(dsv, &string, 1);
		 ok = 1;
	     }
	 }
	 if (!ok)
	     Perl_sv_catpvf(aTHX_ dsv, "\\x{%"UVxf"}", u);
    }
    if (truncated)
	 sv_catpvs(dsv, "...");

    return SvPVX(dsv);
}

/*
=for apidoc sv_uni_display

Build to the scalar C<dsv> a displayable version of the scalar C<sv>,
the displayable version being at most C<pvlim> bytes long
(if longer, the rest is truncated and "..." will be appended).

The C<flags> argument is as in L</pv_uni_display>().

The pointer to the PV of the C<dsv> is returned.

=cut
*/
char *
Perl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)
{
    const char * const ptr =
        isREGEXP(ssv) ? RX_WRAPPED((REGEXP*)ssv) : SvPVX_const(ssv);

    PERL_ARGS_ASSERT_SV_UNI_DISPLAY;

    return Perl_pv_uni_display(aTHX_ dsv, (const U8*)ptr,
				SvCUR(ssv), pvlim, flags);
}

/*
=for apidoc foldEQ_utf8

Returns true if the leading portions of the strings C<s1> and C<s2> (either or both
of which may be in UTF-8) are the same case-insensitively; false otherwise.
How far into the strings to compare is determined by other input parameters.

If C<u1> is true, the string C<s1> is assumed to be in UTF-8-encoded Unicode;
otherwise it is assumed to be in native 8-bit encoding.  Correspondingly for C<u2>
with respect to C<s2>.

If the byte length C<l1> is non-zero, it says how far into C<s1> to check for fold
equality.  In other words, C<s1>+C<l1> will be used as a goal to reach.  The
scan will not be considered to be a match unless the goal is reached, and
scanning won't continue past that goal.  Correspondingly for C<l2> with respect to
C<s2>.

If C<pe1> is non-C<NULL> and the pointer it points to is not C<NULL>, that pointer is
considered an end pointer to the position 1 byte past the maximum point
in C<s1> beyond which scanning will not continue under any circumstances.
(This routine assumes that UTF-8 encoded input strings are not malformed;
malformed input can cause it to read past C<pe1>).
This means that if both C<l1> and C<pe1> are specified, and C<pe1>
is less than C<s1>+C<l1>, the match will never be successful because it can
never
get as far as its goal (and in fact is asserted against).  Correspondingly for
C<pe2> with respect to C<s2>.

At least one of C<s1> and C<s2> must have a goal (at least one of C<l1> and
C<l2> must be non-zero), and if both do, both have to be
reached for a successful match.   Also, if the fold of a character is multiple
characters, all of them must be matched (see tr21 reference below for
'folding').

Upon a successful match, if C<pe1> is non-C<NULL>,
it will be set to point to the beginning of the I<next> character of C<s1>
beyond what was matched.  Correspondingly for C<pe2> and C<s2>.

For case-insensitiveness, the "casefolding" of Unicode is used
instead of upper/lowercasing both the characters, see
L<http://www.unicode.org/unicode/reports/tr21/> (Case Mappings).

=cut */

/* A flags parameter has been added which may change, and hence isn't
 * externally documented.  Currently it is:
 *  0 for as-documented above
 *  FOLDEQ_UTF8_NOMIX_ASCII meaning that if a non-ASCII character folds to an
			    ASCII one, to not match
 *  FOLDEQ_LOCALE	    is set iff the rules from the current underlying
 *	                    locale are to be used.
 *  FOLDEQ_S1_ALREADY_FOLDED  s1 has already been folded before calling this
 *                          routine.  This allows that step to be skipped.
 *                          Currently, this requires s1 to be encoded as UTF-8
 *                          (u1 must be true), which is asserted for.
 *  FOLDEQ_S1_FOLDS_SANE    With either NOMIX_ASCII or LOCALE, no folds may
 *                          cross certain boundaries.  Hence, the caller should
 *                          let this function do the folding instead of
 *                          pre-folding.  This code contains an assertion to
 *                          that effect.  However, if the caller knows what
 *                          it's doing, it can pass this flag to indicate that,
 *                          and the assertion is skipped.
 *  FOLDEQ_S2_ALREADY_FOLDED  Similarly.
 *  FOLDEQ_S2_FOLDS_SANE
 */
I32
Perl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2, U32 flags)
{
    const U8 *p1  = (const U8*)s1; /* Point to current char */
    const U8 *p2  = (const U8*)s2;
    const U8 *g1 = NULL;       /* goal for s1 */
    const U8 *g2 = NULL;
    const U8 *e1 = NULL;       /* Don't scan s1 past this */
    U8 *f1 = NULL;             /* Point to current folded */
    const U8 *e2 = NULL;
    U8 *f2 = NULL;
    STRLEN n1 = 0, n2 = 0;              /* Number of bytes in current char */
    U8 foldbuf1[UTF8_MAXBYTES_CASE+1];
    U8 foldbuf2[UTF8_MAXBYTES_CASE+1];
    U8 flags_for_folder = FOLD_FLAGS_FULL;

    PERL_ARGS_ASSERT_FOLDEQ_UTF8_FLAGS;

    assert( ! ((flags & (FOLDEQ_UTF8_NOMIX_ASCII | FOLDEQ_LOCALE))
               && (((flags & FOLDEQ_S1_ALREADY_FOLDED)
                     && !(flags & FOLDEQ_S1_FOLDS_SANE))
                   || ((flags & FOLDEQ_S2_ALREADY_FOLDED)
                       && !(flags & FOLDEQ_S2_FOLDS_SANE)))));
    /* The algorithm is to trial the folds without regard to the flags on
     * the first line of the above assert(), and then see if the result
     * violates them.  This means that the inputs can't be pre-folded to a
     * violating result, hence the assert.  This could be changed, with the
     * addition of extra tests here for the already-folded case, which would
     * slow it down.  That cost is more than any possible gain for when these
     * flags are specified, as the flags indicate /il or /iaa matching which
     * is less common than /iu, and I (khw) also believe that real-world /il
     * and /iaa matches are most likely to involve code points 0-255, and this
     * function only under rare conditions gets called for 0-255. */

    if (flags & FOLDEQ_LOCALE) {
        if (IN_UTF8_CTYPE_LOCALE) {
            flags &= ~FOLDEQ_LOCALE;
        }
        else {
            flags_for_folder |= FOLD_FLAGS_LOCALE;
        }
    }

    if (pe1) {
        e1 = *(U8**)pe1;
    }

    if (l1) {
        g1 = (const U8*)s1 + l1;
    }

    if (pe2) {
        e2 = *(U8**)pe2;
    }

    if (l2) {
        g2 = (const U8*)s2 + l2;
    }

    /* Must have at least one goal */
    assert(g1 || g2);

    if (g1) {

        /* Will never match if goal is out-of-bounds */
        assert(! e1  || e1 >= g1);

        /* Here, there isn't an end pointer, or it is beyond the goal.  We
        * only go as far as the goal */
        e1 = g1;
    }
    else {
	assert(e1);    /* Must have an end for looking at s1 */
    }

    /* Same for goal for s2 */
    if (g2) {
        assert(! e2  || e2 >= g2);
        e2 = g2;
    }
    else {
	assert(e2);
    }

    /* If both operands are already folded, we could just do a memEQ on the
     * whole strings at once, but it would be better if the caller realized
     * this and didn't even call us */

    /* Look through both strings, a character at a time */
    while (p1 < e1 && p2 < e2) {

        /* If at the beginning of a new character in s1, get its fold to use
	 * and the length of the fold. */
        if (n1 == 0) {
	    if (flags & FOLDEQ_S1_ALREADY_FOLDED) {
		f1 = (U8 *) p1;
                assert(u1);
		n1 = UTF8SKIP(f1);
	    }
	    else {
                if (isASCII(*p1) && ! (flags & FOLDEQ_LOCALE)) {

                    /* We have to forbid mixing ASCII with non-ASCII if the
                     * flags so indicate.  And, we can short circuit having to
                     * call the general functions for this common ASCII case,
                     * all of whose non-locale folds are also ASCII, and hence
                     * UTF-8 invariants, so the UTF8ness of the strings is not
                     * relevant. */
                    if ((flags & FOLDEQ_UTF8_NOMIX_ASCII) && ! isASCII(*p2)) {
                        return 0;
                    }
                    n1 = 1;
                    *foldbuf1 = toFOLD(*p1);
                }
                else if (u1) {
                    _to_utf8_fold_flags(p1, foldbuf1, &n1, flags_for_folder);
                }
                else {  /* Not UTF-8, get UTF-8 fold */
                    _to_uni_fold_flags(*p1, foldbuf1, &n1, flags_for_folder);
                }
                f1 = foldbuf1;
            }
        }

        if (n2 == 0) {    /* Same for s2 */
	    if (flags & FOLDEQ_S2_ALREADY_FOLDED) {
		f2 = (U8 *) p2;
                assert(u2);
		n2 = UTF8SKIP(f2);
	    }
	    else {
                if (isASCII(*p2) && ! (flags & FOLDEQ_LOCALE)) {
                    if ((flags & FOLDEQ_UTF8_NOMIX_ASCII) && ! isASCII(*p1)) {
                        return 0;
                    }
                    n2 = 1;
                    *foldbuf2 = toFOLD(*p2);
                }
                else if (u2) {
                    _to_utf8_fold_flags(p2, foldbuf2, &n2, flags_for_folder);
                }
                else {
                    _to_uni_fold_flags(*p2, foldbuf2, &n2, flags_for_folder);
                }
                f2 = foldbuf2;
	    }
        }

	/* Here f1 and f2 point to the beginning of the strings to compare.
	 * These strings are the folds of the next character from each input
	 * string, stored in UTF-8. */

        /* While there is more to look for in both folds, see if they
        * continue to match */
        while (n1 && n2) {
            U8 fold_length = UTF8SKIP(f1);
            if (fold_length != UTF8SKIP(f2)
                || (fold_length == 1 && *f1 != *f2) /* Short circuit memNE
                                                       function call for single
                                                       byte */
                || memNE((char*)f1, (char*)f2, fold_length))
            {
                return 0; /* mismatch */
            }

            /* Here, they matched, advance past them */
            n1 -= fold_length;
            f1 += fold_length;
            n2 -= fold_length;
            f2 += fold_length;
        }

        /* When reach the end of any fold, advance the input past it */
        if (n1 == 0) {
            p1 += u1 ? UTF8SKIP(p1) : 1;
        }
        if (n2 == 0) {
            p2 += u2 ? UTF8SKIP(p2) : 1;
        }
    } /* End of loop through both strings */

    /* A match is defined by each scan that specified an explicit length
    * reaching its final goal, and the other not having matched a partial
    * character (which can happen when the fold of a character is more than one
    * character). */
    if (! ((g1 == 0 || p1 == g1) && (g2 == 0 || p2 == g2)) || n1 || n2) {
        return 0;
    }

    /* Successful match.  Set output pointers */
    if (pe1) {
        *pe1 = (char*)p1;
    }
    if (pe2) {
        *pe2 = (char*)p2;
    }
    return 1;
}

/* XXX The next two functions should likely be moved to mathoms.c once all
 * occurrences of them are removed from the core; some cpan-upstream modules
 * still use them */

U8 *
Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv)
{
    PERL_ARGS_ASSERT_UVUNI_TO_UTF8;

    return Perl_uvoffuni_to_utf8_flags(aTHX_ d, uv, 0);
}

/*
=for apidoc utf8n_to_uvuni

Instead use L</utf8_to_uvchr_buf>, or rarely, L</utf8n_to_uvchr>.

This function was useful for code that wanted to handle both EBCDIC and
ASCII platforms with Unicode properties, but starting in Perl v5.20, the
distinctions between the platforms have mostly been made invisible to most
code, so this function is quite unlikely to be what you want.  If you do need
this precise functionality, use instead
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|/utf8_to_uvchr_buf>>
or C<L<NATIVE_TO_UNI(utf8n_to_uvchr(...))|/utf8n_to_uvchr>>.

=cut
*/

UV
Perl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
{
    PERL_ARGS_ASSERT_UTF8N_TO_UVUNI;

    return NATIVE_TO_UNI(utf8n_to_uvchr(s, curlen, retlen, flags));
}

/*
=for apidoc uvuni_to_utf8_flags

Instead you almost certainly want to use L</uvchr_to_utf8> or
L</uvchr_to_utf8_flags>.

This function is a deprecated synonym for L</uvoffuni_to_utf8_flags>,
which itself, while not deprecated, should be used only in isolated
circumstances.  These functions were useful for code that wanted to handle
both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl
v5.20, the distinctions between the platforms have mostly been made invisible
to most code, so this function is quite unlikely to be what you want.

=cut
*/

U8 *
Perl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
{
    PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS;

    return uvoffuni_to_utf8_flags(d, uv, flags);
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.1
log
@Initial revision
@
text
@d3 2
a4 1
 *    Copyright (c) 1998-2000, Larry Wall
d12 5
a16 3
 * 'What a fix!' said Sam. 'That's the one place in all the lands we've ever
 * heard of that we don't want to see any closer; and that's the one place
 * we're trying to get to!  And that's just where we can't get, nohow.'
d20 4
a23 1
 * as is the custom in the West, if you wish to be answered?'
d27 2
d34 6
d41 1
a41 1
/* Unicode support */
d43 13
a55 74
U8 *
Perl_uv_to_utf8(pTHX_ U8 *d, UV uv)
{
    if (uv < 0x80) {
	*d++ = uv;
	return d;
    }
    if (uv < 0x800) {
	*d++ = (( uv >>  6)         | 0xc0);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
    if (uv < 0x10000) {
	*d++ = (( uv >> 12)         | 0xe0);
	*d++ = (((uv >>  6) & 0x3f) | 0x80);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
    if (uv < 0x200000) {
	*d++ = (( uv >> 18)         | 0xf0);
	*d++ = (((uv >> 12) & 0x3f) | 0x80);
	*d++ = (((uv >>  6) & 0x3f) | 0x80);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
    if (uv < 0x4000000) {
	*d++ = (( uv >> 24)         | 0xf8);
	*d++ = (((uv >> 18) & 0x3f) | 0x80);
	*d++ = (((uv >> 12) & 0x3f) | 0x80);
	*d++ = (((uv >>  6) & 0x3f) | 0x80);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
    if (uv < 0x80000000) {
	*d++ = (( uv >> 30)         | 0xfc);
	*d++ = (((uv >> 24) & 0x3f) | 0x80);
	*d++ = (((uv >> 18) & 0x3f) | 0x80);
	*d++ = (((uv >> 12) & 0x3f) | 0x80);
	*d++ = (((uv >>  6) & 0x3f) | 0x80);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
#ifdef HAS_QUAD
    if (uv < 0x1000000000LL)
#endif
    {
	*d++ =                        0xfe;	/* Can't match U+FEFF! */
	*d++ = (((uv >> 30) & 0x3f) | 0x80);
	*d++ = (((uv >> 24) & 0x3f) | 0x80);
	*d++ = (((uv >> 18) & 0x3f) | 0x80);
	*d++ = (((uv >> 12) & 0x3f) | 0x80);
	*d++ = (((uv >>  6) & 0x3f) | 0x80);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
#ifdef HAS_QUAD
    {
	*d++ =                        0xff;	/* Can't match U+FFFE! */
	*d++ =                        0x80;	/* 6 Reserved bits */
	*d++ = (((uv >> 60) & 0x0f) | 0x80);	/* 2 Reserved bits */
	*d++ = (((uv >> 54) & 0x3f) | 0x80);
	*d++ = (((uv >> 48) & 0x3f) | 0x80);
	*d++ = (((uv >> 42) & 0x3f) | 0x80);
	*d++ = (((uv >> 36) & 0x3f) | 0x80);
	*d++ = (((uv >> 30) & 0x3f) | 0x80);
	*d++ = (((uv >> 24) & 0x3f) | 0x80);
	*d++ = (((uv >> 18) & 0x3f) | 0x80);
	*d++ = (((uv >> 12) & 0x3f) | 0x80);
	*d++ = (((uv >>  6) & 0x3f) | 0x80);
	*d++ = (( uv        & 0x3f) | 0x80);
	return d;
    }
#endif
}
d57 7
a63 8
/* Tests if some arbitrary number of bytes begins in a valid UTF-8 character.
 * The actual number of bytes in the UTF-8 character will be returned if it
 * is valid, otherwise 0. */
int
Perl_is_utf8_char(pTHX_ U8 *s)
{
    U8 u = *s;
    int slen, len;
d65 3
a67 2
    if (!(u & 0x80))
	return 1;
d69 1
a69 2
    if (!(u & 0x40))
	return 0;
d71 2
a72 17
    if      (!(u & 0x20))	{ len = 2; }
    else if (!(u & 0x10))	{ len = 3; }
    else if (!(u & 0x08))	{ len = 4; }
    else if (!(u & 0x04))	{ len = 5; }
    else if (!(u & 0x02))	{ len = 6; }
    else if (!(u & 0x01))	{ len = 7; }
    else 			{ len = 13; } /* whoa! */

    slen = len - 1;
    s++;
    while (slen--) {
	if ((*s & 0xc0) != 0x80)
	    return 0;
	s++;
    }
    return len;
}
d74 2
a75 2
UV
Perl_utf8_to_uv(pTHX_ U8* s, I32* retlen)
d77 8
a84 14
    UV uv = *s;
    int len;
    if (!(uv & 0x80)) {
	if (retlen)
	    *retlen = 1;
	return *s;
    }
    if (!(uv & 0x40)) {
        dTHR;
	if (ckWARN_d(WARN_UTF8))     
	    Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-8 character");
	if (retlen)
	    *retlen = 1;
	return *s;
d87 1
a87 25
    if      (!(uv & 0x20))	{ len = 2; uv &= 0x1f; }
    else if (!(uv & 0x10))	{ len = 3; uv &= 0x0f; }
    else if (!(uv & 0x08))	{ len = 4; uv &= 0x07; }
    else if (!(uv & 0x04))	{ len = 5; uv &= 0x03; }
    else if (!(uv & 0x02))	{ len = 6; uv &= 0x01; }
    else if (!(uv & 0x01))	{ len = 7;  uv = 0; }
    else 			{ len = 13; uv = 0; } /* whoa! */

    if (retlen)
	*retlen = len;
    --len;
    s++;
    while (len--) {
	if ((*s & 0xc0) != 0x80) {
            dTHR;
	    if (ckWARN_d(WARN_UTF8))     
	        Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-8 character");
	    if (retlen)
		*retlen -= len + 1;
	    return 0xfffd;
	}
	else
	    uv = (uv << 6) | (*s++ & 0x3f);
    }
    return uv;
d90 44
a133 1
/* utf8_distance(a,b) is intended to be a - b in pointer arithmetic */
d135 2
a136 2
I32
Perl_utf8_distance(pTHX_ U8 *a, U8 *b)
d138 5
a142 6
    I32 off = 0;
    if (a < b) {
	while (a < b) {
	    a += UTF8SKIP(a);
	    off--;
	}
d144 5
a148 5
    else {
	while (b < a) {
	    b += UTF8SKIP(b);
	    off++;
	}
a149 2
    return off;
}
d151 28
a178 1
/* WARNING: do not use the following unless you *know* off is within bounds */
d180 32
a211 6
U8 *
Perl_utf8_hop(pTHX_ U8 *s, I32 off)
{
    if (off >= 0) {
	while (off--)
	    s += UTF8SKIP(s);
d213 2
a214 8
    else {
	while (off++) {
	    s--;
	    if (*s & 0x80) {
		while ((*s & 0xc0) == 0x80)
		    s--;
	    }
	}
a215 2
    return s;
}
d217 22
a238 6
/* XXX NOTHING CALLS THE FOLLOWING TWO ROUTINES YET!!! */
/*
 * Convert native or reversed UTF-16 to UTF-8.
 *
 * Destination must be pre-extended to 3/2 source.  Do not use in-place.
 * We optimize for native, for obvious reasons. */
d240 1
a240 39
U8*
Perl_utf16_to_utf8(pTHX_ U16* p, U8* d, I32 bytelen)
{
    U16* pend = p + bytelen / 2;
    while (p < pend) {
	UV uv = *p++;
	if (uv < 0x80) {
	    *d++ = uv;
	    continue;
	}
	if (uv < 0x800) {
	    *d++ = (( uv >>  6)         | 0xc0);
	    *d++ = (( uv        & 0x3f) | 0x80);
	    continue;
	}
	if (uv >= 0xd800 && uv < 0xdbff) {	/* surrogates */
            dTHR;
	    int low = *p++;
	    if (low < 0xdc00 || low >= 0xdfff) {
		if (ckWARN_d(WARN_UTF8))     
	    	    Perl_warner(aTHX_ WARN_UTF8, "Malformed UTF-16 surrogate");
		p--;
		uv = 0xfffd;
	    }
	    uv = ((uv - 0xd800) << 10) + (low - 0xdc00) + 0x10000;
	}
	if (uv < 0x10000) {
	    *d++ = (( uv >> 12)         | 0xe0);
	    *d++ = (((uv >>  6) & 0x3f) | 0x80);
	    *d++ = (( uv        & 0x3f) | 0x80);
	    continue;
	}
	else {
	    *d++ = (( uv >> 18)         | 0xf0);
	    *d++ = (((uv >> 12) & 0x3f) | 0x80);
	    *d++ = (((uv >>  6) & 0x3f) | 0x80);
	    *d++ = (( uv        & 0x3f) | 0x80);
	    continue;
	}
a241 2
    return d;
}
d243 6
a248 1
/* Note: this one is slightly destructive of the source. */
d250 9
a258 10
U8*
Perl_utf16_to_utf8_reversed(pTHX_ U16* p, U8* d, I32 bytelen)
{
    U8* s = (U8*)p;
    U8* send = s + bytelen;
    while (s < send) {
	U8 tmp = s[0];
	s[0] = s[1];
	s[1] = tmp;
	s += 2;
a259 1
    return utf16_to_utf8(p, d, bytelen);
d262 2
a263 1
/* for now these are all defined (inefficiently) in terms of the utf8 versions */
d265 4
a268 7
bool
Perl_is_uni_alnum(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_alnum(tmpbuf);
}
d270 1
a270 7
bool
Perl_is_uni_alnumc(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_alnumc(tmpbuf);
}
d272 1
a272 7
bool
Perl_is_uni_idfirst(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_idfirst(tmpbuf);
}
d274 1
a274 7
bool
Perl_is_uni_alpha(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_alpha(tmpbuf);
}
d276 3
a278 7
bool
Perl_is_uni_ascii(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_ascii(tmpbuf);
}
d280 2
a281 7
bool
Perl_is_uni_space(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_space(tmpbuf);
}
d283 2
a284 7
bool
Perl_is_uni_digit(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_digit(tmpbuf);
}
d286 2
a287 7
bool
Perl_is_uni_upper(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_upper(tmpbuf);
}
d289 2
a290 2
bool
Perl_is_uni_lower(pTHX_ U32 c)
d292 1
a292 3
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_lower(tmpbuf);
d295 2
a296 7
bool
Perl_is_uni_cntrl(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_cntrl(tmpbuf);
}
d298 63
a360 7
bool
Perl_is_uni_graph(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_graph(tmpbuf);
}
d362 2
a363 7
bool
Perl_is_uni_print(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_print(tmpbuf);
}
d365 2
a366 7
bool
Perl_is_uni_punct(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_punct(tmpbuf);
}
d368 2
a369 2
bool
Perl_is_uni_xdigit(pTHX_ U32 c)
d371 1
a371 3
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return is_utf8_xdigit(tmpbuf);
d374 2
a375 7
U32
Perl_to_uni_upper(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return to_utf8_upper(tmpbuf);
}
d377 5
a381 7
U32
Perl_to_uni_title(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return to_utf8_title(tmpbuf);
}
d383 1
a383 7
U32
Perl_to_uni_lower(pTHX_ U32 c)
{
    U8 tmpbuf[UTF8_MAXLEN];
    uv_to_utf8(tmpbuf, (UV)c);
    return to_utf8_lower(tmpbuf);
}
d385 2
a386 1
/* for now these all assume no locale info available for Unicode > 255 */
d389 1
a389 1
Perl_is_uni_alnum_lc(pTHX_ U32 c)
d391 4
a394 2
    return is_uni_alnum(c);	/* XXX no locale support yet */
}
d396 7
a402 5
bool
Perl_is_uni_alnumc_lc(pTHX_ U32 c)
{
    return is_uni_alnumc(c);	/* XXX no locale support yet */
}
d404 1
a404 4
bool
Perl_is_uni_idfirst_lc(pTHX_ U32 c)
{
    return is_uni_idfirst(c);	/* XXX no locale support yet */
d407 2
a408 5
bool
Perl_is_uni_alpha_lc(pTHX_ U32 c)
{
    return is_uni_alpha(c);	/* XXX no locale support yet */
}
d410 1
a410 5
bool
Perl_is_uni_ascii_lc(pTHX_ U32 c)
{
    return is_uni_ascii(c);	/* XXX no locale support yet */
}
d412 3
a414 5
bool
Perl_is_uni_space_lc(pTHX_ U32 c)
{
    return is_uni_space(c);	/* XXX no locale support yet */
}
d416 1
a416 5
bool
Perl_is_uni_digit_lc(pTHX_ U32 c)
{
    return is_uni_digit(c);	/* XXX no locale support yet */
}
d418 1
a418 5
bool
Perl_is_uni_upper_lc(pTHX_ U32 c)
{
    return is_uni_upper(c);	/* XXX no locale support yet */
}
d420 4
a423 5
bool
Perl_is_uni_lower_lc(pTHX_ U32 c)
{
    return is_uni_lower(c);	/* XXX no locale support yet */
}
d425 1
a425 5
bool
Perl_is_uni_cntrl_lc(pTHX_ U32 c)
{
    return is_uni_cntrl(c);	/* XXX no locale support yet */
}
d427 2
a428 5
bool
Perl_is_uni_graph_lc(pTHX_ U32 c)
{
    return is_uni_graph(c);	/* XXX no locale support yet */
}
d431 1
a431 1
Perl_is_uni_print_lc(pTHX_ U32 c)
d433 3
a435 2
    return is_uni_print(c);	/* XXX no locale support yet */
}
d437 1
a437 5
bool
Perl_is_uni_punct_lc(pTHX_ U32 c)
{
    return is_uni_punct(c);	/* XXX no locale support yet */
}
d439 8
a446 5
bool
Perl_is_uni_xdigit_lc(pTHX_ U32 c)
{
    return is_uni_xdigit(c);	/* XXX no locale support yet */
}
d448 7
a454 4
U32
Perl_to_uni_upper_lc(pTHX_ U32 c)
{
    return to_uni_upper(c);	/* XXX no locale support yet */
d457 1
a457 5
U32
Perl_to_uni_title_lc(pTHX_ U32 c)
{
    return to_uni_title(c);	/* XXX no locale support yet */
}
d459 1
a459 5
U32
Perl_to_uni_lower_lc(pTHX_ U32 c)
{
    return to_uni_lower(c);	/* XXX no locale support yet */
}
d461 2
a462 16
bool
Perl_is_utf8_alnum(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_alnum)
	PL_utf8_alnum = swash_init("utf8", "IsAlnum", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_alnum, p);
/*    return *p == '_' || is_utf8_alpha(p) || is_utf8_digit(p); */
#ifdef SURPRISINGLY_SLOWER  /* probably because alpha is usually true */
    if (!PL_utf8_alnum)
	PL_utf8_alnum = swash_init("utf8", "",
	    sv_2mortal(newSVpv("+utf8::IsAlpha\n+utf8::IsDigit\n005F\n",0)), 0, 0);
    return swash_fetch(PL_utf8_alnum, p);
#endif
}
d464 84
a547 16
bool
Perl_is_utf8_alnumc(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_alnum)
	PL_utf8_alnum = swash_init("utf8", "IsAlnumC", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_alnum, p);
/*    return is_utf8_alpha(p) || is_utf8_digit(p); */
#ifdef SURPRISINGLY_SLOWER  /* probably because alpha is usually true */
    if (!PL_utf8_alnum)
	PL_utf8_alnum = swash_init("utf8", "",
	    sv_2mortal(newSVpv("+utf8::IsAlpha\n+utf8::IsDigit\n005F\n",0)), 0, 0);
    return swash_fetch(PL_utf8_alnum, p);
#endif
}
d549 2
a550 5
bool
Perl_is_utf8_idfirst(pTHX_ U8 *p)
{
    return *p == '_' || is_utf8_alpha(p);
}
d552 2
a553 2
bool
Perl_is_utf8_alpha(pTHX_ U8 *p)
d555 42
a596 6
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_alpha)
	PL_utf8_alpha = swash_init("utf8", "IsAlpha", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_alpha, p);
}
d598 8
a605 9
bool
Perl_is_utf8_ascii(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_ascii)
	PL_utf8_ascii = swash_init("utf8", "IsAscii", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_ascii, p);
}
d607 1
a607 9
bool
Perl_is_utf8_space(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_space)
	PL_utf8_space = swash_init("utf8", "IsSpace", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_space, p);
}
d609 7
a615 9
bool
Perl_is_utf8_digit(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_digit)
	PL_utf8_digit = swash_init("utf8", "IsDigit", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_digit, p);
}
d617 4
a620 9
bool
Perl_is_utf8_upper(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_upper)
	PL_utf8_upper = swash_init("utf8", "IsUpper", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_upper, p);
}
d622 8
a629 9
bool
Perl_is_utf8_lower(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_lower)
	PL_utf8_lower = swash_init("utf8", "IsLower", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_lower, p);
}
d631 6
a636 9
bool
Perl_is_utf8_cntrl(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_cntrl)
	PL_utf8_cntrl = swash_init("utf8", "IsCntrl", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_cntrl, p);
}
d638 2
a639 9
bool
Perl_is_utf8_graph(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_graph)
	PL_utf8_graph = swash_init("utf8", "IsGraph", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_graph, p);
}
d641 3
a643 9
bool
Perl_is_utf8_print(pTHX_ U8 *p)
{
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_print)
	PL_utf8_print = swash_init("utf8", "IsPrint", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_print, p);
}
d645 314
a958 2
bool
Perl_is_utf8_punct(pTHX_ U8 *p)
d960 4
a963 5
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_punct)
	PL_utf8_punct = swash_init("utf8", "IsPunct", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_punct, p);
d966 6
a971 2
bool
Perl_is_utf8_xdigit(pTHX_ U8 *p)
d973 33
a1005 5
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_xdigit)
	PL_utf8_xdigit = swash_init("utf8", "IsXDigit", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_xdigit, p);
d1008 28
a1035 2
bool
Perl_is_utf8_mark(pTHX_ U8 *p)
d1037 7
a1043 5
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_mark)
	PL_utf8_mark = swash_init("utf8", "IsM", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_mark, p);
d1046 12
a1057 2
UV
Perl_to_utf8_upper(pTHX_ U8 *p)
d1059 24
a1082 1
    UV uv;
d1084 1
a1084 4
    if (!PL_utf8_toupper)
	PL_utf8_toupper = swash_init("utf8", "ToUpper", &PL_sv_undef, 4, 0);
    uv = swash_fetch(PL_utf8_toupper, p);
    return uv ? uv : utf8_to_uv(p,0);
d1087 14
a1100 2
UV
Perl_to_utf8_title(pTHX_ U8 *p)
d1102 1
a1102 1
    UV uv;
d1104 1
a1104 4
    if (!PL_utf8_totitle)
	PL_utf8_totitle = swash_init("utf8", "ToTitle", &PL_sv_undef, 4, 0);
    uv = swash_fetch(PL_utf8_totitle, p);
    return uv ? uv : utf8_to_uv(p,0);
d1107 15
a1121 2
UV
Perl_to_utf8_lower(pTHX_ U8 *p)
d1123 1
a1123 1
    UV uv;
d1125 16
a1140 4
    if (!PL_utf8_tolower)
	PL_utf8_tolower = swash_init("utf8", "ToLower", &PL_sv_undef, 4, 0);
    uv = swash_fetch(PL_utf8_tolower, p);
    return uv ? uv : utf8_to_uv(p,0);
d1143 13
a1155 1
/* a "swash" is a swatch hash */
d1157 5
a1161 2
SV*
Perl_swash_init(pTHX_ char* pkg, char* name, SV *listsv, I32 minbits, I32 none)
d1163 4
a1166 3
    SV* retval;
    char tmpbuf[256];
    dSP;    
d1168 35
a1202 4
    if (!gv_stashpv(pkg, 0)) {	/* demand load utf8 */
	ENTER;
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, newSVpv(pkg,0), Nullsv);
	LEAVE;
d1204 5
a1208 29
    SPAGAIN;
    PUSHSTACKi(PERLSI_MAGIC);
    PUSHMARK(SP);
    EXTEND(SP,5);
    PUSHs(sv_2mortal(newSVpvn(pkg, strlen(pkg))));
    PUSHs(sv_2mortal(newSVpvn(name, strlen(name))));
    PUSHs(listsv);
    PUSHs(sv_2mortal(newSViv(minbits)));
    PUSHs(sv_2mortal(newSViv(none)));
    PUTBACK;
    ENTER;
    SAVEI32(PL_hints);
    PL_hints = 0;
    save_re_context();
    if (PL_curcop == &PL_compiling)	/* XXX ought to be handled by lex_start */
	strncpy(tmpbuf, PL_tokenbuf, sizeof tmpbuf);
    if (call_method("SWASHNEW", G_SCALAR))
	retval = newSVsv(*PL_stack_sp--);    
    else
	retval = &PL_sv_undef;
    LEAVE;
    POPSTACK;
    if (PL_curcop == &PL_compiling) {
	strncpy(PL_tokenbuf, tmpbuf, sizeof tmpbuf);
	PL_curcop->op_private = PL_hints;
    }
    if (!SvROK(retval) || SvTYPE(SvRV(retval)) != SVt_PVHV)
	Perl_croak(aTHX_ "SWASHNEW didn't return an HV ref");
    return retval;
d1211 22
a1232 11
UV
Perl_swash_fetch(pTHX_ SV *sv, U8 *ptr)
{
    HV* hv = (HV*)SvRV(sv);
    U32 klen = UTF8SKIP(ptr) - 1;
    U32 off = ptr[klen] & 127;  /* NB: 64 bit always 0 when len > 1 */
    STRLEN slen;
    STRLEN needents = (klen ? 64 : 128);
    U8 *tmps;
    U32 bit;
    SV *retval;
d1234 11
a1244 8
    /*
     * This single-entry cache saves about 1/3 of the utf8 overhead in test
     * suite.  (That is, only 7-8% overall over just a hash cache.  Still,
     * it's nothing to sniff at.)  Pity we usually come through at least
     * two function calls to get here...
     *
     * NB: this code assumes that swatches are never modified, once generated!
     */
d1246 9
a1254 6
    if (hv == PL_last_swash_hv &&
	klen == PL_last_swash_klen &&
	(!klen || memEQ(ptr,PL_last_swash_key,klen)) )
    {
	tmps = PL_last_swash_tmps;
	slen = PL_last_swash_slen;
d1256 18
a1273 3
    else {
	/* Try our second-level swatch cache, kept in a hash. */
	SV** svp = hv_fetch(hv, (char*)ptr, klen, FALSE);
d1275 24
a1298 22
	/* If not cached, generate it via utf8::SWASHGET */
	if (!svp || !SvPOK(*svp) || !(tmps = (U8*)SvPV(*svp, slen))) {
	    dSP;
	    ENTER;
	    SAVETMPS;
	    save_re_context();
	    PUSHSTACKi(PERLSI_MAGIC);
	    PUSHMARK(SP);
	    EXTEND(SP,3);
	    PUSHs((SV*)sv);
	    PUSHs(sv_2mortal(newSViv(utf8_to_uv(ptr, 0) & ~(needents - 1))));
	    PUSHs(sv_2mortal(newSViv(needents)));
	    PUTBACK;
	    if (call_method("SWASHGET", G_SCALAR))
		retval = newSVsv(*PL_stack_sp--);    
	    else
		retval = &PL_sv_undef;
	    POPSTACK;
	    FREETMPS;
	    LEAVE;
	    if (PL_curcop == &PL_compiling)
		PL_curcop->op_private = PL_hints;
d1300 1
a1300 1
	    svp = hv_store(hv, (char*)ptr, klen, retval, 0);
d1302 8
a1309 2
	    if (!svp || !(tmps = (U8*)SvPV(*svp, slen)) || slen < 8)
		Perl_croak(aTHX_ "SWASHGET didn't return result of proper length");
d1311 26
d1338 95
a1432 6
	PL_last_swash_hv = hv;
	PL_last_swash_klen = klen;
	PL_last_swash_tmps = tmps;
	PL_last_swash_slen = slen;
	if (klen)
	    Copy(ptr, PL_last_swash_key, klen, U8);
d1434 17
d1452 5
a1456 13
    switch ((slen << 3) / needents) {
    case 1:
	bit = 1 << (off & 7);
	off >>= 3;
	return (tmps[off] & bit) != 0;
    case 8:
	return tmps[off];
    case 16:
	off <<= 1;
	return (tmps[off] << 8) + tmps[off + 1] ;
    case 32:
	off <<= 2;
	return (tmps[off] << 24) + (tmps[off+1] << 16) + (tmps[off+2] << 8) + tmps[off + 3] ;
d1458 9
a1466 2
    Perl_croak(aTHX_ "panic: swash_fetch");
    return 0;
d1468 3074
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1998-2001, Larry Wall
a28 17
/*
=for apidoc A|U8*|uv_to_utf8|U8 *d|UV uv

Adds the UTF8 representation of the Unicode codepoint C<uv> to the end
of the string C<d>; C<d> should be have at least C<UTF8_MAXLEN+1> free
bytes available. The return value is the pointer to the byte after the
end of the new character. In other words, 

    d = uv_to_utf8(d, uv);

is the recommended Unicode-aware way of saying

    *(d++) = uv;

=cut
*/

d72 1
a72 1
    if (uv < UTF8_QUAD_MAX)
d104 4
a107 10
/*
=for apidoc A|STRLEN|is_utf8_char|U8 *s

Tests if some arbitrary number of bytes begins in a valid UTF-8 character.
The actual number of bytes in the UTF-8 character will be returned if it
is valid, otherwise 0. 
 
=cut
*/
STRLEN
d111 1
a111 2
    STRLEN slen, len;
    UV uv, ouv;
d113 1
a113 1
    if (UTF8_IS_ASCII(u))
d116 1
a116 1
    if (!UTF8_IS_START(u))
d119 7
a125 4
    len = UTF8SKIP(s);

    if (len < 2 || !UTF8_IS_CONTINUATION(s[1]))
	return 0;
a128 2
    uv = u;
    ouv = uv;
d130 1
a130 4
	if (!UTF8_IS_CONTINUATION(*s))
	    return 0;
	uv = UTF8_ACCUMULATE(uv, *s);
	if (uv < ouv)
a131 1
	ouv = uv;
a133 4

    if (UNISKIP(uv) < len)
	return 0;

a136 52
/*
=for apidoc A|bool|is_utf8_string|U8 *s|STRLEN len

Returns true if first C<len> bytes of the given string form valid a UTF8
string, false otherwise.

=cut
*/

bool
Perl_is_utf8_string(pTHX_ U8 *s, STRLEN len)
{
    U8* x = s;
    U8* send;
    STRLEN c;

    if (!len)
	len = strlen((char *)s);
    send = s + len;

    while (x < send) {
        c = is_utf8_char(x);
	if (!c)
	    return FALSE;
        x += c;
    }
    if (x != send)
	return FALSE;

    return TRUE;
}

/*
=for apidoc A|U8* s|utf8_to_uv|STRLEN curlen|STRLEN *retlen|U32 flags

Returns the character value of the first character in the string C<s>
which is assumed to be in UTF8 encoding and no longer than C<curlen>;
C<retlen> will be set to the length, in bytes, of that character.

If C<s> does not point to a well-formed UTF8 character, the behaviour
is dependent on the value of C<flags>: if it contains UTF8_CHECK_ONLY,
it is assumed that the caller will raise a warning, and this function
will silently just set C<retlen> to C<-1> and return zero.  If the
C<flags> does not contain UTF8_CHECK_ONLY, warnings about
malformations will be given, C<retlen> will be set to the expected
length of the UTF-8 character in bytes, and zero will be returned.

The C<flags> can also contain various flags to allow deviations from
the strict UTF-8 encoding (see F<utf8.h>).

=cut */

d138 1
a138 1
Perl_utf8_to_uv(pTHX_ U8* s, STRLEN curlen, STRLEN* retlen, U32 flags)
d140 6
a145 27
    UV uv = *s, ouv;
    STRLEN len = 1;
#ifdef EBCDIC
    bool dowarn = 0;
#else
    bool dowarn = ckWARN_d(WARN_UTF8);
#endif
    STRLEN expectlen = 0;
    U32 warning = 0;

/* This list is a superset of the UTF8_ALLOW_XXX. */

#define UTF8_WARN_EMPTY				 1
#define UTF8_WARN_CONTINUATION			 2
#define UTF8_WARN_NON_CONTINUATION	 	 3
#define UTF8_WARN_FE_FF				 4
#define UTF8_WARN_SHORT				 5
#define UTF8_WARN_OVERFLOW			 6
#define UTF8_WARN_SURROGATE			 7
#define UTF8_WARN_BOM				 8
#define UTF8_WARN_LONG				 9
#define UTF8_WARN_FFFF				10

    if (curlen == 0 &&
	!(flags & UTF8_ALLOW_EMPTY)) {
	warning = UTF8_WARN_EMPTY;
	goto malformed;
d147 4
a150 2

    if (UTF8_IS_ASCII(uv)) {
d156 6
a161 24
    if (UTF8_IS_CONTINUATION(uv) &&
	!(flags & UTF8_ALLOW_CONTINUATION)) {
	warning = UTF8_WARN_CONTINUATION;
	goto malformed;
    }

    if (UTF8_IS_START(uv) && curlen > 1 && !UTF8_IS_CONTINUATION(s[1]) &&
	!(flags & UTF8_ALLOW_NON_CONTINUATION)) {
	warning = UTF8_WARN_NON_CONTINUATION;
	goto malformed;
    }
    
    if ((uv == 0xfe || uv == 0xff) &&
	!(flags & UTF8_ALLOW_FE_FF)) {
	warning = UTF8_WARN_FE_FF;
	goto malformed;
    }
	
    if      (!(uv & 0x20))	{ len =  2; uv &= 0x1f; }
    else if (!(uv & 0x10))	{ len =  3; uv &= 0x0f; }
    else if (!(uv & 0x08))	{ len =  4; uv &= 0x07; }
    else if (!(uv & 0x04))	{ len =  5; uv &= 0x03; }
    else if (!(uv & 0x02))	{ len =  6; uv &= 0x01; }
    else if (!(uv & 0x01))	{ len =  7; uv = 0; }
d163 1
a163 1
	
d166 1
a166 10
    
    expectlen = len;

    if ((curlen < expectlen) &&
	!(flags & UTF8_ALLOW_SHORT)) {
	warning = UTF8_WARN_SHORT;
	goto malformed;
    }

    len--;
a167 2
    ouv = uv;

d169 7
a175 5
	if (!UTF8_IS_CONTINUATION(*s) &&
	    !(flags & UTF8_ALLOW_NON_CONTINUATION)) {
	    s--;
	    warning = UTF8_WARN_NON_CONTINUATION;
	    goto malformed;
d178 1
a178 17
	    uv = UTF8_ACCUMULATE(uv, *s);
	if (!(uv > ouv)) {
	    /* These cannot be allowed. */
	    if (uv == ouv) {
		if (!(flags & UTF8_ALLOW_LONG)) {
		    warning = UTF8_WARN_LONG;
		    goto malformed;
		}
	    }
	    else { /* uv < ouv */
		/* This cannot be allowed. */
		warning = UTF8_WARN_OVERFLOW;
		goto malformed;
	    }
	}
	s++;
	ouv = uv;
a179 19

    if (UNICODE_IS_SURROGATE(uv) &&
	!(flags & UTF8_ALLOW_SURROGATE)) {
	warning = UTF8_WARN_SURROGATE;
	goto malformed;
    } else if (UNICODE_IS_BYTE_ORDER_MARK(uv) &&
	       !(flags & UTF8_ALLOW_BOM)) {
	warning = UTF8_WARN_BOM;
	goto malformed;
    } else if ((expectlen > UNISKIP(uv)) &&
	       !(flags & UTF8_ALLOW_LONG)) {
	warning = UTF8_WARN_LONG;
	goto malformed;
    } else if (UNICODE_IS_ILLEGAL(uv) &&
	       !(flags & UTF8_ALLOW_FFFF)) {
	warning = UTF8_WARN_FFFF;
	goto malformed;
    }

a180 87

malformed:

    if (flags & UTF8_CHECK_ONLY) {
	if (retlen)
	    *retlen = -1;
	return 0;
    }

    if (dowarn) {
	SV* sv = sv_2mortal(newSVpv("Malformed UTF-8 character ", 0));

	switch (warning) {
	case 0: /* Intentionally empty. */ break;
	case UTF8_WARN_EMPTY:
	    Perl_sv_catpvf(aTHX_ sv, "(empty string)");
	    break;
	case UTF8_WARN_CONTINUATION:
	    Perl_sv_catpvf(aTHX_ sv, "(unexpected continuation byte 0x%02"UVxf")", uv);
	    break;
	case UTF8_WARN_NON_CONTINUATION:
	    Perl_sv_catpvf(aTHX_ sv, "(unexpected non-continuation byte 0x%02"UVxf" after start byte 0x%02"UVxf")",
                           (UV)s[1], uv);
	    break;
	case UTF8_WARN_FE_FF:
	    Perl_sv_catpvf(aTHX_ sv, "(byte 0x%02"UVxf")", uv);
	    break;
	case UTF8_WARN_SHORT:
	    Perl_sv_catpvf(aTHX_ sv, "(%d byte%s, need %d)",
                           curlen, curlen == 1 ? "" : "s", expectlen);
	    break;
	case UTF8_WARN_OVERFLOW:
	    Perl_sv_catpvf(aTHX_ sv, "(overflow at 0x%"UVxf", byte 0x%02x)",
                           ouv, *s);
	    break;
	case UTF8_WARN_SURROGATE:
	    Perl_sv_catpvf(aTHX_ sv, "(UTF-16 surrogate 0x%04"UVxf")", uv);
	    break;
	case UTF8_WARN_BOM:
	    Perl_sv_catpvf(aTHX_ sv, "(byte order mark 0x%04"UVxf")", uv);
	    break;
	case UTF8_WARN_LONG:
	    Perl_sv_catpvf(aTHX_ sv, "(%d byte%s, need %d)",
			   expectlen, expectlen == 1 ? "": "s", UNISKIP(uv));
	    break;
	case UTF8_WARN_FFFF:
	    Perl_sv_catpvf(aTHX_ sv, "(character 0x%04"UVxf")", uv);
	    break;
	default:
	    Perl_sv_catpvf(aTHX_ sv, "(unknown reason)");
	    break;
	}
	
	if (warning) {
	    char *s = SvPVX(sv);

	    if (PL_op)
		Perl_warner(aTHX_ WARN_UTF8,
			    "%s in %s", s,  PL_op_desc[PL_op->op_type]);
	    else
		Perl_warner(aTHX_ WARN_UTF8, "%s", s);
	}
    }

    if (retlen)
	*retlen = expectlen ? expectlen : len;

    return 0;
}

/*
=for apidoc A|U8* s|utf8_to_uv_simple|STRLEN *retlen

Returns the character value of the first character in the string C<s>
which is assumed to be in UTF8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

If C<s> does not point to a well-formed UTF8 character, zero is
returned and retlen is set, if possible, to -1.

=cut
*/

UV
Perl_utf8_to_uv_simple(pTHX_ U8* s, STRLEN* retlen)
{
    return Perl_utf8_to_uv(aTHX_ s, UTF8_MAXLEN, retlen, 0);
d183 1
a183 29
/*
=for apidoc A|STRLEN|utf8_length|U8* s|U8 *e

Return the length of the UTF-8 char encoded string C<s> in characters.
Stops at C<e> (inclusive).  If C<e E<lt> s> or if the scan would end
up past C<e>, croaks.

=cut
*/

STRLEN
Perl_utf8_length(pTHX_ U8* s, U8* e)
{
    STRLEN len = 0;

    /* Note: cannot use UTF8_IS_...() too eagerly here since e.g.
     * the bitops (especially ~) can create illegal UTF-8.
     * In other words: in Perl UTF-8 is not just for Unicode. */

    if (e < s)
	Perl_croak(aTHX_ "panic: utf8_length: unexpected end");
    while (s < e) {
	U8 t = UTF8SKIP(s);

	if (e - s < t)
	    Perl_croak(aTHX_ "panic: utf8_length: unaligned end");
	s += t;
	len++;
    }
d185 1
a185 15
    return len;
}

/*
=for apidoc A|IV|utf8_distance|U8 *a|U8 *b

Returns the number of UTF8 characters between the UTF-8 pointers C<a>
and C<b>.

WARNING: use only if you *know* that the pointers point inside the
same UTF-8 buffer.

=cut */

IV
d188 1
a188 6
    IV off = 0;

    /* Note: cannot use UTF8_IS_...() too eagerly here since  e.g.
     * the bitops (especially ~) can create illegal UTF-8.
     * In other words: in Perl UTF-8 is not just for Unicode. */

d191 1
a191 5
	    U8 c = UTF8SKIP(a);

	    if (b - a < c)
		Perl_croak(aTHX_ "panic: utf8_distance: unaligned end");
	    a += c;
d197 1
a197 5
	    U8 c = UTF8SKIP(b);

	    if (a - b < c)
		Perl_croak(aTHX_ "panic: utf8_distance: unaligned end");
	    b += c;
a200 1

d204 1
a204 11
/*
=for apidoc A|U8*|utf8_hop|U8 *s|I32 off

Return the UTF-8 pointer C<s> displaced by C<off> characters, either
forward or backward.

WARNING: do not use the following unless you *know* C<off> is within
the UTF-8 data pointed to by C<s> *and* that on entry C<s> is aligned
on the first byte of character or just after the last byte of a character.

=cut */
a208 4
    /* Note: cannot use UTF8_IS_...() too eagerly here since e.g
     * the bitops (especially ~) can create illegal UTF-8.
     * In other words: in Perl UTF-8 is not just for Unicode. */

d216 4
a219 2
	    while (UTF8_IS_CONTINUATION(*s))
		s--;
d225 1
d227 1
a227 137
=for apidoc A|U8 *|utf8_to_bytes|U8 *s|STRLEN *len

Converts a string C<s> of length C<len> from UTF8 into byte encoding.
Unlike C<bytes_to_utf8>, this over-writes the original string, and
updates len to contain the new length.
Returns zero on failure, setting C<len> to -1.

=cut
*/

U8 *
Perl_utf8_to_bytes(pTHX_ U8* s, STRLEN *len)
{
    U8 *send;
    U8 *d;
    U8 *save = s;

    /* ensure valid UTF8 and chars < 256 before updating string */
    for (send = s + *len; s < send; ) {
        U8 c = *s++;

        if (c >= 0x80 &&
            ((s >= send) ||
	     ((*s++ & 0xc0) != 0x80) || ((c & 0xfe) != 0xc2))) {
            *len = -1;
            return 0;
        }
    }

    d = s = save;
    while (s < send) {
        if (UTF8_IS_ASCII(*s)) {
	    *d++ = *s++;
	}
        else {
            STRLEN ulen;
            *d++ = (U8)utf8_to_uv_simple(s, &ulen);
            s += ulen;
        }
    }
    *d = '\0';
    *len = d - save;
    return save;
}

/*
=for apidoc A|U8 *|bytes_from_utf8|U8 *s|STRLEN *len|bool *is_utf8

Converts a string C<s> of length C<len> from UTF8 into byte encoding.
Unlike <utf8_to_bytes> but like C<bytes_to_utf8>, returns a pointer to
the newly-created string, and updates C<len> to contain the new
length.  Returns the original string if no conversion occurs, C<len>
is unchanged. Do nothing if C<is_utf8> points to 0. Sets C<is_utf8> to
0 if C<s> is converted or contains all 7bit characters.

=cut */

U8 *
Perl_bytes_from_utf8(pTHX_ U8* s, STRLEN *len, bool *is_utf8)
{
    U8 *send;
    U8 *d;
    U8 *start = s;
    I32 count = 0;

    if (!*is_utf8)
	return start;

    /* ensure valid UTF8 and chars < 256 before converting string */
    for (send = s + *len; s < send;) {
	U8 c = *s++;
        if (!UTF8_IS_ASCII(c)) {
	    if (UTF8_IS_CONTINUATION(c) || s >= send ||
		!UTF8_IS_CONTINUATION(*s) || UTF8_IS_DOWNGRADEABLE_START(c))
		return start;
	    s++, count++;
        }
    }

    *is_utf8 = 0;		

    if (!count)
	return start;

    Newz(801, d, (*len) - count + 1, U8);
    s = start; start = d;
    while (s < send) {
	U8 c = *s++;

	if (UTF8_IS_ASCII(c))
	    *d++ = c;
	else
	    *d++ = UTF8_ACCUMULATE(c, *s++);
    }
    *d = '\0';
    *len = d - start;
    return start;
}

/*
=for apidoc A|U8 *|bytes_to_utf8|U8 *s|STRLEN *len

Converts a string C<s> of length C<len> from ASCII into UTF8 encoding.
Returns a pointer to the newly-created string, and sets C<len> to
reflect the new length.

=cut
*/

U8*
Perl_bytes_to_utf8(pTHX_ U8* s, STRLEN *len)
{
    U8 *send;
    U8 *d;
    U8 *dst;
    send = s + (*len);

    Newz(801, d, (*len) * 2 + 1, U8);
    dst = d;

    while (s < send) {
        if (UTF8_IS_ASCII(*s))
            *d++ = *s++;
        else {
            UV uv = *s++;

            *d++ = UTF8_EIGHT_BIT_HI(uv);
            *d++ = UTF8_EIGHT_BIT_LO(uv);
        }
    }
    *d = '\0';
    *len = d-dst;
    return dst;
}

/*
 * Convert native (big-endian) or reversed (little-endian) UTF-16 to UTF-8.
d233 1
a233 1
Perl_utf16_to_utf8(pTHX_ U8* p, U8* d, I32 bytelen, I32 *newlen)
d235 1
a235 8
    U8* pend;
    U8* dstart = d;

    if (bytelen & 1)
	Perl_croak(aTHX_ "panic: utf16_to_utf8: odd bytelen");

    pend = p + bytelen;

d237 1
a237 2
	UV uv = (p[0] << 8) + p[1]; /* UTF-16BE */
	p += 2;
d248 8
a255 3
	    UV low = *p++;
	    if (low < 0xdc00 || low >= 0xdfff)
		Perl_croak(aTHX_ "Malformed UTF-16 surrogate");
a271 1
    *newlen = d - dstart;
d278 1
a278 1
Perl_utf16_to_utf8_reversed(pTHX_ U8* p, U8* d, I32 bytelen, I32 *newlen)
d288 1
a288 1
    return utf16_to_utf8(p, d, bytelen, newlen);
d296 1
a296 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d304 1
a304 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d312 1
a312 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d320 1
a320 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d328 1
a328 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d336 1
a336 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d344 1
a344 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d352 1
a352 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d360 1
a360 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d368 1
a368 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d376 1
a376 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d384 1
a384 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d392 1
a392 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d400 1
a400 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d408 1
a408 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d416 1
a416 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d424 1
a424 1
    U8 tmpbuf[UTF8_MAXLEN+1];
d539 1
a539 4
	/* NOTE: "IsWord", not "IsAlnum", since Alnum is a true
	 * descendant of isalnum(3), in other words, it doesn't
	 * contain the '_'. --jhi */
	PL_utf8_alnum = swash_init("utf8", "IsWord", &PL_sv_undef, 0, 0);
d599 1
a599 1
	PL_utf8_space = swash_init("utf8", "IsSpacePerl", &PL_sv_undef, 0, 0);
d701 1
a701 1
    return uv ? uv : utf8_to_uv(p,UTF8_MAXLEN,0,0);
d712 1
a712 1
    return uv ? uv : utf8_to_uv(p,UTF8_MAXLEN,0,0);
d723 1
a723 1
    return uv ? uv : utf8_to_uv(p,UTF8_MAXLEN,0,0);
d732 2
a733 2
    SV* tokenbufsv = sv_2mortal(NEWSV(0,0));
    dSP;
d754 2
a755 3
    if (PL_curcop == &PL_compiling)
	/* XXX ought to be handled by lex_start */
	sv_setpv(tokenbufsv, PL_tokenbuf);
d757 1
a757 1
	retval = newSVsv(*PL_stack_sp--);
d763 1
a763 4
	STRLEN len;
	char* pv = SvPV(tokenbufsv, len);

	Copy(pv, PL_tokenbuf, len+1, char);
d813 1
a813 1
	    PUSHs(sv_2mortal(newSViv(utf8_to_uv(ptr, UTF8_MAXLEN, 0, 0) & ~(needents - 1))));
d817 1
a817 1
		retval = newSVsv(*PL_stack_sp--);
d840 1
a840 1
    switch ((int)((slen << 3) / needents)) {
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1998-2002, Larry Wall
d27 1
a27 1
static char unees[] = "Malformed UTF-8 character (unexpected end of string)";
d29 2
a30 4
/* 
=head1 Unicode Support

=for apidoc A|U8 *|uvuni_to_utf8_flags|U8 *d|UV uv|UV flags
d35 1
a35 5
end of the new character. In other words,

    d = uvuni_to_utf8_flags(d, uv, flags);

or, in most cases,
d37 1
a37 5
    d = uvuni_to_utf8(d, uv);

(which is equivalent to)

    d = uvuni_to_utf8_flags(d, uv, 0);
d47 1
a47 1
Perl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
d49 2
a50 20
    if (ckWARN(WARN_UTF8)) {
	 if (UNICODE_IS_SURROGATE(uv) &&
	     !(flags & UNICODE_ALLOW_SURROGATE))
	      Perl_warner(aTHX_ packWARN(WARN_UTF8), "UTF-16 surrogate 0x%04"UVxf, uv);
	 else if (
		  ((uv >= 0xFDD0 && uv <= 0xFDEF &&
		    !(flags & UNICODE_ALLOW_FDD0))
		   ||
		   ((uv & 0xFFFE) == 0xFFFE && /* Either FFFE or FFFF. */
		    !(flags & UNICODE_ALLOW_FFFF))) &&
		  /* UNICODE_ALLOW_SUPER includes
		   * FFFEs and FFFFs beyond 0x10FFFF. */
		  ((uv <= PERL_UNICODE_MAX) ||
		   !(flags & UNICODE_ALLOW_SUPER))
		  )
	      Perl_warner(aTHX_ packWARN(WARN_UTF8),
			 "Unicode character 0x%04"UVxf" is illegal", uv);
    }
    if (UNI_IS_INVARIANT(uv)) {
	*d++ = (U8)UTF_TO_NATIVE(uv);
a52 12
#if defined(EBCDIC)
    else {
	STRLEN len  = UNISKIP(uv);
	U8 *p = d+len-1;
	while (p > d) {
	    *p-- = (U8)UTF_TO_NATIVE((uv & UTF_CONTINUATION_MASK) | UTF_CONTINUATION_MARK);
	    uv >>= UTF_ACCUMULATION_SHIFT;
	}
	*p = (U8)UTF_TO_NATIVE((uv & UTF_START_MASK(len)) | UTF_START_MARK(len));
	return d+len;
    }
#else /* Non loop style */
d54 2
a55 2
	*d++ = (U8)(( uv >>  6)         | 0xc0);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
d59 3
a61 3
	*d++ = (U8)(( uv >> 12)         | 0xe0);
	*d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
d65 4
a68 4
	*d++ = (U8)(( uv >> 18)         | 0xf0);
	*d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
d72 5
a76 5
	*d++ = (U8)(( uv >> 24)         | 0xf8);
	*d++ = (U8)(((uv >> 18) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
d80 6
a85 6
	*d++ = (U8)(( uv >> 30)         | 0xfc);
	*d++ = (U8)(((uv >> 24) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 18) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
d92 7
a98 7
	*d++ =                            0xfe;	/* Can't match U+FEFF! */
	*d++ = (U8)(((uv >> 30) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 24) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 18) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
d103 13
a115 13
	*d++ =                            0xff;		/* Can't match U+FFFE! */
	*d++ =                            0x80;		/* 6 Reserved bits */
	*d++ = (U8)(((uv >> 60) & 0x0f) | 0x80);	/* 2 Reserved bits */
	*d++ = (U8)(((uv >> 54) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 48) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 42) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 36) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 30) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 24) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 18) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	*d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	*d++ = (U8)(( uv        & 0x3f) | 0x80);
a118 1
#endif /* Loop style */
a119 7
 
U8 *
Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv)
{
    return Perl_uvuni_to_utf8_flags(aTHX_ d, uv, 0);
}

d124 6
a129 6
Tests if some arbitrary number of bytes begins in a valid UTF-8
character.  Note that an INVARIANT (i.e. ASCII) character is a valid
UTF-8 character.  The actual number of bytes in the UTF-8 character
will be returned if it is valid, otherwise 0.

=cut */
d137 1
a137 1
    if (UTF8_IS_INVARIANT(u))
d150 1
a150 2
    u &= UTF_START_MASK(len);
    uv  = u;
d156 1
a156 1
	if (uv < ouv) 
d162 1
a162 1
    if ((STRLEN)UNISKIP(uv) < len)
d171 2
a172 4
Returns true if first C<len> bytes of the given string form a valid UTF8
string, false otherwise.  Note that 'a valid UTF8 string' does not mean
'a string that contains UTF8' because a valid ASCII string is a valid
UTF8 string.
d189 3
a191 11
	 /* Inline the easy bits of is_utf8_char() here for speed... */
	 if (UTF8_IS_INVARIANT(*x))
	      c = 1;
	 else if (!UTF8_IS_START(*x))
	      return FALSE;
	 else {
	      /* ... and call is_utf8_char() only if really needed. */
	      c = is_utf8_char(x);
	      if (!c)
		   return FALSE;
	 }
d201 1
a201 1
=for apidoc A|UV|utf8n_to_uvuni|U8 *s|STRLEN curlen|STRLEN *retlen|U32 flags
d203 1
a203 2
Bottom level UTF-8 decode routine.
Returns the unicode code point value of the first character in the string C<s>
d218 1
a218 4
Most code should use utf8_to_uvchr() rather than call this directly.

=cut
*/
d221 1
a221 1
Perl_utf8n_to_uvuni(pTHX_ U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
d223 1
a223 2
    U8 *s0 = s;
    UV uv = *s, ouv = 0;
d225 3
d229 1
a229 1
    UV startbyte = *s;
d242 3
a244 2
#define UTF8_WARN_LONG				 8
#define UTF8_WARN_FFFF				 9 /* Also FFFE. */
d252 1
a252 1
    if (UTF8_IS_INVARIANT(uv)) {
d255 1
a255 1
	return (UV) (NATIVE_TO_UTF(*s));
d269 1
a269 4

#ifdef EBCDIC
    uv = NATIVE_TO_UTF(uv);
#else
d275 1
a275 2
#endif

a279 4
#ifdef EBCDIC
    else if (!(uv & 0x02))	{ len =  6; uv &= 0x01; }
    else			{ len =  7; uv &= 0x01; }
#else
d282 2
a283 3
    else			{ len = 13; uv = 0; } /* whoa! */
#endif

d286 1
a286 1

d330 5
a334 1
    } else if ((expectlen > (STRLEN)UNISKIP(uv)) &&
d363 1
a363 1
	    Perl_sv_catpvf(aTHX_ sv, "(unexpected continuation byte 0x%02"UVxf", with no preceding start byte)", uv);
d366 2
a367 7
	    if (s == s0)
	        Perl_sv_catpvf(aTHX_ sv, "(unexpected non-continuation byte 0x%02"UVxf", immediately after start byte 0x%02"UVxf")",
                           (UV)s[1], startbyte);
	    else
	        Perl_sv_catpvf(aTHX_ sv, "(unexpected non-continuation byte 0x%02"UVxf", %d byte%s after start byte 0x%02"UVxf", expected %d bytes)",
                           (UV)s[1], s - s0, s - s0 > 1 ? "s" : "", startbyte, expectlen);
	      
d373 2
a374 3
	    Perl_sv_catpvf(aTHX_ sv, "(%d byte%s, need %d, after start byte 0x%02"UVxf")",
                           curlen, curlen == 1 ? "" : "s", expectlen, startbyte);
	    expectlen = curlen;		/* distance for caller to skip */
d377 2
a378 2
	    Perl_sv_catpvf(aTHX_ sv, "(overflow at 0x%"UVxf", byte 0x%02x, after start byte 0x%02"UVxf")",
                           ouv, *s, startbyte);
d383 3
d387 2
a388 2
	    Perl_sv_catpvf(aTHX_ sv, "(%d byte%s, need %d, after start byte 0x%02"UVxf")",
			   expectlen, expectlen == 1 ? "": "s", UNISKIP(uv), startbyte);
d402 2
a403 2
		Perl_warner(aTHX_ packWARN(WARN_UTF8),
			    "%s in %s", s,  OP_DESC(PL_op));
d405 1
a405 1
		Perl_warner(aTHX_ packWARN(WARN_UTF8), "%s", s);
d416 1
a416 21
=for apidoc A|UV|utf8_to_uvchr|U8 *s|STRLEN *retlen

Returns the native character value of the first character in the string C<s>
which is assumed to be in UTF8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

If C<s> does not point to a well-formed UTF8 character, zero is
returned and retlen is set, if possible, to -1.

=cut
*/

UV
Perl_utf8_to_uvchr(pTHX_ U8 *s, STRLEN *retlen)
{
    return Perl_utf8n_to_uvchr(aTHX_ s, UTF8_MAXLEN, retlen,
			       ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
}

/*
=for apidoc A|UV|utf8_to_uvuni|U8 *s|STRLEN *retlen
d418 1
a418 1
Returns the Unicode code point of the first character in the string C<s>
a421 3
This function should only be used when returned UV is considered
an index into the Unicode semantic tables (e.g. swashes).

d429 1
a429 1
Perl_utf8_to_uvuni(pTHX_ U8 *s, STRLEN *retlen)
d431 1
a431 3
    /* Call the low level routine asking for checks */
    return Perl_utf8n_to_uvuni(aTHX_ s, UTF8_MAXLEN, retlen,
			       ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
d435 1
a435 1
=for apidoc A|STRLEN|utf8_length|U8 *s|U8 *e
d445 1
a445 1
Perl_utf8_length(pTHX_ U8 *s, U8 *e)
d453 2
a454 10
    if (e < s) {
        if (ckWARN_d(WARN_UTF8)) {
	    if (PL_op)
	        Perl_warner(aTHX_ packWARN(WARN_UTF8),
			    "%s in %s", unees, OP_DESC(PL_op));
	    else
	        Perl_warner(aTHX_ packWARN(WARN_UTF8), unees);
	}
	return 0;
    }
d458 2
a459 10
	if (e - s < t) {
	    if (ckWARN_d(WARN_UTF8)) {
	        if (PL_op)
		    Perl_warner(aTHX_ packWARN(WARN_UTF8),
				unees, OP_DESC(PL_op));
		else
		    Perl_warner(aTHX_ packWARN(WARN_UTF8), unees);
	    }
	    return len;
	}
d476 1
a476 2
=cut
*/
d491 2
a492 10
	    if (b - a < c) {
	        if (ckWARN_d(WARN_UTF8)) {
		    if (PL_op)
		        Perl_warner(aTHX_ packWARN(WARN_UTF8),
				    "%s in %s", unees, OP_DESC(PL_op));
		    else
		        Perl_warner(aTHX_ packWARN(WARN_UTF8), unees);
		}
		return off;
	    }
d501 2
a502 10
	    if (a - b < c) {
	        if (ckWARN_d(WARN_UTF8)) {
		    if (PL_op)
		        Perl_warner(aTHX_ packWARN(WARN_UTF8),
				    "%s in %s", unees, OP_DESC(PL_op));
		    else
		        Perl_warner(aTHX_ packWARN(WARN_UTF8), unees);
		}
		return off;
	    }
d512 1
a512 1
=for apidoc A|U8 *|utf8_hop|U8 *s|I32 off
d521 1
a521 2
=cut
*/
d556 1
a556 1
Perl_utf8_to_bytes(pTHX_ U8 *s, STRLEN *len)
d566 3
a568 3
        if (!UTF8_IS_INVARIANT(c) &&
            (!UTF8_IS_DOWNGRADEABLE_START(c) || (s >= send)
	     || !(c = *s++) || !UTF8_IS_CONTINUATION(c))) {
d576 8
a583 3
        STRLEN ulen;
        *d++ = (U8)utf8_to_uvchr(s, &ulen);
        s += ulen;
d600 1
a600 2
=cut
*/
d603 1
a603 1
Perl_bytes_from_utf8(pTHX_ U8 *s, STRLEN *len, bool *is_utf8)
d605 1
a607 1
    U8 *send;
d616 3
a618 5
	if (!UTF8_IS_INVARIANT(c)) {
	    if (UTF8_IS_DOWNGRADEABLE_START(c) && s < send &&
                (c = *s++) && UTF8_IS_CONTINUATION(c))
		count++;
	    else
d620 2
a621 1
	}
d626 3
d633 5
a637 6
	if (!UTF8_IS_INVARIANT(c)) {
	    /* Then it is two-byte encoded */
	    c = UTF8_ACCUMULATE(NATIVE_TO_UTF(c), *s++);
	    c = ASCII_TO_NATIVE(c);
	}
	*d++ = c;
d655 1
a655 1
Perl_bytes_to_utf8(pTHX_ U8 *s, STRLEN *len)
d666 2
a667 3
        UV uv = NATIVE_TO_ASCII(*s++);
        if (UNI_IS_INVARIANT(uv))
            *d++ = (U8)UTF_TO_NATIVE(uv);
d669 4
a672 2
            *d++ = (U8)UTF8_EIGHT_BIT_HI(uv);
            *d++ = (U8)UTF8_EIGHT_BIT_LO(uv);
d701 1
a701 1
	    *d++ = (U8)uv;
d705 2
a706 2
	    *d++ = (U8)(( uv >>  6)         | 0xc0);
	    *d++ = (U8)(( uv        & 0x3f) | 0x80);
d716 3
a718 3
	    *d++ = (U8)(( uv >> 12)         | 0xe0);
	    *d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	    *d++ = (U8)(( uv        & 0x3f) | 0x80);
d722 4
a725 4
	    *d++ = (U8)(( uv >> 18)         | 0xf0);
	    *d++ = (U8)(((uv >> 12) & 0x3f) | 0x80);
	    *d++ = (U8)(((uv >>  6) & 0x3f) | 0x80);
	    *d++ = (U8)(( uv        & 0x3f) | 0x80);
d752 1
a752 1
Perl_is_uni_alnum(pTHX_ UV c)
d755 1
a755 1
    uvchr_to_utf8(tmpbuf, c);
d760 1
a760 1
Perl_is_uni_alnumc(pTHX_ UV c)
d763 1
a763 1
    uvchr_to_utf8(tmpbuf, c);
d768 1
a768 1
Perl_is_uni_idfirst(pTHX_ UV c)
d771 1
a771 1
    uvchr_to_utf8(tmpbuf, c);
d776 1
a776 1
Perl_is_uni_alpha(pTHX_ UV c)
d779 1
a779 1
    uvchr_to_utf8(tmpbuf, c);
d784 1
a784 1
Perl_is_uni_ascii(pTHX_ UV c)
d787 1
a787 1
    uvchr_to_utf8(tmpbuf, c);
d792 1
a792 1
Perl_is_uni_space(pTHX_ UV c)
d795 1
a795 1
    uvchr_to_utf8(tmpbuf, c);
d800 1
a800 1
Perl_is_uni_digit(pTHX_ UV c)
d803 1
a803 1
    uvchr_to_utf8(tmpbuf, c);
d808 1
a808 1
Perl_is_uni_upper(pTHX_ UV c)
d811 1
a811 1
    uvchr_to_utf8(tmpbuf, c);
d816 1
a816 1
Perl_is_uni_lower(pTHX_ UV c)
d819 1
a819 1
    uvchr_to_utf8(tmpbuf, c);
d824 1
a824 1
Perl_is_uni_cntrl(pTHX_ UV c)
d827 1
a827 1
    uvchr_to_utf8(tmpbuf, c);
d832 1
a832 1
Perl_is_uni_graph(pTHX_ UV c)
d835 1
a835 1
    uvchr_to_utf8(tmpbuf, c);
d840 1
a840 1
Perl_is_uni_print(pTHX_ UV c)
d843 1
a843 1
    uvchr_to_utf8(tmpbuf, c);
d848 1
a848 1
Perl_is_uni_punct(pTHX_ UV c)
d851 1
a851 1
    uvchr_to_utf8(tmpbuf, c);
d856 1
a856 1
Perl_is_uni_xdigit(pTHX_ UV c)
d858 2
a859 2
    U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
    uvchr_to_utf8(tmpbuf, c);
d863 2
a864 2
UV
Perl_to_uni_upper(pTHX_ UV c, U8* p, STRLEN *lenp)
d866 3
a868 2
    uvchr_to_utf8(p, c);
    return to_utf8_upper(p, p, lenp);
d871 2
a872 2
UV
Perl_to_uni_title(pTHX_ UV c, U8* p, STRLEN *lenp)
d874 3
a876 2
    uvchr_to_utf8(p, c);
    return to_utf8_title(p, p, lenp);
d879 2
a880 2
UV
Perl_to_uni_lower(pTHX_ UV c, U8* p, STRLEN *lenp)
d882 3
a884 9
    uvchr_to_utf8(p, c);
    return to_utf8_lower(p, p, lenp);
}

UV
Perl_to_uni_fold(pTHX_ UV c, U8* p, STRLEN *lenp)
{
    uvchr_to_utf8(p, c);
    return to_utf8_fold(p, p, lenp);
d890 1
a890 1
Perl_is_uni_alnum_lc(pTHX_ UV c)
d896 1
a896 1
Perl_is_uni_alnumc_lc(pTHX_ UV c)
d902 1
a902 1
Perl_is_uni_idfirst_lc(pTHX_ UV c)
d908 1
a908 1
Perl_is_uni_alpha_lc(pTHX_ UV c)
d914 1
a914 1
Perl_is_uni_ascii_lc(pTHX_ UV c)
d920 1
a920 1
Perl_is_uni_space_lc(pTHX_ UV c)
d926 1
a926 1
Perl_is_uni_digit_lc(pTHX_ UV c)
d932 1
a932 1
Perl_is_uni_upper_lc(pTHX_ UV c)
d938 1
a938 1
Perl_is_uni_lower_lc(pTHX_ UV c)
d944 1
a944 1
Perl_is_uni_cntrl_lc(pTHX_ UV c)
d950 1
a950 1
Perl_is_uni_graph_lc(pTHX_ UV c)
d956 1
a956 1
Perl_is_uni_print_lc(pTHX_ UV c)
d962 1
a962 1
Perl_is_uni_punct_lc(pTHX_ UV c)
d968 1
a968 1
Perl_is_uni_xdigit_lc(pTHX_ UV c)
d976 1
a976 5
    /* XXX returns only the first character -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
    return (U32)to_uni_upper(c, tmpbuf, &len);
d982 1
a982 5
    /* XXX returns only the first character XXX -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
    return (U32)to_uni_title(c, tmpbuf, &len);
d988 1
a988 5
    /* XXX returns only the first character -- do not use XXX */
    /* XXX no locale support yet */
    STRLEN len;
    U8 tmpbuf[UTF8_MAXLEN_UCLC+1];
    return (U32)to_uni_lower(c, tmpbuf, &len);
d1001 1
a1001 1
    return swash_fetch(PL_utf8_alnum, p, TRUE) != 0;
d1007 1
a1007 1
    return swash_fetch(PL_utf8_alnum, p, TRUE) != 0;
d1018 1
a1018 1
    return swash_fetch(PL_utf8_alnum, p, TRUE) != 0;
d1024 1
a1024 1
    return swash_fetch(PL_utf8_alnum, p, TRUE) != 0;
d1029 1
a1029 1
Perl_is_utf8_idfirst(pTHX_ U8 *p) /* The naming is historical. */
d1031 1
a1031 19
    if (*p == '_')
	return TRUE;
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_idstart) /* is_utf8_idstart would be more logical. */
	PL_utf8_idstart = swash_init("utf8", "IdStart", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_idstart, p, TRUE) != 0;
}

bool
Perl_is_utf8_idcont(pTHX_ U8 *p)
{
    if (*p == '_')
	return TRUE;
    if (!is_utf8_char(p))
	return FALSE;
    if (!PL_utf8_idcont)
	PL_utf8_idcont = swash_init("utf8", "IdContinue", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_idcont, p, TRUE) != 0;
d1041 1
a1041 1
    return swash_fetch(PL_utf8_alpha, p, TRUE) != 0;
d1051 1
a1051 1
    return swash_fetch(PL_utf8_ascii, p, TRUE) != 0;
d1061 1
a1061 1
    return swash_fetch(PL_utf8_space, p, TRUE) != 0;
d1071 1
a1071 1
    return swash_fetch(PL_utf8_digit, p, TRUE) != 0;
d1081 1
a1081 1
    return swash_fetch(PL_utf8_upper, p, TRUE) != 0;
d1091 1
a1091 1
    return swash_fetch(PL_utf8_lower, p, TRUE) != 0;
d1101 1
a1101 1
    return swash_fetch(PL_utf8_cntrl, p, TRUE) != 0;
d1111 1
a1111 1
    return swash_fetch(PL_utf8_graph, p, TRUE) != 0;
d1121 1
a1121 1
    return swash_fetch(PL_utf8_print, p, TRUE) != 0;
d1131 1
a1131 1
    return swash_fetch(PL_utf8_punct, p, TRUE) != 0;
d1141 1
a1141 1
    return swash_fetch(PL_utf8_xdigit, p, TRUE) != 0;
d1151 1
a1151 1
    return swash_fetch(PL_utf8_mark, p, TRUE) != 0;
a1153 25
/*
=for apidoc A|UV|to_utf8_case|U8 *p|U8* ustrp|STRLEN *lenp|SV **swash|char *normal|char *special

The "p" contains the pointer to the UTF-8 string encoding
the character that is being converted.

The "ustrp" is a pointer to the character buffer to put the
conversion result to.  The "lenp" is a pointer to the length
of the result.

The "swashp" is a pointer to the swash to use.

Both the special and normal mappings are stored lib/unicore/To/Foo.pl,
and loaded by SWASHGET, using lib/utf8_heavy.pl.  The special (usually,
but not always, a multicharacter mapping), is tried first.

The "special" is a string like "utf8::ToSpecLower", which means the
hash %utf8::ToSpecLower.  The access to the hash is through
Perl_to_utf8_case().

The "normal" is a string like "ToLower" which means the swash
%utf8::ToLower.

=cut */

d1155 1
a1155 1
Perl_to_utf8_case(pTHX_ U8 *p, U8* ustrp, STRLEN *lenp, SV **swashp, char *normal, char *special)
d1157 1
a1157 80
    UV uv0, uv1;
    U8 tmpbuf[UTF8_MAXLEN_FOLD+1];
    STRLEN len = 0;

    uv0 = utf8_to_uvchr(p, 0);
    /* The NATIVE_TO_UNI() and UNI_TO_NATIVE() mappings
     * are necessary in EBCDIC, they are redundant no-ops
     * in ASCII-ish platforms, and hopefully optimized away. */
    uv1 = NATIVE_TO_UNI(uv0);
    uvuni_to_utf8(tmpbuf, uv1);

    if (!*swashp) /* load on-demand */
         *swashp = swash_init("utf8", normal, &PL_sv_undef, 4, 0);

    if (special) {
         /* It might be "special" (sometimes, but not always,
	  * a multicharacter mapping) */
	 HV *hv;
	 SV *keysv;
	 HE *he;
	 SV *val;
	
	 if ((hv    = get_hv(special, FALSE)) &&
	     (keysv = sv_2mortal(Perl_newSVpvf(aTHX_ "%04"UVXf, uv1))) &&
	     (he    = hv_fetch_ent(hv, keysv, FALSE, 0)) &&
	     (val   = HeVAL(he))) {
	     char *s;

	      s = SvPV(val, len);
	      if (len == 1)
		   len = uvuni_to_utf8(ustrp, NATIVE_TO_UNI(*(U8*)s)) - ustrp;
	      else {
#ifdef EBCDIC
		   /* If we have EBCDIC we need to remap the characters
		    * since any characters in the low 256 are Unicode
		    * code points, not EBCDIC. */
		   U8 *t = (U8*)s, *tend = t + len, *d;
		
		   d = tmpbuf;
		   if (SvUTF8(val)) {
			STRLEN tlen = 0;
			
			while (t < tend) {
			     UV c = utf8_to_uvchr(t, &tlen);
			     if (tlen > 0) {
				  d = uvchr_to_utf8(d, UNI_TO_NATIVE(c));
				  t += tlen;
			     }
			     else
				  break;
			}
		   }
		   else {
			while (t < tend) {
			     d = uvchr_to_utf8(d, UNI_TO_NATIVE(*t));
			     t++;
			}
		   }
		   len = d - tmpbuf;
		   Copy(tmpbuf, ustrp, len, U8);
#else
		   Copy(s, ustrp, len, U8);
#endif
	      }
	 }
    }

    if (!len && *swashp) {
	 UV uv2 = swash_fetch(*swashp, tmpbuf, TRUE);
	 
	 if (uv2) {
	      /* It was "normal" (a single character mapping). */
	      UV uv3 = UNI_TO_NATIVE(uv2);
	      
	      len = uvchr_to_utf8(ustrp, uv3) - ustrp;
	 }
    }

    if (!len) /* Neither: just copy. */
	 len = uvchr_to_utf8(ustrp, uv0) - ustrp;
d1159 4
a1162 4
    if (lenp)
	 *lenp = len;

    return len ? utf8_to_uvchr(ustrp, 0) : 0;
a1164 14
/*
=for apidoc A|UV|to_utf8_upper|U8 *p|U8 *ustrp|STRLEN *lenp

Convert the UTF-8 encoded character at p to its uppercase version and
store that in UTF-8 in ustrp and its length in bytes in lenp.  Note
that the ustrp needs to be at least UTF8_MAXLEN_UCLC+1 bytes since the
uppercase version may be longer than the original character (up to two
characters).

The first character of the uppercased version is returned
(but note, as explained above, that there may be more.)

=cut */

d1166 1
a1166 1
Perl_to_utf8_upper(pTHX_ U8 *p, U8* ustrp, STRLEN *lenp)
d1168 1
a1168 17
    return Perl_to_utf8_case(aTHX_ p, ustrp, lenp,
                             &PL_utf8_toupper, "ToUpper", "utf8::ToSpecUpper");
}

/*
=for apidoc A|UV|to_utf8_title|U8 *p|U8 *ustrp|STRLEN *lenp

Convert the UTF-8 encoded character at p to its titlecase version and
store that in UTF-8 in ustrp and its length in bytes in lenp.  Note
that the ustrp needs to be at least UTF8_MAXLEN_UCLC+1 bytes since the
titlecase version may be longer than the original character (up to two
characters).

The first character of the titlecased version is returned
(but note, as explained above, that there may be more.)

=cut */
d1170 4
a1173 5
UV
Perl_to_utf8_title(pTHX_ U8 *p, U8* ustrp, STRLEN *lenp)
{
    return Perl_to_utf8_case(aTHX_ p, ustrp, lenp,
                             &PL_utf8_totitle, "ToTitle", "utf8::ToSpecTitle");
a1175 14
/*
=for apidoc A|UV|to_utf8_lower|U8 *p|U8 *ustrp|STRLEN *lenp

Convert the UTF-8 encoded character at p to its lowercase version and
store that in UTF-8 in ustrp and its length in bytes in lenp.  Note
that the ustrp needs to be at least UTF8_MAXLEN_UCLC+1 bytes since the
lowercase version may be longer than the original character (up to two
characters).

The first character of the lowercased version is returned
(but note, as explained above, that there may be more.)

=cut */

d1177 1
a1177 1
Perl_to_utf8_lower(pTHX_ U8 *p, U8* ustrp, STRLEN *lenp)
d1179 1
a1179 17
    return Perl_to_utf8_case(aTHX_ p, ustrp, lenp,
                             &PL_utf8_tolower, "ToLower", "utf8::ToSpecLower");
}

/*
=for apidoc A|UV|to_utf8_fold|U8 *p|U8 *ustrp|STRLEN *lenp

Convert the UTF-8 encoded character at p to its foldcase version and
store that in UTF-8 in ustrp and its length in bytes in lenp.  Note
that the ustrp needs to be at least UTF8_MAXLEN_FOLD+1 bytes since the
foldcase version may be longer than the original character (up to
three characters).

The first character of the foldcased version is returned
(but note, as explained above, that there may be more.)

=cut */
d1181 4
a1184 5
UV
Perl_to_utf8_fold(pTHX_ U8 *p, U8* ustrp, STRLEN *lenp)
{
    return Perl_to_utf8_case(aTHX_ p, ustrp, lenp,
                             &PL_utf8_tofold, "ToFold", "utf8::ToSpecFold");
a1194 2
    HV *stash = gv_stashpvn(pkg, strlen(pkg), FALSE);
    SV* errsv_save;
d1196 1
a1196 1
    if (!gv_fetchmeth(stash, "SWASHNEW", 8, -1)) {	/* demand load utf8 */
a1197 1
	errsv_save = newSVsv(ERRSV);
a1198 3
	if (!SvTRUE(ERRSV))
	    sv_setsv(ERRSV, errsv_save);
	SvREFCNT_dec(errsv_save);
d1215 1
a1215 1
    if (PL_curcop == &PL_compiling) {
a1216 1
	SAVEI32(PL_in_my);
a1217 2
    }
    errsv_save = newSVsv(ERRSV);
a1221 3
    if (!SvTRUE(ERRSV))
	sv_setsv(ERRSV, errsv_save);
    SvREFCNT_dec(errsv_save);
d1229 1
a1229 1
	PL_curcop->op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d1231 1
a1231 4
    if (!SvROK(retval) || SvTYPE(SvRV(retval)) != SVt_PVHV) {
        if (SvPOK(retval))
	    Perl_croak(aTHX_ "Can't find Unicode property definition \"%s\"",
		       SvPV_nolen(retval));
a1232 1
    }
a1235 6

/* This API is wrong for special case conversions since we may need to
 * return several Unicode characters for a single Unicode character
 * (see lib/unicore/SpecCase.txt) The SWASHGET in lib/utf8_heavy.pl is
 * the lower-level routine, and it is similarly broken for returning
 * multiple values.  --jhi */
d1237 1
a1237 1
Perl_swash_fetch(pTHX_ SV *sv, U8 *ptr, bool do_utf8)
d1240 2
a1241 2
    U32 klen;
    U32 off;
d1243 2
a1244 2
    STRLEN needents;
    U8 *tmps = NULL;
a1246 30
    U8 tmputf8[2];
    UV c = NATIVE_TO_ASCII(*ptr);

    if (!do_utf8 && !UNI_IS_INVARIANT(c)) {
        tmputf8[0] = (U8)UTF8_EIGHT_BIT_HI(c);
        tmputf8[1] = (U8)UTF8_EIGHT_BIT_LO(c);
        ptr = tmputf8;
    }
    /* Given a UTF-X encoded char 0xAA..0xYY,0xZZ
     * then the "swatch" is a vec() for al the chars which start
     * with 0xAA..0xYY
     * So the key in the hash (klen) is length of encoded char -1
     */
    klen = UTF8SKIP(ptr) - 1;
    off  = ptr[klen];

    if (klen == 0)
     {
      /* If char in invariant then swatch is for all the invariant chars
       * In both UTF-8 and UTF8-MOD that happens to be UTF_CONTINUATION_MARK
       */
      needents = UTF_CONTINUATION_MARK;
      off      = NATIVE_TO_UTF(ptr[klen]);
     }
    else
     {
      /* If char is encoded then swatch is for the prefix */
      needents = (1 << UTF_ACCUMULATION_SHIFT);
      off      = NATIVE_TO_UTF(ptr[klen]) & UTF_CONTINUATION_MASK;
     }
d1257 1
a1257 1
    if (hv   == PL_last_swash_hv &&
d1259 1
a1259 1
	(!klen || memEQ((char *)ptr, (char *)PL_last_swash_key, klen)) )
a1270 7
	    /* We use utf8n_to_uvuni() as we want an index into
	       Unicode tables, not a native character number.
	     */
	    UV code_point = utf8n_to_uvuni(ptr, UTF8_MAXLEN, 0,
					   ckWARN(WARN_UTF8) ?
					   0 : UTF8_ALLOW_ANY);
	    SV *errsv_save;
d1278 1
a1278 3
	    /* On EBCDIC & ~(0xA0-1) isn't a useful thing to do */
	    PUSHs(sv_2mortal(newSViv((klen) ?
				     (code_point & ~(needents - 1)) : 0)));
a1280 1
	    errsv_save = newSVsv(ERRSV);
a1284 3
	    if (!SvTRUE(ERRSV))
		sv_setsv(ERRSV, errsv_save);
	    SvREFCNT_dec(errsv_save);
d1289 1
a1289 1
		PL_curcop->op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d1293 1
a1293 1
	    if (!svp || !(tmps = (U8*)SvPV(*svp, slen)) || (slen << 3) < needents)
a1321 251


/*
=for apidoc A|U8 *|uvchr_to_utf8|U8 *d|UV uv

Adds the UTF8 representation of the Native codepoint C<uv> to the end
of the string C<d>; C<d> should be have at least C<UTF8_MAXLEN+1> free
bytes available. The return value is the pointer to the byte after the
end of the new character. In other words,

    d = uvchr_to_utf8(d, uv);

is the recommended wide native character-aware way of saying

    *(d++) = uv;

=cut
*/

/* On ASCII machines this is normally a macro but we want a
   real function in case XS code wants it
*/
#undef Perl_uvchr_to_utf8
U8 *
Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv)
{
    return Perl_uvuni_to_utf8_flags(aTHX_ d, NATIVE_TO_UNI(uv), 0);
}

U8 *
Perl_uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
{
    return Perl_uvuni_to_utf8_flags(aTHX_ d, NATIVE_TO_UNI(uv), flags);
}

/*
=for apidoc A|UV|utf8n_to_uvchr|U8 *s|STRLEN curlen|STRLEN *retlen|U32 flags

Returns the native character value of the first character in the string C<s>
which is assumed to be in UTF8 encoding; C<retlen> will be set to the
length, in bytes, of that character.

Allows length and flags to be passed to low level routine.

=cut
*/
/* On ASCII machines this is normally a macro but we want
   a real function in case XS code wants it
*/
#undef Perl_utf8n_to_uvchr
UV
Perl_utf8n_to_uvchr(pTHX_ U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
{
    UV uv = Perl_utf8n_to_uvuni(aTHX_ s, curlen, retlen, flags);
    return UNI_TO_NATIVE(uv);
}

/*
=for apidoc A|char *|pv_uni_display|SV *dsv|U8 *spv|STRLEN len|STRLEN pvlim|UV flags

Build to the scalar dsv a displayable version of the string spv,
length len, the displayable version being at most pvlim bytes long
(if longer, the rest is truncated and "..." will be appended).

The flags argument can have UNI_DISPLAY_ISPRINT set to display
isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH
to display the \\[nrfta\\] as the backslashed versions (like '\n')
(UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\).
UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both
UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.

The pointer to the PV of the dsv is returned.

=cut */
char *
Perl_pv_uni_display(pTHX_ SV *dsv, U8 *spv, STRLEN len, STRLEN pvlim, UV flags)
{
    int truncated = 0;
    char *s, *e;

    sv_setpvn(dsv, "", 0);
    for (s = (char *)spv, e = s + len; s < e; s += UTF8SKIP(s)) {
	 UV u;
	 bool ok = FALSE;

	 if (pvlim && SvCUR(dsv) >= pvlim) {
	      truncated++;
	      break;
	 }
	 u = utf8_to_uvchr((U8*)s, 0);
	 if (u < 256) {
	     if (!ok && (flags & UNI_DISPLAY_BACKSLASH)) {
	         switch (u & 0xFF) {
		 case '\n':
		     Perl_sv_catpvf(aTHX_ dsv, "\\n"); ok = TRUE; break;
		 case '\r':
		     Perl_sv_catpvf(aTHX_ dsv, "\\r"); ok = TRUE; break;
		 case '\t':
		     Perl_sv_catpvf(aTHX_ dsv, "\\t"); ok = TRUE; break;
		 case '\f':
		     Perl_sv_catpvf(aTHX_ dsv, "\\f"); ok = TRUE; break;
		 case '\a':
		     Perl_sv_catpvf(aTHX_ dsv, "\\a"); ok = TRUE; break;
		 case '\\':
		     Perl_sv_catpvf(aTHX_ dsv, "\\\\" ); ok = TRUE; break;
		 default: break;
		 }
	     }
	     /* isPRINT() is the locale-blind version. */
	     if (!ok && (flags & UNI_DISPLAY_ISPRINT) && isPRINT(u & 0xFF)) {
	         Perl_sv_catpvf(aTHX_ dsv, "%c", (char)(u & 0xFF));
		 ok = TRUE;
	     }
	 }
	 if (!ok)
	     Perl_sv_catpvf(aTHX_ dsv, "\\x{%"UVxf"}", u);
    }
    if (truncated)
	 sv_catpvn(dsv, "...", 3);
    
    return SvPVX(dsv);
}

/*
=for apidoc A|char *|sv_uni_display|SV *dsv|SV *ssv|STRLEN pvlim|UV flags

Build to the scalar dsv a displayable version of the scalar sv,
the displayable version being at most pvlim bytes long
(if longer, the rest is truncated and "..." will be appended).

The flags argument is as in pv_uni_display().

The pointer to the PV of the dsv is returned.

=cut */
char *
Perl_sv_uni_display(pTHX_ SV *dsv, SV *ssv, STRLEN pvlim, UV flags)
{
     return Perl_pv_uni_display(aTHX_ dsv, (U8*)SvPVX(ssv), SvCUR(ssv),
				pvlim, flags);
}

/*
=for apidoc A|I32|ibcmp_utf8|const char *s1|char **pe1|register UV l1|bool u1|const char *s2|char **pe2|register UV l2|bool u2

Return true if the strings s1 and s2 differ case-insensitively, false
if not (if they are equal case-insensitively).  If u1 is true, the
string s1 is assumed to be in UTF-8-encoded Unicode.  If u2 is true,
the string s2 is assumed to be in UTF-8-encoded Unicode.  If u1 or u2
are false, the respective string is assumed to be in native 8-bit
encoding.

If the pe1 and pe2 are non-NULL, the scanning pointers will be copied
in there (they will point at the beginning of the I<next> character).
If the pointers behind pe1 or pe2 are non-NULL, they are the end
pointers beyond which scanning will not continue under any
circustances.  If the byte lengths l1 and l2 are non-zero, s1+l1 and
s2+l2 will be used as goal end pointers that will also stop the scan,
and which qualify towards defining a successful match: all the scans
that define an explicit length must reach their goal pointers for
a match to succeed).

For case-insensitiveness, the "casefolding" of Unicode is used
instead of upper/lowercasing both the characters, see
http://www.unicode.org/unicode/reports/tr21/ (Case Mappings).

=cut */
I32
Perl_ibcmp_utf8(pTHX_ const char *s1, char **pe1, register UV l1, bool u1, const char *s2, char **pe2, register UV l2, bool u2)
{
     register U8 *p1  = (U8*)s1;
     register U8 *p2  = (U8*)s2;
     register U8 *e1 = 0, *f1 = 0, *q1 = 0;
     register U8 *e2 = 0, *f2 = 0, *q2 = 0;
     STRLEN n1 = 0, n2 = 0;
     U8 foldbuf1[UTF8_MAXLEN_FOLD+1];
     U8 foldbuf2[UTF8_MAXLEN_FOLD+1];
     U8 natbuf[1+1];
     STRLEN foldlen1, foldlen2;
     bool match;
     
     if (pe1)
	  e1 = *(U8**)pe1;
     if (e1 == 0 || (l1 && l1 < (UV)(e1 - (U8*)s1)))
	  f1 = (U8*)s1 + l1;
     if (pe2)
	  e2 = *(U8**)pe2;
     if (e2 == 0 || (l2 && l2 < (UV)(e2 - (U8*)s2)))
	  f2 = (U8*)s2 + l2;

     if ((e1 == 0 && f1 == 0) || (e2 == 0 && f2 == 0) || (f1 == 0 && f2 == 0))
	  return 1; /* mismatch; possible infinite loop or false positive */

     if (!u1 || !u2)
	  natbuf[1] = 0; /* Need to terminate the buffer. */

     while ((e1 == 0 || p1 < e1) &&
	    (f1 == 0 || p1 < f1) &&
	    (e2 == 0 || p2 < e2) &&
	    (f2 == 0 || p2 < f2)) {
	  if (n1 == 0) {
	       if (u1)
		    to_utf8_fold(p1, foldbuf1, &foldlen1);
	       else {
		    natbuf[0] = *p1;
		    to_utf8_fold(natbuf, foldbuf1, &foldlen1);
	       }
	       q1 = foldbuf1;
	       n1 = foldlen1;
	  }
	  if (n2 == 0) {
	       if (u2)
		    to_utf8_fold(p2, foldbuf2, &foldlen2);
	       else {
		    natbuf[0] = *p2;
		    to_utf8_fold(natbuf, foldbuf2, &foldlen2);
	       }
	       q2 = foldbuf2;
	       n2 = foldlen2;
	  }
	  while (n1 && n2) {
	       if ( UTF8SKIP(q1) != UTF8SKIP(q2) ||
		   (UTF8SKIP(q1) == 1 && *q1 != *q2) ||
		    memNE((char*)q1, (char*)q2, UTF8SKIP(q1)) )
		   return 1; /* mismatch */
	       n1 -= UTF8SKIP(q1);
	       q1 += UTF8SKIP(q1);
	       n2 -= UTF8SKIP(q2);
	       q2 += UTF8SKIP(q2);
	  }
	  if (n1 == 0)
	       p1 += u1 ? UTF8SKIP(p1) : 1;
	  if (n2 == 0)
	       p2 += u2 ? UTF8SKIP(p2) : 1;

     }

     /* A match is defined by all the scans that specified
      * an explicit length reaching their final goals. */
     match = (f1 == 0 || p1 == f1) && (f2 == 0 || p2 == f2);

     if (match) {
	  if (pe1)
	       *pe1 = (char*)p1;
	  if (pe2)
	       *pe2 = (char*)p2;
     }

     return match ? 0 : 1; /* 0 match, 1 mismatch */
}

@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (C) 2000, 2001, 2002, 2003, by Larry Wall and others
d34 1
a34 1
Adds the UTF-8 representation of the Unicode codepoint C<uv> to the end
d220 4
a223 4
Returns true if first C<len> bytes of the given string form a valid
UTF-8 string, false otherwise.  Note that 'a valid UTF-8 string' does
not mean 'a string that contains code points above 0x7F encoded in UTF-8'
because a valid ASCII string is a valid UTF-8 string.
a259 49
=for apidoc A|bool|is_utf8_string_loc|U8 *s|STRLEN len|U8 **p

Like is_ut8_string but store the location of the failure in
the last argument.

=cut
*/

bool
Perl_is_utf8_string_loc(pTHX_ U8 *s, STRLEN len, U8 **p)
{
    U8* x = s;
    U8* send;
    STRLEN c;

    if (!len)
	len = strlen((char *)s);
    send = s + len;

    while (x < send) {
	 /* Inline the easy bits of is_utf8_char() here for speed... */
	 if (UTF8_IS_INVARIANT(*x))
	      c = 1;
	 else if (!UTF8_IS_START(*x)) {
	      if (p)
		  *p = x;
	      return FALSE;
	 }
	 else {
	      /* ... and call is_utf8_char() only if really needed. */
	      c = is_utf8_char(x);
	      if (!c) {
		   if (p)
		      *p = x;
		   return FALSE;
	      }
	 }
        x += c;
    }
    if (x != send) {
       if (p)
	   *p = x;
	return FALSE;
    }

    return TRUE;
}

/*
d264 1
a264 1
which is assumed to be in UTF-8 encoding and no longer than C<curlen>;
d267 1
a267 1
If C<s> does not point to a well-formed UTF-8 character, the behaviour
d487 1
a487 1
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
d490 1
a490 1
If C<s> does not point to a well-formed UTF-8 character, zero is
d507 1
a507 1
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
d513 1
a513 1
If C<s> does not point to a well-formed UTF-8 character, zero is
d579 1
a579 1
Returns the number of UTF-8 characters between the UTF-8 pointers C<a>
d674 1
a674 1
Converts a string C<s> of length C<len> from UTF-8 into byte encoding.
d689 1
a689 1
    /* ensure valid UTF-8 and chars < 256 before updating string */
d715 1
a715 1
Converts a string C<s> of length C<len> from UTF-8 into byte encoding.
d736 1
a736 1
    /* ensure valid UTF-8 and chars < 256 before converting string */
d769 1
a769 1
Converts a string C<s> of length C<len> from ASCII into UTF-8 encoding.
a772 3
If you want to convert to UTF-8 from other encodings than ASCII,
see sv_recode_to_utf8().

d831 1
a831 2
	    UV low = (p[0] << 8) + p[1];
	    p += 2;
d1235 1
a1235 1
	PL_utf8_upper = swash_init("utf8", "IsUppercase", &PL_sv_undef, 0, 0);
d1245 1
a1245 1
	PL_utf8_lower = swash_init("utf8", "IsLowercase", &PL_sv_undef, 0, 0);
d1542 1
a1542 1
    if (IN_PERL_COMPILETIME) {
a1544 1
	PL_in_my = 0;
d1557 1
a1557 1
    if (IN_PERL_COMPILETIME) {
d1566 2
a1567 2
	    Perl_croak(aTHX_ "Can't find Unicode property definition \"%"SVf"\"",
		       retval);
d1609 1
a1609 1
       * In both UTF-8 and UTF-8-MOD that happens to be UTF_CONTINUATION_MARK
d1674 1
a1674 1
	    if (IN_PERL_COMPILETIME)
d1713 1
a1713 1
Adds the UTF-8 representation of the Native codepoint C<uv> to the end
d1747 1
a1747 1
which is assumed to be in UTF-8 encoding; C<retlen> will be set to the
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
 *    Copyright (C) 2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d235 1
a235 1
    if (!len && s)
d275 1
a275 1
    if (!len && s)
d1404 1
a1404 2
    /* The 0xDF is the only special casing Unicode code point below 0x100. */
    if (special && (uv1 == 0xDF || uv1 > 0xFF)) {
d1408 9
a1416 6
	 SV **svp;

	 if ((hv  = get_hv(special, FALSE)) &&
	     (svp = hv_fetch(hv, (const char*)tmpbuf, UNISKIP(uv1), FALSE)) &&
	     (*svp)) {
	      char *s;
d1418 1
a1418 1
	      s = SvPV(*svp, len);
d1429 1
a1429 1
		   if (SvUTF8(*svp)) {
d1569 1
a1569 3
    size_t pkg_len = strlen(pkg);
    size_t name_len = strlen(name);
    HV *stash = gv_stashpvn(pkg, pkg_len, FALSE);
d1575 1
a1575 2
	Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, newSVpvn(pkg,pkg_len),
			 Nullsv);
d1585 2
a1586 2
    PUSHs(sv_2mortal(newSVpvn(pkg, pkg_len)));
    PUSHs(sv_2mortal(newSVpvn(name, name_len)));
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@a31 6
This file contains various utility functions for manipulating UTF8-encoded
strings. For the uninitiated, this is a method of representing arbitrary
Unicode characters as a variable number of bytes, in such a way that
characters in the ASCII range are unmodified, and a zero byte never appears
within non-zero characters.

a864 6
    if (bytelen == 1 && p[0] == 0) { /* Be understanding. */
	 d[0] = 0;
	 *newlen = 1;
	 return d;
    }

d866 1
a866 1
	Perl_croak(aTHX_ "panic: utf16_to_utf8: odd bytelen %d", bytelen);
d1919 1
a1919 1
circumstances.  If the byte lengths l1 and l2 are non-zero, s1+l1 and
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d3 1
a3 2
 *    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006,
 *    by Larry Wall and others
d27 1
a27 2
static const char unees[] =
    "Malformed UTF-8 character (unexpected end of string)";
d41 1
a41 1
of the string C<d>; C<d> should be have at least C<UTF8_MAXBYTES+1> free
d174 1
d176 1
a182 10
This is the "slow" version as opposed to the "fast" version which is
the "unrolled" IS_UTF8_CHAR().  E.g. for t/uni/class.t the speed
difference is a factor of 2 to 3.  For lengths (UTF8SKIP(s)) of four
or less you should use the IS_UTF8_CHAR(), for lengths of five or more
you should use the _slow().  In practice this means that the _slow()
will be used very rarely, since the maximum Unicode code point (as of
Unicode 4.1) is U+10FFFF, which encodes in UTF-8 to four bytes.  Only
the "Perl extended UTF-8" (the infamous 'v-strings') will encode into
five bytes or more.

d184 2
a185 2
STATIC STRLEN
S_is_utf8_char_slow(pTHX_ const U8 *s, const STRLEN len)
d188 1
a188 1
    STRLEN slen;
d197 2
a203 3
#ifdef EBCDIC
    u = NATIVE_TO_UTF(u);
#endif
a223 20
=for apidoc A|STRLEN|is_utf8_char|U8 *s

Tests if some arbitrary number of bytes begins in a valid UTF-8
character.  Note that an INVARIANT (i.e. ASCII) character is a valid
UTF-8 character.  The actual number of bytes in the UTF-8 character
will be returned if it is valid, otherwise 0.

=cut */
STRLEN
Perl_is_utf8_char(pTHX_ U8 *s)
{
    const STRLEN len = UTF8SKIP(s);
#ifdef IS_UTF8_CHAR
    if (IS_UTF8_CHAR_FAST(len))
        return IS_UTF8_CHAR(s, len) ? len : 0;
#endif /* #ifdef IS_UTF8_CHAR */
    return is_utf8_char_slow(s, len);
}

/*
a230 2
See also is_utf8_string_loclen() and is_utf8_string_loc().

d237 3
a239 2
    const U8* x = s;
    const U8* send;
d241 2
a242 2
    if (!len)
	len = strlen((const char *)s);
a245 1
	STRLEN c;
d250 1
a250 1
	     goto out;
d253 1
a253 10
#ifdef IS_UTF8_CHAR
	     c = UTF8SKIP(x);
	     if (IS_UTF8_CHAR_FAST(c)) {
	         if (!IS_UTF8_CHAR(x, c))
		     goto out;
	     } else if (!is_utf8_char_slow(x, c))
	         goto out;
#else
	     c = is_utf8_char(x);
#endif /* #ifdef IS_UTF8_CHAR */
d255 1
a255 1
		  goto out;
a258 2

 out:
d266 1
a266 6
=for apidoc A|bool|is_utf8_string_loclen|const U8 *s|STRLEN len|const U8 **ep|const STRLEN *el

Like is_utf8_string() but stores the location of the failure (in the
case of "utf8ness failure") or the location s+len (in the case of
"utf8ness success") in the C<ep>, and the number of UTF-8
encoded characters in the C<el>.
d268 2
a269 1
See also is_utf8_string_loc() and is_utf8_string().
d275 1
a275 1
Perl_is_utf8_string_loclen(pTHX_ const U8 *s, STRLEN len, const U8 **ep, STRLEN *el)
d277 2
a278 2
    const U8* x = s;
    const U8* send;
d281 2
a282 2
    if (!len)
        len = strlen((const char *)s);
a283 2
    if (el)
        *el = 0;
d288 6
a293 3
	     c = 1;
	 else if (!UTF8_IS_START(*x))
	     goto out;
d295 7
a301 13
	     /* ... and call is_utf8_char() only if really needed. */
#ifdef IS_UTF8_CHAR
	     c = UTF8SKIP(x);
	     if (IS_UTF8_CHAR_FAST(c)) {
	         if (!IS_UTF8_CHAR(x, c))
		     c = 0;
	     } else
	         c = is_utf8_char_slow(x, c);
#else
	     c = is_utf8_char(x);
#endif /* #ifdef IS_UTF8_CHAR */
	     if (!c)
	         goto out;
d303 1
a303 3
         x += c;
	 if (el)
	     (*el)++;
d305 3
a307 5

 out:
    if (ep)
        *ep = x;
    if (x != send)
d309 1
a314 18
=for apidoc A|bool|is_utf8_string_loc|const U8 *s|STRLEN len|const U8 **ep|const STRLEN *el

Like is_utf8_string() but stores the location of the failure (in the
case of "utf8ness failure") or the location s+len (in the case of
"utf8ness success") in the C<ep>.

See also is_utf8_string_loclen() and is_utf8_string().

=cut
*/

bool
Perl_is_utf8_string_loc(pTHX_ U8 *s, STRLEN len, U8 **ep)
{
    return is_utf8_string_loclen(s, len, (const U8 **)ep, 0);
}

/*
d341 1
a341 1
    const U8 *s0 = s;
d344 2
a345 2
    const bool dowarn = ckWARN_d(WARN_UTF8);
    const UV startbyte = *s;
d435 1
a435 1
		if (expectlen != 13 && !(flags & UTF8_ALLOW_LONG)) {
d475 1
a475 1
	SV* const sv = sv_2mortal(newSVpv("Malformed UTF-8 character ", 0));
d480 1
a480 1
	    Perl_sv_catpv(aTHX_ sv, "(empty string)");
d489 1
a489 2
	    else {
		const int len = (int)(s-s0);
d491 2
a492 3
                           (UV)s[1], len, len > 1 ? "s" : "", startbyte, (int)expectlen);
	    }

d499 1
a499 1
                           (int)curlen, curlen == 1 ? "" : "s", (int)expectlen, startbyte);
d511 1
a511 1
			   (int)expectlen, expectlen == 1 ? "": "s", UNISKIP(uv), startbyte);
d517 1
a517 1
	    Perl_sv_catpv(aTHX_ sv, "(unknown reason)");
d522 1
a522 1
	    const char * const s = SvPVX_const(sv);
d554 1
a554 1
    return Perl_utf8n_to_uvchr(aTHX_ s, UTF8_MAXBYTES, retlen,
d578 1
a578 1
    return Perl_utf8n_to_uvuni(aTHX_ s, UTF8_MAXBYTES, retlen,
d601 10
a610 2
    if (e < s)
	goto warn_and_return;
d612 2
a613 1
	const U8 t = UTF8SKIP(s);
a614 1
	    warn_and_return:
d618 1
a618 1
			    "%s in %s", unees, OP_DESC(PL_op));
d654 12
a665 3
	    const U8 c = UTF8SKIP(a);
	    if (b - a < c)
		goto warn_and_return;
d672 1
a672 1
	    const U8 c = UTF8SKIP(b);
a674 1
		warn_and_return:
d723 1
a723 1
    return (U8 *)s;
d768 1
a768 1
=for apidoc A|U8 *|bytes_from_utf8|const U8 *s|STRLEN *len|bool *is_utf8
d771 1
a771 1
Unlike C<utf8_to_bytes> but like C<bytes_to_utf8>, returns a pointer to
d784 2
a785 2
    const U8 *start = s;
    const U8 *send;
a786 1
    const U8 *s2;
d789 1
a789 1
        return (U8 *)start;
d793 1
a793 1
        U8 c = *s++;
d799 1
a799 1
                return (U8 *)start;
d805 4
a808 4
    Newxz(d, (*len) - count + 1, U8);
    s2 = start; start = d;
    while (s2 < send) {
	U8 c = *s2++;
d811 1
a811 1
	    c = UTF8_ACCUMULATE(NATIVE_TO_UTF(c), *s2++);
d818 1
a818 1
    return (U8 *)start;
d837 1
a837 1
    const U8 * const send = s + (*len);
d840 1
d842 1
a842 1
    Newxz(d, (*len) * 2 + 1, U8);
d846 1
a846 1
        const UV uv = NATIVE_TO_ASCII(*s++);
d878 1
a878 1
	Perl_croak(aTHX_ "panic: utf16_to_utf8: odd bytelen %"UVf, (UV)bytelen);
d940 1
a940 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d948 1
a948 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d956 1
a956 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d964 1
a964 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d972 1
a972 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d980 1
a980 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d988 1
a988 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d996 1
a996 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d1004 1
a1004 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d1012 1
a1012 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d1020 1
a1020 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d1028 1
a1028 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d1036 1
a1036 1
    U8 tmpbuf[UTF8_MAXBYTES+1];
d1044 1
a1044 1
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d1169 1
a1169 1
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d1179 1
a1179 1
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d1189 1
a1189 1
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d1218 3
a1220 3
    if (!PL_utf8_alnumc)
	PL_utf8_alnumc = swash_init("utf8", "IsAlnumC", &PL_sv_undef, 0, 0);
    return swash_fetch(PL_utf8_alnumc, p, TRUE) != 0;
d1402 2
a1403 1
    U8 tmpbuf[UTF8_MAXBYTES_CASE+1];
d1406 1
a1406 1
    const UV uv0 = utf8_to_uvchr(p, NULL);
d1410 1
a1410 1
    const UV uv1 = NATIVE_TO_UNI(uv0);
d1426 1
a1426 1
	     const char *s;
d1428 1
a1428 1
	      s = SvPV_const(*svp, len);
d1492 3
a1494 2
that the ustrp needs to be at least UTF8_MAXBYTES_CASE+1 bytes since
the uppercase version may be longer than the original character.
d1513 3
a1515 2
that the ustrp needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the
titlecase version may be longer than the original character.
d1534 3
a1536 2
that the ustrp needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the
lowercase version may be longer than the original character.
d1555 1
a1555 1
that the ustrp needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the
d1577 1
a1577 1
    SV* const tokenbufsv = sv_newmortal();
d1579 3
a1581 3
    const size_t pkg_len = strlen(pkg);
    const size_t name_len = strlen(name);
    HV * const stash = gv_stashpvn(pkg, pkg_len, FALSE);
a1583 5
    PUSHSTACKi(PERLSI_MAGIC);
    ENTER;
    SAVEI32(PL_hints);
    PL_hints = 0;
    save_re_context();
d1595 1
d1604 4
d1626 1
a1626 1
	const char* const pv = SvPV_const(tokenbufsv, len);
d1649 1
a1649 1
    HV* const hv = (HV*)SvRV(sv);
d1654 1
a1654 1
    const U8 *tmps = NULL;
d1706 1
a1706 1
	SV** svp = hv_fetch(hv, (const char*)ptr, klen, FALSE);
d1709 1
a1709 1
	if (!svp || !SvPOK(*svp) || !(tmps = (const U8*)SvPV_const(*svp, slen))) {
d1714 1
a1714 1
	    const UV code_point = utf8n_to_uvuni(ptr, UTF8_MAXBYTES, 0,
d1744 1
a1744 1
	    svp = hv_store(hv, (const char *)ptr, klen, retval, 0);
d1752 1
a1752 2
	/* FIXME change interpvar.h?  */
	PL_last_swash_tmps = (U8 *) tmps;
d1781 1
a1781 1
of the string C<d>; C<d> should be have at least C<UTF8_MAXBYTES+1> free
d1828 1
a1828 1
    const UV uv = Perl_utf8n_to_uvuni(aTHX_ s, curlen, retlen, flags);
d1853 1
a1853 1
    const char *s, *e;
d1856 1
a1856 1
    for (s = (const char *)spv, e = s + len; s < e; s += UTF8SKIP(s)) {
d1858 1
a1858 4
	  /* This serves double duty as a flag and a character to print after
	     a \ when flags & UNI_DISPLAY_BACKSLASH is true.
	  */
	 char ok = 0;
a1865 1
	     const unsigned char c = (unsigned char)u & 0xFF;
d1867 1
a1867 1
	         switch (c) {
d1869 1
a1869 1
		     ok = 'n'; break;
d1871 1
a1871 1
		     ok = 'r'; break;
d1873 1
a1873 1
		     ok = 't'; break;
d1875 1
a1875 1
		     ok = 'f'; break;
d1877 1
a1877 1
		     ok = 'a'; break;
d1879 1
a1879 1
		     ok = '\\'; break;
a1881 3
		 if (ok) {
		     Perl_sv_catpvf(aTHX_ dsv, "\\%c", ok);
		 }
d1884 3
a1886 3
	     if (!ok && (flags & UNI_DISPLAY_ISPRINT) && isPRINT(c)) {
	         Perl_sv_catpvf(aTHX_ dsv, "%c", c);
		 ok = 1;
d1913 2
a1914 2
     return Perl_pv_uni_display(aTHX_ dsv, (U8*)SvPVX_const(ssv),
				SvCUR(ssv), pvlim, flags);
d1945 4
a1948 5
     register const U8 *p1  = (const U8*)s1;
     register const U8 *p2  = (const U8*)s2;
     register const U8 *f1 = 0, *f2 = 0;
     register U8 *e1 = 0, *q1 = 0;
     register U8 *e2 = 0, *q2 = 0;
d1950 2
a1951 2
     U8 foldbuf1[UTF8_MAXBYTES_CASE+1];
     U8 foldbuf2[UTF8_MAXBYTES_CASE+1];
d1958 2
a1959 2
     if (e1 == 0 || (l1 && l1 < (UV)(e1 - (const U8*)s1)))
	  f1 = (const U8*)s1 + l1;
d1962 2
a1963 2
     if (e2 == 0 || (l2 && l2 < (UV)(e2 - (const U8*)s2)))
	  f2 = (const U8*)s2 + l2;
d1977 1
a1977 1
		    to_utf8_fold((U8 *)p1, foldbuf1, &foldlen1);
d1979 1
a1979 1
		    uvuni_to_utf8(natbuf, (UV) NATIVE_TO_UNI(((UV)*p1)));
d1987 1
a1987 1
		    to_utf8_fold((U8 *)p2, foldbuf2, &foldlen2);
d1989 1
a1989 1
		    uvuni_to_utf8(natbuf, (UV) NATIVE_TO_UNI(((UV)*p2)));
a2025 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
a27 7
#ifndef EBCDIC
/* Separate prototypes needed because in ASCII systems these
 * usually macros but they still are compiled as code, too. */
PERL_CALLCONV UV	Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags);
PERL_CALLCONV U8*	Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv);
#endif

d169 6
d195 1
a195 1
S_is_utf8_char_slow(const U8 *s, const STRLEN len)
d235 1
a235 1
=for apidoc A|STRLEN|is_utf8_char|const U8 *s
d244 1
a244 1
Perl_is_utf8_char(pTHX_ const U8 *s)
a246 1
    PERL_UNUSED_CONTEXT;
d255 1
a255 1
=for apidoc A|bool|is_utf8_string|const U8 *s|STRLEN len
d268 1
a268 1
Perl_is_utf8_string(pTHX_ const U8 *s, STRLEN len)
a269 1
    const U8* const send = s + (len ? len : strlen((const char *)s));
d271 1
d273 3
a275 1
    PERL_UNUSED_CONTEXT;
d290 3
a292 4
		     c = 0;
	     }
	     else
		c = is_utf8_char_slow(x, c);
a309 10
Implemented as a macro in utf8.h

=for apidoc A|bool|is_utf8_string_loc|const U8 *s|STRLEN len|const U8 **ep

Like is_utf8_string() but stores the location of the failure (in the
case of "utf8ness failure") or the location s+len (in the case of
"utf8ness success") in the C<ep>.

See also is_utf8_string_loclen() and is_utf8_string().

a324 1
    const U8* const send = s + (len ? len : strlen((const char *)s));
d326 1
d328 6
a333 2
    STRLEN outlen = 0;
    PERL_UNUSED_CONTEXT;
d357 2
a358 1
	 outlen++;
a361 3
    if (el)
        *el = outlen;

d364 4
a367 1
    return (x == send);
d371 7
d379 11
a389 1
=for apidoc A|UV|utf8n_to_uvuni|const U8 *s|STRLEN curlen|STRLEN *retlen|U32 flags
d392 1
a392 1
Returns the Unicode code point value of the first character in the string C<s>
d413 1
a413 1
Perl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
d415 1
a415 2
    dVAR;
    const U8 * const s0 = s;
d544 1
a544 1
	    *retlen = ((STRLEN) -1);
d549 1
a549 1
	SV* const sv = sv_2mortal(newSVpvs("Malformed UTF-8 character "));
d554 1
a554 1
	    sv_catpvs(sv, "(empty string)");
d593 1
a593 1
	    sv_catpvs(sv, "(unknown reason)");
d615 1
a615 1
=for apidoc A|UV|utf8_to_uvchr|const U8 *s|STRLEN *retlen
d628 1
a628 1
Perl_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
d630 2
a631 2
    return utf8n_to_uvchr(s, UTF8_MAXBYTES, retlen,
			  ckWARN(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
d635 1
a635 1
=for apidoc A|UV|utf8_to_uvuni|const U8 *s|STRLEN *retlen
d651 1
a651 1
Perl_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
d659 1
a659 1
=for apidoc A|STRLEN|utf8_length|const U8 *s|const U8 *e
d669 1
a669 1
Perl_utf8_length(pTHX_ const U8 *s, const U8 *e)
a670 1
    dVAR;
a671 1
    U8 t = 0;
d680 1
a680 1
	t = UTF8SKIP(s);
d700 1
a700 1
=for apidoc A|IV|utf8_distance|const U8 *a|const U8 *b
d712 1
a712 1
Perl_utf8_distance(pTHX_ const U8 *a, const U8 *b)
d714 36
a749 1
    return (a < b) ? -1 * (IV) utf8_length(a, b) : (IV) utf8_length(b, a);
d766 1
a766 1
Perl_utf8_hop(pTHX_ const U8 *s, I32 off)
a767 1
    PERL_UNUSED_CONTEXT;
a793 2
If you need a copy of the string, see C<bytes_from_utf8>.

d800 1
a800 2
    U8 * const save = s;
    U8 * const send = s + *len;
d802 1
d805 1
a805 1
    while (s < send) {
d811 1
a811 1
            *len = ((STRLEN) -1);
d841 1
a841 1
Perl_bytes_from_utf8(pTHX_ const U8 *s, STRLEN *len, bool *is_utf8)
d847 1
a848 1
    PERL_UNUSED_CONTEXT;
d864 1
a864 1
    *is_utf8 = FALSE;
d866 4
a869 4
    Newx(d, (*len) - count + 1, U8);
    s = start; start = d;
    while (s < send) {
	U8 c = *s++;
d872 1
a872 1
	    c = UTF8_ACCUMULATE(NATIVE_TO_UTF(c), *s++);
d883 1
a883 1
=for apidoc A|U8 *|bytes_to_utf8|const U8 *s|STRLEN *len
d896 1
a896 1
Perl_bytes_to_utf8(pTHX_ const U8 *s, STRLEN *len)
a900 1
    PERL_UNUSED_CONTEXT;
d902 1
a902 1
    Newx(d, (*len) * 2 + 1, U8);
d938 1
a938 1
	Perl_croak(aTHX_ "panic: utf16_to_utf8: odd bytelen %"UVuf, (UV)bytelen);
a945 3
#ifdef EBCDIC
	    *d++ = UNI_TO_NATIVE(uv);
#else
a946 1
#endif
d985 1
a985 1
    U8* const send = s + bytelen;
d987 1
a987 1
	const U8 tmp = s[0];
d1253 2
a1254 3
static bool
S_is_utf8_common(pTHX_ const U8 *const p, SV **swash,
		 const char *const swashname)
a1255 1
    dVAR;
d1258 13
a1270 3
    if (!*swash)
	*swash = swash_init("utf8", swashname, &PL_sv_undef, 1, 0);
    return swash_fetch(*swash, p, TRUE) != 0;
d1274 1
a1274 1
Perl_is_utf8_alnum(pTHX_ const U8 *p)
d1276 12
a1287 5
    dVAR;
    /* NOTE: "IsWord", not "IsAlnum", since Alnum is a true
     * descendant of isalnum(3), in other words, it doesn't
     * contain the '_'. --jhi */
    return is_utf8_common(p, &PL_utf8_alnum, "IsWord");
d1291 1
a1291 1
Perl_is_utf8_alnumc(pTHX_ const U8 *p)
a1292 8
    dVAR;
    return is_utf8_common(p, &PL_utf8_alnumc, "IsAlnumC");
}

bool
Perl_is_utf8_idfirst(pTHX_ const U8 *p) /* The naming is historical. */
{
    dVAR;
d1295 5
a1299 2
    /* is_utf8_idstart would be more logical. */
    return is_utf8_common(p, &PL_utf8_idstart, "IdStart");
d1303 1
a1303 1
Perl_is_utf8_idcont(pTHX_ const U8 *p)
a1304 1
    dVAR;
d1307 5
a1311 1
    return is_utf8_common(p, &PL_utf8_idcont, "IdContinue");
d1315 1
a1315 1
Perl_is_utf8_alpha(pTHX_ const U8 *p)
d1317 5
a1321 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_alpha, "IsAlpha");
d1325 1
a1325 1
Perl_is_utf8_ascii(pTHX_ const U8 *p)
d1327 5
a1331 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_ascii, "IsAscii");
d1335 1
a1335 1
Perl_is_utf8_space(pTHX_ const U8 *p)
d1337 5
a1341 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_space, "IsSpacePerl");
d1345 1
a1345 1
Perl_is_utf8_digit(pTHX_ const U8 *p)
d1347 5
a1351 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_digit, "IsDigit");
d1355 1
a1355 1
Perl_is_utf8_upper(pTHX_ const U8 *p)
d1357 5
a1361 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_upper, "IsUppercase");
d1365 1
a1365 1
Perl_is_utf8_lower(pTHX_ const U8 *p)
d1367 5
a1371 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_lower, "IsLowercase");
d1375 1
a1375 1
Perl_is_utf8_cntrl(pTHX_ const U8 *p)
d1377 5
a1381 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_cntrl, "IsCntrl");
d1385 1
a1385 1
Perl_is_utf8_graph(pTHX_ const U8 *p)
d1387 5
a1391 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_graph, "IsGraph");
d1395 1
a1395 1
Perl_is_utf8_print(pTHX_ const U8 *p)
d1397 5
a1401 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_print, "IsPrint");
d1405 1
a1405 1
Perl_is_utf8_punct(pTHX_ const U8 *p)
d1407 5
a1411 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_punct, "IsPunct");
d1415 1
a1415 1
Perl_is_utf8_xdigit(pTHX_ const U8 *p)
d1417 5
a1421 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_xdigit, "Isxdigit");
d1425 1
a1425 1
Perl_is_utf8_mark(pTHX_ const U8 *p)
d1427 5
a1431 2
    dVAR;
    return is_utf8_common(p, &PL_utf8_mark, "IsM");
d1447 1
a1447 1
and loaded by SWASHNEW, using lib/utf8_heavy.pl.  The special (usually,
d1460 1
a1460 2
Perl_to_utf8_case(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp,
			SV **swashp, const char *normal, const char *special)
a1461 1
    dVAR;
d1479 1
a1479 1
	 HV * const hv = get_hv(special, FALSE);
d1482 1
a1482 1
	 if (hv &&
d1502 1
a1502 1
			     const UV c = utf8_to_uvchr(t, &tlen);
d1527 2
a1528 2
	const UV uv2 = swash_fetch(*swashp, tmpbuf, TRUE);

d1531 2
a1532 1
	      const UV uv3 = UNI_TO_NATIVE(uv2);
d1547 1
a1547 1
=for apidoc A|UV|to_utf8_upper|const U8 *p|U8 *ustrp|STRLEN *lenp
d1560 1
a1560 1
Perl_to_utf8_upper(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
a1561 1
    dVAR;
d1567 1
a1567 1
=for apidoc A|UV|to_utf8_title|const U8 *p|U8 *ustrp|STRLEN *lenp
d1580 1
a1580 1
Perl_to_utf8_title(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
a1581 1
    dVAR;
d1587 1
a1587 1
=for apidoc A|UV|to_utf8_lower|const U8 *p|U8 *ustrp|STRLEN *lenp
d1600 1
a1600 1
Perl_to_utf8_lower(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
a1601 1
    dVAR;
d1607 1
a1607 1
=for apidoc A|UV|to_utf8_fold|const U8 *p|U8 *ustrp|STRLEN *lenp
d1621 1
a1621 1
Perl_to_utf8_fold(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp)
a1622 1
    dVAR;
d1627 2
a1628 6
/* Note:
 * A "swash" is a swatch hash.
 * A "swatch" is a bit vector generated by utf8.c:S_swash_get().
 * C<pkg> is a pointer to a package name for SWASHNEW, should be "utf8".
 * For other parameters, see utf8::SWASHNEW in lib/utf8_heavy.pl.
 */
d1630 1
a1630 1
Perl_swash_init(pTHX_ const char* pkg, const char* name, SV *listsv, I32 minbits, I32 none)
a1631 1
    dVAR;
d1633 1
d1637 1
a1637 1
    HV * const stash = gv_stashpvn(pkg, pkg_len, 0);
a1647 7
	/* It is assumed that callers of this routine are not passing in any
	   user derived data.  */
	/* Need to do this after save_re_context() as it will set PL_tainted to
	   1 while saving $1 etc (see the code after getrx: in Perl_magic_get).
	   Even line to create errsv_save can turn on PL_tainted.  */
	SAVEBOOL(PL_tainted);
	PL_tainted = 0;
d1649 1
a1649 1
			 NULL);
d1664 6
d1681 5
a1685 1
	CopHINTS_set(PL_curcop, PL_hints);
d1690 1
a1690 1
		       SVfARG(retval));
a1701 8
/* Now SWASHGET is recasted into S_swash_get in this file. */

/* Note:
 * Returns the value of property/mapping C<swash> for the first character
 * of the string C<ptr>. If C<do_utf8> is true, the string C<ptr> is
 * assumed to be in utf8. If C<do_utf8> is false, the string C<ptr> is
 * assumed to be in native 8-bit encoding. Caches the swatch in C<swash>.
 */
d1703 1
a1703 1
Perl_swash_fetch(pTHX_ SV *swash, const U8 *ptr, bool do_utf8)
d1705 1
a1705 2
    dVAR;
    HV* const hv = (HV*)SvRV(swash);
d1712 1
a1712 1
    SV *swatch;
d1714 1
a1714 1
    const UV c = NATIVE_TO_ASCII(*ptr);
d1717 3
a1719 3
	tmputf8[0] = (U8)UTF8_EIGHT_BIT_HI(c);
	tmputf8[1] = (U8)UTF8_EIGHT_BIT_LO(c);
	ptr = tmputf8;
d1729 2
a1730 1
    if (klen == 0) {
d1734 5
a1738 4
	needents = UTF_CONTINUATION_MARK;
	off      = NATIVE_TO_UTF(ptr[klen]);
    }
    else {
d1740 3
a1742 3
	needents = (1 << UTF_ACCUMULATION_SHIFT);
	off      = NATIVE_TO_UTF(ptr[klen]) & UTF_CONTINUATION_MASK;
    }
d1764 3
a1766 3
	/* If not cached, generate it via swash_get */
	if (!svp || !SvPOK(*svp)
		 || !(tmps = (const U8*)SvPV_const(*svp, slen))) {
d1773 24
a1796 5
	    swatch = swash_get(swash,
		    /* On EBCDIC & ~(0xA0-1) isn't a useful thing to do */
				(klen) ? (code_point & ~(needents - 1)) : 0,
				needents);

d1798 1
a1798 1
		CopHINTS_set(PL_curcop, PL_hints);
d1800 1
a1800 1
	    svp = hv_store(hv, (const char *)ptr, klen, swatch, 0);
d1802 2
a1803 3
	    if (!svp || !(tmps = (U8*)SvPV(*svp, slen))
		     || (slen << 3) < needents)
		Perl_croak(aTHX_ "panic: swash_fetch got improper swatch");
d1807 1
a1807 2
	assert(klen <= sizeof(PL_last_swash_key));
	PL_last_swash_klen = (U8)klen;
d1829 2
a1830 2
    Perl_croak(aTHX_ "panic: swash_fetch got swatch of unexpected bit width");
    NORETURN_FUNCTION_END;
a1832 313
/* Note:
 * Returns a swatch (a bit vector string) for a code point sequence
 * that starts from the value C<start> and comprises the number C<span>.
 * A C<swash> must be an object created by SWASHNEW (see lib/utf8_heavy.pl).
 * Should be used via swash_fetch, which will cache the swatch in C<swash>.
 */
STATIC SV*
S_swash_get(pTHX_ SV* swash, UV start, UV span)
{
    SV *swatch;
    U8 *l, *lend, *x, *xend, *s;
    STRLEN lcur, xcur, scur;

    HV* const hv = (HV*)SvRV(swash);
    SV** const listsvp = hv_fetchs(hv, "LIST", FALSE);
    SV** const typesvp = hv_fetchs(hv, "TYPE", FALSE);
    SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);
    SV** const nonesvp = hv_fetchs(hv, "NONE", FALSE);
    SV** const extssvp = hv_fetchs(hv, "EXTRAS", FALSE);
    const U8* const typestr = (U8*)SvPV_nolen(*typesvp);
    const int  typeto  = typestr[0] == 'T' && typestr[1] == 'o';
    const STRLEN bits  = SvUV(*bitssvp);
    const STRLEN octets = bits >> 3; /* if bits == 1, then octets == 0 */
    const UV     none  = SvUV(*nonesvp);
    const UV     end   = start + span;

    if (bits != 1 && bits != 8 && bits != 16 && bits != 32) {
	Perl_croak(aTHX_ "panic: swash_get doesn't expect bits %"UVuf,
						 (UV)bits);
    }

    /* create and initialize $swatch */
    scur   = octets ? (span * octets) : (span + 7) / 8;
    swatch = newSV(scur);
    SvPOK_on(swatch);
    s = (U8*)SvPVX(swatch);
    if (octets && none) {
	const U8* const e = s + scur;
	while (s < e) {
	    if (bits == 8)
		*s++ = (U8)(none & 0xff);
	    else if (bits == 16) {
		*s++ = (U8)((none >>  8) & 0xff);
		*s++ = (U8)( none        & 0xff);
	    }
	    else if (bits == 32) {
		*s++ = (U8)((none >> 24) & 0xff);
		*s++ = (U8)((none >> 16) & 0xff);
		*s++ = (U8)((none >>  8) & 0xff);
		*s++ = (U8)( none        & 0xff);
	    }
	}
	*s = '\0';
    }
    else {
	(void)memzero((U8*)s, scur + 1);
    }
    SvCUR_set(swatch, scur);
    s = (U8*)SvPVX(swatch);

    /* read $swash->{LIST} */
    l = (U8*)SvPV(*listsvp, lcur);
    lend = l + lcur;
    while (l < lend) {
	UV min, max, val;
	STRLEN numlen;
	I32 flags = PERL_SCAN_SILENT_ILLDIGIT | PERL_SCAN_DISALLOW_PREFIX;

	U8* const nl = (U8*)memchr(l, '\n', lend - l);

	numlen = lend - l;
	min = grok_hex((char *)l, &numlen, &flags, NULL);
	if (numlen)
	    l += numlen;
	else if (nl) {
	    l = nl + 1; /* 1 is length of "\n" */
	    continue;
	}
	else {
	    l = lend; /* to LIST's end at which \n is not found */
	    break;
	}

	if (isBLANK(*l)) {
	    ++l;
	    flags = PERL_SCAN_SILENT_ILLDIGIT | PERL_SCAN_DISALLOW_PREFIX;
	    numlen = lend - l;
	    max = grok_hex((char *)l, &numlen, &flags, NULL);
	    if (numlen)
		l += numlen;
	    else
		max = min;

	    if (octets) {
		if (isBLANK(*l)) {
		    ++l;
		    flags = PERL_SCAN_SILENT_ILLDIGIT |
			    PERL_SCAN_DISALLOW_PREFIX;
		    numlen = lend - l;
		    val = grok_hex((char *)l, &numlen, &flags, NULL);
		    if (numlen)
			l += numlen;
		    else
			val = 0;
		}
		else {
		    val = 0;
		    if (typeto) {
			Perl_croak(aTHX_ "%s: illegal mapping '%s'",
					 typestr, l);
		    }
		}
	    }
	    else
		val = 0; /* bits == 1, then val should be ignored */
	}
	else {
	    max = min;
	    if (octets) {
		val = 0;
		if (typeto) {
		    Perl_croak(aTHX_ "%s: illegal mapping '%s'", typestr, l);
		}
	    }
	    else
		val = 0; /* bits == 1, then val should be ignored */
	}

	if (nl)
	    l = nl + 1;
	else
	    l = lend;

	if (max < start)
	    continue;

	if (octets) {
	    UV key;
	    if (min < start) {
		if (!none || val < none) {
		    val += start - min;
		}
		min = start;
	    }
	    for (key = min; key <= max; key++) {
		STRLEN offset;
		if (key >= end)
		    goto go_out_list;
		/* offset must be non-negative (start <= min <= key < end) */
		offset = octets * (key - start);
		if (bits == 8)
		    s[offset] = (U8)(val & 0xff);
		else if (bits == 16) {
		    s[offset    ] = (U8)((val >>  8) & 0xff);
		    s[offset + 1] = (U8)( val        & 0xff);
		}
		else if (bits == 32) {
		    s[offset    ] = (U8)((val >> 24) & 0xff);
		    s[offset + 1] = (U8)((val >> 16) & 0xff);
		    s[offset + 2] = (U8)((val >>  8) & 0xff);
		    s[offset + 3] = (U8)( val        & 0xff);
		}

		if (!none || val < none)
		    ++val;
	    }
	}
	else { /* bits == 1, then val should be ignored */
	    UV key;
	    if (min < start)
		min = start;
	    for (key = min; key <= max; key++) {
		const STRLEN offset = (STRLEN)(key - start);
		if (key >= end)
		    goto go_out_list;
		s[offset >> 3] |= 1 << (offset & 7);
	    }
	}
    } /* while */
  go_out_list:

    /* read $swash->{EXTRAS} */
    x = (U8*)SvPV(*extssvp, xcur);
    xend = x + xcur;
    while (x < xend) {
	STRLEN namelen;
	U8 *namestr;
	SV** othersvp;
	HV* otherhv;
	STRLEN otherbits;
	SV **otherbitssvp, *other;
	U8 *s, *o, *nl;
	STRLEN slen, olen;

	const U8 opc = *x++;
	if (opc == '\n')
	    continue;

	nl = (U8*)memchr(x, '\n', xend - x);

	if (opc != '-' && opc != '+' && opc != '!' && opc != '&') {
	    if (nl) {
		x = nl + 1; /* 1 is length of "\n" */
		continue;
	    }
	    else {
		x = xend; /* to EXTRAS' end at which \n is not found */
		break;
	    }
	}

	namestr = x;
	if (nl) {
	    namelen = nl - namestr;
	    x = nl + 1;
	}
	else {
	    namelen = xend - namestr;
	    x = xend;
	}

	othersvp = hv_fetch(hv, (char *)namestr, namelen, FALSE);
	otherhv = (HV*)SvRV(*othersvp);
	otherbitssvp = hv_fetchs(otherhv, "BITS", FALSE);
	otherbits = (STRLEN)SvUV(*otherbitssvp);
	if (bits < otherbits)
	    Perl_croak(aTHX_ "panic: swash_get found swatch size mismatch");

	/* The "other" swatch must be destroyed after. */
	other = swash_get(*othersvp, start, span);
	o = (U8*)SvPV(other, olen);

	if (!olen)
	    Perl_croak(aTHX_ "panic: swash_get got improper swatch");

	s = (U8*)SvPV(swatch, slen);
	if (bits == 1 && otherbits == 1) {
	    if (slen != olen)
		Perl_croak(aTHX_ "panic: swash_get found swatch length mismatch");

	    switch (opc) {
	    case '+':
		while (slen--)
		    *s++ |= *o++;
		break;
	    case '!':
		while (slen--)
		    *s++ |= ~*o++;
		break;
	    case '-':
		while (slen--)
		    *s++ &= ~*o++;
		break;
	    case '&':
		while (slen--)
		    *s++ &= *o++;
		break;
	    default:
		break;
	    }
	}
	else {
	    STRLEN otheroctets = otherbits >> 3;
	    STRLEN offset = 0;
	    U8* const send = s + slen;

	    while (s < send) {
		UV otherval = 0;

		if (otherbits == 1) {
		    otherval = (o[offset >> 3] >> (offset & 7)) & 1;
		    ++offset;
		}
		else {
		    STRLEN vlen = otheroctets;
		    otherval = *o++;
		    while (--vlen) {
			otherval <<= 8;
			otherval |= *o++;
		    }
		}

		if (opc == '+' && otherval)
		    NOOP;   /* replace with otherval */
		else if (opc == '!' && !otherval)
		    otherval = 1;
		else if (opc == '-' && otherval)
		    otherval = 0;
		else if (opc == '&' && !otherval)
		    otherval = 0;
		else {
		    s += octets; /* no replacement */
		    continue;
		}

		if (bits == 8)
		    *s++ = (U8)( otherval & 0xff);
		else if (bits == 16) {
		    *s++ = (U8)((otherval >>  8) & 0xff);
		    *s++ = (U8)( otherval        & 0xff);
		}
		else if (bits == 32) {
		    *s++ = (U8)((otherval >> 24) & 0xff);
		    *s++ = (U8)((otherval >> 16) & 0xff);
		    *s++ = (U8)((otherval >>  8) & 0xff);
		    *s++ = (U8)( otherval        & 0xff);
		}
	    }
	}
	sv_free(other); /* through with it! */
    } /* while */
    return swatch;
}
d1854 1
d1868 1
a1868 2
=for apidoc A|UV|utf8n_to_uvchr|U8 *s|STRLEN curlen|STRLEN *retlen|U32 
flags
d1870 1
a1870 2
Returns the native character value of the first character in the string 
C<s>
d1881 1
d1883 1
a1883 2
Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, 
U32 flags)
d1907 1
a1907 1
Perl_pv_uni_display(pTHX_ SV *dsv, const U8 *spv, STRLEN len, STRLEN pvlim, UV flags)
a1912 1
    SvUTF8_off(dsv);
d1927 1
a1927 1
	     if (flags & UNI_DISPLAY_BACKSLASH) {
d1944 1
a1944 2
		     const char string = ok;
		     sv_catpvn(dsv, &string, 1);
d1949 1
a1949 2
		 const char string = c;
		 sv_catpvn(dsv, &string, 1);
d1957 1
a1957 1
	 sv_catpvs(dsv, "...");
d1973 1
a1973 2
=cut
*/
d1977 1
a1977 1
     return Perl_pv_uni_display(aTHX_ dsv, (const U8*)SvPVX_const(ssv),
a2008 1
     dVAR;
d2011 3
a2013 6
     register const U8 *f1 = NULL;
     register const U8 *f2 = NULL;
     register U8 *e1 = NULL;
     register U8 *q1 = NULL;
     register U8 *e2 = NULL;
     register U8 *q2 = NULL;
a2022 1
     /* assert(e1 || l1); */
a2026 1
     /* assert(e2 || l2); */
a2029 3
     /* This shouldn't happen. However, putting an assert() there makes some
      * tests fail. */
     /* assert((e1 == 0 && f1 == 0) || (e2 == 0 && f2 == 0) || (f1 == 0 && f2 == 0)); */
d2042 1
a2042 1
		    to_utf8_fold(p1, foldbuf1, &foldlen1);
d2052 1
a2052 1
		    to_utf8_fold(p2, foldbuf2, &foldlen2);
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d3 1
a3 1
 *    Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d12 3
a14 5
 * 'What a fix!' said Sam.  'That's the one place in all the lands we've ever
 *  heard of that we don't want to see any closer; and that's the one place
 *  we're trying to get to!  And that's just where we can't get, nohow.'
 *
 *     [p.603 of _The Lord of the Rings_, IV/I: "The Taming of Smagol"]
d18 1
a18 4
 *  as is the custom in the West, if you wish to be answered?'
 *                           --Gandalf, addressing Thoden's door wardens
 *
 *     [p.508 of _The Lord of the Rings_, III/vi: "The King of the Golden Hall"]
a21 2
 *
 *     [p.512 of _The Lord of the Rings_, III/vi: "The King of the Golden Hall"]
d47 1
a47 1
=for apidoc uvuni_to_utf8_flags
a73 2
    PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS;

a201 2
    PERL_ARGS_ASSERT_IS_UTF8_CHAR_SLOW;

d236 1
a236 1
=for apidoc is_utf8_char
d239 3
a241 3
character.  Note that an INVARIANT (i.e. ASCII on non-EBCDIC machines)
character is a valid UTF-8 character.  The actual number of bytes in the UTF-8
character will be returned if it is valid, otherwise 0.
a247 2

    PERL_ARGS_ASSERT_IS_UTF8_CHAR;
d257 1
a257 1
=for apidoc is_utf8_string
a274 1
    PERL_ARGS_ASSERT_IS_UTF8_STRING;
d313 1
a313 1
=for apidoc is_utf8_string_loc
d321 1
a321 1
=for apidoc is_utf8_string_loclen
a339 2

    PERL_ARGS_ASSERT_IS_UTF8_STRING_LOCLEN;
d378 1
a378 1
=for apidoc utf8n_to_uvuni
a412 2
    PERL_ARGS_ASSERT_UTF8N_TO_UVUNI;

d539 1
a539 1
	SV* const sv = newSVpvs_flags("Malformed UTF-8 character ", SVs_TEMP);
d605 1
a605 1
=for apidoc utf8_to_uvchr
a619 2
    PERL_ARGS_ASSERT_UTF8_TO_UVCHR;

d625 1
a625 1
=for apidoc utf8_to_uvuni
d631 1
a631 1
This function should only be used when the returned UV is considered
a642 2
    PERL_ARGS_ASSERT_UTF8_TO_UVUNI;

d649 1
a649 1
=for apidoc utf8_length
d663 1
a663 2

    PERL_ARGS_ASSERT_UTF8_LENGTH;
d672 6
a677 13
	if (!UTF8_IS_INVARIANT(*s))
	    s += UTF8SKIP(s);
	else
	    s++;
	len++;
    }

    if (e != s) {
	len--;
        warn_and_return:
	if (ckWARN_d(WARN_UTF8)) {
	    if (PL_op)
		Perl_warner(aTHX_ packWARN(WARN_UTF8),
d679 4
a682 2
	    else
		Perl_warner(aTHX_ packWARN(WARN_UTF8), unees);
d684 2
d692 1
a692 1
=for apidoc utf8_distance
a705 2
    PERL_ARGS_ASSERT_UTF8_DISTANCE;

d710 1
a710 1
=for apidoc utf8_hop
a724 2
    PERL_ARGS_ASSERT_UTF8_HOP;

d745 1
a745 1
=for apidoc utf8_to_bytes
d747 1
a747 1
Converts a string C<s> of length C<len> from UTF-8 into native byte encoding.
a763 2
    PERL_ARGS_ASSERT_UTF8_TO_BYTES;

d788 1
a788 1
=for apidoc bytes_from_utf8
d790 1
a790 1
Converts a string C<s> of length C<len> from UTF-8 into native byte encoding.
d795 1
a795 2
0 if C<s> is converted or consisted entirely of characters that are invariant
in utf8 (i.e., US-ASCII on non-EBCDIC machines).
a807 2
    PERL_ARGS_ASSERT_BYTES_FROM_UTF8;

d843 1
a843 1
=for apidoc bytes_to_utf8
d845 1
a845 1
Converts a string C<s> of length C<len> from the native encoding into UTF-8.
d849 1
a849 4
A NUL character will be written after the end of the string.

If you want to convert to UTF-8 from encodings other than
the native (Latin1 or EBCDIC),
a860 2

    PERL_ARGS_ASSERT_BYTES_TO_UTF8;
a891 2
    PERL_ARGS_ASSERT_UTF16_TO_UTF8;

a950 3

    PERL_ARGS_ASSERT_UTF16_TO_UTF8_REVERSED;

a1076 2
    PERL_ARGS_ASSERT_TO_UNI_UPPER;

a1083 2
    PERL_ARGS_ASSERT_TO_UNI_TITLE;

a1090 2
    PERL_ARGS_ASSERT_TO_UNI_LOWER;

a1097 2
    PERL_ARGS_ASSERT_TO_UNI_FOLD;

a1222 3

    PERL_ARGS_ASSERT_IS_UTF8_COMMON;

a1233 3

    PERL_ARGS_ASSERT_IS_UTF8_ALNUM;

a1243 3

    PERL_ARGS_ASSERT_IS_UTF8_ALNUMC;

a1250 3

    PERL_ARGS_ASSERT_IS_UTF8_IDFIRST;

a1260 3

    PERL_ARGS_ASSERT_IS_UTF8_IDCONT;

a1269 3

    PERL_ARGS_ASSERT_IS_UTF8_ALPHA;

a1276 3

    PERL_ARGS_ASSERT_IS_UTF8_ASCII;

a1283 3

    PERL_ARGS_ASSERT_IS_UTF8_SPACE;

a1290 3

    PERL_ARGS_ASSERT_IS_UTF8_DIGIT;

a1297 3

    PERL_ARGS_ASSERT_IS_UTF8_UPPER;

a1304 3

    PERL_ARGS_ASSERT_IS_UTF8_LOWER;

a1311 3

    PERL_ARGS_ASSERT_IS_UTF8_CNTRL;

a1318 3

    PERL_ARGS_ASSERT_IS_UTF8_GRAPH;

a1325 3

    PERL_ARGS_ASSERT_IS_UTF8_PRINT;

a1332 3

    PERL_ARGS_ASSERT_IS_UTF8_PUNCT;

a1339 3

    PERL_ARGS_ASSERT_IS_UTF8_XDIGIT;

a1346 3

    PERL_ARGS_ASSERT_IS_UTF8_MARK;

d1351 1
a1351 1
=for apidoc to_utf8_case
d1382 1
a1387 3

    PERL_ARGS_ASSERT_TO_UTF8_CASE;

d1397 1
a1397 1
	 HV * const hv = get_hv(special, 0);
d1464 1
a1464 1
=for apidoc to_utf8_upper
a1479 3

    PERL_ARGS_ASSERT_TO_UTF8_UPPER;

d1485 1
a1485 1
=for apidoc to_utf8_title
a1500 3

    PERL_ARGS_ASSERT_TO_UTF8_TITLE;

d1506 1
a1506 1
=for apidoc to_utf8_lower
a1521 3

    PERL_ARGS_ASSERT_TO_UTF8_LOWER;

d1527 1
a1527 1
=for apidoc to_utf8_fold
a1543 3

    PERL_ARGS_ASSERT_TO_UTF8_FOLD;

a1564 2
    PERL_ARGS_ASSERT_SWASH_INIT;

d1590 2
a1591 2
    mPUSHp(pkg, pkg_len);
    mPUSHp(name, name_len);
d1593 2
a1594 2
    mPUSHi(minbits);
    mPUSHi(none);
d1636 1
a1636 1
    HV *const hv = MUTABLE_HV(SvRV(swash));
a1646 2
    PERL_ARGS_ASSERT_SWASH_FETCH;

d1757 2
a1758 1
    HV *const hv = MUTABLE_HV(SvRV(swash));
a1770 2
    PERL_ARGS_ASSERT_SWASH_GET;

d1967 1
a1967 1
	otherhv = MUTABLE_HV(SvRV(*othersvp));
d2060 1
a2060 1
=for apidoc uvchr_to_utf8
a2081 2
    PERL_ARGS_ASSERT_UVCHR_TO_UTF8;

a2087 2
    PERL_ARGS_ASSERT_UVCHR_TO_UTF8_FLAGS;

d2092 1
a2092 1
=for apidoc utf8n_to_uvchr
a2111 3

    PERL_ARGS_ASSERT_UTF8N_TO_UVCHR;

d2116 1
a2116 1
=for apidoc pv_uni_display
d2138 1
a2138 3
    PERL_ARGS_ASSERT_PV_UNI_DISPLAY;

    sv_setpvs(dsv, "");
a2171 1
		     sv_catpvs(dsv, "\\");
d2192 1
a2192 1
=for apidoc sv_uni_display
a2206 2
    PERL_ARGS_ASSERT_SV_UNI_DISPLAY;

d2212 1
a2212 1
=for apidoc ibcmp_utf8
a2253 2

     PERL_ARGS_ASSERT_IBCMP_UTF8;
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@a53 31
=cut
*/

/*
=for apidoc is_ascii_string

Returns true if first C<len> bytes of the given string are ASCII (i.e. none
of them even raise the question of UTF-8-ness).

See also is_utf8_string(), is_utf8_string_loclen(), and is_utf8_string_loc().

=cut
*/

bool
Perl_is_ascii_string(const U8 *s, STRLEN len)
{
    const U8* const send = s + (len ? len : strlen((const char *)s));
    const U8* x = s;

    PERL_ARGS_ASSERT_IS_ASCII_STRING;

    for (; x < send; ++x) {
	if (!UTF8_IS_INVARIANT(*x))
	    break;
    }

    return x == send;
}

/*
d99 1
a99 1
		      "Unicode non-character 0x%04"UVxf" is illegal for interchange", uv);
d256 1
a256 1
Perl_is_utf8_char(const U8 *s)
d261 1
a268 1

d277 1
a277 1
See also is_ascii_string(), is_utf8_string_loclen(), and is_utf8_string_loc().
d283 1
a283 1
Perl_is_utf8_string(const U8 *s, STRLEN len)
d289 1
d348 1
a348 1
Perl_is_utf8_string_loclen(const U8 *s, STRLEN len, const U8 **ep, STRLEN *el)
d356 1
a427 1
    SV* sv;
d431 1
a431 1
/* This list is a superset of the UTF8_ALLOW_XXX.  BUT it isn't, eg SUPER missing XXX */
d557 1
a557 6
	if (warning == UTF8_WARN_FFFF) {
	    sv = newSVpvs_flags("Unicode non-character ", SVs_TEMP);
	    Perl_sv_catpvf(aTHX_ sv, "0x%04"UVxf" is illegal for interchange", uv);
	}
	else {
	    sv = newSVpvs_flags("Malformed UTF-8 character ", SVs_TEMP);
d559 17
a575 17
	    switch (warning) {
		case 0: /* Intentionally empty. */ break;
		case UTF8_WARN_EMPTY:
		    sv_catpvs(sv, "(empty string)");
		    break;
		case UTF8_WARN_CONTINUATION:
		    Perl_sv_catpvf(aTHX_ sv, "(unexpected continuation byte 0x%02"UVxf", with no preceding start byte)", uv);
		    break;
		case UTF8_WARN_NON_CONTINUATION:
		    if (s == s0)
			Perl_sv_catpvf(aTHX_ sv, "(unexpected non-continuation byte 0x%02"UVxf", immediately after start byte 0x%02"UVxf")",
				   (UV)s[1], startbyte);
		    else {
			const int len = (int)(s-s0);
			Perl_sv_catpvf(aTHX_ sv, "(unexpected non-continuation byte 0x%02"UVxf", %d byte%s after start byte 0x%02"UVxf", expected %d bytes)",
				   (UV)s[1], len, len > 1 ? "s" : "", startbyte, (int)expectlen);
		    }
d577 26
a602 24
		    break;
		case UTF8_WARN_FE_FF:
		    Perl_sv_catpvf(aTHX_ sv, "(byte 0x%02"UVxf")", uv);
		    break;
		case UTF8_WARN_SHORT:
		    Perl_sv_catpvf(aTHX_ sv, "(%d byte%s, need %d, after start byte 0x%02"UVxf")",
				   (int)curlen, curlen == 1 ? "" : "s", (int)expectlen, startbyte);
		    expectlen = curlen;		/* distance for caller to skip */
		    break;
		case UTF8_WARN_OVERFLOW:
		    Perl_sv_catpvf(aTHX_ sv, "(overflow at 0x%"UVxf", byte 0x%02x, after start byte 0x%02"UVxf")",
				   ouv, *s, startbyte);
		    break;
		case UTF8_WARN_SURROGATE:
		    Perl_sv_catpvf(aTHX_ sv, "(UTF-16 surrogate 0x%04"UVxf")", uv);
		    break;
		case UTF8_WARN_LONG:
		    Perl_sv_catpvf(aTHX_ sv, "(%d byte%s, need %d, after start byte 0x%02"UVxf")",
				   (int)expectlen, expectlen == 1 ? "": "s", UNISKIP(uv), startbyte);
		    break;
		default:
		    sv_catpvs(sv, "(unknown reason)");
		    break;
	    }
d705 7
a711 5
	if (PL_op)
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
			     "%s in %s", unees, OP_DESC(PL_op));
	else
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), unees);
d934 6
d961 4
a964 2
	if (uv >= 0xd800 && uv <= 0xdbff) {	/* surrogates */
	    if (p >= pend) {
d966 1
a966 9
	    } else {
		UV low = (p[0] << 8) + p[1];
		p += 2;
		if (low < 0xdc00 || low > 0xdfff)
		    Perl_croak(aTHX_ "Malformed UTF-16 surrogate");
		uv = ((uv - 0xd800) << 10) + (low - 0xdc00) + 0x10000;
	    }
	} else if (uv >= 0xdc00 && uv <= 0xdfff) {
	    Perl_croak(aTHX_ "Malformed UTF-16 surrogate");
a995 4
    if (bytelen & 1)
	Perl_croak(aTHX_ "panic: utf16_to_utf8_reversed: odd bytelen %"UVuf,
		   (UV)bytelen);

d1016 8
d1164 6
d1300 10
a1364 20
Perl_is_utf8_perl_space(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_PERL_SPACE;

    return is_utf8_common(p, &PL_utf8_perl_space, "IsPerlSpace");
}

bool
Perl_is_utf8_perl_word(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_PERL_WORD;

    return is_utf8_common(p, &PL_utf8_perl_word, "IsPerlWord");
}

bool
a1374 10
Perl_is_utf8_posix_digit(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_POSIX_DIGIT;

    return is_utf8_common(p, &PL_utf8_posix_digit, "IsPosixDigit");
}

bool
d1441 1
a1441 1
    return is_utf8_common(p, &PL_utf8_xdigit, "IsXDigit");
a1453 100
bool
Perl_is_utf8_X_begin(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_BEGIN;

    return is_utf8_common(p, &PL_utf8_X_begin, "_X_Begin");
}

bool
Perl_is_utf8_X_extend(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_EXTEND;

    return is_utf8_common(p, &PL_utf8_X_extend, "_X_Extend");
}

bool
Perl_is_utf8_X_prepend(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_PREPEND;

    return is_utf8_common(p, &PL_utf8_X_prepend, "GCB=Prepend");
}

bool
Perl_is_utf8_X_non_hangul(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_NON_HANGUL;

    return is_utf8_common(p, &PL_utf8_X_non_hangul, "HST=Not_Applicable");
}

bool
Perl_is_utf8_X_L(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_L;

    return is_utf8_common(p, &PL_utf8_X_L, "GCB=L");
}

bool
Perl_is_utf8_X_LV(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_LV;

    return is_utf8_common(p, &PL_utf8_X_LV, "GCB=LV");
}

bool
Perl_is_utf8_X_LVT(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_LVT;

    return is_utf8_common(p, &PL_utf8_X_LVT, "GCB=LVT");
}

bool
Perl_is_utf8_X_T(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_T;

    return is_utf8_common(p, &PL_utf8_X_T, "GCB=T");
}

bool
Perl_is_utf8_X_V(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_V;

    return is_utf8_common(p, &PL_utf8_X_V, "GCB=V");
}

bool
Perl_is_utf8_X_LV_LVT_V(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_X_LV_LVT_V;

    return is_utf8_common(p, &PL_utf8_X_LV_LVT_V, "_X_LV_LVT_V");
}

a1497 16
    /* This is the beginnings of a skeleton of code to read the info section
     * that is in all the swashes in case we ever want to do that, so one can
     * read things whose maps aren't code points, and whose default if missing
     * is not to the code point itself.  This was just to see if it actually
     * worked.  Details on what the possibilities are are in perluniprops.pod
	HV * const hv = get_hv("utf8::SwashInfo", 0);
	if (hv) {
	 SV **svp;
	 svp = hv_fetch(hv, (const char*)normal, strlen(normal), FALSE);
	     const char *s;

	      HV * const this_hash = SvRV(*svp);
		svp = hv_fetch(this_hash, "type", strlen("type"), FALSE);
	      s = SvPV_const(*svp, len);
	}
    }*/
d1560 1
a1560 2
    if (!len) /* Neither: just copy.  In other words, there was no mapping
		 defined, which means that the code point maps to itself */
d1687 2
a1688 1
    SAVEHINTS();
d1775 1
a1775 1
     * then the "swatch" is a vec() for all the chars which start
d1783 1
a1783 1
      /* If char is invariant then swatch is for all the invariant chars
d2455 1
a2455 2
     match = (n1 == 0 && n2 == 0    /* Must not match partial char; Bug #72998 */
	     && (f1 == 0 || p1 == f1) && (f2 == 0 || p2 == f2));
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d16 1
a16 1
 *     [p.603 of _The Lord of the Rings_, IV/I: "The Taming of Sméagol"]
d21 1
a21 1
 *                           --Gandalf, addressing Théoden's door wardens
d36 1
a36 1
/* Separate prototypes needed because in ASCII systems these are
d45 1
a45 1
/*
d60 2
a61 6
Returns true if the first C<len> bytes of the string C<s> are the same whether
or not the string is encoded in UTF-8 (or UTF-EBCDIC on EBCDIC machines).  That
is, if they are invariant.  On ASCII-ish machines, only ASCII characters
fit this definition, hence the function's name.

If C<len> is 0, it will be calculated using C<strlen(s)>.  
d63 1
a63 1
See also L</is_utf8_string>(), L</is_utf8_string_loclen>(), and L</is_utf8_string_loc>().
d87 2
a88 2
Adds the UTF-8 representation of the code point C<uv> to the end
of the string C<d>; C<d> should have at least C<UTF8_MAXBYTES+1> free
d102 1
a102 1
This is the recommended Unicode-aware way of saying
a105 22
This function will convert to UTF-8 (and not warn) even code points that aren't
legal Unicode or are problematic, unless C<flags> contains one or more of the
following flags:

If C<uv> is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set,
the function will raise a warning, provided UTF8 warnings are enabled.  If instead
UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL.
If both flags are set, the function will both warn and return NULL.

The UNICODE_WARN_NONCHAR and UNICODE_DISALLOW_NONCHAR flags correspondingly
affect how the function handles a Unicode non-character.  And, likewise for the
UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags, and code points that are
above the Unicode maximum of 0x10FFFF.  Code points above 0x7FFF_FFFF (which are
even less portable) can be warned and/or disallowed even if other above-Unicode
code points are accepted by the UNICODE_WARN_FE_FF and UNICODE_DISALLOW_FE_FF
flags.

And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the
above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four
DISALLOW flags.


d114 17
a130 33
    if (ckWARN4_d(WARN_UTF8, WARN_SURROGATE, WARN_NON_UNICODE, WARN_NONCHAR)) {
	if (UNICODE_IS_SURROGATE(uv)) {
	    if (flags & UNICODE_WARN_SURROGATE) {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_SURROGATE),
					    "UTF-16 surrogate U+%04"UVXf, uv);
	    }
	    if (flags & UNICODE_DISALLOW_SURROGATE) {
		return NULL;
	    }
	}
	else if (UNICODE_IS_SUPER(uv)) {
	    if (flags & UNICODE_WARN_SUPER
		|| (UNICODE_IS_FE_FF(uv) && (flags & UNICODE_WARN_FE_FF)))
	    {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_NON_UNICODE),
			  "Code point 0x%04"UVXf" is not Unicode, may not be portable", uv);
	    }
	    if (flags & UNICODE_DISALLOW_SUPER
		|| (UNICODE_IS_FE_FF(uv) && (flags & UNICODE_DISALLOW_FE_FF)))
	    {
		return NULL;
	    }
	}
	else if (UNICODE_IS_NONCHAR(uv)) {
	    if (flags & UNICODE_WARN_NONCHAR) {
		Perl_ck_warner_d(aTHX_ packWARN(WARN_NONCHAR),
		 "Unicode non-character U+%04"UVXf" is illegal for open interchange",
		 uv);
	    }
	    if (flags & UNICODE_DISALLOW_NONCHAR) {
		return NULL;
	    }
	}
d219 1
a219 1
Tests if the first C<len> bytes of string C<s> form a valid UTF-8
d221 1
a221 1
UTF-8 character.  The number of bytes in the UTF-8 character
d238 3
a240 3
    dTHX;   /* The function called below requires thread context */

    STRLEN actual_len;
d244 2
a245 1
    utf8n_to_uvuni(s, len, &actual_len, UTF8_CHECK_ONLY);
d247 2
a248 2
    return (actual_len == (STRLEN) -1) ? 0 : actual_len;
}
d250 2
a251 2
/*
=for apidoc is_utf8_char_buf
d253 17
a269 17
Returns the number of bytes that comprise the first UTF-8 encoded character in
buffer C<buf>.  C<buf_end> should point to one position beyond the end of the
buffer.  0 is returned if C<buf> does not point to a complete, valid UTF-8
encoded character.

Note that an INVARIANT character (i.e. ASCII on non-EBCDIC
machines) is a valid UTF-8 character.

=cut */

STRLEN
Perl_is_utf8_char_buf(const U8 *buf, const U8* buf_end)
{

    STRLEN len;

    PERL_ARGS_ASSERT_IS_UTF8_CHAR_BUF;
d271 1
a271 1
    if (buf_end <= buf) {
a272 1
    }
d274 1
a274 10
    len = buf_end - buf;
    if (len > UTF8SKIP(buf)) {
	len = UTF8SKIP(buf);
    }

#ifdef IS_UTF8_CHAR
    if (IS_UTF8_CHAR_FAST(len))
        return IS_UTF8_CHAR(buf, len) ? len : 0;
#endif /* #ifdef IS_UTF8_CHAR */
    return is_utf8_char_slow(buf, len);
a279 2
DEPRECATED!

a284 4
This function is deprecated due to the possibility that malformed input could
cause reading beyond the end of the input buffer.  Use L</is_utf8_char_buf>
instead.

a285 1

d289 2
d292 5
a296 3

    /* Assumes we have enough space, which is why this is deprecated */
    return is_utf8_char_buf(s, s + UTF8SKIP(s));
d303 4
a306 5
Returns true if the first C<len> bytes of string C<s> form a valid
UTF-8 string, false otherwise.  If C<len> is 0, it will be calculated
using C<strlen(s)> (which means if you use this option, that C<s> has to have a
terminating NUL byte).  Note that all characters being ASCII constitute 'a
valid UTF-8 string'.
d308 1
a308 1
See also L</is_ascii_string>(), L</is_utf8_string_loclen>(), and L</is_utf8_string_loc>().
d322 1
d324 2
a325 3
	 if (UTF8_IS_INVARIANT(*x)) {
	    x++;
	 }
d327 1
a327 1
	     return FALSE;
d330 2
a331 7
	     const STRLEN c = UTF8SKIP(x);
	     const U8* const next_char_ptr = x + c;

	     if (next_char_ptr > send) {
		 return FALSE;
	     }

d334 1
a334 1
		     return FALSE;
d336 7
a342 4
	     else if (! is_utf8_char_slow(x, c)) {
		 return FALSE;
	     }
	     x = next_char_ptr;
d344 1
d347 4
d359 2
a360 2
Like L</is_utf8_string> but stores the location of the failure (in the
case of "utf8ness failure") or the location C<s>+C<len> (in the case of
d363 1
a363 1
See also L</is_utf8_string_loclen>() and L</is_utf8_string>().
d367 2
a368 2
Like L</is_utf8_string>() but stores the location of the failure (in the
case of "utf8ness failure") or the location C<s>+C<len> (in the case of
d372 1
a372 1
See also L</is_utf8_string_loc>() and L</is_utf8_string>().
a387 2
	 const U8* next_char_ptr;

d390 1
a390 1
	     next_char_ptr = x + 1;
d395 1
a396 4
	     next_char_ptr = c + x;
	     if (next_char_ptr > send) {
		 goto out;
	     }
d402 3
d408 1
a408 1
         x = next_char_ptr;
d426 14
a439 62
Returns the code point value of the first character in the string C<s>,
which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than
C<curlen> bytes; C<*retlen> (if C<retlen> isn't NULL) will be set to
the length, in bytes, of that character.

The value of C<flags> determines the behavior when C<s> does not point to a
well-formed UTF-8 character.  If C<flags> is 0, when a malformation is found,
zero is returned and C<*retlen> is set so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
Also, if UTF-8 warnings haven't been lexically disabled, a warning is raised.

Various ALLOW flags can be set in C<flags> to allow (and not warn on)
individual types of malformations, such as the sequence being overlong (that
is, when there is a shorter sequence that can express the same code point;
overlong sequences are expressly forbidden in the UTF-8 standard due to
potential security issues).  Another malformation example is the first byte of
a character not being a legal first byte.  See F<utf8.h> for the list of such
flags.  For allowed 0 length strings, this function returns 0; for allowed
overlong sequences, the computed code point is returned; for all other allowed
malformations, the Unicode REPLACEMENT CHARACTER is returned, as these have no
determinable reasonable value.

The UTF8_CHECK_ONLY flag overrides the behavior when a non-allowed (by other
flags) malformation is found.  If this flag is set, the routine assumes that
the caller will raise a warning, and this function will silently just set
C<retlen> to C<-1> and return zero.

Certain code points are considered problematic.  These are Unicode surrogates,
Unicode non-characters, and code points above the Unicode maximum of 0x10FFFF.
By default these are considered regular code points, but certain situations
warrant special handling for them.  If C<flags> contains
UTF8_DISALLOW_ILLEGAL_INTERCHANGE, all three classes are treated as
malformations and handled as such.  The flags UTF8_DISALLOW_SURROGATE,
UTF8_DISALLOW_NONCHAR, and UTF8_DISALLOW_SUPER (meaning above the legal Unicode
maximum) can be set to disallow these categories individually.

The flags UTF8_WARN_ILLEGAL_INTERCHANGE, UTF8_WARN_SURROGATE,
UTF8_WARN_NONCHAR, and UTF8_WARN_SUPER will cause warning messages to be raised
for their respective categories, but otherwise the code points are considered
valid (not malformations).  To get a category to both be treated as a
malformation and raise a warning, specify both the WARN and DISALLOW flags.
(But note that warnings are not raised if lexically disabled nor if
UTF8_CHECK_ONLY is also specified.)

Very large code points (above 0x7FFF_FFFF) are considered more problematic than
the others that are above the Unicode legal maximum.  There are several
reasons: they requre at least 32 bits to represent them on ASCII platforms, are
not representable at all on EBCDIC platforms, and the original UTF-8
specification never went above this number (the current 0x10FFFF limit was
imposed later).  (The smaller ones, those that fit into 32 bits, are
representable by a UV on ASCII platforms, but not by an IV, which means that
the number of operations that can be performed on them is quite restricted.)
The UTF-8 encoding on ASCII platforms for these large code points begins with a
byte containing 0xFE or 0xFF.  The UTF8_DISALLOW_FE_FF flag will cause them to
be treated as malformations, while allowing smaller above-Unicode code points.
(Of course UTF8_DISALLOW_SUPER will treat all above-Unicode code points,
including these, as malformations.) Similarly, UTF8_WARN_FE_FF acts just like
the other WARN flags, but applies just to these code points.

All other code points corresponding to Unicode characters, including private
use and those yet to be assigned, are never considered malformed and never
warn.
d441 1
a441 1
Most code should use L</utf8_to_uvchr_buf>() rather than call this directly.
d451 7
a457 13
    U8 overflow_byte = '\0';	/* Save byte in case of overflow */
    U8 * send;
    UV uv = *s;
    STRLEN expectlen;
    SV* sv = NULL;
    UV outlier_ret = 0;	/* return value when input is in error or problematic
			 */
    UV pack_warn = 0;	/* Save result of packWARN() for later */
    bool unexpected_non_continuation = FALSE;
    bool overflowed = FALSE;
    bool do_overlong_test = TRUE;   /* May have to skip this test */

    const char* const malformed_text = "Malformed UTF-8 character";
d461 1
a461 25
    /* The order of malformation tests here is important.  We should consume as
     * few bytes as possible in order to not skip any valid character.  This is
     * required by the Unicode Standard (section 3.9 of Unicode 6.0); see also
     * http://unicode.org/reports/tr36 for more discussion as to why.  For
     * example, once we've done a UTF8SKIP, we can tell the expected number of
     * bytes, and could fail right off the bat if the input parameters indicate
     * that there are too few available.  But it could be that just that first
     * byte is garbled, and the intended character occupies fewer bytes.  If we
     * blindly assumed that the first byte is correct, and skipped based on
     * that number, we could skip over a valid input character.  So instead, we
     * always examine the sequence byte-by-byte.
     *
     * We also should not consume too few bytes, otherwise someone could inject
     * things.  For example, an input could be deliberately designed to
     * overflow, and if this code bailed out immediately upon discovering that,
     * returning to the caller *retlen pointing to the very next byte (one
     * which is actually part of of the overflowing sequence), that could look
     * legitimate to the caller, which could discard the initial partial
     * sequence and process the rest, inappropriately */

    /* Zero length strings, if allowed, of necessity are zero */
    if (curlen == 0) {
	if (retlen) {
	    *retlen = 0;
	}
d463 13
a475 6
	if (flags & UTF8_ALLOW_EMPTY) {
	    return 0;
	}
	if (! (flags & UTF8_CHECK_ONLY)) {
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (empty string)", malformed_text));
	}
a478 11
    expectlen = UTF8SKIP(s);

    /* A well-formed UTF-8 character, as the vast majority of calls to this
     * function will be for, has this expected length.  For efficiency, set
     * things up here to return it.  It will be overriden only in those rare
     * cases where a malformation is found */
    if (retlen) {
	*retlen = expectlen;
    }

    /* An invariant is trivially well-formed */
d480 2
d485 5
a489 8
    /* A continuation character can't start a valid sequence */
    if (UTF8_IS_CONTINUATION(uv)) {
	if (flags & UTF8_ALLOW_CONTINUATION) {
	    if (retlen) {
		*retlen = 1;
	    }
	    return UNICODE_REPLACEMENT;
	}
d491 3
a493 4
	if (! (flags & UTF8_CHECK_ONLY)) {
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (unexpected continuation byte 0x%02x, with no preceding start byte)", malformed_text, *s0));
	}
	curlen = 1;
d499 6
d507 11
a517 27
    /* Here is not a continuation byte, nor an invariant.  The only thing left
     * is a start byte (possibly for an overlong) */

    /* Remove the leading bits that indicate the number of bytes in the
     * character's whole UTF-8 sequence, leaving just the bits that are part of
     * the value */
    uv &= UTF_START_MASK(expectlen);

    /* Now, loop through the remaining bytes in the character's sequence,
     * accumulating each into the working value as we go.  Be sure to not look
     * past the end of the input string */
    send =  (U8*) s0 + ((expectlen <= curlen) ? expectlen : curlen);

    for (s = s0 + 1; s < send; s++) {
	if (UTF8_IS_CONTINUATION(*s)) {
#ifndef EBCDIC	/* Can't overflow in EBCDIC */
	    if (uv & UTF_ACCUMULATION_OVERFLOW_MASK) {

		/* The original implementors viewed this malformation as more
		 * serious than the others (though I, khw, don't understand
		 * why, since other malformations also give very very wrong
		 * results), so there is no way to turn off checking for it.
		 * Set a flag, but keep going in the loop, so that we absorb
		 * the rest of the bytes that comprise the character. */
		overflowed = TRUE;
		overflow_byte = *s; /* Save for warning message's use */
	    }
a518 10
	    uv = UTF8_ACCUMULATE(uv, *s);
	}
	else {
	    /* Here, found a non-continuation before processing all expected
	     * bytes.  This byte begins a new character, so quit, even if
	     * allowing this malformation. */
	    unexpected_non_continuation = TRUE;
	    break;
	}
    } /* End of loop through the character's bytes */
d520 2
a521 2
    /* Save how many bytes were actually in the character */
    curlen = s - s0;
d523 1
a523 30
    /* The loop above finds two types of malformations: non-continuation and/or
     * overflow.  The non-continuation malformation is really a too-short
     * malformation, as it means that the current character ended before it was
     * expected to (being terminated prematurely by the beginning of the next
     * character, whereas in the too-short malformation there just are too few
     * bytes available to hold the character.  In both cases, the check below
     * that we have found the expected number of bytes would fail if executed.)
     * Thus the non-continuation malformation is really unnecessary, being a
     * subset of the too-short malformation.  But there may be existing
     * applications that are expecting the non-continuation type, so we retain
     * it, and return it in preference to the too-short malformation.  (If this
     * code were being written from scratch, the two types might be collapsed
     * into one.)  I, khw, am also giving priority to returning the
     * non-continuation and too-short malformations over overflow when multiple
     * ones are present.  I don't know of any real reason to prefer one over
     * the other, except that it seems to me that multiple-byte errors trumps
     * errors from a single byte */
    if (unexpected_non_continuation) {
	if (!(flags & UTF8_ALLOW_NON_CONTINUATION)) {
	    if (! (flags & UTF8_CHECK_ONLY)) {
		if (curlen == 1) {
		    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (unexpected non-continuation byte 0x%02x, immediately after start byte 0x%02x)", malformed_text, *s, *s0));
		}
		else {
		    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (unexpected non-continuation byte 0x%02x, %d bytes after start byte 0x%02x, expected %d bytes)", malformed_text, *s, (int) curlen, *s0, (int)expectlen));
		}
	    }
	    goto malformed;
	}
	uv = UNICODE_REPLACEMENT;
d525 4
a528 6
	/* Skip testing for overlongs, as the REPLACEMENT may not be the same
	 * as what the original expectations were. */
	do_overlong_test = FALSE;
	if (retlen) {
	    *retlen = curlen;
	}
d530 10
a539 5
    else if (curlen < expectlen) {
	if (! (flags & UTF8_ALLOW_SHORT)) {
	    if (! (flags & UTF8_CHECK_ONLY)) {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (%d byte%s, need %d, after start byte 0x%02x)", malformed_text, (int)curlen, curlen == 1 ? "" : "s", (int)expectlen, *s0));
	    }
d542 15
a556 4
	uv = UNICODE_REPLACEMENT;
	do_overlong_test = FALSE;
	if (retlen) {
	    *retlen = curlen;
d558 2
d562 7
a568 23
#ifndef EBCDIC	/* EBCDIC allows FE, FF, can't overflow */
    if ((*s0 & 0xFE) == 0xFE	/* matches both FE, FF */
	&& (flags & (UTF8_WARN_FE_FF|UTF8_DISALLOW_FE_FF)))
    {
	/* By adding UTF8_CHECK_ONLY to the test, we avoid unnecessary
	 * generation of the sv, since no warnings are raised under CHECK */
	if ((flags & (UTF8_WARN_FE_FF|UTF8_CHECK_ONLY)) == UTF8_WARN_FE_FF
	    && ckWARN_d(WARN_UTF8))
	{
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s Code point beginning with byte 0x%02X is not Unicode, and not portable", malformed_text, *s0));
	    pack_warn = packWARN(WARN_UTF8);
	}
	if (flags & UTF8_DISALLOW_FE_FF) {
	    goto malformed;
	}
    }
    if (overflowed) {

	/* If the first byte is FF, it will overflow a 32-bit word.  If the
	 * first byte is FE, it will overflow a signed 32-bit word.  The
	 * above preserves backward compatibility, since its message was used
	 * in earlier versions of this code in preference to overflow */
	sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (overflow at byte 0x%02x, after start byte 0x%02x)", malformed_text, overflow_byte, *s0));
d570 3
a572 14
    }
#endif

    if (do_overlong_test
	&& expectlen > (STRLEN)UNISKIP(uv)
	&& ! (flags & UTF8_ALLOW_LONG))
    {
	/* The overlong malformation has lower precedence than the others.
	 * Note that if this malformation is allowed, we return the actual
	 * value, instead of the replacement character.  This is because this
	 * value is actually well-defined. */
	if (! (flags & UTF8_CHECK_ONLY)) {
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (%d byte%s, need %d, after start byte 0x%02x)", malformed_text, (int)expectlen, expectlen == 1 ? "": "s", UNISKIP(uv), *s0));
	}
a575 49
    /* Here, the input is considered to be well-formed , but could be a
     * problematic code point that is not allowed by the input parameters. */
    if (uv >= UNICODE_SURROGATE_FIRST /* isn't problematic if < this */
	&& (flags & (UTF8_DISALLOW_ILLEGAL_INTERCHANGE
		     |UTF8_WARN_ILLEGAL_INTERCHANGE)))
    {
	if (UNICODE_IS_SURROGATE(uv)) {
	    if ((flags & (UTF8_WARN_SURROGATE|UTF8_CHECK_ONLY)) == UTF8_WARN_SURROGATE
		&& ckWARN2_d(WARN_UTF8, WARN_SURROGATE))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "UTF-16 surrogate U+%04"UVXf"", uv));
		pack_warn = packWARN2(WARN_UTF8, WARN_SURROGATE);
	    }
	    if (flags & UTF8_DISALLOW_SURROGATE) {
		goto disallowed;
	    }
	}
	else if (UNICODE_IS_NONCHAR(uv)) {
	    if ((flags & (UTF8_WARN_NONCHAR|UTF8_CHECK_ONLY)) == UTF8_WARN_NONCHAR
		&& ckWARN2_d(WARN_UTF8, WARN_NONCHAR))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "Unicode non-character U+%04"UVXf" is illegal for open interchange", uv));
		pack_warn = packWARN2(WARN_UTF8, WARN_NONCHAR);
	    }
	    if (flags & UTF8_DISALLOW_NONCHAR) {
		goto disallowed;
	    }
	}
	else if ((uv > PERL_UNICODE_MAX)) {
	    if ((flags & (UTF8_WARN_SUPER|UTF8_CHECK_ONLY)) == UTF8_WARN_SUPER
		&& ckWARN2_d(WARN_UTF8, WARN_NON_UNICODE))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "Code point 0x%04"UVXf" is not Unicode, may not be portable", uv));
		pack_warn = packWARN2(WARN_UTF8, WARN_NON_UNICODE);
	    }
	    if (flags & UTF8_DISALLOW_SUPER) {
		goto disallowed;
	    }
	}

	if (sv) {
	    outlier_ret = uv;
	    goto do_warn;
	}

	/* Here, this is not considered a malformed character, so drop through
	 * to return it */
    }

a577 26
    /* There are three cases which get to beyond this point.  In all 3 cases:
     * <sv>	    if not null points to a string to print as a warning.
     * <curlen>	    is what <*retlen> should be set to if UTF8_CHECK_ONLY isn't
     *		    set.
     * <outlier_ret> is what return value to use if UTF8_CHECK_ONLY isn't set.
     *		    This is done by initializing it to 0, and changing it only
     *		    for case 1).
     * The 3 cases are:
     * 1)   The input is valid but problematic, and to be warned about.  The
     *	    return value is the resultant code point; <*retlen> is set to
     *	    <curlen>, the number of bytes that comprise the code point.
     *	    <pack_warn> contains the result of packWARN() for the warning
     *	    types.  The entry point for this case is the label <do_warn>;
     * 2)   The input is a valid code point but disallowed by the parameters to
     *	    this function.  The return value is 0.  If UTF8_CHECK_ONLY is set,
     *	    <*relen> is -1; otherwise it is <curlen>, the number of bytes that
     *	    comprise the code point.  <pack_warn> contains the result of
     *	    packWARN() for the warning types.  The entry point for this case is
     *	    the label <disallowed>.
     * 3)   The input is malformed.  The return value is 0.  If UTF8_CHECK_ONLY
     *	    is set, <*relen> is -1; otherwise it is <curlen>, the number of
     *	    bytes that comprise the malformation.  All such malformations are
     *	    assumed to be warning type <utf8>.  The entry point for this case
     *	    is the label <malformed>.
     */

a579 6
    if (sv && ckWARN_d(WARN_UTF8)) {
	pack_warn = packWARN(WARN_UTF8);
    }

disallowed:

d586 7
a592 1
do_warn:
d594 17
a610 3
    if (pack_warn) {	/* <pack_warn> was initialized to 0, and changed only
			   if warnings are to be raised. */
	const char * const string = SvPVX_const(sv);
d612 35
a646 8
	if (PL_op)
	    Perl_warner(aTHX_ pack_warn, "%s in %s", string,  OP_DESC(PL_op));
	else
	    Perl_warner(aTHX_ pack_warn, "%s", string);
    }

    if (retlen) {
	*retlen = curlen;
d649 2
a650 21
    return outlier_ret;
}

/*
=for apidoc utf8_to_uvchr_buf

Returns the native code point of the first character in the string C<s> which
is assumed to be in UTF-8 encoding; C<send> points to 1 beyond the end of C<s>.
C<*retlen> will be set to the length, in bytes, of that character.

If C<s> does not point to a well-formed UTF-8 character and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvuni> for details on when the REPLACEMENT CHARACTER is returned.

=cut
*/

d652 1
a652 22
UV
Perl_utf8_to_uvchr_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVCHR_BUF;

    assert(s < send);

    return utf8n_to_uvchr(s, send - s, retlen,
			  ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
}

/* Like L</utf8_to_uvchr_buf>(), but should only be called when it is known that
 * there are no malformations in the input UTF-8 string C<s>.  Currently, some
 * malformations are checked for, but this checking likely will be removed in
 * the future */

UV
Perl_valid_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_VALID_UTF8_TO_UVCHR;

    return utf8_to_uvchr_buf(s, s + UTF8_MAXBYTES, retlen);
d658 1
a658 3
DEPRECATED!

Returns the native code point of the first character in the string C<s>
d662 2
a663 11
Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is why this function is deprecated.  Use L</utf8_to_uvchr_buf> instead.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvuni> for details on when the REPLACEMENT CHARACTER is returned.
d673 2
a674 47
    return valid_utf8_to_uvchr(s, retlen);
}

/*
=for apidoc utf8_to_uvuni_buf

Returns the Unicode code point of the first character in the string C<s> which
is assumed to be in UTF-8 encoding; C<send> points to 1 beyond the end of C<s>.
C<retlen> will be set to the length, in bytes, of that character.

This function should only be used when the returned UV is considered
an index into the Unicode semantic tables (e.g. swashes).

If C<s> does not point to a well-formed UTF-8 character and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> isn't
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvuni> for details on when the REPLACEMENT CHARACTER is returned.

=cut
*/

UV
Perl_utf8_to_uvuni_buf(pTHX_ const U8 *s, const U8 *send, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_UTF8_TO_UVUNI_BUF;

    assert(send > s);

    /* Call the low level routine asking for checks */
    return Perl_utf8n_to_uvuni(aTHX_ s, send -s, retlen,
			       ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY);
}

/* Like L</utf8_to_uvuni_buf>(), but should only be called when it is known that
 * there are no malformations in the input UTF-8 string C<s>.  Currently, some
 * malformations are checked for, but this checking likely will be removed in
 * the future */

UV
Perl_valid_utf8_to_uvuni(pTHX_ const U8 *s, STRLEN *retlen)
{
    PERL_ARGS_ASSERT_VALID_UTF8_TO_UVUNI;

    return utf8_to_uvuni_buf(s, s + UTF8_MAXBYTES, retlen);
a679 2
DEPRECATED!

d687 2
a688 11
Some, but not all, UTF-8 malformations are detected, and in fact, some
malformed input could cause reading beyond the end of the input buffer, which
is why this function is deprecated.  Use L</utf8_to_uvuni_buf> instead.

If C<s> points to one of the detected malformations, and UTF8 warnings are
enabled, zero is returned and C<*retlen> is set (if C<retlen> doesn't point to
NULL) to -1.  If those warnings are off, the computed value if well-defined (or
the Unicode REPLACEMENT CHARACTER, if not) is silently returned, and C<*retlen>
is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is the
next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvuni> for details on when the REPLACEMENT CHARACTER is returned.
d698 3
a700 1
    return valid_utf8_to_uvuni(s, retlen);
d742 1
a742 1
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), "%s", unees);
a805 68
=for apidoc bytes_cmp_utf8

Compares the sequence of characters (stored as octets) in C<b>, C<blen> with the
sequence of characters (stored as UTF-8) in C<u>, C<ulen>. Returns 0 if they are
equal, -1 or -2 if the first string is less than the second string, +1 or +2
if the first string is greater than the second string.

-1 or +1 is returned if the shorter string was identical to the start of the
longer string. -2 or +2 is returned if the was a difference between characters
within the strings.

=cut
*/

int
Perl_bytes_cmp_utf8(pTHX_ const U8 *b, STRLEN blen, const U8 *u, STRLEN ulen)
{
    const U8 *const bend = b + blen;
    const U8 *const uend = u + ulen;

    PERL_ARGS_ASSERT_BYTES_CMP_UTF8;

    PERL_UNUSED_CONTEXT;

    while (b < bend && u < uend) {
        U8 c = *u++;
	if (!UTF8_IS_INVARIANT(c)) {
	    if (UTF8_IS_DOWNGRADEABLE_START(c)) {
		if (u < uend) {
		    U8 c1 = *u++;
		    if (UTF8_IS_CONTINUATION(c1)) {
			c = UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(c, c1));
		    } else {
			Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
					 "Malformed UTF-8 character "
					 "(unexpected non-continuation byte 0x%02x"
					 ", immediately after start byte 0x%02x)"
					 /* Dear diag.t, it's in the pod.  */
					 "%s%s", c1, c,
					 PL_op ? " in " : "",
					 PL_op ? OP_DESC(PL_op) : "");
			return -2;
		    }
		} else {
		    if (PL_op)
			Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
					 "%s in %s", unees, OP_DESC(PL_op));
		    else
			Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8), "%s", unees);
		    return -2; /* Really want to return undef :-)  */
		}
	    } else {
		return -2;
	    }
	}
	if (*b != c) {
	    return *b < c ? -2 : +2;
	}
	++b;
    }

    if (b == bend && u == uend)
	return 0;

    return b < bend ? +1 : -1;
}

/*
d809 2
a810 2
Unlike L</bytes_to_utf8>, this over-writes the original string, and
updates C<len> to contain the new length.
d813 1
a813 1
If you need a copy of the string, see L</bytes_from_utf8>.
d842 1
a842 1
        *d++ = (U8)utf8_to_uvchr_buf(s, send, &ulen);
d854 1
a854 1
Unlike L</utf8_to_bytes> but like L</bytes_to_utf8>, returns a pointer to
d898 2
a899 1
	    c = UNI_TO_NATIVE(TWO_BYTE_UTF8_TO_UNI(c, *s++));
d911 1
a911 2
Converts a string C<s> of length C<len> bytes from the native encoding into
UTF-8.
d913 1
a913 1
reflect the new length in bytes.
d919 1
a919 1
see L</sv_recode_to_utf8>().
a923 3
/* This logic is duplicated in sv_catpvn_flags, so any bug fixes will
   likewise need duplication. */

d1040 1
a1040 3
/* for now these are all defined (inefficiently) in terms of the utf8 versions.
 * Note that the macros in handy.h that call these short-circuit calling them
 * for Latin-1 range inputs */
d1069 3
a1071 1
    return isASCII(c);
d1109 3
a1111 1
    return isCNTRL_L1(c);
d1147 1
a1147 1
Perl__to_upper_title_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp, const char S_or_s)
d1149 1
a1149 40
    /* We have the latin1-range values compiled into the core, so just use
     * those, converting the result to utf8.  The only difference between upper
     * and title case in this range is that LATIN_SMALL_LETTER_SHARP_S is
     * either "SS" or "Ss".  Which one to use is passed into the routine in
     * 'S_or_s' to avoid a test */

    UV converted = toUPPER_LATIN1_MOD(c);

    PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1;

    assert(S_or_s == 'S' || S_or_s == 's');

    if (UNI_IS_INVARIANT(converted)) { /* No difference between the two for
					  characters in this range */
	*p = (U8) converted;
	*lenp = 1;
	return converted;
    }

    /* toUPPER_LATIN1_MOD gives the correct results except for three outliers,
     * which it maps to one of them, so as to only have to have one check for
     * it in the main case */
    if (UNLIKELY(converted == LATIN_SMALL_LETTER_Y_WITH_DIAERESIS)) {
	switch (c) {
	    case LATIN_SMALL_LETTER_Y_WITH_DIAERESIS:
		converted = LATIN_CAPITAL_LETTER_Y_WITH_DIAERESIS;
		break;
	    case MICRO_SIGN:
		converted = GREEK_CAPITAL_LETTER_MU;
		break;
	    case LATIN_SMALL_LETTER_SHARP_S:
		*(p)++ = 'S';
		*p = S_or_s;
		*lenp = 2;
		return 'S';
	    default:
		Perl_croak(aTHX_ "panic: to_upper_title_latin1 did not expect '%c' to map to '%c'", c, LATIN_SMALL_LETTER_Y_WITH_DIAERESIS);
		/* NOTREACHED */
	}
    }
d1151 2
a1152 5
    *(p)++ = UTF8_TWO_BYTE_HI(converted);
    *p = UTF8_TWO_BYTE_LO(converted);
    *lenp = 2;

    return converted;
a1154 17
/* Call the function to convert a UTF-8 encoded character to the specified case.
 * Note that there may be more than one character in the result.
 * INP is a pointer to the first byte of the input character
 * OUTP will be set to the first byte of the string of changed characters.  It
 *	needs to have space for UTF8_MAXBYTES_CASE+1 bytes
 * LENP will be set to the length in bytes of the string of changed characters
 *
 * The functions return the ordinal of the first character in the string of OUTP */
#define CALL_UPPER_CASE(INP, OUTP, LENP) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_toupper, "ToUc", "utf8::ToSpecUc")
#define CALL_TITLE_CASE(INP, OUTP, LENP) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_totitle, "ToTc", "utf8::ToSpecTc")
#define CALL_LOWER_CASE(INP, OUTP, LENP) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_tolower, "ToLc", "utf8::ToSpecLc")

/* This additionally has the input parameter SPECIALS, which if non-zero will
 * cause this to use the SPECIALS hash for folding (meaning get full case
 * folding); otherwise, when zero, this implies a simple case fold */
#define CALL_FOLD_CASE(INP, OUTP, LENP, SPECIALS) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_tofold, "ToCf", (SPECIALS) ? "utf8::ToSpecCf" : NULL)

d1156 1
a1156 1
Perl_to_uni_upper(pTHX_ UV c, U8* p, STRLEN *lenp)
d1158 1
a1158 30
    dVAR;

    /* Convert the Unicode character whose ordinal is <c> to its uppercase
     * version and store that in UTF-8 in <p> and its length in bytes in <lenp>.
     * Note that the <p> needs to be at least UTF8_MAXBYTES_CASE+1 bytes since
     * the changed version may be longer than the original character.
     *
     * The ordinal of the first character of the changed version is returned
     * (but note, as explained above, that there may be more.) */

    PERL_ARGS_ASSERT_TO_UNI_UPPER;

    if (c < 256) {
	return _to_upper_title_latin1((U8) c, p, lenp, 'S');
    }

    uvchr_to_utf8(p, c);
    return CALL_UPPER_CASE(p, p, lenp);
}

UV
Perl_to_uni_title(pTHX_ UV c, U8* p, STRLEN *lenp)
{
    dVAR;

    PERL_ARGS_ASSERT_TO_UNI_TITLE;

    if (c < 256) {
	return _to_upper_title_latin1((U8) c, p, lenp, 's');
    }
d1161 1
a1161 24
    return CALL_TITLE_CASE(p, p, lenp);
}

STATIC U8
S_to_lower_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp)
{
    /* We have the latin1-range values compiled into the core, so just use
     * those, converting the result to utf8.  Since the result is always just
     * one character, we allow <p> to be NULL */

    U8 converted = toLOWER_LATIN1(c);

    if (p != NULL) {
	if (UNI_IS_INVARIANT(converted)) {
	    *p = converted;
	    *lenp = 1;
	}
	else {
	    *p = UTF8_TWO_BYTE_HI(converted);
	    *(p+1) = UTF8_TWO_BYTE_LO(converted);
	    *lenp = 2;
	}
    }
    return converted;
a1166 2
    dVAR;

a1168 4
    if (c < 256) {
	return to_lower_latin1((U8) c, p, lenp);
    }

d1170 1
a1170 1
    return CALL_LOWER_CASE(p, p, lenp);
d1174 1
a1174 1
Perl__to_fold_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp, const bool flags)
d1176 1
a1176 46
    /* Corresponds to to_lower_latin1(), <flags> is TRUE if to use full case
     * folding */

    UV converted;

    PERL_ARGS_ASSERT__TO_FOLD_LATIN1;

    if (c == MICRO_SIGN) {
	converted = GREEK_SMALL_LETTER_MU;
    }
    else if (flags && c == LATIN_SMALL_LETTER_SHARP_S) {
	*(p)++ = 's';
	*p = 's';
	*lenp = 2;
	return 's';
    }
    else { /* In this range the fold of all other characters is their lower
              case */
	converted = toLOWER_LATIN1(c);
    }

    if (UNI_IS_INVARIANT(converted)) {
	*p = (U8) converted;
	*lenp = 1;
    }
    else {
	*(p)++ = UTF8_TWO_BYTE_HI(converted);
	*p = UTF8_TWO_BYTE_LO(converted);
	*lenp = 2;
    }

    return converted;
}

UV
Perl__to_uni_fold_flags(pTHX_ UV c, U8* p, STRLEN *lenp, const bool flags)
{

    /* Not currently externally documented, and subject to change, <flags> is
     * TRUE iff full folding is to be used */

    PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS;

    if (c < 256) {
	return _to_fold_latin1((U8) c, p, lenp, flags);
    }
d1179 1
a1179 1
    return CALL_FOLD_CASE(p, p, lenp, flags);
d1182 1
a1182 3
/* for now these all assume no locale info available for Unicode > 255; and
 * the corresponding macros in handy.h (like isALNUM_LC_uvchr) should have been
 * called instead, so that these don't get called for < 255 */
a1295 11
    /* returns a boolean giving whether or not the UTF8-encoded character that
     * starts at <p> is in the swash indicated by <swashname>.  <swash>
     * contains a pointer to where the swash indicated by <swashname>
     * is to be stored; which this routine will do, so that future calls will
     * look at <*swash> and only generate a swash if it is not null
     *
     * Note that it is assumed that the buffer length of <p> is enough to
     * contain all the bytes that comprise the character.  Thus, <*p> should
     * have been checked before this call for mal-formedness enough to assure
     * that. */

d1300 1
a1300 6
    /* The API should have included a length for the UTF-8 character in <p>,
     * but it doesn't.  We therefor assume that p has been validated at least
     * as far as there being enough bytes available in it to accommodate the
     * character without reading beyond the end, and pass that number on to the
     * validating routine */
    if (!is_utf8_char_buf(p, p + UTF8SKIP(p)))
d1334 1
a1334 1
Perl_is_utf8_xidfirst(pTHX_ const U8 *p) /* The naming is historical. */
d1338 1
a1338 1
    PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST;
a1341 21
    /* is_utf8_idstart would be more logical. */
    return is_utf8_common(p, &PL_utf8_xidstart, "XIdStart");
}

bool
Perl__is_utf8__perl_idstart(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT__IS_UTF8__PERL_IDSTART;

    return is_utf8_common(p, &PL_utf8_perl_idstart, "_Perl_IDStart");
}

bool
Perl_is_utf8_idcont(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_IDCONT;

a1345 10
Perl_is_utf8_xidcont(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_XIDCONT;

    return is_utf8_common(p, &PL_utf8_idcont, "XIdContinue");
}

bool
d1362 1
a1362 3
    /* ASCII characters are the same whether in utf8 or not.  So the macro
     * works on both utf8 and non-utf8 representations. */
    return isASCII(*p);
d1372 1
a1372 1
    return is_utf8_common(p, &PL_utf8_space, "IsXPerlSpace");
d1382 1
a1382 3
    /* Only true if is an ASCII space-like character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isSPACE_A(*p);
d1392 1
a1392 3
    /* Only true if is an ASCII word character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isWORDCHAR_A(*p);
d1412 1
a1412 3
    /* Only true if is an ASCII digit character, and ASCII is invariant
     * under utf8, so can just use the macro */
    return isDIGIT_A(*p);
d1442 1
a1442 9
    if (isASCII(*p)) {
	return isCNTRL_A(*p);
    }

    /* All controls are in Latin1 */
    if (! UTF8_IS_DOWNGRADEABLE_START(*p)) {
	return 0;
    }
    return isCNTRL_L1(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)));
a1594 12
bool
Perl__is_utf8_quotemeta(pTHX_ const U8 *p)
{
    /* For exclusive use of pp_quotemeta() */

    dVAR;

    PERL_ARGS_ASSERT__IS_UTF8_QUOTEMETA;

    return is_utf8_common(p, &PL_utf8_quotemeta, "_Perl_Quotemeta");
}

d1598 2
a1599 3
The C<p> contains the pointer to the UTF-8 string encoding
the character that is being converted.  This routine assumes that the character
at C<p> is well-formed.
d1601 2
a1602 2
The C<ustrp> is a pointer to the character buffer to put the
conversion result to.  The C<lenp> is a pointer to the length
d1605 1
a1605 1
The C<swashp> is a pointer to the swash to use.
d1607 2
a1608 2
Both the special and normal mappings are stored in F<lib/unicore/To/Foo.pl>,
and loaded by SWASHNEW, using F<lib/utf8_heavy.pl>.  The C<special> (usually,
d1611 1
a1611 1
The C<special> is a string like "utf8::ToSpecLower", which means the
d1615 1
a1615 1
The C<normal> is a string like "ToLower" which means the swash
d1627 1
a1627 1
    const UV uv0 = valid_utf8_to_uvchr(p, NULL);
a1634 22
    /* Note that swash_fetch() doesn't output warnings for these because it
     * assumes we will */
    if (uv1 >= UNICODE_SURROGATE_FIRST) {
	if (uv1 <= UNICODE_SURROGATE_LAST) {
	    if (ckWARN_d(WARN_SURROGATE)) {
		const char* desc = (PL_op) ? OP_DESC(PL_op) : normal;
		Perl_warner(aTHX_ packWARN(WARN_SURROGATE),
		    "Operation \"%s\" returns its argument for UTF-16 surrogate U+%04"UVXf"", desc, uv1);
	    }
	}
	else if (UNICODE_IS_SUPER(uv1)) {
	    if (ckWARN_d(WARN_NON_UNICODE)) {
		const char* desc = (PL_op) ? OP_DESC(PL_op) : normal;
		Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
		    "Operation \"%s\" returns its argument for non-Unicode code point 0x%04"UVXf"", desc, uv1);
	    }
	}

	/* Note that non-characters are perfectly legal, so no warning should
	 * be given */
    }

d1639 10
d1650 8
a1657 1
    if (special) {
d1683 1
a1683 1
			     const UV c = utf8_to_uvchr_buf(t, tend, &tlen);
d1724 1
a1724 49
    return len ? valid_utf8_to_uvchr(ustrp, 0) : 0;
}

STATIC UV
S_check_locale_boundary_crossing(pTHX_ const U8* const p, const UV result, U8* const ustrp, STRLEN *lenp)
{
    /* This is called when changing the case of a utf8-encoded character above
     * the Latin1 range, and the operation is in locale.  If the result
     * contains a character that crosses the 255/256 boundary, disallow the
     * change, and return the original code point.  See L<perlfunc/lc> for why;
     *
     * p	points to the original string whose case was changed; assumed
     *          by this routine to be well-formed
     * result	the code point of the first character in the changed-case string
     * ustrp	points to the changed-case string (<result> represents its first char)
     * lenp	points to the length of <ustrp> */

    UV original;    /* To store the first code point of <p> */

    PERL_ARGS_ASSERT_CHECK_LOCALE_BOUNDARY_CROSSING;

    assert(! UTF8_IS_INVARIANT(*p) && ! UTF8_IS_DOWNGRADEABLE_START(*p));

    /* We know immediately if the first character in the string crosses the
     * boundary, so can skip */
    if (result > 255) {

	/* Look at every character in the result; if any cross the
	* boundary, the whole thing is disallowed */
	U8* s = ustrp + UTF8SKIP(ustrp);
	U8* e = ustrp + *lenp;
	while (s < e) {
	    if (UTF8_IS_INVARIANT(*s) || UTF8_IS_DOWNGRADEABLE_START(*s))
	    {
		goto bad_crossing;
	    }
	    s += UTF8SKIP(s);
	}

	/* Here, no characters crossed, result is ok as-is */
	return result;
    }

bad_crossing:

    /* Failed, have to return the original */
    original = valid_utf8_to_uvchr(p, lenp);
    Copy(p, ustrp, *lenp, char);
    return original;
d1730 2
a1731 2
Convert the UTF-8 encoded character at C<p> to its uppercase version and
store that in UTF-8 in C<ustrp> and its length in bytes in C<lenp>.  Note
a1737 2
The character at C<p> is assumed by this routine to be well-formed.

a1739 5
/* Not currently externally documented, and subject to change:
 * <flags> is set iff locale semantics are to be used for code points < 256
 * <tainted_ptr> if non-null, *tainted_ptr will be set TRUE iff locale rules
 *		 were used in the calculation; otherwise unchanged. */

d1741 1
a1741 1
Perl__to_utf8_upper_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, const bool flags, bool* tainted_ptr)
d1745 1
a1745 40
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_UPPER_FLAGS;

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags) {
	    result = toUPPER_LC(*p);
	}
	else {
	    return _to_upper_title_latin1(*p, ustrp, lenp, 'S');
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags) {
	    result = toUPPER_LC(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)));
	}
	else {
	    return _to_upper_title_latin1(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)),
				          ustrp, lenp, 'S');
	}
    }
    else {  /* utf8, ord above 255 */
	result = CALL_UPPER_CASE(p, ustrp, lenp);

	if (flags) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}
	return result;
    }

    /* Here, used locale rules.  Convert back to utf8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI(result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO(result);
	*lenp = 2;
    }
d1747 2
a1748 4
    if (tainted_ptr) {
	*tainted_ptr = TRUE;
    }
    return result;
d1754 3
a1756 3
Convert the UTF-8 encoded character at C<p> to its titlecase version and
store that in UTF-8 in C<ustrp> and its length in bytes in C<lenp>.  Note
that the C<ustrp> needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the
a1761 2
The character at C<p> is assumed by this routine to be well-formed.

a1763 7
/* Not currently externally documented, and subject to change:
 * <flags> is set iff locale semantics are to be used for code points < 256
 *	   Since titlecase is not defined in POSIX, uppercase is used instead
 *	   for these/
 * <tainted_ptr> if non-null, *tainted_ptr will be set TRUE iff locale rules
 *		 were used in the calculation; otherwise unchanged. */

d1765 1
a1765 1
Perl__to_utf8_title_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, const bool flags, bool* tainted_ptr)
d1769 1
a1769 40
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_TITLE_FLAGS;

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags) {
	    result = toUPPER_LC(*p);
	}
	else {
	    return _to_upper_title_latin1(*p, ustrp, lenp, 's');
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags) {
	    result = toUPPER_LC(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)));
	}
	else {
	    return _to_upper_title_latin1(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)),
				          ustrp, lenp, 's');
	}
    }
    else {  /* utf8, ord above 255 */
	result = CALL_TITLE_CASE(p, ustrp, lenp);

	if (flags) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}
	return result;
    }

    /* Here, used locale rules.  Convert back to utf8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI(result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO(result);
	*lenp = 2;
    }
d1771 2
a1772 4
    if (tainted_ptr) {
	*tainted_ptr = TRUE;
    }
    return result;
d1778 3
a1780 3
Convert the UTF-8 encoded character at C<p> to its lowercase version and
store that in UTF-8 in ustrp and its length in bytes in C<lenp>.  Note
that the C<ustrp> needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the
a1785 2
The character at C<p> is assumed by this routine to be well-formed.

a1787 5
/* Not currently externally documented, and subject to change:
 * <flags> is set iff locale semantics are to be used for code points < 256
 * <tainted_ptr> if non-null, *tainted_ptr will be set TRUE iff locale rules
 *		 were used in the calculation; otherwise unchanged. */

d1789 1
a1789 1
Perl__to_utf8_lower_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, const bool flags, bool* tainted_ptr)
a1790 2
    UV result;

d1793 1
a1793 39
    PERL_ARGS_ASSERT__TO_UTF8_LOWER_FLAGS;

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags) {
	    result = toLOWER_LC(*p);
	}
	else {
	    return to_lower_latin1(*p, ustrp, lenp);
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags) {
	    result = toLOWER_LC(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)));
	}
	else {
	    return to_lower_latin1(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)),
		                   ustrp, lenp);
	}
    }
    else {  /* utf8, ord above 255 */
	result = CALL_LOWER_CASE(p, ustrp, lenp);

	if (flags) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}

	return result;
    }

    /* Here, used locale rules.  Convert back to utf8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI(result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO(result);
	*lenp = 2;
    }
d1795 2
a1796 4
    if (tainted_ptr) {
	*tainted_ptr = TRUE;
    }
    return result;
d1802 3
a1804 3
Convert the UTF-8 encoded character at C<p> to its foldcase version and
store that in UTF-8 in C<ustrp> and its length in bytes in C<lenp>.  Note
that the C<ustrp> needs to be at least UTF8_MAXBYTES_CASE+1 bytes since the
a1810 2
The character at C<p> is assumed by this routine to be well-formed.

a1812 10
/* Not currently externally documented, and subject to change,
 * in <flags>
 *	bit FOLD_FLAGS_LOCALE is set iff locale semantics are to be used for code
 *			      points < 256.  Since foldcase is not defined in
 *			      POSIX, lowercase is used instead
 *      bit FOLD_FLAGS_FULL   is set iff full case folds are to be used;
 *			      otherwise simple folds
 * <tainted_ptr> if non-null, *tainted_ptr will be set TRUE iff locale rules
 *		 were used in the calculation; otherwise unchanged. */

d1814 1
a1814 1
Perl__to_utf8_fold_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, U8 flags, bool* tainted_ptr)
d1818 1
a1818 42
    UV result;

    PERL_ARGS_ASSERT__TO_UTF8_FOLD_FLAGS;

    if (UTF8_IS_INVARIANT(*p)) {
	if (flags & FOLD_FLAGS_LOCALE) {
	    result = toLOWER_LC(*p);
	}
	else {
	    return _to_fold_latin1(*p, ustrp, lenp,
		                   cBOOL(flags & FOLD_FLAGS_FULL));
	}
    }
    else if UTF8_IS_DOWNGRADEABLE_START(*p) {
	if (flags & FOLD_FLAGS_LOCALE) {
	    result = toLOWER_LC(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)));
	}
	else {
	    return _to_fold_latin1(TWO_BYTE_UTF8_TO_UNI(*p, *(p+1)),
		                   ustrp, lenp, cBOOL(flags & FOLD_FLAGS_FULL));
	}
    }
    else {  /* utf8, ord above 255 */
	result = CALL_FOLD_CASE(p, ustrp, lenp, flags);

	if ((flags & FOLD_FLAGS_LOCALE)) {
	    result = check_locale_boundary_crossing(p, result, ustrp, lenp);
	}

	return result;
    }

    /* Here, used locale rules.  Convert back to utf8 */
    if (UTF8_IS_INVARIANT(result)) {
	*ustrp = (U8) result;
	*lenp = 1;
    }
    else {
	*ustrp = UTF8_EIGHT_BIT_HI(result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO(result);
	*lenp = 2;
    }
d1820 2
a1821 4
    if (tainted_ptr) {
	*tainted_ptr = TRUE;
    }
    return result;
d1825 2
a1826 1
 * Returns a "swash" which is a hash described in utf8.c:Perl_swash_fetch().
a1829 1

a1832 42
    PERL_ARGS_ASSERT_SWASH_INIT;

    /* Returns a copy of a swash initiated by the called function.  This is the
     * public interface, and returning a copy prevents others from doing
     * mischief on the original */

    return newSVsv(_core_swash_init(pkg, name, listsv, minbits, none, FALSE, NULL, FALSE));
}

SV*
Perl__core_swash_init(pTHX_ const char* pkg, const char* name, SV *listsv, I32 minbits, I32 none, bool return_if_undef, SV* invlist, bool passed_in_invlist_has_user_defined_property)
{
    /* Initialize and return a swash, creating it if necessary.  It does this
     * by calling utf8_heavy.pl in the general case.
     *
     * This interface should only be used by functions that won't destroy or
     * adversely change the swash, as doing so affects all other uses of the
     * swash in the program; the general public should use 'Perl_swash_init'
     * instead.
     *
     * pkg  is the name of the package that <name> should be in.
     * name is the name of the swash to find.  Typically it is a Unicode
     *	    property name, including user-defined ones
     * listsv is a string to initialize the swash with.  It must be of the form
     *	    documented as the subroutine return value in
     *	    L<perlunicode/User-Defined Character Properties>
     * minbits is the number of bits required to represent each data element.
     *	    It is '1' for binary properties.
     * none I (khw) do not understand this one, but it is used only in tr///.
     * return_if_undef is TRUE if the routine shouldn't croak if it can't find
     *	    the requested property
     * invlist is an inversion list to initialize the swash with (or NULL)
     * has_user_defined_property is TRUE if <invlist> has some component that
     *      came from a user-defined property
     *
     * Thus there are three possible inputs to find the swash: <name>,
     * <listsv>, and <invlist>.  At least one must be specified.  The result
     * will be the union of the specified ones, although <listsv>'s various
     * actions can intersect, etc. what <name> gives.
     *
     * <invlist> is only valid for binary properties */

d1834 6
a1839 1
    SV* retval = &PL_sv_undef;
d1841 1
a1841 12
    assert(listsv != &PL_sv_undef || strNE(name, "") || invlist);
    assert(! invlist || minbits == 1);

    /* If data was passed in to go out to utf8_heavy to find the swash of, do
     * so */
    if (listsv != &PL_sv_undef || strNE(name, "")) {
	dSP;
	const size_t pkg_len = strlen(pkg);
	const size_t name_len = strlen(name);
	HV * const stash = gv_stashpvn(pkg, pkg_len, 0);
	SV* errsv_save;
	GV *method;
d1843 5
a1847 3
	PERL_ARGS_ASSERT__CORE_SWASH_INIT;

	PUSHSTACKi(PERLSI_MAGIC);
a1848 32
	SAVEHINTS();
	save_re_context();
	if (PL_parser && PL_parser->error_count)
	    SAVEI8(PL_parser->error_count), PL_parser->error_count = 0;
	method = gv_fetchmeth(stash, "SWASHNEW", 8, -1);
	if (!method) {	/* demand load utf8 */
	    ENTER;
	    errsv_save = newSVsv(ERRSV);
	    /* It is assumed that callers of this routine are not passing in
	     * any user derived data.  */
	    /* Need to do this after save_re_context() as it will set
	     * PL_tainted to 1 while saving $1 etc (see the code after getrx:
	     * in Perl_magic_get).  Even line to create errsv_save can turn on
	     * PL_tainted.  */
	    SAVEBOOL(PL_tainted);
	    PL_tainted = 0;
	    Perl_load_module(aTHX_ PERL_LOADMOD_NOIMPORT, newSVpvn(pkg,pkg_len),
			     NULL);
	    if (!SvTRUE(ERRSV))
		sv_setsv(ERRSV, errsv_save);
	    SvREFCNT_dec(errsv_save);
	    LEAVE;
	}
	SPAGAIN;
	PUSHMARK(SP);
	EXTEND(SP,5);
	mPUSHp(pkg, pkg_len);
	mPUSHp(name, name_len);
	PUSHs(listsv);
	mPUSHi(minbits);
	mPUSHi(none);
	PUTBACK;
d1850 9
a1858 8
	/* If we already have a pointer to the method, no need to use
	 * call_method() to repeat the lookup.  */
	if (method ? call_sv(MUTABLE_SV(method), G_SCALAR)
	    : call_sv(newSVpvs_flags("SWASHNEW", SVs_TEMP), G_SCALAR | G_METHOD))
	{
	    retval = *PL_stack_sp--;
	    SvREFCNT_inc(retval);
	}
a1862 77
	POPSTACK;
	if (IN_PERL_COMPILETIME) {
	    CopHINTS_set(PL_curcop, PL_hints);
	}
	if (!SvROK(retval) || SvTYPE(SvRV(retval)) != SVt_PVHV) {
	    if (SvPOK(retval))

		/* If caller wants to handle missing properties, let them */
		if (return_if_undef) {
		    return NULL;
		}
		Perl_croak(aTHX_
			   "Can't find Unicode property definition \"%"SVf"\"",
			   SVfARG(retval));
	    Perl_croak(aTHX_ "SWASHNEW didn't return an HV ref");
	}
    } /* End of calling the module to find the swash */

    /* Make sure there is an inversion list for binary properties */
    if (minbits == 1) {
	SV** swash_invlistsvp = NULL;
	SV* swash_invlist = NULL;
	bool invlist_in_swash_is_valid = FALSE;
	HV* swash_hv = NULL;

        /* If this operation fetched a swash, get its already existing
         * inversion list or create one for it */
	if (retval != &PL_sv_undef) {
	    swash_hv = MUTABLE_HV(SvRV(retval));

	    swash_invlistsvp = hv_fetchs(swash_hv, "INVLIST", FALSE);
	    if (swash_invlistsvp) {
		swash_invlist = *swash_invlistsvp;
		invlist_in_swash_is_valid = TRUE;
	    }
	    else {
		swash_invlist = _swash_to_invlist(retval);
	    }
	}

	/* If an inversion list was passed in, have to include it */
	if (invlist) {

            /* Any fetched swash will by now have an inversion list in it;
             * otherwise <swash_invlist>  will be NULL, indicating that we
             * didn't fetch a swash */
	    if (swash_invlist) {

		/* Add the passed-in inversion list, which invalidates the one
		 * already stored in the swash */
		invlist_in_swash_is_valid = FALSE;
		_invlist_union(invlist, swash_invlist, &swash_invlist);
	    }
	    else {

		/* Here, there is no swash already.  Set up a minimal one */
		swash_hv = newHV();
		retval = newRV_inc(MUTABLE_SV(swash_hv));
		swash_invlist = invlist;
	    }

            if (passed_in_invlist_has_user_defined_property) {
                if (! hv_stores(swash_hv, "USER_DEFINED", newSVuv(1))) {
                    Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
                }
            }
	}

        /* Here, we have computed the union of all the passed-in data.  It may
         * be that there was an inversion list in the swash which didn't get
         * touched; otherwise save the one computed one */
	if (! invlist_in_swash_is_valid) {
	    if (! hv_stores(MUTABLE_HV(SvRV(retval)), "INVLIST", swash_invlist))
            {
		Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
	    }
	}
d1864 28
a1891 1

d1900 2
a1901 3
 * multiple values.  --jhi
 * For those, you should use to_utf8_case() instead */
/* Now SWASHGET is recasted into S_swatch_get in this file. */
a1907 28
 *
 * A "swash" is a hash which contains initially the keys/values set up by
 * SWASHNEW.  The purpose is to be able to completely represent a Unicode
 * property for all possible code points.  Things are stored in a compact form
 * (see utf8_heavy.pl) so that calculation is required to find the actual
 * property value for a given code point.  As code points are looked up, new
 * key/value pairs are added to the hash, so that the calculation doesn't have
 * to ever be re-done.  Further, each calculation is done, not just for the
 * desired one, but for a whole block of code points adjacent to that one.
 * For binary properties on ASCII machines, the block is usually for 64 code
 * points, starting with a code point evenly divisible by 64.  Thus if the
 * property value for code point 257 is requested, the code goes out and
 * calculates the property values for all 64 code points between 256 and 319,
 * and stores these as a single 64-bit long bit vector, called a "swatch",
 * under the key for code point 256.  The key is the UTF-8 encoding for code
 * point 256, minus the final byte.  Thus, if the length of the UTF-8 encoding
 * for a code point is 13 bytes, the key will be 12 bytes long.  If the value
 * for code point 258 is then requested, this code realizes that it would be
 * stored under the key for 256, and would find that value and extract the
 * relevant bit, offset from 256.
 *
 * Non-binary properties are stored in as many bits as necessary to represent
 * their values (32 currently, though the code is more general than that), not
 * as single bits, but the principal is the same: the value for each key is a
 * vector that encompasses the property values for all code points whose UTF-8
 * representations are represented by the key.  That is, for all code points
 * whose UTF-8 representations are length N bytes, and the key is the first N-1
 * bytes of that.
a1925 1
    /* Convert to utf8 if not already */
d1972 1
a1972 1
	/* If not cached, generate it via swatch_get */
d1981 1
a1981 1
	    swatch = swatch_get(swash,
d1983 1
a1983 1
				(klen) ? (code_point & ~((UV)needents - 1)) : 0,
d1993 1
a1993 3
		Perl_croak(aTHX_ "panic: swash_fetch got improper swatch, "
			   "svp=%p, tmps=%p, slen=%"UVuf", needents=%"UVuf,
			   svp, tmps, (UV)slen, (UV)needents);
a2005 18
    if (UTF8_IS_SUPER(ptr) && ckWARN_d(WARN_NON_UNICODE)) {
	SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);

	/* This outputs warnings for binary properties only, assuming that
	 * to_utf8_case() will output any for non-binary.  Also, surrogates
	 * aren't checked for, as that would warn on things like /\p{Gc=Cs}/ */

	if (! bitssvp || SvUV(*bitssvp) == 1) {
	    /* User-defined properties can silently match above-Unicode */
	    SV** const user_defined_svp = hv_fetchs(hv, "USER_DEFINED", FALSE);
	    if (! user_defined_svp || ! SvUV(*user_defined_svp)) {
		const UV code_point = utf8n_to_uvuni(ptr, UTF8_MAXBYTES, 0, 0);
		Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
		    "Code point 0x%04"UVXf" is not Unicode, all \\p{} matches fail; all \\P{} matches succeed", code_point);
	    }
	}
    }

d2020 1
a2020 2
    Perl_croak(aTHX_ "panic: swash_fetch got swatch of unexpected bit width, "
	       "slen=%"UVuf", needents=%"UVuf, (UV)slen, (UV)needents);
d2024 5
a2028 16
/* Read a single line of the main body of the swash input text.  These are of
 * the form:
 * 0053	0056	0073
 * where each number is hex.  The first two numbers form the minimum and
 * maximum of a range, and the third is the value associated with the range.
 * Not all swashes should have a third number
 *
 * On input: l	  points to the beginning of the line to be examined; it points
 *		  to somewhere in the string of the whole input text, and is
 *		  terminated by a \n or the null string terminator.
 *	     lend   points to the null terminator of that string
 *	     wants_value    is non-zero if the swash expects a third number
 *	     typestr is the name of the swash's mapping, like 'ToLower'
 * On output: *min, *max, and *val are set to the values read from the line.
 *	      returns a pointer just beyond the line examined.  If there was no
 *	      valid min number on the line, returns lend+1
d2030 2
a2031 4

STATIC U8*
S_swash_scan_list_line(pTHX_ U8* l, U8* const lend, UV* min, UV* max, UV* val,
			     const bool wants_value, const U8* const typestr)
d2033 10
d2044 4
a2047 108
    STRLEN numlen;	    /* Length of the number */
    I32 flags = PERL_SCAN_SILENT_ILLDIGIT
		| PERL_SCAN_DISALLOW_PREFIX
		| PERL_SCAN_SILENT_NON_PORTABLE;

    /* nl points to the next \n in the scan */
    U8* const nl = (U8*)memchr(l, '\n', lend - l);

    /* Get the first number on the line: the range minimum */
    numlen = lend - l;
    *min = grok_hex((char *)l, &numlen, &flags, NULL);
    if (numlen)	    /* If found a hex number, position past it */
	l += numlen;
    else if (nl) {	    /* Else, go handle next line, if any */
	return nl + 1;	/* 1 is length of "\n" */
    }
    else {		/* Else, no next line */
	return lend + 1;	/* to LIST's end at which \n is not found */
    }

    /* The max range value follows, separated by a BLANK */
    if (isBLANK(*l)) {
	++l;
	flags = PERL_SCAN_SILENT_ILLDIGIT
		| PERL_SCAN_DISALLOW_PREFIX
		| PERL_SCAN_SILENT_NON_PORTABLE;
	numlen = lend - l;
	*max = grok_hex((char *)l, &numlen, &flags, NULL);
	if (numlen)
	    l += numlen;
	else    /* If no value here, it is a single element range */
	    *max = *min;

	/* Non-binary tables have a third entry: what the first element of the
	 * range maps to */
	if (wants_value) {
	    if (isBLANK(*l)) {
		++l;

		/* The ToLc, etc table mappings are not in hex, and must be
		 * corrected by adding the code point to them */
		if (typeto) {
		    char *after_strtol = (char *) lend;
		    *val = Strtol((char *)l, &after_strtol, 10);
		    l = (U8 *) after_strtol;
		}
		else { /* Other tables are in hex, and are the correct result
			  without tweaking */
		    flags = PERL_SCAN_SILENT_ILLDIGIT
			| PERL_SCAN_DISALLOW_PREFIX
			| PERL_SCAN_SILENT_NON_PORTABLE;
		    numlen = lend - l;
		    *val = grok_hex((char *)l, &numlen, &flags, NULL);
		    if (numlen)
			l += numlen;
		    else
			*val = 0;
		}
	    }
	    else {
		*val = 0;
		if (typeto) {
		    /* diag_listed_as: To%s: illegal mapping '%s' */
		    Perl_croak(aTHX_ "%s: illegal mapping '%s'",
				     typestr, l);
		}
	    }
	}
	else
	    *val = 0; /* bits == 1, then any val should be ignored */
    }
    else { /* Nothing following range min, should be single element with no
	      mapping expected */
	*max = *min;
	if (wants_value) {
	    *val = 0;
	    if (typeto) {
		/* diag_listed_as: To%s: illegal mapping '%s' */
		Perl_croak(aTHX_ "%s: illegal mapping '%s'", typestr, l);
	    }
	}
	else
	    *val = 0; /* bits == 1, then val should be ignored */
    }

    /* Position to next line if any, or EOF */
    if (nl)
	l = nl + 1;
    else
	l = lend;

    return l;
}

/* Note:
 * Returns a swatch (a bit vector string) for a code point sequence
 * that starts from the value C<start> and comprises the number C<span>.
 * A C<swash> must be an object created by SWASHNEW (see lib/utf8_heavy.pl).
 * Should be used via swash_fetch, which will cache the swatch in C<swash>.
 */
STATIC SV*
S_swatch_get(pTHX_ SV* swash, UV start, UV span)
{
    SV *swatch;
    U8 *l, *lend, *x, *xend, *s, *send;
    STRLEN lcur, xcur, scur;
    HV *const hv = MUTABLE_HV(SvRV(swash));
    SV** const invlistsvp = hv_fetchs(hv, "INVLIST", FALSE);
d2049 1
a2049 28
    SV** listsvp = NULL; /* The string containing the main body of the table */
    SV** extssvp = NULL;
    SV** invert_it_svp = NULL;
    U8* typestr = NULL;
    STRLEN bits;
    STRLEN octets; /* if bits == 1, then octets == 0 */
    UV  none;
    UV  end = start + span;

    if (invlistsvp == NULL) {
        SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);
        SV** const nonesvp = hv_fetchs(hv, "NONE", FALSE);
        SV** const typesvp = hv_fetchs(hv, "TYPE", FALSE);
        extssvp = hv_fetchs(hv, "EXTRAS", FALSE);
        listsvp = hv_fetchs(hv, "LIST", FALSE);
        invert_it_svp = hv_fetchs(hv, "INVERT_IT", FALSE);

	bits  = SvUV(*bitssvp);
	none  = SvUV(*nonesvp);
	typestr = (U8*)SvPV_nolen(*typesvp);
    }
    else {
	bits = 1;
	none = 0;
    }
    octets = bits >> 3; /* if bits == 1, then octets == 0 */

    PERL_ARGS_ASSERT_SWATCH_GET;
d2052 1
a2052 1
	Perl_croak(aTHX_ "panic: swatch_get doesn't expect bits %"UVuf,
a2055 6
    /* If overflowed, use the max possible */
    if (end < start) {
	end = UV_MAX;
	span = end - start;
    }

a2084 5
    if (invlistsvp) {	/* If has an inversion list set up use that */
	_invlist_populate_swatch(*invlistsvp, start, end, s);
        return swatch;
    }

d2089 16
a2104 4
	UV min, max, val, upper;
	l = S_swash_scan_list_line(aTHX_ l, lend, &min, &max, &val,
					 cBOOL(octets), typestr);
	if (l > lend) {
d2108 50
a2157 1
	/* If looking for something beyond this range, go try the next one */
a2160 9
	/* <end> is generally 1 beyond where we want to set things, but at the
	 * platform's infinity, where we can't go any higher, we want to
	 * include the code point at <end> */
        upper = (max < end)
                ? max
                : (max != UV_MAX || end != UV_MAX)
                  ? end - 1
                  : end;

d2169 1
a2169 1
	    for (key = min; key <= upper; key++) {
d2171 2
d2196 1
a2196 2

	    for (key = min; key <= upper; key++) {
d2198 2
d2204 1
d2206 1
a2206 25
    /* Invert if the data says it should be.  Assumes that bits == 1 */
    if (invert_it_svp && SvUV(*invert_it_svp)) {

	/* Unicode properties should come with all bits above PERL_UNICODE_MAX
	 * be 0, and their inversion should also be 0, as we don't succeed any
	 * Unicode property matches for non-Unicode code points */
	if (start <= PERL_UNICODE_MAX) {

	    /* The code below assumes that we never cross the
	     * Unicode/above-Unicode boundary in a range, as otherwise we would
	     * have to figure out where to stop flipping the bits.  Since this
	     * boundary is divisible by a large power of 2, and swatches comes
	     * in small powers of 2, this should be a valid assumption */
	    assert(start + span - 1 <= PERL_UNICODE_MAX);

	    send = s + scur;
	    while (s < send) {
		*s = ~(*s);
		s++;
	    }
	}
    }

    /* read $swash->{EXTRAS}
     * This code also copied to swash_to_invlist() below */
d2251 1
a2251 2
	    Perl_croak(aTHX_ "panic: swatch_get found swatch size mismatch, "
		       "bits=%"UVuf", otherbits=%"UVuf, (UV)bits, (UV)otherbits);
d2254 1
a2254 1
	other = swatch_get(*othersvp, start, span);
d2258 1
a2258 1
	    Perl_croak(aTHX_ "panic: swatch_get got improper swatch");
d2263 1
a2263 3
		Perl_croak(aTHX_ "panic: swatch_get found swatch length "
			   "mismatch, slen=%"UVuf", olen=%"UVuf,
			   (UV)slen, (UV)olen);
a2338 433
HV*
Perl__swash_inversion_hash(pTHX_ SV* const swash)
{

   /* Subject to change or removal.  For use only in one place in regcomp.c.
    * Can't be used on a property that is subject to user override, as it
    * relies on the value of SPECIALS in the swash which would be set by
    * utf8_heavy.pl to the hash in the non-overriden file, and hence is not set
    * for overridden properties
    *
    * Returns a hash which is the inversion and closure of a swash mapping.
    * For example, consider the input lines:
    * 004B		006B
    * 004C		006C
    * 212A		006B
    *
    * The returned hash would have two keys, the utf8 for 006B and the utf8 for
    * 006C.  The value for each key is an array.  For 006C, the array would
    * have a two elements, the utf8 for itself, and for 004C.  For 006B, there
    * would be three elements in its array, the utf8 for 006B, 004B and 212A.
    *
    * Essentially, for any code point, it gives all the code points that map to
    * it, or the list of 'froms' for that point.
    *
    * Currently it ignores any additions or deletions from other swashes,
    * looking at just the main body of the swash, and if there are SPECIALS
    * in the swash, at that hash
    *
    * The specials hash can be extra code points, and most likely consists of
    * maps from single code points to multiple ones (each expressed as a string
    * of utf8 characters).   This function currently returns only 1-1 mappings.
    * However consider this possible input in the specials hash:
    * "\xEF\xAC\x85" => "\x{0073}\x{0074}",         # U+FB05 => 0073 0074
    * "\xEF\xAC\x86" => "\x{0073}\x{0074}",         # U+FB06 => 0073 0074
    *
    * Both FB05 and FB06 map to the same multi-char sequence, which we don't
    * currently handle.  But it also means that FB05 and FB06 are equivalent in
    * a 1-1 mapping which we should handle, and this relationship may not be in
    * the main table.  Therefore this function examines all the multi-char
    * sequences and adds the 1-1 mappings that come out of that.  */

    U8 *l, *lend;
    STRLEN lcur;
    HV *const hv = MUTABLE_HV(SvRV(swash));

    /* The string containing the main body of the table */
    SV** const listsvp = hv_fetchs(hv, "LIST", FALSE);

    SV** const typesvp = hv_fetchs(hv, "TYPE", FALSE);
    SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);
    SV** const nonesvp = hv_fetchs(hv, "NONE", FALSE);
    /*SV** const extssvp = hv_fetchs(hv, "EXTRAS", FALSE);*/
    const U8* const typestr = (U8*)SvPV_nolen(*typesvp);
    const STRLEN bits  = SvUV(*bitssvp);
    const STRLEN octets = bits >> 3; /* if bits == 1, then octets == 0 */
    const UV     none  = SvUV(*nonesvp);
    SV **specials_p = hv_fetchs(hv, "SPECIALS", 0);

    HV* ret = newHV();

    PERL_ARGS_ASSERT__SWASH_INVERSION_HASH;

    /* Must have at least 8 bits to get the mappings */
    if (bits != 8 && bits != 16 && bits != 32) {
	Perl_croak(aTHX_ "panic: swash_inversion_hash doesn't expect bits %"UVuf,
						 (UV)bits);
    }

    if (specials_p) { /* It might be "special" (sometimes, but not always, a
			mapping to more than one character */

	/* Construct an inverse mapping hash for the specials */
	HV * const specials_hv = MUTABLE_HV(SvRV(*specials_p));
	HV * specials_inverse = newHV();
	char *char_from; /* the lhs of the map */
	I32 from_len;   /* its byte length */
	char *char_to;  /* the rhs of the map */
	I32 to_len;	/* its byte length */
	SV *sv_to;	/* and in a sv */
	AV* from_list;  /* list of things that map to each 'to' */

	hv_iterinit(specials_hv);

	/* The keys are the characters (in utf8) that map to the corresponding
	 * utf8 string value.  Iterate through the list creating the inverse
	 * list. */
	while ((sv_to = hv_iternextsv(specials_hv, &char_from, &from_len))) {
	    SV** listp;
	    if (! SvPOK(sv_to)) {
		Perl_croak(aTHX_ "panic: value returned from hv_iternextsv() "
			   "unexpectedly is not a string, flags=%lu",
			   (unsigned long)SvFLAGS(sv_to));
	    }
	    /*DEBUG_U(PerlIO_printf(Perl_debug_log, "Found mapping from %"UVXf", First char of to is %"UVXf"\n", valid_utf8_to_uvchr((U8*) char_from, 0), valid_utf8_to_uvchr((U8*) SvPVX(sv_to), 0)));*/

	    /* Each key in the inverse list is a mapped-to value, and the key's
	     * hash value is a list of the strings (each in utf8) that map to
	     * it.  Those strings are all one character long */
	    if ((listp = hv_fetch(specials_inverse,
				    SvPVX(sv_to),
				    SvCUR(sv_to), 0)))
	    {
		from_list = (AV*) *listp;
	    }
	    else { /* No entry yet for it: create one */
		from_list = newAV();
		if (! hv_store(specials_inverse,
				SvPVX(sv_to),
				SvCUR(sv_to),
				(SV*) from_list, 0))
		{
		    Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
		}
	    }

	    /* Here have the list associated with this 'to' (perhaps newly
	     * created and empty).  Just add to it.  Note that we ASSUME that
	     * the input is guaranteed to not have duplications, so we don't
	     * check for that.  Duplications just slow down execution time. */
	    av_push(from_list, newSVpvn_utf8(char_from, from_len, TRUE));
	}

	/* Here, 'specials_inverse' contains the inverse mapping.  Go through
	 * it looking for cases like the FB05/FB06 examples above.  There would
	 * be an entry in the hash like
	*	'st' => [ FB05, FB06 ]
	* In this example we will create two lists that get stored in the
	* returned hash, 'ret':
	*	FB05 => [ FB05, FB06 ]
	*	FB06 => [ FB05, FB06 ]
	*
	* Note that there is nothing to do if the array only has one element.
	* (In the normal 1-1 case handled below, we don't have to worry about
	* two lists, as everything gets tied to the single list that is
	* generated for the single character 'to'.  But here, we are omitting
	* that list, ('st' in the example), so must have multiple lists.) */
	while ((from_list = (AV *) hv_iternextsv(specials_inverse,
						 &char_to, &to_len)))
	{
	    if (av_len(from_list) > 0) {
		int i;

		/* We iterate over all combinations of i,j to place each code
		 * point on each list */
		for (i = 0; i <= av_len(from_list); i++) {
		    int j;
		    AV* i_list = newAV();
		    SV** entryp = av_fetch(from_list, i, FALSE);
		    if (entryp == NULL) {
			Perl_croak(aTHX_ "panic: av_fetch() unexpectedly failed");
		    }
		    if (hv_fetch(ret, SvPVX(*entryp), SvCUR(*entryp), FALSE)) {
			Perl_croak(aTHX_ "panic: unexpected entry for %s", SvPVX(*entryp));
		    }
		    if (! hv_store(ret, SvPVX(*entryp), SvCUR(*entryp),
				   (SV*) i_list, FALSE))
		    {
			Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
		    }

		    /* For debugging: UV u = valid_utf8_to_uvchr((U8*) SvPVX(*entryp), 0);*/
		    for (j = 0; j <= av_len(from_list); j++) {
			entryp = av_fetch(from_list, j, FALSE);
			if (entryp == NULL) {
			    Perl_croak(aTHX_ "panic: av_fetch() unexpectedly failed");
			}

			/* When i==j this adds itself to the list */
			av_push(i_list, newSVuv(utf8_to_uvchr_buf(
					(U8*) SvPVX(*entryp),
					(U8*) SvPVX(*entryp) + SvCUR(*entryp),
					0)));
			/*DEBUG_U(PerlIO_printf(Perl_debug_log, "Adding %"UVXf" to list for %"UVXf"\n", valid_utf8_to_uvchr((U8*) SvPVX(*entryp), 0), u));*/
		    }
		}
	    }
	}
	SvREFCNT_dec(specials_inverse); /* done with it */
    } /* End of specials */

    /* read $swash->{LIST} */
    l = (U8*)SvPV(*listsvp, lcur);
    lend = l + lcur;

    /* Go through each input line */
    while (l < lend) {
	UV min, max, val;
	UV inverse;
	l = S_swash_scan_list_line(aTHX_ l, lend, &min, &max, &val,
					 cBOOL(octets), typestr);
	if (l > lend) {
	    break;
	}

	/* Each element in the range is to be inverted */
	for (inverse = min; inverse <= max; inverse++) {
	    AV* list;
	    SV** listp;
	    IV i;
	    bool found_key = FALSE;
	    bool found_inverse = FALSE;

	    /* The key is the inverse mapping */
	    char key[UTF8_MAXBYTES+1];
	    char* key_end = (char *) uvuni_to_utf8((U8*) key, val);
	    STRLEN key_len = key_end - key;

	    /* Get the list for the map */
	    if ((listp = hv_fetch(ret, key, key_len, FALSE))) {
		list = (AV*) *listp;
	    }
	    else { /* No entry yet for it: create one */
		list = newAV();
		if (! hv_store(ret, key, key_len, (SV*) list, FALSE)) {
		    Perl_croak(aTHX_ "panic: hv_store() unexpectedly failed");
		}
	    }

	    /* Look through list to see if this inverse mapping already is
	     * listed, or if there is a mapping to itself already */
	    for (i = 0; i <= av_len(list); i++) {
		SV** entryp = av_fetch(list, i, FALSE);
		SV* entry;
		if (entryp == NULL) {
		    Perl_croak(aTHX_ "panic: av_fetch() unexpectedly failed");
		}
		entry = *entryp;
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "list for %"UVXf" contains %"UVXf"\n", val, SvUV(entry)));*/
		if (SvUV(entry) == val) {
		    found_key = TRUE;
		}
		if (SvUV(entry) == inverse) {
		    found_inverse = TRUE;
		}

		/* No need to continue searching if found everything we are
		 * looking for */
		if (found_key && found_inverse) {
		    break;
		}
	    }

	    /* Make sure there is a mapping to itself on the list */
	    if (! found_key) {
		av_push(list, newSVuv(val));
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "Adding %"UVXf" to list for %"UVXf"\n", val, val));*/
	    }


	    /* Simply add the value to the list */
	    if (! found_inverse) {
		av_push(list, newSVuv(inverse));
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "Adding %"UVXf" to list for %"UVXf"\n", inverse, val));*/
	    }

	    /* swatch_get() increments the value of val for each element in the
	     * range.  That makes more compact tables possible.  You can
	     * express the capitalization, for example, of all consecutive
	     * letters with a single line: 0061\t007A\t0041 This maps 0061 to
	     * 0041, 0062 to 0042, etc.  I (khw) have never understood 'none',
	     * and it's not documented; it appears to be used only in
	     * implementing tr//; I copied the semantics from swatch_get(), just
	     * in case */
	    if (!none || val < none) {
		++val;
	    }
	}
    }

    return ret;
}

SV*
Perl__swash_to_invlist(pTHX_ SV* const swash)
{

   /* Subject to change or removal.  For use only in one place in regcomp.c */

    U8 *l, *lend;
    char *loc;
    STRLEN lcur;
    HV *const hv = MUTABLE_HV(SvRV(swash));
    UV elements = 0;    /* Number of elements in the inversion list */
    U8 empty[] = "";

    /* The string containing the main body of the table */
    SV** const listsvp = hv_fetchs(hv, "LIST", FALSE);
    SV** const typesvp = hv_fetchs(hv, "TYPE", FALSE);
    SV** const bitssvp = hv_fetchs(hv, "BITS", FALSE);
    SV** const extssvp = hv_fetchs(hv, "EXTRAS", FALSE);
    SV** const invert_it_svp = hv_fetchs(hv, "INVERT_IT", FALSE);

    const U8* const typestr = (U8*)SvPV_nolen(*typesvp);
    const STRLEN bits  = SvUV(*bitssvp);
    const STRLEN octets = bits >> 3; /* if bits == 1, then octets == 0 */
    U8 *x, *xend;
    STRLEN xcur;

    SV* invlist;

    PERL_ARGS_ASSERT__SWASH_TO_INVLIST;

    /* read $swash->{LIST} */
    if (SvPOK(*listsvp)) {
	l = (U8*)SvPV(*listsvp, lcur);
    }
    else {
	/* LIST legitimately doesn't contain a string during compilation phases
	 * of Perl itself, before the Unicode tables are generated.  In this
	 * case, just fake things up by creating an empty list */
	l = empty;
	lcur = 0;
    }
    loc = (char *) l;
    lend = l + lcur;

    /* Scan the input to count the number of lines to preallocate array size
     * based on worst possible case, which is each line in the input creates 2
     * elements in the inversion list: 1) the beginning of a range in the list;
     * 2) the beginning of a range not in the list.  */
    while ((loc = (strchr(loc, '\n'))) != NULL) {
	elements += 2;
	loc++;
    }

    /* If the ending is somehow corrupt and isn't a new line, add another
     * element for the final range that isn't in the inversion list */
    if (! (*lend == '\n'
	|| (*lend == '\0' && (lcur == 0 || *(lend - 1) == '\n'))))
    {
	elements++;
    }

    invlist = _new_invlist(elements);

    /* Now go through the input again, adding each range to the list */
    while (l < lend) {
	UV start, end;
	UV val;		/* Not used by this function */

	l = S_swash_scan_list_line(aTHX_ l, lend, &start, &end, &val,
					 cBOOL(octets), typestr);

	if (l > lend) {
	    break;
	}

	invlist = _add_range_to_invlist(invlist, start, end);
    }

    /* Invert if the data says it should be */
    if (invert_it_svp && SvUV(*invert_it_svp)) {
	_invlist_invert_prop(invlist);
    }

    /* This code is copied from swatch_get()
     * read $swash->{EXTRAS} */
    x = (U8*)SvPV(*extssvp, xcur);
    xend = x + xcur;
    while (x < xend) {
	STRLEN namelen;
	U8 *namestr;
	SV** othersvp;
	HV* otherhv;
	STRLEN otherbits;
	SV **otherbitssvp, *other;
	U8 *nl;

	const U8 opc = *x++;
	if (opc == '\n')
	    continue;

	nl = (U8*)memchr(x, '\n', xend - x);

	if (opc != '-' && opc != '+' && opc != '!' && opc != '&') {
	    if (nl) {
		x = nl + 1; /* 1 is length of "\n" */
		continue;
	    }
	    else {
		x = xend; /* to EXTRAS' end at which \n is not found */
		break;
	    }
	}

	namestr = x;
	if (nl) {
	    namelen = nl - namestr;
	    x = nl + 1;
	}
	else {
	    namelen = xend - namestr;
	    x = xend;
	}

	othersvp = hv_fetch(hv, (char *)namestr, namelen, FALSE);
	otherhv = MUTABLE_HV(SvRV(*othersvp));
	otherbitssvp = hv_fetchs(otherhv, "BITS", FALSE);
	otherbits = (STRLEN)SvUV(*otherbitssvp);

	if (bits != otherbits || bits != 1) {
	    Perl_croak(aTHX_ "panic: _swash_to_invlist only operates on boolean "
		       "properties, bits=%"UVuf", otherbits=%"UVuf,
		       (UV)bits, (UV)otherbits);
	}

	/* The "other" swatch must be destroyed after. */
	other = _swash_to_invlist((SV *)*othersvp);

	/* End of code copied from swatch_get() */
	switch (opc) {
	case '+':
	    _invlist_union(invlist, other, &invlist);
	    break;
	case '!':
	    _invlist_invert(other);
	    _invlist_union(invlist, other, &invlist);
	    break;
	case '-':
	    _invlist_subtract(invlist, other, &invlist);
	    break;
	case '&':
	    _invlist_intersection(invlist, other, &invlist);
	    break;
	default:
	    break;
	}
	sv_free(other); /* through with it! */
    }

    return invlist;
}

d2342 2
a2343 2
Adds the UTF-8 representation of the Native code point C<uv> to the end
of the string C<d>; C<d> should have at least C<UTF8_MAXBYTES+1> free
d2377 1
d2379 1
a2379 1
Returns the native character value of the first character in the string
d2384 1
a2384 1
C<length> and C<flags> are the same as L</utf8n_to_uvuni>().
d2392 1
a2392 1
Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen,
a2401 53
bool
Perl_check_utf8_print(pTHX_ register const U8* s, const STRLEN len)
{
    /* May change: warns if surrogates, non-character code points, or
     * non-Unicode code points are in s which has length len bytes.  Returns
     * TRUE if none found; FALSE otherwise.  The only other validity check is
     * to make sure that this won't exceed the string's length */

    const U8* const e = s + len;
    bool ok = TRUE;

    PERL_ARGS_ASSERT_CHECK_UTF8_PRINT;

    while (s < e) {
	if (UTF8SKIP(s) > len) {
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_UTF8),
			   "%s in %s", unees, PL_op ? OP_DESC(PL_op) : "print");
	    return FALSE;
	}
	if (UNLIKELY(*s >= UTF8_FIRST_PROBLEMATIC_CODE_POINT_FIRST_BYTE)) {
	    STRLEN char_len;
	    if (UTF8_IS_SUPER(s)) {
		if (ckWARN_d(WARN_NON_UNICODE)) {
		    UV uv = utf8_to_uvchr_buf(s, e, &char_len);
		    Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
			"Code point 0x%04"UVXf" is not Unicode, may not be portable", uv);
		    ok = FALSE;
		}
	    }
	    else if (UTF8_IS_SURROGATE(s)) {
		if (ckWARN_d(WARN_SURROGATE)) {
		    UV uv = utf8_to_uvchr_buf(s, e, &char_len);
		    Perl_warner(aTHX_ packWARN(WARN_SURROGATE),
			"Unicode surrogate U+%04"UVXf" is illegal in UTF-8", uv);
		    ok = FALSE;
		}
	    }
	    else if
		((UTF8_IS_NONCHAR_GIVEN_THAT_NON_SUPER_AND_GE_PROBLEMATIC(s))
		 && (ckWARN_d(WARN_NONCHAR)))
	    {
		UV uv = utf8_to_uvchr_buf(s, e, &char_len);
		Perl_warner(aTHX_ packWARN(WARN_NONCHAR),
		    "Unicode non-character U+%04"UVXf" is illegal for open interchange", uv);
		ok = FALSE;
	    }
	}
	s += UTF8SKIP(s);
    }

    return ok;
}

d2405 2
a2406 2
Build to the scalar C<dsv> a displayable version of the string C<spv>,
length C<len>, the displayable version being at most C<pvlim> bytes long
d2409 1
a2409 1
The C<flags> argument can have UNI_DISPLAY_ISPRINT set to display
d2416 1
a2416 1
The pointer to the PV of the C<dsv> is returned.
d2440 1
a2440 1
	 u = utf8_to_uvchr_buf((U8*)s, (U8*)e, 0);
d2477 1
a2477 1

d2484 2
a2485 2
Build to the scalar C<dsv> a displayable version of the scalar C<sv>,
the displayable version being at most C<pvlim> bytes long
d2488 1
a2488 1
The C<flags> argument is as in L</pv_uni_display>().
d2490 1
a2490 1
The pointer to the PV of the C<dsv> is returned.
d2504 1
a2504 1
=for apidoc foldEQ_utf8
d2506 16
a2521 32
Returns true if the leading portions of the strings C<s1> and C<s2> (either or both
of which may be in UTF-8) are the same case-insensitively; false otherwise.
How far into the strings to compare is determined by other input parameters.

If C<u1> is true, the string C<s1> is assumed to be in UTF-8-encoded Unicode;
otherwise it is assumed to be in native 8-bit encoding.  Correspondingly for C<u2>
with respect to C<s2>.

If the byte length C<l1> is non-zero, it says how far into C<s1> to check for fold
equality.  In other words, C<s1>+C<l1> will be used as a goal to reach.  The
scan will not be considered to be a match unless the goal is reached, and
scanning won't continue past that goal.  Correspondingly for C<l2> with respect to
C<s2>.

If C<pe1> is non-NULL and the pointer it points to is not NULL, that pointer is
considered an end pointer beyond which scanning of C<s1> will not continue under
any circumstances.  This means that if both C<l1> and C<pe1> are specified, and
C<pe1>
is less than C<s1>+C<l1>, the match will never be successful because it can
never
get as far as its goal (and in fact is asserted against).  Correspondingly for
C<pe2> with respect to C<s2>.

At least one of C<s1> and C<s2> must have a goal (at least one of C<l1> and
C<l2> must be non-zero), and if both do, both have to be
reached for a successful match.   Also, if the fold of a character is multiple
characters, all of them must be matched (see tr21 reference below for
'folding').

Upon a successful match, if C<pe1> is non-NULL,
it will be set to point to the beginning of the I<next> character of C<s1>
beyond what was matched.  Correspondingly for C<pe2> and C<s2>.
d2525 1
a2525 1
L<http://www.unicode.org/unicode/reports/tr21/> (Case Mappings).
a2527 14

/* A flags parameter has been added which may change, and hence isn't
 * externally documented.  Currently it is:
 *  0 for as-documented above
 *  FOLDEQ_UTF8_NOMIX_ASCII meaning that if a non-ASCII character folds to an
			    ASCII one, to not match
 *  FOLDEQ_UTF8_LOCALE	    meaning that locale rules are to be used for code
 *			    points below 256; unicode rules for above 255; and
 *			    folds that cross those boundaries are disallowed,
 *			    like the NOMIX_ASCII option
 *  FOLDEQ_S1_ALREADY_FOLDED s1 has already been folded before calling this
 *                           routine.  This allows that step to be skipped.
 *  FOLDEQ_S2_ALREADY_FOLDED   Similarly.
 */
d2529 1
a2529 1
Perl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, register UV l1, bool u1, const char *s2, char **pe2, register UV l2, bool u2, U32 flags)
d2531 90
a2620 60
    dVAR;
    register const U8 *p1  = (const U8*)s1; /* Point to current char */
    register const U8 *p2  = (const U8*)s2;
    register const U8 *g1 = NULL;       /* goal for s1 */
    register const U8 *g2 = NULL;
    register const U8 *e1 = NULL;       /* Don't scan s1 past this */
    register U8 *f1 = NULL;             /* Point to current folded */
    register const U8 *e2 = NULL;
    register U8 *f2 = NULL;
    STRLEN n1 = 0, n2 = 0;              /* Number of bytes in current char */
    U8 foldbuf1[UTF8_MAXBYTES_CASE+1];
    U8 foldbuf2[UTF8_MAXBYTES_CASE+1];

    PERL_ARGS_ASSERT_FOLDEQ_UTF8_FLAGS;

    /* The algorithm requires that input with the flags on the first line of
     * the assert not be pre-folded. */
    assert( ! ((flags & (FOLDEQ_UTF8_NOMIX_ASCII | FOLDEQ_UTF8_LOCALE))
	&& (flags & (FOLDEQ_S1_ALREADY_FOLDED | FOLDEQ_S2_ALREADY_FOLDED))));

    if (pe1) {
        e1 = *(U8**)pe1;
    }

    if (l1) {
        g1 = (const U8*)s1 + l1;
    }

    if (pe2) {
        e2 = *(U8**)pe2;
    }

    if (l2) {
        g2 = (const U8*)s2 + l2;
    }

    /* Must have at least one goal */
    assert(g1 || g2);

    if (g1) {

        /* Will never match if goal is out-of-bounds */
        assert(! e1  || e1 >= g1);

        /* Here, there isn't an end pointer, or it is beyond the goal.  We
        * only go as far as the goal */
        e1 = g1;
    }
    else {
	assert(e1);    /* Must have an end for looking at s1 */
    }

    /* Same for goal for s2 */
    if (g2) {
        assert(! e2  || e2 >= g2);
        e2 = g2;
    }
    else {
	assert(e2);
    }
d2622 1
a2622 159
    /* If both operands are already folded, we could just do a memEQ on the
     * whole strings at once, but it would be better if the caller realized
     * this and didn't even call us */

    /* Look through both strings, a character at a time */
    while (p1 < e1 && p2 < e2) {

        /* If at the beginning of a new character in s1, get its fold to use
	 * and the length of the fold.  (exception: locale rules just get the
	 * character to a single byte) */
        if (n1 == 0) {
	    if (flags & FOLDEQ_S1_ALREADY_FOLDED) {
		f1 = (U8 *) p1;
		n1 = UTF8SKIP(f1);
	    }

	    else {
		/* If in locale matching, we use two sets of rules, depending
		 * on if the code point is above or below 255.  Here, we test
		 * for and handle locale rules */
		if ((flags & FOLDEQ_UTF8_LOCALE)
		    && (! u1 || UTF8_IS_INVARIANT(*p1)
			|| UTF8_IS_DOWNGRADEABLE_START(*p1)))
		{
		    /* There is no mixing of code points above and below 255. */
		    if (u2 && (! UTF8_IS_INVARIANT(*p2)
			&& ! UTF8_IS_DOWNGRADEABLE_START(*p2)))
		    {
			return 0;
		    }

		    /* We handle locale rules by converting, if necessary, the
		     * code point to a single byte. */
		    if (! u1 || UTF8_IS_INVARIANT(*p1)) {
			*foldbuf1 = *p1;
		    }
		    else {
			*foldbuf1 = TWO_BYTE_UTF8_TO_UNI(*p1, *(p1 + 1));
		    }
		    n1 = 1;
		}
		else if (isASCII(*p1)) {    /* Note, that here won't be both
					       ASCII and using locale rules */

		    /* If trying to mix non- with ASCII, and not supposed to,
		     * fail */
		    if ((flags & FOLDEQ_UTF8_NOMIX_ASCII) && ! isASCII(*p2)) {
			return 0;
		    }
		    n1 = 1;
		    *foldbuf1 = toLOWER(*p1);   /* Folds in the ASCII range are
						   just lowercased */
		}
		else if (u1) {
		    to_utf8_fold(p1, foldbuf1, &n1);
		}
		else {  /* Not utf8, get utf8 fold */
		    to_uni_fold(NATIVE_TO_UNI(*p1), foldbuf1, &n1);
		}
		f1 = foldbuf1;
	    }
        }

        if (n2 == 0) {    /* Same for s2 */
	    if (flags & FOLDEQ_S2_ALREADY_FOLDED) {
		f2 = (U8 *) p2;
		n2 = UTF8SKIP(f2);
	    }
	    else {
		if ((flags & FOLDEQ_UTF8_LOCALE)
		    && (! u2 || UTF8_IS_INVARIANT(*p2) || UTF8_IS_DOWNGRADEABLE_START(*p2)))
		{
		    /* Here, the next char in s2 is < 256.  We've already
		     * worked on s1, and if it isn't also < 256, can't match */
		    if (u1 && (! UTF8_IS_INVARIANT(*p1)
			&& ! UTF8_IS_DOWNGRADEABLE_START(*p1)))
		    {
			return 0;
		    }
		    if (! u2 || UTF8_IS_INVARIANT(*p2)) {
			*foldbuf2 = *p2;
		    }
		    else {
			*foldbuf2 = TWO_BYTE_UTF8_TO_UNI(*p2, *(p2 + 1));
		    }

		    /* Use another function to handle locale rules.  We've made
		     * sure that both characters to compare are single bytes */
		    if (! foldEQ_locale((char *) f1, (char *) foldbuf2, 1)) {
			return 0;
		    }
		    n1 = n2 = 0;
		}
		else if (isASCII(*p2)) {
		    if ((flags & FOLDEQ_UTF8_NOMIX_ASCII) && ! isASCII(*p1)) {
			return 0;
		    }
		    n2 = 1;
		    *foldbuf2 = toLOWER(*p2);
		}
		else if (u2) {
		    to_utf8_fold(p2, foldbuf2, &n2);
		}
		else {
		    to_uni_fold(NATIVE_TO_UNI(*p2), foldbuf2, &n2);
		}
		f2 = foldbuf2;
	    }
        }

	/* Here f1 and f2 point to the beginning of the strings to compare.
	 * These strings are the folds of the next character from each input
	 * string, stored in utf8. */

        /* While there is more to look for in both folds, see if they
        * continue to match */
        while (n1 && n2) {
            U8 fold_length = UTF8SKIP(f1);
            if (fold_length != UTF8SKIP(f2)
                || (fold_length == 1 && *f1 != *f2) /* Short circuit memNE
                                                       function call for single
                                                       byte */
                || memNE((char*)f1, (char*)f2, fold_length))
            {
                return 0; /* mismatch */
            }

            /* Here, they matched, advance past them */
            n1 -= fold_length;
            f1 += fold_length;
            n2 -= fold_length;
            f2 += fold_length;
        }

        /* When reach the end of any fold, advance the input past it */
        if (n1 == 0) {
            p1 += u1 ? UTF8SKIP(p1) : 1;
        }
        if (n2 == 0) {
            p2 += u2 ? UTF8SKIP(p2) : 1;
        }
    } /* End of loop through both strings */

    /* A match is defined by each scan that specified an explicit length
    * reaching its final goal, and the other not having matched a partial
    * character (which can happen when the fold of a character is more than one
    * character). */
    if (! ((g1 == 0 || p1 == g1) && (g2 == 0 || p2 == g2)) || n1 || n2) {
        return 0;
    }

    /* Successful match.  Set output pointers */
    if (pe1) {
        *pe1 = (char*)p1;
    }
    if (pe2) {
        *pe2 = (char*)p2;
    }
    return 1;
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a33 1
#include "inline_invlist.c"
a38 1
PERL_CALLCONV UV	Perl_valid_utf8_to_uvchr(pTHX_ const U8 *s, STRLEN *retlen);
d91 1
a91 1
Adds the UTF-8 representation of the Unicode code point C<uv> to the end
a109 4
where uv is a code point expressed in Latin-1 or above, not the platform's
native character set.  B<Almost all code should instead use L</uvchr_to_utf8>
or L</uvchr_to_utf8_flags>>.

d120 2
a121 3
affect how the function handles a Unicode non-character.  And likewise, the
UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags, affect the handling of
code points that are
d140 1
a140 4
    /* The first problematic code point is the first surrogate */
    if (uv >= UNICODE_SURROGATE_FIRST
        && ckWARN4_d(WARN_UTF8, WARN_SURROGATE, WARN_NON_UNICODE, WARN_NONCHAR))
    {
d256 1
a256 1
#endif /* Non loop style */
d273 1
a273 1
the "Perl extended UTF-8" (e.g, the infamous 'v-strings') will encode into
d277 1
a277 1
PERL_STATIC_INLINE STRLEN
d381 2
d445 2
d505 1
a505 7
C<retlen> to C<-1> (cast to C<STRLEN>) and return zero.

Note that this API requires disambiguation between successful decoding a NUL
character, and an error return (unless the UTF8_CHECK_ONLY flag is set), as
in both cases, 0 is returned.  To disambiguate, upon a zero return, see if the
first byte of C<s> is 0 as well.  If so, the input was a NUL; if not, the input
had an error.
d590 1
a590 1
    if (UNLIKELY(curlen == 0)) {
d620 1
a620 1
    if (UNLIKELY(UTF8_IS_CONTINUATION(uv))) {
d653 1
a653 1
	if (LIKELY(UTF8_IS_CONTINUATION(*s))) {
d698 1
a698 1
    if (UNLIKELY(unexpected_non_continuation)) {
d719 1
a719 1
    else if (UNLIKELY(curlen < expectlen)) {
a741 4
	    /* This message is deliberately not of the same syntax as the other
	     * messages for malformations, for backwards compatibility in the
	     * unlikely event that code is relying on its precise earlier text
	     */
d749 1
a749 1
    if (UNLIKELY(overflowed)) {
d791 11
a812 11
	else if (UNICODE_IS_NONCHAR(uv)) {
	    if ((flags & (UTF8_WARN_NONCHAR|UTF8_CHECK_ONLY)) == UTF8_WARN_NONCHAR
		&& ckWARN2_d(WARN_UTF8, WARN_NONCHAR))
	    {
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "Unicode non-character U+%04"UVXf" is illegal for open interchange", uv));
		pack_warn = packWARN2(WARN_UTF8, WARN_NONCHAR);
	    }
	    if (flags & UTF8_DISALLOW_NONCHAR) {
		goto disallowed;
	    }
	}
d893 5
a897 6
NULL) to -1.  If those warnings are off, the computed value, if well-defined
(or the Unicode REPLACEMENT CHARACTER if not), is silently returned, and
C<*retlen> is set (if C<retlen> isn't NULL) so that (S<C<s> + C<*retlen>>) is
the next possible position in C<s> that could begin a non-malformed character.
See L</utf8n_to_uvuni> for details on when the REPLACEMENT CHARACTER is
returned.
d915 3
a917 3
 * there are no malformations in the input UTF-8 string C<s>.  surrogates,
 * non-character code points, and non-Unicode code points are allowed.  A macro
 * in utf8.h is used to normally avoid this function wrapper */
a921 2
    const UV uv = valid_utf8_to_uvuni(s, retlen);

d924 1
a924 1
    return UNI_TO_NATIVE(uv);
d956 1
a956 1
    return utf8_to_uvchr_buf(s, s + UTF8_MAXBYTES, retlen);
d993 3
a995 2
 * there are no malformations in the input UTF-8 string C<s>.  Surrogates,
 * non-character code points, and non-Unicode code points are allowed */
a999 4
    UV expectlen = UTF8SKIP(s);
    const U8* send = s + expectlen;
    UV uv = NATIVE_TO_UTF(*s);

d1002 1
a1002 21
    if (retlen) {
	*retlen = expectlen;
    }

    /* An invariant is trivially returned */
    if (expectlen == 1) {
	return uv;
    }

    /* Remove the leading bits that indicate the number of bytes, leaving just
     * the bits that are part of the value */
    uv &= UTF_START_MASK(expectlen);

    /* Now, loop through the remaining bytes, accumulating each into the
     * working total as we go.  (I khw tried unrolling the loop for up to 4
     * bytes, but there was no performance improvement) */
    for (++s; s < send; s++) {
	uv = UTF8_ACCUMULATE(uv, *s);
    }

    return uv;
d1065 4
a1068 1
        s += UTF8SKIP(s);
a1447 8
bool
Perl__is_uni_FOO(pTHX_ const U8 classnum, const UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_FOO(classnum, tmpbuf);
}

d1457 1
a1457 23
    return _is_utf8_FOO(_CC_WORDCHAR, tmpbuf);
}

bool
Perl_is_uni_alnumc(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_FOO(_CC_ALPHANUMERIC, tmpbuf);
}

/* Internal function so we can deprecate the external one, and call
   this one from other deprecated functions in this file */

PERL_STATIC_INLINE bool
S_is_utf8_idfirst(pTHX_ const U8 *p)
{
    dVAR;

    if (*p == '_')
	return TRUE;
    /* is_utf8_idstart would be more logical. */
    return is_utf8_common(p, &PL_utf8_idstart, "IdStart");
d1465 1
a1465 17
    return S_is_utf8_idfirst(aTHX_ tmpbuf);
}

bool
Perl__is_uni_perl_idcont(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_perl_idcont(tmpbuf);
}

bool
Perl__is_uni_perl_idstart(pTHX_ UV c)
{
    U8 tmpbuf[UTF8_MAXBYTES+1];
    uvchr_to_utf8(tmpbuf, c);
    return _is_utf8_perl_idstart(tmpbuf);
d1473 1
a1473 1
    return _is_utf8_FOO(_CC_ALPHA, tmpbuf);
a1482 6
Perl_is_uni_blank(pTHX_ UV c)
{
    return isBLANK_uni(c);
}

bool
d1485 3
a1487 1
    return isSPACE_uni(c);
d1495 1
a1495 1
    return _is_utf8_FOO(_CC_DIGIT, tmpbuf);
d1503 1
a1503 1
    return _is_utf8_FOO(_CC_UPPER, tmpbuf);
d1511 1
a1511 1
    return _is_utf8_FOO(_CC_LOWER, tmpbuf);
d1525 1
a1525 1
    return _is_utf8_FOO(_CC_GRAPH, tmpbuf);
d1533 1
a1533 1
    return _is_utf8_FOO(_CC_PRINT, tmpbuf);
d1541 1
a1541 1
    return _is_utf8_FOO(_CC_PUNCT, tmpbuf);
d1547 3
a1549 1
    return isXDIGIT_uni(c);
d1592 1
a1592 1
		assert(0); /* NOTREACHED */
d1734 1
a1734 1
Perl__to_uni_fold_flags(pTHX_ UV c, U8* p, STRLEN *lenp, const U8 flags)
d1737 2
a1738 6
    /* Not currently externally documented, and subject to change
     *  <flags> bits meanings:
     *	    FOLD_FLAGS_FULL  iff full folding is to be used;
     *	    FOLD_FLAGS_LOCALE iff in locale
     *	    FOLD_FLAGS_NOMIX_ASCII iff non-ASCII to ASCII folds are prohibited
     */
d1743 1
a1743 24
	UV result = _to_fold_latin1((U8) c, p, lenp,
			       cBOOL(((flags & FOLD_FLAGS_FULL)
				   /* If ASCII-safe, don't allow full folding,
				    * as that could include SHARP S => ss;
				    * otherwise there is no crossing of
				    * ascii/non-ascii in the latin1 range */
				   && ! (flags & FOLD_FLAGS_NOMIX_ASCII))));
	/* It is illegal for the fold to cross the 255/256 boundary under
	 * locale; in this case return the original */
	return (result > 256 && flags & FOLD_FLAGS_LOCALE)
	       ? c
	       : result;
    }

    /* If no special needs, just use the macro */
    if ( ! (flags & (FOLD_FLAGS_LOCALE|FOLD_FLAGS_NOMIX_ASCII))) {
	uvchr_to_utf8(p, c);
	return CALL_FOLD_CASE(p, p, lenp, flags & FOLD_FLAGS_FULL);
    }
    else {  /* Otherwise, _to_utf8_fold_flags has the intelligence to deal with
	       the special flags. */
	U8 utf8_c[UTF8_MAXBYTES + 1];
	uvchr_to_utf8(utf8_c, c);
	return _to_utf8_fold_flags(utf8_c, p, lenp, flags, NULL);
d1745 3
d1750 4
d1757 1
a1757 13
    if (c < 256) {
        return isALNUM_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_WORDCHAR, c);
}

bool
Perl_is_uni_alnumc_lc(pTHX_ UV c)
{
    if (c < 256) {
        return isALPHANUMERIC_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_ALPHANUMERIC, c);
d1763 1
a1763 4
    if (c < 256) {
        return isIDFIRST_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_perl_idstart(c);
d1769 1
a1769 4
    if (c < 256) {
        return isALPHA_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_ALPHA, c);
d1775 1
a1775 13
    if (c < 256) {
        return isASCII_LC(UNI_TO_NATIVE(c));
    }
    return 0;
}

bool
Perl_is_uni_blank_lc(pTHX_ UV c)
{
    if (c < 256) {
        return isBLANK_LC(UNI_TO_NATIVE(c));
    }
    return isBLANK_uni(c);
d1781 1
a1781 4
    if (c < 256) {
        return isSPACE_LC(UNI_TO_NATIVE(c));
    }
    return isSPACE_uni(c);
d1787 1
a1787 4
    if (c < 256) {
        return isDIGIT_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_DIGIT, c);
d1793 1
a1793 4
    if (c < 256) {
        return isUPPER_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_UPPER, c);
d1799 1
a1799 4
    if (c < 256) {
        return isLOWER_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_LOWER, c);
d1805 1
a1805 4
    if (c < 256) {
        return isCNTRL_LC(UNI_TO_NATIVE(c));
    }
    return 0;
d1811 1
a1811 4
    if (c < 256) {
        return isGRAPH_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_GRAPH, c);
d1817 1
a1817 4
    if (c < 256) {
        return isPRINT_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_PRINT, c);
d1823 1
a1823 4
    if (c < 256) {
        return isPUNCT_LC(UNI_TO_NATIVE(c));
    }
    return _is_uni_FOO(_CC_PUNCT, c);
d1829 1
a1829 4
    if (c < 256) {
       return isXDIGIT_LC(UNI_TO_NATIVE(c));
    }
    return isXDIGIT_uni(c);
d1862 1
a1862 1
PERL_STATIC_INLINE bool
d1882 1
a1882 1
     * but it doesn't.  We therefore assume that p has been validated at least
d1886 4
a1889 16
    if (! is_utf8_char_buf(p, p + UTF8SKIP(p))) {
        if (ckWARN_d(WARN_UTF8)) {
            Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED,WARN_UTF8),
		    "Passing malformed UTF-8 to \"%s\" is deprecated", swashname);
            if (ckWARN(WARN_UTF8)) {    /* This will output details as to the
                                           what the malformation is */
                utf8_to_uvchr_buf(p, p + UTF8SKIP(p), NULL);
            }
        }
        return FALSE;
    }
    if (!*swash) {
        U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
        *swash = _core_swash_init("utf8", swashname, &PL_sv_undef, 1, 0, NULL, &flags);
    }

a1893 12
Perl__is_utf8_FOO(pTHX_ const U8 classnum, const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT__IS_UTF8_FOO;

    assert(classnum < _FIRST_NON_SWASH_CC);

    return is_utf8_common(p, &PL_utf8_swash_ptrs[classnum], swash_property_names[classnum]);
}

bool
d1903 1
a1903 11
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_WORDCHAR], "IsWord");
}

bool
Perl_is_utf8_alnumc(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_ALNUMC;

    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_ALPHANUMERIC], "IsAlnum");
d1913 4
a1916 1
    return S_is_utf8_idfirst(aTHX_ p);
d1933 1
a1933 1
Perl__is_utf8_perl_idstart(pTHX_ const U8 *p)
d1937 1
a1937 1
    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART;
a1942 11
Perl__is_utf8_perl_idcont(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT;

    return is_utf8_common(p, &PL_utf8_perl_idcont, "_Perl_IDCont");
}


bool
d1969 1
a1969 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_ALPHA], "IsAlpha");
a1984 10
Perl_is_utf8_blank(pTHX_ const U8 *p)
{
    dVAR;

    PERL_ARGS_ASSERT_IS_UTF8_BLANK;

    return isBLANK_utf8(p);
}

bool
d1991 1
a1991 1
    return isSPACE_utf8(p);
d2025 1
a2025 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_DIGIT], "IsDigit");
d2047 1
a2047 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_UPPER], "IsUppercase");
d2057 1
a2057 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_LOWER], "IsLowercase");
d2067 9
a2075 1
    return isCNTRL_utf8(p);
d2085 1
a2085 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_GRAPH], "IsGraph");
d2095 1
a2095 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_PRINT], "IsPrint");
d2105 1
a2105 1
    return is_utf8_common(p, &PL_utf8_swash_ptrs[_CC_PUNCT], "IsPunct");
d2115 1
a2115 1
    return is_XDIGIT_utf8(p);
d2119 1
a2119 1
Perl__is_utf8_mark(pTHX_ const U8 *p)
d2123 1
a2123 1
    PERL_ARGS_ASSERT__IS_UTF8_MARK;
d2128 99
d2229 1
a2229 1
Perl_is_utf8_mark(pTHX_ const U8 *p)
d2231 2
d2235 1
a2235 1
    PERL_ARGS_ASSERT_IS_UTF8_MARK;
d2237 1
a2237 1
    return _is_utf8_mark(p);
d2306 1
a2306 1
         *swashp = _core_swash_init("utf8", normal, &PL_sv_undef, 4, 0, NULL, NULL);
d2359 1
a2359 1
	const UV uv2 = swash_fetch(*swashp, tmpbuf, TRUE /* => is utf8 */);
d2368 3
a2370 13
    if (len) {
        if (lenp) {
            *lenp = len;
        }
        return valid_utf8_to_uvchr(ustrp, 0);
    }

    /* Here, there was no mapping defined, which means that the code point maps
     * to itself.  Return the inputs */
    len = UTF8SKIP(p);
    if (p != ustrp) {   /* Don't copy onto itself */
        Copy(p, ustrp, len, U8);
    }
d2375 1
a2375 2
    return uv0;

a2667 2
 *      bit FOLD_FLAGS_NOMIX_ASCII is set iff folds of non-ASCII to ASCII are
 *			      prohibited
a2679 5
    /* These are mutually exclusive */
    assert (! ((flags & FOLD_FLAGS_LOCALE) && (flags & FOLD_FLAGS_NOMIX_ASCII)));

    assert(p != ustrp); /* Otherwise overwrites */

d2695 1
a2695 8
		                   ustrp, lenp,
				   cBOOL((flags & FOLD_FLAGS_FULL
				       /* If ASCII safe, don't allow full
					* folding, as that could include SHARP
					* S => ss; otherwise there is no
					* crossing of ascii/non-ascii in the
					* latin1 range */
				       && ! (flags & FOLD_FLAGS_NOMIX_ASCII))));
d2699 1
a2699 1
	result = CALL_FOLD_CASE(p, ustrp, lenp, flags & FOLD_FLAGS_FULL);
d2702 1
a2702 1
	    return check_locale_boundary_crossing(p, result, ustrp, lenp);
a2703 23
	else if (! (flags & FOLD_FLAGS_NOMIX_ASCII)) {
	    return result;
	}
	else {
	    /* This is called when changing the case of a utf8-encoded
	     * character above the Latin1 range, and the result should not
	     * contain an ASCII character. */

	    UV original;    /* To store the first code point of <p> */

	    /* Look at every character in the result; if any cross the
	    * boundary, the whole thing is disallowed */
	    U8* s = ustrp;
	    U8* e = ustrp + *lenp;
	    while (s < e) {
		if (isASCII(*s)) {
		    /* Crossed, have to return the original */
		    original = valid_utf8_to_uvchr(p, lenp);
		    Copy(p, ustrp, *lenp, char);
		    return original;
		}
		s += UTF8SKIP(s);
	    }
d2705 1
a2705 3
	    /* Here, no characters crossed, result is ok as-is */
	    return result;
	}
d2740 1
a2740 1
    return newSVsv(_core_swash_init(pkg, name, listsv, minbits, none, NULL, NULL));
d2744 1
a2744 1
Perl__core_swash_init(pTHX_ const char* pkg, const char* name, SV *listsv, I32 minbits, I32 none, SV* invlist, U8* const flags_p)
d2747 1
a2747 5
     * by calling utf8_heavy.pl in the general case.  The returned value may be
     * the swash's inversion list instead if the input parameters allow it.
     * Which is returned should be immaterial to callers, as the only
     * operations permitted on a swash, swash_fetch(), _get_swash_invlist(),
     * and swash_to_invlist() handle both these transparently.
d2763 2
d2766 2
a2767 12
     * flags_p if non-NULL is the address of various input and output flag bits
     *      to the routine, as follows:  ('I' means is input to the routine;
     *      'O' means output from the routine.  Only flags marked O are
     *      meaningful on return.)
     *  _CORE_SWASH_INIT_USER_DEFINED_PROPERTY indicates if the swash
     *      came from a user-defined property.  (I O)
     *  _CORE_SWASH_INIT_RETURN_IF_UNDEF indicates that instead of croaking
     *      when the swash cannot be located, to simply return NULL. (I)
     *  _CORE_SWASH_INIT_ACCEPT_INVLIST indicates that the caller will accept a
     *      return of an inversion list instead of a swash hash if this routine
     *      thinks that would result in faster execution of swash_fetch() later
     *      on. (I)
a2777 6
    HV* swash_hv = NULL;
    const int invlist_swash_boundary =
        (flags_p && *flags_p & _CORE_SWASH_INIT_ACCEPT_INVLIST)
        ? 512    /* Based on some benchmarking, but not extensive, see commit
                    message */
        : -1;   /* Never return just an inversion list */
a2797 4
	/* We might get here via a subroutine signature which uses a utf8
	 * parameter name, at which point PL_subname will have been set
	 * but not yet used. */
	save_item(PL_subname);
d2803 1
a2803 2
	    if ((errsv_save = GvSV(PL_errgv))) SAVEFREESV(errsv_save);
	    GvSV(PL_errgv) = NULL;
d2810 2
a2811 4
#ifndef NO_TAINT_SUPPORT
	    SAVEBOOL(TAINT_get);
	    TAINT_NOT;
#endif
d2814 3
a2816 9
	    {
		/* Not ERRSV, as there is no need to vivify a scalar we are
		   about to discard. */
		SV * const errsv = GvSV(PL_errgv);
		if (!SvTRUE(errsv)) {
		    GvSV(PL_errgv) = SvREFCNT_inc_simple(errsv_save);
		    SvREFCNT_dec(errsv);
		}
	    }
d2828 1
a2828 2
	if ((errsv_save = GvSV(PL_errgv))) SAVEFREESV(errsv_save);
	GvSV(PL_errgv) = NULL;
d2831 1
a2831 2
	if (method
            ? call_sv(MUTABLE_SV(method), G_SCALAR)
d2837 3
a2839 8
	{
	    /* Not ERRSV.  See above. */
	    SV * const errsv = GvSV(PL_errgv);
	    if (!SvTRUE(errsv)) {
		GvSV(PL_errgv) = SvREFCNT_inc_simple(errsv_save);
		SvREFCNT_dec(errsv);
	    }
	}
d2849 1
a2849 1
		if (flags_p && *flags_p & _CORE_SWASH_INIT_RETURN_IF_UNDEF) {
a2858 19
    /* If this operation fetched a swash, and we will need it later, get it */
    if (retval != &PL_sv_undef
        && (minbits == 1 || (flags_p
                            && ! (*flags_p
                                  & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY))))
    {
        swash_hv = MUTABLE_HV(SvRV(retval));

        /* If we don't already know that there is a user-defined component to
         * this swash, and the user has indicated they wish to know if there is
         * one (by passing <flags_p>), find out */
        if (flags_p && ! (*flags_p & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)) {
            SV** user_defined = hv_fetchs(swash_hv, "USER_DEFINED", FALSE);
            if (user_defined && SvUV(*user_defined)) {
                *flags_p |= _CORE_SWASH_INIT_USER_DEFINED_PROPERTY;
            }
        }
    }

d2864 1
a2864 2
	bool swash_invlist_unclaimed = FALSE; /* whether swash_invlist has
					    an unclaimed reference count */
d2867 3
a2869 1
         * inversion list, or create one for it */
d2871 1
a2871 2
        if (swash_hv) {
	    swash_invlistsvp = hv_fetchs(swash_hv, "V", FALSE);
a2877 1
		swash_invlist_unclaimed = TRUE;
d2896 3
a2898 6
                /* Here, there is no swash already.  Set up a minimal one, if
                 * we are going to return a swash */
                if ((int) _invlist_len(invlist) > invlist_swash_boundary) {
                    swash_hv = newHV();
                    retval = newRV_noinc(MUTABLE_SV(swash_hv));
                }
d2901 6
d2912 2
a2913 4
	if (! invlist_in_swash_is_valid
            && (int) _invlist_len(swash_invlist) > invlist_swash_boundary)
        {
	    if (! hv_stores(MUTABLE_HV(SvRV(retval)), "V", swash_invlist))
a2916 3
	    /* We just stole a reference count. */
	    if (swash_invlist_unclaimed) swash_invlist_unclaimed = FALSE;
	    else SvREFCNT_inc_simple_void_NN(swash_invlist);
a2917 8

        /* Use the inversion list stand-alone if small enough */
        if ((int) _invlist_len(swash_invlist) <= invlist_swash_boundary) {
	    SvREFCNT_dec(retval);
	    if (!swash_invlist_unclaimed)
		SvREFCNT_inc_simple_void_NN(swash_invlist);
            retval = newRV_noinc(swash_invlist);
        }
a2982 9
    /* If it really isn't a hash, it isn't really swash; must be an inversion
     * list */
    if (SvTYPE(hv) != SVt_PVHV) {
        return _invlist_contains_cp((SV*)hv,
                                    (do_utf8)
                                     ? valid_utf8_to_uvchr(ptr, NULL)
                                     : c);
    }

d3066 18
d3233 1
a3233 1
    SV** const invlistsvp = hv_fetchs(hv, "V", FALSE);
d3538 1
a3538 1
   /* Subject to change or removal.  For use only in regcomp.c and regexec.c
d3579 1
a3579 2
    /* The string containing the main body of the table.  This will have its
     * assertion fail if the swash has been converted to its inversion list */
d3706 1
a3706 1
			/*DEBUG_U(PerlIO_printf(Perl_debug_log, "%s: %d: Adding %"UVXf" to list for %"UVXf"\n", __FILE__, __LINE__, valid_utf8_to_uvchr((U8*) SvPVX(*entryp), 0), u));*/
d3779 1
a3779 1
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "%s: %d: Adding %"UVXf" to list for %"UVXf"\n", __FILE__, __LINE__, val, val));*/
d3786 1
a3786 1
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "%s: %d: Adding %"UVXf" to list for %"UVXf"\n", __FILE__, __LINE__, inverse, val));*/
d3810 1
a3810 2
   /* Subject to change or removal.  For use only in one place in regcomp.c.
    * Ownership is given to one reference count in the returned SV* */
a3817 5
    SV** listsvp;
    SV** typesvp;
    SV** bitssvp;
    SV** extssvp;
    SV** invert_it_svp;
d3819 10
a3828 3
    U8* typestr;
    STRLEN bits;
    STRLEN octets; /* if bits == 1, then octets == 0 */
a3835 16
    /* If not a hash, it must be the swash's inversion list instead */
    if (SvTYPE(hv) != SVt_PVHV) {
        return SvREFCNT_inc_simple_NN((SV*) hv);
    }

    /* The string containing the main body of the table */
    listsvp = hv_fetchs(hv, "LIST", FALSE);
    typesvp = hv_fetchs(hv, "TYPE", FALSE);
    bitssvp = hv_fetchs(hv, "BITS", FALSE);
    extssvp = hv_fetchs(hv, "EXTRAS", FALSE);
    invert_it_svp = hv_fetchs(hv, "INVERT_IT", FALSE);

    typestr = (U8*)SvPV_nolen(*typesvp);
    bits  = SvUV(*bitssvp);
    octets = bits >> 3; /* if bits == 1, then octets == 0 */

d3949 2
a3950 1
            _invlist_union_maybe_complement_2nd(invlist, other, TRUE, &invlist);
a3966 25
SV*
Perl__get_swash_invlist(pTHX_ SV* const swash)
{
    SV** ptr;

    PERL_ARGS_ASSERT__GET_SWASH_INVLIST;

    if (! SvROK(swash)) {
        return NULL;
    }

    /* If it really isn't a hash, it isn't really swash; must be an inversion
     * list */
    if (SvTYPE(SvRV(swash)) != SVt_PVHV) {
        return SvRV(swash);
    }

    ptr = hv_fetchs(MUTABLE_HV(SvRV(swash)), "V", FALSE);
    if (! ptr) {
        return NULL;
    }

    return *ptr;
}

d4030 1
a4030 1
Perl_check_utf8_print(pTHX_ const U8* s, const STRLEN len)
a4176 3
    const char * const ptr =
        isREGEXP(ssv) ? RX_WRAPPED((REGEXP*)ssv) : SvPVX_const(ssv);

d4179 1
a4179 1
    return Perl_pv_uni_display(aTHX_ dsv, (const U8*)ptr,
d4201 3
a4203 5
considered an end pointer to the position 1 byte past the maximum point
in C<s1> beyond which scanning will not continue under any circumstances.
(This routine assumes that UTF-8 encoded input strings are not malformed;
malformed input can cause it to read past C<pe1>).
This means that if both C<l1> and C<pe1> are specified, and C<pe1>
d4239 1
a4239 1
Perl_foldEQ_utf8_flags(pTHX_ const char *s1, char **pe1, UV l1, bool u1, const char *s2, char **pe2, UV l2, bool u2, U32 flags)
d4242 8
a4249 8
    const U8 *p1  = (const U8*)s1; /* Point to current char */
    const U8 *p2  = (const U8*)s2;
    const U8 *g1 = NULL;       /* goal for s1 */
    const U8 *g2 = NULL;
    const U8 *e1 = NULL;       /* Don't scan s1 past this */
    U8 *f1 = NULL;             /* Point to current folded */
    const U8 *e2 = NULL;
    U8 *f2 = NULL;
d4317 1
d4467 1
a4467 1
 * indent-tabs-mode: nil
d4470 1
a4470 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d35 8
a42 1
#include "charclass_invlists.h"
d51 1
a51 1
strings.  For the uninitiated, this is a method of representing arbitrary
d67 1
a67 3
If C<len> is 0, it will be calculated using C<strlen(s)>, (which means if you
use this option, that C<s> can't have embedded C<NUL> characters and has to
have a terminating C<NUL> byte).
d91 33
a123 1
=for apidoc uvoffuni_to_utf8_flags
d125 8
a132 3
THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
Instead, B<Almost all code should use L</uvchr_to_utf8> or
L</uvchr_to_utf8_flags>>.
d134 3
a136 3
This function is like them, but the input is a strict Unicode
(as opposed to native) code point.  Only in very rare circumstances should code
not be using the native code point.
a137 1
For details, see the description for L</uvchr_to_utf8_flags>>.
d143 1
a143 1
Perl_uvoffuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
d145 1
a145 6
    PERL_ARGS_ASSERT_UVOFFUNI_TO_UTF8_FLAGS;

    if (UNI_IS_INVARIANT(uv)) {
	*d++ = (U8) LATIN1_TO_NATIVE(uv);
	return d;
    }
d149 1
a149 1
        && ckWARN3_d(WARN_SURROGATE, WARN_NON_UNICODE, WARN_NONCHAR))
d184 4
a187 1

d189 2
a190 2
    {
	STRLEN len  = OFFUNISKIP(uv);
d193 1
a193 1
	    *p-- = (U8) I8_TO_NATIVE_UTF8((uv & UTF_CONTINUATION_MASK) | UTF_CONTINUATION_MARK);
d196 1
a196 1
	*p = (U8) I8_TO_NATIVE_UTF8((uv & UTF_START_MASK(len)) | UTF_START_MARK(len));
d235 1
a235 1
#ifdef UTF8_QUAD_MAX
d248 1
a248 1
#ifdef UTF8_QUAD_MAX
a267 80
/*
=for apidoc uvchr_to_utf8

Adds the UTF-8 representation of the native code point C<uv> to the end
of the string C<d>; C<d> should have at least C<UNISKIP(uv)+1> (up to
C<UTF8_MAXBYTES+1>) free bytes available.  The return value is the pointer to
the byte after the end of the new character.  In other words,

    d = uvchr_to_utf8(d, uv);

is the recommended wide native character-aware way of saying

    *(d++) = uv;

This function accepts any UV as input.  To forbid or warn on non-Unicode code
points, or those that may be problematic, see L</uvchr_to_utf8_flags>.

=cut
*/

/* This is also a macro */
PERL_CALLCONV U8*       Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv);

U8 *
Perl_uvchr_to_utf8(pTHX_ U8 *d, UV uv)
{
    return uvchr_to_utf8(d, uv);
}

/*
=for apidoc uvchr_to_utf8_flags

Adds the UTF-8 representation of the native code point C<uv> to the end
of the string C<d>; C<d> should have at least C<UNISKIP(uv)+1> (up to
C<UTF8_MAXBYTES+1>) free bytes available.  The return value is the pointer to
the byte after the end of the new character.  In other words,

    d = uvchr_to_utf8_flags(d, uv, flags);

or, in most cases,

    d = uvchr_to_utf8_flags(d, uv, 0);

This is the Unicode-aware way of saying

    *(d++) = uv;

This function will convert to UTF-8 (and not warn) even code points that aren't
legal Unicode or are problematic, unless C<flags> contains one or more of the
following flags:

If C<uv> is a Unicode surrogate code point and UNICODE_WARN_SURROGATE is set,
the function will raise a warning, provided UTF8 warnings are enabled.  If instead
UNICODE_DISALLOW_SURROGATE is set, the function will fail and return NULL.
If both flags are set, the function will both warn and return NULL.

The UNICODE_WARN_NONCHAR and UNICODE_DISALLOW_NONCHAR flags
affect how the function handles a Unicode non-character.  And likewise, the
UNICODE_WARN_SUPER and UNICODE_DISALLOW_SUPER flags affect the handling of
code points that are
above the Unicode maximum of 0x10FFFF.  Code points above 0x7FFF_FFFF (which are
even less portable) can be warned and/or disallowed even if other above-Unicode
code points are accepted, by the UNICODE_WARN_FE_FF and UNICODE_DISALLOW_FE_FF
flags.

And finally, the flag UNICODE_WARN_ILLEGAL_INTERCHANGE selects all four of the
above WARN flags; and UNICODE_DISALLOW_ILLEGAL_INTERCHANGE selects all four
DISALLOW flags.

=cut
*/

/* This is also a macro */
PERL_CALLCONV U8*       Perl_uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags);

U8 *
Perl_uvchr_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
{
    return uvchr_to_utf8_flags(d, uv, flags);
}
d272 2
a273 2
character.  Note that an INVARIANT (i.e. ASCII on non-EBCDIC) character is a
valid UTF-8 character.  The number of bytes in the UTF-8 character
d296 1
a296 1
    utf8n_to_uvchr(s, len, &actual_len, UTF8_CHECK_ONLY);
d331 1
d334 1
d341 2
d369 3
a371 3
using C<strlen(s)> (which means if you use this option, that C<s> can't have
embedded C<NUL> characters and has to have a terminating C<NUL> byte).  Note
that all characters being ASCII constitute 'a valid UTF-8 string'.
d483 1
a483 4
=for apidoc utf8n_to_uvchr

THIS FUNCTION SHOULD BE USED IN ONLY VERY SPECIALIZED CIRCUMSTANCES.
Most code should use L</utf8_to_uvchr_buf>() rather than call this directly.
d486 1
a486 1
Returns the native code point value of the first character in the string C<s>,
d513 1
a513 1
Note that this API requires disambiguation between successful decoding a C<NUL>
d516 2
a517 2
first byte of C<s> is 0 as well.  If so, the input was a C<NUL>; if not, the
input had an error.
d548 1
a548 2
including these, as malformations.)
Similarly, UTF8_WARN_FE_FF acts just like
d555 2
d561 1
a561 1
Perl_utf8n_to_uvchr(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
d579 1
a579 1
    PERL_ARGS_ASSERT_UTF8N_TO_UVCHR;
d596 1
a596 1
     * returning to the caller C<*retlen> pointing to the very next byte (one
d628 1
a628 1
	return uv;
d647 4
a653 4
#ifdef EBCDIC
    uv = NATIVE_UTF8_TO_I8(uv);
#endif

d745 20
a764 1
#ifndef EBCDIC	/* EBCDIC can't overflow */
d766 5
d777 1
a777 1
	&& expectlen > (STRLEN) OFFUNISKIP(uv)
d785 1
a785 1
	    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "%s (%d byte%s, need %d, after start byte 0x%02x)", malformed_text, (int)expectlen, expectlen == 1 ? "": "s", OFFUNISKIP(uv), *s0));
d790 1
a790 1
    /* Here, the input is considered to be well-formed, but it still could be a
a796 3

            /* By adding UTF8_CHECK_ONLY to the test, we avoid unnecessary
             * generation of the sv, since no warnings are raised under CHECK */
d798 1
a798 1
		&& ckWARN_d(WARN_SURROGATE))
d801 1
a801 1
		pack_warn = packWARN(WARN_SURROGATE);
d809 1
a809 1
                && ckWARN_d(WARN_NON_UNICODE))
d812 1
a812 1
		pack_warn = packWARN(WARN_NON_UNICODE);
a813 21
#ifndef EBCDIC	/* EBCDIC always allows FE, FF */

            /* The first byte being 0xFE or 0xFF is a subset of the SUPER code
             * points.  We test for these after the regular SUPER ones, and
             * before possibly bailing out, so that the more dire warning
             * overrides the regular one, if applicable */
            if ((*s0 & 0xFE) == 0xFE	/* matches both FE, FF */
                && (flags & (UTF8_WARN_FE_FF|UTF8_DISALLOW_FE_FF)))
            {
                if ((flags & (UTF8_WARN_FE_FF|UTF8_CHECK_ONLY))
                                                            == UTF8_WARN_FE_FF
                    && ckWARN_d(WARN_UTF8))
                {
                    sv = sv_2mortal(Perl_newSVpvf(aTHX_ "Code point 0x%"UVXf" is not Unicode, and not portable", uv));
                    pack_warn = packWARN(WARN_UTF8);
                }
                if (flags & UTF8_DISALLOW_FE_FF) {
                    goto disallowed;
                }
            }
#endif
d820 1
a820 1
		&& ckWARN_d(WARN_NONCHAR))
d823 1
a823 1
		pack_warn = packWARN(WARN_NONCHAR);
d831 1
a831 3
            outlier_ret = uv;   /* Note we don't bother to convert to native,
                                   as all the outlier code points are the same
                                   in both ASCII and EBCDIC */
d839 1
a839 1
    return UNI_TO_NATIVE(uv);
d913 1
a913 1
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is
d923 2
d933 2
a934 1
 * non-character code points, and non-Unicode code points are allowed. */
d939 1
a939 3
    UV expectlen = UTF8SKIP(s);
    const U8* send = s + expectlen;
    UV uv = *s;
a942 24
    if (retlen) {
        *retlen = expectlen;
    }

    /* An invariant is trivially returned */
    if (expectlen == 1) {
	return uv;
    }

#ifdef EBCDIC
    uv = NATIVE_UTF8_TO_I8(uv);
#endif

    /* Remove the leading bits that indicate the number of bytes, leaving just
     * the bits that are part of the value */
    uv &= UTF_START_MASK(expectlen);

    /* Now, loop through the remaining bytes, accumulating each into the
     * working total as we go.  (I khw tried unrolling the loop for up to 4
     * bytes, but there was no performance improvement) */
    for (++s; s < send; s++) {
        uv = UTF8_ACCUMULATE(uv, *s);
    }

a943 1

d949 2
d965 1
a965 1
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.
d981 1
a981 6
Only in very rare circumstances should code need to be dealing in Unicode
(as opposed to native) code points.  In those few cases, use
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|/utf8_to_uvchr_buf>> instead.

Returns the Unicode (not-native) code point of the first character in the
string C<s> which
d985 3
d994 1
a994 1
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.
d1007 2
a1008 2
    return NATIVE_TO_UNI(Perl_utf8n_to_uvchr(aTHX_ s, send -s, retlen,
			       ckWARN_d(WARN_UTF8) ? 0 : UTF8_ALLOW_ANY));
d1011 1
a1011 2
/* DEPRECATED!
 * Like L</utf8_to_uvuni_buf>(), but should only be called when it is known that
d1018 4
d1024 21
a1044 1
    return NATIVE_TO_UNI(valid_utf8_to_uvchr(s, retlen));
d1050 2
d1056 3
d1061 1
a1061 3
is one reason why this function is deprecated.  The other is that only in
extremely limited circumstances should the Unicode versus native code point be
of any interest to you.  See L</utf8_to_uvuni_buf> for alternatives.
d1069 1
a1069 1
See L</utf8n_to_uvchr> for details on when the REPLACEMENT CHARACTER is returned.
d1079 1
a1079 1
    return NATIVE_TO_UNI(valid_utf8_to_uvchr(s, retlen));
d1185 1
a1185 2
sequence of characters (stored as UTF-8)
in C<u>, C<ulen>.  Returns 0 if they are
d1190 1
a1190 2
longer string.  -2 or +2 is returned if
there was a difference between characters
d1213 1
a1213 1
			c = TWO_BYTE_UTF8_TO_NATIVE(c, c1);
d1273 7
a1279 6
        if (! UTF8_IS_INVARIANT(*s)) {
            if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(s, send)) {
                *len = ((STRLEN) -1);
                return 0;
            }
            s++;
a1280 1
        s++;
d1285 3
a1287 7
	U8 c = *s++;
	if (! UTF8_IS_INVARIANT(c)) {
	    /* Then it is two-byte encoded */
	    c = TWO_BYTE_UTF8_TO_NATIVE(c, *s);
            s++;
	}
	*d++ = c;
d1301 1
a1301 1
is unchanged.  Do nothing if C<is_utf8> points to 0.  Sets C<is_utf8> to
d1324 6
a1329 2
        if (! UTF8_IS_INVARIANT(*s)) {
            if (! UTF8_IS_NEXT_CHAR_DOWNGRADEABLE(s, send)) {
a1330 3
            }
            count++;
            s++;
a1331 1
        s++;
d1340 1
a1340 1
	if (! UTF8_IS_INVARIANT(c)) {
d1342 1
a1342 2
	    c = TWO_BYTE_UTF8_TO_NATIVE(c, *s);
            s++;
d1359 1
a1359 1
A C<NUL> character will be written after the end of the string.
d1385 7
a1391 2
        append_utf8_from_native_byte(*s, &d);
        s++;
d1420 6
a1425 2
	if (UNI_IS_INVARIANT(uv)) {
	    *d++ = LATIN1_TO_NATIVE((U8) uv);
d1428 3
a1430 3
	if (uv <= MAX_UTF8_TWO_BYTE) {
	    *d++ = UTF8_TWO_BYTE_HI(UNI_TO_NATIVE(uv));
	    *d++ = UTF8_TWO_BYTE_LO(UNI_TO_NATIVE(uv));
d1433 1
a1433 5
#define FIRST_HIGH_SURROGATE UNICODE_SURROGATE_FIRST
#define LAST_HIGH_SURROGATE  0xDBFF
#define FIRST_LOW_SURROGATE  0xDC00
#define LAST_LOW_SURROGATE   UNICODE_SURROGATE_LAST
	if (uv >= FIRST_HIGH_SURROGATE && uv <= LAST_HIGH_SURROGATE) {
d1439 1
a1439 1
		if (low < FIRST_LOW_SURROGATE || low > LAST_LOW_SURROGATE)
d1441 1
a1441 2
		uv = ((uv - FIRST_HIGH_SURROGATE) << 10)
                                       + (low - FIRST_LOW_SURROGATE) + 0x10000;
d1443 1
a1443 1
	} else if (uv >= FIRST_LOW_SURROGATE && uv <= LAST_LOW_SURROGATE) {
a1445 3
#ifdef EBCDIC
        d = uvoffuni_to_utf8_flags(d, uv, 0);
#else
a1458 1
#endif
d1495 20
d1526 1
a1526 1
    return is_utf8_common(p, &PL_utf8_idstart, "IdStart", NULL);
d1553 10
a1562 2
UV
Perl__to_upper_title_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp, const char S_or_s)
d1564 2
a1565 5
    /* We have the latin1-range values compiled into the core, so just use
     * those, converting the result to utf8.  The only difference between upper
     * and title case in this range is that LATIN_SMALL_LETTER_SHARP_S is
     * either "SS" or "Ss".  Which one to use is passed into the routine in
     * 'S_or_s' to avoid a test */
d1567 5
a1571 1
    UV converted = toUPPER_LATIN1_MOD(c);
d1573 5
a1577 1
    PERL_ARGS_ASSERT__TO_UPPER_TITLE_LATIN1;
d1579 7
a1585 1
    assert(S_or_s == 'S' || S_or_s == 's');
d1587 73
a1659 6
    if (UVCHR_IS_INVARIANT(converted)) { /* No difference between the two for
					     characters in this range */
	*p = (U8) converted;
	*lenp = 1;
	return converted;
    }
d1698 3
a1700 3
#define CALL_UPPER_CASE(INP, OUTP, LENP) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_toupper, "ToUc", "")
#define CALL_TITLE_CASE(INP, OUTP, LENP) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_totitle, "ToTc", "")
#define CALL_LOWER_CASE(INP, OUTP, LENP) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_tolower, "ToLc", "")
d1705 1
a1705 1
#define CALL_FOLD_CASE(INP, OUTP, LENP, SPECIALS) Perl_to_utf8_case(aTHX_ INP, OUTP, LENP, &PL_utf8_tofold, "ToCf", (SPECIALS) ? "" : NULL)
d1755 1
a1755 1
	if (NATIVE_BYTE_IS_INVARIANT(converted)) {
d1784 1
a1784 1
Perl__to_fold_latin1(pTHX_ const U8 c, U8* p, STRLEN *lenp, const unsigned int flags)
d1786 2
a1787 6
    /* Corresponds to to_lower_latin1(); <flags> bits meanings:
     *	    FOLD_FLAGS_NOMIX_ASCII iff non-ASCII to ASCII folds are prohibited
     *	    FOLD_FLAGS_FULL  iff full folding is to be used;
     *
     *	Not to be used for locale folds
     */
a1792 2
    assert (! (flags & FOLD_FLAGS_LOCALE));

d1796 5
a1800 17
    else if ((flags & FOLD_FLAGS_FULL) && c == LATIN_SMALL_LETTER_SHARP_S) {

        /* If can't cross 127/128 boundary, can't return "ss"; instead return
         * two U+017F characters, as fc("\df") should eq fc("\x{17f}\x{17f}")
         * under those circumstances. */
        if (flags & FOLD_FLAGS_NOMIX_ASCII) {
            *lenp = 2 * sizeof(LATIN_SMALL_LETTER_LONG_S_UTF8) - 2;
            Copy(LATIN_SMALL_LETTER_LONG_S_UTF8 LATIN_SMALL_LETTER_LONG_S_UTF8,
                 p, *lenp, U8);
            return LATIN_SMALL_LETTER_LONG_S;
        }
        else {
            *(p)++ = 's';
            *p = 's';
            *lenp = 2;
            return 's';
        }
d1807 1
a1807 1
    if (UVCHR_IS_INVARIANT(converted)) {
d1821 1
a1821 1
Perl__to_uni_fold_flags(pTHX_ UV c, U8* p, STRLEN *lenp, U8 flags)
d1827 389
a2215 4
     *	    FOLD_FLAGS_LOCALE is set iff the rules from the current underlying
     *	                      locale are to be used.
     *	    FOLD_FLAGS_NOMIX_ASCII iff non-ASCII to ASCII folds are prohibited
     */
d2217 4
a2220 1
    PERL_ARGS_ASSERT__TO_UNI_FOLD_FLAGS;
d2222 4
a2225 4
    /* Tread a UTF-8 locale as not being in locale at all */
    if (IN_UTF8_CTYPE_LOCALE) {
        flags &= ~FOLD_FLAGS_LOCALE;
    }
d2227 1
a2227 9
    if (c < 256) {
	UV result = _to_fold_latin1((U8) c, p, lenp,
			    flags & (FOLD_FLAGS_FULL | FOLD_FLAGS_NOMIX_ASCII));
	/* It is illegal for the fold to cross the 255/256 boundary under
	 * locale; in this case return the original */
	return (result > 256 && flags & FOLD_FLAGS_LOCALE)
	       ? c
	       : result;
    }
d2229 3
a2231 11
    /* If no special needs, just use the macro */
    if ( ! (flags & (FOLD_FLAGS_LOCALE|FOLD_FLAGS_NOMIX_ASCII))) {
	uvchr_to_utf8(p, c);
	return CALL_FOLD_CASE(p, p, lenp, flags & FOLD_FLAGS_FULL);
    }
    else {  /* Otherwise, _to_utf8_fold_flags has the intelligence to deal with
	       the special flags. */
	U8 utf8_c[UTF8_MAXBYTES + 1];
	uvchr_to_utf8(utf8_c, c);
	return _to_utf8_fold_flags(utf8_c, p, lenp, flags);
    }
d2234 2
a2235 3
PERL_STATIC_INLINE bool
S_is_utf8_common(pTHX_ const U8 *const p, SV **swash,
		 const char *const swashname, SV* const invlist)
a2236 13
    /* returns a boolean giving whether or not the UTF8-encoded character that
     * starts at <p> is in the swash indicated by <swashname>.  <swash>
     * contains a pointer to where the swash indicated by <swashname>
     * is to be stored; which this routine will do, so that future calls will
     * look at <*swash> and only generate a swash if it is not null.  <invlist>
     * is NULL or an inversion list that defines the swash.  If not null, it
     * saves time during initialization of the swash.
     *
     * Note that it is assumed that the buffer length of <p> is enough to
     * contain all the bytes that comprise the character.  Thus, <*p> should
     * have been checked before this call for mal-formedness enough to assure
     * that. */

d2239 1
a2239 1
    PERL_ARGS_ASSERT_IS_UTF8_COMMON;
d2241 2
a2242 19
    /* The API should have included a length for the UTF-8 character in <p>,
     * but it doesn't.  We therefore assume that p has been validated at least
     * as far as there being enough bytes available in it to accommodate the
     * character without reading beyond the end, and pass that number on to the
     * validating routine */
    if (! is_utf8_char_buf(p, p + UTF8SKIP(p))) {
        if (ckWARN_d(WARN_UTF8)) {
            Perl_warner(aTHX_ packWARN2(WARN_DEPRECATED,WARN_UTF8),
		    "Passing malformed UTF-8 to \"%s\" is deprecated", swashname);
            if (ckWARN(WARN_UTF8)) {    /* This will output details as to the
                                           what the malformation is */
                utf8_to_uvchr_buf(p, p + UTF8SKIP(p), NULL);
            }
        }
        return FALSE;
    }
    if (!*swash) {
        U8 flags = _CORE_SWASH_INIT_ACCEPT_INVLIST;
        *swash = _core_swash_init("utf8",
d2244 4
a2247 3
                                  /* Only use the name if there is no inversion
                                   * list; otherwise will go out to disk */
                                  (invlist) ? "" : swashname,
d2249 1
a2249 2
                                  &PL_sv_undef, 1, 0, invlist, &flags);
    }
d2251 3
a2253 1
    return swash_fetch(*swash, p, TRUE) != 0;
d2257 1
a2257 1
Perl__is_utf8_FOO(pTHX_ const U8 classnum, const U8 *p)
d2261 1
a2261 3
    PERL_ARGS_ASSERT__IS_UTF8_FOO;

    assert(classnum < _FIRST_NON_SWASH_CC);
d2263 1
a2263 4
    return is_utf8_common(p,
                          &PL_utf8_swash_ptrs[classnum],
                          swash_property_names[classnum],
                          PL_XPosix_ptrs[classnum]);
d2267 1
a2267 1
Perl_is_utf8_idfirst(pTHX_ const U8 *p) /* The naming is historical. */
d2271 1
a2271 1
    PERL_ARGS_ASSERT_IS_UTF8_IDFIRST;
d2273 1
a2273 1
    return S_is_utf8_idfirst(aTHX_ p);
d2277 1
a2277 1
Perl_is_utf8_xidfirst(pTHX_ const U8 *p) /* The naming is historical. */
d2281 1
a2281 1
    PERL_ARGS_ASSERT_IS_UTF8_XIDFIRST;
d2283 1
a2283 4
    if (*p == '_')
	return TRUE;
    /* is_utf8_idstart would be more logical. */
    return is_utf8_common(p, &PL_utf8_xidstart, "XIdStart", NULL);
d2287 1
a2287 1
Perl__is_utf8_perl_idstart(pTHX_ const U8 *p)
a2289 1
    SV* invlist = NULL;
d2291 1
a2291 1
    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART;
d2293 1
a2293 4
    if (! PL_utf8_perl_idstart) {
        invlist = _new_invlist_C_array(_Perl_IDStart_invlist);
    }
    return is_utf8_common(p, &PL_utf8_perl_idstart, "", invlist);
d2297 1
a2297 1
Perl__is_utf8_perl_idcont(pTHX_ const U8 *p)
a2299 1
    SV* invlist = NULL;
d2301 1
a2301 1
    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDCONT;
d2303 1
a2303 4
    if (! PL_utf8_perl_idcont) {
        invlist = _new_invlist_C_array(_Perl_IDCont_invlist);
    }
    return is_utf8_common(p, &PL_utf8_perl_idcont, "", invlist);
a2305 1

d2307 1
a2307 1
Perl_is_utf8_idcont(pTHX_ const U8 *p)
d2311 1
a2311 1
    PERL_ARGS_ASSERT_IS_UTF8_IDCONT;
d2313 1
a2313 1
    return is_utf8_common(p, &PL_utf8_idcont, "IdContinue", NULL);
d2317 1
a2317 1
Perl_is_utf8_xidcont(pTHX_ const U8 *p)
d2321 1
a2321 1
    PERL_ARGS_ASSERT_IS_UTF8_XIDCONT;
d2323 1
a2323 1
    return is_utf8_common(p, &PL_utf8_idcont, "XIdContinue", NULL);
d2333 12
a2344 1
    return is_utf8_common(p, &PL_utf8_mark, "IsM", NULL);
d2350 1
a2350 1
C<p> contains the pointer to the UTF-8 string encoding
d2354 2
a2355 2
C<ustrp> is a pointer to the character buffer to put the
conversion result to.  C<lenp> is a pointer to the length
d2358 1
a2358 1
C<swashp> is a pointer to the swash to use.
d2361 1
a2361 1
and loaded by SWASHNEW, using F<lib/utf8_heavy.pl>.  C<special> (usually,
d2364 3
a2366 4
C<special> is a string, normally C<NULL> or C<"">.  C<NULL> means to not use
any special mappings; C<""> means to use the special mappings.  Values other
than these two are treated as the name of the hash containing the special
mappings, like C<"utf8::ToSpecLower">.
d2368 1
a2368 1
C<normal> is a string like "ToLower" which means the swash
d2378 1
d2380 5
a2384 1
    const UV uv1 = valid_utf8_to_uvchr(p, NULL);
d2410 2
d2418 1
a2418 1
         HV *hv = NULL;
d2421 3
a2423 16
	 /* If passed in the specials name, use that; otherwise use any
	  * given in the swash */
         if (*special != '\0') {
            hv = get_hv(special, 0);
        }
        else {
            svp = hv_fetchs(MUTABLE_HV(SvRV(*swashp)), "SPECIALS", 0);
            if (svp) {
                hv = MUTABLE_HV(SvRV(*svp));
            }
        }

	 if (hv
             && (svp = hv_fetch(hv, (const char*)p, UNISKIP(uv1), FALSE))
             && (*svp))
         {
d2428 1
a2428 2
                  /* EIGHTBIT */
		   len = uvchr_to_utf8(ustrp, *(U8*)s) - ustrp;
d2430 29
d2460 1
d2466 1
a2466 1
	const UV uv2 = swash_fetch(*swashp, p, TRUE /* => is utf8 */);
d2470 2
a2471 1
	      len = uvchr_to_utf8(ustrp, uv2) - ustrp;
d2492 1
a2492 1
    return uv1;
d2500 3
a2502 4
     * the Latin1 range, and the operation is in a non-UTF-8 locale.  If the
     * result contains a character that crosses the 255/256 boundary, disallow
     * the change, and return the original code point.  See L<perlfunc/lc> for
     * why;
d2514 1
a2514 1
    assert(UTF8_IS_ABOVE_LATIN1(*p));
d2525 2
a2526 1
	    if (! UTF8_IS_ABOVE_LATIN1(*s)) {
d2547 9
a2555 1
Instead use L</toUPPER_utf8>.
d2560 3
a2562 2
 * <flags> is set iff iff the rules from the current underlying locale are to
 *         be used. */
d2565 1
a2565 1
Perl__to_utf8_upper_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
a2572 4
    if (flags && IN_UTF8_CTYPE_LOCALE) {
        flags = FALSE;
    }

d2583 1
a2583 2
            U8 c = TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toUPPER_LC(c);
d2586 1
a2586 1
	    return _to_upper_title_latin1(TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1)),
d2605 2
a2606 2
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
d2610 3
d2619 9
a2627 1
Instead use L</toTITLE_utf8>.
d2632 5
a2636 4
 * <flags> is set iff the rules from the current underlying locale are to be
 *         used.  Since titlecase is not defined in POSIX, for other than a
 *         UTF-8 locale, uppercase is used instead for code points < 256.
 */
d2639 1
a2639 1
Perl__to_utf8_title_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
a2646 4
    if (flags && IN_UTF8_CTYPE_LOCALE) {
        flags = FALSE;
    }

d2657 1
a2657 2
            U8 c = TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toUPPER_LC(c);
d2660 1
a2660 1
	    return _to_upper_title_latin1(TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1)),
d2679 2
a2680 2
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
d2684 3
d2693 9
a2701 1
Instead use L</toLOWER_utf8>.
d2706 3
a2708 3
 * <flags> is set iff iff the rules from the current underlying locale are to
 *         be used.
 */
d2711 1
a2711 1
Perl__to_utf8_lower_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, bool flags)
a2718 4
    if (flags && IN_UTF8_CTYPE_LOCALE) {
        flags = FALSE;
    }

d2729 1
a2729 2
            U8 c = TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toLOWER_LC(c);
d2732 1
a2732 1
	    return to_lower_latin1(TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1)),
d2752 2
a2753 2
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
d2757 3
d2766 10
a2775 1
Instead use L</toFOLD_utf8>.
d2781 3
a2783 2
 *	bit FOLD_FLAGS_LOCALE is set iff the rules from the current underlying
 *	                      locale are to be used.
d2788 2
a2789 1
 */
d2792 1
a2792 1
Perl__to_utf8_fold_flags(pTHX_ const U8 *p, U8* ustrp, STRLEN *lenp, U8 flags)
a2804 4
    if (flags & FOLD_FLAGS_LOCALE && IN_UTF8_CTYPE_LOCALE) {
        flags &= ~FOLD_FLAGS_LOCALE;
    }

d2807 1
a2807 1
	    result = toFOLD_LC(*p);
d2811 1
a2811 1
                            flags & (FOLD_FLAGS_FULL | FOLD_FLAGS_NOMIX_ASCII));
d2816 1
a2816 2
            U8 c = TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1));
	    result = toFOLD_LC(c);
d2819 9
a2827 3
	    return _to_fold_latin1(TWO_BYTE_UTF8_TO_NATIVE(*p, *(p+1)),
                            ustrp, lenp,
                            flags & (FOLD_FLAGS_FULL | FOLD_FLAGS_NOMIX_ASCII));
d2833 1
a2833 16
	if (flags & FOLD_FLAGS_LOCALE) {

            /* Special case these two characters, as what normally gets
             * returned under locale doesn't work */
            if (UTF8SKIP(p) == sizeof(LATIN_CAPITAL_LETTER_SHARP_S_UTF8) - 1
                && memEQ((char *) p, LATIN_CAPITAL_LETTER_SHARP_S_UTF8,
                          sizeof(LATIN_CAPITAL_LETTER_SHARP_S_UTF8) - 1))
            {
                goto return_long_s;
            }
            else if (UTF8SKIP(p) == sizeof(LATIN_SMALL_LIGATURE_LONG_S_T) - 1
                && memEQ((char *) p, LATIN_SMALL_LIGATURE_LONG_S_T_UTF8,
                          sizeof(LATIN_SMALL_LIGATURE_LONG_S_T_UTF8) - 1))
            {
                goto return_ligature_st;
            }
d2841 2
a2842 2
             * character above the ASCII range, and the result should not
             * contain an ASCII character. */
a2853 11

                    /* But in these instances, there is an alternative we can
                     * return that is valid */
                    if (original == LATIN_CAPITAL_LETTER_SHARP_S
                        || original == LATIN_SMALL_LETTER_SHARP_S)
                    {
                        goto return_long_s;
                    }
                    else if (original == LATIN_SMALL_LIGATURE_LONG_S_T) {
                        goto return_ligature_st;
                    }
d2871 2
a2872 2
	*ustrp = UTF8_EIGHT_BIT_HI((U8) result);
	*(ustrp + 1) = UTF8_EIGHT_BIT_LO((U8) result);
d2876 3
a2879 20

  return_long_s:
    /* Certain folds to 'ss' are prohibited by the options, but they do allow
     * folds to a string of two of these characters.  By returning this
     * instead, then, e.g.,
     *      fc("\x{1E9E}") eq fc("\x{17F}\x{17F}")
     * works. */

    *lenp = 2 * sizeof(LATIN_SMALL_LETTER_LONG_S_UTF8) - 2;
    Copy(LATIN_SMALL_LETTER_LONG_S_UTF8 LATIN_SMALL_LETTER_LONG_S_UTF8,
        ustrp, *lenp, U8);
    return LATIN_SMALL_LETTER_LONG_S;

  return_ligature_st:
    /* Two folds to 'st' are prohibited by the options; instead we pick one and
     * have the other one fold to it */

    *lenp = sizeof(LATIN_SMALL_LIGATURE_ST_UTF8) - 1;
    Copy(LATIN_SMALL_LIGATURE_ST_UTF8, ustrp, *lenp, U8);
    return LATIN_SMALL_LIGATURE_ST;
d2941 1
a2941 3
     * actions can intersect, etc. what <name> gives.  To avoid going out to
     * disk at all, <invlist> should specify completely what the swash should
     * have, and <listsv> should be &PL_sv_undef and <name> should be "".
d3123 1
a3123 1
         * touched; otherwise save the computed one */
a3135 2
        SvREADONLY_on(swash_invlist);

d3160 2
a3161 2
 * assumed to be in well-formed utf8. If C<do_utf8> is false, the string C<ptr>
 * is assumed to be in native 8-bit encoding. Caches the swatch in C<swash>.
d3198 1
a3198 1
    STRLEN slen = 0;
d3203 2
a3204 1
    const U8 c = *ptr;
d3217 20
a3236 16
    /* We store the values in a "swatch" which is a vec() value in a swash
     * hash.  Code points 0-255 are a single vec() stored with key length
     * (klen) 0.  All other code points have a UTF-8 representation
     * 0xAA..0xYY,0xZZ.  A vec() is constructed containing all of them which
     * share 0xAA..0xYY, which is the key in the hash to that vec.  So the key
     * length for them is the length of the encoded char - 1.  ptr[klen] is the
     * final byte in the sequence representing the character */
    if (!do_utf8 || UTF8_IS_INVARIANT(c)) {
        klen = 0;
	needents = 256;
        off = c;
    }
    else if (UTF8_IS_DOWNGRADEABLE_START(c)) {
        klen = 0;
	needents = 256;
        off = TWO_BYTE_UTF8_TO_NATIVE(c, *(ptr + 1));
d3239 1
a3239 34
        klen = UTF8SKIP(ptr) - 1;

        /* Each vec() stores 2**UTF_ACCUMULATION_SHIFT values.  The offset into
         * the vec is the final byte in the sequence.  (In EBCDIC this is
         * converted to I8 to get consecutive values.)  To help you visualize
         * all this:
         *                       Straight 1047   After final byte
         *             UTF-8      UTF-EBCDIC     I8 transform
         *  U+0400:  \xD0\x80    \xB8\x41\x41    \xB8\x41\xA0
         *  U+0401:  \xD0\x81    \xB8\x41\x42    \xB8\x41\xA1
         *    ...
         *  U+0409:  \xD0\x89    \xB8\x41\x4A    \xB8\x41\xA9
         *  U+040A:  \xD0\x8A    \xB8\x41\x51    \xB8\x41\xAA
         *    ...
         *  U+0412:  \xD0\x92    \xB8\x41\x59    \xB8\x41\xB2
         *  U+0413:  \xD0\x93    \xB8\x41\x62    \xB8\x41\xB3
         *    ...
         *  U+041B:  \xD0\x9B    \xB8\x41\x6A    \xB8\x41\xBB
         *  U+041C:  \xD0\x9C    \xB8\x41\x70    \xB8\x41\xBC
         *    ...
         *  U+041F:  \xD0\x9F    \xB8\x41\x73    \xB8\x41\xBF
         *  U+0420:  \xD0\xA0    \xB8\x42\x41    \xB8\x42\x41
         *
         * (There are no discontinuities in the elided (...) entries.)
         * The UTF-8 key for these 33 code points is '\xD0' (which also is the
         * key for the next 31, up through U+043F, whose UTF-8 final byte is
         * \xBF).  Thus in UTF-8, each key is for a vec() for 64 code points.
         * The final UTF-8 byte, which ranges between \x80 and \xBF, is an
         * index into the vec() swatch (after subtracting 0x80, which we
         * actually do with an '&').
         * In UTF-EBCDIC, each key is for a 32 code point vec().  The first 32
         * code points above have key '\xB8\x41'. The final UTF-EBCDIC byte has
         * dicontinuities which go away by transforming it into I8, and we
         * effectively subtract 0xA0 to get the index. */
d3241 1
a3241 1
	off      = NATIVE_UTF8_TO_I8(ptr[klen]) & UTF_CONTINUATION_MASK;
d3266 11
a3276 12
		 || !(tmps = (const U8*)SvPV_const(*svp, slen)))
        {
            if (klen) {
                const UV code_point = valid_utf8_to_uvchr(ptr, NULL);
                swatch = swatch_get(swash,
                                    code_point & ~((UV)needents - 1),
				    needents);
            }
            else {  /* For the first 256 code points, the swatch has a key of
                       length 0 */
                swatch = swatch_get(swash, 0, needents);
            }
d3376 1
a3376 1
	 * range maps to.  The map for those currently read here is in hex */
d3380 20
a3399 9
                flags = PERL_SCAN_SILENT_ILLDIGIT
                    | PERL_SCAN_DISALLOW_PREFIX
                    | PERL_SCAN_SILENT_NON_PORTABLE;
                numlen = lend - l;
                *val = grok_hex((char *)l, &numlen, &flags, NULL);
                if (numlen)
                    l += numlen;
                else
                    *val = 0;
d3768 1
a3768 1
    * have two elements, the utf8 for itself, and for 004C.  For 006B, there
a3770 3
    * Note that there are no elements in the hash for 004B, 004C, 212A.  The
    * keys are only code points that are folded-to, so it isn't a full closure.
    *
d3890 2
a3891 2
	    if (av_tindex(from_list) > 0) {
		SSize_t i;
d3895 2
a3896 2
		for (i = 0; i <= av_tindex(from_list); i++) {
		    SSize_t j;
d3911 2
a3912 2
		    /* For DEBUG_U: UV u = valid_utf8_to_uvchr((U8*) SvPVX(*entryp), 0);*/
		    for (j = 0; j <= av_tindex(from_list); j++) {
d3955 1
a3955 1
	    char* key_end = (char *) uvchr_to_utf8((U8*) key, val);
d3971 1
a3971 1
	    for (i = 0; i <= av_tindex(list); i++) {
d4082 8
a4089 13
    if (*l == 'V') {    /*  Inversion list format */
        char *after_strtol = (char *) lend;
        UV element0;
        UV* other_elements_ptr;

        /* The first number is a count of the rest */
        l++;
        elements = Strtoul((char *)l, &after_strtol, 10);
        if (elements == 0) {
            invlist = _new_invlist(0);
        }
        else {
            l = (U8 *) after_strtol;
d4091 6
a4096 15
            /* Get the 0th element, which is needed to setup the inversion list */
            element0 = (UV) Strtoul((char *)l, &after_strtol, 10);
            l = (U8 *) after_strtol;
            invlist = _setup_canned_invlist(elements, element0, &other_elements_ptr);
            elements--;

            /* Then just populate the rest of the input */
            while (elements-- > 0) {
                if (l > lend) {
                    Perl_croak(aTHX_ "panic: Expecting %"UVuf" more elements than available", elements);
                }
                *other_elements_ptr++ = (UV) Strtoul((char *)l, &after_strtol, 10);
                l = (U8 *) after_strtol;
            }
        }
a4097 1
    else {
d4099 1
a4099 8
        /* Scan the input to count the number of lines to preallocate array
         * size based on worst possible case, which is each line in the input
         * creates 2 elements in the inversion list: 1) the beginning of a
         * range in the list; 2) the beginning of a range not in the list.  */
        while ((loc = (strchr(loc, '\n'))) != NULL) {
            elements += 2;
            loc++;
        }
d4101 4
a4104 7
        /* If the ending is somehow corrupt and isn't a new line, add another
         * element for the final range that isn't in the inversion list */
        if (! (*lend == '\n'
            || (*lend == '\0' && (lcur == 0 || *(lend - 1) == '\n'))))
        {
            elements++;
        }
d4106 2
a4107 1
        invlist = _new_invlist(elements);
d4109 3
a4111 4
        /* Now go through the input again, adding each range to the list */
        while (l < lend) {
            UV start, end;
            UV val;		/* Not used by this function */
d4113 1
a4113 9
            l = S_swash_scan_list_line(aTHX_ l, lend, &start, &end, &val,
                                            cBOOL(octets), typestr);

            if (l > lend) {
                break;
            }

            invlist = _add_range_to_invlist(invlist, start, end);
        }
d4118 1
a4118 1
	_invlist_invert(invlist);
a4194 1
    SvREADONLY_on(invlist);
d4223 62
d4491 7
a4497 5
 *  FOLDEQ_LOCALE	    is set iff the rules from the current underlying
 *	                    locale are to be used.
 *  FOLDEQ_S1_ALREADY_FOLDED  s1 has already been folded before calling this
 *                            routine.  This allows that step to be skipped.
 *  FOLDEQ_S2_ALREADY_FOLDED  Similarly.
d4517 4
a4520 16
    assert( ! ((flags & (FOLDEQ_UTF8_NOMIX_ASCII | FOLDEQ_LOCALE))
           && (flags & (FOLDEQ_S1_ALREADY_FOLDED | FOLDEQ_S2_ALREADY_FOLDED))));
    /* The algorithm is to trial the folds without regard to the flags on
     * the first line of the above assert(), and then see if the result
     * violates them.  This means that the inputs can't be pre-folded to a
     * violating result, hence the assert.  This could be changed, with the
     * addition of extra tests here for the already-folded case, which would
     * slow it down.  That cost is more than any possible gain for when these
     * flags are specified, as the flags indicate /il or /iaa matching which
     * is less common than /iu, and I (khw) also believe that real-world /il
     * and /iaa matches are most likely to involve code points 0-255, and this
     * function only under rare conditions gets called for 0-255. */

    if (IN_UTF8_CTYPE_LOCALE) {
        flags &= ~FOLDEQ_LOCALE;
    }
d4582 3
a4584 2
		if ((flags & FOLDEQ_LOCALE)
		    && (! u1 || ! UTF8_IS_ABOVE_LATIN1(*p1)))
d4587 3
a4589 1
		    if (u2 && UTF8_IS_ABOVE_LATIN1(*p2)) {
d4599 1
a4599 1
			*foldbuf1 = TWO_BYTE_UTF8_TO_NATIVE(*p1, *(p1 + 1));
d4612 2
a4613 1
		    *foldbuf1 = toFOLD(*p1);
d4619 1
a4619 1
		    to_uni_fold(*p1, foldbuf1, &n1);
d4631 2
a4632 2
		if ((flags & FOLDEQ_LOCALE)
		    && (! u2 || ! UTF8_IS_ABOVE_LATIN1(*p2)))
d4636 3
a4638 1
		    if (u1 && UTF8_IS_ABOVE_LATIN1(*p1)) {
d4645 1
a4645 1
			*foldbuf2 = TWO_BYTE_UTF8_TO_NATIVE(*p2, *(p2 + 1));
d4660 1
a4660 1
		    *foldbuf2 = toFOLD(*p2);
d4666 1
a4666 1
		    to_uni_fold(*p2, foldbuf2, &n2);
a4721 60

/* XXX The next four functions should likely be moved to mathoms.c once all
 * occurrences of them are removed from the core; some cpan-upstream modules
 * still use them */

U8 *
Perl_uvuni_to_utf8(pTHX_ U8 *d, UV uv)
{
    PERL_ARGS_ASSERT_UVUNI_TO_UTF8;

    return Perl_uvoffuni_to_utf8_flags(aTHX_ d, uv, 0);
}

UV
Perl_utf8n_to_uvuni(pTHX_ const U8 *s, STRLEN curlen, STRLEN *retlen, U32 flags)
{
    PERL_ARGS_ASSERT_UTF8N_TO_UVUNI;

    return NATIVE_TO_UNI(utf8n_to_uvchr(s, curlen, retlen, flags));
}

/*
=for apidoc uvuni_to_utf8_flags

Instead you almost certainly want to use L</uvchr_to_utf8> or
L</uvchr_to_utf8_flags>>.

This function is a deprecated synonym for L</uvoffuni_to_utf8_flags>,
which itself, while not deprecated, should be used only in isolated
circumstances.  These functions were useful for code that wanted to handle
both EBCDIC and ASCII platforms with Unicode properties, but starting in Perl
v5.20, the distinctions between the platforms have mostly been made invisible
to most code, so this function is quite unlikely to be what you want.

=cut
*/

U8 *
Perl_uvuni_to_utf8_flags(pTHX_ U8 *d, UV uv, UV flags)
{
    PERL_ARGS_ASSERT_UVUNI_TO_UTF8_FLAGS;

    return uvoffuni_to_utf8_flags(d, uv, flags);
}

/*
=for apidoc utf8n_to_uvuni

Instead use L</utf8_to_uvchr_buf>, or rarely, L</utf8n_to_uvchr>.

This function was useful for code that wanted to handle both EBCDIC and
ASCII platforms with Unicode properties, but starting in Perl v5.20, the
distinctions between the platforms have mostly been made invisible to most
code, so this function is quite unlikely to be what you want.  If you do need
this precise functionality, use instead
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|/utf8_to_uvchr_buf>>
or C<L<NATIVE_TO_UNI(utf8n_to_uvchr(...))|/utf8n_to_uvchr>>.

=cut
*/
@


1.1.1.14
log
@Import perl-5.20.2
@
text
@a2511 8

    /*NOTE NOTE NOTE - If you want to use "return" in this routine you MUST
     * use the following define */

#define CORE_SWASH_INIT_RETURN(x)   \
    PL_curpm= old_PL_curpm;         \
    return x

a2556 2
    PMOP *old_PL_curpm= PL_curpm; /* save away the old PL_curpm */

a2567 4
    PL_curpm= NULL; /* reset PL_curpm so that we dont get confused between the regex
                       that triggered the swash init and the swash init perl logic itself.
                       See perl #122747 */

d2656 1
a2656 1
                    CORE_SWASH_INIT_RETURN(NULL);
d2758 1
a2758 2
    CORE_SWASH_INIT_RETURN(retval);
#undef CORE_SWASH_INIT_RETURN
@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d34 2
a35 1
#include "invlist_inline.h"
a38 4
static const char cp_above_legal_max[] =
 "Use of code point 0x%"UVXf" is deprecated; the permissible max is 0x%"UVXf"";

#define MAX_NON_DEPRECATED_CP ((UV) (IV_MAX))
d42 2
a43 1
These are various utility functions for manipulating UTF8-encoded
d53 1
a53 1
=for apidoc is_invariant_string
d55 4
a58 7
Returns true iff the first C<len> bytes of the string C<s> are the same
regardless of the UTF-8 encoding of the string (or UTF-EBCDIC encoding on
EBCDIC machines).  That is, if they are UTF-8 invariant.  On ASCII-ish
machines, all the ASCII characters and only the ASCII characters fit this
definition.  On EBCDIC machines, the ASCII-range characters are invariant, but
so also are the C1 controls and C<\c?> (which isn't in the ASCII range on
EBCDIC).
d70 1
a70 1
Perl_is_invariant_string(const U8 *s, STRLEN len)
d75 1
a75 1
    PERL_ARGS_ASSERT_IS_INVARIANT_STRING;
d96 1
a96 1
For details, see the description for L</uvchr_to_utf8_flags>.
a100 29
#define HANDLE_UNICODE_SURROGATE(uv, flags)                         \
    STMT_START {                                                    \
        if (flags & UNICODE_WARN_SURROGATE) {                       \
            Perl_ck_warner_d(aTHX_ packWARN(WARN_SURROGATE),        \
                                "UTF-16 surrogate U+%04"UVXf, uv);  \
        }                                                           \
        if (flags & UNICODE_DISALLOW_SURROGATE) {                   \
            return NULL;                                            \
        }                                                           \
    } STMT_END;

#define HANDLE_UNICODE_NONCHAR(uv, flags)                           \
    STMT_START {                                                    \
        if (flags & UNICODE_WARN_NONCHAR) {                         \
            Perl_ck_warner_d(aTHX_ packWARN(WARN_NONCHAR),          \
		 "Unicode non-character U+%04"UVXf" is not "        \
                 "recommended for open interchange", uv);           \
        }                                                           \
        if (flags & UNICODE_DISALLOW_NONCHAR) {                     \
            return NULL;                                            \
        }                                                           \
    } STMT_END;

/*  Use shorter names internally in this file */
#define SHIFT   UTF_ACCUMULATION_SHIFT
#undef  MARK
#define MARK    UTF_CONTINUATION_MARK
#define MASK    UTF_CONTINUATION_MASK

d106 2
a107 2
    if (OFFUNI_IS_INVARIANT(uv)) {
	*d++ = LATIN1_TO_NATIVE(uv);
d111 36
a146 33
    if (uv <= MAX_UTF8_TWO_BYTE) {
        *d++ = I8_TO_NATIVE_UTF8(( uv >> SHIFT) | UTF_START_MARK(2));
        *d++ = I8_TO_NATIVE_UTF8(( uv           & MASK) |   MARK);
        return d;
    }

    /* Not 2-byte; test for and handle 3-byte result.   In the test immediately
     * below, the 16 is for start bytes E0-EF (which are all the possible ones
     * for 3 byte characters).  The 2 is for 2 continuation bytes; these each
     * contribute SHIFT bits.  This yields 0x4000 on EBCDIC platforms, 0x1_0000
     * on ASCII; so 3 bytes covers the range 0x400-0x3FFF on EBCDIC;
     * 0x800-0xFFFF on ASCII */
    if (uv < (16 * (1U << (2 * SHIFT)))) {
	*d++ = I8_TO_NATIVE_UTF8(( uv >> ((3 - 1) * SHIFT)) | UTF_START_MARK(3));
	*d++ = I8_TO_NATIVE_UTF8(((uv >> ((2 - 1) * SHIFT)) & MASK) |   MARK);
	*d++ = I8_TO_NATIVE_UTF8(( uv  /* (1 - 1) */        & MASK) |   MARK);

#ifndef EBCDIC  /* These problematic code points are 4 bytes on EBCDIC, so
                   aren't tested here */
        /* The most likely code points in this range are below the surrogates.
         * Do an extra test to quickly exclude those. */
        if (UNLIKELY(uv >= UNICODE_SURROGATE_FIRST)) {
            if (UNLIKELY(   UNICODE_IS_32_CONTIGUOUS_NONCHARS(uv)
                         || UNICODE_IS_END_PLANE_NONCHAR_GIVEN_NOT_SUPER(uv)))
            {
                HANDLE_UNICODE_NONCHAR(uv, flags);
            }
            else if (UNLIKELY(UNICODE_IS_SURROGATE(uv))) {
                HANDLE_UNICODE_SURROGATE(uv, flags);
            }
        }
#endif
	return d;
d149 1
a149 70
    /* Not 3-byte; that means the code point is at least 0x1_0000 on ASCII
     * platforms, and 0x4000 on EBCDIC.  There are problematic cases that can
     * happen starting with 4-byte characters on ASCII platforms.  We unify the
     * code for these with EBCDIC, even though some of them require 5-bytes on
     * those, because khw believes the code saving is worth the very slight
     * performance hit on these high EBCDIC code points. */

    if (UNLIKELY(UNICODE_IS_SUPER(uv))) {
        if (   UNLIKELY(uv > MAX_NON_DEPRECATED_CP)
            && ckWARN_d(WARN_DEPRECATED))
        {
            Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                        cp_above_legal_max, uv, MAX_NON_DEPRECATED_CP);
        }
        if (   (flags & UNICODE_WARN_SUPER)
            || (   UNICODE_IS_ABOVE_31_BIT(uv)
                && (flags & UNICODE_WARN_ABOVE_31_BIT)))
        {
            Perl_ck_warner_d(aTHX_ packWARN(WARN_NON_UNICODE),

              /* Choose the more dire applicable warning */
              (UNICODE_IS_ABOVE_31_BIT(uv))
              ? "Code point 0x%"UVXf" is not Unicode, and not portable"
              : "Code point 0x%"UVXf" is not Unicode, may not be portable",
             uv);
        }
        if (flags & UNICODE_DISALLOW_SUPER
            || (   UNICODE_IS_ABOVE_31_BIT(uv)
                && (flags & UNICODE_DISALLOW_ABOVE_31_BIT)))
        {
            return NULL;
        }
    }
    else if (UNLIKELY(UNICODE_IS_END_PLANE_NONCHAR_GIVEN_NOT_SUPER(uv))) {
        HANDLE_UNICODE_NONCHAR(uv, flags);
    }

    /* Test for and handle 4-byte result.   In the test immediately below, the
     * 8 is for start bytes F0-F7 (which are all the possible ones for 4 byte
     * characters).  The 3 is for 3 continuation bytes; these each contribute
     * SHIFT bits.  This yields 0x4_0000 on EBCDIC platforms, 0x20_0000 on
     * ASCII, so 4 bytes covers the range 0x4000-0x3_FFFF on EBCDIC;
     * 0x1_0000-0x1F_FFFF on ASCII */
    if (uv < (8 * (1U << (3 * SHIFT)))) {
	*d++ = I8_TO_NATIVE_UTF8(( uv >> ((4 - 1) * SHIFT)) | UTF_START_MARK(4));
	*d++ = I8_TO_NATIVE_UTF8(((uv >> ((3 - 1) * SHIFT)) & MASK) |   MARK);
	*d++ = I8_TO_NATIVE_UTF8(((uv >> ((2 - 1) * SHIFT)) & MASK) |   MARK);
	*d++ = I8_TO_NATIVE_UTF8(( uv  /* (1 - 1) */        & MASK) |   MARK);

#ifdef EBCDIC   /* These were handled on ASCII platforms in the code for 3-byte
                   characters.  The end-plane non-characters for EBCDIC were
                   handled just above */
        if (UNLIKELY(UNICODE_IS_32_CONTIGUOUS_NONCHARS(uv))) {
            HANDLE_UNICODE_NONCHAR(uv, flags);
        }
        else if (UNLIKELY(UNICODE_IS_SURROGATE(uv))) {
            HANDLE_UNICODE_SURROGATE(uv, flags);
        }
#endif

	return d;
    }

    /* Not 4-byte; that means the code point is at least 0x20_0000 on ASCII
     * platforms, and 0x4000 on EBCDIC.  At this point we switch to a loop
     * format.  The unrolled version above turns out to not save all that much
     * time, and at these high code points (well above the legal Unicode range
     * on ASCII platforms, and well above anything in common use in EBCDIC),
     * khw believes that less code outweighs slight performance gains. */

d154 1
a154 1
	    *p-- = I8_TO_NATIVE_UTF8((uv & UTF_CONTINUATION_MASK) | UTF_CONTINUATION_MARK);
d157 1
a157 1
	*p = I8_TO_NATIVE_UTF8((uv & UTF_START_MASK(len)) | UTF_START_MARK(len));
d160 68
a228 1

d233 1
a233 1
of the string C<d>; C<d> should have at least C<UVCHR_SKIP(uv)+1> (up to
d243 2
a244 6
This function accepts any UV as input, but very high code points (above
C<IV_MAX> on the platform)  will raise a deprecation warning.  This is
typically 0x7FFF_FFFF in a 32-bit word.

It is possible to forbid or warn on non-Unicode code points, or those that may
be problematic by using L</uvchr_to_utf8_flags>.
d262 1
a262 1
of the string C<d>; C<d> should have at least C<UVCHR_SKIP(uv)+1> (up to
d276 21
a296 48
If C<flags> is 0, this function accepts any UV as input, but very high code
points (above C<IV_MAX> for the platform)  will raise a deprecation warning.
This is typically 0x7FFF_FFFF in a 32-bit word.

Specifying C<flags> can further restrict what is allowed and not warned on, as
follows:

If C<uv> is a Unicode surrogate code point and C<UNICODE_WARN_SURROGATE> is set,
the function will raise a warning, provided UTF8 warnings are enabled.  If
instead C<UNICODE_DISALLOW_SURROGATE> is set, the function will fail and return
NULL.  If both flags are set, the function will both warn and return NULL.

Similarly, the C<UNICODE_WARN_NONCHAR> and C<UNICODE_DISALLOW_NONCHAR> flags
affect how the function handles a Unicode non-character.

And likewise, the C<UNICODE_WARN_SUPER> and C<UNICODE_DISALLOW_SUPER> flags
affect the handling of code points that are above the Unicode maximum of
0x10FFFF.  Languages other than Perl may not be able to accept files that
contain these.

The flag C<UNICODE_WARN_ILLEGAL_INTERCHANGE> selects all three of
the above WARN flags; and C<UNICODE_DISALLOW_ILLEGAL_INTERCHANGE> selects all
three DISALLOW flags.

Code points above 0x7FFF_FFFF (2**31 - 1) were never specified in any standard,
so using them is more problematic than other above-Unicode code points.  Perl
invented an extension to UTF-8 to represent the ones above 2**36-1, so it is
likely that non-Perl languages will not be able to read files that contain
these that written by the perl interpreter; nor would Perl understand files
written by something that uses a different extension.  For these reasons, there
is a separate set of flags that can warn and/or disallow these extremely high
code points, even if other above-Unicode ones are accepted.  These are the
C<UNICODE_WARN_ABOVE_31_BIT> and C<UNICODE_DISALLOW_ABOVE_31_BIT> flags.  These
are entirely independent from the deprecation warning for code points above
C<IV_MAX>.  On 32-bit machines, it will eventually be forbidden to have any
code point that needs more than 31 bits to represent.  When that happens,
effectively the C<UNICODE_DISALLOW_ABOVE_31_BIT> flag will always be set on
32-bit machines.  (Of course C<UNICODE_DISALLOW_SUPER> will treat all
above-Unicode code points, including these, as malformations; and
C<UNICODE_WARN_SUPER> warns on these.)

On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing
extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower
than on ASCII.  Prior to that, code points 2**31 and higher were simply
unrepresentable, and a different, incompatible method was used to represent
code points between 2**30 and 2**31 - 1.  The flags C<UNICODE_WARN_ABOVE_31_BIT>
and C<UNICODE_DISALLOW_ABOVE_31_BIT> have the same function as on ASCII
platforms, warning and disallowing 2**31 and higher.
d311 91
d410 1
a410 1
See also L</is_invariant_string>(), L</is_utf8_string_loclen>(), and L</is_utf8_string_loc>().
d424 22
a445 5
        STRLEN len = isUTF8_CHAR(x, send);
        if (UNLIKELY(! len)) {
            return FALSE;
        }
        x += len;
d479 1
d485 22
a506 6
        STRLEN len = isUTF8_CHAR(x, send);
        if (UNLIKELY(! len)) {
            goto out;
        }
        x += len;
        outlen++;
d548 1
a548 1
The C<UTF8_CHECK_ONLY> flag overrides the behavior when a non-allowed (by other
d554 1
a554 1
character, and an error return (unless the C<UTF8_CHECK_ONLY> flag is set), as
d563 10
a572 10
C<UTF8_DISALLOW_ILLEGAL_INTERCHANGE>, all three classes are treated as
malformations and handled as such.  The flags C<UTF8_DISALLOW_SURROGATE>,
C<UTF8_DISALLOW_NONCHAR>, and C<UTF8_DISALLOW_SUPER> (meaning above the legal
Unicode maximum) can be set to disallow these categories individually.

The flags C<UTF8_WARN_ILLEGAL_INTERCHANGE>, C<UTF8_WARN_SURROGATE>,
C<UTF8_WARN_NONCHAR>, and C<UTF8_WARN_SUPER> will cause warning messages to be
raised for their respective categories, but otherwise the code points are
considered valid (not malformations).  To get a category to both be treated as
a malformation and raise a warning, specify both the WARN and DISALLOW flags.
d574 1
a574 1
C<UTF8_CHECK_ONLY> is also specified.)
d576 15
a590 29
It is now deprecated to have very high code points (above C<IV_MAX> on the
platforms) and this function will raise a deprecation warning for these (unless
such warnings are turned off).  This value, is typically 0x7FFF_FFFF (2**31 -1)
in a 32-bit word.

Code points above 0x7FFF_FFFF (2**31 - 1) were never specified in any standard,
so using them is more problematic than other above-Unicode code points.  Perl
invented an extension to UTF-8 to represent the ones above 2**36-1, so it is
likely that non-Perl languages will not be able to read files that contain
these that written by the perl interpreter; nor would Perl understand files
written by something that uses a different extension.  For these reasons, there
is a separate set of flags that can warn and/or disallow these extremely high
code points, even if other above-Unicode ones are accepted.  These are the
C<UTF8_WARN_ABOVE_31_BIT> and C<UTF8_DISALLOW_ABOVE_31_BIT> flags.  These
are entirely independent from the deprecation warning for code points above
C<IV_MAX>.  On 32-bit machines, it will eventually be forbidden to have any
code point that needs more than 31 bits to represent.  When that happens,
effectively the C<UTF8_DISALLOW_ABOVE_31_BIT> flag will always be set on
32-bit machines.  (Of course C<UTF8_DISALLOW_SUPER> will treat all
above-Unicode code points, including these, as malformations; and
C<UTF8_WARN_SUPER> warns on these.)

On EBCDIC platforms starting in Perl v5.24, the Perl extension for representing
extremely high code points kicks in at 0x3FFF_FFFF (2**30 -1), which is lower
than on ASCII.  Prior to that, code points 2**31 and higher were simply
unrepresentable, and a different, incompatible method was used to represent
code points between 2**30 and 2**31 - 1.  The flags C<UTF8_WARN_ABOVE_31_BIT>
and C<UTF8_DISALLOW_ABOVE_31_BIT> have the same function as on ASCII
platforms, warning and disallowing 2**31 and higher.
d602 1
d705 1
d717 1
d784 1
d789 1
d808 2
a809 10
	&& ((flags & ( UTF8_DISALLOW_NONCHAR
                      |UTF8_DISALLOW_SURROGATE
                      |UTF8_DISALLOW_SUPER
                      |UTF8_DISALLOW_ABOVE_31_BIT
	              |UTF8_WARN_NONCHAR
                      |UTF8_WARN_SURROGATE
                      |UTF8_WARN_SUPER
                      |UTF8_WARN_ABOVE_31_BIT))
            || (   UNLIKELY(uv > MAX_NON_DEPRECATED_CP)
                && ckWARN_d(WARN_DEPRECATED))))
d829 1
a829 3
		sv = sv_2mortal(Perl_newSVpvf(aTHX_
                   "Code point 0x%04"UVXf" is not Unicode, may not be portable",
                   uv));
d832 1
d834 6
a839 32
            /* The maximum code point ever specified by a standard was
             * 2**31 - 1.  Anything larger than that is a Perl extension that
             * very well may not be understood by other applications (including
             * earlier perl versions on EBCDIC platforms).  On ASCII platforms,
             * these code points are indicated by the first UTF-8 byte being
             * 0xFE or 0xFF.  We test for these after the regular SUPER ones,
             * and before possibly bailing out, so that the slightly more dire
             * warning will override the regular one. */
            if (
#ifndef EBCDIC
                (*s0 & 0xFE) == 0xFE	/* matches both FE, FF */
#else
                 /* The I8 for 2**31 (U+80000000) is
                  *   \xFF\xA0\xA0\xA0\xA0\xA0\xA0\xA2\xA0\xA0\xA0\xA0\xA0\xA0
                  * and it turns out that on all EBCDIC pages recognized that
                  * the UTF-EBCDIC for that code point is
                  *   \xFE\x41\x41\x41\x41\x41\x41\x43\x41\x41\x41\x41\x41\x41
                  * For the next lower code point, the 1047 UTF-EBCDIC is
                  *   \xFE\x41\x41\x41\x41\x41\x41\x42\x73\x73\x73\x73\x73\x73
                  * The other code pages differ only in the bytes following
                  * \x42.  Thus the following works (the minimum continuation
                  * byte is \x41). */
                *s0 == 0xFE && send - s0 > 7 && (   s0[1] > 0x41
                                                 || s0[2] > 0x41
                                                 || s0[3] > 0x41
                                                 || s0[4] > 0x41
                                                 || s0[5] > 0x41
                                                 || s0[6] > 0x41
                                                 || s0[7] > 0x42)
#endif
                && (flags & (UTF8_WARN_ABOVE_31_BIT|UTF8_WARN_SUPER
                            |UTF8_DISALLOW_ABOVE_31_BIT)))
d841 3
a843 3
                if (  ! (flags & UTF8_CHECK_ONLY)
                    &&  (flags & (UTF8_WARN_ABOVE_31_BIT|UTF8_WARN_SUPER))
                    &&  ckWARN_d(WARN_UTF8))
d845 1
a845 3
                    sv = sv_2mortal(Perl_newSVpvf(aTHX_
                        "Code point 0x%"UVXf" is not Unicode, and not portable",
                        uv));
d848 1
a848 1
                if (flags & UTF8_DISALLOW_ABOVE_31_BIT) {
d852 1
a852 1

a855 8

            /* The deprecated warning overrides any non-deprecated one */
            if (UNLIKELY(uv > MAX_NON_DEPRECATED_CP) && ckWARN_d(WARN_DEPRECATED))
            {
                sv = sv_2mortal(Perl_newSVpvf(aTHX_ cp_above_legal_max,
                                              uv, MAX_NON_DEPRECATED_CP));
                pack_warn = packWARN(WARN_DEPRECATED);
            }
d861 1
a861 1
		sv = sv_2mortal(Perl_newSVpvf(aTHX_ "Unicode non-character U+%04"UVXf" is not recommended for open interchange", uv));
d908 1
a908 1
  malformed:
d914 1
a914 1
  disallowed:
d922 1
a922 1
  do_warn:
d950 1
a950 1
C<NULL>) to -1.  If those warnings are off, the computed value, if well-defined
d952 1
a952 1
C<*retlen> is set (if C<retlen> isn't C<NULL>) so that (S<C<s> + C<*retlen>>) is
a956 3
Code points above the platform's C<IV_MAX> will raise a deprecation warning,
unless those are turned off.

a981 1
    PERL_UNUSED_CONTEXT;
d1012 30
a1060 3
Code points above the platform's C<IV_MAX> will raise a deprecation warning,
unless those are turned off.

d1076 45
d1134 1
d1197 1
a1197 1
Perl_utf8_hop(const U8 *s, SSize_t off)
d1201 1
d1245 2
d1254 1
a1254 1
			c = EIGHT_BIT_UTF8_TO_NATIVE(c, c1);
a1310 1
    PERL_UNUSED_CONTEXT;
d1329 1
a1329 1
	    c = EIGHT_BIT_UTF8_TO_NATIVE(c, *s);
d1348 1
a1348 1
in UTF-8 (i.e., US-ASCII on non-EBCDIC machines).
d1362 1
d1387 1
a1387 1
	    c = EIGHT_BIT_UTF8_TO_NATIVE(c, *s);
d1461 1
a1461 1
	if (OFFUNI_IS_INVARIANT(uv)) {
d1474 4
a1477 10

        /* This assumes that most uses will be in the first Unicode plane, not
         * needing surrogates */
	if (UNLIKELY(uv >= UNICODE_SURROGATE_FIRST
                  && uv <= UNICODE_SURROGATE_LAST))
        {
            if (UNLIKELY(p >= pend) || UNLIKELY(uv > LAST_HIGH_SURROGATE)) {
                Perl_croak(aTHX_ "Malformed UTF-16 surrogate");
            }
	    else {
d1479 2
a1480 3
		if (   UNLIKELY(low < FIRST_LOW_SURROGATE)
                    || UNLIKELY(low > LAST_LOW_SURROGATE))
                {
a1481 2
                }
		p += 2;
d1485 2
d1544 2
a1545 2
bool
Perl__is_utf8_idstart(pTHX_ const U8 *p)
d1547 1
a1547 1
    PERL_ARGS_ASSERT__IS_UTF8_IDSTART;
d1551 1
d1556 8
d1583 1
a1583 1
     * those, converting the result to UTF-8.  The only difference between upper
a1611 3
#if    UNICODE_MAJOR_VERSION > 2                                        \
   || (UNICODE_MAJOR_VERSION == 2 && UNICODE_DOT_VERSION >= 1           \
                                  && UNICODE_DOT_DOT_VERSION >= 8)
a1616 1
#endif
d1619 1
a1619 1
		NOT_REACHED; /* NOTREACHED */
d1638 3
a1640 3
#define CALL_UPPER_CASE(uv, s, d, lenp) _to_utf8_case(uv, s, d, lenp, &PL_utf8_toupper, "ToUc", "")
#define CALL_TITLE_CASE(uv, s, d, lenp) _to_utf8_case(uv, s, d, lenp, &PL_utf8_totitle, "ToTc", "")
#define CALL_LOWER_CASE(uv, s, d, lenp) _to_utf8_case(uv, s, d, lenp, &PL_utf8_tolower, "ToLc", "")
d1642 2
a1643 2
/* This additionally has the input parameter 'specials', which if non-zero will
 * cause this to use the specials hash for folding (meaning get full case
d1645 1
a1645 1
#define CALL_FOLD_CASE(uv, s, d, lenp, specials) _to_utf8_case(uv, s, d, lenp, &PL_utf8_tofold, "ToCf", (specials) ? "" : NULL)
d1650 2
d1667 1
a1667 1
    return CALL_UPPER_CASE(c, p, p, lenp);
d1673 2
d1682 1
a1682 1
    return CALL_TITLE_CASE(c, p, p, lenp);
d1686 1
a1686 1
S_to_lower_latin1(const U8 c, U8* p, STRLEN *lenp)
d1689 1
a1689 1
     * those, converting the result to UTF-8.  Since the result is always just
d1700 2
a1701 4
            /* Result is known to always be < 256, so can use the EIGHT_BIT
             * macros */
	    *p = UTF8_EIGHT_BIT_HI(converted);
	    *(p+1) = UTF8_EIGHT_BIT_LO(converted);
d1711 2
d1720 1
a1720 1
    return CALL_LOWER_CASE(c, p, p, lenp);
a1735 1
    PERL_UNUSED_CONTEXT;
d1739 1
a1739 1
    if (UNLIKELY(c == MICRO_SIGN)) {
d1742 2
a1743 6
#if    UNICODE_MAJOR_VERSION > 3 /* no multifolds in early Unicode */   \
   || (UNICODE_MAJOR_VERSION == 3 && (   UNICODE_DOT_VERSION > 0)       \
                                      || UNICODE_DOT_DOT_VERSION > 0)
    else if (   (flags & FOLD_FLAGS_FULL)
             && UNLIKELY(c == LATIN_SMALL_LETTER_SHARP_S))
    {
a1759 1
#endif
d1792 3
a1794 9
    if (flags & FOLD_FLAGS_LOCALE) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags &= ~FOLD_FLAGS_LOCALE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
            goto needs_full_generality;
        }
d1798 1
a1798 1
        return _to_fold_latin1((U8) c, p, lenp,
d1800 5
d1807 1
a1807 1
    /* Here, above 255.  If no special needs, just use the macro */
d1810 1
a1810 1
	return CALL_FOLD_CASE(c, p, p, lenp, flags & FOLD_FLAGS_FULL);
a1814 2

      needs_full_generality:
d1837 2
d1846 1
a1846 1
    if (! isUTF8_CHAR(p, p + UTF8SKIP(p))) {
d1874 2
d1887 1
a1887 1
Perl__is_utf8_perl_idstart(pTHX_ const U8 *p)
d1889 1
a1889 1
    SV* invlist = NULL;
d1891 1
a1891 1
    PERL_ARGS_ASSERT__IS_UTF8_PERL_IDSTART;
d1893 1
a1893 4
    if (! PL_utf8_perl_idstart) {
        invlist = _new_invlist_C_array(_Perl_IDStart_invlist);
    }
    return is_utf8_common(p, &PL_utf8_perl_idstart, "_Perl_IDStart", invlist);
d1897 1
a1897 1
Perl__is_utf8_xidstart(pTHX_ const U8 *p)
d1899 3
a1901 1
    PERL_ARGS_ASSERT__IS_UTF8_XIDSTART;
d1905 1
d1910 14
d1926 1
d1934 1
a1934 1
    return is_utf8_common(p, &PL_utf8_perl_idcont, "_Perl_IDCont", invlist);
d1937 1
d1939 1
a1939 1
Perl__is_utf8_idcont(pTHX_ const U8 *p)
d1941 3
a1943 1
    PERL_ARGS_ASSERT__IS_UTF8_IDCONT;
d1949 1
a1949 1
Perl__is_utf8_xidcont(pTHX_ const U8 *p)
d1951 3
a1953 1
    PERL_ARGS_ASSERT__IS_UTF8_XIDCONT;
d1961 2
a1970 5
Instead use the appropriate one of L</toUPPER_utf8>,
L</toTITLE_utf8>,
L</toLOWER_utf8>,
or L</toFOLD_utf8>.

d1982 1
a1982 1
and loaded by C<SWASHNEW>, using F<lib/utf8_heavy.pl>.  C<special> (usually,
d1990 2
a1991 5
C<normal> is a string like C<"ToLower"> which means the swash
C<%utf8::ToLower>.

Code points above the platform's C<IV_MAX> will raise a deprecation warning,
unless those are turned off.
d1999 1
a1999 10
    PERL_ARGS_ASSERT_TO_UTF8_CASE;

    return _to_utf8_case(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp, swashp, normal, special);
}

    /* change namve uv1 to 'from' */
STATIC UV
S__to_utf8_case(pTHX_ const UV uv1, const U8 *p, U8* ustrp, STRLEN *lenp,
		SV **swashp, const char *normal, const char *special)
{
d2001 1
d2003 1
a2003 1
    PERL_ARGS_ASSERT__TO_UTF8_CASE;
d2005 17
a2021 90
    /* For code points that don't change case, we already know that the output
     * of this function is the unchanged input, so we can skip doing look-ups
     * for them.  Unfortunately the case-changing code points are scattered
     * around.  But there are some long consecutive ranges where there are no
     * case changing code points.  By adding tests, we can eliminate the lookup
     * for all the ones in such ranges.  This is currently done here only for
     * just a few cases where the scripts are in common use in modern commerce
     * (and scripts adjacent to those which can be included without additional
     * tests). */

    if (uv1 >= 0x0590) {
        /* This keeps from needing further processing the code points most
         * likely to be used in the following non-cased scripts: Hebrew,
         * Arabic, Syriac, Thaana, NKo, Samaritan, Mandaic, Devanagari,
         * Bengali, Gurmukhi, Gujarati, Oriya, Tamil, Telugu, Kannada,
         * Malayalam, Sinhala, Thai, Lao, Tibetan, Myanmar */
        if (uv1 < 0x10A0) {
            goto cases_to_self;
        }

        /* The following largish code point ranges also don't have case
         * changes, but khw didn't think they warranted extra tests to speed
         * them up (which would slightly slow down everything else above them):
         * 1100..139F   Hangul Jamo, Ethiopic
         * 1400..1CFF   Unified Canadian Aboriginal Syllabics, Ogham, Runic,
         *              Tagalog, Hanunoo, Buhid, Tagbanwa, Khmer, Mongolian,
         *              Limbu, Tai Le, New Tai Lue, Buginese, Tai Tham,
         *              Combining Diacritical Marks Extended, Balinese,
         *              Sundanese, Batak, Lepcha, Ol Chiki
         * 2000..206F   General Punctuation
         */

        if (uv1 >= 0x2D30) {

            /* This keeps the from needing further processing the code points
             * most likely to be used in the following non-cased major scripts:
             * CJK, Katakana, Hiragana, plus some less-likely scripts.
             *
             * (0x2D30 above might have to be changed to 2F00 in the unlikely
             * event that Unicode eventually allocates the unused block as of
             * v8.0 2FE0..2FEF to code points that are cased.  khw has verified
             * that the test suite will start having failures to alert you
             * should that happen) */
            if (uv1 < 0xA640) {
                goto cases_to_self;
            }

            if (uv1 >= 0xAC00) {
                if (UNLIKELY(UNICODE_IS_SURROGATE(uv1))) {
                    if (ckWARN_d(WARN_SURROGATE)) {
                        const char* desc = (PL_op) ? OP_DESC(PL_op) : normal;
                        Perl_warner(aTHX_ packWARN(WARN_SURROGATE),
                            "Operation \"%s\" returns its argument for UTF-16 surrogate U+%04"UVXf"", desc, uv1);
                    }
                    goto cases_to_self;
                }

                /* AC00..FAFF Catches Hangul syllables and private use, plus
                 * some others */
                if (uv1 < 0xFB00) {
                    goto cases_to_self;

                }

                if (UNLIKELY(UNICODE_IS_SUPER(uv1))) {
                    if (   UNLIKELY(uv1 > MAX_NON_DEPRECATED_CP)
                        && ckWARN_d(WARN_DEPRECATED))
                    {
                        Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
                                cp_above_legal_max, uv1, MAX_NON_DEPRECATED_CP);
                    }
                    if (ckWARN_d(WARN_NON_UNICODE)) {
                        const char* desc = (PL_op) ? OP_DESC(PL_op) : normal;
                        Perl_warner(aTHX_ packWARN(WARN_NON_UNICODE),
                            "Operation \"%s\" returns its argument for non-Unicode code point 0x%04"UVXf"", desc, uv1);
                    }
                    goto cases_to_self;
                }
#ifdef HIGHEST_CASE_CHANGING_CP_FOR_USE_ONLY_BY_UTF8_DOT_C
                if (UNLIKELY(uv1
                    > HIGHEST_CASE_CHANGING_CP_FOR_USE_ONLY_BY_UTF8_DOT_C))
                {

                    /* As of this writing, this means we avoid swash creation
                     * for anything beyond low Plane 1 */
                    goto cases_to_self;
                }
#endif
            }
        }
d2024 1
a2024 2
         * be given.  There are so few of them, that it isn't worth the extra
         * tests to avoid swash creation */
d2049 1
a2049 1
             && (svp = hv_fetch(hv, (const char*)p, UVCHR_SKIP(uv1), FALSE))
d2065 1
a2065 1
	const UV uv2 = swash_fetch(*swashp, p, TRUE /* => is UTF-8 */);
a2081 1
  cases_to_self:
d2097 1
a2097 1
    /* This is called when changing the case of a UTF-8-encoded character above
d2130 1
a2130 2
        /* Here, no characters crossed, result is ok as-is, but we warn. */
        _CHECK_AND_OUTPUT_WIDE_LOCALE_UTF8_MSG(p, p + UTF8SKIP(p));
d2134 1
a2134 1
  bad_crossing:
a2137 8

    /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
    Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                           "Can't do %s(\"\\x{%"UVXf"}\") on non-UTF-8 locale; "
                           "resolved to \"\\x{%"UVXf"}\".",
                           OP_DESC(PL_op),
                           original,
                           original);
d2156 2
d2162 2
a2163 8
    if (flags) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags = FALSE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
d2176 1
a2176 1
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
d2180 1
a2180 1
	    return _to_upper_title_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
d2184 2
a2185 2
    else {  /* UTF-8, ord above 255 */
	result = CALL_UPPER_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp);
d2193 1
a2193 1
    /* Here, used locale rules.  Convert back to UTF-8 */
d2223 2
d2229 2
a2230 8
    if (flags) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags = FALSE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
d2243 1
a2243 1
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
d2247 1
a2247 1
	    return _to_upper_title_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
d2251 2
a2252 2
    else {  /* UTF-8, ord above 255 */
	result = CALL_TITLE_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp);
d2260 1
a2260 1
    /* Here, used locale rules.  Convert back to UTF-8 */
d2291 2
d2295 2
a2296 8
    if (flags) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags = FALSE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
d2309 1
a2309 1
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
d2313 1
a2313 1
	    return to_lower_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
d2317 2
a2318 2
    else {  /* UTF-8, ord above 255 */
	result = CALL_LOWER_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp);
d2327 1
a2327 1
    /* Here, used locale rules.  Convert back to UTF-8 */
d2361 2
d2372 2
a2373 8
    if (flags & FOLD_FLAGS_LOCALE) {
        /* Treat a UTF-8 locale as not being in locale at all */
        if (IN_UTF8_CTYPE_LOCALE) {
            flags &= ~FOLD_FLAGS_LOCALE;
        }
        else {
            _CHECK_AND_WARN_PROBLEMATIC_LOCALE;
        }
d2387 1
a2387 1
            U8 c = EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1));
d2391 1
a2391 1
	    return _to_fold_latin1(EIGHT_BIT_UTF8_TO_NATIVE(*p, *(p+1)),
d2396 2
a2397 2
    else {  /* UTF-8, ord above 255 */
	result = CALL_FOLD_CASE(valid_utf8_to_uvchr(p, NULL), p, ustrp, lenp, flags & FOLD_FLAGS_FULL);
a2400 8
#           define LONG_S_T      LATIN_SMALL_LIGATURE_LONG_S_T_UTF8
            const unsigned int long_s_t_len    = sizeof(LONG_S_T) - 1;

#         ifdef LATIN_CAPITAL_LETTER_SHARP_S_UTF8
#           define CAP_SHARP_S   LATIN_CAPITAL_LETTER_SHARP_S_UTF8

            const unsigned int cap_sharp_s_len = sizeof(CAP_SHARP_S) - 1;

d2403 3
a2405 2
            if (UTF8SKIP(p) == cap_sharp_s_len
                && memEQ((char *) p, CAP_SHARP_S, cap_sharp_s_len))
a2406 4
                /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                              "Can't do fc(\"\\x{1E9E}\") on non-UTF-8 locale; "
                              "resolved to \"\\x{17F}\\x{17F}\".");
d2409 3
a2411 4
            else
#endif
                 if (UTF8SKIP(p) == long_s_t_len
                     && memEQ((char *) p, LONG_S_T, long_s_t_len))
a2412 4
                /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                              "Can't do fc(\"\\x{FB05}\") on non-UTF-8 locale; "
                              "resolved to \"\\x{FB06}\".");
a2414 22

#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1
#           define DOTTED_I   LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_UTF8

            /* And special case this on this Unicode version only, for the same
             * reaons the other two are special cased.  They would cross the
             * 255/256 boundary which is forbidden under /l, and so the code
             * wouldn't catch that they are equivalent (which they are only in
             * this release) */
            else if (UTF8SKIP(p) == sizeof(DOTTED_I) - 1
                     && memEQ((char *) p, DOTTED_I, sizeof(DOTTED_I) - 1))
            {
                /* diag_listed_as: Can't do %s("%s") on non-UTF-8 locale; resolved to "%s". */
                Perl_ck_warner(aTHX_ packWARN(WARN_LOCALE),
                              "Can't do fc(\"\\x{0130}\") on non-UTF-8 locale; "
                              "resolved to \"\\x{0131}\".");
                goto return_dotless_i;
            }
#endif

d2421 1
a2421 1
	    /* This is called when changing the case of a UTF-8-encoded
d2438 3
a2440 5
                    if (original == LATIN_SMALL_LETTER_SHARP_S
#ifdef LATIN_CAPITAL_LETTER_SHARP_S /* not defined in early Unicode releases */
                        || original == LATIN_CAPITAL_LETTER_SHARP_S
#endif
                    ) {
a2445 8
#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1

                    else if (original == LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE) {
                        goto return_dotless_i;
                    }
#endif
d2457 1
a2457 1
    /* Here, used locale rules.  Convert back to UTF-8 */
a2488 12

#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1

  return_dotless_i:
    *lenp = sizeof(LATIN_SMALL_LETTER_DOTLESS_I_UTF8) - 1;
    Copy(LATIN_SMALL_LETTER_DOTLESS_I_UTF8, ustrp, *lenp, U8);
    return LATIN_SMALL_LETTER_DOTLESS_I;

#endif

d2564 1
d2605 1
a2605 1
	if (!method) {	/* demand load UTF-8 */
a2608 1
#ifndef NO_TAINT_SUPPORT
d2615 1
d2666 1
a2666 1
	    if (SvPOK(retval)) {
d2675 1
a2675 2
                NOT_REACHED; /* NOTREACHED */
            }
d2782 1
a2782 1
 * For those, you should use S__to_utf8_case() instead */
d2788 1
a2788 1
 * assumed to be in well-formed UTF-8. If C<do_utf8> is false, the string C<ptr>
d2822 1
d2829 1
d2859 1
a2859 1
        off = EIGHT_BIT_UTF8_TO_NATIVE(c, *(ptr + 1));
d2901 1
a2901 1
     * This single-entry cache saves about 1/3 of the UTF-8 overhead in test
d2959 3
a2961 1
	return ((UV) tmps[off >> 3] & (1 << (off & 7))) != 0;
d2963 1
a2963 1
	return ((UV) tmps[off]);
d2966 1
a2966 3
	return
            ((UV) tmps[off    ] << 8) +
            ((UV) tmps[off + 1]);
d2969 1
a2969 5
	return
            ((UV) tmps[off    ] << 24) +
            ((UV) tmps[off + 1] << 16) +
            ((UV) tmps[off + 2] <<  8) +
            ((UV) tmps[off + 3]);
a3006 2
    PERL_ARGS_ASSERT_SWASH_SCAN_LIST_LINE;

a3009 1
    *max = *min;    /* So can never return without setting max */
d3061 1
d3176 2
a3177 2
	l = swash_scan_list_line(l, lend, &min, &max, &val,
                                                        cBOOL(octets), typestr);
d3412 1
a3412 1
    * The returned hash would have two keys, the UTF-8 for 006B and the UTF-8 for
d3414 2
a3415 2
    * have two elements, the UTF-8 for itself, and for 004C.  For 006B, there
    * would be three elements in its array, the UTF-8 for 006B, 004B and 212A.
d3429 1
a3429 1
    * of UTF-8 characters).   This function currently returns only 1-1 mappings.
d3438 1
a3438 18
    * sequences and adds the 1-1 mappings that come out of that.
    *
    * XXX This function was originally intended to be multipurpose, but its
    * only use is quite likely to remain for constructing the inversion of
    * the CaseFolding (//i) property.  If it were more general purpose for
    * regex patterns, it would have to do the FB05/FB06 game for simple folds,
    * because certain folds are prohibited under /iaa and /il.  As an example,
    * in Unicode 3.0.1 both U+0130 and U+0131 fold to 'i', and hence are both
    * equivalent under /i.  But under /iaa and /il, the folds to 'i' are
    * prohibited, so we would not figure out that they fold to each other.
    * Code could be written to automatically figure this out, similar to the
    * code that does this for multi-character folds, but this is the only case
    * where something like this is ever likely to happen, as all the single
    * char folds to the 0-255 range are now quite settled.  Instead there is a
    * little special code that is compiled only for this Unicode version.  This
    * is smaller and didn't require much coding time to do.  But this makes
    * this routine strongly tied to being used just for CaseFolding.  If ever
    * it should be generalized, this would have to be fixed */
d3483 2
a3484 2
	/* The keys are the characters (in UTF-8) that map to the corresponding
	 * UTF-8 string value.  Iterate through the list creating the inverse
d3496 1
a3496 1
	     * hash value is a list of the strings (each in UTF-8) that map to
d3539 1
a3539 1
	    if (av_tindex_nomg(from_list) > 0) {
d3544 1
a3544 1
		for (i = 0; i <= av_tindex_nomg(from_list); i++) {
d3561 1
a3561 1
		    for (j = 0; j <= av_tindex_nomg(from_list); j++) {
a3580 14

#if    UNICODE_MAJOR_VERSION   == 3         \
    && UNICODE_DOT_VERSION     == 0         \
    && UNICODE_DOT_DOT_VERSION == 1

    /* For this version only U+130 and U+131 are equivalent under qr//i.  Add a
     * rule so that things work under /iaa and /il */

    SV * mod_listsv = sv_mortalcopy(*listsvp);
    sv_catpv(mod_listsv, "130\t130\t131\n");
    l = (U8*)SvPV(mod_listsv, lcur);

#else

a3581 3

#endif

d3588 2
a3589 2
	l = swash_scan_list_line(l, lend, &min, &max, &val,
                                                     cBOOL(octets), typestr);
d3620 1
a3620 1
	    for (i = 0; i <= av_tindex_nomg(list); i++) {
a3622 1
		UV uv;
d3627 2
a3628 3
		uv = SvUV(entry);
		/*DEBUG_U(PerlIO_printf(Perl_debug_log, "list for %"UVXf" contains %"UVXf"\n", val, uv));*/
		if (uv == val) {
d3631 1
a3631 1
		if (uv == inverse) {
d3732 1
a3732 1
        const char *after_atou = (char *) lend;
d3738 1
a3738 3
        if (!grok_atoUV((const char *)l, &elements, &after_atou)) {
            Perl_croak(aTHX_ "panic: Expecting a valid count of elements at start of inversion list");
        }
d3743 1
a3743 2
            while (isSPACE(*l)) l++;
            l = (U8 *) after_atou;
d3746 2
a3747 5
            while (isSPACE(*l)) l++;
            if (!grok_atoUV((const char *)l, &element0, &after_atou)) {
                Perl_croak(aTHX_ "panic: Expecting a valid 0th element for inversion list");
            }
            l = (U8 *) after_atou;
d3756 2
a3757 5
                while (isSPACE(*l)) l++;
                if (!grok_atoUV((const char *)l, other_elements_ptr++, &after_atou)) {
                    Perl_croak(aTHX_ "panic: Expecting a valid element in inversion list");
                }
                l = (U8 *) after_atou;
d3787 2
a3788 2
            l = swash_scan_list_line(l, lend, &start, &end, &val,
                                                        cBOOL(octets), typestr);
d3912 1
a3912 4
     * to make sure that this won't exceed the string's length.
     *
     * Code points above the platform's C<IV_MAX> will raise a deprecation
     * warning, unless those are turned off.  */
d3925 1
a3925 1
	if (UNLIKELY(isUTF8_POSSIBLY_PROBLEMATIC(*s))) {
d3927 7
a3933 28
	    if (UTF8_IS_SUPER(s, e)) {
                if (   ckWARN_d(WARN_NON_UNICODE)
                    || (   ckWARN_d(WARN_DEPRECATED)
#if defined(UV_IS_QUAD)
                        /* 2**63 and up meet these conditions provided we have
                         * a 64-bit word. */
#   ifdef EBCDIC
                        && *s == 0xFE && e - s >= UTF8_MAXBYTES
                        && s[1] >= 0x49
#   else
                        && *s == 0xFF && e -s >= UTF8_MAXBYTES
                        && s[2] >= 0x88
#   endif
#else   /* Below is 32-bit words */
                        /* 2**31 and above meet these conditions on all EBCDIC
                         * pages recognized for 32-bit platforms */
#   ifdef EBCDIC
                        && *s == 0xFE && e - s >= UTF8_MAXBYTES
                        && s[6] >= 0x43
#   else
                        && *s >= 0xFE
#   endif
#endif
                )) {
                    /* A side effect of this function will be to warn */
                    (void) utf8n_to_uvchr(s, e - s, &char_len, UTF8_WARN_SUPER);
                    ok = FALSE;
                }
d3935 1
a3935 1
	    else if (UTF8_IS_SURROGATE(s, e)) {
a3936 3
                    /* This has a different warning than the one the called
                     * function would output, so can't just call it, unlike we
                     * do for the non-chars and above-unicodes */
d3943 7
a3949 3
	    else if ((UTF8_IS_NONCHAR(s, e)) && (ckWARN_d(WARN_NONCHAR))) {
                /* A side effect of this function will be to warn */
                (void) utf8n_to_uvchr(s, e - s, &char_len, UTF8_WARN_NONCHAR);
d3964 1
a3964 1
(if longer, the rest is truncated and C<"..."> will be appended).
d3966 6
a3971 6
The C<flags> argument can have C<UNI_DISPLAY_ISPRINT> set to display
C<isPRINT()>able characters as themselves, C<UNI_DISPLAY_BACKSLASH>
to display the C<\\[nrfta\\]> as the backslashed versions (like C<"\n">)
(C<UNI_DISPLAY_BACKSLASH> is preferred over C<UNI_DISPLAY_ISPRINT> for C<"\\">).
C<UNI_DISPLAY_QQ> (and its alias C<UNI_DISPLAY_REGEX>) have both
C<UNI_DISPLAY_BACKSLASH> and C<UNI_DISPLAY_ISPRINT> turned on.
a3974 2
See also L</sv_uni_display>.

d4080 1
a4080 1
If C<pe1> is non-C<NULL> and the pointer it points to is not C<NULL>, that pointer is
d4097 1
a4097 1
Upon a successful match, if C<pe1> is non-C<NULL>,
d4115 1
a4115 10
 *                          routine.  This allows that step to be skipped.
 *                          Currently, this requires s1 to be encoded as UTF-8
 *                          (u1 must be true), which is asserted for.
 *  FOLDEQ_S1_FOLDS_SANE    With either NOMIX_ASCII or LOCALE, no folds may
 *                          cross certain boundaries.  Hence, the caller should
 *                          let this function do the folding instead of
 *                          pre-folding.  This code contains an assertion to
 *                          that effect.  However, if the caller knows what
 *                          it's doing, it can pass this flag to indicate that,
 *                          and the assertion is skipped.
a4116 1
 *  FOLDEQ_S2_FOLDS_SANE
d4121 1
a4132 1
    U8 flags_for_folder = FOLD_FLAGS_FULL;
d4137 1
a4137 4
               && (((flags & FOLDEQ_S1_ALREADY_FOLDED)
                     && !(flags & FOLDEQ_S1_FOLDS_SANE))
                   || ((flags & FOLDEQ_S2_ALREADY_FOLDED)
                       && !(flags & FOLDEQ_S2_FOLDS_SANE)))));
d4149 2
a4150 7
    if (flags & FOLDEQ_LOCALE) {
        if (IN_UTF8_CTYPE_LOCALE) {
            flags &= ~FOLDEQ_LOCALE;
        }
        else {
            flags_for_folder |= FOLD_FLAGS_LOCALE;
        }
d4202 2
a4203 1
	 * and the length of the fold. */
a4206 1
                assert(u1);
d4210 23
a4232 1
                if (isASCII(*p1) && ! (flags & FOLDEQ_LOCALE)) {
d4234 16
a4249 20
                    /* We have to forbid mixing ASCII with non-ASCII if the
                     * flags so indicate.  And, we can short circuit having to
                     * call the general functions for this common ASCII case,
                     * all of whose non-locale folds are also ASCII, and hence
                     * UTF-8 invariants, so the UTF8ness of the strings is not
                     * relevant. */
                    if ((flags & FOLDEQ_UTF8_NOMIX_ASCII) && ! isASCII(*p2)) {
                        return 0;
                    }
                    n1 = 1;
                    *foldbuf1 = toFOLD(*p1);
                }
                else if (u1) {
                    _to_utf8_fold_flags(p1, foldbuf1, &n1, flags_for_folder);
                }
                else {  /* Not UTF-8, get UTF-8 fold */
                    _to_uni_fold_flags(*p1, foldbuf1, &n1, flags_for_folder);
                }
                f1 = foldbuf1;
            }
a4254 1
                assert(u2);
d4258 36
a4293 14
                if (isASCII(*p2) && ! (flags & FOLDEQ_LOCALE)) {
                    if ((flags & FOLDEQ_UTF8_NOMIX_ASCII) && ! isASCII(*p1)) {
                        return 0;
                    }
                    n2 = 1;
                    *foldbuf2 = toFOLD(*p2);
                }
                else if (u2) {
                    _to_utf8_fold_flags(p2, foldbuf2, &n2, flags_for_folder);
                }
                else {
                    _to_uni_fold_flags(*p2, foldbuf2, &n2, flags_for_folder);
                }
                f2 = foldbuf2;
d4299 1
a4299 1
	 * string, stored in UTF-8. */
d4348 1
a4348 1
/* XXX The next two functions should likely be moved to mathoms.c once all
a4359 16
/*
=for apidoc utf8n_to_uvuni

Instead use L</utf8_to_uvchr_buf>, or rarely, L</utf8n_to_uvchr>.

This function was useful for code that wanted to handle both EBCDIC and
ASCII platforms with Unicode properties, but starting in Perl v5.20, the
distinctions between the platforms have mostly been made invisible to most
code, so this function is quite unlikely to be what you want.  If you do need
this precise functionality, use instead
C<L<NATIVE_TO_UNI(utf8_to_uvchr_buf(...))|/utf8_to_uvchr_buf>>
or C<L<NATIVE_TO_UNI(utf8n_to_uvchr(...))|/utf8n_to_uvchr>>.

=cut
*/

d4372 1
a4372 1
L</uvchr_to_utf8_flags>.
d4393 22
@


