head	1.4;
access;
symbols
	OPENBSD_5_5:1.3.0.6
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.2
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.2.0.26
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.24
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.22
	OPENBSD_5_0:1.2.0.20
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.18
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.16
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.12
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.14
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.10
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.8
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.6
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.4
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	HEIMDAL_0_7_2:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	HEIMDAL_0_6_3:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.6
	OPENBSD_3_6_BASE:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.4
	OPENBSD_3_5_BASE:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.2
	OPENBSD_3_4_BASE:1.1.1.3
	HEIMDAL_0_6:1.1.1.3
	HEIMDAL_0_6RC1:1.1.1.3
	OPENBSD_3_3:1.1.1.2.0.6
	OPENBSD_3_3_BASE:1.1.1.2
	OPENBSD_3_2:1.1.1.2.0.4
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.2
	OPENBSD_3_1_BASE:1.1.1.2
	HEIMDAL_0_4e:1.1.1.2
	OPENBSD_3_0:1.1.1.1.0.2
	OPENBSD_3_0_BASE:1.1.1.1
	HEIMDAL_0_3f:1.1.1.1
	HEIMDAL_0_3e:1.1.1.1
	KTH:1.1.1;
locks; strict;
comment	@ * @;


1.4
date	2014.04.22.10.01.31;	author reyk;	state dead;
branches;
next	1.3;

1.3
date	2013.06.17.18.57.43;	author robert;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.06.07.09.10;	author biorn;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.25.07.50.25;	author hin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.05.25.07.50.25;	author hin;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.02.06.08.55.16;	author hin;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.02.15.45;	author hin;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.10.29.15.55.35;	author biorn;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.04.14.07.33.06;	author biorn;	state Exp;
branches;
next	;


desc
@@


1.4
log
@The complexity and quality of kerberosV and the fact that almost
nobody is using it doesn't justify to have it in base - disable and
remove it.  If the 2 two people who use it still want it, they can
make a port or recompile OpenBSD on their own.

There is a quote in theo.c from August 2010: "basically, dung beetles
fucking.  that's what kerberosV + openssl is like".

Discussed with many.  Tests by henning@@ reyk@@ and others.
ok deraadt@@ henning@@
@
text
@/*
 * Copyright (c) 1997 - 2006 Kungliga Tekniska HÃ¶gskolan
 * (Royal Institute of Technology, Stockholm, Sweden).
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "kadm5_locl.h"
#include <sys/types.h>
#ifdef HAVE_SYS_SOCKET_H
#include <sys/socket.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
#ifdef HAVE_NETDB_H
#include <netdb.h>
#endif

RCSID("$Id: init_c.c,v 1.3 2013/06/17 18:57:43 robert Exp $");

static void
set_funcs(kadm5_client_context *c)
{
#define SET(C, F) (C)->funcs.F = kadm5 ## _c_ ## F
    SET(c, chpass_principal);
    SET(c, chpass_principal_with_key);
    SET(c, create_principal);
    SET(c, delete_principal);
    SET(c, destroy);
    SET(c, flush);
    SET(c, get_principal);
    SET(c, get_principals);
    SET(c, get_privs);
    SET(c, modify_principal);
    SET(c, randkey_principal);
    SET(c, rename_principal);
}

kadm5_ret_t
_kadm5_c_init_context(kadm5_client_context **ctx,
		      kadm5_config_params *params,
		      krb5_context context)
{
    krb5_error_code ret;
    char *colon;

    *ctx = malloc(sizeof(**ctx));
    if(*ctx == NULL)
	return ENOMEM;
    memset(*ctx, 0, sizeof(**ctx));
    krb5_add_et_list (context, initialize_kadm5_error_table_r);
    set_funcs(*ctx);
    (*ctx)->context = context;
    if(params->mask & KADM5_CONFIG_REALM) {
	ret = 0;
	(*ctx)->realm = strdup(params->realm);
	if ((*ctx)->realm == NULL)
	    ret = ENOMEM;
    } else
	ret = krb5_get_default_realm((*ctx)->context, &(*ctx)->realm);
    if (ret) {
	free(*ctx);
	return ret;
    }
    if(params->mask & KADM5_CONFIG_ADMIN_SERVER)
	(*ctx)->admin_server = strdup(params->admin_server);
    else {
	char **hostlist;

	ret = krb5_get_krb_admin_hst (context, &(*ctx)->realm, &hostlist);
	if (ret) {
	    free((*ctx)->realm);
	    free(*ctx);
	    return ret;
	}
	(*ctx)->admin_server = strdup(*hostlist);
	krb5_free_krbhst (context, hostlist);
    }

    if ((*ctx)->admin_server == NULL) {
	free((*ctx)->realm);
	free(*ctx);
	return ENOMEM;
    }
    colon = strchr ((*ctx)->admin_server, ':');
    if (colon != NULL)
	*colon++ = '\0';

    (*ctx)->kadmind_port = 0;

    if(params->mask & KADM5_CONFIG_KADMIND_PORT)
	(*ctx)->kadmind_port = params->kadmind_port;
    else if (colon != NULL) {
	char *end;

	(*ctx)->kadmind_port = htons(strtol (colon, &end, 0));
    }
    if ((*ctx)->kadmind_port == 0)
	(*ctx)->kadmind_port = krb5_getportbyname (context, "kerberos-adm",
						   "tcp", 749);
    return 0;
}

static krb5_error_code
get_kadm_ticket(krb5_context context,
		krb5_ccache id,
		krb5_principal client,
		const char *server_name)
{
    krb5_error_code ret;
    krb5_creds in, *out;

    memset(&in, 0, sizeof(in));
    in.client = client;
    ret = krb5_parse_name(context, server_name, &in.server);
    if(ret)
	return ret;
    ret = krb5_get_credentials(context, 0, id, &in, &out);
    if(ret == 0)
	krb5_free_creds(context, out);
    krb5_free_principal(context, in.server);
    return ret;
}

static krb5_error_code
get_new_cache(krb5_context context,
	      krb5_principal client,
	      const char *password,
	      krb5_prompter_fct prompter,
	      const char *keytab,
	      const char *server_name,
	      krb5_ccache *ret_cache)
{
    krb5_error_code ret;
    krb5_creds cred;
    krb5_get_init_creds_opt *opt;
    krb5_ccache id;

    ret = krb5_get_init_creds_opt_alloc (context, &opt);
    if (ret)
	return ret;

    krb5_get_init_creds_opt_set_default_flags(context, "kadmin",
					      krb5_principal_get_realm(context,
								       client),
					      opt);


    krb5_get_init_creds_opt_set_forwardable (opt, FALSE);
    krb5_get_init_creds_opt_set_proxiable (opt, FALSE);

    if(password == NULL && prompter == NULL) {
	krb5_keytab kt;
	if(keytab == NULL)
	    ret = krb5_kt_default(context, &kt);
	else
	    ret = krb5_kt_resolve(context, keytab, &kt);
	if(ret) {
	    krb5_get_init_creds_opt_free(context, opt);
	    return ret;
	}
	ret = krb5_get_init_creds_keytab (context,
					  &cred,
					  client,
					  kt,
					  0,
					  server_name,
					  opt);
	krb5_kt_close(context, kt);
    } else {
	ret = krb5_get_init_creds_password (context,
					    &cred,
					    client,
					    password,
					    prompter,
					    NULL,
					    0,
					    server_name,
					    opt);
    }
    krb5_get_init_creds_opt_free(context, opt);
    switch(ret){
    case 0:
	break;
    case KRB5_LIBOS_PWDINTR:	/* don't print anything if it was just C-c:ed */
    case KRB5KRB_AP_ERR_BAD_INTEGRITY:
    case KRB5KRB_AP_ERR_MODIFIED:
	return KADM5_BAD_PASSWORD;
    default:
	return ret;
    }
    ret = krb5_cc_new_unique(context, krb5_cc_type_memory, NULL, &id);
    if(ret)
	return ret;
    ret = krb5_cc_initialize (context, id, cred.client);
    if (ret)
	return ret;
    ret = krb5_cc_store_cred (context, id, &cred);
    if (ret)
	return ret;
    krb5_free_cred_contents (context, &cred);
    *ret_cache = id;
    return 0;
}

/*
 * Check the credential cache `idÂ´ to figure out what principal to use
 * when talking to the kadmind. If there is a initial kadmin/admin@@
 * credential in the cache, use that client principal. Otherwise, use
 * the client principals first component and add /admin to the
 * principal.
 */

static krb5_error_code
get_cache_principal(krb5_context context,
		    krb5_ccache *id,
		    krb5_principal *client)
{
    krb5_error_code ret;
    const char *name, *inst;
    krb5_principal p1, p2;

    ret = krb5_cc_default(context, id);
    if(ret) {
	*id = NULL;
	return ret;
    }

    ret = krb5_cc_get_principal(context, *id, &p1);
    if(ret) {
	krb5_cc_close(context, *id);
	*id = NULL;
	return ret;
    }

    ret = krb5_make_principal(context, &p2, NULL,
			      "kadmin", "admin", NULL);
    if (ret) {
	krb5_cc_close(context, *id);
	*id = NULL;
	krb5_free_principal(context, p1);
	return ret;
    }

    {
	krb5_creds in, *out;
	krb5_kdc_flags flags;

	flags.i = 0;
	memset(&in, 0, sizeof(in));

	in.client = p1;
	in.server = p2;

	/* check for initial ticket kadmin/admin */
	ret = krb5_get_credentials_with_flags(context, KRB5_GC_CACHED, flags,
					      *id, &in, &out);
	krb5_free_principal(context, p2);
	if (ret == 0) {
	    if (out->flags.b.initial) {
		*client = p1;
		krb5_free_creds(context, out);
		return 0;
	    }
	    krb5_free_creds(context, out);
	}
    }
    krb5_cc_close(context, *id);
    *id = NULL;

    name = krb5_principal_get_comp_string(context, p1, 0);
    inst = krb5_principal_get_comp_string(context, p1, 1);
    if(inst == NULL || strcmp(inst, "admin") != 0) {
	ret = krb5_make_principal(context, &p2, NULL, name, "admin", NULL);
	krb5_free_principal(context, p1);
	if(ret != 0)
	    return ret;

	*client = p2;
	return 0;
    }

    *client = p1;

    return 0;
}

krb5_error_code
_kadm5_c_get_cred_cache(krb5_context context,
			const char *client_name,
			const char *server_name,
			const char *password,
			krb5_prompter_fct prompter,
			const char *keytab,
			krb5_ccache ccache,
			krb5_ccache *ret_cache)
{
    krb5_error_code ret;
    krb5_ccache id = NULL;
    krb5_principal default_client = NULL, client = NULL;

    /* treat empty password as NULL */
    if(password && *password == '\0')
	password = NULL;
    if(server_name == NULL)
	server_name = KADM5_ADMIN_SERVICE;

    if(client_name != NULL) {
	ret = krb5_parse_name(context, client_name, &client);
	if(ret)
	    return ret;
    }

    if(ccache != NULL) {
	id = ccache;
	ret = krb5_cc_get_principal(context, id, &client);
	if(ret)
	    return ret;
    } else {
	/* get principal from default cache, ok if this doesn't work */

	ret = get_cache_principal(context, &id, &default_client);
	if (ret) {
	    /*
	     * No client was specified by the caller and we cannot
	     * determine the client from a credentials cache.
	     */
	    const char *user;

	    user = get_default_username ();

	    if(user == NULL) {
		krb5_set_error_message(context, KADM5_FAILURE, "Unable to find local user name");
		return KADM5_FAILURE;
	    }
	    ret = krb5_make_principal(context, &default_client,
				      NULL, user, "admin", NULL);
	    if(ret)
		return ret;
	}
    }


    /*
     * No client was specified by the caller, but we have a client
     * from the default credentials cache.
     */
    if (client == NULL && default_client != NULL)
	client = default_client;


    if(id && client && (default_client == NULL ||
	      krb5_principal_compare(context, client, default_client) != 0)) {
	ret = get_kadm_ticket(context, id, client, server_name);
	if(ret == 0) {
	    *ret_cache = id;
	    krb5_free_principal(context, default_client);
	    if (default_client != client)
		krb5_free_principal(context, client);
	    return 0;
	}
	if(ccache != NULL)
	    /* couldn't get ticket from cache */
	    return -1;
    }
    /* get creds via AS request */
    if(id && (id != ccache))
	krb5_cc_close(context, id);
    if (client != default_client)
	krb5_free_principal(context, default_client);

    ret = get_new_cache(context, client, password, prompter, keytab,
			server_name, ret_cache);
    krb5_free_principal(context, client);
    return ret;
}

static kadm5_ret_t
kadm_connect(kadm5_client_context *ctx)
{
    kadm5_ret_t ret;
    krb5_principal server;
    krb5_ccache cc;
    rk_socket_t s = rk_INVALID_SOCKET;
    struct addrinfo *ai, *a;
    struct addrinfo hints;
    int error;
    char portstr[NI_MAXSERV];
    char *hostname, *slash;
    char *service_name;
    krb5_context context = ctx->context;

    memset (&hints, 0, sizeof(hints));
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    snprintf (portstr, sizeof(portstr), "%u", ntohs(ctx->kadmind_port));

    hostname = ctx->admin_server;
    slash = strchr (hostname, '/');
    if (slash != NULL)
	hostname = slash + 1;

    error = getaddrinfo (hostname, portstr, &hints, &ai);
    if (error) {
	krb5_clear_error_message(context);
	return KADM5_BAD_SERVER_NAME;
    }

    for (a = ai; a != NULL; a = a->ai_next) {
	s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
	if (s < 0)
	    continue;
	if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
	    krb5_clear_error_message(context);
	    krb5_warn (context, errno, "connect(%s)", hostname);
	    rk_closesocket (s);
	    continue;
	}
	break;
    }
    if (a == NULL) {
	freeaddrinfo (ai);
	krb5_clear_error_message(context);
	krb5_warnx (context, "failed to contact %s", hostname);
	return KADM5_FAILURE;
    }
    ret = _kadm5_c_get_cred_cache(context,
				  ctx->client_name,
				  ctx->service_name,
				  NULL, ctx->prompter, ctx->keytab,
				  ctx->ccache, &cc);

    if(ret) {
	freeaddrinfo (ai);
	rk_closesocket(s);
	return ret;
    }

    if (ctx->realm)
	asprintf(&service_name, "%s@@%s", KADM5_ADMIN_SERVICE, ctx->realm);
    else
	asprintf(&service_name, "%s", KADM5_ADMIN_SERVICE);

    if (service_name == NULL) {
	freeaddrinfo (ai);
	rk_closesocket(s);
	krb5_clear_error_message(context);
	return ENOMEM;
    }

    ret = krb5_parse_name(context, service_name, &server);
    free(service_name);
    if(ret) {
	freeaddrinfo (ai);
	if(ctx->ccache == NULL)
	    krb5_cc_close(context, cc);
	rk_closesocket(s);
	return ret;
    }
    ctx->ac = NULL;

    ret = krb5_sendauth(context, &ctx->ac, &s,
			KADMIN_APPL_VERSION, NULL,
			server, AP_OPTS_MUTUAL_REQUIRED,
			NULL, NULL, cc, NULL, NULL, NULL);
    if(ret == 0) {
	krb5_data params;
	kadm5_config_params p;
	memset(&p, 0, sizeof(p));
	if(ctx->realm) {
	    p.mask |= KADM5_CONFIG_REALM;
	    p.realm = ctx->realm;
	}
	ret = _kadm5_marshal_params(context, &p, &params);

	ret = krb5_write_priv_message(context, ctx->ac, &s, &params);
	krb5_data_free(&params);
	if(ret) {
	    freeaddrinfo (ai);
	    rk_closesocket(s);
	    if(ctx->ccache == NULL)
		krb5_cc_close(context, cc);
	    return ret;
	}
    } else if(ret == KRB5_SENDAUTH_BADAPPLVERS) {
	rk_closesocket(s);

	s = socket (a->ai_family, a->ai_socktype, a->ai_protocol);
	if (s < 0) {
	    freeaddrinfo (ai);
	    krb5_clear_error_message(context);
	    return errno;
	}
	if (connect (s, a->ai_addr, a->ai_addrlen) < 0) {
	    rk_closesocket (s);
	    freeaddrinfo (ai);
	    krb5_clear_error_message(context);
	    return errno;
	}
	ret = krb5_sendauth(context, &ctx->ac, &s,
			    KADMIN_OLD_APPL_VERSION, NULL,
			    server, AP_OPTS_MUTUAL_REQUIRED,
			    NULL, NULL, cc, NULL, NULL, NULL);
    }
    freeaddrinfo (ai);
    if(ret) {
	rk_closesocket(s);
	return ret;
    }

    krb5_free_principal(context, server);
    if(ctx->ccache == NULL)
	krb5_cc_close(context, cc);
    ctx->sock = s;

    return 0;
}

kadm5_ret_t
_kadm5_connect(void *handle)
{
    kadm5_client_context *ctx = handle;
    if(ctx->sock == -1)
	return kadm_connect(ctx);
    return 0;
}

static kadm5_ret_t
kadm5_c_init_with_context(krb5_context context,
			  const char *client_name,
			  const char *password,
			  krb5_prompter_fct prompter,
			  const char *keytab,
			  krb5_ccache ccache,
			  const char *service_name,
			  kadm5_config_params *realm_params,
			  unsigned long struct_version,
			  unsigned long api_version,
			  void **server_handle)
{
    kadm5_ret_t ret;
    kadm5_client_context *ctx;
    krb5_ccache cc;

    ret = _kadm5_c_init_context(&ctx, realm_params, context);
    if(ret)
	return ret;

    if(password != NULL && *password != '\0') {
	ret = _kadm5_c_get_cred_cache(context,
				      client_name,
				      service_name,
				      password, prompter, keytab, ccache, &cc);
	if(ret)
	    return ret; /* XXX */
	ccache = cc;
    }


    if (client_name != NULL)
	ctx->client_name = strdup(client_name);
    else
	ctx->client_name = NULL;
    if (service_name != NULL)
	ctx->service_name = strdup(service_name);
    else
	ctx->service_name = NULL;
    ctx->prompter = prompter;
    ctx->keytab = keytab;
    ctx->ccache = ccache;
    /* maybe we should copy the params here */
    ctx->sock = -1;

    *server_handle = ctx;
    return 0;
}

static kadm5_ret_t
init_context(const char *client_name,
	     const char *password,
	     krb5_prompter_fct prompter,
	     const char *keytab,
	     krb5_ccache ccache,
	     const char *service_name,
	     kadm5_config_params *realm_params,
	     unsigned long struct_version,
	     unsigned long api_version,
	     void **server_handle)
{
    krb5_context context;
    kadm5_ret_t ret;
    kadm5_server_context *ctx;

    ret = krb5_init_context(&context);
    if (ret)
	return ret;
    ret = kadm5_c_init_with_context(context,
				    client_name,
				    password,
				    prompter,
				    keytab,
				    ccache,
				    service_name,
				    realm_params,
				    struct_version,
				    api_version,
				    server_handle);
    if(ret){
	krb5_free_context(context);
	return ret;
    }
    ctx = *server_handle;
    ctx->my_context = 1;
    return 0;
}

kadm5_ret_t
kadm5_c_init_with_password_ctx(krb5_context context,
			       const char *client_name,
			       const char *password,
			       const char *service_name,
			       kadm5_config_params *realm_params,
			       unsigned long struct_version,
			       unsigned long api_version,
			       void **server_handle)
{
    return kadm5_c_init_with_context(context,
				     client_name,
				     password,
				     krb5_prompter_posix,
				     NULL,
				     NULL,
				     service_name,
				     realm_params,
				     struct_version,
				     api_version,
				     server_handle);
}

kadm5_ret_t
kadm5_c_init_with_password(const char *client_name,
			   const char *password,
			   const char *service_name,
			   kadm5_config_params *realm_params,
			   unsigned long struct_version,
			   unsigned long api_version,
			   void **server_handle)
{
    return init_context(client_name,
			password,
			krb5_prompter_posix,
			NULL,
			NULL,
			service_name,
			realm_params,
			struct_version,
			api_version,
			server_handle);
}

kadm5_ret_t
kadm5_c_init_with_skey_ctx(krb5_context context,
			   const char *client_name,
			   const char *keytab,
			   const char *service_name,
			   kadm5_config_params *realm_params,
			   unsigned long struct_version,
			   unsigned long api_version,
			   void **server_handle)
{
    return kadm5_c_init_with_context(context,
				     client_name,
				     NULL,
				     NULL,
				     keytab,
				     NULL,
				     service_name,
				     realm_params,
				     struct_version,
				     api_version,
				     server_handle);
}


kadm5_ret_t
kadm5_c_init_with_skey(const char *client_name,
		     const char *keytab,
		     const char *service_name,
		     kadm5_config_params *realm_params,
		     unsigned long struct_version,
		     unsigned long api_version,
		     void **server_handle)
{
    return init_context(client_name,
			NULL,
			NULL,
			keytab,
			NULL,
			service_name,
			realm_params,
			struct_version,
			api_version,
			server_handle);
}

kadm5_ret_t
kadm5_c_init_with_creds_ctx(krb5_context context,
			    const char *client_name,
			    krb5_ccache ccache,
			    const char *service_name,
			    kadm5_config_params *realm_params,
			    unsigned long struct_version,
			    unsigned long api_version,
			    void **server_handle)
{
    return kadm5_c_init_with_context(context,
				     client_name,
				     NULL,
				     NULL,
				     NULL,
				     ccache,
				     service_name,
				     realm_params,
				     struct_version,
				     api_version,
				     server_handle);
}

kadm5_ret_t
kadm5_c_init_with_creds(const char *client_name,
			krb5_ccache ccache,
			const char *service_name,
			kadm5_config_params *realm_params,
			unsigned long struct_version,
			unsigned long api_version,
			void **server_handle)
{
    return init_context(client_name,
			NULL,
			NULL,
			NULL,
			ccache,
			service_name,
			realm_params,
			struct_version,
			api_version,
			server_handle);
}

#if 0
kadm5_ret_t
kadm5_init(char *client_name, char *pass,
	   char *service_name,
	   kadm5_config_params *realm_params,
	   unsigned long struct_version,
	   unsigned long api_version,
	   void **server_handle)
{
}
#endif

@


1.3
log
@update kerberosV to Heimdal 1.5.2 using BSD Makefiles based
on the ones from FreeBSD

This is getting commited now so that we can patch it up
fast in the tree.
There are known regressions so please don't try to build
this on your own now, please wait for the next available
snapshot.

If however you would still want to build it, make sure
build and install everything in the tools directory first.

This is not the full commit yet because there are several
subdirectories.
@
text
@d46 1
a46 1
RCSID("$Id$");
@


1.2
log
@Coverity fixes backported from the heimdal cvs.

ok beck@@, No problem deraadt@@
@
text
@d2 3
a4 3
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
 * (Royal Institute of Technology, Stockholm, Sweden). 
 * All rights reserved. 
d6 3
a8 3
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
d10 2
a11 2
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
d13 3
a15 3
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
d17 3
a19 3
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
d21 11
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d36 1
d38 2
d41 2
d44 1
d46 1
a46 1
RCSID("$KTH: init_c.c,v 1.51 2005/05/13 10:57:13 lha Exp $");
d67 1
a67 1
_kadm5_c_init_context(kadm5_client_context **ctx, 
d126 1
a126 1
	(*ctx)->kadmind_port = krb5_getportbyname (context, "kerberos-adm", 
d139 1
a139 1
    
d143 1
a143 1
    if(ret) 
d165 1
a165 1
    
d170 3
a172 3
    krb5_get_init_creds_opt_set_default_flags(context, "kadmin", 
					      krb5_principal_get_realm(context, 
								       client), 
d186 1
a186 1
	    krb5_get_init_creds_opt_free(opt);
d208 1
a208 1
    krb5_get_init_creds_opt_free(opt);
d219 1
a219 1
    ret = krb5_cc_gen_new(context, &krb5_mcc_ops, &id);
d233 82
d328 1
a328 1
    
d334 1
a334 1
    
d337 1
a337 1
	if(ret) 
d341 6
a346 1
    if(password != NULL || prompter != NULL) {
a347 30
	ret = krb5_cc_default(context, &id);
	if(ret == 0) {
	    ret = krb5_cc_get_principal(context, id, &default_client);
	    if(ret) {
		krb5_cc_close(context, id);
		id = NULL;
	    } else {
		const char *name, *inst;
		krb5_principal tmp;
		name = krb5_principal_get_comp_string(context, 
						      default_client, 0);
		inst = krb5_principal_get_comp_string(context, 
						      default_client, 1);
		if(inst == NULL || strcmp(inst, "admin") != 0) {
		    ret = krb5_make_principal(context, &tmp, NULL, 
					      name, "admin", NULL);
		    if(ret != 0) {
			krb5_free_principal(context, default_client);
			if (client)
			    krb5_free_principal(context, client);
			krb5_cc_close(context, id);
			return ret;
		    }
		    krb5_free_principal(context, default_client);
		    default_client = tmp;
		    krb5_cc_close(context, id);
		    id = NULL;
		}
	    }
	}
d349 5
a353 15
	if (client != NULL) {
	    /* A client was specified by the caller. */
	    if (default_client != NULL) {
		krb5_free_principal(context, default_client);
		default_client = NULL;
	    }
	}
	else if (default_client != NULL)
	    /* No client was specified by the caller, but we have a
	     * client from the default credentials cache.
	     */
	    client = default_client;
	else {
	    /* No client was specified by the caller and we cannot determine
	     * the client from a credentials cache.
d359 2
a360 1
	    if(user == NULL)
d362 2
a363 1
	    ret = krb5_make_principal(context, &client, 
a366 4
	    if (id != NULL) {
		krb5_cc_close(context, id);
		id = NULL;
	    }
a367 5
    } else if(ccache != NULL) {
	id = ccache;
	ret = krb5_cc_get_principal(context, id, &client);
	if(ret)
	    return ret;
d370 11
a380 3
    
    if(id && (default_client == NULL || 
	      krb5_principal_compare(context, client, default_client))) {
d399 1
a399 1
    ret = get_new_cache(context, client, password, prompter, keytab, 
d411 1
a411 1
    int s;
d423 1
a423 1
    
d432 2
a433 1
    if (error) 
d435 2
a436 1
    
d442 1
d444 1
a444 1
	    close (s);
d451 1
d456 3
a458 3
				  ctx->client_name, 
				  ctx->service_name, 
				  NULL, ctx->prompter, ctx->keytab, 
d460 1
a460 1
    
d463 1
a463 1
	close(s);
d474 2
a475 1
	close(s);
d485 1
a485 1
	close(s);
d490 3
a492 3
    ret = krb5_sendauth(context, &ctx->ac, &s, 
			KADMIN_APPL_VERSION, NULL, 
			server, AP_OPTS_MUTUAL_REQUIRED, 
d503 1
a503 1
	
d508 1
a508 1
	    close(s);
d514 1
a514 1
	close(s);
d519 1
d523 1
a523 1
	    close (s);
d525 1
d528 3
a530 3
	ret = krb5_sendauth(context, &ctx->ac, &s, 
			    KADMIN_OLD_APPL_VERSION, NULL, 
			    server, AP_OPTS_MUTUAL_REQUIRED, 
d535 1
a535 1
	close(s);
d538 1
a538 1
    
a541 4
    if(ret) {
	close(s);
	return ret;
    }
d543 1
a543 1
    
d556 1
a556 1
static kadm5_ret_t 
d558 1
a558 1
			  const char *client_name, 
d578 1
a578 1
	ret = _kadm5_c_get_cred_cache(context, 
d580 1
a580 1
				      service_name, 
d586 1
a586 1
    
d601 1
a601 1
    
d606 2
a607 2
static kadm5_ret_t 
init_context(const char *client_name, 
d621 1
a621 1
    
d645 1
a645 1
kadm5_ret_t 
d647 1
a647 1
			       const char *client_name, 
d668 2
a669 2
kadm5_ret_t 
kadm5_c_init_with_password(const char *client_name, 
d677 2
a678 2
    return init_context(client_name, 
			password, 
d682 4
a685 4
			service_name, 
			realm_params, 
			struct_version, 
			api_version, 
d689 1
a689 1
kadm5_ret_t 
d691 1
a691 1
			   const char *client_name, 
d713 2
a714 2
kadm5_ret_t 
kadm5_c_init_with_skey(const char *client_name, 
d722 1
a722 1
    return init_context(client_name, 
d727 4
a730 4
			service_name, 
			realm_params, 
			struct_version, 
			api_version, 
d734 1
a734 1
kadm5_ret_t 
d757 1
a757 1
kadm5_ret_t 
d766 1
a766 1
    return init_context(client_name, 
d771 4
a774 4
			service_name, 
			realm_params, 
			struct_version, 
			api_version, 
d779 1
a779 1
kadm5_ret_t 
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2000 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: init_c.c,v 1.40 2000/12/31 08:00:23 assar Exp $");
d75 2
a76 1
    if(params->mask & KADM5_CONFIG_REALM)
d78 8
a85 2
    else
	krb5_get_default_realm((*ctx)->context, &(*ctx)->realm);
d92 3
a94 1
	if (ret)
d96 1
d101 3
a103 1
    if ((*ctx)->admin_server == NULL)
d105 1
d157 1
a157 1
    krb5_get_init_creds_opt opt;
d160 12
a171 3
    krb5_get_init_creds_opt_init (&opt);
    krb5_get_init_creds_opt_set_forwardable (&opt, FALSE);
    krb5_get_init_creds_opt_set_proxiable (&opt, FALSE);
d179 2
a180 1
	if(ret) 
d182 1
d189 1
a189 1
					  &opt);
d200 1
a200 1
					    &opt);
d202 1
d222 1
a222 1
    krb5_free_creds_contents (context, &cred);
d227 9
a235 9
static krb5_error_code
get_cred_cache(krb5_context context,
	       const char *client_name,
	       const char *server_name,
	       const char *password,
	       krb5_prompter_fct prompter,
	       const char *keytab,
	       krb5_ccache ccache,
	       krb5_ccache *ret_cache)
d261 30
d293 4
a296 2
	
	if(client == NULL)
d298 4
a301 1
	if(client == NULL) {
a311 4
	}
	if(client != default_client) {
	    krb5_free_principal(context, default_client);
	    default_client = NULL;
d317 1
a317 1
    } else if(ccache != NULL)
d319 5
a324 1

d340 1
a340 1
    if(id)
d363 1
d397 5
a401 3
    ret = get_cred_cache(context, ctx->client_name, ctx->service_name, 
			 NULL, ctx->prompter, ctx->keytab, 
			 ctx->ccache, &cc);
d408 14
a421 1
    ret = krb5_parse_name(context, KADM5_ADMIN_SERVICE, &server);
d437 7
a443 1
	ret = _kadm5_marshal_params(context, ctx->realm_params, &params);
d521 4
a524 2
	ret = get_cred_cache(context, client_name, service_name, 
			     password, prompter, keytab, ccache, &cc);
d542 1
a542 1
    ctx->realm_params = realm_params;
@


1.1.1.1
log
@Import of heimdal-0.3e
@
text
@@


1.1.1.2
log
@Import of heimdal-0.4e
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2001 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: init_c.c,v 1.41 2001/06/29 16:45:34 joda Exp $");
a147 7

    krb5_get_init_creds_opt_set_default_flags(context, "kadmin", 
					      krb5_principal_get_realm(context, 
								       client), 
					      &opt);


@


1.1.1.3
log
@Import of heimdal-0.6rc1
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2003 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: init_c.c,v 1.45 2003/04/01 15:06:41 lha Exp $");
a242 20
	    } else {
		const char *name, *inst;
		krb5_principal tmp;
		name = krb5_principal_get_comp_string(context, 
						      default_client, 0);
		inst = krb5_principal_get_comp_string(context, 
						      default_client, 1);
		if(inst == NULL || strcmp(inst, "admin") != 0) {
		    ret = krb5_make_principal(context, &tmp, NULL, 
					      name, "admin", NULL);
		    if(ret != 0) {
			krb5_free_principal(context, default_client);
			krb5_cc_close(context, id);
			return ret;
		    }
		    krb5_free_principal(context, default_client);
		    default_client = tmp;
		    krb5_cc_close(context, id);
		    id = NULL;
		}
d245 2
a246 12

	if (client != NULL) {
	    /* A client was specified by the caller. */
	    if (default_client != NULL) {
		krb5_free_principal(context, default_client);
		default_client = NULL;
	    }
	}
	else if (default_client != NULL)
	    /* No client was specified by the caller, but we have a
	     * client from the default credentials cache.
	     */
d248 1
a248 4
	else {
	    /* No client was specified by the caller and we cannot determine
	     * the client from a credentials cache.
	     */
d259 4
d271 1
a309 1
    char *service_name;
d352 1
a352 14

    if (ctx->realm)
	asprintf(&service_name, "%s@@%s", KADM5_ADMIN_SERVICE, ctx->realm);
    else
	asprintf(&service_name, "%s", KADM5_ADMIN_SERVICE);

    if (service_name == NULL) {
	freeaddrinfo (ai);
	close(s);
	return ENOMEM;
    }

    ret = krb5_parse_name(context, service_name, &server);
    free(service_name);
d368 1
a368 7
	kadm5_config_params p;
	memset(&p, 0, sizeof(p));
	if(ctx->realm) {
	    p.mask |= KADM5_CONFIG_REALM;
	    p.realm = ctx->realm;
	}
	ret = _kadm5_marshal_params(context, &p, &params);
d465 1
a465 1
    /* maybe we should copy the params here */
@


1.1.1.4
log
@Import of heimdal-0.6.3
@
text
@d40 1
a40 1
RCSID("$KTH: init_c.c,v 1.45.2.1 2003/12/21 22:48:13 lha Exp $");
d75 1
a75 2
    if(params->mask & KADM5_CONFIG_REALM) {
	ret = 0;
d77 2
a78 8
	if ((*ctx)->realm == NULL)
	    ret = ENOMEM;
    } else
	ret = krb5_get_default_realm((*ctx)->context, &(*ctx)->realm);
    if (ret) {
	free(*ctx);
	return ret;
    }
d85 1
a85 3
	if (ret) {
	    free((*ctx)->realm);
	    free(*ctx);
a86 1
	}
d91 1
a91 1
    if ((*ctx)->admin_server == NULL) {
a92 3
	free((*ctx)->realm);
	free(*ctx);
    }
@


1.1.1.5
log
@Import of heimdal-0.7.2
@
text
@d2 1
a2 1
 * Copyright (c) 1997 - 2004 Kungliga Tekniska Högskolan
d40 1
a40 1
RCSID("$KTH: init_c.c,v 1.51 2005/05/13 10:57:13 lha Exp $");
d102 1
a104 1
	return ENOMEM;
d157 1
a157 1
    krb5_get_init_creds_opt *opt;
d160 1
a160 3
    ret = krb5_get_init_creds_opt_alloc (context, &opt);
    if (ret)
	return ret;
d165 1
a165 1
					      opt);
d168 2
a169 2
    krb5_get_init_creds_opt_set_forwardable (opt, FALSE);
    krb5_get_init_creds_opt_set_proxiable (opt, FALSE);
d177 1
a177 2
	if(ret) {
	    krb5_get_init_creds_opt_free(opt);
a178 1
	}
d185 1
a185 1
					  opt);
d196 1
a196 1
					    opt);
a197 1
    krb5_get_init_creds_opt_free(opt);
d217 1
a217 1
    krb5_free_cred_contents (context, &cred);
d222 9
a230 9
krb5_error_code
_kadm5_c_get_cred_cache(krb5_context context,
			const char *client_name,
			const char *server_name,
			const char *password,
			krb5_prompter_fct prompter,
			const char *keytab,
			krb5_ccache ccache,
			krb5_ccache *ret_cache)
d385 3
a387 5
    ret = _kadm5_c_get_cred_cache(context,
				  ctx->client_name, 
				  ctx->service_name, 
				  NULL, ctx->prompter, ctx->keytab, 
				  ctx->ccache, &cc);
d507 2
a508 4
	ret = _kadm5_c_get_cred_cache(context, 
				      client_name,
				      service_name, 
				      password, prompter, keytab, ccache, &cc);
@


