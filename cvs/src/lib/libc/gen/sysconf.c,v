head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.6
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.8
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.4
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.2
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.8.0.12
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.10
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.8
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.6
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.4.0.20
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.18
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.16
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.14
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.12
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.10
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.8
	OPENBSD_2_7_BASE:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.03.20.02.32.40;	author guenther;	state Exp;
branches;
next	1.23;
commitid	va8OhMk7nsI8YWCs;

1.23
date	2015.09.12.14.56.50;	author guenther;	state Exp;
branches;
next	1.22;
commitid	BXATo6E2rFBuIXKr;

1.22
date	2015.01.16.18.18.58;	author millert;	state Exp;
branches;
next	1.21;
commitid	eexzrTnC64Onwk7E;

1.21
date	2015.01.16.16.48.51;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	0DYulI8hhujBHMcR;

1.20
date	2014.07.08.17.19.21;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	EF98ch02VpFassUi;

1.19
date	2014.04.08.14.04.11;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.24.20.04.35;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.08.29.21.46.29;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2012.06.24.20.11.16;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2012.05.14.23.21.35;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2012.03.06.11.38.26;	author ajacoutot;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.25.20.10.10;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.10.28.02.06.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2010.01.15.08.35.47;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.25.14.54.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.16.19.56.27;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.08.08.05.34;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.18.02.05.52;	author jfb;	state Exp;
branches;
next	1.6;

1.6
date	2004.05.07.18.39.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.20.18.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	98.06.02.06.10.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.15.09.31.06;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.08.19.08.26.24;	author tholo;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.41.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.41.58;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Rearrange C runtime bits: now that ld.so exports environ and __progname,
move their definitions and initialization in static links to libc.a
Make crt0 always invoke a new func _csu_finish() in libc to process the auxv
and to either register the ld.so cleanup function (in dynamic links) or
initialize environ and __progname and do MC_DISABLE_KBIND (in static links).
In libc, get pagesize from auxv; cache that between getpagesize() and
sysconf(_SC_PAGESIZE)

ok mpi@@ "good time" deraadt@@
@
text
@/*	$OpenBSD: sysconf.c,v 1.23 2015/09/12 14:56:50 guenther Exp $ */
/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Sean Eric Fagan of Cygnus Support.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/sem.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/socket.h>

#include <errno.h>
#include <grp.h>
#include <pthread.h>
#include <pwd.h>
#include <stdio.h>
#include <unistd.h>

/*
 * sysconf --
 *	get configurable system variables.
 *
 * XXX
 * POSIX 1003.1 (ISO/IEC 9945-1, 4.8.1.3) states that the variable values
 * not change during the lifetime of the calling process.  This would seem
 * to require that any change to system limits kill all running processes.
 * A workaround might be to cache the values when they are first retrieved
 * and then simply return the cached value on subsequent calls.  This is
 * less useful than returning up-to-date values, however.
 */
long
sysconf(int name)
{
	struct rlimit rl;
	size_t len;
	int mib[3], value, namelen, sverrno;

	len = sizeof(value);
	namelen = 2;

	switch (name) {
/* 1003.1 */
	case _SC_ARG_MAX:
		mib[0] = CTL_KERN;
		mib[1] = KERN_ARGMAX;
		break;
	case _SC_CHILD_MAX:
		if (getrlimit(RLIMIT_NPROC, &rl) != 0)
			return (-1);
		if (rl.rlim_cur == RLIM_INFINITY)
			return (-1);
		if (rl.rlim_cur > LONG_MAX) {
			errno = EOVERFLOW;
			return (-1);
		}
		return ((long)rl.rlim_cur);
	case _SC_CLK_TCK:
		return (CLK_TCK);
	case _SC_JOB_CONTROL:
		return (_POSIX_JOB_CONTROL);
	case _SC_NGROUPS_MAX:
		mib[0] = CTL_KERN;
		mib[1] = KERN_NGROUPS;
		break;
	case _SC_OPEN_MAX:
		if (getrlimit(RLIMIT_NOFILE, &rl) != 0)
			return (-1);
		if (rl.rlim_cur == RLIM_INFINITY)
			return (-1);
		if (rl.rlim_cur > LONG_MAX) {
			errno = EOVERFLOW;
			return (-1);
		}
		return ((long)rl.rlim_cur);
	case _SC_STREAM_MAX:
		if (getrlimit(RLIMIT_NOFILE, &rl) != 0)
			return (-1);
		if (rl.rlim_cur == RLIM_INFINITY)
			return (-1);
		if (rl.rlim_cur > LONG_MAX) {
			errno = EOVERFLOW;
			return (-1);
		}
		/*
		 * struct __sFILE currently has a limitation that
		 * file descriptors must fit in a signed short.
		 * This doesn't precisely capture the letter of POSIX
		 * but approximates the spirit.
		 */
		if (rl.rlim_cur > SHRT_MAX)
			return (SHRT_MAX);

		return ((long)rl.rlim_cur);
	case _SC_TZNAME_MAX:
		return (NAME_MAX);
	case _SC_SAVED_IDS:
		return (_POSIX_SAVED_IDS);
	case _SC_VERSION:
		mib[0] = CTL_KERN;
		mib[1] = KERN_POSIX1;
		break;

/* 1003.1b */
	case _SC_PAGESIZE:
		if (_pagesize != 0)
			return (_pagesize);
		mib[0] = CTL_HW;
		mib[1] = HW_PAGESIZE;
		break;
	case _SC_FSYNC:
		return (_POSIX_FSYNC);

/* 1003.1c */
	case _SC_LOGIN_NAME_MAX:
		return (LOGIN_NAME_MAX);

	case _SC_THREAD_SAFE_FUNCTIONS:
		return (_POSIX_THREAD_SAFE_FUNCTIONS);

	case _SC_GETGR_R_SIZE_MAX:
		return (_GR_BUF_LEN);

	case _SC_GETPW_R_SIZE_MAX:
		return (_PW_BUF_LEN);

/* 1003.2 */
	case _SC_BC_BASE_MAX:
		return (BC_BASE_MAX);
	case _SC_BC_DIM_MAX:
		return (BC_DIM_MAX);
	case _SC_BC_SCALE_MAX:
		return (BC_SCALE_MAX);
	case _SC_BC_STRING_MAX:
		return (BC_STRING_MAX);
	case _SC_COLL_WEIGHTS_MAX:
		return (COLL_WEIGHTS_MAX);
	case _SC_EXPR_NEST_MAX:
		return (EXPR_NEST_MAX);
	case _SC_LINE_MAX:
		return (LINE_MAX);
	case _SC_RE_DUP_MAX:
		return (RE_DUP_MAX);
	case _SC_2_VERSION:
		return (_POSIX2_VERSION);
	case _SC_2_C_BIND:
		return (_POSIX2_C_BIND);
	case _SC_2_C_DEV:
		return (_POSIX2_C_DEV);
	case _SC_2_CHAR_TERM:
		return (_POSIX2_CHAR_TERM);
	case _SC_2_FORT_DEV:
		return (_POSIX2_FORT_DEV);
	case _SC_2_FORT_RUN:
		return (_POSIX2_FORT_RUN);
	case _SC_2_LOCALEDEF:
		return (_POSIX2_LOCALEDEF);
	case _SC_2_SW_DEV:
		return (_POSIX2_SW_DEV);
	case _SC_2_UPE:
		return (_POSIX2_UPE);

/* XPG 4.2 */
	case _SC_XOPEN_SHM:
		mib[0] = CTL_KERN;
		mib[1] = KERN_SYSVSHM;
		if (sysctl(mib, namelen, &value, &len, NULL, 0) == -1)
			return (-1);
		if (value == 0)
			return (-1);
		return (value);
		break;
	case _SC_SEM_NSEMS_MAX:
		return (-1);
	case _SC_SEM_VALUE_MAX:
		return (SEM_VALUE_MAX);

/* Unsorted */
	case _SC_HOST_NAME_MAX:
		return (HOST_NAME_MAX);	/* does not include \0 */
	case _SC_MONOTONIC_CLOCK:
		return (_POSIX_MONOTONIC_CLOCK);
	case _SC_2_PBS:
	case _SC_2_PBS_ACCOUNTING:
	case _SC_2_PBS_CHECKPOINT:
	case _SC_2_PBS_LOCATE:
	case _SC_2_PBS_MESSAGE:
	case _SC_2_PBS_TRACK:
		return (_POSIX2_PBS);
	case _SC_ADVISORY_INFO:
		return (_POSIX_ADVISORY_INFO);
	case _SC_AIO_LISTIO_MAX:
	case _SC_AIO_MAX:
	case _SC_AIO_PRIO_DELTA_MAX:
		return (-1);
	case _SC_ASYNCHRONOUS_IO:
		return (_POSIX_ASYNCHRONOUS_IO);
	case _SC_ATEXIT_MAX:
		return (-1);
	case _SC_BARRIERS:
		return (_POSIX_BARRIERS);
	case _SC_CLOCK_SELECTION:
		return (_POSIX_CLOCK_SELECTION);
	case _SC_CPUTIME:
		return (_POSIX_CPUTIME);
	case _SC_DELAYTIMER_MAX:
		return (-1);
	case _SC_IOV_MAX:
		return (IOV_MAX);
	case _SC_IPV6:
#if _POSIX_IPV6 == 0
		sverrno = errno;
		value = socket(PF_INET6, SOCK_DGRAM, 0);
		errno = sverrno;
		if (value >= 0) {
			close(value);
			return (200112L);
		} else
			return (0);
#else
		return (_POSIX_IPV6);
#endif
	case _SC_MAPPED_FILES:
		return (_POSIX_MAPPED_FILES);
	case _SC_MEMLOCK:
		return (_POSIX_MEMLOCK);
	case _SC_MEMLOCK_RANGE:
		return (_POSIX_MEMLOCK_RANGE);
	case _SC_MEMORY_PROTECTION:
		return (_POSIX_MEMORY_PROTECTION);
	case _SC_MESSAGE_PASSING:
		return (_POSIX_MESSAGE_PASSING);
	case _SC_PRIORITIZED_IO:
		return (_POSIX_PRIORITIZED_IO);
	case _SC_PRIORITY_SCHEDULING:
		return (_POSIX_PRIORITY_SCHEDULING);
	case _SC_RAW_SOCKETS:
		return (_POSIX_RAW_SOCKETS);
	case _SC_READER_WRITER_LOCKS:
		return (_POSIX_READER_WRITER_LOCKS);
	case _SC_REALTIME_SIGNALS:
		return (_POSIX_REALTIME_SIGNALS);
	case _SC_REGEXP:
		return (_POSIX_REGEXP);
	case _SC_SEMAPHORES:
		return (_POSIX_SEMAPHORES);
	case _SC_SHARED_MEMORY_OBJECTS:
		return (_POSIX_SHARED_MEMORY_OBJECTS);
	case _SC_SHELL:
		return (_POSIX_SHELL);
	case _SC_SIGQUEUE_MAX:
		return (-1);
	case _SC_SPAWN:
		return (_POSIX_SPAWN);
	case _SC_SPIN_LOCKS:
		return (_POSIX_SPIN_LOCKS);
	case _SC_SPORADIC_SERVER:
		return (_POSIX_SPORADIC_SERVER);
	case _SC_SYNCHRONIZED_IO:
		return (_POSIX_SYNCHRONIZED_IO);
	case _SC_SYMLOOP_MAX:
		return (SYMLOOP_MAX);
	case _SC_THREAD_ATTR_STACKADDR:
		return (_POSIX_THREAD_ATTR_STACKADDR);
	case _SC_THREAD_ATTR_STACKSIZE:
		return (_POSIX_THREAD_ATTR_STACKSIZE);
	case _SC_THREAD_CPUTIME:
		return (_POSIX_THREAD_CPUTIME);
	case _SC_THREAD_DESTRUCTOR_ITERATIONS:
		return (PTHREAD_DESTRUCTOR_ITERATIONS);
	case _SC_THREAD_KEYS_MAX:
		return (PTHREAD_KEYS_MAX);
	case _SC_THREAD_PRIO_INHERIT:
		return (_POSIX_THREAD_PRIO_INHERIT);
	case _SC_THREAD_PRIO_PROTECT:
		return (_POSIX_THREAD_PRIO_PROTECT);
	case _SC_THREAD_PRIORITY_SCHEDULING:
		return (_POSIX_THREAD_PRIORITY_SCHEDULING);
	case _SC_THREAD_PROCESS_SHARED:
		return (_POSIX_THREAD_PROCESS_SHARED);
	case _SC_THREAD_ROBUST_PRIO_INHERIT:
		return (_POSIX_THREAD_ROBUST_PRIO_INHERIT);
	case _SC_THREAD_ROBUST_PRIO_PROTECT:
		return (_POSIX_THREAD_ROBUST_PRIO_PROTECT);
	case _SC_THREAD_SPORADIC_SERVER:
		return (_POSIX_THREAD_SPORADIC_SERVER);
	case _SC_THREAD_STACK_MIN:
		return (PTHREAD_STACK_MIN);
	case _SC_THREAD_THREADS_MAX:
		return (PTHREAD_THREADS_MAX);
	case _SC_THREADS:
		return (_POSIX_THREADS);
	case _SC_TIMEOUTS:
		return (_POSIX_TIMEOUTS);
	case _SC_TIMER_MAX:
		return (-1);
	case _SC_TIMERS:
		return (_POSIX_TIMERS);
	case _SC_TRACE:
	case _SC_TRACE_EVENT_FILTER:
	case _SC_TRACE_EVENT_NAME_MAX:
	case _SC_TRACE_INHERIT:
	case _SC_TRACE_LOG:
		return (_POSIX_TRACE);
	case _SC_TTY_NAME_MAX:
		return (TTY_NAME_MAX);
	case _SC_TYPED_MEMORY_OBJECTS:
		return (_POSIX_TYPED_MEMORY_OBJECTS);
	case _SC_V6_ILP32_OFF32:
		return (_POSIX_V6_ILP32_OFF32);
	case _SC_V6_ILP32_OFFBIG:
#if _POSIX_V6_ILP32_OFFBIG == 0
		if (sizeof(int) * CHAR_BIT == 32 &&
		    sizeof(long) * CHAR_BIT == 32 &&
		    sizeof(void *) * CHAR_BIT == 32 &&
		    sizeof(off_t) * CHAR_BIT >= 64)
			return 1;
		else
			return -1;
#else
		return (_POSIX_V6_ILP32_OFFBIG);
#endif
	case _SC_V6_LP64_OFF64:
#if _POSIX_V6_LP64_OFF64 == 0
		if (sizeof(int) * CHAR_BIT == 32 &&
		    sizeof(long) * CHAR_BIT == 64 &&
		    sizeof(void *) * CHAR_BIT == 64 &&
		    sizeof(off_t) * CHAR_BIT == 64)
			return 1;
		else
			return -1;
#else
		return (_POSIX_V6_LP64_OFF64);
#endif
	case _SC_V6_LPBIG_OFFBIG:
#if _POSIX_V6_LPBIG_OFFBIG == 0
		if (sizeof(int) * CHAR_BIT >= 32 &&
		    sizeof(long) * CHAR_BIT >= 64 &&
		    sizeof(void *) * CHAR_BIT >= 64 &&
		    sizeof(off_t) * CHAR_BIT >= 64)
			return 1;
		else
			return -1;
#else
		return (_POSIX_V6_LPBIG_OFFBIG);
#endif
	case _SC_V7_ILP32_OFF32:
		return (_POSIX_V7_ILP32_OFF32);
	case _SC_V7_ILP32_OFFBIG:
#if _POSIX_V7_ILP32_OFFBIG == 0
		if (sizeof(int) * CHAR_BIT == 32 &&
		    sizeof(long) * CHAR_BIT == 32 &&
		    sizeof(void *) * CHAR_BIT == 32 &&
		    sizeof(off_t) * CHAR_BIT >= 64)
			return 1;
		else
			return -1;
#else
		return (_POSIX_V7_ILP32_OFFBIG);
#endif
	case _SC_V7_LP64_OFF64:
#if _POSIX_V7_LP64_OFF64 == 0
		if (sizeof(int) * CHAR_BIT == 32 &&
		    sizeof(long) * CHAR_BIT == 64 &&
		    sizeof(void *) * CHAR_BIT == 64 &&
		    sizeof(off_t) * CHAR_BIT == 64)
			return 1;
		else
			return -1;
#else
		return (_POSIX_V7_LP64_OFF64);
#endif
	case _SC_V7_LPBIG_OFFBIG:
#if _POSIX_V7_LPBIG_OFFBIG == 0
		if (sizeof(int) * CHAR_BIT >= 32 &&
		    sizeof(long) * CHAR_BIT >= 64 &&
		    sizeof(void *) * CHAR_BIT >= 64 &&
		    sizeof(off_t) * CHAR_BIT >= 64)
			return 1;
		else
			return -1;
#else
		return (_POSIX_V7_LPBIG_OFFBIG);
#endif
	case _SC_XOPEN_CRYPT:
		return (_XOPEN_CRYPT);
	case _SC_XOPEN_ENH_I18N:
		return (_XOPEN_ENH_I18N);
	case _SC_XOPEN_LEGACY:
		return (_XOPEN_LEGACY);
	case _SC_XOPEN_REALTIME:
		return (_XOPEN_REALTIME);
	case _SC_XOPEN_REALTIME_THREADS:
		return (_XOPEN_REALTIME_THREADS);
	case _SC_XOPEN_STREAMS:
		return (_XOPEN_STREAMS);
	case _SC_XOPEN_UNIX:
		return (_XOPEN_UNIX);
	case _SC_XOPEN_UUCP:
		return (_XOPEN_UUCP);
#ifdef _XOPEN_VERSION
	case _SC_XOPEN_VERSION:
		return (_XOPEN_VERSION);
#endif

/* Extensions */
	case _SC_PHYS_PAGES:
	{
		int64_t physmem;

		mib[0] = CTL_HW;
		mib[1] = HW_PHYSMEM64;
		len = sizeof(physmem);
		if (sysctl(mib, namelen, &physmem, &len, NULL, 0) == -1)
			return (-1);
		return (physmem / getpagesize());
	}
	case _SC_AVPHYS_PAGES:
	{
		struct uvmexp uvmexp;

		mib[0] = CTL_VM;
		mib[1] = VM_UVMEXP;
		len = sizeof(uvmexp);
		if (sysctl(mib, namelen, &uvmexp, &len, NULL, 0) == -1)
			return (-1);
		return (uvmexp.free);
	}

	case _SC_NPROCESSORS_CONF:
		mib[0] = CTL_HW;
		mib[1] = HW_NCPU;
		break;
	case _SC_NPROCESSORS_ONLN:
		mib[0] = CTL_HW;
		mib[1] = HW_NCPU;
		break;

	default:
		errno = EINVAL;
		return (-1);
	}
	return (sysctl(mib, namelen, &value, &len, NULL, 0) == -1 ? -1 : value); 
}
DEF_WEAK(sysconf);
@


1.23
log
@Wrap <unistd.h> so that internal calls go direct and they're all weak symbols
Delete unused 'fd' argument from internal function oldttyname()
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.22 2015/01/16 18:18:58 millert Exp $ */
d134 2
@


1.22
log
@Replace HOST_NAME_MAX+1-1 with HOST_NAME_MAX.  OK deraad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.21 2015/01/16 16:48:51 deraadt Exp $ */
d471 1
@


1.21
log
@Move to the <limits.h> universe.
review by millert, binary checking process with doug, concept with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.20 2014/07/08 17:19:21 deraadt Exp $ */
d206 1
a206 1
		return (HOST_NAME_MAX+1 - 1); /* does not include \0 */
@


1.20
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.19 2014/04/08 14:04:11 mpi Exp $ */
d34 1
a34 1
#include <sys/param.h>
d206 1
a206 1
		return (MAXHOSTNAMELEN - 1); /* does not include \0 */
@


1.19
log
@Use VM_UVMEXP instead of VM_METER for memory usages and directly
include <sys/vmmeter.h> where it is needed instead of relying on
it being included by <uvm/uvm_extern.h>.

miod@@ likes it, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.18 2013/03/24 20:04:35 guenther Exp $ */
a39 2

#include <uvm/uvm_extern.h>
@


1.18
log
@sysconf(_SC_SEM_VALUE_MAX) should return SEM_VALUE_MAX, not some
unrelated sysv sem limit.  Similarly, sysconf(_SC_SEM_NSEMS_MAX)
should return -1 instead of another sysv sem limit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.17 2012/08/29 21:46:29 matthew Exp $ */
a38 1
#include <sys/vmmeter.h>
d41 2
d448 1
a448 1
		struct vmtotal vmtotal;
d451 3
a453 3
		mib[1] = VM_METER;
		len = sizeof(vmtotal);
		if (sysctl(mib, namelen, &vmtotal, &len, NULL, 0) == -1)
d455 1
a455 1
		return (vmtotal.t_free);
@


1.17
log
@Fix _SC_CHILD_MAX, _SC_OPEN_MAX, and _SC_STREAM_MAX to correctly
handle rlim_cur set to RLIM_INFINITY or values greater than LONG_MAX,
as unlikely as those are to happen.  Further limit _SC_STREAM_MAX to
at most SHRT_MAX, because struct __sFILE uses a short int for storing
the file descriptor.

While here, also remove a dead label that Clang complains about.

From FreeBSD via Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.16 2012/06/24 20:11:16 matthew Exp $ */
d201 1
d203 1
a203 6
		mib[0] = CTL_KERN;
		mib[1] = KERN_SEMINFO;
		mib[2] = name = _SC_SEM_NSEMS_MAX ?
		    KERN_SEMINFO_SEMMNS : KERN_SEMINFO_SEMVMX;
		namelen = 3;
		break;
@


1.16
log
@In sysconf(), don't bother querying the kernel for userspace-only
values or features that POSIX now requires to always be provided.

From Brad; ok guenther and me; incorporates feedback from millert too
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.15 2012/05/14 23:21:35 matthew Exp $ */
d78 9
a86 1
		return (getrlimit(RLIMIT_NPROC, &rl) ? -1 : rl.rlim_cur);
d96 9
a104 1
		return (getrlimit(RLIMIT_NOFILE, &rl) ? -1 : rl.rlim_cur);
d106 18
a123 1
		return (FOPEN_MAX);
d194 1
a194 2

yesno:		if (sysctl(mib, namelen, &value, &len, NULL, 0) == -1)
@


1.15
log
@More sysconf(3)-y and pathconf(3)-y goodness from Brad.
ok guenther, millert (and me); bulk build test by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.14 2012/03/06 11:38:26 ajacoutot Exp $ */
d46 1
d82 1
a82 3
		mib[0] = CTL_KERN;
		mib[1] = KERN_JOB_CONTROL;
		goto yesno;
d90 1
a90 3
		mib[0] = CTL_USER;
		mib[1] = USER_STREAM_MAX;
		break;
d92 1
a92 3
		mib[0] = CTL_USER;
		mib[1] = USER_TZNAME_MAX;
		break;
d94 1
a94 3
		mib[0] = CTL_KERN;
		mib[1] = KERN_SAVED_IDS;
		goto yesno;
d106 1
a106 3
		mib[0] = CTL_KERN;
		mib[1] = KERN_FSYNC;
		goto yesno;
d123 1
a123 3
		mib[0] = CTL_USER;
		mib[1] = USER_BC_BASE_MAX;
		break;
d125 1
a125 3
		mib[0] = CTL_USER;
		mib[1] = USER_BC_DIM_MAX;
		break;
d127 1
a127 3
		mib[0] = CTL_USER;
		mib[1] = USER_BC_SCALE_MAX;
		break;
d129 1
a129 3
		mib[0] = CTL_USER;
		mib[1] = USER_BC_STRING_MAX;
		break;
d131 1
a131 3
		mib[0] = CTL_USER;
		mib[1] = USER_COLL_WEIGHTS_MAX;
		break;
d133 1
a133 3
		mib[0] = CTL_USER;
		mib[1] = USER_EXPR_NEST_MAX;
		break;
d135 1
a135 3
		mib[0] = CTL_USER;
		mib[1] = USER_LINE_MAX;
		break;
d137 1
a137 3
		mib[0] = CTL_USER;
		mib[1] = USER_RE_DUP_MAX;
		break;
d191 4
@


1.14
log
@Add the _POSIX_MONOTONIC_CLOCK symbol and the sysconf(3)
_SC_MONOTONIC_CLOCK variable.
from Brad

No libc minor crank needed, as no API has been changed, per se (deraadt).

ports bulk testing by landry@@
small man rewording from thib@@
ok millert@@ otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.13 2011/04/25 20:10:10 sthen Exp $ */
d40 1
d44 1
d65 1
a65 1
	int mib[3], value, namelen;
d164 1
a164 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_VERSION;
		break;
d166 1
a166 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_C_BIND;
		goto yesno;
d168 1
a168 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_C_DEV;
		goto yesno;
d170 1
a170 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_CHAR_TERM;
		goto yesno;
d172 1
a172 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_FORT_DEV;
		goto yesno;
d174 1
a174 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_FORT_RUN;
		goto yesno;
d176 1
a176 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_LOCALEDEF;
		goto yesno;
d178 1
a178 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_SW_DEV;
		goto yesno;
d180 1
a180 3
		mib[0] = CTL_USER;
		mib[1] = USER_POSIX2_UPE;
		goto yesno;
d207 218
@


1.13
log
@Teach sysconf(_SC_GETGR_R_SIZE_MAX) the correct size of a buffer for the
reentrant getgrent functions (getgrgid_r, getgrnam_r).

seems reasonable to millert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.12 2010/10/28 02:06:00 deraadt Exp $ */
d221 2
@


1.12
log
@support _SC_HOST_NAME_MAX; from brad
a libc crank is happening in < 24 hours
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.11 2010/01/15 08:35:47 sthen Exp $ */
d42 1
d123 1
a123 1
		return (_PW_BUF_LEN);
@


1.11
log
@Add support to sysconf(3) for the variables _SC_NPROCESSORS_CONF and
_SC_NPROCESSORS_ONLN, implemented by AIX/Tru64/Solaris/Linux/SCO/FreeBSD/NetBSD.
Bump libc minor.

From Brad, ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.10 2008/06/25 14:54:44 millert Exp $ */
d216 4
@


1.10
log
@Implement _SC_GETGR_R_SIZE_MAX, _SC_GETPW_R_SIZE_MAX, _SC_LOGIN_NAME_MAX,
and _SC_THREAD_SAFE_FUNCTIONS for sysconf(3).  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.9 2008/03/16 19:56:27 kettenis Exp $ */
d240 9
@


1.9
log
@Add the semi-standard _SC_PHYS_PAGES and _SC_AVPHYS_PAGES, sysconf(3) variable.

ok espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysconf.c,v 1.8 2005/08/08 08:05:34 espie Exp $ */
d42 1
d113 13
@


1.8
log
@zap remaining rcsid.

Kill old files that are no longer compiled.

okay theo
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d39 1
d202 25
@


1.7
log
@ansify function definitions and zap some `register'

ok millert@@
@
text
@d1 1
a32 4

#if defined(LIBC_SCCS) && !defined(lint)
static char rcsid[] = "$OpenBSD: sysconf.c,v 1.6 2004/05/07 18:39:19 millert Exp $";
#endif /* LIBC_SCCS and not lint */
@


1.6
log
@Implement _SC_SEM_NSEMS_MAX and _SC_SEM_VALUE_MAX.
Based on a diff from Jean-Gérard Pailloncy.
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: sysconf.c,v 1.5 2003/06/02 20:18:35 millert Exp $";
d59 1
a59 2
sysconf(name)
	int name;
@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d34 1
a34 1
static char rcsid[] = "$OpenBSD: sysconf.c,v 1.4 1998/06/02 06:10:26 deraadt Exp $";
d38 1
d64 1
a64 1
	int mib[2], value;
d67 1
d191 1
a191 1
yesno:		if (sysctl(mib, 2, &value, &len, NULL, 0) == -1)
d197 8
d209 1
a209 1
	return (sysctl(mib, 2, &value, &len, NULL, 0) == -1 ? -1 : value); 
@


1.4
log
@add sysctl and sysconf support for sysvsem, sysvshm, sysvmsg, and fsync; mostly from kleink
@
text
@d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d34 1
a34 1
static char rcsid[] = "$OpenBSD: sysconf.c,v 1.3 1996/09/15 09:31:06 tholo Exp $";
@


1.3
log
@Remove dead code
Remove unused variables
Silence some warnings
lint(1) is your friend
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: sysconf.c,v 1.2 1996/08/19 08:26:24 tholo Exp $";
d108 10
d186 7
@


1.2
log
@Fix RCS ids
Make sure everything uses {SYS,}LIBC_SCCS properly
@
text
@d38 1
a38 1
static char rcsid[] = "$OpenBSD: sysconf.c,v 1.3 1995/03/04 01:56:09 cgd Exp $";
a64 1
	struct clockinfo clk;
@


1.1
log
@Initial revision
@
text
@a0 2
/*	$NetBSD: sysconf.c,v 1.3 1995/03/04 01:56:09 cgd Exp $	*/

d38 1
a38 5
#if 0
static char sccsid[] = "@@(#)sysconf.c	8.2 (Berkeley) 3/20/94";
#else
static char rcsid[] = "$NetBSD: sysconf.c,v 1.3 1995/03/04 01:56:09 cgd Exp $";
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
