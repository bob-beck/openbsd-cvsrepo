head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.2
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46;
locks; strict;
comment	@ * @;


1.50
date	2017.08.28.17.41.59;	author jsing;	state Exp;
branches;
next	1.49;
commitid	HNb94kdjIJ4zZ0dV;

1.49
date	2017.05.02.03.59.45;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	Dm63V7JYy6WzetfM;

1.48
date	2017.04.28.22.46.40;	author beck;	state Exp;
branches;
next	1.47;
commitid	11hStSIlHxe9fBKc;

1.47
date	2017.04.28.22.38.51;	author beck;	state Exp;
branches;
next	1.46;
commitid	dQno2SIagjq478c3;

1.46
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.45;
commitid	kT0fLt3r4lroFJra;

1.45
date	2017.01.21.10.38.29;	author beck;	state Exp;
branches;
next	1.44;
commitid	hKAfCRL9IRQ9ENaK;

1.44
date	2017.01.21.09.38.59;	author beck;	state Exp;
branches;
next	1.43;
commitid	iyR9b2itDMsxzmrQ;

1.43
date	2016.09.09.11.39.11;	author tb;	state Exp;
branches;
next	1.42;
commitid	gF9X9lCaWPXdCCCT;

1.42
date	2016.07.07.11.53.12;	author bcook;	state Exp;
branches;
next	1.41;
commitid	eavwKDwtZUNQRWCp;

1.41
date	2016.06.30.02.02.06;	author bcook;	state Exp;
branches;
next	1.40;
commitid	NoRqiDVUjRmOOT9v;

1.40
date	2015.09.10.15.56.25;	author jsing;	state Exp;
branches;
next	1.39;
commitid	vHznCDK3idwNEFz4;

1.39
date	2015.06.13.08.38.10;	author doug;	state Exp;
branches;
next	1.38;
commitid	A7PrDVdy9HjfQlSR;

1.38
date	2015.02.14.15.10.39;	author miod;	state Exp;
branches;
next	1.37;
commitid	k2BJ637oY92Wf8fy;

1.37
date	2015.02.09.15.49.22;	author jsing;	state Exp;
branches;
next	1.36;
commitid	69Tc75PIK8JcRRsC;

1.36
date	2014.10.18.17.20.40;	author jsing;	state Exp;
branches;
next	1.35;
commitid	8tb4v3IC8S2vzfHj;

1.35
date	2014.07.11.15.21.51;	author miod;	state Exp;
branches;
next	1.34;
commitid	wGSazvIbMXoonfV9;

1.34
date	2014.07.11.08.44.49;	author jsing;	state Exp;
branches;
next	1.33;
commitid	yQEL1wOWIearrW15;

1.33
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.32;
commitid	nzndm3zqPmFurSaK;

1.32
date	2014.07.10.07.43.11;	author jsing;	state Exp;
branches;
next	1.31;
commitid	Kf1g3OOqy6sn8Ouy;

1.31
date	2014.07.09.19.51.38;	author jsing;	state Exp;
branches;
next	1.30;
commitid	1XPBWlejiS4drgFK;

1.30
date	2014.07.09.08.44.53;	author miod;	state Exp;
branches;
next	1.29;
commitid	KbL8PrMGlaveisds;

1.29
date	2014.07.09.08.20.08;	author miod;	state Exp;
branches;
next	1.28;
commitid	JPwi7kYvSgWTaIWo;

1.28
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	mJUVYpkFBZ0Zv2bG;

1.27
date	2014.04.27.20.26.49;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.17.13.37.49;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.05.23.01.39;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.03.02.34.33;	author djm;	state Exp;
branches;
next	1.22;

1.22
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.21;

1.21
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.07.15.37.02;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.04.07.10.32;	author pvalchev;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2005.04.29.05.39.26;	author djm;	state Exp;
branches
	1.15.2.1
	1.15.4.1;
next	1.14;

1.14
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.17.19.57.16;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.15.16.35.53;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.03.45.34;	author beck;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.22.00.03.19;	author beck;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.04.22.23.33.03;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.02.58.08;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.15.17.16.32;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.13.16.26.12;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.11.39;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.42;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.52;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.52;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.53;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.35.46;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.11.11.21.17.21;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.16;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.35;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.01.09.12.13.59;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2011.11.03.02.32.14;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.01.05.22.59.01;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;

1.8.4.1
date	2003.03.19.01.05.20;	author miod;	state Exp;
branches;
next	;

1.10.2.1
date	2003.03.19.01.18.19;	author margarida;	state Exp;
branches;
next	;

1.15.2.1
date	2006.10.05.18.42.22;	author brad;	state Exp;
branches;
next	;

1.15.4.1
date	2006.10.05.17.36.24;	author brad;	state Exp;
branches;
next	;

1.16.2.1
date	2006.11.02.19.56.23;	author brad;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Remove RSA_padding_add_SSLv23()/RSA_padding_check_SSLv23() and related
code. We removed SSLv2/SSLv3 a long time ago...

Discussed with doug@@
@
text
@/* $OpenBSD: rsa_eay.c,v 1.49 2017/05/02 03:59:45 deraadt Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */

#include <stdio.h>
#include <string.h>

#include <openssl/opensslconf.h>

#include <openssl/bn.h>
#include <openssl/err.h>
#include <openssl/rsa.h>

#include "bn_lcl.h"

static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa, BN_CTX *ctx);
static int RSA_eay_init(RSA *rsa);
static int RSA_eay_finish(RSA *rsa);

static RSA_METHOD rsa_pkcs1_eay_meth = {
	.name = "Eric Young's PKCS#1 RSA",
	.rsa_pub_enc = RSA_eay_public_encrypt,
	.rsa_pub_dec = RSA_eay_public_decrypt, /* signature verification */
	.rsa_priv_enc = RSA_eay_private_encrypt, /* signing */
	.rsa_priv_dec = RSA_eay_private_decrypt,
	.rsa_mod_exp = RSA_eay_mod_exp,
	.bn_mod_exp = BN_mod_exp_mont_ct, /* XXX probably we should not use Montgomery if  e == 3 */
	.init = RSA_eay_init,
	.finish = RSA_eay_finish,
};

const RSA_METHOD *
RSA_PKCS1_SSLeay(void)
{
	return &rsa_pkcs1_eay_meth;
}

static int
RSA_eay_public_encrypt(int flen, const unsigned char *from, unsigned char *to,
    RSA *rsa, int padding)
{
	BIGNUM *f, *ret;
	int i, j, k, num = 0, r = -1;
	unsigned char *buf = NULL;
	BN_CTX *ctx = NULL;

	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS) {
		RSAerror(RSA_R_MODULUS_TOO_LARGE);
		return -1;
	}

	if (BN_ucmp(rsa->n, rsa->e) <= 0) {
		RSAerror(RSA_R_BAD_E_VALUE);
		return -1;
	}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS) {
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS) {
			RSAerror(RSA_R_BAD_E_VALUE);
			return -1;
		}
	}

	if ((ctx = BN_CTX_new()) == NULL)
		goto err;

	BN_CTX_start(ctx);
	f = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
	num = BN_num_bytes(rsa->n);
	buf = malloc(num);

	if (f == NULL || ret == NULL || buf == NULL) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	switch (padding) {
	case RSA_PKCS1_PADDING:
		i = RSA_padding_add_PKCS1_type_2(buf, num, from, flen);
		break;
#ifndef OPENSSL_NO_SHA
	case RSA_PKCS1_OAEP_PADDING:
		i = RSA_padding_add_PKCS1_OAEP(buf, num, from, flen, NULL, 0);
		break;
#endif
	case RSA_NO_PADDING:
		i = RSA_padding_add_none(buf, num, from, flen);
		break;
	default:
		RSAerror(RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
	}
	if (i <= 0)
		goto err;

	if (BN_bin2bn(buf, num, f) == NULL)
		goto err;

	if (BN_ucmp(f, rsa->n) >= 0) {
		/* usually the padding functions would catch this */
		RSAerror(RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
	}

	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
		    CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;

	if (!rsa->meth->bn_mod_exp(ret, f, rsa->e, rsa->n, ctx,
	    rsa->_method_mod_n))
		goto err;

	/* put in leading 0 bytes if the number is less than the
	 * length of the modulus */
	j = BN_num_bytes(ret);
	i = BN_bn2bin(ret, &(to[num - j]));
	for (k = 0; k < num - i; k++)
		to[k] = 0;

	r = num;
err:
	if (ctx != NULL) {
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
	}
	freezero(buf, num);
	return r;
}

static BN_BLINDING *
rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
{
	BN_BLINDING *ret;
	int got_write_lock = 0;
	CRYPTO_THREADID cur;

	CRYPTO_r_lock(CRYPTO_LOCK_RSA);

	if (rsa->blinding == NULL) {
		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
		CRYPTO_w_lock(CRYPTO_LOCK_RSA);
		got_write_lock = 1;

		if (rsa->blinding == NULL)
			rsa->blinding = RSA_setup_blinding(rsa, ctx);
	}

	ret = rsa->blinding;
	if (ret == NULL)
		goto err;

	CRYPTO_THREADID_current(&cur);
	if (!CRYPTO_THREADID_cmp(&cur, BN_BLINDING_thread_id(ret))) {
		/* rsa->blinding is ours! */
		*local = 1;
	} else {
		/* resort to rsa->mt_blinding instead */
		/*
		 * Instruct rsa_blinding_convert(), rsa_blinding_invert()
		 * that the BN_BLINDING is shared, meaning that accesses
		 * require locks, and that the blinding factor must be
		 * stored outside the BN_BLINDING
		 */
		*local = 0;

		if (rsa->mt_blinding == NULL) {
			if (!got_write_lock) {
				CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
				got_write_lock = 1;
			}

			if (rsa->mt_blinding == NULL)
				rsa->mt_blinding = RSA_setup_blinding(rsa, ctx);
		}
		ret = rsa->mt_blinding;
	}

err:
	if (got_write_lock)
		CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	else
		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
	return ret;
}

static int
rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind, BN_CTX *ctx)
{
	if (unblind == NULL)
		/*
		 * Local blinding: store the unblinding factor
		 * in BN_BLINDING.
		 */
		return BN_BLINDING_convert_ex(f, NULL, b, ctx);
	else {
		/*
		 * Shared blinding: store the unblinding factor
		 * outside BN_BLINDING.
		 */
		int ret;
		CRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING);
		ret = BN_BLINDING_convert_ex(f, unblind, b, ctx);
		CRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING);
		return ret;
	}
}

static int
rsa_blinding_invert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind, BN_CTX *ctx)
{
	/*
	 * For local blinding, unblind is set to NULL, and BN_BLINDING_invert_ex
	 * will use the unblinding factor stored in BN_BLINDING.
	 * If BN_BLINDING is shared between threads, unblind must be non-null:
	 * BN_BLINDING_invert_ex will then use the local unblinding factor,
	 * and will only read the modulus from BN_BLINDING.
	 * In both cases it's safe to access the blinding without a lock.
	 */
	return BN_BLINDING_invert_ex(f, unblind, b, ctx);
}

/* signing */
static int
RSA_eay_private_encrypt(int flen, const unsigned char *from, unsigned char *to,
    RSA *rsa, int padding)
{
	BIGNUM *f, *ret, *res;
	int i, j, k, num = 0, r = -1;
	unsigned char *buf = NULL;
	BN_CTX *ctx = NULL;
	int local_blinding = 0;
	/*
	 * Used only if the blinding structure is shared. A non-NULL unblind
	 * instructs rsa_blinding_convert() and rsa_blinding_invert() to store
	 * the unblinding factor outside the blinding structure.
	 */
	BIGNUM *unblind = NULL;
	BN_BLINDING *blinding = NULL;

	if ((ctx = BN_CTX_new()) == NULL)
		goto err;

	BN_CTX_start(ctx);
	f = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
	num = BN_num_bytes(rsa->n);
	buf = malloc(num);

	if (f == NULL || ret == NULL || buf == NULL) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	switch (padding) {
	case RSA_PKCS1_PADDING:
		i = RSA_padding_add_PKCS1_type_1(buf, num, from, flen);
		break;
	case RSA_X931_PADDING:
		i = RSA_padding_add_X931(buf, num, from, flen);
		break;
	case RSA_NO_PADDING:
		i = RSA_padding_add_none(buf, num, from, flen);
		break;
	default:
		RSAerror(RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
	}
	if (i <= 0)
		goto err;

	if (BN_bin2bn(buf, num, f) == NULL)
		goto err;

	if (BN_ucmp(f, rsa->n) >= 0) {
		/* usually the padding functions would catch this */
		RSAerror(RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
	}

	if (!(rsa->flags & RSA_FLAG_NO_BLINDING)) {
		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
		if (blinding == NULL) {
			RSAerror(ERR_R_INTERNAL_ERROR);
			goto err;
		}
	}

	if (blinding != NULL) {
		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL)) {
			RSAerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!rsa_blinding_convert(blinding, f, unblind, ctx))
			goto err;
	}

	if ((rsa->flags & RSA_FLAG_EXT_PKEY) ||
	    (rsa->p != NULL && rsa->q != NULL && rsa->dmp1 != NULL &&
	    rsa->dmq1 != NULL && rsa->iqmp != NULL)) {
		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx))
			goto err;
	} else {
		BIGNUM d;

		BN_init(&d);
		BN_with_flags(&d, rsa->d, BN_FLG_CONSTTIME);

		if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
			    CRYPTO_LOCK_RSA, rsa->n, ctx))
				goto err;

		if (!rsa->meth->bn_mod_exp(ret, f, &d, rsa->n, ctx,
		    rsa->_method_mod_n)) {
			goto err;
		}
	}

	if (blinding)
		if (!rsa_blinding_invert(blinding, ret, unblind, ctx))
			goto err;

	if (padding == RSA_X931_PADDING) {
		BN_sub(f, rsa->n, ret);
		if (BN_cmp(ret, f) > 0)
			res = f;
		else
			res = ret;
	} else
		res = ret;

	/* put in leading 0 bytes if the number is less than the
	 * length of the modulus */
	j = BN_num_bytes(res);
	i = BN_bn2bin(res, &(to[num - j]));
	for (k = 0; k < num - i; k++)
		to[k] = 0;

	r = num;
err:
	if (ctx != NULL) {
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
	}
	freezero(buf, num);
	return r;
}

static int
RSA_eay_private_decrypt(int flen, const unsigned char *from, unsigned char *to,
    RSA *rsa, int padding)
{
	BIGNUM *f, *ret;
	int j, num = 0, r = -1;
	unsigned char *p;
	unsigned char *buf = NULL;
	BN_CTX *ctx = NULL;
	int local_blinding = 0;
	/*
	 * Used only if the blinding structure is shared. A non-NULL unblind
	 * instructs rsa_blinding_convert() and rsa_blinding_invert() to store
	 * the unblinding factor outside the blinding structure.
	 */
	BIGNUM *unblind = NULL;
	BN_BLINDING *blinding = NULL;

	if ((ctx = BN_CTX_new()) == NULL)
		goto err;

	BN_CTX_start(ctx);
	f = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
	num = BN_num_bytes(rsa->n);
	buf = malloc(num);

	if (!f || !ret || !buf) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/* This check was for equality but PGP does evil things
	 * and chops off the top '0' bytes */
	if (flen > num) {
		RSAerror(RSA_R_DATA_GREATER_THAN_MOD_LEN);
		goto err;
	}

	/* make data into a big number */
	if (BN_bin2bn(from, (int)flen, f) == NULL)
		goto err;

	if (BN_ucmp(f, rsa->n) >= 0) {
		RSAerror(RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
	}

	if (!(rsa->flags & RSA_FLAG_NO_BLINDING)) {
		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
		if (blinding == NULL) {
			RSAerror(ERR_R_INTERNAL_ERROR);
			goto err;
		}
	}

	if (blinding != NULL) {
		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL)) {
			RSAerror(ERR_R_MALLOC_FAILURE);
			goto err;
		}
		if (!rsa_blinding_convert(blinding, f, unblind, ctx))
			goto err;
	}

	/* do the decrypt */
	if ((rsa->flags & RSA_FLAG_EXT_PKEY) ||
	    (rsa->p != NULL && rsa->q != NULL && rsa->dmp1 != NULL &&
	    rsa->dmq1 != NULL && rsa->iqmp != NULL)) {
		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx))
			goto err;
	} else {
		BIGNUM d;

		BN_init(&d);
		BN_with_flags(&d, rsa->d, BN_FLG_CONSTTIME);

		if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
			    CRYPTO_LOCK_RSA, rsa->n, ctx))
				goto err;

		if (!rsa->meth->bn_mod_exp(ret, f, &d, rsa->n, ctx,
		    rsa->_method_mod_n)) {
			goto err;
		}
	}

	if (blinding)
		if (!rsa_blinding_invert(blinding, ret, unblind, ctx))
			goto err;

	p = buf;
	j = BN_bn2bin(ret, p); /* j is only used with no-padding mode */

	switch (padding) {
	case RSA_PKCS1_PADDING:
		r = RSA_padding_check_PKCS1_type_2(to, num, buf, j, num);
		break;
#ifndef OPENSSL_NO_SHA
	case RSA_PKCS1_OAEP_PADDING:
		r = RSA_padding_check_PKCS1_OAEP(to, num, buf, j, num, NULL, 0);
		break;
#endif
	case RSA_NO_PADDING:
		r = RSA_padding_check_none(to, num, buf, j, num);
		break;
	default:
		RSAerror(RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
	}
	if (r < 0)
		RSAerror(RSA_R_PADDING_CHECK_FAILED);

err:
	if (ctx != NULL) {
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
	}
	freezero(buf, num);
	return r;
}

/* signature verification */
static int
RSA_eay_public_decrypt(int flen, const unsigned char *from, unsigned char *to,
    RSA *rsa, int padding)
{
	BIGNUM *f, *ret;
	int i, num = 0, r = -1;
	unsigned char *p;
	unsigned char *buf = NULL;
	BN_CTX *ctx = NULL;

	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS) {
		RSAerror(RSA_R_MODULUS_TOO_LARGE);
		return -1;
	}

	if (BN_ucmp(rsa->n, rsa->e) <= 0) {
		RSAerror(RSA_R_BAD_E_VALUE);
		return -1;
	}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS) {
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS) {
			RSAerror(RSA_R_BAD_E_VALUE);
			return -1;
		}
	}

	if ((ctx = BN_CTX_new()) == NULL)
		goto err;

	BN_CTX_start(ctx);
	f = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
	num = BN_num_bytes(rsa->n);
	buf = malloc(num);

	if (!f || !ret || !buf) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	/* This check was for equality but PGP does evil things
	 * and chops off the top '0' bytes */
	if (flen > num) {
		RSAerror(RSA_R_DATA_GREATER_THAN_MOD_LEN);
		goto err;
	}

	if (BN_bin2bn(from, flen, f) == NULL)
		goto err;

	if (BN_ucmp(f, rsa->n) >= 0) {
		RSAerror(RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
	}

	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
		    CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;

	if (!rsa->meth->bn_mod_exp(ret, f, rsa->e, rsa->n, ctx,
	    rsa->_method_mod_n))
		goto err;

	if (padding == RSA_X931_PADDING && (ret->d[0] & 0xf) != 12)
		if (!BN_sub(ret, rsa->n, ret))
			goto err;

	p = buf;
	i = BN_bn2bin(ret, p);

	switch (padding) {
	case RSA_PKCS1_PADDING:
		r = RSA_padding_check_PKCS1_type_1(to, num, buf, i, num);
		break;
	case RSA_X931_PADDING:
		r = RSA_padding_check_X931(to, num, buf, i, num);
		break;
	case RSA_NO_PADDING:
		r = RSA_padding_check_none(to, num, buf, i, num);
		break;
	default:
		RSAerror(RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
	}
	if (r < 0)
		RSAerror(RSA_R_PADDING_CHECK_FAILED);

err:
	if (ctx != NULL) {
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
	}
	freezero(buf, num);
	return r;
}

static int
RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
{
	BIGNUM *r1, *m1, *vrfy;
	BIGNUM dmp1, dmq1, c, pr1;
	int ret = 0;

	BN_CTX_start(ctx);
	r1 = BN_CTX_get(ctx);
	m1 = BN_CTX_get(ctx);
	vrfy = BN_CTX_get(ctx);
	if (r1 == NULL || m1 == NULL || vrfy == NULL) {
		RSAerror(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	{
		BIGNUM p, q;

		/*
		 * Make sure BN_mod_inverse in Montgomery intialization uses the
		 * BN_FLG_CONSTTIME flag
		 */
		BN_init(&p);
		BN_init(&q);
		BN_with_flags(&p, rsa->p, BN_FLG_CONSTTIME);
		BN_with_flags(&q, rsa->q, BN_FLG_CONSTTIME);

		if (rsa->flags & RSA_FLAG_CACHE_PRIVATE) {
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p,
			     CRYPTO_LOCK_RSA, &p, ctx) ||
			    !BN_MONT_CTX_set_locked(&rsa->_method_mod_q,
			     CRYPTO_LOCK_RSA, &q, ctx)) {
				goto err;
			}
		}
	}

	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
		    CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;

	/* compute I mod q */
	BN_init(&c);
	BN_with_flags(&c, I, BN_FLG_CONSTTIME);

	if (!BN_mod_ct(r1, &c, rsa->q, ctx))
		goto err;

	/* compute r1^dmq1 mod q */
	BN_init(&dmq1);
	BN_with_flags(&dmq1, rsa->dmq1, BN_FLG_CONSTTIME);

	if (!rsa->meth->bn_mod_exp(m1, r1, &dmq1, rsa->q, ctx,
	    rsa->_method_mod_q))
		goto err;

	/* compute I mod p */
	BN_with_flags(&c, I, BN_FLG_CONSTTIME);

	if (!BN_mod_ct(r1, &c, rsa->p, ctx))
		goto err;

	/* compute r1^dmp1 mod p */
	BN_init(&dmp1);
	BN_with_flags(&dmp1, rsa->dmp1, BN_FLG_CONSTTIME);

	if (!rsa->meth->bn_mod_exp(r0, r1, &dmp1, rsa->p, ctx,
	    rsa->_method_mod_p))
		goto err;

	if (!BN_sub(r0, r0, m1))
		goto err;

	/*
	 * This will help stop the size of r0 increasing, which does
	 * affect the multiply if it optimised for a power of 2 size
	 */
	if (BN_is_negative(r0))
		if (!BN_add(r0, r0, rsa->p))
			goto err;

	if (!BN_mul(r1, r0, rsa->iqmp, ctx))
		goto err;

	/* Turn BN_FLG_CONSTTIME flag on before division operation */
	BN_init(&pr1);
	BN_with_flags(&pr1, r1, BN_FLG_CONSTTIME);

	if (!BN_mod_ct(r0, &pr1, rsa->p, ctx))
		goto err;

	/*
	 * If p < q it is occasionally possible for the correction of
	 * adding 'p' if r0 is negative above to leave the result still
	 * negative. This can break the private key operations: the following
	 * second correction should *always* correct this rare occurrence.
	 * This will *never* happen with OpenSSL generated keys because
	 * they ensure p > q [steve]
	 */
	if (BN_is_negative(r0))
		if (!BN_add(r0, r0, rsa->p))
			goto err;
	if (!BN_mul(r1, r0, rsa->q, ctx))
		goto err;
	if (!BN_add(r0, r1, m1))
		goto err;

	if (rsa->e && rsa->n) {
		if (!rsa->meth->bn_mod_exp(vrfy, r0, rsa->e, rsa->n, ctx,
		    rsa->_method_mod_n))
			goto err;
		/*
		 * If 'I' was greater than (or equal to) rsa->n, the operation
		 * will be equivalent to using 'I mod n'. However, the result of
		 * the verify will *always* be less than 'n' so we don't check
		 * for absolute equality, just congruency.
		 */
		if (!BN_sub(vrfy, vrfy, I))
			goto err;
		if (!BN_mod_ct(vrfy, vrfy, rsa->n, ctx))
			goto err;
		if (BN_is_negative(vrfy))
			if (!BN_add(vrfy, vrfy, rsa->n))
				goto err;
		if (!BN_is_zero(vrfy)) {
			/*
			 * 'I' and 'vrfy' aren't congruent mod n. Don't leak
			 * miscalculated CRT output, just do a raw (slower)
			 * mod_exp and return that instead.
			 */
			BIGNUM d;

			BN_init(&d);
			BN_with_flags(&d, rsa->d, BN_FLG_CONSTTIME);

			if (!rsa->meth->bn_mod_exp(r0, I, &d, rsa->n, ctx,
			    rsa->_method_mod_n)) {
				goto err;
			}
		}
	}
	ret = 1;
err:
	BN_CTX_end(ctx);
	return ret;
}

static int
RSA_eay_init(RSA *rsa)
{
	rsa->flags |= RSA_FLAG_CACHE_PUBLIC | RSA_FLAG_CACHE_PRIVATE;
	return 1;
}

static int
RSA_eay_finish(RSA *rsa)
{
	BN_MONT_CTX_free(rsa->_method_mod_n);
	BN_MONT_CTX_free(rsa->_method_mod_p);
	BN_MONT_CTX_free(rsa->_method_mod_q);

	return 1;
}
@


1.49
log
@use freezero() instead of memset/explicit_bzero + free.  Substantially
reduces conditional logic (-218, +82).

MOD_EXP_CTIME_MIN_CACHE_LINE_WIDTH cache alignment calculation bn/bn_exp.c
wasn'tt quite right.  Two other tricky bits with ASN1_STRING_FLAG_NDEF and
BN_FLG_STATIC_DATA where the condition cannot be collapsed completely.

Passes regress.  ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.48 2017/04/28 22:46:40 beck Exp $ */
a202 3
	case RSA_SSLV23_PADDING:
		i = RSA_padding_add_SSLv23(buf, num, from, flen);
		break;
a382 1
	case RSA_SSLV23_PADDING:
a571 3
	case RSA_SSLV23_PADDING:
		r = RSA_padding_check_SSLv23(to, num, buf, j, num);
		break;
@


1.48
log
@revert previous accidental commit
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.46 2017/01/29 17:49:23 beck Exp $ */
d247 1
a247 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
d468 1
a468 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
d594 1
a594 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
d694 1
a694 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
@


1.47
log
@*** empty log message ***
@
text
@d247 4
a250 2
	freezero(buf, num);

d471 4
a474 2
	freezero(buf, num);

d600 4
a603 2
	freezero(buf, num);

d703 4
a706 2
	freezero(buf, num);

@


1.46
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.45 2017/01/21 10:38:29 beck Exp $ */
d247 2
a248 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
d469 2
a470 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
d596 2
a597 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
d697 2
a698 4
	if (buf != NULL) {
		explicit_bzero(buf, num);
		free(buf);
	}
@


1.45
log
@Split out BN_div and BN_mod into ct and nonct versions for Internal use.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.44 2017/01/21 09:38:59 beck Exp $ */
d163 1
a163 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
d168 1
a168 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
d175 1
a175 1
			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
d190 1
a190 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, ERR_R_MALLOC_FAILURE);
d210 1
a210 2
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,
		    RSA_R_UNKNOWN_PADDING_TYPE);
d221 1
a221 2
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,
		    RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d375 1
a375 1
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_MALLOC_FAILURE);
d391 1
a391 2
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,
		    RSA_R_UNKNOWN_PADDING_TYPE);
d402 1
a402 2
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,
		    RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d409 1
a409 2
			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,
			    ERR_R_INTERNAL_ERROR);
d416 1
a416 2
			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,
			    ERR_R_MALLOC_FAILURE);
d506 1
a506 1
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_MALLOC_FAILURE);
d513 1
a513 2
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,
		    RSA_R_DATA_GREATER_THAN_MOD_LEN);
d522 1
a522 2
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,
		    RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d529 1
a529 2
			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,
			    ERR_R_INTERNAL_ERROR);
d536 1
a536 2
			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,
			    ERR_R_MALLOC_FAILURE);
d589 1
a589 2
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,
		    RSA_R_UNKNOWN_PADDING_TYPE);
d593 1
a593 2
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,
		    RSA_R_PADDING_CHECK_FAILED);
d619 1
a619 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
d624 1
a624 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
d631 1
a631 1
			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
d646 1
a646 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, ERR_R_MALLOC_FAILURE);
d653 1
a653 2
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,
		    RSA_R_DATA_GREATER_THAN_MOD_LEN);
d661 1
a661 2
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,
		    RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d692 1
a692 2
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,
		    RSA_R_UNKNOWN_PADDING_TYPE);
d696 1
a696 2
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,
		    RSA_R_PADDING_CHECK_FAILED);
d722 1
a722 1
		RSAerr(RSA_F_RSA_EAY_MOD_EXP, ERR_R_MALLOC_FAILURE);
@


1.44
log
@Make explicit _ct and _nonct versions of bn_mod_exp funcitons that
matter for constant time, and make the public interface only used
external to the library.

This moves us to a model where the important things are constant time
versions unless you ask for them not to be, rather than the opposite.
I'll continue with this method by method.

Add regress tests for same.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.43 2016/09/09 11:39:11 tb Exp $ */
d773 1
a773 1
	if (!BN_mod(r1, &c, rsa->q, ctx))
d787 1
a787 1
	if (!BN_mod(r1, &c, rsa->p, ctx))
d816 1
a816 1
	if (!BN_mod(r0, &pr1, rsa->p, ctx))
d847 1
a847 1
		if (!BN_mod(vrfy, vrfy, rsa->n, ctx))
@


1.43
log
@missing space after comma
(this was apparently lost during the repo surgery)

ok bcook
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.42 2016/07/07 11:53:12 bcook Exp $ */
d121 2
d142 1
a142 1
	.bn_mod_exp = BN_mod_exp_mont, /* XXX probably we should not use Montgomery if  e == 3 */
@


1.42
log
@call BN_init on temporaries to avoid use-before-set warnings

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.41 2016/06/30 02:02:06 bcook Exp $ */
d230 1
a230 1
	if (!rsa->meth->bn_mod_exp(ret, f,rsa->e, rsa->n, ctx,
@


1.41
log
@Remove flags for disabling constant-time operations.

This removes support for DSA_FLAG_NO_EXP_CONSTTIME, DH_FLAG_NO_EXP_CONSTTIME,
and RSA_FLAG_NO_CONSTTIME flags, making all of these operations unconditionally
constant-time.

Based on the original patch by CÃ©sar Pereid.  ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.40 2015/09/10 15:56:25 jsing Exp $ */
d435 1
d560 1
d747 2
d768 1
d775 1
d789 1
d811 1
d858 1
@


1.40
log
@Correct spelling of OPENSSL_cleanse.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.39 2015/06/13 08:38:10 doug Exp $ */
d180 1
d186 1
d367 1
d373 1
d433 1
a433 2
		BIGNUM local_d;
		BIGNUM *d = NULL;
d435 1
a435 6
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
			BN_init(&local_d);
			d = &local_d;
			BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
		} else
			d = rsa->d;
d442 2
a443 2
		if (!rsa->meth->bn_mod_exp(ret, f, d, rsa->n, ctx,
		    rsa->_method_mod_n))
d445 1
d501 1
d507 1
d557 1
a557 2
		BIGNUM local_d;
		BIGNUM *d = NULL;
d559 1
a559 5
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
			d = &local_d;
			BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
		} else
			d = rsa->d;
d565 3
a567 2
		if (!rsa->meth->bn_mod_exp(ret, f, d, rsa->n, ctx,
		    rsa->_method_mod_n))
d569 1
d646 1
d652 1
d726 1
a726 2
	BIGNUM local_dmp1, local_dmq1, local_c, local_r1;
	BIGNUM *dmp1, *dmq1, *c, *pr1;
d739 1
a739 2
		BIGNUM local_p, local_q;
		BIGNUM *p = NULL, *q = NULL;
d743 1
a743 1
		 * BN_FLG_CONSTTIME flag (unless RSA_FLAG_NO_CONSTTIME is set)
d745 2
a746 12
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
			BN_init(&local_p);
			p = &local_p;
			BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);

			BN_init(&local_q);
			q = &local_q;
			BN_with_flags(q, rsa->q, BN_FLG_CONSTTIME);
		} else {
			p = rsa->p;
			q = rsa->q;
		}
d750 3
a752 4
			    CRYPTO_LOCK_RSA, p, ctx))
				goto err;
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q,
			    CRYPTO_LOCK_RSA, q, ctx))
d754 1
d764 4
a767 9
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
		c = &local_c;
		BN_with_flags(c, I, BN_FLG_CONSTTIME);
		if (!BN_mod(r1, c, rsa->q, ctx))
			goto err;
	} else {
		if (!BN_mod(r1, I, rsa->q, ctx))
			goto err;
	}
d770 3
a772 6
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
		dmq1 = &local_dmq1;
		BN_with_flags(dmq1, rsa->dmq1, BN_FLG_CONSTTIME);
	} else
		dmq1 = rsa->dmq1;
	if (!rsa->meth->bn_mod_exp(m1, r1, dmq1, rsa->q, ctx,
d777 4
a780 9
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
		c = &local_c;
		BN_with_flags(c, I, BN_FLG_CONSTTIME);
		if (!BN_mod(r1, c, rsa->p, ctx))
			goto err;
	} else {
		if (!BN_mod(r1, I, rsa->p, ctx))
			goto err;
	}
d783 3
a785 6
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
		dmp1 = &local_dmp1;
		BN_with_flags(dmp1, rsa->dmp1, BN_FLG_CONSTTIME);
	} else
		dmp1 = rsa->dmp1;
	if (!rsa->meth->bn_mod_exp(r0, r1, dmp1, rsa->p, ctx,
d791 1
d804 3
a806 6
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
		pr1 = &local_r1;
		BN_with_flags(pr1, r1, BN_FLG_CONSTTIME);
	} else
		pr1 = r1;
	if (!BN_mod(r0, pr1, rsa->p, ctx))
d848 1
d850 1
a850 2
			BIGNUM local_d;
			BIGNUM *d = NULL;
d852 2
a853 7
			if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME)) {
				d = &local_d;
				BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
			} else
				d = rsa->d;
			if (!rsa->meth->bn_mod_exp(r0, I, d, rsa->n, ctx,
			    rsa->_method_mod_n))
d855 1
@


1.39
log
@Fix bad indenting in LibreSSL.

jsg@@ noticed that some of the lines in libssl and libcrypto are not
indented properly.  At a quick glance, it looks like it has a different
control flow than it really does.  I checked the history in our tree and
in OpenSSL to make sure these were simple mistakes.

ok miod@@ jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.38 2015/02/14 15:10:39 miod Exp $ */
d113 1
d246 1
a246 1
		OPENSSL_cleanse(buf, num);
d476 1
a476 1
		OPENSSL_cleanse(buf, num);
d611 1
a611 1
		OPENSSL_cleanse(buf, num);
d716 1
a716 1
		OPENSSL_cleanse(buf, num);
@


1.38
log
@Check for allocation error in RSA_eay_mod_exp(). Coverity CID 25217.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.37 2015/02/09 15:49:22 jsing Exp $ */
d396 1
a396 1
		if (BN_ucmp(f, rsa->n) >= 0) {
@


1.37
log
@BN_CTX_get() can fail - consistently check its return value.

There are currently cases where the return from each call is checked,
the return from only the last call is checked and cases where it is not
checked at all (including code in bn, ec and engine).

Checking the last return value is valid as once the function fails it will
continue to return NULL. However, in order to be consistent check each
call with the same idiom. This makes it easy to verify.

Note there are still a handful of cases that do not follow the idiom -
these will be handled separately.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.36 2014/10/18 17:20:40 jsing Exp $ */
d733 4
@


1.36
log
@None of these need to include <openssl/rand.h>
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.35 2014/07/11 15:21:51 miod Exp $ */
d184 1
a184 1
	if (!f || !ret || !buf) {
d369 1
a369 1
	if (!f || !ret || !buf) {
@


1.35
log
@In RSA_eay_private_encrypt(), correctly return the smaller BN; OpenSSL
PR #3418 via OpenSSL trunk
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.34 2014/07/11 08:44:49 jsing Exp $ */
a117 1
#include <openssl/rand.h>
@


1.34
log
@Only import cryptlib.h in the four source files that actually need it.
Remove the openssl public includes from cryptlib.h and add a small number
of includes into the source files that actually need them. While here,
also sort/group/tidy the includes.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.33 2014/07/10 22:45:57 jsing Exp $ */
d455 1
a455 1
		if (BN_cmp(ret, f))
@


1.33
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.32 2014/07/10 07:43:11 jsing Exp $ */
a115 1
#include "cryptlib.h"
d117 2
a119 1
#include <openssl/rand.h>
@


1.32
log
@BN_free, BN_clear_free, BN_CTX_free, BN_BLINDING_free and BN_MONT_CTX_free
all have implicit NULL checks, so we do not need them here.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.31 2014/07/09 19:51:38 jsing Exp $ */
d113 3
@


1.31
log
@More KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.30 2014/07/09 08:44:53 miod Exp $ */
d901 3
a903 6
	if (rsa->_method_mod_n != NULL)
		BN_MONT_CTX_free(rsa->_method_mod_n);
	if (rsa->_method_mod_p != NULL)
		BN_MONT_CTX_free(rsa->_method_mod_p);
	if (rsa->_method_mod_q != NULL)
		BN_MONT_CTX_free(rsa->_method_mod_q);
@


1.30
log
@RSA_NULL used to be a compile option allowing the RSA interfaces to be
compiled-in, with nonfunctional code, to be able to cope with the RSA
patent.

However, we don't use this option, and the RSA patent has expired more than 10
years ago, so just drop this piece.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.29 2014/07/09 08:20:08 miod Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d119 1
a119 1
		unsigned char *to, RSA *rsa,int padding);
d121 1
a121 1
		unsigned char *to, RSA *rsa,int padding);
d123 1
a123 1
		unsigned char *to, RSA *rsa,int padding);
d125 1
a125 1
		unsigned char *to, RSA *rsa,int padding);
d129 1
d174 2
a175 2
	
	if ((ctx=BN_CTX_new()) == NULL)
d183 1
a183 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);
d193 1
a193 1
	        i = RSA_padding_add_PKCS1_OAEP(buf, num, from, flen, NULL, 0);
d212 1
a212 1
	
d225 2
a226 1
	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx, rsa->_method_mod_n))
d291 1
a291 1
			
d360 1
a360 1
	if ((ctx=BN_CTX_new()) == NULL)
d391 1
a391 1
	if (BN_bin2bn(buf,num,f) == NULL)
d393 2
a394 2
	
	if (BN_ucmp(f, rsa->n) >= 0) {	
d409 1
a409 1
	
d422 1
a422 1
	     rsa->dmq1 != NULL && rsa->iqmp != NULL)) { 
d428 1
a428 1
		
d441 1
a441 1
		if (!rsa->meth->bn_mod_exp(ret, f, d, rsa->n,ctx,
d535 1
a535 1
	
d549 1
a549 1
	     rsa->dmq1 != NULL && rsa->iqmp != NULL)) {
d555 1
a555 1
		
d583 3
a585 3
        case RSA_PKCS1_OAEP_PADDING:
	        r = RSA_padding_check_PKCS1_OAEP(to, num, buf, j, num, NULL, 0);
                break;
d587 1
a587 1
 	case RSA_SSLV23_PADDING:
d608 1
a608 1
		OPENSSL_cleanse(buf,num);
d620 1
a620 1
	int i, num = 0,r = -1;
d642 1
a642 1
	
d663 1
a663 1
	if (BN_bin2bn(from,flen,f) == NULL)
d806 1
a806 1
	if (!rsa->meth->bn_mod_exp(r0, r1, dmp1, rsa->p,ctx,
d829 1
a829 1
	if (!BN_mod(r0, pr1, rsa->p,ctx))
d874 1
a874 1
		
d895 1
a895 1
	return 1 ;
d907 1
@


1.29
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: rsa_eay.c,v 1.28 2014/06/12 15:49:30 deraadt Exp $ */
a117 2
#ifndef RSA_NULL

a906 2

#endif
@


1.28
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d143 5
a147 4
const RSA_METHOD *RSA_PKCS1_SSLeay(void)
	{
	return(&rsa_pkcs1_eay_meth);
	}
d149 8
a156 7
static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
	{
	BIGNUM *f,*ret;
	int i,j,k,num=0,r= -1;
	unsigned char *buf=NULL;
	BN_CTX *ctx=NULL;
d158 1
a158 2
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
d161 1
a161 1
		}
d163 1
a163 2
	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
d166 1
a166 1
		}
d169 2
a170 4
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
a172 1
			}
d174 1
d176 2
a177 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d181 1
a181 1
	num=BN_num_bytes(rsa->n);
d183 1
a183 2
	if (!f || !ret || !buf)
		{
d186 1
a186 1
		}
d188 1
a188 2
	switch (padding)
		{
d190 1
a190 1
		i=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);
d194 1
a194 1
	        i=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);
d198 1
a198 1
		i=RSA_padding_add_SSLv23(buf,num,from,flen);
d201 1
a201 1
		i=RSA_padding_add_none(buf,num,from,flen);
d204 5
a208 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
a209 2
		}
	if (i <= 0) goto err;
d211 2
a212 1
	if (BN_bin2bn(buf,num,f) == NULL) goto err;
d214 1
a214 2
	if (BN_ucmp(f, rsa->n) >= 0)
		{
d216 2
a217 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d219 1
a219 1
		}
d222 2
a223 1
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
d226 2
a227 2
	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
		rsa->_method_mod_n)) goto err;
d231 4
a234 4
	j=BN_num_bytes(ret);
	i=BN_bn2bin(ret,&(to[num-j]));
	for (k=0; k<(num-i); k++)
		to[k]=0;
d236 1
a236 1
	r=num;
d238 1
a238 2
	if (ctx != NULL)
		{
d241 3
a243 4
		}
	if (buf != NULL) 
		{
		OPENSSL_cleanse(buf,num);
a244 2
		}
	return(r);
d246 2
d249 2
a250 1
static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
d258 1
a258 2
	if (rsa->blinding == NULL)
		{
d265 1
a265 1
		}
d272 1
a272 2
	if (!CRYPTO_THREADID_cmp(&cur, BN_BLINDING_thread_id(ret)))
		{
a273 1

d275 1
a275 3
		}
	else
		{
d277 7
d285 2
a286 10
		*local = 0; /* instructs rsa_blinding_convert(), rsa_blinding_invert()
		             * that the BN_BLINDING is shared, meaning that accesses
		             * require locks, and that the blinding factor must be
		             * stored outside the BN_BLINDING
		             */

		if (rsa->mt_blinding == NULL)
			{
			if (!got_write_lock)
				{
d290 1
a290 1
				}
d294 1
a294 1
			}
d296 1
a296 1
		}
d298 1
a298 1
 err:
d306 3
a308 3
static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
	BN_CTX *ctx)
	{
d310 4
a313 2
		/* Local blinding: store the unblinding factor
		 * in BN_BLINDING. */
d315 5
a319 4
	else
		{
		/* Shared blinding: store the unblinding factor
		 * outside BN_BLINDING. */
a324 1
		}
d326 1
d328 5
a332 4
static int rsa_blinding_invert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
	BN_CTX *ctx)
	{
	/* For local blinding, unblind is set to NULL, and BN_BLINDING_invert_ex
d340 1
a340 1
	}
d343 4
a346 3
static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
	{
d348 3
a350 3
	int i,j,k,num=0,r= -1;
	unsigned char *buf=NULL;
	BN_CTX *ctx=NULL;
d352 2
a353 1
	/* Used only if the blinding structure is shared. A non-NULL unblind
d355 2
a356 1
	 * the unblinding factor outside the blinding structure. */
d360 2
a361 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d363 1
a363 1
	f   = BN_CTX_get(ctx);
d367 2
a368 3
	if(!f || !ret || !buf)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
d370 1
a370 1
		}
d372 1
a372 2
	switch (padding)
		{
d374 1
a374 1
		i=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);
d377 1
a377 1
		i=RSA_padding_add_X931(buf,num,from,flen);
d380 1
a380 1
		i=RSA_padding_add_none(buf,num,from,flen);
d384 5
a388 1
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
a389 2
		}
	if (i <= 0) goto err;
d391 2
a392 1
	if (BN_bin2bn(buf,num,f) == NULL) goto err;
d394 1
a394 2
	if (BN_ucmp(f, rsa->n) >= 0)
		{	
d396 2
a397 1
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d399 1
a399 1
		}
d401 1
a401 2
	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
		{
d403 3
a405 3
		if (blinding == NULL)
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);
a406 1
			}
d408 1
d410 4
a413 5
	if (blinding != NULL)
		{
		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
d415 1
a415 1
			}
d418 1
a418 1
		}
d420 6
a425 11
	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
		((rsa->p != NULL) &&
		(rsa->q != NULL) &&
		(rsa->dmp1 != NULL) &&
		(rsa->dmq1 != NULL) &&
		(rsa->iqmp != NULL)) )
		{ 
		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
		}
	else
		{
d429 1
a429 2
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
			{
d433 2
a434 3
			}
		else
			d= rsa->d;
d437 2
a438 1
			if(!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
d441 4
a444 3
		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
				rsa->_method_mod_n)) goto err;
		}
d450 1
a450 2
	if (padding == RSA_X931_PADDING)
		{
d456 1
a456 2
		}
	else
d461 4
a464 4
	j=BN_num_bytes(res);
	i=BN_bn2bin(res,&(to[num-j]));
	for (k=0; k<(num-i); k++)
		to[k]=0;
d466 1
a466 1
	r=num;
d468 1
a468 2
	if (ctx != NULL)
		{
d471 3
a473 4
		}
	if (buf != NULL)
		{
		OPENSSL_cleanse(buf,num);
a474 2
		}
	return(r);
d476 2
d479 4
a482 3
static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
	{
d484 1
a484 1
	int j,num=0,r= -1;
d486 2
a487 2
	unsigned char *buf=NULL;
	BN_CTX *ctx=NULL;
d489 2
a490 1
	/* Used only if the blinding structure is shared. A non-NULL unblind
d492 2
a493 1
	 * the unblinding factor outside the blinding structure. */
d497 2
a498 1
	if((ctx = BN_CTX_new()) == NULL) goto err;
d500 1
a500 1
	f   = BN_CTX_get(ctx);
d504 2
a505 3
	if(!f || !ret || !buf)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
d507 1
a507 1
		}
d511 3
a513 3
	if (flen > num)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
d515 1
a515 1
		}
d518 2
a519 1
	if (BN_bin2bn(from,(int)flen,f) == NULL) goto err;
d521 3
a523 3
	if (BN_ucmp(f, rsa->n) >= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d525 1
a525 1
		}
d527 1
a527 2
	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
		{
d529 3
a531 3
		if (blinding == NULL)
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);
a532 1
			}
d534 1
d536 4
a539 5
	if (blinding != NULL)
		{
		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
d541 1
a541 1
			}
d544 1
a544 1
		}
d547 6
a552 11
	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
		((rsa->p != NULL) &&
		(rsa->q != NULL) &&
		(rsa->dmp1 != NULL) &&
		(rsa->dmq1 != NULL) &&
		(rsa->iqmp != NULL)) )
		{
		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
		}
	else
		{
d556 1
a556 2
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
			{
d559 1
a559 2
			}
		else
d563 2
a564 1
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
d566 4
a569 4
		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
				rsa->_method_mod_n))
		  goto err;
		}
d575 2
a576 2
	p=buf;
	j=BN_bn2bin(ret,p); /* j is only used with no-padding mode */
d578 1
a578 2
	switch (padding)
		{
d580 1
a580 1
		r=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);
d584 1
a584 1
	        r=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);
d588 1
a588 1
		r=RSA_padding_check_SSLv23(to,num,buf,j,num);
d591 1
a591 1
		r=RSA_padding_check_none(to,num,buf,j,num);
d594 2
a595 1
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
d597 1
a597 1
		}
d599 2
a600 1
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
d603 1
a603 2
	if (ctx != NULL)
		{
d606 2
a607 3
		}
	if (buf != NULL)
		{
a609 2
		}
	return(r);
d611 2
d615 6
a620 5
static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
	{
	BIGNUM *f,*ret;
	int i,num=0,r= -1;
d622 2
a623 2
	unsigned char *buf=NULL;
	BN_CTX *ctx=NULL;
d625 1
a625 2
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
d628 1
a628 1
		}
d630 1
a630 2
	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
d633 1
a633 1
		}
d636 2
a637 4
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
a639 1
			}
d641 1
d643 2
a644 1
	if((ctx = BN_CTX_new()) == NULL) goto err;
d648 1
a648 1
	num=BN_num_bytes(rsa->n);
d650 2
a651 3
	if(!f || !ret || !buf)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);
d653 1
a653 1
		}
d657 3
a659 3
	if (flen > num)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
d661 1
a661 1
		}
d663 2
a664 1
	if (BN_bin2bn(from,flen,f) == NULL) goto err;
d666 3
a668 3
	if (BN_ucmp(f, rsa->n) >= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
d670 1
a670 1
		}
d673 2
a674 1
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
d677 3
a679 2
	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
		rsa->_method_mod_n)) goto err;
d681 3
a683 2
	if ((padding == RSA_X931_PADDING) && ((ret->d[0] & 0xf) != 12))
		if (!BN_sub(ret, rsa->n, ret)) goto err;
d685 2
a686 2
	p=buf;
	i=BN_bn2bin(ret,p);
d688 1
a688 2
	switch (padding)
		{
d690 1
a690 1
		r=RSA_padding_check_PKCS1_type_1(to,num,buf,i,num);
d693 1
a693 1
		r=RSA_padding_check_X931(to,num,buf,i,num);
d696 1
a696 1
		r=RSA_padding_check_none(to,num,buf,i,num);
d699 2
a700 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
d702 1
a702 1
		}
d704 2
a705 1
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
d708 1
a708 2
	if (ctx != NULL)
		{
d711 3
a713 4
		}
	if (buf != NULL)
		{
		OPENSSL_cleanse(buf,num);
a714 2
		}
	return(r);
d716 2
d719 7
a725 6
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
	{
	BIGNUM *r1,*m1,*vrfy;
	BIGNUM local_dmp1,local_dmq1,local_c,local_r1;
	BIGNUM *dmp1,*dmq1,*c,*pr1;
	int ret=0;
d736 2
a737 1
		/* Make sure BN_mod_inverse in Montgomery intialization uses the
d740 1
a740 2
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
			{
d748 1
a748 3
			}
		else
			{
d751 1
a751 1
			}
d753 3
a755 3
		if (rsa->flags & RSA_FLAG_CACHE_PRIVATE)
			{
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p, CRYPTO_LOCK_RSA, p, ctx))
d757 2
a758 1
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q, CRYPTO_LOCK_RSA, q, ctx))
d760 1
a760 1
			}
d764 2
a765 1
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
d769 1
a769 2
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
d772 6
a777 6
		if (!BN_mod(r1,c,rsa->q,ctx)) goto err;
		}
	else
		{
		if (!BN_mod(r1,I,rsa->q,ctx)) goto err;
		}
d780 1
a780 2
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
d783 1
a783 2
		}
	else
d785 3
a787 2
	if (!rsa->meth->bn_mod_exp(m1,r1,dmq1,rsa->q,ctx,
		rsa->_method_mod_q)) goto err;
d790 1
a790 2
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
d793 6
a798 6
		if (!BN_mod(r1,c,rsa->p,ctx)) goto err;
		}
	else
		{
		if (!BN_mod(r1,I,rsa->p,ctx)) goto err;
		}
d801 1
a801 2
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
d804 1
a804 2
		}
	else
d806 3
a808 2
	if (!rsa->meth->bn_mod_exp(r0,r1,dmp1,rsa->p,ctx,
		rsa->_method_mod_p)) goto err;
d810 6
a815 3
	if (!BN_sub(r0,r0,m1)) goto err;
	/* This will help stop the size of r0 increasing, which does
	 * affect the multiply if it optimised for a power of 2 size */
d817 2
a818 1
		if (!BN_add(r0,r0,rsa->p)) goto err;
d820 2
a821 1
	if (!BN_mul(r1,r0,rsa->iqmp,ctx)) goto err;
d824 1
a824 2
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
d827 1
a827 2
		}
	else
d829 2
a830 1
	if (!BN_mod(r0,pr1,rsa->p,ctx)) goto err;
d832 2
a833 1
	/* If p < q it is occasionally possible for the correction of
d841 13
a853 8
		if (!BN_add(r0,r0,rsa->p)) goto err;
	if (!BN_mul(r1,r0,rsa->q,ctx)) goto err;
	if (!BN_add(r0,r1,m1)) goto err;

	if (rsa->e && rsa->n)
		{
		if (!rsa->meth->bn_mod_exp(vrfy,r0,rsa->e,rsa->n,ctx,rsa->_method_mod_n)) goto err;
		/* If 'I' was greater than (or equal to) rsa->n, the operation
d856 6
a861 3
		 * for absolute equality, just congruency. */
		if (!BN_sub(vrfy, vrfy, I)) goto err;
		if (!BN_mod(vrfy, vrfy, rsa->n, ctx)) goto err;
d863 5
a867 4
			if (!BN_add(vrfy, vrfy, rsa->n)) goto err;
		if (!BN_is_zero(vrfy))
			{
			/* 'I' and 'vrfy' aren't congruent mod n. Don't leak
d869 2
a870 1
			 * mod_exp and return that instead. */
d875 1
a875 2
			if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
				{
d878 1
a878 2
				}
			else
d880 3
a882 3
			if (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,
						   rsa->_method_mod_n)) goto err;
			}
d884 2
a885 1
	ret=1;
d888 2
a889 2
	return(ret);
	}
d891 6
a896 5
static int RSA_eay_init(RSA *rsa)
	{
	rsa->flags|=RSA_FLAG_CACHE_PUBLIC|RSA_FLAG_CACHE_PRIVATE;
	return(1);
	}
d898 3
a900 2
static int RSA_eay_finish(RSA *rsa)
	{
d907 2
a908 2
	return(1);
	}
@


1.27
log
@Use C99 initializers for the various FOO_METHOD structs. More readable, and
avoid unreadable/unmaintainable constructs like that:

const EVP_PKEY_ASN1_METHOD cmac_asn1_meth =
        {
        EVP_PKEY_CMAC,
        EVP_PKEY_CMAC,
        0,

        "CMAC",
        "OpenSSL CMAC method",

        0,0,0,0,

        0,0,0,

        cmac_size,
        0,
        0,0,0,0,0,0,0,

        cmac_key_free,
        0,
        0,0
        };

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/* crypto/rsa/rsa_eay.c */
@


1.26
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@d131 11
a141 16
static RSA_METHOD rsa_pkcs1_eay_meth={
	"Eric Young's PKCS#1 RSA",
	RSA_eay_public_encrypt,
	RSA_eay_public_decrypt, /* signature verification */
	RSA_eay_private_encrypt, /* signing */
	RSA_eay_private_decrypt,
	RSA_eay_mod_exp,
	BN_mod_exp_mont, /* XXX probably we should not use Montgomery if  e == 3 */
	RSA_eay_init,
	RSA_eay_finish,
	0, /* flags */
	NULL,
	0, /* rsa_sign */
	0, /* rsa_verify */
	NULL /* rsa_keygen */
	};
@


1.25
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d188 1
a188 1
	buf = OPENSSL_malloc(num);
d250 1
a250 1
		OPENSSL_free(buf);
d369 1
a369 1
	buf = OPENSSL_malloc(num);
d487 1
a487 1
		OPENSSL_free(buf);
d512 1
a512 1
	buf = OPENSSL_malloc(num);
d627 1
a627 1
		OPENSSL_free(buf);
d669 1
a669 1
	buf = OPENSSL_malloc(num);
d732 1
a732 1
		OPENSSL_free(buf);
@


1.24
log
@OpenSSL 1.0.0f: merge
@
text
@d850 1
a850 1
         * adding 'p' if r0 is negative above to leave the result still
d854 2
a855 2
         * they ensure p > q [steve]
         */
@


1.23
log
@openssl-1.0.0e: resolve conflicts
@
text
@d317 6
a322 4
static int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f,
	BIGNUM *r, BN_CTX *ctx)
{
	if (local)
d326 2
a327 15
		int ret;
		CRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING);
		ret = BN_BLINDING_convert_ex(f, r, b, ctx);
		CRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING);
		return ret;
		}
}

static int rsa_blinding_invert(BN_BLINDING *b, int local, BIGNUM *f,
	BIGNUM *r, BN_CTX *ctx)
{
	if (local)
		return BN_BLINDING_invert_ex(f, NULL, b, ctx);
	else
		{
d330 1
a330 1
		ret = BN_BLINDING_invert_ex(f, r, b, ctx);
d334 14
a347 1
}
d353 1
a353 1
	BIGNUM *f, *ret, *br, *res;
d358 4
a366 1
	br  = BN_CTX_get(ctx);
d414 4
a417 1
		if (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))
d419 4
d456 1
a456 1
		if (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))
d495 1
a495 1
	BIGNUM *f, *ret, *br;
d501 4
a509 1
	br  = BN_CTX_get(ctx);
d547 4
a550 1
		if (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))
d552 4
d589 1
a589 1
		if (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))
@


1.22
log
@resolve conflicts, fix local changes
@
text
@d678 1
a678 1
		BN_sub(ret, rsa->n, ret);
@


1.21
log
@resolve conflicts
@
text
@d118 1
a118 1
#if !defined(RSA_NULL) && !defined(OPENSSL_FIPS)
d259 1
d277 2
a278 1
	if (BN_BLINDING_get_thread_id(ret) == CRYPTO_thread_id())
a356 22

	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}
@


1.20
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d118 1
a118 1
#ifndef RSA_NULL
@


1.19
log
@Fix merge botch.

ok miod@@
@
text
@a152 10
/* Usage example;
 *    MONT_HELPER(rsa->_method_mod_p, bn_ctx, rsa->p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
 */
#define MONT_HELPER(method_mod, ctx, m, pre_cond, err_instr) \
	if ((pre_cond) && ((method_mod) == NULL) && \
			!BN_MONT_CTX_set_locked(&(method_mod), \
				CRYPTO_LOCK_RSA, \
				(m), (ctx))) \
		err_instr

d226 3
a228 1
	MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
d455 3
a457 1
		MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
d578 3
a580 1
		MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
d690 3
a692 1
	MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
d770 7
a776 2
		MONT_HELPER(rsa->_method_mod_p, ctx, p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
		MONT_HELPER(rsa->_method_mod_q, ctx, q, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
d779 3
a781 1
	MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
@


1.18
log
@resolve conflicts
@
text
@a363 3
	BN_init(&f);
	BN_init(&ret);

@


1.17
log
@openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
d118 1
a118 1
#if !defined(RSA_NULL) && !defined(OPENSSL_FIPS)
d128 1
a128 1
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa);
d144 2
a145 1
	0  /* rsa_verify */
d153 10
d166 1
a166 1
	BIGNUM f,ret;
d171 22
a192 2
	BN_init(&f);
	BN_init(&ret);
d194 3
d198 2
a199 1
	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
d227 1
a227 1
	if (BN_bin2bn(buf,num,&f) == NULL) goto err;
d229 2
a230 2
	if (BN_ucmp(&f, rsa->n) >= 0)
		{	
d236 1
a236 6
	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		{
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
					CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;
		}
d238 1
a238 1
	if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
d243 2
a244 2
	j=BN_num_bytes(&ret);
	i=BN_bn2bin(&ret,&(to[num-j]));
d250 5
a254 3
	if (ctx != NULL) BN_CTX_free(ctx);
	BN_clear_free(&f);
	BN_clear_free(&ret);
d263 4
a266 10
static int rsa_eay_blinding(RSA *rsa, BN_CTX *ctx)
	{
	int ret = 1;
	CRYPTO_w_lock(CRYPTO_LOCK_RSA);
	/* Check again inside the lock - the macro's check is racey */
	if(rsa->blinding == NULL)
		ret = RSA_blinding_on(rsa, ctx);
	CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	return ret;
	}
d268 1
a268 7
#define BLINDING_HELPER(rsa, ctx, err_instr) \
	do { \
		if((!((rsa)->flags & RSA_FLAG_NO_BLINDING)) && \
		    ((rsa)->blinding == NULL) && \
		    !rsa_eay_blinding(rsa, ctx)) \
		    err_instr \
	} while(0)
d270 5
a274 4
static BN_BLINDING *setup_blinding(RSA *rsa, BN_CTX *ctx)
	{
	BIGNUM *A, *Ai;
	BN_BLINDING *ret = NULL;
d276 3
a278 1
	/* added in OpenSSL 0.9.6j and 0.9.7b */
d280 3
a282 3
	/* NB: similar code appears in RSA_blinding_on (rsa_lib.c);
	 * this should be placed in a new function of its own, but for reasons
	 * of binary compatibility can't */
d284 1
a284 3
	BN_CTX_start(ctx);
	A = BN_CTX_get(ctx);
	if ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)
d286 3
a288 3
		/* if PRNG is not properly seeded, resort to secret exponent as unpredictable seed */
		RAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0);
		if (!BN_pseudo_rand_range(A,rsa->n)) goto err;
d292 21
a312 1
		if (!BN_rand_range(A,rsa->n)) goto err;
a313 1
	if ((Ai=BN_mod_inverse(NULL,A,rsa->n,ctx)) == NULL) goto err;
d315 5
a319 6
	if (!rsa->meth->bn_mod_exp(A,A,rsa->e,rsa->n,ctx,rsa->_method_mod_n))
		goto err;
	ret = BN_BLINDING_new(A,Ai,rsa->n);
	BN_free(Ai);
err:
	BN_CTX_end(ctx);
d321 31
a351 1
	}
d357 1
a357 1
	BIGNUM f,ret, *res;
d390 7
a396 2
	num=BN_num_bytes(rsa->n);
	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
d407 3
d420 1
a420 1
	if (BN_bin2bn(buf,num,&f) == NULL) goto err;
d422 1
a422 1
	if (BN_ucmp(&f, rsa->n) >= 0)
a428 9
	BLINDING_HELPER(rsa, ctx, goto err;);
	blinding = rsa->blinding;
	
	/* Now unless blinding is disabled, 'blinding' is non-NULL.
	 * But the BN_BLINDING object may be owned by some other thread
	 * (we don't want to keep it constant and we don't want to use
	 * lots of locking to avoid race conditions, so only a single
	 * thread can use it; other threads have to use local blinding
	 * factors) */
d431 1
d440 2
a441 14
		{
		if (blinding->thread_id != CRYPTO_thread_id())
			{
			/* we need a local one-time blinding factor */

			blinding = setup_blinding(rsa, ctx);
			if (blinding == NULL)
				goto err;
			local_blinding = 1;
			}
		}

	if (blinding)
		if (!BN_BLINDING_convert(&f, blinding, ctx)) goto err;
d450 1
a450 1
		if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err;
d457 1
a457 1
		if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
d461 1
a461 1
			BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
d464 6
a469 2
			d = rsa->d;
		if (!rsa->meth->bn_mod_exp(&ret,&f,d,rsa->n,ctx,NULL)) goto err;
d473 2
a474 1
		if (!BN_BLINDING_invert(&ret, blinding, ctx)) goto err;
d478 3
a480 3
		BN_sub(&f, rsa->n, &ret);
		if (BN_cmp(&ret, &f))
			res = &f;
d482 1
a482 1
			res = &ret;
d485 1
a485 1
		res = &ret;
d496 5
a500 5
	if (ctx != NULL) BN_CTX_free(ctx);
	BN_clear_free(&ret);
	BN_clear_free(&f);
	if (local_blinding)
		BN_BLINDING_free(blinding);
d512 1
a512 1
	BIGNUM f,ret;
d520 8
a527 8
	BN_init(&f);
	BN_init(&ret);
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;

	num=BN_num_bytes(rsa->n);

	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
d542 1
a542 1
	if (BN_bin2bn(from,(int)flen,&f) == NULL) goto err;
d544 1
a544 1
	if (BN_ucmp(&f, rsa->n) >= 0)
a549 9
	BLINDING_HELPER(rsa, ctx, goto err;);
	blinding = rsa->blinding;
	
	/* Now unless blinding is disabled, 'blinding' is non-NULL.
	 * But the BN_BLINDING object may be owned by some other thread
	 * (we don't want to keep it constant and we don't want to use
	 * lots of locking to avoid race conditions, so only a single
	 * thread can use it; other threads have to use local blinding
	 * factors) */
d552 1
d561 2
a562 14
		{
		if (blinding->thread_id != CRYPTO_thread_id())
			{
			/* we need a local one-time blinding factor */

			blinding = setup_blinding(rsa, ctx);
			if (blinding == NULL)
				goto err;
			local_blinding = 1;
			}
		}

	if (blinding)
		if (!BN_BLINDING_convert(&f, blinding, ctx)) goto err;
d572 1
a572 1
		if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err;
d579 1
a579 1
		if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
d582 1
a582 1
			BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
d586 5
a590 2
		if (!rsa->meth->bn_mod_exp(&ret,&f,d,rsa->n,ctx,NULL))
			goto err;
d594 2
a595 1
		if (!BN_BLINDING_invert(&ret, blinding, ctx)) goto err;
d598 1
a598 1
	j=BN_bn2bin(&ret,p); /* j is only used with no-padding mode */
d624 5
a628 5
	if (ctx != NULL) BN_CTX_free(ctx);
	BN_clear_free(&f);
	BN_clear_free(&ret);
	if (local_blinding)
		BN_BLINDING_free(blinding);
d641 1
a641 1
	BIGNUM f,ret;
d668 5
a672 6

	BN_init(&f);
	BN_init(&ret);
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;

d674 2
a675 2
	buf=(unsigned char *)OPENSSL_malloc(num);
	if (buf == NULL)
d689 1
a689 1
	if (BN_bin2bn(from,flen,&f) == NULL) goto err;
d691 1
a691 1
	if (BN_ucmp(&f, rsa->n) >= 0)
d697 1
a697 1
	/* do the decrypt */
d699 1
a699 8
	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		{
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
					CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;
		}

	if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
d702 2
a703 2
	if ((padding == RSA_X931_PADDING) && ((ret.d[0] & 0xf) != 12))
		BN_sub(&ret, rsa->n, &ret);
d706 1
a706 1
	i=BN_bn2bin(&ret,p);
d713 3
d727 5
a731 3
	if (ctx != NULL) BN_CTX_free(ctx);
	BN_clear_free(&f);
	BN_clear_free(&ret);
d740 1
a740 1
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
d742 3
a744 3
	BIGNUM r1,m1,vrfy;
	BIGNUM local_dmp1, local_dmq1;
	BIGNUM *dmp1, *dmq1;
a745 1
	BN_CTX *ctx;
d747 33
a779 4
	BN_init(&m1);
	BN_init(&r1);
	BN_init(&vrfy);
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d781 2
a782 1
	if (rsa->flags & RSA_FLAG_CACHE_PRIVATE)
d784 7
a790 6
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p,
					CRYPTO_LOCK_RSA, rsa->p, ctx))
			goto err;
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q,
					CRYPTO_LOCK_RSA, rsa->q, ctx))
			goto err;
d793 2
a794 2
	if (!BN_mod(&r1,I,rsa->q,ctx)) goto err;
	if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
d797 1
a797 1
		BN_with_flags(dmq1, rsa->dmq1, BN_FLG_EXP_CONSTTIME);
d801 1
a801 1
	if (!rsa->meth->bn_mod_exp(&m1,&r1,dmq1,rsa->q,ctx,
d804 14
a817 2
	if (!BN_mod(&r1,I,rsa->p,ctx)) goto err;
	if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
d820 1
a820 1
		BN_with_flags(dmp1, rsa->dmp1, BN_FLG_EXP_CONSTTIME);
d824 1
a824 1
	if (!rsa->meth->bn_mod_exp(r0,&r1,dmp1,rsa->p,ctx,
d827 1
a827 1
	if (!BN_sub(r0,r0,&m1)) goto err;
d830 1
a830 1
	if (r0->neg)
d833 12
a844 2
	if (!BN_mul(&r1,r0,rsa->iqmp,ctx)) goto err;
	if (!BN_mod(r0,&r1,rsa->p,ctx)) goto err;
d852 1
a852 1
	if (r0->neg)
d854 2
a855 2
	if (!BN_mul(&r1,r0,rsa->q,ctx)) goto err;
	if (!BN_add(r0,&r1,&m1)) goto err;
d859 1
a859 1
		if (!rsa->meth->bn_mod_exp(&vrfy,r0,rsa->e,rsa->n,ctx,NULL)) goto err;
d864 5
a868 5
		if (!BN_sub(&vrfy, &vrfy, I)) goto err;
		if (!BN_mod(&vrfy, &vrfy, rsa->n, ctx)) goto err;
		if (vrfy.neg)
			if (!BN_add(&vrfy, &vrfy, rsa->n)) goto err;
		if (!BN_is_zero(&vrfy))
d877 1
a877 1
			if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
d880 1
a880 1
				BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
d884 2
a885 1
			if (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,NULL)) goto err;
d890 1
a890 4
	BN_clear_free(&m1);
	BN_clear_free(&r1);
	BN_clear_free(&vrfy);
	BN_CTX_free(ctx);
@


1.16
log
@resolve conflicts
@
text
@d298 22
d600 22
@


1.16.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a297 22
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}

a577 22

	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}
@


1.15
log
@resolve conflicts
@
text
@d58 53
d201 1
a201 1
	if ((rsa->_method_mod_n == NULL) && (rsa->flags & RSA_FLAG_CACHE_PUBLIC))
d203 2
a204 2
		BN_MONT_CTX* bn_mont_ctx;
		if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
a205 17
		if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->n,ctx))
			{
			BN_MONT_CTX_free(bn_mont_ctx);
			goto err;
			}
		if (rsa->_method_mod_n == NULL) /* other thread may have finished first */
			{
			CRYPTO_w_lock(CRYPTO_LOCK_RSA);
			if (rsa->_method_mod_n == NULL)
				{
				rsa->_method_mod_n = bn_mont_ctx;
				bn_mont_ctx = NULL;
				}
			CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
			}
		if (bn_mont_ctx)
			BN_MONT_CTX_free(bn_mont_ctx);
d207 1
a207 1
		
d288 1
a288 1
	BIGNUM f,ret;
d370 3
a372 1
		{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
d375 12
a386 1
		if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL)) goto err;
d392 11
d405 2
a406 2
	j=BN_num_bytes(&ret);
	i=BN_bn2bin(&ret,&(to[num-j]));
d507 3
a509 1
		{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
d512 11
a522 1
		if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL))
d609 2
a610 1
	if ((rsa->_method_mod_n == NULL) && (rsa->flags & RSA_FLAG_CACHE_PUBLIC))
d612 2
a613 2
		BN_MONT_CTX* bn_mont_ctx;
		if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
a614 17
		if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->n,ctx))
			{
			BN_MONT_CTX_free(bn_mont_ctx);
			goto err;
			}
		if (rsa->_method_mod_n == NULL) /* other thread may have finished first */
			{
			CRYPTO_w_lock(CRYPTO_LOCK_RSA);
			if (rsa->_method_mod_n == NULL)
				{
				rsa->_method_mod_n = bn_mont_ctx;
				bn_mont_ctx = NULL;
				}
			CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
			}
		if (bn_mont_ctx)
			BN_MONT_CTX_free(bn_mont_ctx);
d616 1
a616 1
		
d620 3
d656 2
d668 7
a674 23
		if (rsa->_method_mod_p == NULL)
			{
			BN_MONT_CTX* bn_mont_ctx;
			if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
				goto err;
			if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->p,ctx))
				{
				BN_MONT_CTX_free(bn_mont_ctx);
				goto err;
				}
			if (rsa->_method_mod_p == NULL) /* other thread may have finished first */
				{
				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
				if (rsa->_method_mod_p == NULL)
					{
					rsa->_method_mod_p = bn_mont_ctx;
					bn_mont_ctx = NULL;
					}
				CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
				}
			if (bn_mont_ctx)
				BN_MONT_CTX_free(bn_mont_ctx);
			}
d676 5
a680 23
		if (rsa->_method_mod_q == NULL)
			{
			BN_MONT_CTX* bn_mont_ctx;
			if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
				goto err;
			if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->q,ctx))
				{
				BN_MONT_CTX_free(bn_mont_ctx);
				goto err;
				}
			if (rsa->_method_mod_q == NULL) /* other thread may have finished first */
				{
				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
				if (rsa->_method_mod_q == NULL)
					{
					rsa->_method_mod_q = bn_mont_ctx;
					bn_mont_ctx = NULL;
					}
				CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
				}
			if (bn_mont_ctx)
				BN_MONT_CTX_free(bn_mont_ctx);
			}
d682 3
a684 3
		
	if (!BN_mod(&r1,I,rsa->q,ctx)) goto err;
	if (!rsa->meth->bn_mod_exp(&m1,&r1,rsa->dmq1,rsa->q,ctx,
d688 8
a695 1
	if (!rsa->meth->bn_mod_exp(r0,&r1,rsa->dmp1,rsa->p,ctx,
d730 1
d734 13
a746 1
			if (!rsa->meth->bn_mod_exp(r0,I,rsa->d,rsa->n,ctx,NULL)) goto err;
@


1.15.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a261 22
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}

a505 22

	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}
@


1.15.4.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a261 22
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}

a505 22

	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}
@


1.14
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d65 1
a65 1
#ifndef RSA_NULL
@


1.13
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d487 2
@


1.12
log
@update to official patch from openssl.org; ok deraadt@@, millert@@
@
text
@a63 1
#include <openssl/engine.h>
d189 1
a189 1
		memset(buf,0,num);
d208 4
a211 4
		if(((rsa)->flags & RSA_FLAG_BLINDING) && \
				((rsa)->blinding == NULL) && \
				!rsa_eay_blinding(rsa, ctx)) \
			err_instr \
d214 34
d256 2
d295 22
d318 9
a326 2
	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;
d340 2
a341 2
	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;
d355 2
d359 1
a359 1
		memset(buf,0,num);
d373 2
d407 29
d437 2
a438 2
	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;
d454 2
a455 2
	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;
d489 1
a489 1
		memset(buf,0,num);
d586 1
a586 1
		memset(buf,0,num);
@


1.11
log
@Enforce blinding on RSA operations involving private keys.
From http://www.openssl.org/~geoff, modified to be enabled at all times.
@
text
@a99 15
static void rsa_eay_blinding(RSA *rsa, BN_CTX *ctx)
	{
	CRYPTO_w_lock(CRYPTO_LOCK_RSA);
	/* Check again inside the lock - the macro's check is racey */
	if(rsa->blinding == NULL)
		RSA_blinding_on(rsa, ctx);
	CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	}
#define BLINDING_HELPER(rsa, ctx) \
	do { \
		if(((rsa)->flags & RSA_FLAG_BLINDING) && \
				((rsa)->blinding == NULL)) \
			rsa_eay_blinding(rsa, ctx); \
	} while(0)

d196 19
d259 1
a259 1
	BLINDING_HELPER(rsa, ctx);
d338 1
a338 1
	BLINDING_HELPER(rsa, ctx);
a613 4

	/* Enforce blinding. */
	rsa->flags|=RSA_FLAG_BLINDING;

@


1.10
log
@Merge OpenSSL 0.9.7-stable-20020605,
correctly autogenerate obj_mac.h
@
text
@d100 15
d255 2
a256 2
	if ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))
		RSA_blinding_on(rsa,ctx);
d334 2
a335 2
	if ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))
		RSA_blinding_on(rsa,ctx);
d610 4
@


1.10.2.1
log
@Errata #11 (markus):
Enforce blinding on RSA operations involving private keys.

millert@@ markus@@ ok
@
text
@a195 19
static int rsa_eay_blinding(RSA *rsa, BN_CTX *ctx)
	{
	int ret = 1;
	CRYPTO_w_lock(CRYPTO_LOCK_RSA);
	/* Check again inside the lock - the macro's check is racey */
	if(rsa->blinding == NULL)
		ret = RSA_blinding_on(rsa, ctx);
	CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	return ret;
	}

#define BLINDING_HELPER(rsa, ctx, err_instr) \
	do { \
		if(((rsa)->flags & RSA_FLAG_BLINDING) && \
				((rsa)->blinding == NULL) && \
				!rsa_eay_blinding(rsa, ctx)) \
			err_instr \
	} while(0)

d240 2
a241 2
	BLINDING_HELPER(rsa, ctx, goto err;);

d319 2
a320 2
	BLINDING_HELPER(rsa, ctx, goto err;);

@


1.9
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a481 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d485 1
@


1.8
log
@openssl-engine-0.9.6a merge
@
text
@d68 1
a68 1
static int RSA_eay_public_encrypt(int flen, unsigned char *from,
d70 1
a70 1
static int RSA_eay_private_encrypt(int flen, unsigned char *from,
d72 1
a72 1
static int RSA_eay_public_decrypt(int flen, unsigned char *from,
d74 1
a74 1
static int RSA_eay_private_decrypt(int flen, unsigned char *from,
d76 1
a76 1
static int RSA_eay_mod_exp(BIGNUM *r0, BIGNUM *i, RSA *rsa);
d82 2
a83 2
	RSA_eay_public_decrypt,
	RSA_eay_private_encrypt,
d86 1
a86 1
	BN_mod_exp_mont,
d89 1
a89 1
	0,
d91 2
d95 1
a95 1
RSA_METHOD *RSA_PKCS1_SSLeay(void)
d100 1
a100 1
static int RSA_eay_public_encrypt(int flen, unsigned char *from,
a102 1
	const RSA_METHOD *meth;
a107 1
	meth = ENGINE_get_RSA(rsa->engine);
d123 1
a123 1
#ifndef NO_SHA
d142 7
d172 2
a173 2

	if (!meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
d196 2
a197 1
static int RSA_eay_private_encrypt(int flen, unsigned char *from,
a199 1
	const RSA_METHOD *meth;
a204 1
	meth = ENGINE_get_RSA(rsa->engine);
d232 7
d251 1
a251 1
		{ if (!meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
d254 1
a254 1
		if (!meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL)) goto err;
d280 1
a280 1
static int RSA_eay_private_decrypt(int flen, unsigned char *from,
a282 1
	const RSA_METHOD *meth;
a288 1
	meth = ENGINE_get_RSA(rsa->engine);
d313 6
d331 1
a331 1
		{ if (!meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
d334 1
a334 1
		if (!meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL))
d349 1
a349 1
#ifndef NO_SHA
d379 2
a380 1
static int RSA_eay_public_decrypt(int flen, unsigned char *from,
a382 1
	const RSA_METHOD *meth;
a388 1
	meth = ENGINE_get_RSA(rsa->engine);
d411 7
d442 2
a443 2

	if (!meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
d476 1
a476 1
static int RSA_eay_mod_exp(BIGNUM *r0, BIGNUM *I, RSA *rsa)
a477 1
	const RSA_METHOD *meth;
a481 1
	meth = ENGINE_get_RSA(rsa->engine);
d539 1
a539 1
	if (!meth->bn_mod_exp(&m1,&r1,rsa->dmq1,rsa->q,ctx,
d543 1
a543 1
	if (!meth->bn_mod_exp(r0,&r1,rsa->dmp1,rsa->p,ctx,
d568 14
a581 5
		if (!meth->bn_mod_exp(&vrfy,r0,rsa->e,rsa->n,ctx,NULL)) goto err;
		if (BN_cmp(I, &vrfy) != 0)
			{
			if (!meth->bn_mod_exp(r0,I,rsa->d,rsa->n,ctx,NULL)) goto err;
			}
@


1.8.4.1
log
@Errata #024 (markus):
Enforce blinding on RSA operations involving private keys.
@
text
@a188 20
static int rsa_eay_blinding(RSA *rsa, BN_CTX *ctx)
	{
	int ret = 1;
	CRYPTO_w_lock(CRYPTO_LOCK_RSA);
	/* Check again inside the lock - the macro's check is racey */
	if(rsa->blinding == NULL)
		ret = RSA_blinding_on(rsa, ctx);
	CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	return ret;
	}

#define BLINDING_HELPER(rsa, ctx, err_instr) \
	do { \
		if(((rsa)->flags & RSA_FLAG_BLINDING) && \
				((rsa)->blinding == NULL) && \
				!rsa_eay_blinding(rsa, ctx)) \
			err_instr \
	} while(0)

/* signing */
d227 2
a228 2
	BLINDING_HELPER(rsa, ctx, goto err;);

d302 2
a303 2
	BLINDING_HELPER(rsa, ctx, goto err;);

@


1.7
log
@CRT and DH+SSL fix from 0.9.6a, ok provos@@/deraadt@@
@
text
@d144 20
a163 3
		if ((rsa->_method_mod_n=BN_MONT_CTX_new()) != NULL)
			if (!BN_MONT_CTX_set(rsa->_method_mod_n,rsa->n,ctx))
			    goto err;
d398 20
a417 3
		if ((rsa->_method_mod_n=BN_MONT_CTX_new()) != NULL)
			if (!BN_MONT_CTX_set(rsa->_method_mod_n,rsa->n,ctx))
			    goto err;
d470 20
a489 4
			if ((rsa->_method_mod_p=BN_MONT_CTX_new()) != NULL)
				if (!BN_MONT_CTX_set(rsa->_method_mod_p,rsa->p,
						     ctx))
					goto err;
d491 1
d494 20
a513 4
			if ((rsa->_method_mod_q=BN_MONT_CTX_new()) != NULL)
				if (!BN_MONT_CTX_set(rsa->_method_mod_q,rsa->q,
						     ctx))
					goto err;
d516 1
a516 1

@


1.6
log
@openssl-engine-0.9.6 merge
@
text
@d422 1
a422 1
	BIGNUM r1,m1;
d430 1
d478 8
d490 1
@


1.5
log
@RSA goes in tree for next our next release, as it will be after
Sept 21.  Note: This means you shouldn't really be running -current
for anything in the United States. Either wait for Sept 21, or for the
next release, or move to the free world :)
@
text
@d64 1
d101 1
d107 1
d112 1
a112 1
	if ((buf=(unsigned char *)Malloc(num)) == NULL)
d149 1
a149 1
	if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
d167 1
a167 1
		Free(buf);
d175 1
d181 1
d187 1
a187 1
	if ((buf=(unsigned char *)Malloc(num)) == NULL)
d221 1
a221 1
		{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
d224 1
a224 1
		if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL)) goto err;
d245 1
a245 1
		Free(buf);
d253 1
d260 1
d268 1
a268 1
	if ((buf=(unsigned char *)Malloc(num)) == NULL)
d297 1
a297 1
		{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
d300 1
a300 1
		if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL))
d340 1
a340 1
		Free(buf);
d348 1
d355 1
d362 1
a362 1
	buf=(unsigned char *)Malloc(num);
d386 1
a386 1
	if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
d414 1
a414 1
		Free(buf);
d421 1
d426 1
d450 1
a450 1
	if (!rsa->meth->bn_mod_exp(&m1,&r1,rsa->dmq1,rsa->q,ctx,
d454 1
a454 1
	if (!rsa->meth->bn_mod_exp(r0,&r1,rsa->dmp1,rsa->p,ctx,
@


1.4
log
@Fix an oopsie so these get initialized even when RSA isn't there,
thanks niklas@@

*WARNING* - this breaks the patch used in the "ssl26" port - you'll
need to use the new minty ssl-intl port, coming right after this
@
text
@a0 10

/* This file has been explicitly broken by ryker for OpenBSD, July
 * 1, 1998. In spite of the title, there is no implementation of the
 * RSA algorithm left in this file. All these routines will return an
 * error and fail when called. They exist as stubs and can be
 * ressurected from the bit bucket by someone in the free world once
 * the RSA algorithm is no longer subject to patent problems. Eric
 * Young's original copyright is below. 
 */

d177 2
a178 2
        BN_init(&f);
        BN_init(&ret);
d180 7
a186 3
	/* Body of this routine removed for OpenBSD - will return
	 * when the RSA patent expires
	 */
d188 45
d254 42
a295 2
        BN_init(&f);
        BN_init(&ret);
d297 28
a324 3
	/* Body of this routine removed for OpenBSD - will return
	 * when the RSA patent expires
	 */
d347 4
a350 2
        BN_init(&f);
        BN_init(&ret);
d352 45
a396 3
	/* Body of this routine removed for OpenBSD - will return
	 * when the RSA patent expires
	 */
d414 1
a414 1
	BN_CTX *ctx = NULL;
d416 1
a418 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d420 47
a466 3
	/* Body of this routine removed for OpenBSD - will return
	 * when the RSA patent expires
	 */
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d187 3
d215 3
d243 3
d266 1
a266 1
	BN_CTX *ctx;
a267 1
	if ((ctx=BN_CTX_new()) == NULL) goto err;
d270 1
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d75 2
d290 1
a290 1

@


1.1
log
@Initial revision
@
text
@d71 3
a73 3
#include "bn.h"
#include "rsa.h"
#include "rand.h"
a74 1
#ifndef NOPROTO
a85 10
#else
static int RSA_eay_public_encrypt();
static int RSA_eay_private_encrypt();
static int RSA_eay_public_decrypt();
static int RSA_eay_private_decrypt();
static int RSA_eay_mod_exp();
static int RSA_eay_init();
static int RSA_eay_finish();
#endif

d100 1
a100 1
RSA_METHOD *RSA_PKCS1_SSLeay()
d105 2
a106 6
static int RSA_eay_public_encrypt(flen, from, to, rsa, padding)
int flen;
unsigned char *from;
unsigned char *to;
RSA *rsa;
int padding;
d108 1
a108 1
	BIGNUM *f=NULL,*ret=NULL;
d113 50
a162 3
	/* Body of this routine removed for OpenBSD - will return
	 * when the RSA patent expires
	 */
d164 1
d167 2
a168 2
	if (f != NULL) BN_free(f);
	if (ret != NULL) BN_free(ret);
d177 2
a178 6
static int RSA_eay_private_encrypt(flen, from, to, rsa, padding)
int flen;
unsigned char *from;
unsigned char *to;
RSA *rsa;
int padding;
d180 1
a180 1
	BIGNUM *f=NULL,*ret=NULL;
d191 2
a192 2
	if (ret != NULL) BN_free(ret);
	if (f != NULL) BN_free(f);
d201 2
a202 6
static int RSA_eay_private_decrypt(flen, from, to, rsa,padding)
int flen;
unsigned char *from;
unsigned char *to;
RSA *rsa;
int padding;
d204 1
a204 1
	BIGNUM *f=NULL,*ret=NULL;
d216 2
a217 2
	if (f != NULL) BN_free(f);
	if (ret != NULL) BN_free(ret);
d226 2
a227 6
static int RSA_eay_public_decrypt(flen, from, to, rsa, padding)
int flen;
unsigned char *from;
unsigned char *to;
RSA *rsa;
int padding;
d229 1
a229 1
	BIGNUM *f=NULL,*ret=NULL;
a234 1

d241 2
a242 2
	if (f != NULL) BN_free(f);
	if (ret != NULL) BN_free(ret);
d251 1
a251 4
static int RSA_eay_mod_exp(r0, I, rsa)
BIGNUM *r0;
BIGNUM *I;
RSA *rsa;
d253 1
a253 1
	BIGNUM *r1=NULL,*m1=NULL;
d258 2
a259 3
	m1=BN_new();
	r1=BN_new();
	if ((m1 == NULL) || (r1 == NULL)) goto err;
d265 2
a266 2
	if (m1 != NULL) BN_free(m1);
	if (r1 != NULL) BN_free(r1);
d271 1
a271 2
static int RSA_eay_init(rsa)
RSA *rsa;
d277 1
a277 2
static int RSA_eay_finish(rsa)
RSA *rsa;
d279 6
a284 6
	if (rsa->method_mod_n != NULL)
		BN_MONT_CTX_free((BN_MONT_CTX *)rsa->method_mod_n);
	if (rsa->method_mod_p != NULL)
		BN_MONT_CTX_free((BN_MONT_CTX *)rsa->method_mod_p);
	if (rsa->method_mod_q != NULL)
		BN_MONT_CTX_free((BN_MONT_CTX *)rsa->method_mod_q);
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 10
d71 3
a73 4
#include <openssl/bn.h>
#include <openssl/rsa.h>
#include <openssl/rand.h>
#include <openssl/engine.h>
d75 2
a76 3
#ifndef RSA_NULL

static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
d78 1
a78 1
static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
d80 1
a80 1
static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
d82 1
a82 1
static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
d84 1
a84 1
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa);
d87 10
d100 2
a101 2
	RSA_eay_public_decrypt, /* signature verification */
	RSA_eay_private_encrypt, /* signing */
d104 1
a104 1
	BN_mod_exp_mont, /* XXX probably we should not use Montgomery if  e == 3 */
d107 1
a107 1
	0, /* flags */
a108 2
	0, /* rsa_sign */
	0  /* rsa_verify */
d111 1
a111 1
const RSA_METHOD *RSA_PKCS1_SSLeay(void)
d116 6
a121 2
static int RSA_eay_public_encrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
d123 1
a123 1
	BIGNUM f,ret;
d128 3
a130 9
	BN_init(&f);
	BN_init(&ret);
	if ((ctx=BN_CTX_new()) == NULL) goto err;
	num=BN_num_bytes(rsa->n);
	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,ERR_R_MALLOC_FAILURE);
		goto err;
		}
a131 66
	switch (padding)
		{
	case RSA_PKCS1_PADDING:
		i=RSA_padding_add_PKCS1_type_2(buf,num,from,flen);
		break;
#ifndef OPENSSL_NO_SHA
	case RSA_PKCS1_OAEP_PADDING:
	        i=RSA_padding_add_PKCS1_OAEP(buf,num,from,flen,NULL,0);
		break;
#endif
	case RSA_SSLV23_PADDING:
		i=RSA_padding_add_SSLv23(buf,num,from,flen);
		break;
	case RSA_NO_PADDING:
		i=RSA_padding_add_none(buf,num,from,flen);
		break;
	default:
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
		}
	if (i <= 0) goto err;

	if (BN_bin2bn(buf,num,&f) == NULL) goto err;
	
	if (BN_ucmp(&f, rsa->n) >= 0)
		{	
		/* usually the padding functions would catch this */
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
		}

	if ((rsa->_method_mod_n == NULL) && (rsa->flags & RSA_FLAG_CACHE_PUBLIC))
		{
		BN_MONT_CTX* bn_mont_ctx;
		if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
			goto err;
		if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->n,ctx))
			{
			BN_MONT_CTX_free(bn_mont_ctx);
			goto err;
			}
		if (rsa->_method_mod_n == NULL) /* other thread may have finished first */
			{
			CRYPTO_w_lock(CRYPTO_LOCK_RSA);
			if (rsa->_method_mod_n == NULL)
				{
				rsa->_method_mod_n = bn_mont_ctx;
				bn_mont_ctx = NULL;
				}
			CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
			}
		if (bn_mont_ctx)
			BN_MONT_CTX_free(bn_mont_ctx);
		}
		
	if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
		rsa->_method_mod_n)) goto err;

	/* put in leading 0 bytes if the number is less than the
	 * length of the modulus */
	j=BN_num_bytes(&ret);
	i=BN_bn2bin(&ret,&(to[num-j]));
	for (k=0; k<(num-i); k++)
		to[k]=0;

	r=num;
d134 2
a135 2
	BN_clear_free(&f);
	BN_clear_free(&ret);
d139 1
a139 1
		OPENSSL_free(buf);
d144 6
a149 3
/* signing */
static int RSA_eay_private_encrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
d151 1
a151 1
	BIGNUM f,ret;
d156 3
a158 34
	BN_init(&f);
	BN_init(&ret);

	if ((ctx=BN_CTX_new()) == NULL) goto err;
	num=BN_num_bytes(rsa->n);
	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	switch (padding)
		{
	case RSA_PKCS1_PADDING:
		i=RSA_padding_add_PKCS1_type_1(buf,num,from,flen);
		break;
	case RSA_NO_PADDING:
		i=RSA_padding_add_none(buf,num,from,flen);
		break;
	case RSA_SSLV23_PADDING:
	default:
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
		}
	if (i <= 0) goto err;

	if (BN_bin2bn(buf,num,&f) == NULL) goto err;
	
	if (BN_ucmp(&f, rsa->n) >= 0)
		{	
		/* usually the padding functions would catch this */
		RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
		}
a159 28
	if ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))
		RSA_blinding_on(rsa,ctx);
	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;

	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
		((rsa->p != NULL) &&
		(rsa->q != NULL) &&
		(rsa->dmp1 != NULL) &&
		(rsa->dmq1 != NULL) &&
		(rsa->iqmp != NULL)) )
		{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
	else
		{
		if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL)) goto err;
		}

	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;

	/* put in leading 0 bytes if the number is less than the
	 * length of the modulus */
	j=BN_num_bytes(&ret);
	i=BN_bn2bin(&ret,&(to[num-j]));
	for (k=0; k<(num-i); k++)
		to[k]=0;

	r=num;
d162 2
a163 2
	BN_clear_free(&ret);
	BN_clear_free(&f);
d167 1
a167 1
		OPENSSL_free(buf);
d172 6
a177 2
static int RSA_eay_private_decrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
d179 1
a179 1
	BIGNUM f,ret;
d185 3
a187 77
	BN_init(&f);
	BN_init(&ret);
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;

	num=BN_num_bytes(rsa->n);

	if ((buf=(unsigned char *)OPENSSL_malloc(num)) == NULL)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	/* This check was for equality but PGP does evil things
	 * and chops off the top '0' bytes */
	if (flen > num)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
		goto err;
		}

	/* make data into a big number */
	if (BN_bin2bn(from,(int)flen,&f) == NULL) goto err;

	if (BN_ucmp(&f, rsa->n) >= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
		}

	if ((rsa->flags & RSA_FLAG_BLINDING) && (rsa->blinding == NULL))
		RSA_blinding_on(rsa,ctx);
	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_convert(&f,rsa->blinding,ctx)) goto err;

	/* do the decrypt */
	if ( (rsa->flags & RSA_FLAG_EXT_PKEY) ||
		((rsa->p != NULL) &&
		(rsa->q != NULL) &&
		(rsa->dmp1 != NULL) &&
		(rsa->dmq1 != NULL) &&
		(rsa->iqmp != NULL)) )
		{ if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err; }
	else
		{
		if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->d,rsa->n,ctx,NULL))
			goto err;
		}

	if (rsa->flags & RSA_FLAG_BLINDING)
		if (!BN_BLINDING_invert(&ret,rsa->blinding,ctx)) goto err;

	p=buf;
	j=BN_bn2bin(&ret,p); /* j is only used with no-padding mode */

	switch (padding)
		{
	case RSA_PKCS1_PADDING:
		r=RSA_padding_check_PKCS1_type_2(to,num,buf,j,num);
		break;
#ifndef OPENSSL_NO_SHA
        case RSA_PKCS1_OAEP_PADDING:
	        r=RSA_padding_check_PKCS1_OAEP(to,num,buf,j,num,NULL,0);
                break;
#endif
 	case RSA_SSLV23_PADDING:
		r=RSA_padding_check_SSLv23(to,num,buf,j,num);
		break;
	case RSA_NO_PADDING:
		r=RSA_padding_check_none(to,num,buf,j,num);
		break;
	default:
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
		}
	if (r < 0)
		RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
d191 2
a192 2
	BN_clear_free(&f);
	BN_clear_free(&ret);
d196 1
a196 1
		OPENSSL_free(buf);
d201 6
a206 3
/* signature verification */
static int RSA_eay_public_decrypt(int flen, const unsigned char *from,
	     unsigned char *to, RSA *rsa, int padding)
d208 1
a208 1
	BIGNUM f,ret;
a213 20
	BN_init(&f);
	BN_init(&ret);
	ctx=BN_CTX_new();
	if (ctx == NULL) goto err;

	num=BN_num_bytes(rsa->n);
	buf=(unsigned char *)OPENSSL_malloc(num);
	if (buf == NULL)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,ERR_R_MALLOC_FAILURE);
		goto err;
		}

	/* This check was for equality but PGP does evil things
	 * and chops off the top '0' bytes */
	if (flen > num)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_GREATER_THAN_MOD_LEN);
		goto err;
		}
d215 3
a217 53
	if (BN_bin2bn(from,flen,&f) == NULL) goto err;

	if (BN_ucmp(&f, rsa->n) >= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);
		goto err;
		}

	/* do the decrypt */
	if ((rsa->_method_mod_n == NULL) && (rsa->flags & RSA_FLAG_CACHE_PUBLIC))
		{
		BN_MONT_CTX* bn_mont_ctx;
		if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
			goto err;
		if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->n,ctx))
			{
			BN_MONT_CTX_free(bn_mont_ctx);
			goto err;
			}
		if (rsa->_method_mod_n == NULL) /* other thread may have finished first */
			{
			CRYPTO_w_lock(CRYPTO_LOCK_RSA);
			if (rsa->_method_mod_n == NULL)
				{
				rsa->_method_mod_n = bn_mont_ctx;
				bn_mont_ctx = NULL;
				}
			CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
			}
		if (bn_mont_ctx)
			BN_MONT_CTX_free(bn_mont_ctx);
		}
		
	if (!rsa->meth->bn_mod_exp(&ret,&f,rsa->e,rsa->n,ctx,
		rsa->_method_mod_n)) goto err;

	p=buf;
	i=BN_bn2bin(&ret,p);

	switch (padding)
		{
	case RSA_PKCS1_PADDING:
		r=RSA_padding_check_PKCS1_type_1(to,num,buf,i,num);
		break;
	case RSA_NO_PADDING:
		r=RSA_padding_check_none(to,num,buf,i,num);
		break;
	default:
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_UNKNOWN_PADDING_TYPE);
		goto err;
		}
	if (r < 0)
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT,RSA_R_PADDING_CHECK_FAILED);
d221 2
a222 2
	BN_clear_free(&f);
	BN_clear_free(&ret);
d226 1
a226 1
		OPENSSL_free(buf);
d231 4
a234 1
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa)
d236 1
a236 1
	BIGNUM r1,m1,vrfy;
a239 3
	BN_init(&m1);
	BN_init(&r1);
	BN_init(&vrfy);
d241 7
a247 98

	if (rsa->flags & RSA_FLAG_CACHE_PRIVATE)
		{
		if (rsa->_method_mod_p == NULL)
			{
			BN_MONT_CTX* bn_mont_ctx;
			if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
				goto err;
			if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->p,ctx))
				{
				BN_MONT_CTX_free(bn_mont_ctx);
				goto err;
				}
			if (rsa->_method_mod_p == NULL) /* other thread may have finished first */
				{
				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
				if (rsa->_method_mod_p == NULL)
					{
					rsa->_method_mod_p = bn_mont_ctx;
					bn_mont_ctx = NULL;
					}
				CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
				}
			if (bn_mont_ctx)
				BN_MONT_CTX_free(bn_mont_ctx);
			}

		if (rsa->_method_mod_q == NULL)
			{
			BN_MONT_CTX* bn_mont_ctx;
			if ((bn_mont_ctx=BN_MONT_CTX_new()) == NULL)
				goto err;
			if (!BN_MONT_CTX_set(bn_mont_ctx,rsa->q,ctx))
				{
				BN_MONT_CTX_free(bn_mont_ctx);
				goto err;
				}
			if (rsa->_method_mod_q == NULL) /* other thread may have finished first */
				{
				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
				if (rsa->_method_mod_q == NULL)
					{
					rsa->_method_mod_q = bn_mont_ctx;
					bn_mont_ctx = NULL;
					}
				CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
				}
			if (bn_mont_ctx)
				BN_MONT_CTX_free(bn_mont_ctx);
			}
		}
		
	if (!BN_mod(&r1,I,rsa->q,ctx)) goto err;
	if (!rsa->meth->bn_mod_exp(&m1,&r1,rsa->dmq1,rsa->q,ctx,
		rsa->_method_mod_q)) goto err;

	if (!BN_mod(&r1,I,rsa->p,ctx)) goto err;
	if (!rsa->meth->bn_mod_exp(r0,&r1,rsa->dmp1,rsa->p,ctx,
		rsa->_method_mod_p)) goto err;

	if (!BN_sub(r0,r0,&m1)) goto err;
	/* This will help stop the size of r0 increasing, which does
	 * affect the multiply if it optimised for a power of 2 size */
	if (r0->neg)
		if (!BN_add(r0,r0,rsa->p)) goto err;

	if (!BN_mul(&r1,r0,rsa->iqmp,ctx)) goto err;
	if (!BN_mod(r0,&r1,rsa->p,ctx)) goto err;
	/* If p < q it is occasionally possible for the correction of
         * adding 'p' if r0 is negative above to leave the result still
	 * negative. This can break the private key operations: the following
	 * second correction should *always* correct this rare occurrence.
	 * This will *never* happen with OpenSSL generated keys because
         * they ensure p > q [steve]
         */
	if (r0->neg)
		if (!BN_add(r0,r0,rsa->p)) goto err;
	if (!BN_mul(&r1,r0,rsa->q,ctx)) goto err;
	if (!BN_add(r0,&r1,&m1)) goto err;

	if (rsa->e && rsa->n)
		{
		if (!rsa->meth->bn_mod_exp(&vrfy,r0,rsa->e,rsa->n,ctx,NULL)) goto err;
		/* If 'I' was greater than (or equal to) rsa->n, the operation
		 * will be equivalent to using 'I mod n'. However, the result of
		 * the verify will *always* be less than 'n' so we don't check
		 * for absolute equality, just congruency. */
		if (!BN_sub(&vrfy, &vrfy, I)) goto err;
		if (!BN_mod(&vrfy, &vrfy, rsa->n, ctx)) goto err;
		if (vrfy.neg)
			if (!BN_add(&vrfy, &vrfy, rsa->n)) goto err;
		if (!BN_is_zero(&vrfy))
			/* 'I' and 'vrfy' aren't congruent mod n. Don't leak
			 * miscalculated CRT output, just do a raw (slower)
			 * mod_exp and return that instead. */
			if (!rsa->meth->bn_mod_exp(r0,I,rsa->d,rsa->n,ctx,NULL)) goto err;
		}
	ret=1;
d249 2
a250 3
	BN_clear_free(&m1);
	BN_clear_free(&r1);
	BN_clear_free(&vrfy);
d255 2
a256 1
static int RSA_eay_init(RSA *rsa)
d262 2
a263 1
static int RSA_eay_finish(RSA *rsa)
d265 6
a270 6
	if (rsa->_method_mod_n != NULL)
		BN_MONT_CTX_free(rsa->_method_mod_n);
	if (rsa->_method_mod_p != NULL)
		BN_MONT_CTX_free(rsa->_method_mod_p);
	if (rsa->_method_mod_q != NULL)
		BN_MONT_CTX_free(rsa->_method_mod_q);
d274 1
a274 1
#endif
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d64 1
d190 1
a190 1
		OPENSSL_cleanse(buf,num);
a195 53
static int rsa_eay_blinding(RSA *rsa, BN_CTX *ctx)
	{
	int ret = 1;
	CRYPTO_w_lock(CRYPTO_LOCK_RSA);
	/* Check again inside the lock - the macro's check is racey */
	if(rsa->blinding == NULL)
		ret = RSA_blinding_on(rsa, ctx);
	CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	return ret;
	}

#define BLINDING_HELPER(rsa, ctx, err_instr) \
	do { \
		if((!((rsa)->flags & RSA_FLAG_NO_BLINDING)) && \
		    ((rsa)->blinding == NULL) && \
		    !rsa_eay_blinding(rsa, ctx)) \
		    err_instr \
	} while(0)

static BN_BLINDING *setup_blinding(RSA *rsa, BN_CTX *ctx)
	{
	BIGNUM *A, *Ai;
	BN_BLINDING *ret = NULL;

	/* added in OpenSSL 0.9.6j and 0.9.7b */

	/* NB: similar code appears in RSA_blinding_on (rsa_lib.c);
	 * this should be placed in a new function of its own, but for reasons
	 * of binary compatibility can't */

	BN_CTX_start(ctx);
	A = BN_CTX_get(ctx);
	if ((RAND_status() == 0) && rsa->d != NULL && rsa->d->d != NULL)
		{
		/* if PRNG is not properly seeded, resort to secret exponent as unpredictable seed */
		RAND_add(rsa->d->d, rsa->d->dmax * sizeof rsa->d->d[0], 0);
		if (!BN_pseudo_rand_range(A,rsa->n)) goto err;
		}
	else
		{
		if (!BN_rand_range(A,rsa->n)) goto err;
		}
	if ((Ai=BN_mod_inverse(NULL,A,rsa->n,ctx)) == NULL) goto err;

	if (!rsa->meth->bn_mod_exp(A,A,rsa->e,rsa->n,ctx,rsa->_method_mod_n))
		goto err;
	ret = BN_BLINDING_new(A,Ai,rsa->n);
	BN_free(Ai);
err:
	BN_CTX_end(ctx);
	return ret;
	}

a203 2
	int local_blinding = 0;
	BN_BLINDING *blinding = NULL;
d240 4
a243 33
	BLINDING_HELPER(rsa, ctx, goto err;);
	blinding = rsa->blinding;
	
	/* Now unless blinding is disabled, 'blinding' is non-NULL.
	 * But the BN_BLINDING object may be owned by some other thread
	 * (we don't want to keep it constant and we don't want to use
	 * lots of locking to avoid race conditions, so only a single
	 * thread can use it; other threads have to use local blinding
	 * factors) */
	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
		{
		if (blinding == NULL)
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT, ERR_R_INTERNAL_ERROR);
			goto err;
			}
		}
	
	if (blinding != NULL)
		{
		if (blinding->thread_id != CRYPTO_thread_id())
			{
			/* we need a local one-time blinding factor */

			blinding = setup_blinding(rsa, ctx);
			if (blinding == NULL)
				goto err;
			local_blinding = 1;
			}
		}

	if (blinding)
		if (!BN_BLINDING_convert(&f, blinding, ctx)) goto err;
d257 2
a258 2
	if (blinding)
		if (!BN_BLINDING_invert(&ret, blinding, ctx)) goto err;
a271 2
	if (local_blinding)
		BN_BLINDING_free(blinding);
d274 1
a274 1
		OPENSSL_cleanse(buf,num);
a287 2
	int local_blinding = 0;
	BN_BLINDING *blinding = NULL;
d319 4
a322 33
	BLINDING_HELPER(rsa, ctx, goto err;);
	blinding = rsa->blinding;
	
	/* Now unless blinding is disabled, 'blinding' is non-NULL.
	 * But the BN_BLINDING object may be owned by some other thread
	 * (we don't want to keep it constant and we don't want to use
	 * lots of locking to avoid race conditions, so only a single
	 * thread can use it; other threads have to use local blinding
	 * factors) */
	if (!(rsa->flags & RSA_FLAG_NO_BLINDING))
		{
		if (blinding == NULL)
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT, ERR_R_INTERNAL_ERROR);
			goto err;
			}
		}
	
	if (blinding != NULL)
		{
		if (blinding->thread_id != CRYPTO_thread_id())
			{
			/* we need a local one-time blinding factor */

			blinding = setup_blinding(rsa, ctx);
			if (blinding == NULL)
				goto err;
			local_blinding = 1;
			}
		}

	if (blinding)
		if (!BN_BLINDING_convert(&f, blinding, ctx)) goto err;
d338 2
a339 2
	if (blinding)
		if (!BN_BLINDING_invert(&ret, blinding, ctx)) goto err;
d373 1
a373 1
		OPENSSL_cleanse(buf,num);
d470 1
a470 1
		OPENSSL_cleanse(buf,num);
@


1.1.1.4
log
@import 0.9.7c
@
text
@a486 2
	if (local_blinding)
		BN_BLINDING_free(blinding);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@d65 1
a65 1
#if !defined(RSA_NULL) && !defined(OPENSSL_FIPS)
@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@a57 53
/* ====================================================================
 * Copyright (c) 1998-2005 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
d148 1
a148 1
	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
d150 2
a151 2
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
					CRYPTO_LOCK_RSA, rsa->n, ctx))
d153 17
d171 1
a171 1

d252 1
a252 1
	BIGNUM f,ret, *res;
d334 1
a334 3
		{ 
		if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err;
		}
d337 1
a337 12
		BIGNUM local_d;
		BIGNUM *d = NULL;
		
		if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
			{
			BN_init(&local_d);
			d = &local_d;
			BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
			}
		else
			d = rsa->d;
		if (!rsa->meth->bn_mod_exp(&ret,&f,d,rsa->n,ctx,NULL)) goto err;
a342 11
	if (padding == RSA_X931_PADDING)
		{
		BN_sub(&f, rsa->n, &ret);
		if (BN_cmp(&ret, &f))
			res = &f;
		else
			res = &ret;
		}
	else
		res = &ret;

d345 2
a346 2
	j=BN_num_bytes(res);
	i=BN_bn2bin(res,&(to[num-j]));
d447 1
a447 3
		{
		if (!rsa->meth->rsa_mod_exp(&ret,&f,rsa)) goto err;
		}
d450 1
a450 11
		BIGNUM local_d;
		BIGNUM *d = NULL;
		
		if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
			{
			d = &local_d;
			BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
			}
		else
			d = rsa->d;
		if (!rsa->meth->bn_mod_exp(&ret,&f,d,rsa->n,ctx,NULL))
d537 1
a537 2

	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
d539 2
a540 2
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n,
					CRYPTO_LOCK_RSA, rsa->n, ctx))
d542 17
d560 1
a560 1

a563 3
	if ((padding == RSA_X931_PADDING) && ((ret.d[0] & 0xf) != 12))
		BN_sub(&ret, rsa->n, &ret);

a596 2
	BIGNUM local_dmp1, local_dmq1;
	BIGNUM *dmp1, *dmq1;
d607 47
a653 6
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p,
					CRYPTO_LOCK_RSA, rsa->p, ctx))
			goto err;
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q,
					CRYPTO_LOCK_RSA, rsa->q, ctx))
			goto err;
d655 1
a655 1

d657 1
a657 8
	if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
		{
		dmq1 = &local_dmq1;
		BN_with_flags(dmq1, rsa->dmq1, BN_FLG_EXP_CONSTTIME);
		}
	else
		dmq1 = rsa->dmq1;
	if (!rsa->meth->bn_mod_exp(&m1,&r1,dmq1,rsa->q,ctx,
d661 1
a661 8
	if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
		{
		dmp1 = &local_dmp1;
		BN_with_flags(dmp1, rsa->dmp1, BN_FLG_EXP_CONSTTIME);
		}
	else
		dmp1 = rsa->dmp1;
	if (!rsa->meth->bn_mod_exp(r0,&r1,dmp1,rsa->p,ctx,
a695 1
			{
d699 1
a699 13

			BIGNUM local_d;
			BIGNUM *d = NULL;
		
			if (!(rsa->flags & RSA_FLAG_NO_EXP_CONSTTIME))
				{
				d = &local_d;
				BN_with_flags(d, rsa->d, BN_FLG_EXP_CONSTTIME);
				}
			else
				d = rsa->d;
			if (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,NULL)) goto err;
			}
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d118 1
a118 1
#ifndef RSA_NULL
d128 1
a128 1
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *i, RSA *rsa, BN_CTX *ctx);
d144 1
a144 2
	0, /* rsa_verify */
	NULL /* rsa_keygen */
a151 10
/* Usage example;
 *    MONT_HELPER(rsa->_method_mod_p, bn_ctx, rsa->p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
 */
#define MONT_HELPER(method_mod, ctx, m, pre_cond, err_instr) \
	if ((pre_cond) && ((method_mod) == NULL) && \
			!BN_MONT_CTX_set_locked(&(method_mod), \
				CRYPTO_LOCK_RSA, \
				(m), (ctx))) \
		err_instr

d155 1
a155 1
	BIGNUM *f,*ret;
d160 2
a161 22
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}

	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_ENCRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}
	
a162 3
	BN_CTX_start(ctx);
	f = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
d164 1
a164 2
	buf = OPENSSL_malloc(num);
	if (!f || !ret || !buf)
d192 1
a192 1
	if (BN_bin2bn(buf,num,f) == NULL) goto err;
d194 2
a195 2
	if (BN_ucmp(f, rsa->n) >= 0)
		{
d201 6
a206 1
	MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
d208 1
a208 1
	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
d213 2
a214 2
	j=BN_num_bytes(ret);
	i=BN_bn2bin(ret,&(to[num-j]));
d220 3
a222 5
	if (ctx != NULL)
		{
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
		}
d231 10
a240 4
static BN_BLINDING *rsa_get_blinding(RSA *rsa, int *local, BN_CTX *ctx)
{
	BN_BLINDING *ret;
	int got_write_lock = 0;
d242 7
a248 1
	CRYPTO_r_lock(CRYPTO_LOCK_RSA);
d250 4
a253 5
	if (rsa->blinding == NULL)
		{
		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
		CRYPTO_w_lock(CRYPTO_LOCK_RSA);
		got_write_lock = 1;
d255 1
a255 3
		if (rsa->blinding == NULL)
			rsa->blinding = RSA_setup_blinding(rsa, ctx);
		}
d257 3
a259 3
	ret = rsa->blinding;
	if (ret == NULL)
		goto err;
d261 3
a263 1
	if (BN_BLINDING_get_thread_id(ret) == CRYPTO_thread_id())
d265 3
a267 3
		/* rsa->blinding is ours! */

		*local = 1;
d271 1
a271 21
		/* resort to rsa->mt_blinding instead */

		*local = 0; /* instructs rsa_blinding_convert(), rsa_blinding_invert()
		             * that the BN_BLINDING is shared, meaning that accesses
		             * require locks, and that the blinding factor must be
		             * stored outside the BN_BLINDING
		             */

		if (rsa->mt_blinding == NULL)
			{
			if (!got_write_lock)
				{
				CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
				CRYPTO_w_lock(CRYPTO_LOCK_RSA);
				got_write_lock = 1;
				}
			
			if (rsa->mt_blinding == NULL)
				rsa->mt_blinding = RSA_setup_blinding(rsa, ctx);
			}
		ret = rsa->mt_blinding;
d273 1
d275 6
a280 5
 err:
	if (got_write_lock)
		CRYPTO_w_unlock(CRYPTO_LOCK_RSA);
	else
		CRYPTO_r_unlock(CRYPTO_LOCK_RSA);
d282 1
a282 31
}

static int rsa_blinding_convert(BN_BLINDING *b, int local, BIGNUM *f,
	BIGNUM *r, BN_CTX *ctx)
{
	if (local)
		return BN_BLINDING_convert_ex(f, NULL, b, ctx);
	else
		{
		int ret;
		CRYPTO_r_lock(CRYPTO_LOCK_RSA_BLINDING);
		ret = BN_BLINDING_convert_ex(f, r, b, ctx);
		CRYPTO_r_unlock(CRYPTO_LOCK_RSA_BLINDING);
		return ret;
		}
}

static int rsa_blinding_invert(BN_BLINDING *b, int local, BIGNUM *f,
	BIGNUM *r, BN_CTX *ctx)
{
	if (local)
		return BN_BLINDING_invert_ex(f, NULL, b, ctx);
	else
		{
		int ret;
		CRYPTO_w_lock(CRYPTO_LOCK_RSA_BLINDING);
		ret = BN_BLINDING_invert_ex(f, r, b, ctx);
		CRYPTO_w_unlock(CRYPTO_LOCK_RSA_BLINDING);
		return ret;
		}
}
d288 1
a288 1
	BIGNUM *f, *ret, *br, *res;
d295 3
d299 2
a300 7
	BN_CTX_start(ctx);
	f   = BN_CTX_get(ctx);
	br  = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
	num = BN_num_bytes(rsa->n);
	buf = OPENSSL_malloc(num);
	if(!f || !ret || !buf)
a310 3
	case RSA_X931_PADDING:
		i=RSA_padding_add_X931(buf,num,from,flen);
		break;
d321 1
a321 1
	if (BN_bin2bn(buf,num,f) == NULL) goto err;
d323 1
a323 1
	if (BN_ucmp(f, rsa->n) >= 0)
d330 9
a340 1
		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
d349 14
a362 2
		if (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))
			goto err;
d371 1
a371 1
		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
d378 1
a378 1
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
d382 1
a382 1
			BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
d385 2
a386 6
			d= rsa->d;

		MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);

		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
				rsa->_method_mod_n)) goto err;
d390 1
a390 2
		if (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))
			goto err;
d394 3
a396 3
		BN_sub(f, rsa->n, ret);
		if (BN_cmp(ret, f))
			res = f;
d398 1
a398 1
			res = ret;
d401 1
a401 1
		res = ret;
d412 5
a416 5
	if (ctx != NULL)
		{
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
		}
d428 1
a428 1
	BIGNUM *f, *ret, *br;
d436 8
a443 8
	if((ctx = BN_CTX_new()) == NULL) goto err;
	BN_CTX_start(ctx);
	f   = BN_CTX_get(ctx);
	br  = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
	num = BN_num_bytes(rsa->n);
	buf = OPENSSL_malloc(num);
	if(!f || !ret || !buf)
d458 1
a458 1
	if (BN_bin2bn(from,(int)flen,f) == NULL) goto err;
d460 1
a460 1
	if (BN_ucmp(f, rsa->n) >= 0)
d466 9
a476 1
		blinding = rsa_get_blinding(rsa, &local_blinding, ctx);
d485 14
a498 2
		if (!rsa_blinding_convert(blinding, local_blinding, f, br, ctx))
			goto err;
d508 1
a508 1
		if (!rsa->meth->rsa_mod_exp(ret, f, rsa, ctx)) goto err;
d515 1
a515 1
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
d518 1
a518 1
			BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
d522 2
a523 5

		MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
		if (!rsa->meth->bn_mod_exp(ret,f,d,rsa->n,ctx,
				rsa->_method_mod_n))
		  goto err;
d527 1
a527 2
		if (!rsa_blinding_invert(blinding, local_blinding, ret, br, ctx))
			goto err;
d530 1
a530 1
	j=BN_bn2bin(ret,p); /* j is only used with no-padding mode */
d556 5
a560 5
	if (ctx != NULL)
		{
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
		}
d573 1
a573 1
	BIGNUM *f,*ret;
d579 4
a582 11
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_MAX_MODULUS_BITS)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_MODULUS_TOO_LARGE);
		return -1;
		}

	if (BN_ucmp(rsa->n, rsa->e) <= 0)
		{
		RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
		return -1;
		}
a583 14
	/* for large moduli, enforce exponent limit */
	if (BN_num_bits(rsa->n) > OPENSSL_RSA_SMALL_MODULUS_BITS)
		{
		if (BN_num_bits(rsa->e) > OPENSSL_RSA_MAX_PUBEXP_BITS)
			{
			RSAerr(RSA_F_RSA_EAY_PUBLIC_DECRYPT, RSA_R_BAD_E_VALUE);
			return -1;
			}
		}
	
	if((ctx = BN_CTX_new()) == NULL) goto err;
	BN_CTX_start(ctx);
	f = BN_CTX_get(ctx);
	ret = BN_CTX_get(ctx);
d585 2
a586 2
	buf = OPENSSL_malloc(num);
	if(!f || !ret || !buf)
d600 1
a600 1
	if (BN_bin2bn(from,flen,f) == NULL) goto err;
d602 1
a602 1
	if (BN_ucmp(f, rsa->n) >= 0)
d608 8
a615 1
	MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);
d617 1
a617 1
	if (!rsa->meth->bn_mod_exp(ret,f,rsa->e,rsa->n,ctx,
d620 2
a621 2
	if ((padding == RSA_X931_PADDING) && ((ret->d[0] & 0xf) != 12))
		BN_sub(ret, rsa->n, ret);
d624 1
a624 1
	i=BN_bn2bin(ret,p);
a630 3
	case RSA_X931_PADDING:
		r=RSA_padding_check_X931(to,num,buf,i,num);
		break;
d642 3
a644 5
	if (ctx != NULL)
		{
		BN_CTX_end(ctx);
		BN_CTX_free(ctx);
		}
d653 1
a653 1
static int RSA_eay_mod_exp(BIGNUM *r0, const BIGNUM *I, RSA *rsa, BN_CTX *ctx)
d655 3
a657 3
	BIGNUM *r1,*m1,*vrfy;
	BIGNUM local_dmp1,local_dmq1,local_c,local_r1;
	BIGNUM *dmp1,*dmq1,*c,*pr1;
d659 1
d661 4
a664 4
	BN_CTX_start(ctx);
	r1 = BN_CTX_get(ctx);
	m1 = BN_CTX_get(ctx);
	vrfy = BN_CTX_get(ctx);
d666 1
a666 31
	{
		BIGNUM local_p, local_q;
		BIGNUM *p = NULL, *q = NULL;

		/* Make sure BN_mod_inverse in Montgomery intialization uses the
		 * BN_FLG_CONSTTIME flag (unless RSA_FLAG_NO_CONSTTIME is set)
		 */
		if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
			{
			BN_init(&local_p);
			p = &local_p;
			BN_with_flags(p, rsa->p, BN_FLG_CONSTTIME);

			BN_init(&local_q);
			q = &local_q;
			BN_with_flags(q, rsa->q, BN_FLG_CONSTTIME);
			}
		else
			{
			p = rsa->p;
			q = rsa->q;
			}

		MONT_HELPER(rsa->_method_mod_p, ctx, p, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
		MONT_HELPER(rsa->_method_mod_q, ctx, q, rsa->flags & RSA_FLAG_CACHE_PRIVATE, goto err);
	}

	MONT_HELPER(rsa->_method_mod_n, ctx, rsa->n, rsa->flags & RSA_FLAG_CACHE_PUBLIC, goto err);

	/* compute I mod q */
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
d668 6
a673 7
		c = &local_c;
		BN_with_flags(c, I, BN_FLG_CONSTTIME);
		if (!BN_mod(r1,c,rsa->q,ctx)) goto err;
		}
	else
		{
		if (!BN_mod(r1,I,rsa->q,ctx)) goto err;
d676 2
a677 2
	/* compute r1^dmq1 mod q */
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
d680 1
a680 1
		BN_with_flags(dmq1, rsa->dmq1, BN_FLG_CONSTTIME);
d684 1
a684 1
	if (!rsa->meth->bn_mod_exp(m1,r1,dmq1,rsa->q,ctx,
d687 2
a688 14
	/* compute I mod p */
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
		c = &local_c;
		BN_with_flags(c, I, BN_FLG_CONSTTIME);
		if (!BN_mod(r1,c,rsa->p,ctx)) goto err;
		}
	else
		{
		if (!BN_mod(r1,I,rsa->p,ctx)) goto err;
		}

	/* compute r1^dmp1 mod p */
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
d691 1
a691 1
		BN_with_flags(dmp1, rsa->dmp1, BN_FLG_CONSTTIME);
d695 1
a695 1
	if (!rsa->meth->bn_mod_exp(r0,r1,dmp1,rsa->p,ctx,
d698 1
a698 1
	if (!BN_sub(r0,r0,m1)) goto err;
d701 1
a701 1
	if (BN_is_negative(r0))
d704 2
a705 12
	if (!BN_mul(r1,r0,rsa->iqmp,ctx)) goto err;

	/* Turn BN_FLG_CONSTTIME flag on before division operation */
	if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
		{
		pr1 = &local_r1;
		BN_with_flags(pr1, r1, BN_FLG_CONSTTIME);
		}
	else
		pr1 = r1;
	if (!BN_mod(r0,pr1,rsa->p,ctx)) goto err;

d713 1
a713 1
	if (BN_is_negative(r0))
d715 2
a716 2
	if (!BN_mul(r1,r0,rsa->q,ctx)) goto err;
	if (!BN_add(r0,r1,m1)) goto err;
d720 1
a720 1
		if (!rsa->meth->bn_mod_exp(vrfy,r0,rsa->e,rsa->n,ctx,rsa->_method_mod_n)) goto err;
d725 5
a729 5
		if (!BN_sub(vrfy, vrfy, I)) goto err;
		if (!BN_mod(vrfy, vrfy, rsa->n, ctx)) goto err;
		if (BN_is_negative(vrfy))
			if (!BN_add(vrfy, vrfy, rsa->n)) goto err;
		if (!BN_is_zero(vrfy))
d738 1
a738 1
			if (!(rsa->flags & RSA_FLAG_NO_CONSTTIME))
d741 1
a741 1
				BN_with_flags(d, rsa->d, BN_FLG_CONSTTIME);
d745 1
a745 2
			if (!rsa->meth->bn_mod_exp(r0,I,d,rsa->n,ctx,
						   rsa->_method_mod_n)) goto err;
d750 4
a753 1
	BN_CTX_end(ctx);
@


1.1.1.8
log
@import openssl-0.9.8j
@
text
@d118 1
a118 1
#if !defined(RSA_NULL) && !defined(OPENSSL_FIPS)
d153 10
d236 1
a236 3
	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;
d441 1
a441 3
		if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
			if(!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
				goto err;
d562 1
a562 3
		if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
				goto err;
d672 1
a672 3
	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;
d750 2
a751 7
		if (rsa->flags & RSA_FLAG_CACHE_PRIVATE)
			{
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_p, CRYPTO_LOCK_RSA, p, ctx))
				goto err;
			if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_q, CRYPTO_LOCK_RSA, q, ctx))
				goto err;
			}
d754 1
a754 3
	if (rsa->flags & RSA_FLAG_CACHE_PUBLIC)
		if (!BN_MONT_CTX_set_locked(&rsa->_method_mod_n, CRYPTO_LOCK_RSA, rsa->n, ctx))
			goto err;
@


1.1.1.9
log
@import OpenSSL-1.0.0a
@
text
@d118 1
a118 1
#ifndef RSA_NULL
a258 1
	CRYPTO_THREADID cur;
d276 1
a276 2
	CRYPTO_THREADID_current(&cur);
	if (!CRYPTO_THREADID_cmp(&cur, BN_BLINDING_thread_id(ret)))
@


1.1.1.10
log
@import OpenSSL 1.0.0e
@
text
@d678 1
a678 1
		if (!BN_sub(ret, rsa->n, ret)) goto err;
@


1.1.1.11
log
@OpenSSL 1.0.0f: import upstream source
@
text
@d317 4
a320 6
static int rsa_blinding_convert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
	BN_CTX *ctx)
	{
	if (unblind == NULL)
		/* Local blinding: store the unblinding factor
		 * in BN_BLINDING. */
d324 15
a338 2
		/* Shared blinding: store the unblinding factor
		 * outside BN_BLINDING. */
d341 1
a341 1
		ret = BN_BLINDING_convert_ex(f, unblind, b, ctx);
d345 1
a345 14
	}

static int rsa_blinding_invert(BN_BLINDING *b, BIGNUM *f, BIGNUM *unblind,
	BN_CTX *ctx)
	{
	/* For local blinding, unblind is set to NULL, and BN_BLINDING_invert_ex
	 * will use the unblinding factor stored in BN_BLINDING.
	 * If BN_BLINDING is shared between threads, unblind must be non-null:
	 * BN_BLINDING_invert_ex will then use the local unblinding factor,
	 * and will only read the modulus from BN_BLINDING.
	 * In both cases it's safe to access the blinding without a lock.
	 */
	return BN_BLINDING_invert_ex(f, unblind, b, ctx);
	}
d351 1
a351 1
	BIGNUM *f, *ret, *res;
a355 4
	/* Used only if the blinding structure is shared. A non-NULL unblind
	 * instructs rsa_blinding_convert() and rsa_blinding_invert() to store
	 * the unblinding factor outside the blinding structure. */
	BIGNUM *unblind = NULL;
d361 1
d409 1
a409 4
		{
		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_ENCRYPT,ERR_R_MALLOC_FAILURE);
a410 4
			}
		if (!rsa_blinding_convert(blinding, f, unblind, ctx))
			goto err;
		}
d444 1
a444 1
		if (!rsa_blinding_invert(blinding, ret, unblind, ctx))
d483 1
a483 1
	BIGNUM *f, *ret;
a488 4
	/* Used only if the blinding structure is shared. A non-NULL unblind
	 * instructs rsa_blinding_convert() and rsa_blinding_invert() to store
	 * the unblinding factor outside the blinding structure. */
	BIGNUM *unblind = NULL;
d494 1
d532 1
a532 4
		{
		if (!local_blinding && ((unblind = BN_CTX_get(ctx)) == NULL))
			{
			RSAerr(RSA_F_RSA_EAY_PRIVATE_DECRYPT,ERR_R_MALLOC_FAILURE);
a533 4
			}
		if (!rsa_blinding_convert(blinding, f, unblind, ctx))
			goto err;
		}
d567 1
a567 1
		if (!rsa_blinding_invert(blinding, ret, unblind, ctx))
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@d850 1
a850 1
	 * adding 'p' if r0 is negative above to leave the result still
d854 2
a855 2
	 * they ensure p > q [steve]
	 */
@


