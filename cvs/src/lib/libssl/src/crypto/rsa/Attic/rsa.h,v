head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.2
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	butholakala:1.17
	openssl_1_0_1_g:1.1.1.12
	OPENBSD_5_5:1.16.0.8
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.4
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.2
	OPENBSD_5_3_BASE:1.16
	openssl_1_0_1_c:1.1.1.11
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.8
	openssl_1_0_0_f:1.1.1.10
	openssl_1_0_0_e:1.1.1.10
	OPENBSD_5_0:1.15.0.4
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	openssh_1_0_0_a:1.1.1.10
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	openssl_0_9_8_k:1.1.1.9
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	openssl_0_9_8_j:1.1.1.9
	openssl_0_9_8_h:1.1.1.8
	pre_openssl_0_9_8h:1.11
	OPENBSD_4_4:1.11.0.8
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	openssl_0_9_7j:1.1.1.7
	openssl:1.1.1
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENSSL_0_9_7G:1.1.1.6
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	OPENSSL_0_9_7D:1.1.1.5
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENSSL_0_9_7C:1.1.1.5
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	OPENSSL_0_9_7B:1.1.1.4
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENSSL_0_9_7_STABLE_SNAP_20020911:1.1.1.3
	OPENSSL_0_9_7_BETA3:1.1.1.3
	OPENSSL_0_9_7_BETA1:1.1.1.2
	OPENSSL:1.1.1
	OPENBSD_3_1:1.4.0.6
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.1.1.1.0.4
	OPENBSD_2_5_BASE:1.1.1.1
	OPENBSD_2_4:1.1.1.1.0.2
	OPENBSD_2_4_BASE:1.1.1.1
	SSLeay_0_9_0b:1.1.1.1
	SSLeay:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.09.03.11.33.39;	author beck;	state dead;
branches;
next	1.28;
commitid	HnbXxsegngek41U2;

1.28
date	2016.06.30.02.02.06;	author bcook;	state Exp;
branches;
next	1.27;
commitid	NoRqiDVUjRmOOT9v;

1.27
date	2015.02.14.15.10.39;	author miod;	state Exp;
branches;
next	1.26;
commitid	k2BJ637oY92Wf8fy;

1.26
date	2014.07.12.16.03.37;	author miod;	state Exp;
branches;
next	1.25;
commitid	G74O1dmRukKsW7IJ;

1.25
date	2014.07.10.22.45.57;	author jsing;	state Exp;
branches;
next	1.24;
commitid	nzndm3zqPmFurSaK;

1.24
date	2014.07.10.12.08.22;	author jsing;	state Exp;
branches;
next	1.23;
commitid	LBiDJ9R8mVapAzcc;

1.23
date	2014.07.10.11.04.49;	author jsing;	state Exp;
branches;
next	1.22;
commitid	8lQAGWqwA45xFka9;

1.22
date	2014.07.09.20.05.54;	author jsing;	state Exp;
branches;
next	1.21;
commitid	KVhxRPsEWficjUjW;

1.21
date	2014.07.09.19.51.31;	author jsing;	state Exp;
branches;
next	1.20;
commitid	FhFtAmFpjHlG4gWT;

1.20
date	2014.07.09.08.55.32;	author miod;	state Exp;
branches;
next	1.19;
commitid	kK6vkkSmKSSgbFDw;

1.19
date	2014.06.12.15.49.30;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	mJUVYpkFBZ0Zv2bG;

1.18
date	2014.05.29.20.21.23;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.13;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.58.57;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.09.12.15.51;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2009.01.05.21.36.38;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.06.12.17.51;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2006.10.04.07.10.32;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.27.05.07.02;	author djm;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2005.04.29.05.39.26;	author djm;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2003.11.11.22.15.19;	author markus;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.12.02.18.38;	author markus;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.10.16.31.56;	author markus;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.15.02.29.16;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.15.02.58.08;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.11.38;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.36.42;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.12.52;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.12.52;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.50.53;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.05.22.41.17;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.05.11.21.35.46;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.11.11.21.17.23;	author markus;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.04.29.05.37.16;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.06.27.05.05.35;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.06.12.15.46;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.01.09.12.13.59;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.10.01.22.54.10;	author djm;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2012.10.13.21.23.43;	author djm;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.04.13.15.16.34;	author miod;	state Exp;
branches;
next	;

1.9.2.1
date	2006.10.05.18.42.22;	author brad;	state Exp;
branches;
next	;

1.9.4.1
date	2006.10.05.17.36.24;	author brad;	state Exp;
branches;
next	;

1.10.2.1
date	2006.11.02.19.56.23;	author brad;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Remove the libssl/src directory
@
text
@/* $OpenBSD: rsa.h,v 1.28 2016/06/30 02:02:06 bcook Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

#ifndef HEADER_RSA_H
#define HEADER_RSA_H

#include <openssl/opensslconf.h>

#include <openssl/asn1.h>

#ifndef OPENSSL_NO_BIO
#include <openssl/bio.h>
#endif
#include <openssl/crypto.h>
#include <openssl/ossl_typ.h>
#ifndef OPENSSL_NO_DEPRECATED
#include <openssl/bn.h>
#endif

#ifdef OPENSSL_NO_RSA
#error RSA is disabled.
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Declared already in ossl_typ.h */
/* typedef struct rsa_st RSA; */
/* typedef struct rsa_meth_st RSA_METHOD; */

struct rsa_meth_st {
	const char *name;
	int (*rsa_pub_enc)(int flen, const unsigned char *from,
	    unsigned char *to, RSA *rsa, int padding);
	int (*rsa_pub_dec)(int flen, const unsigned char *from,
	    unsigned char *to, RSA *rsa, int padding);
	int (*rsa_priv_enc)(int flen, const unsigned char *from,
	    unsigned char *to, RSA *rsa, int padding);
	int (*rsa_priv_dec)(int flen, const unsigned char *from,
	    unsigned char *to, RSA *rsa, int padding);
	int (*rsa_mod_exp)(BIGNUM *r0, const BIGNUM *I, RSA *rsa,
	    BN_CTX *ctx); /* Can be null */
	int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
	    const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx); /* Can be null */
	int (*init)(RSA *rsa);		/* called at new */
	int (*finish)(RSA *rsa);	/* called at free */
	int flags;			/* RSA_METHOD_FLAG_* things */
	char *app_data;			/* may be needed! */
/* New sign and verify functions: some libraries don't allow arbitrary data
 * to be signed/verified: this allows them to be used. Note: for this to work
 * the RSA_public_decrypt() and RSA_private_encrypt() should *NOT* be used
 * RSA_sign(), RSA_verify() should be used instead. Note: for backwards
 * compatibility this functionality is only enabled if the RSA_FLAG_SIGN_VER
 * option is set in 'flags'.
 */
	int (*rsa_sign)(int type, const unsigned char *m, unsigned int m_length,
	    unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
	int (*rsa_verify)(int dtype, const unsigned char *m,
	    unsigned int m_length, const unsigned char *sigbuf,
	    unsigned int siglen, const RSA *rsa);
/* If this callback is NULL, the builtin software RSA key-gen will be used. This
 * is for behavioural compatibility whilst the code gets rewired, but one day
 * it would be nice to assume there are no such things as "builtin software"
 * implementations. */
	int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
};

struct rsa_st {
	/* The first parameter is used to pickup errors where
	 * this is passed instead of aEVP_PKEY, it is set to 0 */
	int pad;
	long version;
	const RSA_METHOD *meth;
	/* functional reference if 'meth' is ENGINE-provided */
	ENGINE *engine;
	BIGNUM *n;
	BIGNUM *e;
	BIGNUM *d;
	BIGNUM *p;
	BIGNUM *q;
	BIGNUM *dmp1;
	BIGNUM *dmq1;
	BIGNUM *iqmp;
	/* be careful using this if the RSA structure is shared */
	CRYPTO_EX_DATA ex_data;
	int references;
	int flags;

	/* Used to cache montgomery values */
	BN_MONT_CTX *_method_mod_n;
	BN_MONT_CTX *_method_mod_p;
	BN_MONT_CTX *_method_mod_q;

	/* all BIGNUM values are actually in the following data, if it is not
	 * NULL */
	BN_BLINDING *blinding;
	BN_BLINDING *mt_blinding;
};

#ifndef OPENSSL_RSA_MAX_MODULUS_BITS
# define OPENSSL_RSA_MAX_MODULUS_BITS	16384
#endif

#ifndef OPENSSL_RSA_SMALL_MODULUS_BITS
# define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
#endif
#ifndef OPENSSL_RSA_MAX_PUBEXP_BITS
# define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "large" modulus only */
#endif

#define RSA_3	0x3L
#define RSA_F4	0x10001L

/* Don't check pub/private match. */
#define RSA_METHOD_FLAG_NO_CHECK	0x0001

#define RSA_FLAG_CACHE_PUBLIC		0x0002
#define RSA_FLAG_CACHE_PRIVATE		0x0004
#define RSA_FLAG_BLINDING		0x0008
#define RSA_FLAG_THREAD_SAFE		0x0010

/*
 * This flag means the private key operations will be handled by rsa_mod_exp
 * and that they do not depend on the private key components being present:
 * for example a key stored in external hardware. Without this flag bn_mod_exp
 * gets called when private key components are absent.
 */
#define RSA_FLAG_EXT_PKEY		0x0020

/*
 * This flag in the RSA_METHOD enables the new rsa_sign, rsa_verify functions.
 */
#define RSA_FLAG_SIGN_VER		0x0040

/*
 * The built-in RSA implementation uses blinding by default, but other engines
 * might not need it.
 */
#define RSA_FLAG_NO_BLINDING		0x0080

#define EVP_PKEY_CTX_set_rsa_padding(ctx, pad) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, EVP_PKEY_CTRL_RSA_PADDING, \
				pad, NULL)

#define EVP_PKEY_CTX_get_rsa_padding(ctx, ppad) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, \
				EVP_PKEY_CTRL_GET_RSA_PADDING, 0, ppad)

#define EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, len) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, \
				(EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
				EVP_PKEY_CTRL_RSA_PSS_SALTLEN, \
				len, NULL)

#define EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx, plen) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, \
				(EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
				EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN, \
				0, plen)

#define EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN, \
				EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)

#define EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN, \
				EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)

#define	 EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md)	\
		EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_SIG,  \
				EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)md)

#define	 EVP_PKEY_CTX_get_rsa_mgf1_md(ctx, pmd)	\
		EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_SIG,  \
				EVP_PKEY_CTRL_GET_RSA_MGF1_MD, 0, (void *)pmd)

#define EVP_PKEY_CTRL_RSA_PADDING	(EVP_PKEY_ALG_CTRL + 1)
#define EVP_PKEY_CTRL_RSA_PSS_SALTLEN	(EVP_PKEY_ALG_CTRL + 2)

#define EVP_PKEY_CTRL_RSA_KEYGEN_BITS	(EVP_PKEY_ALG_CTRL + 3)
#define EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP	(EVP_PKEY_ALG_CTRL + 4)
#define EVP_PKEY_CTRL_RSA_MGF1_MD	(EVP_PKEY_ALG_CTRL + 5)

#define EVP_PKEY_CTRL_GET_RSA_PADDING		(EVP_PKEY_ALG_CTRL + 6)
#define EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN	(EVP_PKEY_ALG_CTRL + 7)
#define EVP_PKEY_CTRL_GET_RSA_MGF1_MD		(EVP_PKEY_ALG_CTRL + 8)

#define RSA_PKCS1_PADDING	1
#define RSA_SSLV23_PADDING	2
#define RSA_NO_PADDING		3
#define RSA_PKCS1_OAEP_PADDING	4
#define RSA_X931_PADDING	5
/* EVP_PKEY_ only */
#define RSA_PKCS1_PSS_PADDING	6

#define RSA_PKCS1_PADDING_SIZE	11

#define RSA_set_app_data(s,arg)         RSA_set_ex_data(s,0,arg)
#define RSA_get_app_data(s)             RSA_get_ex_data(s,0)

RSA *RSA_new(void);
RSA *RSA_new_method(ENGINE *engine);
int RSA_size(const RSA *rsa);

/* Deprecated version */
#ifndef OPENSSL_NO_DEPRECATED
RSA *RSA_generate_key(int bits, unsigned long e,
    void (*callback)(int, int, void *), void *cb_arg);
#endif /* !defined(OPENSSL_NO_DEPRECATED) */

/* New version */
int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);

int RSA_check_key(const RSA *);
/* next 4 return -1 on error */
int RSA_public_encrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
int RSA_private_encrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
int RSA_public_decrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
int RSA_private_decrypt(int flen, const unsigned char *from,
    unsigned char *to, RSA *rsa, int padding);
void RSA_free(RSA *r);
/* "up" the RSA object's reference count */
int RSA_up_ref(RSA *r);

int RSA_flags(const RSA *r);

void RSA_set_default_method(const RSA_METHOD *meth);
const RSA_METHOD *RSA_get_default_method(void);
const RSA_METHOD *RSA_get_method(const RSA *rsa);
int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);

/* these are the actual SSLeay RSA functions */
const RSA_METHOD *RSA_PKCS1_SSLeay(void);

const RSA_METHOD *RSA_null_method(void);

DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPublicKey)
DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPrivateKey)

typedef struct rsa_pss_params_st {
	X509_ALGOR *hashAlgorithm;
	X509_ALGOR *maskGenAlgorithm;
	ASN1_INTEGER *saltLength;
	ASN1_INTEGER *trailerField;
} RSA_PSS_PARAMS;

DECLARE_ASN1_FUNCTIONS(RSA_PSS_PARAMS)

int RSA_print_fp(FILE *fp, const RSA *r, int offset);

#ifndef OPENSSL_NO_BIO
int RSA_print(BIO *bp, const RSA *r, int offset);
#endif

#ifndef OPENSSL_NO_RC4
int i2d_RSA_NET(const RSA *a, unsigned char **pp,
    int (*cb)(char *buf, int len, const char *prompt, int verify), int sgckey);
RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,
    int (*cb)(char *buf, int len, const char *prompt, int verify), int sgckey);

int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,
    int (*cb)(char *buf, int len, const char *prompt, int verify));
RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,
    int (*cb)(char *buf, int len, const char *prompt, int verify));
#endif

/* The following 2 functions sign and verify a X509_SIG ASN1 object
 * inside PKCS#1 padded RSA encryption */
int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
    unsigned char *sigret, unsigned int *siglen, RSA *rsa);
int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
    const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);

/* The following 2 function sign and verify a ASN1_OCTET_STRING
 * object inside PKCS#1 padded RSA encryption */
int RSA_sign_ASN1_OCTET_STRING(int type, const unsigned char *m,
    unsigned int m_length, unsigned char *sigret, unsigned int *siglen,
    RSA *rsa);
int RSA_verify_ASN1_OCTET_STRING(int type, const unsigned char *m,
    unsigned int m_length, unsigned char *sigbuf, unsigned int siglen,
    RSA *rsa);

int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);
void RSA_blinding_off(RSA *rsa);
BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);

int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
    const unsigned char *f, int fl);
int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
    const unsigned char *f, int fl, int rsa_len);
int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
    const unsigned char *f, int fl);
int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
    const unsigned char *f, int fl, int rsa_len);
int PKCS1_MGF1(unsigned char *mask, long len,
    const unsigned char *seed, long seedlen, const EVP_MD *dgst);
int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
    const unsigned char *f, int fl,
    const unsigned char *p, int pl);
int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
    const unsigned char *f, int fl, int rsa_len,
    const unsigned char *p, int pl);
int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
    const unsigned char *f, int fl);
int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
    const unsigned char *f, int fl, int rsa_len);
int RSA_padding_add_none(unsigned char *to, int tlen,
    const unsigned char *f, int fl);
int RSA_padding_check_none(unsigned char *to, int tlen,
    const unsigned char *f, int fl, int rsa_len);
int RSA_padding_add_X931(unsigned char *to, int tlen,
    const unsigned char *f, int fl);
int RSA_padding_check_X931(unsigned char *to, int tlen,
    const unsigned char *f, int fl, int rsa_len);
int RSA_X931_hash_id(int nid);

int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
    const EVP_MD *Hash, const unsigned char *EM, int sLen);
int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
    const unsigned char *mHash, const EVP_MD *Hash, int sLen);

int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
    const EVP_MD *Hash, const EVP_MD *mgf1Hash, const unsigned char *EM,
    int sLen);

int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
    const unsigned char *mHash, const EVP_MD *Hash, const EVP_MD *mgf1Hash,
    int sLen);

int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
    CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int RSA_set_ex_data(RSA *r, int idx, void *arg);
void *RSA_get_ex_data(const RSA *r, int idx);

RSA *RSAPublicKey_dup(RSA *rsa);
RSA *RSAPrivateKey_dup(RSA *rsa);

/* If this flag is set the RSA method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its responsibility
 * to ensure the result is compliant.
 */

#define RSA_FLAG_FIPS_METHOD			0x0400

/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */

#define RSA_FLAG_NON_FIPS_ALLOW			0x0400
/* Application has decided PRNG is good enough to generate a key: don't
 * check.
 */
#define RSA_FLAG_CHECKED			0x0800

/* BEGIN ERROR CODES */
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_RSA_strings(void);

/* Error codes for the RSA functions. */

/* Function codes. */
#define RSA_F_CHECK_PADDING_MD				 140
#define RSA_F_DO_RSA_PRINT				 146
#define RSA_F_INT_RSA_VERIFY				 145
#define RSA_F_MEMORY_LOCK				 100
#define RSA_F_OLD_RSA_PRIV_DECODE			 147
#define RSA_F_PKEY_RSA_CTRL				 143
#define RSA_F_PKEY_RSA_CTRL_STR				 144
#define RSA_F_PKEY_RSA_SIGN				 142
#define RSA_F_PKEY_RSA_VERIFY				 154
#define RSA_F_PKEY_RSA_VERIFYRECOVER			 141
#define RSA_F_RSA_BUILTIN_KEYGEN			 129
#define RSA_F_RSA_CHECK_KEY				 123
#define RSA_F_RSA_EAY_MOD_EXP				 157
#define RSA_F_RSA_EAY_PRIVATE_DECRYPT			 101
#define RSA_F_RSA_EAY_PRIVATE_ENCRYPT			 102
#define RSA_F_RSA_EAY_PUBLIC_DECRYPT			 103
#define RSA_F_RSA_EAY_PUBLIC_ENCRYPT			 104
#define RSA_F_RSA_GENERATE_KEY				 105
#define RSA_F_RSA_GENERATE_KEY_EX			 155
#define RSA_F_RSA_ITEM_VERIFY				 156
#define RSA_F_RSA_MEMORY_LOCK				 130
#define RSA_F_RSA_NEW_METHOD				 106
#define RSA_F_RSA_NULL					 124
#define RSA_F_RSA_NULL_MOD_EXP				 131
#define RSA_F_RSA_NULL_PRIVATE_DECRYPT			 132
#define RSA_F_RSA_NULL_PRIVATE_ENCRYPT			 133
#define RSA_F_RSA_NULL_PUBLIC_DECRYPT			 134
#define RSA_F_RSA_NULL_PUBLIC_ENCRYPT			 135
#define RSA_F_RSA_PADDING_ADD_NONE			 107
#define RSA_F_RSA_PADDING_ADD_PKCS1_OAEP		 121
#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS			 125
#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1		 148
#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1		 108
#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2		 109
#define RSA_F_RSA_PADDING_ADD_SSLV23			 110
#define RSA_F_RSA_PADDING_ADD_X931			 127
#define RSA_F_RSA_PADDING_CHECK_NONE			 111
#define RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP		 122
#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1		 112
#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2		 113
#define RSA_F_RSA_PADDING_CHECK_SSLV23			 114
#define RSA_F_RSA_PADDING_CHECK_X931			 128
#define RSA_F_RSA_PRINT					 115
#define RSA_F_RSA_PRINT_FP				 116
#define RSA_F_RSA_PRIVATE_DECRYPT			 150
#define RSA_F_RSA_PRIVATE_ENCRYPT			 151
#define RSA_F_RSA_PRIV_DECODE				 137
#define RSA_F_RSA_PRIV_ENCODE				 138
#define RSA_F_RSA_PUBLIC_DECRYPT			 152
#define RSA_F_RSA_PUBLIC_ENCRYPT			 153
#define RSA_F_RSA_PUB_DECODE				 139
#define RSA_F_RSA_SETUP_BLINDING			 136
#define RSA_F_RSA_SIGN					 117
#define RSA_F_RSA_SIGN_ASN1_OCTET_STRING		 118
#define RSA_F_RSA_VERIFY				 119
#define RSA_F_RSA_VERIFY_ASN1_OCTET_STRING		 120
#define RSA_F_RSA_VERIFY_PKCS1_PSS			 126
#define RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1			 149

/* Reason codes. */
#define RSA_R_ALGORITHM_MISMATCH			 100
#define RSA_R_BAD_E_VALUE				 101
#define RSA_R_BAD_FIXED_HEADER_DECRYPT			 102
#define RSA_R_BAD_PAD_BYTE_COUNT			 103
#define RSA_R_BAD_SIGNATURE				 104
#define RSA_R_BLOCK_TYPE_IS_NOT_01			 106
#define RSA_R_BLOCK_TYPE_IS_NOT_02			 107
#define RSA_R_DATA_GREATER_THAN_MOD_LEN			 108
#define RSA_R_DATA_TOO_LARGE				 109
#define RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE		 110
#define RSA_R_DATA_TOO_LARGE_FOR_MODULUS		 132
#define RSA_R_DATA_TOO_SMALL				 111
#define RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE		 122
#define RSA_R_DIGEST_TOO_BIG_FOR_RSA_KEY		 112
#define RSA_R_DMP1_NOT_CONGRUENT_TO_D			 124
#define RSA_R_DMQ1_NOT_CONGRUENT_TO_D			 125
#define RSA_R_D_E_NOT_CONGRUENT_TO_1			 123
#define RSA_R_FIRST_OCTET_INVALID			 133
#define RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE	 144
#define RSA_R_INVALID_DIGEST_LENGTH			 143
#define RSA_R_INVALID_HEADER				 137
#define RSA_R_INVALID_KEYBITS				 145
#define RSA_R_INVALID_MESSAGE_LENGTH			 131
#define RSA_R_INVALID_MGF1_MD				 156
#define RSA_R_INVALID_PADDING				 138
#define RSA_R_INVALID_PADDING_MODE			 141
#define RSA_R_INVALID_PSS_PARAMETERS			 149
#define RSA_R_INVALID_PSS_SALTLEN			 146
#define RSA_R_INVALID_SALT_LENGTH			 150
#define RSA_R_INVALID_TRAILER				 139
#define RSA_R_INVALID_X931_DIGEST			 142
#define RSA_R_IQMP_NOT_INVERSE_OF_Q			 126
#define RSA_R_KEY_SIZE_TOO_SMALL			 120
#define RSA_R_LAST_OCTET_INVALID			 134
#define RSA_R_MODULUS_TOO_LARGE				 105
#define RSA_R_NON_FIPS_RSA_METHOD			 157
#define RSA_R_NO_PUBLIC_EXPONENT			 140
#define RSA_R_NULL_BEFORE_BLOCK_MISSING			 113
#define RSA_R_N_DOES_NOT_EQUAL_P_Q			 127
#define RSA_R_OAEP_DECODING_ERROR			 121
#define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	 158
#define RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 148
#define RSA_R_PADDING_CHECK_FAILED			 114
#define RSA_R_P_NOT_PRIME				 128
#define RSA_R_Q_NOT_PRIME				 129
#define RSA_R_RSA_OPERATIONS_NOT_SUPPORTED		 130
#define RSA_R_SLEN_CHECK_FAILED				 136
#define RSA_R_SLEN_RECOVERY_FAILED			 135
#define RSA_R_SSLV3_ROLLBACK_ATTACK			 115
#define RSA_R_THE_ASN1_OBJECT_IDENTIFIER_IS_NOT_KNOWN_FOR_THIS_MD 116
#define RSA_R_UNKNOWN_ALGORITHM_TYPE			 117
#define RSA_R_UNKNOWN_MASK_DIGEST			 151
#define RSA_R_UNKNOWN_PADDING_TYPE			 118
#define RSA_R_UNKNOWN_PSS_DIGEST			 152
#define RSA_R_UNSUPPORTED_MASK_ALGORITHM		 153
#define RSA_R_UNSUPPORTED_MASK_PARAMETER		 154
#define RSA_R_UNSUPPORTED_SIGNATURE_TYPE		 155
#define RSA_R_VALUE_MISSING				 147
#define RSA_R_WRONG_SIGNATURE_LENGTH			 119

#ifdef  __cplusplus
}
#endif
#endif
@


1.28
log
@Remove flags for disabling constant-time operations.

This removes support for DSA_FLAG_NO_EXP_CONSTTIME, DH_FLAG_NO_EXP_CONSTTIME,
and RSA_FLAG_NO_CONSTTIME flags, making all of these operations unconditionally
constant-time.

Based on the original patch by CÃ©sar Pereid.  ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.27 2015/02/14 15:10:39 miod Exp $ */
@


1.27
log
@Check for allocation error in RSA_eay_mod_exp(). Coverity CID 25217.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.26 2014/07/12 16:03:37 miod Exp $ */
a195 10

/*
 * The built-in RSA implementation uses constant time operations by default
 * in private key operations, e.g., constant time modular exponentiation,
 * modular inverse without leaking branches, division without leaking branches.
 * This flag disables these constant time operations and results in faster RSA
 * private key operations.
 */
#define RSA_FLAG_NO_CONSTTIME		0x0100

@


1.26
log
@if (x) FOO_free(x) -> FOO_free(x).
Improves readability, keeps the code smaller so that it is warmer in your
cache.

review & ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.25 2014/07/10 22:45:57 jsing Exp $ */
d447 1
@


1.25
log
@Explicitly include <openssl/opensslconf.h> in every file that references
an OPENSSL_NO_* define. This avoids relying on something else pulling it
in for us, plus it fixes several cases where the #ifndef OPENSSL_NO_XYZ is
never going to do anything, since OPENSSL_NO_XYZ will never defined, due
to the fact that opensslconf.h has not been included.

This also includes some miscellaneous sorting/tidying of headers.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.24 2014/07/10 12:08:22 jsing Exp $ */
d290 1
a290 1
void RSA_free (RSA *r);
@


1.24
log
@Tweak some comments. We do not really need to know that "New!" flags were
added 10+ years ago (they're kinda somewhat stale by now...)
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.22 2014/07/09 20:05:54 jsing Exp $ */
d61 2
@


1.23
log
@Remove RSA_FLAG_NO_EXP_CONSTTIME, which was deprecated 12+ years ago.

sthen@@ confirmed that no ports are referencing it.

ok miod@@.
@
text
@d190 2
a191 3
 * New with 0.9.6j and 0.9.7b; the built-in RSA implementation now uses
 * blinding by default (ignoring RSA_FLAG_BLINDING), but other engines might
 * not need it.
d196 5
a200 5
 * New with 0.9.8f; the built-in RSA implementation now uses constant time
 * operations by default in private key operations, e.g., constant time modular
 * exponentiation, modular inverse without leaking branches, division without
 * leaking branches. This flag disables these constant time operations and
 * results in faster RSA private key operations.
@


1.22
log
@Make comments readable.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.21 2014/07/09 19:51:31 jsing Exp $ */
a203 12

#ifndef OPENSSL_NO_DEPRECATED

/* Deprecated name for the flag. */
/*
 * New with 0.9.7h; the built-in RSA implementation now uses constant time
 * modular exponentiation for secret exponents by default. This flag causes
 * the faster variable sliding window method to be used for all exponents.
 */
#define RSA_FLAG_NO_EXP_CONSTTIME RSA_FLAG_NO_CONSTTIME

#endif
@


1.21
log
@KNF.
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.20 2014/07/09 08:55:32 miod Exp $ */
d168 2
a169 1
#define RSA_METHOD_FLAG_NO_CHECK	0x0001 /* don't check pub/private match */
d175 3
a177 1
/* This flag means the private key operations will be handled by rsa_mod_exp
d184 2
a185 1
/* This flag in the RSA_METHOD enables the new rsa_sign, rsa_verify functions.
d189 16
a204 15
#define RSA_FLAG_NO_BLINDING		0x0080 /* new with 0.9.6j and 0.9.7b; the built-in
                                                * RSA implementation now uses blinding by
                                                * default (ignoring RSA_FLAG_BLINDING),
                                                * but other engines might not need it
                                                */
#define RSA_FLAG_NO_CONSTTIME		0x0100 /* new with 0.9.8f; the built-in RSA
						* implementation now uses constant time
						* operations by default in private key operations,
						* e.g., constant time modular exponentiation,
                                                * modular inverse without leaking branches,
                                                * division without leaking branches. This
                                                * flag disables these constant time
                                                * operations and results in faster RSA
                                                * private key operations.
                                                */
d206 9
a214 8
#define RSA_FLAG_NO_EXP_CONSTTIME RSA_FLAG_NO_CONSTTIME /* deprecated name for the flag*/
                                                /* new with 0.9.7h; the built-in RSA
                                                * implementation now uses constant time
                                                * modular exponentiation for secret exponents
                                                * by default. This flag causes the
                                                * faster variable sliding window method to
                                                * be used for all exponents.
                                                */
@


1.20
log
@Remove RSA_memory_lock(). This undocumented function sort-of serializes your
RSA components to memory and clears them, but there is no unserializing
function, so its usefulness is close to zero.

A grep through the ports tree sources show that it is only present in ports
embedding their own openssl copy, and never used otherwise.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: rsa.h,v 1.19 2014/06/12 15:49:30 deraadt Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d85 1
a85 2
struct rsa_meth_st
	{
d87 10
a96 13
	int (*rsa_pub_enc)(int flen,const unsigned char *from,
			   unsigned char *to,
			   RSA *rsa,int padding);
	int (*rsa_pub_dec)(int flen,const unsigned char *from,
			   unsigned char *to,
			   RSA *rsa,int padding);
	int (*rsa_priv_enc)(int flen,const unsigned char *from,
			    unsigned char *to,
			    RSA *rsa,int padding);
	int (*rsa_priv_dec)(int flen,const unsigned char *from,
			    unsigned char *to,
			    RSA *rsa,int padding);
	int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa,BN_CTX *ctx); /* Can be null */
d98 1
a98 2
			  const BIGNUM *m, BN_CTX *ctx,
			  BN_MONT_CTX *m_ctx); /* Can be null */
d110 5
a114 7
	int (*rsa_sign)(int type,
		const unsigned char *m, unsigned int m_length,
		unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
	int (*rsa_verify)(int dtype,
		const unsigned char *m, unsigned int m_length,
		const unsigned char *sigbuf, unsigned int siglen,
								const RSA *rsa);
d120 1
a120 1
	};
d122 1
a122 2
struct rsa_st
	{
d152 1
a152 1
	};
d193 5
a197 5
						* e.g., constant time modular exponentiation, 
                                                * modular inverse without leaking branches, 
                                                * division without leaking branches. This 
                                                * flag disables these constant time 
                                                * operations and results in faster RSA 
d199 1
a199 1
                                                */ 
d272 3
a274 3
RSA *	RSA_new(void);
RSA *	RSA_new_method(ENGINE *engine);
int	RSA_size(const RSA *rsa);
d278 2
a279 2
RSA *	RSA_generate_key(int bits, unsigned long e,void
		(*callback)(int,int,void *),void *cb_arg);
d283 1
a283 1
int	RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
d285 11
a295 11
int	RSA_check_key(const RSA *);
	/* next 4 return -1 on error */
int	RSA_public_encrypt(int flen, const unsigned char *from,
		unsigned char *to, RSA *rsa,int padding);
int	RSA_private_encrypt(int flen, const unsigned char *from,
		unsigned char *to, RSA *rsa,int padding);
int	RSA_public_decrypt(int flen, const unsigned char *from, 
		unsigned char *to, RSA *rsa,int padding);
int	RSA_private_decrypt(int flen, const unsigned char *from, 
		unsigned char *to, RSA *rsa,int padding);
void	RSA_free (RSA *r);
d297 1
a297 1
int	RSA_up_ref(RSA *r);
d299 1
a299 1
int	RSA_flags(const RSA *r);
d314 1
a314 2
typedef struct rsa_pss_params_st
	{
d319 1
a319 1
	} RSA_PSS_PARAMS;
d323 1
a323 1
int	RSA_print_fp(FILE *fp, const RSA *r,int offset);
d326 1
a326 1
int	RSA_print(BIO *bp, const RSA *r,int offset);
d331 1
a331 2
		int (*cb)(char *buf, int len, const char *prompt, int verify),
		int sgckey);
d333 1
a333 2
		 int (*cb)(char *buf, int len, const char *prompt, int verify),
		 int sgckey);
d336 1
a336 2
		     int (*cb)(char *buf, int len, const char *prompt,
			       int verify));
d338 1
a338 2
		      int (*cb)(char *buf, int len, const char *prompt,
				int verify));
d344 1
a344 1
	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
d346 1
a346 1
	const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
d350 6
a355 6
int RSA_sign_ASN1_OCTET_STRING(int type,
	const unsigned char *m, unsigned int m_length,
	unsigned char *sigret, unsigned int *siglen, RSA *rsa);
int RSA_verify_ASN1_OCTET_STRING(int type,
	const unsigned char *m, unsigned int m_length,
	unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
d361 8
a368 8
int RSA_padding_add_PKCS1_type_1(unsigned char *to,int tlen,
	const unsigned char *f,int fl);
int RSA_padding_check_PKCS1_type_1(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_PKCS1_type_2(unsigned char *to,int tlen,
	const unsigned char *f,int fl);
int RSA_padding_check_PKCS1_type_2(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len);
d370 19
a388 19
	const unsigned char *seed, long seedlen, const EVP_MD *dgst);
int RSA_padding_add_PKCS1_OAEP(unsigned char *to,int tlen,
	const unsigned char *f,int fl,
	const unsigned char *p,int pl);
int RSA_padding_check_PKCS1_OAEP(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len,
	const unsigned char *p,int pl);
int RSA_padding_add_SSLv23(unsigned char *to,int tlen,
	const unsigned char *f,int fl);
int RSA_padding_check_SSLv23(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_none(unsigned char *to,int tlen,
	const unsigned char *f,int fl);
int RSA_padding_check_none(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_X931(unsigned char *to,int tlen,
	const unsigned char *f,int fl);
int RSA_padding_check_X931(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len);
d392 1
a392 1
			const EVP_MD *Hash, const unsigned char *EM, int sLen);
d394 1
a394 2
			const unsigned char *mHash,
			const EVP_MD *Hash, int sLen);
d397 2
a398 2
			const EVP_MD *Hash, const EVP_MD *mgf1Hash, 
			const unsigned char *EM, int sLen);
d401 2
a402 2
			const unsigned char *mHash,
			const EVP_MD *Hash, const EVP_MD *mgf1Hash, int sLen);
d405 2
a406 2
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int RSA_set_ex_data(RSA *r,int idx,void *arg);
@


1.19
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a157 1
	char *bignum_data;
a312 3

/* This function needs the memory locking malloc callbacks to be installed */
int RSA_memory_lock(RSA *r);
@


1.18
log
@Everything sane has stdio, and FILE *. we don't need ifdefs for this.
ok to firebomb from tedu@@
@
text
@d1 1
a1 1
/* crypto/rsa/rsa.h */
@


1.17
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@a335 1
#ifndef OPENSSL_NO_FP_API
a336 1
#endif
@


1.16
log
@resolve conflicts
@
text
@d283 1
a283 1
int	RSA_size(const RSA *);
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d225 4
d235 6
d249 8
d262 5
d326 10
d416 8
d432 19
d468 1
d477 2
d490 1
d503 2
d507 2
d516 1
d542 1
d545 1
d547 1
d554 1
d559 1
d570 1
d572 4
@


1.14
log
@resolve conflicts
@
text
@a76 19
/* If this flag is set the RSA method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its reposibility
 * to ensure the result is compliant.
 */

#define RSA_FLAG_FIPS_METHOD			0x0400

/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */

#define RSA_FLAG_NON_FIPS_ALLOW			0x0400

#ifdef OPENSSL_FIPS
#define FIPS_RSA_SIZE_T	int
#endif

d120 2
a121 1
		unsigned char *sigbuf, unsigned int siglen, const RSA *rsa);
a166 2
#define OPENSSL_RSA_FIPS_MIN_MODULUS_BITS 1024

d221 24
d250 2
a269 5
int RSA_X931_derive_ex(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1, BIGNUM *q2,
			const BIGNUM *Xp1, const BIGNUM *Xp2, const BIGNUM *Xp,
			const BIGNUM *Xq1, const BIGNUM *Xq2, const BIGNUM *Xq,
			const BIGNUM *e, BN_GENCB *cb);
int RSA_X931_generate_key_ex(RSA *rsa, int bits, const BIGNUM *e, BN_GENCB *cb);
a286 5
#ifdef OPENSSL_FIPS
RSA *FIPS_rsa_new(void);
void FIPS_rsa_free(RSA *r);
#endif

d332 1
a332 1
	unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
d400 3
a402 2
#define RSA_F_FIPS_RSA_SIGN				 140
#define RSA_F_FIPS_RSA_VERIFY				 141
d404 5
d439 3
a441 2
#define RSA_F_RSA_PRIVATE_ENCRYPT			 137
#define RSA_F_RSA_PUBLIC_DECRYPT			 138
a442 2
#define RSA_F_RSA_SET_DEFAULT_METHOD			 139
#define RSA_F_RSA_SET_METHOD				 142
d468 2
d471 1
d474 2
d477 1
a481 1
#define RSA_R_NON_FIPS_METHOD				 141
d486 1
a486 1
#define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	 142
d497 1
@


1.13
log
@update to openssl-0.9.8i; tested by several, especially krw@@
@
text
@d77 19
d185 2
d264 5
d286 5
d404 2
d437 2
d440 2
d475 1
d480 1
@


1.12
log
@resolve conflicts
@
text
@d284 1
d298 1
@


1.11
log
@openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a66 1
#include <openssl/bn.h>
d69 3
a76 4
#if defined(OPENSSL_FIPS)
#define FIPS_RSA_SIZE_T	int
#endif

d81 3
a83 1
typedef struct rsa_st RSA;
d85 1
a85 1
typedef struct rsa_meth_st
d100 1
a100 1
	int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa); /* Can be null */
d121 6
a126 2

	} RSA_METHOD;
d159 1
d162 3
a164 1
#define OPENSSL_RSA_MAX_MODULUS_BITS	16384
d166 6
a171 2
#define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
#define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "small" modulus only */
d198 13
a210 1
#define RSA_FLAG_NO_EXP_CONSTTIME	0x0100 /* new with 0.9.7h; the built-in RSA
d217 2
d234 3
d239 5
a244 9
#ifdef OPENSSL_FIPS
int RSA_X931_derive(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1, BIGNUM *q2,
			void (*cb)(int, int, void *), void *cb_arg,
			const BIGNUM *Xp1, const BIGNUM *Xp2, const BIGNUM *Xp,
			const BIGNUM *Xq1, const BIGNUM *Xq2, const BIGNUM *Xq,
			const BIGNUM *e);
RSA *RSA_X931_generate_key(int bits, const BIGNUM *e,
	     void (*cb)(int,int,void *), void *cb_arg);
#endif
d284 13
a296 5
int i2d_RSA_NET(const RSA *a, unsigned char **pp, int (*cb)(), int sgckey);
RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length, int (*cb)(), int sgckey);

int i2d_Netscape_RSA(const RSA *a, unsigned char **pp, int (*cb)());
RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length, int (*cb)());
d316 1
d372 1
d379 1
d382 5
d402 1
d436 1
@


1.10
log
@resolve conflicts
@
text
@d157 5
d394 1
@


1.10.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a156 5
#define OPENSSL_RSA_MAX_MODULUS_BITS	16384

#define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
#define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "small" modulus only */

a388 1
#define RSA_R_MODULUS_TOO_LARGE				 105
@


1.9
log
@resolve conflicts
@
text
@d160 1
a160 1
#define RSA_METHOD_FLAG_NO_CHECK	0x01 /* don't check pub/private match */
d162 4
a165 4
#define RSA_FLAG_CACHE_PUBLIC		0x02
#define RSA_FLAG_CACHE_PRIVATE		0x04
#define RSA_FLAG_BLINDING		0x08
#define RSA_FLAG_THREAD_SAFE		0x10
d171 1
a171 1
#define RSA_FLAG_EXT_PKEY		0x20
d175 1
a175 1
#define RSA_FLAG_SIGN_VER		0x40
d177 12
a188 5
#define RSA_FLAG_NO_BLINDING		0x80 /* new with 0.9.6j and 0.9.7b; the built-in
                                              * RSA implementation now uses blinding by
                                              * default (ignoring RSA_FLAG_BLINDING),
                                              * but other engines might not need it
                                              */
d194 1
d207 9
d288 2
d304 11
d344 1
d348 1
d354 1
d361 1
d381 2
d384 2
d388 1
d396 2
@


1.9.2.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a156 5
#define OPENSSL_RSA_MAX_MODULUS_BITS	16384

#define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
#define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "small" modulus only */

a349 1
#define RSA_R_MODULUS_TOO_LARGE				 105
@


1.9.4.1
log
@MFC:
Fix by pvalchev@@

openssl security fixes, diff from markus@@, ok & "commit it" djm@@
http://www.openssl.org/news/secadv_20060928.txt for more
@
text
@a156 5
#define OPENSSL_RSA_MAX_MODULUS_BITS	16384

#define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
#define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "small" modulus only */

a349 1
#define RSA_R_MODULUS_TOO_LARGE				 105
@


1.8
log
@merge 0.9.7c; minor bugsfixes;
API addition: ERR_release_err_state_table
[make includes before you build libssl/libcrypto]
@
text
@d75 4
@


1.7
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@a160 5
#define RSA_FLAG_NO_BLINDING		0x80 /* new with 0.9.6j and 0.9.7b; the built-in
                                              * RSA implementation now uses blinding by
                                              * default (ignoring RSA_FLAG_BLINDING),
                                              * but other engines might not need it
                                              */
d173 5
a177 1
#define RSA_FLAG_NO_BLINDING		0x80
@


1.6
log
@merge openssl-0.9.7-beta3, tested on vax by miod@@
@
text
@d161 5
d178 2
d184 2
@


1.5
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@d279 3
@


1.4
log
@openssl-engine-0.9.6 merge
@
text
@d62 3
a64 1
#ifndef NO_BIO
d69 1
d71 1
a71 1
#ifdef NO_RSA
d84 2
a85 1
	int (*rsa_pub_enc)(int flen,unsigned char *from,unsigned char *to,
d87 2
a88 1
	int (*rsa_pub_dec)(int flen,unsigned char *from,unsigned char *to,
d90 2
a91 1
	int (*rsa_priv_enc)(int flen,unsigned char *from,unsigned char *to,
d93 2
a94 1
	int (*rsa_priv_dec)(int flen,unsigned char *from,unsigned char *to,
d96 2
a97 2
	int (*rsa_mod_exp)(BIGNUM *r0,BIGNUM *I,RSA *rsa); /* Can be null */
	int (*bn_mod_exp)(BIGNUM *r, BIGNUM *a, const BIGNUM *p,
d111 6
a116 4
	int (*rsa_sign)(int type, unsigned char *m, unsigned int m_len,
             unsigned char *sigret, unsigned int *siglen, RSA *rsa);
	int (*rsa_verify)(int dtype, unsigned char *m, unsigned int m_len,
             unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
d125 4
a128 6
	int version;
#if 0
	RSA_METHOD *meth;
#else
	struct engine_st *engine;
#endif
d182 2
a183 6
#if 0
RSA *	RSA_new_method(RSA_METHOD *method);
#else
RSA *	RSA_new_method(struct engine_st *engine);
#endif
int	RSA_size(RSA *);
d186 1
a186 1
int	RSA_check_key(RSA *);
d188 1
a188 1
int	RSA_public_encrypt(int flen, unsigned char *from,
d190 1
a190 1
int	RSA_private_encrypt(int flen, unsigned char *from,
d192 1
a192 1
int	RSA_public_decrypt(int flen, unsigned char *from, 
d194 1
a194 1
int	RSA_private_decrypt(int flen, unsigned char *from, 
d197 2
d200 1
a200 1
int	RSA_flags(RSA *r);
d202 4
a205 8
void RSA_set_default_openssl_method(RSA_METHOD *meth);
RSA_METHOD *RSA_get_default_openssl_method(void);
RSA_METHOD *RSA_get_method(RSA *rsa);
#if 0
RSA_METHOD *RSA_set_method(RSA *rsa, RSA_METHOD *meth);
#else
int RSA_set_method(RSA *rsa, struct engine_st *engine);
#endif
a209 3
/* If you have RSAref compiled in. */
RSA_METHOD *RSA_PKCS1_RSAref(void);

d211 1
a211 1
RSA_METHOD *RSA_PKCS1_SSLeay(void);
d213 1
a213 1
RSA_METHOD *RSA_null_method(void);
d215 2
a216 1
void	ERR_load_RSA_strings(void );
d218 2
a219 6
RSA *	d2i_RSAPublicKey(RSA **a, unsigned char **pp, long length);
int	i2d_RSAPublicKey(RSA *a, unsigned char **pp);
RSA *	d2i_RSAPrivateKey(RSA **a, unsigned char **pp, long length);
int 	i2d_RSAPrivateKey(RSA *a, unsigned char **pp);
#ifndef NO_FP_API
int	RSA_print_fp(FILE *fp, RSA *r,int offset);
d222 2
a223 2
#ifndef NO_BIO
int	RSA_print(BIO *bp, RSA *r,int offset);
d226 5
a230 9
int i2d_RSA_NET(RSA *a, unsigned char **pp, int (*cb)(), int sgckey);
RSA *d2i_RSA_NET(RSA **a, unsigned char **pp, long length, int (*cb)(), int sgckey);
RSA *d2i_RSA_NET_2(RSA **a, unsigned char **pp, long length, int (*cb)(), int sgckey);

int i2d_Netscape_RSA(RSA *a, unsigned char **pp, int (*cb)());
RSA *d2i_Netscape_RSA(RSA **a, unsigned char **pp, long length, int (*cb)());
/* Naughty internal function required elsewhere, to handle a MS structure
 * that is the same as the netscape one :-) */
RSA *d2i_Netscape_RSA_2(RSA **a, unsigned char **pp, long length, int (*cb)());
d234 1
a234 1
int RSA_sign(int type, unsigned char *m, unsigned int m_len,
d236 1
a236 1
int RSA_verify(int type, unsigned char *m, unsigned int m_len,
d241 2
a242 1
int RSA_sign_ASN1_OCTET_STRING(int type, unsigned char *m, unsigned int m_len,
d244 2
a245 1
int RSA_verify_ASN1_OCTET_STRING(int type, unsigned char *m, unsigned int m_len,
d252 1
a252 1
	unsigned char *f,int fl);
d254 1
a254 1
	unsigned char *f,int fl,int rsa_len);
d256 1
a256 1
	unsigned char *f,int fl);
d258 1
a258 1
	unsigned char *f,int fl,int rsa_len);
d260 2
a261 2
			       unsigned char *f,int fl,unsigned char *p,
			       int pl);
d263 2
a264 2
				 unsigned char *f,int fl,int rsa_len,
				 unsigned char *p,int pl);
d266 1
a266 1
	unsigned char *f,int fl);
d268 1
a268 1
	unsigned char *f,int fl,int rsa_len);
d270 1
a270 1
	unsigned char *f,int fl);
d272 1
a272 1
	unsigned char *f,int fl,int rsa_len);
d277 1
a277 1
void *RSA_get_ex_data(RSA *r, int idx);
d283 1
d325 1
a351 1

@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d62 2
a63 2
#ifdef  __cplusplus
extern "C" {
a64 1

d72 4
d117 1
d119 3
d175 1
d177 3
d197 2
a198 2
void RSA_set_default_method(RSA_METHOD *meth);
RSA_METHOD *RSA_get_default_method(void);
d200 1
d202 3
d227 1
a227 1
#ifdef HEADER_BIO_H
d230 4
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d94 12
d155 4
d164 1
a164 1
#define RSA_set_app_data(s,arg)         RSA_set_ex_data(s,0,(char *)arg)
d200 2
d262 4
a265 4
int RSA_get_ex_new_index(long argl, char *argp, int (*new_func)(),
	int (*dup_func)(), void (*free_func)());
int RSA_set_ex_data(RSA *r,int idx,char *arg);
char *RSA_get_ex_data(RSA *r, int idx);
d283 1
a313 1
#define RSA_R_D_E_NOT_CONGRUENT_TO_1			 123
d317 2
d327 1
@


1.1
log
@Initial revision
@
text
@d66 8
a73 2
#include "bn.h"
#include "crypto.h"
d77 15
a91 10
	char *name;
	int (*rsa_pub_enc)();
	int (*rsa_pub_dec)();
	int (*rsa_priv_enc)();
	int (*rsa_priv_dec)();
	int (*rsa_mod_exp)();		/* Can be null */
	int (*bn_mod_exp)();		/* Can be null */
	int (*init)(/* RSA * */);	/* called at new */
	int (*finish)(/* RSA * */);	/* called at free */

d96 1
a96 1
typedef struct rsa_st
d111 1
a111 1
	/* be carefull using this if the RSA structure is shared */
d116 8
a123 5
	/* Normally used to cached montgomery values */
	char *method_mod_n;
	char *method_mod_p;
	char *method_mod_q;

d125 1
a125 1
	} RSA;
d131 1
d136 6
d146 1
a150 1
#ifndef NOPROTO
d155 2
a156 1
		(*callback)(int,int,char *),char *cb_arg);
d171 6
d224 1
a224 1
	unsigned char *f,int fl);
d228 7
a234 1
	unsigned char *f,int fl);
d238 1
a238 1
	unsigned char *f,int fl);
d242 1
a242 1
	unsigned char *f,int fl);
d249 4
a252 30
#else

RSA *	RSA_new();
RSA *	RSA_new_method();
int	RSA_size();
RSA *	RSA_generate_key();
int	RSA_public_encrypt();
int	RSA_private_encrypt();
int	RSA_public_decrypt();
int	RSA_private_decrypt();
void	RSA_free ();

int	RSA_flags();

void RSA_set_default_method();

/* RSA_METHOD *RSA_PKCS1_RSAref(); */
RSA_METHOD *RSA_PKCS1_SSLeay();

void	ERR_load_RSA_strings();

RSA *	d2i_RSAPublicKey();
int	i2d_RSAPublicKey();
RSA *	d2i_RSAPrivateKey();
int 	i2d_RSAPrivateKey();
#ifndef NO_FP_API
int	RSA_print_fp();
#endif

int	RSA_print();
a253 28
int i2d_Netscape_RSA();
RSA *d2i_Netscape_RSA();
RSA *d2i_Netscape_RSA_2();

int RSA_sign();
int RSA_verify();

int RSA_sign_ASN1_OCTET_STRING();
int RSA_verify_ASN1_OCTET_STRING();
int RSA_blinding_on();
void RSA_blinding_off();

int RSA_padding_add_PKCS1_type_1();
int RSA_padding_check_PKCS1_type_1();
int RSA_padding_add_PKCS1_type_2();
int RSA_padding_check_PKCS1_type_2();
int RSA_padding_add_SSLv23();
int RSA_padding_check_SSLv23();
int RSA_padding_add_none();
int RSA_padding_check_none();

int RSA_get_ex_new_index();
int RSA_set_ex_data();
char *RSA_get_ex_data();

#endif

/* BEGIN ERROR CODES */
d257 24
a280 20
#define RSA_F_RSA_EAY_PRIVATE_DECRYPT			 100
#define RSA_F_RSA_EAY_PRIVATE_ENCRYPT			 101
#define RSA_F_RSA_EAY_PUBLIC_DECRYPT			 102
#define RSA_F_RSA_EAY_PUBLIC_ENCRYPT			 103
#define RSA_F_RSA_GENERATE_KEY				 104
#define RSA_F_RSA_NEW_METHOD				 105
#define RSA_F_RSA_PADDING_ADD_NONE			 106
#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1		 107
#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2		 108
#define RSA_F_RSA_PADDING_ADD_SSLV23			 109
#define RSA_F_RSA_PADDING_CHECK_NONE			 110
#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1		 111
#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2		 112
#define RSA_F_RSA_PADDING_CHECK_SSLV23			 113
#define RSA_F_RSA_PRINT					 114
#define RSA_F_RSA_PRINT_FP				 115
#define RSA_F_RSA_SIGN					 116
#define RSA_F_RSA_SIGN_ASN1_OCTET_STRING		 117
#define RSA_F_RSA_VERIFY				 118
#define RSA_F_RSA_VERIFY_ASN1_OCTET_STRING		 119
a287 1
#define RSA_R_BAD_ZERO_BYTE				 105
d294 2
d297 4
d302 2
d305 2
d312 1
a312 1
 
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@a61 13
#include <openssl/asn1.h>

#ifndef OPENSSL_NO_BIO
#include <openssl/bio.h>
#endif
#include <openssl/bn.h>
#include <openssl/crypto.h>
#include <openssl/ossl_typ.h>

#ifdef OPENSSL_NO_RSA
#error RSA is disabled.
#endif

d66 2
a67 1
typedef struct rsa_st RSA;
d71 10
a80 19
	const char *name;
	int (*rsa_pub_enc)(int flen,const unsigned char *from,
			   unsigned char *to,
			   RSA *rsa,int padding);
	int (*rsa_pub_dec)(int flen,const unsigned char *from,
			   unsigned char *to,
			   RSA *rsa,int padding);
	int (*rsa_priv_enc)(int flen,const unsigned char *from,
			    unsigned char *to,
			    RSA *rsa,int padding);
	int (*rsa_priv_dec)(int flen,const unsigned char *from,
			    unsigned char *to,
			    RSA *rsa,int padding);
	int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa); /* Can be null */
	int (*bn_mod_exp)(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
			  const BIGNUM *m, BN_CTX *ctx,
			  BN_MONT_CTX *m_ctx); /* Can be null */
	int (*init)(RSA *rsa);		/* called at new */
	int (*finish)(RSA *rsa);	/* called at free */
a82 14
/* New sign and verify functions: some libraries don't allow arbitrary data
 * to be signed/verified: this allows them to be used. Note: for this to work
 * the RSA_public_decrypt() and RSA_private_encrypt() should *NOT* be used
 * RSA_sign(), RSA_verify() should be used instead. Note: for backwards
 * compatibility this functionality is only enabled if the RSA_FLAG_SIGN_VER
 * option is set in 'flags'.
 */
	int (*rsa_sign)(int type,
		const unsigned char *m, unsigned int m_length,
		unsigned char *sigret, unsigned int *siglen, const RSA *rsa);
	int (*rsa_verify)(int dtype,
		const unsigned char *m, unsigned int m_length,
		unsigned char *sigbuf, unsigned int siglen, const RSA *rsa);

d85 1
a85 1
struct rsa_st
d90 2
a91 4
	long version;
	const RSA_METHOD *meth;
	/* functional reference if 'meth' is ENGINE-provided */
	ENGINE *engine;
d100 1
a100 1
	/* be careful using this if the RSA structure is shared */
d105 5
a109 8
	/* Used to cache montgomery values */
	BN_MONT_CTX *_method_mod_n;
	BN_MONT_CTX *_method_mod_p;
	BN_MONT_CTX *_method_mod_q;

	/* all BIGNUM values are actually in the following data, if it is not
	 * NULL */
	char *bignum_data;
d111 1
a111 1
	};
a116 1

a120 10
/* This flag means the private key operations will be handled by rsa_mod_exp
 * and that they do not depend on the private key components being present:
 * for example a key stored in external hardware. Without this flag bn_mod_exp
 * gets called when private key components are absent.
 */
#define RSA_FLAG_EXT_PKEY		0x20

/* This flag in the RSA_METHOD enables the new rsa_sign, rsa_verify functions.
 */
#define RSA_FLAG_SIGN_VER		0x40
a124 1
#define RSA_PKCS1_OAEP_PADDING	4
d126 1
a126 1
#define RSA_set_app_data(s,arg)         RSA_set_ex_data(s,0,arg)
d129 1
d131 2
a132 2
RSA *	RSA_new_method(ENGINE *engine);
int	RSA_size(const RSA *);
d134 1
a134 2
		(*callback)(int,int,void *),void *cb_arg);
int	RSA_check_key(const RSA *);
d136 1
a136 1
int	RSA_public_encrypt(int flen, const unsigned char *from,
d138 1
a138 1
int	RSA_private_encrypt(int flen, const unsigned char *from,
d140 1
a140 1
int	RSA_public_decrypt(int flen, const unsigned char *from, 
d142 1
a142 1
int	RSA_private_decrypt(int flen, const unsigned char *from, 
a144 2
/* "up" the RSA object's reference count */
int	RSA_up_ref(RSA *r);
d146 1
a146 1
int	RSA_flags(const RSA *r);
d148 1
a148 4
void RSA_set_default_method(const RSA_METHOD *meth);
const RSA_METHOD *RSA_get_default_method(void);
const RSA_METHOD *RSA_get_method(const RSA *rsa);
int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);
d150 2
a151 2
/* This function needs the memory locking malloc callbacks to be installed */
int RSA_memory_lock(RSA *r);
d154 1
a154 3
const RSA_METHOD *RSA_PKCS1_SSLeay(void);

const RSA_METHOD *RSA_null_method(void);
d156 1
a156 2
DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPublicKey)
DECLARE_ASN1_ENCODE_FUNCTIONS_const(RSA, RSAPrivateKey)
d158 6
a163 2
#ifndef OPENSSL_NO_FP_API
int	RSA_print_fp(FILE *fp, const RSA *r,int offset);
d166 2
a167 2
#ifndef OPENSSL_NO_BIO
int	RSA_print(BIO *bp, const RSA *r,int offset);
d170 5
a174 5
int i2d_RSA_NET(const RSA *a, unsigned char **pp, int (*cb)(), int sgckey);
RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length, int (*cb)(), int sgckey);

int i2d_Netscape_RSA(const RSA *a, unsigned char **pp, int (*cb)());
RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length, int (*cb)());
d178 1
a178 1
int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
d180 1
a180 1
int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
d185 1
a185 2
int RSA_sign_ASN1_OCTET_STRING(int type,
	const unsigned char *m, unsigned int m_length,
d187 1
a187 2
int RSA_verify_ASN1_OCTET_STRING(int type,
	const unsigned char *m, unsigned int m_length,
d194 1
a194 1
	const unsigned char *f,int fl);
d196 1
a196 1
	const unsigned char *f,int fl,int rsa_len);
d198 1
a198 1
	const unsigned char *f,int fl);
d200 1
a200 7
	const unsigned char *f,int fl,int rsa_len);
int RSA_padding_add_PKCS1_OAEP(unsigned char *to,int tlen,
	const unsigned char *f,int fl,
	const unsigned char *p,int pl);
int RSA_padding_check_PKCS1_OAEP(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len,
	const unsigned char *p,int pl);
d202 1
a202 1
	const unsigned char *f,int fl);
d204 1
a204 1
	const unsigned char *f,int fl,int rsa_len);
d206 1
a206 1
	const unsigned char *f,int fl);
d208 35
a242 1
	const unsigned char *f,int fl,int rsa_len);
d244 28
a271 4
int RSA_get_ex_new_index(long argl, void *argp, CRYPTO_EX_new *new_func,
	CRYPTO_EX_dup *dup_func, CRYPTO_EX_free *free_func);
int RSA_set_ex_data(RSA *r,int idx,void *arg);
void *RSA_get_ex_data(const RSA *r, int idx);
a273 5
/* The following lines are auto generated by the script mkerr.pl. Any changes
 * made after this point may be overwritten when the script is next run.
 */
void ERR_load_RSA_strings(void);

d277 20
a296 25
#define RSA_F_MEMORY_LOCK				 100
#define RSA_F_RSA_CHECK_KEY				 123
#define RSA_F_RSA_EAY_PRIVATE_DECRYPT			 101
#define RSA_F_RSA_EAY_PRIVATE_ENCRYPT			 102
#define RSA_F_RSA_EAY_PUBLIC_DECRYPT			 103
#define RSA_F_RSA_EAY_PUBLIC_ENCRYPT			 104
#define RSA_F_RSA_GENERATE_KEY				 105
#define RSA_F_RSA_NEW_METHOD				 106
#define RSA_F_RSA_NULL					 124
#define RSA_F_RSA_PADDING_ADD_NONE			 107
#define RSA_F_RSA_PADDING_ADD_PKCS1_OAEP		 121
#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_1		 108
#define RSA_F_RSA_PADDING_ADD_PKCS1_TYPE_2		 109
#define RSA_F_RSA_PADDING_ADD_SSLV23			 110
#define RSA_F_RSA_PADDING_CHECK_NONE			 111
#define RSA_F_RSA_PADDING_CHECK_PKCS1_OAEP		 122
#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_1		 112
#define RSA_F_RSA_PADDING_CHECK_PKCS1_TYPE_2		 113
#define RSA_F_RSA_PADDING_CHECK_SSLV23			 114
#define RSA_F_RSA_PRINT					 115
#define RSA_F_RSA_PRINT_FP				 116
#define RSA_F_RSA_SIGN					 117
#define RSA_F_RSA_SIGN_ASN1_OCTET_STRING		 118
#define RSA_F_RSA_VERIFY				 119
#define RSA_F_RSA_VERIFY_ASN1_OCTET_STRING		 120
d304 1
a309 1
#define RSA_R_DATA_TOO_LARGE_FOR_MODULUS		 132
a310 1
#define RSA_R_DATA_TOO_SMALL_FOR_KEY_SIZE		 122
a311 6
#define RSA_R_DMP1_NOT_CONGRUENT_TO_D			 124
#define RSA_R_DMQ1_NOT_CONGRUENT_TO_D			 125
#define RSA_R_D_E_NOT_CONGRUENT_TO_1			 123
#define RSA_R_INVALID_MESSAGE_LENGTH			 131
#define RSA_R_IQMP_NOT_INVERSE_OF_Q			 126
#define RSA_R_KEY_SIZE_TOO_SMALL			 120
a312 2
#define RSA_R_N_DOES_NOT_EQUAL_P_Q			 127
#define RSA_R_OAEP_DECODING_ERROR			 121
a313 3
#define RSA_R_P_NOT_PRIME				 128
#define RSA_R_Q_NOT_PRIME				 129
#define RSA_R_RSA_OPERATIONS_NOT_SUPPORTED		 130
d319 1
a319 1

d324 1
@


1.1.1.3
log
@import openssl-0.9.7-beta3
@
text
@a278 3
RSA *RSAPublicKey_dup(RSA *rsa);
RSA *RSAPrivateKey_dup(RSA *rsa);

@


1.1.1.4
log
@import 0.9.7b (without idea and rc5)
@
text
@a160 5
#define RSA_FLAG_NO_BLINDING		0x80 /* new with 0.9.6j and 0.9.7b; the built-in
                                              * RSA implementation now uses blinding by
                                              * default (ignoring RSA_FLAG_BLINDING),
                                              * but other engines might not need it
                                              */
a172 2
#define RSA_FLAG_NO_BLINDING		0x80

a176 2

#define RSA_PKCS1_PADDING_SIZE	11
@


1.1.1.5
log
@import 0.9.7c
@
text
@d161 5
d178 1
a178 5
#define RSA_FLAG_NO_BLINDING		0x80 /* new with 0.9.6j and 0.9.7b; the built-in
                                              * RSA implementation now uses blinding by
                                              * default (ignoring RSA_FLAG_BLINDING),
                                              * but other engines might not need it
                                              */
@


1.1.1.6
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a74 4
#if defined(OPENSSL_FIPS)
#define FIPS_RSA_SIZE_T	int
#endif

@


1.1.1.7
log
@import of openssl-0.9.7j
@
text
@d160 1
a160 1
#define RSA_METHOD_FLAG_NO_CHECK	0x0001 /* don't check pub/private match */
d162 4
a165 4
#define RSA_FLAG_CACHE_PUBLIC		0x0002
#define RSA_FLAG_CACHE_PRIVATE		0x0004
#define RSA_FLAG_BLINDING		0x0008
#define RSA_FLAG_THREAD_SAFE		0x0010
d171 1
a171 1
#define RSA_FLAG_EXT_PKEY		0x0020
d175 1
a175 1
#define RSA_FLAG_SIGN_VER		0x0040
d177 5
a181 12
#define RSA_FLAG_NO_BLINDING		0x0080 /* new with 0.9.6j and 0.9.7b; the built-in
                                                * RSA implementation now uses blinding by
                                                * default (ignoring RSA_FLAG_BLINDING),
                                                * but other engines might not need it
                                                */
#define RSA_FLAG_NO_EXP_CONSTTIME	0x0100 /* new with 0.9.7h; the built-in RSA
                                                * implementation now uses constant time
                                                * modular exponentiation for secret exponents
                                                * by default. This flag causes the
                                                * faster variable sliding window method to
                                                * be used for all exponents.
                                                */
a186 1
#define RSA_X931_PADDING	5
a198 9
#ifdef OPENSSL_FIPS
int RSA_X931_derive(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1, BIGNUM *q2,
			void (*cb)(int, int, void *), void *cb_arg,
			const BIGNUM *Xp1, const BIGNUM *Xp2, const BIGNUM *Xp,
			const BIGNUM *Xq1, const BIGNUM *Xq2, const BIGNUM *Xq,
			const BIGNUM *e);
RSA *RSA_X931_generate_key(int bits, const BIGNUM *e,
	     void (*cb)(int,int,void *), void *cb_arg);
#endif
a270 2
int PKCS1_MGF1(unsigned char *mask, long len,
	const unsigned char *seed, long seedlen, const EVP_MD *dgst);
a284 11
int RSA_padding_add_X931(unsigned char *to,int tlen,
	const unsigned char *f,int fl);
int RSA_padding_check_X931(unsigned char *to,int tlen,
	const unsigned char *f,int fl,int rsa_len);
int RSA_X931_hash_id(int nid);

int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
			const EVP_MD *Hash, const unsigned char *EM, int sLen);
int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
			const unsigned char *mHash,
			const EVP_MD *Hash, int sLen);
a313 1
#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS			 125
a316 1
#define RSA_F_RSA_PADDING_ADD_X931			 127
a321 1
#define RSA_F_RSA_PADDING_CHECK_X931			 128
a327 1
#define RSA_F_RSA_VERIFY_PKCS1_PSS			 126
a346 2
#define RSA_R_FIRST_OCTET_INVALID			 133
#define RSA_R_INVALID_HEADER				 137
a347 2
#define RSA_R_INVALID_PADDING				 138
#define RSA_R_INVALID_TRAILER				 139
a349 1
#define RSA_R_LAST_OCTET_INVALID			 134
a356 2
#define RSA_R_SLEN_CHECK_FAILED				 136
#define RSA_R_SLEN_RECOVERY_FAILED			 135
@


1.1.1.8
log
@import of OpenSSL 0.9.8h
@
text
@d67 1
a69 3
#ifndef OPENSSL_NO_DEPRECATED
#include <openssl/bn.h>
#endif
d75 4
d83 1
a83 3
/* Declared already in ossl_typ.h */
/* typedef struct rsa_st RSA; */
/* typedef struct rsa_meth_st RSA_METHOD; */
d85 1
a85 1
struct rsa_meth_st
d100 1
a100 1
	int (*rsa_mod_exp)(BIGNUM *r0,const BIGNUM *I,RSA *rsa,BN_CTX *ctx); /* Can be null */
d121 2
a122 6
/* If this callback is NULL, the builtin software RSA key-gen will be used. This
 * is for behavioural compatibility whilst the code gets rewired, but one day
 * it would be nice to assume there are no such things as "builtin software"
 * implementations. */
	int (*rsa_keygen)(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
	};
a154 1
	BN_BLINDING *mt_blinding;
a156 11
#ifndef OPENSSL_RSA_MAX_MODULUS_BITS
# define OPENSSL_RSA_MAX_MODULUS_BITS	16384
#endif

#ifndef OPENSSL_RSA_SMALL_MODULUS_BITS
# define OPENSSL_RSA_SMALL_MODULUS_BITS	3072
#endif
#ifndef OPENSSL_RSA_MAX_PUBEXP_BITS
# define OPENSSL_RSA_MAX_PUBEXP_BITS	64 /* exponent limit enforced for "large" modulus only */
#endif

d182 1
a182 13
#define RSA_FLAG_NO_CONSTTIME		0x0100 /* new with 0.9.8f; the built-in RSA
						* implementation now uses constant time
						* operations by default in private key operations,
						* e.g., constant time modular exponentiation, 
                                                * modular inverse without leaking branches, 
                                                * division without leaking branches. This 
                                                * flag disables these constant time 
                                                * operations and results in faster RSA 
                                                * private key operations.
                                                */ 
#ifndef OPENSSL_NO_DEPRECATED
#define RSA_FLAG_NO_EXP_CONSTTIME RSA_FLAG_NO_CONSTTIME /* deprecated name for the flag*/
                                                /* new with 0.9.7h; the built-in RSA
a188 2
#endif

a203 3

/* Deprecated version */
#ifndef OPENSSL_NO_DEPRECATED
a205 5
#endif /* !defined(OPENSSL_NO_DEPRECATED) */

/* New version */
int	RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);

d207 9
d255 5
a259 13
int i2d_RSA_NET(const RSA *a, unsigned char **pp,
		int (*cb)(char *buf, int len, const char *prompt, int verify),
		int sgckey);
RSA *d2i_RSA_NET(RSA **a, const unsigned char **pp, long length,
		 int (*cb)(char *buf, int len, const char *prompt, int verify),
		 int sgckey);

int i2d_Netscape_RSA(const RSA *a, unsigned char **pp,
		     int (*cb)(char *buf, int len, const char *prompt,
			       int verify));
RSA *d2i_Netscape_RSA(RSA **a, const unsigned char **pp, long length,
		      int (*cb)(char *buf, int len, const char *prompt,
				int verify));
a278 1
BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);
a333 1
#define RSA_F_RSA_BUILTIN_KEYGEN			 129
a339 1
#define RSA_F_RSA_MEMORY_LOCK				 130
a341 5
#define RSA_F_RSA_NULL_MOD_EXP				 131
#define RSA_F_RSA_NULL_PRIVATE_DECRYPT			 132
#define RSA_F_RSA_NULL_PRIVATE_ENCRYPT			 133
#define RSA_F_RSA_NULL_PUBLIC_DECRYPT			 134
#define RSA_F_RSA_NULL_PUBLIC_ENCRYPT			 135
a356 1
#define RSA_F_RSA_SETUP_BLINDING			 136
a388 2
#define RSA_R_MODULUS_TOO_LARGE				 105
#define RSA_R_NO_PUBLIC_EXPONENT			 140
@


1.1.1.9
log
@import openssl-0.9.8j
@
text
@a76 19
/* If this flag is set the RSA method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its reposibility
 * to ensure the result is compliant.
 */

#define RSA_FLAG_FIPS_METHOD			0x0400

/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */

#define RSA_FLAG_NON_FIPS_ALLOW			0x0400

#ifdef OPENSSL_FIPS
#define FIPS_RSA_SIZE_T	int
#endif

a165 2
#define OPENSSL_RSA_FIPS_MIN_MODULUS_BITS 1024

a242 5
int RSA_X931_derive_ex(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1, BIGNUM *q2,
			const BIGNUM *Xp1, const BIGNUM *Xp2, const BIGNUM *Xp,
			const BIGNUM *Xq1, const BIGNUM *Xq2, const BIGNUM *Xq,
			const BIGNUM *e, BN_GENCB *cb);
int RSA_X931_generate_key_ex(RSA *rsa, int bits, const BIGNUM *e, BN_GENCB *cb);
a259 5
#ifdef OPENSSL_FIPS
RSA *FIPS_rsa_new(void);
void FIPS_rsa_free(RSA *r);
#endif

a283 1
#ifndef OPENSSL_NO_RC4
a296 1
#endif
a370 2
#define RSA_F_FIPS_RSA_SIGN				 140
#define RSA_F_FIPS_RSA_VERIFY				 141
a401 2
#define RSA_F_RSA_PRIVATE_ENCRYPT			 137
#define RSA_F_RSA_PUBLIC_DECRYPT			 138
a402 2
#define RSA_F_RSA_SET_DEFAULT_METHOD			 139
#define RSA_F_RSA_SET_METHOD				 142
a435 1
#define RSA_R_NON_FIPS_METHOD				 141
a439 1
#define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	 142
@


1.1.1.10
log
@import OpenSSL-1.0.0a
@
text
@d77 19
d139 1
a139 2
		const unsigned char *sigbuf, unsigned int siglen,
								const RSA *rsa);
d185 2
a240 24
#define EVP_PKEY_CTX_set_rsa_padding(ctx, pad) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, EVP_PKEY_CTRL_RSA_PADDING, \
				pad, NULL)

#define EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, len) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, \
				(EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
				EVP_PKEY_CTRL_RSA_PSS_SALTLEN, \
				len, NULL)

#define EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, bits) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN, \
				EVP_PKEY_CTRL_RSA_KEYGEN_BITS, bits, NULL)

#define EVP_PKEY_CTX_set_rsa_keygen_pubexp(ctx, pubexp) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_KEYGEN, \
				EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP, 0, pubexp)

#define EVP_PKEY_CTRL_RSA_PADDING	(EVP_PKEY_ALG_CTRL + 1)
#define EVP_PKEY_CTRL_RSA_PSS_SALTLEN	(EVP_PKEY_ALG_CTRL + 2)

#define EVP_PKEY_CTRL_RSA_KEYGEN_BITS	(EVP_PKEY_ALG_CTRL + 3)
#define EVP_PKEY_CTRL_RSA_KEYGEN_PUBEXP	(EVP_PKEY_ALG_CTRL + 4)

a245 2
/* EVP_PKEY_ only */
#define RSA_PKCS1_PSS_PADDING	6
d264 5
d286 5
d336 1
a336 1
	const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
d404 2
a405 3
#define RSA_F_CHECK_PADDING_MD				 140
#define RSA_F_DO_RSA_PRINT				 146
#define RSA_F_INT_RSA_VERIFY				 145
a406 5
#define RSA_F_OLD_RSA_PRIV_DECODE			 147
#define RSA_F_PKEY_RSA_CTRL				 143
#define RSA_F_PKEY_RSA_CTRL_STR				 144
#define RSA_F_PKEY_RSA_SIGN				 142
#define RSA_F_PKEY_RSA_VERIFYRECOVER			 141
d437 2
a438 3
#define RSA_F_RSA_PRIV_DECODE				 137
#define RSA_F_RSA_PRIV_ENCODE				 138
#define RSA_F_RSA_PUB_DECODE				 139
d440 2
a466 2
#define RSA_R_ILLEGAL_OR_UNSUPPORTED_PADDING_MODE	 144
#define RSA_R_INVALID_DIGEST_LENGTH			 143
a467 1
#define RSA_R_INVALID_KEYBITS				 145
a469 2
#define RSA_R_INVALID_PADDING_MODE			 141
#define RSA_R_INVALID_PSS_SALTLEN			 146
a470 1
#define RSA_R_INVALID_X931_DIGEST			 142
d475 1
d480 1
a480 1
#define RSA_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE	 148
a490 1
#define RSA_R_VALUE_MISSING				 147
@


1.1.1.11
log
@import OpenSSL-1.0.1c
@
text
@a224 4
#define EVP_PKEY_CTX_get_rsa_padding(ctx, ppad) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, -1, \
				EVP_PKEY_CTRL_GET_RSA_PADDING, 0, ppad)

a230 6
#define EVP_PKEY_CTX_get_rsa_pss_saltlen(ctx, plen) \
	EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, \
				(EVP_PKEY_OP_SIGN|EVP_PKEY_OP_VERIFY), \
				EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN, \
				0, plen)

a238 8
#define	 EVP_PKEY_CTX_set_rsa_mgf1_md(ctx, md)	\
		EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_SIG,  \
				EVP_PKEY_CTRL_RSA_MGF1_MD, 0, (void *)md)

#define	 EVP_PKEY_CTX_get_rsa_mgf1_md(ctx, pmd)	\
		EVP_PKEY_CTX_ctrl(ctx, EVP_PKEY_RSA, EVP_PKEY_OP_TYPE_SIG,  \
				EVP_PKEY_CTRL_GET_RSA_MGF1_MD, 0, (void *)pmd)

a243 5
#define EVP_PKEY_CTRL_RSA_MGF1_MD	(EVP_PKEY_ALG_CTRL + 5)

#define EVP_PKEY_CTRL_GET_RSA_PADDING		(EVP_PKEY_ALG_CTRL + 6)
#define EVP_PKEY_CTRL_GET_RSA_PSS_SALTLEN	(EVP_PKEY_ALG_CTRL + 7)
#define EVP_PKEY_CTRL_GET_RSA_MGF1_MD		(EVP_PKEY_ALG_CTRL + 8)
a302 10
typedef struct rsa_pss_params_st
	{
	X509_ALGOR *hashAlgorithm;
	X509_ALGOR *maskGenAlgorithm;
	ASN1_INTEGER *saltLength;
	ASN1_INTEGER *trailerField;
	} RSA_PSS_PARAMS;

DECLARE_ASN1_FUNCTIONS(RSA_PSS_PARAMS)

a382 8
int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
			const EVP_MD *Hash, const EVP_MD *mgf1Hash, 
			const unsigned char *EM, int sLen);

int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
			const unsigned char *mHash,
			const EVP_MD *Hash, const EVP_MD *mgf1Hash, int sLen);

a390 19
/* If this flag is set the RSA method is FIPS compliant and can be used
 * in FIPS mode. This is set in the validated module method. If an
 * application sets this flag in its own methods it is its responsibility
 * to ensure the result is compliant.
 */

#define RSA_FLAG_FIPS_METHOD			0x0400

/* If this flag is set the operations normally disabled in FIPS mode are
 * permitted it is then the applications responsibility to ensure that the
 * usage is compliant.
 */

#define RSA_FLAG_NON_FIPS_ALLOW			0x0400
/* Application has decided PRNG is good enough to generate a key: don't
 * check.
 */
#define RSA_FLAG_CHECKED			0x0800

a407 1
#define RSA_F_PKEY_RSA_VERIFY				 154
a415 2
#define RSA_F_RSA_GENERATE_KEY_EX			 155
#define RSA_F_RSA_ITEM_VERIFY				 156
a426 1
#define RSA_F_RSA_PADDING_ADD_PKCS1_PSS_MGF1		 148
a438 2
#define RSA_F_RSA_PRIVATE_DECRYPT			 150
#define RSA_F_RSA_PRIVATE_ENCRYPT			 151
a440 2
#define RSA_F_RSA_PUBLIC_DECRYPT			 152
#define RSA_F_RSA_PUBLIC_ENCRYPT			 153
a447 1
#define RSA_F_RSA_VERIFY_PKCS1_PSS_MGF1			 149
a472 1
#define RSA_R_INVALID_MGF1_MD				 156
a474 1
#define RSA_R_INVALID_PSS_PARAMETERS			 149
a475 1
#define RSA_R_INVALID_SALT_LENGTH			 150
a481 1
#define RSA_R_NON_FIPS_RSA_METHOD			 157
a485 1
#define RSA_R_OPERATION_NOT_ALLOWED_IN_FIPS_MODE	 158
a495 1
#define RSA_R_UNKNOWN_MASK_DIGEST			 151
a496 4
#define RSA_R_UNKNOWN_PSS_DIGEST			 152
#define RSA_R_UNSUPPORTED_MASK_ALGORITHM		 153
#define RSA_R_UNSUPPORTED_MASK_PARAMETER		 154
#define RSA_R_UNSUPPORTED_SIGNATURE_TYPE		 155
@


1.1.1.12
log
@Import OpenSSL 1.0.1g
@
text
@d283 1
a283 1
int	RSA_size(const RSA *rsa);
@


