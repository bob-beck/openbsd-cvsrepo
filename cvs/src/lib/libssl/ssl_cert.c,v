head	1.66;
access;
symbols
	OPENBSD_6_2_BASE:1.66
	OPENBSD_6_1:1.64.0.4
	OPENBSD_6_1_BASE:1.64;
locks; strict;
comment	@ * @;


1.66
date	2017.08.12.02.55.22;	author jsing;	state Exp;
branches;
next	1.65;
commitid	75ze73v4QudzrM8f;

1.65
date	2017.08.10.17.18.38;	author jsing;	state Exp;
branches;
next	1.64;
commitid	dKulPy2Ty6efAQYX;

1.64
date	2017.02.07.02.08.38;	author beck;	state Exp;
branches;
next	1.63;
commitid	xH3OeartUDKSlAnB;

1.63
date	2017.01.29.17.49.23;	author beck;	state Exp;
branches;
next	1.62;
commitid	kT0fLt3r4lroFJra;

1.62
date	2017.01.26.12.16.13;	author beck;	state Exp;
branches;
next	1.61;
commitid	lb4UTPLS9Casn2PL;

1.61
date	2017.01.26.10.40.21;	author beck;	state Exp;
branches;
next	1.60;
commitid	Bi1VygMenL4YtCp7;

1.60
date	2017.01.24.15.04.12;	author jsing;	state Exp;
branches;
next	1.59;
commitid	aMjlYSO7tAuwLGon;

1.59
date	2017.01.24.14.57.31;	author jsing;	state Exp;
branches;
next	1.58;
commitid	nQzaI20w3vrSZN0L;

1.58
date	2017.01.23.06.45.30;	author beck;	state Exp;
branches;
next	1.57;
commitid	grTXB43OAHDwwKOU;

1.57
date	2017.01.23.05.13.02;	author jsing;	state Exp;
branches;
next	1.56;
commitid	XWcFqNClp2MoKERU;

1.56
date	2017.01.23.04.55.27;	author beck;	state Exp;
branches;
next	1.55;
commitid	AhwkqHI5lKK3NR31;

1.55
date	2017.01.23.04.15.28;	author jsing;	state Exp;
branches;
next	1.54;
commitid	j20UnjrPw7WvzMvm;

1.54
date	2017.01.22.09.02.07;	author jsing;	state Exp;
branches;
next	1.53;
commitid	570ElYZpaAvthwZh;

1.53
date	2016.12.21.16.44.31;	author jsing;	state Exp;
branches;
next	1.52;
commitid	QsxdTGoZtELBjsxp;

1.52
date	2016.03.11.07.08.45;	author mmcc;	state Exp;
branches;
next	1.51;
commitid	MTdM7aVFdRMAzAYE;

1.51
date	2015.09.11.17.37.47;	author jsing;	state Exp;
branches;
next	1.50;
commitid	EbVUFfLy1NvhaoDt;

1.50
date	2015.04.06.04.09.59;	author guenther;	state Exp;
branches;
next	1.49;
commitid	6GStEBu1FPgZnOs7;

1.49
date	2014.12.14.15.30.50;	author jsing;	state Exp;
branches;
next	1.48;
commitid	XNZawfRSWvnVv1VS;

1.48
date	2014.12.10.15.36.47;	author jsing;	state Exp;
branches;
next	1.47;
commitid	x50cturILyXAfPoH;

1.47
date	2014.12.06.14.24.26;	author jsing;	state Exp;
branches;
next	1.46;
commitid	R8J9s9ZDvNB7vidN;

1.46
date	2014.11.18.05.33.43;	author miod;	state Exp;
branches;
next	1.45;
commitid	81uwsCsokEuKDUjo;

1.45
date	2014.11.16.14.12.47;	author jsing;	state Exp;
branches;
next	1.44;
commitid	M3pvHgIFoWUHNqJn;

1.44
date	2014.10.31.15.25.55;	author jsing;	state Exp;
branches;
next	1.43;
commitid	NOaAgwTtK29a9Ncs;

1.43
date	2014.10.31.14.51.01;	author jsing;	state Exp;
branches;
next	1.42;
commitid	cMCIoWtrOiPFZWnD;

1.42
date	2014.10.03.13.58.18;	author jsing;	state Exp;
branches;
next	1.41;
commitid	TTuHOVoRSWSvd6HI;

1.41
date	2014.07.10.08.25.00;	author guenther;	state Exp;
branches
	1.41.4.1;
next	1.40;
commitid	w11OIjBmQPrJwUQI;

1.40
date	2014.07.09.11.25.42;	author jsing;	state Exp;
branches;
next	1.39;
commitid	N5P2FUkVkAd7ODs9;

1.39
date	2014.06.21.09.10.30;	author logan;	state Exp;
branches;
next	1.38;
commitid	VhFQqgj8euqNophF;

1.38
date	2014.06.12.15.49.31;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	mJUVYpkFBZ0Zv2bG;

1.37
date	2014.06.08.14.51.53;	author jsing;	state Exp;
branches;
next	1.36;
commitid	Sd8cyylY16EhW2bX;

1.36
date	2014.06.07.14.35.31;	author jsing;	state Exp;
branches;
next	1.35;
commitid	moce2ayovF9fb7cV;

1.35
date	2014.06.07.14.10.35;	author jsing;	state Exp;
branches;
next	1.34;
commitid	AgFmutmGDUehZZeH;

1.34
date	2014.06.07.13.45.15;	author jsing;	state Exp;
branches;
next	1.33;
commitid	CTb1U78h4QzizbKq;

1.33
date	2014.05.30.14.30.50;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.29.18.27.52;	author beck;	state Exp;
branches;
next	1.31;

1.31
date	2014.05.29.18.11.13;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2014.05.26.20.15.29;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2014.05.22.17.43.52;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.26.18.56.38;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.21.16.34.43;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.19.08.52.32;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.17.21.37.37;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.17.21.32.37;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.17.13.37.50;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.15.22.43.53;	author beck;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.14.17.20.24;	author beck;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.14.13.10.35;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2014.04.13.22.11.45;	author beck;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.13.21.11.19;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.13.15.25.34;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.13.21.25.14;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.01.22.59.00;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.06.12.17.53;	author djm;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.27.05.07.03;	author djm;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.05.39.31;	author djm;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.08.03.15;	author markus;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.12.02.18.40;	author markus;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.21.01.49.11;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.15.02.29.20;	author beck;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.22.00.03.41;	author beck;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.15.02.58.40;	author beck;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.16.23.49.28;	author beck;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.15.06.18.50;	author beck;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.19.11.13.32;	author beck;	state Exp;
branches;
next	1.2;

1.2
date	99.09.29.04.37.29;	author beck;	state Exp;
branches;
next	1.1;

1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.10.05.20.13.14;	author ryker;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.05.12.51.39;	author markus;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.05.11.21.36.42;	author markus;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.04.07.20.42.07;	author markus;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.04.29.05.37.28;	author djm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.06.27.05.05.39;	author djm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.06.12.15.51;	author djm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.10.01.22.54.16;	author djm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2012.10.13.21.23.50;	author djm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.04.13.15.16.36;	author miod;	state Exp;
branches;
next	;

1.41.4.1
date	2015.03.11.19.52.37;	author tedu;	state Exp;
branches;
next	;
commitid	hkSvLV4ooBbkYqsi;


desc
@@


1.66
log
@Remove support for DSS/DSA, since we removed the cipher suites a while
back.

ok guenther@@
@
text
@/* $OpenBSD: ssl_cert.c,v 1.65 2017/08/10 17:18:38 jsing Exp $ */
/* Copyright (C) 1995-1998 Eric Young (eay@@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */
/* ====================================================================
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@openssl.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
 */

#include <sys/types.h>

#include <dirent.h>
#include <stdio.h>
#include <unistd.h>

#include <openssl/bio.h>
#include <openssl/bn.h>
#include <openssl/dh.h>
#include <openssl/objects.h>
#include <openssl/opensslconf.h>
#include <openssl/pem.h>
#include <openssl/x509v3.h>

#include "ssl_locl.h"

int
SSL_get_ex_data_X509_STORE_CTX_idx(void)
{
	static volatile int ssl_x509_store_ctx_idx = -1;
	int got_write_lock = 0;

	CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);

	if (ssl_x509_store_ctx_idx < 0) {
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		got_write_lock = 1;

		if (ssl_x509_store_ctx_idx < 0) {
			ssl_x509_store_ctx_idx =
			    X509_STORE_CTX_get_ex_new_index(
				0, "SSL for verify callback", NULL, NULL, NULL);
		}
	}

	if (got_write_lock)
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	else
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);

	return ssl_x509_store_ctx_idx;
}

static void
ssl_cert_set_default_md(CERT *cert)
{
	/* Set digest values to defaults */
	cert->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();
	cert->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();
	cert->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
#ifndef OPENSSL_NO_GOST
	cert->pkeys[SSL_PKEY_GOST01].digest = EVP_gostr341194();
#endif
}

CERT *
ssl_cert_new(void)
{
	CERT *ret;

	ret = calloc(1, sizeof(CERT));
	if (ret == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}
	ret->key = &(ret->pkeys[SSL_PKEY_RSA_ENC]);
	ret->references = 1;
	ssl_cert_set_default_md(ret);
	return (ret);
}

CERT *
ssl_cert_dup(CERT *cert)
{
	CERT *ret;
	int i;

	ret = calloc(1, sizeof(CERT));
	if (ret == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return (NULL);
	}

	/*
	 * same as ret->key = ret->pkeys + (cert->key - cert->pkeys),
	 * if you find that more readable
	 */
	ret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];

	ret->valid = cert->valid;
	ret->mask_k = cert->mask_k;
	ret->mask_a = cert->mask_a;

	if (cert->dh_tmp != NULL) {
		ret->dh_tmp = DHparams_dup(cert->dh_tmp);
		if (ret->dh_tmp == NULL) {
			SSLerrorx(ERR_R_DH_LIB);
			goto err;
		}
		if (cert->dh_tmp->priv_key) {
			BIGNUM *b = BN_dup(cert->dh_tmp->priv_key);
			if (!b) {
				SSLerrorx(ERR_R_BN_LIB);
				goto err;
			}
			ret->dh_tmp->priv_key = b;
		}
		if (cert->dh_tmp->pub_key) {
			BIGNUM *b = BN_dup(cert->dh_tmp->pub_key);
			if (!b) {
				SSLerrorx(ERR_R_BN_LIB);
				goto err;
			}
			ret->dh_tmp->pub_key = b;
		}
	}
	ret->dh_tmp_cb = cert->dh_tmp_cb;
	ret->dh_tmp_auto = cert->dh_tmp_auto;

	if (cert->ecdh_tmp) {
		ret->ecdh_tmp = EC_KEY_dup(cert->ecdh_tmp);
		if (ret->ecdh_tmp == NULL) {
			SSLerrorx(ERR_R_EC_LIB);
			goto err;
		}
	}

	for (i = 0; i < SSL_PKEY_NUM; i++) {
		if (cert->pkeys[i].x509 != NULL) {
			ret->pkeys[i].x509 = cert->pkeys[i].x509;
			CRYPTO_add(&ret->pkeys[i].x509->references, 1,
			CRYPTO_LOCK_X509);
		}

		if (cert->pkeys[i].privatekey != NULL) {
			ret->pkeys[i].privatekey = cert->pkeys[i].privatekey;
			CRYPTO_add(&ret->pkeys[i].privatekey->references, 1,
			CRYPTO_LOCK_EVP_PKEY);

			switch (i) {
				/*
				 * If there was anything special to do for
				 * certain types of keys, we'd do it here.
				 * (Nothing at the moment, I think.)
				 */

			case SSL_PKEY_RSA_ENC:
			case SSL_PKEY_RSA_SIGN:
				/* We have an RSA key. */
				break;

			case SSL_PKEY_DH_RSA:
				/* We have a DH key. */
				break;

			case SSL_PKEY_ECC:
				/* We have an ECC key */
				break;

			default:
				/* Can't happen. */
				SSLerrorx(SSL_R_LIBRARY_BUG);
			}
		}
	}

	/*
	 * ret->extra_certs *should* exist, but currently the own certificate
	 * chain is held inside SSL_CTX
	 */

	ret->references = 1;
	/*
	 * Set digests to defaults. NB: we don't copy existing values
	 * as they will be set during handshake.
	 */
	ssl_cert_set_default_md(ret);

	return (ret);

err:
	DH_free(ret->dh_tmp);
	EC_KEY_free(ret->ecdh_tmp);

	for (i = 0; i < SSL_PKEY_NUM; i++) {
		X509_free(ret->pkeys[i].x509);
		EVP_PKEY_free(ret->pkeys[i].privatekey);
	}
	free (ret);
	return NULL;
}


void
ssl_cert_free(CERT *c)
{
	int i;

	if (c == NULL)
		return;

	i = CRYPTO_add(&c->references, -1, CRYPTO_LOCK_SSL_CERT);
	if (i > 0)
		return;

	DH_free(c->dh_tmp);
	EC_KEY_free(c->ecdh_tmp);

	for (i = 0; i < SSL_PKEY_NUM; i++) {
		X509_free(c->pkeys[i].x509);
		EVP_PKEY_free(c->pkeys[i].privatekey);
	}

	free(c);
}

int
ssl_cert_inst(CERT **o)
{
	/*
	 * Create a CERT if there isn't already one
	 * (which cannot really happen, as it is initially created in
	 * SSL_CTX_new; but the earlier code usually allows for that one
	 * being non-existant, so we follow that behaviour, as it might
	 * turn out that there actually is a reason for it -- but I'm
	 * not sure that *all* of the existing code could cope with
	 * s->cert being NULL, otherwise we could do without the
	 * initialization in SSL_CTX_new).
	 */

	if (o == NULL) {
		SSLerrorx(ERR_R_PASSED_NULL_PARAMETER);
		return (0);
	}
	if (*o == NULL) {
		if ((*o = ssl_cert_new()) == NULL) {
			SSLerrorx(ERR_R_MALLOC_FAILURE);
			return (0);
		}
	}
	return (1);
}


SESS_CERT *
ssl_sess_cert_new(void)
{
	SESS_CERT *ret;

	ret = calloc(1, sizeof *ret);
	if (ret == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		return NULL;
	}
	ret->peer_key = &(ret->peer_pkeys[SSL_PKEY_RSA_ENC]);
	ret->references = 1;

	return ret;
}

void
ssl_sess_cert_free(SESS_CERT *sc)
{
	int i;

	if (sc == NULL)
		return;

	i = CRYPTO_add(&sc->references, -1, CRYPTO_LOCK_SSL_SESS_CERT);
	if (i > 0)
		return;

	sk_X509_pop_free(sc->cert_chain, X509_free);
	for (i = 0; i < SSL_PKEY_NUM; i++)
		X509_free(sc->peer_pkeys[i].x509);

	DH_free(sc->peer_dh_tmp);
	EC_KEY_free(sc->peer_ecdh_tmp);
	free(sc->peer_x25519_tmp);

	free(sc);
}

int
ssl_verify_cert_chain(SSL *s, STACK_OF(X509) *sk)
{
	X509_STORE_CTX ctx;
	X509 *x;
	int ret;

	if ((sk == NULL) || (sk_X509_num(sk) == 0))
		return (0);

	x = sk_X509_value(sk, 0);
	if (!X509_STORE_CTX_init(&ctx, s->ctx->cert_store, x, sk)) {
		SSLerror(s, ERR_R_X509_LIB);
		return (0);
	}
	X509_STORE_CTX_set_ex_data(&ctx,
	    SSL_get_ex_data_X509_STORE_CTX_idx(), s);

	/*
	 * We need to inherit the verify parameters. These can be
	 * determined by the context: if its a server it will verify
	 * SSL client certificates or vice versa.
	 */
	X509_STORE_CTX_set_default(&ctx,
	    s->server ? "ssl_client" : "ssl_server");

	/*
	 * Anything non-default in "param" should overwrite anything
	 * in the ctx.
	 */
	X509_VERIFY_PARAM_set1(X509_STORE_CTX_get0_param(&ctx), s->param);

	if (s->internal->verify_callback)
		X509_STORE_CTX_set_verify_cb(&ctx, s->internal->verify_callback);

	if (s->ctx->internal->app_verify_callback != NULL)
		ret = s->ctx->internal->app_verify_callback(&ctx,
		    s->ctx->internal->app_verify_arg);
	else
		ret = X509_verify_cert(&ctx);

	s->verify_result = ctx.error;
	X509_STORE_CTX_cleanup(&ctx);

	return (ret);
}

static void
set_client_CA_list(STACK_OF(X509_NAME) **ca_list,
    STACK_OF(X509_NAME) *name_list)
{
	sk_X509_NAME_pop_free(*ca_list, X509_NAME_free);
	*ca_list = name_list;
}

STACK_OF(X509_NAME) *
SSL_dup_CA_list(STACK_OF(X509_NAME) *sk)
{
	int i;
	STACK_OF(X509_NAME) *ret;
	X509_NAME *name;

	ret = sk_X509_NAME_new_null();
	for (i = 0; i < sk_X509_NAME_num(sk); i++) {
		name = X509_NAME_dup(sk_X509_NAME_value(sk, i));
		if ((name == NULL) || !sk_X509_NAME_push(ret, name)) {
			sk_X509_NAME_pop_free(ret, X509_NAME_free);
			return (NULL);
		}
	}
	return (ret);
}

void
SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list)
{
	set_client_CA_list(&(s->internal->client_CA), name_list);
}

void
SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list)
{
	set_client_CA_list(&(ctx->internal->client_CA), name_list);
}

STACK_OF(X509_NAME) *
SSL_CTX_get_client_CA_list(const SSL_CTX *ctx)
{
	return (ctx->internal->client_CA);
}

STACK_OF(X509_NAME) *
SSL_get_client_CA_list(const SSL *s)
{
	if (s->internal->type == SSL_ST_CONNECT) {
		/* We are in the client. */
		if (((s->version >> 8) == SSL3_VERSION_MAJOR) &&
		    (s->s3 != NULL))
			return (S3I(s)->tmp.ca_names);
		else
			return (NULL);
	} else {
		if (s->internal->client_CA != NULL)
			return (s->internal->client_CA);
		else
			return (s->ctx->internal->client_CA);
	}
}

static int
add_client_CA(STACK_OF(X509_NAME) **sk, X509 *x)
{
	X509_NAME *name;

	if (x == NULL)
		return (0);
	if ((*sk == NULL) && ((*sk = sk_X509_NAME_new_null()) == NULL))
		return (0);

	if ((name = X509_NAME_dup(X509_get_subject_name(x))) == NULL)
		return (0);

	if (!sk_X509_NAME_push(*sk, name)) {
		X509_NAME_free(name);
		return (0);
	}
	return (1);
}

int
SSL_add_client_CA(SSL *ssl, X509 *x)
{
	return (add_client_CA(&(ssl->internal->client_CA), x));
}

int
SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x)
{
	return (add_client_CA(&(ctx->internal->client_CA), x));
}

static int
xname_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
{
	return (X509_NAME_cmp(*a, *b));
}

/*!
 * Load CA certs from a file into a ::STACK. Note that it is somewhat misnamed;
 * it doesn't really have anything to do with clients (except that a common use
 * for a stack of CAs is to send it to the client). Actually, it doesn't have
 * much to do with CAs, either, since it will load any old cert.
 * \param file the file containing one or more certs.
 * \return a ::STACK containing the certs.
 */
STACK_OF(X509_NAME) *
SSL_load_client_CA_file(const char *file)
{
	BIO *in;
	X509 *x = NULL;
	X509_NAME *xn = NULL;
	STACK_OF(X509_NAME) *ret = NULL, *sk;

	sk = sk_X509_NAME_new(xname_cmp);

	in = BIO_new(BIO_s_file_internal());

	if ((sk == NULL) || (in == NULL)) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (!BIO_read_filename(in, file))
		goto err;

	for (;;) {
		if (PEM_read_bio_X509(in, &x, NULL, NULL) == NULL)
			break;
		if (ret == NULL) {
			ret = sk_X509_NAME_new_null();
			if (ret == NULL) {
				SSLerrorx(ERR_R_MALLOC_FAILURE);
				goto err;
			}
		}
		if ((xn = X509_get_subject_name(x)) == NULL) goto err;
			/* check for duplicates */
		xn = X509_NAME_dup(xn);
		if (xn == NULL)
			goto err;
		if (sk_X509_NAME_find(sk, xn) >= 0)
			X509_NAME_free(xn);
		else {
			sk_X509_NAME_push(sk, xn);
			sk_X509_NAME_push(ret, xn);
		}
	}

	if (0) {
err:
		sk_X509_NAME_pop_free(ret, X509_NAME_free);
		ret = NULL;
	}
	sk_X509_NAME_free(sk);
	BIO_free(in);
	X509_free(x);
	if (ret != NULL)
		ERR_clear_error();

	return (ret);
}

/*!
 * Add a file of certs to a stack.
 * \param stack the stack to add to.
 * \param file the file to add from. All certs in this file that are not
 * already in the stack will be added.
 * \return 1 for success, 0 for failure. Note that in the case of failure some
 * certs may have been added to \c stack.
 */

int
SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
    const char *file)
{
	BIO *in;
	X509 *x = NULL;
	X509_NAME *xn = NULL;
	int ret = 1;
	int (*oldcmp)(const X509_NAME * const *a, const X509_NAME * const *b);

	oldcmp = sk_X509_NAME_set_cmp_func(stack, xname_cmp);

	in = BIO_new(BIO_s_file_internal());

	if (in == NULL) {
		SSLerrorx(ERR_R_MALLOC_FAILURE);
		goto err;
	}

	if (!BIO_read_filename(in, file))
		goto err;

	for (;;) {
		if (PEM_read_bio_X509(in, &x, NULL, NULL) == NULL)
			break;
		if ((xn = X509_get_subject_name(x)) == NULL) goto err;
			xn = X509_NAME_dup(xn);
		if (xn == NULL)
			goto err;
		if (sk_X509_NAME_find(stack, xn) >= 0)
			X509_NAME_free(xn);
		else
			sk_X509_NAME_push(stack, xn);
	}

	ERR_clear_error();

	if (0) {
err:
		ret = 0;
	}
	BIO_free(in);
	X509_free(x);

	(void)sk_X509_NAME_set_cmp_func(stack, oldcmp);

	return ret;
}

/*!
 * Add a directory of certs to a stack.
 * \param stack the stack to append to.
 * \param dir the directory to append from. All files in this directory will be
 * examined as potential certs. Any that are acceptable to
 * SSL_add_dir_cert_subjects_to_stack() that are not already in the stack will
 * be included.
 * \return 1 for success, 0 for failure. Note that in the case of failure some
 * certs may have been added to \c stack.
 */

int
SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack, const char *dir)
{
	DIR *dirp = NULL;
	char *path = NULL;
	int ret = 0;

	dirp = opendir(dir);
	if (dirp) {
		struct dirent *dp;
		while ((dp = readdir(dirp)) != NULL) {
			if (asprintf(&path, "%s/%s", dir, dp->d_name) != -1) {
				ret = SSL_add_file_cert_subjects_to_stack(
				    stack, path);
				free(path);
			}
			if (!ret)
				break;
		}
		(void) closedir(dirp);
	}
	if (!ret) {
 		SYSerror(errno);
		ERR_asprintf_error_data("opendir ('%s')", dir);
		SSLerrorx(ERR_R_SYS_LIB);
	}
	return ret;
}
@


1.65
log
@Clean up the EC key/curve configuration handling.

Over the years OpenSSL grew multiple ways of being able to specify EC keys
(and/or curves) for use with ECDH and ECDHE key exchange. You could specify
a static EC key (SSL{_CTX,}_set_tmp_ecdh()), use that as a curve and
generate ephemeral keys (SSL_OP_SINGLE_ECDH_USE), provide the EC key via
a callback that was provided with insufficient information
(SSL{_CTX,}_set_tmp_ecdh_cb()) or enable automatic selection and generation
of EC keys via SSL{_CTX,}_set_ecdh_auto(). This complexity leads to
problems (like ECDHE not being enabled) and potential weird configuration
(like being able to do ECDHE without the ephemeral part...).

We no longer support ECDH and ECDHE can be disabled by removing ECDHE
ciphers from the cipher list. As such, permanently enable automatic EC
curve selection and generation, effectively disabling all of the
configuration knobs. The only exception is the
SSL{_CTX,}_set_tmp_ecdh() functions, which retain part of their previous
behaviour by configuring the curve of the given EC key as the only curve
being enabled. Everything else becomes a no-op.

ok beck@@ doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.64 2017/02/07 02:08:38 beck Exp $ */
a164 1
	cert->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();
a268 4
			case SSL_PKEY_DSA_SIGN:
				/* We have a DSA key. */
				break;

a269 1
			case SSL_PKEY_DH_DSA:
@


1.64
log
@Change SSLerror() back to taking two args, with the first one being an SSL *.
Make a table of "function codes" which maps the internal state of the SSL *
to something like a useful name so in a typical error in the connection you
know in what sort of place in the handshake things happened. (instead of
by arcane function name).
Add SSLerrorx() for when we don't have an SSL *
ok jsing@@ after us both being prodded by bluhm@@ to make it not terrible
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.63 2017/01/29 17:49:23 beck Exp $ */
a244 2
	ret->ecdh_tmp_cb = cert->ecdh_tmp_cb;
	ret->ecdh_tmp_auto = cert->ecdh_tmp_auto;
@


1.63
log
@Send the function codes from the error functions to the bit bucket,
as was done earlier in libssl. Thanks inoguchi@@ for noticing
libssl had more reacharounds into this.
ok jsing@@ inoguchi@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.62 2017/01/26 12:16:13 beck Exp $ */
d181 1
a181 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d198 1
a198 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d215 1
a215 1
			SSLerror(ERR_R_DH_LIB);
d221 1
a221 1
				SSLerror(ERR_R_BN_LIB);
d229 1
a229 1
				SSLerror(ERR_R_BN_LIB);
d241 1
a241 1
			SSLerror(ERR_R_EC_LIB);
d287 1
a287 1
				SSLerror(SSL_R_LIBRARY_BUG);
d357 1
a357 1
		SSLerror(ERR_R_PASSED_NULL_PARAMETER);
d362 1
a362 1
			SSLerror(ERR_R_MALLOC_FAILURE);
d377 1
a377 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d421 1
a421 1
		SSLerror(ERR_R_X509_LIB);
d577 1
a577 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d590 1
a590 1
				SSLerror(ERR_R_MALLOC_FAILURE);
d645 1
a645 1
		SSLerror(ERR_R_MALLOC_FAILURE);
d714 1
a714 1
		SSLerror(ERR_R_SYS_LIB);
@


1.62
log
@Finish the fallout of the SSLerr->SSLerror cleanup to get rid of the ugly
line wraps that resulted
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.61 2017/01/26 10:40:21 beck Exp $ */
d712 1
a712 1
 		SYSerr(SYS_F_OPENDIR, errno);
@


1.61
log
@Send the error function codes to rot in the depths of hell where they belong
We leave a single funciton code (0xFFF) to say "SSL_internal" so the public
API will not break, and we replace all internal use of the two argument
SSL_err() with the internal only SSL_error() that only takes a reason code.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.60 2017/01/24 15:04:12 jsing Exp $ */
d590 1
a590 2
				SSLerror(
				    ERR_R_MALLOC_FAILURE);
d645 1
a645 2
		SSLerror(
		    ERR_R_MALLOC_FAILURE);
@


1.60
log
@sk_free() checks for NULL so do not bother doing it from the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.59 2017/01/24 14:57:31 jsing Exp $ */
d181 1
a181 1
		SSLerr(SSL_F_SSL_CERT_NEW, ERR_R_MALLOC_FAILURE);
d198 1
a198 1
		SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);
d215 1
a215 1
			SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_DH_LIB);
d221 1
a221 1
				SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);
d229 1
a229 1
				SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);
d241 1
a241 1
			SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_EC_LIB);
d287 1
a287 1
				SSLerr(SSL_F_SSL_CERT_DUP, SSL_R_LIBRARY_BUG);
d357 1
a357 1
		SSLerr(SSL_F_SSL_CERT_INST, ERR_R_PASSED_NULL_PARAMETER);
d362 1
a362 1
			SSLerr(SSL_F_SSL_CERT_INST, ERR_R_MALLOC_FAILURE);
d377 1
a377 1
		SSLerr(SSL_F_SSL_SESS_CERT_NEW, ERR_R_MALLOC_FAILURE);
d421 1
a421 1
		SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN, ERR_R_X509_LIB);
d577 1
a577 1
		SSLerr(SSL_F_SSL_LOAD_CLIENT_CA_FILE, ERR_R_MALLOC_FAILURE);
d590 1
a590 1
				SSLerr(SSL_F_SSL_LOAD_CLIENT_CA_FILE,
d646 1
a646 1
		SSLerr(SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK,
d716 1
a716 1
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB);
@


1.59
log
@sk_pop_free() checks for NULL so do not bother doing it from the callers.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.58 2017/01/23 06:45:30 beck Exp $ */
d613 1
a613 2
	if (sk != NULL)
		sk_X509_NAME_free(sk);
d618 1
@


1.58
log
@Move a large part of ssl_st into internal, so we can see what squeals.
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.57 2017/01/23 05:13:02 jsing Exp $ */
d398 1
a398 3
	/* i == 0 */
	if (sc->cert_chain != NULL)
		sk_X509_pop_free(sc->cert_chain, X509_free);
d460 1
a460 3
	if (*ca_list != NULL)
		sk_X509_NAME_pop_free(*ca_list, X509_NAME_free);

d610 1
a610 2
		if (ret != NULL)
			sk_X509_NAME_pop_free(ret, X509_NAME_free);
@


1.57
log
@Move most of the fields in SSL_CTX to internal - the ones that remain are
known to be in use.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.56 2017/01/23 04:55:27 beck Exp $ */
d489 1
a489 1
	set_client_CA_list(&(s->client_CA), name_list);
d507 1
a507 1
	if (s->type == SSL_ST_CONNECT) {
d515 2
a516 2
		if (s->client_CA != NULL)
			return (s->client_CA);
d545 1
a545 1
	return (add_client_CA(&(ssl->client_CA), x));
@


1.56
log
@move the callbacks from ssl_st to internal
ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.55 2017/01/23 04:15:28 jsing Exp $ */
d495 1
a495 1
	set_client_CA_list(&(ctx->client_CA), name_list);
d501 1
a501 1
	return (ctx->client_CA);
d518 1
a518 1
			return (s->ctx->client_CA);
d551 1
a551 1
	return (add_client_CA(&(ctx->client_CA), x));
@


1.55
log
@Move callback function pointers and argument pointers from SSL_CTX to
internal.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.54 2017/01/22 09:02:07 jsing Exp $ */
d443 2
a444 2
	if (s->verify_callback)
		X509_STORE_CTX_set_verify_cb(&ctx, s->verify_callback);
@


1.54
log
@Move most of the SSL3_STATE fields to internal - the ones that remain are
known to be used by ports.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.53 2016/12/21 16:44:31 jsing Exp $ */
d446 3
a448 2
	if (s->ctx->app_verify_callback != NULL)
		ret = s->ctx->app_verify_callback(&ctx, s->ctx->app_verify_arg);
@


1.53
log
@Add support for ECDHE with X25519.

Testing of an earlier revision by naddy@@.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.52 2016/03/11 07:08:45 mmcc Exp $ */
d510 1
a510 1
			return (s->s3->tmp.ca_names);
@


1.52
log
@X509_free(3) is NULL-safe, so remove NULL checks before its calls.

ok doug@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.51 2015/09/11 17:37:47 jsing Exp $ */
d406 1
@


1.51
log
@Nuke ssl_set_peer_cert_type().

ok "flensing knife"
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.50 2015/04/06 04:09:59 guenther Exp $ */
d311 1
a311 2
		if (ret->pkeys[i].x509 != NULL)
			X509_free(ret->pkeys[i].x509);
d335 1
a335 2
		if (c->pkeys[i].x509 != NULL)
			X509_free(c->pkeys[i].x509);
d401 2
a402 4
	for (i = 0; i < SSL_PKEY_NUM; i++) {
		if (sc->peer_pkeys[i].x509 != NULL)
			X509_free(sc->peer_pkeys[i].x509);
	}
d619 1
a619 2
	if (x != NULL)
		X509_free(x);
d677 1
a677 2
	if (x != NULL)
		X509_free(x);
@


1.50
log
@readdir() is thread-safe when DIR handles aren't shared, so delete the lock.
(POSIX is fixing its description: readdir_r() was a botch)

Patch from Carlos Martín Nieto (cmn (at) dwim.me)
no -portable concerns bcook@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.49 2014/12/14 15:30:50 jsing Exp $ */
a411 7
}

int
ssl_set_peer_cert_type(SESS_CERT *sc, int type)
{
	sc->peer_cert_type = type;
	return (1);
@


1.49
log
@Remove trailing whitespace.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.48 2014/12/10 15:36:47 jsing Exp $ */
a714 1
	CRYPTO_w_lock(CRYPTO_LOCK_READDIR);
a733 1
	CRYPTO_w_unlock(CRYPTO_LOCK_READDIR);
@


1.48
log
@Remove support for GOST R 34.10-94 signature authentication, along with
the two ciphersuites that use it. GOST94 public/private keys have been
long obsoleted and libcrypto does not have support for them anyway.

Discussed with Dmitry Eremin-Solenikov.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.47 2014/12/06 14:24:26 jsing Exp $ */
d8 1
a8 1
 * 
d15 1
a15 1
 * 
d22 1
a22 1
 * 
d37 1
a37 1
 * 4. If you include any Windows specific code (or a derivative thereof) from 
d40 1
a40 1
 * 
d52 1
a52 1
 * 
d66 1
a66 1
 *    notice, this list of conditions and the following disclaimer. 
d113 1
a113 1
 * ECC cipher suite support in OpenSSL originally developed by 
@


1.47
log
@Remove client handling of RSA in ServerKeyExchange messages, along with
the associated peer_rsa_tmp goop.

This was only needed for export cipher handling and intentional RFC
violations. The export cipher suites have already been removed and
previous cleanup means that we will never send ServerKeyExchange messages
from the server side for RSA.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.46 2014/11/18 05:33:43 miod Exp $ */
a169 1
	cert->pkeys[SSL_PKEY_GOST94].digest = EVP_gostr341194();
@


1.46
log
@Update the GOST code in libssl, as contributed by Dmitry Eremin-Solenikov.

This causes a libssl major version bump as this affects the layout of some
internal-but-unfortunately-made-visible structs.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.45 2014/11/16 14:12:47 jsing Exp $ */
a408 1
	RSA_free(sc->peer_rsa_tmp);
@


1.45
log
@Sort and group includes.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.44 2014/10/31 15:25:55 jsing Exp $ */
d169 4
@


1.44
log
@Add support for automatic DH ephemeral keys.

This allows an SSL server to enable DHE ciphers with a single setting,
which results in an DH key being generated based on the server key length.

Partly based on OpenSSL.
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.43 2014/10/31 14:51:01 jsing Exp $ */
d119 1
a121 1
#include <dirent.h>
d123 4
a127 2
#include <openssl/objects.h>
#include <openssl/bio.h>
d130 1
a130 2
#include <openssl/dh.h>
#include <openssl/bn.h>
@


1.43
log
@Remove support for ephemeral/temporary RSA private keys.

The only use for these is via SSL_OP_EPHEMERAL_RSA (which is effectively
a standards violation) and for RSA sign-only, should only be possible if
you are using an export cipher and have an RSA private key that is more
than 512 bits in size (however we no longer support export ciphers).

ok bcook@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.42 2014/10/03 13:58:18 jsing Exp $ */
d232 1
@


1.42
log
@Add support for automatic ephemeral EC keys.

This allows an SSL server to enable ECDHE ciphers with a single setting,
which results in an EC key being generated using the first preference
shared curve.

Based on OpenSSL with inspiration from boringssl.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.41 2014/07/10 08:25:00 guenther Exp $ */
a207 6
	if (cert->rsa_tmp != NULL) {
		RSA_up_ref(cert->rsa_tmp);
		ret->rsa_tmp = cert->rsa_tmp;
	}
	ret->rsa_tmp_cb = cert->rsa_tmp_cb;

a301 1
	RSA_free(ret->rsa_tmp);
a326 1
	RSA_free(c->rsa_tmp);
@


1.41
log
@KNF comments, reflowing and moving out of the middle of argument lists in
places

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.40 2014/07/09 11:25:42 jsing Exp $ */
d247 1
@


1.41.4.1
log
@backport fixes to prevent connections from being downgraded to weak keys.
ok bluhm miod
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.41 2014/07/10 08:25:00 guenther Exp $ */
d410 1
@


1.40
log
@tedu the SSL export cipher handling - since we do not have enabled export
ciphers we no longer need the flags or code to support it.

ok beck@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.39 2014/06/21 09:10:30 logan Exp $ */
d198 4
a202 2
	/* or ret->key = ret->pkeys + (cert->key - cert->pkeys),
	 * if you find that more readable */
d261 2
a262 1
				/* If there was anything special to do for
d264 2
a265 1
				 * (Nothing at the moment, I think.) */
d292 4
a295 2
	/* ret->extra_certs *should* exist, but currently the own certificate
	 * chain is held inside SSL_CTX */
d298 3
a300 2
	/* Set digests to defaults. NB: we don't copy existing values as they
	 * will be set during handshake.
d349 2
a350 1
	/* Create a CERT if there isn't already one
d442 4
a445 3
	/* We need to inherit the verify parameters. These can be determined by
	 * the context: if its a server it will verify SSL client certificates
	 * or vice versa.
a446 1

d450 3
a452 2
	/* Anything non-default in "param" should overwrite anything in the
	 * ctx.
@


1.39
log
@Fix memory leak in error path.

OK from miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ssl_cert.c,v 1.38 2014/06/12 15:49:31 deraadt Exp $ */
a204 2
	ret->export_mask_k = cert->export_mask_k;
	ret->export_mask_a = cert->export_mask_a;
@


1.38
log
@tags as requested by miod and tedu
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d311 1
a311 1

@


1.37
log
@No, we will not be building with OPENSSL_NO_X509_VERIFY. Nuke it and
do some other clean up while here.

ok deraadt@@
@
text
@d1 1
a1 1
/*! \file ssl/ssl_cert.c */
@


1.36
log
@BIO_free has an implicit NULL check, so do not bother checking for NULL
before calling it.
@
text
@d421 1
d423 1
a423 2
	int i;
	X509_STORE_CTX ctx;
d442 2
a443 1
	s->server ? "ssl_client" : "ssl_server");
d453 3
a455 10
		i = s->ctx->app_verify_callback(&ctx, s->ctx->app_verify_arg);
	else {
#ifndef OPENSSL_NO_X509_VERIFY
		i = X509_verify_cert(&ctx);
#else
		i = 0;
		ctx.error = X509_V_ERR_APPLICATION_VERIFICATION;
		SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN, SSL_R_NO_VERIFY_CALLBACK);
#endif
	}
d460 1
a460 1
	return (i);
@


1.35
log
@The DH_free, EC_KEY_free, EVP_PKEY_free and RSA_free functions all have
implicit NULL checks, so there is no point ensuring that the pointer is
non-NULL before calling them.
@
text
@d631 1
a631 2
	if (in != NULL)
		BIO_free(in);
d690 1
a690 2
	if (in != NULL)
		BIO_free(in);
@


1.34
log
@More KNF.
@
text
@d302 3
a304 6
	if (ret->rsa_tmp != NULL)
		RSA_free(ret->rsa_tmp);
	if (ret->dh_tmp != NULL)
		DH_free(ret->dh_tmp);
	if (ret->ecdh_tmp != NULL)
		EC_KEY_free(ret->ecdh_tmp);
d309 1
a309 2
		if (ret->pkeys[i].privatekey != NULL)
			EVP_PKEY_free(ret->pkeys[i].privatekey);
d328 3
a330 6
	if (c->rsa_tmp)
		RSA_free(c->rsa_tmp);
	if (c->dh_tmp)
		DH_free(c->dh_tmp);
	if (c->ecdh_tmp)
		EC_KEY_free(c->ecdh_tmp);
d335 1
a335 2
		if (c->pkeys[i].privatekey != NULL)
			EVP_PKEY_free(c->pkeys[i].privatekey);
d337 1
d404 3
a406 6
	if (sc->peer_rsa_tmp != NULL)
		RSA_free(sc->peer_rsa_tmp);
	if (sc->peer_dh_tmp != NULL)
		DH_free(sc->peer_dh_tmp);
	if (sc->peer_ecdh_tmp != NULL)
		EC_KEY_free(sc->peer_ecdh_tmp);
@


1.33
log
@remove some #if 0 code. we don't need any more reminders that we're using
a not quite appropriate data structure. ok jsing
@
text
@d146 3
a148 2
			ssl_x509_store_ctx_idx = X509_STORE_CTX_get_ex_new_index(
			0, "SSL for verify callback", NULL, NULL, NULL);
d443 2
a444 1
	X509_STORE_CTX_set_ex_data(&ctx, SSL_get_ex_data_X509_STORE_CTX_idx(), s);
d480 2
a481 1
set_client_CA_list(STACK_OF(X509_NAME) **ca_list, STACK_OF(X509_NAME) *name_list)
d528 2
a529 2
	if (s->type == SSL_ST_CONNECT)
			{ /* we are in the client */
d531 2
a532 2
			(s->s3 != NULL))
		return (s->s3->tmp.ca_names);
d615 2
a616 1
				SSLerr(SSL_F_SSL_LOAD_CLIENT_CA_FILE, ERR_R_MALLOC_FAILURE);
d674 2
a675 1
		SSLerr(SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK, ERR_R_MALLOC_FAILURE);
d716 2
a717 2
 * SSL_add_dir_cert_subjects_to_stack() that are not already in the stack will be
 * included.
d723 1
a723 2
SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
    const char *dir)
d732 1
a732 1
		struct dirent * dp;
d735 2
a736 2
				ret = SSL_add_file_cert_subjects_to_stack
				    (stack,path);
d747 1
a747 2
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,
		    ERR_R_SYS_LIB);
@


1.32
log
@Any sane platform has stdio. Stop pretending we will ever use a platform
that does not.
"fire bomb" tedu@@
@
text
@a342 4
#if 0
		if (c->pkeys[i].publickey != NULL)
			EVP_PKEY_free(c->pkeys[i].publickey);
#endif
a407 6
#if 0 /* We don't have the peer's private key.  These lines are just
       * here as a reminder that we're still using a not-quite-appropriate
       * data structure. */
		if (sc->peer_pkeys[i].privatekey != NULL)
			EVP_PKEY_free(sc->peer_pkeys[i].privatekey);
#endif
a441 4
#if 0
	if (SSL_get_verify_depth(s) >= 0)
		X509_STORE_CTX_set_depth(&ctx, SSL_get_verify_depth(s));
#endif
@


1.31
log
@unidef DH, ECDH, and ECDSA. there's no purpose to a libssl without them.
ok deraadt jsing
@
text
@a591 1
#ifndef OPENSSL_NO_STDIO
a658 1
#endif
@


1.30
log
@We don't really to keep history in constructs such as:

#if 1 /* new with openssl 0.9.4 */
current code;
#else
obsolete code;
#endif
@
text
@a127 1
#ifndef OPENSSL_NO_DH
a128 1
#endif
a165 1
#ifndef OPENSSL_NO_ECDSA
a166 1
#endif
a212 1
#ifndef OPENSSL_NO_DH
a236 1
#endif
a237 1
#ifndef OPENSSL_NO_ECDH
a245 1
#endif
a299 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_ECDH)
a300 1
#endif
a302 1
#ifndef OPENSSL_NO_DH
a304 2
#endif
#ifndef OPENSSL_NO_ECDH
a306 1
#endif
a332 1
#ifndef OPENSSL_NO_DH
a334 2
#endif
#ifndef OPENSSL_NO_ECDH
a336 1
#endif
a421 1
#ifndef OPENSSL_NO_DH
a423 2
#endif
#ifndef OPENSSL_NO_ECDH
a425 1
#endif
@


1.29
log
@There are two actual uses of e_os2.h in libssl - an OPENSSL_GLOBAL (an
empty define) and an OPENSSL_EXTERN (which is defined as, well... extern).
The use of OPENSSL_EXTERN is already inconsistent since the lines above
and below just use plain old "extern". Expand the two uses of these macros
and stop including e_os2.h in libssl.

ok miod@@
@
text
@d496 1
a496 6
#if 1 /* new with OpenSSL 0.9.7 */
	i = s->ctx->app_verify_callback(&ctx, s->ctx->app_verify_arg);

#else
	i=s->ctx->app_verify_callback(&ctx); /* should pass app_verify_arg */
#endif
@


1.28
log
@Replace all use of ERR_add_error_data with ERR_asprintf_error_data.
This avoids a lot of ugly gymnastics to do snprintfs before sending the
bag of strings to ERR, and eliminates at least one place in dso_dlfctn.c
where it was being called with the incorrect number of arguments and
using random things off the stack as addresses of strings.
ok krw@@, jsing@@
@
text
@a123 1
#include <openssl/e_os2.h>
@


1.27
log
@more malloc/realloc/calloc cleanups; ok beck kettenis
@
text
@d786 1
a786 1
		ERR_add_error_data(3, "opendir ('", dir, "')");
@


1.26
log
@More KNF and style consistency tweaks
@
text
@d179 1
a179 1
	ret = (CERT *)malloc(sizeof(CERT));
a183 2
	memset(ret, 0, sizeof(CERT));

d196 1
a196 1
	ret = (CERT *)malloc(sizeof(CERT));
a201 2
	memset(ret, 0, sizeof(CERT));

d402 1
a402 1
	ret = malloc(sizeof *ret);
a406 2

	memset(ret, 0 , sizeof *ret);
@


1.25
log
@always build in RSA and DSA. ok deraadt miod
@
text
@d174 2
a175 2
CERT
*ssl_cert_new(void)
d192 2
a193 2
CERT
*ssl_cert_dup(CERT *cert)
d401 2
a402 2
SESS_CERT
*ssl_sess_cert_new(void)
d534 2
a535 2
STACK_OF(X509_NAME)
*SSL_dup_CA_list(STACK_OF(X509_NAME) *sk)
d564 2
a565 2
STACK_OF(X509_NAME)
*SSL_CTX_get_client_CA_list(const SSL_CTX *ctx)
d570 2
a571 2
STACK_OF(X509_NAME)
*SSL_get_client_CA_list(const SSL *s)
d635 2
a636 2
STACK_OF(X509_NAME)
*SSL_load_client_CA_file(const char *file)
@


1.24
log
@kill REF_PRINT/REF_CHECK debugging framework noone would use
ok miod
@
text
@a165 1
#ifndef OPENSSL_NO_DSA
a166 2
#endif
#ifndef OPENSSL_NO_RSA
a168 1
#endif
a215 1
#ifndef OPENSSL_NO_RSA
a220 1
#endif
a315 1
#ifndef OPENSSL_NO_RSA
a317 1
#endif
a349 1
#ifndef OPENSSL_NO_RSA
a351 1
#endif
a444 1
#ifndef OPENSSL_NO_RSA
a446 1
#endif
@


1.23
log
@Change library to use intrinsic memory allocation functions instead of
OPENSSL_foo wrappers. This changes:
OPENSSL_malloc->malloc
OPENSSL_free->free
OPENSSL_relloc->realloc
OPENSSL_freeFunc->free
@
text
@a354 3
#ifdef REF_PRINT
	REF_PRINT("CERT", c);
#endif
a356 6
#ifdef REF_CHECK
	if (i < 0) {
		fprintf(stderr, "ssl_cert_free, bad reference count\n");
		abort(); /* ok */
	}
#endif
a437 3
#ifdef REF_PRINT
	REF_PRINT("SESS_CERT", sc);
#endif
a439 6
#ifdef REF_CHECK
	if (i < 0) {
		fprintf(stderr, "ssl_sess_cert_free, bad reference count\n");
		abort(); /* ok */
	}
#endif
@


1.22
log
@o_dir.c had a very funny odor. all users of this now use standard functions.
consign it to the Attic.
ok deraadt@@
@
text
@d183 1
a183 1
	ret = (CERT *)OPENSSL_malloc(sizeof(CERT));
d202 1
a202 1
	ret = (CERT *)OPENSSL_malloc(sizeof(CERT));
d390 1
a390 1
	OPENSSL_free(c);
d425 1
a425 1
	ret = OPENSSL_malloc(sizeof *ret);
d486 1
a486 1
	OPENSSL_free(sc);
@


1.21
log
@convert the use of OPENSSL_DIR_XXX functions to opendir() and frends.
ok deraadt@@
@
text
@a124 1
#include "o_dir.h"
@


1.20
log
@First pass at applying KNF to the OpenSSL code, which almost makes it
readable. This pass is whitespace only and can readily be verified using
tr and md5.
@
text
@d121 1
d802 2
a803 2
	OPENSSL_DIR_CTX *d = NULL;
	const char *filename;
d807 11
a817 10

	/* Note that a side effect is that the CAs will be sorted by name */

	while ((filename = OPENSSL_DIR_read(&d, dir))) {
		char buf[1024];
		int r;

		if (strlen(dir) + strlen(filename) + 2 > sizeof buf) {
			SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, SSL_R_PATH_TOO_LONG);
			goto err;
d819 1
a819 5
		r = BIO_snprintf(buf, sizeof buf, "%s/%s", dir, filename);
		if (r <= 0 || r >= (int)sizeof(buf))
			goto err;
		if (!SSL_add_file_cert_subjects_to_stack(stack, buf))
			goto err;
d821 5
a825 6

	if (errno) {
		SYSerr(SYS_F_OPENDIR, errno);
		ERR_add_error_data(3, "OPENSSL_DIR_read(&ctx, '", dir, "')");
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB);
		goto err;
a826 6

	ret = 1;

err:
	if (d)
		OPENSSL_DIR_end(&d);
a829 1

@


1.19
log
@Remove vms support stuff.
ok deraadt@@
@
text
@d135 4
a138 3
int SSL_get_ex_data_X509_STORE_CTX_idx(void)
	{
	static volatile int ssl_x509_store_ctx_idx= -1;
d143 1
a143 2
	if (ssl_x509_store_ctx_idx < 0)
		{
d147 4
a150 6
		
		if (ssl_x509_store_ctx_idx < 0)
			{
			ssl_x509_store_ctx_idx=X509_STORE_CTX_get_ex_new_index(
				0,"SSL for verify callback",NULL,NULL,NULL);
			}
d152 1
d158 1
a158 1
	
d160 1
a160 1
	}
d162 3
a164 2
static void ssl_cert_set_default_md(CERT *cert)
	{
d176 1
a176 1
	}
d178 3
a180 2
CERT *ssl_cert_new(void)
	{
d183 6
a188 7
	ret=(CERT *)OPENSSL_malloc(sizeof(CERT));
	if (ret == NULL)
		{
		SSLerr(SSL_F_SSL_CERT_NEW,ERR_R_MALLOC_FAILURE);
		return(NULL);
		}
	memset(ret,0,sizeof(CERT));
d190 2
a191 2
	ret->key= &(ret->pkeys[SSL_PKEY_RSA_ENC]);
	ret->references=1;
d193 2
a194 2
	return(ret);
	}
d196 3
a198 2
CERT *ssl_cert_dup(CERT *cert)
	{
d203 1
a203 2
	if (ret == NULL)
		{
d205 2
a206 2
		return(NULL);
		}
d221 1
a221 2
	if (cert->rsa_tmp != NULL)
		{
d224 1
a224 1
		}
d229 1
a229 2
	if (cert->dh_tmp != NULL)
		{
d231 1
a231 2
		if (ret->dh_tmp == NULL)
			{
d234 2
a235 3
			}
		if (cert->dh_tmp->priv_key)
			{
d237 1
a237 2
			if (!b)
				{
d240 1
a240 1
				}
d242 2
a243 3
			}
		if (cert->dh_tmp->pub_key)
			{
d245 1
a245 2
			if (!b)
				{
d248 1
a248 1
				}
a249 1
			}
d251 1
d256 1
a256 2
	if (cert->ecdh_tmp)
		{
d258 1
a258 2
		if (ret->ecdh_tmp == NULL)
			{
a260 1
			}
d262 1
d266 2
a267 4
	for (i = 0; i < SSL_PKEY_NUM; i++)
		{
		if (cert->pkeys[i].x509 != NULL)
			{
d270 4
a273 5
				CRYPTO_LOCK_X509);
			}
		
		if (cert->pkeys[i].privatekey != NULL)
			{
d276 1
a276 1
				CRYPTO_LOCK_EVP_PKEY);
d278 1
a278 2
			switch(i) 
				{
d287 1
a287 1
				
d291 1
a291 1
				
a303 1
				}
d306 2
a307 1
	
d311 1
a311 1
	ret->references=1;
d317 2
a318 2
	return(ret);
	
d335 1
a335 2
	for (i = 0; i < SSL_PKEY_NUM; i++)
		{
d340 1
a340 1
		}
d343 1
a343 1
	}
d346 3
a348 2
void ssl_cert_free(CERT *c)
	{
d351 2
a352 2
	if(c == NULL)
	    return;
d354 1
a354 1
	i=CRYPTO_add(&c->references,-1,CRYPTO_LOCK_SSL_CERT);
d356 1
a356 1
	REF_PRINT("CERT",c);
d358 2
a359 1
	if (i > 0) return;
d361 2
a362 3
	if (i < 0)
		{
		fprintf(stderr,"ssl_cert_free, bad reference count\n");
d364 1
a364 1
		}
d368 2
a369 1
	if (c->rsa_tmp) RSA_free(c->rsa_tmp);
d372 2
a373 1
	if (c->dh_tmp) DH_free(c->dh_tmp);
d376 2
a377 1
	if (c->ecdh_tmp) EC_KEY_free(c->ecdh_tmp);
d380 1
a380 2
	for (i=0; i<SSL_PKEY_NUM; i++)
		{
d389 1
a389 1
		}
d391 1
a391 1
	}
d393 3
a395 2
int ssl_cert_inst(CERT **o)
	{
d405 2
a406 3
	
	if (o == NULL) 
		{
d408 4
a411 6
		return(0);
		}
	if (*o == NULL)
		{
		if ((*o = ssl_cert_new()) == NULL)
			{
d413 1
a413 2
			return(0);
			}
a414 1
	return(1);
d416 2
d420 3
a422 2
SESS_CERT *ssl_sess_cert_new(void)
	{
d426 1
a426 2
	if (ret == NULL)
		{
d429 1
a429 1
		}
d431 1
a431 1
	memset(ret, 0 ,sizeof *ret);
d436 1
a436 1
	}
d438 3
a440 2
void ssl_sess_cert_free(SESS_CERT *sc)
	{
d453 2
a454 3
	if (i < 0)
		{
		fprintf(stderr,"ssl_sess_cert_free, bad reference count\n");
d456 1
a456 1
		}
d462 1
a462 2
	for (i = 0; i < SSL_PKEY_NUM; i++)
		{
d466 2
a467 2
	   * here as a reminder that we're still using a not-quite-appropriate
	   * data structure. */
d471 1
a471 1
		}
d487 1
a487 1
	}
d489 3
a491 2
int ssl_set_peer_cert_type(SESS_CERT *sc,int type)
	{
d493 2
a494 2
	return(1);
	}
d496 3
a498 2
int ssl_verify_cert_chain(SSL *s,STACK_OF(X509) *sk)
	{
d504 1
a504 1
		return(0);
d506 5
a510 6
	x=sk_X509_value(sk,0);
	if(!X509_STORE_CTX_init(&ctx,s->ctx->cert_store,x,sk))
		{
		SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN,ERR_R_X509_LIB);
		return(0);
		}
d515 1
a515 1
	X509_STORE_CTX_set_ex_data(&ctx,SSL_get_ex_data_X509_STORE_CTX_idx(),s);
d523 1
a523 1
				s->server ? "ssl_client" : "ssl_server");
d534 2
a535 1
		i=s->ctx->app_verify_callback(&ctx, s->ctx->app_verify_arg); 
d537 1
a537 1
		i=s->ctx->app_verify_callback(&ctx); /* should pass app_verify_arg */
d539 1
a539 2
	else
		{
d541 1
a541 1
		i=X509_verify_cert(&ctx);
d543 3
a545 3
		i=0;
		ctx.error=X509_V_ERR_APPLICATION_VERIFICATION;
		SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN,SSL_R_NO_VERIFY_CALLBACK);
d547 1
a547 1
		}
d549 1
a549 1
	s->verify_result=ctx.error;
d552 2
a553 2
	return(i);
	}
d555 3
a557 2
static void set_client_CA_list(STACK_OF(X509_NAME) **ca_list,STACK_OF(X509_NAME) *name_list)
	{
d559 1
a559 1
		sk_X509_NAME_pop_free(*ca_list,X509_NAME_free);
d561 2
a562 2
	*ca_list=name_list;
	}
d564 3
a566 2
STACK_OF(X509_NAME) *SSL_dup_CA_list(STACK_OF(X509_NAME) *sk)
	{
d571 32
a602 30
	ret=sk_X509_NAME_new_null();
	for (i=0; i<sk_X509_NAME_num(sk); i++)
		{
		name=X509_NAME_dup(sk_X509_NAME_value(sk,i));
		if ((name == NULL) || !sk_X509_NAME_push(ret,name))
			{
			sk_X509_NAME_pop_free(ret,X509_NAME_free);
			return(NULL);
			}
		}
	return(ret);
	}

void SSL_set_client_CA_list(SSL *s,STACK_OF(X509_NAME) *name_list)
	{
	set_client_CA_list(&(s->client_CA),name_list);
	}

void SSL_CTX_set_client_CA_list(SSL_CTX *ctx,STACK_OF(X509_NAME) *name_list)
	{
	set_client_CA_list(&(ctx->client_CA),name_list);
	}

STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx)
	{
	return(ctx->client_CA);
	}

STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s)
	{
d604 2
a605 2
		{ /* we are in the client */
		if (((s->version>>8) == SSL3_VERSION_MAJOR) &&
d607 1
a607 1
			return(s->s3->tmp.ca_names);
d609 2
a610 4
			return(NULL);
		}
	else
		{
d612 1
a612 1
			return(s->client_CA);
d614 1
a614 2
			return(s->ctx->client_CA);
		}
d616 1
d618 3
a620 2
static int add_client_CA(STACK_OF(X509_NAME) **sk,X509 *x)
	{
d623 7
a629 6
	if (x == NULL) return(0);
	if ((*sk == NULL) && ((*sk=sk_X509_NAME_new_null()) == NULL))
		return(0);
		
	if ((name=X509_NAME_dup(X509_get_subject_name(x))) == NULL)
		return(0);
d631 1
a631 2
	if (!sk_X509_NAME_push(*sk,name))
		{
d633 1
a633 3
		return(0);
		}
	return(1);
d635 2
d638 17
a654 14
int SSL_add_client_CA(SSL *ssl,X509 *x)
	{
	return(add_client_CA(&(ssl->client_CA),x));
	}

int SSL_CTX_add_client_CA(SSL_CTX *ctx,X509 *x)
	{
	return(add_client_CA(&(ctx->client_CA),x));
	}

static int xname_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
	{
	return(X509_NAME_cmp(*a,*b));
	}
d665 3
a667 2
STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file)
	{
d669 3
a671 3
	X509 *x=NULL;
	X509_NAME *xn=NULL;
	STACK_OF(X509_NAME) *ret = NULL,*sk;
d673 1
a673 1
	sk=sk_X509_NAME_new(xname_cmp);
d675 1
a675 1
	in=BIO_new(BIO_s_file_internal());
d677 2
a678 3
	if ((sk == NULL) || (in == NULL))
		{
		SSLerr(SSL_F_SSL_LOAD_CLIENT_CA_FILE,ERR_R_MALLOC_FAILURE);
d680 3
a682 3
		}
	
	if (!BIO_read_filename(in,file))
d685 2
a686 3
	for (;;)
		{
		if (PEM_read_bio_X509(in,&x,NULL,NULL) == NULL)
d688 1
a688 2
		if (ret == NULL)
			{
d690 2
a691 3
			if (ret == NULL)
				{
				SSLerr(SSL_F_SSL_LOAD_CLIENT_CA_FILE,ERR_R_MALLOC_FAILURE);
a692 1
				}
d694 7
a700 5
		if ((xn=X509_get_subject_name(x)) == NULL) goto err;
		/* check for duplicates */
		xn=X509_NAME_dup(xn);
		if (xn == NULL) goto err;
		if (sk_X509_NAME_find(sk,xn) >= 0)
d702 3
a704 5
		else
			{
			sk_X509_NAME_push(sk,xn);
			sk_X509_NAME_push(ret,xn);
			}
d706 1
d708 1
a708 2
	if (0)
		{
d710 10
a719 6
		if (ret != NULL) sk_X509_NAME_pop_free(ret,X509_NAME_free);
		ret=NULL;
		}
	if (sk != NULL) sk_X509_NAME_free(sk);
	if (in != NULL) BIO_free(in);
	if (x != NULL) X509_free(x);
d722 2
a723 2
	return(ret);
	}
d735 4
a738 3
int SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
					const char *file)
	{
d740 3
a742 3
	X509 *x=NULL;
	X509_NAME *xn=NULL;
	int ret=1;
d744 7
a750 8
	
	oldcmp=sk_X509_NAME_set_cmp_func(stack,xname_cmp);
	
	in=BIO_new(BIO_s_file_internal());
	
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK,ERR_R_MALLOC_FAILURE);
d752 3
a754 3
		}
	
	if (!BIO_read_filename(in,file))
d756 3
a758 4
	
	for (;;)
		{
		if (PEM_read_bio_X509(in,&x,NULL,NULL) == NULL)
d760 5
a764 4
		if ((xn=X509_get_subject_name(x)) == NULL) goto err;
		xn=X509_NAME_dup(xn);
		if (xn == NULL) goto err;
		if (sk_X509_NAME_find(stack,xn) >= 0)
d767 2
a768 2
			sk_X509_NAME_push(stack,xn);
		}
d772 1
a772 2
	if (0)
		{
d774 3
a776 3
		ret=0;
		}
	if(in != NULL)
d778 1
a778 1
	if(x != NULL)
d780 2
a781 2
	
	(void)sk_X509_NAME_set_cmp_func(stack,oldcmp);
d784 1
a784 1
	}
d797 4
a800 3
int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
				       const char *dir)
	{
d809 1
a809 2
	while((filename = OPENSSL_DIR_read(&d, dir)))
		{
d813 2
a814 3
		if(strlen(dir)+strlen(filename)+2 > sizeof buf)
			{
			SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
d816 2
a817 2
			}
		r = BIO_snprintf(buf,sizeof buf,"%s/%s",dir,filename);
d820 1
a820 1
		if(!SSL_add_file_cert_subjects_to_stack(stack,buf))
d822 1
a822 1
		}
d824 1
a824 2
	if (errno)
		{
d829 1
a829 1
		}
d834 2
a835 1
	if (d) OPENSSL_DIR_end(&d);
d838 1
a838 1
	}
@


1.18
log
@Do not include "e_os.h" anymore.  Simply pull in the necessary headers.

ok miod@@, deraadt@@
@
text
@a825 4

#ifdef OPENSSL_SYS_VMS
		r = BIO_snprintf(buf,sizeof buf,"%s%s",dir,filename);
#else
a826 1
#endif
@


1.17
log
@Merge conflicts; remove MacOS, Netware, OS/2, VMS and Windows build machinery.
@
text
@d117 2
d120 1
d122 2
a123 5
#include "e_os.h"
#ifndef NO_SYS_TYPES_H
# include <sys/types.h>
#endif

d840 1
a840 1
		SYSerr(SYS_F_OPENDIR, get_last_sys_error());
@


1.16
log
@resolve conflicts
@
text
@d167 1
a167 1
	cert->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_dss1();
d174 1
a174 1
	cert->pkeys[SSL_PKEY_ECC].digest = EVP_ecdsa();
@


1.15
log
@resolve conflicts, fix local changes
@
text
@d163 15
d192 1
a192 1

d325 4
@


1.14
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d200 4
a203 2
	ret->mask = cert->mask;
	ret->export_mask = cert->export_mask;
a504 3
	if (s->param)
		X509_VERIFY_PARAM_inherit(X509_STORE_CTX_get0_param(&ctx),
						s->param);
d518 4
d757 2
@


1.13
log
@resolve conflicts
@
text
@d59 1
a59 1
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
d76 1
a76 1
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
d81 1
a81 1
 *    openssl-core@@OpenSSL.org.
d90 1
a90 1
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
d105 10
d124 1
a124 14
#if !defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_SYS_VMS) && !defined(NeXT) && !defined(MAC_OS_pre_X)
#include <dirent.h>
#endif

#if defined(WIN32)
#include <windows.h>
#include <tchar.h>
#endif

#ifdef NeXT
#include <sys/dir.h>
#define dirent direct
#endif

d129 4
a133 1
#include <openssl/fips.h>
d138 3
d144 1
a144 2
		/* any write lock will do; usually this branch
		 * will only be taken once anyway */
d146 1
d153 3
a155 1
		
d157 3
a159 1
		}
a214 1
		/* DH parameters don't have a reference count */
d245 13
d292 5
a296 1
				
d311 1
a311 1
#ifndef OPENSSL_NO_DH /* avoid 'unreferenced label' warning if OPENSSL_NO_DH is defined */
d322 4
d365 3
d474 4
d503 4
d509 1
d512 1
a512 1
	/* We need to set the verify purpose. The purpose can be determined by
a515 4
	if (s->server)
		i = X509_PURPOSE_SSL_CLIENT;
	else
		i = X509_PURPOSE_SSL_SERVER;
d517 2
a518 1
	X509_STORE_CTX_purpose_inherit(&ctx, i, s->purpose, s->trust);
d765 1
a765 1
	sk_X509_NAME_set_cmp_func(stack,oldcmp);
a780 4
#ifndef OPENSSL_SYS_WIN32
#ifndef OPENSSL_SYS_VMS		/* XXXX This may be fixed in the future */
#ifndef OPENSSL_SYS_MACINTOSH_CLASSIC /* XXXXX: Better scheme needed! */

d784 2
a785 2
	DIR *d;
	struct dirent *dstruct;
a788 1
	d = opendir(dir);
d791 2
a792 9
	if(!d)
		{
		SYSerr(SYS_F_OPENDIR, get_last_sys_error());
		ERR_add_error_data(3, "opendir('", dir, "')");
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB);
		goto err;
		}
	
	while((dstruct=readdir(d)))
d796 2
a797 2
		
		if(strlen(dir)+strlen(dstruct->d_name)+2 > sizeof buf)
d802 7
a808 3
		
		r = BIO_snprintf(buf,sizeof buf,"%s/%s",dir,dstruct->d_name);
		if (r <= 0 || r >= sizeof buf)
a812 60
	ret = 1;

err:	
	if (d) closedir(d);
	CRYPTO_w_unlock(CRYPTO_LOCK_READDIR);
	return ret;
	}

#endif
#endif

#else /* OPENSSL_SYS_WIN32 */

#if defined(_WIN32_WCE)
# ifndef UNICODE
#  error "WinCE comes in UNICODE flavor only..."
# endif
# if _WIN32_WCE<101 && !defined(OPENSSL_NO_MULTIBYTE)
#  define OPENSSL_NO_MULTIBYTE
# endif
# ifndef  FindFirstFile
#  define FindFirstFile FindFirstFileW
# endif
# ifndef  FindNextFile
#  define FindNextFile FindNextFileW
# endif
#endif

int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
				       const char *dir)
	{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	int    ret = 0;
	TCHAR *wdir = NULL;
	size_t i,len_0 = strlen(dir)+1;	/* len_0 accounts for trailing 0 */
	char   buf[1024],*slash;

	if (len_0 > (sizeof(buf)-14))	/* 14 is just some value... */
		{
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
		return ret;
		}

	CRYPTO_w_lock(CRYPTO_LOCK_READDIR);

	if (sizeof(TCHAR) != sizeof(char))
		{
		wdir = (TCHAR *)malloc(len_0*sizeof(TCHAR));
		if (wdir == NULL)
			goto err_noclose;
#ifndef OPENSSL_NO_MULTIBYTE
		if (!MultiByteToWideChar(CP_ACP,0,dir,len_0,
					(WCHAR *)wdir,len_0))
#endif
			for (i=0;i<len_0;i++) wdir[i]=(TCHAR)dir[i];

		hFind = FindFirstFile(wdir, &FindFileData);
		}
	else	hFind = FindFirstFile((const TCHAR *)dir, &FindFileData);
d814 1
a814 2
	/* Note that a side effect is that the CAs will be sorted by name */
	if(hFind == INVALID_HANDLE_VALUE)
d817 1
a817 1
		ERR_add_error_data(3, "opendir('", dir, "')");
d819 1
a819 1
		goto err_noclose;
a821 31
	strncpy(buf,dir,sizeof(buf));	/* strcpy is safe too... */
	buf[len_0-1]='/';		/* no trailing zero!     */
	slash=buf+len_0;

	do	{
		const TCHAR *fnam=FindFileData.cFileName;
		size_t flen_0=_tcslen(fnam)+1;

		if (flen_0 > (sizeof(buf)-len_0))
			{
			SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
			goto err;
			}
		/* else strcpy would be safe too... */

		if (sizeof(TCHAR) != sizeof(char))
			{
#ifndef OPENSSL_NO_MULTIBYTE
			if (!WideCharToMultiByte(CP_ACP,0,
						(WCHAR *)fnam,flen_0,
						slash,sizeof(buf)-len_0,
						NULL,0))
#endif
				for (i=0;i<flen_0;i++) slash[i]=(char)fnam[i];
			}
		else	strncpy(slash,(const char *)fnam,sizeof(buf)-len_0);

		if(!SSL_add_file_cert_subjects_to_stack(stack,buf))
			goto err;
		}
	while (FindNextFile(hFind, &FindFileData) != FALSE);
d824 2
a825 6
err:	
	FindClose(hFind);
err_noclose:
	if (wdir != NULL)
		free(wdir);

a829 1
#endif
@


1.12
log
@resolve conflicts
@
text
@d619 1
a619 1
	STACK_OF(X509_NAME) *ret,*sk;
a620 1
	ret=sk_X509_NAME_new_null();
d625 1
a625 1
	if ((ret == NULL) || (sk == NULL) || (in == NULL))
d638 9
d669 2
@


1.11
log
@merge 0.9.7d
@
text
@d120 1
d133 1
d547 1
a547 1
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(SSL_CTX *ctx)
d552 1
a552 1
STACK_OF(X509_NAME) *SSL_get_client_CA_list(SSL *s)
d788 15
d808 10
a817 4
	int ret = 0;
#ifdef OPENSSL_SYS_WINCE
	WCHAR* wdir = NULL;
#endif
d820 4
a823 7
	
#ifdef OPENSSL_SYS_WINCE
	/* convert strings to UNICODE */
	{
		BOOL result = FALSE;
		int i;
		wdir = malloc((strlen(dir)+1)*2);
d826 3
a828 3
		for (i=0; i<(int)strlen(dir)+1; i++)
			wdir[i] = (short)dir[i];
	}
d830 5
a835 5
#ifdef OPENSSL_SYS_WINCE
	hFind = FindFirstFile(wdir, &FindFileData);
#else
	hFind = FindFirstFile(dir, &FindFileData);
#endif
d844 10
a853 11
	
	do 
		{
		char buf[1024];
		int r;
		
#ifdef OPENSSL_SYS_WINCE
		if(strlen(dir)+_tcslen(FindFileData.cFileName)+2 > sizeof buf)
#else
		if(strlen(dir)+strlen(FindFileData.cFileName)+2 > sizeof buf)
#endif
d858 14
a871 4
		
		r = BIO_snprintf(buf,sizeof buf,"%s/%s",dir,FindFileData.cFileName);
		if (r <= 0 || r >= sizeof buf)
			goto err;
a880 1
#ifdef OPENSSL_SYS_WINCE
d883 1
a883 1
#endif
@


1.10
log
@merge 0.9.7b with local changes; crank majors for libssl/libcrypto
@
text
@d508 1
a508 1
static void set_client_CA_list(STACK_OF(X509_NAME) **ca_list,STACK_OF(X509_NAME) *list)
d513 1
a513 1
	*ca_list=list;
d535 1
a535 1
void SSL_set_client_CA_list(SSL *s,STACK_OF(X509_NAME) *list)
d537 1
a537 1
	set_client_CA_list(&(s->client_CA),list);
d540 1
a540 1
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx,STACK_OF(X509_NAME) *list)
d542 1
a542 1
	set_client_CA_list(&(ctx->client_CA),list);
@


1.9
log
@Merge openssl-0.9.7-stable-SNAP-20020519
@
text
@d784 1
a784 1
#else
d792 3
d798 16
d815 1
d830 3
d834 1
d852 4
@


1.8
log
@OpenSSL 0.9.7 stable 2002 05 08 merge
@
text
@a827 1
	if (d) closedir(d);
@


1.7
log
@openssl-engine-0.9.6a merge
@
text
@d109 1
a109 2
#include "openssl/e_os.h"

d114 1
a114 1
#if !defined(WIN32) && !defined(VSM) && !defined(NeXT) && !defined(MAC_OS_pre_X)
d118 4
d135 1
a135 1
	static int ssl_x509_store_ctx_idx= -1;
d139 11
a149 2
		ssl_x509_store_ctx_idx=X509_STORE_CTX_get_ex_new_index(
			0,"SSL for verify callback",NULL,NULL,NULL);
d151 1
a151 1
	return(ssl_x509_store_ctx_idx);
d194 1
a194 1
#ifndef NO_RSA
d197 1
a198 1
		CRYPTO_add(&ret->rsa_tmp->references, 1, CRYPTO_LOCK_RSA);
d203 1
a203 1
#ifndef NO_DH
d286 1
a286 1
#ifndef NO_DH /* avoid 'unreferenced label' warning if NO_DH is defined */
d289 1
a289 1
#ifndef NO_RSA
d293 1
a293 1
#ifndef NO_DH
d330 1
a330 1
#ifndef NO_RSA
d333 1
a333 1
#ifndef NO_DH
d434 1
a434 1
#ifndef NO_RSA
d438 1
a438 1
#ifndef NO_DH
d462 5
a466 1
	X509_STORE_CTX_init(&ctx,s->ctx->cert_store,x,sk);
d470 1
d474 5
a478 1
         */
d480 1
a480 2
	if(s->server) i = X509_PURPOSE_SSL_CLIENT;
	else i = X509_PURPOSE_SSL_SERVER;
d482 2
a483 1
	X509_STORE_CTX_purpose_inherit(&ctx, i, s->purpose, s->trust);
d486 3
d490 1
d493 1
a493 1
#ifndef NO_X509_VERIFY
d603 1
a603 1
#ifndef NO_STDIO
d733 3
a735 3
#ifndef WIN32
#ifndef VMS			/* XXXX This may be fixed in the future */
#ifndef MAC_OS_pre_X
d776 1
d783 50
@


1.6
log
@openssl-engine-0.9.6 merge
@
text
@d274 1
d276 1
@


1.5
log
@fix missing closedir() that could allow apacheSSL to leak fd's,
from netbsd (taca) credited to TAKANO Yuji <takachan@@running-dog.net>
@
text
@d146 1
a146 1
	ret=(CERT *)Malloc(sizeof(CERT));
d165 1
a165 1
	ret = (CERT *)Malloc(sizeof(CERT));
d334 1
a334 1
	Free(c);
d370 1
a370 1
	ret = Malloc(sizeof *ret);
d429 1
a429 1
	Free(sc);
d571 1
a571 1
static int xname_cmp(X509_NAME **a,X509_NAME **b)
d592 1
a592 1
	ret=sk_X509_NAME_new(NULL);
a646 12
    {
    BIO *in;
    X509 *x=NULL;
    X509_NAME *xn=NULL;
    int ret=1;
    int (*oldcmp)(X509_NAME **a, X509_NAME **b);

    oldcmp=sk_X509_NAME_set_cmp_func(stack,xname_cmp);

    in=BIO_new(BIO_s_file_internal());

    if (in == NULL)
d648 18
a665 3
	SSLerr(SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK,ERR_R_MALLOC_FAILURE);
	goto err;
	}
d667 12
a678 2
    if (!BIO_read_filename(in,file))
	goto err;
d680 11
a690 12
    for (;;)
	{
	if (PEM_read_bio_X509(in,&x,NULL,NULL) == NULL)
	    break;
	if ((xn=X509_get_subject_name(x)) == NULL) goto err;
	xn=X509_NAME_dup(xn);
	if (xn == NULL) goto err;
	if (sk_X509_NAME_find(stack,xn) >= 0)
	    X509_NAME_free(xn);
	else
	    sk_X509_NAME_push(stack,xn);
	}
d692 1
a692 4
    if (0)
	{
err:
	ret=0;
a693 9
    if(in != NULL)
	BIO_free(in);
    if(x != NULL)
	X509_free(x);

    sk_X509_NAME_set_cmp_func(stack,oldcmp);

    return ret;
    }
a711 10
    {
    DIR *d;
    struct dirent *dstruct;
    int ret = 0;

    CRYPTO_w_lock(CRYPTO_LOCK_READDIR);
    d = opendir(dir);

    /* Note that a side effect is that the CAs will be sorted by name */
    if(!d)
d713 15
a727 15
	SYSerr(SYS_F_OPENDIR, get_last_sys_error());
	ERR_add_error_data(3, "opendir('", dir, "')");
	SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB);
	goto err;
	}

    while((dstruct=readdir(d)))
	{
	char buf[1024];

	if(strlen(dir)+strlen(dstruct->d_name)+2 > sizeof buf)
	    {
	    SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
	    goto err;
	    }
d729 18
a746 5
	sprintf(buf,"%s/%s",dir,dstruct->d_name);
	if(!SSL_add_file_cert_subjects_to_stack(stack,buf))
	    goto err;
	}
    ret = 1;
d749 3
a751 4
    closedir(d);
    CRYPTO_w_unlock(CRYPTO_LOCK_READDIR);
    return ret;
    }
@


1.4
log
@OpenSSL 0.9.5a merge
@
text
@d746 1
@


1.3
log
@OpenSSL 0.9.5 merge

*warning* this bumps shared lib minors for libssl and libcrypto from 2.1 to 2.2
if you are using the ssl26 packages for ssh and other things to work you will
need to get new ones (see ~beck/libsslsnap/<arch>) on cvs or ~beck/src-patent.tar.gz on cvs
@
text
@d194 1
a194 4
		/* DH parameters don't have a reference count (and cannot
		 * reasonably be shared anyway, as the secret exponent may
		 * be created just when it is needed -- earlier library
		 * versions did not pay attention to this) */
d198 1
a198 1
			SSLerr(SSL_F_SSL_CERT_NEW, ERR_R_DH_LIB);
d200 20
@


1.2
log
@OpenSSL 0.9.4 merge
@
text
@d108 8
a115 2
#include <sys/types.h>
#if !defined(WIN32) && !defined(VSM) && !defined(NeXT)
d118 1
d123 1
d127 1
d434 10
a443 2
	X509_STORE_CTX_set_ex_data(&ctx,SSL_get_ex_data_X509_STORE_CTX_idx(),
		(char *)s);
d554 1
a554 1
static int name_cmp(X509_NAME **a,X509_NAME **b)
d576 1
a576 1
	sk=sk_X509_NAME_new(name_cmp);
d637 1
a637 1
    oldcmp=sk_X509_NAME_set_cmp_func(stack,name_cmp);
d691 1
d733 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* ssl/ssl_cert.c */
d58 48
d108 11
a118 3
#include "objects.h"
#include "bio.h"
#include "pem.h"
d121 13
a133 1
CERT *ssl_cert_new()
a143 8
/*
	ret->valid=0;
	ret->mask=0;
	ret->export_mask=0;
	ret->cert_type=0;
	ret->key->x509=NULL;
	ret->key->publickey=NULL;
	ret->key->privatekey=NULL; */
d151 120
a270 2
void ssl_cert_free(c)
CERT *c;
d274 3
a307 2
	if (c->cert_chain != NULL)
		sk_pop_free(c->cert_chain,X509_free);
d311 96
a406 3
int ssl_set_cert_type(c, type)
CERT *c;
int type;
d408 1
a408 1
	c->cert_type=type;
d412 1
a412 3
int ssl_verify_cert_chain(s,sk)
SSL *s;
STACK *sk;
d418 1
a418 1
	if ((sk == NULL) || (sk_num(sk) == 0))
d421 1
a421 1
	x=(X509 *)sk_value(sk,0);
d423 4
a426 1
	X509_STORE_CTX_set_app_data(&ctx,(char *)s);
d429 1
a429 1
		i=s->ctx->app_verify_callback(&ctx);
d431 2
d434 6
d441 1
a442 1
	s->verify_result=ctx.error;
d447 1
a447 3
static void set_client_CA_list(ca_list,list)
STACK **ca_list;
STACK *list;
d450 1
a450 1
		sk_pop_free(*ca_list,X509_NAME_free);
d455 1
a455 2
STACK *SSL_dup_CA_list(sk)
STACK *sk;
d458 1
a458 1
	STACK *ret;
d461 2
a462 2
	ret=sk_new_null();
	for (i=0; i<sk_num(sk); i++)
d464 2
a465 2
		name=X509_NAME_dup((X509_NAME *)sk_value(sk,i));
		if ((name == NULL) || !sk_push(ret,(char *)name))
d467 1
a467 1
			sk_pop_free(ret,X509_NAME_free);
d474 1
a474 3
void SSL_set_client_CA_list(s,list)
SSL *s;
STACK *list;
d479 1
a479 3
void SSL_CTX_set_client_CA_list(ctx,list)
SSL_CTX *ctx;
STACK *list;
d484 1
a484 2
STACK *SSL_CTX_get_client_CA_list(ctx)
SSL_CTX *ctx;
d489 1
a489 2
STACK *SSL_get_client_CA_list(s)
SSL *s;
d508 1
a508 3
static int add_client_CA(sk,x)
STACK **sk;
X509 *x;
d513 1
a513 1
	if ((*sk == NULL) && ((*sk=sk_new_null()) == NULL))
d519 1
a519 1
	if (!sk_push(*sk,(char *)name))
d527 1
a527 3
int SSL_add_client_CA(ssl,x)
SSL *ssl;
X509 *x;
d532 1
a532 3
int SSL_CTX_add_client_CA(ctx,x)
SSL_CTX *ctx;
X509 *x;
d537 1
a537 2
static int name_cmp(a,b)
X509_NAME **a,**b;
d543 9
a551 2
STACK *SSL_load_client_CA_file(file)
char *file;
d556 1
a556 1
	STACK *ret,*sk;
d558 2
a559 2
	ret=sk_new(NULL);
	sk=sk_new(name_cmp);
d574 1
a574 1
		if (PEM_read_bio_X509(in,&x,NULL) == NULL)
d580 1
a580 1
		if (sk_find(sk,(char *)xn) >= 0)
d584 2
a585 2
			sk_push(sk,(char *)xn);
			sk_push(ret,(char *)xn);
d592 1
a592 1
		if (ret != NULL) sk_pop_free(ret,X509_NAME_free);
d595 1
a595 1
	if (sk != NULL) sk_free(sk);
d602 115
@


1.1.1.1
log
@Import of SSLeay-0.9.0b with RSA and IDEA stubbed + OpenBSD build
functionality for shared libs.

Note that routines such as sslv2_init and friends that use RSA will
not work due to lack of RSA in this library.

Needs documentation and help from ports for easy upgrade to full
functionality where legally possible.
@
text
@@


1.1.1.2
log
@import openssl-0.9.7-beta1
@
text
@d1 1
a1 1
/*! \file ssl/ssl_cert.c */
a57 48
/* ====================================================================
 * Copyright (c) 1999 The OpenSSL Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer. 
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * 3. All advertising materials mentioning features or use of this
 *    software must display the following acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit. (http://www.OpenSSL.org/)"
 *
 * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
 *    endorse or promote products derived from this software without
 *    prior written permission. For written permission, please contact
 *    openssl-core@@OpenSSL.org.
 *
 * 5. Products derived from this software may not be called "OpenSSL"
 *    nor may "OpenSSL" appear in their names without prior written
 *    permission of the OpenSSL Project.
 *
 * 6. Redistributions of any form whatsoever must retain the following
 *    acknowledgment:
 *    "This product includes software developed by the OpenSSL Project
 *    for use in the OpenSSL Toolkit (http://www.OpenSSL.org/)"
 *
 * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
 * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 * ====================================================================
 */
d60 3
a62 23

#include "e_os.h"
#ifndef NO_SYS_TYPES_H
# include <sys/types.h>
#endif

#if !defined(OPENSSL_SYS_WIN32) && !defined(OPENSSL_SYS_VMS) && !defined(NeXT) && !defined(MAC_OS_pre_X)
#include <dirent.h>
#endif

#if defined(WIN32)
#include <windows.h>
#endif

#ifdef NeXT
#include <sys/dir.h>
#define dirent direct
#endif

#include <openssl/objects.h>
#include <openssl/bio.h>
#include <openssl/pem.h>
#include <openssl/x509v3.h>
d65 1
a65 22
int SSL_get_ex_data_X509_STORE_CTX_idx(void)
	{
	static volatile int ssl_x509_store_ctx_idx= -1;

	if (ssl_x509_store_ctx_idx < 0)
		{
		/* any write lock will do; usually this branch
		 * will only be taken once anyway */
		CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
		
		if (ssl_x509_store_ctx_idx < 0)
			{
			ssl_x509_store_ctx_idx=X509_STORE_CTX_get_ex_new_index(
				0,"SSL for verify callback",NULL,NULL,NULL);
			}
		
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
		}
	return ssl_x509_store_ctx_idx;
	}

CERT *ssl_cert_new(void)
d69 1
a69 1
	ret=(CERT *)OPENSSL_malloc(sizeof(CERT));
d76 8
d91 2
a92 139
CERT *ssl_cert_dup(CERT *cert)
	{
	CERT *ret;
	int i;

	ret = (CERT *)OPENSSL_malloc(sizeof(CERT));
	if (ret == NULL)
		{
		SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_MALLOC_FAILURE);
		return(NULL);
		}

	memset(ret, 0, sizeof(CERT));

	ret->key = &ret->pkeys[cert->key - &cert->pkeys[0]];
	/* or ret->key = ret->pkeys + (cert->key - cert->pkeys),
	 * if you find that more readable */

	ret->valid = cert->valid;
	ret->mask = cert->mask;
	ret->export_mask = cert->export_mask;

#ifndef OPENSSL_NO_RSA
	if (cert->rsa_tmp != NULL)
		{
		RSA_up_ref(cert->rsa_tmp);
		ret->rsa_tmp = cert->rsa_tmp;
		}
	ret->rsa_tmp_cb = cert->rsa_tmp_cb;
#endif

#ifndef OPENSSL_NO_DH
	if (cert->dh_tmp != NULL)
		{
		/* DH parameters don't have a reference count */
		ret->dh_tmp = DHparams_dup(cert->dh_tmp);
		if (ret->dh_tmp == NULL)
			{
			SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_DH_LIB);
			goto err;
			}
		if (cert->dh_tmp->priv_key)
			{
			BIGNUM *b = BN_dup(cert->dh_tmp->priv_key);
			if (!b)
				{
				SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);
				goto err;
				}
			ret->dh_tmp->priv_key = b;
			}
		if (cert->dh_tmp->pub_key)
			{
			BIGNUM *b = BN_dup(cert->dh_tmp->pub_key);
			if (!b)
				{
				SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_BN_LIB);
				goto err;
				}
			ret->dh_tmp->pub_key = b;
			}
		}
	ret->dh_tmp_cb = cert->dh_tmp_cb;
#endif

	for (i = 0; i < SSL_PKEY_NUM; i++)
		{
		if (cert->pkeys[i].x509 != NULL)
			{
			ret->pkeys[i].x509 = cert->pkeys[i].x509;
			CRYPTO_add(&ret->pkeys[i].x509->references, 1,
				CRYPTO_LOCK_X509);
			}
		
		if (cert->pkeys[i].privatekey != NULL)
			{
			ret->pkeys[i].privatekey = cert->pkeys[i].privatekey;
			CRYPTO_add(&ret->pkeys[i].privatekey->references, 1,
				CRYPTO_LOCK_EVP_PKEY);

			switch(i) 
				{
				/* If there was anything special to do for
				 * certain types of keys, we'd do it here.
				 * (Nothing at the moment, I think.) */

			case SSL_PKEY_RSA_ENC:
			case SSL_PKEY_RSA_SIGN:
				/* We have an RSA key. */
				break;
				
			case SSL_PKEY_DSA_SIGN:
				/* We have a DSA key. */
				break;
				
			case SSL_PKEY_DH_RSA:
			case SSL_PKEY_DH_DSA:
				/* We have a DH key. */
				break;
				
			default:
				/* Can't happen. */
				SSLerr(SSL_F_SSL_CERT_DUP, SSL_R_LIBRARY_BUG);
				}
			}
		}
	
	/* ret->extra_certs *should* exist, but currently the own certificate
	 * chain is held inside SSL_CTX */

	ret->references=1;

	return(ret);
	
#ifndef OPENSSL_NO_DH /* avoid 'unreferenced label' warning if OPENSSL_NO_DH is defined */
err:
#endif
#ifndef OPENSSL_NO_RSA
	if (ret->rsa_tmp != NULL)
		RSA_free(ret->rsa_tmp);
#endif
#ifndef OPENSSL_NO_DH
	if (ret->dh_tmp != NULL)
		DH_free(ret->dh_tmp);
#endif

	for (i = 0; i < SSL_PKEY_NUM; i++)
		{
		if (ret->pkeys[i].x509 != NULL)
			X509_free(ret->pkeys[i].x509);
		if (ret->pkeys[i].privatekey != NULL)
			EVP_PKEY_free(ret->pkeys[i].privatekey);
		}

	return NULL;
	}


void ssl_cert_free(CERT *c)
a95 3
	if(c == NULL)
	    return;

d109 1
a109 1
#ifndef OPENSSL_NO_RSA
d112 1
a112 1
#ifndef OPENSSL_NO_DH
d127 3
a129 1
	OPENSSL_free(c);
d132 3
a134 1
int ssl_cert_inst(CERT **o)
d136 1
a136 23
	/* Create a CERT if there isn't already one
	 * (which cannot really happen, as it is initially created in
	 * SSL_CTX_new; but the earlier code usually allows for that one
	 * being non-existant, so we follow that behaviour, as it might
	 * turn out that there actually is a reason for it -- but I'm
	 * not sure that *all* of the existing code could cope with
	 * s->cert being NULL, otherwise we could do without the
	 * initialization in SSL_CTX_new).
	 */
	
	if (o == NULL) 
		{
		SSLerr(SSL_F_SSL_CERT_INST, ERR_R_PASSED_NULL_PARAMETER);
		return(0);
		}
	if (*o == NULL)
		{
		if ((*o = ssl_cert_new()) == NULL)
			{
			SSLerr(SSL_F_SSL_CERT_INST, ERR_R_MALLOC_FAILURE);
			return(0);
			}
		}
d140 3
a142 74

SESS_CERT *ssl_sess_cert_new(void)
	{
	SESS_CERT *ret;

	ret = OPENSSL_malloc(sizeof *ret);
	if (ret == NULL)
		{
		SSLerr(SSL_F_SSL_SESS_CERT_NEW, ERR_R_MALLOC_FAILURE);
		return NULL;
		}

	memset(ret, 0 ,sizeof *ret);
	ret->peer_key = &(ret->peer_pkeys[SSL_PKEY_RSA_ENC]);
	ret->references = 1;

	return ret;
	}

void ssl_sess_cert_free(SESS_CERT *sc)
	{
	int i;

	if (sc == NULL)
		return;

	i = CRYPTO_add(&sc->references, -1, CRYPTO_LOCK_SSL_SESS_CERT);
#ifdef REF_PRINT
	REF_PRINT("SESS_CERT", sc);
#endif
	if (i > 0)
		return;
#ifdef REF_CHECK
	if (i < 0)
		{
		fprintf(stderr,"ssl_sess_cert_free, bad reference count\n");
		abort(); /* ok */
		}
#endif

	/* i == 0 */
	if (sc->cert_chain != NULL)
		sk_X509_pop_free(sc->cert_chain, X509_free);
	for (i = 0; i < SSL_PKEY_NUM; i++)
		{
		if (sc->peer_pkeys[i].x509 != NULL)
			X509_free(sc->peer_pkeys[i].x509);
#if 0 /* We don't have the peer's private key.  These lines are just
	   * here as a reminder that we're still using a not-quite-appropriate
	   * data structure. */
		if (sc->peer_pkeys[i].privatekey != NULL)
			EVP_PKEY_free(sc->peer_pkeys[i].privatekey);
#endif
		}

#ifndef OPENSSL_NO_RSA
	if (sc->peer_rsa_tmp != NULL)
		RSA_free(sc->peer_rsa_tmp);
#endif
#ifndef OPENSSL_NO_DH
	if (sc->peer_dh_tmp != NULL)
		DH_free(sc->peer_dh_tmp);
#endif

	OPENSSL_free(sc);
	}

int ssl_set_peer_cert_type(SESS_CERT *sc,int type)
	{
	sc->peer_cert_type = type;
	return(1);
	}

int ssl_verify_cert_chain(SSL *s,STACK_OF(X509) *sk)
d148 1
a148 1
	if ((sk == NULL) || (sk_X509_num(sk) == 0))
d151 3
a153 23
	x=sk_X509_value(sk,0);
	if(!X509_STORE_CTX_init(&ctx,s->ctx->cert_store,x,sk))
		{
		SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN,ERR_R_X509_LIB);
		return(0);
		}
	if (SSL_get_verify_depth(s) >= 0)
		X509_STORE_CTX_set_depth(&ctx, SSL_get_verify_depth(s));
	X509_STORE_CTX_set_ex_data(&ctx,SSL_get_ex_data_X509_STORE_CTX_idx(),s);

	/* We need to set the verify purpose. The purpose can be determined by
	 * the context: if its a server it will verify SSL client certificates
	 * or vice versa.
	 */
	if (s->server)
		i = X509_PURPOSE_SSL_CLIENT;
	else
		i = X509_PURPOSE_SSL_SERVER;

	X509_STORE_CTX_purpose_inherit(&ctx, i, s->purpose, s->trust);

	if (s->verify_callback)
		X509_STORE_CTX_set_verify_cb(&ctx, s->verify_callback);
d156 1
a156 5
#if 1 /* new with OpenSSL 0.9.7 */
		i=s->ctx->app_verify_callback(&ctx, s->ctx->app_verify_arg); 
#else
		i=s->ctx->app_verify_callback(&ctx); /* should pass app_verify_arg */
#endif
a157 2
		{
#ifndef OPENSSL_NO_X509_VERIFY
a158 6
#else
		i=0;
		ctx.error=X509_V_ERR_APPLICATION_VERIFICATION;
		SSLerr(SSL_F_SSL_VERIFY_CERT_CHAIN,SSL_R_NO_VERIFY_CALLBACK);
#endif
		}
d160 1
a161 1
	X509_STORE_CTX_cleanup(&ctx);
d166 3
a168 1
static void set_client_CA_list(STACK_OF(X509_NAME) **ca_list,STACK_OF(X509_NAME) *list)
d171 1
a171 1
		sk_X509_NAME_pop_free(*ca_list,X509_NAME_free);
d176 2
a177 1
STACK_OF(X509_NAME) *SSL_dup_CA_list(STACK_OF(X509_NAME) *sk)
d180 1
a180 1
	STACK_OF(X509_NAME) *ret;
d183 2
a184 2
	ret=sk_X509_NAME_new_null();
	for (i=0; i<sk_X509_NAME_num(sk); i++)
d186 2
a187 2
		name=X509_NAME_dup(sk_X509_NAME_value(sk,i));
		if ((name == NULL) || !sk_X509_NAME_push(ret,name))
d189 1
a189 1
			sk_X509_NAME_pop_free(ret,X509_NAME_free);
d196 3
a198 1
void SSL_set_client_CA_list(SSL *s,STACK_OF(X509_NAME) *list)
d203 3
a205 1
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx,STACK_OF(X509_NAME) *list)
d210 2
a211 1
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(SSL_CTX *ctx)
d216 2
a217 1
STACK_OF(X509_NAME) *SSL_get_client_CA_list(SSL *s)
d236 3
a238 1
static int add_client_CA(STACK_OF(X509_NAME) **sk,X509 *x)
d243 1
a243 1
	if ((*sk == NULL) && ((*sk=sk_X509_NAME_new_null()) == NULL))
d249 1
a249 1
	if (!sk_X509_NAME_push(*sk,name))
d257 3
a259 1
int SSL_add_client_CA(SSL *ssl,X509 *x)
d264 3
a266 1
int SSL_CTX_add_client_CA(SSL_CTX *ctx,X509 *x)
d271 2
a272 1
static int xname_cmp(const X509_NAME * const *a, const X509_NAME * const *b)
d277 3
a279 10
#ifndef OPENSSL_NO_STDIO
/*!
 * Load CA certs from a file into a ::STACK. Note that it is somewhat misnamed;
 * it doesn't really have anything to do with clients (except that a common use
 * for a stack of CAs is to send it to the client). Actually, it doesn't have
 * much to do with CAs, either, since it will load any old cert.
 * \param file the file containing one or more certs.
 * \return a ::STACK containing the certs.
 */
STACK_OF(X509_NAME) *SSL_load_client_CA_file(const char *file)
d284 1
a284 1
	STACK_OF(X509_NAME) *ret,*sk;
d286 2
a287 2
	ret=sk_X509_NAME_new_null();
	sk=sk_X509_NAME_new(xname_cmp);
d302 1
a302 1
		if (PEM_read_bio_X509(in,&x,NULL,NULL) == NULL)
d308 1
a308 1
		if (sk_X509_NAME_find(sk,xn) >= 0)
d312 2
a313 2
			sk_X509_NAME_push(sk,xn);
			sk_X509_NAME_push(ret,xn);
d320 1
a320 1
		if (ret != NULL) sk_X509_NAME_pop_free(ret,X509_NAME_free);
d323 1
a323 1
	if (sk != NULL) sk_X509_NAME_free(sk);
a329 170
/*!
 * Add a file of certs to a stack.
 * \param stack the stack to add to.
 * \param file the file to add from. All certs in this file that are not
 * already in the stack will be added.
 * \return 1 for success, 0 for failure. Note that in the case of failure some
 * certs may have been added to \c stack.
 */

int SSL_add_file_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
					const char *file)
	{
	BIO *in;
	X509 *x=NULL;
	X509_NAME *xn=NULL;
	int ret=1;
	int (*oldcmp)(const X509_NAME * const *a, const X509_NAME * const *b);
	
	oldcmp=sk_X509_NAME_set_cmp_func(stack,xname_cmp);
	
	in=BIO_new(BIO_s_file_internal());
	
	if (in == NULL)
		{
		SSLerr(SSL_F_SSL_ADD_FILE_CERT_SUBJECTS_TO_STACK,ERR_R_MALLOC_FAILURE);
		goto err;
		}
	
	if (!BIO_read_filename(in,file))
		goto err;
	
	for (;;)
		{
		if (PEM_read_bio_X509(in,&x,NULL,NULL) == NULL)
			break;
		if ((xn=X509_get_subject_name(x)) == NULL) goto err;
		xn=X509_NAME_dup(xn);
		if (xn == NULL) goto err;
		if (sk_X509_NAME_find(stack,xn) >= 0)
			X509_NAME_free(xn);
		else
			sk_X509_NAME_push(stack,xn);
		}

	if (0)
		{
err:
		ret=0;
		}
	if(in != NULL)
		BIO_free(in);
	if(x != NULL)
		X509_free(x);
	
	sk_X509_NAME_set_cmp_func(stack,oldcmp);

	return ret;
	}

/*!
 * Add a directory of certs to a stack.
 * \param stack the stack to append to.
 * \param dir the directory to append from. All files in this directory will be
 * examined as potential certs. Any that are acceptable to
 * SSL_add_dir_cert_subjects_to_stack() that are not already in the stack will be
 * included.
 * \return 1 for success, 0 for failure. Note that in the case of failure some
 * certs may have been added to \c stack.
 */

#ifndef OPENSSL_SYS_WIN32
#ifndef OPENSSL_SYS_VMS		/* XXXX This may be fixed in the future */
#ifndef OPENSSL_SYS_MACINTOSH_CLASSIC /* XXXXX: Better scheme needed! */

int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
				       const char *dir)
	{
	DIR *d;
	struct dirent *dstruct;
	int ret = 0;

	CRYPTO_w_lock(CRYPTO_LOCK_READDIR);
	d = opendir(dir);

	/* Note that a side effect is that the CAs will be sorted by name */
	if(!d)
		{
		SYSerr(SYS_F_OPENDIR, get_last_sys_error());
		ERR_add_error_data(3, "opendir('", dir, "')");
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB);
		goto err;
		}
	
	while((dstruct=readdir(d)))
		{
		char buf[1024];
		int r;
		
		if(strlen(dir)+strlen(dstruct->d_name)+2 > sizeof buf)
			{
			SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
			goto err;
			}
		
		r = BIO_snprintf(buf,sizeof buf,"%s/%s",dir,dstruct->d_name);
		if (r <= 0 || r >= sizeof buf)
			goto err;
		if(!SSL_add_file_cert_subjects_to_stack(stack,buf))
			goto err;
		}
	ret = 1;

err:	
	if (d) closedir(d);
	CRYPTO_w_unlock(CRYPTO_LOCK_READDIR);
	return ret;
	}

#endif
#endif

#else

int SSL_add_dir_cert_subjects_to_stack(STACK_OF(X509_NAME) *stack,
				       const char *dir)
	{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;
	int ret = 0;

	CRYPTO_w_lock(CRYPTO_LOCK_READDIR);
	
	hFind = FindFirstFile(dir, &FindFileData);
	/* Note that a side effect is that the CAs will be sorted by name */
	if(hFind == INVALID_HANDLE_VALUE)
		{
		SYSerr(SYS_F_OPENDIR, get_last_sys_error());
		ERR_add_error_data(3, "opendir('", dir, "')");
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK, ERR_R_SYS_LIB);
		goto err_noclose;
		}
	
	do 
		{
		char buf[1024];
		int r;
		
		if(strlen(dir)+strlen(FindFileData.cFileName)+2 > sizeof buf)
			{
			SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
			goto err;
			}
		
		r = BIO_snprintf(buf,sizeof buf,"%s/%s",dir,FindFileData.cFileName);
		if (r <= 0 || r >= sizeof buf)
			goto err;
		if(!SSL_add_file_cert_subjects_to_stack(stack,buf))
			goto err;
		}
	while (FindNextFile(hFind, &FindFileData) != FALSE);
	ret = 1;

err:	
	FindClose(hFind);
err_noclose:
	CRYPTO_w_unlock(CRYPTO_LOCK_READDIR);
	return ret;
	}

#endif
@


1.1.1.3
log
@import 0.9.7b (without idea and rc5)
@
text
@d784 1
a784 1
#else /* OPENSSL_SYS_WIN32 */
a791 3
#ifdef OPENSSL_SYS_WINCE
	WCHAR* wdir = NULL;
#endif
a794 16
#ifdef OPENSSL_SYS_WINCE
	/* convert strings to UNICODE */
	{
		BOOL result = FALSE;
		int i;
		wdir = malloc((strlen(dir)+1)*2);
		if (wdir == NULL)
			goto err_noclose;
		for (i=0; i<(int)strlen(dir)+1; i++)
			wdir[i] = (short)dir[i];
	}
#endif

#ifdef OPENSSL_SYS_WINCE
	hFind = FindFirstFile(wdir, &FindFileData);
#else
a795 1
#endif
a809 3
#ifdef OPENSSL_SYS_WINCE
		if(strlen(dir)+_tcslen(FindFileData.cFileName)+2 > sizeof buf)
#else
a810 1
#endif
a827 4
#ifdef OPENSSL_SYS_WINCE
	if (wdir != NULL)
		free(wdir);
#endif
@


1.1.1.4
log
@import openssl-0.9.7d
@
text
@d508 1
a508 1
static void set_client_CA_list(STACK_OF(X509_NAME) **ca_list,STACK_OF(X509_NAME) *name_list)
d513 1
a513 1
	*ca_list=name_list;
d535 1
a535 1
void SSL_set_client_CA_list(SSL *s,STACK_OF(X509_NAME) *name_list)
d537 1
a537 1
	set_client_CA_list(&(s->client_CA),name_list);
d540 1
a540 1
void SSL_CTX_set_client_CA_list(SSL_CTX *ctx,STACK_OF(X509_NAME) *name_list)
d542 1
a542 1
	set_client_CA_list(&(ctx->client_CA),name_list);
@


1.1.1.5
log
@import of openssl-0.9.7g; tested on platforms from alpha to zaurus, ok deraadt@@
@
text
@a119 1
#include <tchar.h>
a131 1
#include <openssl/fips.h>
d545 1
a545 1
STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx)
d550 1
a550 1
STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s)
a785 15
#if defined(_WIN32_WCE)
# ifndef UNICODE
#  error "WinCE comes in UNICODE flavor only..."
# endif
# if _WIN32_WCE<101 && !defined(OPENSSL_NO_MULTIBYTE)
#  define OPENSSL_NO_MULTIBYTE
# endif
# ifndef  FindFirstFile
#  define FindFirstFile FindFirstFileW
# endif
# ifndef  FindNextFile
#  define FindNextFile FindNextFileW
# endif
#endif

d791 4
a794 10
	int    ret = 0;
	TCHAR *wdir = NULL;
	size_t i,len_0 = strlen(dir)+1;	/* len_0 accounts for trailing 0 */
	char   buf[1024],*slash;

	if (len_0 > (sizeof(buf)-14))	/* 14 is just some value... */
		{
		SSLerr(SSL_F_SSL_ADD_DIR_CERT_SUBJECTS_TO_STACK,SSL_R_PATH_TOO_LONG);
		return ret;
		}
d797 7
a803 4

	if (sizeof(TCHAR) != sizeof(char))
		{
		wdir = (TCHAR *)malloc(len_0*sizeof(TCHAR));
d806 3
a808 3
#ifndef OPENSSL_NO_MULTIBYTE
		if (!MultiByteToWideChar(CP_ACP,0,dir,len_0,
					(WCHAR *)wdir,len_0))
a809 5
			for (i=0;i<len_0;i++) wdir[i]=(TCHAR)dir[i];

		hFind = FindFirstFile(wdir, &FindFileData);
		}
	else	hFind = FindFirstFile((const TCHAR *)dir, &FindFileData);
d811 5
d824 11
a834 10

	strncpy(buf,dir,sizeof(buf));	/* strcpy is safe too... */
	buf[len_0-1]='/';		/* no trailing zero!     */
	slash=buf+len_0;

	do	{
		const TCHAR *fnam=FindFileData.cFileName;
		size_t flen_0=_tcslen(fnam)+1;

		if (flen_0 > (sizeof(buf)-len_0))
d839 4
a842 14
		/* else strcpy would be safe too... */

		if (sizeof(TCHAR) != sizeof(char))
			{
#ifndef OPENSSL_NO_MULTIBYTE
			if (!WideCharToMultiByte(CP_ACP,0,
						(WCHAR *)fnam,flen_0,
						slash,sizeof(buf)-len_0,
						NULL,0))
#endif
				for (i=0;i<flen_0;i++) slash[i]=(char)fnam[i];
			}
		else	strncpy(slash,(const char *)fnam,sizeof(buf)-len_0);

d852 1
d855 1
a855 1

@


1.1.1.6
log
@import of openssl-0.9.7j
@
text
@d619 1
a619 1
	STACK_OF(X509_NAME) *ret = NULL,*sk;
d621 1
d626 1
a626 1
	if ((sk == NULL) || (in == NULL))
a638 9
		if (ret == NULL)
			{
			ret = sk_X509_NAME_new_null();
			if (ret == NULL)
				{
				SSLerr(SSL_F_SSL_LOAD_CLIENT_CA_FILE,ERR_R_MALLOC_FAILURE);
				goto err;
				}
			}
a660 2
	if (ret != NULL)
		ERR_clear_error();
@


1.1.1.7
log
@import of OpenSSL 0.9.8h
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2006 The OpenSSL Project.  All rights reserved.
d76 1
a76 1
 *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
d81 1
a81 1
 *    openssl-core@@openssl.org.
d90 1
a90 1
 *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
a104 10
 *
 * This product includes cryptographic software written by Eric Young
 * (eay@@cryptsoft.com).  This product includes software written by Tim
 * Hudson (tjh@@cryptsoft.com).
 *
 */
/* ====================================================================
 * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
 * ECC cipher suite support in OpenSSL originally developed by 
 * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
d114 14
a127 1
#include "o_dir.h"
a131 4
#ifndef OPENSSL_NO_DH
#include <openssl/dh.h>
#endif
#include <openssl/bn.h>
d133 1
a137 3
	int got_write_lock = 0;

	CRYPTO_r_lock(CRYPTO_LOCK_SSL_CTX);
d141 2
a142 1
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
a143 1
		got_write_lock = 1;
d150 2
a152 6

	if (got_write_lock)
		CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
	else
		CRYPTO_r_unlock(CRYPTO_LOCK_SSL_CTX);
	
d208 1
a238 13
#ifndef OPENSSL_NO_ECDH
	if (cert->ecdh_tmp)
		{
		ret->ecdh_tmp = EC_KEY_dup(cert->ecdh_tmp);
		if (ret->ecdh_tmp == NULL)
			{
			SSLerr(SSL_F_SSL_CERT_DUP, ERR_R_EC_LIB);
			goto err;
			}
		}
	ret->ecdh_tmp_cb = cert->ecdh_tmp_cb;
#endif

d273 1
a273 5

			case SSL_PKEY_ECC:
				/* We have an ECC key */
				break;

d288 1
a288 1
#if !defined(OPENSSL_NO_DH) || !defined(OPENSSL_NO_ECDH)
a298 4
#ifndef OPENSSL_NO_ECDH
	if (ret->ecdh_tmp != NULL)
		EC_KEY_free(ret->ecdh_tmp);
#endif
a337 3
#ifndef OPENSSL_NO_ECDH
	if (c->ecdh_tmp) EC_KEY_free(c->ecdh_tmp);
#endif
a443 4
#ifndef OPENSSL_NO_ECDH
	if (sc->peer_ecdh_tmp != NULL)
		EC_KEY_free(sc->peer_ecdh_tmp);
#endif
a468 4
	if (s->param)
		X509_VERIFY_PARAM_inherit(X509_STORE_CTX_get0_param(&ctx),
						s->param);
#if 0
a470 1
#endif
d473 1
a473 1
	/* We need to inherit the verify parameters. These can be determined by
d477 4
d482 1
a482 2
	X509_STORE_CTX_set_default(&ctx,
				s->server ? "ssl_client" : "ssl_server");
d729 1
a729 1
	(void)sk_X509_NAME_set_cmp_func(stack,oldcmp);
d745 4
d752 2
a753 2
	OPENSSL_DIR_CTX *d = NULL;
	const char *filename;
d757 1
d760 9
a768 2

	while((filename = OPENSSL_DIR_read(&d, dir)))
d772 2
a773 2

		if(strlen(dir)+strlen(filename)+2 > sizeof buf)
d778 3
a780 7

#ifdef OPENSSL_SYS_VMS
		r = BIO_snprintf(buf,sizeof buf,"%s%s",dir,filename);
#else
		r = BIO_snprintf(buf,sizeof buf,"%s/%s",dir,filename);
#endif
		if (r <= 0 || r >= (int)sizeof(buf))
d785 60
d846 2
a847 1
	if (errno)
d850 1
a850 1
		ERR_add_error_data(3, "OPENSSL_DIR_read(&ctx, '", dir, "')");
d852 1
a852 1
		goto err;
d855 31
d888 6
a893 2
err:
	if (d) OPENSSL_DIR_end(&d);
d898 1
@


1.1.1.8
log
@import OpenSSL-1.0.0a
@
text
@d59 1
a59 1
 * Copyright (c) 1998-2007 The OpenSSL Project.  All rights reserved.
d200 2
a201 4
	ret->mask_k = cert->mask_k;
	ret->mask_a = cert->mask_a;
	ret->export_mask_k = cert->export_mask_k;
	ret->export_mask_a = cert->export_mask_a;
d503 3
a518 4
	/* Anything non-default in "param" should overwrite anything in the
	 * ctx.
	 */
	X509_VERIFY_PARAM_set1(X509_STORE_CTX_get0_param(&ctx), s->param);
a753 2

	ERR_clear_error();
@


1.1.1.9
log
@import OpenSSL-1.0.1c
@
text
@a162 15
static void ssl_cert_set_default_md(CERT *cert)
	{
	/* Set digest values to defaults */
#ifndef OPENSSL_NO_DSA
	cert->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_dss1();
#endif
#ifndef OPENSSL_NO_RSA
	cert->pkeys[SSL_PKEY_RSA_SIGN].digest = EVP_sha1();
	cert->pkeys[SSL_PKEY_RSA_ENC].digest = EVP_sha1();
#endif
#ifndef OPENSSL_NO_ECDSA
	cert->pkeys[SSL_PKEY_ECC].digest = EVP_ecdsa();
#endif
	}

d177 1
a177 1
	ssl_cert_set_default_md(ret);
a309 4
	/* Set digests to defaults. NB: we don't copy existing values as they
	 * will be set during handshake.
	 */
	ssl_cert_set_default_md(ret);
@


1.1.1.10
log
@Import OpenSSL 1.0.1g
@
text
@d167 1
a167 1
	cert->pkeys[SSL_PKEY_DSA_SIGN].digest = EVP_sha1();
d174 1
a174 1
	cert->pkeys[SSL_PKEY_ECC].digest = EVP_sha1();
@


