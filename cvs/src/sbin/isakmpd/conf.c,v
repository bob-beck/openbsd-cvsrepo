head	1.106;
access;
symbols
	OPENBSD_6_0:1.106.0.2
	OPENBSD_6_0_BASE:1.106
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.103.0.10
	OPENBSD_5_8_BASE:1.103
	OPENBSD_5_7:1.103.0.2
	OPENBSD_5_7_BASE:1.103
	OPENBSD_5_6:1.103.0.6
	OPENBSD_5_6_BASE:1.103
	OPENBSD_5_5:1.103.0.4
	OPENBSD_5_5_BASE:1.103
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.101.0.4
	OPENBSD_5_3_BASE:1.101
	OPENBSD_5_2:1.101.0.2
	OPENBSD_5_2_BASE:1.101
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.6
	OPENBSD_5_0:1.99.0.4
	OPENBSD_5_0_BASE:1.99
	OPENBSD_4_9:1.99.0.2
	OPENBSD_4_9_BASE:1.99
	OPENBSD_4_8:1.98.0.2
	OPENBSD_4_8_BASE:1.98
	OPENBSD_4_7:1.97.0.8
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.97.0.10
	OPENBSD_4_6_BASE:1.97
	OPENBSD_4_5:1.97.0.6
	OPENBSD_4_5_BASE:1.97
	OPENBSD_4_4:1.97.0.4
	OPENBSD_4_4_BASE:1.97
	OPENBSD_4_3:1.97.0.2
	OPENBSD_4_3_BASE:1.97
	OPENBSD_4_2:1.96.0.2
	OPENBSD_4_2_BASE:1.96
	OPENBSD_4_1:1.93.0.2
	OPENBSD_4_1_BASE:1.93
	OPENBSD_4_0:1.92.0.2
	OPENBSD_4_0_BASE:1.92
	OPENBSD_3_9:1.86.0.2
	OPENBSD_3_9_BASE:1.86
	OPENBSD_3_8:1.84.0.2
	OPENBSD_3_8_BASE:1.84
	OPENBSD_3_7:1.76.0.2
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.73.0.2
	OPENBSD_3_6_BASE:1.73
	OPENBSD_3_5:1.62.0.2
	OPENBSD_3_5_BASE:1.62
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	OPENBSD_3_3:1.49.0.2
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.106
date	2016.03.16.15.41.10;	author krw;	state Exp;
branches;
next	1.105;
commitid	JEVxsRygqcjPtWTf;

1.105
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.104;
commitid	CLwtYUTkBZ3FXV1w;

1.104
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	0qPuuXwccpVXsXcV;

1.103
date	2013.11.22.04.12.47;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2012.07.13.15.16.18;	author mikeb;	state Exp;
branches;
next	1.100;

1.100
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.22.13.45.15;	author mikeb;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.04.18.09.45;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2008.02.17.10.36.32;	author hshoexer;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.01.10.27.17;	author moritz;	state Exp;
branches;
next	1.95;

1.95
date	2007.04.22.11.34.36;	author moritz;	state Exp;
branches;
next	1.94;

1.94
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.93;

1.93
date	2007.02.19.09.43.34;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2006.08.29.08.51.28;	author hshoexer;	state Exp;
branches;
next	1.91;

1.91
date	2006.06.10.21.15.45;	author hshoexer;	state Exp;
branches;
next	1.90;

1.90
date	2006.06.10.21.09.45;	author msf;	state Exp;
branches;
next	1.89;

1.89
date	2006.06.10.21.07.10;	author hshoexer;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.10.20.10.02;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2006.05.27.17.01.46;	author hshoexer;	state Exp;
branches;
next	1.86;

1.86
date	2005.12.28.10.57.35;	author hshoexer;	state Exp;
branches;
next	1.85;

1.85
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2005.08.02.09.08.40;	author hshoexer;	state Exp;
branches;
next	1.83;

1.83
date	2005.05.26.02.38.35;	author cloder;	state Exp;
branches;
next	1.82;

1.82
date	2005.04.08.22.32.09;	author cloder;	state Exp;
branches;
next	1.81;

1.81
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2005.04.08.16.04.17;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.15.20.33.07;	author moritz;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.10.17.30.31;	author cloder;	state Exp;
branches;
next	1.74;

1.74
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.73;

1.73
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2004.07.29.20.02.02;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.25.20.25.34;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.14.13.53.31;	author hshoexer;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.14.08.42.56;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.23.14.15.55;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.15.20.20.55;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.15.18.53.56;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.61;

1.61
date	2004.02.27.19.07.16;	author hshoexer;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.06.00.22.48;	author hshoexer;	state Exp;
branches;
next	1.59;

1.59
date	2003.09.02.18.15.55;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.28.14.43.35;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.25.08.31.16;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.03.12.51.38;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.18.19.37.46;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.14.18.11.18;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.30.15.15.11;	author jason;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.04.20.02.34;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.06.07.46.50;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.15.14.58.38;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.14.16.13.27;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches;
next	1.44;

1.44
date	2002.08.07.13.19.20;	author ho;	state Exp;
branches;
next	1.43;

1.43
date	2002.08.02.13.10.41;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.28.11.23.20;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.29.06.26.50;	author pvalchev;	state Exp;
branches;
next	1.38;

1.38
date	2002.04.22.12.52.39;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.01.14.54.20;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.23.18.44.47;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.03.16.27.41;	author ho;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.05.05.59.06;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.05.12.36.47;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.01.19.48.43;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.29.19.42.16;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.27.15.46.29;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.13.17.56.31;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.28.08.49.43;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.27.12.03.31;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.26.12.12.51;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.12.01.45.55;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.27.19.22.36;	author niklas;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.10.26.22.28.16;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.16.23.28.56;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.13.13.22.01;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.13.12.19.57;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.13.11.44.10;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.09.23.27.30;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.07.06.59.05;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.08.20.50.29;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.03.13.47.15;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.02.14.35.54;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.07.22.10.30;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.07.22.06.44;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.25.17.23.38;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.08.05.22.41.08;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.05.01.20.43.42;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.04.05.21.00.40;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.03.02.15.35.12;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.02.26.03.34.26;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.12.21.21.52.56;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.20.07.38.30;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.08;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2001.05.08.12.45.21;	author ho;	state Exp;
branches;
next	;


desc
@@


1.106
log
@More "(<blah> *)0" -> NULL, avoiding any stdarg functions.

Feedback millert@@ kettenis@@
@
text
@/* $OpenBSD: conf.c,v 1.105 2015/12/09 21:41:50 naddy Exp $	 */
/* $EOM: conf.c,v 1.48 2000/12/04 02:04:29 angelos Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000, 2001, 2002 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/mman.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "app.h"
#include "conf.h"
#include "log.h"
#include "monitor.h"
#include "util.h"

static char    *conf_get_trans_str(int, char *, char *);
static void     conf_load_defaults(int);
#if 0
static int      conf_find_trans_xf(int, char *);
#endif

struct conf_trans {
	TAILQ_ENTRY(conf_trans) link;
	int	 trans;
	enum conf_op {
		CONF_SET, CONF_REMOVE, CONF_REMOVE_SECTION
	}	 op;
	char	*section;
	char	*tag;
	char	*value;
	int	 override;
	int	 is_default;
};

#define CONF_SECT_MAX 256

TAILQ_HEAD(conf_trans_head, conf_trans) conf_trans_queue;

struct conf_binding {
	LIST_ENTRY(conf_binding) link;
	char	*section;
	char	*tag;
	char	*value;
	int	 is_default;
};

char	*conf_path = CONFIG_FILE;
LIST_HEAD(conf_bindings, conf_binding) conf_bindings[256];

static char	*conf_addr;
static __inline__ u_int8_t
conf_hash(char *s)
{
	u_int8_t hash = 0;

	while (*s) {
		hash = ((hash << 1) | (hash >> 7)) ^ tolower((unsigned char)*s);
		s++;
	}
	return hash;
}

/*
 * Insert a tag-value combination from LINE (the equal sign is at POS)
 */
static int
conf_remove_now(char *section, char *tag)
{
	struct conf_binding *cb, *next;

	for (cb = LIST_FIRST(&conf_bindings[conf_hash(section)]); cb;
	    cb = next) {
		next = LIST_NEXT(cb, link);
		if (strcasecmp(cb->section, section) == 0 &&
		    strcasecmp(cb->tag, tag) == 0) {
			LIST_REMOVE(cb, link);
			LOG_DBG((LOG_MISC, 95, "[%s]:%s->%s removed", section,
			    tag, cb->value));
			free(cb->section);
			free(cb->tag);
			free(cb->value);
			free(cb);
			return 0;
		}
	}
	return 1;
}

static int
conf_remove_section_now(char *section)
{
	struct conf_binding *cb, *next;
	int	unseen = 1;

	for (cb = LIST_FIRST(&conf_bindings[conf_hash(section)]); cb;
	    cb = next) {
		next = LIST_NEXT(cb, link);
		if (strcasecmp(cb->section, section) == 0) {
			unseen = 0;
			LIST_REMOVE(cb, link);
			LOG_DBG((LOG_MISC, 95, "[%s]:%s->%s removed", section,
			    cb->tag, cb->value));
			free(cb->section);
			free(cb->tag);
			free(cb->value);
			free(cb);
		}
	}
	return unseen;
}

/*
 * Insert a tag-value combination from LINE (the equal sign is at POS)
 * into SECTION of our configuration database.
 */
static int
conf_set_now(char *section, char *tag, char *value, int override,
    int is_default)
{
	struct conf_binding *node = 0;

	if (override)
		conf_remove_now(section, tag);
	else if (conf_get_str(section, tag)) {
		if (!is_default)
			log_print("conf_set_now: duplicate tag [%s]:%s, "
			    "ignoring...\n", section, tag);
		return 1;
	}
	node = calloc(1, sizeof *node);
	if (!node) {
		log_error("conf_set_now: calloc (1, %lu) failed",
		    (unsigned long)sizeof *node);
		return 1;
	}
	node->section = node->tag = node->value = NULL;
	if ((node->section = strdup(section)) == NULL)
		goto fail;
	if ((node->tag = strdup(tag)) == NULL)
		goto fail;
	if ((node->value = strdup(value)) == NULL)
		goto fail;
	node->is_default = is_default;

	LIST_INSERT_HEAD(&conf_bindings[conf_hash(section)], node, link);
	LOG_DBG((LOG_MISC, 95, "conf_set_now: [%s]:%s->%s", node->section,
	    node->tag, node->value));
	return 0;
fail:
	free(node->value);
	free(node->tag);
	free(node->section);
	free(node);
	return 1;
}

/*
 * Parse the line LINE of SZ bytes.  Skip Comments, recognize section
 * headers and feed tag-value pairs into our configuration database.
 */
static void
conf_parse_line(int trans, char *line, int ln, size_t sz)
{
	char	*val;
	size_t	 i;
	int	 j;
	static char *section = 0;

	/* Lines starting with '#' or ';' are comments.  */
	if (*line == '#' || *line == ';')
		return;

	/* '[section]' parsing...  */
	if (*line == '[') {
		for (i = 1; i < sz; i++)
			if (line[i] == ']')
				break;
		free(section);
		if (i == sz) {
			log_print("conf_parse_line: %d:"
			    "unmatched ']', ignoring until next section", ln);
			section = 0;
			return;
		}
		section = malloc(i);
		if (!section) {
			log_print("conf_parse_line: %d: malloc (%lu) failed",
			    ln, (unsigned long)i);
			return;
		}
		strlcpy(section, line + 1, i);
		return;
	}
	/* Deal with assignments.  */
	for (i = 0; i < sz; i++)
		if (line[i] == '=') {
			/* If no section, we are ignoring the lines.  */
			if (!section) {
				log_print("conf_parse_line: %d: ignoring line "
				    "due to no section", ln);
				return;
			}
			line[strcspn(line, " \t=")] = '\0';
			val = line + i + 1 + strspn(line + i + 1, " \t");
			/* Skip trailing whitespace, if any */
			for (j = sz - (val - line) - 1; j > 0 &&
			    isspace((unsigned char)val[j]); j--)
				val[j] = '\0';
			/* XXX Perhaps should we not ignore errors?  */
			conf_set(trans, section, line, val, 0, 0);
			return;
		}
	/* Other non-empty lines are weird.  */
	i = strspn(line, " \t");
	if (line[i])
		log_print("conf_parse_line: %d: syntax error", ln);
}

/* Parse the mapped configuration file.  */
static void
conf_parse(int trans, char *buf, size_t sz)
{
	char	*cp = buf;
	char	*bufend = buf + sz;
	char	*line;
	int	ln = 1;

	line = cp;
	while (cp < bufend) {
		if (*cp == '\n') {
			/* Check for escaped newlines.  */
			if (cp > buf && *(cp - 1) == '\\')
				*(cp - 1) = *cp = ' ';
			else {
				*cp = '\0';
				conf_parse_line(trans, line, ln, cp - line);
				line = cp + 1;
			}
			ln++;
		}
		cp++;
	}
	if (cp != line)
		log_print("conf_parse: last line unterminated, ignored.");
}

/*
 * Auto-generate default configuration values for the transforms and
 * suites the user wants.
 *
 * Resulting section names can be:
 *  For main mode:
 *     {BLF,3DES,CAST,AES,AES-{128,192,256}-{MD5,SHA,SHA2-{256,384,512}} \
 *         [-GRP{1,2,5,14,15}][-{DSS,RSA_SIG}]
 *  For quick mode:
 *     QM-{proto}[-TRP]-{cipher}[-{hash}][-PFS[-{group}]]-SUITE
 *     where
 *       {proto}  = ESP, AH
 *       {cipher} = 3DES, CAST, BLF, AES, AES-{128,192,256}, AESCTR
 *       {hash}   = MD5, SHA, RIPEMD, SHA2-{256,384,512}
 *       {group}  = GRP1, GRP2, GRP5, GRP14, GRP15
 *
 * DH group defaults to MODP_1024.
 *
 * XXX We may want to support USE_TRIPLEDES, etc...
 * XXX No EC2N DH support here yet.
 */

/* Find the value for a section+tag in the transaction list.  */
static char *
conf_get_trans_str(int trans, char *section, char *tag)
{
	struct conf_trans *node, *nf = 0;

	for (node = TAILQ_FIRST(&conf_trans_queue); node;
	    node = TAILQ_NEXT(node, link))
		if (node->trans == trans && strcasecmp(section, node->section)
		    == 0 && strcasecmp(tag, node->tag) == 0) {
			if (!nf)
				nf = node;
			else if (node->override)
				nf = node;
		}
	return nf ? nf->value : 0;
}

#if 0
/* XXX Currently unused.  */
static int
conf_find_trans_xf(int phase, char *xf)
{
	struct conf_trans *node;
	char	*p;

	/* Find the relevant transforms and suites, if any.  */
	for (node = TAILQ_FIRST(&conf_trans_queue); node;
	    node = TAILQ_NEXT(node, link))
		if ((phase == 1 && strcmp("Transforms", node->tag) == 0) ||
		    (phase == 2 && strcmp("Suites", node->tag) == 0)) {
			p = node->value;
			while ((p = strstr(p, xf)) != NULL)
				if (*(p + strlen(p)) &&
				    *(p + strlen(p)) != ',')
					p += strlen(p);
				else
					return 1;
		}
	return 0;
}
#endif

static void
conf_load_defaults_mm(int tr, char *mme, char *mmh, char *mma, char *dhg,
    char *mme_p, char *mma_p, char *dhg_p, char *mmh_p)
{
	char sect[CONF_SECT_MAX];

	snprintf(sect, sizeof sect, "%s%s%s%s", mme_p, mmh_p, dhg_p, mma_p);

	LOG_DBG((LOG_MISC, 95, "conf_load_defaults_mm: main mode %s", sect));

	conf_set(tr, sect, "ENCRYPTION_ALGORITHM", mme, 0, 1);
	if (strcmp(mme, "BLOWFISH_CBC") == 0)
		conf_set(tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN, 0,
		    1);
        else if (strcmp(mme_p, "AES-128") == 0)
                conf_set(tr, sect, "KEY_LENGTH", "128,128:128", 0, 1);
        else if (strcmp(mme_p, "AES-192") == 0)
                conf_set(tr, sect, "KEY_LENGTH", "192,192:192", 0, 1);
        else if (strcmp(mme_p, "AES-256") == 0)
                conf_set(tr, sect, "KEY_LENGTH", "256,256:256", 0, 1);
	else if (strcmp(mme, "AES_CBC") == 0)
		conf_set(tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_AES_KEYLEN, 0,
		    1);

	conf_set(tr, sect, "HASH_ALGORITHM", mmh, 0, 1);
	conf_set(tr, sect, "AUTHENTICATION_METHOD", mma, 0, 1);
	conf_set(tr, sect, "GROUP_DESCRIPTION", dhg, 0, 1);
	conf_set(tr, sect, "Life", CONF_DFLT_TAG_LIFE_MAIN_MODE, 0, 1);
}

static void
conf_load_defaults_qm(int tr, char *qme, char *qmh, char *dhg, char *qme_p,
    char *qmh_p, char *qm_ah_id, char *dhg_p, int proto, int mode, int pfs)
{
	char sect[CONF_SECT_MAX], tmp[CONF_SECT_MAX];

	/* Helper #defines, incl abbreviations.  */
#define PROTO(x)  ((x) ? "AH" : "ESP")
#define PFS(x)    ((x) ? "-PFS" : "")
#define MODE(x)   ((x) ? "TRANSPORT" : "TUNNEL")
#define MODE_p(x) ((x) ? "-TRP" : "")

	/* For AH a hash must be present and no encryption is allowed */
	if (proto == 1 && (strcmp(qmh, "NONE") == 0 ||
	    strcmp(qme, "NONE") != 0))
		return;

	/* For ESP encryption must be provided, an empty hash is ok. */
	if (proto == 0 && strcmp(qme, "NONE") == 0)
		return;

	/* When PFS is disabled no DH group must be specified. */
	if (pfs == 0 && strcmp(dhg_p, ""))
		return;

	/* For GCM no additional authentication must be specified */
	if (proto == 0 && strcmp(qmh, "NONE") != 0 &&
	    (strcmp(qme, "AES_GCM_16") == 0 || strcmp(qme, "AES_GMAC") == 0))
		return;

	snprintf(tmp, sizeof tmp, "QM-%s%s%s%s%s%s", PROTO(proto),
	    MODE_p(mode), qme_p, qmh_p, PFS(pfs), dhg_p);

	strlcpy(sect, tmp, CONF_SECT_MAX);
	strlcat(sect, "-SUITE",	CONF_SECT_MAX);

	LOG_DBG((LOG_MISC, 95, "conf_load_defaults_qm: quick mode %s", sect));

	conf_set(tr, sect, "Protocols", tmp, 0, 1);
	snprintf(sect, sizeof sect, "IPSEC_%s", PROTO(proto));
	conf_set(tr, tmp, "PROTOCOL_ID", sect, 0, 1);
	strlcpy(sect, tmp, CONF_SECT_MAX);
	strlcat(sect, "-XF", CONF_SECT_MAX);
	conf_set(tr, tmp, "Transforms", sect, 0, 1);

	/*
	 * XXX For now, defaults
	 * contain one xf per protocol.
	 */
	if (proto == 0)
		conf_set(tr, sect, "TRANSFORM_ID", qme, 0, 1);
	else
		conf_set(tr, sect, "TRANSFORM_ID", qm_ah_id, 0, 1);
	if (strcmp(qme ,"BLOWFISH") == 0)
		conf_set(tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN, 0,
			 1);
	else if (strcmp(qme_p, "-AES-128") == 0 ||
	    strcmp(qme_p, "-AESCTR-128") == 0 ||
	    strcmp(qme_p, "-AESGCM-128") == 0 ||
	    strcmp(qme_p, "-AESGMAC-128") == 0)
		conf_set(tr, sect, "KEY_LENGTH", "128,128:128", 0, 1);
	else if (strcmp(qme_p, "-AES-192") == 0 ||
	    strcmp(qme_p, "-AESCTR-192") == 0 ||
	    strcmp(qme_p, "-AESGCM-192") == 0 ||
	    strcmp(qme_p, "-AESGMAC-192") == 0)
		conf_set(tr, sect, "KEY_LENGTH", "192,192:192", 0, 1);
	else if (strcmp(qme_p, "-AES-256") == 0 ||
	    strcmp(qme_p, "-AESCTR-256") == 0 ||
	    strcmp(qme_p, "-AESGCM-256") == 0 ||
	    strcmp(qme_p, "-AESGMAC-256") == 0)
		conf_set(tr, sect, "KEY_LENGTH", "256,256:256", 0, 1);
	else if	(strcmp(qme, "AES") == 0)
		conf_set(tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_AES_KEYLEN, 0,
			 1);

	conf_set(tr, sect, "ENCAPSULATION_MODE", MODE(mode), 0, 1);
	if (strcmp(qmh, "NONE")) {
		conf_set(tr, sect, "AUTHENTICATION_ALGORITHM", qmh, 0, 1);

		/* XXX Another shortcut to keep length down */
		if (pfs)
			conf_set(tr, sect, "GROUP_DESCRIPTION", dhg, 0, 1);
	}

	/* XXX Lifetimes depending on enc/auth strength? */
	conf_set(tr, sect, "Life", CONF_DFLT_TAG_LIFE_QUICK_MODE, 0, 1);
}

static void
conf_load_defaults(int tr)
{
	int	 enc, auth, hash, group, proto, mode, pfs;
	char	*dflt;

	char	*mm_auth[] = {"PRE_SHARED", "DSS", "RSA_SIG", 0};
	char	*mm_auth_p[] = {"", "-DSS", "-RSA_SIG", 0};
	char	*mm_hash[] = {"MD5", "SHA", "SHA2_256", "SHA2_384", "SHA2_512",
		     0};
	char	*mm_hash_p[] = {"-MD5", "-SHA", "-SHA2-256", "-SHA2-384",
		    "-SHA2-512", "", 0 };
	char	*mm_enc[] = {"BLOWFISH_CBC", "3DES_CBC", "CAST_CBC",
		    "AES_CBC", "AES_CBC", "AES_CBC", "AES_CBC", 0};
	char	*mm_enc_p[] = {"BLF", "3DES", "CAST", "AES", "AES-128",
		    "AES-192", "AES-256", 0};
	char	*dhgroup[] = {"MODP_1024", "MODP_768", "MODP_1024",
		    "MODP_1536", "MODP_2048", "MODP_3072", "MODP_4096",
		    "MODP_6144", "MODP_8192", 0};
	char	*dhgroup_p[] = {"", "-GRP1", "-GRP2", "-GRP5", "-GRP14",
		    "-GRP15", "-GRP16", "-GRP17", "-GRP18", 0};
	char	*qm_enc[] = {"3DES", "CAST", "BLOWFISH", "AES",
		    "AES", "AES", "AES", "AES_CTR", "AES_CTR", "AES_CTR",
		    "AES_CTR", "AES_GCM_16",
		    "AES_GCM_16", "AES_GCM_16", "AES_GMAC", "AES_GMAC",
		    "AES_GMAC", "NULL", "NONE", 0};
	char	*qm_enc_p[] = {"-3DES", "-CAST", "-BLF", "-AES",
		    "-AES-128", "-AES-192", "-AES-256", "-AESCTR",
		    "-AESCTR-128", "-AESCTR-192", "-AESCTR-256",
		    "-AESGCM-128", "-AESGCM-192", "-AESGCM-256",
		    "-AESGMAC-128", "-AESGMAC-192", "-AESGMAC-256", "-NULL",
		    "", 0};
	char	*qm_hash[] = {"HMAC_MD5", "HMAC_SHA", "HMAC_RIPEMD",
		    "HMAC_SHA2_256", "HMAC_SHA2_384", "HMAC_SHA2_512", "NONE",
		    0};
	char	*qm_hash_p[] = {"-MD5", "-SHA", "-RIPEMD", "-SHA2-256",
		    "-SHA2-384", "-SHA2-512", "", 0};
	char	*qm_ah_id[] = {"MD5", "SHA", "RIPEMD", "SHA2_256", "SHA2_384",
		    "SHA2_512", "", 0};

	/* General and X509 defaults */
	conf_set(tr, "General", "Retransmits", CONF_DFLT_RETRANSMITS, 0, 1);
	conf_set(tr, "General", "Exchange-max-time", CONF_DFLT_EXCH_MAX_TIME,
	    0, 1);
	conf_set(tr, "General", "Use-Keynote", CONF_DFLT_USE_KEYNOTE, 0, 1);
	conf_set(tr, "General", "Policy-file", CONF_DFLT_POLICY_FILE, 0, 1);
	conf_set(tr, "General", "Pubkey-directory", CONF_DFLT_PUBKEY_DIR, 0,
	    1);

	conf_set(tr, "X509-certificates", "CA-directory",
	    CONF_DFLT_X509_CA_DIR, 0, 1);
	conf_set(tr, "X509-certificates", "Cert-directory",
	    CONF_DFLT_X509_CERT_DIR, 0, 1);
	conf_set(tr, "X509-certificates", "Private-key",
	    CONF_DFLT_X509_PRIVATE_KEY, 0, 1);
	conf_set(tr, "X509-certificates", "Private-key-directory",
	    CONF_DFLT_X509_PRIVATE_KEY_DIR, 0, 1);
	conf_set(tr, "X509-certificates", "CRL-directory",
	    CONF_DFLT_X509_CRL_DIR, 0, 1);

	conf_set(tr, "KeyNote", "Credential-directory",
	    CONF_DFLT_KEYNOTE_CRED_DIR, 0, 1);

	conf_set(tr, "General", "Delete-SAs", CONF_DFLT_DELETE_SAS, 0, 1);

	/* Lifetimes. XXX p1/p2 vs main/quick mode may be unclear.  */
	dflt = conf_get_trans_str(tr, "General", "Default-phase-1-lifetime");
	conf_set(tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_MAIN_MODE, 0, 1);
	conf_set(tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_MAIN_MODE), 0, 1);

	dflt = conf_get_trans_str(tr, "General", "Default-phase-2-lifetime");
	conf_set(tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_QUICK_MODE, 0, 1);
	conf_set(tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_QUICK_MODE), 0, 1);

	/* Default Phase-1 Configuration section */
	conf_set(tr, CONF_DFLT_TAG_PHASE1_CONFIG, "EXCHANGE_TYPE",
	    CONF_DFLT_PHASE1_EXCH_TYPE, 0, 1);
	conf_set(tr, CONF_DFLT_TAG_PHASE1_CONFIG, "Transforms",
	    CONF_DFLT_PHASE1_TRANSFORMS, 0, 1);

	/* Main modes */
	for (enc = 0; mm_enc[enc]; enc++)
		for (hash = 0; mm_hash[hash]; hash++)
			for (auth = 0; mm_auth[auth]; auth++)
				for (group = 0; dhgroup_p[group]; group++)
					conf_load_defaults_mm (tr, mm_enc[enc],
					    mm_hash[hash], mm_auth[auth],
					    dhgroup[group], mm_enc_p[enc],
					    mm_auth_p[auth], dhgroup_p[group],
					    mm_hash_p[hash]);

	/* Setup a default Phase 1 entry */
	conf_set(tr, "Phase 1", "Default", "Default-phase-1", 0, 1);
	conf_set(tr, "Default-phase-1", "Phase", "1", 0, 1);
	conf_set(tr, "Default-phase-1", "Configuration",
	    "Default-phase-1-configuration", 0, 1);
	dflt = conf_get_trans_str(tr, "General", "Default-phase-1-ID");
	if (dflt)
		conf_set(tr, "Default-phase-1", "ID", dflt, 0, 1);

	/* Quick modes */
	for (enc = 0; qm_enc[enc]; enc++)
		for (proto = 0; proto < 2; proto++)
			for (mode = 0; mode < 2; mode++)
				for (pfs = 0; pfs < 2; pfs++)
					for (hash = 0; qm_hash[hash]; hash++)
						for (group = 0;
						    dhgroup_p[group]; group++)
							conf_load_defaults_qm(
							    tr, qm_enc[enc],
							    qm_hash[hash],
							    dhgroup[group],
							    qm_enc_p[enc],
							    qm_hash_p[hash],
							    qm_ah_id[hash],
							    dhgroup_p[group],
							    proto, mode, pfs);
}

void
conf_init(void)
{
	unsigned int i;

	for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
		LIST_INIT(&conf_bindings[i]);
	TAILQ_INIT(&conf_trans_queue);
	conf_reinit();
}

/* Open the config file and map it into our address space, then parse it.  */
void
conf_reinit(void)
{
	struct conf_binding *cb = 0;
	int	 fd, trans;
	unsigned int i;
	size_t	 sz;
	char	*new_conf_addr = 0;

	fd = monitor_open(conf_path, O_RDONLY, 0);
	if (fd == -1 || check_file_secrecy_fd(fd, conf_path, &sz) == -1) {
		if (fd == -1 && errno != ENOENT)
			log_error("conf_reinit: open(\"%s\", O_RDONLY, 0) "
			    "failed", conf_path);
		if (fd != -1)
			close(fd);

		trans = conf_begin();
	} else {
		new_conf_addr = malloc(sz);
		if (!new_conf_addr) {
			log_error("conf_reinit: malloc (%lu) failed",
			    (unsigned long)sz);
			goto fail;
		}
		/* XXX I assume short reads won't happen here.  */
		if (read(fd, new_conf_addr, sz) != (int)sz) {
			log_error("conf_reinit: read (%d, %p, %lu) failed",
			    fd, new_conf_addr, (unsigned long)sz);
			goto fail;
		}
		close(fd);

		trans = conf_begin();

		/* XXX Should we not care about errors and rollback?  */
		conf_parse(trans, new_conf_addr, sz);
	}

	/* Load default configuration values.  */
	conf_load_defaults(trans);

	/* Free potential existing configuration.  */
	if (conf_addr) {
		for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0];
		    i++)
			for (cb = LIST_FIRST(&conf_bindings[i]); cb;
			    cb = LIST_FIRST(&conf_bindings[i]))
				conf_remove_now(cb->section, cb->tag);
		free(conf_addr);
	}
	conf_end(trans, 1);
	conf_addr = new_conf_addr;
	return;

fail:
	free(new_conf_addr);
	close(fd);
}

/*
 * Return the numeric value denoted by TAG in section SECTION or DEF
 * if that tag does not exist.
 */
int
conf_get_num(char *section, char *tag, int def)
{
	char	*value = conf_get_str(section, tag);

	if (value)
		return atoi(value);
	return def;
}

/*
 * Return the socket endpoint address denoted by TAG in SECTION as a
 * struct sockaddr.  It is the callers responsibility to deallocate
 * this structure when it is finished with it.
 */
struct sockaddr *
conf_get_address(char *section, char *tag)
{
	char	*value = conf_get_str(section, tag);
	struct sockaddr *sa;

	if (!value)
		return 0;
	if (text2sockaddr(value, 0, &sa, 0, 0) == -1)
		return 0;
	return sa;
}

/* Validate X according to the range denoted by TAG in section SECTION.  */
int
conf_match_num(char *section, char *tag, int x)
{
	char	*value = conf_get_str(section, tag);
	int	 val, min, max, n;

	if (!value)
		return 0;
	n = sscanf(value, "%d,%d:%d", &val, &min, &max);
	switch (n) {
	case 1:
		LOG_DBG((LOG_MISC, 95, "conf_match_num: %s:%s %d==%d?",
		    section, tag, val, x));
		return x == val;
	case 3:
		LOG_DBG((LOG_MISC, 95, "conf_match_num: %s:%s %d<=%d<=%d?",
		    section, tag, min, x, max));
		return min <= x && max >= x;
	default:
		log_error("conf_match_num: section %s tag %s: invalid number "
		    "spec %s", section, tag, value);
	}
	return 0;
}

/* Return the string value denoted by TAG in section SECTION.  */
char *
conf_get_str(char *section, char *tag)
{
	struct conf_binding *cb;

	for (cb = LIST_FIRST(&conf_bindings[conf_hash(section)]); cb;
	    cb = LIST_NEXT(cb, link))
		if (strcasecmp(section, cb->section) == 0 &&
		    strcasecmp(tag, cb->tag) == 0) {
			LOG_DBG((LOG_MISC, 95, "conf_get_str: [%s]:%s->%s",
			    section, tag, cb->value));
			return cb->value;
		}
	LOG_DBG((LOG_MISC, 95,
	    "conf_get_str: configuration value not found [%s]:%s", section,
	    tag));
	return 0;
}

/*
 * Build a list of string values out of the comma separated value denoted by
 * TAG in SECTION.
 */
struct conf_list *
conf_get_list(char *section, char *tag)
{
	char	*liststr = 0, *p, *field, *t;
	struct conf_list *list = 0;
	struct conf_list_node *node = 0;

	list = malloc(sizeof *list);
	if (!list)
		goto cleanup;
	TAILQ_INIT(&list->fields);
	list->cnt = 0;
	liststr = conf_get_str(section, tag);
	if (!liststr)
		goto cleanup;
	liststr = strdup(liststr);
	if (!liststr)
		goto cleanup;
	p = liststr;
	while ((field = strsep(&p, ",")) != NULL) {
		/* Skip leading whitespace */
		while (isspace((unsigned char)*field))
			field++;
		/* Skip trailing whitespace */
		if (p)
			for (t = p - 1; t > field && isspace((unsigned char)*t); t--)
				*t = '\0';
		if (*field == '\0') {
			log_print("conf_get_list: empty field, ignoring...");
			continue;
		}
		list->cnt++;
		node = calloc(1, sizeof *node);
		if (!node)
			goto cleanup;
		node->field = strdup(field);
		if (!node->field)
			goto cleanup;
		TAILQ_INSERT_TAIL(&list->fields, node, link);
	}
	free(liststr);
	return list;

cleanup:
	free(node);
	if (list)
		conf_free_list(list);
	free(liststr);
	return 0;
}

struct conf_list *
conf_get_tag_list(char *section)
{
	struct conf_list *list = 0;
	struct conf_list_node *node = 0;
	struct conf_binding *cb;

	list = malloc(sizeof *list);
	if (!list)
		goto cleanup;
	TAILQ_INIT(&list->fields);
	list->cnt = 0;
	for (cb = LIST_FIRST(&conf_bindings[conf_hash(section)]); cb;
	    cb = LIST_NEXT(cb, link))
		if (strcasecmp(section, cb->section) == 0) {
			list->cnt++;
			node = calloc(1, sizeof *node);
			if (!node)
				goto cleanup;
			node->field = strdup(cb->tag);
			if (!node->field)
				goto cleanup;
			TAILQ_INSERT_TAIL(&list->fields, node, link);
		}
	return list;

cleanup:
	free(node);
	if (list)
		conf_free_list(list);
	return 0;
}

void
conf_free_list(struct conf_list *list)
{
	struct conf_list_node *node = TAILQ_FIRST(&list->fields);

	while (node) {
		TAILQ_REMOVE(&list->fields, node, link);
		free(node->field);
		free(node);
		node = TAILQ_FIRST(&list->fields);
	}
	free(list);
}

int
conf_begin(void)
{
	static int	seq = 0;

	return ++seq;
}

static int
conf_trans_node(int transaction, enum conf_op op, char *section, char *tag,
    char *value, int override, int is_default)
{
	struct conf_trans *node;

	node = calloc(1, sizeof *node);
	if (!node) {
		log_error("conf_trans_node: calloc (1, %lu) failed",
		    (unsigned long)sizeof *node);
		return 1;
	}
	node->trans = transaction;
	node->op = op;
	node->override = override;
	node->is_default = is_default;
	if (section && (node->section = strdup(section)) == NULL)
		goto fail;
	if (tag && (node->tag = strdup(tag)) == NULL)
		goto fail;
	if (value && (node->value = strdup(value)) == NULL)
		goto fail;
	TAILQ_INSERT_TAIL(&conf_trans_queue, node, link);
	return 0;

fail:
	free(node->section);
	free(node->tag);
	free(node->value);
	free(node);
	return 1;
}

/* Queue a set operation.  */
int
conf_set(int transaction, char *section, char *tag, char *value, int override,
    int is_default)
{
	return conf_trans_node(transaction, CONF_SET, section, tag, value,
	    override, is_default);
}

/* Queue a remove operation.  */
int
conf_remove(int transaction, char *section, char *tag)
{
	return conf_trans_node(transaction, CONF_REMOVE, section, tag, NULL,
	    0, 0);
}

/* Queue a remove section operation.  */
int
conf_remove_section(int transaction, char *section)
{
	return conf_trans_node(transaction, CONF_REMOVE_SECTION, section, NULL,
	    NULL, 0, 0);
}

/* Execute all queued operations for this transaction.  Cleanup.  */
int
conf_end(int transaction, int commit)
{
	struct conf_trans *node, *next;

	for (node = TAILQ_FIRST(&conf_trans_queue); node; node = next) {
		next = TAILQ_NEXT(node, link);
		if (node->trans == transaction) {
			if (commit)
				switch (node->op) {
				case CONF_SET:
					conf_set_now(node->section, node->tag,
					    node->value, node->override,
					    node->is_default);
					break;
				case CONF_REMOVE:
					conf_remove_now(node->section,
					    node->tag);
					break;
				case CONF_REMOVE_SECTION:
					conf_remove_section_now(node->section);
					break;
				default:
					log_print("conf_end: unknown "
					    "operation: %d", node->op);
				}
			TAILQ_REMOVE(&conf_trans_queue, node, link);
			free(node->section);
			free(node->tag);
			free(node->value);
			free(node);
		}
	}
	return 0;
}

/*
 * Dump running configuration upon SIGUSR1.
 * Configuration is "stored in reverse order", so reverse it again.
 */
struct dumper {
	char	*s, *v;
	struct dumper *next;
};

static void
conf_report_dump(struct dumper *node)
{
	/* Recursive, cleanup when we're done.  */

	if (node->next)
		conf_report_dump(node->next);

	if (node->v)
		LOG_DBG((LOG_REPORT, 0, "%s=\t%s", node->s, node->v));
	else if (node->s) {
		LOG_DBG((LOG_REPORT, 0, "%s", node->s));
		if (strlen(node->s) > 0)
			free(node->s);
	}
	free(node);
}

void
conf_report(void)
{
	struct conf_binding *cb, *last = 0;
	unsigned int	i;
	char           *current_section = NULL;
	struct dumper  *dumper, *dnode;

	dumper = dnode = calloc(1, sizeof *dumper);
	if (!dumper)
		goto mem_fail;

	LOG_DBG((LOG_REPORT, 0, "conf_report: dumping running configuration"));

	for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
		for (cb = LIST_FIRST(&conf_bindings[i]); cb;
		    cb = LIST_NEXT(cb, link)) {
			if (!cb->is_default) {
				/* Dump this entry.  */
				if (!current_section || strcmp(cb->section,
				    current_section)) {
					if (current_section) {
						if (asprintf(&dnode->s, "[%s]",
						    current_section) == -1)
							goto mem_fail;
						dnode->next = calloc(1,
						    sizeof(struct dumper));
						dnode = dnode->next;
						if (!dnode)
							goto mem_fail;

						dnode->s = "";
						dnode->next = calloc(1,
						    sizeof(struct dumper));
						dnode = dnode->next;
						if (!dnode)
							goto mem_fail;
					}
					current_section = cb->section;
				}
				dnode->s = cb->tag;
				dnode->v = cb->value;
				dnode->next = calloc(1, sizeof(struct dumper));
				dnode = dnode->next;
				if (!dnode)
					goto mem_fail;
				last = cb;
			}
		}

	if (last)
		if (asprintf(&dnode->s, "[%s]", last->section) == -1)
			goto mem_fail;
	conf_report_dump(dumper);

	return;

mem_fail:
	log_error("conf_report: malloc/calloc failed");
	while ((dnode = dumper) != 0) {
		dumper = dumper->next;
		free(dnode->s);
		free(dnode);
	}
}
@


1.105
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.104 2015/08/20 22:02:21 deraadt Exp $	 */
d978 1
a978 1
	char           *current_section = (char *)0;
@


1.104
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.103 2013/11/22 04:12:47 deraadt Exp $	 */
d291 1
a291 1
 *     {DES,BLF,3DES,CAST,AES,AES-{128,192,256}-{MD5,SHA,SHA2-{256,384,512}} \
d297 1
a297 1
 *       {cipher} = DES, 3DES, CAST, BLF, AES, AES-{128,192,256}, AESCTR
d480 1
a480 1
	char	*mm_enc[] = {"DES_CBC", "BLOWFISH_CBC", "3DES_CBC", "CAST_CBC",
d482 1
a482 1
	char	*mm_enc_p[] = {"DES", "BLF", "3DES", "CAST", "AES", "AES-128",
d489 1
a489 1
	char	*qm_enc[] = {"DES", "3DES", "CAST", "BLOWFISH", "AES",
d494 1
a494 1
	char	*qm_enc_p[] = {"-DES", "-3DES", "-CAST", "-BLF", "-AES",
@


1.103
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.102 2013/03/21 04:30:14 deraadt Exp $	 */
d981 1
a981 1
	dumper = dnode = (struct dumper *)calloc(1, sizeof *dumper);
d998 2
a999 3
						dnode->next = (struct dumper *)
						    calloc(1,
							sizeof(struct dumper));
d1005 2
a1006 3
						dnode->next = (struct dumper *)
						    calloc(1,
							sizeof(struct dumper));
d1015 1
a1015 2
				dnode->next = (struct dumper *)
				    calloc(1, sizeof(struct dumper));
@


1.102
log
@remove excessive includes
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.101 2012/07/13 15:16:18 mikeb Exp $	 */
d95 1
a95 1
		hash = ((hash << 1) | (hash >> 7)) ^ tolower(*s);
d245 1
a245 1
			    isspace(val[j]); j--)
d766 1
a766 1
		while (isspace(*field))
d770 1
a770 1
			for (t = p - 1; t > field && isspace(*t); t--)
@


1.101
log
@Support additional MODP DH groups in the Phase 1 and Phase 2.
lteo@@ noticed that ipsecctl allowed them within the ike rules
while isakmpd failed to load the generated configuration.
The fix was verified by hshoexer, ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.100 2012/06/30 14:51:31 naddy Exp $	 */
d33 1
a33 1
#include <sys/param.h>
@


1.100
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.99 2010/09/22 13:45:15 mikeb Exp $	 */
d485 2
a486 1
		    "MODP_1536", "MODP_2048", "MODP_3072", 0};
d488 1
a488 1
		    "-GRP15", 0};
@


1.99
log
@Support for use of AES-GCM-16 (as AESGCM) and ENCR_NULL_AUTH_AES_GMAC
(as AESGMAC) ciphers in the ISAKMP Phase 2 (aka Quick Mode).

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.98 2010/08/04 18:09:45 deraadt Exp $	 */
d437 1
d442 1
d447 1
d489 2
a490 1
		    "AES", "AES", "AES", "AES_128_CTR", "AES_GCM_16",
d495 1
@


1.98
log
@fixup keylength for aes-128-cbc in quickmode
from mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.97 2008/02/17 10:36:32 hshoexer Exp $	 */
d405 5
d436 3
a438 1
	else if (strcmp(qme_p ,"-AES-128") == 0)
d440 3
a442 1
	else if (strcmp(qme_p ,"-AES-192") == 0)
d444 5
a448 3
        else if (strcmp(qme_p ,"-AES-256") == 0)
                conf_set(tr, sect, "KEY_LENGTH", "256,256:256", 0, 1);
	else if (strcmp(qme ,"AES") == 0)
d486 3
a488 1
		    "AES", "AES", "AES", "AES_128_CTR", "NULL", "NONE", 0};
d490 3
a492 1
		    "-AES-128", "-AES-192", "-AES-256", "-AESCTR", "-NULL",
@


1.97
log
@Define default configurations for AES-192 and AES-256.  From Mitja Muzenic
<mitja at muzenic dot net>, diff provided already quite some time ago,
many many thanks.  This should have gone in months ago but I was slacking,
sorry for that.
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.96 2007/06/01 10:27:17 moritz Exp $	 */
d432 1
a432 1
		conf_set(tr, sect, "KEY_LENGTH", "128,192:128", 0, 1);
@


1.96
log
@Let conf_trans_node() set all parts of the node, so that we don't
have to expose the node to the outside.

Without this, conf_trans_node() created a node, linked it into the
conf_trans queue and returned it to the caller. If something failed
in one of the callers, the half-initialized node would still be
linked in the queue and could get accessed later on.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.95 2007/04/22 11:34:36 moritz Exp $	 */
d291 2
a292 2
 *     {DES,BLF,3DES,CAST,AES}-{MD5,SHA,SHA2-{256,384,512}}[-GRP{1,2,5,14,15}] \
 *         [-{DSS,RSA_SIG}]
d297 1
a297 1
 *       {cipher} = DES, 3DES, CAST, BLF, AES, AESCTR
d364 6
d431 6
d440 1
d467 3
a469 2
		    "AES_CBC", 0};
	char	*mm_enc_p[] = {"DES", "BLF", "3DES", "CAST", "AES", 0};
d475 1
a475 1
		    "AES_128_CTR", "NULL", "NONE", 0};
d477 2
a478 1
		    "-AESCTR", "-NULL", "", 0};
@


1.95
log
@Free allocated node in conf_set_now() before failing,
so we do not leak memory.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.94 2007/04/16 13:01:39 moritz Exp $	 */
d815 3
a817 2
static struct conf_trans *
conf_trans_node(int transaction, enum conf_op op)
d825 1
a825 1
		return 0;
d829 3
a831 17
	TAILQ_INSERT_TAIL(&conf_trans_queue, node, link);
	return node;
}

/* Queue a set operation.  */
int
conf_set(int transaction, char *section, char *tag, char *value, int override,
    int is_default)
{
	struct conf_trans *node;

	node = conf_trans_node(transaction, CONF_SET);
	if (!node)
		return 1;
	node->section = strdup(section);
	if (!node->section) {
		log_error("conf_set: strdup (\"%s\") failed", section);
d833 1
a833 4
	}
	node->tag = strdup(tag);
	if (!node->tag) {
		log_error("conf_set: strdup (\"%s\") failed", tag);
d835 1
a835 4
	}
	node->value = strdup(value);
	if (!node->value) {
		log_error("conf_set: strdup (\"%s\") failed", value);
d837 1
a837 3
	}
	node->override = override;
	node->is_default = is_default;
d841 1
d843 1
a843 1
	free(node->section);
d848 9
d861 2
a862 21
	struct conf_trans *node;

	node = conf_trans_node(transaction, CONF_REMOVE);
	if (!node)
		goto fail;
	node->section = strdup(section);
	if (!node->section) {
		log_error("conf_remove: strdup (\"%s\") failed", section);
		goto fail;
	}
	node->tag = strdup(tag);
	if (!node->tag) {
		log_error("conf_remove: strdup (\"%s\") failed", tag);
		goto fail;
	}
	return 0;

fail:
	free(node->section);
	free(node);
	return 1;
d869 2
a870 16
	struct conf_trans *node;

	node = conf_trans_node(transaction, CONF_REMOVE_SECTION);
	if (!node)
		goto fail;
	node->section = strdup(section);
	if (!node->section) {
		log_error("conf_remove_section: strdup (\"%s\") failed",
		    section);
		goto fail;
	}
	return 0;

fail:
	free(node);
	return 1;
@


1.94
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.93 2007/02/19 09:43:34 hshoexer Exp $	 */
a188 1
	node->value = NULL;
a189 1
	node->tag = NULL;
d191 1
a191 1
	node->section = NULL;
@


1.93
log
@isakmpd bits for ESP+NULL encryption.  This is useful, when AH can
not be used (when being behind NAT).  With Martin Hedenfalk
<martin.hedenfalk at gmail.com>, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.92 2006/08/29 08:51:28 hshoexer Exp $	 */
d188 6
a193 12
	if (node->value) {
		free(node->value);
		node->value = NULL;
	}
	if (node->tag) {
		free(node->tag);
		node->tag = NULL;
	}
	if (node->section) {
		free(node->section);
		node->section = NULL;
	}
d218 1
a218 2
		if (section)
			free(section);
d625 1
a625 2
	if (new_conf_addr)
		free(new_conf_addr);
d755 1
a755 2
	if (node)
		free(node);
d758 1
a758 2
	if (liststr)
		free(liststr);
d789 1
a789 2
	if (node)
		free(node);
d802 1
a802 2
		if (node->field)
			free(node->field);
d864 3
a866 6
	if (node->tag)
		free(node->tag);
	if (node->section)
		free(node->section);
	if (node)
		free(node);
d892 2
a893 4
	if (node->section)
		free(node->section);
	if (node)
		free(node);
d915 1
a915 2
	if (node)
		free(node);
d947 3
a949 6
			if (node->section)
				free(node->section);
			if (node->tag)
				free(node->tag);
			if (node->value)
				free(node->value);
d1047 1
a1047 2
		if (dnode->s)
			free(dnode->s);
@


1.92
log
@Properly define quick mode suites for AH.  With naddy.
ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.91 2006/06/10 21:15:45 hshoexer Exp $	 */
d470 1
a470 1
		    "AES_128_CTR", "NONE", 0};
d472 1
a472 1
		    "-AESCTR", "", 0};
@


1.91
log
@Make deletion of SAs on shutdown optional.  The default behaviour
now is to not delete SAs.  Needed for reliable ipsec failover.
Suggested by mtu@@.  Moreover, this ensures that packets do not leak
when isakmpd is shutdown.

ok mcbride@@, testing mtu@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.90 2006/06/10 21:09:45 msf Exp $	 */
d385 1
a385 1
    char *qmh_p, char *dhg_p, int proto, int mode, int pfs)
d395 11
a405 1
	if (proto == 1 && strcmp(qmh, "NONE") == 0) /* AH */
d427 4
a430 1
	conf_set(tr, sect, "TRANSFORM_ID", qme, 0, 1);
d470 1
a470 1
		    "AES_128_CTR", 0};
d472 1
a472 1
		    "-AESCTR", 0};
d478 2
d559 1
@


1.90
log
@Allow isakmpd to use a different private rsa key per isakmp ID. Hans wrote this a long time ago, I synced it to -current and tested.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.89 2006/06/10 21:07:10 hshoexer Exp $	 */
d488 2
@


1.89
log
@This shouldn't have been commited yet.
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.88 2006/06/10 20:10:02 hshoexer Exp $	 */
d481 2
@


1.88
log
@support sha2 for main mode hmacs and aesctr for quick mode encryption.
ok markus@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.87 2006/05/27 17:01:46 hshoexer Exp $	 */
a485 2

	conf_set(tr, "General", "Delete-SAs", CONF_DFLT_DELETE_SAS, 0, 1);
@


1.87
log
@add group15/modp3072 to default configurations.
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.86 2005/12/28 10:57:35 hshoexer Exp $	 */
d300 2
a301 1
 *     {DES,BLF,3DES,CAST,AES}-{MD5,SHA}[-GRP{1,2,5,14,15}][-{DSS,RSA_SIG}]
d306 2
a307 2
 *       {cipher} = DES, 3DES, CAST, BLF, AES
 *       {hash}   = MD5, SHA, RIPEMD, SHA2-{-256,384,512}
d361 1
a361 1
    char *mme_p, char *mma_p, char *dhg_p)
d365 1
a365 1
	snprintf(sect, sizeof sect, "%s-%s%s%s", mme_p, mmh, dhg_p, mma_p);
d445 4
a448 1
	char	*mm_hash[] = {"MD5", "SHA", 0};
d456 4
a459 2
	char	*qm_enc[] = {"DES", "3DES", "CAST", "BLOWFISH", "AES", 0};
	char	*qm_enc_p[] = {"-DES", "-3DES", "-CAST", "-BLF", "-AES", 0};
d487 2
d516 2
a517 1
					    mm_auth_p[auth], dhgroup_p[group]);
@


1.86
log
@remove some unused functions and an unused variable found by lint.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.85 2005/11/14 23:25:11 deraadt Exp $	 */
d300 1
a300 1
 *     {DES,BLF,3DES,CAST,AES}-{MD5,SHA}[-GRP{1,2,5,14}][-{DSS,RSA_SIG}]
d307 1
a307 1
 *       {group}  = GRP1, GRP2, GRP5, GRP14
d449 3
a451 2
		    "MODP_1536", "MODP_2048", 0};
	char	*dhgroup_p[] = {"", "-GRP1", "-GRP2", "-GRP5", "-GRP14", 0};
@


1.85
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.84 2005/08/02 09:08:40 hshoexer Exp $	 */
a76 26
/*
 * Radix-64 Encoding.
 */
const u_int8_t  bin2asc[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

const u_int8_t  asc2bin[] =
{
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 255, 255, 255, 255, 255,
	255, 255, 255, 62, 255, 255, 255, 63,
	52, 53, 54, 55, 56, 57, 58, 59,
	60, 61, 255, 255, 255, 255, 255, 255,
	255, 0, 1, 2, 3, 4, 5, 6,
	7, 8, 9, 10, 11, 12, 13, 14,
	15, 16, 17, 18, 19, 20, 21, 22,
	23, 24, 25, 255, 255, 255, 255, 255,
	255, 26, 27, 28, 29, 30, 31, 32,
	33, 34, 35, 36, 37, 38, 39, 40,
	41, 42, 43, 44, 45, 46, 47, 48,
	49, 50, 51, 255, 255, 255, 255, 255
};

a775 59
}

/* Decode a PEM encoded buffer.  */
int
conf_decode_base64(u_int8_t *out, u_int32_t *len, u_char *buf)
{
	u_int32_t	c = 0;
	u_int8_t	c1, c2, c3, c4;

	while (*buf) {
		if (*buf > 127 || (c1 = asc2bin[*buf]) == 255)
			return 0;
		buf++;

		if (*buf > 127 || (c2 = asc2bin[*buf]) == 255)
			return 0;
		buf++;

		if (*buf == '=') {
			c3 = c4 = 0;
			c++;

			/* Check last four bit */
			if (c2 & 0xF)
				return 0;

			if (strcmp((char *)buf, "==") == 0)
				buf++;
			else
				return 0;
		} else if (*buf > 127 || (c3 = asc2bin[*buf]) == 255)
			return 0;
		else {
			if (*++buf == '=') {
				c4 = 0;
				c += 2;

				/* Check last two bit */
				if (c3 & 3)
					return 0;

				if (strcmp((char *)buf, "="))
					return 0;

			} else if (*buf > 127 || (c4 = asc2bin[*buf]) == 255)
				return 0;
			else
				c += 3;
		}

		buf++;
		*out++ = (c1 << 2) | (c2 >> 4);
		*out++ = (c2 << 4) | (c3 >> 2);
		*out++ = (c3 << 6) | c4;
	}

	*len = c;
	return 1;

@


1.84
log
@Make sure to always load at least the default configuration values.  Fixes a
problem noticed by Yaron Wahl, who also pointed out that problem.  Thanks!

ok mpf@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.83 2005/05/26 02:38:35 cloder Exp $	 */
d1065 1
a1065 1
	unsigned int	i, len;
d1083 2
a1084 4
						len = strlen(current_section)
						    + 3;
						dnode->s = malloc(len);
						if (!dnode->s)
a1085 3

						snprintf(dnode->s, len, "[%s]",
						    current_section);
d1114 2
a1115 4
	if (last) {
		len = strlen(last->section) + 3;
		dnode->s = malloc(len);
		if (!dnode->s)
a1116 2
		snprintf(dnode->s, len, "[%s]", last->section);
	}
@


1.83
log
@Handle strdup returning NULL. OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.82 2005/04/08 22:32:09 cloder Exp $	 */
d583 7
a589 3
	if ((fd = monitor_open(conf_path, O_RDONLY, 0)) != -1) {
		if (check_file_secrecy_fd(fd, conf_path, &sz))
			goto fail;
d591 2
a610 6
	} else {
		if (errno != ENOENT)
			log_error("conf_reinit: open(\"%s\", O_RDONLY, 0) "
			    "failed", conf_path);

		trans = conf_begin();
@


1.82
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.81 2005/04/08 17:15:01 deraadt Exp $	 */
d200 7
a206 3
	node->section = strdup(section);
	node->tag = strdup(tag);
	node->value = strdup(value);
d213 14
@


1.81
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.80 2005/04/08 16:04:17 deraadt Exp $	 */
a46 2

#include "sysdep.h"
@


1.80
log
@un-ifdef USE_BLOWFISH
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.79 2005/04/06 16:00:20 deraadt Exp $	 */
a486 1
#ifdef USE_KEYNOTE
a488 1
#endif
@


1.79
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.78 2005/04/05 20:46:20 cloder Exp $	 */
d321 1
a321 1
 * XXX We may want to support USE_BLOWFISH, USE_TRIPLEDES, etc...
@


1.78
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.77 2005/04/04 19:31:11 deraadt Exp $	 */
d140 2
a141 2
		if (strcasecmp(cb->section, section) == 0
		    && strcasecmp(cb->tag, tag) == 0) {
@


1.77
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.76 2005/03/15 20:33:07 moritz Exp $	 */
a477 1
#ifdef USE_X509
a485 1
#endif
@


1.76
log
@reset config line numbers, when daemon gets reinitialized.
prevents wrong line numbers in error cases.
help from jaredy@@ and ok hshoexer@@.
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.75 2005/03/10 17:30:31 cloder Exp $	 */
d696 2
a697 2
	     "conf_get_str: configuration value not found [%s]:%s", section,
	     tag));
@


1.75
log
@Avoid memory leak if strdup should fail.
OK hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.74 2004/12/14 10:17:28 mcbride Exp $	 */
d218 1
a218 1
conf_parse_line(int trans, char *line, size_t sz)
a223 3
	static int ln = 0;

	ln++;
d283 1
d293 1
a293 1
				conf_parse_line(trans, line, cp - line);
d296 1
@


1.74
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.73 2004/08/08 19:11:06 deraadt Exp $	 */
d711 1
a711 1
	struct conf_list_node *node;
d750 2
d763 1
a763 1
	struct conf_list_node *node;
d786 2
@


1.73
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.72 2004/07/29 20:02:02 ho Exp $	 */
d651 1
a651 1
	if (text2sockaddr(value, 0, &sa) == -1)
@


1.72
log
@Less noise while debugging.
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.71 2004/06/25 20:25:34 hshoexer Exp $	 */
d452 1
a452 1
	
d1077 1
a1077 1
						    calloc(1, 
d1085 1
a1085 1
						    calloc(1, 
@


1.71
log
@Keynote policy checking can now be disabled by "-K" switch and config tag
"Use-Keynote".  Default is to use keynote.

ok henning@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.70 2004/06/14 13:53:31 hshoexer Exp $	 */
d377 1
a377 1
	LOG_DBG((LOG_MISC, 90, "conf_load_defaults_mm: main mode %s", sect));
d414 1
a414 1
	LOG_DBG((LOG_MISC, 90, "conf_load_defaults_qm: quick mode %s", sect));
d668 1
a668 1
		LOG_DBG((LOG_MISC, 90, "conf_match_num: %s:%s %d==%d?",
d672 1
a672 1
		LOG_DBG((LOG_MISC, 90, "conf_match_num: %s:%s %d<=%d<=%d?",
@


1.70
log
@avoid stat before open

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.69 2004/06/14 09:55:41 ho Exp $	 */
d474 1
@


1.69
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.68 2004/06/09 14:02:44 ho Exp $	 */
d377 1
a377 1
	LOG_DBG((LOG_MISC, 90, "conf_load_defaults : main mode %s", sect));
d414 1
a414 1
	LOG_DBG((LOG_MISC, 90, "conf_load_defaults : quick mode %s", sect));
a569 1
	struct stat sb;
d571 3
a573 3
	if ((monitor_stat(conf_path, &sb) == 0) || (errno != ENOENT)) {
		if (check_file_secrecy(conf_path, &sz))
			return;
a574 6
		fd = monitor_open(conf_path, O_RDONLY, 0);
		if (fd == -1) {
			log_error("conf_reinit: "
			    "open (\"%s\", O_RDONLY) failed", conf_path);
			return;
		}
d593 5
a597 1
	} else
d599 1
@


1.68
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.67 2004/05/14 08:42:56 hshoexer Exp $	 */
d241 1
a241 1
			    "non-matched ']', ignoring until next section", ln);
d302 1
a302 1
		log_print("conf_parse: last line non-terminated, ignored.");
d359 2
a360 1
				if (*(p + strlen(p)) && *(p + strlen(p)) != ',')
d578 2
a579 2
			log_error("conf_reinit: open (\"%s\", O_RDONLY) failed",
			    conf_path);
d1078 2
a1079 1
						    calloc(1, sizeof(struct dumper));
d1086 2
a1087 1
						    calloc(1, sizeof(struct dumper));
@


1.67
log
@Some more KNF, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.66 2004/04/23 14:15:55 ho Exp $	 */
d1029 1
a1029 1
conf_report_dump(struct dumper * node)
@


1.66
log
@Make sure KEY_LENGTH attribute is present when checking AES proposals,
required when acting as responder to SafeNet peers.
Also make conf_load_defaults() readable again (KNF).
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.65 2004/04/15 20:20:55 deraadt Exp $	 */
d64 1
a64 1
	int             trans;
d67 6
a72 6
	}               op;
	char           *section;
	char           *tag;
	char           *value;
	int             override;
	int             is_default;
d107 4
a110 4
	char           *section;
	char           *tag;
	char           *value;
	int             is_default;
d113 1
a113 1
char           *conf_path = CONFIG_FILE;
d116 1
a116 1
static char    *conf_addr;
d120 1
a120 1
	u_int8_t        hash = 0;
d137 2
a138 1
	for (cb = LIST_FIRST(&conf_bindings[conf_hash(section)]); cb; cb = next) {
d143 2
a144 2
			LOG_DBG((LOG_MISC, 95, "[%s]:%s->%s removed", section, tag,
			    cb->value));
d159 1
a159 1
	int             unseen = 1;
d161 2
a162 1
	for (cb = LIST_FIRST(&conf_bindings[conf_hash(section)]); cb; cb = next) {
d167 2
a168 2
			LOG_DBG((LOG_MISC, 95, "[%s]:%s->%s removed", section, cb->tag,
			    cb->value));
d184 1
a184 1
	     int is_default)
d192 2
a193 2
			log_print("conf_set_now: duplicate tag [%s]:%s, ignoring...\n",
			    section, tag);
d198 2
a199 2
		log_error("conf_set_now: calloc (1, %lu) failed", (unsigned long) sizeof
		    *node);
d208 2
a209 2
	LOG_DBG((LOG_MISC, 95, "conf_set_now: [%s]:%s->%s", node->section, node->tag,
	    node->value));
d220 5
a224 5
	char           *val;
	size_t          i;
	int             j;
	static char    *section = 0;
	static int      ln = 0;
d247 2
a248 2
			log_print("conf_parse_line: %d: malloc (%lu) failed", ln,
			    (unsigned long) i);
d266 2
a267 1
			for (j = sz - (val - line) - 1; j > 0 && isspace(val[j]); j--)
d283 3
a285 3
	char           *cp = buf;
	char           *bufend = buf + sz;
	char           *line;
d327 1
a327 1
static char    *
d333 3
a335 3
	     node = TAILQ_NEXT(node, link))
		if (node->trans == trans && strcasecmp(section, node->section) == 0
		    && strcasecmp(tag, node->tag) == 0) {
d350 1
a350 1
	char           *p;
d354 1
a354 1
	     node = TAILQ_NEXT(node, link))
d449 2
a450 2
	int             enc, auth, hash, group, proto, mode, pfs;
	char            *dflt;
d452 16
a467 19
	char           *mm_auth[] = {"PRE_SHARED", "DSS", "RSA_SIG", 0};
	char           *mm_auth_p[] = {"", "-DSS", "-RSA_SIG", 0};
	char           *mm_hash[] = {"MD5", "SHA", 0};
	char           *mm_enc[] = {"DES_CBC", "BLOWFISH_CBC", "3DES_CBC",
				    "CAST_CBC", "AES_CBC", 0};
	char           *mm_enc_p[] = {"DES", "BLF", "3DES", "CAST", "AES", 0};
	char           *dhgroup[] = {"MODP_1024", "MODP_768", "MODP_1024",
				     "MODP_1536", "MODP_2048", 0};
	char           *dhgroup_p[] = {"", "-GRP1", "-GRP2", "-GRP5", "-GRP14",
				       0};
	char           *qm_enc[] = {"DES", "3DES", "CAST", "BLOWFISH", "AES",
				    0};
	char           *qm_enc_p[] = {"-DES", "-3DES", "-CAST", "-BLF",
				      "-AES", 0};
	char           *qm_hash[] = {"HMAC_MD5", "HMAC_SHA", "HMAC_RIPEMD",
				     "HMAC_SHA2_256", "HMAC_SHA2_384",
				     "HMAC_SHA2_512", "NONE", 0};
	char           *qm_hash_p[] = {"-MD5", "-SHA", "-RIPEMD", "-SHA2-256",
				       "-SHA2-384", "-SHA2-512", "", 0};
d489 2
a490 2
	conf_set(tr, "KeyNote", "Credential-directory", CONF_DFLT_KEYNOTE_CRED_DIR,
		 0, 1);
d496 1
a496 1
		 CONF_DFLT_TYPE_LIFE_MAIN_MODE, 0, 1);
d498 1
a498 1
		 (dflt ? dflt : CONF_DFLT_VAL_LIFE_MAIN_MODE), 0, 1);
d502 1
a502 1
		 CONF_DFLT_TYPE_LIFE_QUICK_MODE, 0, 1);
d504 1
a504 1
		 (dflt ? dflt : CONF_DFLT_VAL_LIFE_QUICK_MODE), 0, 1);
d508 1
a508 1
		 CONF_DFLT_PHASE1_EXCH_TYPE, 0, 1);
d510 1
a510 1
		 CONF_DFLT_PHASE1_TRANSFORMS, 0, 1);
d538 1
a538 1
						     dhgroup_p[group]; group++)
d552 1
a552 1
	unsigned int    i;
d565 5
a569 5
	int             fd, trans;
	unsigned int    i;
	size_t          sz;
	char           *new_conf_addr = 0;
	struct stat     sb;
d577 2
a578 1
			log_error("conf_reinit: open (\"%s\", O_RDONLY) failed", conf_path);
d583 2
a584 1
			log_error("conf_reinit: malloc (%lu) failed", (unsigned long) sz);
d588 1
a588 1
		if (read(fd, new_conf_addr, sz) != (int) sz) {
d590 1
a590 1
				  fd, new_conf_addr, (unsigned long) sz);
d607 2
a608 1
		for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
d610 1
a610 1
			     cb = LIST_FIRST(&conf_bindings[i]))
d631 1
a631 1
	char           *value = conf_get_str(section, tag);
d646 1
a646 1
	char           *value = conf_get_str(section, tag);
d660 2
a661 2
	char           *value = conf_get_str(section, tag);
	int             val, min, max, n;
d668 2
a669 2
		LOG_DBG((LOG_MISC, 90, "conf_match_num: %s:%s %d==%d?", section, tag,
			 val, x));
d672 2
a673 2
		LOG_DBG((LOG_MISC, 90, "conf_match_num: %s:%s %d<=%d<=%d?", section,
			 tag, min, x, max));
d676 2
a677 2
		log_error("conf_match_num: section %s tag %s: invalid number spec %s",
			  section, tag, value);
d683 1
a683 1
char           *
d689 5
a693 5
	     cb = LIST_NEXT(cb, link))
		if (strcasecmp(section, cb->section) == 0
		    && strcasecmp(tag, cb->tag) == 0) {
			LOG_DBG((LOG_MISC, 95, "conf_get_str: [%s]:%s->%s", section,
				 tag, cb->value));
d698 1
a698 1
		 tag));
d709 1
a709 1
	char           *liststr = 0, *p, *field, *t;
d770 1
a770 1
	     cb = LIST_NEXT(cb, link))
d791 1
a791 1
conf_decode_base64(u_int8_t * out, u_int32_t * len, u_char * buf)
d793 2
a794 2
	u_int32_t       c = 0;
	u_int8_t        c1, c2, c3, c4;
d813 1
a813 1
			if (strcmp((char *) buf, "==") == 0)
d828 1
a828 1
				if (strcmp((char *) buf, "="))
d849 1
a849 1
conf_free_list(struct conf_list * list)
d866 1
a866 1
	static int      seq = 0;
d879 1
a879 1
			  (unsigned long) sizeof *node);
d891 1
a891 1
	 int is_default)
d967 2
a968 1
		log_error("conf_remove_section: strdup (\"%s\") failed", section);
d996 2
a997 1
					conf_remove_now(node->section, node->tag);
d1003 2
a1004 2
					log_print("conf_end: unknown operation: %d",
					    node->op);
d1024 2
a1025 2
	char           *s, *v;
	struct dumper  *next;
d1050 2
a1051 2
	unsigned int    i, len;
	char           *current_section = (char *) 0;
d1054 1
a1054 1
	dumper = dnode = (struct dumper *) calloc(1, sizeof *dumper);
d1062 1
a1062 1
		     cb = LIST_NEXT(cb, link)) {
d1065 2
a1066 2
				if (!current_section ||
				    strcmp(cb->section, current_section)) {
d1068 2
a1069 1
						len = strlen(current_section) + 3;
@


1.65
log
@more knf; ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.64 2004/04/15 18:53:56 deraadt Exp $	 */
d75 2
d366 2
a367 1
conf_load_defaults(int tr)
d369 5
a373 4
#define CONF_MAX 256
	int             enc, auth, hash, group, group_max, proto, mode,
	                pfs;
	char            sect[CONF_MAX], *dflt;
d375 13
a387 9
	char           *mm_auth[] = {"PRE_SHARED", "DSS", "RSA_SIG", 0};
	char           *mm_hash[] = {"MD5", "SHA", 0};
	char           *mm_enc[] = {"DES_CBC", "BLOWFISH_CBC", "3DES_CBC",
	"CAST_CBC", "AES_CBC", 0};
	char           *dh_group[] = {"MODP_768", "MODP_1024", "MODP_1536", "MODP_2048", 0};
	char           *qm_enc[] = {"DES", "3DES", "CAST", "BLOWFISH", "AES", 0};
	char           *qm_hash[] = {"HMAC_MD5", "HMAC_SHA", "HMAC_RIPEMD",
		"HMAC_SHA2_256", "HMAC_SHA2_384", "HMAC_SHA2_512",
	"NONE", 0};
d389 5
a393 8
	/* Abbreviations to make section names a bit shorter.  */
	char           *mm_auth_p[] = {"", "-DSS", "-RSA_SIG", 0};
	char           *mm_enc_p[] = {"DES", "BLF", "3DES", "CAST", "AES", 0};
	char           *dh_group_p[] = {"-GRP1", "-GRP2", "-GRP5", "-GRP14", "", 0};
	char           *qm_enc_p[] = {"-DES", "-3DES", "-CAST", "-BLF", "-AES", 0};
	char           *qm_hash_p[] = {"-MD5", "-SHA", "-RIPEMD",
		"-SHA2-256", "-SHA2-384", "-SHA2-512",
	"", 0};
d400 68
a467 1
	group_max = sizeof dh_group / sizeof *dh_group - 1;
d471 2
a472 1
	conf_set(tr, "General", "Exchange-max-time", CONF_DFLT_EXCH_MAX_TIME, 0, 1);
d474 2
a475 1
	conf_set(tr, "General", "Pubkey-directory", CONF_DFLT_PUBKEY_DIR, 0, 1);
d478 8
a485 8
	conf_set(tr, "X509-certificates", "CA-directory", CONF_DFLT_X509_CA_DIR, 0,
		 1);
	conf_set(tr, "X509-certificates", "Cert-directory", CONF_DFLT_X509_CERT_DIR,
		 0, 1);
	conf_set(tr, "X509-certificates", "Private-key", CONF_DFLT_X509_PRIVATE_KEY,
		 0, 1);
	conf_set(tr, "X509-certificates", "CRL-directory", CONF_DFLT_X509_CRL_DIR,
		 0, 1);
d513 8
a520 40
	for (enc = 0; mm_enc[enc]; enc++) {
		for (hash = 0; mm_hash[hash]; hash++) {
			for (auth = 0; mm_auth[auth]; auth++) {
				for (group = 0; dh_group_p[group]; group++) {
					/* special */
					snprintf(sect, sizeof sect, "%s-%s%s%s",
					    mm_enc_p[enc], mm_hash[hash],
					    dh_group_p[group], mm_auth_p[auth]);

#if 0
					if (!conf_find_trans_xf(1, sect))
						continue;
#endif

					LOG_DBG((LOG_MISC, 90,
					    "conf_load_defaults : main mode %s",
					    sect));

					conf_set(tr, sect, "ENCRYPTION_ALGORITHM",
					    mm_enc[enc], 0, 1);
					if (strcmp(mm_enc[enc], "BLOWFISH_CBC") == 0)
						conf_set(tr, sect, "KEY_LENGTH",
						    CONF_DFLT_VAL_BLF_KEYLEN, 0, 1);

					conf_set(tr, sect, "HASH_ALGORITHM",
					    mm_hash[hash], 0, 1);
					conf_set(tr, sect, "AUTHENTICATION_METHOD",
					    mm_auth[auth], 0, 1);

					/* XXX Always DH group 2 (MODP_1024) */
					conf_set(tr, sect, "GROUP_DESCRIPTION",
					    dh_group[group < group_max ? group : 1],
					    0, 1);

					conf_set(tr, sect, "Life",
					    CONF_DFLT_TAG_LIFE_MAIN_MODE, 0, 1);
				}
			}
		}
	}
a523 1

d526 1
a526 1
		 "Default-phase-1-configuration", 0, 1);
d532 11
a542 18
	for (enc = 0; qm_enc[enc]; enc++) {
		for (proto = 0; proto < 2; proto++) {
			for (mode = 0; mode < 2; mode++) {
				for (pfs = 0; pfs < 2; pfs++) {
					for (hash = 0; qm_hash[hash]; hash++) {
						for (group = 0; dh_group_p[group];
						    group++) {
							char tmp[CONF_MAX];

							if ((proto == 1 &&
							    strcmp(qm_hash[hash],
							    "NONE") == 0)) /* AH */
								continue;

							snprintf(tmp, sizeof tmp,
							    "QM-%s%s%s%s%s%s",
							    PROTO(proto),
							    MODE_p(mode),
d545 2
a546 78
							    PFS(pfs),
							    dh_group_p[group]);

							strlcpy(sect, tmp, CONF_MAX);
							strlcat(sect, "-SUITE",
							    CONF_MAX);

#if 0
							if (!conf_find_trans_xf(2, sect))
								continue;
#endif

							LOG_DBG((LOG_MISC, 90,
							    "conf_load_defaults : quick mode %s",
							    sect));

							conf_set(tr, sect, "Protocols",
							    tmp, 0, 1);

							snprintf(sect, sizeof sect,
							    "IPSEC_%s", PROTO(proto));
							conf_set(tr, tmp, "PROTOCOL_ID",
							    sect, 0, 1);

							strlcpy(sect, tmp, CONF_MAX);
							strlcat(sect, "-XF", CONF_MAX);
							conf_set(tr, tmp, "Transforms",
							    sect, 0, 1);

							/*
							 * XXX For now, defaults
							 * contain one xf per protocol.
							 */

							conf_set(tr, sect,
							    "TRANSFORM_ID",
							    qm_enc[enc], 0, 1);

							if (strcmp(qm_enc[enc],
							    "BLOWFISH") == 0)
								conf_set(tr, sect,
								    "KEY_LENGTH",
								    CONF_DFLT_VAL_BLF_KEYLEN,
								    0, 1);

							conf_set(tr, sect,
							    "ENCAPSULATION_MODE",
							    MODE(mode), 0, 1);

							if (strcmp(qm_hash[hash], "NONE")) {
								conf_set(tr, sect, "AUTHENTICATION_ALGORITHM",
								    qm_hash[hash], 0, 1);

								/*
								 * XXX
								 *
								 * Another shortcut:
								 * to keep length down
								 */
								if (pfs)
									conf_set(tr, sect, "GROUP_DESCRIPTION",
									    dh_group[group < group_max ? group : 1],
									    0, 1);
							}
							/*
							 * XXX
							 * Lifetimes depending
							 * on enc/auth strength?
							 */
							conf_set(tr, sect, "Life", CONF_DFLT_TAG_LIFE_QUICK_MODE, 0,
							    1);

						}
					}
				}
			}
		}
	}
@


1.64
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.63 2004/04/15 18:39:25 deraadt Exp $	 */
d141 1
a141 1
				 cb->value));
d164 1
a164 1
				 cb->value));
d189 1
a189 1
				  section, tag);
d195 1
a195 1
			  *node);
d205 1
a205 1
		 node->value));
d237 1
a237 1
			"non-matched ']', ignoring until next section", ln);
d244 1
a244 1
				  (unsigned long) i);
d255 2
a256 2
				log_print("conf_parse_line: %d: ignoring line due to no section",
					  ln);
a271 2

	return;
d439 8
a446 6
	for (enc = 0; mm_enc[enc]; enc++)
		for (hash = 0; mm_hash[hash]; hash++)
			for (auth = 0; mm_auth[auth]; auth++)
				for (group = 0; dh_group_p[group]; group++) {	/* special */
					snprintf(sect, sizeof sect, "%s-%s%s%s", mm_enc_p[enc],
						 mm_hash[hash], dh_group_p[group], mm_auth_p[auth]);
d453 3
a455 2
					LOG_DBG((LOG_MISC, 90, "conf_load_defaults : main mode %s",
						 sect));
d457 2
a458 1
					conf_set(tr, sect, "ENCRYPTION_ALGORITHM", mm_enc[enc], 0, 1);
d460 2
a461 2
						conf_set(tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN, 0,
							 1);
d463 4
a466 2
					conf_set(tr, sect, "HASH_ALGORITHM", mm_hash[hash], 0, 1);
					conf_set(tr, sect, "AUTHENTICATION_METHOD", mm_auth[auth], 0, 1);
d470 2
a471 1
						 dh_group[group < group_max ? group : 1], 0, 1);
d473 2
a474 1
					conf_set(tr, sect, "Life", CONF_DFLT_TAG_LIFE_MAIN_MODE, 0, 1);
d476 3
d491 12
a502 7
	for (enc = 0; qm_enc[enc]; enc++)
		for (proto = 0; proto < 2; proto++)
			for (mode = 0; mode < 2; mode++)
				for (pfs = 0; pfs < 2; pfs++)
					for (hash = 0; qm_hash[hash]; hash++)
						for (group = 0; dh_group_p[group]; group++)
							if ((proto == 1 && strcmp(qm_hash[hash], "NONE") == 0))	/* AH */
a503 6
							else {
								char            tmp[CONF_MAX];

								snprintf(tmp, sizeof tmp, "QM-%s%s%s%s%s%s", PROTO(proto),
									 MODE_p(mode), qm_enc_p[enc], qm_hash_p[hash],
									 PFS(pfs), dh_group_p[group]);
d505 12
a516 2
								strlcpy(sect, tmp, CONF_MAX);
								strlcat(sect, "-SUITE", CONF_MAX);
d519 2
a520 2
								if (!conf_find_trans_xf(2, sect))
									continue;
d523 40
a562 22
								LOG_DBG((LOG_MISC, 90, "conf_load_defaults : quick mode %s",
								     sect));

								conf_set(tr, sect, "Protocols", tmp, 0, 1);

								snprintf(sect, sizeof sect, "IPSEC_%s", PROTO(proto));
								conf_set(tr, tmp, "PROTOCOL_ID", sect, 0, 1);

								strlcpy(sect, tmp, CONF_MAX);
								strlcat(sect, "-XF", CONF_MAX);
								conf_set(tr, tmp, "Transforms", sect, 0, 1);

								/*
								 * XXX For
								 * now,
								 * defaults
								 * contain
								 * one xf per
								 * protocol.
								 */

								conf_set(tr, sect, "TRANSFORM_ID", qm_enc[enc], 0, 1);
a563 34
								if (strcmp(qm_enc[enc], "BLOWFISH") == 0)
									conf_set(tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN,
										 0, 1);

								conf_set(tr, sect, "ENCAPSULATION_MODE", MODE(mode), 0, 1);

								if (strcmp(qm_hash[hash], "NONE")) {
									conf_set(tr, sect, "AUTHENTICATION_ALGORITHM",
										 qm_hash[hash], 0, 1);

									/*
									 * XXX
									 *
									 * Ano
									 * the
									 * r
									 * sho
									 * rtc
									 * ut
									 * --
									 * to
									 * kee
									 * p
									 * len
									 * gth
									 *
									 * dow
									 * n.
									 */
									if (pfs)
										conf_set(tr, sect, "GROUP_DESCRIPTION",
											 dh_group[group < group_max ? group : 1], 0,
											 1);
								}
d566 3
a568 5
								 * Lifetimes
								 * depending
								 * on
								 * enc/auth
								 * strength?
d570 4
a573 2
								conf_set(tr, sect, "Life", CONF_DFLT_TAG_LIFE_QUICK_MODE, 0,
									 1);
d575 14
a588 1
	return;
a1156 1
	return;
@


1.63
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: conf.c,v 1.62 2004/03/19 14:04:43 hshoexer Exp $	 */
d80 2
a81 2
	const u_int8_t  bin2asc[]
	= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
d83 19
a101 27
	const u_int8_t  asc2bin[] =
	{
		255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 255, 255, 255, 255, 255,
		255, 255, 255, 62, 255, 255, 255, 63,
		52, 53, 54, 55, 56, 57, 58, 59,
		60, 61, 255, 255, 255, 255, 255, 255,
		255, 0, 1, 2, 3, 4, 5, 6,
		7, 8, 9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22,
		23, 24, 25, 255, 255, 255, 255, 255,
		255, 26, 27, 28, 29, 30, 31, 32,
		33, 34, 35, 36, 37, 38, 39, 40,
		41, 42, 43, 44, 45, 46, 47, 48,
		49, 50, 51, 255, 255, 255, 255, 255
	};

	struct conf_binding {
		LIST_ENTRY(conf_binding) link;
		char           *section;
		char           *tag;
		char           *value;
		int             is_default;
	};
d103 9
a111 1
	char           *conf_path = CONFIG_FILE;
d114 3
a116 4
	static char    *conf_addr;

	static __inline__ u_int8_t
	                conf_hash(char *s)
d1014 3
a1016 2
					conf_set_now(node->section, node->tag, node->value,
					  node->override, node->is_default);
d1025 2
a1026 1
					log_print("conf_end: unknown operation: %d", node->op);
d1087 2
a1088 1
				if (!current_section || strcmp(cb->section, current_section)) {
d1095 4
a1098 3
						snprintf(dnode->s, len, "[%s]", current_section);
						dnode->next
							= (struct dumper *) calloc(1, sizeof(struct dumper));
d1104 2
a1105 2
						dnode->next
							= (struct dumper *) calloc(1, sizeof(struct dumper));
d1114 2
a1115 1
				dnode->next = (struct dumper *) calloc(1, sizeof(struct dumper));
@


1.62
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.61 2004/02/27 19:07:16 hshoexer Exp $	*/
/*	$EOM: conf.c,v 1.48 2000/12/04 02:04:29 angelos Exp $	*/
d56 2
a57 2
static char *conf_get_trans_str (int, char *, char *);
static void conf_load_defaults (int);
d59 1
a59 1
static int conf_find_trans_xf (int, char *);
d63 10
a72 8
  TAILQ_ENTRY (conf_trans) link;
  int trans;
  enum conf_op { CONF_SET, CONF_REMOVE, CONF_REMOVE_SECTION } op;
  char *section;
  char *tag;
  char *value;
  int override;
  int is_default;
d75 1
a75 1
TAILQ_HEAD (conf_trans_head, conf_trans) conf_trans_queue;
d80 2
a81 2
const u_int8_t bin2asc[]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
d83 43
a125 44
const u_int8_t asc2bin[] =
{
  255, 255, 255, 255, 255, 255, 255, 255,
  255, 255, 255, 255, 255, 255, 255, 255,
  255, 255, 255, 255, 255, 255, 255, 255,
  255, 255, 255, 255, 255, 255, 255, 255,
  255, 255, 255, 255, 255, 255, 255, 255,
  255, 255, 255,  62, 255, 255, 255,  63,
   52,  53,  54,  55,  56,  57,  58,  59,
   60,  61, 255, 255, 255, 255, 255, 255,
  255,   0,   1,   2,   3,   4,   5,   6,
    7,   8,   9,  10,  11,  12,  13,  14,
   15,  16,  17,  18,  19,  20,  21,  22,
   23,  24,  25, 255, 255, 255, 255, 255,
  255,  26,  27,  28,  29,  30,  31,  32,
   33,  34,  35,  36,  37,  38,  39,  40,
   41,  42,  43,  44,  45,  46,  47,  48,
   49,  50,  51, 255, 255, 255, 255, 255
};

struct conf_binding {
  LIST_ENTRY (conf_binding) link;
  char *section;
  char *tag;
  char *value;
  int is_default;
};

char *conf_path = CONFIG_FILE;
LIST_HEAD (conf_bindings, conf_binding) conf_bindings[256];

static char *conf_addr;

static __inline__ u_int8_t
conf_hash (char *s)
{
  u_int8_t hash = 0;

  while (*s)
    {
      hash = ((hash << 1) | (hash >> 7)) ^ tolower (*s);
      s++;
    }
  return hash;
d132 1
a132 1
conf_remove_now (char *section, char *tag)
d134 1
a134 1
  struct conf_binding *cb, *next;
d136 13
a148 14
  for (cb = LIST_FIRST (&conf_bindings[conf_hash (section)]); cb; cb = next)
    {
      next = LIST_NEXT (cb, link);
      if (strcasecmp (cb->section, section) == 0
	  && strcasecmp (cb->tag, tag) == 0)
	{
	  LIST_REMOVE (cb, link);
	  LOG_DBG ((LOG_MISC, 95, "[%s]:%s->%s removed", section, tag,
		    cb->value));
	  free (cb->section);
	  free (cb->tag);
	  free (cb->value);
	  free (cb);
	  return 0;
d150 1
a150 2
    }
  return 1;
d154 1
a154 1
conf_remove_section_now (char *section)
d156 2
a157 2
  struct conf_binding *cb, *next;
  int unseen = 1;
d159 12
a170 13
  for (cb = LIST_FIRST (&conf_bindings[conf_hash (section)]); cb; cb = next)
    {
      next = LIST_NEXT (cb, link);
      if (strcasecmp (cb->section, section) == 0)
	{
	  unseen = 0;
	  LIST_REMOVE (cb, link);
	  LOG_DBG ((LOG_MISC, 95, "[%s]:%s->%s removed", section, cb->tag,
		    cb->value));
	  free (cb->section);
	  free (cb->tag);
	  free (cb->value);
	  free (cb);
d172 1
a172 2
    }
  return unseen;
d180 2
a181 2
conf_set_now (char *section, char *tag, char *value, int override,
	      int is_default)
d183 1
a183 1
  struct conf_binding *node = 0;
d185 23
a207 26
  if (override)
    conf_remove_now (section, tag);
  else if (conf_get_str (section, tag))
    {
      if (!is_default)
	log_print ("conf_set_now: duplicate tag [%s]:%s, ignoring...\n",
		   section, tag);
      return 1;
    }

  node = calloc (1, sizeof *node);
  if (!node)
    {
      log_error ("conf_set_now: calloc (1, %lu) failed", (unsigned long)sizeof
		 * node);
      return 1;
    }
  node->section = strdup (section);
  node->tag = strdup (tag);
  node->value = strdup (value);
  node->is_default = is_default;

  LIST_INSERT_HEAD (&conf_bindings[conf_hash (section)], node, link);
  LOG_DBG ((LOG_MISC, 95, "conf_set_now: [%s]:%s->%s", node->section, node->tag,
	    node->value));
  return 0;
d215 1
a215 1
conf_parse_line (int trans, char *line, size_t sz)
d217 33
a249 26
  char *val;
  size_t i;
  int j;
  static char *section = 0;
  static int ln = 0;

  ln++;

  /* Lines starting with '#' or ';' are comments.  */
  if (*line == '#' || *line == ';')
    return;

  /* '[section]' parsing...  */
  if (*line == '[')
    {
      for (i = 1; i < sz; i++)
	if (line[i] == ']')
	  break;
      if (section)
	free (section);
      if (i == sz)
	{
	  log_print ("conf_parse_line: %d:"
		     "non-matched ']', ignoring until next section", ln);
	  section = 0;
	  return;
d251 23
a273 29
      section = malloc (i);
      if (!section)
	{
	  log_print ("conf_parse_line: %d: malloc (%lu) failed", ln,
		(unsigned long)i);
	  return;
	}
      strlcpy (section, line + 1, i);
      return;
    }

  /* Deal with assignments.  */
  for (i = 0; i < sz; i++)
    if (line[i] == '=')
      {
	/* If no section, we are ignoring the lines.  */
	if (!section)
	  {
	    log_print ("conf_parse_line: %d: ignoring line due to no section",
		       ln);
	    return;
	  }
	line[strcspn (line, " \t=")] = '\0';
	val = line + i + 1 + strspn (line + i + 1, " \t");
	/* Skip trailing whitespace, if any */
	for (j = sz - (val - line) - 1; j > 0 && isspace (val[j]); j--)
	  val[j] = '\0';
	/* XXX Perhaps should we not ignore errors?  */
	conf_set (trans, section, line, val, 0, 0);
a274 8
      }

  /* Other non-empty lines are weird.  */
  i = strspn (line, " \t");
  if (line[i])
    log_print ("conf_parse_line: %d: syntax error", ln);

  return;
d279 1
a279 1
conf_parse (int trans, char *buf, size_t sz)
d281 20
a300 23
  char *cp = buf;
  char *bufend = buf + sz;
  char *line;

  line = cp;
  while (cp < bufend)
    {
      if (*cp == '\n')
	{
	  /* Check for escaped newlines.  */
	  if (cp > buf && *(cp - 1) == '\\')
	    *(cp - 1) = *cp = ' ';
	  else
	    {
	      *cp = '\0';
	      conf_parse_line (trans, line, cp - line);
	      line = cp + 1;
	    }
	}
      cp++;
    }
  if (cp != line)
    log_print ("conf_parse: last line non-terminated, ignored.");
d325 2
a326 2
static char *
conf_get_trans_str (int trans, char *section, char *tag)
d328 1
a328 1
  struct conf_trans *node, *nf = 0;
d330 10
a339 11
  for (node = TAILQ_FIRST (&conf_trans_queue); node;
       node = TAILQ_NEXT (node, link))
    if (node->trans == trans && strcasecmp (section, node->section) == 0
	&& strcasecmp (tag, node->tag) == 0)
      {
	if (!nf)
	  nf = node;
	else if (node->override)
	  nf = node;
      }
  return nf ? nf->value : 0;
d345 1
a345 1
conf_find_trans_xf (int phase, char *xf)
d347 2
a348 2
  struct conf_trans *node;
  char *p;
d350 13
a362 14
  /* Find the relevant transforms and suites, if any.  */
  for (node = TAILQ_FIRST (&conf_trans_queue); node;
       node = TAILQ_NEXT (node, link))
    if ((phase == 1 && strcmp ("Transforms", node->tag) == 0) ||
	(phase == 2 && strcmp ("Suites", node->tag) == 0))
      {
	p = node->value;
	while ((p = strstr (p, xf)) != NULL)
	  if (*(p + strlen (p)) && *(p + strlen (p)) != ',')
	    p += strlen (p);
	  else
	    return 1;
      }
  return 0;
d367 1
a367 1
conf_load_defaults (int tr)
d370 22
a391 21
  int enc, auth, hash, group, group_max, proto, mode, pfs;
  char sect[CONF_MAX], *dflt;

  char *mm_auth[]   = { "PRE_SHARED", "DSS", "RSA_SIG", 0 };
  char *mm_hash[]   = { "MD5", "SHA", 0 };
  char *mm_enc[]    = { "DES_CBC", "BLOWFISH_CBC", "3DES_CBC",
			"CAST_CBC", "AES_CBC", 0 };
  char *dh_group[]  = { "MODP_768", "MODP_1024", "MODP_1536", "MODP_2048", 0 };
  char *qm_enc[]    = { "DES", "3DES", "CAST", "BLOWFISH", "AES", 0 };
  char *qm_hash[]   = { "HMAC_MD5", "HMAC_SHA", "HMAC_RIPEMD",
			"HMAC_SHA2_256", "HMAC_SHA2_384", "HMAC_SHA2_512",
			"NONE", 0 };

  /* Abbreviations to make section names a bit shorter.  */
  char *mm_auth_p[] = { "", "-DSS", "-RSA_SIG", 0 };
  char *mm_enc_p[]  = { "DES", "BLF", "3DES", "CAST", "AES", 0 };
  char *dh_group_p[]= { "-GRP1", "-GRP2", "-GRP5", "-GRP14", "", 0 };
  char *qm_enc_p[]  = { "-DES", "-3DES", "-CAST", "-BLF", "-AES", 0 };
  char *qm_hash_p[] = { "-MD5", "-SHA", "-RIPEMD",
                        "-SHA2-256", "-SHA2-384", "-SHA2-512",
                        "", 0 };
d393 1
a393 1
  /* Helper #defines, incl abbreviations.  */
d398 1
a398 1
  group_max = sizeof dh_group / sizeof *dh_group - 1;
d400 5
a404 5
  /* General and X509 defaults */
  conf_set (tr, "General", "Retransmits", CONF_DFLT_RETRANSMITS, 0, 1);
  conf_set (tr, "General", "Exchange-max-time", CONF_DFLT_EXCH_MAX_TIME, 0, 1);
  conf_set (tr, "General", "Policy-file", CONF_DFLT_POLICY_FILE, 0, 1);
  conf_set (tr, "General", "Pubkey-directory", CONF_DFLT_PUBKEY_DIR, 0, 1);
d407 8
a414 8
  conf_set (tr, "X509-certificates", "CA-directory", CONF_DFLT_X509_CA_DIR, 0,
	    1);
  conf_set (tr, "X509-certificates", "Cert-directory", CONF_DFLT_X509_CERT_DIR,
	    0, 1);
  conf_set (tr, "X509-certificates", "Private-key", CONF_DFLT_X509_PRIVATE_KEY,
	    0, 1);
  conf_set (tr, "X509-certificates", "CRL-directory", CONF_DFLT_X509_CRL_DIR,
	    0, 1);
d418 2
a419 2
  conf_set (tr, "KeyNote", "Credential-directory", CONF_DFLT_KEYNOTE_CRED_DIR,
	    0, 1);
d422 26
a447 27
  /* Lifetimes. XXX p1/p2 vs main/quick mode may be unclear.  */
  dflt = conf_get_trans_str (tr, "General", "Default-phase-1-lifetime");
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_MAIN_MODE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_MAIN_MODE), 0, 1);

  dflt = conf_get_trans_str (tr, "General", "Default-phase-2-lifetime");
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_QUICK_MODE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_QUICK_MODE), 0, 1);

  /* Default Phase-1 Configuration section */
  conf_set (tr, CONF_DFLT_TAG_PHASE1_CONFIG, "EXCHANGE_TYPE",
	    CONF_DFLT_PHASE1_EXCH_TYPE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_PHASE1_CONFIG, "Transforms",
	    CONF_DFLT_PHASE1_TRANSFORMS, 0, 1);

  /* Main modes */
  for (enc = 0; mm_enc[enc]; enc ++)
    for (hash = 0; mm_hash[hash]; hash ++)
      for (auth = 0; mm_auth[auth]; auth ++)
	for (group = 0; dh_group_p[group]; group ++) /* special */
	  {
	    snprintf (sect, sizeof sect, "%s-%s%s%s", mm_enc_p[enc],
		      mm_hash[hash], dh_group_p[group], mm_auth_p[auth]);
d450 2
a451 2
	    if (!conf_find_trans_xf (1, sect))
	      continue;
d454 2
a455 2
	    LOG_DBG ((LOG_MISC, 90, "conf_load_defaults : main mode %s",
		      sect));
d457 40
a496 41
	    conf_set (tr, sect, "ENCRYPTION_ALGORITHM", mm_enc[enc], 0, 1);
	    if (strcmp (mm_enc[enc], "BLOWFISH_CBC") == 0)
	      conf_set (tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN, 0,
			1);

	    conf_set (tr, sect, "HASH_ALGORITHM", mm_hash[hash], 0, 1);
	    conf_set (tr, sect, "AUTHENTICATION_METHOD", mm_auth[auth], 0, 1);

	    /* XXX Always DH group 2 (MODP_1024) */
	    conf_set (tr, sect, "GROUP_DESCRIPTION",
		      dh_group[group < group_max ? group : 1], 0, 1);

	    conf_set (tr, sect, "Life", CONF_DFLT_TAG_LIFE_MAIN_MODE, 0, 1);
	}

  /* Setup a default Phase 1 entry */
  conf_set (tr, "Phase 1", "Default", "Default-phase-1", 0, 1);

  conf_set (tr, "Default-phase-1", "Phase", "1", 0, 1);
  conf_set (tr, "Default-phase-1", "Configuration",
            "Default-phase-1-configuration", 0, 1);
  dflt = conf_get_trans_str (tr, "General", "Default-phase-1-ID");
  if (dflt)
    conf_set (tr, "Default-phase-1", "ID", dflt, 0, 1);

   /* Quick modes */
  for (enc = 0; qm_enc[enc]; enc ++)
    for (proto = 0; proto < 2; proto ++)
      for (mode = 0; mode < 2; mode ++)
	for (pfs = 0; pfs < 2; pfs ++)
	  for (hash = 0; qm_hash[hash]; hash ++)
	    for (group = 0; dh_group_p[group]; group ++)
	      if ((proto == 1 && strcmp (qm_hash[hash], "NONE") == 0)) /* AH */
		continue;
	      else
		{
		  char tmp[CONF_MAX];

		  snprintf (tmp, sizeof tmp, "QM-%s%s%s%s%s%s", PROTO (proto),
			    MODE_p (mode), qm_enc_p[enc], qm_hash_p[hash],
			    PFS (pfs), dh_group_p[group]);
d498 2
a499 2
		  strlcpy (sect, tmp, CONF_MAX);
		  strlcat (sect, "-SUITE", CONF_MAX);
d502 2
a503 2
		  if (!conf_find_trans_xf (2, sect))
		    continue;
d506 2
a507 2
		  LOG_DBG ((LOG_MISC, 90, "conf_load_defaults : quick mode %s",
			    sect));
d509 1
a509 1
		  conf_set (tr, sect, "Protocols", tmp, 0, 1);
d511 2
a512 2
		  snprintf (sect, sizeof sect, "IPSEC_%s", PROTO (proto));
		  conf_set (tr, tmp, "PROTOCOL_ID", sect, 0, 1);
d514 61
a574 31
		  strlcpy (sect, tmp, CONF_MAX);
		  strlcat (sect, "-XF", CONF_MAX);
		  conf_set (tr, tmp, "Transforms", sect, 0, 1);

		  /* XXX For now, defaults contain one xf per protocol.  */

		  conf_set (tr, sect, "TRANSFORM_ID", qm_enc[enc], 0, 1);

		  if (strcmp (qm_enc[enc], "BLOWFISH") == 0)
		    conf_set (tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN,
			      0, 1);

		  conf_set (tr, sect, "ENCAPSULATION_MODE", MODE (mode), 0, 1);

		  if (strcmp (qm_hash[hash], "NONE"))
		    {
		      conf_set (tr, sect, "AUTHENTICATION_ALGORITHM",
				qm_hash[hash], 0, 1);

		      /* XXX Another shortcut -- to keep length down.  */
		      if (pfs)
			conf_set (tr, sect, "GROUP_DESCRIPTION",
				  dh_group[group < group_max ? group : 1], 0,
				  1);
		    }

		  /* XXX Lifetimes depending on enc/auth strength?  */
		  conf_set (tr, sect, "Life", CONF_DFLT_TAG_LIFE_QUICK_MODE, 0,
			    1);
	      }
  return;
d578 1
a578 1
conf_init (void)
d580 1
a580 1
  unsigned int i;
d582 4
a585 4
  for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
    LIST_INIT (&conf_bindings[i]);
  TAILQ_INIT (&conf_trans_queue);
  conf_reinit ();
d590 1
a590 1
conf_reinit (void)
d592 49
a640 10
  struct conf_binding *cb = 0;
  int fd, trans;
  unsigned int i;
  size_t sz;
  char *new_conf_addr = 0;
  struct stat sb;

  if ((monitor_stat (conf_path, &sb) == 0) || (errno != ENOENT))
    {
      if (check_file_secrecy (conf_path, &sz))
d643 4
a646 52
      fd = monitor_open (conf_path, O_RDONLY, 0);
      if (fd == -1)
        {
	  log_error ("conf_reinit: open (\"%s\", O_RDONLY) failed", conf_path);
	  return;
	}

      new_conf_addr = malloc (sz);
      if (!new_conf_addr)
        {
	  log_error ("conf_reinit: malloc (%lu) failed", (unsigned long)sz);
	  goto fail;
	}

      /* XXX I assume short reads won't happen here.  */
      if (read (fd, new_conf_addr, sz) != (int)sz)
        {
	    log_error ("conf_reinit: read (%d, %p, %lu) failed",
		       fd, new_conf_addr, (unsigned long)sz);
	    goto fail;
	}
      close (fd);

      trans = conf_begin ();

      /* XXX Should we not care about errors and rollback?  */
      conf_parse (trans, new_conf_addr, sz);
    }
  else
    trans = conf_begin ();

  /* Load default configuration values.  */
  conf_load_defaults (trans);

  /* Free potential existing configuration.  */
  if (conf_addr)
    {
      for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
	for (cb = LIST_FIRST (&conf_bindings[i]); cb;
	     cb = LIST_FIRST (&conf_bindings[i]))
	  conf_remove_now (cb->section, cb->tag);
      free (conf_addr);
    }

  conf_end (trans, 1);
  conf_addr = new_conf_addr;
  return;

 fail:
  if (new_conf_addr)
    free (new_conf_addr);
  close (fd);
d654 1
a654 1
conf_get_num (char *section, char *tag, int def)
d656 1
a656 1
  char *value = conf_get_str (section, tag);
d658 3
a660 3
  if (value)
      return atoi (value);
  return def;
d669 1
a669 1
conf_get_address (char *section, char *tag)
d671 2
a672 2
  char *value = conf_get_str (section, tag);
  struct sockaddr *sa;
d674 5
a678 5
  if (!value)
    return 0;
  if (text2sockaddr (value, 0, &sa) == -1)
    return 0;
  return sa;
d683 1
a683 1
conf_match_num (char *section, char *tag, int x)
d685 2
a686 2
  char *value = conf_get_str (section, tag);
  int val, min, max, n;
d688 17
a704 18
  if (!value)
    return 0;
  n = sscanf (value, "%d,%d:%d", &val, &min, &max);
  switch (n)
    {
    case 1:
      LOG_DBG ((LOG_MISC, 90, "conf_match_num: %s:%s %d==%d?", section, tag,
		val, x));
      return x == val;
    case 3:
      LOG_DBG ((LOG_MISC, 90, "conf_match_num: %s:%s %d<=%d<=%d?", section,
		tag, min, x, max));
      return min <= x && max >= x;
    default:
      log_error ("conf_match_num: section %s tag %s: invalid number spec %s",
		 section, tag, value);
    }
  return 0;
d708 2
a709 2
char *
conf_get_str (char *section, char *tag)
d711 1
a711 1
  struct conf_binding *cb;
d713 12
a724 13
  for (cb = LIST_FIRST (&conf_bindings[conf_hash (section)]); cb;
       cb = LIST_NEXT (cb, link))
    if (strcasecmp (section, cb->section) == 0
	&& strcasecmp (tag, cb->tag) == 0)
      {
	LOG_DBG ((LOG_MISC, 95, "conf_get_str: [%s]:%s->%s", section,
		  tag, cb->value));
	return cb->value;
      }
  LOG_DBG ((LOG_MISC, 95,
	    "conf_get_str: configuration value not found [%s]:%s", section,
	    tag));
  return 0;
d732 1
a732 1
conf_get_list (char *section, char *tag)
d734 36
a769 29
  char *liststr = 0, *p, *field, *t;
  struct conf_list *list = 0;
  struct conf_list_node *node;

  list = malloc (sizeof *list);
  if (!list)
    goto cleanup;
  TAILQ_INIT (&list->fields);
  list->cnt = 0;
  liststr = conf_get_str (section, tag);
  if (!liststr)
    goto cleanup;
  liststr = strdup (liststr);
  if (!liststr)
    goto cleanup;
  p = liststr;
  while ((field = strsep (&p, ",")) != NULL)
    {
      /* Skip leading whitespace */
      while (isspace (*field))
	field++;
      /* Skip trailing whitespace */
      if (p)
	for (t = p - 1; t > field && isspace (*t); t--)
	  *t = '\0';
      if (*field == '\0')
	{
	  log_print ("conf_get_list: empty field, ignoring...");
	  continue;
d771 9
a779 18
      list->cnt++;
      node = calloc (1, sizeof *node);
      if (!node)
	goto cleanup;
      node->field = strdup (field);
      if (!node->field)
	goto cleanup;
      TAILQ_INSERT_TAIL (&list->fields, node, link);
    }
  free (liststr);
  return list;

 cleanup:
  if (list)
    conf_free_list (list);
  if (liststr)
    free (liststr);
  return 0;
d783 1
a783 1
conf_get_tag_list (char *section)
d785 27
a811 28
  struct conf_list *list = 0;
  struct conf_list_node *node;
  struct conf_binding *cb;

  list = malloc (sizeof *list);
  if (!list)
    goto cleanup;
  TAILQ_INIT (&list->fields);
  list->cnt = 0;
  for (cb = LIST_FIRST (&conf_bindings[conf_hash (section)]); cb;
       cb = LIST_NEXT (cb, link))
    if (strcasecmp (section, cb->section) == 0)
      {
	list->cnt++;
	node = calloc (1, sizeof *node);
	if (!node)
	  goto cleanup;
	node->field = strdup (cb->tag);
	if (!node->field)
	  goto cleanup;
	TAILQ_INSERT_TAIL (&list->fields, node, link);
      }
  return list;

 cleanup:
  if (list)
    conf_free_list (list);
  return 0;
d816 1
a816 1
conf_decode_base64 (u_int8_t *out, u_int32_t *len, u_char *buf)
d818 2
a819 2
  u_int32_t c = 0;
  u_int8_t c1, c2, c3, c4;
d821 45
a865 45
  while (*buf)
    {
      if (*buf > 127 || (c1 = asc2bin[*buf]) == 255)
	return 0;
      buf++;

      if (*buf > 127 || (c2 = asc2bin[*buf]) == 255)
	return 0;
      buf++;

      if (*buf == '=')
	{
	  c3 = c4 = 0;
	  c++;

	  /* Check last four bit */
	  if (c2 & 0xF)
	    return 0;

	  if (strcmp ((char *)buf, "==") == 0)
	    buf++;
	  else
	    return 0;
	}
      else if (*buf > 127 || (c3 = asc2bin[*buf]) == 255)
	return 0;
      else
	{
	  if (*++buf == '=')
	    {
	      c4 = 0;
	      c += 2;

	      /* Check last two bit */
	      if (c3 & 3)
		return 0;

	      if (strcmp ((char *)buf, "="))
		return 0;

	    }
	  else if (*buf > 127 || (c4 = asc2bin[*buf]) == 255)
	      return 0;
	  else
	      c += 3;
d868 2
a869 8
      buf++;
      *out++ = (c1 << 2) | (c2 >> 4);
      *out++ = (c2 << 4) | (c3 >> 2);
      *out++ = (c3 << 6) | c4;
    }

  *len = c;
  return 1;
d874 1
a874 1
conf_free_list (struct conf_list *list)
d876 1
a876 1
  struct conf_list_node *node = TAILQ_FIRST (&list->fields);
d878 8
a885 9
  while (node)
    {
      TAILQ_REMOVE (&list->fields, node, link);
      if (node->field)
	free (node->field);
      free (node);
      node = TAILQ_FIRST (&list->fields);
    }
  free (list);
d889 1
a889 1
conf_begin (void)
d891 1
a891 1
  static int seq = 0;
d893 1
a893 1
  return ++seq;
d897 1
a897 1
conf_trans_node (int transaction, enum conf_op op)
d899 1
a899 1
  struct conf_trans *node;
d901 10
a910 11
  node = calloc (1, sizeof *node);
  if (!node)
    {
      log_error ("conf_trans_node: calloc (1, %lu) failed",
	(unsigned long)sizeof *node);
      return 0;
    }
  node->trans = transaction;
  node->op = op;
  TAILQ_INSERT_TAIL (&conf_trans_queue, node, link);
  return node;
d915 2
a916 2
conf_set (int transaction, char *section, char *tag, char *value, int override,
	  int is_default)
d918 1
a918 1
  struct conf_trans *node;
d920 30
a949 33
  node = conf_trans_node (transaction, CONF_SET);
  if (!node)
    return 1;
  node->section = strdup (section);
  if (!node->section)
    {
      log_error ("conf_set: strdup (\"%s\") failed", section);
      goto fail;
    }
  node->tag = strdup (tag);
  if (!node->tag)
    {
      log_error ("conf_set: strdup (\"%s\") failed", tag);
      goto fail;
    }
  node->value = strdup (value);
  if (!node->value)
    {
      log_error ("conf_set: strdup (\"%s\") failed", value);
      goto fail;
    }
  node->override = override;
  node->is_default = is_default;
  return 0;

 fail:
  if (node->tag)
    free (node->tag);
  if (node->section)
    free (node->section);
  if (node)
    free (node);
  return 1;
d954 1
a954 1
conf_remove (int transaction, char *section, char *tag)
d956 1
a956 1
  struct conf_trans *node;
d958 21
a978 23
  node = conf_trans_node (transaction, CONF_REMOVE);
  if (!node)
    goto fail;
  node->section = strdup (section);
  if (!node->section)
    {
      log_error ("conf_remove: strdup (\"%s\") failed", section);
      goto fail;
    }
  node->tag = strdup (tag);
  if (!node->tag)
    {
      log_error ("conf_remove: strdup (\"%s\") failed", tag);
      goto fail;
    }
  return 0;

 fail:
  if (node->section)
    free (node->section);
  if (node)
    free (node);
  return 1;
d983 1
a983 1
conf_remove_section (int transaction, char *section)
d985 11
a995 1
  struct conf_trans *node;
d997 4
a1000 15
  node = conf_trans_node (transaction, CONF_REMOVE_SECTION);
  if (!node)
    goto fail;
  node->section = strdup (section);
  if (!node->section)
    {
      log_error ("conf_remove_section: strdup (\"%s\") failed", section);
      goto fail;
    }
  return 0;

 fail:
  if (node)
    free (node);
  return 1;
d1005 1
a1005 1
conf_end (int transaction, int commit)
d1007 1
a1007 1
  struct conf_trans *node, *next;
d1009 27
a1035 29
  for (node = TAILQ_FIRST (&conf_trans_queue); node; node = next)
    {
      next = TAILQ_NEXT (node, link);
      if (node->trans == transaction)
	{
	  if (commit)
	    switch (node->op)
	      {
	      case CONF_SET:
		conf_set_now (node->section, node->tag, node->value,
			      node->override, node->is_default);
		break;
	      case CONF_REMOVE:
		conf_remove_now (node->section, node->tag);
		break;
	      case CONF_REMOVE_SECTION:
		conf_remove_section_now (node->section);
		break;
	      default:
		log_print ("conf_end: unknown operation: %d", node->op);
	      }
	  TAILQ_REMOVE (&conf_trans_queue, node, link);
	  if (node->section)
	    free (node->section);
	  if (node->tag)
	    free (node->tag);
	  if (node->value)
	    free (node->value);
	  free (node);
d1037 1
a1037 2
    }
  return 0;
d1045 2
a1046 2
  char *s, *v;
  struct dumper *next;
d1050 1
a1050 1
conf_report_dump (struct dumper *node)
d1052 1
a1052 1
  /* Recursive, cleanup when we're done.  */
d1054 2
a1055 2
  if (node->next)
    conf_report_dump (node->next);
d1057 8
a1064 10
  if (node->v)
    LOG_DBG ((LOG_REPORT, 0, "%s=\t%s", node->s, node->v));
  else if (node->s)
    {
      LOG_DBG ((LOG_REPORT, 0, "%s", node->s));
      if (strlen (node->s) > 0)
	free (node->s);
    }

  free (node);
d1068 1
a1068 1
conf_report (void)
d1070 69
a1138 76
  struct conf_binding *cb, *last = 0;
  unsigned int i, len;
  char *current_section = (char *)0;
  struct dumper *dumper, *dnode;

  dumper = dnode = (struct dumper *)calloc (1, sizeof *dumper);
  if (!dumper)
    goto mem_fail;

  LOG_DBG ((LOG_REPORT, 0, "conf_report: dumping running configuration"));

  for (i = 0; i < sizeof conf_bindings / sizeof conf_bindings[0]; i++)
    for (cb = LIST_FIRST (&conf_bindings[i]); cb;
	 cb = LIST_NEXT (cb, link))
      {
	if (!cb->is_default)
	  {
	    /* Dump this entry.  */
	    if (!current_section || strcmp (cb->section, current_section))
	      {
		if (current_section)
		  {
		    len = strlen (current_section) + 3;
		    dnode->s = malloc (len);
		    if (!dnode->s)
		      goto mem_fail;

		    snprintf (dnode->s, len, "[%s]", current_section);
		    dnode->next
		      = (struct dumper *)calloc (1, sizeof (struct dumper));
		    dnode = dnode->next;
		    if (!dnode)
		      goto mem_fail;

		    dnode->s = "";
		    dnode->next
		      = (struct dumper *)calloc (1, sizeof (struct dumper));
		    dnode = dnode->next;
		    if (!dnode)
		      goto mem_fail;
		  }
		current_section = cb->section;
	      }
	    dnode->s = cb->tag;
	    dnode->v = cb->value;
	    dnode->next = (struct dumper *)calloc (1, sizeof (struct dumper));
	    dnode = dnode->next;
	    if (!dnode)
	      goto mem_fail;
	    last = cb;
	  }
      }

  if (last)
    {
      len = strlen (last->section) + 3;
      dnode->s = malloc (len);
      if (!dnode->s)
	goto mem_fail;
      snprintf (dnode->s, len, "[%s]", last->section);
    }

  conf_report_dump (dumper);

  return;

 mem_fail:
  log_error ("conf_report: malloc/calloc failed");
  while ((dnode = dumper) != 0)
    {
      dumper = dumper->next;
      if (dnode->s)
	free (dnode->s);
      free (dnode);
    }
  return;
@


1.61
log
@Add group 14 (modp2048) to predefined suites.  Manpage also updated.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.60 2004/01/06 00:22:48 hshoexer Exp $	*/
d588 1
a588 1
  if ((stat (conf_path, &sb) == 0) || (errno != ENOENT))
@


1.60
log
@small typos fixed.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.59 2003/09/02 18:15:55 ho Exp $	*/
d325 1
a325 1
 *     {DES,BLF,3DES,CAST,AES}-{MD5,SHA}[-GRP{1,2,5}][-{DSS,RSA_SIG}]
d332 1
a332 1
 *       {group}  = GRP1, GRP2, GRP5
d395 1
a395 1
  char *dh_group[]  = { "MODP_768", "MODP_1024", "MODP_1536", 0 };
d404 1
a404 1
  char *dh_group_p[]= { "-GRP1", "-GRP2", "-GRP5", "", 0 };
@


1.59
log
@A couple of nits. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.58 2003/08/28 14:43:35 markus Exp $	*/
d193 2
a194 2
	log_print ("conf_set: duplicate tag [%s]:%s, ignoring...\n", section,
		   tag);
d201 2
a202 1
      log_error ("conf_set: calloc (1, %lu) failed", (unsigned long)sizeof *node);
d211 1
a211 1
  LOG_DBG ((LOG_MISC, 95, "conf_set: [%s]:%s->%s", node->section, node->tag,
@


1.58
log
@support AES in phase 1, too. switch to OpenSSL EVP interface;
with Hans-Joerg.Hoexer at yerbouti.franken.de; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.57 2003/07/25 08:31:16 markus Exp $	*/
d324 1
a324 1
 *     {DES,BLF,3DES,CAST}-{MD5,SHA}[-GRP{1,2,5}][-{DSS,RSA_SIG}]
@


1.57
log
@add sha2 support; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.56 2003/06/10 16:41:29 deraadt Exp $	*/
d393 1
a393 1
			"CAST_CBC", 0 };
d402 1
a402 1
  char *mm_enc_p[]  = { "DES", "BLF", "3DES", "CAST", 0 };
@


1.56
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.55 2003/06/03 14:28:16 ho Exp $	*/
d330 1
a330 1
 *       {hash}   = MD5, SHA, RIPEMD
d396 3
a398 1
  char *qm_hash[]   = { "HMAC_MD5", "HMAC_SHA", "HMAC_RIPEMD", "NONE", 0 };
d405 3
a407 1
  char *qm_hash_p[] = { "-MD5", "-SHA", "-RIPEMD", "", 0 };
@


1.55
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.54 2003/06/03 12:51:38 ho Exp $	*/
d450 1
a450 1
  conf_set (tr, CONF_DFLT_TAG_PHASE1_CONFIG, "Transforms", 
@


1.54
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.53 2003/05/18 19:37:46 ho Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.53
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.52 2003/05/15 00:28:53 ho Exp $	*/
d464 1
a464 1
	    snprintf (sect, CONF_MAX, "%s-%s%s%s", mm_enc_p[enc],
d513 1
a513 1
		  snprintf (tmp, CONF_MAX, "QM-%s%s%s%s%s%s", PROTO (proto),
d530 1
a530 1
		  snprintf (sect, CONF_MAX, "IPSEC_%s", PROTO (proto));
@


1.52
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.51 2003/05/14 18:11:18 ho Exp $	*/
d614 1
a614 1
      monitor_close (fd);
@


1.51
log
@Default public key directory definition sanity.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.50 2003/04/30 15:15:11 jason Exp $	*/
d58 1
d593 1
a593 1
      fd = open (conf_path, O_RDONLY);
d614 1
a614 1
      close (fd);
@


1.50
log
@cast size_t to unsigned long and use %lu;ok ho
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.49 2003/02/04 20:02:34 markus Exp $	*/
d420 1
@


1.49
log
@don't set the Transform for Default-phase-1-configuration twice, ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.48 2002/12/06 07:46:50 ho Exp $	*/
d256 2
a257 1
	  log_print ("conf_parse_line: %d: malloc (%d) failed", ln, i);
@


1.48
log
@Section and tag comparisions should be case-insensitive. PR#3010, Mike Neuman.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.47 2002/11/15 14:58:38 ho Exp $	*/
a495 5

  conf_set (tr, "Default-phase-1-configuration",
            "EXCHANGE_TYPE", "ID_PROT", 0, 1);
  conf_set (tr, "Default-phase-1-configuration", "Transforms",
            "3DES-SHA-RSA_SIG", 0, 1);
@


1.47
log
@Missing "Configuration" tag in a Phase-1 peer was not handled correctly,
pointed out by Aref Taidi. Replace this with a "Default-Phase-1-Configuration"
that will be used if this tag is missing from the peer. Update manpage
accordingly. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.46 2002/11/14 16:13:27 ho Exp $	*/
d350 2
a351 2
    if (node->trans == trans && strcmp (section, node->section) == 0
	&& strcmp (tag, node->tag) == 0)
@


1.46
log
@Better whitespace/newline handling, this should make broken lines and
multiple values parse correctly again, as well as fix PR#2974.
Also fix some int/u_int mismatches, and remove conf_get_line() (obsolete).
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.45 2002/09/11 09:50:43 ho Exp $	*/
d448 6
@


1.45
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.44 2002/08/07 13:19:20 ho Exp $	*/
d227 2
a228 1
  int i;
d277 2
a278 3
	i = strcspn (val, " \t\r");
	if (i)
	  val[i] = '\0';
d565 1
a565 1
  int i;
d578 2
a579 1
  int fd, i, trans;
d604 1
a604 1
      if (read (fd, new_conf_addr, sz) != sz)
d730 1
a730 1
  char *liststr = 0, *p, *field;
d746 1
a746 1
  while ((field = strsep (&p, ", \t")) != NULL)
d748 7
a877 24
/* Read a line from a stream to the buffer.  */
int
conf_get_line (FILE *stream, char *buf, u_int32_t len)
{
  int c;

  while (len-- > 1)
    {
      c = fgetc (stream);
      if (c == '\n')
	{
	  *buf = 0;
	  return 1;
	}
      else if (c == EOF)
	break;

      *buf++ = c;
    }

  *buf = 0;
  return 0;
}

d1089 1
a1089 1
  int i, len;
@


1.44
log
@A rewrite of the CRL support code, also from <Thomas.Walpuski@@gmx.net>.
Some style mods, and checks added for OpenSSL version 0.9.7 or later.
Currently CRLs are not supported for earlier versions.
Manual pages updated.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.43 2002/08/02 13:10:41 ho Exp $	*/
d831 1
a831 1
	  if (strcmp (buf, "==") == 0)
d849 1
a849 1
	      if (strcmp (buf, "="))
@


1.43
log
@CRL support for isakmpd. From <Thomas.Walpuski@@gmx.net> with some minor
modifications by me. ok niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.42 2002/06/09 08:13:06 todd Exp $	*/
d427 2
a428 1
  conf_set (tr, "X509-certificates", "CRL-file", CONF_DFLT_X509_CRL_FILE, 0, 1);
@


1.42
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.41 2002/06/01 07:44:21 deraadt Exp $	*/
d427 1
@


1.41
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.40 2002/05/28 11:23:20 ho Exp $	*/
d473 1
a473 1
	    conf_set (tr, sect, "GROUP_DESCRIPTION", 
d508 1
a508 1
			    MODE_p (mode), qm_enc_p[enc], qm_hash_p[hash], 
d548 1
a548 1
			conf_set (tr, sect, "GROUP_DESCRIPTION", 
@


1.40
log
@off_t to size_t change for printf format and malloc. Pointed out by <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.39 2002/04/29 06:26:50 pvalchev Exp $	*/
d205 1
a205 1
      log_error ("conf_set: calloc (1, %d) failed", sizeof *node);
d596 1
a596 1
	  log_error ("conf_reinit: malloc (%d) failed", sz);
d603 2
a604 2
	    log_error ("conf_reinit: read (%d, %p, %d) failed",
		       fd, new_conf_addr, sz);
d924 2
a925 1
      log_error ("conf_trans_node: calloc (1, %d) failed", sizeof *node);
@


1.39
log
@wierd -> weird
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.38 2002/04/22 12:52:39 ho Exp $	*/
d577 1
a577 1
  off_t sz;
@


1.38
log
@Handle configuration lines that end in whitespace or ^M.
Also avoid a potential memory leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.37 2002/03/01 14:54:20 ho Exp $	*/
d284 1
a284 1
  /* Other non-empty lines are wierd.  */
@


1.37
log
@Change DH group handling in the pre-generated parts of the
configuration. Add a -GRP{1,2,5} component to transform and suite
names to directly specify which group to use. If no group is
specified, use DH group 2 (MODP_1024). Earlier transforms and suites
using the MD5 hash defaulted to DH group 1, this is no longer true.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.36 2002/01/23 18:44:47 ho Exp $	*/
d6 1
a6 1
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
d226 1
a226 1
  char *cp = line;
d243 2
a251 2
      if (section)
	free (section);
d253 5
d264 1
a264 1
    if (cp[i] == '=')
d274 5
d280 1
a280 2
	conf_set (trans, section, line,
		  line + i + 1 + strspn (line + i + 1, " \t"), 0, 0);
@


1.36
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.35 2002/01/03 16:27:41 ho Exp $	*/
d318 1
a318 1
 *     {DES,BLF,3DES,CAST}-{MD5,SHA}[-{DSS,RSA_SIG}]
d320 8
a327 2
 *     QM-{ESP,AH}[-TRP]-{DES,3DES,CAST,BLF,AES}[-{MD5,SHA,RIPEMD}][-PFS]-SUITE
 * DH groups; currently always MODP_768 for MD5, and MODP_1024 for SHA.
d381 1
a381 1
  int enc, auth, hash, proto, mode, pfs;
d395 1
d404 1
d442 4
a445 3
	{
	  snprintf (sect, CONF_MAX, "%s-%s%s", mm_enc_p[enc], mm_hash[hash],
		    mm_auth_p[auth]);
d448 2
a449 2
	  if (!conf_find_trans_xf (1, sect))
	    continue;
d452 2
a453 1
	  LOG_DBG ((LOG_MISC, 90, "conf_load_defaults : main mode %s", sect));
d455 11
a465 3
	  conf_set (tr, sect, "ENCRYPTION_ALGORITHM", mm_enc[enc], 0, 1);
	  if (strcmp (mm_enc[enc], "BLOWFISH_CBC") == 0)
	    conf_set (tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN, 0, 1);
d467 1
a467 7
	  conf_set (tr, sect, "HASH_ALGORITHM", mm_hash[hash], 0, 1);
	  conf_set (tr, sect, "AUTHENTICATION_METHOD", mm_auth[auth], 0, 1);

	  /* XXX Assumes md5 -> modp768 and sha -> modp1024 */
	  conf_set (tr, sect, "GROUP_DESCRIPTION", dh_group[hash], 0, 1);

	  conf_set (tr, sect, "Life", CONF_DFLT_TAG_LIFE_MAIN_MODE, 0, 1);
d491 10
a500 9
	    if ((proto == 1 && strcmp (qm_hash[hash], "NONE") == 0)) /* AH */
	      continue;
	    else
	      {
		char tmp[CONF_MAX];

		snprintf (tmp, CONF_MAX, "QM-%s%s%s%s%s", PROTO (proto),
			  MODE_p (mode), qm_enc_p[enc], qm_hash_p[hash], 
			  PFS (pfs));
d502 2
a503 2
		strlcpy (sect, tmp, CONF_MAX);
		strlcat (sect, "-SUITE", CONF_MAX);
d506 2
a507 2
		if (!conf_find_trans_xf (2, sect))
		  continue;
d510 2
a511 2
		LOG_DBG ((LOG_MISC, 90, "conf_load_defaults : quick mode %s",
			  sect));
d513 1
a513 1
		conf_set (tr, sect, "Protocols", tmp, 0, 1);
d515 2
a516 2
		snprintf (sect, CONF_MAX, "IPSEC_%s", PROTO (proto));
		conf_set (tr, tmp, "PROTOCOL_ID", sect, 0, 1);
d518 3
a520 3
		strlcpy (sect, tmp, CONF_MAX);
		strlcat (sect, "-XF", CONF_MAX);
		conf_set (tr, tmp, "Transforms", sect, 0, 1);
d522 1
a522 1
                /* XXX For now, defaults contain just one xf per protocol.  */
d524 1
a524 1
		conf_set (tr, sect, "TRANSFORM_ID", qm_enc[enc], 0, 1);
d526 3
a528 3
                if (strcmp (qm_enc[enc], "BLOWFISH") == 0)
		  conf_set (tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN,
			    0, 1);
d530 1
a530 1
		conf_set (tr, sect, "ENCAPSULATION_MODE", MODE (mode), 0, 1);
d532 4
a535 4
                if (strcmp (qm_hash[hash], "NONE"))
                {
		  conf_set (tr, sect, "AUTHENTICATION_ALGORITHM",
			    qm_hash[hash], 0, 1);
d537 6
a542 5
                  /* XXX Another shortcut -- to keep length down.  */
                  if (pfs)
		    conf_set (tr, sect, "GROUP_DESCRIPTION",
			      dh_group[ ((hash<2) ? hash : 1) ], 0, 1);
                }
d544 3
a546 3
                /* XXX Lifetimes depending on enc/auth strength?  */
		conf_set (tr, sect, "Life", CONF_DFLT_TAG_LIFE_QUICK_MODE, 0,
			  1);
@


1.35
log
@str[n]{cpy,cat} -> strl{cpy,cat}, sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.34 2001/10/05 05:59:06 ho Exp $	*/
d1079 1
a1079 1
  int i;
d1100 2
a1101 1
		    dnode->s = malloc (strlen (current_section) + 3);
d1105 1
a1105 1
		    sprintf (dnode->s, "[%s]", current_section);
d1133 2
a1134 1
      dnode->s = malloc (strlen (last->section) + 3);
d1137 1
a1137 1
      sprintf (dnode->s, "[%s]", last->section);
@


1.34
log
@Missed this file; some more debug level fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.33 2001/07/05 12:36:47 ho Exp $	*/
d253 1
a253 2
      strncpy (section, line + 1, i - 1);
      section[i - 1] = '\0';
d374 1
d376 1
a376 1
  char sect[256], *dflt;
d435 2
a436 2
	  sprintf (sect, "%s-%s%s", mm_enc_p[enc], mm_hash[hash],
		   mm_auth_p[auth]);
d483 1
a483 1
		char tmp[256];
d485 3
a487 2
		sprintf (tmp, "QM-%s%s%s%s%s", PROTO (proto), MODE_p (mode),
			 qm_enc_p[enc], qm_hash_p[hash], PFS (pfs));
d489 2
a490 2
		strcpy (sect, tmp);
		strcat (sect, "-SUITE");
d502 1
a502 1
		sprintf (sect, "IPSEC_%s", PROTO (proto));
d505 2
a506 2
		strcpy (sect, tmp);
		strcat (sect, "-XF");
@


1.33
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.32 2001/07/01 19:48:43 niklas Exp $	*/
d146 1
a146 1
	  LOG_DBG ((LOG_MISC, 70, "[%s]:%s->%s removed", section, tag,
d171 1
a171 1
	  LOG_DBG ((LOG_MISC, 70, "[%s]:%s->%s removed", section, cb->tag,
d214 1
a214 1
  LOG_DBG ((LOG_MISC, 70, "conf_set: [%s]:%s->%s", node->section, node->tag,
d443 1
a443 1
	  LOG_DBG ((LOG_MISC, 40, "conf_load_defaults : main mode %s", sect));
d496 1
a496 1
		LOG_DBG ((LOG_MISC, 40, "conf_load_defaults : quick mode %s",
d686 1
a686 1
	LOG_DBG ((LOG_MISC, 60, "conf_get_str: [%s]:%s->%s", section,
d690 1
a690 1
  LOG_DBG ((LOG_MISC, 60,
d1047 1
a1047 1
 * XXX Configuration is "stored in reverse order", so reverse it.
@


1.32
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.31 2001/06/29 19:42:16 niklas Exp $	*/
d60 6
d329 1
a329 1
char *
d347 3
a349 1
int
d370 1
d372 1
a372 1
void
@


1.31
log
@Provide an API to get sockaddrs out of the config db
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.30 2001/03/27 15:46:29 ho Exp $	*/
d322 1
a322 1
/* Find the value for a section+tag in the transaction list */
d327 1
a327 1
  
d330 2
a331 2
    if (node->trans == trans && strcmp (section, node->section) == 0 && 
	strcmp (tag, node->tag) == 0)
d338 1
a338 1
  return nf ? nf->value : NULL;
d369 2
a370 2
  char *mm_auth[]   = { "PRE_SHARED", "DSS", "RSA_SIG", NULL };
  char *mm_hash[]   = { "MD5", "SHA", NULL };
d372 4
a375 4
			"CAST_CBC", NULL };
  char *dh_group[]  = { "MODP_768", "MODP_1024", "MODP_1536", NULL };
  char *qm_enc[]    = { "DES", "3DES", "CAST", "BLOWFISH", "AES", NULL };
  char *qm_hash[]   = { "HMAC_MD5", "HMAC_SHA", "HMAC_RIPEMD", "NONE", NULL };
d378 4
a381 4
  char *mm_auth_p[] = { "", "-DSS", "-RSA_SIG", NULL };
  char *mm_enc_p[]  = { "DES", "BLF", "3DES", "CAST", NULL };
  char *qm_enc_p[]  = { "-DES", "-3DES", "-CAST", "-BLF", "-AES", NULL };
  char *qm_hash_p[] = { "-MD5", "-SHA", "-RIPEMD", "", NULL };
d1068 1
a1068 1
  struct conf_binding *cb, *last = NULL;
d1085 1
a1085 1
	    /* Dump this entry */
d1133 2
a1134 2
  LOG_DBG ((LOG_REPORT, 0, "conf_report: memory allocation failure."));
  while ((dnode = dumper) != NULL)
@


1.30
log
@(c)-2001
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.29 2001/03/13 17:56:31 ho Exp $	*/
d41 1
d43 2
d619 18
@


1.29
log
@Somewhere along the line we stopped using the configuration file defaults
properly. Make them work again. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.28 2001/02/28 08:49:43 angelos Exp $	*/
d6 1
a6 1
 * Copyright (c) 2000 Håkan Olsson.  All rights reserved.
@


1.28
log
@Make sure the default lifetimes in the General section are taken into
consideration.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.27 2001/01/27 12:03:31 niklas Exp $	*/
d205 1
a205 1
  LOG_DBG ((LOG_MISC, 70, "[%s]:%s->%s", node->section, node->tag,
d319 19
d347 2
a348 2
    if (( phase == 1 && !strcmp ("Transforms", node->tag)) ||
	( phase == 2 && !strcmp ("Suites", node->tag)))
d405 2
a406 2
 /* Lifetimes. XXX p1/p2 vs main/quick mode may be unclear.  */
  dflt = conf_get_str ("General", "Default-phase-1-lifetime");
d412 1
a412 1
  dflt = conf_get_str ("General", "Default-phase-2-lifetime");
d434 1
a434 1
	  if (!strcmp (mm_enc[enc], "BLOWFISH_CBC"))
d452 1
a452 1
  dflt = conf_get_str ("General", "Default-phase-1-ID");
d467 1
a467 2
	    if ((proto == 1 && /* AH */
		 !strcmp (qm_hash[hash], "NONE")))
d500 1
a500 1
                if (!strcmp (qm_enc[enc], "BLOWFISH"))
d775 1
a775 1
	  if (!strcmp (buf, "=="))
@


1.27
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.26 2001/01/26 12:12:51 niklas Exp $	*/
d386 13
d442 1
a442 1
  /* Quick modes */
a502 14

  /* Lifetimes. XXX p1/p2 vs main/quick mode may be unclear.  */
  dflt = conf_get_str ("General", "Default-phase-1-lifetime");
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_MAIN_MODE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_MAIN_MODE), 0, 1);

  dflt = conf_get_str ("General", "Default-phase-2-lifetime");
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_QUICK_MODE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_QUICK_MODE), 0, 1);

@


1.26
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.25 2000/12/12 01:45:55 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
@


1.25
log
@Merge with EOM 1.48

author: angelos
Add Default-phase-1-ID tag in [General], and document its use.

author: angelos
Default Phase 1 entry.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.c,v 1.24 2000/10/27 19:22:36 niklas Exp $	*/
d325 1
a325 1
  /* Find the relevant transforms and suites, if any. */
d998 4
a1001 2
/* Dump running configuration upon SIGUSR1. */
/* XXX Configuration is "stored in reverse order", so reverse it. */
d1010 1
a1010 1
  /* Recursive, cleanup when we're done. */
@


1.24
log
@conf.c: Merge with EOM 1.46
util.c: Merge EOM diff 1.20 - 1.21, i.e. 1.19 is still left to be merged

author: ho
Use stat(), not lstat().
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.23 2000/10/26 22:28:16 niklas Exp $	*/
/*	$EOM: conf.c,v 1.46 2000/10/26 16:17:19 ho Exp $	*/
d413 15
@


1.24.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.30 2001/03/27 15:46:29 ho Exp $	*/
/*	$EOM: conf.c,v 1.48 2000/12/04 02:04:29 angelos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
d205 1
a205 1
  LOG_DBG ((LOG_MISC, 70, "conf_set: [%s]:%s->%s", node->section, node->tag,
a318 19
/* Find the value for a section+tag in the transaction list */
char *
conf_get_trans_str (int trans, char *section, char *tag)
{
  struct conf_trans *node, *nf = 0;
  
  for (node = TAILQ_FIRST (&conf_trans_queue); node;
       node = TAILQ_NEXT (node, link))
    if (node->trans == trans && strcmp (section, node->section) == 0 && 
	strcmp (tag, node->tag) == 0)
      {
	if (!nf)
	  nf = node;
	else if (node->override)
	  nf = node;
      }
  return nf ? nf->value : NULL;
}

d325 1
a325 1
  /* Find the relevant transforms and suites, if any.  */
d328 2
a329 2
    if ((phase == 1 && strcmp ("Transforms", node->tag) == 0) ||
	(phase == 2 && strcmp ("Suites", node->tag) == 0))
a385 13
  /* Lifetimes. XXX p1/p2 vs main/quick mode may be unclear.  */
  dflt = conf_get_trans_str (tr, "General", "Default-phase-1-lifetime");
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_MAIN_MODE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_MAIN_MODE), 0, 1);

  dflt = conf_get_trans_str (tr, "General", "Default-phase-2-lifetime");
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_TYPE",
	    CONF_DFLT_TYPE_LIFE_QUICK_MODE, 0, 1);
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_DURATION",
	    (dflt ? dflt : CONF_DFLT_VAL_LIFE_QUICK_MODE), 0, 1);

d402 1
a402 1
	  if (strcmp (mm_enc[enc], "BLOWFISH_CBC") == 0)
d414 1
a414 16
  /* Setup a default Phase 1 entry */
  conf_set (tr, "Phase 1", "Default", "Default-phase-1", 0, 1);

  conf_set (tr, "Default-phase-1", "Phase", "1", 0, 1);
  conf_set (tr, "Default-phase-1", "Configuration",
            "Default-phase-1-configuration", 0, 1);
  dflt = conf_get_trans_str (tr, "General", "Default-phase-1-ID");
  if (dflt)
    conf_set (tr, "Default-phase-1", "ID", dflt, 0, 1);

  conf_set (tr, "Default-phase-1-configuration",
            "EXCHANGE_TYPE", "ID_PROT", 0, 1);
  conf_set (tr, "Default-phase-1-configuration", "Transforms",
            "3DES-SHA-RSA_SIG", 0, 1);

   /* Quick modes */
d420 2
a421 1
	    if ((proto == 1 && strcmp (qm_hash[hash], "NONE") == 0)) /* AH */
d454 1
a454 1
                if (strcmp (qm_enc[enc], "BLOWFISH") == 0)
d475 14
d743 1
a743 1
	  if (strcmp (buf, "==") == 0)
d983 2
a984 4
/*
 * Dump running configuration upon SIGUSR1.
 * XXX Configuration is "stored in reverse order", so reverse it.
 */
d993 1
a993 1
  /* Recursive, cleanup when we're done.  */
@


1.23
log
@Merge with EOM 1.45

author: niklas
fgetc returns int not char; Boris Prochazka <boris@@stargate.ipunplugged.com>
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.22 2000/10/16 23:28:56 niklas Exp $	*/
/*	$EOM: conf.c,v 1.45 2000/10/24 13:29:15 niklas Exp $	*/
d513 1
a513 1
  if ((lstat (conf_path, &sb) == 0) || (errno != ENOENT))
@


1.22
log
@Merge with EOM 1.44

author: angelos
Just to be on the safe side, use a struct stat.

author: angelos
Only do the secrecy check and parse the configuration file if it
actually exists.

author: angelos
Actually create all the pre-configured Transforms and Suites, even if
the user doesn't actually define them in the configuration file; ugly
kludge, but it allows use of isakmpd without a configuration file.

author: angelos
Add RIPEMD negotiation/configuration.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.21 2000/10/13 13:22:01 niklas Exp $	*/
/*	$EOM: conf.c,v 1.44 2000/10/14 08:45:18 angelos Exp $	*/
d786 1
a786 1
  char c;
@


1.21
log
@regress/b2n/Makefile: Merge with EOM 1.12
regress/ec2n/Makefile: Merge with EOM 1.9
conf.c: Merge with EOM 1.40
util.c: Merge with EOM 1.17

author: ho
Add file permission check to private key file. Split out check function to util.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.20 2000/10/13 12:19:57 niklas Exp $	*/
/*	$EOM: conf.c,v 1.40 2000/10/13 13:04:16 ho Exp $	*/
d48 1
d312 1
a312 1
 *     QM-{ESP,AH}[-TRP]-{DES,3DES,CAST,BLF,AES}[-{MD5,SHA}][-PFS]-SUITE
d353 1
a353 1
  char *qm_hash[]   = { "HMAC_MD5", "HMAC_SHA", "NONE", NULL };
d359 1
a359 1
  char *qm_hash_p[] = { "-MD5", "-SHA", "", NULL };
d394 1
d397 1
d433 1
d436 1
d511 6
d518 6
a523 2
  if (check_file_secrecy (conf_path, &sz))
    return;
d525 6
a530 6
  fd = open (conf_path, O_RDONLY);
  if (fd == -1)
    {
      log_error ("conf_reinit: open (\"%s\", O_RDONLY) failed", conf_path);
      return;
    }
d532 8
a539 14
  new_conf_addr = malloc (sz);
  if (!new_conf_addr)
    {
      log_error ("conf_reinit: malloc (%d) failed", sz);
      goto fail;
    }
  /* XXX I assume short reads won't happen here.  */
  if (read (fd, new_conf_addr, sz) != sz)
    {
      log_error ("conf_reinit: read (%d, %p, %d) failed", fd, new_conf_addr,
		 sz);
      goto fail;
    }
  close (fd);
d541 1
a541 1
  trans = conf_begin ();
d543 5
a547 2
  /* XXX Should we not care about errors and rollback?  */
  conf_parse (trans, new_conf_addr, sz);
@


1.20
log
@Merge with EOM 1.39

author: ho
Revert. Be strict about file mode.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.19 2000/10/13 11:44:10 niklas Exp $	*/
/*	$EOM: conf.c,v 1.39 2000/10/13 12:20:35 ho Exp $	*/
d54 1
a503 1
  struct stat st;
d507 3
d516 1
a516 20
  if (fstat (fd, &st) == -1)
    {
      log_error ("conf_reinit: fstat (%d, &st) failed", fd);
      goto fail;
    }
  if (st.st_uid != geteuid () && st.st_uid != getuid ())
    {
      log_print ("conf_reinit: not loading %s - file owner is not process "
		 "user", conf_path);
      close (fd);
      return;
    }
  if ((st.st_mode & (S_IRWXG | S_IRWXO)) != 0)
    {
      log_print ("conf_reinit: not loading %s - too open permissions",
		 conf_path);
      close (fd);
      return;
    }
  sz = st.st_size;
@


1.19
log
@Merge with EOM 1.38

author: ho
Warn but continue on isakmpd.conf permissions.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.18 2000/10/09 23:27:30 niklas Exp $	*/
/*	$EOM: conf.c,v 1.38 2000/10/13 10:23:03 ho Exp $	*/
d526 6
a531 2
    log_print ("conf_reinit: warning, %s may have too open permissions",
	       conf_path);
@


1.18
log
@samples/VPN-3way-template.conf: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.12
samples/VPN-west.conf: Merge with EOM 1.13
samples/policy: Merge with EOM 1.6
samples/singlehost-west.conf: Merge with EOM 1.9
samples/singlehost-east.conf: Merge with EOM 1.9
conf.c: Merge with EOM 1.37
ipsec.c: Merge with EOM 1.133
ipsec_num.cst: Merge with EOM 1.4
isakmpd.conf.5: Merge with EOM 1.48
isakmpd.policy.5: Merge with EOM 1.21
policy.c: Merge with EOM 1.46

author: angelos
AES support.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.17 2000/10/07 06:59:05 niklas Exp $	*/
/*	$EOM: conf.c,v 1.37 2000/10/09 22:08:29 angelos Exp $	*/
d526 2
a527 6
    {
      log_print ("conf_reinit: not loading %s - too open permissions",
		 conf_path);
      close (fd);
      return;
    }
@


1.17
log
@Merge with EOM 1.36

author: niklas
Remove some spaces

author: niklas
do not crash on empty config files

author: ho
(c)-2000

author: provos
style as pointed out by the code style pedant.

author: provos
proper reference counting for isakmp_sa in struct message, remove bogus
calls to sa_reference; fix some more memory leaks in conf.c
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.16 2000/06/08 20:50:29 niklas Exp $	*/
/*	$EOM: conf.c,v 1.36 2000/10/06 23:19:49 niklas Exp $	*/
d310 1
a310 1
 *     QM-{ESP,AH}[-TRP]-{DES,3DES,CAST,BLF}[-{MD5,SHA}][-PFS]-SUITE
d350 1
a350 1
  char *qm_enc[]    = { "DES", "3DES", "CAST", "BLOWFISH", NULL };
d356 1
a356 1
  char *qm_enc_p[]  = { "-DES", "-3DES", "-CAST", "-BLF", NULL };
@


1.16
log
@Merge with EOM 1.31

author: angelos
Initialize [Keynote]:Credential-directory.

author: ho
Autogenerated p1/p2 default lifetimes can be defined in config.

author: niklas
style
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.15 2000/05/03 13:47:15 niklas Exp $	*/
/*	$EOM: conf.c,v 1.31 2000/05/18 05:10:18 angelos Exp $	*/
d6 1
d176 1
a176 1
conf_set_now (char *section, char *tag, char *value, int override, 
d197 3
a199 3
  node->section = section;
  node->tag = tag;
  node->value = value;
d239 2
d302 1
a302 1
/* 
d304 1
a304 1
 * suites the user wants. 
d307 1
a307 1
 *  For main mode: 
d324 1
a324 1
  for (node = TAILQ_FIRST (&conf_trans_queue); node; 
d331 2
a332 2
	  if ( *(p + strlen (p)) && *(p + strlen(p)) != ',')
	    p += strlen(p);
d347 1
a347 1
  char *mm_enc[]    = { "DES_CBC", "BLOWFISH_CBC", "3DES_CBC", 
d352 1
a352 1
  
d358 1
a358 1
  
d389 1
a389 1
	  sprintf (sect, "%s-%s%s", mm_enc_p[enc], mm_hash[hash], 
d391 1
a391 1
	  
d400 1
a400 1
	  
d403 1
a403 1
	  
d423 1
a423 1
		sprintf (tmp, "QM-%s%s%s%s%s", PROTO (proto), MODE_p (mode), 
d445 1
a445 1
		
d449 1
a449 1
		  conf_set (tr, sect, "KEY_LENGTH", CONF_DFLT_VAL_BLF_KEYLEN, 
d451 1
a451 1
                
d456 1
a456 1
		  conf_set (tr, sect, "AUTHENTICATION_ALGORITHM", 
d458 1
a458 1
                  
d461 1
a461 1
		    conf_set (tr, sect, "GROUP_DESCRIPTION", 
d466 1
a466 1
		conf_set (tr, sect, "Life", CONF_DFLT_TAG_LIFE_QUICK_MODE, 0, 
d472 1
a472 1
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_TYPE", 
d474 1
a474 1
  conf_set (tr, CONF_DFLT_TAG_LIFE_MAIN_MODE, "LIFE_DURATION", 
d478 1
a478 1
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_TYPE", 
d480 1
a480 1
  conf_set (tr, CONF_DFLT_TAG_LIFE_QUICK_MODE, "LIFE_DURATION", 
d524 1
a524 1
    } 
d721 1
a721 1
/* Decode a PEM encoded buffer.  */ 
d760 1
a760 1
	      
d768 1
a768 1
	    } 
d771 1
a771 1
	  else 
d975 6
d998 1
a998 1
  
d1004 1
a1004 1
  else 
d1010 1
a1010 1
  
d1025 1
a1025 1
  
d1055 1
a1055 1
		      goto mem_fail;		  
@


1.15
log
@Merge with EOM 1.28

author: niklas
style fascism

author: ho
style fix

author: ho
Typo in comment.

author: ho
Typo; Cers-directory -> Cert-directory

author: ho
Do not load configuration if isakmpd.conf is not owned by the user running
isakmpd. Also, do not load config if file modes are too open.
Do not warn about ignored duplicate tags when they are autogenerated.

author: niklas
From ho: provide defaults for requested transforms, shortens config files
vastly.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.14 2000/04/07 22:10:30 niklas Exp $	*/
/*	$EOM: conf.c,v 1.28 2000/05/03 13:24:45 niklas Exp $	*/
d184 1
a184 1
      if (is_default == 0)
d340 1
a340 1
  char sect[256];
d376 5
d467 2
a468 1
  /* Lifetimes */
d472 1
a472 1
	    CONF_DFLT_VAL_LIFE_MAIN_MODE, 0, 1);
d474 1
d478 1
a478 1
	    CONF_DFLT_VAL_LIFE_QUICK_MODE, 0, 1);
@


1.14
log
@Merge with EOM 1.26

author: ho
Typo in comment.

author: ho
Typo; Cers-directory -> Cert-directory

author: ho
Do not load configuration if isakmpd.conf is not owned by the user running
isakmpd. Also, do not load config if file modes are too open.
Do not warn about ignored duplicate tags when they are autogenerated.

author: niklas
From ho: provide defaults for requested transforms, shortens config files
vastly.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.13 2000/04/07 22:10:30 niklas Exp $	*/
/*	$EOM: conf.c,v 1.26 2000/05/01 23:35:37 ho Exp $	*/
d508 1
a508 1
  if (st.st_uid != geteuid() && st.st_uid != getuid())
d515 1
a515 1
  if ((st.st_mode & (S_IRWXG|S_IRWXO)) != 0)
d1006 1
a1006 1
  dumper = dnode = (struct dumper *)calloc (1, sizeof (struct dumper));
d1020 23
a1042 23
	    {
	      if (current_section)
		{
		  dnode->s = malloc (strlen (current_section) + 3);
		  if (!dnode->s)
		    goto mem_fail;

		  sprintf (dnode->s, "[%s]", current_section);
		  dnode->next = 
		    (struct dumper *)calloc (1, sizeof (struct dumper));
		  dnode = dnode->next;
		  if (!dnode)
		    goto mem_fail;

		  dnode->s = "";
		  dnode->next = 
		    (struct dumper *)calloc (1, sizeof (struct dumper));
		  dnode = dnode->next;
		  if (!dnode)
		    goto mem_fail;		  
		}
	      current_section = cb->section;
	    }
d1068 6
a1073 6
  {
    dumper = dumper->next;
    if (dnode->s)
      free (dnode->s);
    free (dnode);
  }
@


1.13
log
@conf.c: Merge with EOM 1.22
gmp_util.c: Merge with EOM 1.5
gmp_util.h: Merge with EOM 1.3
math_mp.h: Merge with EOM 1.2
sa.c: Merge with EOM 1.101
ui.c: Merge with EOM 1.40

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.12 2000/04/07 22:06:44 niklas Exp $	*/
/*	$EOM: conf.c,v 1.22 2000/04/07 22:05:57 niklas Exp $	*/
d62 1
d70 2
a71 2
const u_int8_t bin2asc[] =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
d98 1
d175 2
a176 1
conf_set_now (char *section, char *tag, char *value, int override)
d184 3
a186 2
      log_print ("conf_set: duplicate tag [%s]:%s, ignoring...\n", section,
		 tag);
d199 1
d258 1
a258 1
		  line + i + 1 + strspn (line + i + 1, " \t"), 0);
d299 177
d508 14
d543 3
d713 1
a713 1
conf_decode_base64(u_int8_t *out, u_int32_t *len, u_char *buf)
d755 1
a755 1
	      if (strcmp(buf, "="))
d843 2
a844 1
conf_set (int transaction, char *section, char *tag, char *value, int override)
d870 1
d953 1
a953 1
			      node->override);
d969 106
@


1.12
log
@conf.c: Merge with EOM 1.21
isakmpd.c: Merge with EOM 1.46
sa.c: Merge with EOM 1.100
ui.c: Merge with EOM 1.39

author: niklas
error message style
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.11 2000/02/25 17:23:38 niklas Exp $	*/
/*	$EOM: conf.c,v 1.21 2000/04/07 19:03:25 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.11
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.10 1999/08/05 22:41:08 niklas Exp $	*/
/*	$EOM: conf.c,v 1.20 2000/02/20 19:58:36 niklas Exp $	*/
d318 1
a318 1
      log_error ("open (\"%s\", O_RDONLY) failed", conf_path);
d323 1
a323 1
      log_error ("fstat (%d, &st) failed", fd);
d330 1
a330 1
      log_error ("malloc (%d) failed", sz);
d336 2
a337 1
      log_error ("read (%d, %p, %d) failed", fd, new_conf_addr, sz);
@


1.10
log
@DESIGN-NOTES: Merge with EOM 1.47
conf.c: Merge with EOM 1.19
conf.h: Merge with EOM 1.10
ui.c: Merge with EOM 1.34

author: niklas
Dynamic updates of the configuration database is now possible, either through
ui, or through the new conf_* API described in DESIGN-NOTES
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.9 1999/05/01 20:43:42 niklas Exp $	*/
/*	$EOM: conf.c,v 1.19 1999/08/05 14:57:59 niklas Exp $	*/
d132 2
a133 2
	  log_debug (LOG_MISC, 70, "[%s]:%s->%s removed", section, tag,
		     cb->value);
d157 2
a158 2
	  log_debug (LOG_MISC, 70, "[%s]:%s->%s removed", section, cb->tag,
		     cb->value);
d197 2
a198 2
  log_debug (LOG_MISC, 70, "[%s]:%s->%s", node->section, node->tag,
	     node->value);
d393 2
a394 2
      log_debug (LOG_MISC, 90, "conf_match_num: %s:%s %d==%d?", section, tag,
		 val, x);
d397 2
a398 2
      log_debug (LOG_MISC, 90, "conf_match_num: %s:%s %d<=%d<=%d?", section,
		 tag, min, x, max);
d418 2
a419 2
	log_debug (LOG_MISC, 60, "conf_get_str: [%s]:%s->%s", section,
		   tag, cb->value);
d422 3
a424 3
  log_debug (LOG_MISC, 60,
	     "conf_get_str: configuration value not found [%s]:%s", section,
	     tag);
@


1.9
log
@sysdep/openbsd/sysdep.c: Merge with EOM 1.7
DESIGN-NOTES: Merge with EOM 1.42
Makefile: Merge with EOM 1.51
app.c: Merge with EOM 1.6
conf.c: Merge with EOM 1.18
init.c: Merge with EOM 1.14
isakmpd.conf.5: Merge with EOM 1.19
pf_encap.c: Merge with EOM 1.64
pf_encap.h: Merge with EOM 1.12
pf_key_v2.h: Merge with EOM 1.3
sysdep.h: Merge with EOM 1.16
transport.c: Merge with EOM 1.40
ui.c: Merge with EOM 1.32

author: niklas
A new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.8 1999/04/05 21:00:40 niklas Exp $	*/
/*	$EOM: conf.c,v 1.18 1999/05/01 20:21:07 niklas Exp $	*/
d54 12
a68 1

d100 1
a100 1
LIST_HEAD (conf_bindings, conf_binding) conf_bindings;
a101 1
static off_t conf_sz;
d104 64
a170 1
 * XXX Should really be a hash table implementation.
d172 2
a173 2
static void
conf_set (char *section, char *line, int pos)
d175 10
a184 2
  struct conf_binding *node;
  int i;
d186 1
a186 1
  node = malloc (sizeof *node);
a187 7
    log_fatal ("conf_set: out of memory");
  node->section = section;
  node->tag = line;
  for (i = 0; line[i] && i < pos; i++)
    ;
  line[i] = '\0';
  if (conf_get_str (section, line))
d189 2
a190 3
      log_print ("conf_set: duplicate tag [%s]:%s, ignoring...\n", section,
		 line);
      return;
d192 6
a197 3
  node->value = line + pos + 1 + strspn (line + pos + 1, " \t");
  LIST_INSERT_HEAD (&conf_bindings, node, link);
  log_debug (LOG_MISC, 70, "(%s,%s)->%s", node->section, node->tag,
d199 1
d207 1
a207 1
conf_parse_line (char *line, size_t sz)
d250 4
a253 1
	conf_set (section, line, i);
d267 1
a267 1
conf_parse (void)
d269 2
a270 2
  char *cp = conf_addr;
  char *conf_end = conf_addr + conf_sz;
d274 1
a274 1
  while (cp < conf_end)
d279 1
a279 1
	  if (cp > conf_addr && *(cp - 1) == '\\')
d284 1
a284 1
	      conf_parse_line (line, cp - line);
d294 11
d307 1
a307 1
conf_init (void)
d309 2
a310 1
  int fd;
d312 30
d343 4
a346 7
  /*
   * Start by freeing potential existing configuration.
   *
   * XXX One could envision doing this late, surviving failures with just
   * a warning log message that the new configuration did not get read
   * and that the former one persists.
   */
d349 4
a352 2
      while (LIST_FIRST (&conf_bindings))
	LIST_REMOVE (LIST_FIRST (&conf_bindings), link);
d356 7
a362 12
  fd = open (conf_path, O_RDONLY);
  if (fd == -1)
    log_fatal ("open (\"%s\", O_RDONLY)", conf_path);
  if (fstat (fd, &st) == -1)
    log_fatal ("fstat (%d, &st)", fd);
  conf_sz = st.st_size;
  conf_addr = malloc (conf_sz);
  if (!conf_addr)
    log_fatal ("malloc (%d)", conf_sz);
  /* XXX I assume short reads won't happen here.  */
  if (read (fd, conf_addr, conf_sz) != conf_sz)
    log_fatal ("read (%d, %p, %d)", fd, conf_addr, conf_sz);
a363 3

  LIST_INIT (&conf_bindings);
  conf_parse ();
d413 2
a414 1
  for (cb = LIST_FIRST (&conf_bindings); cb; cb = LIST_NEXT (cb, link))
d418 1
a418 1
	log_debug (LOG_MISC, 60, "conf_get_str: (%s, %s) -> %s", section,
d423 1
a423 1
	     "conf_get_str: configuration value not found (%s, %s)", section,
d490 2
a491 1
  for (cb = LIST_FIRST (&conf_bindings); cb; cb = LIST_NEXT (cb, link))
d614 153
@


1.8
log
@Merge with EOM 1.17
memory leak fixes

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.7 1999/03/02 15:35:12 niklas Exp $	*/
/*	$EOM: conf.c,v 1.17 1999/04/05 08:30:41 niklas Exp $	*/
a250 5

#ifdef NEED_SYSDEP_APP
  /* Let the application layer record on-demand keyed connections.  */
  app_conf_init_hook ();
#endif
@


1.7
log
@conf.c: Merge with EOM 1.15
One include too much

conf.h: Merge with EOM 1.7
Forgotten include file
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.6 1999/02/26 03:34:26 niklas Exp $	*/
/*	$EOM: conf.c,v 1.15 1999/03/02 15:33:33 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d319 4
d350 1
a350 1
      node = malloc (sizeof *node);
d353 3
a355 1
      node->field = field;
d358 1
d385 1
a385 1
	node = malloc (sizeof *node);
d388 3
a390 1
	node->field = cb->tag;
d493 10
a502 2
  while (TAILQ_FIRST (&list->fields))
    TAILQ_REMOVE (&list->fields, TAILQ_FIRST (&list->fields), link);
@


1.6
log
@Merge from the Ericsson repository
| revision 1.14
| date: 1999/02/25 11:38:47;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.13
| date: 1999/02/25 11:09:31;  author: niklas;  state: Exp;  lines: +7 -4
| Make conf_get_num take a default value to give back when tag does not exist
| ----------------------------
| revision 1.12
| date: 1999/01/31 01:20:42;  author: niklas;  state: Exp;  lines: +7 -1
| on-demand keying
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.5 1998/12/21 21:52:56 niklas Exp $	*/
/*	$EOM: conf.c,v 1.14 1999/02/25 11:38:47 niklas Exp $	*/
a37 1
#include <sys/types.h>
@


1.5
log
@Remove bogus check of printableness of the config file
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.4 1998/11/20 07:38:30 niklas Exp $	*/
/*	$EOM: conf.c,v 1.11 1998/12/21 21:28:55 niklas Exp $	*/
d49 3
d252 5
d259 4
a262 1
/* Return the numeric value denoted by TAG in section SECTION.  */
d264 1
a264 1
conf_get_num (char *section, char *tag)
d270 1
a270 1
  return 0;
@


1.4
log
@Add iterator for tags in a section.  Add range checking for numbers.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.3 1998/11/17 11:10:08 niklas Exp $	*/
/*	$EOM: conf.c,v 1.10 1998/11/20 07:19:21 niklas Exp $	*/
a135 7
  for (i = 0; line[i]; i++)
    if (!isprint (*cp))
      {
	log_print ("conf_parse_line: %d:"
		   "ignoring line %d with non-printable characters", ln);
	return;
      }
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.c,v 1.2 1998/11/15 00:43:50 niklas Exp $	*/
/*	$EOM: conf.c,v 1.9 1998/10/08 21:21:37 niklas Exp $	*/
d269 27
d356 30
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: conf.c,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: conf.c,v 1.9 1998/10/08 21:21:37 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
