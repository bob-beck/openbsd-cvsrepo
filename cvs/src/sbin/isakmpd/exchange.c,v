head	1.138;
access;
symbols
	OPENBSD_6_1:1.138.0.6
	OPENBSD_6_1_BASE:1.138
	OPENBSD_6_0:1.138.0.2
	OPENBSD_6_0_BASE:1.138
	OPENBSD_5_9:1.137.0.2
	OPENBSD_5_9_BASE:1.137
	OPENBSD_5_8:1.136.0.4
	OPENBSD_5_8_BASE:1.136
	OPENBSD_5_7:1.135.0.2
	OPENBSD_5_7_BASE:1.135
	OPENBSD_5_6:1.135.0.6
	OPENBSD_5_6_BASE:1.135
	OPENBSD_5_5:1.135.0.4
	OPENBSD_5_5_BASE:1.135
	OPENBSD_5_4:1.134.0.10
	OPENBSD_5_4_BASE:1.134
	OPENBSD_5_3:1.134.0.8
	OPENBSD_5_3_BASE:1.134
	OPENBSD_5_2:1.134.0.6
	OPENBSD_5_2_BASE:1.134
	OPENBSD_5_1_BASE:1.134
	OPENBSD_5_1:1.134.0.4
	OPENBSD_5_0:1.134.0.2
	OPENBSD_5_0_BASE:1.134
	OPENBSD_4_9:1.133.0.10
	OPENBSD_4_9_BASE:1.133
	OPENBSD_4_8:1.133.0.8
	OPENBSD_4_8_BASE:1.133
	OPENBSD_4_7:1.133.0.4
	OPENBSD_4_7_BASE:1.133
	OPENBSD_4_6:1.133.0.6
	OPENBSD_4_6_BASE:1.133
	OPENBSD_4_5:1.133.0.2
	OPENBSD_4_5_BASE:1.133
	OPENBSD_4_4:1.132.0.4
	OPENBSD_4_4_BASE:1.132
	OPENBSD_4_3:1.132.0.2
	OPENBSD_4_3_BASE:1.132
	OPENBSD_4_2:1.131.0.2
	OPENBSD_4_2_BASE:1.131
	OPENBSD_4_1:1.129.0.2
	OPENBSD_4_1_BASE:1.129
	OPENBSD_4_0:1.128.0.2
	OPENBSD_4_0_BASE:1.128
	OPENBSD_3_9:1.125.0.2
	OPENBSD_3_9_BASE:1.125
	OPENBSD_3_8:1.123.0.2
	OPENBSD_3_8_BASE:1.123
	OPENBSD_3_7:1.111.0.2
	OPENBSD_3_7_BASE:1.111
	OPENBSD_3_6:1.103.0.2
	OPENBSD_3_6_BASE:1.103
	OPENBSD_3_5:1.91.0.2
	OPENBSD_3_5_BASE:1.91
	OPENBSD_3_4:1.84.0.2
	OPENBSD_3_4_BASE:1.84
	OPENBSD_3_3:1.78.0.2
	OPENBSD_3_3_BASE:1.78
	OPENBSD_3_2:1.70.0.2
	OPENBSD_3_2_BASE:1.70
	OPENBSD_3_1:1.64.0.2
	OPENBSD_3_1_BASE:1.64
	OPENBSD_3_0:1.62.0.2
	OPENBSD_3_0_BASE:1.62
	OPENBSD_2_9:1.45.0.2
	OPENBSD_2_9_BASE:1.45
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.29.0.2
	OPENBSD_2_7_BASE:1.29
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.138
date	2016.03.10.07.32.16;	author yasuoka;	state Exp;
branches;
next	1.137;
commitid	aGOfvj3wuWdmV0zv;

1.137
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.136;
commitid	82PdNqu2kKAuXPfA;

1.136
date	2015.04.20.17.22.18;	author mikeb;	state Exp;
branches;
next	1.135;
commitid	uAGz6jodRlpOdhby;

1.135
date	2014.01.23.01.04.28;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.23.03.17.04;	author lum;	state Exp;
branches;
next	1.133;

1.133
date	2009.01.28.13.24.07;	author hshoexer;	state Exp;
branches;
next	1.132;

1.132
date	2007.09.02.23.50.04;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2007.08.05.09.43.09;	author tom;	state Exp;
branches;
next	1.130;

1.130
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.129;

1.129
date	2007.03.03.10.29.18;	author tom;	state Exp;
branches;
next	1.128;

1.128
date	2006.09.01.00.24.06;	author mpf;	state Exp;
branches;
next	1.127;

1.127
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.126;

1.126
date	2006.05.31.04.54.46;	author hshoexer;	state Exp;
branches;
next	1.125;

1.125
date	2005.11.16.18.35.32;	author cloder;	state Exp;
branches;
next	1.124;

1.124
date	2005.10.26.20.10.49;	author markus;	state Exp;
branches;
next	1.123;

1.123
date	2005.07.05.11.57.03;	author hshoexer;	state Exp;
branches;
next	1.122;

1.122
date	2005.06.25.23.20.43;	author hshoexer;	state Exp;
branches;
next	1.121;

1.121
date	2005.05.26.06.11.09;	author hshoexer;	state Exp;
branches;
next	1.120;

1.120
date	2005.05.26.05.14.17;	author hshoexer;	state Exp;
branches;
next	1.119;

1.119
date	2005.04.08.22.32.09;	author cloder;	state Exp;
branches;
next	1.118;

1.118
date	2005.04.08.19.40.02;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2005.04.08.18.47.19;	author hshoexer;	state Exp;
branches;
next	1.116;

1.116
date	2005.04.08.18.41.58;	author hshoexer;	state Exp;
branches;
next	1.115;

1.115
date	2005.04.08.16.52.41;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2005.03.10.17.19.08;	author cloder;	state Exp;
branches;
next	1.110;

1.110
date	2005.03.05.12.25.12;	author ho;	state Exp;
branches;
next	1.109;

1.109
date	2005.03.04.13.33.32;	author markus;	state Exp;
branches;
next	1.108;

1.108
date	2005.03.02.13.27.12;	author hshoexer;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.106;

1.106
date	2005.01.31.10.30.49;	author hshoexer;	state Exp;
branches;
next	1.105;

1.105
date	2004.12.06.12.28.21;	author ho;	state Exp;
branches;
next	1.104;

1.104
date	2004.09.17.13.53.08;	author ho;	state Exp;
branches;
next	1.103;

1.103
date	2004.08.23.11.53.24;	author ho;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2004.08.10.15.59.10;	author ho;	state Exp;
branches;
next	1.101;

1.101
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2004.07.09.16.06.48;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2004.06.21.13.09.00;	author ho;	state Exp;
branches;
next	1.98;

1.98
date	2004.06.20.17.17.34;	author ho;	state Exp;
branches;
next	1.97;

1.97
date	2004.06.20.15.20.06;	author ho;	state Exp;
branches;
next	1.96;

1.96
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.95;

1.95
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.94;

1.94
date	2004.05.06.10.40.34;	author ho;	state Exp;
branches;
next	1.93;

1.93
date	2004.05.03.21.23.51;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.31.10.54.46;	author ho;	state Exp;
branches;
next	1.91;

1.91
date	2004.02.16.20.40.34;	author markus;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2004.02.05.11.01.54;	author hshoexer;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.16.10.51.57;	author hshoexer;	state Exp;
branches;
next	1.88;

1.88
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.87;

1.87
date	2003.11.06.15.55.54;	author ho;	state Exp;
branches;
next	1.86;

1.86
date	2003.10.14.14.29.15;	author ho;	state Exp;
branches;
next	1.85;

1.85
date	2003.09.25.14.15.15;	author cloder;	state Exp;
branches;
next	1.84;

1.84
date	2003.08.08.08.46.59;	author ho;	state Exp;
branches
	1.84.2.1;
next	1.83;

1.83
date	2003.06.15.10.32.15;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.04.07.31.16;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.03.12.51.38;	author ho;	state Exp;
branches;
next	1.79;

1.79
date	2003.05.15.02.28.55;	author ho;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.06.13.32.42;	author ho;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2003.02.26.08.17.59;	author david;	state Exp;
branches;
next	1.76;

1.76
date	2003.01.09.02.50.00;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2003.01.09.02.34.43;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.21.12.09.20;	author ho;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.15.14.58.38;	author ho;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.08.10.16.30;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2002.11.06.23.57.36;	author ho;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches;
next	1.69;

1.69
date	2002.09.05.17.30.03;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2002.09.05.14.54.16;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.07.19.53.19;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.23.18.24.34;	author ho;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.03.16.27.41;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2001.08.25.22.13.27;	author niklas;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.22.07.09.03;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.15.13.06.53;	author ho;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.11.05.27.36;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2001.07.05.12.36.50;	author ho;	state Exp;
branches;
next	1.57;

1.57
date	2001.07.03.12.51.39;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2001.07.01.19.48.43;	author niklas;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.01.06.03.34;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.29.19.59.51;	author niklas;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.29.19.55.51;	author niklas;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.29.18.52.16;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.27.00.48.21;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.05.10.14.56;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.05.05.59.43;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.05.01.29.05;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.31.20.25.10;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.05.00.48.11;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.04.24.07.27.36;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.09.22.09.51;	author ho;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.08.21.23.02;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.28.22.33.48;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.24.03.59.54;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.27.12.03.32;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.26.12.12.51;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.22.08.37.05;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.12.01.45.17;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.02.02.09.26;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.12.02.02.08.17;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.16.23.27.33;	author niklas;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.10.09.23.27.11;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.07.06.57.43;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.03.07.25.24;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.08.20.49.54;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.04.07.22.07.30;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.25.17.23.39;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.19.19.31.32;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.02.01.02.46.17;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.26.15.20.29;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	99.08.26.22.32.16;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	99.07.17.21.54.39;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.07.07.22.05.06;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.06.02.06.33.00;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.05.02.19.17.18;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.05.01.22.57.14;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.04.30.22.32.51;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.04.30.11.47.26;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.04.27.21.07.40;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.04.19.19.58.17;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.05.20.58.13;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.02.01.08.25;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.03.31.23.46.25;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.03.31.01.50.29;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.03.24.14.42.18;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.02.15.48.23;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.03.37.56;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	98.12.21.01.02.23;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.11.17.11.10.10;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.11.16.12.20.33;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.15.01.13.26;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.15.01.11.25;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2001.05.08.12.45.22;	author ho;	state Exp;
branches;
next	;

1.78.2.1
date	2004.01.16.00.00.21;	author brad;	state Exp;
branches;
next	;

1.84.2.1
date	2004.01.13.22.50.07;	author brad;	state Exp;
branches;
next	;

1.91.2.1
date	2005.03.16.23.45.20;	author brad;	state Exp;
branches;
next	;

1.103.2.1
date	2005.03.16.23.34.56;	author brad;	state Exp;
branches;
next	;


desc
@@


1.138
log
@Don't retransmit responses for unauthenticated messages.
Base on diff from Yuuichi Someya

ok markus reyk mikeb
@
text
@/* $OpenBSD: exchange.c,v 1.137 2015/12/10 17:27:00 mmcc Exp $	 */
/* $EOM: exchange.c,v 1.143 2000/12/04 00:02:25 angelos Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000, 2002 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <regex.h>
#include <keynote.h>

#include "cert.h"
#include "conf.h"
#include "connection.h"
#include "constants.h"
#include "cookie.h"
#include "crypto.h"
#include "doi.h"
#include "exchange.h"
#include "ipsec_num.h"
#include "isakmp.h"
#include "isakmp_cfg.h"
#include "libcrypto.h"
#include "log.h"
#include "message.h"
#include "timer.h"
#include "transport.h"
#include "ipsec.h"
#include "sa.h"
#include "ui.h"
#include "util.h"
#include "key.h"
#include "dpd.h"

/* Initial number of bits from the cookies used as hash.  */
#define INITIAL_BUCKET_BITS 6

/*
 * Don't try to use more bits than this as a hash.
 * We only XOR 16 bits so going above that means changing the code below
 * too.
 */
#define MAX_BUCKET_BITS 16

static void     exchange_dump(char *, struct exchange *);
static void     exchange_free_aux(void *);
static struct exchange *exchange_lookup_active(char *, int);

static
LIST_HEAD(exchange_list, exchange) *exchange_tab;

/* Works both as a maximum index and a mask.  */
static int      bucket_mask;

/*
 * Validation scripts used to test messages for correct content of
 * payloads depending on the exchange type.
 */
int16_t script_base[] = {
	ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_KEY_EXCH,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_ID,
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_KEY_EXCH,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_ID,
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_END
};

int16_t script_identity_protection[] = {
	ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_KEY_EXCH,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_KEY_EXCH,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_ID,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_ID,	/* Responder -> initiator.  */
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_END
};

int16_t script_authentication_only[] = {
	ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_NONCE,
	ISAKMP_PAYLOAD_ID,
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_ID,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_END
};

int16_t script_aggressive[] = {
	ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_KEY_EXCH,
	ISAKMP_PAYLOAD_NONCE,
	ISAKMP_PAYLOAD_ID,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_KEY_EXCH,
	ISAKMP_PAYLOAD_NONCE,
	ISAKMP_PAYLOAD_ID,
	EXCHANGE_SCRIPT_AUTH,
	EXCHANGE_SCRIPT_SWITCH,
	EXCHANGE_SCRIPT_AUTH,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_END
};

int16_t script_informational[] = {
	EXCHANGE_SCRIPT_INFO,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_END
};

/*
 * Check what exchange SA is negotiated with and return a suitable validation
 * script.
 */
int16_t *
exchange_script(struct exchange *exchange)
{
	switch (exchange->type) {
	case ISAKMP_EXCH_BASE:
		return script_base;
	case ISAKMP_EXCH_ID_PROT:
		return script_identity_protection;
	case ISAKMP_EXCH_AUTH_ONLY:
		return script_authentication_only;
	case ISAKMP_EXCH_AGGRESSIVE:
		return script_aggressive;
	case ISAKMP_EXCH_INFO:
		return script_informational;
	case ISAKMP_EXCH_TRANSACTION:
		return script_transaction;
	default:
		if (exchange->type >= ISAKMP_EXCH_DOI_MIN)
			return exchange->doi->exchange_script(exchange->type);
	}
	return 0;
}

/*
 * Validate the message MSG's contents wrt what payloads the exchange type
 * requires at this point in the dialogue.  Return -1 if the validation fails,
 * 0 if it succeeds and the script is not finished and 1 if it's ready.
 */
static int
exchange_validate(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	int16_t		*pc = exchange->exch_pc;

	while (*pc != EXCHANGE_SCRIPT_END && *pc != EXCHANGE_SCRIPT_SWITCH) {
		LOG_DBG((LOG_EXCHANGE, 90,
		    "exchange_validate: checking for required %s",
		    *pc >= ISAKMP_PAYLOAD_NONE
		    ? constant_name(isakmp_payload_cst, *pc)
		    : constant_name(exchange_script_cst, *pc)));

		/* Check for existence of the required payloads.  */
		if ((*pc > 0 && !payload_first(msg, *pc)) ||
		    (*pc == EXCHANGE_SCRIPT_AUTH &&
		    !payload_first(msg, ISAKMP_PAYLOAD_HASH) &&
		    !payload_first(msg, ISAKMP_PAYLOAD_SIG)) ||
		    (*pc == EXCHANGE_SCRIPT_INFO &&
		    ((!payload_first(msg, ISAKMP_PAYLOAD_NOTIFY) &&
		    !payload_first(msg, ISAKMP_PAYLOAD_DELETE)) ||
		    (payload_first(msg, ISAKMP_PAYLOAD_DELETE) &&
		    !payload_first(msg, ISAKMP_PAYLOAD_HASH))))) {
			/* Missing payload.  */
			LOG_DBG((LOG_MESSAGE, 70,
			    "exchange_validate: msg %p requires missing %s",
			    msg, *pc >= ISAKMP_PAYLOAD_NONE
			    ? constant_name(isakmp_payload_cst, *pc)
			    : constant_name(exchange_script_cst, *pc)));
			return -1;
		}
		pc++;
	}
	if (*pc == EXCHANGE_SCRIPT_END)
		/* Cleanup.  */
		return 1;

	return 0;
}

/* Feed unhandled payloads to the DOI for handling. Help for exchange_run(). */
static void
exchange_handle_leftover_payloads(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct doi	*doi = exchange->doi;
	struct payload	*p;
	int	i;

	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_MAX; i++) {
		if (i == ISAKMP_PAYLOAD_PROPOSAL ||
		    i == ISAKMP_PAYLOAD_TRANSFORM)
			continue;
		TAILQ_FOREACH(p, &msg->payload[i], link) {
			if (p->flags & PL_MARK)
				continue;
			if (!doi->handle_leftover_payload ||
			    doi->handle_leftover_payload(msg, i, p))
				LOG_DBG((LOG_EXCHANGE, 10,
				    "exchange_handle_leftover_payloads: "
				    "unexpected payload %s",
				    constant_name(isakmp_payload_cst, i)));
		}
	}
}

/*
 * Run the exchange script from a point given by the "program counter"
 * upto either the script's end or a transmittal of a message.  If we are
 * at the point of a reception of a message, that message should be handed
 * in here in the MSG argument.  Otherwise we are the initiator and should
 * expect MSG to be a half-cooked message without payloads.
 */
void
exchange_run(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct doi	*doi = exchange->doi;
	int             (*handler)(struct message *) = exchange->initiator ?
			    doi->initiator : doi->responder;
	int              done = 0;

	while (!done) {
		/*
		 * It's our turn if we're either the initiator on an even step,
		 * or the responder on an odd step of the dialogue.
		 */
		if (exchange->initiator ^ (exchange->step % 2)) {
			done = 1;
			if (exchange->step)
				msg = message_alloc_reply(msg);
			message_setup_header(msg, exchange->type, 0,
			    exchange->message_id);
			if (handler(msg)) {
				/*
				 * This can happen when transient starvation
				 * of memory occurs.
				 * XXX The peer's retransmit ought to
				 * kick-start this exchange again.  If he's
				 * stopped retransmitting he's likely dropped
				 * the SA at his side so we need to do that
				 * too, i.e.  implement automatic SA teardown
				 * after a certain amount of inactivity.
				 */
				log_print("exchange_run: doi->%s (%p) failed",
				    exchange->initiator ? "initiator" :
				    "responder", msg);
				message_free(msg);
				return;
			}
			switch (exchange_validate(msg)) {
			case 1:
				/*
				 * The last message of a multi-message
				 * exchange should not be retransmitted other
				 * than "on-demand", i.e. if we see
				 * retransmits of the last message of the peer
				 * later.
				 */
				msg->flags |= MSG_LAST;
				if (exchange->step > 0) {
					if (exchange->last_sent)
						message_free(exchange->last_sent);
					exchange->last_sent = msg;
				}
				/*
				 * After we physically have sent our last
				 * message we need to do SA-specific
				 * finalization, like telling our application
				 * the SA is ready to be used, or issuing a
				 * CONNECTED notify if we set the COMMIT bit.
				 */
				message_register_post_send(msg,
				    exchange_finalize);

				/* FALLTHROUGH */

			case 0:
				/*
				 * Don't retransmit responses for
				 * unauthenticated messages.
				 */
				if ((exchange->type == ISAKMP_EXCH_ID_PROT ||
				    exchange->type == ISAKMP_EXCH_AGGRESSIVE) &&
				    exchange->phase == 1 && exchange->step == 1)
					msg->flags |= MSG_DONTRETRANSMIT;

				/* XXX error handling.  */
				message_send(msg);
				break;

			default:
				log_print("exchange_run: exchange_validate "
				    "failed, DOI error");
				exchange_free(exchange);
				message_free(msg);
				return;
			}
		} else {
			done = exchange_validate(msg);
			switch (done) {
			case 0:
			case 1:
				/* Feed the message to the DOI.  */
				if (handler(msg)) {
					/*
					 * Trust the peer to retransmit.
					 * XXX We have to implement SA aging
					 * with automatic teardown.
					 */
					message_free(msg);
					return;
				}
				/*
				 * Go over the yet unhandled payloads and feed
				 * them to DOI for handling.
				 */
				exchange_handle_leftover_payloads(msg);

				/*
				 * We have advanced the state.  If we have
				 * been processing an incoming message, record
				 * that message as the one to do duplication
				 * tests against.
				 */
				if (exchange->last_received)
					message_free(exchange->last_received);
				exchange->last_received = msg;
				if (exchange->flags & EXCHANGE_FLAG_ENCRYPT)
					crypto_update_iv(exchange->keystate);

				if (done) {
					exchange_finalize(msg);
					return;
				}
				break;

			case -1:
				log_print("exchange_run: exchange_validate "
				    "failed");
				/*
				 * XXX Is this the best error notification
				 * type?
				 */
				message_drop(msg,
				    ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
				return;
			}
		}

		LOG_DBG((LOG_EXCHANGE, 40,
		    "exchange_run: exchange %p finished step %d, advancing...",
		    exchange, exchange->step));
		exchange->step++;
		while (*exchange->exch_pc != EXCHANGE_SCRIPT_SWITCH &&
		    *exchange->exch_pc != EXCHANGE_SCRIPT_END)
			exchange->exch_pc++;
		exchange->exch_pc++;
	}
}

void
exchange_init(void)
{
	int	i;

	bucket_mask = (1 << INITIAL_BUCKET_BITS) - 1;
	exchange_tab = calloc(bucket_mask + 1, sizeof(struct exchange_list));
	if (!exchange_tab)
		log_fatal("exchange_init: out of memory");
	for (i = 0; i <= bucket_mask; i++)
		LIST_INIT(&exchange_tab[i]);
}

/* Lookup a phase 1 exchange out of just the initiator cookie.  */
struct exchange *
exchange_lookup_from_icookie(u_int8_t *cookie)
{
	struct exchange *exchange;
	int	i;

	for (i = 0; i <= bucket_mask; i++)
		for (exchange = LIST_FIRST(&exchange_tab[i]); exchange;
		    exchange = LIST_NEXT(exchange, link))
			if (memcmp(exchange->cookies, cookie,
			    ISAKMP_HDR_ICOOKIE_LEN) == 0 &&
			    exchange->phase == 1)
				return exchange;
	return 0;
}

/* Lookup an exchange out of the name and phase.  */
struct exchange *
exchange_lookup_by_name(char *name, int phase)
{
	struct exchange *exchange;
	int	i;

	/* If we search for nothing, we will find nothing.  */
	if (!name)
		return 0;

	for (i = 0; i <= bucket_mask; i++)
		for (exchange = LIST_FIRST(&exchange_tab[i]); exchange;
		    exchange = LIST_NEXT(exchange, link)) {
			LOG_DBG((LOG_EXCHANGE, 90,
			    "exchange_lookup_by_name: %s == %s && %d == %d?",
			    name, exchange->name ? exchange->name :
			    "<unnamed>", phase, exchange->phase));

			/*
			 * Match by name, but don't select finished exchanges,
			 * i.e where MSG_LAST are set in last_sent msg.
			 */
			if (exchange->name &&
			    strcasecmp(exchange->name, name) == 0 &&
			    exchange->phase == phase &&
			    (!exchange->last_sent ||
				(exchange->last_sent->flags & MSG_LAST) == 0))
				return exchange;
		}
	return 0;
}

/* Lookup an exchange out of the name, phase and step > 1.  */
static struct exchange *
exchange_lookup_active(char *name, int phase)
{
	struct exchange *exchange;
	int	i;

	/* XXX Almost identical to exchange_lookup_by_name.  */

	if (!name)
		return 0;

	for (i = 0; i <= bucket_mask; i++)
		for (exchange = LIST_FIRST(&exchange_tab[i]); exchange;
		    exchange = LIST_NEXT(exchange, link)) {
			LOG_DBG((LOG_EXCHANGE, 90,
			    "exchange_lookup_active: %s == %s && %d == %d?",
			    name, exchange->name ? exchange->name :
			    "<unnamed>", phase, exchange->phase));
			if (exchange->name &&
			    strcasecmp(exchange->name, name) == 0 &&
			    exchange->phase == phase) {
				if (exchange->step > 1)
					return exchange;
				else
					LOG_DBG((LOG_EXCHANGE, 80,
					    "exchange_lookup_active: avoided "
					    "early (pre-step 1) exchange %p",
					    exchange));
			}
		}
	return 0;
}

static void
exchange_enter(struct exchange *exchange)
{
	u_int16_t	bucket = 0;
	u_int8_t       *cp;
	int             i;

	/* XXX We might resize if we are crossing a certain threshold */

	for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2) {
		cp = exchange->cookies + i;
		/* Doing it this way avoids alignment problems.  */
		bucket ^= cp[0] | cp[1] << 8;
	}
	for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2) {
		cp = exchange->message_id + i;
		/* Doing it this way avoids alignment problems.  */
		bucket ^= cp[0] | cp[1] << 8;
	}
	bucket &= bucket_mask;
	LIST_INSERT_HEAD(&exchange_tab[bucket], exchange, link);
}

/*
 * Lookup the exchange given by the header fields MSG.  PHASE2 is false when
 * looking for phase 1 exchanges and true otherwise.
 */
struct exchange *
exchange_lookup(u_int8_t *msg, int phase2)
{
	struct exchange *exchange;
	u_int16_t       bucket = 0;
	u_int8_t       *cp;
	int             i;

	/*
         * We use the cookies to get bits to use as an index into exchange_tab,
	 * as at least one (our cookie) is a good hash, xoring all the bits,
	 * 16 at a time, and then masking, should do.  Doing it this way means
	 * we can validate cookies very fast thus delimiting the effects of
	 * "Denial of service"-attacks using packet flooding.
         */
	for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2) {
		cp = msg + ISAKMP_HDR_COOKIES_OFF + i;
		/* Doing it this way avoids alignment problems.  */
		bucket ^= cp[0] | cp[1] << 8;
	}
	if (phase2)
		for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2) {
			cp = msg + ISAKMP_HDR_MESSAGE_ID_OFF + i;
			/* Doing it this way avoids alignment problems.  */
			bucket ^= cp[0] | cp[1] << 8;
		}
	bucket &= bucket_mask;
	for (exchange = LIST_FIRST(&exchange_tab[bucket]);
	    exchange && (memcmp(msg + ISAKMP_HDR_COOKIES_OFF,
		exchange->cookies, ISAKMP_HDR_COOKIES_LEN) != 0 ||
		(phase2 && memcmp(msg + ISAKMP_HDR_MESSAGE_ID_OFF,
		    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN) != 0) ||
		(!phase2 && !zero_test(msg + ISAKMP_HDR_MESSAGE_ID_OFF,
		    ISAKMP_HDR_MESSAGE_ID_LEN)));
	    exchange = LIST_NEXT(exchange, link))
		;

	return exchange;
}

/*
 * Create a phase PHASE exchange where INITIATOR denotes our role.  DOI
 * is the domain of interpretation identifier and TYPE tells what exchange
 * type to use per either the DOI document or the ISAKMP spec proper.
 * NSA tells how many SAs we should pre-allocate, and should be zero
 * when we have the responder role.
 */
static struct exchange *
exchange_create(int phase, int initiator, int doi, int type)
{
	struct exchange *exchange;
	struct timeval	 expiration;
	int	delta;

	/*
         * We want the exchange zeroed for exchange_free to be able to find
         * out what fields have been filled-in.
         */
	exchange = calloc(1, sizeof *exchange);
	if (!exchange) {
		log_error("exchange_create: calloc (1, %lu) failed",
		    (unsigned long)sizeof *exchange);
		return 0;
	}
	exchange->phase = phase;
	exchange->step = 0;
	exchange->initiator = initiator;
	bzero(exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	bzero(exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
	exchange->doi = doi_lookup(doi);
	exchange->type = type;
	exchange->policy_id = -1;
	exchange->exch_pc = exchange_script(exchange);
	exchange->last_sent = exchange->last_received = 0;
	TAILQ_INIT(&exchange->sa_list);
	TAILQ_INIT(&exchange->aca_list);

	/* Allocate the DOI-specific structure and initialize it to zeroes.  */
	if (exchange->doi->exchange_size) {
		exchange->data = calloc(1, exchange->doi->exchange_size);
		if (!exchange->data) {
			log_error("exchange_create: calloc (1, %lu) failed",
			    (unsigned long)exchange->doi->exchange_size);
			exchange_free(exchange);
			return 0;
		}
	}
	gettimeofday(&expiration, 0);
	delta = conf_get_num("General", "Exchange-max-time",
	    EXCHANGE_MAX_TIME);
	expiration.tv_sec += delta;
	exchange->death = timer_add_event("exchange_free_aux",
	    exchange_free_aux, exchange, &expiration);
	if (!exchange->death) {
		/* If we don't give up we might start leaking...  */
		exchange_free_aux(exchange);
		return 0;
	}
	return exchange;
}

struct exchange_finalization_node {
	void	(*first)(struct exchange *, void *, int);
	void	*first_arg;
	void	(*second)(struct exchange *, void *, int);
	void	*second_arg;
};

/* Run the finalization functions of ARG.  */
static void
exchange_run_finalizations(struct exchange *exchange, void *arg, int fail)
{
	struct exchange_finalization_node *node = arg;

	node->first(exchange, node->first_arg, fail);
	node->second(exchange, node->second_arg, fail);
	free(node);
}

/*
 * Add a finalization function FINALIZE with argument ARG to the tail
 * of the finalization function list of EXCHANGE.
 */
static void
exchange_add_finalization(struct exchange *exchange,
    void (*finalize)(struct exchange *, void *, int), void *arg)
{
	struct exchange_finalization_node *node;

	if (!finalize)
		return;

	if (!exchange->finalize) {
		exchange->finalize = finalize;
		exchange->finalize_arg = arg;
		return;
	}
	node = malloc(sizeof *node);
	if (!node) {
		log_error("exchange_add_finalization: malloc (%lu) failed",
		    (unsigned long)sizeof *node);
		free(arg);
		return;
	}
	node->first = exchange->finalize;
	node->first_arg = exchange->finalize_arg;
	node->second = finalize;
	node->second_arg = arg;
	exchange->finalize = exchange_run_finalizations;
	exchange->finalize_arg = node;
}

static void
exchange_establish_transaction(struct exchange *exchange, void *arg, int fail)
{
	/* Establish a TRANSACTION exchange.  */
	struct exchange_finalization_node *node =
	    (struct exchange_finalization_node *)arg;
	struct sa *isakmp_sa = sa_lookup_by_name((char *) node->second_arg, 1);

	if (isakmp_sa && !fail)
		exchange_establish_p2(isakmp_sa, ISAKMP_EXCH_TRANSACTION, 0, 0,
		    node->first, node->first_arg);

	free(node);
}

/* Establish a phase 1 exchange.  */
void
exchange_establish_p1(struct transport *t, u_int8_t type, u_int32_t doi,
    char *name, void *args, void (*finalize)(struct exchange *, void *, int),
    void *arg, int stayalive)
{
	struct exchange		*exchange;
	struct message		*msg;
	struct conf_list	*flags;
	struct conf_list_node	*flag;
	char	*tag = 0;
	char	*str;

	if (name) {
		/* If no exchange type given, fetch from the configuration.  */
		if (type == 0) {
			/*
			 * XXX Similar code can be found in
			 * exchange_setup_p1.  Share?
			 */

			/* Find out our phase 1 mode.  */
			tag = conf_get_str(name, "Configuration");
			if (!tag) {
				/* Use default setting.  */
				tag = CONF_DFLT_TAG_PHASE1_CONFIG;
			}
			/* Figure out the DOI.  XXX Factor out?  */
			str = conf_get_str(tag, "DOI");
			if (!str || strcasecmp(str, "IPSEC") == 0)
				doi = IPSEC_DOI_IPSEC;
			else if (strcasecmp(str, "ISAKMP") == 0)
				doi = ISAKMP_DOI_ISAKMP;
			else {
				log_print("exchange_establish_p1: "
				    "DOI \"%s\" unsupported", str);
				return;
			}

			/* What exchange type do we want?  */
			str = conf_get_str(tag, "EXCHANGE_TYPE");
			if (!str) {
				log_print("exchange_establish_p1: "
				    "no \"EXCHANGE_TYPE\" tag in [%s] section",
				    tag);
				return;
			}
			type = constant_value(isakmp_exch_cst, str);
			if (!type) {
				log_print("exchange_establish_p1: "
				    "unknown exchange type %s", str);
				return;
			}
		}
	}
	exchange = exchange_create(1, 1, doi, type);
	if (!exchange) {
		/* XXX Do something here?  */
		return;
	}
	if (name) {
		exchange->name = strdup(name);
		if (!exchange->name) {
			log_error("exchange_establish_p1: "
			    "strdup (\"%s\") failed", name);
			exchange_free(exchange);
			return;
		}
	}
	exchange->policy = name ? conf_get_str(name, "Configuration") : 0;
	if (!exchange->policy && name)
		exchange->policy = CONF_DFLT_TAG_PHASE1_CONFIG;

	if (name && (flags = conf_get_list(name, "Flags")) != NULL) {
		for (flag = TAILQ_FIRST(&flags->fields); flag;
		    flag = TAILQ_NEXT(flag, link))
			if (strcasecmp(flag->field, "ikecfg") == 0) {
				struct exchange_finalization_node *node;

				node = calloc(1, (unsigned long)sizeof *node);
				if (!node) {
					log_print("exchange_establish_p1: "
					    "calloc (1, %lu) failed",
					    (unsigned long)sizeof(*node));
					exchange_free(exchange);
					return;
				}
				/*
				 * Insert this finalization inbetween
				 * the original.
				 */
				node->first = finalize;
				node->first_arg = arg;
				node->second_arg = name;
				exchange_add_finalization(exchange,
				    exchange_establish_transaction,
				    node);
				finalize = 0;
			}
		conf_free_list(flags);
	}

	exchange_add_finalization(exchange, finalize, arg);
	cookie_gen(t, exchange, exchange->cookies, ISAKMP_HDR_ICOOKIE_LEN);
	exchange_enter(exchange);
	exchange_dump("exchange_establish_p1", exchange);

	msg = message_alloc(t, 0, ISAKMP_HDR_SZ);
	if (!msg) {
		log_print("exchange_establish_p1: message_alloc () failed");
		exchange_free(exchange);
		return;
	}
	msg->exchange = exchange;

	/* Do not create SA for an information or transaction exchange. */
	if (exchange->type != ISAKMP_EXCH_INFO &&
	    exchange->type != ISAKMP_EXCH_TRANSACTION) {
		/*
		 * Don't install a transport into this SA as it will be an
		 * INADDR_ANY address in the local end, which is not good at
		 * all.  Let the reply packet install the transport instead.
		 */
		sa_create(exchange, 0);
		msg->isakmp_sa = TAILQ_FIRST(&exchange->sa_list);
		if (!msg->isakmp_sa) {
			/* XXX Do something more here?  */
			message_free(msg);
			exchange_free(exchange);
			return;
		}
		sa_reference(msg->isakmp_sa);

		if (stayalive)
			msg->isakmp_sa->flags |= SA_FLAG_STAYALIVE;
	}
	msg->extra = args;

	exchange_run(msg);
}

/* Establish a phase 2 exchange.  XXX With just one SA for now.  */
void
exchange_establish_p2(struct sa *isakmp_sa, u_int8_t type, char *name,
    void *args, void (*finalize)(struct exchange *, void *, int), void *arg)
{
	struct exchange *exchange;
	struct message	*msg;
	u_int32_t        doi = ISAKMP_DOI_ISAKMP;
	u_int32_t        seq = 0;
	int              i;
	char		*tag, *str;

	if (isakmp_sa)
		doi = isakmp_sa->doi->id;

	if (name) {
		/* Find out our phase 2 modes.  */
		tag = conf_get_str(name, "Configuration");
		if (!tag) {
			log_print("exchange_establish_p2: "
			    "no configuration for peer \"%s\"", name);
			return;
		}
		seq = (u_int32_t)conf_get_num(name, "Acquire-ID", 0);

		/* Figure out the DOI.  */
		str = conf_get_str(tag, "DOI");
		if (!str || strcasecmp(str, "IPSEC") == 0)
			doi = IPSEC_DOI_IPSEC;
		else if (strcasecmp(str, "ISAKMP") == 0)
			doi = ISAKMP_DOI_ISAKMP;
		else {
			log_print("exchange_establish_p2: "
			    "DOI \"%s\" unsupported", str);
			return;
		}

		/* What exchange type do we want?  */
		if (!type) {
			str = conf_get_str(tag, "EXCHANGE_TYPE");
			if (!str) {
				log_print("exchange_establish_p2: "
				    "no \"EXCHANGE_TYPE\" tag in [%s] section",
				    tag);
				return;
			}
			/* XXX IKE dependent.  */
			type = constant_value(ike_exch_cst, str);
			if (!type) {
				log_print("exchange_establish_p2: unknown "
				    "exchange type %s", str);
				return;
			}
		}
	}
	exchange = exchange_create(2, 1, doi, type);
	if (!exchange) {
		/* XXX Do something here?  */
		return;
	}
	if (name) {
		exchange->name = strdup(name);
		if (!exchange->name) {
			log_error("exchange_establish_p2: "
			    "strdup (\"%s\") failed", name);
			exchange_free(exchange);
			return;
		}
	}
	exchange->policy = name ? conf_get_str(name, "Configuration") : 0;
	exchange->finalize = finalize;
	exchange->finalize_arg = arg;
	exchange->seq = seq;
	memcpy(exchange->cookies, isakmp_sa->cookies, ISAKMP_HDR_COOKIES_LEN);
	arc4random_buf(exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
	exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
	if (isakmp_sa->flags & SA_FLAG_NAT_T_ENABLE)
		exchange->flags |= EXCHANGE_FLAG_NAT_T_ENABLE;
	if (isakmp_sa->flags & SA_FLAG_NAT_T_KEEPALIVE)
		exchange->flags |= EXCHANGE_FLAG_NAT_T_KEEPALIVE;
	exchange_enter(exchange);
	exchange_dump("exchange_establish_p2", exchange);

	/*
         * Do not create SA's for informational exchanges.
         * XXX How to handle new group mode?
         */
	if (exchange->type != ISAKMP_EXCH_INFO &&
	    exchange->type != ISAKMP_EXCH_TRANSACTION) {
		/* XXX Number of SAs should come from the args structure.  */
		for (i = 0; i < 1; i++)
			if (sa_create(exchange, isakmp_sa->transport)) {
				exchange_free(exchange);
				return;
			}
	}
	msg = message_alloc(isakmp_sa->transport, 0, ISAKMP_HDR_SZ);
	msg->isakmp_sa = isakmp_sa;
	sa_reference(isakmp_sa);

	msg->extra = args;

	/* This needs to be done late or else get_keystate won't work right. */
	msg->exchange = exchange;

	exchange_run(msg);
}

/* Out of an incoming phase 1 message, setup an exchange.  */
struct exchange *
exchange_setup_p1(struct message *msg, u_int32_t doi)
{
	struct transport	*t = msg->transport;
	struct exchange		*exchange;
	struct sockaddr		*dst;
	struct conf_list	*flags;
	struct conf_list_node	*flag;
	char		*name = 0, *policy = 0, *str;
	u_int32_t        want_doi;
	u_int8_t         type;

	/* XXX Similar code can be found in exchange_establish_p1.  Share?  */

	/*
	 * Unless this is an informational exchange, look up our policy for
	 * this peer.
         */
	type = GET_ISAKMP_HDR_EXCH_TYPE(msg->iov[0].iov_base);
	if (type != ISAKMP_EXCH_INFO) {
		/*
		 * Find out our inbound phase 1 mode.
		 */
		t->vtbl->get_dst(t, &dst);
		if (sockaddr2text(dst, &str, 0) == -1)
			return 0;
		name = conf_get_str("Phase 1", str);
		free(str);
		if (name) {
			/*
			 * If another phase 1 exchange is ongoing don't bother
			 * returning the call. However, we will need to
			 * continue responding if our phase 1 exchange is
			 * still waiting for step 1 (i.e still half-open).
			 */
			exchange = exchange_lookup_active(name, 1);
			if (exchange) {
				LOG_DBG((LOG_EXCHANGE, 40,
				    "exchange_establish: %s exchange already "
				    "exists as %p", name, exchange));
				return 0;
			}
		} else {
			name = conf_get_str("Phase 1", "Default");
			if (!name) {
				log_print("exchange_setup_p1: no \"Default\" "
				    "tag in [Phase 1] section");
				return 0;
			}
		}

		policy = conf_get_str(name, "Configuration");
		if (!policy)
			policy = CONF_DFLT_TAG_PHASE1_CONFIG;

		/* Figure out the DOI.  */
		str = conf_get_str(policy, "DOI");
		if (!str || strcasecmp(str, "IPSEC") == 0) {
			want_doi = IPSEC_DOI_IPSEC;
			str = "IPSEC";
		}
		else if (strcasecmp(str, "ISAKMP") == 0)
			want_doi = ISAKMP_DOI_ISAKMP;
		else {
			log_print("exchange_setup_p1: "
			    "DOI \"%s\" unsupported", str);
			return 0;
		}
		if (want_doi != doi) {
			/* XXX Should I tell what DOI I got?  */
			log_print("exchange_setup_p1: expected %s DOI", str);
			return 0;
		}
		/* What exchange type do we want?  */
		str = conf_get_str(policy, "EXCHANGE_TYPE");
		if (!str) {
			log_print("exchange_setup_p1: no \"EXCHANGE_TYPE\" "
			    "tag in [%s] section", policy);
			return 0;
		}
		type = constant_value(isakmp_exch_cst, str);
		if (!type) {
			log_print("exchange_setup_p1: "
			    "unknown exchange type %s", str);
			return 0;
		}
		if (type != GET_ISAKMP_HDR_EXCH_TYPE(msg->iov[0].iov_base)) {
			log_print("exchange_setup_p1: "
			    "expected exchange type %s got %s", str,
			    constant_name(isakmp_exch_cst,
				GET_ISAKMP_HDR_EXCH_TYPE(msg->iov[0].iov_base)));
			return 0;
		}
	}
	exchange = exchange_create(1, 0, doi, type);
	if (!exchange)
		return 0;

	exchange->name = name ? strdup(name) : 0;
	if (name && !exchange->name) {
		log_error("exchange_setup_p1: strdup (\"%s\") failed", name);
		exchange_free(exchange);
		return 0;
	}
	exchange->policy = policy;

	if (name && (flags = conf_get_list(name, "Flags")) != NULL) {
		for (flag = TAILQ_FIRST(&flags->fields); flag;
		    flag = TAILQ_NEXT(flag, link))
			if (strcasecmp(flag->field, "ikecfg") == 0) {
				struct exchange_finalization_node *node;

				node = calloc(1, (unsigned long)sizeof *node);
				if (!node) {
					log_print("exchange_establish_p1: "
					    "calloc (1, %lu) failed",
					    (unsigned long)sizeof(*node));
					exchange_free(exchange);
					return 0;
				}
				/*
				 * Insert this finalization inbetween
				 * the original.
				 */
				node->first = 0;
				node->first_arg = 0;
				node->second_arg = name;
				exchange_add_finalization(exchange,
				    exchange_establish_transaction,
				    node);
			}
		conf_free_list(flags);
	}

	cookie_gen(msg->transport, exchange, exchange->cookies +
	    ISAKMP_HDR_ICOOKIE_LEN, ISAKMP_HDR_RCOOKIE_LEN);
	GET_ISAKMP_HDR_ICOOKIE(msg->iov[0].iov_base, exchange->cookies);
	exchange_enter(exchange);
	exchange_dump("exchange_setup_p1", exchange);
	return exchange;
}

/* Out of an incoming phase 2 message, setup an exchange.  */
struct exchange *
exchange_setup_p2(struct message *msg, u_int8_t doi)
{
	struct exchange *exchange;
	u_int8_t	*buf = msg->iov[0].iov_base;

	exchange = exchange_create(2, 0, doi, GET_ISAKMP_HDR_EXCH_TYPE(buf));
	if (!exchange)
		return 0;
	GET_ISAKMP_HDR_ICOOKIE(buf, exchange->cookies);
	GET_ISAKMP_HDR_RCOOKIE(buf,
	    exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN);
	GET_ISAKMP_HDR_MESSAGE_ID(buf, exchange->message_id);
	if (msg->isakmp_sa && (msg->isakmp_sa->flags & SA_FLAG_NAT_T_ENABLE))
		exchange->flags |= EXCHANGE_FLAG_NAT_T_ENABLE;
	if (msg->isakmp_sa && (msg->isakmp_sa->flags & SA_FLAG_NAT_T_KEEPALIVE))
		exchange->flags |= EXCHANGE_FLAG_NAT_T_KEEPALIVE;
	exchange_enter(exchange);
	exchange_dump("exchange_setup_p2", exchange);
	return exchange;
}

/* Dump interesting data about an exchange.  */
static void
exchange_dump_real(char *header, struct exchange *exchange, int class,
    int level)
{
	struct sa	*sa;
	char             buf[LOG_SIZE];
	/* Don't risk overflowing the final log buffer.  */
	size_t           bufsize_max = LOG_SIZE - strlen(header) - 32;

	LOG_DBG((class, level,
	    "%s: %p %s %s policy %s phase %d doi %d exchange %d step %d",
	    header, exchange, exchange->name ? exchange->name : "<unnamed>",
	    exchange->policy ? exchange->policy : "<no policy>",
	    exchange->initiator ? "initiator" : "responder", exchange->phase,
	    exchange->doi->id, exchange->type, exchange->step));
	LOG_DBG((class, level, "%s: icookie %08x%08x rcookie %08x%08x", header,
	    decode_32(exchange->cookies), decode_32(exchange->cookies + 4),
	    decode_32(exchange->cookies + 8),
	    decode_32(exchange->cookies + 12)));

	/* Include phase 2 SA list for this exchange */
	if (exchange->phase == 2) {
		snprintf(buf, bufsize_max, "sa_list ");
		for (sa = TAILQ_FIRST(&exchange->sa_list);
		    sa && strlen(buf) < bufsize_max; sa = TAILQ_NEXT(sa, next))
			snprintf(buf + strlen(buf), bufsize_max - strlen(buf),
			    "%p ", sa);
		if (sa)
			strlcat(buf, "...", bufsize_max);
	} else
		buf[0] = '\0';

	LOG_DBG((class, level, "%s: msgid %08x %s", header,
	    decode_32(exchange->message_id), buf));
}

static void
exchange_dump(char *header, struct exchange *exchange)
{
	exchange_dump_real(header, exchange, LOG_EXCHANGE, 10);
}

void
exchange_report(void)
{
	struct exchange	*exchange;
	int	i;

	for (i = 0; i <= bucket_mask; i++)
		for (exchange = LIST_FIRST(&exchange_tab[i]); exchange;
		    exchange = LIST_NEXT(exchange, link))
			exchange_dump_real("exchange_report", exchange,
			    LOG_REPORT, 0);
}

/*
 * Release all resources this exchange is using *except* for the "death"
 * event.  When removing an exchange from the expiration handler that event
 * will be dealt with therein instead.
 */
static void
exchange_free_aux(void *v_exch)
{
	struct exchange		*exchange = v_exch;
	struct sa		*sa, *next_sa;
	struct cert_handler	*handler;

	LOG_DBG((LOG_EXCHANGE, 80, "exchange_free_aux: freeing exchange %p",
	    exchange));

	if (exchange->last_received)
		message_free(exchange->last_received);
	if (exchange->last_sent)
		message_free(exchange->last_sent);
	if (exchange->in_transit &&
	    exchange->in_transit != exchange->last_sent)
		message_free(exchange->in_transit);
	free(exchange->nonce_i);
	free(exchange->nonce_r);
	free(exchange->id_i);
	free(exchange->id_r);
	free(exchange->keystate);
	if (exchange->doi && exchange->doi->free_exchange_data)
		exchange->doi->free_exchange_data(exchange->data);
	free(exchange->data);
	free(exchange->name);
	if (exchange->recv_cert) {
		handler = cert_get(exchange->recv_certtype);
		if (handler)
			handler->cert_free(exchange->recv_cert);
	}
	if (exchange->sent_cert) {
		handler = cert_get(exchange->sent_certtype);
		if (handler)
			handler->cert_free(exchange->sent_cert);
	}
	if (exchange->recv_key)
		key_free(exchange->recv_keytype, ISAKMP_KEYTYPE_PUBLIC,
		    exchange->recv_key);
	free(exchange->keynote_key);	/* This is just a string */

	if (exchange->policy_id != -1)
		kn_close(exchange->policy_id);

	exchange_free_aca_list(exchange);
	LIST_REMOVE(exchange, link);

	/* Tell potential finalize routine we never got there.  */
	if (exchange->finalize)
		exchange->finalize(exchange, exchange->finalize_arg, 1);

	/* Remove any SAs that have not been disassociated from us.  */
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa; sa = next_sa) {
		next_sa = TAILQ_NEXT(sa, next);
		/* One for the reference in exchange->sa_list.  */
		sa_release(sa);
		/* And two more for the expiration and SA linked list.  */
		sa_free(sa);
	}

	free(exchange);
}

/* Release all resources this exchange is using.  */
void
exchange_free(struct exchange *exchange)
{
	if (exchange->death)
		timer_remove_event(exchange->death);
	exchange_free_aux(exchange);
}

/*
 * Upgrade the phase 1 exchange and its ISAKMP SA with the rcookie of our
 * peer (found in his recently sent message MSG).
 */
void
exchange_upgrade_p1(struct message *msg)
{
	struct exchange *exchange = msg->exchange;

	LIST_REMOVE(exchange, link);
	GET_ISAKMP_HDR_RCOOKIE(msg->iov[0].iov_base, exchange->cookies +
	    ISAKMP_HDR_ICOOKIE_LEN);
	exchange_enter(exchange);
	sa_isakmp_upgrade(msg);
}

static int
exchange_check_old_sa(struct sa *sa, void *v_arg)
{
	struct sa	*new_sa = v_arg;
	char		 res1[1024];

	if (sa == new_sa || !sa->name || !(sa->flags & SA_FLAG_READY) ||
	    (sa->flags & SA_FLAG_REPLACED))
		return 0;

	if (sa->phase != new_sa->phase || new_sa->name == 0 ||
	    strcasecmp(sa->name, new_sa->name))
		return 0;

	if (sa->initiator)
		strlcpy(res1, ipsec_decode_ids("%s %s", sa->id_i, sa->id_i_len,
		    sa->id_r, sa->id_r_len, 0), sizeof res1);
	else
		strlcpy(res1, ipsec_decode_ids("%s %s", sa->id_r, sa->id_r_len,
		    sa->id_i, sa->id_i_len, 0), sizeof res1);

	LOG_DBG((LOG_EXCHANGE, 30,
	    "checking whether new SA replaces existing SA with IDs %s", res1));

	if (new_sa->initiator)
		return strcasecmp(res1, ipsec_decode_ids("%s %s", new_sa->id_i,
		    new_sa->id_i_len, new_sa->id_r, new_sa->id_r_len, 0)) == 0;
	else
		return strcasecmp(res1, ipsec_decode_ids("%s %s", new_sa->id_r,
		    new_sa->id_r_len, new_sa->id_i, new_sa->id_i_len, 0)) == 0;
}

void
exchange_finalize(struct message *msg)
{
	struct exchange		*exchange = msg->exchange;
	struct sa		*sa, *old_sa;
	struct proto		*proto;
	struct conf_list	*attrs;
	struct conf_list_node	*attr;
	struct cert_handler	*handler;
	int	 i;
	char	*id_doi, *id_trp;

	exchange_dump("exchange_finalize", exchange);

	/* Copy the ID from phase 1 to exchange or phase 2 SA.  */
	if (msg->isakmp_sa) {
		if (exchange->id_i && exchange->id_r) {
			ipsec_clone_id(&msg->isakmp_sa->id_i,
			    &msg->isakmp_sa->id_i_len, exchange->id_i,
			    exchange->id_i_len);
			ipsec_clone_id(&msg->isakmp_sa->id_r,
			    &msg->isakmp_sa->id_r_len, exchange->id_r,
			    exchange->id_r_len);
		} else if (msg->isakmp_sa->id_i && msg->isakmp_sa->id_r) {
			ipsec_clone_id(&exchange->id_i, &exchange->id_i_len,
			    msg->isakmp_sa->id_i, msg->isakmp_sa->id_i_len);
			ipsec_clone_id(&exchange->id_r, &exchange->id_r_len,
			    msg->isakmp_sa->id_r, msg->isakmp_sa->id_r_len);
		}
	}
	/*
         * Walk over all the SAs and noting them as ready.  If we set the
         * COMMIT bit, tell the peer each SA is connected.
         *
         * XXX The decision should really be based on if a SA was installed
         * successfully.
         */
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
	    sa = TAILQ_NEXT(sa, next)) {
		/* Move over the name to the SA.  */
		sa->name = exchange->name ? strdup(exchange->name) : 0;

		if (exchange->flags & EXCHANGE_FLAG_I_COMMITTED) {
			for (proto = TAILQ_FIRST(&sa->protos); proto;
			    proto = TAILQ_NEXT(proto, link))
				for (i = 0; i < 2; i++)
					message_send_notification(exchange->last_received,
					    msg->isakmp_sa,
					    ISAKMP_NOTIFY_STATUS_CONNECTED,
					    proto, i);
		}
		/*
		 * Locate any old SAs and mark them replaced
		 * (SA_FLAG_REPLACED).
		 */
		sa->initiator = exchange->initiator;
		while ((old_sa = sa_find(exchange_check_old_sa, sa)) != 0)
			sa_mark_replaced(old_sa);

		/* Setup the SA flags.  */
		sa->flags |= SA_FLAG_READY;
		if (exchange->name) {
			attrs = conf_get_list(exchange->name, "Flags");
			if (attrs) {
				for (attr = TAILQ_FIRST(&attrs->fields); attr;
				    attr = TAILQ_NEXT(attr, link))
					sa->flags |= sa_flag(attr->field);
				conf_free_list(attrs);
			}
			/* 'Connections' should stay alive.  */
			if (connection_exist(exchange->name)) {
				sa->flags |= SA_FLAG_STAYALIVE;

				/*
				 * ISAKMP SA of this connection should also
				 * stay alive.
				 */
				if (exchange->phase == 2 && msg->isakmp_sa)
					msg->isakmp_sa->flags |=
					    SA_FLAG_STAYALIVE;
			}
		}
		sa->seq = exchange->seq;
		sa->exch_type = exchange->type;
	}

	/*
	 * If this was an phase 1 SA negotiation, save the keystate in the
	 * ISAKMP SA structure for future initialization of phase 2 exchanges'
	 * keystates.  Also save the Phase 1 ID and authentication
	 * information.
         */
	if (exchange->phase == 1 && msg->isakmp_sa) {
		msg->isakmp_sa->keystate = exchange->keystate;
		exchange->keystate = 0;

		msg->isakmp_sa->recv_certtype = exchange->recv_certtype;
		msg->isakmp_sa->sent_certtype = exchange->sent_certtype;
		msg->isakmp_sa->recv_keytype = exchange->recv_keytype;
		msg->isakmp_sa->recv_key = exchange->recv_key;
		msg->isakmp_sa->keynote_key = exchange->keynote_key;
		/* Reset.  */
		exchange->recv_key = 0;
		exchange->keynote_key = 0;
		msg->isakmp_sa->policy_id = exchange->policy_id;
		exchange->policy_id = -1;
		msg->isakmp_sa->initiator = exchange->initiator;

		if (exchange->recv_certtype && exchange->recv_cert) {
			handler = cert_get(exchange->recv_certtype);
			if (handler)
				msg->isakmp_sa->recv_cert =
				    handler->cert_dup(exchange->recv_cert);
		}
		if (exchange->sent_certtype) {
			handler = cert_get(exchange->sent_certtype);
			if (handler)
				msg->isakmp_sa->sent_cert =
				    handler->cert_dup(exchange->sent_cert);
		}
		if (exchange->doi)
			id_doi = exchange->doi->decode_ids(
			    "initiator id %s, responder id %s",
			    exchange->id_i, exchange->id_i_len,
			    exchange->id_r, exchange->id_r_len, 0);
		else
			id_doi = "<no doi>";

		if (msg->isakmp_sa->transport)
			id_trp =
			    msg->isakmp_sa->transport->vtbl->decode_ids(msg->isakmp_sa->transport);
		else
			id_trp = "<no transport>";

		if (exchange->flags & EXCHANGE_FLAG_NAT_T_ENABLE)
			msg->isakmp_sa->flags |= SA_FLAG_NAT_T_ENABLE;
		if (exchange->flags & EXCHANGE_FLAG_NAT_T_KEEPALIVE)
			msg->isakmp_sa->flags |= SA_FLAG_NAT_T_KEEPALIVE;

		LOG_DBG((LOG_EXCHANGE, 10,
		    "exchange_finalize: phase 1 done: %s, %s", id_doi,
		    id_trp));

		log_verbose("isakmpd: phase 1 done%s: %s, %s",
			(exchange->initiator == 0) ? " (as responder)" : "",
			id_doi, id_trp);
	}
	exchange->doi->finalize_exchange(msg);
	if (exchange->finalize)
		exchange->finalize(exchange, exchange->finalize_arg, 0);
	exchange->finalize = 0;

	/*
         * There is no reason to keep the SAs connected to us anymore, in fact
         * it can hurt us if we have short lifetimes on the SAs and we try
         * to call exchange_report, where the SA list will be walked and
         * references to freed SAs can occur.
         */
	while (TAILQ_FIRST(&exchange->sa_list)) {
		sa = TAILQ_FIRST(&exchange->sa_list);

		if (exchange->id_i && exchange->id_r) {
			ipsec_clone_id(&sa->id_i, &sa->id_i_len,
			    exchange->id_i, exchange->id_i_len);
			ipsec_clone_id(&sa->id_r, &sa->id_r_len,
			    exchange->id_r, exchange->id_r_len);
		}
		TAILQ_REMOVE(&exchange->sa_list, sa, next);
		sa_release(sa);
	}
	/*
	 * Start sending DPD messages after all SAs have been released.
	 * Otherwise we have a race between exchange_free_aux() and
	 * dpd_check_event() where both will call sa_free().
	 */
	if (exchange->phase == 1 && msg->isakmp_sa &&
	    (exchange->flags & EXCHANGE_FLAG_DPD_CAP_PEER))
		dpd_start(msg->isakmp_sa);

	/* If we have nothing to retransmit we can safely remove ourselves.  */
	if (!exchange->last_sent)
		exchange_free(exchange);
}

/* Stash a nonce into the exchange data.  */
static int
exchange_nonce(struct exchange *exchange, int peer, size_t nonce_sz,
    u_int8_t *buf)
{
	u_int8_t      **nonce;
	size_t         *nonce_len;
	int		initiator = exchange->initiator ^ peer;
	char            header[32];

	if (nonce_sz < 8 || nonce_sz > 256) {
		/*
		 * RFC2409, ch 5: The length of nonce payload MUST be
		 * between 8 and 256 bytes inclusive.
		 * XXX I'm assuming the generic payload header is not included.
		 */
		LOG_DBG((LOG_EXCHANGE, 20,
		    "exchange_nonce: invalid nonce length %lu",
		    (unsigned long)nonce_sz));
		return -1;
	}

	nonce = initiator ? &exchange->nonce_i : &exchange->nonce_r;
	nonce_len =
	    initiator ? &exchange->nonce_i_len : &exchange->nonce_r_len;
	*nonce_len = nonce_sz;
	*nonce = malloc(nonce_sz);
	if (!*nonce) {
		log_error("exchange_nonce: malloc (%lu) failed",
		    (unsigned long)nonce_sz);
		return -1;
	}
	memcpy(*nonce, buf, nonce_sz);
	snprintf(header, sizeof header, "exchange_nonce: NONCE_%c",
	    initiator ? 'i' : 'r');
	LOG_DBG_BUF((LOG_EXCHANGE, 80, header, *nonce, nonce_sz));
	return 0;
}

/* Generate our NONCE.  */
int
exchange_gen_nonce(struct message *msg, size_t nonce_sz)
{
	struct exchange *exchange = msg->exchange;
	u_int8_t	*buf;

	buf = malloc(ISAKMP_NONCE_SZ + nonce_sz);
	if (!buf) {
		log_error("exchange_gen_nonce: malloc (%lu) failed",
		    ISAKMP_NONCE_SZ + (unsigned long)nonce_sz);
		return -1;
	}
	arc4random_buf(buf + ISAKMP_NONCE_DATA_OFF, nonce_sz);
	if (message_add_payload(msg, ISAKMP_PAYLOAD_NONCE, buf,
	    ISAKMP_NONCE_SZ + nonce_sz, 1)) {
		free(buf);
		return -1;
	}
	return exchange_nonce(exchange, 0, nonce_sz,
	    buf + ISAKMP_NONCE_DATA_OFF);
}

/* Save the peer's NONCE.  */
int
exchange_save_nonce(struct message *msg)
{
	struct payload	*noncep;
	struct exchange *exchange = msg->exchange;

	noncep = payload_first(msg, ISAKMP_PAYLOAD_NONCE);
	noncep->flags |= PL_MARK;
	return exchange_nonce(exchange, 1, GET_ISAKMP_GEN_LENGTH(noncep->p) -
	    ISAKMP_NONCE_DATA_OFF, noncep->p + ISAKMP_NONCE_DATA_OFF);
}

/* Save the peer's CERT REQuests.  */
int
exchange_save_certreq(struct message *msg)
{
	struct payload	*cp;
	struct exchange	*exchange = msg->exchange;
	struct certreq_aca *aca;

	TAILQ_FOREACH(cp, &msg->payload[ISAKMP_PAYLOAD_CERT_REQ], link) {
		cp->flags |= PL_MARK;
		aca = certreq_decode(GET_ISAKMP_CERTREQ_TYPE(cp->p), cp->p +
		    ISAKMP_CERTREQ_AUTHORITY_OFF, GET_ISAKMP_GEN_LENGTH(cp->p)
		    - ISAKMP_CERTREQ_AUTHORITY_OFF);
		if (aca)
			TAILQ_INSERT_TAIL(&exchange->aca_list, aca, link);
	}

	return 0;
}

/* Free the list of pending CERTREQs.  */
void
exchange_free_aca_list(struct exchange *exchange)
{
	struct certreq_aca *aca;

	for (aca = TAILQ_FIRST(&exchange->aca_list); aca;
	    aca = TAILQ_FIRST(&exchange->aca_list)) {
		free(aca->raw_ca);
		if (aca->data) {
			if (aca->handler)
				aca->handler->free_aca(aca->data);
			free(aca->data);
		}
		TAILQ_REMOVE(&exchange->aca_list, aca, link);
		free(aca);
	}
}

/* Add any CERTREQs we should send.  */
int
exchange_add_certreqs(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct certreq_aca *aca;
	u_int8_t *buf;

	/*
	 * Some peers (e.g. Cisco IOS) won't send their cert unless we
	 * specifically ask beforehand with CERTREQ.  We reflect any
	 * CERTREQs we receive from the initiator in order to do this.
	 * This avoids leaking information about which CAs we trust,
	 * and works in the most common case where both ends trust the
	 * same CA.
	 */
	for (aca = TAILQ_FIRST(&exchange->aca_list); aca;
	    aca = TAILQ_NEXT(aca, link)) {

		/* But only do this if we have at least one CA */
		if (aca->handler != NULL && aca->handler->ca_count() == 0) {
			LOG_DBG((LOG_EXCHANGE, 10,
			    "exchange_add_certreqs: no CA, so not "
			    "sending a CERTREQ"));
			continue;
		}

		if (aca->raw_ca_len) {
			buf = malloc(ISAKMP_CERTREQ_SZ + aca->raw_ca_len);
			if (buf == NULL) {
				log_error("exchange_add_certreqs: "
				    "malloc (%lu) failed",
				    ISAKMP_CERTREQ_SZ +
				    (unsigned long)aca->raw_ca_len);
				return -1;
			}

			buf[ISAKMP_CERTREQ_TYPE_OFF] = aca->id;
			memcpy(buf + ISAKMP_CERTREQ_AUTHORITY_OFF,
			    aca->raw_ca, aca->raw_ca_len);

			if (message_add_payload(msg, ISAKMP_PAYLOAD_CERT_REQ,
			    buf, ISAKMP_CERTREQ_SZ + aca->raw_ca_len, 1)) {
				free(buf);
				return -1;
			}
		}
	}

	return 0;
}

/* Obtain certificates from acceptable certification authority.  */
int
exchange_add_certs(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct certreq_aca *aca;
	u_int8_t       *cert = 0, *new_cert = 0;
	u_int32_t       certlen;
	u_int8_t       *id;
	size_t          id_len;

	id = exchange->initiator ? exchange->id_r : exchange->id_i;
	id_len = exchange->initiator ? exchange->id_r_len : exchange->id_i_len;

	/*
         * Without IDs we cannot handle this yet. Keep the aca_list around for
         * a later step/retry to see if we got the ID by then.
         * Note: A 'return -1' breaks X509-auth interop in the responder case
         *       with some IPsec clients that send CERTREQs early (such as
	 *       the SSH Sentinel).
         */
	if (!id)
		return 0;

	for (aca = TAILQ_FIRST(&exchange->aca_list); aca;
	    aca = TAILQ_NEXT(aca, link)) {
		/* XXX? If we can not satisfy a CERTREQ we drop the message. */
		if (!aca->handler->cert_obtain(id, id_len, aca->data, &cert,
		    &certlen)) {
			log_print("exchange_add_certs: could not obtain cert "
			    "for a type %d cert request", aca->id);
			free(cert);
			return -1;
		}
		new_cert = realloc(cert, ISAKMP_CERT_SZ + certlen);
		if (!new_cert) {
			log_error("exchange_add_certs: realloc (%p, %d) "
			    "failed", cert, ISAKMP_CERT_SZ + certlen);
			free(cert);
			return -1;
		}
		cert = new_cert;
		memmove(cert + ISAKMP_CERT_DATA_OFF, cert, certlen);
		SET_ISAKMP_CERT_ENCODING(cert, aca->id);
		if (message_add_payload(msg, ISAKMP_PAYLOAD_CERT, cert,
		    ISAKMP_CERT_SZ + certlen, 1)) {
			free(cert);
			return -1;
		}
		/*
		 * We need to reset cert here, as it is now controlled by
		 * message_add_payload() (i.e. we must not free() it), and
		 * it is possible for the next iteration of the aca loop
		 * to fail early in cert_obtain before it writes to &cert.
		 */
		cert = NULL;
	}

	/* We dont need the CERT REQs any more, they are answered.  */
	exchange_free_aca_list(exchange);

	return 0;
}

static void
exchange_establish_finalize(struct exchange *exchange, void *arg, int fail)
{
	char	*name = arg;

	LOG_DBG((LOG_EXCHANGE, 20, "exchange_establish_finalize: "
	    "finalizing exchange %p with arg %p (%s) & fail = %d",
	    exchange, arg, name ? name : "<unnamed>", fail));

	if (!fail)
		exchange_establish(name, 0, 0, 0);
	free(name);
}

/*
 * Establish an exchange named NAME, and record the FINALIZE function
 * taking ARG as an argument to be run after the exchange is ready.
 */
void
exchange_establish(char *name, void (*finalize)(struct exchange *, void *,
    int), void *arg, int stayalive)
{
	struct transport	*transport;
	struct sa		*isakmp_sa;
	struct exchange		*exchange;
	int	 phase;
	char	*trpt, *peer;

	phase = conf_get_num(name, "Phase", 0);

	if (ui_daemon_passive) {
		LOG_DBG((LOG_EXCHANGE, 40, "exchange_establish:"
		    " returning in passive mode for exchange %s phase %d",
		    name, phase));
		return;
	}

	/*
	 * First of all, never try to establish anything if another exchange
	 * of the same kind is running.
         */
	exchange = exchange_lookup_by_name(name, phase);
	if (exchange) {
		LOG_DBG((LOG_EXCHANGE, 40,
		    "exchange_establish: %s exchange already exists as %p",
		    name, exchange));
		exchange_add_finalization(exchange, finalize, arg);
		return;
	}
	switch (phase) {
	case 1:
		trpt = conf_get_str(name, "Transport");
		if (!trpt) {
			/* Phase 1 transport defaults to "udp".  */
			trpt = ISAKMP_DEFAULT_TRANSPORT;
		}
		transport = transport_create(trpt, name);
		if (!transport) {
			log_print("exchange_establish: transport \"%s\" for "
			    "peer \"%s\" could not be created", trpt, name);
			return;
		}
		exchange_establish_p1(transport, 0, 0, name, 0, finalize, arg,
		    stayalive);
		break;

	case 2:
		peer = conf_get_str(name, "ISAKMP-peer");
		if (!peer) {
			log_print("exchange_establish: No ISAKMP-peer given "
			    "for \"%s\"", name);
			return;
		}
		isakmp_sa = sa_lookup_by_name(peer, 1);
		if (!isakmp_sa) {
			name = strdup(name);
			if (!name) {
				log_error("exchange_establish: "
				    "strdup (\"%s\") failed", name);
				return;
			}
			if (conf_get_num(peer, "Phase", 0) != 1) {
				log_print("exchange_establish: "
				    "[%s]:ISAKMP-peer's (%s) phase is not 1",
				    name, peer);
				free(name);
				return;
			}
			/*
			 * XXX We're losing information here (what the
			 * original finalize routine was. As a result, if an
			 * exchange does not manage to get through, there may
			 * be application-specific information that won't get
			 * cleaned up, since no error signaling will be done.
			 * This is the case with dynamic SAs and PFKEY.
			 */
			exchange_establish(peer, exchange_establish_finalize,
			    name, 0);
			exchange = exchange_lookup_by_name(peer, 1);
			/*
			 * If the exchange was correctly initialized, add the
			 * original finalization routine; otherwise, call it
			 * directly.
			 */
			if (exchange)
				exchange_add_finalization(exchange, finalize,
				    arg);
			else {
				/* Indicate failure */
				if (finalize)
					finalize(0, arg, 1);
				free(name);
			}
			return;
		} else
			exchange_establish_p2(isakmp_sa, 0, name, 0, finalize,
			    arg);
		break;

	default:
		log_print("exchange_establish: "
		    "peer \"%s\" does not have a correct phase (%d)",
		    name, phase);
		break;
	}
}
@


1.137
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.136 2015/04/20 17:22:18 mikeb Exp $	 */
d331 9
@


1.136
log
@Log if we refuse to continue the exchange when another one that corresponds
to the same policy is already active.  OK markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.135 2014/01/23 01:04:28 deraadt Exp $	 */
d1579 1
a1579 2
		if (aca->raw_ca)
			free(aca->raw_ca);
@


1.135
log
@Remove a mid-layer which acts like arc4random isn't fairly standard.
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.134 2011/04/23 03:17:04 lum Exp $	 */
d981 5
a985 1
			if (exchange_lookup_active(name, 1))
d987 1
@


1.134
log
@Indicate which side of the connection responded during phase 1 while using -v.
ok sthen@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.133 2009/01/28 13:24:07 hshoexer Exp $	 */
d911 1
a911 1
	getrandom(exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1523 1
a1523 1
	getrandom(buf + ISAKMP_NONCE_DATA_OFF, nonce_sz);
@


1.133
log
@Remove some dead (#if 0) code.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.132 2007/09/02 23:50:04 deraadt Exp $	 */
d1430 3
a1432 1
		log_verbose("isakmpd: phase 1 done: %s, %s", id_doi, id_trp);
@


1.132
log
@more malloc(n * m) -> calloc(n, m); from Igor Zinovik
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.131 2007/08/05 09:43:09 tom Exp $	 */
a77 3
#if 0
static void     exchange_resize(void);
#endif
a416 20

#if 0
/* XXX Currently unused.  */
static void
exchange_resize(void)
{
	struct exchange_list *new_tab;
	int	new_mask = (bucket_mask + 1) * 2 - 1;
	int	i;

	new_tab = realloc(exchange_tab,
	    (new_mask + 1) * sizeof(struct exchange_list));
	if (!new_tab)
		return;
	for (i = bucket_mask + 1; i <= new_mask; i++)
		LIST_INIT(&new_tab[i]);
	bucket_mask = new_mask;
	/* XXX Rehash existing entries.  */
}
#endif
@


1.131
log
@Allow key exchange with RSA signature authentication to work with
Cisco IOS and other initiators that only send their certs in response
to CERT_REQUEST.

With input and help from cloder@@, Stuart Henderson, mpf@@, and several
others who did lots of testing - thanks to all.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.130 2007/04/16 13:01:39 moritz Exp $	 */
d414 1
a414 2
	exchange_tab = malloc((bucket_mask + 1) *
	    sizeof(struct exchange_list));
@


1.130
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.129 2007/03/03 10:29:18 tom Exp $	 */
d1596 2
d1606 52
@


1.129
log
@Make sure we can't accidentally free() a pointer that's been accepted
by message_add_payload(), since we are no longer responsible for it.

ok cloder@@ hshoexer@@ moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.128 2006/09/01 00:24:06 mpf Exp $	 */
d1208 5
a1212 10
	if (exchange->nonce_i)
		free(exchange->nonce_i);
	if (exchange->nonce_r)
		free(exchange->nonce_r);
	if (exchange->id_i)
		free(exchange->id_i);
	if (exchange->id_r)
		free(exchange->id_r);
	if (exchange->keystate)
		free(exchange->keystate);
d1215 2
a1216 4
	if (exchange->data)
		free(exchange->data);
	if (exchange->name)
		free(exchange->name);
d1230 1
a1230 2
	if (exchange->keynote_key)
		free(exchange->keynote_key);	/* This is just a string */
d1637 1
a1637 2
			if (cert)
				free(cert);
d1644 1
a1644 2
			if (cert)
				free(cert);
@


1.128
log
@Add a new UI command to force isakmpd into passive only mode.
Will be used by sasyncd to prevent two talking isakmpd's in an HA setup.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.127 2006/06/02 19:35:55 hshoexer Exp $	 */
d1665 7
@


1.127
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.126 2006/05/31 04:54:46 hshoexer Exp $	 */
d61 1
d1702 7
@


1.126
log
@Make sure, that phase 1 SAs of active connections stay alive.  Fixes a DPD
breakage noticed and reported by Mitja Muzenic.

ok markus@@ ho@@, testing by Mitja and cloder@@, discussed with Nathanael.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.125 2005/11/16 18:35:32 cloder Exp $	 */
d192 1
a192 1
 * requires at this point in the dialogoue.  Return -1 if the validation fails,
d1758 1
a1758 1
			 * cleaned up, since no error signalling will be done.
@


1.125
log
@Avoid printing a NULL string. ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.124 2005/10/26 20:10:49 markus Exp $	 */
d723 1
a723 1
    void *arg)
d851 3
d1682 1
a1682 1
		exchange_establish(name, 0, 0);
d1692 1
a1692 1
    int), void *arg)
d1727 2
a1728 1
		exchange_establish_p1(transport, 0, 0, name, 0, finalize, arg);
d1762 1
a1762 1
			    name);
@


1.124
log
@don't send DPD messages before the exchange is finialized, otherwise
we have a race between DPD and exchange timeouts and both will release
the SA and corrupt the SA list. ok hshoexer@@, ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.123 2005/07/05 11:57:03 hshoexer Exp $	 */
d1018 1
a1018 1
		if (!str || strcasecmp(str, "IPSEC") == 0)
d1020 2
@


1.123
log
@use correct function name in log message, tiny KNF
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.122 2005/06/25 23:20:43 hshoexer Exp $	 */
d63 1
d1481 8
@


1.122
log
@/* Fallthrough. */ -> /* FALLTHROUGH */
now that's useable with lint
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.121 2005/05/26 06:11:09 hshoexer Exp $	 */
d253 2
a254 1
				    "exchange_run: unexpected payload %s",
d273 1
a273 1
	    doi->initiator : doi->responder;
@


1.121
log
@Use TAILQ_FOREACH where possible, remove payload_last()

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.120 2005/05/26 05:14:17 hshoexer Exp $	 */
d328 1
a328 1
				/* Fallthrough.  */
@


1.120
log
@get rid of payload mapping

ok markus ho cloder
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.119 2005/04/08 22:32:09 cloder Exp $	 */
d247 1
a247 2
		for (p = payload_first(msg, i); p;
		    p = TAILQ_NEXT(p, link)) {
d1564 1
a1564 1
	struct payload	*cp = payload_first(msg, ISAKMP_PAYLOAD_CERT_REQ);
d1568 1
a1568 1
	for (; cp; cp = TAILQ_NEXT(cp, link)) {
@


1.119
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.118 2005/04/08 19:40:02 deraadt Exp $	 */
d243 1
a243 1
	for (i = ISAKMP_PAYLOAD_SA; i < payload_index_max; i++) {
@


1.118
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.117 2005/04/08 18:47:19 hshoexer Exp $	 */
a41 2

#include "sysdep.h"
@


1.117
log
@missing includes
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.116 2005/04/08 18:41:58 hshoexer Exp $	 */
a75 1
#ifdef USE_DEBUG
a76 1
#endif
a824 1
#ifdef USE_DEBUG
a825 1
#endif
a938 1
#ifdef USE_DEBUG
a939 1
#endif
a1097 1
#ifdef USE_DEBUG
a1098 1
#endif
a1120 1
#ifdef USE_DEBUG
a1121 1
#endif
a1161 1
#ifdef USE_DEBUG
a1166 1
#endif
a1325 1
#ifdef USE_DEBUG
a1326 1
#endif
@


1.116
log
@remove leftovers
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.115 2005/04/08 16:52:41 deraadt Exp $	 */
d40 2
@


1.115
log
@always enable aggressive, dpd, and isakmp_cfg
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.114 2005/04/08 16:37:14 deraadt Exp $	 */
a1244 1
#if defined (POLICY) || defined (KEYNOTE)
a1246 1
#endif
@


1.114
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.113 2005/04/06 16:00:20 deraadt Exp $	 */
a52 1
#ifdef USE_ISAKMP_CFG
a53 1
#endif
a142 1
#ifdef USE_AGGRESSIVE
a157 1
#endif				/* USE_AGGRESSIVE */
a177 1
#ifdef USE_AGGRESSIVE
a179 1
#endif
a181 1
#ifdef USE_ISAKMP_CFG
a183 1
#endif
a704 1
#ifdef USE_ISAKMP_CFG
a718 1
#endif				/* USE_ISAKMP_CFG */
a727 1
#ifdef USE_ISAKMP_CFG
a729 1
#endif
a792 1
#ifdef USE_ISAKMP_CFG
a820 1
#endif				/* USE_ISAKMP_CFG */
a976 1
#ifdef USE_ISAKMP_CFG
a978 1
#endif
a1069 1
#ifdef USE_ISAKMP_CFG
a1096 1
#endif
@


1.113
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.112 2005/04/04 19:31:11 deraadt Exp $	 */
a949 1
#if defined (USE_NAT_TRAVERSAL)
a953 1
#endif
a1139 1
#if defined (USE_NAT_TRAVERSAL)
a1143 1
#endif
a1479 1
#if defined (USE_NAT_TRAVERSAL)
a1483 1
#endif
@


1.112
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.111 2005/03/10 17:19:08 cloder Exp $	 */
d193 1
a193 5
		if (exchange->type >= ISAKMP_EXCH_DOI_MIN
#if 0 /* always true; silence GCC3 warning */
		    && exchange->type <= ISAKMP_EXCH_DOI_MAX
#endif
		    )
d218 9
a226 9
		if ((*pc > 0 && !payload_first(msg, *pc))
		    || (*pc == EXCHANGE_SCRIPT_AUTH
		    && !payload_first(msg, ISAKMP_PAYLOAD_HASH)
		    && !payload_first(msg, ISAKMP_PAYLOAD_SIG))
		    || (*pc == EXCHANGE_SCRIPT_INFO
		    && ((!payload_first(msg, ISAKMP_PAYLOAD_NOTIFY)
		    && !payload_first(msg, ISAKMP_PAYLOAD_DELETE))
		    || (payload_first(msg, ISAKMP_PAYLOAD_DELETE)
		    && !payload_first(msg, ISAKMP_PAYLOAD_HASH))))) {
d409 2
a410 2
		while (*exchange->exch_pc != EXCHANGE_SCRIPT_SWITCH
		    && *exchange->exch_pc != EXCHANGE_SCRIPT_END)
d852 2
a853 2
	if (exchange->type != ISAKMP_EXCH_INFO
	    && exchange->type != ISAKMP_EXCH_TRANSACTION) {
@


1.111
log
@Avoid crash on finalization.  We have been using this diff
in production since mid-2003.  OK hshoexer@@, markus@@, ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.110 2005/03/05 12:25:12 ho Exp $	 */
d193 1
a193 1
		if (exchange->type >= ISAKMP_EXCH_DOI_MIN 
d262 1
a262 1
		     p = TAILQ_NEXT(p, link)) {
d292 3
a294 3
	         * It's our turn if we're either the initiator on an even step,
	         * or the responder on an odd step of the dialogue.
	         */
d311 1
a311 1
			         */
d326 1
a326 1
			         */
d339 1
a339 1
			         */
d365 1
a365 1
				         * Trust the peer to retransmit.
d368 1
a368 1
				         */
d375 1
a375 1
			         */
d383 1
a383 1
			         */
d463 1
a463 1
		     exchange = LIST_NEXT(exchange, link))
d484 1
a484 1
		     exchange = LIST_NEXT(exchange, link)) {
d599 1
a599 1
	     exchange = LIST_NEXT(exchange, link))
d862 1
a862 1
	         */
d1014 2
a1015 2
	         * Find out our inbound phase 1 mode.
	         */
d1027 1
a1027 1
		         */
d1095 1
a1095 1
		     flag = TAILQ_NEXT(flag, link))
d1542 1
a1542 1
		 * RFC2409, ch 5: The length of nonce payload MUST be 
d1789 1
a1789 1
		         */
d1797 1
a1797 1
		         */
@


1.110
log
@Silence a couple of annoying gcc3 warnings. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.109 2005/03/04 13:33:32 markus Exp $	 */
d1802 3
a1804 1
				finalize(0, arg, 1);	/* Indicate failure */
@


1.109
log
@fix leak when a phase 2 SA cannot create an exchange for the matching phase 1
ok ho@@, hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.108 2005/03/02 13:27:12 hshoexer Exp $	 */
d193 5
a197 2
		if (exchange->type >= ISAKMP_EXCH_DOI_MIN &&
		    exchange->type <= ISAKMP_EXCH_DOI_MAX)
@


1.108
log
@correct function name in log message
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.107 2005/02/27 13:12:12 hshoexer Exp $	 */
d1776 1
d1798 1
a1798 1
			else
d1800 2
@


1.107
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.106 2005/01/31 10:30:49 hshoexer Exp $	 */
d453 1
a453 1
exchange_lookup_from_icookie(u_int8_t * cookie)
d782 1
a782 1
				log_print("exchange_setup_p1: "
@


1.106
log
@Avoid dereferencing a NULL pointer

ok msf
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.105 2004/12/06 12:28:21 ho Exp $	 */
d629 2
a630 2
	memset(exchange->cookies, 0, ISAKMP_HDR_COOKIES_LEN);
	memset(exchange->message_id, 0, ISAKMP_HDR_MESSAGE_ID_LEN);
@


1.105
log
@RFC2409 mandates min and max nonce lengths. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.104 2004/09/17 13:53:08 ho Exp $	 */
d1144 1
a1144 1
	if (msg->isakmp_sa->flags & SA_FLAG_NAT_T_ENABLE)
d1146 1
a1146 1
	if (msg->isakmp_sa->flags & SA_FLAG_NAT_T_KEEPALIVE)
@


1.104
log
@Missing #ifdefs.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.103 2004/08/23 11:53:24 ho Exp $	 */
d1536 12
@


1.103
log
@We need to set sa->initiator before checking if the newly created SA
replaces an old one, or the id_i/id_r check will mismatch. Previous
behaviour was mostly harmless, but wasted some resources (until normal
SA expiration). hshoexer@@ "haven't tried, but think it's ok"
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.102 2004/08/10 15:59:10 ho Exp $	 */
d76 1
d78 1
d1193 1
d1199 1
@


1.103.2.1
log
@MFC:
Fix by cloder@@

Avoid crash on finalization.  We have been using this diff
in production since mid-2003.

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.103 2004/08/23 11:53:24 ho Exp $	 */
d1781 1
a1781 1
			else if (finalize)
@


1.102
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.101 2004/08/08 19:11:06 deraadt Exp $	 */
d1402 1
@


1.101
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.100 2004/07/09 16:06:48 deraadt Exp $	 */
a49 3
#ifdef USE_DPD
#include "dpd.h"
#endif
a189 4
#ifdef USE_DPD
	case ISAKMP_EXCH_DPD:
		return script_dpd;
#endif
d850 1
a850 1
	/* Do not create SA for an information, transaction or DPD exchange. */
d852 1
a852 2
	    && exchange->type != ISAKMP_EXCH_TRANSACTION
	    && exchange->type != ISAKMP_EXCH_DPD) {
d965 1
a965 2
	    exchange->type != ISAKMP_EXCH_TRANSACTION &&
	    exchange->type != ISAKMP_EXCH_DPD) {
@


1.100
log
@ansi
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.99 2004/06/21 13:09:00 ho Exp $	 */
d817 1
a817 1
				
d1078 1
a1078 1
			    "expected exchange type %s got %s", str, 
d1102 1
a1102 1
				
d1155 1
a1155 1
#endif	
d1227 1
a1227 1
	struct exchange 	*exchange = v_exch;
d1494 1
a1494 1
#endif		
@


1.99
log
@Port floating (500->4500) for p1 and p2 exchanges.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.98 2004/06/20 17:17:34 ho Exp $	 */
d423 1
a423 1
exchange_init()
@


1.98
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.97 2004/06/20 15:20:06 ho Exp $	 */
d957 6
d1150 6
d1483 1
a1483 1
		if (msg->isakmp_sa && msg->isakmp_sa->transport)
d1488 7
@


1.97
log
@A start towards Dead Peer Detection (DPD) support, as specified in RFC 3706
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.96 2004/06/14 09:55:41 ho Exp $	 */
d224 1
a224 1
		if ((*pc > 0 && !TAILQ_FIRST(&msg->payload[*pc]))
d226 2
a227 2
		    && !TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH])
		    && !TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SIG]))
d229 4
a232 4
		    && ((!TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_NOTIFY])
		    && !TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_DELETE]))
		    || (TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_DELETE])
		    && !TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]))))) {
d259 1
a259 1
	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++) {
d263 1
a263 1
		for (p = TAILQ_FIRST(&msg->payload[i]); p;
d1569 1
a1569 1
	noncep = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_NONCE]);
d1579 1
a1579 2
	struct payload	*cp =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_CERT_REQ]);
@


1.96
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.95 2004/06/09 14:02:44 ho Exp $	 */
d50 3
d193 4
d857 1
a857 1
	/* Do not create SA for an information or transaction exchange.  */
d859 2
a860 1
	    && exchange->type != ISAKMP_EXCH_TRANSACTION) {
d966 3
a968 2
	if (exchange->type != ISAKMP_EXCH_INFO
	    && exchange->type != ISAKMP_EXCH_TRANSACTION) {
@


1.95
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.94 2004/05/06 10:40:34 ho Exp $	 */
d1160 2
a1161 1
	    decode_32(exchange->cookies + 8), decode_32(exchange->cookies + 12)));
@


1.94
log
@KNF cleanup. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.93 2004/05/03 21:23:51 hshoexer Exp $	 */
d204 1
a204 1
exchange_validate(struct message * msg)
d1606 1
a1606 1
exchange_add_certs(struct message * msg)
@


1.93
log
@KNF.  ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: exchange.c,v 1.92 2004/03/31 10:54:46 ho Exp $	 */
a77 1
static struct exchange *exchange_lookup_active(char *, int);
d81 1
d83 1
a83 1
static 
d94 15
a108 15
		ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
		ISAKMP_PAYLOAD_NONCE,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
		ISAKMP_PAYLOAD_NONCE,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_KEY_EXCH,	/* Initiator -> responder.  */
		ISAKMP_PAYLOAD_ID,
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_KEY_EXCH,	/* Responder -> initiator.  */
		ISAKMP_PAYLOAD_ID,
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_END
	};
d111 17
a127 17
		ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_KEY_EXCH,	/* Initiator -> responder.  */
		ISAKMP_PAYLOAD_NONCE,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_KEY_EXCH,	/* Responder -> initiator.  */
		ISAKMP_PAYLOAD_NONCE,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_ID,	/* Initiator -> responder.  */
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_ID,	/* Responder -> initiator.  */
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_END
	};
d130 12
a141 12
		ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
		ISAKMP_PAYLOAD_NONCE,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
		ISAKMP_PAYLOAD_NONCE,
		ISAKMP_PAYLOAD_ID,
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_ID,	/* Initiator -> responder.  */
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_END
	};
d145 14
a158 14
		ISAKMP_PAYLOAD_SA,	/* Initiator -> responder.  */
		ISAKMP_PAYLOAD_KEY_EXCH,
		ISAKMP_PAYLOAD_NONCE,
		ISAKMP_PAYLOAD_ID,
		EXCHANGE_SCRIPT_SWITCH,
		ISAKMP_PAYLOAD_SA,	/* Responder -> initiator.  */
		ISAKMP_PAYLOAD_KEY_EXCH,
		ISAKMP_PAYLOAD_NONCE,
		ISAKMP_PAYLOAD_ID,
		EXCHANGE_SCRIPT_AUTH,
		EXCHANGE_SCRIPT_SWITCH,
		EXCHANGE_SCRIPT_AUTH,	/* Initiator -> responder.  */
		EXCHANGE_SCRIPT_END
	};
d162 3
a164 3
		EXCHANGE_SCRIPT_INFO,	/* Initiator -> responder.  */
		EXCHANGE_SCRIPT_END
	};
d191 2
a192 2
		if (exchange->type >= ISAKMP_EXCH_DOI_MIN
		    && exchange->type <= ISAKMP_EXCH_DOI_MAX)
d207 1
a207 1
	int16_t        *pc = exchange->exch_pc;
d243 26
a278 1
	int             i, done = 0;
d280 1
a280 1
	struct doi     *doi = exchange->doi;
d282 2
a283 2
			    doi->initiator : doi->responder;
	struct payload *payload;
d335 2
a336 1
				message_register_post_send(msg, exchange_finalize);
d346 2
a347 1
				log_print("exchange_run: exchange_validate failed, DOI error");
d371 1
a371 17
				for (i = ISAKMP_PAYLOAD_SA; i <
				    ISAKMP_PAYLOAD_RESERVED_MIN; i++) {
					if (i != ISAKMP_PAYLOAD_PROPOSAL
					    && i != ISAKMP_PAYLOAD_TRANSFORM) {
						for (payload = TAILQ_FIRST(&msg->payload[i]); payload;
						     payload = TAILQ_NEXT(payload, link)) {
							if ((payload->flags & PL_MARK) == 0) {
								if (!doi->handle_leftover_payload
								    || doi->handle_leftover_payload(msg, i, payload)) {
									LOG_DBG((LOG_EXCHANGE, 10,
										 "exchange_run: unexpected payload %s",
										 constant_name(isakmp_payload_cst, i)));
								}
							}
						}
					}
				}
d392 2
a393 1
				log_print("exchange_run: exchange_validate failed");
d398 2
a399 1
				message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
d418 1
a418 1
	int             i;
d421 2
a422 1
	exchange_tab = malloc((bucket_mask + 1) * sizeof(struct exchange_list));
d425 1
a425 1
	for (i = 0; i <= bucket_mask; i++) {
a426 2
	}

a433 2
	int             new_mask = (bucket_mask + 1) * 2 - 1;
	int             i;
d435 2
d438 2
a439 1
	new_tab = realloc(exchange_tab, (new_mask + 1) * sizeof(struct exchange_list));
d442 1
a442 1
	for (i = bucket_mask + 1; i <= new_mask; i++) {
a443 1
	}
a452 1
	int             i;
d454 1
d458 1
a458 1
		    exchange = LIST_NEXT(exchange, link))
d460 2
a461 2
			    ISAKMP_HDR_ICOOKIE_LEN) == 0
			    && exchange->phase == 1)
a469 1
	int             i;
d471 1
d489 5
a493 4
			if (exchange->name && strcasecmp(exchange->name, name) == 0
			    && exchange->phase == phase
			    && (!exchange->last_sent
			    || (exchange->last_sent->flags & MSG_LAST) == 0))
a502 1
	int             i;
d504 1
d518 3
a520 2
			if (exchange->name && strcasecmp(exchange->name, name) == 0
			    && exchange->phase == phase) {
d525 3
a527 2
					    "exchange_lookup_active: avoided early (pre-step 1) "
					    "exchange %p", exchange));
d536 2
a537 1
	u_int16_t       bucket = 0;
a538 1
	u_int8_t       *cp;
d563 1
d565 1
a566 2
	struct exchange *exchange;
	u_int8_t       *cp;
d569 5
a573 5
         * We use the cookies to get bits to use as an index into exchange_tab, as at
         * least one (our cookie) is a good hash, xoring all the bits, 16 at a
         * time, and then masking, should do.  Doing it this way means we can
         * validate cookies very fast thus delimiting the effects of "Denial of
         * service"-attacks using packet flooding.
d588 7
a594 7
	    exchange && (memcmp(msg + ISAKMP_HDR_COOKIES_OFF, exchange->cookies,
	    ISAKMP_HDR_COOKIES_LEN) != 0
	    || (phase2 && memcmp(msg + ISAKMP_HDR_MESSAGE_ID_OFF,
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN) != 0)
	    || (!phase2 && !zero_test(msg + ISAKMP_HDR_MESSAGE_ID_OFF,
	    ISAKMP_HDR_MESSAGE_ID_LEN)));
	    exchange = LIST_NEXT(exchange, link))
d611 2
a612 2
	struct timeval  expiration;
	int             delta;
d648 2
a649 1
	delta = conf_get_num("General", "Exchange-max-time", EXCHANGE_MAX_TIME);
d651 2
a652 2
	exchange->death = timer_add_event("exchange_free_aux", exchange_free_aux,
	    exchange, &expiration);
d662 4
a665 4
	void            (*first)(struct exchange *, void *, int);
	void           *first_arg;
	void            (*second)(struct exchange *, void *, int);
	void           *second_arg;
d735 2
a736 2
	struct exchange *exchange;
	struct message *msg;
d738 2
a739 2
	struct conf_list *flags;
	struct conf_list_node *flag;
d741 2
a742 2
	char           *tag = 0;
	char           *str;
d765 2
a766 2
				log_print("exchange_establish_p1: DOI \"%s\" unsupported",
				    str);
d780 2
a781 2
				log_print("exchange_setup_p1: unknown exchange type %s",
				    str);
d794 2
a795 1
			log_error("exchange_establish_p1: strdup (\"%s\") failed", name);
d805 13
a817 26
	if (name) {
		flags = conf_get_list(name, "Flags");
		if (flags) {
			for (flag = TAILQ_FIRST(&flags->fields); flag;
			    flag = TAILQ_NEXT(flag, link))
				if (strcasecmp(flag->field, "ikecfg") == 0) {
					struct exchange_finalization_node *node;

					node = calloc(1, (unsigned long)sizeof *node);
					if (!node) {
						log_print("exchange_establish_p1: calloc (1, %lu) failed",
						    (unsigned long)sizeof(*node));
						exchange_free(exchange);
						return;
					}
					/*
					 * Insert this finalization inbetween
					 * the original.
					 */
					node->first = finalize;
					node->first_arg = arg;
					node->second_arg = name;
					exchange_add_finalization(exchange,
					    exchange_establish_transaction,
					    node);
					finalize = 0;
d819 13
a831 2
			conf_free_list(flags);
		}
d879 5
a883 5
	struct message *msg;
	int             i;
	char           *tag, *str;
	u_int32_t       doi = ISAKMP_DOI_ISAKMP;
	u_int32_t       seq = 0;
d892 2
a893 2
			log_print("exchange_establish_p2: no configuration for peer \"%s\"",
			    name);
d905 2
a906 1
			log_print("exchange_establish_p2: DOI \"%s\" unsupported", str);
d936 2
a937 1
			log_error("exchange_establish_p2: strdup (\"%s\") failed", name);
d973 1
a973 1
	/* This needs to be done late or else get_keystate won't work right.  */
d983 3
a985 3
	struct transport *t = msg->transport;
	struct exchange *exchange;
	struct sockaddr *dst;
d987 2
a988 2
	struct conf_list *flags;
	struct conf_list_node *flag;
d990 3
a992 3
	char           *name = 0, *policy = 0, *str;
	u_int32_t       want_doi;
	u_int8_t        type;
d1039 2
a1040 1
			log_print("exchange_setup_p1: DOI \"%s\" unsupported", str);
d1057 2
a1058 2
			log_print("exchange_setup_p1: unknown exchange type %s",
			    str);
d1062 4
a1065 3
			log_print("exchange_setup_p1: expected exchange type %s got %s",
			    str, constant_name(isakmp_exch_cst,
			    GET_ISAKMP_HDR_EXCH_TYPE(msg->iov[0].iov_base)));
d1082 13
a1094 25
	if (name) {
		flags = conf_get_list(name, "Flags");
		if (flags) {
			for (flag = TAILQ_FIRST(&flags->fields); flag;
			    flag = TAILQ_NEXT(flag, link))
				if (strcasecmp(flag->field, "ikecfg") == 0) {
					struct exchange_finalization_node *node;

					node = calloc(1, (unsigned long)sizeof *node);
					if (!node) {
						log_print("exchange_establish_p1: calloc (1, %lu) failed",
						    (unsigned long)sizeof(*node));
						exchange_free(exchange);
						return 0;
					}
					/*
					 * Insert this finalization inbetween
					 * the original.
					 */
					node->first = 0;
					node->first_arg = 0;
					node->second_arg = name;
					exchange_add_finalization(exchange,
					    exchange_establish_transaction,
					    node);
d1096 12
a1107 2
			conf_free_list(flags);
		}
d1126 1
a1126 1
	u_int8_t       *buf = msg->iov[0].iov_base;
d1132 2
a1133 1
	GET_ISAKMP_HDR_RCOOKIE(buf, exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN);
d1147 2
a1148 1
	char            buf[LOG_SIZE];
d1150 1
a1150 2
	size_t          bufsize_max = LOG_SIZE - strlen(header) - 32;
	struct sa      *sa;
d1167 2
a1168 1
			snprintf(buf + strlen(buf), bufsize_max - strlen(buf), "%p ", sa);
d1187 2
a1188 2
	int             i;
	struct exchange *exchange;
d1193 2
a1194 1
			exchange_dump_real("exchange_report", exchange, LOG_REPORT, 0);
d1205 3
a1207 3
	struct exchange *exchange = v_exch;
	struct sa      *sa, *next_sa;
	struct cert_handler *handler;
d1216 2
a1217 1
	if (exchange->in_transit && exchange->in_transit != exchange->last_sent)
d1303 2
a1304 2
	struct sa      *new_sa = v_arg;
	char            res1[1024];
d1335 8
a1342 8
	struct exchange *exchange = msg->exchange;
	struct sa      *sa, *old_sa;
	struct proto   *proto;
	struct conf_list *attrs;
	struct conf_list_node *attr;
	struct cert_handler *handler;
	int             i;
	char           *id_doi, *id_trp;
d1351 6
a1356 4
			ipsec_clone_id(&msg->isakmp_sa->id_i, &msg->isakmp_sa->id_i_len,
			    exchange->id_i, exchange->id_i_len);
			ipsec_clone_id(&msg->isakmp_sa->id_r, &msg->isakmp_sa->id_r_len,
			    exchange->id_r, exchange->id_r_len);
d1371 2
a1372 1
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa; sa = TAILQ_NEXT(sa, next)) {
d1411 2
a1412 1
					msg->isakmp_sa->flags |= SA_FLAG_STAYALIVE;
d1462 2
a1463 1
			id_trp = msg->isakmp_sa->transport->vtbl->decode_ids(msg->isakmp_sa->transport);
d1468 2
a1469 1
		    "exchange_finalize: phase 1 done: %s, %s", id_doi, id_trp));
d1488 4
a1491 4
			ipsec_clone_id(&sa->id_i, &sa->id_i_len, exchange->id_i,
			    exchange->id_i_len);
			ipsec_clone_id(&sa->id_r, &sa->id_r_len, exchange->id_r,
			    exchange->id_r_len);
a1506 1
	int             initiator = exchange->initiator ^ peer;
d1509 1
d1513 2
a1514 1
	nonce_len = initiator ? &exchange->nonce_i_len : &exchange->nonce_r_len;
d1534 1
a1534 1
	u_int8_t       *buf;
d1548 2
a1549 1
	return exchange_nonce(exchange, 0, nonce_sz, buf + ISAKMP_NONCE_DATA_OFF);
d1556 1
a1556 1
	struct payload *noncep;
d1569 3
a1571 2
	struct payload *cp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_CERT_REQ]);
	struct exchange *exchange = msg->exchange;
d1622 2
a1623 1
         *       with some IPsec clients that send CERTREQs early (ex SSH Sentinel).
d1630 3
a1632 2
		/* XXX? If we can not satisfy a CERTREQ we drop the message.  */
		if (!aca->handler->cert_obtain(id, id_len, aca->data, &cert, &certlen)) {
d1641 2
a1642 2
			log_error("exchange_add_certs: realloc (%p, %d) failed",
			    cert, ISAKMP_CERT_SZ + certlen);
d1666 1
a1666 1
	char           *name = arg;
d1685 6
a1690 6
	int             phase;
	char           *trpt;
	struct transport *transport;
	char           *peer;
	struct sa      *isakmp_sa;
	struct exchange *exchange;
d1700 2
a1701 2
		"exchange_establish: %s exchange already exists as %p", name,
		    exchange));
d1714 2
a1715 3
			log_print("exchange_establish: "
			    "transport \"%s\" for peer \"%s\" could not be created",
			    trpt, name);
d1724 2
a1725 2
			log_print("exchange_establish: No ISAKMP-peer given for \"%s\"",
			    name);
d1732 2
a1733 2
				log_error("exchange_establish: strdup (\"%s\") failed",
				    name);
d1750 2
a1751 1
			exchange_establish(peer, exchange_establish_finalize, name);
d1759 2
a1760 1
				exchange_add_finalization(exchange, finalize, arg);
d1765 2
a1766 1
			exchange_establish_p2(isakmp_sa, 0, name, 0, finalize, arg);
@


1.92
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.91 2004/02/16 20:40:34 markus Exp $	*/
/*	$EOM: exchange.c,v 1.143 2000/12/04 00:02:25 angelos Exp $	*/
d76 3
a78 3
static void exchange_dump (char *, struct exchange *);
static void exchange_free_aux (void *);
static struct exchange *exchange_lookup_active (char *, int);
d80 1
a80 1
static void exchange_resize (void);
d83 2
a84 1
static LIST_HEAD (exchange_list, exchange) *exchange_tab;
d87 1
a87 1
static int bucket_mask;
d94 15
a108 15
  ISAKMP_PAYLOAD_SA,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_SA,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_KEY_EXCH,	/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_ID,
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_KEY_EXCH,	/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_ID,
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_END
};
d111 17
a127 17
  ISAKMP_PAYLOAD_SA,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_SA,		/* Responder -> initiator.  */
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_KEY_EXCH,	/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_KEY_EXCH,	/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_ID,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_ID,		/* Responder -> initiator.  */
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_END
};
d130 12
a141 12
  ISAKMP_PAYLOAD_SA,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_SA,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_NONCE,
  ISAKMP_PAYLOAD_ID,
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_ID,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_END
};
d145 15
a159 15
  ISAKMP_PAYLOAD_SA,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_KEY_EXCH,
  ISAKMP_PAYLOAD_NONCE,
  ISAKMP_PAYLOAD_ID,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_SA,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_KEY_EXCH,
  ISAKMP_PAYLOAD_NONCE,
  ISAKMP_PAYLOAD_ID,
  EXCHANGE_SCRIPT_AUTH,
  EXCHANGE_SCRIPT_SWITCH,
  EXCHANGE_SCRIPT_AUTH,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_END
};
#endif /* USE_AGGRESSIVE */
d162 3
a164 3
  EXCHANGE_SCRIPT_INFO,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_END
};
d171 1
a171 1
exchange_script (struct exchange *exchange)
d173 7
a179 8
  switch (exchange->type)
    {
    case ISAKMP_EXCH_BASE:
      return script_base;
    case ISAKMP_EXCH_ID_PROT:
      return script_identity_protection;
    case ISAKMP_EXCH_AUTH_ONLY:
      return script_authentication_only;
d181 2
a182 2
    case ISAKMP_EXCH_AGGRESSIVE:
      return script_aggressive;
d184 2
a185 2
    case ISAKMP_EXCH_INFO:
      return script_informational;
d187 2
a188 2
    case ISAKMP_EXCH_TRANSACTION:
      return script_transaction;
d190 6
a195 6
    default:
      if (exchange->type >= ISAKMP_EXCH_DOI_MIN
	  && exchange->type <= ISAKMP_EXCH_DOI_MAX)
	return exchange->doi->exchange_script (exchange->type);
    }
  return 0;
d204 1
a204 1
exchange_validate (struct message *msg)
d206 2
a207 2
  struct exchange *exchange = msg->exchange;
  int16_t *pc = exchange->exch_pc;
d209 3
a211 22
  while (*pc != EXCHANGE_SCRIPT_END && *pc != EXCHANGE_SCRIPT_SWITCH)
    {
      LOG_DBG ((LOG_EXCHANGE, 90,
		"exchange_validate: checking for required %s",
		*pc >= ISAKMP_PAYLOAD_NONE
		? constant_name (isakmp_payload_cst, *pc)
		: constant_name (exchange_script_cst, *pc)));

      /* Check for existence of the required payloads.  */
      if ((*pc > 0 && !TAILQ_FIRST (&msg->payload[*pc]))
	  || (*pc == EXCHANGE_SCRIPT_AUTH
	      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH])
	      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SIG]))
	  || (*pc == EXCHANGE_SCRIPT_INFO
	      && ((!TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NOTIFY])
		   && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE]))
	          || (TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])
		      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH])))))
	{
	  /* Missing payload.  */
	  LOG_DBG ((LOG_MESSAGE, 70,
		    "exchange_validate: msg %p requires missing %s", msg,
d213 2
a214 9
		    ? constant_name (isakmp_payload_cst, *pc)
		    : constant_name (exchange_script_cst, *pc)));
	  return -1;
	}
      pc++;
    }
  if (*pc == EXCHANGE_SCRIPT_END)
    /* Cleanup.  */
    return 1;
d216 25
a240 1
  return 0;
d251 1
a251 1
exchange_run (struct message *msg)
d253 147
a399 143
  int i, done = 0;
  struct exchange *exchange = msg->exchange;
  struct doi *doi = exchange->doi;
  int (*handler) (struct message *)
    = exchange->initiator ? doi->initiator : doi->responder;
  struct payload *payload;

  while (!done)
    {
      /*
       * It's our turn if we're either the initiator on an even step,
       * or the responder on an odd step of the dialogue.
       */
      if (exchange->initiator ^ (exchange->step % 2))
	{
	  done = 1;
	  if (exchange->step)
	    msg = message_alloc_reply (msg);
	  message_setup_header (msg, exchange->type, 0, exchange->message_id);
	  if (handler (msg))
	    {
	      /*
	       * This can happen when transient starvation of memory occurs.
	       * XXX The peer's retransmit ought to kick-start this exchange
	       * again.  If he's stopped retransmitting he's likely dropped
	       * the SA at his side so we need to do that too, i.e.
	       * implement automatic SA teardown after a certain amount
	       * of inactivity.
	       */
	      log_print ("exchange_run: doi->%s (%p) failed",
			 exchange->initiator ? "initiator" : "responder", msg);
	      message_free (msg);
	      return;
	    }

	  switch (exchange_validate (msg))
	    {
	    case 1:
	      /*
	       * The last message of a multi-message exchange should
	       * not be retransmitted other than "on-demand", i.e. if we
	       * see retransmits of the last message of the peer
	       * later.
	       */
	      msg->flags |= MSG_LAST;
	      if (exchange->step > 0)
		{
		  if (exchange->last_sent)
		    message_free (exchange->last_sent);
		  exchange->last_sent = msg;
		}

	      /*
	       * After we physically have sent our last message we need to
	       * do SA-specific finalization, like telling our application
	       * the SA is ready to be used, or issuing a CONNECTED notify
	       * if we set the COMMIT bit.
	       */
	      message_register_post_send (msg, exchange_finalize);

	      /* Fallthrough.  */

	    case 0:
	      /* XXX error handling.  */
	      message_send (msg);
	      break;

	    default:
	      log_print ("exchange_run: exchange_validate failed, DOI error");
	      exchange_free (exchange);
	      message_free (msg);
	      return;
	    }
	}
      else
	{
	  done = exchange_validate (msg);
	  switch (done)
	    {
	    case 0:
	    case 1:
	      /* Feed the message to the DOI.  */
	      if (handler (msg))
		{
		  /*
		   * Trust the peer to retransmit.
		   * XXX We have to implement SA aging with automatic teardown.
		   */
		  message_free (msg);
		  return;
		}

	      /*
	       * Go over the yet unhandled payloads and feed them to DOI
	       * for handling.
	       */
	      for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
		if (i != ISAKMP_PAYLOAD_PROPOSAL
		    && i != ISAKMP_PAYLOAD_TRANSFORM)
		  for (payload = TAILQ_FIRST (&msg->payload[i]); payload;
		       payload = TAILQ_NEXT (payload, link))
		    if ((payload->flags & PL_MARK) == 0)
		      if (!doi->handle_leftover_payload
			  || doi->handle_leftover_payload (msg, i, payload))
			LOG_DBG ((LOG_EXCHANGE, 10,
				  "exchange_run: unexpected payload %s",
				  constant_name (isakmp_payload_cst, i)));

	      /*
	       * We have advanced the state.  If we have been processing an
	       * incoming message, record that message as the one to do
	       * duplication tests against.
	       */
	      if (exchange->last_received)
		message_free (exchange->last_received);
	      exchange->last_received = msg;
	      if (exchange->flags & EXCHANGE_FLAG_ENCRYPT)
		crypto_update_iv (exchange->keystate);

	      if (done)
		{
		  exchange_finalize (msg);
		  return;
		}
	      break;

	    case -1:
	      log_print ("exchange_run: exchange_validate failed");
	      /* XXX Is this the best error notification type?  */
	      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	      return;
	    }
	}

      LOG_DBG ((LOG_EXCHANGE, 40,
		"exchange_run: exchange %p finished step %d, advancing...",
		exchange, exchange->step));
      exchange->step++;
      while (*exchange->exch_pc != EXCHANGE_SCRIPT_SWITCH
	     && *exchange->exch_pc != EXCHANGE_SCRIPT_END)
	exchange->exch_pc++;
      exchange->exch_pc++;
    }
d403 1
a403 1
exchange_init ()
d405 1
a405 1
  int i;
d407 7
a413 8
  bucket_mask = (1 << INITIAL_BUCKET_BITS) - 1;
  exchange_tab = malloc ((bucket_mask + 1) * sizeof (struct exchange_list));
  if (!exchange_tab)
    log_fatal ("exchange_init: out of memory");
  for (i = 0; i <= bucket_mask; i++)
    {
      LIST_INIT (&exchange_tab[i]);
    }
d420 1
a420 1
exchange_resize (void)
d422 12
a433 14
  int new_mask = (bucket_mask + 1) * 2 - 1;
  int i;
  struct exchange_list *new_tab;

  new_tab
    = realloc (exchange_tab, (new_mask + 1) * sizeof (struct exchange_list));
  if (!new_tab)
    return;
  for (i = bucket_mask + 1; i <= new_mask; i++)
    {
      LIST_INIT (&new_tab[i]);
    }
  bucket_mask = new_mask;
  /* XXX Rehash existing entries.  */
d439 1
a439 1
exchange_lookup_from_icookie (u_int8_t *cookie)
d441 2
a442 2
  int i;
  struct exchange *exchange;
d444 8
a451 7
  for (i = 0; i <= bucket_mask; i++)
    for (exchange = LIST_FIRST (&exchange_tab[i]); exchange;
	 exchange = LIST_NEXT (exchange, link))
      if (memcmp (exchange->cookies, cookie, ISAKMP_HDR_ICOOKIE_LEN) == 0
	  && exchange->phase == 1)
	return exchange;
  return 0;
d456 1
a456 1
exchange_lookup_by_name (char *name, int phase)
d458 2
a459 2
  int i;
  struct exchange *exchange;
d461 23
a483 24
  /* If we search for nothing, we will find nothing.  */
  if (!name)
    return 0;

  for (i = 0; i <= bucket_mask; i++)
    for (exchange = LIST_FIRST (&exchange_tab[i]); exchange;
	 exchange = LIST_NEXT (exchange, link))
      {
	LOG_DBG ((LOG_EXCHANGE, 90,
		  "exchange_lookup_by_name: %s == %s && %d == %d?", name,
		  exchange->name ? exchange->name : "<unnamed>", phase,
		  exchange->phase));

	/*
	 * Match by name, but don't select finished exchanges, i.e
	 * where MSG_LAST are set in last_sent msg.
	 */
	if (exchange->name && strcasecmp (exchange->name, name) == 0
	    && exchange->phase == phase
	    && (!exchange->last_sent
		|| (exchange->last_sent->flags & MSG_LAST) == 0))
	  return exchange;
      }
  return 0;
d488 1
a488 1
exchange_lookup_active (char *name, int phase)
d490 2
a491 2
  int i;
  struct exchange *exchange;
d493 1
a493 1
  /* XXX Almost identical to exchange_lookup_by_name.  */
d495 21
a515 23
  if (!name)
    return 0;

  for (i = 0; i <= bucket_mask; i++)
    for (exchange = LIST_FIRST (&exchange_tab[i]); exchange;
	 exchange = LIST_NEXT (exchange, link))
      {
	LOG_DBG ((LOG_EXCHANGE, 90,
		  "exchange_lookup_active: %s == %s && %d == %d?",
		  name, exchange->name ? exchange->name : "<unnamed>", phase,
		  exchange->phase));
	if (exchange->name && strcasecmp (exchange->name, name) == 0
	    && exchange->phase == phase)
	  {
	    if (exchange->step > 1)
	      return exchange;
	    else
	      LOG_DBG ((LOG_EXCHANGE, 80,
			"exchange_lookup_active: avoided early (pre-step 1) "
			"exchange %p", exchange));
	  }
      }
  return 0;
d519 1
a519 1
exchange_enter (struct exchange *exchange)
d521 18
a538 20
  u_int16_t bucket = 0;
  int i;
  u_int8_t *cp;

  /* XXX We might resize if we are crossing a certain threshold */

  for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2)
    {
      cp = exchange->cookies + i;
      /* Doing it this way avoids alignment problems.  */
      bucket ^= cp[0] | cp[1] << 8;
    }
  for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2)
    {
      cp = exchange->message_id + i;
      /* Doing it this way avoids alignment problems.  */
      bucket ^= cp[0] | cp[1] << 8;
    }
  bucket &= bucket_mask;
  LIST_INSERT_HEAD (&exchange_tab[bucket], exchange, link);
d546 1
a546 1
exchange_lookup (u_int8_t *msg, int phase2)
d548 4
a551 36
  u_int16_t bucket = 0;
  int i;
  struct exchange *exchange;
  u_int8_t *cp;

  /*
   * We use the cookies to get bits to use as an index into exchange_tab, as at
   * least one (our cookie) is a good hash, xoring all the bits, 16 at a
   * time, and then masking, should do.  Doing it this way means we can
   * validate cookies very fast thus delimiting the effects of "Denial of
   * service"-attacks using packet flooding.
   */
  for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2)
    {
      cp = msg + ISAKMP_HDR_COOKIES_OFF + i;
      /* Doing it this way avoids alignment problems.  */
      bucket ^= cp[0] | cp[1] << 8;
    }
  if (phase2)
    for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2)
      {
	cp = msg + ISAKMP_HDR_MESSAGE_ID_OFF + i;
	/* Doing it this way avoids alignment problems.  */
	bucket ^= cp[0] | cp[1] << 8;
      }
  bucket &= bucket_mask;
  for (exchange = LIST_FIRST (&exchange_tab[bucket]);
       exchange && (memcmp (msg + ISAKMP_HDR_COOKIES_OFF, exchange->cookies,
			    ISAKMP_HDR_COOKIES_LEN) != 0
		    || (phase2 && memcmp (msg + ISAKMP_HDR_MESSAGE_ID_OFF,
					  exchange->message_id,
					  ISAKMP_HDR_MESSAGE_ID_LEN) != 0)
		    || (!phase2 && !zero_test (msg + ISAKMP_HDR_MESSAGE_ID_OFF,
					       ISAKMP_HDR_MESSAGE_ID_LEN)));
       exchange = LIST_NEXT (exchange, link))
    ;
d553 30
a582 1
  return exchange;
d593 1
a593 1
exchange_create (int phase, int initiator, int doi, int type)
d595 55
a649 62
  struct exchange *exchange;
  struct timeval expiration;
  int delta;

  /*
   * We want the exchange zeroed for exchange_free to be able to find
   * out what fields have been filled-in.
   */
  exchange = calloc (1, sizeof *exchange);
  if (!exchange)
    {
      log_error ("exchange_create: calloc (1, %lu) failed",
	(unsigned long)sizeof *exchange);
      return 0;
    }
  exchange->phase = phase;
  exchange->step = 0;
  exchange->initiator = initiator;
  memset (exchange->cookies, 0, ISAKMP_HDR_COOKIES_LEN);
  memset (exchange->message_id, 0, ISAKMP_HDR_MESSAGE_ID_LEN);
  exchange->doi = doi_lookup (doi);
  exchange->type = type;
  exchange->policy_id = -1;
  exchange->exch_pc = exchange_script (exchange);
  exchange->last_sent = exchange->last_received = 0;
  TAILQ_INIT (&exchange->sa_list);
  TAILQ_INIT (&exchange->aca_list);

  /* Allocate the DOI-specific structure and initialize it to zeroes.  */
  if (exchange->doi->exchange_size)
    {
      exchange->data = calloc (1, exchange->doi->exchange_size);
      if (!exchange->data)
	{
	  log_error ("exchange_create: calloc (1, %lu) failed",
		(unsigned long)exchange->doi->exchange_size);
	  exchange_free (exchange);
	  return 0;
	}
    }

  gettimeofday (&expiration, 0);
  delta = conf_get_num ("General", "Exchange-max-time", EXCHANGE_MAX_TIME);
  expiration.tv_sec += delta;
  exchange->death = timer_add_event ("exchange_free_aux", exchange_free_aux,
				     exchange, &expiration);
  if (!exchange->death)
    {
      /* If we don't give up we might start leaking...  */
      exchange_free_aux (exchange);
      return 0;
    }

  return exchange;
}

struct exchange_finalization_node
{
  void (*first) (struct exchange *, void *, int);
  void *first_arg;
  void (*second) (struct exchange *, void *, int);
  void *second_arg;
d654 1
a654 1
exchange_run_finalizations (struct exchange *exchange, void *arg, int fail)
d656 1
a656 1
  struct exchange_finalization_node *node = arg;
d658 3
a660 3
  node->first (exchange, node->first_arg, fail);
  node->second (exchange, node->second_arg, fail);
  free (node);
d668 26
a693 30
exchange_add_finalization (struct exchange *exchange,
			   void (*finalize) (struct exchange *, void *, int),
			   void *arg)
{
  struct exchange_finalization_node *node;

  if (!finalize)
    return;

  if (!exchange->finalize)
    {
      exchange->finalize = finalize;
      exchange->finalize_arg = arg;
      return;
    }

  node = malloc (sizeof *node);
  if (!node)
    {
      log_error ("exchange_add_finalization: malloc (%lu) failed",
		 (unsigned long)sizeof *node);
      free (arg);
      return;
    }
  node->first = exchange->finalize;
  node->first_arg = exchange->finalize_arg;
  node->second = finalize;
  node->second_arg = arg;
  exchange->finalize = exchange_run_finalizations;
  exchange->finalize_arg = node;
d698 1
a698 1
exchange_establish_transaction (struct exchange *exchange, void *arg, int fail)
d700 4
a703 4
  /* Establish a TRANSACTION exchange.  */
  struct exchange_finalization_node *node
    = (struct exchange_finalization_node *)arg;
  struct sa *isakmp_sa = sa_lookup_by_name ((char *)node->second_arg, 1);
d705 3
a707 3
  if (isakmp_sa && !fail)
    exchange_establish_p2 (isakmp_sa, ISAKMP_EXCH_TRANSACTION, 0, 0,
			   node->first, node->first_arg);
d709 1
a709 1
  free (node);
d711 1
a711 1
#endif /* USE_ISAKMP_CFG */
d715 3
a717 4
exchange_establish_p1 (struct transport *t, u_int8_t type, u_int32_t doi,
		       char *name, void *args,
		       void (*finalize) (struct exchange *, void *, int),
		       void *arg)
d719 2
a720 2
  struct exchange *exchange;
  struct message *msg;
d722 2
a723 2
  struct conf_list *flags;
  struct conf_list_node *flag;
d725 2
a726 2
  char *tag = 0;
  char *str;
d728 58
a785 66
  if (name)
    {
      /* If no exchange type given, fetch from the configuration.  */
      if (type == 0)
	{
	  /* XXX Similar code can be found in exchange_setup_p1.  Share?  */

	  /* Find out our phase 1 mode.  */
	  tag = conf_get_str (name, "Configuration");
	  if (!tag)
	    {
	      /* Use default setting.  */
	      tag = CONF_DFLT_TAG_PHASE1_CONFIG;
	    }

	  /* Figure out the DOI.  XXX Factor out?  */
	  str = conf_get_str (tag, "DOI");
	  if (!str || strcasecmp (str, "IPSEC") == 0)
	    doi = IPSEC_DOI_IPSEC;
	  else if (strcasecmp (str, "ISAKMP") == 0)
	    doi = ISAKMP_DOI_ISAKMP;
	  else
	    {
	      log_print ("exchange_establish_p1: DOI \"%s\" unsupported", str);
	      return;
	    }

	  /* What exchange type do we want?  */
	  str = conf_get_str (tag, "EXCHANGE_TYPE");
	  if (!str)
	    {
	      log_print ("exchange_establish_p1: "
			 "no \"EXCHANGE_TYPE\" tag in [%s] section", tag);
	      return;
	    }
	  type = constant_value (isakmp_exch_cst, str);
	  if (!type)
	    {
	      log_print ("exchange_setup_p1: unknown exchange type %s",
			 str);
	      return;
	    }
	}
    }

  exchange = exchange_create (1, 1, doi, type);
  if (!exchange)
    {
      /* XXX Do something here?  */
      return;
    }

  if (name)
    {
      exchange->name = strdup (name);
      if (!exchange->name)
	{
	  log_error ("exchange_establish_p1: strdup (\"%s\") failed", name);
	  exchange_free (exchange);
	  return;
	}
    }

  exchange->policy = name ? conf_get_str (name, "Configuration") : 0;
  if (!exchange->policy && name)
    exchange->policy = CONF_DFLT_TAG_PHASE1_CONFIG;
d788 35
a822 37
  if (name)
    {
      flags = conf_get_list (name, "Flags");
      if (flags)
	{
	  for (flag = TAILQ_FIRST (&flags->fields); flag;
	       flag = TAILQ_NEXT (flag, link))
	    if (strcasecmp (flag->field, "ikecfg") == 0)
	      {
		struct exchange_finalization_node *node;

		node = calloc (1, (unsigned long)sizeof *node);
		if (!node)
		  {
		    log_print ("exchange_establish_p1: calloc (1, %lu) failed",
			       (unsigned long)sizeof (*node));
		    exchange_free (exchange);
		    return;
		  }

		/* Insert this finalization inbetween the original.  */
		node->first = finalize;
		node->first_arg = arg;
		node->second_arg = name;
		exchange_add_finalization (exchange,
					   exchange_establish_transaction,
					   node);
		finalize = 0;
	      }
	  conf_free_list (flags);
	}
    }
#endif /* USE_ISAKMP_CFG */

  exchange_add_finalization (exchange, finalize, arg);
  cookie_gen (t, exchange, exchange->cookies, ISAKMP_HDR_ICOOKIE_LEN);
  exchange_enter (exchange);
d824 1
a824 1
  exchange_dump ("exchange_establish_p1", exchange);
d827 25
a851 26
  msg = message_alloc (t, 0, ISAKMP_HDR_SZ);
  if (!msg)
    {
      log_print ("exchange_establish_p1: message_alloc () failed");
      exchange_free (exchange);
      return;
    }
  msg->exchange = exchange;

  /* Do not create SA for an information or transaction exchange.  */
  if (exchange->type != ISAKMP_EXCH_INFO
      && exchange->type != ISAKMP_EXCH_TRANSACTION)
    {
      /*
       * Don't install a transport into this SA as it will be an INADDR_ANY
       * address in the local end, which is not good at all.  Let the reply
       * packet install the transport instead.
       */
      sa_create (exchange, 0);
      msg->isakmp_sa = TAILQ_FIRST (&exchange->sa_list);
      if (!msg->isakmp_sa)
	{
	  /* XXX Do something more here?  */
	  message_free (msg);
	  exchange_free (exchange);
	  return;
d853 1
a853 4
      sa_reference (msg->isakmp_sa);
    }

  msg->extra = args;
d855 1
a855 1
  exchange_run (msg);
d860 73
a932 86
exchange_establish_p2 (struct sa *isakmp_sa, u_int8_t type, char *name,
		       void *args,
		       void (*finalize) (struct exchange *, void *, int),
		       void *arg)
{
  struct exchange *exchange;
  struct message *msg;
  int i;
  char *tag, *str;
  u_int32_t doi = ISAKMP_DOI_ISAKMP;
  u_int32_t seq = 0;

  if (isakmp_sa)
    doi = isakmp_sa->doi->id;

  if (name)
    {
      /* Find out our phase 2 modes.  */
      tag = conf_get_str (name, "Configuration");
      if (!tag)
	{
	  log_print ("exchange_establish_p2: no configuration for peer \"%s\"",
		     name);
	  return;
	}

      seq = (u_int32_t) conf_get_num (name, "Acquire-ID", 0);

      /* Figure out the DOI.  */
      str = conf_get_str (tag, "DOI");
      if (!str || strcasecmp (str, "IPSEC") == 0)
	doi = IPSEC_DOI_IPSEC;
      else if (strcasecmp (str, "ISAKMP") == 0)
	doi = ISAKMP_DOI_ISAKMP;
      else
	{
	  log_print ("exchange_establish_p2: DOI \"%s\" unsupported", str);
	  return;
	}

      /* What exchange type do we want?  */
      if (!type)
	{
	  str = conf_get_str (tag, "EXCHANGE_TYPE");
	  if (!str)
	    {
	      log_print ("exchange_establish_p2: "
			 "no \"EXCHANGE_TYPE\" tag in [%s] section", tag);
	      return;
	    }
	  /* XXX IKE dependent.  */
	  type = constant_value (ike_exch_cst, str);
	  if (!type)
	    {
	      log_print ("exchange_establish_p2: unknown exchange type %s",
			 str);
	      return;
	    }
	}
    }

  exchange = exchange_create (2, 1, doi, type);
  if (!exchange)
    {
      /* XXX Do something here?  */
      return;
    }

  if (name)
    {
      exchange->name = strdup (name);
      if (!exchange->name)
	{
	  log_error ("exchange_establish_p2: strdup (\"%s\") failed", name);
	  exchange_free (exchange);
	  return;
	}
    }
  exchange->policy = name ? conf_get_str (name, "Configuration") : 0;
  exchange->finalize = finalize;
  exchange->finalize_arg = arg;
  exchange->seq = seq;
  memcpy (exchange->cookies, isakmp_sa->cookies, ISAKMP_HDR_COOKIES_LEN);
  getrandom (exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
  exchange_enter (exchange);
d934 1
a934 1
  exchange_dump ("exchange_establish_p2", exchange);
d937 16
a952 19
  /*
   * Do not create SA's for informational exchanges.
   * XXX How to handle new group mode?
   */
  if (exchange->type != ISAKMP_EXCH_INFO
      && exchange->type != ISAKMP_EXCH_TRANSACTION)
    {
      /* XXX Number of SAs should come from the args structure.  */
      for (i = 0; i < 1; i++)
	if (sa_create (exchange, isakmp_sa->transport))
	  {
	    exchange_free (exchange);
	    return;
	  }
    }

  msg = message_alloc (isakmp_sa->transport, 0, ISAKMP_HDR_SZ);
  msg->isakmp_sa = isakmp_sa;
  sa_reference (isakmp_sa);
d954 1
a954 1
  msg->extra = args;
d956 2
a957 2
  /* This needs to be done late or else get_keystate won't work right.  */
  msg->exchange = exchange;
d959 1
a959 1
  exchange_run (msg);
d964 1
a964 1
exchange_setup_p1 (struct message *msg, u_int32_t doi)
d966 3
a968 3
  struct transport *t = msg->transport;
  struct exchange *exchange;
  struct sockaddr *dst;
d970 2
a971 2
  struct conf_list *flags;
  struct conf_list_node *flag;
d973 88
a1060 101
  char *name = 0, *policy = 0, *str;
  u_int32_t want_doi;
  u_int8_t type;

  /* XXX Similar code can be found in exchange_establish_p1.  Share?  */

  /*
   * Unless this is an informational exchange, look up our policy for this
   * peer.
   */
  type = GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0].iov_base);
  if (type != ISAKMP_EXCH_INFO)
    {
      /*
       * Find out our inbound phase 1 mode.
       */
      t->vtbl->get_dst (t, &dst);
      if (sockaddr2text (dst, &str, 0) == -1)
	return 0;
      name = conf_get_str ("Phase 1", str);
      free (str);
      if (name)
	{
	  /*
	   * If another phase 1 exchange is ongoing don't bother returning the
	   * call. However, we will need to continue responding if our phase 1
	   * exchange is still waiting for step 1 (i.e still half-open).
	   */
	  if (exchange_lookup_active (name, 1))
	    return 0;
	}
      else
	{
	  name = conf_get_str ("Phase 1", "Default");
	  if (!name)
	    {
	      log_print ("exchange_setup_p1: "
			 "no \"Default\" tag in [Phase 1] section");
	      return 0;
	    }
	}

      policy = conf_get_str (name, "Configuration");
      if (!policy)
	policy = CONF_DFLT_TAG_PHASE1_CONFIG;

      /* Figure out the DOI.  */
      str = conf_get_str (policy, "DOI");
      if (!str || strcasecmp (str, "IPSEC") == 0)
	want_doi = IPSEC_DOI_IPSEC;
      else if (strcasecmp (str, "ISAKMP") == 0)
	want_doi = ISAKMP_DOI_ISAKMP;
      else
	{
	  log_print ("exchange_setup_p1: DOI \"%s\" unsupported", str);
	  return 0;
	}
      if (want_doi != doi)
	{
	  /* XXX Should I tell what DOI I got?  */
	  log_print ("exchange_setup_p1: expected %s DOI", str);
	  return 0;
	}

      /* What exchange type do we want?  */
      str = conf_get_str (policy, "EXCHANGE_TYPE");
      if (!str)
	{
	  log_print ("exchange_setup_p1: "
		     "no \"EXCHANGE_TYPE\" tag in [%s] section", policy);
	  return 0;
	}
      type = constant_value (isakmp_exch_cst, str);
      if (!type)
	{
	  log_print ("exchange_setup_p1: unknown exchange type %s", str);
	  return 0;
	}
      if (type != GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0].iov_base))
	{
	  log_print ("exchange_setup_p1: expected exchange type %s got %s",
		     str,
		     constant_name (isakmp_exch_cst,
				    GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0]
							      .iov_base)));
	  return 0;
	}
    }

  exchange = exchange_create (1, 0, doi, type);
  if (!exchange)
    return 0;

  exchange->name = name ? strdup (name) : 0;
  if (name && !exchange->name)
    {
      log_error ("exchange_setup_p1: strdup (\"%s\") failed", name);
      exchange_free (exchange);
      return 0;
    }
  exchange->policy = policy;
d1063 28
a1090 29
  if (name)
    {
      flags = conf_get_list (name, "Flags");
      if (flags)
	{
	  for (flag = TAILQ_FIRST (&flags->fields); flag;
	       flag = TAILQ_NEXT (flag, link))
	    if (strcasecmp (flag->field, "ikecfg") == 0)
	      {
		struct exchange_finalization_node *node;

		node = calloc (1, (unsigned long)sizeof *node);
		if (!node)
		  {
		    log_print ("exchange_establish_p1: calloc (1, %lu) failed",
			       (unsigned long)sizeof (*node));
		    exchange_free (exchange);
		    return 0;
		  }

		/* Insert this finalization inbetween the original.  */
		node->first = 0;
		node->first_arg = 0;
		node->second_arg = name;
		exchange_add_finalization (exchange,
					   exchange_establish_transaction,
					   node);
	      }
	  conf_free_list (flags);
a1091 1
    }
d1094 4
a1097 5
  cookie_gen (msg->transport, exchange,
	      exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN,
	      ISAKMP_HDR_RCOOKIE_LEN);
  GET_ISAKMP_HDR_ICOOKIE (msg->iov[0].iov_base, exchange->cookies);
  exchange_enter (exchange);
d1099 1
a1099 1
  exchange_dump ("exchange_setup_p1", exchange);
d1101 1
a1101 1
  return exchange;
d1106 1
a1106 1
exchange_setup_p2 (struct message *msg, u_int8_t doi)
d1108 2
a1109 2
  struct exchange *exchange;
  u_int8_t *buf = msg->iov[0].iov_base;
d1111 7
a1117 7
  exchange = exchange_create (2, 0, doi, GET_ISAKMP_HDR_EXCH_TYPE (buf));
  if (!exchange)
    return 0;
  GET_ISAKMP_HDR_ICOOKIE (buf, exchange->cookies);
  GET_ISAKMP_HDR_RCOOKIE (buf, exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN);
  GET_ISAKMP_HDR_MESSAGE_ID (buf, exchange->message_id);
  exchange_enter (exchange);
d1119 1
a1119 1
  exchange_dump ("exchange_setup_p2", exchange);
d1121 1
a1121 1
  return exchange;
d1126 2
a1127 2
exchange_dump_real (char *header, struct exchange *exchange, int class,
		    int level)
d1129 4
a1132 4
  char buf[LOG_SIZE];
  /* Don't risk overflowing the final log buffer.  */
  size_t bufsize_max = LOG_SIZE - strlen (header) - 32;
  struct sa *sa;
d1134 1
a1134 1
  LOG_DBG ((class, level,
d1140 14
a1153 18
  LOG_DBG ((class, level,
	    "%s: icookie %08x%08x rcookie %08x%08x", header,
	    decode_32 (exchange->cookies), decode_32 (exchange->cookies + 4),
	    decode_32 (exchange->cookies + 8),
	    decode_32 (exchange->cookies + 12)));

  /* Include phase 2 SA list for this exchange */
  if (exchange->phase == 2)
    {
      snprintf (buf, bufsize_max, "sa_list ");
      for (sa = TAILQ_FIRST (&exchange->sa_list);
	   sa && strlen (buf) < bufsize_max; sa = TAILQ_NEXT (sa, next))
	snprintf (buf + strlen (buf), bufsize_max - strlen (buf), "%p ", sa);
      if (sa)
	strlcat (buf, "...", bufsize_max);
    }
  else
    buf[0] = '\0';
d1155 2
a1156 2
  LOG_DBG ((class, level, "%s: msgid %08x %s", header,
	    decode_32 (exchange->message_id), buf));
d1160 1
a1160 1
exchange_dump (char *header, struct exchange *exchange)
d1162 1
a1162 1
  exchange_dump_real (header, exchange, LOG_EXCHANGE, 10);
d1166 1
a1166 1
exchange_report (void)
d1168 2
a1169 2
  int i;
  struct exchange *exchange;
d1171 4
a1174 4
  for (i = 0; i <= bucket_mask; i++)
    for (exchange = LIST_FIRST (&exchange_tab[i]); exchange;
	 exchange = LIST_NEXT (exchange, link))
      exchange_dump_real ("exchange_report", exchange, LOG_REPORT, 0);
d1183 1
a1183 1
exchange_free_aux (void *v_exch)
d1185 3
a1187 3
  struct exchange *exchange = v_exch;
  struct sa *sa, *next_sa;
  struct cert_handler *handler;
d1189 1
a1189 1
  LOG_DBG ((LOG_EXCHANGE, 80, "exchange_free_aux: freeing exchange %p",
d1192 37
a1228 39
  if (exchange->last_received)
    message_free (exchange->last_received);
  if (exchange->last_sent)
    message_free (exchange->last_sent);
  if (exchange->in_transit && exchange->in_transit != exchange->last_sent)
    message_free (exchange->in_transit);
  if (exchange->nonce_i)
    free (exchange->nonce_i);
  if (exchange->nonce_r)
    free (exchange->nonce_r);
  if (exchange->id_i)
    free (exchange->id_i);
  if (exchange->id_r)
    free (exchange->id_r);
  if (exchange->keystate)
    free (exchange->keystate);
  if (exchange->doi && exchange->doi->free_exchange_data)
    exchange->doi->free_exchange_data (exchange->data);
  if (exchange->data)
    free (exchange->data);
  if (exchange->name)
    free (exchange->name);
  if (exchange->recv_cert)
    {
      handler = cert_get (exchange->recv_certtype);
      if (handler)
	handler->cert_free (exchange->recv_cert);
    }
  if (exchange->sent_cert)
    {
      handler = cert_get (exchange->sent_certtype);
      if (handler)
	handler->cert_free (exchange->sent_cert);
    }
  if (exchange->recv_key)
    key_free (exchange->recv_keytype, ISAKMP_KEYTYPE_PUBLIC,
	      exchange->recv_key);
  if (exchange->keynote_key)
    free (exchange->keynote_key); /* This is just a string */
d1231 2
a1232 2
  if (exchange->policy_id != -1)
    kn_close (exchange->policy_id);
d1235 2
a1236 2
  exchange_free_aca_list (exchange);
  LIST_REMOVE (exchange, link);
d1238 12
a1249 13
  /* Tell potential finalize routine we never got there.  */
  if (exchange->finalize)
    exchange->finalize (exchange, exchange->finalize_arg, 1);

  /* Remove any SAs that have not been disassociated from us.  */
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = next_sa)
    {
      next_sa = TAILQ_NEXT (sa, next);
      /* One for the reference in exchange->sa_list.  */
      sa_release (sa);
      /* And two more for the expiration and SA linked list.  */
      sa_free (sa);
    }
d1251 1
a1251 1
  free (exchange);
d1256 1
a1256 1
exchange_free (struct exchange *exchange)
d1258 3
a1260 3
  if (exchange->death)
    timer_remove_event (exchange->death);
  exchange_free_aux (exchange);
d1268 1
a1268 1
exchange_upgrade_p1 (struct message *msg)
d1270 1
a1270 1
  struct exchange *exchange = msg->exchange;
d1272 5
a1276 5
  LIST_REMOVE (exchange, link);
  GET_ISAKMP_HDR_RCOOKIE (msg->iov[0].iov_base,
			  exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN);
  exchange_enter (exchange);
  sa_isakmp_upgrade (msg);
d1280 1
a1280 1
exchange_check_old_sa (struct sa *sa, void *v_arg)
d1282 2
a1283 2
  struct sa *new_sa = v_arg;
  char res1[1024];
d1285 14
a1298 14
  if (sa == new_sa || !sa->name || !(sa->flags & SA_FLAG_READY)
      || (sa->flags & SA_FLAG_REPLACED))
    return 0;

  if (sa->phase != new_sa->phase || new_sa->name == 0
      || strcasecmp (sa->name, new_sa->name))
    return 0;

  if (sa->initiator)
    strlcpy (res1, ipsec_decode_ids ("%s %s", sa->id_i, sa->id_i_len, sa->id_r,
				     sa->id_r_len, 0), sizeof res1);
  else
    strlcpy (res1, ipsec_decode_ids ("%s %s", sa->id_r, sa->id_r_len, sa->id_i,
				     sa->id_i_len, 0), sizeof res1);
d1300 1
a1300 1
  LOG_DBG ((LOG_EXCHANGE, 30,
d1303 6
a1308 8
  if (new_sa->initiator)
    return strcasecmp (res1, ipsec_decode_ids ("%s %s", new_sa->id_i,
					       new_sa->id_i_len, new_sa->id_r,
					       new_sa->id_r_len, 0)) == 0;
  else
    return strcasecmp (res1, ipsec_decode_ids ("%s %s", new_sa->id_r,
					       new_sa->id_r_len, new_sa->id_i,
					       new_sa->id_i_len, 0)) == 0;
d1312 1
a1312 1
exchange_finalize (struct message *msg)
d1314 8
a1321 8
  struct exchange *exchange = msg->exchange;
  struct sa *sa, *old_sa;
  struct proto *proto;
  struct conf_list *attrs;
  struct conf_list_node *attr;
  struct cert_handler *handler;
  int i;
  char *id_doi, *id_trp;
d1324 1
a1324 1
  exchange_dump ("exchange_finalize", exchange);
d1327 146
a1472 161
  /* Copy the ID from phase 1 to exchange or phase 2 SA.  */
  if (msg->isakmp_sa)
    {
      if (exchange->id_i && exchange->id_r)
	{
	  ipsec_clone_id (&msg->isakmp_sa->id_i, &msg->isakmp_sa->id_i_len,
			  exchange->id_i, exchange->id_i_len);
	  ipsec_clone_id (&msg->isakmp_sa->id_r, &msg->isakmp_sa->id_r_len,
			  exchange->id_r, exchange->id_r_len);
	}
      else if (msg->isakmp_sa->id_i && msg->isakmp_sa->id_r)
	{
	  ipsec_clone_id (&exchange->id_i, &exchange->id_i_len,
			  msg->isakmp_sa->id_i, msg->isakmp_sa->id_i_len);
	  ipsec_clone_id (&exchange->id_r, &exchange->id_r_len,
			  msg->isakmp_sa->id_r, msg->isakmp_sa->id_r_len);
	}
    }

  /*
   * Walk over all the SAs and noting them as ready.  If we set the
   * COMMIT bit, tell the peer each SA is connected.
   *
   * XXX The decision should really be based on if a SA was installed
   * successfully.
   */
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = TAILQ_NEXT (sa, next))
    {
      /* Move over the name to the SA.  */
      sa->name = exchange->name ? strdup (exchange->name) : 0;

      if (exchange->flags & EXCHANGE_FLAG_I_COMMITTED)
	{
	  for (proto = TAILQ_FIRST (&sa->protos); proto;
	       proto = TAILQ_NEXT (proto, link))
	    for (i = 0; i < 2; i++)
	      message_send_notification (exchange->last_received,
					 msg->isakmp_sa,
					 ISAKMP_NOTIFY_STATUS_CONNECTED, proto,
					 i);
	}

      /* Locate any old SAs and mark them replaced (SA_FLAG_REPLACED).  */
      while ((old_sa = sa_find (exchange_check_old_sa, sa)) != 0)
	sa_mark_replaced (old_sa);

      /* Setup the SA flags.  */
      sa->flags |= SA_FLAG_READY;
      if (exchange->name)
	{
	  attrs = conf_get_list (exchange->name, "Flags");
	  if (attrs)
	    {
	      for (attr = TAILQ_FIRST (&attrs->fields); attr;
		   attr = TAILQ_NEXT (attr, link))
		sa->flags |= sa_flag (attr->field);
	      conf_free_list (attrs);
	    }
	  /* 'Connections' should stay alive.  */
	  if (connection_exist (exchange->name))
	    {
	      sa->flags |= SA_FLAG_STAYALIVE;

	      /* ISAKMP SA of this connection should also stay alive.  */
	      if (exchange->phase == 2 && msg->isakmp_sa)
		msg->isakmp_sa->flags |= SA_FLAG_STAYALIVE;
	    }
	}

      sa->seq = exchange->seq;
      sa->exch_type = exchange->type;
    }

  /*
   * If this was an phase 1 SA negotiation, save the keystate in the ISAKMP SA
   * structure for future initialization of phase 2 exchanges' keystates.
   * Also save the Phase 1 ID and authentication information.
   */
  if (exchange->phase == 1 && msg->isakmp_sa)
    {
      msg->isakmp_sa->keystate = exchange->keystate;
      exchange->keystate = 0;

      msg->isakmp_sa->recv_certtype = exchange->recv_certtype;
      msg->isakmp_sa->sent_certtype = exchange->sent_certtype;
      msg->isakmp_sa->recv_keytype = exchange->recv_keytype;
      msg->isakmp_sa->recv_key = exchange->recv_key;
      msg->isakmp_sa->keynote_key = exchange->keynote_key;
      /* Reset.  */
      exchange->recv_key = 0;
      exchange->keynote_key = 0;
      msg->isakmp_sa->policy_id = exchange->policy_id;
      exchange->policy_id = -1;
      msg->isakmp_sa->initiator = exchange->initiator;

      if (exchange->recv_certtype && exchange->recv_cert)
	{
	  handler = cert_get (exchange->recv_certtype);
	  if (handler)
	    msg->isakmp_sa->recv_cert
	      = handler->cert_dup (exchange->recv_cert);
	}

      if (exchange->sent_certtype)
        {
	  handler = cert_get (exchange->sent_certtype);
	  if (handler)
	    msg->isakmp_sa->sent_cert
	      = handler->cert_dup (exchange->sent_cert);
	}

      if (exchange->doi)
	id_doi = exchange->doi->decode_ids ("initiator id %s, responder id %s",
					    exchange->id_i, exchange->id_i_len,
					    exchange->id_r, exchange->id_r_len,
					    0);
      else
	id_doi = "<no doi>";

      if (msg->isakmp_sa && msg->isakmp_sa->transport)
	id_trp = msg->isakmp_sa->transport->vtbl->decode_ids
	  (msg->isakmp_sa->transport);
      else
        id_trp = "<no transport>";

      LOG_DBG ((LOG_EXCHANGE, 10, "exchange_finalize: phase 1 done: %s, %s",
	        id_doi, id_trp));

      log_verbose ("isakmpd: phase 1 done: %s, %s", id_doi, id_trp);
    }

  exchange->doi->finalize_exchange (msg);
  if (exchange->finalize)
    exchange->finalize (exchange, exchange->finalize_arg, 0);
  exchange->finalize = 0;

  /*
   * There is no reason to keep the SAs connected to us anymore, in fact
   * it can hurt us if we have short lifetimes on the SAs and we try
   * to call exchange_report, where the SA list will be walked and
   * references to freed SAs can occur.
   */
  while (TAILQ_FIRST (&exchange->sa_list))
    {
      sa = TAILQ_FIRST (&exchange->sa_list);

      if (exchange->id_i && exchange->id_r)
	{
          ipsec_clone_id (&sa->id_i, &sa->id_i_len, exchange->id_i,
		          exchange->id_i_len);
          ipsec_clone_id (&sa->id_r, &sa->id_r_len, exchange->id_r,
		          exchange->id_r_len);
	}

      TAILQ_REMOVE (&exchange->sa_list, sa, next);
      sa_release (sa);
    }

  /* If we have nothing to retransmit we can safely remove ourselves.  */
  if (!exchange->last_sent)
    exchange_free (exchange);
d1477 2
a1478 2
exchange_nonce (struct exchange *exchange, int peer, size_t nonce_sz,
		u_int8_t *buf)
d1480 16
a1495 16
  int initiator = exchange->initiator ^ peer;
  u_int8_t **nonce;
  size_t *nonce_len;
  char header[32];

  nonce = initiator ? &exchange->nonce_i : &exchange->nonce_r;
  nonce_len = initiator ? &exchange->nonce_i_len : &exchange->nonce_r_len;
  *nonce_len = nonce_sz;
  *nonce = malloc (nonce_sz);
  if (!*nonce)
    {
      log_error ("exchange_nonce: malloc (%lu) failed", (unsigned long)nonce_sz);
      return -1;
    }
  memcpy (*nonce, buf, nonce_sz);
  snprintf (header, sizeof header, "exchange_nonce: NONCE_%c",
d1497 2
a1498 2
  LOG_DBG_BUF ((LOG_EXCHANGE, 80, header, *nonce, nonce_sz));
  return 0;
d1503 1
a1503 1
exchange_gen_nonce (struct message *msg, size_t nonce_sz)
d1505 2
a1506 2
  struct exchange *exchange = msg->exchange;
  u_int8_t *buf;
d1508 13
a1520 15
  buf = malloc (ISAKMP_NONCE_SZ + nonce_sz);
  if (!buf)
    {
      log_error ("exchange_gen_nonce: malloc (%lu) failed",
		 ISAKMP_NONCE_SZ + (unsigned long)nonce_sz);
      return -1;
    }
  getrandom (buf + ISAKMP_NONCE_DATA_OFF, nonce_sz);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_NONCE, buf,
			   ISAKMP_NONCE_SZ + nonce_sz, 1))
    {
      free (buf);
      return -1;
    }
  return exchange_nonce (exchange, 0, nonce_sz, buf + ISAKMP_NONCE_DATA_OFF);
d1525 1
a1525 1
exchange_save_nonce (struct message *msg)
d1527 2
a1528 2
  struct payload *noncep;
  struct exchange *exchange = msg->exchange;
d1530 4
a1533 6
  noncep = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NONCE]);
  noncep->flags |= PL_MARK;
  return exchange_nonce (exchange, 1,
			 GET_ISAKMP_GEN_LENGTH (noncep->p)
			 - ISAKMP_NONCE_DATA_OFF,
			 noncep->p + ISAKMP_NONCE_DATA_OFF);
d1538 1
a1538 1
exchange_save_certreq (struct message *msg)
d1540 12
a1551 14
  struct payload *cp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT_REQ]);
  struct exchange *exchange = msg->exchange;
  struct certreq_aca *aca;

  for ( ; cp; cp = TAILQ_NEXT (cp, link))
    {
      cp->flags |= PL_MARK;
      aca = certreq_decode (GET_ISAKMP_CERTREQ_TYPE (cp->p),
			    cp->p + ISAKMP_CERTREQ_AUTHORITY_OFF,
			    GET_ISAKMP_GEN_LENGTH (cp->p) -
			    ISAKMP_CERTREQ_AUTHORITY_OFF);
      if (aca)
	TAILQ_INSERT_TAIL (&exchange->aca_list, aca, link);
    }
d1553 1
a1553 1
  return 0;
d1558 1
a1558 1
exchange_free_aca_list (struct exchange *exchange)
d1560 1
a1560 1
  struct certreq_aca *aca;
d1562 10
a1571 12
  for (aca = TAILQ_FIRST (&exchange->aca_list); aca;
       aca = TAILQ_FIRST (&exchange->aca_list))
    {
      if (aca->data)
	{
	  if (aca->handler)
	    aca->handler->free_aca (aca->data);
	  free (aca->data);
	}
      TAILQ_REMOVE (&exchange->aca_list, aca, link);
      free (aca);
    }
d1576 1
a1576 1
exchange_add_certs (struct message *msg)
d1578 45
a1622 48
  struct exchange *exchange = msg->exchange;
  struct certreq_aca *aca;
  u_int8_t *cert = 0, *new_cert = 0;
  u_int32_t certlen;
  u_int8_t *id;
  size_t id_len;

  id = exchange->initiator ? exchange->id_r : exchange->id_i;
  id_len = exchange->initiator ? exchange->id_r_len : exchange->id_i_len;

  /*
   * Without IDs we cannot handle this yet. Keep the aca_list around for
   * a later step/retry to see if we got the ID by then.
   * Note: A 'return -1' breaks X509-auth interop in the responder case
   *       with some IPsec clients that send CERTREQs early (ex SSH Sentinel).
   */
  if (!id)
    return 0;

  for (aca = TAILQ_FIRST (&exchange->aca_list); aca;
       aca = TAILQ_NEXT (aca, link))
    {
      /* XXX? If we can not satisfy a CERTREQ we drop the message.  */
      if (!aca->handler->cert_obtain (id, id_len, aca->data, &cert, &certlen))
	{
	  log_print ("exchange_add_certs: could not obtain cert for a type %d "
		     "cert request", aca->id);
	  if (cert)
	    free (cert);
	  return -1;
	}
      new_cert = realloc (cert, ISAKMP_CERT_SZ + certlen);
      if (!new_cert)
	{
	  log_error ("exchange_add_certs: realloc (%p, %d) failed", cert,
		     ISAKMP_CERT_SZ + certlen);
	  if (cert)
	    free (cert);
	  return -1;
	}
      cert = new_cert;
      memmove (cert + ISAKMP_CERT_DATA_OFF, cert, certlen);
      SET_ISAKMP_CERT_ENCODING (cert, aca->id);
      if (message_add_payload (msg, ISAKMP_PAYLOAD_CERT, cert,
			       ISAKMP_CERT_SZ + certlen, 1))
	{
	  free (cert);
	  return -1;
a1623 1
    }
d1625 2
a1626 2
  /* We dont need the CERT REQs any more, they are answered.  */
  exchange_free_aca_list (exchange);
d1628 1
a1628 1
  return 0;
d1632 1
a1632 1
exchange_establish_finalize (struct exchange *exchange, void *arg, int fail)
d1634 1
a1634 1
  char *name = arg;
d1636 1
a1636 2
  LOG_DBG ((LOG_EXCHANGE, 20,
	    "exchange_establish_finalize: "
d1640 3
a1642 3
  if (!fail)
    exchange_establish (name, 0, 0);
  free (name);
d1650 18
a1667 20
exchange_establish (char *name,
		    void (*finalize) (struct exchange *, void *, int),
		    void *arg)
{
  int phase;
  char *trpt;
  struct transport *transport;
  char *peer;
  struct sa *isakmp_sa;
  struct exchange *exchange;
  phase = conf_get_num (name, "Phase", 0);

  /*
   * First of all, never try to establish anything if another exchange of the
   * same kind is running.
   */
  exchange = exchange_lookup_by_name (name, phase);
  if (exchange)
    {
      LOG_DBG ((LOG_EXCHANGE, 40,
d1669 72
a1740 82
		exchange));
      exchange_add_finalization (exchange, finalize, arg);
      return;
    }

  switch (phase)
    {
    case 1:
      trpt = conf_get_str (name, "Transport");
      if (!trpt)
	{
	  /* Phase 1 transport defaults to "udp".  */
	  trpt = ISAKMP_DEFAULT_TRANSPORT;
	}

      transport = transport_create (trpt, name);
      if (!transport)
	{
	  log_print ("exchange_establish: "
		     "transport \"%s\" for peer \"%s\" could not be created",
		     trpt, name);
	  return;
	}

      exchange_establish_p1 (transport, 0, 0, name, 0, finalize, arg);
      break;

    case 2:
      peer = conf_get_str (name, "ISAKMP-peer");
      if (!peer)
	{
	  log_print ("exchange_establish: No ISAKMP-peer given for \"%s\"",
		     name);
	  return;
	}

      isakmp_sa = sa_lookup_by_name (peer, 1);
      if (!isakmp_sa)
	{
	  name = strdup (name);
	  if (!name)
	    {
	      log_error ("exchange_establish: strdup (\"%s\") failed", name);
	      return;
	    }

	  if (conf_get_num (peer, "Phase", 0) != 1)
	    {
	      log_print ("exchange_establish: "
			 "[%s]:ISAKMP-peer's (%s) phase is not 1", name, peer);
	      return;
	    }

	  /*
	   * XXX We're losing information here (what the original finalize
	   * routine was. As a result, if an exchange does not manage to
	   * get through, there may be application-specific information
	   * that won't get cleaned up, since no error signalling will be
	   * done. This is the case with dynamic SAs and PFKEY.
	   */
	  exchange_establish (peer, exchange_establish_finalize, name);
	  exchange = exchange_lookup_by_name (peer, 1);
	  /*
	   * If the exchange was correctly initialized, add the original
	   * finalization routine; otherwise, call it directly.
	   */
	  if (exchange)
	    exchange_add_finalization (exchange, finalize, arg);
	  else
	    finalize (0, arg, 1); /* Indicate failure */
	  return;
	}
      else
	exchange_establish_p2 (isakmp_sa, 0, name, 0, finalize, arg);
      break;

    default:
      log_print ("exchange_establish: "
		 "peer \"%s\" does not have a correct phase (%d)",
		 name, phase);
      break;
    }
@


1.91
log
@check for isakmp_sa->transport != NULL; noticed by bluhm at genua.de ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.90 2004/02/05 11:01:54 hshoexer Exp $	*/
d1197 1
a1197 1
  int bufsize_max = LOG_SIZE - strlen (header) - 32;
@


1.91.2.1
log
@MFC:
Fix by cloder@@

Avoid crash on finalization.  We have been using this diff
in production since mid-2003.

ok deraadt@@ cloder@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.91 2004/02/16 20:40:34 markus Exp $	*/
d1842 1
a1842 1
	  else if (finalize)
@


1.90
log
@small logging cleanup and improvement requested by markus
ok ho@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.89 2004/01/16 10:51:57 hshoexer Exp $	*/
d1521 1
a1521 1
      if (msg->isakmp_sa)
@


1.89
log
@Added -v option.  Enables logging of successful exchange completion.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.88 2003/11/06 16:12:07 ho Exp $	*/
d1396 1
d1513 18
a1530 16
      LOG_DBG ((LOG_EXCHANGE, 10,
		"exchange_finalize: phase 1 done: %s, %s",
		!exchange->doi ? "<no doi>" :
		exchange->doi->decode_ids ("initiator id %s, responder id %s",
					   exchange->id_i, exchange->id_i_len,
					   exchange->id_r, exchange->id_r_len,
					   0),
		!msg->isakmp_sa || !msg->isakmp_sa->transport
		? "<no transport>"
		: msg->isakmp_sa->transport->vtbl->decode_ids (msg->isakmp_sa
							       ->transport)));
      log_verbose ("isakmpd: phase 1 done: %s",
	           !msg->isakmp_sa || !msg->isakmp_sa->transport
		   ? "<no transport>"
		   : msg->isakmp_sa->transport->vtbl->decode_ids
		   (msg->isakmp_sa ->transport));
@


1.88
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.87 2003/11/06 15:55:54 ho Exp $	*/
d1523 5
@


1.87
log
@Require encrypted messages are soon as we have the keystate for it.
Require DELETE payloads to be accompanied by HASHes, and add validation
for HASH payloads without active exchanges.
From Hans-Joerg Hoexer with various modifications and suggestions from me
and markus@@. Ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.86 2003/10/14 14:29:15 ho Exp $	*/
d1040 1
a1040 1
      if (sockaddr2text(dst, &str, 0) == -1)
d1696 1
a1696 1
	    free(cert);
d1705 1
a1705 1
	    free(cert);
@


1.86
log
@constant_lookup() to constant_name() cleanup. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.85 2003/09/25 14:15:15 cloder Exp $	*/
d223 4
a226 2
	      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NOTIFY])
	      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])))
@


1.85
log
@Fix one case of set length before realloc.  Fix another case of
foo = realloc(foo...) and avoid possible memory leaks.  Avoid
leaving things pointing to freed memory on failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.84 2003/08/08 08:46:59 ho Exp $	*/
d1021 1
a1021 1
  char *name = 0, *policy = 0, *str, *tag;
a1100 3
	  tag = constant_lookup (isakmp_exch_cst,
				 GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0]
							   .iov_base));
d1102 4
a1105 2
		     str, tag ? tag : "<unknown>");
		     
@


1.84
log
@Be more careful when using constant_lookup() in messages. Pointed out by
Jean-Francois Dive, although I opted for a slightly different patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.83 2003/06/15 10:32:15 ho Exp $	*/
d1669 1
a1669 1
  u_int8_t *cert;
d1694 2
d1698 2
a1699 2
      cert = realloc (cert, ISAKMP_CERT_SZ + certlen);
      if (!cert)
d1703 2
d1707 1
@


1.84.2.1
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.84 2003/08/08 08:46:59 ho Exp $	*/
d223 2
a224 4
	      && ((!TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NOTIFY])
		   && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE]))
	          || (TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])
		      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH])))))
@


1.83
log
@ID copying should happen earlier in exchange_finalize so that we won't lose
data during rekeying. From Jean-Francois Dive.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.82 2003/06/10 16:41:29 deraadt Exp $	*/
d1021 1
a1021 1
  char *name = 0, *policy = 0, *str;
d1101 3
d1105 2
a1106 4
		     str,
		     constant_lookup (isakmp_exch_cst,
				      GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0]
								.iov_base)));
@


1.82
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.81 2003/06/04 07:31:16 ho Exp $	*/
d1399 19
a1520 19
    }

  /* Copy the ID from phase 1 to exchange or phase 2 SA.  */
  if (msg->isakmp_sa)
    {
      if (exchange->id_i && exchange->id_r)
	{
	  ipsec_clone_id (&msg->isakmp_sa->id_i, &msg->isakmp_sa->id_i_len,
			  exchange->id_i, exchange->id_i_len);
	  ipsec_clone_id (&msg->isakmp_sa->id_r, &msg->isakmp_sa->id_r_len,
			  exchange->id_r, exchange->id_r_len);
	}
      else if (msg->isakmp_sa->id_i && msg->isakmp_sa->id_r)
	{
	  ipsec_clone_id (&exchange->id_i, &exchange->id_i_len,
			  msg->isakmp_sa->id_i, msg->isakmp_sa->id_i_len);
	  ipsec_clone_id (&exchange->id_r, &exchange->id_r_len,
			  msg->isakmp_sa->id_r, msg->isakmp_sa->id_r_len);
	}
@


1.81
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.80 2003/06/03 12:51:38 ho Exp $	*/
d1677 2
a1678 2
   * Without IDs we cannot handle this yet. Keep the aca_list around for 
   * a later step/retry to see if we got the ID by then. 
@


1.80
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.79 2003/05/15 02:28:55 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.79
log
@Cleanup. Do not store the private key in either the exchange or sa structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.78 2003/03/06 13:32:42 ho Exp $	*/
d1580 2
a1581 1
  snprintf (header, 32, "exchange_nonce: NONCE_%c", initiator ? 'i' : 'r');
@


1.78
log
@Bad cut'n'paste msg plus style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.77 2003/02/26 08:17:59 david Exp $	*/
a1301 3
  if (exchange->sent_key)
    key_free (exchange->sent_keytype, ISAKMP_KEYTYPE_PRIVATE,
	      exchange->sent_key);
a1470 1
      msg->isakmp_sa->sent_keytype = exchange->sent_keytype;
a1471 1
      msg->isakmp_sa->sent_key = exchange->sent_key;
a1474 1
      exchange->sent_key = 0;
@


1.78.2.1
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.78 2003/03/06 13:32:42 ho Exp $	*/
d228 2
a229 4
	      && ((!TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NOTIFY])
		   && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE]))
	          || (TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])
		      && !TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH])))))
@


1.77
log
@IPsec is written ``IPsec'', not ``IPSec''.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.76 2003/01/09 02:50:00 ho Exp $	*/
d789 1
a789 1
	      log_print ("exchange_establish_p1: unknown exchange type %s",
d1836 1
a1836 3
	    {
	      exchange_add_finalization (exchange, finalize, arg);
	    }
d1838 2
a1839 4
	    {
	      finalize (0, arg, 1); /* Indicate failure */
	    }
      return;
@


1.76
log
@Add some #ifdef USE_ISAKMP_CFG, no need to compile in code that will
never be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.75 2003/01/09 02:34:43 ho Exp $	*/
d1690 1
a1690 1
   *       with some IPSec clients that send CERTREQs early (ex SSH Sentinel).
@


1.75
log
@Enable SET/ACK (ike-mode-cfg) when acting as responder. From Tomas
Walpuski.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.74 2002/11/21 12:09:20 ho Exp $	*/
d718 1
d733 1
d744 1
d747 1
d818 1
d851 2
d1022 1
d1025 1
d1128 1
d1160 2
@


1.74
log
@-Wshadow nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.73 2002/11/15 14:58:38 ho Exp $	*/
d1015 2
d1118 32
@


1.73
log
@Missing "Configuration" tag in a Phase-1 peer was not handled correctly,
pointed out by Aref Taidi. Replace this with a "Default-Phase-1-Configuration"
that will be used if this tag is missing from the peer. Update manpage
accordingly. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.72 2002/11/08 10:16:30 ho Exp $	*/
d1501 1
a1501 1
      struct sa *sa = TAILQ_FIRST (&exchange->sa_list);
@


1.72
log
@I missed a 'return' statement. Also spotted by Aref Taidi. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.71 2002/11/06 23:57:36 ho Exp $	*/
d758 2
a759 13
	      /* Use default setting */
	      tag = conf_get_str ("Phase 1", "Default");
	      if (!tag)
		{
		  log_print ("exchange_establish_p1: "
			     "no \"Default\" tag in [Phase 1] section");
		  return;
		}
#if 0
	      log_print ("exchange_establish_p1: "
			 "no configuration found for peer \"%s\"",
			 name);
#endif
d812 1
a812 1
    exchange->policy = conf_get_str ("Phase 1", "Default");
d1059 1
a1059 5
	{
	  log_print ("exchange_setup_p1: no configuration for peer \"%s\"",
		     name);
	  return 0;
	}
@


1.71
log
@More careful will alloc/free. Spotted by Aref Taidi.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.70 2002/09/11 09:50:43 ho Exp $	*/
d869 1
@


1.70
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.69 2002/09/05 17:30:03 ho Exp $	*/
d865 5
d886 1
@


1.69
log
@Without IDs wait until next step/retry to handle CERTREQs. This should
make certificate auth work better with some clients, such as SSH Sentinel.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.68 2002/09/05 14:54:16 ho Exp $	*/
d174 1
a174 1
u_int16_t *
@


1.68
log
@Do not create SAs for transaction exchanges either. By niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.67 2002/06/10 18:08:58 ho Exp $	*/
d1647 9
@


1.67
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.66 2002/06/07 19:53:19 ho Exp $	*/
d988 2
a989 1
  if (exchange->type != ISAKMP_EXCH_INFO)
@


1.66
log
@Start for support of IKECFG in SET/ACK mode. Server side only so far.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.65 2002/06/01 07:44:21 deraadt Exp $	*/
d1271 1
a1271 1
    LK (kn_close, (exchange->policy_id));
@


1.65
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.64 2002/01/23 18:24:34 ho Exp $	*/
d7 1
a7 1
 * Copyright (c) 1999, 2000 Håkan Olsson.  All rights reserved.
d718 15
d742 2
d825 33
a857 2
  exchange->finalize = finalize;
  exchange->finalize_arg = arg;
d867 3
a869 2
  /* Do not create SA for an information exchange.  */
  if (exchange->type != ISAKMP_EXCH_INFO)
a1444 2
      msg->isakmp_sa->id_i_len = exchange->id_i_len;
      msg->isakmp_sa->id_r_len = exchange->id_r_len;
a1475 5
  exchange->doi->finalize_exchange (msg);
  if (exchange->finalize)
    exchange->finalize (exchange, exchange->finalize_arg, 0);
  exchange->finalize = 0;

d1494 5
@


1.64
log
@snprintf, and only dump exchange data if USE_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.63 2002/01/03 16:27:41 ho Exp $	*/
d617 2
a618 1
      log_error ("exchange_create: calloc (1, %d) failed", sizeof *exchange);
d640 2
a641 2
	  log_error ("exchange_create: calloc (1, %d) failed",
		     exchange->doi->exchange_size);
d705 2
a706 2
      log_error ("exchange_add_finalization: malloc (%d) failed",
		 sizeof *node);
d1496 1
a1496 1
      log_error ("exchange_nonce: malloc (%d) failed", nonce_sz);
d1515 2
a1516 2
      log_error ("exchange_gen_nonce: malloc (%d) failed",
		 ISAKMP_NONCE_SZ + nonce_sz);
@


1.63
log
@str[n]{cpy,cat} -> strl{cpy,cat}, sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.62 2001/08/25 22:13:27 niklas Exp $	*/
d811 1
d813 1
d930 1
d932 1
d1078 1
d1080 1
d1098 1
d1100 1
d1132 1
a1132 1
	sprintf (buf + strlen (buf), "%p ", sa);
d1314 1
d1316 1
@


1.62
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.61 2001/08/22 07:09:03 angelos Exp $	*/
d1121 1
a1121 1
      sprintf (buf, "sa_list ");
d1126 1
a1126 1
	strcat (buf, "...");
d1276 1
a1276 1
    strncpy (res1, ipsec_decode_ids ("%s %s", sa->id_i, sa->id_i_len, sa->id_r,
d1279 1
a1279 1
    strncpy (res1, ipsec_decode_ids ("%s %s", sa->id_r, sa->id_r_len, sa->id_i,
a1280 1
  res1[sizeof res1 - 1] = '\0';
@


1.61
log
@Need an extra sa_release() when de-allocating exchange-associated SAs;
thus, failed exchanges/negotiations don't leak SAs and transports. ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.60 2001/08/15 13:06:53 ho Exp $	*/
d1394 2
a1395 2
	    msg->isakmp_sa->recv_cert =
	      handler->cert_dup (exchange->recv_cert);
d1402 2
a1403 2
	    msg->isakmp_sa->sent_cert =
	      handler->cert_dup (exchange->sent_cert);
@


1.60
log
@Some more style...
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.59 2001/08/11 05:27:36 angelos Exp $	*/
d1223 1
a1223 1
  /* Remove any SAs that has not been disassociated from us.  */
d1227 3
@


1.59
log
@Fix keynote credential case again.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.58 2001/07/05 12:36:50 ho Exp $	*/
d1211 1
a1211 1
#if defined(POLICY) || defined(KEYNOTE)
@


1.58
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.57 2001/07/03 12:51:39 markus Exp $	*/
d1381 1
a1382 1
      msg->isakmp_sa->policy_id = exchange->policy_id;
@


1.57
log
@strlcpy->strncpy for now
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.56 2001/07/01 19:48:43 niklas Exp $	*/
d83 4
d419 4
a422 2
void
exchange_resize ()
d439 1
d491 1
a491 1
struct exchange *
@


1.56
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.55 2001/07/01 06:03:34 angelos Exp $	*/
d1266 1
a1266 1
    strlcpy (res1, ipsec_decode_ids ("%s %s", sa->id_i, sa->id_i_len, sa->id_r,
d1269 1
a1269 1
    strlcpy (res1, ipsec_decode_ids ("%s %s", sa->id_r, sa->id_r_len, sa->id_i,
d1271 1
@


1.55
log
@Remove inaccurate "Assumes IPv4" comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.54 2001/06/29 19:59:51 niklas Exp $	*/
d797 1
a797 1
  if ((exchange->policy == NULL) && name)
d1261 1
a1261 1
  if (sa->phase != new_sa->phase || new_sa->name == NULL
d1369 5
a1373 3
      exchange->recv_key = NULL; /* Reset */
      exchange->sent_key = NULL; /* Reset */
      exchange->keynote_key = NULL; /* Reset */
a1374 1
      exchange->policy_id = -1; /* Reset */
d1397 1
a1397 1
		exchange->doi == NULL ? "<no doi>" :
d1402 1
a1402 1
		msg->isakmp_sa == NULL || msg->isakmp_sa->transport == NULL
@


1.54
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.53 2001/06/29 19:55:51 niklas Exp $	*/
a971 2
       * XXX Assumes IPv4.  It might make sense to search through several
       * policies too.
@


1.53
log
@more AF-independence
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.52 2001/06/29 18:52:16 ho Exp $	*/
d976 1
a976 1
      if (sockaddr2text(dst, &addr, 0) == -1)
d978 2
a979 2
      name = conf_get_str ("Phase 1", addr);
      free (addr);
@


1.52
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.51 2001/06/27 00:48:21 angelos Exp $	*/
d58 3
d187 4
d976 4
a979 2
      name = conf_get_str ("Phase 1",
			   inet_ntoa (((struct sockaddr_in *)dst)->sin_addr));
d1546 1
a1546 1
/* Free the list of pending CERTREQ.  */
@


1.51
log
@Keep track of the ACQUIRE sequence number, and pass it to the kernel
along with the ADD message.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.50 2001/06/05 10:14:56 angelos Exp $	*/
a949 1
  int dst_len;
d968 1
a968 1
      t->vtbl->get_dst (t, &dst, &dst_len);
@


1.50
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.49 2001/06/05 05:59:43 niklas Exp $	*/
d1342 1
@


1.49
log
@Style issues and commentary
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.48 2001/06/05 01:29:05 angelos Exp $	*/
d1687 1
a1687 1
	      log_error ("exchange_establish: strdup(\"%s\") failed", name);
@


1.48
log
@Dynamically allocate conn, as this is given to the exchange; cleanup
conf space on failure to establish dynamic SA. ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.47 2001/05/31 20:25:10 angelos Exp $	*/
d205 1
a205 1
      LOG_DBG ((LOG_EXCHANGE, 90, 
d320 1
a320 1
	}      
d351 1
a351 1
			LOG_DBG ((LOG_EXCHANGE, 10, 
d381 1
a381 1
      LOG_DBG ((LOG_EXCHANGE, 40, 
d405 1
a405 1
 
d463 1
a463 1
	/* 
d502 1
a502 1
	      LOG_DBG ((LOG_EXCHANGE, 80, 
d867 1
a867 1
      
d916 3
a918 3
  /* 
   * Do not create SA's for informational exchanges. 
   * XXX How to handle new group mode? 
d934 1
a934 1
  
d1090 1
a1090 1
  int bufsize_max = LOG_SIZE - strlen (header) - 32; 
d1093 1
a1093 1
  LOG_DBG ((class, level, 
d1099 1
a1099 1
  LOG_DBG ((class, level, 
d1109 1
a1109 1
      for (sa = TAILQ_FIRST (&exchange->sa_list); 
d1118 1
a1118 1
  LOG_DBG ((class, level, "%s: msgid %08x %s", header, 
d1152 1
a1152 1
  LOG_DBG ((LOG_EXCHANGE, 80, "exchange_free_aux: freeing exchange %p", 
d1251 2
a1252 2
  if (sa == new_sa || !sa->name || !(sa->flags & SA_FLAG_READY) || 
      (sa->flags & SA_FLAG_REPLACED))
d1255 2
a1256 2
  if (sa->phase != new_sa->phase || new_sa->name == NULL ||
      strcasecmp (sa->name, new_sa->name))
d1267 1
a1267 2
	    "checking whether new SA replaces existing SA with IDs %s",
	    res1));
d1271 1
a1271 2
					       new_sa->id_i_len,
					       new_sa->id_r,
d1275 1
a1275 2
					       new_sa->id_r_len,
					       new_sa->id_i,
d1396 2
a1397 1
		: msg->isakmp_sa->transport->vtbl->decode_ids (msg->isakmp_sa->transport)));
d1405 2
a1406 2
  /* copy the ID from phase 1 to exchange or phase 2 SA */
  if (msg->isakmp_sa) 
d1408 1
a1408 1
      if (exchange->id_i && exchange->id_r) 
d1521 1
a1521 1
  struct certreq_aca *tmp;
d1526 1
a1526 1
      tmp = certreq_decode (GET_ISAKMP_CERTREQ_TYPE (cp->p),
d1528 1
a1528 1
			    GET_ISAKMP_GEN_LENGTH (cp->p) - 
d1530 2
a1531 3
      if (!tmp)
	continue;
      TAILQ_INSERT_TAIL (&exchange->aca_list, tmp, link);
d1537 1
a1537 2
/* Free the list of pending CERTREQ */

d1571 1
a1571 1
  for (aca = TAILQ_FIRST (&exchange->aca_list); aca; 
d1574 1
a1574 1
      /* XXX? If we can not satisfy a CERTREQ we drop the message */
d1598 1
a1598 1
  /* We dont need the CERT REQs any more, they are anwsered */
@


1.47
log
@Copy the new information from the exchange to the sa at the end of the
exchange, and generalize certificate copying by taking advantage of
the new routines in the cert handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.46 2001/05/05 00:48:11 angelos Exp $	*/
d1710 14
@


1.46
log
@Add comment about finalize routine processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.45 2001/04/24 07:27:36 niklas Exp $	*/
d66 1
a66 3
#ifdef USE_X509
#include "x509.h"
#endif
d1182 6
a1187 2
      else if (exchange->recv_certtype == ISAKMP_CERTENC_NONE)
	free (exchange->recv_cert);
d1190 7
a1196 1
    free (exchange->recv_key);
d1290 1
d1359 3
a1361 1
      msg->isakmp_sa->recv_certlen = exchange->recv_certlen;
d1363 2
d1366 2
d1374 9
a1382 1
      switch (exchange->recv_certtype)
d1384 4
a1387 38
        case ISAKMP_CERTENC_NONE:
	case ISAKMP_CERTENC_KEYNOTE: /* No need for special handling */
	    msg->isakmp_sa->recv_cert = malloc (exchange->recv_certlen);
	    if (!msg->isakmp_sa->recv_cert)
	      {
		log_error ("exchange_finalize: malloc (%d) failed",
			   exchange->recv_certlen);
		/* XXX How to cleanup?  */
		return;
	      }
	    memcpy (msg->isakmp_sa->recv_cert, exchange->recv_cert,
		    msg->isakmp_sa->recv_certlen);
	    break;

	case ISAKMP_CERTENC_X509_SIG:
#ifdef USE_X509
	    msg->isakmp_sa->recv_cert = LC (X509_dup,
					    ((X509 *) exchange->recv_cert));
	    if (!msg->isakmp_sa->recv_cert)
	      {
		log_print ("exchange_finalize: "
			   "failed copying X509 certificate to isakmp_sa");
		/* XXX How to cleanup?  */
		return;
	      }
	    break;
#endif

	    /* XXX Eventually handle these */
	case ISAKMP_CERTENC_PKCS:
	case ISAKMP_CERTENC_PGP:	
	case ISAKMP_CERTENC_DNS:
	case ISAKMP_CERTENC_X509_KE:
	case ISAKMP_CERTENC_KERBEROS:
	case ISAKMP_CERTENC_CRL:
	case ISAKMP_CERTENC_ARL:
	case ISAKMP_CERTENC_SPKI:
	case ISAKMP_CERTENC_X509_ATTR:
@


1.45
log
@Correct SA refcounting.  Fixes a bug where isakmpd could die when a peer was
discovered to have rebooted, and old now invalid SAs had to be garbage-
collected.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.44 2001/04/09 22:09:51 ho Exp $	*/
d1713 7
@


1.44
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.43 2001/04/08 21:23:02 ho Exp $	*/
d820 1
a820 2
      else
        sa_reference (msg->isakmp_sa);
d934 1
a935 1
  msg->isakmp_sa = isakmp_sa;
d1456 1
a1456 4

      /* Only release the SA if it is time-expired */
      if (sa->refcnt > 1)
	sa_release (sa);
@


1.43
log
@log_print, not log_error
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.42 2001/03/28 22:33:48 angelos Exp $	*/
d634 1
a634 1
  gettimeofday(&expiration, 0);
@


1.42
log
@Take into consideration the IDs when determining whether two Phase 1
SAs match.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.41 2001/02/24 03:59:54 angelos Exp $	*/
d1712 1
a1712 1
	      log_error ("exchange_establish: "
@


1.41
log
@For the GETSPI PFKEY message, use the sequence number from the ACQUIRE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.40 2001/01/27 12:03:32 niklas Exp $	*/
d1242 2
a1243 1
  
d1248 25
a1272 2
  return sa->phase == new_sa->phase && new_sa->name &&
    strcasecmp (sa->name, new_sa->name) == 0;
@


1.40
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.39 2001/01/26 12:12:51 niklas Exp $	*/
d841 1
d857 2
d912 1
@


1.39
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.38 2001/01/22 08:37:05 angelos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
@


1.38
log
@Fix comment and error message reporting.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.37 2000/12/12 01:45:17 niklas Exp $	*/
d641 1
a641 1
      /* If we don't give up we might start leaking... */
d1088 1
a1088 1
  /* Don't risk overflowing the final log buffer. */
d1647 1
a1647 1
	  /* Phase 1 transport defaults to "udp". */
@


1.37
log
@Merge with EOM 1.143

author: angelos
Careful when copying IDs.

author: angelos
Oops, what am I thinking ?

author: angelos
Ooops again, I reverted the wrong patch.

author: angelos
Oops, shouldn't have committed this.

author: angelos
x509_hash() should also skip the cert length (willey@@serasystems.com)

author: angelos
If it's a dynamically established Phase 2 SA, don't keep a copy of it
in isakmpd (the kernel keeps track of everything in this case).

author: angelos
Comment.

author: angelos
If no time-based lifetime was negotiated, don't release the SA.
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.36 2000/12/02 02:09:26 angelos Exp $	*/
d1199 1
a1199 1
  /* Remove any SAs that has not been dissociated from us.  */
d1339 2
a1340 2
		log_error ("exchange_finalize: strdup (\"%s\") failed",
			   exchange->recv_cert);
@


1.36
log
@Add comment.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.35 2000/12/02 02:08:17 angelos Exp $	*/
/*	$EOM: exchange.c,v 1.134 2000/10/16 18:16:58 provos Exp $	*/
d1420 7
a1426 4
      ipsec_clone_id (&sa->id_i, &sa->id_i_len, exchange->id_i,
		      exchange->id_i_len);
      ipsec_clone_id (&sa->id_r, &sa->id_r_len, exchange->id_r,
		      exchange->id_r_len);
@


1.35
log
@Manual sync with EOM -- only release an SA if it's referenced by the
timeout routine (should there be a default expiration if none is
negotiated ?)
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.34 2000/10/16 23:27:33 niklas Exp $	*/
d1426 2
d1429 1
a1429 1
        sa_release (sa);
@


1.34
log
@Merge with EOM 1.134

author: provos
better referencing.  okay niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.33 2000/10/09 23:27:11 niklas Exp $	*/
a1409 1

d1426 2
a1427 1
      sa_release (sa);
@


1.34.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.45 2001/04/24 07:27:36 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.143 2000/12/04 00:02:25 angelos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2001 Angelos D. Keromytis.  All rights reserved.
d634 1
a634 1
  gettimeofday (&expiration, 0);
d641 1
a641 1
      /* If we don't give up we might start leaking...  */
d820 2
a821 1
      sa_reference (msg->isakmp_sa);
a840 1
  u_int32_t seq = 0;
a855 2
      seq = (u_int32_t) conf_get_num (name, "Acquire-ID", 0);

a908 1
  exchange->seq = seq;
d931 1
a932 1
  sa_reference (isakmp_sa);
d1088 1
a1088 1
  /* Don't risk overflowing the final log buffer.  */
d1199 1
a1199 1
  /* Remove any SAs that has not been disassociated from us.  */
d1238 1
a1238 2
  char res1[1024];

d1243 2
a1244 25
  if (sa->phase != new_sa->phase || new_sa->name == NULL ||
      strcasecmp (sa->name, new_sa->name))
    return 0;

  if (sa->initiator)
    strlcpy (res1, ipsec_decode_ids ("%s %s", sa->id_i, sa->id_i_len, sa->id_r,
				     sa->id_r_len, 0), sizeof res1);
  else
    strlcpy (res1, ipsec_decode_ids ("%s %s", sa->id_r, sa->id_r_len, sa->id_i,
				     sa->id_i_len, 0), sizeof res1);

  LOG_DBG ((LOG_EXCHANGE, 30,
	    "checking whether new SA replaces existing SA with IDs %s",
	    res1));

  if (new_sa->initiator)
    return strcasecmp (res1, ipsec_decode_ids ("%s %s", new_sa->id_i,
					       new_sa->id_i_len,
					       new_sa->id_r,
					       new_sa->id_r_len, 0)) == 0;
  else
    return strcasecmp (res1, ipsec_decode_ids ("%s %s", new_sa->id_r,
					       new_sa->id_r_len,
					       new_sa->id_i,
					       new_sa->id_i_len, 0)) == 0;
d1339 2
a1340 2
		log_error ("exchange_finalize: malloc (%d) failed",
			   exchange->recv_certlen);
d1410 1
d1421 4
a1424 7
      if (exchange->id_i && exchange->id_r)
	{
          ipsec_clone_id (&sa->id_i, &sa->id_i_len, exchange->id_i,
		          exchange->id_i_len);
          ipsec_clone_id (&sa->id_r, &sa->id_r_len, exchange->id_r,
		          exchange->id_r_len);
	}
d1642 1
a1642 1
	  /* Phase 1 transport defaults to "udp".  */
d1679 1
a1679 1
	      log_print ("exchange_establish: "
@


1.33
log
@Merge with EOM 1.133

author: angelos
Use Default entry for Phase 1 configuration if none is found.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.32 2000/10/07 06:57:43 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.133 2000/10/09 02:54:34 angelos Exp $	*/
d1427 1
@


1.32
log
@Merge with EOM 1.132

author: niklas
style

author: ho
(c)-2000

author: provos
proper reference counting for isakmp_sa in struct message, remove bogus
calls to sa_reference; fix some more memory leaks in conf.c
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.31 2000/08/03 07:25:24 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.132 2000/10/06 23:36:11 niklas Exp $	*/
d728 1
a728 2
	      /* XXX I am not sure a default should be used.  */
#if 0
d736 1
a736 1
#else
d790 1
d792 3
@


1.31
log
@Merge with EOM 1.129

author: provos
dont strdup exchange->recv_cert, it is not always a 0 terminated string
for CERTENC_NONE.  we need to malloc and memcpy instead.  found by
electric fence.

author: provos
provide transport dependent ID decoding; hope indentation is right now ;)

author: ho
ISAKMP peer transport defaults to UDP.

author: provos
make a DOI specific decode_ids, but have isakmp doi decode point to
ipsec.

author: provos
indent

author: provos
introduce ipsec_decode_ids, also decodes FQDN and USER_FQDN now.
new ipsec_clone_id to copy IDs to phase 2 SAs for better status
reports. okay angelos@@
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.30 2000/06/08 20:49:54 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.129 2000/07/20 15:29:17 provos Exp $	*/
d7 1
d817 2
d928 1
@


1.30
log
@Merge with EOM 1.123

author: angelos
Reset policy_id and recv_key after we've moved them over from the
exchange to the isakmp_sa, so they don't get free'ed.

author: angelos
Allow exchange of KeyNote credentials over IKE. Multiple credentials
may be passed in a single CERT payload. KeyNote is used if a
directory named as the local ID we use in an exchange exists in the
KeyNote directory (default: /etc/isakmpd/keynote/). Note that
asymmetric credentials are possible (use KeyNote in one direction and
X509 in the other); such authentication is envisioned to be the most
common: the clients will use KeyNote credentials to authenticate and
authorize with a server, whilst the server will just provide an X509
certificate proving its binding to the IP address or ID.

Totally asymmetric authentication (e.g., shared key in one direction,
RSA in the other) is not supported by the IKE protocol.

author: angelos
Add CERTENC_KEYNOTE.

author: ho
DOI IPSEC is default if not specified.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.29 2000/04/07 22:07:30 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.123 2000/05/19 06:31:45 angelos Exp $	*/
d62 1
a1324 20
      msg->isakmp_sa->id_i = malloc (exchange->id_i_len);
      if (!msg->isakmp_sa->id_i)
	{
	  log_error ("exchange_finalize: malloc (%d) failed",
		     exchange->id_i_len);
	  /* XXX How to cleanup?  */
	  return;
	}
      msg->isakmp_sa->id_r = malloc (exchange->id_r_len);
      if (!msg->isakmp_sa->id_r)
	{
	  log_error ("exchange_finalize: malloc (%d) failed",
		     exchange->id_r_len);
	  /* XXX How to cleanup?  */
	  return;
	}

      memcpy (msg->isakmp_sa->id_i, exchange->id_i, exchange->id_i_len);
      memcpy (msg->isakmp_sa->id_r, exchange->id_r, exchange->id_r_len);

d1329 1
a1329 1
	    msg->isakmp_sa->recv_cert = strdup (exchange->recv_cert);
d1337 2
d1366 11
d1384 20
d1411 10
a1420 1
    TAILQ_REMOVE (&exchange->sa_list, TAILQ_FIRST (&exchange->sa_list), next);
d1634 2
a1635 3
	  log_print ("exchange_establish: No transport given for peer \"%s\"",
		     name);
	  return;
@


1.29
log
@Merge with EOM 1.119

author: niklas
log_fatal is only OK during initialization

author: ho
Missing #ifdef USE_X509 added

author: ho
Add #ifdef USE_X509
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.28 2000/02/25 17:23:39 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.119 2000/04/07 19:16:44 niklas Exp $	*/
d613 1
d744 3
a746 7
	  if (!str)
	    {
	      log_print ("exchange_establish_p1: "
			 "no \"DOI\" tag in [%s] section", tag);
	      return;
	    }
	  if (strcasecmp (str, "ISAKMP") == 0)
a747 2
	  else if (strcasecmp (str, "IPSEC") == 0)
	    doi = IPSEC_DOI_IPSEC;
d851 5
a855 1
      if (str)
d857 2
a858 7
	  if (strcasecmp (str, "IPSEC") == 0)
	    doi = IPSEC_DOI_IPSEC;
	  else
	    {
	      log_print ("exchange_establish_p2: DOI \"%s\" unsupported", str);
	      return;
	    }
d860 1
a860 1

d994 3
a996 7
      if (!str)
	{
	  log_print ("exchange_setup_p1: no \"DOI\" tag in [%s] section",
		     policy);
	  return 0;
	}
      if (strcasecmp (str, "ISAKMP") == 0)
a997 2
      else if (strcasecmp (str, "IPSEC") == 0)
	want_doi = IPSEC_DOI_IPSEC;
d1176 8
d1316 4
d1347 1
a1381 1
/*      case ISAKMP_CERTENC_KEYNOTE: */
@


1.28
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.27 2000/02/19 19:31:32 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.116 2000/02/20 19:58:37 niklas Exp $	*/
d64 1
d66 1
d1324 16
a1339 6
      msg->isakmp_sa->id_i = calloc (exchange->id_i_len, sizeof (char));
      if (msg->isakmp_sa->id_i == NULL)
	log_fatal ("exchange_finalize: failed to allocate memory for copying id_i (%d bytes)", exchange->id_i_len);
      msg->isakmp_sa->id_r = calloc (exchange->id_r_len, sizeof (char));
      if (msg->isakmp_sa->id_r == NULL)
	log_fatal ("exchange_finalize: failed to allocate memory for copying id_r (%d bytes)", exchange->id_r_len);
d1348 7
a1354 3
	    if (msg->isakmp_sa->recv_cert == NULL)
	      log_fatal ("exchange_finalize: strdup (\"%s\") failed",
			 exchange->recv_cert);
d1358 1
d1361 7
a1367 3
	    if (msg->isakmp_sa->recv_cert == NULL)
	      log_fatal ("exchange_finalize: "
			 "failed copying X509 certificate to isakmp_sa");
d1369 1
@


1.27
log
@Makefile: Merge with EOM 1.61
crypto.c: Merge with EOM 1.27
exchange.c: Merge with EOM 1.115
ike_quick_mode.c: Merge with EOM 1.115
x509.c: Merge with EOM 1.35
features/ec: Merge with EOM 1.1
features/aggressive: Merge with EOM 1.1
features/policy: Merge with EOM 1.1
features/x509: Merge with EOM 1.1

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.26 2000/02/01 02:46:17 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.115 2000/02/19 07:46:30 niklas Exp $	*/
d203 5
a207 5
      log_debug (LOG_EXCHANGE, 90, 
		 "exchange_validate: checking for required %s",
		 *pc >= ISAKMP_PAYLOAD_NONE
		 ? constant_name (isakmp_payload_cst, *pc)
		 : constant_name (exchange_script_cst, *pc));
d219 5
a223 5
	  log_debug (LOG_MESSAGE, 70,
		     "exchange_validate: msg %p requires missing %s", msg,
		     *pc >= ISAKMP_PAYLOAD_NONE
		     ? constant_name (isakmp_payload_cst, *pc)
		     : constant_name (exchange_script_cst, *pc));
d349 3
a351 3
			log_debug (LOG_EXCHANGE, 10, 
				   "exchange_run: unexpected payload %s",
				   constant_name (isakmp_payload_cst, i));
d379 3
a381 3
      log_debug (LOG_EXCHANGE, 40, 
		 "exchange_run: exchange %p finished step %d, advancing...",
		 exchange, exchange->step);
d456 4
a459 4
	log_debug (LOG_EXCHANGE, 90,
		   "exchange_lookup_by_name: %s == %s && %d == %d?", name,
		   exchange->name ? exchange->name : "<unnamed>", phase,
		   exchange->phase);
d490 4
a493 4
	log_debug (LOG_EXCHANGE, 90,
		   "exchange_lookup_active: %s == %s && %d == %d?",
		   name, exchange->name ? exchange->name : "<unnamed>", phase,
		   exchange->phase);
d500 3
a502 3
	      log_debug (LOG_EXCHANGE, 80, 
			 "exchange_lookup_active: avoided early (pre-step 1) "
			 "exchange %p", exchange);
d1094 11
a1104 11
  log_debug (class, level, 
	     "%s: %p %s %s policy %s phase %d doi %d exchange %d step %d",
	     header, exchange, exchange->name ? exchange->name : "<unnamed>",
	     exchange->policy ? exchange->policy : "<no policy>",
	     exchange->initiator ? "initiator" : "responder", exchange->phase,
	     exchange->doi->id, exchange->type, exchange->step);
  log_debug (class, level, 
	     "%s: icookie %08x%08x rcookie %08x%08x", header,
	     decode_32 (exchange->cookies), decode_32 (exchange->cookies + 4),
	     decode_32 (exchange->cookies + 8),
	     decode_32 (exchange->cookies + 12));
d1119 2
a1120 2
  log_debug (class, level, "%s: msgid %08x %s", header, 
	     decode_32 (exchange->message_id), buf);
d1153 2
a1154 2
  log_debug (LOG_EXCHANGE, 80, "exchange_free_aux: freeing exchange %p", 
	     exchange);
d1403 1
a1403 1
  log_debug_buf (LOG_EXCHANGE, 80, header, *nonce, nonce_sz);
d1542 4
a1545 4
  log_debug (LOG_EXCHANGE, 20,
	     "exchange_establish_finalize: "
	     "finalizing exchange %p with arg %p (%s) & fail = %d",
	     exchange, arg, name ? name : "<unnamed>", fail);
d1576 3
a1578 3
      log_debug (LOG_EXCHANGE, 40,
		 "exchange_establish: %s exchange already exists as %p", name,
		 exchange);
@


1.26
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.25 2000/01/26 15:20:29 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.114 2000/01/31 22:33:44 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
d138 1
d154 1
d176 1
d179 1
@


1.25
log
@Merge with EOM 1.113

author: ho
Lower common log message from log_print to log_debug 'level'.

author: niklas
style & wording
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.24 1999/08/26 22:32:16 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.113 1999/11/28 17:46:28 ho Exp $	*/
d6 1
@


1.24
log
@Merge with EOM 1.111

author: niklas
Check that ISAKMP-peer's are phase 1

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.23 1999/07/17 21:54:39 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.111 1999/08/20 11:57:29 niklas Exp $	*/
d56 1
d344 2
a345 1
			log_print ("exchange_run: unexpected payload %s",
d1332 2
a1333 1
	      log_fatal ("exchange_finalize: failed copying shared secret to isakmp_sa");
d1340 2
a1341 1
	      log_fatal ("exchange_finalize: failed copying X509 certificate to isakmp_sa");
@


1.23
log
@regress/rsakeygen/Makefile: Merge with EOM 1.4
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.6
regress/x509/x509test.c: Merge with EOM 1.6
regress/Makefile: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.6
samples/VPN-west.conf: Merge with EOM 1.6
samples/singlehost-east.conf: Merge with EOM 1.3
samples/singlehost-west.conf: Merge with EOM 1.3
sysdep/openbsd/Makefile.sysdep: Merge with EOM 1.5
x509.h: Merge with EOM 1.6
x509.c: Merge with EOM 1.17
DESIGN-NOTES: Merge with EOM 1.46
Makefile: Merge with EOM 1.55
cert.c: Merge with EOM 1.11
cert.h: Merge with EOM 1.6
exchange.c: Merge with EOM 1.109
exchange.h: Merge with EOM 1.26
ike_auth.c: Merge with EOM 1.32
ike_phase_1.c: Merge with EOM 1.7
init.c: Merge with EOM 1.16
isakmpd.conf.5: Merge with EOM 1.27
README.PKI: Merge with EOM 1.1

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.22 1999/07/07 22:05:06 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.109 1999/07/17 20:44:09 niklas Exp $	*/
d62 1
d1302 1
d1308 44
d1353 1
d1613 7
@


1.22
log
@Merge with EOM 1.108

author: ho
Connection names only match phase 2 exchanges, so let a
phase 2 stayalive imply stayalive of the "parent" ISAKMP SA.

author: ho
'Connections' should stay alive (SA_FLAG_STAYALIVE)
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.21 1999/06/02 06:33:00 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.108 1999/06/06 17:48:30 ho Exp $	*/
d1143 1
d1170 8
d1442 5
d1452 1
a1452 1
      if (!aca->handler->cert_obtain (exchange, aca->data, &cert, &certlen))
@


1.21
log
@exchange.c: Merge with EOM 1.106
timer.c: Merge with EOM 1.12

author: ho
Logging nitpicks
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.20 1999/05/02 19:17:18 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.106 1999/05/21 14:12:57 ho Exp $	*/
d48 1
d1274 9
@


1.20
log
@Merge with EOM 1.105

author: niklas
Free SAs left in the exchange's SA list always when freeing
the exchange.

author: niklas
disconnect SAs from the exchange when they are ready

author: ho
Don't create SAs for informational exchanges.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.19 1999/05/01 22:57:14 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.105 1999/05/02 18:17:42 niklas Exp $	*/
d371 2
a372 2
		 "exchange_run: finished step %d, advancing...",
		 exchange->step);
@


1.19
log
@Merge with EOM 1.102

author: niklas
Remove larval SAs if an exchange dies.  Also use the DOI from the isakmp_sa
if doing an informational exchange in phase 2.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.18 1999/04/30 22:32:51 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.102 1999/05/01 22:35:13 niklas Exp $	*/
d793 2
a794 8
  /*
   * Don't install a transport into this SA as it will be an INADDR_ANY
   * address in the local end, which is not good at all.  Let the reply
   * packet install the transport instead.
   */
  sa_create (exchange, 0);
  msg->isakmp_sa = TAILQ_FIRST (&exchange->sa_list);
  if (!msg->isakmp_sa)
d796 13
a808 3
      /* XXX Do something more here?  */
      exchange_free (exchange);
      return;
d903 14
a916 10
  /* XXX Number of SAs should come from the args structure.  */
  for (i = 0; i < 1; i++)
    if (sa_create (exchange, isakmp_sa->transport))
      {
	while (TAILQ_FIRST (&exchange->sa_list))
	  TAILQ_REMOVE (&exchange->sa_list, TAILQ_FIRST (&exchange->sa_list),
			next);
	exchange_free (exchange);
	return;
      }
d920 1
d1082 1
a1082 1
  int bufsize_max = LOG_SIZE - strlen(header) - 32; 
d1102 2
a1103 2
	   sa && strlen(buf) < bufsize_max; sa = TAILQ_NEXT (sa, next))
	sprintf (buf + strlen(buf), "%p ", sa);
d1171 1
a1171 4
  /*
   * Tell potential finalize routine we never got there.  This also means
   * any SAs we have need to be torn down as they never got finalized.
   */
d1173 4
d1178 2
a1179 6
      exchange->finalize (exchange, exchange->finalize_arg, 1);
      for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = next_sa)
	{
	  next_sa = TAILQ_NEXT (sa, next);
	  sa_free (sa);
	}
d1292 9
@


1.18
log
@Merge with EOM 1.101

author: niklas
Do not free a message twice
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.17 1999/04/30 11:47:26 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.101 1999/04/30 20:52:41 niklas Exp $	*/
d825 3
d841 1
a841 5
      if (!str)
	doi = isakmp_sa->doi->id;
      else if (strcasecmp (str, "IPSEC") == 0)
	doi = IPSEC_DOI_IPSEC;
      else
d843 7
a849 2
	  log_print ("exchange_establish_p2: DOI \"%s\" unsupported", str);
	  return;
d1132 1
d1162 4
a1165 1
  /* Tell potential finalize routine we never got there.  */
d1167 8
a1174 1
    exchange->finalize (exchange, exchange->finalize_arg, 1);
@


1.17
log
@Merge with EOM 1.100

author: niklas
Try to fix the retransmit business, so info exchanges does not retransmit

author: niklas
Remove unneccesary code

author: niklas
Keep track of messages in the send queue from the exchange point of view.

author: niklas
Free the last sent message when freeing an exchange

author: niklas
New message_drop API.  Generate real INVALID_COOKIE notification.
Generate informational exchanges in phase 1 too.  Really get these
messages to the wire
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.16 1999/04/27 21:07:40 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.100 1999/04/29 22:11:50 niklas Exp $	*/
d1136 1
a1136 1
  if (exchange->in_transit)
@


1.16
log
@Merge with EOM 1.95

author: niklas
Handle leftover payloads.

author: niklas
Simplify exchange life logic some.  Some style too.

author: niklas
Collapse MSG_NO_RETRANS & MSG_KEEP into MSG_LAST.

author: niklas
Style

author: ho
Keep track of trailing retransmissions by keeping exchanges around longer.
Removed references to sa->last_sent_in_setup, use last_sent and
last_received in exchange instead. Free setup exchanges by expiration only.

author: ho
Backout last change. (Go with exchange directly instead of sa->msg)

author: ho
Handle phase 2 late retransmissions.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.15 1999/04/19 19:58:17 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.95 1999/04/27 09:40:33 niklas Exp $	*/
d281 1
d283 5
a287 4
		msg->flags |= MSG_LAST;
	      if (exchange->last_sent)
		message_free (exchange->last_sent);
	      exchange->last_sent = msg;
d365 1
a365 1
	      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 1);
d1134 4
@


1.15
log
@./exchange.c: Merge with EOM 1.88

Check should be for step > 1, not step > 0.

Don't drop new incoming phase 1 exchange request if our existing
exchange hasn't gotten past step 0.

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

Off by one (< -> <=)

Let's get aggressive\!

Added classes LOG_SA and LOG_EXCHANGE, converted
many LOG_MISC to new classes, adjusted levels slightly.
More SA logging.

Simplify the checks of existing exchanges by moving it into
exchange_establish.  This means we need to change the finalize API.
Try to make PF_ENCAP support handle multiple connections to a single
security gateway.

Include sa_list in exchange_dump
Add finalization to exchange when we initiate a new exchange
while an old one is being setup.

Add LOG_REPORT to always go to logchannel regardless of level; misc small fixes

Deal with incoming informational exchanges

style

At end of an exchange, mark the old SAs as replaced.

Do not answer on main-mode initiations from peers we already talk to.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.14 1999/04/05 20:58:13 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.88 1999/04/18 18:01:21 ho Exp $	*/
d73 1
a73 1
static void exchange_free_aux (struct exchange *);
d239 3
a241 3
  int (*handler) (struct message *) = (exchange->initiator
				       ? exchange->doi->initiator
				       : exchange->doi->responder);
d266 1
a266 1
	      log_print ("exchange_run: exchange->doi->%s (%p) failed",
d276 4
a279 7
	       * The last message of an exchange should not be retransmitted.
	       * We should save this message in the ISAKMP SA if this is the
	       * final message of a phase 1 exchange.  Then we can retransmit
	       * "on-demand" if we see retransmits of the last message of the
	       * peer later.
	       * XXX Think about this some more wrt the last message in
	       * phase 2 messages, does this not apply there too?
d281 5
a285 13
	      msg->flags |= MSG_NO_RETRANS;
	      if (exchange->phase == 1 && msg->isakmp_sa)
		{
		  if (msg->isakmp_sa->last_sent_in_setup)
		    {
		      exchange_release (msg->isakmp_sa->last_sent_in_setup
					->exchange);
		      message_free (msg->isakmp_sa->last_sent_in_setup);
		    }
		  msg->isakmp_sa->last_sent_in_setup = msg;
		  msg->flags |= MSG_KEEP;
		  exchange_reference (msg->exchange);
		}
d337 4
a340 2
		      log_print ("exchange_run: unexpected payload %s",
				 constant_name (isakmp_payload_cst, i));
d449 5
d455 3
a457 1
	    && exchange->phase == phase)
d470 1
a470 1
  /* XXX Almost identical to exchange_lookup_by_name().  */
d584 2
a585 2
   * We want the exchange zeroed for exchange_free to be able to find out
   * what fields have been filled-in.
a592 1
  exchange_reference (exchange);
d621 1
a621 2
  exchange->death = timer_add_event ("exchange_free_aux",
				     (void (*) (void *))exchange_free_aux,
d626 1
a626 1
      exchange_free (exchange);
d1117 7
a1123 9
/* Add a reference to EXCHANGE.  */
void exchange_reference (struct exchange *exchange)
{
  exchange->refcnt++;
}

/* Remove a reference to EXCHANGE, and deallocate if the last.  */
void
exchange_release (struct exchange *exchange)
d1125 1
a1125 2
  if (--exchange->refcnt)
    return;
d1127 1
a1127 1
  log_debug (LOG_EXCHANGE, 80, "exchange_release: freeing exchange %p", 
d1130 2
d1149 1
a1157 16
/*
 * Release all resources this exchange is using *except* for the "death"
 * event.  When removing an exchange from the expiration handler that event
 * will be dealt with therein instead.
 */
static void
exchange_free_aux (struct exchange *exchange)
{
  if (exchange->last_received)
    message_free (exchange->last_received);
  if (exchange->last_sent)
    message_free (exchange->last_sent);
  LIST_REMOVE (exchange, link);
  exchange_release (exchange);
}

d1188 2
a1189 2
  if(sa == new_sa || !sa->name || !(sa->flags & SA_FLAG_READY) || 
     (sa->flags & SA_FLAG_REPLACED))
d1193 1
a1193 1
    strcasecmp(sa->name, new_sa->name) == 0;
d1200 1
a1200 1
  struct sa *sa;
d1209 3
a1211 2
   * Walk over all the SAs and noting them as ready.  If we set the COMMIT
   * bit, tell the peer each SA is connected.
a1216 2
      struct sa *old_sa;

d1266 3
a1268 2
  /* No need for this anymore.  */
  exchange_free (exchange);
@


1.14
log
@Merge with EOM 1.75
Plug the leak of the last QM message.  More error reporting from
insufficient memory.  Move the finalize call of exchanges as close to
the real deallocation as possible.

New finalize API so we can call it when failing too, so we do not leak
resources.  Plug memory leaks in general.  More memory allocation error
reporting.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.13 1999/04/02 01:08:25 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.75 1999/04/05 18:28:50 niklas Exp $	*/
d195 2
a196 1
      log_debug (LOG_MISC, 90, "exchange_validate: checking for required %s",
d377 2
a378 1
      log_debug (LOG_MISC, 40, "exchange_run: finished step %d, advancing...",
d430 1
a430 1
  for (i = 0; i < bucket_mask; i++)
d446 5
a450 1
  for (i = 0; i < bucket_mask; i++)
d454 4
a457 4
	log_debug(LOG_MISC, 90,
		  "exchange_lookup_by_name: %s == %s && %d == %d?", name,
		  exchange->name ? exchange->name : "<unnamed>", phase,
		  exchange->phase);
d465 34
d639 1
a639 1
  void (*first) (void *, int);
d641 1
a641 1
  void (*second) (void *, int);
d647 1
a647 1
exchange_run_finalizations (void *arg, int fail)
d651 2
a652 2
  node->first (node->first_arg, fail);
  node->second (node->second_arg, fail);
d662 2
a663 1
			   void (*finalize) (void *, int), void *arg)
d696 2
a697 1
		       char *name, void *args, void (*finalize) (void *, int),
a706 7
      exchange = exchange_lookup_by_name (name, 1);
      if (exchange)
	{
	  exchange_add_finalization (exchange, finalize, arg);
	  return;
	}

d817 3
a819 1
		       void *args, void (*finalize) (void *, int), void *arg)
a828 7
      exchange = exchange_lookup_by_name (name, 2);
      if (exchange)
	{
	  exchange_add_finalization (exchange, finalize, arg);
	  return;
	}

d926 1
a926 1
  char *name, *policy, *str;
d933 2
a934 2
   * Find out our inbound phase 1 mode.
   * XXX Assumes IPv4.
d936 2
a937 4
  t->vtbl->get_dst (t, &dst, &dst_len);
  name = conf_get_str ("Phase 1",
		       inet_ntoa (((struct sockaddr_in *)dst)->sin_addr));
  if (!name)
d939 19
a957 2
      name = conf_get_str ("Phase 1", "Default");
      if (!name)
d959 14
a972 2
	  log_print ("exchange_setup_p1: "
		     "no \"Default\" tag in [Phase 1] section");
a974 1
    }
d976 23
a998 6
  policy = conf_get_str (name, "Configuration");
  if (!policy)
    {
      log_print ("exchange_setup_p1: no configuration for peer \"%s\"", name);
      return 0;
    }
d1000 23
a1022 42
  /* Figure out the DOI.  */
  str = conf_get_str (policy, "DOI");
  if (!str)
    {
      log_print ("exchange_setup_p1: no \"DOI\" tag in [%s] section", policy);
      return 0;
    }
  if (strcasecmp (str, "ISAKMP") == 0)
    want_doi = ISAKMP_DOI_ISAKMP;
  else if (strcasecmp (str, "IPSEC") == 0)
    want_doi = IPSEC_DOI_IPSEC;
  else
    {
      log_print ("exchange_setup_p1: DOI \"%s\" unsupported", str);
      return 0;
    }
  if (want_doi != doi)
    {
      /* XXX Should I tell what DOI I got?  */
      log_print ("exchange_setup_p1: expected %s DOI", str);
      return 0;
    }

  /* What exchange type do we want?  */
  str = conf_get_str (policy, "EXCHANGE_TYPE");
  if (!str)
    {
      log_print ("exchange_setup_p1: no \"EXCHANGE_TYPE\" tag in [%s] section",
		 policy);
      return 0;
    }
  type = constant_value (isakmp_exch_cst, str);
  if (!type)
    {
      log_print ("exchange_setup_p1: unknown exchange type %s", str);
      return 0;
    }
  if (type != GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0].iov_base))
    {
      /* XXX Should I tell what exchange type I got?  */
      log_print ("exchange_setup_p1: expected exchange type %s", str);
      return 0;
d1029 2
a1030 2
  exchange->name = strdup (name);
  if (!exchange->name)
d1066 2
a1067 1
exchange_dump (char *header, struct exchange *exchange)
d1069 6
a1074 1
  log_debug (LOG_MISC, 10,
d1080 1
a1080 1
  log_debug (LOG_MISC, 10,
d1085 22
a1106 2
  log_debug (LOG_MISC, 10, "%s: msgid %08x", header,
	     decode_32 (exchange->message_id));
d1115 1
a1115 1
  for (i = 0; i < bucket_mask; i++)
d1118 1
a1118 1
      exchange_dump ("exchange_report", exchange);
d1134 2
a1135 1
  log_debug (LOG_MISC, 80, "exchange_release: freeing exchange %p", exchange);
d1157 1
a1157 1
    exchange->finalize (exchange->finalize_arg, 1);
d1203 13
d1236 2
d1252 4
d1284 1
a1284 1
    exchange->finalize (exchange->finalize_arg, 0);
d1312 1
a1312 1
  log_debug_buf (LOG_MISC, 80, header, *nonce, nonce_sz);
d1370 1
a1370 1
      if (tmp == NULL)
d1388 1
a1388 1
      if (aca->data != NULL)
d1390 1
a1390 1
	  if (aca->handler != NULL)
d1442 1
a1442 1
exchange_establish_finalize (void *arg, int fail)
d1445 5
a1449 2
  char *peer;
  struct sa *isakmp_sa;
d1452 1
a1452 19
    {
      peer = conf_get_str (name, "ISAKMP-peer");
      if (!peer)
	{
	  log_print ("exchange_establish_finalize: "
		     "no ISAKMP-peer given for \"%s\"", name);
	  return;
	}

      isakmp_sa = sa_lookup_by_name (peer, 1);
      if (!isakmp_sa)
	{
	  log_print ("exchange_establish_finalize: "
		     "did not find \"%s\" ISAKMP SA", peer);
	  return;
	}

      exchange_establish_p2 (isakmp_sa, 0, name, 0, 0, 0);
    }
d1461 3
a1463 1
exchange_establish (char *name, void (*finalize) (void *, int), void *arg)
d1470 16
a1486 1
  phase = conf_get_num (name, "Phase", 0);
@


1.13
log
@Merge with EOM 1.73
refcounting on exchanges

Do not malloc zero bytes, some implementations dislike

resource track exchange->name and sa->name
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.12 1999/03/31 23:46:25 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.73 1999/04/02 00:39:57 niklas Exp $	*/
a281 2
	       * MSG_NO_RETRANS and MSG_KEEP seems to go hand in hand btw..
	       * Unify?
d283 1
a283 1
	      msg->flags |= MSG_NO_RETRANS | MSG_KEEP;
d293 1
d551 4
a554 1
    return 0;
d574 2
d599 1
a599 1
  void (*first) (void *);
d601 1
a601 1
  void (*second) (void *);
d607 1
a607 1
exchange_run_finalizations (void *arg)
d611 2
a612 2
  node->first (node->first_arg);
  node->second (node->second_arg);
d622 1
a622 1
			   void (*finalize) (void *), void *arg)
d655 1
a655 1
		       char *name, void *args, void (*finalize) (void *),
d782 1
a782 1
		       void *args, void (*finalize) (void *), void *arg)
d1073 5
a1093 1

d1162 6
a1167 3
	    for (attr = TAILQ_FIRST (&attrs->fields); attr;
		 attr = TAILQ_NEXT (attr, link))
	      sa->flags |= sa_flag (attr->field);
d1184 2
a1185 1
    exchange->finalize (exchange->finalize_arg);
d1206 4
a1209 1
    return -1;
d1225 5
a1229 1
    return -1;
d1299 1
a1299 2
/* Obtain Certificates from Acceptable Certification Authority */

d1319 4
a1322 1
      if (cert == NULL)
d1324 1
d1342 1
a1342 1
exchange_establish_finalize (void *arg)
d1348 1
a1348 2
  peer = conf_get_str (name, "ISAKMP-peer");
  if (!peer)
d1350 15
a1364 5
      log_print ("exchange_establish_finalize: "
		 "no ISAKMP-peer given for \"%s\"",
		 name);
      return;
    }
d1366 1
a1366 6
  isakmp_sa = sa_lookup_by_name (peer, 1);
  if (!isakmp_sa)
    {
      log_print ("exchange_establish_finalize: did not find \"%s\" ISAKMP SA",
		 peer);
      return;
a1367 2

  exchange_establish_p2 (isakmp_sa, 0, name, 0, 0, 0);
d1376 1
a1376 1
exchange_establish (char *name, void (*finalize) (void *), void *arg)
@


1.12
log
@Merge with EOM 1.70
Make it possible to send a notification in a phase 1 informational exchange.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.11 1999/03/31 01:50:29 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.70 1999/03/31 23:32:30 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d289 5
a293 1
		    message_free (msg->isakmp_sa->last_sent_in_setup);
d295 1
d553 1
d567 1
a567 2
  exchange->data = calloc (1, exchange->doi->exchange_size);
  if (!exchange->data)
d569 6
a574 2
      exchange_free (exchange);
      return 0;
d736 1
a736 2
  exchange->name = name ? strdup (name) : "<unnamed>";
  if (!exchange->name)
d738 7
a744 3
      /* XXX Log?  */
      exchange_free (exchange);
      return;
d844 1
a844 2
  exchange->name = name ? strdup (name) : "<unnamed>";
  if (!exchange->name)
d846 7
a852 3
      /* XXX Log?  */
      exchange_free (exchange);
      return;
d971 1
a971 1
  exchange->name = name ? strdup (name) : "<unnamed>";
d974 1
a974 1
      /* XXX Log?  */
d1037 9
a1045 7
/*
 * Release all resources this exchange is using *except* for the "death"
 * event.  When removing an exchange from the expiration handler that event
 * will be dealt with therein instead.
 */
static void
exchange_free_aux (struct exchange *exchange)
d1047 5
a1051 4
  if (exchange->last_received)
    message_free (exchange->last_received);
  if (exchange->last_sent)
    message_free (exchange->last_sent);
d1069 15
d1085 2
a1086 1
  free (exchange);
d1135 1
a1135 1
      sa->name = exchange->name;
d1344 1
a1395 1
	  /* XXX We leak these names.  */
@


1.11
log
@Merge with EOM 1.69
Do not overwrite the last-sent-message of phase 1 with last-sent dittos
of phase2.  Add some debugging.  Make exchange finalization accept added
hooks to run.  Try to protect better against multiple equal exchanges
getting started concurrently.  Set the SA names from the exchange name up
early.  Change "Attributes" to "Flags" to not be mistaken for ISAKMP
attributes.  Let phase 2 exchanges take finalization functions too.
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.10 1999/03/24 14:42:18 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.69 1999/03/31 01:29:52 niklas Exp $	*/
d650 1
a650 2
  exchange = exchange_lookup_by_name (name, 1);
  if (exchange)
d652 6
a657 3
      exchange_add_finalization (exchange, finalize, arg);
      return;
    }
d659 4
a662 4
  /* If no exchange type given, fetch from the configuration.  */
  if (type == 0)
    {
      /* XXX Similar code can be found in exchange_setup_p1.  Share?  */
d664 5
a668 5
      /* Find out our phase 1 mode.  */
      tag = conf_get_str (name, "Configuration");
      if (!tag)
	{
	  /* XXX I am not sure a default should be used.  */
d670 17
a686 2
	  tag = conf_get_str ("Phase 1", "Default");
	  if (!tag)
d689 10
a698 1
			 "no \"Default\" tag in [Phase 1] section");
a700 6
#else
	  log_print ("exchange_establish_p1: "
		     "no configuration found for peer \"%s\"",
		     name);
#endif
	}
d702 15
a716 31
      /* Figure out the DOI.  XXX Factor out?  */
      str = conf_get_str (tag, "DOI");
      if (!str)
	{
	  log_print ("exchange_establish_p1: no \"DOI\" tag in [%s] section",
		     tag);
	  return;
	}
      if (strcasecmp (str, "ISAKMP") == 0)
	doi = ISAKMP_DOI_ISAKMP;
      else if (strcasecmp (str, "IPSEC") == 0)
	doi = IPSEC_DOI_IPSEC;
      else
	{
	  log_print ("exchange_establish_p1: DOI \"%s\" unsupported", str);
	  return;
	}

      /* What exchange type do we want?  */
      str = conf_get_str (tag, "EXCHANGE_TYPE");
      if (!str)
	{
	  log_print ("exchange_establish_p1: "
		     "no \"EXCHANGE_TYPE\" tag in [%s] section", tag);
	  return;
	}
      type = constant_value (isakmp_exch_cst, str);
      if (!type)
	{
	  log_print ("exchange_establish_p1: unknown exchange type %s", str);
	  return;
@


1.10
log
@Merge with EOM 1.68
Only get the destination address when needed

If no exchange name, do not look for attributes

The SA name is not yet setup, use the exchange name instead
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.9 1999/03/02 15:48:23 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.68 1999/03/24 10:59:11 niklas Exp $	*/
d286 1
a286 1
	      if (msg->isakmp_sa)
d443 9
a451 2
      if (strcmp (exchange->name, name) == 0 && exchange->phase == phase)
	return exchange;
d455 1
a455 1
int
a477 1
  return 1;
d584 55
d642 2
a643 1
		       void *args, void (*finalize) (void *), void *arg)
a648 1
  char *name = args;
d650 2
a651 1
  if (exchange_lookup_by_name (name, 1))
d653 1
a653 4
      /*
       * Another exchange for this name is already being run.
       * XXX What about the finalize routine?
       */
d761 2
a762 1
exchange_establish_p2 (struct sa *isakmp_sa, u_int8_t type, void *args)
d767 2
a768 2
  char *tag, *str, *name = args;
  u_int32_t doi;
d770 1
a770 3
  /* Find out our phase 2 modes.  */
  tag = conf_get_str (name, "Configuration");
  if (!tag)
d772 6
a777 4
      log_print ("exchange_establish_p2: no configuration for peer \"%s\"",
		 name);
      return;
    }
d779 8
a786 11
  /* Figure out the DOI.  */
  str = conf_get_str (tag, "DOI");
  if (!str)
    doi = isakmp_sa->doi->id;
  else if (strcasecmp (str, "IPSEC") == 0)
    doi = IPSEC_DOI_IPSEC;
  else
    {
      log_print ("exchange_establish_p2: DOI \"%s\" unsupported", str);
      return;
    }
d788 2
a789 4
  /* What exchange type do we want?  */
  if (!type)
    {
      str = conf_get_str (tag, "EXCHANGE_TYPE");
d791 4
d796 1
a796 2
	  log_print ("exchange_establish_p2: "
		     "no \"EXCHANGE_TYPE\" tag in [%s] section", tag);
d799 2
a800 2
      /* XXX IKE dependent.  */
      type = constant_value (ike_exch_cst, str);
d803 15
a817 2
	  log_print ("exchange_establish_p2: unknown exchange type %s", str);
	  return;
d836 2
d993 2
a994 1
	     header, exchange, exchange->name, exchange->policy,
d1096 3
d1114 1
a1114 1
	  attrs = conf_get_list (exchange->name, "Attributes");
d1292 1
a1292 1
		 "No ISAKMP-peer given for \"%s\"",
d1304 2
a1305 1
  exchange_establish_p2 (isakmp_sa, 0, name);
d1308 4
d1342 1
a1342 1
      exchange_establish_p1 (transport, 0, 0, name, finalize, arg);
a1356 2
	  /* XXX Check that peer is really a phase 1 peer.  */

d1361 1
a1361 2
	      log_error ("exchange_establish: strdup failed",
			 name);
d1364 1
d1368 1
a1368 1
	exchange_establish_p2 (isakmp_sa, 0, name);
@


1.9
log
@sa.c: Merge with EOM 1.67
Add SA attributes, specifically stayalive

sa.h: Merge with EOM 1.42
Add SA attributes, specifically stayalive

pf_encap.c: Merge with EOM 1.46
Add SA attributes, specifically stayalive

exchange.c: Merge with EOM 1.65
Add SA attributes, specifically stayalive
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.8 1999/02/26 03:37:56 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.65 1999/03/02 15:42:59 niklas Exp $	*/
a584 2
  struct sockaddr *dst;
  int dst_len;
a603 1
      t->vtbl->get_dst (t, &dst, &dst_len);
d806 4
a809 1
  /* Find out our inbound phase 1 mode.  */
d1035 8
a1042 5
      attrs = conf_get_list (sa->name, "Attributes");
      if (attrs)
	for (attr = TAILQ_FIRST (&attrs->fields); attr;
	     attr = TAILQ_NEXT (attr, link))
	  sa->flags |= sa_flag (attr->field);
@


1.8
log
@Merge from the Ericsson repository
| revision 1.64
| date: 1999/02/25 11:38:53;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.63
| date: 1999/02/25 11:09:33;  author: niklas;  state: Exp;  lines: +3 -5
| Make conf_get_num take a default value to give back when tag does not exist
| ----------------------------
| revision 1.62
| date: 1999/02/06 14:57:51;  author: niklas;  state: Exp;  lines: +3 -3
| Export exchange_lookup_by_name
| ----------------------------
| revision 1.61
| date: 1999/01/31 01:14:58;  author: niklas;  state: Exp;  lines: +2 -2
| commentary
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.7 1998/12/21 01:02:23 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.64 1999/02/25 11:38:53 niklas Exp $	*/
d1008 2
d1032 2
d1035 6
@


1.7
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.6 1998/11/17 11:10:10 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.60 1998/12/21 00:34:12 niklas Exp $	*/
d44 2
d433 2
a434 2
/* Lookup a phase 1 exchange out of the name.  */
static struct exchange *
d563 1
a563 3
  delta = conf_get_num ("General", "Exchange-max-time");
  if (!delta)
    delta = EXCHANGE_MAX_TIME;
d626 1
a626 1
      /* Figure out the DOI.  */
d1226 1
a1226 1
  phase = conf_get_num (name, "Phase");
@


1.6
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: exchange.c,v 1.5 1998/11/16 12:20:33 niklas Exp $	*/
/*	$EOM: exchange.c,v 1.50 1998/11/14 23:42:23 niklas Exp $	*/
d38 3
d45 1
d51 1
d56 1
d431 15
d510 3
a512 1
					  ISAKMP_HDR_MESSAGE_ID_LEN) != 0));
d531 1
d561 4
a564 1
  expiration.tv_sec += EXCHANGE_MAX_TIME;
d581 1
a581 1
		       void *args)
d585 74
d666 11
d710 23
d734 20
a753 1
  exchange = exchange_create (2, 1, isakmp_sa->doi->id, type);
d759 9
d799 1
d801 22
d824 52
a875 2
  exchange = exchange_create (1, 0, doi,
			      GET_ISAKMP_HDR_EXCH_TYPE (msg->iov[0].iov_base));
d878 9
d914 1
d919 4
a922 4
	     "%s: %s phase %d doi %d exchange %d step %d msgid %08x",
	     header, exchange->initiator ? "initiator" : "responder",
	     exchange->phase, exchange->doi->id, exchange->type,
	     exchange->step, decode_32 (exchange->message_id));
d928 2
d970 2
d1044 2
d1189 95
@


1.5
log
@Add back cert handling, no patent problem here
@
text
@d1 2
a2 1
/*	$OpenBSD: exchange.c,v 1.4 1998/11/15 01:13:26 niklas Exp $	*/
@


1.4
log
@Remove last warnings after crippling
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.3 1998/11/15 01:11:25 niklas Exp $	*/
a859 1
#if 0
a861 1
#endif
a865 1
#if 0
a872 1
#endif
@


1.3
log
@At the moment we do not do certificates
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.2 1998/11/15 00:43:52 niklas Exp $	*/
d860 1
d863 1
@


1.2
log
@openBSD RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: exchange.c,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
d866 1
d874 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: exchange.c,v 1.50 1998/11/14 23:42:23 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
