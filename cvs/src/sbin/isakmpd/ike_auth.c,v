head	1.113;
access;
symbols
	OPENBSD_6_2:1.113.0.12
	OPENBSD_6_2_BASE:1.113
	OPENBSD_6_1:1.113.0.10
	OPENBSD_6_1_BASE:1.113
	OPENBSD_6_0:1.113.0.6
	OPENBSD_6_0_BASE:1.113
	OPENBSD_5_9:1.113.0.2
	OPENBSD_5_9_BASE:1.113
	OPENBSD_5_8:1.113.0.4
	OPENBSD_5_8_BASE:1.113
	OPENBSD_5_7:1.112.0.2
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.110.0.32
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.110.0.30
	OPENBSD_5_5_BASE:1.110
	OPENBSD_5_4:1.110.0.26
	OPENBSD_5_4_BASE:1.110
	OPENBSD_5_3:1.110.0.24
	OPENBSD_5_3_BASE:1.110
	OPENBSD_5_2:1.110.0.22
	OPENBSD_5_2_BASE:1.110
	OPENBSD_5_1_BASE:1.110
	OPENBSD_5_1:1.110.0.20
	OPENBSD_5_0:1.110.0.18
	OPENBSD_5_0_BASE:1.110
	OPENBSD_4_9:1.110.0.16
	OPENBSD_4_9_BASE:1.110
	OPENBSD_4_8:1.110.0.14
	OPENBSD_4_8_BASE:1.110
	OPENBSD_4_7:1.110.0.10
	OPENBSD_4_7_BASE:1.110
	OPENBSD_4_6:1.110.0.12
	OPENBSD_4_6_BASE:1.110
	OPENBSD_4_5:1.110.0.8
	OPENBSD_4_5_BASE:1.110
	OPENBSD_4_4:1.110.0.6
	OPENBSD_4_4_BASE:1.110
	OPENBSD_4_3:1.110.0.4
	OPENBSD_4_3_BASE:1.110
	OPENBSD_4_2:1.110.0.2
	OPENBSD_4_2_BASE:1.110
	OPENBSD_4_1:1.109.0.2
	OPENBSD_4_1_BASE:1.109
	OPENBSD_4_0:1.107.0.2
	OPENBSD_4_0_BASE:1.107
	OPENBSD_3_9:1.106.0.2
	OPENBSD_3_9_BASE:1.106
	OPENBSD_3_8:1.104.0.2
	OPENBSD_3_8_BASE:1.104
	OPENBSD_3_7:1.97.0.2
	OPENBSD_3_7_BASE:1.97
	OPENBSD_3_6:1.95.0.2
	OPENBSD_3_6_BASE:1.95
	OPENBSD_3_5:1.83.0.2
	OPENBSD_3_5_BASE:1.83
	OPENBSD_3_4:1.79.0.2
	OPENBSD_3_4_BASE:1.79
	OPENBSD_3_3:1.68.0.2
	OPENBSD_3_3_BASE:1.68
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.61.0.2
	OPENBSD_3_1_BASE:1.61
	OPENBSD_3_0:1.60.0.2
	OPENBSD_3_0_BASE:1.60
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.24.0.2
	OPENBSD_2_7_BASE:1.24
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.113
date	2015.04.21.01.44.47;	author jsg;	state Exp;
branches;
next	1.112;
commitid	YsWOV0VgfvvmakrR;

1.112
date	2014.08.25.08.00.48;	author doug;	state Exp;
branches;
next	1.111;
commitid	b381riCusQyVD20a;

1.111
date	2014.08.23.00.48.57;	author doug;	state Exp;
branches;
next	1.110;
commitid	1vU7IHxPgqerhW9M;

1.110
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.109;

1.109
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.108;

1.108
date	2006.11.09.09.43.35;	author markus;	state Exp;
branches;
next	1.107;

1.107
date	2006.06.10.21.09.45;	author msf;	state Exp;
branches;
next	1.106;

1.106
date	2005.11.17.13.44.11;	author moritz;	state Exp;
branches;
next	1.105;

1.105
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2005.07.14.12.50.08;	author moritz;	state Exp;
branches;
next	1.103;

1.103
date	2005.05.26.06.11.09;	author hshoexer;	state Exp;
branches;
next	1.102;

1.102
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.101;

1.101
date	2005.04.08.20.04.57;	author hshoexer;	state Exp;
branches;
next	1.100;

1.100
date	2005.04.08.18.35.37;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.97;

1.97
date	2005.02.22.16.57.48;	author hshoexer;	state Exp;
branches;
next	1.96;

1.96
date	2004.12.22.12.25.27;	author hshoexer;	state Exp;
branches;
next	1.95;

1.95
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2004.06.23.03.01.52;	author hshoexer;	state Exp;
branches;
next	1.93;

1.93
date	2004.06.22.18.22.18;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.20.17.17.34;	author ho;	state Exp;
branches;
next	1.91;

1.91
date	2004.06.14.13.53.31;	author hshoexer;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.89;

1.89
date	2004.06.02.16.19.16;	author hshoexer;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.26.22.17.58;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2004.05.23.18.17.55;	author hshoexer;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.31.10.54.46;	author ho;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.82;

1.82
date	2004.03.17.11.10.06;	author ho;	state Exp;
branches;
next	1.81;

1.81
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2003.10.14.14.29.15;	author ho;	state Exp;
branches;
next	1.79;

1.79
date	2003.08.08.08.46.59;	author ho;	state Exp;
branches;
next	1.78;

1.78
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.04.07.31.16;	author ho;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.03.14.28.16;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2003.05.18.19.37.46;	author ho;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.15.03.20.28;	author ho;	state Exp;
branches;
next	1.72;

1.72
date	2003.05.15.02.28.56;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2003.05.15.02.08.54;	author ho;	state Exp;
branches;
next	1.70;

1.70
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.14.18.11.19;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2003.03.13.13.24.48;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.22.15.13.11;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.28.11.23.20;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2002.01.23.17.14.28;	author ho;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.23.19.32.46;	author niklas;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.22.17.30.46;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.22.17.24.45;	author ho;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.16.16.51.57;	author ho;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.16.13.49.50;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.16.13.27.03;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.15.13.06.53;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.15.09.16.29;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.01.19.48.43;	author niklas;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.29.19.55.36;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.29.04.11.59;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.28.21.41.58;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.11.10.50.09;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.07.04.48.21;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.07.04.19.03;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.06.22.22.12;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.05.10.04.46;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.05.05.59.42;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.05.05.08.26;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.31.20.29.49;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.24.03.15.37;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.09.12.34.37;	author ho;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.03.27.18.47.09;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.27.15.39.54;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.27.12.03.32;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.27.11.53.57;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.26.21.49.37;	author ho;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.26.19.12.38;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.26.12.12.51;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.19.19.03.05;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.23.12.56.33;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.13.13.42.50;	author niklas;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2000.10.07.07.01.04;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.03.07.23.32;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.20.05.55.15;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.08.20.48.53;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.07.22.07.44;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.28.23.59.14;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.25.17.23.40;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.19.19.32.53;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.10.01.14.10.54;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.09.29.04.45.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.08.26.22.30.08;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.07.18.09.33.33;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.07.17.21.54.39;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.07.07.22.04.08;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.05.02.19.20.31;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.04.19.21.08.44;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.03.24.14.42.49;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.02.26.03.40.50;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.12.21.01.02.24;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	98.11.20.23.42.29;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	98.11.17.11.10.12;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.11.16.21.07.16;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.11.15.01.13.27;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.15.01.09.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.15.00.59.11;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.29.2.1
date	2000.12.11.05.38.23;	author jason;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.05.08.12.45.22;	author ho;	state Exp;
branches;
next	;

1.39.2.1
date	2001.06.03.19.00.23;	author jason;	state Exp;
branches;
next	;


desc
@@


1.113
log
@No need to do "size = (size_t)sb.st_size" both before and after
a fstat() call.
ok mikeb@@ markus@@
@
text
@/* $OpenBSD: ike_auth.c,v 1.112 2014/08/25 08:00:48 doug Exp $	 */
/* $EOM: ike_auth.c,v 1.59 2000/11/21 00:21:31 angelos Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Niels Provos.  All rights reserved.
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2000, 2001, 2003 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <errno.h>
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <regex.h>
#include <keynote.h>
#include <policy.h>

#include "cert.h"
#include "conf.h"
#include "constants.h"
#if defined (USE_DNSSEC)
#include "dnssec.h"
#endif
#include "exchange.h"
#include "hash.h"
#include "ike_auth.h"
#include "ipsec.h"
#include "ipsec_doi.h"
#include "libcrypto.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "prf.h"
#include "transport.h"
#include "util.h"
#include "key.h"
#include "x509.h"

#ifdef notyet
static u_int8_t *enc_gen_skeyid(struct exchange *, size_t *);
#endif
static u_int8_t *pre_shared_gen_skeyid(struct exchange *, size_t *);

static int      pre_shared_decode_hash(struct message *);
static int      pre_shared_encode_hash(struct message *);

static u_int8_t *sig_gen_skeyid(struct exchange *, size_t *);
static int      rsa_sig_decode_hash(struct message *);
static int      rsa_sig_encode_hash(struct message *);

static int      get_raw_key_from_file(int, u_int8_t *, size_t, RSA **);

static int      ike_auth_hash(struct exchange *, u_int8_t *);

static struct ike_auth ike_auth[] = {
	{
		IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid,
		pre_shared_decode_hash,
		pre_shared_encode_hash
	},
#ifdef notdef
	{
		IKE_AUTH_DSS, sig_gen_skeyid,
		pre_shared_decode_hash,
		pre_shared_encode_hash
	},
#endif
	{
		IKE_AUTH_RSA_SIG, sig_gen_skeyid,
		rsa_sig_decode_hash,
		rsa_sig_encode_hash
	},
#ifdef notdef
	{
		IKE_AUTH_RSA_ENC, enc_gen_skeyid,
		pre_shared_decode_hash,
		pre_shared_encode_hash
	},
	{
		IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid,
		pre_shared_decode_hash,
		pre_shared_encode_hash
	},
#endif
};

struct ike_auth *
ike_auth_get(u_int16_t id)
{
	size_t	i;

	for (i = 0; i < sizeof ike_auth / sizeof ike_auth[0]; i++)
		if (id == ike_auth[i].id)
			return &ike_auth[i];
	return 0;
}

/*
 * Find and decode the configured key (pre-shared or public) for the
 * peer denoted by ID.  Stash the len in KEYLEN.
 */
static void *
ike_auth_get_key(int type, char *id, char *local_id, size_t *keylen)
{
	char	*key, *buf;
	char	*keyfile, *privkeyfile;
	FILE	*keyfp;
	RSA	*rsakey;
	size_t	 fsize, pkflen;
	int	 fd;

	switch (type) {
	case IKE_AUTH_PRE_SHARED:
		/* Get the pre-shared key for our peer.  */
		key = conf_get_str(id, "Authentication");
		if (!key && local_id)
			key = conf_get_str(local_id, "Authentication");

		if (!key) {
			log_print("ike_auth_get_key: "
			    "no key found for peer \"%s\" or local ID \"%s\"",
			    id, local_id ? local_id : "<none>");
			return 0;
		}
		/* If the key starts with 0x it is in hex format.  */
		if (strncasecmp(key, "0x", 2) == 0) {
			*keylen = (strlen(key) - 1) / 2;
			buf = malloc(*keylen);
			if (!buf) {
				log_error("ike_auth_get_key: malloc (%lu) "
				    "failed", (unsigned long)*keylen);
				return 0;
			}
			if (hex2raw(key + 2, (unsigned char *)buf, *keylen)) {
				free(buf);
				log_print("ike_auth_get_key: invalid hex key "
				    "%s", key);
				return 0;
			}
			key = buf;
		} else {
			buf = key;
			key = strdup(buf);
			if (!key) {
				log_error("ike_auth_get_key: strdup() failed");
				return 0;
			}
			*keylen = strlen(key);
		}
		break;

	case IKE_AUTH_RSA_SIG:
		if (local_id && (keyfile = conf_get_str("KeyNote",
		    "Credential-directory")) != 0) {
			struct stat     sb;
			struct keynote_deckey dc;
			char           *privkeyfile, *buf2;
			size_t          size;

			if (asprintf(&privkeyfile, "%s/%s/%s", keyfile,
			    local_id, PRIVATE_KEY_FILE) == -1) {
				log_print("ike_auth_get_key: failed to asprintf()");
				return 0;
			}
			keyfile = privkeyfile;

			fd = monitor_open(keyfile, O_RDONLY, 0);
			if (fd < 0) {
				free(keyfile);
				goto ignorekeynote;
			}

			if (fstat(fd, &sb) < 0) {
				log_print("ike_auth_get_key: fstat failed");
				free(keyfile);
				close(fd);
				return 0;
			}
			size = (size_t)sb.st_size;

			buf = calloc(size + 1, sizeof(char));
			if (!buf) {
				log_print("ike_auth_get_key: failed allocating"
				    " %lu bytes", (unsigned long)size + 1);
				free(keyfile);
				close(fd);
				return 0;
			}
			if (read(fd, buf, size) != (ssize_t)size) {
				free(buf);
				log_print("ike_auth_get_key: "
				    "failed reading %lu bytes from \"%s\"",
				    (unsigned long)size, keyfile);
				free(keyfile);
				close(fd);
				return 0;
			}
			close(fd);

			/* Parse private key string */
			buf2 = kn_get_string(buf);
			free(buf);

			if (!buf2 || kn_decode_key(&dc, buf2,
			    KEYNOTE_PRIVATE_KEY) == -1) {
				free(buf2);
				log_print("ike_auth_get_key: failed decoding "
				    "key in \"%s\"", keyfile);
				free(keyfile);
				return 0;
			}
			free(buf2);

			if (dc.dec_algorithm != KEYNOTE_ALGORITHM_RSA) {
				log_print("ike_auth_get_key: wrong algorithm "
				    "type %d in \"%s\"", dc.dec_algorithm,
				    keyfile);
				free(keyfile);
				kn_free_key(&dc);
				return 0;
			}
			free(keyfile);
			return dc.dec_key;
		}
ignorekeynote:
		/* Otherwise, try X.509 */

		privkeyfile = keyfile = NULL;
		fd = -1;

		if (local_id) {
			/* Look in Private-key-directory. */
			keyfile = conf_get_str("X509-certificates",
			    "Private-key-directory");
			pkflen = strlen(keyfile) + strlen(local_id) + sizeof "/";
			privkeyfile = calloc(pkflen, sizeof(char));
			if (!privkeyfile) {
				log_print("ike_auth_get_key: failed to "
				    "allocate %lu bytes", (unsigned long)pkflen);
				return 0;
			}

			snprintf(privkeyfile, pkflen, "%s/%s", keyfile,
			    local_id);
			keyfile = privkeyfile;

			fd = monitor_open(keyfile, O_RDONLY, 0);
			if (fd < 0 && errno != ENOENT) {
				log_print("ike_auth_get_key: failed opening "
				    "\"%s\"", keyfile);
				free(privkeyfile);
				privkeyfile = NULL;
				keyfile = NULL;
			}
		}

		if (fd < 0) {
			/* No key found, try default key. */
			keyfile = conf_get_str("X509-certificates",
			    "Private-key");

			fd = monitor_open(keyfile, O_RDONLY, 0);
			if (fd < 0) {
				log_print("ike_auth_get_key: failed opening "
				    "\"%s\"", keyfile);
				return 0;
			}
		}

		if (check_file_secrecy_fd(fd, keyfile, &fsize)) {
			free(privkeyfile);
			close(fd);
			return 0;
		}

		if ((keyfp = fdopen(fd, "r")) == NULL) {
			log_print("ike_auth_get_key: fdopen failed");
			free(privkeyfile);
			close(fd);
			return 0;
		}
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		rsakey = PEM_read_RSAPrivateKey(keyfp, NULL, NULL, NULL);
#else
		rsakey = PEM_read_RSAPrivateKey(keyfp, NULL, NULL);
#endif
		fclose(keyfp);

		free(privkeyfile);

		if (!rsakey) {
			log_print("ike_auth_get_key: "
			    "PEM_read_bio_RSAPrivateKey failed");
			return 0;
		}
		return rsakey;

	default:
		log_print("ike_auth_get_key: unknown key type %d", type);
		return 0;
	}

	return key;
}

static u_int8_t *
pre_shared_gen_skeyid(struct exchange *exchange, size_t *sz)
{
	struct prf     *prf;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *skeyid, *buf = 0;
	unsigned char  *key;
	size_t          keylen;

	/*
	 * If we're the responder and have the initiator's ID (which is the
	 * case in Aggressive mode), try to find the preshared key in the
	 * section of the initiator's Phase 1 ID.  This allows us to do
	 * mobile user support with preshared keys.
         */
	if (!exchange->initiator && exchange->id_i) {
		switch (exchange->id_i[0]) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV6_ADDR:
			util_ntoa((char **) &buf,
			    exchange->id_i[0] == IPSEC_ID_IPV4_ADDR ? AF_INET :
			    AF_INET6, exchange->id_i + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ);
			if (!buf)
				return 0;
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
			buf = calloc(exchange->id_i_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!buf) {
				log_print("pre_shared_gen_skeyid: malloc (%lu"
				    ") failed",
				    (unsigned long)exchange->id_i_len -
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
				return 0;
			}
			memcpy(buf,
			    exchange->id_i + ISAKMP_ID_DATA_OFF -
			    ISAKMP_GEN_SZ,
			    exchange->id_i_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ);
			break;

			/* XXX Support more ID types ? */
		default:
			break;
		}
	}
	/*
	 * Get the pre-shared key for our peer. This will work even if the key
	 * has been passed to us through a mechanism like PFKEYv2.
         */
	key = ike_auth_get_key(IKE_AUTH_PRE_SHARED, exchange->name,
	    (char *)buf, &keylen);
	free(buf);

	/* Fail if no key could be found.  */
	if (!key)
		return 0;

	/* Store the secret key for later policy processing.  */
	exchange->recv_key = calloc(keylen + 1, sizeof(char));
	exchange->recv_keytype = ISAKMP_KEY_PASSPHRASE;
	if (!exchange->recv_key) {
		log_error("pre_shared_gen_skeyid: malloc (%lu) failed",
		    (unsigned long)keylen);
		free(key);
		return 0;
	}
	memcpy(exchange->recv_key, key, keylen);
	exchange->recv_certtype = ISAKMP_CERTENC_NONE;
	free(key);

	prf = prf_alloc(ie->prf_type, ie->hash->type, exchange->recv_key,
	    keylen);
	if (!prf)
		return 0;

	*sz = prf->blocksize;
	skeyid = malloc(*sz);
	if (!skeyid) {
		log_error("pre_shared_gen_skeyid: malloc (%lu) failed",
		    (unsigned long)*sz);
		prf_free(prf);
		return 0;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
	prf->Update(prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
	prf->Final(skeyid, prf->prfctx);
	prf_free(prf);
	return skeyid;
}

/* Both DSS & RSA signature authentication use this algorithm.  */
static u_int8_t *
sig_gen_skeyid(struct exchange *exchange, size_t *sz)
{
	struct prf     *prf;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *skeyid;
	unsigned char  *key;

	key = malloc(exchange->nonce_i_len + exchange->nonce_r_len);
	if (!key)
		return 0;
	memcpy(key, exchange->nonce_i, exchange->nonce_i_len);
	memcpy(key + exchange->nonce_i_len, exchange->nonce_r,
	    exchange->nonce_r_len);

	LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: PRF type %d, hash %d",
	    ie->prf_type, ie->hash->type));
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "sig_gen_skeyid: SKEYID initialized with",
	    (u_int8_t *)key, exchange->nonce_i_len + exchange->nonce_r_len));

	prf = prf_alloc(ie->prf_type, ie->hash->type, key,
	    exchange->nonce_i_len + exchange->nonce_r_len);
	free(key);
	if (!prf)
		return 0;

	*sz = prf->blocksize;
	skeyid = malloc(*sz);
	if (!skeyid) {
		log_error("sig_gen_skeyid: malloc (%lu) failed",
		    (unsigned long)*sz);
		prf_free(prf);
		return 0;
	}
	LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %lu",
	    (unsigned long)ie->g_x_len));
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "sig_gen_skeyid: SKEYID fed with g^xy", ie->g_xy, ie->g_x_len));

	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, ie->g_xy, ie->g_x_len);
	prf->Final(skeyid, prf->prfctx);
	prf_free(prf);
	return skeyid;
}

#ifdef notdef
/*
 * Both standard and revised RSA encryption authentication use this SKEYID
 * computation.
 */
static u_int8_t *
enc_gen_skeyid(struct exchange *exchange, size_t *sz)
{
	struct prf     *prf;
	struct ipsec_exch *ie = exchange->data;
	struct hash    *hash = ie->hash;
	u_int8_t       *skeyid;

	hash->Init(hash->ctx);
	hash->Update(hash->ctx, exchange->nonce_i, exchange->nonce_i_len);
	hash->Update(hash->ctx, exchange->nonce_r, exchange->nonce_r_len);
	hash->Final(hash->digest, hash->ctx);
	prf = prf_alloc(ie->prf_type, hash->type, hash->digest, *sz);
	if (!prf)
		return 0;

	*sz = prf->blocksize;
	skeyid = malloc(*sz);
	if (!skeyid) {
		log_error("enc_gen_skeyid: malloc (%d) failed", *sz);
		prf_free(prf);
		return 0;
	}
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	prf->Final(skeyid, prf->prfctx);
	prf_free(prf);
	return skeyid;
}
#endif				/* notdef */

static int
pre_shared_decode_hash(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct payload *payload;
	size_t          hashsize = ie->hash->hashsize;
	char            header[80];
	int             initiator = exchange->initiator;
	u_int8_t      **hash_p;

	/* Choose the right fields to fill-in.  */
	hash_p = initiator ? &ie->hash_r : &ie->hash_i;

	payload = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	if (!payload) {
		log_print("pre_shared_decode_hash: no HASH payload found");
		return -1;
	}
	/* Check that the hash is of the correct size.  */
	if (GET_ISAKMP_GEN_LENGTH(payload->p) - ISAKMP_GEN_SZ != hashsize)
		return -1;

	/* XXX Need this hash be in the SA?  */
	*hash_p = malloc(hashsize);
	if (!*hash_p) {
		log_error("pre_shared_decode_hash: malloc (%lu) failed",
		    (unsigned long)hashsize);
		return -1;
	}
	memcpy(*hash_p, payload->p + ISAKMP_HASH_DATA_OFF, hashsize);
	snprintf(header, sizeof header, "pre_shared_decode_hash: HASH_%c",
	    initiator ? 'R' : 'I');
	LOG_DBG_BUF((LOG_MISC, 80, header, *hash_p, hashsize));

	payload->flags |= PL_MARK;
	return 0;
}

/* Decrypt the HASH in SIG, we already need a parsed ID payload.  */
static int
rsa_sig_decode_hash(struct message *msg)
{
	struct cert_handler *handler;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct payload *p;
	void           *cert = 0;
	u_int8_t       *rawcert = 0, **hash_p, **id_cert, *id;
	u_int32_t       rawcertlen, *id_cert_len;
	RSA            *key = 0;
	size_t          hashsize = ie->hash->hashsize, id_len;
	char            header[80];
	int             len, initiator = exchange->initiator;
	int             found = 0, n, i, id_found;
#if defined (USE_DNSSEC)
	u_int8_t       *rawkey = 0;
	u_int32_t       rawkeylen;
#endif

	/* Choose the right fields to fill-in.  */
	hash_p = initiator ? &ie->hash_r : &ie->hash_i;
	id = initiator ? exchange->id_r : exchange->id_i;
	id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

	if (!id || id_len == 0) {
		log_print("rsa_sig_decode_hash: ID is missing");
		return -1;
	}
	/*
	 * XXX Assume we should use the same kind of certification as the
	 * remote...  moreover, just use the first CERT payload to decide what
	 * to use.
         */
	p = payload_first(msg, ISAKMP_PAYLOAD_CERT);
	if (!p)
		handler = cert_get(ISAKMP_CERTENC_KEYNOTE);
	else
		handler = cert_get(GET_ISAKMP_CERT_ENCODING(p->p));
	if (!handler) {
		log_print("rsa_sig_decode_hash: cert_get (%d) failed",
		    p ? GET_ISAKMP_CERT_ENCODING(p->p) : -1);
		return -1;
	}
	/*
	 * We need the policy session initialized now, so we can add
	 * credentials etc.
         */
	exchange->policy_id = kn_init();
	if (exchange->policy_id == -1) {
		log_print("rsa_sig_decode_hash: failed to initialize policy "
		    "session");
		return -1;
	}

	/* Obtain a certificate from our certificate storage.  */
	if (handler->cert_obtain(id, id_len, 0, &rawcert, &rawcertlen)) {
		if (handler->id == ISAKMP_CERTENC_X509_SIG) {
			cert = handler->cert_get(rawcert, rawcertlen);
			if (!cert)
				LOG_DBG((LOG_CRYPTO, 50, "rsa_sig_decode_hash:"
				    " certificate malformed"));
			else {
				if (!handler->cert_get_key(cert, &key)) {
					log_print("rsa_sig_decode_hash: "
					    "decoding certificate failed");
					handler->cert_free(cert);
				} else {
					found++;
					LOG_DBG((LOG_CRYPTO, 40,
					    "rsa_sig_decode_hash: using cert "
					    "of type %d", handler->id));
					exchange->recv_cert = cert;
					exchange->recv_certtype = handler->id;
					x509_generate_kn(exchange->policy_id,
					    cert);
				}
			}
		} else if (handler->id == ISAKMP_CERTENC_KEYNOTE)
			handler->cert_insert(exchange->policy_id, rawcert);
		free(rawcert);
	}
	/*
	 * Walk over potential CERT payloads in this message.
	 * XXX I believe this is the wrong spot for this.  CERTs can appear
	 * anytime.
         */
	TAILQ_FOREACH(p, &msg->payload[ISAKMP_PAYLOAD_CERT], link) {
		p->flags |= PL_MARK;

		/*
		 * When we have found a key, just walk over the rest, marking
		 * them.
		 */
		if (found)
			continue;

		handler = cert_get(GET_ISAKMP_CERT_ENCODING(p->p));
		if (!handler) {
			LOG_DBG((LOG_MISC, 30, "rsa_sig_decode_hash: "
			    "no handler for %s CERT encoding",
			    constant_name(isakmp_certenc_cst,
			    GET_ISAKMP_CERT_ENCODING(p->p))));
			continue;
		}
		cert = handler->cert_get(p->p + ISAKMP_CERT_DATA_OFF,
		    GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_CERT_DATA_OFF);
		if (!cert) {
			log_print("rsa_sig_decode_hash: "
			    "can not get data from CERT");
			continue;
		}
		if (!handler->cert_validate(cert)) {
			handler->cert_free(cert);
			log_print("rsa_sig_decode_hash: received CERT can't "
			    "be validated");
			continue;
		}
		if (GET_ISAKMP_CERT_ENCODING(p->p) ==
		    ISAKMP_CERTENC_X509_SIG) {
			if (!handler->cert_get_subjects(cert, &n, &id_cert,
			    &id_cert_len)) {
				handler->cert_free(cert);
				log_print("rsa_sig_decode_hash: can not get "
				    "subject from CERT");
				continue;
			}
			id_found = 0;
			for (i = 0; i < n; i++)
				if (id_cert_len[i] == id_len &&
				    id[0] == id_cert[i][0] &&
				    memcmp(id + 4, id_cert[i] + 4, id_len - 4)
				    == 0) {
					id_found++;
					break;
				}
			if (!id_found) {
				handler->cert_free(cert);
				log_print("rsa_sig_decode_hash: no CERT "
				    "subject match the ID");
				free(id_cert);
				continue;
			}
			cert_free_subjects(n, id_cert, id_cert_len);
		}
		if (!handler->cert_get_key(cert, &key)) {
			handler->cert_free(cert);
			log_print("rsa_sig_decode_hash: decoding payload CERT "
			    "failed");
			continue;
		}
		/* We validated the cert, cache it for later use.  */
		handler->cert_insert(exchange->policy_id, cert);

		exchange->recv_cert = cert;
		exchange->recv_certtype = GET_ISAKMP_CERT_ENCODING(p->p);

		if (exchange->recv_certtype == ISAKMP_CERTENC_KEYNOTE) {
			struct keynote_deckey dc;
			char           *pp;

			dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
			dc.dec_key = key;

			pp = kn_encode_key(&dc, INTERNAL_ENC_PKCS1,
			    ENCODING_HEX, KEYNOTE_PUBLIC_KEY);
			if (pp == NULL) {
				kn_free_key(&dc);
				log_print("rsa_sig_decode_hash: failed to "
				    "ASCII-encode key");
				return -1;
			}
			if (asprintf(&exchange->keynote_key, "rsa-hex:%s",
			    pp) == -1) {
				free(pp);
				kn_free_key(&dc);
				log_print("rsa_sig_decode_hash: failed to asprintf()");
				return -1;
			}
			free(pp);
		}
		found++;
	}

#if defined (USE_DNSSEC)
	/*
	 * If no certificate provided a key, try to find a validated DNSSEC
	 * KEY.
	 */
	if (!found) {
		rawkey = dns_get_key(IKE_AUTH_RSA_SIG, msg, &rawkeylen);

		/* We need to convert 'void *rawkey' into 'RSA *key'.  */
		if (dns_RSA_dns_to_x509(rawkey, rawkeylen, &key) == 0)
			found++;
		else
			log_print("rsa_sig_decode_hash: KEY to RSA key "
			    "conversion failed");

		free(rawkey);
	}
#endif				/* USE_DNSSEC */

	/* If we still have not found a key, try to read it from a file. */
	if (!found)
		if (get_raw_key_from_file(IKE_AUTH_RSA_SIG, id, id_len, &key)
		    != -1)
			found++;

	if (!found) {
		log_print("rsa_sig_decode_hash: no public key found");
		return -1;
	}
	p = payload_first(msg, ISAKMP_PAYLOAD_SIG);
	if (!p) {
		log_print("rsa_sig_decode_hash: missing signature payload");
		RSA_free(key);
		return -1;
	}
	/* Check that the sig is of the correct size.  */
	len = GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_SIG_SZ;
	if (len != RSA_size(key)) {
		RSA_free(key);
		log_print("rsa_sig_decode_hash: "
		    "SIG payload length does not match public key");
		return -1;
	}
	*hash_p = malloc(len);
	if (!*hash_p) {
		RSA_free(key);
		log_error("rsa_sig_decode_hash: malloc (%d) failed", len);
		return -1;
	}
	len = RSA_public_decrypt(len, p->p + ISAKMP_SIG_DATA_OFF, *hash_p, key,
	    RSA_PKCS1_PADDING);
	if (len == -1) {
		RSA_free(key);
		log_print("rsa_sig_decode_hash: RSA_public_decrypt () failed");
		return -1;
	}
	/* Store key for later use */
	exchange->recv_key = key;
	exchange->recv_keytype = ISAKMP_KEY_RSA;

	if (len != (int)hashsize) {
		free(*hash_p);
		*hash_p = 0;
		log_print("rsa_sig_decode_hash: len %lu != hashsize %lu",
		    (unsigned long)len, (unsigned long)hashsize);
		return -1;
	}
	snprintf(header, sizeof header, "rsa_sig_decode_hash: HASH_%c",
	    initiator ? 'R' : 'I');
	LOG_DBG_BUF((LOG_MISC, 80, header, *hash_p, hashsize));

	p->flags |= PL_MARK;
	return 0;
}

static int
pre_shared_encode_hash(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	size_t          hashsize = ie->hash->hashsize;
	char            header[80];
	int             initiator = exchange->initiator;
	u_int8_t       *buf;

	buf = ipsec_add_hash_payload(msg, hashsize);
	if (!buf)
		return -1;

	if (ike_auth_hash(exchange, buf + ISAKMP_HASH_DATA_OFF) == -1)
		return -1;

	snprintf(header, sizeof header, "pre_shared_encode_hash: HASH_%c",
	    initiator ? 'I' : 'R');
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF,
	    hashsize));
	return 0;
}

/* Encrypt the HASH into a SIG type.  */
static int
rsa_sig_encode_hash(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	size_t          hashsize = ie->hash->hashsize, id_len;
	struct cert_handler *handler;
	char            header[80];
	int             initiator = exchange->initiator, idtype;
	u_int8_t       *buf, *data, *buf2, *id;
	u_int32_t       datalen;
	int32_t         sigsize;
	void           *sent_key;

	id = initiator ? exchange->id_i : exchange->id_r;
	id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

	/* We may have been provided these by the kernel */
	buf = (u_int8_t *)conf_get_str(exchange->name, "Credentials");
	if (buf && (idtype = conf_get_num(exchange->name, "Credential_Type",
	    -1)) != -1) {
		exchange->sent_certtype = idtype;
		handler = cert_get(idtype);
		if (!handler) {
			log_print("rsa_sig_encode_hash: cert_get (%d) failed",
			    idtype);
			return -1;
		}
		exchange->sent_cert =
		    handler->cert_from_printable((char *)buf);
		if (!exchange->sent_cert) {
			log_print("rsa_sig_encode_hash: failed to retrieve "
			    "certificate");
			return -1;
		}
		handler->cert_serialize(exchange->sent_cert, &data, &datalen);
		if (!data) {
			log_print("rsa_sig_encode_hash: cert serialization "
			    "failed");
			return -1;
		}
		goto aftercert;	/* Skip all the certificate discovery */
	}
	/* XXX This needs to be configurable.  */
	idtype = ISAKMP_CERTENC_KEYNOTE;

	/* Find a certificate with subjectAltName = id.  */
	handler = cert_get(idtype);
	if (!handler) {
		idtype = ISAKMP_CERTENC_X509_SIG;
		handler = cert_get(idtype);
		if (!handler) {
			log_print("rsa_sig_encode_hash: cert_get(%d) failed",
			    idtype);
			return -1;
		}
	}
	if (handler->cert_obtain(id, id_len, 0, &data, &datalen) == 0) {
		if (idtype == ISAKMP_CERTENC_KEYNOTE) {
			idtype = ISAKMP_CERTENC_X509_SIG;
			handler = cert_get(idtype);
			if (!handler) {
				log_print("rsa_sig_encode_hash: cert_get(%d) "
				    "failed", idtype);
				return -1;
			}
			if (handler->cert_obtain(id, id_len, 0, &data,
			    &datalen) == 0) {
				LOG_DBG((LOG_MISC, 10, "rsa_sig_encode_hash: "
				    "no certificate to send for id %s",
				    ipsec_id_string(id, id_len)));
				goto skipcert;
			}
		} else {
			LOG_DBG((LOG_MISC, 10,
			    "rsa_sig_encode_hash: no certificate to send"
			    " for id %s", ipsec_id_string(id, id_len)));
			goto skipcert;
		}
	}
	/* Let's store the certificate we are going to use */
	exchange->sent_certtype = idtype;
	exchange->sent_cert = handler->cert_get(data, datalen);
	if (!exchange->sent_cert) {
		free(data);
		log_print("rsa_sig_encode_hash: failed to get certificate "
		    "from wire encoding");
		return -1;
	}
aftercert:

	buf = realloc(data, ISAKMP_CERT_SZ + datalen);
	if (!buf) {
		log_error("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		    ISAKMP_CERT_SZ + datalen);
		free(data);
		return -1;
	}
	memmove(buf + ISAKMP_CERT_SZ, buf, datalen);
	SET_ISAKMP_CERT_ENCODING(buf, idtype);
	if (message_add_payload(msg, ISAKMP_PAYLOAD_CERT, buf,
	    ISAKMP_CERT_SZ + datalen, 1)) {
		free(buf);
		return -1;
	}
skipcert:

	/* Again, we may have these from the kernel */
	buf = (u_int8_t *)conf_get_str(exchange->name, "PKAuthentication");
	if (buf) {
		key_from_printable(ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE,
		    (char *)buf, &data, &datalen);
		if (!data) {
			log_print("rsa_sig_encode_hash: badly formatted RSA "
			    "private key");
			return 0;
		}
		sent_key = key_internalize(ISAKMP_KEY_RSA,
		    ISAKMP_KEYTYPE_PRIVATE, data, datalen);
		if (!sent_key) {
			log_print("rsa_sig_encode_hash: bad RSA private key "
			    "from dynamic SA acquisition subsystem");
			return 0;
		}
	} else {
		/* Try through the regular means.  */
		switch (id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ]) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV6_ADDR:
			util_ntoa((char **)&buf2,
			    id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ] ==
			    IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
			if (!buf2)
				return 0;
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
			buf2 = calloc(id_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof(char));
			if (!buf2) {
				log_print("rsa_sig_encode_hash: malloc (%lu) "
				    "failed", (unsigned long)id_len -
				    ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
				return 0;
			}
			memcpy(buf2, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			    id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
			break;

			/* XXX Support more ID types?  */
		default:
			buf2 = 0;
			return 0;
		}

		sent_key = ike_auth_get_key(IKE_AUTH_RSA_SIG, exchange->name,
		    (char *)buf2, 0);
		free(buf2);

		/* Did we find a key?  */
		if (!sent_key) {
			log_print("rsa_sig_encode_hash: "
			    "could not get private key");
			return -1;
		}
	}

	/* Enable RSA blinding.  */
	if (RSA_blinding_on(sent_key, NULL) != 1) {
		log_error("rsa_sig_encode_hash: RSA_blinding_on () failed.");
		RSA_free(sent_key);
		return -1;
	}
	/* XXX hashsize is not necessarily prf->blocksize.  */
	buf = malloc(hashsize);
	if (!buf) {
		log_error("rsa_sig_encode_hash: malloc (%lu) failed",
		    (unsigned long)hashsize);
		RSA_free(sent_key);
		return -1;
	}
	if (ike_auth_hash(exchange, buf) == -1) {
		free(buf);
		RSA_free(sent_key);
		return -1;
	}
	snprintf(header, sizeof header, "rsa_sig_encode_hash: HASH_%c",
	    initiator ? 'I' : 'R');
	LOG_DBG_BUF((LOG_MISC, 80, header, buf, hashsize));

	data = malloc(RSA_size(sent_key));
	if (!data) {
		log_error("rsa_sig_encode_hash: malloc (%d) failed",
		    RSA_size(sent_key));
		free(buf);
		RSA_free(sent_key);
		return -1;
	}
	sigsize = RSA_private_encrypt(hashsize, buf, data, sent_key,
	    RSA_PKCS1_PADDING);
	if (sigsize == -1) {
		log_print("rsa_sig_encode_hash: "
		    "RSA_private_encrypt () failed");
		free(data);
		free(buf);
		RSA_free(sent_key);
		return -1;
	}
	datalen = (u_int32_t) sigsize;

	free(buf);
	RSA_free(sent_key);

	buf = realloc(data, ISAKMP_SIG_SZ + datalen);
	if (!buf) {
		log_error("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		    ISAKMP_SIG_SZ + datalen);
		free(data);
		return -1;
	}
	memmove(buf + ISAKMP_SIG_SZ, buf, datalen);

	snprintf(header, sizeof header, "rsa_sig_encode_hash: SIG_%c",
	    initiator ? 'I' : 'R');
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF,
	    datalen));
	if (message_add_payload(msg, ISAKMP_PAYLOAD_SIG, buf,
	    ISAKMP_SIG_SZ + datalen, 1)) {
		free(buf);
		return -1;
	}
	return 0;
}

int
ike_auth_hash(struct exchange *exchange, u_int8_t *buf)
{
	struct ipsec_exch *ie = exchange->data;
	struct prf     *prf;
	struct hash    *hash = ie->hash;
	int             initiator = exchange->initiator;
	u_int8_t       *id;
	size_t          id_len;

	/* Choose the right fields to fill-in.  */
	id = initiator ? exchange->id_i : exchange->id_r;
	id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

	/* Allocate the prf and start calculating our HASH.  */
	prf = prf_alloc(ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
	if (!prf)
		return -1;

	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, initiator ? ie->g_xi : ie->g_xr, ie->g_x_len);
	prf->Update(prf->prfctx, initiator ? ie->g_xr : ie->g_xi, ie->g_x_len);
	prf->Update(prf->prfctx, exchange->cookies +
	    (initiator ? ISAKMP_HDR_ICOOKIE_OFF : ISAKMP_HDR_RCOOKIE_OFF),
	    ISAKMP_HDR_ICOOKIE_LEN);
	prf->Update(prf->prfctx, exchange->cookies +
	    (initiator ? ISAKMP_HDR_RCOOKIE_OFF : ISAKMP_HDR_ICOOKIE_OFF),
	    ISAKMP_HDR_ICOOKIE_LEN);
	prf->Update(prf->prfctx, ie->sa_i_b, ie->sa_i_b_len);
	prf->Update(prf->prfctx, id, id_len);
	prf->Final(buf, prf->prfctx);
	prf_free(prf);
	return 0;
}

static int
get_raw_key_from_file(int type, u_int8_t *id, size_t id_len, RSA **rsa)
{
	char            filename[FILENAME_MAX];
	char           *fstr;
	FILE           *keyfp;

	if (type != IKE_AUTH_RSA_SIG) {	/* XXX More types? */
		LOG_DBG((LOG_NEGOTIATION, 20, "get_raw_key_from_file: "
		    "invalid auth type %d\n", type));
		return -1;
	}
	*rsa = 0;

	fstr = conf_get_str("General", "Pubkey-directory");
	if (!fstr)
		fstr = CONF_DFLT_PUBKEY_DIR;

	if (snprintf(filename, sizeof filename, "%s/", fstr) >
	    (int)sizeof filename - 1)
		return -1;

	fstr = ipsec_id_string(id, id_len);
	if (!fstr) {
		LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		    "ipsec_id_string failed"));
		return -1;
	}
	strlcat(filename, fstr, sizeof filename - strlen(filename));
	free(fstr);

	/* If the file does not exist, fail silently.  */
	keyfp = monitor_fopen(filename, "r");
	if (keyfp) {
		*rsa = PEM_read_RSA_PUBKEY(keyfp, NULL, NULL, NULL);
		if (!*rsa) {
			rewind(keyfp);
			*rsa = PEM_read_RSAPublicKey(keyfp, NULL, NULL, NULL);
		}
		if (!*rsa)
			log_print("get_raw_key_from_file: failed to get "
			    "public key %s", filename);
		fclose(keyfp);
	} else if (errno != ENOENT) {
		log_error("get_raw_key_from_file: monitor_fopen "
		    "(\"%s\", \"r\") failed", filename);
		return -1;
	} else
		LOG_DBG((LOG_NEGOTIATION, 50,
		    "get_raw_key_from_file: file %s not found", filename));

	return (*rsa ? 0 : -1);
}
@


1.112
log
@Fix a few fd leaks in isakmpd.

The latter close is from a sweep of the tree looking for fdopen problems.
While reviewing the patch, gerhard@@ fixed another leak.

ok gerhard@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.111 2014/08/23 00:48:57 doug Exp $	 */
a202 1
			size = (size_t)sb.st_size;
@


1.111
log
@Fix double free in ike_auth.c

ok jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.110 2007/04/16 13:01:39 moritz Exp $	 */
d304 1
d311 1
@


1.110
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.109 2006/11/24 13:52:14 reyk Exp $	 */
d284 2
@


1.109
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.108 2006/11/09 09:43:35 markus Exp $	 */
d238 1
a238 2
				if (buf2)
					free(buf2);
d301 1
a301 2
			if (privkeyfile)
				free(privkeyfile);
d307 1
a307 2
			if (privkeyfile)
				free(privkeyfile);
d317 1
a317 2
		if (privkeyfile)
			free(privkeyfile);
d390 1
a390 2
	if (buf)
		free(buf);
d753 1
a753 2
		if (rawkey)
			free(rawkey);
d1043 1
a1043 2
		if (data)
			free(data);
@


1.108
log
@support public keys w/o SubjectPublicKeyInfo (format: BEGIN RSA PUBLIC KEY)
ok ho, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.107 2006/06/10 21:09:45 msf Exp $	 */
d913 2
a914 1
				    "no certificate to send"));
d919 2
a920 1
			    "rsa_sig_encode_hash: no certificate to send"));
@


1.107
log
@Allow isakmpd to use a different private rsa key per isakmp ID. Hans wrote this a long time ago, I synced it to -current and tested.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.106 2005/11/17 13:44:11 moritz Exp $	 */
d1149 4
@


1.106
log
@add a free() which got lost in r1.104. ok hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.105 2005/11/14 23:25:11 deraadt Exp $	 */
d137 1
a137 2
	int	 fd;
	char	*keyfile;
d140 2
a141 1
	size_t	fsize;
d203 1
a259 1
		keyfile = conf_get_str("X509-certificates", "Private-key");
d261 27
a287 1
		fd = monitor_open(keyfile, O_RDONLY, 0);
d289 10
a298 3
			log_print("ike_auth_get_key: failed opening \"%s\"",
			    keyfile);
			return 0;
d301 3
a303 2
		if (check_file_secrecy_fd(fd, keyfile, &fsize) < 0) {
			close(fd);
d309 2
a310 1
			close(fd);
d319 3
@


1.105
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.104 2005/07/14 12:50:08 moritz Exp $	 */
d695 1
@


1.104
log
@fix some memleaks. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.103 2005/05/26 06:11:09 hshoexer Exp $	 */
a188 1
			int             pkflen;
d191 3
a193 6
			pkflen = strlen(keyfile) + strlen(local_id) +
			    sizeof PRIVATE_KEY_FILE + sizeof "//" - 1;
			privkeyfile = calloc(pkflen, sizeof(char));
			if (!privkeyfile) {
				log_print("ike_auth_get_key: failed to "
				    "allocate %d bytes", pkflen);
a195 2
			snprintf(privkeyfile, pkflen, "%s/%s/%s", keyfile,
			    local_id, PRIVATE_KEY_FILE);
a680 1
			int             dclen;
d693 2
a694 4
			dclen = strlen(pp) + sizeof "rsa-hex:";
			exchange->keynote_key = calloc(dclen, sizeof(char));
			if (!exchange->keynote_key) {
				free(pp);
d696 1
a696 2
				log_print("rsa_sig_decode_hash: failed to "
				    "allocate %d bytes", dclen);
a698 2
			snprintf(exchange->keynote_key, dclen, "rsa-hex:%s",
			    pp);
@


1.103
log
@Use TAILQ_FOREACH where possible, remove payload_last()

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.102 2005/04/08 22:32:10 cloder Exp $	 */
d987 1
d995 1
d1000 1
d1011 2
d1029 1
@


1.102
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.101 2005/04/08 20:04:57 hshoexer Exp $	 */
d614 1
a614 2
	for (p = payload_first(msg, ISAKMP_PAYLOAD_CERT); p;
	    p = TAILQ_NEXT(p, link)) {
@


1.101
log
@kill gmp
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.100 2005/04/08 18:35:37 deraadt Exp $	 */
a47 2

#include "sysdep.h"
@


1.100
log
@zap USE_RAWKEY
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.99 2005/04/08 17:15:01 deraadt Exp $	 */
a57 1
#include "gmp_util.h"
@


1.99
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.98 2005/04/05 20:46:20 cloder Exp $	 */
a84 1
#if defined (USE_RAWKEY)
a85 1
#endif
a739 1
#if defined (USE_RAWKEY)
a744 1
#endif
a1084 1
#if defined (USE_RAWKEY)
a1133 1
#endif				/* USE_RAWKEY */
@


1.98
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.97 2005/02/22 16:57:48 hshoexer Exp $	 */
a45 1
#if defined (USE_KEYNOTE)
a46 1
#endif
a188 1
#if defined (USE_KEYNOTE)
a268 1
#endif				/* USE_KEYNOTE */
a575 1
#if defined (USE_POLICY) || defined (USE_KEYNOTE)
a585 1
#endif				/* USE_POLICY || USE_KEYNOTE */
a605 1
#if defined (USE_POLICY)
a607 1
#endif				/* USE_POLICY */
a689 1
#if defined (USE_POLICY) || defined (USE_KEYNOTE)
a718 2
#endif

@


1.97
log
@better error messages

ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.96 2004/12/22 12:25:27 hshoexer Exp $	 */
a72 1
#if defined (USE_X509)
a73 1
#endif
a82 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a85 1
#endif
a105 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a110 1
#endif
a143 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a145 1
#if defined (USE_X509)
a148 2
#endif
#endif
a190 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a272 1
#ifdef USE_X509
a305 2
#endif /* USE_X509 */
#endif /* USE_X509 || USE_KEYNOTE */
a411 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a458 1
#endif				/* USE_X509 || USE_KEYNOTE */
a534 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a809 1
#endif				/* USE_X509 || USE_KEYNOTE */
a834 1
#if defined (USE_X509) || defined (USE_KEYNOTE)
a1063 1
#endif				/* USE_X509 || USE_KEYNOTE */
@


1.96
log
@Fix parenthesis mismatch, from Stefan Miltchev.  Thanks!
While around, zap some spaces

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.95 2004/08/08 19:11:06 deraadt Exp $	 */
d170 1
a170 1
			    id, local_id);
d1156 3
@


1.95
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.94 2004/06/23 03:01:52 hshoexer Exp $	 */
d384 1
a384 1
	    (char *) buf, &keylen);
d464 1
a464 1
	    (unsigned long) ie->g_x_len));
d813 1
a813 1
	if (len != (int) hashsize) {
d873 1
a873 1
	buf = (u_int8_t *) conf_get_str(exchange->name, "Credentials");
d875 1
a875 1
	    -1) != -1)) {
d961 1
a961 1
	buf = (u_int8_t *) conf_get_str(exchange->name, "PKAuthentication");
@


1.94
log
@Avoid stat before open.  Do open and fstat instead.
Remove check_file_secrecy() as it is obsoleted be check_file_secrecy_fd().

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.93 2004/06/22 18:22:18 hshoexer Exp $	 */
d676 1
a676 1
		if (GET_ISAKMP_CERT_ENCODING(p->p) == 
@


1.93
log
@kn_get_string() may return NULL on failure.  Handle this corrctly.

with msf@@, ok ho@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.92 2004/06/20 17:17:34 ho Exp $	 */
d151 1
d208 1
a208 1
			int             fd, pkflen;
d288 9
a296 1
		if (check_file_secrecy(keyfile, &fsize))
d298 1
d300 3
a302 4
		keyfp = monitor_fopen(keyfile, "r");
		if (!keyfp) {
			log_print("ike_auth_get_key: failed opening \"%s\"",
			    keyfile);
@


1.92
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.91 2004/06/14 13:53:31 hshoexer Exp $	 */
d259 4
a262 3
			if (kn_decode_key(&dc, buf2, KEYNOTE_PRIVATE_KEY)
			    == -1) {
				free(buf2);
@


1.91
log
@avoid stat before open

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.90 2004/06/14 09:55:41 ho Exp $	 */
d516 1
a516 1
	payload = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
d577 1
a577 1
	p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_CERT]);
d634 1
a634 1
	for (p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_CERT]); p;
d772 1
a772 1
	p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SIG]);
@


1.90
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.89 2004/06/02 16:19:16 hshoexer Exp $	 */
a36 2
#include <unistd.h>
#include <fcntl.h>
d39 3
d44 1
d178 1
a178 1
				    "failed", (unsigned long) *keylen);
d222 2
a223 1
			if (monitor_stat(keyfile, &sb) < 0) {
a226 1
			size = (size_t) sb.st_size;
d228 2
a229 4
			fd = monitor_open(keyfile, O_RDONLY, 0);
			if (fd < 0) {
				log_print("ike_auth_get_key: failed opening "
				    "\"%s\"", keyfile);
d231 1
d234 2
d244 1
a244 1
			if (read(fd, buf, size) != (ssize_t) size) {
a1115 1
	struct stat     st;
d1143 2
a1144 7
	if (monitor_stat(filename, &st) == 0) {
		keyfp = monitor_fopen(filename, "r");
		if (!keyfp) {
			log_error("get_raw_key_from_file: monitor_fopen "
			    "(\"%s\", \"r\") failed", filename);
			return -1;
		}
d1147 4
@


1.89
log
@remove unused BIO-functions.

ok markus@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.88 2004/05/26 22:17:58 hshoexer Exp $	 */
d97 2
a98 1
		IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid, pre_shared_decode_hash,
d103 2
a104 1
		IKE_AUTH_DSS, sig_gen_skeyid, pre_shared_decode_hash,
d110 2
a111 1
		IKE_AUTH_RSA_SIG, sig_gen_skeyid, rsa_sig_decode_hash,
d117 2
a118 1
		IKE_AUTH_RSA_ENC, enc_gen_skeyid, pre_shared_decode_hash,
d122 2
a123 1
		IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid, pre_shared_decode_hash,
d256 2
a257 1
			if (kn_decode_key(&dc, buf2, KEYNOTE_PRIVATE_KEY) == -1) {
d300 2
a301 1
			log_print("ike_auth_get_key: PEM_read_bio_RSAPrivateKey failed");
d355 2
a356 1
			    exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
d392 2
a393 1
	prf = prf_alloc(ie->prf_type, ie->hash->type, exchange->recv_key, keylen);
d617 2
a618 1
					x509_generate_kn(exchange->policy_id, cert);
d644 2
a645 2
			LOG_DBG((LOG_MISC, 30,
			    "rsa_sig_decode_hash: no handler for %s CERT encoding",
d653 2
a654 1
			log_print("rsa_sig_decode_hash: can not get data from CERT");
d663 2
a664 1
		if (GET_ISAKMP_CERT_ENCODING(p->p) == ISAKMP_CERTENC_X509_SIG) {
d711 2
a712 2
			pp = kn_encode_key(&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			    KEYNOTE_PUBLIC_KEY);
d728 2
a729 1
			snprintf(exchange->keynote_key, dclen, "rsa-hex:%s", pp);
d835 2
a836 1
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize));
d861 2
a862 2
	if (buf && (idtype = conf_get_num(exchange->name, "Credential_Type", -1)
	    != -1)) {
d870 2
a871 1
		exchange->sent_cert = handler->cert_from_printable((char *)buf);
d910 2
a911 2
				LOG_DBG((LOG_MISC, 10,
				    "rsa_sig_encode_hash: no certificate to send"));
d1003 2
a1004 1
			log_print("rsa_sig_encode_hash: could not get private key");
d1038 2
a1039 1
		log_print("rsa_sig_encode_hash: RSA_private_encrypt () failed");
d1061 2
a1062 1
	LOG_DBG_BUF((LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF, datalen));
@


1.88
log
@do not leak fd on error path.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.87 2004/05/23 18:17:55 hshoexer Exp $	 */
a145 1
#if defined (USE_PRIVSEP)
a146 3
#else
	BIO	*keyh;
#endif
a279 1
#if defined (USE_PRIVSEP)
a291 20
#else
		keyh = BIO_new(BIO_s_file());
		if (keyh == NULL) {
			log_print("ike_auth_get_key: BIO_new (BIO_s_file ())"
			    "failed");
			return 0;
		}
		if (BIO_read_filename(keyh, keyfile) == -1) {
			log_print("ike_auth_get_key: BIO_read_filename (keyh,"
			    "\"%s\") failed", keyfile);
			BIO_free(keyh);
			return 0;
		}
#if SSLEAY_VERSION_NUMBER >= 0x00904100L
		rsakey = PEM_read_bio_RSAPrivateKey(keyh, NULL, NULL, NULL);
#else
		rsakey = PEM_read_bio_RSAPrivateKey(keyh, NULL, NULL);
#endif
		BIO_free(keyh);
#endif				/* USE_PRIVSEP */
a1095 1
#if defined (USE_PRIVSEP)
a1096 3
#else
	BIO            *bio;
#endif
a1123 1
#if defined (USE_PRIVSEP)
a1131 17
#else
		bio = BIO_new(BIO_s_file());
		if (!bio) {
			log_error("get_raw_key_from_file: could not initialize BIO");
			return -1;
		}
		if (BIO_read_filename(bio, filename) <= 0) {
			LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
			    "BIO_read_filename(bio, \"%s\") failed", filename));
			BIO_free(bio);
			return -1;
		}
		LOG_DBG((LOG_NEGOTIATION, 80,
		    "get_raw_key_from_file: reading file %s", filename));
		*rsa = PEM_read_bio_RSA_PUBKEY(bio, NULL, NULL, NULL);
		BIO_free(bio);
#endif				/* USE_PRIVSEP */
@


1.87
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.86 2004/04/15 18:39:25 deraadt Exp $	 */
d237 1
d246 1
@


1.86
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_auth.c,v 1.85 2004/04/07 22:45:49 ho Exp $	 */
d142 1
a142 1
	char           *key, *buf;
d144 1
a144 1
	char           *keyfile;
d147 1
a147 1
	FILE           *keyfp;
d149 1
a149 1
	BIO            *keyh;
d151 2
a152 2
	RSA            *rsakey;
	size_t          fsize;
d174 2
a175 2
				log_error("ike_auth_get_key: malloc (%lu) failed",
				    (unsigned long) *keylen);
d178 1
a178 1
			if (hex2raw(key + 2, (unsigned char *) buf, *keylen)) {
d180 2
a181 2
				log_print("ike_auth_get_key: invalid hex key %s",
				    key);
d199 2
a200 2
		if (local_id &&
		    (keyfile = conf_get_str("KeyNote", "Credential-directory")) != 0) {
d211 2
a212 2
				log_print("ike_auth_get_key: failed to allocate %d bytes",
				    pkflen);
d215 2
a216 2
			snprintf(privkeyfile, pkflen, "%s/%s/%s", keyfile, local_id,
				 PRIVATE_KEY_FILE);
d227 2
a228 2
				log_print("ike_auth_get_key: failed opening \"%s\"",
				    keyfile);
d234 2
a235 2
				log_print("ike_auth_get_key: failed allocating %lu bytes",
				    (unsigned long) size + 1);
d243 1
a243 1
				    (unsigned long) size, keyfile);
d255 2
a256 2
				log_print("ike_auth_get_key: failed decoding key in \"%s\"",
				    keyfile);
d263 3
a265 2
				log_print("ike_auth_get_key: wrong algorithm type %d in \"%s\"",
				    dc.dec_algorithm, keyfile);
d285 2
a286 1
			log_print("ike_auth_get_key: failed opening \"%s\"", keyfile);
d298 2
a299 2
			log_print("ike_auth_get_key: "
			    "BIO_new (BIO_s_file ()) failed");
d303 2
a304 3
			log_print("ike_auth_get_key: "
			    "BIO_read_filename (keyh, \"%s\") failed",
			    keyfile);
d352 3
a354 2
			    exchange->id_i[0] == IPSEC_ID_IPV4_ADDR ? AF_INET : AF_INET6,
			    exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
d364 3
a366 2
				log_print("pre_shared_gen_skeyid: malloc (%lu) failed",
				    (unsigned long) exchange->id_i_len -
d372 2
a373 1
			    exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
d399 1
a399 1
		    (unsigned long) keylen);
d415 1
a415 1
		    (unsigned long) *sz);
d446 3
a448 2
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with",
	    (u_int8_t *) key, exchange->nonce_i_len + exchange->nonce_r_len));
d460 1
a460 1
		    (unsigned long) *sz);
d466 2
a467 2
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID fed with g^xy",
	    ie->g_xy, ie->g_x_len));
d540 1
a540 1
		    (unsigned long) hashsize);
d584 3
a586 2
	 * XXX Assume we should use the same kind of certification as the remote...
	 * moreover, just use the first CERT payload to decide what to use.
d605 2
a606 1
		log_print("rsa_sig_decode_hash: failed to initialize policy session");
d616 2
a617 2
				LOG_DBG((LOG_CRYPTO, 50,
				    "rsa_sig_decode_hash: certificate malformed"));
d626 2
a627 2
					    "rsa_sig_decode_hash: using cert of type %d",
					    handler->id));
d671 2
a672 1
			log_print("rsa_sig_decode_hash: received CERT can't be validated");
d679 2
a680 1
				log_print("rsa_sig_decode_hash: can not get subject from CERT");
d687 2
a688 1
				    memcmp(id + 4, id_cert[i] + 4, id_len - 4) == 0) {
d694 2
a695 1
				log_print("rsa_sig_decode_hash: no CERT subject match the ID");
d703 2
a704 1
			log_print("rsa_sig_decode_hash: decoding payload CERT failed");
d726 2
a727 1
				log_print("rsa_sig_decode_hash: failed to ASCII-encode key");
d735 2
a736 2
				log_print("rsa_sig_decode_hash: failed to allocate %d bytes",
				    dclen);
d759 2
a760 1
			log_print("rsa_sig_decode_hash: KEY to RSA key conversion failed");
d770 2
a771 1
		if (get_raw_key_from_file(IKE_AUTH_RSA_SIG, id, id_len, &key) != -1)
d814 1
a814 1
		    (unsigned long) len, (unsigned long) hashsize);
d870 2
a871 2
	if (buf &&
	    (idtype = conf_get_num(exchange->name, "Credential_Type", -1) != -1)) {
d875 2
a876 1
			log_print("rsa_sig_encode_hash: cert_get (%d) failed", idtype);
d879 1
a879 1
		exchange->sent_cert = handler->cert_from_printable((char *) buf);
d881 2
a882 1
			log_print("rsa_sig_encode_hash: failed to retrieve certificate");
d887 2
a888 1
			log_print("rsa_sig_encode_hash: cert serialization failed");
d902 2
a903 1
			log_print("rsa_sig_encode_hash: cert_get(%d) failed", idtype);
d912 2
a913 2
				log_print("rsa_sig_encode_hash: cert_get(%d) failed",
				    idtype);
d916 2
a917 1
			if (handler->cert_obtain(id, id_len, 0, &data, &datalen) == 0) {
d933 2
a934 2
		log_print("rsa_sig_encode_hash: failed to get certificate from wire "
		    "encoding");
d958 2
a959 2
		key_from_printable(ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, (char *) buf,
		    &data, &datalen);
d961 2
a962 1
			log_print("rsa_sig_encode_hash: badly formatted RSA private key");
d965 2
a966 2
		sent_key = key_internalize(ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE,
		    data, datalen);
d968 2
a969 2
			log_print("rsa_sig_encode_hash: bad RSA private key from dynamic "
			    "SA acquisition subsystem");
d977 1
a977 1
			util_ntoa((char **) &buf2,
d987 2
a988 2
			buf2 = calloc(id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			    sizeof(char));
d990 3
a992 3
				log_print("rsa_sig_encode_hash: malloc (%lu) failed",
				    (unsigned long) id_len - ISAKMP_ID_DATA_OFF +
				    ISAKMP_GEN_SZ + 1);
d1006 1
a1006 1
		    (char *) buf2, 0);
d1025 1
a1025 1
		    (unsigned long) hashsize);
d1137 1
a1137 1
	    (int) sizeof filename - 1)
d1154 2
a1155 2
			log_error("get_raw_key_from_file: monitor_fopen (\"%s\", \"r\") "
			    "failed", filename);
@


1.85
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.84 2004/03/31 10:54:46 ho Exp $	*/
/*	$EOM: ike_auth.c,v 1.59 2000/11/21 00:21:31 angelos Exp $	*/
d76 1
a76 1
static u_int8_t *enc_gen_skeyid (struct exchange *, size_t *);
d78 1
a78 1
static u_int8_t *pre_shared_gen_skeyid (struct exchange *, size_t *);
d80 2
a81 2
static int pre_shared_decode_hash (struct message *);
static int pre_shared_encode_hash (struct message *);
d84 3
a86 3
static u_int8_t *sig_gen_skeyid (struct exchange *, size_t *);
static int rsa_sig_decode_hash (struct message *);
static int rsa_sig_encode_hash (struct message *);
d90 1
a90 1
static int get_raw_key_from_file (int, u_int8_t *, size_t, RSA **);
d93 1
a93 1
static int ike_auth_hash (struct exchange *, u_int8_t *);
d96 4
a99 4
  {
    IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
d101 4
a104 4
  {
    IKE_AUTH_DSS, sig_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
d107 4
a110 4
  {
    IKE_AUTH_RSA_SIG, sig_gen_skeyid, rsa_sig_decode_hash,
    rsa_sig_encode_hash
  },
d113 8
a120 8
  {
    IKE_AUTH_RSA_ENC, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
  {
    IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash
  },
d125 1
a125 1
ike_auth_get (u_int16_t id)
d127 1
a127 1
  size_t i;
d129 4
a132 4
  for (i = 0; i < sizeof ike_auth / sizeof ike_auth[0]; i++)
    if (id == ike_auth[i].id)
      return &ike_auth[i];
  return 0;
d140 1
a140 1
ike_auth_get_key (int type, char *id, char *local_id, size_t *keylen)
d142 1
a142 1
  char *key, *buf;
d144 1
a144 1
  char *keyfile;
d147 1
a147 1
  FILE *keyfp;
d149 1
a149 1
  BIO *keyh;
d151 2
a152 2
  RSA *rsakey;
  size_t fsize;
d156 39
a194 47
  switch (type)
    {
    case IKE_AUTH_PRE_SHARED:
      /* Get the pre-shared key for our peer.  */
      key = conf_get_str (id, "Authentication");
      if (!key && local_id)
	key = conf_get_str (local_id, "Authentication");

      if (!key)
        {
	  log_print ("ike_auth_get_key: "
		     "no key found for peer \"%s\" or local ID \"%s\"",
		     id, local_id);
	  return 0;
	}

      /* If the key starts with 0x it is in hex format.  */
      if (strncasecmp (key, "0x", 2) == 0)
	{
	  *keylen = (strlen (key) - 1) / 2;
	  buf = malloc (*keylen);
	  if (!buf)
	    {
	      log_error ("ike_auth_get_key: malloc (%lu) failed",
		(unsigned long)*keylen);
	      return 0;
	    }
	  if (hex2raw (key + 2, (unsigned char *)buf, *keylen))
	    {
	      free (buf);
	      log_print ("ike_auth_get_key: invalid hex key %s", key);
	      return 0;
	    }
	  key = buf;
	}
      else
	{
	  buf = key;
	  key = strdup (buf);
	  if (!key)
	    {
	      log_error ("ike_auth_get_key: strdup() failed");
	      return 0;
	    }
	  *keylen = strlen (key);
	}
      break;
d196 1
a196 1
    case IKE_AUTH_RSA_SIG:
d199 75
a273 89
      if (local_id &&
	  (keyfile = conf_get_str ("KeyNote", "Credential-directory")) != 0)
        {
	  struct stat sb;
	  struct keynote_deckey dc;
	  char *privkeyfile, *buf2;
	  int fd, pkflen;
	  size_t size;

	  pkflen = strlen (keyfile) + strlen (local_id) +
	    sizeof PRIVATE_KEY_FILE + sizeof "//" - 1;
	  privkeyfile = calloc (pkflen, sizeof (char));
	  if (!privkeyfile)
	    {
	      log_print ("ike_auth_get_key: failed to allocate %d bytes",
			 pkflen);
	      return 0;
	    }

	  snprintf (privkeyfile, pkflen, "%s/%s/%s", keyfile, local_id,
		   PRIVATE_KEY_FILE);
	  keyfile = privkeyfile;

	  if (monitor_stat (keyfile, &sb) < 0)
	    {
	      free (keyfile);
	      goto ignorekeynote;
	    }
	  size = (size_t)sb.st_size;

	  fd = monitor_open (keyfile, O_RDONLY, 0);
	  if (fd < 0)
	    {
	      log_print ("ike_auth_get_key: failed opening \"%s\"", keyfile);
	      free (keyfile);
	      return 0;
	    }

	  buf = calloc (size + 1, sizeof (char));
	  if (!buf)
	    {
	      log_print ("ike_auth_get_key: failed allocating %lu bytes",
			 (unsigned long)size + 1);
	      free (keyfile);
	      return 0;
	    }

	  if (read (fd, buf, size) != (ssize_t)size)
	    {
	      free (buf);
	      log_print ("ike_auth_get_key: "
			 "failed reading %lu bytes from \"%s\"",
			(unsigned long)size, keyfile);
	      free (keyfile);
	      return 0;
	    }

	  close (fd);

	  /* Parse private key string */
	  buf2 = kn_get_string (buf);
	  free (buf);

	  if (kn_decode_key (&dc, buf2, KEYNOTE_PRIVATE_KEY) == -1)
	    {
	      free (buf2);
	      log_print ("ike_auth_get_key: failed decoding key in \"%s\"",
			 keyfile);
	      free (keyfile);
	      return 0;
	    }

	  free (buf2);

	  if (dc.dec_algorithm != KEYNOTE_ALGORITHM_RSA)
	    {
	      log_print ("ike_auth_get_key: wrong algorithm type %d in \"%s\"",
			 dc.dec_algorithm, keyfile);
	      free (keyfile);
	      kn_free_key (&dc);
	      return 0;
	    }

	  free (keyfile);
	  return dc.dec_key;
	}

    ignorekeynote:
#endif /* USE_KEYNOTE */
d275 2
a276 2
      /* Otherwise, try X.509 */
      keyfile = conf_get_str ("X509-certificates", "Private-key");
d278 2
a279 2
      if (check_file_secrecy (keyfile, &fsize))
	return 0;
d282 5
a286 6
      keyfp = monitor_fopen (keyfile, "r");
      if (!keyfp)
	{
	  log_print ("ike_auth_get_key: failed opening \"%s\"", keyfile);
	  return 0;
	}
d288 1
a288 1
      rsakey = PEM_read_RSAPrivateKey (keyfp, NULL, NULL, NULL);
d290 1
a290 1
      rsakey = PEM_read_RSAPrivateKey (keyfp, NULL, NULL);
d292 1
a292 1
      fclose (keyfp);
d294 13
a306 16
      keyh = BIO_new (BIO_s_file ());
      if (keyh == NULL)
	{
	  log_print ("ike_auth_get_key: "
		     "BIO_new (BIO_s_file ()) failed");
	  return 0;
	}
      if (BIO_read_filename (keyh, keyfile) == -1)
	{
	  log_print ("ike_auth_get_key: "
		     "BIO_read_filename (keyh, \"%s\") failed",
		     keyfile);
	  BIO_free (keyh);
	  return 0;
	}

d308 1
a308 1
      rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL, NULL);
d310 1
a310 1
      rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL);
d312 2
a313 2
      BIO_free (keyh);
#endif	/* USE_PRIVSEP */
d315 5
a319 7
      if (!rsakey)
	{
	  log_print ("ike_auth_get_key: PEM_read_bio_RSAPrivateKey failed");
	  return 0;
	}

      return rsakey;
d323 4
a326 4
    default:
      log_print ("ike_auth_get_key: unknown key type %d", type);
      return 0;
    }
d328 1
a328 1
  return key;
d332 1
a332 1
pre_shared_gen_skeyid (struct exchange *exchange, size_t *sz)
d334 42
a375 45
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *skeyid;
  u_int8_t *buf = 0;
  unsigned char *key;
  size_t keylen;

  /*
   * If we're the responder and have the initiator's ID (which is the
   * case in Aggressive mode), try to find the preshared key in the
   * section of the initiator's Phase 1 ID.  This allows us to do
   * mobile user support with preshared keys.
   */
  if (!exchange->initiator && exchange->id_i)
    {
      switch (exchange->id_i[0])
        {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa ((char **)&buf,
		     exchange->id_i[0] == IPSEC_ID_IPV4_ADDR
		     ? AF_INET : AF_INET6,
		     exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  if (!buf)
	    return 0;
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  buf = calloc (exchange->id_i_len - ISAKMP_ID_DATA_OFF
			+ ISAKMP_GEN_SZ + 1, sizeof (char));
	  if (!buf)
	    {
              log_print ("pre_shared_gen_skeyid: malloc (%lu) failed",
			 (unsigned long)exchange->id_i_len - ISAKMP_ID_DATA_OFF
			 + ISAKMP_GEN_SZ + 1);
	      return 0;
	    }
	  memcpy (buf, exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;

	  /* XXX Support more ID types ? */
	default:
	  break;
d377 44
a420 50
    }

  /*
   * Get the pre-shared key for our peer. This will work even if the key
   * has been passed to us through a mechanism like PFKEYv2.
   */
  key = ike_auth_get_key (IKE_AUTH_PRE_SHARED, exchange->name, (char *)buf,
			  &keylen);
  if (buf)
    free (buf);

  /* Fail if no key could be found.  */
  if (!key)
    return 0;

  /* Store the secret key for later policy processing.  */
  exchange->recv_key = calloc (keylen + 1, sizeof (char));
  exchange->recv_keytype = ISAKMP_KEY_PASSPHRASE;
  if (!exchange->recv_key)
    {
      log_error ("pre_shared_gen_skeyid: malloc (%lu) failed",
	(unsigned long)keylen);
      free (key);
      return 0;
    }
  memcpy (exchange->recv_key, key, keylen);
  exchange->recv_certtype = ISAKMP_CERTENC_NONE;
  free (key);

  prf = prf_alloc (ie->prf_type, ie->hash->type, exchange->recv_key, keylen);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      log_error ("pre_shared_gen_skeyid: malloc (%lu) failed",
	(unsigned long)*sz);
      prf_free (prf);
      return 0;
    }

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  prf->Update (prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);

  return skeyid;
d426 1
a426 1
sig_gen_skeyid (struct exchange *exchange, size_t *sz)
d428 11
a438 11
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *skeyid;
  unsigned char *key;

  key = malloc (exchange->nonce_i_len + exchange->nonce_r_len);
  if (!key)
    return 0;
  memcpy (key, exchange->nonce_i, exchange->nonce_i_len);
  memcpy (key + exchange->nonce_i_len, exchange->nonce_r,
	  exchange->nonce_r_len);
d440 1
a440 1
  LOG_DBG ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: PRF type %d, hash %d",
d442 2
a443 29
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with",
		(u_int8_t *)key,
		exchange->nonce_i_len + exchange->nonce_r_len));

  prf = prf_alloc (ie->prf_type, ie->hash->type, key,
		   exchange->nonce_i_len + exchange->nonce_r_len);
  free (key);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      log_error ("sig_gen_skeyid: malloc (%lu) failed",
	(unsigned long)*sz);
      prf_free (prf);
      return 0;
    }

  LOG_DBG ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %lu",
	    (unsigned long)ie->g_x_len));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID fed with g^xy",
		ie->g_xy, ie->g_x_len));

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, ie->g_xy, ie->g_x_len);
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);
d445 24
a468 1
  return skeyid;
d470 1
a470 1
#endif /* USE_X509 || USE_KEYNOTE */
d478 1
a478 1
enc_gen_skeyid (struct exchange *exchange, size_t *sz)
d480 25
a504 28
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  struct hash *hash = ie->hash;
  u_int8_t *skeyid;

  hash->Init (hash->ctx);
  hash->Update (hash->ctx, exchange->nonce_i, exchange->nonce_i_len);
  hash->Update (hash->ctx, exchange->nonce_r, exchange->nonce_r_len);
  hash->Final (hash->digest, hash->ctx);
  prf = prf_alloc (ie->prf_type, hash->type, hash->digest, *sz);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      log_error ("enc_gen_skeyid: malloc (%d) failed", *sz);
      prf_free (prf);
      return 0;
    }

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);

  return skeyid;
d506 1
a506 1
#endif /* notdef */
d509 1
a509 1
pre_shared_decode_hash (struct message *msg)
d511 29
a539 33
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *payload;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t **hash_p;

  /* Choose the right fields to fill-in.  */
  hash_p = initiator ? &ie->hash_r : &ie->hash_i;

  payload = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  if (!payload)
    {
      log_print ("pre_shared_decode_hash: no HASH payload found");
      return -1;
    }

  /* Check that the hash is of the correct size.  */
  if (GET_ISAKMP_GEN_LENGTH (payload->p) - ISAKMP_GEN_SZ != hashsize)
    return -1;

  /* XXX Need this hash be in the SA?  */
  *hash_p = malloc (hashsize);
  if (!*hash_p)
    {
      log_error ("pre_shared_decode_hash: malloc (%lu) failed",
	(unsigned long)hashsize);
      return -1;
    }

  memcpy (*hash_p, payload->p + ISAKMP_HASH_DATA_OFF, hashsize);
  snprintf (header, sizeof header, "pre_shared_decode_hash: HASH_%c",
d541 1
a541 1
  LOG_DBG_BUF ((LOG_MISC, 80, header, *hash_p, hashsize));
d543 2
a544 3
  payload->flags |= PL_MARK;

  return 0;
d550 1
a550 1
rsa_sig_decode_hash (struct message *msg)
d552 12
a563 16
  struct cert_handler *handler;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *p;
  void *cert = 0;
  u_int8_t *rawcert = 0;
  u_int32_t rawcertlen;
  RSA *key = 0;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int len;
  int initiator = exchange->initiator;
  u_int8_t **hash_p, **id_cert, *id;
  u_int32_t *id_cert_len;
  size_t id_len;
  int found = 0, n, i, id_found;
d565 2
a566 2
  u_int8_t *rawkey = 0;
  u_int32_t rawkeylen;
d569 23
a591 27
  /* Choose the right fields to fill-in.  */
  hash_p = initiator ? &ie->hash_r : &ie->hash_i;
  id = initiator ? exchange->id_r : exchange->id_i;
  id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

  if (!id || id_len == 0)
    {
      log_print ("rsa_sig_decode_hash: ID is missing");
      return -1;
    }

  /*
   * XXX Assume we should use the same kind of certification as the remote...
   * moreover, just use the first CERT payload to decide what to use.
   */
  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT]);
  if (!p)
    handler = cert_get (ISAKMP_CERTENC_KEYNOTE);
  else
    handler = cert_get (GET_ISAKMP_CERT_ENCODING (p->p));
  if (!handler)
    {
      log_print ("rsa_sig_decode_hash: cert_get (%d) failed",
		 p ? GET_ISAKMP_CERT_ENCODING (p->p) : -1);
      return -1;
    }

d593 30
a622 37
  /*
   * We need the policy session initialized now, so we can add
   * credentials etc.
   */
  exchange->policy_id = kn_init ();
  if (exchange->policy_id == -1)
    {
      log_print ("rsa_sig_decode_hash: failed to initialize policy session");
      return -1;
    }
#endif /* USE_POLICY || USE_KEYNOTE */

  /* Obtain a certificate from our certificate storage.  */
  if (handler->cert_obtain (id, id_len, 0, &rawcert, &rawcertlen))
    {
      if (handler->id == ISAKMP_CERTENC_X509_SIG)
        {
	  cert = handler->cert_get (rawcert, rawcertlen);
	  if (!cert)
	    LOG_DBG ((LOG_CRYPTO, 50,
		      "rsa_sig_decode_hash: certificate malformed"));
	  else
	    {
	      if (!handler->cert_get_key (cert, &key))
	        {
		  log_print ("rsa_sig_decode_hash: "
			     "decoding certificate failed");
		  handler->cert_free (cert);
		}
	      else
	        {
		  found++;
		  LOG_DBG ((LOG_CRYPTO, 40,
			    "rsa_sig_decode_hash: using cert of type %d",
			    handler->id));
		  exchange->recv_cert = cert;
		  exchange->recv_certtype = handler->id;
d624 31
a654 2
		  x509_generate_kn (exchange->policy_id, cert);
#endif /* USE_POLICY */
d656 41
a696 20
	    }
	}
      else if (handler->id == ISAKMP_CERTENC_KEYNOTE)
	handler->cert_insert (exchange->policy_id, rawcert);
      free (rawcert);
    }

  /*
   * Walk over potential CERT payloads in this message.
   * XXX I believe this is the wrong spot for this.  CERTs can appear
   * anytime.
   */
  for (p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT]); p;
       p = TAILQ_NEXT (p, link))
    {
      p->flags |= PL_MARK;

      /* When we have found a key, just walk over the rest, marking them.  */
      if (found)
	continue;
d698 2
a699 9
      handler = cert_get (GET_ISAKMP_CERT_ENCODING (p->p));
      if (!handler)
	{
	  LOG_DBG ((LOG_MISC, 30,
		    "rsa_sig_decode_hash: no handler for %s CERT encoding",
		    constant_name (isakmp_certenc_cst,
				   GET_ISAKMP_CERT_ENCODING (p->p))));
	  continue;
	}
d701 29
a729 8
      cert = handler->cert_get (p->p + ISAKMP_CERT_DATA_OFF,
				GET_ISAKMP_GEN_LENGTH (p->p)
				- ISAKMP_CERT_DATA_OFF);
      if (!cert)
	{
	  log_print ("rsa_sig_decode_hash: can not get data from CERT");
	  continue;
	}
d731 1
a731 34
      if (!handler->cert_validate (cert))
	{
	  handler->cert_free (cert);
	  log_print ("rsa_sig_decode_hash: received CERT can't be validated");
	  continue;
	}

      if (GET_ISAKMP_CERT_ENCODING (p->p) == ISAKMP_CERTENC_X509_SIG)
        {
	  if (!handler->cert_get_subjects (cert, &n, &id_cert, &id_cert_len))
	    {
	      handler->cert_free (cert);
	      log_print ("rsa_sig_decode_hash: can not get subject from CERT");
	      continue;
	    }

	  id_found = 0;
	  for (i = 0; i < n; i++)
	    if (id_cert_len[i] == id_len
		&& id[0] == id_cert[i][0]
		&& memcmp (id + 4, id_cert[i] + 4, id_len - 4) == 0)
	      {
		id_found++;
		break;
	      }
	  if (!id_found)
	    {
	      handler->cert_free (cert);
	      log_print ("rsa_sig_decode_hash: no CERT subject match the ID");
	      free (id_cert);
	      continue;
	    }

	  cert_free_subjects (n, id_cert, id_cert_len);
d734 13
a746 12
      if (!handler->cert_get_key (cert, &key))
	{
	  handler->cert_free (cert);
	  log_print ("rsa_sig_decode_hash: decoding payload CERT failed");
	  continue;
	}

      /* We validated the cert, cache it for later use.  */
      handler->cert_insert (exchange->policy_id, cert);

      exchange->recv_cert = cert;
      exchange->recv_certtype = GET_ISAKMP_CERT_ENCODING (p->p);
d748 2
a749 32
#if defined (USE_POLICY) || defined (USE_KEYNOTE)
      if (exchange->recv_certtype == ISAKMP_CERTENC_KEYNOTE)
        {
	  struct keynote_deckey dc;
	  char *pp;
	  int dclen;

	  dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
	  dc.dec_key = key;

	  pp = kn_encode_key (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
			      KEYNOTE_PUBLIC_KEY);
	  if (pp == NULL)
	    {
	      kn_free_key (&dc);
	      log_print ("rsa_sig_decode_hash: failed to ASCII-encode key");
	      return -1;
	    }

	  dclen = strlen (pp) + sizeof "rsa-hex:";
	  exchange->keynote_key = calloc (dclen, sizeof (char));
	  if (!exchange->keynote_key)
	    {
	      free (pp);
	      kn_free_key (&dc);
	      log_print ("rsa_sig_decode_hash: failed to allocate %d bytes",
			 dclen);
	      return -1;
	    }

	  snprintf (exchange->keynote_key, dclen, "rsa-hex:%s", pp);
	  free (pp);
d751 1
a751 21
#endif

      found++;
    }

#if defined (USE_DNSSEC)
  /* If no certificate provided a key, try to find a validated DNSSEC KEY.  */
  if (!found)
    {
      rawkey = dns_get_key (IKE_AUTH_RSA_SIG, msg, &rawkeylen);

      /* We need to convert 'void *rawkey' into 'RSA *key'.  */
      if (dns_RSA_dns_to_x509 (rawkey, rawkeylen, &key) == 0)
	found++;
      else
	log_print ("rsa_sig_decode_hash: KEY to RSA key conversion failed");

      if (rawkey)
	free (rawkey);
    }
#endif /* USE_DNSSEC */
d754 4
a757 4
  /* If we still have not found a key, try to read it from a file. */
  if (!found)
    if (get_raw_key_from_file (IKE_AUTH_RSA_SIG, id, id_len, &key) != -1)
      found++;
d760 43
a802 55
  if (!found)
    {
      log_print ("rsa_sig_decode_hash: no public key found");
      return -1;
    }

  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SIG]);
  if (!p)
    {
      log_print ("rsa_sig_decode_hash: missing signature payload");
      RSA_free (key);
      return -1;
    }

  /* Check that the sig is of the correct size.  */
  len = GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SIG_SZ;
  if (len != RSA_size (key))
    {
      RSA_free (key);
      log_print ("rsa_sig_decode_hash: "
		 "SIG payload length does not match public key");
      return -1;
    }

  *hash_p = malloc (len);
  if (!*hash_p)
    {
      RSA_free (key);
      log_error ("rsa_sig_decode_hash: malloc (%d) failed", len);
      return -1;
    }

  len = RSA_public_decrypt (len, p->p + ISAKMP_SIG_DATA_OFF, *hash_p, key,
			    RSA_PKCS1_PADDING);
  if (len == -1)
    {
      RSA_free (key);
      log_print ("rsa_sig_decode_hash: RSA_public_decrypt () failed");
      return -1;
    }

  /* Store key for later use */
  exchange->recv_key = key;
  exchange->recv_keytype = ISAKMP_KEY_RSA;

  if (len != (int)hashsize)
    {
      free (*hash_p);
      *hash_p = 0;
      log_print ("rsa_sig_decode_hash: len %lu != hashsize %lu",
	(unsigned long)len, (unsigned long)hashsize);
      return -1;
    }

  snprintf (header, sizeof header, "rsa_sig_decode_hash: HASH_%c",
d804 1
a804 1
  LOG_DBG_BUF ((LOG_MISC, 80, header, *hash_p, hashsize));
d806 2
a807 3
  p->flags |= PL_MARK;

  return 0;
d809 1
a809 1
#endif /* USE_X509 || USE_KEYNOTE */
d812 1
a812 1
pre_shared_encode_hash (struct message *msg)
d814 10
a823 10
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t *buf;

  buf = ipsec_add_hash_payload (msg, hashsize);
  if (!buf)
    return -1;
d825 2
a826 2
  if (ike_auth_hash (exchange, buf + ISAKMP_HASH_DATA_OFF) == -1)
    return -1;
d828 1
a828 1
  snprintf (header, sizeof header, "pre_shared_encode_hash: HASH_%c",
d830 2
a831 2
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize));
  return 0;
d837 1
a837 1
rsa_sig_encode_hash (struct message *msg)
d839 35
a873 28
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  size_t hashsize = ie->hash->hashsize;
  struct cert_handler *handler;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t *buf, *data, *buf2;
  u_int32_t datalen;
  u_int8_t *id;
  size_t id_len;
  int idtype;
  int32_t sigsize;
  void *sent_key;

  id = initiator ? exchange->id_i : exchange->id_r;
  id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

  /* We may have been provided these by the kernel */
  buf = (u_int8_t *)conf_get_str (exchange->name, "Credentials");
  if (buf
      && (idtype = conf_get_num (exchange->name, "Credential_Type", -1) != -1))
    {
      exchange->sent_certtype = idtype;
      handler = cert_get (idtype);
      if (!handler)
	{
	  log_print ("rsa_sig_encode_hash: cert_get (%d) failed", idtype);
	  return -1;
d875 2
d878 9
a886 5
      exchange->sent_cert = handler->cert_from_printable ((char *)buf);
      if (!exchange->sent_cert)
	{
	  log_print ("rsa_sig_encode_hash: failed to retrieve certificate");
	  return -1;
d888 19
a906 6

      handler->cert_serialize (exchange->sent_cert, &data, &datalen);
      if (!data)
	{
	  log_print ("rsa_sig_encode_hash: cert serialization failed");
	  return -1;
d908 75
d984 9
a992 16
      goto aftercert; /* Skip all the certificate discovery */
    }

  /* XXX This needs to be configurable.  */
  idtype = ISAKMP_CERTENC_KEYNOTE;

  /* Find a certificate with subjectAltName = id.  */
  handler = cert_get (idtype);
  if (!handler)
    {
      idtype = ISAKMP_CERTENC_X509_SIG;
      handler = cert_get (idtype);
      if (!handler)
	{
	  log_print ("rsa_sig_encode_hash: cert_get(%d) failed", idtype);
	  return -1;
a993 1
    }
d995 15
a1009 112
  if (handler->cert_obtain (id, id_len, 0, &data, &datalen) == 0)
    {
      if (idtype == ISAKMP_CERTENC_KEYNOTE)
	{
	  idtype = ISAKMP_CERTENC_X509_SIG;
	  handler = cert_get (idtype);
	  if (!handler)
	    {
	      log_print ("rsa_sig_encode_hash: cert_get(%d) failed", idtype);
	      return -1;
	    }

	  if (handler->cert_obtain (id, id_len, 0, &data, &datalen) == 0)
	    {
	      LOG_DBG ((LOG_MISC, 10,
			"rsa_sig_encode_hash: no certificate to send"));
	      goto skipcert;
	    }
	}
      else
	{
	  LOG_DBG ((LOG_MISC, 10,
		    "rsa_sig_encode_hash: no certificate to send"));
	  goto skipcert;
	}
    }

  /* Let's store the certificate we are going to use */
  exchange->sent_certtype = idtype;
  exchange->sent_cert = handler->cert_get (data, datalen);
  if (!exchange->sent_cert)
    {
      free (data);
      log_print ("rsa_sig_encode_hash: failed to get certificate from wire "
		 "encoding");
      return -1;
    }

 aftercert:

  buf = realloc (data, ISAKMP_CERT_SZ + datalen);
  if (!buf)
    {
      log_error ("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		 ISAKMP_CERT_SZ + datalen);
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_CERT_SZ, buf, datalen);
  SET_ISAKMP_CERT_ENCODING (buf, idtype);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_CERT, buf,
			   ISAKMP_CERT_SZ + datalen, 1))
    {
      free (buf);
      return -1;
    }

 skipcert:

  /* Again, we may have these from the kernel */
  buf = (u_int8_t *)conf_get_str (exchange->name, "PKAuthentication");
  if (buf)
    {
      key_from_printable (ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, (char *)buf,
			  &data, &datalen);
      if (!data)
	{
	  log_print ("rsa_sig_encode_hash: badly formatted RSA private key");
	  return 0;
	}

      sent_key = key_internalize (ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, data,
				  datalen);
      if (!sent_key)
	{
	  log_print ("rsa_sig_encode_hash: bad RSA private key from dynamic "
		     "SA acquisition subsystem");
	  return 0;
	}
    }
  else /* Try through the regular means.  */
    {
      switch (id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ])
	{
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa ((char **)&buf2,
		     id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ] == IPSEC_ID_IPV4_ADDR
		     ? AF_INET : AF_INET6,
		     id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  if (!buf2)
	    return 0;
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  buf2 = calloc (id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
			 sizeof (char));
	  if (!buf2)
	    {
	      log_print ("rsa_sig_encode_hash: malloc (%lu) failed",
			 (unsigned long)id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
	      return 0;
	    }
	  memcpy (buf2, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	  break;

	  /* XXX Support more ID types?  */
	default:
	  buf2 = 0;
	  return 0;
d1011 3
d1015 26
a1040 9
      sent_key = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name,
				   (char *)buf2, 0);
      free (buf2);

      /* Did we find a key?  */
      if (!sent_key)
	{
	  log_print ("rsa_sig_encode_hash: could not get private key");
	  return -1;
d1042 1
a1042 1
    }
d1044 1
a1044 23
  /* Enable RSA blinding.  */
  if (RSA_blinding_on (sent_key, NULL) != 1)
    {
      log_error ("rsa_sig_encode_hash: RSA_blinding_on () failed.");
      return -1;
    }

  /* XXX hashsize is not necessarily prf->blocksize.  */
  buf = malloc (hashsize);
  if (!buf)
    {
      log_error ("rsa_sig_encode_hash: malloc (%lu) failed",
	(unsigned long)hashsize);
      return -1;
    }

  if (ike_auth_hash (exchange, buf) == -1)
    {
      free (buf);
      return -1;
    }

  snprintf (header, sizeof header, "rsa_sig_encode_hash: HASH_%c",
d1046 7
a1052 45
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf, hashsize));

  data = malloc (RSA_size (sent_key));
  if (!data)
    {
      log_error ("rsa_sig_encode_hash: malloc (%d) failed",
		 RSA_size (sent_key));
      return -1;
    }

  sigsize = RSA_private_encrypt (hashsize, buf, data, sent_key,
				 RSA_PKCS1_PADDING);
  if (sigsize == -1)
    {
      log_print ("rsa_sig_encode_hash: RSA_private_encrypt () failed");
      if (data)
	free (data);
      free (buf);
      RSA_free (sent_key);
      return -1;
    }
  datalen = (u_int32_t)sigsize;

  free (buf);

  buf = realloc (data, ISAKMP_SIG_SZ + datalen);
  if (!buf)
    {
      log_error ("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		 ISAKMP_SIG_SZ + datalen);
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_SIG_SZ, buf, datalen);

  snprintf (header, sizeof header, "rsa_sig_encode_hash: SIG_%c",
	    initiator ? 'I' : 'R');
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF, datalen));
  if (message_add_payload (msg, ISAKMP_PAYLOAD_SIG, buf,
			   ISAKMP_SIG_SZ + datalen, 1))
    {
      free (buf);
      return -1;
    }
  return 0;
d1054 1
a1054 1
#endif /* USE_X509 || USE_KEYNOTE */
d1057 1
a1057 1
ike_auth_hash (struct exchange *exchange, u_int8_t *buf)
d1059 30
a1088 33
  struct ipsec_exch *ie = exchange->data;
  struct prf *prf;
  struct hash *hash = ie->hash;
  int initiator = exchange->initiator;
  u_int8_t *id;
  size_t id_len;

  /* Choose the right fields to fill-in.  */
  id = initiator ? exchange->id_i : exchange->id_r;
  id_len = initiator ? exchange->id_i_len : exchange->id_r_len;

  /* Allocate the prf and start calculating our HASH.  */
  prf = prf_alloc (ie->prf_type, hash->type, ie->skeyid, ie->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, initiator ? ie->g_xi : ie->g_xr, ie->g_x_len);
  prf->Update (prf->prfctx, initiator ? ie->g_xr : ie->g_xi, ie->g_x_len);
  prf->Update (prf->prfctx,
	       exchange->cookies
	       + (initiator ? ISAKMP_HDR_ICOOKIE_OFF : ISAKMP_HDR_RCOOKIE_OFF),
	       ISAKMP_HDR_ICOOKIE_LEN);
  prf->Update (prf->prfctx,
	       exchange->cookies
	       + (initiator ? ISAKMP_HDR_RCOOKIE_OFF : ISAKMP_HDR_ICOOKIE_OFF),
	       ISAKMP_HDR_ICOOKIE_LEN);
  prf->Update (prf->prfctx, ie->sa_i_b, ie->sa_i_b_len);
  prf->Update (prf->prfctx, id, id_len);
  prf->Final (buf, prf->prfctx);
  prf_free (prf);

  return 0;
d1093 1
a1093 1
get_raw_key_from_file (int type, u_int8_t *id, size_t id_len, RSA **rsa)
d1095 3
a1097 3
  char filename[FILENAME_MAX];
  char *fstr;
  struct stat st;
d1099 1
a1099 1
  FILE *keyfp;
d1101 1
a1101 1
  BIO *bio;
d1104 26
a1129 30
  if (type != IKE_AUTH_RSA_SIG) /* XXX More types? */
    {
      LOG_DBG ((LOG_NEGOTIATION, 20, "get_raw_key_from_file: "
		"invalid auth type %d\n", type));
      return -1;
    }

  *rsa = 0;

  fstr = conf_get_str ("General", "Pubkey-directory");
  if (!fstr)
    fstr = CONF_DFLT_PUBKEY_DIR;

  if (snprintf (filename, sizeof filename, "%s/", fstr)
      > (int)sizeof filename - 1)
    return -1;

  fstr = ipsec_id_string (id, id_len);
  if (!fstr)
    {
      LOG_DBG ((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		"ipsec_id_string failed"));
      return -1;
    }
  strlcat (filename, fstr, sizeof filename - strlen (filename));
  free (fstr);

  /* If the file does not exist, fail silently.  */
  if (monitor_stat (filename, &st) == 0)
    {
d1131 8
a1138 9
      keyfp = monitor_fopen (filename, "r");
      if (!keyfp)
	{
	  log_error ("get_raw_key_from_file: monitor_fopen (\"%s\", \"r\") "
	             "failed", filename);
	  return -1;
	}
      *rsa = PEM_read_RSA_PUBKEY (keyfp, NULL, NULL, NULL);
      fclose (keyfp);
d1140 19
a1158 22
      bio = BIO_new (BIO_s_file ());
      if (!bio)
	{
	  log_error ("get_raw_key_from_file: could not initialize BIO");
	  return -1;
	}
      if (BIO_read_filename (bio, filename) <= 0)
	{
	  LOG_DBG ((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		    "BIO_read_filename(bio, \"%s\") failed", filename));
	  BIO_free (bio);
	  return -1;
	}
      LOG_DBG ((LOG_NEGOTIATION, 80, "get_raw_key_from_file: reading file %s",
		filename));
      *rsa = PEM_read_bio_RSA_PUBKEY (bio, NULL, NULL, NULL);
      BIO_free (bio);
#endif	/* USE_PRIVSEP */
    }
  else
    LOG_DBG ((LOG_NEGOTIATION, 50, "get_raw_key_from_file: file %s not found",
	      filename));
d1160 1
a1160 1
  return (*rsa ? 0 : -1);
d1162 1
a1162 1
#endif /* USE_RAWKEY */
@


1.84
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.83 2004/03/19 14:04:43 hshoexer Exp $	*/
d887 1
a887 1
  if (len != hashsize)
d945 1
d1062 1
a1062 1
      if (!data || datalen == -1)
d1157 1
a1157 1
  datalen = RSA_private_encrypt (hashsize, buf, data, sent_key,
d1159 1
a1159 1
  if (datalen == -1)
d1168 1
d1259 2
a1260 1
  if (snprintf (filename, sizeof filename, "%s/", fstr) > sizeof filename - 1)
@


1.83
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.82 2004/03/17 11:10:06 ho Exp $	*/
d127 1
a127 1
  int i;
d254 1
a254 1
	  if (read (fd, buf, size) != size)
@


1.82
log
@For consistency and to avoid a rare memory leak, the result from
ike_auth_get_key() should always be released after use.
Found and ok hshoexer@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.81 2003/11/06 16:12:07 ho Exp $	*/
d146 3
d150 1
d230 1
a230 1
	  if (stat (keyfile, &sb) < 0)
d237 1
a237 1
	  fd = open (keyfile, O_RDONLY, 0);
d303 14
d339 2
a1074 7
#if defined (USE_PRIVSEP)
      {
	/* With USE_PRIVSEP, the sent_key should be a key number. */
	void *key = sent_key;
	sent_key = monitor_RSA_upload_key (key);
      }
#endif
a1109 3
#if defined (USE_PRIVSEP)
      sent_key = monitor_RSA_get_private_key (exchange->name, (char *)buf2);
#else
a1111 1
#endif
a1121 1
#if !defined (USE_PRIVSEP)
a1127 1
#endif
a1147 1
#if !defined (USE_PRIVSEP)
a1157 4
#else
  datalen = monitor_RSA_private_encrypt (hashsize, buf, &data, sent_key,
					 RSA_PKCS1_PADDING);
#endif /* USE_PRIVSEP */
d1164 1
a1164 1
      monitor_RSA_free (sent_key);
d1238 3
d1242 1
d1271 1
a1271 1
  if (stat (filename, &st) == 0)
d1273 11
d1301 1
@


1.81
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.80 2003/10/14 14:29:15 ho Exp $	*/
d175 1
a175 1
	      log_print ("ike_auth_get_key: malloc (%lu) failed",
d188 10
a197 1
	*keylen = strlen (key);
d410 1
d415 1
d417 1
a417 1
  prf = prf_alloc (ie->prf_type, ie->hash->type, key, keylen);
@


1.80
log
@constant_lookup() to constant_name() cleanup. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.79 2003/08/08 08:46:59 ho Exp $	*/
d446 5
a450 4
  LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: PRF type %d, hash %d",
      ie->prf_type, ie->hash->type));
  LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with",
      (u_int8_t *)key, exchange->nonce_i_len + exchange->nonce_r_len));
d468 4
a471 4
  LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %lu",
      (unsigned long)ie->g_x_len));
  LOG_DBG_BUF((LOG_NEGOTIATION, 80,
      "sig_gen_skeyid: SKEYID fed with g^xy", ie->g_xy, ie->g_x_len));
d1264 2
a1265 2
	  LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: "
		   "BIO_read_filename(bio, \"%s\") failed", filename));
d1269 2
a1270 2
      LOG_DBG((LOG_NEGOTIATION, 80, "get_raw_key_from_file: reading file %s",
	       filename));
d1275 2
a1276 2
    LOG_DBG((LOG_NEGOTIATION, 50, "get_raw_key_from_file: file %s not found",
	     filename));
@


1.79
log
@Be more careful when using constant_lookup() in messages. Pointed out by
Jean-Francois Dive, although I opted for a slightly different patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.78 2003/06/10 16:41:29 deraadt Exp $	*/
a584 1
  char *tag;
a682 2
	  tag = constant_lookup (isakmp_certenc_cst,
				 GET_ISAKMP_CERT_ENCODING (p->p));
d685 2
a686 1
		    tag ? tag : "<unknown>"));
@


1.78
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.77 2003/06/04 07:31:16 ho Exp $	*/
d585 1
d684 2
d688 1
a688 2
		    constant_lookup (isakmp_certenc_cst,
				     GET_ISAKMP_CERT_ENCODING (p->p))));
@


1.77
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.76 2003/06/03 14:28:16 ho Exp $	*/
d717 1
a717 1
 	    if (id_cert_len[i] == id_len
@


1.76
log
@Remove clauses 3 and 4. With approval from Niklas Hallqvist and
Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.75 2003/06/03 12:51:39 ho Exp $	*/
a17 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.75
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.74 2003/05/18 19:37:46 ho Exp $	*/
d8 1
a8 1
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
@


1.74
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.73 2003/05/15 03:20:28 ho Exp $	*/
d560 1
a560 1
  snprintf (header, 80, "pre_shared_decode_hash: HASH_%c",
d869 2
a870 1
  snprintf (header, 80, "rsa_sig_decode_hash: HASH_%c", initiator ? 'R' : 'I');
d896 1
a896 1
  snprintf (header, 80, "pre_shared_encode_hash: HASH_%c",
d1130 2
a1131 1
  snprintf (header, 80, "rsa_sig_encode_hash: HASH_%c", initiator ? 'I' : 'R');
d1171 2
a1172 1
  snprintf (header, 80, "rsa_sig_encode_hash: SIG_%c", initiator ? 'I' : 'R');
@


1.73
log
@Correct a two year old typo, which might actually make
setsockopt(..., IP_IPSEC_LOCAL_AUTH, ...) start working.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.72 2003/05/15 02:28:56 ho Exp $	*/
a153 4
#if defined (USE_PRIVSEP)
  int fd;
  char *fdata;
#endif
a294 45
#if defined (USE_PRIVSEP)
      /* XXX Try to find a better solution.  */
      keyh = BIO_new (BIO_s_mem ());
      if (keyh == NULL)
	{
	  log_print ("ike_auth_get_key: "
		     "BIO_new (BIO_s_mem ()) failed");
	  return 0;
	}
      fd = monitor_open (keyfile, O_RDONLY, 0);
      if (fd < 0)
	{
	  log_print ("ike_auth_get_key: open(\"%s\") failed", keyfile);
	  BIO_free (keyh);
	  return 0;
	}
      fdata = (char *)malloc (fsize);
      if (!fdata)
	{
	  log_error ("ike_auth_get_get: malloc (%d) failed", fsize);
	  monitor_close (fd);
	  BIO_free (keyh);
	  return 0;
	}
      if (read (fd, fdata, fsize) != fsize)
	{
	  log_error ("ike_auth_get_key: short read");
	  monitor_close (fd);
	  BIO_free (keyh);
	  memset (fdata, 0, fsize);
	  free (fdata);
	  return 0;
	}
      monitor_close (fd);
      if (BIO_write (keyh, fdata, fsize) == -1)
	{
	  log_print ("ike_auth_get_key: BIO_read () failed");
	  BIO_free (keyh);
	  memset (fdata, 0, fsize);
	  free (fdata);
	  return 0;
	}
      memset (fdata, 0, fsize);
      free (fdata);
#else
a309 1
#endif /* USE_PRIVSEP */
a916 1
  int sent_keytype;
a1026 32
  switch (id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ])
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      util_ntoa ((char **)&buf2,
		 id[ISAKMP_ID_TYPE_OFF - ISAKMP_GEN_SZ] == IPSEC_ID_IPV4_ADDR
		 ? AF_INET : AF_INET6,
		 id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
      if (!buf2)
	return 0;
      break;

    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      buf2 = calloc (id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1,
		     sizeof (char));
      if (!buf2)
        {
	  log_print ("rsa_sig_encode_hash: malloc (%lu) failed",
		     (unsigned long)id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
	  return 0;
	}
      memcpy (buf2, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
	      id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
      break;

      /* XXX Support more ID types?  */
    default:
      buf2 = 0;
      break;
    }

a1038 1
      sent_keytype = ISAKMP_KEY_RSA;
d1047 7
d1057 35
d1094 1
a1102 2

      sent_keytype = ISAKMP_KEY_RSA;
d1105 1
d1112 1
d1132 1
d1143 4
d1150 2
d1153 1
@


1.72
log
@Cleanup. Do not store the private key in either the exchange or sa structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.71 2003/05/15 02:08:54 ho Exp $	*/
d1111 1
a1111 1
  buf = (u_int8_t *)conf_get_str (exchange->name, "OKAuthentication");
@


1.71
log
@Work around some OpenSSL BIO "features" to read the key correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.70 2003/05/15 00:28:53 ho Exp $	*/
d967 2
d1122 4
a1125 5
      exchange->sent_keytype = ISAKMP_KEY_RSA;
      exchange->sent_key = key_internalize (ISAKMP_KEY_RSA,
					    ISAKMP_KEYTYPE_PRIVATE, data,
					    datalen);
      if (!exchange->sent_key)
d1134 2
a1135 2
      exchange->sent_key = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name,
					     (char *)buf2, 0);
d1139 1
a1139 1
      if (!exchange->sent_key)
d1145 1
a1145 1
      exchange->sent_keytype = ISAKMP_KEY_RSA;
d1149 1
a1149 1
  if (RSA_blinding_on (exchange->sent_key, NULL) != 1)
d1173 1
a1173 1
  data = malloc (RSA_size (exchange->sent_key));
d1177 1
a1177 1
		 RSA_size (exchange->sent_key));
d1181 1
a1181 1
  datalen = RSA_private_encrypt (hashsize, buf, data, exchange->sent_key,
@


1.70
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.69 2003/05/14 18:11:19 ho Exp $	*/
d299 3
a301 1
      keyh = BIO_new (BIO_s_file ());
d305 1
a305 1
		     "BIO_new (BIO_s_file ()) failed");
a307 2
#if defined (USE_PRIVSEP)
      /* XXX Try to find a BIO_read_fd() function instead of this.  */
d333 1
a333 1
      if (BIO_read (keyh, fdata, fsize) == -1)
d344 7
d374 2
a375 2
#endif
#endif
@


1.69
log
@Default public key directory definition sanity.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.68 2003/03/13 13:24:48 ho Exp $	*/
d71 1
d153 5
d296 1
a296 1
      if (check_file_secrecy (keyfile, 0))
d306 38
d352 1
@


1.68
log
@Might as well do blinding here too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.67 2003/01/22 15:13:11 ho Exp $	*/
a93 1
#define PUBKEY_DIR_DEFAULT "/etc/isakmpd/pubkeys"
d1219 1
a1219 1
    fstr = PUBKEY_DIR_DEFAULT;
@


1.67
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.66 2002/09/11 09:50:43 ho Exp $	*/
d1094 7
@


1.66
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.65 2002/06/10 18:08:58 ho Exp $	*/
d167 1
a167 1
		     "no key found for peer \"%s\"or local ID \"%s\"",
@


1.65
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.64 2002/06/09 08:13:06 todd Exp $	*/
d183 1
a183 1
	  if (hex2raw (key + 2, buf, *keylen))
a339 1
  u_int8_t *key;
d341 1
d389 2
a390 1
  key = ike_auth_get_key (IKE_AUTH_PRE_SHARED, exchange->name, buf, &keylen);
d440 2
a441 1
  u_int8_t *skeyid, *key;
d453 1
a453 1
      key, exchange->nonce_i_len + exchange->nonce_r_len));
d921 1
a921 1
  buf = conf_get_str (exchange->name, "Credentials");
d933 1
a933 1
      exchange->sent_cert = handler->cert_from_printable (buf);
d1058 1
a1058 1
  buf = conf_get_str (exchange->name, "OKAuthentication");
d1061 2
a1062 2
      key_from_printable (ISAKMP_KEY_RSA, ISAKMP_KEYTYPE_PRIVATE, buf, &data,
			  &datalen);
d1083 1
a1083 1
					     buf2, 0);
@


1.64
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.63 2002/06/01 07:44:21 deraadt Exp $	*/
a196 4
#ifdef HAVE_DLOPEN
      if (!libcrypto)
	return 0;
#endif
d261 1
a261 1
	  if (LK (kn_decode_key, (&dc, buf2, KEYNOTE_PRIVATE_KEY)) == -1)
d277 1
a277 1
	      LK (kn_free_key, (&dc));
d294 1
a294 1
      keyh = LC (BIO_new, (LC (BIO_s_file, ())));
d301 1
a301 1
      if (LC (BIO_read_filename, (keyh, keyfile)) == -1)
d306 1
a306 1
	  LC (BIO_free, (keyh));
d311 1
a311 1
      rsakey = LC (PEM_read_bio_RSAPrivateKey, (keyh, NULL, NULL, NULL));
d313 1
a313 1
      rsakey = LC (PEM_read_bio_RSAPrivateKey, (keyh, NULL, NULL));
d315 1
a315 1
      LC (BIO_free, (keyh));
d624 1
a624 1
  exchange->policy_id = LK (kn_init, ());
d760 2
a761 2
	  pp = LK (kn_encode_key, (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
				   KEYNOTE_PUBLIC_KEY));
d764 1
a764 1
	      LK (kn_free_key, (&dc));
d774 1
a774 1
	      LK (kn_free_key, (&dc));
d822 1
a822 1
      LC (RSA_free, (key));
d828 1
a828 1
  if (len != LC (RSA_size, (key)))
d830 1
a830 1
      LC (RSA_free, (key));
d839 1
a839 1
      LC (RSA_free, (key));
d844 2
a845 2
  len = LC (RSA_public_decrypt, (len, p->p + ISAKMP_SIG_DATA_OFF, *hash_p, key,
				 RSA_PKCS1_PADDING));
d848 1
a848 1
      LC (RSA_free, (key));
d1112 1
a1112 1
  data = malloc (LC (RSA_size, (exchange->sent_key)));
d1116 1
a1116 1
		 LC (RSA_size, (exchange->sent_key)));
d1120 2
a1121 2
  datalen = LC (RSA_private_encrypt, (hashsize, buf, data,
				      exchange->sent_key, RSA_PKCS1_PADDING));
d1229 1
a1229 1
      bio = LC (BIO_new, (LC (BIO_s_file, ())));
d1235 1
a1235 1
      if (LC (BIO_read_filename, (bio, filename)) <= 0)
d1239 1
a1239 1
	  LC (BIO_free, (bio));
d1244 2
a1245 2
      *rsa = LC (PEM_read_bio_RSA_PUBKEY, (bio, NULL, NULL, NULL));
      LC (BIO_free, (bio));
@


1.63
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.62 2002/05/28 11:23:20 ho Exp $	*/
d1254 1
a1254 1
  
@


1.62
log
@off_t to size_t change for printf format and malloc. Pointed out by <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.61 2002/01/23 17:14:28 ho Exp $	*/
d179 2
a180 1
	      log_print ("ike_auth_get_key: malloc (%d) failed", *keylen);
d243 2
a244 2
	      log_print ("ike_auth_get_key: failed allocating %d bytes",
			 size + 1);
d253 2
a254 1
			 "failed reading %d bytes from \"%s\"", size, keyfile);
d374 2
a375 2
              log_print ("pre_shared_gen_skeyid: malloc (%d) failed",
			 exchange->id_i_len - ISAKMP_ID_DATA_OFF
d406 2
a407 1
      log_error ("pre_shared_gen_skeyid: malloc (%d) failed", keylen);
d421 2
a422 1
      log_error ("pre_shared_gen_skeyid: malloc (%d) failed", *sz);
d467 2
a468 1
      log_error ("sig_gen_skeyid: malloc (%d) failed", *sz);
d473 2
a474 2
  LOG_DBG((LOG_NEGOTIATION, 80, "sig_gen_skeyid: g^xy length %d",
      ie->g_x_len));
d555 2
a556 1
      log_error ("pre_shared_decode_hash: malloc (%d) failed", hashsize);
d865 2
a866 1
      log_print ("rsa_sig_decode_hash: len %d != hashsize %d", len, hashsize);
d1045 2
a1046 2
	  log_print ("rsa_sig_encode_hash: malloc (%d) failed",
		     id_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
d1102 2
a1103 1
      log_error ("rsa_sig_encode_hash: malloc (%d) failed", hashsize);
@


1.61
log
@strncat->strlcat, sprintf->snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.60 2001/08/23 19:32:46 niklas Exp $	*/
d208 1
d229 1
d239 1
a239 1
	  buf = calloc (sb.st_size + 1, sizeof (char));
d243 1
a243 1
			 sb.st_size + 1);
d248 1
a248 1
	  if (read (fd, buf, sb.st_size) != sb.st_size)
d252 1
a252 2
			 "failed reading %d bytes from \"%s\"",
			 sb.st_size, keyfile);
@


1.60
log
@Correct ipsec_id_string buffer and length handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.59 2001/08/22 17:30:46 ho Exp $	*/
d207 1
a207 1
	  int fd;
d209 3
a211 3
	  privkeyfile = calloc (strlen (keyfile) + strlen (local_id)
				+ sizeof PRIVATE_KEY_FILE + sizeof "//" - 1,
				sizeof (char));
d215 1
a215 2
			 strlen (keyfile) + strlen (local_id)
			 + sizeof PRIVATE_KEY_FILE + sizeof "//" - 1);
d219 1
a219 1
	  sprintf (privkeyfile, "%s/%s/%s", keyfile, local_id,
d752 1
d766 2
a767 2
	  exchange->keynote_key = calloc (strlen (pp) + sizeof "rsa-hex:",
					  sizeof (char));
d773 1
a773 1
			 strlen (pp) + sizeof "rsa-hex:");
d777 1
a777 1
	  sprintf (exchange->keynote_key, "rsa-hex:%s", pp);
d1218 1
a1218 1
  strncat (filename, fstr, sizeof filename - 1 - strlen (filename));
@


1.59
log
@use ipsec_id_string() when generating rawkey file names.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.58 2001/08/22 17:24:45 ho Exp $	*/
a1209 3

   /* XXX This can't be the right place for this... */
  id_len += ISAKMP_GEN_SZ;
@


1.58
log
@If we fail to get a key from DNSSEC, RAWKEY can still succeed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.57 2001/08/16 16:51:57 ho Exp $	*/
d1191 1
a1191 1
  char *rdir, *base, *addrstr = 0;
d1204 3
a1206 10
  rdir = conf_get_str ("General", "Pubkey-directory");
  if (!rdir)
    rdir = PUBKEY_DIR_DEFAULT;

  strncpy (filename, rdir, FILENAME_MAX - 1);
  filename[FILENAME_MAX - 1] = '\0';

  /* Exchanges (and SAs) don't carry the ID in ISAKMP form */
  id -= ISAKMP_ID_TYPE_OFF;
  id_len += ISAKMP_ID_TYPE_OFF;
d1208 2
a1209 11
  switch (GET_ISAKMP_ID_TYPE (id))
    {
    case IPSEC_ID_IPV4_ADDR:
      if (id_len < sizeof (struct in_addr))
	return -1;
      util_ntoa (&addrstr, AF_INET, id + ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	return -1;
      strncat (filename, "/ipv4/", FILENAME_MAX - 1 - strlen (filename));
      strncat (filename, addrstr, FILENAME_MAX - 1 - strlen (filename));
      break;
d1211 2
a1212 9
    case IPSEC_ID_IPV6_ADDR:
      if (id_len < sizeof (struct in6_addr))
	return -1;
      util_ntoa (&addrstr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	return -1;
      strncat (filename, "/ipv6/", FILENAME_MAX - 1 - strlen (filename));
      strncat (filename, addrstr, FILENAME_MAX - 1 - strlen (filename));
      break;
d1214 5
a1218 22
    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      if (GET_ISAKMP_ID_TYPE (id) == IPSEC_ID_FQDN)
	addrstr = "/fqdn/";
      else
	addrstr = "/ufqdn/";

      strncat (filename, addrstr, FILENAME_MAX - 1 - strlen (filename));

      /* Id is not NULL-terminated.  */
      id_len -= ISAKMP_ID_DATA_OFF;
      id_len = MIN (id_len, FILENAME_MAX - 1 - strlen (filename));
      base = filename + strlen (filename);
      memcpy (base, id + ISAKMP_ID_DATA_OFF, id_len);
      *(base + id_len) = '\0';
      addrstr = 0;
      break;

    default:
      /* Unknown type.  */
      LOG_DBG ((LOG_NEGOTIATION, 10, "get_raw_key_from_file: "
		"unknown identity type %d\n", GET_ISAKMP_ID_TYPE (id)));
a1219 1
      break;
d1221 2
d1231 1
a1231 1
	  goto out;
d1238 1
a1238 1
	  goto out;
a1248 4
 out:
  if (addrstr)
    free (addrstr);

@


1.57
log
@openssl black magic.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.56 2001/08/16 13:49:50 ho Exp $	*/
d790 3
a792 1
      if (rawkey)
d794 2
d797 2
a798 8
      /* We need to convert 'void *rawkey' into 'RSA *key'.  */
      if (dns_RSA_dns_to_x509 (rawkey, rawkeylen, &key) == -1)
	{
	  log_print ("rsa_sig_decode_hash: KEY to RSA key conversion failed");
	  free (rawkey);
	  return -1;
	}
      free (rawkey);
@


1.56
log
@Off-by-one error in [u]fqdn cases, plus better debug messages when
looking for public key files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.55 2001/08/16 13:27:03 ho Exp $	*/
d1195 1
a1195 1
  FILE *fp;
d1268 2
a1269 2
      fp = fopen (filename, "r");
      if (!fp)
d1271 8
a1278 1
	  log_error ("get_raw_key_from_file: could not open \"%s\"", filename);
d1283 2
a1284 2
      *rsa = LC (PEM_read_RSAPublicKey, (fp, NULL, NULL, NULL));
      fclose (fp);
@


1.55
log
@ISAKMP ID type offset was wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.54 2001/08/15 13:06:53 ho Exp $	*/
a1211 1
  base = filename + strlen (filename) - 1;
d1251 3
a1253 2
      memcpy (base + strlen (addrstr), id + ISAKMP_ID_DATA_OFF, id_len);
      *(base + strlen (addrstr) + id_len) = '\0';
d1274 2
d1279 3
@


1.54
log
@Some more style...
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.53 2001/08/15 09:16:29 ho Exp $	*/
d1213 4
@


1.53
log
@Support trusted public (RSA) keys as files too. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.52 2001/07/01 19:48:43 niklas Exp $	*/
d49 1
a49 1
#if defined(USE_KEYNOTE)
d59 1
a59 1
#if defined(USE_DNSSEC)
d87 1
a87 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
d111 1
a111 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
d148 1
a148 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
d150 1
a150 1
#if defined(USE_X509)
d195 1
a195 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
d200 1
a200 1
#if defined(USE_KEYNOTE)
d432 1
a432 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
d564 1
a564 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
d585 1
a585 1
#if defined(USE_DNSSEC)
d617 1
a617 1
#if defined(USE_POLICY) || defined(USE_KEYNOTE)
d655 1
a655 1
#if defined(USE_POLICY)
d748 1
a748 1
#if defined(USE_POLICY) || defined(USE_KEYNOTE)
d785 1
a785 1
#if defined(USE_DNSSEC)
d896 1
a896 1
#if defined(USE_X509) || defined(USE_KEYNOTE)
@


1.52
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.51 2001/06/29 19:55:36 angelos Exp $	*/
d93 5
d804 7
d1187 94
@


1.51
log
@Remove extra ':' from LOG_DBG_BUF()
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.50 2001/06/29 04:11:59 ho Exp $	*/
d196 2
a197 3
      if ((local_id) &&
	  ((keyfile = conf_get_str ("KeyNote",
				    "Credential-directory")) != NULL))
d204 4
a207 3
	  privkeyfile = calloc (strlen (keyfile) + strlen (local_id) +
				strlen (PRIVATE_KEY_FILE) + 3, sizeof (char));
	  if (privkeyfile == NULL)
d210 2
a211 2
			 strlen (keyfile) + strlen (local_id) +
			 strlen (PRIVATE_KEY_FILE) + 3);
d234 1
a234 1
	  if (buf == NULL)
d288 1
a288 1
      if (check_file_secrecy (keyfile, NULL))
d291 2
a292 1
      if ((keyh = LC (BIO_new, (LC (BIO_s_file, ())))) == NULL)
d352 5
a356 2
	  util_ntoa ((char **)&buf, AF_INET, exchange->id_i +
		     ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
a359 5
	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa ((char **)&buf, AF_INET6, exchange->id_i +
		     ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);
	  if (!buf)
	    return 0;
d363 2
a364 2
	  buf = calloc (exchange->id_i_len - ISAKMP_ID_DATA_OFF +
			ISAKMP_GEN_SZ + 1, sizeof (char));
d569 1
a569 1
  u_int8_t *rawcert = NULL;
d581 1
a581 1
  u_int8_t *rawkey = NULL;
d607 2
a608 3
      log_print ("rsa_sig_decode_hash: "
		 "cert_get (%d) failed", p != NULL
		 ? GET_ISAKMP_CERT_ENCODING (p->p) : -1);
d761 1
a761 2
	  exchange->keynote_key = calloc (strlen (pp) +
					  strlen ("rsa-hex:") + 1,
d763 1
a763 1
	  if (exchange->keynote_key == NULL)
d768 1
a768 1
			 strlen (pp) + strlen ("rsa-hex:") + 1);
d905 3
a907 2
  if ((buf = conf_get_str (exchange->name, "Credentials")) != NULL &&
      (idtype = conf_get_num (exchange->name, "Credential_Type", -1) != -1))
d918 1
a918 1
      if (exchange->sent_cert == NULL)
d925 1
a925 1
      if (data == NULL)
a1011 5
      util_ntoa ((char **)&buf2, AF_INET, id + ISAKMP_ID_DATA_OFF -
		 ISAKMP_GEN_SZ);
      if (!buf2)
	return 0;
      break;
d1013 4
a1016 2
      util_ntoa ((char **)&buf2, AF_INET6, id + ISAKMP_ID_DATA_OFF -
		 ISAKMP_GEN_SZ);
d1023 2
a1024 2
      buf2 = calloc (id_len - ISAKMP_ID_DATA_OFF +
		    ISAKMP_GEN_SZ + 1, sizeof (char));
d1037 1
a1037 1
      buf2 = NULL;
d1042 2
a1043 1
  if ((buf = conf_get_str (exchange->name, "OKAuthentication")) != NULL)
d1047 1
a1047 1
      if ((data == NULL) || (datalen == -1))
d1057 1
a1057 1
      if (exchange->sent_key == NULL)
d1064 1
a1064 1
  else /* Try through the regular means */
d1067 1
a1067 1
					     buf2, NULL);
d1070 2
a1071 2
      /* Did we find a key ? */
      if (exchange->sent_key == NULL)
@


1.50
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.49 2001/06/28 21:41:58 angelos Exp $	*/
d446 1
a446 1
  LOG_DBG_BUF((LOG_NEGOTIATION, 80, "sig_gen_skeyid: SKEYID initialized with:",
d467 1
a467 1
      "sig_gen_skeyid: SKEYID fed with g^xy:", ie->g_xy, ie->g_x_len));
@


1.49
log
@Add some more debugging information wrt PRF generation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.48 2001/06/11 10:50:09 itojun Exp $	*/
a338 1
  in_addr_t addr;
d351 2
a352 1
	  buf = malloc (16);
d354 1
a354 7
	    {
	      log_error ("pre_shared_gen_skeyid: malloc (16) failed");
	      return 0;
	    }
	  addr = htonl (decode_32 (exchange->id_i + ISAKMP_ID_DATA_OFF -
				   ISAKMP_GEN_SZ));
	  inet_ntop (AF_INET, &addr, buf, 16);
d356 5
a902 1
  in_addr_t addr;
d1014 2
a1015 1
      buf2 = malloc (16);
d1017 7
a1023 6
        {
	  log_error ("rsa_sig_encode_hash: malloc (16) failed");
	  return 0;
	}
      addr = htonl (decode_32 (id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ));
      inet_ntop (AF_INET, &addr, buf2, 16);
@


1.48
log
@make #ifdef around x509_generate_kn() consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.47 2001/06/07 04:48:21 angelos Exp $	*/
d444 6
d464 5
@


1.47
log
@Actually, don't re-insert X509 certs which we acquired from our store
-- just translate them to KeyNote.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.46 2001/06/07 04:19:03 angelos Exp $	*/
d642 1
a642 1
#if defined(USE_X509)
d644 1
a644 1
#endif /* USE_X509 */
@


1.46
log
@Add an X509 cert in the policy session even if it was found in our
local repository.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.45 2001/06/06 22:22:12 angelos Exp $	*/
d75 3
d642 3
a644 1
		  handler->cert_insert (exchange->policy_id, cert);
@


1.45
log
@NUL-terminate passphrase.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.44 2001/06/05 10:04:46 angelos Exp $	*/
d639 1
@


1.44
log
@Don't use log_error() if it's an internal error.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.43 2001/06/05 05:59:42 niklas Exp $	*/
d394 1
a394 1
  exchange->recv_key = malloc (keylen);
@


1.43
log
@Style issues and commentary
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.42 2001/06/05 05:08:26 angelos Exp $	*/
d900 1
a900 1
	  log_error ("rsa_sig_encode_hash: cert_get (%d) failed", idtype);
d907 1
a907 1
	  log_error ("rsa_sig_encode_hash: failed to retrieve certificate");
d914 1
a914 1
	  log_error ("rsa_sig_encode_hash: cert serialization failed");
d970 2
a971 1
      log_error ("rsa_sig_encode_hash: failed to get certificate from wire encoding");
d1036 1
a1036 1
	  log_error ("rsa_sig_encode_hash: badly formatted RSA private key");
d1046 1
a1046 1
	  log_error ("rsa_sig_encode_hash: bad RSA private key from dynamic "
d1096 1
a1096 1
      log_error ("rsa_sig_encode_hash: RSA_private_encrypt () failed");
@


1.42
log
@Add back check for found/not found public key to use for verification
(somehow was dropped during the previous commit).
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.41 2001/05/31 20:29:49 angelos Exp $	*/
d389 2
a390 2
  /* Fail if no key could be found */
  if (key == NULL) 
d614 1
a614 1
  /* Obtain a certificate from our certificate storage */
d670 1
a670 1
  
a766 1
  /* If no certificate provided a key, try to find a validated DNSSEC KEY. */
d768 1
d774 2
a775 2
      
      /* We need to convert 'void *rawkey' into 'RSA *key'. */
d861 1
a861 1
    
d864 1
a864 1
    
d1022 1
a1022 1
      /* XXX Support more ID types ? */
d1079 1
a1079 1
    
@


1.41
log
@When trying to find the right certificate/key to use, first check in
the conf space, as we may have been passed that information from the
kernel.

Likewise, store the peer's key and cert so we can send it back to the
kernel when we establish the SA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.40 2001/05/24 03:15:37 angelos Exp $	*/
d556 1
a556 1
  void *cert;
d559 1
a559 1
  RSA *key;
d785 6
@


1.40
log
@Match the IDs without checking the ASN1 length field, similar to how
we do things in x509.c --- this should solve some problems with
certificate-based authentication not working.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.39 2001/04/09 12:34:37 ho Exp $	*/
d74 1
d308 1
a311 1
	  LC (BIO_free, (keyh));
a314 1
      LC (BIO_free, (keyh));
d381 4
a384 1
  /* Get the pre-shared key for our peer.  */
d394 3
a396 2
  exchange->recv_cert = malloc (keylen);
  if (!exchange->recv_cert)
d401 1
a401 2
  memcpy (exchange->recv_cert, key, keylen);
  exchange->recv_certlen = keylen;
d403 1
a403 1
  
d747 4
a750 3
	  exchange->recv_key = calloc (strlen (pp) + strlen ("rsa-hex:") + 1,
				       sizeof (char));
	  if (exchange->recv_key == NULL)
d759 1
a759 1
	  sprintf (exchange->recv_key, "rsa-hex:%s", pp);
a785 16
  /* If we still have not found a key, try the config file.  */
  if (!found)
    {
#ifdef notyet
      rawkey = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name, &keylen);
      if (!rawkey)
	{
	  log_print ("rsa_sig_decode_hash: no public key found");
	  return -1;
	}
#else
      log_print ("rsa_sig_decode_hash: no public key found");
      return -1;
#endif
    }

d821 4
a824 2
  LC (RSA_free, (key));
  
a873 1
  RSA *key;
d886 30
a915 1
  /* XXX This needs to be configureable.  */
d918 1
a918 1
 doitagain:
d922 7
a928 9
      if (idtype == ISAKMP_CERTENC_KEYNOTE)
        {
          idtype = ISAKMP_CERTENC_X509_SIG;
          goto doitagain;
        }

      log_print ("rsa_sig_encode_hash: "
		 "cert_get(%d) failed", idtype);
      return -1;
d931 1
a931 2
  /* Find a certificate with subjectAltName = id.  */
  if (handler->cert_obtain (id, id_len, 0, &data, &datalen))
d933 1
a933 2
      buf = realloc (data, ISAKMP_CERT_SZ + datalen);
      if (!buf)
d935 14
a948 4
	  log_error ("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		     ISAKMP_CERT_SZ + datalen);
	  free (data);
	  return -1;
d950 1
a950 4
      memmove (buf + ISAKMP_CERT_SZ, buf, datalen);
      SET_ISAKMP_CERT_ENCODING (buf, idtype);
      if (message_add_payload (msg, ISAKMP_PAYLOAD_CERT, buf,
			       ISAKMP_CERT_SZ + datalen, 1))
d952 3
a954 2
	  free (buf);
	  return -1;
d957 25
a981 1
  else
d983 2
a984 8
      if (handler->id == ISAKMP_CERTENC_KEYNOTE)
        {
	  idtype = ISAKMP_CERTENC_X509_SIG;
	  goto doitagain;
	}
      else
	LOG_DBG ((LOG_MISC, 10,
		  "rsa_sig_encode_hash: no certificate to send"));
d987 2
d1022 23
a1044 3
  key = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name, buf2, NULL);
  free (buf2);
  if (key == NULL)
d1046 12
a1057 2
      log_print ("rsa_sig_encode_hash: could not get private key");
      return -1;
a1064 1
      LC (RSA_free, (key));
a1070 1
      LC (RSA_free, (key));
d1077 1
a1077 1
  data = malloc (LC (RSA_size, (key)));
d1081 1
a1081 2
		 LC (RSA_size, (key)));
      LC (RSA_free, (key));
d1085 2
a1086 2
  datalen
    = LC (RSA_private_encrypt, (hashsize, buf, data, key, RSA_PKCS1_PADDING));
a1090 1
      LC (RSA_free, (key));
a1093 1
  LC (RSA_free, (key));
@


1.39
log
@Style police a'la niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.38 2001/03/27 18:47:09 ho Exp $	*/
d696 2
a697 1
		&& memcmp (id, id_cert[i], id_len) == 0)
@


1.39.2.1
log
@Pull in patch from current:
Fix (angelos):
Match the IDs without checking the ASN1 length field, similar to how
we do things in x509.c --- this should solve some problems with
certificate-based authentication not working.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.39 2001/04/09 12:34:37 ho Exp $	*/
d696 1
a696 2
		&& id[0] == id_cert[i][0]
		&& memcmp (id + 4, id_cert[i] + 4, id_len - 4) == 0)
@


1.38
log
@Plug one memory leak. Found with boehm-gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.37 2001/01/27 15:39:54 ho Exp $	*/
d202 1
a202 1
				strlen (PRIVATE_KEY_FILE) + 3, sizeof(char));
d229 1
a229 1
	  buf = calloc (sb.st_size + 1, sizeof(char));
d744 1
a744 1
				       sizeof(char));
@


1.37
log
@Call OpenSSL functions with LC (). Various style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.36 2001/01/27 12:03:32 niklas Exp $	*/
d216 4
a219 1
	    goto ignorekeynote;
@


1.36
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.35 2001/01/27 11:53:57 itojun Exp $	*/
d59 3
a73 3
#ifdef USE_DNSSEC
#include "dnssec.h"
#endif
@


1.35
log
@include dnssec.h only if USE_DNSSEC; niklas ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.34 2001/01/26 21:49:37 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
d8 1
a8 1
 * Copyright (c) 2000 Håkan Olsson.  All rights reserved.
@


1.34
log
@Preliminary but working code to permit IKE authentication using DNSSEC
validated KEY records. Uses lwresd from the bind-9.1.0 port.
Enable by adding 'dnssec' to FEATURES.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.31 2000/12/19 19:03:05 mickey Exp $	*/
d71 1
d73 1
@


1.33
log
@include keynote.h only if USE_KEYNOTE is defined; ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.32 2001/01/26 12:12:51 niklas Exp $	*/
d8 1
d71 1
d550 1
a550 1
  u_int32_t rawlen;
d560 4
d607 1
a607 1
  if (handler->cert_obtain (id, id_len, 0, &rawcert, &rawlen))
d611 1
a611 1
	  cert = handler->cert_get (rawcert, rawlen);
d757 20
a776 1
  /* If no certificate provided a key, try the config file.  */
@


1.32
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.31 2000/12/19 19:03:05 mickey Exp $	*/
d48 1
d50 1
@


1.31
log
@gmp is gone, make it build again; cvs retard
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.30 2000/11/23 12:56:33 niklas Exp $	*/
d568 4
a571 3
  /* XXX Assume we should use the same kind of certification as the
     XXX remote...moreover, just use the first CERT payload to
     XXX decide what to use. */
@


1.30
log
@Merge with EOM 1.59

author: angelos
Initialize variable, avoid free() warnings.

author: provos
when cert_get fails dont dereference p if its NULL, found by
francis.dupont@@enst-bretagne.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.29 2000/10/13 13:42:50 niklas Exp $	*/
a56 1
#include "gmp.h"
@


1.29
log
@util.h: Merge with EOM 1.8
ike_auth.c: Merge with EOM 1.57

author: ho
Add file permission check to private key file. Split out check function to util.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.28 2000/10/07 07:01:04 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.57 2000/10/13 13:04:16 ho Exp $	*/
d546 1
a546 1
  u_int8_t *rawcert;
d580 2
a581 1
		 "cert_get (%d) failed", GET_ISAKMP_CERT_ENCODING (p->p));
@


1.29.2.1
log
@Pull in patch from current:
Fix (angelos, provos):
Merge with EOM 1.59

author: angelos
Initialize variable, avoid free() warnings.

author: provos
when cert_get fails dont dereference p if its NULL, found by
francis.dupont@@enst-bretagne.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.29 2000/10/13 13:42:50 niklas Exp $	*/
d546 1
a546 1
  u_int8_t *rawcert = NULL;
d580 1
a580 2
		 "cert_get (%d) failed", p != NULL
		 ? GET_ISAKMP_CERT_ENCODING (p->p) : -1);
@


1.29.2.2
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.39 2001/04/09 12:34:37 ho Exp $	*/
/*	$EOM: ike_auth.c,v 1.59 2000/11/21 00:21:31 angelos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
a7 1
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
a47 1
#if defined(USE_KEYNOTE)
a48 1
#endif
a55 3
#if defined(USE_DNSSEC)
#include "dnssec.h"
#endif
d57 1
d197 1
a197 1
				strlen (PRIVATE_KEY_FILE) + 3, sizeof (char));
d211 1
a211 4
	    {
	      free (keyfile);
	      goto ignorekeynote;
	    }
d221 1
a221 1
	  buf = calloc (sb.st_size + 1, sizeof (char));
d547 1
a547 1
  u_int32_t rawcertlen;
a556 4
#if defined(USE_DNSSEC)
  u_int8_t *rawkey = NULL;
  u_int32_t rawkeylen;
#endif
d569 3
a571 4
  /*
   * XXX Assume we should use the same kind of certification as the remote...
   * moreover, just use the first CERT payload to decide what to use.
   */
d599 1
a599 1
  if (handler->cert_obtain (id, id_len, 0, &rawcert, &rawcertlen))
d603 1
a603 1
	  cert = handler->cert_get (rawcert, rawcertlen);
d731 1
a731 1
				       sizeof (char));
d749 1
a749 20
  /* If no certificate provided a key, try to find a validated DNSSEC KEY. */
#if defined(USE_DNSSEC)
  if (!found)
    {
      rawkey = dns_get_key (IKE_AUTH_RSA_SIG, msg, &rawkeylen);
      if (rawkey)
	found++;
      
      /* We need to convert 'void *rawkey' into 'RSA *key'. */
      if (dns_RSA_dns_to_x509 (rawkey, rawkeylen, &key) == -1)
	{
	  log_print ("rsa_sig_decode_hash: KEY to RSA key conversion failed");
	  free (rawkey);
	  return -1;
	}
      free (rawkey);
    }
#endif /* USE_DNSSEC */

  /* If we still have not found a key, try the config file.  */
@


1.28
log
@Merge with EOM 1.56

author: niklas
Multiple subject name matching, makes certificate interop with PGPnet at least
partly working.  Added some error checking.

author: angelos
No need to delete SPIs, they'll just expire.

author: provos
style as pointed out by the code style pedant.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.27 2000/08/03 07:23:32 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.56 2000/09/28 12:53:27 niklas Exp $	*/
d275 3
@


1.27
log
@Merge with EOM 1.53

author: provos
prevent isakmpd crashing when client gives an unknown ID in aggressive mode.
bug report from James Winquist <winquist@@mail.cybernet.com>
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.26 2000/06/20 05:55:15 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.53 2000/07/25 17:15:40 provos Exp $	*/
d243 2
a244 2
	  buf2 = kn_get_string(buf);
	  free(buf);
d550 2
a551 2
  u_int8_t **hash_p, *id_cert, *id;
  u_int32_t id_cert_len;
d553 1
a553 1
  int found = 0;
d669 1
a669 1
	  if (!handler->cert_get_subject (cert, &id_cert, &id_cert_len))
d676 9
a684 1
	  if (id_cert_len != id_len || memcmp (id, id_cert, id_len) != 0)
d687 1
a687 2
	      log_print ("rsa_sig_decode_hash: CERT subject does "
			 "not match ID");
d692 1
a692 1
	  free (id_cert);
d867 6
d874 1
a874 1
		 "cert_get(ISAKMP_CERTENC_X509_SIG) failed");
@


1.26
log
@Merge with EOM 1.52

author: niklas
Indentation, bad greek
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.25 2000/06/08 20:48:53 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.52 2000/06/19 07:41:07 niklas Exp $	*/
d374 4
@


1.25
log
@Merge with EOM 1.51

author: angelos
Don't add the callback at initialization time, we must set it before
each invokation.

author: angelos
Different policy/Keynote sessions per Phase 1 SA.

author: angelos
Allow exchange of KeyNote credentials over IKE. Multiple credentials
may be passed in a single CERT payload. KeyNote is used if a
directory named as the local ID we use in an exchange exists in the
KeyNote directory (default: /etc/isakmpd/keynote/). Note that
asymmetric credentials are possible (use KeyNote in one direction and
X509 in the other); such authentication is envisioned to be the most
common: the clients will use KeyNote credentials to authenticate and
authorize with a server, whilst the server will just provide an X509
certificate proving its binding to the IP address or ID.

Totally asymmetric authentication (e.g., shared key in one direction,
RSA in the other) is not supported by the IKE protocol.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.24 2000/04/07 22:07:44 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.51 2000/06/08 01:47:53 angelos Exp $	*/
d152 4
a155 2
	    log_print ("ike_auth_get_key: no key found for peer \"%s\"or local ID \"%s\"", id, local_id);
	    return 0;
d233 3
a235 1
	      log_print ("ike_auth_get_key: failed reading %d bytes from \"%s\"", sb.st_size, keyfile);
d603 3
a605 2
		    log_print ("rsa_sig_decode_hash: decoding certificate failed");
		    handler->cert_free (cert);
d618 2
a619 5
      else
	if (handler->id == ISAKMP_CERTENC_KEYNOTE)
	  {
	    handler->cert_insert (exchange->policy_id, rawcert);
	  }
d893 1
a893 1
  switch (id[0])
@


1.24
log
@Merge with EOM 1.48

author: niklas
Style and correct error reporting

author: provos
remove double free(buf), caused skeyid to point to skeyid_d when using USER_FQDN

author: niklas
More braindamage with USE_ macros
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.23 2000/02/28 23:59:14 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.48 2000/04/07 19:43:31 niklas Exp $	*/
d40 3
d47 3
d78 1
a78 1
#ifdef USE_X509
d97 1
a97 1
#ifdef USE_X509
d131 1
a131 1
ike_auth_get_key (int type, char *id, size_t *keylen)
d134 1
a134 1
#ifdef USE_X509
d136 1
d140 1
d147 3
d151 3
a153 3
	{
	  log_print ("ike_auth_get_key: no key found for peer \"%s\"", id);
	  return 0;
d155 1
a155 1
      
d179 1
a179 1
#ifdef USE_X509
d184 68
d253 17
d302 1
d323 7
a329 4
  /* Get the pre-shared key for our peer.  */
  key = ike_auth_get_key (IKE_AUTH_PRE_SHARED, exchange->name, &keylen);

  if (!key)
d331 1
a331 7
      /*
       * If we're the responder and have the initiator's ID (which is the
       * case in Aggressive mode), try to find the preshared key in the
       * section of the initiator's Phase I ID.  This allows us to do mobile
       * user support with preshared keys.
       */
      if (!exchange->initiator && exchange->id_i)
d333 3
a335 1
	  switch (exchange->id_i[0])
d337 17
a353 29
	    case IPSEC_ID_IPV4_ADDR:
	      buf = malloc (16);
	      if (!buf)
		{
		  log_error ("pre_shared_gen_skeyid: malloc (16) failed");
		  return 0;
		}
	      addr = htonl (decode_32 (exchange->id_i + ISAKMP_ID_DATA_OFF -
				       ISAKMP_GEN_SZ));
	      inet_ntop (AF_INET, &addr, buf, 16);
	      break;
		  
	    case IPSEC_ID_FQDN:
	    case IPSEC_ID_USER_FQDN:
	      buf = calloc (exchange->id_i_len - ISAKMP_ID_DATA_OFF +
			    ISAKMP_GEN_SZ + 1, sizeof (char));
	      if (!buf)
		{
		  log_print ("pre_shared_gen_skeyid: malloc (%d) failed",
			     exchange->id_i_len - ISAKMP_ID_DATA_OFF
			     + ISAKMP_GEN_SZ + 1);
		  return 0;
		}
	      memcpy (buf, exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		      exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
	      break;

	      /* XXX Support more ID types ? */
	    default:
d356 9
d366 4
a369 8
	  key = ike_auth_get_key (IKE_AUTH_PRE_SHARED, buf, &keylen);
	  free (buf);
	  if (!key)
	    return 0;
	}
      else
	return 0;
  }
d404 2
a405 2
#ifdef USE_X509
/* Both DSS & RSA signature authentication uses this algorithm.  */
d441 1
a441 1
#endif /* USE_X509 */
d445 1
a445 1
 * Both standard and revised RSA encryption authentication uses this SKEYID
d525 1
a525 1
#ifdef USE_X509
d558 8
a565 2
  /* XXX This needs to be configureable.  */
  handler = cert_get (ISAKMP_CERTENC_X509_SIG);
d569 1
a569 1
		 "cert_get (ISAKMP_CERTENC_X509_SIG) failed");
d573 13
d589 6
a594 11
      cert = handler->cert_get (rawcert, rawlen);
      if (!cert)
	LOG_DBG ((LOG_CRYPTO, 50,
		  "rsa_sig_decode_hash: certificate malformed"));
      else
	{
	  if (!handler->cert_get_key (cert, &key))
	    {
	      log_print ("rsa_sig_decode_hash: decoding certificate failed");
	      handler->cert_free (cert);
	    }
d597 14
a610 5
	      found++;
	      LOG_DBG ((LOG_CRYPTO, 40,
			"rsa_sig_decode_hash: using cert from X509_STORE"));
	      exchange->recv_cert = cert;
	      exchange->recv_certtype = handler->id;
d613 5
d661 17
a677 6
      if (!handler->cert_get_subject (cert, &id_cert, &id_cert_len))
	{
	  handler->cert_free (cert);
	  log_print ("rsa_sig_decode_hash: can not get subject from CERT");
	  continue;
	}
a678 4
      if (id_cert_len != id_len || memcmp (id, id_cert, id_len) != 0)
	{
	  handler->cert_free (cert);
	  log_print ("rsa_sig_decode_hash: CERT subject does not match ID");
a679 1
	  continue;
a680 1
      free (id_cert);
d690 1
a690 1
      handler->cert_insert (cert);
d695 34
d800 1
a800 1
#endif /* USE_X509 */
d825 1
a825 1
#ifdef USE_X509
d837 1
a837 1
  u_int8_t *buf, *data;
d841 2
d848 4
a851 1
  handler = cert_get (ISAKMP_CERTENC_X509_SIG);
d871 1
a871 1
      SET_ISAKMP_CERT_ENCODING (buf, ISAKMP_CERTENC_X509_SIG);
d880 10
a889 1
    LOG_DBG ((LOG_MISC, 10, "rsa_sig_encode_hash: no certificate to send"));
d891 35
a925 1
  key = ike_auth_get_key (IKE_AUTH_RSA_SIG, exchange->name, NULL);
d940 1
a940 1
  
d993 1
a993 1
#endif /* USE_X509 */
@


1.23
log
@Merge with EOM 1.45

author: niklas
I must have been on drugs.  X509 is not preshared key.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.22 2000/02/25 17:23:40 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.45 2000/02/28 23:59:40 niklas Exp $	*/
d64 1
d66 1
a67 1
static u_int8_t *sig_gen_skeyid (struct exchange *, size_t *);
d70 4
a74 1
static int pre_shared_encode_hash (struct message *);
d76 1
a77 1
#ifdef USE_X509
a78 1
#endif
d85 1
d90 2
d96 2
d106 1
d230 8
a237 6
  {
      /* If we're the responder and have the initiator's ID (which is the
	 case in Aggressive mode), try to find the preshared key in the
	 section of the initiator's Phase I ID. This allows us to do mobile
	 user support with preshared keys. */
      if ((exchange->initiator == 0) && exchange->id_i)
d239 13
a251 11
	    switch (exchange->id_i[0])
	      {
	      case IPSEC_ID_IPV4_ADDR:
		  buf = calloc (16, sizeof (char));
		  if (!buf)
		    log_fatal ("pre_shared_gen_skeyid: failed to allocate 16 bytes for ID");
		  addr = ntohl (decode_32 (exchange->id_i +
					   ISAKMP_ID_DATA_OFF -
					   ISAKMP_GEN_SZ));
		  inet_ntop (AF_INET, &addr, buf, 16);
		  break;
d253 9
a261 13
	      case IPSEC_ID_FQDN:
	      case IPSEC_ID_USER_FQDN:
		  buf = calloc (exchange->id_i_len - ISAKMP_ID_DATA_OFF +
				ISAKMP_GEN_SZ + 1, sizeof (char));
		  if (!buf)
		    log_fatal ("pre_shared_gen_skeyid: failed to allocate %d bytes for ID", exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1);
		  memcpy (buf, exchange->id_i + ISAKMP_ID_DATA_OFF -
			  ISAKMP_GEN_SZ, exchange->id_i_len -
			  ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ);
		  break;

		  /* XXX Support more ID types ? */
	      default:
d263 4
a266 1
	      }
d268 2
a269 3
	    key = ike_auth_get_key (IKE_AUTH_PRE_SHARED, buf, &keylen);
	    free (buf);
	    if (!key)
d271 6
d282 1
a282 1
  /* Store the secret key for later policy processing */
d286 1
a286 1
      log_error ("pre_shared_gen_skeyid: malloc (%d) failed", keylen + 1);
a293 2
  if (buf)
    free (buf);
d315 1
d352 1
d354 1
d391 1
d436 1
a440 1
#ifdef USE_X509
d643 1
a643 2
#else
  return -1;
a644 1
}
d669 1
a673 1
#ifdef USE_X509
d693 1
a693 1
      log_print ("rsa_sig_decode_hash: "
d719 1
a719 1
    LOG_DBG ((LOG_MISC, 10, "rsa_sig_decode_hash: no certificate to send"));
d724 1
a724 1
      log_error ("rsa_sig_encode_hash: could not get private key");
d788 1
a788 2
#else 
  return -1;
a789 1
}
a790 1
#ifdef USE_X509
a827 1
#endif
@


1.22
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.21 2000/02/19 19:32:53 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.44 2000/02/20 19:58:37 niklas Exp $	*/
a631 1
#ifdef USE_X509
a649 3
#else
  return -1;
#endif
@


1.21
log
@cert.c: Merge with EOM 1.14
ike_auth.c: Merge with EOM 1.43
ike_phase_1.c: Merge with EOM 1.21
init.c: Merge with EOM 1.24
ipsec.c: Merge with EOM 1.117
isakmpd.c: Merge with EOM 1.44
math_group.c: Merge with EOM 1.22

author: niklas
Copyright 2000

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.20 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.43 2000/02/19 07:58:54 niklas Exp $	*/
d410 1
a410 1
  log_debug_buf (LOG_MISC, 80, header, *hash_p, hashsize);
d464 2
a465 2
	log_debug (LOG_CRYPTO, 50,
		   "rsa_sig_decode_hash: certificate malformed");
d476 2
a477 2
	      log_debug (LOG_CRYPTO, 40,
			 "rsa_sig_decode_hash: using cert from X509_STORE");
d502 4
a505 4
	  log_debug (LOG_MISC, 30,
		     "rsa_sig_decode_hash: no handler for %s CERT encoding",
		     constant_lookup (isakmp_certenc_cst,
				      GET_ISAKMP_CERT_ENCODING (p->p)));
d619 1
a619 1
  log_debug_buf (LOG_MISC, 80, header, *hash_p, hashsize);
d649 1
a649 1
  log_debug_buf (LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize);
d706 1
a706 1
    log_debug (LOG_MISC, 10, "rsa_sig_decode_hash: no certificate to send");
d732 1
a732 1
  log_debug_buf (LOG_MISC, 80, header, buf, hashsize);
d767 1
a767 1
  log_debug_buf (LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF, datalen);
@


1.20
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.19 1999/10/01 14:10:54 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.41 2000/01/31 22:33:45 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
d73 1
a73 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d119 1
a119 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d159 1
a159 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d421 1
a421 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d626 1
a626 1
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
d632 1
a632 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d660 1
a660 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
d777 1
a777 1
#endif /* USE_LIBCRYPTO || HAVE_DLOPEN */
d780 1
a780 1
#if defined (USE_LIBCRYPTO) || defined (HAVE_DLOPEN)
@


1.19
log
@Merge with EOM 1.40

author: angelos
Allow for new versions of SSLeay

author: angelos
Remove evil experimental code, fix off-by-1 buffer allocation.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.18 1999/09/29 04:45:01 deraadt Exp $	*/
/*	$EOM: ike_auth.c,v 1.40 1999/09/28 16:35:48 angelos Exp $	*/
d7 1
@


1.18
log
@openssl readiness; various group members
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.17 1999/08/26 22:30:08 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.38 1999/08/21 22:20:41 angelos Exp $	*/
a37 2
/* #define OBTAIN_KEY 1 */

a43 4
#if defined(OBTAIN_KEY)
#include <unistd.h>
#endif /* OBTAIN_KEY */

a213 6

#if defined (OBTAIN_KEY)
  struct sockaddr_in sin;
  u_int32_t idlen;
  int sock;
#else /* OBTAIN_KEY */
a214 1
#endif /* OBTAIN_KEY */
a218 1
#if !defined (OBTAIN_KEY)
a262 70
#else /* OBTAIN_KEY */
  /* If we didn't find the key in the config file, we can try to
   * find it based on ID, or (if that fails) we can try to fetch it
   * from a remote server.
   */
  /* XXX Experimental */

  if (!key)
    {
	sock = socket (PF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == -1)
	  return 0;

	sin.sin_addr.s_addr = inet_addr ("158.130.6.141"); /* XXX */
	sin.sin_port = ntohs (3456); /* XXX */
	sin.sin_family = AF_INET;
	sin.sin_len = sizeof (sin);

	if (connect (sock, (struct sockaddr *) &sin, sizeof (sin)) == -1)
	  {
	      close (sock);
	      return 0;
	  }

	idlen = htonl (exchange->id_i_len - ISAKMP_ID_DATA_OFF +
		       ISAKMP_GEN_SZ);

	printf ("%d [%s]\n", exchange->id_i[0],
		exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ);

	/* Simple protocol; write type (1 byte), size (4 bytes, big endian),
	   id data */
	if ((write (sock, exchange->id_i, 1) == -1) ||
	    (write (sock, &idlen, sizeof (idlen)) == -1) ||
	    (write (sock, exchange->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		    exchange->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ) ==
	     -1))
	  {
	      close (sock);
	      return 0;
	  }

	/* Read response; size (4 bytes, big endian), passphrase */
	/* XXX This should really be some sort of asynchronous operation... */
	/* XXXXXX This should be protected XXXXXXX */
	if (read (sock, &keylen, sizeof (idlen)) == -1)
	  {
	      close (sock);
	      return 0;
	  }

	keylen = ntohl (keylen);
	key = malloc (keylen);
	if (!key)
	  {
	      log_error ("pre_shared_gen_skeyid: malloc (%d) failed", keylen);
	      close (sock);
	      return 0;
	  }

	if (read (sock, key, keylen) == -1)
	  {
	      free (key);
	      close (sock);
	      return 0;
	  }
	
	close (sock);
    }
#endif /* OBTAIN_KEY */
d268 1
a268 1
      log_error ("pre_shared_gen_skeyid: malloc (%d) failed", keylen);
@


1.17
log
@Merge with EOM 1.38

author: angelos
When doing preshared key authentication, if the responder has the
initiator's ID (as is the case in aggressive mode) and a shared key
cannot be found for the initiator's address (as may be the case for a
roaming laptop user), try to find the password under using as a lookup
key the initiator's Phase 1 ID, if it's an IPv4 address, an FQDN
(host.domain), or a User-FQDN (user@@host.domain). This allows us to
support roaming laptop users with preshared key authentication, using
aggressive mode (sick).

There is also a lot of experimental, insecure, and ifdef'd out code
for fetching credentials and secret passphrases from a remote server
if all else fails. Extremely experimental code. Don't use. You'll be
blinded and your hair will fall if you even think about using it. You
have been warned.

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.

author: ho
Compile without USE_LIBCRYPTO and HAVE_DLOPEN.

author: niklas
Missing dynamic link fixes

author: niklas
Add support for dynamic loading of optional facilities, libcrypto first.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.16 1999/07/18 09:33:33 niklas Exp $	*/
d187 3
d191 1
@


1.16
log
@samples/VPN-east.conf: Merge with EOM 1.7
samples/VPN-west.conf: Merge with EOM 1.7
samples/singlehost-west.conf: Merge with EOM 1.4
samples/singlehost-east.conf: Merge with EOM 1.4
README.PKI: Merge with EOM 1.3
ike_auth.c: Merge with EOM 1.33
isakmpd.conf.5: Merge with EOM 1.28

author: niklas
Moving the PRIVKEY tag into the X509-certificates section, renaming it to
Private-key.  Also rename the keynote policy file.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.15 1999/07/17 21:54:39 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.33 1999/07/18 09:25:33 niklas Exp $	*/
d38 2
d46 3
a48 3
#include <ssl/evp.h>
#include <ssl/pem.h>
#include <ssl/x509.h>
d62 1
d78 1
d80 1
d124 1
d128 1
d164 6
d172 1
a172 1
      if ((keyh = BIO_new (BIO_s_file ())) == NULL)
d174 2
a175 1
	  log_print ("ike_auth_get_key: BIO_new() failed");
d178 1
a178 1
      if (BIO_read_filename (keyh, keyfile) == -1)
d180 2
a181 1
	  log_print ("ike_auth_get_key: BIO_read_filename(%s) failed",
d183 1
a183 1
	  BIO_free (keyh);
d187 1
a187 1
      rsakey = PEM_read_bio_RSAPrivateKey (keyh, NULL, NULL);
d190 2
a191 3
	  log_print ("ike_auth_get_key: PEM_read_bio_RSAPrivateKey failed",
		     keyfile);
	  BIO_free (keyh);
d195 1
a195 1
      BIO_free (keyh);
d197 1
d217 8
d227 2
d230 113
a342 1
    return 0;
d351 1
d354 1
a354 1

d500 1
d511 1
a513 1
  int len;
d656 1
a656 1
      RSA_free (key);
d662 1
a662 1
  if (len != RSA_size (key))
d664 1
a664 1
      RSA_free (key);
d673 1
a673 1
      RSA_free (key);
d678 2
a679 2
  len = RSA_public_decrypt (len, p->p + ISAKMP_SIG_DATA_OFF, *hash_p, key,
			    RSA_PKCS1_PADDING);
d682 1
a682 1
      RSA_free (key);
d687 1
a687 1
  RSA_free (key);
d703 3
d711 1
a728 1

d730 3
d739 1
d799 1
a799 1
      RSA_free (key);
d806 1
a806 1
      RSA_free (key);
d813 1
a813 1
  data = malloc (RSA_size (key));
d816 3
a818 2
      log_error ("rsa_sig_encode_hash: malloc (%d) failed", RSA_size (key));
      RSA_free (key);
d822 2
a823 1
  datalen = RSA_private_encrypt (hashsize, buf, data, key, RSA_PKCS1_PADDING);
d828 1
a828 1
      RSA_free (key);
d832 1
a832 1
  RSA_free (key);
a852 1

d854 3
d859 1
d897 1
@


1.15
log
@regress/rsakeygen/Makefile: Merge with EOM 1.4
regress/rsakeygen/rsakeygen.c: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.6
regress/x509/x509test.c: Merge with EOM 1.6
regress/Makefile: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.6
samples/VPN-west.conf: Merge with EOM 1.6
samples/singlehost-east.conf: Merge with EOM 1.3
samples/singlehost-west.conf: Merge with EOM 1.3
sysdep/openbsd/Makefile.sysdep: Merge with EOM 1.5
x509.h: Merge with EOM 1.6
x509.c: Merge with EOM 1.17
DESIGN-NOTES: Merge with EOM 1.46
Makefile: Merge with EOM 1.55
cert.c: Merge with EOM 1.11
cert.h: Merge with EOM 1.6
exchange.c: Merge with EOM 1.109
exchange.h: Merge with EOM 1.26
ike_auth.c: Merge with EOM 1.32
ike_phase_1.c: Merge with EOM 1.7
init.c: Merge with EOM 1.16
isakmpd.conf.5: Merge with EOM 1.27
README.PKI: Merge with EOM 1.1

author: niklas
From Niels Provos, edited by me: certificate support using SSLeay
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.14 1999/07/07 22:04:08 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.32 1999/07/17 20:44:10 niklas Exp $	*/
d157 1
a157 1
      keyfile = conf_get_str ("RSA_sig", "privkey");
@


1.14
log
@Merge with EOM 1.31

author: niklas
indent
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.13 1999/05/02 19:20:31 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.31 1999/06/10 13:29:02 niklas Exp $	*/
d6 1
d44 4
a49 1
#include "asn.h"
a61 1
#include "pkcs.h"
d115 2
a116 2
static char *
ike_auth_get_key (char *id, size_t *keylen)
d119 3
d123 1
a123 3
  /* Get the pre-shared key for our peer.  */
  key = conf_get_str (id, "Authentication");
  if (!key)
d125 33
a157 3
      log_print ("ike_auth_get_key: no key found for peer \"%s\"", id);
      return 0;
    }
d159 6
a164 6
  /* If the key starts with 0x it is in hex format.  */
  if (strncasecmp (key, "0x", 2) == 0)
    {
      *keylen = (strlen (key) - 1) / 2;
      buf = malloc (*keylen);
      if (!buf)
d166 3
a168 1
	  log_print ("ike_auth_get_key: malloc (%d) failed", *keylen);
d171 3
a173 1
      if (hex2raw (key + 2, buf, *keylen))
d175 3
a177 2
	  free (buf);
	  log_print ("ike_auth_get_key: invalid hex key %s", key);
d180 7
a186 1
      key = buf;
a187 2
  else
    *keylen = strlen (key);
d203 1
a203 1
  key = ike_auth_get_key (exchange->name, &keylen);
d207 10
d366 4
a369 1
  struct rsa_public_key key;
d374 1
a374 1
  u_int16_t len;
d386 1
a386 1
      log_print ("rsa_sig_decode_hash: no ID in sa");
d390 34
a423 3
  /* Just bother with the ID data field.  */
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
d425 5
d449 17
a465 4
      if (!handler->cert_get_subject (p->p + ISAKMP_CERT_DATA_OFF, 
				      GET_ISAKMP_GEN_LENGTH (p->p) - 
				      ISAKMP_CERT_DATA_OFF,
				      &id_cert, &id_cert_len))
d467 1
d474 1
d481 1
a481 4
      if (!handler->cert_get_key (p->p + ISAKMP_CERT_DATA_OFF, 
				  GET_ISAKMP_GEN_LENGTH (p->p) -
				  ISAKMP_CERT_DATA_OFF,
				  &key))
d483 1
d488 6
d501 1
a501 1
      rawkey = ike_auth_get_key (exchange->name, &keylen);
d517 1
a517 1
      pkcs_free_public_key (&key);
d522 2
a523 1
  if (GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SIG_SZ != mpz_sizeinoctets (key.n))
d525 1
a525 1
      pkcs_free_public_key (&key);
d531 2
a532 2
  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, &key, 0, p->p + ISAKMP_SIG_DATA_OFF,
			 hash_p, &len))
d534 2
a535 1
      pkcs_free_public_key (&key);
d539 10
a548 1
  pkcs_free_public_key (&key);
d554 1
d598 1
a598 1
  struct rsa_private_key key;
d601 7
a607 3
  u_int8_t *buf, *asn, *data;
  u_int32_t asnlen, datalen;
  char *keyfile;
d613 2
a614 7
      /* XXX Log? */
      return -1;
    }
  /* XXX Implicitly uses exchange->id_{i,r}.  */
  if (!handler->cert_obtain (exchange, 0, &data, &datalen))
    {
      /* XXX Log? */
d618 2
a619 2
  buf = realloc (data, ISAKMP_CERT_SZ + datalen);
  if (!buf)
d621 16
a636 12
      log_error ("rsa_sig_encode_hash: realloc (%p, %d) failed", data,
		 ISAKMP_CERT_SZ + datalen);
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_CERT_SZ, buf, datalen);
  SET_ISAKMP_CERT_ENCODING (buf, ISAKMP_CERTENC_X509_SIG);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_CERT, buf,
			   ISAKMP_CERT_SZ + datalen, 1))
    {
      free (buf);
      return -1;
d638 2
d641 2
a642 9
  /* XXX Do we want to store our files in ASN.1?  */
  keyfile = conf_get_str ("RSA_sig", "privkey");
  if (!asn_get_from_file (keyfile, &asn, &asnlen))
    {
      /* XXX Log? */
      return -1;
    }
	
  if (!pkcs_private_key_from_asn (&key, asn, asnlen))
d644 1
a644 2
      /* XXX Log? */
      free (asn);
a646 1
  free (asn);
d648 1
a648 1
  /* XXX hashsize is not necessarily prf->blocksize */
d653 1
a653 1
      pkcs_free_private_key (&key);
d660 1
a660 1
      pkcs_free_private_key (&key);
d667 2
a668 2
  if (!pkcs_rsa_encrypt (PKCS_PRIVATE, 0, &key, buf, hashsize, &data,
			 &datalen))
d670 9
d680 1
a680 1
      pkcs_free_private_key (&key);
d683 2
a684 1
  pkcs_free_private_key (&key);
@


1.13
log
@BUGS: Merge with EOM 1.31
doi.h: Merge with EOM 1.27
ike_auth.c: Merge with EOM 1.30
ike_quick_mode.c: Merge with EOM 1.85
ipsec.c: Merge with EOM 1.107
ipsec.h: Merge with EOM 1.36
isakmp_doi.c: Merge with EOM 1.39

author: niklas
Factor out keyed hashing of all payloads with SKEYID_a, and make DOI hooks
for informational exchanges to add such hashing.  Use it from QM and the IKE
authentication module too.  Remove some bogus XXX comments.  Add error
reporting
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.12 1999/04/19 21:08:44 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.30 1999/05/02 12:48:56 niklas Exp $	*/
d390 6
a395 6
    rawkey = ike_auth_get_key (exchange->name, &keylen);
    if (!rawkey)
      {
	log_print ("rsa_sig_decode_hash: no public key found");
	return -1;
      }
@


1.12
log
@./ike_auth.c: Merge with EOM 1.29

Accept multiple CERT payloads.  Some style nits.

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

Memory alloc. error reporting

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.11 1999/03/24 14:42:49 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.29 1999/04/18 15:17:51 niklas Exp $	*/
d278 4
a281 1
    return -1;
d453 1
a453 2
  /* XXX - hashsize is not necessarily prf->blocksize.  */
  buf = malloc (ISAKMP_HASH_SZ + hashsize);
d455 2
a456 6
    {
      log_error ("pre_shared_encode_hash: malloc (%d) failed",
		 ISAKMP_HASH_SZ + hashsize);
      return -1;
    }
  
d458 1
a458 5
    {
      /* XXX Log? */
      free (buf);
      return -1;
    }
a462 6
  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, buf,
			   ISAKMP_HASH_SZ + hashsize, 1))
    {
      free (buf);
      return -1;
    }
d513 1
a513 1
  /* XXX - do we want to store our files in ASN.1 ? */
d529 1
a529 1
  /* XXX - hashsize is not necessarily prf->blocksize */
d533 1
a533 1
      /* XXX Log?  */
a539 1
      /* XXX Log? */
d597 1
a597 1
      return -1;
@


1.11
log
@Merge with EOM 1.25
Only get the destination address when needed

RSA fixes and optimiations from Ilya Tsindlekht, via Niels Provos
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.10 1999/02/26 03:40:50 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.25 1999/03/24 10:59:29 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d48 1
d75 20
a94 10
  { IKE_AUTH_PRE_SHARED, pre_shared_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash},
  { IKE_AUTH_DSS, sig_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash},
  { IKE_AUTH_RSA_SIG, sig_gen_skeyid, rsa_sig_decode_hash,
    rsa_sig_encode_hash},
  { IKE_AUTH_RSA_ENC, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash},
  { IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash},
d108 6
a113 2
static u_int8_t *
pre_shared_gen_skeyid (struct exchange *exchange, size_t *sz)
d115 1
a115 6
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *skeyid;
  u_int8_t *key;
  u_int8_t *buf = 0;
  size_t keylen;
d118 1
a118 1
  key = conf_get_str (exchange->name, "Authentication");
d121 1
a121 2
      log_print ("pre_shared_gen_skeyid: no key found for peer \"%s\"",
		 exchange->name);
d128 2
a129 2
      keylen = (strlen (key) - 1) / 2;
      buf = malloc (keylen);
d132 1
a132 1
	  log_print ("pre_shared_gen_skeyid: malloc (%d) failed", keylen);
d135 1
a135 1
      if (hex2raw (key + 2, buf, keylen))
d138 1
a138 1
	  log_print ("pre_shared_gen_skeyid: invalid hex key");
d144 19
a162 1
    keylen = strlen (key);
d174 1
d212 1
d249 1
d287 4
a290 1
    return -1;
d302 1
a302 4
/*
 * Decrypt the HASH in SIG, we already need a parsed ID payload
 */

d318 1
d325 1
a325 1
  if (id == NULL || id_len == 0)
d335 8
a342 3
  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT]);
  if (!p)
    return -1;
d344 9
a352 5
  if ((handler = cert_get (GET_ISAKMP_CERT_ENCODING(p->p))) == NULL)
    {
      log_print ("rsa_sig_decode_hash: no handler for CERT encoding");
      return -1;
    }
d354 19
a372 3
  /* XXX - this assumes IPv4 here */
  if (!handler->cert_get_subject (p->p + ISAKMP_CERT_DATA_OFF, 
				  GET_ISAKMP_GEN_LENGTH(p->p) - 
d374 5
a378 5
				  &id_cert, &id_cert_len))
    {
      log_print ("rsa_sig_decode_hash: can not get subject from CERT");
      return -1;
    }
d380 1
a380 5
  if (id_cert_len != id_len || memcmp (id, id_cert, id_len))
    {
      log_print ("rsa_sig_decode_hash: CERT subject does not match ID");
      free (id_cert);
      return -1;
a381 1
  free (id_cert);
d383 2
a384 4
  if (!handler->cert_get_key (p->p + ISAKMP_CERT_DATA_OFF, 
			      GET_ISAKMP_GEN_LENGTH(p->p) -
			      ISAKMP_CERT_DATA_OFF,
			      &key))
d386 9
a394 1
      log_print ("rsa_sig_decode_hash: decoding payload CERT failed");
d396 1
a398 2
  p->flags |= PL_MARK;

d402 1
d411 2
a412 2
      log_print ("rsa_sig_decode_hash: SIG payload length does not match "
		 "public key");
d416 2
a417 2
  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, &key, NULL,
			 p->p + ISAKMP_SIG_DATA_OFF, hash_p, &len))
d428 1
a428 1
      *hash_p = NULL;
d450 1
a450 1
  /* XXX - hashsize is not necessarily prf->blocksize */
d454 2
a455 1
      /* XXX Log?  */
a471 1
      /* XXX Log?  */
d479 1
a479 3

/* Encrypt the HASH into a SIG type */

d494 1
a494 1
  /* XXX - this needs to be configureable */
d496 1
a496 1
  if (handler == NULL)
d498 1
a498 1
      /* XXX - Log? */
d501 2
a502 2
  /* XXX - implicitly uses exchange->id_{i,r} */
  if (!handler->cert_obtain (exchange, NULL, &data, &datalen))
d504 1
a504 1
      /* XXX - Log? */
d509 1
a509 1
  if (buf == NULL)
d511 2
a512 1
      /* XXX Log? */
a520 1
      /* XXX Log?  */
d526 1
a526 1
  keyfile = conf_get_str ("rsa_sig", "privkey");
d561 2
a562 2
  if (!pkcs_rsa_encrypt (PKCS_PRIVATE, NULL, &key, buf, hashsize,
			 &data, &datalen))
d574 2
a575 1
      /* XXX Log?  */
a585 1
      /* XXX Log?  */
@


1.10
log
@Merge from the Ericsson repository
| revision 1.23
| date: 1999/02/25 11:39:02;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.9 1998/12/21 01:02:24 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.23 1999/02/25 11:39:02 niklas Exp $	*/
a103 3
  struct transport *t = exchange->last_received->transport;
  struct sockaddr *dst;
  int dst_len;
d107 1
a107 5
  /*
   * Get the pre-shared key for our peer's IP address, or if that does not
   * exist, the default.
   */
  t->vtbl->get_dst (t, &dst, &dst_len);
d359 1
a359 1
  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, key.n, key.e,
d506 1
a506 1
  if (!pkcs_rsa_encrypt (PKCS_PRIVATE, key.n, key.e, buf, hashsize,
@


1.9
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.8 1998/11/20 23:42:29 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.22 1998/12/15 16:58:41 niklas Exp $	*/
d42 2
@


1.8
log
@Preshared key per IP-address, and in hex-format too
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.7 1998/11/17 11:10:12 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.21 1998/11/20 23:34:56 niklas Exp $	*/
d113 1
a113 2
  key = conf_get_str ("pre_shared",
		      inet_ntoa (((struct sockaddr_in *)dst)->sin_addr));
d116 3
a118 6
      key = conf_get_str ("pre_shared", "default");
      if (!key)
	{
	  log_print ("pre_shared_gen_skeyid: no key found");
	  return 0;
	}
@


1.7
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_auth.c,v 1.6 1998/11/16 21:07:16 niklas Exp $	*/
/*	$EOM: ike_auth.c,v 1.20 1998/08/26 14:25:34 niklas Exp $	*/
d38 2
d57 2
d102 5
d109 2
a110 3
   * Get the default pre-shared key.
   * XXX This will be per-IP configurable too later, and representable in
   * hex too.
d112 37
a148 2
  key = conf_get_str ("pre_shared", "key");
  prf = prf_alloc (ie->prf_type, ie->hash->type, key, strlen (key));
@


1.6
log
@Reinstate X509 signature code except for RSA code
@
text
@d1 2
a2 1
/*	$OpenBSD: ike_auth.c,v 1.2 1998/11/15 00:43:54 niklas Exp $	*/
@


1.5
log
@Remove last warnings after crippling
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.4 1998/11/15 01:09:59 niklas Exp $	*/
d55 1
d60 1
d62 1
d71 6
a76 1
  /* XXX Here should be hooks to code patented in the US.  */
d161 36
d234 114
d378 116
@


1.4
log
@Remove more cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.3 1998/11/15 00:59:11 niklas Exp $	*/
a54 1
static u_int8_t *enc_gen_skeyid (struct exchange *, size_t *);
@


1.3
log
@cripple until later
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.2 1998/11/15 00:43:54 niklas Exp $	*/
a59 1
static int rsa_sig_decode_hash (struct message *);
a60 1
static int rsa_sig_encode_hash (struct message *);
a147 36
  prf->Final (skeyid, prf->prfctx);
  prf_free (prf);

  return skeyid;
}

/*
 * Both standard and revised RSA encryption authentication uses this SKEYID
 * computation.
 */
static u_int8_t *
enc_gen_skeyid (struct exchange *exchange, size_t *sz)
{
  struct prf *prf;
  struct ipsec_exch *ie = exchange->data;
  struct hash *hash = ie->hash;
  u_int8_t *skeyid;

  hash->Init (hash->ctx);
  hash->Update (hash->ctx, exchange->nonce_i, exchange->nonce_i_len);
  hash->Update (hash->ctx, exchange->nonce_r, exchange->nonce_r_len);
  hash->Final (hash->digest, hash->ctx);
  prf = prf_alloc (ie->prf_type, hash->type, hash->digest, *sz);
  if (!prf)
    return 0;

  *sz = prf->blocksize;
  skeyid = malloc (*sz);
  if (!skeyid)
    {
      prf_free (prf);
      return 0;
    }

  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
@


1.2
log
@openBSD RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_auth.c,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
d71 1
a71 6
  { IKE_AUTH_RSA_SIG, sig_gen_skeyid, rsa_sig_decode_hash,
    rsa_sig_encode_hash},
  { IKE_AUTH_RSA_ENC, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash},
  { IKE_AUTH_RSA_ENC_REV, enc_gen_skeyid, pre_shared_decode_hash,
    pre_shared_encode_hash},
a228 114
/*
 * Decrypt the HASH in SIG, we already need a parsed ID payload
 */

static int
rsa_sig_decode_hash (struct message *msg)
{
  struct cert_handler *handler;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *p;
  struct rsa_public_key key;
  size_t hashsize = ie->hash->hashsize;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t **hash_p, *id_cert, *id;
  u_int16_t len;
  u_int32_t id_cert_len;
  size_t id_len;

  /* Choose the right fields to fill-in.  */
  hash_p = initiator ? &ie->hash_r : &ie->hash_i;
  id = initiator ? exchange->id_r : exchange->id_i;
  id_len = initiator ? exchange->id_r_len : exchange->id_i_len;

  if (id == NULL || id_len == 0)
    {
      log_print ("rsa_sig_decode_hash: no ID in sa");
      return -1;
    }

  /* Just bother with the ID data field.  */
  id += ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
  id_len -= ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;

  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_CERT]);
  if (!p)
    return -1;

  if ((handler = cert_get (GET_ISAKMP_CERT_ENCODING(p->p))) == NULL)
    {
      log_print ("rsa_sig_decode_hash: no handler for CERT encoding");
      return -1;
    }
  
  /* XXX - this assumes IPv4 here */
  if (!handler->cert_get_subject (p->p + ISAKMP_CERT_DATA_OFF, 
				  GET_ISAKMP_GEN_LENGTH(p->p) - 
				  ISAKMP_CERT_DATA_OFF,
				  &id_cert, &id_cert_len))
    {
      log_print ("rsa_sig_decode_hash: can not get subject from CERT");
      return -1;
    }

  if (id_cert_len != id_len || memcmp (id, id_cert, id_len))
    {
      log_print ("rsa_sig_decode_hash: CERT subject does not match ID");
      free (id_cert);
      return -1;
    }
  free (id_cert);

  if (!handler->cert_get_key (p->p + ISAKMP_CERT_DATA_OFF, 
			      GET_ISAKMP_GEN_LENGTH(p->p) -
			      ISAKMP_CERT_DATA_OFF,
			      &key))
    {
      log_print ("rsa_sig_decode_hash: decoding payload CERT failed");
      return -1;
    }

  p->flags |= PL_MARK;

  p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SIG]);
  if (!p)
    {
      pkcs_free_public_key (&key);
      return -1;
    }

  /* Check that the sig is of the correct size.  */
  if (GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SIG_SZ != mpz_sizeinoctets (key.n))
    {
      pkcs_free_public_key (&key);
      log_print ("rsa_sig_decode_hash: SIG payload length does not match "
		 "public key");
      return -1;
    }

  if (!pkcs_rsa_decrypt (PKCS_PRIVATE, key.n, key.e,
			 p->p + ISAKMP_SIG_DATA_OFF, hash_p, &len))
    {
      pkcs_free_public_key (&key);
      return -1;
    }

  pkcs_free_public_key (&key);
  
  if (len != hashsize)
    {
      free (*hash_p);
      *hash_p = NULL;
      return -1;
    }

  snprintf (header, 80, "rsa_sig_decode_hash: HASH_%c", initiator ? 'R' : 'I');
  log_debug_buf (LOG_MISC, 80, header, *hash_p, hashsize);

  p->flags |= PL_MARK;

  return 0;
}

a258 116
    {
      /* XXX Log?  */
      free (buf);
      return -1;
    }

  return 0;
}


/* Encrypt the HASH into a SIG type */

static int
rsa_sig_encode_hash (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  size_t hashsize = ie->hash->hashsize;
  struct cert_handler *handler;
  struct rsa_private_key key;
  char header[80];
  int initiator = exchange->initiator;
  u_int8_t *buf, *asn, *data;
  u_int32_t asnlen, datalen;
  char *keyfile;

  /* XXX - this needs to be configureable */
  handler = cert_get (ISAKMP_CERTENC_X509_SIG);
  if (handler == NULL)
    {
      /* XXX - Log? */
      return -1;
    }
  /* XXX - implicitly uses exchange->id_{i,r} */
  if (!handler->cert_obtain (exchange, NULL, &data, &datalen))
    {
      /* XXX - Log? */
      return -1;
    }

  buf = realloc (data, ISAKMP_CERT_SZ + datalen);
  if (buf == NULL)
    {
      /* XXX Log? */
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_CERT_SZ, buf, datalen);
  SET_ISAKMP_CERT_ENCODING (buf, ISAKMP_CERTENC_X509_SIG);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_CERT, buf,
			   ISAKMP_CERT_SZ + datalen, 1))
    {
      /* XXX Log?  */
      free (buf);
      return -1;
    }

  /* XXX - do we want to store our files in ASN.1 ? */
  keyfile = conf_get_str ("rsa_sig", "privkey");
  if (!asn_get_from_file (keyfile, &asn, &asnlen))
    {
      /* XXX Log? */
      return -1;
    }
	
  if (!pkcs_private_key_from_asn (&key, asn, asnlen))
    {
      /* XXX Log? */
      free (asn);
      return -1;
    }
  free (asn);

  /* XXX - hashsize is not necessarily prf->blocksize */
  buf = malloc (hashsize);
  if (!buf)
    {
      /* XXX Log?  */
      pkcs_free_private_key (&key);
      return -1;
    }
  
  if (ike_auth_hash (exchange, buf) == -1)
    {
      /* XXX Log? */
      free (buf);
      pkcs_free_private_key (&key);
      return -1;
    }
    
  snprintf (header, 80, "rsa_sig_encode_hash: HASH_%c", initiator ? 'I' : 'R');
  log_debug_buf (LOG_MISC, 80, header, buf, hashsize);

  if (!pkcs_rsa_encrypt (PKCS_PRIVATE, key.n, key.e, buf, hashsize,
			 &data, &datalen))
    {
      free (buf);
      pkcs_free_private_key (&key);
      return -1;
    }
  pkcs_free_private_key (&key);
  free (buf);

  buf = realloc (data, ISAKMP_SIG_SZ + datalen);
  if (!buf)
    {
      /* XXX Log?  */
      free (data);
      return -1;
    }
  memmove (buf + ISAKMP_SIG_SZ, buf, datalen);

  snprintf (header, 80, "rsa_sig_encode_hash: SIG_%c", initiator ? 'I' : 'R');
  log_debug_buf (LOG_MISC, 80, header, buf + ISAKMP_SIG_DATA_OFF, datalen);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_SIG, buf,
			   ISAKMP_SIG_SZ + datalen, 1))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: ike_auth.c,v 1.20 1998/08/26 14:25:34 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
