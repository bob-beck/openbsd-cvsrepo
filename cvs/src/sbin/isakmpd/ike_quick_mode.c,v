head	1.110;
access;
symbols
	OPENBSD_6_1_BASE:1.110
	OPENBSD_6_0:1.110.0.4
	OPENBSD_6_0_BASE:1.110
	OPENBSD_5_9:1.110.0.2
	OPENBSD_5_9_BASE:1.110
	OPENBSD_5_8:1.108.0.6
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.108.0.2
	OPENBSD_5_7_BASE:1.108
	OPENBSD_5_6:1.107.0.14
	OPENBSD_5_6_BASE:1.107
	OPENBSD_5_5:1.107.0.12
	OPENBSD_5_5_BASE:1.107
	OPENBSD_5_4:1.107.0.8
	OPENBSD_5_4_BASE:1.107
	OPENBSD_5_3:1.107.0.6
	OPENBSD_5_3_BASE:1.107
	OPENBSD_5_2:1.107.0.4
	OPENBSD_5_2_BASE:1.107
	OPENBSD_5_1_BASE:1.107
	OPENBSD_5_1:1.107.0.2
	OPENBSD_5_0:1.106.0.2
	OPENBSD_5_0_BASE:1.106
	OPENBSD_4_9:1.105.0.4
	OPENBSD_4_9_BASE:1.105
	OPENBSD_4_8:1.105.0.2
	OPENBSD_4_8_BASE:1.105
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.102.0.6
	OPENBSD_4_6_BASE:1.102
	OPENBSD_4_5:1.102.0.2
	OPENBSD_4_5_BASE:1.102
	OPENBSD_4_4:1.101.0.6
	OPENBSD_4_4_BASE:1.101
	OPENBSD_4_3:1.101.0.4
	OPENBSD_4_3_BASE:1.101
	OPENBSD_4_2:1.101.0.2
	OPENBSD_4_2_BASE:1.101
	OPENBSD_4_1:1.99.0.4
	OPENBSD_4_1_BASE:1.99
	OPENBSD_4_0:1.99.0.2
	OPENBSD_4_0_BASE:1.99
	OPENBSD_3_9:1.97.0.2
	OPENBSD_3_9_BASE:1.97
	OPENBSD_3_8:1.96.0.2
	OPENBSD_3_8_BASE:1.96
	OPENBSD_3_7:1.89.0.2
	OPENBSD_3_7_BASE:1.89
	OPENBSD_3_6:1.86.0.2
	OPENBSD_3_6_BASE:1.86
	OPENBSD_3_5:1.75.0.2
	OPENBSD_3_5_BASE:1.75
	OPENBSD_3_4:1.70.0.2
	OPENBSD_3_4_BASE:1.70
	OPENBSD_3_3:1.67.0.4
	OPENBSD_3_3_BASE:1.67
	OPENBSD_3_2:1.67.0.2
	OPENBSD_3_2_BASE:1.67
	OPENBSD_3_1:1.59.0.2
	OPENBSD_3_1_BASE:1.59
	OPENBSD_3_0:1.55.0.2
	OPENBSD_3_0_BASE:1.55
	OPENBSD_2_9:1.47.0.2
	OPENBSD_2_9_BASE:1.47
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.110
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.109;
commitid	82PdNqu2kKAuXPfA;

1.109
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	0qPuuXwccpVXsXcV;

1.108
date	2014.10.09.02.38.56;	author deraadt;	state Exp;
branches;
next	1.107;
commitid	lHB12E9VkXKsWY0B;

1.107
date	2011.12.12.07.35.29;	author yasuoka;	state Exp;
branches;
next	1.106;

1.106
date	2011.04.23.03.17.04;	author lum;	state Exp;
branches;
next	1.105;

1.105
date	2010.06.29.19.50.16;	author reyk;	state Exp;
branches;
next	1.104;

1.104
date	2010.03.04.13.55.28;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2009.11.13.22.07.59;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2008.11.11.15.11.28;	author hshoexer;	state Exp;
branches;
next	1.101;

1.101
date	2007.08.15.21.05.45;	author hshoexer;	state Exp;
branches;
next	1.100;

1.100
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.99;

1.99
date	2006.06.10.21.09.45;	author msf;	state Exp;
branches;
next	1.98;

1.98
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2005.05.26.06.11.09;	author hshoexer;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.94;

1.94
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.91;

1.91
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2005.03.22.12.43.39;	author hshoexer;	state Exp;
branches;
next	1.89;

1.89
date	2005.03.05.12.32.58;	author ho;	state Exp;
branches;
next	1.88;

1.88
date	2005.02.10.13.01.01;	author ho;	state Exp;
branches;
next	1.87;

1.87
date	2004.09.17.13.53.08;	author ho;	state Exp;
branches;
next	1.86;

1.86
date	2004.08.14.13.29.50;	author hshoexer;	state Exp;
branches;
next	1.85;

1.85
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.25.20.25.34;	author hshoexer;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.20.17.17.35;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2004.06.15.15.53.13;	author hshoexer;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.10.12.54.53;	author hshoexer;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.28.20.20.31;	author hshoexer;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.27.10.16.26;	author ho;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2004.02.27.09.01.18;	author ho;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.20.11.31.10;	author hshoexer;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.20.09.46.56;	author hshoexer;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.16.10.51.57;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2003.06.04.07.31.16;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches
	1.67.4.1;
next	1.66;

1.66
date	2002.06.14.12.43.11;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.11.18.56.07;	author ho;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.10.20.45.35;	author ho;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.07.21.59.22;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.06.09.43.08;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2002.01.23.18.44.47;	author ho;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.23.17.16.42;	author ho;	state Exp;
branches;
next	1.56;

1.56
date	2001.10.26.12.03.07;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.05.05.57.06;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.15.13.06.53;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.01.20.11.53;	author niklas;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.29.18.52.16;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.29.17.59.34;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.27.00.16.30;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.07.04.45.42;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.31.20.27.50;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.04.09.12.34.37;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.13.14.05.18;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.19.16.58.04;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.08.22.37.34;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.27.12.03.33;	author niklas;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.26.12.12.51;	author niklas;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.26.11.08.43;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.14.23.09.11;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.10.18.16.26;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.10.16.23.29.07;	author niklas;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.10.07.07.01.19;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2000.08.03.07.23.44;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.08.20.50.16;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2000.04.07.22.05.19;	author niklas;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.02.25.17.22.22;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.02.19.19.31.32;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.12.09.21.23;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.11.10.21.28;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.07.01.32.54;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.01.02.46.17;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.31.08.38.28;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.30.21.01.49;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.30.20.52.20;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.26.15.22.02;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	99.10.26.22.32.28;	author angelos;	state Exp;
branches;
next	1.22;

1.22
date	99.10.01.14.07.16;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.08.26.22.30.21;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.08.05.22.42.04;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.07.07.22.09.54;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.06.05.23.09.21;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.06.02.06.30.39;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.05.02.19.20.32;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.04.30.11.46.24;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.27.21.04.07;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.19.21.22.49;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.04.06.17.08.53;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.04.05.20.58.52;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.04.03.09.14.52;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.31.20.29.57;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.03.31.14.28.34;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.03.31.00.50.21;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.02.26.03.42.30;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.12.21.01.02.24;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.20.07.37.44;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2000.06.10.17.22.57;	author jason;	state Exp;
branches;
next	;

1.38.2.1
date	2001.05.08.12.45.23;	author ho;	state Exp;
branches;
next	;

1.67.4.1
date	2004.03.17.15.05.03;	author brad;	state Exp;
branches;
next	;

1.70.2.1
date	2004.03.17.14.59.17;	author brad;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2004.06.11.03.08.02;	author brad;	state Exp;
branches;
next	;

1.75.2.1
date	2004.06.11.02.34.56;	author brad;	state Exp;
branches;
next	;


desc
@@


1.110
log
@Remove NULL-checks before free(). ok tb@@
@
text
@/* $OpenBSD: ike_quick_mode.c,v 1.109 2015/08/20 22:02:21 deraadt Exp $	 */
/* $EOM: ike_quick_mode.c,v 1.139 2001/01/26 10:43:17 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2000, 2001, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <stdlib.h>
#include <string.h>

#include <sys/types.h>
#include <regex.h>
#include <keynote.h>

#include "attribute.h"
#include "conf.h"
#include "connection.h"
#include "dh.h"
#include "doi.h"
#include "exchange.h"
#include "hash.h"
#include "ike_quick_mode.h"
#include "ipsec.h"
#include "log.h"
#include "message.h"
#include "policy.h"
#include "prf.h"
#include "sa.h"
#include "transport.h"
#include "util.h"
#include "key.h"
#include "x509.h"

static void     gen_g_xy(struct message *);
static int      initiator_send_HASH_SA_NONCE(struct message *);
static int      initiator_recv_HASH_SA_NONCE(struct message *);
static int      initiator_send_HASH(struct message *);
static void     post_quick_mode(struct message *);
static int      responder_recv_HASH_SA_NONCE(struct message *);
static int      responder_send_HASH_SA_NONCE(struct message *);
static int      responder_recv_HASH(struct message *);

static int      check_policy(struct exchange *, struct sa *, struct sa *);

int	(*ike_quick_mode_initiator[])(struct message *) = {
	initiator_send_HASH_SA_NONCE,
	initiator_recv_HASH_SA_NONCE,
	initiator_send_HASH
};

int	(*ike_quick_mode_responder[])(struct message *) = {
	responder_recv_HASH_SA_NONCE,
	responder_send_HASH_SA_NONCE,
	responder_recv_HASH
};

/* How many return values will policy handle -- true/false for now */
#define RETVALUES_NUM 2

/*
 * Given an exchange and our policy, check whether the SA and IDs are
 * acceptable.
 */
static int
check_policy(struct exchange *exchange, struct sa *sa, struct sa *isakmp_sa)
{
	char           *return_values[RETVALUES_NUM];
	char          **principal = 0;
	int             i, len, result = 0, nprinc = 0;
	int            *x509_ids = 0, *keynote_ids = 0;
	unsigned char   hashbuf[20];	/* Set to the largest digest result */
	struct keynote_deckey dc;
	X509_NAME      *subject;

	/* Do we want to use keynote policies? */
	if (ignore_policy ||
	    strncmp("yes", conf_get_str("General", "Use-Keynote"), 3))
		return 1;

	/* Initialize if necessary -- e.g., if pre-shared key auth was used */
	if (isakmp_sa->policy_id < 0) {
		if ((isakmp_sa->policy_id = kn_init()) == -1) {
			log_print("check_policy: "
			    "failed to initialize policy session");
			return 0;
		}
	}
	/* Add the callback that will handle attributes.  */
	if (kn_add_action(isakmp_sa->policy_id, ".*", (char *)policy_callback,
	    ENVIRONMENT_FLAG_FUNC | ENVIRONMENT_FLAG_REGEX) == -1) {
		log_print("check_policy: "
		    "kn_add_action (%d, \".*\", %p, FUNC | REGEX) failed",
		    isakmp_sa->policy_id, policy_callback);
		kn_close(isakmp_sa->policy_id);
		isakmp_sa->policy_id = -1;
		return 0;
	}
	if (policy_asserts_num) {
		keynote_ids = calloc(policy_asserts_num, sizeof *keynote_ids);
		if (!keynote_ids) {
			log_error("check_policy: calloc (%d, %lu) failed",
			    policy_asserts_num,
			    (unsigned long)sizeof *keynote_ids);
			kn_close(isakmp_sa->policy_id);
			isakmp_sa->policy_id = -1;
			return 0;
		}
	}
	/* Add the policy assertions */
	for (i = 0; i < policy_asserts_num; i++)
		keynote_ids[i] = kn_add_assertion(isakmp_sa->policy_id,
		    policy_asserts[i],
		    strlen(policy_asserts[i]), ASSERT_FLAG_LOCAL);

	/* Initialize -- we'll let the callback do all the work.  */
	policy_exchange = exchange;
	policy_sa = sa;
	policy_isakmp_sa = isakmp_sa;

	/* Set the return values; true/false for now at least.  */
	return_values[0] = "false";	/* Order of values in array is
					 * important.  */
	return_values[1] = "true";

	/* Create a principal (authorizer) for the SA/ID request.  */
	switch (isakmp_sa->recv_certtype) {
	case ISAKMP_CERTENC_NONE:
		/*
		 * For shared keys, just duplicate the passphrase with the
		 * appropriate prefix tag.
		 */
		nprinc = 3;
		principal = calloc(nprinc, sizeof *principal);
		if (!principal) {
			log_error("check_policy: calloc (%d, %lu) failed",
			    nprinc, (unsigned long)sizeof *principal);
			goto policydone;
		}
		len = strlen(isakmp_sa->recv_key) + sizeof "passphrase:";
		principal[0] = calloc(len, sizeof(char));
		if (!principal[0]) {
			log_error("check_policy: calloc (%d, %lu) failed", len,
			    (unsigned long)sizeof(char));
			goto policydone;
		}
		/*
		 * XXX Consider changing the magic hash lengths with
		 * constants.
		 */
		strlcpy(principal[0], "passphrase:", len);
		memcpy(principal[0] + sizeof "passphrase:" - 1,
		    isakmp_sa->recv_key, strlen(isakmp_sa->recv_key));

		len = sizeof "passphrase-md5-hex:" + 2 * 16;
		principal[1] = calloc(len, sizeof(char));
		if (!principal[1]) {
			log_error("check_policy: calloc (%d, %lu) failed", len,
			    (unsigned long)sizeof(char));
			goto policydone;
		}
		strlcpy(principal[1], "passphrase-md5-hex:", len);
		MD5(isakmp_sa->recv_key, strlen(isakmp_sa->recv_key), hashbuf);
		for (i = 0; i < 16; i++)
			snprintf(principal[1] + 2 * i +
			    sizeof "passphrase-md5-hex:" - 1, 3, "%02x",
			    hashbuf[i]);

		len = sizeof "passphrase-sha1-hex:" + 2 * 20;
		principal[2] = calloc(len, sizeof(char));
		if (!principal[2]) {
			log_error("check_policy: calloc (%d, %lu) failed", len,
			    (unsigned long)sizeof(char));
			goto policydone;
		}
		strlcpy(principal[2], "passphrase-sha1-hex:", len);
		SHA1(isakmp_sa->recv_key, strlen(isakmp_sa->recv_key),
		    hashbuf);
		for (i = 0; i < 20; i++)
			snprintf(principal[2] + 2 * i +
			    sizeof "passphrase-sha1-hex:" - 1, 3, "%02x",
			    hashbuf[i]);
		break;

	case ISAKMP_CERTENC_KEYNOTE:
		nprinc = 1;

		principal = calloc(nprinc, sizeof *principal);
		if (!principal) {
			log_error("check_policy: calloc (%d, %lu) failed",
			    nprinc, (unsigned long)sizeof *principal);
			goto policydone;
		}
		/* Dup the keys */
		principal[0] = strdup(isakmp_sa->keynote_key);
		if (!principal[0]) {
			log_error("check_policy: calloc (%lu, %lu) failed",
			    (unsigned long)strlen(isakmp_sa->keynote_key),
			    (unsigned long)sizeof(char));
			goto policydone;
		}
		break;

	case ISAKMP_CERTENC_X509_SIG:
		principal = calloc(2, sizeof *principal);
		if (!principal) {
			log_error("check_policy: calloc (2, %lu) failed",
			    (unsigned long)sizeof *principal);
			goto policydone;
		}
		if (isakmp_sa->recv_keytype == ISAKMP_KEY_RSA)
			dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
		else {
			log_error("check_policy: "
			    "unknown/unsupported public key algorithm %d",
			    isakmp_sa->recv_keytype);
			goto policydone;
		}

		dc.dec_key = isakmp_sa->recv_key;
		principal[0] = kn_encode_key(&dc, INTERNAL_ENC_PKCS1,
		    ENCODING_HEX, KEYNOTE_PUBLIC_KEY);
		if (keynote_errno == ERROR_MEMORY) {
			log_print("check_policy: "
			    "failed to get memory for public key");
			goto policydone;
		}
		if (!principal[0]) {
			log_print("check_policy: "
			    "failed to allocate memory for principal");
			goto policydone;
		}
		if (asprintf(&principal[1], "rsa-hex:%s", principal[0]) == -1) {
			log_error("check_policy: asprintf() failed");
			goto policydone;
		}
		free(principal[0]);
		principal[0] = principal[1];
		principal[1] = 0;

		/* Generate a "DN:" principal.  */
		subject = X509_get_subject_name(isakmp_sa->recv_cert);
		if (subject) {
			principal[1] = calloc(259, sizeof(char));
			if (!principal[1]) {
				log_error("check_policy: "
				    "calloc (259, %lu) failed",
				    (unsigned long)sizeof(char));
				goto policydone;
			}
			strlcpy(principal[1], "DN:", 259);
			X509_NAME_oneline(subject, principal[1] + 3, 256);
			nprinc = 2;
		} else {
			nprinc = 1;
		}
		break;

		/* XXX Eventually handle these.  */
	case ISAKMP_CERTENC_PKCS:
	case ISAKMP_CERTENC_PGP:
	case ISAKMP_CERTENC_DNS:
	case ISAKMP_CERTENC_X509_KE:
	case ISAKMP_CERTENC_KERBEROS:
	case ISAKMP_CERTENC_CRL:
	case ISAKMP_CERTENC_ARL:
	case ISAKMP_CERTENC_SPKI:
	case ISAKMP_CERTENC_X509_ATTR:
	default:
		log_print("check_policy: "
		    "unknown/unsupported certificate/authentication method %d",
		    isakmp_sa->recv_certtype);
		goto policydone;
	}

	/*
	 * Add the authorizer (who is requesting the SA/ID);
	 * this may be a public or a secret key, depending on
	 * what mode of authentication we used in Phase 1.
         */
	for (i = 0; i < nprinc; i++) {
		LOG_DBG((LOG_POLICY, 40, "check_policy: "
		    "adding authorizer [%s]", principal[i]));

		if (kn_add_authorizer(isakmp_sa->policy_id, principal[i])
		    == -1) {
			int	j;

			for (j = 0; j < i; j++)
				kn_remove_authorizer(isakmp_sa->policy_id,
				    principal[j]);
			log_print("check_policy: kn_add_authorizer failed");
			goto policydone;
		}
	}

	/* Ask policy */
	result = kn_do_query(isakmp_sa->policy_id, return_values,
	    RETVALUES_NUM);
	LOG_DBG((LOG_POLICY, 40, "check_policy: kn_do_query returned %d",
	    result));

	/* Cleanup environment */
	kn_cleanup_action_environment(isakmp_sa->policy_id);

	/* Remove authorizers from the session */
	for (i = 0; i < nprinc; i++) {
		kn_remove_authorizer(isakmp_sa->policy_id, principal[i]);
		free(principal[i]);
	}

	free(principal);
	principal = 0;
	nprinc = 0;

	/* Check what policy said.  */
	if (result < 0) {
		LOG_DBG((LOG_POLICY, 40, "check_policy: proposal refused"));
		result = 0;
		goto policydone;
	}
policydone:
	for (i = 0; i < nprinc; i++)
		if (principal && principal[i])
			free(principal[i]);

	free(principal);

	/* Remove the policies */
	for (i = 0; i < policy_asserts_num; i++) {
		if (keynote_ids[i] != -1)
			kn_remove_assertion(isakmp_sa->policy_id,
			    keynote_ids[i]);
	}

	free(keynote_ids);

	free(x509_ids);

	/*
	 * XXX Currently, check_policy() is only called from
	 * message_negotiate_sa(), and so this log message reflects this.
	 * Change to something better?
         */
	if (result == 0)
		log_print("check_policy: negotiated SA failed policy check");

	/*
	 * Given that we have only 2 return values from policy (true/false)
	 * we can just return the query result directly (no pre-processing
	 * needed).
         */
	return result;
}

/*
 * Offer several sets of transforms to the responder.
 * XXX Split this huge function up and look for common code with main mode.
 */
static int
initiator_send_HASH_SA_NONCE(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct doi     *doi = exchange->doi;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t     ***transform = 0, ***new_transform;
	u_int8_t      **proposal = 0, **new_proposal;
	u_int8_t       *sa_buf = 0, *attr, *saved_nextp_sa, *saved_nextp_prop,
	               *id, *spi;
	size_t          spi_sz, sz;
	size_t          proposal_len = 0, proposals_len = 0, sa_len;
	size_t        **transform_len = 0, **new_transform_len;
	size_t         *transforms_len = 0, *new_transforms_len;
	u_int32_t      *transform_cnt = 0, *new_transform_cnt;
	u_int32_t       suite_no, prop_no, prot_no, xf_no, prop_cnt = 0;
	u_int32_t       i;
	int             value, update_nextp, protocol_num, proto_id;
	struct proto   *proto;
	struct conf_list *suite_conf, *prot_conf = 0, *xf_conf = 0, *life_conf;
	struct conf_list_node *suite, *prot, *xf, *life;
	struct constant_map *id_map;
	char           *protocol_id, *transform_id;
	char           *local_id, *remote_id;
	int             group_desc = -1, new_group_desc;
	struct ipsec_sa *isa = msg->isakmp_sa->data;
	struct hash    *hash = hash_get(isa->hash);
	struct sockaddr *src;
	struct proto_attr *pa;

	if (!ipsec_add_hash_payload(msg, hash->hashsize))
		return -1;

	/* Get the list of protocol suites.  */
	suite_conf = conf_get_list(exchange->policy, "Suites");
	if (!suite_conf)
		return -1;

	for (suite = TAILQ_FIRST(&suite_conf->fields), suite_no = prop_no = 0;
	    suite_no < suite_conf->cnt;
	    suite_no++, suite = TAILQ_NEXT(suite, link)) {
		/* Now get each protocol in this specific protocol suite.  */
		prot_conf = conf_get_list(suite->field, "Protocols");
		if (!prot_conf)
			goto bail_out;

		for (prot = TAILQ_FIRST(&prot_conf->fields), prot_no = 0;
		    prot_no < prot_conf->cnt;
		    prot_no++, prot = TAILQ_NEXT(prot, link)) {
			/* Make sure we have a proposal/transform vectors.  */
			if (prop_no >= prop_cnt) {
				/*
				 * This resize algorithm is completely
				 * arbitrary.
				 */
				prop_cnt = 2 * prop_cnt + 10;
				new_proposal = reallocarray(proposal,
				    prop_cnt, sizeof *proposal);
				if (!new_proposal) {
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "realloc (%p, %lu) failed",
					    proposal,
					    prop_cnt * (unsigned long)sizeof *proposal);
					goto bail_out;
				}
				proposal = new_proposal;

				new_transforms_len = reallocarray(transforms_len,
				    prop_cnt, sizeof *transforms_len);
				if (!new_transforms_len) {
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "realloc (%p, %lu) failed",
					    transforms_len,
					    prop_cnt * (unsigned long)sizeof *transforms_len);
					goto bail_out;
				}
				transforms_len = new_transforms_len;

				new_transform = reallocarray(transform,
				    prop_cnt, sizeof *transform);
				if (!new_transform) {
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "realloc (%p, %lu) failed",
					    transform,
					    prop_cnt * (unsigned long)sizeof *transform);
					goto bail_out;
				}
				transform = new_transform;

				new_transform_cnt = reallocarray(transform_cnt,
				    prop_cnt, sizeof *transform_cnt);
				if (!new_transform_cnt) {
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "realloc (%p, %lu) failed",
					    transform_cnt,
					    prop_cnt * (unsigned long)sizeof *transform_cnt);
					goto bail_out;
				}
				transform_cnt = new_transform_cnt;

				new_transform_len = reallocarray(transform_len,
				    prop_cnt, sizeof *transform_len);
				if (!new_transform_len) {
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "realloc (%p, %lu) failed",
					    transform_len,
					    prop_cnt * (unsigned long)sizeof *transform_len);
					goto bail_out;
				}
				transform_len = new_transform_len;
			}
			protocol_id = conf_get_str(prot->field, "PROTOCOL_ID");
			if (!protocol_id)
				goto bail_out;

			proto_id = constant_value(ipsec_proto_cst,
			    protocol_id);
			switch (proto_id) {
			case IPSEC_PROTO_IPSEC_AH:
				id_map = ipsec_ah_cst;
				break;

			case IPSEC_PROTO_IPSEC_ESP:
				id_map = ipsec_esp_cst;
				break;

			case IPSEC_PROTO_IPCOMP:
				id_map = ipsec_ipcomp_cst;
				break;

			default:
			    {
				log_print("initiator_send_HASH_SA_NONCE: "
				    "invalid PROTCOL_ID: %s", protocol_id);
				goto bail_out;
			    }
			}

			/* Now get each transform we offer for this protocol.*/
			xf_conf = conf_get_list(prot->field, "Transforms");
			if (!xf_conf)
				goto bail_out;
			transform_cnt[prop_no] = xf_conf->cnt;

			transform[prop_no] = calloc(transform_cnt[prop_no],
			    sizeof **transform);
			if (!transform[prop_no]) {
				log_error("initiator_send_HASH_SA_NONCE: "
				    "calloc (%d, %lu) failed",
				    transform_cnt[prop_no],
				    (unsigned long)sizeof **transform);
				goto bail_out;
			}
			transform_len[prop_no] = calloc(transform_cnt[prop_no],
			    sizeof **transform_len);
			if (!transform_len[prop_no]) {
				log_error("initiator_send_HASH_SA_NONCE: "
				    "calloc (%d, %lu) failed",
				    transform_cnt[prop_no],
				    (unsigned long)sizeof **transform_len);
				goto bail_out;
			}
			transforms_len[prop_no] = 0;
			for (xf = TAILQ_FIRST(&xf_conf->fields), xf_no = 0;
			    xf_no < transform_cnt[prop_no];
			    xf_no++, xf = TAILQ_NEXT(xf, link)) {

				/* XXX The sizing needs to be dynamic.  */
				transform[prop_no][xf_no] =
				    calloc(ISAKMP_TRANSFORM_SA_ATTRS_OFF +
				    9 * ISAKMP_ATTR_VALUE_OFF, 1);
				if (!transform[prop_no][xf_no]) {
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "calloc (%d, 1) failed",
					    ISAKMP_TRANSFORM_SA_ATTRS_OFF +
					    9 * ISAKMP_ATTR_VALUE_OFF);
					goto bail_out;
				}
				SET_ISAKMP_TRANSFORM_NO(transform[prop_no][xf_no],
				    xf_no + 1);

				transform_id = conf_get_str(xf->field,
				    "TRANSFORM_ID");
				if (!transform_id)
					goto bail_out;
				SET_ISAKMP_TRANSFORM_ID(transform[prop_no][xf_no],
				    constant_value(id_map, transform_id));
				SET_ISAKMP_TRANSFORM_RESERVED(transform[prop_no][xf_no], 0);

				attr = transform[prop_no][xf_no] +
				    ISAKMP_TRANSFORM_SA_ATTRS_OFF;

				/*
				 * Life durations are special, we should be
				 * able to specify several, one per type.
				 */
				life_conf = conf_get_list(xf->field, "Life");
				if (life_conf) {
					for (life = TAILQ_FIRST(&life_conf->fields);
					    life; life = TAILQ_NEXT(life, link)) {
						attribute_set_constant(
						    life->field, "LIFE_TYPE",
						    ipsec_duration_cst,
						    IPSEC_ATTR_SA_LIFE_TYPE,
						    &attr);

						/*
						 * XXX Deals with 16 and 32
						 * bit lifetimes only
						 */
						value =
						    conf_get_num(life->field,
							"LIFE_DURATION", 0);
						if (value) {
							if (value <= 0xffff)
								attr =
								    attribute_set_basic(
									attr,
									IPSEC_ATTR_SA_LIFE_DURATION,
									value);
							else {
								value = htonl(value);
								attr =
								    attribute_set_var(
									attr,
									IPSEC_ATTR_SA_LIFE_DURATION,
									(u_int8_t *)&value,
									sizeof value);
							}
						}
					}
					conf_free_list(life_conf);
				}
				attribute_set_constant(xf->field,
				    "ENCAPSULATION_MODE", ipsec_encap_cst,
				    IPSEC_ATTR_ENCAPSULATION_MODE, &attr);

				if (proto_id != IPSEC_PROTO_IPCOMP) {
					attribute_set_constant(xf->field,
					    "AUTHENTICATION_ALGORITHM",
					    ipsec_auth_cst,
					    IPSEC_ATTR_AUTHENTICATION_ALGORITHM,
					    &attr);

					attribute_set_constant(xf->field,
					    "GROUP_DESCRIPTION",
					    ike_group_desc_cst,
					    IPSEC_ATTR_GROUP_DESCRIPTION, &attr);

					value = conf_get_num(xf->field,
					    "KEY_LENGTH", 0);
					if (value)
						attr = attribute_set_basic(
						    attr,
						    IPSEC_ATTR_KEY_LENGTH,
						    value);

					value = conf_get_num(xf->field,
					    "KEY_ROUNDS", 0);
					if (value)
						attr = attribute_set_basic(
						    attr,
						    IPSEC_ATTR_KEY_ROUNDS,
						    value);
				} else {
					value = conf_get_num(xf->field,
					    "COMPRESS_DICTIONARY_SIZE", 0);
					if (value)
						attr = attribute_set_basic(
						    attr,
						    IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE,
						    value);

					value = conf_get_num(xf->field,
					   "COMPRESS_PRIVATE_ALGORITHM", 0);
					if (value)
						attr = attribute_set_basic(
						    attr,
						    IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM,
						    value);
				}

				value = conf_get_num(xf->field, "ECN_TUNNEL",
				    0);
				if (value)
					attr = attribute_set_basic(attr,
					    IPSEC_ATTR_ECN_TUNNEL, value);

				/* Record the real transform size.  */
				transforms_len[prop_no] +=
				    (transform_len[prop_no][xf_no]
					= attr - transform[prop_no][xf_no]);

				if (proto_id != IPSEC_PROTO_IPCOMP) {
					/*
					 * Make sure that if a group
					 * description is specified, it is
					 * specified for all transforms
					 * equally.
					 */
					attr =
					    (u_int8_t *)conf_get_str(xf->field,
						"GROUP_DESCRIPTION");
					new_group_desc
					    = attr ? constant_value(ike_group_desc_cst,
						(char *)attr) : 0;
					if (group_desc == -1)
						group_desc = new_group_desc;
					else if (group_desc != new_group_desc) {
						log_print("initiator_send_HASH_SA_NONCE: "
						    "differing group descriptions in a proposal");
						goto bail_out;
					}
				}
			}
			conf_free_list(xf_conf);
			xf_conf = 0;

			/*
			 * Get SPI from application.
			 * XXX Should we care about unknown constants?
			 */
			protocol_num = constant_value(ipsec_proto_cst,
			    protocol_id);
			spi = doi->get_spi(&spi_sz, protocol_num, msg);
			if (spi_sz && !spi) {
				log_print("initiator_send_HASH_SA_NONCE: "
				    "doi->get_spi failed");
				goto bail_out;
			}
			proposal_len = ISAKMP_PROP_SPI_OFF + spi_sz;
			proposals_len +=
			    proposal_len + transforms_len[prop_no];
			proposal[prop_no] = malloc(proposal_len);
			if (!proposal[prop_no]) {
				log_error("initiator_send_HASH_SA_NONCE: "
				    "malloc (%lu) failed",
				    (unsigned long)proposal_len);
				goto bail_out;
			}
			SET_ISAKMP_PROP_NO(proposal[prop_no], suite_no + 1);
			SET_ISAKMP_PROP_PROTO(proposal[prop_no], protocol_num);

			/* XXX I would like to see this factored out.  */
			proto = calloc(1, sizeof *proto);
			if (!proto) {
				log_error("initiator_send_HASH_SA_NONCE: "
				    "calloc (1, %lu) failed",
				    (unsigned long)sizeof *proto);
				goto bail_out;
			}
			if (doi->proto_size) {
				proto->data = calloc(1, doi->proto_size);
				if (!proto->data) {
					free(proto);
					log_error(
					    "initiator_send_HASH_SA_NONCE: "
					    "calloc (1, %lu) failed",
					    (unsigned long)doi->proto_size);
					goto bail_out;
				}
			}
			proto->no = suite_no + 1;
			proto->proto = protocol_num;
			proto->sa = TAILQ_FIRST(&exchange->sa_list);
			proto->xf_cnt = transform_cnt[prop_no];
			TAILQ_INIT(&proto->xfs);
			for (xf_no = 0; xf_no < proto->xf_cnt; xf_no++) {
				pa = calloc(1, sizeof *pa);
				if (!pa) {
					free(proto->data);
					free(proto);
					goto bail_out;
				}
				pa->len = transform_len[prop_no][xf_no];
				pa->attrs = malloc(pa->len);
				if (!pa->attrs) {
					free(proto->data);
					free(proto);
					free(pa);
					goto bail_out;
				}
				memcpy(pa->attrs, transform[prop_no][xf_no],
				    pa->len);
				TAILQ_INSERT_TAIL(&proto->xfs, pa, next);
			}
			TAILQ_INSERT_TAIL(&TAILQ_FIRST(&exchange->sa_list)->protos,
			    proto, link);

			/* Setup the incoming SPI.  */
			SET_ISAKMP_PROP_SPI_SZ(proposal[prop_no], spi_sz);
			memcpy(proposal[prop_no] + ISAKMP_PROP_SPI_OFF, spi,
			    spi_sz);
			proto->spi_sz[1] = spi_sz;
			proto->spi[1] = spi;

			/*
			 * Let the DOI get at proto for initializing its own
			 * data.
			 */
			if (doi->proto_init)
				doi->proto_init(proto, prot->field);

			SET_ISAKMP_PROP_NTRANSFORMS(proposal[prop_no],
						    transform_cnt[prop_no]);
			prop_no++;
		}
		conf_free_list(prot_conf);
		prot_conf = 0;
	}

	sa_len = ISAKMP_SA_SIT_OFF + IPSEC_SIT_SIT_LEN;
	sa_buf = malloc(sa_len);
	if (!sa_buf) {
		log_error("initiator_send_HASH_SA_NONCE: malloc (%lu) failed",
			  (unsigned long)sa_len);
		goto bail_out;
	}
	SET_ISAKMP_SA_DOI(sa_buf, IPSEC_DOI_IPSEC);
	SET_IPSEC_SIT_SIT(sa_buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);

	/*
	 * Add the payloads.  As this is a SA, we need to recompute the
	 * lengths of the payloads containing others.  We also need to
	 * reset these payload's "next payload type" field.
         */
	if (message_add_payload(msg, ISAKMP_PAYLOAD_SA, sa_buf, sa_len, 1))
		goto bail_out;
	SET_ISAKMP_GEN_LENGTH(sa_buf, sa_len + proposals_len);
	sa_buf = 0;

	update_nextp = 0;
	saved_nextp_sa = msg->nextp;
	for (i = 0; i < prop_no; i++) {
		if (message_add_payload(msg, ISAKMP_PAYLOAD_PROPOSAL,
		    proposal[i], proposal_len, update_nextp))
			goto bail_out;
		SET_ISAKMP_GEN_LENGTH(proposal[i],
		    proposal_len + transforms_len[i]);
		proposal[i] = 0;

		update_nextp = 0;
		saved_nextp_prop = msg->nextp;
		for (xf_no = 0; xf_no < transform_cnt[i]; xf_no++) {
			if (message_add_payload(msg, ISAKMP_PAYLOAD_TRANSFORM,
			    transform[i][xf_no],
			    transform_len[i][xf_no], update_nextp))
				goto bail_out;
			update_nextp = 1;
			transform[i][xf_no] = 0;
		}
		msg->nextp = saved_nextp_prop;
		update_nextp = 1;
	}
	msg->nextp = saved_nextp_sa;

	/*
	 * Save SA payload body in ie->sa_i_b, length ie->sa_i_b_len.
         */
	ie->sa_i_b = message_copy(msg, ISAKMP_GEN_SZ, &ie->sa_i_b_len);
	if (!ie->sa_i_b)
		goto bail_out;

	/*
	 * Generate a nonce, and add it to the message.
	 * XXX I want a better way to specify the nonce's size.
         */
	if (exchange_gen_nonce(msg, 16))
		return -1;

	/* Generate optional KEY_EXCH payload.  */
	if (group_desc > 0) {
		ie->group = group_get(group_desc);
		ie->g_x_len = dh_getlen(ie->group);

		if (ipsec_gen_g_x(msg)) {
			group_free(ie->group);
			ie->group = 0;
			return -1;
		}
	}
	/* Generate optional client ID payloads.  XXX Share with responder.  */
	local_id = conf_get_str(exchange->name, "Local-ID");
	remote_id = conf_get_str(exchange->name, "Remote-ID");
	if (local_id && remote_id) {
		id = ipsec_build_id(local_id, &sz);
		if (!id)
			return -1;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "initiator_send_HASH_SA_NONCE: IDic", id, sz));
		if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, id, sz, 1)) {
			free(id);
			return -1;
		}
		id = ipsec_build_id(remote_id, &sz);
		if (!id)
			return -1;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "initiator_send_HASH_SA_NONCE: IDrc", id, sz));
		if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, id, sz, 1)) {
			free(id);
			return -1;
		}
	}
	/* XXX I do not judge these as errors, are they?  */
	else if (local_id)
		log_print("initiator_send_HASH_SA_NONCE: "
			  "Local-ID given without Remote-ID for \"%s\"",
			  exchange->name);
	else if (remote_id)
		/*
		 * This code supports the "road warrior" case, where the
		 * initiator doesn't have a fixed IP address, but wants to
		 * specify a particular remote network to talk to. -- Adrian
		 * Close <adrian@@esec.com.au>
		 */
	{
		log_print("initiator_send_HASH_SA_NONCE: "
			  "Remote-ID given without Local-ID for \"%s\"",
			  exchange->name);

		/*
		 * If we're here, then we are the initiator, so use initiator
		 * address for local ID
		 */
		msg->transport->vtbl->get_src(msg->transport, &src);
		sz = ISAKMP_ID_SZ + sockaddr_addrlen(src);

		id = calloc(sz, sizeof(char));
		if (!id) {
			log_error("initiator_send_HASH_SA_NONCE: "
			    "calloc (%lu, %lu) failed", (unsigned long)sz,
			    (unsigned long)sizeof(char));
			return -1;
		}
		switch (src->sa_family) {
		case AF_INET6:
			SET_ISAKMP_ID_TYPE(id, IPSEC_ID_IPV6_ADDR);
			break;
		case AF_INET:
			SET_ISAKMP_ID_TYPE(id, IPSEC_ID_IPV4_ADDR);
			break;
		default:
			log_error("initiator_send_HASH_SA_NONCE: "
			    "unknown sa_family %d", src->sa_family);
			free(id);
			return -1;
		}
		memcpy(id + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(src),
		    sockaddr_addrlen(src));

		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "initiator_send_HASH_SA_NONCE: IDic", id, sz));
		if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, id, sz, 1)) {
			free(id);
			return -1;
		}
		/* Send supplied remote_id */
		id = ipsec_build_id(remote_id, &sz);
		if (!id)
			return -1;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "initiator_send_HASH_SA_NONCE: IDrc", id, sz));
		if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, id, sz, 1)) {
			free(id);
			return -1;
		}
	}
	if (ipsec_fill_in_hash(msg))
		goto bail_out;

	conf_free_list(suite_conf);
	for (i = 0; i < prop_no; i++) {
		free(transform[i]);
		free(transform_len[i]);
	}
	free(proposal);
	free(transform);
	free(transforms_len);
	free(transform_len);
	free(transform_cnt);
	return 0;

bail_out:
	free(sa_buf);
	if (proposal) {
		for (i = 0; i < prop_no; i++) {
			free(proposal[i]);
			if (transform[i]) {
				for (xf_no = 0; xf_no < transform_cnt[i];
				    xf_no++)
					free(transform[i][xf_no]);
				free(transform[i]);
			}
			free(transform_len[i]);
		}
		free(proposal);
		free(transforms_len);
		free(transform);
		free(transform_len);
		free(transform_cnt);
	}
	if (xf_conf)
		conf_free_list(xf_conf);
	if (prot_conf)
		conf_free_list(prot_conf);
	conf_free_list(suite_conf);
	return -1;
}

/* Figure out what transform the responder chose.  */
static int
initiator_recv_HASH_SA_NONCE(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct sa      *sa;
	struct proto   *proto, *next_proto;
	struct payload *sa_p = payload_first(msg, ISAKMP_PAYLOAD_SA);
	struct payload *xf, *idp;
	struct payload *hashp = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	struct payload *kep = payload_first(msg, ISAKMP_PAYLOAD_KEY_EXCH);
	struct prf     *prf;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct hash    *hash = hash_get(isa->hash);
	u_int8_t       *rest;
	size_t          rest_len;
	struct sockaddr *src, *dst;

	/* Allocate the prf and start calculating our HASH(1).  XXX Share?  */
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: "
	    "SKEYID_a", (u_int8_t *)isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		return -1;

	prf->Init(prf->prfctx);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "initiator_recv_HASH_SA_NONCE: message_id",
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: "
	    "NONCE_I_b", exchange->nonce_i, exchange->nonce_i_len));
	prf->Update(prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
	rest = hashp->p + GET_ISAKMP_GEN_LENGTH(hashp->p);
	rest_len = (GET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base)
	    - (rest - (u_int8_t *)msg->iov[0].iov_base));
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "initiator_recv_HASH_SA_NONCE: payloads after HASH(2)", rest,
	    rest_len));
	prf->Update(prf->prfctx, rest, rest_len);
	prf->Final(hash->digest, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_NEGOTIATION, 80,
	    "initiator_recv_HASH_SA_NONCE: computed HASH(2)", hash->digest,
	    hash->hashsize));
	if (memcmp(hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest,
	    hash->hashsize) != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1,
		    0);
		return -1;
	}
	/* Mark the HASH as handled.  */
	hashp->flags |= PL_MARK;

	/* Mark message as authenticated. */
	msg->flags |= MSG_AUTHENTICATED;

	/*
	 * As we are getting an answer on our transform offer, only one
	 * transform should be given.
         *
	 * XXX Currently we only support negotiating one SA per quick mode run.
         */
	if (TAILQ_NEXT(sa_p, link)) {
		log_print("initiator_recv_HASH_SA_NONCE: "
		    "multiple SA payloads in quick mode not supported yet");
		return -1;
	}
	sa = TAILQ_FIRST(&exchange->sa_list);

	/* This is here for the policy check */
	if (kep)
		ie->pfs = 1;

	/* Drop message when it contains ID types we do not implement yet.  */
	TAILQ_FOREACH(idp, &msg->payload[ISAKMP_PAYLOAD_ID], link) {
		switch (GET_ISAKMP_ID_TYPE(idp->p)) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV4_ADDR_SUBNET:
		case IPSEC_ID_IPV6_ADDR:
		case IPSEC_ID_IPV6_ADDR_SUBNET:
			break;

		case IPSEC_ID_FQDN:
			/*
			 * FQDN may be used for in NAT-T with transport mode.
			 * We can handle the message in this case.  In the
			 * other cases we'll drop the message later.
			 */
			break;

		default:
			message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION,
			    0, 1, 0);
			return -1;
		}
	}

	/* Handle optional client ID payloads.  */
	idp = payload_first(msg, ISAKMP_PAYLOAD_ID);
	if (idp) {
		/* If IDci is there, IDcr must be too.  */
		if (!TAILQ_NEXT(idp, link)) {
			/* XXX Is this a good notify type?  */
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0,
			    1, 0);
			return -1;
		}
		/* XXX We should really compare, not override.  */
		ie->id_ci_sz = GET_ISAKMP_GEN_LENGTH(idp->p);
		ie->id_ci = malloc(ie->id_ci_sz);
		if (!ie->id_ci) {
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "malloc (%lu) failed",
			    (unsigned long)ie->id_ci_sz);
			return -1;
		}
		memcpy(ie->id_ci, idp->p, ie->id_ci_sz);
		idp->flags |= PL_MARK;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "initiator_recv_HASH_SA_NONCE: IDci",
		    ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz - ISAKMP_GEN_SZ));

		idp = TAILQ_NEXT(idp, link);
		ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH(idp->p);
		ie->id_cr = malloc(ie->id_cr_sz);
		if (!ie->id_cr) {
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "malloc (%lu) failed",
			    (unsigned long)ie->id_cr_sz);
			return -1;
		}
		memcpy(ie->id_cr, idp->p, ie->id_cr_sz);
		idp->flags |= PL_MARK;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "initiator_recv_HASH_SA_NONCE: IDcr",
		    ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz - ISAKMP_GEN_SZ));
	} else {
		/*
		 * If client identifiers are not present in the exchange,
		 * we fake them. RFC 2409 states:
		 *    The identities of the SAs negotiated in Quick Mode are
		 *    implicitly assumed to be the IP addresses of the ISAKMP
		 *    peers, without any constraints on the protocol or port
		 *    numbers allowed, unless client identifiers are specified
		 *    in Quick Mode.
		 *
		 * -- Michael Paddon (mwp@@aba.net.au)
		 */

		ie->flags = IPSEC_EXCH_FLAG_NO_ID;

		/* Get initiator and responder addresses.  */
		msg->transport->vtbl->get_src(msg->transport, &src);
		msg->transport->vtbl->get_dst(msg->transport, &dst);
		ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen(src);
		ie->id_cr_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen(dst);
		ie->id_ci = calloc(ie->id_ci_sz, sizeof(char));
		ie->id_cr = calloc(ie->id_cr_sz, sizeof(char));

		if (!ie->id_ci || !ie->id_cr) {
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "calloc (%lu, %lu) failed",
			    (unsigned long)ie->id_cr_sz,
			    (unsigned long)sizeof(char));
			free(ie->id_ci);
			ie->id_ci = 0;
			free(ie->id_cr);
			ie->id_cr = 0;
			return -1;
		}
		if (src->sa_family != dst->sa_family) {
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "sa_family mismatch");
			free(ie->id_ci);
			ie->id_ci = 0;
			free(ie->id_cr);
			ie->id_cr = 0;
			return -1;
		}
		switch (src->sa_family) {
		case AF_INET:
			SET_ISAKMP_ID_TYPE(ie->id_ci, IPSEC_ID_IPV4_ADDR);
			SET_ISAKMP_ID_TYPE(ie->id_cr, IPSEC_ID_IPV4_ADDR);
			break;

		case AF_INET6:
			SET_ISAKMP_ID_TYPE(ie->id_ci, IPSEC_ID_IPV6_ADDR);
			SET_ISAKMP_ID_TYPE(ie->id_cr, IPSEC_ID_IPV6_ADDR);
			break;

		default:
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "unknown sa_family %d", src->sa_family);
			free(ie->id_ci);
			ie->id_ci = 0;
			free(ie->id_cr);
			ie->id_cr = 0;
			return -1;
		}
		memcpy(ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(src),
		    sockaddr_addrlen(src));
		memcpy(ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(dst),
		    sockaddr_addrlen(dst));
	}

	/* Build the protection suite in our SA.  */
	TAILQ_FOREACH(xf, &msg->payload[ISAKMP_PAYLOAD_TRANSFORM], link) {
		/*
		 * XXX We could check that the proposal each transform
		 * belongs to is unique.
		 */

		if (sa_add_transform(sa, xf, exchange->initiator, &proto))
			return -1;

		/* XXX Check that the chosen transform matches an offer.  */

		ipsec_decode_transform(msg, sa, proto, xf->p);
	}

	/* Now remove offers that we don't need anymore.  */
	for (proto = TAILQ_FIRST(&sa->protos); proto; proto = next_proto) {
		next_proto = TAILQ_NEXT(proto, link);
		if (!proto->chosen)
			proto_free(proto);
	}

	if (!check_policy(exchange, sa, msg->isakmp_sa)) {
		message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
		log_print("initiator_recv_HASH_SA_NONCE: policy check failed");
		return -1;
	}

	/* Mark the SA as handled.  */
	sa_p->flags |= PL_MARK;

	isa = sa->data;
	if ((isa->group_desc &&
	    (!ie->group || ie->group->id != isa->group_desc)) ||
	    (!isa->group_desc && ie->group)) {
		log_print("initiator_recv_HASH_SA_NONCE: disagreement on PFS");
		return -1;
	}
	/* Copy out the initiator's nonce.  */
	if (exchange_save_nonce(msg))
		return -1;

	/* Handle the optional KEY_EXCH payload.  */
	if (kep && ipsec_save_g_x(msg))
		return -1;

	return 0;
}

static int
initiator_send_HASH(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct prf     *prf;
	u_int8_t       *buf;
	struct hash    *hash = hash_get(isa->hash);

	/*
	 * We want a HASH payload to start with.  XXX Share with
	 * ike_main_mode.c?
	 */
	buf = malloc(ISAKMP_HASH_SZ + hash->hashsize);
	if (!buf) {
		log_error("initiator_send_HASH: malloc (%lu) failed",
		    ISAKMP_HASH_SZ + (unsigned long)hash->hashsize);
		return -1;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_HASH, buf,
	    ISAKMP_HASH_SZ + hash->hashsize, 1)) {
		free(buf);
		return -1;
	}
	/* Allocate the prf and start calculating our HASH(3).  XXX Share?  */
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH: SKEYID_a",
	    isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		return -1;
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, (unsigned char *)"\0", 1);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH: message_id",
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH: NONCE_I_b",
	    exchange->nonce_i, exchange->nonce_i_len));
	prf->Update(prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH: NONCE_R_b",
	    exchange->nonce_r, exchange->nonce_r_len));
	prf->Update(prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
	prf->Final(buf + ISAKMP_GEN_SZ, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH: HASH(3)",
	    buf + ISAKMP_GEN_SZ, hash->hashsize));

	if (ie->group)
		message_register_post_send(msg, gen_g_xy);

	message_register_post_send(msg, post_quick_mode);

	return 0;
}

static void
post_quick_mode(struct message *msg)
{
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct prf     *prf;
	struct sa      *sa;
	struct proto   *proto;
	struct ipsec_proto *iproto;
	u_int8_t       *keymat;
	int             i;

	/*
	 * Loop over all SA negotiations and do both an in- and an outgoing SA
	 * per protocol.
         */
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
	    sa = TAILQ_NEXT(sa, next)) {
		for (proto = TAILQ_FIRST(&sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link)) {
			if (proto->proto == IPSEC_PROTO_IPCOMP)
				continue;

			iproto = proto->data;

			/*
			 * There are two SAs for each SA negotiation,
			 * incoming and outgoing.
			 */
			for (i = 0; i < 2; i++) {
				prf = prf_alloc(isa->prf_type, isa->hash,
				    isa->skeyid_d, isa->skeyid_len);
				if (!prf) {
					/* XXX What to do?  */
					continue;
				}
				ie->keymat_len = ipsec_keymat_length(proto);

				/*
				 * We need to roundup the length of the key
				 * material buffer to a multiple of the PRF's
				 * blocksize as it is generated in chunks of
				 * that blocksize.
				 */
				iproto->keymat[i]
					= malloc(((ie->keymat_len + prf->blocksize - 1)
					/ prf->blocksize) * prf->blocksize);
				if (!iproto->keymat[i]) {
					log_error("post_quick_mode: "
					    "malloc (%lu) failed",
					    (((unsigned long)ie->keymat_len +
						prf->blocksize - 1) / prf->blocksize) *
					    prf->blocksize);
					/* XXX What more to do?  */
					free(prf);
					continue;
				}
				for (keymat = iproto->keymat[i];
				keymat < iproto->keymat[i] + ie->keymat_len;
				    keymat += prf->blocksize) {
					prf->Init(prf->prfctx);

					if (keymat != iproto->keymat[i]) {
						/*
						 * Hash in last round's
						 * KEYMAT.
						 */
						LOG_DBG_BUF((LOG_NEGOTIATION,
						    90, "post_quick_mode: "
						    "last KEYMAT",
						    keymat - prf->blocksize,
						    prf->blocksize));
						prf->Update(prf->prfctx,
						    keymat - prf->blocksize,
						    prf->blocksize);
					}
					/* If PFS is used hash in g^xy.  */
					if (ie->g_xy) {
						LOG_DBG_BUF((LOG_NEGOTIATION,
						    90, "post_quick_mode: "
						    "g^xy", ie->g_xy,
						    ie->g_x_len));
						prf->Update(prf->prfctx,
						    ie->g_xy, ie->g_x_len);
					}
					LOG_DBG((LOG_NEGOTIATION, 90,
					    "post_quick_mode: "
					    "suite %d proto %d", proto->no,
					    proto->proto));
					prf->Update(prf->prfctx, &proto->proto,
					    1);
					LOG_DBG_BUF((LOG_NEGOTIATION, 90,
					    "post_quick_mode: SPI",
					    proto->spi[i], proto->spi_sz[i]));
					prf->Update(prf->prfctx,
					    proto->spi[i], proto->spi_sz[i]);
					LOG_DBG_BUF((LOG_NEGOTIATION, 90,
					    "post_quick_mode: Ni_b",
					    exchange->nonce_i,
					    exchange->nonce_i_len));
					prf->Update(prf->prfctx,
					    exchange->nonce_i,
					    exchange->nonce_i_len);
					LOG_DBG_BUF((LOG_NEGOTIATION, 90,
					    "post_quick_mode: Nr_b",
					    exchange->nonce_r,
					    exchange->nonce_r_len));
					prf->Update(prf->prfctx,
					    exchange->nonce_r,
					    exchange->nonce_r_len);
					prf->Final(keymat, prf->prfctx);
				}
				prf_free(prf);
				LOG_DBG_BUF((LOG_NEGOTIATION, 90,
				    "post_quick_mode: KEYMAT",
				    iproto->keymat[i], ie->keymat_len));
			}
		}
	}

	log_verbose("isakmpd: quick mode done%s: %s",
	    (exchange->initiator == 0) ? " (as responder)" : "",
	    !msg->isakmp_sa || !msg->isakmp_sa->transport ? "<no transport>"
	    : msg->isakmp_sa->transport->vtbl->decode_ids
	    (msg->isakmp_sa->transport));
}

/*
 * Accept a set of transforms offered by the initiator and chose one we can
 * handle.
 * XXX Describe in more detail.
 */
static int
responder_recv_HASH_SA_NONCE(struct message *msg)
{
	struct payload *hashp, *kep, *idp;
	struct sa      *sa;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct prf     *prf;
	u_int8_t       *hash, *my_hash = 0;
	size_t          hash_len;
	u_int8_t       *pkt = msg->iov[0].iov_base;
	u_int8_t        group_desc = 0;
	int             retval = -1;
	struct proto   *proto;
	struct sockaddr *src, *dst;
	char           *name;

	hashp = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	hash = hashp->p;
	hashp->flags |= PL_MARK;

	/* The HASH payload should be the first one.  */
	if (hash != pkt + ISAKMP_HDR_SZ) {
		/* XXX Is there a better notification type?  */
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		goto cleanup;
	}
	hash_len = GET_ISAKMP_GEN_LENGTH(hash);
	my_hash = malloc(hash_len - ISAKMP_GEN_SZ);
	if (!my_hash) {
		log_error("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
		    (unsigned long)hash_len - ISAKMP_GEN_SZ);
		goto cleanup;
	}
	/*
	 * Check the payload's integrity.
	 * XXX Share with ipsec_fill_in_hash?
         */
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_recv_HASH_SA_NONCE: "
	    "SKEYID_a", isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		goto cleanup;
	prf->Init(prf->prfctx);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "responder_recv_HASH_SA_NONCE: message_id",
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "responder_recv_HASH_SA_NONCE: message after HASH",
	    hash + hash_len,
	    msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len));
	prf->Update(prf->prfctx, hash + hash_len,
	    msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
	prf->Final(my_hash, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "responder_recv_HASH_SA_NONCE: computed HASH(1)", my_hash,
	    hash_len - ISAKMP_GEN_SZ));
	if (memcmp(hash + ISAKMP_GEN_SZ, my_hash, hash_len - ISAKMP_GEN_SZ)
	    != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0,
		    1, 0);
		goto cleanup;
	}
	free(my_hash);
	my_hash = 0;

	/* Mark message as authenticated. */
	msg->flags |= MSG_AUTHENTICATED;

	kep = payload_first(msg, ISAKMP_PAYLOAD_KEY_EXCH);
	if (kep)
		ie->pfs = 1;

	/* Drop message when it contains ID types we do not implement yet.  */
	TAILQ_FOREACH(idp, &msg->payload[ISAKMP_PAYLOAD_ID], link) {
		switch (GET_ISAKMP_ID_TYPE(idp->p)) {
		case IPSEC_ID_IPV4_ADDR:
		case IPSEC_ID_IPV4_ADDR_SUBNET:
		case IPSEC_ID_IPV6_ADDR:
		case IPSEC_ID_IPV6_ADDR_SUBNET:
			break;

		case IPSEC_ID_FQDN:
			/*
			 * FQDN may be used for in NAT-T with transport mode.
			 * We can handle the message in this case.  In the
			 * other cases we'll drop the message later.
			 */
			break;

		default:
			message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION,
			    0, 1, 0);
			goto cleanup;
		}
	}

	/* Handle optional client ID payloads.  */
	idp = payload_first(msg, ISAKMP_PAYLOAD_ID);
	if (idp) {
		/* If IDci is there, IDcr must be too.  */
		if (!TAILQ_NEXT(idp, link)) {
			/* XXX Is this a good notify type?  */
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0,
			    1, 0);
			goto cleanup;
		}
		ie->id_ci_sz = GET_ISAKMP_GEN_LENGTH(idp->p);
		ie->id_ci = malloc(ie->id_ci_sz);
		if (!ie->id_ci) {
			log_error("responder_recv_HASH_SA_NONCE: "
			    "malloc (%lu) failed",
			    (unsigned long)ie->id_ci_sz);
			goto cleanup;
		}
		memcpy(ie->id_ci, idp->p, ie->id_ci_sz);
		idp->flags |= PL_MARK;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "responder_recv_HASH_SA_NONCE: IDci",
		    ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz - ISAKMP_GEN_SZ));

		idp = TAILQ_NEXT(idp, link);
		ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH(idp->p);
		ie->id_cr = malloc(ie->id_cr_sz);
		if (!ie->id_cr) {
			log_error("responder_recv_HASH_SA_NONCE: "
			    "malloc (%lu) failed",
			    (unsigned long)ie->id_cr_sz);
			goto cleanup;
		}
		memcpy(ie->id_cr, idp->p, ie->id_cr_sz);
		idp->flags |= PL_MARK;
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "responder_recv_HASH_SA_NONCE: IDcr",
		    ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz - ISAKMP_GEN_SZ));
	} else {
		/*
		 * If client identifiers are not present in the exchange,
		 * we fake them. RFC 2409 states:
		 *    The identities of the SAs negotiated in Quick Mode are
		 *    implicitly assumed to be the IP addresses of the ISAKMP
		 *    peers, without any constraints on the protocol or port
		 *    numbers allowed, unless client identifiers are specified
		 *    in Quick Mode.
		 *
		 * -- Michael Paddon (mwp@@aba.net.au)
		 */

		ie->flags = IPSEC_EXCH_FLAG_NO_ID;

		/* Get initiator and responder addresses.  */
		msg->transport->vtbl->get_src(msg->transport, &src);
		msg->transport->vtbl->get_dst(msg->transport, &dst);
		ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen(src);
		ie->id_cr_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen(dst);
		ie->id_ci = calloc(ie->id_ci_sz, sizeof(char));
		ie->id_cr = calloc(ie->id_cr_sz, sizeof(char));

		if (!ie->id_ci || !ie->id_cr) {
			log_error("responder_recv_HASH_SA_NONCE: "
			    "calloc (%lu, %lu) failed",
			    (unsigned long)ie->id_ci_sz,
			    (unsigned long)sizeof(char));
			goto cleanup;
		}
		if (src->sa_family != dst->sa_family) {
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "sa_family mismatch");
			goto cleanup;
		}
		switch (src->sa_family) {
		case AF_INET:
			SET_ISAKMP_ID_TYPE(ie->id_ci, IPSEC_ID_IPV4_ADDR);
			SET_ISAKMP_ID_TYPE(ie->id_cr, IPSEC_ID_IPV4_ADDR);
			break;

		case AF_INET6:
			SET_ISAKMP_ID_TYPE(ie->id_ci, IPSEC_ID_IPV6_ADDR);
			SET_ISAKMP_ID_TYPE(ie->id_cr, IPSEC_ID_IPV6_ADDR);
			break;

		default:
			log_error("initiator_recv_HASH_SA_NONCE: "
			    "unknown sa_family %d", src->sa_family);
			goto cleanup;
		}

		memcpy(ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(src),
		    sockaddr_addrlen(src));
		memcpy(ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(dst),
		    sockaddr_addrlen(dst));
	}

	if (message_negotiate_sa(msg, check_policy))
		goto cleanup;

	for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
	    sa = TAILQ_NEXT(sa, next)) {
		for (proto = TAILQ_FIRST(&sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link)) {
			/*
			 * XXX we need to have some attributes per proto, not
			 * all per SA.
			 */
			ipsec_decode_transform(msg, sa, proto,
			    proto->chosen->p);
			if (proto->proto == IPSEC_PROTO_IPSEC_AH &&
			    !((struct ipsec_proto *)proto->data)->auth) {
				log_print("responder_recv_HASH_SA_NONCE: "
				    "AH proposed without an algorithm "
				    "attribute");
				message_drop(msg,
				    ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
				goto next_sa;
			}
		}

		isa = sa->data;

		/*
		 * The group description is mandatory if we got a KEY_EXCH
		 * payload.
		 */
		if (kep) {
			if (!isa->group_desc) {
				log_print("responder_recv_HASH_SA_NONCE: "
				    "KEY_EXCH payload without a group "
				    "desc. attribute");
				message_drop(msg,
				    ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
				continue;
			}
			/* Also, all SAs must have equal groups.  */
			if (!group_desc)
				group_desc = isa->group_desc;
			else if (group_desc != isa->group_desc) {
				log_print("responder_recv_HASH_SA_NONCE: "
				  "differing group descriptions in one QM");
				message_drop(msg,
				    ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
				continue;
			}
		}
		/* At least one SA was accepted.  */
		retval = 0;

next_sa:
		;	/* XXX gcc3 wants this. */
	}

	if (kep) {
		ie->group = group_get(group_desc);
		if (!ie->group) {
			/*
			 * XXX If the error was due to an out-of-range group
			 * description we should notify our peer, but this
			 * should probably be done by the attribute
			 * validation.  Is it?
			 */
			goto cleanup;
		}
	}
	/* Copy out the initiator's nonce.  */
	if (exchange_save_nonce(msg))
		goto cleanup;

	/* Handle the optional KEY_EXCH payload.  */
	if (kep && ipsec_save_g_x(msg))
		goto cleanup;

	/*
	 * Try to find and set the connection name on the exchange.
         */

	/*
	 * Check for accepted identities as well as lookup the connection
	 * name and set it on the exchange.
	 *
	 * When not using policies make sure the peer proposes sane IDs.
	 * Otherwise this is done by KeyNote.
         */
	name = connection_passive_lookup_by_ids(ie->id_ci, ie->id_cr);
	if (name) {
		exchange->name = strdup(name);
		if (!exchange->name) {
			log_error("responder_recv_HASH_SA_NONCE: "
			    "strdup (\"%s\") failed", name);
			goto cleanup;
		}
	} else if (
	    ignore_policy ||
	    strncmp("yes", conf_get_str("General", "Use-Keynote"), 3)) {
		log_print("responder_recv_HASH_SA_NONCE: peer proposed "
		    "invalid phase 2 IDs: %s",
		    (exchange->doi->decode_ids("initiator id %s, responder"
		    " id %s", ie->id_ci, ie->id_ci_sz, ie->id_cr,
		    ie->id_cr_sz, 1)));
		message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1,
		    0);
		goto cleanup;
	}

	return retval;

cleanup:
	/* Remove all potential protocols that have been added to the SAs.  */
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
	    sa = TAILQ_NEXT(sa, next))
		while ((proto = TAILQ_FIRST(&sa->protos)) != 0)
			proto_free(proto);
	free(my_hash);
	free(ie->id_ci);
	ie->id_ci = 0;
	free(ie->id_cr);
	ie->id_cr = 0;
	return -1;
}

/* Reply with the transform we chose.  */
static int
responder_send_HASH_SA_NONCE(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct prf     *prf;
	struct hash    *hash = hash_get(isa->hash);
	size_t          nonce_sz = exchange->nonce_i_len;
	u_int8_t       *buf;
	int             initiator = exchange->initiator;
	char            header[80];
	u_int32_t       i;
	u_int8_t       *id;
	size_t          sz;

	/*
	 * We want a HASH payload to start with.  XXX Share with
	 * ike_main_mode.c?
	 */
	buf = malloc(ISAKMP_HASH_SZ + hash->hashsize);
	if (!buf) {
		log_error("responder_send_HASH_SA_NONCE: malloc (%lu) failed",
			  ISAKMP_HASH_SZ + (unsigned long)hash->hashsize);
		return -1;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_HASH, buf,
	    ISAKMP_HASH_SZ + hash->hashsize, 1)) {
		free(buf);
		return -1;
	}
	/* Add the SA payload(s) with the transform(s) that was/were chosen. */
	if (message_add_sa_payload(msg))
		return -1;

	/* Generate a nonce, and add it to the message.  */
	if (exchange_gen_nonce(msg, nonce_sz))
		return -1;

	/* Generate optional KEY_EXCH payload.  This is known as PFS.  */
	if (ie->group && ipsec_gen_g_x(msg))
		return -1;

	/*
	 * If the initiator client ID's were acceptable, just mirror them
	 * back.
	 */
	if (!(ie->flags & IPSEC_EXCH_FLAG_NO_ID)) {
		sz = ie->id_ci_sz;
		id = malloc(sz);
		if (!id) {
			log_error("responder_send_HASH_SA_NONCE: "
			    "malloc (%lu) failed", (unsigned long)sz);
			return -1;
		}
		memcpy(id, ie->id_ci, sz);
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "responder_send_HASH_SA_NONCE: IDic", id, sz));
		if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, id, sz, 1)) {
			free(id);
			return -1;
		}
		sz = ie->id_cr_sz;
		id = malloc(sz);
		if (!id) {
			log_error("responder_send_HASH_SA_NONCE: "
			    "malloc (%lu) failed", (unsigned long)sz);
			return -1;
		}
		memcpy(id, ie->id_cr, sz);
		LOG_DBG_BUF((LOG_NEGOTIATION, 90,
		    "responder_send_HASH_SA_NONCE: IDrc", id, sz));
		if (message_add_payload(msg, ISAKMP_PAYLOAD_ID, id, sz, 1)) {
			free(id);
			return -1;
		}
	}
	/* Allocate the prf and start calculating our HASH(2).  XXX Share?  */
	LOG_DBG((LOG_NEGOTIATION, 90, "responder_recv_HASH: "
	    "isakmp_sa %p isa %p", isakmp_sa, isa));
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: "
	    "SKEYID_a", isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		return -1;
	prf->Init(prf->prfctx);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "responder_send_HASH_SA_NONCE: message_id",
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: "
	    "NONCE_I_b", exchange->nonce_i, exchange->nonce_i_len));
	prf->Update(prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);

	/* Loop over all payloads after HASH(2).  */
	for (i = 2; i < msg->iovlen; i++) {
		/* XXX Misleading payload type printouts.  */
		snprintf(header, sizeof header,
		   "responder_send_HASH_SA_NONCE: payload %d after HASH(2)",
			 i - 1);
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, header, msg->iov[i].iov_base,
		    msg->iov[i].iov_len));
		prf->Update(prf->prfctx, msg->iov[i].iov_base,
		    msg->iov[i].iov_len);
	}
	prf->Final(buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
	prf_free(prf);
	snprintf(header, sizeof header, "responder_send_HASH_SA_NONCE: "
	    "HASH_%c", initiator ? 'I' : 'R');
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, header, buf + ISAKMP_HASH_DATA_OFF,
	    hash->hashsize));

	if (ie->group)
		message_register_post_send(msg, gen_g_xy);

	return 0;
}

static void
gen_g_xy(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;

	/* Compute Diffie-Hellman shared value.  */
	ie->g_xy = malloc(ie->g_x_len);
	if (!ie->g_xy) {
		log_error("gen_g_xy: malloc (%lu) failed",
		    (unsigned long)ie->g_x_len);
		return;
	}
	if (dh_create_shared(ie->group, ie->g_xy,
	    exchange->initiator ? ie->g_xr : ie->g_xi)) {
		log_print("gen_g_xy: dh_create_shared failed");
		return;
	}
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, "gen_g_xy: g^xy", ie->g_xy,
	    ie->g_x_len));
}

static int
responder_recv_HASH(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct prf     *prf;
	u_int8_t       *hash, *my_hash = 0;
	size_t          hash_len;
	struct payload *hashp;

	/* Find HASH(3) and create our own hash, just as big.  */
	hashp = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	hash = hashp->p;
	hashp->flags |= PL_MARK;
	hash_len = GET_ISAKMP_GEN_LENGTH(hash);
	my_hash = malloc(hash_len - ISAKMP_GEN_SZ);
	if (!my_hash) {
		log_error("responder_recv_HASH: malloc (%lu) failed",
			  (unsigned long)hash_len - ISAKMP_GEN_SZ);
		goto cleanup;
	}
	/* Allocate the prf and start calculating our HASH(3).  XXX Share?  */
	LOG_DBG((LOG_NEGOTIATION, 90, "responder_recv_HASH: "
	    "isakmp_sa %p isa %p", isakmp_sa, isa));
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_recv_HASH: SKEYID_a",
	    isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		goto cleanup;
	prf->Init(prf->prfctx);
	prf->Update(prf->prfctx, (unsigned char *)"\0", 1);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_recv_HASH: message_id",
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_recv_HASH: NONCE_I_b",
	    exchange->nonce_i, exchange->nonce_i_len));
	prf->Update(prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_recv_HASH: NONCE_R_b",
	    exchange->nonce_r, exchange->nonce_r_len));
	prf->Update(prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
	prf->Final(my_hash, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90,
	    "responder_recv_HASH: computed HASH(3)", my_hash,
	    hash_len - ISAKMP_GEN_SZ));
	if (memcmp(hash + ISAKMP_GEN_SZ, my_hash, hash_len - ISAKMP_GEN_SZ)
	    != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0,
		    1, 0);
		goto cleanup;
	}
	free(my_hash);

	/* Mark message as authenticated. */
	msg->flags |= MSG_AUTHENTICATED;

	post_quick_mode(msg);

	return 0;

cleanup:
	free(my_hash);
	return -1;
}
@


1.109
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.108 2014/10/09 02:38:56 deraadt Exp $	 */
d761 1
a761 2
					if (proto->data)
						free(proto->data);
d768 1
a768 2
					if (proto->data)
						free(proto->data);
@


1.108
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.107 2011/12/12 07:35:29 yasuoka Exp $	 */
d759 1
a759 2
				pa = (struct proto_attr *)calloc(1,
				    sizeof *pa);
d767 1
a767 1
				pa->attrs = (u_int8_t *)malloc(pa->len);
@


1.107
log
@Allow using FQDN as a ID payload type.  Some client (eg Windows XP)
uses the FQDN type in NAT-T with transport mode.

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.106 2011/04/23 03:17:04 lum Exp $	 */
d441 2
a442 2
				new_proposal = realloc(proposal,
				    prop_cnt * sizeof *proposal);
d453 2
a454 2
				new_transforms_len = realloc(transforms_len,
				    prop_cnt * sizeof *transforms_len);
d465 2
a466 2
				new_transform = realloc(transform,
				    prop_cnt * sizeof *transform);
d477 2
a478 2
				new_transform_cnt = realloc(transform_cnt,
				    prop_cnt * sizeof *transform_cnt);
d489 2
a490 2
				new_transform_len = realloc(transform_len,
				    prop_cnt * sizeof *transform_len);
@


1.106
log
@Indicate which side of the connection responded during phase 1 while using -v.
ok sthen@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.105 2010/06/29 19:50:16 reyk Exp $	 */
d1091 8
d1541 8
@


1.105
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.103 2009/11/13 22:07:59 deraadt Exp $	 */
d1435 2
a1436 1
	log_verbose("isakmpd: quick mode done: %s",
@


1.104
log
@don't crash on invalid phase 2 IDs; from hshoexer; ok sthen@@
@
text
@a50 1
#include "math_group.h"
@


1.103
log
@fix a few memory leaks found by parfait; ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.102 2008/11/11 15:11:28 hshoexer Exp $	 */
d1083 16
d1525 16
@


1.102
log
@Use rfc2409 conform notification message when client identities are
not valid during phase 2.

From Dirk Mast <condor2k at googlemail dot com>, thanks!

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.101 2007/08/15 21:05:45 hshoexer Exp $	 */
d746 1
d762 4
a765 1
				if (!pa)
d767 1
d771 3
@


1.101
log
@Remove a superflous debug fprintf.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.100 2007/04/16 13:01:39 moritz Exp $	 */
d1702 2
a1703 1
		message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
@


1.100
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.99 2006/06/10 21:09:45 msf Exp $	 */
a152 2
	fprintf(stderr, "ISAKMP_SA RECV_CERTTYPE: %i\n", 
	    isakmp_sa->recv_certtype);
@


1.99
log
@Allow isakmpd to use a different private rsa key per isakmp ID. Hans wrote this a long time ago, I synced it to -current and tested.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.98 2006/06/02 19:35:55 hshoexer Exp $	 */
d355 1
a355 2
	if (principal)
		free(principal);
d364 1
a364 2
	if (keynote_ids)
		free(keynote_ids);
d366 1
a366 2
	if (x509_ids)
		free(x509_ids);
d973 1
a973 2
	if (sa_buf)
		free(sa_buf);
d976 1
a976 2
			if (proposal[i])
				free(proposal[i]);
d980 1
a980 2
					if (transform[i][xf_no])
						free(transform[i][xf_no]);
d983 1
a983 2
			if (transform_len[i])
				free(transform_len[i]);
d1144 4
a1147 8
			if (ie->id_ci) {
				free(ie->id_ci);
				ie->id_ci = 0;
			}
			if (ie->id_cr) {
				free(ie->id_cr);
				ie->id_cr = 0;
			}
d1716 5
a1720 10
	if (my_hash)
		free(my_hash);
	if (ie->id_ci) {
		free(ie->id_ci);
		ie->id_ci = 0;
	}
	if (ie->id_cr) {
		free(ie->id_cr);
		ie->id_cr = 0;
	}
d1932 1
a1932 2
	if (my_hash)
		free(my_hash);
@


1.98
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.97 2005/11/14 23:25:11 deraadt Exp $	 */
d153 2
@


1.97
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.96 2005/05/26 06:11:09 hshoexer Exp $	 */
d1330 1
a1330 1
			 * incoming and outcoing.
@


1.96
log
@Use TAILQ_FOREACH where possible, remove payload_last()

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.95 2005/04/08 22:32:10 cloder Exp $	 */
d259 2
a260 5
		len = strlen(principal[0]) + sizeof "rsa-hex:";
		principal[1] = calloc(len, sizeof(char));
		if (!principal[1]) {
			log_error("check_policy: calloc (%d, %lu) failed", len,
			    (unsigned long)sizeof(char));
a262 1
		snprintf(principal[1], len, "rsa-hex:%s", principal[0]);
@


1.95
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.94 2005/04/08 17:15:01 deraadt Exp $	 */
d1199 1
a1199 3
	for (xf = payload_first(msg, ISAKMP_PAYLOAD_TRANSFORM); xf;
	    xf = TAILQ_NEXT(xf, link)) {

@


1.94
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.93 2005/04/06 16:00:20 deraadt Exp $	 */
a39 2

#include "sysdep.h"
@


1.93
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.92 2005/04/05 20:46:20 cloder Exp $	 */
a36 1
#if defined (USE_POLICY) || defined (USE_KEYNOTE)
a39 1
#endif
a71 1
#ifdef USE_POLICY
a72 1
#endif
a85 2
#ifdef USE_POLICY

a213 1
#ifdef USE_KEYNOTE
a229 1
#endif
a389 1
#endif				/* USE_POLICY */
a1223 1
#ifdef USE_POLICY
a1228 1
#endif
a1616 2
#ifdef USE_POLICY
#ifdef USE_KEYNOTE
a1618 8
#else
	if (message_negotiate_sa(msg, 0))
		goto cleanup;
#endif
#else
	if (message_negotiate_sa(msg, 0))
		goto cleanup;
#endif				/* USE_POLICY */
@


1.92
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.91 2005/04/04 19:31:11 deraadt Exp $	 */
d1651 2
a1652 2
			if (proto->proto == IPSEC_PROTO_IPSEC_AH
			    && !((struct ipsec_proto *)proto->data)->auth) {
@


1.91
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.90 2005/03/22 12:43:39 hshoexer Exp $	 */
a62 2

#ifdef USE_X509
a63 1
#endif
a106 1
#ifdef USE_X509
a108 1
#endif
a240 1
#ifdef USE_X509
a297 1
#endif
a1734 1
#if defined (USE_X509) && defined (USE_POLICY)
a1735 1
#endif
@


1.90
log
@Do not leak keynote session in error path.

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.89 2005/03/05 12:32:58 ho Exp $	 */
d171 1
a171 1
	         */
d612 1
a612 1
			         */
d616 1
a616 2
					     life;
					     life = TAILQ_NEXT(life, link)) {
d652 1
a652 1
				      IPSEC_ATTR_ENCAPSULATION_MODE, &attr);
d716 1
a716 1
				         */
d738 1
a738 1
		         */
d857 2
a858 2
						transform[i][xf_no],
				     transform_len[i][xf_no], update_nextp))
d961 1
a961 1
		       sockaddr_addrlen(src));
d1004 1
a1004 1
				     xf_no++)
d1152 1
a1152 1
	         *
d1154 1
a1154 1
	         */
d1211 1
a1211 1
		       sockaddr_addrlen(src));
d1213 1
a1213 1
		       sockaddr_addrlen(dst));
d1218 1
a1218 1
	     xf = TAILQ_NEXT(xf, link)) {
d1223 1
a1223 1
	         */
d1287 1
a1287 1
			  ISAKMP_HASH_SZ + (unsigned long)hash->hashsize);
d1297 1
a1297 1
		     isa->skeyid_a, isa->skeyid_len));
d1346 1
a1346 1
	     sa = TAILQ_NEXT(sa, next)) {
d1348 1
a1348 1
		     proto = TAILQ_NEXT(proto, link)) {
d1357 1
a1357 1
		         */
d1372 1
a1372 1
			         */
d1388 1
a1388 1
				     keymat += prf->blocksize) {
d1493 1
a1493 1
			  (unsigned long)hash_len - ISAKMP_GEN_SZ);
d1508 2
a1509 2
		     "responder_recv_HASH_SA_NONCE: message_id",
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
d1513 3
a1515 3
		     "responder_recv_HASH_SA_NONCE: message after HASH",
		     hash + hash_len,
		     msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len));
d1517 1
a1517 1
		    msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
d1521 2
a1522 2
		  "responder_recv_HASH_SA_NONCE: computed HASH(1)", my_hash,
		     hash_len - ISAKMP_GEN_SZ));
d1586 1
a1586 1
	         *
d1588 1
a1588 1
	         */
d1630 1
a1630 1
		       sockaddr_addrlen(src));
d1632 1
a1632 1
		       sockaddr_addrlen(dst));
d1649 1
a1649 1
	     sa = TAILQ_NEXT(sa, next)) {
d1651 1
a1651 1
		     proto = TAILQ_NEXT(proto, link)) {
d1710 1
a1710 1
		         */
d1748 3
a1750 3
		        (exchange->doi->decode_ids("initiator id %s, responder"
			" id %s", ie->id_ci, ie->id_ci_sz, ie->id_cr,
			ie->id_cr_sz, 1)));
d1760 1
a1760 1
	     sa = TAILQ_NEXT(sa, next))
d1866 2
a1867 2
		     "responder_send_HASH_SA_NONCE: message_id",
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
d1881 1
a1881 1
			     msg->iov[i].iov_len));
d1912 1
a1912 1
			     exchange->initiator ? ie->g_xr : ie->g_xi)) {
d1946 1
a1946 1
		     isa->skeyid_a, isa->skeyid_len));
d1954 1
a1954 1
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
d1958 1
a1958 1
		     exchange->nonce_i, exchange->nonce_i_len));
d1961 1
a1961 1
		     exchange->nonce_r, exchange->nonce_r_len));
d1966 2
a1967 2
		     "responder_recv_HASH: computed HASH(3)", my_hash,
		     hash_len - ISAKMP_GEN_SZ));
@


1.89
log
@No need to use a local hashsize. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.88 2005/02/10 13:01:01 ho Exp $	 */
d144 2
@


1.88
log
@ignore_policy should be ifdef USE_POLICY. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.87 2004/09/17 13:53:08 ho Exp $	 */
a1040 1
	size_t          hashsize = hash->hashsize;
d1073 3
a1075 3
	    hashsize));
	if (memcmp(hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest, hashsize)
	    != 0) {
a1277 1
	size_t          hashsize = hash->hashsize;
d1283 1
a1283 1
	buf = malloc(ISAKMP_HASH_SZ + hashsize);
d1286 1
a1286 1
			  ISAKMP_HASH_SZ + (unsigned long)hashsize);
d1290 1
a1290 1
	    ISAKMP_HASH_SZ + hashsize, 1)) {
d1316 1
a1316 1
	    buf + ISAKMP_GEN_SZ, hashsize));
a1784 1
	size_t          hashsize = hash->hashsize;
d1797 1
a1797 1
	buf = malloc(ISAKMP_HASH_SZ + hashsize);
d1800 1
a1800 1
			  ISAKMP_HASH_SZ + (unsigned long)hashsize);
d1804 1
a1804 1
				ISAKMP_HASH_SZ + hashsize, 1)) {
d1889 1
a1889 1
		     hashsize));
@


1.87
log
@Missing #ifdefs.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.86 2004/08/14 13:29:50 hshoexer Exp $	 */
d1743 1
a1743 1
#ifdef USE_X509
@


1.86
log
@When using -K (keynote disabled), check peers' proposal against isakmpd.conf.

ok ho@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.85 2004/08/08 19:11:06 deraadt Exp $	 */
d1742 5
a1746 2
	} else if (ignore_policy || strncmp("yes", conf_get_str("General",
	    "Use-Keynote"), 3)) {
@


1.85
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.84 2004/06/25 20:25:34 hshoexer Exp $	 */
d1730 3
d1742 8
a1749 11
	}
#if !defined (USE_POLICY) && !defined (USE_KEYNOTE)
	else {
		/*
		 * This code is no longer necessary, as policy determines
		 * acceptance of IDs/SAs. (angelos@@openbsd.org)
	         *
		 * XXX Keep it if not USE_POLICY for now, though.
	         */

		/* XXX Notify peer and log.  */
a1751 1
#endif				/* !USE_POLICY && !USE_KEYNOTE */
@


1.84
log
@Keynote policy checking can now be disabled by "-K" switch and config tag
"Use-Keynote".  Default is to use keynote.

ok henning@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.83 2004/06/20 17:17:35 ho Exp $	 */
d202 1
a202 1
			snprintf(principal[1] + 2 * i + 
d378 1
a378 1
			kn_remove_assertion(isakmp_sa->policy_id, 
d626 2
a627 2
						value = 
						    conf_get_num(life->field, 
d705 1
a705 1
				transforms_len[prop_no] += 
d747 1
a747 1
			proposals_len += 
d1424 1
a1424 1
					prf->Update(prf->prfctx, 
@


1.83
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.82 2004/06/15 15:53:13 hshoexer Exp $	 */
d114 5
@


1.82
log
@also use MSG_AUTHENTICATED flag.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.81 2004/06/14 09:55:41 ho Exp $	 */
d1028 1
a1028 1
	struct payload *sa_p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SA]);
d1030 2
a1031 4
	struct payload *hashp =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
	struct payload *kep =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
d1100 1
a1100 1
	idp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ID]);
d1212 1
a1212 1
	for (xf = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]); xf;
d1475 1
a1475 1
	hashp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
d1531 1
a1531 1
	kep = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
d1536 1
a1536 1
	idp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_ID]);
d1927 1
a1927 1
	hashp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
@


1.81
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.80 2004/06/10 12:54:53 hshoexer Exp $	 */
d1080 3
@


1.80
log
@Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!

ok ho@@ niklas@@, testing and spellcheck by todd@@ msf@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.79 2004/06/09 14:02:44 ho Exp $	 */
d118 2
a119 1
			log_print("check_policy: failed to initialize policy session");
d168 2
a169 2
			log_error("check_policy: calloc (%d, %lu) failed", nprinc,
			    (unsigned long)sizeof *principal);
d184 2
a185 2
		memcpy(principal[0] + sizeof "passphrase:" - 1, isakmp_sa->recv_key,
		    strlen(isakmp_sa->recv_key));
d197 3
a199 2
			snprintf(principal[1] + 2 * i + sizeof "passphrase-md5-hex:" - 1,
			    3, "%02x", hashbuf[i]);
d209 2
a210 1
		SHA1(isakmp_sa->recv_key, strlen(isakmp_sa->recv_key), hashbuf);
d212 3
a214 2
			snprintf(principal[2] + 2 * i + sizeof "passphrase-sha1-hex:" - 1,
			    3, "%02x", hashbuf[i]);
d223 2
a224 2
			log_error("check_policy: calloc (%d, %lu) failed", nprinc,
			    (unsigned long)sizeof *principal);
d249 3
a251 2
			log_error("check_policy: unknown/unsupported public key algorithm "
			    "%d", isakmp_sa->recv_keytype);
d256 2
a257 2
		principal[0] = kn_encode_key(&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
		    KEYNOTE_PUBLIC_KEY);
d259 2
a260 1
			log_print("check_policy: failed to get memory for public key");
d264 2
a265 1
			log_print("check_policy: failed to allocate memory for principal");
d285 2
a286 1
				log_error("check_policy: calloc (259, %lu) failed",
d322 2
a323 2
		LOG_DBG((LOG_POLICY, 40, "check_policy: adding authorizer [%s]",
		    principal[i]));
d325 3
a327 2
		if (kn_add_authorizer(isakmp_sa->policy_id, principal[i]) == -1) {
			int             j;
d330 2
a331 1
				kn_remove_authorizer(isakmp_sa->policy_id, principal[j]);
d338 4
a341 2
	result = kn_do_query(isakmp_sa->policy_id, return_values, RETVALUES_NUM);
	LOG_DBG((LOG_POLICY, 40, "check_policy: kn_do_query returned %d", result));
d373 2
a374 1
			kn_remove_assertion(isakmp_sa->policy_id, keynote_ids[i]);
d384 3
a386 2
	 * XXX Currently, check_policy() is only called from message_negotiate_sa(),
	 *     and so this log message reflects this. Change to something better?
d393 2
a394 1
	 * we can just return the query result directly (no pre-processing needed).
d463 2
a464 1
					log_error("initiator_send_HASH_SA_NONCE: "
d475 2
a476 1
					log_error("initiator_send_HASH_SA_NONCE: "
d487 2
a488 1
					log_error("initiator_send_HASH_SA_NONCE: "
d499 2
a500 1
					log_error("initiator_send_HASH_SA_NONCE: "
d511 2
a512 1
					log_error("initiator_send_HASH_SA_NONCE: "
d524 2
a525 1
			proto_id = constant_value(ipsec_proto_cst, protocol_id);
d541 2
a542 2
				log_print("initiator_send_HASH_SA_NONCE: invalid PROTCOL_ID: "
				    "%s", protocol_id);
d547 1
a547 1
			/* Now get each transform we offer for this protocol.  */
d581 2
a582 1
					log_error("initiator_send_HASH_SA_NONCE: "
d591 2
a592 1
				transform_id = conf_get_str(xf->field, "TRANSFORM_ID");
d599 2
a600 1
				attr = transform[prop_no][xf_no] + ISAKMP_TRANSFORM_SA_ATTRS_OFF;
d603 2
a604 2
				 * Life durations are special, we should be able to specify
				 * several, one per type.
d608 2
a609 1
					for (life = TAILQ_FIRST(&life_conf->fields); life;
d611 5
a615 3
						attribute_set_constant(life->field, "LIFE_TYPE",
							 ipsec_duration_cst,
								       IPSEC_ATTR_SA_LIFE_TYPE, &attr);
d621 3
a623 1
						value = conf_get_num(life->field, "LIFE_DURATION", 0);
d627 4
a630 3
									attribute_set_basic(attr,
											    IPSEC_ATTR_SA_LIFE_DURATION,
								     value);
d634 5
a638 4
									attribute_set_var(attr,
											  IPSEC_ATTR_SA_LIFE_DURATION,
											  (u_int8_t *)&value,
											  sizeof value);
d644 2
a645 2
				attribute_set_constant(xf->field, "ENCAPSULATION_MODE",
						       ipsec_encap_cst,
d650 4
a653 8
						 "AUTHENTICATION_ALGORITHM",
							     ipsec_auth_cst,
					IPSEC_ATTR_AUTHENTICATION_ALGORITHM,
							       &attr);

					attribute_set_constant(xf->field, "GROUP_DESCRIPTION",
							 ike_group_desc_cst,
					IPSEC_ATTR_GROUP_DESCRIPTION, &attr);
d655 7
a661 1
					value = conf_get_num(xf->field, "KEY_LENGTH", 0);
d663 4
a666 2
						attr = attribute_set_basic(attr, IPSEC_ATTR_KEY_LENGTH,
								     value);
d668 2
a669 1
					value = conf_get_num(xf->field, "KEY_ROUNDS", 0);
d671 4
a674 2
						attr = attribute_set_basic(attr, IPSEC_ATTR_KEY_ROUNDS,
								     value);
d676 2
a677 2
					value = conf_get_num(xf->field, "COMPRESS_DICTIONARY_SIZE",
							     0);
d679 4
a682 3
						attr = attribute_set_basic(attr,
									   IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE,
								     value);
d687 4
a690 3
						attr = attribute_set_basic(attr,
									   IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM,
								     value);
d693 2
a694 1
				value = conf_get_num(xf->field, "ECN_TUNNEL", 0);
d696 2
a697 2
					attr = attribute_set_basic(attr, IPSEC_ATTR_ECN_TUNNEL,
								   value);
d700 2
a701 1
				transforms_len[prop_no] += (transform_len[prop_no][xf_no]
d706 4
a709 2
					 * Make sure that if a group description is specified, it is
					 * specified for all transforms equally.
d711 3
a713 2
					attr = (u_int8_t *)conf_get_str(xf->field,
						       "GROUP_DESCRIPTION");
d715 2
a716 2
						= attr ? constant_value(ike_group_desc_cst,
							 (char *)attr) : 0;
d721 1
a721 1
							  "differing group descriptions in a proposal");
d733 2
a734 1
			protocol_num = constant_value(ipsec_proto_cst, protocol_id);
d737 2
a738 1
				log_print("initiator_send_HASH_SA_NONCE: doi->get_spi failed");
d742 2
a743 1
			proposals_len += proposal_len + transforms_len[prop_no];
d746 3
a748 2
				log_error("initiator_send_HASH_SA_NONCE: malloc (%lu) failed",
					  (unsigned long)proposal_len);
d757 3
a759 2
				log_error("initiator_send_HASH_SA_NONCE: calloc (1, %lu) "
				   "failed", (unsigned long)sizeof *proto);
d765 4
a768 2
					log_error("initiator_send_HASH_SA_NONCE: calloc (1, %lu) "
						  "failed", (unsigned long)doi->proto_size);
d778 2
a779 1
				pa = (struct proto_attr *)calloc(1, sizeof *pa);
d788 2
a789 1
				memcpy(pa->attrs, transform[prop_no][xf_no], pa->len);
d792 2
a793 2
			TAILQ_INSERT_TAIL(&TAILQ_FIRST(&exchange->sa_list)->protos, proto,
					  link);
d797 2
a798 1
			memcpy(proposal[prop_no] + ISAKMP_PROP_SPI_OFF, spi, spi_sz);
d840 2
a841 2
		if (message_add_payload(msg, ISAKMP_PAYLOAD_PROPOSAL, proposal[i],
					proposal_len, update_nextp))
d843 2
a844 1
		SET_ISAKMP_GEN_LENGTH(proposal[i], proposal_len + transforms_len[i]);
d894 2
a895 2
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDic",
			     id, sz));
d903 2
a904 2
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDrc",
			     id, sz));
d936 3
a938 2
			log_error("initiator_send_HASH_SA_NONCE: calloc (%lu, %lu) failed",
			  (unsigned long)sz, (unsigned long)sizeof(char));
d949 2
a950 2
			log_error("initiator_send_HASH_SA_NONCE: unknown sa_family %d",
				  src->sa_family);
d957 2
a958 2
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDic",
			     id, sz));
d967 2
a968 2
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDrc",
			     id, sz));
d997 2
a998 1
				for (xf_no = 0; xf_no < transform_cnt[i]; xf_no++)
d1030 4
a1033 2
	struct payload *hashp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
	struct payload *kep = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
d1044 4
a1047 3
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: SKEYID_a",
		     (u_int8_t *)isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
d1053 6
a1058 5
		     "initiator_recv_HASH_SA_NONCE: message_id",
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: NONCE_I_b",
		     exchange->nonce_i, exchange->nonce_i_len));
d1062 1
a1062 1
		    - (rest - (u_int8_t *)msg->iov[0].iov_base));
d1064 2
a1065 2
	       "initiator_recv_HASH_SA_NONCE: payloads after HASH(2)", rest,
		     rest_len));
d1070 6
a1075 4
		     "initiator_recv_HASH_SA_NONCE: computed HASH(2)",
		     hash->digest, hashsize));
	if (memcmp(hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest, hashsize) != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
d1082 2
a1083 2
	 * As we are getting an answer on our transform offer, only one transform
	 * should be given.
d1104 2
a1105 1
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
d1112 3
a1114 2
			log_error("initiator_recv_HASH_SA_NONCE: malloc (%lu) failed",
				  (unsigned long)ie->id_ci_sz);
d1120 2
a1121 3
			     "initiator_recv_HASH_SA_NONCE: IDci",
			     ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz
			     - ISAKMP_GEN_SZ));
d1127 3
a1129 2
			log_error("initiator_recv_HASH_SA_NONCE: malloc (%lu) failed",
				  (unsigned long)ie->id_cr_sz);
d1135 2
a1136 3
			     "initiator_recv_HASH_SA_NONCE: IDcr",
			     ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz
			     - ISAKMP_GEN_SZ));
d1161 4
a1164 2
			log_error("initiator_recv_HASH_SA_NONCE: calloc (%lu, %lu) failed",
				  (unsigned long)ie->id_cr_sz, (unsigned long)sizeof(char));
d1176 2
a1177 1
			log_error("initiator_recv_HASH_SA_NONCE: sa_family mismatch");
d1196 2
a1197 2
			log_error("initiator_recv_HASH_SA_NONCE: unknown sa_family %d",
				  src->sa_family);
d1215 2
a1216 2
		 * XXX We could check that the proposal each transform belongs to
		 * is unique.
d1246 3
a1248 2
	if ((isa->group_desc && (!ie->group || ie->group->id != isa->group_desc))
	    || (!isa->group_desc && ie->group)) {
d1286 1
a1286 1
				ISAKMP_HASH_SZ + hashsize, 1)) {
d1293 2
a1294 1
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
d1300 3
a1302 2
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1304 1
a1304 1
		     exchange->nonce_i, exchange->nonce_i_len));
d1307 1
a1307 1
		     exchange->nonce_r, exchange->nonce_r_len));
d1312 1
a1312 1
		     buf + ISAKMP_GEN_SZ, hashsize));
d1340 2
a1341 1
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa; sa = TAILQ_NEXT(sa, next)) {
d1350 2
a1351 1
			 * There are two SAs for each SA negotiation, incoming and outcoing.
d1354 2
a1355 2
				prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_d,
						isa->skeyid_len);
d1363 4
a1366 3
				 * We need to roundup the length of the key material buffer
				 * to a multiple of the PRF's blocksize as it is generated
				 * in chunks of that blocksize.
d1372 5
a1376 4
					log_error("post_quick_mode: malloc (%lu) failed",
					  (((unsigned long)ie->keymat_len +
					    prf->blocksize - 1) / prf->blocksize) *
						  prf->blocksize);
d1391 3
a1393 2
						LOG_DBG_BUF((LOG_NEGOTIATION, 90,
							     "post_quick_mode: last KEYMAT",
d1395 4
a1398 3
							   prf->blocksize));
						prf->Update(prf->prfctx, keymat - prf->blocksize,
							    prf->blocksize);
d1402 6
a1407 4
						LOG_DBG_BUF((LOG_NEGOTIATION, 90,
							     "post_quick_mode: g^xy", ie->g_xy,
							     ie->g_x_len));
						prf->Update(prf->prfctx, ie->g_xy, ie->g_x_len);
d1410 24
a1433 14
						 "post_quick_mode: suite %d proto %d", proto->no,
						 proto->proto));
					prf->Update(prf->prfctx, &proto->proto, 1);
					LOG_DBG_BUF((LOG_NEGOTIATION, 90, "post_quick_mode: SPI",
					  proto->spi[i], proto->spi_sz[i]));
					prf->Update(prf->prfctx, proto->spi[i], proto->spi_sz[i]);
					LOG_DBG_BUF((LOG_NEGOTIATION, 90, "post_quick_mode: Ni_b",
						     exchange->nonce_i, exchange->nonce_i_len));
					prf->Update(prf->prfctx, exchange->nonce_i,
						    exchange->nonce_i_len);
					LOG_DBG_BUF((LOG_NEGOTIATION, 90, "post_quick_mode: Nr_b",
						     exchange->nonce_r, exchange->nonce_r_len));
					prf->Update(prf->prfctx, exchange->nonce_r,
						    exchange->nonce_r_len);
d1437 3
a1439 2
				LOG_DBG_BUF((LOG_NEGOTIATION, 90, "post_quick_mode: KEYMAT",
					iproto->keymat[i], ie->keymat_len));
d1445 3
a1447 4
		    !msg->isakmp_sa || !msg->isakmp_sa->transport
		    ? "<no transport>"
		    : msg->isakmp_sa->transport->vtbl->decode_ids
		    (msg->isakmp_sa->transport));
d1495 4
a1498 3
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_recv_HASH_SA_NONCE: SKEYID_a",
		     isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
d1505 2
a1506 1
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1518 4
a1521 2
	if (memcmp(hash + ISAKMP_GEN_SZ, my_hash, hash_len - ISAKMP_GEN_SZ) != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
d1540 2
a1541 1
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
d1547 3
a1549 2
			log_error("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
				  (unsigned long)ie->id_ci_sz);
d1555 2
a1556 3
			     "responder_recv_HASH_SA_NONCE: IDci",
			     ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz
			     - ISAKMP_GEN_SZ));
d1562 3
a1564 2
			log_error("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
				  (unsigned long)ie->id_cr_sz);
d1570 2
a1571 3
			     "responder_recv_HASH_SA_NONCE: IDcr",
			     ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz
			     - ISAKMP_GEN_SZ));
d1596 4
a1599 2
			log_error("responder_recv_HASH_SA_NONCE: calloc (%lu, %lu) failed",
				  (unsigned long)ie->id_ci_sz, (unsigned long)sizeof(char));
d1603 2
a1604 1
			log_error("initiator_recv_HASH_SA_NONCE: sa_family mismatch");
d1619 2
a1620 2
			log_error("initiator_recv_HASH_SA_NONCE: unknown sa_family %d",
				  src->sa_family);
d1643 2
a1644 1
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa; sa = TAILQ_NEXT(sa, next)) {
d1651 2
a1652 1
			ipsec_decode_transform(msg, sa, proto, proto->chosen->p);
d1656 4
a1659 2
					  "AH proposed without an algorithm attribute");
				message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
d1673 4
a1676 2
					  "KEY_EXCH payload without a group desc. attribute");
				message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
d1685 2
a1686 1
				message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
d1694 1
a1694 1
		;		/* XXX gcc3 wants this. */
d1701 4
a1704 3
			 * XXX If the error was due to an out-of-range group description
			 * we should notify our peer, but this should probably be done
			 * by the attribute validation.  Is it?
d1729 2
a1730 2
			log_error("responder_recv_HASH_SA_NONCE: strdup (\"%s\") failed",
				  name);
d1737 2
a1738 2
		 * This code is no longer necessary, as policy determines acceptance
		 * of IDs/SAs. (angelos@@openbsd.org)
d1752 2
a1753 1
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa; sa = TAILQ_NEXT(sa, next))
d1803 1
a1803 1
	/* Add the SA payload(s) with the transform(s) that was/were chosen.  */
d1823 2
a1824 2
			log_error("responder_send_HASH_SA_NONCE: malloc (%lu) failed",
				  (unsigned long)sz);
d1828 2
a1829 2
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: IDic",
			     id, sz));
d1837 2
a1838 2
			log_error("responder_send_HASH_SA_NONCE: malloc (%lu) failed",
				  (unsigned long)sz);
d1842 2
a1843 2
		LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: IDrc",
			     id, sz));
d1850 6
a1855 5
	LOG_DBG((LOG_NEGOTIATION, 90, "responder_recv_HASH: isakmp_sa %p isa %p",
		 isakmp_sa, isa));
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: SKEYID_a",
		     isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
d1862 4
a1865 3
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
	LOG_DBG_BUF((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: NONCE_I_b",
		     exchange->nonce_i, exchange->nonce_i_len));
d1876 2
a1877 1
		prf->Update(prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
d1881 2
a1882 2
	snprintf(header, sizeof header, "responder_send_HASH_SA_NONCE: HASH_%c",
		 initiator ? 'I' : 'R');
d1901 2
a1902 1
		log_error("gen_g_xy: malloc (%lu) failed", (unsigned long)ie->g_x_len);
d1910 2
a1911 1
	LOG_DBG_BUF((LOG_NEGOTIATION, 80, "gen_g_xy: g^xy", ie->g_xy, ie->g_x_len));
d1937 2
a1938 2
	LOG_DBG((LOG_NEGOTIATION, 90, "responder_recv_HASH: isakmp_sa %p isa %p",
		 isakmp_sa, isa));
d1941 2
a1942 1
	prf = prf_alloc(isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
d1949 2
a1950 1
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1962 4
a1965 2
	if (memcmp(hash + ISAKMP_GEN_SZ, my_hash, hash_len - ISAKMP_GEN_SZ) != 0) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
@


1.79
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.78 2004/04/28 20:20:31 hshoexer Exp $	 */
d1434 3
d1854 3
@


1.78
log
@remove unused variable and shorten names of two other.  Removed some spaces
while around.

ok ho@@ markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.77 2004/04/15 18:39:25 deraadt Exp $	 */
d390 1
a390 1
initiator_send_HASH_SA_NONCE(struct message * msg)
d964 1
a964 1
initiator_recv_HASH_SA_NONCE(struct message * msg)
d1195 1
a1195 1
initiator_send_HASH(struct message * msg)
d1252 1
a1252 1
post_quick_mode(struct message * msg)
d1367 1
a1367 1
responder_recv_HASH_SA_NONCE(struct message * msg)
d1662 1
a1662 1
responder_send_HASH_SA_NONCE(struct message * msg)
d1781 1
a1781 1
gen_g_xy(struct message * msg)
d1801 1
a1801 1
responder_recv_HASH(struct message * msg)
@


1.77
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ike_quick_mode.c,v 1.76 2004/04/07 22:45:49 ho Exp $	 */
d81 1
a81 1
int	(*ike_quick_mode_initiator[]) (struct message *) = {
d87 1
a87 1
int	(*ike_quick_mode_responder[]) (struct message *) = {
d123 1
a123 1
	if (kn_add_action(isakmp_sa->policy_id, ".*", (char *) policy_callback,
d132 2
a133 2
	if (keynote_policy_asserts_num) {
		keynote_ids = calloc(keynote_policy_asserts_num, sizeof *keynote_ids);
d136 2
a137 2
			    keynote_policy_asserts_num,
			    (unsigned long) sizeof *keynote_ids);
d142 1
a142 1
	for (i = 0; i < keynote_policy_asserts_num; i++)
d144 2
a145 2
		    keynote_policy_asserts[i],
		    strlen(keynote_policy_asserts[i]), ASSERT_FLAG_LOCAL);
d168 1
a168 1
			    (unsigned long) sizeof *principal);
d175 1
a175 1
			    (unsigned long) sizeof(char));
d190 1
a190 1
			    (unsigned long) sizeof(char));
d203 1
a203 1
			    (unsigned long) sizeof(char));
d220 1
a220 1
			    (unsigned long) sizeof *principal);
d227 2
a228 2
			    (unsigned long) strlen(isakmp_sa->keynote_key),
			    (unsigned long) sizeof(char));
d239 1
a239 1
			    (unsigned long) sizeof *principal);
d265 1
a265 1
			    (unsigned long) sizeof(char));
d279 1
a279 1
				    (unsigned long) sizeof(char));
d359 1
a359 1
	for (i = 0; i < keynote_policy_asserts_num; i++) {
d451 1
a451 1
					    prop_cnt * (unsigned long) sizeof *proposal);
d462 1
a462 1
					    prop_cnt * (unsigned long) sizeof *transforms_len);
d473 1
a473 1
					    prop_cnt * (unsigned long) sizeof *transform);
d484 1
a484 1
					    prop_cnt * (unsigned long) sizeof *transform_cnt);
d495 1
a495 1
					    prop_cnt * (unsigned long) sizeof *transform_len);
d538 1
a538 1
				    (unsigned long) sizeof **transform);
d547 1
a547 1
				    (unsigned long) sizeof **transform_len);
d606 1
a606 1
											  (u_int8_t *) & value,
d667 1
a667 1
					attr = (u_int8_t *) conf_get_str(xf->field,
d671 1
a671 1
							 (char *) attr) : 0;
d699 1
a699 1
					  (unsigned long) proposal_len);
d709 1
a709 1
				   "failed", (unsigned long) sizeof *proto);
d716 1
a716 1
						  "failed", (unsigned long) doi->proto_size);
d726 1
a726 1
				pa = (struct proto_attr *) calloc(1, sizeof *pa);
d730 1
a730 1
				pa->attrs = (u_int8_t *) malloc(pa->len);
d766 1
a766 1
			  (unsigned long) sa_len);
d881 1
a881 1
			  (unsigned long) sz, (unsigned long) sizeof(char));
d985 1
a985 1
		     (u_int8_t *) isa->skeyid_a, isa->skeyid_len));
d1000 1
a1000 1
		    - (rest - (u_int8_t *) msg->iov[0].iov_base));
d1048 1
a1048 1
				  (unsigned long) ie->id_ci_sz);
d1063 1
a1063 1
				  (unsigned long) ie->id_cr_sz);
d1097 1
a1097 1
				  (unsigned long) ie->id_cr_sz, (unsigned long) sizeof(char));
d1213 1
a1213 1
			  ISAKMP_HASH_SZ + (unsigned long) hashsize);
d1228 1
a1228 1
	prf->Update(prf->prfctx, (unsigned char *) "\0", 1);
d1299 1
a1299 1
					  (((unsigned long) ie->keymat_len +
d1399 1
a1399 1
			  (unsigned long) hash_len - ISAKMP_GEN_SZ);
d1451 1
a1451 1
				  (unsigned long) ie->id_ci_sz);
d1466 1
a1466 1
				  (unsigned long) ie->id_cr_sz);
d1500 1
a1500 1
				  (unsigned long) ie->id_ci_sz, (unsigned long) sizeof(char));
d1552 1
a1552 1
			    && !((struct ipsec_proto *) proto->data)->auth) {
d1686 1
a1686 1
			  ISAKMP_HASH_SZ + (unsigned long) hashsize);
d1715 1
a1715 1
				  (unsigned long) sz);
d1729 1
a1729 1
				  (unsigned long) sz);
d1789 1
a1789 1
		log_error("gen_g_xy: malloc (%lu) failed", (unsigned long) ie->g_x_len);
d1819 1
a1819 1
			  (unsigned long) hash_len - ISAKMP_GEN_SZ);
d1831 1
a1831 1
	prf->Update(prf->prfctx, (unsigned char *) "\0", 1);
@


1.76
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.75 2004/02/27 10:16:26 ho Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.139 2001/01/26 10:43:17 niklas Exp $	*/
d68 8
a75 8
static void gen_g_xy (struct message *);
static int initiator_send_HASH_SA_NONCE (struct message *);
static int initiator_recv_HASH_SA_NONCE (struct message *);
static int initiator_send_HASH (struct message *);
static void post_quick_mode (struct message *);
static int responder_recv_HASH_SA_NONCE (struct message *);
static int responder_send_HASH_SA_NONCE (struct message *);
static int responder_recv_HASH (struct message *);
d78 1
a78 1
static int check_policy (struct exchange *, struct sa *, struct sa *);
d81 4
a84 4
int (*ike_quick_mode_initiator[]) (struct message *) = {
  initiator_send_HASH_SA_NONCE,
  initiator_recv_HASH_SA_NONCE,
  initiator_send_HASH
d87 4
a90 4
int (*ike_quick_mode_responder[]) (struct message *) = {
  responder_recv_HASH_SA_NONCE,
  responder_send_HASH_SA_NONCE,
  responder_recv_HASH
d103 1
a103 1
check_policy (struct exchange *exchange, struct sa *sa, struct sa *isakmp_sa)
d105 5
a109 5
  char *return_values[RETVALUES_NUM];
  char **principal = 0;
  int i, len, result = 0, nprinc = 0;
  int *x509_ids = 0, *keynote_ids = 0;
  unsigned char hashbuf[20]; /* Set to the largest digest result */
d111 2
a112 2
  struct keynote_deckey dc;
  X509_NAME *subject;
d115 97
a211 110
  /* Initialize if necessary -- e.g., if pre-shared key auth was used */
  if (isakmp_sa->policy_id < 0)
    {
      if ((isakmp_sa->policy_id = kn_init ()) == -1)
        {
	  log_print ("check_policy: failed to initialize policy session");
	  return 0;
	}
    }

  /* Add the callback that will handle attributes.  */
  if (kn_add_action (isakmp_sa->policy_id, ".*", (char *) policy_callback,
		     ENVIRONMENT_FLAG_FUNC | ENVIRONMENT_FLAG_REGEX) == -1)
    {
      log_print ("check_policy: "
		 "kn_add_action (%d, \".*\", %p, FUNC | REGEX) failed",
		 isakmp_sa->policy_id, policy_callback);
      kn_close (isakmp_sa->policy_id);
      isakmp_sa->policy_id = -1;
      return 0;
    }

  if (keynote_policy_asserts_num)
    {
      keynote_ids = calloc (keynote_policy_asserts_num, sizeof *keynote_ids);
      if (!keynote_ids)
        {
	  log_error ("check_policy: calloc (%d, %lu) failed",
	     keynote_policy_asserts_num, (unsigned long)sizeof *keynote_ids);
	  return 0;
        }
    }

  /* Add the policy assertions */
  for (i = 0; i < keynote_policy_asserts_num; i++)
    keynote_ids[i] = kn_add_assertion (isakmp_sa->policy_id,
				       keynote_policy_asserts[i],
				       strlen (keynote_policy_asserts[i]),
				       ASSERT_FLAG_LOCAL);

  /* Initialize -- we'll let the callback do all the work.  */
  policy_exchange = exchange;
  policy_sa = sa;
  policy_isakmp_sa = isakmp_sa;

  /* Set the return values; true/false for now at least.  */
  return_values[0] = "false"; /* Order of values in array is important.  */
  return_values[1] = "true";

  /* Create a principal (authorizer) for the SA/ID request.  */
  switch (isakmp_sa->recv_certtype)
    {
    case ISAKMP_CERTENC_NONE:
      /*
       * For shared keys, just duplicate the passphrase with the
       * appropriate prefix tag.
       */
      nprinc = 3;
      principal = calloc (nprinc, sizeof *principal);
      if (!principal)
        {
	  log_error ("check_policy: calloc (%d, %lu) failed", nprinc,
		     (unsigned long)sizeof *principal);
	  goto policydone;
	}

      len = strlen (isakmp_sa->recv_key) + sizeof "passphrase:";
      principal[0] = calloc (len, sizeof (char));
      if (!principal[0])
        {
	  log_error ("check_policy: calloc (%d, %lu) failed", len,
		     (unsigned long)sizeof (char));
	  goto policydone;
	}

      /* XXX Consider changing the magic hash lengths with constants.  */
      strlcpy (principal[0], "passphrase:", len);
      memcpy (principal[0] + sizeof "passphrase:" - 1, isakmp_sa->recv_key,
	      strlen (isakmp_sa->recv_key));

      len = sizeof "passphrase-md5-hex:" + 2 * 16;
      principal[1] = calloc (len, sizeof (char));
      if (!principal[1])
        {
	  log_error ("check_policy: calloc (%d, %lu) failed", len,
		     (unsigned long)sizeof (char));
	  goto policydone;
	}

      strlcpy (principal[1], "passphrase-md5-hex:", len);
      MD5 (isakmp_sa->recv_key, strlen (isakmp_sa->recv_key), hashbuf);
      for (i = 0; i < 16; i++)
	snprintf (principal[1] + 2 * i + sizeof "passphrase-md5-hex:" - 1,
		  3, "%02x", hashbuf[i]);

      len = sizeof "passphrase-sha1-hex:" + 2 * 20;
      principal[2] = calloc (len, sizeof (char));
      if (!principal[2])
        {
	  log_error ("check_policy: calloc (%d, %lu) failed", len,
		     (unsigned long)sizeof (char));
	  goto policydone;
	}

      strlcpy (principal[2], "passphrase-sha1-hex:", len);
      SHA1 (isakmp_sa->recv_key, strlen (isakmp_sa->recv_key), hashbuf);
      for (i = 0; i < 20; i++)
	snprintf (principal[2] + 2 * i + sizeof "passphrase-sha1-hex:" - 1,
		  3, "%02x", hashbuf[i]);
      break;
d213 1
a213 1
    case ISAKMP_CERTENC_KEYNOTE:
d215 1
a215 1
      nprinc = 1;
d217 14
a230 17
      principal = calloc (nprinc, sizeof *principal);
      if (!principal)
        {
	  log_error ("check_policy: calloc (%d, %lu) failed", nprinc,
		     (unsigned long)sizeof *principal);
	  goto policydone;
	}

      /* Dup the keys */
      principal[0] = strdup (isakmp_sa->keynote_key);
      if (!principal[0])
        {
	  log_error ("check_policy: calloc (%lu, %lu) failed",
		     (unsigned long)strlen (isakmp_sa->keynote_key),
		     (unsigned long)sizeof (char));
	  goto policydone;
	}
d232 1
a232 1
      break;
d234 1
a234 1
    case ISAKMP_CERTENC_X509_SIG:
d236 13
a248 7
      principal = calloc (2, sizeof *principal);
      if (!principal)
        {
	  log_error ("check_policy: calloc (2, %lu) failed",
		     (unsigned long)sizeof *principal);
	  goto policydone;
	}
d250 40
a289 8
      if (isakmp_sa->recv_keytype == ISAKMP_KEY_RSA)
	dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
      else
	{
	  log_error ("check_policy: unknown/unsupported public key algorithm "
		     "%d", isakmp_sa->recv_keytype);
	  goto policydone;
	}
d291 34
a324 22
      dc.dec_key = isakmp_sa->recv_key;
      principal[0] = kn_encode_key (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
				    KEYNOTE_PUBLIC_KEY);
      if (keynote_errno == ERROR_MEMORY)
	{
	  log_print ("check_policy: failed to get memory for public key");
	  goto policydone;
	}

      if (!principal[0])
	{
	  log_print ("check_policy: failed to allocate memory for principal");
	  goto policydone;
	}

      len = strlen (principal[0]) + sizeof "rsa-hex:";
      principal[1] = calloc (len, sizeof (char));
      if (!principal[1])
	{
	  log_error ("check_policy: calloc (%d, %lu) failed", len,
		     (unsigned long)sizeof (char));
	  goto policydone;
d327 55
a381 122
      snprintf (principal[1], len, "rsa-hex:%s", principal[0]);
      free (principal[0]);
      principal[0] = principal[1];
      principal[1] = 0;

      /* Generate a "DN:" principal.  */
      subject = X509_get_subject_name (isakmp_sa->recv_cert);
      if (subject)
	{
          principal[1] = calloc (259, sizeof (char));
          if (!principal[1])
            {
	      log_error ("check_policy: calloc (259, %lu) failed",
			 (unsigned long)sizeof (char));
	      goto policydone;
            }
	  strlcpy (principal[1], "DN:", 259);
	  X509_NAME_oneline (subject, principal[1] + 3, 256);
	  nprinc = 2;
	} else {
	  nprinc = 1;
	}
      break;
#endif

    /* XXX Eventually handle these.  */
    case ISAKMP_CERTENC_PKCS:
    case ISAKMP_CERTENC_PGP:
    case ISAKMP_CERTENC_DNS:
    case ISAKMP_CERTENC_X509_KE:
    case ISAKMP_CERTENC_KERBEROS:
    case ISAKMP_CERTENC_CRL:
    case ISAKMP_CERTENC_ARL:
    case ISAKMP_CERTENC_SPKI:
    case ISAKMP_CERTENC_X509_ATTR:
    default:
      log_print ("check_policy: "
		 "unknown/unsupported certificate/authentication method %d",
		 isakmp_sa->recv_certtype);
      goto policydone;
    }

  /*
   * Add the authorizer (who is requesting the SA/ID);
   * this may be a public or a secret key, depending on
   * what mode of authentication we used in Phase 1.
   */
  for (i = 0; i < nprinc; i++)
    {
      LOG_DBG ((LOG_POLICY, 40, "check_policy: adding authorizer [%s]",
		principal[i]));

      if (kn_add_authorizer (isakmp_sa->policy_id, principal[i]) == -1)
        {
	  int j;

	  for (j = 0; j < i; j++)
	    kn_remove_authorizer (isakmp_sa->policy_id, principal[j]);
	  log_print ("check_policy: kn_add_authorizer failed");
	  goto policydone;
	}
    }

  /* Ask policy */
  result = kn_do_query (isakmp_sa->policy_id, return_values, RETVALUES_NUM);
  LOG_DBG ((LOG_POLICY, 40, "check_policy: kn_do_query returned %d", result));

  /* Cleanup environment */
  kn_cleanup_action_environment (isakmp_sa->policy_id);

  /* Remove authorizers from the session */
  for (i = 0; i < nprinc; i++)
    {
      kn_remove_authorizer (isakmp_sa->policy_id, principal[i]);
      free (principal[i]);
    }

  free (principal);
  principal = 0;
  nprinc = 0;

  /* Check what policy said.  */
  if (result < 0)
    {
      LOG_DBG ((LOG_POLICY, 40, "check_policy: proposal refused"));
      result = 0;
      goto policydone;
    }

 policydone:
  for (i = 0; i < nprinc; i++)
    if (principal && principal[i])
      free (principal[i]);

  if (principal)
    free (principal);

  /* Remove the policies */
  for (i = 0; i < keynote_policy_asserts_num; i++)
    {
      if (keynote_ids[i] != -1)
	kn_remove_assertion (isakmp_sa->policy_id, keynote_ids[i]);
    }

  if (keynote_ids)
    free (keynote_ids);

  if (x509_ids)
    free (x509_ids);

  /*
   * XXX Currently, check_policy() is only called from message_negotiate_sa(),
   *     and so this log message reflects this. Change to something better?
   */
  if (result == 0)
    log_print ("check_policy: negotiated SA failed policy check");

  /*
   * Given that we have only 2 return values from policy (true/false)
   * we can just return the query result directly (no pre-processing needed).
   */
  return result;
d383 1
a383 1
#endif /* USE_POLICY */
d390 1
a390 1
initiator_send_HASH_SA_NONCE (struct message *msg)
d392 224
a615 138
  struct exchange *exchange = msg->exchange;
  struct doi *doi = exchange->doi;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t ***transform = 0, ***new_transform;
  u_int8_t **proposal = 0, **new_proposal;
  u_int8_t *sa_buf = 0, *attr, *saved_nextp_sa, *saved_nextp_prop, *id, *spi;
  size_t spi_sz, sz;
  size_t proposal_len = 0, proposals_len = 0, sa_len;
  size_t **transform_len = 0, **new_transform_len;
  size_t *transforms_len = 0, *new_transforms_len;
  u_int32_t *transform_cnt = 0, *new_transform_cnt;
  u_int32_t suite_no, prop_no, prot_no, xf_no, prop_cnt = 0;
  u_int32_t i;
  int value, update_nextp, protocol_num, proto_id;
  struct proto *proto;
  struct conf_list *suite_conf, *prot_conf = 0, *xf_conf = 0, *life_conf;
  struct conf_list_node *suite, *prot, *xf, *life;
  struct constant_map *id_map;
  char *protocol_id, *transform_id;
  char *local_id, *remote_id;
  int group_desc = -1, new_group_desc;
  struct ipsec_sa *isa = msg->isakmp_sa->data;
  struct hash *hash = hash_get (isa->hash);
  struct sockaddr *src;
  struct proto_attr *pa;

  if (!ipsec_add_hash_payload (msg, hash->hashsize))
    return -1;

  /* Get the list of protocol suites.  */
  suite_conf = conf_get_list (exchange->policy, "Suites");
  if (!suite_conf)
    return -1;

  for (suite = TAILQ_FIRST (&suite_conf->fields), suite_no = prop_no = 0;
       suite_no < suite_conf->cnt;
       suite_no++, suite = TAILQ_NEXT (suite, link))
    {
      /* Now get each protocol in this specific protocol suite.  */
      prot_conf = conf_get_list (suite->field, "Protocols");
      if (!prot_conf)
	goto bail_out;

      for (prot = TAILQ_FIRST (&prot_conf->fields), prot_no = 0;
	   prot_no < prot_conf->cnt;
	   prot_no++, prot = TAILQ_NEXT (prot, link))
	{
	  /* Make sure we have a proposal/transform vectors.  */
	  if (prop_no >= prop_cnt)
	    {
	      /* This resize algorithm is completely arbitrary.  */
	      prop_cnt = 2 * prop_cnt + 10;
	      new_proposal = realloc (proposal, prop_cnt * sizeof *proposal);
	      if (!new_proposal)
		{
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "realloc (%p, %lu) failed",
			     proposal,
			     prop_cnt * (unsigned long)sizeof *proposal);
		  goto bail_out;
		}
	      proposal = new_proposal;

	      new_transforms_len = realloc (transforms_len,
					    prop_cnt * sizeof *transforms_len);
	      if (!new_transforms_len)
		{
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "realloc (%p, %lu) failed",
			     transforms_len,
			     prop_cnt * (unsigned long)sizeof *transforms_len);
		  goto bail_out;
		}
	      transforms_len = new_transforms_len;

	      new_transform = realloc (transform,
				       prop_cnt * sizeof *transform);
	      if (!new_transform)
		{
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "realloc (%p, %lu) failed",
			     transform,
			     prop_cnt * (unsigned long)sizeof *transform);
		  goto bail_out;
		}
	      transform = new_transform;

	      new_transform_cnt = realloc (transform_cnt,
					   prop_cnt * sizeof *transform_cnt);
	      if (!new_transform_cnt)
		{
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "realloc (%p, %lu) failed",
			     transform_cnt,
			     prop_cnt * (unsigned long)sizeof *transform_cnt);
		  goto bail_out;
		}
	      transform_cnt = new_transform_cnt;

	      new_transform_len = realloc (transform_len,
					   prop_cnt * sizeof *transform_len);
	      if (!new_transform_len)
		{
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "realloc (%p, %lu) failed",
			     transform_len,
			     prop_cnt * (unsigned long)sizeof *transform_len);
		  goto bail_out;
		}
	      transform_len = new_transform_len;
	    }

	  protocol_id = conf_get_str (prot->field, "PROTOCOL_ID");
	  if (!protocol_id)
	    goto bail_out;

	  proto_id = constant_value (ipsec_proto_cst, protocol_id);
	  switch (proto_id)
	    {
	    case IPSEC_PROTO_IPSEC_AH:
	      id_map = ipsec_ah_cst;
	      break;

	    case IPSEC_PROTO_IPSEC_ESP:
	      id_map = ipsec_esp_cst;
	      break;

	    case IPSEC_PROTO_IPCOMP:
	      id_map = ipsec_ipcomp_cst;
	      break;

	    default:
	      {
		log_print ("initiator_send_HASH_SA_NONCE: invalid PROTCOL_ID: "
			   "%s", protocol_id);
		goto bail_out;
	      }
	    }
d617 140
a756 45
	  /* Now get each transform we offer for this protocol.  */
	  xf_conf = conf_get_list (prot->field, "Transforms");
	  if (!xf_conf)
	    goto bail_out;
	  transform_cnt[prop_no] = xf_conf->cnt;

	  transform[prop_no] = calloc (transform_cnt[prop_no],
				       sizeof **transform);
	  if (!transform[prop_no])
	    {
	      log_error ("initiator_send_HASH_SA_NONCE: "
			 "calloc (%d, %lu) failed",
			 transform_cnt[prop_no],
			 (unsigned long)sizeof **transform);
	      goto bail_out;
	    }

	  transform_len[prop_no]
	    = calloc (transform_cnt[prop_no], sizeof **transform_len);
	  if (!transform_len[prop_no])
	    {
	      log_error ("initiator_send_HASH_SA_NONCE: "
			 "calloc (%d, %lu) failed",
			 transform_cnt[prop_no],
			 (unsigned long)sizeof **transform_len);
	      goto bail_out;
	    }

	  transforms_len[prop_no] = 0;
	  for (xf = TAILQ_FIRST (&xf_conf->fields), xf_no = 0;
	       xf_no < transform_cnt[prop_no];
	       xf_no++, xf = TAILQ_NEXT (xf, link))
	    {

	      /* XXX The sizing needs to be dynamic.  */
	      transform[prop_no][xf_no] = calloc (ISAKMP_TRANSFORM_SA_ATTRS_OFF
						  + 9 * ISAKMP_ATTR_VALUE_OFF,
						  1);
	      if (!transform[prop_no][xf_no])
		{
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "calloc (%d, 1) failed",
			     ISAKMP_TRANSFORM_SA_ATTRS_OFF
			     + 9 * ISAKMP_ATTR_VALUE_OFF);
		  goto bail_out;
d758 3
d762 9
a770 1
	      SET_ISAKMP_TRANSFORM_NO (transform[prop_no][xf_no], xf_no + 1);
d772 6
a777 2
	      transform_id = conf_get_str (xf->field, "TRANSFORM_ID");
	      if (!transform_id)
d779 21
a799 41
	      SET_ISAKMP_TRANSFORM_ID (transform[prop_no][xf_no],
				       constant_value (id_map, transform_id));
	      SET_ISAKMP_TRANSFORM_RESERVED (transform[prop_no][xf_no], 0);

	      attr = transform[prop_no][xf_no] + ISAKMP_TRANSFORM_SA_ATTRS_OFF;

	      /*
	       * Life durations are special, we should be able to specify
	       * several, one per type.
	       */
	      life_conf = conf_get_list (xf->field, "Life");
	      if (life_conf)
		{
		  for (life = TAILQ_FIRST (&life_conf->fields); life;
		       life = TAILQ_NEXT (life, link))
		    {
		      attribute_set_constant (life->field, "LIFE_TYPE",
					      ipsec_duration_cst,
					      IPSEC_ATTR_SA_LIFE_TYPE, &attr);

                      /* XXX Deals with 16 and 32 bit lifetimes only */
		      value = conf_get_num (life->field, "LIFE_DURATION", 0);
		      if (value)
                        {
                          if (value <= 0xffff)
			    attr =
                              attribute_set_basic (attr,
						   IPSEC_ATTR_SA_LIFE_DURATION,
						   value);
                          else
                            {
                              value = htonl (value);
                              attr =
                                attribute_set_var (attr,
                                                   IPSEC_ATTR_SA_LIFE_DURATION,
                                                   (u_int8_t *)&value,
						   sizeof value);
                            }
                        }
		    }
		  conf_free_list (life_conf);
d801 4
d806 5
a810 130
	      attribute_set_constant (xf->field, "ENCAPSULATION_MODE",
				      ipsec_encap_cst,
				      IPSEC_ATTR_ENCAPSULATION_MODE, &attr);

	      if (proto_id != IPSEC_PROTO_IPCOMP)
		{
		  attribute_set_constant (xf->field,
					  "AUTHENTICATION_ALGORITHM",
					  ipsec_auth_cst,
					  IPSEC_ATTR_AUTHENTICATION_ALGORITHM,
					  &attr);

		  attribute_set_constant (xf->field, "GROUP_DESCRIPTION",
					  ike_group_desc_cst,
					  IPSEC_ATTR_GROUP_DESCRIPTION, &attr);

		  value = conf_get_num (xf->field, "KEY_LENGTH", 0);
		  if (value)
		    attr = attribute_set_basic (attr, IPSEC_ATTR_KEY_LENGTH,
						value);

		  value = conf_get_num (xf->field, "KEY_ROUNDS", 0);
		  if (value)
		    attr = attribute_set_basic (attr, IPSEC_ATTR_KEY_ROUNDS,
						value);
		}
	      else
		{
		  value = conf_get_num (xf->field, "COMPRESS_DICTIONARY_SIZE",
					0);
		  if (value)
		    attr = attribute_set_basic (attr,
						IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE,
						value);

		  value = conf_get_num (xf->field,
					"COMPRESS_PRIVATE_ALGORITHM", 0);
		  if (value)
		    attr = attribute_set_basic (attr,
						IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM,
						value);
		}

	      value = conf_get_num (xf->field, "ECN_TUNNEL", 0);
	      if (value)
		attr = attribute_set_basic (attr, IPSEC_ATTR_ECN_TUNNEL,
					    value);

	      /* Record the real transform size.  */
	      transforms_len[prop_no] += (transform_len[prop_no][xf_no]
					  = attr - transform[prop_no][xf_no]);

	      if (proto_id != IPSEC_PROTO_IPCOMP)
		{
		  /*
		   * Make sure that if a group description is specified, it is
		   * specified for all transforms equally.
		   */
		  attr = (u_int8_t *)conf_get_str (xf->field,
						   "GROUP_DESCRIPTION");
		  new_group_desc
		    = attr ? constant_value (ike_group_desc_cst,
					     (char *)attr) : 0;
		  if (group_desc == -1)
		    group_desc = new_group_desc;
		  else if (group_desc != new_group_desc)
		    {
		      log_print ("initiator_send_HASH_SA_NONCE: "
				 "differing group descriptions in a proposal");
		      goto bail_out;
		    }
		}
	    }
	  conf_free_list (xf_conf);
	  xf_conf = 0;

	  /*
	   * Get SPI from application.
	   * XXX Should we care about unknown constants?
	   */
	  protocol_num = constant_value (ipsec_proto_cst, protocol_id);
	  spi = doi->get_spi (&spi_sz, protocol_num, msg);
	  if (spi_sz && !spi)
	    {
	      log_print ("initiator_send_HASH_SA_NONCE: doi->get_spi failed");
	      goto bail_out;
	    }

	  proposal_len = ISAKMP_PROP_SPI_OFF + spi_sz;
	  proposals_len += proposal_len + transforms_len[prop_no];
	  proposal[prop_no] = malloc (proposal_len);
	  if (!proposal[prop_no])
	    {
	      log_error ("initiator_send_HASH_SA_NONCE: malloc (%lu) failed",
			 (unsigned long)proposal_len);
	      goto bail_out;
	    }

	  SET_ISAKMP_PROP_NO (proposal[prop_no], suite_no + 1);
	  SET_ISAKMP_PROP_PROTO (proposal[prop_no], protocol_num);

	  /* XXX I would like to see this factored out.  */
	  proto = calloc (1, sizeof *proto);
	  if (!proto)
	    {
	      log_error ("initiator_send_HASH_SA_NONCE: calloc (1, %lu) "
			 "failed", (unsigned long)sizeof *proto);
	      goto bail_out;
	    }

	  if (doi->proto_size)
	    {
	      proto->data = calloc (1, doi->proto_size);
	      if (!proto->data)
		{
		  log_error ("initiator_send_HASH_SA_NONCE: calloc (1, %lu) "
			     "failed", (unsigned long)doi->proto_size);
		  goto bail_out;
		}
	    }

	  proto->no = suite_no + 1;
	  proto->proto = protocol_num;
	  proto->sa = TAILQ_FIRST (&exchange->sa_list);
	  proto->xf_cnt = transform_cnt[prop_no];
	  TAILQ_INIT (&proto->xfs);
	  for (xf_no = 0; xf_no < proto->xf_cnt; xf_no++)
	    {
	      pa = (struct proto_attr *)calloc (1, sizeof *pa);
	      if (!pa)
a811 97
	      pa->len = transform_len[prop_no][xf_no];
	      pa->attrs = (u_int8_t *)malloc (pa->len);
	      if (!pa->attrs)
		{
		  free (pa);
		  goto bail_out;
		}
	      memcpy (pa->attrs, transform[prop_no][xf_no], pa->len);
	      TAILQ_INSERT_TAIL (&proto->xfs, pa, next);
	    }
	  TAILQ_INSERT_TAIL (&TAILQ_FIRST (&exchange->sa_list)->protos, proto,
			     link);

	  /* Setup the incoming SPI.  */
	  SET_ISAKMP_PROP_SPI_SZ (proposal[prop_no], spi_sz);
	  memcpy (proposal[prop_no] + ISAKMP_PROP_SPI_OFF, spi, spi_sz);
	  proto->spi_sz[1] = spi_sz;
	  proto->spi[1] = spi;

	  /* Let the DOI get at proto for initializing its own data.  */
	  if (doi->proto_init)
	    doi->proto_init (proto, prot->field);

	  SET_ISAKMP_PROP_NTRANSFORMS (proposal[prop_no],
				       transform_cnt[prop_no]);
	  prop_no++;
	}
      conf_free_list (prot_conf);
      prot_conf = 0;
    }

  sa_len = ISAKMP_SA_SIT_OFF + IPSEC_SIT_SIT_LEN;
  sa_buf = malloc (sa_len);
  if (!sa_buf)
    {
      log_error ("initiator_send_HASH_SA_NONCE: malloc (%lu) failed",
		 (unsigned long)sa_len);
      goto bail_out;
    }
  SET_ISAKMP_SA_DOI (sa_buf, IPSEC_DOI_IPSEC);
  SET_IPSEC_SIT_SIT (sa_buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);

  /*
   * Add the payloads.  As this is a SA, we need to recompute the
   * lengths of the payloads containing others.  We also need to
   * reset these payload's "next payload type" field.
   */
  if (message_add_payload (msg, ISAKMP_PAYLOAD_SA, sa_buf, sa_len, 1))
    goto bail_out;
  SET_ISAKMP_GEN_LENGTH (sa_buf, sa_len + proposals_len);
  sa_buf = 0;

  update_nextp = 0;
  saved_nextp_sa = msg->nextp;
  for (i = 0; i < prop_no; i++)
    {
      if (message_add_payload (msg, ISAKMP_PAYLOAD_PROPOSAL, proposal[i],
			       proposal_len, update_nextp))
	goto bail_out;
      SET_ISAKMP_GEN_LENGTH (proposal[i], proposal_len + transforms_len[i]);
      proposal[i] = 0;

      update_nextp = 0;
      saved_nextp_prop = msg->nextp;
      for (xf_no = 0; xf_no < transform_cnt[i]; xf_no++)
	{
	  if (message_add_payload (msg, ISAKMP_PAYLOAD_TRANSFORM,
				   transform[i][xf_no],
				   transform_len[i][xf_no], update_nextp))
	    goto bail_out;
	  update_nextp = 1;
	  transform[i][xf_no] = 0;
	}
      msg->nextp = saved_nextp_prop;
      update_nextp = 1;
    }
  msg->nextp = saved_nextp_sa;

  /*
   * Save SA payload body in ie->sa_i_b, length ie->sa_i_b_len.
   */
  ie->sa_i_b = message_copy (msg, ISAKMP_GEN_SZ, &ie->sa_i_b_len);
  if (!ie->sa_i_b)
    goto bail_out;

  /*
   * Generate a nonce, and add it to the message.
   * XXX I want a better way to specify the nonce's size.
   */
  if (exchange_gen_nonce (msg, 16))
    return -1;

  /* Generate optional KEY_EXCH payload.  */
  if (group_desc > 0)
    {
      ie->group = group_get (group_desc);
      ie->g_x_len = dh_getlen (ie->group);
d813 17
a829 22
      if (ipsec_gen_g_x (msg))
	{
	  group_free (ie->group);
	  ie->group = 0;
	  return -1;
	}
    }

  /* Generate optional client ID payloads.  XXX Share with responder.  */
  local_id = conf_get_str (exchange->name, "Local-ID");
  remote_id = conf_get_str (exchange->name, "Remote-ID");
  if (local_id && remote_id)
    {
      id = ipsec_build_id (local_id, &sz);
      if (!id)
	return -1;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDic",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
d831 22
a852 10

      id = ipsec_build_id (remote_id, &sz);
      if (!id)
	return -1;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDrc",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
d854 45
a898 21
    }
  /* XXX I do not judge these as errors, are they?  */
  else if (local_id)
    log_print ("initiator_send_HASH_SA_NONCE: "
	       "Local-ID given without Remote-ID for \"%s\"",
	       exchange->name);
  else if (remote_id)
    /* This code supports the "road warrior" case, where the initiator doesn't
     * have a fixed IP address, but wants to specify a particular remote
     * network to talk to.
     * -- Adrian Close <adrian@@esec.com.au>
     */
    {
      log_print ("initiator_send_HASH_SA_NONCE: "
	       "Remote-ID given without Local-ID for \"%s\"",
	       exchange->name);

      /* If we're here, then we are the initiator, so use initiator
	address for local ID */
      msg->transport->vtbl->get_src (msg->transport, &src);
      sz = ISAKMP_ID_SZ + sockaddr_addrlen (src);
d900 16
a915 6
      id = calloc (sz, sizeof (char));
      if (!id)
	{
	  log_error ("initiator_send_HASH_SA_NONCE: calloc (%lu, %lu) failed",
		     (unsigned long)sz, (unsigned long)sizeof (char));
	  return -1;
d917 2
d920 39
a958 28
      switch (src->sa_family)
	{
	case AF_INET6:
	  SET_ISAKMP_ID_TYPE (id, IPSEC_ID_IPV6_ADDR);
	  break;
	case AF_INET:
	  SET_ISAKMP_ID_TYPE (id, IPSEC_ID_IPV4_ADDR);
	  break;
	default:
	  log_error ("initiator_send_HASH_SA_NONCE: unknown sa_family %d",
		     src->sa_family);
	  free (id);
	  return -1;
	}
      memcpy (id + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (src),
	      sockaddr_addrlen (src));

      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDic",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
	}

      /* Send supplied remote_id */
      id = ipsec_build_id (remote_id, &sz);
      if (!id)
a959 56
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDrc",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
	}
    }

  if (ipsec_fill_in_hash (msg))
    goto bail_out;

  conf_free_list (suite_conf);
  for (i = 0; i < prop_no; i++)
    {
      free (transform[i]);
      free (transform_len[i]);
    }
  free (proposal);
  free (transform);
  free (transforms_len);
  free (transform_len);
  free (transform_cnt);
  return 0;

 bail_out:
  if (sa_buf)
    free (sa_buf);
  if (proposal)
    {
      for (i = 0; i < prop_no; i++)
	{
	  if (proposal[i])
	    free (proposal[i]);
	  if (transform[i])
	    {
	      for (xf_no = 0; xf_no < transform_cnt[i]; xf_no++)
		if (transform[i][xf_no])
		  free (transform[i][xf_no]);
	      free (transform[i]);
	    }
	  if (transform_len[i])
	    free (transform_len[i]);
	}
      free (proposal);
      free (transforms_len);
      free (transform);
      free (transform_len);
      free (transform_cnt);
    }
  if (xf_conf)
    conf_free_list (xf_conf);
  if (prot_conf)
    conf_free_list (prot_conf);
  conf_free_list (suite_conf);
  return -1;
d964 1
a964 1
initiator_recv_HASH_SA_NONCE (struct message *msg)
d966 174
a1139 81
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct sa *sa;
  struct proto *proto, *next_proto;
  struct payload *sa_p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SA]);
  struct payload *xf, *idp;
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  struct payload *kep = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
  struct prf *prf;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct hash *hash = hash_get (isa->hash);
  size_t hashsize = hash->hashsize;
  u_int8_t *rest;
  size_t rest_len;
  struct sockaddr *src, *dst;

  /* Allocate the prf and start calculating our HASH(1).  XXX Share?  */
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: SKEYID_a",
		(u_int8_t *)isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"initiator_recv_HASH_SA_NONCE: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: NONCE_I_b",
		exchange->nonce_i, exchange->nonce_i_len));
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  rest = hashp->p + GET_ISAKMP_GEN_LENGTH (hashp->p);
  rest_len = (GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base)
	      - (rest - (u_int8_t*)msg->iov[0].iov_base));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"initiator_recv_HASH_SA_NONCE: payloads after HASH(2)", rest,
		rest_len));
  prf->Update (prf->prfctx, rest, rest_len);
  prf->Final (hash->digest, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"initiator_recv_HASH_SA_NONCE: computed HASH(2)",
		hash->digest, hashsize));
  if (memcmp (hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest, hashsize) != 0)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      return -1;
    }
  /* Mark the HASH as handled.  */
  hashp->flags |= PL_MARK;

  /*
   * As we are getting an answer on our transform offer, only one transform
   * should be given.
   *
   * XXX Currently we only support negotiating one SA per quick mode run.
   */
  if (TAILQ_NEXT (sa_p, link))
    {
      log_print ("initiator_recv_HASH_SA_NONCE: "
		 "multiple SA payloads in quick mode not supported yet");
      return -1;
    }

  sa = TAILQ_FIRST (&exchange->sa_list);

  /* This is here for the policy check */
  if (kep)
    ie->pfs = 1;

  /* Handle optional client ID payloads.  */
  idp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ID]);
  if (idp)
    {
      /* If IDci is there, IDcr must be too.  */
      if (!TAILQ_NEXT (idp, link))
	{
	  /* XXX Is this a good notify type?  */
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
	  return -1;
d1142 3
a1144 55
      /* XXX We should really compare, not override.  */
      ie->id_ci_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
      ie->id_ci = malloc (ie->id_ci_sz);
      if (!ie->id_ci)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)ie->id_ci_sz);
	  return -1;
	}
      memcpy (ie->id_ci, idp->p, ie->id_ci_sz);
      idp->flags |= PL_MARK;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		    "initiator_recv_HASH_SA_NONCE: IDci",
		    ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz
		    - ISAKMP_GEN_SZ));

      idp = TAILQ_NEXT (idp, link);
      ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
      ie->id_cr = malloc (ie->id_cr_sz);
      if (!ie->id_cr)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)ie->id_cr_sz);
	  return -1;
	}
      memcpy (ie->id_cr, idp->p, ie->id_cr_sz);
      idp->flags |= PL_MARK;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		    "initiator_recv_HASH_SA_NONCE: IDcr",
		    ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz
		    - ISAKMP_GEN_SZ));
    }
  else
    {
      /*
       * If client identifiers are not present in the exchange,
       * we fake them. RFC 2409 states:
       *    The identities of the SAs negotiated in Quick Mode are
       *    implicitly assumed to be the IP addresses of the ISAKMP
       *    peers, without any constraints on the protocol or port
       *    numbers allowed, unless client identifiers are specified
       *    in Quick Mode.
       *
       * -- Michael Paddon (mwp@@aba.net.au)
       */

      ie->flags = IPSEC_EXCH_FLAG_NO_ID;

      /* Get initiator and responder addresses.  */
      msg->transport->vtbl->get_src (msg->transport, &src);
      msg->transport->vtbl->get_dst (msg->transport, &dst);
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen (src);
      ie->id_cr_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen (dst);
      ie->id_ci = calloc (ie->id_ci_sz, sizeof (char));
      ie->id_cr = calloc (ie->id_cr_sz, sizeof (char));
d1146 4
a1149 16
      if (!ie->id_ci || !ie->id_cr)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: calloc (%lu, %lu) failed",
		     (unsigned long)ie->id_cr_sz, (unsigned long)sizeof (char));
	  if (ie->id_ci)
	    {
	      free (ie->id_ci);
	      ie->id_ci = 0;
	    }
	  if (ie->id_cr)
	    {
	      free (ie->id_cr);
	      ie->id_cr = 0;
	    }
	  return -1;
	}
d1151 2
a1152 9
      if (src->sa_family != dst->sa_family)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: sa_family mismatch");
	  free (ie->id_ci);
	  ie->id_ci = 0;
	  free (ie->id_cr);
	  ie->id_cr = 0;
	  return -1;
	}
d1154 1
a1154 11
      switch (src->sa_family)
	{
	case AF_INET:
	  SET_ISAKMP_ID_TYPE (ie->id_ci, IPSEC_ID_IPV4_ADDR);
	  SET_ISAKMP_ID_TYPE (ie->id_cr, IPSEC_ID_IPV4_ADDR);
	  break;

	case AF_INET6:
	  SET_ISAKMP_ID_TYPE (ie->id_ci, IPSEC_ID_IPV6_ADDR);
	  SET_ISAKMP_ID_TYPE (ie->id_cr, IPSEC_ID_IPV6_ADDR);
	  break;
d1156 2
a1157 24
	default:
	  log_error ("initiator_recv_HASH_SA_NONCE: unknown sa_family %d",
		     src->sa_family);
	  free (ie->id_ci);
	  ie->id_ci = 0;
	  free (ie->id_cr);
	  ie->id_cr = 0;
	  return -1;
	}
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (src),
	      sockaddr_addrlen (src));
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (dst),
	      sockaddr_addrlen (dst));
    }

  /* Build the protection suite in our SA.  */
  for (xf = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]); xf;
       xf = TAILQ_NEXT (xf, link))
    {

      /*
       * XXX We could check that the proposal each transform belongs to
       * is unique.
       */
d1159 6
a1164 15
      if (sa_add_transform (sa, xf, exchange->initiator, &proto))
	return -1;

      /* XXX Check that the chosen transform matches an offer.  */

      ipsec_decode_transform (msg, sa, proto, xf->p);
    }

  /* Now remove offers that we don't need anymore.  */
  for (proto = TAILQ_FIRST (&sa->protos); proto; proto = next_proto)
    {
      next_proto = TAILQ_NEXT (proto, link);
      if (!proto->chosen)
	proto_free (proto);
    }
d1167 5
a1171 6
  if (!check_policy (exchange, sa, msg->isakmp_sa))
    {
      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
      log_print ("initiator_recv_HASH_SA_NONCE: policy check failed");
      return -1;
    }
d1174 2
a1175 2
  /* Mark the SA as handled.  */
  sa_p->flags |= PL_MARK;
d1177 13
a1189 15
  isa = sa->data;
  if ((isa->group_desc && (!ie->group || ie->group->id != isa->group_desc))
      || (!isa->group_desc && ie->group))
    {
      log_print ("initiator_recv_HASH_SA_NONCE: disagreement on PFS");
      return -1;
    }

  /* Copy out the initiator's nonce.  */
  if (exchange_save_nonce (msg))
    return -1;

  /* Handle the optional KEY_EXCH payload.  */
  if (kep && ipsec_save_g_x (msg))
    return -1;
d1191 1
a1191 1
  return 0;
d1195 1
a1195 1
initiator_send_HASH (struct message *msg)
d1197 45
a1241 45
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct prf *prf;
  u_int8_t *buf;
  struct hash *hash = hash_get (isa->hash);
  size_t hashsize = hash->hashsize;

  /* We want a HASH payload to start with.  XXX Share with ike_main_mode.c?  */
  buf = malloc (ISAKMP_HASH_SZ + hashsize);
  if (!buf)
    {
      log_error ("initiator_send_HASH: malloc (%lu) failed",
		 ISAKMP_HASH_SZ + (unsigned long)hashsize);
      return -1;
    }
  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, buf,
			   ISAKMP_HASH_SZ + hashsize, 1))
    {
      free (buf);
      return -1;
    }

  /* Allocate the prf and start calculating our HASH(3).  XXX Share?  */
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;
  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, (unsigned char *)"\0", 1);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: NONCE_I_b",
		exchange->nonce_i, exchange->nonce_i_len));
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: NONCE_R_b",
		exchange->nonce_r, exchange->nonce_r_len));
  prf->Update (prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
  prf->Final (buf + ISAKMP_GEN_SZ, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: HASH(3)",
		buf + ISAKMP_GEN_SZ, hashsize));
d1243 2
a1244 2
  if (ie->group)
    message_register_post_send (msg, gen_g_xy);
d1246 1
a1246 1
  message_register_post_send (msg, post_quick_mode);
d1248 1
a1248 1
  return 0;
d1252 1
a1252 1
post_quick_mode (struct message *msg)
d1254 99
a1352 22
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct prf *prf;
  struct sa *sa;
  struct proto *proto;
  struct ipsec_proto *iproto;
  u_int8_t *keymat;
  int i;

  /*
   * Loop over all SA negotiations and do both an in- and an outgoing SA
   * per protocol.
   */
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = TAILQ_NEXT (sa, next))
    {
      for (proto = TAILQ_FIRST (&sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	{
	  if (proto->proto == IPSEC_PROTO_IPCOMP)
	    continue;
d1354 5
a1358 90
	  iproto = proto->data;

	  /*
	   * There are two SAs for each SA negotiation, incoming and outcoing.
	   */
	  for (i = 0; i < 2; i++)
	    {
	      prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_d,
			       isa->skeyid_len);
	      if (!prf)
		{
		  /* XXX What to do?  */
		  continue;
		}

	      ie->keymat_len = ipsec_keymat_length (proto);

	      /*
	       * We need to roundup the length of the key material buffer
	       * to a multiple of the PRF's blocksize as it is generated
	       * in chunks of that blocksize.
	       */
	      iproto->keymat[i]
		= malloc (((ie->keymat_len + prf->blocksize - 1)
			   / prf->blocksize) * prf->blocksize);
	      if (!iproto->keymat[i])
		{
		  log_error ("post_quick_mode: malloc (%lu) failed",
			     (((unsigned long)ie->keymat_len +
			       prf->blocksize - 1) / prf->blocksize) *
			     prf->blocksize);
		  /* XXX What more to do?  */
		  free (prf);
		  continue;
		}

	      for (keymat = iproto->keymat[i];
		   keymat < iproto->keymat[i] + ie->keymat_len;
		   keymat += prf->blocksize)
		{
		  prf->Init (prf->prfctx);

		  if (keymat != iproto->keymat[i])
		    {
		      /* Hash in last round's KEYMAT.  */
		      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
				    "post_quick_mode: last KEYMAT",
				    keymat - prf->blocksize,
				    prf->blocksize));
		      prf->Update (prf->prfctx, keymat - prf->blocksize,
				   prf->blocksize);
		    }

		  /* If PFS is used hash in g^xy.  */
		  if (ie->g_xy)
		    {
		      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
				    "post_quick_mode: g^xy", ie->g_xy,
				    ie->g_x_len));
		      prf->Update (prf->prfctx, ie->g_xy, ie->g_x_len);
		    }
		  LOG_DBG ((LOG_NEGOTIATION, 90,
			    "post_quick_mode: suite %d proto %d", proto->no,
			    proto->proto));
		  prf->Update (prf->prfctx, &proto->proto, 1);
		  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: SPI",
				proto->spi[i], proto->spi_sz[i]));
		  prf->Update (prf->prfctx, proto->spi[i], proto->spi_sz[i]);
		  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: Ni_b",
				exchange->nonce_i, exchange->nonce_i_len));
		  prf->Update (prf->prfctx, exchange->nonce_i,
			       exchange->nonce_i_len);
		  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: Nr_b",
				exchange->nonce_r, exchange->nonce_r_len));
		  prf->Update (prf->prfctx, exchange->nonce_r,
			       exchange->nonce_r_len);
		  prf->Final (keymat, prf->prfctx);
		}
	      prf_free (prf);
	      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: KEYMAT",
			    iproto->keymat[i], ie->keymat_len));
	    }
	}
    }

  log_verbose ("isakmpd: quick mode done: %s",
	           !msg->isakmp_sa || !msg->isakmp_sa->transport
		   ? "<no transport>"
		   : msg->isakmp_sa->transport->vtbl->decode_ids
		   (msg->isakmp_sa ->transport));
d1367 1
a1367 1
responder_recv_HASH_SA_NONCE (struct message *msg)
d1369 154
a1522 152
  struct payload *hashp, *kep, *idp;
  struct sa *sa;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct prf *prf;
  u_int8_t *hash, *my_hash = 0;
  size_t hash_len;
  u_int8_t *pkt = msg->iov[0].iov_base;
  u_int8_t group_desc = 0;
  int retval = -1;
  struct proto *proto;
  struct sockaddr *src, *dst;
  char *name;

  hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  hash = hashp->p;
  hashp->flags |= PL_MARK;

  /* The HASH payload should be the first one.  */
  if (hash != pkt + ISAKMP_HDR_SZ)
    {
      /* XXX Is there a better notification type?  */
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      goto cleanup;
    }
  hash_len = GET_ISAKMP_GEN_LENGTH (hash);
  my_hash = malloc (hash_len - ISAKMP_GEN_SZ);
  if (!my_hash)
    {
      log_error ("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
		 (unsigned long)hash_len - ISAKMP_GEN_SZ);
      goto cleanup;
    }

  /*
   * Check the payload's integrity.
   * XXX Share with ipsec_fill_in_hash?
   */
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH_SA_NONCE: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    goto cleanup;
  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"responder_recv_HASH_SA_NONCE: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"responder_recv_HASH_SA_NONCE: message after HASH",
		hash + hash_len,
		msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len));
  prf->Update (prf->prfctx, hash + hash_len,
	       msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
  prf->Final (my_hash, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"responder_recv_HASH_SA_NONCE: computed HASH(1)", my_hash,
		hash_len - ISAKMP_GEN_SZ));
  if (memcmp (hash + ISAKMP_GEN_SZ, my_hash, hash_len - ISAKMP_GEN_SZ) != 0)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      goto cleanup;
    }
  free (my_hash);
  my_hash = 0;

  kep = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
  if (kep)
    ie->pfs = 1;

  /* Handle optional client ID payloads.  */
  idp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ID]);
  if (idp)
    {
      /* If IDci is there, IDcr must be too.  */
      if (!TAILQ_NEXT (idp, link))
	{
	  /* XXX Is this a good notify type?  */
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
	  goto cleanup;
	}

      ie->id_ci_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
      ie->id_ci = malloc (ie->id_ci_sz);
      if (!ie->id_ci)
	{
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)ie->id_ci_sz);
	  goto cleanup;
	}
      memcpy (ie->id_ci, idp->p, ie->id_ci_sz);
      idp->flags |= PL_MARK;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		    "responder_recv_HASH_SA_NONCE: IDci",
		    ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz
		    - ISAKMP_GEN_SZ));

      idp = TAILQ_NEXT (idp, link);
      ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
      ie->id_cr = malloc (ie->id_cr_sz);
      if (!ie->id_cr)
	{
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)ie->id_cr_sz);
	  goto cleanup;
	}
      memcpy (ie->id_cr, idp->p, ie->id_cr_sz);
      idp->flags |= PL_MARK;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		    "responder_recv_HASH_SA_NONCE: IDcr",
		    ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz
		    - ISAKMP_GEN_SZ));
    }
  else
    {
      /*
       * If client identifiers are not present in the exchange,
       * we fake them. RFC 2409 states:
       *    The identities of the SAs negotiated in Quick Mode are
       *    implicitly assumed to be the IP addresses of the ISAKMP
       *    peers, without any constraints on the protocol or port
       *    numbers allowed, unless client identifiers are specified
       *    in Quick Mode.
       *
       * -- Michael Paddon (mwp@@aba.net.au)
       */

      ie->flags = IPSEC_EXCH_FLAG_NO_ID;

      /* Get initiator and responder addresses.  */
      msg->transport->vtbl->get_src (msg->transport, &src);
      msg->transport->vtbl->get_dst (msg->transport, &dst);
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen (src);
      ie->id_cr_sz = ISAKMP_ID_DATA_OFF + sockaddr_addrlen (dst);
      ie->id_ci = calloc (ie->id_ci_sz, sizeof (char));
      ie->id_cr = calloc (ie->id_cr_sz, sizeof (char));

      if (!ie->id_ci || !ie->id_cr)
	{
	  log_error ("responder_recv_HASH_SA_NONCE: calloc (%lu, %lu) failed",
		     (unsigned long)ie->id_ci_sz, (unsigned long)sizeof (char));
	  goto cleanup;
	}

      if (src->sa_family != dst->sa_family)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: sa_family mismatch");
	  goto cleanup;
	}
d1524 4
a1527 16
      switch (src->sa_family)
	{
	case AF_INET:
	  SET_ISAKMP_ID_TYPE (ie->id_ci, IPSEC_ID_IPV4_ADDR);
	  SET_ISAKMP_ID_TYPE (ie->id_cr, IPSEC_ID_IPV4_ADDR);
	  break;

	case AF_INET6:
	  SET_ISAKMP_ID_TYPE (ie->id_ci, IPSEC_ID_IPV6_ADDR);
	  SET_ISAKMP_ID_TYPE (ie->id_cr, IPSEC_ID_IPV6_ADDR);
	  break;

	default:
	  log_error ("initiator_recv_HASH_SA_NONCE: unknown sa_family %d",
		     src->sa_family);
	  goto cleanup;
a1529 6
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (src),
	      sockaddr_addrlen (src));
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (dst),
	      sockaddr_addrlen (dst));
    }

d1532 2
a1533 2
  if (message_negotiate_sa (msg, check_policy))
    goto cleanup;
d1535 2
a1536 2
  if (message_negotiate_sa (msg, 0))
    goto cleanup;
d1539 49
a1587 19
  if (message_negotiate_sa (msg, 0))
    goto cleanup;
#endif /* USE_POLICY */

  for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = TAILQ_NEXT (sa, next))
    {
      for (proto = TAILQ_FIRST (&sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	{
	  /* XXX we need to have some attributes per proto, not all per SA.  */
	  ipsec_decode_transform (msg, sa, proto, proto->chosen->p);
	  if (proto->proto == IPSEC_PROTO_IPSEC_AH
	      && !((struct ipsec_proto *)proto->data)->auth)
	    {
	      log_print ("responder_recv_HASH_SA_NONCE: "
			 "AH proposed without an algorithm attribute");
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	      goto next_sa;
	    }
d1590 44
a1633 1
      isa = sa->data;
d1635 2
a1636 69
      /* The group description is mandatory if we got a KEY_EXCH payload.  */
      if (kep)
	{
	  if (!isa->group_desc)
	    {
	      log_print ("responder_recv_HASH_SA_NONCE: "
			 "KEY_EXCH payload without a group desc. attribute");
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	      continue;
	    }

	  /* Also, all SAs must have equal groups.  */
	  if (!group_desc)
	    group_desc = isa->group_desc;
	  else if (group_desc != isa->group_desc)
	    {
	      log_print ("responder_recv_HASH_SA_NONCE: "
			 "differing group descriptions in one QM");
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	      continue;
	    }
	}

      /* At least one SA was accepted.  */
      retval = 0;

    next_sa:
      ; /* XXX gcc3 wants this. */
    }

  if (kep)
    {
      ie->group = group_get (group_desc);
      if (!ie->group)
	{
	  /*
	   * XXX If the error was due to an out-of-range group description
	   * we should notify our peer, but this should probably be done
	   * by the attribute validation.  Is it?
	   */
	  goto cleanup;
	}
    }

  /* Copy out the initiator's nonce.  */
  if (exchange_save_nonce (msg))
    goto cleanup;

  /* Handle the optional KEY_EXCH payload.  */
  if (kep && ipsec_save_g_x (msg))
    goto cleanup;

  /*
   * Try to find and set the connection name on the exchange.
   */

  /*
   * Check for accepted identities as well as lookup the connection
   * name and set it on the exchange.
   */
  name = connection_passive_lookup_by_ids (ie->id_ci, ie->id_cr);
  if (name)
    {
      exchange->name = strdup (name);
      if (!exchange->name)
	{
	  log_error ("responder_recv_HASH_SA_NONCE: strdup (\"%s\") failed",
		     name);
	  goto cleanup;
d1638 1
a1638 15
    }
#if !defined (USE_POLICY) && !defined (USE_KEYNOTE)
  else
    {
      /*
       * This code is no longer necessary, as policy determines acceptance
       * of IDs/SAs. (angelos@@openbsd.org)
       *
       * XXX Keep it if not USE_POLICY for now, though.
       */

      /* XXX Notify peer and log.  */
      goto cleanup;
    }
#endif /* !USE_POLICY && !USE_KEYNOTE */
d1640 1
a1640 1
  return retval;
d1643 15
a1657 17
  /* Remove all potential protocols that have been added to the SAs.  */
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = TAILQ_NEXT (sa, next))
    while ((proto = TAILQ_FIRST (&sa->protos)) != 0)
      proto_free (proto);
  if (my_hash)
    free (my_hash);
  if (ie->id_ci)
    {
      free (ie->id_ci);
      ie->id_ci = 0;
    }
  if (ie->id_cr)
    {
      free (ie->id_cr);
      ie->id_cr = 0;
    }
  return -1;
d1662 1
a1662 1
responder_send_HASH_SA_NONCE (struct message *msg)
d1664 75
a1738 60
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct prf *prf;
  struct hash *hash = hash_get (isa->hash);
  size_t hashsize = hash->hashsize;
  size_t nonce_sz = exchange->nonce_i_len;
  u_int8_t *buf;
  int initiator = exchange->initiator;
  char header[80];
  u_int32_t i;
  u_int8_t *id;
  size_t sz;

  /* We want a HASH payload to start with.  XXX Share with ike_main_mode.c?  */
  buf = malloc (ISAKMP_HASH_SZ + hashsize);
  if (!buf)
    {
      log_error ("responder_send_HASH_SA_NONCE: malloc (%lu) failed",
		 ISAKMP_HASH_SZ + (unsigned long)hashsize);
      return -1;
    }
  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, buf,
			   ISAKMP_HASH_SZ + hashsize, 1))
    {
      free (buf);
      return -1;
    }

  /* Add the SA payload(s) with the transform(s) that was/were chosen.  */
  if (message_add_sa_payload (msg))
    return -1;

  /* Generate a nonce, and add it to the message.  */
  if (exchange_gen_nonce (msg, nonce_sz))
    return -1;

  /* Generate optional KEY_EXCH payload.  This is known as PFS.  */
  if (ie->group && ipsec_gen_g_x (msg))
    return -1;

  /* If the initiator client ID's were acceptable, just mirror them back.  */
  if (!(ie->flags & IPSEC_EXCH_FLAG_NO_ID))
    {
      sz = ie->id_ci_sz;
      id = malloc (sz);
      if (!id)
	{
	  log_error ("responder_send_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)sz);
	  return -1;
	}
      memcpy (id, ie->id_ci, sz);
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: IDic",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
d1740 33
d1774 2
a1775 17
      sz = ie->id_cr_sz;
      id = malloc (sz);
      if (!id)
	{
	  log_error ("responder_send_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)sz);
	  return -1;
	}
      memcpy (id, ie->id_cr, sz);
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: IDrc",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
	}
    }
d1777 1
a1777 39
  /* Allocate the prf and start calculating our HASH(2).  XXX Share?  */
  LOG_DBG ((LOG_NEGOTIATION, 90, "responder_recv_HASH: isakmp_sa %p isa %p",
	    isakmp_sa, isa));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;
  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"responder_send_HASH_SA_NONCE: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: NONCE_I_b",
		exchange->nonce_i, exchange->nonce_i_len));
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);

  /* Loop over all payloads after HASH(2).  */
  for (i = 2; i < msg->iovlen; i++)
    {
      /* XXX Misleading payload type printouts.  */
      snprintf (header, sizeof header,
		"responder_send_HASH_SA_NONCE: payload %d after HASH(2)",
		i - 1);
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, header, msg->iov[i].iov_base,
		    msg->iov[i].iov_len));
      prf->Update (prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
    }
  prf->Final (buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
  prf_free (prf);
  snprintf (header, sizeof header, "responder_send_HASH_SA_NONCE: HASH_%c",
	    initiator ? 'I' : 'R');
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, header, buf + ISAKMP_HASH_DATA_OFF,
		hashsize));

  if (ie->group)
    message_register_post_send (msg, gen_g_xy);

  return 0;
d1781 1
a1781 1
gen_g_xy (struct message *msg)
d1783 2
a1784 2
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
d1786 12
a1797 14
  /* Compute Diffie-Hellman shared value.  */
  ie->g_xy = malloc (ie->g_x_len);
  if (!ie->g_xy)
    {
      log_error ("gen_g_xy: malloc (%lu) failed", (unsigned long)ie->g_x_len);
      return;
    }
  if (dh_create_shared (ie->group, ie->g_xy,
			exchange->initiator ? ie->g_xr : ie->g_xi))
    {
      log_print ("gen_g_xy: dh_create_shared failed");
      return;
    }
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, "gen_g_xy: g^xy", ie->g_xy, ie->g_x_len));
d1801 1
a1801 1
responder_recv_HASH (struct message *msg)
d1803 57
a1859 60
  struct exchange *exchange = msg->exchange;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct prf *prf;
  u_int8_t *hash, *my_hash = 0;
  size_t hash_len;
  struct payload *hashp;

  /* Find HASH(3) and create our own hash, just as big.  */
  hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  hash = hashp->p;
  hashp->flags |= PL_MARK;
  hash_len = GET_ISAKMP_GEN_LENGTH (hash);
  my_hash = malloc (hash_len - ISAKMP_GEN_SZ);
  if (!my_hash)
    {
      log_error ("responder_recv_HASH: malloc (%lu) failed",
		 (unsigned long)hash_len - ISAKMP_GEN_SZ);
      goto cleanup;
    }

  /* Allocate the prf and start calculating our HASH(3).  XXX Share?  */
  LOG_DBG ((LOG_NEGOTIATION, 90, "responder_recv_HASH: isakmp_sa %p isa %p",
	    isakmp_sa, isa));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, isa->hash, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    goto cleanup;
  prf->Init (prf->prfctx);
  prf->Update (prf->prfctx, (unsigned char *)"\0", 1);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: NONCE_I_b",
		exchange->nonce_i, exchange->nonce_i_len));
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: NONCE_R_b",
		exchange->nonce_r, exchange->nonce_r_len));
  prf->Update (prf->prfctx, exchange->nonce_r, exchange->nonce_r_len);
  prf->Final (my_hash, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"responder_recv_HASH: computed HASH(3)", my_hash,
		hash_len - ISAKMP_GEN_SZ));
  if (memcmp (hash + ISAKMP_GEN_SZ, my_hash, hash_len - ISAKMP_GEN_SZ) != 0)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      goto cleanup;
    }
  free (my_hash);

  post_quick_mode (msg);

  return 0;

 cleanup:
  if (my_hash)
    free (my_hash);
  return -1;
@


1.75
log
@(C)-2004
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.74 2004/02/27 09:01:18 ho Exp $	*/
d435 4
a438 3
  int *transform_cnt = 0, *new_transform_cnt;
  int i, suite_no, prop_no, prot_no, xf_no, value, update_nextp, protocol_num;
  int prop_cnt = 0, proto_id;
d1808 1
a1808 1
  int i;
@


1.75.2.1
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.75 2004/02/27 10:16:26 ho Exp $	*/
a1543 3
  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;

a1992 3

  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;
@


1.74
log
@Follow RFC 2408 more closely regarding how to better check the proposal
returned by the other peer (the responder). Some implementations (notably
the Cisco PIX) does not follow a SHOULD in section 4.2 of the RFC. With
certain proposal combinations this caused us to setup the wrong SA
resulting in us being unable to process incoming IPsec traffic (over this
tunnel).

Tested against a number of different IKE implementations.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.73 2004/02/20 11:31:10 hshoexer Exp $	*/
d7 1
a7 1
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
@


1.73
log
@More small adjustments of log messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.72 2004/02/20 09:46:56 hshoexer Exp $	*/
d448 1
d782 17
@


1.72
log
@Fix some double free errors.  While around, adjust a log message.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.71 2004/01/16 10:51:57 hshoexer Exp $	*/
d142 2
a143 3
	  log_error ("check_policy: "
	     "failed to allocate %lu bytes for book keeping",
	     keynote_policy_asserts_num * (unsigned long)sizeof *keynote_ids);
d928 2
a929 2
	  log_error ("initiator_send_HASH_SA_NONCE: malloc(%lu) failed",
		     (unsigned long)sz);
d1599 2
a1600 2
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)ie->id_ci_sz);
@


1.71
log
@Added -v option.  Enables logging of successful exchange completion.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.70 2003/06/10 16:41:29 deraadt Exp $	*/
d1166 2
a1167 2
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%lu) failed",
		     (unsigned long)ie->id_cr_sz);
d1169 4
a1172 1
	    free (ie->id_ci);
d1174 4
a1177 1
	    free (ie->id_cr);
d1185 1
d1187 1
d1207 1
d1209 1
d1763 4
a1766 1
    free (ie->id_ci);
d1768 4
a1771 1
    free (ie->id_cr);
@


1.70
log
@boring cleanups
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.69 2003/06/04 07:31:16 ho Exp $	*/
d1432 6
@


1.70.2.1
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.70 2003/06/10 16:41:29 deraadt Exp $	*/
d1166 2
a1167 2
	  log_error ("initiator_recv_HASH_SA_NONCE: calloc (%lu, %lu) failed",
	             (unsigned long)ie->id_cr_sz, (unsigned long)sizeof (char));
d1169 1
a1169 4
	    {
	      free (ie->id_ci);
	      ie->id_ci = 0;
	    }
d1171 1
a1171 4
	    {
	      free (ie->id_cr);
	      ie->id_cr = 0;
	    }
a1178 1
	  ie->id_ci = 0;
a1179 1
	  ie->id_cr = 0;
a1198 1
	  ie->id_ci = 0;
a1199 1
	  ie->id_cr = 0;
d1747 1
a1747 4
    {
      free (ie->id_ci);
      ie->id_ci = 0;
    }
d1749 1
a1749 4
    {
      free (ie->id_cr);
      ie->id_cr = 0;
    }
@


1.70.2.2
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.70.2.1 2004/03/17 14:59:17 brad Exp $	*/
a1520 3
  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;

a1969 3

  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;
@


1.69
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.68 2003/06/03 12:51:39 ho Exp $	*/
d643 1
a643 1
	              				   value);
@


1.68
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.67 2002/09/11 09:50:43 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.67
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.66 2002/06/14 12:43:11 ho Exp $	*/
d1863 1
a1863 1
      snprintf (header, 80,
d1872 1
a1872 1
  snprintf (header, 80, "responder_send_HASH_SA_NONCE: HASH_%c",
@


1.67.4.1
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.67 2002/09/11 09:50:43 ho Exp $	*/
d1171 2
a1172 2
	  log_error ("initiator_recv_HASH_SA_NONCE: calloc (%lu, %lu) failed",
	             (unsigned long)ie->id_cr_sz, (unsigned long)sizeof (char));
d1174 1
a1174 4
	    {
	      free (ie->id_ci);
	      ie->id_ci = 0;
	    }
d1176 1
a1176 4
	    {
	      free (ie->id_cr);
	      ie->id_cr = 0;
	    }
a1183 1
	  ie->id_ci = 0;
a1184 1
	  ie->id_cr = 0;
a1203 1
	  ie->id_ci = 0;
a1204 1
	  ie->id_cr = 0;
d1752 1
a1752 4
    {
      free (ie->id_ci);
      ie->id_ci = 0;
    }
d1754 1
a1754 4
    {
      free (ie->id_cr);
      ie->id_cr = 0;
    }
@


1.66
log
@Recognize the ECN_TUNNEL attribute.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.65 2002/06/11 18:56:07 ho Exp $	*/
d655 1
a655 1
                                                   (char *)&value,
d721 2
a722 1
		  attr = conf_get_str (xf->field, "GROUP_DESCRIPTION");
d724 2
a725 1
		    = attr ? constant_value (ike_group_desc_cst, attr) : 0;
d1049 1
a1049 1
		isa->skeyid_a, isa->skeyid_len));
d1304 1
a1304 1
  prf->Update (prf->prfctx, "\0", 1);
d1938 1
a1938 1
  prf->Update (prf->prfctx, "\0", 1);
@


1.65
log
@Various IPComp-related mods
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.64 2002/06/10 20:45:35 ho Exp $	*/
d705 5
@


1.64
log
@Zap a few remaining libkeynote refs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.63 2002/06/10 18:08:58 ho Exp $	*/
d443 1
a443 1
  int prop_cnt = 0;
d545 22
a566 6
	  /* XXX Not too beautiful, but do we have a choice?  */
	  id_map = strcasecmp (protocol_id, "IPSEC_AH") == 0 ? ipsec_ah_cst
	    : strcasecmp (protocol_id, "IPSEC_ESP") == 0 ? ipsec_esp_cst
	    : strcasecmp (protocol_id, "IPCOMP") == 0 ? ipsec_ipcomp_cst : 0;
	  if (!id_map)
	    goto bail_out;
d667 38
a704 34
	      attribute_set_constant (xf->field, "AUTHENTICATION_ALGORITHM",
				      ipsec_auth_cst,
				      IPSEC_ATTR_AUTHENTICATION_ALGORITHM,
				      &attr);

	      attribute_set_constant (xf->field, "GROUP_DESCRIPTION",
				      ike_group_desc_cst,
				      IPSEC_ATTR_GROUP_DESCRIPTION, &attr);


	      value = conf_get_num (xf->field, "KEY_LENGTH", 0);
	      if (value)
		attr = attribute_set_basic (attr, IPSEC_ATTR_KEY_LENGTH,
					    value);

	      value = conf_get_num (xf->field, "KEY_ROUNDS", 0);
	      if (value)
		attr = attribute_set_basic (attr, IPSEC_ATTR_KEY_ROUNDS,
					    value);

	      value = conf_get_num (xf->field, "COMPRESS_DICTIONARY_SIZE", 0);
	      if (value)
		attr
		  = attribute_set_basic (attr,
					 IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE,
					 value);

	      value
		= conf_get_num (xf->field, "COMPRESS_PRIVATE_ALGORITHM", 0);
	      if (value)
		attr
		  = attribute_set_basic (attr,
					 IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM,
					 value);
d710 1
a710 10
	      /*
	       * Make sure that if a group description is specified, it is
	       * specified for all transforms equally.
	       */
	      attr = conf_get_str (xf->field, "GROUP_DESCRIPTION");
	      new_group_desc
		= attr ? constant_value (ike_group_desc_cst, attr) : 0;
	      if (group_desc == -1)
		group_desc = new_group_desc;
	      else if (group_desc != new_group_desc)
d712 15
a726 3
		  log_print ("initiator_send_HASH_SA_NONCE: "
			     "differing group descriptions in a proposal");
		  goto bail_out;
d761 2
a762 2
	      log_error ("initiator_send_HASH_SA_NONCE: calloc (1, %lu) failed",
			 (unsigned long)sizeof *proto);
d771 2
a772 3
		  log_error ("initiator_send_HASH_SA_NONCE: "
			     "calloc (1, %lu) failed",
			     (unsigned long)doi->proto_size);
d863 1
a863 1
  if (group_desc)
d957 1
a957 1
    /* Send supplied remote_id */
d1343 3
@


1.63
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.62 2002/06/07 21:59:22 ho Exp $	*/
d1597 1
a1597 1
  if (message_negotiate_sa (msg, libkeynote ? check_policy : 0))
a1695 3
#ifdef USE_POLICY
  else if (!libkeynote)
#else
a1696 1
#endif
@


1.62
log
@Avoid some gcc3 warnings. From David Krause <openbsd@@davidkrause.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.61 2002/06/06 02:15:27 ho Exp $	*/
d123 1
a123 1
      if ((isakmp_sa->policy_id = LK (kn_init, ())) == -1)
d131 2
a132 4
  if (LK (kn_add_action, (isakmp_sa->policy_id, ".*",
			  (char *) policy_callback,
			  ENVIRONMENT_FLAG_FUNC | ENVIRONMENT_FLAG_REGEX))
      == -1)
d137 1
a137 1
      LK (kn_close, (isakmp_sa->policy_id));
d156 4
a159 4
    keynote_ids[i] = LK (kn_add_assertion, (isakmp_sa->policy_id,
					    keynote_policy_asserts[i],
					    strlen (keynote_policy_asserts[i]),
					    ASSERT_FLAG_LOCAL));
d276 3
a278 3
      principal[0] = LK (kn_encode_key, (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
					 KEYNOTE_PUBLIC_KEY));
      if (LKV (keynote_errno) == ERROR_MEMORY)
d305 1
a305 1
      subject = LC (X509_get_subject_name, (isakmp_sa->recv_cert));
d316 1
a316 1
	  LC (X509_NAME_oneline, (subject, principal[1] + 3, 256));
d351 1
a351 1
      if (LK (kn_add_authorizer, (isakmp_sa->policy_id, principal[i])) == -1)
d356 1
a356 1
	    LK (kn_remove_authorizer, (isakmp_sa->policy_id, principal[j]));
d363 1
a363 2
  result = LK (kn_do_query, (isakmp_sa->policy_id, return_values,
			     RETVALUES_NUM));
d367 1
a367 1
  LK (kn_cleanup_action_environment, (isakmp_sa->policy_id));
d372 1
a372 1
      LK (kn_remove_authorizer, (isakmp_sa->policy_id, principal[i]));
d400 1
a400 1
	LK (kn_remove_assertion, (isakmp_sa->policy_id, keynote_ids[i]));
@


1.61
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.60 2002/06/01 07:44:21 deraadt Exp $	*/
d1654 1
@


1.60
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.59 2002/03/06 09:43:08 ho Exp $	*/
d251 2
a252 2
	     (unsigned long)strlen (isakmp_sa->keynote_key),
	    (unsigned long)sizeof (char));
d264 1
a264 1
		(unsigned long)sizeof *principal);
d297 1
a297 1
		(unsigned long)sizeof (char));
d489 2
a490 1
			     proposal, prop_cnt * (unsigned long)sizeof *proposal);
d513 2
a514 1
			     transform, prop_cnt * (unsigned long)sizeof *transform);
d525 2
a526 1
			     transform_cnt, prop_cnt * (unsigned long)sizeof *transform_cnt);
d567 2
a568 1
			 transform_cnt[prop_no], (unsigned long)sizeof **transform);
d578 2
a579 1
			 transform_cnt[prop_no], (unsigned long)sizeof **transform_len);
d753 1
a753 1
			    (unsigned long)doi->proto_size);
d787 1
a787 1
	(unsigned long)sa_len);
d909 1
a909 1
		(unsigned long)sz);
d1352 3
a1354 2
			     (((unsigned long)ie->keymat_len + prf->blocksize - 1)
			      / prf->blocksize) * prf->blocksize);
d1786 1
a1786 1
		(unsigned long)sz);
d1803 1
a1803 1
		(unsigned long)sz);
@


1.59
log
@Unbreak MD5 and SHA1 passphrases in policy check. From
<chris@@stallion.oz.au>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.58 2002/01/23 18:44:47 ho Exp $	*/
d150 2
a151 2
		     "failed to allocate %d bytes for book keeping",
		     keynote_policy_asserts_num * sizeof *keynote_ids);
d184 2
a185 2
	  log_error ("check_policy: calloc (%d, %d) failed", nprinc,
		     sizeof *principal);
d193 2
a194 2
	  log_error ("check_policy: calloc (%d, %d) failed", len,
		     sizeof (char));
d207 2
a208 2
	  log_error ("check_policy: calloc (%d, %d) failed", len,
		     sizeof (char));
d222 2
a223 2
	  log_error ("check_policy: calloc (%d, %d) failed", len,
		     sizeof (char));
d241 2
a242 2
	  log_error ("check_policy: calloc (%d, %d) failed", nprinc,
		     sizeof *principal);
d250 3
a252 2
	  log_error ("check_policy: calloc (%d, %d) failed",
		     strlen (isakmp_sa->keynote_key), sizeof (char));
d263 2
a264 1
	  log_error ("check_policy: calloc (2, %d) failed", sizeof *principal);
d296 2
a297 2
	  log_error ("check_policy: calloc (%d, %d) failed", len,
		     sizeof (char));
d313 2
a314 2
	      log_error ("check_policy: calloc (259, %d) failed",
			 sizeof (char));
d488 2
a489 2
			     "realloc (%p, %d) failed",
			     proposal, prop_cnt * sizeof *proposal);
d499 1
a499 1
			     "realloc (%p, %d) failed",
d501 1
a501 1
			     prop_cnt * sizeof *transforms_len);
d511 2
a512 2
			     "realloc (%p, %d) failed",
			     transform, prop_cnt * sizeof *transform);
d522 2
a523 2
			     "realloc (%p, %d) failed",
			     transform_cnt, prop_cnt * sizeof *transform_cnt);
d533 3
a535 2
			     "realloc (%p, %d) failed",
			     transform_len, prop_cnt * sizeof *transform_len);
d563 2
a564 2
			 "calloc (%d, %d) failed",
			 transform_cnt[prop_no], sizeof **transform);
d573 2
a574 2
			 "calloc (%d, %d) failed",
			 transform_cnt[prop_no], sizeof **transform_len);
d724 2
a725 2
	      log_error ("initiator_send_HASH_SA_NONCE: malloc (%d) failed",
			 proposal_len);
d736 2
a737 2
	      log_error ("initiator_send_HASH_SA_NONCE: calloc (1, %d) failed",
			 sizeof *proto);
d747 2
a748 1
			     "calloc (1, %d) failed", doi->proto_size);
d781 2
a782 1
      log_error ("initiator_send_HASH_SA_NONCE: malloc (%d) failed", sa_len);
d903 2
a904 1
	  log_error ("initiator_send_HASH_SA_NONCE: malloc(%d) failed", sz);
d1087 2
a1088 2
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_ci_sz);
d1103 2
a1104 2
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_cr_sz);
d1140 2
a1141 2
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_cr_sz);
d1255 2
a1256 2
      log_error ("initiator_send_HASH: malloc (%d) failed",
		 ISAKMP_HASH_SZ + hashsize);
d1346 2
a1347 2
		  log_error ("post_quick_mode: malloc (%d) failed",
			     ((ie->keymat_len + prf->blocksize - 1)
d1443 2
a1444 2
      log_error ("responder_recv_HASH_SA_NONCE: malloc (%d) failed",
		 hash_len - ISAKMP_GEN_SZ);
d1501 2
a1502 2
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_ci_sz);
d1517 2
a1518 2
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_cr_sz);
d1554 2
a1555 2
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_ci_sz);
d1749 2
a1750 2
      log_error ("responder_send_HASH_SA_NONCE: malloc (%d) failed",
		 ISAKMP_HASH_SZ + hashsize);
d1779 2
a1780 1
	  log_error ("responder_send_HASH_SA_NONCE: malloc (%d) failed", sz);
d1796 2
a1797 1
	  log_error ("responder_send_HASH_SA_NONCE: malloc (%d) failed", sz);
d1861 1
a1861 1
      log_error ("gen_g_xy: malloc (%d) failed", ie->g_x_len);
d1892 2
a1893 2
      log_error ("responder_recv_HASH: malloc (%d) failed",
		 hash_len - ISAKMP_GEN_SZ);
@


1.58
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.57 2002/01/23 17:16:42 ho Exp $	*/
d216 1
a216 1
		  2, "%02x", hashbuf[i]);
d231 1
a231 1
		  2, "%02x", hashbuf[i]);
@


1.57
log
@strcpy->strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.56 2001/10/26 12:03:07 ho Exp $	*/
d215 2
a216 2
	sprintf (principal[1] + 2 * i + sizeof "passphrase-md5-hex:" - 1,
		 "%02x", hashbuf[i]);
d230 2
a231 2
	sprintf (principal[2] + 2 * i + sizeof "passphrase-sha1-hex:" - 1,
		 "%02x", hashbuf[i]);
d290 2
a291 2
      principal[1] = calloc (strlen (principal[0]) + sizeof "rsa-hex:",
			     sizeof (char));
d294 2
a295 2
	  log_error ("check_policy: calloc (%d, %d) failed",
		     strlen (principal[0]) + sizeof "rsa-hex:", sizeof (char));
d299 1
a299 1
      sprintf (principal[1], "rsa-hex:%s", principal[0]);
@


1.56
log
@Just rename sockaddr_data/len functions to sockaddr_addrdata/addrlen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.55 2001/10/05 05:57:06 ho Exp $	*/
d112 1
a112 1
  int i, result = 0, nprinc = 0;
d189 2
a190 2
      principal[0] = calloc (strlen (isakmp_sa->recv_key)
			     + sizeof "passphrase:", sizeof (char));
d193 1
a193 2
	  log_error ("check_policy: calloc (%d, %d) failed",
		     strlen (isakmp_sa->recv_key) + sizeof "passphrase:",
d199 1
a199 1
      strcpy (principal[0], "passphrase:");
d203 2
a204 2
      principal[1] = calloc (sizeof "passphrase-md5-hex:" + 2 * 16,
			     sizeof (char));
d207 2
a208 2
	  log_error ("check_policy: calloc (%d, %d) failed",
		     sizeof "passphrase-md5-hex:" + 2 * 16, sizeof (char));
d212 1
a212 1
      strcpy (principal[1], "passphrase-md5-hex:");
d218 2
a219 2
      principal[2] = calloc (sizeof "passphrase-sha1-hex:" + 2 * 20,
			     sizeof (char));
d222 2
a223 2
	  log_error ("check_policy: calloc (%d, %d) failed",
		     sizeof "passphrase-sha1-hex:" + 2 * 20, sizeof (char));
d227 1
a227 1
      strcpy (principal[2], "passphrase-sha1-hex:");
d315 1
a315 1
	  strcpy (principal[1], "DN:");
@


1.55
log
@Some more debug level fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.54 2001/08/15 13:06:53 ho Exp $	*/
d894 1
a894 1
      sz = ISAKMP_ID_SZ + sockaddr_len (src);
d917 2
a918 2
      memcpy (id + ISAKMP_ID_DATA_OFF, sockaddr_data (src),
	      sockaddr_len (src));
d1128 2
a1129 2
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_len (src);
      ie->id_cr_sz = ISAKMP_ID_DATA_OFF + sockaddr_len (dst);
d1171 4
a1174 4
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_data (src),
	      sockaddr_len (src));
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_data (dst),
	      sockaddr_len (dst));
d1542 2
a1543 2
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_len (src);
      ie->id_cr_sz = ISAKMP_ID_DATA_OFF + sockaddr_len (dst);
d1578 4
a1581 4
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_data (src),
	      sockaddr_len (src));
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_data (dst),
	      sockaddr_len (dst));
@


1.54
log
@Some more style...
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.53 2001/07/01 20:11:53 niklas Exp $	*/
d1804 1
a1804 1
  LOG_DBG ((LOG_NEGOTIATION, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
d1891 1
a1891 1
  LOG_DBG ((LOG_NEGOTIATION, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
@


1.53
log
@More Style police, but also sane checking of address
family vs stated ID-type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.52 2001/06/29 18:52:16 ho Exp $	*/
d42 1
a42 1
#if defined(USE_POLICY) || defined(USE_KEYNOTE)
@


1.52
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.51 2001/06/29 17:59:34 ho Exp $	*/
d111 1
a111 1
  char **principal = NULL;
d113 1
a113 1
  int *x509_ids = NULL, *keynote_ids = NULL;
d182 1
a182 1
      if (principal == NULL)
d184 2
a185 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     nprinc * sizeof *principal);
d189 3
a191 3
      principal[0] = calloc (strlen (isakmp_sa->recv_key) + 1 +
			     strlen ("passphrase:"), sizeof (char));
      if (principal[0] == NULL)
d193 3
a195 3
	  log_error ("check_policy: failed to allocate %d bytes",
		     strlen (isakmp_sa->recv_key) + 1 +
		     strlen ("passphrase:"));
d199 1
d201 1
a201 1
      memcpy (principal[0] + strlen ("passphrase:"), isakmp_sa->recv_key,
d204 3
a206 3
      principal[1] = calloc (strlen ("passphrase-md5-hex:") +
			     32 + 1, sizeof (char));
      if (principal[1] == NULL)
d208 2
a209 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     strlen ("passphrase-md5-hex:") + 33);
d216 1
a216 1
	sprintf (principal[1] + (2 * i) + strlen ("passphrase-md5-hex:"),
d218 4
a221 4
      
      principal[2] = calloc (strlen ("passphrase-sha1-hex:") +
			     32 + 1, sizeof (char));
      if (principal[2] == NULL)
d223 2
a224 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     strlen ("passphrase-sha1-hex:") + 33);
d231 1
a231 1
	sprintf (principal[2] + (2 * i) + strlen ("passphrase-sha1-hex:"),
d240 1
a240 1
      if (principal == NULL)
d242 2
a243 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     nprinc * sizeof *principal);
d249 1
a249 1
      if (principal[0] == NULL)
d251 2
a252 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     strlen (isakmp_sa->keynote_key));
d261 1
a261 1
      if (principal == NULL)
d263 1
a263 1
	  log_error ("check_policy: failed to get memory for principal");
d285 1
a285 1
      if (principal[0] == NULL)
d291 1
a291 1
      principal[1] = calloc (strlen (principal[0]) + strlen ("rsa-hex:") + 1,
d293 1
a293 1
      if (principal[1] == NULL)
d295 2
a296 1
	  log_error ("check_policy: failed to allocate memory for principal");
d300 1
a300 2
      strcpy (principal[1], "rsa-hex:");
      strcpy (principal[1] + strlen ("rsa-hex:"), principal[0]);
d303 1
a303 1
      principal[1] = NULL;
d305 1
a305 1
      /* Generate a "DN:" principal */
d310 1
a310 1
          if (principal[1] == NULL)
d312 2
a313 1
	      log_error ("check_policy: failed to allocate memory for principal[1]");
d379 1
a379 1
  principal = NULL;
d882 1
a882 1
     * have a fixed IP address, but wants to specify a particular remote 
d885 1
a885 1
     */ 
d917 1
a917 1
      memcpy (id + ISAKMP_ID_DATA_OFF, sockaddr_data (src), 
d1019 1
a1019 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
d1158 1
d1163 1
d1173 1
a1173 1
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF, sockaddr_data (dst), 
d1262 1
a1262 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: SKEYID_a", 
d1369 2
a1370 2
		      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
				    "post_quick_mode: g^xy", ie->g_xy, 
d1453 1
a1453 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
d1551 1
a1551 1
	  goto cleanup; 
d1566 1
d1571 1
d1577 1
d1580 1
a1580 1
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF, sockaddr_data (dst), 
d1812 2
a1813 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
		"responder_send_HASH_SA_NONCE: message_id", 
@


1.51
log
@Be consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.50 2001/06/27 00:16:30 ho Exp $	*/
a453 1
  socklen_t srclen;
d891 1
a891 1
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
a1007 1
  socklen_t srclen, dstlen;
d1124 2
a1125 2
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
      msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
a1416 1
  socklen_t srclen, dstlen;
d1536 2
a1537 2
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
      msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
@


1.50
log
@IPv6. Also avoid a couple of mem leaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.49 2001/06/07 04:45:42 angelos Exp $	*/
d1541 1
a1541 1
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF + sockaddr_len (dst);
@


1.49
log
@Get rid of useless x509_policy_asserts[]
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.48 2001/05/31 20:27:50 angelos Exp $	*/
d893 1
a893 3

      sz = ISAKMP_ID_SZ 
	+ sizeof (((struct sockaddr_in *)src)->sin_addr.s_addr);
d900 1
a900 2
	}  
      SET_ISAKMP_ID_TYPE (id, IPSEC_ID_IPV4_ADDR);
d902 16
a917 2
      encode_32 (id + ISAKMP_ID_DATA_OFF,
	      ntohl (((struct sockaddr_in *)src)->sin_addr.s_addr));
a939 1

d1125 2
a1126 1
      /* Get responder address.  */
d1128 3
a1130 2
      ie->id_cr_sz = ISAKMP_ID_DATA_OFF
	+ sizeof ((struct sockaddr_in *)dst)->sin_addr.s_addr;
d1132 2
a1133 1
      if (!ie->id_cr)
d1137 12
a1150 4
      SET_ISAKMP_ID_TYPE (ie->id_cr, IPSEC_ID_IPV4_ADDR);
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF,
	      &((struct sockaddr_in *)dst)->sin_addr.s_addr,
	      sizeof ((struct sockaddr_in *)dst)->sin_addr.s_addr);
d1152 1
a1152 6
      /* Get initiator address.  */
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF
	+ sizeof ((struct sockaddr_in *)dst)->sin_addr.s_addr;
      ie->id_ci = calloc (ie->id_ci_sz, sizeof (char));
      if (!ie->id_ci)
d1154 13
a1166 2
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_ci_sz);
d1169 4
a1172 4
      SET_ISAKMP_ID_TYPE (ie->id_ci, IPSEC_ID_IPV4_ADDR);
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF,
	      &((struct sockaddr_in *)src)->sin_addr.s_addr,
	      sizeof ((struct sockaddr_in *)src)->sin_addr.s_addr);
d1488 1
a1488 1
	  return -1;
d1538 2
a1539 1
      /* Get initiator address.  */
d1541 2
a1542 2
      ie->id_ci_sz = ISAKMP_ID_DATA_OFF
	+ sizeof ((struct sockaddr_in *)dst)->sin_addr.s_addr;
d1544 3
a1546 1
      if (!ie->id_ci)
d1550 6
a1557 4
      SET_ISAKMP_ID_TYPE (ie->id_ci, IPSEC_ID_IPV4_ADDR);
      memcpy (ie->id_ci + ISAKMP_ID_DATA_OFF,
	      &((struct sockaddr_in *)dst)->sin_addr.s_addr,
	      sizeof ((struct sockaddr_in *)dst)->sin_addr.s_addr);
d1559 1
a1559 6
      /* Get responder address.  */
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
      ie->id_cr_sz = ISAKMP_ID_DATA_OFF
	+ sizeof ((struct sockaddr_in *)dst)->sin_addr.s_addr;
      ie->id_cr = calloc (ie->id_cr_sz, sizeof (char));
      if (!ie->id_cr)
d1561 11
a1571 2
	  log_error ("responder_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_cr_sz);
d1574 4
a1577 4
      SET_ISAKMP_ID_TYPE (ie->id_cr, IPSEC_ID_IPV4_ADDR);
      memcpy (ie->id_cr + ISAKMP_ID_DATA_OFF,
	      &((struct sockaddr_in *)src)->sin_addr.s_addr,
	      sizeof ((struct sockaddr_in *)src)->sin_addr.s_addr);
d1710 4
@


1.48
log
@Store/retrieve the right information in terms of keys.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.47 2001/04/09 12:34:37 ho Exp $	*/
a155 13
  if (x509_policy_asserts_num)
    {
      x509_ids = calloc (x509_policy_asserts_num, sizeof *x509_ids);
      if (!x509_ids)
        {
          log_error ("check_policy: "
		     "failed to allocate %d bytes for book keeping",
		     x509_policy_asserts_num * sizeof *x509_ids);
          free (keynote_ids);
          return 0;
        }
    }

a162 6
  for (i = 0; i < x509_policy_asserts_num; i++)
    x509_ids[i] = LK (kn_add_assertion, (isakmp_sa->policy_id,
					 x509_policy_asserts[i],
					 strlen (x509_policy_asserts[i]),
					 ASSERT_FLAG_LOCAL));

a400 6
    }

  for (i = 0; i < x509_policy_asserts_num; i++)
    {
      if (x509_ids[i] != -1)
	LK (kn_remove_assertion, (isakmp_sa->policy_id, x509_ids[i]));
@


1.47
log
@Style police a'la niklas@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.46 2001/03/13 14:05:18 ho Exp $	*/
d67 2
a117 1
  RSA *key;
d208 1
a208 1
      principal[0] = calloc (isakmp_sa->recv_certlen + 1 +
d213 2
a214 1
		     isakmp_sa->recv_certlen + 1 + strlen ("passphrase:"));
d219 2
a220 2
      memcpy (principal[0] + strlen ("passphrase:"), isakmp_sa->recv_cert,
	      isakmp_sa->recv_certlen);
d232 1
a232 1
      MD5 (isakmp_sa->recv_cert, isakmp_sa->recv_certlen, hashbuf);
d247 1
a247 1
      SHA1 (isakmp_sa->recv_cert, isakmp_sa->recv_certlen, hashbuf);
d266 1
a266 1
      principal[0] = strdup (isakmp_sa->recv_key);
d270 1
a270 1
		     strlen (isakmp_sa->recv_key));
a277 7
      /* Retrieve key from certificate.  */
      if (!x509_cert_get_key (isakmp_sa->recv_cert, &key))
	{
	  log_print ("check_policy: failed to get key from X509 cert");
	  goto policydone;
	}

d285 10
a294 3
      /* XXX RSA-specific.  */
      dc.dec_algorithm = KEYNOTE_ALGORITHM_RSA;
      dc.dec_key = (void *) key;
a299 1
	  LC (RSA_free, (key));
a305 1
	  LC (RSA_free, (key));
a313 1
	  LC (RSA_free, (key));
a319 1
      LC (RSA_free, (key));
a330 1
	      LC (RSA_free, (key));
@


1.46
log
@Add logging classes for Negotiation and Policy, and change a number of
debug messages to use these instead. Change a number of 'log_print'
to debug messages to keep the noise down. Use 'log_error' instead of
'log_print' in some cases when we have errno. Some indentation fixes.
(niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.45 2001/02/19 16:58:04 angelos Exp $	*/
d199 1
a199 1
      principal = calloc (nprinc, sizeof(*principal));
d203 1
a203 1
		     nprinc * sizeof(*principal));
d255 1
a255 1
      principal = calloc (nprinc, sizeof(*principal));
d259 1
a259 1
		     nprinc * sizeof(*principal));
d283 1
a283 1
      principal = calloc (2, sizeof(*principal));
@


1.45
log
@passphrase-md5-hex: and passphrase-sha1-hex: formats for passphrases.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.44 2001/02/08 22:37:34 angelos Exp $	*/
d148 4
a151 4
            log_print ("check_policy: "
		       "failed to allocate %d bytes for book keeping",
		       keynote_policy_asserts_num * sizeof *keynote_ids);
            return 0;
d160 1
a160 1
          log_print ("check_policy: "
d202 1
a202 1
	  log_print ("check_policy: failed to allocate %d bytes",
d211 1
a211 1
	  log_print ("check_policy: failed to allocate %d bytes",
d224 3
a226 3
	    log_print ("check_policy: failed to allocate %d bytes",
		       strlen ("passphrase-md5-hex:") + 33);
	    goto policydone;
d239 3
a241 3
	    log_print ("check_policy: failed to allocate %d bytes",
		       strlen ("passphrase-sha1-hex:") + 33);
	    goto policydone;
d258 1
a258 1
	  log_print ("check_policy: failed to allocate %d bytes",
d267 1
a267 1
	  log_print ("check_policy: failed to allocate %d bytes",
d286 1
a286 1
	  log_print ("check_policy: failed to get memory for principal");
d313 1
a313 1
	  log_print ("check_policy: failed to allocate memory for principal");
d332 1
a332 1
	      log_print ("check_policy: failed to allocate memory for principal[1]");
d369 1
a369 1
      LOG_DBG ((LOG_MISC, 40, "check_policy: adding authorizer [%s]",
d386 1
a386 1
  LOG_DBG ((LOG_MISC, 40, "check_policy: kn_do_query returned %d", result));
d405 1
a405 1
      LOG_DBG ((LOG_MISC, 40, "check_policy: proposal refused"));
d883 2
a884 2
      LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: IDic", id,
		    sz));
d894 2
a895 2
      LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: IDrc", id,
		    sz));
d936 2
a937 2
      LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: IDic", id,
		    sz));
d948 2
a949 2
      LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: IDrc", id,
		    sz));
d1030 1
a1030 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: SKEYID_a",
d1037 2
a1038 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: message_id",
d1041 1
a1041 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: NONCE_I_b",
d1047 1
a1047 1
  LOG_DBG_BUF ((LOG_MISC, 90,
d1053 1
a1053 1
  LOG_DBG_BUF ((LOG_MISC, 80,
d1106 1
a1106 1
      LOG_DBG_BUF ((LOG_MISC, 90,
d1122 1
a1122 1
      LOG_DBG_BUF ((LOG_MISC, 90,
d1261 2
a1262 2
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
d1268 1
a1268 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH: message_id",
d1271 1
a1271 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH: NONCE_I_b",
d1274 1
a1274 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH: NONCE_R_b",
d1279 1
a1279 1
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_send_HASH: HASH(3)",
d1357 1
a1357 1
		      LOG_DBG_BUF ((LOG_MISC, 90,
d1368 3
a1370 2
		      LOG_DBG_BUF ((LOG_MISC, 90, "post_quick_mode: g^xy",
				    ie->g_xy, ie->g_x_len));
d1373 1
a1373 1
		  LOG_DBG ((LOG_MISC, 90,
d1377 1
a1377 1
		  LOG_DBG_BUF ((LOG_MISC, 90, "post_quick_mode: SPI",
d1380 1
a1380 1
		  LOG_DBG_BUF ((LOG_MISC, 90, "post_quick_mode: Ni_b",
d1384 1
a1384 1
		  LOG_DBG_BUF ((LOG_MISC, 90, "post_quick_mode: Nr_b",
d1391 1
a1391 1
	      LOG_DBG_BUF ((LOG_MISC, 90, "post_quick_mode: KEYMAT",
d1447 1
a1447 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_recv_HASH_SA_NONCE: SKEYID_a",
d1453 2
a1454 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_recv_HASH_SA_NONCE: message_id",
d1457 1
a1457 1
  LOG_DBG_BUF ((LOG_MISC, 90,
d1465 1
a1465 1
  LOG_DBG_BUF ((LOG_MISC, 90,
d1502 1
a1502 1
      LOG_DBG_BUF ((LOG_MISC, 90,
d1518 1
a1518 1
      LOG_DBG_BUF ((LOG_MISC, 90,
d1762 2
a1763 2
      LOG_DBG_BUF ((LOG_MISC, 90, "responder_send_HASH_SA_NONCE: IDic", id,
		    sz));
d1778 2
a1779 2
      LOG_DBG_BUF ((LOG_MISC, 90, "responder_send_HASH_SA_NONCE: IDrc", id,
		    sz));
d1788 1
a1788 1
  LOG_DBG ((LOG_MISC, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
d1790 1
a1790 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_send_HASH_SA_NONCE: SKEYID_a",
d1796 2
a1797 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_send_HASH_SA_NONCE: message_id",
d1800 1
a1800 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_send_HASH_SA_NONCE: NONCE_I_b",
d1811 1
a1811 1
      LOG_DBG_BUF ((LOG_MISC, 90, header, msg->iov[i].iov_base,
d1819 2
a1820 1
  LOG_DBG_BUF ((LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize));
d1847 1
a1847 1
  LOG_DBG_BUF ((LOG_MISC, 80, "gen_g_xy: g^xy", ie->g_xy, ie->g_x_len));
d1875 1
a1875 1
  LOG_DBG ((LOG_MISC, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
d1877 2
a1878 2
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_recv_HASH: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
d1884 1
a1884 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_recv_HASH: message_id",
d1887 1
a1887 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_recv_HASH: NONCE_I_b",
d1890 1
a1890 1
  LOG_DBG_BUF ((LOG_MISC, 90, "responder_recv_HASH: NONCE_R_b",
d1895 1
a1895 1
  LOG_DBG_BUF ((LOG_MISC, 90,
@


1.44
log
@Add debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.43 2001/01/27 12:03:33 niklas Exp $	*/
d112 1
d198 1
a198 1
      nprinc = 1;
a212 1
	  free (principal);
d219 30
a268 1
	  free (principal);
a298 1
	  free (principal);
a305 1
	  free (principal);
a313 2
	  free (principal[0]);
	  free (principal);
a332 2
	      free (principal[0]);
	      free (principal);
d369 3
a371 1
      LOG_DBG ((LOG_MISC, 40, "check_policy: adding authorizer [%s]", principal[i]));
d377 1
a377 10
	    {
		LK (kn_remove_authorizer, (isakmp_sa->policy_id,
					   principal[j]));
		free (principal[j]);
	    }

	  for (; j < nprinc; j++)
	    free (principal[j]);

	  free (principal);
d383 1
a383 1
  /* Ask policy.  */
d391 1
a391 1
  /* Remove authorizers from the session.  */
d399 2
d405 1
a405 1
	LOG_DBG ((LOG_MISC, 40, "check_policy: proposal refused"));
d411 7
@


1.43
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.42 2001/01/26 12:12:51 niklas Exp $	*/
d346 1
@


1.42
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.41 2001/01/26 11:08:43 niklas Exp $	*/
d5 3
a7 3
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2000 Håkan Olsson.  All rights reserved.
@


1.41
log
@Merge with EOM 1.139

author: niklas
Remove blank line

author: ho
Print warning with log_print, not log_error.

author: ho
Report if doi->get_spi() fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.40 2001/01/14 23:09:11 angelos Exp $	*/
d144 2
a145 2
      keynote_ids = calloc (keynote_policy_asserts_num, sizeof(int));
      if (keynote_ids == NULL)
d147 3
a149 1
            log_print ("check_policy: failed to allocate %d bytes for book keeping", keynote_policy_asserts_num * sizeof(int));
d156 2
a157 2
      x509_ids = calloc (x509_policy_asserts_num, sizeof(int));
      if (x509_ids == NULL)
d159 3
a161 1
          log_print ("check_policy: failed to allocate %d bytes for book keeping", x509_policy_asserts_num * sizeof(int));
d193 4
a196 2
      /* For shared keys, just duplicate the passphrase with the
         appropriate prefix tag. */
d763 1
a763 1
	  /* Let the DOI get at proto for initializing its own data. */
@


1.40
log
@Do the HASH verification before handling the SA payload.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.39 2001/01/10 18:16:26 angelos Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.135 2000/10/16 18:16:59 provos Exp $	*/
a448 1

d707 4
a710 1
	    goto bail_out;
@


1.39
log
@If only the Remote-ID is specified for a Phase 2 configuration, use
our address for Local-ID; useful for road-warrior scenarios
(adrian@@lion.aba.net.au)
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.38 2000/10/16 23:29:07 niklas Exp $	*/
d995 34
a1177 34

  /* Allocate the prf and start calculating our HASH(1).  XXX Share?  */
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: NONCE_I_b",
		exchange->nonce_i, exchange->nonce_i_len));
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  rest = hashp->p + GET_ISAKMP_GEN_LENGTH (hashp->p);
  rest_len = (GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base)
	      - (rest - (u_int8_t*)msg->iov[0].iov_base));
  LOG_DBG_BUF ((LOG_MISC, 90,
		"initiator_recv_HASH_SA_NONCE: payloads after HASH(2)", rest,
		rest_len));
  prf->Update (prf->prfctx, rest, rest_len);
  prf->Final (hash->digest, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_MISC, 80,
		"initiator_recv_HASH_SA_NONCE: computed HASH(2)",
		hash->digest, hashsize));
  if (memcmp (hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest, hashsize) != 0)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      return -1;
    }
  /* Mark the HASH as handled.  */
  hashp->flags |= PL_MARK;
@


1.38
log
@Merge with EOM 1.135

author: provos
better referencing.  okay niklas@@

author: angelos
Eliminate bogus freeing of static variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.37 2000/10/07 07:01:19 niklas Exp $	*/
d66 1
d450 3
d874 7
a880 1
    log_print ("initiator_send_HASH_SA_NONCE: "
d883 40
@


1.38.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.47 2001/04/09 12:34:37 ho Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.139 2001/01/26 10:43:17 niklas Exp $	*/
d5 3
a7 3
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2000, 2001 Håkan Olsson.  All rights reserved.
a65 1
#include "util.h"
a110 1
  unsigned char hashbuf[20]; /* Set to the largest digest result */
d143 2
a144 2
      keynote_ids = calloc (keynote_policy_asserts_num, sizeof *keynote_ids);
      if (!keynote_ids)
d146 2
a147 4
	  log_error ("check_policy: "
		     "failed to allocate %d bytes for book keeping",
		     keynote_policy_asserts_num * sizeof *keynote_ids);
	  return 0;
d153 2
a154 2
      x509_ids = calloc (x509_policy_asserts_num, sizeof *x509_ids);
      if (!x509_ids)
d156 1
a156 3
          log_error ("check_policy: "
		     "failed to allocate %d bytes for book keeping",
		     x509_policy_asserts_num * sizeof *x509_ids);
d188 4
a191 6
      /*
       * For shared keys, just duplicate the passphrase with the
       * appropriate prefix tag.
       */
      nprinc = 3;
      principal = calloc (nprinc, sizeof *principal);
d194 2
a195 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     nprinc * sizeof *principal);
d203 1
a203 1
	  log_error ("check_policy: failed to allocate %d bytes",
d205 1
a211 30

      principal[1] = calloc (strlen ("passphrase-md5-hex:") +
			     32 + 1, sizeof (char));
      if (principal[1] == NULL)
        {
	  log_error ("check_policy: failed to allocate %d bytes",
		     strlen ("passphrase-md5-hex:") + 33);
	  goto policydone;
	}

      strcpy (principal[1], "passphrase-md5-hex:");
      MD5 (isakmp_sa->recv_cert, isakmp_sa->recv_certlen, hashbuf);
      for (i = 0; i < 16; i++)
	sprintf (principal[1] + (2 * i) + strlen ("passphrase-md5-hex:"),
		 "%02x", hashbuf[i]);
      
      principal[2] = calloc (strlen ("passphrase-sha1-hex:") +
			     32 + 1, sizeof (char));
      if (principal[2] == NULL)
        {
	  log_error ("check_policy: failed to allocate %d bytes",
		     strlen ("passphrase-sha1-hex:") + 33);
	  goto policydone;
	}

      strcpy (principal[2], "passphrase-sha1-hex:");
      SHA1 (isakmp_sa->recv_cert, isakmp_sa->recv_certlen, hashbuf);
      for (i = 0; i < 20; i++)
	sprintf (principal[2] + (2 * i) + strlen ("passphrase-sha1-hex:"),
		 "%02x", hashbuf[i]);
d218 1
a218 1
      principal = calloc (nprinc, sizeof *principal);
d221 2
a222 2
	  log_error ("check_policy: failed to allocate %d bytes",
		     nprinc * sizeof *principal);
d230 1
a230 1
	  log_error ("check_policy: failed to allocate %d bytes",
d232 1
d247 1
a247 1
      principal = calloc (2, sizeof *principal);
d250 1
a250 1
	  log_error ("check_policy: failed to get memory for principal");
d263 1
d271 1
d279 3
a281 1
	  log_error ("check_policy: failed to allocate memory for principal");
d300 3
a302 1
	      log_error ("check_policy: failed to allocate memory for principal[1]");
a338 3
      LOG_DBG ((LOG_POLICY, 40, "check_policy: adding authorizer [%s]",
		principal[i]));

d344 10
a353 1
	    LK (kn_remove_authorizer, (isakmp_sa->policy_id, principal[j]));
d359 1
a359 1
  /* Ask policy */
d362 1
a362 1
  LOG_DBG ((LOG_POLICY, 40, "check_policy: kn_do_query returned %d", result));
d367 1
a367 1
  /* Remove authorizers from the session */
a374 2
  principal = NULL;
  nprinc = 0;
d379 1
a379 1
      LOG_DBG ((LOG_POLICY, 40, "check_policy: proposal refused"));
a384 7
  for (i = 0; i < nprinc; i++)
    if (principal && principal[i])
      free (principal[i]);

  if (principal)
    free (principal);

a447 2
  struct sockaddr *src;
  socklen_t srclen;
d704 1
a704 4
	    {
	      log_print ("initiator_send_HASH_SA_NONCE: doi->get_spi failed");
	      goto bail_out;
	    }
d751 1
a751 1
	  /* Let the DOI get at proto for initializing its own data.  */
d845 2
a846 2
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDic",
		    id, sz));
d856 2
a857 2
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDrc",
		    id, sz));
d870 1
a870 7
    /* This code supports the "road warrior" case, where the initiator doesn't
     * have a fixed IP address, but wants to specify a particular remote 
     * network to talk to.
     * -- Adrian Close <adrian@@esec.com.au>
     */ 
    {
      log_print ("initiator_send_HASH_SA_NONCE: "
a873 40
      /* If we're here, then we are the initiator, so use initiator
	address for local ID */
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);

      sz = ISAKMP_ID_SZ 
	+ sizeof (((struct sockaddr_in *)src)->sin_addr.s_addr);

      id = calloc (sz, sizeof (char));
      if (!id)
	{
	  log_error ("initiator_send_HASH_SA_NONCE: malloc(%d) failed", sz);
	  return -1;
	}  
      SET_ISAKMP_ID_TYPE (id, IPSEC_ID_IPV4_ADDR);

      encode_32 (id + ISAKMP_ID_DATA_OFF,
	      ntohl (((struct sockaddr_in *)src)->sin_addr.s_addr));

      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDic",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
	}

    /* Send supplied remote_id */
      id = ipsec_build_id (remote_id, &sz);
      if (!id)
	return -1;
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH_SA_NONCE: IDrc",
		    id, sz));
      if (message_add_payload (msg, ISAKMP_PAYLOAD_ID, id, sz, 1))
	{
	  free (id);
	  return -1;
	}
    }


a944 35
  /* Allocate the prf and start calculating our HASH(1).  XXX Share?  */
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
		"initiator_recv_HASH_SA_NONCE: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_recv_HASH_SA_NONCE: NONCE_I_b",
		exchange->nonce_i, exchange->nonce_i_len));
  prf->Update (prf->prfctx, exchange->nonce_i, exchange->nonce_i_len);
  rest = hashp->p + GET_ISAKMP_GEN_LENGTH (hashp->p);
  rest_len = (GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base)
	      - (rest - (u_int8_t*)msg->iov[0].iov_base));
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
		"initiator_recv_HASH_SA_NONCE: payloads after HASH(2)", rest,
		rest_len));
  prf->Update (prf->prfctx, rest, rest_len);
  prf->Final (hash->digest, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80,
		"initiator_recv_HASH_SA_NONCE: computed HASH(2)",
		hash->digest, hashsize));
  if (memcmp (hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest, hashsize) != 0)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      return -1;
    }
  /* Mark the HASH as handled.  */
  hashp->flags |= PL_MARK;

d987 1
a987 1
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1003 1
a1003 1
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1095 34
d1176 2
a1177 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: SKEYID_a", 
		isa->skeyid_a, isa->skeyid_len));
d1183 1
a1183 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: message_id",
d1186 1
a1186 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: NONCE_I_b",
d1189 1
a1189 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: NONCE_R_b",
d1194 1
a1194 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "initiator_send_HASH: HASH(3)",
d1272 1
a1272 1
		      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1283 2
a1284 3
		      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
				    "post_quick_mode: g^xy", ie->g_xy, 
				    ie->g_x_len));
d1287 1
a1287 1
		  LOG_DBG ((LOG_NEGOTIATION, 90,
d1291 1
a1291 1
		  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: SPI",
d1294 1
a1294 1
		  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: Ni_b",
d1298 1
a1298 1
		  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: Nr_b",
d1305 1
a1305 1
	      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "post_quick_mode: KEYMAT",
d1361 1
a1361 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH_SA_NONCE: SKEYID_a",
d1367 1
a1367 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
		"responder_recv_HASH_SA_NONCE: message_id",
d1370 1
a1370 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1378 1
a1378 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1415 1
a1415 1
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1431 1
a1431 1
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
d1675 2
a1676 2
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: IDic",
		    id, sz));
d1691 2
a1692 2
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: IDrc",
		    id, sz));
d1701 1
a1701 1
  LOG_DBG ((LOG_NEGOTIATION, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
d1703 1
a1703 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: SKEYID_a",
d1709 1
a1709 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, 
		"responder_send_HASH_SA_NONCE: message_id", 
d1712 1
a1712 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_send_HASH_SA_NONCE: NONCE_I_b",
d1723 1
a1723 1
      LOG_DBG_BUF ((LOG_NEGOTIATION, 90, header, msg->iov[i].iov_base,
d1731 1
a1731 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, header, buf + ISAKMP_HASH_DATA_OFF,
		hashsize));
d1758 1
a1758 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 80, "gen_g_xy: g^xy", ie->g_xy, ie->g_x_len));
d1786 1
a1786 1
  LOG_DBG ((LOG_NEGOTIATION, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
d1788 2
a1789 2
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: SKEYID_a",
		isa->skeyid_a, isa->skeyid_len));
d1795 1
a1795 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: message_id",
d1798 1
a1798 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: NONCE_I_b",
d1801 1
a1801 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90, "responder_recv_HASH: NONCE_R_b",
d1806 1
a1806 1
  LOG_DBG_BUF ((LOG_NEGOTIATION, 90,
@


1.37
log
@Merge with EOM 1.133

author: niklas
style and < that should be <=

author: angelos
If the initiator does not propose a Phase 2 ID, use the local/peer
addresses as implicit IDs; this was supported on the responder side,
but weirdly enough not on the initiator. Reported by itojun@@

author: angelos
Handle 32-bit lifetimes (in generating them).

author: ho
(c)-2000

author: provos
style as pointed out by the code style pedant.

author: provos
proper reference counting for isakmp_sa in struct message, remove bogus
calls to sa_reference; fix some more memory leaks in conf.c
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.36 2000/08/03 07:23:44 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.133 2000/10/06 23:45:27 niklas Exp $	*/
a111 1
  char cn[259];
d297 11
a307 3
	  strcpy (cn, "DN:");
	  LC (X509_NAME_oneline, (subject, cn + 3, 256));
	  principal[1] = cn;
a1309 2
  sa_release (isakmp_sa);
  msg->isakmp_sa = NULL;
@


1.36
log
@Merge with EOM 1.127

author: angelos
Be careful when there's no assertions.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.35 2000/06/08 20:50:16 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.127 2000/07/01 20:06:23 angelos Exp $	*/
d7 1
d127 1
a127 1
  
d250 1
a250 1
        {  
d282 1
a282 1
	  free(principal);
d307 1
a307 1
	
d310 1
a310 1
    case ISAKMP_CERTENC_PGP:	
d325 1
a325 1
  /* 
d346 1
a346 1
	  free(principal);
d392 1
a392 1
    free (keynote_ids);  
d401 1
a401 1
  if (result == 0)  
d444 1
a444 1
    
d605 1
a605 1
		      /* XXX Does only handle 16-bit entities!  */
d608 16
a623 4
			attr
			  = attribute_set_basic (attr,
						 IPSEC_ATTR_SA_LIFE_DURATION,
						 value);
d935 2
d968 1
a968 1
	  
d1001 48
d1192 1
a1192 1
  sa_reference (msg->isakmp_sa);
d1304 1
d1399 1
a1399 1
	  
d1451 1
a1451 1
      ie->id_ci = malloc (ie->id_ci_sz);
d1467 1
a1467 1
      ie->id_cr = malloc (ie->id_cr_sz);
d1577 1
a1577 1
	  log_error ("responder_recv_HASH_SA_NONCE: strdup (\"%s\") failed", 
d1593 1
a1593 1
       * XXX Keep it if not USE_POLICY for now, though. 
d1646 1
a1646 1
    
a1810 1
  sa_reference (msg->isakmp_sa);
@


1.35
log
@Merge with EOM 1.126

author: angelos
Be a bit more verbose when printing policy results.

author: angelos
Correct environment cleanup.

author: angelos
Different policy/Keynote sessions per Phase 1 SA.

author: angelos
&&, not ||

author: angelos
Begin support for KeyNote credentials exchanged.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.34 2000/04/07 22:05:19 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.126 2000/06/08 04:21:17 angelos Exp $	*/
d109 1
a109 1
  int *x509_ids, *keynote_ids;
d141 1
a141 2
  keynote_ids = calloc (keynote_policy_asserts_num, sizeof(int));
  if (keynote_ids == NULL)
d143 6
a148 3
      log_print ("check_policy: failed to allocate %d bytes for book keeping",
		 keynote_policy_asserts_num * sizeof(int));
      return 0;
d151 1
a151 2
  x509_ids = calloc (x509_policy_asserts_num, sizeof(int));
  if (x509_ids == NULL)
d153 7
a159 4
      log_print ("check_policy: failed to allocate %d bytes for book keeping",
		 x509_policy_asserts_num * sizeof(int));
      free (keynote_ids);
      return 0;
@


1.34
log
@Merge with EOM 1.121

author: niklas
log_fatal is only OK during initialization

author: ho
Missing #ifdef USE_X509 added

author: ho
typo

author: ho
Add #ifdef USE_X509
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.33 2000/02/25 17:22:22 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.121 2000/04/07 19:02:42 niklas Exp $	*/
d41 1
a41 1
#ifdef USE_POLICY
a95 6
/* Policy session ID and other necessary globals.  XXX Why not in policy.h?  */
extern int keynote_sessid;
extern struct exchange *policy_exchange;
extern struct sa *policy_sa;
extern struct sa *policy_isakmp_sa;

d107 3
a109 2
  char *principal = NULL, *principal2 = NULL;
  int result;
d117 53
a169 3
  /* If there is no policy setup, everything fails.  */
  if (keynote_sessid < 0)
    return 0;
d186 2
a187 2
      principal = calloc (isakmp_sa->recv_certlen + 1 + strlen ("passphrase:"),
                          sizeof (char));
d189 18
a206 3
	return 0;
      strcpy (principal, "passphrase:");
      memcpy (principal + strlen ("passphrase:"), isakmp_sa->recv_cert,
d210 24
d240 8
a247 1
	  return 0;
d253 2
a254 2
      principal = LK (kn_encode_key, (&dc, INTERNAL_ENC_PKCS1, ENCODING_HEX,
				      KEYNOTE_PUBLIC_KEY));
d259 2
a260 1
	  return 0;
d262 2
a263 1
      if (principal == NULL)
d267 2
a268 1
	  return 0;
d270 4
a273 3
      principal2 = calloc (strlen (principal) + strlen ("rsa-hex:") + 1,
			   sizeof (char));
      if (principal2 == NULL)
d276 2
a277 1
	  free (principal);
d279 1
a279 1
	  return 0;
d282 3
a284 3
      strcpy (principal2, "rsa-hex:");
      strcpy (principal2 + strlen ("rsa-hex:"), principal);
      free (principal);
d286 2
a287 2
      principal = principal2;
      principal2 = NULL;
d295 4
a298 1
	  principal2 = cn;
a312 3
#if 0
    case ISAKMP_CERTENC_KEYNOTE:
#endif
d317 1
a317 1
      return 0;
d325 1
a325 1
  if (LK (kn_add_authorizer, (keynote_sessid, principal)) == -1)
d327 18
a344 3
      free (principal);
      log_print ("check_policy: kn_add_authorizer failed");
      return 0;
d347 7
a353 7
  if (principal2)
    if (LK (kn_add_authorizer, (keynote_sessid, principal2)) == -1)
      {
	free (principal);
      	log_print ("check_policy: kn_add_authorizer failed");
      	return 0;
      }
d355 6
a360 2
  /* Ask policy.  */
  result = LK (kn_do_query, (keynote_sessid, return_values, RETVALUES_NUM));
a361 2
  /* Remove authorizer from the session.  */
  LK (kn_remove_authorizer, (keynote_sessid, principal));
a363 4
  /* Remove "DN:" authorizer, if present */
  if (principal2)
          LK (kn_remove_authorizer, (keynote_sessid, principal2));

d367 17
a383 3
      LOG_DBG ((LOG_MISC, 40, "check_policy: kn_do_query returned %d",
		result));
      return 0;
d386 6
d1514 1
a1514 1
#if !defined (USE_POLICY) || !defined (USE_KEYNOTE)
d1531 1
a1531 1
#endif /* !USE_POLICY || !USE_KEYNOTE */
@


1.34.2.1
log
@Pull in patch:
Errata (009):
A serious bug in isakmpd(8) policy handling wherein policy verification could
be completely bypassed in isakmpd.
Fix (angelos):
Fix bug that resulted in bypass of policy verification of proposed SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.34 2000/04/07 22:05:19 niklas Exp $	*/
a120 1
  extern char *policy_callback(char *);
a130 3
  /* Reset information */
  policy_callback(KEYNOTE_CALLBACK_INITIALIZE);

a245 1
  policy_callback(KEYNOTE_CALLBACK_CLEANUP); /* Just to make sure */
@


1.33
log
@Merge with EOM 1.117

author: angelos
Move the check after we get rid of the unused protos.

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.32 2000/02/19 19:31:32 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.117 2000/02/25 07:06:22 angelos Exp $	*/
d65 1
d67 1
d112 1
a112 1
  char *return_values[RETVALUES_NUM], cn[259];
d114 3
a118 1
  int result;
d120 1
d151 1
d165 5
a169 1
	log_fatal ("check_policy: failed to get memory for public key");
d202 1
@


1.32
log
@Makefile: Merge with EOM 1.61
crypto.c: Merge with EOM 1.27
exchange.c: Merge with EOM 1.115
ike_quick_mode.c: Merge with EOM 1.115
x509.c: Merge with EOM 1.35
features/ec: Merge with EOM 1.1
features/aggressive: Merge with EOM 1.1
features/policy: Merge with EOM 1.1
features/x509: Merge with EOM 1.1

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.31 2000/02/12 09:21:23 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.115 2000/02/19 07:46:31 niklas Exp $	*/
d247 2
a248 2
      log_debug (LOG_MISC, 40, "check_policy: kn_do_query returned %d",
		 result);
d681 2
a682 2
      log_debug_buf (LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: IDic", id,
		     sz);
d692 2
a693 2
      log_debug_buf (LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: IDrc", id,
		     sz);
d821 4
a824 3
      log_debug_buf (LOG_MISC, 90,
		     "initiator_recv_HASH_SA_NONCE: IDci",
		     ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz - ISAKMP_GEN_SZ);
d837 4
a840 3
      log_debug_buf (LOG_MISC, 90,
		     "initiator_recv_HASH_SA_NONCE: IDcr",
		     ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz - ISAKMP_GEN_SZ);
a858 9

#ifdef USE_POLICY
      if (!check_policy (exchange, sa, msg->isakmp_sa))
	{
	  message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	  log_print ("initiator_recv_HASH_SA_NONCE: policy check failed");
	  return -1;
	}
#endif
d869 9
d882 2
a883 2
  log_debug_buf (LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: SKEYID_a",
		 isa->skeyid_a, isa->skeyid_len);
d889 2
a890 2
  log_debug_buf (LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d892 2
a893 2
  log_debug_buf (LOG_MISC, 90, "initiator_recv_HASH_SA_NONCE: NONCE_I_b",
		 exchange->nonce_i, exchange->nonce_i_len);
d898 3
a900 3
  log_debug_buf (LOG_MISC, 90,
		 "initiator_recv_HASH_SA_NONCE: payloads after HASH(2)", rest,
		 rest_len);
d904 3
a906 3
  log_debug_buf (LOG_MISC, 80,
		 "initiator_recv_HASH_SA_NONCE: computed HASH(2)",
		 hash->digest, hashsize);
d962 2
a963 2
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH: SKEYID_a", isa->skeyid_a,
		 isa->skeyid_len);
d969 2
a970 2
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d972 2
a973 2
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH: NONCE_I_b",
		 exchange->nonce_i, exchange->nonce_i_len);
d975 2
a976 2
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH: NONCE_R_b",
		 exchange->nonce_r, exchange->nonce_r_len);
d980 2
a981 2
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH: HASH(3)",
		 buf + ISAKMP_GEN_SZ, hashsize);
d1058 4
a1061 3
		      log_debug_buf (LOG_MISC, 90,
				     "post_quick_mode: last KEYMAT",
				     keymat - prf->blocksize, prf->blocksize);
d1069 2
a1070 2
		      log_debug_buf (LOG_MISC, 90, "post_quick_mode: g^xy",
				     ie->g_xy, ie->g_x_len);
d1073 3
a1075 3
		  log_debug (LOG_MISC, 90,
			     "post_quick_mode: suite %d proto %d", proto->no,
			     proto->proto);
d1077 2
a1078 2
		  log_debug_buf (LOG_MISC, 90, "post_quick_mode: SPI",
				 proto->spi[i], proto->spi_sz[i]);
d1080 2
a1081 2
		  log_debug_buf (LOG_MISC, 90, "post_quick_mode: Ni_b",
				 exchange->nonce_i, exchange->nonce_i_len);
d1084 2
a1085 2
		  log_debug_buf (LOG_MISC, 90, "post_quick_mode: Nr_b",
				 exchange->nonce_r, exchange->nonce_r_len);
d1091 2
a1092 2
	      log_debug_buf (LOG_MISC, 90, "post_quick_mode: KEYMAT",
			     iproto->keymat[i], ie->keymat_len);
d1148 2
a1149 2
  log_debug_buf (LOG_MISC, 90, "responder_recv_HASH_SA_NONCE: SKEYID_a",
		 isa->skeyid_a, isa->skeyid_len);
d1154 2
a1155 2
  log_debug_buf (LOG_MISC, 90, "responder_recv_HASH_SA_NONCE: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1157 4
a1160 4
  log_debug_buf (LOG_MISC, 90,
		 "responder_recv_HASH_SA_NONCE: message after HASH",
		 hash + hash_len,
		 msg->iov[0].iov_len - ISAKMP_HDR_SZ - hash_len);
d1165 3
a1167 3
  log_debug_buf (LOG_MISC, 90,
		 "responder_recv_HASH_SA_NONCE: computed HASH(1)", my_hash,
		 hash_len - ISAKMP_GEN_SZ);
d1202 4
a1205 3
      log_debug_buf (LOG_MISC, 90,
		     "responder_recv_HASH_SA_NONCE: IDci",
		     ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz - ISAKMP_GEN_SZ);
d1218 4
a1221 3
      log_debug_buf (LOG_MISC, 90,
		     "responder_recv_HASH_SA_NONCE: IDcr",
		     ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz - ISAKMP_GEN_SZ);
d1462 2
a1463 2
      log_debug_buf (LOG_MISC, 90, "responder_send_HASH_SA_NONCE: IDic", id,
		     sz);
d1478 2
a1479 2
      log_debug_buf (LOG_MISC, 90, "responder_send_HASH_SA_NONCE: IDrc", id,
		     sz);
d1488 4
a1491 4
  log_debug (LOG_MISC, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
	     isakmp_sa, isa);
  log_debug_buf (LOG_MISC, 90, "responder_send_HASH_SA_NONCE: SKEYID_a",
		 isa->skeyid_a, isa->skeyid_len);
d1496 2
a1497 2
  log_debug_buf (LOG_MISC, 90, "responder_send_HASH_SA_NONCE: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1499 2
a1500 2
  log_debug_buf (LOG_MISC, 90, "responder_send_HASH_SA_NONCE: NONCE_I_b",
		 exchange->nonce_i, exchange->nonce_i_len);
d1510 2
a1511 2
      log_debug_buf (LOG_MISC, 90, header, msg->iov[i].iov_base,
		     msg->iov[i].iov_len);
d1518 1
a1518 1
  log_debug_buf (LOG_MISC, 80, header, buf + ISAKMP_HASH_DATA_OFF, hashsize);
d1545 1
a1545 1
  log_debug_buf (LOG_MISC, 80, "gen_g_xy: g^xy", ie->g_xy, ie->g_x_len);
d1573 4
a1576 4
  log_debug (LOG_MISC, 95, "responder_recv_HASH: isakmp_sa %p isa %p",
	     isakmp_sa, isa);
  log_debug_buf (LOG_MISC, 90, "responder_recv_HASH: SKEYID_a", isa->skeyid_a,
		 isa->skeyid_len);
d1582 2
a1583 2
  log_debug_buf (LOG_MISC, 90, "responder_recv_HASH: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1585 2
a1586 2
  log_debug_buf (LOG_MISC, 90, "responder_recv_HASH: NONCE_I_b",
		 exchange->nonce_i, exchange->nonce_i_len);
d1588 2
a1589 2
  log_debug_buf (LOG_MISC, 90, "responder_recv_HASH: NONCE_R_b",
		 exchange->nonce_r, exchange->nonce_r_len);
d1593 3
a1595 3
  log_debug_buf (LOG_MISC, 90,
		 "responder_recv_HASH: computed HASH(3)", my_hash,
		 hash_len - ISAKMP_GEN_SZ);
@


1.31
log
@Merge with EOM 1.114

author: angelos
Bad typo, the check should be inverted. Also, add a NOTIFY message
being sent to the Responder if policy check fails at the initiator
(and print a log message).
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.30 2000/02/11 10:21:28 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.114 2000/02/12 00:11:28 angelos Exp $	*/
d41 1
a41 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d76 1
a76 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d92 1
a92 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d265 1
a265 1
#endif /* USE_KEYNOTE */
d858 1
a858 1
#if defined (USE_KEYNOTE)
d1267 2
a1268 1
#if defined (USE_KEYNOTE)
d1271 1
a1271 1
#elif defined (HAVE_DLOPEN)
d1274 1
d1278 1
a1278 1
#endif
d1369 2
a1370 2
#ifndef USE_KEYNOTE
#ifdef HAVE_DLOPEN
d1380 1
a1380 1
       * XXX Keep it if not USE_KEYNOTE for now, though. 
d1386 1
a1386 1
#endif /* USE_KEYNOTE */
@


1.30
log
@Merge with EOM 1.113

author: angelos
Rename the "CN:" tag to "DN:", after Jorgen's suggestion.

author: angelos
Do a policy check on the Initiator, when notified by the Responder on
the SA selection. For efficiency, we should replicate this check on
the first message sent by the Initiator (so we only send proposals we
know we'll eventually accept).
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.29 2000/02/07 01:32:54 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.113 2000/02/10 16:25:00 angelos Exp $	*/
d859 6
a864 2
      if (check_policy (exchange, sa, msg->isakmp_sa))
	return -1;
@


1.29
log
@ike_quick_mode.c: Merge with EOM 1.111
libcrypto.c: Merge with EOM 1.11
libcrypto.h: Merge with EOM 1.11
x509.c: Merge with EOM 1.33

author: angelos
Add Canonical Names as policy targets (so they can be specified in the
Licensees field), with the "CN:..." format.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.28 2000/02/01 02:46:17 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.111 2000/02/07 01:30:35 angelos Exp $	*/
d183 1
a183 1
      /* Generate a "CN:" principal */
d187 1
a187 1
	  strcpy (cn, "CN:");
d240 1
a240 1
  /* Remove "CN:" authorizer, if present */
d794 47
d845 1
d857 5
a923 43

  /* Handle optional client ID payloads.  */
  idp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_ID]);
  if (idp)
    {
      /* If IDci is there, IDcr must be too.  */
      if (!TAILQ_NEXT (idp, link))
	{
	  /* XXX Is this a good notify type?  */
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
	  return -1;
	}
	  
      /* XXX We should really compare, not override.  */
      ie->id_ci_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
      ie->id_ci = malloc (ie->id_ci_sz);
      if (!ie->id_ci)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_ci_sz);
	  return -1;
	}
      memcpy (ie->id_ci, idp->p, ie->id_ci_sz);
      idp->flags |= PL_MARK;
      log_debug_buf (LOG_MISC, 90,
		     "initiator_recv_HASH_SA_NONCE: IDci",
		     ie->id_ci + ISAKMP_GEN_SZ, ie->id_ci_sz - ISAKMP_GEN_SZ);

      idp = TAILQ_NEXT (idp, link);
      ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
      ie->id_cr = malloc (ie->id_cr_sz);
      if (!ie->id_cr)
	{
	  log_error ("initiator_recv_HASH_SA_NONCE: malloc (%d) failed",
		     ie->id_cr_sz);
	  return -1;
	}
      memcpy (ie->id_cr, idp->p, ie->id_cr_sz);
      idp->flags |= PL_MARK;
      log_debug_buf (LOG_MISC, 90,
		     "initiator_recv_HASH_SA_NONCE: IDcr",
		     ie->id_cr + ISAKMP_GEN_SZ, ie->id_cr_sz - ISAKMP_GEN_SZ);
    }
@


1.28
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.27 2000/01/31 08:38:28 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.110 2000/01/31 22:33:45 niklas Exp $	*/
d110 2
a111 2
  char *return_values[RETVALUES_NUM];
  char *principal = NULL, *princ2;
d113 1
d166 3
a168 3
      princ2 = calloc (strlen (principal) + strlen ("rsa-hex:") + 1,
		       sizeof (char));
      if (princ2 == NULL)
d176 2
a177 2
      strcpy (princ2, "rsa-hex:");
      strcpy (princ2 + strlen ("rsa-hex:"), principal);
d180 11
a190 2
      principal = princ2;
      princ2 = NULL;
d220 1
d225 8
d239 4
@


1.27
log
@ike_quick_mode.c: Merge with EOM 1.109
isakmpd.conf.5: Merge with EOM 1.38
message.c: Merge with EOM 1.142
pf_key_v2.c: Merge with EOM 1.35
x509.c: Merge with EOM 1.31

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.26 2000/01/30 21:01:49 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.109 2000/01/31 08:39:44 niklas Exp $	*/
d6 1
@


1.26
log
@Merge with EOM 1.108

author: niklas
style
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.25 2000/01/30 20:52:20 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.108 2000/01/30 21:03:46 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.25
log
@Merge with EOM 1.107

author: angelos
Fix part of the problem with X509 certificates (delegating to the CA
isn't working yet, but I know where the problem is -- upcoming commit
later today).
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.24 2000/01/26 15:22:02 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.107 2000/01/30 20:17:47 angelos Exp $	*/
d164 2
a165 1
      princ2 = calloc(strlen(principal) + strlen("rsa-hex:") + 1, sizeof(char));
d169 1
a169 1
	  free(principal);
d174 3
a176 3
      strcpy(princ2, "rsa-hex:");
      strcpy(princ2 + strlen("rsa-hex:"), principal);
      free(principal);
d230 1
a230 1
   *     and so this log message reflects this. Change to somethine better?
@


1.24
log
@Merge with EOM 1.106

date: 2000/01/24 22:55:46;  author: angelos;  state: Exp;  lines: +2 -2
Fix typo.

date: 2000/01/24 16:48:42;  author: ho;  state: Exp;  lines: +12 -2
Log when check_policy() returns failure. (bitten by keynote once too often... sigh)

author: angelos
Typo.

author: angelos
Passphrases are encoded as "passphrase:xxxx" now, to distinguish
between passphrases and logic labels.

author: angelos
Oops on previous PFS-policy patch. Small fixes in the manpages.

author: angelos
Include files, in anticipation of the keynote.h changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.23 1999/10/26 22:32:28 angelos Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.106 2000/01/24 22:55:46 angelos Exp $	*/
d110 1
a111 1
  char *principal = NULL;
d159 17
a175 1
	return 0;
d177 2
@


1.23
log
@sync with latest libkeynote (include file changes only)
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.22 1999/10/01 14:07:16 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.100 1999/10/01 13:44:21 niklas Exp $	*/
d132 4
a135 2
      /* For shared keys, just duplicate the passphrase.  */
      principal = calloc (isakmp_sa->recv_certlen + 1, sizeof (char));
d138 3
a140 1
      memcpy (principal, isakmp_sa->recv_cert, isakmp_sa->recv_certlen);
d189 4
a192 1
    return 0;
d210 7
d482 1
a482 1
		  log_print ("inititor_send_HASH_SA_NONCE: "
d1117 2
@


1.22
log
@Merge with EOM 1.100

author: niklas
AUTHENTICATION_ALGORITHM is a must in AH transforms.  Better error reporting.

author: ho
More debugging output.

author: angelos
Remove evil experimental code, fix off-by-1 buffer allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ike_quick_mode.c,v 1.21 1999/08/26 22:30:21 niklas Exp $	*/
d41 2
@


1.21
log
@Merge with EOM 1.97

author: niklas
Support dynamic loading of libkeynote too.  Build isakmpd static by default.
Stylistic cleanup of keynote policy code.  Correct some libcrypto calls.

author: ho
We want the exchange name if it's one of our (passive) connections.

author: angelos
Warning about RSA-specific code.

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.20 1999/08/05 22:42:04 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.97 1999/08/26 11:21:50 niklas Exp $	*/
d131 1
a131 1
      principal = strdup (isakmp_sa->recv_cert);
d134 1
d1207 12
a1218 2
	/* XXX we need to have some attributes per proto, not all per SA.  */
	ipsec_decode_transform (msg, sa, proto, proto->chosen->p);
d1227 2
d1238 2
d1247 2
@


1.20
log
@Merge with EOM 1.93

author: niklas
Fix no ID in QM, when acting as responder, bug

author: niklas
Fix bad size computation in last commit

author: niklas
Make ID-less QM really work.  Forgot to allocate space for the
fake ID payloads.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.19 1999/07/07 22:09:54 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.93 1999/07/25 09:12:36 niklas Exp $	*/
d40 1
a40 1
#ifdef USE_KEYNOTE
d58 1
d62 1
d73 2
a74 2
#ifdef USE_KEYNOTE
static int check_policy (struct exchange *, struct sa *);
d89 1
a89 1
#ifdef USE_KEYNOTE
d91 1
a91 1
/* Policy session ID and other necessary globals */
d95 1
d105 1
a105 1
check_policy (struct exchange *exchange, struct sa *sa)
d108 1
d111 1
d113 1
a113 1
  /* If there is no policy setup, everything fails */
d117 1
a117 1
  /* Initialize -- we'll let the callback do all the work */
d120 1
d122 2
a123 2
  /* Set the return values; true/false for now at least */
  return_values[0] = "false"; /* Order of values in array is important */
d126 49
a174 2
  /* XXX Create a principal (authorizer) for the SA/ID request. */
  principal = "dontmatter";
d181 1
a181 1
  if (kn_add_authorizer (keynote_sessid, principal) == -1)
d184 2
a185 10
  /*
   * XXX If doing X509 certificates, create a fake KeyNote assertion,
   * delegating from the CA to the actual pubkey.
   */

  /* Ask policy */
  result = kn_do_query (keynote_sessid, return_values, RETVALUES_NUM);

  /* Remove authorizer from the session */
  kn_remove_authorizer (keynote_sessid, principal);
d187 2
a188 1
#if 0
a189 1
#endif
d191 1
a191 1
  /* Check what policy said */
a193 1
      /* XXX Some sort of debug message about failure */
a1044 2

#ifndef USE_KEYNOTE
a1045 1
#endif
d1191 1
a1191 1
#ifdef USE_KEYNOTE  
d1194 3
a1255 1
#ifndef USE_KEYNOTE
d1257 1
a1257 3
   * XXX This code is no longer necessary, as policy determines acceptance
   * XXX of IDs/SAs. (angelos@@openbsd.org)
   * XXX Keep it if not USE_KEYNOTE for now, though. 
d1265 1
a1265 1
  if (!name)
d1267 7
a1273 2
      /* XXX Notify peer and log.  */
      goto cleanup;
d1275 13
d1289 1
a1289 4
  exchange->name = strdup (name);
  if (!exchange->name)
    {
      log_error ("responder_recv_HASH_SA_NONCE: strdup (\"%s\") failed", name);
d1292 1
a1292 1
#endif
@


1.19
log
@exchange.h: Merge with EOM 1.25
ike_quick_mode.c: Merge with EOM 1.90
init.c: Merge with EOM 1.15

author: ho
Add keynote policy support (with USE_KEYNOTE). angelos@@openbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.18 1999/06/05 23:09:21 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.90 1999/06/07 00:02:12 ho Exp $	*/
d1115 2
d1119 9
d1135 9
d1297 1
a1297 1
  if (ie->id_ci)
@


1.18
log
@Merge with EOM 1.89

author: ho
Remove early variable initialization.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.17 1999/06/02 06:30:39 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.89 1999/06/05 22:07:20 ho Exp $	*/
d40 4
d71 4
d87 76
d1001 2
d1004 1
a1057 3
  if (message_negotiate_sa (msg, 0))
    goto cleanup;

a1058 56
  
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa; sa = TAILQ_NEXT (sa, next))
    {
      for (proto = TAILQ_FIRST (&sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	/* XXX we need to have some attributes per proto, not all per SA.  */
	ipsec_decode_transform (msg, sa, proto, proto->chosen->p);

      isa = sa->data;

      /* Check the SA for reasonableness.  */

      /* The group description is mandatory if we got a KEY_EXCH payload.  */
      if (kep)
	{
	  if (!isa->group_desc)
	    {
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	      continue;
	    }

	  /* Also, all SAs must have equal groups.  */
	  if (!group_desc)
	    group_desc = isa->group_desc;
	  else if (group_desc != isa->group_desc)
	    {
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	      continue;
	    }
	}

      /* At least one SA was accepted.  */
      retval = 0;
    }

  if (kep)
    {
      ie->group = group_get (group_desc);
      if (!ie->group)
	{
	  /*
	   * XXX If the error was due to an out-of-range group description
	   * we should notify our peer, but this should probably be done
	   * by the attribute validation.  Is it?
	   */
	  goto cleanup;
	}
    }

  /* Copy out the initiator's nonce.  */
  if (exchange_save_nonce (msg))
    goto cleanup;

  /* Handle the optional KEY_EXCH payload.  */
  if (kep && ipsec_save_g_x (msg))
    goto cleanup;
d1130 69
d1209 1
d1216 1
@


1.17
log
@Merge with EOM 1.88

author: niklas
Some extra error checking, documentation and style wrt connections

author: niklas
Some more #if 0 stuff for passive connections

author: niklas
Error handling looked over.  Some restructuring of ID checks, but still no
coupling to names.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.16 1999/05/02 19:20:32 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.88 1999/05/30 14:12:30 niklas Exp $	*/
d797 1
a797 1
  struct ipsec_proto *iproto = proto->data;
@


1.16
log
@BUGS: Merge with EOM 1.31
doi.h: Merge with EOM 1.27
ike_auth.c: Merge with EOM 1.30
ike_quick_mode.c: Merge with EOM 1.85
ipsec.c: Merge with EOM 1.107
ipsec.h: Merge with EOM 1.36
isakmp_doi.c: Merge with EOM 1.39

author: niklas
Factor out keyed hashing of all payloads with SKEYID_a, and make DOI hooks
for informational exchanges to add such hashing.  Use it from QM and the IKE
authentication module too.  Remove some bogus XXX comments.  Add error
reporting
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.15 1999/04/30 11:46:24 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.85 1999/05/02 12:48:58 niklas Exp $	*/
d44 1
d469 1
a469 4
    {
      /* XXX Log?  */
      return -1;
    }
a478 1
	  /* XXX Log?  */
d600 1
a600 3
		 "multiple SA payloads in quick mode");
      /* XXX Is there a better notification type?  */
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
d616 1
a616 4
	{
	  /* XXX Log?  */
	  return -1;
	}
d662 1
a662 2
      log_print ("initiator_recv_HASH_SA_NONCE: bad hash");
      /* XXX Notify?  */
d678 1
a678 4
    {
      /* XXX Notify peer?  */
      return -1;
    }
d682 1
a682 4
    {
      /* XXX Notify peer?  */
      return -1;
    }
d688 8
d700 5
a704 1
	return -1;
d712 3
a714 2
      /* XXX Is IDci without IDcr valid?  */
      if (idp)
d716 3
a718 10
	  ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
	  ie->id_cr = malloc (ie->id_cr_sz);
	  if (!ie->id_cr)
	    return -1;
	  memcpy (ie->id_cr, idp->p, ie->id_cr_sz);
	  idp->flags |= PL_MARK;
	  log_debug_buf (LOG_MISC, 90,
			 "initiator_recv_HASH_SA_NONCE: IDcr",
			 ie->id_cr + ISAKMP_GEN_SZ,
			 ie->id_cr_sz - ISAKMP_GEN_SZ);
d720 5
d762 1
a762 4
    {
      /* XXX Log?  */
      return -1;
    }
d837 4
a840 1
		  /* XXX What to do?  */
d915 3
a964 1
      /* XXX Is there a better notification type?  */
d1015 5
a1019 1
	  /* XXX Notify peer?  */
d1026 1
a1026 4
    {
      /* XXX Notify peer?  */
      goto cleanup;
    }
d1030 1
a1030 4
    {
      /* XXX Notify peer?  */
      goto cleanup;
    }
d1036 8
d1059 3
a1061 2
      /* XXX Is IDci without IDcr valid?  */
      if (idp)
d1063 3
a1065 14
	  ie->id_cr_sz = GET_ISAKMP_GEN_LENGTH (idp->p);
	  ie->id_cr = malloc (ie->id_cr_sz);
	  if (!ie->id_cr)
	    {
	      log_error ("responder_recv_HASH_SA_NONCE: malloc (%d) failed",
			 ie->id_cr_sz);
	      goto cleanup;
	    }
	  memcpy (ie->id_cr, idp->p, ie->id_cr_sz);
	  idp->flags |= PL_MARK;
	  log_debug_buf (LOG_MISC, 90,
			 "responder_recv_HASH_SA_NONCE: IDcr",
			 ie->id_cr + ISAKMP_GEN_SZ,
			 ie->id_cr_sz - ISAKMP_GEN_SZ);
d1067 50
d1167 1
a1167 4
    {
      /* XXX Log?  */
      return -1;
    }
d1171 1
a1171 4
    {
      /* XXX Log?  */
      return -1;
    }
d1175 1
a1175 4
    {
      /* XXX Log?  */
      return -1;
    }
d1220 1
a1220 4
    {
      /* XXX Log?  */
      return -1;
    }
a1261 1
      /* XXX How to notify peer?  */
a1267 1
      /* XXX How to notify peer?  */
a1323 1
      /* XXX Is there a better notification type?  */
@


1.15
log
@ike_phase_1.c: Merge with EOM 1.3
ike_quick_mode.c: Merge with EOM 1.84
message.h: Merge with EOM 1.46

author: niklas
New message_drop API.  Generate real INVALID_COOKIE notification.
Generate informational exchanges in phase 1 too.  Really get these
messages to the wire
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.14 1999/04/27 21:04:07 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.84 1999/04/29 10:51:34 niklas Exp $	*/
a87 2
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
d90 1
a90 3
  u_int8_t *sa_buf = 0, *attr, *saved_nextp_sa, *saved_nextp_prop;
  u_int8_t *buf, *id;
  u_int8_t *spi;
a91 3
  struct prf *prf;
  struct hash *hash = hash_get (isa->hash);
  size_t hashsize = hash->hashsize;
a95 1
  char header[80];
d105 2
d108 2
a109 15
  /* We want a HASH payload to start with.  XXX Share with ike_main_mode.c?  */
  buf = malloc (ISAKMP_HASH_SZ + hashsize);
  if (!buf)
    {
      log_error ("initiator_send_HASH_SA_NONCE: malloc (%d) failed",
		 ISAKMP_HASH_SZ + hashsize);
      return -1;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, buf,
			   ISAKMP_HASH_SZ + hashsize, 1))
    {
      free (buf);
      return -1;
    }
d525 2
a526 29
  /* Allocate the prf and start calculating our HASH(1).  XXX Share?  */
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: SKEYID_a",
		 isa->skeyid_a, isa->skeyid_len);
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    {
      /* XXX Log?  */
      return -1;
    }
  prf->Init (prf->prfctx);
  log_debug_buf (LOG_MISC, 90, "initiator_send_HASH_SA_NONCE: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);

  /* Loop over all payloads after HASH(1).  */
  for (i = 2; i < msg->iovlen; i++)
    {
      /* XXX Misleading payload type printouts.  */
      snprintf (header, 80,
		"initiator_send_HASH_SA_NONCE: payload %d after HASH(1)",
		i - 1);
      log_debug_buf (LOG_MISC, 90, header, msg->iov[i].iov_base,
		     msg->iov[i].iov_len);
      prf->Update (prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
    }
  prf->Final (buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
  prf_free (prf);
  log_debug_buf (LOG_MISC, 80, "initiator_send_HASH_SA_NONCE: HASH(1)",
		 buf + ISAKMP_HASH_DATA_OFF, hashsize);
d647 2
a648 4
    {
      /* XXX Log?  */
      return -1;
    }
d940 4
a943 1
  /* Check the payload's integrity.  */
d948 1
a948 4
    {
      /* XXX Log?  */
      goto cleanup;
    }
d1275 1
a1275 4
    {
      /* XXX Log?  */
      goto cleanup;
    }
@


1.14
log
@Merge with EOM 1.83

author: niklas
Do not hold on to the exchange for post quick mode, it will be there.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.13 1999/04/19 21:22:49 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.83 1999/04/25 22:08:08 niklas Exp $	*/
d651 1
a651 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
d976 1
a976 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
d1015 1
a1015 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 0, 0);
d1042 1
a1042 1
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 0, 0);
d1051 1
a1051 1
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 0, 0);
d1346 1
a1346 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 0, 0);
@


1.13
log
@./regress/x509/x509test.c: Merge with EOM 1.4
./dh.h: Merge with EOM 1.4
./math_ec2n.c: Merge with EOM 1.8
./crypto.c: Merge with EOM 1.25
./ike_quick_mode.c: Merge with EOM 1.82
./math_group.c: Merge with EOM 1.16
./math_ec2n.h: Merge with EOM 1.4

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.12 1999/04/06 17:08:53 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.82 1999/04/17 23:20:27 niklas Exp $	*/
a836 1
  exchange_reference (exchange);
a943 1
  exchange_release (exchange);
a1351 1
  exchange_reference (exchange);
@


1.12
log
@Merge with EOM 1.81
Too much removed in last commit

Actually save the DH values in inititor mode

Non-PFS case for initiators bailed out wrongly.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.11 1999/04/05 20:58:52 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.81 1999/04/06 14:11:35 niklas Exp $	*/
d1280 9
a1288 1
      /* XXX How to log and notify peer?  */
a1290 2
  dh_create_shared (ie->group, ie->g_xy,
		    exchange->initiator ? ie->g_xr : ie->g_xi);
@


1.11
log
@Merge with EOM 1.78
clear pointer when what is pointed to is freed

Fix PFS in initator mode.  Improve commentary.  Some more error reporting.
GC proto structures if we bail out on a message.  Never free twice.

Error handling of group allocation.

Memory alloc. error reporting. Mem leak plugging.
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.10 1999/04/03 09:14:52 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.78 1999/04/05 20:18:32 niklas Exp $	*/
a504 2
      group_free (ie->group);
      ie->group = 0;
d726 2
a727 2
  ie->group = group_get (isa->group_desc);
  if (!ie->group)
d729 1
a729 1
      /* XXX Notify peer?  */
@


1.10
log
@Merge with EOM 1.74
refcount the exchange when delayed processing is scheduled for QM

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.9 1999/03/31 20:29:57 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.74 1999/04/03 09:13:55 niklas Exp $	*/
d107 1
a107 1
  struct conf_list *suite_conf = 0, *prot_conf = 0, *xf_conf = 0, *life_conf;
d112 1
d118 2
a119 1
      /* XXX Log?  */
d122 1
a125 1
      /* XXX Log?  */
d155 6
a160 1
		goto bail_out;
d166 7
a172 1
		goto bail_out;
d178 6
a183 1
		goto bail_out;
d189 6
a194 1
		goto bail_out;
d200 6
a205 1
		goto bail_out;
d229 7
a235 1
	    goto bail_out;
d239 6
a244 1
	    goto bail_out;
d257 8
a264 1
		goto bail_out;
d298 1
d314 1
d343 16
d360 2
d376 6
a381 1
	    goto bail_out;
d388 6
a393 1
	    goto bail_out;
d398 5
a402 1
		goto bail_out;
d404 1
d425 2
d432 4
a435 1
    goto bail_out;
d493 1
a493 1
  if (ie->group)
d495 1
d501 2
d505 2
d521 1
a521 1
	  /* XXX Log?  */
d532 1
a532 1
	  /* XXX Log?  */
d576 11
d600 1
a600 1
	      for (xf_no = 0; xf_no < xf_conf->cnt; xf_no++)
d618 1
a618 2
  if (suite_conf)
    conf_free_list (suite_conf);
d657 1
a657 1
  sa = TAILQ_FIRST (&msg->exchange->sa_list);
d720 2
a721 1
      /* XXX Log & notify?  */
d727 1
a727 1
  /* XXX Errors possible?  */
d729 5
d738 1
a738 1
      /* XXX How to log and notify peer?  */
d745 1
a745 1
      /* XXX How to log and notify peer?  */
d800 2
a801 1
      /* XXX Log?  */
a806 1
      /* XXX Log?  */
d965 1
a965 1
  u_int8_t *hash, *my_hash;
d981 1
a981 1
      return -1;
d987 3
a989 2
      /* XXX Log?  */
      return -1;
d999 1
a999 1
      return -1;
d1020 1
a1020 1
      return -1;
d1022 2
d1026 1
a1026 1
    return -1;
d1030 1
a1030 2
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa;
       sa = TAILQ_NEXT (sa, next))
a1036 1

d1064 9
a1072 2
  /* XXX Errors possible?  */
  ie->group = group_get (group_desc);
d1077 2
a1078 2
      /* XXX How to log and notify peer?  */
      return -1;
d1084 2
a1085 2
      /* XXX How to log and notify peer?  */
      return -1;
d1095 5
a1099 1
	retval = 1;
d1113 5
a1117 1
	    retval = 1;
d1128 9
d1162 2
a1163 1
      /* XXX Log?  */
a1168 1
      /* XXX Log?  */
d1201 1
a1201 1
	  /* XXX Log?  */
d1209 1
a1209 1
	  /* XXX Log?  */
d1217 1
a1217 1
	  /* XXX Log?  */
d1225 1
a1225 1
	  /* XXX Log?  */
d1297 1
a1297 1
  u_int8_t *hash, *my_hash;
d1309 3
a1311 2
      /* XXX Log?  */
      return -1;
d1323 1
a1323 2
      free (my_hash);
      return -1;
d1345 1
a1345 1
      return -1;
d1347 1
d1354 5
@


1.9
log
@Merge with EOM 1.72
Use SA refcounting where needed
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.8 1999/03/31 14:28:34 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.72 1999/03/31 20:22:16 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d732 1
d840 1
d1217 1
@


1.8
log
@Merge with EOM 1.71
Fix comment
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.7 1999/03/31 00:50:21 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.71 1999/03/31 14:18:45 niklas Exp $	*/
d731 1
d838 1
d1214 1
@


1.7
log
@Merge with EOM 1.70
Do not deref after free, thanks ElectricFence
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.6 1999/02/26 03:42:30 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.70 1999/03/30 21:40:48 niklas Exp $	*/
d778 1
a778 1
	       * to a multiple of the PRF´s blocksize as it is generated
@


1.6
log
@Merge from the Ericsson repository
| revision 1.69
| date: 1999/02/25 11:39:04;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.68
| date: 1999/02/25 11:09:36;  author: niklas;  state: Exp;  lines: +7 -6
| Make conf_get_num take a default value to give back when tag does not exist
| ----------------------------
| revision 1.67
| date: 1999/02/25 10:21:30;  author: niklas;  state: Exp;  lines: +2 -2
| Replay window changes was done at the wrong level
| ----------------------------
| revision 1.66
| date: 1999/02/25 09:30:23;  author: niklas;  state: Exp;  lines: +5 -1
| Replay protection window configurable
| ----------------------------
| revision 1.65
| date: 1999/02/14 00:07:24;  author: niklas;  state: Exp;  lines: +4 -3
| Clarify which SPI we are setting up
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.5 1998/12/21 01:02:24 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.69 1999/02/25 11:39:04 niklas Exp $	*/
d528 1
a528 1
  struct proto *proto;
d579 6
a584 4
  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    if (!proto->chosen)
      proto_free (proto);
@


1.5
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.4 1998/11/20 07:37:44 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.64 1998/12/17 07:55:46 niklas Exp $	*/
d40 2
d245 1
a245 1
		      value = conf_get_num (life->field, "LIFE_DURATION");
d267 1
a267 1
	      value = conf_get_num (xf->field, "KEY_LENGTH");
d272 1
a272 1
	      value = conf_get_num (xf->field, "KEY_ROUNDS");
d277 1
a277 1
	      value = conf_get_num (xf->field, "COMPRESS_DICTIONARY_SIZE");
d284 2
a285 1
	      value = conf_get_num (xf->field, "COMPRESS_PRIVATE_ALGORITHM");
d330 1
d333 6
a338 2
	  proto->spi_sz[exchange->initiator] = spi_sz;
	  proto->spi[exchange->initiator] = spi;
@


1.4
log
@Use new message_negotiate_sa API
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.3 1998/11/17 11:10:13 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.58 1998/11/20 07:18:10 niklas Exp $	*/
d91 1
a91 1
  u_int8_t *buf;
d93 1
a93 1
  size_t spi_sz;
d109 1
d127 1
a127 1
  suite_conf = conf_get_list ("Quick mode", "Offered-suites");
d238 1
a238 1
		      attribute_set_constant (life->field, "SA_LIFE_TYPE",
d243 1
a243 1
		      value = conf_get_num (life->field, "SA_LIFE_DURATION");
d263 1
a263 1
				      IKE_ATTR_GROUP_DESCRIPTION, &attr);
d410 36
a445 1
  /* XXX Generate optional client ID payloads.  */
d522 1
a522 1
  struct payload *xf;
d632 31
a662 1
  /* XXX Handle optional client ID payloads.  */
d837 1
a837 1
  struct payload *hashp, *kep;
d959 30
a988 1
  /* XXX Handle optional client ID payloads.  */
d1009 2
d1041 1
a1041 1
  /* Generate optional KEY_EXCH payload.  */
d1048 35
a1082 1
  /* XXX Generate optional client ID payload.  */
d1085 2
d1168 2
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: ike_quick_mode.c,v 1.2 1998/11/15 00:43:55 niklas Exp $	*/
/*	$EOM: ike_quick_mode.c,v 1.57 1998/11/14 13:20:09 niklas Exp $	*/
d126 1
a126 1
  suite_conf = conf_get_list ("Quick mode initiator", "Offered-suites");
d835 1
a835 1
  if (message_negotiate_sa (msg))
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: ike_quick_mode.c,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: ike_quick_mode.c,v 1.57 1998/11/14 13:20:09 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
