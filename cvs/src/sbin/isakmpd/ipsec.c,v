head	1.147;
access;
symbols
	OPENBSD_6_2_BASE:1.147
	OPENBSD_6_1:1.146.0.8
	OPENBSD_6_1_BASE:1.146
	OPENBSD_6_0:1.146.0.4
	OPENBSD_6_0_BASE:1.146
	OPENBSD_5_9:1.146.0.2
	OPENBSD_5_9_BASE:1.146
	OPENBSD_5_8:1.143.0.6
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.143.0.2
	OPENBSD_5_7_BASE:1.143
	OPENBSD_5_6:1.140.0.6
	OPENBSD_5_6_BASE:1.140
	OPENBSD_5_5:1.140.0.4
	OPENBSD_5_5_BASE:1.140
	OPENBSD_5_4:1.138.0.6
	OPENBSD_5_4_BASE:1.138
	OPENBSD_5_3:1.138.0.4
	OPENBSD_5_3_BASE:1.138
	OPENBSD_5_2:1.138.0.2
	OPENBSD_5_2_BASE:1.138
	OPENBSD_5_1_BASE:1.137
	OPENBSD_5_1:1.137.0.2
	OPENBSD_5_0:1.136.0.4
	OPENBSD_5_0_BASE:1.136
	OPENBSD_4_9:1.136.0.2
	OPENBSD_4_9_BASE:1.136
	OPENBSD_4_8:1.135.0.2
	OPENBSD_4_8_BASE:1.135
	OPENBSD_4_7:1.134.0.2
	OPENBSD_4_7_BASE:1.134
	OPENBSD_4_6:1.132.0.6
	OPENBSD_4_6_BASE:1.132
	OPENBSD_4_5:1.132.0.2
	OPENBSD_4_5_BASE:1.132
	OPENBSD_4_4:1.130.0.4
	OPENBSD_4_4_BASE:1.130
	OPENBSD_4_3:1.130.0.2
	OPENBSD_4_3_BASE:1.130
	OPENBSD_4_2:1.129.0.2
	OPENBSD_4_2_BASE:1.129
	OPENBSD_4_1:1.127.0.2
	OPENBSD_4_1_BASE:1.127
	OPENBSD_4_0:1.126.0.2
	OPENBSD_4_0_BASE:1.126
	OPENBSD_3_9:1.122.0.2
	OPENBSD_3_9_BASE:1.122
	OPENBSD_3_8:1.121.0.2
	OPENBSD_3_8_BASE:1.121
	OPENBSD_3_7:1.107.0.2
	OPENBSD_3_7_BASE:1.107
	OPENBSD_3_6:1.103.0.2
	OPENBSD_3_6_BASE:1.103
	OPENBSD_3_5:1.87.0.2
	OPENBSD_3_5_BASE:1.87
	OPENBSD_3_4:1.80.0.2
	OPENBSD_3_4_BASE:1.80
	OPENBSD_3_3:1.72.0.2
	OPENBSD_3_3_BASE:1.72
	OPENBSD_3_2:1.71.0.2
	OPENBSD_3_2_BASE:1.71
	OPENBSD_3_1:1.64.0.2
	OPENBSD_3_1_BASE:1.64
	OPENBSD_3_0:1.58.0.2
	OPENBSD_3_0_BASE:1.58
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_8:1.30.0.2
	OPENBSD_2_8_BASE:1.30
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.147
date	2017.07.18.06.19.07;	author mpi;	state Exp;
branches;
next	1.146;
commitid	jTbaqAFAT0cOFIgt;

1.146
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.145;
commitid	82PdNqu2kKAuXPfA;

1.145
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.144;
commitid	CLwtYUTkBZ3FXV1w;

1.144
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.143;
commitid	0qPuuXwccpVXsXcV;

1.143
date	2015.01.16.06.39.58;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	Uu5nFG3wCl0LACBb;

1.142
date	2015.01.13.04.19.00;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	2fhK8RTLFQqewQS0;

1.141
date	2014.10.09.02.38.56;	author deraadt;	state Exp;
branches;
next	1.140;
commitid	lHB12E9VkXKsWY0B;

1.140
date	2014.01.22.03.09.31;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2013.11.21.22.25.01;	author yasuoka;	state Exp;
branches;
next	1.138;

1.138
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.137;

1.137
date	2011.10.20.00.28.06;	author yasuoka;	state Exp;
branches;
next	1.136;

1.136
date	2010.09.22.13.45.15;	author mikeb;	state Exp;
branches;
next	1.135;

1.135
date	2010.06.29.19.50.16;	author reyk;	state Exp;
branches;
next	1.134;

1.134
date	2010.03.04.13.55.28;	author markus;	state Exp;
branches;
next	1.133;

1.133
date	2010.01.10.12.39.43;	author markus;	state Exp;
branches;
next	1.132;

1.132
date	2009.01.29.10.05.50;	author hshoexer;	state Exp;
branches;
next	1.131;

1.131
date	2009.01.20.14.36.19;	author mpf;	state Exp;
branches;
next	1.130;

1.130
date	2007.09.02.15.19.24;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2007.07.31.20.59.33;	author hshoexer;	state Exp;
branches;
next	1.128;

1.128
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.127;

1.127
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.126;

1.126
date	2006.06.10.20.10.02;	author hshoexer;	state Exp;
branches;
next	1.125;

1.125
date	2006.06.09.21.37.17;	author naddy;	state Exp;
branches;
next	1.124;

1.124
date	2006.05.29.06.56.36;	author mcbride;	state Exp;
branches;
next	1.123;

1.123
date	2006.05.28.02.22.34;	author mcbride;	state Exp;
branches;
next	1.122;

1.122
date	2005.09.23.14.44.03;	author hshoexer;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2005.06.25.23.20.43;	author hshoexer;	state Exp;
branches
	1.121.2.1;
next	1.120;

1.120
date	2005.06.14.10.50.47;	author hshoexer;	state Exp;
branches;
next	1.119;

1.119
date	2005.05.26.06.11.09;	author hshoexer;	state Exp;
branches;
next	1.118;

1.118
date	2005.05.04.10.05.01;	author hshoexer;	state Exp;
branches;
next	1.117;

1.117
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.116;

1.116
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.115;

1.115
date	2005.04.08.16.52.41;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2005.04.08.16.09.25;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.110;

1.110
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2005.04.04.18.40.45;	author hshoexer;	state Exp;
branches;
next	1.108;

1.108
date	2005.03.29.04.51.21;	author cloder;	state Exp;
branches;
next	1.107;

1.107
date	2005.03.18.17.27.39;	author cloder;	state Exp;
branches;
next	1.106;

1.106
date	2005.03.05.23.39.34;	author cloder;	state Exp;
branches;
next	1.105;

1.105
date	2004.12.14.10.17.28;	author mcbride;	state Exp;
branches;
next	1.104;

1.104
date	2004.09.17.13.53.08;	author ho;	state Exp;
branches;
next	1.103;

1.103
date	2004.08.10.15.59.10;	author ho;	state Exp;
branches;
next	1.102;

1.102
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2004.06.23.00.55.59;	author hshoexer;	state Exp;
branches;
next	1.100;

1.100
date	2004.06.21.23.27.10;	author ho;	state Exp;
branches;
next	1.99;

1.99
date	2004.06.21.18.29.06;	author ho;	state Exp;
branches;
next	1.98;

1.98
date	2004.06.20.17.17.35;	author ho;	state Exp;
branches;
next	1.97;

1.97
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.96;

1.96
date	2004.06.17.19.39.38;	author hshoexer;	state Exp;
branches;
next	1.95;

1.95
date	2004.06.16.15.05.37;	author hshoexer;	state Exp;
branches;
next	1.94;

1.94
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.93;

1.93
date	2004.06.10.12.54.53;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.91;

1.91
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.90;

1.90
date	2004.05.19.14.30.26;	author ho;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.15.18.39.25;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.87;

1.87
date	2004.03.10.23.08.48;	author hshoexer;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2004.02.27.19.14.57;	author hshoexer;	state Exp;
branches;
next	1.85;

1.85
date	2004.01.03.16.38.13;	author ho;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.15.10.06.42;	author hshoexer;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2003.11.06.15.50.53;	author ho;	state Exp;
branches;
next	1.81;

1.81
date	2003.10.14.14.29.15;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2003.09.02.18.15.55;	author ho;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2003.08.08.08.46.59;	author ho;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.25.08.31.16;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.10.12.21.29;	author ho;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.04.07.31.16;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2003.05.14.17.37.22;	author ho;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.12.21.43.21;	author ho;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.21.12.09.20;	author ho;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2002.09.11.09.50.43;	author ho;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.09.08.12.38.04;	author ho;	state Exp;
branches;
next	1.69;

1.69
date	2002.07.05.11.08.13;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.14.12.43.11;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.07.04.56.13;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.21.20.09.18;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.27.01.56.31;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2002.01.23.17.12.36;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2001.12.16.22.39.09;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.10.26.13.29.26;	author ho;	state Exp;
branches;
next	1.59;

1.59
date	2001.10.26.12.03.07;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.25.22.22.11;	author niklas;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2001.08.24.09.29.14;	author ho;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.23.19.32.46;	author niklas;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.22.08.49.00;	author niklas;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.06.14.37.11;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.04.22.23.24;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.01.20.43.39;	author niklas;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.01.14.17.06;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.29.19.08.11;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.29.18.52.17;	author ho;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.29.18.05.24;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.29.04.12.00;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.27.03.31.40;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.05.00.52.50;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.24.07.27.37;	author niklas;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.15.16.09.16;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	2001.03.29.06.51.25;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.07.07.33.53;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.24.03.59.55;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.27.12.03.33;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.14.23.40.01;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.11.00.46.28;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.10.21.29.04;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.10.19.48.29;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.12.01.45.31;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.21.06.44.04;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.16.23.26.33;	author niklas;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2000.10.09.23.27.30;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.07.06.58.47;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.03.07.24.58;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.08.20.50.41;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.25.17.23.40;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.19.19.32.53;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.26.15.23.32;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.07.13.15.46.43;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.07.07.22.13.08;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.06.02.06.33.36;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.05.06.22.44.16;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.05.02.22.05.35;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.05.02.19.20.33;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.04.30.23.32.08;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.04.30.11.47.41;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.27.21.05.18;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.19.21.04.41;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.04.05.20.57.50;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.04.02.01.09.07;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.03.31.20.29.37;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.31.14.27.37;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.03.31.00.51.07;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.03.24.14.43.12;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.02.27.09.59.36;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.03.43.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.12.21.01.02.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.48;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2000.11.25.03.26.14;	author jason;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2001.05.08.12.45.23;	author ho;	state Exp;
branches;
next	;

1.58.2.1
date	2002.02.21.04.18.57;	author jason;	state Exp;
branches;
next	;

1.71.2.1
date	2003.06.13.03.34.13;	author brad;	state Exp;
branches;
next	;

1.72.2.1
date	2003.06.13.03.50.53;	author brad;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2004.01.16.00.00.21;	author brad;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	2004.03.17.15.05.03;	author brad;	state Exp;
branches;
next	;

1.80.2.1
date	2004.01.13.22.50.07;	author brad;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2004.03.17.14.59.17;	author brad;	state Exp;
branches;
next	1.80.2.3;

1.80.2.3
date	2004.06.11.03.08.02;	author brad;	state Exp;
branches;
next	;

1.87.2.1
date	2004.06.11.02.34.56;	author brad;	state Exp;
branches;
next	;

1.121.2.1
date	2006.08.19.20.30.22;	author brad;	state Exp;
branches;
next	;

1.122.2.1
date	2006.08.19.20.23.28;	author brad;	state Exp;
branches;
next	;


desc
@@


1.147
log
@Prevent a NULL dereference when comparing incomplete SAs.

This deference can occur because sa_find() is called from a timer and
iterates over all existing `sa'.  At that time the corresponding
`finalize_exchange' might not have been called, in which case it is
unsafe to dereference `src_net', `dst_net' & co.

Issue reported by Micha≈Ç Koc. ok hshoexer@@, markus@@
@
text
@/* $OpenBSD: ipsec.c,v 1.146 2015/12/10 17:27:00 mmcc Exp $	 */
/* $EOM: ipsec.c,v 1.143 2000/12/11 23:57:42 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2001 HÂkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>

#include <net/if.h>
#include <net/pfvar.h>

#include "attribute.h"
#include "conf.h"
#include "connection.h"
#include "constants.h"
#include "crypto.h"
#include "dh.h"
#include "doi.h"
#include "dpd.h"
#include "exchange.h"
#include "hash.h"
#include "ike_aggressive.h"
#include "ike_auth.h"
#include "ike_main_mode.h"
#include "ike_quick_mode.h"
#include "ipsec.h"
#include "ipsec_doi.h"
#include "isakmp.h"
#include "isakmp_cfg.h"
#include "isakmp_fld.h"
#include "isakmp_num.h"
#include "log.h"
#include "message.h"
#include "nat_traversal.h"
#include "pf_key_v2.h"
#include "prf.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "util.h"
#include "x509.h"

extern int acquire_only;

#define MINIMUM(a, b)	(((a) < (b)) ? (a) : (b))
#define MAXIMUM(a, b)	(((a) > (b)) ? (a) : (b))

/* The replay window size used for all IPsec protocols if not overridden.  */
#define DEFAULT_REPLAY_WINDOW 16

struct ipsec_decode_arg {
	struct message *msg;
	struct sa      *sa;
	struct proto   *proto;
};

/* These variables hold the contacted peers ADT state.  */
struct contact {
	struct sockaddr *addr;
	socklen_t       len;
}              *contacts = 0;
int             contact_cnt = 0, contact_limit = 0;

static int      addr_cmp(const void *, const void *);
static int      ipsec_add_contact(struct message *);
static int      ipsec_contacted(struct message *);
static int      ipsec_debug_attribute(u_int16_t, u_int8_t *, u_int16_t,
    void *);
static void     ipsec_delete_spi(struct sa *, struct proto *, int);
static int16_t *ipsec_exchange_script(u_int8_t);
static void     ipsec_finalize_exchange(struct message *);
static void     ipsec_free_exchange_data(void *);
static void     ipsec_free_proto_data(void *);
static void     ipsec_free_sa_data(void *);
static struct keystate *ipsec_get_keystate(struct message *);
static u_int8_t *ipsec_get_spi(size_t *, u_int8_t, struct message *);
static int	ipsec_handle_leftover_payload(struct message *, u_int8_t,
    struct payload *);
static int      ipsec_informational_post_hook(struct message *);
static int      ipsec_informational_pre_hook(struct message *);
static int      ipsec_initiator(struct message *);
static void     ipsec_proto_init(struct proto *, char *);
static int      ipsec_responder(struct message *);
static void     ipsec_setup_situation(u_int8_t *);
static int      ipsec_set_network(u_int8_t *, u_int8_t *, struct sa *);
static size_t   ipsec_situation_size(void);
static u_int8_t ipsec_spi_size(u_int8_t);
static int      ipsec_validate_attribute(u_int16_t, u_int8_t *, u_int16_t,
    void *);
static int      ipsec_validate_exchange(u_int8_t);
static int	ipsec_validate_id_information(u_int8_t, u_int8_t *, u_int8_t *,
    size_t, struct exchange *);
static int      ipsec_validate_key_information(u_int8_t *, size_t);
static int      ipsec_validate_notification(u_int16_t);
static int      ipsec_validate_proto(u_int8_t);
static int      ipsec_validate_situation(u_int8_t *, size_t *, size_t);
static int      ipsec_validate_transform_id(u_int8_t, u_int8_t);
static int      ipsec_sa_check_flow(struct sa *, void *);
static int      ipsec_sa_check_flow_any(struct sa *, void *);
static int      ipsec_sa_tag(struct exchange *, struct sa *, struct sa *);

static struct doi ipsec_doi = {
	{0}, IPSEC_DOI_IPSEC,
	sizeof(struct ipsec_exch), sizeof(struct ipsec_sa),
	sizeof(struct ipsec_proto),
	ipsec_debug_attribute,
	ipsec_delete_spi,
	ipsec_exchange_script,
	ipsec_finalize_exchange,
	ipsec_free_exchange_data,
	ipsec_free_proto_data,
	ipsec_free_sa_data,
	ipsec_get_keystate,
	ipsec_get_spi,
	ipsec_handle_leftover_payload,
	ipsec_informational_post_hook,
	ipsec_informational_pre_hook,
	ipsec_is_attribute_incompatible,
	ipsec_proto_init,
	ipsec_setup_situation,
	ipsec_situation_size,
	ipsec_spi_size,
	ipsec_validate_attribute,
	ipsec_validate_exchange,
	ipsec_validate_id_information,
	ipsec_validate_key_information,
	ipsec_validate_notification,
	ipsec_validate_proto,
	ipsec_validate_situation,
	ipsec_validate_transform_id,
	ipsec_initiator,
	ipsec_responder,
	ipsec_decode_ids
};

int16_t script_quick_mode[] = {
	ISAKMP_PAYLOAD_HASH,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_SA,
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_HASH,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_SA,
	ISAKMP_PAYLOAD_NONCE,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_HASH,	/* Initiator -> responder.  */
	EXCHANGE_SCRIPT_END
};

int16_t script_new_group_mode[] = {
	ISAKMP_PAYLOAD_HASH,	/* Initiator -> responder.  */
	ISAKMP_PAYLOAD_SA,
	EXCHANGE_SCRIPT_SWITCH,
	ISAKMP_PAYLOAD_HASH,	/* Responder -> initiator.  */
	ISAKMP_PAYLOAD_SA,
	EXCHANGE_SCRIPT_END
};

struct dst_spi_proto_arg {
	struct sockaddr *dst;
	u_int32_t       spi;
	u_int8_t        proto;
};

/*
 * Check if SA matches what we are asking for through V_ARG.  It has to
 * be a finished phase 2 SA.
 * if "proto" arg is 0, match any proto
 */
static int
ipsec_sa_check(struct sa *sa, void *v_arg)
{
	struct dst_spi_proto_arg *arg = v_arg;
	struct proto   *proto;
	struct sockaddr *dst, *src;
	int             incoming;

	if (sa->phase != 2 || !(sa->flags & SA_FLAG_READY))
		return 0;

	sa->transport->vtbl->get_dst(sa->transport, &dst);
	if (memcmp(sockaddr_addrdata(dst), sockaddr_addrdata(arg->dst),
	    sockaddr_addrlen(dst)) == 0)
		incoming = 0;
	else {
		sa->transport->vtbl->get_src(sa->transport, &src);
		if (memcmp(sockaddr_addrdata(src), sockaddr_addrdata(arg->dst),
		    sockaddr_addrlen(src)) == 0)
			incoming = 1;
		else
			return 0;
	}

	for (proto = TAILQ_FIRST(&sa->protos); proto;
	    proto = TAILQ_NEXT(proto, link))
		if ((arg->proto == 0 || proto->proto == arg->proto) &&
		    memcmp(proto->spi[incoming], &arg->spi, sizeof arg->spi)
		    == 0)
			return 1;
	return 0;
}

/* Find an SA with a "name" of DST, SPI & PROTO.  */
struct sa *
ipsec_sa_lookup(struct sockaddr *dst, u_int32_t spi, u_int8_t proto)
{
	struct dst_spi_proto_arg arg;

	arg.dst = dst;
	arg.spi = spi;
	arg.proto = proto;
	return sa_find(ipsec_sa_check, &arg);
}

/*
 * Check if SA matches the flow of another SA in V_ARG.  It has to
 * be a finished non-replaced phase 2 SA.
 * XXX At some point other selectors will matter here too.
 */
static int
ipsec_sa_check_flow(struct sa *sa, void *v_arg)
{
	if ((sa->flags & (SA_FLAG_READY | SA_FLAG_REPLACED)) != SA_FLAG_READY)
		return 0;

	return ipsec_sa_check_flow_any(sa, v_arg);
}

static int
ipsec_sa_check_flow_any(struct sa *sa, void *v_arg)
{
	struct sa      *sa2 = v_arg;
	struct ipsec_sa *isa = sa->data, *isa2 = sa2->data;

	if (sa == sa2 || sa->phase != 2 ||
	    (sa->flags & SA_FLAG_READY) != SA_FLAG_READY)
		return 0;

	if (isa->tproto != isa2->tproto || isa->sport != isa2->sport ||
	    isa->dport != isa2->dport)
		return 0;

	/*
	 * If at least one of the IPsec SAs is incomplete, we're done.
	 */
	if (isa->src_net == NULL || isa2->src_net == NULL ||
	    isa->dst_net == NULL || isa2->dst_net == NULL ||
	    isa->src_mask == NULL || isa2->src_mask == NULL ||
	    isa->dst_mask == NULL || isa2->dst_mask == NULL)
		return 0;

	return isa->src_net->sa_family == isa2->src_net->sa_family &&
	    memcmp(sockaddr_addrdata(isa->src_net),
	    sockaddr_addrdata(isa2->src_net),
	    sockaddr_addrlen(isa->src_net)) == 0 &&
	    memcmp(sockaddr_addrdata(isa->src_mask),
	    sockaddr_addrdata(isa2->src_mask),
	    sockaddr_addrlen(isa->src_mask)) == 0 &&
	    memcmp(sockaddr_addrdata(isa->dst_net),
	    sockaddr_addrdata(isa2->dst_net),
	    sockaddr_addrlen(isa->dst_net)) == 0 &&
	    memcmp(sockaddr_addrdata(isa->dst_mask),
	    sockaddr_addrdata(isa2->dst_mask),
	    sockaddr_addrlen(isa->dst_mask)) == 0;
}

/*
 * Construct a PF tag if specified in the configuration.
 * It is possible to use variables to expand the tag:
 * $id		The string representation of the remote ID
 * $domain	The stripped domain part of the ID (for FQDN and UFQDN)
 */
static int
ipsec_sa_tag(struct exchange *exchange, struct sa *sa, struct sa *isakmp_sa)
{
	char *format, *section;
	char *id_string = NULL, *domain = NULL;
	int error = -1;
	size_t len;

	sa->tag = NULL;

	if (exchange->name == NULL ||
	    (section = exchange->name) == NULL ||
	    (format = conf_get_str(section, "PF-Tag")) == NULL)
		return (0);	/* ignore if not present */

	len = PF_TAG_NAME_SIZE;
	if ((sa->tag = calloc(1, len)) == NULL) {
		log_error("ipsec_sa_tag: calloc");
		goto fail;
	}
	if (strlcpy(sa->tag, format, len) >= len) {
		log_print("ipsec_sa_tag: tag too long");
		goto fail;
	}
	if (isakmp_sa->initiator)
		id_string = ipsec_id_string(isakmp_sa->id_r,
		    isakmp_sa->id_r_len);
	else
		id_string = ipsec_id_string(isakmp_sa->id_i,
		    isakmp_sa->id_i_len);

	if (strstr(format, "$id") != NULL) {
		if (id_string == NULL) {
			log_print("ipsec_sa_tag: cannot get ID");
			goto fail;
		}
		if (expand_string(sa->tag, len, "$id", id_string) != 0) {
			log_print("ipsec_sa_tag: failed to expand tag");
			goto fail;
		}
	}

	if (strstr(format, "$domain") != NULL) {
		if (id_string == NULL) {
			log_print("ipsec_sa_tag: cannot get ID");
			goto fail;
		}
		if (strncmp(id_string, "fqdn/", strlen("fqdn/")) == 0)
			domain = strchr(id_string, '.');
		else if (strncmp(id_string, "ufqdn/", strlen("ufqdn/")) == 0)
			domain = strchr(id_string, '@@');
		if (domain == NULL || strlen(domain) < 2) {
			log_print("ipsec_sa_tag: no valid domain in ID %s",
			    id_string);
			goto fail;
		}
		domain++;
		if (expand_string(sa->tag, len, "$domain", domain) != 0) {
			log_print("ipsec_sa_tag: failed to expand tag");
			goto fail;
		}
	}

	LOG_DBG((LOG_SA, 10, "ipsec_sa_tag: tag_len %ld tag \"%s\"",
	    strlen(sa->tag), sa->tag));

	error = 0;
 fail:
	free(id_string);
	if (error != 0) {
		free(sa->tag);
		sa->tag = NULL;
	}

	return (error);
}

/*
 * Do IPsec DOI specific finalizations task for the exchange where MSG was
 * the final message.
 */
static void
ipsec_finalize_exchange(struct message *msg)
{
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct sa      *sa = 0, *old_sa;
	struct proto   *proto, *last_proto = 0;
	char           *addr1, *addr2, *mask1, *mask2;

	switch (exchange->phase) {
	case 1:
		switch (exchange->type) {
		case ISAKMP_EXCH_ID_PROT:
		case ISAKMP_EXCH_AGGRESSIVE:
			isa = isakmp_sa->data;
			isa->hash = ie->hash->type;
			isa->prf_type = ie->prf_type;
			isa->skeyid_len = ie->skeyid_len;
			isa->skeyid_d = ie->skeyid_d;
			isa->skeyid_a = ie->skeyid_a;
			/* Prevents early free of SKEYID_*.  */
			ie->skeyid_a = ie->skeyid_d = 0;

			/*
			 * If a lifetime was negotiated setup the expiration
			 * timers.
			 */
			if (isakmp_sa->seconds)
				sa_setup_expirations(isakmp_sa);

			if (isakmp_sa->flags & SA_FLAG_NAT_T_KEEPALIVE)
				nat_t_setup_keepalive(isakmp_sa);
			break;
		}
		break;

	case 2:
		switch (exchange->type) {
		case IKE_EXCH_QUICK_MODE:
			/*
			 * Tell the application(s) about the SPIs and key
			 * material.
			 */
			for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
			    sa = TAILQ_NEXT(sa, next)) {
				isa = sa->data;

				if (exchange->initiator) {
					/*
					 * Initiator is source, responder is
					 * destination.
					 */
					if (ipsec_set_network(ie->id_ci,
					    ie->id_cr, sa)) {
						log_print(
						    "ipsec_finalize_exchange: "
						    "ipsec_set_network "
						    "failed");
						return;
					}
				} else {
					/*
					 * Responder is source, initiator is
					 * destination.
					 */
					if (ipsec_set_network(ie->id_cr,
					    ie->id_ci, sa)) {
						log_print(
						    "ipsec_finalize_exchange: "
						    "ipsec_set_network "
						    "failed");
						return;
					}
				}

				if (ipsec_sa_tag(exchange, sa, isakmp_sa) == -1)
					return;

				for (proto = TAILQ_FIRST(&sa->protos),
				    last_proto = 0; proto;
				    proto = TAILQ_NEXT(proto, link)) {
					if (pf_key_v2_set_spi(sa, proto,
					    0, isakmp_sa) ||
					    (last_proto &&
					    pf_key_v2_group_spis(sa,
						last_proto, proto, 0)) ||
					    pf_key_v2_set_spi(sa, proto,
						1, isakmp_sa) ||
					    (last_proto &&
						pf_key_v2_group_spis(sa,
						last_proto, proto, 1)))
						/*
						 * XXX Tear down this
						 * exchange.
						 */
						return;
					last_proto = proto;
				}

				if (sockaddr2text(isa->src_net, &addr1, 0))
					addr1 = 0;
				if (sockaddr2text(isa->src_mask, &mask1, 0))
					mask1 = 0;
				if (sockaddr2text(isa->dst_net, &addr2, 0))
					addr2 = 0;
				if (sockaddr2text(isa->dst_mask, &mask2, 0))
					mask2 = 0;

				LOG_DBG((LOG_EXCHANGE, 50,
				    "ipsec_finalize_exchange: src %s %s "
				    "dst %s %s tproto %u sport %u dport %u",
				    addr1 ? addr1 : "<??\?>",
				    mask1 ?  mask1 : "<??\?>",
				    addr2 ? addr2 : "<??\?>",
				    mask2 ? mask2 : "<??\?>",
				    isa->tproto, ntohs(isa->sport),
				    ntohs(isa->dport)));

				free(addr1);
				free(mask1);
				free(addr2);
				free(mask2);

				/*
				 * If this is not an SA acquired by the
				 * kernel, it needs to have a SPD entry
				 * (a.k.a. flow) set up.
				 */
				if (!(sa->flags & SA_FLAG_ONDEMAND ||
				    conf_get_str("General", "Acquire-Only") ||
				    acquire_only) &&
				    pf_key_v2_enable_sa(sa, isakmp_sa))
					/* XXX Tear down this exchange.  */
					return;

				/*
				 * Mark elder SAs with the same flow
				 * information as replaced.
				 */
				while ((old_sa = sa_find(ipsec_sa_check_flow,
				    sa)) != 0)
					sa_mark_replaced(old_sa);
			}
			break;
		}
	}
}

/* Set the client addresses in ISA from SRC_ID and DST_ID.  */
static int
ipsec_set_network(u_int8_t *src_id, u_int8_t *dst_id, struct sa *sa)
{
	void               *src_net, *dst_net;
	void               *src_mask = NULL, *dst_mask = NULL;
	struct sockaddr    *addr;
	struct proto       *proto;
	struct ipsec_proto *iproto;
	struct ipsec_sa    *isa = sa->data;
	int                 src_af, dst_af;
	int                 id;
	char               *name, *nat = NULL;
	u_int8_t           *nat_id = NULL;
	size_t              nat_sz;

	if ((name = connection_passive_lookup_by_ids(src_id, dst_id)))
		nat = conf_get_str(name, "NAT-ID");

	if (nat) {
		if ((nat_id = ipsec_build_id(nat, &nat_sz))) {
			LOG_DBG((LOG_EXCHANGE, 50, "ipsec_set_network: SRC-NAT:"
			    " src: %s -> %s", name, nat));
			src_id = nat_id;
		} else
			log_print("ipsec_set_network: ipsec_build_id"
			    " failed for NAT-ID: %s", nat);
	}

	if (((proto = TAILQ_FIRST(&sa->protos)) != NULL) &&
	    ((iproto = proto->data) != NULL) && 
	    (iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TRANSPORT ||
	    iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TRANSPORT_DRAFT)) {
		/*
		 * For NAT-T with transport mode, we need to use the ISAKMP's
		 * SA addresses for the flow.
		 */
		sa->transport->vtbl->get_src(sa->transport, &addr);
		src_af = addr->sa_family;
		src_net = sockaddr_addrdata(addr);

		sa->transport->vtbl->get_dst(sa->transport, &addr);
		dst_af = addr->sa_family;
		dst_net = sockaddr_addrdata(addr);
	} else {
		id = GET_ISAKMP_ID_TYPE(src_id);
		src_net = src_id + ISAKMP_ID_DATA_OFF;
		switch (id) {
		case IPSEC_ID_IPV4_ADDR_SUBNET:
			src_mask = (u_int8_t *)src_net + sizeof(struct in_addr);
			/* FALLTHROUGH */
		case IPSEC_ID_IPV4_ADDR:
			src_af = AF_INET;
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
			src_mask = (u_int8_t *)src_net +
			    sizeof(struct in6_addr);
			/* FALLTHROUGH */
		case IPSEC_ID_IPV6_ADDR:
			src_af = AF_INET6;
			break;

		default:
			log_print(
			    "ipsec_set_network: ID type %d (%s) not supported",
			    id, constant_name(ipsec_id_cst, id));
			return -1;
		}

		id = GET_ISAKMP_ID_TYPE(dst_id);
		dst_net = dst_id + ISAKMP_ID_DATA_OFF;
		switch (id) {
		case IPSEC_ID_IPV4_ADDR_SUBNET:
			dst_mask = (u_int8_t *)dst_net + sizeof(struct in_addr);
			/* FALLTHROUGH */
		case IPSEC_ID_IPV4_ADDR:
			dst_af = AF_INET;
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
			dst_mask = (u_int8_t *)dst_net +
			    sizeof(struct in6_addr);
			/* FALLTHROUGH */
		case IPSEC_ID_IPV6_ADDR:
			dst_af = AF_INET6;
			break;

		default:
			log_print(
			    "ipsec_set_network: ID type %d (%s) not supported",
			    id, constant_name(ipsec_id_cst, id));
			return -1;
		}
	}

	/* Set source address/mask.  */
	switch (src_af) {
	case AF_INET:
		isa->src_net = calloc(1, sizeof(struct sockaddr_in));
		if (!isa->src_net)
			goto memfail;
		isa->src_net->sa_family = AF_INET;
		isa->src_net->sa_len = sizeof(struct sockaddr_in);

		isa->src_mask = calloc(1, sizeof(struct sockaddr_in));
		if (!isa->src_mask)
			goto memfail;
		isa->src_mask->sa_family = AF_INET;
		isa->src_mask->sa_len = sizeof(struct sockaddr_in);
		break;

	case AF_INET6:
		isa->src_net = calloc(1, sizeof(struct sockaddr_in6));
		if (!isa->src_net)
			goto memfail;
		isa->src_net->sa_family = AF_INET6;
		isa->src_net->sa_len = sizeof(struct sockaddr_in6);

		isa->src_mask = calloc(1, sizeof(struct sockaddr_in6));
		if (!isa->src_mask)
			goto memfail;
		isa->src_mask->sa_family = AF_INET6;
		isa->src_mask->sa_len = sizeof(struct sockaddr_in6);
		break;
	}

	/* Net */
	memcpy(sockaddr_addrdata(isa->src_net), src_net,
	    sockaddr_addrlen(isa->src_net));

	/* Mask */
	if (src_mask == NULL)
		memset(sockaddr_addrdata(isa->src_mask), 0xff,
		    sockaddr_addrlen(isa->src_mask));
	else
		memcpy(sockaddr_addrdata(isa->src_mask), src_mask,
		    sockaddr_addrlen(isa->src_mask));

	memcpy(&isa->sport,
	    src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	    IPSEC_ID_PORT_LEN);

	free(nat_id);

	/* Set destination address.  */
	switch (dst_af) {
	case AF_INET:
		isa->dst_net = calloc(1, sizeof(struct sockaddr_in));
		if (!isa->dst_net)
			goto memfail;
		isa->dst_net->sa_family = AF_INET;
		isa->dst_net->sa_len = sizeof(struct sockaddr_in);

		isa->dst_mask = calloc(1, sizeof(struct sockaddr_in));
		if (!isa->dst_mask)
			goto memfail;
		isa->dst_mask->sa_family = AF_INET;
		isa->dst_mask->sa_len = sizeof(struct sockaddr_in);
		break;

	case AF_INET6:
		isa->dst_net = calloc(1, sizeof(struct sockaddr_in6));
		if (!isa->dst_net)
			goto memfail;
		isa->dst_net->sa_family = AF_INET6;
		isa->dst_net->sa_len = sizeof(struct sockaddr_in6);

		isa->dst_mask = calloc(1, sizeof(struct sockaddr_in6));
		if (!isa->dst_mask)
			goto memfail;
		isa->dst_mask->sa_family = AF_INET6;
		isa->dst_mask->sa_len = sizeof(struct sockaddr_in6);
		break;
	}

	/* Net */
	memcpy(sockaddr_addrdata(isa->dst_net), dst_net,
	    sockaddr_addrlen(isa->dst_net));

	/* Mask */
	if (dst_mask == NULL)
		memset(sockaddr_addrdata(isa->dst_mask), 0xff,
		    sockaddr_addrlen(isa->dst_mask));
	else
		memcpy(sockaddr_addrdata(isa->dst_mask), dst_mask,
		    sockaddr_addrlen(isa->dst_mask));

	memcpy(&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF +
	    IPSEC_ID_PROTO_OFF, IPSEC_ID_PROTO_LEN);
	memcpy(&isa->dport,
	    dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	    IPSEC_ID_PORT_LEN);
	return 0;

memfail:
	log_error("ipsec_set_network: calloc () failed");
	return -1;
}

/* Free the DOI-specific exchange data pointed to by VIE.  */
static void
ipsec_free_exchange_data(void *vie)
{
	struct ipsec_exch *ie = vie;
	struct isakmp_cfg_attr *attr;

	free(ie->sa_i_b);
	free(ie->id_ci);
	free(ie->id_cr);
	free(ie->g_xi);
	free(ie->g_xr);
	free(ie->g_xy);
	free(ie->skeyid);
	free(ie->skeyid_d);
	free(ie->skeyid_a);
	free(ie->skeyid_e);
	free(ie->hash_i);
	free(ie->hash_r);
	if (ie->group)
		group_free(ie->group);
	for (attr = LIST_FIRST(&ie->attrs); attr;
	    attr = LIST_FIRST(&ie->attrs)) {
		LIST_REMOVE(attr, link);
		if (attr->length)
			free(attr->value);
		free(attr);
	}
}

/* Free the DOI-specific SA data pointed to by VISA.  */
static void
ipsec_free_sa_data(void *visa)
{
	struct ipsec_sa *isa = visa;

	free(isa->src_net);
	free(isa->src_mask);
	free(isa->dst_net);
	free(isa->dst_mask);
	free(isa->skeyid_a);
	free(isa->skeyid_d);
}

/* Free the DOI-specific protocol data of an SA pointed to by VIPROTO.  */
static void
ipsec_free_proto_data(void *viproto)
{
	struct ipsec_proto *iproto = viproto;
	int             i;

	for (i = 0; i < 2; i++)
		free(iproto->keymat[i]);
}

/* Return exchange script based on TYPE.  */
static int16_t *
ipsec_exchange_script(u_int8_t type)
{
	switch (type) {
	case ISAKMP_EXCH_TRANSACTION:
		return script_transaction;
	case IKE_EXCH_QUICK_MODE:
		return script_quick_mode;
	case IKE_EXCH_NEW_GROUP_MODE:
		return script_new_group_mode;
	}
	return 0;
}

/* Initialize this DOI, requires doi_init to already have been called.  */
void
ipsec_init(void)
{
	doi_register(&ipsec_doi);
}

/* Given a message MSG, return a suitable IV (or rather keystate).  */
static struct keystate *
ipsec_get_keystate(struct message *msg)
{
	struct keystate *ks;
	struct hash    *hash;

	/* If we have already have an IV, use it.  */
	if (msg->exchange && msg->exchange->keystate) {
		ks = malloc(sizeof *ks);
		if (!ks) {
			log_error("ipsec_get_keystate: malloc (%lu) failed",
			    (unsigned long) sizeof *ks);
			return 0;
		}
		memcpy(ks, msg->exchange->keystate, sizeof *ks);
		return ks;
	}
	/*
	 * For phase 2 when no SA yet is setup we need to hash the IV used by
	 * the ISAKMP SA concatenated with the message ID, and use that as an
	 * IV for further cryptographic operations.
         */
	if (!msg->isakmp_sa->keystate) {
		log_print("ipsec_get_keystate: no keystate in ISAKMP SA %p",
		    msg->isakmp_sa);
		return 0;
	}
	ks = crypto_clone_keystate(msg->isakmp_sa->keystate);
	if (!ks)
		return 0;

	hash = hash_get(((struct ipsec_sa *)msg->isakmp_sa->data)->hash);
	hash->Init(hash->ctx);
	LOG_DBG_BUF((LOG_CRYPTO, 80, "ipsec_get_keystate: final phase 1 IV",
	    ks->riv, ks->xf->blocksize));
	hash->Update(hash->ctx, ks->riv, ks->xf->blocksize);
	LOG_DBG_BUF((LOG_CRYPTO, 80, "ipsec_get_keystate: message ID",
	    ((u_int8_t *) msg->iov[0].iov_base) + ISAKMP_HDR_MESSAGE_ID_OFF,
	    ISAKMP_HDR_MESSAGE_ID_LEN));
	hash->Update(hash->ctx, ((u_int8_t *) msg->iov[0].iov_base) +
	    ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN);
	hash->Final(hash->digest, hash->ctx);
	crypto_init_iv(ks, hash->digest, ks->xf->blocksize);
	LOG_DBG_BUF((LOG_CRYPTO, 80, "ipsec_get_keystate: phase 2 IV",
	    hash->digest, ks->xf->blocksize));
	return ks;
}

static void
ipsec_setup_situation(u_int8_t *buf)
{
	SET_IPSEC_SIT_SIT(buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);
}

static size_t
ipsec_situation_size(void)
{
	return IPSEC_SIT_SIT_LEN;
}

static u_int8_t
ipsec_spi_size(u_int8_t proto)
{
	return IPSEC_SPI_SIZE;
}

static int
ipsec_validate_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
    void *vmsg)
{
	struct message *msg = vmsg;

	if (msg->exchange->phase == 1 &&
	    (type < IKE_ATTR_ENCRYPTION_ALGORITHM || type > IKE_ATTR_GROUP_ORDER))
		return -1;
	if (msg->exchange->phase == 2 &&
	    (type < IPSEC_ATTR_SA_LIFE_TYPE || type > IPSEC_ATTR_ECN_TUNNEL))
		return -1;
	return 0;
}

static int
ipsec_validate_exchange(u_int8_t exch)
{
	return exch != IKE_EXCH_QUICK_MODE && exch != IKE_EXCH_NEW_GROUP_MODE;
}

static int
ipsec_validate_id_information(u_int8_t type, u_int8_t *extra, u_int8_t *buf,
    size_t sz, struct exchange *exchange)
{
	u_int8_t        proto = GET_IPSEC_ID_PROTO(extra);
	u_int16_t       port = GET_IPSEC_ID_PORT(extra);

	LOG_DBG((LOG_MESSAGE, 40,
	    "ipsec_validate_id_information: proto %d port %d type %d",
	    proto, port, type));
	if (type < IPSEC_ID_IPV4_ADDR || type > IPSEC_ID_KEY_ID)
		return -1;

	switch (type) {
	case IPSEC_ID_IPV4_ADDR:
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv4", buf,
		    sizeof(struct in_addr)));
		break;

	case IPSEC_ID_IPV6_ADDR:
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv6", buf,
		    sizeof(struct in6_addr)));
		break;

	case IPSEC_ID_IPV4_ADDR_SUBNET:
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv4 network/netmask",
		    buf, 2 * sizeof(struct in_addr)));
		break;

	case IPSEC_ID_IPV6_ADDR_SUBNET:
		LOG_DBG_BUF((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv6 network/netmask",
		    buf, 2 * sizeof(struct in6_addr)));
		break;

	default:
		break;
	}

	if (exchange->phase == 1 &&
	    (proto != IPPROTO_UDP || port != UDP_DEFAULT_PORT) &&
	    (proto != 0 || port != 0)) {
		/*
		 * XXX SSH's ISAKMP tester fails this test (proto 17 - port
		 * 0).
		 */
#ifdef notyet
		return -1;
#else
		log_print("ipsec_validate_id_information: dubious ID "
		    "information accepted");
#endif
	}
	/* XXX More checks?  */

	return 0;
}

static int
ipsec_validate_key_information(u_int8_t *buf, size_t sz)
{
	/* XXX Not implemented yet.  */
	return 0;
}

static int
ipsec_validate_notification(u_int16_t type)
{
	return type < IPSEC_NOTIFY_RESPONDER_LIFETIME ||
	    type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
}

static int
ipsec_validate_proto(u_int8_t proto)
{
	return proto < IPSEC_PROTO_IPSEC_AH ||
	    proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
}

static int
ipsec_validate_situation(u_int8_t *buf, size_t *sz, size_t len)
{
	if (len < IPSEC_SIT_SIT_OFF + IPSEC_SIT_SIT_LEN) {
		log_print("ipsec_validate_situation: payload too short: %u",
		    (unsigned int) len);
		return -1;
	}
	/* Currently only "identity only" situations are supported.  */
	if (GET_IPSEC_SIT_SIT(buf) != IPSEC_SIT_IDENTITY_ONLY)
		return 1;

	*sz = IPSEC_SIT_SIT_LEN;

	return 0;
}

static int
ipsec_validate_transform_id(u_int8_t proto, u_int8_t transform_id)
{
	switch (proto) {
	/*
	 * As no unexpected protocols can occur, we just tie the
	 * default case to the first case, in order to silence a GCC
	 * warning.
	 */
	default:
	case ISAKMP_PROTO_ISAKMP:
		return transform_id != IPSEC_TRANSFORM_KEY_IKE;
	case IPSEC_PROTO_IPSEC_AH:
		return transform_id < IPSEC_AH_MD5 ||
		    transform_id > IPSEC_AH_RIPEMD ? -1 : 0;
	case IPSEC_PROTO_IPSEC_ESP:
		return transform_id < IPSEC_ESP_DES_IV64 ||
		    (transform_id > IPSEC_ESP_AES_GMAC &&
		    transform_id < IPSEC_ESP_AES_MARS) ||
		    transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
	case IPSEC_PROTO_IPCOMP:
		return transform_id < IPSEC_IPCOMP_OUI ||
		    transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
	}
}

static int
ipsec_initiator(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	int             (**script)(struct message *) = 0;

	/* Check that the SA is coherent with the IKE rules.  */
	if (exchange->type != ISAKMP_EXCH_TRANSACTION &&
	    ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT &&
	    exchange->type != ISAKMP_EXCH_AGGRESSIVE &&
	    exchange->type != ISAKMP_EXCH_INFO) ||
	    (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE &&
	    exchange->type != ISAKMP_EXCH_INFO))) {
		log_print("ipsec_initiator: unsupported exchange type %d "
		    "in phase %d", exchange->type, exchange->phase);
		return -1;
	}
	switch (exchange->type) {
	case ISAKMP_EXCH_ID_PROT:
		script = ike_main_mode_initiator;
		break;
	case ISAKMP_EXCH_AGGRESSIVE:
		script = ike_aggressive_initiator;
		break;
	case ISAKMP_EXCH_TRANSACTION:
		script = isakmp_cfg_initiator;
		break;
	case ISAKMP_EXCH_INFO:
		return message_send_info(msg);
	case IKE_EXCH_QUICK_MODE:
		script = ike_quick_mode_initiator;
		break;
	default:
		log_print("ipsec_initiator: unsupported exchange type %d",
			  exchange->type);
		return -1;
	}

	/* Run the script code for this step.  */
	if (script)
		return script[exchange->step] (msg);

	return 0;
}

/*
 * delete all SA's from addr with the associated proto and SPI's
 *
 * spis[] is an array of SPIs of size 16-octet for proto ISAKMP
 * or 4-octet otherwise.
 */
static void
ipsec_delete_spi_list(struct sockaddr *addr, u_int8_t proto, u_int8_t *spis,
    int nspis, char *type)
{
	struct sa	*sa;
	char		*peer;
	char		 ids[1024];
	int		 i;

	for (i = 0; i < nspis; i++) {
		if (proto == ISAKMP_PROTO_ISAKMP) {
			u_int8_t *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;

			/*
			 * This really shouldn't happen in IPSEC DOI
			 * code, but Cisco VPN 3000 sends ISAKMP DELETE's
			 * this way.
			 */
			sa = sa_lookup_isakmp_sa(addr, spi);
		} else {
			u_int32_t spi = ((u_int32_t *)spis)[i];

			sa = ipsec_sa_lookup(addr, spi, proto);
		}

		if (sa == NULL) {
			LOG_DBG((LOG_SA, 30, "ipsec_delete_spi_list: could "
			    "not locate SA (SPI %08x, proto %u)",
			    ((u_int32_t *)spis)[i], proto));
			continue;
		}

		strlcpy(ids,
		    sa->doi->decode_ids("initiator id: %s, responder id: %s",
		    sa->id_i, sa->id_i_len, sa->id_r, sa->id_r_len, 0),
		    sizeof ids);
		if (sockaddr2text(addr, &peer, 0))
			peer = NULL;

		/* only log deletion of SAs which are not soft expired yet */
		if (sa->soft_death != NULL)
			log_verbose("isakmpd: Peer %s made us delete live SA "
			    "%s for proto %d, %s", peer ? peer : "<unknown>",
			    sa->name ? sa->name : "<unnamed>", proto, ids);

		LOG_DBG((LOG_SA, 30, "ipsec_delete_spi_list: "
		    "%s made us delete SA %p (%d references) for proto %d (%s)",
		    type, sa, sa->refcnt, proto, ids));
		free(peer);

		/* Delete the SA and search for the next */
		sa_free(sa);
	}
}

static int
ipsec_responder(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	int             (**script)(struct message *) = 0;
	struct payload *p;
	u_int16_t       type;

	/* Check that a new exchange is coherent with the IKE rules.  */
	if (exchange->step == 0 && exchange->type != ISAKMP_EXCH_TRANSACTION &&
	    ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT &&
	    exchange->type != ISAKMP_EXCH_AGGRESSIVE &&
	    exchange->type != ISAKMP_EXCH_INFO) ||
	    (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE &&
	    exchange->type != ISAKMP_EXCH_INFO))) {
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE,
		    0, 1, 0);
		return -1;
	}
	LOG_DBG((LOG_MISC, 30, "ipsec_responder: phase %d exchange %d step %d",
	    exchange->phase, exchange->type, exchange->step));
	switch (exchange->type) {
	case ISAKMP_EXCH_ID_PROT:
		script = ike_main_mode_responder;
		break;
	case ISAKMP_EXCH_AGGRESSIVE:
		script = ike_aggressive_responder;
		break;
	case ISAKMP_EXCH_TRANSACTION:
		script = isakmp_cfg_responder;
		break;
	case ISAKMP_EXCH_INFO:
		TAILQ_FOREACH(p, &msg->payload[ISAKMP_PAYLOAD_NOTIFY], link) {
			type = GET_ISAKMP_NOTIFY_MSG_TYPE(p->p);
			LOG_DBG((LOG_EXCHANGE, 10,
			    "ipsec_responder: got NOTIFY of type %s",
			    constant_name(isakmp_notify_cst, type)));

			switch (type) {
			case IPSEC_NOTIFY_INITIAL_CONTACT:
				/* Handled by leftover logic. */
				break;

			case ISAKMP_NOTIFY_STATUS_DPD_R_U_THERE:
			case ISAKMP_NOTIFY_STATUS_DPD_R_U_THERE_ACK:
				dpd_handle_notify(msg, p);
				break;

			default:
				p->flags |= PL_MARK;
				break;
			}
		}

		/*
		 * If any DELETEs are in here, let the logic of leftover
		 * payloads deal with them.
		 */
		return 0;

	case IKE_EXCH_QUICK_MODE:
		script = ike_quick_mode_responder;
		break;

	default:
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE,
		    0, 1, 0);
		return -1;
	}

	/* Run the script code for this step.  */
	if (script)
		return script[exchange->step] (msg);

	/*
	 * XXX So far we don't accept any proposals for exchanges we don't
	 * support.
         */
	if (payload_first(msg, ISAKMP_PAYLOAD_SA)) {
		message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
		return -1;
	}
	return 0;
}

static enum hashes
from_ike_hash(u_int16_t hash)
{
	switch (hash) {
		case IKE_HASH_MD5:
		return HASH_MD5;
	case IKE_HASH_SHA:
		return HASH_SHA1;
	case IKE_HASH_SHA2_256:
		return HASH_SHA2_256;
	case IKE_HASH_SHA2_384:
		return HASH_SHA2_384;
	case IKE_HASH_SHA2_512:
		return HASH_SHA2_512;
	}
	return -1;
}

static enum transform
from_ike_crypto(u_int16_t crypto)
{
	/* Coincidentally this is the null operation :-)  */
	return crypto;
}

/*
 * Find out whether the attribute of type TYPE with a LEN length value
 * pointed to by VALUE is incompatible with what we can handle.
 * VMSG is a pointer to the current message.
 */
int
ipsec_is_attribute_incompatible(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vmsg)
{
	struct message *msg = vmsg;
	u_int16_t dv = decode_16(value);

	if (msg->exchange->phase == 1) {
		switch (type) {
		case IKE_ATTR_ENCRYPTION_ALGORITHM:
			return !crypto_get(from_ike_crypto(dv));
		case IKE_ATTR_HASH_ALGORITHM:
			return !hash_get(from_ike_hash(dv));
		case IKE_ATTR_AUTHENTICATION_METHOD:
			return !ike_auth_get(dv);
		case IKE_ATTR_GROUP_DESCRIPTION:
			return (dv < IKE_GROUP_DESC_MODP_768 ||
			    dv > IKE_GROUP_DESC_MODP_1536) &&
			    (dv < IKE_GROUP_DESC_MODP_2048 ||
			    dv > IKE_GROUP_DESC_MODP_8192);
		case IKE_ATTR_GROUP_TYPE:
			return 1;
		case IKE_ATTR_GROUP_PRIME:
			return 1;
		case IKE_ATTR_GROUP_GENERATOR_1:
			return 1;
		case IKE_ATTR_GROUP_GENERATOR_2:
			return 1;
		case IKE_ATTR_GROUP_CURVE_A:
			return 1;
		case IKE_ATTR_GROUP_CURVE_B:
			return 1;
		case IKE_ATTR_LIFE_TYPE:
			return dv < IKE_DURATION_SECONDS ||
			    dv > IKE_DURATION_KILOBYTES;
		case IKE_ATTR_LIFE_DURATION:
			return len != 2 && len != 4;
		case IKE_ATTR_PRF:
			return 1;
		case IKE_ATTR_KEY_LENGTH:
			/*
			 * Our crypto routines only allows key-lengths which
			 * are multiples of an octet.
			 */
			return dv % 8 != 0;
		case IKE_ATTR_FIELD_SIZE:
			return 1;
		case IKE_ATTR_GROUP_ORDER:
			return 1;
		}
	} else {
		switch (type) {
		case IPSEC_ATTR_SA_LIFE_TYPE:
			return dv < IPSEC_DURATION_SECONDS ||
			    dv > IPSEC_DURATION_KILOBYTES;
		case IPSEC_ATTR_SA_LIFE_DURATION:
			return len != 2 && len != 4;
		case IPSEC_ATTR_GROUP_DESCRIPTION:
			return (dv < IKE_GROUP_DESC_MODP_768 ||
			    dv > IKE_GROUP_DESC_MODP_1536) &&
			    (dv < IKE_GROUP_DESC_MODP_2048 ||
			    IKE_GROUP_DESC_MODP_8192 < dv);
		case IPSEC_ATTR_ENCAPSULATION_MODE:
			return dv != IPSEC_ENCAP_TUNNEL &&
			    dv != IPSEC_ENCAP_TRANSPORT &&
			    dv != IPSEC_ENCAP_UDP_ENCAP_TUNNEL &&
			    dv != IPSEC_ENCAP_UDP_ENCAP_TRANSPORT &&
			    dv != IPSEC_ENCAP_UDP_ENCAP_TUNNEL_DRAFT &&
			    dv != IPSEC_ENCAP_UDP_ENCAP_TRANSPORT_DRAFT;
		case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
			return dv < IPSEC_AUTH_HMAC_MD5 ||
			    dv > IPSEC_AUTH_HMAC_RIPEMD;
		case IPSEC_ATTR_KEY_LENGTH:
			/*
			 * XXX Blowfish needs '0'. Others appear to disregard
			 * this attr?
			 */
			return 0;
		case IPSEC_ATTR_KEY_ROUNDS:
			return 1;
		case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
			return 1;
		case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
			return 1;
		case IPSEC_ATTR_ECN_TUNNEL:
			return 1;
		}
	}
	/* XXX Silence gcc.  */
	return 1;
}

/*
 * Log the attribute of TYPE with a LEN length value pointed to by VALUE
 * in human-readable form.  VMSG is a pointer to the current message.
 */
int
ipsec_debug_attribute(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vmsg)
{
	struct message *msg = vmsg;
	char            val[20];

	/* XXX Transient solution.  */
	if (len == 2)
		snprintf(val, sizeof val, "%d", decode_16(value));
	else if (len == 4)
		snprintf(val, sizeof val, "%d", decode_32(value));
	else
		snprintf(val, sizeof val, "unrepresentable");

	LOG_DBG((LOG_MESSAGE, 50, "Attribute %s value %s",
	    constant_name(msg->exchange->phase == 1 ? ike_attr_cst :
	    ipsec_attr_cst, type), val));
	return 0;
}

/*
 * Decode the attribute of type TYPE with a LEN length value pointed to by
 * VALUE.  VIDA is a pointer to a context structure where we can find the
 * current message, SA and protocol.
 */
int
ipsec_decode_attribute(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *vida)
{
	struct ipsec_decode_arg *ida = vida;
	struct message *msg = ida->msg;
	struct sa      *sa = ida->sa;
	struct ipsec_sa *isa = sa->data;
	struct proto   *proto = ida->proto;
	struct ipsec_proto *iproto = proto->data;
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	static int      lifetype = 0;

	if (exchange->phase == 1) {
		switch (type) {
		case IKE_ATTR_ENCRYPTION_ALGORITHM:
			/* XXX Errors possible?  */
			exchange->crypto = crypto_get(from_ike_crypto(
			    decode_16(value)));
			break;
		case IKE_ATTR_HASH_ALGORITHM:
			/* XXX Errors possible?  */
			ie->hash = hash_get(from_ike_hash(decode_16(value)));
			break;
		case IKE_ATTR_AUTHENTICATION_METHOD:
			/* XXX Errors possible?  */
			ie->ike_auth = ike_auth_get(decode_16(value));
			break;
		case IKE_ATTR_GROUP_DESCRIPTION:
			isa->group_desc = decode_16(value);
			break;
		case IKE_ATTR_GROUP_TYPE:
			break;
		case IKE_ATTR_GROUP_PRIME:
			break;
		case IKE_ATTR_GROUP_GENERATOR_1:
			break;
		case IKE_ATTR_GROUP_GENERATOR_2:
			break;
		case IKE_ATTR_GROUP_CURVE_A:
			break;
		case IKE_ATTR_GROUP_CURVE_B:
			break;
		case IKE_ATTR_LIFE_TYPE:
			lifetype = decode_16(value);
			return 0;
		case IKE_ATTR_LIFE_DURATION:
			switch (lifetype) {
			case IKE_DURATION_SECONDS:
				switch (len) {
				case 2:
					sa->seconds = decode_16(value);
					break;
				case 4:
					sa->seconds = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
				}
				break;
			case IKE_DURATION_KILOBYTES:
				switch (len) {
				case 2:
					sa->kilobytes = decode_16(value);
					break;
				case 4:
					sa->kilobytes = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
				}
				break;
			default:
				log_print("ipsec_decode_attribute: unknown "
				    "lifetime type");
			}
			break;
		case IKE_ATTR_PRF:
			break;
		case IKE_ATTR_KEY_LENGTH:
			exchange->key_length = decode_16(value) / 8;
			break;
		case IKE_ATTR_FIELD_SIZE:
			break;
		case IKE_ATTR_GROUP_ORDER:
			break;
		}
	} else {
		switch (type) {
		case IPSEC_ATTR_SA_LIFE_TYPE:
			lifetype = decode_16(value);
			return 0;
		case IPSEC_ATTR_SA_LIFE_DURATION:
			switch (lifetype) {
			case IPSEC_DURATION_SECONDS:
				switch (len) {
				case 2:
					sa->seconds = decode_16(value);
					break;
				case 4:
					sa->seconds = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
				}
				break;
			case IPSEC_DURATION_KILOBYTES:
				switch (len) {
				case 2:
					sa->kilobytes = decode_16(value);
					break;
				case 4:
					sa->kilobytes = decode_32(value);
					break;
				default:
					log_print("ipsec_decode_attribute: "
					    "unreasonable lifetime");
				}
				break;
			default:
				log_print("ipsec_decode_attribute: unknown "
				    "lifetime type");
			}
			break;
		case IPSEC_ATTR_GROUP_DESCRIPTION:
			isa->group_desc = decode_16(value);
			break;
		case IPSEC_ATTR_ENCAPSULATION_MODE:
			/*
			 * XXX Multiple protocols must have same
			 * encapsulation mode, no?
			 */
			iproto->encap_mode = decode_16(value);
			break;
		case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
			iproto->auth = decode_16(value);
			break;
		case IPSEC_ATTR_KEY_LENGTH:
			iproto->keylen = decode_16(value);
			break;
		case IPSEC_ATTR_KEY_ROUNDS:
			iproto->keyrounds = decode_16(value);
			break;
		case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
			break;
		case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
			break;
		case IPSEC_ATTR_ECN_TUNNEL:
			break;
		}
	}
	lifetype = 0;
	return 0;
}

/*
 * Walk over the attributes of the transform payload found in BUF, and
 * fill out the fields of the SA attached to MSG.  Also mark the SA as
 * processed.
 */
void
ipsec_decode_transform(struct message *msg, struct sa *sa, struct proto *proto,
    u_int8_t *buf)
{
	struct ipsec_exch *ie = msg->exchange->data;
	struct ipsec_decode_arg ida;

	LOG_DBG((LOG_MISC, 20, "ipsec_decode_transform: transform %d chosen",
	    GET_ISAKMP_TRANSFORM_NO(buf)));

	ida.msg = msg;
	ida.sa = sa;
	ida.proto = proto;

	/* The default IKE lifetime is 8 hours.  */
	if (sa->phase == 1)
		sa->seconds = 28800;

	/* Extract the attributes and stuff them into the SA.  */
	attribute_map(buf + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    GET_ISAKMP_GEN_LENGTH(buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    ipsec_decode_attribute, &ida);

	/*
	 * If no pseudo-random function was negotiated, it's HMAC.
	 * XXX As PRF_HMAC currently is zero, this is a no-op.
         */
	if (!ie->prf_type)
		ie->prf_type = PRF_HMAC;
}

/*
 * Delete the IPsec SA represented by the INCOMING direction in protocol PROTO
 * of the IKE security association SA.
 */
static void
ipsec_delete_spi(struct sa *sa, struct proto *proto, int incoming)
{
	struct sa *new_sa;
	struct ipsec_proto *iproto;

	if (sa->phase == 1)
		return;

	iproto = proto->data;
	/*
	 * If the SA is using UDP encap and it replaced other SA,
	 * enable the other SA to keep the flow for the other SAs.
	 */
	if ((iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TRANSPORT ||
	    iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TRANSPORT_DRAFT) &&
	    (sa->flags & SA_FLAG_REPLACED) == 0 &&
	    (new_sa = sa_find(ipsec_sa_check_flow_any, sa)) != NULL &&
	    new_sa->flags & SA_FLAG_REPLACED)
		sa_replace(sa, new_sa);

	/*
	 * If the SA was not replaced and was not one acquired through the
	 * kernel (ACQUIRE message), remove the flow associated with it.
	 * We ignore any errors from the disabling of the flow.
	 */
	if (sa->flags & SA_FLAG_READY && !(sa->flags & SA_FLAG_ONDEMAND ||
	    sa->flags & SA_FLAG_REPLACED || acquire_only ||
	    conf_get_str("General", "Acquire-Only")))
		pf_key_v2_disable_sa(sa, incoming);

	/* XXX Error handling?  Is it interesting?  */
	pf_key_v2_delete_spi(sa, proto, incoming);
}

/*
 * Store BUF into the g^x entry of the exchange that message MSG belongs to.
 * PEER is non-zero when the value is our peer's, and zero when it is ours.
 */
static int
ipsec_g_x(struct message *msg, int peer, u_int8_t *buf)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t      **g_x;
	int             initiator = exchange->initiator ^ peer;
	char            header[32];

	g_x = initiator ? &ie->g_xi : &ie->g_xr;
	*g_x = malloc(ie->g_x_len);
	if (!*g_x) {
		log_error("ipsec_g_x: malloc (%lu) failed",
		    (unsigned long)ie->g_x_len);
		return -1;
	}
	memcpy(*g_x, buf, ie->g_x_len);
	snprintf(header, sizeof header, "ipsec_g_x: g^x%c",
	    initiator ? 'i' : 'r');
	LOG_DBG_BUF((LOG_MISC, 80, header, *g_x, ie->g_x_len));
	return 0;
}

/* Generate our DH value.  */
int
ipsec_gen_g_x(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	u_int8_t       *buf;

	buf = malloc(ISAKMP_KE_SZ + ie->g_x_len);
	if (!buf) {
		log_error("ipsec_gen_g_x: malloc (%lu) failed",
		    ISAKMP_KE_SZ + (unsigned long)ie->g_x_len);
		return -1;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_KEY_EXCH, buf,
	    ISAKMP_KE_SZ + ie->g_x_len, 1)) {
		free(buf);
		return -1;
	}
	if (dh_create_exchange(ie->group, buf + ISAKMP_KE_DATA_OFF)) {
		log_print("ipsec_gen_g_x: dh_create_exchange failed");
		free(buf);
		return -1;
	}
	return ipsec_g_x(msg, 0, buf + ISAKMP_KE_DATA_OFF);
}

/* Save the peer's DH value.  */
int
ipsec_save_g_x(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct ipsec_exch *ie = exchange->data;
	struct payload *kep;

	kep = payload_first(msg, ISAKMP_PAYLOAD_KEY_EXCH);
	kep->flags |= PL_MARK;
	ie->g_x_len = GET_ISAKMP_GEN_LENGTH(kep->p) - ISAKMP_KE_DATA_OFF;

	/* Check that the given length matches the group's expectancy.  */
	if (ie->g_x_len != (size_t) dh_getlen(ie->group)) {
		/* XXX Is this a good notify type?  */
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
		return -1;
	}
	return ipsec_g_x(msg, 1, kep->p + ISAKMP_KE_DATA_OFF);
}

/*
 * Get a SPI for PROTO and the transport MSG passed over.  Store the
 * size where SZ points.  NB!  A zero return is OK if *SZ is zero.
 */
static u_int8_t *
ipsec_get_spi(size_t *sz, u_int8_t proto, struct message *msg)
{
	struct sockaddr *dst, *src;
	struct transport *transport = msg->transport;

	if (msg->exchange->phase == 1) {
		*sz = 0;
		return 0;
	} else {
		/* We are the destination in the SA we want a SPI for.  */
		transport->vtbl->get_src(transport, &dst);
		/* The peer is the source.  */
		transport->vtbl->get_dst(transport, &src);
		return pf_key_v2_get_spi(sz, proto, src, dst,
		    msg->exchange->seq);
	}
}

/*
 * We have gotten a payload PAYLOAD of type TYPE, which did not get handled
 * by the logic of the exchange MSG takes part in.  Now is the time to deal
 * with such a payload if we know how to, if we don't, return -1, otherwise
 * 0.
 */
int
ipsec_handle_leftover_payload(struct message *msg, u_int8_t type,
    struct payload *payload)
{
	u_int32_t       spisz, nspis;
	struct sockaddr *dst;
	int             reenter = 0;
	u_int8_t       *spis, proto;
	struct sa      *sa;

	switch (type) {
	case ISAKMP_PAYLOAD_DELETE:
		proto = GET_ISAKMP_DELETE_PROTO(payload->p);
		nspis = GET_ISAKMP_DELETE_NSPIS(payload->p);
		spisz = GET_ISAKMP_DELETE_SPI_SZ(payload->p);

		if (nspis == 0) {
			LOG_DBG((LOG_SA, 60, "ipsec_handle_leftover_payload: "
			    "message specified zero SPIs, ignoring"));
			return -1;
		}
		/* verify proper SPI size */
		if ((proto == ISAKMP_PROTO_ISAKMP &&
		    spisz != ISAKMP_HDR_COOKIES_LEN) ||
		    (proto != ISAKMP_PROTO_ISAKMP && spisz != sizeof(u_int32_t))) {
			log_print("ipsec_handle_leftover_payload: invalid SPI "
			    "size %d for proto %d in DELETE payload",
			    spisz, proto);
			return -1;
		}
		spis = calloc(nspis, spisz);
		if (!spis) {
			log_error("ipsec_handle_leftover_payload: malloc "
			    "(%d) failed", nspis * spisz);
			return -1;
		}
		/* extract SPI and get dst address */
		memcpy(spis, payload->p + ISAKMP_DELETE_SPI_OFF, nspis * spisz);
		msg->transport->vtbl->get_dst(msg->transport, &dst);

		ipsec_delete_spi_list(dst, proto, spis, nspis, "DELETE");

		free(spis);
		payload->flags |= PL_MARK;
		return 0;

	case ISAKMP_PAYLOAD_NOTIFY:
		switch (GET_ISAKMP_NOTIFY_MSG_TYPE(payload->p)) {
		case IPSEC_NOTIFY_INITIAL_CONTACT:
			/*
			 * Permit INITIAL-CONTACT if
			 *   - this is not an AGGRESSIVE mode exchange
			 *   - it is protected by an ISAKMP SA
			 *
			 * XXX Instead of the first condition above, we could
			 * XXX permit this only for phase 2. In the last
			 * XXX packet of main-mode, this payload, while
			 * XXX encrypted, is not part of the hash digest.  As
			 * XXX we currently send our own INITIAL-CONTACTs at
			 * XXX this point, this too would need to be changed.
			 */
			if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE) {
				log_print("ipsec_handle_leftover_payload: got "
				    "INITIAL-CONTACT in AGGRESSIVE mode");
				return -1;
			}
			if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT)
			    == 0) {
				log_print("ipsec_handle_leftover_payload: got "
				    "INITIAL-CONTACT without ISAKMP SA");
				return -1;
			}

			if ((msg->flags & MSG_AUTHENTICATED) == 0) {
				log_print("ipsec_handle_leftover_payload: "
				    "got unauthenticated INITIAL-CONTACT");
				return -1;
			}
			/*
			 * Find out who is sending this and then delete every
			 * SA that is ready.  Exchanges will timeout
			 * themselves and then the non-ready SAs will
			 * disappear too.
			 */
			msg->transport->vtbl->get_dst(msg->transport, &dst);
			while ((sa = sa_lookup_by_peer(dst, SA_LEN(dst), 0)) != 0) {
				/*
				 * Don't delete the current SA -- we received
				 * the notification over it, so it's obviously
				 * still active. We temporarily need to remove
				 * the SA from the list to avoid an endless
				 * loop, but keep a reference so it won't
				 * disappear meanwhile.
				 */
				if (sa == msg->isakmp_sa) {
					sa_reference(sa);
					sa_remove(sa);
					reenter = 1;
					continue;
				}
				LOG_DBG((LOG_SA, 30,
				    "ipsec_handle_leftover_payload: "
				    "INITIAL-CONTACT made us delete SA %p",
				    sa));
				sa_delete(sa, 0);
			}

			if (reenter) {
				sa_enter(msg->isakmp_sa);
				sa_release(msg->isakmp_sa);
			}
			payload->flags |= PL_MARK;
			return 0;
		}
	}
	return -1;
}

/* Return the encryption keylength in octets of the ESP protocol PROTO.  */
int
ipsec_esp_enckeylength(struct proto *proto)
{
	struct ipsec_proto *iproto = proto->data;

	/* Compute the keylength to use.  */
	switch (proto->id) {
	case IPSEC_ESP_3DES:
		return 24;
	case IPSEC_ESP_CAST:
		if (!iproto->keylen)
			return 16;
		return iproto->keylen / 8;
	case IPSEC_ESP_AES_CTR:
	case IPSEC_ESP_AES_GCM_16:
	case IPSEC_ESP_AES_GMAC:
		if (!iproto->keylen)
			return 20;
		return iproto->keylen / 8 + 4;
	case IPSEC_ESP_AES:
		if (!iproto->keylen)
			return 16;
		/* FALLTHROUGH */
	default:
		return iproto->keylen / 8;
	}
}

/* Return the authentication keylength in octets of the ESP protocol PROTO.  */
int
ipsec_esp_authkeylength(struct proto *proto)
{
	struct ipsec_proto *iproto = proto->data;

	switch (iproto->auth) {
	case IPSEC_AUTH_HMAC_MD5:
		return 16;
	case IPSEC_AUTH_HMAC_SHA:
	case IPSEC_AUTH_HMAC_RIPEMD:
		return 20;
	case IPSEC_AUTH_HMAC_SHA2_256:
		return 32;
	case IPSEC_AUTH_HMAC_SHA2_384:
		return 48;
	case IPSEC_AUTH_HMAC_SHA2_512:
		return 64;
	default:
		return 0;
	}
}

/* Return the authentication keylength in octets of the AH protocol PROTO.  */
int
ipsec_ah_keylength(struct proto *proto)
{
	switch (proto->id) {
		case IPSEC_AH_MD5:
		return 16;
	case IPSEC_AH_SHA:
	case IPSEC_AH_RIPEMD:
		return 20;
	case IPSEC_AH_SHA2_256:
		return 32;
	case IPSEC_AH_SHA2_384:
		return 48;
	case IPSEC_AH_SHA2_512:
		return 64;
	default:
		return -1;
	}
}

/* Return the total keymaterial length of the protocol PROTO.  */
int
ipsec_keymat_length(struct proto *proto)
{
	switch (proto->proto) {
		case IPSEC_PROTO_IPSEC_ESP:
		return ipsec_esp_enckeylength(proto)
		    + ipsec_esp_authkeylength(proto);
	case IPSEC_PROTO_IPSEC_AH:
		return ipsec_ah_keylength(proto);
	default:
		return -1;
	}
}

/* Helper function for ipsec_get_id().  */
static int
ipsec_get_proto_port(char *section, u_int8_t *tproto, u_int16_t *port)
{
	struct protoent	*pe = NULL;
	struct servent	*se;
	char	*pstr;

	pstr = conf_get_str(section, "Protocol");
	if (!pstr) {
		*tproto = 0;
		return 0;
	}
	*tproto = (u_int8_t)atoi(pstr);
	if (!*tproto) {
		pe = getprotobyname(pstr);
		if (pe)
			*tproto = pe->p_proto;
	}
	if (!*tproto) {
		log_print("ipsec_get_proto_port: protocol \"%s\" unknown",
		    pstr);
		return -1;
	}

	pstr = conf_get_str(section, "Port");
	if (!pstr)
		return 0;
	*port = (u_int16_t)atoi(pstr);
	if (!*port) {
		se = getservbyname(pstr,
		    pe ? pe->p_name : (pstr ? pstr : NULL));
		if (se)
			*port = ntohs(se->s_port);
	}
	if (!*port) {
		log_print("ipsec_get_proto_port: port \"%s\" unknown",
		    pstr);
		return -1;
	}
	return 0;
}

/*
 * Out of a named section SECTION in the configuration file find out
 * the network address and mask as well as the ID type.  Put the info
 * in the areas pointed to by ADDR, MASK, TPROTO, PORT, and ID respectively.
 * Return 0 on success and -1 on failure.
 */
int
ipsec_get_id(char *section, int *id, struct sockaddr **addr,
    struct sockaddr **mask, u_int8_t *tproto, u_int16_t *port)
{
	char	*type, *address, *netmask;
	sa_family_t	af = 0;

	type = conf_get_str(section, "ID-type");
	if (!type) {
		log_print("ipsec_get_id: section %s has no \"ID-type\" tag",
		    section);
		return -1;
	}
	*id = constant_value(ipsec_id_cst, type);
	switch (*id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
		af = AF_INET;
		break;
	case IPSEC_ID_IPV6_ADDR:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		af = AF_INET6;
		break;
	}
	switch (*id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR: {
		int ret;

		address = conf_get_str(section, "Address");
		if (!address) {
			log_print("ipsec_get_id: section %s has no "
			    "\"Address\" tag", section);
			return -1;
		}
		if (text2sockaddr(address, NULL, addr, af, 0)) {
			log_print("ipsec_get_id: invalid address %s in "
			    "section %s", address, section);
			return -1;
		}
		ret = ipsec_get_proto_port(section, tproto, port);
		if (ret < 0)
			free(*addr);

		return ret;
	}

#ifdef notyet
	case IPSEC_ID_FQDN:
		return -1;

	case IPSEC_ID_USER_FQDN:
		return -1;
#endif

	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_SUBNET: {
		int ret;

		address = conf_get_str(section, "Network");
		if (!address) {
			log_print("ipsec_get_id: section %s has no "
			    "\"Network\" tag", section);
			return -1;
		}
		if (text2sockaddr(address, NULL, addr, af, 0)) {
			log_print("ipsec_get_id: invalid section %s "
			    "network %s", section, address);
			return -1;
		}
		netmask = conf_get_str(section, "Netmask");
		if (!netmask) {
			log_print("ipsec_get_id: section %s has no "
			    "\"Netmask\" tag", section);
			free(*addr);
			return -1;
		}
		if (text2sockaddr(netmask, NULL, mask, af, 1)) {
			log_print("ipsec_get_id: invalid section %s "
			    "network %s", section, netmask);
			free(*addr);
			return -1;
		}
		ret = ipsec_get_proto_port(section, tproto, port);
		if (ret < 0) {
			free(*mask);
			free(*addr);
		}
		return ret;
	}

#ifdef notyet
	case IPSEC_ID_IPV4_RANGE:
		return -1;

	case IPSEC_ID_IPV6_RANGE:
		return -1;

	case IPSEC_ID_DER_ASN1_DN:
		return -1;

	case IPSEC_ID_DER_ASN1_GN:
		return -1;

	case IPSEC_ID_KEY_ID:
		return -1;
#endif

	default:
		log_print("ipsec_get_id: unknown ID type \"%s\" in "
		    "section %s", type, section);
		return -1;
	}

	return 0;
}

/*
 * XXX I rather want this function to return a status code, and fail if
 * we cannot fit the information in the supplied buffer.
 */
static void
ipsec_decode_id(char *buf, size_t size, u_int8_t *id, size_t id_len,
    int isakmpform)
{
	int             id_type;
	char           *addr = 0, *mask = 0;
	u_int32_t      *idp;

	if (id) {
		if (!isakmpform) {
			/*
			 * Exchanges and SAs dont carry the IDs in ISAKMP
			 * form.
			 */
			id -= ISAKMP_GEN_SZ;
			id_len += ISAKMP_GEN_SZ;
		}
		id_type = GET_ISAKMP_ID_TYPE(id);
		idp = (u_int32_t *) (id + ISAKMP_ID_DATA_OFF);
		switch (id_type) {
		case IPSEC_ID_IPV4_ADDR:
			util_ntoa(&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
			snprintf(buf, size, "%s", addr);
			break;

		case IPSEC_ID_IPV4_ADDR_SUBNET:
			util_ntoa(&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
			util_ntoa(&mask, AF_INET, id + ISAKMP_ID_DATA_OFF + 4);
			snprintf(buf, size, "%s/%s", addr, mask);
			break;

		case IPSEC_ID_IPV6_ADDR:
			util_ntoa(&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
			snprintf(buf, size, "%s", addr);
			break;

		case IPSEC_ID_IPV6_ADDR_SUBNET:
			util_ntoa(&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
			util_ntoa(&mask, AF_INET6, id + ISAKMP_ID_DATA_OFF +
			    sizeof(struct in6_addr));
			snprintf(buf, size, "%s/%s", addr, mask);
			break;

		case IPSEC_ID_FQDN:
		case IPSEC_ID_USER_FQDN:
			/* String is not NUL terminated, be careful */
			id_len -= ISAKMP_ID_DATA_OFF;
			id_len = MINIMUM(id_len, size - 1);
			memcpy(buf, id + ISAKMP_ID_DATA_OFF, id_len);
			buf[id_len] = '\0';
			break;

		case IPSEC_ID_DER_ASN1_DN:
			addr = x509_DN_string(id + ISAKMP_ID_DATA_OFF,
			    id_len - ISAKMP_ID_DATA_OFF);
			if (!addr) {
				snprintf(buf, size, "unparsable ASN1 DN ID");
				return;
			}
			strlcpy(buf, addr, size);
			break;

		default:
			snprintf(buf, size, "<id type unknown: %x>", id_type);
			break;
		}
	} else
		snprintf(buf, size, "<no ipsec id>");
	free(addr);
	free(mask);
}

char *
ipsec_decode_ids(char *fmt, u_int8_t *id1, size_t id1_len, u_int8_t *id2,
    size_t id2_len, int isakmpform)
{
	static char     result[1024];
	char            s_id1[256], s_id2[256];

	ipsec_decode_id(s_id1, sizeof s_id1, id1, id1_len, isakmpform);
	ipsec_decode_id(s_id2, sizeof s_id2, id2, id2_len, isakmpform);

	snprintf(result, sizeof result, fmt, s_id1, s_id2);
	return result;
}

/*
 * Out of a named section SECTION in the configuration file build an
 * ISAKMP ID payload.  Ths payload size should be stashed in SZ.
 * The caller is responsible for freeing the payload.
 */
u_int8_t *
ipsec_build_id(char *section, size_t *sz)
{
	struct sockaddr *addr, *mask;
	u_int8_t       *p;
	int             id, subnet = 0;
	u_int8_t        tproto = 0;
	u_int16_t       port = 0;

	if (ipsec_get_id(section, &id, &addr, &mask, &tproto, &port))
		return 0;

	if (id == IPSEC_ID_IPV4_ADDR_SUBNET || id == IPSEC_ID_IPV6_ADDR_SUBNET)
		subnet = 1;

	*sz = ISAKMP_ID_SZ + sockaddr_addrlen(addr);
	if (subnet)
		*sz += sockaddr_addrlen(mask);

	p = malloc(*sz);
	if (!p) {
		log_print("ipsec_build_id: malloc(%lu) failed",
		    (unsigned long)*sz);
		if (subnet)
			free(mask);
		free(addr);
		return 0;
	}
	SET_ISAKMP_ID_TYPE(p, id);
	SET_ISAKMP_ID_DOI_DATA(p, (unsigned char *)"\000\000\000");

	memcpy(p + ISAKMP_ID_DATA_OFF, sockaddr_addrdata(addr),
	    sockaddr_addrlen(addr));
	if (subnet)
		memcpy(p + ISAKMP_ID_DATA_OFF + sockaddr_addrlen(addr),
		    sockaddr_addrdata(mask), sockaddr_addrlen(mask));

	SET_IPSEC_ID_PROTO(p + ISAKMP_ID_DOI_DATA_OFF, tproto);
	SET_IPSEC_ID_PORT(p + ISAKMP_ID_DOI_DATA_OFF, port);

	if (subnet)
		free(mask);
	free(addr);
	return p;
}

/*
 * copy an ISAKMPD id
 */
int
ipsec_clone_id(u_int8_t **did, size_t *did_len, u_int8_t *id, size_t id_len)
{
	free(*did);

	if (!id_len || !id) {
		*did = 0;
		*did_len = 0;
		return 0;
	}
	*did = malloc(id_len);
	if (!*did) {
		*did_len = 0;
		log_error("ipsec_clone_id: malloc(%lu) failed",
		    (unsigned long)id_len);
		return -1;
	}
	*did_len = id_len;
	memcpy(*did, id, id_len);

	return 0;
}

/*
 * IPsec-specific PROTO initializations.  SECTION is only set if we are the
 * initiator thus only usable there.
 * XXX I want to fix this later.
 */
void
ipsec_proto_init(struct proto *proto, char *section)
{
	struct ipsec_proto *iproto = proto->data;

	if (proto->sa->phase == 2)
		iproto->replay_window = section ? conf_get_num(section,
		    "ReplayWindow", DEFAULT_REPLAY_WINDOW) :
		    DEFAULT_REPLAY_WINDOW;
}

/*
 * Add a notification payload of type INITIAL CONTACT to MSG if this is
 * the first contact we have made to our peer.
 */
int
ipsec_initial_contact(struct message *msg)
{
	u_int8_t *buf;

	if (ipsec_contacted(msg))
		return 0;

	buf = malloc(ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
	if (!buf) {
		log_error("ike_phase_1_initial_contact: malloc (%d) failed",
		    ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
		return -1;
	}
	SET_ISAKMP_NOTIFY_DOI(buf, IPSEC_DOI_IPSEC);
	SET_ISAKMP_NOTIFY_PROTO(buf, ISAKMP_PROTO_ISAKMP);
	SET_ISAKMP_NOTIFY_SPI_SZ(buf, ISAKMP_HDR_COOKIES_LEN);
	SET_ISAKMP_NOTIFY_MSG_TYPE(buf, IPSEC_NOTIFY_INITIAL_CONTACT);
	memcpy(buf + ISAKMP_NOTIFY_SPI_OFF, msg->isakmp_sa->cookies,
	    ISAKMP_HDR_COOKIES_LEN);
	if (message_add_payload(msg, ISAKMP_PAYLOAD_NOTIFY, buf,
	    ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN, 1)) {
		free(buf);
		return -1;
	}
	return ipsec_add_contact(msg);
}

/*
 * Compare the two contacts pointed to by A and B.  Return negative if
 * *A < *B, 0 if they are equal, and positive if *A is the largest of them.
 */
static int
addr_cmp(const void *a, const void *b)
{
	const struct contact *x = a, *y = b;
	int             minlen = MINIMUM(x->len, y->len);
	int             rv = memcmp(x->addr, y->addr, minlen);

	return rv ? rv : (x->len - y->len);
}

/*
 * Add the peer that MSG is bound to as an address we don't want to send
 * INITIAL CONTACT too from now on.  Do not call this function with a
 * specific address duplicate times. We want fast lookup, speed of insertion
 * is unimportant, if this is to scale.
 */
static int
ipsec_add_contact(struct message *msg)
{
	struct contact *new_contacts;
	struct sockaddr *dst, *addr;
	int             cnt;

	if (contact_cnt == contact_limit) {
		cnt = contact_limit ? 2 * contact_limit : 64;
		new_contacts = reallocarray(contacts, cnt, sizeof contacts[0]);
		if (!new_contacts) {
			log_error("ipsec_add_contact: "
			    "realloc (%p, %lu) failed", contacts,
			    cnt * (unsigned long) sizeof contacts[0]);
			return -1;
		}
		contact_limit = cnt;
		contacts = new_contacts;
	}
	msg->transport->vtbl->get_dst(msg->transport, &dst);
	addr = malloc(SA_LEN(dst));
	if (!addr) {
		log_error("ipsec_add_contact: malloc (%lu) failed",
		    (unsigned long)SA_LEN(dst));
		return -1;
	}
	memcpy(addr, dst, SA_LEN(dst));
	contacts[contact_cnt].addr = addr;
	contacts[contact_cnt++].len = SA_LEN(dst);

	/*
	 * XXX There are better algorithms for already mostly-sorted data like
	 * this, but only qsort is standard.  I will someday do this inline.
         */
	qsort(contacts, contact_cnt, sizeof *contacts, addr_cmp);
	return 0;
}

/* Return true if the recipient of MSG has already been contacted.  */
static int
ipsec_contacted(struct message *msg)
{
	struct contact  contact;

	msg->transport->vtbl->get_dst(msg->transport, &contact.addr);
	contact.len = SA_LEN(contact.addr);
	return contacts ? (bsearch(&contact, contacts, contact_cnt,
	    sizeof *contacts, addr_cmp) != 0) : 0;
}

/* Add a HASH for to MSG.  */
u_int8_t *
ipsec_add_hash_payload(struct message *msg, size_t hashsize)
{
	u_int8_t *buf;

	buf = malloc(ISAKMP_HASH_SZ + hashsize);
	if (!buf) {
		log_error("ipsec_add_hash_payload: malloc (%lu) failed",
		    ISAKMP_HASH_SZ + (unsigned long) hashsize);
		return 0;
	}
	if (message_add_payload(msg, ISAKMP_PAYLOAD_HASH, buf,
	    ISAKMP_HASH_SZ + hashsize, 1)) {
		free(buf);
		return 0;
	}
	return buf;
}

/* Fill in the HASH payload of MSG.  */
int
ipsec_fill_in_hash(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa = isakmp_sa->data;
	struct hash    *hash = hash_get(isa->hash);
	struct prf     *prf;
	struct payload *payload;
	u_int8_t       *buf;
	u_int32_t       i;
	char            header[80];

	/* If no SKEYID_a, we need not do anything.  */
	if (!isa->skeyid_a)
		return 0;

	payload = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	if (!payload) {
		log_print("ipsec_fill_in_hash: no HASH payload found");
		return -1;
	}
	buf = payload->p;

	/* Allocate the prf and start calculating our HASH(1).  */
	LOG_DBG_BUF((LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a",
	    isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf)
		return -1;

	prf->Init(prf->prfctx);
	LOG_DBG_BUF((LOG_MISC, 90, "ipsec_fill_in_hash: message_id",
	    exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);

	/* Loop over all payloads after HASH(1).  */
	for (i = 2; i < msg->iovlen; i++) {
		/* XXX Misleading payload type printouts.  */
		snprintf(header, sizeof header,
		    "ipsec_fill_in_hash: payload %d after HASH(1)", i - 1);
		LOG_DBG_BUF((LOG_MISC, 90, header, msg->iov[i].iov_base,
		    msg->iov[i].iov_len));
		prf->Update(prf->prfctx, msg->iov[i].iov_base,
		    msg->iov[i].iov_len);
	}
	prf->Final(buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
	prf_free(prf);
	LOG_DBG_BUF((LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)", buf +
	    ISAKMP_HASH_DATA_OFF, hash->hashsize));

	return 0;
}

/* Add a HASH payload to MSG, if we have an ISAKMP SA we're protected by.  */
static int
ipsec_informational_pre_hook(struct message *msg)
{
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa;
	struct hash    *hash;

	if (!isakmp_sa)
		return 0;
	isa = isakmp_sa->data;
	hash = hash_get(isa->hash);
	return ipsec_add_hash_payload(msg, hash->hashsize) == 0;
}

/*
 * Fill in the HASH payload in MSG, if we have an ISAKMP SA we're protected by.
 */
static int
ipsec_informational_post_hook(struct message *msg)
{
	if (!msg->isakmp_sa)
		return 0;
	return ipsec_fill_in_hash(msg);
}

ssize_t
ipsec_id_size(char *section, u_int8_t *id)
{
	char *type, *data;

	type = conf_get_str(section, "ID-type");
	if (!type) {
		log_print("ipsec_id_size: section %s has no \"ID-type\" tag",
		    section);
		return -1;
	}
	*id = constant_value(ipsec_id_cst, type);
	switch (*id) {
	case IPSEC_ID_IPV4_ADDR:
		return sizeof(struct in_addr);
	case IPSEC_ID_IPV4_ADDR_SUBNET:
		return 2 * sizeof(struct in_addr);
	case IPSEC_ID_IPV6_ADDR:
		return sizeof(struct in6_addr);
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		return 2 * sizeof(struct in6_addr);
	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	case IPSEC_ID_KEY_ID:
	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
		data = conf_get_str(section, "Name");
		if (!data) {
			log_print("ipsec_id_size: "
			    "section %s has no \"Name\" tag", section);
			return -1;
		}
		return strlen(data);
	}
	log_print("ipsec_id_size: unrecognized/unsupported ID-type %d (%s)",
	    *id, type);
	return -1;
}

/*
 * Generate a string version of the ID.
 */
char *
ipsec_id_string(u_int8_t *id, size_t id_len)
{
	char           *buf = 0;
	char           *addrstr = 0;
	size_t          len, size;

	/*
	 * XXX Real ugly way of making the offsets correct.  Be aware that id
	 * now will point before the actual buffer and cannot be dereferenced
	 * without an offset larger than or equal to ISAKM_GEN_SZ.
         */
	id -= ISAKMP_GEN_SZ;

	/* This is the actual length of the ID data field.  */
	id_len += ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF;

	/*
	 * Conservative allocation.
	 * XXX I think the ASN1 DN case can be thought through to give a better
	 * estimate.
         */
	size = MAXIMUM(sizeof "ipv6/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
	    sizeof "asn1_dn/" + id_len);
	buf = malloc(size);
	if (!buf)
		/* XXX Log?  */
		goto fail;

	switch (GET_ISAKMP_ID_TYPE(id)) {
	case IPSEC_ID_IPV4_ADDR:
		if (id_len < sizeof(struct in_addr))
			goto fail;
		util_ntoa(&addrstr, AF_INET, id + ISAKMP_ID_DATA_OFF);
		if (!addrstr)
			goto fail;
		snprintf(buf, size, "ipv4/%s", addrstr);
		break;

	case IPSEC_ID_IPV6_ADDR:
		if (id_len < sizeof(struct in6_addr))
			goto fail;
		util_ntoa(&addrstr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
		if (!addrstr)
			goto fail;
		snprintf(buf, size, "ipv6/%s", addrstr);
		break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
		strlcpy(buf, GET_ISAKMP_ID_TYPE(id) == IPSEC_ID_FQDN ?
		    "fqdn/" : "ufqdn/", size);
		len = strlen(buf);

		memcpy(buf + len, id + ISAKMP_ID_DATA_OFF, id_len);
		*(buf + len + id_len) = '\0';
		break;

	case IPSEC_ID_DER_ASN1_DN:
		strlcpy(buf, "asn1_dn/", size);
		len = strlen(buf);
		addrstr = x509_DN_string(id + ISAKMP_ID_DATA_OFF, id_len);
		if (!addrstr)
			goto fail;
		if (size < len + strlen(addrstr) + 1)
			goto fail;
		strlcpy(buf + len, addrstr, size - len);
		break;

	default:
		/* Unknown type.  */
		LOG_DBG((LOG_MISC, 10,
		    "ipsec_id_string: unknown identity type %d\n",
		    GET_ISAKMP_ID_TYPE(id)));
		goto fail;
	}

	free(addrstr);
	return buf;

fail:
	free(buf);
	free(addrstr);
	return 0;
}
@


1.146
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.145 2015/12/09 21:41:50 naddy Exp $	 */
d273 9
@


1.145
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.144 2015/08/20 22:02:21 deraadt Exp $	 */
d670 1
a670 2
	if (nat_id)
		free(nat_id);
@


1.144
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.143 2015/01/16 06:39:58 deraadt Exp $	 */
a1824 4
	case IPSEC_ESP_DES:
	case IPSEC_ESP_DES_IV32:
	case IPSEC_ESP_DES_IV64:
		return 8;
@


1.143
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.142 2015/01/13 04:19:00 deraadt Exp $	 */
d626 1
a626 2
		isa->src_net = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in));
d632 1
a632 2
		isa->src_mask = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in));
d640 1
a640 2
		isa->src_net = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in6));
d646 1
a646 2
		isa->src_mask = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in6));
d676 1
a676 2
		isa->dst_net = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in));
d682 1
a682 2
		isa->dst_mask = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in));
d690 1
a690 2
		isa->dst_net = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in6));
d696 1
a696 2
		isa->dst_mask = (struct sockaddr *)calloc(1,
		    sizeof(struct sockaddr_in6));
d1729 1
a1729 1
		spis = (u_int8_t *) calloc(nspis, spisz);
@


1.142
log
@-/* Backwards compatibility.  */
-#ifndef NI_MAXHOST
-#define NI_MAXHOST 1025
-#endif
Disappointing.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.141 2014/10/09 02:38:56 deraadt Exp $	 */
d78 3
d2134 1
a2134 1
			id_len = MIN(id_len, size - 1);
d2306 1
a2306 1
	int             minlen = MIN(x->len, y->len);
d2535 1
a2535 1
	size = MAX(sizeof "ipv6/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
@


1.141
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.140 2014/01/22 03:09:31 deraadt Exp $	 */
a76 5

/* Backwards compatibility.  */
#ifndef NI_MAXHOST
#define NI_MAXHOST 1025
#endif
@


1.140
log
@improve randomization.  remove some junk debugging features that are
fundamentally broken.
ok jsing mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.139 2013/11/21 22:25:01 yasuoka Exp $	 */
d2329 1
a2329 1
		new_contacts = realloc(contacts, cnt * sizeof contacts[0]);
@


1.139
log
@Keep the flow until last IPsec SA is deleted, if the flow is shared by
multiple IPsec SAs in NAT-T case.

This fixes a problem that L2TP/IPsec connections are disconnected
improper in case multiple Windows clients are connected from behind
one NAT.

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.138 2012/06/30 14:51:31 naddy Exp $	 */
a43 2

#include "sysdep.h"
@


1.138
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.137 2011/10/20 00:28:06 yasuoka Exp $	 */
d135 2
d259 9
d272 1
a272 1
	    (sa->flags & (SA_FLAG_READY | SA_FLAG_REPLACED)) != SA_FLAG_READY)
d1575 3
d1580 12
@


1.137
log
@For NAT-T with transport mode, use the ISAKMP's SA addresses for the
flow instead of the ID payload.  This will fix a part of problems of
L2TP/IPsec from NAT'd clients.

ok markus@@
tested by markus@@ and myself.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.136 2010/09/22 13:45:15 mikeb Exp $	 */
d1821 1
a1821 2
	case IPSEC_ESP_AES_128_CTR:
		return 20;
@


1.136
log
@Support for use of AES-GCM-16 (as AESGCM) and ENCR_NULL_AUTH_AES_GMAC
(as AESGMAC) ciphers in the ISAKMP Phase 2 (aka Quick Mode).

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.135 2010/06/29 19:50:16 reyk Exp $	 */
d122 1
a122 1
static int      ipsec_set_network(u_int8_t *, u_int8_t *, struct ipsec_sa *);
d425 1
a425 1
					    ie->id_cr, isa)) {
d438 1
a438 1
					    ie->id_ci, isa)) {
d522 1
a522 1
ipsec_set_network(u_int8_t *src_id, u_int8_t *dst_id, struct ipsec_sa *isa)
d524 11
a534 4
	int	id;
	char *name, *nat = NULL;
	u_int8_t *nat_id = NULL;
	size_t nat_sz;
d549 67
d617 2
a618 4
	id = GET_ISAKMP_ID_TYPE(src_id);
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
d634 1
a634 2
	case IPSEC_ID_IPV6_ADDR:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
a648 11

	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
	case IPSEC_ID_FQDN:
	case IPSEC_ID_KEY_ID:
	default:
		log_print("ipsec_set_network: ID type %d (%s) not supported",
		    id, constant_name(ipsec_id_cst, id));
		return -1;
d652 1
a652 1
	memcpy(sockaddr_addrdata(isa->src_net), src_id + ISAKMP_ID_DATA_OFF,
d656 1
a656 3
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
d659 2
a660 5
		break;
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		memcpy(sockaddr_addrdata(isa->src_mask), src_id +
		    ISAKMP_ID_DATA_OFF + sockaddr_addrlen(isa->src_net),
a661 2
		break;
	}
d671 2
a672 4
	id = GET_ISAKMP_ID_TYPE(dst_id);
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
d688 1
a688 2
	case IPSEC_ID_IPV6_ADDR:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
a702 11

	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
	case IPSEC_ID_FQDN:
	case IPSEC_ID_KEY_ID:
	default:
		log_print("ipsec_set_network: ID type %d (%s) not supported",
		    id, constant_name(ipsec_id_cst, id));
		return -1;
d706 1
a706 1
	memcpy(sockaddr_addrdata(isa->dst_net), dst_id + ISAKMP_ID_DATA_OFF,
d710 1
a710 3
	switch (id) {
	case IPSEC_ID_IPV4_ADDR:
	case IPSEC_ID_IPV6_ADDR:
d713 2
a714 5
		break;
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
		memcpy(sockaddr_addrdata(isa->dst_mask), dst_id +
		    ISAKMP_ID_DATA_OFF + sockaddr_addrlen(isa->dst_net),
a715 2
		break;
	}
@


1.135
log
@Replace the hand-crafted Diffie-Hellman implementation in isakmpd with
the smaller implementation from iked that is using libcrypto instead.
This allows to remove a lot of code (which is always good), get rid of
some custom crypto code by using libcrypto, theoretically adds
support for many new MODP and EC2N/ECP modes (but it is not configurable
yet), and allows to share the dh.c/dh.h code in different codebases
(it is identical in isakmpd and iked, but could also be used elsewhere).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.133 2010/01/10 12:39:43 markus Exp $	 */
d978 1
a978 1
		    (transform_id > IPSEC_ESP_AES_128_CTR &&
d1791 5
@


1.134
log
@don't crash on invalid phase 2 IDs; from hshoexer; ok sthen@@
@
text
@a67 1
#include "math_group.h"
@


1.133
log
@only substract ISAKMP_ID_DATA_OFF once. otherwise 'buf' might overflow
and/or ASN1-DNs get not parsed correctly; with and ok krw@@; ok reyk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.132 2009/01/29 10:05:50 hshoexer Exp $	 */
d584 1
d654 11
@


1.132
log
@Improve logging:

- in ipsec_delete_spi_list() a log_verbose is added, when a remote peer
  sends us a delete message for an SA.  However, to avoid spamming the log
  when SAs are deleted during re-keying, I only log_verbose, when the soft
  timeout of the SA is not expired yet.  Thus only deletion of live SAs
  gets logged.

- in ipsec_decode_ids() I remove the additonal printing of IP-Adresses in
  hex as the addresses are already printed in CIDR.

- while there, apply some KNF

ok todd@@, mpf@@, bluhm@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.131 2009/01/20 14:36:19 mpf Exp $	 */
d2467 1
a2467 1
	    sizeof "asn1_dn/" + id_len - ISAKMP_ID_DATA_OFF);
d2505 1
a2505 2
		addrstr = x509_DN_string(id + ISAKMP_ID_DATA_OFF,
		    id_len - ISAKMP_ID_DATA_OFF);
@


1.131
log
@Add support to isakmpd(8) and ipsecctl(8) to install SA's with a
different source network than we have negotiated with a peer.
This enables us to do nat/binat on the enc(4) interface.
Very useful to work around rfc 1918 collisions.
Manpage and testing by Mitja Muzenic. Thanks!
OK hshoexer@@, markus@@. "I like it" todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.130 2007/09/02 15:19:24 deraadt Exp $	 */
d1031 4
a1034 2
	struct sa      *sa;
	int             i;
d1058 14
a1071 1
		/* Delete the SA and search for the next */
d1073 3
a1075 2
		    "%s made us delete SA %p (%d references) for proto %d",
		    type, sa, sa->refcnt, proto));
d1077 1
d2040 1
a2040 2
			snprintf(buf, size, "%08x: %s",
			    decode_32(id + ISAKMP_ID_DATA_OFF), addr);
d2046 1
a2046 3
			snprintf(buf, size, "%08x/%08x: %s/%s",
			    decode_32(id + ISAKMP_ID_DATA_OFF),
			decode_32(id + ISAKMP_ID_DATA_OFF + 4), addr, mask);
d2051 1
a2051 2
			snprintf(buf, size, "%08x%08x%08x%08x: %s", *idp,
			    *(idp + 1), *(idp + 2), *(idp + 3), addr);
d2058 1
a2058 4
			snprintf(buf, size,
			    "%08x%08x%08x%08x/%08x%08x%08x%08x: %s/%s", *idp,
			    *(idp + 1), *(idp + 2), *(idp + 3), *(idp + 4),
			    *(idp + 5), *(idp + 6), *(idp + 7), addr, mask);
d2494 2
a2495 3
		strlcpy(buf,
		GET_ISAKMP_ID_TYPE(id) == IPSEC_ID_FQDN ? "fqdn/" : "ufqdn/",
		    size);
@


1.130
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.129 2007/07/31 20:59:33 hshoexer Exp $	 */
d49 1
d526 16
d613 3
@


1.129
log
@Use correct function name in log message.  Noticed by Igor Zinovk
zinovik@@cs.karelia.ru.  Thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.128 2007/04/16 13:01:39 moritz Exp $	 */
d1635 1
a1635 1
		spis = (u_int8_t *) malloc(nspis * spisz);
@


1.128
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.127 2006/11/24 13:52:14 reyk Exp $	 */
d1938 1
a1938 1
			log_print("ipsec_id_build: invalid section %s "
@


1.127
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.126 2006/06/10 20:10:02 hshoexer Exp $	 */
d357 2
a358 3
	if (id_string != NULL)
		free(id_string);
	if (error != 0 && sa->tag != NULL) {
d490 4
a493 8
				if (addr1)
					free(addr1);
				if (mask1)
					free(mask1);
				if (addr2)
					free(addr2);
				if (mask2)
					free(mask2);
d673 12
a684 24
	if (ie->sa_i_b)
		free(ie->sa_i_b);
	if (ie->id_ci)
		free(ie->id_ci);
	if (ie->id_cr)
		free(ie->id_cr);
	if (ie->g_xi)
		free(ie->g_xi);
	if (ie->g_xr)
		free(ie->g_xr);
	if (ie->g_xy)
		free(ie->g_xy);
	if (ie->skeyid)
		free(ie->skeyid);
	if (ie->skeyid_d)
		free(ie->skeyid_d);
	if (ie->skeyid_a)
		free(ie->skeyid_a);
	if (ie->skeyid_e)
		free(ie->skeyid_e);
	if (ie->hash_i)
		free(ie->hash_i);
	if (ie->hash_r)
		free(ie->hash_r);
d702 6
a707 12
	if (isa->src_net)
		free(isa->src_net);
	if (isa->src_mask)
		free(isa->src_mask);
	if (isa->dst_net)
		free(isa->dst_net);
	if (isa->dst_mask)
		free(isa->dst_mask);
	if (isa->skeyid_a)
		free(isa->skeyid_a);
	if (isa->skeyid_d)
		free(isa->skeyid_d);
d718 1
a718 2
		if (iproto->keymat[i])
			free(iproto->keymat[i]);
d2056 2
a2057 4
	if (addr)
		free(addr);
	if (mask)
		free(mask);
d2131 1
a2131 2
	if (*did)
		free(*did);
d2493 1
a2493 2
	if (addrstr)
		free(addrstr);
d2497 2
a2498 4
	if (buf)
		free(buf);
	if (addrstr)
		free(addrstr);
@


1.126
log
@support sha2 for main mode hmacs and aesctr for quick mode encryption.
ok markus@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.125 2006/06/09 21:37:17 naddy Exp $	 */
d42 3
d135 1
d284 84
d447 3
@


1.125
log
@Allow for AH the use of the authentication algorithms added a while ago.
Fix the indentation while we're here.  ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.124 2006/05/29 06:56:36 mcbride Exp $	 */
d1071 6
d1674 2
a1676 1
	case IPSEC_ESP_AES_128_CTR:
@


1.124
log
@Fix broken merge of patch. Pointed out by nathanael at polymorpheus dot com.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.123 2006/05/28 02:22:34 mcbride Exp $	 */
d867 11
a877 11
		/*
		 * As no unexpected protocols can occur, we just tie the
		 * default case to the first case, in orer to silence a GCC
		 * warning.
		 */
		default:
		case ISAKMP_PROTO_ISAKMP:
			return transform_id != IPSEC_TRANSFORM_KEY_IKE;
		case IPSEC_PROTO_IPSEC_AH:
			return transform_id < IPSEC_AH_MD5 ||
			    transform_id > IPSEC_AH_DES ? -1 : 0;
@


1.123
log
@Change the default replay window for SAs created by the isakmpd responder
to be DEFAULT_REPLAY_WINDOW instead of zero. The default replay window is
then the same for both initiator and receiver.

Fix from nathanael at polymorpheous dot com.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.122 2005/09/23 14:44:03 hshoexer Exp $	 */
d1413 11
d2090 1
a2090 1
	if (proto->sa->phase == 2 && section)
@


1.122
log
@Provide UI commands to delete phase 1 SAs.

Looks good mortiz@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.121 2005/06/25 23:20:43 hshoexer Exp $	 */
d2080 3
a2082 2
		iproto->replay_window = conf_get_num(section, "ReplayWindow",
		    DEFAULT_REPLAY_WINDOW);
@


1.122.2.1
log
@MFC:
Fix by mcbride@@

Change the default replay window for SAs created by the isakmpd responder
to be DEFAULT_REPLAY_WINDOW instead of zero. The default replay window is
then the same for both initiator and receiver.

Fix from nathanael at polymorpheous dot com.

ok mpf@@ hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.122 2005/09/23 14:44:03 hshoexer Exp $	 */
d2079 3
a2081 4
	if (proto->sa->phase == 2)
		iproto->replay_window = section ? conf_get_num(section,
		    "ReplayWindow", DEFAULT_REPLAY_WINDOW) :
		    DEFAULT_REPLAY_WINDOW;
@


1.121
log
@/* Fallthrough. */ -> /* FALLTHROUGH */
now that's useable with lint
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.120 2005/06/14 10:50:47 hshoexer Exp $	 */
d1606 1
a1606 1
			while ((sa = sa_lookup_by_peer(dst, SA_LEN(dst))) != 0) {
@


1.121.2.1
log
@MFC:
Fix by mcbride@@

Change the default replay window for SAs created by the isakmpd responder
to be DEFAULT_REPLAY_WINDOW instead of zero. The default replay window is
then the same for both initiator and receiver.

Fix from nathanael at polymorpheous dot com.

ok mpf@@ hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.121 2005/06/25 23:20:43 hshoexer Exp $	 */
d2079 3
a2081 4
	if (proto->sa->phase == 2)
		iproto->replay_window = section ? conf_get_num(section,
		    "ReplayWindow", DEFAULT_REPLAY_WINDOW) :
		    DEFAULT_REPLAY_WINDOW;
@


1.120
log
@add ENCAP_UDP_{TUNNEL,TRANSPORT} types according to rfc 3947

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.119 2005/05/26 06:11:09 hshoexer Exp $	 */
d1661 1
a1661 1
		/* Fallthrough */
@


1.119
log
@Use TAILQ_FOREACH where possible, remove payload_last()

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.118 2005/05/04 10:05:01 hshoexer Exp $	 */
d1153 3
a1155 1
			    dv != IPSEC_ENCAP_UDP_ENCAP_TRANSPORT;
@


1.118
log
@clean up KEY_API() wrapper.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.117 2005/04/08 23:15:26 hshoexer Exp $	 */
d1010 1
a1010 2
		for (p = payload_first(msg, ISAKMP_PAYLOAD_NOTIFY); p;
		    p = TAILQ_NEXT(p, link)) {
@


1.117
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.116 2005/04/08 19:40:03 deraadt Exp $	 */
d67 1
d363 1
a363 1
					if (sysdep_ipsec_set_spi(sa, proto,
d366 1
a366 1
					    sysdep_ipsec_group_spis(sa,
d368 1
a368 1
					    sysdep_ipsec_set_spi(sa, proto,
d371 1
a371 1
						sysdep_ipsec_group_spis(sa,
d417 1
a417 1
				    sysdep_ipsec_enable_sa(sa, isakmp_sa))
d1413 1
a1413 1
	sysdep_ipsec_delete_spi(sa, proto, incoming);
d1509 1
a1509 1
		return sysdep_ipsec_get_spi(sz, proto, src, dst,
@


1.116
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.115 2005/04/08 16:52:41 deraadt Exp $	 */
d1604 1
a1604 2
			while ((sa = sa_lookup_by_peer(dst,
			    sysdep_sa_len(dst))) != 0) {
d2154 1
a2154 1
	addr = malloc(sysdep_sa_len(dst));
d2156 2
a2157 2
		log_error("ipsec_add_contact: malloc (%d) failed",
		    sysdep_sa_len(dst));
d2160 1
a2160 1
	memcpy(addr, dst, sysdep_sa_len(dst));
d2162 1
a2162 1
	contacts[contact_cnt++].len = sysdep_sa_len(dst);
d2179 1
a2179 1
	contact.len = sysdep_sa_len(contact.addr);
@


1.115
log
@always enable aggressive, dpd, and isakmp_cfg
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.114 2005/04/08 16:37:14 deraadt Exp $	 */
a99 1
#ifdef USE_DEBUG
a101 1
#endif
a135 1
#ifdef USE_DEBUG
a136 1
#endif
a290 1
#ifdef USE_DEBUG
a291 1
#endif
a379 1
#ifdef USE_DEBUG
a407 2
#endif				/* USE_DEBUG */

a1176 1
#ifdef USE_DEBUG
a1200 1
#endif
@


1.114
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.113 2005/04/08 16:09:25 deraadt Exp $	 */
a49 1
#if defined (USE_DPD)
a50 1
#endif
a592 1
#ifdef USE_ISAKMP_CFG
a593 1
#endif
a620 1
#ifdef USE_ISAKMP_CFG
a627 1
#endif
d667 1
a667 2
#ifdef USE_ISAKMP_CFG
		case ISAKMP_EXCH_TRANSACTION:
a668 1
#endif
a917 1
#ifdef USE_AGGRESSIVE
a920 2
#endif
#ifdef USE_ISAKMP_CFG
a923 1
#endif
a1010 1
#ifdef USE_AGGRESSIVE
a1013 2
#endif
#ifdef USE_ISAKMP_CFG
a1016 1
#endif
a1029 1
#if defined (USE_DPD)
a1033 1
#endif
@


1.113
log
@kill USE_OLD_SOCKADDR
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.112 2005/04/06 16:00:20 deraadt Exp $	 */
a67 1
#if defined (USE_NAT_TRAVERSAL)
a68 1
#endif
a321 1
#if defined (USE_NAT_TRAVERSAL)
a323 1
#endif
a1176 1
#if defined (USE_NAT_TRAVERSAL)
a1180 4
#else
			return dv < IPSEC_ENCAP_TUNNEL ||
			    dv > IPSEC_ENCAP_TRANSPORT;
#endif /* USE_NAT_TRAVERSAL */
@


1.112
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.111 2005/04/05 20:46:20 cloder Exp $	 */
a463 1
#ifndef USE_OLD_SOCKADDR
a464 1
#endif
a470 1
#ifndef USE_OLD_SOCKADDR
a471 1
#endif
a480 1
#ifndef USE_OLD_SOCKADDR
a481 1
#endif
a487 1
#ifndef USE_OLD_SOCKADDR
a488 1
#endif
a534 1
#ifndef USE_OLD_SOCKADDR
a535 1
#endif
a541 1
#ifndef USE_OLD_SOCKADDR
a542 1
#endif
a551 1
#ifndef USE_OLD_SOCKADDR
a552 1
#endif
a558 1
#ifndef USE_OLD_SOCKADDR
a559 1
#endif
@


1.111
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.110 2005/04/04 19:31:11 deraadt Exp $	 */
d429 3
a431 3
					conf_get_str("General", "Acquire-Only")
					|| acquire_only)
				    && sysdep_ipsec_enable_sa(sa, isakmp_sa))
d785 5
a789 6
	if ((msg->exchange->phase == 1
	    && (type < IKE_ATTR_ENCRYPTION_ALGORITHM
		|| type > IKE_ATTR_GROUP_ORDER))
	    || (msg->exchange->phase == 2
		&& (type < IPSEC_ATTR_SA_LIFE_TYPE
		    || type > IPSEC_ATTR_ECN_TUNNEL)))
d842 3
a844 3
	if (exchange->phase == 1
	    && (proto != IPPROTO_UDP || port != UDP_DEFAULT_PORT)
	    && (proto != 0 || port != 0)) {
d932 2
a933 3
	if (exchange->type != ISAKMP_EXCH_TRANSACTION
	    && ((exchange->phase == 1 &&
	    exchange->type != ISAKMP_EXCH_ID_PROT &&
d935 2
a936 3
	    exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 &&
	    exchange->type != IKE_EXCH_QUICK_MODE &&
d1027 6
a1032 8
	if (exchange->step == 0 && exchange->type != ISAKMP_EXCH_TRANSACTION
	    && ((exchange->phase == 1 &&
		exchange->type != ISAKMP_EXCH_ID_PROT &&
		exchange->type != ISAKMP_EXCH_AGGRESSIVE &&
		exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 &&
		exchange->type != IKE_EXCH_QUICK_MODE &&
		exchange->type != ISAKMP_EXCH_INFO))) {
d1150 4
a1153 4
			return (dv < IKE_GROUP_DESC_MODP_768
				|| dv > IKE_GROUP_DESC_MODP_1536)
			    && (dv < IKE_GROUP_DESC_MODP_2048
				|| dv > IKE_GROUP_DESC_MODP_8192);
d1167 2
a1168 2
			return dv < IKE_DURATION_SECONDS
			    || dv > IKE_DURATION_KILOBYTES;
d1187 2
a1188 2
			return dv < IPSEC_DURATION_SECONDS
			    || dv > IPSEC_DURATION_KILOBYTES;
d1192 4
a1195 4
			return (dv < IKE_GROUP_DESC_MODP_768
				|| dv > IKE_GROUP_DESC_MODP_1536)
			    && (dv < IKE_GROUP_DESC_MODP_2048
				|| IKE_GROUP_DESC_MODP_8192 < dv);
d1198 4
a1201 4
			return dv != IPSEC_ENCAP_TUNNEL
			    && dv != IPSEC_ENCAP_TRANSPORT
			    && dv != IPSEC_ENCAP_UDP_ENCAP_TUNNEL
			    && dv != IPSEC_ENCAP_UDP_ENCAP_TRANSPORT;
d1203 2
a1204 2
			return dv < IPSEC_ENCAP_TUNNEL
			    || dv > IPSEC_ENCAP_TRANSPORT;
d1207 2
a1208 2
			return dv < IPSEC_AUTH_HMAC_MD5
			    || dv > IPSEC_AUTH_HMAC_RIPEMD;
d1595 3
a1597 4
		if ((proto == ISAKMP_PROTO_ISAKMP && spisz !=
			ISAKMP_HDR_COOKIES_LEN)
		    || (proto != ISAKMP_PROTO_ISAKMP && spisz !=
			sizeof(u_int32_t))) {
@


1.110
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.109 2005/04/04 18:40:45 hshoexer Exp $	 */
a75 1
#ifdef USE_X509
a76 1
#endif
a2013 1
#ifdef USE_X509
a2022 1
#endif
a2448 1
#ifdef USE_X509
a2459 1
#endif
@


1.109
log
@fix byteorder confusion

ok cloder ho
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.108 2005/03/29 04:51:21 cloder Exp $	 */
d340 1
a340 1
		         */
d429 1
a429 1
			         */
d874 2
a875 2
	return type < IPSEC_NOTIFY_RESPONDER_LIFETIME
	    || type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
d881 2
a882 2
	return proto < IPSEC_PROTO_IPSEC_AH
	    || proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
d910 1
a910 1
	         */
d915 2
a916 2
			return transform_id < IPSEC_AH_MD5
			    || transform_id > IPSEC_AH_DES ? -1 : 0;
d918 4
a921 4
		return transform_id < IPSEC_ESP_DES_IV64
		    || (transform_id > IPSEC_ESP_AES_128_CTR
			&& transform_id < IPSEC_ESP_AES_MARS)
		    || transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
d923 2
a924 2
		return transform_id < IPSEC_IPCOMP_OUI
		    || transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
d937 6
a942 6
		exchange->type != ISAKMP_EXCH_ID_PROT &&
		exchange->type != ISAKMP_EXCH_AGGRESSIVE &&
		exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 &&	
		exchange->type != IKE_EXCH_QUICK_MODE &&
		exchange->type != ISAKMP_EXCH_INFO))) {
d1089 1
a1089 1
	         */
d1184 1
a1184 1
		         */
d1634 1
a1634 1
		         *
d1641 1
a1641 1
		         */
d1664 1
a1664 1
		         */
d1675 1
a1675 1
			         */
@


1.108
log
@Always use network byte order when stuffing port numbers into IPSEC ID
packets. This reinstates the correct part of r1.106 which did ntohs
incorrectly on received port numbers already in host byte order. OK ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.106 2005/03/05 23:39:34 cloder Exp $	 */
d1815 1
a1815 1
	*port = htons((u_int16_t)atoi(pstr));
d1820 1
a1820 1
			*port = se->s_port;
@


1.107
log
@Back out a possible bogus minor diff until we investigate what
broke.
OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.105 2004/12/14 10:17:28 mcbride Exp $	 */
d1815 1
a1815 1
	*port = (u_int16_t)atoi(pstr);
@


1.106
log
@Always use correct byte order when stuffing port numbers into packets.
OK hshoexer@@, ho@@
@
text
@d812 1
a812 1
	    proto, ntohs(port), type));
d846 1
a846 1
	    && (proto != IPPROTO_UDP || ntohs(port) != UDP_DEFAULT_PORT)
d1815 1
a1815 1
	*port = htons((u_int16_t)atoi(pstr));
@


1.105
log
@Allow the Address, Network, or Netmask values of the <IPsec-ID> to be
specified with an interface name (in which case the first address is used)
or the keyword 'default' (in which case the address is selected based on the
default route). eg:

[roadwarrior-ip]
ID-type=                IPV4_ADDR
Address=                default

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.104 2004/09/17 13:53:08 ho Exp $	 */
d812 1
a812 1
	    proto, port, type));
d846 1
a846 1
	    && (proto != IPPROTO_UDP || port != UDP_DEFAULT_PORT)
d1815 1
a1815 1
	*port = (u_int16_t)atoi(pstr);
@


1.104
log
@Missing #ifdefs.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.103 2004/08/10 15:59:10 ho Exp $	 */
d1841 1
d1852 10
d1871 1
a1871 1
		if (text2sockaddr(address, NULL, addr)) {
d1901 1
a1901 1
		if (text2sockaddr(address, NULL, addr)) {
d1913 1
a1913 1
		if (text2sockaddr(netmask, NULL, mask)) {
@


1.103
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.102 2004/08/08 19:11:06 deraadt Exp $	 */
d76 1
d78 1
@


1.102
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.101 2004/06/23 00:55:59 hshoexer Exp $	 */
d50 3
d934 7
a940 5
	    && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
		&& exchange->type != ISAKMP_EXCH_AGGRESSIVE
		&& exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE
		&& exchange->type != ISAKMP_EXCH_INFO))) {
d1031 7
a1037 5
	    && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
		&& exchange->type != ISAKMP_EXCH_AGGRESSIVE
		&& exchange->type != ISAKMP_EXCH_INFO)
	    || (exchange->phase == 2 && exchange->type ==
		ISAKMP_EXCH_ID_PROT))) {
a1047 1

a1052 1

a1057 1

d1071 7
a1087 1

@


1.101
log
@Add commandline switch -a / config tag "Acquire-Only" to tell isakmpd to not
touch flows.

initial work by markus
ok markus@@ ho@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.100 2004/06/21 23:27:10 ho Exp $	 */
d374 2
a375 2
					    	sysdep_ipsec_group_spis(sa,
					    	last_proto, proto, 0)) ||
d379 1
a379 1
					    	sysdep_ipsec_group_spis(sa,
d526 1
a526 1
	memcpy(&isa->sport, 
d1782 1
a1782 1
	
@


1.100
log
@Implement NAT-T keepalive messages.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.99 2004/06/21 18:29:06 ho Exp $	 */
d75 2
d425 4
a428 2
				if (!(sa->flags & SA_FLAG_ONDEMAND) &&
				    sysdep_ipsec_enable_sa(sa, isakmp_sa))
@


1.99
log
@style nit
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.98 2004/06/20 17:17:35 ho Exp $	 */
d65 3
d318 5
@


1.98
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.97 2004/06/20 15:24:05 ho Exp $	 */
d233 1
a233 1
struct sa      *
@


1.97
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.96 2004/06/17 19:39:38 hshoexer Exp $	 */
d1043 1
a1043 1
		for (p = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_NOTIFY]); p;
d1086 1
a1086 1
	if (TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_SA])) {
d1514 1
a1514 1
	kep = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
d2252 1
a2252 1
	payload = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
@


1.96
log
@Yet another bunch of memleask found and fixed by Patrick Latifi.  Thanks!

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.95 2004/06/16 15:05:37 hshoexer Exp $	 */
d1122 1
d1127 1
a1127 1
			return !crypto_get(from_ike_crypto(decode_16(value)));
d1129 1
a1129 1
			return !hash_get(from_ike_hash(decode_16(value)));
d1131 1
a1131 1
			return !ike_auth_get(decode_16(value));
d1133 4
a1136 4
			return (decode_16(value) < IKE_GROUP_DESC_MODP_768
				|| decode_16(value) > IKE_GROUP_DESC_MODP_1536)
			    && (decode_16(value) < IKE_GROUP_DESC_MODP_2048
				|| decode_16(value) > IKE_GROUP_DESC_MODP_8192);
d1150 2
a1151 2
			return decode_16(value) < IKE_DURATION_SECONDS
			    || decode_16(value) > IKE_DURATION_KILOBYTES;
d1161 1
a1161 1
			return decode_16(value) % 8 != 0;
d1170 2
a1171 2
			return decode_16(value) < IPSEC_DURATION_SECONDS
			    || decode_16(value) > IPSEC_DURATION_KILOBYTES;
d1175 4
a1178 4
			return (decode_16(value) < IKE_GROUP_DESC_MODP_768
				|| decode_16(value) > IKE_GROUP_DESC_MODP_1536)
			    && (decode_16(value) < IKE_GROUP_DESC_MODP_2048
				|| IKE_GROUP_DESC_MODP_8192 < decode_16(value));
d1180 9
a1188 2
			return decode_16(value) < IPSEC_ENCAP_TUNNEL
			    || decode_16(value) > IPSEC_ENCAP_TRANSPORT;
d1190 2
a1191 2
			return decode_16(value) < IPSEC_AUTH_HMAC_MD5
			    || decode_16(value) > IPSEC_AUTH_HMAC_RIPEMD;
@


1.95
log
@fix ipv6-address and ipv6-address-mask mixup.
Found by Patrick Latifi.  Thanks!

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.94 2004/06/14 09:55:41 ho Exp $	 */
d1819 3
a1821 1
	case IPSEC_ID_IPV6_ADDR:
d1833 6
a1838 1
		return ipsec_get_proto_port(section, tproto, port);
d1849 3
a1851 1
	case IPSEC_ID_IPV6_ADDR_SUBNET:
d1867 1
d1873 1
d1876 7
a1882 1
		return ipsec_get_proto_port(section, tproto, port);
d2039 3
d2056 3
@


1.94
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.93 2004/06/10 12:54:53 hshoexer Exp $	 */
d1939 1
a1939 1
			util_ntoa(&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF +
@


1.93
log
@Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!

ok ho@@ niklas@@, testing and spellcheck by todd@@ msf@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.92 2004/06/09 14:02:44 ho Exp $	 */
d97 2
a98 1
static int      ipsec_debug_attribute(u_int16_t, u_int8_t *, u_int16_t, void *);
d109 1
a109 1
		    struct payload *);
d120 1
a120 1
		    void *);
d123 1
a123 1
		    size_t, struct exchange *);
d337 4
a340 2
						log_print("ipsec_finalize_exchange: "
						    "ipsec_set_network failed");
d350 4
a353 2
						log_print("ipsec_finalize_exchange: "
						    "ipsec_set_network failed");
d514 2
a515 1
	memcpy(&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
d585 2
a586 1
	memcpy(&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
d1634 2
a1635 2
			while ((sa = sa_lookup_by_peer(dst, sysdep_sa_len(dst)))
			    != 0) {
d2144 3
a2146 2
			log_error("ipsec_add_contact: realloc (%p, %lu) failed",
			    contacts, cnt * (unsigned long) sizeof contacts[0]);
d2314 2
a2315 2
			log_print("ipsec_id_size: section %s has no \"Name\" tag",
			    section);
@


1.92
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.91 2004/05/23 18:17:56 hshoexer Exp $	 */
d1043 9
a1051 1
			p->flags |= PL_MARK;
d1612 6
@


1.91
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.90 2004/05/19 14:30:26 ho Exp $	 */
d94 2
a95 2
static int      ipsec_add_contact(struct message * msg);
static int      ipsec_contacted(struct message * msg);
d233 1
a233 1
ipsec_sa_lookup(struct sockaddr * dst, u_int32_t spi, u_int8_t proto)
d249 1
a249 1
ipsec_sa_check_flow(struct sa * sa, void *v_arg)
d692 1
a692 1
ipsec_get_keystate(struct message * msg)
@


1.90
log
@Permit symbolic protocol and service names, such as "Protocol= tcp", in the
<IPsec-ID> sections. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.89 2004/04/15 18:39:25 deraadt Exp $	 */
d107 2
a108 3
static int
ipsec_handle_leftover_payload(struct message *, u_int8_t,
			      struct payload *);
d118 2
a119 1
static int      ipsec_validate_attribute(u_int16_t, u_int8_t *, u_int16_t, void *);
d121 2
a122 3
static int
ipsec_validate_id_information(u_int8_t, u_int8_t *, u_int8_t *,
			      size_t, struct exchange *);
d165 1
a165 1
int16_t         script_quick_mode[] = {
d178 1
a178 1
int16_t         script_new_group_mode[] = {
d225 2
a226 1
		    memcmp(proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
d282 1
a282 1
ipsec_finalize_exchange(struct message * msg)
d322 2
a323 1
			 * Tell the application(s) about the SPIs and key material.
d345 2
a346 2
					if (ipsec_set_network(ie->id_cr, ie->id_ci,
					    isa)) {
d358 3
a360 2
					    (last_proto && sysdep_ipsec_group_spis(sa,
					    last_proto, proto, 0)) ||
d362 4
a365 3
					    1, isakmp_sa) ||
					    (last_proto && sysdep_ipsec_group_spis(sa,
					    last_proto, proto, 1)))
d385 8
a392 5
				    "ipsec_finalize_exchange: "
				    "src %s %s dst %s %s tproto %u sport %u dport %u",
				     addr1 ? addr1 : "<??\?>", mask1 ? mask1 : "<??\?>",
				    addr2 ? addr2 : "<??\?>", mask2 ? mask2 : "<??\?>",
				     isa->tproto, ntohs(isa->sport), ntohs(isa->dport)));
d406 3
a408 2
				 * If this is not an SA acquired by the kernel, it needs
				 * to have a SPD entry (a.k.a. flow) set up.
d419 2
a420 1
				while ((old_sa = sa_find(ipsec_sa_check_flow, sa)) != 0)
d432 1
a432 1
	int             id;
d439 1
a439 1
		isa->src_net = (struct sockaddr *) calloc(1,
d448 1
a448 1
		isa->src_mask = (struct sockaddr *) calloc(1,
d460 1
a460 1
		isa->src_net = (struct sockaddr *) calloc(1,
d469 1
a469 1
		isa->src_mask = (struct sockaddr *) calloc(1,
d503 3
a505 2
		memcpy(sockaddr_addrdata(isa->src_mask), src_id + ISAKMP_ID_DATA_OFF +
		    sockaddr_addrlen(isa->src_net), sockaddr_addrlen(isa->src_mask));
d510 1
a510 1
	       IPSEC_ID_PORT_LEN);
d517 2
a518 2
		isa->dst_net =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in));
d526 2
a527 2
		isa->dst_mask =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in));
d538 2
a539 2
		isa->dst_net =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in6));
d547 2
a548 2
		isa->dst_mask =
			(struct sockaddr *) calloc(1, sizeof(struct sockaddr_in6));
d560 1
a560 1
	       sockaddr_addrlen(isa->dst_net));
d567 1
a567 1
		       sockaddr_addrlen(isa->dst_mask));
d571 3
a573 3
		memcpy(sockaddr_addrdata(isa->dst_mask), dst_id + ISAKMP_ID_DATA_OFF +
		       sockaddr_addrlen(isa->dst_net),
		       sockaddr_addrlen(isa->dst_mask));
d577 2
a578 2
	memcpy(&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	       IPSEC_ID_PROTO_LEN);
d580 1
a580 1
	       IPSEC_ID_PORT_LEN);
d624 2
a625 1
	for (attr = LIST_FIRST(&ie->attrs); attr; attr = LIST_FIRST(&ie->attrs)) {
d702 1
a702 1
				  (unsigned long) sizeof *ks);
d715 1
a715 1
			  msg->isakmp_sa);
d722 1
a722 1
	hash = hash_get(((struct ipsec_sa *) msg->isakmp_sa->data)->hash);
d725 1
a725 1
		     ks->riv, ks->xf->blocksize));
a727 4
		     ((u_int8_t *) msg->iov[0].iov_base)
		     + ISAKMP_HDR_MESSAGE_ID_OFF,
		     ISAKMP_HDR_MESSAGE_ID_LEN));
	hash->Update(hash->ctx,
d729 3
a731 1
		     ISAKMP_HDR_MESSAGE_ID_LEN);
d735 1
a735 1
		     hash->digest, ks->xf->blocksize));
d740 1
a740 1
ipsec_setup_situation(u_int8_t * buf)
d745 1
a745 1
static          size_t
d751 1
a751 1
static          u_int8_t
d759 1
a759 1
			 void *vmsg)
d764 2
a765 2
	     && (type < IKE_ATTR_ENCRYPTION_ALGORITHM
		 || type > IKE_ATTR_GROUP_ORDER))
d780 2
a781 2
ipsec_validate_id_information(u_int8_t type, u_int8_t * extra, u_int8_t * buf,
			      size_t sz, struct exchange * exchange)
d787 2
a788 2
		 "ipsec_validate_id_information: proto %d port %d type %d",
		 proto, port, type));
d794 3
a796 2
		LOG_DBG_BUF((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv4",
			     buf, sizeof(struct in_addr)));
d800 3
a802 2
		LOG_DBG_BUF((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv6",
			     buf, sizeof(struct in6_addr)));
d807 2
a808 2
		      "ipsec_validate_id_information: IPv4 network/netmask",
			     buf, 2 * sizeof(struct in_addr)));
d813 2
a814 2
		      "ipsec_validate_id_information: IPv6 network/netmask",
			     buf, 2 * sizeof(struct in6_addr)));
d831 2
a832 2
		log_print("ipsec_validate_id_information: "
			  "dubious ID information accepted");
d841 1
a841 1
ipsec_validate_key_information(u_int8_t * buf, size_t sz)
d851 1
a851 1
	|| type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
d857 2
a858 1
	return proto < IPSEC_PROTO_IPSEC_AH || proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
d862 1
a862 1
ipsec_validate_situation(u_int8_t * buf, size_t * sz, size_t len)
d866 1
a866 1
			  (unsigned int) len);
d883 3
a885 2
		 * As no unexpected protocols can occur, we just tie the default case
		 * to the first case, in orer to silence a GCC warning.
d889 4
a892 4
		return transform_id != IPSEC_TRANSFORM_KEY_IKE;
	case IPSEC_PROTO_IPSEC_AH:
		return
			transform_id < IPSEC_AH_MD5 || transform_id > IPSEC_AH_DES ? -1 : 0;
d895 3
a897 3
			|| (transform_id > IPSEC_ESP_AES_128_CTR
			    && transform_id < IPSEC_ESP_AES_MARS)
			|| transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
d900 1
a900 1
			|| transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
d905 1
a905 1
ipsec_initiator(struct message * msg)
d908 1
a908 1
	int             (**script) (struct message *) = 0;
d912 7
a918 7
	  && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	       && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	       && exchange->type != ISAKMP_EXCH_INFO)
	   || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE
	       && exchange->type != ISAKMP_EXCH_INFO))) {
		log_print("ipsec_initiator: unsupported exchange type %d in phase %d",
			  exchange->type, exchange->phase);
d960 2
a961 2
ipsec_delete_spi_list(struct sockaddr * addr, u_int8_t proto,
		      u_int8_t * spis, int nspis, char *type)
d968 1
a968 1
			u_int8_t       *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;
d977 1
a977 1
			u_int32_t       spi = ((u_int32_t *) spis)[i];
d983 3
a985 3
			LOG_DBG((LOG_SA, 30, "ipsec_delete_spi_list: "
				 "could not locate SA (SPI %08x, proto %u)",
				 ((u_int32_t *) spis)[i], proto));
d990 2
a991 2
		     "%s made us delete SA %p (%d references) for proto %d",
			 type, sa, sa->refcnt, proto));
d998 1
a998 1
ipsec_responder(struct message * msg)
d1001 1
a1001 1
	int             (**script) (struct message *) = 0;
d1007 7
a1013 5
	  && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	       && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	       && exchange->type != ISAKMP_EXCH_INFO)
	      || (exchange->phase == 2 && exchange->type == ISAKMP_EXCH_ID_PROT))) {
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
d1016 2
a1017 3
	LOG_DBG((LOG_MISC, 30,
	   "ipsec_responder: phase %d exchange %d step %d", exchange->phase,
		 exchange->type, exchange->step));
d1037 1
a1037 1
		     p = TAILQ_NEXT(p, link)) {
d1040 2
a1041 2
				 "ipsec_responder: got NOTIFY of type %s",
				 constant_name(isakmp_notify_cst, type)));
d1047 2
a1048 2
		 * If any DELETEs are in here, let the logic of leftover payloads deal
		 * with them.
d1058 2
a1059 1
		message_drop(msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
d1068 2
a1069 1
	 * XXX So far we don't accept any proposals for exchanges we don't support.
d1103 2
a1104 2
ipsec_is_attribute_incompatible(u_int16_t type, u_int8_t * value,
				u_int16_t len, void *vmsg)
d1118 3
a1120 3
			     || decode_16(value) > IKE_GROUP_DESC_MODP_1536)
				&& (decode_16(value) < IKE_GROUP_DESC_MODP_2048
			    || decode_16(value) > IKE_GROUP_DESC_MODP_8192);
d1135 1
a1135 1
				|| decode_16(value) > IKE_DURATION_KILOBYTES;
d1142 2
a1143 2
			 * Our crypto routines only allows key-lengths which are multiples
			 * of an octet.
d1155 1
a1155 1
				|| decode_16(value) > IPSEC_DURATION_KILOBYTES;
d1160 3
a1162 3
			     || decode_16(value) > IKE_GROUP_DESC_MODP_1536)
				&& (decode_16(value) < IKE_GROUP_DESC_MODP_2048
			    || IKE_GROUP_DESC_MODP_8192 < decode_16(value));
d1165 1
a1165 1
				|| decode_16(value) > IPSEC_ENCAP_TRANSPORT;
d1168 1
a1168 1
				|| decode_16(value) > IPSEC_AUTH_HMAC_RIPEMD;
d1195 2
a1196 2
ipsec_debug_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
		      void *vmsg)
d1210 2
a1211 3
		 constant_name(msg->exchange->phase == 1
			       ? ike_attr_cst : ipsec_attr_cst, type),
		 val));
d1222 2
a1223 2
ipsec_decode_attribute(u_int16_t type, u_int8_t * value, u_int16_t len,
		       void *vida)
d1239 2
a1240 1
			exchange->crypto = crypto_get(from_ike_crypto(decode_16(value)));
d1279 2
a1280 1
					log_print("ipsec_decode_attribute: unreasonable lifetime");
d1292 2
a1293 1
					log_print("ipsec_decode_attribute: unreasonable lifetime");
d1297 2
a1298 1
				log_print("ipsec_decode_attribute: unknown lifetime type");
d1327 2
a1328 1
					log_print("ipsec_decode_attribute: unreasonable lifetime");
d1340 2
a1341 1
					log_print("ipsec_decode_attribute: unreasonable lifetime");
d1345 2
a1346 1
				log_print("ipsec_decode_attribute: unknown lifetime type");
d1386 2
a1387 2
ipsec_decode_transform(struct message * msg, struct sa * sa,
		       struct proto * proto, u_int8_t * buf)
d1393 1
a1393 1
		 GET_ISAKMP_TRANSFORM_NO(buf)));
d1405 2
a1406 2
		 GET_ISAKMP_GEN_LENGTH(buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		      ipsec_decode_attribute, &ida);
d1421 1
a1421 1
ipsec_delete_spi(struct sa * sa, struct proto * proto, int incoming)
d1434 1
a1434 1
ipsec_g_x(struct message * msg, int peer, u_int8_t * buf)
d1445 2
a1446 1
		log_error("ipsec_g_x: malloc (%lu) failed", (unsigned long) ie->g_x_len);
d1450 2
a1451 1
	snprintf(header, sizeof header, "ipsec_g_x: g^x%c", initiator ? 'i' : 'r');
d1458 1
a1458 1
ipsec_gen_g_x(struct message * msg)
d1467 1
a1467 1
			  ISAKMP_KE_SZ + (unsigned long) ie->g_x_len);
d1471 1
a1471 1
				ISAKMP_KE_SZ + ie->g_x_len, 1)) {
d1485 1
a1485 1
ipsec_save_g_x(struct message * msg)
d1509 1
a1509 1
ipsec_get_spi(size_t * sz, u_int8_t proto, struct message * msg)
d1522 2
a1523 1
		return sysdep_ipsec_get_spi(sz, proto, src, dst, msg->exchange->seq);
d1534 2
a1535 2
ipsec_handle_leftover_payload(struct message * msg, u_int8_t type,
			      struct payload * payload)
d1550 2
a1551 2
			LOG_DBG((LOG_SA, 60, "ipsec_handle_leftover_payload: message "
				 "specified zero SPIs, ignoring"));
d1555 7
a1561 5
		if ((proto == ISAKMP_PROTO_ISAKMP && spisz != ISAKMP_HDR_COOKIES_LEN)
		    || (proto != ISAKMP_PROTO_ISAKMP && spisz != sizeof(u_int32_t))) {
			log_print("ipsec_handle_leftover_payload: "
			"invalid SPI size %d for proto %d in DELETE payload",
				  spisz, proto);
d1566 2
a1567 2
			log_error("ipsec_handle_leftover_payload: malloc (%d) failed",
				  nspis * spisz);
d1588 6
a1593 5
			 * XXX Instead of the first condition above, we could permit this
			 * XXX only for phase 2. In the last packet of main-mode, this
			 * XXX payload, while encrypted, is not part of the hash digest.
			 * XXX As we currently send our own INITIAL-CONTACTs at this point,
			 * XXX this too would need to be changed.
d1596 2
a1597 2
				log_print("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
					  "in AGGRESSIVE mode");
d1600 4
a1603 3
			if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0) {
				log_print("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
					  "without ISAKMP SA");
d1607 4
a1610 3
			 * Find out who is sending this and then delete every SA that is
			 * ready.  Exchanges will timeout themselves and then the
			 * non-ready SAs will disappear too.
d1613 2
a1614 1
			while ((sa = sa_lookup_by_peer(dst, sysdep_sa_len(dst))) != 0) {
d1616 6
a1621 5
				 * Don't delete the current SA -- we received the
				 * notification over it, so it's obviously still
				 * active. We temporarily need to remove the SA
				 * from the list to avoid an endless loop, but
				 * keep a reference so it won't disappear meanwhile.
d1649 1
a1649 1
ipsec_esp_enckeylength(struct proto * proto)
d1677 1
a1677 1
ipsec_esp_authkeylength(struct proto * proto)
d1700 1
a1700 1
ipsec_ah_keylength(struct proto * proto)
d1721 1
a1721 1
ipsec_keymat_length(struct proto * proto)
d1725 2
a1726 1
		return ipsec_esp_enckeylength(proto) + ipsec_esp_authkeylength(proto);
d1877 2
a1878 2
ipsec_decode_id(char *buf, size_t size, u_int8_t * id, size_t id_len,
		int isakmpform)
d1899 1
a1899 1
				 decode_32(id + ISAKMP_ID_DATA_OFF), addr);
d1906 1
a1906 1
				 decode_32(id + ISAKMP_ID_DATA_OFF),
d1912 2
a1913 2
			snprintf(buf, size, "%08x%08x%08x%08x: %s", *idp, *(idp + 1),
				 *(idp + 2), *(idp + 3), addr);
d1919 4
a1922 3
				  sizeof(struct in6_addr));
			snprintf(buf, size, "%08x%08x%08x%08x/%08x%08x%08x%08x: %s/%s",
			*idp, *(idp + 1), *(idp + 2), *(idp + 3), *(idp + 4),
d1938 1
a1938 1
					      id_len - ISAKMP_ID_DATA_OFF);
d1959 3
a1961 3
char           *
ipsec_decode_ids(char *fmt, u_int8_t * id1, size_t id1_len,
		 u_int8_t * id2, size_t id2_len, int isakmpform)
d1978 2
a1979 2
u_int8_t       *
ipsec_build_id(char *section, size_t * sz)
d1999 2
a2000 1
		log_print("ipsec_build_id: malloc(%lu) failed", (unsigned long) *sz);
d2004 1
a2004 1
	SET_ISAKMP_ID_DOI_DATA(p, (unsigned char *) "\000\000\000");
d2007 1
a2007 1
	       sockaddr_addrlen(addr));
d2010 1
a2010 1
		       sockaddr_addrdata(mask), sockaddr_addrlen(mask));
d2022 1
a2022 1
ipsec_clone_id(u_int8_t ** did, size_t * did_len, u_int8_t * id, size_t id_len)
d2035 2
a2036 1
		log_error("ipsec_clone_id: malloc(%lu) failed", (unsigned long) id_len);
d2051 1
a2051 1
ipsec_proto_init(struct proto * proto, char *section)
d2056 2
a2057 2
		iproto->replay_window
			= conf_get_num(section, "ReplayWindow", DEFAULT_REPLAY_WINDOW);
d2065 1
a2065 1
ipsec_initial_contact(struct message * msg)
d2067 1
a2067 1
	u_int8_t       *buf;
d2075 1
a2075 1
			  ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
d2083 1
a2083 1
	       ISAKMP_HDR_COOKIES_LEN);
d2085 1
a2085 1
			    ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN, 1)) {
d2113 1
a2113 1
ipsec_add_contact(struct message * msg)
d2123 2
a2124 2
			log_error("ipsec_add_contact: realloc (%p, %lu) failed", contacts,
				  cnt * (unsigned long) sizeof contacts[0]);
d2133 2
a2134 1
		log_error("ipsec_add_contact: malloc (%d) failed", sysdep_sa_len(dst));
d2151 1
a2151 1
ipsec_contacted(struct message * msg)
d2157 2
a2158 4
	return contacts
		? (bsearch(&contact, contacts, contact_cnt, sizeof *contacts, addr_cmp)
		   != 0)
		: 0;
d2162 2
a2163 2
u_int8_t       *
ipsec_add_hash_payload(struct message * msg, size_t hashsize)
d2165 1
a2165 1
	u_int8_t       *buf;
d2170 1
a2170 1
			  ISAKMP_HASH_SZ + (unsigned long) hashsize);
d2174 1
a2174 1
				ISAKMP_HASH_SZ + hashsize, 1)) {
d2183 1
a2183 1
ipsec_fill_in_hash(struct message * msg)
d2207 4
a2210 3
	LOG_DBG_BUF((LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a", isa->skeyid_a,
		     isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
d2216 3
a2218 2
		     exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d2224 1
a2224 1
		     "ipsec_fill_in_hash: payload %d after HASH(1)", i - 1);
d2226 3
a2228 2
			     msg->iov[i].iov_len));
		prf->Update(prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
d2232 2
a2233 2
	LOG_DBG_BUF((LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)",
		     buf + ISAKMP_HASH_DATA_OFF, hash->hashsize));
d2240 1
a2240 1
ipsec_informational_pre_hook(struct message * msg)
d2257 1
a2257 1
ipsec_informational_post_hook(struct message * msg)
d2265 1
a2265 1
ipsec_id_size(char *section, u_int8_t * id)
d2267 1
a2267 1
	char           *type, *data;
d2271 2
a2272 1
		log_print("ipsec_id_size: section %s has no \"ID-type\" tag", section);
d2292 2
a2293 1
			log_print("ipsec_id_size: section %s has no \"Name\" tag", section);
d2299 1
a2299 1
		  *id, type);
d2306 2
a2307 2
char           *
ipsec_id_string(u_int8_t * id, size_t id_len)
d2314 3
a2316 3
	 * XXX Real ugly way of making the offsets correct.  Be aware that id now
	 * will point before the actual buffer and cannot be dereferenced without
	 * an offset larger than or equal to ISAKM_GEN_SZ.
d2329 1
a2329 1
		   sizeof "asn1_dn/" + id_len - ISAKMP_ID_DATA_OFF);
d2358 1
a2358 1
			size);
d2370 1
a2370 1
					 id_len - ISAKMP_ID_DATA_OFF);
d2381 3
a2383 2
		LOG_DBG((LOG_MISC, 10, "ipsec_id_string: unknown identity type %d\n",
			 GET_ISAKMP_ID_TYPE(id)));
@


1.89
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: ipsec.c,v 1.88 2004/04/07 22:45:49 ho Exp $	 */
d1702 43
d1752 2
a1753 2
ipsec_get_id(char *section, int *id, struct sockaddr ** addr,
	     struct sockaddr ** mask, u_int8_t * tproto, u_int16_t * port)
d1755 1
a1755 1
	char           *type, *address, *netmask;
d1759 2
a1760 1
		log_print("ipsec_get_id: section %s has no \"ID-type\" tag", section);
d1769 2
a1770 2
			log_print("ipsec_get_id: section %s has no \"Address\" tag",
				  section);
d1774 2
a1775 2
			log_print("ipsec_get_id: invalid address %s in section %s", address,
				  section);
d1778 1
a1778 4
		*tproto = conf_get_num(section, "Protocol", 0);
		if (*tproto)
			*port = conf_get_num(section, "Port", 0);
		break;
d1792 2
a1793 2
			log_print("ipsec_get_id: section %s has no \"Network\" tag",
				  section);
d1797 2
a1798 2
			log_print("ipsec_get_id: invalid section %s network %s", section,
				  address);
d1803 2
a1804 2
			log_print("ipsec_get_id: section %s has no \"Netmask\" tag",
				  section);
d1808 2
a1809 2
			log_print("ipsec_id_build: invalid section %s network %s", section,
				  netmask);
d1812 1
a1812 4
		*tproto = conf_get_num(section, "Protocol", 0);
		if (*tproto)
			*port = conf_get_num(section, "Port", 0);
		break;
d1832 2
a1833 2
		log_print("ipsec_get_id: unknown ID type \"%s\" in section %s", type,
			  section);
@


1.88
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.87 2004/03/10 23:08:48 hshoexer Exp $	*/
/*	$EOM: ipsec.c,v 1.143 2000/12/11 23:57:42 niklas Exp $	*/
d81 3
a83 3
  struct message *msg;
  struct sa *sa;
  struct proto *proto;
d88 8
a95 8
  struct sockaddr *addr;
  socklen_t len;
} *contacts = 0;
int contact_cnt = 0, contact_limit = 0;

static int addr_cmp (const void *, const void *);
static int ipsec_add_contact (struct message *msg);
static int ipsec_contacted (struct message *msg);
d97 1
a97 1
static int ipsec_debug_attribute (u_int16_t, u_int8_t *, u_int16_t, void *);
d99 30
a128 28
static void ipsec_delete_spi (struct sa *, struct proto *, int);
static int16_t *ipsec_exchange_script (u_int8_t);
static void ipsec_finalize_exchange (struct message *);
static void ipsec_free_exchange_data (void *);
static void ipsec_free_proto_data (void *);
static void ipsec_free_sa_data (void *);
static struct keystate *ipsec_get_keystate (struct message *);
static u_int8_t *ipsec_get_spi (size_t *, u_int8_t, struct message *);
static int ipsec_handle_leftover_payload (struct message *, u_int8_t,
					  struct payload *);
static int ipsec_informational_post_hook (struct message *);
static int ipsec_informational_pre_hook (struct message *);
static int ipsec_initiator (struct message *);
static void ipsec_proto_init (struct proto *, char *);
static int ipsec_responder (struct message *);
static void ipsec_setup_situation (u_int8_t *);
static int ipsec_set_network (u_int8_t *, u_int8_t *, struct ipsec_sa *);
static size_t ipsec_situation_size (void);
static u_int8_t ipsec_spi_size (u_int8_t);
static int ipsec_validate_attribute (u_int16_t, u_int8_t *, u_int16_t, void *);
static int ipsec_validate_exchange (u_int8_t);
static int ipsec_validate_id_information (u_int8_t, u_int8_t *, u_int8_t *,
					  size_t, struct exchange *);
static int ipsec_validate_key_information (u_int8_t *, size_t);
static int ipsec_validate_notification (u_int16_t);
static int ipsec_validate_proto (u_int8_t);
static int ipsec_validate_situation (u_int8_t *, size_t *, size_t);
static int ipsec_validate_transform_id (u_int8_t, u_int8_t);
d131 3
a133 3
  { 0 }, IPSEC_DOI_IPSEC,
  sizeof (struct ipsec_exch), sizeof (struct ipsec_sa),
  sizeof (struct ipsec_proto),
d135 1
a135 1
  ipsec_debug_attribute,
d137 27
a163 27
  ipsec_delete_spi,
  ipsec_exchange_script,
  ipsec_finalize_exchange,
  ipsec_free_exchange_data,
  ipsec_free_proto_data,
  ipsec_free_sa_data,
  ipsec_get_keystate,
  ipsec_get_spi,
  ipsec_handle_leftover_payload,
  ipsec_informational_post_hook,
  ipsec_informational_pre_hook,
  ipsec_is_attribute_incompatible,
  ipsec_proto_init,
  ipsec_setup_situation,
  ipsec_situation_size,
  ipsec_spi_size,
  ipsec_validate_attribute,
  ipsec_validate_exchange,
  ipsec_validate_id_information,
  ipsec_validate_key_information,
  ipsec_validate_notification,
  ipsec_validate_proto,
  ipsec_validate_situation,
  ipsec_validate_transform_id,
  ipsec_initiator,
  ipsec_responder,
  ipsec_decode_ids
d166 11
a176 11
int16_t script_quick_mode[] = {
  ISAKMP_PAYLOAD_HASH,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_SA,
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_HASH,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_SA,
  ISAKMP_PAYLOAD_NONCE,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_HASH,		/* Initiator -> responder.  */
  EXCHANGE_SCRIPT_END
d179 7
a185 7
int16_t script_new_group_mode[] = {
  ISAKMP_PAYLOAD_HASH,		/* Initiator -> responder.  */
  ISAKMP_PAYLOAD_SA,
  EXCHANGE_SCRIPT_SWITCH,
  ISAKMP_PAYLOAD_HASH,		/* Responder -> initiator.  */
  ISAKMP_PAYLOAD_SA,
  EXCHANGE_SCRIPT_END
d189 3
a191 3
  struct sockaddr *dst;
  u_int32_t spi;
  u_int8_t proto;
d200 1
a200 1
ipsec_sa_check (struct sa *sa, void *v_arg)
d202 26
a227 19
  struct dst_spi_proto_arg *arg = v_arg;
  struct proto *proto;
  struct sockaddr *dst, *src;
  int incoming;

  if (sa->phase != 2 || !(sa->flags & SA_FLAG_READY))
    return 0;

  sa->transport->vtbl->get_dst (sa->transport, &dst);
  if (memcmp (sockaddr_addrdata (dst), sockaddr_addrdata (arg->dst),
	      sockaddr_addrlen (dst)) == 0)
    incoming = 0;
  else
    {
      sa->transport->vtbl->get_src (sa->transport, &src);
      if (memcmp (sockaddr_addrdata (src), sockaddr_addrdata (arg->dst),
		  sockaddr_addrlen (src)) == 0)
	incoming = 1;
      else
a228 8
    }

  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    if ((arg->proto == 0 || proto->proto == arg->proto)
       && memcmp (proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
      return 1;
  return 0;
d232 2
a233 2
struct sa *
ipsec_sa_lookup (struct sockaddr *dst, u_int32_t spi, u_int8_t proto)
d235 1
a235 5
  struct dst_spi_proto_arg arg;

  arg.dst = dst;
  arg.spi = spi;
  arg.proto = proto;
d237 4
a240 1
  return sa_find (ipsec_sa_check, &arg);
d249 1
a249 1
ipsec_sa_check_flow (struct sa *sa, void *v_arg)
d251 2
a252 2
  struct sa *sa2 = v_arg;
  struct ipsec_sa *isa = sa->data, *isa2 = sa2->data;
d254 21
a274 21
  if (sa == sa2 || sa->phase != 2
      || (sa->flags & (SA_FLAG_READY | SA_FLAG_REPLACED)) != SA_FLAG_READY)
    return 0;

  if (isa->tproto != isa2->tproto || isa->sport != isa2->sport
      || isa->dport != isa2->dport)
    return 0;

  return isa->src_net->sa_family == isa2->src_net->sa_family
    && memcmp (sockaddr_addrdata (isa->src_net),
	       sockaddr_addrdata (isa2->src_net),
	       sockaddr_addrlen (isa->src_net)) == 0
    && memcmp (sockaddr_addrdata (isa->src_mask),
	       sockaddr_addrdata (isa2->src_mask),
	       sockaddr_addrlen (isa->src_mask)) == 0
    && memcmp (sockaddr_addrdata (isa->dst_net),
	       sockaddr_addrdata (isa2->dst_net),
	       sockaddr_addrlen (isa->dst_net)) == 0
    && memcmp (sockaddr_addrdata (isa->dst_mask),
	       sockaddr_addrdata (isa2->dst_mask),
	       sockaddr_addrlen (isa->dst_mask)) == 0;
d282 1
a282 1
ipsec_finalize_exchange (struct message *msg)
d284 6
a289 6
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct sa *sa = 0, *old_sa;
  struct proto *proto, *last_proto = 0;
d291 1
a291 1
  char *addr1, *addr2, *mask1, *mask2;
d294 21
a314 70
  switch (exchange->phase)
    {
    case 1:
      switch (exchange->type)
	{
	case ISAKMP_EXCH_ID_PROT:
	case ISAKMP_EXCH_AGGRESSIVE:
	  isa = isakmp_sa->data;
	  isa->hash = ie->hash->type;
	  isa->prf_type = ie->prf_type;
	  isa->skeyid_len = ie->skeyid_len;
	  isa->skeyid_d = ie->skeyid_d;
	  isa->skeyid_a = ie->skeyid_a;
	  /* Prevents early free of SKEYID_*.  */
	  ie->skeyid_a = ie->skeyid_d = 0;

	  /* If a lifetime was negotiated setup the expiration timers.  */
	  if (isakmp_sa->seconds)
	    sa_setup_expirations (isakmp_sa);
	  break;
	}
      break;

    case 2:
      switch (exchange->type)
	{
	case IKE_EXCH_QUICK_MODE:
	  /*
	   * Tell the application(s) about the SPIs and key material.
	   */
	  for (sa = TAILQ_FIRST (&exchange->sa_list); sa;
	       sa = TAILQ_NEXT (sa, next))
	    {
	      isa = sa->data;

	      if (exchange->initiator)
		{
		  /* Initiator is source, responder is destination.  */
		  if (ipsec_set_network (ie->id_ci, ie->id_cr, isa))
		    {
		      log_print ("ipsec_finalize_exchange: "
				 "ipsec_set_network failed");
		      return;
		    }
		}
	      else
		{
		  /* Responder is source, initiator is destination.  */
		  if (ipsec_set_network (ie->id_cr, ie->id_ci, isa))
		    {
		      log_print ("ipsec_finalize_exchange: "
				 "ipsec_set_network failed");
		      return;
		    }
		}

	      for (proto = TAILQ_FIRST (&sa->protos), last_proto = 0; proto;
		   proto = TAILQ_NEXT (proto, link))
		{
		  if (sysdep_ipsec_set_spi (sa, proto, 0, isakmp_sa)
		      || (last_proto
			  && sysdep_ipsec_group_spis (sa, last_proto, proto,
						      0))
		      || sysdep_ipsec_set_spi (sa, proto, 1, isakmp_sa)
		      || (last_proto
			  && sysdep_ipsec_group_spis (sa, last_proto, proto,
						      1)))
		    /* XXX Tear down this exchange.  */
		    return;
		  last_proto = proto;
d316 54
d372 45
a416 41
	      if (sockaddr2text (isa->src_net, &addr1, 0))
		addr1 = 0;
	      if (sockaddr2text (isa->src_mask, &mask1, 0))
		mask1 = 0;
	      if (sockaddr2text (isa->dst_net, &addr2, 0))
		addr2 = 0;
	      if (sockaddr2text (isa->dst_mask, &mask2, 0))
		mask2 = 0;
		
	      LOG_DBG ((LOG_EXCHANGE, 50,
			"ipsec_finalize_exchange: "
			"src %s %s dst %s %s tproto %u sport %u dport %u",
			addr1 ? addr1 : "<??\?>" , mask1 ? mask1 : "<??\?>",
			addr2 ? addr2 : "<??\?>" , mask2 ? mask2 : "<??\?>",
			isa->tproto, ntohs (isa->sport), ntohs (isa->dport)));

	      if (addr1)
		free (addr1);
	      if (mask1)
		free (mask1);
	      if (addr2)
		free (addr2);
	      if (mask2)
		free (mask2);

#endif /* USE_DEBUG */

	      /*
	       * If this is not an SA acquired by the kernel, it needs
	       * to have a SPD entry (a.k.a. flow) set up.
	       */
	      if (!(sa->flags & SA_FLAG_ONDEMAND)
		  && sysdep_ipsec_enable_sa (sa, isakmp_sa))
		/* XXX Tear down this exchange.  */
		return;

	      /* Mark elder SAs with the same flow information as replaced.  */
	      while ((old_sa = sa_find (ipsec_sa_check_flow, sa)) != 0)
		sa_mark_replaced (old_sa);
	    }
	  break;
a417 1
    }
d422 1
a422 1
ipsec_set_network (u_int8_t *src_id, u_int8_t *dst_id, struct ipsec_sa *isa)
d424 1
a424 1
  int id;
d426 10
a435 11
  /* Set source address/mask.  */
  id = GET_ISAKMP_ID_TYPE (src_id);
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      isa->src_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->src_net)
	goto memfail;
      isa->src_net->sa_family = AF_INET;
d437 1
a437 1
      isa->src_net->sa_len = sizeof (struct sockaddr_in);
d440 5
a444 5
      isa->src_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->src_mask)
	goto memfail;
      isa->src_mask->sa_family = AF_INET;
d446 1
a446 1
      isa->src_mask->sa_len = sizeof (struct sockaddr_in);
d448 1
a448 1
      break;
d450 7
a456 7
    case IPSEC_ID_IPV6_ADDR:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      isa->src_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->src_net)
	goto memfail;
      isa->src_net->sa_family = AF_INET6;
d458 1
a458 1
      isa->src_net->sa_len = sizeof (struct sockaddr_in6);
d461 5
a465 5
      isa->src_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->src_mask)
	goto memfail;
      isa->src_mask->sa_family = AF_INET6;
d467 1
a467 1
      isa->src_mask->sa_len = sizeof (struct sockaddr_in6);
d469 30
a498 1
      break;
d500 13
a512 45
    case IPSEC_ID_IPV4_RANGE:
    case IPSEC_ID_IPV6_RANGE:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
    case IPSEC_ID_KEY_ID:
    default:
      log_print ("ipsec_set_network: ID type %d (%s) not supported",
		 id, constant_name (ipsec_id_cst, id));
      return -1;
    }

  /* Net */
  memcpy (sockaddr_addrdata (isa->src_net), src_id + ISAKMP_ID_DATA_OFF,
	  sockaddr_addrlen (isa->src_net));

  /* Mask */
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      memset (sockaddr_addrdata (isa->src_mask), 0xff,
	      sockaddr_addrlen (isa->src_mask));
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      memcpy (sockaddr_addrdata (isa->src_mask), src_id + ISAKMP_ID_DATA_OFF +
	      sockaddr_addrlen (isa->src_net),
	      sockaddr_addrlen (isa->src_mask));
      break;
    }

  memcpy (&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	  IPSEC_ID_PORT_LEN);

  /* Set destination address.  */
  id = GET_ISAKMP_ID_TYPE (dst_id);
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      isa->dst_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->dst_net)
	goto memfail;
      isa->dst_net->sa_family = AF_INET;
d514 1
a514 1
      isa->dst_net->sa_len = sizeof (struct sockaddr_in);
d517 5
a521 5
      isa->dst_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in));
      if (!isa->dst_mask)
	goto memfail;
      isa->dst_mask->sa_family = AF_INET;
d523 1
a523 1
      isa->dst_mask->sa_len = sizeof (struct sockaddr_in);
d525 1
a525 1
      break;
d527 7
a533 7
    case IPSEC_ID_IPV6_ADDR:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      isa->dst_net =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->dst_net)
	goto memfail;
      isa->dst_net->sa_family = AF_INET6;
d535 1
a535 1
      isa->dst_net->sa_len = sizeof (struct sockaddr_in6);
d538 5
a542 5
      isa->dst_mask =
	(struct sockaddr *)calloc (1, sizeof (struct sockaddr_in6));
      if (!isa->dst_mask)
	goto memfail;
      isa->dst_mask->sa_family = AF_INET6;
d544 1
a544 1
      isa->dst_mask->sa_len = sizeof (struct sockaddr_in6);
d546 21
a566 2
      break;
    }
d568 9
a576 29
  /* Net */
  memcpy (sockaddr_addrdata (isa->dst_net), dst_id + ISAKMP_ID_DATA_OFF,
	  sockaddr_addrlen (isa->dst_net));

  /* Mask */
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      memset (sockaddr_addrdata (isa->dst_mask), 0xff,
	      sockaddr_addrlen (isa->dst_mask));
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      memcpy (sockaddr_addrdata (isa->dst_mask), dst_id + ISAKMP_ID_DATA_OFF +
	      sockaddr_addrlen (isa->dst_net),
	      sockaddr_addrlen (isa->dst_mask));
      break;
    }

  memcpy (&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	  IPSEC_ID_PROTO_LEN);
  memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	  IPSEC_ID_PORT_LEN);
  return 0;

 memfail:
  log_error ("ipsec_set_network: calloc () failed");
  return -1;
d581 1
a581 1
ipsec_free_exchange_data (void *vie)
d583 1
a583 1
  struct ipsec_exch *ie = vie;
d585 1
a585 1
  struct isakmp_cfg_attr *attr;
d588 26
a613 26
  if (ie->sa_i_b)
    free (ie->sa_i_b);
  if (ie->id_ci)
    free (ie->id_ci);
  if (ie->id_cr)
    free (ie->id_cr);
  if (ie->g_xi)
    free (ie->g_xi);
  if (ie->g_xr)
    free (ie->g_xr);
  if (ie->g_xy)
    free (ie->g_xy);
  if (ie->skeyid)
    free (ie->skeyid);
  if (ie->skeyid_d)
    free (ie->skeyid_d);
  if (ie->skeyid_a)
    free (ie->skeyid_a);
  if (ie->skeyid_e)
    free (ie->skeyid_e);
  if (ie->hash_i)
    free (ie->hash_i);
  if (ie->hash_r)
    free (ie->hash_r);
  if (ie->group)
    group_free (ie->group);
d615 6
a620 7
  for (attr = LIST_FIRST (&ie->attrs); attr; attr = LIST_FIRST (&ie->attrs))
    {
      LIST_REMOVE (attr, link);
      if (attr->length)
	free (attr->value);
      free (attr);
    }
d626 1
a626 1
ipsec_free_sa_data (void *visa)
d628 1
a628 1
  struct ipsec_sa *isa = visa;
d630 12
a641 12
  if (isa->src_net)
    free (isa->src_net);
  if (isa->src_mask)
    free (isa->src_mask);
  if (isa->dst_net)
    free (isa->dst_net);
  if (isa->dst_mask)
    free (isa->dst_mask);
  if (isa->skeyid_a)
    free (isa->skeyid_a);
  if (isa->skeyid_d)
    free (isa->skeyid_d);
d646 1
a646 1
ipsec_free_proto_data (void *viproto)
d648 2
a649 2
  struct ipsec_proto *iproto = viproto;
  int i;
d651 3
a653 3
  for (i = 0; i < 2; i++)
    if (iproto->keymat[i])
      free (iproto->keymat[i]);
d658 1
a658 1
ipsec_exchange_script (u_int8_t type)
d660 1
a660 2
  switch (type)
    {
d662 2
a663 2
    case ISAKMP_EXCH_TRANSACTION:
      return script_transaction;
d665 6
a670 6
    case IKE_EXCH_QUICK_MODE:
      return script_quick_mode;
    case IKE_EXCH_NEW_GROUP_MODE:
      return script_new_group_mode;
    }
  return 0;
d675 1
a675 1
ipsec_init (void)
d677 1
a677 1
  doi_register (&ipsec_doi);
d682 1
a682 1
ipsec_get_keystate (struct message *msg)
d684 2
a685 2
  struct keystate *ks;
  struct hash *hash;
d687 42
a728 46
  /* If we have already have an IV, use it.  */
  if (msg->exchange && msg->exchange->keystate)
    {
      ks = malloc (sizeof *ks);
      if (!ks)
	{
	  log_error ("ipsec_get_keystate: malloc (%lu) failed",
		(unsigned long)sizeof *ks);
	  return 0;
	}
      memcpy (ks, msg->exchange->keystate, sizeof *ks);
      return ks;
    }

  /*
   * For phase 2 when no SA yet is setup we need to hash the IV used by
   * the ISAKMP SA concatenated with the message ID, and use that as an
   * IV for further cryptographic operations.
   */
  if (!msg->isakmp_sa->keystate)
    {
      log_print ("ipsec_get_keystate: no keystate in ISAKMP SA %p",
		 msg->isakmp_sa);
      return 0;
    }
  ks = crypto_clone_keystate (msg->isakmp_sa->keystate);
  if (!ks)
    return 0;

  hash = hash_get (((struct ipsec_sa *)msg->isakmp_sa->data)->hash);
  hash->Init (hash->ctx);
  LOG_DBG_BUF ((LOG_CRYPTO, 80, "ipsec_get_keystate: final phase 1 IV",
		ks->riv, ks->xf->blocksize));
  hash->Update (hash->ctx, ks->riv, ks->xf->blocksize);
  LOG_DBG_BUF ((LOG_CRYPTO, 80, "ipsec_get_keystate: message ID",
		((u_int8_t *)msg->iov[0].iov_base)
		+ ISAKMP_HDR_MESSAGE_ID_OFF,
		ISAKMP_HDR_MESSAGE_ID_LEN));
  hash->Update (hash->ctx,
		((u_int8_t *)msg->iov[0].iov_base) + ISAKMP_HDR_MESSAGE_ID_OFF,
		ISAKMP_HDR_MESSAGE_ID_LEN);
  hash->Final (hash->digest, hash->ctx);
  crypto_init_iv (ks, hash->digest, ks->xf->blocksize);
  LOG_DBG_BUF ((LOG_CRYPTO, 80, "ipsec_get_keystate: phase 2 IV",
		hash->digest, ks->xf->blocksize));
  return ks;
d732 1
a732 1
ipsec_setup_situation (u_int8_t *buf)
d734 1
a734 1
  SET_IPSEC_SIT_SIT (buf + ISAKMP_SA_SIT_OFF, IPSEC_SIT_IDENTITY_ONLY);
d737 2
a738 2
static size_t
ipsec_situation_size (void)
d740 1
a740 1
  return IPSEC_SIT_SIT_LEN;
d743 2
a744 2
static u_int8_t
ipsec_spi_size (u_int8_t proto)
d746 1
a746 1
  return IPSEC_SPI_SIZE;
d750 2
a751 2
ipsec_validate_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
			  void *vmsg)
d753 1
a753 1
  struct message *msg = vmsg;
d755 8
a762 8
  if ((msg->exchange->phase == 1
       && (type < IKE_ATTR_ENCRYPTION_ALGORITHM
	   || type > IKE_ATTR_GROUP_ORDER))
      || (msg->exchange->phase == 2
	  && (type < IPSEC_ATTR_SA_LIFE_TYPE
	      || type > IPSEC_ATTR_ECN_TUNNEL)))
    return -1;
  return 0;
d766 1
a766 1
ipsec_validate_exchange (u_int8_t exch)
d768 1
a768 1
  return exch != IKE_EXCH_QUICK_MODE && exch != IKE_EXCH_NEW_GROUP_MODE;
d772 2
a773 2
ipsec_validate_id_information (u_int8_t type, u_int8_t *extra, u_int8_t *buf,
			       size_t sz, struct exchange *exchange)
d775 2
a776 2
  u_int8_t proto = GET_IPSEC_ID_PROTO (extra);
  u_int16_t port = GET_IPSEC_ID_PORT (extra);
d778 5
a782 5
  LOG_DBG ((LOG_MESSAGE, 40,
	    "ipsec_validate_id_information: proto %d port %d type %d",
	    proto, port, type));
  if (type < IPSEC_ID_IPV4_ADDR || type > IPSEC_ID_KEY_ID)
    return -1;
d784 5
a788 6
  switch (type)
    {
    case IPSEC_ID_IPV4_ADDR:
      LOG_DBG_BUF ((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv4",
		    buf, sizeof (struct in_addr)));
      break;
d790 4
a793 4
    case IPSEC_ID_IPV6_ADDR:
      LOG_DBG_BUF ((LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv6",
		    buf, sizeof (struct in6_addr)));
      break;
d795 5
a799 5
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      LOG_DBG_BUF ((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv4 network/netmask",
		    buf, 2 * sizeof (struct in_addr)));
      break;
d801 5
a805 5
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      LOG_DBG_BUF ((LOG_MESSAGE, 40,
		    "ipsec_validate_id_information: IPv6 network/netmask",
		    buf, 2 * sizeof (struct in6_addr)));
      break;
d807 3
a809 3
    default:
      break;
    }
d811 7
a817 5
  if (exchange->phase == 1
      && (proto != IPPROTO_UDP || port != UDP_DEFAULT_PORT)
      && (proto != 0 || port != 0))
    {
/* XXX SSH's ISAKMP tester fails this test (proto 17 - port 0).  */
d819 1
a819 1
      return -1;
d821 2
a822 2
      log_print ("ipsec_validate_id_information: "
		 "dubious ID information accepted");
d824 2
a825 1
    }
d827 1
a827 3
  /* XXX More checks?  */

  return 0;
d831 1
a831 1
ipsec_validate_key_information (u_int8_t *buf, size_t sz)
d833 2
a834 2
  /* XXX Not implemented yet.  */
  return 0;
d838 1
a838 1
ipsec_validate_notification (u_int16_t type)
d840 2
a841 2
  return type < IPSEC_NOTIFY_RESPONDER_LIFETIME
    || type > IPSEC_NOTIFY_INITIAL_CONTACT ? -1 : 0;
d845 1
a845 1
ipsec_validate_proto (u_int8_t proto)
d847 1
a847 1
  return proto < IPSEC_PROTO_IPSEC_AH || proto > IPSEC_PROTO_IPCOMP ? -1 : 0;
d851 1
a851 1
ipsec_validate_situation (u_int8_t *buf, size_t *sz, size_t len)
d853 8
a860 6
  if (len < IPSEC_SIT_SIT_OFF + IPSEC_SIT_SIT_LEN)
    {
      log_print ("ipsec_validate_situation: payload too short: %u",
	         (unsigned int)len);
      return -1;
    }
d862 1
a862 3
  /* Currently only "identity only" situations are supported.  */
  if (GET_IPSEC_SIT_SIT (buf) != IPSEC_SIT_IDENTITY_ONLY)
    return 1;
d864 1
a864 3
  *sz = IPSEC_SIT_SIT_LEN;

  return 0;
d868 1
a868 1
ipsec_validate_transform_id (u_int8_t proto, u_int8_t transform_id)
d870 20
a889 21
  switch (proto)
    {
      /*
       * As no unexpected protocols can occur, we just tie the default case
       * to the first case, in orer to silence a GCC warning.
       */
    default:
    case ISAKMP_PROTO_ISAKMP:
      return transform_id != IPSEC_TRANSFORM_KEY_IKE;
    case IPSEC_PROTO_IPSEC_AH:
      return
	transform_id < IPSEC_AH_MD5 || transform_id > IPSEC_AH_DES ? -1 : 0;
    case IPSEC_PROTO_IPSEC_ESP:
      return transform_id < IPSEC_ESP_DES_IV64
	|| (transform_id > IPSEC_ESP_AES_128_CTR
	    && transform_id < IPSEC_ESP_AES_MARS)
	|| transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
    case IPSEC_PROTO_IPCOMP:
      return transform_id < IPSEC_IPCOMP_OUI
	|| transform_id > IPSEC_IPCOMP_V42BIS ? -1 : 0;
    }
d893 1
a893 1
ipsec_initiator (struct message *msg)
d895 2
a896 2
  struct exchange *exchange = msg->exchange;
  int (**script) (struct message *) = 0;
d898 15
a912 18
  /* Check that the SA is coherent with the IKE rules.  */
  if (exchange->type != ISAKMP_EXCH_TRANSACTION
      && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	   && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	   && exchange->type != ISAKMP_EXCH_INFO)
	  || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE
	      && exchange->type != ISAKMP_EXCH_INFO)))
    {
      log_print ("ipsec_initiator: unsupported exchange type %d in phase %d",
		 exchange->type, exchange->phase);
      return -1;
    }

  switch (exchange->type)
    {
    case ISAKMP_EXCH_ID_PROT:
      script = ike_main_mode_initiator;
      break;
d914 3
a916 3
    case ISAKMP_EXCH_AGGRESSIVE:
      script = ike_aggressive_initiator;
      break;
d919 18
a936 18
    case ISAKMP_EXCH_TRANSACTION:
      script = isakmp_cfg_initiator;
      break;
#endif
    case ISAKMP_EXCH_INFO:
      return message_send_info (msg);
    case IKE_EXCH_QUICK_MODE:
      script = ike_quick_mode_initiator;
      break;
    default:
      log_print ("ipsec_initiator: unsupported exchange type %d",
		 exchange->type);
      return -1;
    }

  /* Run the script code for this step.  */
  if (script)
    return script[exchange->step] (msg);
d938 1
a938 1
  return 0;
d948 2
a949 2
ipsec_delete_spi_list (struct sockaddr *addr, u_int8_t proto,
                       u_int8_t *spis, int nspis, char *type)
d951 33
a983 2
  struct sa *sa;
  int i;
d985 24
a1008 64
  for (i = 0; i < nspis; i++)
    {
      if (proto == ISAKMP_PROTO_ISAKMP)
        {
          u_int8_t *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;

          /*
           * This really shouldn't happen in IPSEC DOI
           * code, but Cisco VPN 3000 sends ISAKMP DELETE's
           * this way.
           */
          sa = sa_lookup_isakmp_sa (addr, spi);
        }
      else
        {
          u_int32_t spi = ((u_int32_t *)spis)[i];

          sa = ipsec_sa_lookup (addr, spi, proto);
        }

      if (sa == NULL)
        {
	  LOG_DBG ((LOG_SA, 30, "ipsec_delete_spi_list: "
		   "could not locate SA (SPI %08x, proto %u)",
		   ((u_int32_t *)spis)[i], proto));
	  continue;
	}

      /* Delete the SA and search for the next */
      LOG_DBG ((LOG_SA, 30, "ipsec_delete_spi_list: "
	       "%s made us delete SA %p (%d references) for proto %d",
	       type, sa, sa->refcnt, proto));

      sa_free (sa);
    }
}

static int
ipsec_responder (struct message *msg)
{
  struct exchange *exchange = msg->exchange;
  int (**script) (struct message *) = 0;
  struct payload *p;
  u_int16_t type;

  /* Check that a new exchange is coherent with the IKE rules.  */
  if (exchange->step == 0 && exchange->type != ISAKMP_EXCH_TRANSACTION
      && ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
	   && exchange->type != ISAKMP_EXCH_AGGRESSIVE
	   && exchange->type != ISAKMP_EXCH_INFO)
	  || (exchange->phase == 2 && exchange->type == ISAKMP_EXCH_ID_PROT)))
    {
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
      return -1;
    }

  LOG_DBG ((LOG_MISC, 30,
	    "ipsec_responder: phase %d exchange %d step %d", exchange->phase,
	    exchange->type, exchange->step));
  switch (exchange->type)
    {
    case ISAKMP_EXCH_ID_PROT:
      script = ike_main_mode_responder;
      break;
d1011 3
a1013 3
    case ISAKMP_EXCH_AGGRESSIVE:
      script = ike_aggressive_responder;
      break;
d1017 44
a1060 58
    case ISAKMP_EXCH_TRANSACTION:
      script = isakmp_cfg_responder;
      break;
#endif

    case ISAKMP_EXCH_INFO:
      for (p = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_NOTIFY]); p;
	   p = TAILQ_NEXT (p, link))
	{
	  type = GET_ISAKMP_NOTIFY_MSG_TYPE (p->p);
	  LOG_DBG ((LOG_EXCHANGE, 10,
		    "ipsec_responder: got NOTIFY of type %s",
		    constant_name (isakmp_notify_cst, type)));

	  p->flags |= PL_MARK;
	}

      /*
       * If any DELETEs are in here, let the logic of leftover payloads deal
       * with them.
       */

      return 0;

    case IKE_EXCH_QUICK_MODE:
      script = ike_quick_mode_responder;
      break;

    default:
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
      return -1;
    }

  /* Run the script code for this step.  */
  if (script)
    return script[exchange->step] (msg);

  /*
   * XXX So far we don't accept any proposals for exchanges we don't support.
   */
  if (TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_SA]))
    {
      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
      return -1;
    }
  return 0;
}

static enum hashes from_ike_hash (u_int16_t hash)
{
  switch (hash)
    {
    case IKE_HASH_MD5:
      return HASH_MD5;
    case IKE_HASH_SHA:
      return HASH_SHA1;
    }
  return -1;
d1063 2
a1064 1
static enum transform from_ike_crypto (u_int16_t crypto)
d1066 14
a1079 2
  /* Coincidentally this is the null operation :-)  */
  return crypto;
d1088 2
a1089 2
ipsec_is_attribute_incompatible (u_int16_t type, u_int8_t *value,
				 u_int16_t len, void *vmsg)
d1091 1
a1091 1
  struct message *msg = vmsg;
d1093 79
a1171 81
  if (msg->exchange->phase == 1)
    {
      switch (type)
	{
	case IKE_ATTR_ENCRYPTION_ALGORITHM:
	  return !crypto_get (from_ike_crypto (decode_16 (value)));
	case IKE_ATTR_HASH_ALGORITHM:
	  return !hash_get (from_ike_hash (decode_16 (value)));
	case IKE_ATTR_AUTHENTICATION_METHOD:
	  return !ike_auth_get (decode_16 (value));
	case IKE_ATTR_GROUP_DESCRIPTION:
	  return (decode_16 (value) < IKE_GROUP_DESC_MODP_768
	          || decode_16 (value) > IKE_GROUP_DESC_MODP_1536) 
	    && (decode_16 (value) < IKE_GROUP_DESC_MODP_2048
	        || decode_16 (value) > IKE_GROUP_DESC_MODP_8192);
	case IKE_ATTR_GROUP_TYPE:
	  return 1;
	case IKE_ATTR_GROUP_PRIME:
	  return 1;
	case IKE_ATTR_GROUP_GENERATOR_1:
	  return 1;
	case IKE_ATTR_GROUP_GENERATOR_2:
	  return 1;
	case IKE_ATTR_GROUP_CURVE_A:
	  return 1;
	case IKE_ATTR_GROUP_CURVE_B:
	  return 1;
	case IKE_ATTR_LIFE_TYPE:
	  return decode_16 (value) < IKE_DURATION_SECONDS
	    || decode_16 (value) > IKE_DURATION_KILOBYTES;
	case IKE_ATTR_LIFE_DURATION:
	  return len != 2 && len != 4;
	case IKE_ATTR_PRF:
	  return 1;
	case IKE_ATTR_KEY_LENGTH:
	  /*
	   * Our crypto routines only allows key-lengths which are multiples
	   * of an octet.
	   */
	  return decode_16 (value) % 8 != 0;
	case IKE_ATTR_FIELD_SIZE:
	  return 1;
	case IKE_ATTR_GROUP_ORDER:
	  return 1;
	}
    }
  else
    {
      switch (type)
	{
	case IPSEC_ATTR_SA_LIFE_TYPE:
	  return decode_16 (value) < IPSEC_DURATION_SECONDS
	    || decode_16 (value) > IPSEC_DURATION_KILOBYTES;
	case IPSEC_ATTR_SA_LIFE_DURATION:
	  return len != 2 && len != 4;
	case IPSEC_ATTR_GROUP_DESCRIPTION:
	  return (decode_16 (value) < IKE_GROUP_DESC_MODP_768
	          || decode_16 (value) > IKE_GROUP_DESC_MODP_1536)
	    && (decode_16 (value) < IKE_GROUP_DESC_MODP_2048
		|| IKE_GROUP_DESC_MODP_8192 < decode_16 (value));
	case IPSEC_ATTR_ENCAPSULATION_MODE:
	  return decode_16 (value) < IPSEC_ENCAP_TUNNEL
	    || decode_16 (value) > IPSEC_ENCAP_TRANSPORT;
	case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
	  return decode_16 (value) < IPSEC_AUTH_HMAC_MD5
	    || decode_16 (value) > IPSEC_AUTH_HMAC_RIPEMD;
	case IPSEC_ATTR_KEY_LENGTH:
	  /* XXX Blowfish needs '0'. Others appear to disregard this attr?  */
	  return 0;
	case IPSEC_ATTR_KEY_ROUNDS:
	  return 1;
	case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
	  return 1;
	case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
	  return 1;
	case IPSEC_ATTR_ECN_TUNNEL:
	  return 1;
	}
    }
  /* XXX Silence gcc.  */
  return 1;
d1180 2
a1181 2
ipsec_debug_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
		       void *vmsg)
d1183 2
a1184 2
  struct message *msg = vmsg;
  char val[20];
d1186 13
a1198 13
  /* XXX Transient solution.  */
  if (len == 2)
    snprintf (val, sizeof val, "%d", decode_16 (value));
  else if (len == 4)
    snprintf (val, sizeof val, "%d", decode_32 (value));
  else
    snprintf (val, sizeof val, "unrepresentable");

  LOG_DBG ((LOG_MESSAGE, 50, "Attribute %s value %s",
	    constant_name (msg->exchange->phase == 1
			   ? ike_attr_cst : ipsec_attr_cst, type),
	    val));
  return 0;
d1208 2
a1209 2
ipsec_decode_attribute (u_int16_t type, u_int8_t *value, u_int16_t len,
			void *vida)
d1211 81
a1291 58
  struct ipsec_decode_arg *ida = vida;
  struct message *msg = ida->msg;
  struct sa *sa = ida->sa;
  struct ipsec_sa *isa = sa->data;
  struct proto *proto = ida->proto;
  struct ipsec_proto *iproto = proto->data;
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  static int lifetype = 0;

  if (exchange->phase == 1)
    {
      switch (type)
	{
	case IKE_ATTR_ENCRYPTION_ALGORITHM:
	  /* XXX Errors possible?  */
	  exchange->crypto = crypto_get (from_ike_crypto (decode_16 (value)));
	  break;
	case IKE_ATTR_HASH_ALGORITHM:
	  /* XXX Errors possible?  */
	  ie->hash = hash_get (from_ike_hash (decode_16 (value)));
	  break;
	case IKE_ATTR_AUTHENTICATION_METHOD:
	  /* XXX Errors possible?  */
	  ie->ike_auth = ike_auth_get (decode_16 (value));
	  break;
	case IKE_ATTR_GROUP_DESCRIPTION:
	  isa->group_desc = decode_16 (value);
	  break;
	case IKE_ATTR_GROUP_TYPE:
	  break;
	case IKE_ATTR_GROUP_PRIME:
	  break;
	case IKE_ATTR_GROUP_GENERATOR_1:
	  break;
	case IKE_ATTR_GROUP_GENERATOR_2:
	  break;
	case IKE_ATTR_GROUP_CURVE_A:
	  break;
	case IKE_ATTR_GROUP_CURVE_B:
	  break;
	case IKE_ATTR_LIFE_TYPE:
	  lifetype = decode_16 (value);
	  return 0;
	case IKE_ATTR_LIFE_DURATION:
	  switch (lifetype)
	    {
	    case IKE_DURATION_SECONDS:
	      switch (len)
		{
		case 2:
		  sa->seconds = decode_16 (value);
		  break;
		case 4:
		  sa->seconds = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
d1293 60
a1352 12
	      break;
	    case IKE_DURATION_KILOBYTES:
	      switch (len)
		{
		case 2:
		  sa->kilobytes = decode_16 (value);
		  break;
		case 4:
		  sa->kilobytes = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
d1354 3
a1356 82
	      break;
	    default:
	      log_print ("ipsec_decode_attribute: unknown lifetime type");
	    }
	  break;
	case IKE_ATTR_PRF:
	  break;
	case IKE_ATTR_KEY_LENGTH:
	  exchange->key_length = decode_16 (value) / 8;
	  break;
	case IKE_ATTR_FIELD_SIZE:
	  break;
	case IKE_ATTR_GROUP_ORDER:
	  break;
	}
    }
  else
    {
      switch (type)
	{
	case IPSEC_ATTR_SA_LIFE_TYPE:
	  lifetype = decode_16 (value);
	  return 0;
	case IPSEC_ATTR_SA_LIFE_DURATION:
	  switch (lifetype)
	    {
	    case IPSEC_DURATION_SECONDS:
	      switch (len)
		{
		case 2:
		  sa->seconds = decode_16 (value);
		  break;
		case 4:
		  sa->seconds = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
		}
	      break;
	    case IPSEC_DURATION_KILOBYTES:
	      switch (len)
		{
		case 2:
		  sa->kilobytes = decode_16 (value);
		  break;
		case 4:
		  sa->kilobytes = decode_32 (value);
		  break;
		default:
		  log_print ("ipsec_decode_attribute: unreasonable lifetime");
		}
	      break;
	    default:
	      log_print ("ipsec_decode_attribute: unknown lifetime type");
	    }
	  break;
	case IPSEC_ATTR_GROUP_DESCRIPTION:
	  isa->group_desc = decode_16 (value);
	  break;
	case IPSEC_ATTR_ENCAPSULATION_MODE:
	  /* XXX Multiple protocols must have same encapsulation mode, no?  */
	  iproto->encap_mode = decode_16 (value);
	  break;
	case IPSEC_ATTR_AUTHENTICATION_ALGORITHM:
	  iproto->auth = decode_16 (value);
	  break;
	case IPSEC_ATTR_KEY_LENGTH:
	  iproto->keylen = decode_16 (value);
	  break;
	case IPSEC_ATTR_KEY_ROUNDS:
	  iproto->keyrounds = decode_16 (value);
	  break;
	case IPSEC_ATTR_COMPRESS_DICTIONARY_SIZE:
	  break;
	case IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM:
	  break;
	case IPSEC_ATTR_ECN_TUNNEL:
	  break;
	}
    }
  lifetype = 0;
  return 0;
d1365 2
a1366 2
ipsec_decode_transform (struct message *msg, struct sa *sa,
			struct proto *proto, u_int8_t *buf)
d1368 2
a1369 2
  struct ipsec_exch *ie = msg->exchange->data;
  struct ipsec_decode_arg ida;
d1371 2
a1372 2
  LOG_DBG ((LOG_MISC, 20, "ipsec_decode_transform: transform %d chosen",
	    GET_ISAKMP_TRANSFORM_NO (buf)));
d1374 19
a1392 19
  ida.msg = msg;
  ida.sa = sa;
  ida.proto = proto;

  /* The default IKE lifetime is 8 hours.  */
  if (sa->phase == 1)
    sa->seconds = 28800;

  /* Extract the attributes and stuff them into the SA.  */
  attribute_map (buf + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 GET_ISAKMP_GEN_LENGTH (buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 ipsec_decode_attribute, &ida);

  /*
   * If no pseudo-random function was negotiated, it's HMAC.
   * XXX As PRF_HMAC currently is zero, this is a no-op.
   */
  if (!ie->prf_type)
    ie->prf_type = PRF_HMAC;
d1400 1
a1400 1
ipsec_delete_spi (struct sa *sa, struct proto *proto, int incoming)
d1402 4
a1405 4
  if (sa->phase == 1)
    return;
  /* XXX Error handling?  Is it interesting?  */
  sysdep_ipsec_delete_spi (sa, proto, incoming);
d1413 1
a1413 1
ipsec_g_x (struct message *msg, int peer, u_int8_t *buf)
d1415 16
a1430 17
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t **g_x;
  int initiator = exchange->initiator ^ peer;
  char header[32];

  g_x = initiator ? &ie->g_xi : &ie->g_xr;
  *g_x = malloc (ie->g_x_len);
  if (!*g_x)
    {
      log_error ("ipsec_g_x: malloc (%lu) failed", (unsigned long)ie->g_x_len);
      return -1;
    }
  memcpy (*g_x, buf, ie->g_x_len);
  snprintf (header, sizeof header, "ipsec_g_x: g^x%c", initiator ? 'i' : 'r');
  LOG_DBG_BUF ((LOG_MISC, 80, header, *g_x, ie->g_x_len));
  return 0;
d1435 1
a1435 1
ipsec_gen_g_x (struct message *msg)
d1437 21
a1457 26
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  u_int8_t *buf;

  buf = malloc (ISAKMP_KE_SZ + ie->g_x_len);
  if (!buf)
    {
      log_error ("ipsec_gen_g_x: malloc (%lu) failed",
		 ISAKMP_KE_SZ + (unsigned long)ie->g_x_len);
      return -1;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_KEY_EXCH, buf,
			   ISAKMP_KE_SZ + ie->g_x_len, 1))
    {
      free (buf);
      return -1;
    }

  if (dh_create_exchange (ie->group, buf + ISAKMP_KE_DATA_OFF))
    {
      log_print ("ipsec_gen_g_x: dh_create_exchange failed");
      free (buf);
      return -1;
    }
  return ipsec_g_x (msg, 0, buf + ISAKMP_KE_DATA_OFF);
d1462 1
a1462 1
ipsec_save_g_x (struct message *msg)
d1464 15
a1478 17
  struct exchange *exchange = msg->exchange;
  struct ipsec_exch *ie = exchange->data;
  struct payload *kep;

  kep = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_KEY_EXCH]);
  kep->flags |= PL_MARK;
  ie->g_x_len = GET_ISAKMP_GEN_LENGTH (kep->p) - ISAKMP_KE_DATA_OFF;

  /* Check that the given length matches the group's expectancy.  */
  if (ie->g_x_len != (size_t)dh_getlen (ie->group))
    {
      /* XXX Is this a good notify type?  */
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 0);
      return -1;
    }

  return ipsec_g_x (msg, 1, kep->p + ISAKMP_KE_DATA_OFF);
d1486 1
a1486 1
ipsec_get_spi (size_t *sz, u_int8_t proto, struct message *msg)
d1488 2
a1489 2
  struct sockaddr *dst, *src;
  struct transport *transport = msg->transport;
d1491 10
a1500 13
  if (msg->exchange->phase == 1)
    {
      *sz = 0;
      return 0;
    }
  else
    {
      /* We are the destination in the SA we want a SPI for.  */
      transport->vtbl->get_src (transport, &dst);
      /* The peer is the source.  */
      transport->vtbl->get_dst (transport, &src);
      return sysdep_ipsec_get_spi (sz, proto, src, dst, msg->exchange->seq);
    }
d1510 2
a1511 2
ipsec_handle_leftover_payload (struct message *msg, u_int8_t type,
			       struct payload *payload)
d1513 99
a1611 113
  u_int32_t spisz, nspis;
  struct sockaddr *dst;
  int reenter = 0;
  u_int8_t *spis, proto;
  struct sa *sa;

  switch (type)
    {
    case ISAKMP_PAYLOAD_DELETE:
      proto = GET_ISAKMP_DELETE_PROTO (payload->p);
      nspis = GET_ISAKMP_DELETE_NSPIS (payload->p);
      spisz = GET_ISAKMP_DELETE_SPI_SZ (payload->p);

      if (nspis == 0)
        {
	  LOG_DBG ((LOG_SA, 60, "ipsec_handle_leftover_payload: message "
		    "specified zero SPIs, ignoring"));
	  return -1;
	}

      /* verify proper SPI size */
      if ((proto == ISAKMP_PROTO_ISAKMP && spisz != ISAKMP_HDR_COOKIES_LEN)
          || (proto != ISAKMP_PROTO_ISAKMP && spisz != sizeof (u_int32_t)))
        {
	  log_print ("ipsec_handle_leftover_payload: "
		     "invalid SPI size %d for proto %d in DELETE payload",
		     spisz, proto);
	  return -1;
        }

      spis = (u_int8_t *)malloc (nspis * spisz);
      if (!spis)
        {
	  log_error ("ipsec_handle_leftover_payload: malloc (%d) failed",
		     nspis * spisz);
	  return -1;
	}

      /* extract SPI and get dst address */
      memcpy (spis, payload->p + ISAKMP_DELETE_SPI_OFF, nspis * spisz);
      msg->transport->vtbl->get_dst (msg->transport, &dst);

      ipsec_delete_spi_list (dst, proto, spis, nspis, "DELETE");

      free (spis);
      payload->flags |= PL_MARK;
      return 0;

    case ISAKMP_PAYLOAD_NOTIFY:
      switch (GET_ISAKMP_NOTIFY_MSG_TYPE (payload->p))
	{
	case IPSEC_NOTIFY_INITIAL_CONTACT:
	  /*
	   * Permit INITIAL-CONTACT if
	   *   - this is not an AGGRESSIVE mode exchange
	   *   - it is protected by an ISAKMP SA
	   *
	   * XXX Instead of the first condition above, we could permit this
	   * XXX only for phase 2. In the last packet of main-mode, this
	   * XXX payload, while encrypted, is not part of the hash digest.
	   * XXX As we currently send our own INITIAL-CONTACTs at this point,
	   * XXX this too would need to be changed.
	   */
	  if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE)
	    {	
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "in AGGRESSIVE mode");
	      return -1;
	    }

	  if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0)
	    {
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "without ISAKMP SA");
	      return -1;
	    }

	  /*
	   * Find out who is sending this and then delete every SA that is
	   * ready.  Exchanges will timeout themselves and then the
	   * non-ready SAs will disappear too.
	   */
	  msg->transport->vtbl->get_dst (msg->transport, &dst);
	  while ((sa = sa_lookup_by_peer (dst, sysdep_sa_len (dst))) != 0)
	    {
	      /*
	       * Don't delete the current SA -- we received the notification
	       * over it, so it's obviously still active. We temporarily need
               * to remove the SA from the list to avoid an endless loop,
	       * but keep a reference so it won't disappear meanwhile.
	       */
	      if (sa == msg->isakmp_sa)
	        {
		  sa_reference (sa);
                  sa_remove (sa);
                  reenter = 1;
		  continue;
		}

	      LOG_DBG ((LOG_SA, 30,
			"ipsec_handle_leftover_payload: "
			"INITIAL-CONTACT made us delete SA %p",
			sa));
	      sa_delete (sa, 0);
	    }

          if (reenter)
	    {
	      sa_enter (msg->isakmp_sa);
	      sa_release (msg->isakmp_sa);
	    }
	  payload->flags |= PL_MARK;
	  return 0;
d1613 1
a1613 2
    }
  return -1;
d1618 1
a1618 1
ipsec_esp_enckeylength (struct proto *proto)
d1620 1
a1620 1
  struct ipsec_proto *iproto = proto->data;
d1622 20
a1641 21
  /* Compute the keylength to use.  */
  switch (proto->id)
    {
    case IPSEC_ESP_DES:
    case IPSEC_ESP_DES_IV32:
    case IPSEC_ESP_DES_IV64:
      return 8;
    case IPSEC_ESP_3DES:
      return 24;
    case IPSEC_ESP_CAST:
      if (!iproto->keylen)
        return 16;
      return iproto->keylen / 8;
    case IPSEC_ESP_AES:
    case IPSEC_ESP_AES_128_CTR:
      if (!iproto->keylen)
	return 16;
      /* Fallthrough */
    default:
      return iproto->keylen / 8;
    }
d1646 1
a1646 1
ipsec_esp_authkeylength (struct proto *proto)
d1648 1
a1648 1
  struct ipsec_proto *iproto = proto->data;
d1650 15
a1664 16
  switch (iproto->auth)
    {
    case IPSEC_AUTH_HMAC_MD5:
      return 16;
    case IPSEC_AUTH_HMAC_SHA:
    case IPSEC_AUTH_HMAC_RIPEMD:
      return 20;
    case IPSEC_AUTH_HMAC_SHA2_256:
      return 32;
    case IPSEC_AUTH_HMAC_SHA2_384:
      return 48;
    case IPSEC_AUTH_HMAC_SHA2_512:
      return 64;
    default:
      return 0;
    }
d1669 1
a1669 1
ipsec_ah_keylength (struct proto *proto)
d1671 15
a1685 16
  switch (proto->id)
    {
    case IPSEC_AH_MD5:
      return 16;
    case IPSEC_AH_SHA:
    case IPSEC_AH_RIPEMD:
      return 20;
    case IPSEC_AH_SHA2_256:
      return 32;
    case IPSEC_AH_SHA2_384:
      return 48;
    case IPSEC_AH_SHA2_512:
      return 64;
    default:
      return -1;
    }
d1690 1
a1690 1
ipsec_keymat_length (struct proto *proto)
d1692 8
a1699 9
  switch (proto->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      return ipsec_esp_enckeylength (proto) + ipsec_esp_authkeylength (proto);
    case IPSEC_PROTO_IPSEC_AH:
      return ipsec_ah_keylength (proto);
    default:
      return -1;
    }
d1709 2
a1710 2
ipsec_get_id (char *section, int *id, struct sockaddr **addr,
	      struct sockaddr **mask, u_int8_t *tproto, u_int16_t *port)
d1712 1
a1712 1
  char *type, *address, *netmask;
d1714 24
a1737 31
  type = conf_get_str (section, "ID-type");
  if (!type)
    {
      log_print ("ipsec_get_id: section %s has no \"ID-type\" tag", section);
      return -1;
    }

  *id = constant_value (ipsec_id_cst, type);
  switch (*id)
    {
    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV6_ADDR:
      address = conf_get_str (section, "Address");
      if (!address)
	{
	  log_print ("ipsec_get_id: section %s has no \"Address\" tag",
		     section);
	  return -1;
	}

      if (text2sockaddr (address, NULL, addr))
	{
	  log_print ("ipsec_get_id: invalid address %s in section %s", address,
		     section);
	  return -1;
	}

      *tproto = conf_get_num (section, "Protocol", 0);
      if (*tproto)
	*port = conf_get_num (section, "Port", 0);
      break;
d1740 2
a1741 2
    case IPSEC_ID_FQDN:
      return -1;
d1743 2
a1744 2
    case IPSEC_ID_USER_FQDN:
      return -1;
d1747 28
a1774 36
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      address = conf_get_str (section, "Network");
      if (!address)
	{
	  log_print ("ipsec_get_id: section %s has no \"Network\" tag",
		     section);
	  return -1;
	}

      if (text2sockaddr (address, NULL, addr))
	{
	  log_print ("ipsec_get_id: invalid section %s network %s", section,
		     address);
	  return -1;
	}

      netmask = conf_get_str (section, "Netmask");
      if (!netmask)
	{
	  log_print ("ipsec_get_id: section %s has no \"Netmask\" tag",
		     section);
	  return -1;
	}

      if (text2sockaddr (netmask, NULL, mask))
	{
	  log_print ("ipsec_id_build: invalid section %s network %s", section,
		     netmask);
	  return -1;
	}

      *tproto = conf_get_num (section, "Protocol", 0);
      if (*tproto)
	*port = conf_get_num (section, "Port", 0);
      break;
d1777 2
a1778 2
    case IPSEC_ID_IPV4_RANGE:
      return -1;
d1780 2
a1781 2
    case IPSEC_ID_IPV6_RANGE:
      return -1;
d1783 2
a1784 2
    case IPSEC_ID_DER_ASN1_DN:
      return -1;
d1786 2
a1787 2
    case IPSEC_ID_DER_ASN1_GN:
      return -1;
d1789 2
a1790 2
    case IPSEC_ID_KEY_ID:
      return -1;
d1793 5
a1797 5
    default:
      log_print ("ipsec_get_id: unknown ID type \"%s\" in section %s", type,
		 section);
      return -1;
    }
d1799 1
a1799 1
  return 0;
d1807 2
a1808 2
ipsec_decode_id (char *buf, size_t size, u_int8_t *id, size_t id_len,
		 int isakmpform)
d1810 53
a1862 54
  int id_type;
  char *addr = 0, *mask = 0;
  u_int32_t *idp;

  if (id)
    {
      if (!isakmpform)
	{
	  /* Exchanges and SAs dont carry the IDs in ISAKMP form.  */
	  id -= ISAKMP_GEN_SZ;
	  id_len += ISAKMP_GEN_SZ;
	}

      id_type = GET_ISAKMP_ID_TYPE (id);
      idp = (u_int32_t *)(id + ISAKMP_ID_DATA_OFF);
      switch (id_type)
	{
	case IPSEC_ID_IPV4_ADDR:
	  util_ntoa (&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
	  snprintf (buf, size, "%08x: %s",
		    decode_32 (id + ISAKMP_ID_DATA_OFF), addr);
	  break;

	case IPSEC_ID_IPV4_ADDR_SUBNET:
	  util_ntoa (&addr, AF_INET, id + ISAKMP_ID_DATA_OFF);
	  util_ntoa (&mask, AF_INET, id + ISAKMP_ID_DATA_OFF + 4);
	  snprintf (buf, size, "%08x/%08x: %s/%s",
		    decode_32 (id + ISAKMP_ID_DATA_OFF),
		    decode_32 (id + ISAKMP_ID_DATA_OFF + 4), addr, mask);
	  break;

	case IPSEC_ID_IPV6_ADDR:
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
	  snprintf (buf, size, "%08x%08x%08x%08x: %s", *idp, *(idp + 1),
		    *(idp + 2), *(idp + 3), addr);
	  break;

	case IPSEC_ID_IPV6_ADDR_SUBNET:
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF +
		     sizeof (struct in6_addr));
	  snprintf (buf, size, "%08x%08x%08x%08x/%08x%08x%08x%08x: %s/%s",
		    *idp, *(idp + 1), *(idp + 2), *(idp + 3), *(idp + 4),
		    *(idp + 5), *(idp + 6), *(idp + 7), addr, mask);
	  break;

	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  /* String is not NUL terminated, be careful */
	  id_len -= ISAKMP_ID_DATA_OFF;
	  id_len = MIN (id_len, size - 1);
	  memcpy (buf, id + ISAKMP_ID_DATA_OFF, id_len);
	  buf[id_len] = '\0';
	  break;
d1865 9
a1873 10
	case IPSEC_ID_DER_ASN1_DN:
	  addr = x509_DN_string (id + ISAKMP_ID_DATA_OFF,
				 id_len - ISAKMP_ID_DATA_OFF);
	  if (!addr)
	    {
	      snprintf (buf, size, "unparsable ASN1 DN ID");
	      return;
	    }
	  strlcpy (buf, addr, size);
	  break;
d1876 15
a1890 16
	default:
	  snprintf (buf, size, "<id type unknown: %x>", id_type);
	  break;
	}
    }
  else
    snprintf (buf, size, "<no ipsec id>");
  if (addr)
    free (addr);
  if (mask)
    free (mask);
}

char *
ipsec_decode_ids (char *fmt, u_int8_t *id1, size_t id1_len,
		  u_int8_t *id2, size_t id2_len, int isakmpform)
d1892 2
a1893 2
  static char result[1024];
  char s_id1[256], s_id2[256];
d1895 2
a1896 2
  ipsec_decode_id (s_id1, sizeof s_id1, id1, id1_len, isakmpform);
  ipsec_decode_id (s_id2, sizeof s_id2, id2, id2_len, isakmpform);
d1898 2
a1899 2
  snprintf (result, sizeof result, fmt, s_id1, s_id2);
  return result;
d1907 2
a1908 2
u_int8_t *
ipsec_build_id (char *section, size_t *sz)
d1910 29
a1938 31
  struct sockaddr *addr, *mask;
  u_int8_t *p;
  int id, subnet = 0;
  u_int8_t tproto = 0;
  u_int16_t port = 0;

  if (ipsec_get_id (section, &id, &addr, &mask, &tproto, &port))
    return 0;

  if (id == IPSEC_ID_IPV4_ADDR_SUBNET || id == IPSEC_ID_IPV6_ADDR_SUBNET)
    subnet = 1;

  *sz = ISAKMP_ID_SZ + sockaddr_addrlen (addr);
  if (subnet)
    *sz += sockaddr_addrlen (mask);

  p = malloc (*sz);
  if (!p)
    {
      log_print ("ipsec_build_id: malloc(%lu) failed", (unsigned long)*sz);
      return 0;
    }

  SET_ISAKMP_ID_TYPE (p, id);
  SET_ISAKMP_ID_DOI_DATA (p, (unsigned char *)"\000\000\000");

  memcpy (p + ISAKMP_ID_DATA_OFF, sockaddr_addrdata (addr),
	  sockaddr_addrlen (addr));
  if (subnet)
    memcpy (p + ISAKMP_ID_DATA_OFF + sockaddr_addrlen (addr),
	    sockaddr_addrdata (mask), sockaddr_addrlen (mask));
d1940 2
a1941 2
  SET_IPSEC_ID_PROTO (p + ISAKMP_ID_DOI_DATA_OFF, tproto);
  SET_IPSEC_ID_PORT (p + ISAKMP_ID_DOI_DATA_OFF, port);
d1943 1
a1943 1
  return p;
d1950 1
a1950 1
ipsec_clone_id (u_int8_t **did, size_t *did_len, u_int8_t *id, size_t id_len)
d1952 2
a1953 2
  if (*did)
    free (*did);
d1955 13
a1967 14
  if (!id_len || !id)
    {
      *did = 0;
      *did_len = 0;
      return 0;
    }

  *did = malloc (id_len);
  if (!*did)
    {
      *did_len = 0;
      log_error ("ipsec_clone_id: malloc(%lu) failed", (unsigned long)id_len);
      return -1;
    }
d1969 1
a1969 4
  *did_len = id_len;
  memcpy (*did, id, id_len);

  return 0;
d1978 1
a1978 1
ipsec_proto_init (struct proto *proto, char *section)
d1980 1
a1980 1
  struct ipsec_proto *iproto = proto->data;
d1982 3
a1984 3
  if (proto->sa->phase == 2 && section)
    iproto->replay_window
      = conf_get_num (section, "ReplayWindow", DEFAULT_REPLAY_WINDOW);
d1992 1
a1992 1
ipsec_initial_contact (struct message *msg)
d1994 1
a1994 1
  u_int8_t *buf;
d1996 2
a1997 2
  if (ipsec_contacted (msg))
    return 0;
d1999 18
a2016 21
  buf = malloc (ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
  if (!buf)
    {
      log_error ("ike_phase_1_initial_contact: malloc (%d) failed",
		 ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN);
      return -1;
    }
  SET_ISAKMP_NOTIFY_DOI (buf, IPSEC_DOI_IPSEC);
  SET_ISAKMP_NOTIFY_PROTO (buf, ISAKMP_PROTO_ISAKMP);
  SET_ISAKMP_NOTIFY_SPI_SZ (buf, ISAKMP_HDR_COOKIES_LEN);
  SET_ISAKMP_NOTIFY_MSG_TYPE (buf, IPSEC_NOTIFY_INITIAL_CONTACT);
  memcpy (buf + ISAKMP_NOTIFY_SPI_OFF, msg->isakmp_sa->cookies,
	  ISAKMP_HDR_COOKIES_LEN);
  if (message_add_payload (msg, ISAKMP_PAYLOAD_NOTIFY, buf,
			   ISAKMP_NOTIFY_SZ + ISAKMP_HDR_COOKIES_LEN, 1))
    {
      free (buf);
      return -1;
    }

  return ipsec_add_contact (msg);
d2024 1
a2024 1
addr_cmp (const void *a, const void *b)
d2026 3
a2028 3
  const struct contact *x = a, *y = b;
  int minlen = MIN (x->len, y->len);
  int rv = memcmp (x->addr, y->addr, minlen);
d2030 1
a2030 1
  return rv ? rv : (x->len - y->len);
d2040 1
a2040 1
ipsec_add_contact (struct message *msg)
d2042 31
a2072 34
  struct contact *new_contacts;
  struct sockaddr *dst, *addr;
  int cnt;

  if (contact_cnt == contact_limit)
    {
      cnt = contact_limit ? 2 * contact_limit : 64;
      new_contacts = realloc (contacts, cnt * sizeof contacts[0]);
      if (!new_contacts)
	{
	  log_error ("ipsec_add_contact: realloc (%p, %lu) failed", contacts,
		     cnt * (unsigned long)sizeof contacts[0]);
	  return -1;
	}
      contact_limit = cnt;
      contacts = new_contacts;
    }
  msg->transport->vtbl->get_dst (msg->transport, &dst);
  addr = malloc (sysdep_sa_len (dst));
  if (!addr)
    {
      log_error ("ipsec_add_contact: malloc (%d) failed", sysdep_sa_len (dst));
      return -1;
    }
  memcpy (addr, dst, sysdep_sa_len (dst));
  contacts[contact_cnt].addr = addr;
  contacts[contact_cnt++].len = sysdep_sa_len (dst);

  /*
   * XXX There are better algorithms for already mostly-sorted data like
   * this, but only qsort is standard.  I will someday do this inline.
   */
  qsort (contacts, contact_cnt, sizeof *contacts, addr_cmp);
  return 0;
d2077 1
a2077 1
ipsec_contacted (struct message *msg)
d2079 1
a2079 1
  struct contact contact;
d2081 6
a2086 6
  msg->transport->vtbl->get_dst (msg->transport, &contact.addr);
  contact.len = sysdep_sa_len (contact.addr);
  return contacts
    ? (bsearch (&contact, contacts, contact_cnt, sizeof *contacts, addr_cmp)
       != 0)
    : 0;
d2090 2
a2091 2
u_int8_t *
ipsec_add_hash_payload (struct message *msg, size_t hashsize)
d2093 1
a2093 1
  u_int8_t *buf;
d2095 12
a2106 16
  buf = malloc (ISAKMP_HASH_SZ + hashsize);
  if (!buf)
    {
      log_error ("ipsec_add_hash_payload: malloc (%lu) failed",
		 ISAKMP_HASH_SZ + (unsigned long)hashsize);
      return 0;
    }

  if (message_add_payload (msg, ISAKMP_PAYLOAD_HASH, buf,
			   ISAKMP_HASH_SZ + hashsize, 1))
    {
      free (buf);
      return 0;
    }

  return buf;
d2111 1
a2111 1
ipsec_fill_in_hash (struct message *msg)
d2113 46
a2158 48
  struct exchange *exchange = msg->exchange;
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
  struct hash *hash = hash_get (isa->hash);
  struct prf *prf;
  struct payload *payload;
  u_int8_t *buf;
  u_int32_t i;
  char header[80];

  /* If no SKEYID_a, we need not do anything.  */
  if (!isa->skeyid_a)
    return 0;

  payload = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  if (!payload)
    {
      log_print ("ipsec_fill_in_hash: no HASH payload found");
      return -1;
    }
  buf = payload->p;

  /* Allocate the prf and start calculating our HASH(1).  */
  LOG_DBG_BUF ((LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_MISC, 90, "ipsec_fill_in_hash: message_id",
		exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);

  /* Loop over all payloads after HASH(1).  */
  for (i = 2; i < msg->iovlen; i++)
    {
      /* XXX Misleading payload type printouts.  */
      snprintf (header, sizeof header,
		"ipsec_fill_in_hash: payload %d after HASH(1)",	i - 1);
      LOG_DBG_BUF ((LOG_MISC, 90, header, msg->iov[i].iov_base,
		    msg->iov[i].iov_len));
      prf->Update (prf->prfctx, msg->iov[i].iov_base, msg->iov[i].iov_len);
    }
  prf->Final (buf + ISAKMP_HASH_DATA_OFF, prf->prfctx);
  prf_free (prf);
  LOG_DBG_BUF ((LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)",
		buf + ISAKMP_HASH_DATA_OFF, hash->hashsize));
d2160 1
a2160 1
  return 0;
d2165 1
a2165 1
ipsec_informational_pre_hook (struct message *msg)
d2167 9
a2175 9
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct hash *hash;

  if (!isakmp_sa)
    return 0;
  isa = isakmp_sa->data;
  hash = hash_get (isa->hash);
  return ipsec_add_hash_payload (msg, hash->hashsize) == 0;
d2182 1
a2182 1
ipsec_informational_post_hook (struct message *msg)
d2184 3
a2186 3
  if (!msg->isakmp_sa)
    return 0;
  return ipsec_fill_in_hash (msg);
d2190 1
a2190 1
ipsec_id_size (char *section, u_int8_t *id)
d2192 1
a2192 1
  char *type, *data;
d2194 30
a2223 34
  type = conf_get_str (section, "ID-type");
  if (!type)
    {
      log_print ("ipsec_id_size: section %s has no \"ID-type\" tag", section);
      return -1;
    }

  *id = constant_value (ipsec_id_cst, type);
  switch (*id)
    {
    case IPSEC_ID_IPV4_ADDR:
      return sizeof (struct in_addr);
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      return 2 * sizeof (struct in_addr);
    case IPSEC_ID_IPV6_ADDR:
      return sizeof (struct in6_addr);
    case IPSEC_ID_IPV6_ADDR_SUBNET:
      return 2 * sizeof (struct in6_addr);
    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
    case IPSEC_ID_KEY_ID:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
      data = conf_get_str (section, "Name");
      if (!data)
	{
	  log_print ("ipsec_id_size: section %s has no \"Name\" tag", section);
	  return -1;
	}
      return strlen (data);
    }
  log_print ("ipsec_id_size: unrecognized/unsupported ID-type %d (%s)",
	     *id, type);
  return -1;
d2229 2
a2230 2
char *
ipsec_id_string (u_int8_t *id, size_t id_len)
d2232 55
a2286 56
  char *buf = 0;
  char *addrstr = 0;
  size_t len, size;

  /*
   * XXX Real ugly way of making the offsets correct.  Be aware that id now
   * will point before the actual buffer and cannot be dereferenced without
   * an offset larger than or equal to ISAKM_GEN_SZ.
   */
  id -= ISAKMP_GEN_SZ;

  /* This is the actual length of the ID data field.  */
  id_len += ISAKMP_GEN_SZ - ISAKMP_ID_DATA_OFF;

  /*
   * Conservative allocation.
   * XXX I think the ASN1 DN case can be thought through to give a better
   * estimate.
   */
  size = MAX (sizeof "ipv6/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
	      sizeof "asn1_dn/" + id_len - ISAKMP_ID_DATA_OFF);
  buf = malloc (size);
  if (!buf)
    /* XXX Log?  */
    goto fail;

  switch (GET_ISAKMP_ID_TYPE (id))
    {
    case IPSEC_ID_IPV4_ADDR:
      if (id_len < sizeof (struct in_addr))
	goto fail;
      util_ntoa (&addrstr, AF_INET, id + ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	goto fail;
      snprintf (buf, size, "ipv4/%s", addrstr);
      break;

    case IPSEC_ID_IPV6_ADDR:
      if (id_len < sizeof (struct in6_addr))
	goto fail;
      util_ntoa (&addrstr, AF_INET6, id + ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	goto fail;
      snprintf (buf, size, "ipv6/%s", addrstr);
      break;

    case IPSEC_ID_FQDN:
    case IPSEC_ID_USER_FQDN:
      strlcpy (buf,
	       GET_ISAKMP_ID_TYPE (id) == IPSEC_ID_FQDN ? "fqdn/" : "ufqdn/",
	       size);
      len = strlen (buf);

      memcpy (buf + len, id + ISAKMP_ID_DATA_OFF, id_len);
      *(buf + len + id_len) = '\0';
      break;
d2289 30
a2318 30
    case IPSEC_ID_DER_ASN1_DN:
      strlcpy (buf, "asn1_dn/", size);
      len = strlen (buf);
      addrstr = x509_DN_string (id + ISAKMP_ID_DATA_OFF,
				id_len - ISAKMP_ID_DATA_OFF);
      if (!addrstr)
	goto fail;
      if (size < len + strlen (addrstr) + 1)
	goto fail;
      strlcpy (buf + len, addrstr, size - len);
      break;
#endif

    default:
      /* Unknown type.  */
      LOG_DBG ((LOG_MISC, 10, "ipsec_id_string: unknown identity type %d\n",
		GET_ISAKMP_ID_TYPE (id)));
      goto fail;
    }

  if (addrstr)
    free (addrstr);
  return buf;

 fail:
  if (buf)
    free (buf);
  if (addrstr)
    free (addrstr);
  return 0;
@


1.87
log
@Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.  Testing by markus@@ cloder@@ hshoexer@@.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.86 2004/02/27 19:14:57 hshoexer Exp $	*/
d1508 1
a1508 1
  if (ie->g_x_len != dh_getlen (ie->group))
d1881 1
a1881 1
ipsec_decode_id (char *buf, int size, u_int8_t *id, size_t id_len,
d2213 1
a2213 1
  int i;
@


1.87.2.1
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.87 2004/03/10 23:08:48 hshoexer Exp $	*/
d1049 1
a1049 10
	  switch (type)
	    {
	    case IPSEC_NOTIFY_INITIAL_CONTACT:
	      /* Handled by leftover logic. */
	      break;

	    default:
	      p->flags |= PL_MARK;
	      break;
	    }
a1626 7
	      return -1;
	    }

	  if ((msg->flags & MSG_AUTHENTICATED) == 0)
	    {
	      log_print("ipsec_handle_leftover_payload: got unauthenticated "
			"INITIAL-CONTACT");
@


1.86
log
@Remove dead code.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.85 2004/01/03 16:38:13 ho Exp $	*/
d125 1
a125 1
static int ipsec_validate_situation (u_int8_t *, size_t *);
d854 1
a854 1
ipsec_validate_situation (u_int8_t *buf, size_t *sz)
d856 1
a856 4
  int sit = GET_IPSEC_SIT_SIT (buf);
  int off;

  if (sit & (IPSEC_SIT_SECRECY | IPSEC_SIT_INTEGRITY))
d858 3
a860 10
      /*
       * XXX All the roundups below, round up to 32 bit boundaries given
       * that the situation field is aligned.  This is not necessarily so,
       * but I interpret the drafts as this is like this they want it.
       */
      off = ROUNDUP_32 (GET_IPSEC_SIT_SECRECY_LENGTH (buf));
      off += ROUNDUP_32 (GET_IPSEC_SIT_SECRECY_CAT_LENGTH (buf + off));
      off += ROUNDUP_32 (GET_IPSEC_SIT_INTEGRITY_LENGTH (buf + off));
      off += ROUNDUP_32 (GET_IPSEC_SIT_INTEGRITY_CAT_LENGTH (buf + off));
      *sz = off + IPSEC_SIT_SZ;
a861 2
  else
    *sz = IPSEC_SIT_SIT_LEN;
d864 6
a869 6
#ifdef notdef
  return
    sit & ~(IPSEC_SIT_IDENTITY_ONLY | IPSEC_SIT_SECRECY | IPSEC_SIT_INTEGRITY);
#else
  return sit & ~IPSEC_SIT_IDENTITY_ONLY;
#endif
@


1.85
log
@Be more careful with INITIAL-CONTACT and do not delete SPIs when getting
an INVALID-SPI notification. Issues noted by Thomas Walpuski. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.84 2003/12/15 10:06:42 hshoexer Exp $	*/
d880 1
a880 1
   return sit & ~IPSEC_SIT_IDENTITY_ONLY;
a881 2
    return 1;
  return 0;
@


1.84
log
@Support for groups modp2048, modp3072, modp4096, modp6144 and modp8192 (IDs 14
to 18).

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.83 2003/11/06 16:12:07 ho Exp $	*/
a1013 37
/*
 * deal with a NOTIFY of INVALID_SPI
 */
static void
ipsec_invalid_spi (struct message *msg, struct payload *p)
{
  struct sockaddr *dst;
  int invspisz, off;
  u_int32_t spi;
  u_int16_t totsiz;
  u_int8_t spisz;

  /*
   * get the invalid spi out of the variable sized notification data
   * field, which is after the variable sized SPI field [which specifies
   * the receiving entity's phase-1 SPI, not the invalid spi]
   */
  totsiz = GET_ISAKMP_GEN_LENGTH (p->p);
  spisz = GET_ISAKMP_NOTIFY_SPI_SZ (p->p);
  off = ISAKMP_NOTIFY_SPI_OFF + spisz;
  invspisz = totsiz - off;

  if (invspisz != sizeof spi)
    {
      LOG_DBG ((LOG_SA, 40,
	       "ipsec_invalid_spi: SPI size %d in INVALID_SPI "
	       "payload unsupported", spisz));
       return;
    }
  memcpy (&spi, p->p + off, sizeof spi);

  msg->transport->vtbl->get_dst (msg->transport, &dst);

  /* delete matching SPI's from this peer */
  ipsec_delete_spi_list (dst, 0, (u_int8_t *)&spi, 1, "INVALID_SPI");
}

a1062 3
	  if (type == ISAKMP_NOTIFY_INVALID_SPI)
	    ipsec_invalid_spi (msg, p);

d1619 25
@


1.83
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.82 2003/11/06 15:50:53 ho Exp $	*/
d1177 4
a1180 2
	  return decode_16 (value) < IKE_GROUP_DESC_MODP_768
	    || decode_16 (value) > IKE_GROUP_DESC_MODP_1536;
d1222 4
a1225 2
	  return decode_16 (value) < IKE_GROUP_DESC_MODP_768
	    || decode_16 (value) > IKE_GROUP_DESC_MODP_1536;
@


1.82
log
@spis[] type tweak. From Hans-Joerg Hoexer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.81 2003/10/14 14:29:15 ho Exp $	*/
d1959 1
a1959 1
	  id_len = MIN(id_len, size - 1);
d1970 1
a1970 1
	      snprintf(buf, size, "unparsable ASN1 DN ID");
d2407 1
a2407 1
      len = strlen(buf);
d2416 1
a2416 1
      len = strlen(buf);
@


1.81
log
@constant_lookup() to constant_name() cleanup. markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.80 2003/09/02 18:15:55 ho Exp $	*/
d1001 1
a1001 1
		   spis[i], proto));
@


1.80
log
@A couple of nits. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.79 2003/08/08 08:46:59 ho Exp $	*/
a416 1
  char *v;
a469 1
      v = constant_lookup (ipsec_id_cst, id);
d471 1
a471 1
		 id, v ? v : "<unknown>");
a1056 1
  char *tag;
a1095 1
	  tag = constant_lookup (isakmp_notify_cst, type);
d1098 1
a1098 1
		    tag ? tag : "<unknown>"));
@


1.80.2.1
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.80 2003/09/02 18:15:55 ho Exp $	*/
d1016 37
d1104 3
a1658 25
	  /*
	   * Permit INITIAL-CONTACT if
	   *   - this is not an AGGRESSIVE mode exchange
	   *   - it is protected by an ISAKMP SA
	   *
	   * XXX Instead of the first condition above, we could permit this
	   * XXX only for phase 2. In the last packet of main-mode, this
	   * XXX payload, while encrypted, is not part of the hash digest.
	   * XXX As we currently send our own INITIAL-CONTACTs at this point,
	   * XXX this too would need to be changed.
	   */
	  if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE)
	    {	
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "in AGGRESSIVE mode");
	      return -1;
	    }

	  if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0)
	    {
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "without ISAKMP SA");
	      return -1;
	    }

@


1.80.2.2
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.80.2.1 2004/01/13 22:50:07 brad Exp $	*/
d125 1
a125 1
static int ipsec_validate_situation (u_int8_t *, size_t *, size_t);
d856 1
a856 1
ipsec_validate_situation (u_int8_t *buf, size_t *sz, size_t len)
d858 15
a872 5
  if (len < IPSEC_SIT_SIT_OFF + IPSEC_SIT_SIT_LEN)
    { 
      log_print ("ipsec_validate_situation: payload too short: %u",
                 (unsigned int)len);
      return -1;
d874 2
d878 6
a883 1
  if (GET_IPSEC_SIT_SIT (buf) != IPSEC_SIT_IDENTITY_ONLY)
a884 3

  *sz = IPSEC_SIT_SIT_LEN;

@


1.80.2.3
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.80.2.2 2004/03/17 14:59:17 brad Exp $	*/
d1053 1
a1053 10
	  switch (type)
	    {
	    case IPSEC_NOTIFY_INITIAL_CONTACT:
	      /* Handled by leftover logic. */
	      break;

	    default:
	      p->flags |= PL_MARK;
	      break;
	    }
a1626 7
	      return -1;
	    }

	  if ((msg->flags & MSG_AUTHENTICATED) == 0)
	    {
	      log_print("ipsec_handle_leftover_payload: got unauthenticated "
			"INITIAL-CONTACT");
@


1.79
log
@Be more careful when using constant_lookup() in messages. Pointed out by
Jean-Francois Dive, although I opted for a slightly different patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.78 2003/07/25 08:31:16 markus Exp $	*/
d783 1
a783 1
  LOG_DBG ((LOG_MESSAGE, 0,
@


1.78
log
@add sha2 support; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.77 2003/06/10 12:21:29 ho Exp $	*/
d1059 1
d1098 2
a1099 1
          type = GET_ISAKMP_NOTIFY_MSG_TYPE (p->p);
d1102 1
a1102 1
		    constant_lookup (isakmp_notify_cst, type)));
d1104 2
a1105 2
          if (type == ISAKMP_NOTIFY_INVALID_SPI)
              ipsec_invalid_spi (msg, p);
@


1.77
log
@Do not crash on unsupported IPSec ID types, as noted by Eric Boudrand.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.76 2003/06/04 07:31:16 ho Exp $	*/
d1229 1
a1229 1
	    || decode_16 (value) > IPSEC_AUTH_KPDK;
d1740 6
d1762 6
@


1.76
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.75 2003/06/03 12:51:39 ho Exp $	*/
d334 1
a334 1
		      log_error ("ipsec_finalize_exchange: "
d344 1
a344 1
		      log_error ("ipsec_finalize_exchange: "
d417 1
d428 1
a428 1
	return -1;
d437 1
a437 1
	return -1;
d449 1
a449 1
	return -1;
d458 1
a458 1
	return -1;
d464 11
d509 1
a509 1
	return -1;
d518 1
a518 1
	return -1;
d530 1
a530 1
	return -1;
d539 1
a539 1
	return -1;
d572 4
@


1.75
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.74 2003/05/14 17:37:22 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.74
log
@I did not test this enough. Unbreak.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.73 2003/05/12 21:43:21 ho Exp $	*/
d1250 1
a1250 1
    snprintf (val, 20, "%d", decode_16 (value));
d1252 1
a1252 1
    snprintf (val, 20, "%d", decode_32 (value));
d1254 1
a1254 1
    snprintf (val, 20, "unrepresentable");
d1499 1
a1499 1
  snprintf (header, 32, "ipsec_g_x: g^x%c", initiator ? 'i' : 'r');
d2248 2
a2249 2
      snprintf (header, 80, "ipsec_fill_in_hash: payload %d after HASH(1)",
		i - 1);
@


1.73
log
@AES -> AES_128_CBC
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.72 2002/11/21 12:09:20 ho Exp $	*/
d1706 1
a1706 1
    case IPSEC_ESP_AES_128_CBC:
@


1.72
log
@-Wshadow nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.71 2002/09/11 09:50:43 ho Exp $	*/
d894 2
a895 1
	|| (transform_id > IPSEC_ESP_AES && transform_id < IPSEC_ESP_AES_MARS)
d1706 2
a1707 1
    case IPSEC_ESP_AES:
@


1.72.2.1
log
@MFC:
Fix from ho@@

Do not crash on unsupported IPSec ID types, as noted by Eric Boudrand.

deraadt@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.72 2002/11/21 12:09:20 ho Exp $	*/
d339 1
a339 1
		      log_print ("ipsec_finalize_exchange: "
d349 1
a349 1
		      log_print ("ipsec_finalize_exchange: "
a421 1
  char *v;
d432 1
a432 1
	goto memfail;
d441 1
a441 1
	goto memfail;
d453 1
a453 1
	goto memfail;
d462 1
a462 1
	goto memfail;
a467 11

    case IPSEC_ID_IPV4_RANGE:
    case IPSEC_ID_IPV6_RANGE:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
    case IPSEC_ID_KEY_ID:
    default:
      v = constant_lookup (ipsec_id_cst, id);
      log_print ("ipsec_set_network: ID type %d (%s) not supported",
		 id, v ? v : "<unknown>");
      return -1;
d502 1
a502 1
	goto memfail;
d511 1
a511 1
	goto memfail;
d523 1
a523 1
	goto memfail;
d532 1
a532 1
	goto memfail;
a564 4

 memfail:
  log_error ("ipsec_set_network: calloc () failed");
  return -1;
@


1.72.2.2
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.72.2.1 2003/06/13 03:50:53 brad Exp $	*/
d1020 37
d1106 3
a1660 25
	  /*
	   * Permit INITIAL-CONTACT if
	   *   - this is not an AGGRESSIVE mode exchange
	   *   - it is protected by an ISAKMP SA
	   *
	   * XXX Instead of the first condition above, we could permit this
	   * XXX only for phase 2. In the last packet of main-mode, this
	   * XXX payload, while encrypted, is not part of the hash digest.
	   * XXX As we currently send our own INITIAL-CONTACTs at this point,
	   * XXX this too would need to be changed.
	   */
	  if (msg->exchange->type == ISAKMP_EXCH_AGGRESSIVE)
	    {	
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "in AGGRESSIVE mode");
	      return -1;
	    }

	  if ((msg->exchange->flags & EXCHANGE_FLAG_ENCRYPT) == 0)
	    {
	      log_print ("ipsec_handle_leftover_payload: got INITIAL-CONTACT "
			 "without ISAKMP SA");
	      return -1;
	    }

@


1.72.2.3
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.72.2.2 2004/01/16 00:00:21 brad Exp $	*/
d130 1
a130 1
static int ipsec_validate_situation (u_int8_t *, size_t *, size_t);
d861 1
a861 1
ipsec_validate_situation (u_int8_t *buf, size_t *sz, size_t len)
d863 15
a877 5
  if (len < IPSEC_SIT_SIT_OFF + IPSEC_SIT_SIT_LEN)
    { 
      log_print ("ipsec_validate_situation: payload too short: %u",
                 (unsigned int)len);
      return -1;
d879 2
d883 6
a888 1
  if (GET_IPSEC_SIT_SIT (buf) != IPSEC_SIT_IDENTITY_ONLY)
a889 3

  *sz = IPSEC_SIT_SIT_LEN;

@


1.71
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.70 2002/09/08 12:38:04 ho Exp $	*/
d906 1
a906 1
  int (**script) (struct message *msg) = 0;
d1045 1
a1045 1
  int (**script) (struct message *msg) = 0;
@


1.71.2.1
log
@MFC:
Fix from ho@@

Do not crash on unsupported IPSec ID types, as noted by Eric Boudrand.

deraadt@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.71 2002/09/11 09:50:43 ho Exp $	*/
d339 1
a339 1
		      log_print ("ipsec_finalize_exchange: "
d349 1
a349 1
		      log_print ("ipsec_finalize_exchange: "
a421 1
  char *v;
d432 1
a432 1
	goto memfail;
d441 1
a441 1
	goto memfail;
d453 1
a453 1
	goto memfail;
d462 1
a462 1
	goto memfail;
a467 11

    case IPSEC_ID_IPV4_RANGE:
    case IPSEC_ID_IPV6_RANGE:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
    case IPSEC_ID_KEY_ID:
    default:
      v = constant_lookup (ipsec_id_cst, id);
      log_print ("ipsec_set_network: ID type %d (%s) not supported",
		 id, v ? v : "<unknown>");
      return -1;
d502 1
a502 1
	goto memfail;
d511 1
a511 1
	goto memfail;
d523 1
a523 1
	goto memfail;
d532 1
a532 1
	goto memfail;
a564 4

 memfail:
  log_error ("ipsec_set_network: calloc () failed");
  return -1;
@


1.70
log
@Fix -pedantic errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.69 2002/07/05 11:08:13 ho Exp $	*/
d105 1
a105 1
static u_int16_t *ipsec_exchange_script (u_int8_t);
d646 1
a646 1
static u_int16_t *
d1883 1
a1883 1
ipsec_decode_id (u_int8_t *buf, int size, u_int8_t *id, size_t id_len,
d2013 1
a2013 1
  SET_ISAKMP_ID_DOI_DATA (p, "\000\000\000");
@


1.69
log
@gcc 3.1 nits. Pointed out by David Krause.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.68 2002/06/14 12:43:11 ho Exp $	*/
d239 5
a243 1
  struct dst_spi_proto_arg arg = { dst, spi, proto };
@


1.68
log
@Recognize the ECN_TUNNEL attribute.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.67 2002/06/09 08:13:06 todd Exp $	*/
d380 2
a381 2
			addr1 ? addr1 : "<???>" , mask1 ? mask1 : "<???>",
			addr2 ? addr2 : "<???>" , mask2 ? mask2 : "<???>",
@


1.67
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.66 2002/06/07 04:56:13 ho Exp $	*/
d332 1
a332 1
		/* Initiator is source, responder is destination.  */
d750 1
a750 1
	      || type > IPSEC_ATTR_COMPRESS_PRIVATE_ALGORITHM)))
d1223 2
d1415 2
@


1.66
log
@This should solve PR#2729.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.65 2002/06/01 07:44:21 deraadt Exp $	*/
d214 1
a214 1
  if (memcmp (sockaddr_addrdata (dst), sockaddr_addrdata (arg->dst), 
d220 1
a220 1
      if (memcmp (sockaddr_addrdata (src), sockaddr_addrdata (arg->dst), 
d259 1
a259 1
  if (isa->tproto != isa2->tproto || isa->sport != isa2->sport 
d273 1
a273 1
    && memcmp (sockaddr_addrdata (isa->dst_mask), 
d376 1
a376 1
		  
d425 1
a425 1
      isa->src_net = 
d434 1
a434 1
      isa->src_mask = 
d446 1
a446 1
      isa->src_net = 
d455 1
a455 1
      isa->src_mask = 
d475 1
a475 1
      memset (sockaddr_addrdata (isa->src_mask), 0xff, 
d495 1
a495 1
      isa->dst_net = 
d504 1
a504 1
      isa->dst_mask = 
d516 1
a516 1
      isa->dst_net = 
d525 1
a525 1
      isa->dst_mask = 
d545 1
a545 1
      memset (sockaddr_addrdata (isa->dst_mask), 0xff, 
d957 1
a957 1
ipsec_delete_spi_list (struct sockaddr *addr, u_int8_t proto, 
d963 1
a963 1
  for (i = 0; i < nspis; i++) 
d969 1
a969 1
          /* 
d975 1
a975 1
        } 
d1012 1
a1012 1
  /* 
d1917 1
a1917 1
	  util_ntoa (&addr, AF_INET6, id + ISAKMP_ID_DATA_OFF + 
d2010 1
a2010 1
    memcpy (p + ISAKMP_ID_DATA_OFF + sockaddr_addrlen (addr), 
@


1.65
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.64 2002/02/21 20:09:18 angelos Exp $	*/
a327 16
	      for (proto = TAILQ_FIRST (&sa->protos), last_proto = 0; proto;
		   proto = TAILQ_NEXT (proto, link))
		{
		  if (sysdep_ipsec_set_spi (sa, proto, 0, isakmp_sa)
		      || (last_proto
			  && sysdep_ipsec_group_spis (sa, last_proto, proto,
						      0))
		      || sysdep_ipsec_set_spi (sa, proto, 1, isakmp_sa)
		      || (last_proto
			  && sysdep_ipsec_group_spis (sa, last_proto, proto,
						      1)))
		    /* XXX Tear down this exchange.  */
		    return;
		  last_proto = proto;
		}

d349 16
@


1.64
log
@Set the source port correctly, shifflett@@nps.navy.mil
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.63 2002/01/27 01:56:31 ho Exp $	*/
d679 2
a680 1
	  log_error ("ipsec_get_keystate: malloc (%d) failed", sizeof *ks);
d1486 1
a1486 1
      log_error ("ipsec_g_x: malloc (%d) failed", ie->g_x_len);
d1506 2
a1507 2
      log_error ("ipsec_gen_g_x: malloc (%d) failed",
		 ISAKMP_KE_SZ + ie->g_x_len);
d2000 1
a2000 1
      log_print ("ipsec_build_id: malloc(%d) failed", *sz);
d2039 1
a2039 1
      log_error ("ipsec_clone_id: malloc(%d) failed", id_len);
d2132 2
a2133 2
	  log_error ("ipsec_add_contact: realloc (%p, %d) failed", contacts,
		     cnt * sizeof contacts[0]);
d2181 2
a2182 2
      log_error ("ipsec_add_hash_payload: malloc (%d) failed",
		 ISAKMP_HASH_SZ + hashsize);
@


1.63
log
@Add the (former) AES candidate ESP ciphers for IKE, as of
http://csrc.nist.gov/ipsec/papers/aes-draft.00.txt
In particular, recognize a Twofish proposal with cipher number 253, as used
by the SSH Sentinel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.62 2002/01/23 17:12:36 ho Exp $	*/
d382 1
a382 1
			ntohs (isa->tproto), isa->sport, ntohs (isa->dport)));
d486 1
a486 3
  memcpy (&isa->tproto, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	  IPSEC_ID_PROTO_LEN);
  memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
@


1.62
log
@less sprintf/str[n]cpy/strcat
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.61 2001/12/16 22:39:09 deraadt Exp $	*/
d891 2
a892 1
	|| transform_id > IPSEC_ESP_AES ? -1 : 0;
@


1.61
log
@diagnostic incorrect; vlada@@openbsd.cz
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.60 2001/10/26 13:29:26 ho Exp $	*/
d1243 1
a1243 1
    sprintf (val, "%d", decode_16 (value));
d1245 1
a1245 1
    sprintf (val, "%d", decode_32 (value));
d1247 1
a1247 1
    sprintf (val, "unrepresentable");
d1942 1
a1942 2
	  strncpy (buf, addr, size - 1);
	  buf[size - 1] = '\0';
d2359 1
a2359 1
      sprintf (buf, "ipv4/%s", addrstr);
d2368 1
a2368 1
      sprintf (buf, "ipv6/%s", addrstr);
d2373 3
a2375 2
      strcpy (buf,
	      GET_ISAKMP_ID_TYPE (id) == IPSEC_ID_FQDN ? "fqdn/" : "ufqdn/");
d2384 1
a2384 1
      strcpy (buf, "asn1_dn/");
d2392 1
a2392 1
      strcpy (buf + len, addrstr);
@


1.60
log
@Change to use sysdep_sa_len() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.59 2001/10/26 12:03:07 ho Exp $	*/
d1789 2
a1790 2
	  log_print ("ipsec_get_id: invalid address %s in section %s", section,
		     address);
@


1.59
log
@Just rename sockaddr_data/len functions to sockaddr_addrdata/addrlen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.58 2001/08/25 22:22:11 niklas Exp $	*/
d430 1
d432 1
d439 1
d441 1
d451 1
d453 1
d460 1
d462 1
d502 1
d504 1
d511 1
d513 1
d523 1
d525 1
d532 1
d534 1
d1643 1
a1643 1
	  while ((sa = sa_lookup_by_peer (dst, dst->sa_len)) != 0)
d2141 1
a2141 1
  addr = malloc (dst->sa_len);
d2144 1
a2144 1
      log_error ("ipsec_add_contact: malloc (%d) failed", dst->sa_len);
d2147 1
a2147 1
  memcpy (addr, dst, dst->sa_len);
d2149 1
a2149 1
  contacts[contact_cnt++].len = dst->sa_len;
d2166 1
a2166 1
  contact.len = contact.addr->sa_len;
@


1.58
log
@Use x509_DN_string API.  Style fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.57 2001/08/24 09:29:14 ho Exp $	*/
d214 2
a215 2
  if (memcmp (sockaddr_data (dst), sockaddr_data (arg->dst), 
	      sockaddr_len (dst)) == 0)
d220 2
a221 2
      if (memcmp (sockaddr_data (src), sockaddr_data (arg->dst), 
		  sockaddr_len (src)) == 0)
d264 12
a275 8
    && memcmp (sockaddr_data (isa->src_net), sockaddr_data (isa2->src_net),
		 sockaddr_len (isa->src_net)) == 0
    && memcmp (sockaddr_data (isa->src_mask), sockaddr_data (isa2->src_mask),
	       sockaddr_len (isa->src_mask)) == 0
    && memcmp (sockaddr_data (isa->dst_net), sockaddr_data (isa2->dst_net),
	       sockaddr_len (isa->dst_net)) == 0
    && memcmp (sockaddr_data (isa->dst_mask), sockaddr_data (isa2->dst_mask),
	       sockaddr_len (isa->dst_mask)) == 0;
d459 2
a460 2
  memcpy (sockaddr_data (isa->src_net), src_id + ISAKMP_ID_DATA_OFF,
	  sockaddr_len (isa->src_net));
d467 2
a468 2
      memset (sockaddr_data (isa->src_mask), 0xff, 
	      sockaddr_len (isa->src_mask));
d472 3
a474 2
      memcpy (sockaddr_data (isa->src_mask), src_id + ISAKMP_ID_DATA_OFF +
	      sockaddr_len (isa->src_net), sockaddr_len (isa->src_mask));
d523 2
a524 2
  memcpy (sockaddr_data (isa->dst_net), dst_id + ISAKMP_ID_DATA_OFF,
	  sockaddr_len (isa->dst_net));
d531 2
a532 2
      memset (sockaddr_data (isa->dst_mask), 0xff, 
	      sockaddr_len (isa->dst_mask));
d536 3
a538 2
      memcpy (sockaddr_data (isa->dst_mask), dst_id + ISAKMP_ID_DATA_OFF +
	      sockaddr_len (isa->dst_net), sockaddr_len (isa->dst_mask));
d1978 1
a1978 1
  *sz = ISAKMP_ID_SZ + sockaddr_len (addr);
d1980 1
a1980 1
    *sz += sockaddr_len (mask);
d1992 2
a1993 1
  memcpy (p + ISAKMP_ID_DATA_OFF, sockaddr_data (addr), sockaddr_len (addr));
d1995 2
a1996 2
    memcpy (p + ISAKMP_ID_DATA_OFF + sockaddr_len (addr), 
	    sockaddr_data (mask), sockaddr_len (mask));
@


1.58.2.1
log
@Pull in patch from current:
Fix (ho):
Add the (former) AES candidate ESP ciphers for IKE, as of
http://csrc.nist.gov/ipsec/papers/aes-draft.00.txt
In particular, recognize a Twofish proposal with cipher number 253, as
used by the SSH Sentinel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.58 2001/08/25 22:22:11 niklas Exp $	*/
d869 1
a869 2
	|| (transform_id > IPSEC_ESP_AES && transform_id < IPSEC_ESP_AES_MARS)
	|| transform_id > IPSEC_ESP_AES_TWOFISH ? -1 : 0;
@


1.57
log
@typo in debug msg
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.56 2001/08/23 19:32:46 niklas Exp $	*/
d75 1
d1848 4
d1864 3
a1866 3
	  /* exchanges and SAs dont carry the IDs in ISAKMP form */
	  id -= ISAKMP_ID_TYPE_OFF;
	  id_len += ISAKMP_ID_TYPE_OFF;
d1878 1
d1886 1
d1892 1
d1910 15
d2305 1
a2305 1
  size_t len;
d2317 8
a2324 3
  /* Conservative allocation.  */
  buf = malloc (MAX (sizeof "ipv6/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
		     sizeof "ufqdn/" + id_len - ISAKMP_ID_DATA_OFF));
d2358 14
@


1.56
log
@Correct ipsec_id_string buffer and length handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.55 2001/08/22 08:49:00 niklas Exp $	*/
d2333 1
a2333 1
      LOG_DBG ((LOG_MISC, 10, "id_string: unknown identity type %d\n",
@


1.55
log
@Add ipsec_id_string, a function for converting IDs to on epossible
string form, to be used for IKE mode config and raw key selection by ID.
Not yet used though.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.54 2001/07/06 14:37:11 ho Exp $	*/
d2280 1
a2280 2
  /* XXX Guess at a maximum length.  */
  char buf[256];
d2284 5
a2288 1
  /* XXX real ugly way of making the offsets correct.  */
d2291 10
d2309 1
a2309 2
      if (snprintf (buf, sizeof buf, "ipv4/%s", addrstr) > sizeof buf - 1)
	goto fail;
d2318 1
a2318 2
      if (snprintf (buf, sizeof buf, "ipv6/%s", addrstr) > sizeof buf - 1)
	goto fail;
a2322 3
      /* Statically resolvable, should be optimized away by the compiler.  */
      if (sizeof buf < sizeof "ufqdn/")
	goto fail;
a2326 5
      /* Id is not NULL-terminated.  */
      id_len -= ISAKMP_ID_DATA_OFF;
      if (id_len > sizeof buf - len - 1)
	goto fail;

d2340 1
a2340 1
  return strdup (buf);
d2343 2
@


1.54
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.53 2001/07/04 22:23:24 angelos Exp $	*/
d2272 71
@


1.53
log
@Merge entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.52 2001/07/01 20:43:39 niklas Exp $	*/
d640 1
a640 1
ipsec_init ()
@


1.52
log
@ISAKMP configuration, a.k.a IKECFG or "mode-config", protocol implementation.
Disabled, has no configuration mechanism yet.  This will be used for roaming
users, who are going to get parameters like IP-address and nameserver from its
peer, very much like DHCP, but securily inside an ISAKMP connection and still
in time before negotiation of IPsec connections.  You may see stylistic fixes
in this commit too.  Add some not yet used Makefile magic to deal with DNSSEC-
enabled OpenSSL too.  The IKECFG code work was sponsered by Gatespace Inc.
Thank you!  Configuration will come very soon, btw.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.51 2001/07/01 14:17:06 ho Exp $	*/
d2259 2
a2267 8
    case IPSEC_ID_DER_ASN1_DN:
      data = conf_get_str (section, "Name");
      if (!data)
	{
	  log_print ("ipsec_id_size: section %s has no \"Name\" tag", section);
	  return -1;
	}
      break;
d2269 2
a2270 1
  log_print ("ipsec_id_size: unrecognized ID-type %d (%s)", *id, type);
@


1.51
log
@Teach ipsec_decode_ids about IPv6. More error checking, some better log msgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.50 2001/06/29 19:08:11 ho Exp $	*/
d64 3
d547 3
d577 9
d626 4
d882 6
a887 5
  if ((exchange->phase == 1 && exchange->type != ISAKMP_EXCH_ID_PROT
       && exchange->type != ISAKMP_EXCH_AGGRESSIVE
       && exchange->type != ISAKMP_EXCH_INFO)
      || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE
	  && exchange->type != ISAKMP_EXCH_INFO))
d904 5
d1023 1
a1023 1
  if (exchange->step == 0
d1048 6
a1976 1

d1983 1
a1983 1
  if (!id_len || id == NULL)
d1985 1
a1985 1
      *did = NULL;
d1991 1
a1991 1
  if (*did == NULL)
d2266 8
@


1.50
log
@Get rid of redundant lengths in get_spi API.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.49 2001/06/29 18:52:17 ho Exp $	*/
d116 1
a116 1
static void ipsec_set_network (u_int8_t *, u_int8_t *, struct ipsec_sa *);
d339 1
d341 7
a347 1
		ipsec_set_network (ie->id_ci, ie->id_cr, isa);
d349 9
a357 2
		/* Responder is source, initiator is destination.  */
		ipsec_set_network (ie->id_cr, ie->id_ci, isa);
d371 1
a371 1
			"src %x %x dst %x %x tproto %u sport %u dport %u",
d406 1
a406 1
static void
d419 2
a420 1
      /* XXX this may fail ! */
d423 1
d426 2
a427 1
      /* XXX this may fail ! */
d436 2
a437 1
      /* XXX this may fail ! */
d440 1
d443 2
a444 1
      /* XXX this may fail ! */
d482 2
a483 1
      /* XXX this may fail ! */
d486 1
d489 2
a490 1
      /* XXX this may fail ! */
d494 1
d499 2
a500 1
      /* XXX this may fail ! */
d503 1
d506 2
a507 1
      /* XXX this may fail ! */
d536 1
d1269 1
a1269 1
		  /* XXX Log.  */
d1282 1
a1282 1
		  /* XXX Log.  */
d1286 1
a1286 1
	      /* XXX Log!  */
d1320 1
a1320 1
		  /* XXX Log.  */
d1333 1
a1333 1
		  /* XXX Log.  */
d1337 1
a1337 1
	      /* XXX Log!  */
d1822 1
d1834 1
d1847 1
a1847 2
		    decode_32 (id + ISAKMP_ID_DATA_OFF + 4),
		    addr, mask);
d1850 11
a1860 1
	  /* XXX */
d1872 1
a1872 1
	  snprintf (buf, size, "<type unknown: %x>", id_type);
d1877 1
a1877 1
    snprintf (buf, size, "<no id>");
@


1.49
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.48 2001/06/29 18:05:24 ho Exp $	*/
d1489 1
a1489 2
      return sysdep_ipsec_get_spi (sz, proto, src, src->sa_len, dst, 
				   dst->sa_len, msg->exchange->seq);
@


1.48
log
@Since we have a sockaddr struct, use sa_len directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.47 2001/06/29 04:12:00 ho Exp $	*/
a203 1
  int dstlen, srclen;
d209 1
a209 1
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
d215 1
a215 1
      sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
d931 1
a931 1
  int invspisz, off, dstlen;
d955 1
a955 1
  msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
a1475 1
  int dstlen, srclen;
d1486 1
a1486 1
      transport->vtbl->get_src (transport, &dst, &dstlen);
d1488 1
a1488 1
      transport->vtbl->get_dst (transport, &src, &srclen);
a1505 1
  socklen_t dstlen;
d1544 1
a1544 1
      msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
d1561 2
a1562 2
	  msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
	  while ((sa = sa_lookup_by_peer (dst, dstlen)) != 0)
a2010 1
  socklen_t dstlen;
d2026 2
a2027 2
  msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
  addr = malloc (dstlen);
d2030 1
a2030 1
      log_error ("ipsec_add_contact: malloc (%d) failed", dstlen);
d2033 1
a2033 1
  memcpy (addr, dst, dstlen);
d2035 1
a2035 1
  contacts[contact_cnt++].len = dstlen;
d2051 2
a2052 1
  msg->transport->vtbl->get_dst (msg->transport, &contact.addr, &contact.len);
@


1.47
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.46 2001/06/27 03:31:40 angelos Exp $	*/
d1491 2
a1492 2
      return sysdep_ipsec_get_spi (sz, proto, src, srclen, dst, dstlen,
				   msg->exchange->seq);
@


1.46
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.45 2001/05/05 00:52:50 angelos Exp $	*/
d7 1
d188 1
a188 1
  in_addr_t dst;
d211 2
a212 1
  if (((struct sockaddr_in *)dst)->sin_addr.s_addr == arg->dst)
d217 2
a218 1
      if (((struct sockaddr_in *)src)->sin_addr.s_addr == arg->dst)
d234 1
a234 1
ipsec_sa_lookup (in_addr_t dst, u_int32_t spi, u_int8_t proto)
d256 13
a268 4
  return isa->src_net == isa2->src_net && isa->src_mask == isa2->src_mask
    && isa->dst_net == isa2->dst_net && isa->dst_mask == isa2->dst_mask
    && isa->tproto == isa2->tproto && isa->sport == isa2->sport
    && isa->dport == isa2->dport;
d284 3
d346 10
d359 2
a360 2
			ntohl (isa->src_net), ntohl (isa->src_mask),
			ntohl (isa->dst_net), ntohl (isa->dst_mask),
d363 11
d398 1
a398 1
  /* Set source address.  */
d403 25
a427 7
      memcpy (&isa->src_net, src_id + ISAKMP_ID_DATA_OFF, sizeof isa->src_net);
      isa->src_mask = htonl (0xffffffff);
      memcpy (&isa->tproto,
	      src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
d429 5
d435 8
d444 3
a446 9
      memcpy (&isa->src_net, src_id + ISAKMP_ID_DATA_OFF, sizeof isa->src_net);
      memcpy (&isa->src_mask,
	      src_id + ISAKMP_ID_DATA_OFF + sizeof isa->src_net,
	      sizeof isa->src_mask);
      memcpy (&isa->tproto,
	      src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
d448 6
a453 1
  }
d460 24
a483 7
      memcpy (&isa->dst_net, dst_id + ISAKMP_ID_DATA_OFF, sizeof isa->dst_net);
      isa->dst_mask = htonl (0xffffffff);
      memcpy (&isa->tproto,
	      dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
d485 1
d487 12
d500 3
a502 9
      memcpy (&isa->dst_net, dst_id + ISAKMP_ID_DATA_OFF, sizeof isa->dst_net);
      memcpy (&isa->dst_mask,
	      dst_id + ISAKMP_ID_DATA_OFF + sizeof isa->dst_net,
	      sizeof isa->dst_mask);
      memcpy (&isa->tproto,
	      dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
d505 5
d552 8
d710 6
a715 1
		    buf, 4));
d721 7
a727 1
		    buf, 8));
a884 1
  u_int32_t iaddr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
d905 1
a905 1
          sa = ipsec_sa_lookup (iaddr, spi, proto);
d1684 2
a1685 2
ipsec_get_id (char *section, int *id, struct in_addr *addr,
	      struct in_addr *mask, u_int8_t *tproto, u_int16_t *port)
d1700 1
d1709 1
a1709 1
      if (!inet_aton (address, addr))
d1730 1
d1739 1
a1739 1
      if (!inet_aton (address, addr))
d1754 1
a1754 1
      if (!inet_aton (netmask, mask))
a1766 6
    case IPSEC_ID_IPV6_ADDR:
      return -1;

    case IPSEC_ID_IPV6_ADDR_SUBNET:
      return -1;

a1792 25
ipsec_ipv4toa (char *buf, size_t size, u_int8_t *addr)
{
#ifdef HAVE_GETNAMEINFO
  struct sockaddr_storage from;
  struct sockaddr_in *sfrom = (struct sockaddr_in *)&from;
  socklen_t fromlen = sizeof from;

  memset (&from, 0, fromlen);
  sfrom->sin_len = sizeof *sfrom;
  sfrom->sin_family = AF_INET;
  memcpy (&sfrom->sin_addr.s_addr, addr, sizeof sfrom->sin_addr.s_addr);

  if (getnameinfo ((struct sockaddr *)sfrom, sfrom->sin_len, buf, size, NULL,
		   0, NI_NUMERICHOST) != 0)
    {
      log_print ("ipsec_ipv4toa: getnameinfo () failed");
      strcpy (buf, "<error>");
    }
#else
  strncpy (buf, inet_ntoa (*(struct in_addr *)addr), size - 1);
  buf[size - 1] = '\0';
#endif /* HAVE_GETNAMEINFO */
}

static void
d1797 1
a1797 1
  char ntop[NI_MAXHOST], ntop2[NI_MAXHOST];
d1803 1
a1803 1
	  /* exchanges and SA's dont carry the IDs in ISAKMP form */
d1812 1
a1812 1
	  ipsec_ipv4toa (ntop, sizeof ntop, id + ISAKMP_ID_DATA_OFF);
d1814 1
a1814 1
		    decode_32 (id + ISAKMP_ID_DATA_OFF), ntop);
d1817 2
a1818 2
	  ipsec_ipv4toa (ntop, sizeof ntop, id + ISAKMP_ID_DATA_OFF);
	  ipsec_ipv4toa (ntop2, sizeof ntop2, id + ISAKMP_ID_DATA_OFF + 4);
d1822 4
a1825 1
		    ntop, ntop2);
d1827 1
a1835 1
	  /* XXX - IPV6 et al */
d1843 4
d1871 1
a1871 1
  struct in_addr addr, mask;
d1873 1
a1873 1
  int id;
d1880 6
a1885 10
  *sz = ISAKMP_ID_SZ;
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
      *sz += sizeof addr;
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      *sz += sizeof addr + sizeof mask;
      break;
    }
d1897 7
a1903 14
  switch (id)
    {
    case IPSEC_ID_IPV4_ADDR:
      encode_32 (p + ISAKMP_ID_DATA_OFF, ntohl (addr.s_addr));
      SET_IPSEC_ID_PROTO (p + ISAKMP_ID_DOI_DATA_OFF, tproto);
      SET_IPSEC_ID_PORT (p + ISAKMP_ID_DOI_DATA_OFF, port);
      break;
    case IPSEC_ID_IPV4_ADDR_SUBNET:
      encode_32 (p + ISAKMP_ID_DATA_OFF, ntohl (addr.s_addr));
      encode_32 (p + ISAKMP_ID_DATA_OFF + 4, ntohl (mask.s_addr));
      SET_IPSEC_ID_PROTO (p + ISAKMP_ID_DOI_DATA_OFF, tproto);
      SET_IPSEC_ID_PORT (p + ISAKMP_ID_DOI_DATA_OFF, port);
      break;
    }
d2184 1
a2184 1
      return sizeof (in_addr_t);
d2186 5
a2190 1
      return 2 * sizeof (in_addr_t);
@


1.45
log
@Pass the Phase 1 SA to the set_spi routine, so the IDs (and eventually
any credentials) can be associated with the Phase 2 SA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.44 2001/04/24 07:27:37 niklas Exp $	*/
d77 1
a77 1
/* The replay window size used for all IPSec protocols if not overridden.  */
d260 1
a260 1
 * Do IPSec DOI specific finalizations task for the exchange where MSG was
d1263 1
a1263 1
 * Delete the IPSec SA represented by the INCOMING direction in protocol PROTO
d1860 1
a1860 1
 * IPSec-specific PROTO initializations.  SECTION is only set if we are the
@


1.44
log
@Correct SA refcounting.  Fixes a bug where isakmpd could die when a peer was
discovered to have rebooted, and old now invalid SAs had to be garbage-
collected.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.43 2001/04/15 16:09:16 ho Exp $	*/
d309 1
a309 1
		  if (sysdep_ipsec_set_spi (sa, proto, 0)
d313 1
a313 1
		      || sysdep_ipsec_set_spi (sa, proto, 1)
@


1.43
log
@Style.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.42 2001/04/09 22:09:52 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
a807 1
      sa_reference (sa);
d1396 1
a1396 1
  int flag = 0;
d1418 4
a1421 4
	    LOG_DBG ((LOG_SA, 50,
	             "ipsec_handle_leftover_payload: invalid SPI size %d "
                     "for proto %d in DELETE payload", spisz, proto));
	    return -1;
d1424 2
a1425 2
      spis = (u_int8_t *) malloc (nspis * spisz);
      if (spis == NULL)
d1427 2
a1428 4
	  LOG_DBG ((LOG_SA, 50,
		    "ipsec_handle_leftover_payload: "
		    "DELETE failed to allocate %d SPIs of %d bytes each",
		    nspis, spisz));
d1441 1
d1457 2
a1458 1
               * to remove the SA from the list to avoid an endless loop.
a1459 1

d1462 3
a1464 2
                  LIST_REMOVE (sa, link);
                  flag = 1;
d1475 5
a1479 2
          if (flag)
            sa_enter (msg->isakmp_sa);
@


1.42
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.41 2001/03/29 06:51:25 ho Exp $	*/
d835 1
a835 1
  if(invspisz != sizeof spi)
d893 1
a893 1
          if(type == ISAKMP_NOTIFY_INVALID_SPI)
@


1.41
log
@We need ipsec_decode_ids regardless of DEBUG feature now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.40 2001/03/07 07:33:53 angelos Exp $	*/
d1763 2
a1764 2
  ipsec_decode_id(s_id1, sizeof s_id1, id1, id1_len, isakmpform);
  ipsec_decode_id(s_id2, sizeof s_id2, id2, id2_len, isakmpform);
@


1.40
log
@Add KEY_ID support (mostly from roland@@digitalvampire.org)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.39 2001/02/24 03:59:55 angelos Exp $	*/
a160 1
#ifdef USE_DEBUG
a161 1
#endif
a1680 1
#ifdef USE_DEBUG
a1768 1
#endif /* USE_DEBUG */
@


1.39
log
@For the GETSPI PFKEY message, use the sequence number from the ACQUIRE
message.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.38 2001/01/27 12:03:33 niklas Exp $	*/
d2111 1
@


1.38
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.37 2001/01/26 12:12:52 niklas Exp $	*/
d1381 2
a1382 1
      return sysdep_ipsec_get_spi (sz, proto, src, srclen, dst, dstlen);
@


1.37
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.36 2001/01/14 23:40:01 angelos Exp $	*/
d6 1
@


1.36
log
@Handling of Phase 1 DELETE and Phase 2 INVALID_SPI messages
(newsham@@lava.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.35 2001/01/11 00:46:28 angelos Exp $	*/
d363 1
a363 1
  /* Set source address. */
@


1.35
log
@Reference the sa, so sa_release() does the right thing (talk about
convoluted logic).
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.34 2001/01/10 21:29:04 angelos Exp $	*/
d196 1
d224 2
a225 2
    if (proto->proto == arg->proto
	&& memcmp (proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
d762 89
d857 1
d889 1
d892 5
a896 2
		    constant_lookup (isakmp_notify_cst,
				     GET_ISAKMP_NOTIFY_MSG_TYPE (p->p))));
d1394 1
a1394 1
  u_int32_t spisz, nspis, *spis;
d1397 2
a1398 2
  int flag = 0, i;
  u_int8_t proto;
a1407 8
      if (spisz != sizeof (u_int32_t))
        {
	    LOG_DBG ((LOG_SA, 50,
		      "ipsec_handle_leftover_payload: SPI size %d in DELETE "
		      "payload unsupported", spisz));
	    return -1;
	}

d1415 11
a1425 1
      spis = (u_int32_t *) malloc (nspis * spisz);
d1435 1
d1439 1
a1439 26
      for (i = 0; i < nspis; i++)
        {
	    sa = ipsec_sa_lookup (((struct sockaddr_in *)dst)->sin_addr.s_addr,
				  spis[i], proto);
	    if (sa == NULL)
	      {
		LOG_DBG ((LOG_SA, 40, "ipsec_handle_leftover_payload: "
			  "could not locate SA (SPI %08x, proto %u)",
			  spis[i], proto));
		continue;
	      }

	    /* Delete the SA and search for the next */
	    LOG_DBG ((LOG_SA, 30, "ipsec_handle_leftover_payload: "
		      "DELETE made us delete SA %p (%d references)",
		      sa, sa->refcnt));

	    /*
	     * This SA is still referenced by the software timeout.
	     * However, sa_free will clean up all timeouts and
	     * decrement reference counters.  We need to reference it
	     * so that sa_release() works.
	     */
	    sa_reference(sa);
	    sa_free(sa);
	}
@


1.34
log
@Get logging priorities right.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.33 2001/01/10 19:48:29 angelos Exp $	*/
d1358 7
@


1.33
log
@Handle DELETE payloads (delete the relevant IPsec SAs) -- problem
reported, patches tested, and feedback provided by newsham@@lava.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.32 2000/12/12 01:45:31 niklas Exp $	*/
d1315 1
a1315 1
	    LOG_DBG ((LOG_SA, 40,
d1323 1
a1323 1
	  LOG_DBG ((LOG_SA, 40, "ipsec_handle_leftover_payload: message "
d1331 1
a1331 1
	  LOG_DBG ((LOG_SA, 70,
d1347 1
a1347 1
		LOG_DBG ((LOG_SA, 30, "ipsec_handle_leftover_payload: "
@


1.32
log
@Merge with EOM 1.143

author: niklas
Style nits

author: angelos
Pass the local/remote Phase 1 ID to the flow, so it can be reused when
an SA is re-negotiated.

author: angelos
isakmpd can now negotiate transport protocol/ports (either through the
configuration file or through kernel ACQUIREs).

author: angelos
CAST-128 has a maximum of 128bit keys, not 256.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.31 2000/11/21 06:44:04 angelos Exp $	*/
d1299 1
d1302 2
a1304 1
  int flag = 0;
a1305 1
  /* So far, the only thing we handle is an INITIAL-CONTACT NOTIFY.  */
d1308 56
a1399 1
	  break;
@


1.31
log
@CAST-128 has a maximum of 128bit keys, not 256.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.30 2000/10/16 23:26:33 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.139 2000/10/16 06:01:34 niklas Exp $	*/
d254 3
a256 1
    && isa->dst_net == isa2->dst_net && isa->dst_mask == isa2->dst_mask;
d266 1
a266 1
  struct sa *isakmp_sa;
a279 1
	  isakmp_sa = msg->isakmp_sa;
d332 2
a333 1
			"ipsec_finalize_exchange: src %x %x dst %x %x",
d335 2
a336 1
			ntohl (isa->dst_net), ntohl (isa->dst_mask)));
d343 1
a343 1
		  && sysdep_ipsec_enable_sa (sa))
d369 5
d375 1
d381 5
d396 5
d402 1
d408 5
d1429 2
a1430 2
 * in the areas pointed to by ADDR, MASK and ID respectively.  Return
 * 0 on success and -1 on failure.
d1434 1
a1434 1
	      struct in_addr *mask)
d1463 4
d1507 4
d1647 2
d1650 1
a1650 1
  if (ipsec_get_id (section, &id, &addr, &mask))
d1678 2
d1684 2
@


1.30
log
@Merge with EOM 1.139

author: niklas
Allow new and old style configuration simultaneously

author: niklas
use snprintf instead of strlcpy since it is more backwards compatible

author: niklas
Provide NI_MAXHOSTS for systems who do not have it

author: niklas
conditionalize getnaminfo and be a style pedant

author: angelos
Fix bounds checking for transforms to include AES (noticed by mickey@@)

author: angelos
Add RIPEMD negotiation/configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.29 2000/10/09 23:27:30 niklas Exp $	*/
d1341 1
a1341 1
        return 32;
@


1.30.2.1
log
@Pull in patch from current:
Fix (angelos):
CAST-128 has a maximum of 128bit keys, not 256.
@
text
@d1 1
a1 1
/*	$OpenBSD: ipsec.c,v 1.30 2000/10/16 23:26:33 niklas Exp $	*/
d1341 1
a1341 1
        return 16;
@


1.30.2.2
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.44 2001/04/24 07:27:37 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.143 2000/12/11 23:57:42 niklas Exp $	*/
d5 1
a5 2
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2001 Angelos D. Keromytis.  All rights reserved.
d160 1
d162 1
a195 1
 * if "proto" arg is 0, match any proto
d223 2
a224 2
    if ((arg->proto == 0 || proto->proto == arg->proto)
       && memcmp (proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
d254 1
a254 3
    && isa->dst_net == isa2->dst_net && isa->dst_mask == isa2->dst_mask
    && isa->tproto == isa2->tproto && isa->sport == isa2->sport
    && isa->dport == isa2->dport;
d264 1
a264 1
  struct sa *isakmp_sa = msg->isakmp_sa;
d278 1
d331 1
a331 2
			"ipsec_finalize_exchange: "
			"src %x %x dst %x %x tproto %u sport %u dport %u",
d333 1
a333 2
			ntohl (isa->dst_net), ntohl (isa->dst_mask),
			ntohs (isa->tproto), isa->sport, ntohs (isa->dport)));
d340 1
a340 1
		  && sysdep_ipsec_enable_sa (sa, isakmp_sa))
d359 1
a359 1
  /* Set source address.  */
a365 5
      memcpy (&isa->tproto,
	      src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
a366 1

a371 5
      memcpy (&isa->tproto,
	      src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->sport, src_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
a381 5
      memcpy (&isa->tproto,
	      dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
a382 1

a387 5
      memcpy (&isa->tproto,
	      dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PROTO_OFF,
	      IPSEC_ID_PROTO_LEN);
      memcpy (&isa->dport, dst_id + ISAKMP_ID_DOI_DATA_OFF + IPSEC_ID_PORT_OFF,
	      IPSEC_ID_PORT_LEN);
a735 88
/*
 * delete all SA's from addr with the associated proto and SPI's
 *
 * spis[] is an array of SPIs of size 16-octet for proto ISAKMP
 * or 4-octet otherwise.
 */
static void
ipsec_delete_spi_list (struct sockaddr *addr, u_int8_t proto, 
                       u_int8_t *spis, int nspis, char *type)
{
  u_int32_t iaddr = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
  struct sa *sa;
  int i;

  for (i = 0; i < nspis; i++) 
    {
      if (proto == ISAKMP_PROTO_ISAKMP)
        {
          u_int8_t *spi = spis + i * ISAKMP_HDR_COOKIES_LEN;

          /* 
           * This really shouldn't happen in IPSEC DOI
           * code, but Cisco VPN 3000 sends ISAKMP DELETE's
           * this way.
           */
          sa = sa_lookup_isakmp_sa (addr, spi);
        } 
      else
        {
          u_int32_t spi = ((u_int32_t *)spis)[i];

          sa = ipsec_sa_lookup (iaddr, spi, proto);
        }

      if (sa == NULL)
        {
	  LOG_DBG ((LOG_SA, 30, "ipsec_delete_spi_list: "
		   "could not locate SA (SPI %08x, proto %u)",
		   spis[i], proto));
	  continue;
	}

      /* Delete the SA and search for the next */
      LOG_DBG ((LOG_SA, 30, "ipsec_delete_spi_list: "
	       "%s made us delete SA %p (%d references) for proto %d",
	       type, sa, sa->refcnt, proto));

      sa_free (sa);
    }
}

/*
 * deal with a NOTIFY of INVALID_SPI
 */
static void
ipsec_invalid_spi (struct message *msg, struct payload *p)
{
  struct sockaddr *dst;
  int invspisz, off, dstlen;
  u_int32_t spi;
  u_int16_t totsiz;
  u_int8_t spisz;

  /* 
   * get the invalid spi out of the variable sized notification data
   * field, which is after the variable sized SPI field [which specifies
   * the receiving entity's phase-1 SPI, not the invalid spi]
   */
  totsiz = GET_ISAKMP_GEN_LENGTH (p->p);
  spisz = GET_ISAKMP_NOTIFY_SPI_SZ (p->p);
  off = ISAKMP_NOTIFY_SPI_OFF + spisz;
  invspisz = totsiz - off;

  if (invspisz != sizeof spi)
    {
      LOG_DBG ((LOG_SA, 40,
	       "ipsec_invalid_spi: SPI size %d in INVALID_SPI "
	       "payload unsupported", spisz));
       return;
    }
  memcpy (&spi, p->p + off, sizeof spi);

  msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);

  /* delete matching SPI's from this peer */
  ipsec_delete_spi_list (dst, 0, (u_int8_t *)&spi, 1, "INVALID_SPI");
}

a741 1
  u_int16_t type;
a772 1
          type = GET_ISAKMP_NOTIFY_MSG_TYPE (p->p);
d775 2
a776 5
		    constant_lookup (isakmp_notify_cst, type)));

          if (type == ISAKMP_NOTIFY_INVALID_SPI)
              ipsec_invalid_spi (msg, p);

d1260 1
a1260 2
      return sysdep_ipsec_get_spi (sz, proto, src, srclen, dst, dstlen,
				   msg->exchange->seq);
a1273 1
  u_int32_t spisz, nspis;
a1275 2
  int reenter = 0;
  u_int8_t *spis, proto;
d1277 1
d1279 1
a1281 40
    case ISAKMP_PAYLOAD_DELETE:
      proto = GET_ISAKMP_DELETE_PROTO (payload->p);
      nspis = GET_ISAKMP_DELETE_NSPIS (payload->p);
      spisz = GET_ISAKMP_DELETE_SPI_SZ (payload->p);

      if (nspis == 0)
        {
	  LOG_DBG ((LOG_SA, 60, "ipsec_handle_leftover_payload: message "
		    "specified zero SPIs, ignoring"));
	  return -1;
	}

      /* verify proper SPI size */
      if ((proto == ISAKMP_PROTO_ISAKMP && spisz != ISAKMP_HDR_COOKIES_LEN)
          || (proto != ISAKMP_PROTO_ISAKMP && spisz != sizeof (u_int32_t)))
        {
	  log_print ("ipsec_handle_leftover_payload: "
		     "invalid SPI size %d for proto %d in DELETE payload",
		     spisz, proto);
	  return -1;
        }

      spis = (u_int8_t *)malloc (nspis * spisz);
      if (!spis)
        {
	  log_error ("ipsec_handle_leftover_payload: malloc (%d) failed",
		     nspis * spisz);
	  return -1;
	}

      /* extract SPI and get dst address */
      memcpy (spis, payload->p + ISAKMP_DELETE_SPI_OFF, nspis * spisz);
      msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);

      ipsec_delete_spi_list (dst, proto, spis, nspis, "DELETE");

      free (spis);
      payload->flags |= PL_MARK;
      return 0;

d1297 1
a1297 2
               * to remove the SA from the list to avoid an endless loop,
	       * but keep a reference so it won't disappear meanwhile.
d1299 1
d1302 2
a1303 3
		  sa_reference (sa);
                  sa_remove (sa);
                  reenter = 1;
d1314 2
a1315 5
          if (reenter)
	    {
	      sa_enter (msg->isakmp_sa);
	      sa_release (msg->isakmp_sa);
	    }
d1318 1
d1404 2
a1405 2
 * in the areas pointed to by ADDR, MASK, TPROTO, PORT, and ID respectively.
 * Return 0 on success and -1 on failure.
d1409 1
a1409 1
	      struct in_addr *mask, u_int8_t *tproto, u_int16_t *port)
a1437 4

      *tproto = conf_get_num (section, "Protocol", 0);
      if (*tproto)
	*port = conf_get_num (section, "Port", 0);
a1477 4

      *tproto = conf_get_num (section, "Protocol", 0);
      if (*tproto)
	*port = conf_get_num (section, "Port", 0);
d1512 1
d1595 2
a1596 2
  ipsec_decode_id (s_id1, sizeof s_id1, id1, id1_len, isakmpform);
  ipsec_decode_id (s_id2, sizeof s_id2, id2, id2_len, isakmpform);
d1601 1
a1613 2
  u_int8_t tproto = 0;
  u_int16_t port = 0;
d1615 1
a1615 1
  if (ipsec_get_id (section, &id, &addr, &mask, &tproto, &port))
a1642 2
      SET_IPSEC_ID_PROTO (p + ISAKMP_ID_DOI_DATA_OFF, tproto);
      SET_IPSEC_ID_PORT (p + ISAKMP_ID_DOI_DATA_OFF, port);
a1646 2
      SET_IPSEC_ID_PROTO (p + ISAKMP_ID_DOI_DATA_OFF, tproto);
      SET_IPSEC_ID_PORT (p + ISAKMP_ID_DOI_DATA_OFF, port);
a1933 1
    case IPSEC_ID_KEY_ID:
@


1.29
log
@samples/VPN-3way-template.conf: Merge with EOM 1.8
samples/VPN-east.conf: Merge with EOM 1.12
samples/VPN-west.conf: Merge with EOM 1.13
samples/policy: Merge with EOM 1.6
samples/singlehost-west.conf: Merge with EOM 1.9
samples/singlehost-east.conf: Merge with EOM 1.9
conf.c: Merge with EOM 1.37
ipsec.c: Merge with EOM 1.133
ipsec_num.cst: Merge with EOM 1.4
isakmpd.conf.5: Merge with EOM 1.48
isakmpd.policy.5: Merge with EOM 1.21
policy.c: Merge with EOM 1.46

author: angelos
AES support.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.28 2000/10/07 06:58:47 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.133 2000/10/09 22:08:29 angelos Exp $	*/
d71 5
d335 6
a340 1
	      if (sysdep_ipsec_enable_sa (sa))
d683 1
a683 1
	|| transform_id > IPSEC_ESP_NULL ? -1 : 0;
d1363 1
d1379 1
d1516 1
d1519 1
a1519 1
  socklen_t fromlen = sizeof(from);
d1522 1
a1522 1
  sfrom->sin_len = sizeof (struct sockaddr_in);
d1524 1
a1524 1
  memcpy (&sfrom->sin_addr.s_addr, addr, 4);
d1526 2
a1527 2
  if (getnameinfo ((struct sockaddr *)sfrom, sfrom->sin_len,
		  buf, size, NULL, 0, NI_NUMERICHOST) != 0)
d1529 1
a1529 1
      log_error("ipsec_ipv4toa: getnameinfo() failed");
d1532 4
d1558 1
a1558 1
	  ipsec_ipv4toa (ntop, sizeof(ntop), id + ISAKMP_ID_DATA_OFF);
d1563 2
a1564 2
	  ipsec_ipv4toa (ntop, sizeof(ntop), id + ISAKMP_ID_DATA_OFF);
	  ipsec_ipv4toa (ntop2, sizeof(ntop2), id + ISAKMP_ID_DATA_OFF + 4);
d1585 1
a1585 1
    strlcpy (buf, "<noid>", size);
d1595 2
a1596 2
  ipsec_decode_id(s_id1, sizeof(s_id1), id1, id1_len, isakmpform);
  ipsec_decode_id(s_id2, sizeof(s_id2), id2, id2_len, isakmpform);
d1598 1
a1598 1
  snprintf (result, sizeof(result), fmt, s_id1, s_id2);
@


1.28
log
@Merge with EOM 1.132

author: niklas
style

author: angelos
Make sure the LIFE_DURATION length is 2 or 4 bytes (we don't handle
anything else, although we could extend it to handle anything up to 8
bytes).

author: provos
dont crash when isakmp sa keystate = 0; happens when encountering high
packet loss.

author: ho
ipsec_decode_ids is only used with USE_DEBUG

author: provos
style as pointed out by the code style pedant.

author: provos
proper reference counting for isakmp_sa in struct message, remove bogus
calls to sa_reference; fix some more memory leaks in conf.c
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.27 2000/08/03 07:24:58 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.132 2000/10/06 23:49:39 niklas Exp $	*/
d1330 4
@


1.27
log
@Merge with EOM 1.126

author: angelos
Be more careful.

author: angelos
Oops, typo.

author: angelos
Avoid endless loop in INITIAL-CONTACT handling.

author: angelos
Don't delete the ISAKMP SA over which we received an INITIAL-CONTACT
payload.

author: provos
make a DOI specific decode_ids, but have isakmp doi decode point to
ipsec.

author: provos
indent

author: provos
introduce ipsec_decode_ids, also decodes FQDN and USER_FQDN now.
new ipsec_clone_id to copy IDs to phase 2 SAs for better status
reports. okay angelos@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.26 2000/06/08 20:50:41 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.126 2000/07/13 20:05:07 angelos Exp $	*/
d155 1
d157 1
d486 6
d562 1
a562 1
  LOG_DBG ((LOG_MESSAGE, 0, 
d697 1
a697 1
    
d743 1
a743 1
    
d859 1
a859 1
	  return 0;
d867 1
a867 1
	  return decode_16 (value) % 8 != 0; 
d882 1
a882 1
	  return 0;
d1289 1
a1289 1
		   
d1513 1
a1513 1
      strcpy(buf, "<error>");
d1544 1
a1544 1
	  snprintf (buf, size, "%08x/%08x: %s/%s", 
d1564 1
a1564 1
    strlcpy(buf, "<noid>", size);
d1617 1
a1617 1
  
d1650 1
a1650 1
  if (*did == NULL) 
d1652 1
d1659 1
a1659 1
    
@


1.26
log
@Merge with EOM 1.119

author: provos
typo
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.25 2000/02/25 17:23:40 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.119 2000/05/04 21:44:30 provos Exp $	*/
d39 1
d154 2
a155 1
  ipsec_responder
d1259 1
d1276 13
d1296 2
d1488 86
d1622 30
@


1.25
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.24 2000/02/19 19:32:53 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.118 2000/02/20 19:58:38 niklas Exp $	*/
d704 1
a704 1
      log_print ("ipsec_initiator: unuspported exchange type %d",
@


1.24
log
@cert.c: Merge with EOM 1.14
ike_auth.c: Merge with EOM 1.43
ike_phase_1.c: Merge with EOM 1.21
init.c: Merge with EOM 1.24
ipsec.c: Merge with EOM 1.117
isakmpd.c: Merge with EOM 1.44
math_group.c: Merge with EOM 1.22

author: niklas
Copyright 2000

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.23 2000/01/26 15:23:32 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.117 2000/02/19 07:58:55 niklas Exp $	*/
d89 1
d91 1
d125 1
d127 1
d321 4
a324 4
	      log_debug (LOG_EXCHANGE, 50,
			 "ipsec_finalize_exchange: src %x %x dst %x %x",
			 ntohl (isa->src_net), ntohl (isa->src_mask),
			 ntohl (isa->dst_net), ntohl (isa->dst_mask));
d488 2
a489 2
  log_debug_buf (LOG_CRYPTO, 80, "ipsec_get_keystate: final phase 1 IV",
		 ks->riv, ks->xf->blocksize);
d491 4
a494 4
  log_debug_buf (LOG_CRYPTO, 80, "ipsec_get_keystate: message ID",
		 ((u_int8_t *)msg->iov[0].iov_base)
		 + ISAKMP_HDR_MESSAGE_ID_OFF,
		 ISAKMP_HDR_MESSAGE_ID_LEN);
d500 2
a501 2
  log_debug_buf (LOG_CRYPTO, 80, "ipsec_get_keystate: phase 2 IV",
		 hash->digest, ks->xf->blocksize);
d552 3
a554 3
  log_debug (LOG_MESSAGE, 0, 
	     "ipsec_validate_id_information: proto %d port %d type %d",
	     proto, port, type);
d561 2
a562 2
      log_debug_buf (LOG_MESSAGE, 40, "ipsec_validate_id_information: IPv4",
		     buf, 4);
d566 3
a568 3
      log_debug_buf (LOG_MESSAGE, 40,
		     "ipsec_validate_id_information: IPv4 network/netmask",
		     buf, 8);
d734 3
a736 3
  log_debug (LOG_MISC, 30,
	     "ipsec_responder: phase %d exchange %d step %d", exchange->phase,
	     exchange->type, exchange->step);
d753 4
a756 4
	  log_debug (LOG_EXCHANGE, 10,
		     "ipsec_responder: got NOTIFY of type %s",
		     constant_lookup (isakmp_notify_cst,
				      GET_ISAKMP_NOTIFY_MSG_TYPE (p->p)));
d897 1
d917 4
a920 4
  log_debug (LOG_MESSAGE, 50, "Attribute %s value %s",
	     constant_name (msg->exchange->phase == 1
			    ? ike_attr_cst : ipsec_attr_cst, type),
	     val);
d923 1
d1100 2
a1101 2
  log_debug (LOG_MISC, 20, "ipsec_decode_transform: transform %d chosen",
	     GET_ISAKMP_TRANSFORM_NO (buf));
d1159 1
a1159 1
  log_debug_buf (LOG_MISC, 80, header, *g_x, ie->g_x_len);
d1273 4
a1276 4
	      log_debug (LOG_SA, 30,
			 "ipsec_handle_leftover_payload: "
			 "INITIAL-CONTACT made us delete SA %p",
			 sa);
a1674 1
  size_t hashsize = hash->hashsize;
d1694 2
a1695 2
  log_debug_buf (LOG_MISC, 90, "ipsec_fill_in_hash: SKEYID_a", isa->skeyid_a,
		 isa->skeyid_len);
d1701 2
a1702 2
  log_debug_buf (LOG_MISC, 90, "ipsec_fill_in_hash: message_id",
		 exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d1711 2
a1712 2
      log_debug_buf (LOG_MISC, 90, header, msg->iov[i].iov_base,
		     msg->iov[i].iov_len);
d1717 2
a1718 2
  log_debug_buf (LOG_MISC, 80, "ipsec_fill_in_hash: HASH(1)",
		 buf + ISAKMP_HASH_DATA_OFF, hashsize);
@


1.23
log
@Merge with EOM 1.115

author: ho
Blowfish needs the KEY_LENGTH attribute accepted.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.22 1999/07/13 15:46:43 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.115 1999/12/20 10:12:17 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
a685 2
    case ISAKMP_EXCH_BASE:
      break;
d689 1
a689 4
    case ISAKMP_EXCH_AUTH_ONLY:
      log_print ("ipsec_initiator: unuspported exchange type %d",
		 exchange->type);
      return -1;
d693 1
d699 4
a702 2
    case IKE_EXCH_NEW_GROUP_MODE:
      break;
a734 5
    case ISAKMP_EXCH_BASE:
    case ISAKMP_EXCH_AUTH_ONLY:
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 1, 0);
      return -1;

d739 1
d743 1
d767 3
a769 3
    case IKE_EXCH_NEW_GROUP_MODE:
      /* XXX Not implemented yet.  */
      break;
@


1.22
log
@ipsec.c: Merge with EOM 1.114
math_group.c: Merge with EOM 1.20

author: niklas
Really make group 5 work
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.21 1999/07/07 22:13:08 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.114 1999/07/13 15:43:21 niklas Exp $	*/
d884 2
a885 1
	  return 1;
@


1.21
log
@ipsec.c: Merge with EOM 1.113
ipsec.h: Merge with EOM 1.37

author: niklas
Add a function giving the size of a certain ID-payload
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.20 1999/06/02 06:33:36 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.113 1999/06/10 13:34:56 niklas Exp $	*/
d833 1
a833 1
	    || decode_16 (value) > IKE_GROUP_DESC_EC2N_185;
d876 1
a876 1
	    || decode_16 (value) > IKE_GROUP_DESC_EC2N_185;
@


1.20
log
@Merge with EOM 1.112

author: niklas
Some restructuring of ID checks, but still no coupling to names.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.19 1999/05/06 22:44:16 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.112 1999/05/25 07:57:18 niklas Exp $	*/
d1746 33
@


1.19
log
@Merge with EOM 1.111

author: niklas
Reversed a condition by mistake

author: niklas
Another part of the former commit.

author: niklas
Do not add HASH to informational exchanges if we have
no ISAKMP SA.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.18 1999/05/02 22:05:35 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.111 1999/05/06 21:23:06 niklas Exp $	*/
a256 2
  struct sockaddr *addr;
  int len;
d310 1
a310 24
	      /*
	       * If client identifiers are not present in the exchange,
	       * we fake them. RFC 2409 states:
	       *    The identities of the SAs negotiated in Quick Mode are
	       *    implicitly assumed to be the IP addresses of the ISAKMP
	       *    peers, without any constraints on the protocol or port
	       *    numbers allowed, unless client identifiers are specified
	       *    in Quick Mode.
	       *
	       * -- Michael Paddon (mwp@@aba.net.au)
	       */
	      if (!ie->id_ci || !ie->id_cr)
		{
		  /* Get source address.  */
		  msg->transport->vtbl->get_src (msg->transport, &addr, &len);
		  isa->src_net = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
		  isa->src_mask = htonl (0xffffffff);

		  /* Get destination address.  */
		  msg->transport->vtbl->get_dst (msg->transport, &addr, &len);
		  isa->dst_net = ((struct sockaddr_in *)addr)->sin_addr.s_addr;
		  isa->dst_mask = htonl (0xffffffff);
		}
	      else if (exchange->initiator)
@


1.18
log
@Merge with EOM 1.108

author: niklas
Correct allocation of contacts
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.17 1999/05/02 19:20:33 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.108 1999/05/02 21:02:04 niklas Exp $	*/
d100 1
d133 1
a133 1
  ipsec_fill_in_hash,
d1747 1
d1751 3
a1753 2
  struct ipsec_sa *isa = msg->isakmp_sa->data;
  struct hash *hash = hash_get (isa->hash);
d1755 4
d1760 11
@


1.17
log
@BUGS: Merge with EOM 1.31
doi.h: Merge with EOM 1.27
ike_auth.c: Merge with EOM 1.30
ike_quick_mode.c: Merge with EOM 1.85
ipsec.c: Merge with EOM 1.107
ipsec.h: Merge with EOM 1.36
isakmp_doi.c: Merge with EOM 1.39

author: niklas
Factor out keyed hashing of all payloads with SKEYID_a, and make DOI hooks
for informational exchanges to add such hashing.  Use it from QM and the IKE
authentication module too.  Remove some bogus XXX comments.  Add error
reporting
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.16 1999/04/30 23:32:08 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.107 1999/05/02 12:48:57 niklas Exp $	*/
d84 1
a84 1
size_t contact_cnt = 0, contact_limit = 0;
d1618 1
d1622 2
a1623 2
      new_contacts = realloc (contacts,
			      contact_limit ? 2 * contact_limit : 64);
d1627 1
a1627 1
		     2 * contact_limit);
d1630 1
a1630 1
      contact_limit *= 2;
@


1.16
log
@Merge with EOM 1.106

author: niklas
Informational exchanges do not have SAs
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.15 1999/04/30 11:47:41 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.106 1999/04/30 23:25:28 niklas Exp $	*/
d99 2
a100 1
					   struct payload *);
d132 2
d1662 90
@


1.15
log
@ipsec.c: Merge with EOM 1.105
isakmp_doi.c: Merge with EOM 1.38

author: niklas
Recognize but ignore incoming informationmal exchanges

author: niklas
New message_drop API.  Generate real INVALID_COOKIE notification.
Generate informational exchanges in phase 1 too.  Really get these
messages to the wire
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.14 1999/04/27 21:05:18 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.105 1999/04/29 12:08:47 niklas Exp $	*/
a258 3
      isakmp_sa = msg->isakmp_sa;
      isa = isakmp_sa->data;

d263 2
d272 4
a277 4

      /* If a lifetime was negotiated setup the expiration timers.  */
      if (isakmp_sa->seconds)
	sa_setup_expirations (isakmp_sa);
@


1.14
log
@Merge with EOM 1.103

author: niklas
Handle leftover payloads, esp INITIAL CONTACT notifications.
Factor out SA expiration setting.  Add commentary.

author: niklas
Send out INITIAL-CONTACT notifications
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.13 1999/04/19 21:04:41 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.103 1999/04/27 09:42:28 niklas Exp $	*/
a693 2
  /* XXX Mostly not implemented yet.  */
  
d698 2
a699 1
      || (exchange->phase == 2 && exchange->type != IKE_EXCH_QUICK_MODE))
d721 1
a721 2
      message_send_info (msg);
      break;
d741 1
d750 1
a750 1
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 0, 0);
d761 1
a761 1
      message_drop (msg, ISAKMP_NOTIFY_UNSUPPORTED_EXCHANGE_TYPE, 0, 0, 0);
d773 16
a788 2
      /* XXX Not implemented yet.  */
      break;
d808 1
a808 1
      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 0, 0);
d1231 1
a1231 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 0);
@


1.13
log
@./ipsec.c: Merge with EOM 1.101

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

Let's get aggressive\!

Added classes LOG_SA and LOG_EXCHANGE, converted
many LOG_MISC to new classes, adjusted levels slightly.
More SA logging.

seconds are quad

style

Fix timer log message to show new lifetime

Remove SA_FLAG_REPLACED settings from various parts in preparation of a
grand unified setting in exchange_finalize.  Fix sa_mark_replaced to not
release a referance to the sa, and adjust the API as it won't get called
as a finalize func anymore.

Keep the original lifetime (before randomization) in the sa, if we sometime
will create new proposals out of existing SAs.

Add randomized decrease of ISAKMP SA lifetime
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.12 1999/04/05 20:57:50 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.101 1999/04/17 23:20:29 niklas Exp $	*/
d79 10
a92 1
static void ipsec_set_network (u_int8_t *, u_int8_t *, struct ipsec_sa *);
d98 2
d104 1
d130 1
a252 1
  struct timeval expiration;
a254 1
  u_int64_t seconds;
d278 1
a278 41
	{
	  /* 
	   * Decrease lifetime by random 0-5% to break strictly synchronized
	   * renegotiations. Works better when the randomization is of the
	   * order of processing plus network-roundtrip times, or larger.
	   * I.e depends on configuration and negotiated lifetimes.
	   * XXX Better scheme to come?
	   */
	  seconds = isakmp_sa->seconds * (950 + sysdep_random () % 51) / 1000;

	  log_debug (LOG_TIMER, 95, 
		     "ipsec_finalize_exchange: "
		     "ISAKMP SA lifetime reset from %qd to %qd seconds",
		     isakmp_sa->seconds, seconds);

	  gettimeofday (&expiration, 0);
	  expiration.tv_sec += seconds * 9 / 10;
	  isakmp_sa->soft_death
	    = timer_add_event ("sa_soft_expire",
			       (void (*) (void *))sa_soft_expire, isakmp_sa,
			       &expiration);
	  if (!isakmp_sa->soft_death)
	    {
	      /* If we don't give up we might start leaking... */
	      sa_delete (isakmp_sa, 1);
	      return;
	    }

	  gettimeofday(&expiration, 0);
	  expiration.tv_sec += seconds;
	  isakmp_sa->death
	    = timer_add_event ("sa_hard_expire",
			       (void (*) (void *))sa_hard_expire, isakmp_sa,
			       &expiration);
	  if (!isakmp_sa->death)
	    {
	      /* If we don't give up we might start leaking... */
	      sa_delete (isakmp_sa, 1);
	      return;
	    }
	}
d819 5
d906 4
d932 5
d1144 4
d1251 45
d1319 1
d1336 1
d1351 1
d1540 107
@


1.12
log
@Merge with EOM 1.92
More error reporting.

Plug memleak (all memleak I have fixed recently have been discovered by the
leak-finding mode of Boehm's conservative garbage collector.  Error
handling of group allocation.

Memory alloc. error reporting.  Be consistent on allocating keystate.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.11 1999/04/02 01:09:07 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.92 1999/04/05 18:28:10 niklas Exp $	*/
d54 1
d211 1
d243 1
d268 16
a283 2
	  gettimeofday(&expiration, 0);
	  expiration.tv_sec += isakmp_sa->seconds * 9 / 10;
d296 1
a296 1
	  expiration.tv_sec += isakmp_sa->seconds;
d368 1
a368 1
	      log_debug (LOG_MISC, 50,
d379 1
a379 4
		{
		  sa_reference (old_sa);
		  sa_mark_replaced (old_sa, 0);
		}
d727 1
d748 1
d776 1
d799 1
a799 1
      /* XXX Not implemented yet.  */
d983 1
a983 3
	  ie->group = group_get (decode_16 (value));
	  if (!ie->group)
	    return -1;
d1204 6
a1209 1
  dh_create_exchange (ie->group, buf + ISAKMP_KE_DATA_OFF);
@


1.11
log
@Merge with EOM 1.89
Assign locals where the are needed, otherwise we might deref deallocated
stuff.

resource track exchange->name and sa->name
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.10 1999/03/31 20:29:37 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.89 1999/04/02 00:47:56 niklas Exp $	*/
d364 1
a364 1
		  sa_mark_replaced (old_sa);
d441 2
d499 10
a508 1
    return msg->exchange->keystate;
a965 1
	  /* XXX Errors possible?  */
d967 2
d1156 4
a1159 1
    return -1;
d1176 5
a1180 1
    return -1;
@


1.10
log
@Merge with EOM 1.87
Use SA refcounting where needed
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.9 1999/03/31 14:27:37 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.87 1999/03/31 20:22:18 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d232 2
a233 2
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa = isakmp_sa->data;
a237 1
  int initiator = exchange->initiator;
d245 2
a246 3
      /* Move over the name to the SA.  */
      isakmp_sa->name = exchange->name;
      exchange->name = 0;
d344 1
a344 1
	      else if (initiator)
a366 1
	  exchange->name = 0;
@


1.9
log
@ipsec.c: Merge with EOM 1.86
ipsec.h: Merge with EOM 1.33
pf_encap.c: Merge with EOM 1.52
pf_key_v2.c: Merge with EOM 1.3

Fix case of missing client ID payloads, a case the standards allow.  Thanks
to Michael Paddon (mwp@@aba.net.au) for the diffs I based my fix upon.  His
diff also made me realize I stored the address information in host order in
internal structures where I had planned to use network order.  Fix this,
and remove the XXXes I had due to this elsewhere.  Add commentary.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.8 1999/03/31 00:51:07 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.86 1999/03/31 14:19:51 niklas Exp $	*/
d364 4
a367 1
		sa_mark_replaced (old_sa);
@


1.8
log
@Merge with EOM 1.85
Mark replaced SAs as such. Move SA naming earlier. Reorder & comment funcs.
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.7 1999/03/24 14:43:12 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.85 1999/03/30 21:39:42 niklas Exp $	*/
d82 1
d240 2
a241 1
  int id;
a320 1
	      /* Figure out the networks.  */
d322 13
a334 2
	      id = GET_ISAKMP_ID_TYPE (ie->id_ci);
	      switch (id)
d336 9
a344 14
		case IPSEC_ID_IPV4_ADDR:
		  isa->src_net
		    = decode_32 ((initiator ? ie->id_ci : ie->id_cr)
				 + ISAKMP_ID_DATA_OFF);
		  isa->src_mask = 0xffffffff;
		  break;
		case IPSEC_ID_IPV4_ADDR_SUBNET:
		  isa->src_net
		    = decode_32 ((initiator ? ie->id_ci : ie->id_cr)
				 + ISAKMP_ID_DATA_OFF);
		  isa->src_mask
		    = decode_32 ((initiator ? ie->id_ci : ie->id_cr)
				 + ISAKMP_ID_DATA_OFF + 4);
		  break;
d346 6
a352 18
	      id = GET_ISAKMP_ID_TYPE (ie->id_cr);
	      switch (id)
		{
		case IPSEC_ID_IPV4_ADDR:
		  isa->dst_net
		    = decode_32 ((initiator ? ie->id_cr : ie->id_ci)
				 + ISAKMP_ID_DATA_OFF);
		  isa->dst_mask = 0xffffffff;
		  break;
		case IPSEC_ID_IPV4_ADDR_SUBNET:
		  isa->dst_net
		    = decode_32 ((initiator ? ie->id_cr : ie->id_ci)
				 + ISAKMP_ID_DATA_OFF);
		  isa->dst_mask
		    = decode_32 ((initiator ? ie->id_cr : ie->id_ci)
				 + ISAKMP_ID_DATA_OFF + 4);
		  break;
		}
d355 2
a356 2
			 isa->src_net, isa->src_mask, isa->dst_net,
			 isa->dst_mask);
d372 40
d443 1
d455 1
d467 1
d481 1
a481 1
/* Requires doi_init to already have been called.  */
@


1.7
log
@Merge with EOM 1.84
Use new sysdep API
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.6 1999/02/27 09:59:36 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.84 1999/03/24 11:00:47 niklas Exp $	*/
d155 73
d235 1
a235 1
  struct sa *sa = 0;
a302 3
	      /* Move over the name to the SA.  */
	      sa->name = exchange->name;

d366 4
a1410 46
}

struct dst_spi_proto_arg {
  in_addr_t dst;
  u_int32_t spi;
  u_int8_t proto;
};

static int
ipsec_sa_check (struct sa *sa, void *v_arg)
{
  struct dst_spi_proto_arg *arg = v_arg;
  struct proto *proto;
  struct sockaddr *dst, *src;
  int dstlen, srclen;
  int incoming;

  if (sa->phase != 2)
    return 0;

  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  if (((struct sockaddr_in *)dst)->sin_addr.s_addr == arg->dst)
    incoming = 0;
  else
    {
      sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
      if (((struct sockaddr_in *)src)->sin_addr.s_addr == arg->dst)
	incoming = 1;
      else
	return 0;
    }

  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    if (proto->proto == arg->proto
	&& memcmp (proto->spi[incoming], &arg->spi, sizeof arg->spi) == 0)
      return 1;
  return 0;
}

struct sa *
ipsec_sa_lookup (in_addr_t dst, u_int32_t spi, u_int8_t proto)
{
  struct dst_spi_proto_arg arg = { dst, spi, proto };

  return sa_find (ipsec_sa_check, &arg);
@


1.6
log
@ipsec.c: Merge with EOM 1.83
Only accept IPsec SAs when searching for such

sa.h: Merge with EOM 1.41
Stayalive connections as a default for now, init pf_encap_socket

pf_encap.c: Merge with EOM 1.45
Stayalive connections as a default for now, init pf_encap_socket
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.5 1999/02/26 03:43:41 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.83 1999/02/26 14:32:18 niklas Exp $	*/
d236 1
a236 1
		  if (sysdep_ipsec_set_spi (sa, proto, 0, initiator)
d240 1
a240 1
		      || sysdep_ipsec_set_spi (sa, proto, 1, initiator)
d256 1
a256 1
		    = decode_32 ((exchange->initiator ? ie->id_ci : ie->id_cr)
d262 1
a262 1
		    = decode_32 ((exchange->initiator ? ie->id_ci : ie->id_cr)
d265 1
a265 1
		    = decode_32 ((exchange->initiator ? ie->id_ci : ie->id_cr)
d275 1
a275 1
		    = decode_32 ((exchange->initiator ? ie->id_cr : ie->id_ci)
d281 1
a281 1
		    = decode_32 ((exchange->initiator ? ie->id_cr : ie->id_ci)
d284 1
a284 1
		    = decode_32 ((exchange->initiator ? ie->id_cr : ie->id_ci)
d293 1
a293 1
	      if (sysdep_ipsec_enable_sa (sa, initiator))
d1007 4
d1012 1
a1012 1
ipsec_delete_spi (struct sa *sa, struct proto *proto, int initiator)
d1017 1
a1017 1
  sysdep_ipsec_delete_spi (sa, proto, initiator);
d1092 2
a1093 2
  struct sockaddr *dst;
  int dstlen;
d1105 3
a1107 1
      return sysdep_ipsec_get_spi (sz, proto, dst, dstlen);
@


1.5
log
@Merge from the Ericsson repository
| revision 1.82
| date: 1999/02/25 13:35:41;  author: niklas;  state: Exp;  lines: +6 -2
| doh wrong replay window default
| ----------------------------
| revision 1.81
| date: 1999/02/25 11:39:07;  author: niklas;  state: Exp;  lines: +3 -2
| include sysdep.h everywhere
| ----------------------------
| revision 1.80
| date: 1999/02/25 11:09:38;  author: niklas;  state: Exp;  lines: +2 -2
| Make conf_get_num take a default value to give back when tag does not exist
| ----------------------------
| revision 1.79
| date: 1999/02/25 10:21:32;  author: niklas;  state: Exp;  lines: +10 -5
| Replay window changes was done at the wrong level
| ----------------------------
| revision 1.78
| date: 1999/02/25 09:30:25;  author: niklas;  state: Exp;  lines: +12 -1
| Replay protection window configurable
| ----------------------------
| revision 1.77
| date: 1999/02/14 00:21:10;  author: niklas;  state: Exp;  lines: +62 -5
| Find relevant SAs out of IPsec expiration info.  Do not automatically rekey.
| ----------------------------
| revision 1.76
| date: 1999/01/31 01:16:59;  author: niklas;  state: Exp;  lines: +67 -45
| splitup ipsec_build_id into more useful API
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.4 1998/12/21 01:02:24 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.82 1999/02/25 13:35:41 niklas Exp $	*/
d1347 3
@


1.4
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.3 1998/11/17 11:10:13 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.75 1998/12/15 09:11:57 niklas Exp $	*/
d44 2
a64 1
#include "sysdep.h"
d69 3
d88 1
d117 1
d189 1
a189 1
      /* If a lifetime was negotiated setup the death timer.  */
d193 13
d207 4
a210 3
	  isakmp_sa->death = timer_add_event ("sa_rekey_p1",
					      (void (*) (void *))sa_rekey_p1,
					      isakmp_sa, &expiration);
d293 1
a293 1
	      if (sysdep_ipsec_enable_spi (sa, initiator))
d1173 4
a1176 3
 * Out of a named section SECTION in the configuration file build an
 * ISAKMP ID payload.  Ths payload size should be stashed in SZ.
 * The caller is responsible for freeing the payload.
d1178 3
a1180 2
u_int8_t *
ipsec_build_id (char *section, size_t *sz)
a1182 3
  struct in_addr addr, mask;
  u_int8_t *p;
  int id;
d1187 2
a1188 2
      log_print ("ipsec_build_id: section %s has no ID-type", section);
      return 0;
d1191 2
a1192 4
  *sz = ISAKMP_ID_SZ;

  id = constant_value (ipsec_id_cst, type);
  switch (id)
d1198 1
a1198 1
	  log_print ("ipsec_id_build: section %s has no \"Address\" tag",
d1200 1
a1200 1
	  return 0;
d1203 1
a1203 1
      if (!inet_aton (address, &addr))
d1205 1
a1205 1
	  log_print ("ipsec_id_build: invalid section %s address %s", section,
d1207 1
a1207 1
	  return 0;
a1208 2

      *sz += sizeof (in_addr_t);
d1213 1
a1213 1
      return 0;
d1216 1
a1216 1
      return 0;
d1223 1
a1223 1
	  log_print ("ipsec_id_build: section %s has no \"Network\" tag",
d1225 1
a1225 1
	  return 0;
d1228 1
a1228 1
      if (!inet_aton (address, &addr))
d1230 1
a1230 1
	  log_print ("ipsec_id_build: invalid section %s network %s", section,
d1232 1
a1232 1
	  return 0;
d1238 1
a1238 1
	  log_print ("ipsec_id_build: section %s has no \"Netmask\" tag",
d1240 1
a1240 1
	  return 0;
d1243 1
a1243 1
      if (!inet_aton (netmask, &mask))
d1247 1
a1247 1
	  return 0;
a1248 2

      *sz += 2 * sizeof (in_addr_t);
d1253 1
a1253 1
      return 0;
d1256 1
a1256 1
      return 0;
d1259 1
a1259 1
      return 0;
d1262 1
a1262 1
      return 0;
d1265 1
a1265 1
      return 0;
d1268 1
a1268 1
      return 0;
d1271 1
a1271 1
      return 0;
d1275 1
a1275 1
      log_print ("ipsec_build_id: unknown ID type \"%s\" in section %s", type,
d1277 30
a1306 1
      return 0;
d1331 58
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: ipsec.c,v 1.2 1998/11/15 00:43:55 niklas Exp $	*/
/*	$EOM: ipsec.c,v 1.71 1998/11/14 23:42:25 niklas Exp $	*/
d38 1
d40 1
d45 1
d156 1
a156 1
  struct sa *sa;
d160 1
d165 4
d183 1
a183 1
      /* If a lifetime was negotiated sutup the death timer.  */
d210 3
d228 45
d277 1
d290 4
d448 17
d571 1
a571 1
      || (exchange->phase == 2 && exchange->type == ISAKMP_EXCH_ID_PROT))
d1099 4
d1150 139
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: ipsec.c,v 1.1.1.1 1998/11/15 00:03:48 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: ipsec.c,v 1.71 1998/11/14 23:42:25 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
