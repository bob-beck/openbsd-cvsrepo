head	1.104;
access;
symbols
	OPENBSD_6_1:1.104.0.4
	OPENBSD_6_1_BASE:1.104
	OPENBSD_6_0:1.104.0.2
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.102.0.6
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.102.0.2
	OPENBSD_5_7_BASE:1.102
	OPENBSD_5_6:1.101.0.6
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.100.0.2
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.98.0.12
	OPENBSD_5_3_BASE:1.98
	OPENBSD_5_2:1.98.0.10
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.98
	OPENBSD_5_1:1.98.0.8
	OPENBSD_5_0:1.98.0.6
	OPENBSD_5_0_BASE:1.98
	OPENBSD_4_9:1.98.0.4
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.98.0.2
	OPENBSD_4_8_BASE:1.98
	OPENBSD_4_7:1.97.0.6
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.97.0.8
	OPENBSD_4_6_BASE:1.97
	OPENBSD_4_5:1.97.0.4
	OPENBSD_4_5_BASE:1.97
	OPENBSD_4_4:1.97.0.2
	OPENBSD_4_4_BASE:1.97
	OPENBSD_4_3:1.96.0.4
	OPENBSD_4_3_BASE:1.96
	OPENBSD_4_2:1.96.0.2
	OPENBSD_4_2_BASE:1.96
	OPENBSD_4_1:1.95.0.4
	OPENBSD_4_1_BASE:1.95
	OPENBSD_4_0:1.95.0.2
	OPENBSD_4_0_BASE:1.95
	OPENBSD_3_9:1.90.0.2
	OPENBSD_3_9_BASE:1.90
	OPENBSD_3_8:1.89.0.2
	OPENBSD_3_8_BASE:1.89
	OPENBSD_3_7:1.73.0.2
	OPENBSD_3_7_BASE:1.73
	OPENBSD_3_6:1.67.0.2
	OPENBSD_3_6_BASE:1.67
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.53.0.2
	OPENBSD_3_4_BASE:1.53
	OPENBSD_3_3:1.48.0.2
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	OPENBSD_3_0:1.36.0.2
	OPENBSD_3_0_BASE:1.36
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_8:1.25.0.2
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.104
date	2016.04.02.14.37.42;	author krw;	state Exp;
branches;
next	1.103;
commitid	rfpOX4oSITckBvQ2;

1.103
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	0qPuuXwccpVXsXcV;

1.102
date	2015.02.07.02.09.13;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	pzd3OPiuZ6mCFBtc;

1.101
date	2013.09.26.15.31.14;	author patrick;	state Exp;
branches;
next	1.100;

1.100
date	2013.04.24.13.46.09;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2013.03.21.04.30.14;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2010.04.15.07.51.17;	author lum;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.12.19.15.02;	author pyr;	state Exp;
branches;
next	1.96;

1.96
date	2007.04.02.08.08.32;	author moritz;	state Exp;
branches;
next	1.95;

1.95
date	2006.09.01.00.24.06;	author mpf;	state Exp;
branches;
next	1.94;

1.94
date	2006.08.30.16.56.56;	author hshoexer;	state Exp;
branches;
next	1.93;

1.93
date	2006.06.10.21.15.45;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2006.06.01.01.39.16;	author hshoexer;	state Exp;
branches;
next	1.91;

1.91
date	2006.03.20.16.43.22;	author hshoexer;	state Exp;
branches;
next	1.90;

1.90
date	2005.12.20.22.03.53;	author moritz;	state Exp;
branches;
next	1.89;

1.89
date	2005.06.25.23.20.43;	author hshoexer;	state Exp;
branches;
next	1.88;

1.88
date	2005.05.26.20.40.50;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2005.05.03.14.03.11;	author moritz;	state Exp;
branches;
next	1.86;

1.86
date	2005.05.03.13.09.45;	author moritz;	state Exp;
branches;
next	1.85;

1.85
date	2005.04.10.14.17.49;	author jmc;	state Exp;
branches;
next	1.84;

1.84
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.83;

1.83
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2005.04.08.16.24.12;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2005.04.08.16.11.58;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2005.04.08.15.47.24;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.08.15.44.13;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2005.04.05.18.06.06;	author cloder;	state Exp;
branches;
next	1.75;

1.75
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.22.17.27.59;	author cloder;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.25.14.21.20;	author hshoexer;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.25.14.14.31;	author hshoexer;	state Exp;
branches;
next	1.70;

1.70
date	2005.02.24.13.55.51;	author hshoexer;	state Exp;
branches;
next	1.69;

1.69
date	2005.02.16.22.00.14;	author hshoexer;	state Exp;
branches;
next	1.68;

1.68
date	2004.09.17.14.54.09;	author hshoexer;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.25.20.25.34;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2004.06.23.00.55.59;	author hshoexer;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.20.15.03.35;	author ho;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.63;

1.63
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.19.14.30.26;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.08.10.05.54;	author hshoexer;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.31.10.47.16;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.19.15.35.16;	author hshoexer;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.19.09.54.52;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.19.09.46.19;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2004.01.16.10.51.57;	author hshoexer;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.18.19.37.46;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.14.18.08.27;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2003.04.14.13.08.42;	author ho;	state Exp;
branches;
next	1.48;

1.48
date	2002.12.03.20.05.10;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2002.11.27.15.29.20;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2002.11.21.12.09.20;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.05.13.58.50;	author ho;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.14.21.34.58;	author todd;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.07.01.07.18;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.26.09.24.35;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.11.01.54.34;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.10.03.34.51;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.26.11.37.16;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2001.08.24.13.53.02;	author ho;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.23.23.11.02;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.23.14.17.08;	author aaron;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.05.12.36.53;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.01.19.59.13;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.29.19.41.43;	author ho;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.09.21.21.57;	author ho;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.07.20.36.47;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.27.12.03.33;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.07.06.58.37;	author niklas;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.06.08.20.51.31;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.05.03.13.47.27;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.05.02.14.36.30;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.07.22.06.44;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.25.17.23.39;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.19.19.32.53;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.31.08.18.54;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.26.15.21.08;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.10.01.14.09.20;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.08.26.22.31.45;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.08.05.22.40.57;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.07.07.22.11.45;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.06.02.06.28.34;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.04.19.21.09.36;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.24.14.43.37;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.03.44.42;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	98.12.22.15.27.40;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.12.22.02.25.16;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.12.21.01.02.25;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.20.07.33.45;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.15;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.43.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2001.05.08.12.45.23;	author ho;	state Exp;
branches;
next	;


desc
@@


1.104
log
@Another use for fcntl() and thus of the superfluous 3rd parameter
is when sanitising standard fd's before calling daemon().

Use a tweaked version of the ssh(1) function in all three places
found using fcntl() this way.

ok jca@@ beck@@
@
text
@/* $OpenBSD: isakmpd.c,v 1.103 2015/08/20 22:02:21 deraadt Exp $	 */
/* $EOM: isakmpd.c,v 1.54 2000/10/05 09:28:22 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <netdb.h>
#include <unistd.h>
#include <fcntl.h>
#include <paths.h>

#include "app.h"
#include "conf.h"
#include "connection.h"
#include "init.h"
#include "libcrypto.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "nat_traversal.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "udp.h"
#include "udp_encap.h"
#include "ui.h"
#include "util.h"
#include "cert.h"

#include "policy.h"

static void     usage(void);

/*
 * Set if -d is given, currently just for running in the foreground and log
 * to stderr instead of syslog.
 */
int             debug = 0;

/* Set when no policy file shall be used. */
int		acquire_only = 0;

/* Set when SAs shall be deleted on shutdown. */
int		delete_sas = 1;

/*
 * If we receive a SIGHUP signal, this flag gets set to show we need to
 * reconfigure ASAP.
 */
volatile sig_atomic_t sighupped = 0;

/*
 * If we receive a USR1 signal, this flag gets set to show we need to dump
 * a report over our internal state ASAP.  The file to report to is settable
 * via the -R parameter.
 */
volatile sig_atomic_t sigusr1ed = 0;
static char    *report_file = "/var/run/isakmpd.report";

/*
 * If we receive a TERM signal, perform a "clean shutdown" of the daemon.
 * This includes to send DELETE notifications for all our active SAs.
 * Also on recv of an INT signal (Ctrl-C out of an '-d' session, typically).
 */
volatile sig_atomic_t sigtermed = 0;
void            daemon_shutdown_now(int);
void		set_slave_signals(void);
void		sanitise_stdfd(void);

/* The default path of the PID file.  */
char	       *pid_file = "/var/run/isakmpd.pid";

/* The path of the IKE packet capture log file.  */
static char    *pcap_file = 0;

static void
usage(void)
{
	extern char *__progname;

	fprintf(stderr,
	    "usage: %s [-46adKLnSTv] [-c config-file] [-D class=level] [-f fifo]\n"
	    "          [-i pid-file] [-l packetlog-file] [-N udpencap-port]\n"
	    "          [-p listen-port] [-R report-file]\n",
	    __progname);
	exit(1);
}

static void
parse_args(int argc, char *argv[])
{
	int             ch;
	int             cls, level;
	int             do_packetlog = 0;

	while ((ch = getopt(argc, argv, "46ac:dD:f:i:KnN:p:Ll:R:STv")) != -1) {
		switch (ch) {
		case '4':
			bind_family |= BIND_FAMILY_INET4;
			break;

		case '6':
			bind_family |= BIND_FAMILY_INET6;
			break;

		case 'a':
			acquire_only = 1;
			break;

		case 'c':
			conf_path = optarg;
			break;

		case 'd':
			debug++;
			break;

		case 'D':
			if (sscanf(optarg, "%d=%d", &cls, &level) != 2) {
				if (sscanf(optarg, "A=%d", &level) == 1) {
					for (cls = 0; cls < LOG_ENDCLASS;
					    cls++)
						log_debug_cmd(cls, level);
				} else
					log_print("parse_args: -D argument "
					    "unparseable: %s", optarg);
			} else
				log_debug_cmd(cls, level);
			break;

		case 'f':
			ui_fifo = optarg;
			break;

		case 'i':
			pid_file = optarg;
			break;

		case 'K':
			ignore_policy++;
			break;

		case 'n':
			app_none++;
			break;

		case 'N':
			udp_encap_default_port = optarg;
			break;

		case 'p':
			udp_default_port = optarg;
			break;

		case 'l':
			pcap_file = optarg;
			/* FALLTHROUGH */

		case 'L':
			do_packetlog++;
			break;

		case 'R':
			report_file = optarg;
			break;

		case 'S':
			delete_sas = 0;
			ui_daemon_passive = 1;
			break;

		case 'T':
			disable_nat_t = 1;
			break;

		case 'v':
			verbose_logging = 1;
			break;

		case '?':
		default:
			usage();
		}
	}
	argc -= optind;
	argv += optind;

	if (argc > 0)	
		usage();

	if (do_packetlog && !pcap_file)
		pcap_file = PCAP_FILE_DEFAULT;
}

/* ARGSUSED */
static void
sighup(int sig)
{
	sighupped = 1;
}

/* Report internal state on SIGUSR1.  */
static void
report(void)
{
	FILE	*rfp, *old;
	mode_t	old_umask;

	old_umask = umask(S_IRWXG | S_IRWXO);
	rfp = monitor_fopen(report_file, "w");
	umask(old_umask);

	if (!rfp) {
		log_error("report: fopen (\"%s\", \"w\") failed", report_file);
		return;
	}
	/* Divert the log channel to the report file during the report.  */
	old = log_current();
	log_to(rfp);
	ui_report("r");
	log_to(old);
	fclose(rfp);
}

static void
sigusr1(int sig)
{
	sigusr1ed = 1;
}

static int
phase2_sa_check(struct sa *sa, void *arg)
{
	return sa->phase == 2;
}

static int
phase1_sa_check(struct sa *sa, void *arg)
{
	return sa->phase == 1;
}

void
set_slave_signals(void)
{
	int n;

	for (n = 1; n < _NSIG; n++)
		signal(n, SIG_DFL);

	/*
	 * Do a clean daemon shutdown on TERM/INT. These signals must be
	 * initialized before monitor_init(). INT is only used with '-d'.
         */
	signal(SIGTERM, daemon_shutdown_now);
	if (debug == 1)		/* i.e '-dd' will skip this.  */
		signal(SIGINT, daemon_shutdown_now);

	/* Reinitialize on HUP reception.  */
	signal(SIGHUP, sighup);

	/* Report state on USR1 reception.  */
	signal(SIGUSR1, sigusr1);
}

static void
daemon_shutdown(void)
{
	/* Perform a (protocol-wise) clean shutdown of the daemon.  */
	struct sa	*sa;

	if (sigtermed == 1) {
		log_print("isakmpd: shutting down...");

		if (delete_sas &&
		    strncmp("no", conf_get_str("General", "Delete-SAs"), 2)) {
			/*
			 * Delete all active SAs.  First IPsec SAs, then
			 * ISAKMPD.  Each DELETE is another (outgoing) message.
			 */
			while ((sa = sa_find(phase2_sa_check, NULL)))
				sa_delete(sa, 1);

			while ((sa = sa_find(phase1_sa_check, NULL)))
				sa_delete(sa, 1);
		}

		/* We only want to do this once. */
		sigtermed++;
	}
	if (transport_prio_sendqs_empty()) {
		/*
		 * When the prioritized transport sendq:s are empty, i.e all
		 * the DELETE notifications have been sent, we can shutdown.
		 */

		log_packet_stop();
		log_print("isakmpd: exit");
		exit(0);
	}
}

/* Called on SIGTERM, SIGINT or by ui_shutdown_daemon().  */
/* ARGSUSED */
void
daemon_shutdown_now(int sig)
{
	sigtermed = 1;
}

/* Write pid file.  */
static void
write_pid_file(void)
{
	FILE	*fp;

	unlink(pid_file);

	fp = fopen(pid_file, "w");
	if (fp != NULL) {
		if (fprintf(fp, "%ld\n", (long) getpid()) < 0)
			log_error("write_pid_file: failed to write PID to "
			    "\"%.100s\"", pid_file);
		fclose(fp);
	} else
		log_fatal("write_pid_file: fopen (\"%.100s\", \"w\") failed",
		    pid_file);
}

void
sanitise_stdfd(void)
{
	int nullfd, dupfd;

	if ((nullfd = dupfd = open(_PATH_DEVNULL, O_RDWR)) == -1) {
		fprintf(stderr, "Couldn't open /dev/null: %s\n",
		    strerror(errno));
		exit(1);
	}
	while (++dupfd <= STDERR_FILENO) {
		/* Only populate closed fds */
		if (fcntl(dupfd, F_GETFL) == -1 && errno == EBADF) {
			if (dup2(nullfd, dupfd) == -1) {
				fprintf(stderr, "dup2: %s\n", strerror(errno));
				exit(1);
			}
		}
	}
	if (nullfd > STDERR_FILENO)
		close(nullfd);
}

int
main(int argc, char *argv[])
{
	fd_set         *rfds, *wfds;
	int             n, m;
	size_t          mask_size;
	struct timeval  tv, *timeout;

	closefrom(STDERR_FILENO + 1);

	/*
	 * Make sure init() won't alloc fd 0, 1 or 2, as daemon() will close
	 * them.
	 */
	sanitise_stdfd();

	/* Log cmd line parsing and initialization errors to stderr.  */
	log_to(stderr);
	parse_args(argc, argv);
	log_init(debug);
	log_print("isakmpd: starting");

	/* Open protocols and services databases.  */
	setprotoent(1);
	setservent(1);

	/* Open command fifo */
	ui_init();

	set_slave_signals();
	/* Daemonize before forking unpriv'ed child */
	if (!debug)
		if (daemon(0, 0))
			log_fatal("main: daemon (0, 0) failed");

	/* Set timezone before priv'separation */
	tzset();

	write_pid_file();

	if (monitor_init(debug)) {
		/* The parent, with privileges enters infinite monitor loop. */
		monitor_loop(debug);
		exit(0);	/* Never reached.  */
	}
	/* Child process only from this point on, no privileges left.  */

	init();

	/* If we wanted IKE packet capture to file, initialize it now.  */
	if (pcap_file != 0)
		log_packet_init(pcap_file);

	/* Allocate the file descriptor sets just big enough.  */
	n = getdtablesize();
	mask_size = howmany(n, NFDBITS) * sizeof(fd_mask);
	rfds = malloc(mask_size);
	if (!rfds)
		log_fatal("main: malloc (%lu) failed",
		    (unsigned long)mask_size);
	wfds = malloc(mask_size);
	if (!wfds)
		log_fatal("main: malloc (%lu) failed",
		    (unsigned long)mask_size);

	monitor_init_done();

	while (1) {
		/* If someone has sent SIGHUP to us, reconfigure.  */
		if (sighupped) {
			sighupped = 0;
			log_print("SIGHUP received");
			reinit();
		}
		/* and if someone sent SIGUSR1, do a state report.  */
		if (sigusr1ed) {
			sigusr1ed = 0;
			log_print("SIGUSR1 received");
			report();
		}
		/*
		 * and if someone set 'sigtermed' (SIGTERM, SIGINT or via the
		 * UI), this indicates we should start a controlled shutdown
		 * of the daemon.
		 *
		 * Note: Since _one_ message is sent per iteration of this
		 * enclosing while-loop, and we want to send a number of
		 * DELETE notifications, we must loop atleast this number of
		 * times. The daemon_shutdown() function starts by queueing
		 * the DELETEs, all other calls just increments the
		 * 'sigtermed' variable until it reaches a "safe" value, and
		 * the daemon exits.
		 */
		if (sigtermed)
			daemon_shutdown();

		/* Setup the descriptors to look for incoming messages at.  */
		bzero(rfds, mask_size);
		n = transport_fd_set(rfds);
		FD_SET(ui_socket, rfds);
		if (ui_socket + 1 > n)
			n = ui_socket + 1;

		/*
		 * XXX Some day we might want to deal with an abstract
		 * application class instead, with many instantiations
		 * possible.
		 */
		if (!app_none && app_socket >= 0) {
			FD_SET(app_socket, rfds);
			if (app_socket + 1 > n)
				n = app_socket + 1;
		}
		/* Setup the descriptors that have pending messages to send. */
		bzero(wfds, mask_size);
		m = transport_pending_wfd_set(wfds);
		if (m > n)
			n = m;

		/* Find out when the next timed event is.  */
		timeout = &tv;
		timer_next_event(&timeout);

		n = select(n, rfds, wfds, 0, timeout);
		if (n == -1) {
			if (errno != EINTR) {
				log_error("main: select");

				/*
				 * In order to give the unexpected error
				 * condition time to resolve without letting
				 * this process eat up all available CPU
				 * we sleep for a short while.
				 */
				sleep(1);
			}
		} else if (n) {
			transport_handle_messages(rfds);
			transport_send_messages(wfds);
			if (FD_ISSET(ui_socket, rfds))
				ui_handler();
			if (!app_none && app_socket >= 0 &&
			    FD_ISSET(app_socket, rfds))
				app_handler();
		}
		timer_handle_expirations();
	}
}
@


1.103
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.102 2015/02/07 02:09:13 deraadt Exp $	 */
d45 1
d103 1
d365 23
d402 1
a402 3
	for (n = 0; n <= 2; n++)
		if (fcntl(n, F_GETFL, 0) == -1 && errno == EBADF)
			(void) open("/dev/null", n ? O_WRONLY : O_RDONLY, 0);
@


1.102
log
@When getopt processing flags, many should be flag=1 instead of flag++
ok tedu miod
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.101 2013/09/26 15:31:14 patrick Exp $	 */
d421 1
a421 1
	rfds = (fd_set *) malloc(mask_size);
d425 1
a425 1
	wfds = (fd_set *) malloc(mask_size);
@


1.101
log
@Removed a break of a switch-case, which had not been removed in the last commit.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.100 2013/04/24 13:46:09 deraadt Exp $	 */
d140 1
a140 1
			acquire_only++;
@


1.100
log
@remove old backwards random junk
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.99 2013/03/21 04:30:14 deraadt Exp $	 */
a195 1
			break;
@


1.99
log
@remove excessive includes
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.98 2010/04/15 07:51:17 lum Exp $	 */
a125 3
#if defined(INSECURE_RAND)
	char           *ep;
#endif
d129 1
a129 1
	while ((ch = getopt(argc, argv, "46ac:dD:f:i:KnN:p:Ll:r:R:STv")) != -1) {
a195 11
		case 'r':
#if defined(INSECURE_RAND)
			seed = strtoul(optarg, &ep, 0);
			srandom(seed);
			if (*ep != '\0')
				log_fatal("parse_args: invalid numeric arg "
				    "to -r (%s)", optarg);
			regrand = 1;
#else
			usage();
#endif
@


1.98
log
@Log when isakmpd starts - patch from Toni Mueller
ok ho@@ mpf@@ krw@@ sthen@@ kjell@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.97 2008/05/12 19:15:02 pyr Exp $	 */
a34 1
#include <sys/param.h>
@


1.97
log
@Error out with usage line if additional arguments are given after the
option parsing. Found out the hard way by jdixon on ifstated.

ok sobrado@@, jdixon@@, millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.96 2007/04/02 08:08:32 moritz Exp $	 */
d401 1
@


1.96
log
@Don't let -r fall through to the next case block,
if INSECURE_RAND is defined.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.95 2006/09/01 00:24:06 mpf Exp $	 */
d236 3
@


1.95
log
@Add a new UI command to force isakmpd into passive only mode.
Will be used by sasyncd to prevent two talking isakmpd's in an HA setup.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.94 2006/08/30 16:56:56 hshoexer Exp $	 */
d210 1
a211 1
#endif
@


1.94
log
@Make SA deletion on shutdown the default again.  Use -S for failover
situations where you do not want this.

Discussed and agreed on with ho, mcbride, markus, cloder,...  We
will have to teach sasyncd to deal with this.

Testing by msf and hshoexer with help from mtu

ok markus cloder
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.93 2006/06/10 21:15:45 hshoexer Exp $	 */
d218 1
@


1.93
log
@Make deletion of SAs on shutdown optional.  The default behaviour
now is to not delete SAs.  Needed for reliable ipsec failover.
Suggested by mtu@@.  Moreover, this ensures that packets do not leak
when isakmpd is shutdown.

ok mcbride@@, testing mtu@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.92 2006/06/01 01:39:16 hshoexer Exp $	 */
d79 1
a79 1
int		delete_sas = 0;
d217 1
a217 1
			delete_sas = 1;
d320 2
a321 2
		if (delete_sas ||
		    !strncmp("yes", conf_get_str("General", "Delete-SAs"), 3)) {
@


1.92
log
@Fix a comment
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.91 2006/03/20 16:43:22 hshoexer Exp $	 */
d78 3
d116 1
a116 1
	    "usage: %s [-46adKLnTv] [-c config-file] [-D class=level] [-f fifo]\n"
d133 1
a133 1
	while ((ch = getopt(argc, argv, "46ac:dD:f:i:KnN:p:Ll:r:R:Tv")) != -1) {
d216 4
d320 8
a327 6
		/*
		 * Delete all active SAs.  First IPsec SAs, then ISAKMPD.
		 * Each DELETE is another (outgoing) message.
		 */
		while ((sa = sa_find(phase2_sa_check, NULL)))
			sa_delete(sa, 1);
d329 3
a331 2
		while ((sa = sa_find(phase1_sa_check, NULL)))
			sa_delete(sa, 1);
@


1.91
log
@make sure the command fifo is ready before isakmpd returns.  This
resolves a startup race when interacting with ipsecctl.  Suggested
by and discussed with moritz@@

ok moritz@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.90 2005/12/20 22:03:53 moritz Exp $	 */
d75 1
a75 1
/* Set when no policy file is found. */
@


1.90
log
@let isakmpd(8) remove it's pid/fifo file on exit.
rework signal handling in the monitor process to
let this work. testing and ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.89 2005/06/25 23:20:43 hshoexer Exp $	 */
d391 3
@


1.89
log
@/* Fallthrough. */ -> /* FALLTHROUGH */
now that's useable with lint
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.88 2005/05/26 20:40:50 hshoexer Exp $	 */
d102 1
a102 1
static char    *pid_file = "/var/run/isakmpd.pid";
a332 3
		/* Remove FIFO and pid files.  */
		unlink(ui_fifo);
		unlink(pid_file);
a351 1
	/* Ignore errors. This fails with privsep.  */
d354 1
a354 1
	fp = monitor_fopen(pid_file, "w");
d401 2
a410 2

	write_pid_file();
@


1.88
log
@Add ARGSUSED for lint, one comment for me
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.87 2005/05/03 14:03:11 moritz Exp $	 */
d191 1
a191 1
			/* Fallthrough intended.  */
@


1.87
log
@Remove SIGUSR2-related stuff as suggested by ho@@.
SA rehashing won't happen anytime soon. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.86 2005/05/03 13:09:45 moritz Exp $	 */
d233 1
d322 2
d342 1
@


1.86
log
@fix signal race, when child dies before the monitor
sets it's signal handlers. ok hshoexer@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.85 2005/04/10 14:17:49 jmc Exp $	 */
a92 7
 * If we receive a USR2 signal, this flag gets set to show we need to
 * rehash our SA soft expiration timers to a uniform distribution.
 * XXX Perhaps this is a really bad idea?
 */
volatile sig_atomic_t sigusr2ed = 0;

/*
a267 18
/* Rehash soft expiration timers on SIGUSR2.  */
static void
rehash_timers(void)
{
#if 0
	/* XXX - not yet */
	log_print("SIGUSR2 received, rehashing soft expiration timers.");

	timer_rehash_timers();
#endif
}

static void
sigusr2(int sig)
{
	sigusr2ed = 1;
}

a300 3

	/* Rehash soft expiration timers on USR2 reception.  */
	signal(SIGUSR2, sigusr2);
a441 6
		}
		/* and if someone sent SIGUSR2, do a timer rehash.  */
		if (sigusr2ed) {
			sigusr2ed = 0;
			log_print("SIGUSR2 received");
			rehash_timers();
@


1.85
log
@- sort synopsis + options list
- sync usage()
- tidy up lists and displays
- misc tweaks
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.84 2005/04/08 22:32:10 cloder Exp $	 */
d106 1
d305 26
a410 3
	for (n = 1; n < _NSIG; n++)
		signal(n, SIG_DFL);

d420 1
a420 8
	/*
	 * Do a clean daemon shutdown on TERM/INT. These signals must be
	 * initialized before monitor_init(). INT is only used with '-d'.
         */
	signal(SIGTERM, daemon_shutdown_now);
	if (debug == 1)		/* i.e '-dd' will skip this.  */
		signal(SIGINT, daemon_shutdown_now);

a438 9

	/* Reinitialize on HUP reception.  */
	signal(SIGHUP, sighup);

	/* Report state on USR1 reception.  */
	signal(SIGUSR1, sigusr1);

	/* Rehash soft expiration timers on USR2 reception.  */
	signal(SIGUSR2, sigusr2);
@


1.84
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.83 2005/04/08 19:40:03 deraadt Exp $	 */
d119 3
a121 4
	    "usage: %s [-4] [-6] [-a] [-c config-file] [-d] [-D class=level]\n"
	    "          [-f fifo] [-i pid-file] [-K] [-n] [-N udpencap-port]\n"
	    "          [-p listen-port] [-L] [-l packetlog-file] [-r seed]\n"
	    "          [-R report-file] [-T] [-v]\n",
@


1.83
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.82 2005/04/08 17:15:01 deraadt Exp $	 */
a46 2
#include "sysdep.h"

d131 1
d133 1
d205 1
d212 2
d215 1
a215 1

@


1.82
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.81 2005/04/08 16:37:14 deraadt Exp $	 */
a111 1
#ifdef USE_DEBUG
a113 1
#endif
a133 1
#ifdef USE_DEBUG
a135 1
#endif
a158 1
#ifdef USE_DEBUG
a170 1
#endif				/* USE_DEBUG */
a195 1
#ifdef USE_DEBUG
a202 1
#endif				/* USE_DEBUG */
a232 1
#ifdef USE_DEBUG
a234 1
#endif
a327 1
#ifdef USE_DEBUG
a328 1
#endif
a429 1
#if defined (USE_DEBUG)
a432 1
#endif
@


1.81
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.80 2005/04/08 16:24:12 deraadt Exp $	 */
a66 1
#ifdef USE_POLICY
a67 1
#endif
a185 1
#ifdef USE_POLICY
a188 1
#endif
@


1.80
log
@privsep always
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.79 2005/04/08 16:11:58 deraadt Exp $	 */
a197 1
#if defined(USE_NAT_TRAVERSAL)
a200 1
#endif
a228 1
#if defined(USE_NAT_TRAVERSAL)
a231 1
#endif
@


1.79
log
@kill HAVE_CLOSEFROM
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.78 2005/04/08 15:47:24 deraadt Exp $	 */
d370 1
a370 1
	/* Ignore errors. This will fail with USE_PRIVSEP.  */
a429 1
#if defined (USE_PRIVSEP)
a435 1
#endif
a467 1
#if defined (USE_PRIVSEP)
a468 1
#endif
@


1.78
log
@more __progname
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.77 2005/04/08 15:44:13 deraadt Exp $	 */
a391 1
#if defined (HAVE_CLOSEFROM) && (!defined (OpenBSD) || (OpenBSD >= 200405))
a392 5
#else
	m = getdtablesize();
	for (n = STDERR_FILENO + 1; n < m; n++)
		(void) close(n);
#endif
@


1.77
log
@use __progname
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.76 2005/04/05 18:06:06 cloder Exp $	 */
d122 2
@


1.76
log
@Add -T flag to isakmpd to disable NAT-T support from the command line.
This lets binat setups work again without having to recompile isakmpd.
OK ho, hshoexer.
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.75 2005/04/04 19:31:11 deraadt Exp $	 */
d127 1
a127 1
	    sysdep_progname());
@


1.75
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.74 2005/03/22 17:27:59 cloder Exp $	 */
d55 1
d57 1
d126 1
a126 1
	    "          [-R report-file] [-v]\n",
d141 1
a141 1
	while ((ch = getopt(argc, argv, "46ac:dD:f:i:KnN:p:Ll:r:R:v")) != -1) {
d196 1
a196 1
#ifdef USE_NAT_TRAVERSAL
d228 6
@


1.74
log
@Compile when nat_traversal is disabled.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.73 2005/02/27 13:12:12 hshoexer Exp $	 */
d166 1
a166 1
					     cls++)
d320 1
a320 1
		 * Delete all active SAs.  First IPsec SAs, then ISAKMPD. 
d334 1
a334 1
	         */
d493 1
a493 1
	         *
d501 1
a501 1
	         */
d516 1
a516 1
	         */
d542 1
a542 1
			         */
@


1.73
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.72 2005/02/25 14:21:20 hshoexer Exp $	 */
d194 1
d198 1
@


1.72
log
@forgot to remove -P from getopt().
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.71 2005/02/25 14:14:31 hshoexer Exp $	 */
d504 1
a504 1
		memset(rfds, 0, mask_size);
d521 1
a521 1
		memset(wfds, 0, mask_size);
@


1.71
log
@Zap -P option.  It has never done anything.  While there tweak descripton of
-N.

zap -P ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.70 2005/02/24 13:55:51 hshoexer Exp $	 */
d139 1
a139 1
	while ((ch = getopt(argc, argv, "46ac:dD:f:i:KnN:p:P:Ll:r:R:v")) != -1) {
@


1.70
log
@Add -N switch to select port for udpencap.  Thus it's possible to run multiple
isakmpds on different ports specified with -p and -N.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.69 2005/02/16 22:00:14 hshoexer Exp $	 */
d123 2
a124 2
	    "          [-p listen-port] [-P local-port] [-L]\n"
	    "          [-l packetlog-file] [-r seed] [-R report-file] [-v]\n",
a199 4
			break;

		case 'P':
			udp_bind_port = optarg;
@


1.69
log
@On shutdown also send delete messages for isakmp SAs.

ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.68 2004/09/17 14:54:09 hshoexer Exp $	 */
d60 1
d122 3
a124 3
	    "          [-f fifo] [-i pid-file] [-K] [-n] [-p listen-port]\n"
	    "          [-P local-port] [-L] [-l packetlog-file] [-r seed]\n"
	    "          [-R report-file] [-v]\n",
d139 1
a139 1
	while ((ch = getopt(argc, argv, "46ac:dD:f:i:Knp:P:Ll:r:R:v")) != -1) {
d192 4
@


1.68
log
@avoid signal race.

ok ho@@ otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.67 2004/06/25 20:25:34 hshoexer Exp $	 */
d301 6
d316 8
a323 3
		/* Delete all active phase 2 SAs.  */
		while ((sa = sa_find(phase2_sa_check, NULL))) {
			/* Each DELETE is another (outgoing) message.  */
a324 1
		}
@


1.67
log
@Keynote policy checking can now be disabled by "-K" switch and config tag
"Use-Keynote".  Default is to use keynote.

ok henning@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.65 2004/06/20 15:03:35 ho Exp $	 */
a268 2

	sigusr1ed = 0;
a286 2

	sigusr2ed = 0;
d460 1
a462 1
			sighupped = 0;
d466 1
d472 1
@


1.66
log
@Add commandline switch -a / config tag "Acquire-Only" to tell isakmpd to not
touch flows.

initial work by markus
ok markus@@ ho@@ henning@@
@
text
@d121 1
a121 1
	    "          [-f fifo] [-i pid-file] [-n] [-p listen-port]\n"
d138 1
a138 1
	while ((ch = getopt(argc, argv, "46ac:dD:f:i:np:P:Ll:r:R:v")) != -1) {
d182 6
@


1.65
log
@To make debugging the unprivileged child process easier, make 'isakmpd -dd'
pause just after privsep; print the PIDs and wait for SIGCONT.
hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.64 2004/06/14 09:55:41 ho Exp $	 */
d76 3
d120 1
a120 1
	    "usage: %s [-4] [-6] [-c config-file] [-d] [-D class=level]\n"
d138 1
a138 1
	while ((ch = getopt(argc, argv, "46c:dD:f:i:np:P:Ll:r:R:v")) != -1) {
d146 4
@


1.64
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.63 2004/05/23 18:17:56 hshoexer Exp $	 */
d405 1
a405 1
	if (monitor_init()) {
@


1.63
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.62 2004/05/19 14:30:26 ho Exp $	 */
d157 2
a158 1
					for (cls = 0; cls < LOG_ENDCLASS; cls++)
d406 1
a406 1
		/* The parent, with privileges enters infinite monitor loop.  */
d498 1
a498 1
		/* Setup the descriptors that have pending messages to send.  */
@


1.62
log
@Permit symbolic protocol and service names, such as "Protocol= tcp", in the
<IPsec-ID> sections. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.61 2004/04/15 18:39:26 deraadt Exp $	 */
d160 2
a161 1
					log_print("parse_args: -D argument unparseable: %s", optarg);
d201 2
a202 1
				log_fatal("parse_args: invalid numeric arg to -r (%s)", optarg);
d286 1
a286 1
phase2_sa_check(struct sa * sa, void *arg)
d295 1
a295 1
	struct sa      *sa;
d335 1
a335 1
	FILE           *fp;
d343 2
a344 2
			log_error("write_pid_file: failed to write PID to \"%.100s\"",
			    pid_file);
d347 2
a348 1
		log_fatal("write_pid_file: fopen (\"%.100s\", \"w\") failed", pid_file);
d436 2
a437 1
		log_fatal("main: malloc (%lu) failed", (unsigned long) mask_size);
d440 2
a441 1
		log_fatal("main: malloc (%lu) failed", (unsigned long) mask_size);
d465 3
a467 2
		 * and if someone set 'sigtermed' (SIGTERM, SIGINT or via the UI),
		 * this indicates we should start a controlled shutdown of the daemon.
d469 7
a475 6
		 * Note: Since _one_ message is sent per iteration of this enclosing
		 * while-loop, and we want to send a number of DELETE notifications,
		 * we must loop atleast this number of times. The daemon_shutdown()
		 * function starts by queueing the DELETEs, all other calls just
		 * increments the 'sigtermed' variable until it reaches a "safe"
		 * value, and the daemon exits.
d488 3
a490 2
		 * XXX Some day we might want to deal with an abstract application
		 * class instead, with many instantiations possible.
d525 2
a526 1
			if (!app_none && app_socket >= 0 && FD_ISSET(app_socket, rfds))
@


1.61
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: isakmpd.c,v 1.60 2004/04/08 10:05:54 hshoexer Exp $	 */
d43 1
d379 4
@


1.60
log
@Set timezone before privsep, child uses now correct timezone.
Noticed by david@@

ok ho@@ david@@
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.59 2004/03/31 10:47:16 ho Exp $	*/
/*	$EOM: isakmpd.c,v 1.54 2000/10/05 09:28:22 niklas Exp $	*/
d67 1
a67 1
static void usage (void);
d73 1
a73 1
int debug = 0;
d87 1
a87 1
static char *report_file = "/var/run/isakmpd.report";
d102 1
a102 1
void daemon_shutdown_now (int);
d105 1
a105 1
static char *pid_file = "/var/run/isakmpd.pid";
d109 1
a109 1
static char *pcap_file = 0;
d113 1
a113 1
usage (void)
d115 7
a121 7
  fprintf (stderr,
	   "usage: %s [-4] [-6] [-c config-file] [-d] [-D class=level]\n"
	   "          [-f fifo] [-i pid-file] [-n] [-p listen-port]\n"
	   "          [-P local-port] [-L] [-l packetlog-file] [-r seed]\n"
	   "          [-R report-file] [-v]\n",
	   sysdep_progname ());
  exit (1);
d125 1
a125 1
parse_args (int argc, char *argv[])
d127 2
a128 2
  int ch;
  char *ep;
d130 2
a131 2
  int cls, level;
  int do_packetlog = 0;
d134 17
a150 17
  while ((ch = getopt (argc, argv, "46c:dD:f:i:np:P:Ll:r:R:v")) != -1) {
    switch (ch) {
    case '4':
      bind_family |= BIND_FAMILY_INET4;
      break;

    case '6':
      bind_family |= BIND_FAMILY_INET6;
      break;

    case 'c':
      conf_path = optarg;
      break;

    case 'd':
      debug++;
      break;
d153 31
a183 35
    case 'D':
      if (sscanf (optarg, "%d=%d", &cls, &level) != 2)
	{
	    if (sscanf (optarg, "A=%d", &level) == 1)
	      {
		  for (cls = 0; cls < LOG_ENDCLASS; cls++)
		    log_debug_cmd (cls, level);
	      }
	    else
	      log_print ("parse_args: -D argument unparseable: %s", optarg);
	}
      else
	log_debug_cmd (cls, level);
      break;
#endif /* USE_DEBUG */

    case 'f':
      ui_fifo = optarg;
      break;

    case 'i':
      pid_file = optarg;
      break;

    case 'n':
      app_none++;
      break;

    case 'p':
      udp_default_port = optarg;
      break;

    case 'P':
      udp_bind_port = optarg;
      break;
d186 32
a217 32
    case 'l':
      pcap_file = optarg;
      /* Fallthrough intended.  */

    case 'L':
      do_packetlog++;
      break;
#endif /* USE_DEBUG */

    case 'r':
      seed = strtoul (optarg, &ep, 0);
      srandom (seed);
      if (*ep != '\0')
	log_fatal ("parse_args: invalid numeric arg to -r (%s)", optarg);
      regrand = 1;
      break;

    case 'R':
      report_file = optarg;
      break;

    case 'v':
      verbose_logging = 1;
      break;

    case '?':
    default:
      usage ();
    }
  }
  argc -= optind;
  argv += optind;
d220 2
a221 2
  if (do_packetlog && !pcap_file)
    pcap_file = PCAP_FILE_DEFAULT;
d226 1
a226 1
sighup (int sig)
d228 1
a228 1
  sighupped = 1;
d233 1
a233 1
report (void)
d235 2
a236 2
  FILE *rfp, *old;
  mode_t old_umask;
d238 14
a251 16
  old_umask = umask (S_IRWXG | S_IRWXO);
  rfp = monitor_fopen (report_file, "w");
  umask (old_umask);

  if (!rfp)
    {
      log_error ("report: fopen (\"%s\", \"w\") failed", report_file);
      return;
    }

  /* Divert the log channel to the report file during the report.  */
  old = log_current ();
  log_to (rfp);
  ui_report ("r");
  log_to (old);
  fclose (rfp);
d253 1
a253 1
  sigusr1ed = 0;
d257 1
a257 1
sigusr1 (int sig)
d259 1
a259 1
  sigusr1ed = 1;
d264 1
a264 1
rehash_timers (void)
d267 2
a268 2
  /* XXX - not yet */
  log_print ("SIGUSR2 received, rehashing soft expiration timers.");
d270 1
a270 1
  timer_rehash_timers ();
d273 1
a273 1
  sigusr2ed = 0;
d277 1
a277 1
sigusr2 (int sig)
d279 1
a279 1
  sigusr2ed = 1;
d283 1
a283 1
phase2_sa_check (struct sa *sa, void *arg)
d285 1
a285 1
  return sa->phase == 2;
d289 1
a289 1
daemon_shutdown (void)
d291 5
a295 2
  /* Perform a (protocol-wise) clean shutdown of the daemon.  */
  struct sa *sa;
d297 6
a302 9
  if (sigtermed == 1)
    {
      log_print ("isakmpd: shutting down...");

      /* Delete all active phase 2 SAs.  */
      while ((sa = sa_find (phase2_sa_check, NULL)))
	{
	  /* Each DELETE is another (outgoing) message.  */
	  sa_delete (sa, 1);
d304 5
a308 2
      sigtermed++;
    }
a309 7
  if (transport_prio_sendqs_empty ())
    {
      /*
       * When the prioritized transport sendq:s are empty, i.e all
       * the DELETE notifications have been sent, we can shutdown.
       */
	
d311 1
a311 1
      log_packet_stop ();
d313 6
a318 6
      /* Remove FIFO and pid files.  */
      unlink (ui_fifo);
      unlink (pid_file);
      log_print ("isakmpd: exit");
      exit (0);
    }
d323 1
a323 1
daemon_shutdown_now (int sig)
d325 1
a325 1
  sigtermed = 1;
d330 1
a330 1
write_pid_file (void)
d332 1
a332 1
  FILE *fp;
d334 2
a335 2
  /* Ignore errors. This will fail with USE_PRIVSEP.  */
  unlink (pid_file);
d337 8
a344 10
  fp = monitor_fopen (pid_file, "w");
  if (fp != NULL)
    {
      if (fprintf (fp, "%ld\n", (long) getpid ()) < 0)
	log_error ("write_pid_file: failed to write PID to \"%.100s\"",
	           pid_file);
      fclose (fp);
    }
  else
    log_fatal ("write_pid_file: fopen (\"%.100s\", \"w\") failed", pid_file);
d348 1
a348 1
main (int argc, char *argv[])
d350 4
a353 4
  fd_set *rfds, *wfds;
  int n, m;
  size_t mask_size;
  struct timeval tv, *timeout;
d356 1
a356 1
  closefrom (STDERR_FILENO + 1);
d358 3
a360 3
  m = getdtablesize ();
  for (n = STDERR_FILENO + 1; n < m; n++)
    (void)close (n);
d363 28
a390 25
  /* Make sure init() won't alloc fd 0, 1 or 2, as daemon() will close them. */
  for (n = 0; n <= 2; n++)
    if (fcntl (n, F_GETFL, 0) == -1 && errno == EBADF)
      (void)open ("/dev/null", n ? O_WRONLY : O_RDONLY, 0);

  for (n = 1; n < _NSIG; n++)
    signal (n, SIG_DFL);

  /* Log cmd line parsing and initialization errors to stderr.  */
  log_to (stderr);
  parse_args (argc, argv);
  log_init (debug);

  /*
   * Do a clean daemon shutdown on TERM/INT. These signals must be
   * initialized before monitor_init(). INT is only used with '-d'.
   */
  signal (SIGTERM, daemon_shutdown_now);
  if (debug == 1) /* i.e '-dd' will skip this.  */
    signal (SIGINT, daemon_shutdown_now);

  /* Daemonize before forking unpriv'ed child */
  if (!debug)
    if (daemon (0, 0))
      log_fatal ("main: daemon (0, 0) failed");
d392 2
a393 2
  /* Set timezone before priv'separation */
  tzset();
d396 6
a401 8
  if (monitor_init ())
    {
      /* The parent, with privileges enters infinite monitor loop.  */
      monitor_loop (debug);
      exit (0); /* Never reached.  */
    }

  /* Child process only from this point on, no privileges left.  */
d404 1
a404 1
  init ();
d406 1
a406 1
  write_pid_file ();
d408 2
a409 2
  /* Reinitialize on HUP reception.  */
  signal (SIGHUP, sighup);
d411 2
a412 2
  /* Report state on USR1 reception.  */
  signal (SIGUSR1, sigusr1);
d414 2
a415 2
  /* Rehash soft expiration timers on USR2 reception.  */
  signal (SIGUSR2, sigusr2);
d418 3
a420 3
  /* If we wanted IKE packet capture to file, initialize it now.  */
  if (pcap_file != 0)
    log_packet_init (pcap_file);
d423 9
a431 9
  /* Allocate the file descriptor sets just big enough.  */
  n = getdtablesize ();
  mask_size = howmany (n, NFDBITS) * sizeof (fd_mask);
  rfds = (fd_set *)malloc (mask_size);
  if (!rfds)
    log_fatal ("main: malloc (%lu) failed", (unsigned long)mask_size);
  wfds = (fd_set *)malloc (mask_size);
  if (!wfds)
    log_fatal ("main: malloc (%lu) failed", (unsigned long)mask_size);
d434 1
a434 1
  monitor_init_done();
d437 79
a515 89
  while (1)
    {
      /* If someone has sent SIGHUP to us, reconfigure.  */
      if (sighupped)
	{
	  log_print ("SIGHUP received");
	  reinit ();
	  sighupped = 0;
	}

      /* and if someone sent SIGUSR1, do a state report.  */
      if (sigusr1ed)
	{
	  log_print ("SIGUSR1 received");
	  report ();
	}

      /* and if someone sent SIGUSR2, do a timer rehash.  */
      if (sigusr2ed)
	{
	  log_print ("SIGUSR2 received");
	  rehash_timers ();
	}

      /*
       * and if someone set 'sigtermed' (SIGTERM, SIGINT or via the UI),
       * this indicates we should start a controlled shutdown of the daemon.
       *
       * Note: Since _one_ message is sent per iteration of this enclosing
       * while-loop, and we want to send a number of DELETE notifications,
       * we must loop atleast this number of times. The daemon_shutdown()
       * function starts by queueing the DELETEs, all other calls just
       * increments the 'sigtermed' variable until it reaches a "safe"
       * value, and the daemon exits.
       */
      if (sigtermed)
	daemon_shutdown ();

      /* Setup the descriptors to look for incoming messages at.  */
      memset (rfds, 0, mask_size);
      n = transport_fd_set (rfds);
      FD_SET (ui_socket, rfds);
      if (ui_socket + 1 > n)
	n = ui_socket + 1;

      /*
       * XXX Some day we might want to deal with an abstract application
       * class instead, with many instantiations possible.
       */
      if (!app_none && app_socket >= 0)
	{
	  FD_SET (app_socket, rfds);
	  if (app_socket + 1 > n)
	    n = app_socket + 1;
	}

      /* Setup the descriptors that have pending messages to send.  */
      memset (wfds, 0, mask_size);
      m = transport_pending_wfd_set (wfds);
      if (m > n)
	n = m;

      /* Find out when the next timed event is.  */
      timeout = &tv;
      timer_next_event (&timeout);

      n = select (n, rfds, wfds, 0, timeout);
      if (n == -1)
	{
	  if (errno != EINTR)
	    {
	      log_error ("main: select");

	      /*
	       * In order to give the unexpected error condition time to
	       * resolve without letting this process eat up all available CPU
	       * we sleep for a short while.
	       */
	      sleep (1);
	    }
	}
      else if (n)
	{
	  transport_handle_messages (rfds);
	  transport_send_messages (wfds);
	  if (FD_ISSET (ui_socket, rfds))
	    ui_handler ();
	  if (!app_none && app_socket >= 0 && FD_ISSET (app_socket, rfds))
	    app_handler ();
a516 2
      timer_handle_expirations ();
    }
@


1.59
log
@Don't assume closefrom(2) exists everywhere. hshoexer@@, markus@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.58 2004/03/19 14:04:43 hshoexer Exp $	*/
d42 1
d400 3
@


1.58
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.57 2004/02/19 15:35:16 hshoexer Exp $	*/
d366 1
d368 5
@


1.57
log
@small cleanup of log messages.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.56 2004/02/19 09:54:52 ho Exp $	*/
d366 2
d373 3
d389 5
d397 1
a397 6
      /* The parent, with privileges.  */
      if (!debug)
	if (daemon (0, 0))
	  log_fatal ("main [priv]: daemon (0, 0) failed");

      /* Enter infinite monitor loop.  */
a406 4
  if (!debug)
    if (daemon (0, 0))
      log_fatal ("main: daemon (0, 0) failed");

d433 4
@


1.56
log
@With -d, SIGINT should do a clean shutdown.
Without -d, logs should be sent to syslog, level LOG_INFO.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.55 2004/02/19 09:46:19 ho Exp $	*/
d247 1
a247 1
      log_error ("fopen (\"%s\", \"w\") failed", report_file);
d350 2
a351 1
	log_error ("main: failed to write PID to \"%.100s\"", pid_file);
d355 1
a355 1
    log_fatal ("main: fopen (\"%.100s\", \"w\") failed", pid_file);
d504 1
a504 1
	      log_error ("select");
@


1.55
log
@Cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.54 2004/01/16 10:51:57 hshoexer Exp $	*/
d98 1
d330 1
a330 1
/* Called on SIGTERM, or by ui_shutdown_daemon().  */
d373 1
a373 1
  log_init ();
d375 4
a378 1
  /* Do a clean daemon shutdown on TERM reception. (Needed by monitor).  */
d380 2
d402 2
a403 6
    {
      if (daemon (0, 0))
	log_fatal ("main: daemon (0, 0) failed");
      /* Switch to syslog.  */
      log_to (0);
    }
d457 2
a458 2
       * and if someone set 'sigtermed' (SIGTERM or via the UI), this
       * indicated we should start a shutdown of the daemon.
@


1.54
log
@Added -v option.  Enables logging of successful exchange completion.
ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.53 2003/06/04 07:31:17 ho Exp $	*/
d342 1
a342 1
  /* Ignore errors. XXX Will fail with USE_PRIVSEP.  */
d348 2
a349 2
      /* XXX Error checking!  */
      fprintf (fp, "%ld\n", (long) getpid ());
d353 1
a353 1
    log_fatal ("main: fopen (\"%s\", \"w\") failed", pid_file);
@


1.53
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.52 2003/05/18 19:37:46 ho Exp $	*/
d117 1
a117 1
	   "          [-R report-file]\n",
d132 1
a132 1
  while ((ch = getopt (argc, argv, "46c:dD:f:i:np:P:Ll:r:R:")) != -1) {
d207 4
@


1.52
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.51 2003/05/15 00:28:53 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.51
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.50 2003/05/14 18:08:27 ho Exp $	*/
d256 1
a256 1
  monitor_fclose (rfp);
d351 1
a351 1
      monitor_fclose (fp);
@


1.50
log
@Fix a typo (in unused code).
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.49 2003/04/14 13:08:42 ho Exp $	*/
d58 1
d242 1
a242 1
  rfp = fopen (report_file, "w");
d256 1
a256 1
  fclose (rfp);
d343 1
a343 1
  /* Ignore errors.  */
d346 1
a346 1
  fp = fopen (pid_file, "w");
d351 1
a351 1
      fclose (fp);
d373 21
d415 1
a415 4
  /* Do a clean daemon shutdown on TERM reception.  */
  signal (SIGTERM, daemon_shutdown_now);

#ifdef USE_DEBUG
@


1.49
log
@Unlink FIFO and pid files on clean shutdown. PR#3199
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.48 2002/12/03 20:05:10 ho Exp $	*/
d272 1
a272 1
  log_print ("SIGUSR2 received, rehasing soft expiration timers.");
@


1.48
log
@Add -4/-6 cmdline options to select what address family (IPv4,v6) to use.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.47 2002/11/27 15:29:20 ho Exp $	*/
d321 3
@


1.47
log
@Make sure daemon() does not close any fd opened during initialization.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.46 2002/11/21 12:09:20 ho Exp $	*/
d118 4
a121 3
	   "usage: %s [-c config-file] [-d] [-D class=level] [-f fifo]\n"
	   "          [-i pid-file] [-n] [-p listen-port] [-P local-port]\n"
	   "          [-L] [-l packetlog-file] [-r seed] [-R report-file]\n",
d136 1
a136 1
  while ((ch = getopt (argc, argv, "c:dD:f:i:np:P:Ll:r:R:")) != -1) {
d138 8
@


1.46
log
@-Wshadow nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.45 2002/07/05 13:58:50 ho Exp $	*/
d48 1
d352 6
d361 1
@


1.45
log
@volatile sig_atomic_t, suggested by Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.44 2002/06/14 21:34:58 todd Exp $	*/
d227 1
a227 1
  FILE *report, *old;
d231 1
a231 1
  report = fopen (report_file, "w");
d234 1
a234 1
  if (!report)
d242 1
a242 1
  log_to (report);
d245 1
a245 1
  fclose (report);
@


1.44
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.43 2002/06/09 08:13:06 todd Exp $	*/
d81 1
a81 1
static int sighupped = 0;
d88 1
a88 1
static int sigusr1ed = 0;
d96 1
a96 1
static int sigusr2ed = 0;
d102 1
a102 1
static int sigtermed = 0;
@


1.43
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.42 2002/06/07 01:07:18 ho Exp $	*/
d99 1
a99 1
 * If we recieve a TERM signal, perform a "clean shutdown" of the daemon.
@


1.42
log
@Before detaching, log output should go to stderr, not syslog.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.41 2002/06/01 07:44:21 deraadt Exp $	*/
d304 1
a304 1
       * When the prioritized transport sendq:s are empty, i.e all 
d307 1
a307 1
	 
d421 1
a421 1
       * while-loop, and we want to send a number of DELETE notifications, 
@


1.41
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.40 2002/05/26 09:24:35 deraadt Exp $	*/
d351 1
@


1.40
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.39 2001/12/11 01:54:34 ho Exp $	*/
d386 1
a386 1
    log_fatal ("main: malloc (%d) failed", mask_size);
d389 1
a389 1
    log_fatal ("main: malloc (%d) failed", mask_size);
@


1.39
log
@Don't hang waiting for select() with SIGTERM + no active SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.38 2001/12/10 03:34:51 ho Exp $	*/
d336 1
a336 1
      fprintf (fp, "%d\n", getpid ());
@


1.38
log
@Add UI option 'R' to trigger isakmpd reinit (same as SIGHUP).
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.37 2001/10/26 11:37:16 ho Exp $	*/
d300 2
a301 1
  else if (transport_prio_sendqs_empty ())
d316 1
a316 1
/* called on SIGTERM */
@


1.37
log
@Sometimes the daemon will not die promptly on SIGTERM, even though
all DELETE notifications is sent out.  Create a prioritized send-queue
for the DELETE messages to solve this. Some (C)-2001.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.36 2001/08/24 13:53:02 ho Exp $	*/
a216 53
/* Reinitialize after a SIGHUP reception.  */
static void
reinit (void)
{
  log_print ("SIGHUP received, reinitializing daemon.");

  /*
   * XXX Remove all(/some?) pending exchange timers? - they may not be
   *     possible to complete after we've re-read the config file.
   *     User-initiated SIGHUP's maybe "authorizes" a wait until
   *     next connection-check.
   * XXX This means we discard exchange->last_msg, is this really ok?
   */

  /* Reinitialize PRNG if we are in deterministic mode.  */
  if (regrand)
    srandom (seed);

  /* Reread config file.  */
  conf_reinit ();

  /* Try again to link in libcrypto (good if we started without /usr).  */
  libcrypto_init ();

  /* Set timezone */
  tzset ();

#ifdef USE_POLICY
  /* Reread the policies.  */
  policy_init ();
#endif

  /* Reinitialize certificates */
  cert_init ();

  /* Reinitialize our connection list.  */
  connection_reinit ();

  /*
   * Rescan interfaces.
   */
  transport_reinit ();

  /*
   * XXX "These" (non-existant) reinitializations should not be done.
   *   cookie_reinit ();
   *   ui_reinit ();
   *   sa_reinit ();
   */

  sighupped = 0;
}

d394 5
a398 1
	reinit ();
d402 4
a405 1
	report ();
d409 4
a412 1
	rehash_timers ();
@


1.36
log
@Send DELETE notifications for all active SAs when we shut down the daemon.
This "clean" shutdown happens on SIGTERM ('kill <pid>') or if a 'Q' command
is input to the fifo UI. Suggested by <Ghislaine.Labouret@@hsc.fr>.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.35 2001/08/23 23:11:02 angelos Exp $	*/
d7 1
a7 1
 * Copyright (c) 1999, 2000 Håkan Olsson.  All rights reserved.
a339 1
  static int msg_counter = 0;
a348 1
	  msg_counter++;
d351 4
a354 1

d356 2
a357 4
       * As there may have been other messages queued before these, we
       * add a 'grace factor' to make sure all the DELETEs actually get
       * sent before we shut down. The select() loop will just spin
       * a number of more times before we actually do the exit.
d359 1
a359 7
      msg_counter = ++msg_counter * 2;

      /* XXX Phase 1, transports, timers, exchanges, connections, ...?  */
    }
  else if (sigtermed >= msg_counter)
    {
      /* Goodbye.  */
a365 2

  sigtermed++;
@


1.35
log
@Reinitialize transports on SIGUP.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.34 2001/08/23 14:17:08 aaron Exp $	*/
d57 1
d91 14
a112 7
/*
 * If we receive a USR2 signal, this flag gets set to show we need to
 * rehash our SA soft expiration timers to a uniform distribution.
 * XXX Perhaps this is a really bad idea?
 */
static int sigusr2ed = 0;

d329 55
d433 3
d465 14
@


1.34
log
@recieve -> receive
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.33 2001/07/05 12:36:53 ho Exp $	*/
d248 1
a248 3
   * XXX Rescan interfaces.
   *   transport_reinit ();
   *   udp_reinit ();
d250 1
@


1.33
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.32 2001/07/01 19:59:13 niklas Exp $	*/
d213 1
a213 1
  log_print ("SIGHUP recieved, reinitializing daemon.");
@


1.32
log
@strict strtol checking.  text2sockaddr/sockaddr2text implementations
for systems without get{addr,name}info calls.  Some style police.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.31 2001/06/29 19:41:43 ho Exp $	*/
d68 2
d106 1
a106 1
usage ()
@


1.31
log
@IPv6 support, by niklas@@ and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.30 2001/04/09 22:09:52 ho Exp $	*/
d118 1
d142 1
a142 1
	      }  
d182 4
a185 1
      srandom (strtoul (optarg, 0, 0));
d213 2
a214 2
  /* 
   * XXX Remove all(/some?) pending exchange timers? - they may not be 
d223 1
a223 1
    srandom (strtoul (optarg, 0, 0));
d247 1
a247 1
   *   transport_reinit (); 
d273 1
a273 1
	
d307 1
a307 1
  
d374 1
a374 1
  
d398 1
a398 1
      
@


1.30
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.29 2001/04/09 21:21:57 ho Exp $	*/
d163 1
a163 3
      udp_default_port = udp_decode_port (optarg);
      if (!udp_default_port)
	exit (1);
d167 1
a167 3
      udp_bind_port = udp_decode_port (optarg);
      if (!udp_bind_port)
	exit (1);
@


1.29
log
@isakmpd can now capture un-encrypted IKE negotiation packets to a
file. In pcap(3) format, so tcpdump(8) can read it.
Idea by Tim Newsham <newsham@@lava.net>, work by him and me.
Ok angelos@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.28 2001/04/07 20:36:47 ho Exp $	*/
d240 1
a240 1
  cert_init();
d253 1
a253 1
   *   cookie_reinit();
d333 1
a333 1
      fprintf (fp, "%d\n", getpid());
@


1.28
log
@Add missing filename argument.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.27 2001/01/27 12:03:33 niklas Exp $	*/
d91 5
d109 1
a109 1
	   "          [-r seed] [-R report-file]\n",
d120 1
d123 1
a123 1
  while ((ch = getopt (argc, argv, "c:dD:f:i:np:P:r:R:")) != -1) {
d174 10
d200 5
d357 1
a357 1
  
d369 6
@


1.27
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.26 2001/01/26 12:12:52 niklas Exp $	*/
d259 1
a259 1
      log_error ("fopen (\"%s\", \"w\") failed");
@


1.26
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.25 2000/10/07 06:58:37 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
@


1.25
log
@isakmp_doi.h: Merge with EOM 1.1
isakmpd.c: Merge with EOM 1.54
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.24 2000/06/08 20:51:31 niklas Exp $	*/
d204 1
a204 1
  /* Reread config file. */
d214 1
a214 1
  /* Reread the policies. */
d221 1
a221 1
  /* Reinitialize our connection list. */
@


1.25.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: isakmpd.c,v 1.30 2001/04/09 22:09:52 ho Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
a90 5
#ifdef USE_DEBUG
/* The path of the IKE packet capture log file.  */
static char *pcap_file = 0;
#endif

d104 1
a104 1
	   "          [-L] [-l packetlog-file] [-r seed] [-R report-file]\n",
a114 1
  int do_packetlog = 0;
d117 1
a117 1
  while ((ch = getopt (argc, argv, "c:dD:f:i:np:P:Ll:r:R:")) != -1) {
a167 10
#ifdef USE_DEBUG
    case 'l':
      pcap_file = optarg;
      /* Fallthrough intended.  */

    case 'L':
      do_packetlog++;
      break;
#endif /* USE_DEBUG */

a183 5

#ifdef USE_DEBUG
  if (do_packetlog && !pcap_file)
    pcap_file = PCAP_FILE_DEFAULT;
#endif
d204 1
a204 1
  /* Reread config file.  */
d214 1
a214 1
  /* Reread the policies.  */
d219 1
a219 1
  cert_init ();
d221 1
a221 1
  /* Reinitialize our connection list.  */
d232 1
a232 1
   *   cookie_reinit ();
d259 1
a259 1
      log_error ("fopen (\"%s\", \"w\") failed", report_file);
d312 1
a312 1
      fprintf (fp, "%d\n", getpid ());
d336 1
a336 1

a347 6
#ifdef USE_DEBUG
  /* If we wanted IKE packet capture to file, initialize it now.  */
  if (pcap_file != 0)
    log_packet_init (pcap_file);
#endif
  
@


1.24
log
@Merge with EOM 1.52

author: angelos
Add the -R option in getopt!!!
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.23 2000/05/03 13:47:27 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.52 2000/05/14 20:24:13 angelos Exp $	*/
d7 1
d102 1
a102 1
	   "usage: %s [-d] [-c config-file] [-D class=level] [-f fifo]\n"
@


1.23
log
@Merge with EOM 1.51

author: ho
style fix

author: ho
Create report files with umask 077
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.22 2000/05/02 14:36:30 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.51 2000/05/03 13:22:20 ho Exp $	*/
d116 1
a116 1
  while ((ch = getopt (argc, argv, "c:dD:f:i:np:P:r:")) != -1) {
@


1.22
log
@Merge with EOM 1.49

author: niklas
Consolidate PID writers

author: niklas
save pid in a pidfile, based on code from Lawrence A. Wimble.  Also retry
to dlopen libcrypto after SIGHUP, useful if /usr was mounted in between.

author: ho
Write pid file on start. (angelos@@ ok)
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.21 2000/04/07 22:06:44 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.49 2000/04/27 17:39:17 niklas Exp $	*/
d40 2
d249 6
a254 2
  FILE *report = fopen (report_file, "w");
  FILE *old;
@


1.21
log
@conf.c: Merge with EOM 1.21
isakmpd.c: Merge with EOM 1.46
sa.c: Merge with EOM 1.100
ui.c: Merge with EOM 1.39

author: niklas
error message style
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.20 2000/02/25 17:23:39 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.46 2000/04/07 19:03:25 niklas Exp $	*/
d52 1
d85 3
d99 3
a101 3
	   "usage: %s [-d] [-c config-file] [-D class=level] [-f fifo] [-n]\n"
	   "          [-p listen-port] [-P local-port] [-r seed]\n"
	   "          [-R report-file]\n",
d114 1
a114 1
  while ((ch = getopt (argc, argv, "c:dD:f:np:P:r:")) != -1) {
d145 4
d204 3
d292 20
d329 2
@


1.20
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.19 2000/02/19 19:32:53 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.45 2000/02/20 19:58:39 niklas Exp $	*/
d294 1
a294 1
	log_fatal ("main: daemon");
d313 1
a313 1
    log_fatal ("main: malloc (%d)", mask_size);
d316 1
a316 1
    log_fatal ("main: malloc (%d)", mask_size);
@


1.19
log
@cert.c: Merge with EOM 1.14
ike_auth.c: Merge with EOM 1.43
ike_phase_1.c: Merge with EOM 1.21
init.c: Merge with EOM 1.24
ipsec.c: Merge with EOM 1.117
isakmpd.c: Merge with EOM 1.44
math_group.c: Merge with EOM 1.22

author: niklas
Copyright 2000

author: niklas
Allow isakmpd builders to remove optional parts and save bytes.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.18 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.44 2000/02/19 07:58:56 niklas Exp $	*/
d105 4
a108 1
  int ch, cls, level;
d115 1
d119 2
d135 2
d140 1
d144 1
d150 1
d156 1
d161 1
d165 1
@


1.18
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.17 2000/01/31 08:18:54 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.42 2000/01/31 22:33:46 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
d60 1
a60 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
d185 1
a185 1
#if defined (USE_KEYNOTE) || defined (HAVE_DLOPEN)
@


1.17
log
@Merge with EOM 1.41

author: angelos
Make x509_cert_init() able to re-initialize.

author: angelos
Reinitialize certificates as well.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.16 2000/01/26 15:21:08 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.41 2000/01/31 05:50:59 angelos Exp $	*/
d6 1
@


1.16
log
@isakmpd.c: Merge with EOM 1.39
init.c: Merge with EOM 1.19

author: angelos
GMTTimeOfDay and LocalTimeOfDay attributes, comment in x509.c.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.15 1999/10/01 14:09:20 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.39 1999/10/10 22:48:36 angelos Exp $	*/
d57 1
d189 4
a192 1
  /* Reinitalize our connection list. */
@


1.15
log
@isakmpd.8: Merge with EOM 1.17
isakmpd.c: Merge with EOM 1.38

author: angelos
Allow "-DA=xx" to mean "set all debug classes to level xx"
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.14 1999/08/26 22:31:45 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.38 1999/09/20 19:57:50 angelos Exp $	*/
d179 3
@


1.14
log
@Merge with EOM 1.37

author: niklas
Support dynamic loading of libkeynote too.  Build isakmpd static by default.
Stylistic cleanup of keynote policy code.  Correct some libcrypto calls.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.13 1999/08/05 22:40:57 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.37 1999/08/26 11:21:49 niklas Exp $	*/
d115 9
a123 1
	log_print ("parse_args: -D argument unparseable: %s", optarg);
@


1.13
log
@Merge with EOM 1.36

author: niklas
regrand is in util.h now.  Use new conf_reinit API at SIGHUP time.  Fix
timeout handling in deteerministic mode.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.12 1999/07/07 22:11:45 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.36 1999/08/05 15:01:20 niklas Exp $	*/
d58 1
a58 1
#ifdef USE_KEYNOTE
d172 1
a172 1
#ifdef USE_KEYNOTE
@


1.12
log
@Merge with EOM 1.35

author: ho
Add trap for SIGUSR2. Preliminary use to rehash soft exp. timers.

author: ho
Add keynote policy support (with USE_KEYNOTE). angelos@@openbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.11 1999/06/02 06:28:34 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.35 1999/06/26 23:30:38 ho Exp $	*/
d56 1
a68 5
 * Use -r seed to initalize random numbers to a deterministic sequence.
 */
extern int regrand;

/*
d165 4
d170 1
a170 1
  conf_init ();
d257 1
a257 1
  struct timeval tv, *timeout = &tv;
d327 1
@


1.11
log
@Merge with EOM 1.33

author: ho
Add missing #include

author: ho
Add connection_reinit to SIGHUP handler. Add comments.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.10 1999/04/19 21:09:36 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.33 1999/05/21 14:18:14 ho Exp $	*/
d57 4
d86 7
d172 5
d231 20
d275 3
d298 4
@


1.10
log
@./isakmpd.c: Merge with EOM 1.31

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

Log any SIGHUPs looking our way.

1999 copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.9 1999/03/24 14:43:37 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.31 1999/04/17 23:20:30 niklas Exp $	*/
d49 1
d148 1
a148 2
  /* XXX Remove log message later on? */
  log_debug (LOG_MISC, 80, "reinit: SIGHUP recieved, reinitializing.");
d150 9
a158 1
  /* Reread config file.  */
d161 15
a175 1
  /* XXX Rescan interfaces.  */
@


1.9
log
@Merge with EOM 1.28
Allow the application socket to not exist
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.8 1999/02/26 03:44:42 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.28 1999/03/24 11:01:06 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d128 1
a128 1
      srandom (strtoul (optarg, NULL, 0));
d147 3
@


1.8
log
@Merge from the Ericsson repository
| revision 1.27
| date: 1999/02/25 11:39:09;  author: niklas;  state: Exp;  lines: +3 -2
| include sysdep.h everywhere
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.7 1998/12/22 15:27:40 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.27 1999/02/25 11:39:09 niklas Exp $	*/
d245 1
a245 1
      if (!app_none)
d282 1
a282 1
	  if (!app_none && FD_ISSET (app_socket, rfds))
@


1.7
log
@Size the fd sets from the descriptor table
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.6 1998/12/22 02:25:16 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.26 1998/12/22 15:22:03 niklas Exp $	*/
d45 2
a50 1
#include "sysdep.h"
@


1.6
log
@Generalize udp port decoding.  Remove unneeded decls.
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.5 1998/12/21 01:02:25 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.25 1998/12/22 02:23:44 niklas Exp $	*/
d192 1
a192 1
  fd_set rfds, wfds;
d194 1
d202 1
a202 1
	log_fatal ("daemon");
d213 10
d234 3
a236 3
      FD_ZERO (&rfds);
      n = transport_fd_set (&rfds);
      FD_SET (ui_socket, &rfds);
d246 1
a246 1
	  FD_SET (app_socket, &rfds);
d252 2
a253 2
      FD_ZERO (&wfds);
      m = transport_pending_wfd_set (&wfds);
d260 1
a260 1
      n = select (n, &rfds, &wfds, 0, timeout);
d277 3
a279 3
	  transport_handle_messages (&rfds);
	  transport_send_messages (&wfds);
	  if (FD_ISSET (ui_socket, &rfds))
d281 1
a281 1
	  if (!app_none && FD_ISSET (app_socket, &rfds))
@


1.5
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.4 1998/11/20 07:33:45 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.24 1998/12/01 10:18:43 niklas Exp $	*/
a54 3
extern char *optarg;
extern int optind;

d117 3
a119 1
      udp_default_port = atoi (optarg);
d122 3
a124 1
      udp_bind_port = atoi (optarg);
@


1.4
log
@Do not report select errors on EINTR
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.3 1998/11/17 11:10:15 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.23 1998/11/20 07:13:19 niklas Exp $	*/
d75 8
d88 2
a89 1
	   "          [-p listen-port] [-P local-port] [-r seed]\n",
d129 3
d159 29
d208 3
d216 4
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: isakmpd.c,v 1.2 1998/11/15 00:43:57 niklas Exp $	*/
/*	$EOM: isakmpd.c,v 1.22 1998/10/11 16:19:12 niklas Exp $	*/
d37 1
d203 11
a213 7
	  log_error ("select");
	  /*
	   * In order to give the unexpected error condition time to resolve
	   * without letting this process eat up all available CPU we sleep
	   * for a short while.
	   */
	  sleep (1);
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: isakmpd.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: isakmpd.c,v 1.22 1998/10/11 16:19:12 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
