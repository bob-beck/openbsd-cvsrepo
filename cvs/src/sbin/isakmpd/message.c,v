head	1.129;
access;
symbols
	OPENBSD_6_1:1.129.0.6
	OPENBSD_6_1_BASE:1.129
	OPENBSD_6_0:1.129.0.2
	OPENBSD_6_0_BASE:1.129
	OPENBSD_5_9:1.128.0.2
	OPENBSD_5_9_BASE:1.128
	OPENBSD_5_8:1.127.0.6
	OPENBSD_5_8_BASE:1.127
	OPENBSD_5_7:1.127.0.2
	OPENBSD_5_7_BASE:1.127
	OPENBSD_5_6:1.126.0.32
	OPENBSD_5_6_BASE:1.126
	OPENBSD_5_5:1.126.0.30
	OPENBSD_5_5_BASE:1.126
	OPENBSD_5_4:1.126.0.26
	OPENBSD_5_4_BASE:1.126
	OPENBSD_5_3:1.126.0.24
	OPENBSD_5_3_BASE:1.126
	OPENBSD_5_2:1.126.0.22
	OPENBSD_5_2_BASE:1.126
	OPENBSD_5_1_BASE:1.126
	OPENBSD_5_1:1.126.0.20
	OPENBSD_5_0:1.126.0.18
	OPENBSD_5_0_BASE:1.126
	OPENBSD_4_9:1.126.0.16
	OPENBSD_4_9_BASE:1.126
	OPENBSD_4_8:1.126.0.14
	OPENBSD_4_8_BASE:1.126
	OPENBSD_4_7:1.126.0.10
	OPENBSD_4_7_BASE:1.126
	OPENBSD_4_6:1.126.0.12
	OPENBSD_4_6_BASE:1.126
	OPENBSD_4_5:1.126.0.8
	OPENBSD_4_5_BASE:1.126
	OPENBSD_4_4:1.126.0.6
	OPENBSD_4_4_BASE:1.126
	OPENBSD_4_3:1.126.0.4
	OPENBSD_4_3_BASE:1.126
	OPENBSD_4_2:1.126.0.2
	OPENBSD_4_2_BASE:1.126
	OPENBSD_4_1:1.123.0.2
	OPENBSD_4_1_BASE:1.123
	OPENBSD_4_0:1.120.0.2
	OPENBSD_4_0_BASE:1.120
	OPENBSD_3_9:1.116.0.2
	OPENBSD_3_9_BASE:1.116
	OPENBSD_3_8:1.114.0.2
	OPENBSD_3_8_BASE:1.114
	OPENBSD_3_7:1.98.0.2
	OPENBSD_3_7_BASE:1.98
	OPENBSD_3_6:1.88.0.2
	OPENBSD_3_6_BASE:1.88
	OPENBSD_3_5:1.69.0.2
	OPENBSD_3_5_BASE:1.69
	OPENBSD_3_4:1.61.0.2
	OPENBSD_3_4_BASE:1.61
	OPENBSD_3_3:1.57.0.4
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.57.0.2
	OPENBSD_3_2_BASE:1.57
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	OPENBSD_3_0:1.45.0.2
	OPENBSD_3_0_BASE:1.45
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.129
date	2016.04.04.17.35.07;	author yasuoka;	state Exp;
branches;
next	1.128;
commitid	XHuyFjcs3y0eOibq;

1.128
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.127;
commitid	0qPuuXwccpVXsXcV;

1.127
date	2014.10.09.02.38.56;	author deraadt;	state Exp;
branches;
next	1.126;
commitid	lHB12E9VkXKsWY0B;

1.126
date	2007.06.02.01.29.11;	author pvalchev;	state Exp;
branches;
next	1.125;

1.125
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.124;

1.124
date	2007.04.15.19.37.46;	author hshoexer;	state Exp;
branches;
next	1.123;

1.123
date	2006.12.05.15.01.00;	author hshoexer;	state Exp;
branches
	1.123.2.1;
next	1.122;

1.122
date	2006.12.05.13.27.12;	author moritz;	state Exp;
branches;
next	1.121;

1.121
date	2006.10.29.18.42.05;	author pedro;	state Exp;
branches;
next	1.120;

1.120
date	2006.07.02.13.19.00;	author hshoexer;	state Exp;
branches
	1.120.2.1;
next	1.119;

1.119
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.118;

1.118
date	2006.05.31.04.54.46;	author hshoexer;	state Exp;
branches;
next	1.117;

1.117
date	2006.05.30.19.54.29;	author hshoexer;	state Exp;
branches;
next	1.116;

1.116
date	2005.10.25.10.38.01;	author hshoexer;	state Exp;
branches;
next	1.115;

1.115
date	2005.09.23.14.44.03;	author hshoexer;	state Exp;
branches;
next	1.114;

1.114
date	2005.07.20.16.50.43;	author moritz;	state Exp;
branches;
next	1.113;

1.113
date	2005.06.26.20.49.24;	author hshoexer;	state Exp;
branches;
next	1.112;

1.112
date	2005.05.26.06.11.09;	author hshoexer;	state Exp;
branches;
next	1.111;

1.111
date	2005.05.26.05.14.17;	author hshoexer;	state Exp;
branches;
next	1.110;

1.110
date	2005.05.25.22.09.17;	author hshoexer;	state Exp;
branches;
next	1.109;

1.109
date	2005.05.18.20.04.51;	author hshoexer;	state Exp;
branches;
next	1.108;

1.108
date	2005.04.09.00.42.27;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.106;

1.106
date	2005.04.08.20.55.21;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2005.04.08.16.52.41;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2005.04.07.19.15.58;	author hshoexer;	state Exp;
branches;
next	1.101;

1.101
date	2005.04.07.18.52.18;	author hshoexer;	state Exp;
branches;
next	1.100;

1.100
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2005.03.05.12.35.03;	author ho;	state Exp;
branches;
next	1.97;

1.97
date	2005.03.05.12.25.12;	author ho;	state Exp;
branches;
next	1.96;

1.96
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.95;

1.95
date	2005.02.24.00.30.41;	author cloder;	state Exp;
branches;
next	1.94;

1.94
date	2005.02.22.21.42.14;	author hshoexer;	state Exp;
branches;
next	1.93;

1.93
date	2005.01.29.16.59.45;	author hshoexer;	state Exp;
branches;
next	1.92;

1.92
date	2004.12.14.19.03.16;	author ho;	state Exp;
branches;
next	1.91;

1.91
date	2004.12.10.09.00.48;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2004.12.08.16.05.37;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2004.09.17.13.45.02;	author ho;	state Exp;
branches;
next	1.88;

1.88
date	2004.08.17.14.48.23;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2004.08.10.15.59.10;	author ho;	state Exp;
branches;
next	1.86;

1.86
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2004.07.07.09.16.20;	author hshoexer;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.21.16.01.56;	author ho;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.20.17.44.06;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2004.06.20.17.17.35;	author ho;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.20.15.24.05;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.20.15.11.29;	author ho;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.14.10.04.22;	author hshoexer;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.11.10.17.58;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.10.12.54.53;	author hshoexer;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.09.12.59.36;	author hshoexer;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.29.22.36.26;	author hshoexer;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.10.23.08.49;	author hshoexer;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2004.03.10.16.10.57;	author hshoexer;	state Exp;
branches;
next	1.67;

1.67
date	2004.03.10.11.17.38;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2004.03.09.21.42.02;	author hshoexer;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.05.13.17.37;	author ho;	state Exp;
branches;
next	1.64;

1.64
date	2003.12.04.22.44.31;	author hshoexer;	state Exp;
branches;
next	1.63;

1.63
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2003.11.06.15.55.54;	author ho;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.02.18.14.52;	author ho;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2003.06.14.11.47.13;	author ho;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches
	1.57.4.1;
next	1.56;

1.56
date	2002.07.09.14.31.45;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.04.22.23.49;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.06.02.42.29;	author ho;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.01.07.44.21;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.28.10.09.46;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.26.13.19.28;	author ho;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2002.01.23.18.44.47;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.26.13.29.26;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.10.26.11.37.16;	author ho;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.01.20.43.39;	author niklas;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2001.07.01.06.10.34;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.29.18.52.17;	author ho;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.24.07.27.37;	author niklas;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.14.01.25.34;	author ho;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.12.15.48.37;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.09.21.21.57;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.13.14.05.19;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.27.12.03.34;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.10.13.35.11;	author niklas;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.10.07.07.00.20;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.08.03.07.23.10;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.19.02.25.44;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.25.17.23.41;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.31.08.38.28;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.30.10.18.56;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.30.10.11.57;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.30.09.59.46;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.01.30.09.47.55;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.26.15.20.56;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.08.26.22.27.51;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.05.14.20.10.11;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.05.03.22.45.04;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.05.02.19.18.48;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.05.01.22.58.02;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.04.30.11.48.19;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.04.27.21.10.14;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.04.19.20.59.27;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.05.21.02.03;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.02.01.09.22;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.03.31.01.52.00;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.03.24.14.44.26;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.03.02.15.12.00;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.02.26.03.47.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	98.12.21.01.02.26;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	98.11.20.07.32.50;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.11.17.11.10.17;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.11.16.12.20.33;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.15.01.13.27;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.15.01.11.25;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2001.05.08.12.45.24;	author ho;	state Exp;
branches;
next	;

1.45.2.1
date	2002.03.27.04.24.22;	author jason;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2002.07.05.16.03.10;	author miod;	state Exp;
branches;
next	1.45.2.3;

1.45.2.3
date	2002.07.10.08.47.55;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2002.07.06.22.01.38;	author jason;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2002.07.09.15.33.53;	author jason;	state Exp;
branches;
next	;

1.57.4.1
date	2004.01.16.00.00.21;	author brad;	state Exp;
branches;
next	1.57.4.2;

1.57.4.2
date	2004.03.17.15.05.03;	author brad;	state Exp;
branches;
next	;

1.61.2.1
date	2004.01.13.22.50.07;	author brad;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2004.03.17.14.59.18;	author brad;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2004.06.09.21.15.05;	author brad;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2004.06.11.03.08.02;	author brad;	state Exp;
branches;
next	;

1.69.2.1
date	2004.06.09.20.48.47;	author brad;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2004.06.11.02.34.56;	author brad;	state Exp;
branches;
next	;

1.120.2.1
date	2007.05.18.21.34.43;	author ckuethe;	state Exp;
branches;
next	;

1.123.2.1
date	2007.05.18.21.34.07;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.129
log
@Fix memory leak.  Call proto_free() always to free proto.
Diff from Yuuichi Someya.

ok reyk markus
@
text
@/* $OpenBSD: message.c,v 1.128 2015/08/20 22:02:21 deraadt Exp $	 */
/* $EOM: message.c,v 1.156 2000/10/10 12:36:39 provos Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>

#include "attribute.h"
#include "cert.h"
#include "constants.h"
#include "crypto.h"
#include "doi.h"
#include "dpd.h"
#include "exchange.h"
#include "field.h"
#include "hash.h"
#include "ipsec.h"
#include "ipsec_num.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "nat_traversal.h"
#include "prf.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "util.h"
#include "vendor.h"
#include "virtual.h"

/* A local set datatype, coincidentally fd_set suits our purpose fine.  */
typedef fd_set  set;
#define ISSET FD_ISSET
#define SET FD_SET
#define ZERO FD_ZERO

static int      message_check_duplicate(struct message *);
static int      message_encrypt(struct message *);
static int	message_index_payload(struct message *, struct payload *,
		    u_int8_t ,u_int8_t *);
static int	message_parse_transform(struct message *, struct payload *,
		    u_int8_t, u_int8_t *);
static struct field *message_get_field(u_int8_t);
static int	message_validate_payload(struct message *, struct payload *,
		    u_int8_t);
static u_int16_t message_payload_sz(u_int8_t);
static int      message_validate_attribute(struct message *, struct payload *);
static int      message_validate_cert(struct message *, struct payload *);
static int      message_validate_cert_req(struct message *, struct payload *);
static int      message_validate_delete(struct message *, struct payload *);
static int      message_validate_hash(struct message *, struct payload *);
static int      message_validate_id(struct message *, struct payload *);
static int      message_validate_key_exch(struct message *, struct payload *);
static int      message_validate_nat_d(struct message *, struct payload *);
static int      message_validate_nat_oa(struct message *, struct payload *);
static int      message_validate_nonce(struct message *, struct payload *);
static int      message_validate_notify(struct message *, struct payload *);
static int      message_validate_proposal(struct message *, struct payload *);
static int      message_validate_sa(struct message *, struct payload *);
static int      message_validate_sig(struct message *, struct payload *);
static int      message_validate_transform(struct message *, struct payload *);
static int      message_validate_vendor(struct message *, struct payload *);

static void     message_packet_log(struct message *);

/*
 * Fields used for checking monotonic increasing of proposal and transform
 * numbers.
 */
static u_int8_t *last_sa = 0;
static u_int32_t last_prop_no;
static u_int8_t *last_prop = 0;
static u_int32_t last_xf_no;

/*
 * Allocate a message structure bound to transport T, and with a first
 * segment buffer sized SZ, copied from BUF if given.
 */
struct message *
message_alloc(struct transport *t, u_int8_t *buf, size_t sz)
{
	struct message *msg;
	int             i;

	/*
	 * We use calloc(3) because it zeroes the structure which we rely on in
	 * message_free when determining what sub-allocations to free.
	 */
	msg = calloc(1, sizeof *msg);
	if (!msg)
		return 0;
	msg->iov = calloc(1, sizeof *msg->iov);
	if (!msg->iov) {
		message_free(msg);
		return 0;
	}
	msg->iov[0].iov_len = sz;
	msg->iov[0].iov_base = malloc(sz);
	if (!msg->iov[0].iov_base) {
		message_free(msg);
		return 0;
	}
	msg->iovlen = 1;
	if (buf)
		memcpy(msg->iov[0].iov_base, buf, sz);
	msg->nextp = (u_int8_t *)msg->iov[0].iov_base +
	    ISAKMP_HDR_NEXT_PAYLOAD_OFF;
	msg->transport = t;
	transport_reference(t);
	msg->payload = calloc(ISAKMP_PAYLOAD_MAX, sizeof *msg->payload);
	if (!msg->payload) {
		message_free(msg);
		return 0;
	}
	for (i = 0; i < ISAKMP_PAYLOAD_MAX; i++)
		TAILQ_INIT(&msg->payload[i]);
	TAILQ_INIT(&msg->post_send);
	LOG_DBG((LOG_MESSAGE, 90, "message_alloc: allocated %p", msg));
	return msg;
}

/*
 * Allocate a message suitable for a reply to MSG.  Just allocate an empty
 * ISAKMP header as the first segment.
 */
struct message *
message_alloc_reply(struct message *msg)
{
	struct message *reply;

	reply = message_alloc(msg->transport, 0, ISAKMP_HDR_SZ);
	reply->exchange = msg->exchange;
	reply->isakmp_sa = msg->isakmp_sa;
	reply->flags = msg->flags;
	if (msg->isakmp_sa)
		sa_reference(msg->isakmp_sa);
	return reply;
}

/* Free up all resources used by the MSG message.  */
void
message_free(struct message *msg)
{
	u_int32_t       i;
	struct payload *payload;
	struct post_send *node;

	LOG_DBG((LOG_MESSAGE, 20, "message_free: freeing %p", msg));
	if (!msg)
		return;
	if (msg->iov) {
		if (msg->orig && msg->orig != (u_int8_t *)msg->iov[0].iov_base)
			free(msg->orig);
		for (i = 0; i < msg->iovlen; i++)
			free(msg->iov[i].iov_base);
		free(msg->iov);
	}
	if (msg->retrans)
		timer_remove_event(msg->retrans);
	if (msg->payload) {
		for (i = 0; i < ISAKMP_PAYLOAD_MAX; i++)
			while ((payload = TAILQ_FIRST(&msg->payload[i]))) {
				TAILQ_REMOVE(&msg->payload[i], payload, link);
				free(payload);
			}
		free(msg->payload);
	}
	while ((node = TAILQ_FIRST(&msg->post_send)))
		TAILQ_REMOVE(&msg->post_send, node, link);
	if (msg->transport) {
		/* If we are on the send queue, remove us from there.  */
		if (msg->flags & MSG_IN_TRANSIT)
			TAILQ_REMOVE(msg->transport->vtbl->get_queue(msg),
			    msg, link);

		transport_release(msg->transport);
	}

	if (msg->isakmp_sa)
		sa_release(msg->isakmp_sa);

	free(msg);
}

/*
 * Generic ISAKMP parser.
 * MSG is the ISAKMP message to be parsed.  NEXT is the type of the first
 * payload to be parsed, and it's pointed to by BUF.  ACCEPTED_PAYLOADS
 * tells what payloads are accepted and FUNC is a pointer to a function
 * to be called for each payload found, which is also responsible for
 * freeing the passed ISAKMP message in the failure case.
 * Returns the total length of the parsed payloads.
 */
static int
message_parse_payloads(struct message *msg, struct payload *p, u_int8_t next,
    u_int8_t *buf, set *accepted_payloads, int (*func)(struct message *,
    struct payload *, u_int8_t, u_int8_t *))
{
	u_int8_t        payload;
	u_int16_t       len;
	int             sz = 0;

	do {
		LOG_DBG((LOG_MESSAGE, 50,
			 "message_parse_payloads: offset %ld payload %s",
			 (long)(buf - (u_int8_t *) msg->iov[0].iov_base),
			 constant_name(isakmp_payload_cst, next)));

		/* Does this payload's header fit?  */
		if (buf + ISAKMP_GEN_SZ > (u_int8_t *)msg->iov[0].iov_base +
		    msg->iov[0].iov_len) {
			log_print("message_parse_payloads: short message");
			message_drop(msg,
			    ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 1, 1);
			return -1;
		}
		/* Ponder on the payload that is at BUF...  */
		payload = next;

		/* Look at the next payload's type.  */
		next = GET_ISAKMP_GEN_NEXT_PAYLOAD(buf);
		if (next >= ISAKMP_PAYLOAD_RESERVED_MIN &&
		    next <= ISAKMP_PAYLOAD_RESERVED_MAX) {
			log_print("message_parse_payloads: invalid next "
			    "payload type %s in payload of type %d",
			    constant_name(isakmp_payload_cst, next), payload);
			message_drop(msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE,
			    0, 1, 1);
			return -1;
		}
		/* Reserved fields in ISAKMP messages should be zero.  */
		if (GET_ISAKMP_GEN_RESERVED(buf) != 0) {
			log_print("message_parse_payloads: reserved field "
			    "non-zero: %x", GET_ISAKMP_GEN_RESERVED(buf));
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED,
			    0, 1, 1);
			return -1;
		}
		/*
		 * Decode and validate the payload length field.
		 */
		len = GET_ISAKMP_GEN_LENGTH(buf);

		if (message_payload_sz(payload) == 0) {
			log_print("message_parse_payloads: unknown minimum "
			    "payload size for payload type %s",
			    constant_name(isakmp_payload_cst, payload));
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED,
			    0, 1, 1);
			return -1;
		}
		if (len < message_payload_sz(payload)) {
			log_print("message_parse_payloads: payload too "
			    "short: %u", len);
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED,
			    0, 1, 1);
			return -1;
		}
		if (buf + len > (u_int8_t *)msg->iov[0].iov_base +
		    msg->iov[0].iov_len) {
			log_print("message_parse_payloads: payload too "
			    "long: %u", len);
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED,
			    0, 1, 1);
			return -1;
		}
		/* Ignore most private payloads.  */
		if (next >= ISAKMP_PAYLOAD_PRIVATE_MIN &&
		    next != ISAKMP_PAYLOAD_NAT_D_DRAFT &&
		    next != ISAKMP_PAYLOAD_NAT_OA_DRAFT) {
			LOG_DBG((LOG_MESSAGE, 30, "message_parse_payloads: "
			    "private next payload type %s in payload of "
			    "type %d ignored",
			    constant_name(isakmp_payload_cst, next), payload));
			goto next_payload;
		}
		/*
		 * Check if the current payload is one of the accepted ones at
		 * this stage.
		 */
		if (!ISSET(payload, accepted_payloads)) {
			log_print("message_parse_payloads: payload type %s "
			    "unexpected", constant_name(isakmp_payload_cst,
				payload));
			message_drop(msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE,
			    0, 1, 1);
			return -1;
		}
		/* Call the payload handler specified by the caller.  */
		if (func(msg, p, payload, buf))
			return -1;

next_payload:
		/* Advance to next payload.  */
		buf += len;
		sz += len;
	} while (next != ISAKMP_PAYLOAD_NONE);
	return sz;
}

/*
 * Parse a proposal payload found in message MSG.  PAYLOAD is always
 * ISAKMP_PAYLOAD_PROPOSAL and ignored in here.  It's needed as the API for
 * message_parse_payloads requires it.  BUF points to the proposal's
 * generic payload header.
 */
static int
message_parse_proposal(struct message *msg, struct payload *p,
    u_int8_t payload, u_int8_t *buf)
{
	set	payload_set;

	/* Put the proposal into the proposal bucket.  */
	if (message_index_payload(msg, p, payload, buf) == -1)
		return -1;

	ZERO(&payload_set);
	SET(ISAKMP_PAYLOAD_TRANSFORM, &payload_set);
	if (message_parse_payloads(msg,
	    TAILQ_LAST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL], payload_head),
	    ISAKMP_PAYLOAD_TRANSFORM, buf + ISAKMP_PROP_SPI_OFF +
	    GET_ISAKMP_PROP_SPI_SZ(buf), &payload_set, message_parse_transform)
	    == -1)
		return -1;

	return 0;
}

static int
message_parse_transform(struct message *msg, struct payload *p,
    u_int8_t payload, u_int8_t *buf)
{
	/* Put the transform into the transform bucket.  */
	if (message_index_payload(msg, p, payload, buf) == -1)
		return -1;

	LOG_DBG((LOG_MESSAGE, 50, "Transform %d's attributes",
	    GET_ISAKMP_TRANSFORM_NO(buf)));
	attribute_map(buf + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    GET_ISAKMP_GEN_LENGTH(buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    msg->exchange->doi->debug_attribute, msg);

	return 0;
}

static struct field *
message_get_field(u_int8_t payload)
{
	switch (payload) {
	case ISAKMP_PAYLOAD_SA:
		return isakmp_sa_fld;
	case ISAKMP_PAYLOAD_PROPOSAL:
		return isakmp_prop_fld;
	case ISAKMP_PAYLOAD_TRANSFORM:
		return isakmp_transform_fld;
	case ISAKMP_PAYLOAD_KEY_EXCH:
		return isakmp_ke_fld;
	case ISAKMP_PAYLOAD_ID:
		return isakmp_id_fld;
	case ISAKMP_PAYLOAD_CERT:
		return isakmp_cert_fld;
	case ISAKMP_PAYLOAD_CERT_REQ:
		return isakmp_certreq_fld;
	case ISAKMP_PAYLOAD_HASH:
		return isakmp_hash_fld;
	case ISAKMP_PAYLOAD_SIG:
		return isakmp_sig_fld;
	case ISAKMP_PAYLOAD_NONCE:
		return isakmp_nonce_fld;
	case ISAKMP_PAYLOAD_NOTIFY:
		return isakmp_notify_fld;
	case ISAKMP_PAYLOAD_DELETE:
		return isakmp_delete_fld;
	case ISAKMP_PAYLOAD_VENDOR:
		return isakmp_vendor_fld;
	case ISAKMP_PAYLOAD_ATTRIBUTE:
		return isakmp_attribute_fld;
	case ISAKMP_PAYLOAD_NAT_D:
	case ISAKMP_PAYLOAD_NAT_D_DRAFT:
		return isakmp_nat_d_fld;
	case ISAKMP_PAYLOAD_NAT_OA:
	case ISAKMP_PAYLOAD_NAT_OA_DRAFT:
		return isakmp_nat_oa_fld;
	/* Not yet supported and any other unknown payloads. */
	case ISAKMP_PAYLOAD_SAK:
	case ISAKMP_PAYLOAD_SAT:
	case ISAKMP_PAYLOAD_KD:
	case ISAKMP_PAYLOAD_SEQ:
	case ISAKMP_PAYLOAD_POP:
	default:
		break;
	}
	return NULL;
}

static int
message_validate_payload(struct message *m, struct payload *p, u_int8_t payload)
{
	switch (payload) {
	case ISAKMP_PAYLOAD_SA:
		return message_validate_sa(m, p);
	case ISAKMP_PAYLOAD_PROPOSAL:
		return message_validate_proposal(m, p);
	case ISAKMP_PAYLOAD_TRANSFORM:
		return message_validate_transform(m, p);
	case ISAKMP_PAYLOAD_KEY_EXCH:
		return message_validate_key_exch(m, p);
	case ISAKMP_PAYLOAD_ID:
		return message_validate_id(m, p);
	case ISAKMP_PAYLOAD_CERT:
		return message_validate_cert(m, p);
	case ISAKMP_PAYLOAD_CERT_REQ:
		return message_validate_cert_req(m, p);
	case ISAKMP_PAYLOAD_HASH:
		return message_validate_hash(m, p);
	case ISAKMP_PAYLOAD_SIG:
		return message_validate_sig(m, p);
	case ISAKMP_PAYLOAD_NONCE:
		return message_validate_nonce(m, p);
	case ISAKMP_PAYLOAD_NOTIFY:
		return message_validate_notify(m, p);
	case ISAKMP_PAYLOAD_DELETE:
		return message_validate_delete(m, p);
	case ISAKMP_PAYLOAD_VENDOR:
		return message_validate_vendor(m, p);
	case ISAKMP_PAYLOAD_ATTRIBUTE:
		return message_validate_attribute(m, p);
	case ISAKMP_PAYLOAD_NAT_D:
	case ISAKMP_PAYLOAD_NAT_D_DRAFT:
		return message_validate_nat_d(m, p);
	case ISAKMP_PAYLOAD_NAT_OA:
	case ISAKMP_PAYLOAD_NAT_OA_DRAFT:
		return message_validate_nat_oa(m, p);
	/* Not yet supported and any other unknown payloads. */
	case ISAKMP_PAYLOAD_SAK:
	case ISAKMP_PAYLOAD_SAT:
	case ISAKMP_PAYLOAD_KD:
	case ISAKMP_PAYLOAD_SEQ:
	case ISAKMP_PAYLOAD_POP:
	default:
		break;
	}
	message_drop(m, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
	return -1;
}

/* Check payloads for their required minimum size. */
static u_int16_t
message_payload_sz(u_int8_t payload)
{
	switch (payload) {
	case ISAKMP_PAYLOAD_SA:
		return ISAKMP_SA_SZ;
	case ISAKMP_PAYLOAD_PROPOSAL:
		return ISAKMP_PROP_SZ;
	case ISAKMP_PAYLOAD_TRANSFORM:
		return ISAKMP_TRANSFORM_SZ;
	case ISAKMP_PAYLOAD_KEY_EXCH:
		return ISAKMP_KE_SZ;
	case ISAKMP_PAYLOAD_ID:
		return ISAKMP_ID_SZ;
	case ISAKMP_PAYLOAD_CERT:
		return ISAKMP_CERT_SZ;
	case ISAKMP_PAYLOAD_CERT_REQ:
		return ISAKMP_CERTREQ_SZ;
	case ISAKMP_PAYLOAD_HASH:
		return ISAKMP_HASH_SZ;
	case ISAKMP_PAYLOAD_SIG:
		return ISAKMP_SIG_SZ;
	case ISAKMP_PAYLOAD_NONCE:
		return ISAKMP_NONCE_SZ;
	case ISAKMP_PAYLOAD_NOTIFY:
		return ISAKMP_NOTIFY_SZ;
	case ISAKMP_PAYLOAD_DELETE:
		return ISAKMP_DELETE_SZ;
	case ISAKMP_PAYLOAD_VENDOR:
		return ISAKMP_VENDOR_SZ;
	case ISAKMP_PAYLOAD_ATTRIBUTE:
		return ISAKMP_ATTRIBUTE_SZ;
	case ISAKMP_PAYLOAD_NAT_D:
	case ISAKMP_PAYLOAD_NAT_D_DRAFT:
		return ISAKMP_NAT_D_SZ;
	case ISAKMP_PAYLOAD_NAT_OA:
	case ISAKMP_PAYLOAD_NAT_OA_DRAFT:
		return ISAKMP_NAT_OA_SZ;
	/* Not yet supported and any other unknown payloads. */
	case ISAKMP_PAYLOAD_SAK:
	case ISAKMP_PAYLOAD_SAT:
	case ISAKMP_PAYLOAD_KD:
	case ISAKMP_PAYLOAD_SEQ:
	case ISAKMP_PAYLOAD_POP:
	default:
		return 0;
	}
}

/* Validate the attribute payload P in message MSG.  */
static int
message_validate_attribute(struct message *msg, struct payload *p)
{
	/* If we don't have an exchange yet, create one.  */
	if (!msg->exchange) {
		if (zero_test((u_int8_t *) msg->iov[0].iov_base +
		    ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
			msg->exchange = exchange_setup_p1(msg,
			    IPSEC_DOI_IPSEC);
		else
			msg->exchange = exchange_setup_p2(msg,
			    IPSEC_DOI_IPSEC);
		if (!msg->exchange) {
			log_print("message_validate_attribute: can not "
			    "create exchange");
			message_free(msg);
			return -1;
		}
	}
	return 0;
}

/* Validate the certificate payload P in message MSG.  */
static int
message_validate_cert(struct message *msg, struct payload *p)
{
	if (GET_ISAKMP_CERT_ENCODING(p->p) >= ISAKMP_CERTENC_RESERVED_MIN) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 1,
		    1);
		return -1;
	}
	return 0;
}

/* Validate the certificate request payload P in message MSG.  */
static int
message_validate_cert_req(struct message *msg, struct payload *p)
{
	struct cert_handler *cert;
	size_t	len =
	    GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_CERTREQ_AUTHORITY_OFF;

	if (GET_ISAKMP_CERTREQ_TYPE(p->p) >= ISAKMP_CERTENC_RESERVED_MIN) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 1,
		    1);
		return -1;
	}
	/*
	 * Check the certificate types we support and if an acceptable
	 * authority is included in the payload check if it can be decoded
	 */
	cert = cert_get(GET_ISAKMP_CERTREQ_TYPE(p->p));
	if (!cert || (len && !cert->certreq_validate(p->p +
	    ISAKMP_CERTREQ_AUTHORITY_OFF, len))) {
		message_drop(msg, ISAKMP_NOTIFY_CERT_TYPE_UNSUPPORTED, 0, 1,
		    1);
		return -1;
	}
	return 0;
}

/*
 * Validate the delete payload P in message MSG.  As a side-effect, create
 * an exchange if we do not have one already.
 */
static int
message_validate_delete(struct message *msg, struct payload *p)
{
	u_int8_t        proto = GET_ISAKMP_DELETE_PROTO(p->p);
	struct doi     *doi;
	struct sa      *sa, *isakmp_sa;
	struct sockaddr *dst, *dst_isa;
	u_int32_t       nspis = GET_ISAKMP_DELETE_NSPIS(p->p);
	u_int8_t       *spis = (u_int8_t *)p->p + ISAKMP_DELETE_SPI_OFF;
	u_int32_t       i;
	char           *addr;

	/* Only accept authenticated DELETEs. */
	if ((msg->flags & MSG_AUTHENTICATED) == 0) {
		log_print("message_validate_delete: "
		    "got unauthenticated DELETE");
		message_free(msg);
		return -1;
	}

	doi = doi_lookup(GET_ISAKMP_DELETE_DOI(p->p));
	if (!doi) {
		log_print("message_validate_delete: DOI not supported");
		message_free(msg);
		return -1;
	}
	/* If we don't have an exchange yet, create one.  */
	if (!msg->exchange) {
		if (zero_test((u_int8_t *) msg->iov[0].iov_base
		    + ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
			msg->exchange = exchange_setup_p1(msg, doi->id);
		else
			msg->exchange = exchange_setup_p2(msg, doi->id);
		if (!msg->exchange) {
			log_print("message_validate_delete: can not create "
			    "exchange");
			message_free(msg);
			return -1;
		}
	}
	/* Only accept DELETE as part of an INFORMATIONAL exchange. */
	if (msg->exchange->type != ISAKMP_EXCH_INFO) {
		log_print("message_validate_delete: delete in exchange other "
		    "than INFO: %s", constant_name(isakmp_exch_cst,
		    msg->exchange->type));
		message_free(msg);
		return -1;
	}
	if (proto != ISAKMP_PROTO_ISAKMP && doi->validate_proto(proto)) {
		log_print("message_validate_delete: protocol not supported");
		message_free(msg);
		return -1;
	}
	/* Validate the SPIs.  */
	for (i = 0; i < nspis; i++) {
		/* Get ISAKMP SA protecting this message. */
		isakmp_sa = msg->isakmp_sa;
		if (!isakmp_sa) {
			/* XXX should not happen? */
			log_print("message_validate_delete: invalid spi (no "
			    "valid ISAKMP SA found)");
			message_free(msg);
			return -1;
		}
		isakmp_sa->transport->vtbl->get_dst(isakmp_sa->transport,
		    &dst_isa);

		/* Get SA to be deleted. */
		msg->transport->vtbl->get_dst(msg->transport, &dst);
		if (proto == ISAKMP_PROTO_ISAKMP)
			sa = sa_lookup_isakmp_sa(dst, spis + i
			    * ISAKMP_HDR_COOKIES_LEN);
		else
			sa = ipsec_sa_lookup(dst, ((u_int32_t *) spis)[i],
			    proto);
		if (!sa) {
			LOG_DBG((LOG_MESSAGE, 50, "message_validate_delete: "
			    "invalid spi (no valid SA found)"));
			message_free(msg);
			return -1;
		}
		sa->transport->vtbl->get_dst(sa->transport, &dst);

		/* Destination addresses must match. */
		if (dst->sa_family != dst_isa->sa_family ||
		    memcmp(sockaddr_addrdata(dst_isa), sockaddr_addrdata(dst),
		    sockaddr_addrlen(dst))) {
			sockaddr2text(dst_isa, &addr, 0);

			log_print("message_validate_delete: invalid spi "
			    "(illegal delete request from %s)", addr);
			free(addr);
			message_free(msg);
			return -1;
		}
	}

	return 0;
}

/*
 * Validate the hash payload P in message MSG.
 */
static int
message_validate_hash(struct message *msg, struct payload *p)
{
	struct sa      *isakmp_sa = msg->isakmp_sa;
	struct ipsec_sa *isa;
	struct hash    *hash;
	struct payload *hashp = payload_first(msg, ISAKMP_PAYLOAD_HASH);
	struct prf     *prf;
	u_int8_t       *rest;
	u_int8_t        message_id[ISAKMP_HDR_MESSAGE_ID_LEN];
	size_t          rest_len;

	/* active exchanges other than INFORMATIONAL validates hash payload. */
	if (msg->exchange && (msg->exchange->type != ISAKMP_EXCH_INFO))
		return 0;

	if (isakmp_sa == NULL)
		goto invalid;

	isa = isakmp_sa->data;
	hash = hash_get(isa->hash);
	if (hash == NULL)
		goto invalid;

	/* If no SKEYID_a, we can not do anything (should not happen).  */
	if (!isa->skeyid_a)
		goto invalid;

	/* Allocate the prf and start calculating our HASH(1). */
	LOG_DBG_BUF((LOG_MISC, 90, "message_validate_hash: SKEYID_a",
	    isa->skeyid_a, isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a,
	    isa->skeyid_len);
	if (!prf) {
		message_free(msg);
		return -1;
	}
	/* This is not an active exchange. */
	GET_ISAKMP_HDR_MESSAGE_ID(msg->iov[0].iov_base, message_id);

	prf->Init(prf->prfctx);
	LOG_DBG_BUF((LOG_MISC, 90, "message_validate_hash: message_id",
	    message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
	prf->Update(prf->prfctx, message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
	rest = hashp->p + GET_ISAKMP_GEN_LENGTH(hashp->p);
	rest_len = (GET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base) - (rest -
	    (u_int8_t *)msg->iov[0].iov_base));
	LOG_DBG_BUF((LOG_MISC, 90,
	    "message_validate_hash: payloads after HASH(1)", rest, rest_len));
	prf->Update(prf->prfctx, rest, rest_len);
	prf->Final(hash->digest, prf->prfctx);
	prf_free(prf);

	if (memcmp(hashp->p + ISAKMP_HASH_DATA_OFF, hash->digest,
	    hash->hashsize))
		goto invalid;

	/* Mark the HASH as handled. */
	hashp->flags |= PL_MARK;

	/* Mark message as authenticated. */
	msg->flags |= MSG_AUTHENTICATED;

	return 0;

  invalid:
	log_print("message_validate_hash: invalid hash information");
	message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
	return -1;
}

/* Validate the identification payload P in message MSG.  */
static int
message_validate_id(struct message *msg, struct payload *p)
{
	struct exchange *exchange = msg->exchange;
	size_t          len = GET_ISAKMP_GEN_LENGTH(p->p);

	if (!exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_id: payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	if (exchange->doi &&
	    exchange->doi->validate_id_information(GET_ISAKMP_ID_TYPE(p->p),
	    p->p + ISAKMP_ID_DOI_DATA_OFF, p->p + ISAKMP_ID_DATA_OFF,
	    len - ISAKMP_ID_DATA_OFF, exchange)) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1,
		    1);
		return -1;
	}
	return 0;
}

/* Validate the key exchange payload P in message MSG.  */
static int
message_validate_key_exch(struct message *msg, struct payload *p)
{
	struct exchange *exchange = msg->exchange;
	size_t          len = GET_ISAKMP_GEN_LENGTH(p->p);

	if (!exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_key_exch: "
		    "payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	if (exchange->doi && exchange->doi->validate_key_information(p->p +
	    ISAKMP_KE_DATA_OFF, len - ISAKMP_KE_DATA_OFF)) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_KEY_INFORMATION,
		    0, 1, 1);
		return -1;
	}
	return 0;
}

/* Validate the NAT-D payload P in message MSG.  */
static int
message_validate_nat_d(struct message *msg, struct payload *p)
{
	struct exchange	*exchange = msg->exchange;

	if (!exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_nat_d: payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}

	if (exchange->phase != 1) {
		log_print("message_validate_nat_d: "
		    "NAT-D payload must be in phase 1");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}

	/* Mark as handled.  */
	p->flags |= PL_MARK;

	return 0;
}

/* Validate the NAT-OA payload P in message MSG.  */
static int
message_validate_nat_oa(struct message *msg, struct payload *p)
{
	struct exchange	*exchange = msg->exchange;

	if (!exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_nat_d: payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}

#ifdef notyet /* XXX Probably never, due to patent issues.  */
	/* Mark as handled.  */
	p->flags |= PL_MARK;
#endif

	return 0;
}

/* Validate the nonce payload P in message MSG.  */
static int
message_validate_nonce(struct message *msg, struct payload *p)
{
	if (!msg->exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_nonce: payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	/* Nonces require no specific validation.  */
	return 0;
}

/*
 * Validate the notify payload P in message MSG.  As a side-effect, create
 * an exchange if we do not have one already.
 */
static int
message_validate_notify(struct message *msg, struct payload *p)
{
	u_int8_t        proto = GET_ISAKMP_NOTIFY_PROTO(p->p);
	u_int16_t       type = GET_ISAKMP_NOTIFY_MSG_TYPE(p->p);
	struct doi     *doi;

	doi = doi_lookup(GET_ISAKMP_NOTIFY_DOI(p->p));
	if (!doi) {
		log_print("message_validate_notify: DOI not supported");
		message_free(msg);
		return -1;
	}
	/* If we don't have an exchange yet, create one.  */
	if (!msg->exchange) {
		if (zero_test((u_int8_t *) msg->iov[0].iov_base +
		    ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
			msg->exchange = exchange_setup_p1(msg, doi->id);
		else
			msg->exchange = exchange_setup_p2(msg, doi->id);
		if (!msg->exchange) {
			log_print("message_validate_notify: can not create "
			    "exchange");
			message_free(msg);
			return -1;
		}
	}
	if (proto != ISAKMP_PROTO_ISAKMP && doi->validate_proto(proto)) {
		log_print("message_validate_notify: protocol not supported");
		message_free(msg);
		return -1;
	}

	/* Validate the SPI. XXX Just ISAKMP for now.  */
	if (proto == ISAKMP_PROTO_ISAKMP &&
	    GET_ISAKMP_NOTIFY_SPI_SZ(p->p) == ISAKMP_HDR_COOKIES_LEN &&
	    msg->isakmp_sa &&
	    memcmp(p->p + ISAKMP_NOTIFY_SPI_OFF, msg->isakmp_sa->cookies,
		ISAKMP_HDR_COOKIES_LEN) != 0) {
		log_print("message_validate_notify: bad cookies");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_SPI, 0, 1, 1);
		return -1;
	}

	if (type < ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE ||
	    (type >= ISAKMP_NOTIFY_RESERVED_MIN &&
	    type < ISAKMP_NOTIFY_PRIVATE_MIN) ||
	    (type >= ISAKMP_NOTIFY_STATUS_RESERVED1_MIN &&
	    type <= ISAKMP_NOTIFY_STATUS_RESERVED1_MAX) ||
	    (type >= ISAKMP_NOTIFY_STATUS_DOI_MIN &&
	    type <= ISAKMP_NOTIFY_STATUS_DOI_MAX &&
	    doi->validate_notification(type)) ||
	    type >= ISAKMP_NOTIFY_STATUS_RESERVED2_MIN) {
		log_print("message_validate_notify: "
		    "message type not supported");
		message_free(msg);
		return -1;
	}

	return 0;
}

/* Validate the proposal payload P in message MSG.  */
static int
message_validate_proposal(struct message *msg, struct payload *p)
{
	u_int8_t        proto = GET_ISAKMP_PROP_PROTO(p->p);
	u_int8_t       *sa = p->context->p;

	if (!msg->exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_proposal: "
		    "payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	if (proto != ISAKMP_PROTO_ISAKMP &&
	    msg->exchange->doi->validate_proto(proto)) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_PROTOCOL_ID, 0, 1, 1);
		return -1;
	}
	/* Check that we get monotonically increasing proposal IDs per SA.  */
	if (sa != last_sa)
		last_sa = sa;
	else if (GET_ISAKMP_PROP_NO(p->p) < last_prop_no) {
		message_drop(msg, ISAKMP_NOTIFY_BAD_PROPOSAL_SYNTAX, 0, 1, 1);
		return -1;
	}
	last_prop_no = GET_ISAKMP_PROP_NO(p->p);

	/* XXX Validate the SPI, and other syntactic things.  */

	return 0;
}

/*
 * Validate the SA payload P in message MSG.
 * Aside from normal validation, note what DOI is in use for other
 * validation routines to look at.  Also index the proposal payloads
 * on the fly.
 * XXX This assumes PAYLOAD_SA is always the first payload
 * to be validated, which is true for IKE, except for quick mode where
 * a PAYLOAD_HASH comes first, but in that specific case it does not matter.
 * XXX Make sure the above comment is relevant, isn't SA always checked
 * first due to the IANA assigned payload number?
 */
static int
message_validate_sa(struct message *msg, struct payload *p)
{
	set             payload_set;
	size_t          len;
	u_int32_t       doi_id;
	struct exchange *exchange = msg->exchange;
	u_int8_t       *pkt = msg->iov[0].iov_base;

	doi_id = GET_ISAKMP_SA_DOI(p->p);
	if (!doi_lookup(doi_id)) {
		log_print("message_validate_sa: DOI not supported");
		message_drop(msg, ISAKMP_NOTIFY_DOI_NOT_SUPPORTED, 0, 1, 1);
		return -1;
	}
	/*
	 * It's time to figure out what SA this message is about.  If it is
	 * already set, then we are creating a new phase 1 SA.  Otherwise,
	 * lookup the SA using the cookies and the message ID.  If we cannot
	 * find it, and the phase 1 SA is ready, setup a phase 2 SA.
	 */
	if (!exchange) {
		if (zero_test(pkt + ISAKMP_HDR_RCOOKIE_OFF,
		    ISAKMP_HDR_RCOOKIE_LEN))
			exchange = exchange_setup_p1(msg, doi_id);
		else if (msg->isakmp_sa->flags & SA_FLAG_READY)
			exchange = exchange_setup_p2(msg, doi_id);
		else {
			/* XXX What to do here?  */
			message_free(msg);
			return -1;
		}
		if (!exchange) {
			/* XXX Log?  */
			message_free(msg);
			return -1;
		}
	}
	msg->exchange = exchange;

	/*
	 * Create a struct sa for each SA payload handed to us unless we are
	 * the initiator where we only will count them.
	 */
	if (exchange->initiator) {
		/* XXX Count SA payloads.  */
	} else if (sa_create(exchange, msg->transport)) {
		/* XXX Remove exchange if we just created it?   */
		message_free(msg);
		return -1;
	}
	if (exchange->phase == 1) {
		msg->isakmp_sa = TAILQ_FIRST(&exchange->sa_list);
		if (msg->isakmp_sa)
			sa_reference(msg->isakmp_sa);
	}
	/*
	 * Let the DOI validate the situation, at the same time it tells us
	 * what the length of the situation field is.
	 */
	if (exchange->doi->validate_situation(p->p + ISAKMP_SA_SIT_OFF, &len,
	    GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_SA_SIT_OFF)) {
		log_print("message_validate_sa: situation not supported");
		message_drop(msg, ISAKMP_NOTIFY_SITUATION_NOT_SUPPORTED,
		    0, 1, 1);
		return -1;
	}
	/*
	 * Reset the fields we base our proposal & transform number checks
	 * on.
	 */
	last_sa = last_prop = 0;
	last_prop_no = last_xf_no = 0;

	/* Go through the PROPOSAL payloads.  */
	ZERO(&payload_set);
	SET(ISAKMP_PAYLOAD_PROPOSAL, &payload_set);
	if (message_parse_payloads(msg, p, ISAKMP_PAYLOAD_PROPOSAL,
	    p->p + ISAKMP_SA_SIT_OFF + len, &payload_set,
	    message_parse_proposal) == -1)
		return -1;

	return 0;
}

/* Validate the signature payload P in message MSG.  */
static int
message_validate_sig(struct message *msg, struct payload *p)
{
	if (!msg->exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_sig: payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	/* XXX Not implemented yet.  */
	return 0;
}

/* Validate the transform payload P in message MSG.  */
static int
message_validate_transform(struct message *msg, struct payload *p)
{
	u_int8_t        proto = GET_ISAKMP_PROP_PROTO(p->context->p);
	u_int8_t       *prop = p->context->p;

	if (!msg->exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_transform: "
		    "payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	if (msg->exchange->doi
	    ->validate_transform_id(proto, GET_ISAKMP_TRANSFORM_ID(p->p))) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_TRANSFORM_ID, 0, 1, 1);
		return -1;
	}
	/* Check that the reserved field is zero.  */
	if (!zero_test(p->p + ISAKMP_TRANSFORM_RESERVED_OFF,
	    ISAKMP_TRANSFORM_RESERVED_LEN)) {
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	/*
	 * Check that we get monotonically increasing transform numbers per
	 * proposal.
	 */
	if (prop != last_prop)
		last_prop = prop;
	else if (GET_ISAKMP_TRANSFORM_NO(p->p) <= last_xf_no) {
		message_drop(msg, ISAKMP_NOTIFY_BAD_PROPOSAL_SYNTAX, 0, 1, 1);
		return -1;
	}
	last_xf_no = GET_ISAKMP_TRANSFORM_NO(p->p);

	/* Validate the attributes.  */
	if (attribute_map(p->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    msg->exchange->doi->validate_attribute, msg)) {
		message_drop(msg, ISAKMP_NOTIFY_ATTRIBUTES_NOT_SUPPORTED,
		    0, 1, 1);
		return -1;
	}
	return 0;
}

/* Validate the vendor payload P in message MSG.  */
static int
message_validate_vendor(struct message *msg, struct payload *p)
{
	if (!msg->exchange) {
		/* We should have an exchange at this point.  */
		log_print("message_validate_vendor: payload out of sequence");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		return -1;
	}
	/* Vendor IDs are only allowed in phase 1.  */
	if (msg->exchange->phase != 1) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
		return -1;
	}
	check_vendor_openbsd(msg, p);
	dpd_check_vendor_payload(msg, p);
	nat_t_check_vendor_payload(msg, p);
	if (!(p->flags & PL_MARK))
		LOG_DBG((LOG_MESSAGE, 40, "message_validate_vendor: "
		    "vendor ID seen"));
	return 0;
}

/*
 * Add an index-record pointing to the payload at BUF in message MSG
 * to the PAYLOAD bucket of payloads.  This allows us to quickly reference
 * payloads by type.  Also stash the parent payload P link into the new
 * node so we can go from transforms -> payloads -> SAs.
 */
static int
message_index_payload(struct message *msg, struct payload *p, u_int8_t payload,
    u_int8_t *buf)
{
	struct payload *payload_node;

	/* Put the payload pointer into the right bucket.  */
	payload_node = malloc(sizeof *payload_node);
	if (!payload_node) {
		message_free(msg);
		return -1;
	}
	payload_node->p = buf;
	payload_node->context = p;
	payload_node->flags = 0;
	TAILQ_INSERT_TAIL(&msg->payload[payload], payload_node, link);
	return 0;
}

/*
 * Group each payload found in MSG by type for easy reference later.
 * While doing this, validate the generic parts of the message structure too.
 * NEXT is the 1st payload's type.  This routine will also register the
 * computed message length (i.e. without padding) in msg->iov[0].iov_len.
 */
static int
message_sort_payloads(struct message *msg, u_int8_t next)
{
	set	payload_set;
	int	i, sz;

	ZERO(&payload_set);
	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_MAX; i++)
		if (i != ISAKMP_PAYLOAD_PROPOSAL && i !=
		    ISAKMP_PAYLOAD_TRANSFORM)
			SET(i, &payload_set);
	sz = message_parse_payloads(msg, 0, next,
	    (u_int8_t *)msg->iov[0].iov_base + ISAKMP_HDR_SZ, &payload_set,
	    message_index_payload);
	if (sz == -1)
		return -1;
	msg->iov[0].iov_len = ISAKMP_HDR_SZ + sz;
	SET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base, ISAKMP_HDR_SZ + sz);
	return 0;
}

/* Run all the generic payload tests that the drafts specify.  */
static int
message_validate_payloads(struct message *msg)
{
	int             i;
	struct payload *p;
	struct field   *f;

	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_MAX; i++)
		TAILQ_FOREACH(p, &msg->payload[i], link) {
			LOG_DBG((LOG_MESSAGE, 60, "message_validate_payloads: "
			    "payload %s at %p of message %p",
			    constant_name(isakmp_payload_cst, i), p->p, msg));
			if ((f = message_get_field(i)) != NULL)
				field_dump_payload(f, p->p);
			if (message_validate_payload(msg, p, i))
				return -1;
		}
	return 0;
}

/*
 * All incoming messages go through here.  We do generic validity checks
 * and try to find or establish SAs.  Last but not least we try to find
 * the exchange this message, MSG, is part of, and feed it there.
 */
int
message_recv(struct message *msg)
{
	u_int8_t       *buf = msg->iov[0].iov_base;
	size_t          sz = msg->iov[0].iov_len;
	u_int8_t        exch_type;
	int             setup_isakmp_sa, msgid_is_zero;
	u_int8_t        flags;
	struct keystate *ks = 0;
	struct proto    tmp_proto;
	struct sa       tmp_sa;
	struct transport *t;

	/* Messages shorter than an ISAKMP header are bad.  */
	if (sz < ISAKMP_HDR_SZ || sz != GET_ISAKMP_HDR_LENGTH(buf)) {
		log_print("message_recv: bad message length");
		message_drop(msg, 0, 0, 1, 1);
		return -1;
	}
	/* Possibly dump a raw hex image of the message to the log channel.  */
	message_dump_raw("message_recv", msg, LOG_MESSAGE);

	/*
	 * If the responder cookie is zero, this is a request to setup an
	 * ISAKMP SA.  Otherwise the cookies should refer to an existing
	 * ISAKMP SA.
	 *
	 * XXX This is getting ugly, please reread later to see if it can be
	 * made nicer.
	 */
	setup_isakmp_sa = zero_test(buf + ISAKMP_HDR_RCOOKIE_OFF,
	    ISAKMP_HDR_RCOOKIE_LEN);
	if (setup_isakmp_sa) {
		/*
		 * This might be a retransmission of a former ISAKMP SA setup
		 * message.  If so, just drop it.
		 * XXX Must we really look in both the SA and exchange pools?
		 */
		if (exchange_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF) ||
		    sa_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF)) {
			/*
			 * XXX Later we should differentiate between
			 * retransmissions and potential replay attacks.
			 */
			LOG_DBG((LOG_MESSAGE, 90,
			    "message_recv: dropping setup for existing SA"));
			message_free(msg);
			return -1;
		}
	} else {
		msg->isakmp_sa = sa_lookup_by_header(buf, 0);
		if (msg->isakmp_sa)
			sa_reference(msg->isakmp_sa);

		/*
		 * If we cannot find an ISAKMP SA out of the cookies, this is
		 * either a responder's first reply, and we need to upgrade
		 * our exchange, or it's just plain invalid cookies.
		 */
		if (!msg->isakmp_sa) {
			msg->exchange = exchange_lookup_from_icookie(buf +
			    ISAKMP_HDR_ICOOKIE_OFF);
			if (msg->exchange && msg->exchange->phase == 1 &&
			    zero_test(msg->exchange->cookies +
			    ISAKMP_HDR_RCOOKIE_OFF, ISAKMP_HDR_RCOOKIE_LEN))
				exchange_upgrade_p1(msg);
			else {
				log_print("message_recv: invalid cookie(s) "
				    "%08x%08x %08x%08x",
				    decode_32(buf + ISAKMP_HDR_ICOOKIE_OFF),
				decode_32(buf + ISAKMP_HDR_ICOOKIE_OFF + 4),
				    decode_32(buf + ISAKMP_HDR_RCOOKIE_OFF),
				decode_32(buf + ISAKMP_HDR_RCOOKIE_OFF + 4));
				tmp_proto.sa = &tmp_sa;
				tmp_sa.doi = doi_lookup(ISAKMP_DOI_ISAKMP);
				tmp_proto.proto = ISAKMP_PROTO_ISAKMP;
				tmp_proto.spi_sz[1] = ISAKMP_HDR_COOKIES_LEN;
				tmp_proto.spi[1] =
				    buf + ISAKMP_HDR_COOKIES_OFF;
				message_drop(msg, ISAKMP_NOTIFY_INVALID_COOKIE,
				    &tmp_proto, 1, 1);
				return -1;
			}
#if 0
			msg->isakmp_sa = sa_lookup_from_icookie(buf +
			    ISAKMP_HDR_ICOOKIE_OFF);
			if (msg->isakmp_sa)
				sa_isakmp_upgrade(msg);
#endif
		}
		msg->exchange = exchange_lookup(buf, 1);
	}

	if (message_check_duplicate(msg))
		return -1;

	if (GET_ISAKMP_HDR_NEXT_PAYLOAD(buf) >= ISAKMP_PAYLOAD_RESERVED_MIN) {
		log_print("message_recv: invalid payload type %d in ISAKMP "
		    "header (check passphrases, if applicable and in Phase 1)",
		    GET_ISAKMP_HDR_NEXT_PAYLOAD(buf));
		message_drop(msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
		return -1;
	}
	/* Validate that the message is of version 1.0.  */
	if (ISAKMP_VERSION_MAJOR(GET_ISAKMP_HDR_VERSION(buf)) != 1) {
		log_print("message_recv: invalid version major %d",
		    ISAKMP_VERSION_MAJOR(GET_ISAKMP_HDR_VERSION(buf)));
		message_drop(msg, ISAKMP_NOTIFY_INVALID_MAJOR_VERSION, 0, 1,
		    1);
		return -1;
	}
	if (ISAKMP_VERSION_MINOR(GET_ISAKMP_HDR_VERSION(buf)) != 0) {
		log_print("message_recv: invalid version minor %d",
		    ISAKMP_VERSION_MINOR(GET_ISAKMP_HDR_VERSION(buf)));
		message_drop(msg, ISAKMP_NOTIFY_INVALID_MINOR_VERSION, 0, 1,
		    1);
		return -1;
	}
	/*
	 * Validate the exchange type.  If it's a DOI-specified exchange wait
	 * until after all payloads have been seen for the validation as the
	 * SA payload might not yet have been parsed, thus the DOI might be
	 * unknown.
	 */
	exch_type = GET_ISAKMP_HDR_EXCH_TYPE(buf);
	if (exch_type == ISAKMP_EXCH_NONE ||
	    (exch_type >= ISAKMP_EXCH_FUTURE_MIN &&
	    exch_type <= ISAKMP_EXCH_FUTURE_MAX) ||
	    (setup_isakmp_sa && exch_type >= ISAKMP_EXCH_DOI_MIN)) {
		log_print("message_recv: invalid exchange type %s",
		    constant_name(isakmp_exch_cst, exch_type));
		message_drop(msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 1,
		    1);
		return -1;
	}
	/*
	 * Check for unrecognized flags, or the encryption flag when we don't
	 * have an ISAKMP SA to decrypt with.
	 */
	flags = GET_ISAKMP_HDR_FLAGS(buf);
	if (flags & ~(ISAKMP_FLAGS_ENC | ISAKMP_FLAGS_COMMIT |
	    ISAKMP_FLAGS_AUTH_ONLY)) {
		log_print("message_recv: invalid flags 0x%x",
		    GET_ISAKMP_HDR_FLAGS(buf));
		message_drop(msg, ISAKMP_NOTIFY_INVALID_FLAGS, 0, 1, 1);
		return -1;
	}
	/*
	 * If we are about to setup an ISAKMP SA, the message ID must be
	 * zero.
	 */
	msgid_is_zero = zero_test(buf + ISAKMP_HDR_MESSAGE_ID_OFF,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	if (setup_isakmp_sa && !msgid_is_zero) {
		log_print("message_recv: invalid message id");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_MESSAGE_ID, 0, 1, 1);
		return -1;
	}
	if (!setup_isakmp_sa && msgid_is_zero) {
		/*
		 * XXX Very likely redundant, look at the  else clause of the
		 * if (setup_isakmp_sa) statement above.
		 */
		msg->exchange = exchange_lookup(buf, 0);
		if (!msg->exchange) {
			log_print("message_recv: phase 1 message after "
			    "ISAKMP SA is ready");
			message_free(msg);
			return -1;
		} else if (msg->exchange->last_sent) {
			LOG_DBG((LOG_MESSAGE, 80, "message_recv: resending "
			    "last message from phase 1"));
			message_send(msg->exchange->last_sent);
		}
	}
	if (flags & ISAKMP_FLAGS_ENC) {
		if (!msg->isakmp_sa) {
			LOG_DBG((LOG_MISC, 10, "message_recv: no isakmp_sa "
			    "for encrypted message"));
			message_free(msg);
			return -1;
		}
		/* Decrypt rest of message using a DOI-specified IV.  */
		ks = msg->isakmp_sa->doi->get_keystate(msg);
		if (!ks) {
			message_free(msg);
			return -1;
		}
		msg->orig = malloc(sz);
		if (!msg->orig) {
			message_free(msg);
			free(ks);
			return -1;
		}
		memcpy(msg->orig, buf, sz);
		crypto_decrypt(ks, buf + ISAKMP_HDR_SZ, sz - ISAKMP_HDR_SZ);
	} else
		msg->orig = buf;
	msg->orig_sz = sz;

	/* IKE packet capture */
	message_packet_log(msg);

	/*
	 * Check the overall payload structure at the same time as indexing
	 * them by type.
	 */
	if (GET_ISAKMP_HDR_NEXT_PAYLOAD(buf) != ISAKMP_PAYLOAD_NONE &&
	    message_sort_payloads(msg, GET_ISAKMP_HDR_NEXT_PAYLOAD(buf))) {
		free(ks);
		return -1;
	}
	/*
	 * Run generic payload tests now.  If anything fails these checks, the
	 * message needs either to be retained for later duplicate checks or
	 * freed entirely.
	 * XXX Should SAs and even transports be cleaned up then too?
	 */
	if (message_validate_payloads(msg)) {
		free(ks);
		return -1;
	}
	/*
	 * If we have not found an exchange by now something is definitely
	 * wrong.
	 */
	if (!msg->exchange) {
		log_print("message_recv: no exchange");
		message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
		free(ks);
		return -1;
	}
	/*
	 * NAT-T may have switched ports for us. We need to replace the
	 * old ISAKMP SA transport here with one that contains the proper
	 * (i.e translated) ports.
	 */
	if (msg->isakmp_sa && msg->exchange->phase == 1) {
		t = msg->isakmp_sa->transport;
		msg->isakmp_sa->transport = msg->transport;
		transport_reference(msg->transport);
		transport_release(t);
	}

	/*
	 * Now we can validate DOI-specific exchange types.  If we have no SA
	 * DOI-specific exchange types are definitely wrong.
	 */
	if (exch_type >= ISAKMP_EXCH_DOI_MIN &&
	    msg->exchange->doi->validate_exchange(exch_type)) {
		log_print("message_recv: invalid DOI exchange type %d",
		    exch_type);
		message_drop(msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 1,
		    1);
		free(ks);
		return -1;
	}
	/* Make sure the IV we used gets saved in the proper SA.  */
	if (ks) {
		if (!msg->exchange->keystate) {
			msg->exchange->keystate = ks;
			msg->exchange->crypto = ks->xf;
		} else
			free(ks);
	}
	/* Handle the flags.  */
	if (flags & ISAKMP_FLAGS_ENC)
		msg->exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
	if ((msg->exchange->flags & EXCHANGE_FLAG_COMMITTED) == 0 &&
	    (flags & ISAKMP_FLAGS_COMMIT))
		msg->exchange->flags |= EXCHANGE_FLAG_HE_COMMITTED;

	/*
	 * Except for the 3rd Aggressive Mode message, require encryption
	 * as soon as we have the keystate for it.
	 */
	if ((flags & ISAKMP_FLAGS_ENC) == 0 &&
	    (msg->exchange->phase == 2 ||
		(msg->exchange->keystate &&
		    msg->exchange->type != ISAKMP_EXCH_AGGRESSIVE))) {
		log_print("message_recv: cleartext phase %d message",
		    msg->exchange->phase);
		message_drop(msg, ISAKMP_NOTIFY_INVALID_FLAGS, 0, 1, 1);
		return -1;
	}

	/* OK let the exchange logic do the rest.  */
	exchange_run(msg);

	return 0;
}

void
message_send_expire(struct message *msg)
{
	msg->retrans = 0;

	message_send(msg);
}

/* Queue up message MSG for transmittal.  */
void
message_send(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	struct message *m;
	struct msg_head *q;

	/* Remove retransmissions on this message  */
	if (msg->retrans) {
		timer_remove_event(msg->retrans);
		msg->retrans = 0;
	}
	/* IKE packet capture */
	message_packet_log(msg);

	/*
	 * If the ISAKMP SA has set up encryption, encrypt the message.
	 * However, in a retransmit, it is already encrypted.
	 */
	if ((msg->flags & MSG_ENCRYPTED) == 0 &&
	    exchange->flags & EXCHANGE_FLAG_ENCRYPT) {
		if (!exchange->keystate) {
			exchange->keystate = exchange->doi->get_keystate(msg);
			if (!exchange->keystate)
				return;
			exchange->crypto = exchange->keystate->xf;
			exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
		}
		if (message_encrypt(msg)) {
			/* XXX Log.  */
			return;
		}
	}
	/* Keep the COMMIT bit on.  */
	if (exchange->flags & EXCHANGE_FLAG_COMMITTED)
		SET_ISAKMP_HDR_FLAGS(msg->iov[0].iov_base,
		    GET_ISAKMP_HDR_FLAGS(msg->iov[0].iov_base)
		    | ISAKMP_FLAGS_COMMIT);

	message_dump_raw("message_send", msg, LOG_MESSAGE);
	msg->flags |= MSG_IN_TRANSIT;
	exchange->in_transit = msg;

	/*
	 * If we get a retransmission of a message before our response
	 * has left the queue, don't queue it again, as it will result
	 * in a circular list.
	 */
	q = msg->transport->vtbl->get_queue(msg);
	for (m = TAILQ_FIRST(q); m; m = TAILQ_NEXT(m, link))
		if (m == msg) {
			LOG_DBG((LOG_MESSAGE, 60,
			    "message_send: msg %p already on sendq %p", m, q));
			return;
		}
	TAILQ_INSERT_TAIL(q, msg, link);
}

/*
 * Setup the ISAKMP message header for message MSG.  EXCHANGE is the exchange
 * type, FLAGS are the ISAKMP header flags and MSG_ID is message ID
 * identifying the exchange.
 */
void
message_setup_header(struct message *msg, u_int8_t exchange, u_int8_t flags,
    u_int8_t *msg_id)
{
	u_int8_t	*buf = msg->iov[0].iov_base;

	SET_ISAKMP_HDR_ICOOKIE(buf, msg->exchange->cookies);
	SET_ISAKMP_HDR_RCOOKIE(buf, msg->exchange->cookies +
	    ISAKMP_HDR_ICOOKIE_LEN);
	SET_ISAKMP_HDR_NEXT_PAYLOAD(buf, ISAKMP_PAYLOAD_NONE);
	SET_ISAKMP_HDR_VERSION(buf, ISAKMP_VERSION_MAKE(1, 0));
	SET_ISAKMP_HDR_EXCH_TYPE(buf, exchange);
	SET_ISAKMP_HDR_FLAGS(buf, flags);
	SET_ISAKMP_HDR_MESSAGE_ID(buf, msg_id);
	SET_ISAKMP_HDR_LENGTH(buf, msg->iov[0].iov_len);
}

/*
 * Add the payload of type PAYLOAD in BUF sized SZ to the MSG message.
 * The caller thereby is released from the responsibility of freeing BUF,
 * unless we return a failure of course.  If LINK is set the former
 * payload's "next payload" field to PAYLOAD.
 *
 * XXX We might want to resize the iov array several slots at a time.
 */
int
message_add_payload(struct message *msg, u_int8_t payload, u_int8_t *buf,
    size_t sz, int link)
{
	struct iovec   *new_iov;
	struct payload *payload_node;

	payload_node = calloc(1, sizeof *payload_node);
	if (!payload_node) {
		log_error("message_add_payload: calloc (1, %lu) failed",
		    (unsigned long)sizeof *payload_node);
		return -1;
	}
	new_iov = reallocarray(msg->iov, msg->iovlen + 1,
	    sizeof *msg->iov);
	if (!new_iov) {
		log_error("message_add_payload: realloc (%p, %lu) failed",
		    msg->iov, (msg->iovlen + 1) *
		    (unsigned long)sizeof *msg->iov);
		free(payload_node);
		return -1;
	}
	msg->iov = new_iov;
	new_iov[msg->iovlen].iov_base = buf;
	new_iov[msg->iovlen].iov_len = sz;
	msg->iovlen++;
	if (link)
		*msg->nextp = payload;
	msg->nextp = buf + ISAKMP_GEN_NEXT_PAYLOAD_OFF;
	*msg->nextp = ISAKMP_PAYLOAD_NONE;
	SET_ISAKMP_GEN_RESERVED(buf, 0);
	SET_ISAKMP_GEN_LENGTH(buf, sz);
	SET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base,
	    GET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base) + sz);

	/*
	 * For the sake of exchange_validate we index the payloads even in
	 * outgoing messages, however context and flags are uninteresting in
	 * this situation.
	 */
	payload_node->p = buf;
	TAILQ_INSERT_TAIL(&msg->payload[payload], payload_node, link);
	return 0;
}

/* XXX Move up when ready.  */
struct info_args {
	char            discr;
	u_int32_t       doi;
	u_int8_t        proto;
	u_int16_t       spi_sz;
	union {
		struct {
			u_int16_t       msg_type;
			u_int8_t       *spi;
		} n;
		struct {
			u_int16_t       nspis;
			u_int8_t       *spis;
		} d;
		struct {
			u_int16_t	msg_type;
			u_int8_t	*spi;
			u_int32_t	seq;
		} dpd;
	} u;
};

/*
 * As a reaction to the incoming message MSG create an informational exchange
 * protected by ISAKMP_SA and send a notify payload of type NOTIFY, with
 * fields initialized from SA.  INCOMING is true if the SPI field should be
 * filled with the incoming SPI and false if it is to be filled with the
 * outgoing one.
 *
 * XXX Should we handle sending multiple notify payloads?  The draft allows
 * it, but do we need it?  Furthermore, should we not return a success
 * status value?
 */
void
message_send_notification(struct message *msg, struct sa *isakmp_sa,
    u_int16_t notify, struct proto *proto, int incoming)
{
	struct info_args args;
	struct sa      *doi_sa = proto ? proto->sa : isakmp_sa;

	args.discr = 'N';
	args.doi = doi_sa ? doi_sa->doi->id : ISAKMP_DOI_ISAKMP;
	args.proto = proto ? proto->proto : ISAKMP_PROTO_ISAKMP;
	args.spi_sz = proto ? proto->spi_sz[incoming] : 0;
	args.u.n.msg_type = notify;
	args.u.n.spi = proto ? proto->spi[incoming] : 0;
	if (isakmp_sa && (isakmp_sa->flags & SA_FLAG_READY))
		exchange_establish_p2(isakmp_sa, ISAKMP_EXCH_INFO, 0, &args,
		    0, 0);
	else
		exchange_establish_p1(msg->transport, ISAKMP_EXCH_INFO,
		    msg->exchange ? msg->exchange->doi->id : ISAKMP_DOI_ISAKMP,
		    0, &args, 0, 0, 0);
}

/* Send a DELETE inside an informational exchange for each protocol in SA.  */
void
message_send_delete(struct sa *sa)
{
	struct info_args args;
	struct proto   *proto;
	struct sa      *isakmp_sa;
	struct sockaddr *dst;

	if (!sa->transport)
		return;

	sa->transport->vtbl->get_dst(sa->transport, &dst);
	isakmp_sa = sa_isakmp_lookup_by_peer(dst, SA_LEN(dst));
	if (!isakmp_sa) {
		/*
		 * XXX We ought to setup an ISAKMP SA with our peer here and
		 * send the DELETE over that one.
		 */
		return;
	}
	args.discr = 'D';
	args.doi = sa->doi->id;
	args.u.d.nspis = 1;
	for (proto = TAILQ_FIRST(&sa->protos); proto;
	    proto = TAILQ_NEXT(proto, link)) {
		switch (proto->proto) {
		case ISAKMP_PROTO_ISAKMP:
			args.spi_sz = ISAKMP_HDR_COOKIES_LEN;
			args.u.d.spis = sa->cookies;
			break;

		case IPSEC_PROTO_IPSEC_AH:
		case IPSEC_PROTO_IPSEC_ESP:
		case IPSEC_PROTO_IPCOMP:
			args.spi_sz = proto->spi_sz[1];
			args.u.d.spis = proto->spi[1];
			break;
		default:
			log_print("message_send_delete: cannot delete unknown "
			    "protocol %d", proto->proto);
			continue;
		}

		args.proto = proto->proto;
		exchange_establish_p2(isakmp_sa, ISAKMP_EXCH_INFO, 0, &args,
		    0, 0);
	}
}

void
message_send_dpd_notify(struct sa* isakmp_sa, u_int16_t notify, u_int32_t seq)
{
	struct info_args args;

	args.discr = 'P';
	args.doi = IPSEC_DOI_IPSEC;
	args.proto = ISAKMP_PROTO_ISAKMP;
	args.spi_sz = ISAKMP_HDR_COOKIES_LEN;
	args.u.dpd.msg_type = notify;
	args.u.dpd.spi = isakmp_sa->cookies;
	args.u.dpd.seq = htonl(seq);

	exchange_establish_p2(isakmp_sa, ISAKMP_EXCH_INFO, 0, &args, 0, 0);
}

/* Build the informational message into MSG.  */
int
message_send_info(struct message *msg)
{
	u_int8_t       *buf;
	size_t          sz = 0;
	struct info_args *args = msg->extra;
	u_int8_t	payload;

	/* Let the DOI get the first hand on the message.  */
	if (msg->exchange->doi->informational_pre_hook)
		if (msg->exchange->doi->informational_pre_hook(msg))
			return -1;

	switch (args->discr) {
	case 'P':
		sz = sizeof args->u.dpd.seq;
		/* FALLTHROUGH */
	case 'N':
		sz += ISAKMP_NOTIFY_SPI_OFF + args->spi_sz;
		break;
	case 'D':
	default:	/* Silence gcc */
		sz = ISAKMP_DELETE_SPI_OFF + args->u.d.nspis * args->spi_sz;
		break;
	}

	buf = calloc(1, sz);
	if (!buf) {
		log_error("message_send_info: calloc (1, %lu) failed",
		    (unsigned long)sz);
		message_free(msg);
		return -1;
	}
	switch (args->discr) {
	case 'P':
		memcpy(buf + ISAKMP_NOTIFY_SPI_OFF + args->spi_sz,
		    &args->u.dpd.seq, sizeof args->u.dpd.seq);
		/* FALLTHROUGH */
	case 'N':
		/* Build the NOTIFY payload.  */
		payload = ISAKMP_PAYLOAD_NOTIFY;
		SET_ISAKMP_NOTIFY_DOI(buf, args->doi);
		SET_ISAKMP_NOTIFY_PROTO(buf, args->proto);
		SET_ISAKMP_NOTIFY_SPI_SZ(buf, args->spi_sz);
		SET_ISAKMP_NOTIFY_MSG_TYPE(buf, args->u.n.msg_type);
		memcpy(buf + ISAKMP_NOTIFY_SPI_OFF, args->u.n.spi,
		    args->spi_sz);
		break;

	case 'D':
	default:		/* Silence GCC.  */
		/* Build the DELETE payload.  */
		payload = ISAKMP_PAYLOAD_DELETE;
		SET_ISAKMP_DELETE_DOI(buf, args->doi);
		SET_ISAKMP_DELETE_PROTO(buf, args->proto);
		SET_ISAKMP_DELETE_SPI_SZ(buf, args->spi_sz);
		SET_ISAKMP_DELETE_NSPIS(buf, args->u.d.nspis);
		memcpy(buf + ISAKMP_DELETE_SPI_OFF, args->u.d.spis,
		    args->u.d.nspis * args->spi_sz);
		msg->flags |= MSG_PRIORITIZED;
		break;
	}

	if (message_add_payload(msg, payload, buf, sz, 1)) {
		free(buf);
		message_free(msg);
		return -1;
	}
	/* Let the DOI get the last hand on the message.  */
	if (msg->exchange->doi->informational_post_hook)
		if (msg->exchange->doi->informational_post_hook(msg)) {
			message_free(msg);
			return -1;
		}
	return 0;
}

/*
 * Drop the MSG message due to reason given in NOTIFY.  If NOTIFY is set
 * send out a notification to the originator.  Fill this notification with
 * values from PROTO.  INCOMING decides which SPI to include.  If CLEAN is
 * set, free the message when ready with it.
 */
void
message_drop(struct message *msg, int notify, struct proto *proto,
    int incoming, int clean)
{
	struct transport *t = msg->transport;
	struct sockaddr *dst;
	char           *address;
	short           port = 0;

	t->vtbl->get_dst(t, &dst);
	if (sockaddr2text(dst, &address, 0)) {
		log_error("message_drop: sockaddr2text () failed");
		address = 0;
	}
	switch (dst->sa_family) {
	case AF_INET:
		port = ((struct sockaddr_in *)dst)->sin_port;
		break;
	case AF_INET6:
		port = ((struct sockaddr_in6 *)dst)->sin6_port;
		break;
	default:
		log_print("message_drop: unknown protocol family %d",
		    dst->sa_family);
	}

	log_print("dropped message from %s port %d due to notification type "
	    "%s", address ? address : "<unknown>", htons(port),
	    constant_name(isakmp_notify_cst, notify));

	free(address);

	/* If specified, return a notification.  */
	if (notify)
		message_send_notification(msg, msg->isakmp_sa, notify, proto,
		    incoming);
	if (clean)
		message_free(msg);
}

/*
 * If the user demands debug printouts, printout MSG with as much detail
 * as we can without resorting to per-payload handling.
 */
void
message_dump_raw(char *header, struct message *msg, int class)
{
	u_int32_t	i, j, k = 0;
	char            buf[80], *p = buf;

	LOG_DBG((class, 70, "%s: message %p", header, msg));
	field_dump_payload(isakmp_hdr_fld, msg->iov[0].iov_base);
	for (i = 0; i < msg->iovlen; i++)
		for (j = 0; j < msg->iov[i].iov_len; j++) {
			snprintf(p, sizeof buf - (int) (p - buf), "%02x",
			    ((u_int8_t *) msg->iov[i].iov_base)[j]);
			p += strlen(p);
			if (++k % 32 == 0) {
				*p = '\0';
				LOG_DBG((class, 70, "%s: %s", header, buf));
				p = buf;
			} else if (k % 4 == 0)
				*p++ = ' ';
		}
	*p = '\0';
	if (p != buf)
		LOG_DBG((class, 70, "%s: %s", header, buf));
}

static void
message_packet_log(struct message *msg)
{
	struct sockaddr *src, *dst;
	struct transport *t = msg->transport;

	/* Don't log retransmissions. Redundant for incoming packets... */
	if (msg->xmits > 0)
		return;

	if (msg->exchange && msg->exchange->flags & EXCHANGE_FLAG_NAT_T_ENABLE)
		t = ((struct virtual_transport *)msg->transport)->encap;

	/* Figure out direction. */
	if (msg->exchange &&
	    msg->exchange->initiator ^ (msg->exchange->step % 2)) {
		t->vtbl->get_src(t, &src);
		t->vtbl->get_dst(t, &dst);
	} else {
		t->vtbl->get_src(t, &dst);
		t->vtbl->get_dst(t, &src);
	}

	log_packet_iov(src, dst, msg->iov, msg->iovlen);
}

/*
 * Encrypt an outgoing message MSG.  As outgoing messages are represented
 * with an iovec with one segment per payload, we need to coalesce them
 * into just une buffer containing all payloads and some padding before
 * we encrypt.
 */
static int
message_encrypt(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	size_t          i, sz = 0;
	u_int8_t       *buf;

	/* If no payloads, nothing to do.  */
	if (msg->iovlen == 1)
		return 0;

	/*
	 * For encryption we need to put all payloads together in a single
	 * buffer.  This buffer should be padded to the current crypto
	 * transform's blocksize.
	 */
	for (i = 1; i < msg->iovlen; i++)
		sz += msg->iov[i].iov_len;
	sz = ((sz + exchange->crypto->blocksize - 1) /
	    exchange->crypto->blocksize) * exchange->crypto->blocksize;
	buf = realloc(msg->iov[1].iov_base, sz);
	if (!buf) {
		log_error("message_encrypt: realloc (%p, %lu) failed",
		    msg->iov[1].iov_base, (unsigned long) sz);
		return -1;
	}
	msg->iov[1].iov_base = buf;
	for (i = 2; i < msg->iovlen; i++) {
		memcpy(buf + msg->iov[1].iov_len, msg->iov[i].iov_base,
		    msg->iov[i].iov_len);
		msg->iov[1].iov_len += msg->iov[i].iov_len;
		free(msg->iov[i].iov_base);
	}

	/* Pad with zeroes.  */
	memset(buf + msg->iov[1].iov_len, '\0', sz - msg->iov[1].iov_len);
	msg->iov[1].iov_len = sz;
	msg->iovlen = 2;

	SET_ISAKMP_HDR_FLAGS(msg->iov[0].iov_base,
	    GET_ISAKMP_HDR_FLAGS(msg->iov[0].iov_base) | ISAKMP_FLAGS_ENC);
	SET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base, ISAKMP_HDR_SZ + sz);
	crypto_encrypt(exchange->keystate, buf, msg->iov[1].iov_len);
	msg->flags |= MSG_ENCRYPTED;

	/* Update the IV so we can decrypt the next incoming message.  */
	crypto_update_iv(exchange->keystate);

	return 0;
}

/*
 * Check whether the message MSG is a duplicate of the last one negotiating
 * this specific SA.
 */
static int
message_check_duplicate(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	size_t          sz = msg->iov[0].iov_len;
	u_int8_t       *pkt = msg->iov[0].iov_base;

	/* If no SA has been found, we cannot test, thus it's good.  */
	if (!exchange)
		return 0;

	LOG_DBG((LOG_MESSAGE, 90, "message_check_duplicate: last_received %p",
	    exchange->last_received));
	if (exchange->last_received) {
		LOG_DBG_BUF((LOG_MESSAGE, 95,
		    "message_check_duplicate: last_received",
		    exchange->last_received->orig,
		    exchange->last_received->orig_sz));
		/* Is it a duplicate, lose the new one.  */
		if (sz == exchange->last_received->orig_sz &&
		    memcmp(pkt, exchange->last_received->orig, sz) == 0) {
			LOG_DBG((LOG_MESSAGE, 80,
			    "message_check_duplicate: dropping dup"));

			/*
			 * Retransmit if the previous sent message was the last
			 * of an exchange, otherwise just wait for the
			 * ordinary retransmission.
			 */
			if (exchange->last_sent && (exchange->last_sent->flags
			    & MSG_LAST))
				message_send(exchange->last_sent);
			message_free(msg);
			return -1;
		}
	}
	/*
	 * As this new message is an indication that state is moving forward
	 * at the peer, remove the retransmit timer on our last message.
	 */
	if (exchange->last_sent) {
		if (exchange->last_sent == exchange->in_transit) {
			struct message *m = exchange->in_transit;
			TAILQ_REMOVE(m->transport->vtbl->get_queue(m), m,
			    link);
			exchange->in_transit = 0;
		}
		message_free(exchange->last_sent);
		exchange->last_sent = 0;
	}
	return 0;
}

/* Helper to message_negotiate_sa.  */
static __inline struct payload *
step_transform(struct payload *tp, struct payload **propp,
    struct payload **sap)
{
	tp = TAILQ_NEXT(tp, link);
	if (tp) {
		*propp = tp->context;
		*sap = (*propp)->context;
	}
	return tp;
}

/*
 * Pick out the first transforms out of MSG (which should contain at least one
 * SA payload) we accept as a full protection suite.
 */
int
message_negotiate_sa(struct message *msg, int (*validate)(struct exchange *,
    struct sa *, struct sa *))
{
	struct payload *tp, *propp, *sap, *next_tp = 0, *next_propp, *next_sap;
	struct payload *saved_tp = 0, *saved_propp = 0, *saved_sap = 0;
	struct sa      *sa;
	struct proto   *proto;
	int             suite_ok_so_far = 0;
	struct exchange *exchange = msg->exchange;

	/*
	 * This algorithm is a weird bottom-up thing... mostly due to the
	 * payload links pointing upwards.
	 *
	 * The algorithm goes something like this:
	 * Foreach transform
	 *   If transform is compatible
	 *     Remember that this protocol can work
	 *     Skip to last transform of this protocol
	 *   If next transform belongs to a new protocol inside the same suite
	 *     If no transform was found for the current protocol
	 *       Forget all earlier transforms for protocols in this suite
	 *       Skip to last transform of this suite
	 *   If next transform belongs to a new suite
	 *     If the current protocol had an OK transform
	 *       Skip to the last transform of this SA
	 *   If the next transform belongs to a new SA
	 *     If no transforms have been chosen
	 *       Issue a NO_PROPOSAL_CHOSEN notification
	 */

	sa = TAILQ_FIRST(&exchange->sa_list);
	for (tp = payload_first(msg, ISAKMP_PAYLOAD_TRANSFORM); tp;
	    tp = next_tp) {
		propp = tp->context;
		sap = propp->context;
		sap->flags |= PL_MARK;
		next_tp = step_transform(tp, &next_propp, &next_sap);

		/* For each transform, see if it is compatible.  */
		if (!attribute_map(tp->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		    GET_ISAKMP_GEN_LENGTH(tp->p) -
		    ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		    exchange->doi->is_attribute_incompatible, msg)) {
			LOG_DBG((LOG_NEGOTIATION, 30, "message_negotiate_sa: "
			    "transform %d proto %d proposal %d ok",
			    GET_ISAKMP_TRANSFORM_NO(tp->p),
			    GET_ISAKMP_PROP_PROTO(propp->p),
			    GET_ISAKMP_PROP_NO(propp->p)));
			if (sa_add_transform(sa, tp, exchange->initiator,
			    &proto))
				goto cleanup;
			suite_ok_so_far = 1;

			saved_tp = next_tp;
			saved_propp = next_propp;
			saved_sap = next_sap;
			/* Skip to last transform of this protocol proposal. */
			while ((next_tp = step_transform(tp, &next_propp,
			    &next_sap)) && next_propp == propp)
				tp = next_tp;
		}
retry_transform:
		/*
		 * Figure out if we will be looking at a new protocol proposal
		 * inside the current protection suite.
		 */
		if (next_tp && propp != next_propp && sap == next_sap &&
		    (GET_ISAKMP_PROP_NO(propp->p) ==
		    GET_ISAKMP_PROP_NO(next_propp->p))) {
			if (!suite_ok_so_far) {
				LOG_DBG((LOG_NEGOTIATION, 30,
				    "message_negotiate_sa: proto %d proposal "
				    "%d failed",
				    GET_ISAKMP_PROP_PROTO(propp->p),
				    GET_ISAKMP_PROP_NO(propp->p)));
				/*
				 * Remove potentially succeeded choices from
				 * the SA.
				 */
				while ((proto = TAILQ_FIRST(&sa->protos)))
					proto_free(proto);

				/*
				 * Skip to the last transform of this
				 * protection suite.
				 */
				while ((next_tp = step_transform(tp,
				    &next_propp, &next_sap)) &&
				    (GET_ISAKMP_PROP_NO(next_propp->p) ==
				    GET_ISAKMP_PROP_NO(propp->p)) &&
				    next_sap == sap)
					tp = next_tp;
			}
			suite_ok_so_far = 0;
		}
		/*
		 * Figure out if we will be looking at a new protection
		 * suite.
		 */
		if (!next_tp ||
		    (propp != next_propp && (GET_ISAKMP_PROP_NO(propp->p) !=
		    GET_ISAKMP_PROP_NO(next_propp->p))) ||
		    sap != next_sap) {
			/*
			 * Check if the suite we just considered was OK, if so
			 * we check it against the accepted ones.
			 */
			if (suite_ok_so_far) {
				if (!validate || validate(exchange, sa,
				    msg->isakmp_sa)) {
					LOG_DBG((LOG_NEGOTIATION, 30,
					    "message_negotiate_sa: proposal "
					    "%d succeeded",
					    GET_ISAKMP_PROP_NO(propp->p)));

					/*
					 * Skip to the last transform of this
					 * SA.
					 */
					while ((next_tp = step_transform(tp,
					    &next_propp, &next_sap)) &&
					    next_sap == sap)
						tp = next_tp;
				} else {
					/* Backtrack.  */
					LOG_DBG((LOG_NEGOTIATION, 30,
					    "message_negotiate_sa: proposal "
					    "%d failed",
					    GET_ISAKMP_PROP_NO(propp->p)));
					next_tp = saved_tp;
					next_propp = saved_propp;
					next_sap = saved_sap;
					suite_ok_so_far = 0;

					/*
					 * Remove potentially succeeded
					 * choices from the SA.
					 */
					while ((proto =
					    TAILQ_FIRST(&sa->protos)))
						proto_free(proto);
					goto retry_transform;
				}
			}
		}
		/* Have we walked all the proposals of an SA?  */
		if (!next_tp || sap != next_sap) {
			if (!suite_ok_so_far) {
				/*
				 * XXX We cannot possibly call this a drop...
				 * seeing we just turn down one of the offers,
				 * can we?  I suggest renaming message_drop to
				 * something else.
				 */
				log_print("message_negotiate_sa: no "
				    "compatible proposal found");
				message_drop(msg,
				    ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
			}
			sa = TAILQ_NEXT(sa, next);
		}
	}
	return 0;

cleanup:
	/*
	 * Remove potentially succeeded choices from the SA.
	 */
	while ((proto = TAILQ_FIRST(&sa->protos)))
		proto_free(proto);
	return -1;
}

/*
 * Add SA, proposal and transform payload(s) to MSG out of information
 * found in the exchange MSG is part of..
 */
int
message_add_sa_payload(struct message *msg)
{
	struct exchange *exchange = msg->exchange;
	u_int8_t       *sa_buf, *saved_nextp_sa, *saved_nextp_prop;
	size_t          sa_len, extra_sa_len;
	int             i, nprotos = 0;
	struct proto   *proto;
	u_int8_t      **transforms = 0, **proposals = 0;
	size_t         *transform_lens = 0, *proposal_lens = 0;
	struct sa      *sa;
	struct doi     *doi = exchange->doi;
	u_int8_t       *spi = 0;
	size_t          spi_sz;

	/*
	 * Generate SA payloads.
	 */
	for (sa = TAILQ_FIRST(&exchange->sa_list); sa;
	    sa = TAILQ_NEXT(sa, next)) {
		/* Setup a SA payload.  */
		sa_len = ISAKMP_SA_SIT_OFF + doi->situation_size();
		extra_sa_len = 0;
		sa_buf = malloc(sa_len);
		if (!sa_buf) {
			log_error("message_add_sa_payload: "
			    "malloc (%lu) failed", (unsigned long)sa_len);
			goto cleanup;
		}
		SET_ISAKMP_SA_DOI(sa_buf, doi->id);
		doi->setup_situation(sa_buf);

		/* Count transforms.  */
		nprotos = 0;
		for (proto = TAILQ_FIRST(&sa->protos); proto;
		    proto = TAILQ_NEXT(proto, link))
			nprotos++;

		/*
		 * Allocate transient transform and proposal payload/size
		 * vectors.
		 */
		transforms = calloc(nprotos, sizeof *transforms);
		if (!transforms) {
			log_error("message_add_sa_payload: calloc (%d, %lu) "
			    "failed", nprotos,
			    (unsigned long)sizeof *transforms);
			goto cleanup;
		}
		transform_lens = calloc(nprotos, sizeof *transform_lens);
		if (!transform_lens) {
			log_error("message_add_sa_payload: calloc (%d, %lu) "
			    "failed", nprotos,
			    (unsigned long) sizeof *transform_lens);
			goto cleanup;
		}
		proposals = calloc(nprotos, sizeof *proposals);
		if (!proposals) {
			log_error("message_add_sa_payload: calloc (%d, %lu) "
			    "failed", nprotos,
			    (unsigned long)sizeof *proposals);
			goto cleanup;
		}
		proposal_lens = calloc(nprotos, sizeof *proposal_lens);
		if (!proposal_lens) {
			log_error("message_add_sa_payload: calloc (%d, %lu) "
			    "failed", nprotos,
			    (unsigned long)sizeof *proposal_lens);
			goto cleanup;
		}
		/* Pick out the chosen transforms.  */
		for (proto = TAILQ_FIRST(&sa->protos), i = 0; proto;
		    proto = TAILQ_NEXT(proto, link), i++) {
			transform_lens[i] =
			    GET_ISAKMP_GEN_LENGTH(proto->chosen->p);
			transforms[i] = malloc(transform_lens[i]);
			if (!transforms[i]) {
				log_error("message_add_sa_payload: malloc "
				    "(%lu) failed",
				    (unsigned long)transform_lens[i]);
				goto cleanup;
			}
			/* Get incoming SPI from application.  */
			if (doi->get_spi) {
				spi = doi->get_spi(&spi_sz,
				    GET_ISAKMP_PROP_PROTO(proto->chosen->context->p),
				    msg);
				if (spi_sz && !spi)
					goto cleanup;
				proto->spi[1] = spi;
				proto->spi_sz[1] = spi_sz;
			} else
				spi_sz = 0;

			proposal_lens[i] = ISAKMP_PROP_SPI_OFF + spi_sz;
			proposals[i] = malloc(proposal_lens[i]);
			if (!proposals[i]) {
				log_error("message_add_sa_payload: malloc "
				    "(%lu) failed",
				    (unsigned long)proposal_lens[i]);
				goto cleanup;
			}
			memcpy(transforms[i], proto->chosen->p,
			    transform_lens[i]);
			memcpy(proposals[i], proto->chosen->context->p,
			    ISAKMP_PROP_SPI_OFF);
			SET_ISAKMP_PROP_NTRANSFORMS(proposals[i], 1);
			SET_ISAKMP_PROP_SPI_SZ(proposals[i], spi_sz);
			if (spi_sz)
				memcpy(proposals[i] + ISAKMP_PROP_SPI_OFF, spi,
				    spi_sz);
			extra_sa_len += proposal_lens[i] + transform_lens[i];
		}

		/*
		 * Add the payloads.  As this is a SA, we need to recompute the
		 * lengths of the payloads containing others.  We also need to
		 * reset these payload's "next payload type" field.
		 */
		if (message_add_payload(msg, ISAKMP_PAYLOAD_SA, sa_buf,
		    sa_len, 1))
			goto cleanup;
		SET_ISAKMP_GEN_LENGTH(sa_buf, sa_len + extra_sa_len);
		sa_buf = 0;

		saved_nextp_sa = msg->nextp;
		for (proto = TAILQ_FIRST(&sa->protos), i = 0; proto;
		    proto = TAILQ_NEXT(proto, link), i++) {
			if (message_add_payload(msg, ISAKMP_PAYLOAD_PROPOSAL,
			    proposals[i], proposal_lens[i], i > 0))
				goto cleanup;
			SET_ISAKMP_GEN_LENGTH(proposals[i], proposal_lens[i] +
			    transform_lens[i]);
			proposals[i] = 0;

			saved_nextp_prop = msg->nextp;
			if (message_add_payload(msg, ISAKMP_PAYLOAD_TRANSFORM,
			    transforms[i], transform_lens[i], 0))
				goto cleanup;
			msg->nextp = saved_nextp_prop;
			transforms[i] = 0;
		}
		msg->nextp = saved_nextp_sa;

		/* Free the temporary allocations made above.  */
		free(transforms);
		free(transform_lens);
		free(proposals);
		free(proposal_lens);
	}
	return 0;

cleanup:
	free(sa_buf);
	for (i = 0; i < nprotos; i++) {
		free(transforms[i]);
		free(proposals[i]);
	}
	free(transforms);
	free(transform_lens);
	free(proposals);
	free(proposal_lens);
	return -1;
}

/*
 * Return a copy of MSG's constants starting from OFFSET and stash the size
 * in SZP.  It is the callers responsibility to free this up.
 */
u_int8_t *
message_copy(struct message *msg, size_t offset, size_t *szp)
{
	int             skip = 0;
	size_t          i, sz = 0;
	ssize_t         start = -1;
	u_int8_t       *buf, *p;

	/* Calculate size of message and where we want to start to copy.  */
	for (i = 1; i < msg->iovlen; i++) {
		sz += msg->iov[i].iov_len;
		if (sz <= offset)
			skip = i;
		else if (start < 0)
			start = offset - (sz - msg->iov[i].iov_len);
	}

	/* Allocate and copy.  */
	*szp = sz - offset;
	buf = malloc(*szp);
	if (!buf)
		return 0;
	p = buf;
	for (i = skip + 1; i < msg->iovlen; i++) {
		memcpy(p, (u_int8_t *) msg->iov[i].iov_base + start,
		    msg->iov[i].iov_len - start);
		p += msg->iov[i].iov_len - start;
		start = 0;
	}
	return buf;
}

/* Register a post-send function POST_SEND with message MSG.  */
int
message_register_post_send(struct message *msg,
    void (*post_send)(struct message *))
{
	struct post_send *node;

	node = malloc(sizeof *node);
	if (!node)
		return -1;
	node->func = post_send;
	TAILQ_INSERT_TAIL(&msg->post_send, node, link);
	return 0;
}

/* Run the post-send functions of message MSG.  */
void
message_post_send(struct message *msg)
{
	struct post_send *node;

	while ((node = TAILQ_FIRST(&msg->post_send)) != 0) {
		TAILQ_REMOVE(&msg->post_send, node, link);
		node->func(msg);
		free(node);
	}
}

struct payload *
payload_first(struct message *msg, u_int8_t payload)
{
	return TAILQ_FIRST(&msg->payload[payload]);
}
@


1.128
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.127 2014/10/09 02:38:56 deraadt Exp $	 */
d2185 1
a2185 1
					TAILQ_REMOVE(&sa->protos, proto, link);
d2245 1
a2245 2
						TAILQ_REMOVE(&sa->protos,
						    proto, link);
a2271 1
	 * XXX Do we leak struct protos and related data here?
d2274 1
a2274 1
		TAILQ_REMOVE(&sa->protos, proto, link);
@


1.127
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.126 2007/06/02 01:29:11 pvalchev Exp $	 */
d122 1
a122 1
	msg = (struct message *)calloc(1, sizeof *msg);
d143 1
a143 2
	msg->payload = (struct payload_head *)calloc(ISAKMP_PAYLOAD_MAX,
	    sizeof *msg->payload);
@


1.126
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.125 2007/04/16 13:01:39 moritz Exp $	 */
d1640 1
a1640 1
	new_iov = (struct iovec *) realloc(msg->iov, (msg->iovlen + 1) *
@


1.125
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.124 2007/04/15 19:37:46 hshoexer Exp $	 */
d1934 1
a1934 1
			p += 2;
@


1.124
log
@Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.123 2006/12/05 15:01:00 hshoexer Exp $	 */
d189 1
a189 2
			if (msg->iov[i].iov_base)
				free(msg->iov[i].iov_base);
d1447 1
a1447 2
		if (ks)
			free(ks);
d1457 1
a1457 2
		if (ks)
			free(ks);
d1467 1
a1467 2
		if (ks)
			free(ks);
d1492 1
a1492 2
		if (ks)
			free(ks);
d1908 1
a1908 2
	if (address)
		free(address);
d2438 1
a2438 2
	if (sa_buf)
		free(sa_buf);
d2440 2
a2441 4
		if (transforms[i])
			free(transforms[i]);
		if (proposals[i])
			free(proposals[i]);
d2443 4
a2446 8
	if (transforms)
		free(transforms);
	if (transform_lens)
		free(transform_lens);
	if (proposals)
		free(proposals);
	if (proposal_lens)
		free(proposal_lens);
@


1.123
log
@plug memleak, noticed by jesus@@mxtelecom.com
ok moritz@@, tested by jesus@@mxtelecom.com (thanks!)
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.122 2006/12/05 13:27:12 moritz Exp $	 */
d168 1
@


1.123.2.1
log
@Original Commit by hshoexer@@, original commit message:
===========================================================================
Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
===========================================================================
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.123 2006/12/05 15:01:00 hshoexer Exp $	 */
a167 1
	reply->flags = msg->flags;
@


1.122
log
@Don't leak message structures, when we see unsupported payloads
or if the payload node allocation fails. Also adjust a comment to
make it more clear, who's responsible for freeing the message
structs. Input from cloder@@.

OK hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.121 2006/10/29 18:42:05 pedro Exp $	 */
d923 1
a923 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_SPI, 0, 1, 0);
@


1.121
log
@Fix TAILQ usage, preventing crashes
Okay henning@@ krw@@ millert@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.120 2006/07/02 13:19:00 hshoexer Exp $	 */
d224 3
a226 2
 * to be called for each payload found.  Returns the total length of the
 * parsed payloads.
d348 2
a349 1
	message_index_payload(msg, p, payload, buf);
d368 2
a369 1
	message_index_payload(msg, p, payload, buf);
d477 1
d1174 2
a1175 1
	if (!payload_node)
d1177 1
@


1.120
log
@Let isakmpd send out a vendor ID announcing isamkpds release version.
Will be handy for release specific bug fixes, etc.  Suggested by
markus@@ quite some time ago.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.119 2006/06/02 19:35:55 hshoexer Exp $	 */
d179 1
d202 2
a203 4
	while (TAILQ_FIRST(&msg->post_send) != 0)
		TAILQ_REMOVE(&msg->post_send, TAILQ_FIRST(&msg->post_send),
		    link);

d2184 2
a2185 3
				while (TAILQ_FIRST(&sa->protos))
					TAILQ_REMOVE(&sa->protos,
					    TAILQ_FIRST(&sa->protos), link);
d2243 2
a2244 1
					while (TAILQ_FIRST(&sa->protos))
d2246 1
a2246 2
						    TAILQ_FIRST(&sa->protos),
						    link);
d2275 2
a2276 2
	while (TAILQ_FIRST(&sa->protos))
		TAILQ_REMOVE(&sa->protos, TAILQ_FIRST(&sa->protos), link);
@


1.120.2.1
log
@Original Commit by hshoexer@@, original commit message:
===========================================================================
Fix interop-issue with vpn peers that start reyking on port 4500 when
NAT-T is used.  Solves problems with cisco and openswan.

Tested by todd@@ (cisco interop), ok ho@@

Original fix with Stefan Roth (stefan dot roth at siemens dot com),
thanks!
===========================================================================
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.120 2006/07/02 13:19:00 hshoexer Exp $	 */
a167 1
	reply->flags = msg->flags;
@


1.119
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.118 2006/05/31 04:54:46 hshoexer Exp $	 */
d61 1
d1148 1
@


1.118
log
@Make sure, that phase 1 SAs of active connections stay alive.  Fixes a DPD
breakage noticed and reported by Mitja Muzenic.

ok markus@@ ho@@, testing by Mitja and cloder@@, discussed with Nathanael.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.117 2006/05/30 19:54:29 hshoexer Exp $	 */
d2057 1
a2057 1
			 * Retransmit if the previos sent message was the last
@


1.117
log
@fix SA grouping.  Now, esp+ah and ah+esp works again.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.116 2005/10/25 10:38:01 hshoexer Exp $	 */
d1722 1
a1722 1
		    0, &args, 0, 0);
@


1.116
log
@Do not send a message when no transport is available.

ok cloder ho
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.115 2005/09/23 14:44:03 hshoexer Exp $	 */
d2413 1
a2413 1
			    proposals[i], proposal_lens[i], i > 1))
@


1.115
log
@Provide UI commands to delete phase 1 SAs.

Looks good mortiz@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.114 2005/07/20 16:50:43 moritz Exp $	 */
d1733 3
@


1.114
log
@revert one TAILQ_FOREACH conversion from r1.112 which was
wrong and broke some isakmpd setups. ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.113 2005/06/26 20:49:24 hshoexer Exp $	 */
d1748 2
a1749 1
		if (proto->proto == ISAKMP_PROTO_ISAKMP) {
d1752 5
a1756 1
		} else {
d1759 5
d1765 1
@


1.113
log
@indentation/white space cleanup, no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.112 2005/05/26 06:11:09 hshoexer Exp $	 */
d2121 2
a2122 1
	TAILQ_FOREACH(tp, &msg->payload[ISAKMP_PAYLOAD_TRANSFORM], link) {
@


1.112
log
@Use TAILQ_FOREACH where possible, remove payload_last()

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.111 2005/05/26 05:14:17 hshoexer Exp $	 */
d120 1
a120 1
         */
d578 1
a578 1
         */
d1005 1
a1005 1
         */
d1028 1
a1028 1
         */
d1044 1
a1044 1
         */
d1112 1
a1112 1
         */
d1257 1
a1257 1
         *
d1260 1
a1260 1
         */
d1354 1
a1354 1
         */
d1369 1
a1369 1
         */
d1383 1
a1383 1
				  ISAKMP_HDR_MESSAGE_ID_LEN);
d1437 1
a1437 1
         */
d1449 1
a1449 1
         */
d1481 1
a1481 1
         */
d1554 1
a1554 1
         */
d1583 1
a1583 1
         */
d1663 1
a1663 1
         */
d1978 1
a1978 1
         */
d2057 1
a2057 1
         */
d2102 1
a2102 1
         *
d2118 1
a2118 1
         */
d2259 1
a2259 1
         */
d2286 1
a2286 1
         */
@


1.111
log
@get rid of payload mapping

ok markus ho cloder
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.110 2005/05/25 22:09:17 hshoexer Exp $	 */
d352 1
a352 1
	    payload_last(msg, ISAKMP_PAYLOAD_PROPOSAL),
d1214 1
a1214 1
		for (p = payload_first(msg, i); p; p = TAILQ_NEXT(p, link)) {
d2121 1
a2121 2
	for (tp = payload_first(msg, ISAKMP_PAYLOAD_TRANSFORM); tp;
	    tp = next_tp) {
a2508 6
}

struct payload *
payload_last(struct message *msg, u_int8_t payload)
{
	return TAILQ_LAST(&msg->payload[payload], payload_head);
@


1.110
log
@Fix a comment
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.109 2005/05/18 20:04:51 hshoexer Exp $	 */
d75 3
a97 41
static int (*message_validate_payload[])(struct message *, struct payload *) =
{
	message_validate_sa, message_validate_proposal,
	message_validate_transform, message_validate_key_exch,
	message_validate_id, message_validate_cert, message_validate_cert_req,
	message_validate_hash, message_validate_sig, message_validate_nonce,
	message_validate_notify, message_validate_delete,
	message_validate_vendor, message_validate_attribute,
	message_validate_nat_d, message_validate_nat_oa
};

static struct field *fields[] = {
	isakmp_sa_fld, isakmp_prop_fld, isakmp_transform_fld, isakmp_ke_fld,
	isakmp_id_fld, isakmp_cert_fld, isakmp_certreq_fld, isakmp_hash_fld,
	isakmp_sig_fld, isakmp_nonce_fld, isakmp_notify_fld, isakmp_delete_fld,
	isakmp_vendor_fld, isakmp_attribute_fld, isakmp_nat_d_fld,
	isakmp_nat_oa_fld
};

/*
 * These maps are used for indexing the payloads in msg->payloads[i].
 * payload_revmap should be updated if the payloads in isakmp_num.cst change.
 * payload_map is populated during startup by message_init().
 */
static u_int8_t payload_revmap[] = {
	ISAKMP_PAYLOAD_NONE, ISAKMP_PAYLOAD_SA, ISAKMP_PAYLOAD_PROPOSAL,
	ISAKMP_PAYLOAD_TRANSFORM, ISAKMP_PAYLOAD_KEY_EXCH, ISAKMP_PAYLOAD_ID,
	ISAKMP_PAYLOAD_CERT, ISAKMP_PAYLOAD_CERT_REQ, ISAKMP_PAYLOAD_HASH,
	ISAKMP_PAYLOAD_SIG, ISAKMP_PAYLOAD_NONCE, ISAKMP_PAYLOAD_NOTIFY,
	ISAKMP_PAYLOAD_DELETE, ISAKMP_PAYLOAD_VENDOR, ISAKMP_PAYLOAD_ATTRIBUTE,
#ifdef notyet
	ISAKMP_PAYLOAD_SAK, ISAKMP_PAYLOAD_SAT, ISAKMP_PAYLOAD_KD,
	ISAKMP_PAYLOAD_SEQ, ISAKMP_PAYLOAD_POP
#endif
	ISAKMP_PAYLOAD_NAT_D, ISAKMP_PAYLOAD_NAT_OA,
	ISAKMP_PAYLOAD_NAT_D_DRAFT, ISAKMP_PAYLOAD_NAT_OA_DRAFT
};

static u_int8_t payload_map[256];
u_int8_t payload_index_max;

d142 1
a142 1
	msg->payload = (struct payload_head *)calloc(payload_index_max,
d148 1
a148 1
	for (i = 0; i < payload_index_max; i++)
d193 1
a193 1
		for (i = 0; i < payload_index_max; i++)
d350 1
a350 1
	SET(payload_revmap[ISAKMP_PAYLOAD_TRANSFORM], &payload_set);
d377 100
d1061 1
a1061 1
	SET(payload_revmap[ISAKMP_PAYLOAD_PROPOSAL], &payload_set);
d1174 1
a1174 2
	TAILQ_INSERT_TAIL(&msg->payload[payload_map[payload]], payload_node,
	    link);
d1191 1
a1191 1
	for (i = ISAKMP_PAYLOAD_SA; i < payload_index_max; i++)
d1194 1
a1194 1
			SET(payload_revmap[i], &payload_set);
d1211 1
d1213 1
a1213 1
	for (i = ISAKMP_PAYLOAD_SA; i < payload_index_max; i++)
d1218 3
a1220 4
			field_dump_payload(fields[i - ISAKMP_PAYLOAD_SA],
			    p->p);
			if (message_validate_payload[i - ISAKMP_PAYLOAD_SA]
			    (msg, p))
d1665 1
a1665 2
	TAILQ_INSERT_TAIL(&msg->payload[payload_map[payload]], payload_node,
	    link);
a2505 16
/* Initialize and populate payload_map[].  */
void
message_init(void)
{
	u_int8_t	i;

	bzero(&payload_map, sizeof payload_map);

	payload_index_max = sizeof payload_revmap / sizeof payload_revmap[0];
	for (i = 0; i < payload_index_max; i++) {
		payload_map[payload_revmap[i]] = i;
		LOG_DBG((LOG_MESSAGE, 95, "message_init: payload_map[%d] = %d",
		    payload_revmap[i], i));
	}
}

d2509 1
a2509 4
	if (payload_map[payload])
		return TAILQ_FIRST(&msg->payload[payload_map[payload]]);
	else
		return 0;
d2515 1
a2515 5
	if (payload_map[payload])
		return TAILQ_LAST(&msg->payload[payload_map[payload]],
		    payload_head);
	else
		return 0;
@


1.109
log
@allow payload types 20 and 21 for nat-t

ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.108 2005/04/09 00:42:27 deraadt Exp $	 */
a529 5
 *
 * Note:  DELETEs are only accepted as part of an INFORMATIONAL exchange.
 * exchange_validate() makes sure a HASH payload is present.  Due to the order
 * of message validation functions in message_validate_payload[] we can be
 * sure that the HASH payload has been successfully validated at this point.
@


1.108
log
@knf
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.107 2005/04/08 23:15:26 hshoexer Exp $	 */
d129 2
a130 1
	ISAKMP_PAYLOAD_NAT_D, ISAKMP_PAYLOAD_NAT_OA
d340 2
a341 2
		    next != ISAKMP_PAYLOAD_NAT_D &&
		    next != ISAKMP_PAYLOAD_NAT_OA) {
d449 1
d452 1
@


1.107
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.106 2005/04/08 20:55:21 deraadt Exp $	 */
d367 1
a367 2
	}
	while (next != ISAKMP_PAYLOAD_NONE);
@


1.106
log
@move __inline to right place
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.105 2005/04/08 19:40:03 deraadt Exp $	 */
a40 2
#include "sysdep.h"

d1678 1
a1678 1
	isakmp_sa = sa_isakmp_lookup_by_peer(dst, sysdep_sa_len(dst));
@


1.105
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.104 2005/04/08 16:52:41 deraadt Exp $	 */
a64 6
#ifdef __GNUC__
#define INLINE __inline
#else
#define INLINE
#endif

d2017 1
a2017 1
static INLINE struct payload *
@


1.104
log
@always enable aggressive, dpd, and isakmp_cfg
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.103 2005/04/08 16:37:14 deraadt Exp $	 */
a415 1
#ifdef USE_DEBUG
a418 1
#endif
a1199 1
#ifdef USE_DEBUG
a1201 1
#endif
a1524 1
#ifdef USE_DEBUG
a1525 1
#endif
a1884 1
#if defined (USE_DEBUG)
a1905 1
#endif				/* USE_DEBUG */
@


1.103
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.102 2005/04/07 19:15:58 hshoexer Exp $	 */
a47 1
#ifdef USE_DPD
a48 1
#endif
a476 1
#ifdef USE_ISAKMP_CFG
a492 1
#endif
a1097 1
#if defined (USE_DPD)
a1098 1
#endif
a1640 1
#if defined (USE_DPD)
a1645 1
#endif
a1717 1
#if defined (USE_DPD)
a1732 1
#endif
a1748 1
#if defined (USE_DPD)
a1751 1
#endif
a1768 1
#if defined (USE_DPD)
a1772 1
#endif
@


1.102
log
@small cleanup, no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.101 2005/04/07 18:52:18 hshoexer Exp $	 */
a58 1
#if defined (USE_NAT_TRAVERSAL)
a59 1
#endif
a459 1
#if defined (USE_NAT_TRAVERSAL)
a463 1
#endif
a1104 1
#if defined (USE_NAT_TRAVERSAL)
a1105 1
#endif
a1199 1
#if defined (USE_NAT_TRAVERSAL)
a1200 1
#endif
a1425 1
#if defined (USE_NAT_TRAVERSAL)
d1437 1
a1437 1
#endif
a1912 1
#if defined (USE_NAT_TRAVERSAL)
a1914 1
#endif
@


1.101
log
@Plug memleak.

ok cloder ho markus
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.100 2005/04/06 16:00:20 deraadt Exp $	 */
d242 1
a242 1
		for (i = 0; i < payload_index_max; i++) {
a246 1
		}
@


1.100
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.99 2005/04/04 19:31:11 deraadt Exp $	 */
d226 1
a226 1
	struct payload *payload, *next;
d242 3
a244 4
		for (i = 0; i < payload_index_max; i++)
			for (payload = payload_first(msg, i); payload;
			    payload = next) {
				next = TAILQ_NEXT(payload, link);
d247 1
@


1.99
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.98 2005/03/05 12:35:03 ho Exp $	 */
d740 4
a743 4
	if (exchange->doi
	    && exchange->doi->validate_id_information(GET_ISAKMP_ID_TYPE(p->p),
	    p->p + ISAKMP_ID_DOI_DATA_OFF, p->p + ISAKMP_ID_DATA_OFF, len -
	    ISAKMP_ID_DATA_OFF, exchange)) {
d883 9
a891 9
	if (type < ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE
	    || (type >= ISAKMP_NOTIFY_RESERVED_MIN
		&& type < ISAKMP_NOTIFY_PRIVATE_MIN)
	    || (type >= ISAKMP_NOTIFY_STATUS_RESERVED1_MIN
		&& type <= ISAKMP_NOTIFY_STATUS_RESERVED1_MAX)
	    || (type >= ISAKMP_NOTIFY_STATUS_DOI_MIN
		&& type <= ISAKMP_NOTIFY_STATUS_DOI_MAX
		&& doi->validate_notification(type))
	    || type >= ISAKMP_NOTIFY_STATUS_RESERVED2_MIN) {
d915 2
a916 2
	if (proto != ISAKMP_PROTO_ISAKMP
	    && msg->exchange->doi->validate_proto(proto)) {
d1238 2
a1239 2
		if (exchange_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF)
		    || sa_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF)) {
d1262 2
a1263 2
			if (msg->exchange && msg->exchange->phase == 1
			    && zero_test(msg->exchange->cookies +
d1325 4
a1328 4
	if (exch_type == ISAKMP_EXCH_NONE
	    || (exch_type >= ISAKMP_EXCH_FUTURE_MIN &&
		exch_type <= ISAKMP_EXCH_FUTURE_MAX)
	    || (setup_isakmp_sa && exch_type >= ISAKMP_EXCH_DOI_MIN)) {
d1407 2
a1408 2
	if (GET_ISAKMP_HDR_NEXT_PAYLOAD(buf) != ISAKMP_PAYLOAD_NONE
	    && message_sort_payloads(msg, GET_ISAKMP_HDR_NEXT_PAYLOAD(buf))) {
d1452 2
a1453 5
	if (exch_type >= ISAKMP_EXCH_DOI_MIN
#if 0 /* always true; silence GCC3 warning */
	    && exch_type <= ISAKMP_EXCH_DOI_MAX
#endif
	    && msg->exchange->doi->validate_exchange(exch_type)) {
d1473 2
a1474 2
	if ((msg->exchange->flags & EXCHANGE_FLAG_COMMITTED) == 0
	    && (flags & ISAKMP_FLAGS_COMMIT))
d1525 2
a1526 2
	if ((msg->flags & MSG_ENCRYPTED) == 0
	    && exchange->flags & EXCHANGE_FLAG_ENCRYPT) {
d2022 2
a2023 2
		if (sz == exchange->last_received->orig_sz
		    && memcmp(pkt, exchange->last_received->orig, sz) == 0) {
d2141 3
a2143 3
		if (next_tp && propp != next_propp && sap == next_sap
		    && (GET_ISAKMP_PROP_NO(propp->p)
		    == GET_ISAKMP_PROP_NO(next_propp->p))) {
d2163 4
a2166 4
					&next_propp, &next_sap))
				    && (GET_ISAKMP_PROP_NO(next_propp->p)
					== GET_ISAKMP_PROP_NO(propp->p))
				    && next_sap == sap)
d2175 4
a2178 4
		if (!next_tp
		    || (propp != next_propp && (GET_ISAKMP_PROP_NO(propp->p)
			!= GET_ISAKMP_PROP_NO(next_propp->p)))
		    || sap != next_sap) {
d2196 2
a2197 2
						&next_propp, &next_sap))
					    && next_sap == sap)
@


1.98
log
@No need to allocate a local digest buffer. Cleanup error path. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.97 2005/03/05 12:25:12 ho Exp $	 */
d244 1
a244 1
			     payload = next) {
d324 1
a324 1
	         */
d363 1
a363 1
	         */
d683 1
a683 1
		
d873 1
a873 1
	if (proto == ISAKMP_PROTO_ISAKMP && 
d1237 1
a1237 1
	         */
d1243 1
a1243 1
		         */
d1258 1
a1258 1
	         */
d1362 1
a1362 1
	         */
d1718 1
a1718 1
	         */
d1785 1
a1785 1
	
d2034 1
a2034 1
		         */
d2143 1
a2143 1
	         */
d2185 1
a2185 1
		         */
d2233 1
a2233 1
			         */
d2376 1
a2376 1
	         */
@


1.97
log
@Silence a couple of annoying gcc3 warnings. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.96 2005/02/27 13:12:12 hshoexer Exp $	 */
a654 2
 * XXX Currently hash payloads are processed by the particular exchanges,
 * except INFORMATIONAL.  This should be actually done here.
d664 1
a664 1
	u_int8_t       *comp_hash, *rest;
d672 3
a674 6
	if (isakmp_sa == NULL) {
		log_print("message_validate_hash: invalid hash information");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION,
		    0, 1, 1);
		return -1;
	}
d677 2
a679 6
	if (hash == NULL) {
		log_print("message_validate_hash: invalid hash information");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION,
		    0, 1, 1);
		return -1;
	}
d681 3
a683 6
	if (!isa->skeyid_a) {
		log_print("message_validate_hash: invalid hash information");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION,
		    0, 1, 1);
		return -1;
	}
a692 8
	comp_hash = (u_int8_t *)malloc(hash->hashsize);
	if (!comp_hash) {
		log_error("message_validate_hash: malloc (%lu) failed",
		    (unsigned long)hash->hashsize);
		prf_free(prf);
		message_free(msg);
		return -1;
	}
d706 1
a706 1
	prf->Final(comp_hash, prf->prfctx);
d709 3
a711 11
	if (memcmp(hashp->p + ISAKMP_HASH_DATA_OFF, comp_hash,
	    hash->hashsize)) {
		log_print("message_validate_hash: invalid hash value for %s "
		    "payload", payload_first(msg, ISAKMP_PAYLOAD_DELETE) ?
		    "DELETE" : "NOTIFY");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION,
		    0, 1, 1);
		free(comp_hash);
		return -1;
	}
	free(comp_hash);
d720 5
@


1.96
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.95 2005/02/24 00:30:41 cloder Exp $	 */
d1476 1
d1478 1
@


1.95
log
@Never respond to 0-length UDP packets.  Reduces, but does not eliminate
probability that isakmp service will be detected during port scans.
OK hoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.94 2005/02/22 21:42:14 hshoexer Exp $	 */
d2521 1
a2521 1
	memset(&payload_map, 0, sizeof payload_map);
@


1.94
log
@build delete messages for isakmp sa correctly.

ok and help ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.93 2005/01/29 16:59:45 hshoexer Exp $	 */
d1237 1
a1237 2
		message_drop(msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS,
		    0, 1, 1);
@


1.93
log
@Handle some pointers more carefully.  From pat@@ some while ago.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.92 2004/12/14 19:03:16 ho Exp $	 */
d1748 7
a1755 2
		args.spi_sz = proto->spi_sz[1];
		args.u.d.spis = proto->spi[1];
@


1.92
log
@Reword comment a bit for clarity. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.91 2004/12/10 09:00:48 markus Exp $	 */
a230 2
	if (msg->orig && msg->orig != (u_int8_t *) msg->iov[0].iov_base)
		free(msg->orig);
d232 2
d254 5
a258 3
	/* If we are on the send queue, remove us from there.  */
	if (msg->flags & MSG_IN_TRANSIT)
		TAILQ_REMOVE(msg->transport->vtbl->get_queue(msg), msg, link);
a259 1
	if (msg->transport)
d261 1
@


1.91
log
@check msg->isakmp_sa != NULL before the transport gets updated; ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.90 2004/12/08 16:05:37 markus Exp $	 */
d1459 3
a1461 2
	 * Update the isakmp transport, but only in phase 1,
	 * since phase 2 SAs might use this transport
@


1.90
log
@NAT/T: replace the isakmpd SA transport with the transport from the
message (only during phase 1). this avoids DPD messages to the
'wrong' port. ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.89 2004/09/17 13:45:02 ho Exp $	 */
d1462 1
a1462 1
	if (msg->exchange->phase == 1) {
@


1.89
log
@Permit next payload type NAT-OA. Noted by Kamel Messaoudi.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.88 2004/08/17 14:48:23 hshoexer Exp $	 */
d1228 3
d1457 12
@


1.88
log
@check for msg->isakmpg_sa being NULL before referencing
ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.87 2004/08/10 15:59:10 ho Exp $	 */
d350 2
a351 1
		    next != ISAKMP_PAYLOAD_NAT_D) {
@


1.87
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.86 2004/08/08 19:11:06 deraadt Exp $	 */
d895 1
@


1.86
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.85 2004/07/07 09:16:20 hshoexer Exp $	 */
d891 10
a900 1
	/* XXX Validate the SPI.  */
d916 1
d1534 2
d1662 7
d1736 18
d1759 1
a1759 1
	size_t          sz;
d1768 15
a1782 2
	sz = (args->discr == 'N' ? ISAKMP_NOTIFY_SPI_OFF + args->spi_sz
	    : ISAKMP_DELETE_SPI_OFF + args->u.d.nspis * args->spi_sz);
d1791 6
@


1.85
log
@plug memleak when receiving an INVALID_HASH_INFORMATION notify.
Found by Patrick Latifi, thanks!

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.84 2004/06/21 16:01:56 ho Exp $	 */
d138 1
a138 1
	ISAKMP_PAYLOAD_SAK, ISAKMP_PAYLOAD_SAT, ISAKMP_PAYLOAD_KD, 
d1118 1
a1118 1
#endif	
d2464 1
a2464 1
		return TAILQ_LAST(&msg->payload[payload_map[payload]], 
@


1.84
log
@Packet capture should add the ESP-marker when NAT-T is active.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.83 2004/06/20 17:44:06 ho Exp $	 */
d732 1
a732 1
		    0, 1, 0);
@


1.83
log
@message_parse_payloads should accept payloads in the private range.
While here, also cleanup some messages.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.82 2004/06/20 17:17:35 ho Exp $	 */
d67 1
d1859 1
a1859 1
#ifdef USE_DEBUG
d1861 1
d1867 5
d1875 2
a1876 2
		msg->transport->vtbl->get_src(msg->transport, &src);
		msg->transport->vtbl->get_dst(msg->transport, &dst);
d1878 2
a1879 2
		msg->transport->vtbl->get_src(msg->transport, &dst);
		msg->transport->vtbl->get_dst(msg->transport, &src);
@


1.82
log
@Make the payload array in struct message dynamic, since we need to handle
payloads in the private range, such as the pre-RFC NAT-D/NAT-OA.
Replace TAILQ_FIRST(&msg->payload[i]) instances with function calls.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.81 2004/06/20 15:24:05 ho Exp $	 */
d305 2
a306 2
			    "payload type %d in payload of type %d", next,
			    payload);
d326 2
a327 1
			    "payload size for payload type %u", payload);
d347 3
a349 2
		/* Ignore private payloads.  */
		if (next >= ISAKMP_PAYLOAD_PRIVATE_MIN) {
d351 3
a353 2
			    "private next payload type %d in payload of "
			    "type %d ignored", next, payload));
d361 3
a363 2
			log_print("message_parse_payloads: payload type %d "
			    "unexpected", payload);
d397 1
a397 1
	SET(ISAKMP_PAYLOAD_TRANSFORM, &payload_set);
d1029 1
a1029 1
	SET(ISAKMP_PAYLOAD_PROPOSAL, &payload_set);
d1167 1
a1167 1
			SET(i, &payload_set);
@


1.81
log
@NAT-Traversal for isakmpd. Work in progress...
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.80 2004/06/20 15:11:29 ho Exp $	 */
d126 21
d190 7
a196 1
	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
d240 9
a248 6
	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
		for (payload = TAILQ_FIRST(&msg->payload[i]); payload;
		    payload = next) {
			next = TAILQ_NEXT(payload, link);
			free(payload);
		}
d257 2
a258 1
	transport_release(msg->transport);
d395 1
a395 1
	    TAILQ_LAST(&msg->payload[ISAKMP_PAYLOAD_PROPOSAL], payload_head),
d455 6
a466 2
	case ISAKMP_PAYLOAD_NAT_D:
	case ISAKMP_PAYLOAD_NAT_OA:
d559 2
a560 1
		log_print("message_validate_delete: got unauthenticated DELETE");
d656 1
a656 2
	struct payload *hashp =
	    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
d723 2
a724 3
		log_print("message_validate_hash: invalid hash value for "
		    "%s payload",
		    TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_DELETE]) ?
d1142 2
a1143 1
	TAILQ_INSERT_TAIL(&msg->payload[payload], payload_node, link);
d1160 1
a1160 1
	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
d1181 2
a1182 3
	for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
		for (p = TAILQ_FIRST(&msg->payload[i]); p;
		    p = TAILQ_NEXT(p, link)) {
d1625 2
a1626 1
	TAILQ_INSERT_TAIL(&msg->payload[payload], payload_node, link);
d2039 1
a2039 1
	for (tp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]); tp;
d2422 35
@


1.80
log
@Some vendors send the last Aggressive Mode message unencrypted, which we
should accept. Problem noted by alex at vbone.net. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.79 2004/06/14 10:04:22 hshoexer Exp $	 */
d7 1
a7 1
 * Copyright (c) 1999, 2000, 2001 Håkan Olsson.  All rights reserved.
d48 3
d59 3
d94 2
d113 2
a114 1
	message_validate_vendor, message_validate_attribute
d121 2
a122 1
	isakmp_vendor_fld, isakmp_attribute_fld
d224 3
a226 6
	if (msg->flags & MSG_IN_TRANSIT) {
		if (msg->flags & MSG_PRIORITIZED)
			TAILQ_REMOVE(&msg->transport->prio_sendq, msg, link);
		else
			TAILQ_REMOVE(&msg->transport->sendq, msg, link);
	}
d488 2
a489 2
	 * Check the certificate types we support and if an acceptable authority
	 * is included in the payload check if it can be decoded
d755 47
d1077 9
a1085 1
	LOG_DBG((LOG_MESSAGE, 40, "message_validate_vendor: vendor ID seen"));
d1199 1
a1199 1
				    ISAKMP_HDR_RCOOKIE_LEN);
d1510 1
a1510 3
	q = msg->flags & MSG_PRIORITIZED ? &msg->transport->prio_sendq :
		&msg->transport->sendq;

d1943 3
a1945 6
			if (exchange->in_transit->flags & MSG_PRIORITIZED)
				TAILQ_REMOVE(&exchange->in_transit->transport->prio_sendq,
				    exchange->in_transit, link);
			else
				TAILQ_REMOVE(&exchange->in_transit->transport->sendq,
				    exchange->in_transit, link);
@


1.79
log
@added a missing message_free().

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.78 2004/06/14 09:55:41 ho Exp $	 */
d1371 4
a1374 1
	/* Require encryption as soon as we have the keystate for it.  */
d1376 3
a1378 1
	    (msg->exchange->phase == 2 || msg->exchange->keystate)) {
d1384 1
@


1.78
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.77 2004/06/11 10:17:58 brad Exp $	 */
d518 1
@


1.77
log
@typo in comment
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.76 2004/06/10 12:54:53 hshoexer Exp $	 */
d255 2
a256 2
			message_drop(msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS,
			    0, 1, 1);
d310 3
a312 3
			LOG_DBG((LOG_MESSAGE, 30,
			    "message_parse_payloads: private next payload type "
			    "%d in payload of type %d ignored", next, payload));
d346 2
a347 2
message_parse_proposal(struct message *msg, struct payload *p, u_int8_t payload,
    u_int8_t *buf)
d439 2
a440 1
			msg->exchange = exchange_setup_p1(msg, IPSEC_DOI_IPSEC);
d442 2
a443 1
			msg->exchange = exchange_setup_p2(msg, IPSEC_DOI_IPSEC);
d460 2
a461 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 1, 1);
d472 2
a473 1
	size_t	len = GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_CERTREQ_AUTHORITY_OFF;
d476 2
a477 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 1, 1);
d487 2
a488 1
		message_drop(msg, ISAKMP_NOTIFY_CERT_TYPE_UNSUPPORTED, 0, 1, 1);
d612 2
a613 1
	struct payload *hashp = TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_HASH]);
d678 2
a679 1
	if (memcmp(hashp->p + ISAKMP_HASH_DATA_OFF, comp_hash, hash->hashsize)) {
d717 2
a718 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1, 1);
d733 2
a734 1
		log_print("message_validate_key_exch: payload out of sequence");
d808 2
a809 1
		log_print("message_validate_notify: message type not supported");
d825 2
a826 1
		log_print("message_validate_proposal: payload out of sequence");
d901 2
a902 2
	 * Create a struct sa for each SA payload handed to us unless we are the
	 * initiator where we only will count them.
d917 2
a918 2
	 * Let the DOI validate the situation, at the same time it tells us what
	 * the length of the situation field is.
d968 2
a969 1
		log_print("message_validate_transform: payload out of sequence");
d1089 2
a1090 1
			field_dump_payload(fields[i - ISAKMP_PAYLOAD_SA], p->p);
d1182 2
a1183 1
				tmp_proto.spi[1] = buf + ISAKMP_HDR_COOKIES_OFF;
d1212 2
a1213 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_MAJOR_VERSION, 0, 1, 1);
d1219 2
a1220 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_MINOR_VERSION, 0, 1, 1);
d1236 2
a1237 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 1, 1);
d1344 2
a1345 1
	if (exch_type >= ISAKMP_EXCH_DOI_MIN && exch_type <= ISAKMP_EXCH_DOI_MAX
d1349 2
a1350 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 1, 1);
d1641 2
a1642 1
		memcpy(buf + ISAKMP_NOTIFY_SPI_OFF, args->u.n.spi, args->spi_sz);
d1680 2
a1681 2
message_drop(struct message *msg, int notify, struct proto *proto, int incoming,
    int clean)
d1705 2
a1706 2
	log_print("dropped message from %s port %d due to notification type %s",
	    address ? address : "<unknown>", htons(port),
d1760 2
a1761 1
	if (msg->exchange && msg->exchange->initiator ^ (msg->exchange->step % 2)) {
d1892 2
a1893 1
step_transform(struct payload *tp, struct payload **propp, struct payload **sap)
d1965 1
a1965 1
			/* Skip to last transform of this protocol proposal.  */
d2114 2
a2115 2
			log_error("message_add_sa_payload: malloc (%lu) failed",
			    (unsigned long)sa_len);
@


1.76
log
@Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!

ok ho@@ niklas@@, testing and spellcheck by todd@@ msf@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.75 2004/06/09 14:02:44 ho Exp $	 */
d509 1
a509 1
	/* Only accpet authenticated DELETEs. */
@


1.75
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.74 2004/06/09 12:59:36 hshoexer Exp $	 */
d509 6
d612 2
a613 1
	if (msg->exchange)	/* active exchange validates hash payload. */
d685 3
@


1.74
log
@only accept DELETEs during an authenticated INFORMATIONAL exchange.
Fix for recent problem disclosed by Thomas Walpuski.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.73 2004/05/23 18:17:56 hshoexer Exp $	 */
d466 1
a466 1
message_validate_cert_req(struct message * msg, struct payload * p)
d1529 1
a1529 1
    u_int16_t notify, struct proto * proto, int incoming)
@


1.73
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.72 2004/04/29 22:36:26 hshoexer Exp $	 */
d491 5
d528 8
@


1.72
log
@Better checking of minimum payload lengths.  Drop out safely when an unknown
payload type is encountered.  While around, do some KNF.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.71 2004/04/15 18:39:26 deraadt Exp $	 */
d98 1
a98 1
static int      (*message_validate_payload[]) (struct message *, struct payload *) =
d100 5
a104 4
	message_validate_sa, message_validate_proposal, message_validate_transform,
	message_validate_key_exch, message_validate_id, message_validate_cert,
	message_validate_cert_req, message_validate_hash, message_validate_sig,
	message_validate_nonce, message_validate_notify, message_validate_delete,
d129 1
a129 1
message_alloc(struct transport * t, u_int8_t * buf, size_t sz)
d138 1
a138 1
	msg = (struct message *) calloc(1, sizeof *msg);
d155 2
a156 1
	msg->nextp = (u_int8_t *) msg->iov[0].iov_base + ISAKMP_HDR_NEXT_PAYLOAD_OFF;
d171 1
a171 1
message_alloc_reply(struct message * msg)
d185 1
a185 1
message_free(struct message * msg)
d204 2
a205 1
		for (payload = TAILQ_FIRST(&msg->payload[i]); payload; payload = next) {
d210 2
a211 1
		TAILQ_REMOVE(&msg->post_send, TAILQ_FIRST(&msg->post_send), link);
d237 3
a239 4
message_parse_payloads(struct message * msg, struct payload * p, u_int8_t next,
		       u_int8_t * buf, set * accepted_payloads,
		       int (*func) (struct message *, struct payload *,
				    u_int8_t, u_int8_t *))
d248 1
a248 1
			 (long) (buf - (u_int8_t *) msg->iov[0].iov_base),
d252 2
a253 2
		if (buf + ISAKMP_GEN_SZ
		> (u_int8_t *) msg->iov[0].iov_base + msg->iov[0].iov_len) {
d255 2
a256 1
			message_drop(msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 1, 1);
d266 5
a270 3
			log_print("message_parse_payloads: invalid next payload type %d "
				  "in payload of type %d", next, payload);
			message_drop(msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
d275 4
a278 3
			log_print("message_parse_payloads: reserved field non-zero: %x",
				  GET_ISAKMP_GEN_RESERVED(buf));
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
d289 2
a290 1
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
d294 4
a297 2
			log_print("message_parse_payloads: payload too short: %u", len);
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
d300 6
a305 3
		if (buf + len > (u_int8_t *) msg->iov[0].iov_base + msg->iov[0].iov_len) {
			log_print("message_parse_payloads: payload too long: %u", len);
			message_drop(msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
d320 4
a323 3
			log_print("message_parse_payloads: payload type %d unexpected",
				  payload);
			message_drop(msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
d346 2
a347 2
message_parse_proposal(struct message * msg, struct payload * p,
		       u_int8_t payload, u_int8_t * buf)
d349 1
a349 1
	set             payload_set;
d357 4
a360 7
				   TAILQ_LAST(&msg->payload
					      [ISAKMP_PAYLOAD_PROPOSAL],
					      payload_head),
				   ISAKMP_PAYLOAD_TRANSFORM,
				   buf + ISAKMP_PROP_SPI_OFF
				   + GET_ISAKMP_PROP_SPI_SZ(buf),
			       &payload_set, message_parse_transform) == -1)
d367 2
a368 2
message_parse_transform(struct message * msg, struct payload * p,
			u_int8_t payload, u_int8_t * buf)
d374 1
a374 1
		 GET_ISAKMP_TRANSFORM_NO(buf)));
d377 2
a378 2
		 GET_ISAKMP_GEN_LENGTH(buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		      msg->exchange->doi->debug_attribute, msg);
d432 1
a432 1
message_validate_attribute(struct message * msg, struct payload * p)
d437 2
a438 2
		if (zero_test((u_int8_t *) msg->iov[0].iov_base
		    + ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
d443 2
a444 1
			log_print("message_validate_attribute: can not create exchange");
d455 1
a455 1
message_validate_cert(struct message * msg, struct payload * p)
d469 1
a469 1
	size_t          len = GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_CERTREQ_AUTHORITY_OFF;
d480 2
a481 3
	if (!cert
	    || (len && !cert->certreq_validate(p->p + ISAKMP_CERTREQ_AUTHORITY_OFF,
					       len))) {
d493 1
a493 1
message_validate_delete(struct message * msg, struct payload * p)
d500 1
a500 1
	u_int8_t       *spis = (u_int8_t *) p->p + ISAKMP_DELETE_SPI_OFF;
d518 2
a519 1
			log_print("message_validate_delete: can not create exchange");
d535 2
a536 2
			log_print("message_validate_delete: invalid spi "
				  "(no valid ISAKMP SA found)");
d540 2
a541 1
		isakmp_sa->transport->vtbl->get_dst(isakmp_sa->transport, &dst_isa);
d546 2
a547 1
			sa = sa_lookup_isakmp_sa(dst, spis + i * ISAKMP_HDR_COOKIES_LEN);
d549 2
a550 1
			sa = ipsec_sa_lookup(dst, ((u_int32_t *) spis)[i], proto);
d552 2
a553 2
			LOG_DBG((LOG_MESSAGE, 50, "message_validate_delete: invalid spi "
				 "(no valid SA found)"));
d561 2
a562 2
		  memcmp(sockaddr_addrdata(dst_isa), sockaddr_addrdata(dst),
			 sockaddr_addrlen(dst))) {
d566 1
a566 1
				  "(illegal delete request from %s)", addr);
d582 1
a582 1
message_validate_hash(struct message * msg, struct payload * p)
d598 2
a599 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
d607 2
a608 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
d614 2
a615 1
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
d619 4
a622 3
	LOG_DBG_BUF((LOG_MISC, 90, "message_validate_hash: SKEYID_a", isa->skeyid_a,
		     isa->skeyid_len));
	prf = prf_alloc(isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
d627 1
a627 1
	comp_hash = (u_int8_t *) malloc(hash->hashsize);
d630 1
a630 1
			  (unsigned long) hash->hashsize);
d640 1
a640 1
		     message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
d643 4
a646 4
	rest_len = (GET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base)
		    - (rest - (u_int8_t *) msg->iov[0].iov_base));
	LOG_DBG_BUF((LOG_MISC, 90, "message_validate_hash: payloads after HASH(1)",
		     rest, rest_len));
d652 6
a657 4
		log_print("message_validate_hash: invalid hash value for %s payload",
			  TAILQ_FIRST(&msg->payload[ISAKMP_PAYLOAD_DELETE])
			  ? "DELETE" : "NOTIFY");
		message_drop(msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
d671 1
a671 1
message_validate_id(struct message * msg, struct payload * p)
d683 3
a685 5
	 && exchange->doi->validate_id_information(GET_ISAKMP_ID_TYPE(p->p),
					      p->p + ISAKMP_ID_DOI_DATA_OFF,
						   p->p + ISAKMP_ID_DATA_OFF,
						   len - ISAKMP_ID_DATA_OFF,
						   exchange)) {
d694 1
a694 1
message_validate_key_exch(struct message * msg, struct payload * p)
d705 4
a708 4
	if (exchange->doi
	&& exchange->doi->validate_key_information(p->p + ISAKMP_KE_DATA_OFF,
						len - ISAKMP_KE_DATA_OFF)) {
		message_drop(msg, ISAKMP_NOTIFY_INVALID_KEY_INFORMATION, 0, 1, 1);
d716 1
a716 1
message_validate_nonce(struct message * msg, struct payload * p)
d733 1
a733 1
message_validate_notify(struct message * msg, struct payload * p)
d747 2
a748 2
		if (zero_test((u_int8_t *) msg->iov[0].iov_base
		    + ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
d753 2
a754 1
			log_print("message_validate_notify: can not create exchange");
d784 1
a784 1
message_validate_proposal(struct message * msg, struct payload * p)
d826 1
a826 1
message_validate_sa(struct message * msg, struct payload * p)
d842 3
a844 3
	 * already set, then we are creating a new phase 1 SA.  Otherwise, lookup
	 * the SA using the cookies and the message ID.  If we cannot find
	 * it, and the phase 1 SA is ready, setup a phase 2 SA.
d847 2
a848 1
		if (zero_test(pkt + ISAKMP_HDR_RCOOKIE_OFF, ISAKMP_HDR_RCOOKIE_LEN))
d886 1
a886 1
			 GET_ISAKMP_GEN_LENGTH(p->p) - ISAKMP_SA_SIT_OFF)) {
d888 2
a889 1
		message_drop(msg, ISAKMP_NOTIFY_SITUATION_NOT_SUPPORTED, 0, 1, 1);
d903 2
a904 2
			       p->p + ISAKMP_SA_SIT_OFF + len, &payload_set,
				   message_parse_proposal) == -1)
d912 1
a912 1
message_validate_sig(struct message * msg, struct payload * p)
d926 1
a926 1
message_validate_transform(struct message * msg, struct payload * p)
d944 1
a944 1
		       ISAKMP_TRANSFORM_RESERVED_LEN)) {
d949 2
a950 1
	 * Check that we get monotonically increasing transform numbers per proposal.
d962 4
a965 4
			  GET_ISAKMP_GEN_LENGTH(p->p)
			  - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			  msg->exchange->doi->validate_attribute, msg)) {
		message_drop(msg, ISAKMP_NOTIFY_ATTRIBUTES_NOT_SUPPORTED, 0, 1, 1);
d973 1
a973 1
message_validate_vendor(struct message * msg, struct payload * p)
d997 2
a998 2
message_index_payload(struct message * msg, struct payload * p,
		      u_int8_t payload, u_int8_t * buf)
d1020 1
a1020 1
message_sort_payloads(struct message * msg, u_int8_t next)
d1022 2
a1023 2
	set             payload_set;
	int             i, sz;
d1027 2
a1028 1
		if (i != ISAKMP_PAYLOAD_PROPOSAL && i != ISAKMP_PAYLOAD_TRANSFORM)
d1030 3
a1032 4
	sz =
		message_parse_payloads(msg, 0, next,
			  (u_int8_t *) msg->iov[0].iov_base + ISAKMP_HDR_SZ,
				       &payload_set, message_index_payload);
d1042 1
a1042 1
message_validate_payloads(struct message * msg)
d1048 5
a1052 5
		for (p = TAILQ_FIRST(&msg->payload[i]); p; p = TAILQ_NEXT(p, link)) {
			LOG_DBG((LOG_MESSAGE, 60,
				 "message_validate_payloads: "
				 "payload %s at %p of message %p",
			  constant_name(isakmp_payload_cst, i), p->p, msg));
d1054 2
a1055 1
			if (message_validate_payload[i - ISAKMP_PAYLOAD_SA] (msg, p))
d1067 1
a1067 1
message_recv(struct message * msg)
d1081 2
a1082 1
		message_drop(msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 1, 1);
d1091 3
a1093 2
	 * If the responder cookie is zero, this is a request to setup an ISAKMP SA.
	 * Otherwise the cookies should refer to an existing ISAKMP SA.
d1095 2
a1096 2
	 * XXX This is getting ugly, please reread later to see if it can be made
	 * nicer.
d1102 2
a1103 2
		 * This might be a retransmission of a former ISAKMP SA setup message.
		 * If so, just drop it.
d1107 1
a1107 1
		  || sa_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF)) {
d1109 2
a1110 2
			 * XXX Later we should differentiate between retransmissions and
			 * potential replay attacks.
d1113 1
a1113 1
			   "message_recv: dropping setup for existing SA"));
d1123 3
a1125 3
		 * If we cannot find an ISAKMP SA out of the cookies, this is either
		 * a responder's first reply, and we need to upgrade our exchange,
		 * or it's just plain invalid cookies.
d1128 2
a1129 2
			msg->exchange
				= exchange_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF);
d1131 2
a1132 2
			    && zero_test(msg->exchange->cookies + ISAKMP_HDR_RCOOKIE_OFF,
					 ISAKMP_HDR_RCOOKIE_LEN))
d1135 2
a1136 1
				log_print("message_recv: invalid cookie(s) %08x%08x %08x%08x",
d1146 2
a1147 2
				message_drop(msg, ISAKMP_NOTIFY_INVALID_COOKIE, &tmp_proto, 1,
					     1);
d1151 2
a1152 2
			msg->isakmp_sa
				= sa_lookup_from_icookie(buf + ISAKMP_HDR_ICOOKIE_OFF);
d1164 3
a1166 4
		log_print("message_recv: "
			  "invalid payload type %d in ISAKMP header "
			"(check passphrases, if applicable and in Phase 1)",
			  GET_ISAKMP_HDR_NEXT_PAYLOAD(buf));
d1173 1
a1173 1
			  ISAKMP_VERSION_MAJOR(GET_ISAKMP_HDR_VERSION(buf)));
d1179 1
a1179 1
			  ISAKMP_VERSION_MINOR(GET_ISAKMP_HDR_VERSION(buf)));
d1184 4
a1187 3
	 * Validate the exchange type.  If it's a DOI-specified exchange wait until
	 * after all payloads have been seen for the validation as the SA payload
	 * might not yet have been parsed, thus the DOI might be unknown.
d1195 1
a1195 1
			  constant_name(isakmp_exch_cst, exch_type));
d1204 2
a1205 2
	if (flags
	    & ~(ISAKMP_FLAGS_ENC | ISAKMP_FLAGS_COMMIT | ISAKMP_FLAGS_AUTH_ONLY)) {
d1207 1
a1207 1
			  GET_ISAKMP_HDR_FLAGS(buf));
d1229 2
a1230 1
			log_print("message_recv: phase 1 message after ISAKMP SA is ready");
d1234 2
a1235 2
			LOG_DBG((LOG_MESSAGE, 80,
				 "message_recv: resending last message from phase 1"));
d1241 2
a1242 2
			LOG_DBG((LOG_MISC, 10,
			"message_recv: no isakmp_sa for encrypted message"));
d1268 2
a1269 2
	 * Check the overall payload structure at the same time as indexing them by
	 * type.
d1272 1
a1272 1
	  && message_sort_payloads(msg, GET_ISAKMP_HDR_NEXT_PAYLOAD(buf))) {
d1305 2
a1306 1
		log_print("message_recv: invalid DOI exchange type %d", exch_type);
d1331 1
a1331 1
			  msg->exchange->phase);
d1342 1
a1342 1
message_send_expire(struct message * msg)
d1351 1
a1351 1
message_send(struct message * msg)
d1384 2
a1385 2
				  GET_ISAKMP_HDR_FLAGS(msg->iov[0].iov_base)
				     | ISAKMP_FLAGS_COMMIT);
d1404 1
a1404 1
			 "message_send: msg %p already on sendq %p", m, q));
d1416 2
a1417 2
message_setup_header(struct message * msg, u_int8_t exchange, u_int8_t flags,
		     u_int8_t * msg_id)
d1419 1
a1419 1
	u_int8_t       *buf = msg->iov[0].iov_base;
d1422 2
a1423 2
	SET_ISAKMP_HDR_RCOOKIE(buf,
			   msg->exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN);
d1441 2
a1442 2
message_add_payload(struct message * msg, u_int8_t payload, u_int8_t * buf,
		    size_t sz, int link)
d1450 1
a1450 1
			  (unsigned long) sizeof *payload_node);
d1453 2
a1454 2
	new_iov
		= (struct iovec *) realloc(msg->iov, (msg->iovlen + 1) * sizeof *msg->iov);
d1456 3
a1458 2
		log_error("message_add_payload: realloc (%p, %lu) failed", msg->iov,
		      (msg->iovlen + 1) * (unsigned long) sizeof *msg->iov);
d1473 1
a1473 1
			  GET_ISAKMP_HDR_LENGTH(msg->iov[0].iov_base) + sz);
d1476 3
a1478 2
	 * For the sake of exchange_validate we index the payloads even in outgoing
	 * messages, however context and flags are uninteresting in this situation.
d1495 1
a1495 1
		}               n;
d1499 2
a1500 2
		}               d;
	}               u;
d1515 2
a1516 3
message_send_notification(struct message * msg, struct sa * isakmp_sa,
			  u_int16_t notify, struct proto * proto,
			  int incoming)
d1528 2
a1529 1
		exchange_establish_p2(isakmp_sa, ISAKMP_EXCH_INFO, 0, &args, 0, 0);
d1532 2
a1533 3
				      msg->exchange
			       ? msg->exchange->doi->id : ISAKMP_DOI_ISAKMP,
				      0, &args, 0, 0);
d1538 1
a1538 1
message_send_delete(struct sa * sa)
d1549 2
a1550 2
		 * XXX We ought to setup an ISAKMP SA with our peer here and send
		 * the DELETE over that one.
d1558 1
a1558 1
	     proto = TAILQ_NEXT(proto, link)) {
d1562 2
a1563 1
		exchange_establish_p2(isakmp_sa, ISAKMP_EXCH_INFO, 0, &args, 0, 0);
d1569 1
a1569 1
message_send_info(struct message * msg)
d1574 1
a1574 1
	u_int8_t        payload;
d1582 1
a1582 1
	      : ISAKMP_DELETE_SPI_OFF + args->u.d.nspis * args->spi_sz);
d1585 2
a1586 1
		log_error("message_send_info: calloc (1, %lu) failed", (unsigned long) sz);
d1610 1
a1610 1
		       args->u.d.nspis * args->spi_sz);
d1636 2
a1637 2
message_drop(struct message * msg, int notify, struct proto * proto,
	     int incoming, int clean)
d1651 1
a1651 1
		port = ((struct sockaddr_in *) dst)->sin_port;
d1654 1
a1654 1
		port = ((struct sockaddr_in6 *) dst)->sin6_port;
d1657 2
a1658 1
		log_print("message_drop: unknown protocol family %d", dst->sa_family);
d1662 2
a1663 2
		  address ? address : "<unknown>", htons(port),
		  constant_name(isakmp_notify_cst, notify));
d1670 2
a1671 1
		message_send_notification(msg, msg->isakmp_sa, notify, proto, incoming);
d1681 1
a1681 1
message_dump_raw(char *header, struct message * msg, int class)
d1683 1
a1683 1
	u_int32_t       i, j, k = 0;
d1691 1
a1691 1
				 ((u_int8_t *) msg->iov[i].iov_base)[j]);
d1706 1
a1706 1
message_packet_log(struct message * msg)
d1735 1
a1735 1
message_encrypt(struct message * msg)
d1746 3
a1748 2
	 * For encryption we need to put all payloads together in a single buffer.
	 * This buffer should be padded to the current crypto transform's blocksize.
d1752 2
a1753 2
	sz = ((sz + exchange->crypto->blocksize - 1) / exchange->crypto->blocksize)
		* exchange->crypto->blocksize;
d1757 1
a1757 1
			  msg->iov[1].iov_base, (unsigned long) sz);
d1763 1
a1763 1
		       msg->iov[i].iov_len);
d1774 1
a1774 2
			     GET_ISAKMP_HDR_FLAGS(msg->iov[0].iov_base)
			     | ISAKMP_FLAGS_ENC);
d1790 1
a1790 1
message_check_duplicate(struct message * msg)
d1801 1
a1801 1
		 exchange->last_received));
d1804 3
a1806 3
			     "message_check_duplicate: last_received",
			     exchange->last_received->orig,
			     exchange->last_received->orig_sz));
d1811 1
a1811 1
				 "message_check_duplicate: dropping dup"));
d1814 3
a1816 2
			 * Retransmit if the previos sent message was the last of an
			 * exchange, otherwise just wait for the ordinary retransmission.
d1818 2
a1819 1
			if (exchange->last_sent && (exchange->last_sent->flags & MSG_LAST))
d1833 1
a1833 1
					     exchange->in_transit, link);
d1836 1
a1836 1
					     exchange->in_transit, link);
d1847 1
a1847 2
step_transform(struct payload * tp, struct payload ** propp,
	       struct payload ** sap)
d1862 2
a1863 3
message_negotiate_sa(struct message * msg,
		     int (*validate) (struct exchange *, struct sa *,
				      struct sa *))
d1895 1
a1895 1
	     tp = next_tp) {
d1903 10
a1912 10
				   GET_ISAKMP_GEN_LENGTH(tp->p)
				   - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			   exchange->doi->is_attribute_incompatible, msg)) {
			LOG_DBG((LOG_NEGOTIATION, 30,
				 "message_negotiate_sa: "
				 "transform %d proto %d proposal %d ok",
				 GET_ISAKMP_TRANSFORM_NO(tp->p),
				 GET_ISAKMP_PROP_PROTO(propp->p),
				 GET_ISAKMP_PROP_NO(propp->p)));
			if (sa_add_transform(sa, tp, exchange->initiator, &proto))
d1920 2
a1921 2
			while ((next_tp = step_transform(tp, &next_propp, &next_sap))
			       && next_propp == propp)
d1931 1
a1931 1
			== GET_ISAKMP_PROP_NO(next_propp->p))) {
d1934 4
a1937 3
					 "message_negotiate_sa: proto %d proposal %d failed",
					 GET_ISAKMP_PROP_PROTO(propp->p),
					 GET_ISAKMP_PROP_NO(propp->p)));
d1943 2
a1944 1
					TAILQ_REMOVE(&sa->protos, TAILQ_FIRST(&sa->protos), link);
d1950 5
a1954 4
				while ((next_tp = step_transform(tp, &next_propp, &next_sap))
				       && (GET_ISAKMP_PROP_NO(next_propp->p)
					   == GET_ISAKMP_PROP_NO(propp->p))
				       && next_sap == sap)
d1964 2
a1965 3
		    || (propp != next_propp
			&& (GET_ISAKMP_PROP_NO(propp->p)
			    != GET_ISAKMP_PROP_NO(next_propp->p)))
d1968 2
a1969 2
			 * Check if the suite we just considered was OK, if so we check
			 * it against the accepted ones.
d1972 2
a1973 1
				if (!validate || validate(exchange, sa, msg->isakmp_sa)) {
d1975 3
a1977 2
						 "message_negotiate_sa: proposal %d succeeded",
					     GET_ISAKMP_PROP_NO(propp->p)));
d1983 3
a1985 3
					while ((next_tp
						= step_transform(tp, &next_propp, &next_sap))
					       && next_sap == sap)
d1990 3
a1992 2
						 "message_negotiate_sa: proposal %d failed",
					     GET_ISAKMP_PROP_NO(propp->p)));
d2003 3
a2005 2
						TAILQ_REMOVE(&sa->protos, TAILQ_FIRST(&sa->protos),
							     link);
d2014 4
a2017 3
				 * XXX We cannot possibly call this a drop... seeing we just turn
				 * down one of the offers, can we?  I suggest renaming
				 * message_drop to something else.
d2019 4
a2022 2
				log_print("message_negotiate_sa: no compatible proposal found");
				message_drop(msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
d2044 1
a2044 1
message_add_sa_payload(struct message * msg)
d2062 1
a2062 1
	     sa = TAILQ_NEXT(sa, next)) {
d2069 1
a2069 1
				  (unsigned long) sa_len);
d2078 1
a2078 1
		     proto = TAILQ_NEXT(proto, link))
d2087 3
a2089 2
			log_error("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
				  (unsigned long) sizeof *transforms);
d2094 3
a2096 2
			log_error("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
				  (unsigned long) sizeof *transform_lens);
d2101 3
a2103 2
			log_error("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
				  (unsigned long) sizeof *proposals);
d2108 3
a2110 2
			log_error("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
				  (unsigned long) sizeof *proposal_lens);
d2115 3
a2117 2
		     proto = TAILQ_NEXT(proto, link), i++) {
			transform_lens[i] = GET_ISAKMP_GEN_LENGTH(proto->chosen->p);
d2120 3
a2122 2
				log_error("message_add_sa_payload: malloc (%lu) failed",
					  (unsigned long) transform_lens[i]);
d2128 2
a2129 3
					 GET_ISAKMP_PROP_PROTO(proto->chosen
							       ->context->p),
						   msg);
d2140 3
a2142 2
				log_error("message_add_sa_payload: malloc (%lu) failed",
					  (unsigned long) proposal_lens[i]);
d2145 2
a2146 1
			memcpy(transforms[i], proto->chosen->p, transform_lens[i]);
d2148 1
a2148 1
			       ISAKMP_PROP_SPI_OFF);
d2152 2
a2153 1
				memcpy(proposals[i] + ISAKMP_PROP_SPI_OFF, spi, spi_sz);
d2162 2
a2163 1
		if (message_add_payload(msg, ISAKMP_PAYLOAD_SA, sa_buf, sa_len, 1))
d2170 3
a2172 3
		     proto = TAILQ_NEXT(proto, link), i++) {
			if (message_add_payload(msg, ISAKMP_PAYLOAD_PROPOSAL, proposals[i],
						proposal_lens[i], i > 1))
d2174 2
a2175 2
			SET_ISAKMP_GEN_LENGTH(proposals[i],
				      proposal_lens[i] + transform_lens[i]);
d2180 1
a2180 1
				       transforms[i], transform_lens[i], 0))
d2219 2
a2220 2
u_int8_t       *
message_copy(struct message * msg, size_t offset, size_t * szp)
d2244 1
a2244 1
		       msg->iov[i].iov_len - start);
d2253 2
a2254 2
message_register_post_send(struct message * msg,
			   void (*post_send) (struct message *))
d2268 1
a2268 1
message_post_send(struct message * msg)
@


1.71
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: message.c,v 1.70 2004/04/07 22:45:49 ho Exp $	 */
d76 5
a80 6
static int
message_index_payload(struct message *, struct payload *, u_int8_t,
		      u_int8_t *);
static int
message_parse_transform(struct message *, struct payload *,
			u_int8_t, u_int8_t *);
a113 7
static u_int16_t min_payload_lengths[] = {
	0, ISAKMP_SA_SZ, ISAKMP_PROP_SZ, ISAKMP_TRANSFORM_SZ, ISAKMP_KE_SZ,
	ISAKMP_ID_SZ, ISAKMP_CERT_SZ, ISAKMP_CERTREQ_SZ, ISAKMP_HASH_SZ,
	ISAKMP_SIG_SZ, ISAKMP_NONCE_SZ, ISAKMP_NOTIFY_SZ, ISAKMP_DELETE_SZ,
	ISAKMP_VENDOR_SZ, ISAKMP_ATTRIBUTE_SZ
};

d279 7
a285 2
		if ((payload < ISAKMP_PAYLOAD_RESERVED_MIN)
		    && (len < min_payload_lengths[payload])) {
d298 2
a299 2
				 "message_parse_payloads: private next payload type %d "
			   "in payload of type %d ignored", next, payload));
d303 2
a304 2
		 * Check if the current payload is one of the accepted ones at this
		 * stage.
d371 46
@


1.70
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.69 2004/03/10 23:08:49 hshoexer Exp $	*/
/*	$EOM: message.c,v 1.156 2000/10/10 12:36:39 provos Exp $	*/
d69 1
a69 1
typedef fd_set set;
d74 32
a105 30
static int message_check_duplicate (struct message *);
static int message_encrypt (struct message *);
static int message_index_payload (struct message *, struct payload *, u_int8_t,
				  u_int8_t *);
static int message_parse_transform (struct message *, struct payload *,
				    u_int8_t, u_int8_t *);
static int message_validate_attribute (struct message *, struct payload *);
static int message_validate_cert (struct message *, struct payload *);
static int message_validate_cert_req (struct message *, struct payload *);
static int message_validate_delete (struct message *, struct payload *);
static int message_validate_hash (struct message *, struct payload *);
static int message_validate_id (struct message *, struct payload *);
static int message_validate_key_exch (struct message *, struct payload *);
static int message_validate_nonce (struct message *, struct payload *);
static int message_validate_notify (struct message *, struct payload *);
static int message_validate_proposal (struct message *, struct payload *);
static int message_validate_sa (struct message *, struct payload *);
static int message_validate_sig (struct message *, struct payload *);
static int message_validate_transform (struct message *, struct payload *);
static int message_validate_vendor (struct message *, struct payload *);

static void message_packet_log (struct message *);

static int (*message_validate_payload[]) (struct message *, struct payload *) =
{
  message_validate_sa, message_validate_proposal, message_validate_transform,
  message_validate_key_exch, message_validate_id, message_validate_cert,
  message_validate_cert_req, message_validate_hash, message_validate_sig,
  message_validate_nonce, message_validate_notify, message_validate_delete,
  message_validate_vendor, message_validate_attribute
d109 4
a112 4
  isakmp_sa_fld, isakmp_prop_fld, isakmp_transform_fld, isakmp_ke_fld,
  isakmp_id_fld, isakmp_cert_fld, isakmp_certreq_fld, isakmp_hash_fld,
  isakmp_sig_fld, isakmp_nonce_fld, isakmp_notify_fld, isakmp_delete_fld,
  isakmp_vendor_fld, isakmp_attribute_fld
d116 4
a119 4
  0, ISAKMP_SA_SZ, ISAKMP_PROP_SZ, ISAKMP_TRANSFORM_SZ, ISAKMP_KE_SZ,
  ISAKMP_ID_SZ, ISAKMP_CERT_SZ, ISAKMP_CERTREQ_SZ, ISAKMP_HASH_SZ,
  ISAKMP_SIG_SZ, ISAKMP_NONCE_SZ, ISAKMP_NOTIFY_SZ, ISAKMP_DELETE_SZ,
  ISAKMP_VENDOR_SZ, ISAKMP_ATTRIBUTE_SZ
d136 1
a136 1
message_alloc (struct transport *t, u_int8_t *buf, size_t sz)
d138 2
a139 2
  struct message *msg;
  int i;
d141 29
a169 31
  /*
   * We use calloc(3) because it zeroes the structure which we rely on in
   * message_free when determining what sub-allocations to free.
   */
  msg = (struct message *)calloc (1, sizeof *msg);
  if (!msg)
    return 0;
  msg->iov = calloc (1, sizeof *msg->iov);
  if (!msg->iov)
    {
      message_free (msg);
      return 0;
    }
  msg->iov[0].iov_len = sz;
  msg->iov[0].iov_base = malloc (sz);
  if (!msg->iov[0].iov_base)
    {
      message_free (msg);
      return 0;
    }
  msg->iovlen = 1;
  if (buf)
    memcpy (msg->iov[0].iov_base, buf, sz);
  msg->nextp = (u_int8_t *)msg->iov[0].iov_base + ISAKMP_HDR_NEXT_PAYLOAD_OFF;
  msg->transport = t;
  transport_reference (t);
  for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
    TAILQ_INIT (&msg->payload[i]);
  TAILQ_INIT (&msg->post_send);
  LOG_DBG ((LOG_MESSAGE, 90, "message_alloc: allocated %p", msg));
  return msg;
d177 1
a177 1
message_alloc_reply (struct message *msg)
d179 1
a179 1
  struct message *reply;
d181 6
a186 6
  reply = message_alloc (msg->transport, 0, ISAKMP_HDR_SZ);
  reply->exchange = msg->exchange;
  reply->isakmp_sa = msg->isakmp_sa;
  if (msg->isakmp_sa)
    sa_reference (msg->isakmp_sa);
  return reply;
d191 1
a191 1
message_free (struct message *msg)
d193 2
a194 2
  u_int32_t i;
  struct payload *payload, *next;
d196 20
a215 32
  LOG_DBG ((LOG_MESSAGE, 20, "message_free: freeing %p", msg));
  if (!msg)
    return;
  if (msg->orig && msg->orig != (u_int8_t *)msg->iov[0].iov_base)
    free (msg->orig);
  if (msg->iov)
    {
      for (i = 0; i < msg->iovlen; i++)
	if (msg->iov[i].iov_base)
	  free (msg->iov[i].iov_base);
      free (msg->iov);
    }
  if (msg->retrans)
    timer_remove_event (msg->retrans);
  for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
    for (payload = TAILQ_FIRST (&msg->payload[i]); payload; payload = next)
      {
	next = TAILQ_NEXT (payload, link);
	free (payload);
      }
  while (TAILQ_FIRST (&msg->post_send) != 0)
    TAILQ_REMOVE (&msg->post_send, TAILQ_FIRST (&msg->post_send), link);

  /* If we are on the send queue, remove us from there.  */
  if (msg->flags & MSG_IN_TRANSIT)
    {
      if (msg->flags & MSG_PRIORITIZED)
	TAILQ_REMOVE (&msg->transport->prio_sendq, msg, link);
      else
	TAILQ_REMOVE (&msg->transport->sendq, msg, link);
    }
  transport_release (msg->transport);
d217 8
a224 2
  if (msg->isakmp_sa)
    sa_release (msg->isakmp_sa);
d226 4
a229 1
  free (msg);
d241 82
a322 87
message_parse_payloads (struct message *msg, struct payload *p, u_int8_t next,
			u_int8_t *buf, set *accepted_payloads,
			int (*func) (struct message *, struct payload *,
				     u_int8_t, u_int8_t *))
{
  u_int8_t payload;
  u_int16_t len;
  int sz = 0;

  do
    {
      LOG_DBG ((LOG_MESSAGE, 50,
		"message_parse_payloads: offset %ld payload %s",
		(long)(buf - (u_int8_t *)msg->iov[0].iov_base),
		constant_name (isakmp_payload_cst, next)));

      /* Does this payload's header fit?  */
      if (buf + ISAKMP_GEN_SZ
	  > (u_int8_t *)msg->iov[0].iov_base + msg->iov[0].iov_len)
	{
	  log_print ("message_parse_payloads: short message");
	  message_drop (msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 1, 1);
	  return -1;
	}

      /* Ponder on the payload that is at BUF...  */
      payload = next;

      /* Look at the next payload's type.  */
      next = GET_ISAKMP_GEN_NEXT_PAYLOAD (buf);
      if (next >= ISAKMP_PAYLOAD_RESERVED_MIN &&
	  next <= ISAKMP_PAYLOAD_RESERVED_MAX)
	{
	  log_print ("message_parse_payloads: invalid next payload type %d "
		     "in payload of type %d", next, payload);
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
	  return -1;
	}

      /* Reserved fields in ISAKMP messages should be zero.  */
      if (GET_ISAKMP_GEN_RESERVED (buf) != 0)
	{
	  log_print ("message_parse_payloads: reserved field non-zero: %x",
		     GET_ISAKMP_GEN_RESERVED (buf));
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}

      /*
       * Decode and validate the payload length field.
       */
      len = GET_ISAKMP_GEN_LENGTH (buf);

      if ((payload < ISAKMP_PAYLOAD_RESERVED_MIN)
	   && (len < min_payload_lengths[payload]))
	{
	  log_print ("message_parse_payloads: payload too short: %u", len);
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}
  
      if (buf + len > (u_int8_t *)msg->iov[0].iov_base + msg->iov[0].iov_len)
	{
	  log_print ("message_parse_payloads: payload too long: %u", len);
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}

      /* Ignore private payloads.  */
      if (next >= ISAKMP_PAYLOAD_PRIVATE_MIN)
	{
	  LOG_DBG ((LOG_MESSAGE, 30,
		    "message_parse_payloads: private next payload type %d "
		    "in payload of type %d ignored", next, payload));
	  goto next_payload;
	}

      /*
       * Check if the current payload is one of the accepted ones at this
       * stage.
       */
      if (!ISSET (payload, accepted_payloads))
	{
	  log_print ("message_parse_payloads: payload type %d unexpected",
		     payload);
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
	  return -1;
d324 2
a325 12

      /* Call the payload handler specified by the caller.  */
      if (func (msg, p, payload, buf))
	return -1;

    next_payload:
      /* Advance to next payload.  */
      buf += len;
      sz += len;
    }
  while (next != ISAKMP_PAYLOAD_NONE);
  return sz;
d335 2
a336 2
message_parse_proposal (struct message *msg, struct payload *p,
			u_int8_t payload, u_int8_t *buf)
d338 1
a338 1
  set payload_set;
d340 2
a341 2
  /* Put the proposal into the proposal bucket.  */
  message_index_payload (msg, p, payload, buf);
d343 11
a353 11
  ZERO (&payload_set);
  SET (ISAKMP_PAYLOAD_TRANSFORM, &payload_set);
  if (message_parse_payloads (msg,
			      TAILQ_LAST (&msg->payload
					  [ISAKMP_PAYLOAD_PROPOSAL],
					  payload_head),
			      ISAKMP_PAYLOAD_TRANSFORM,
			      buf + ISAKMP_PROP_SPI_OFF
			      + GET_ISAKMP_PROP_SPI_SZ (buf),
			      &payload_set, message_parse_transform) == -1)
    return -1;
d355 1
a355 1
  return 0;
d359 2
a360 2
message_parse_transform (struct message *msg, struct payload *p,
			 u_int8_t payload, u_int8_t *buf)
d362 2
a363 2
  /* Put the transform into the transform bucket.  */
  message_index_payload (msg, p, payload, buf);
d365 2
a366 2
  LOG_DBG ((LOG_MESSAGE, 50, "Transform %d's attributes",
	    GET_ISAKMP_TRANSFORM_NO (buf)));
d368 3
a370 3
  attribute_map (buf + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 GET_ISAKMP_GEN_LENGTH (buf) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		 msg->exchange->doi->debug_attribute, msg);
d373 1
a373 1
  return 0;
d378 1
a378 1
message_validate_attribute (struct message *msg, struct payload *p)
d381 12
a392 13
  /* If we don't have an exchange yet, create one.  */
  if (!msg->exchange)
    {
      if (zero_test ((u_int8_t *)msg->iov[0].iov_base
		     + ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
	msg->exchange = exchange_setup_p1 (msg, IPSEC_DOI_IPSEC);
      else
	msg->exchange = exchange_setup_p2 (msg, IPSEC_DOI_IPSEC);
      if (!msg->exchange)
	{
	  log_print ("message_validate_attribute: can not create exchange");
	  message_free (msg);
	  return -1;
a393 1
    }
d395 1
a395 1
  return 0;
d400 1
a400 1
message_validate_cert (struct message *msg, struct payload *p)
d402 5
a406 6
  if (GET_ISAKMP_CERT_ENCODING (p->p) >= ISAKMP_CERTENC_RESERVED_MIN)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 1, 1);
      return -1;
    }
  return 0;
d411 1
a411 1
message_validate_cert_req (struct message *msg, struct payload *p)
d413 2
a414 2
  struct cert_handler *cert;
  size_t len = GET_ISAKMP_GEN_LENGTH (p->p)- ISAKMP_CERTREQ_AUTHORITY_OFF;
d416 16
a431 19
  if (GET_ISAKMP_CERTREQ_TYPE (p->p) >= ISAKMP_CERTENC_RESERVED_MIN)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 1, 1);
      return -1;
    }

  /*
   * Check the certificate types we support and if an acceptable authority
   * is included in the payload check if it can be decoded
   */
  cert = cert_get (GET_ISAKMP_CERTREQ_TYPE (p->p));
  if (!cert
      || (len && !cert->certreq_validate (p->p + ISAKMP_CERTREQ_AUTHORITY_OFF,
					  len)))
    {
      message_drop (msg, ISAKMP_NOTIFY_CERT_TYPE_UNSUPPORTED, 0, 1, 1);
      return -1;
    }
  return 0;
d439 1
a439 1
message_validate_delete (struct message *msg, struct payload *p)
d441 45
a485 84
  u_int8_t proto = GET_ISAKMP_DELETE_PROTO (p->p);
  struct doi *doi;
  struct sa *sa, *isakmp_sa;
  struct sockaddr *dst, *dst_isa;
  u_int32_t nspis = GET_ISAKMP_DELETE_NSPIS (p->p);
  u_int8_t *spis = (u_int8_t *)p->p + ISAKMP_DELETE_SPI_OFF;
  u_int32_t i;
  char *addr;

  doi = doi_lookup (GET_ISAKMP_DELETE_DOI (p->p));
  if (!doi)
    {
      log_print ("message_validate_delete: DOI not supported");
      message_free (msg);
      return -1;
    }

  /* If we don't have an exchange yet, create one.  */
  if (!msg->exchange)
    {
      if (zero_test ((u_int8_t *)msg->iov[0].iov_base
		     + ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
	msg->exchange = exchange_setup_p1 (msg, doi->id);
      else
	msg->exchange = exchange_setup_p2 (msg, doi->id);
      if (!msg->exchange)
	{
	  log_print ("message_validate_delete: can not create exchange");
	  message_free (msg);
	  return -1;
	}
    }

  if (proto != ISAKMP_PROTO_ISAKMP && doi->validate_proto (proto))
    {
      log_print ("message_validate_delete: protocol not supported");
      message_free (msg);
      return -1;
    }

  /* Validate the SPIs.  */
  for (i = 0; i < nspis; i++)
    {
      /* Get ISAKMP SA protecting this message. */
      isakmp_sa = msg->isakmp_sa;
      if (!isakmp_sa)
        {
          /* XXX should not happen? */
          log_print ("message_validate_delete: invalid spi "
                     "(no valid ISAKMP SA found)");
          message_free (msg);
          return -1;
        }
      isakmp_sa->transport->vtbl->get_dst (isakmp_sa->transport, &dst_isa);

      /* Get SA to be deleted. */
      msg->transport->vtbl->get_dst (msg->transport, &dst);
      if (proto == ISAKMP_PROTO_ISAKMP)
	sa = sa_lookup_isakmp_sa (dst, spis + i * ISAKMP_HDR_COOKIES_LEN);
      else
	sa = ipsec_sa_lookup (dst, ((u_int32_t *)spis)[i], proto);
      if (!sa)
        {
          LOG_DBG ((LOG_MESSAGE, 50, "message_validate_delete: invalid spi "
                    "(no valid SA found)"));
          message_free (msg);
          return -1;
        }
      sa->transport->vtbl->get_dst (sa->transport, &dst);

      /* Destination addresses must match. */
      if (dst->sa_family != dst_isa->sa_family ||
          memcmp (sockaddr_addrdata (dst_isa), sockaddr_addrdata (dst),
                  sockaddr_addrlen (dst)))
        {
          sockaddr2text (dst_isa, &addr, 0);

          log_print ("message_validate_delete: invalid spi "
                     "(illegal delete request from %s)", addr);
          free (addr);
          message_free (msg);
          return -1;
        }
    }
d487 29
a515 1
  return 0;
d524 1
a524 1
message_validate_hash (struct message *msg, struct payload *p)
d526 72
a597 83
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct hash *hash;
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  struct prf *prf;
  u_int8_t *comp_hash, *rest;
  u_int8_t message_id[ISAKMP_HDR_MESSAGE_ID_LEN];
  size_t rest_len;

  if (msg->exchange)	/* active exchange validates hash payload. */
    return 0;

  if (isakmp_sa == NULL)
    {
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
    }

  isa = isakmp_sa->data;
  hash = hash_get (isa->hash);

  if (hash == NULL)
    {
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
    }

  /* If no SKEYID_a, we can not do anything (should not happen).  */
  if (!isa->skeyid_a)
    {
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
    }

  /* Allocate the prf and start calculating our HASH(1). */
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    {
      message_free (msg);
      return -1;
    }

  comp_hash = (u_int8_t *)malloc (hash->hashsize);
  if (!comp_hash)
    {
      log_error ("message_validate_hash: malloc (%lu) failed",
	         (unsigned long)hash->hashsize);
      prf_free (prf);
      message_free (msg);
      return -1;
    }

  /* This is not an active exchange. */
  GET_ISAKMP_HDR_MESSAGE_ID (msg->iov[0].iov_base, message_id);

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: message_id",
		message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  rest = hashp->p + GET_ISAKMP_GEN_LENGTH (hashp->p);
  rest_len = (GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base)
	        - (rest - (u_int8_t*)msg->iov[0].iov_base));
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: payloads after HASH(1)",
		rest, rest_len));
  prf->Update (prf->prfctx, rest, rest_len);
  prf->Final (comp_hash, prf->prfctx);
  prf_free (prf);

  if (memcmp (hashp->p + ISAKMP_HASH_DATA_OFF, comp_hash, hash->hashsize))
    {
      log_print ("message_validate_hash: invalid hash value for %s payload",
		 TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])
		 ? "DELETE" : "NOTIFY");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      free (comp_hash);
      return -1;
    }
  free (comp_hash);
d599 2
a600 2
  /* Mark the HASH as handled. */
  hashp->flags |= PL_MARK;
d602 1
a602 1
  return 0;
d607 1
a607 1
message_validate_id (struct message *msg, struct payload *p)
d609 2
a610 2
  struct exchange *exchange = msg->exchange;
  size_t len = GET_ISAKMP_GEN_LENGTH (p->p);
d612 16
a627 19
  if (!exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_id: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  if (exchange->doi
      && exchange->doi->validate_id_information (GET_ISAKMP_ID_TYPE (p->p),
						 p->p + ISAKMP_ID_DOI_DATA_OFF,
						 p->p + ISAKMP_ID_DATA_OFF,
						 len - ISAKMP_ID_DATA_OFF,
						 exchange))
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 1, 1);
      return -1;
    }
  return 0;
d632 1
a632 1
message_validate_key_exch (struct message *msg, struct payload *p)
d634 2
a635 2
  struct exchange *exchange = msg->exchange;
  size_t len = GET_ISAKMP_GEN_LENGTH (p->p);
d637 13
a649 16
  if (!exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_key_exch: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  if (exchange->doi
      && exchange->doi->validate_key_information (p->p + ISAKMP_KE_DATA_OFF,
						  len - ISAKMP_KE_DATA_OFF))
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_KEY_INFORMATION, 0, 1, 1);
      return -1;
    }
  return 0;
d654 1
a654 1
message_validate_nonce (struct message *msg, struct payload *p)
d656 8
a663 10
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_nonce: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  /* Nonces require no specific validation.  */
  return 0;
d671 1
a671 1
message_validate_notify (struct message *msg, struct payload *p)
d673 44
a716 52
  u_int8_t proto = GET_ISAKMP_NOTIFY_PROTO (p->p);
  u_int16_t type = GET_ISAKMP_NOTIFY_MSG_TYPE (p->p);
  struct doi *doi;

  doi = doi_lookup (GET_ISAKMP_NOTIFY_DOI (p->p));
  if (!doi)
    {
      log_print ("message_validate_notify: DOI not supported");
      message_free (msg);
      return -1;
    }

  /* If we don't have an exchange yet, create one.  */
  if (!msg->exchange)
    {
      if (zero_test ((u_int8_t *)msg->iov[0].iov_base
		     + ISAKMP_HDR_MESSAGE_ID_OFF, ISAKMP_HDR_MESSAGE_ID_LEN))
	msg->exchange = exchange_setup_p1 (msg, doi->id);
      else
	msg->exchange = exchange_setup_p2 (msg, doi->id);
      if (!msg->exchange)
	{
	  log_print ("message_validate_notify: can not create exchange");
	  message_free (msg);
	  return -1;
	}
    }

  if (proto != ISAKMP_PROTO_ISAKMP && doi->validate_proto (proto))
    {
      log_print ("message_validate_notify: protocol not supported");
      message_free (msg);
      return -1;
    }

  /* XXX Validate the SPI.  */

  if (type < ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE
      || (type >= ISAKMP_NOTIFY_RESERVED_MIN
	  && type < ISAKMP_NOTIFY_PRIVATE_MIN)
      || (type >= ISAKMP_NOTIFY_STATUS_RESERVED1_MIN
	  && type <= ISAKMP_NOTIFY_STATUS_RESERVED1_MAX)
      || (type >= ISAKMP_NOTIFY_STATUS_DOI_MIN
	  && type <= ISAKMP_NOTIFY_STATUS_DOI_MAX
	  && doi->validate_notification (type))
      || type >= ISAKMP_NOTIFY_STATUS_RESERVED2_MIN)
    {
      log_print ("message_validate_notify: message type not supported");
      message_free (msg);
      return -1;
    }
  return 0;
d721 1
a721 1
message_validate_proposal (struct message *msg, struct payload *p)
d723 2
a724 2
  u_int8_t proto = GET_ISAKMP_PROP_PROTO (p->p);
  u_int8_t *sa = p->context->p;
d726 19
a744 24
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_proposal: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  if (proto != ISAKMP_PROTO_ISAKMP
      && msg->exchange->doi->validate_proto (proto))
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_PROTOCOL_ID, 0, 1, 1);
      return -1;
    }

  /* Check that we get monotonically increasing proposal IDs per SA.  */
  if (sa != last_sa)
    last_sa = sa;
  else if (GET_ISAKMP_PROP_NO (p->p) < last_prop_no)
    {
      message_drop (msg, ISAKMP_NOTIFY_BAD_PROPOSAL_SYNTAX, 0, 1, 1);
      return -1;
    }
  last_prop_no = GET_ISAKMP_PROP_NO (p->p);
d746 1
a746 1
  /* XXX Validate the SPI, and other syntactic things.  */
d748 1
a748 1
  return 0;
d763 1
a763 1
message_validate_sa (struct message *msg, struct payload *p)
d765 76
a840 86
  set payload_set;
  size_t len;
  u_int32_t doi_id;
  struct exchange *exchange = msg->exchange;
  u_int8_t *pkt = msg->iov[0].iov_base;

  doi_id = GET_ISAKMP_SA_DOI (p->p);
  if (!doi_lookup (doi_id))
    {
      log_print ("message_validate_sa: DOI not supported");
      message_drop (msg, ISAKMP_NOTIFY_DOI_NOT_SUPPORTED, 0, 1, 1);
      return -1;
    }

  /*
   * It's time to figure out what SA this message is about.  If it is
   * already set, then we are creating a new phase 1 SA.  Otherwise, lookup
   * the SA using the cookies and the message ID.  If we cannot find
   * it, and the phase 1 SA is ready, setup a phase 2 SA.
   */
  if (!exchange)
    {
      if (zero_test (pkt + ISAKMP_HDR_RCOOKIE_OFF, ISAKMP_HDR_RCOOKIE_LEN))
	exchange = exchange_setup_p1 (msg, doi_id);
      else if (msg->isakmp_sa->flags & SA_FLAG_READY)
	exchange = exchange_setup_p2 (msg, doi_id);
      else
	{
	  /* XXX What to do here?  */
	  message_free (msg);
	  return -1;
	}
      if (!exchange)
	{
	  /* XXX Log?  */
	  message_free (msg);
	  return -1;
	}
    }
  msg->exchange = exchange;

  /*
   * Create a struct sa for each SA payload handed to us unless we are the
   * initiator where we only will count them.
   */
  if (exchange->initiator)
    {
      /* XXX Count SA payloads.  */
    }
  else if (sa_create (exchange, msg->transport))
    {
      /* XXX Remove exchange if we just created it?   */
      message_free (msg);
      return -1;
    }

  if (exchange->phase == 1)
    {
      msg->isakmp_sa = TAILQ_FIRST (&exchange->sa_list);
      if (msg->isakmp_sa)
        sa_reference (msg->isakmp_sa);
    }

  /*
   * Let the DOI validate the situation, at the same time it tells us what
   * the length of the situation field is.
   */
  if (exchange->doi->validate_situation (p->p + ISAKMP_SA_SIT_OFF, &len,
      GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SA_SIT_OFF))
    {
      log_print ("message_validate_sa: situation not supported");
      message_drop (msg, ISAKMP_NOTIFY_SITUATION_NOT_SUPPORTED, 0, 1, 1);
      return -1;
    }

  /* Reset the fields we base our proposal & transform number checks on.  */
  last_sa = last_prop = 0;
  last_prop_no = last_xf_no = 0;

  /* Go through the PROPOSAL payloads.  */
  ZERO (&payload_set);
  SET (ISAKMP_PAYLOAD_PROPOSAL, &payload_set);
  if (message_parse_payloads (msg, p, ISAKMP_PAYLOAD_PROPOSAL,
			      p->p + ISAKMP_SA_SIT_OFF + len, &payload_set,
			      message_parse_proposal) == -1)
    return -1;
d842 1
a842 1
  return 0;
d847 1
a847 1
message_validate_sig (struct message *msg, struct payload *p)
d849 8
a856 10
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_sig: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  /* XXX Not implemented yet.  */
  return 0;
d861 1
a861 1
message_validate_transform (struct message *msg, struct payload *p)
d863 2
a864 2
  u_int8_t proto = GET_ISAKMP_PROP_PROTO (p->context->p);
  u_int8_t *prop = p->context->p;
d866 37
a902 46
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_transform: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  if (msg->exchange->doi
      ->validate_transform_id (proto, GET_ISAKMP_TRANSFORM_ID (p->p)))
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_TRANSFORM_ID, 0, 1, 1);
      return -1;
    }

  /* Check that the reserved field is zero.  */
  if (!zero_test (p->p + ISAKMP_TRANSFORM_RESERVED_OFF,
		  ISAKMP_TRANSFORM_RESERVED_LEN))
    {
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  /*
   * Check that we get monotonically increasing transform numbers per proposal.
   */
  if (prop != last_prop)
    last_prop = prop;
  else if (GET_ISAKMP_TRANSFORM_NO (p->p) <= last_xf_no)
    {
      message_drop (msg, ISAKMP_NOTIFY_BAD_PROPOSAL_SYNTAX, 0, 1, 1);
      return -1;
    }
  last_xf_no = GET_ISAKMP_TRANSFORM_NO (p->p);

  /* Validate the attributes.  */
  if (attribute_map (p->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		     GET_ISAKMP_GEN_LENGTH (p->p)
		     - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		     msg->exchange->doi->validate_attribute, msg))
    {
      message_drop (msg, ISAKMP_NOTIFY_ATTRIBUTES_NOT_SUPPORTED, 0, 1, 1);
      return -1;
    }

  return 0;
d907 1
a907 1
message_validate_vendor (struct message *msg, struct payload *p)
d909 13
a921 17
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_vendor: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

  /* Vendor IDs are only allowed in phase 1.  */
  if (msg->exchange->phase != 1)
    {
      message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
      return -1;
    }

  LOG_DBG ((LOG_MESSAGE, 40, "message_validate_vendor: vendor ID seen"));
  return 0;
d931 2
a932 2
message_index_payload (struct message *msg, struct payload *p,
		       u_int8_t payload, u_int8_t *buf)
d934 1
a934 1
  struct payload *payload_node;
d936 9
a944 9
  /* Put the payload pointer into the right bucket.  */
  payload_node = malloc (sizeof *payload_node);
  if (!payload_node)
    return -1;
  payload_node->p = buf;
  payload_node->context = p;
  payload_node->flags = 0;
  TAILQ_INSERT_TAIL (&msg->payload[payload], payload_node, link);
  return 0;
d954 1
a954 1
message_sort_payloads (struct message *msg, u_int8_t next)
d956 2
a957 2
  set payload_set;
  int i, sz;
d959 13
a971 13
  ZERO (&payload_set);
  for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
    if (i != ISAKMP_PAYLOAD_PROPOSAL && i != ISAKMP_PAYLOAD_TRANSFORM)
      SET (i, &payload_set);
  sz =
    message_parse_payloads (msg, 0, next,
			    (u_int8_t *)msg->iov[0].iov_base + ISAKMP_HDR_SZ,
			    &payload_set, message_index_payload);
  if (sz == -1)
    return -1;
  msg->iov[0].iov_len = ISAKMP_HDR_SZ + sz;
  SET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base, ISAKMP_HDR_SZ + sz);
  return 0;
d976 1
a976 1
message_validate_payloads (struct message *msg)
d978 2
a979 2
  int i;
  struct payload *p;
d981 11
a991 12
  for (i = ISAKMP_PAYLOAD_SA; i < ISAKMP_PAYLOAD_RESERVED_MIN; i++)
    for (p = TAILQ_FIRST (&msg->payload[i]); p; p = TAILQ_NEXT (p, link))
      {
	LOG_DBG ((LOG_MESSAGE, 60,
		  "message_validate_payloads: "
		  "payload %s at %p of message %p",
		  constant_name (isakmp_payload_cst, i), p->p, msg));
	field_dump_payload (fields[i - ISAKMP_PAYLOAD_SA], p->p);
	if (message_validate_payload[i - ISAKMP_PAYLOAD_SA] (msg, p))
	  return -1;
      }
  return 0;
d1000 1
a1000 1
message_recv (struct message *msg)
d1002 15
a1016 17
  u_int8_t *buf = msg->iov[0].iov_base;
  size_t sz = msg->iov[0].iov_len;
  u_int8_t exch_type;
  int setup_isakmp_sa, msgid_is_zero;
  u_int8_t flags;
  struct keystate *ks = 0;
  struct proto tmp_proto;
  struct sa tmp_sa;

  /* Messages shorter than an ISAKMP header are bad.  */
  if (sz < ISAKMP_HDR_SZ || sz != GET_ISAKMP_HDR_LENGTH (buf))
    {
      log_print ("message_recv: bad message length");
      message_drop (msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 1, 1);
      return -1;
    }

d1018 2
a1019 2
  /* Possibly dump a raw hex image of the message to the log channel.  */
  message_dump_raw ("message_recv", msg, LOG_MESSAGE);
d1022 58
a1079 64
  /*
   * If the responder cookie is zero, this is a request to setup an ISAKMP SA.
   * Otherwise the cookies should refer to an existing ISAKMP SA.
   *
   * XXX This is getting ugly, please reread later to see if it can be made
   * nicer.
   */
  setup_isakmp_sa = zero_test (buf + ISAKMP_HDR_RCOOKIE_OFF,
			       ISAKMP_HDR_RCOOKIE_LEN);
  if (setup_isakmp_sa)
    {
      /*
       * This might be a retransmission of a former ISAKMP SA setup message.
       * If so, just drop it.
       * XXX Must we really look in both the SA and exchange pools?
       */
      if (exchange_lookup_from_icookie (buf + ISAKMP_HDR_ICOOKIE_OFF)
	  || sa_lookup_from_icookie (buf + ISAKMP_HDR_ICOOKIE_OFF))
	{
	  /*
	   * XXX Later we should differentiate between retransmissions and
	   * potential replay attacks.
	   */
	  LOG_DBG ((LOG_MESSAGE, 90,
		    "message_recv: dropping setup for existing SA"));
	  message_free (msg);
	  return -1;
	}
    }
  else
    {
      msg->isakmp_sa = sa_lookup_by_header (buf, 0);
      if (msg->isakmp_sa)
        sa_reference (msg->isakmp_sa);

      /*
       * If we cannot find an ISAKMP SA out of the cookies, this is either
       * a responder's first reply, and we need to upgrade our exchange,
       * or it's just plain invalid cookies.
       */
      if (!msg->isakmp_sa)
	{
	  msg->exchange
	    = exchange_lookup_from_icookie (buf + ISAKMP_HDR_ICOOKIE_OFF);
	  if (msg->exchange && msg->exchange->phase == 1
	      && zero_test (msg->exchange->cookies + ISAKMP_HDR_RCOOKIE_OFF,
			    ISAKMP_HDR_RCOOKIE_LEN))
	    exchange_upgrade_p1 (msg);
	  else
	    {
	      log_print ("message_recv: invalid cookie(s) %08x%08x %08x%08x",
			 decode_32 (buf + ISAKMP_HDR_ICOOKIE_OFF),
			 decode_32 (buf + ISAKMP_HDR_ICOOKIE_OFF + 4),
			 decode_32 (buf + ISAKMP_HDR_RCOOKIE_OFF),
			 decode_32 (buf + ISAKMP_HDR_RCOOKIE_OFF + 4));
	      tmp_proto.sa = &tmp_sa;
	      tmp_sa.doi = doi_lookup (ISAKMP_DOI_ISAKMP);
	      tmp_proto.proto = ISAKMP_PROTO_ISAKMP;
	      tmp_proto.spi_sz[1] = ISAKMP_HDR_COOKIES_LEN;
	      tmp_proto.spi[1] = buf + ISAKMP_HDR_COOKIES_OFF;
	      message_drop (msg, ISAKMP_NOTIFY_INVALID_COOKIE, &tmp_proto, 1,
			    1);
	      return -1;
	    }
d1081 4
a1084 4
	  msg->isakmp_sa
	    = sa_lookup_from_icookie (buf + ISAKMP_HDR_ICOOKIE_OFF);
	  if (msg->isakmp_sa)
	    sa_isakmp_upgrade (msg);
d1086 2
a1088 2
      msg->exchange = exchange_lookup (buf, 1);
    }
d1090 2
a1091 2
  if (message_check_duplicate (msg))
    return -1;
d1093 172
a1264 200
  if (GET_ISAKMP_HDR_NEXT_PAYLOAD (buf) >= ISAKMP_PAYLOAD_RESERVED_MIN)
    {
      log_print ("message_recv: "
		 "invalid payload type %d in ISAKMP header "
		 "(check passphrases, if applicable and in Phase 1)",
		 GET_ISAKMP_HDR_NEXT_PAYLOAD (buf));
      message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 1, 1);
      return -1;
    }

  /* Validate that the message is of version 1.0.  */
  if (ISAKMP_VERSION_MAJOR (GET_ISAKMP_HDR_VERSION (buf)) != 1)
    {
      log_print ("message_recv: invalid version major %d",
		 ISAKMP_VERSION_MAJOR (GET_ISAKMP_HDR_VERSION (buf)));
      message_drop (msg, ISAKMP_NOTIFY_INVALID_MAJOR_VERSION, 0, 1, 1);
      return -1;
    }

  if (ISAKMP_VERSION_MINOR (GET_ISAKMP_HDR_VERSION (buf)) != 0)
    {
      log_print ("message_recv: invalid version minor %d",
		 ISAKMP_VERSION_MINOR (GET_ISAKMP_HDR_VERSION (buf)));
      message_drop (msg, ISAKMP_NOTIFY_INVALID_MINOR_VERSION, 0, 1, 1);
      return -1;
    }

  /*
   * Validate the exchange type.  If it's a DOI-specified exchange wait until
   * after all payloads have been seen for the validation as the SA payload
   * might not yet have been parsed, thus the DOI might be unknown.
   */
  exch_type = GET_ISAKMP_HDR_EXCH_TYPE (buf);
  if (exch_type == ISAKMP_EXCH_NONE
      || (exch_type >= ISAKMP_EXCH_FUTURE_MIN &&
	  exch_type <= ISAKMP_EXCH_FUTURE_MAX)
      || (setup_isakmp_sa && exch_type >= ISAKMP_EXCH_DOI_MIN))
    {
      log_print ("message_recv: invalid exchange type %s",
		 constant_name (isakmp_exch_cst, exch_type));
      message_drop (msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 1, 1);
      return -1;
    }

  /*
   * Check for unrecognized flags, or the encryption flag when we don't
   * have an ISAKMP SA to decrypt with.
   */
  flags = GET_ISAKMP_HDR_FLAGS (buf);
  if (flags
      & ~(ISAKMP_FLAGS_ENC | ISAKMP_FLAGS_COMMIT | ISAKMP_FLAGS_AUTH_ONLY))
    {
      log_print ("message_recv: invalid flags 0x%x",
		 GET_ISAKMP_HDR_FLAGS (buf));
      message_drop (msg, ISAKMP_NOTIFY_INVALID_FLAGS, 0, 1, 1);
      return -1;
    }

  /* If we are about to setup an ISAKMP SA, the message ID must be zero.  */
  msgid_is_zero = zero_test (buf + ISAKMP_HDR_MESSAGE_ID_OFF,
			     ISAKMP_HDR_MESSAGE_ID_LEN);
  if (setup_isakmp_sa && !msgid_is_zero)
    {
      log_print ("message_recv: invalid message id");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_MESSAGE_ID, 0, 1, 1);
      return -1;
    }

  if (!setup_isakmp_sa && msgid_is_zero)
    {
      /*
       * XXX Very likely redundant, look at the  else clause of the
       * if (setup_isakmp_sa) statement above.
       */
      msg->exchange = exchange_lookup (buf, 0);
      if (!msg->exchange)
	{
	  log_print ("message_recv: phase 1 message after ISAKMP SA is ready");
	  message_free (msg);
	  return -1;
	}
      else if (msg->exchange->last_sent)
	{
	  LOG_DBG ((LOG_MESSAGE, 80,
		    "message_recv: resending last message from phase 1"));
	  message_send (msg->exchange->last_sent);
	}
    }

  if (flags & ISAKMP_FLAGS_ENC)
    {
      if (!msg->isakmp_sa)
	{
	  LOG_DBG ((LOG_MISC, 10,
		    "message_recv: no isakmp_sa for encrypted message"));
	  message_free (msg);
	  return -1;
	}

      /* Decrypt rest of message using a DOI-specified IV.  */
      ks = msg->isakmp_sa->doi->get_keystate (msg);
      if (!ks)
	{
	  message_free (msg);
	  return -1;
	}
      msg->orig = malloc (sz);
      if (!msg->orig)
	{
	  message_free (msg);
	  free (ks);
	  return -1;
	}
      memcpy (msg->orig, buf, sz);
      crypto_decrypt (ks, buf + ISAKMP_HDR_SZ, sz - ISAKMP_HDR_SZ);
    }
  else
    msg->orig = buf;
  msg->orig_sz = sz;

  /* IKE packet capture */
  message_packet_log (msg);

  /*
   * Check the overall payload structure at the same time as indexing them by
   * type.
   */
  if (GET_ISAKMP_HDR_NEXT_PAYLOAD (buf) != ISAKMP_PAYLOAD_NONE
      && message_sort_payloads (msg, GET_ISAKMP_HDR_NEXT_PAYLOAD (buf)))
    {
      if (ks)
	free (ks);
      return -1;
    }

  /*
   * Run generic payload tests now.  If anything fails these checks, the
   * message needs either to be retained for later duplicate checks or
   * freed entirely.
   * XXX Should SAs and even transports be cleaned up then too?
   */
  if (message_validate_payloads (msg))
    {
      if (ks)
	free (ks);
      return -1;
    }

  /* If we have not found an exchange by now something is definitely wrong.  */
  if (!msg->exchange)
    {
      log_print ("message_recv: no exchange");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      if (ks)
	free (ks);
      return -1;
    }

  /*
   * Now we can validate DOI-specific exchange types.  If we have no SA
   * DOI-specific exchange types are definitely wrong.
   */
  if (exch_type >= ISAKMP_EXCH_DOI_MIN && exch_type <= ISAKMP_EXCH_DOI_MAX
      && msg->exchange->doi->validate_exchange (exch_type))
    {
      log_print ("message_recv: invalid DOI exchange type %d", exch_type);
      message_drop (msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 1, 1);
      if (ks)
	free (ks);
      return -1;
    }

  /* Make sure the IV we used gets saved in the proper SA.  */
  if (ks)
    {
      if (!msg->exchange->keystate)
	{
	  msg->exchange->keystate = ks;
	  msg->exchange->crypto = ks->xf;
	}
      else
	free (ks);
    }

  /* Handle the flags.  */
  if (flags & ISAKMP_FLAGS_ENC)
    msg->exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
  if ((msg->exchange->flags & EXCHANGE_FLAG_COMMITTED) == 0
      && (flags & ISAKMP_FLAGS_COMMIT))
    msg->exchange->flags |= EXCHANGE_FLAG_HE_COMMITTED;

  /* Require encryption as soon as we have the keystate for it.  */
  if ((flags & ISAKMP_FLAGS_ENC) == 0 &&
      (msg->exchange->phase == 2 || msg->exchange->keystate))
    {
      log_print ("message_recv: cleartext phase %d message",
		 msg->exchange->phase);
      message_drop (msg, ISAKMP_NOTIFY_INVALID_FLAGS, 0, 1, 1);
      return -1;
    }
d1266 1
a1266 4
  /* OK let the exchange logic do the rest.  */
  exchange_run (msg);

  return 0;
d1270 1
a1270 1
message_send_expire (struct message *msg)
d1272 1
a1272 1
  msg->retrans = 0;
d1274 1
a1274 1
  message_send (msg);
d1279 1
a1279 1
message_send (struct message *msg)
d1281 33
a1313 40
  struct exchange *exchange = msg->exchange;
  struct message *m;
  struct msg_head *q;

  /* Remove retransmissions on this message  */
  if (msg->retrans)
    {
      timer_remove_event (msg->retrans);
      msg->retrans = 0;
    }

  /* IKE packet capture */
  message_packet_log (msg);

  /*
   * If the ISAKMP SA has set up encryption, encrypt the message.
   * However, in a retransmit, it is already encrypted.
   */
  if ((msg->flags & MSG_ENCRYPTED) == 0
      && exchange->flags & EXCHANGE_FLAG_ENCRYPT)
    {
      if (!exchange->keystate)
	{
	  exchange->keystate = exchange->doi->get_keystate (msg);
	  exchange->crypto = exchange->keystate->xf;
	  exchange->flags |= EXCHANGE_FLAG_ENCRYPT;
	}

      if (message_encrypt (msg))
	{
	  /* XXX Log.  */
	  return;
	}
    }

  /* Keep the COMMIT bit on.  */
  if (exchange->flags & EXCHANGE_FLAG_COMMITTED)
    SET_ISAKMP_HDR_FLAGS (msg->iov[0].iov_base,
			  GET_ISAKMP_HDR_FLAGS (msg->iov[0].iov_base)
			  | ISAKMP_FLAGS_COMMIT);
d1316 1
a1316 1
  message_dump_raw ("message_send", msg, LOG_MESSAGE);
d1318 2
a1319 2
  msg->flags |= MSG_IN_TRANSIT;
  exchange->in_transit = msg;
d1321 15
a1335 17
  /*
   * If we get a retransmission of a message before our response
   * has left the queue, don't queue it again, as it will result
   * in a circular list.
   */
  q = msg->flags & MSG_PRIORITIZED ? &msg->transport->prio_sendq :
    &msg->transport->sendq;

  for (m = TAILQ_FIRST (q); m; m = TAILQ_NEXT (m, link))
    if (m == msg)
      {
	LOG_DBG ((LOG_MESSAGE, 60,
		  "message_send: msg %p already on sendq %p", m, q));
	return;
      }

  TAILQ_INSERT_TAIL (q, msg, link);
d1344 2
a1345 2
message_setup_header (struct message *msg, u_int8_t exchange, u_int8_t flags,
		      u_int8_t *msg_id)
d1347 1
a1347 1
  u_int8_t *buf = msg->iov[0].iov_base;
d1349 9
a1357 9
  SET_ISAKMP_HDR_ICOOKIE (buf, msg->exchange->cookies);
  SET_ISAKMP_HDR_RCOOKIE (buf,
			  msg->exchange->cookies + ISAKMP_HDR_ICOOKIE_LEN);
  SET_ISAKMP_HDR_NEXT_PAYLOAD (buf, ISAKMP_PAYLOAD_NONE);
  SET_ISAKMP_HDR_VERSION (buf, ISAKMP_VERSION_MAKE (1, 0));
  SET_ISAKMP_HDR_EXCH_TYPE (buf, exchange);
  SET_ISAKMP_HDR_FLAGS (buf, flags);
  SET_ISAKMP_HDR_MESSAGE_ID (buf, msg_id);
  SET_ISAKMP_HDR_LENGTH (buf, msg->iov[0].iov_len);
d1369 2
a1370 2
message_add_payload (struct message *msg, u_int8_t payload, u_int8_t *buf,
		     size_t sz, int link)
d1372 2
a1373 2
  struct iovec *new_iov;
  struct payload *payload_node;
d1375 34
a1408 36
  payload_node = calloc (1, sizeof *payload_node);
  if (!payload_node)
    {
      log_error ("message_add_payload: calloc (1, %lu) failed",
		 (unsigned long)sizeof *payload_node);
      return -1;
    }
  new_iov
    = (struct iovec *)realloc (msg->iov, (msg->iovlen + 1) * sizeof *msg->iov);
  if (!new_iov)
    {
      log_error ("message_add_payload: realloc (%p, %lu) failed", msg->iov,
		 (msg->iovlen + 1) * (unsigned long)sizeof *msg->iov);
      free (payload_node);
      return -1;
    }
  msg->iov = new_iov;
  new_iov[msg->iovlen].iov_base = buf;
  new_iov[msg->iovlen].iov_len = sz;
  msg->iovlen++;
  if (link)
    *msg->nextp = payload;
  msg->nextp = buf + ISAKMP_GEN_NEXT_PAYLOAD_OFF;
  *msg->nextp = ISAKMP_PAYLOAD_NONE;
  SET_ISAKMP_GEN_RESERVED (buf, 0);
  SET_ISAKMP_GEN_LENGTH (buf, sz);
  SET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base,
			 GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base) + sz);

  /*
   * For the sake of exchange_validate we index the payloads even in outgoing
   * messages, however context and flags are uninteresting in this situation.
   */
  payload_node->p = buf;
  TAILQ_INSERT_TAIL (&msg->payload[payload], payload_node, link);
  return 0;
d1413 14
a1426 14
  char discr;
  u_int32_t doi;
  u_int8_t proto;
  u_int16_t spi_sz;
  union {
    struct {
      u_int16_t msg_type;
      u_int8_t *spi;
    } n;
    struct {
      u_int16_t nspis;
      u_int8_t *spis;
    } d;
  } u;
d1441 20
a1460 20
message_send_notification (struct message *msg, struct sa *isakmp_sa,
			   u_int16_t notify, struct proto *proto,
			   int incoming)
{
  struct info_args args;
  struct sa *doi_sa = proto ? proto->sa : isakmp_sa;

  args.discr = 'N';
  args.doi = doi_sa ? doi_sa->doi->id : ISAKMP_DOI_ISAKMP;
  args.proto = proto ? proto->proto : ISAKMP_PROTO_ISAKMP;
  args.spi_sz = proto ? proto->spi_sz[incoming] : 0;
  args.u.n.msg_type = notify;
  args.u.n.spi = proto ? proto->spi[incoming] : 0;
  if (isakmp_sa && (isakmp_sa->flags & SA_FLAG_READY))
    exchange_establish_p2 (isakmp_sa, ISAKMP_EXCH_INFO, 0, &args, 0 ,0);
  else
    exchange_establish_p1 (msg->transport, ISAKMP_EXCH_INFO,
			   msg->exchange
			   ? msg->exchange->doi->id : ISAKMP_DOI_ISAKMP,
			   0, &args, 0, 0);
d1465 1
a1465 1
message_send_delete (struct sa *sa)
d1467 24
a1490 27
  struct info_args args;
  struct proto *proto;
  struct sa *isakmp_sa;
  struct sockaddr *dst;

  sa->transport->vtbl->get_dst (sa->transport, &dst);
  isakmp_sa = sa_isakmp_lookup_by_peer (dst, sysdep_sa_len (dst));
  if (!isakmp_sa)
    {
      /*
       * XXX We ought to setup an ISAKMP SA with our peer here and send
       * the DELETE over that one.
       */
      return;
    }

  args.discr = 'D';
  args.doi = sa->doi->id;
  args.u.d.nspis = 1;
  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    {
      args.proto = proto->proto;
      args.spi_sz = proto->spi_sz[1];
      args.u.d.spis = proto->spi[1];
      exchange_establish_p2 (isakmp_sa, ISAKMP_EXCH_INFO, 0, &args, 0 ,0);
    }
d1495 1
a1495 1
message_send_info (struct message *msg)
d1497 55
a1551 62
  u_int8_t *buf;
  size_t sz;
  struct info_args *args = msg->extra;
  u_int8_t payload;

  /* Let the DOI get the first hand on the message.  */
  if (msg->exchange->doi->informational_pre_hook)
    if (msg->exchange->doi->informational_pre_hook (msg))
      return -1;

  sz = (args->discr == 'N' ? ISAKMP_NOTIFY_SPI_OFF + args->spi_sz
	: ISAKMP_DELETE_SPI_OFF + args->u.d.nspis * args->spi_sz);
  buf = calloc (1, sz);
  if (!buf)
    {
      log_error ("message_send_info: calloc (1, %lu) failed", (unsigned long)sz);
      message_free (msg);
      return -1;
    }

  switch (args->discr)
    {
    case 'N':
      /* Build the NOTIFY payload.  */
      payload = ISAKMP_PAYLOAD_NOTIFY;
      SET_ISAKMP_NOTIFY_DOI (buf, args->doi);
      SET_ISAKMP_NOTIFY_PROTO (buf, args->proto);
      SET_ISAKMP_NOTIFY_SPI_SZ (buf, args->spi_sz);
      SET_ISAKMP_NOTIFY_MSG_TYPE (buf, args->u.n.msg_type);
      memcpy (buf + ISAKMP_NOTIFY_SPI_OFF, args->u.n.spi, args->spi_sz);
      break;

    case 'D':
    default:			/* Silence GCC.  */
      /* Build the DELETE payload.  */
      payload = ISAKMP_PAYLOAD_DELETE;
      SET_ISAKMP_DELETE_DOI (buf, args->doi);
      SET_ISAKMP_DELETE_PROTO (buf, args->proto);
      SET_ISAKMP_DELETE_SPI_SZ (buf, args->spi_sz);
      SET_ISAKMP_DELETE_NSPIS (buf, args->u.d.nspis);
      memcpy (buf + ISAKMP_DELETE_SPI_OFF, args->u.d.spis,
	      args->u.d.nspis * args->spi_sz);
      msg->flags |= MSG_PRIORITIZED;
      break;
    }

  if (message_add_payload (msg, payload, buf, sz, 1))
    {
      free (buf);
      message_free (msg);
      return -1;
    }

  /* Let the DOI get the last hand on the message.  */
  if (msg->exchange->doi->informational_post_hook)
    if (msg->exchange->doi->informational_post_hook (msg))
      {
	message_free (msg);
	return -1;
      }

  return 0;
d1561 2
a1562 2
message_drop (struct message *msg, int notify, struct proto *proto,
	      int incoming, int clean)
d1564 33
a1596 36
  struct transport *t = msg->transport;
  struct sockaddr *dst;
  char *address;
  short port = 0;

  t->vtbl->get_dst (t, &dst);
  if (sockaddr2text (dst, &address, 0))
    {
      log_error ("message_drop: sockaddr2text () failed");
      address = 0;
    }

  switch (dst->sa_family)
    {
    case AF_INET:
      port = ((struct sockaddr_in *)dst)->sin_port;
      break;
    case AF_INET6:
      port = ((struct sockaddr_in6 *)dst)->sin6_port;
      break;
    default:
      log_print ("message_drop: unknown protocol family %d", dst->sa_family);
    }

  log_print ("dropped message from %s port %d due to notification type %s",
             address ? address : "<unknown>", htons (port),
	     constant_name (isakmp_notify_cst, notify));

  if (address)
    free (address);

  /* If specified, return a notification.  */
  if (notify)
    message_send_notification (msg, msg->isakmp_sa, notify, proto, incoming);
  if (clean)
    message_free (msg);
d1604 1
a1604 1
message_dump_raw (char *header, struct message *msg, int class)
d1606 2
a1607 2
  u_int32_t i, j, k = 0;
  char buf[80], *p = buf;
d1609 17
a1625 20
  LOG_DBG ((class, 70, "%s: message %p", header, msg));
  field_dump_payload (isakmp_hdr_fld, msg->iov[0].iov_base);
  for (i = 0; i < msg->iovlen; i++)
    for (j = 0; j < msg->iov[i].iov_len; j++)
      {
	snprintf (p, sizeof buf - (int)(p - buf), "%02x",
		  ((u_int8_t *)msg->iov[i].iov_base)[j]);
	p += 2;
	if (++k % 32 == 0)
	  {
	    *p = '\0';
	    LOG_DBG ((class, 70, "%s: %s", header, buf));
	    p = buf;
	  }
	else if (k % 4 == 0)
	  *p++ = ' ';
      }
  *p = '\0';
  if (p != buf)
    LOG_DBG ((class, 70, "%s: %s", header, buf));
d1629 1
a1629 1
message_packet_log (struct message *msg)
d1632 1
a1632 1
  struct sockaddr *src, *dst;
d1634 12
a1645 15
  /* Don't log retransmissions. Redundant for incoming packets... */
  if (msg->xmits > 0)
    return;

  /* Figure out direction. */
  if (msg->exchange && msg->exchange->initiator ^ (msg->exchange->step % 2))
    {
      msg->transport->vtbl->get_src (msg->transport, &src);
      msg->transport->vtbl->get_dst (msg->transport, &dst);
    }
  else
    {
      msg->transport->vtbl->get_src (msg->transport, &dst);
      msg->transport->vtbl->get_dst (msg->transport, &src);
    }
d1647 2
a1648 2
  log_packet_iov (src, dst, msg->iov, msg->iovlen);
#endif /* USE_DEBUG */
d1658 1
a1658 1
message_encrypt (struct message *msg)
d1660 41
a1700 43
  struct exchange *exchange = msg->exchange;
  size_t i, sz = 0;
  u_int8_t *buf;

  /* If no payloads, nothing to do.  */
  if (msg->iovlen == 1)
    return 0;

  /*
   * For encryption we need to put all payloads together in a single buffer.
   * This buffer should be padded to the current crypto transform's blocksize.
   */
  for (i = 1; i < msg->iovlen; i++)
    sz += msg->iov[i].iov_len;
  sz = ((sz + exchange->crypto->blocksize - 1) / exchange->crypto->blocksize)
    * exchange->crypto->blocksize;
  buf = realloc (msg->iov[1].iov_base, sz);
  if (!buf)
    {
      log_error ("message_encrypt: realloc (%p, %lu) failed",
		 msg->iov[1].iov_base, (unsigned long)sz);
      return -1;
    }
  msg->iov[1].iov_base = buf;
  for (i = 2; i < msg->iovlen; i++)
    {
      memcpy (buf + msg->iov[1].iov_len, msg->iov[i].iov_base,
	      msg->iov[i].iov_len);
      msg->iov[1].iov_len += msg->iov[i].iov_len;
      free (msg->iov[i].iov_base);
    }

  /* Pad with zeroes.  */
  memset (buf + msg->iov[1].iov_len, '\0', sz - msg->iov[1].iov_len);
  msg->iov[1].iov_len = sz;
  msg->iovlen = 2;

  SET_ISAKMP_HDR_FLAGS (msg->iov[0].iov_base,
			GET_ISAKMP_HDR_FLAGS (msg->iov[0].iov_base)
			| ISAKMP_FLAGS_ENC);
  SET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base, ISAKMP_HDR_SZ + sz);
  crypto_encrypt (exchange->keystate, buf, msg->iov[1].iov_len);
  msg->flags |= MSG_ENCRYPTED;
d1702 2
a1703 2
  /* Update the IV so we can decrypt the next incoming message.  */
  crypto_update_iv (exchange->keystate);
d1705 1
a1705 1
  return 0;
d1713 1
a1713 1
message_check_duplicate (struct message *msg)
d1715 49
a1763 55
  struct exchange *exchange = msg->exchange;
  size_t sz = msg->iov[0].iov_len;
  u_int8_t *pkt = msg->iov[0].iov_base;

  /* If no SA has been found, we cannot test, thus it's good.  */
  if (!exchange)
    return 0;

  LOG_DBG ((LOG_MESSAGE, 90, "message_check_duplicate: last_received %p",
	    exchange->last_received));
  if (exchange->last_received)
    {
      LOG_DBG_BUF ((LOG_MESSAGE, 95,
		    "message_check_duplicate: last_received",
		    exchange->last_received->orig,
		    exchange->last_received->orig_sz));
      /* Is it a duplicate, lose the new one.  */
      if (sz == exchange->last_received->orig_sz
	  && memcmp (pkt, exchange->last_received->orig, sz) == 0)
	{
	  LOG_DBG ((LOG_MESSAGE, 80,
		    "message_check_duplicate: dropping dup"));

	  /*
	   * Retransmit if the previos sent message was the last of an
	   * exchange, otherwise just wait for the ordinary retransmission.
	   */
	  if (exchange->last_sent && (exchange->last_sent->flags & MSG_LAST))
	    message_send (exchange->last_sent);
	  message_free (msg);
	  return -1;
	}
    }

  /*
   * As this new message is an indication that state is moving forward
   * at the peer, remove the retransmit timer on our last message.
   */
  if (exchange->last_sent)
    {
      if (exchange->last_sent == exchange->in_transit)
	{
	  if (exchange->in_transit->flags & MSG_PRIORITIZED)
	    TAILQ_REMOVE (&exchange->in_transit->transport->prio_sendq,
			  exchange->in_transit, link);
	  else
	    TAILQ_REMOVE (&exchange->in_transit->transport->sendq,
			  exchange->in_transit, link);
	  exchange->in_transit = 0;
	}
      message_free (exchange->last_sent);
      exchange->last_sent = 0;
    }

  return 0;
d1768 2
a1769 2
step_transform (struct payload *tp, struct payload **propp,
		struct payload **sap)
d1771 6
a1776 7
  tp = TAILQ_NEXT (tp, link);
  if (tp)
    {
      *propp = tp->context;
      *sap = (*propp)->context;
    }
  return tp;
d1784 167
a1950 166
message_negotiate_sa (struct message *msg,
		      int (*validate) (struct exchange *, struct sa *,
				       struct sa *))
{
  struct payload *tp, *propp, *sap, *next_tp = 0, *next_propp, *next_sap;
  struct payload *saved_tp = 0, *saved_propp = 0, *saved_sap = 0;
  struct sa *sa;
  struct proto *proto;
  int suite_ok_so_far = 0;
  struct exchange *exchange = msg->exchange;

  /*
   * This algorithm is a weird bottom-up thing... mostly due to the
   * payload links pointing upwards.
   *
   * The algorithm goes something like this:
   * Foreach transform
   *   If transform is compatible
   *     Remember that this protocol can work
   *     Skip to last transform of this protocol
   *   If next transform belongs to a new protocol inside the same suite
   *     If no transform was found for the current protocol
   *       Forget all earlier transforms for protocols in this suite
   *       Skip to last transform of this suite
   *   If next transform belongs to a new suite
   *     If the current protocol had an OK transform
   *       Skip to the last transform of this SA
   *   If the next transform belongs to a new SA
   *     If no transforms have been chosen
   *       Issue a NO_PROPOSAL_CHOSEN notification
   */

  sa = TAILQ_FIRST (&exchange->sa_list);
  for (tp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_TRANSFORM]); tp;
       tp = next_tp)
    {
      propp = tp->context;
      sap = propp->context;
      sap->flags |= PL_MARK;
      next_tp = step_transform (tp, &next_propp, &next_sap);

      /* For each transform, see if it is compatible.  */
      if (!attribute_map (tp->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			  GET_ISAKMP_GEN_LENGTH (tp->p)
			  - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			  exchange->doi->is_attribute_incompatible, msg))
	{
	  LOG_DBG ((LOG_NEGOTIATION, 30,
		    "message_negotiate_sa: "
		    "transform %d proto %d proposal %d ok",
		    GET_ISAKMP_TRANSFORM_NO (tp->p),
		    GET_ISAKMP_PROP_PROTO (propp->p),
		    GET_ISAKMP_PROP_NO (propp->p)));
	  if (sa_add_transform (sa, tp, exchange->initiator, &proto))
	    goto cleanup;
	  suite_ok_so_far = 1;

	  saved_tp = next_tp;
	  saved_propp = next_propp;
	  saved_sap = next_sap;
	  /* Skip to last transform of this protocol proposal.  */
	  while ((next_tp = step_transform (tp, &next_propp, &next_sap))
		 && next_propp == propp)
	    tp = next_tp;
	}

    retry_transform:
      /*
       * Figure out if we will be looking at a new protocol proposal
       * inside the current protection suite.
       */
      if (next_tp && propp != next_propp && sap == next_sap
	  && (GET_ISAKMP_PROP_NO (propp->p)
	      == GET_ISAKMP_PROP_NO (next_propp->p)))
	{
	  if (!suite_ok_so_far)
	    {
	      LOG_DBG ((LOG_NEGOTIATION, 30,
			"message_negotiate_sa: proto %d proposal %d failed",
			GET_ISAKMP_PROP_PROTO (propp->p),
			GET_ISAKMP_PROP_NO (propp->p)));
	      /* Remove potentially succeeded choices from the SA.  */
	      while (TAILQ_FIRST (&sa->protos))
		TAILQ_REMOVE (&sa->protos, TAILQ_FIRST (&sa->protos), link);

	      /* Skip to the last transform of this protection suite.  */
	      while ((next_tp = step_transform (tp, &next_propp, &next_sap))
		     && (GET_ISAKMP_PROP_NO (next_propp->p)
			 == GET_ISAKMP_PROP_NO (propp->p))
		     && next_sap == sap)
		tp = next_tp;
	    }
	  suite_ok_so_far = 0;
	}

      /* Figure out if we will be looking at a new protection suite.  */
      if (!next_tp
	  || (propp != next_propp
	      && (GET_ISAKMP_PROP_NO (propp->p)
		  != GET_ISAKMP_PROP_NO (next_propp->p)))
	  || sap != next_sap)
	{
	  /*
	   * Check if the suite we just considered was OK, if so we check
	   * it against the accepted ones.
	   */
	  if (suite_ok_so_far)
	    {
	      if (!validate || validate (exchange, sa, msg->isakmp_sa))
		{
		  LOG_DBG ((LOG_NEGOTIATION, 30,
			    "message_negotiate_sa: proposal %d succeeded",
			    GET_ISAKMP_PROP_NO (propp->p)));

		  /* Skip to the last transform of this SA.  */
		  while ((next_tp
			  = step_transform (tp, &next_propp, &next_sap))
			 && next_sap == sap)
		    tp = next_tp;
		}
	      else
		{
		  /* Backtrack.  */
		  LOG_DBG ((LOG_NEGOTIATION, 30,
			    "message_negotiate_sa: proposal %d failed",
			    GET_ISAKMP_PROP_NO (propp->p)));
		  next_tp = saved_tp;
		  next_propp = saved_propp;
		  next_sap = saved_sap;
		  suite_ok_so_far = 0;

		  /* Remove potentially succeeded choices from the SA.  */
		  while (TAILQ_FIRST (&sa->protos))
		    TAILQ_REMOVE (&sa->protos, TAILQ_FIRST (&sa->protos),
				  link);
		  goto retry_transform;
		}
	    }
	}

      /* Have we walked all the proposals of an SA?  */
      if (!next_tp || sap != next_sap)
	{
	  if (!suite_ok_so_far)
	    {
	      /*
	       * XXX We cannot possibly call this a drop... seeing we just turn
	       * down one of the offers, can we?  I suggest renaming
	       * message_drop to something else.
	       */
	      log_print ("message_negotiate_sa: no compatible proposal found");
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 1, 0);
	    }
	  sa = TAILQ_NEXT (sa, next);
	}
    }
  return 0;

 cleanup:
  /*
   * Remove potentially succeeded choices from the SA.
   * XXX Do we leak struct protos and related data here?
   */
  while (TAILQ_FIRST (&sa->protos))
    TAILQ_REMOVE (&sa->protos, TAILQ_FIRST (&sa->protos), link);
  return -1;
d1958 1
a1958 1
message_add_sa_payload (struct message *msg)
d1960 158
a2117 175
  struct exchange *exchange = msg->exchange;
  u_int8_t *sa_buf, *saved_nextp_sa, *saved_nextp_prop;
  size_t sa_len, extra_sa_len;
  int i, nprotos = 0;
  struct proto *proto;
  u_int8_t **transforms = 0, **proposals = 0;
  size_t *transform_lens = 0, *proposal_lens = 0;
  struct sa *sa;
  struct doi *doi = exchange->doi;
  u_int8_t *spi = 0;
  size_t spi_sz;

  /*
   * Generate SA payloads.
   */
  for (sa = TAILQ_FIRST (&exchange->sa_list); sa;
       sa = TAILQ_NEXT (sa, next))
    {
      /* Setup a SA payload.  */
      sa_len = ISAKMP_SA_SIT_OFF + doi->situation_size ();
      extra_sa_len = 0;
      sa_buf = malloc (sa_len);
      if (!sa_buf)
	{
	  log_error ("message_add_sa_payload: malloc (%lu) failed",
		(unsigned long)sa_len);
	  goto cleanup;
	}

      SET_ISAKMP_SA_DOI (sa_buf, doi->id);
      doi->setup_situation (sa_buf);

      /* Count transforms.  */
      nprotos = 0;
      for (proto = TAILQ_FIRST (&sa->protos); proto;
	   proto = TAILQ_NEXT (proto, link))
	nprotos++;

      /* Allocate transient transform and proposal payload/size vectors.  */
      transforms = calloc (nprotos, sizeof *transforms);
      if (!transforms)
	{
	  log_error ("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
		     (unsigned long)sizeof *transforms);
	  goto cleanup;
	}

      transform_lens = calloc (nprotos, sizeof *transform_lens);
      if (!transform_lens)
	{
	  log_error ("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
		     (unsigned long)sizeof *transform_lens);
	  goto cleanup;
	}

      proposals = calloc (nprotos, sizeof *proposals);
      if (!proposals)
	{
	  log_error ("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
		     (unsigned long)sizeof *proposals);
	  goto cleanup;
	}

      proposal_lens = calloc (nprotos, sizeof *proposal_lens);
      if (!proposal_lens)
	{
	  log_error ("message_add_sa_payload: calloc (%d, %lu) failed", nprotos,
		     (unsigned long)sizeof *proposal_lens);
	  goto cleanup;
	}

      /* Pick out the chosen transforms.  */
      for (proto = TAILQ_FIRST (&sa->protos), i = 0; proto;
	   proto = TAILQ_NEXT (proto, link), i++)
	{
	  transform_lens[i] = GET_ISAKMP_GEN_LENGTH (proto->chosen->p);
	  transforms[i] = malloc (transform_lens[i]);
	  if (!transforms[i])
	    {
	      log_error ("message_add_sa_payload: malloc (%lu) failed",
			 (unsigned long)transform_lens[i]);
	      goto cleanup;
	    }

	  /* Get incoming SPI from application.  */
	  if (doi->get_spi)
	    {
	      spi = doi->get_spi (&spi_sz,
				  GET_ISAKMP_PROP_PROTO (proto->chosen
							 ->context->p),
				  msg);
	      if (spi_sz && !spi)
		goto cleanup;
	      proto->spi[1] = spi;
	      proto->spi_sz[1] = spi_sz;
	    }
	  else
	    spi_sz = 0;

	  proposal_lens[i] = ISAKMP_PROP_SPI_OFF + spi_sz;
	  proposals[i] = malloc (proposal_lens[i]);
	  if (!proposals[i])
	    {
	      log_error ("message_add_sa_payload: malloc (%lu) failed",
			 (unsigned long)proposal_lens[i]);
	      goto cleanup;
	    }

	  memcpy (transforms[i], proto->chosen->p, transform_lens[i]);
	  memcpy (proposals[i], proto->chosen->context->p,
		  ISAKMP_PROP_SPI_OFF);
	  SET_ISAKMP_PROP_NTRANSFORMS (proposals[i], 1);
	  SET_ISAKMP_PROP_SPI_SZ (proposals[i], spi_sz);
	  if (spi_sz)
	    memcpy (proposals[i] + ISAKMP_PROP_SPI_OFF, spi, spi_sz);
	  extra_sa_len += proposal_lens[i] + transform_lens[i];
	}

      /*
       * Add the payloads.  As this is a SA, we need to recompute the
       * lengths of the payloads containing others.  We also need to
       * reset these payload's "next payload type" field.
       */
      if (message_add_payload (msg, ISAKMP_PAYLOAD_SA, sa_buf, sa_len, 1))
	goto cleanup;
      SET_ISAKMP_GEN_LENGTH (sa_buf, sa_len + extra_sa_len);
      sa_buf = 0;

      saved_nextp_sa = msg->nextp;
      for (proto = TAILQ_FIRST (&sa->protos), i = 0; proto;
	   proto = TAILQ_NEXT (proto, link), i++)
	{
	  if (message_add_payload (msg, ISAKMP_PAYLOAD_PROPOSAL, proposals[i],
				   proposal_lens[i], i > 1))
	    goto cleanup;
	  SET_ISAKMP_GEN_LENGTH (proposals[i],
				 proposal_lens[i] + transform_lens[i]);
	  proposals[i] = 0;

	  saved_nextp_prop = msg->nextp;
	  if (message_add_payload (msg, ISAKMP_PAYLOAD_TRANSFORM,
				   transforms[i], transform_lens[i], 0))
	    goto cleanup;
	  msg->nextp = saved_nextp_prop;
	  transforms[i] = 0;
	}
      msg->nextp = saved_nextp_sa;

      /* Free the temporary allocations made above.  */
      free (transforms);
      free (transform_lens);
      free (proposals);
      free (proposal_lens);
    }
  return 0;

 cleanup:
  if (sa_buf)
    free (sa_buf);
  for (i = 0; i < nprotos; i++)
    {
      if (transforms[i])
	free (transforms[i]);
      if (proposals[i])
	free (proposals[i]);
    }
  if (transforms)
    free (transforms);
  if (transform_lens)
    free (transform_lens);
  if (proposals)
    free (proposals);
  if (proposal_lens)
    free (proposal_lens);
  return -1;
d2124 2
a2125 2
u_int8_t *
message_copy (struct message *msg, size_t offset, size_t *szp)
d2127 27
a2153 29
  int skip = 0;
  size_t i, sz = 0;
  ssize_t start = -1;
  u_int8_t *buf, *p;

  /* Calculate size of message and where we want to start to copy.  */
  for (i = 1; i < msg->iovlen; i++)
    {
      sz += msg->iov[i].iov_len;
      if (sz <= offset)
	skip = i;
      else if (start < 0)
	start = offset - (sz - msg->iov[i].iov_len);
    }

  /* Allocate and copy.  */
  *szp = sz - offset;
  buf = malloc (*szp);
  if (!buf)
    return 0;
  p = buf;
  for (i = skip + 1; i < msg->iovlen; i++)
    {
      memcpy (p, (u_int8_t *)msg->iov[i].iov_base + start,
	      msg->iov[i].iov_len - start);
      p += msg->iov[i].iov_len - start;
      start = 0;
    }
  return buf;
d2158 2
a2159 2
message_register_post_send (struct message *msg,
			    void (*post_send) (struct message *))
d2161 1
a2161 1
  struct post_send *node;
d2163 6
a2168 6
  node = malloc (sizeof *node);
  if (!node)
    return -1;
  node->func = post_send;
  TAILQ_INSERT_TAIL (&msg->post_send, node, link);
  return 0;
d2173 1
a2173 1
message_post_send (struct message *msg)
d2175 1
a2175 1
  struct post_send *node;
d2177 5
a2181 6
  while ((node = TAILQ_FIRST (&msg->post_send)) != 0)
    {
      TAILQ_REMOVE (&msg->post_send, node, link);
      node->func (msg);
      free (node);
    }
@


1.69
log
@Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.  Testing by markus@@ cloder@@ hshoexer@@.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.68 2004/03/10 16:10:57 hshoexer Exp $	*/
d125 1
a125 1
static int last_prop_no;
d127 1
a127 1
static int last_xf_no;
d193 1
a193 1
  int i;
d471 1
a471 1
  int i;
d1762 1
a1762 1
  int i, j, k = 0;
d1823 1
a1823 1
  size_t sz = 0;
a1824 1
  int i;
d2314 2
a2315 2
  int i, skip = 0;
  size_t sz = 0;
@


1.69.2.1
log
@MFC:
Fix by hshoexer@@

only accept DELETEs during an authenticated INFORMATIONAL exchange.
Fix for recent problem disclosed by Thomas Walpuski.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.69 2004/03/10 23:08:49 hshoexer Exp $	*/
a460 5
 *
 * Note:  DELETEs are only accepted as part of an INFORMATIONAL exchange.
 * exchange_validate() makes sure a HASH payload is present.  Due to the order
 * of message validation functions in message_validate_payload[] we can be
 * sure that the HASH payload has been successfully validated at this point.
d497 1
a497 8
  /* Only accept DELETE as part of an INFORMATIONAL exchange. */
  if (msg->exchange->type != ISAKMP_EXCH_INFO) {
	  log_print("message_validate_delete: delete in exchange other "
	     "than INFO: %s", constant_name(isakmp_exch_cst,
	     msg->exchange->type));
	  message_free(msg);
	  return -1;
  }
@


1.69.2.2
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@a478 7
  /* Only accpet authenticated DELETEs. */
  if ((msg->flags & MSG_AUTHENTICATED) == 0)
    {
      log_print("message_validate_delete: got unauthenticated DELETE");
      return -1;
    }

d582 1
a582 2
  /* active exchanges other than INFORMATIONAL validates hash payload. */
  if (msg->exchange && (msg->exchange->type != ISAKMP_EXCH_INFO))
d584 1
a584 1
 
a658 3

  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;
@


1.68
log
@Plug up memory leak.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.67 2004/03/10 11:17:38 hshoexer Exp $	*/
d113 7
d293 1
a293 1
       * Decode the payload length field.
d297 15
d899 2
a900 1
  if (exchange->doi->validate_situation (p->p + ISAKMP_SA_SIT_OFF, &len))
@


1.67
log
@Reduce some noise on receipt of an invalid spi.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.66 2004/03/09 21:42:02 hshoexer Exp $	*/
d1721 3
@


1.66
log
@Plug memleaks, found by cloder@@.

ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.65 2003/12/05 13:17:37 ho Exp $	*/
d506 2
a507 2
          log_print ("message_validate_delete: invalid spi "
		     "(no valid SA found)");
@


1.65
log
@Style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.64 2003/12/04 22:44:31 hshoexer Exp $	*/
d553 3
a555 2
       log_print ("message_validate_hash: invalid hash information");
       return -1;
d563 3
a565 2
       log_print ("message_validate_hash: invalid hash information");
       return -1;
d572 1
d581 4
a584 1
    return -1;
d590 1
a590 1
	        (unsigned long)hash->hashsize);
d592 1
d1266 1
@


1.64
log
@Validate SPIs presented in DELETE messages of the informational exchange.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.63 2003/11/06 16:12:07 ho Exp $	*/
d501 1
a501 3
        {
          sa = sa_lookup_isakmp_sa (dst, spis + i * ISAKMP_HDR_COOKIES_LEN);
        }
d503 1
a503 3
        {
          sa = ipsec_sa_lookup (dst, ((u_int32_t *)spis)[i], proto);
        }
d506 2
a507 1
          log_print ("message_validate_delete: invalid spi (no valid SA found)");
@


1.63
log
@Style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.62 2003/11/06 15:55:54 ho Exp $	*/
d445 6
d484 46
@


1.62
log
@Require encrypted messages are soon as we have the keystate for it.
Require DELETE payloads to be accompanied by HASHes, and add validation
for HASH payloads without active exchanges.
From Hans-Joerg Hoexer with various modifications and suggestions from me
and markus@@. Ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.61 2003/09/02 18:14:52 ho Exp $	*/
d1662 1
a1662 1
             address ? address : "<unknown>", htons(port),
@


1.61
log
@Require ISAKMP_FLAGS_ENC on phase 2 messages. ok markus@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.60 2003/06/14 11:47:13 ho Exp $	*/
d50 2
d56 1
d483 4
a486 1
 * Validate the hash payload P in message MSG.  */
d490 80
a569 1
  /* XXX Not implemented yet.  */
d1305 3
a1307 2
  /* Require encryption for any phase 2 message. XXX Always?  */
  if (msg->exchange->phase == 2 && (flags & ISAKMP_FLAGS_ENC) == 0)
d1309 2
a1310 1
      log_print ("message_recv: cleartext phase 2 message");
@


1.61.2.1
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.61 2003/09/02 18:14:52 ho Exp $	*/
a49 2
#include "hash.h"
#include "ipsec.h"
a53 1
#include "prf.h"
a441 6
  struct sa *sa, *isakmp_sa;
  struct sockaddr *dst, *dst_isa;
  u_int32_t nspis = GET_ISAKMP_DELETE_NSPIS (p->p);
  u_int8_t *spis = (u_int8_t *)p->p + ISAKMP_DELETE_SPI_OFF;
  int i;
  char *addr;
a474 43
  for (i = 0; i < nspis; i++)
    {
      /* Get ISAKMP SA protecting this message. */
      isakmp_sa = msg->isakmp_sa;
      if (!isakmp_sa)
        {
          /* XXX should not happen? */
          log_print ("message_validate_delete: invalid spi "
                     "(no valid ISAKMP SA found)");
          message_free (msg);
          return -1;
        }
      isakmp_sa->transport->vtbl->get_dst (isakmp_sa->transport, &dst_isa);

      /* Get SA to be deleted. */
      msg->transport->vtbl->get_dst (msg->transport, &dst);
      if (proto == ISAKMP_PROTO_ISAKMP)
	sa = sa_lookup_isakmp_sa (dst, spis + i * ISAKMP_HDR_COOKIES_LEN);
      else
	sa = ipsec_sa_lookup (dst, ((u_int32_t *)spis)[i], proto);
      if (!sa)
        {
          log_print ("message_validate_delete: invalid spi "
		     "(no valid SA found)");
          message_free (msg);
          return -1;
        }
      sa->transport->vtbl->get_dst (sa->transport, &dst);

      /* Destination addresses must match. */
      if (dst->sa_family != dst_isa->sa_family ||
          memcmp (sockaddr_addrdata (dst_isa), sockaddr_addrdata (dst),
                  sockaddr_addrlen (dst)))
        {
          sockaddr2text (dst_isa, &addr, 0);

          log_print ("message_validate_delete: invalid spi "
                     "(illegal delete request from %s)", addr);
          free (addr);
          message_free (msg);
          return -1;
        }
    }
d480 1
a480 4
 * Validate the hash payload P in message MSG.
 * XXX Currently hash payloads are processed by the particular exchanges,
 * except INFORMATIONAL.  This should be actually done here.
 */
d484 1
a484 80
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct hash *hash;
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  struct prf *prf;
  u_int8_t *comp_hash, *rest;
  u_int8_t message_id[ISAKMP_HDR_MESSAGE_ID_LEN];
  size_t rest_len;

  if (msg->exchange)	/* active exchange validates hash payload. */
    return 0;

  if (isakmp_sa == NULL)
    {
       log_print ("message_validate_hash: invalid hash information");
       return -1;
    }

  isa = isakmp_sa->data;
  hash = hash_get (isa->hash);

  if (hash == NULL)
    {
       log_print ("message_validate_hash: invalid hash information");
       return -1;
    }

  /* If no SKEYID_a, we can not do anything (should not happen).  */
  if (!isa->skeyid_a)
    {
      log_print ("message_validate_hash: invalid hash information");
      return -1;
    }

  /* Allocate the prf and start calculating our HASH(1). */
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  comp_hash = (u_int8_t *)malloc (hash->hashsize);
  if (!comp_hash)
    {
      log_error ("message_validate_hash: malloc (%lu) failed",
	        (unsigned long)hash->hashsize);
      prf_free (prf);
      return -1;
    }

  /* This is not an active exchange. */
  GET_ISAKMP_HDR_MESSAGE_ID (msg->iov[0].iov_base, message_id);

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: message_id",
		message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  rest = hashp->p + GET_ISAKMP_GEN_LENGTH (hashp->p);
  rest_len = (GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base)
	        - (rest - (u_int8_t*)msg->iov[0].iov_base));
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: payloads after HASH(1)",
		rest, rest_len));
  prf->Update (prf->prfctx, rest, rest_len);
  prf->Final (comp_hash, prf->prfctx);
  prf_free (prf);

  if (memcmp (hashp->p + ISAKMP_HASH_DATA_OFF, comp_hash, hash->hashsize))
    {
      log_print ("message_validate_hash: invalid hash value for %s payload",
		 TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])
		 ? "DELETE" : "NOTIFY");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      free (comp_hash);
      return -1;
    }
  free (comp_hash);

  /* Mark the HASH as handled. */
  hashp->flags |= PL_MARK;

d1220 2
a1221 3
  /* Require encryption as soon as we have the keystate for it.  */
  if ((flags & ISAKMP_FLAGS_ENC) == 0 &&
      (msg->exchange->phase == 2 || msg->exchange->keystate))
d1223 1
a1223 2
      log_print ("message_recv: cleartext phase %d message",
		 msg->exchange->phase);
@


1.61.2.2
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.61.2.1 2004/01/13 22:50:07 brad Exp $	*/
a112 7
static u_int16_t min_payload_lengths[] = {
  0, ISAKMP_SA_SZ, ISAKMP_PROP_SZ, ISAKMP_TRANSFORM_SZ, ISAKMP_KE_SZ,
  ISAKMP_ID_SZ, ISAKMP_CERT_SZ, ISAKMP_CERTREQ_SZ, ISAKMP_HASH_SZ,
  ISAKMP_SIG_SZ, ISAKMP_NONCE_SZ, ISAKMP_NOTIFY_SZ, ISAKMP_DELETE_SZ,
  ISAKMP_VENDOR_SZ, ISAKMP_ATTRIBUTE_SZ
};

d286 1
a286 1
       * Decode and validate the payload length field.
a289 15
      if ((payload < ISAKMP_PAYLOAD_RESERVED_MIN)
	   && (len < min_payload_lengths[payload]))
	{
	  log_print ("message_parse_payloads: payload too short: %u", len);
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}
  
      if (buf + len > (u_int8_t *)msg->iov[0].iov_base + msg->iov[0].iov_len)
	{
	  log_print ("message_parse_payloads: payload too long: %u", len);
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}

d553 2
a554 3
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
d562 2
a563 3
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
a569 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
d578 1
a578 4
    {
      message_free (msg);
      return -1;
    }
a585 1
      message_free (msg);
d870 1
a870 2
  if (exchange->doi->validate_situation (p->p + ISAKMP_SA_SIT_OFF, &len,
      GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SA_SIT_OFF))
a1258 1
	  message_free (msg);
a1712 3

  if (address)
    free (address);
@


1.61.2.3
log
@MFC:
Fix by hshoexer@@

only accept DELETEs during an authenticated INFORMATIONAL exchange.
Fix for recent problem disclosed by Thomas Walpuski.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.61.2.2 2004/03/17 14:59:18 brad Exp $	*/
a460 5
 *
 * Note:  DELETEs are only accepted as part of an INFORMATIONAL exchange.
 * exchange_validate() makes sure a HASH payload is present.  Due to the order
 * of message validation functions in message_validate_payload[] we can be
 * sure that the HASH payload has been successfully validated at this point.
d497 1
a497 8
  /* Only accept DELETE as part of an INFORMATIONAL exchange. */
  if (msg->exchange->type != ISAKMP_EXCH_INFO) {
	  log_print("message_validate_delete: delete in exchange other "
	     "than INFO: %s", constant_name(isakmp_exch_cst,
	     msg->exchange->type));
	  message_free(msg);
	  return -1;
  }
@


1.61.2.4
log
@MFC:
Fix by hshoexer@@

Mark authenticated messages explicitly.  Better check for authentication before
deleteing SAs.

This fix is needed to solve the problems reported by Thomas Walpuski, previous
diff was not sufficient.  Pointed out by Thomas.  Thanks!
@
text
@a478 7
  /* Only accpet authenticated DELETEs. */
  if ((msg->flags & MSG_AUTHENTICATED) == 0)
    {
      log_print("message_validate_delete: got unauthenticated DELETE");
      return -1;
    }

d582 1
a582 2
  /* active exchanges other than INFORMATIONAL validates hash payload. */
  if (msg->exchange && (msg->exchange->type != ISAKMP_EXCH_INFO))
d584 1
a584 1
 
a658 3

  /* Mark message as authenticated. */
  msg->flags |= MSG_AUTHENTICATED;
@


1.60
log
@allocate payload_node with calloc instead of malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.59 2003/06/04 07:31:17 ho Exp $	*/
d1219 8
@


1.59
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.58 2003/06/03 12:51:39 ho Exp $	*/
d1341 1
a1341 1
  payload_node = malloc (sizeof *payload_node);
d1344 1
a1344 1
      log_error ("message_add_payload: malloc (%lu) failed",
@


1.58
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.57 2002/09/11 09:50:44 ho Exp $	*/
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.57
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.56 2002/07/09 14:31:45 ho Exp $	*/
d1597 1
a1597 1
	snprintf (p, 80 - (int)(p - buf), "%02x",
@


1.57.4.1
log
@Fixes a few message handling flaws in isakmpd as reported by
Thomas Walpuski.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.57 2002/09/11 09:50:44 ho Exp $	*/
a54 2
#include "hash.h"
#include "ipsec.h"
a58 1
#include "prf.h"
a446 6
  struct sa *sa, *isakmp_sa;
  struct sockaddr *dst, *dst_isa;
  u_int32_t nspis = GET_ISAKMP_DELETE_NSPIS (p->p);
  u_int8_t *spis = (u_int8_t *)p->p + ISAKMP_DELETE_SPI_OFF;
  int i;
  char *addr;
a479 43
  for (i = 0; i < nspis; i++)
    {
      /* Get ISAKMP SA protecting this message. */
      isakmp_sa = msg->isakmp_sa;
      if (!isakmp_sa)
        {
          /* XXX should not happen? */
          log_print ("message_validate_delete: invalid spi "
                     "(no valid ISAKMP SA found)");
          message_free (msg);
          return -1;
        }
      isakmp_sa->transport->vtbl->get_dst (isakmp_sa->transport, &dst_isa);

      /* Get SA to be deleted. */
      msg->transport->vtbl->get_dst (msg->transport, &dst);
      if (proto == ISAKMP_PROTO_ISAKMP)
	sa = sa_lookup_isakmp_sa (dst, spis + i * ISAKMP_HDR_COOKIES_LEN);
      else
	sa = ipsec_sa_lookup (dst, ((u_int32_t *)spis)[i], proto);
      if (!sa)
        {
          log_print ("message_validate_delete: invalid spi "
		     "(no valid SA found)");
          message_free (msg);
          return -1;
        }
      sa->transport->vtbl->get_dst (sa->transport, &dst);

      /* Destination addresses must match. */
      if (dst->sa_family != dst_isa->sa_family ||
          memcmp (sockaddr_addrdata (dst_isa), sockaddr_addrdata (dst),
                  sockaddr_addrlen (dst)))
        {
          sockaddr2text (dst_isa, &addr, 0);

          log_print ("message_validate_delete: invalid spi "
                     "(illegal delete request from %s)", addr);
          free (addr);
          message_free (msg);
          return -1;
        }
    }
d485 1
a485 4
 * Validate the hash payload P in message MSG.
 * XXX Currently hash payloads are processed by the particular exchanges,
 * except INFORMATIONAL.  This should be actually done here.
 */
d489 1
a489 80
  struct sa *isakmp_sa = msg->isakmp_sa;
  struct ipsec_sa *isa;
  struct hash *hash;
  struct payload *hashp = TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_HASH]);
  struct prf *prf;
  u_int8_t *comp_hash, *rest;
  u_int8_t message_id[ISAKMP_HDR_MESSAGE_ID_LEN];
  size_t rest_len;

  if (msg->exchange)	/* active exchange validates hash payload. */
    return 0;

  if (isakmp_sa == NULL)
    {
       log_print ("message_validate_hash: invalid hash information");
       return -1;
    }

  isa = isakmp_sa->data;
  hash = hash_get (isa->hash);

  if (hash == NULL)
    {
       log_print ("message_validate_hash: invalid hash information");
       return -1;
    }

  /* If no SKEYID_a, we can not do anything (should not happen).  */
  if (!isa->skeyid_a)
    {
      log_print ("message_validate_hash: invalid hash information");
      return -1;
    }

  /* Allocate the prf and start calculating our HASH(1). */
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: SKEYID_a", isa->skeyid_a,
		isa->skeyid_len));
  prf = prf_alloc (isa->prf_type, hash->type, isa->skeyid_a, isa->skeyid_len);
  if (!prf)
    return -1;

  comp_hash = (u_int8_t *)malloc (hash->hashsize);
  if (!comp_hash)
    {
      log_error ("message_validate_hash: malloc (%lu) failed",
	        (unsigned long)hash->hashsize);
      prf_free (prf);
      return -1;
    }

  /* This is not an active exchange. */
  GET_ISAKMP_HDR_MESSAGE_ID (msg->iov[0].iov_base, message_id);

  prf->Init (prf->prfctx);
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: message_id",
		message_id, ISAKMP_HDR_MESSAGE_ID_LEN));
  prf->Update (prf->prfctx, message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  rest = hashp->p + GET_ISAKMP_GEN_LENGTH (hashp->p);
  rest_len = (GET_ISAKMP_HDR_LENGTH (msg->iov[0].iov_base)
	        - (rest - (u_int8_t*)msg->iov[0].iov_base));
  LOG_DBG_BUF ((LOG_MISC, 90, "message_validate_hash: payloads after HASH(1)",
		rest, rest_len));
  prf->Update (prf->prfctx, rest, rest_len);
  prf->Final (comp_hash, prf->prfctx);
  prf_free (prf);

  if (memcmp (hashp->p + ISAKMP_HASH_DATA_OFF, comp_hash, hash->hashsize))
    {
      log_print ("message_validate_hash: invalid hash value for %s payload",
		 TAILQ_FIRST (&msg->payload[ISAKMP_PAYLOAD_DELETE])
		 ? "DELETE" : "NOTIFY");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 0);
      free (comp_hash);
      return -1;
    }
  free (comp_hash);

  /* Mark the HASH as handled. */
  hashp->flags |= PL_MARK;

a1223 10

  /* Require encryption as soon as we have the keystate for it.  */
  if ((flags & ISAKMP_FLAGS_ENC) == 0 &&
      (msg->exchange->phase == 2 || msg->exchange->keystate))
    {
      log_print ("message_recv: cleartext phase %d message",
                 msg->exchange->phase);
      message_drop (msg, ISAKMP_NOTIFY_INVALID_FLAGS, 0, 1, 1);
      return -1;
    }
@


1.57.4.2
log
@MFC:
Fix by hshoexer@@

Fix payload handling flaws found by cloder@@.  Based on initial patch by
cloder@@.

ok deraadt@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.57.4.1 2004/01/16 00:00:21 brad Exp $	*/
a117 7
static u_int16_t min_payload_lengths[] = {
  0, ISAKMP_SA_SZ, ISAKMP_PROP_SZ, ISAKMP_TRANSFORM_SZ, ISAKMP_KE_SZ,
  ISAKMP_ID_SZ, ISAKMP_CERT_SZ, ISAKMP_CERTREQ_SZ, ISAKMP_HASH_SZ,
  ISAKMP_SIG_SZ, ISAKMP_NONCE_SZ, ISAKMP_NOTIFY_SZ, ISAKMP_DELETE_SZ,
  ISAKMP_VENDOR_SZ, ISAKMP_ATTRIBUTE_SZ
};

d291 1
a291 1
       * Decode and validate the payload length field.
a294 15
      if ((payload < ISAKMP_PAYLOAD_RESERVED_MIN)
	   && (len < min_payload_lengths[payload]))
	{
	  log_print ("message_parse_payloads: payload too short: %u", len);
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}
  
      if (buf + len > (u_int8_t *)msg->iov[0].iov_base + msg->iov[0].iov_len)
	{
	  log_print ("message_parse_payloads: payload too long: %u", len);
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
	  return -1;
	}

d558 2
a559 3
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
d567 2
a568 3
      log_print ("message_validate_hash: invalid hash information");
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
      return -1;
a574 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_HASH_INFORMATION, 0, 1, 1);
d583 1
a583 4
    {
      message_free (msg);
      return -1;
    }
a590 1
      message_free (msg);
d875 1
a875 2
  if (exchange->doi->validate_situation (p->p + ISAKMP_SA_SIT_OFF, &len,
      GET_ISAKMP_GEN_LENGTH (p->p) - ISAKMP_SA_SIT_OFF))
a1263 1
	  message_free (msg);
a1717 3

  if (address)
    free (address);
@


1.56
log
@HASH payload validation does not require an exchange.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.55 2002/07/04 22:23:49 ho Exp $	*/
d157 1
a157 1
  msg->nextp = msg->iov[0].iov_base + ISAKMP_HDR_NEXT_PAYLOAD_OFF;
d382 2
a383 2
      if (zero_test (msg->iov[0].iov_base + ISAKMP_HDR_MESSAGE_ID_OFF,
		     ISAKMP_HDR_MESSAGE_ID_LEN))
d459 2
a460 2
      if (zero_test (msg->iov[0].iov_base + ISAKMP_HDR_MESSAGE_ID_OFF,
		     ISAKMP_HDR_MESSAGE_ID_LEN))
d584 2
a585 2
      if (zero_test (msg->iov[0].iov_base + ISAKMP_HDR_MESSAGE_ID_OFF,
		     ISAKMP_HDR_MESSAGE_ID_LEN))
d896 4
a899 3
  sz = message_parse_payloads (msg, 0, next,
			       msg->iov[0].iov_base + ISAKMP_HDR_SZ,
			       &payload_set, message_index_payload);
d2165 2
a2166 1
      memcpy (p, msg->iov[i].iov_base + start, msg->iov[i].iov_len - start);
@


1.55
log
@Do not assume we have an active exchange during payload validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.54 2002/06/09 08:13:06 todd Exp $	*/
a488 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_hash: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

@


1.54
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.53 2002/06/06 02:42:29 ho Exp $	*/
d489 8
d508 8
d536 8
d558 8
d638 8
d775 8
d794 8
d846 8
@


1.53
log
@better format/type
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.52 2002/06/06 02:15:27 ho Exp $	*/
d1232 1
a1232 1
  
d1238 1
a1238 1
  q = msg->flags & MSG_PRIORITIZED ? &msg->transport->prio_sendq : 
d1540 1
a1540 1
	snprintf (p, 80 - (int)(p - buf), "%02x", 
@


1.52
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.51 2002/06/01 07:44:21 deraadt Exp $	*/
d251 2
a252 2
		"message_parse_payloads: offset %d payload %s",
		buf - (u_int8_t *)msg->iov[0].iov_base,
@


1.51
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.50 2002/05/28 10:09:46 ho Exp $	*/
d251 1
a251 1
		"message_parse_payloads: offset %p payload %s",
@


1.50
log
@Proper types in format strings. From <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.49 2002/03/26 13:19:28 ho Exp $	*/
d251 1
a251 1
		"message_parse_payloads: offset 0x%x payload %s",
d1292 2
a1293 2
      log_error ("message_add_payload: malloc (%d) failed",
		 sizeof *payload_node);
d1300 2
a1301 2
      log_error ("message_add_payload: realloc (%p, %d) failed", msg->iov,
		 (msg->iovlen + 1) * sizeof *msg->iov);
d1431 1
a1431 1
      log_error ("message_send_info: calloc (1, %d) failed", sz);
d1612 2
a1613 2
      log_error ("message_encrypt: realloc (%p, %d) failed",
		 msg->iov[1].iov_base, sz);
d1925 2
a1926 1
	  log_error ("message_add_sa_payload: malloc (%d) failed", sa_len);
d1943 2
a1944 2
	  log_error ("message_add_sa_payload: calloc (%d, %d) failed", nprotos,
		     sizeof *transforms);
d1951 2
a1952 2
	  log_error ("message_add_sa_payload: calloc (%d, %d) failed", nprotos,
		     sizeof *transform_lens);
d1959 2
a1960 2
	  log_error ("message_add_sa_payload: calloc (%d, %d) failed", nprotos,
		     sizeof *proposals);
d1967 2
a1968 2
	  log_error ("message_add_sa_payload: calloc (%d, %d) failed", nprotos,
		     sizeof *proposal_lens);
d1980 2
a1981 2
	      log_error ("message_add_sa_payload: malloc (%d) failed",
			 transform_lens[i]);
d2004 2
a2005 2
	      log_error ("message_add_sa_payload: malloc (%d) failed",
			 proposal_lens[i]);
@


1.49
log
@Don't message_dump_raw() bad length messages, i.e too short.
Should solve PR 2474 (unconfirmed). niklas@@, me.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.48 2002/01/23 18:44:47 ho Exp $	*/
d1658 1
a1658 1
  LOG_DBG ((LOG_MESSAGE, 90, "message_check_duplicate: last_received 0x%x",
@


1.49.2.1
log
@Pull in patch from current:
Fix (ho), errata 010:
Do not assume we have an active exchange during payload validation.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.49 2002/03/26 13:19:28 ho Exp $	*/
a488 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_hash: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a499 8
  if (!exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_id: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a519 8
  if (!exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_key_exch: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a533 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_nonce: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a605 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_proposal: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a734 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_sig: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a745 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_transform: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a789 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_vendor: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

@


1.49.2.2
log
@Pull in patch from current:
Fix (ho), revised errata:
HASH payload validation does not require an exchange.
Reported by Toni Mueller <support@@oeko.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.49.2.1 2002/07/06 22:01:38 jason Exp $	*/
d489 8
@


1.48
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.47 2001/10/26 13:29:26 ho Exp $	*/
a887 5
#ifdef USE_DEBUG
  /* Possibly dump a raw hex image of the message to the log channel.  */
  message_dump_raw ("message_recv", msg, LOG_MESSAGE);
#endif

d895 5
@


1.47
log
@Change to use sysdep_sa_len() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.46 2001/10/26 11:37:16 ho Exp $	*/
d888 1
d891 1
d1227 1
d1229 1
d1540 2
a1541 1
	sprintf (p, "%02x", ((u_int8_t *)msg->iov[i].iov_base)[j]);
@


1.46
log
@Sometimes the daemon will not die promptly on SIGTERM, even though
all DELETE notifications is sent out.  Create a prioritized send-queue
for the DELETE messages to solve this. Some (C)-2001.
niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.45 2001/07/01 20:43:39 niklas Exp $	*/
d1385 1
a1385 1
  isakmp_sa = sa_isakmp_lookup_by_peer (dst, dst->sa_len);
@


1.45
log
@ISAKMP configuration, a.k.a IKECFG or "mode-config", protocol implementation.
Disabled, has no configuration mechanism yet.  This will be used for roaming
users, who are going to get parameters like IP-address and nameserver from its
peer, very much like DHCP, but securily inside an ISAKMP connection and still
in time before negotiation of IPsec connections.  You may see stylistic fixes
in this commit too.  Add some not yet used Makefile magic to deal with DNSSEC-
enabled OpenSSL too.  The IKECFG code work was sponsered by Gatespace Inc.
Thank you!  Configuration will come very soon, btw.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.44 2001/07/01 06:10:34 angelos Exp $	*/
d7 1
a7 1
 * Copyright (c) 1999, 2000 Håkan Olsson.  All rights reserved.
d216 6
a221 1
    TAILQ_REMOVE (&msg->transport->sendq, msg, link);
d1186 1
d1234 4
a1237 1
  for (m = TAILQ_FIRST (&msg->transport->sendq); m; m = TAILQ_NEXT (m, link))
d1240 2
a1241 2
	LOG_DBG ((LOG_MESSAGE, 60, "message_send: msg %p already on sendq", 
		  m));
d1245 1
a1245 1
  TAILQ_INSERT_TAIL (&msg->transport->sendq, msg, link);
d1454 1
d1687 6
a1692 2
	  TAILQ_REMOVE (&exchange->in_transit->transport->sendq,
			exchange->in_transit, link);
@


1.45.2.1
log
@Pull in patch from current:
Errata 017:
isakmpd(8) will crash when receiving a zero length IKE packet due to a too-late length check.
Fix (ho):
Don't message_dump_raw() bad length messages, i.e too short.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.45 2001/07/01 20:43:39 niklas Exp $	*/
d883 3
a892 5

#ifdef USE_DEBUG
  /* Possibly dump a raw hex image of the message to the log channel.  */
  message_dump_raw ("message_recv", msg, LOG_MESSAGE);
#endif
@


1.45.2.2
log
@Errata #027:
Receiving IKE payloads out of sequence can cause isakmpd to crash.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.45.2.1 2002/03/27 04:24:22 jason Exp $	*/
a483 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_hash: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a494 8
  if (!exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_id: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a514 8
  if (!exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_key_exch: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a528 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_nonce: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a600 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_proposal: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a729 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_sig: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a740 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_transform: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

a784 8
  if (!msg->exchange)
    {
      /* We should have an exchange at this point.  */
      log_print ("message_validate_vendor: payload out of sequence");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 1, 1);
      return -1;
    }

@


1.45.2.3
log
@Revised errata #027:
HASH payload validation does not require an exchange.
Reported by Toni Mueller <support@@oeko.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.45.2.2 2002/07/05 16:03:10 miod Exp $	*/
d484 8
@


1.44
log
@Eliminate IPv4 dependency.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.43 2001/06/29 18:52:17 ho Exp $	*/
d55 1
d82 1
d105 1
a105 1
  message_validate_vendor
d112 1
a112 1
  isakmp_vendor_fld
d369 24
d1062 1
a1062 1
      if (msg->isakmp_sa == NULL)
@


1.43
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.42 2001/04/24 07:27:37 niklas Exp $	*/
d1452 2
d1456 17
a1473 1
  /* XXX Assumes IPv4.  */
d1475 1
a1475 2
	     inet_ntoa (((struct sockaddr_in *)dst)->sin_addr),
	     ntohs (((struct sockaddr_in *)dst)->sin_port),
@


1.42
log
@Correct SA refcounting.  Fixes a bug where isakmpd could die when a peer was
discovered to have rebooted, and old now invalid SAs had to be garbage-
collected.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.41 2001/04/14 01:25:34 ho Exp $	*/
a1347 1
  socklen_t dstlen;
d1349 2
a1350 2
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  isakmp_sa = sa_isakmp_lookup_by_peer (dst, dstlen);
a1451 1
  int dst_len;
d1453 1
a1453 1
  t->vtbl->get_dst (t, &dst, &dst_len);
a1503 1
  int srclen, dstlen;
d1512 2
a1513 2
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
      msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
d1517 2
a1518 2
      msg->transport->vtbl->get_src (msg->transport, &dst, &dstlen);
      msg->transport->vtbl->get_dst (msg->transport, &src, &srclen);
@


1.41
log
@Minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.40 2001/04/12 15:48:37 ho Exp $	*/
d176 1
a178 1
  reply->isakmp_sa = msg->isakmp_sa;
@


1.40
log
@Don't put the same message on the sendq twice. By niklas and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.39 2001/04/09 22:09:52 ho Exp $	*/
a187 1
  struct post_send *node;
d209 1
a209 1
  while ((node = TAILQ_FIRST (&msg->post_send)) != 0)
@


1.39
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.38 2001/04/09 21:21:57 ho Exp $	*/
d1155 1
d1197 14
@


1.38
log
@isakmpd can now capture un-encrypted IKE negotiation packets to a
file. In pcap(3) format, so tcpdump(8) can read it.
Idea by Tim Newsham <newsham@@lava.net>, work by him and me.
Ok angelos@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.37 2001/03/13 14:05:19 ho Exp $	*/
d672 1
a672 1
        sa_reference(msg->isakmp_sa);
d902 1
a902 1
        sa_reference(msg->isakmp_sa);
d1471 1
a1471 1
	sprintf(p, "%02x", ((u_int8_t *)msg->iov[i].iov_base)[j]);
@


1.37
log
@Add logging classes for Negotiation and Policy, and change a number of
debug messages to use these instead. Change a number of 'log_print'
to debug messages to keep the noise down. Use 'log_error' instead of
'log_print' in some cases when we have errno. Some indentation fixes.
(niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.36 2001/01/27 12:03:34 niklas Exp $	*/
d95 2
d1065 3
d1163 3
d1485 27
@


1.36
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.35 2001/01/26 12:12:52 niklas Exp $	*/
d1665 1
a1665 1
	  LOG_DBG ((LOG_MESSAGE, 30,
d1695 1
a1695 1
	      LOG_DBG ((LOG_MESSAGE, 30,
d1728 1
a1728 1
		  LOG_DBG ((LOG_MESSAGE, 30,
d1741 1
a1741 1
		  LOG_DBG ((LOG_MESSAGE, 30,
@


1.35
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.34 2000/10/10 13:35:11 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
@


1.34
log
@message.c: Merge with EOM 1.156
message.h: Merge with EOM 1.51
transport.c: Merge with EOM 1.43

author: provos
use message_send_expire for timeouts. okay niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.33 2000/10/07 07:00:20 niklas Exp $	*/
d284 1
a284 1
      /* Ignore private payloads. */
d946 3
a948 1
      log_print ("message_recv: invalid payload type %d in ISAKMP header (check  passphrases, if applicable and in Phase 1)",
@


1.34.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.42 2001/04/24 07:27:37 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
a94 2
static void message_packet_log (struct message *);

a173 1
  reply->isakmp_sa = msg->isakmp_sa;
d176 1
d186 1
d208 1
a208 1
  while (TAILQ_FIRST (&msg->post_send) != 0)
d284 1
a284 1
      /* Ignore private payloads.  */
d670 1
a670 1
        sa_reference (msg->isakmp_sa);
d900 1
a900 1
        sa_reference (msg->isakmp_sa);
d946 1
a946 3
      log_print ("message_recv: "
		 "invalid payload type %d in ISAKMP header "
		 "(check passphrases, if applicable and in Phase 1)",
a1060 3
  /* IKE packet capture */
  message_packet_log (msg);

a1147 1
  struct message *m;
a1155 3
  /* IKE packet capture */
  message_packet_log (msg);

a1185 14
  
  /*
   * If we get a retransmission of a message before our response
   * has left the queue, don't queue it again, as it will result
   * in a circular list.
   */
  for (m = TAILQ_FIRST (&msg->transport->sendq); m; m = TAILQ_NEXT (m, link))
    if (m == msg)
      {
	LOG_DBG ((LOG_MESSAGE, 60, "message_send: msg %p already on sendq", 
		  m));
	return;
      }

d1461 1
a1461 1
	sprintf (p, "%02x", ((u_int8_t *)msg->iov[i].iov_base)[j]);
a1476 27
static void
message_packet_log (struct message *msg)
{
#ifdef USE_DEBUG
  struct sockaddr *src, *dst;
  int srclen, dstlen;

  /* Don't log retransmissions. Redundant for incoming packets... */
  if (msg->xmits > 0)
    return;

  /* Figure out direction. */
  if (msg->exchange && msg->exchange->initiator ^ (msg->exchange->step % 2))
    {
      msg->transport->vtbl->get_src (msg->transport, &src, &srclen);
      msg->transport->vtbl->get_dst (msg->transport, &dst, &dstlen);
    }
  else
    {
      msg->transport->vtbl->get_src (msg->transport, &dst, &dstlen);
      msg->transport->vtbl->get_dst (msg->transport, &src, &srclen);
    }

  log_packet_iov (src, dst, msg->iov, msg->iovlen);
#endif /* USE_DEBUG */
}

d1663 1
a1663 1
	  LOG_DBG ((LOG_NEGOTIATION, 30,
d1693 1
a1693 1
	      LOG_DBG ((LOG_NEGOTIATION, 30,
d1726 1
a1726 1
		  LOG_DBG ((LOG_NEGOTIATION, 30,
d1739 1
a1739 1
		  LOG_DBG ((LOG_NEGOTIATION, 30,
@


1.33
log
@Merge with EOM 1.155

author: niklas
style

author: niklas
spelling

author: ho
(c)-2000

author: niklas
style

author: provos
fail if exchange can not be created

author: angelos
Invalid payload may be because of passphrase mismatch, so warn about that.

author: provos
reference to freed object, move free down

author: ho
log_debug -> LOG_DBG (USE_DEBUG)

author: provos
proper reference counting for isakmp_sa in struct message, remove bogus
calls to sa_reference; fix some more memory leaks in conf.c
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.32 2000/08/03 07:23:10 niklas Exp $	*/
/*	$EOM: message.c,v 1.155 2000/10/06 23:55:42 niklas Exp $	*/
d273 2
a274 1
	  log_print ("message_parse_payloads: reserved field non-zero");
d1135 8
d1149 6
a1154 2
  /* Reset the retransmission event.  */
  msg->retrans = 0;
@


1.32
log
@Merge with EOM 1.146

author: provos
prevent crashing when we receive an encrypted message as response to
our first packet as initiator. James Winquist <winquist@@mail.cybernet.com>
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.31 2000/06/19 02:25:44 niklas Exp $	*/
/*	$EOM: message.c,v 1.146 2000/08/02 22:37:43 provos Exp $	*/
d7 1
d164 1
a164 1
 * Allocate a message sutiable for a reply to MSG.  Just allocate an empty
d174 2
d201 1
a201 1
      timer_remove_event (msg->retrans);
d216 3
d261 1
a261 1
      if (next >= ISAKMP_PAYLOAD_RESERVED_MIN && 
d286 3
a288 3
	  log_debug (LOG_MESSAGE, 30, 
		     "message_parse_payloads: private next payload type %d "
		     "in payload of type %d ignored", next, payload);
d390 1
a390 1
  /* 
d431 6
d532 6
d666 5
a670 1
    msg->isakmp_sa = TAILQ_FIRST (&exchange->sa_list);
d898 2
d945 1
a945 1
      log_print ("message_recv: invalid payload type %d in ISAKMP header",
d1032 1
a1032 1
      if (msg->isakmp_sa == NULL) 
a1570 1
      message_free (exchange->last_sent);
d1577 1
d1687 1
a1687 1
	      
d1707 1
a1707 1
	   * it against the accepted ones. 
d1727 1
a1727 1
			    "message_negotiate_sa: proposal %d failed", 
@


1.31
log
@Merge with EOM 1.145

author: ho
Recognize and handle reserved and private payloads differently.
A private payload in a message is ignored.
A message containing a reserved payload is dropped.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.30 2000/02/25 17:23:41 niklas Exp $	*/
/*	$EOM: message.c,v 1.145 2000/06/13 16:25:10 ho Exp $	*/
d1008 7
@


1.30
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.29 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: message.c,v 1.144 2000/02/20 19:58:40 niklas Exp $	*/
d255 2
a256 1
      if (next >= ISAKMP_PAYLOAD_RESERVED_MIN)
d277 9
d302 1
@


1.29
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.28 2000/01/31 08:38:28 niklas Exp $	*/
/*	$EOM: message.c,v 1.143 2000/01/31 22:33:47 niklas Exp $	*/
d158 1
a158 1
  log_debug (LOG_MESSAGE, 90, "message_alloc: allocated %p", msg);
d185 1
a185 1
  log_debug (LOG_MESSAGE, 20, "message_free: freeing %p", msg);
d236 4
a239 4
      log_debug (LOG_MESSAGE, 50,
		 "message_parse_payloads: offset 0x%x payload %s",
		 buf - (u_int8_t *)msg->iov[0].iov_base,
		 constant_name (isakmp_payload_cst, next));
d337 3
a339 2
  log_debug (LOG_MESSAGE, 50, "Transform %d's attributes",
	     GET_ISAKMP_TRANSFORM_NO (buf));
d343 1
d731 1
a731 1
  log_debug (LOG_MESSAGE, 40, "message_validate_vendor: vendor ID seen");
d794 4
a797 3
	log_debug (LOG_MESSAGE, 60,
		   "message_validate_payloads: payload %s at %p of message %p",
		   constant_name (isakmp_payload_cst, i), p->p, msg);
d856 2
a857 2
	  log_debug (LOG_MESSAGE, 90,
		     "message_recv: dropping setup for existing SA");
d989 2
a990 2
	  log_debug (LOG_MESSAGE, 80,
		     "message_recv: resending last message from phase 1");
d1401 1
a1401 1
  log_debug (class, 70, "%s: message %p", header, msg);
d1411 1
a1411 1
	    log_debug (class, 70, "%s: %s", header, buf);
d1419 1
a1419 1
    log_debug (class, 70, "%s: %s", header, buf);
d1497 2
a1498 2
  log_debug (LOG_MESSAGE, 90, "message_check_duplicate: last_received 0x%x",
	     exchange->last_received);
d1501 4
a1504 3
      log_debug_buf (LOG_MESSAGE, 95, "message_check_duplicate: last_received",
		     exchange->last_received->orig,
		     exchange->last_received->orig_sz);
d1509 2
a1510 1
	  log_debug (LOG_MESSAGE, 80, "message_check_duplicate: dropping dup");
d1608 6
a1613 6
	  log_debug (LOG_MESSAGE, 30,
		     "message_negotiate_sa: "
		     "transform %d proto %d proposal %d ok",
		     GET_ISAKMP_TRANSFORM_NO (tp->p),
		     GET_ISAKMP_PROP_PROTO (propp->p),
		     GET_ISAKMP_PROP_NO (propp->p));
d1638 4
a1641 4
	      log_debug (LOG_MESSAGE, 30,
			 "message_negotiate_sa: proto %d proposal %d failed",
			 GET_ISAKMP_PROP_PROTO (propp->p),
			 GET_ISAKMP_PROP_NO (propp->p));
d1671 3
a1673 3
		  log_debug (LOG_MESSAGE, 30,
			     "message_negotiate_sa: proposal %d succeeded",
			     GET_ISAKMP_PROP_NO (propp->p));
d1684 3
a1686 3
		  log_debug (LOG_MESSAGE, 30,
			     "message_negotiate_sa: proposal %d failed", 
			     GET_ISAKMP_PROP_NO (propp->p));
@


1.28
log
@ike_quick_mode.c: Merge with EOM 1.109
isakmpd.conf.5: Merge with EOM 1.38
message.c: Merge with EOM 1.142
pf_key_v2.c: Merge with EOM 1.35
x509.c: Merge with EOM 1.31

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.27 2000/01/30 10:18:56 niklas Exp $	*/
/*	$EOM: message.c,v 1.142 2000/01/31 08:39:44 niklas Exp $	*/
d6 1
@


1.27
log
@RCS Id sync with EOM
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.26 2000/01/30 10:11:57 niklas Exp $	*/
/*	$EOM: message.c,v 1.141 2000/01/30 10:21:29 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.26
log
@Another oopsie :-)
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.25 2000/01/30 09:59:46 niklas Exp $	*/
/*	$EOM: message.c,v 1.140 2000/01/30 10:04:08 niklas Exp $	*/
@


1.25
log
@Merge with EOM 1.140

author: niklas
Also check that the exchange to be upgraded is phase 1
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.24 2000/01/30 09:47:55 niklas Exp $	*/
d871 1
a871 1
	  if (msg->exchange && msg->exchange->phase == 1 &&
@


1.24
log
@Merge with EOM 1.139

author: niklas
Oops in last commit

author: niklas
Only upgrade exchanges that are still without a responder cookie
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.23 2000/01/26 15:20:56 niklas Exp $	*/
/*	$EOM: message.c,v 1.139 2000/01/30 09:52:00 niklas Exp $	*/
d871 1
a871 1
	  if (msg->exchange
@


1.23
log
@Merge with EOM 1.137

author: ho
Log a reason for dropping the message.

author: niklas
Some systems need to cast iov_base
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.22 1999/08/26 22:27:51 niklas Exp $	*/
/*	$EOM: message.c,v 1.137 1999/12/17 17:10:23 ho Exp $	*/
d871 3
a873 1
	  if (msg->exchange)
@


1.22
log
@ike_phase_1.c: Merge with EOM 1.8
message.c: Merge with EOM 1.135
message.h: Merge with EOM 1.48
sa.c: Merge with EOM 1.97
sa.h: Merge with EOM 1.53

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.21 1999/05/14 20:10:11 niklas Exp $	*/
/*	$EOM: message.c,v 1.135 1999/08/18 00:44:56 angelos Exp $	*/
d187 1
a187 1
  if (msg->orig && msg->orig != msg->iov[0].iov_base)
d1703 1
@


1.21
log
@Merge with EOM 1.134

author: niklas
We forgot to remove messages in-transit from the send queue when freeing it
due to the other side acknowledging it.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.20 1999/05/03 22:45:04 niklas Exp $	*/
/*	$EOM: message.c,v 1.134 1999/05/14 20:09:49 niklas Exp $	*/
d1554 2
a1555 1
		      int (*validate) (struct exchange *, struct sa *))
d1661 1
a1661 1
	      if (!validate || validate (exchange, sa))
@


1.20
log
@Merge with EOM 1.133

author: niklas
Plug a message leak
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.19 1999/05/02 19:18:48 niklas Exp $	*/
/*	$EOM: message.c,v 1.133 1999/05/03 07:58:37 niklas Exp $	*/
d1522 6
@


1.19
log
@Merge with EOM 1.132

author: niklas
Use new informational exchange hooks.  Never bind incoming phase 2 messages to
ISAKMP SAs that are not ready.  It is not clear just yet what to do in that
case, for now just drop such messages.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.18 1999/05/01 22:58:02 niklas Exp $	*/
/*	$EOM: message.c,v 1.132 1999/05/02 12:55:03 niklas Exp $	*/
d978 1
@


1.18
log
@TO-DO: Merge with EOM 1.36
sa.c: Merge with EOM 1.90
message.c: Merge with EOM 1.131
message.h: Merge with EOM 1.47

author: niklas
Send DELETE payloads in informational exchanges
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.17 1999/04/30 11:48:19 niklas Exp $	*/
/*	$EOM: message.c,v 1.131 1999/05/01 22:36:32 niklas Exp $	*/
d595 1
a595 2
   * it, setup a phase 2 SA.
   * XXX Is this correct?
d601 2
d604 5
a608 1
	exchange = exchange_setup_p2 (msg, doi_id);
d1297 5
d1343 8
@


1.17
log
@Merge with EOM 1.130

author: niklas
Try to get the right DOI in notifications

author: niklas
Revert last change

author: niklas
Informational exchanges reaches their end immediately.

author: niklas
Keep track of messages in the send queue from the exchange point of view.

author: niklas
Only retransmit if we have something to retransmit

author: niklas
New message_drop API.  Generate real INVALID_COOKIE notification.
Generate informational exchanges in phase 1 too.  Really get these
messages to the wire
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.16 1999/04/27 21:10:14 niklas Exp $	*/
/*	$EOM: message.c,v 1.130 1999/04/29 21:43:14 niklas Exp $	*/
d1210 1
a1210 1
      u_int8_t **spi;
d1249 34
d1322 1
a1322 1
      memcpy (buf + ISAKMP_DELETE_SPI_OFF, args->u.d.spi,
d1694 4
@


1.16
log
@Merge with EOM 1.124

author: niklas
When seeing duplicates, just retransmit if the last sent
message was the last of an exchange, thus not scheduled for retransmission.

author: ho
Keep track of trailing retransmissions by keeping exchanges around longer.
Removed references to sa->last_sent_in_setup, use last_sent and
last_received in exchange instead. Free setup exchanges by expiration only.

author: ho
Backout last change. (Go with exchange directly instead of sa->msg)

author: ho
Handle phase 2 late retransmissions.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.15 1999/04/19 20:59:27 niklas Exp $	*/
/*	$EOM: message.c,v 1.124 1999/04/27 18:44:37 niklas Exp $	*/
d245 1
a245 1
	  message_drop (msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 0, 1);
d258 1
a258 1
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 0, 1);
d266 1
a266 1
	  message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 1);
d283 1
a283 1
	  message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 0, 1);
d351 1
a351 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 0, 1);
d366 1
a366 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_CERT_ENCODING, 0, 0, 1);
d379 1
a379 1
      message_drop (msg, ISAKMP_NOTIFY_CERT_TYPE_UNSUPPORTED, 0, 0, 1);
d448 1
a448 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_ID_INFORMATION, 0, 0, 1);
d465 1
a465 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_KEY_INFORMATION, 0, 0, 1);
d544 1
a544 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_PROTOCOL_ID, 0, 0, 1);
d553 1
a553 1
      message_drop (msg, ISAKMP_NOTIFY_BAD_PROPOSAL_SYNTAX, 0, 0, 1);
d587 1
a587 1
      message_drop (msg, ISAKMP_NOTIFY_DOI_NOT_SUPPORTED, 0, 0, 1);
d638 1
a638 1
      message_drop (msg, ISAKMP_NOTIFY_SITUATION_NOT_SUPPORTED, 0, 0, 1);
d675 1
a675 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_TRANSFORM_ID, 0, 0, 1);
d683 1
a683 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 1);
d694 1
a694 1
      message_drop (msg, ISAKMP_NOTIFY_BAD_PROPOSAL_SYNTAX, 0, 0, 1);
d705 1
a705 1
      message_drop (msg, ISAKMP_NOTIFY_ATTRIBUTES_NOT_SUPPORTED, 0, 0, 1);
d719 1
a719 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 0, 1);
d810 2
d820 1
a820 1
      message_drop (msg, ISAKMP_NOTIFY_UNEQUAL_PAYLOAD_LENGTHS, 0, 0, 1);
d870 12
a881 2
	      log_print ("message_recv: invalid cookie");
	      message_drop (msg, ISAKMP_NOTIFY_INVALID_COOKIE, 0, 0, 1);
d901 1
a901 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_PAYLOAD_TYPE, 0, 0, 1);
d910 1
a910 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_MAJOR_VERSION, 0, 0, 1);
d918 1
a918 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_MINOR_VERSION, 0, 0, 1);
d935 1
a935 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 0, 1);
d949 1
a949 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_FLAGS, 0, 0, 1);
d959 1
a959 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_MESSAGE_ID, 0, 0, 1);
d1035 1
a1035 1
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 1);
d1049 1
a1049 1
      message_drop (msg, ISAKMP_NOTIFY_INVALID_EXCHANGE_TYPE, 0, 0, 1);
d1111 1
a1111 1
  if (exchange && exchange->flags & EXCHANGE_FLAG_COMMITTED)
d1118 1
d1232 1
d1235 2
a1236 2
  args.doi = proto ? proto->sa->doi->id : 0;
  args.proto = proto ? proto->proto : 0;
d1240 1
a1240 1
  if (isakmp_sa->flags & SA_FLAG_READY)
d1244 3
a1246 1
			   msg->exchange->doi->id, 0, &args, 0, 0);
d1249 2
a1250 5
/*
 * Build the informational message into MSG.
 * XXX We deallocate MSG on failure here, but how can we tell the caller?
 */
void
d1265 1
d1297 1
a1297 1
      return;
d1299 2
d1305 3
a1307 1
 * send out a notification to the originator.
d1311 1
a1311 1
	      int initiator, int clean)
d1325 3
a1327 6
  /*
   * If specified and we have at least an ISAKMP SA, return a notification.
   * XXX how to setup my SA.
   */
  if (notify && msg->isakmp_sa)
    message_send_notification (msg, msg->isakmp_sa, notify, proto, initiator);
d1455 1
a1455 1
	  if (exchange->last_sent->flags & MSG_LAST)
d1643 1
a1643 1
	      message_drop (msg, ISAKMP_NOTIFY_NO_PROPOSAL_CHOSEN, 0, 0, 0);
@


1.15
log
@./message.c: Merge with EOM 1.120

Style.  alloc error reporting.  Math error propagation.  Allocate right
sizes.

Add LOG_REPORT to always go to logchannel regardless of level; misc small fixes

Deal with incoming informational exchanges

Make message_dump_raw public, for udp_report in udp.c

message_dump_raw logs with LOG_MESSAGE, was LOG_TRANSPORT

Garbage collect transports via refcounting.  Fix commentary.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.14 1999/04/05 21:02:03 niklas Exp $	*/
/*	$EOM: message.c,v 1.120 1999/04/17 23:20:41 niklas Exp $	*/
a960 12

	  /*
	   * Retransmit final message of the exchange that set up the
	   * ISAKMP SA.
	   */
	  if (msg->isakmp_sa->last_sent_in_setup)
	    {
	      log_debug (LOG_MESSAGE, 80,
			 "message_recv: resending last message from phase 1");
	      message_send (msg->isakmp_sa->last_sent_in_setup);
	    }

d963 6
d1435 7
a1441 1
	  /* XXX Should we do an early retransmit of our last message?  */
@


1.14
log
@Merge with EOM 1.114
Remove obsoleted code

Memory alloc. error reporting.  Garbage collect keystate.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.13 1999/04/02 01:09:22 niklas Exp $	*/
/*	$EOM: message.c,v 1.114 1999/04/05 20:36:12 niklas Exp $	*/
a73 1
static void message_dump_raw (char *, struct message *);
d153 1
d210 1
d374 4
a377 3
  if ((cert = cert_get (GET_ISAKMP_CERTREQ_TYPE (p->p))) == NULL ||
      (len && !cert->certreq_validate (p->p + ISAKMP_CERTREQ_AUTHORITY_OFF,
				       len)))
d385 4
a388 1
/* Validate the delete payload P in message MSG.  */
d403 10
d479 4
a482 1
/* Validate the notify payload P in message MSG.  */
d498 10
d571 2
d606 1
a606 1
	  /* Log?  */
d615 1
a615 1
   * inititor where we only will count them.
d812 1
a812 1
  message_dump_raw ("message_recv", msg);
d841 4
d953 4
d1025 10
d1040 1
a1040 1
      && (!msg->exchange || msg->exchange->doi->validate_exchange (exch_type)))
a1048 10
  /* If we have not found an exchange by now something is definitely wrong.  */
  if (!msg->exchange)
    {
      log_print ("message_recv: no exchange");
      message_drop (msg, ISAKMP_NOTIFY_PAYLOAD_MALFORMED, 0, 0, 1);
      if (ks)
	free (ks);
      return -1;
    }

d1110 1
a1110 1
  message_dump_raw ("message_send", msg);
d1327 2
a1328 2
static void
message_dump_raw (char *header, struct message *msg)
d1333 1
a1333 2
  /* XXX Should we use LOG_MESSAGE instead?  */
  log_debug (LOG_TRANSPORT, 10, "%s: message %p", header, msg);
d1343 1
a1343 1
	    log_debug (LOG_TRANSPORT, 10, "%s", buf);
d1351 1
a1351 1
    log_debug (LOG_TRANSPORT, 10, "%s", buf);
@


1.13
log
@Merge with EOM 1.112
1999 copyrights

do not free already freed messages
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.12 1999/03/31 01:52:00 niklas Exp $	*/
/*	$EOM: message.c,v 1.112 1999/04/02 00:58:19 niklas Exp $	*/
d952 1
d968 5
a972 1
    return -1;
d981 5
a985 1
    return -1;
d996 2
a1004 1
      /* XXX I got here in an informational exchange.. I should not!  */
d1006 2
d1012 1
a1012 1
  if (!msg->exchange->keystate && ks)
d1014 7
a1020 2
      msg->exchange->keystate = ks;
      msg->exchange->crypto = ks->xf;
d1116 5
a1120 1
    return -1;
d1125 2
d1201 4
d1216 6
d1249 1
a1249 1
      /* Log!  */
d1345 5
a1349 1
    return -1;
a1450 2
  u_int8_t *spi;
  size_t spi_sz;
a1554 15
		  /* Record the other guy's (i.e. our outgoing) SPI.  */
		  spi_sz = GET_ISAKMP_PROP_SPI_SZ (propp->p);
		  if (spi_sz)
		    {
		      spi = malloc (spi_sz);
		      if (!spi)
			goto cleanup;
		      memcpy (spi, propp->p + ISAKMP_PROP_SPI_OFF, spi_sz);
		    }
		  else
		    spi = 0;
		  TAILQ_FIRST (&sa->protos)->spi[0] = spi;
		  log_debug_buf (LOG_MESSAGE, 40, "message_negotiate_sa: SPI",
				 spi, spi_sz);

d1599 4
a1602 1
  /* Remove potentially succeeded choices from the SA.  */
d1634 5
a1638 1
	goto cleanup;
d1651 6
a1656 1
        goto cleanup;
d1659 6
a1664 1
        goto cleanup;
d1667 6
a1672 1
        goto cleanup;
d1675 5
a1679 1
        goto cleanup;
d1688 5
a1692 1
	    goto cleanup;
d1712 5
a1716 1
	    goto cleanup;
@


1.12
log
@Merge with EOM 1.110
new exchange establishment API, byteorder fix to debug printout.  Fix a long
standing logic error related to saving SA bodies that ElectricFence found
for me.
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.11 1999/03/24 14:44:26 niklas Exp $	*/
/*	$EOM: message.c,v 1.110 1999/03/31 01:31:36 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d967 1
a967 4
    {
      message_free (msg);
      return -1;
    }
@


1.11
log
@Merge with EOM 1.109
Store SPIs in the right slots, also tell about port numbers when dropping
messages.

Do not free SPI buffers we still reference
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.10 1999/03/02 15:12:00 niklas Exp $	*/
/*	$EOM: message.c,v 1.109 1999/03/24 11:03:01 niklas Exp $	*/
d1175 1
a1175 1
    exchange_establish_p2 (isakmp_sa, ISAKMP_EXCH_INFO, &args);
d1178 1
a1178 1
			   msg->exchange->doi->id, &args, 0, 0);
d1242 1
a1242 1
	     ((struct sockaddr_in *)dst)->sin_port,
d1743 1
a1743 1
  int i, skip = -1;
@


1.10
log
@if.c: Merge with EOM 1.8
Deal with old socket APIs

udp.c: Merge with EOM 1.31
Deal with old socket APIs

message.c: Merge with EOM 1.107
Remove unnecessary system dependent include
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.9 1999/02/26 03:47:46 niklas Exp $	*/
/*	$EOM: message.c,v 1.107 1999/03/02 14:23:04 niklas Exp $	*/
d1240 1
a1240 1
  log_print ("dropped message from %s due to notification type %s",
d1242 1
d1523 1
a1523 1
		  /* Record the other guy's SPI.  */
d1534 1
a1534 1
		  TAILQ_FIRST (&sa->protos)->spi[1] = spi;
d1647 1
a1647 1
	  /* Get SPI from application.  */
d1656 2
a1657 2
	      proto->spi[0] = spi;
	      proto->spi_sz[0] = spi_sz;
a1673 2
	  free (spi);
	  spi = 0;
a1715 2
  if (spi)
    free (spi);
@


1.9
log
@Merge from the Ericsson repository
| revision 1.106
| date: 1999/02/25 11:39:15;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.105
| date: 1999/02/14 00:18:11;  author: niklas;  state: Exp;  lines: +10 -9
| Keep track of what SPI we are generating/using
| ----------------------------
| revision 1.104
| date: 1999/02/06 15:03:39;  author: niklas;  state: Exp;  lines: +7 -1
| Do not forget to remove message from sendq when freed
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.8 1998/12/21 01:02:26 niklas Exp $	*/
/*	$EOM: message.c,v 1.106 1999/02/25 11:39:15 niklas Exp $	*/
a40 1
#include <machine/endian.h>
@


1.8
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.7 1998/11/20 07:32:50 niklas Exp $	*/
/*	$EOM: message.c,v 1.103 1998/12/15 16:58:45 niklas Exp $	*/
d45 2
d207 5
d1060 1
d1154 3
a1156 1
 * fields initialized from SA.
d1165 1
a1165 1
			   int initiator)
d1172 1
a1172 1
  args.spi_sz = proto ? proto->spi_sz[initiator] : 0;
d1174 1
a1174 1
  args.u.n.spi = proto ? proto->spi[initiator] : 0;
d1534 1
a1534 2
		  TAILQ_FIRST (&sa->protos)->spi[!msg->exchange->initiator]
		    = spi;
d1656 2
a1657 2
	      proto->spi[exchange->initiator] = spi;
	      proto->spi_sz[exchange->initiator] = spi_sz;
@


1.7
log
@Validate proposals against policies
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.6 1998/11/17 11:10:17 niklas Exp $	*/
/*	$EOM: message.c,v 1.101 1998/11/20 07:12:03 niklas Exp $	*/
d991 1
d1169 1
a1169 1
			   msg->exchange->doi->id, &args);
d1398 2
a1399 1
message_negotiate_sa (struct message *msg, int (*validate) (struct sa *))
d1507 1
a1507 1
	      if (!validate || validate (sa))
@


1.6
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: message.c,v 1.5 1998/11/16 12:20:33 niklas Exp $	*/
/*	$EOM: message.c,v 1.100 1998/11/12 13:02:29 niklas Exp $	*/
d1397 1
a1397 1
message_negotiate_sa (struct message *msg)
d1400 1
d1454 3
d1463 1
d1500 2
a1501 1
	   * Check if the suite we just considered was OK, if so we're done.
d1505 1
a1505 7
	      log_debug (LOG_MESSAGE, 30,
			 "message_negotiate_sa: proposal %d succeeded",
			 GET_ISAKMP_PROP_NO (propp->p));

	      /* Record the other guy's SPI.  */
	      spi_sz = GET_ISAKMP_PROP_SPI_SZ (propp->p);
	      if (spi_sz)
d1507 25
a1531 4
		  spi = malloc (spi_sz);
		  if (!spi)
		    goto cleanup;
		  memcpy (spi, propp->p + ISAKMP_PROP_SPI_OFF, spi_sz);
d1534 16
a1549 10
		spi = 0;
	      TAILQ_FIRST (&sa->protos)->spi[!msg->exchange->initiator]
		= spi;
	      log_debug_buf (LOG_MESSAGE, 40, "message_negotiate_sa: SPI", spi,
			     spi_sz);

	      /* Skip to the last transform of this SA.  */
	      while ((next_tp = step_transform (tp, &next_propp, &next_sap))
		     && next_sap == sap)
		tp = next_tp;
@


1.5
log
@Add back cert handling, no patent problem here
@
text
@d1 2
a2 1
/*	$OpenBSD: message.c,v 1.4 1998/11/15 01:13:27 niklas Exp $	*/
@


1.4
log
@Remove last warnings after crippling
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.3 1998/11/15 01:11:25 niklas Exp $	*/
a352 1
#if 0
a354 1
#endif
a365 1
#if 0
a372 1
#endif
@


1.3
log
@At the moment we do not do certificates
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.2 1998/11/15 00:44:01 niklas Exp $	*/
d353 1
d356 1
@


1.2
log
@openBSD RCS IDs
@
text
@d1 1
a1 1
/*	$OpenBSD: message.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
d366 1
d374 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: message.c,v 1.100 1998/11/12 13:02:29 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
