head	1.198;
access;
symbols
	OPENBSD_6_1_BASE:1.198
	OPENBSD_6_0:1.197.0.4
	OPENBSD_6_0_BASE:1.197
	OPENBSD_5_9:1.197.0.2
	OPENBSD_5_9_BASE:1.197
	OPENBSD_5_8:1.194.0.4
	OPENBSD_5_8_BASE:1.194
	OPENBSD_5_7:1.191.0.2
	OPENBSD_5_7_BASE:1.191
	OPENBSD_5_6:1.188.0.12
	OPENBSD_5_6_BASE:1.188
	OPENBSD_5_5:1.188.0.10
	OPENBSD_5_5_BASE:1.188
	OPENBSD_5_4:1.188.0.6
	OPENBSD_5_4_BASE:1.188
	OPENBSD_5_3:1.188.0.4
	OPENBSD_5_3_BASE:1.188
	OPENBSD_5_2:1.188.0.2
	OPENBSD_5_2_BASE:1.188
	OPENBSD_5_1_BASE:1.187
	OPENBSD_5_1:1.187.0.4
	OPENBSD_5_0:1.187.0.2
	OPENBSD_5_0_BASE:1.187
	OPENBSD_4_9:1.186.0.2
	OPENBSD_4_9_BASE:1.186
	OPENBSD_4_8:1.185.0.8
	OPENBSD_4_8_BASE:1.185
	OPENBSD_4_7:1.185.0.4
	OPENBSD_4_7_BASE:1.185
	OPENBSD_4_6:1.185.0.6
	OPENBSD_4_6_BASE:1.185
	OPENBSD_4_5:1.185.0.2
	OPENBSD_4_5_BASE:1.185
	OPENBSD_4_4:1.184.0.2
	OPENBSD_4_4_BASE:1.184
	OPENBSD_4_3:1.182.0.2
	OPENBSD_4_3_BASE:1.182
	OPENBSD_4_2:1.181.0.2
	OPENBSD_4_2_BASE:1.181
	OPENBSD_4_1:1.178.0.2
	OPENBSD_4_1_BASE:1.178
	OPENBSD_4_0:1.176.0.2
	OPENBSD_4_0_BASE:1.176
	OPENBSD_3_9:1.168.0.2
	OPENBSD_3_9_BASE:1.168
	OPENBSD_3_8:1.167.0.2
	OPENBSD_3_8_BASE:1.167
	OPENBSD_3_7:1.155.0.2
	OPENBSD_3_7_BASE:1.155
	OPENBSD_3_6:1.149.0.2
	OPENBSD_3_6_BASE:1.149
	OPENBSD_3_5:1.138.0.2
	OPENBSD_3_5_BASE:1.138
	OPENBSD_3_4:1.136.0.2
	OPENBSD_3_4_BASE:1.136
	OPENBSD_3_3:1.122.0.2
	OPENBSD_3_3_BASE:1.122
	OPENBSD_3_2:1.117.0.2
	OPENBSD_3_2_BASE:1.117
	OPENBSD_3_1:1.97.0.2
	OPENBSD_3_1_BASE:1.97
	OPENBSD_3_0:1.90.0.2
	OPENBSD_3_0_BASE:1.90
	OPENBSD_2_9:1.50.0.2
	OPENBSD_2_9_BASE:1.50
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	OPENBSD_2_6:1.15.0.2
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.198
date	2017.02.28.16.46.27;	author bluhm;	state Exp;
branches;
next	1.197;
commitid	rmbXKt3efXwOBuCw;

1.197
date	2015.12.10.17.27.00;	author mmcc;	state Exp;
branches;
next	1.196;
commitid	82PdNqu2kKAuXPfA;

1.196
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.195;
commitid	CLwtYUTkBZ3FXV1w;

1.195
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.194;
commitid	0qPuuXwccpVXsXcV;

1.194
date	2015.04.17.10.04.37;	author mikeb;	state Exp;
branches;
next	1.193;
commitid	KP3L4W0chjmfJmS7;

1.193
date	2015.04.14.12.22.15;	author mikeb;	state Exp;
branches;
next	1.192;
commitid	bQi1IVHgugweH5gs;

1.192
date	2015.03.26.12.21.37;	author mikeb;	state Exp;
branches;
next	1.191;
commitid	GUv4gLlXi8Tx36WA;

1.191
date	2014.10.29.06.26.40;	author deraadt;	state Exp;
branches;
next	1.190;
commitid	Tez37f8p0vZ5t0Gz;

1.190
date	2014.10.22.16.35.34;	author millert;	state Exp;
branches;
next	1.189;
commitid	BEpmHa0BiZInAWeq;

1.189
date	2014.10.18.03.10.00;	author doug;	state Exp;
branches;
next	1.188;
commitid	fsQOoYAvksqdKXQI;

1.188
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.187;

1.187
date	2011.08.02.22.51.38;	author markus;	state Exp;
branches;
next	1.186;

1.186
date	2010.09.22.13.45.16;	author mikeb;	state Exp;
branches;
next	1.185;

1.185
date	2009.01.28.17.57.15;	author hshoexer;	state Exp;
branches;
next	1.184;

1.184
date	2008.07.01.15.00.53;	author bluhm;	state Exp;
branches;
next	1.183;

1.183
date	2008.06.10.17.25.57;	author bluhm;	state Exp;
branches;
next	1.182;

1.182
date	2007.09.02.15.19.24;	author deraadt;	state Exp;
branches;
next	1.181;

1.181
date	2007.05.27.18.31.30;	author claudio;	state Exp;
branches;
next	1.180;

1.180
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.179;

1.179
date	2007.04.08.11.20.31;	author moritz;	state Exp;
branches;
next	1.178;

1.178
date	2007.02.19.09.43.34;	author hshoexer;	state Exp;
branches;
next	1.177;

1.177
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.176;

1.176
date	2006.09.01.00.24.06;	author mpf;	state Exp;
branches;
next	1.175;

1.175
date	2006.08.30.22.54.32;	author henning;	state Exp;
branches;
next	1.174;

1.174
date	2006.08.30.18.27.17;	author henning;	state Exp;
branches;
next	1.173;

1.173
date	2006.08.30.10.50.36;	author markus;	state Exp;
branches;
next	1.172;

1.172
date	2006.06.10.20.10.02;	author hshoexer;	state Exp;
branches;
next	1.171;

1.171
date	2006.05.31.04.58.13;	author hshoexer;	state Exp;
branches;
next	1.170;

1.170
date	2006.05.31.04.54.46;	author hshoexer;	state Exp;
branches;
next	1.169;

1.169
date	2006.05.29.10.17.59;	author markus;	state Exp;
branches;
next	1.168;

1.168
date	2005.11.14.23.25.11;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2005.06.14.10.50.47;	author hshoexer;	state Exp;
branches;
next	1.166;

1.166
date	2005.06.01.23.04.35;	author cloder;	state Exp;
branches;
next	1.165;

1.165
date	2005.05.22.06.22.53;	author cloder;	state Exp;
branches;
next	1.164;

1.164
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.163;

1.163
date	2005.04.08.19.40.03;	author deraadt;	state Exp;
branches;
next	1.162;

1.162
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.161;

1.161
date	2005.04.08.16.37.14;	author deraadt;	state Exp;
branches;
next	1.160;

1.160
date	2005.04.08.16.09.25;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2005.04.08.16.07.21;	author cloder;	state Exp;
branches;
next	1.158;

1.158
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2005.04.05.20.46.20;	author cloder;	state Exp;
branches;
next	1.156;

1.156
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2005.03.02.12.49.51;	author hshoexer;	state Exp;
branches;
next	1.154;

1.154
date	2005.02.27.14.26.00;	author pat;	state Exp;
branches;
next	1.153;

1.153
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.152;

1.152
date	2005.02.25.03.02.41;	author cloder;	state Exp;
branches;
next	1.151;

1.151
date	2004.12.27.11.02.03;	author hshoexer;	state Exp;
branches;
next	1.150;

1.150
date	2004.09.17.13.53.08;	author ho;	state Exp;
branches;
next	1.149;

1.149
date	2004.08.12.11.08.54;	author ho;	state Exp;
branches;
next	1.148;

1.148
date	2004.08.10.15.59.10;	author ho;	state Exp;
branches;
next	1.147;

1.147
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2004.06.26.06.07.03;	author hshoexer;	state Exp;
branches;
next	1.145;

1.145
date	2004.06.23.23.36.01;	author ho;	state Exp;
branches;
next	1.144;

1.144
date	2004.06.21.18.41.06;	author ho;	state Exp;
branches;
next	1.143;

1.143
date	2004.06.21.15.15.38;	author ho;	state Exp;
branches;
next	1.142;

1.142
date	2004.06.14.09.55.41;	author ho;	state Exp;
branches;
next	1.141;

1.141
date	2004.06.09.14.02.44;	author ho;	state Exp;
branches;
next	1.140;

1.140
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.139;

1.139
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.138;

1.138
date	2004.03.10.09.28.46;	author ho;	state Exp;
branches;
next	1.137;

1.137
date	2003.11.06.16.12.07;	author ho;	state Exp;
branches;
next	1.136;

1.136
date	2003.08.08.08.37.36;	author ho;	state Exp;
branches;
next	1.135;

1.135
date	2003.07.25.08.31.16;	author markus;	state Exp;
branches;
next	1.134;

1.134
date	2003.07.24.09.59.03;	author itojun;	state Exp;
branches;
next	1.133;

1.133
date	2003.06.10.16.41.29;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.131;

1.131
date	2003.05.18.19.37.46;	author ho;	state Exp;
branches;
next	1.130;

1.130
date	2003.05.18.18.16.34;	author ho;	state Exp;
branches;
next	1.129;

1.129
date	2003.05.15.00.28.53;	author ho;	state Exp;
branches;
next	1.128;

1.128
date	2003.05.14.23.44.48;	author kjell;	state Exp;
branches;
next	1.127;

1.127
date	2003.05.14.17.37.22;	author ho;	state Exp;
branches;
next	1.126;

1.126
date	2003.05.12.21.43.21;	author ho;	state Exp;
branches;
next	1.125;

1.125
date	2003.05.11.02.16.54;	author markus;	state Exp;
branches;
next	1.124;

1.124
date	2003.04.14.10.22.13;	author ho;	state Exp;
branches;
next	1.123;

1.123
date	2003.04.14.10.14.16;	author ho;	state Exp;
branches;
next	1.122;

1.122
date	2003.02.24.12.01.04;	author markus;	state Exp;
branches;
next	1.121;

1.121
date	2003.01.09.13.10.34;	author ho;	state Exp;
branches;
next	1.120;

1.120
date	2002.12.06.20.28.20;	author ho;	state Exp;
branches;
next	1.119;

1.119
date	2002.12.04.18.08.40;	author ho;	state Exp;
branches;
next	1.118;

1.118
date	2002.12.04.15.06.33;	author markus;	state Exp;
branches;
next	1.117;

1.117
date	2002.09.11.09.50.44;	author ho;	state Exp;
branches;
next	1.116;

1.116
date	2002.08.29.15.15.45;	author itojun;	state Exp;
branches;
next	1.115;

1.115
date	2002.08.23.18.01.33;	author ho;	state Exp;
branches;
next	1.114;

1.114
date	2002.08.23.17.11.08;	author ho;	state Exp;
branches;
next	1.113;

1.113
date	2002.07.11.21.23.28;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2002.07.05.11.08.13;	author ho;	state Exp;
branches;
next	1.111;

1.111
date	2002.06.11.18.50.21;	author ho;	state Exp;
branches;
next	1.110;

1.110
date	2002.06.11.18.28.01;	author ho;	state Exp;
branches;
next	1.109;

1.109
date	2002.06.11.18.04.28;	author ho;	state Exp;
branches;
next	1.108;

1.108
date	2002.06.10.20.54.51;	author ho;	state Exp;
branches;
next	1.107;

1.107
date	2002.06.09.08.13.06;	author todd;	state Exp;
branches;
next	1.106;

1.106
date	2002.06.07.06.37.08;	author ho;	state Exp;
branches;
next	1.105;

1.105
date	2002.06.07.05.07.33;	author angelos;	state Exp;
branches;
next	1.104;

1.104
date	2002.06.06.18.35.15;	author ho;	state Exp;
branches;
next	1.103;

1.103
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.01.07.44.22;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2002.05.31.02.16.55;	author angelos;	state Exp;
branches;
next	1.100;

1.100
date	2002.05.28.10.09.46;	author ho;	state Exp;
branches;
next	1.99;

1.99
date	2002.05.27.04.21.38;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2002.05.26.09.24.35;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2002.02.21.20.12.56;	author angelos;	state Exp;
branches;
next	1.96;

1.96
date	2002.02.19.21.11.19;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2002.01.25.13.07.23;	author ho;	state Exp;
branches;
next	1.94;

1.94
date	2002.01.23.18.44.47;	author ho;	state Exp;
branches;
next	1.93;

1.93
date	2002.01.23.17.21.16;	author ho;	state Exp;
branches;
next	1.92;

1.92
date	2002.01.03.09.19.52;	author ho;	state Exp;
branches;
next	1.91;

1.91
date	2001.10.26.13.29.26;	author ho;	state Exp;
branches;
next	1.90;

1.90
date	2001.10.12.15.47.49;	author ho;	state Exp;
branches;
next	1.89;

1.89
date	2001.08.27.18.26.16;	author ho;	state Exp;
branches;
next	1.88;

1.88
date	2001.08.25.07.42.19;	author niklas;	state Exp;
branches;
next	1.87;

1.87
date	2001.08.24.13.47.21;	author ho;	state Exp;
branches;
next	1.86;

1.86
date	2001.08.23.16.56.46;	author markus;	state Exp;
branches;
next	1.85;

1.85
date	2001.08.19.18.24.29;	author angelos;	state Exp;
branches;
next	1.84;

1.84
date	2001.08.14.20.33.02;	author ho;	state Exp;
branches;
next	1.83;

1.83
date	2001.08.14.20.24.40;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2001.08.14.19.38.38;	author ho;	state Exp;
branches;
next	1.81;

1.81
date	2001.07.29.13.45.28;	author itojun;	state Exp;
branches;
next	1.80;

1.80
date	2001.07.25.15.29.47;	author markus;	state Exp;
branches;
next	1.79;

1.79
date	2001.07.25.11.42.06;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2001.07.18.20.48.33;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2001.07.02.02.28.35;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2001.07.01.19.48.44;	author niklas;	state Exp;
branches;
next	1.75;

1.75
date	2001.07.01.18.33.50;	author angelos;	state Exp;
branches;
next	1.74;

1.74
date	2001.07.01.18.27.37;	author angelos;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.01.05.16.03;	author angelos;	state Exp;
branches;
next	1.72;

1.72
date	2001.06.29.19.08.11;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.29.18.52.17;	author ho;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.29.18.05.24;	author ho;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.29.05.17.57;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.29.04.12.00;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.27.03.31.43;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.27.00.48.21;	author angelos;	state Exp;
branches;
next	1.65;

1.65
date	2001.06.07.07.50.29;	author angelos;	state Exp;
branches;
next	1.64;

1.64
date	2001.06.07.07.45.18;	author angelos;	state Exp;
branches;
next	1.63;

1.63
date	2001.06.05.21.43.46;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2001.06.05.10.51.27;	author angelos;	state Exp;
branches;
next	1.61;

1.61
date	2001.06.05.10.43.56;	author angelos;	state Exp;
branches;
next	1.60;

1.60
date	2001.06.05.10.43.05;	author angelos;	state Exp;
branches;
next	1.59;

1.59
date	2001.06.05.07.59.33;	author angelos;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.05.01.29.05;	author angelos;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.05.01.03.40;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2001.06.05.00.17.46;	author niklas;	state Exp;
branches;
next	1.55;

1.55
date	2001.05.31.20.30.29;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2001.05.30.22.06.42;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2001.05.30.18.49.16;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.05.30.16.46.33;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.05.00.55.13;	author angelos;	state Exp;
branches;
next	1.50;

1.50
date	2001.04.24.07.27.37;	author niklas;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2001.04.19.20.12.44;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.27.21.09.49;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.24.03.59.55;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.01.27.12.03.34;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.43;

1.43
date	2001.01.10.21.41.54;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.01.05.19.30.37;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2000.12.15.06.34.54;	author provos;	state Exp;
branches;
next	1.40;

1.40
date	2000.12.12.01.46.55;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	2000.12.02.01.56.04;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2000.11.27.01.42.58;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.27.01.41.04;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.17.05.16.36;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.17.04.53.57;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.30.16.04.00;	author angelos;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.10.16.23.26.20;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.10.13.34.58;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.10.09.23.26.59;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2000.10.07.06.57.56;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.09.19.19.01.31;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.19.08.38.28;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.20.05.55.27;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.19.02.25.31;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.08.08.41.57;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.25.17.23.40;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.31.08.38.29;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	2000.01.26.15.36.19;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.26.15.24.32;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.23.22.50.55;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.13.22.55.48;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.13.06.42.26;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	99.12.04.23.31.42;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	99.07.16.00.44.49;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.07.08.17.49.35;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.07.07.22.08.10;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.07.02.23.37.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	99.06.02.06.34.53;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.05.01.20.42.54;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.05.01.00.51.45;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.04.27.21.01.28;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.04.19.20.58.30;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.04.05.20.59.22;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.03.31.23.48.19;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.03.31.20.30.38;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.03.31.14.27.38;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.03.31.01.53.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.03.24.14.37.13;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2000.11.29.03.44.16;	author jason;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.05.08.12.45.25;	author ho;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.06.06.21.20.04;	author miod;	state Exp;
branches;
next	;

1.50.2.1
date	2001.06.06.03.39.07;	author jason;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2001.07.17.04.08.55;	author jason;	state Exp;
branches;
next	;


desc
@@


1.198
log
@Depending on the addresses, ipsecctl(8) automatically groups sa
bundles together.  Extend the kernel interface to export the bundle
information to userland.  Then ipsecctl -ss -v can show the internal
relations.  Unfortunately the header SADB_X_EXT_PROTOCOL was reused
by SADB_X_GRPSPIS, so it cannot be used to transfer the second sa
type with sysctl.  Introduce a new SADB_X_EXT_SATYPE2 and use it
consistently.
OK hshoexer@@ markus@@
@
text
@/* $OpenBSD: pf_key_v2.c,v 1.197 2015/12/10 17:27:00 mmcc Exp $  */
/* $EOM: pf_key_v2.c,v 1.79 2000/12/12 00:33:19 niklas Exp $	 */

/*
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2001 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <net/pfkeyv2.h>
#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <poll.h>
#include <string.h>
#include <unistd.h>
#include <pwd.h>
#include <errno.h>
#include <bitstring.h>

#include "cert.h"
#include "conf.h"
#include "connection.h"
#include "exchange.h"
#include "ipsec.h"
#include "ipsec_num.h"
#include "key.h"
#include "log.h"
#include "pf_key_v2.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "ui.h"
#include "util.h"

#include "policy.h"

#include "udp_encap.h"

#define IN6_IS_ADDR_FULL(a)						\
	((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0xffffffff) &&	\
	(*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0xffffffff) &&	\
	(*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == 0xffffffff) &&	\
	(*(u_int32_t *)(void *)(&(a)->s6_addr[12]) == 0xffffffff))

#define ADDRESS_MAX sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"

/*
 * PF_KEY v2 always work with 64-bit entities and aligns on 64-bit boundaries.
 */
#define PF_KEY_V2_CHUNK 8
#define PF_KEY_V2_ROUND(x)						\
	(((x) + PF_KEY_V2_CHUNK - 1) & ~(PF_KEY_V2_CHUNK - 1))

/* How many microseconds we will wait for a reply from the PF_KEY socket.  */
#define PF_KEY_REPLY_TIMEOUT 1000

struct pf_key_v2_node {
	TAILQ_ENTRY(pf_key_v2_node) link;
	void           *seg;
	size_t		sz;
	int		cnt;
	u_int16_t       type;
	u_int8_t	flags;
};

TAILQ_HEAD(pf_key_v2_msg, pf_key_v2_node);

#define PF_KEY_V2_NODE_MALLOCED 1
#define PF_KEY_V2_NODE_MARK 2

/* Used to derive "unique" connection identifiers. */
int		connection_seq = 0;

static u_int8_t *pf_key_v2_convert_id(u_int8_t *, int, size_t *, int *);
static struct pf_key_v2_msg *pf_key_v2_call(struct pf_key_v2_msg *);
static struct pf_key_v2_node *pf_key_v2_find_ext(struct pf_key_v2_msg *,
		    u_int16_t);
static void     pf_key_v2_notify(struct pf_key_v2_msg *);
static struct pf_key_v2_msg *pf_key_v2_read(u_int32_t);
static u_int32_t pf_key_v2_seq(void);
static u_int32_t pf_key_v2_write(struct pf_key_v2_msg *);
static int      pf_key_v2_remove_conf(char *);
static int      pf_key_v2_conf_refhandle(int, char *);

static int      pf_key_v2_conf_refinc(int, char *);

/* The socket to use for PF_KEY interactions.  */
int      pf_key_v2_socket;

static struct pf_key_v2_msg *
pf_key_v2_msg_new(struct sadb_msg *msg, int flags)
{
	struct pf_key_v2_node *node;
	struct pf_key_v2_msg *ret;

	node = malloc(sizeof *node);
	if (!node)
		goto cleanup;
	ret = malloc(sizeof *ret);
	if (!ret)
		goto cleanup;
	TAILQ_INIT(ret);
	node->seg = msg;
	node->sz = sizeof *msg;
	node->type = 0;
	node->cnt = 1;
	node->flags = flags;
	TAILQ_INSERT_HEAD(ret, node, link);
	return ret;

cleanup:
	free(node);
	return 0;
}

/* Add a SZ sized segment SEG to the PF_KEY message MSG.  */
static int
pf_key_v2_msg_add(struct pf_key_v2_msg *msg, struct sadb_ext *ext, int flags)
{
	struct pf_key_v2_node *node;

	node = malloc(sizeof *node);
	if (!node)
		return -1;
	node->seg = ext;
	node->sz = ext->sadb_ext_len * PF_KEY_V2_CHUNK;
	node->type = ext->sadb_ext_type;
	node->flags = flags;
	TAILQ_FIRST(msg)->cnt++;
	TAILQ_INSERT_TAIL(msg, node, link);
	return 0;
}

/* Deallocate the PF_KEY message MSG.  */
static void
pf_key_v2_msg_free(struct pf_key_v2_msg *msg)
{
	struct pf_key_v2_node *np;

	np = TAILQ_FIRST(msg);
	while (np) {
		TAILQ_REMOVE(msg, np, link);
		if (np->flags & PF_KEY_V2_NODE_MALLOCED)
			free(np->seg);
		free(np);
		np = TAILQ_FIRST(msg);
	}
	free(msg);
}

/* Just return a new sequence number.  */
static u_int32_t
pf_key_v2_seq(void)
{
	static u_int32_t seq = 0;

	return ++seq;
}

/*
 * Read a PF_KEY packet with SEQ as the sequence number, looping if necessary.
 * If SEQ is zero just read the first message we see, otherwise we queue
 * messages up until both the PID and the sequence number match.
 */
static struct pf_key_v2_msg *
pf_key_v2_read(u_int32_t seq)
{
	ssize_t		n;
	u_int8_t       *buf = 0;
	struct pf_key_v2_msg *ret = 0;
	struct sadb_msg *msg;
	struct sadb_msg hdr;
	struct sadb_ext *ext;
	struct timeval	tv;
	struct pollfd	pfd[1];

	pfd[0].fd = pf_key_v2_socket;
	pfd[0].events = POLLIN;

	while (1) {
		/*
		 * If this is a read of a reply we should actually expect the
		 * reply to get lost as PF_KEY is an unreliable service per
		 * the specs. Currently we do this by setting a short timeout,
		 * and if it is not readable in that time, we fail the read.
		 */
		if (seq) {
			n = poll(pfd, 1, PF_KEY_REPLY_TIMEOUT / 1000);
			if (n == -1) {
				log_error("pf_key_v2_read: poll() failed");
				goto cleanup;
			}
			if (!n) {
				log_print("pf_key_v2_read: "
				    "no reply from PF_KEY");
				goto cleanup;
			}
		}
		n = recv(pf_key_v2_socket, &hdr, sizeof hdr, MSG_PEEK);
		if (n == -1) {
			log_error("pf_key_v2_read: recv (%d, ...) failed",
			    pf_key_v2_socket);
			goto cleanup;
		}
		if (n != sizeof hdr) {
			log_error("pf_key_v2_read: recv (%d, ...) "
			    "returned short packet (%lu bytes)",
			    pf_key_v2_socket, (unsigned long) n);
			goto cleanup;
		}
		buf = reallocarray(NULL, hdr.sadb_msg_len, PF_KEY_V2_CHUNK);
		if (!buf) {
			log_error("pf_key_v2_read: reallocarray (%d, %d) failed",
			    hdr.sadb_msg_len, PF_KEY_V2_CHUNK);
			goto cleanup;
		}
		n = hdr.sadb_msg_len * PF_KEY_V2_CHUNK;

		n = read(pf_key_v2_socket, buf, n);
		if (n == -1) {
			log_error("pf_key_v2_read: read (%d, ...) failed",
				  pf_key_v2_socket);
			goto cleanup;
		}
		if (n != hdr.sadb_msg_len * PF_KEY_V2_CHUNK) {
			log_print("pf_key_v2_read: read (%d, ...) "
			    "returned short packet (%lu bytes)",
			    pf_key_v2_socket, (unsigned long) n);
			goto cleanup;
		}
		LOG_DBG_BUF((LOG_SYSDEP, 80, "pf_key_v2_read: msg", buf, n));

		/* We drop all messages that is not what we expect.  */
		msg = (struct sadb_msg *) buf;
		if (msg->sadb_msg_version != PF_KEY_V2 ||
		    (msg->sadb_msg_pid != 0 &&
		    msg->sadb_msg_pid != (u_int32_t) getpid())) {
			if (seq) {
				free(buf);
				buf = 0;
				continue;
			} else {
				LOG_DBG((LOG_SYSDEP, 90, "pf_key_v2_read:"
				    "bad version (%d) or PID (%d, mine is "
				    "%ld), ignored", msg->sadb_msg_version,
				    msg->sadb_msg_pid, (long) getpid()));
				goto cleanup;
			}
		}
		/* Parse the message.  */
		ret = pf_key_v2_msg_new(msg, PF_KEY_V2_NODE_MALLOCED);
		if (!ret)
			goto cleanup;
		buf = 0;
		for (ext = (struct sadb_ext *) (msg + 1);
		    (u_int8_t *) ext - (u_int8_t *) msg <
		    msg->sadb_msg_len * PF_KEY_V2_CHUNK;
		    ext = (struct sadb_ext *) ((u_int8_t *) ext +
		    ext->sadb_ext_len * PF_KEY_V2_CHUNK))
			pf_key_v2_msg_add(ret, ext, 0);

		/*
		 * If the message is not the one we are waiting for, queue it
		 * up.
		 */
		if (seq && (msg->sadb_msg_pid != (u_int32_t) getpid() ||
		    msg->sadb_msg_seq != seq)) {
			gettimeofday(&tv, 0);
			timer_add_event("pf_key_v2_notify",
			    (void (*) (void *)) pf_key_v2_notify, ret, &tv);
			ret = 0;
			continue;
		}
		return ret;
	}

cleanup:
	free(buf);
	if (ret)
		pf_key_v2_msg_free(ret);
	return 0;
}

/* Write the message in PMSG to the PF_KEY socket.  */
u_int32_t
pf_key_v2_write(struct pf_key_v2_msg *pmsg)
{
	struct iovec   *iov = 0;
	ssize_t		n;
	size_t		len;
	int		i, cnt = TAILQ_FIRST(pmsg)->cnt;
	char		header[80];
	struct sadb_msg *msg = TAILQ_FIRST(pmsg)->seg;
	struct pf_key_v2_node *np = TAILQ_FIRST(pmsg);

	iov = calloc(cnt, sizeof *iov);
	if (!iov) {
		log_error("pf_key_v2_write: malloc (%lu) failed",
		    cnt * (unsigned long) sizeof *iov);
		return 0;
	}
	msg->sadb_msg_version = PF_KEY_V2;
	msg->sadb_msg_errno = 0;
	msg->sadb_msg_reserved = 0;
	msg->sadb_msg_pid = getpid();
	if (!msg->sadb_msg_seq)
		msg->sadb_msg_seq = pf_key_v2_seq();

	/* Compute the iovec segments as well as the message length.  */
	len = 0;
	for (i = 0; i < cnt; i++) {
		iov[i].iov_base = np->seg;
		len += iov[i].iov_len = np->sz;

		/*
		 * XXX One can envision setting specific extension fields,
		 * like *_reserved ones here.  For now we require them to be
		 * set by the caller.
		 */

		np = TAILQ_NEXT(np, link);
	}
	msg->sadb_msg_len = len / PF_KEY_V2_CHUNK;

	for (i = 0; i < cnt; i++) {
		snprintf(header, sizeof header, "pf_key_v2_write: iov[%d]", i);
		LOG_DBG_BUF((LOG_SYSDEP, 80, header,
		    (u_int8_t *) iov[i].iov_base, iov[i].iov_len));
	}

	do {
		n = writev(pf_key_v2_socket, iov, cnt);
	} while (n == -1 && (errno == EAGAIN || errno == EINTR));
	if (n == -1) {
		log_error("pf_key_v2_write: writev (%d, %p, %d) failed",
		    pf_key_v2_socket, iov, cnt);
		goto cleanup;
	}
	if ((size_t) n != len) {
		log_error("pf_key_v2_write: "
		    "writev (%d, ...) returned prematurely (%lu)",
		    pf_key_v2_socket, (unsigned long) n);
		goto cleanup;
	}
	free(iov);
	return msg->sadb_msg_seq;

cleanup:
	free(iov);
	return 0;
}

/*
 * Do a PF_KEY "call", i.e. write a message MSG, read the reply and return
 * it to the caller.
 */
static struct pf_key_v2_msg *
pf_key_v2_call(struct pf_key_v2_msg *msg)
{
	u_int32_t       seq;

	seq = pf_key_v2_write(msg);
	if (!seq)
		return 0;
	return pf_key_v2_read(seq);
}

/* Find the TYPE extension in MSG.  Return zero if none found.  */
static struct pf_key_v2_node *
pf_key_v2_find_ext(struct pf_key_v2_msg *msg, u_int16_t type)
{
	struct pf_key_v2_node *ext;

	for (ext = TAILQ_NEXT(TAILQ_FIRST(msg), link); ext;
	    ext = TAILQ_NEXT(ext, link))
		if (ext->type == type)
			return ext;
	return 0;
}

/*
 * Open the PF_KEYv2 sockets and return the descriptor used for notifies.
 * Return -1 for failure and -2 if no notifies will show up.
 */
int
pf_key_v2_open(void)
{
	int		fd = -1, err;
	struct sadb_msg msg;
	struct pf_key_v2_msg *regmsg = 0, *ret = 0;

	/* Open the socket we use to speak to IPsec. */
	pf_key_v2_socket = -1;
	fd = socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
	if (fd == -1) {
		log_error("pf_key_v2_open: "
		    "socket (PF_KEY, SOCK_RAW, PF_KEY_V2) failed");
		goto cleanup;
	}
	pf_key_v2_socket = fd;

	/* Register it to get ESP and AH acquires from the kernel.  */
	msg.sadb_msg_seq = 0;
	msg.sadb_msg_type = SADB_REGISTER;
	msg.sadb_msg_satype = SADB_SATYPE_ESP;
	regmsg = pf_key_v2_msg_new(&msg, 0);
	if (!regmsg)
		goto cleanup;
	ret = pf_key_v2_call(regmsg);
	pf_key_v2_msg_free(regmsg);
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		log_print("pf_key_v2_open: REGISTER: %s", strerror(err));
		goto cleanup;
	}
	/* XXX Register the accepted transforms.  */

	pf_key_v2_msg_free(ret);
	ret = 0;

	msg.sadb_msg_seq = 0;
	msg.sadb_msg_type = SADB_REGISTER;
	msg.sadb_msg_satype = SADB_SATYPE_AH;
	regmsg = pf_key_v2_msg_new(&msg, 0);
	if (!regmsg)
		goto cleanup;
	ret = pf_key_v2_call(regmsg);
	pf_key_v2_msg_free(regmsg);
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		log_print("pf_key_v2_open: REGISTER: %s", strerror(err));
		goto cleanup;
	}
	/* XXX Register the accepted transforms.  */

	pf_key_v2_msg_free(ret);
	ret = 0;

	msg.sadb_msg_seq = 0;
	msg.sadb_msg_type = SADB_REGISTER;
	msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
	regmsg = pf_key_v2_msg_new(&msg, 0);
	if (!regmsg)
		goto cleanup;
	ret = pf_key_v2_call(regmsg);
	pf_key_v2_msg_free(regmsg);
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		log_print("pf_key_v2_open: REGISTER: %s", strerror(err));
		goto cleanup;
	}
	/* XXX Register the accepted transforms.  */

	pf_key_v2_msg_free(ret);

	return fd;

cleanup:
	if (pf_key_v2_socket != -1) {
		close(pf_key_v2_socket);
		pf_key_v2_socket = -1;
	}
	if (ret)
		pf_key_v2_msg_free(ret);
	return -1;
}

/*
 * Generate a SPI for protocol PROTO and the source/destination pair given by
 * SRC, SRCLEN, DST & DSTLEN.  Stash the SPI size in SZ.
 */
u_int8_t *
pf_key_v2_get_spi(size_t *sz, u_int8_t proto, struct sockaddr *src,
    struct sockaddr *dst, u_int32_t seq)
{
	struct sadb_msg msg;
	struct sadb_sa *sa;
	struct sadb_address *addr = 0;
	struct sadb_spirange spirange;
	struct pf_key_v2_msg *getspi = 0, *ret = 0;
	struct pf_key_v2_node *ext;
	u_int8_t       *spi = 0;
	int		len, err;

	msg.sadb_msg_type = SADB_GETSPI;
	switch (proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		msg.sadb_msg_satype = SADB_SATYPE_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		msg.sadb_msg_satype = SADB_SATYPE_AH;
		break;
	case IPSEC_PROTO_IPCOMP:
		msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		break;
	default:
		log_print("pf_key_v2_get_spi: invalid proto %d", proto);
		goto cleanup;
	}

	/* Set the sequence number from the ACQUIRE message. */
	msg.sadb_msg_seq = seq;
	getspi = pf_key_v2_msg_new(&msg, 0);
	if (!getspi)
		goto cleanup;

	/* Setup the ADDRESS extensions.  */
	len =
	    sizeof(struct sadb_address) + PF_KEY_V2_ROUND(SA_LEN(src));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, src, SA_LEN(src));
	switch (((struct sockaddr *) (addr + 1))->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(getspi, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	len = sizeof(struct sadb_address) + PF_KEY_V2_ROUND(SA_LEN(dst));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, dst, SA_LEN(dst));
	switch (((struct sockaddr *) (addr + 1))->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(getspi, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	/* Setup the SPIRANGE extension.  */
	spirange.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
	spirange.sadb_spirange_len = sizeof spirange / PF_KEY_V2_CHUNK;
	if (proto == IPSEC_PROTO_IPCOMP) {
		spirange.sadb_spirange_min = CPI_RESERVED_MAX + 1;
		spirange.sadb_spirange_max = CPI_PRIVATE_MIN - 1;
	} else {
		spirange.sadb_spirange_min = IPSEC_SPI_LOW;
		spirange.sadb_spirange_max = 0xffffffff;
	}
	spirange.sadb_spirange_reserved = 0;
	if (pf_key_v2_msg_add(getspi, (struct sadb_ext *)&spirange, 0) == -1)
		goto cleanup;

	ret = pf_key_v2_call(getspi);
	pf_key_v2_msg_free(getspi);
	getspi = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		log_print("pf_key_v2_get_spi: GETSPI: %s", strerror(err));
		goto cleanup;
	}
	ext = pf_key_v2_find_ext(ret, SADB_EXT_SA);
	if (!ext) {
		log_print("pf_key_v2_get_spi: no SA extension found");
		goto cleanup;
	}
	sa = ext->seg;

	/* IPCOMP CPIs are only 16 bits long.  */
	*sz = (proto == IPSEC_PROTO_IPCOMP) ? sizeof(u_int16_t)
		: sizeof sa->sadb_sa_spi;
	spi = malloc(*sz);
	if (!spi)
		goto cleanup;
	/* XXX This is ugly.  */
	if (proto == IPSEC_PROTO_IPCOMP) {
		u_int32_t       tspi = ntohl(sa->sadb_sa_spi);
		*(u_int16_t *) spi = htons((u_int16_t) tspi);
	} else
		memcpy(spi, &sa->sadb_sa_spi, *sz);

	pf_key_v2_msg_free(ret);

	LOG_DBG_BUF((LOG_SYSDEP, 50, "pf_key_v2_get_spi: spi", spi, *sz));
	return spi;

cleanup:
	free(spi);
	free(addr);
	if (getspi)
		pf_key_v2_msg_free(getspi);
	if (ret)
		pf_key_v2_msg_free(ret);
	return 0;
}

/* Fetch SA information from the kernel. XXX OpenBSD only?  */
struct sa_kinfo *
pf_key_v2_get_kernel_sa(u_int8_t *spi, size_t spi_sz, u_int8_t proto,
    struct sockaddr *dst)
{
	struct sadb_msg msg;
	struct sadb_sa *ssa;
	struct sadb_address *addr = 0;
	struct sockaddr *sa;
	struct sadb_lifetime *life;
	struct pf_key_v2_msg *gettdb = 0, *ret = 0;
	struct pf_key_v2_node *ext;
	static struct sa_kinfo ksa;
	struct sadb_x_udpencap *udpencap;
	int len, err;

	if (spi_sz != sizeof (ssa->sadb_sa_spi))
		return 0;

	msg.sadb_msg_type = SADB_GET;
	switch (proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		msg.sadb_msg_satype = SADB_SATYPE_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		msg.sadb_msg_satype = SADB_SATYPE_AH;
		break;
	case IPSEC_PROTO_IPCOMP:
		msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		break;
	default:
		log_print("pf_key_v2_get_kernel_sa: invalid proto %d", proto);
		goto cleanup;
	}

	gettdb = pf_key_v2_msg_new(&msg, 0);
	if (!gettdb)
		goto cleanup;

	/* SPI */
	ssa = calloc(1, sizeof *ssa);
	if (!ssa) {
		log_print("pf_key_v2_get_kernel_sa: calloc(1, %lu) failed",
		    (unsigned long)sizeof *ssa);
		goto cleanup;
	}

	ssa->sadb_sa_exttype = SADB_EXT_SA;
	ssa->sadb_sa_len = sizeof *ssa / PF_KEY_V2_CHUNK;
	memcpy(&ssa->sadb_sa_spi, spi, sizeof ssa->sadb_sa_spi);
	ssa->sadb_sa_state = SADB_SASTATE_MATURE;
	if (pf_key_v2_msg_add(gettdb, (struct sadb_ext *)ssa,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	ssa = 0;

	/* Address */
	len =
	    sizeof(struct sadb_address) + PF_KEY_V2_ROUND(SA_LEN(dst));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, dst, SA_LEN(dst));
	switch (((struct sockaddr *) (addr + 1))->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(gettdb, (struct sadb_ext *)addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	ret = pf_key_v2_call(gettdb);
	pf_key_v2_msg_free(gettdb);
	gettdb = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		log_print("pf_key_v2_get_kernel_sa: SADB_GET: %s",
		    strerror(err));
		goto cleanup;
	}

	/* Extract the data.  */
	bzero(&ksa, sizeof ksa);

	ext = pf_key_v2_find_ext(ret, SADB_EXT_SA);
	if (!ext)
		goto cleanup;

	ssa = (struct sadb_sa *)ext;
	ksa.spi = ssa->sadb_sa_spi;
	ksa.wnd = ssa->sadb_sa_replay;
	ksa.flags = ssa->sadb_sa_flags;

	ext = pf_key_v2_find_ext(ret, SADB_EXT_LIFETIME_CURRENT);
	if (ext) {
		life = (struct sadb_lifetime *)ext->seg;
		ksa.cur_allocations = life->sadb_lifetime_allocations;
		ksa.cur_bytes =	life->sadb_lifetime_bytes;
		ksa.first_use = life->sadb_lifetime_usetime;
		ksa.established = life->sadb_lifetime_addtime;
	}

	ext = pf_key_v2_find_ext(ret, SADB_EXT_LIFETIME_SOFT);
	if (ext) {
		life = (struct sadb_lifetime *)ext->seg;
		ksa.soft_allocations = life->sadb_lifetime_allocations;
		ksa.soft_bytes = life->sadb_lifetime_bytes;
		ksa.soft_timeout = life->sadb_lifetime_addtime;
		ksa.soft_first_use = life->sadb_lifetime_usetime;
	}

	ext = pf_key_v2_find_ext(ret, SADB_EXT_LIFETIME_HARD);
	if (ext) {
		life = (struct sadb_lifetime *)ext->seg;
		ksa.exp_allocations = life->sadb_lifetime_allocations;
		ksa.exp_bytes = life->sadb_lifetime_bytes;
		ksa.exp_timeout = life->sadb_lifetime_addtime;
		ksa.exp_first_use = life->sadb_lifetime_usetime;
	}

	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_LIFETIME_LASTUSE);
	if (ext) {
		life = (struct sadb_lifetime *)ext->seg;
		ksa.last_used = life->sadb_lifetime_usetime;
	}

	ext = pf_key_v2_find_ext(ret, SADB_EXT_ADDRESS_SRC);
	if (ext) {
		sa = (struct sockaddr *)ext->seg;
		memcpy(&ksa.src, sa,
		    sa->sa_family == AF_INET ? sizeof(struct sockaddr_in) :
		    sizeof(struct sockaddr_in6));
	}

	ext = pf_key_v2_find_ext(ret, SADB_EXT_ADDRESS_DST);
	if (ext) {
		sa = (struct sockaddr *)ext->seg;
		memcpy(&ksa.dst, sa,
		    sa->sa_family == AF_INET ? sizeof(struct sockaddr_in) :
		    sizeof(struct sockaddr_in6));
	}

	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_UDPENCAP);
	if (ext) {
		udpencap = (struct sadb_x_udpencap *)ext->seg;
		ksa.udpencap_port = udpencap->sadb_x_udpencap_port;
	}

	pf_key_v2_msg_free(ret);

	LOG_DBG_BUF((LOG_SYSDEP, 50, "pf_key_v2_get_kernel_sa: spi", spi,
	    spi_sz));

	return &ksa;

  cleanup:
	free(addr);
	if (gettdb)
		pf_key_v2_msg_free(gettdb);
	if (ret)
		pf_key_v2_msg_free(ret);
	return 0;
}

static void
pf_key_v2_setup_sockaddr(void *res, struct sockaddr *src,
    struct sockaddr *dst, in_port_t port, int ingress)
{
	struct sockaddr_in *ip4_sa;
	struct sockaddr_in6 *ip6_sa;
	u_int8_t       *p;

	switch (src->sa_family) {
	case AF_INET:
		ip4_sa = (struct sockaddr_in *) res;
		ip4_sa->sin_family = AF_INET;
		ip4_sa->sin_len = sizeof *ip4_sa;
		ip4_sa->sin_port = port;
		if (dst)
			p = (u_int8_t *) (ingress ?
			    &((struct sockaddr_in *)src)->sin_addr.s_addr :
			    &((struct sockaddr_in *)dst)->sin_addr.s_addr);
		else
			p = (u_int8_t *)&((struct sockaddr_in *)src)->sin_addr.s_addr;
		ip4_sa->sin_addr.s_addr = *((in_addr_t *) p);
		break;

	case AF_INET6:
		ip6_sa = (struct sockaddr_in6 *) res;
		ip6_sa->sin6_family = AF_INET6;
		ip6_sa->sin6_len = sizeof *ip6_sa;
		ip6_sa->sin6_port = port;
		if (dst)
			p = (u_int8_t *) (ingress ?
			    &((struct sockaddr_in6 *)src)->sin6_addr.s6_addr :
			    &((struct sockaddr_in6 *)dst)->sin6_addr.s6_addr);
		else
			p = (u_int8_t *)&((struct sockaddr_in6 *)src)->sin6_addr.s6_addr;
		memcpy(ip6_sa->sin6_addr.s6_addr, p, sizeof(struct in6_addr));
		break;

	default:
		log_print("pf_key_v2_setup_sockaddr: unknown family %d\n",
		    src->sa_family);
		break;
	}
}

/*
 * Store/update a PF_KEY_V2 security association with full information from the
 * IKE SA and PROTO into the kernel.  INCOMING is set if we are setting the
 * parameters for the incoming SA, and cleared otherwise.
 */
int
pf_key_v2_set_spi(struct sa *sa, struct proto *proto, int incoming,
    struct sa *isakmp_sa)
{
	struct sadb_msg msg;
	struct sadb_sa  ssa;
	struct sadb_x_tag *stag = NULL;
	struct sadb_lifetime *life = 0;
	struct sadb_address *addr = 0;
	struct sadb_key *key = 0;
	struct sadb_ident *sid = 0;
	struct sockaddr *src, *dst;
	struct pf_key_v2_msg *update = 0, *ret = 0;
	struct ipsec_proto *iproto = proto->data;
	size_t		len;
	int		keylen, hashlen, err;
	u_int8_t       *pp;
	int		idtype;
	struct ipsec_sa *isa = sa->data;
	struct sadb_protocol flowtype, tprotocol;
	struct sadb_x_udpencap udpencap;
	char           *addr_str, *s;

	msg.sadb_msg_type = incoming ? SADB_UPDATE : SADB_ADD;
	switch (proto->proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		msg.sadb_msg_satype = SADB_SATYPE_ESP;
		keylen = ipsec_esp_enckeylength(proto);
		hashlen = ipsec_esp_authkeylength(proto);

		switch (proto->id) {
		case IPSEC_ESP_3DES:
			ssa.sadb_sa_encrypt = SADB_EALG_3DESCBC;
			break;

		case IPSEC_ESP_AES:
			ssa.sadb_sa_encrypt = SADB_X_EALG_AES;
			break;

		case IPSEC_ESP_AES_CTR:
			ssa.sadb_sa_encrypt = SADB_X_EALG_AESCTR;
			break;

		case IPSEC_ESP_AES_GCM_16:
			ssa.sadb_sa_encrypt = SADB_X_EALG_AESGCM16;
			break;

		case IPSEC_ESP_AES_GMAC:
			ssa.sadb_sa_encrypt = SADB_X_EALG_AESGMAC;
			break;

		case IPSEC_ESP_CAST:
			ssa.sadb_sa_encrypt = SADB_X_EALG_CAST;
			break;

		case IPSEC_ESP_BLOWFISH:
			ssa.sadb_sa_encrypt = SADB_X_EALG_BLF;
			break;

		case IPSEC_ESP_NULL:
			ssa.sadb_sa_encrypt = SADB_EALG_NULL;
			break;

		default:
			LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_set_spi: "
			    "unknown encryption algorithm %d", proto->id));
			return -1;
		}

		switch (iproto->auth) {
		case IPSEC_AUTH_HMAC_MD5:
			ssa.sadb_sa_auth = SADB_AALG_MD5HMAC;
			break;

		case IPSEC_AUTH_HMAC_SHA:
			ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
			break;

		case IPSEC_AUTH_HMAC_RIPEMD:
			ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
			break;

		case IPSEC_AUTH_HMAC_SHA2_256:
			ssa.sadb_sa_auth = SADB_X_AALG_SHA2_256;
			break;

		case IPSEC_AUTH_HMAC_SHA2_384:
			ssa.sadb_sa_auth = SADB_X_AALG_SHA2_384;
			break;

		case IPSEC_AUTH_HMAC_SHA2_512:
			ssa.sadb_sa_auth = SADB_X_AALG_SHA2_512;
			break;

		case IPSEC_AUTH_DES_MAC:
		case IPSEC_AUTH_KPDK:
			/* XXX We should be supporting KPDK */
			LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_set_spi: "
			    "unknown authentication algorithm %d",
			    iproto->auth));
			return -1;

		default:
			ssa.sadb_sa_auth = SADB_AALG_NONE;
		}
		break;

	case IPSEC_PROTO_IPSEC_AH:
		msg.sadb_msg_satype = SADB_SATYPE_AH;
		hashlen = ipsec_ah_keylength(proto);
		keylen = 0;

		ssa.sadb_sa_encrypt = SADB_EALG_NONE;
		switch (proto->id) {
		case IPSEC_AH_MD5:
			ssa.sadb_sa_auth = SADB_AALG_MD5HMAC;
			break;

		case IPSEC_AH_SHA:
			ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
			break;

		case IPSEC_AH_RIPEMD:
			ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
			break;

		case IPSEC_AH_SHA2_256:
			ssa.sadb_sa_auth = SADB_X_AALG_SHA2_256;
			break;

		case IPSEC_AH_SHA2_384:
			ssa.sadb_sa_auth = SADB_X_AALG_SHA2_384;
			break;

		case IPSEC_AH_SHA2_512:
			ssa.sadb_sa_auth = SADB_X_AALG_SHA2_512;
			break;

		default:
			LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_set_spi: "
			    "unknown authentication algorithm %d", proto->id));
			goto cleanup;
		}
		break;

	case IPSEC_PROTO_IPCOMP:
		msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		ssa.sadb_sa_auth = SADB_AALG_NONE;
		keylen = 0;
		hashlen = 0;

		/*
		 * Put compression algorithm type in the sadb_sa_encrypt
		 * field.
		 */
		switch (proto->id) {
		case IPSEC_IPCOMP_OUI:
			ssa.sadb_sa_encrypt = SADB_X_CALG_OUI;
			break;

		case IPSEC_IPCOMP_DEFLATE:
			ssa.sadb_sa_encrypt = SADB_X_CALG_DEFLATE;
			break;

		case IPSEC_IPCOMP_LZS:
			ssa.sadb_sa_encrypt = SADB_X_CALG_LZS;
			break;

		default:
			break;
		}
		break;

	default:
		log_print("pf_key_v2_set_spi: invalid proto %d", proto->proto);
		goto cleanup;
	}
	if (incoming)
		sa->transport->vtbl->get_src(sa->transport, &dst);
	else
		sa->transport->vtbl->get_dst(sa->transport, &dst);
	msg.sadb_msg_seq = sa->seq;
	update = pf_key_v2_msg_new(&msg, 0);
	if (!update)
		goto cleanup;

	/* Setup the rest of the SA extension.  */
	ssa.sadb_sa_exttype = SADB_EXT_SA;
	ssa.sadb_sa_len = sizeof ssa / PF_KEY_V2_CHUNK;
	if (proto->spi_sz[incoming] == 2)	/* IPCOMP uses 16bit CPIs.  */
		ssa.sadb_sa_spi = htonl(proto->spi[incoming][0] << 8 |
		    proto->spi[incoming][1]);
	else
		memcpy(&ssa.sadb_sa_spi, proto->spi[incoming],
		    sizeof ssa.sadb_sa_spi);
	ssa.sadb_sa_replay = conf_get_str("General", "Shared-SADB") ? 0 :
	    iproto->replay_window;
	ssa.sadb_sa_state = SADB_SASTATE_MATURE;
	ssa.sadb_sa_flags = 0;
	if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL ||
	    iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TUNNEL ||
	    iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TUNNEL_DRAFT)
		ssa.sadb_sa_flags = SADB_X_SAFLAGS_TUNNEL;

	if (isakmp_sa->flags & SA_FLAG_NAT_T_ENABLE) {
		bzero(&udpencap, sizeof udpencap);
		ssa.sadb_sa_flags |= SADB_X_SAFLAGS_UDPENCAP;
		udpencap.sadb_x_udpencap_exttype = SADB_X_EXT_UDPENCAP;
		udpencap.sadb_x_udpencap_len =
		    sizeof udpencap / PF_KEY_V2_CHUNK;
		udpencap.sadb_x_udpencap_port = sockaddr_port(dst);
		if (pf_key_v2_msg_add(update, (struct sadb_ext *)&udpencap, 0)
		    == -1)
			goto cleanup;
	}

	if (pf_key_v2_msg_add(update, (struct sadb_ext *)&ssa, 0) == -1)
		goto cleanup;

	if (sa->seconds || sa->kilobytes) {
		/* Setup the hard limits.  */
		life = malloc(sizeof *life);
		if (!life)
			goto cleanup;
		life->sadb_lifetime_len = sizeof *life / PF_KEY_V2_CHUNK;
		life->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
		life->sadb_lifetime_allocations = 0;
		life->sadb_lifetime_bytes = sa->kilobytes * 1024;
		/*
		 * XXX I am not sure which one is best in security respect.
		 * Maybe the RFCs actually mandate what a lifetime really is.
		 */
#if 0
		life->sadb_lifetime_addtime = 0;
		life->sadb_lifetime_usetime = sa->seconds;
#else
		life->sadb_lifetime_addtime = sa->seconds;
		life->sadb_lifetime_usetime = 0;
#endif
		if (pf_key_v2_msg_add(update, (struct sadb_ext *) life,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
		life = 0;

		/*
		 * Setup the soft limits, we use 90 % of the hard ones.
		 * XXX A configurable ratio would be better.
		 */
		life = malloc(sizeof *life);
		if (!life)
			goto cleanup;
		life->sadb_lifetime_len = sizeof *life / PF_KEY_V2_CHUNK;
		life->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
		life->sadb_lifetime_allocations = 0;
		life->sadb_lifetime_bytes = sa->kilobytes * 1024 * 9 / 10;
		/*
		 * XXX I am not sure which one is best in security respect.
		 * Maybe the RFCs actually mandate what a lifetime really is.
		 */
#if 0
		life->sadb_lifetime_addtime = 0;
		life->sadb_lifetime_usetime = sa->seconds * 9 / 10;
#else
		life->sadb_lifetime_addtime = sa->seconds * 9 / 10;
		life->sadb_lifetime_usetime = 0;
#endif
		if (pf_key_v2_msg_add(update, (struct sadb_ext *) life,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
		life = 0;
	}
	/*
	 * Setup the ADDRESS extensions.
	 */
	if (incoming)
		sa->transport->vtbl->get_dst(sa->transport, &src);
	else
		sa->transport->vtbl->get_src(sa->transport, &src);
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(src));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, src, SA_LEN(src));
	switch (((struct sockaddr *) (addr + 1))->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(dst));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, dst, SA_LEN(dst));
	switch (((struct sockaddr *) (addr + 1))->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	if (proto->proto != IPSEC_PROTO_IPCOMP) {
		/* Setup the KEY extensions.  */
		if (hashlen) {
			len = sizeof *key + PF_KEY_V2_ROUND(hashlen);
			key = malloc(len);
			if (!key)
				goto cleanup;
			key->sadb_key_exttype = SADB_EXT_KEY_AUTH;
			key->sadb_key_len = len / PF_KEY_V2_CHUNK;
			key->sadb_key_bits = hashlen * 8;
			key->sadb_key_reserved = 0;
			memcpy(key + 1,
			    iproto->keymat[incoming] +
			    (proto->proto ==
				IPSEC_PROTO_IPSEC_ESP ? keylen : 0),
			    hashlen);
			if (pf_key_v2_msg_add(update, (struct sadb_ext *) key,
			    PF_KEY_V2_NODE_MALLOCED) == -1)
				goto cleanup;
			key = 0;
		}
		if (keylen) {
			len = sizeof *key + PF_KEY_V2_ROUND(keylen);
			key = malloc(len);
			if (!key)
				goto cleanup;
			key->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
			key->sadb_key_len = len / PF_KEY_V2_CHUNK;
			key->sadb_key_bits = keylen * 8;
			key->sadb_key_reserved = 0;
			memcpy(key + 1, iproto->keymat[incoming], keylen);
			if (pf_key_v2_msg_add(update, (struct sadb_ext *) key,
			    PF_KEY_V2_NODE_MALLOCED) == -1)
				goto cleanup;
			key = 0;
		}
	}
	/* Setup identity extensions. */
	if (isakmp_sa->id_i) {
		pp = pf_key_v2_convert_id(isakmp_sa->id_i, isakmp_sa->id_i_len,
		    &len, &idtype);
		if (!pp)
			goto nosid;

		sid = calloc(PF_KEY_V2_ROUND(len + 1) + sizeof *sid,
		    sizeof(u_int8_t));
		if (!sid) {
			free(pp);
			goto cleanup;
		}
		sid->sadb_ident_type = idtype;
		sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK) +
		    PF_KEY_V2_ROUND(len + 1) / PF_KEY_V2_CHUNK;
		if ((isakmp_sa->initiator && !incoming) ||
		    (!isakmp_sa->initiator && incoming))
			sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;
		else
			sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;

		memcpy(sid + 1, pp, len);
		free(pp);

		if (pf_key_v2_msg_add(update, (struct sadb_ext *) sid,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
		sid = 0;

nosid:
		free(sid);
		sid = 0;
	}
	if (isakmp_sa->id_r) {
		pp = pf_key_v2_convert_id(isakmp_sa->id_r, isakmp_sa->id_r_len,
		    &len, &idtype);
		if (!pp)
			goto nodid;

		sid = calloc(PF_KEY_V2_ROUND(len + 1) + sizeof *sid,
		    sizeof(u_int8_t));
		if (!sid) {
			free(pp);
			goto cleanup;
		}
		sid->sadb_ident_type = idtype;
		sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK) +
		    PF_KEY_V2_ROUND(len + 1) / PF_KEY_V2_CHUNK;
		if ((isakmp_sa->initiator && !incoming) ||
		    (!isakmp_sa->initiator && incoming))
			sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;
		else
			sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;

		memcpy(sid + 1, pp, len);
		free(pp);

		if (pf_key_v2_msg_add(update, (struct sadb_ext *) sid,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
		sid = 0;

nodid:
		free(sid);
		sid = 0;
	}

	/* Setup the flow type extension.  */
	bzero(&flowtype, sizeof flowtype);
	flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
	flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK;
	flowtype.sadb_protocol_direction = incoming ?
	    IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;

	if (pf_key_v2_msg_add(update, (struct sadb_ext *)&flowtype, 0) == -1)
		goto cleanup;

	bzero(&tprotocol, sizeof tprotocol);
	tprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	tprotocol.sadb_protocol_len = sizeof tprotocol / PF_KEY_V2_CHUNK;
	tprotocol.sadb_protocol_proto = isa->tproto;

	if (pf_key_v2_msg_add(update, (struct sadb_ext *)&tprotocol,
	    0) == -1)
		goto cleanup;

	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(isa->src_net));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = incoming ?
	    SADB_X_EXT_DST_FLOW : SADB_X_EXT_SRC_FLOW;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, isa->src_net, 0, isa->sport, 0);
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype =
		incoming ? SADB_X_EXT_DST_MASK : SADB_X_EXT_SRC_MASK;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, isa->src_mask, 0,
	    isa->sport ? 0xffff : 0, 0);
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = incoming ?
	    SADB_X_EXT_SRC_FLOW : SADB_X_EXT_DST_FLOW;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, isa->dst_net, 0, isa->dport, 0);
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype =
		incoming ? SADB_X_EXT_SRC_MASK : SADB_X_EXT_DST_MASK;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, isa->dst_mask, 0,
	    isa->dport ? 0xffff : 0, 0);
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	/* Add a pf tag to matching packets of this SA. */
	if (sa->tag != NULL) {
		len = sizeof(*stag) + PF_KEY_V2_ROUND(strlen(sa->tag) + 1);
		if ((stag = calloc(1, len)) == NULL)
			goto cleanup;
		stag->sadb_x_tag_exttype = SADB_X_EXT_TAG;
		stag->sadb_x_tag_len = len / PF_KEY_V2_CHUNK;
		stag->sadb_x_tag_taglen = strlen(sa->tag) + 1;
		s = (char *)(stag + 1);
		strlcpy(s, sa->tag, stag->sadb_x_tag_taglen);
		if (pf_key_v2_msg_add(update, (struct sadb_ext *)stag,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
	}

	/* XXX Here can sensitivity extensions be setup.  */

	if (sockaddr2text(dst, &addr_str, 0))
		addr_str = 0;

	LOG_DBG((LOG_SYSDEP, 10, "pf_key_v2_set_spi: "
	    "satype %d dst %s SPI 0x%x%s%s", msg.sadb_msg_satype,
	    addr_str ? addr_str : "unknown",
	    ntohl(ssa.sadb_sa_spi), sa->tag ? " tag " : "",
	    sa->tag ? sa->tag : ""));

	free(addr_str);

	/*
	 * Although PF_KEY knows about expirations, it is unreliable per the
	 * specs thus we need to do them inside isakmpd as well.
	 */
	if (sa->seconds)
		if (sa_setup_expirations(sa))
			goto cleanup;

	ret = pf_key_v2_call(update);
	pf_key_v2_msg_free(update);
	update = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	pf_key_v2_msg_free(ret);
	ret = 0;

	/*
	 * If we are doing an addition into an SADB shared with our peer,
	 * errors here are to be expected as the peer will already have
	 * created the SA, and can thus be ignored.
	 */
	if (err && !(msg.sadb_msg_type == SADB_ADD &&
	    conf_get_str("General", "Shared-SADB"))) {
		log_print("pf_key_v2_set_spi: %s: %s",
		    msg.sadb_msg_type == SADB_ADD ? "ADD" : "UPDATE",
		    strerror(err));
		goto cleanup;
	}
	LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_set_spi: done"));

	return 0;

cleanup:
	free(sid);
	free(addr);
	free(life);
	free(key);
	if (update)
		pf_key_v2_msg_free(update);
	if (ret)
		pf_key_v2_msg_free(ret);
	return -1;
}

static __inline__ int
pf_key_v2_mask_to_bits(u_int32_t mask)
{
	u_int32_t       hmask = ntohl(mask);

	return (33 - ffs(~hmask + 1)) % 33;
}

static int
pf_key_v2_mask6_to_bits(u_int8_t *mask)
{
	int		n;

	bit_ffc(mask, 128, &n);
	return n == -1 ? 128 : n;
}

/*
 * Enable/disable a flow.
 * XXX Assumes OpenBSD {ADD,DEL}FLOW extensions.
 */
static int
pf_key_v2_flow(struct sockaddr *laddr, struct sockaddr *lmask,
    struct sockaddr *raddr, struct sockaddr *rmask,
    u_int8_t tproto, u_int16_t sport, u_int16_t dport,
    u_int8_t *spi, u_int8_t proto, struct sockaddr *dst,
    struct sockaddr *src, int delete, int ingress,
    u_int8_t srcid_type, u_int8_t *srcid, int srcid_len,
    u_int8_t dstid_type, u_int8_t *dstid, int dstid_len,
    struct ipsec_proto *iproto)
{
	char           *laddr_str, *lmask_str, *raddr_str, *rmask_str;

	struct sadb_msg msg;
	struct sadb_protocol flowtype;
	struct sadb_ident *sid = 0;
	struct sadb_address *addr = 0;
	struct sadb_protocol tprotocol;
	struct pf_key_v2_msg *flow = 0, *ret = 0;
	size_t		len;
	int		err;

	msg.sadb_msg_type = delete ? SADB_X_DELFLOW : SADB_X_ADDFLOW;
	switch (proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		msg.sadb_msg_satype = SADB_SATYPE_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		msg.sadb_msg_satype = SADB_SATYPE_AH;
		break;
	case IPSEC_PROTO_IPCOMP:
		msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		break;
	default:
		log_print("pf_key_v2_flow: invalid proto %d", proto);
		goto cleanup;
	}
	msg.sadb_msg_seq = 0;
	flow = pf_key_v2_msg_new(&msg, 0);
	if (!flow)
		goto cleanup;

	if (!delete) {
		/* Setup the source ID, if provided. */
		if (srcid) {
			sid = calloc(
			    PF_KEY_V2_ROUND(srcid_len + 1) + sizeof *sid,
			    sizeof(u_int8_t));
			if (!sid)
				goto cleanup;

			sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
			    + PF_KEY_V2_ROUND(srcid_len + 1) / PF_KEY_V2_CHUNK;
			sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;
			sid->sadb_ident_type = srcid_type;

			memcpy(sid + 1, srcid, srcid_len);

			if (pf_key_v2_msg_add(flow, (struct sadb_ext *) sid,
			    PF_KEY_V2_NODE_MALLOCED) == -1)
				goto cleanup;

			sid = 0;
		}
		/* Setup the destination ID, if provided. */
		if (dstid) {
			sid = calloc(
			    PF_KEY_V2_ROUND(dstid_len + 1) + sizeof *sid,
			    sizeof(u_int8_t));
			if (!sid)
				goto cleanup;

			sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
			    + PF_KEY_V2_ROUND(dstid_len + 1) / PF_KEY_V2_CHUNK;
			sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;
			sid->sadb_ident_type = dstid_type;

			memcpy(sid + 1, dstid, dstid_len);

			if (pf_key_v2_msg_add(flow, (struct sadb_ext *) sid,
			    PF_KEY_V2_NODE_MALLOCED) == -1)
				goto cleanup;

			sid = 0;
		}
	}
	/* Setup the flow type extension.  */
	bzero(&flowtype, sizeof flowtype);
	flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
	flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK;
	flowtype.sadb_protocol_direction =
	    ingress ? IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;
	flowtype.sadb_protocol_proto =
	    ingress ? SADB_X_FLOW_TYPE_USE : SADB_X_FLOW_TYPE_REQUIRE;

	if (pf_key_v2_msg_add(flow, (struct sadb_ext *)&flowtype, 0) == -1)
		goto cleanup;

	/*
	 * Setup the ADDRESS extensions.
	 */
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(src));
	if (!delete)
	{
		addr = calloc(1, len);
		if (!addr)
			goto cleanup;
		addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
		addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
		addr->sadb_address_reserved = 0;
		pf_key_v2_setup_sockaddr(addr + 1, src, dst, 0, ingress);
		if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
		addr = 0;
	}
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(laddr));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, laddr, 0, sport, 0);
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_X_EXT_SRC_MASK;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, lmask, 0, sport ? 0xffff : 0, 0);
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_X_EXT_DST_FLOW;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, raddr, 0, dport, 0);
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_X_EXT_DST_MASK;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, rmask, 0, dport ? 0xffff : 0, 0);
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	/* Setup the protocol extension.  */
	bzero(&tprotocol, sizeof tprotocol);
	tprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
	tprotocol.sadb_protocol_len = sizeof tprotocol / PF_KEY_V2_CHUNK;
	tprotocol.sadb_protocol_proto = tproto;

	if (pf_key_v2_msg_add(flow, (struct sadb_ext *)&tprotocol, 0) == -1)
		goto cleanup;

	if (sockaddr2text(laddr, &laddr_str, 0))
		laddr_str = 0;
	if (sockaddr2text(lmask, &lmask_str, 0))
		lmask_str = 0;
	if (sockaddr2text(raddr, &raddr_str, 0))
		raddr_str = 0;
	if (sockaddr2text(rmask, &rmask_str, 0))
		rmask_str = 0;

	LOG_DBG((LOG_SYSDEP, 50,
	   "pf_key_v2_flow: src %s %s dst %s %s proto %u sport %u dport %u",
	 laddr_str ? laddr_str : "<??\?>", lmask_str ? lmask_str : "<??\?>",
	 raddr_str ? raddr_str : "<??\?>", rmask_str ? rmask_str : "<??\?>",
		 tproto, ntohs(sport), ntohs(dport)));

	free(laddr_str);
	free(lmask_str);
	free(raddr_str);
	free(rmask_str);

	ret = pf_key_v2_call(flow);
	pf_key_v2_msg_free(flow);
	flow = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		if (err == ESRCH)	/* These are common and usually
					 * harmless.  */
			LOG_DBG((LOG_SYSDEP, 10, "pf_key_v2_flow: %sFLOW: %s",
				 delete ? "DEL" : "ADD", strerror(err)));
		else
			log_print("pf_key_v2_flow: %sFLOW: %s",
			    delete ? "DEL" : "ADD", strerror(err));
		goto cleanup;
	}
	pf_key_v2_msg_free(ret);

	LOG_DBG((LOG_MISC, 50, "pf_key_v2_flow: %sFLOW: done",
		 delete ? "DEL" : "ADD"));

	return 0;

cleanup:
	free(sid);
	free(addr);
	if (flow)
		pf_key_v2_msg_free(flow);
	if (ret)
		pf_key_v2_msg_free(ret);
	return -1;
}

static u_int8_t *
pf_key_v2_convert_id(u_int8_t *id, int idlen, size_t *reslen, int *idtype)
{
	u_int8_t       *addr, *res = 0;
	char		addrbuf[ADDRESS_MAX + 5];

	switch (id[0]) {
	case IPSEC_ID_FQDN:
		res = calloc(idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ,
		    sizeof(u_int8_t));
		if (!res)
			return 0;

		*reslen = idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
		memcpy(res, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, *reslen);
		*idtype = SADB_IDENTTYPE_FQDN;
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: FQDN %.*s",
		    (int) *reslen, res));
		return res;

	case IPSEC_ID_USER_FQDN:
		res = calloc(idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ,
		    sizeof(u_int8_t));
		if (!res)
			return 0;

		*reslen = idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
		memcpy(res, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, *reslen);
		*idtype = SADB_IDENTTYPE_USERFQDN;
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: UFQDN %.*s",
		    (int) *reslen, res));
		return res;

	case IPSEC_ID_IPV4_ADDR:
		if (inet_ntop(AF_INET, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		    addrbuf, ADDRESS_MAX) == NULL)
			return 0;
		*reslen = strlen(addrbuf) + 3;
		strlcat(addrbuf, "/32", ADDRESS_MAX + 5);
		res = (u_int8_t *) strdup(addrbuf);
		if (!res)
			return 0;
		*idtype = SADB_IDENTTYPE_PREFIX;
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: "
		    "IPv4 address %s", res));
		return res;

	case IPSEC_ID_IPV6_ADDR:
		if (inet_ntop(AF_INET6,
		    id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		    addrbuf, ADDRESS_MAX) == NULL)
			return 0;
		*reslen = strlen(addrbuf) + 4;
		strlcat(addrbuf, "/128", ADDRESS_MAX + 5);
		res = (u_int8_t *) strdup(addrbuf);
		if (!res)
			return 0;
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: "
		    "IPv6 address %s", res));
		*idtype = SADB_IDENTTYPE_PREFIX;
		return res;

	case IPSEC_ID_IPV4_ADDR_SUBNET:	/* XXX PREFIX */
		addr = id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
		if (inet_ntop(AF_INET, addr, addrbuf, ADDRESS_MAX) == NULL)
			return 0;
		snprintf(addrbuf + strlen(addrbuf),
		    ADDRESS_MAX - strlen(addrbuf), "/%d",
		    pf_key_v2_mask_to_bits(*(u_int32_t *)(addr +
			sizeof(struct in_addr))));
		*reslen = strlen(addrbuf);
		res = (u_int8_t *) strdup(addrbuf);
		if (!res)
			return 0;
		*idtype = SADB_IDENTTYPE_PREFIX;
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: "
		    "IPv4 subnet %s", res));
		return res;

	case IPSEC_ID_IPV6_ADDR_SUBNET:	/* XXX PREFIX */
		addr = id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
		if (inet_ntop(AF_INET6, addr, addrbuf, ADDRESS_MAX) == NULL)
			return 0;
		snprintf(addrbuf + strlen(addrbuf),
		    ADDRESS_MAX - strlen(addrbuf), "/%d",
		    pf_key_v2_mask6_to_bits(addr +
			sizeof(struct in6_addr)));
		*reslen = strlen(addrbuf);
		res = (u_int8_t *) strdup(addrbuf);
		if (!res)
			return 0;
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: "
		    "IPv6 subnet %s", res));
		*idtype = SADB_IDENTTYPE_PREFIX;
		return res;

	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_DER_ASN1_DN:
	case IPSEC_ID_DER_ASN1_GN:
	case IPSEC_ID_KEY_ID:
		/* XXX Not implemented yet.  */
		return 0;
	}

	return 0;
}

/* Enable a flow given an SA.  */
int
pf_key_v2_enable_sa(struct sa *sa, struct sa *isakmp_sa)
{
	struct ipsec_sa *isa = sa->data;
	struct sockaddr *dst, *src;
	int		error;
	struct proto   *proto = TAILQ_FIRST(&sa->protos);
	int		sidtype = 0, didtype = 0;
	size_t		sidlen = 0, didlen = 0;
	u_int8_t       *sid = 0, *did = 0;

	sa->transport->vtbl->get_dst(sa->transport, &dst);
	sa->transport->vtbl->get_src(sa->transport, &src);

	if (isakmp_sa->id_i) {
		if (isakmp_sa->initiator)
			sid = pf_key_v2_convert_id(isakmp_sa->id_i,
			    isakmp_sa->id_i_len, &sidlen, &sidtype);
		else
			did = pf_key_v2_convert_id(isakmp_sa->id_i,
			    isakmp_sa->id_i_len, &didlen, &didtype);
	}
	if (isakmp_sa->id_r) {
		if (isakmp_sa->initiator)
			did = pf_key_v2_convert_id(isakmp_sa->id_r,
			    isakmp_sa->id_r_len, &didlen, &didtype);
		else
			sid = pf_key_v2_convert_id(isakmp_sa->id_r,
			    isakmp_sa->id_r_len, &sidlen, &sidtype);
	}

	error = pf_key_v2_flow(isa->src_net, isa->src_mask, isa->dst_net,
	    isa->dst_mask, isa->tproto, isa->sport, isa->dport, proto->spi[0],
	    proto->proto, dst, src, 0, 0, sidtype, sid, sidlen, didtype, did,
	    didlen, proto->data);
	if (error)
		goto cleanup;

	error = pf_key_v2_flow(isa->dst_net, isa->dst_mask, isa->src_net,
	    isa->src_mask, isa->tproto, isa->dport, isa->sport, proto->spi[1],
	    proto->proto, src, dst, 0, 1, sidtype, sid, sidlen, didtype, did,
	    didlen, proto->data);

cleanup:
	free(sid);
	free(did);

	return error;
}

/* Increase reference count of refcounted sections. */
static int
pf_key_v2_conf_refinc(int af, char *section)
{
	char		conn[22];
	int		num;

	if (!section)
		return 0;

	num = conf_get_num(section, "Refcount", 0);
	if (num == 0)
		return 0;

	snprintf(conn, sizeof conn, "%d", num + 1);
	conf_set(af, section, "Refcount", conn, 1, 0);
	return 0;
}

/*
 * Return 0 if the section didn't exist or was removed, non-zero otherwise.
 * Don't touch non-refcounted (statically defined) sections.
 */
static int
pf_key_v2_conf_refhandle(int af, char *section)
{
	char		conn[22];
	int		num;

	if (!section)
		return 0;

	num = conf_get_num(section, "Refcount", 0);
	if (num == 1) {
		conf_remove_section(af, section);
		num--;
	} else if (num != 0) {
		snprintf(conn, sizeof conn, "%d", num - 1);
		conf_set(af, section, "Refcount", conn, 1, 0);
	}
	return num;
}

/* Remove all dynamically-established configuration entries.  */
static int
pf_key_v2_remove_conf(char *section)
{
	char           *ikepeer, *localid, *remoteid, *configname;
	struct conf_list_node *attr;
	struct conf_list *attrs;
	int		af;

	if (!section)
		return 0;

	if (!conf_get_str(section, "Phase"))
		return 0;

	/* Only remove dynamically-established entries. */
	attrs = conf_get_list(section, "Flags");
	if (attrs) {
		for (attr = TAILQ_FIRST(&attrs->fields); attr;
		    attr = TAILQ_NEXT(attr, link))
			if (!strcasecmp(attr->field, "__ondemand"))
				goto passed;

		conf_free_list(attrs);
	}
	return 0;

passed:
	conf_free_list(attrs);

	af = conf_begin();

	configname = conf_get_str(section, "Configuration");
	pf_key_v2_conf_refhandle(af, configname);

	/* These are the Phase 2 Local/Remote IDs. */
	localid = conf_get_str(section, "Local-ID");
	pf_key_v2_conf_refhandle(af, localid);

	remoteid = conf_get_str(section, "Remote-ID");
	pf_key_v2_conf_refhandle(af, remoteid);

	ikepeer = conf_get_str(section, "ISAKMP-peer");

	pf_key_v2_conf_refhandle(af, section);

	if (ikepeer) {
		remoteid = conf_get_str(ikepeer, "Remote-ID");
		localid = conf_get_str(ikepeer, "ID");
		configname = conf_get_str(ikepeer, "Configuration");

		pf_key_v2_conf_refhandle(af, ikepeer);
		pf_key_v2_conf_refhandle(af, configname);

		/* Phase 1 IDs */
		pf_key_v2_conf_refhandle(af, localid);
		pf_key_v2_conf_refhandle(af, remoteid);
	}
	conf_end(af, 1);
	return 0;
}

/* Disable a flow given a SA.  */
int
pf_key_v2_disable_sa(struct sa *sa, int incoming)
{
	struct ipsec_sa *isa = sa->data;
	struct sockaddr *dst, *src;
	struct proto   *proto = TAILQ_FIRST(&sa->protos);

	sa->transport->vtbl->get_dst(sa->transport, &dst);
	sa->transport->vtbl->get_src(sa->transport, &src);

	if (!incoming)
		return pf_key_v2_flow(isa->src_net, isa->src_mask,
		    isa->dst_net, isa->dst_mask, isa->tproto, isa->sport,
		    isa->dport, proto->spi[0], proto->proto, src, dst, 1, 0,
		    0, 0, 0, 0, 0, 0, proto->data);
	else {
		return pf_key_v2_flow(isa->dst_net, isa->dst_mask,
		    isa->src_net, isa->src_mask, isa->tproto, isa->dport,
		    isa->sport, proto->spi[1], proto->proto, src, dst, 1, 1,
		    0, 0, 0, 0, 0, 0, proto->data);
	}
}

/*
 * Delete the IPsec SA represented by the INCOMING direction in protocol PROTO
 * of the IKE security association SA.  Also delete potential flows tied to it.
 */
int
pf_key_v2_delete_spi(struct sa *sa, struct proto *proto, int incoming)
{
	struct sadb_msg msg;
	struct sadb_sa  ssa;
	struct sadb_address *addr = 0;
	struct sockaddr *saddr;
	int		len, err;
	struct pf_key_v2_msg *delete = 0, *ret = 0;

	/* If it's not an established SA, don't proceed. */
	if (!(sa->flags & SA_FLAG_READY))
		return 0;

	if (sa->name && !(sa->flags & SA_FLAG_REPLACED)) {
		LOG_DBG((LOG_SYSDEP, 50,
			 "pf_key_v2_delete_spi: removing configuration %s",
			 sa->name));
		pf_key_v2_remove_conf(sa->name);
	}
	msg.sadb_msg_type = SADB_DELETE;
	switch (proto->proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		msg.sadb_msg_satype = SADB_SATYPE_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		msg.sadb_msg_satype = SADB_SATYPE_AH;
		break;
	case IPSEC_PROTO_IPCOMP:
		msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		break;
	default:
		log_print("pf_key_v2_delete_spi: invalid proto %d",
		    proto->proto);
		goto cleanup;
	}
	msg.sadb_msg_seq = 0;
	delete = pf_key_v2_msg_new(&msg, 0);
	if (!delete)
		goto cleanup;

	/* Setup the SA extension.  */
	ssa.sadb_sa_exttype = SADB_EXT_SA;
	ssa.sadb_sa_len = sizeof ssa / PF_KEY_V2_CHUNK;
	memcpy(&ssa.sadb_sa_spi, proto->spi[incoming], sizeof ssa.sadb_sa_spi);
	ssa.sadb_sa_replay = 0;
	ssa.sadb_sa_state = 0;
	ssa.sadb_sa_auth = 0;
	ssa.sadb_sa_encrypt = 0;
	ssa.sadb_sa_flags = 0;
	if (pf_key_v2_msg_add(delete, (struct sadb_ext *)&ssa, 0) == -1)
		goto cleanup;

	/*
	 * Setup the ADDRESS extensions.
	 */
	if (incoming)
		sa->transport->vtbl->get_dst(sa->transport, &saddr);
	else
		sa->transport->vtbl->get_src(sa->transport, &saddr);
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(saddr));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, saddr, SA_LEN(saddr));
	switch (saddr->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(delete, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	if (incoming)
		sa->transport->vtbl->get_src(sa->transport, &saddr);
	else
		sa->transport->vtbl->get_dst(sa->transport, &saddr);
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(saddr));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, saddr, SA_LEN(saddr));
	switch (saddr->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) (addr + 1))->sin_port = 0;
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
		break;
	}
	if (pf_key_v2_msg_add(delete, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	ret = pf_key_v2_call(delete);
	pf_key_v2_msg_free(delete);
	delete = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		LOG_DBG((LOG_SYSDEP, 10, "pf_key_v2_delete_spi: DELETE: %s",
			 strerror(err)));
		goto cleanup;
	}
	pf_key_v2_msg_free(ret);

	LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_delete_spi: done"));

	return 0;

cleanup:
	free(addr);
	if (delete)
		pf_key_v2_msg_free(delete);
	if (ret)
		pf_key_v2_msg_free(ret);
	return -1;
}

static void
pf_key_v2_stayalive(struct exchange *exchange, void *vconn, int fail)
{
	char           *conn = vconn;
	struct sa      *sa;

	/* XXX What if it is phase 1 ? */
	sa = sa_lookup_by_name(conn, 2);
	if (sa)
		sa->flags |= SA_FLAG_STAYALIVE;

	/*
	 * Remove failed configuration entry -- call twice because it is
	 * created with a Refcount of 2.
	 */
	if (fail && (!exchange || exchange->name)) {
		pf_key_v2_remove_conf(conn);
		pf_key_v2_remove_conf(conn);
	}
}

/* Check if a connection CONN exists, otherwise establish it.  */
void
pf_key_v2_connection_check(char *conn)
{
	if (!sa_lookup_by_name(conn, 2)) {
		LOG_DBG((LOG_SYSDEP, 70,
		    "pf_key_v2_connection_check: SA for %s missing", conn));
		exchange_establish(conn, pf_key_v2_stayalive, conn, 0);
	} else
		LOG_DBG((LOG_SYSDEP, 70, "pf_key_v2_connection_check: "
		    "SA for %s exists", conn));
}

/* Handle a PF_KEY lifetime expiration message PMSG.  */
static void
pf_key_v2_expire(struct pf_key_v2_msg *pmsg)
{
	struct sadb_msg *msg;
	struct sadb_sa *ssa;
	struct sadb_address *dst;
	struct sockaddr *dstaddr;
	struct sadb_lifetime *life, *lifecurrent;
	struct sa      *sa;
	struct pf_key_v2_node *lifenode, *ext;
	char           *dst_str;

	msg = (struct sadb_msg *)TAILQ_FIRST(pmsg)->seg;
	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_SA);
	if (!ext) {
		log_print("pf_key_v2_expire: no SA extension found");
		return;
	}
	ssa = ext->seg;
	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_ADDRESS_DST);
	if (!ext) {
		log_print("pf_key_v2_expire: "
		    "no destination address extension found");
		return;
	}
	dst = ext->seg;
	dstaddr = (struct sockaddr *) (dst + 1);
	lifenode = pf_key_v2_find_ext(pmsg, SADB_EXT_LIFETIME_HARD);
	if (!lifenode)
		lifenode = pf_key_v2_find_ext(pmsg, SADB_EXT_LIFETIME_SOFT);
	if (!lifenode) {
		log_print("pf_key_v2_expire: no lifetime extension found");
		return;
	}
	life = lifenode->seg;

	lifenode = pf_key_v2_find_ext(pmsg, SADB_EXT_LIFETIME_CURRENT);
	if (!lifenode) {
		log_print("pf_key_v2_expire: "
		    "no current lifetime extension found");
		return;
	}
	lifecurrent = lifenode->seg;

	if (sockaddr2text(dstaddr, &dst_str, 0))
		dst_str = 0;

	LOG_DBG((LOG_SYSDEP, 20, "pf_key_v2_expire: "
	    "%s dst %s SPI %x sproto %d",
	    life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ? "SOFT"
	    : "HARD", dst_str ? dst_str : "<unknown>",
	    ntohl(ssa->sadb_sa_spi), msg->sadb_msg_satype));

	free(dst_str);

	/*
	 * Find the IPsec SA.  The IPsec stack has two SAs for every IKE SA,
	 * one outgoing and one incoming, we regard expirations for any of
	 * them as an expiration of the full IKE SA.  Likewise, in
	 * protection suites consisting of more than one protocol, any
	 * expired individual IPsec stack SA will be seen as an expiration
	 * of the full suite.
	 */
	switch (msg->sadb_msg_satype) {
	case SADB_SATYPE_ESP:
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi,
		    IPSEC_PROTO_IPSEC_ESP);
		break;

	case SADB_SATYPE_AH:
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi,
		    IPSEC_PROTO_IPSEC_AH);
		break;

	case SADB_X_SATYPE_IPCOMP:
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi,
		    IPSEC_PROTO_IPCOMP);
		break;

	default:
		/* XXX Log? */
		sa = 0;
		break;
	}

	/* If the SA is already gone, don't do anything.  */
	if (!sa)
		return;

	/*
	 * If we got a notification, try to renegotiate the SA -- unless of
	 * course it has already been replaced by another.
	 * Also, ignore SAs that were not dynamically established, or that
	 * did not see any use.
	 */
	if (!(sa->flags & SA_FLAG_REPLACED) &&
	    (sa->flags & SA_FLAG_ONDEMAND) &&
	    lifecurrent->sadb_lifetime_bytes)
		exchange_establish(sa->name, 0, 0, 0);

	if (life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_HARD) {
		/* Remove the old SA, it isn't useful anymore.  */
		sa_free(sa);
	}
}

static int
mask4len(const struct sockaddr_in *mask)
{
	int len;
	u_int32_t m;

	len = 0;
	for (m = 0x80000000; m & ntohl(mask->sin_addr.s_addr); m >>= 1)
		len++;
	if (len == 32)
		len = -1;
	return len;
}

#ifndef s6_addr8
#define s6_addr8 __u6_addr.__u6_addr8
#endif

static int
mask6len(const struct sockaddr_in6 *mask)
{
	int i, len;
	u_int8_t m;

	len = 0;
	for (i = 0, m = 0; i < 16 && !m; i++)
		for (m = 0x80; m & mask->sin6_addr.s6_addr8[i]; m >>= 1)
			len++;
	if (len == 128)
		len = -1;
	return len;
}

static int
phase2id(char *str, size_t size, const char *side, const char *sflow,
    int masklen, u_int8_t proto, u_int16_t port)
{
	char smasklen[10], sproto[10], sport[10];

	smasklen[0] = sproto[0] = sport[0] = 0;
	if (masklen != -1)
		snprintf(smasklen, sizeof smasklen, "/%d", masklen);
	if (proto)
		snprintf(sproto, sizeof sproto, "=%u", proto);
	if (port)
		snprintf(sport, sizeof sport, ":%u", ntohs(port));

	return snprintf(str, size, "%s-%s%s%s%s", side, sflow, smasklen,
	    sproto, sport);
}

/* Handle a PF_KEY SA ACQUIRE message PMSG.  */
static void
pf_key_v2_acquire(struct pf_key_v2_msg *pmsg)
{
	struct sadb_msg *msg, askpolicy_msg;
	struct pf_key_v2_msg *askpolicy = 0, *ret = 0;
	struct sadb_x_policy policy;
	struct sadb_address *dst = 0, *src = 0;
	struct sockaddr *dstaddr, *srcaddr = 0;
	struct sadb_comb *scmb = 0;
	struct sadb_prop *sprp = 0;
	struct sadb_ident *srcident = 0, *dstident = 0;
	char		dstbuf[ADDRESS_MAX], srcbuf[ADDRESS_MAX], *peer = 0;
	char		confname[120], *conn = 0;
	char           *srcid = 0, *dstid = 0, *prefstring = 0;
	int		slen, af, afamily, masklen;
	struct sockaddr *smask, *sflow, *dmask, *dflow;
	struct sadb_protocol *sproto;
	char		ssflow[ADDRESS_MAX], sdflow[ADDRESS_MAX];
	char		sdmask[ADDRESS_MAX], ssmask[ADDRESS_MAX];
	int		dmasklen, smasklen;
	char           *sidtype = 0, *didtype = 0;
	char		lname[100], dname[100], configname[200];
	int		shostflag = 0, dhostflag = 0;
	struct pf_key_v2_node *ext;
	struct passwd  *pwd = 0;
	u_int16_t       sport = 0, dport = 0;
	u_int8_t	tproto = 0;
	char		tmbuf[sizeof sport * 3 + 1], *xform;
	int		connlen;

	/* This needs to be dynamically allocated. */
	connlen = 22;
	conn = malloc(connlen);
	if (!conn) {
		log_error("pf_key_v2_acquire: malloc (%d) failed", connlen);
		return;
	}
	msg = (struct sadb_msg *)TAILQ_FIRST(pmsg)->seg;

	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_ADDRESS_DST);
	if (!ext) {
		log_print("pf_key_v2_acquire: "
		    "no destination address specified");
		free(conn);
		return;
	}
	dst = ext->seg;

	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_ADDRESS_SRC);
	if (ext)
		src = ext->seg;

	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_PROPOSAL);
	if (ext) {
		sprp = ext->seg;
		scmb = (struct sadb_comb *) (sprp + 1);
	}
	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_IDENTITY_SRC);
	if (ext)
		srcident = ext->seg;

	ext = pf_key_v2_find_ext(pmsg, SADB_EXT_IDENTITY_DST);
	if (ext)
		dstident = ext->seg;

	/* Ask the kernel for the matching policy. */
	bzero(&askpolicy_msg, sizeof askpolicy_msg);
	askpolicy_msg.sadb_msg_type = SADB_X_ASKPOLICY;
	askpolicy = pf_key_v2_msg_new(&askpolicy_msg, 0);
	if (!askpolicy)
		goto fail;

	policy.sadb_x_policy_exttype = SADB_X_EXT_POLICY;
	policy.sadb_x_policy_len = sizeof policy / PF_KEY_V2_CHUNK;
	policy.sadb_x_policy_seq = msg->sadb_msg_seq;
	if (pf_key_v2_msg_add(askpolicy, (struct sadb_ext *)&policy, 0) == -1)
		goto fail;

	ret = pf_key_v2_call(askpolicy);
	if (!ret)
		goto fail;

	/* Now we have all the information needed. */

	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_SRC_FLOW);
	if (!ext) {
		log_print("pf_key_v2_acquire: no source flow extension found");
		goto fail;
	}
	sflow = (struct sockaddr *) (((struct sadb_address *) ext->seg) + 1);

	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_DST_FLOW);
	if (!ext) {
		log_print("pf_key_v2_acquire: "
		    "no destination flow extension found");
		goto fail;
	}
	dflow = (struct sockaddr *) (((struct sadb_address *) ext->seg) + 1);
	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_SRC_MASK);
	if (!ext) {
		log_print("pf_key_v2_acquire: no source mask extension found");
		goto fail;
	}
	smask = (struct sockaddr *) (((struct sadb_address *) ext->seg) + 1);

	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_DST_MASK);
	if (!ext) {
		log_print("pf_key_v2_acquire: "
		    "no destination mask extension found");
		goto fail;
	}
	dmask = (struct sockaddr *) (((struct sadb_address *) ext->seg) + 1);

	ext = pf_key_v2_find_ext(ret, SADB_X_EXT_FLOW_TYPE);
	if (!ext) {
		log_print("pf_key_v2_acquire: no flow type extension found");
		goto fail;
	}
	sproto = ext->seg;
	tproto = sproto->sadb_protocol_proto;

	bzero(ssflow, sizeof ssflow);
	bzero(sdflow, sizeof sdflow);
	bzero(ssmask, sizeof ssmask);
	bzero(sdmask, sizeof sdmask);
	smasklen = dmasklen = -1;

	sidtype = didtype = "IPV4_ADDR_SUBNET";	/* default */

	switch (sflow->sa_family) {
	case AF_INET:
		if (inet_ntop(AF_INET,
		    &((struct sockaddr_in *) sflow)->sin_addr, ssflow,
		    ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		sport = ((struct sockaddr_in *) sflow)->sin_port;
		if (inet_ntop(AF_INET,
		    &((struct sockaddr_in *) dflow)->sin_addr, sdflow,
		    ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		dport = ((struct sockaddr_in *) dflow)->sin_port;
		if (inet_ntop(AF_INET,
		    &((struct sockaddr_in *) smask)->sin_addr, ssmask,
		    ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		if (inet_ntop(AF_INET,
		    &((struct sockaddr_in *) dmask)->sin_addr, sdmask,
		    ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		smasklen = mask4len((struct sockaddr_in *) smask);
		dmasklen = mask4len((struct sockaddr_in *) dmask);
		if (((struct sockaddr_in *) smask)->sin_addr.s_addr ==
		    INADDR_BROADCAST) {
			shostflag = 1;
			sidtype = "IPV4_ADDR";
		}
		if (((struct sockaddr_in *) dmask)->sin_addr.s_addr ==
		    INADDR_BROADCAST) {
			dhostflag = 1;
			didtype = "IPV4_ADDR";
		}
		break;

	case AF_INET6:
		if (inet_ntop(AF_INET6,
		    &((struct sockaddr_in6 *) sflow)->sin6_addr,
		    ssflow, ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		sport = ((struct sockaddr_in6 *) sflow)->sin6_port;
		if (inet_ntop(AF_INET6,
		    &((struct sockaddr_in6 *) dflow)->sin6_addr,
		    sdflow, ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		dport = ((struct sockaddr_in6 *) dflow)->sin6_port;
		if (inet_ntop(AF_INET6,
		    &((struct sockaddr_in6 *) smask)->sin6_addr,
		    ssmask, ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		if (inet_ntop(AF_INET6,
		    &((struct sockaddr_in6 *) dmask)->sin6_addr,
		    sdmask, ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		smasklen = mask6len((struct sockaddr_in6 *) smask);
		dmasklen = mask6len((struct sockaddr_in6 *) dmask);
		sidtype = didtype = "IPV6_ADDR_SUBNET";
		if (IN6_IS_ADDR_FULL(&((struct sockaddr_in6 *)smask)->sin6_addr)) {
			shostflag = 1;
			sidtype = "IPV6_ADDR";
		}
		if (IN6_IS_ADDR_FULL(&((struct sockaddr_in6 *)dmask)->sin6_addr)) {
			dhostflag = 1;
			didtype = "IPV6_ADDR";
		}
		break;
	}

	dstaddr = (struct sockaddr *)(dst + 1);
	bzero(dstbuf, sizeof dstbuf);
	bzero(srcbuf, sizeof srcbuf);

	if (dstaddr->sa_family == 0) {
		/*
		 * Destination was not specified in the flow -- can we derive
		 * it?
		 */
		if (dhostflag == 0) {
			log_print("pf_key_v2_acquire: "
			    "Cannot determine precise destination");
			goto fail;
		}
		dstaddr = dflow;
	}
	switch (dstaddr->sa_family) {
	case AF_INET:
		if (inet_ntop(AF_INET,
		    &((struct sockaddr_in *) dstaddr)->sin_addr,
		    dstbuf, ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		LOG_DBG((LOG_SYSDEP, 20,
		    "pf_key_v2_acquire: dst=%s sproto %d", dstbuf,
		    msg->sadb_msg_satype));
		break;

	case AF_INET6:
		if (inet_ntop(AF_INET6,
		    &((struct sockaddr_in6 *) dstaddr)->sin6_addr,
		    dstbuf, ADDRESS_MAX) == NULL) {
			log_print("pf_key_v2_acquire: inet_ntop failed");
			goto fail;
		}
		LOG_DBG((LOG_SYSDEP, 20,
		    "pf_key_v2_acquire: dst=%s sproto %d", dstbuf,
		    msg->sadb_msg_satype));
		break;
	}

	if (src) {
		srcaddr = (struct sockaddr *) (src + 1);

		switch (srcaddr->sa_family) {
		case AF_INET:
			if (inet_ntop(AF_INET,
			    &((struct sockaddr_in *) srcaddr)->sin_addr,
			    srcbuf, ADDRESS_MAX) == NULL) {
				log_print("pf_key_v2_acquire: "
				    "inet_ntop failed");
				goto fail;
			}
			break;

		case AF_INET6:
			if (inet_ntop(AF_INET6,
			    &((struct sockaddr_in6 *)srcaddr)->sin6_addr,
			    srcbuf, ADDRESS_MAX) == NULL) {
				log_print("pf_key_v2_acquire: "
				    "inet_ntop failed");
				goto fail;
			}
			break;

		default:
			/*
			 * The kernel will pass an all '0' EXT_ADDRESS_SRC if
			 * it wasn't specified for the flow. In that case, do
			 * NOT specify the srcaddr in the Peer-name below
			 */
			srcbuf[0] = 0;
			srcaddr = NULL;
			break;
		}
	}
	/* Insert source ID. */
	if (srcident) {
		slen = (srcident->sadb_ident_len * sizeof(u_int64_t))
			- sizeof(struct sadb_ident);
		if (((unsigned char *) (srcident + 1))[slen - 1] != '\0') {
			log_print("pf_key_v2_acquire: "
			    "source identity not NUL-terminated");
			goto fail;
		}
		/* Check for valid type. */
		switch (srcident->sadb_ident_type) {
		case SADB_IDENTTYPE_PREFIX:
			/* Determine what the address family is. */
			srcid = memchr(srcident + 1, ':', slen);
			if (srcid)
				afamily = AF_INET6;
			else
				afamily = AF_INET;

			srcid = memchr(srcident + 1, '/', slen);
			if (!srcid) {
				log_print("pf_key_v2_acquire: "
				    "badly formatted PREFIX identity");
				goto fail;
			}
			masklen = atoi(srcid + 1);

			/* XXX We only support host addresses. */
			if ((afamily == AF_INET6 && masklen != 128) ||
			    (afamily == AF_INET && masklen != 32)) {
				log_print("pf_key_v2_acquire: "
				    "non-host address specified in source "
				    "identity (mask length %d), ignoring "
				    "request", masklen);
				goto fail;
			}
			/*
			 * NUL-terminate the PREFIX string at the separator,
			 * then dup.
			 */
			*srcid = '\0';
			if (asprintf(&srcid, "id-%s",
			    (char *) (srcident + 1)) == -1) {
				log_error("pf_key_v2_acquire: asprintf() failed");
				goto fail;
			}

			/* Set the section if it doesn't already exist. */
			af = conf_begin();
			if (!conf_get_str(srcid, "ID-type")) {
				if (conf_set(af, srcid, "ID-type",
				    afamily == AF_INET ? "IPV4_ADDR" :
				    "IPV6_ADDR", 1, 0) ||
				    conf_set(af, srcid, "Refcount", "1", 1, 0) ||
				    conf_set(af, srcid, "Address",
					(char *) (srcident + 1), 1, 0)) {
					conf_end(af, 0);
					goto fail;
				}
			} else
				pf_key_v2_conf_refinc(af, srcid);
			conf_end(af, 1);
			break;

		case SADB_IDENTTYPE_FQDN:
			prefstring = "FQDN";
			/*FALLTHROUGH*/
		case SADB_IDENTTYPE_USERFQDN:
			if (!prefstring) {
				prefstring = "USER_FQDN";

				/*
				 * Check whether there is a string following
				 * the header; if no, that there is a user ID
				 * (and acquire the login name). If there is
				 * both a string and a user ID, check that
				 * they match.
				 */
				if ((slen == 0) &&
				    (srcident->sadb_ident_id == 0)) {
					log_print("pf_key_v2_acquire: "
					    "no user FQDN or ID provided");
					goto fail;
				}
				if (srcident->sadb_ident_id) {
					pwd =
					    getpwuid(srcident->sadb_ident_id);
					if (!pwd) {
						log_error("pf_key_v2_acquire: "
						    "could not acquire "
						    "username from provided "
						    "ID %llu",
						    srcident->sadb_ident_id);
						goto fail;
					}
					if (slen != 0)
						if (strcmp(pwd->pw_name,
						    (char *) (srcident + 1))
						    != 0) {
							log_print("pf_key_v2_acquire: "
							    "provided user "
							    "name and ID do "
							    "not match (%s != "
							    "%s)",
							    (char *) (srcident + 1),
							    pwd->pw_name);
							/*
							 * String has
							 * precedence, per
							 * RFC 2367.
							 */
						}
				}
			}
			if (asprintf(&srcid, "id-%s",
			    slen ? (char *) (srcident + 1) : pwd->pw_name) == -1) {
				log_error("pf_key_v2_acquire: asprintf() failed");
				goto fail;
			}
			pwd = 0;

			/* Set the section if it doesn't already exist. */
			af = conf_begin();
			if (!conf_get_str(srcid, "ID-type")) {
				if (conf_set(af, srcid, "ID-type", prefstring,
				    1, 0) ||
				    conf_set(af, srcid, "Refcount", "1", 1, 0) ||
				    conf_set(af, srcid, "Name",
					srcid + 3, 1, 0)) {
					conf_end(af, 0);
					goto fail;
				}
			} else
				pf_key_v2_conf_refinc(af, srcid);
			conf_end(af, 1);
			break;

		default:
			LOG_DBG((LOG_SYSDEP, 20,
			    "pf_key_v2_acquire: invalid source ID type %d",
			    srcident->sadb_ident_type));
			goto fail;
		}

		LOG_DBG((LOG_SYSDEP, 50,
		    "pf_key_v2_acquire: constructed source ID \"%s\"", srcid));
		prefstring = 0;
	}
	/* Insert destination ID. */
	if (dstident) {
		slen = (dstident->sadb_ident_len * sizeof(u_int64_t))
			- sizeof(struct sadb_ident);

		/* Check for valid type. */
		switch (dstident->sadb_ident_type) {
		case SADB_IDENTTYPE_PREFIX:
			/* Determine what the address family is. */
			dstid = memchr(dstident + 1, ':', slen);
			if (dstid)
				afamily = AF_INET6;
			else
				afamily = AF_INET;

			dstid = memchr(dstident + 1, '/', slen);
			if (!dstid) {
				log_print("pf_key_v2_acquire: "
				    "badly formatted PREFIX identity");
				goto fail;
			}
			masklen = atoi(dstid + 1);

			/* XXX We only support host addresses. */
			if ((afamily == AF_INET6 && masklen != 128) ||
			    (afamily == AF_INET && masklen != 32)) {
				log_print("pf_key_v2_acquire: "
				    "non-host address specified in "
				    "destination identity (mask length %d), "
				    "ignoring request", masklen);
				goto fail;
			}
			/*
			 * NUL-terminate the PREFIX string at the separator,
			 * then dup.
			 */
			*dstid = '\0';
			if (asprintf(&dstid, "id-%s",
			    (char *) (dstident + 1)) == -1) {
				log_error("pf_key_v2_acquire: asprintf() failed");
				goto fail;
			}

			/* Set the section if it doesn't already exist. */
			af = conf_begin();
			if (!conf_get_str(dstid, "ID-type")) {
				if (conf_set(af, dstid, "ID-type",
				    afamily == AF_INET ? "IPV4_ADDR" :
				    "IPV6_ADDR", 1, 0) ||
				    conf_set(af, dstid, "Refcount", "1", 1, 0) ||
				    conf_set(af, dstid, "Address",
					(char *) (dstident + 1), 1, 0)) {
					conf_end(af, 0);
					goto fail;
				}
			} else
				pf_key_v2_conf_refinc(af, dstid);
			conf_end(af, 1);
			break;

		case SADB_IDENTTYPE_FQDN:
			prefstring = "FQDN";
			/*FALLTHROUGH*/
		case SADB_IDENTTYPE_USERFQDN:
			if (!prefstring) {
				prefstring = "USER_FQDN";

				/*
				 * Check whether there is a string following
				 * the header; if no, that there is a user ID
				 * (and acquire the login name). If there is
				 * both a string and a user ID, check that
				 * they match.
				 */
				if (slen == 0 &&
				    dstident->sadb_ident_id == 0) {
					log_print("pf_key_v2_acquire: "
					    "no user FQDN or ID provided");
					goto fail;
				}
				if (dstident->sadb_ident_id) {
					pwd = getpwuid(dstident->sadb_ident_id);
					if (!pwd) {
						log_error("pf_key_v2_acquire: "
						    "could not acquire "
						    "username from provided "
						    "ID %llu",
						    dstident->sadb_ident_id);
						goto fail;
					}
					if (slen != 0)
						if (strcmp(pwd->pw_name,
						    (char *) (dstident + 1))
						    != 0) {
							log_print("pf_key_v2_acquire: "
							    "provided user "
							    "name and ID do "
							    "not match (%s != "
							    "%s)",
							    (char *) (dstident + 1),
							    pwd->pw_name);
							/*
							 * String has
							 * precedence, per RF
							 * 2367.
							 */
						}
				}
			}
			if (asprintf(&dstid, "id-%s",
			    slen ? (char *) (dstident + 1) : pwd->pw_name) == -1) {
				log_error("pf_key_v2_acquire: asprintf() failed");
				goto fail;
			}
			pwd = 0;

			/* Set the section if it doesn't already exist. */
			af = conf_begin();
			if (!conf_get_str(dstid, "ID-type")) {
				if (conf_set(af, dstid, "ID-type", prefstring,
				    1, 0) ||
				    conf_set(af, dstid, "Refcount", "1", 1, 0) ||
				    conf_set(af, dstid, "Name",
					dstid + 3, 1, 0)) {
					conf_end(af, 0);
					goto fail;
				}
			} else
				pf_key_v2_conf_refinc(af, dstid);
			conf_end(af, 1);
			break;

		default:
			LOG_DBG((LOG_SYSDEP, 20, "pf_key_v2_acquire: "
			    "invalid destination ID type %d",
			    dstident->sadb_ident_type));
			goto fail;
		}

		LOG_DBG((LOG_SYSDEP, 50,
		    "pf_key_v2_acquire: constructed destination ID \"%s\"",
		    dstid));
	}
	/* Now we've placed the necessary IDs in the configuration space. */

	/* Get a new connection sequence number. */
	for (;; connection_seq++) {
		snprintf(conn, connlen, "Connection-%u", connection_seq);

		/* Does it exist ? */
		if (!conf_get_str(conn, "Phase"))
			break;
	}

	/*
	 * Set the IPsec connection entry. In particular, the following fields:
	 * - Phase
	 * - ISAKMP-peer
	 * - Local-ID/Remote-ID (if provided)
	 * - Acquire-ID (sequence number of kernel message, e.g., PF_KEYv2)
	 * - Configuration
	 *
	 * Also set the following section:
	 *    [peer-dstaddr(-local-srcaddr)]
	 * with these fields:
	 * - Phase
	 * - ID (if provided)
	 * - Remote-ID (if provided)
	 * - Local-address (if provided)
	 * - Address
	 * - Configuration (if an entry phase1-dstaddr-srcadd)
	 *                  exists -- otherwise use the defaults)
	 */

	/*
	 * The various cases:
	 * - peer-dstaddr
	 * - peer-dstaddr-local-srcaddr
	 */
	if (asprintf(&peer, "peer-%s%s%s", dstbuf, srcaddr ? "-local-" : "",
	    srcaddr ? srcbuf : "") == -1)
		goto fail;

	/*
	 * Set the IPsec connection section. Refcount is set to 2, because
	 * it will be linked both to the incoming and the outgoing SA.
	 */
	af = conf_begin();
	if (conf_set(af, conn, "Phase", "2", 0, 0) ||
	    conf_set(af, conn, "Flags", "__ondemand", 0, 0) ||
	    conf_set(af, conn, "Refcount", "2", 0, 0) ||
	    conf_set(af, conn, "ISAKMP-peer", peer, 0, 0)) {
		conf_end(af, 0);
		goto fail;
	}
	/* Set the sequence number. */
	snprintf(lname, sizeof lname, "%u", msg->sadb_msg_seq);
	if (conf_set(af, conn, "Acquire-ID", lname, 0, 0)) {
		conf_end(af, 0);
		goto fail;
	}
	/*
	 * Set Phase 2 IDs -- this is the Local-ID section.
	 * - from-address
	 * - from-address=proto
	 * - from-address=proto:port
	 * - from-network/masklen
	 * - from-network/masklen=proto
	 * - from-network/masklen=proto:port
	 */
	phase2id(lname, sizeof lname, "from", ssflow, smasklen, tproto, sport);
	if (conf_set(af, conn, "Local-ID", lname, 0, 0)) {
		conf_end(af, 0);
		goto fail;
	}
	if (!conf_get_str(lname, "ID-type")) {
		if (conf_set(af, lname, "Refcount", "1", 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}
		if (shostflag) {
			if (conf_set(af, lname, "ID-type", sidtype, 0, 0) ||
			    conf_set(af, lname, "Address", ssflow, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		} else {
			if (conf_set(af, lname, "ID-type", sidtype, 0, 0) ||
			    conf_set(af, lname, "Network", ssflow, 0, 0) ||
			    conf_set(af, lname, "Netmask", ssmask, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		}
		if (tproto) {
			snprintf(tmbuf, sizeof sport * 3 + 1, "%u", tproto);
			if (conf_set(af, lname, "Protocol", tmbuf, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
			if (sport) {
				snprintf(tmbuf, sizeof sport * 3 + 1, "%u",
				    ntohs(sport));
				if (conf_set(af, lname, "Port", tmbuf, 0, 0)) {
					conf_end(af, 0);
					goto fail;
				}
			}
		}
	} else
		pf_key_v2_conf_refinc(af, lname);

	/*
	 * Set Remote-ID section.
	 * to-address
	 * to-address=proto
	 * to-address=proto:port
	 * to-network/masklen
	 * to-network/masklen=proto
	 * to-network/masklen=proto:port
	 */
	phase2id(dname, sizeof dname, "to", sdflow, dmasklen, tproto, dport);
	if (conf_set(af, conn, "Remote-ID", dname, 0, 0)) {
		conf_end(af, 0);
		goto fail;
	}
	if (!conf_get_str(dname, "ID-type")) {
		if (conf_set(af, dname, "Refcount", "1", 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}
		if (dhostflag) {
			if (conf_set(af, dname, "ID-type", didtype, 0, 0) ||
			    conf_set(af, dname, "Address", sdflow, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		} else {
			if (conf_set(af, dname, "ID-type", didtype, 0, 0) ||
			    conf_set(af, dname, "Network", sdflow, 0, 0) ||
			    conf_set(af, dname, "Netmask", sdmask, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		}

		if (tproto) {
			snprintf(tmbuf, sizeof dport * 3 + 1, "%u", tproto);
			if (conf_set(af, dname, "Protocol", tmbuf, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
			if (dport) {
				snprintf(tmbuf, sizeof dport * 3 + 1, "%u",
				    ntohs(dport));
				if (conf_set(af, dname, "Port", tmbuf, 0, 0)) {
					conf_end(af, 0);
					goto fail;
				}
			}
		}
	} else
		pf_key_v2_conf_refinc(af, dname);

	/*
	 * XXX
	 * We should be using information from the proposal to set this up.
	 * At least, we should make this selectable.
	 */

	/*
	 * Phase 2 configuration.
	 * - phase2-from-address-to-address
	 * - ...
	 * - phase2-from-net/len=proto:port-to-net/len=proto:port
	 */
	snprintf(configname, sizeof configname, "phase2-%s-%s", lname, dname);
	if (conf_set(af, conn, "Configuration", configname, 0, 0)) {
		conf_end(af, 0);
		goto fail;
	}
	if (!conf_get_str(configname, "Exchange_type")) {
		if (conf_set(af, configname, "Exchange_type", "Quick_mode",
		    0, 0) ||
		    conf_set(af, peer, "Refcount", "1", 0, 0) ||
		    conf_set(af, configname, "DOI", "IPSEC", 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}
		if (conf_get_str("General", "Default-phase-2-suites")) {
			if (conf_set(af, configname, "Suites",
			    conf_get_str("General", "Default-phase-2-suites"),
			    0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		} else {
			if (conf_set(af, configname, "Suites",
			    "QM-ESP-3DES-SHA-PFS-SUITE", 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		}
	} else 
		pf_key_v2_conf_refinc(af, configname);

	/* Set the ISAKMP-peer section. */
	if (!conf_get_str(peer, "Phase")) {
		if (conf_set(af, peer, "Phase", "1", 0, 0) ||
		    conf_set(af, peer, "Refcount", "1", 0, 0) ||
		    conf_set(af, peer, "Address", dstbuf, 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}
		if (srcaddr && conf_set(af, peer, "Local-address", srcbuf, 0,
		    0)) {
			conf_end(af, 0);
			goto fail;
		}
		snprintf(confname, sizeof confname, "phase1-%s", peer);
		if (conf_set(af, peer, "Configuration", confname, 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}

		/* Phase 1 configuration. */
		if (!conf_get_str(confname, "exchange_type")) {
			xform = conf_get_str("Default-phase-1-configuration",
			"Transforms");
			if (conf_set(af, confname, "Transforms", xform ? xform :
			    "3DES-SHA-RSA_SIG", 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}

			if (conf_set(af, confname, "Exchange_Type", "ID_PROT",
			    0, 0) ||
			    conf_set(af, confname, "DOI", "IPSEC", 0, 0) ||
			    conf_set(af, confname, "Refcount", "1", 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
		} else
			pf_key_v2_conf_refinc(af, confname);

		/* The ID we should use in Phase 1. */
		if (srcid && conf_set(af, peer, "ID", srcid, 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}
		/* The ID the other side should use in Phase 1. */
		if (dstid && conf_set(af, peer, "Remote-ID", dstid, 0, 0)) {
			conf_end(af, 0);
			goto fail;
		}
	} else
		pf_key_v2_conf_refinc(af, peer);

	/* All done. */
	conf_end(af, 1);

	/* Let's rock 'n roll. */
	pf_key_v2_connection_check(conn);
	connection_record_passive(conn);
	conn = 0;

	/* Fall-through to cleanup. */
fail:
	if (ret)
		pf_key_v2_msg_free(ret);
	if (askpolicy)
		pf_key_v2_msg_free(askpolicy);
	free(srcid);
	free(dstid);
	free(peer);
	free(conn);
	return;
}

static void
pf_key_v2_notify(struct pf_key_v2_msg *msg)
{
	switch (((struct sadb_msg *)TAILQ_FIRST(msg)->seg)->sadb_msg_type) {
	case SADB_EXPIRE:
		pf_key_v2_expire(msg);
		break;

	case SADB_ACQUIRE:
		if (!ui_daemon_passive)
			pf_key_v2_acquire(msg);
		break;

	default:
		log_print("pf_key_v2_notify: unexpected message type (%d)",
		    ((struct sadb_msg *)TAILQ_FIRST(msg)->seg)->sadb_msg_type);
	}
	pf_key_v2_msg_free(msg);
}

void
pf_key_v2_handler(int fd)
{
	struct pf_key_v2_msg *msg;
	int		n;

	/*
	 * As synchronous read/writes to the socket can have taken place
	 * between the select(2) call of the main loop and this handler, we
	 * need to recheck the readability.
	 */
	if (ioctl(pf_key_v2_socket, FIONREAD, &n) == -1) {
		log_error("pf_key_v2_handler: ioctl (%d, FIONREAD, &n) failed",
		    pf_key_v2_socket);
		return;
	}
	if (!n)
		return;

	msg = pf_key_v2_read(0);
	if (msg)
		pf_key_v2_notify(msg);
}

/*
 * Group 2 IPsec SAs given by the PROTO1 and PROTO2 protocols of the SA IKE
 * security association in a chain.
 * XXX Assumes OpenBSD GRPSPIS extension.
 */
int
pf_key_v2_group_spis(struct sa *sa, struct proto *proto1,
    struct proto *proto2, int incoming)
{
	struct sadb_msg msg;
	struct sadb_sa  sa1, sa2;
	struct sadb_address *addr = 0;
	struct sadb_protocol protocol;
	struct pf_key_v2_msg *grpspis = 0, *ret = 0;
	struct sockaddr *saddr;
	int		err;
	size_t		len;

	msg.sadb_msg_type = SADB_X_GRPSPIS;
	switch (proto1->proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		msg.sadb_msg_satype = SADB_SATYPE_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		msg.sadb_msg_satype = SADB_SATYPE_AH;
		break;
	case IPSEC_PROTO_IPCOMP:
		msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
		break;
	default:
		log_print("pf_key_v2_group_spis: invalid proto %d",
		    proto1->proto);
		goto cleanup;
	}
	msg.sadb_msg_seq = 0;
	grpspis = pf_key_v2_msg_new(&msg, 0);
	if (!grpspis)
		goto cleanup;

	/* Setup the SA extensions.  */
	sa1.sadb_sa_exttype = SADB_EXT_SA;
	sa1.sadb_sa_len = sizeof sa1 / PF_KEY_V2_CHUNK;
	memcpy(&sa1.sadb_sa_spi, proto1->spi[incoming],
	    sizeof sa1.sadb_sa_spi);
	sa1.sadb_sa_replay = 0;
	sa1.sadb_sa_state = 0;
	sa1.sadb_sa_auth = 0;
	sa1.sadb_sa_encrypt = 0;
	sa1.sadb_sa_flags = 0;
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *)&sa1, 0) == -1)
		goto cleanup;

	sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
	sa2.sadb_sa_len = sizeof sa2 / PF_KEY_V2_CHUNK;
	memcpy(&sa2.sadb_sa_spi, proto2->spi[incoming],
	    sizeof sa2.sadb_sa_spi);
	sa2.sadb_sa_replay = 0;
	sa2.sadb_sa_state = 0;
	sa2.sadb_sa_auth = 0;
	sa2.sadb_sa_encrypt = 0;
	sa2.sadb_sa_flags = 0;
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *)&sa2, 0) == -1)
		goto cleanup;

	/*
	 * Setup the ADDRESS extensions.
	 */
	if (incoming)
		sa->transport->vtbl->get_src(sa->transport, &saddr);
	else
		sa->transport->vtbl->get_dst(sa->transport, &saddr);
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(saddr));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, saddr, SA_LEN(saddr));
	((struct sockaddr_in *) (addr + 1))->sin_port = 0;
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_X_EXT_DST2;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_reserved = 0;
	memcpy(addr + 1, saddr, SA_LEN(saddr));
	((struct sockaddr_in *) (addr + 1))->sin_port = 0;
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	/* Setup the sa type extension.  */
	protocol.sadb_protocol_exttype = SADB_X_EXT_SATYPE2;
	protocol.sadb_protocol_len = sizeof protocol / PF_KEY_V2_CHUNK;
	switch (proto2->proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		protocol.sadb_protocol_proto = SADB_SATYPE_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		protocol.sadb_protocol_proto = SADB_SATYPE_AH;
		break;
	case IPSEC_PROTO_IPCOMP:
		protocol.sadb_protocol_proto = SADB_X_SATYPE_IPCOMP;
		break;
	default:
		log_print("pf_key_v2_group_spis: invalid proto %d",
		    proto2->proto);
		goto cleanup;
	}
	protocol.sadb_protocol_reserved2 = 0;
	if (pf_key_v2_msg_add(grpspis,
	    (struct sadb_ext *)&protocol, 0) == -1)
		goto cleanup;

	ret = pf_key_v2_call(grpspis);
	pf_key_v2_msg_free(grpspis);
	grpspis = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (err) {
		log_print("pf_key_v2_group_spis: GRPSPIS: %s", strerror(err));
		goto cleanup;
	}
	pf_key_v2_msg_free(ret);

	LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_group_spis: done"));

	return 0;

cleanup:
	free(addr);
	if (grpspis)
		pf_key_v2_msg_free(grpspis);
	if (ret)
		pf_key_v2_msg_free(ret);
	return -1;
}
@


1.197
log
@Remove NULL-checks before free(). ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.196 2015/12/09 21:41:50 naddy Exp $  */
d3306 2
a3307 2
	/* Setup the PROTOCOL extension.  */
	protocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
@


1.196
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.195 2015/08/20 22:02:21 deraadt Exp $  */
d815 1
a815 2
	if (addr)
		free (addr);
@


1.195
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.194 2015/04/17 10:04:37 mikeb Exp $  */
a903 6
		case IPSEC_ESP_DES:
		case IPSEC_ESP_DES_IV32:
		case IPSEC_ESP_DES_IV64:
			ssa.sadb_sa_encrypt = SADB_EALG_DESCBC;
			break;

@


1.194
log
@Remove unsupported SADB_X_IDENTTYPE_CONNECTION;  OK markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.193 2015/04/14 12:22:15 mikeb Exp $  */
d329 1
a329 1
	iov = (struct iovec *) calloc(cnt, sizeof *iov);
d689 1
a689 1
	ssa = (struct sadb_sa *)calloc(1, sizeof *ssa);
d1381 1
a1381 1
		if ((stag = (struct sadb_x_tag *)calloc(1, len)) == NULL)
@


1.193
log
@Remove support for storing credentials and auth information in the kernel.

This code is largely unfinished and is not used for anything.  The change
leaves identities as only objects referenced by ipsec_ref structure and
their handling requires some changes to support more advanced matching of
IPsec connections.

No objections from reyk and hshoexer, with and OK markus.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.192 2015/03/26 12:21:37 mikeb Exp $  */
d1731 1
a1731 1
	case IPSEC_ID_IPV4_ADDR:	/* XXX CONNECTION ? */
d1745 1
a1745 1
	case IPSEC_ID_IPV6_ADDR:	/* XXX CONNECTION ? */
a2614 4
		case SADB_X_IDENTTYPE_CONNECTION:
			/* XXX */
			break;

a2758 4
		case SADB_X_IDENTTYPE_CONNECTION:
			/* XXX */
			break;

@


1.192
log
@Remove bits of unfinished IPsec proxy support.  DNS' KX records, anyone?
ok markus, hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.191 2014/10/29 06:26:40 deraadt Exp $  */
a891 1
	struct sadb_x_cred *cred;
a1303 128
	/*
	 * Send received credentials to the kernel. We don't bother with
	 * our credentials, since the process either knows them (if it
	 * specified them with setsockopt()), or has no business looking at
	 * them (e.g., system wide certs).
	 */
	if (isakmp_sa->recv_cert) {
		switch (isakmp_sa->recv_certtype) {
		case ISAKMP_CERTENC_NONE:
			/* Nothing to be done here. */
			break;

		case ISAKMP_CERTENC_KEYNOTE:
			len = strlen(isakmp_sa->recv_cert);
			cred = calloc(PF_KEY_V2_ROUND(len) + sizeof *cred,
			    sizeof(u_int8_t));
			if (!cred)
				goto cleanup;

			cred->sadb_x_cred_len =
			    ((sizeof *cred) / PF_KEY_V2_CHUNK) +
			    PF_KEY_V2_ROUND(len) / PF_KEY_V2_CHUNK;
			cred->sadb_x_cred_exttype =
			    SADB_X_EXT_REMOTE_CREDENTIALS;
			cred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
			memcpy(cred + 1, isakmp_sa->recv_cert, len);

			if (pf_key_v2_msg_add(update, (struct sadb_ext *) cred,
			    PF_KEY_V2_NODE_MALLOCED) == -1)
				goto cleanup;
			break;

		case ISAKMP_CERTENC_X509_SIG:
			{
				u_int8_t       *data;
				u_int32_t       datalen;
				struct cert_handler *handler;

				/* We do it this way to avoid weird includes.*/
				handler = cert_get(ISAKMP_CERTENC_X509_SIG);
				if (!handler)
					break;
				handler->cert_serialize(isakmp_sa->recv_cert,
				    &data, &datalen);
				if (!data)
					break;

				len = datalen;
				cred =
				    calloc(PF_KEY_V2_ROUND(len) + sizeof *cred,
					sizeof(u_int8_t));
				if (!cred) {
					free(data);
					goto cleanup;
				}
				cred->sadb_x_cred_len =
				    ((sizeof *cred) / PF_KEY_V2_CHUNK) +
				    PF_KEY_V2_ROUND(len) / PF_KEY_V2_CHUNK;
				cred->sadb_x_cred_exttype =
				    SADB_X_EXT_REMOTE_CREDENTIALS;
				cred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
				memcpy(cred + 1, data, len);
				free(data);

				if (pf_key_v2_msg_add(update,
				    (struct sadb_ext *) cred,
				    PF_KEY_V2_NODE_MALLOCED) == -1)
					goto cleanup;
			}
			break;
		}
	}

	/*
	 * Tell the kernel what the peer used to authenticate, unless it was a
	 * passphrase.
	 */
	if (isakmp_sa->recv_key) {
		u_int8_t       *data;

		/*
		 * If it's a private key, we shouldn't pass it to the kernel
		 * for processes to see; successful authentication of Phase 1
		 * implies that the process already knew the passphrase. On
		 * the other hand, we don't want to reveal to processes any
		 * system-wide passphrases used for authentication with remote
		 * systems. Same reason we don't send up the key (private or
		 * passphrase) we used to authenticate with the peer.
		 */
		if (isakmp_sa->recv_keytype == ISAKMP_KEY_PASSPHRASE)
			goto doneauth;

		key_serialize(isakmp_sa->recv_keytype, ISAKMP_KEYTYPE_PUBLIC,
		    isakmp_sa->recv_key, &data, &len);
		if (!data)
			goto cleanup;

		cred = calloc(PF_KEY_V2_ROUND(len) + sizeof *cred,
		    sizeof(u_int8_t));
		if (!cred) {
			free(data);
			goto cleanup;
		}
		cred->sadb_x_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
		    PF_KEY_V2_ROUND(len) / PF_KEY_V2_CHUNK;
		cred->sadb_x_cred_exttype = SADB_X_EXT_REMOTE_AUTH;
		memcpy(cred + 1, data, len);
		free(data);

		switch (isakmp_sa->recv_keytype) {
		case ISAKMP_KEY_RSA:
			cred->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
			break;

		default:
			log_print("pf_key_v2_set_spi: "
			    "unknown received key type %d",
			    isakmp_sa->recv_keytype);
			free(cred);
			goto cleanup;
		}

		if (pf_key_v2_msg_add(update, (struct sadb_ext *) cred,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
	}
doneauth:

a2343 1
	struct sadb_x_cred *cred = 0, *sauth = 0;
a2435 12
	ext = pf_key_v2_find_ext(pmsg, SADB_X_EXT_LOCAL_CREDENTIALS);
	if (ext)
		cred = (struct sadb_x_cred *) ext->seg;
	else
		cred = 0;

	ext = pf_key_v2_find_ext(pmsg, SADB_X_EXT_LOCAL_AUTH);
	if (ext)
		sauth = (struct sadb_x_cred *) ext->seg;
	else
		sauth = 0;

a3123 5
		/* Store any credentials passed to us. */
		if (cred) {
			struct cert_handler *handler = 0;
			void           *cert;
			char		num[12], *certprint;
d3125 6
a3130 25
			/* Convert to bytes in-place. */
			cred->sadb_x_cred_len *= PF_KEY_V2_CHUNK;

			if (cred->sadb_x_cred_len <= sizeof *cred) {
				log_print("pf_key_v2_acquire: "
				    "zero-length credentials, aborting SA "
				    "acquisition");
				conf_end(af, 0);
				goto fail;
			}
			switch (cred->sadb_x_cred_type) {
			case SADB_X_CREDTYPE_X509:
				snprintf(num, sizeof num, "%d",
				    ISAKMP_CERTENC_X509_SIG);
				handler = cert_get(ISAKMP_CERTENC_X509_SIG);
				break;
			case SADB_X_CREDTYPE_KEYNOTE:
				snprintf(num, sizeof num, "%d",
				    ISAKMP_CERTENC_KEYNOTE);
				handler = cert_get(ISAKMP_CERTENC_KEYNOTE);
				break;
			default:
				log_print("pf_key_v2_acquire: "
				    "unknown credential type %d",
				    cred->sadb_x_cred_type);
a3132 148
			}

			if (!handler) {
				log_print("pf_key_v2_acquire: "
				    "cert_get (%s) failed", num);
				conf_end(af, 0);
				goto fail;
			}
			/* Set the credential type as a number. */
			if (conf_set(af, peer, "Credential_type", num, 0, 0)) {
				conf_end(af, 0);
				goto fail;
			}
			/* Get the certificate. */
			cert = handler->cert_get((u_int8_t *) (cred + 1),
			    cred->sadb_x_cred_len - sizeof *cred);

			/* Now convert to printable format. */
			certprint = handler->cert_printable(cert);
			handler->cert_free(cert);
			if (!certprint ||
			    conf_set(af, peer, "Credentials", certprint, 0,
				0)) {
				free(certprint);
				conf_end(af, 0);
				goto fail;
			}
			free(certprint);
		}

		/* Phase 1 configuration. */
		if (!conf_get_str(confname, "exchange_type")) {
			/*
			 * We may have been provided with authentication
			 * material.
			 */
			if (sauth) {
				char           *authm;

				/* Convert to bytes in-place. */
				sauth->sadb_x_cred_len *= PF_KEY_V2_CHUNK;

				switch (sauth->sadb_x_cred_type) {
				case SADB_X_AUTHTYPE_PASSPHRASE:
					if (conf_set(af, confname,
					    "Transforms", "3DES-SHA", 0, 0)) {
						conf_end(af, 0);
						goto fail;
					}
					if (sauth->sadb_x_cred_len <=
					    sizeof *sauth) {
						log_print("pf_key_v2_acquire: "
						    "zero-length passphrase, "
						    "aborting SA acquisition");
						conf_end(af, 0);
						goto fail;
					}
					authm = malloc(sauth->sadb_x_cred_len -
					    sizeof *sauth + 1);
					if (!authm) {
						log_error("pf_key_v2_acquire: "
						    "malloc (%lu) failed",
						    sauth->sadb_x_cred_len -
						    (unsigned long) sizeof *sauth + 1);
						conf_end(af, 0);
						goto fail;
					}
					memcpy(authm, sauth + 1,
					    sauth->sadb_x_cred_len -
					    sizeof *sauth + 1);

					/* Set the passphrase in the peer. */
					if (conf_set(af, peer,
					    "Authentication", authm, 0, 0)) {
						free(authm);
						conf_end(af, 0);
						goto fail;
					}
					free(authm);
					break;

				case SADB_X_AUTHTYPE_RSA:
					if (conf_set(af, confname,
					    "Transforms", "3DES-SHA-RSA_SIG",
					    0, 0)) {
						conf_end(af, 0);
						goto fail;
					}
					if (sauth->sadb_x_cred_len <=
					    sizeof *sauth) {
						log_print("pf_key_v2_acquire: "
						    "zero-length RSA key, "
						    "aborting SA acquisition");
						conf_end(af, 0);
						goto fail;
					}
					authm = key_printable(ISAKMP_KEY_RSA,
					    ISAKMP_KEYTYPE_PRIVATE,
					    (u_int8_t *)(sauth + 1),
					    sauth->sadb_x_cred_len -
					    sizeof *sauth);
					if (!authm) {
						log_print("pf_key_v2_acquire: "
						    "failed to convert "
						    "private key to printable "
						    "format (size %lu)",
						    sauth->sadb_x_cred_len -
						    (unsigned long) sizeof *sauth);
						conf_end(af, 0);
						goto fail;
					}
					/*
					 * Set the key in the peer. We don't
					 * use "Authentication" to avoid
					 * potential conflicts with file-based
					 * configurations that use public key
					 * authentication but still specify
					 * an "Authentication" tag (typically
					 * as a remnant of passphrase-based
					 * testing).
					 */
					if (conf_set(af, peer,
					    "PKAuthentication", authm, 0, 0)) {
						free(authm);
						conf_end(af, 0);
						goto fail;
					}
					free(authm);
					break;

				default:
					log_print("pf_key_v2_acquire: "
					    "unknown authentication "
					    "material type %d received from "
					    "kernel", sauth->sadb_x_cred_type);
					conf_end(af, 0);
					goto fail;
				}
			} else {
				xform = conf_get_str(
				    "Default-phase-1-configuration",
				    "Transforms");
				if (conf_set(af, confname, "Transforms",
				    xform ? xform : "3DES-SHA-RSA_SIG", 0,
				    0)) {
					conf_end(af, 0);
					goto fail;
				}
@


1.191
log
@convert simple cases of select() to poll()
ok doug
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.190 2014/10/22 16:35:34 millert Exp $  */
a800 8
	ext = pf_key_v2_find_ext(ret, SADB_EXT_ADDRESS_PROXY);
	if (ext) {
		sa = (struct sockaddr *)ext->seg;
		memcpy(sa, &ksa.proxy,
		    sa->sa_family == AF_INET ? sizeof(struct sockaddr_in) :
		    sizeof(struct sockaddr_in6));
	}

a1198 30

#if 0
	/* XXX I am not sure about what to do here just yet.  */
	if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL) {
		len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(dst));
		addr = calloc(1, len);
		if (!addr)
			goto cleanup;
		addr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;
		addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
		addr->sadb_address_reserved = 0;
		memcpy(addr + 1, dst, SA_LEN(dst));
		switch (((struct sockaddr *) (addr + 1))->sa_family) {
		case AF_INET:
			((struct sockaddr_in *) (addr + 1))->sin_port = 0;
			break;
		case AF_INET6:
			((struct sockaddr_in6 *) (addr + 1))->sin6_port = 0;
			break;
		}
		if (pf_key_v2_msg_add(update, (struct sadb_ext *) addr,
		    PF_KEY_V2_NODE_MALLOCED) == -1)
			goto cleanup;
		addr = 0;
#if 0
		msg->em_odst = msg->em_dst;
		msg->em_osrc = msg->em_src;
#endif
	}
#endif
@


1.190
log
@Fix error reporting when reallocarray() fails.  OK miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.189 2014/10/18 03:10:00 doug Exp $  */
d46 1
d207 5
a211 2
	struct timeval  tv;
	fd_set         *fds;
d221 1
a221 15
			fds = calloc(howmany(pf_key_v2_socket + 1, NFDBITS),
			    sizeof(fd_mask));
			if (!fds) {
				log_error("pf_key_v2_read: "
				    "calloc (%lu, %lu) failed",
				    (unsigned long) howmany(pf_key_v2_socket + 1,
					NFDBITS),
				    (unsigned long) sizeof(fd_mask));
				goto cleanup;
			}
			FD_SET(pf_key_v2_socket, fds);
			tv.tv_sec = 0;
			tv.tv_usec = PF_KEY_REPLY_TIMEOUT;
			n = select(pf_key_v2_socket + 1, fds, 0, 0, &tv);
			free(fds);
d223 1
a223 3
				log_error("pf_key_v2_read: "
				    "select (%d, fds, 0, 0, &tv) failed",
				    pf_key_v2_socket + 1);
@


1.189
log
@Convert malloc() with a size var using multiplication to reallocarray().

Avoid assigning the size unless reallocarray() succeeds to avoid overflow.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.188 2012/06/30 14:51:31 naddy Exp $  */
d258 2
a259 2
			log_error("pf_key_v2_read: malloc (%zu) failed",
			    hdr.sadb_msg_len * PF_KEY_V2_CHUNK);
@


1.188
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.187 2011/08/02 22:51:38 markus Exp $  */
d256 1
a256 2
		n = hdr.sadb_msg_len * PF_KEY_V2_CHUNK;
		buf = malloc(n);
d258 2
a259 2
			log_error("pf_key_v2_read: malloc (%lu) failed",
			    (unsigned long) n);
d262 2
@


1.187
log
@add refcounting for "Configuration" section for acquire-mode SAs
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.186 2010/09/22 13:45:16 mikeb Exp $  */
d938 1
a938 1
		case IPSEC_ESP_AES_128_CTR:
@


1.186
log
@Support for use of AES-GCM-16 (as AESGCM) and ENCR_NULL_AUTH_AES_GMAC
(as AESGMAC) ciphers in the ISAKMP Phase 2 (aka Quick Mode).

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.185 2009/01/28 17:57:15 hshoexer Exp $  */
d2111 1
a2111 1
	conf_remove_section(af, configname);
d3275 1
d3294 2
a3295 1
	}
@


1.185
log
@cleaning up my tree:  trivial KNF and a comment fix.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.184 2008/07/01 15:00:53 bluhm Exp $  */
d940 8
@


1.184
log
@Isakmpd acquire mode did not work with a config generated from
ipsec.conf.  The config created by isakmpd dynamically was different
from the config that ipsecctl generated out of ipsec.conf.

Both config formats are changed so that they match.  One needs a
passive ike line and a require flow line with the same parameters
in the ipsec.conf.  Then the acquire message generated by the kernel
will trigger isakmpd to generate a config that matches the one that
ipsecctl generated from the ike line.

ok hshoexer, 'sounds good' todd
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.183 2008/06/10 17:25:57 bluhm Exp $  */
d580 1
a580 2
	len =
	    sizeof(struct sadb_address) + PF_KEY_V2_ROUND(SA_LEN(dst));
@


1.183
log
@Fix implementation of IN6_IS_ADDR_FULL so that IPV6_ADDR is used
instead of IPV6_ADDR_SUBNET where appropriate.  Then isakmpd has
the same behaviour for IPv6 and IPv4.
ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.182 2007/09/02 15:19:24 deraadt Exp $  */
d2434 51
d2505 1
d2507 1
a2507 1
	char		lname[100], dname[100], configname[30];
d2624 1
d2656 2
d2697 2
d2833 1
a2833 1
			if (asprintf(&srcid, "ID:Address/%s",
d2906 1
a2906 1
			if (asprintf(&srcid, "ID:%s/%s", prefstring,
d2920 1
a2920 2
					srcid + sizeof "ID:/" - 1 +
					strlen(prefstring), 1, 0)) {
d2981 1
a2981 1
			if (asprintf(&dstid, "ID:Address/%s",
d3053 1
a3053 1
			if (asprintf(&dstid, "ID:%s/%s", prefstring,
d3067 1
a3067 2
					dstid + sizeof "ID:/" - 1 +
					strlen(prefstring), 1, 0)) {
a3091 2
		snprintf(configname, sizeof configname, "Config-Phase2-%u",
		    connection_seq);
d3094 1
a3094 2
		if (!conf_get_str(conn, "Phase") &&
		    !conf_get_str(configname, "Suites"))
d3107 1
a3107 1
	 *    [Peer-dstaddr(/srcaddr)(-srcid)(/dstid)]
d3114 1
a3114 1
	 * - Configuration (if an entry ISAKMP-configuration-dstaddr(/srcaddr)
d3120 2
a3121 8
	 * - Peer-dstaddr
	 * - Peer-dstaddr/srcaddr
	 * - Peer-dstaddr/srcaddr-srcid
	 * - Peer-dstaddr/srcaddr-srcid/dstid
	 * - Peer-dstaddr/srcaddr-/dstid
	 * - Peer-dstaddr-srcid/dstid
	 * - Peer-dstaddr-/dstid
	 * - Peer-dstaddr-srcid
d3123 2
a3124 3
	if (asprintf(&peer, "Peer-%s%s%s%s%s%s%s", dstbuf, srcaddr ? "/" : "",
	    srcaddr ? srcbuf : "", srcid ? "-" : "", srcid ? srcid : "",
	    dstid ? (srcid ? "/" : "-/") : "", dstid ? dstid : "") == -1)
d3145 10
a3154 3
	/* Set Phase 2 IDs -- this is the Local-ID section. */
	snprintf(lname, sizeof lname, "Phase2-ID:%s/%s/%u/%u", ssflow, ssmask,
	    tproto, sport);
d3196 10
a3205 3
	/* Set Remote-ID section. */
	snprintf(dname, sizeof dname, "Phase2-ID:%s/%s/%u/%u", sdflow, sdmask,
	    tproto, dport);
d3254 7
a3260 1
	/* Phase 2 configuration. */
d3265 4
a3268 8
	if (conf_set(af, configname, "Exchange_type", "Quick_mode", 0, 0) ||
	    conf_set(af, configname, "DOI", "IPSEC", 0, 0)) {
		conf_end(af, 0);
		goto fail;
	}
	if (conf_get_str("General", "Default-phase-2-suites")) {
		if (conf_set(af, configname, "Suites",
		    conf_get_str("General", "Default-phase-2-suites"), 0, 0)) {
d3272 13
a3284 5
	} else {
		if (conf_set(af, configname, "Suites",
		    "QM-ESP-3DES-SHA-PFS-SUITE", 0, 0)) {
			conf_end(af, 0);
			goto fail;
d3301 1
a3301 2
		snprintf(confname, sizeof confname, "ISAKMP-Configuration-%s",
		    peer);
@


1.182
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.181 2007/05/27 18:31:30 claudio Exp $  */
d72 4
a75 4
	((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0xffff) &&	\
	(*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0xffff) &&		\
	(*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == 0xffff) &&		\
	(*(u_int32_t *)(void *)(&(a)->s6_addr[12]) == 0xffff))
@


1.181
log
@Don't include sys/mbuf.h it is not needed. OK mcbride@@ msf@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.180 2007/04/16 13:01:39 moritz Exp $  */
d340 1
a340 1
	iov = (struct iovec *) malloc(cnt * sizeof *iov);
@


1.180
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.179 2007/04/08 11:20:31 moritz Exp $  */
a42 1
#include <sys/mbuf.h>
@


1.179
log
@Fix lint comments. s/Fall through/FALLTHROUGH/.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.178 2007/02/19 09:43:34 hshoexer Exp $  */
d126 1
a126 1
	struct pf_key_v2_node *node = 0;
d145 1
a145 2
	if (node)
		free(node);
d323 1
a323 2
	if (buf)
		free(buf);
d394 1
a394 2
	if (iov)
		free(iov);
d653 2
a654 4
	if (spi)
		free(spi);
	if (addr)
		free(addr);
d1311 1
a1311 2
		if (sid)
			free(sid);
d1344 1
a1344 2
		if (sid)
			free(sid);
d1576 1
a1576 2
	if (addr_str)
		free(addr_str);
d1612 4
a1615 8
	if (sid)
		free(sid);
	if (addr)
		free(addr);
	if (life)
		free(life);
	if (key)
		free(key);
d1832 4
a1835 8
	if (laddr_str)
		free(laddr_str);
	if (lmask_str)
		free(lmask_str);
	if (raddr_str)
		free(raddr_str);
	if (rmask_str)
		free(rmask_str);
d1861 2
a1862 4
	if (sid)
		free(sid);
	if (addr)
		free(addr);
d2023 2
a2024 4
	if (sid)
		free(sid);
	if (did)
		free(did);
d2286 1
a2286 2
	if (addr)
		free(addr);
d2382 1
a2382 2
	if (dst_str)
		free(dst_str);
d3295 1
a3295 2
				if (certprint)
					free(certprint);
d3459 4
a3462 8
	if (srcid)
		free(srcid);
	if (dstid)
		free(dstid);
	if (peer)
		free(peer);
	if (conn)
		free(conn);
d3648 1
a3648 2
	if (addr)
		free(addr);
@


1.178
log
@isakmpd bits for ESP+NULL encryption.  This is useful, when AH can
not be used (when being behind NAT).  With Martin Hedenfalk
<martin.hedenfalk at gmail.com>, thanks!
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.177 2006/11/24 13:52:14 reyk Exp $  */
d2824 1
a2824 1
			/* Fall through */
d2973 1
a2973 2
			/* Fall through */

d3433 1
a3433 2
			} else	/* Fall through */
			{
@


1.177
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.176 2006/09/01 00:24:06 mpf Exp $  */
d955 4
@


1.176
log
@Add a new UI command to force isakmpd into passive only mode.
Will be used by sasyncd to prevent two talking isakmpd's in an HA setup.
Based on a diff by ho@@.
OK ho@@, hshoexer@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.175 2006/08/30 22:54:32 henning Exp $  */
d905 1
d921 1
a921 1
	char           *addr_str;
d1553 15
d1574 4
a1577 2
	    "satype %d dst %s SPI 0x%x", msg.sadb_msg_satype,
	    addr_str ? addr_str : "unknown", ntohl(ssa.sadb_sa_spi)));
@


1.175
log
@fix isakmpd -Ka, as used by bgpd, or acquire flows set up via ipsecctl.
acquire flows need to be recorded on the fly via connection_record_passive(),
otherwise later lookups fail and the policy check fails.
ok hshoexer ho markus msf deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.173 2006/08/30 10:50:36 markus Exp $  */
d65 1
d3482 2
a3483 1
		pf_key_v2_acquire(msg);
@


1.174
log
@need to retry writing to pfkey socket on EAGAIN, ok theo hshoexer
@
text
@d55 1
d3452 1
@


1.173
log
@do not call pf_key_v2_disable_sa twice; ok hshoexer, ho
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.172 2006/06/10 20:10:02 hshoexer Exp $  */
d376 3
a378 1
	n = writev(pf_key_v2_socket, iov, cnt);
@


1.172
log
@support sha2 for main mode hmacs and aesctr for quick mode encryption.
ok markus@@ ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.171 2006/05/31 04:58:13 hshoexer Exp $  */
a2168 8

	/*
	 * If the SA was not replaced and was not one acquired through the
	 * kernel (ACQUIRE message), remove the flow associated with it.
	 * We ignore any errors from the disabling of the flow.
	 */
	if (!(sa->flags & SA_FLAG_REPLACED) && !(sa->flags & SA_FLAG_ONDEMAND))
		pf_key_v2_disable_sa(sa, incoming);
@


1.171
log
@tiny KNF
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.170 2006/05/31 04:54:46 hshoexer Exp $  */
a936 1
			/* case IPSEC_ESP_AES_128_CTR: */
d938 4
@


1.170
log
@Make sure, that phase 1 SAs of active connections stay alive.  Fixes a DPD
breakage noticed and reported by Mitja Muzenic.

ok markus@@ ho@@, testing by Mitja and cloder@@, discussed with Nathanael.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.169 2006/05/29 10:17:59 markus Exp $  */
d3523 1
a3523 1
		     struct proto *proto2, int incoming)
@


1.169
log
@export pf_key_v2_disable_sa() (unbreaks build)
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.168 2005/11/14 23:25:11 deraadt Exp $  */
d2322 1
a2322 1
		exchange_establish(conn, pf_key_v2_stayalive, conn);
d2428 1
a2428 1
		exchange_establish(sa->name, 0, 0);
@


1.168
log
@use snprintf; ok cloder.  also looked at by a few other people
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.167 2005/06/14 10:50:47 hshoexer Exp $  */
d2126 1
a2126 1
static int
@


1.167
log
@add ENCAP_UDP_{TUNNEL,TRANSPORT} types according to rfc 3947

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.166 2005/06/01 23:04:35 cloder Exp $  */
d2451 1
a2451 1
	int		slen, af, afamily, masklen, buflen;
d2778 3
a2780 6
			slen = strlen((char *) (srcident + 1)) +
			    sizeof "ID:Address/";
			srcid = malloc(slen);
			if (!srcid) {
				log_error("pf_key_v2_acquire: "
				    "malloc (%d) failed", slen);
a2782 2
			snprintf(srcid, slen, "ID:Address/%s",
			    (char *) (srcident + 1));
d2851 3
a2853 6
			buflen = (slen ? slen : strlen(pwd->pw_name)) +
			    strlen(prefstring) + sizeof "ID:/";
			srcid = malloc(buflen);
			if (!srcid) {
				log_error("pf_key_v2_acquire: "
				    "malloc (%d) failed", buflen);
a2855 6
			snprintf(srcid, buflen, "ID:%s/", prefstring);
			if (slen != 0)
				strlcat(srcid,
				    (char *) (srcident + 1), buflen);
			else
				strlcat(srcid, pwd->pw_name, buflen);
d2927 3
a2929 6
			slen = strlen((char *) (dstident + 1)) +
			    sizeof "ID:Address/";
			dstid = malloc(slen);
			if (!dstid) {
				log_error("pf_key_v2_acquire: "
				    "malloc (%d) failed", slen);
a2931 2
			snprintf(dstid, slen, "ID:Address/%s",
			    (char *) (dstident + 1));
d3000 3
a3002 6
			buflen = (slen ? slen : strlen(pwd->pw_name)) +
			    strlen(prefstring) + sizeof "ID:/";
			dstid = malloc(buflen);
			if (!dstid) {
				log_error("pf_key_v2_acquire: "
				    "malloc (%d) failed", buflen);
a3004 6
			snprintf(dstid, buflen, "ID:%s/", prefstring);
			if (slen != 0)
				strlcat(dstid, (char *) (dstident + 1),
				    buflen);
			else
				strlcat(dstid, pwd->pw_name, buflen);
a3068 6
	slen = strlen(dstbuf) + strlen(srcbuf) + (srcid ? strlen(srcid) : 0)
		+ (dstid ? strlen(dstid) : 0) + sizeof "Peer-/-/";
	peer = malloc(slen);
	if (!peer)
		goto fail;

d3080 4
a3083 3
	snprintf(peer, slen, "Peer-%s%s%s%s%s%s%s", dstbuf, srcaddr ? "/" : "",
		 srcaddr ? srcbuf : "", srcid ? "-" : "", srcid ? srcid : "",
		 dstid ? (srcid ? "/" : "-/") : "", dstid ? dstid : "");
d3105 1
a3105 1
		 tproto, sport);
@


1.166
log
@Fix memory leak. OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.165 2005/05/22 06:22:53 cloder Exp $  */
d1086 2
a1087 1
	    iproto->encap_mode == IPSEC_ENCAP_UDP_ENCAP_TUNNEL)
@


1.165
log
@No more ifdef KAME.  From hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.164 2005/04/08 23:15:26 hshoexer Exp $  */
d2479 1
@


1.164
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.163 2005/04/08 19:40:03 deraadt Exp $  */
a42 1
#ifdef SADB_X_EXT_FLOW_TYPE
a44 1
#endif
a104 19
#ifdef KAME
/*
 * KAME requires the sadb_msg_seq of an UPDATE be the same of that of the
 * GETSPI creating the larval SA.
 */
struct pf_key_v2_sa_seq {
	TAILQ_ENTRY(pf_key_v2_sa_seq) link;
	u_int8_t       *spi;
	size_t		sz;
	u_int8_t	proto;
	struct sockaddr *dst;
	int		dstlen;
	u_int32_t       seq;
};

TAILQ_HEAD(, pf_key_v2_sa_seq) pf_key_v2_sa_seq_map;
#endif

#ifndef KAME
a105 1
#endif
a115 1
#ifdef SADB_X_ASKPOLICY
a116 1
#endif
a120 51
#ifdef KAME
static int
pf_key_v2_register_sa_seq(u_int8_t *spi, size_t sz, u_int8_t proto,
    struct sockaddr *dst, int dstlen, u_int32_t seq)
{
	struct pf_key_v2_sa_seq *node = 0;

	node = calloc(1, sizeof *node);
	if (!node)
		goto cleanup;
	node->spi = malloc(sz);
	if (!node->spi)
		goto cleanup;
	node->dst = malloc(SA_LEN(dst));
	if (!node->dst)
		goto cleanup;
	memcpy(node->dst, dst, SA_LEN(dst));
	node->dstlen = SA_LEN(dst);
	memcpy(node->spi, spi, sz);
	node->sz = sz;
	node->proto = proto;
	node->seq = seq;
	TAILQ_INSERT_TAIL(&pf_key_v2_sa_seq_map, node, link);
	return 1;

cleanup:
	if (node) {
		if (node->spi)
			free(node->spi);
		free(node);
	}
	return 0;
}

static u_int32_t
pf_key_v2_seq_by_sa(u_int8_t *spi, size_t sz, u_int8_t proto,
    struct sockaddr *dst, int dstlen)
{
	struct pf_key_v2_sa_seq *node;

	for (node = TAILQ_FIRST(&pf_key_v2_sa_seq_map); node;
	    node = TAILQ_NEXT(node, link))
		if (node->proto == proto &&
		    node->sz == sz && memcmp(node->spi, spi, sz) == 0 &&
		    node->dstlen == SA_LEN(dst) &&
		    memcmp(node->dst, dst, SA_LEN(dst)) == 0)
			return node->seq;
	return 0;
}
#endif

a486 1
#ifdef SADB_X_SATYPE_IPCOMP
a504 5
#endif /* SADB_X_SATYPE_IPCOMP */

#ifdef KAME
	TAILQ_INIT(&pf_key_v2_sa_seq_map);
#endif
a533 3
#ifdef KAME
	struct sadb_x_sa2 ssa2;
#endif
a542 1
#ifdef SADB_X_SATYPE_IPCOMP
a545 1
#endif
a556 9
#ifdef KAME
	bzero(&ssa2, sizeof ssa2);
	ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
	ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
	ssa2.sadb_x_sa2_mode = 0;
	if (pf_key_v2_msg_add(getspi, (struct sadb_ext *)&ssa2, 0) == -1)
		goto cleanup;
#endif

a564 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a586 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a645 5
#ifdef KAME
	if (!pf_key_v2_register_sa_seq(spi, *sz, proto, dst, SA_LEN(dst),
	    ((struct sadb_msg *) (TAILQ_FIRST(ret)->seg))->sadb_msg_seq))
		goto cleanup;
#endif
a675 1
#if defined (SADB_X_EXT_UDPENCAP)
a676 1
#endif
a689 1
#ifdef SADB_X_SATYPE_IPCOMP
a692 1
#endif
a718 2
	/* XXX KAME SADB_X_EXT_xyz here? */

a726 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a792 1
#if defined (SADB_X_EXT_LIFETIME_LASTUSE)
a797 1
#endif
a822 1
#if defined (SADB_X_EXT_UDPENCAP)
a827 1
#endif
a909 1
#ifndef KAME
a911 4
#else				/* KAME */
	struct sadb_x_sa2 ssa2;
#endif
#if defined (SADB_X_CREDTYPE_NONE) || defined (SADB_X_AUTHTYPE_NONE)
a914 1
#endif
a935 1
#ifdef SADB_X_EALG_AES
a939 1
#endif
a940 1
#ifdef SADB_X_EALG_CAST
a943 1
#endif
a944 1
#ifdef SADB_X_EALG_BLF
a947 1
#endif
a956 3
#ifdef SADB_AALG_MD5HMAC96
			ssa.sadb_sa_auth = SADB_AALG_MD5HMAC96;
#else
a957 1
#endif
a960 3
#ifdef SADB_AALG_SHA1HMAC96
			ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC96;
#else
a961 1
#endif
a963 1
#ifndef KAME
a964 3
#ifdef SADB_X_AALG_RIPEMD160HMAC96
			ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC96;
#elif defined (SADB_X_AALG_RIPEMD160HMAC)
a965 5
#elif defined (SADB_X_AALG_RIPEMD160)
			ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160;
#else
			ssa.sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
#endif
a966 1
#endif
a967 1
#ifdef SADB_X_AALG_SHA2_256
a970 1
#endif
a971 1
#ifdef SADB_X_AALG_SHA2_384
a974 1
#endif
a975 1
#ifdef SADB_X_AALG_SHA2_512
a978 1
#endif
a1000 3
#ifdef SADB_AALG_MD5HMAC96
			ssa.sadb_sa_auth = SADB_AALG_MD5HMAC96;
#else
a1001 1
#endif
a1004 3
#ifdef SADB_AALG_SHA1HMAC96
			ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC96;
#else
a1005 1
#endif
a1007 1
#ifndef KAME
a1008 3
#ifdef SADB_X_AALG_RIPEMD160HMAC96
			ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC96;
#elif defined (SADB_X_AALG_RIPEMD160HMAC)
a1009 5
#elif defined (SADB_X_AALG_RIPEMD160)
			ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160;
#else
			ssa.sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
#endif
a1010 1
#endif
a1011 1
#ifdef SADB_X_AALG_SHA2_256
a1014 1
#endif
a1015 1
#ifdef SADB_X_AALG_SHA2_384
a1018 1
#endif
a1019 1
#ifdef SADB_X_AALG_SHA2_512
a1022 1
#endif
a1030 1
#ifdef SADB_X_SATYPE_IPCOMP
a1041 1
#ifdef SADB_X_CALG_OUI
a1044 1
#endif
a1045 1
#ifdef SADB_X_CALG_DEFLATE
a1048 1
#endif
a1049 1
#ifdef SADB_X_CALG_LZS
a1052 7
#endif

#ifdef SADB_X_CALG_V42BIS
		case IPSEC_IPCOMP_V42BIS:
			ssa.sadb_sa_encrypt = SADB_X_CALG_V42BIS;
			break;
#endif
a1057 1
#endif /* SADB_X_SATYPE_IPCOMP */
a1066 5
#ifdef KAME
	msg.sadb_msg_seq = (incoming ?
	    pf_key_v2_seq_by_sa(proto->spi[incoming], sizeof ssa.sadb_sa_spi,
	    proto->proto, dst, SA_LEN(dst)) : 0);
#else
a1067 1
#endif
a1071 9
#ifdef KAME
	bzero(&ssa2, sizeof ssa2);
	ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
	ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
	ssa2.sadb_x_sa2_mode = 0;
	if (pf_key_v2_msg_add(update, (struct sadb_ext *)&ssa2, 0) == -1)
		goto cleanup;
#endif

a1084 1
#ifdef SADB_X_SAFLAGS_TUNNEL
a1087 1
#endif
a1168 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a1189 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a1213 4
#ifndef __OpenBSD__
		addr->sadb_address_proto = 0;
		addr->sadb_address_prefixlen = 0;
#endif
a1271 1
#ifndef KAME
a1340 1
#endif /* KAME */
a1341 1
#ifdef SADB_X_CREDTYPE_NONE
a1373 1
#if defined (SADB_X_EXT_REMOTE_CREDENTIALS)
a1411 1
#endif
a1413 1
#endif /* SADB_X_CREDTYPE_NONE */
a1414 1
#ifdef SADB_X_AUTHTYPE_NONE
a1468 1
#endif				/* SADB_X_AUTHTYPE_NONE */
a1469 1
#ifdef SADB_X_EXT_FLOW_TYPE
a1542 1
#endif /* SADB_X_EXT_FLOW_TYPE */
a1637 1
#if defined (SADB_X_ADDFLOW) && defined (SADB_X_DELFLOW)
a1638 1
#if defined (SADB_X_EXT_FLOW_TYPE)
a1640 3
#else
	struct sadb_sa  ssa;
#endif
a1646 5
#if !defined (SADB_X_SAFLAGS_INGRESS_FLOW) && !defined (SADB_X_EXT_FLOW_TYPE)
	if (ingress)
		return 0;
#endif

a1666 1
#if defined (SADB_X_EXT_FLOW_TYPE)
a1721 22
#else				/* SADB_X_EXT_FLOW_TYPE */
	/* Setup the SA extension.  */
	ssa.sadb_sa_exttype = SADB_EXT_SA;
	ssa.sadb_sa_len = sizeof ssa / PF_KEY_V2_CHUNK;
	memcpy(&ssa.sadb_sa_spi, spi, sizeof ssa.sadb_sa_spi);
	ssa.sadb_sa_replay = 0;
	ssa.sadb_sa_state = 0;
	ssa.sadb_sa_auth = 0;
	ssa.sadb_sa_encrypt = 0;
	ssa.sadb_sa_flags = 0;
#if defined (SADB_X_SAFLAGS_INGRESS_FLOW)
	if (ingress)
		ssa.sadb_sa_flags |= SADB_X_SAFLAGS_INGRESS_FLOW;
#endif
#if defined (SADB_X_SAFLAGS_REPLACEFLOW)
	if (!delete && !ingress)
		ssa.sadb_sa_flags |= SADB_X_SAFLAGS_REPLACEFLOW;
#endif

	if (pf_key_v2_msg_add(flow, (struct sadb_ext *)&ssa, 0) == -1)
		goto cleanup;
#endif				/* SADB_X_EXT_FLOW_TYPE */
a1726 3
#if !defined (SADB_X_EXT_FLOW_TYPE)
	if (!delete || ingress)
#else
a1727 1
#endif				/* SADB_X_EXT_FLOW_TYPE */
a1734 1
#if defined (SADB_X_EXT_FLOW_TYPE)
a1735 3
#else
		pf_key_v2_setup_sockaddr(addr + 1, dst, 0, 0, 0);
#endif
a1846 1
#if defined (SADB_X_EXT_FLOW_TYPE)
a1848 1
#endif				/* SADB_X_EXT_FLOW_TYPE */
a1855 198

#elif defined (SADB_X_SPDADD) && defined (SADB_X_SPDDELETE)
	struct sadb_msg msg;
	struct sadb_x_policy *policy = 0;
	struct sadb_x_ipsecrequest *ipsecrequest;
	struct sadb_x_sa2 ssa2;
	struct sadb_address *addr = 0;
	struct sockaddr *saddr;
	struct pf_key_v2_msg *flow = 0, *ret = 0;
	u_int8_t       *policy_buf;
	size_t		len;
	int		err;
	struct sockaddr_in *ip4_sa;
	struct sockaddr_in6 *ip6_sa;

	msg.sadb_msg_type = delete ? SADB_X_SPDDELETE : SADB_X_SPDADD;
	msg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
	msg.sadb_msg_seq = 0;
	flow = pf_key_v2_msg_new(&msg, 0);
	if (!flow)
		goto cleanup;

	bzero(&ssa2, sizeof ssa2);
	ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
	ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
	ssa2.sadb_x_sa2_mode = 0;
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *)&ssa2, 0) == -1)
		goto cleanup;

	/*
	 * Setup the ADDRESS extensions.
	 */
	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(src));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_proto = IPSEC_ULPROTO_ANY;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, laddr, 0, IPSEC_PORT_ANY, 0);
	switch (laddr->sa_family) {
	case AF_INET:
		ip4_sa = (struct sockaddr_in *) lmask;
		addr->sadb_address_prefixlen
			= pf_key_v2_mask_to_bits(ip4_sa->sin_addr.s_addr);
		break;
	case AF_INET6:
		ip6_sa = (struct sockaddr_in6 *) lmask;
		addr->sadb_address_prefixlen =
			pf_key_v2_mask6_to_bits(&ip6_sa->sin6_addr.s6_addr[0]);
		break;
	}
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	len = sizeof *addr + PF_KEY_V2_ROUND(SA_LEN(raddr));
	addr = calloc(1, len);
	if (!addr)
		goto cleanup;
	addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
	addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
	addr->sadb_address_proto = IPSEC_ULPROTO_ANY;
	addr->sadb_address_reserved = 0;
	pf_key_v2_setup_sockaddr(addr + 1, raddr, 0, IPSEC_PORT_ANY, 0);
	switch (raddr->sa_family) {
	case AF_INET:
		ip4_sa = (struct sockaddr_in *) rmask;
		addr->sadb_address_prefixlen
			= pf_key_v2_mask_to_bits(ip4_sa->sin_addr.s_addr);
		break;
	case AF_INET6:
		ip6_sa = (struct sockaddr_in6 *) rmask;
		addr->sadb_address_prefixlen =
			pf_key_v2_mask6_to_bits(&ip6_sa->sin6_addr.s6_addr[0]);
		break;
	}
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) addr,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	addr = 0;

	/* Setup the POLICY extension.  */
	len = sizeof *policy + sizeof *ipsecrequest +
		2 * PF_KEY_V2_ROUND(SA_LEN(src));
	policy_buf = (u_int8_t *) calloc(1, len);
	if (!policy_buf) {
		log_error("pf_key_v2_flow: calloc %lu failed",
		    (unsigned long) len);
		goto cleanup;
	}
	policy = (struct sadb_x_policy *) policy_buf;
	policy->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
	policy->sadb_x_policy_len = len / PF_KEY_V2_CHUNK;
	policy->sadb_x_policy_type = IPSEC_POLICY_IPSEC;
	if (ingress)
		policy->sadb_x_policy_dir = IPSEC_DIR_INBOUND;
	else
		policy->sadb_x_policy_dir = IPSEC_DIR_OUTBOUND;
	policy->sadb_x_policy_reserved = 0;

	/* Setup the IPSECREQUEST extension part.  */
	ipsecrequest = (struct sadb_x_ipsecrequest *) (policy + 1);
	ipsecrequest->sadb_x_ipsecrequest_len = len - sizeof *policy;
	switch (proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		ipsecrequest->sadb_x_ipsecrequest_proto = IPPROTO_ESP;
		break;
	case IPSEC_PROTO_IPSEC_AH:
		ipsecrequest->sadb_x_ipsecrequest_proto = IPPROTO_AH;
		break;
	default:
		log_print("pf_key_v2_flow: invalid proto %d", proto);
		goto cleanup;
	}
	ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TUNNEL; /* XXX */
	ipsecrequest->sadb_x_ipsecrequest_level
		= ingress ? IPSEC_LEVEL_USE : IPSEC_LEVEL_REQUIRE;
	ipsecrequest->sadb_x_ipsecrequest_reqid = 0;	/* XXX */

	/* Add source and destination addresses. */
	saddr = (struct sockaddr *)(ipsecrequest + 1);
	pf_key_v2_setup_sockaddr(saddr, src, 0, 0, 0);
	switch (src->sa_family) {
	case AF_INET:
		saddr = (struct sockaddr *)((struct sockaddr_in *)saddr + 1);
		break;
	case AF_INET6:
		saddr = (struct sockaddr *)((struct sockaddr_in6 *)saddr + 1);
		break;
	}
	pf_key_v2_setup_sockaddr(saddr, dst, 0, 0, 0);
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *)policy,
	    PF_KEY_V2_NODE_MALLOCED) == -1)
		goto cleanup;
	policy = 0;

	if (sockaddr2text(laddr, &laddr_str, 0))
		laddr_str = 0;
	if (sockaddr2text(lmask, &lmask_str, 0))
		lmask_str = 0;
	if (sockaddr2text(raddr, &raddr_str, 0))
		raddr_str = 0;
	if (sockaddr2text(rmask, &rmask_str, 0))
		rmask_str = 0;

	LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_flow: src %s %s dst %s %s",
	 laddr_str ? laddr_str : "<??\?>", lmask_str ? lmask_str : "<??\?>",
		 raddr_str ? raddr_str : "<??\?>",
		 rmask_str ? rmask_str : "<??\?>"));

	if (laddr_str)
		free(laddr_str);
	if (lmask_str)
		free(lmask_str);
	if (raddr_str)
		free(raddr_str);
	if (rmask_str)
		free(rmask_str);

	ret = pf_key_v2_call(flow);
	pf_key_v2_msg_free(flow);
	flow = 0;
	if (!ret)
		goto cleanup;
	err = ((struct sadb_msg *)TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
	if (!delete && err == EEXIST) {
		LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_flow: "
		    "SPDADD returns EEXIST"));
	} else if (err) {
		log_print("pf_key_v2_flow: SPD%s: %s",
		    delete ? "DELETE" : "ADD", strerror(err));
		goto cleanup;
	}
	pf_key_v2_msg_free(ret);

	LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_flow: SPD%s: done",
		 delete ? "DELETE" : "ADD"));

	return 0;

cleanup:
	if (addr)
		free(addr);
	if (policy)
		free(policy);
	if (flow)
		pf_key_v2_msg_free(flow);
	if (ret)
		pf_key_v2_msg_free(ret);
	return -1;

#else
	log_print("pf_key_v2_flow: not supported in pure PF_KEYv2");
	return -1;
#endif
a1857 1
#ifndef KAME
a1964 1
#endif
a1976 4
#if !defined (SADB_X_EXT_FLOW_TYPE)
	struct sockaddr_storage hostmask_storage;
	struct sockaddr *hostmask = (struct sockaddr *)&hostmask_storage;
#endif				/* SADB_X_EXT_FLOW_TYPE */
a1980 1
#if defined (SADB_X_EXT_FLOW_TYPE)
a1996 1
#endif				/* SADB_X_EXT_FLOW_TYPE */
a2004 30
#if !defined (SADB_X_EXT_FLOW_TYPE)
	/* Set hostmask to '-1'. */
	switch (dst->sa_family) {
	case AF_INET:
		((struct sockaddr_in *) hostmask)->sin_family = AF_INET;
		((struct sockaddr_in *) hostmask)->sin_len =
		    sizeof(struct in_addr);
		memset(&((struct sockaddr_in *) hostmask)->sin_addr.s_addr,
		    0xff, sizeof(struct in_addr));
		break;
	case AF_INET6:
		((struct sockaddr_in6 *) hostmask)->sin6_family = AF_INET6;
		((struct sockaddr_in6 *) hostmask)->sin6_len =
		    sizeof(struct in6_addr);
		memset(&((struct sockaddr_in6 *) hostmask)->sin6_addr.s6_addr,
		    0xff, sizeof(struct in6_addr));
		break;
	}

	/* Ingress flows, handling SA bundles. */
	while (TAILQ_NEXT(proto, link)) {
		error = pf_key_v2_flow(dst, hostmask, src, hostmask, 0, 0, 0,
		    proto->spi[1], proto->proto, src, dst, 0, 1, 0, 0, 0, 0, 0,
		    0, proto->data);
		if (error)
			goto cleanup;
		proto = TAILQ_NEXT(proto, link);
	}
#endif				/* SADB_X_EXT_FLOW_TYPE */

a2010 1
#if defined (SADB_X_EXT_FLOW_TYPE)
a2014 1
#endif				/* SADB_X_EXT_FLOW_TYPE */
a2018 1
#if defined (SADB_X_ASKPOLICY)
a2036 1
#endif
a2130 5
#if !defined (SADB_X_EXT_FLOW_TYPE)
	struct sockaddr_storage hostmask_storage;
	struct sockaddr *hostmask = (struct sockaddr *)&hostmask_storage;
	int		error;
#endif				/* SADB_X_EXT_FLOW_TYPE */
a2140 32
#if !defined (SADB_X_EXT_FLOW_TYPE)
		/* Set hostmask to '-1'. */
		switch (dst->sa_family) {
		case AF_INET:
			((struct sockaddr_in *) hostmask)->sin_family =
			    AF_INET;
			((struct sockaddr_in *) hostmask)->sin_len =
			    sizeof(struct in_addr);
			memset(&((struct sockaddr_in *) hostmask)->sin_addr.s_addr,
			    0xff, sizeof(struct in_addr));
			break;
		case AF_INET6:
			((struct sockaddr_in6 *) hostmask)->sin6_family =
			    AF_INET6;
			((struct sockaddr_in6 *) hostmask)->sin6_len =
			    sizeof(struct in6_addr);
			memset(&((struct sockaddr_in6 *) hostmask)->sin6_addr.s6_addr,
			    0xff, sizeof(struct in6_addr));
			break;
		}

		/* Ingress flow --- SA bundles */
		while (TAILQ_NEXT(proto, link)) {
			error = pf_key_v2_flow(dst, hostmask, src, hostmask,
			    0, 0, 0, proto->spi[1], proto->proto, src, dst,
			    1, 1, 0, 0, 0, 0, 0, 0, proto->data);
			if (error)
				return error;
			proto = TAILQ_NEXT(proto, link);
		}
#endif				/* SADB_X_EXT_FLOW_TYPE */

a2160 3
#ifdef KAME
	struct sadb_x_sa2 ssa2;
#endif
a2187 1
#if defined (SADB_X_SATYPE_IPCOMP)
a2190 1
#endif
a2212 9
#ifdef KAME
	bzero(&ssa2, sizeof ssa2);
	ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
	ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
	ssa2.sadb_x_sa2_mode = 0;
	if (pf_key_v2_msg_add(delete, (struct sadb_ext *)&ssa2, 0) == -1)
		goto cleanup;
#endif

a2225 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a2250 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a2402 1
#ifdef SADB_X_SATYPE_IPCOMP
a2406 1
#endif
a2438 1
#if defined (SADB_X_ASKPOLICY)
a2463 1
#if defined (SADB_X_CREDTYPE_NONE)
a2464 1
#endif
a2555 1
#if defined (SADB_X_EXT_LOCAL_CREDENTIALS)
a2560 1
#endif
a2561 1
#if defined (SADB_X_EXT_LOCAL_AUTH)
a2566 1
#endif
a2741 1
#if defined (SADB_X_IDENTTYPE_CONNECTION)
a2744 1
#endif
a2904 1
#if defined (SADB_X_IDENTTYPE_CONNECTION)
a2907 1
#endif
a3271 1
#if defined (SADB_X_CREDTYPE_NONE)
a3334 1
#endif				/* SADB_X_CREDTYPE_NONE */
a3337 1
#if defined (SADB_X_EXT_LOCAL_AUTH)
a3444 1
#endif				/* SADB_X_EXT_LOCAL_AUTH */
a3501 4
#else
	/* acquire not supported */
	return;
#endif				/* SADB_X_ASKPOLICY */
a3555 1
#if defined (SADB_X_GRPSPIS)
a3563 3
#ifdef KAME
	struct sadb_x_sa2 kamesa2;
#endif
a3572 1
#if defined (SADB_X_SATYPE_IPCOMP)
a3575 1
#endif
a3598 1
#ifndef KAME
a3609 8
#else
	bzero(&kamesa2, sizeof kamesa2);
	kamesa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
	kamesa2.sadb_x_sa2_len = sizeof kamesa2 / PF_KEY_V2_CHUNK;
	kamesa2.sadb_x_sa2_mode = 0;
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *)&kamesa2, 0) == -1)
		goto cleanup;
#endif
a3623 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a3636 4
#ifndef __OpenBSD__
	addr->sadb_address_proto = 0;
	addr->sadb_address_prefixlen = 0;
#endif
a3654 1
#if defined (SADB_X_SATYPE_IPCOMP)
a3657 1
#endif
a3691 5

#else				/* SADB_X_GRPSPIS */
	log_print("pf_key_v2_group_spis: not supported in pure PF_KEYv2");
	return -1;
#endif
@


1.163
log
@USE_DEBUG is bye bye
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.162 2005/04/08 17:15:01 deraadt Exp $  */
a40 2
#include "sysdep.h"

d158 1
a158 1
	node->dst = malloc(sysdep_sa_len(dst));
d161 2
a162 2
	memcpy(node->dst, dst, sysdep_sa_len(dst));
	node->dstlen = sysdep_sa_len(dst);
d189 2
a190 2
		    node->dstlen == sysdep_sa_len(dst) &&
		    memcmp(node->dst, dst, sysdep_sa_len(dst)) == 0)
d654 1
a654 1
	    sizeof(struct sadb_address) + PF_KEY_V2_ROUND(sysdep_sa_len(src));
d665 1
a665 1
	memcpy(addr + 1, src, sysdep_sa_len(src));
d680 1
a680 1
	    sizeof(struct sadb_address) + PF_KEY_V2_ROUND(sysdep_sa_len(dst));
d691 1
a691 1
	memcpy(addr + 1, dst, sysdep_sa_len(dst));
d750 1
a750 2
	if (!pf_key_v2_register_sa_seq(spi, *sz, proto, dst,
	    sysdep_sa_len(dst),
d835 1
a835 1
	    sizeof(struct sadb_address) + PF_KEY_V2_ROUND(sysdep_sa_len(dst));
d846 1
a846 1
	memcpy(addr + 1, dst, sysdep_sa_len(dst));
d1266 1
a1266 1
	    proto->proto, dst, sysdep_sa_len(dst)) : 0);
d1376 1
a1376 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(src));
d1387 1
a1387 1
	memcpy(addr + 1, src, sysdep_sa_len(src));
d1401 1
a1401 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(dst));
d1412 1
a1412 1
	memcpy(addr + 1, dst, sysdep_sa_len(dst));
d1429 1
a1429 1
		len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(dst));
d1440 1
a1440 1
		memcpy(addr + 1, dst, sysdep_sa_len(dst));
d1723 1
a1723 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(isa->src_net));
a1859 1
 * Should probably be moved to sysdep.c
d1994 1
a1994 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(src));
d2017 1
a2017 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(laddr));
d2166 1
a2166 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(src));
d2192 1
a2192 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(raddr));
d2220 1
a2220 1
		2 * PF_KEY_V2_ROUND(sysdep_sa_len(src));
d2789 1
a2789 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(saddr));
d2800 1
a2800 1
	memcpy(addr + 1, saddr, sysdep_sa_len(saddr));
d2818 1
a2818 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(saddr));
d2829 1
a2829 1
	memcpy(addr + 1, saddr, sysdep_sa_len(saddr));
d4148 1
a4148 1
 * XXX Assumes OpenBSD GRPSPIS extension.  Should probably be moved to sysdep.c
d4231 1
a4231 1
	len = sizeof *addr + PF_KEY_V2_ROUND(sysdep_sa_len(saddr));
d4242 1
a4242 1
	memcpy(addr + 1, saddr, sysdep_sa_len(saddr));
d4259 1
a4259 1
	memcpy(addr + 1, saddr, sysdep_sa_len(saddr));
@


1.162
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.161 2005/04/08 16:37:14 deraadt Exp $  */
a1046 1
#ifdef USE_DEBUG
a1047 1
#endif
a1783 1
#ifdef USE_DEBUG
a1792 1
#endif				/* USE_DEBUG */
a1874 1
#ifdef USE_DEBUG
a1875 1
#endif
a2078 1
#ifdef USE_DEBUG
a2101 1
#endif				/* USE_DEBUG */
a2276 1
#ifdef USE_DEBUG
a2298 1
#endif
a2918 1
#ifdef USE_DEBUG
a2919 1
#endif
a2952 2
#ifdef USE_DEBUG

a2963 2

#endif				/* USE_DEBUG */
@


1.161
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.160 2005/04/08 16:09:25 deraadt Exp $  */
a69 1
#if defined (USE_KEYNOTE)
a70 1
#endif
a1586 1
#if defined (USE_KEYNOTE) && defined (SADB_X_EXT_REMOTE_CREDENTIALS)
a1605 1
#endif				/* USE_KEYNOTE */
@


1.160
log
@kill USE_OLD_SOCKADDR
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.159 2005/04/08 16:07:21 cloder Exp $  */
a73 1
#if defined (USE_NAT_TRAVERSAL)
a74 1
#endif
a1047 1
#if defined (USE_NAT_TRAVERSAL) && defined (SADB_X_EXT_UDPENCAP)
a1048 1
#endif
a1308 1
#if defined (USE_NAT_TRAVERSAL) && defined (SADB_X_EXT_UDPENCAP)
a1319 1
#endif
@


1.159
log
@Remove references to LINUX_IPSEC
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.158 2005/04/06 16:00:20 deraadt Exp $  */
a986 1
#ifndef USE_OLD_SOCKADDR
a987 1
#endif
a1000 1
#ifndef USE_OLD_SOCKADDR
a1001 1
#endif
a2517 1
#ifndef USE_OLD_SOCKADDR
a2519 1
#endif
a2524 1
#ifndef USE_OLD_SOCKADDR
a2526 1
#endif
a2693 1
#ifndef USE_OLD_SOCKADDR
a2695 1
#endif
a2701 1
#ifndef USE_OLD_SOCKADDR
a2703 1
#endif
@


1.158
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.157 2005/04/05 20:46:20 cloder Exp $  */
a42 1
#if !defined (LINUX_IPSEC)
a43 1
#endif
a1292 6
#if defined (LINUX_IPSEC)
	if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL)
		ssa2.sadb_x_sa2_mode = IPSEC_MODE_TUNNEL;
	else
		ssa2.sadb_x_sa2_mode = IPSEC_MODE_TRANSPORT;
#else
a1293 1
#endif
a2197 3
#ifdef LINUX_IPSEC
	addr->sadb_address_proto = tproto;
#else
a2198 1
#endif
a2199 3
#ifdef LINUX_IPSEC
	pf_key_v2_setup_sockaddr(addr + 1, laddr, 0, sport, 0);
#else
a2200 1
#endif
a2223 3
#ifdef LINUX_IPSEC
	addr->sadb_address_proto = tproto;
#else
a2224 1
#endif
a2225 3
#ifdef LINUX_IPSEC
	pf_key_v2_setup_sockaddr(addr + 1, raddr, 0, dport, 0);
#else
a2226 1
#endif
a2276 6
#if defined (LINUX_IPSEC)
	if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL)
		ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TUNNEL;
	else
		ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TRANSPORT;
#else
a2277 1
#endif
a4166 1
#if !defined (LINUX_IPSEC)
a4180 1
#endif				/* LINUX_IPSEC */
@


1.157
log
@Always compile X509 support. Almost everyone uses it.  Makes the code
much easier to read and to maintain.
OK and testing by hshoexer@@, more testing by me
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.156 2005/04/04 19:31:11 deraadt Exp $  */
d3425 2
a3426 2
			if ((afamily == AF_INET6 && masklen != 128)
			    || (afamily == AF_INET && masklen != 32)) {
d3454 3
a3456 4
				    "IPV6_ADDR", 1, 0)
				    || conf_set(af, srcid, "Refcount", "1", 1,
					0)
				    || conf_set(af, srcid, "Address",
d3536 3
a3538 4
				    1, 0)
				    || conf_set(af, srcid, "Refcount", "1", 1,
					0)
				    || conf_set(af, srcid, "Name",
d3590 2
a3591 2
			if ((afamily == AF_INET6 && masklen != 128)
			    || (afamily == AF_INET && masklen != 32)) {
d3619 3
a3621 4
				    "IPV6_ADDR", 1, 0)
				    || conf_set(af, dstid, "Refcount", "1", 1,
					0)
				    || conf_set(af, dstid, "Address",
d3701 3
a3703 4
				    1, 0)
				    || conf_set(af, dstid, "Refcount", "1", 1,
					0)
				    || conf_set(af, dstid, "Name",
d3734 2
a3735 2
		if (!conf_get_str(conn, "Phase")
		    && !conf_get_str(configname, "Suites"))
d3785 4
a3788 4
	if (conf_set(af, conn, "Phase", "2", 0, 0)
	    || conf_set(af, conn, "Flags", "__ondemand", 0, 0)
	    || conf_set(af, conn, "Refcount", "2", 0, 0)
	    || conf_set(af, conn, "ISAKMP-peer", peer, 0, 0)) {
d3811 2
a3812 2
			if (conf_set(af, lname, "ID-type", sidtype, 0, 0)
			  || conf_set(af, lname, "Address", ssflow, 0, 0)) {
d3817 3
a3819 3
			if (conf_set(af, lname, "ID-type", sidtype, 0, 0)
			    || conf_set(af, lname, "Network", ssflow, 0, 0)
			  || conf_set(af, lname, "Netmask", ssmask, 0, 0)) {
d3855 2
a3856 2
			if (conf_set(af, dname, "ID-type", didtype, 0, 0)
			    || conf_set(af, dname, "Address", sdflow, 0, 0)) {
d3861 3
a3863 3
			if (conf_set(af, dname, "ID-type", didtype, 0, 0)
			    || conf_set(af, dname, "Network", sdflow, 0, 0)
			    || conf_set(af, dname, "Netmask", sdmask, 0, 0)) {
d3898 2
a3899 2
	if (conf_set(af, configname, "Exchange_type", "Quick_mode", 0, 0)
	    || conf_set(af, configname, "DOI", "IPSEC", 0, 0)) {
d3919 3
a3921 3
		if (conf_set(af, peer, "Phase", "1", 0, 0)
		    || conf_set(af, peer, "Refcount", "1", 0, 0)
		    || conf_set(af, peer, "Address", dstbuf, 0, 0)) {
d3990 2
a3991 2
			if (!certprint
			    || conf_set(af, peer, "Credentials", certprint, 0,
d4126 3
a4128 3
			    0, 0)
			    || conf_set(af, confname, "DOI", "IPSEC", 0, 0)
			    || conf_set(af, confname, "Refcount", "1", 0, 0)) {
@


1.156
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.155 2005/03/02 12:49:51 hshoexer Exp $  */
d1630 1
a1630 1
#if defined (USE_X509) && defined (SADB_X_EXT_REMOTE_CREDENTIALS)
d1669 1
a1669 1
#endif /* USE_X509 */
@


1.155
log
@knf, linewrapping, whitespaces, no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.154 2005/02/27 14:26:00 pat Exp $  */
d138 1
a138 1
	                u_int16_t);
d830 1
a830 1
	
d887 1
a887 1
	
d910 1
a910 1
	
d920 1
a920 1
#if defined (SADB_X_EXT_LIFETIME_LASTUSE)	
d935 1
a935 1
	
d966 1
a966 1
	
d1364 1
a1364 1
				      PF_KEY_V2_NODE_MALLOCED) == -1)
d2046 1
a2046 1
				      PF_KEY_V2_NODE_MALLOCED) == -1)
d2059 1
a2059 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2071 1
a2071 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2083 1
a2083 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2095 1
a2095 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2231 1
a2231 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2265 1
a2265 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2404 1
a2404 1
			     sizeof(u_int8_t));
d2417 1
a2417 1
			     sizeof(u_int8_t));
d2430 1
a2430 1
			      addrbuf, ADDRESS_MAX) == NULL)
d3101 2
a3102 3
	char		dstbuf[ADDRESS_MAX], srcbuf[ADDRESS_MAX], *peer = 0,
	               *conn = 0;
	char		confname[120];
d3553 2
a3554 2
			     "pf_key_v2_acquire: invalid source ID type %d",
				 srcident->sadb_ident_type));
d4213 1
a4213 1
			  pf_key_v2_socket);
@


1.154
log
@cleanup correctly in some error paths.

ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.153 2005/02/27 13:12:12 hshoexer Exp $  */
d101 2
a102 2
	size_t          sz;
	int             cnt;
d104 1
a104 1
	u_int8_t        flags;
d113 1
a113 1
int             connection_seq = 0;
d123 2
a124 2
	size_t          sz;
	u_int8_t        proto;
d126 1
a126 1
	int             dstlen;
d283 1
a283 1
	ssize_t         n;
d298 1
a298 1
	         */
d417 4
a420 4
	ssize_t         n;
	size_t          len;
	int             i, cnt = TAILQ_FIRST(pmsg)->cnt;
	char            header[80];
d444 4
a447 4
		 * XXX One can envision setting specific extension fields, like
		 * *_reserved ones here.  For now we require them to be set by the
		 * caller.
	         */
d515 1
a515 1
	int             fd = -1, err;
d622 1
a622 1
	int             len, err;
d1043 2
a1044 2
	size_t          len;
	int             keylen, hashlen, err;
d1047 1
a1047 1
	int             idtype;
d1355 1
a1355 1
	         */
d1371 1
a1371 1
	         */
d1382 1
a1382 1
	         */
d1391 1
a1391 1
				      PF_KEY_V2_NODE_MALLOCED) == -1)
d1397 1
a1397 1
         */
d1601 1
a1601 1
         */
d1678 1
a1678 1
         */
d1690 1
a1690 1
	         */
d1824 1
a1824 1
         */
d1842 1
a1842 1
         */
d1879 1
a1879 1
pf_key_v2_mask6_to_bits(u_int8_t * mask)
d1881 1
a1881 1
	int             n;
d1917 2
a1918 2
	size_t          len;
	int             err;
d2026 1
a2026 1
         */
d2179 2
a2180 2
	size_t          len;
	int             err;
d2200 1
a2200 1
         */
d2396 1
a2396 1
pf_key_v2_convert_id(u_int8_t * id, int idlen, size_t * reslen, int *idtype)
d2399 1
a2399 1
	char            addrbuf[ADDRESS_MAX + 5];
d2412 1
a2412 1
			 (int) *reslen, res));
d2425 1
a2425 1
			 (int) *reslen, res));
d2510 1
a2510 1
	int             error;
d2512 2
a2513 2
	int             sidtype = 0, didtype = 0;
	size_t          sidlen = 0, didlen = 0;
d2543 3
a2545 4
			 isa->dst_mask, isa->tproto, isa->sport, isa->dport,
			       proto->spi[0], proto->proto, dst, src, 0, 0,
			       sidtype, sid, sidlen, didtype, did, didlen,
			       proto->data);
d2575 2
a2576 2
				       proto->spi[1], proto->proto, src, dst,
				       0, 1, 0, 0, 0, 0, 0, 0, proto->data);
d2584 3
a2586 4
			 isa->src_mask, isa->tproto, isa->dport, isa->sport,
			       proto->spi[1], proto->proto, src, dst, 0, 1,
			       sidtype, sid, sidlen, didtype, did, didlen,
			       proto->data);
d2604 2
a2605 2
	char            conn[22];
	int             num;
d2627 2
a2628 2
	char            conn[22];
	int             num;
d2651 1
a2651 1
	int             af;
d2663 1
a2663 1
		     attr = TAILQ_NEXT(attr, link))
d2716 1
a2716 1
	int             error;
d2782 1
a2782 1
	int             len, err;
d2796 2
a2797 3
         */
	if (!(sa->flags & SA_FLAG_REPLACED)
	    && !(sa->flags & SA_FLAG_ONDEMAND))
d2852 1
a2852 1
         */
d2878 1
a2878 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2907 1
a2907 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d2952 1
a2952 1
         */
d3042 1
a3042 1
         */
d3076 1
a3076 1
         */
d3101 1
a3101 1
	char            dstbuf[ADDRESS_MAX], srcbuf[ADDRESS_MAX], *peer = 0,
d3103 1
a3103 1
	char            confname[120];
d3105 1
a3105 1
	int             slen, af, afamily, masklen, buflen;
d3108 2
a3109 2
	char            ssflow[ADDRESS_MAX], sdflow[ADDRESS_MAX];
	char            sdmask[ADDRESS_MAX], ssmask[ADDRESS_MAX];
d3111 2
a3112 2
	char            lname[100], dname[100], configname[30];
	int             shostflag = 0, dhostflag = 0;
d3116 3
a3118 3
	u_int8_t        tproto = 0;
	char            tmbuf[sizeof sport * 3 + 1], *xform;
	int             connlen;
d3386 1
a3386 1
		         */
d3481 1
a3481 1
			         */
d3649 1
a3649 1
			         */
d3751 1
a3751 1
         *
d3762 1
a3762 1
         */
d3780 1
a3780 1
         */
d3788 1
a3788 1
         */
d3896 1
a3896 1
         */
d3946 1
a3946 1
			char            num[12], *certprint;
d4098 1
a4098 1
				         */
d4205 1
a4205 1
	int             n;
d4211 1
a4211 1
         */
d4242 2
a4243 2
	int             err;
	size_t          len;
d4307 1
a4307 1
         */
@


1.153
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.152 2005/02/25 03:02:41 cloder Exp $  */
d179 3
a181 3
	if (node->dst)
		free(node->dst);
	if (node)
d183 1
@


1.152
log
@Fix an obviously incorrect call to memset.  '0' and 0 are not the same
thing.  Input and OK from markus@@, ho@@, niklas@@, deraadt@@, hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.151 2004/12/27 11:02:03 hshoexer Exp $  */
d651 1
a651 1
	memset(&ssa2, 0, sizeof ssa2);
d881 1
a881 1
	memset(&ksa, 0, sizeof ksa);
d1291 1
a1291 1
	memset(&ssa2, 0, sizeof ssa2);
d1327 1
a1327 1
		memset(&udpencap, 0, sizeof udpencap);
d2190 1
a2190 1
	memset(&ssa2, 0, sizeof ssa2);
d2844 1
a2844 1
	memset(&ssa2, 0, sizeof ssa2);
d4299 1
a4299 1
	memset(&kamesa2, 0, sizeof kamesa2);
@


1.151
log
@Fix broken pointer arithmetic when receiving a RSA key from the kernel.  Found
and fix provided by Stefan Miltchev.  Thanks!

ok otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.150 2004/09/17 13:53:08 ho Exp $  */
d160 1
a160 1
	node = malloc(sizeof *node);
a162 1
	memset(node, '0', sizeof *node);
@


1.150
log
@Missing #ifdefs.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.149 2004/08/12 11:08:54 ho Exp $  */
d4079 1
a4079 1
					    (u_int8_t *) sauth + 1,
@


1.149
log
@Avoid memleak on error (Linux/KAME). Found by Benjamin Pineau.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.148 2004/08/10 15:59:10 ho Exp $  */
d2986 1
d2988 1
@


1.148
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.147 2004/08/08 19:11:06 deraadt Exp $  */
d2315 1
a2315 1
	saddr = (struct sockaddr *) (ipsecrequest + 1);
d2319 1
a2319 2
		saddr =
		    (struct sockaddr *) ((struct sockaddr_in *) saddr + 1);
d2322 1
a2322 2
		saddr =
		    (struct sockaddr *) ((struct sockaddr_in6 *) saddr + 1);
d2326 2
a2327 1
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) policy, 0) == -1)
d2329 1
@


1.147
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.146 2004/06/26 06:07:03 hshoexer Exp $  */
d683 1
a683 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d775 197
@


1.146
log
@Narrow down privsep interface.  Move pf_key_v2_open() to monitor.

Work in progress.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.145 2004/06/23 23:36:01 ho Exp $  */
d661 1
a661 1
	len = 
d2169 1
a2169 1
		log_print("pf_key_v2_flow: SPD%s: %s", 
d2849 1
a2849 1
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi, 
d2854 1
a2854 1
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi, 
d3293 1
a3293 1
					pwd = 
d3346 1
a3346 1
					srcid + sizeof "ID:/" - 1 + 
d3850 1
a3850 1
					    sauth->sadb_x_cred_len - 
d3894 1
a3894 1
					 * Set the key in the peer. We don't 
d4013 1
a4013 1
	 * between the select(2) call of the main loop and this handler, we 
d4172 1
a4172 1
	if (pf_key_v2_msg_add(grpspis, 
@


1.145
log
@Print corrent prefix. Found and tested by alex at vbone.net.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.144 2004/06/21 18:41:06 ho Exp $  */
a65 1
#include "monitor.h"
d151 1
a151 1
static int      pf_key_v2_socket;
d521 1
a521 1
	fd = monitor_socket(PF_KEY, SOCK_RAW, PF_KEY_V2);
@


1.144
log
@udpencap_port should be taken from dst transport
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.143 2004/06/21 15:15:38 ho Exp $  */
d2266 3
a2268 3
		    ADDRESS_MAX - strlen(addrbuf),
		    "/%d", pf_key_v2_mask_to_bits((u_int32_t)
			* (addr + sizeof(struct in_addr))));
@


1.143
log
@Tell the kernel to enable ESP-in-UDP encapsulation when we have
SAs negotiated with NAT-T.
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.142 2004/06/14 09:55:41 ho Exp $  */
a861 1
	const char *errstr;
d1137 4
a1140 12
		udpencap.sadb_x_udpencap_port =
		    strtonum(udp_encap_default_port ? udp_encap_default_port :
			UDP_ENCAP_DEFAULT_PORT_STR, 0, USHRT_MAX, &errstr);
		if (errstr)
			log_print("pf_key_v2_set_spi: bad port for UDPENCAP");
		else {
			udpencap.sadb_x_udpencap_port =
			    htons(udpencap.sadb_x_udpencap_port);
			if (pf_key_v2_msg_add(update,
			    (struct sadb_ext *)&udpencap, 0) == -1)
				goto cleanup;
		}
@


1.142
log
@KNF, style, 80c, etc. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.141 2004/06/09 14:02:44 ho Exp $  */
d73 1
a73 1
#ifdef USE_KEYNOTE
d77 4
d541 1
a541 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d561 1
a561 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d582 1
a582 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d657 1
a657 1
	if (pf_key_v2_msg_add(getspi, (struct sadb_ext *) & ssa2, 0) == -1)
d725 1
a725 1
	if (pf_key_v2_msg_add(getspi, (struct sadb_ext *) & spirange, 0) == -1)
d733 1
a733 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d860 4
d1108 1
a1108 1
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) & ssa2, 0) == -1)
d1124 1
d1126 25
a1150 4
	ssa.sadb_sa_flags = iproto->encap_mode == IPSEC_ENCAP_TUNNEL ?
	    SADB_X_SAFLAGS_TUNNEL : 0;
#else
	ssa.sadb_sa_flags = 0;
d1152 2
a1153 1
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) & ssa, 0) == -1)
d1552 1
a1552 1
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) & flowtype, 0) == -1)
d1560 1
a1560 1
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) & tprotocol,
d1647 1
a1647 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d1812 1
a1812 1
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) & flowtype, 0) == -1)
d1833 1
a1833 1
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) & ssa, 0) == -1)
d1918 1
a1918 1
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) & tprotocol, 0) == -1)
d1952 1
a1952 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d2008 1
a2008 1
	if (pf_key_v2_msg_add(flow, (struct sadb_ext *) & ssa2, 0) == -1)
d2174 1
a2174 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d2330 1
a2330 1
	struct sockaddr *hostmask = (struct sockaddr *) & hostmask_storage;
d2530 1
a2530 1
	struct sockaddr *hostmask = (struct sockaddr *) & hostmask_storage;
d2654 1
a2654 1
	if (pf_key_v2_msg_add(delete, (struct sadb_ext *) & ssa, 0) == -1)
d2662 1
a2662 1
	if (pf_key_v2_msg_add(delete, (struct sadb_ext *) & ssa2, 0) == -1)
d2732 1
a2732 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
d2801 1
a2801 1
	msg = (struct sadb_msg *) TAILQ_FIRST(pmsg)->seg;
d2944 1
a2944 1
	msg = (struct sadb_msg *) TAILQ_FIRST(pmsg)->seg;
d2981 1
a2981 1
	if (pf_key_v2_msg_add(askpolicy, (struct sadb_ext *) & policy, 0) == -1)
d3998 1
a3998 1
	switch (((struct sadb_msg *) TAILQ_FIRST(msg)->seg)->sadb_msg_type) {
d4095 1
a4095 1
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *) & sa1, 0) == -1)
d4108 1
a4108 1
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *) & sa2, 0) == -1)
d4115 1
a4115 1
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *) & kamesa2, 0) == -1)
d4183 1
a4183 1
	    (struct sadb_ext *) & protocol, 0) == -1)
d4191 1
a4191 1
	err = ((struct sadb_msg *) TAILQ_FIRST(ret)->seg)->sadb_msg_errno;
@


1.141
log
@Style nits. hshoexer@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.140 2004/04/15 18:39:26 deraadt Exp $  */
d291 4
a294 4
		 * If this is a read of a reply we should actually expect the reply to
		 * get lost as PF_KEY is an unreliable service per the specs.
		 * Currently we do this by setting a short timeout, and if it is not
		 * readable in that time, we fail the read.
d300 2
a301 1
				log_error("pf_key_v2_read: calloc (%lu, %lu) failed",
d303 1
a303 1
				    NFDBITS),
d313 2
a314 2
				log_error("pf_key_v2_read: select (%d, fds, 0, "
				    "0, &tv) failed",
d319 2
a320 1
				log_print("pf_key_v2_read: no reply from PF_KEY");
d367 4
a370 5
				LOG_DBG((LOG_SYSDEP, 90,
				    "pf_key_v2_read:"
				    "bad version (%d) or PID (%d, mine is %ld), ignored",
				    msg->sadb_msg_version, msg->sadb_msg_pid,
				    (long) getpid()));
d452 2
a453 2
		LOG_DBG_BUF((LOG_SYSDEP, 80, header, (u_int8_t *) iov[i].iov_base,
		    iov[i].iov_len));
d463 3
a465 2
		log_error("pf_key_v2_write: writev (%d, ...) returned prematurely "
		    "(%lu)", pf_key_v2_socket, (unsigned long) n);
d658 2
a659 1
	len = sizeof(struct sadb_address) + PF_KEY_V2_ROUND(sysdep_sa_len(src));
d684 2
a685 1
	len = sizeof(struct sadb_address) + PF_KEY_V2_ROUND(sysdep_sa_len(dst));
d755 2
a756 1
	if (!pf_key_v2_register_sa_seq(spi, *sz, proto, dst, sysdep_sa_len(dst),
d898 2
a899 3
			LOG_DBG((LOG_SYSDEP, 50,
			    "pf_key_v2_set_spi: unknown encryption algorithm %d",
			    proto->id));
d955 2
a956 2
			LOG_DBG((LOG_SYSDEP, 50,
			    "pf_key_v2_set_spi: unknown authentication algorithm %d",
d1021 2
a1022 3
			LOG_DBG((LOG_SYSDEP, 50,
			    "pf_key_v2_set_spi: unknown authentication algorithm %d",
			    proto->id));
d1135 2
a1136 2
		 * XXX I am not sure which one is best in security respect.  Maybe the
		 * RFCs actually mandate what a lifetime really is.
d1162 2
a1163 2
		 * XXX I am not sure which one is best in security respect.  Maybe the
		 * RFCs actually mandate what a lifetime really is.
d1281 2
a1282 1
			    (proto->proto == IPSEC_PROTO_IPSEC_ESP ? keylen : 0),
d1313 2
a1314 1
		sid = calloc(PF_KEY_V2_ROUND(len + 1) + sizeof *sid, sizeof(u_int8_t));
d1347 2
a1348 1
		sid = calloc(PF_KEY_V2_ROUND(len + 1) + sizeof *sid, sizeof(u_int8_t));
d1380 3
a1382 3
	 * our credentials, since the process either knows them (if it specified
	 * them with setsockopt()), or has no business looking at them (e.g.,
	 * system wide certs).
d1398 2
a1399 1
			cred->sadb_x_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
d1401 2
a1402 1
			cred->sadb_x_cred_exttype = SADB_X_EXT_REMOTE_CREDENTIALS;
d1419 1
a1419 1
				/* We do it this way to avoid weird includes. */
d1429 3
a1431 2
				cred = calloc(PF_KEY_V2_ROUND(len) + sizeof *cred,
				    sizeof(u_int8_t));
d1445 2
a1446 1
				if (pf_key_v2_msg_add(update, (struct sadb_ext *) cred,
d1465 7
a1471 7
		 * If it's a private key, we shouldn't pass it to the kernel for
		 * processes to see; successful authentication of Phase 1 implies
		 * that the process already knew the passphrase. On the other hand,
		 * we don't want to reveal to processes any system-wide passphrases
		 * used for authentication with remote systems. Same reason we don't
		 * send up the key (private or passphrase) we used to authenticate
		 * with the peer.
d1481 2
a1482 1
		cred = calloc(PF_KEY_V2_ROUND(len) + sizeof *cred, sizeof(u_int8_t));
d1499 2
a1500 1
			log_print("pf_key_v2_set_spi: unknown received key type %d",
d1529 2
a1530 1
	if (pf_key_v2_msg_add(update, (struct sadb_ext *) & tprotocol, 0) == -1)
d1595 3
a1597 3
	LOG_DBG((LOG_SYSDEP, 10, "pf_key_v2_set_spi: satype %d dst %s SPI 0x%x",
	    msg.sadb_msg_satype, addr_str ? addr_str : "unknown",
	    ntohl(ssa.sadb_sa_spi)));
d1604 2
a1605 2
	 * Although PF_KEY knows about expirations, it is unreliable per the specs
	 * thus we need to do them inside isakmpd as well.
d1621 3
a1623 3
	 * If we are doing an addition into an SADB shared with our peer, errors
	 * here are to be expected as the peer will already have created the SA,
	 * and can thus be ignored.
d1731 3
a1733 2
			sid = calloc(PF_KEY_V2_ROUND(srcid_len + 1) + sizeof *sid,
				     sizeof(u_int8_t));
d1738 1
a1738 1
				+ PF_KEY_V2_ROUND(srcid_len + 1) / PF_KEY_V2_CHUNK;
d1745 1
a1745 1
					      PF_KEY_V2_NODE_MALLOCED) == -1)
d1752 3
a1754 2
			sid = calloc(PF_KEY_V2_ROUND(dstid_len + 1) + sizeof *sid,
				     sizeof(u_int8_t));
d1759 1
a1759 1
				+ PF_KEY_V2_ROUND(dstid_len + 1) / PF_KEY_V2_CHUNK;
d1766 1
a1766 1
					      PF_KEY_V2_NODE_MALLOCED) == -1)
d1776 4
a1779 4
	flowtype.sadb_protocol_direction
		= ingress ? IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;
	flowtype.sadb_protocol_proto
		= ingress ? SADB_X_FLOW_TYPE_USE : SADB_X_FLOW_TYPE_REQUIRE;
d1928 2
a1929 2
			log_print("pf_key_v2_flow: %sFLOW: %s", delete ? "DEL" : "ADD",
				  strerror(err));
d2008 2
a2009 2
		addr->sadb_address_prefixlen
			= pf_key_v2_mask6_to_bits(&ip6_sa->sin6_addr.s6_addr[0]);
d2042 2
a2043 2
		addr->sadb_address_prefixlen
			= pf_key_v2_mask6_to_bits(&ip6_sa->sin6_addr.s6_addr[0]);
d2056 2
a2057 1
		log_error("pf_key_v2_flow: calloc %lu failed", (unsigned long) len);
d2090 1
a2090 1
	ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TUNNEL;	/* XXX */
d2101 2
a2102 1
		saddr = (struct sockaddr *) ((struct sockaddr_in *) saddr + 1);
d2105 2
a2106 1
		saddr = (struct sockaddr *) ((struct sockaddr_in6 *) saddr + 1);
d2145 2
a2146 1
		LOG_DBG((LOG_SYSDEP, 50, "pf_key_v2_flow: SPDADD returns EEXIST"));
d2148 2
a2149 2
		log_print("pf_key_v2_flow: SPD%s: %s", delete ? "DELETE" : "ADD",
			  strerror(err));
d2220 2
a2221 1
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv4 address %s", res));
d2225 3
a2227 2
		if (inet_ntop(AF_INET6, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			      addrbuf, ADDRESS_MAX) == NULL)
d2234 2
a2235 1
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv6 address %s", res));
d2243 4
a2246 4
		snprintf(addrbuf + strlen(addrbuf), ADDRESS_MAX - strlen(addrbuf),
			 "/%d", pf_key_v2_mask_to_bits((u_int32_t)
						       * (addr +
						  sizeof(struct in_addr))));
d2252 2
a2253 1
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv4 subnet %s", res));
d2260 4
a2263 3
		snprintf(addrbuf + strlen(addrbuf), ADDRESS_MAX - strlen(addrbuf),
			 "/%d", pf_key_v2_mask6_to_bits(addr +
						  sizeof(struct in6_addr)));
d2268 2
a2269 1
		LOG_DBG((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv6 subnet %s", res));
d2308 2
a2309 2
			sid = pf_key_v2_convert_id(isakmp_sa->id_i, isakmp_sa->id_i_len,
						   &sidlen, &sidtype);
d2311 2
a2312 2
			did = pf_key_v2_convert_id(isakmp_sa->id_i, isakmp_sa->id_i_len,
						   &didlen, &didtype);
d2316 2
a2317 2
			did = pf_key_v2_convert_id(isakmp_sa->id_r, isakmp_sa->id_r_len,
						   &didlen, &didtype);
d2319 2
a2320 2
			sid = pf_key_v2_convert_id(isakmp_sa->id_r, isakmp_sa->id_r_len,
						   &sidlen, &sidtype);
d2338 2
a2339 1
		((struct sockaddr_in *) hostmask)->sin_len = sizeof(struct in_addr);
d2341 2
a2342 2
		memset(&((struct sockaddr_in *) hostmask)->sin_addr.s_addr, 0xff,
		       sizeof(struct in_addr));
d2347 2
a2348 1
		((struct sockaddr_in6 *) hostmask)->sin6_len = sizeof(struct in6_addr);
d2350 2
a2351 2
		memset(&((struct sockaddr_in6 *) hostmask)->sin6_addr.s6_addr, 0xff,
		       sizeof(struct in6_addr));
d2507 4
a2510 4
		return pf_key_v2_flow(isa->src_net, isa->src_mask, isa->dst_net,
			 isa->dst_mask, isa->tproto, isa->sport, isa->dport,
				proto->spi[0], proto->proto, src, dst, 1, 0,
				      0, 0, 0, 0, 0, 0, proto->data);
d2516 2
a2517 1
			((struct sockaddr_in *) hostmask)->sin_family = AF_INET;
d2519 2
a2520 1
			((struct sockaddr_in *) hostmask)->sin_len = sizeof(struct in_addr);
d2522 2
a2523 2
			memset(&((struct sockaddr_in *) hostmask)->sin_addr.s_addr, 0xff,
			       sizeof(struct in_addr));
d2526 2
a2527 1
			((struct sockaddr_in6 *) hostmask)->sin6_family = AF_INET6;
d2530 1
a2530 1
				sizeof(struct in6_addr);
d2532 2
a2533 2
			memset(&((struct sockaddr_in6 *) hostmask)->sin6_addr.s6_addr, 0xff,
			       sizeof(struct in6_addr));
d2539 3
a2541 3
			error = pf_key_v2_flow(dst, hostmask, src, hostmask, 0, 0, 0,
				      proto->spi[1], proto->proto, src, dst,
				       1, 1, 0, 0, 0, 0, 0, 0, proto->data);
d2548 4
a2551 4
		return pf_key_v2_flow(isa->dst_net, isa->dst_mask, isa->src_net,
				      isa->src_mask, isa->tproto, isa->dport,
				    isa->sport, proto->spi[1], proto->proto,
			     src, dst, 1, 1, 0, 0, 0, 0, 0, 0, proto->data);
d2605 2
a2606 1
		log_print("pf_key_v2_delete_spi: invalid proto %d", proto->proto);
d2753 2
a2754 2
		LOG_DBG((LOG_SYSDEP, 70, "pf_key_v2_connection_check: SA for %s exists",
			 conn));
d2779 2
a2780 1
		log_print("pf_key_v2_expire: no destination address extension found");
d2796 2
a2797 1
		log_print("pf_key_v2_expire: no current lifetime extension found");
d2807 5
a2811 4
	LOG_DBG((LOG_SYSDEP, 20, "pf_key_v2_expire: %s dst %s SPI %x sproto %d",
	      life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ? "SOFT"
		 : "HARD", dst_str ? dst_str : "<unknown>",
		 ntohl(ssa->sadb_sa_spi), msg->sadb_msg_satype));
d2828 2
a2829 1
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi, IPSEC_PROTO_IPSEC_ESP);
d2833 2
a2834 1
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi, IPSEC_PROTO_IPSEC_AH);
d2839 2
a2840 1
		sa = ipsec_sa_lookup(dstaddr, ssa->sadb_sa_spi, IPSEC_PROTO_IPCOMP);
d2860 2
a2861 1
	if (!(sa->flags & SA_FLAG_REPLACED) && (sa->flags & SA_FLAG_ONDEMAND) &&
d2917 2
a2918 1
		log_print("pf_key_v2_acquire: no destination address specified");
d2968 2
a2969 1
		log_print("pf_key_v2_acquire: no destination flow extension found");
d2982 2
a2983 1
		log_print("pf_key_v2_acquire: no destination mask extension found");
d3021 3
a3023 2
		if (inet_ntop(AF_INET, &((struct sockaddr_in *) sflow)->sin_addr, ssflow,
			      ADDRESS_MAX) == NULL) {
d3028 3
a3030 2
		if (inet_ntop(AF_INET, &((struct sockaddr_in *) dflow)->sin_addr, sdflow,
			      ADDRESS_MAX) == NULL) {
d3035 3
a3037 2
		if (inet_ntop(AF_INET, &((struct sockaddr_in *) smask)->sin_addr, ssmask,
			      ADDRESS_MAX) == NULL) {
d3041 3
a3043 2
		if (inet_ntop(AF_INET, &((struct sockaddr_in *) dmask)->sin_addr, sdmask,
			      ADDRESS_MAX) == NULL) {
d3047 2
a3048 1
		if (((struct sockaddr_in *) smask)->sin_addr.s_addr == INADDR_BROADCAST) {
d3052 2
a3053 1
		if (((struct sockaddr_in *) dmask)->sin_addr.s_addr == INADDR_BROADCAST) {
d3060 3
a3062 2
		if (inet_ntop(AF_INET6, &((struct sockaddr_in6 *) sflow)->sin6_addr,
			      ssflow, ADDRESS_MAX) == NULL) {
d3067 3
a3069 2
		if (inet_ntop(AF_INET6, &((struct sockaddr_in6 *) dflow)->sin6_addr,
			      sdflow, ADDRESS_MAX) == NULL) {
d3074 3
a3076 2
		if (inet_ntop(AF_INET6, &((struct sockaddr_in6 *) smask)->sin6_addr,
			      ssmask, ADDRESS_MAX) == NULL) {
d3080 3
a3082 2
		if (inet_ntop(AF_INET6, &((struct sockaddr_in6 *) dmask)->sin6_addr,
			      sdmask, ADDRESS_MAX) == NULL) {
d3087 1
a3087 1
		if (IN6_IS_ADDR_FULL(&((struct sockaddr_in6 *) smask)->sin6_addr)) {
d3091 1
a3091 1
		if (IN6_IS_ADDR_FULL(&((struct sockaddr_in6 *) dmask)->sin6_addr)) {
d3098 1
a3098 1
	dstaddr = (struct sockaddr *) (dst + 1);
d3108 2
a3109 1
			log_print("pf_key_v2_acquire: Cannot determine precise destination");
d3116 3
a3118 2
		if (inet_ntop(AF_INET, &((struct sockaddr_in *) dstaddr)->sin_addr,
			      dstbuf, ADDRESS_MAX) == NULL) {
d3122 3
a3124 2
		LOG_DBG((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d", dstbuf,
			 msg->sadb_msg_satype));
d3128 3
a3130 2
		if (inet_ntop(AF_INET6, &((struct sockaddr_in6 *) dstaddr)->sin6_addr,
			      dstbuf, ADDRESS_MAX) == NULL) {
d3134 3
a3136 2
		LOG_DBG((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d", dstbuf,
			 msg->sadb_msg_satype));
d3145 5
a3149 3
			if (inet_ntop(AF_INET, &((struct sockaddr_in *) srcaddr)->sin_addr,
				      srcbuf, ADDRESS_MAX) == NULL) {
				log_print("pf_key_v2_acquire: inet_ntop failed");
d3156 4
a3159 3
				      &((struct sockaddr_in6 *) srcaddr)->sin6_addr, srcbuf,
				      ADDRESS_MAX) == NULL) {
				log_print("pf_key_v2_acquire: inet_ntop failed");
d3166 3
a3168 3
			 * The kernel will pass an all '0' EXT_ADDRESS_SRC if it wasn't
			 * specified for the flow. In that case, do NOT specify the srcaddr
			 * in the Peer- name below
d3180 2
a3181 1
			log_print("pf_key_v2_acquire: source identity not NUL-terminated");
d3202 2
a3203 1
				log_print("pf_key_v2_acquire: badly formatted PREFIX identity");
d3211 4
a3214 3
				log_print("pf_key_v2_acquire: non-host address specified in "
					  "source identity (mask length %d), ignoring request",
					  masklen);
d3222 2
a3223 1
			slen = strlen((char *) (srcident + 1)) + sizeof "ID:Address/";
d3226 2
a3227 1
				log_error("pf_key_v2_acquire: malloc (%d) failed", slen);
d3230 2
a3231 1
			snprintf(srcid, slen, "ID:Address/%s", (char *) (srcident + 1));
d3237 6
a3242 5
					     afamily == AF_INET ? "IPV4_ADDR" : "IPV6_ADDR",
					     1, 0)
				|| conf_set(af, srcid, "Refcount", "1", 1, 0)
				    || conf_set(af, srcid, "Address", (char *) (srcident + 1),
						1, 0)) {
d3259 5
a3263 4
				 * Check whether there is a string following the header;
				 * if no, that there is a user ID (and acquire the login
				 * name). If there is both a string and a user ID, check
				 * that they match.
d3265 4
a3268 2
				if ((slen == 0) && (srcident->sadb_ident_id == 0)) {
					log_print("pf_key_v2_acquire: no user FQDN or ID provided");
d3272 2
a3273 1
					pwd = getpwuid(srcident->sadb_ident_id);
d3275 5
a3279 3
						log_error("pf_key_v2_acquire: could not acquire "
							  "username from provided ID %llu",
						   srcident->sadb_ident_id);
d3283 10
a3292 4
						if (strcmp(pwd->pw_name, (char *) (srcident + 1)) != 0) {
							log_print("pf_key_v2_acquire: provided user name and "
								  "ID do not match (%s != %s)",
								  (char *) (srcident + 1), pwd->pw_name);
d3301 2
a3302 2
			buflen = (slen ? slen : strlen(pwd->pw_name)) + strlen(prefstring)
				+ sizeof "ID:/";
d3305 2
a3306 1
				log_error("pf_key_v2_acquire: malloc (%d) failed", buflen);
d3311 2
a3312 1
				strlcat(srcid, (char *) (srcident + 1), buflen);
d3320 4
a3323 2
				if (conf_set(af, srcid, "ID-type", prefstring, 1, 0)
				|| conf_set(af, srcid, "Refcount", "1", 1, 0)
d3325 2
a3326 2
						srcid + sizeof "ID:/" - 1 + strlen(prefstring),
						1, 0)) {
d3343 1
a3343 1
		 "pf_key_v2_acquire: constructed source ID \"%s\"", srcid));
d3369 2
a3370 1
				log_print("pf_key_v2_acquire: badly formatted PREFIX identity");
d3378 4
a3381 4
				log_print("pf_key_v2_acquire: non-host address specified in "
					  "destination identity (mask length %d), ignoring "
					  "request",
					  masklen);
d3389 2
a3390 1
			slen = strlen((char *) (dstident + 1)) + sizeof "ID:Address/";
d3393 2
a3394 1
				log_error("pf_key_v2_acquire: malloc (%d) failed", slen);
d3397 2
a3398 1
			snprintf(dstid, slen, "ID:Address/%s", (char *) (dstident + 1));
d3404 6
a3409 5
					     afamily == AF_INET ? "IPV4_ADDR" : "IPV6_ADDR",
					     1, 0)
				|| conf_set(af, dstid, "Refcount", "1", 1, 0)
				    || conf_set(af, dstid, "Address", (char *) (dstident + 1),
						1, 0)) {
d3427 5
a3431 4
				 * Check whether there is a string following the header;
				 * if no, that there is a user ID (and acquire the login
				 * name). If there is both a string and a user ID, check
				 * that they match.
d3433 4
a3436 2
				if (slen == 0 && dstident->sadb_ident_id == 0) {
					log_print("pf_key_v2_acquire: no user FQDN or ID provided");
d3442 5
a3446 3
						log_error("pf_key_v2_acquire: could not acquire "
							  "username from provided ID %llu",
						   dstident->sadb_ident_id);
d3450 10
a3459 4
						if (strcmp(pwd->pw_name, (char *) (dstident + 1)) != 0) {
							log_print("pf_key_v2_acquire: provided user name and "
								  "ID do not match (%s != %s)",
								  (char *) (dstident + 1), pwd->pw_name);
d3468 2
a3469 2
			buflen = (slen ? slen : strlen(pwd->pw_name)) + strlen(prefstring)
				+ sizeof "ID:/";
d3472 2
a3473 1
				log_error("pf_key_v2_acquire: malloc (%d) failed", buflen);
d3478 2
a3479 1
				strlcat(dstid, (char *) (dstident + 1), buflen);
d3487 4
a3490 2
				if (conf_set(af, dstid, "ID-type", prefstring, 1, 0)
				|| conf_set(af, dstid, "Refcount", "1", 1, 0)
d3492 2
a3493 2
						dstid + sizeof "ID:/" - 1 + strlen(prefstring),
						1, 0)) {
d3503 3
a3505 3
			LOG_DBG((LOG_SYSDEP, 20,
			"pf_key_v2_acquire: invalid destination ID type %d",
				 dstident->sadb_ident_type));
d3510 2
a3511 2
		     "pf_key_v2_acquire: constructed destination ID \"%s\"",
			 dstid));
d3519 1
a3519 1
			 connection_seq);
d3543 1
a3543 1
	 * - Configuration (if an entry "ISAKMP-configuration-dstaddr(/srcaddr)"
d3619 2
a3620 1
				snprintf(tmbuf, sizeof sport * 3 + 1, "%u", ntohs(sport));
d3632 1
a3632 1
		 tproto, dport);
d3644 1
a3644 1
			  || conf_set(af, dname, "Address", sdflow, 0, 0)) {
d3651 1
a3651 1
			  || conf_set(af, dname, "Netmask", sdmask, 0, 0)) {
d3664 2
a3665 1
				snprintf(tmbuf, sizeof dport * 3 + 1, "%u", ntohs(dport));
d3693 1
a3693 1
		 conf_get_str("General", "Default-phase-2-suites"), 0, 0)) {
d3699 1
a3699 1
			     "QM-ESP-3DES-SHA-PFS-SUITE", 0, 0)) {
d3713 2
a3714 1
		if (srcaddr && conf_set(af, peer, "Local-address", srcbuf, 0, 0)) {
d3718 2
a3719 1
		snprintf(confname, sizeof confname, "ISAKMP-Configuration-%s", peer);
d3735 3
a3737 2
				log_print("pf_key_v2_acquire: zero-length credentials, "
					  "aborting SA acquisition");
d3743 2
a3744 1
				snprintf(num, sizeof num, "%d", ISAKMP_CERTENC_X509_SIG);
d3748 2
a3749 1
				snprintf(num, sizeof num, "%d", ISAKMP_CERTENC_KEYNOTE);
d3753 3
a3755 2
				log_print("pf_key_v2_acquire: unknown credential type %d",
					  cred->sadb_x_cred_type);
d3761 2
a3762 1
				log_print("pf_key_v2_acquire: cert_get (%s) failed", num);
d3773 1
a3773 1
				      cred->sadb_x_cred_len - sizeof *cred);
d3779 2
a3780 1
			    || conf_set(af, peer, "Credentials", certprint, 0, 0)) {
d3805 2
a3806 1
					if (conf_set(af, confname, "Transforms", "3DES-SHA", 0, 0)) {
d3810 5
a3814 3
					if (sauth->sadb_x_cred_len <= sizeof *sauth) {
						log_print("pf_key_v2_acquire: zero-length passphrase, "
						 "aborting SA acquisition");
d3818 2
a3819 1
					authm = malloc(sauth->sadb_x_cred_len - sizeof *sauth + 1);
d3821 2
a3822 1
						log_error("pf_key_v2_acquire: malloc (%lu) failed",
d3824 1
a3824 1
							  (unsigned long) sizeof *sauth + 1);
d3829 2
a3830 1
					       sauth->sadb_x_cred_len - sizeof *sauth + 1);
d3833 2
a3834 1
					if (conf_set(af, peer, "Authentication", authm, 0, 0)) {
d3843 3
a3845 2
					if (conf_set(af, confname, "Transforms", "3DES-SHA-RSA_SIG",
						     0, 0)) {
d3849 5
a3853 3
					if (sauth->sadb_x_cred_len <= sizeof *sauth) {
						log_print("pf_key_v2_acquire: zero-length RSA key, "
						 "aborting SA acquisition");
d3858 4
a3861 4
						     ISAKMP_KEYTYPE_PRIVATE,
						     (u_int8_t *) sauth + 1,
						      sauth->sadb_x_cred_len
							   - sizeof *sauth);
d3863 4
a3866 2
						log_print("pf_key_v2_acquire: failed to convert "
							  "private key to printable format (size %lu)",
d3868 1
a3868 1
							  (unsigned long) sizeof *sauth);
d3873 8
a3880 5
					 * Set the key in the peer. We don't use "Authentication"
					 * to avoid potential conflicts with file-based
					 * configurations that use public key authentication
					 * but still specify an "Authentication" tag (typically
					 * as a remnant of passphrase-based testing).
d3882 2
a3883 1
					if (conf_set(af, peer, "PKAuthentication", authm, 0, 0)) {
d3892 4
a3895 3
					log_print("pf_key_v2_acquire: unknown authentication "
						  "material type %d received from kernel",
						  sauth->sadb_x_cred_type);
d3902 3
a3904 2
				xform = conf_get_str("Default-phase-1-configuration",
						     "Transforms");
d3906 2
a3907 1
				xform ? xform : "3DES-SHA-RSA_SIG", 0, 0)) {
d3913 2
a3914 1
			if (conf_set(af, confname, "Exchange_Type", "ID_PROT", 0, 0)
d3916 1
a3916 1
			 || conf_set(af, confname, "Refcount", "1", 0, 0)) {
d3968 1
a3968 1
		case SADB_EXPIRE:
d3978 1
a3978 1
		((struct sadb_msg *) TAILQ_FIRST(msg)->seg)->sadb_msg_type);
d3991 3
a3993 3
	 * As synchronous read/writes to the socket can have taken place between
	 * the select(2) call of the main loop and this handler, we need to recheck
	 * the readability.
d4045 2
a4046 1
		log_print("pf_key_v2_group_spis: invalid proto %d", proto1->proto);
d4057 2
a4058 1
	memcpy(&sa1.sadb_sa_spi, proto1->spi[incoming], sizeof sa1.sadb_sa_spi);
d4070 2
a4071 1
	memcpy(&sa2.sadb_sa_spi, proto2->spi[incoming], sizeof sa2.sadb_sa_spi);
d4109 1
a4109 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d4126 1
a4126 1
			      PF_KEY_V2_NODE_MALLOCED) == -1)
d4146 2
a4147 1
		log_print("pf_key_v2_group_spis: invalid proto %d", proto2->proto);
d4151 2
a4152 1
	if (pf_key_v2_msg_add(grpspis, (struct sadb_ext *) & protocol, 0) == -1)
@


1.140
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: pf_key_v2.c,v 1.139 2004/04/07 22:45:49 ho Exp $  */
d2263 1
a2263 1
pf_key_v2_enable_sa(struct sa * sa, struct sa * isakmp_sa)
d2465 1
a2465 1
pf_key_v2_disable_sa(struct sa * sa, int incoming)
d2530 1
a2530 1
pf_key_v2_delete_spi(struct sa * sa, struct proto * proto, int incoming)
d2693 1
a2693 1
pf_key_v2_stayalive(struct exchange * exchange, void *vconn, int fail)
d2728 1
a2728 1
pf_key_v2_expire(struct pf_key_v2_msg * pmsg)
d2835 1
a2835 1
pf_key_v2_acquire(struct pf_key_v2_msg * pmsg)
d3833 1
a3833 1
pf_key_v2_notify(struct pf_key_v2_msg * msg)
d3883 2
a3884 2
pf_key_v2_group_spis(struct sa * sa, struct proto * proto1,
		     struct proto * proto2, int incoming)
@


1.139
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*      $OpenBSD: pf_key_v2.c,v 1.138 2004/03/10 09:28:46 ho Exp $  */
/*	$EOM: pf_key_v2.c,v 1.79 2000/12/12 00:33:19 niklas Exp $	*/
d78 4
a81 4
  ((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0xffff)			\
   && (*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0xffff)		\
   && (*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == 0xffff)		\
   && (*(u_int32_t *)(void *)(&(a)->s6_addr[12]) == 0xffff))
d90 1
a90 1
  (((x) + PF_KEY_V2_CHUNK - 1) & ~(PF_KEY_V2_CHUNK - 1))
d96 6
a101 6
  TAILQ_ENTRY (pf_key_v2_node) link;
  void *seg;
  size_t sz;
  int cnt;
  u_int16_t type;
  u_int8_t flags;
d104 1
a104 1
TAILQ_HEAD (pf_key_v2_msg, pf_key_v2_node);
d110 1
a110 1
int connection_seq = 0;
d118 7
a124 7
  TAILQ_ENTRY (pf_key_v2_sa_seq) link;
  u_int8_t *spi;
  size_t sz;
  u_int8_t proto;
  struct sockaddr *dst;
  int dstlen;
  u_int32_t seq;
d127 1
a127 1
TAILQ_HEAD (, pf_key_v2_sa_seq) pf_key_v2_sa_seq_map;
d131 1
a131 1
static u_int8_t *pf_key_v2_convert_id (u_int8_t *, int, size_t *, int *);
d133 9
a141 9
static struct pf_key_v2_msg *pf_key_v2_call (struct pf_key_v2_msg *);
static struct pf_key_v2_node *pf_key_v2_find_ext (struct pf_key_v2_msg *,
						  u_int16_t);
static void pf_key_v2_notify (struct pf_key_v2_msg *);
static struct pf_key_v2_msg *pf_key_v2_read (u_int32_t);
static u_int32_t pf_key_v2_seq (void);
static u_int32_t pf_key_v2_write (struct pf_key_v2_msg *);
static int pf_key_v2_remove_conf (char *);
static int pf_key_v2_conf_refhandle (int, char *);
d144 1
a144 1
static int pf_key_v2_conf_refinc (int, char *);
d148 1
a148 1
static int pf_key_v2_socket;
d152 2
a153 2
pf_key_v2_register_sa_seq (u_int8_t *spi, size_t sz, u_int8_t proto,
			   struct sockaddr *dst, int dstlen, u_int32_t seq)
d155 1
a155 1
  struct pf_key_v2_sa_seq *node = 0;
d157 25
a181 25
  node = malloc (sizeof *node);
  if (!node)
    goto cleanup;
  memset (node, '0', sizeof *node);
  node->spi = malloc (sz);
  if (!node->spi)
    goto cleanup;
  node->dst = malloc (sysdep_sa_len (dst));
  if (!node->dst)
    goto cleanup;
  memcpy (node->dst, dst, sysdep_sa_len (dst));
  node->dstlen = sysdep_sa_len (dst);
  memcpy (node->spi, spi, sz);
  node->sz = sz;
  node->proto = proto;
  node->seq = seq;
  TAILQ_INSERT_TAIL (&pf_key_v2_sa_seq_map, node, link);
  return 1;

 cleanup:
  if (node->dst)
    free (node->dst);
  if (node)
    free (node);
  return 0;
d185 2
a186 2
pf_key_v2_seq_by_sa (u_int8_t *spi, size_t sz, u_int8_t proto,
		     struct sockaddr *dst, int dstlen)
d188 1
a188 1
  struct pf_key_v2_sa_seq *node;
d190 8
a197 8
  for (node = TAILQ_FIRST (&pf_key_v2_sa_seq_map); node;
       node = TAILQ_NEXT (node, link))
    if (node->proto == proto
	&& node->sz == sz && memcmp (node->spi, spi, sz) == 0
	&& node->dstlen == sysdep_sa_len (dst)
	&& memcmp (node->dst, dst, sysdep_sa_len (dst)) == 0)
      return node->seq;
  return 0;
d202 1
a202 1
pf_key_v2_msg_new (struct sadb_msg *msg, int flags)
d204 2
a205 2
  struct pf_key_v2_node *node = 0;
  struct pf_key_v2_msg *ret;
d207 19
a225 19
  node = malloc (sizeof *node);
  if (!node)
    goto cleanup;
  ret = malloc (sizeof *ret);
  if (!ret)
    goto cleanup;
  TAILQ_INIT (ret);
  node->seg = msg;
  node->sz = sizeof *msg;
  node->type = 0;
  node->cnt = 1;
  node->flags = flags;
  TAILQ_INSERT_HEAD (ret, node, link);
  return ret;

 cleanup:
  if (node)
    free (node);
  return 0;
d230 1
a230 1
pf_key_v2_msg_add (struct pf_key_v2_msg *msg, struct sadb_ext *ext, int flags)
d232 1
a232 1
  struct pf_key_v2_node *node;
d234 10
a243 10
  node = malloc (sizeof *node);
  if (!node)
    return -1;
  node->seg = ext;
  node->sz = ext->sadb_ext_len * PF_KEY_V2_CHUNK;
  node->type = ext->sadb_ext_type;
  node->flags = flags;
  TAILQ_FIRST (msg)->cnt++;
  TAILQ_INSERT_TAIL (msg, node, link);
  return 0;
d248 1
a248 1
pf_key_v2_msg_free (struct pf_key_v2_msg *msg)
d250 1
a250 1
  struct pf_key_v2_node *np;
d252 9
a260 10
  np = TAILQ_FIRST (msg);
  while (np)
    {
      TAILQ_REMOVE (msg, np, link);
      if (np->flags & PF_KEY_V2_NODE_MALLOCED)
	free (np->seg);
      free (np);
      np = TAILQ_FIRST (msg);
    }
  free (msg);
d265 1
a265 1
pf_key_v2_seq (void)
d267 1
a267 1
  static u_int32_t seq = 0;
d269 1
a269 1
  return ++seq;
d278 1
a278 1
pf_key_v2_read (u_int32_t seq)
d280 74
a353 59
  ssize_t n;
  u_int8_t *buf = 0;
  struct pf_key_v2_msg *ret = 0;
  struct sadb_msg *msg;
  struct sadb_msg hdr;
  struct sadb_ext *ext;
  struct timeval tv;
  fd_set *fds;

  while (1)
    {
      /*
       * If this is a read of a reply we should actually expect the reply to
       * get lost as PF_KEY is an unreliable service per the specs.
       * Currently we do this by setting a short timeout, and if it is not
       * readable in that time, we fail the read.
       */
      if (seq)
	{
	  fds = calloc (howmany (pf_key_v2_socket + 1, NFDBITS),
			sizeof (fd_mask));
	  if (!fds)
	    {
	      log_error ("pf_key_v2_read: calloc (%lu, %lu) failed",
			 (unsigned long)howmany (pf_key_v2_socket + 1,
						 NFDBITS),
			 (unsigned long)sizeof (fd_mask));
	      goto cleanup;
	    }
	  FD_SET (pf_key_v2_socket, fds);
	  tv.tv_sec = 0;
	  tv.tv_usec = PF_KEY_REPLY_TIMEOUT;
	  n = select (pf_key_v2_socket + 1, fds, 0, 0, &tv);
	  free (fds);
	  if (n == -1)
	    {
	      log_error ("pf_key_v2_read: select (%d, fds, 0, 0, &tv) failed",
			 pf_key_v2_socket + 1);
	      goto cleanup;
	    }
	  if (!n)
	    {
	      log_print ("pf_key_v2_read: no reply from PF_KEY");
	      goto cleanup;
	    }
	}
      n = recv (pf_key_v2_socket, &hdr, sizeof hdr, MSG_PEEK);
      if (n == -1)
	{
	  log_error ("pf_key_v2_read: recv (%d, ...) failed",
		     pf_key_v2_socket);
	  goto cleanup;
	}
      if (n != sizeof hdr)
	{
	  log_error ("pf_key_v2_read: recv (%d, ...) returned short packet "
		     "(%lu bytes)", pf_key_v2_socket, (unsigned long)n);
	  goto cleanup;
	}
d355 43
a397 6
      n = hdr.sadb_msg_len * PF_KEY_V2_CHUNK;
      buf = malloc (n);
      if (!buf)
	{
	  log_error ("pf_key_v2_read: malloc (%lu) failed", (unsigned long)n);
	  goto cleanup;
d400 6
a405 72
      n = read (pf_key_v2_socket, buf, n);
      if (n == -1)
	{
	  log_error ("pf_key_v2_read: read (%d, ...) failed",
		     pf_key_v2_socket);
	  goto cleanup;
	}

      if (n != hdr.sadb_msg_len * PF_KEY_V2_CHUNK)
	{
	  log_print ("pf_key_v2_read: read (%d, ...) returned short packet "
		     "(%lu bytes)", pf_key_v2_socket, (unsigned long)n);
	  goto cleanup;
	}

      LOG_DBG_BUF ((LOG_SYSDEP, 80, "pf_key_v2_read: msg", buf, n));

      /* We drop all messages that is not what we expect.  */
      msg = (struct sadb_msg *)buf;
      if (msg->sadb_msg_version != PF_KEY_V2
	  || (msg->sadb_msg_pid != 0
	      && msg->sadb_msg_pid != (u_int32_t)getpid ()))
	{
	  if (seq)
	    {
	      free (buf);
	      buf = 0;
	      continue;
	    }
	  else
	    {
	      LOG_DBG ((LOG_SYSDEP, 90,
			"pf_key_v2_read:"
			"bad version (%d) or PID (%d, mine is %ld), ignored",
			msg->sadb_msg_version, msg->sadb_msg_pid,
			(long)getpid ()));
	      goto cleanup;
	    }
	}

      /* Parse the message.  */
      ret = pf_key_v2_msg_new (msg, PF_KEY_V2_NODE_MALLOCED);
      if (!ret)
	goto cleanup;
      buf = 0;
      for (ext = (struct sadb_ext *)(msg + 1);
	   (u_int8_t *)ext - (u_int8_t *)msg
	     < msg->sadb_msg_len * PF_KEY_V2_CHUNK;
	   ext = (struct sadb_ext *)((u_int8_t *)ext
				     + ext->sadb_ext_len * PF_KEY_V2_CHUNK))
	pf_key_v2_msg_add (ret, ext, 0);

      /* If the message is not the one we are waiting for, queue it up.  */
      if (seq && (msg->sadb_msg_pid != (u_int32_t)getpid ()
		  || msg->sadb_msg_seq != seq))
	{
	  gettimeofday (&tv, 0);
	  timer_add_event ("pf_key_v2_notify",
			   (void (*) (void *))pf_key_v2_notify, ret, &tv);
	  ret = 0;
	  continue;
	}

      return ret;
    }

 cleanup:
  if (buf)
    free (buf);
  if (ret)
    pf_key_v2_msg_free (ret);
  return 0;
d410 1
a410 1
pf_key_v2_write (struct pf_key_v2_msg *pmsg)
d412 40
a451 44
  struct iovec *iov = 0;
  ssize_t n;
  size_t len;
  int i, cnt = TAILQ_FIRST (pmsg)->cnt;
  char header[80];
  struct sadb_msg *msg = TAILQ_FIRST (pmsg)->seg;
  struct pf_key_v2_node *np = TAILQ_FIRST (pmsg);

  iov = (struct iovec *)malloc (cnt * sizeof *iov);
  if (!iov)
    {
      log_error ("pf_key_v2_write: malloc (%lu) failed",
		 cnt * (unsigned long)sizeof *iov);
      return 0;
    }

  msg->sadb_msg_version = PF_KEY_V2;
  msg->sadb_msg_errno = 0;
  msg->sadb_msg_reserved = 0;
  msg->sadb_msg_pid = getpid ();
  if (!msg->sadb_msg_seq)
    msg->sadb_msg_seq = pf_key_v2_seq ();

  /* Compute the iovec segments as well as the message length.  */
  len = 0;
  for (i = 0; i < cnt; i++)
    {
      iov[i].iov_base = np->seg;
      len += iov[i].iov_len = np->sz;

      /*
       * XXX One can envision setting specific extension fields, like
       * *_reserved ones here.  For now we require them to be set by the
       * caller.
       */

      np = TAILQ_NEXT (np, link);
    }
  msg->sadb_msg_len = len / PF_KEY_V2_CHUNK;

  for (i = 0; i < cnt; i++)
    {
      snprintf (header, sizeof header, "pf_key_v2_write: iov[%d]", i);
      LOG_DBG_BUF ((LOG_SYSDEP, 80, header, (u_int8_t *)iov[i].iov_base,
d453 15
a467 1
    }
d469 4
a472 20
  n = writev (pf_key_v2_socket, iov, cnt);
  if (n == -1)
    {
      log_error ("pf_key_v2_write: writev (%d, %p, %d) failed",
		 pf_key_v2_socket, iov, cnt);
      goto cleanup;
    }
  if ((size_t)n != len)
    {
      log_error ("pf_key_v2_write: writev (%d, ...) returned prematurely "
		 "(%lu)", pf_key_v2_socket, (unsigned long)n);
      goto cleanup;
    }
  free (iov);
  return msg->sadb_msg_seq;

 cleanup:
  if (iov)
    free (iov);
  return 0;
d480 1
a480 1
pf_key_v2_call (struct pf_key_v2_msg *msg)
d482 1
a482 1
  u_int32_t seq;
d484 4
a487 4
  seq = pf_key_v2_write (msg);
  if (!seq)
    return 0;
  return pf_key_v2_read (seq);
d492 1
a492 1
pf_key_v2_find_ext (struct pf_key_v2_msg *msg, u_int16_t type)
d494 1
a494 1
  struct pf_key_v2_node *ext;
d496 5
a500 5
  for (ext = TAILQ_NEXT (TAILQ_FIRST (msg), link); ext;
       ext = TAILQ_NEXT (ext, link))
    if (ext->type == type)
      return ext;
  return 0;
d508 1
a508 1
pf_key_v2_open (void)
d510 34
a543 54
  int fd = -1, err;
  struct sadb_msg msg;
  struct pf_key_v2_msg *regmsg = 0, *ret = 0;

  /* Open the socket we use to speak to IPsec. */
  pf_key_v2_socket = -1;
  fd = monitor_socket (PF_KEY, SOCK_RAW, PF_KEY_V2);
  if (fd == -1)
    {
      log_error ("pf_key_v2_open: "
		 "socket (PF_KEY, SOCK_RAW, PF_KEY_V2) failed");
      goto cleanup;
    }
  pf_key_v2_socket = fd;

  /* Register it to get ESP and AH acquires from the kernel.  */
  msg.sadb_msg_seq = 0;
  msg.sadb_msg_type = SADB_REGISTER;
  msg.sadb_msg_satype = SADB_SATYPE_ESP;
  regmsg = pf_key_v2_msg_new (&msg, 0);
  if (!regmsg)
    goto cleanup;
  ret = pf_key_v2_call (regmsg);
  pf_key_v2_msg_free (regmsg);
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      log_print ("pf_key_v2_open: REGISTER: %s", strerror (err));
      goto cleanup;
    }

  /* XXX Register the accepted transforms.  */

  pf_key_v2_msg_free (ret);
  ret = 0;

  msg.sadb_msg_seq = 0;
  msg.sadb_msg_type = SADB_REGISTER;
  msg.sadb_msg_satype = SADB_SATYPE_AH;
  regmsg = pf_key_v2_msg_new (&msg, 0);
  if (!regmsg)
    goto cleanup;
  ret = pf_key_v2_call (regmsg);
  pf_key_v2_msg_free (regmsg);
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      log_print ("pf_key_v2_open: REGISTER: %s", strerror (err));
      goto cleanup;
    }
d545 16
a560 1
  /* XXX Register the accepted transforms.  */
d562 2
a563 2
  pf_key_v2_msg_free (ret);
  ret = 0;
d566 16
a581 16
  msg.sadb_msg_seq = 0;
  msg.sadb_msg_type = SADB_REGISTER;
  msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
  regmsg = pf_key_v2_msg_new (&msg, 0);
  if (!regmsg)
    goto cleanup;
  ret = pf_key_v2_call (regmsg);
  pf_key_v2_msg_free (regmsg);
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      log_print ("pf_key_v2_open: REGISTER: %s", strerror (err));
      goto cleanup;
    }
d583 1
a583 3
  /* XXX Register the accepted transforms.  */

  pf_key_v2_msg_free (ret);
d587 1
a587 1
  TAILQ_INIT (&pf_key_v2_sa_seq_map);
d590 1
a590 1
  return fd;
d592 8
a599 9
 cleanup:
  if (pf_key_v2_socket != -1)
    {
      close (pf_key_v2_socket);
      pf_key_v2_socket = -1;
    }
  if (ret)
    pf_key_v2_msg_free (ret);
  return -1;
d607 2
a608 2
pf_key_v2_get_spi (size_t *sz, u_int8_t proto, struct sockaddr *src,
		   struct sockaddr *dst, u_int32_t seq)
d610 8
a617 8
  struct sadb_msg msg;
  struct sadb_sa *sa;
  struct sadb_address *addr = 0;
  struct sadb_spirange spirange;
  struct pf_key_v2_msg *getspi = 0, *ret = 0;
  struct pf_key_v2_node *ext;
  u_int8_t *spi = 0;
  int len, err;
d619 1
a619 1
  struct sadb_x_sa2 ssa2;
d622 8
a629 9
  msg.sadb_msg_type = SADB_GETSPI;
  switch (proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      msg.sadb_msg_satype = SADB_SATYPE_ESP;
      break;
    case IPSEC_PROTO_IPSEC_AH:
      msg.sadb_msg_satype = SADB_SATYPE_AH;
      break;
d631 14
a644 14
    case IPSEC_PROTO_IPCOMP:
      msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
      break;
#endif
    default:
      log_print ("pf_key_v2_get_spi: invalid proto %d", proto);
      goto cleanup;
    }

  /* Set the sequence number from the ACQUIRE message. */
  msg.sadb_msg_seq = seq;
  getspi = pf_key_v2_msg_new (&msg, 0);
  if (!getspi)
    goto cleanup;
d647 6
a652 6
  memset (&ssa2, 0, sizeof ssa2);
  ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
  ssa2.sadb_x_sa2_mode = 0;
  if (pf_key_v2_msg_add (getspi, (struct sadb_ext *)&ssa2, 0) == -1)
    goto cleanup;
d655 7
a661 7
  /* Setup the ADDRESS extensions.  */
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (sysdep_sa_len (src));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d663 2
a664 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d666 21
a686 22
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, src, sysdep_sa_len (src));
  switch (((struct sockaddr *)(addr + 1))->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
      break;
    }
  if (pf_key_v2_msg_add (getspi, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (sysdep_sa_len (dst));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d688 2
a689 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d691 58
a748 67
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, dst, sysdep_sa_len (dst));
  switch (((struct sockaddr *)(addr + 1))->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
      break;
    }
  if (pf_key_v2_msg_add (getspi, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  /* Setup the SPIRANGE extension.  */
  spirange.sadb_spirange_exttype = SADB_EXT_SPIRANGE;
  spirange.sadb_spirange_len = sizeof spirange / PF_KEY_V2_CHUNK;
  if (proto == IPSEC_PROTO_IPCOMP)
    {
      spirange.sadb_spirange_min = CPI_RESERVED_MAX + 1;
      spirange.sadb_spirange_max = CPI_PRIVATE_MIN - 1;
    }
  else
    {
      spirange.sadb_spirange_min = IPSEC_SPI_LOW;
      spirange.sadb_spirange_max = 0xffffffff;
    }
  spirange.sadb_spirange_reserved = 0;
  if (pf_key_v2_msg_add (getspi, (struct sadb_ext *)&spirange, 0) == -1)
    goto cleanup;

  ret = pf_key_v2_call (getspi);
  pf_key_v2_msg_free (getspi);
  getspi = 0;
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      log_print ("pf_key_v2_get_spi: GETSPI: %s", strerror (err));
      goto cleanup;
    }

  ext = pf_key_v2_find_ext (ret, SADB_EXT_SA);
  if (!ext)
    {
      log_print ("pf_key_v2_get_spi: no SA extension found");
      goto cleanup;
    }
  sa = ext->seg;

  /* IPCOMP CPIs are only 16 bits long.  */
  *sz = (proto == IPSEC_PROTO_IPCOMP) ? sizeof (u_int16_t)
    : sizeof sa->sadb_sa_spi;
  spi = malloc (*sz);
  if (!spi)
    goto cleanup;
  /* XXX This is ugly.  */
  if (proto == IPSEC_PROTO_IPCOMP)
    {
      u_int32_t tspi = ntohl (sa->sadb_sa_spi);
      *(u_int16_t *)spi = htons ((u_int16_t)tspi);
    }
  else
    memcpy (spi, &sa->sadb_sa_spi, *sz);
d751 19
a769 21
  if (!pf_key_v2_register_sa_seq (spi, *sz, proto, dst, sysdep_sa_len (dst),
				  ((struct sadb_msg *)(TAILQ_FIRST (ret)->seg))
				  ->sadb_msg_seq))
    goto cleanup;
#endif
  pf_key_v2_msg_free (ret);

  LOG_DBG_BUF ((LOG_SYSDEP, 50, "pf_key_v2_get_spi: spi", spi, *sz));

  return spi;

 cleanup:
  if (spi)
    free (spi);
  if (addr)
    free (addr);
  if (getspi)
    pf_key_v2_msg_free (getspi);
  if (ret)
    pf_key_v2_msg_free (ret);
  return 0;
d773 2
a774 2
pf_key_v2_setup_sockaddr (void *res, struct sockaddr *src,
			  struct sockaddr *dst, in_port_t port, int ingress)
d776 8
a783 9
  struct sockaddr_in *ip4_sa;
  struct sockaddr_in6 *ip6_sa;
  u_int8_t *p;

  switch (src->sa_family)
    {
    case AF_INET:
      ip4_sa = (struct sockaddr_in *)res;
      ip4_sa->sin_family = AF_INET;
d785 1
a785 1
      ip4_sa->sin_len = sizeof *ip4_sa;
d787 13
a799 13
      ip4_sa->sin_port = port;
      if (dst)
	p = (u_int8_t *)(ingress
			 ? &((struct sockaddr_in *)src)->sin_addr.s_addr
			 : &((struct sockaddr_in *)dst)->sin_addr.s_addr);
      else
	p = (u_int8_t *)&((struct sockaddr_in *)src)->sin_addr.s_addr;
      ip4_sa->sin_addr.s_addr = *((in_addr_t *)p);
      break;

    case AF_INET6:
      ip6_sa = (struct sockaddr_in6 *)res;
      ip6_sa->sin6_family = AF_INET6;
d801 1
a801 1
      ip6_sa->sin6_len = sizeof *ip6_sa;
d803 15
a817 15
      ip6_sa->sin6_port = port;
      if (dst)
	p = (u_int8_t *)(ingress
			 ? &((struct sockaddr_in6 *)src)->sin6_addr.s6_addr
			 : &((struct sockaddr_in6 *)dst)->sin6_addr.s6_addr);
      else
	p = (u_int8_t *)&((struct sockaddr_in6 *)src)->sin6_addr.s6_addr;
      memcpy (ip6_sa->sin6_addr.s6_addr, p, sizeof (struct in6_addr));
      break;

    default:
      log_print ("pf_key_v2_setup_sockaddr: unknown family %d\n",
		 src->sa_family);
      break;
    }
d826 2
a827 2
pf_key_v2_set_spi (struct sa *sa, struct proto *proto, int incoming,
		   struct sa *isakmp_sa)
d829 11
a839 11
  struct sadb_msg msg;
  struct sadb_sa ssa;
  struct sadb_lifetime *life = 0;
  struct sadb_address *addr = 0;
  struct sadb_key *key = 0;
  struct sadb_ident *sid = 0;
  struct sockaddr *src, *dst;
  struct pf_key_v2_msg *update = 0, *ret = 0;
  struct ipsec_proto *iproto = proto->data;
  size_t len;
  int keylen, hashlen, err;
d841 4
a844 4
  u_int8_t *pp;
  int idtype;
#else /* KAME */
  struct sadb_x_sa2 ssa2;
d847 3
a849 3
  struct ipsec_sa *isa = sa->data;
  struct sadb_x_cred *cred;
  struct sadb_protocol flowtype, tprotocol;
d852 1
a852 1
  char *addr_str;
d855 17
a871 19
  msg.sadb_msg_type = incoming ? SADB_UPDATE : SADB_ADD;
  switch (proto->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      msg.sadb_msg_satype = SADB_SATYPE_ESP;
      keylen = ipsec_esp_enckeylength (proto);
      hashlen = ipsec_esp_authkeylength (proto);

      switch (proto->id)
	{
	case IPSEC_ESP_DES:
	case IPSEC_ESP_DES_IV32:
	case IPSEC_ESP_DES_IV64:
	  ssa.sadb_sa_encrypt = SADB_EALG_DESCBC;
	  break;

	case IPSEC_ESP_3DES:
	  ssa.sadb_sa_encrypt = SADB_EALG_3DESCBC;
	  break;
d874 4
a877 4
	case IPSEC_ESP_AES:
	/* case IPSEC_ESP_AES_128_CTR: */
	  ssa.sadb_sa_encrypt = SADB_X_EALG_AES;
	  break;
d881 3
a883 3
	case IPSEC_ESP_CAST:
	  ssa.sadb_sa_encrypt = SADB_X_EALG_CAST;
	  break;
d887 3
a889 3
	case IPSEC_ESP_BLOWFISH:
	  ssa.sadb_sa_encrypt = SADB_X_EALG_BLF;
	  break;
d892 6
a897 6
	default:
	  LOG_DBG ((LOG_SYSDEP, 50,
		    "pf_key_v2_set_spi: unknown encryption algorithm %d",
		    proto->id));
	  return -1;
	}
d899 2
a900 3
      switch (iproto->auth)
	{
	case IPSEC_AUTH_HMAC_MD5:
d902 1
a902 1
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC96;
d904 1
a904 1
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC;
d906 1
a906 1
	  break;
d908 1
a908 1
	case IPSEC_AUTH_HMAC_SHA:
d910 1
a910 1
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC96;
d912 1
a912 1
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
d914 1
a914 1
	  break;
d917 1
a917 1
        case IPSEC_AUTH_HMAC_RIPEMD:
d919 1
a919 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC96;
d921 1
a921 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
d923 1
a923 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160;
d925 1
a925 1
	  ssa.sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
d927 1
a927 1
	  break;
d931 3
a933 3
	case IPSEC_AUTH_HMAC_SHA2_256:
	  ssa.sadb_sa_auth = SADB_X_AALG_SHA2_256;
	  break;
d937 3
a939 3
	case IPSEC_AUTH_HMAC_SHA2_384:
	  ssa.sadb_sa_auth = SADB_X_AALG_SHA2_384;
	  break;
d943 3
a945 3
	case IPSEC_AUTH_HMAC_SHA2_512:
	  ssa.sadb_sa_auth = SADB_X_AALG_SHA2_512;
	  break;
d948 7
a954 7
	case IPSEC_AUTH_DES_MAC:
	case IPSEC_AUTH_KPDK:
	  /* XXX We should be supporting KPDK */
	  LOG_DBG ((LOG_SYSDEP, 50,
		    "pf_key_v2_set_spi: unknown authentication algorithm %d",
		    iproto->auth));
	  return -1;
d956 4
a959 9
	default:
	  ssa.sadb_sa_auth = SADB_AALG_NONE;
	}
      break;

    case IPSEC_PROTO_IPSEC_AH:
      msg.sadb_msg_satype = SADB_SATYPE_AH;
      hashlen = ipsec_ah_keylength (proto);
      keylen = 0;
d961 8
a968 4
      ssa.sadb_sa_encrypt = SADB_EALG_NONE;
      switch (proto->id)
	{
	case IPSEC_AH_MD5:
d970 1
a970 1
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC96;
d972 1
a972 1
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC;
d974 1
a974 1
	  break;
d976 1
a976 1
	case IPSEC_AH_SHA:
d978 1
a978 1
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC96;
d980 1
a980 1
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
d982 1
a982 1
	  break;
d985 1
a985 1
	case IPSEC_AH_RIPEMD:
d987 1
a987 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC96;
d989 1
a989 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
d991 1
a991 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160;
d993 1
a993 1
	  ssa.sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
d995 1
a995 1
	  break;
d999 3
a1001 3
	case IPSEC_AH_SHA2_256:
	  ssa.sadb_sa_auth = SADB_X_AALG_SHA2_256;
	  break;
d1005 3
a1007 3
	case IPSEC_AH_SHA2_384:
	  ssa.sadb_sa_auth = SADB_X_AALG_SHA2_384;
	  break;
d1011 3
a1013 3
	case IPSEC_AH_SHA2_512:
	  ssa.sadb_sa_auth = SADB_X_AALG_SHA2_512;
	  break;
d1016 7
a1022 7
	default:
	  LOG_DBG ((LOG_SYSDEP, 50,
		    "pf_key_v2_set_spi: unknown authentication algorithm %d",
		    proto->id));
	  goto cleanup;
	}
      break;
d1025 11
a1035 9
    case IPSEC_PROTO_IPCOMP:
      msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
      ssa.sadb_sa_auth = SADB_AALG_NONE;
      keylen = 0;
      hashlen = 0;

      /* Put compression algorithm type in the sadb_sa_encrypt field.  */
      switch (proto->id)
	{
d1037 3
a1039 3
	case IPSEC_IPCOMP_OUI:
	  ssa.sadb_sa_encrypt = SADB_X_CALG_OUI;
	  break;
d1043 3
a1045 3
	case IPSEC_IPCOMP_DEFLATE:
	  ssa.sadb_sa_encrypt = SADB_X_CALG_DEFLATE;
	  break;
d1049 3
a1051 3
	case IPSEC_IPCOMP_LZS:
	  ssa.sadb_sa_encrypt = SADB_X_CALG_LZS;
	  break;
d1055 3
a1057 3
	case IPSEC_IPCOMP_V42BIS:
	  ssa.sadb_sa_encrypt = SADB_X_CALG_V42BIS;
	  break;
d1060 6
d1067 2
a1068 1
	  break;
d1070 4
a1073 11
      break;
#endif /* SADB_X_SATYPE_IPCOMP */

    default:
      log_print ("pf_key_v2_set_spi: invalid proto %d", proto->proto);
      goto cleanup;
    }
  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &dst);
  else
    sa->transport->vtbl->get_dst (sa->transport, &dst);
d1075 3
a1077 5
  msg.sadb_msg_seq
    = (incoming ? pf_key_v2_seq_by_sa (proto->spi[incoming],
				       sizeof ssa.sadb_sa_spi, proto->proto,
				       dst, sysdep_sa_len (dst))
       : 0);
d1079 1
a1079 1
  msg.sadb_msg_seq = sa->seq;
d1081 3
a1083 3
  update = pf_key_v2_msg_new (&msg, 0);
  if (!update)
    goto cleanup;
d1086 3
a1088 3
  memset (&ssa2, 0, sizeof ssa2);
  ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
d1090 4
a1093 4
  if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL)
    ssa2.sadb_x_sa2_mode = IPSEC_MODE_TUNNEL;
  else
    ssa2.sadb_x_sa2_mode = IPSEC_MODE_TRANSPORT;
d1095 1
a1095 1
  ssa2.sadb_x_sa2_mode = 0;
d1097 2
a1098 2
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)&ssa2, 0) == -1)
    goto cleanup;
d1101 12
a1112 11
  /* Setup the rest of the SA extension.  */
  ssa.sadb_sa_exttype = SADB_EXT_SA;
  ssa.sadb_sa_len = sizeof ssa / PF_KEY_V2_CHUNK;
  if (proto->spi_sz[incoming] == 2) /* IPCOMP uses 16bit CPIs.  */
    ssa.sadb_sa_spi = htonl (proto->spi[incoming][0] << 8
			     | proto->spi[incoming][1]);
  else
    memcpy (&ssa.sadb_sa_spi, proto->spi[incoming], sizeof ssa.sadb_sa_spi);
  ssa.sadb_sa_replay
    = conf_get_str ("General", "Shared-SADB") ? 0 : iproto->replay_window;
  ssa.sadb_sa_state = SADB_SASTATE_MATURE;
d1114 2
a1115 2
  ssa.sadb_sa_flags
    = iproto->encap_mode == IPSEC_ENCAP_TUNNEL ? SADB_X_SAFLAGS_TUNNEL : 0;
d1117 1
a1117 1
  ssa.sadb_sa_flags = 0;
d1119 2
a1120 2
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)&ssa, 0) == -1)
    goto cleanup;
d1122 13
a1134 14
  if (sa->seconds || sa->kilobytes)
    {
      /* Setup the hard limits.  */
      life = malloc (sizeof *life);
      if (!life)
	goto cleanup;
      life->sadb_lifetime_len = sizeof *life / PF_KEY_V2_CHUNK;
      life->sadb_lifetime_exttype = SADB_EXT_LIFETIME_HARD;
      life->sadb_lifetime_allocations = 0;
      life->sadb_lifetime_bytes = sa->kilobytes * 1024;
      /*
       * XXX I am not sure which one is best in security respect.  Maybe the
       * RFCs actually mandate what a lifetime really is.
       */
d1136 2
a1137 2
      life->sadb_lifetime_addtime = 0;
      life->sadb_lifetime_usetime = sa->seconds;
d1139 2
a1140 2
      life->sadb_lifetime_addtime = sa->seconds;
      life->sadb_lifetime_usetime = 0;
d1142 20
a1161 20
      if (pf_key_v2_msg_add (update, (struct sadb_ext *)life,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      life = 0;

      /*
       * Setup the soft limits, we use 90 % of the hard ones.
       * XXX A configurable ratio would be better.
       */
      life = malloc (sizeof *life);
      if (!life)
	goto cleanup;
      life->sadb_lifetime_len = sizeof *life / PF_KEY_V2_CHUNK;
      life->sadb_lifetime_exttype = SADB_EXT_LIFETIME_SOFT;
      life->sadb_lifetime_allocations = 0;
      life->sadb_lifetime_bytes = sa->kilobytes * 1024 * 9 / 10;
      /*
       * XXX I am not sure which one is best in security respect.  Maybe the
       * RFCs actually mandate what a lifetime really is.
       */
d1163 2
a1164 2
      life->sadb_lifetime_addtime = 0;
      life->sadb_lifetime_usetime = sa->seconds * 9 / 10;
d1166 2
a1167 2
      life->sadb_lifetime_addtime = sa->seconds * 9 / 10;
      life->sadb_lifetime_usetime = 0;
d1169 18
a1186 19
      if (pf_key_v2_msg_add (update, (struct sadb_ext *)life,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      life = 0;
    }

  /*
   * Setup the ADDRESS extensions.
   */
  if (incoming)
    sa->transport->vtbl->get_dst (sa->transport, &src);
  else
    sa->transport->vtbl->get_src (sa->transport, &src);
  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (src));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d1188 2
a1189 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d1191 14
a1204 41
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, src, sysdep_sa_len (src));
  switch (((struct sockaddr *)(addr + 1))->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
      break;
    }
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (dst));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
#ifndef __OpenBSD__
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, dst, sysdep_sa_len (dst));
  switch (((struct sockaddr *)(addr + 1))->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
      break;
    }
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;
d1206 6
a1211 10
#if 0
  /* XXX I am not sure about what to do here just yet.  */
  if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL)
    {
      len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (dst));
      addr = calloc (1, len);
      if (!addr)
	goto cleanup;
      addr->sadb_address_exttype = SADB_EXT_ADDRESS_PROXY;
      addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d1213 2
a1214 2
      addr->sadb_address_proto = 0;
      addr->sadb_address_prefixlen = 0;
d1216 3
a1218 4
      addr->sadb_address_reserved = 0;
      memcpy (addr + 1, dst, sysdep_sa_len (dst));
      switch (((struct sockaddr *)(addr + 1))->sa_family)
	{
d1220 2
a1221 2
	  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
	  break;
d1223 2
a1224 2
	  ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
	  break;
d1226 5
a1230 4
      if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      addr = 0;
d1232 11
a1242 2
      msg->em_odst = msg->em_dst;
      msg->em_osrc = msg->em_src;
d1244 17
a1260 1
    }
a1261 22

  if (proto->proto != IPSEC_PROTO_IPCOMP)
    {
      /* Setup the KEY extensions.  */
      if (hashlen)
	{
	  len = sizeof *key + PF_KEY_V2_ROUND (hashlen);
	  key = malloc (len);
	  if (!key)
	    goto cleanup;
	  key->sadb_key_exttype = SADB_EXT_KEY_AUTH;
	  key->sadb_key_len = len / PF_KEY_V2_CHUNK;
	  key->sadb_key_bits = hashlen * 8;
	  key->sadb_key_reserved = 0;
	  memcpy (key + 1,
		  iproto->keymat[incoming]
		  + (proto->proto == IPSEC_PROTO_IPSEC_ESP ? keylen : 0),
		  hashlen);
	  if (pf_key_v2_msg_add (update, (struct sadb_ext *)key,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;
	  key = 0;
d1263 1
d1265 35
a1299 15
      if (keylen)
	{
	  len = sizeof *key + PF_KEY_V2_ROUND (keylen);
	  key = malloc (len);
	  if (!key)
	    goto cleanup;
	  key->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
	  key->sadb_key_len = len / PF_KEY_V2_CHUNK;
	  key->sadb_key_bits = keylen * 8;
	  key->sadb_key_reserved = 0;
	  memcpy (key + 1, iproto->keymat[incoming], keylen);
	  if (pf_key_v2_msg_add (update, (struct sadb_ext *)key,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;
	  key = 0;
a1300 2
    }

d1302 66
a1367 50
  /* Setup identity extensions. */
  if (isakmp_sa->id_i)
    {
      pp = pf_key_v2_convert_id (isakmp_sa->id_i, isakmp_sa->id_i_len,
				 &len, &idtype);
      if (!pp)
	goto nosid;

      sid = calloc (PF_KEY_V2_ROUND (len + 1) + sizeof *sid, sizeof (u_int8_t));
      if (!sid)
	{
	  free (pp);
	  goto cleanup;
	}

      sid->sadb_ident_type = idtype;
      sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
			    + PF_KEY_V2_ROUND (len + 1) / PF_KEY_V2_CHUNK;
      if ((isakmp_sa->initiator && !incoming)
	  || (!isakmp_sa->initiator && incoming))
	sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;
      else
	sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;

      memcpy (sid + 1, pp, len);
      free (pp);

      if (pf_key_v2_msg_add (update, (struct sadb_ext *)sid,
			      PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      sid = 0;

 nosid:
      if (sid)
	free (sid);
      sid = 0;
    }

  if (isakmp_sa->id_r)
    {
      pp = pf_key_v2_convert_id (isakmp_sa->id_r, isakmp_sa->id_r_len,
				 &len, &idtype);
      if (!pp)
	goto nodid;

      sid = calloc (PF_KEY_V2_ROUND (len + 1) + sizeof *sid, sizeof (u_int8_t));
      if (!sid)
	{
	  free (pp);
	  goto cleanup;
a1368 23

      sid->sadb_ident_type = idtype;
      sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
			    + PF_KEY_V2_ROUND (len + 1) / PF_KEY_V2_CHUNK;
      if ((isakmp_sa->initiator && !incoming)
	  || (!isakmp_sa->initiator && incoming))
	sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;
      else
	sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;

      memcpy (sid + 1, pp, len);
      free (pp);

      if (pf_key_v2_msg_add (update, (struct sadb_ext *)sid,
			      PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      sid = 0;

 nodid:
      if (sid)
	free (sid);
      sid = 0;
    }
d1372 11
a1382 13
  /*
   * Send received credentials to the kernel. We don't bother with
   * our credentials, since the process either knows them (if it specified
   * them with setsockopt()), or has no business looking at them (e.g.,
   * system wide certs).
   */
  if (isakmp_sa->recv_cert)
    {
      switch (isakmp_sa->recv_certtype)
	{
	case ISAKMP_CERTENC_NONE:
	  /* Nothing to be done here. */
	  break;
d1385 18
a1402 18
	case ISAKMP_CERTENC_KEYNOTE:
	  len = strlen (isakmp_sa->recv_cert);
	  cred = calloc (PF_KEY_V2_ROUND (len) + sizeof *cred,
			 sizeof (u_int8_t));
	  if (!cred)
	    goto cleanup;

	  cred->sadb_x_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
	    PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
	  cred->sadb_x_cred_exttype = SADB_X_EXT_REMOTE_CREDENTIALS;
	  cred->sadb_x_cred_type = SADB_X_CREDTYPE_KEYNOTE;
	  memcpy (cred + 1, isakmp_sa->recv_cert, len);

	  if (pf_key_v2_msg_add (update, (struct sadb_ext *)cred,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;
	  break;
#endif /* USE_KEYNOTE */
d1405 36
a1440 35
	case ISAKMP_CERTENC_X509_SIG:
	  {
	    u_int8_t *data;
	    u_int32_t datalen;
	    struct cert_handler *handler;

	    /* We do it this way to avoid weird includes. */
	    handler = cert_get (ISAKMP_CERTENC_X509_SIG);
	    if (!handler)
	      break;
	    handler->cert_serialize (isakmp_sa->recv_cert, &data, &datalen);
	    if (!data)
	      break;

	    len = datalen;
	    cred = calloc (PF_KEY_V2_ROUND (len) + sizeof *cred,
			   sizeof (u_int8_t));
	    if (!cred)
	      {
		free (data);
		goto cleanup;
	      }

	    cred->sadb_x_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
	      PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
	    cred->sadb_x_cred_exttype = SADB_X_EXT_REMOTE_CREDENTIALS;
	    cred->sadb_x_cred_type = SADB_X_CREDTYPE_X509;
	    memcpy (cred + 1, data, len);
	    free (data);

	    if (pf_key_v2_msg_add (update, (struct sadb_ext *)cred,
				   PF_KEY_V2_NODE_MALLOCED) == -1)
	      goto cleanup;
	  }
	  break;
d1442 1
a1443 1
    }
d1447 46
a1492 24
  /*
   * Tell the kernel what the peer used to authenticate, unless it was a
   * passphrase.
   */
  if (isakmp_sa->recv_key)
    {
      u_int8_t *data;

      /*
       * If it's a private key, we shouldn't pass it to the kernel for
       * processes to see; successful authentication of Phase 1 implies
       * that the process already knew the passphrase. On the other hand,
       * we don't want to reveal to processes any system-wide passphrases
       * used for authentication with remote systems. Same reason we don't
       * send up the key (private or passphrase) we used to authenticate
       * with the peer.
       */
      if (isakmp_sa->recv_keytype == ISAKMP_KEY_PASSPHRASE)
	goto doneauth;

      key_serialize (isakmp_sa->recv_keytype, ISAKMP_KEYTYPE_PUBLIC,
		     isakmp_sa->recv_key, &data, &len);
      if (!data)
	goto cleanup;
d1494 3
a1496 5
      cred = calloc (PF_KEY_V2_ROUND (len) + sizeof *cred, sizeof (u_int8_t));
      if (!cred)
	{
	  free (data);
	  goto cleanup;
d1498 18
d1517 2
a1518 5
      cred->sadb_x_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
	PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
      cred->sadb_x_cred_exttype = SADB_X_EXT_REMOTE_AUTH;
      memcpy (cred + 1, data, len);
      free (data);
d1520 13
a1532 5
      switch (isakmp_sa->recv_keytype)
	{
	case ISAKMP_KEY_RSA:
	  cred->sadb_x_cred_type = SADB_X_AUTHTYPE_RSA;
	  break;
d1534 13
a1546 6
	default:
	  log_print ("pf_key_v2_set_spi: unknown received key type %d",
		     isakmp_sa->recv_keytype);
	  free (cred);
	  goto cleanup;
	}
d1548 12
a1559 6
      if (pf_key_v2_msg_add (update, (struct sadb_ext *)cred,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
    }
 doneauth:
#endif /* SADB_X_AUTHTYPE_NONE */
d1561 13
a1573 73
#ifdef SADB_X_EXT_FLOW_TYPE
  /* Setup the flow type extension.  */
  bzero (&flowtype, sizeof flowtype);
  flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
  flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK;
  flowtype.sadb_protocol_direction
    = incoming ? IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;

  if (pf_key_v2_msg_add (update, (struct sadb_ext *)&flowtype, 0) == -1)
    goto cleanup;

  bzero (&tprotocol, sizeof tprotocol);
  tprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
  tprotocol.sadb_protocol_len = sizeof tprotocol / PF_KEY_V2_CHUNK;
  tprotocol.sadb_protocol_proto = isa->tproto;

  if (pf_key_v2_msg_add (update, (struct sadb_ext *)&tprotocol, 0) == -1)
    goto cleanup;

  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (isa->src_net));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype =
      incoming ? SADB_X_EXT_DST_FLOW : SADB_X_EXT_SRC_FLOW;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, isa->src_net, 0, isa->sport, 0);
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype =
      incoming ? SADB_X_EXT_DST_MASK : SADB_X_EXT_SRC_MASK;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, isa->src_mask, 0,
      isa->sport ? 0xffff : 0, 0);
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype =
      incoming ? SADB_X_EXT_SRC_FLOW : SADB_X_EXT_DST_FLOW;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, isa->dst_net, 0, isa->dport, 0);
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype =
      incoming ? SADB_X_EXT_SRC_MASK : SADB_X_EXT_DST_MASK;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, isa->dst_mask, 0,
      isa->dport ? 0xffff : 0, 0);
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;
d1576 1
a1576 1
  /* XXX Here can sensitivity extensions be setup.  */
d1579 2
a1580 2
  if (sockaddr2text (dst, &addr_str, 0))
    addr_str = 0;
d1582 1
a1582 1
  LOG_DBG ((LOG_SYSDEP, 10, "pf_key_v2_set_spi: satype %d dst %s SPI 0x%x",
d1584 38
a1621 1
	    ntohl (ssa.sadb_sa_spi)));
d1623 14
a1636 53
  if (addr_str)
    free (addr_str);
#endif /* USE_DEBUG */

  /*
   * Although PF_KEY knows about expirations, it is unreliable per the specs
   * thus we need to do them inside isakmpd as well.
   */
  if (sa->seconds)
    if (sa_setup_expirations (sa))
      goto cleanup;

  ret = pf_key_v2_call (update);
  pf_key_v2_msg_free (update);
  update = 0;
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  pf_key_v2_msg_free (ret);
  ret = 0;

  /*
   * If we are doing an addition into an SADB shared with our peer, errors
   * here are to be expected as the peer will already have created the SA,
   * and can thus be ignored.
   */
  if (err && !(msg.sadb_msg_type == SADB_ADD
	       && conf_get_str ("General", "Shared-SADB")))
    {
      log_print ("pf_key_v2_set_spi: %s: %s",
		 msg.sadb_msg_type == SADB_ADD ? "ADD" : "UPDATE",
		 strerror (err));
      goto cleanup;
    }

  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_set_spi: done"));

  return 0;

 cleanup:
  if (sid)
    free (sid);
  if (addr)
    free (addr);
  if (life)
    free (life);
  if (key)
    free (key);
  if (update)
    pf_key_v2_msg_free (update);
  if (ret)
    pf_key_v2_msg_free (ret);
  return -1;
d1640 1
a1640 1
pf_key_v2_mask_to_bits (u_int32_t mask)
d1642 3
a1644 2
  u_int32_t hmask = ntohl (mask);
  return (33 - ffs (~hmask + 1)) % 33;
d1648 1
a1648 1
pf_key_v2_mask6_to_bits (u_int8_t *mask)
d1650 4
a1653 3
  int n;
  bit_ffc (mask, 128, &n);
  return n == -1 ? 128 : n;
d1662 8
a1669 8
pf_key_v2_flow (struct sockaddr *laddr, struct sockaddr *lmask,
		struct sockaddr *raddr,	struct sockaddr *rmask,
		u_int8_t tproto, u_int16_t sport, u_int16_t dport,
		u_int8_t *spi, u_int8_t proto, struct sockaddr *dst,
		struct sockaddr *src, int delete, int ingress,
		u_int8_t srcid_type, u_int8_t *srcid, int srcid_len,
		u_int8_t dstid_type, u_int8_t *dstid, int dstid_len,
		struct ipsec_proto *iproto)
d1672 1
a1672 1
  char *laddr_str, *lmask_str, *raddr_str, *rmask_str;
d1676 1
a1676 1
  struct sadb_msg msg;
d1678 2
a1679 2
  struct sadb_protocol flowtype;
  struct sadb_ident *sid = 0;
d1681 1
a1681 1
  struct sadb_sa ssa;
d1683 5
a1687 5
  struct sadb_address *addr = 0;
  struct sadb_protocol tprotocol;
  struct pf_key_v2_msg *flow = 0, *ret = 0;
  size_t len;
  int err;
d1690 2
a1691 2
  if (ingress)
    return 0;
d1694 19
a1712 20
  msg.sadb_msg_type = delete ? SADB_X_DELFLOW : SADB_X_ADDFLOW;
  switch (proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      msg.sadb_msg_satype = SADB_SATYPE_ESP;
      break;
    case IPSEC_PROTO_IPSEC_AH:
      msg.sadb_msg_satype = SADB_SATYPE_AH;
      break;
    case IPSEC_PROTO_IPCOMP:
      msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
      break;
    default:
      log_print ("pf_key_v2_flow: invalid proto %d", proto);
      goto cleanup;
    }
  msg.sadb_msg_seq = 0;
  flow = pf_key_v2_msg_new (&msg, 0);
  if (!flow)
    goto cleanup;
d1715 63
a1777 68
  if (!delete)
    {
      /* Setup the source ID, if provided. */
      if (srcid)
        {
	  sid = calloc (PF_KEY_V2_ROUND (srcid_len + 1) + sizeof *sid,
			sizeof (u_int8_t));
	  if (!sid)
	    goto cleanup;

	  sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
	    + PF_KEY_V2_ROUND (srcid_len + 1) / PF_KEY_V2_CHUNK;
	  sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;
	  sid->sadb_ident_type = srcid_type;

	  memcpy (sid + 1, srcid, srcid_len);

	  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)sid,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;

	  sid = 0;
	}

      /* Setup the destination ID, if provided. */
      if (dstid)
        {
	  sid = calloc (PF_KEY_V2_ROUND (dstid_len + 1) + sizeof *sid,
			sizeof (u_int8_t));
	  if (!sid)
	    goto cleanup;

	  sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
	    + PF_KEY_V2_ROUND (dstid_len + 1) / PF_KEY_V2_CHUNK;
	  sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;
	  sid->sadb_ident_type = dstid_type;

	  memcpy (sid + 1, dstid, dstid_len);

	  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)sid,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;

	  sid = 0;
	}
    }

  /* Setup the flow type extension.  */
  bzero (&flowtype, sizeof flowtype);
  flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
  flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK;
  flowtype.sadb_protocol_direction
    = ingress ? IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;
  flowtype.sadb_protocol_proto
    = ingress ? SADB_X_FLOW_TYPE_USE : SADB_X_FLOW_TYPE_REQUIRE;

  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&flowtype, 0) == -1)
    goto cleanup;
#else /* SADB_X_EXT_FLOW_TYPE */
  /* Setup the SA extension.  */
  ssa.sadb_sa_exttype = SADB_EXT_SA;
  ssa.sadb_sa_len = sizeof ssa / PF_KEY_V2_CHUNK;
  memcpy (&ssa.sadb_sa_spi, spi, sizeof ssa.sadb_sa_spi);
  ssa.sadb_sa_replay = 0;
  ssa.sadb_sa_state = 0;
  ssa.sadb_sa_auth = 0;
  ssa.sadb_sa_encrypt = 0;
  ssa.sadb_sa_flags = 0;
d1779 2
a1780 2
  if (ingress)
    ssa.sadb_sa_flags |= SADB_X_SAFLAGS_INGRESS_FLOW;
d1783 2
a1784 2
  if (!delete && !ingress)
    ssa.sadb_sa_flags |= SADB_X_SAFLAGS_REPLACEFLOW;
d1787 3
a1789 3
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&ssa, 0) == -1)
    goto cleanup;
#endif /* SADB_X_EXT_FLOW_TYPE */
d1791 4
a1794 4
  /*
   * Setup the ADDRESS extensions.
   */
  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (src));
d1796 1
a1796 1
  if (!delete || ingress)
d1798 9
a1806 9
  if (!delete)
#endif /* SADB_X_EXT_FLOW_TYPE */
    {
      addr = calloc (1, len);
      if (!addr)
	goto cleanup;
      addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
      addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
      addr->sadb_address_reserved = 0;
d1808 1
a1808 1
      pf_key_v2_setup_sockaddr (addr + 1, src, dst, 0, ingress);
d1810 1
a1810 1
      pf_key_v2_setup_sockaddr (addr + 1, dst, 0, 0, 0);
d1812 59
a1870 60
      if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      addr = 0;
    }

  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (laddr));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_X_EXT_SRC_FLOW;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, laddr, 0, sport, 0);
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_X_EXT_SRC_MASK;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, lmask, 0, sport ? 0xffff : 0, 0);
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_X_EXT_DST_FLOW;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, raddr, 0, dport, 0);
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_X_EXT_DST_MASK;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
  addr->sadb_address_reserved = 0;
  pf_key_v2_setup_sockaddr (addr + 1, rmask, 0, dport ? 0xffff : 0, 0);
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  /* Setup the protocol extension.  */
  bzero (&tprotocol, sizeof tprotocol);
  tprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
  tprotocol.sadb_protocol_len = sizeof tprotocol / PF_KEY_V2_CHUNK;
  tprotocol.sadb_protocol_proto = tproto;
d1872 2
a1873 2
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&tprotocol, 0) == -1)
    goto cleanup;
d1876 42
a1917 42
  if (sockaddr2text (laddr, &laddr_str, 0))
    laddr_str = 0;
  if (sockaddr2text (lmask, &lmask_str, 0))
    lmask_str = 0;
  if (sockaddr2text (raddr, &raddr_str, 0))
    raddr_str = 0;
  if (sockaddr2text (rmask, &rmask_str, 0))
    rmask_str = 0;

  LOG_DBG ((LOG_SYSDEP, 50,
	    "pf_key_v2_flow: src %s %s dst %s %s proto %u sport %u dport %u",
	    laddr_str ? laddr_str : "<??\?>", lmask_str ? lmask_str : "<??\?>",
	    raddr_str ? raddr_str : "<??\?>", rmask_str ? rmask_str : "<??\?>",
	    tproto, ntohs (sport), ntohs (dport)));

  if (laddr_str)
    free (laddr_str);
  if (lmask_str)
    free (lmask_str);
  if (raddr_str)
    free (raddr_str);
  if (rmask_str)
    free (rmask_str);
#endif /* USE_DEBUG */

  ret = pf_key_v2_call (flow);
  pf_key_v2_msg_free (flow);
  flow = 0;
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      if (err == ESRCH) /* These are common and usually harmless.  */
	LOG_DBG ((LOG_SYSDEP, 10, "pf_key_v2_flow: %sFLOW: %s",
		  delete ? "DEL" : "ADD", strerror (err)));
      else
	log_print ("pf_key_v2_flow: %sFLOW: %s", delete ? "DEL" : "ADD",
		   strerror (err));
      goto cleanup;
    }
  pf_key_v2_msg_free (ret);
d1919 2
a1920 2
  LOG_DBG ((LOG_MISC, 50, "pf_key_v2_flow: %sFLOW: done",
	    delete ? "DEL" : "ADD"));
d1922 1
a1922 1
  return 0;
d1924 1
a1924 1
 cleanup:
d1926 10
a1935 10
  if (sid)
    free (sid);
#endif /* SADB_X_EXT_FLOW_TYPE */
  if (addr)
    free (addr);
  if (flow)
    pf_key_v2_msg_free (flow);
  if (ret)
    pf_key_v2_msg_free (ret);
  return -1;
d1938 36
a1973 36
  struct sadb_msg msg;
  struct sadb_x_policy *policy = 0;
  struct sadb_x_ipsecrequest *ipsecrequest;
  struct sadb_x_sa2 ssa2;
  struct sadb_address *addr = 0;
  struct sockaddr *saddr;
  struct pf_key_v2_msg *flow = 0, *ret = 0;
  u_int8_t *policy_buf;
  size_t len;
  int err;
  struct sockaddr_in *ip4_sa;
  struct sockaddr_in6 *ip6_sa;

  msg.sadb_msg_type = delete ? SADB_X_SPDDELETE : SADB_X_SPDADD;
  msg.sadb_msg_satype = SADB_SATYPE_UNSPEC;
  msg.sadb_msg_seq = 0;
  flow = pf_key_v2_msg_new (&msg, 0);
  if (!flow)
    goto cleanup;

  memset (&ssa2, 0, sizeof ssa2);
  ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
  ssa2.sadb_x_sa2_mode = 0;
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&ssa2, 0) == -1)
    goto cleanup;

  /*
   * Setup the ADDRESS extensions.
   */
  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (src));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d1975 1
a1975 1
  addr->sadb_address_proto = tproto;
d1977 1
a1977 1
  addr->sadb_address_proto = IPSEC_ULPROTO_ANY;
d1979 1
a1979 1
  addr->sadb_address_reserved = 0;
d1981 1
a1981 1
  pf_key_v2_setup_sockaddr (addr + 1, laddr, 0, sport, 0);
d1983 1
a1983 1
  pf_key_v2_setup_sockaddr (addr + 1, laddr, 0, IPSEC_PORT_ANY, 0);
d1985 23
a2007 24
  switch (laddr->sa_family)
    {
    case AF_INET:
      ip4_sa = (struct sockaddr_in *)lmask;
      addr->sadb_address_prefixlen
	= pf_key_v2_mask_to_bits (ip4_sa->sin_addr.s_addr);
      break;
    case AF_INET6:
      ip6_sa = (struct sockaddr_in6 *)lmask;
      addr->sadb_address_prefixlen
	= pf_key_v2_mask6_to_bits (&ip6_sa->sin6_addr.s6_addr[0]);
      break;
    }
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (raddr));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d2009 1
a2009 1
  addr->sadb_address_proto = tproto;
d2011 1
a2011 1
  addr->sadb_address_proto = IPSEC_ULPROTO_ANY;
d2013 1
a2013 1
  addr->sadb_address_reserved = 0;
d2015 1
a2015 1
  pf_key_v2_setup_sockaddr (addr + 1, raddr, 0, dport, 0);
d2017 1
a2017 1
  pf_key_v2_setup_sockaddr (addr + 1, raddr, 0, IPSEC_PORT_ANY, 0);
d2019 49
a2067 53
  switch (raddr->sa_family)
    {
    case AF_INET:
      ip4_sa = (struct sockaddr_in *)rmask;
      addr->sadb_address_prefixlen
	= pf_key_v2_mask_to_bits (ip4_sa->sin_addr.s_addr);
      break;
    case AF_INET6:
      ip6_sa = (struct sockaddr_in6 *)rmask;
      addr->sadb_address_prefixlen
	= pf_key_v2_mask6_to_bits (&ip6_sa->sin6_addr.s6_addr[0]);
      break;
    }
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  /* Setup the POLICY extension.  */
  len = sizeof *policy + sizeof *ipsecrequest +
    2 * PF_KEY_V2_ROUND (sysdep_sa_len (src));
  policy_buf = (u_int8_t *)calloc (1, len);
  if (!policy_buf)
    {
      log_error ("pf_key_v2_flow: calloc %lu failed", (unsigned long)len);
      goto cleanup;
    }

  policy = (struct sadb_x_policy *)policy_buf;
  policy->sadb_x_policy_exttype = SADB_X_EXT_POLICY;
  policy->sadb_x_policy_len = len / PF_KEY_V2_CHUNK;
  policy->sadb_x_policy_type = IPSEC_POLICY_IPSEC;
  if (ingress)
	policy->sadb_x_policy_dir = IPSEC_DIR_INBOUND;
  else
	policy->sadb_x_policy_dir = IPSEC_DIR_OUTBOUND;
  policy->sadb_x_policy_reserved = 0;

  /* Setup the IPSECREQUEST extension part.  */
  ipsecrequest = (struct sadb_x_ipsecrequest *)(policy + 1);
  ipsecrequest->sadb_x_ipsecrequest_len = len - sizeof *policy;
  switch (proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      ipsecrequest->sadb_x_ipsecrequest_proto = IPPROTO_ESP;
      break;
    case IPSEC_PROTO_IPSEC_AH:
      ipsecrequest->sadb_x_ipsecrequest_proto = IPPROTO_AH;
      break;
    default:
      log_print ("pf_key_v2_flow: invalid proto %d", proto);
      goto cleanup;
  }
d2069 25
a2093 26
  if (iproto->encap_mode == IPSEC_ENCAP_TUNNEL)
    ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TUNNEL;
  else
    ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TRANSPORT;
#else
  ipsecrequest->sadb_x_ipsecrequest_mode = IPSEC_MODE_TUNNEL;	/* XXX */
#endif
  ipsecrequest->sadb_x_ipsecrequest_level
    = ingress ? IPSEC_LEVEL_USE : IPSEC_LEVEL_REQUIRE;
  ipsecrequest->sadb_x_ipsecrequest_reqid = 0;	/* XXX */

  /* Add source and destination addresses. */
  saddr = (struct sockaddr *)(ipsecrequest + 1);
  pf_key_v2_setup_sockaddr (saddr, src, 0, 0, 0);
  switch (src->sa_family)
    {
    case AF_INET:
      saddr = (struct sockaddr *)((struct sockaddr_in *)saddr + 1);
      break;
    case AF_INET6:
      saddr = (struct sockaddr *)((struct sockaddr_in6 *)saddr + 1);
      break;
    }
  pf_key_v2_setup_sockaddr (saddr, dst, 0, 0, 0);
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)policy, 0) == -1)
    goto cleanup;
d2096 54
a2149 57
  if (sockaddr2text (laddr, &laddr_str, 0))
    laddr_str = 0;
  if (sockaddr2text (lmask, &lmask_str, 0))
    lmask_str = 0;
  if (sockaddr2text (raddr, &raddr_str, 0))
    raddr_str = 0;
  if (sockaddr2text (rmask, &rmask_str, 0))
    rmask_str = 0;

  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_flow: src %s %s dst %s %s",
	    laddr_str ? laddr_str : "<??\?>", lmask_str ? lmask_str : "<??\?>",
	    raddr_str ? raddr_str : "<??\?>",
	    rmask_str ? rmask_str : "<??\?>"));

  if (laddr_str)
    free (laddr_str);
  if (lmask_str)
    free (lmask_str);
  if (raddr_str)
    free (raddr_str);
  if (rmask_str)
    free (rmask_str);
#endif

  ret = pf_key_v2_call (flow);
  pf_key_v2_msg_free (flow);
  flow = 0;
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (!delete && err == EEXIST)
    {
      LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_flow: SPDADD returns EEXIST"));
    }
  else if (err)
    {
      log_print ("pf_key_v2_flow: SPD%s: %s", delete ? "DELETE" : "ADD",
		 strerror (err));
      goto cleanup;
    }
  pf_key_v2_msg_free (ret);

  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_flow: SPD%s: done",
	    delete ? "DELETE" : "ADD"));

  return 0;

 cleanup:
  if (addr)
    free (addr);
  if (policy)
    free (policy);
  if (flow)
    pf_key_v2_msg_free (flow);
  if (ret)
    pf_key_v2_msg_free (ret);
  return -1;
d2152 2
a2153 2
  log_print ("pf_key_v2_flow: not supported in pure PF_KEYv2");
  return -1;
d2159 1
a2159 1
pf_key_v2_convert_id (u_int8_t *id, int idlen, size_t *reslen, int *idtype)
d2161 2
a2162 2
  u_int8_t *addr, *res = 0;
  char addrbuf[ADDRESS_MAX + 5];
d2164 92
a2255 20
  switch (id[0])
    {
    case IPSEC_ID_FQDN:
      res = calloc (idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ,
		    sizeof (u_int8_t));
      if (!res)
	return 0;

      *reslen = idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
      memcpy (res, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, *reslen);
      *idtype = SADB_IDENTTYPE_FQDN;
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: FQDN %.*s",
		   (int)*reslen, res));
      return res;

    case IPSEC_ID_USER_FQDN:
      res = calloc (idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ,
		    sizeof (u_int8_t));
      if (!res)
	return 0;
a2256 15
      *reslen = idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
      memcpy (res, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, *reslen);
      *idtype = SADB_IDENTTYPE_USERFQDN;
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: UFQDN %.*s",
		   (int)*reslen, res));
      return res;

    case IPSEC_ID_IPV4_ADDR: /* XXX CONNECTION ? */
      if (inet_ntop (AF_INET, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		     addrbuf, ADDRESS_MAX) == NULL)
	return 0;
      *reslen = strlen (addrbuf) + 3;
      strlcat (addrbuf, "/32", ADDRESS_MAX + 5);
      res = (u_int8_t *)strdup (addrbuf);
      if (!res)
a2257 58
      *idtype = SADB_IDENTTYPE_PREFIX;
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv4 address %s", res));
      return res;

    case IPSEC_ID_IPV6_ADDR: /* XXX CONNECTION ? */
      if (inet_ntop (AF_INET6, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		     addrbuf, ADDRESS_MAX) == NULL)
	return 0;
      *reslen = strlen (addrbuf) + 4;
      strlcat (addrbuf, "/128", ADDRESS_MAX + 5);
      res = (u_int8_t *)strdup (addrbuf);
      if (!res)
	return 0;
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv6 address %s", res));
      *idtype = SADB_IDENTTYPE_PREFIX;
      return res;

    case IPSEC_ID_IPV4_ADDR_SUBNET: /* XXX PREFIX */
      addr = id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
      if (inet_ntop (AF_INET, addr, addrbuf, ADDRESS_MAX) == NULL)
	return 0;
      snprintf (addrbuf + strlen (addrbuf), ADDRESS_MAX - strlen (addrbuf),
		"/%d", pf_key_v2_mask_to_bits ((u_int32_t)
					       *(addr +
						 sizeof (struct in_addr))));
      *reslen = strlen (addrbuf);
      res = (u_int8_t *)strdup (addrbuf);
      if (!res)
	return 0;
      *idtype = SADB_IDENTTYPE_PREFIX;
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv4 subnet %s", res));
      return res;

    case IPSEC_ID_IPV6_ADDR_SUBNET: /* XXX PREFIX */
      addr = id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ;
      if (inet_ntop (AF_INET6, addr, addrbuf, ADDRESS_MAX) == NULL)
	return 0;
      snprintf (addrbuf + strlen (addrbuf), ADDRESS_MAX - strlen (addrbuf),
		"/%d", pf_key_v2_mask6_to_bits (addr +
						sizeof (struct in6_addr)));
      *reslen = strlen (addrbuf);
      res = (u_int8_t *)strdup (addrbuf);
      if (!res)
	return 0;
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: IPv6 subnet %s", res));
      *idtype = SADB_IDENTTYPE_PREFIX;
      return res;

    case IPSEC_ID_IPV4_RANGE:
    case IPSEC_ID_IPV6_RANGE:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
    case IPSEC_ID_KEY_ID:
      /* XXX Not implemented yet.  */
      return 0;
    }

  return 0;
d2263 1
a2263 1
pf_key_v2_enable_sa (struct sa *sa, struct sa *isakmp_sa)
d2265 7
a2271 7
  struct ipsec_sa *isa = sa->data;
  struct sockaddr *dst, *src;
  int error;
  struct proto *proto = TAILQ_FIRST (&sa->protos);
  int sidtype = 0, didtype = 0;
  size_t sidlen = 0, didlen = 0;
  u_int8_t *sid = 0, *did = 0;
d2273 3
a2275 3
  struct sockaddr_storage hostmask_storage;
  struct sockaddr *hostmask = (struct sockaddr *)&hostmask_storage;
#endif /* SADB_X_EXT_FLOW_TYPE */
d2277 2
a2278 2
  sa->transport->vtbl->get_dst (sa->transport, &dst);
  sa->transport->vtbl->get_src (sa->transport, &src);
d2281 25
a2305 28
  if (isakmp_sa->id_i)
    {
      if (isakmp_sa->initiator)
	sid = pf_key_v2_convert_id (isakmp_sa->id_i, isakmp_sa->id_i_len,
				    &sidlen, &sidtype);
      else
	did = pf_key_v2_convert_id (isakmp_sa->id_i, isakmp_sa->id_i_len,
				    &didlen, &didtype);
    }

  if (isakmp_sa->id_r)
    {
      if (isakmp_sa->initiator)
	did = pf_key_v2_convert_id (isakmp_sa->id_r, isakmp_sa->id_r_len,
				    &didlen, &didtype);
      else
	sid = pf_key_v2_convert_id (isakmp_sa->id_r, isakmp_sa->id_r_len,
				    &sidlen, &sidtype);
    }
#endif /* SADB_X_EXT_FLOW_TYPE */

  error = pf_key_v2_flow (isa->src_net, isa->src_mask, isa->dst_net,
			  isa->dst_mask, isa->tproto, isa->sport, isa->dport,
			  proto->spi[0], proto->proto, dst, src, 0, 0,
			  sidtype, sid, sidlen, didtype, did, didlen,
			  proto->data);
  if (error)
    goto cleanup;
d2308 4
a2311 5
  /* Set hostmask to '-1'. */
  switch (dst->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)hostmask)->sin_family = AF_INET;
d2313 1
a2313 1
      ((struct sockaddr_in *)hostmask)->sin_len = sizeof (struct in_addr);
d2315 5
a2319 5
      memset (&((struct sockaddr_in *)hostmask)->sin_addr.s_addr, 0xff,
	      sizeof (struct in_addr));
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)hostmask)->sin6_family = AF_INET6;
d2321 1
a2321 1
      ((struct sockaddr_in6 *)hostmask)->sin6_len = sizeof (struct in6_addr);
d2323 21
a2343 16
      memset (&((struct sockaddr_in6 *)hostmask)->sin6_addr.s6_addr, 0xff,
	      sizeof (struct in6_addr));
      break;
    }

  /* Ingress flows, handling SA bundles. */
  while (TAILQ_NEXT (proto, link))
    {
      error = pf_key_v2_flow (dst, hostmask, src, hostmask, 0, 0, 0,
			      proto->spi[1], proto->proto, src, dst,
			      0, 1, 0, 0, 0, 0, 0, 0, proto->data);
      if (error)
	goto cleanup;
      proto = TAILQ_NEXT (proto, link);
    }
#endif /* SADB_X_EXT_FLOW_TYPE */
d2345 1
a2345 7
  error = pf_key_v2_flow (isa->dst_net, isa->dst_mask, isa->src_net,
			  isa->src_mask, isa->tproto, isa->dport, isa->sport,
			  proto->spi[1], proto->proto, src, dst, 0, 1,
			  sidtype, sid, sidlen, didtype, did, didlen,
			  proto->data);

 cleanup:
d2347 5
a2351 5
  if (sid)
    free (sid);
  if (did)
    free (did);
#endif /* SADB_X_EXT_FLOW_TYPE */
d2353 1
a2353 1
  return error;
d2359 1
a2359 1
pf_key_v2_conf_refinc (int af, char *section)
d2361 2
a2362 2
  char conn[22];
  int num;
d2364 2
a2365 2
  if (!section)
    return 0;
d2367 7
a2373 7
  num = conf_get_num (section, "Refcount", 0);
  if (num == 0)
    return 0;

  snprintf (conn, sizeof conn, "%d", num + 1);
  conf_set (af, section, "Refcount", conn, 1, 0);
  return 0;
d2382 1
a2382 1
pf_key_v2_conf_refhandle (int af, char *section)
d2384 2
a2385 2
  char conn[22];
  int num;
d2387 2
a2388 2
  if (!section)
    return 0;
d2390 9
a2398 14
  num = conf_get_num (section, "Refcount", 0);
  if (num == 1)
    {
      conf_remove_section (af, section);
      num--;
    }
  else
    if (num != 0)
      {
	snprintf (conn, sizeof conn, "%d", num - 1);
	conf_set (af, section, "Refcount", conn, 1, 0);
      }

  return num;
d2403 1
a2403 1
pf_key_v2_remove_conf (char *section)
d2405 18
a2422 4
  char *ikepeer, *localid, *remoteid, *configname;
  struct conf_list_node *attr;
  struct conf_list *attrs;
  int af;
d2424 3
a2426 2
  if (!section)
    return 0;
d2428 2
a2429 2
  if (!conf_get_str (section, "Phase"))
    return 0;
d2431 1
a2431 8
  /* Only remove dynamically-established entries. */
  attrs = conf_get_list (section, "Flags");
  if (attrs)
    {
      for (attr = TAILQ_FIRST (&attrs->fields); attr;
	   attr = TAILQ_NEXT (attr, link))
	if (!strcasecmp (attr->field, "__ondemand"))
	  goto passed;
d2433 2
a2434 2
      conf_free_list (attrs);
    }
d2436 3
a2438 1
  return 0;
d2440 2
a2441 2
 passed:
  conf_free_list (attrs);
d2443 1
a2443 1
  af = conf_begin ();
d2445 1
a2445 2
  configname = conf_get_str (section, "Configuration");
  conf_remove_section (af, configname);
d2447 4
a2450 3
  /* These are the Phase 2 Local/Remote IDs. */
  localid = conf_get_str (section, "Local-ID");
  pf_key_v2_conf_refhandle (af, localid);
d2452 2
a2453 2
  remoteid = conf_get_str (section, "Remote-ID");
  pf_key_v2_conf_refhandle (af, remoteid);
d2455 6
a2460 20
  ikepeer = conf_get_str (section, "ISAKMP-peer");

  pf_key_v2_conf_refhandle (af, section);

  if (ikepeer)
    {
      remoteid = conf_get_str (ikepeer, "Remote-ID");
      localid = conf_get_str (ikepeer, "ID");
      configname = conf_get_str (ikepeer, "Configuration");

      pf_key_v2_conf_refhandle (af, ikepeer);
      pf_key_v2_conf_refhandle (af, configname);

      /* Phase 1 IDs */
      pf_key_v2_conf_refhandle (af, localid);
      pf_key_v2_conf_refhandle (af, remoteid);
    }

  conf_end (af, 1);
  return 0;
d2465 1
a2465 1
pf_key_v2_disable_sa (struct sa *sa, int incoming)
d2467 3
a2469 3
  struct ipsec_sa *isa = sa->data;
  struct sockaddr *dst, *src;
  struct proto *proto = TAILQ_FIRST (&sa->protos);
d2471 14
a2484 15
  struct sockaddr_storage hostmask_storage;
  struct sockaddr *hostmask = (struct sockaddr *)&hostmask_storage;
  int error;
#endif /* SADB_X_EXT_FLOW_TYPE */

  sa->transport->vtbl->get_dst (sa->transport, &dst);
  sa->transport->vtbl->get_src (sa->transport, &src);

  if (!incoming)
    return pf_key_v2_flow (isa->src_net, isa->src_mask, isa->dst_net,
			   isa->dst_mask, isa->tproto, isa->sport, isa->dport,
			   proto->spi[0], proto->proto, src, dst, 1, 0,
			   0, 0, 0, 0, 0, 0, proto->data);
  else
    {
d2486 4
a2489 5
      /* Set hostmask to '-1'. */
      switch (dst->sa_family)
	{
	case AF_INET:
	  ((struct sockaddr_in *)hostmask)->sin_family = AF_INET;
d2491 1
a2491 1
	  ((struct sockaddr_in *)hostmask)->sin_len = sizeof (struct in_addr);
d2493 5
a2497 5
	  memset (&((struct sockaddr_in *)hostmask)->sin_addr.s_addr, 0xff,
		  sizeof (struct in_addr));
	  break;
	case AF_INET6:
	  ((struct sockaddr_in6 *)hostmask)->sin6_family = AF_INET6;
d2499 2
a2500 2
	  ((struct sockaddr_in6 *)hostmask)->sin6_len =
	    sizeof (struct in6_addr);
d2502 4
a2505 4
	  memset (&((struct sockaddr_in6 *)hostmask)->sin6_addr.s6_addr, 0xff,
		  sizeof (struct in6_addr));
	  break;
	}
d2507 10
a2516 11
      /* Ingress flow --- SA bundles */
      while (TAILQ_NEXT (proto, link))
	{
          error = pf_key_v2_flow (dst, hostmask, src, hostmask, 0, 0, 0,
				  proto->spi[1], proto->proto, src, dst,
				  1, 1, 0, 0, 0, 0, 0, 0, proto->data);
          if (error)
	    return error;
          proto = TAILQ_NEXT (proto, link);
	}
#endif /* SADB_X_EXT_FLOW_TYPE */
d2518 3
a2520 3
      return pf_key_v2_flow (isa->dst_net, isa->dst_mask, isa->src_net,
			     isa->src_mask, isa->tproto, isa->dport,
			     isa->sport, proto->spi[1], proto->proto,
d2522 1
a2522 1
    }
d2530 1
a2530 1
pf_key_v2_delete_spi (struct sa *sa, struct proto *proto, int incoming)
d2532 6
a2537 6
  struct sadb_msg msg;
  struct sadb_sa ssa;
  struct sadb_address *addr = 0;
  struct sockaddr *saddr;
  int len, err;
  struct pf_key_v2_msg *delete = 0, *ret = 0;
d2539 1
a2539 1
  struct sadb_x_sa2 ssa2;
d2542 27
a2568 30
  /* If it's not an established SA, don't proceed. */
  if (!(sa->flags & SA_FLAG_READY))
    return 0;

  /*
   * If the SA was not replaced and was not one acquired through the
   * kernel (ACQUIRE message), remove the flow associated with it.
   * We ignore any errors from the disabling of the flow.
   */
  if (!(sa->flags & SA_FLAG_REPLACED)
      && !(sa->flags & SA_FLAG_ONDEMAND))
    pf_key_v2_disable_sa (sa, incoming);

  if (sa->name && !(sa->flags & SA_FLAG_REPLACED))
    {
      LOG_DBG ((LOG_SYSDEP, 50,
		"pf_key_v2_delete_spi: removing configuration %s",
		sa->name));
      pf_key_v2_remove_conf (sa->name);
    }

  msg.sadb_msg_type = SADB_DELETE;
  switch (proto->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      msg.sadb_msg_satype = SADB_SATYPE_ESP;
      break;
    case IPSEC_PROTO_IPSEC_AH:
      msg.sadb_msg_satype = SADB_SATYPE_AH;
      break;
d2570 24
a2593 24
    case IPSEC_PROTO_IPCOMP:
      msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
      break;
#endif
    default:
      log_print ("pf_key_v2_delete_spi: invalid proto %d", proto->proto);
      goto cleanup;
    }
  msg.sadb_msg_seq = 0;
  delete = pf_key_v2_msg_new (&msg, 0);
  if (!delete)
    goto cleanup;

  /* Setup the SA extension.  */
  ssa.sadb_sa_exttype = SADB_EXT_SA;
  ssa.sadb_sa_len = sizeof ssa / PF_KEY_V2_CHUNK;
  memcpy (&ssa.sadb_sa_spi, proto->spi[incoming], sizeof ssa.sadb_sa_spi);
  ssa.sadb_sa_replay = 0;
  ssa.sadb_sa_state = 0;
  ssa.sadb_sa_auth = 0;
  ssa.sadb_sa_encrypt = 0;
  ssa.sadb_sa_flags = 0;
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)&ssa, 0) == -1)
    goto cleanup;
d2596 21
a2616 21
  memset (&ssa2, 0, sizeof ssa2);
  ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  ssa2.sadb_x_sa2_len = sizeof ssa2 / PF_KEY_V2_CHUNK;
  ssa2.sadb_x_sa2_mode = 0;
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)&ssa2, 0) == -1)
    goto cleanup;
#endif

  /*
   * Setup the ADDRESS extensions.
   */
  if (incoming)
    sa->transport->vtbl->get_dst (sa->transport, &saddr);
  else
    sa->transport->vtbl->get_src (sa->transport, &saddr);
  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (saddr));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d2618 2
a2619 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d2621 25
a2645 26
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, saddr, sysdep_sa_len (saddr));
  switch (saddr->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
      break;
    }
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &saddr);
  else
    sa->transport->vtbl->get_dst (sa->transport, &saddr);
  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (saddr));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d2647 2
a2648 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d2650 40
a2689 42
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, saddr, sysdep_sa_len (saddr));
  switch (saddr->sa_family)
    {
    case AF_INET:
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
      break;
    case AF_INET6:
      ((struct sockaddr_in6 *)(addr + 1))->sin6_port = 0;
      break;
    }
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  ret = pf_key_v2_call (delete);
  pf_key_v2_msg_free (delete);
  delete = 0;
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      LOG_DBG ((LOG_SYSDEP, 10, "pf_key_v2_delete_spi: DELETE: %s",
		strerror (err)));
      goto cleanup;
    }
  pf_key_v2_msg_free (ret);

  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_delete_spi: done"));

  return 0;

 cleanup:
  if (addr)
    free (addr);
  if (delete)
    pf_key_v2_msg_free (delete);
  if (ret)
    pf_key_v2_msg_free (ret);
  return -1;
d2693 1
a2693 1
pf_key_v2_stayalive (struct exchange *exchange, void *vconn, int fail)
d2695 2
a2696 2
  char *conn = vconn;
  struct sa *sa;
d2698 13
a2710 14
  /* XXX What if it is phase 1 ? */
  sa = sa_lookup_by_name (conn, 2);
  if (sa)
    sa->flags |= SA_FLAG_STAYALIVE;

  /*
   * Remove failed configuration entry -- call twice because it is
   * created with a Refcount of 2.
   */
  if (fail && (!exchange || exchange->name))
    {
      pf_key_v2_remove_conf (conn);
      pf_key_v2_remove_conf (conn);
    }
d2715 1
a2715 1
pf_key_v2_connection_check (char *conn)
d2717 7
a2723 9
  if (!sa_lookup_by_name (conn, 2))
    {
      LOG_DBG ((LOG_SYSDEP, 70,
		"pf_key_v2_connection_check: SA for %s missing", conn));
      exchange_establish (conn, pf_key_v2_stayalive, conn);
    }
  else
    LOG_DBG ((LOG_SYSDEP, 70, "pf_key_v2_connection_check: SA for %s exists",
	      conn));
d2728 1
a2728 1
pf_key_v2_expire (struct pf_key_v2_msg *pmsg)
d2730 38
a2767 42
  struct sadb_msg *msg;
  struct sadb_sa *ssa;
  struct sadb_address *dst;
  struct sockaddr *dstaddr;
  struct sadb_lifetime *life, *lifecurrent;
  struct sa *sa;
  struct pf_key_v2_node *lifenode, *ext;
  char *dst_str;

  msg = (struct sadb_msg *)TAILQ_FIRST (pmsg)->seg;
  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_SA);
  if (!ext)
    {
      log_print ("pf_key_v2_expire: no SA extension found");
      return;
    }
  ssa = ext->seg;
  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_ADDRESS_DST);
  if (!ext)
    {
      log_print ("pf_key_v2_expire: no destination address extension found");
      return;
    }
  dst = ext->seg;
  dstaddr = (struct sockaddr *)(dst + 1);
  lifenode = pf_key_v2_find_ext (pmsg, SADB_EXT_LIFETIME_HARD);
  if (!lifenode)
    lifenode = pf_key_v2_find_ext (pmsg, SADB_EXT_LIFETIME_SOFT);
  if (!lifenode)
    {
      log_print ("pf_key_v2_expire: no lifetime extension found");
      return;
    }
  life = lifenode->seg;

  lifenode = pf_key_v2_find_ext (pmsg, SADB_EXT_LIFETIME_CURRENT);
  if (!lifenode)
    {
      log_print ("pf_key_v2_expire: no current lifetime extension found");
      return;
    }
  lifecurrent = lifenode->seg;
d2771 2
a2772 2
  if (sockaddr2text (dstaddr, &dst_str, 0))
    dst_str = 0;
d2774 26
a2799 27
  LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_expire: %s dst %s SPI %x sproto %d",
	    life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ? "SOFT"
	    : "HARD", dst_str ? dst_str : "<unknown>",
	    ntohl (ssa->sadb_sa_spi), msg->sadb_msg_satype));

  if (dst_str)
    free (dst_str);

#endif /* USE_DEBUG */

  /*
   * Find the IPsec SA.  The IPsec stack has two SAs for every IKE SA,
   * one outgoing and one incoming, we regard expirations for any of
   * them as an expiration of the full IKE SA.  Likewise, in
   * protection suites consisting of more than one protocol, any
   * expired individual IPsec stack SA will be seen as an expiration
   * of the full suite.
   */
  switch (msg->sadb_msg_satype)
    {
    case SADB_SATYPE_ESP:
      sa = ipsec_sa_lookup (dstaddr, ssa->sadb_sa_spi, IPSEC_PROTO_IPSEC_ESP);
      break;

    case SADB_SATYPE_AH:
      sa = ipsec_sa_lookup (dstaddr, ssa->sadb_sa_spi, IPSEC_PROTO_IPSEC_AH);
      break;
d2802 29
a2830 30
    case SADB_X_SATYPE_IPCOMP:
      sa = ipsec_sa_lookup (dstaddr, ssa->sadb_sa_spi, IPSEC_PROTO_IPCOMP);
      break;
#endif

    default:
      /* XXX Log? */
      sa = 0;
      break;
    }

  /* If the SA is already gone, don't do anything.  */
  if (!sa)
    return;

  /*
   * If we got a notification, try to renegotiate the SA -- unless of
   * course it has already been replaced by another.
   * Also, ignore SAs that were not dynamically established, or that
   * did not see any use.
   */
  if (!(sa->flags & SA_FLAG_REPLACED) && (sa->flags & SA_FLAG_ONDEMAND) &&
      lifecurrent->sadb_lifetime_bytes)
    exchange_establish (sa->name, 0, 0);

  if (life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_HARD)
    {
      /* Remove the old SA, it isn't useful anymore.  */
      sa_free (sa);
    }
d2835 1
a2835 1
pf_key_v2_acquire (struct pf_key_v2_msg *pmsg)
d2838 26
a2863 25
  struct sadb_msg *msg, askpolicy_msg;
  struct pf_key_v2_msg *askpolicy = 0, *ret = 0;
  struct sadb_x_policy policy;
  struct sadb_address *dst = 0, *src = 0;
  struct sockaddr *dstaddr, *srcaddr = 0;
  struct sadb_comb *scmb = 0;
  struct sadb_prop *sprp = 0;
  struct sadb_ident *srcident = 0, *dstident = 0;
  char dstbuf[ADDRESS_MAX], srcbuf[ADDRESS_MAX], *peer = 0, *conn = 0;
  char confname[120];
  char *srcid = 0, *dstid = 0, *prefstring = 0;
  int slen, af, afamily, masklen, buflen;
  struct sockaddr *smask, *sflow, *dmask, *dflow;
  struct sadb_protocol *sproto;
  char ssflow[ADDRESS_MAX], sdflow[ADDRESS_MAX];
  char sdmask[ADDRESS_MAX], ssmask[ADDRESS_MAX];
  char *sidtype = 0, *didtype = 0;
  char lname[100], dname[100], configname[30];
  int shostflag = 0, dhostflag = 0;
  struct pf_key_v2_node *ext;
  struct passwd *pwd = 0;
  u_int16_t sport = 0, dport = 0;
  u_int8_t tproto = 0;
  char tmbuf[sizeof sport * 3 + 1], *xform;
  int connlen;
d2865 1
a2865 1
  struct sadb_x_cred *cred = 0, *sauth = 0;
d2868 49
a2916 96
  /* This needs to be dynamically allocated. */
  connlen = 22;
  conn = malloc (connlen);
  if (!conn)
    {
      log_error ("pf_key_v2_acquire: malloc (%d) failed", connlen);
      return;
    }

  msg = (struct sadb_msg *)TAILQ_FIRST (pmsg)->seg;

  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_ADDRESS_DST);
  if (!ext)
    {
      log_print ("pf_key_v2_acquire: no destination address specified");
      return;
    }
  dst = ext->seg;

  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_ADDRESS_SRC);
  if (ext)
    src = ext->seg;

  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_PROPOSAL);
  if (ext)
    {
      sprp = ext->seg;
      scmb = (struct sadb_comb *)(sprp + 1);
    }

  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_IDENTITY_SRC);
  if (ext)
    srcident = ext->seg;

  ext = pf_key_v2_find_ext (pmsg, SADB_EXT_IDENTITY_DST);
  if (ext)
    dstident = ext->seg;

  /* Ask the kernel for the matching policy. */
  bzero (&askpolicy_msg, sizeof askpolicy_msg);
  askpolicy_msg.sadb_msg_type = SADB_X_ASKPOLICY;
  askpolicy = pf_key_v2_msg_new (&askpolicy_msg, 0);
  if (!askpolicy)
    goto fail;

  policy.sadb_x_policy_exttype = SADB_X_EXT_POLICY;
  policy.sadb_x_policy_len = sizeof policy / PF_KEY_V2_CHUNK;
  policy.sadb_x_policy_seq = msg->sadb_msg_seq;
  if (pf_key_v2_msg_add (askpolicy, (struct sadb_ext *)&policy, 0) == -1)
    goto fail;

  ret = pf_key_v2_call (askpolicy);
  if (!ret)
    goto fail;

  /* Now we have all the information needed. */

  ext = pf_key_v2_find_ext (ret, SADB_X_EXT_SRC_FLOW);
  if (!ext)
    {
      log_print ("pf_key_v2_acquire: no source flow extension found");
      goto fail;
    }
  sflow = (struct sockaddr *)(((struct sadb_address *)ext->seg) + 1);

  ext = pf_key_v2_find_ext (ret, SADB_X_EXT_DST_FLOW);
  if (!ext)
    {
      log_print ("pf_key_v2_acquire: no destination flow extension found");
      goto fail;
    }
  dflow = (struct sockaddr *)(((struct sadb_address *)ext->seg) + 1);
  ext = pf_key_v2_find_ext (ret, SADB_X_EXT_SRC_MASK);
  if (!ext)
    {
      log_print ("pf_key_v2_acquire: no source mask extension found");
      goto fail;
    }
  smask = (struct sockaddr *)(((struct sadb_address *)ext->seg) + 1);

  ext = pf_key_v2_find_ext (ret, SADB_X_EXT_DST_MASK);
  if (!ext)
    {
      log_print ("pf_key_v2_acquire: no destination mask extension found");
      goto fail;
    }
  dmask = (struct sockaddr *)(((struct sadb_address *)ext->seg) + 1);

  ext = pf_key_v2_find_ext (ret, SADB_X_EXT_FLOW_TYPE);
  if (!ext)
    {
      log_print ("pf_key_v2_acquire: no flow type extension found");
      goto fail;
    }
  sproto = ext->seg;
  tproto = sproto->sadb_protocol_proto;
d2918 1
a2918 7
#if defined (SADB_X_EXT_LOCAL_CREDENTIALS)
  ext = pf_key_v2_find_ext (pmsg, SADB_X_EXT_LOCAL_CREDENTIALS);
  if (ext)
    cred = (struct sadb_x_cred *) ext->seg;
  else
    cred = 0;
#endif
d2920 4
a2923 23
#if defined (SADB_X_EXT_LOCAL_AUTH)
  ext = pf_key_v2_find_ext (pmsg, SADB_X_EXT_LOCAL_AUTH);
  if (ext)
    sauth = (struct sadb_x_cred *) ext->seg;
  else
    sauth = 0;
#endif

  bzero (ssflow, sizeof ssflow);
  bzero (sdflow, sizeof sdflow);
  bzero (ssmask, sizeof ssmask);
  bzero (sdmask, sizeof sdmask);

  sidtype = didtype = "IPV4_ADDR_SUBNET"; /* default */

  switch (sflow->sa_family)
    {
    case AF_INET:
      if (inet_ntop (AF_INET, &((struct sockaddr_in *)sflow)->sin_addr, ssflow,
		     ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
d2925 6
a2930 6
      sport = ((struct sockaddr_in *)sflow)->sin_port;
      if (inet_ntop (AF_INET, &((struct sockaddr_in *)dflow)->sin_addr, sdflow,
		     ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
d2932 5
a2936 6
      dport = ((struct sockaddr_in *)dflow)->sin_port;
      if (inet_ntop (AF_INET, &((struct sockaddr_in *)smask)->sin_addr, ssmask,
		     ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
d2938 6
a2943 5
      if (inet_ntop (AF_INET, &((struct sockaddr_in *)dmask)->sin_addr, sdmask,
		     ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
d2945 6
a2950 4
      if (((struct sockaddr_in *)smask)->sin_addr.s_addr == INADDR_BROADCAST)
	{
	  shostflag = 1;
	  sidtype = "IPV4_ADDR";
d2952 59
a3010 6
      if (((struct sockaddr_in *)dmask)->sin_addr.s_addr == INADDR_BROADCAST)
	{
	  dhostflag = 1;
	  didtype = "IPV4_ADDR";
	}
      break;
d3012 33
a3044 37
    case AF_INET6:
      if (inet_ntop (AF_INET6, &((struct sockaddr_in6 *)sflow)->sin6_addr,
		     ssflow, ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
	}
      sport = ((struct sockaddr_in6 *)sflow)->sin6_port;
      if (inet_ntop (AF_INET6, &((struct sockaddr_in6 *)dflow)->sin6_addr,
		     sdflow, ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
	}
      dport = ((struct sockaddr_in6 *)dflow)->sin6_port;
      if (inet_ntop (AF_INET6, &((struct sockaddr_in6 *)smask)->sin6_addr,
		     ssmask, ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
	}
      if (inet_ntop (AF_INET6, &((struct sockaddr_in6 *)dmask)->sin6_addr,
		     sdmask, ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
	}
      sidtype = didtype = "IPV6_ADDR_SUBNET";
      if (IN6_IS_ADDR_FULL (&((struct sockaddr_in6 *)smask)->sin6_addr))
	{
	  shostflag = 1;
	  sidtype = "IPV6_ADDR";
	}
      if (IN6_IS_ADDR_FULL (&((struct sockaddr_in6 *)dmask)->sin6_addr))
	{
	  dhostflag = 1;
	  didtype = "IPV6_ADDR";
a3045 2
      break;
    }
d3047 14
a3060 33
  dstaddr = (struct sockaddr *)(dst + 1);
  bzero (dstbuf, sizeof dstbuf);
  bzero (srcbuf, sizeof srcbuf);

  if (dstaddr->sa_family == 0)
    {
      /* Destination was not specified in the flow -- can we derive it? */
      if (dhostflag == 0)
	{
          log_print("pf_key_v2_acquire: Cannot determine precise destination");
          goto fail;
        }
      dstaddr = dflow;
    }
  switch (dstaddr->sa_family)
    {
    case AF_INET:
      if (inet_ntop (AF_INET, &((struct sockaddr_in *)dstaddr)->sin_addr,
		     dstbuf, ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
	}
      LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d", dstbuf,
		msg->sadb_msg_satype));
      break;

    case AF_INET6:
      if (inet_ntop (AF_INET6, &((struct sockaddr_in6 *)dstaddr)->sin6_addr,
		     dstbuf, ADDRESS_MAX) == NULL)
	{
	  log_print ("pf_key_v2_acquire: inet_ntop failed");
	  goto fail;
d3062 1
a3062 11
      LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d", dstbuf,
		msg->sadb_msg_satype));
      break;
    }

  if (src)
    {
      srcaddr = (struct sockaddr *)(src + 1);

      switch (srcaddr->sa_family)
        {
d3064 8
a3071 7
	  if (inet_ntop (AF_INET, &((struct sockaddr_in *)srcaddr)->sin_addr,
			 srcbuf, ADDRESS_MAX) == NULL)
	    {
	      log_print ("pf_key_v2_acquire: inet_ntop failed");
	      goto fail;
	    }
	  break;
d3074 30
a3103 8
	  if (inet_ntop (AF_INET6,
			 &((struct sockaddr_in6 *)srcaddr)->sin6_addr, srcbuf,
			 ADDRESS_MAX) == NULL)
	    {
	      log_print ("pf_key_v2_acquire: inet_ntop failed");
	      goto fail;
	    }
          break;
d3105 10
a3114 21
	default:
	  /*
	   * The kernel will pass an all '0' EXT_ADDRESS_SRC if it wasn't
	   * specified for the flow. In that case, do NOT specify the srcaddr
	   * in the Peer- name below
	   */
	  srcbuf[0] = 0;
	  srcaddr = NULL;
	  break;
	}
    }

  /* Insert source ID. */
  if (srcident)
    {
      slen = (srcident->sadb_ident_len * sizeof (u_int64_t))
	- sizeof (struct sadb_ident);
      if (((unsigned char *)(srcident + 1))[slen - 1] != '\0')
	{
	  log_print ("pf_key_v2_acquire: source identity not NUL-terminated");
	  goto fail;
d3116 152
d3269 2
a3270 3
      /* Check for valid type. */
      switch (srcident->sadb_ident_type)
        {
d3272 134
a3405 140
	case SADB_X_IDENTTYPE_CONNECTION:
	  /* XXX */
	  break;
#endif

	case SADB_IDENTTYPE_PREFIX:
	  /* Determine what the address family is. */
	  srcid = memchr (srcident + 1, ':', slen);
	  if (srcid)
	    afamily = AF_INET6;
	  else
	    afamily = AF_INET;

	  srcid = memchr (srcident + 1, '/', slen);
	  if (!srcid)
	    {
	      log_print ("pf_key_v2_acquire: badly formatted PREFIX identity");
	      goto fail;
	    }

	  masklen = atoi (srcid + 1);

	  /* XXX We only support host addresses. */
	  if ((afamily == AF_INET6 && masklen != 128)
	      || (afamily == AF_INET && masklen != 32))
	    {
	      log_print ("pf_key_v2_acquire: non-host address specified in "
			 "source identity (mask length %d), ignoring request",
			 masklen);
	      goto fail;
	    }

	  /* NUL-terminate the PREFIX string at the separator, then dup. */
	  *srcid = '\0';
	  slen = strlen ((char *)(srcident + 1)) + sizeof "ID:Address/";
	  srcid = malloc (slen);
	  if (!srcid)
	    {
	      log_error ("pf_key_v2_acquire: malloc (%d) failed", slen);
	      goto fail;
	    }

	  snprintf (srcid, slen, "ID:Address/%s", (char *)(srcident + 1));

	  /* Set the section if it doesn't already exist. */
	  af = conf_begin ();
	  if (!conf_get_str (srcid, "ID-type"))
	    {
	      if (conf_set (af, srcid, "ID-type",
			    afamily == AF_INET ? "IPV4_ADDR" : "IPV6_ADDR",
			    1, 0)
		  || conf_set (af, srcid, "Refcount", "1", 1, 0)
		  || conf_set (af, srcid, "Address", (char *)(srcident + 1),
			       1, 0))
		{
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	  else
	    pf_key_v2_conf_refinc (af, srcid);
	  conf_end (af, 1);
	  break;

	case SADB_IDENTTYPE_FQDN:
	  prefstring = "FQDN";
	  /* Fall through */
	case SADB_IDENTTYPE_USERFQDN:
	  if (!prefstring)
	    {
	      prefstring = "USER_FQDN";

	      /*
	       * Check whether there is a string following the header;
	       * if no, that there is a user ID (and acquire the login
	       * name). If there is both a string and a user ID, check
	       * that they match.
	       */
	      if ((slen == 0) && (srcident->sadb_ident_id == 0))
	        {
		  log_print ("pf_key_v2_acquire: no user FQDN or ID provided");
		  goto fail;
		}

	      if (srcident->sadb_ident_id)
	        {
		  pwd = getpwuid (srcident->sadb_ident_id);
		  if (!pwd)
		    {
		      log_error ("pf_key_v2_acquire: could not acquire "
				 "username from provided ID %llu",
				 srcident->sadb_ident_id);
		      goto fail;
		    }

		  if (slen != 0)
		    if (strcmp (pwd->pw_name, (char *)(srcident + 1)) != 0)
		      {
			log_print ("pf_key_v2_acquire: provided user name and "
				   "ID do not match (%s != %s)",
				   (char *)(srcident + 1), pwd->pw_name);
			/* String has precedence, per RFC 2367. */
		      }
		}
	    }

	  buflen = (slen ? slen : strlen (pwd->pw_name)) + strlen (prefstring)
	    + sizeof "ID:/";
	  srcid = malloc (buflen);
	  if (!srcid)
	    {
	      log_error ("pf_key_v2_acquire: malloc (%d) failed", buflen);
	      goto fail;
	    }

	  snprintf (srcid, buflen, "ID:%s/", prefstring);
	  if (slen != 0)
	    strlcat (srcid, (char *)(srcident + 1), buflen);
	  else
	    strlcat (srcid, pwd->pw_name, buflen);
	  pwd = 0;

	  /* Set the section if it doesn't already exist. */
	  af = conf_begin ();
	  if (!conf_get_str (srcid, "ID-type"))
	    {
	      if (conf_set (af, srcid, "ID-type", prefstring, 1, 0)
		  || conf_set (af, srcid, "Refcount", "1", 1, 0)
		  || conf_set (af, srcid, "Name",
			       srcid + sizeof "ID:/" - 1 + strlen (prefstring),
			       1, 0))
		{
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	  else
	    pf_key_v2_conf_refinc (af, srcid);
	  conf_end (af, 1);
	  break;
d3407 43
a3449 164
	default:
	  LOG_DBG ((LOG_SYSDEP, 20,
		    "pf_key_v2_acquire: invalid source ID type %d",
		    srcident->sadb_ident_type));
	  goto fail;
	}

      LOG_DBG ((LOG_SYSDEP, 50,
		"pf_key_v2_acquire: constructed source ID \"%s\"", srcid));
      prefstring = 0;
    }

  /* Insert destination ID. */
  if (dstident)
    {
      slen = (dstident->sadb_ident_len * sizeof (u_int64_t))
	- sizeof (struct sadb_ident);

      /* Check for valid type. */
      switch (dstident->sadb_ident_type)
        {
#if defined (SADB_X_IDENTTYPE_CONNECTION)
	case SADB_X_IDENTTYPE_CONNECTION:
	  /* XXX */
	  break;
#endif

	case SADB_IDENTTYPE_PREFIX:
	  /* Determine what the address family is. */
	  dstid = memchr (dstident + 1, ':', slen);
	  if (dstid)
	    afamily = AF_INET6;
	  else
	    afamily = AF_INET;

	  dstid = memchr (dstident + 1, '/', slen);
	  if (!dstid)
	    {
	      log_print ("pf_key_v2_acquire: badly formatted PREFIX identity");
	      goto fail;
	    }

	  masklen = atoi (dstid + 1);

	  /* XXX We only support host addresses. */
	  if ((afamily == AF_INET6 && masklen != 128)
	      || (afamily == AF_INET && masklen != 32))
	    {
	      log_print ("pf_key_v2_acquire: non-host address specified in "
			 "destination identity (mask length %d), ignoring "
			 "request",
			 masklen);
	      goto fail;
	    }

	  /* NUL-terminate the PREFIX string at the separator, then dup. */
	  *dstid = '\0';
	  slen = strlen ((char *)(dstident + 1)) + sizeof "ID:Address/";
	  dstid = malloc (slen);
	  if (!dstid)
	    {
	      log_error ("pf_key_v2_acquire: malloc (%d) failed", slen);
	      goto fail;
	    }

	  snprintf (dstid, slen, "ID:Address/%s", (char *)(dstident + 1));

	  /* Set the section if it doesn't already exist. */
	  af = conf_begin ();
	  if (!conf_get_str (dstid, "ID-type"))
	    {
	      if (conf_set (af, dstid, "ID-type",
			    afamily == AF_INET ? "IPV4_ADDR" : "IPV6_ADDR",
			    1, 0)
		  || conf_set (af, dstid, "Refcount", "1", 1, 0)
		  || conf_set (af, dstid, "Address", (char *)(dstident + 1),
			       1, 0))
		{
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	  else
	    pf_key_v2_conf_refinc (af, dstid);
	  conf_end (af, 1);
	  break;

	case SADB_IDENTTYPE_FQDN:
	  prefstring = "FQDN";
	  /* Fall through */

	case SADB_IDENTTYPE_USERFQDN:
	  if (!prefstring)
	    {
	      prefstring = "USER_FQDN";

	      /*
	       * Check whether there is a string following the header;
	       * if no, that there is a user ID (and acquire the login
	       * name). If there is both a string and a user ID, check
	       * that they match.
	       */
	      if (slen == 0 && dstident->sadb_ident_id == 0)
	        {
		  log_print ("pf_key_v2_acquire: no user FQDN or ID provided");
		  goto fail;
		}

	      if (dstident->sadb_ident_id)
	        {
		  pwd = getpwuid (dstident->sadb_ident_id);
		  if (!pwd)
		    {
		      log_error ("pf_key_v2_acquire: could not acquire "
				 "username from provided ID %llu",
				 dstident->sadb_ident_id);
		      goto fail;
		    }

		  if (slen != 0)
		    if (strcmp (pwd->pw_name, (char *)(dstident + 1)) != 0)
		      {
			log_print ("pf_key_v2_acquire: provided user name and "
				   "ID do not match (%s != %s)",
				   (char *)(dstident + 1), pwd->pw_name);
			/* String has precedence, per RF 2367. */
		      }
		}
	    }

	  buflen = (slen ? slen : strlen (pwd->pw_name)) + strlen (prefstring)
	    + sizeof "ID:/";
	  dstid = malloc (buflen);
	  if (!dstid)
	    {
	      log_error ("pf_key_v2_acquire: malloc (%d) failed", buflen);
	      goto fail;
	    }

	  snprintf (dstid, buflen, "ID:%s/", prefstring);
	  if (slen != 0)
	    strlcat (dstid, (char *)(dstident + 1), buflen);
	  else
	    strlcat (dstid, pwd->pw_name, buflen);
	  pwd = 0;

	  /* Set the section if it doesn't already exist. */
	  af = conf_begin ();
	  if (!conf_get_str (dstid, "ID-type"))
	    {
	      if (conf_set (af, dstid, "ID-type", prefstring, 1, 0)
		  || conf_set (af, dstid, "Refcount", "1", 1, 0)
		  || conf_set (af, dstid, "Name",
			       dstid + sizeof "ID:/" - 1 + strlen (prefstring),
			       1, 0))
		{
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	  else
	    pf_key_v2_conf_refinc (af, dstid);
	  conf_end (af, 1);
	  break;
d3451 39
a3489 105
	default:
	  LOG_DBG ((LOG_SYSDEP, 20,
		    "pf_key_v2_acquire: invalid destination ID type %d",
		    dstident->sadb_ident_type));
	  goto fail;
	}

      LOG_DBG ((LOG_SYSDEP, 50,
		"pf_key_v2_acquire: constructed destination ID \"%s\"",
		dstid));
    }

  /* Now we've placed the necessary IDs in the configuration space. */

  /* Get a new connection sequence number. */
  for (;; connection_seq++)
    {
      snprintf (conn, connlen, "Connection-%u", connection_seq);
      snprintf (configname, sizeof configname, "Config-Phase2-%u",
		connection_seq);

      /* Does it exist ? */
      if (!conf_get_str (conn, "Phase")
	  && !conf_get_str (configname, "Suites"))
	break;
    }

  /*
   * Set the IPsec connection entry. In particular, the following fields:
   * - Phase
   * - ISAKMP-peer
   * - Local-ID/Remote-ID (if provided)
   * - Acquire-ID (sequence number of kernel message, e.g., PF_KEYv2)
   * - Configuration
   *
   * Also set the following section:
   *    [Peer-dstaddr(/srcaddr)(-srcid)(/dstid)]
   * with these fields:
   * - Phase
   * - ID (if provided)
   * - Remote-ID (if provided)
   * - Local-address (if provided)
   * - Address
   * - Configuration (if an entry "ISAKMP-configuration-dstaddr(/srcaddr)"
   *                  exists -- otherwise use the defaults)
   */

  slen = strlen (dstbuf) + strlen (srcbuf) + (srcid ? strlen (srcid) : 0)
    + (dstid ? strlen (dstid) : 0) + sizeof "Peer-/-/";
  peer = malloc (slen);
  if (!peer)
    goto fail;

  /*
   * The various cases:
   * - Peer-dstaddr
   * - Peer-dstaddr/srcaddr
   * - Peer-dstaddr/srcaddr-srcid
   * - Peer-dstaddr/srcaddr-srcid/dstid
   * - Peer-dstaddr/srcaddr-/dstid
   * - Peer-dstaddr-srcid/dstid
   * - Peer-dstaddr-/dstid
   * - Peer-dstaddr-srcid
   */
  snprintf (peer, slen, "Peer-%s%s%s%s%s%s%s", dstbuf, srcaddr ? "/" : "",
	    srcaddr ? srcbuf : "", srcid ? "-" : "", srcid ? srcid : "",
	    dstid ? (srcid ? "/" : "-/") : "", dstid ? dstid : "");

  /*
   * Set the IPsec connection section. Refcount is set to 2, because
   * it will be linked both to the incoming and the outgoing SA.
   */
  af = conf_begin ();
  if (conf_set (af, conn, "Phase", "2", 0, 0)
      || conf_set (af, conn, "Flags", "__ondemand", 0 , 0)
      || conf_set (af, conn, "Refcount", "2", 0 , 0)
      || conf_set (af, conn, "ISAKMP-peer", peer, 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

  /* Set the sequence number. */
  snprintf (lname, sizeof lname, "%u", msg->sadb_msg_seq);
  if (conf_set (af, conn, "Acquire-ID", lname, 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

  /* Set Phase 2 IDs -- this is the Local-ID section. */
  snprintf (lname, sizeof lname, "Phase2-ID:%s/%s/%u/%u", ssflow, ssmask,
	    tproto, sport);
  if (conf_set (af, conn, "Local-ID", lname, 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

  if (!conf_get_str (lname, "ID-type"))
    {
      if (conf_set (af, lname, "Refcount", "1", 0, 0))
	{
	  conf_end (af, 0);
	  goto fail;
d3491 35
d3527 6
a3532 57
      if (shostflag)
        {
	  if (conf_set (af, lname, "ID-type", sidtype, 0, 0)
	      || conf_set (af, lname, "Address", ssflow, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }
	}
      else
        {
	  if (conf_set (af, lname, "ID-type", sidtype, 0, 0)
	      || conf_set (af, lname, "Network", ssflow, 0, 0)
	      || conf_set (af, lname, "Netmask", ssmask, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }
	}
      if (tproto)
        {
	  snprintf (tmbuf, sizeof sport * 3 + 1, "%u", tproto);
	  if (conf_set (af, lname, "Protocol", tmbuf, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }

	  if (sport)
	    {
	      snprintf (tmbuf, sizeof sport * 3 + 1, "%u", ntohs (sport));
	      if (conf_set (af, lname, "Port", tmbuf, 0, 0))
	        {
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	}
    }
  else
    pf_key_v2_conf_refinc (af, lname);

  /* Set Remote-ID section. */
  snprintf (dname, sizeof dname, "Phase2-ID:%s/%s/%u/%u", sdflow, sdmask,
	    tproto, dport);
  if (conf_set (af, conn, "Remote-ID", dname, 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

  if (!conf_get_str (dname, "ID-type"))
    {
      if (conf_set (af, dname, "Refcount", "1", 0, 0))
	{
	  conf_end (af, 0);
	  goto fail;
d3534 19
d3554 16
a3569 92
      if (dhostflag)
        {
	  if (conf_set (af, dname, "ID-type", didtype, 0, 0)
	      || conf_set (af, dname, "Address", sdflow, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }
	}
      else
        {
	  if (conf_set (af, dname, "ID-type", didtype, 0, 0)
	      || conf_set (af, dname, "Network", sdflow, 0, 0)
	      || conf_set (af, dname, "Netmask", sdmask, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }
	}

      if (tproto)
        {
	  snprintf (tmbuf, sizeof dport * 3 + 1, "%u", tproto);
	  if (conf_set (af, dname, "Protocol", tmbuf, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }

	  if (dport)
	    {
	      snprintf (tmbuf, sizeof dport * 3 + 1, "%u", ntohs (dport));
	      if (conf_set (af, dname, "Port", tmbuf, 0, 0))
	        {
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	}
    }
  else
    pf_key_v2_conf_refinc (af, dname);

  /*
   * XXX
   * We should be using information from the proposal to set this up.
   * At least, we should make this selectable.
   */

  /* Phase 2 configuration. */
  if (conf_set (af, conn, "Configuration", configname, 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

  if (conf_set (af, configname, "Exchange_type", "Quick_mode", 0, 0)
      || conf_set (af, configname, "DOI", "IPSEC", 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

  if (conf_get_str ("General", "Default-phase-2-suites"))
    {
      if (conf_set (af, configname, "Suites",
		    conf_get_str ("General", "Default-phase-2-suites"), 0, 0))
        {
	  conf_end (af, 0);
	  goto fail;
	}
    }
  else
    {
      if (conf_set (af, configname, "Suites",
		    "QM-ESP-3DES-SHA-PFS-SUITE", 0, 0))
        {
	  conf_end (af, 0);
	  goto fail;
	}
    }

  /* Set the ISAKMP-peer section. */
  if (!conf_get_str (peer, "Phase"))
    {
      if (conf_set (af, peer, "Phase", "1", 0, 0)
	  || conf_set (af, peer, "Refcount", "1", 0, 0)
	  || conf_set (af, peer, "Address", dstbuf, 0, 0))
        {
	  conf_end (af, 0);
	  goto fail;
        }
d3571 15
a3585 4
      if (srcaddr && conf_set (af, peer, "Local-address", srcbuf, 0, 0))
	{
	  conf_end (af, 0);
	  goto fail;
d3587 12
a3598 6

      snprintf (confname, sizeof confname, "ISAKMP-Configuration-%s", peer);
      if (conf_set (af, peer, "Configuration", confname, 0, 0))
        {
	  conf_end (af, 0);
	  goto fail;
d3601 17
d3619 58
a3676 67
      /* Store any credentials passed to us. */
      if (cred)
	{
	  struct cert_handler *handler = 0;
	  void *cert;
	  char num[12], *certprint;

	  /* Convert to bytes in-place. */
	  cred->sadb_x_cred_len *= PF_KEY_V2_CHUNK;

	  if (cred->sadb_x_cred_len <= sizeof *cred)
	    {
	      log_print ("pf_key_v2_acquire: zero-length credentials, "
			 "aborting SA acquisition");
	      conf_end (af, 0);
	      goto fail;
	    }

	  switch (cred->sadb_x_cred_type)
	    {
	    case SADB_X_CREDTYPE_X509:
	      snprintf (num, sizeof num, "%d", ISAKMP_CERTENC_X509_SIG);
	      handler = cert_get (ISAKMP_CERTENC_X509_SIG);
	      break;
	    case SADB_X_CREDTYPE_KEYNOTE:
	      snprintf (num, sizeof num, "%d", ISAKMP_CERTENC_KEYNOTE);
	      handler = cert_get (ISAKMP_CERTENC_KEYNOTE);
	      break;
	    default:
	      log_print ("pf_key_v2_acquire: unknown credential type %d",
			 cred->sadb_x_cred_type);
	      conf_end (af, 0);
	      goto fail;
	    }

	  if (!handler)
	    {
	      log_print ("pf_key_v2_acquire: cert_get (%s) failed", num);
	      conf_end (af, 0);
	      goto fail;
	    }

	  /* Set the credential type as a number. */
	  if (conf_set (af, peer, "Credential_type", num, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }

	  /* Get the certificate. */
	  cert = handler->cert_get ((u_int8_t *)(cred + 1),
				    cred->sadb_x_cred_len - sizeof *cred);

	  /* Now convert to printable format. */
	  certprint = handler->cert_printable (cert);
	  handler->cert_free (cert);
	  if (!certprint
	      || conf_set (af, peer, "Credentials", certprint, 0, 0))
	    {
	      if (certprint)
		free (certprint);
	      conf_end (af, 0);
	      goto fail;
	    }
	  free (certprint);
	}
#endif /* SADB_X_CREDTYPE_NONE */
d3678 2
a3679 3
      /* Phase 1 configuration. */
      if (!conf_get_str (confname, "exchange_type"))
        {
d3681 122
a3802 114
	  /* We may have been provided with authentication material. */
	  if (sauth)
	    {
	      char *authm;

	      /* Convert to bytes in-place. */
	      sauth->sadb_x_cred_len *= PF_KEY_V2_CHUNK;

	      switch (sauth->sadb_x_cred_type)
		{
		case SADB_X_AUTHTYPE_PASSPHRASE:
		  if (conf_set (af, confname, "Transforms", "3DES-SHA", 0, 0))
		    {
		      conf_end (af, 0);
		      goto fail;
		    }

		  if (sauth->sadb_x_cred_len <= sizeof *sauth)
		    {
		      log_print ("pf_key_v2_acquire: zero-length passphrase, "
				 "aborting SA acquisition");
		      conf_end (af, 0);
		      goto fail;
		    }

		  authm = malloc (sauth->sadb_x_cred_len - sizeof *sauth + 1);
		  if (!authm)
		    {
		      log_error ("pf_key_v2_acquire: malloc (%lu) failed",
				 sauth->sadb_x_cred_len -
				 (unsigned long)sizeof *sauth + 1);
		      conf_end (af, 0);
		      goto fail;
		    }
		  memcpy (authm, sauth + 1,
			  sauth->sadb_x_cred_len - sizeof *sauth + 1);

		  /* Set the passphrase in the peer. */
		  if (conf_set (af, peer, "Authentication", authm, 0, 0))
		    {
		      free (authm);
		      conf_end (af, 0);
		      goto fail;
		    }
		  free (authm);
		  break;

		case SADB_X_AUTHTYPE_RSA:
		  if (conf_set (af, confname, "Transforms", "3DES-SHA-RSA_SIG",
				0, 0))
		    {
		      conf_end (af, 0);
		      goto fail;
		    }

		  if (sauth->sadb_x_cred_len <= sizeof *sauth)
		    {
		      log_print ("pf_key_v2_acquire: zero-length RSA key, "
				 "aborting SA acquisition");
		      conf_end (af, 0);
		      goto fail;
		    }

		  authm = key_printable (ISAKMP_KEY_RSA,
					 ISAKMP_KEYTYPE_PRIVATE,
					 (u_int8_t *) sauth + 1,
					 sauth->sadb_x_cred_len
					 - sizeof *sauth);
		  if (!authm)
		    {
		      log_print ("pf_key_v2_acquire: failed to convert "
				 "private key to printable format (size %lu)",
				 sauth->sadb_x_cred_len -
				 (unsigned long)sizeof *sauth);
		      conf_end (af, 0);
		      goto fail;
		    }

		  /*
		   * Set the key in the peer. We don't use "Authentication"
		   * to avoid potential conflicts with file-based
		   * configurations that use public key authentication
		   * but still specify an "Authentication" tag (typically
		   * as a remnant of passphrase-based testing).
		   */
		  if (conf_set (af, peer, "PKAuthentication", authm, 0, 0))
		    {
		      free (authm);
		      conf_end (af, 0);
		      goto fail;
		    }
		  free (authm);
		  break;

		default:
		  log_print ("pf_key_v2_acquire: unknown authentication "
			     "material type %d received from kernel",
			     sauth->sadb_x_cred_type);
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	  else /* Fall through */
#endif /* SADB_X_EXT_LOCAL_AUTH */
	  {
	    xform = conf_get_str ("Default-phase-1-configuration",
				  "Transforms");
	    if (conf_set (af, confname, "Transforms",
			  xform ? xform : "3DES-SHA-RSA_SIG", 0, 0))
	      {
		conf_end (af, 0);
		goto fail;
	      }
	  }
d3804 2
a3805 17
	  if (conf_set (af, confname, "Exchange_Type", "ID_PROT", 0, 0)
	      || conf_set (af, confname, "DOI", "IPSEC", 0, 0)
	      || conf_set (af, confname, "Refcount", "1", 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }
	}
      else
	pf_key_v2_conf_refinc (af, confname);

      /* The ID we should use in Phase 1. */
      if (srcid && conf_set (af, peer, "ID", srcid, 0, 0))
	  {
	    conf_end (af, 0);
	    goto fail;
	  }
d3807 23
a3829 36
      /* The ID the other side should use in Phase 1. */
      if (dstid && conf_set (af, peer, "Remote-ID", dstid, 0, 0))
	{
	  conf_end (af, 0);
	  goto fail;
	}
    }
  else
    pf_key_v2_conf_refinc (af, peer);

  /* All done. */
  conf_end (af, 1);

  /* Let's rock 'n roll. */
  pf_key_v2_connection_check (conn);
  conn = 0;

  /* Fall-through to cleanup. */
 fail:
  if (ret)
    pf_key_v2_msg_free (ret);
  if (askpolicy)
    pf_key_v2_msg_free (askpolicy);
  if (srcid)
    free (srcid);
  if (dstid)
    free (dstid);
  if (peer)
    free (peer);
  if (conn)
    free (conn);
  return;
#else
  /* acquire not supported */
  return;
#endif /* SADB_X_ASKPOLICY */
d3833 1
a3833 1
pf_key_v2_notify (struct pf_key_v2_msg *msg)
d3835 14
a3848 15
  switch (((struct sadb_msg *)TAILQ_FIRST (msg)->seg)->sadb_msg_type)
    {
    case SADB_EXPIRE:
      pf_key_v2_expire (msg);
      break;

    case SADB_ACQUIRE:
      pf_key_v2_acquire (msg);
      break;

    default:
      log_print ("pf_key_v2_notify: unexpected message type (%d)",
		 ((struct sadb_msg *)TAILQ_FIRST (msg)->seg)->sadb_msg_type);
    }
  pf_key_v2_msg_free (msg);
d3852 1
a3852 1
pf_key_v2_handler (int fd)
d3854 1
a3854 1
  struct pf_key_v2_msg *msg;
d3856 1
a3856 1
  int n;
d3858 17
a3874 18
  /*
   * As synchronous read/writes to the socket can have taken place between
   * the select(2) call of the main loop and this handler, we need to recheck
   * the readability.
   */
  if (ioctl (pf_key_v2_socket, FIONREAD, &n) == -1)
    {
      log_error ("pf_key_v2_handler: ioctl (%d, FIONREAD, &n) failed",
		 pf_key_v2_socket);
      return;
    }
  if (!n)
    return;
#endif /* LINUX_IPSEC */

  msg = pf_key_v2_read (0);
  if (msg)
    pf_key_v2_notify (msg);
d3883 2
a3884 2
pf_key_v2_group_spis (struct sa *sa, struct proto *proto1,
		      struct proto *proto2, int incoming)
d3887 8
a3894 8
  struct sadb_msg msg;
  struct sadb_sa sa1, sa2;
  struct sadb_address *addr = 0;
  struct sadb_protocol protocol;
  struct pf_key_v2_msg *grpspis = 0, *ret = 0;
  struct sockaddr *saddr;
  int err;
  size_t len;
d3896 1
a3896 1
  struct sadb_x_sa2 kamesa2;
d3899 8
a3906 9
  msg.sadb_msg_type = SADB_X_GRPSPIS;
  switch (proto1->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      msg.sadb_msg_satype = SADB_SATYPE_ESP;
      break;
    case IPSEC_PROTO_IPSEC_AH:
      msg.sadb_msg_satype = SADB_SATYPE_AH;
      break;
d3908 24
a3931 24
    case IPSEC_PROTO_IPCOMP:
      msg.sadb_msg_satype = SADB_X_SATYPE_IPCOMP;
      break;
#endif
    default:
      log_print ("pf_key_v2_group_spis: invalid proto %d", proto1->proto);
      goto cleanup;
    }
  msg.sadb_msg_seq = 0;
  grpspis = pf_key_v2_msg_new (&msg, 0);
  if (!grpspis)
    goto cleanup;

  /* Setup the SA extensions.  */
  sa1.sadb_sa_exttype = SADB_EXT_SA;
  sa1.sadb_sa_len = sizeof sa1 / PF_KEY_V2_CHUNK;
  memcpy (&sa1.sadb_sa_spi, proto1->spi[incoming], sizeof sa1.sadb_sa_spi);
  sa1.sadb_sa_replay = 0;
  sa1.sadb_sa_state = 0;
  sa1.sadb_sa_auth = 0;
  sa1.sadb_sa_encrypt = 0;
  sa1.sadb_sa_flags = 0;
  if (pf_key_v2_msg_add (grpspis, (struct sadb_ext *)&sa1, 0) == -1)
    goto cleanup;
d3934 10
a3943 10
  sa2.sadb_sa_exttype = SADB_X_EXT_SA2;
  sa2.sadb_sa_len = sizeof sa2 / PF_KEY_V2_CHUNK;
  memcpy (&sa2.sadb_sa_spi, proto2->spi[incoming], sizeof sa2.sadb_sa_spi);
  sa2.sadb_sa_replay = 0;
  sa2.sadb_sa_state = 0;
  sa2.sadb_sa_auth = 0;
  sa2.sadb_sa_encrypt = 0;
  sa2.sadb_sa_flags = 0;
  if (pf_key_v2_msg_add (grpspis, (struct sadb_ext *)&sa2, 0) == -1)
    goto cleanup;
d3945 21
a3965 21
  memset (&kamesa2, 0, sizeof kamesa2);
  kamesa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  kamesa2.sadb_x_sa2_len = sizeof kamesa2 / PF_KEY_V2_CHUNK;
  kamesa2.sadb_x_sa2_mode = 0;
  if (pf_key_v2_msg_add (grpspis, (struct sadb_ext *)&kamesa2, 0) == -1)
    goto cleanup;
#endif

  /*
   * Setup the ADDRESS extensions.
   */
  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &saddr);
  else
    sa->transport->vtbl->get_dst (sa->transport, &saddr);
  len = sizeof *addr + PF_KEY_V2_ROUND (sysdep_sa_len (saddr));
  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d3967 2
a3968 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d3970 13
a3982 13
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, saddr, sysdep_sa_len (saddr));
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
  if (pf_key_v2_msg_add (grpspis, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = calloc (1, len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_X_EXT_DST2;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
d3984 2
a3985 2
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
d3987 18
a4004 19
  addr->sadb_address_reserved = 0;
  memcpy (addr + 1, saddr, sysdep_sa_len (saddr));
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
  if (pf_key_v2_msg_add (grpspis, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  /* Setup the PROTOCOL extension.  */
  protocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
  protocol.sadb_protocol_len = sizeof protocol / PF_KEY_V2_CHUNK;
  switch (proto2->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      protocol.sadb_protocol_proto = SADB_SATYPE_ESP;
      break;
    case IPSEC_PROTO_IPSEC_AH:
      protocol.sadb_protocol_proto = SADB_SATYPE_AH;
      break;
d4006 40
a4045 41
    case IPSEC_PROTO_IPCOMP:
      protocol.sadb_protocol_proto = SADB_X_SATYPE_IPCOMP;
      break;
#endif
    default:
      log_print ("pf_key_v2_group_spis: invalid proto %d", proto2->proto);
      goto cleanup;
    }
  protocol.sadb_protocol_reserved2 = 0;
  if (pf_key_v2_msg_add (grpspis, (struct sadb_ext *)&protocol, 0) == -1)
    goto cleanup;

  ret = pf_key_v2_call (grpspis);
  pf_key_v2_msg_free (grpspis);
  grpspis = 0;
  if (!ret)
    goto cleanup;
  err = ((struct sadb_msg *)TAILQ_FIRST (ret)->seg)->sadb_msg_errno;
  if (err)
    {
      log_print ("pf_key_v2_group_spis: GRPSPIS: %s", strerror (err));
      goto cleanup;
    }
  pf_key_v2_msg_free (ret);

  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_group_spis: done"));

  return 0;

 cleanup:
  if (addr)
     free (addr);
  if (grpspis)
    pf_key_v2_msg_free (grpspis);
  if (ret)
    pf_key_v2_msg_free (ret);
  return -1;

#else /* SADB_X_GRPSPIS */
  log_print ("pf_key_v2_group_spis: not supported in pure PF_KEYv2");
  return -1;
@


1.138
log
@Fix for PR2429, from Clemens Wittinger.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.137 2003/11/06 16:12:07 ho Exp $  */
d357 1
a357 1
      if ((size_t)n != hdr.sadb_msg_len * PF_KEY_V2_CHUNK)
d369 2
a370 1
	  || (msg->sadb_msg_pid != 0 && msg->sadb_msg_pid != getpid ()))
d402 2
a403 1
      if (seq && (msg->sadb_msg_pid != getpid () || msg->sadb_msg_seq != seq))
@


1.137
log
@Style nits.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.136 2003/08/08 08:37:36 ho Exp $  */
d1318 19
a1336 16
      len = sizeof *key + PF_KEY_V2_ROUND (hashlen);
      key = malloc (len);
      if (!key)
	goto cleanup;
      key->sadb_key_exttype = SADB_EXT_KEY_AUTH;
      key->sadb_key_len = len / PF_KEY_V2_CHUNK;
      key->sadb_key_bits = hashlen * 8;
      key->sadb_key_reserved = 0;
      memcpy (key + 1,
	      iproto->keymat[incoming]
	      + (proto->proto == IPSEC_PROTO_IPSEC_ESP ? keylen : 0),
	      hashlen);
      if (pf_key_v2_msg_add (update, (struct sadb_ext *)key,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
	goto cleanup;
      key = 0;
@


1.136
log
@Fine grained selectors for Linux native IPsec. From Jean-Francois Dive.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.135 2003/07/25 08:31:16 markus Exp $  */
d964 1
a964 1
#elif defined(SADB_X_AALG_RIPEMD160HMAC)
d966 1
a966 1
#elif defined(SADB_X_AALG_RIPEMD160)
d1033 1
a1033 1
#elif defined(SADB_X_AALG_RIPEMD160HMAC)
d1035 1
a1035 1
#elif defined(SADB_X_AALG_RIPEMD160)
d1150 2
a1151 2
    ssa.sadb_sa_spi = htonl(proto->spi[incoming][0] << 8
			    | proto->spi[incoming][1]);
d1378 1
a1378 1
      memcpy(sid + 1, pp, len);
@


1.135
log
@add sha2 support; ok ho@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.134 2003/07/24 09:59:03 itojun Exp $  */
d2045 3
d2049 1
d2051 3
d2055 1
d2080 3
d2084 1
d2086 3
d2090 1
@


1.134
log
@conform to RFC2367 on SADB_xx naming (local name must be prefixed with
SADB_X_xx)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.133 2003/06/10 16:41:29 deraadt Exp $  */
d974 18
d1040 18
@


1.133
log
@boring cleanups
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.132 2003/06/04 07:31:17 ho Exp $  */
d964 4
d1015 4
@


1.132
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.131 2003/05/18 19:37:46 ho Exp $  */
d2064 1
a2064 1
  	policy->sadb_x_policy_dir = IPSEC_DIR_INBOUND;
d2066 1
a2066 1
  	policy->sadb_x_policy_dir = IPSEC_DIR_OUTBOUND;
d3187 1
a3187 1
	  /* 
@


1.131
log
@More isakmpd privsep work. X509 private keys are now kept in the privileged
process only. Various cleanup and bugfixes.
markus@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.130 2003/05/18 18:16:34 ho Exp $  */
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.130
log
@Sysdep for native Linux IPSec, 2.5 and later. From Thomas Walpuski, with
various tweaks by me. niklas@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.129 2003/05/15 00:28:53 ho Exp $  */
d626 1
a626 1
      monitor_close (pf_key_v2_socket);
@


1.129
log
@Start of privilege separation for isakmpd.
There are some kinks left, so keep it default disabled for now.
markus@@ says ok to commit.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.128 2003/05/14 23:44:48 kjell Exp $  */
d45 4
d50 1
a63 2
#include "sysdep.h"

d830 1
d832 1
d846 1
d848 1
d1095 6
d1102 1
d1693 2
a1694 1
		u_int8_t dstid_type, u_int8_t *dstid, int dstid_len)
d2088 7
a2094 1
    }
d2096 1
d2331 2
a2332 1
			  sidtype, sid, sidlen, didtype, did, didlen);
d2342 1
d2344 1
d2350 1
d2352 1
d2363 1
a2363 1
			      0, 1, 0, 0, 0, 0, 0, 0);
d2373 2
a2374 1
			  sidtype, sid, sidlen, didtype, did, didlen);
d2523 1
a2523 1
			   0, 0, 0, 0, 0, 0);
d2532 1
d2534 1
d2540 1
d2543 1
d2554 1
a2554 1
				  1, 1, 0, 0, 0, 0, 0, 0);
d2564 1
a2564 1
			     src, dst, 1, 1, 0, 0, 0, 0, 0, 0);
d4064 1
d4080 1
@


1.128
log
@properly terminate debug string (levels >=40)
Use "%.*s" as suggested by Niklas.
ok ho@@. Lost by kjell. oked ho@@. lost by kjell again. oked ho@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.127 2003/05/14 17:37:22 ho Exp $  */
d68 1
d537 1
a537 1
  fd = socket (PF_KEY, SOCK_RAW, PF_KEY_V2);
d623 1
a623 1
      close (pf_key_v2_socket);
@


1.127
log
@I did not test this enough. Unbreak.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.126 2003/05/12 21:43:21 ho Exp $  */
d2177 2
a2178 1
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: FQDN %s", res));
d2190 2
a2191 1
      LOG_DBG ((LOG_SYSDEP, 40, "pf_key_v2_convert_id: UFQDN %s", res));
@


1.126
log
@AES -> AES_128_CBC
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.125 2003/05/11 02:16:54 markus Exp $  */
d914 1
a914 1
	case IPSEC_ESP_AES_128_CBC:
@


1.125
log
@fix ID-type for ipv6; ok niklas; report fries
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.124 2003/04/14 10:22:13 ho Exp $  */
d914 2
a915 1
	case IPSEC_ESP_AES:
@


1.124
log
@More snprintf style
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.123 2003/04/14 10:14:16 ho Exp $  */
d2876 1
d3007 2
d3039 4
a3042 1
	shostflag = 1;
d3044 4
a3047 1
	dhostflag = 1;
d3077 1
d3079 4
a3082 1
	shostflag = 1;
d3084 4
a3087 1
	dhostflag = 1;
d3597 1
a3597 1
	  if (conf_set (af, lname, "ID-type", "IPV4_ADDR", 0, 0)
d3606 1
a3606 1
	  if (conf_set (af, lname, "ID-type", "IPV4_ADDR_SUBNET", 0, 0)
d3656 1
a3656 1
	  if (conf_set (af, dname, "ID-type", "IPV4_ADDR", 0, 0)
d3665 1
a3665 1
	  if (conf_set (af, dname, "ID-type", "IPV4_ADDR_SUBNET", 0, 0)
@


1.123
log
@A "%d" is 12 chars, not 10. Use sizeof num instead of '10' in
snprintf. From Theo.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.122 2003/02/24 12:01:04 markus Exp $  */
d468 1
a468 1
      snprintf (header, 80, "pf_key_v2_write: iov[%d]", i);
d2370 1
a2370 1
  snprintf (conn, 22, "%d", num + 1);
d2398 1
a2398 1
	snprintf (conn, 22, "%d", num - 1);
d2883 1
d2889 2
a2890 1
  conn = malloc (22);
d2893 1
a2893 1
      log_error ("pf_key_v2_acquire: malloc (22) failed");
d3489 3
a3491 2
      snprintf (conn, 22, "Connection-%u", connection_seq);
      snprintf (configname, 30, "Config-Phase2-%u", connection_seq);
d3555 1
a3555 1
  snprintf (lname, 100, "%u", msg->sadb_msg_seq);
d3563 2
a3564 2
  snprintf (lname, 100, "Phase2-ID:%s/%s/%u/%u", ssflow, ssmask, tproto,
	    sport);
d3622 2
a3623 2
  snprintf (dname, 100, "Phase2-ID:%s/%s/%u/%u", sdflow, sdmask, tproto,
	    dport);
d3737 1
a3737 1
      snprintf (confname, 120, "ISAKMP-Configuration-%s", peer);
@


1.122
log
@pf_key_v2_flow: typo in debug msg (KAME)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.121 2003/01/09 13:10:34 ho Exp $  */
d3747 1
a3747 1
	  char num[10], *certprint;
d3763 1
a3763 1
	      snprintf (num, 10, "%d", ISAKMP_CERTENC_X509_SIG);
d3767 1
a3767 1
	      snprintf (num, 10, "%d", ISAKMP_CERTENC_KEYNOTE);
@


1.121
log
@Change "Default-Phase-2-Suites" --> "Default-phase-2-suites"
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.120 2002/12/06 20:28:20 ho Exp $  */
d2104 3
a2106 3
	    laddr_str ? laddr_str : "<??\?>", lmask_str ? laddr_str : "<??\?>",
	    raddr_str ? laddr_str : "<??\?>",
	    rmask_str ? laddr_str : "<??\?>"));
@


1.120
log
@Set transform from default. PR#3008
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.119 2002/12/04 18:08:40 ho Exp $  */
d3698 1
a3698 1
  if (conf_get_str ("General", "Default-Phase-2-Suites"))
d3701 1
a3701 1
		    conf_get_str ("General", "Default-Phase-2-Suites"), 0, 0))
@


1.119
log
@bit_ffc(3) returns a -1 location for a full bitset. Problem found by
Olivier Courtay.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.118 2002/12/04 15:06:33 markus Exp $  */
d2882 1
a2882 1
  char tmbuf[sizeof sport * 3 + 1];
d3918 10
a3927 6
	  /* XXX Default transform set should be settable. */
	  if (conf_set (af, confname, "Transforms", "3DES-SHA-RSA_SIG", 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }
@


1.118
log
@allow ACQUIRE with empty EXT_ADDRESS_SRC; PR 2996; ok angelos@@, ho@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.117 2002/09/11 09:50:44 ho Exp $  */
d1662 1
a1662 1
  return n;
@


1.117
log
@signed vs unsigned, some void * arithmetic, from -pedantic. niklas@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.116 2002/08/29 15:15:45 itojun Exp $  */
d3077 10
d3135 10
@


1.116
log
@size_t has to be casted to u_long on printing.
From: Martti Kuparinen <martti.kuparinen@@iki.fi>
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.115 2002/08/23 18:01:33 ho Exp $  */
d879 1
a879 1
  char *pp;
d2162 1
a2162 1
  u_int8_t *res = 0;
a2163 1
  char *addr;
d2197 1
a2197 1
      res = strdup (addrbuf);
d2210 1
a2210 1
      res = strdup (addrbuf);
d2226 1
a2226 1
      res = strdup (addrbuf);
d2241 1
a2241 1
      res = strdup (addrbuf);
d2360 1
a2360 1
  unsigned char conn[22];
d2383 1
a2383 1
  unsigned char conn[22];
d3797 1
a3797 1
	      u_int8_t *authm;
@


1.115
log
@Small cleanup.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.114 2002/08/23 17:11:08 ho Exp $  */
d2043 1
a2043 1
      log_error ("pf_key_v2_flow: calloc %lu failed", len);
@


1.114
log
@Proper format
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.113 2002/07/11 21:23:28 deraadt Exp $  */
d2043 1
a2043 1
      log_error ("pf_key_v2_flow: calloc %d failed", len);
@


1.113
log
@malloc() failure tests; rimshot@@pandora.be
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.112 2002/07/05 11:08:13 ho Exp $  */
d2103 1
a2103 1
  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_flow: src %x %x dst %x %x",
@


1.112
log
@gcc 3.1 nits. Pointed out by David Krause.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.111 2002/06/11 18:50:21 ho Exp $  */
d166 1
a166 1
  if (!node->spi)
@


1.111
log
@set_spi: CPIs are 16 bit.
flow: accept IPComp flows.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.110 2002/06/11 18:28:01 ho Exp $  */
d1902 2
a1903 2
	    laddr_str ? laddr_str : "<???>", lmask_str ? lmask_str : "<???>",
	    raddr_str ? raddr_str : "<???>", rmask_str ? rmask_str : "<???>",
d2104 3
a2106 2
	    laddr_str ? laddr_str : "<???>", lmask_str ? laddr_str : "<???>",
	    raddr_str ? laddr_str : "<???>", rmask_str ? laddr_str : "<???>"));
@


1.110
log
@Don't send KEY extensions for IPCOMP.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.109 2002/06/11 18:04:28 ho Exp $  */
d1094 5
a1098 1
  memcpy (&ssa.sadb_sa_spi, proto->spi[incoming], sizeof ssa.sadb_sa_spi);
d1710 3
@


1.109
log
@Stupid 16-bit CPI numbers.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.108 2002/06/10 20:54:51 ho Exp $  */
d1256 1
a1256 19
  /* Setup the KEY extensions.  */
  len = sizeof *key + PF_KEY_V2_ROUND (hashlen);
  key = malloc (len);
  if (!key)
    goto cleanup;
  key->sadb_key_exttype = SADB_EXT_KEY_AUTH;
  key->sadb_key_len = len / PF_KEY_V2_CHUNK;
  key->sadb_key_bits = hashlen * 8;
  key->sadb_key_reserved = 0;
  memcpy (key + 1,
	  iproto->keymat[incoming]
	  + (proto->proto == IPSEC_PROTO_IPSEC_ESP ? keylen : 0),
	  hashlen);
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)key,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  key = 0;

  if (keylen)
d1258 2
a1259 1
      len = sizeof *key + PF_KEY_V2_ROUND (keylen);
d1263 1
a1263 1
      key->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
d1265 1
a1265 1
      key->sadb_key_bits = keylen * 8;
d1267 4
a1270 1
      memcpy (key + 1, iproto->keymat[incoming], keylen);
d1275 17
@


1.108
log
@CPIs cannot be selected from the same range as SPIs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.107 2002/06/09 08:13:06 todd Exp $  */
d782 4
a785 1
    *(u_int16_t *)spi = (u_int16_t)sa->sadb_sa_spi;
@


1.107
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.106 2002/06/07 06:37:08 ho Exp $  */
d740 10
a749 2
  spirange.sadb_spirange_min = IPSEC_SPI_LOW;
  spirange.sadb_spirange_max = 0xffffffff;
@


1.106
log
@own sadb_protocol struct for EXT_PROTOCOL
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.105 2002/06/07 05:07:33 angelos Exp $  */
d306 1
a306 1
			 (unsigned long)howmany (pf_key_v2_socket + 1, 
d2202 1
a2202 1
					       *(addr + 
d2217 1
a2217 1
		"/%d", pf_key_v2_mask6_to_bits (addr + 
@


1.105
log
@Send a flow type.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.104 2002/06/06 18:35:15 ho Exp $  */
d876 1
a876 1
  struct sadb_protocol flowtype;
d1503 4
a1506 4
  bzero (&flowtype, sizeof flowtype);
  flowtype.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
  flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK;
  flowtype.sadb_protocol_proto = isa->tproto;
d1508 1
a1508 1
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)&flowtype, 0) == -1)
@


1.104
log
@Cleanup / style
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.103 2002/06/06 02:15:27 ho Exp $  */
d1495 1
a1495 1
  flowtype.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
d1499 7
@


1.103
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.102 2002/06/01 07:44:22 deraadt Exp $  */
d143 1
d861 1
d863 4
a866 1
  struct sadb_ident *sid = 0;
d870 2
a872 3
  int keylen, hashlen, err;
  struct pf_key_v2_msg *update = 0, *ret = 0;
  struct ipsec_proto *iproto = proto->data;
a876 5
  
#endif
  size_t len;
#ifdef KAME
  struct sadb_x_sa2 ssa2;
d1493 1
a1493 1
    /* Setup the flow type extension.  */
d1657 1
d1660 1
a1660 1
#ifdef SADB_X_EXT_FLOW_TYPE
d1695 1
a1695 1
#ifdef SADB_X_EXT_FLOW_TYPE
d1764 1
a1764 1
#ifdef SADB_X_SAFLAGS_INGRESS_FLOW
d1768 1
a1768 1
#ifdef SADB_X_SAFLAGS_REPLACEFLOW
d1781 1
a1781 1
#ifndef SADB_X_EXT_FLOW_TYPE
d1793 1
a1793 1
#ifdef SADB_X_EXT_FLOW_TYPE
d1912 1
a1912 1
#ifdef SADB_X_EXT_FLOW_TYPE
d2244 1
a2244 1
#ifndef SADB_X_EXT_FLOW_TYPE
d2252 1
a2252 1
#ifdef SADB_X_EXT_FLOW_TYPE
d2281 1
a2281 1
#ifndef SADB_X_EXT_FLOW_TYPE
d2317 1
a2317 1
#ifdef SADB_X_EXT_FLOW_TYPE
d2327 1
a2327 1
#ifdef SADB_X_ASKPOLICY
d2332 2
a2333 2
    unsigned char conn[22];
    int num;
d2335 2
a2336 2
    if (!section)
      return 0;
d2338 3
a2340 3
    num = conf_get_num (section, "Refcount", 0);
    if (num == 0)
      return 0;
d2342 3
a2344 3
    snprintf (conn, 22, "%d", num + 1);
    conf_set (af, section, "Refcount", conn, 1, 0);
    return 0;
d2355 2
a2356 2
    unsigned char conn[22];
    int num;
d2358 2
a2359 2
    if (!section)
      return 0;
d2361 8
a2368 2
    num = conf_get_num (section, "Refcount", 0);
    if (num == 1)
d2370 2
a2371 2
	conf_remove_section (af, section);
	num--;
a2372 6
    else
      if (num != 0)
        {
	  snprintf (conn, 22, "%d", num - 1);
	  conf_set (af, section, "Refcount", conn, 1, 0);
	}
d2374 1
a2374 1
    return num;
d2381 4
a2384 4
    char *ikepeer, *localid, *remoteid, *configname;
    struct conf_list_node *attr;
    struct conf_list *attrs;
    int af;
d2386 2
a2387 2
    if (!section)
      return 0;
d2389 2
a2390 2
    if (!conf_get_str (section, "Phase"))
      return 0;
d2392 8
a2399 8
    /* Only remove dynamically-established entries. */
    attrs = conf_get_list (section, "Flags");
    if (attrs)
      {
	for (attr = TAILQ_FIRST (&attrs->fields); attr;
	     attr = TAILQ_NEXT (attr, link))
	  if (!strcasecmp (attr->field, "__ondemand"))
	    goto passed;
d2401 2
a2402 2
	conf_free_list (attrs);
      }
d2404 1
a2404 1
    return 0;
d2407 6
a2412 1
    conf_free_list (attrs);
d2414 3
a2416 1
    af = conf_begin ();
d2418 2
a2419 2
    configname = conf_get_str (section, "Configuration");
    conf_remove_section (af, configname);
d2421 1
a2421 3
    /* These are the Phase 2 Local/Remote IDs. */
    localid = conf_get_str (section, "Local-ID");
    pf_key_v2_conf_refhandle (af, localid);
d2423 1
a2423 2
    remoteid = conf_get_str (section, "Remote-ID");
    pf_key_v2_conf_refhandle (af, remoteid);
d2425 5
a2429 1
    ikepeer = conf_get_str (section, "ISAKMP-peer");
d2431 2
a2432 1
    pf_key_v2_conf_refhandle (af, section);
d2434 4
a2437 13
    if (ikepeer)
      {
	remoteid = conf_get_str (ikepeer, "Remote-ID");
	localid = conf_get_str (ikepeer, "ID");
	configname = conf_get_str (ikepeer, "Configuration");

	pf_key_v2_conf_refhandle (af, ikepeer);
	pf_key_v2_conf_refhandle (af, configname);

	/* Phase 1 IDs */
	pf_key_v2_conf_refhandle (af, localid);
	pf_key_v2_conf_refhandle (af, remoteid);
      }
d2439 2
a2440 2
    conf_end (af, 1);
    return 0;
d2450 1
a2450 1
#ifndef SADB_X_EXT_FLOW_TYPE
d2466 1
a2466 1
#ifndef SADB_X_EXT_FLOW_TYPE
d2551 1
a2551 1
#ifdef SADB_X_SATYPE_IPCOMP
d2831 1
a2831 3
#ifndef SADB_X_ASKPOLICY
  return;
#else
d2855 1
a2855 1
#ifdef SADB_X_CREDTYPE_NONE
d2955 1
a2955 1
#ifdef SADB_X_EXT_LOCAL_CREDENTIALS
d2963 1
a2963 1
#ifdef SADB_X_EXT_LOCAL_AUTH
d3115 1
a3115 1
#ifdef SADB_X_IDENTTYPE_CONNECTION
d3278 1
a3278 1
#ifdef SADB_X_IDENTTYPE_CONNECTION
d3693 1
a3693 1
#ifdef SADB_X_CREDTYPE_NONE
d3706 1
a3706 1
	      log_print ("pf_key_v2_set_spi: zero-length credentials, "
d3723 1
a3723 1
	      log_print ("pf_key_v2_set_spi: unknown credential type %d",
d3731 1
a3731 1
	      log_print ("pf_key_v2_set_spi: cert_get (%s) failed", num);
d3765 1
a3765 1
#ifdef SADB_X_EXT_LOCAL_AUTH
d3785 1
a3785 1
		      log_print ("pf_key_v2_set_spi: zero-length passphrase, "
d3794 1
a3794 1
		      log_error ("pf_key_v2_set_spi: malloc (%lu) failed",
d3823 1
a3823 1
		      log_print ("pf_key_v2_set_spi: zero-length RSA key, "
d3836 1
a3836 1
		      log_print ("pf_key_v2_set_spi: failed to convert "
d3927 4
a3930 1
#endif
d3987 1
a3987 1
#ifdef SADB_X_GRPSPIS
d4009 1
a4009 1
#ifdef SADB_X_SATYPE_IPCOMP
d4108 1
a4108 1
#ifdef SADB_X_SATYPE_IPCOMP
d4147 1
a4147 1
#else
@


1.102
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.101 2002/05/31 02:16:55 angelos Exp $  */
d305 2
a306 1
			 (unsigned long)howmany (pf_key_v2_socket + 1, NFDBITS),
d337 1
a337 2
		     "(%lu bytes)",
		     pf_key_v2_socket, n);
d360 1
a360 2
		     "(%lu bytes)",
		     pf_key_v2_socket, (unsigned long)n);
d437 1
a437 1
	cnt * (unsigned long)sizeof *iov);
d481 2
a482 2
      log_error ("pf_key_v2_write: writev (%d, ...) returned prematurely (%lu)",
		 pf_key_v2_socket, (unsigned long)n);
d3797 2
a3798 1
			 sauth->sadb_x_cred_len - (unsigned long)sizeof *sauth + 1);
d3839 3
a3841 2
			 "private key to printable format (size %lu)",
			 sauth->sadb_x_cred_len - (unsigned long)sizeof *sauth);
@


1.101
log
@Look for the authentication info from the kernel in the correct message.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.100 2002/05/28 10:09:46 ho Exp $  */
d304 3
a306 3
	      log_error ("pf_key_v2_read: calloc (%d, %d) failed",
			 howmany (pf_key_v2_socket + 1, NFDBITS),
			 sizeof (fd_mask));
d336 1
a336 1
		     "(%d bytes)",
d345 1
a345 1
	  log_error ("pf_key_v2_read: malloc (%d) failed", n);
d360 2
a361 2
		     "(%d bytes)",
		     pf_key_v2_socket, n);
d437 2
a438 1
      log_error ("pf_key_v2_write: malloc (%d) failed", cnt * sizeof *iov);
d482 2
a483 2
      log_error ("pf_key_v2_write: writev (%d, ...) returned prematurely (%d)",
		 pf_key_v2_socket, n);
d3797 2
a3798 2
		      log_error ("pf_key_v2_set_spi: malloc (%d) failed",
				 sauth->sadb_x_cred_len - sizeof *sauth + 1);
d3839 2
a3840 2
				 "private key to printable format (size %d)",
				 sauth->sadb_x_cred_len - sizeof *sauth);
@


1.100
log
@Proper types in format strings. From <greg@@nest.cx>
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.99 2002/05/27 04:21:38 deraadt Exp $  */
d801 45
d870 1
d872 2
d1493 68
a1640 45
static void
pf_key_v2_setup_sockaddr (void *res, struct sockaddr *src,
			  struct sockaddr *dst, in_port_t port, int ingress)
{
  struct sockaddr_in *ip4_sa;
  struct sockaddr_in6 *ip6_sa;
  u_int8_t *p;

  switch (src->sa_family)
    {
    case AF_INET:
      ip4_sa = (struct sockaddr_in *)res;
      ip4_sa->sin_family = AF_INET;
      ip4_sa->sin_len = sizeof *ip4_sa;
      ip4_sa->sin_port = port;
      if (dst)
	p = (u_int8_t *)(ingress
			 ? &((struct sockaddr_in *)src)->sin_addr.s_addr
			 : &((struct sockaddr_in *)dst)->sin_addr.s_addr);
      else
	p = (u_int8_t *)&((struct sockaddr_in *)src)->sin_addr.s_addr;
      ip4_sa->sin_addr.s_addr = *((in_addr_t *)p);
      break;

    case AF_INET6:
      ip6_sa = (struct sockaddr_in6 *)res;
      ip6_sa->sin6_family = AF_INET6;
      ip6_sa->sin6_len = sizeof *ip6_sa;
      ip6_sa->sin6_port = port;
      if (dst)
	p = (u_int8_t *)(ingress
			 ? &((struct sockaddr_in6 *)src)->sin6_addr.s6_addr
			 : &((struct sockaddr_in6 *)dst)->sin6_addr.s6_addr);
      else
	p = (u_int8_t *)&((struct sockaddr_in6 *)src)->sin6_addr.s6_addr;
      memcpy (ip6_sa->sin6_addr.s6_addr, p, sizeof (struct in6_addr));
      break;

    default:
      log_print ("pf_key_v2_setup_sockaddr: unknown family %d\n",
		 src->sa_family);
      break;
    }
}

d2233 1
a2233 1
/* Enable a flow given a SA.  */
d2958 5
a2962 3
  cred
    = (struct sadb_x_cred *)pf_key_v2_find_ext (ret,
						SADB_X_EXT_LOCAL_CREDENTIALS);
d2966 5
a2970 2
  sauth = (struct sadb_x_cred *)pf_key_v2_find_ext (ret,
						    SADB_X_EXT_LOCAL_AUTH);
d3767 1
a3767 1
#ifdef SADB_X_CREDTYPE_NONE
d3861 1
a3861 1
		  log_print ("pf_key_v2_set_spi: unknown authentication "
d3869 1
a3869 1
#endif /* SADB_X_CREDTYPE_NONE */
@


1.99
log
@correct pid handling
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.98 2002/05/26 09:24:35 deraadt Exp $  */
d382 1
a382 1
			"bad version (%d) or PID (%ld, mine is %d), ignored",
d3132 1
a3132 1
				 "username from provided ID %d",
d3297 1
a3297 1
				 "username from provided ID %d",
@


1.98
log
@pid_t cleanup
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.97 2002/02/21 20:12:56 angelos Exp $  */
d383 2
a384 2
			msg->sadb_msg_version, (long)msg->sadb_msg_pid,
			getpid ()));
@


1.97
log
@Use dport instead of sport, shifflett@@nps.navy.mil
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.96 2002/02/19 21:11:19 miod Exp $  */
d382 2
a383 2
			"bad version (%d) or PID (%d, mine is %d), ignored",
			msg->sadb_msg_version, msg->sadb_msg_pid,
@


1.96
log
@IPsec is written ``IPsec'', not ``IPSec''.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.95 2002/01/25 13:07:23 ho Exp $  */
d1764 1
a1764 1
  pf_key_v2_setup_sockaddr (addr + 1, raddr, 0, sport, 0);
d1776 1
a1776 1
  pf_key_v2_setup_sockaddr (addr + 1, rmask, 0, sport ? 0xffff : 0, 0);
@


1.95
log
@Typo. <mccreary@@pch.net>
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.94 2002/01/23 18:44:47 ho Exp $  */
d533 1
a533 1
  /* Open the socket we use to speak to IPSec. */
@


1.94
log
@the last few sprintf -> snprintf
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.93 2002/01/23 17:21:16 ho Exp $  */
d985 1
a985 1
#ifdef SADB_X_CALG_LSZ
d987 1
a987 1
	  ssa.sadb_sa_encrypt = SADB_X_CALG_LSZ;
@


1.93
log
@strcat->strlcat, sprintf->snprintf
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.92 2002/01/03 09:19:52 ho Exp $  */
d2122 4
a2125 3
      sprintf (addrbuf + strlen (addrbuf), "/%d",
	       pf_key_v2_mask_to_bits ((u_int32_t)
				       *(addr + sizeof (struct in_addr))));
d2138 3
a2140 2
      sprintf (addrbuf + strlen (addrbuf), "/%d",
	       pf_key_v2_mask6_to_bits (addr + sizeof (struct in6_addr)));
d2774 1
a2774 1
  int slen, af, afamily, masklen;
d3148 3
a3150 2
	  srcid = malloc ((slen ? slen : strlen (pwd->pw_name))
			  + strlen (prefstring) + sizeof "ID:/");
d3153 1
a3153 3
	      log_error ("pf_key_v2_acquire: malloc (%d) failed",
			 slen ? slen : strlen (pwd->pw_name)
			 + strlen (prefstring) + sizeof "ID:/");
d3157 1
a3157 1
	  sprintf (srcid, "ID:%s/", prefstring);
d3159 1
a3159 3
	    strlcat (srcid + sizeof "ID:/" - 1 + strlen (prefstring),
		     (char *)(srcident + 1),
		     slen + strlen (prefstring) + sizeof "ID:/");
d3161 1
a3161 2
	    strlcat (srcid + sizeof "ID:/" - 1 + strlen (prefstring),
		     pwd->pw_name, strlen (prefstring) + sizeof "ID:/");
d3313 3
a3315 2
	  dstid = malloc ((slen ? slen : strlen (pwd->pw_name))
			  + strlen (prefstring) + sizeof "ID:/");
d3318 1
a3318 3
	      log_error ("pf_key_v2_acquire: malloc (%d) failed",
			 slen ? slen : strlen (pwd->pw_name)
			 + strlen (prefstring) + sizeof "ID:/");
d3322 1
a3322 1
	  sprintf (dstid, "ID:%s/", prefstring);
d3324 1
a3324 3
	    strlcat (dstid + sizeof "ID:/" - 1 + strlen (prefstring),
		     (char *)(dstident + 1),
		     slen + strlen (prefstring) + sizeof "ID:/");
d3326 1
a3326 3
	    strlcat (dstid + sizeof "ID:/" - 1 + strlen (prefstring),
		     pwd->pw_name,
		     strlen (prefstring) + sizeof "ID:/");
@


1.92
log
@Typo.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.91 2001/10/26 13:29:26 ho Exp $  */
d467 1
a467 1
      sprintf (header, "pf_key_v2_write: iov[%d]", i);
d2097 1
a2097 1
      strcat (addrbuf, "/32");
d2110 1
a2110 1
      strcat (addrbuf, "/128");
d2269 1
a2269 1
    sprintf (conn, "%d", num + 1);
d2297 1
a2297 1
	  sprintf (conn, "%d", num - 1);
d3082 1
a3082 1
	  sprintf (srcid, "ID:Address/%s", (char *)(srcident + 1));
d3250 1
a3250 1
	  sprintf (dstid, "ID:Address/%s", (char *)(dstident + 1));
d3372 2
a3373 2
      sprintf (conn, "Connection-%u", connection_seq);
      sprintf (configname, "Config-Phase2-%u", connection_seq);
d3401 3
a3403 3
  peer = malloc (strlen (dstbuf) + strlen (srcbuf)
                 + (srcid ? strlen (srcid) : 0)
		 + (dstid ? strlen (dstid) : 0) + sizeof "Peer-/-/");
d3418 3
a3420 3
  sprintf (peer, "Peer-%s%s%s%s%s%s%s", dstbuf, srcaddr ? "/" : "",
	   srcaddr ? srcbuf : "", srcid ? "-" : "", srcid ? srcid : "",
	   dstid ? (srcid ? "/" : "-/") : "", dstid ? dstid : "");
d3437 1
a3437 1
  sprintf (lname, "%u", msg->sadb_msg_seq);
d3445 2
a3446 1
  sprintf (lname, "Phase2-ID:%s/%s/%u/%u", ssflow, ssmask, tproto, sport);
d3482 1
a3482 1
	  sprintf (tmbuf, "%u", tproto);
d3491 1
a3491 1
	      sprintf (tmbuf, "%u", ntohs (sport));
d3504 2
a3505 1
  sprintf (dname, "Phase2-ID:%s/%s/%u/%u", sdflow, sdmask, tproto, dport);
d3542 1
a3542 1
	  sprintf (tmbuf, "%u", tproto);
d3551 1
a3551 1
	      sprintf (tmbuf, "%u", ntohs (dport));
d3619 1
a3619 1
      sprintf (confname, "ISAKMP-Configuration-%s", peer);
d3648 1
a3648 1
	      sprintf (num, "%d", ISAKMP_CERTENC_X509_SIG);
d3652 1
a3652 1
	      sprintf (num, "%d", ISAKMP_CERTENC_KEYNOTE);
@


1.91
log
@Change to use sysdep_sa_len() function.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.90 2001/10/12 15:47:49 ho Exp $  */
d276 1
a276 1
 * messages up untile both the PID and the sequence number match.
@


1.90
log
@SADB_X_IDENTTYPE_CONNECTION appeared after 2.9. niklas@@ ok.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.89 2001/08/27 18:26:16 ho Exp $  */
d164 1
a164 1
  node->dst = malloc (dst->sa_len);
d167 2
a168 2
  memcpy (node->dst, dst, dst->sa_len);
  node->dstlen = dst->sa_len;
d194 2
a195 2
	&& node->dstlen == dst->sa_len
	&& memcmp (node->dst, dst, dst->sa_len) == 0)
d684 1
a684 1
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (src->sa_len);
d695 1
a695 1
  memcpy (addr + 1, src, src->sa_len);
d710 1
a710 1
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (dst->sa_len);
d721 1
a721 1
  memcpy (addr + 1, dst, dst->sa_len);
d778 1
a778 1
  if (!pf_key_v2_register_sa_seq (spi, *sz, proto, dst, dst->sa_len,
d1015 1
a1015 1
				       dst, dst->sa_len)
d1110 1
a1110 1
  len = sizeof *addr + PF_KEY_V2_ROUND (src->sa_len);
d1121 1
a1121 1
  memcpy (addr + 1, src, src->sa_len);
d1136 1
a1136 1
  len = sizeof *addr + PF_KEY_V2_ROUND (dst->sa_len);
d1147 1
a1147 1
  memcpy (addr + 1, dst, dst->sa_len);
d1166 1
a1166 1
      len = sizeof *addr + PF_KEY_V2_ROUND (dst->sa_len);
d1177 1
a1177 1
      memcpy (addr + 1, dst, dst->sa_len);
d1709 1
a1709 1
  len = sizeof *addr + PF_KEY_V2_ROUND (src->sa_len);
d1733 1
a1733 1
  len = sizeof *addr + PF_KEY_V2_ROUND (laddr->sa_len);
d1884 1
a1884 1
  len = sizeof *addr + PF_KEY_V2_ROUND (src->sa_len);
d1911 1
a1911 1
  len = sizeof *addr + PF_KEY_V2_ROUND (raddr->sa_len);
d1940 1
a1940 1
    2 * PF_KEY_V2_ROUND (src->sa_len);
d2520 1
a2520 1
  len = sizeof *addr + PF_KEY_V2_ROUND (saddr->sa_len);
d2531 1
a2531 1
  memcpy (addr + 1, saddr, saddr->sa_len);
d2550 1
a2550 1
  len = sizeof *addr + PF_KEY_V2_ROUND (saddr->sa_len);
d2561 1
a2561 1
  memcpy (addr + 1, saddr, saddr->sa_len);
d3988 1
a3988 1
  len = sizeof *addr + PF_KEY_V2_ROUND (saddr->sa_len);
d3999 1
a3999 1
  memcpy (addr + 1, saddr, saddr->sa_len);
d4016 1
a4016 1
  memcpy (addr + 1, saddr, saddr->sa_len);
@


1.89
log
@Compile on alpha.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.88 2001/08/25 07:42:19 niklas Exp $  */
d3039 1
d3043 1
d3206 1
d3210 1
@


1.88
log
@Casting of lhs, is not what you think it is.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.87 2001/08/24 13:47:21 ho Exp $  */
d773 1
a773 1
    *(u_int16_t *)spi = *(u_int16_t *)sa->sadb_sa_spi;
@


1.87
log
@Initial IPCOMP support.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.86 2001/08/23 16:56:46 markus Exp $  */
d773 1
a773 1
    (u_int16_t)*spi = *(u_int16_t *)sa->sadb_sa_spi;
@


1.86
log
@ignore EEXIST for SPDADD on KAME; ok ho@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.85 2001/08/19 18:24:29 angelos Exp $  */
d266 1
a266 1
pf_key_v2_seq ()
d527 1
a527 1
pf_key_v2_open ()
d586 26
a615 1
  pf_key_v2_msg_free (ret);
d658 5
d765 3
a767 1
  *sz = sizeof sa->sadb_sa_spi;
d771 6
a776 1
  memcpy (spi, &sa->sadb_sa_spi, *sz);
d963 40
d2478 5
a2709 2
   *
   * XXX When anything else than AH and ESP is supported this needs to change.
d2711 21
a2731 3
  sa = ipsec_sa_lookup (dstaddr, ssa->sadb_sa_spi,
			msg->sadb_msg_satype == SADB_SATYPE_ESP
			? IPSEC_PROTO_IPSEC_ESP : IPSEC_PROTO_IPSEC_AH);
d3931 5
d4030 5
@


1.85
log
@Prevent section leak in conf space.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.84 2001/08/14 20:33:02 ho Exp $  */
d1947 5
a1951 1
  if (err)
@


1.84
log
@The same msg length fix for KAME cases.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.83 2001/08/14 20:24:40 ho Exp $  */
a2257 7

    if (pf_key_v2_conf_refhandle (af, section))
      {
	conf_end (af, 1);
	return 0;
      }

d2260 1
d2262 2
d2265 2
d2269 1
a2269 3
    /* These are the Phase 2 Local/Remote IDs. */
    pf_key_v2_conf_refhandle (af, localid);
    pf_key_v2_conf_refhandle (af, remoteid);
d2277 1
a2277 6
	if (pf_key_v2_conf_refhandle (af, ikepeer))
	  {
	    conf_end (af, 1);
	    return 0;
	  }

@


1.83
log
@Proper length for PFKEYv2 messages in IPv4-in-IPv6 / IPv6-in-IPv4 flows.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.82 2001/08/14 19:38:38 ho Exp $  */
d1834 1
@


1.82
log
@Print the correct fields in a debug message. (cut'n'paste bug)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.81 2001/07/29 13:45:28 itojun Exp $  */
d1656 1
@


1.81
log
@-Wunused for KAME case
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.80 2001/07/25 15:29:47 markus Exp $  */
d1725 2
a1726 2
	    laddr_str ? laddr_str : "<???>", lmask_str ? laddr_str : "<???>",
	    raddr_str ? laddr_str : "<???>", rmask_str ? laddr_str : "<???>",
@


1.80
log
@pf_key_v2_flow: sync success and failure messages; ok niklas@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.79 2001/07/25 11:42:06 markus Exp $  */
d131 1
d133 1
d780 1
d782 3
a784 1
  int keylen, hashlen, err, idtype;
d1975 1
d2075 1
@


1.79
log
@do not setup identity extensions for KAME; ok angelos@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.78 2001/07/18 20:48:33 markus Exp $  */
d1752 2
a1753 1
  LOG_DBG ((LOG_MISC, 50, "pf_key_v2_flow: done"));
d1948 2
a1949 1
  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_flow: done"));
@


1.78
log
@use correct length for SADB_X_EXT_POLICY message on KAME
tested on bsd/os; ok ho@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.77 2001/07/02 02:28:35 deraadt Exp $  */
d1151 1
d1226 1
@


1.77
log
@make the alpha happy
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.76 2001/07/01 19:48:44 niklas Exp $  */
d1852 3
a1854 2
  policy_buf = (u_int8_t *)calloc (1, sizeof *policy + sizeof *ipsecrequest +
				   2 * sockaddr_len (src));
d1857 1
a1857 2
      log_error ("pf_key_v2_flow: calloc %d failed", sizeof *policy +
		 sizeof *ipsecrequest + 2 * sockaddr_len (src));
d1863 1
a1863 1
  policy->sadb_x_policy_len = sizeof policy_buf / PF_KEY_V2_CHUNK;
d1873 1
a1873 2
  ipsecrequest->sadb_x_ipsecrequest_len
    = sizeof *ipsecrequest + 2 * sockaddr_len (src);
@


1.76
log
@Style
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.75 2001/07/01 18:33:50 angelos Exp $  */
d131 1
a131 1
static u_int8_t *pf_key_v2_convert_id (u_int8_t *, int, int *, int *);
d1968 1
a1968 1
pf_key_v2_convert_id (u_int8_t *id, int idlen, int *reslen, int *idtype)
d2075 2
a2076 1
  int sidtype = 0, didtype = 0, sidlen = 0, didlen = 0;
@


1.75
log
@Debug information for IDs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.74 2001/07/01 18:27:37 angelos Exp $  */
d192 1
a192 1
	&& node->dstlen == dst->sa_len 
d652 1
a652 1
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (src->sa_len); 
d678 1
a678 1
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (dst->sa_len); 
d845 1
a845 1
#endif	
d1427 1
a1427 1
pf_key_v2_mask_to_bits (u_int32_t mask) 
d1434 1
a1434 1
pf_key_v2_mask6_to_bits (u_int8_t *mask) 
d1442 1
a1442 1
pf_key_v2_setup_sockaddr (void *res, struct sockaddr *src, 
d1457 3
a1459 3
	p = (u_int8_t *)(ingress ? 
			 &((struct sockaddr_in *)src)->sin_addr.s_addr :
			 &((struct sockaddr_in *)dst)->sin_addr.s_addr);
d1471 3
a1473 3
	p = (u_int8_t *)(ingress ? 
			 &((struct sockaddr_in6 *)src)->sin6_addr.s6_addr :
			 &((struct sockaddr_in6 *)dst)->sin6_addr.s6_addr);
d1493 3
a1495 3
		struct sockaddr *raddr,	struct sockaddr *rmask, 
		u_int8_t tproto, u_int16_t sport, u_int16_t dport, 
		u_int8_t *spi, u_int8_t proto, struct sockaddr *dst, 
d1641 1
a1641 1
      pf_key_v2_setup_sockaddr (addr + 1, dst, NULL, 0, 0);
d1655 1
a1655 1
  pf_key_v2_setup_sockaddr (addr + 1, laddr, NULL, sport, 0);
d1667 1
a1667 1
  pf_key_v2_setup_sockaddr (addr + 1, lmask, NULL, sport ? 0xffff : 0, 0);
d1679 1
a1679 1
  pf_key_v2_setup_sockaddr (addr + 1, raddr, NULL, sport, 0);
d1691 1
a1691 1
  pf_key_v2_setup_sockaddr (addr + 1, rmask, NULL, sport ? 0xffff : 0, 0);
d1717 1
a1717 1
	    "pf_key_v2_flow: src %x %x dst %x %x proto %u sport %u dport %u",
d1741 1
a1741 1
	LOG_DBG ((LOG_SYSDEP, 10, "pf_key_v2_flow: %sFLOW: %s", 
d1744 1
a1744 1
	log_print ("pf_key_v2_flow: %sFLOW: %s", delete ? "DEL" : "ADD", 
d1806 1
a1806 1
  pf_key_v2_setup_sockaddr (addr + 1, laddr, NULL, IPSEC_PORT_ANY, 0);
d1811 2
a1812 2
      addr->sadb_address_prefixlen = 
	pf_key_v2_mask_to_bits (ip4_sa->sin_addr.s_addr);
d1816 2
a1817 2
      addr->sadb_address_prefixlen = 
	pf_key_v2_mask6_to_bits (&ip6_sa->sin6_addr.s6_addr[0]);
d1832 1
a1832 1
  pf_key_v2_setup_sockaddr (addr + 1, raddr, NULL, IPSEC_PORT_ANY, 0);
d1837 2
a1838 2
      addr->sadb_address_prefixlen = 
	pf_key_v2_mask_to_bits (ip4_sa->sin_addr.s_addr);
d1842 2
a1843 2
      addr->sadb_address_prefixlen = 
	pf_key_v2_mask6_to_bits (&ip6_sa->sin6_addr.s6_addr[0]);
d1894 1
a1894 1
  pf_key_v2_setup_sockaddr (saddr, src, NULL, 0, 0);
d1904 1
a1904 1
  pf_key_v2_setup_sockaddr (saddr, dst, NULL, 0, 0);
d1919 1
a1919 1
	    laddr_str ? laddr_str : "<???>", lmask_str ? laddr_str : "<???>", 
d2030 4
a2033 4
      sprintf (addrbuf + strlen (addrbuf), "/%d", 
	       pf_key_v2_mask_to_bits ((u_int32_t)*(addr + 
						    sizeof (struct in_addr))));
      *reslen = strlen(addrbuf);
d2045 1
a2045 1
      sprintf (addrbuf + strlen (addrbuf), "/%d", 
d2121 1
a2121 1
      memset (&((struct sockaddr_in *)hostmask)->sin_addr.s_addr, 0xff, 
d2127 1
a2127 1
      memset (&((struct sockaddr_in6 *)hostmask)->sin6_addr.s6_addr, 0xff, 
d2135 2
a2136 2
      error = pf_key_v2_flow (dst, hostmask, src, hostmask, 0, 0, 0, 
			      proto->spi[1], proto->proto, src, dst, 
d2210 1
a2210 1
/* Remove all dynamically-established configuration entries. */
d2315 1
a2315 1
	  memset (&((struct sockaddr_in *)hostmask)->sin_addr.s_addr, 0xff, 
d2320 1
a2320 1
	  ((struct sockaddr_in6 *)hostmask)->sin6_len = 
d2322 1
a2322 1
	  memset (&((struct sockaddr_in6 *)hostmask)->sin6_addr.s6_addr, 0xff, 
d2330 2
a2331 2
          error = pf_key_v2_flow (dst, hostmask, src, hostmask, 0, 0, 0, 
				  proto->spi[1], proto->proto, src, dst, 
d2353 1
a2353 1
  struct sadb_msg msg; 
d2494 1
a2494 1
      LOG_DBG ((LOG_SYSDEP, 10, "pf_key_v2_delete_spi: DELETE: %s", 
d2829 1
a2829 1
    case AF_INET6: 
d2926 1
a2926 1
	  log_print ("pf_key_v2_acquire: source identity not NULL-terminated");
d2966 1
a2966 2
	  slen = strlen ((char *)(srcident + 1)) + strlen ("ID:/")
	    + 1 + strlen ("Address");
d3014 1
a3014 1
		} 
d3038 2
a3039 2
	  srcid = malloc ((slen ? slen : strlen (pwd->pw_name)) +
			  strlen (prefstring) + 1 + strlen ("ID:/"));
d3044 1
a3044 1
			 + strlen (prefstring) + 1 + strlen ("ID:/"));
d3050 1
a3050 1
	    strlcat (srcid + strlen ("ID:/") + strlen (prefstring),
d3052 1
a3052 1
		     slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d3054 2
a3055 3
	    strlcat (srcid + strlen ("ID:/") + strlen (prefstring),
		     pwd->pw_name,
		     strlen (prefstring) + 1 + strlen ("ID:/"));
d3065 1
a3065 1
			       srcid + strlen ("ID:/") + strlen (prefstring),
d3132 1
a3132 2
	  slen = strlen ((char *)(dstident + 1)) + strlen ("ID:/")
	    + 1 + strlen ("Address");
d3177 1
a3177 1
	      if ((slen == 0) && (dstident->sadb_ident_id == 0))
d3181 1
a3181 1
		} 
d3206 1
a3206 1
			  + strlen (prefstring) + 1 + strlen ("ID:/"));
d3211 1
a3211 1
			 + strlen (prefstring) + 1 + strlen ("ID:/"));
d3217 1
a3217 1
	    strlcat (dstid + strlen ("ID:/") + strlen (prefstring),
d3219 1
a3219 1
		     slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d3221 1
a3221 1
	    strlcat (dstid + strlen ("ID:/") + strlen (prefstring),
d3223 1
a3223 1
		     strlen (prefstring) + 1 + strlen ("ID:/"));
d3233 1
a3233 1
			       dstid + strlen ("ID:/") + strlen (prefstring),
d3291 3
a3293 3
  peer = malloc (strlen (dstbuf) + strlen (srcbuf) +
                 (srcid ? strlen (srcid) : 0) +
		 (dstid ? strlen (dstid) : 0) + strlen ("Peer-/-/") + 1);
@


1.74
log
@Return the right length for address IDs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.73 2001/07/01 05:16:03 angelos Exp $  */
d1985 1
d1997 1
d2010 1
d2022 1
d2038 1
d2051 1
@


1.73
log
@Don't try to delete unestablished SPIs.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.72 2001/06/29 19:08:11 ho Exp $  */
d2000 3
a2002 2
		     addrbuf, ADDRESS_MAX) != NULL)
	*reslen = strlen (addrbuf) + 4;
d2012 3
a2014 2
		     addrbuf, ADDRESS_MAX) != NULL)
	*reslen = strlen (addrbuf) + 5;
d2024 2
a2025 2
      if (inet_ntop (AF_INET, addr, addrbuf, ADDRESS_MAX) != NULL)
	*reslen = strlen (addrbuf) + 4;
d2029 1
d2038 2
a2039 2
      if (inet_ntop (AF_INET6, addr, addrbuf, ADDRESS_MAX) != NULL)
	*reslen = strlen (addrbuf) + 5;
d2042 1
@


1.72
log
@Get rid of redundant lengths in get_spi API.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.71 2001/06/29 18:52:17 ho Exp $  */
d2352 4
@


1.71
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.70 2001/06/29 18:05:24 ho Exp $  */
d608 1
a608 1
		   int srclen, struct sockaddr *dst, int dstlen, u_int32_t seq)
@


1.70
log
@Since we have a sockaddr struct, use sa_len directly.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.69 2001/06/29 05:17:57 itojun Exp $  */
d779 1
a779 1
  int srclen, dstlen, keylen, hashlen, err, idtype;
d926 1
a926 1
    sa->transport->vtbl->get_src (sa->transport, &dst, &dstlen);
d928 1
a928 1
    sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
d1025 1
a1025 1
    sa->transport->vtbl->get_dst (sa->transport, &src, &srclen);
d1027 1
a1027 1
    sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
d2063 1
a2063 1
  int dstlen, srclen, error;
d2072 2
a2073 2
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
a2280 1
  int dstlen, srclen;
d2288 2
a2289 2
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
d2347 1
a2347 1
  int saddrlen, len, err;
d2413 1
a2413 1
    sa->transport->vtbl->get_dst (sa->transport, &saddr, &saddrlen);
d2415 1
a2415 1
    sa->transport->vtbl->get_src (sa->transport, &saddr, &saddrlen);
d2443 1
a2443 1
    sa->transport->vtbl->get_src (sa->transport, &saddr, &saddrlen);
d2445 1
a2445 1
    sa->transport->vtbl->get_dst (sa->transport, &saddr, &saddrlen);
d3799 1
a3799 1
  int saddrlen, err;
d3859 1
a3859 1
    sa->transport->vtbl->get_src (sa->transport, &saddr, &saddrlen);
d3861 1
a3861 1
    sa->transport->vtbl->get_dst (sa->transport, &saddr, &saddrlen);
@


1.69
log
@fix compilation on netbsd/kame.  not really  tested
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.68 2001/06/29 04:12:00 ho Exp $  */
d162 1
a162 1
  node->dst = malloc (dstlen);
d165 2
a166 2
  memcpy (node->dst, dst, dstlen);
  node->dstlen = dstlen;
d192 2
a193 1
	&& node->dstlen == dstlen && memcmp (node->dst, dst, dstlen) == 0)
d608 1
a608 2
		   int srclen, struct sockaddr *dst, int dstlen,
		   u_int32_t seq)
d652 1
a652 1
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (srclen); 
d663 1
a663 1
  memcpy (addr + 1, src, srclen);
d678 1
a678 1
  len = sizeof (struct sadb_address) + PF_KEY_V2_ROUND (dstlen); 
d689 1
a689 1
  memcpy (addr + 1, dst, dstlen);
d739 1
a739 1
  if (!pf_key_v2_register_sa_seq (spi, *sz, proto, dst, dstlen,
d933 1
a933 1
				       dst, dstlen)
d1028 1
a1028 1
  len = sizeof *addr + PF_KEY_V2_ROUND (srclen);
d1039 1
a1039 1
  memcpy (addr + 1, src, srclen);
d1054 1
a1054 1
  len = sizeof *addr + PF_KEY_V2_ROUND (dstlen);
d1065 1
a1065 1
  memcpy (addr + 1, dst, dstlen);
d1084 1
a1084 1
      len = sizeof *addr + PF_KEY_V2_ROUND (dstlen);
d1095 1
a1095 1
      memcpy (addr + 1, dst, dstlen);
d2417 1
a2417 1
  len = sizeof *addr + PF_KEY_V2_ROUND (saddrlen);
d2428 1
a2428 1
  memcpy (addr + 1, saddr, saddrlen);
d2447 1
a2447 1
  len = sizeof *addr + PF_KEY_V2_ROUND (saddrlen);
d2458 1
a2458 1
  memcpy (addr + 1, saddr, saddrlen);
d3863 1
a3863 1
  len = sizeof *addr + PF_KEY_V2_ROUND (saddrlen);
d3874 1
a3874 1
  memcpy (addr + 1, saddr, saddrlen);
d3891 1
a3891 1
  memcpy (addr + 1, saddr, saddrlen);
@


1.68
log
@Initial IPv6 support. (niklas@@ ok)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.67 2001/06/27 03:31:43 angelos Exp $  */
d1500 3
a1515 3
#ifdef USE_DEBUG
  char *laddr_str, *lmask_str, *raddr_str, *rmask_str;
#endif
d1778 2
d1812 1
a1812 1
	pf_key_v2_mask_to_bits (ip4_sa->sin_addr.in_addr);
d1817 1
a1817 1
	pf_key_v2_mask6_to_bits (ip6_sa->sin6_addr.in6_addr);
d1838 1
a1838 1
	pf_key_v2_mask_to_bits (ip4_sa->sin_addr.in_addr);
d1843 1
a1843 1
	pf_key_v2_mask6_to_bits (ip6_sa->sin6_addr.in6_addr);
d1898 1
a1898 1
      saddr = (struct sockaddr_in *)saddr + 1;
d1901 1
a1901 1
      saddr = (struct sockaddr_in6 *)saddr + 1;
@


1.67
log
@Consistently use "IPsec" capitalization (jsyn@@nthought.com)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.66 2001/06/27 00:48:21 angelos Exp $  */
d7 1
d57 1
d61 1
d66 1
d72 1
a72 2
#include "cert.h"
#include "key.h"
d653 1
a653 1
  addr = malloc (len);
a655 1
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
d664 9
a672 2
  /* XXX IPv4-specific.  */
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d679 1
a679 1
  addr = malloc (len);
a681 1
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
d690 9
a698 2
  /* XXX IPv4-specific.  */
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d779 1
a779 1
  int dstlen, srclen, keylen, hashlen, err, idtype;
d789 3
a1022 2
   *
   * XXX Addresses have to be thought through.  Assumes IPv4.
d1029 1
a1029 1
  addr = malloc (len);
d1040 9
a1048 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1055 1
a1055 1
  addr = malloc (len);
d1066 9
a1074 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1085 1
a1085 1
      addr = malloc (len);
d1096 9
a1104 1
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1363 4
a1366 1
  /* XXX IPv4 specific.  */
d1368 1
a1368 2
	    msg.sadb_msg_satype,
	    inet_ntoa (((struct sockaddr_in *)dst)->sin_addr),
d1371 4
d1429 55
a1483 1
  return (33 - ffs (~mask + 1)) % 33;
d1492 5
a1496 4
pf_key_v2_flow (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr,
		in_addr_t rmask, u_int8_t tproto, u_int16_t sport,
		u_int16_t dport, u_int8_t *spi, u_int8_t proto,
		in_addr_t dst, in_addr_t src, int delete, int ingress,
d1513 3
a1623 2
   *
   * XXX Addresses have to be thought through.  Assumes IPv4.
d1625 1
a1625 1
  len = sizeof *addr + PF_KEY_V2_ROUND (sizeof (struct sockaddr_in));
d1632 1
a1632 1
      addr = malloc (len);
a1637 4
      memset (addr + 1, '\0', sizeof (struct sockaddr_in));
      ((struct sockaddr_in *)(addr + 1))->sin_len
	= sizeof (struct sockaddr_in);
      ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
d1639 1
a1639 2
      ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr
	= ingress ? src : dst;
d1641 1
a1641 1
      ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = dst;
a1642 1
      ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1649 1
a1649 1
  addr = malloc (len);
d1655 1
a1655 5
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = laddr;
  ((struct sockaddr_in *)(addr + 1))->sin_port = sport;
d1661 1
a1661 1
  addr = malloc (len);
d1667 1
a1667 5
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = lmask;
  ((struct sockaddr_in *)(addr + 1))->sin_port = sport ? 0xffff : 0;
d1673 1
a1673 1
  addr = malloc (len);
d1679 1
a1679 5
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = raddr;
  ((struct sockaddr_in *)(addr + 1))->sin_port = dport;
d1685 1
a1685 1
  addr = malloc (len);
d1691 1
a1691 5
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = rmask;
  ((struct sockaddr_in *)(addr + 1))->sin_port = dport ? 0xffff : 0;
d1706 10
d1718 2
a1719 1
	    ntohl (laddr), ntohl (lmask), ntohl (raddr), ntohl (rmask),
d1722 10
d1773 1
a1773 3
  struct sockaddr_in *saddr;
  u_int8_t
    policy_buf[sizeof *policy + sizeof *ipsecrequest + 2 * sizeof *saddr];
d1775 1
a1794 2
   *
   * XXX Addresses have to be thought through.  Assumes IPv4.
d1796 2
a1797 2
  len = sizeof *addr + PF_KEY_V2_ROUND (sizeof (struct sockaddr_in));
  addr = malloc (len);
a1802 1
  addr->sadb_address_prefixlen = pf_key_v2_mask_to_bits (ntohl (lmask));
d1804 14
a1817 5
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = laddr;
  ((struct sockaddr_in *)(addr + 1))->sin_port = IPSEC_PORT_ANY;
d1823 1
a1823 1
  addr = malloc (len);
a1828 1
  addr->sadb_address_prefixlen = pf_key_v2_mask_to_bits (ntohl (rmask));
d1830 14
a1843 5
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = raddr;
  ((struct sockaddr_in *)(addr + 1))->sin_port = IPSEC_PORT_ANY;
d1850 9
d1872 1
a1872 1
    = sizeof *ipsecrequest + 2 * sizeof *saddr;
d1890 13
a1902 15
  /* Add source and destination addresses.  XXX IPv4 dependent */
  saddr = (struct sockaddr_in *)(ipsecrequest + 1);
  memset (saddr, '\0', sizeof *saddr);
  saddr->sin_len = sizeof (struct sockaddr_in);
  saddr->sin_family = AF_INET;
  saddr->sin_addr.s_addr = src;
  saddr->sin_port = 0;

  saddr++;
  memset (saddr, '\0', sizeof *saddr);
  saddr->sin_len = sizeof (struct sockaddr_in);
  saddr->sin_family = AF_INET;
  saddr->sin_addr.s_addr = dst;
  saddr->sin_port = 0;
  
d1906 10
d1917 12
a1928 1
	    ntohl (laddr), ntohl (lmask), ntohl (raddr), ntohl (rmask)));
d1970 1
d2010 1
a2010 1
	*reslen = strlen (addrbuf) + 4;
d2019 12
d2032 11
d2066 2
a2067 1
  in_addr_t hostmask = 0xffffffff; /* XXX IPv4 specific */
a2094 1
  /* XXX IPv4 specific */
d2097 1
a2097 3
			  proto->spi[0], proto->proto,
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			  ((struct sockaddr_in *)src)->sin_addr.s_addr, 0, 0,
d2103 17
d2123 2
a2124 6
      error = pf_key_v2_flow (((struct sockaddr_in *)dst)->sin_addr.s_addr,
			      hostmask,
			      ((struct sockaddr_in *)src)->sin_addr.s_addr,
			      hostmask, 0, 0, 0, proto->spi[1], proto->proto,
			      ((struct sockaddr_in *)src)->sin_addr.s_addr,
			      ((struct sockaddr_in *)dst)->sin_addr.s_addr,
d2134 1
a2134 3
			  proto->spi[1], proto->proto,
			  ((struct sockaddr_in *)src)->sin_addr.s_addr,
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1,
d2282 2
a2283 1
  in_addr_t hostmask = 0xffffffff; /* XXX IPv4 specific */
d2293 1
a2293 3
			   proto->spi[0], proto->proto,
			   ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			   ((struct sockaddr_in *)src)->sin_addr.s_addr, 1, 0,
d2298 18
d2319 2
a2320 7
          error = pf_key_v2_flow (((struct sockaddr_in *)dst)->sin_addr.s_addr,
				  hostmask,
				  ((struct sockaddr_in *)src)->sin_addr.s_addr,
				  hostmask, 0, 0, 0,
				  proto->spi[1], proto->proto,
				  ((struct sockaddr_in *)src)->sin_addr.s_addr,
				  ((struct sockaddr_in *)dst)->sin_addr.s_addr,
d2331 1
a2331 3
			     ((struct sockaddr_in *)src)->sin_addr.s_addr,
			     ((struct sockaddr_in *)dst)->sin_addr.s_addr,
                             1, 1, 0, 0, 0, 0, 0, 0);
a2409 2
   *
   * XXX Addresses have to be thought through.  Assumes IPv4.
d2416 1
a2416 1
  addr = malloc (len);
d2427 9
a2435 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d2446 1
a2446 1
  addr = malloc (len);
d2457 9
a2465 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d2547 1
d2583 5
a2587 1
  /* XXX IPv4 specific.  */
d2590 1
a2590 2
	    : "HARD",
	    inet_ntoa (((struct sockaddr_in *)dstaddr)->sin_addr),
d2593 5
a2606 1
   * XXX IPv4 specific.
d2608 1
a2608 2
  sa = ipsec_sa_lookup (((struct sockaddr_in *)dstaddr)->sin_addr.s_addr,
			ssa->sadb_sa_spi,
a3855 2
   *
   * XXX Addresses have to be thought through.  Assumes IPv4.
d3862 1
a3862 1
  addr = malloc (len);
d3879 1
a3879 1
  addr = malloc (len);
@


1.66
log
@Keep track of the ACQUIRE sequence number, and pass it to the kernel
along with the ADD message.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.65 2001/06/07 07:50:29 angelos Exp $  */
d527 1
a527 1
  /* Open the socket we use to speak to IPSec.  */
d2151 1
a2151 1
 * Delete the IPSec SA represented by the INCOMING direction in protocol PROTO
d3577 1
a3577 1
 * Group 2 IPSec SAs given by the PROTO1 and PROTO2 protocols of the SA IKE
@


1.65
log
@Actually, using ACQUIRE can cause lowering of security policy level
for outgoing policies -- so, just use USE on the remote.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.64 2001/06/07 07:45:18 angelos Exp $  */
d918 1
a918 1
  msg.sadb_msg_seq = 0;
@


1.64
log
@Ingress flows should be ACQUIRE, not REQUIRE.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.63 2001/06/05 21:43:46 ho Exp $  */
d1491 1
a1491 1
    = ingress ? SADB_X_FLOW_TYPE_ACQUIRE: SADB_X_FLOW_TYPE_REQUIRE;
@


1.63
log
@PF_KEY identity extensions are NUL-terminated. Now, also calculate
the length properly.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.62 2001/06/05 10:51:27 angelos Exp $  */
d1490 2
a1491 1
  flowtype.sadb_protocol_proto = SADB_X_FLOW_TYPE_REQUIRE;
d1763 2
a1764 1
  ipsecrequest->sadb_x_ipsecrequest_level = IPSEC_LEVEL_REQUIRE;
d1961 1
a1961 1
  
@


1.62
log
@Correctly initialize remote ID when using prefix.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.61 2001/06/05 10:43:56 angelos Exp $  */
d1119 1
a1119 1
      sid = calloc (PF_KEY_V2_ROUND (len) + sizeof *sid, sizeof (u_int8_t));
d1128 1
a1128 1
			    + PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
d1156 1
a1156 1
      sid = calloc (PF_KEY_V2_ROUND (len) + sizeof *sid, sizeof (u_int8_t));
d1165 1
a1165 1
			    + PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
d1448 1
a1448 1
	    + PF_KEY_V2_ROUND (srcid_len) / PF_KEY_V2_CHUNK;
d1470 1
a1470 1
	    + PF_KEY_V2_ROUND (dstid_len) / PF_KEY_V2_CHUNK;
@


1.61
log
@Oops, typo.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.60 2001/06/05 10:43:05 angelos Exp $  */
d2924 1
a2924 1
	  if (!conf_get_str (srcid, "ID-type"))
d2926 1
a2926 1
	      if (conf_set (af, srcid, "ID-type",
d2929 2
a2930 2
		  || conf_set (af, srcid, "Refcount", "1", 1, 0)
		  || conf_set (af, srcid, "Address", (char *)(dstident + 1),
@


1.60
log
@Use pf_key_v2_convert_id() instead of repeating code for the IDs;
log_error() cleanup.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.59 2001/06/05 07:59:33 angelos Exp $  */
d3386 1
a3386 1
		      log_[rint ("pf_key_v2_set_spi: zero-length passphrase, "
@


1.59
log
@SADB_IDENTTYPE_PREFIX support (only for fully-specified hosts), plus
punctuation. niklas@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.58 2001/06/05 01:29:05 angelos Exp $  */
d128 1
d763 2
a764 1
  int dstlen, srclen, keylen, hashlen, err;
a766 1
  char addrbuf[ADDRESS_MAX + 5];
d1114 7
a1120 1
      switch (isakmp_sa->id_i[0])
d1122 1
a1122 36
	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  len = isakmp_sa->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1;
	  break;

	case IPSEC_ID_IPV4_ADDR:
	  if (inet_ntop (AF_INET,
			 isakmp_sa->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 addrbuf, ADDRESS_MAX) != NULL)
	    len = strlen (addrbuf) + 4;
	  else
	    goto nosid;
	  break;

	case IPSEC_ID_IPV6_ADDR:
	  if (inet_ntop (AF_INET6,
			 isakmp_sa->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 addrbuf, ADDRESS_MAX) != NULL)
	    len = strlen (addrbuf) + 5;
	  else
	    goto nosid;
	  break;

	case IPSEC_ID_KEY_ID:
	case IPSEC_ID_DER_ASN1_DN:
	  /* XXX FQDN ? */
	  goto nosid;

	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
	default:
	  /* These cannot appear as valid Phase 1 IDs. */
	  log_error ("pf_key_v2_acquire: invalid Phase 1 Initiator ID type %d",
		     isakmp_sa->id_i[0]);
d1126 1
a1126 4
      sid = calloc (PF_KEY_V2_ROUND (len) + sizeof *sid, sizeof (u_int8_t));
      if (!sid)
	goto cleanup;

d1135 2
a1136 34
      switch (isakmp_sa->id_i[0])
        {
	case IPSEC_ID_FQDN:
	  memcpy (sid + 1,
		  isakmp_sa->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  len - 1);
	  sid->sadb_ident_type = SADB_IDENTTYPE_FQDN;
	  break;

	case IPSEC_ID_USER_FQDN:
	  memcpy (sid + 1,
		  isakmp_sa->id_i + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  len - 1);
	  sid->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
	  break;

	case IPSEC_ID_IPV4_ADDR:
	  sid->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	  strcat (addrbuf, "/32");
	  memcpy (sid + 1, addrbuf, strlen (addrbuf));
	  break;

	case IPSEC_ID_IPV6_ADDR:
	  sid->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	  strcat (addrbuf, "/128");
	  memcpy (sid + 1, addrbuf, strlen (addrbuf));
	  break;

	case IPSEC_ID_KEY_ID:
	case IPSEC_ID_DER_ASN1_DN:
	  /* XXX FQDN ? */
	default: /* This shouldn't really happen. */
	  goto nosid;
	}
d1151 7
a1157 1
      switch (isakmp_sa->id_r[0])
d1159 1
a1159 36
	case IPSEC_ID_FQDN:
	case IPSEC_ID_USER_FQDN:
	  len = isakmp_sa->id_r_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1;
	  break;

	case IPSEC_ID_IPV4_ADDR:
	  if (inet_ntop (AF_INET,
			 isakmp_sa->id_r + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 addrbuf, ADDRESS_MAX) != NULL)
	    len = strlen (addrbuf) + 4;
	  else
	    goto nodid;
	  break;

	case IPSEC_ID_IPV6_ADDR:
	  if (inet_ntop (AF_INET6,
			 isakmp_sa->id_r + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
			 addrbuf, ADDRESS_MAX) != NULL)
	    len = strlen (addrbuf) + 5;
	  else
	    goto nodid;
	  break;

	case IPSEC_ID_KEY_ID:
	case IPSEC_ID_DER_ASN1_DN:
	  /* XXX FQDN ? */
	  goto nodid;

	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
	default:
	  /* These cannot appear as valid Phase 1 IDs. */
	  log_error ("pf_key_v2_acquire: invalid Phase 1 Responder ID type %d",
		     isakmp_sa->id_r[0]);
d1163 1
a1163 4
      sid = calloc (PF_KEY_V2_ROUND (len) + sizeof *sid, sizeof (u_int8_t));
      if (!sid)
	goto cleanup;

d1172 2
a1173 34
      switch (isakmp_sa->id_r[0])
        {
	case IPSEC_ID_FQDN:
	  memcpy (sid + 1,
		  isakmp_sa->id_r + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  len - 1);
	  sid->sadb_ident_type = SADB_IDENTTYPE_FQDN;
	  break;

	case IPSEC_ID_USER_FQDN:
	  memcpy (sid + 1,
		  isakmp_sa->id_r + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ,
		  len - 1);
	  sid->sadb_ident_type = SADB_IDENTTYPE_USERFQDN;
	  break;

	case IPSEC_ID_IPV4_ADDR:
	  sid->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	  strcat (addrbuf, "/32");
	  memcpy (sid + 1, addrbuf, strlen (addrbuf));
	  break;

	case IPSEC_ID_IPV6_ADDR:
	  sid->sadb_ident_type = SADB_IDENTTYPE_PREFIX;
	  strcat (addrbuf, "/128");
	  memcpy (sid + 1, addrbuf, strlen (addrbuf));
	  break;

	case IPSEC_ID_KEY_ID:
	case IPSEC_ID_DER_ASN1_DN:
	  /* XXX FQDN ? */
	default: /* This shouldn't really happen. */
	  goto nodid;
	}
d1308 1
a1308 1
	  log_error ("pf_key_v2_set_spi: unknown received key type %d",
d1816 1
a1816 1
  log_error ("pf_key_v2_flow: not supported in pure PF_KEYv2");
a1820 1
#ifdef SADB_X_EXT_FLOW_TYPE
d1825 1
d1851 24
a1874 1
    case IPSEC_ID_IPV4_ADDR:
a1875 2
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR:
a1876 1
    case IPSEC_ID_IPV6_ADDR_SUBNET:
a1885 1
#endif /* SADB_X_EXT_FLOW_TYPE */
d2577 1
a2577 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2584 1
a2584 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2591 1
a2591 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2597 1
a2597 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2610 1
a2610 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2617 1
a2617 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2624 1
a2624 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2630 1
a2630 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2650 1
a2650 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2661 1
a2661 1
	  log_error ("pf_key_v2_acquire: inet_ntop failed");
d2679 1
a2679 1
	      log_error ("pf_key_v2_acquire: inet_ntop failed");
d2689 1
a2689 1
	      log_error ("pf_key_v2_acquire: inet_ntop failed");
d2703 1
a2703 1
	  log_error ("pf_key_v2_acquire: source identity not NULL-terminated");
d2725 1
a2725 1
	      log_error ("pf_key_v2_acquire: badly formatted PREFIX identity");
d2735 1
a2735 1
	      log_error ("pf_key_v2_acquire: non-host address specified in "
d2790 1
a2790 1
		  log_error ("pf_key_v2_acquire: no user FQDN or ID provided");
d2808 1
a2808 1
			log_error ("pf_key_v2_acquire: provided user name and "
d2892 1
a2892 1
	      log_error ("pf_key_v2_acquire: badly formatted PREFIX identity");
d2902 1
a2902 1
	      log_error ("pf_key_v2_acquire: non-host address specified in "
d2959 1
a2959 1
		  log_error ("pf_key_v2_acquire: no user FQDN or ID provided");
d2977 1
a2977 1
			log_error ("pf_key_v2_acquire: provided user name and "
d3307 1
a3307 1
	      log_error ("pf_key_v2_set_spi: zero-length credentials, "
d3324 1
a3324 1
	      log_error ("pf_key_v2_set_spi: unknown credential type %d",
d3332 1
a3332 1
	      log_error ("pf_key_v2_set_spi: cert_get (%s) failed", num);
d3386 1
a3386 1
		      log_error ("pf_key_v2_set_spi: zero-length passphrase, "
d3423 1
a3423 1
		      log_error ("pf_key_v2_set_spi: zero-length RSA key, "
d3436 1
a3436 1
		      log_error ("pf_key_v2_set_spi: failed to convert "
d3460 1
a3460 1
		  log_error ("pf_key_v2_set_spi: unknown authentication "
d3736 1
a3736 1
  log_error ("pf_key_v2_group_spis: not supported in pure PF_KEYv2");
@


1.58
log
@Dynamically allocate conn, as this is given to the exchange; cleanup
conf space on failure to establish dynamic SA. ok niklas@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.57 2001/06/05 01:03:40 itojun Exp $  */
d107 1
a107 1
/* Used to derive "unique" connection identifiers */
d632 1
a632 1
  /* Set the sequence number from the ACQUIRE message */
d765 1
d950 1
a950 1
      /* setup the hard limits.  */
d1110 1
a1110 1
  /* Setup identity extensions */
d1113 40
a1152 1
      len = isakmp_sa->id_i_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1;
d1160 2
a1161 1
      if (isakmp_sa->initiator)
d1183 5
d1189 5
a1193 6
	    /* XXX CONNECTION/PREFIX ? */
	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
	    /* XXX PREFIX */
d1196 2
a1197 2
	    /* XXX FQDN ? */
	default:
d1209 1
d1214 40
a1253 1
      len = isakmp_sa->id_r_len - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ + 1;
d1261 2
a1262 1
      if (isakmp_sa->initiator)
d1284 5
d1290 5
a1294 6
	    /* XXX CONNECTION/PREFIX */
	case IPSEC_ID_IPV4_RANGE:
	case IPSEC_ID_IPV4_ADDR_SUBNET:
	case IPSEC_ID_IPV6_RANGE:
	case IPSEC_ID_IPV6_ADDR_SUBNET:
	    /* XXX PREFIX */
d1297 2
a1298 2
	    /* XXX FQDN ? */
	default:
d1310 1
d1325 1
a1325 1
	  /* Nothing to be done */
d1355 1
a1355 1
	    /* We do it this way to avoid weird includes */
d1390 4
a1393 1
  /* Tell the kernel what the peer used to authenticate, unless passphrase */
d1566 1
a1566 1
      /* Setup the source ID, if provided */
d1588 1
a1588 1
      /* Setup the destination ID, if provided */
d2045 1
a2045 1
  /* Ingress flows, handling SA bundles */
d2129 1
a2129 1
/* Remove all dynamically-established configuration entries */
d2144 1
a2144 1
    /* Only remove dynamically-established entries */
d2177 1
a2177 1
    /* These are the Phase 2 Local/Remote IDs */
d2412 1
a2412 1
  /* XXX What if it is phase 1?  */
d2539 1
a2539 1
#else  
d2551 1
a2551 1
  int slen, af;
d2567 1
a2567 1
  /* This needs to be dynamically allocated */
d2604 1
a2604 1
  /* Ask the kernel for the matching policy */
d2621 1
a2621 1
  /* Now we have all the information needed */
d2804 1
a2804 1
  /* Insert source ID */
d2807 9
a2815 1
      /* Check for valid type */
d2818 4
d2823 57
a2879 1
	  /* XXX Process the address */
a2884 1

a2885 2
	  slen = (srcident->sadb_ident_len * sizeof (u_int64_t))
	    - sizeof (struct sadb_ident);
d2919 1
a2919 1
			goto fail;
d2929 2
a2930 1
			 slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d2945 1
a2945 1
	  /* Set the section if it doesn't already exist */
d2976 1
a2976 1
  /* Insert destination ID */
d2979 4
a2982 1
      /* Check for valid type */
d2985 4
d2990 58
a3047 1
	  /* XXX Process the address */
a3054 2
	  slen = (dstident->sadb_ident_len * sizeof (u_int64_t))
	    - sizeof (struct sadb_ident);
d3088 1
a3088 1
			goto fail;
d3098 2
a3099 1
			 slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d3114 1
a3114 1
	  /* Set the section if it doesn't already exist */
d3145 1
a3145 1
  /* Now we've placed the necessary IDs in the configuration space */
d3147 1
a3147 1
  /* Get a new connection sequence number */
d3214 1
a3214 1
  /* Set the sequence number */
d3222 1
a3222 1
  /* Set Phase 2 IDs -- this is the Local-ID section */
d3280 1
a3280 1
  /* Set Remote-ID section */
d3345 1
a3345 1
  /* Phase 2 configuration */
d3378 1
a3378 1
  /* Set the ISAKMP-peer section */
d3403 1
a3403 1
      /* Store any credentials passed to us */
d3410 1
a3410 1
	  /* Convert to bytes in-place */
d3445 1
a3445 1
	  /* Set the credential type as a number */
d3452 1
a3452 1
	  /* Get the certificate */
d3456 1
a3456 1
	  /* Now convert to printable format */
d3471 1
a3471 1
      /* Phase 1 configuration */
d3475 1
a3475 1
	  /* We may have been provided with authentication material */
d3480 1
a3480 1
	      /* Convert to bytes in-place */
d3511 1
a3511 1
		  /* Set the passphrase in the peer */
d3577 1
a3577 1
	  /* XXX Default transform set should be settable */
d3595 1
a3595 1
      /* The ID we should use in Phase 1 */
d3602 1
a3602 1
      /* The ID the other side should use in Phase 1 */
d3612 1
a3612 1
  /* All done */
d3615 1
a3615 1
  /* Let's rock */
d3619 1
a3619 1
  /* Fall-through to cleanup */
@


1.57
log
@portability; unused function on non-openbsd platform
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.56 2001/06/05 00:17:46 niklas Exp $  */
d2327 1
a2327 1
  if (fail && exchange->name)
d2329 2
a2330 2
      pf_key_v2_remove_conf (exchange->name);
      pf_key_v2_remove_conf (exchange->name);
d2454 1
a2454 1
  char dstbuf[ADDRESS_MAX], srcbuf[ADDRESS_MAX], *peer = 0, conn[22];
d2473 8
d3394 1
d3408 2
@


1.56
log
@Make our pfkeyv2.h more RFC2367 compliant.  Also fix some backwards
compatibility problems in isakmpd, at least 2.8 stable can compile current
isakmpd now.  angelos@@ ok
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.55 2001/05/31 20:30:29 angelos Exp $  */
d137 1
d139 1
d1985 1
d2004 1
@


1.55
log
@If we're passed keys and certs to use, put them in the conf space.

Send back keys/certs the peer has sent us during Phase 1.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.54 2001/05/30 22:06:42 angelos Exp $  */
d763 2
a764 2
#if defined(SADB_CREDTYPE_NONE) || defined(SADB_AUTHTYPE_NONE)
  struct sadb_cred *cred;
d1220 1
a1220 1
#ifdef SADB_CREDTYPE_NONE
d1235 1
a1236 1
#ifdef USE_KEYNOTE
d1239 1
a1239 1
			 sizeof(u_int8_t));
d1243 1
a1243 1
	  cred->sadb_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
d1245 3
a1247 3
	  cred->sadb_cred_exttype = SADB_X_EXT_REMOTE_CREDENTIALS;
	  cred->sadb_cred_type = SADB_CREDTYPE_KEYNOTE;
	  memcpy(cred + 1, isakmp_sa->recv_cert, len);
d1252 1
a1253 1
	  break;
d1255 1
a1256 1
#ifdef USE_X509
d1272 1
a1272 1
			   sizeof(u_int8_t));
d1279 1
a1279 1
	    cred->sadb_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
d1281 3
a1283 3
	    cred->sadb_cred_exttype = SADB_X_EXT_REMOTE_CREDENTIALS;
	    cred->sadb_cred_type = SADB_CREDTYPE_X509;
	    memcpy(cred + 1, data, len);
d1290 1
a1291 1
	  break;
d1294 1
a1294 1
#endif /* SADB_CREDTYPE_NONE */
d1296 1
a1296 1
#ifdef SADB_AUTHTYPE_NONE
d1319 1
a1319 1
      cred = calloc (PF_KEY_V2_ROUND(len) + sizeof *cred, sizeof (u_int8_t));
d1326 1
a1326 1
      cred->sadb_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
d1328 2
a1329 2
      cred->sadb_cred_exttype = SADB_X_EXT_REMOTE_AUTH;
      memcpy(cred + 1, data, len);
d1335 1
a1335 1
	  cred->sadb_cred_type = SADB_AUTHTYPE_RSA;
d1350 1
a1350 1
#endif /* SADB_AUTHTYPE_NONE */
d1444 1
a1444 1
#if !defined (SADB_X_SAFLAGS_INGRESS_FLOW) && !defined(SADB_X_EXT_FLOW_TYPE)
d1521 1
a1521 1
  flowtype.sadb_protocol_proto = FLOW_X_TYPE_REQUIRE;
d1990 1
a1990 1
    if (section == NULL)
d2012 1
a2012 1
    if (section == NULL)
d2033 1
a2033 1
pf_key_v2_remove_conf(char *section)
d2040 1
a2040 1
    if (section == NULL)
d2439 1
a2439 1
#if !defined (SADB_X_ASKPOLICY)
d2444 1
a2444 1
  struct sadb_policy policy;
d2461 1
a2461 1
  struct passwd *pwd = NULL;
d2465 2
a2466 2
#if defined(SADB_CREDTYPE_NONE)
  struct sadb_cred *cred, *sauth;
d2505 3
a2507 3
  policy.sadb_policy_exttype = SADB_X_EXT_POLICY;
  policy.sadb_policy_len = sizeof policy / PF_KEY_V2_CHUNK;
  policy.sadb_policy_seq = msg->sadb_msg_seq;
d2523 1
a2523 1
  sflow = (struct sockaddr *) (((struct sadb_address *)ext->seg) + 1);
d2557 5
a2561 3
#if defined(SADB_CREDTYPE_NONE)
  cred = (struct sadb_cred *)pf_key_v2_find_ext (ret,
						 SADB_X_EXT_LOCAL_CREDENTIALS);
d2563 3
a2565 1
  sauth = (struct sadb_cred *)pf_key_v2_find_ext (ret, SADB_X_EXT_LOCAL_AUTH);
d2734 1
a2734 1
		  if (pwd == NULL)
d2771 1
a2771 1
	  pwd = NULL;
d2840 1
a2840 1
		  if (pwd == NULL)
d2877 1
a2877 1
	  pwd = NULL;
d3167 1
a3167 1
#if defined(SADB_CREDTYPE_NONE)
d3169 1
a3169 1
      if (cred != NULL)
d3171 1
a3171 1
	  struct cert_handler *handler = NULL;
d3176 1
a3176 1
	  cred->sadb_cred_len *= PF_KEY_V2_CHUNK;
d3178 1
a3178 1
	  if (cred->sadb_cred_len <= sizeof *cred)
d3186 1
a3186 1
	  switch (cred->sadb_cred_type)
d3188 1
a3188 1
	    case SADB_CREDTYPE_X509:
d3192 1
a3192 1
	    case SADB_CREDTYPE_KEYNOTE:
d3198 1
a3198 1
			 cred->sadb_cred_type);
d3203 1
a3203 1
	  if (handler == NULL)
d3219 1
a3219 1
				    cred->sadb_cred_len - sizeof *cred);
d3224 2
a3225 2
	  if (certprint == NULL ||
	      conf_set (af, peer, "Credentials", certprint, 0, 0))
d3234 1
a3234 1
#endif /* SADB_CREDTYPE_NONE */
d3239 1
a3239 1
#if defined(SADB_CREDTYPE_NONE)
d3241 1
a3241 1
	  if (sauth != NULL)
d3246 1
a3246 1
	      sauth->sadb_cred_len *= PF_KEY_V2_CHUNK;
d3248 1
a3248 1
	      switch (sauth->sadb_cred_type)
d3250 1
a3250 1
		case SADB_AUTHTYPE_PASSPHRASE:
d3257 1
a3257 1
		  if (sauth->sadb_cred_len <= sizeof *sauth)
d3265 2
a3266 2
		  authm = malloc (sauth->sadb_cred_len - sizeof *sauth + 1);
		  if (authm == NULL)
d3269 1
a3269 1
				 sauth->sadb_cred_len - sizeof *sauth + 1);
d3274 1
a3274 1
			  sauth->sadb_cred_len - sizeof *sauth + 1);
d3286 1
a3286 1
		case SADB_AUTHTYPE_RSA:
d3294 1
a3294 1
		  if (sauth->sadb_cred_len <= sizeof *sauth)
d3305 3
a3307 2
					 sauth->sadb_cred_len - sizeof *sauth);
		  if (authm == NULL)
d3311 1
a3311 1
				 sauth->sadb_cred_len - sizeof *sauth);
d3335 1
a3335 1
			     sauth->sadb_cred_type);
d3341 1
a3341 1
#endif /* SADB_CREDTYPE_NONE */
@


1.54
log
@ifdef out some of the things I inadvertently committed along with the
MBOX->USERFQDN commit earlier.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.53 2001/05/30 18:49:16 angelos Exp $  */
d69 1
d763 1
a763 1
#if 0
d1220 7
a1226 2
#if 0
  /* Setup credentials */
d1236 1
d1252 1
d1284 1
a1293 32

  if (isakmp_sa->sent_cert)
    {
      switch (isakmp_sa->sent_certtype)
	{
	case ISAKMP_CERTENC_NONE:
	  /* Nothing to be done */
	  break;

	case ISAKMP_CERTENC_KEYNOTE:
	  len = strlen (isakmp_sa->sent_cert);
	  cred = calloc (PF_KEY_V2_ROUND (len) + sizeof *cred,
			 sizeof (u_int8_t));
	  if (!cred)
	    goto cleanup;

	  cred->sadb_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
	    PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
	  cred->sadb_cred_exttype = SADB_X_EXT_LOCAL_CREDENTIALS;
	  cred->sadb_cred_type = SADB_CREDTYPE_KEYNOTE;
	  memcpy(cred + 1, isakmp_sa->sent_cert, len);

	  if (pf_key_v2_msg_add (update, (struct sadb_ext *)cred,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;
	  break;

	case ISAKMP_CERTENC_X509_SIG:
	  /* XXX */
	  break;
	}
    }
d1296 2
a1297 2
#if 0
  /* Setup authentication information */
d1300 1
a1300 4
      len = strlen (isakmp_sa->recv_key);
      cred = calloc (PF_KEY_V2_ROUND(len) + sizeof *cred, sizeof (u_int8_t));
      if (!cred)
	goto cleanup;
d1302 11
a1312 4
      cred->sadb_cred_len = ((sizeof *cred) / PF_KEY_V2_CHUNK) +
	PF_KEY_V2_ROUND (len) / PF_KEY_V2_CHUNK;
      cred->sadb_cred_exttype = SADB_X_EXT_REMOTE_AUTH;
      memcpy(cred + 1, isakmp_sa->recv_key, len);
d1314 3
a1316 13
      switch (isakmp_sa->recv_certtype)
	{
	case ISAKMP_CERTENC_NONE:
	  cred->sadb_cred_type = SADB_AUTHTYPE_PASSPHRASE;
	  break;
	case ISAKMP_CERTENC_KEYNOTE:
	case ISAKMP_CERTENC_X509_SIG:
	  cred->sadb_cred_type = SADB_AUTHTYPE_RSA;
	  break;
	}

      if (pf_key_v2_msg_add (update, (struct sadb_ext *)cred,
			     PF_KEY_V2_NODE_MALLOCED) == -1)
a1317 1
    }
a1318 3
  if (isakmp_sa->sent_key)
    {
      len = strlen (isakmp_sa->sent_key);
d1321 4
a1324 1
	goto cleanup;
d1328 3
a1330 2
      cred->sadb_cred_exttype = SADB_X_EXT_LOCAL_AUTH;
      memcpy(cred + 1, isakmp_sa->sent_key, len);
d1332 1
a1332 1
      switch (isakmp_sa->sent_certtype)
d1334 1
a1334 5
	case ISAKMP_CERTENC_NONE:
	  cred->sadb_cred_type = SADB_AUTHTYPE_PASSPHRASE;
	  break;
	case ISAKMP_CERTENC_KEYNOTE:
	case ISAKMP_CERTENC_X509_SIG:
d1337 6
d1349 1
a1351 2
  /* Send authentication information */

d2465 3
d2557 7
d3163 69
a3231 1
      /* XXX Default transform set should be settable */
d3235 109
d3346 1
a3346 3
	      || conf_set (af, confname, "Refcount", "1", 0, 0)
	      || conf_set (af, confname, "Transforms", "3DES-SHA-RSA_SIG", 0,
			   0))
@


1.53
log
@Remove bogus printf
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.52 2001/05/30 16:46:33 angelos Exp $  */
d762 1
a762 1
#ifdef SADB_CREDTYPE_NONE
d1219 1
a1219 1
#ifdef SADB_CREDTYPE_NONE
d1319 1
a1319 1
#ifdef SADB_AUTHTYPE_NONE
@


1.52
log
@MBOX->FQDN, begining of passing some credentials to the kernel.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.51 2001/05/05 00:55:13 angelos Exp $  */
a1217 3

  printf("%p %p %p %p\n",isakmp_sa->recv_cert, isakmp_sa->sent_cert,
	 isakmp_sa->sent_key, isakmp_sa->recv_key);
@


1.51
log
@pf_key_v2_set_spi now sets the Phase 1 IDs on the Phase 2 SAs;
credentials to follow.

Dynamic configuration entries are garbage-collected.

Default-Phase-2-Suites entry in the [General] section may be used to
specify Phase 2 default Suites (overriding the default 3DES-SHA-PFS).
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.50 2001/04/24 07:27:37 niklas Exp $  */
d68 5
d762 3
d1135 1
a1135 1
	  sid->sadb_ident_type = SADB_IDENTTYPE_MBOX;
a1137 1
	case IPSEC_ID_KEY_ID:
d1139 2
a1142 1
	case IPSEC_ID_IPV6_ADDR:
d1146 1
d1191 1
a1191 1
	  sid->sadb_ident_type = SADB_IDENTTYPE_MBOX;
a1193 1
	case IPSEC_ID_KEY_ID:
d1195 2
a1198 1
	case IPSEC_ID_IPV6_ADDR:
d1202 1
d1219 163
a1381 1
  /* XXX Setup credentials */
d1910 1
a1910 1
      *idtype = SADB_IDENTTYPE_MBOX;
d2729 1
a2729 1
	case SADB_IDENTTYPE_MBOX:
d2835 1
a2835 1
	case SADB_IDENTTYPE_MBOX:
@


1.50
log
@Correct SA refcounting.  Fixes a bug where isakmpd could die when a peer was
discovered to have rebooted, and old now invalid SAs had to be garbage-
collected.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.49 2001/04/19 20:12:44 niklas Exp $  */
d129 3
d744 2
a745 1
pf_key_v2_set_spi (struct sa *sa, struct proto *proto, int incoming)
d753 1
d1098 114
a1211 1
  /* XXX Here can identity and sensitivity extensions be setup.  */
d1255 2
d1842 123
d2043 8
d2177 10
d2619 1
d2622 2
a2623 2
	      af = conf_begin ();
	      if (conf_set (af, srcid, "ID-type", prefstring, 0, 0)
d2626 1
a2626 1
			       0, 0))
a2630 2

	      conf_end (af, 1);
d2632 3
a2634 1

d2725 1
d2728 2
a2729 2
	      af = conf_begin ();
	      if (conf_set (af, dstid, "ID-type", prefstring, 0, 0)
d2732 1
a2732 1
			       0, 0))
a2736 2

	      conf_end (af, 1);
d2738 3
a2740 1

d2760 2
a2761 2
      sprintf (conn, "Connection-%d", connection_seq);
      sprintf (configname, "Config-Phase2-%d", connection_seq);
d2775 1
d2810 4
a2813 1
  /* Set the IPsec connection section */
d2816 2
a2817 1
      || conf_set (af, conn, "Flags", "__ondemand", 0 ,0)
d2833 1
a2833 1
  sprintf (lname, "Phase2-ID:%s/%s/%d/%d", ssflow, ssmask, tproto, sport);
d2842 6
d2869 1
a2869 1
	  sprintf (tmbuf, "%d", tproto);
d2878 1
a2878 1
	      sprintf (tmbuf, "%d", ntohs (sport));
d2887 2
d2891 1
a2891 1
  sprintf (dname, "Phase2-ID:%s/%s/%d/%d", sdflow, sdmask, tproto, dport);
d2900 6
d2928 1
a2928 1
	  sprintf (tmbuf, "%d", tproto);
d2937 1
a2937 1
	      sprintf (tmbuf, "%d", ntohs (dport));
d2946 2
d2963 1
a2963 3
      || conf_set (af, configname, "DOI", "IPSEC", 0, 0)
      || conf_set (af, configname, "Suites",
		   "QM-ESP-3DES-SHA-PFS-SUITE", 0, 0))
d2969 19
d2992 1
d3018 1
d3026 2
d3044 1
a3044 3
    {
      /* Phase 1 tag exists, there's nothing more we need to do */
    }
a3050 6

  /*
   * XXX Need to implement cleanup of sections after SAs expire. In
   * particular, we need to expire the IPsec connection section; we
   * could keep the ISAKMP-peer, Local-ID/Remote-ID sections.
   */
@


1.50.2.1
log
@Pull in patch from current:
Errata:
isakmpd will fail to use a certificate with an identity string that is exactly N * 8 bytes long.
Fix (ho):
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.50 2001/04/24 07:27:37 niklas Exp $  */
d1218 1
a1218 1
	    + PF_KEY_V2_ROUND (srcid_len + 1) / PF_KEY_V2_CHUNK;
d1240 1
a1240 1
	    + PF_KEY_V2_ROUND (dstid_len + 1) / PF_KEY_V2_CHUNK;
@


1.50.2.2
log
@Pull in patch from current:
Fix (angelos):
Do not try to delete SAs that have been proposed in Phase 2 but not accepted
(and thus established). This could cause crashes in situations where multiple
proposals are offered.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.73 2001/07/01 05:16:03 angelos Exp $  */
a1789 4

  /* If it's not an established SA, don't proceed. */
  if (!(sa->flags & SA_FLAG_READY))
    return 0;
@


1.49
log
@PF_KEY identity extensions are NUL-terminated.  Do not forget neither to
allocate for the NUL, nor to actually transfer it.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.48 2001/04/09 22:09:52 ho Exp $  */
a2027 7
      /*
       * This SA is still referenced by the software timeout.
       * However, sa_free will clean up all timeouts and
       * decrement reference counters.  We need to reference it
       * so that sa_release() works.
       */
      sa_reference (sa);
@


1.48
log
@More style fixes...
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.47 2001/03/27 21:09:49 ho Exp $  */
d1212 1
a1212 1
	  sid = calloc (PF_KEY_V2_ROUND (srcid_len) + sizeof *sid,
d1234 1
a1234 1
	  sid = calloc (PF_KEY_V2_ROUND (dstid_len) + sizeof *sid,
d1390 1
a1390 1
  tprotocol.sadb_protocol_proto = tproto;;
@


1.47
log
@Fix another memory leak, found by boehm-gc. While not required,
also keep what I think is a cleanup of pf_key_v2_msg_free().
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.46 2001/02/24 03:59:55 angelos Exp $  */
d628 1
a628 1
  memset(&ssa2, 0, sizeof ssa2);
d907 1
a907 1
  memset(&ssa2, 0, sizeof ssa2);
d1455 1
a1455 1
  memset(&ssa2, 0, sizeof ssa2);
d1831 1
a1831 1
  memset(&ssa2, 0, sizeof ssa2);
d2887 1
a2887 1
  memset(&kamesa2, 0, sizeof kamesa2);
@


1.46
log
@For the GETSPI PFKEY message, use the sequence number from the ACQUIRE
message.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.45 2001/01/27 12:03:34 niklas Exp $  */
d232 1
a232 1
  struct pf_key_v2_node *np, *next;
d234 2
a235 1
  for (np = TAILQ_FIRST (msg); np; np = next)
d237 1
a237 1
      next = TAILQ_NEXT (np, link);
d241 1
d1685 1
a1685 1
    return error;
d1699 1
a1699 1
	return error;
d1704 16
a1719 6
  return pf_key_v2_flow (isa->dst_net, isa->dst_mask, isa->src_net,
			 isa->src_mask, isa->tproto, isa->dport, isa->sport,
			 proto->spi[1], proto->proto,
			 ((struct sockaddr_in *)src)->sin_addr.s_addr,
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1,
			 sidtype, sid, sidlen, didtype, did, didlen);
@


1.45
log
@(c) 2001
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.44 2001/01/26 12:12:52 niklas Exp $  */
d590 2
a591 1
		   int srclen, struct sockaddr *dst, int dstlen)
d618 3
a620 5
  /*
   * XXX When we have acquires working, the sequence number has to be set
   * from the acquire message.
   */
  msg.sadb_msg_seq = 0;
a2058 1
  
d2506 1
d2546 8
@


1.44
log
@Pedantic style police
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.43 2001/01/10 21:41:54 angelos Exp $  */
d5 2
a6 2
 * Copyright (c) 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000 Angelos D. Keromytis.  All rights reserved.
@


1.43
log
@Fix comment.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.42 2001/01/05 19:30:37 angelos Exp $  */
d795 3
a797 1
	  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_set_spi: unknown encryption algorithm %d", proto->id));
d832 3
a834 1
	  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_set_spi: unknown authentication algorithm %d", iproto->auth));
d877 3
a879 1
	  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_set_spi: unknown authentication algorithm %d", proto->id));
d1030 1
a1030 1
  /* XXX I am not sure about what to do here just yet. */
d2317 3
a2319 1
		      log_error ("pf_key_v2_acquire: could not acquire username from provided ID %d", srcident->sadb_ident_id);
d2326 3
a2328 1
			log_error ("pf_key_v2_acquire: provided user name and ID do not match (%s != %s)", (char *)(srcident + 1), pwd->pw_name);
d2422 3
a2424 1
		      log_error ("pf_key_v2_acquire: could not acquire username from provided ID %d", dstident->sadb_ident_id);
d2431 3
a2433 1
			log_error ("pf_key_v2_acquire: provided user name and ID do not match (%s != %s)", (char *)(dstident + 1), pwd->pw_name);
@


1.42
log
@Set the correct direction for KAME SPD entries (problem reported and
fix tested by Tim.Ding@@qobra.com)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.41 2000/12/15 06:34:54 provos Exp $  */
d2011 2
a2012 1
      /* This SA is still referenced by the software timeout.
@


1.41
log
@only create new exchange on SA expires, when there has been used.
okay angelos@@
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.40 2000/12/12 01:46:55 niklas Exp $  */
d1502 4
a1505 1
  policy->sadb_x_policy_dir = IPSEC_DIR_OUTBOUND;
@


1.40
log
@Merge with EOM 1.79

author: niklas
whitespace

author: niklas
style

author: angelos
Pass the local/remote Phase 1 ID to the flow, so it can be reused when
an SA is re-negotiated.

author: angelos
Save the Phase 1 IDs along with the flow.

author: angelos
Don't block new phase 1 SA establishment -- avoids some sync problems.

Also, handle kernel-issued expirations more intelligently.

author: angelos
isakmpd can now negotiate transport protocol/ports (either through the
configuration file or through kernel ACQUIREs).

author: angelos
Fix flow cleanup/setup on renegotiation (or failure thereof) -- thanks
to cedric@@wireless-networks.com for testing and feedback.

author: angelos
Remove unused code.

author: angelos
Don't be too permissive with the installed flows -- after all, we can
just run more negotiations.

author: angelos
ifndef, not ifdef

author: angelos
Delete ingress flow correctly.

author: angelos
Initialize structure.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.39 2000/12/02 01:56:04 angelos Exp $  */
d1931 1
a1931 1
  struct sadb_lifetime *life;
d1961 8
d1999 2
a2000 1
   * Also, ignore SAs that were not dynamically established.
d2002 2
a2003 1
  if (!(sa->flags & SA_FLAG_REPLACED) && (sa->flags & SA_FLAG_ONDEMAND))
@


1.39
log
@A bunch of stability fixes, thanks to cedric@@wireless-networks.com for
testing and feedback.
@
text
@d1 2
a2 2
/*      $OpenBSD: pf_key_v2.c,v 1.38 2000/11/27 01:42:58 angelos Exp $  */
/*	$EOM: pf_key_v2.c,v 1.67 2000/11/17 05:10:14 angelos Exp $	*/
d1156 5
a1160 2
		in_addr_t rmask, u_int8_t *spi, u_int8_t proto,
		in_addr_t dst, in_addr_t src, int delete, int ingress)
d1166 1
d1171 1
d1200 47
d1325 1
a1325 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1341 1
a1341 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1357 1
a1357 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1373 1
a1373 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
d1379 13
a1391 2
  LOG_DBG ((LOG_SYSDEP, 50, "pf_key_v2_flow: src %x %x dst %x %x",
	    ntohl (laddr), ntohl (lmask), ntohl (raddr), ntohl (rmask)));
d1416 4
d1581 47
d1630 1
a1630 1
pf_key_v2_enable_sa (struct sa *sa)
d1636 2
d1645 22
d1669 2
a1670 1
			  isa->dst_mask, proto->spi[0], proto->proto,
d1672 2
a1673 1
			  ((struct sockaddr_in *)src)->sin_addr.s_addr, 0, 0);
d1684 1
a1684 1
			      hostmask, proto->spi[1], proto->proto,
d1687 1
a1687 1
			      0, 1);
d1695 2
a1696 1
			 isa->src_mask, proto->spi[1], proto->proto,
d1698 2
a1699 1
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1);
d1720 2
a1721 1
			   isa->dst_mask, proto->spi[0], proto->proto,
d1723 2
a1724 1
			   ((struct sockaddr_in *)src)->sin_addr.s_addr, 1, 0);
d1734 2
a1735 1
				  hostmask, proto->spi[1], proto->proto,
d1738 1
a1738 1
				  1, 1);
d1746 2
a1747 1
			     isa->src_mask, proto->spi[1], proto->proto,
d1750 1
a1750 1
                             1, 1);
d1989 3
a1991 4
   * If we want this connection to stay "forever", we should renegotiate
   * already at the soft expire, and certainly at the hard expire if we
   * haven't started a negotiation by then.  However, do not renegotiate
   * if this SA is already obsoleted by another.
d1993 1
a1993 2
  if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED))
      == SA_FLAG_STAYALIVE)
d2032 1
a2032 1
  char lname[90], dname[90], configname[30];
d2036 3
d2040 1
a2103 1

d2127 1
d2143 1
d2150 1
d2176 1
d2183 1
d2525 1
a2525 1
  sprintf (lname, "Phase2-ID:%s/%s", ssflow, ssmask);
d2553 19
d2575 1
a2575 1
  sprintf (dname, "Phase2-ID:%s/%s", sdflow, sdmask);
d2601 20
@


1.38
log
@ifndef, not ifdef
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.37 2000/11/27 01:41:04 angelos Exp $  */
a1553 24
#if 0 /* This should not be needed -- but there's some weird implementations */
  /* The remote gateway is also allowed to talk to the subnet */
  error = pf_key_v2_flow (((struct sockaddr_in *)dst)->sin_addr.s_addr,
			  hostmask, isa->src_net, isa->src_mask,
			  proto->spi[1], proto->proto,
			  ((struct sockaddr_in *)src)->sin_addr.s_addr,
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1);
  if (error)
    return error;
#endif /* 0 */

#ifndef SADB_X_EXT_FLOW_TYPE
  /* The remote gateway is also allowed to talk to the local gateway */
  error = pf_key_v2_flow (((struct sockaddr_in *)dst)->sin_addr.s_addr,
			  hostmask,
			  ((struct sockaddr_in *)src)->sin_addr.s_addr,
			  hostmask, proto->spi[1], proto->proto,
			  ((struct sockaddr_in *)src)->sin_addr.s_addr,
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			  0, 1);
  if (error)
    return error;
#endif /* SADB_X_EXT_FLOW_TYPE */

a1580 1

a1597 10

      error = pf_key_v2_flow (((struct sockaddr_in *)dst)->sin_addr.s_addr,
			      hostmask,
			      ((struct sockaddr_in *)src)->sin_addr.s_addr,
			      hostmask, proto->spi[1], proto->proto,
			      ((struct sockaddr_in *)src)->sin_addr.s_addr,
			      ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			      1, 1);
      if (error)
	return error;
a1599 11
#if 0
      error = pf_key_v2_flow (((struct sockaddr_in *)dst)->sin_addr.s_addr,
			      hostmask, isa->src_net, isa->src_mask,
			      proto->spi[1], proto->proto,
			      ((struct sockaddr_in *)src)->sin_addr.s_addr,
			      ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			      1, 1);
      if (error)
	return error;
#endif /* 0 */

d1626 3
a1628 4
   * If the SA was outbound and it has not yet been replaced, or it's
   * incoming, remove the flow associated with it.
   * We ignore any errors from the disabling of the flow, it does not matter.
   * Only remove flows if it was not an SA acquired by the kernel.
d1630 1
a1630 1
  if (((!incoming && !(sa->flags & SA_FLAG_REPLACED)) || incoming)
@


1.37
log
@Fix deletion of flows.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.36 2000/11/17 05:16:36 angelos Exp $  */
d1234 1
a1234 1
#ifdef SADB_X_EXT_FLOW_TYPE
@


1.36
log
@Merge with EOM (since Niklas won't get off his nether regions)
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.35 2000/11/17 04:53:57 angelos Exp $  */
d1196 1
d1234 1
d1236 3
@


1.35
log
@HMAC96->HMAC as needed.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.34 2000/10/30 16:04:00 angelos Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.59 2000/10/16 18:16:59 provos Exp $	*/
d54 1
d455 1
a455 1
      log_error ("pf_key_v2_write: writev (%d, 0x%p, %d) failed",
d810 1
a810 1
#ifdef SADB_AALG_SHA1HMAC96 
d822 1
a822 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
d867 1
a867 1
	  ssa.sadb_sa_auth = SADB_X_AALG_RIPEMD160HMAC;
d1517 1
d1519 1
d1532 2
a1533 1
  /* Ingress flows */
d1547 1
d1549 1
d1558 1
d1560 1
d1571 1
d1585 1
a1585 1
  int dstlen, srclen, error;
d1587 1
d1589 2
d1603 2
a1604 1
      /* Ingress flow */
d1628 1
d1630 1
d1639 1
d1933 1
d2167 14
a2180 1
	    prefstring = "USER_FQDN";
d2182 20
a2201 1
	  srcid = malloc (slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d2210 9
a2218 3
	  strlcat (srcid + strlen ("ID:/") + strlen (prefstring),
		   (char *)(srcident + 1),
		   slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d2268 2
a2269 1
	    prefstring = "USER_FQDN";
d2271 32
a2302 1
	  dstid = malloc (slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d2311 9
a2319 3
	  strlcat (dstid + strlen ("ID:/") + strlen (prefstring),
		   (char *) (dstident + 1),
		   slen + strlen (prefstring) + 1 + strlen ("ID:/"));
d2377 1
a2377 1
   * - Listen-address (if provided)
d2385 1
a2385 1
                (dstid ? strlen (dstid) : 0) + strlen ("Peer-/-/") + 1);
d2435 1
a2435 1
	  if (conf_set (af, lname, "ID-type", "IPV4_SUBNET", 0, 0)
d2466 1
a2466 1
	  if (conf_set (af, dname, "ID-type", "IPV4_SUBNET", 0, 0)
d2523 1
a2523 1
      if (!conf_get_str (confname, "Exchange_Type"))
d2525 1
a2525 1
	  if (conf_set (af, confname, "exchange_type", "ID_PROT", 0, 0)
@


1.34
log
@Fix bug with ACQUIRE message.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.33 2000/10/16 23:26:20 niklas Exp $	*/
d801 3
a803 1
#ifdef KAME
a804 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC96;
d809 3
a811 1
#ifdef KAME
a812 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC96;
d818 1
d820 3
d846 3
a848 1
#ifdef KAME
a849 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC96;
d854 3
a856 1
#ifdef KAME
a857 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC96;
d863 1
d865 3
@


1.34.2.1
log
@Pull in changes from current:
Fixes (angelos):
* ifndef, not ifdef
* Fix deletion of flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.34 2000/10/30 16:04:00 angelos Exp $	*/
a1186 1
  bzero (&flowtype, sizeof flowtype);
a1223 1
#ifndef SADB_X_EXT_FLOW_TYPE
a1224 3
#else
  if (!delete)
#endif /* SADB_X_EXT_FLOW_TYPE */
@


1.34.2.2
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*      $OpenBSD: pf_key_v2.c,v 1.50 2001/04/24 07:27:37 niklas Exp $  */
/*	$EOM: pf_key_v2.c,v 1.79 2000/12/12 00:33:19 niklas Exp $	*/
d5 2
a6 2
 * Copyright (c) 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2000, 2001 Angelos D. Keromytis.  All rights reserved.
a53 1
#include <pwd.h>
d231 1
a231 1
  struct pf_key_v2_node *np;
d233 1
a233 2
  np = TAILQ_FIRST (msg);
  while (np)
d235 1
a235 1
      TAILQ_REMOVE (msg, np, link);
a238 1
      np = TAILQ_FIRST (msg);
d454 1
a454 1
      log_error ("pf_key_v2_write: writev (%d, %p, %d) failed",
d589 1
a589 2
		   int srclen, struct sockaddr *dst, int dstlen,
		   u_int32_t seq)
d616 5
a620 3

  /* Set the sequence number from the ACQUIRE message */
  msg.sadb_msg_seq = seq;
d626 1
a626 1
  memset (&ssa2, 0, sizeof ssa2);
d794 1
a794 3
	  LOG_DBG ((LOG_SYSDEP, 50,
		    "pf_key_v2_set_spi: unknown encryption algorithm %d",
		    proto->id));
d801 3
a803 1
#ifdef SADB_AALG_MD5HMAC96
a804 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC;
d809 3
a811 1
#ifdef SADB_AALG_SHA1HMAC96
a812 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
a817 1
#ifdef SADB_X_AALG_RIPEMD160HMAC96
a818 3
#else
	  ssa.sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
#endif
d825 1
a825 3
	  LOG_DBG ((LOG_SYSDEP, 50,
		    "pf_key_v2_set_spi: unknown authentication algorithm %d",
		    iproto->auth));
d842 3
a844 1
#ifdef SADB_AALG_MD5HMAC96
a845 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_MD5HMAC;
d850 3
a852 1
#ifdef SADB_AALG_SHA1HMAC96
a853 2
#else
	  ssa.sadb_sa_auth = SADB_AALG_SHA1HMAC;
a858 1
#ifdef SADB_X_AALG_RIPEMD160HMAC96
a859 3
#else
	  ssa.sadb_sa_auth = SADB_AALG_RIPEMD160HMAC;
#endif
d864 1
a864 3
	  LOG_DBG ((LOG_SYSDEP, 50,
		    "pf_key_v2_set_spi: unknown authentication algorithm %d",
		    proto->id));
d891 1
a891 1
  memset (&ssa2, 0, sizeof ssa2);
d1015 1
a1015 1
  /* XXX I am not sure about what to do here just yet.  */
d1147 2
a1148 5
		in_addr_t rmask, u_int8_t tproto, u_int16_t sport,
		u_int16_t dport, u_int8_t *spi, u_int8_t proto,
		in_addr_t dst, in_addr_t src, int delete, int ingress,
		u_int8_t srcid_type, u_int8_t *srcid, int srcid_len,
		u_int8_t dstid_type, u_int8_t *dstid, int dstid_len)
a1153 1
  struct sadb_ident *sid = 0;
a1157 1
  struct sadb_protocol tprotocol;
a1185 47
  if (!delete)
    {
      /* Setup the source ID, if provided */
      if (srcid)
        {
	  sid = calloc (PF_KEY_V2_ROUND (srcid_len + 1) + sizeof *sid,
			sizeof (u_int8_t));
	  if (!sid)
	    goto cleanup;

	  sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
	    + PF_KEY_V2_ROUND (srcid_len) / PF_KEY_V2_CHUNK;
	  sid->sadb_ident_exttype = SADB_EXT_IDENTITY_SRC;
	  sid->sadb_ident_type = srcid_type;

	  memcpy (sid + 1, srcid, srcid_len);

	  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)sid,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;

	  sid = 0;
	}

      /* Setup the destination ID, if provided */
      if (dstid)
        {
	  sid = calloc (PF_KEY_V2_ROUND (dstid_len + 1) + sizeof *sid,
			sizeof (u_int8_t));
	  if (!sid)
	    goto cleanup;

	  sid->sadb_ident_len = ((sizeof *sid) / PF_KEY_V2_CHUNK)
	    + PF_KEY_V2_ROUND (dstid_len) / PF_KEY_V2_CHUNK;
	  sid->sadb_ident_exttype = SADB_EXT_IDENTITY_DST;
	  sid->sadb_ident_type = dstid_type;

	  memcpy (sid + 1, dstid, dstid_len);

	  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)sid,
				 PF_KEY_V2_NODE_MALLOCED) == -1)
	    goto cleanup;

	  sid = 0;
	}
    }

d1264 1
a1264 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = sport;
d1280 1
a1280 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = sport ? 0xffff : 0;
d1296 1
a1296 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = dport;
d1312 1
a1312 1
  ((struct sockaddr_in *)(addr + 1))->sin_port = dport ? 0xffff : 0;
d1318 2
a1319 13
  /* Setup the protocol extension.  */
  bzero (&tprotocol, sizeof tprotocol);
  tprotocol.sadb_protocol_exttype = SADB_X_EXT_PROTOCOL;
  tprotocol.sadb_protocol_len = sizeof tprotocol / PF_KEY_V2_CHUNK;
  tprotocol.sadb_protocol_proto = tproto;

  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&tprotocol, 0) == -1)
    goto cleanup;

  LOG_DBG ((LOG_SYSDEP, 50,
	    "pf_key_v2_flow: src %x %x dst %x %x proto %u sport %u dport %u",
	    ntohl (laddr), ntohl (lmask), ntohl (raddr), ntohl (rmask),
	    tproto, ntohs (sport), ntohs (dport)));
a1343 4
#ifdef SADB_X_EXT_FLOW_TYPE
  if (sid)
    free (sid);
#endif /* SADB_X_EXT_FLOW_TYPE */
d1372 1
a1372 1
  memset (&ssa2, 0, sizeof ssa2);
d1426 1
a1426 4
  if (ingress)
  	policy->sadb_x_policy_dir = IPSEC_DIR_INBOUND;
  else
  	policy->sadb_x_policy_dir = IPSEC_DIR_OUTBOUND;
a1504 47
#ifdef SADB_X_EXT_FLOW_TYPE
static u_int8_t *
pf_key_v2_convert_id (u_int8_t *id, int idlen, int *reslen, int *idtype)
{
  u_int8_t *res = 0;

  switch (id[0])
    {
    case IPSEC_ID_FQDN:
      res = calloc (idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ,
		    sizeof (u_int8_t));
      if (!res)
	return 0;

      *reslen = idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
      memcpy (res, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, *reslen);
      *idtype = SADB_IDENTTYPE_FQDN;
      return res;

    case IPSEC_ID_USER_FQDN:
      res = calloc (idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ,
		    sizeof (u_int8_t));
      if (!res)
	return 0;

      *reslen = idlen - ISAKMP_ID_DATA_OFF + ISAKMP_GEN_SZ;
      memcpy (res, id + ISAKMP_ID_DATA_OFF - ISAKMP_GEN_SZ, *reslen);
      *idtype = SADB_IDENTTYPE_MBOX;
      return res;

    case IPSEC_ID_IPV4_ADDR:
    case IPSEC_ID_IPV4_RANGE:
    case IPSEC_ID_IPV4_ADDR_SUBNET:
    case IPSEC_ID_IPV6_ADDR:
    case IPSEC_ID_IPV6_RANGE:
    case IPSEC_ID_IPV6_ADDR_SUBNET:
    case IPSEC_ID_DER_ASN1_DN:
    case IPSEC_ID_DER_ASN1_GN:
    case IPSEC_ID_KEY_ID:
      /* XXX Not implemented yet.  */
      return 0;
    }

  return 0;
}
#endif /* SADB_X_EXT_FLOW_TYPE */

d1507 1
a1507 1
pf_key_v2_enable_sa (struct sa *sa, struct sa *isakmp_sa)
a1512 3
  int sidtype = 0, didtype = 0, sidlen = 0, didlen = 0;
  u_int8_t *sid = 0, *did = 0;
#ifndef SADB_X_EXT_FLOW_TYPE
a1513 1
#endif /* SADB_X_EXT_FLOW_TYPE */
a1517 22
#ifdef SADB_X_EXT_FLOW_TYPE
  if (isakmp_sa->id_i)
    {
      if (isakmp_sa->initiator)
	sid = pf_key_v2_convert_id (isakmp_sa->id_i, isakmp_sa->id_i_len,
				    &sidlen, &sidtype);
      else
	did = pf_key_v2_convert_id (isakmp_sa->id_i, isakmp_sa->id_i_len,
				    &didlen, &didtype);
    }

  if (isakmp_sa->id_r)
    {
      if (isakmp_sa->initiator)
	did = pf_key_v2_convert_id (isakmp_sa->id_r, isakmp_sa->id_r_len,
				    &didlen, &didtype);
      else
	sid = pf_key_v2_convert_id (isakmp_sa->id_r, isakmp_sa->id_r_len,
				    &sidlen, &sidtype);
    }
#endif /* SADB_X_EXT_FLOW_TYPE */

d1520 1
a1520 2
			  isa->dst_mask, isa->tproto, isa->sport, isa->dport,
			  proto->spi[0], proto->proto,
d1522 1
a1522 2
			  ((struct sockaddr_in *)src)->sin_addr.s_addr, 0, 0,
			  sidtype, sid, sidlen, didtype, did, didlen);
d1524 1
a1524 1
    goto cleanup;
d1526 1
a1526 2
#ifndef SADB_X_EXT_FLOW_TYPE
  /* Ingress flows, handling SA bundles */
d1532 1
a1532 1
			      hostmask, 0, 0, 0, proto->spi[1], proto->proto,
d1535 1
a1535 1
			      0, 1, 0, 0, 0, 0, 0, 0);
d1537 1
a1537 1
	goto cleanup;
a1539 1
#endif /* SADB_X_EXT_FLOW_TYPE */
d1541 3
a1543 2
  error = pf_key_v2_flow (isa->dst_net, isa->dst_mask, isa->src_net,
			  isa->src_mask, isa->tproto, isa->dport, isa->sport,
d1546 14
a1559 10
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1,
			  sidtype, sid, sidlen, didtype, did, didlen);
  
 cleanup:
#ifdef SADB_X_EXT_FLOW_TYPE
  if (sid)
    free (sid);
  if (did)
    free (did);
#endif /* SADB_X_EXT_FLOW_TYPE */
d1561 4
a1564 1
  return error;
d1573 1
a1573 1
  int dstlen, srclen;
a1574 1
#ifndef SADB_X_EXT_FLOW_TYPE
a1575 2
  int error;
#endif /* SADB_X_EXT_FLOW_TYPE */
d1582 1
a1582 2
			   isa->dst_mask, isa->tproto, isa->sport, isa->dport,
			   proto->spi[0], proto->proto,
d1584 2
a1585 2
			   ((struct sockaddr_in *)src)->sin_addr.s_addr, 1, 0,
			   0, 0, 0, 0, 0, 0);
d1588 1
a1588 2
#ifndef SADB_X_EXT_FLOW_TYPE
      /* Ingress flow --- SA bundles */
d1594 1
a1594 2
				  hostmask, 0, 0, 0,
				  proto->spi[1], proto->proto,
d1597 1
a1597 1
				  1, 1, 0, 0, 0, 0, 0, 0);
d1602 19
a1620 1
#endif /* SADB_X_EXT_FLOW_TYPE */
d1623 1
a1623 2
			     isa->src_mask, isa->tproto, isa->dport,
			     isa->sport, proto->spi[1], proto->proto,
d1626 1
a1626 1
                             1, 1, 0, 0, 0, 0, 0, 0);
d1648 4
a1651 3
   * If the SA was not replaced and was not one acquired through the
   * kernel (ACQUIRE message), remove the flow associated with it.
   * We ignore any errors from the disabling of the flow.
d1653 1
a1653 1
  if (!(sa->flags & SA_FLAG_REPLACED)
d1688 1
a1688 1
  memset (&ssa2, 0, sizeof ssa2);
d1808 1
a1808 1
  struct sadb_lifetime *life, *lifecurrent;
a1837 8
  lifenode = pf_key_v2_find_ext (pmsg, SADB_EXT_LIFETIME_CURRENT);
  if (!lifenode)
    {
      log_print ("pf_key_v2_expire: no current lifetime extension found");
      return;
    }
  lifecurrent = lifenode->seg;

d1866 4
a1869 4
   * If we got a notification, try to renegotiate the SA -- unless of
   * course it has already been replaced by another.
   * Also, ignore SAs that were not dynamically established, or that
   * did not see any use.
d1871 2
a1872 2
  if (!(sa->flags & SA_FLAG_REPLACED) && (sa->flags & SA_FLAG_ONDEMAND) &&
      lifecurrent->sadb_lifetime_bytes)
d1877 6
d1911 1
a1911 1
  char lname[100], dname[100], configname[30];
a1913 4
  struct passwd *pwd = NULL;
  u_int16_t sport = 0, dport = 0;
  u_int8_t tproto = 0;
  char tmbuf[sizeof sport * 3 + 1];
d1978 1
a2001 1
  tproto = sproto->sadb_protocol_proto;
a2016 1
      sport = ((struct sockaddr_in *)sflow)->sin_port;
a2022 1
      dport = ((struct sockaddr_in *)dflow)->sin_port;
a2047 1
      sport = ((struct sockaddr_in6 *)sflow)->sin6_port;
a2053 1
      dport = ((struct sockaddr_in6 *)dflow)->sin6_port;
d2147 1
a2147 36
	    {
	      prefstring = "USER_FQDN";

	      /*
	       * Check whether there is a string following the header;
	       * if no, that there is a user ID (and acquire the login
	       * name). If there is both a string and a user ID, check
	       * that they match.
	       */
	      if ((slen == 0) && (srcident->sadb_ident_id == 0))
	        {
		  log_error ("pf_key_v2_acquire: no user FQDN or ID provided");
		  goto fail;
		} 

	      if (srcident->sadb_ident_id)
	        {
		  pwd = getpwuid (srcident->sadb_ident_id);
		  if (pwd == NULL)
		    {
		      log_error ("pf_key_v2_acquire: could not acquire "
				 "username from provided ID %d",
				 srcident->sadb_ident_id);
		      goto fail;
		    }

		  if (slen != 0)
		    if (strcmp (pwd->pw_name, (char *)(srcident + 1)) != 0)
		      {
			log_error ("pf_key_v2_acquire: provided user name and "
				   "ID do not match (%s != %s)",
				   (char *)(srcident + 1), pwd->pw_name);
			goto fail;
		      }
		}
	    }
d2149 1
a2149 2
	  srcid = malloc ((slen ? slen : strlen (pwd->pw_name)) +
			  strlen (prefstring) + 1 + strlen ("ID:/"));
d2158 3
a2160 9
	  if (slen != 0)
	    strlcat (srcid + strlen ("ID:/") + strlen (prefstring),
		     (char *)(srcident + 1),
		     slen + strlen (prefstring) + 1 + strlen ("ID:/"));
	  else
	    strlcat (srcid + strlen ("ID:/") + strlen (prefstring),
		     pwd->pw_name,
		     strlen (prefstring) + 1 + strlen ("ID:/"));
	  pwd = NULL;
d2210 1
a2210 14
	    {
	      prefstring = "USER_FQDN";

	      /*
	       * Check whether there is a string following the header;
	       * if no, that there is a user ID (and acquire the login
	       * name). If there is both a string and a user ID, check
	       * that they match.
	       */
	      if ((slen == 0) && (dstident->sadb_ident_id == 0))
	        {
		  log_error ("pf_key_v2_acquire: no user FQDN or ID provided");
		  goto fail;
		} 
d2212 1
a2212 24
	      if (dstident->sadb_ident_id)
	        {
		  pwd = getpwuid (dstident->sadb_ident_id);
		  if (pwd == NULL)
		    {
		      log_error ("pf_key_v2_acquire: could not acquire "
				 "username from provided ID %d",
				 dstident->sadb_ident_id);
		      goto fail;
		    }

		  if (slen != 0)
		    if (strcmp (pwd->pw_name, (char *)(dstident + 1)) != 0)
		      {
			log_error ("pf_key_v2_acquire: provided user name and "
				   "ID do not match (%s != %s)",
				   (char *)(dstident + 1), pwd->pw_name);
			goto fail;
		      }
		}
	    }

	  dstid = malloc ((slen ? slen : strlen (pwd->pw_name))
			  + strlen (prefstring) + 1 + strlen ("ID:/"));
d2221 3
a2223 9
	  if (slen != 0)
	    strlcat (dstid + strlen ("ID:/") + strlen (prefstring),
		     (char *)(dstident + 1),
		     slen + strlen (prefstring) + 1 + strlen ("ID:/"));
	  else
	    strlcat (dstid + strlen ("ID:/") + strlen (prefstring),
		     pwd->pw_name,
		     strlen (prefstring) + 1 + strlen ("ID:/"));
	  pwd = NULL;
a2273 1
   * - Acquire-ID (sequence number of kernel message, e.g., PF_KEYv2)
d2281 1
a2281 1
   * - Local-address (if provided)
d2289 1
a2289 1
		 (dstid ? strlen (dstid) : 0) + strlen ("Peer-/-/") + 1);
a2317 8
  /* Set the sequence number */
  sprintf (lname, "%u", msg->sadb_msg_seq);
  if (conf_set (af, conn, "Acquire-ID", lname, 0, 0))
    {
      conf_end (af, 0);
      goto fail;
    }

d2319 1
a2319 1
  sprintf (lname, "Phase2-ID:%s/%s/%d/%d", ssflow, ssmask, tproto, sport);
d2339 1
a2339 1
	  if (conf_set (af, lname, "ID-type", "IPV4_ADDR_SUBNET", 0, 0)
a2346 19
      if (tproto)
        {
	  sprintf (tmbuf, "%d", tproto);
	  if (conf_set (af, lname, "Protocol", tmbuf, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }

	  if (sport)
	    {
	      sprintf (tmbuf, "%d", ntohs (sport));
	      if (conf_set (af, lname, "Port", tmbuf, 0, 0))
	        {
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	}
d2350 1
a2350 1
  sprintf (dname, "Phase2-ID:%s/%s/%d/%d", sdflow, sdmask, tproto, dport);
d2370 1
a2370 1
	  if (conf_set (af, dname, "ID-type", "IPV4_ADDR_SUBNET", 0, 0)
a2377 20

      if (tproto)
        {
	  sprintf (tmbuf, "%d", tproto);
	  if (conf_set (af, dname, "Protocol", tmbuf, 0, 0))
	    {
	      conf_end (af, 0);
	      goto fail;
	    }

	  if (dport)
	    {
	      sprintf (tmbuf, "%d", ntohs (dport));
	      if (conf_set (af, dname, "Port", tmbuf, 0, 0))
	        {
		  conf_end (af, 0);
		  goto fail;
		}
	    }
	}
d2427 1
a2427 1
      if (!conf_get_str (confname, "exchange_type"))
d2429 1
a2429 1
	  if (conf_set (af, confname, "Exchange_Type", "ID_PROT", 0, 0)
d2595 1
a2595 1
  memset (&kamesa2, 0, sizeof kamesa2);
@


1.34.2.3
log
@Pull in patch from current, requested by ho@@
Errata:
isakmpd will fail to use a certificate with an identity string that
is exactly N * 8 bytes long.
Fix(ho):
PF_KEY identity extensions are NUL-terminated. Now, also calculate
the length properly.
@
text
@d1 1
a1 1
/*      $OpenBSD: pf_key_v2.c,v 1.34.2.2 2001/05/08 12:45:25 ho Exp $  */
d1218 1
a1218 1
	    + PF_KEY_V2_ROUND (srcid_len + 1) / PF_KEY_V2_CHUNK;
d1240 1
a1240 1
	    + PF_KEY_V2_ROUND (dstid_len + 1) / PF_KEY_V2_CHUNK;
@


1.33
log
@Merge with EOM 1.59

author: provos
better referencing.  okay niklas@@

author: niklas
Name collissions introduced by me, DOH!

author: niklas
Allow new and old style configuration simultaneously

author: niklas
Backward compatibility with old style configuration

author: niklas
remove redundant ifdefs

author: niklas
facistoid style and naming pedantery

author: angelos
Construct the ISAKMP-peer section such that it actually contains the
src/dst Phase 1 IDs (so we don't have to worry about configuration
conflicts). I should update the manpage....

author: angelos
Use local-address, not listen-address.

author: angelos
First cut of ACQUIRE handling, fully functional but not entirely
dynamic (it depends on the pre-defined Transforms and
Suites). Nonetheless, it is possible to use isakmpd without a
configuration file when using certificates for authentication.

author: angelos
Add RIPEMD negotiation/configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.32 2000/10/10 13:34:58 niklas Exp $	*/
d1990 1
a1990 1
  ext = pf_key_v2_find_ext (pmsg, SADB_X_EXT_FLOW_TYPE);
d2070 1
a2099 1
      bzero (srcbuf, sizeof srcbuf);
d2267 1
a2267 1
   * - ISAKMPD-peer
d2282 3
a2284 2
  peer = malloc (strlen (dstbuf) + strlen (srcbuf) + srcid ? strlen (srcid) : 0
		 + dstid ? strlen (dstid) : 0 + strlen ("Peer-/-/") + 1);
d2422 1
a2422 1
      if (!conf_get_str (confname, "exchange_type"))
@


1.32
log
@Merge with EOM 1.49

author: niklas
Very ugly, transient fix so isakmpd works in a backward compatible
way, instead of requiring the new undocumented ACQUIRE-based setup
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.31 2000/10/09 23:26:59 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.49 2000/10/10 13:30:26 niklas Exp $	*/
d68 8
d100 3
d596 1
d617 1
a617 1
   * XXX When we have acquires working, the sequence number have to be set
d626 1
a626 1
  memset(&ssa2, 0, sizeof(ssa2));
d628 1
a628 1
  ssa2.sadb_x_sa2_len = sizeof(ssa2) / PF_KEY_V2_CHUNK;
d696 2
a697 2
  sa = (struct sadb_sa *)pf_key_v2_find_ext (ret, SADB_EXT_SA)->seg;
  if (!sa)
d702 1
d794 1
a794 1
	  /* XXX Log?  */
d816 6
d824 2
a825 1
	  /* XXX Log?  */
d857 6
d864 1
a864 1
	  /* XXX Log?  */
d891 1
a891 1
  memset(&ssa2, 0, sizeof(ssa2));
d893 1
a893 1
  ssa2.sadb_x_sa2_len = sizeof(ssa2) / PF_KEY_V2_CHUNK;
d927 1
a927 1
       * RFCs actually mandate what a lifetime reaaly is.
d972 1
a972 1
   * XXX Addresses has to be thought through.  Assumes IPv4.
a1139 3
#undef OPENBSD_IPSEC_API_VERSION

#ifndef OPENBSD_IPSEC_API_VERSION
a1151 1
  struct sadb_sa ssa;
d1154 2
a1160 3
#ifdef KAME
  struct sadb_x_sa2 ssa2;
#endif
d1185 9
a1193 6
#ifdef KAME
  memset(&ssa2, 0, sizeof(ssa2));
  ssa2.sadb_x_sa2_exttype = SADB_X_EXT_SA2;
  ssa2.sadb_x_sa2_len = sizeof(ssa2) / PF_KEY_V2_CHUNK;
  ssa2.sadb_x_sa2_mode = 0;
  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&ssa2, 0) == -1)
d1195 1
a1195 2
#endif

d1216 1
a1216 12

#ifdef SADB_X_EXT_FLOW_TYPE
  /* Setup the flow type extension.  */
  flowtype.sadb_protocol_exttype = SADB_X_EXT_FLOW_TYPE;
  flowtype.sadb_protocol_len = sizeof flowtype / PF_KEY_V2_CHUNK;
  flowtype.sadb_protocol_direction
    = ingress ? IPSP_DIRECTION_IN : IPSP_DIRECTION_OUT;
  flowtype.sadb_protocol_proto = FLOW_X_TYPE_REQUIRE;

  if (pf_key_v2_msg_add (flow, (struct sadb_ext *)&flowtype, 0) == -1)
    goto cleanup;
#endif
d1221 1
a1221 1
   * XXX Addresses has to be thought through.  Assumes IPv4.
a1230 4
#ifndef __OpenBSD__
      addr->sadb_address_proto = 0;
      addr->sadb_address_prefixlen = 0;
#endif
a1253 4
#ifndef __OpenBSD__
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
a1269 4
#ifndef __OpenBSD__
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
a1285 4
#ifndef __OpenBSD__
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
a1301 4
#ifndef __OpenBSD__
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
a1323 1
#ifdef __OpenBSD__
a1327 1
#endif
d1351 1
a1358 3
#ifdef KAME
  struct sadb_x_sa2 ssa2;
#endif
d1367 1
a1367 2
#ifdef KAME
  memset(&ssa2, 0, sizeof(ssa2));
d1369 1
a1369 1
  ssa2.sadb_x_sa2_len = sizeof(ssa2) / PF_KEY_V2_CHUNK;
a1372 1
#endif
d1377 1
a1377 1
   * XXX Addresses has to be thought through.  Assumes IPv4.
a1384 1
#ifndef __OpenBSD__
a1386 1
#endif
a1402 1
#ifndef __OpenBSD__
a1404 1
#endif
a1498 1
#endif
a1503 4
#if OPENBSD_IPSEC_API_VERSION == 1
  /* We don't mess with flows */
  return 0;
#else
a1559 1
#endif
a1561 1
#ifndef OPENBSD_IPSEC_API_VERSION
a1623 1
#endif
a1631 3
#if OPENBSD_IPSEC_API_VERSION == 1
  return 0;
#else
d1646 1
d1648 2
a1649 1
  if ((!incoming && !(sa->flags & SA_FLAG_REPLACED)) || incoming)
d1683 1
a1683 1
  memset(&ssa2, 0, sizeof(ssa2));
d1685 1
a1685 1
  ssa2.sadb_x_sa2_len = sizeof(ssa2) / PF_KEY_V2_CHUNK;
d1694 1
a1694 1
   * XXX Addresses has to be thought through.  Assumes IPv4.
a1765 1
#endif
d1805 1
a1805 1
  struct pf_key_v2_node *lifenode;
d1808 14
a1821 2
  ssa = pf_key_v2_find_ext (pmsg, SADB_EXT_SA)->seg;
  dst = pf_key_v2_find_ext (pmsg, SADB_EXT_ADDRESS_DST)->seg;
d1826 5
d1834 1
a1834 2
  LOG_DBG ((LOG_SYSDEP, 20,
	    "pf_key_v2_expire: %s dst %s SPI %x sproto %d",
d1872 4
a1875 4
      /*
       * XXX We need to reestablish the on-demand route here.  This we need
       * even if we have started a new negotiation, considering it might
       * fail.
d1877 1
a1877 1

d1887 22
a1908 6
  struct sadb_msg *msg;
  struct sadb_address *dst, *src;
  struct sockaddr *dstaddr, *srcaddr;
  struct sadb_comb *scmb;
  struct sadb_prop *sprp;
  char adbuf[40];
d1911 156
a2066 4
  dst = pf_key_v2_find_ext (pmsg, SADB_EXT_ADDRESS_DST)->seg;
  src = pf_key_v2_find_ext (pmsg, SADB_EXT_ADDRESS_SRC)->seg;
  sprp = pf_key_v2_find_ext (pmsg, SADB_EXT_PROPOSAL)->seg;
  scmb = (struct sadb_comb *)(sprp + 1);
d2069 1
a2069 1
  srcaddr = (struct sockaddr *)(src + 1);
d2074 8
a2081 3
      LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d",
		inet_ntop(AF_INET, &((struct sockaddr_in *)dstaddr)->sin_addr,
			  adbuf, 16), msg->sadb_msg_satype));
d2085 8
a2092 4
      LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d",
		inet_ntop(AF_INET6
			  , &((struct sockaddr_in6 *)dstaddr)->sin6_addr,
			  adbuf, 16), msg->sadb_msg_satype));
d2096 382
a2477 2
  /* XXX Only support one proposal for now */
  /* XXX Finish it */
d2589 1
a2589 1
  memset(&kamesa2, 0, sizeof(kamesa2));
d2591 1
a2591 1
  kamesa2.sadb_x_sa2_len = sizeof(kamesa2) / PF_KEY_V2_CHUNK;
d2600 1
a2600 1
   * XXX Addresses has to be thought through.  Assumes IPv4.
@


1.31
log
@Merge with EOM 1.48

author: niklas
properly ifdef PF_KEY extension

author: angelos
AES support.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.30 2000/10/07 06:57:56 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.48 2000/10/09 23:24:23 niklas Exp $	*/
d46 4
d1114 2
d1130 3
d1141 1
a1141 1
#ifndef SADB_X_SAFLAGS_INGRESS_FLOW
d1186 1
d1189 1
d1194 12
d1228 4
d1233 1
@


1.30
log
@Merge with EOM 1.46

author: niklas
style

author: angelos
No reserved1 field anymore.

author: angelos
Begining of ACQUIRE support.

author: angelos
No need to delete SPIs, they'll just expire.

author: angelos
Only play with flows if we're using the "old" IPsec code (the new
kernel code to be committed).
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.46 2000/10/07 06:46:55 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.46 2000/10/07 06:46:55 niklas Exp $	*/
d757 6
@


1.29
log
@Manually merge some changes from EOM.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.28 2000/09/19 08:38:28 angelos Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.41 2000/06/20 03:35:01 itojun Exp $	*/
d1882 14
a1895 11
  {
      case AF_INET:
         LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d",
                   inet_ntop(AF_INET, &((struct sockaddr_in *)dstaddr)->sin_addr, adbuf, 16), msg->sadb_msg_satype));
         break;

      case AF_INET6:
         LOG_DBG ((LOG_SYSDEP, 20, "pf_key_v2_acquire: dst=%s sproto %d",
                   inet_ntop(AF_INET6, &((struct sockaddr_in6 *)dstaddr)->sin6_addr, adbuf, 16), msg->sadb_msg_satype));
         break;
  }
@


1.28
log
@No reserved1 field in sprotocol structure any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.27 2000/06/20 05:55:27 niklas Exp $	*/
d1104 1
d1483 1
d1489 4
d1549 1
d1552 1
d1615 1
d1624 3
d1759 1
d1861 37
d1908 1
a1908 2
      log_print ("pf_key_v2_notify: ACQUIRE not yet implemented");
      /* XXX To be implemented.  */
@


1.27
log
@Merge with EOM 1.41

author: itojun
synchronize with latest KAME PF_KEY interface.  need more testing.
old: changes sadb_msg, which is bad
new: added sadb_x_sa2 for extra meat
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.26 2000/06/19 02:25:31 niklas Exp $	*/
a2024 1
  protocol.sadb_protocol_reserved1 = 0;
@


1.26
log
@Merge with EOM 1.40

author: niklas
&& not &
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.25 2000/03/08 08:41:57 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.40 2000/06/19 02:13:37 niklas Exp $	*/
a406 7
#ifdef KAME
  if (!msg->sadb_msg_mode)
    msg->sadb_msg_mode = IPSEC_MODE_ANY;
  msg->sadb_msg_reqid = 0;	/* XXX */
  msg->sadb_msg_reserved1 = 0;
  msg->sadb_msg_reserved2 = 0;
#else
a407 1
#endif
a509 3
#ifdef KAME
  msg.sadb_msg_mode = 0;
#endif
a531 3
#ifdef KAME
  msg.sadb_msg_mode = 0;
#endif
d583 3
a604 3
#ifdef KAME
  msg.sadb_msg_mode = IPSEC_MODE_TUNNEL;	/* XXX */
#endif
d609 9
d734 3
a846 2
  msg.sadb_msg_mode = iproto->encap_mode == IPSEC_ENCAP_TUNNEL
    ? IPSEC_MODE_TUNNEL : IPSEC_MODE_TRANSPORT;
d854 9
d1121 3
a1143 3
#ifdef KAME
  msg.sadb_msg_mode = 0;
#endif
d1148 9
d1172 1
d1333 3
a1339 3
#ifdef KAME
  msg.sadb_msg_mode = 0;
#endif
d1344 9
d1621 3
a1646 3
#ifdef KAME
  msg.sadb_msg_mode = 0;
#endif
d1663 9
d1912 3
a1929 3
#ifdef KAME
  msg.sadb_msg_mode = 0;
#endif
d1946 1
d1957 8
@


1.25
log
@Merge with EOM 1.39

author: ho
FreeBSD and NetBSD use KAME

author: ho
Add netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.24 2000/02/25 17:23:40 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.39 2000/03/07 22:52:21 ho Exp $	*/
d1156 1
a1156 1
  if (!delete & !ingress)
@


1.24
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.23 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.37 2000/02/20 19:58:41 niklas Exp $	*/
d88 1
a88 1
#ifdef __FreeBSD__
d117 1
a117 1
#ifdef __FreeBSD__
d407 1
a407 1
#ifdef __FreeBSD__
d518 1
a518 1
#ifdef __FreeBSD__
d543 1
a543 1
#ifdef __FreeBSD__
d564 1
a564 1
#ifdef __FreeBSD__
d616 1
a616 1
#ifdef __FreeBSD__
d697 1
a697 1
#ifdef __FreeBSD__
d780 1
a780 1
#ifdef __FreeBSD__
d788 1
a788 1
#ifdef __FreeBSD__
d814 1
a814 1
#ifdef __FreeBSD__
d822 1
a822 1
#ifdef __FreeBSD__
d843 1
a843 1
#ifdef __FreeBSD__
d1136 1
a1136 1
#ifdef __FreeBSD__
d1322 1
a1322 1
#ifdef __FreeBSD__
d1620 1
a1620 1
#ifdef __FreeBSD__
d1894 1
a1894 1
#ifdef __FreeBSD__
@


1.23
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.22 2000/01/31 08:38:29 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.36 2000/01/31 22:33:48 niklas Exp $	*/
d329 1
a329 1
      log_debug_buf (LOG_SYSDEP, 80, "pf_key_v2_read: msg", buf, n);
d344 5
a348 4
	      log_debug (LOG_SYSDEP, 90,
			 "pf_key_v2_read:"
			 "bad version (%d) or PID (%d, mine is %d), ignored",
			 msg->sadb_msg_version, msg->sadb_msg_pid, getpid ());
d440 2
a441 2
      log_debug_buf (LOG_SYSDEP, 80, header, (u_int8_t *)iov[i].iov_base,
		     iov[i].iov_len);
d705 1
a705 1
  log_debug_buf (LOG_SYSDEP, 50, "pf_key_v2_get_spi: spi", spi, *sz);
d1039 4
a1042 4
  log_debug (LOG_SYSDEP, 10, "pf_key_v2_set_spi: satype %d dst %s SPI 0x%x",
	     msg.sadb_msg_satype,
	     inet_ntoa (((struct sockaddr_in *)dst)->sin_addr),
	     ntohl (ssa.sadb_sa_spi));
d1075 1
a1075 1
  log_debug (LOG_SYSDEP, 50, "pf_key_v2_set_spi: done");
d1271 2
a1272 2
  log_debug (LOG_SYSDEP, 50, "pf_key_v2_flow: src %x %x dst %x %x",
	     ntohl (laddr), ntohl (lmask), ntohl (raddr), ntohl (rmask));
d1284 2
a1285 2
	log_debug (LOG_SYSDEP, 10, "pf_key_v2_flow: %sFLOW: %s", 
		   delete ? "DEL" : "ADD", strerror (err));
d1294 1
a1294 1
  log_debug (LOG_MISC, 50, "pf_key_v2_flow: done");
d1421 2
a1422 2
  log_debug (LOG_SYSDEP, 50, "pf_key_v2_flow: src %x %x dst %x %x",
	     ntohl (laddr), ntohl (lmask), ntohl (raddr), ntohl (rmask));
d1438 1
a1438 1
  log_debug (LOG_SYSDEP, 50, "pf_key_v2_flow: done");
d1696 2
a1697 2
      log_debug (LOG_SYSDEP, 10, "pf_key_v2_delete_spi: DELETE: %s", 
		 strerror (err));
d1702 1
a1702 1
  log_debug (LOG_SYSDEP, 50, "pf_key_v2_delete_spi: done");
d1734 2
a1735 2
      log_debug (LOG_SYSDEP, 70,
		 "pf_key_v2_connection_check: SA for %s missing", conn);
d1739 2
a1740 2
    log_debug (LOG_SYSDEP, 70, "pf_key_v2_connection_check: SA for %s exists",
	       conn);
d1765 6
a1770 6
  log_debug (LOG_SYSDEP, 20,
	     "pf_key_v2_expire: %s dst %s SPI %x sproto %d",
	     life->sadb_lifetime_exttype == SADB_EXT_LIFETIME_SOFT ? "SOFT"
	     : "HARD",
	     inet_ntoa (((struct sockaddr_in *)dstaddr)->sin_addr),
	     ntohl (ssa->sadb_sa_spi), msg->sadb_msg_satype);
d2001 1
a2001 1
  log_debug (LOG_SYSDEP, 50, "pf_key_v2_group_spis: done");
@


1.22
log
@ike_quick_mode.c: Merge with EOM 1.109
isakmpd.conf.5: Merge with EOM 1.38
message.c: Merge with EOM 1.142
pf_key_v2.c: Merge with EOM 1.35
x509.c: Merge with EOM 1.31

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.21 2000/01/26 15:36:19 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.35 2000/01/31 08:39:45 niklas Exp $	*/
d6 1
@


1.21
log
@Merge with EOM 1.34

author: niklas
style

author: ho
Lower the common {ADD,DEL}FLOW warnings to log_debug() on OpenBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.20 2000/01/26 15:24:32 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.34 2000/01/26 15:37:06 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1999 Niklas Hallqvist.  All rights reserved.
@


1.20
log
@Merge with EOM 1.32

date: 2000/01/25 13:35:24;  author: niklas;  state: Exp;  lines: +8 -1
Do not assume ingress flows are available

date: 2000/01/25 01:24:38;  author: angelos;  state: Exp;  lines: +40 -1
We also allow the remote gateway to talk to the local subnet and the
local gateway through the SAs setup.

date: 2000/01/25 01:09:20;  author: angelos;  state: Exp;  lines: +2 -2
Don't use REPLACE for ingress flows.

date: 2000/01/24 23:28:39;  author: angelos;  state: Exp;  lines: +30 -28
Delete ACL only for incoming SAs...

date: 2000/01/23 22:56:43;  author: angelos;  state: Exp;  lines: +2 -2
Send SA payload when deleting ingress flow.

date: 2000/01/13 22:54:54;  author: angelos;  state: Exp;  lines: +5 -1
Return on error from ingress flow establishment/deletion.

date: 2000/01/13 22:53:21;  author: angelos;  state: Exp;  lines: +25 -5
Interim ingress flows.

date: 2000/01/13 06:48:27;  author: angelos;  state: Exp;  lines: +37 -12
Establish (and delete) ingress flows.

author: ho
Unbreak.

author: ho
Compile under OpenBSD again.

author: niklas
Ugly KAME support, will be improved

author: angelos
Get rid of the LOCALFLOW flag.

author: ho
log_print -> log_debug for delete_spi: DELETE message. Plus log class typos.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.19 2000/01/23 22:50:55 angelos Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.32 2000/01/25 13:35:24 niklas Exp $	*/
d139 1
a139 1
  TAILQ_INSERT_TAIL(&pf_key_v2_sa_seq_map, node, link);
d144 1
a144 1
    free(node->dst);
d563 1
a563 1
  TAILQ_INIT(&pf_key_v2_sa_seq_map);
d696 3
a698 3
  if (!pf_key_v2_register_sa_seq(spi, *sz, proto, dst, dstlen,
				 ((struct sadb_msg *)(TAILQ_FIRST (ret)->seg))
				 ->sadb_msg_seq))
d1479 9
a1487 9
  while (TAILQ_NEXT(proto, link))
  {
      error = pf_key_v2_flow(((struct sockaddr_in *)dst)->sin_addr.s_addr,
			     hostmask,
			     ((struct sockaddr_in *)src)->sin_addr.s_addr,
			     hostmask, proto->spi[1], proto->proto,
			     ((struct sockaddr_in *)src)->sin_addr.s_addr,
			     ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			     0, 1);
d1490 2
a1491 2
      proto = TAILQ_NEXT(proto, link);
  }
d1494 5
a1498 5
  error = pf_key_v2_flow(((struct sockaddr_in *)dst)->sin_addr.s_addr,
			 hostmask, isa->src_net, isa->src_mask,
			 proto->spi[1], proto->proto,
			 ((struct sockaddr_in *)src)->sin_addr.s_addr,
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1);
d1503 7
a1509 7
  error = pf_key_v2_flow(((struct sockaddr_in *)dst)->sin_addr.s_addr,
			 hostmask,
			 ((struct sockaddr_in *)src)->sin_addr.s_addr,
			 hostmask, proto->spi[1], proto->proto,
			 ((struct sockaddr_in *)src)->sin_addr.s_addr,
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			 0, 1);
d1539 1
a1539 1
  {
d1541 9
a1549 9
      while (TAILQ_NEXT(proto, link))
      {
          error = pf_key_v2_flow(((struct sockaddr_in *)dst)->sin_addr.s_addr,
			         hostmask,
			         ((struct sockaddr_in *)src)->sin_addr.s_addr,
			         hostmask, proto->spi[1], proto->proto,
			         ((struct sockaddr_in *)src)->sin_addr.s_addr,
			         ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			         1, 1);
d1552 2
a1553 2
          proto = TAILQ_NEXT(proto, link);
      }
d1555 7
a1561 7
      error = pf_key_v2_flow(((struct sockaddr_in *)dst)->sin_addr.s_addr,
			     hostmask,
			     ((struct sockaddr_in *)src)->sin_addr.s_addr,
			     hostmask, proto->spi[1], proto->proto,
			     ((struct sockaddr_in *)src)->sin_addr.s_addr,
			     ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			     1, 1);
d1565 6
a1570 6
      error = pf_key_v2_flow(((struct sockaddr_in *)dst)->sin_addr.s_addr,
			     hostmask, isa->src_net, isa->src_mask,
			     proto->spi[1], proto->proto,
			     ((struct sockaddr_in *)src)->sin_addr.s_addr,
			     ((struct sockaddr_in *)dst)->sin_addr.s_addr,
			     1, 1);
d1579 1
a1579 1
  }
@


1.19
log
@Send an SA payload when we're deleting an ingress flow.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.18 2000/01/13 22:55:48 angelos Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.19 1999/07/16 00:29:11 niklas Exp $	*/
d49 1
d87 18
d116 50
d405 7
d413 1
d516 3
d541 3
d562 4
d614 3
d626 1
d629 1
a629 1
#if 0
d646 1
d649 1
a649 1
#if 0
d695 6
d778 3
d782 1
d786 3
d790 1
d812 3
d816 1
d820 3
d824 1
d837 13
d851 1
d941 1
a941 1
#if 0
a952 4
  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &dst, &dstlen);
  else
    sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
d959 1
a959 1
#if 0
d981 1
a981 1
#if 0
d1090 7
a1096 1
 
d1105 1
a1105 1
		in_addr_t dst, int delete, int ingress)
d1115 5
d1134 3
d1150 1
a1150 2
  if (!delete)
    ssa.sadb_sa_flags |= SADB_X_SAFLAGS_REPLACEFLOW;
d1153 3
d1172 1
a1172 1
#if 0
d1194 1
a1194 1
#if 0
d1214 1
a1214 1
#if 0
d1234 1
a1234 1
#if 0
d1254 1
a1254 1
#if 0
d1270 1
a1270 1
	     htonl(laddr), htonl(lmask), htonl(raddr), htonl(rmask));
d1280 151
a1430 1
      log_print ("pf_key_v2_flow: %sFLOW: %s", delete ? "DEL" : "ADD",
d1436 1
a1436 1
  log_debug (LOG_MISC, 50, "pf_key_v2_flow: done");
d1443 2
d1463 1
a1463 1
  int dstlen, error;
d1468 1
a1468 1
  sa->transport->vtbl->get_src (sa->transport, &src, &dstlen);
d1470 1
d1473 2
a1474 2
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 0);

d1478 1
a1478 1
  /* Ingress flow */
d1486 1
d1493 24
a1516 3
  return pf_key_v2_flow(isa->dst_net, isa->dst_mask, isa->src_net,
			isa->src_mask, proto->spi[1], proto->proto,
			((struct sockaddr_in *)src)->sin_addr.s_addr, 0, 1);
d1521 1
a1521 1
pf_key_v2_disable_sa (struct sa *sa)
d1525 1
a1525 1
  int dstlen, error;
d1530 1
a1530 1
  sa->transport->vtbl->get_src (sa->transport, &src, &dstlen);
d1532 5
a1536 5
  error = pf_key_v2_flow (isa->src_net, isa->src_mask, isa->dst_net,
			  isa->dst_mask, proto->spi[0], proto->proto,
			  ((struct sockaddr_in *)dst)->sin_addr.s_addr, 1, 0);
  if (error)
    return error;
d1538 1
a1538 2
  /* Ingress flow */
  while (TAILQ_NEXT(proto, link))
d1540 15
d1560 1
d1564 15
a1578 1
      proto = TAILQ_NEXT(proto, link);
a1579 4

  return pf_key_v2_flow(isa->dst_net, isa->dst_mask, isa->src_net,
			isa->src_mask, proto->spi[1], proto->proto,
			((struct sockaddr_in *)src)->sin_addr.s_addr, 1, 1);
d1597 2
a1598 2
   * If the SA was outbound and it has not yet been replaced, remove the
   * flow associated with it.
d1601 2
a1602 2
  if (!incoming && !(sa->flags & SA_FLAG_REPLACED))
    pf_key_v2_disable_sa (sa);
d1618 3
d1652 1
a1652 1
#if 0
d1674 1
a1674 1
#if 0
d1694 2
a1695 1
      log_print ("pf_key_v2_delete_spi: DELETE: %s", strerror (err));
d1700 1
a1700 1
  log_debug (LOG_MISC, 50, "pf_key_v2_delete_spi: done");
d1892 3
d1937 1
a1937 1
#if 0
d1954 1
a1954 1
#if 0
@


1.18
log
@Interim ingress flows when doing linked SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.17 2000/01/13 06:42:26 angelos Exp $	*/
d1025 1
a1025 1
  if (!delete)
@


1.17
log
@Establish ingress flows.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.16 1999/12/04 23:31:42 angelos Exp $	*/
d1170 1
a1170 1
  struct sockaddr *dst;
d1173 1
d1176 1
d1187 11
a1197 3
    proto = TAILQ_NEXT(proto, link);

  sa->transport->vtbl->get_src (sa->transport, &dst, &dstlen);
d1201 1
a1201 1
			((struct sockaddr_in *)dst)->sin_addr.s_addr, 0, 1);
d1209 1
a1209 1
  struct sockaddr *dst;
d1212 1
d1215 1
d1225 11
a1235 3
    proto = TAILQ_NEXT(proto, link);

  sa->transport->vtbl->get_src (sa->transport, &dst, &dstlen);
d1239 1
a1239 1
			((struct sockaddr_in *)dst)->sin_addr.s_addr, 1, 1);
@


1.16
log
@Get rid of the LOCALFLOW flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.15 1999/07/16 00:44:49 niklas Exp $	*/
d975 1
a975 1
		in_addr_t dst, int delete)
d1014 2
d1171 1
a1171 1
  int dstlen;
d1176 16
a1191 3
  return pf_key_v2_flow (isa->src_net, isa->src_mask, isa->dst_net,
			 isa->dst_mask, proto->spi[0], proto->proto,
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr, 0);
d1200 1
a1200 1
  int dstlen;
d1205 15
a1219 3
  return pf_key_v2_flow (isa->src_net, isa->src_mask, isa->dst_net,
			 isa->dst_mask, proto->spi[0], proto->proto,
			 ((struct sockaddr_in *)dst)->sin_addr.s_addr, 1);
@


1.15
log
@Merge with EOM 1.19

author: niklas
Do not try to establish an encryption key for AH
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.14 1999/07/08 17:49:35 niklas Exp $	*/
d1011 1
a1011 5
  /*
   * XXX The LOCALFLOW flag should only be set if this machine is part of the
   * source subnet.
   */
  ssa.sadb_sa_flags = SADB_X_SAFLAGS_LOCALFLOW;
@


1.14
log
@sysdep/openbsd/sysdep-os.h: Merge with EOM 1.3
pf_key_v2.c: Merge with EOM 1.18

author: niklas
Support building on older PF_KEY systems with non-standard-compliant SADB_-
constants.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.13 1999/07/07 22:08:10 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.18 1999/07/08 16:48:40 niklas Exp $	*/
d893 16
a908 13
  len = sizeof *key + PF_KEY_V2_ROUND (keylen);
  key = malloc (len);
  if (!key)
    goto cleanup;
  key->sadb_key_exttype = SADB_EXT_KEY_ENCRYPT;
  key->sadb_key_len = len / PF_KEY_V2_CHUNK;
  key->sadb_key_bits = keylen * 8;
  key->sadb_key_reserved = 0;
  memcpy (key + 1, iproto->keymat[incoming], keylen);
  if (pf_key_v2_msg_add (update, (struct sadb_ext *)key,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  key = 0;
@


1.13
log
@isakmpd.8: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.17

author: niklas
Merge in fixes done in the OpenBSD tree
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.12 1999/07/02 23:37:32 deraadt Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.17 1999/07/07 19:17:31 niklas Exp $	*/
d49 2
@


1.12
log
@rename SADB_foo_X_bar to SADB_X_foo_bar
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.11 1999/06/02 06:34:53 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.16 1999/05/25 08:06:26 niklas Exp $	*/
@


1.11
log
@Merge with EOM 1.16

author: niklas
As PF_KEY per the specs is a best-effort service, expect messages to get lost.
That means both replies in PF_KEY "RPCs" and expirations, the latter we
solve with extra paranoia and sets timeouts in isakmpd too.
@
text
@d1 1
a1 1
/*	$OpenBSD: pf_key_v2.c,v 1.10 1999/05/01 20:42:54 niklas Exp $	*/
d658 1
a658 1
#ifdef SADB_EALG_X_CAST
d660 1
a660 1
	  ssa.sadb_sa_encrypt = SADB_EALG_X_CAST;
d664 1
a664 1
#ifdef SADB_EALG_X_BLF
d666 1
a666 1
	  ssa.sadb_sa_encrypt = SADB_EALG_X_BLF;
d733 1
a733 1
#ifdef SADB_SAFLAGS_X_TUNNEL
d735 1
a735 1
    = iproto->encap_mode == IPSEC_ENCAP_TUNNEL ? SADB_SAFLAGS_X_TUNNEL : 0;
d1010 1
a1010 1
  ssa.sadb_sa_flags = SADB_SAFLAGS_X_LOCALFLOW;
d1012 1
a1012 1
    ssa.sadb_sa_flags |= SADB_SAFLAGS_X_REPLACEFLOW;
d1049 1
a1049 1
  addr->sadb_address_exttype = SADB_EXT_X_SRC_FLOW;
d1069 1
a1069 1
  addr->sadb_address_exttype = SADB_EXT_X_SRC_MASK;
d1089 1
a1089 1
  addr->sadb_address_exttype = SADB_EXT_X_DST_FLOW;
d1109 1
a1109 1
  addr->sadb_address_exttype = SADB_EXT_X_DST_MASK;
d1516 1
a1516 1
  sa2.sadb_sa_exttype = SADB_EXT_X_SA2;
d1557 1
a1557 1
  addr->sadb_address_exttype = SADB_EXT_X_DST2;
d1572 1
a1572 1
  protocol.sadb_protocol_exttype = SADB_EXT_X_PROTOCOL;
@


1.10
log
@Merge with EOM 1.15

author: niklas
typo in debug output

author: niklas
A new connection abstraction
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.9 1999/05/01 00:51:45 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.15 1999/05/01 20:38:45 niklas Exp $	*/
d41 1
d67 3
d179 2
a180 1
  struct timeval now;
d184 34
d295 1
a295 1
	  gettimeofday (&now, 0);
d297 1
a297 1
			   (void (*) (void *))pf_key_v2_notify, ret, &now);
d781 1
a781 1
       * RFCs actually mandate what a lifetime reaaly is.
d912 8
@


1.9
log
@Merge with EOM 1.13

author: niklas
Sigh, tunnel mode needs a special flag.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.8 1999/04/27 21:01:28 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.13 1999/05/01 00:52:42 niklas Exp $	*/
a65 3
/* How often should we check that connections we require to be up, are up?  */
#define PF_KEY_V2_CHECK_FREQ 60

d1287 1
a1287 1
/* Establish the connection in VCONN and set the stayalive flag for it.  */
d1289 1
a1289 1
pf_key_v2_checker (void *vconn)
a1290 7
  struct timeval now;
  char *conn = vconn;

  gettimeofday (&now, 0);
  now.tv_sec += PF_KEY_V2_CHECK_FREQ;
  if (!timer_add_event ("pf_key_v2_checker", pf_key_v2_checker, conn, &now))
    log_print ("pf_key_v2_checker: could not add timer event");
d1293 3
a1295 2
      log_debug (LOG_SYSDEP, 70, "pf_key_v2_checker: SA for %s missing", conn);
      exchange_establish (conn, pf_key_v2_stayalive, vconn);
d1298 2
a1299 31
    log_debug (LOG_SYSDEP, 70, "pf_key_v2_checker: SA for %s exists", conn);
}

/*
 * Establish a connection CONN that should be available from now,
 * XXX Should establish a keying route that will generate ACQUIRE messages on
 * use.
 * XXX This is not really belonging in the PF_KEYv2 glue, it should be moved
 * to sysdep.c
 */
int
pf_key_v2_connection (char *conn)
{
  struct timeval now;
  char *conn_copy;

  /*
   * As we do not have ACQUIRE notifications just yet, we actually establish
   * the connection as soon as possible.
   */
  gettimeofday (&now, 0);
  conn_copy = strdup (conn);
  if (!conn_copy)
    {
      log_error ("pf_key_v2_connection: strdup(\"%s\") failed", conn);
      return -1;
    }
  if (!timer_add_event ("pf_key_v2_checker", pf_key_v2_checker, conn_copy,
			&now))
    log_print ("pf_key_v2_connection: could not add timer event");
  return 0;
@


1.8
log
@Merge with EOM 1.12

author: niklas
Remove unused macro.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.7 1999/04/19 20:58:30 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.12 1999/04/25 15:50:19 niklas Exp $	*/
d697 4
d702 1
@


1.7
log
@./pf_key_v2.c: Merge with EOM 1.11

exchange_establish do checking of existing exchanges these days

Remove SA_FLAG_REPLACED settings from various parts in preparation of a
grand unified setting in exchange_finalize.  Fix sa_mark_replaced to not
release a referance to the sa, and adjust the API as it won't get called
as a finalize func anymore.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.6 1999/04/05 20:59:22 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.11 1999/04/15 18:55:08 niklas Exp $	*/
a57 4

/* Rounding needed for PF_ROUTE.  XXX Really OpenBSD-specific.  */
#define ROUNDUP(a) \
  ((a) > 0 ? (1 + (((a) - 1) | (sizeof (long) - 1))) : sizeof (long))
@


1.6
log
@Merge with EOM 1.9
Typecast correct

Get a private copy of connection names that should live forever.

New finalize API.

Make "Connections" handling nicer, and even implement it for KLIPS.
A stab at reregestering the on-demand routes for PF_ENCAP.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.5 1999/03/31 23:48:19 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.9 1999/04/05 20:36:45 niklas Exp $	*/
d1164 1
a1164 1
   * If the SA was incoming and it has not yet been replaced, remove the
d1278 1
a1278 1
pf_key_v2_stayalive (void *vconn, int fail)
d1396 1
a1396 9
    {
      /* If we are already renegotiating, don't start over.  */
      if (!exchange_lookup_by_name (sa->name, 2))
	{
	  sa_reference (sa);
	  exchange_establish (sa->name,
			      (void (*) (void *, int))sa_mark_replaced, sa);
	}
    }
@


1.5
log
@Merge with EOM 1.5
Add a connection checker thread, that sees to that required connections
will get restarted if they die for an abnormal reason.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.4 1999/03/31 20:30:38 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.5 1999/03/31 23:34:21 niklas Exp $	*/
d1278 1
a1278 1
pf_key_v2_stayalive (void *vconn)
d1310 3
a1312 1
 * Establish a keying route that will generate ACQUIRE messages on use.
d1317 1
a1317 2
pf_key_v2_route (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr,
		 in_addr_t rmask, u_int32_t spi, in_addr_t dst, char *conn)
d1320 1
d1327 9
a1335 2
  if (!timer_add_event ("pf_key_v2_checker", pf_key_v2_checker, conn, &now))
    log_print ("pf_key_v2_route: could not add timer event");
d1401 2
a1402 2
	  exchange_establish (sa->name, (void (*) (void *))sa_mark_replaced,
			      sa);
@


1.4
log
@Merge with EOM 1.4
Use SA refcounting where needed.  Until we have ACQUIRES do phase 2
connections automatically at startup.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.3 1999/03/31 14:27:38 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.4 1999/03/31 20:24:25 niklas Exp $	*/
d63 3
d70 3
d1291 1
a1291 1
pf_key_v2_startup (void *vconn)
d1293 14
a1306 1
  exchange_establish ((char *)vconn, pf_key_v2_stayalive, vconn);
d1325 1
a1325 1
  if (!timer_add_event ("pf_key_v2_startup", pf_key_v2_startup, conn, &now))
@


1.3
log
@ipsec.c: Merge with EOM 1.86
ipsec.h: Merge with EOM 1.33
pf_encap.c: Merge with EOM 1.52
pf_key_v2.c: Merge with EOM 1.3

Fix case of missing client ID payloads, a case the standards allow.  Thanks
to Michael Paddon (mwp@@aba.net.au) for the diffs I based my fix upon.  His
diff also made me realize I stored the address information in host order in
internal structures where I had planned to use network order.  Fix this,
and remove the XXXes I had due to this elsewhere.  Add commentary.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.2 1999/03/31 01:53:00 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.3 1999/03/31 14:19:54 niklas Exp $	*/
d1271 19
d1291 1
a1291 1
 * Establish an on-demand keying route.
d1299 10
a1308 2
  log_print ("pf_key_v2_route: not implemented");
  return -1;
d1311 1
d1332 1
a1332 1
  /* XXX IPv4 specific */
d1371 5
a1375 1
	exchange_establish (sa->name, (void (*) (void *))sa_mark_replaced, sa);
@


1.2
log
@Merge with EOM 1.2
Use flow replacment openbsd extension.  Deleted flows when deleting SAs.
Handle expirations.  General cleanup.
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.1 1999/03/24 14:37:13 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.2 1999/03/31 01:32:57 niklas Exp $	*/
d1122 2
a1123 4
  /* XXX Check why byte ordering is backwards.  */
  return pf_key_v2_flow (htonl (isa->src_net), htonl (isa->src_mask),
			 htonl (isa->dst_net), htonl (isa->dst_mask),
			 proto->spi[0], proto->proto,
d1138 2
a1139 4
  /* XXX Check why byte ordering is backwards.  */
  return pf_key_v2_flow (htonl (isa->src_net), htonl (isa->src_mask),
			 htonl (isa->dst_net), htonl (isa->dst_mask),
			 proto->spi[0], proto->proto,
@


1.1
log
@Initial PF_KEYv2 support
@
text
@d1 2
a2 2
/*	$OpenBSD: pf_key_v2.c,v 1.1 1999/03/24 11:09:18 niklas Exp $	*/
/*	$EOM: pf_key_v2.c,v 1.1 1999/03/24 11:09:18 niklas Exp $	*/
d38 1
d50 1
a82 1
						  struct pf_key_v2_node *,
d362 1
a362 4
/*
 * Find the next TYPE extension in MSG starting from EXT, unless EXT is zero
 * which means find the first.  Return zero if none found.
 */
d364 1
a364 2
pf_key_v2_find_ext (struct pf_key_v2_msg *msg, struct pf_key_v2_node *ext,
		    u_int16_t type)
d366 3
a368 1
  for (ext = TAILQ_NEXT (ext ? ext : TAILQ_FIRST (msg), link); ext;
d551 1
a551 1
  sa = (struct sadb_sa *)pf_key_v2_find_ext (ret, 0, SADB_EXT_SA)->seg;
d912 3
a914 2
 * Delete the IPSec SA represented by the INCOMING direction in protocol PROTO
 * of the IKE security association SA.
d916 4
a919 2
int
pf_key_v2_delete_spi (struct sa *sa, struct proto *proto, int incoming)
d921 2
a922 1
  struct sadb_msg msg; 
d925 3
a927 3
  struct sockaddr *saddr;
  int saddrlen, len, err;
  struct pf_key_v2_msg *delete = 0, *ret = 0;
d929 2
a930 2
  msg.sadb_msg_type = SADB_DELETE;
  switch (proto->proto)
d939 1
a939 1
      log_print ("pf_key_v2_delete_spi: invalid proto %d", proto->proto);
d943 2
a944 2
  delete = pf_key_v2_msg_new (&msg, 0);
  if (!delete)
d950 1
a950 1
  memcpy (&ssa.sadb_sa_spi, proto->spi[incoming], sizeof ssa.sadb_sa_spi);
d955 8
a962 2
  ssa.sadb_sa_flags = 0;
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)&ssa, 0) == -1)
d970 65
a1034 5
  if (incoming)
    sa->transport->vtbl->get_dst (sa->transport, &saddr, &saddrlen);
  else
    sa->transport->vtbl->get_src (sa->transport, &saddr, &saddrlen);
  len = sizeof *addr + PF_KEY_V2_ROUND (saddrlen);
d1038 1
a1038 1
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_SRC;
d1045 4
a1048 1
  memcpy (addr + 1, saddr, saddrlen);
d1050 1
a1050 1
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)addr,
a1054 5
  if (incoming)
    sa->transport->vtbl->get_src (sa->transport, &saddr, &saddrlen);
  else
    sa->transport->vtbl->get_dst (sa->transport, &saddr, &saddrlen);
  len = sizeof *addr + PF_KEY_V2_ROUND (saddrlen);
d1058 1
a1058 1
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
d1065 4
a1068 1
  memcpy (addr + 1, saddr, saddrlen);
d1070 1
a1070 1
  if (pf_key_v2_msg_add (delete, (struct sadb_ext *)addr,
d1075 6
a1080 3
  ret = pf_key_v2_call (delete);
  pf_key_v2_msg_free (delete);
  delete = 0;
d1086 2
a1087 1
      log_print ("pf_key_v2_delete_spi: DELETE: %s", strerror (err));
d1092 1
a1092 1
  log_debug (LOG_MISC, 50, "pf_key_v2_delete_spi: done");
d1099 2
a1100 2
  if (delete)
    pf_key_v2_msg_free (delete);
d1104 5
d1123 22
a1144 4
  return pf_key_v2_enable_spi (htonl (isa->src_net), htonl (isa->src_mask),
			       htonl (isa->dst_net), htonl (isa->dst_mask),
			       proto->spi[0], proto->proto,
			       ((struct sockaddr_in *)dst)->sin_addr.s_addr);
d1148 2
a1149 2
 * Enable a flow.
 * XXX Assumes OpenBSD ADDFLOW extension.  Should probably be moved to sysdep.c
d1152 1
a1152 3
pf_key_v2_enable_spi (in_addr_t laddr, in_addr_t lmask, in_addr_t raddr,
		      in_addr_t rmask, u_int8_t *spi, u_int8_t proto,
		      in_addr_t dst)
d1154 1
a1154 2
#ifdef SADB_X_ADDFLOW
  struct sadb_msg msg;
d1157 11
a1167 3
  struct pf_key_v2_msg *addflow = 0, *ret = 0;
  size_t len;
  int err;
d1169 2
a1170 2
  msg.sadb_msg_type = SADB_X_ADDFLOW;
  switch (proto)
d1179 1
a1179 1
      log_print ("pf_key_v2_delete_spi: invalid proto %d", proto);
d1183 2
a1184 2
  addflow = pf_key_v2_msg_new (&msg, 0);
  if (!addflow)
d1190 1
a1190 1
  memcpy (&ssa.sadb_sa_spi, spi, sizeof ssa.sadb_sa_spi);
d1195 2
a1196 6
  /*
   * XXX The LOCALFLOW flag should only be set if this machine is part of the
   * source subnet.
   */
  ssa.sadb_sa_flags = SADB_SAFLAGS_X_LOCALFLOW;
  if (pf_key_v2_msg_add (addflow, (struct sadb_ext *)&ssa, 0) == -1)
d1204 5
a1208 1
  len = sizeof *addr + PF_KEY_V2_ROUND (sizeof (struct sockaddr_in));
d1212 1
a1212 1
  addr->sadb_address_exttype = SADB_EXT_ADDRESS_DST;
d1219 1
a1219 4
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = dst;
d1221 1
a1221 1
  if (pf_key_v2_msg_add (addflow, (struct sadb_ext *)addr,
d1226 5
d1234 1
a1234 1
  addr->sadb_address_exttype = SADB_EXT_X_SRC_FLOW;
d1241 1
a1241 4
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = laddr;
d1243 1
a1243 1
  if (pf_key_v2_msg_add (addflow, (struct sadb_ext *)addr,
d1248 3
a1250 66
  addr = malloc (len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_X_SRC_MASK;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
#if 0
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
  addr->sadb_address_reserved = 0;
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = lmask;
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
  if (pf_key_v2_msg_add (addflow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = malloc (len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_X_DST_FLOW;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
#if 0
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
  addr->sadb_address_reserved = 0;
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = raddr;
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
  if (pf_key_v2_msg_add (addflow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  addr = malloc (len);
  if (!addr)
    goto cleanup;
  addr->sadb_address_exttype = SADB_EXT_X_DST_MASK;
  addr->sadb_address_len = len / PF_KEY_V2_CHUNK;
#if 0
  addr->sadb_address_proto = 0;
  addr->sadb_address_prefixlen = 0;
#endif
  addr->sadb_address_reserved = 0;
  memset (addr + 1, '\0', sizeof (struct sockaddr_in));
  ((struct sockaddr_in *)(addr + 1))->sin_len = sizeof (struct sockaddr_in);
  ((struct sockaddr_in *)(addr + 1))->sin_family = AF_INET;
  ((struct sockaddr_in *)(addr + 1))->sin_addr.s_addr = rmask;
  ((struct sockaddr_in *)(addr + 1))->sin_port = 0;
  if (pf_key_v2_msg_add (addflow, (struct sadb_ext *)addr,
			 PF_KEY_V2_NODE_MALLOCED) == -1)
    goto cleanup;
  addr = 0;

  log_debug (LOG_SYSDEP, 50, "pf_key_v2_enable_spi: src %x %x dst %x %x",
	     laddr, lmask, raddr, rmask);

  ret = pf_key_v2_call (addflow);
  pf_key_v2_msg_free (addflow);
  addflow = 0;
d1256 1
a1256 1
      log_print ("pf_key_v2_enable_spi: ADDFLOW: %s", strerror (err));
d1261 1
a1261 1
  log_debug (LOG_MISC, 50, "pf_key_v2_enable_spi: done");
d1268 2
a1269 2
  if (addflow)
    pf_key_v2_msg_free (addflow);
a1272 5

#else
  log_error ("pf_key_v2_enable_spi: not supported in pure PF_KEYv2");
  return -1;
#endif
d1276 1
a1276 1
 * Establish an encap route.
d1289 75
d1366 5
a1370 1
  log_debug (LOG_SYSDEP, 80, "pf_key_v2_notify: entered");
d1372 4
a1375 1
  /* XXX To be implemented.  */
d1377 4
d1388 15
@

