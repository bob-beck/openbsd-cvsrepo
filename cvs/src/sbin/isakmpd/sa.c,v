head	1.123;
access;
symbols
	OPENBSD_6_1_BASE:1.123
	OPENBSD_6_0:1.123.0.4
	OPENBSD_6_0_BASE:1.123
	OPENBSD_5_9:1.123.0.2
	OPENBSD_5_9_BASE:1.123
	OPENBSD_5_8:1.121.0.6
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.121.0.2
	OPENBSD_5_7_BASE:1.121
	OPENBSD_5_6:1.120.0.6
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.120.0.4
	OPENBSD_5_5_BASE:1.120
	OPENBSD_5_4:1.117.0.6
	OPENBSD_5_4_BASE:1.117
	OPENBSD_5_3:1.117.0.4
	OPENBSD_5_3_BASE:1.117
	OPENBSD_5_2:1.117.0.2
	OPENBSD_5_2_BASE:1.117
	OPENBSD_5_1_BASE:1.116
	OPENBSD_5_1:1.116.0.2
	OPENBSD_5_0:1.115.0.4
	OPENBSD_5_0_BASE:1.115
	OPENBSD_4_9:1.115.0.2
	OPENBSD_4_9_BASE:1.115
	OPENBSD_4_8:1.113.0.12
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.113.0.8
	OPENBSD_4_7_BASE:1.113
	OPENBSD_4_6:1.113.0.10
	OPENBSD_4_6_BASE:1.113
	OPENBSD_4_5:1.113.0.6
	OPENBSD_4_5_BASE:1.113
	OPENBSD_4_4:1.113.0.4
	OPENBSD_4_4_BASE:1.113
	OPENBSD_4_3:1.113.0.2
	OPENBSD_4_3_BASE:1.113
	OPENBSD_4_2:1.112.0.2
	OPENBSD_4_2_BASE:1.112
	OPENBSD_4_1:1.110.0.2
	OPENBSD_4_1_BASE:1.110
	OPENBSD_4_0:1.109.0.2
	OPENBSD_4_0_BASE:1.109
	OPENBSD_3_9:1.102.0.2
	OPENBSD_3_9_BASE:1.102
	OPENBSD_3_8:1.101.0.2
	OPENBSD_3_8_BASE:1.101
	OPENBSD_3_7:1.90.0.2
	OPENBSD_3_7_BASE:1.90
	OPENBSD_3_6:1.86.0.2
	OPENBSD_3_6_BASE:1.86
	OPENBSD_3_5:1.77.0.2
	OPENBSD_3_5_BASE:1.77
	OPENBSD_3_4:1.73.0.2
	OPENBSD_3_4_BASE:1.73
	OPENBSD_3_3:1.65.0.2
	OPENBSD_3_3_BASE:1.65
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.54.0.2
	OPENBSD_3_1_BASE:1.54
	OPENBSD_3_0:1.48.0.2
	OPENBSD_3_0_BASE:1.48
	OPENBSD_2_9:1.41.0.2
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	NIKLAS_981114:1.1.1.1
	NIKLAS:1.1.1;
locks; strict;
comment	@ * @;


1.123
date	2015.12.09.21.41.50;	author naddy;	state Exp;
branches;
next	1.122;
commitid	CLwtYUTkBZ3FXV1w;

1.122
date	2015.08.20.22.02.21;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	0qPuuXwccpVXsXcV;

1.121
date	2014.10.09.02.38.56;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	lHB12E9VkXKsWY0B;

1.120
date	2014.01.23.01.04.28;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2014.01.22.03.09.31;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2013.11.21.22.25.01;	author yasuoka;	state Exp;
branches;
next	1.117;

1.117
date	2012.06.30.14.51.31;	author naddy;	state Exp;
branches;
next	1.116;

1.116
date	2012.01.16.08.45.55;	author eric;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.09.12.46.11;	author martinh;	state Exp;
branches;
next	1.114;

1.114
date	2010.09.22.13.45.16;	author mikeb;	state Exp;
branches;
next	1.113;

1.113
date	2007.09.02.15.19.24;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2007.06.02.01.29.12;	author pvalchev;	state Exp;
branches;
next	1.111;

1.111
date	2007.04.16.13.01.39;	author moritz;	state Exp;
branches;
next	1.110;

1.110
date	2006.11.24.13.52.14;	author reyk;	state Exp;
branches;
next	1.109;

1.109
date	2006.08.30.16.33.31;	author cloder;	state Exp;
branches;
next	1.108;

1.108
date	2006.06.02.19.35.55;	author hshoexer;	state Exp;
branches;
next	1.107;

1.107
date	2006.05.31.04.54.46;	author hshoexer;	state Exp;
branches;
next	1.106;

1.106
date	2006.05.29.14.31.39;	author hshoexer;	state Exp;
branches;
next	1.105;

1.105
date	2006.05.29.07.02.10;	author mcbride;	state Exp;
branches;
next	1.104;

1.104
date	2006.05.28.19.08.11;	author mcbride;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.28.17.40.21;	author hshoexer;	state Exp;
branches;
next	1.102;

1.102
date	2005.09.23.14.44.03;	author hshoexer;	state Exp;
branches;
next	1.101;

1.101
date	2005.08.09.12.50.08;	author hshoexer;	state Exp;
branches;
next	1.100;

1.100
date	2005.07.25.14.56.42;	author hshoexer;	state Exp;
branches;
next	1.99;

1.99
date	2005.07.22.11.36.43;	author hshoexer;	state Exp;
branches;
next	1.98;

1.98
date	2005.04.08.23.15.26;	author hshoexer;	state Exp;
branches;
next	1.97;

1.97
date	2005.04.08.22.32.10;	author cloder;	state Exp;
branches;
next	1.96;

1.96
date	2005.04.08.17.15.01;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.08.16.52.41;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2005.04.08.16.37.15;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2005.04.06.16.00.20;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2005.04.06.00.02.56;	author cloder;	state Exp;
branches;
next	1.91;

1.91
date	2005.04.04.19.31.11;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2005.02.27.13.12.12;	author hshoexer;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.24.16.16.46;	author markus;	state Exp;
branches;
next	1.88;

1.88
date	2005.02.16.22.00.14;	author hshoexer;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.30.12.36.13;	author hshoexer;	state Exp;
branches;
next	1.86;

1.86
date	2004.08.10.15.59.10;	author ho;	state Exp;
branches;
next	1.85;

1.85
date	2004.08.08.19.11.06;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2004.08.02.15.48.22;	author hshoexer;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.21.23.27.10;	author ho;	state Exp;
branches;
next	1.82;

1.82
date	2004.05.23.18.17.56;	author hshoexer;	state Exp;
branches;
next	1.81;

1.81
date	2004.05.13.06.56.34;	author ho;	state Exp;
branches;
next	1.80;

1.80
date	2004.04.15.18.39.26;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2004.04.07.22.45.49;	author ho;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.07.20.04.34;	author ho;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.19.14.04.43;	author hshoexer;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.27.10.16.26;	author ho;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.27.09.01.19;	author ho;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.06.00.22.48;	author hshoexer;	state Exp;
branches;
next	1.73;

1.73
date	2003.07.25.08.31.16;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.04.07.31.17;	author ho;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.03.12.51.39;	author ho;	state Exp;
branches;
next	1.70;

1.70
date	2003.05.18.20.39.25;	author ho;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.16.20.31.16;	author ho;	state Exp;
branches;
next	1.68;

1.68
date	2003.05.15.02.28.56;	author ho;	state Exp;
branches;
next	1.67;

1.67
date	2003.05.14.17.37.22;	author ho;	state Exp;
branches;
next	1.66;

1.66
date	2003.05.12.21.43.22;	author ho;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.21.12.09.20;	author ho;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.08.12.38.04;	author ho;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.10.18.08.58;	author ho;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.09.08.13.07;	author todd;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.07.15.59.37;	author ho;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.07.15.24.22;	author ho;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.06.15.40.09;	author ho;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.06.02.15.27;	author ho;	state Exp;
branches;
next	1.57;

1.57
date	2002.06.01.07.44.22;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.28.10.09.46;	author ho;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.23.13.58.57;	author ho;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.17.21.50.59;	author angelos;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.17.21.48.06;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.25.13.46.22;	author ho;	state Exp;
branches;
next	1.51;

1.51
date	2001.11.21.10.01.43;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.21.09.59.26;	author ho;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.26.13.29.26;	author ho;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.15.13.06.53;	author ho;	state Exp;
branches;
next	1.47;

1.47
date	2001.07.05.12.36.55;	author ho;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.01.19.48.44;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.29.18.52.17;	author ho;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.29.18.12.07;	author ho;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.07.03.20.21;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.31.20.25.37;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.24.07.27.37;	author niklas;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.04.09.22.09.52;	author ho;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.06.22.18.48;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.24.04.42.48;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.27.12.03.36;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.26.12.12.52;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.22.08.14.24;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.14.23.40.01;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2000.12.12.01.47.12;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.16.23.27.43;	author niklas;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.08.03.07.28.44;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.03.07.24.23;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2000.06.08.20.51.11;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.02.14.36.04;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.07.22.10.30;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.07.22.06.44;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.25.17.23.38;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.01.02.46.18;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	99.08.26.22.27.51;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.07.07.22.10.11;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.06.02.06.29.35;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.05.14.20.09.50;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	99.05.06.22.44.42;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.05.01.22.58.02;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.04.30.11.46.06;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.04.27.20.59.46;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.04.20.11.32.21;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.19.20.53.05;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.04.05.20.59.05;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.04.02.01.08.51;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.03.31.20.31.05;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.03.31.00.52.06;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	99.03.24.14.41.17;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.03.02.15.48.23;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.02.26.03.50.09;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.12.21.01.02.27;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.11.20.07.31.56;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	98.11.17.22.36.20;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.11.17.11.10.19;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	98.11.15.00.44.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.11.15.00.03.49;	author niklas;	state Exp;
branches;
next	;

1.32.2.1
date	2001.05.08.12.45.25;	author ho;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.06.07.20.32.44;	author miod;	state Exp;
branches;
next	;

1.41.2.1
date	2001.06.07.04.33.37;	author jason;	state Exp;
branches;
next	;


desc
@@


1.123
log
@Remove plain DES encryption from IPsec.

DES is insecure since brute force attacks are practical due to its
short key length.

This removes support for DES-CBC encryption in ESP and in IKE main
and quick mode from the kernel, isakmpd(8), ipsecctl(8), and iked(8).

ok mikeb@@
@
text
@/* $OpenBSD: sa.c,v 1.122 2015/08/20 22:02:21 deraadt Exp $	 */
/* $EOM: sa.c,v 1.112 2000/12/12 00:22:52 niklas Exp $	 */

/*
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2001 Angelos D. Keromytis.  All rights reserved.
 * Copyright (c) 2003, 2004 Håkan Olsson.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This code was written under funding by Ericsson Radio Systems.
 */

#include <sys/types.h>
#include <sys/un.h>

#include <stdlib.h>
#include <string.h>
#include <netdb.h>

#include <regex.h>
#include <keynote.h>

#include "attribute.h"
#include "conf.h"
#include "connection.h"
#include "cookie.h"
#include "doi.h"
#include "dpd.h"
#include "exchange.h"
#include "isakmp.h"
#include "log.h"
#include "message.h"
#include "monitor.h"
#include "sa.h"
#include "timer.h"
#include "transport.h"
#include "util.h"
#include "cert.h"
#include "policy.h"
#include "key.h"
#include "ipsec.h"
#include "ipsec_num.h"

/* Initial number of bits from the cookies used as hash.  */
#define INITIAL_BUCKET_BITS 6

/*
 * Don't try to use more bits than this as a hash.
 * We only XOR 16 bits so going above that means changing the code below
 * too.
 */
#define MAX_BUCKET_BITS 16

#if 0
static void     sa_resize(void);
#endif
static void     sa_soft_expire(void *);
static void     sa_hard_expire(void *);

static int	_net_addrcmp(struct sockaddr *, struct sockaddr *);

static		LIST_HEAD(sa_list, sa) *sa_tab;

/* Works both as a maximum index and a mask.  */
static int      bucket_mask;

void
sa_init(void)
{
	int	i;

	bucket_mask = (1 << INITIAL_BUCKET_BITS) - 1;
	sa_tab = calloc(bucket_mask + 1, sizeof(struct sa_list));
	if (!sa_tab)
		log_fatal("sa_init: malloc (%lu) failed",
		    (bucket_mask + 1) * (unsigned long)sizeof(struct sa_list));
	for (i = 0; i <= bucket_mask; i++)
		LIST_INIT(&sa_tab[i]);
}

#if 0
/* XXX We don't yet resize.  */
static void
sa_resize(void)
{
	int	new_mask = (bucket_mask + 1) * 2 - 1;
	int	i;
	struct sa_list *new_tab;

	new_tab = reallocarray(sa_tab, new_mask + 1, sizeof(struct sa_list));
	if (!new_tab)
		return;
	sa_tab = new_tab;
	for (i = bucket_mask + 1; i <= new_mask; i++)
		LIST_INIT(&sa_tab[i]);
	bucket_mask = new_mask;

	/* XXX Rehash existing entries.  */
}
#endif

/* Lookup an SA with the help from a user-supplied checking function.  */
struct sa *
sa_find(int (*check) (struct sa*, void *), void *arg)
{
	int             i;
	struct sa      *sa;

	for (i = 0; i <= bucket_mask; i++)
		for (sa = LIST_FIRST(&sa_tab[i]); sa; sa = LIST_NEXT(sa, link))
			if (check(sa, arg)) {
				LOG_DBG((LOG_SA, 90, "sa_find: return SA %p",
				    sa));
				return sa;
			}
	LOG_DBG((LOG_SA, 90, "sa_find: no SA matched query"));
	return 0;
}

/* Check if SA is an ISAKMP SA with an initiator cookie equal to ICOOKIE.  */
static int
sa_check_icookie(struct sa *sa, void *icookie)
{
	return sa->phase == 1 &&
	    memcmp(sa->cookies, icookie, ISAKMP_HDR_ICOOKIE_LEN) == 0;
}

/* Lookup an ISAKMP SA out of just the initiator cookie.  */
struct sa *
sa_lookup_from_icookie(u_int8_t *cookie)
{
	return sa_find(sa_check_icookie, cookie);
}

struct name_phase_arg {
	char           *name;
	u_int8_t        phase;
};

/* Check if SA has the name and phase given by V_ARG.  */
static int
sa_check_name_phase(struct sa *sa, void *v_arg)
{
	struct name_phase_arg *arg = v_arg;

	return sa->name && strcasecmp(sa->name, arg->name) == 0 &&
	    sa->phase == arg->phase && !(sa->flags & SA_FLAG_REPLACED);
}

/* Lookup an SA by name, case-independent, and phase.  */
struct sa *
sa_lookup_by_name(char *name, int phase)
{
	struct name_phase_arg arg;

	arg.name = name;
	arg.phase = phase;
	return sa_find(sa_check_name_phase, &arg);
}

struct addr_arg {
	struct sockaddr *addr;
	socklen_t       len;
	int             phase;
	int             flags;
};

/*
 * This function has been removed from libc and put here as this
 * file is the only user for it.
 */
static int
_net_addrcmp(struct sockaddr *sa1, struct sockaddr *sa2)
{

	if (sa1->sa_len != sa2->sa_len)
		return (sa1->sa_len < sa2->sa_len) ? -1 : 1;
	if (sa1->sa_family != sa2->sa_family)
		return (sa1->sa_family < sa2->sa_family) ? -1 : 1;

	switch(sa1->sa_family) {
	case AF_INET:
		return (memcmp(&((struct sockaddr_in *)sa1)->sin_addr,
		    &((struct sockaddr_in *)sa2)->sin_addr,
		    sizeof(struct in_addr)));
	case AF_INET6:
		if (((struct sockaddr_in6 *)sa1)->sin6_scope_id !=
		    ((struct sockaddr_in6 *)sa2)->sin6_scope_id)
			return (((struct sockaddr_in6 *)sa1)->sin6_scope_id < 
			    ((struct sockaddr_in6 *)sa2)->sin6_scope_id)
			    ? -1 : 1;
		return memcmp(&((struct sockaddr_in6 *)sa1)->sin6_addr,
		    &((struct sockaddr_in6 *)sa2)->sin6_addr,
		    sizeof(struct in6_addr));
	case AF_LOCAL:
		return (strcmp(((struct sockaddr_un *)sa1)->sun_path,
		    ((struct sockaddr_un *)sa2)->sun_path));
	default:
		return -1;
	}
}

/*
 * Check if SA is ready and has a peer with an address equal the one given
 * by V_ADDR.  Furthermore if we are searching for a specific phase, check
 * that too.
 */
static int
sa_check_peer(struct sa *sa, void *v_addr)
{
	struct addr_arg *addr = v_addr;
	struct sockaddr *dst;

	if (!sa->transport || (sa->flags & SA_FLAG_READY) == 0 ||
	    (addr->phase && addr->phase != sa->phase))
		return 0;

	sa->transport->vtbl->get_dst(sa->transport, &dst);
	if (_net_addrcmp(dst, addr->addr) != 0)
		return 0;

	/* same family, length and address, check port if inet/inet6 */
	switch (dst->sa_family) {
	case AF_INET:
		return ((struct sockaddr_in *)dst)->sin_port == ((struct sockaddr_in *)addr->addr)->sin_port;
	case AF_INET6:
		return ((struct sockaddr_in6 *)dst)->sin6_port == ((struct sockaddr_in6 *)addr->addr)->sin6_port;
	}

	return 1;
}

struct dst_isakmpspi_arg {
	struct sockaddr *dst;
	u_int8_t       *spi;	/* must be ISAKMP_SPI_SIZE octets */
};

/*
 * Check if SA matches what we are asking for through V_ARG.  It has to
 * be a finished phase 1 (ISAKMP) SA.
 */
static int
isakmp_sa_check(struct sa *sa, void *v_arg)
{
	struct dst_isakmpspi_arg *arg = v_arg;
	struct sockaddr		*dst, *src;

	if (sa->phase != 1 || !(sa->flags & SA_FLAG_READY))
		return 0;

	/* verify address is either src or dst for this sa */
	sa->transport->vtbl->get_dst(sa->transport, &dst);
	sa->transport->vtbl->get_src(sa->transport, &src);
	if (memcmp(src, arg->dst, SA_LEN(src)) &&
	    memcmp(dst, arg->dst, SA_LEN(dst)))
		return 0;

	/* match icookie+rcookie against spi */
	if (memcmp(sa->cookies, arg->spi, ISAKMP_HDR_COOKIES_LEN) == 0)
		return 1;

	return 0;
}

/*
 * Find an ISAKMP SA with a "name" of DST & SPI.
 */
struct sa *
sa_lookup_isakmp_sa(struct sockaddr *dst, u_int8_t *spi)
{
	struct dst_isakmpspi_arg arg;

	arg.dst = dst;
	arg.spi = spi;

	return sa_find(isakmp_sa_check, &arg);
}

/* Lookup a ready SA by the peer's address.  */
struct sa *
sa_lookup_by_peer(struct sockaddr *dst, socklen_t dstlen, int phase)
{
	struct addr_arg arg;

	arg.addr = dst;
	arg.len = dstlen;
	arg.phase = phase;

	return sa_find(sa_check_peer, &arg);
}

/* Lookup a ready ISAKMP SA given its peer address.  */
struct sa *
sa_isakmp_lookup_by_peer(struct sockaddr *dst, socklen_t dstlen)
{
	struct addr_arg arg;

	arg.addr = dst;
	arg.len = dstlen;
	arg.phase = 1;

	return sa_find(sa_check_peer, &arg);
}

int
sa_enter(struct sa *sa)
{
	u_int16_t       bucket = 0;
	int             i;
	u_int8_t       *cp;

	/* XXX We might resize if we are crossing a certain threshold */

	for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2) {
		cp = sa->cookies + i;
		/* Doing it this way avoids alignment problems.  */
		bucket ^= cp[0] | cp[1] << 8;
	}
	for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2) {
		cp = sa->message_id + i;
		/* Doing it this way avoids alignment problems.  */
		bucket ^= cp[0] | cp[1] << 8;
	}
	bucket &= bucket_mask;
	LIST_INSERT_HEAD(&sa_tab[bucket], sa, link);
	sa_reference(sa);
	LOG_DBG((LOG_SA, 70, "sa_enter: SA %p added to SA list", sa));
	return 1;
}

/*
 * Lookup the SA given by the header fields MSG.  PHASE2 is false when
 * looking for phase 1 SAa and true otherwise.
 */
struct sa *
sa_lookup_by_header(u_int8_t *msg, int phase2)
{
	return sa_lookup(msg + ISAKMP_HDR_COOKIES_OFF,
	    phase2 ? msg + ISAKMP_HDR_MESSAGE_ID_OFF : 0);
}

/*
 * Lookup the SA given by the COOKIES and possibly the MESSAGE_ID unless
 * a null pointer, meaning we are looking for phase 1 SAs.
 */
struct sa *
sa_lookup(u_int8_t *cookies, u_int8_t *message_id)
{
	u_int16_t       bucket = 0;
	int             i;
	struct sa      *sa;
	u_int8_t       *cp;

	/*
	 * We use the cookies to get bits to use as an index into sa_tab, as at
	 * least one (our cookie) is a good hash, xoring all the bits, 16 at a
	 * time, and then masking, should do.  Doing it this way means we can
	 * validate cookies very fast thus delimiting the effects of "Denial of
	 * service"-attacks using packet flooding.
	 */
	for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2) {
		cp = cookies + i;
		/* Doing it this way avoids alignment problems.  */
		bucket ^= cp[0] | cp[1] << 8;
	}
	if (message_id)
		for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2) {
			cp = message_id + i;
			/* Doing it this way avoids alignment problems.  */
			bucket ^= cp[0] | cp[1] << 8;
		}
	bucket &= bucket_mask;
	for (sa = LIST_FIRST(&sa_tab[bucket]);
	    sa && (memcmp(cookies, sa->cookies, ISAKMP_HDR_COOKIES_LEN) != 0 ||
	    (message_id && memcmp(message_id, sa->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN) != 0) ||
	    (!message_id && !zero_test(sa->message_id, ISAKMP_HDR_MESSAGE_ID_LEN)));
	    sa = LIST_NEXT(sa, link))
		;

	return sa;
}

/* Create an SA.  */
int
sa_create(struct exchange *exchange, struct transport *t)
{
	struct sa      *sa;

	/*
	 * We want the SA zeroed for sa_free to be able to find out what fields
	 * have been filled-in.
	 */
	sa = calloc(1, sizeof *sa);
	if (!sa) {
		log_error("sa_create: calloc (1, %lu) failed",
		    (unsigned long)sizeof *sa);
		return -1;
	}
	sa->transport = t;
	if (t)
		transport_reference(t);
	sa->phase = exchange->phase;
	memcpy(sa->cookies, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
	memcpy(sa->message_id, exchange->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN);
	sa->doi = exchange->doi;
	sa->policy_id = -1;

	if (sa->doi->sa_size) {
		/*
		 * Allocate the DOI-specific structure and initialize it to
		 * zeroes.
		 */
		sa->data = calloc(1, sa->doi->sa_size);
		if (!sa->data) {
			log_error("sa_create: calloc (1, %lu) failed",
			    (unsigned long)sa->doi->sa_size);
			free(sa);
			return -1;
		}
	}
	TAILQ_INIT(&sa->protos);

	sa_enter(sa);
	TAILQ_INSERT_TAIL(&exchange->sa_list, sa, next);
	sa_reference(sa);

	LOG_DBG((LOG_SA, 60,
	    "sa_create: sa %p phase %d added to exchange %p (%s)", sa,
	    sa->phase, exchange,
	    exchange->name ? exchange->name : "<unnamed>"));
	return 0;
}

/*
 * Dump the internal state of SA to the report channel, with HEADER
 * prepended to each line.
 */
void
sa_dump(int cls, int level, char *header, struct sa *sa)
{
	struct proto   *proto;
	char            spi_header[80];
	int             i;

	LOG_DBG((cls, level, "%s: %p %s phase %d doi %d flags 0x%x", header,
	    sa, sa->name ? sa->name : "<unnamed>", sa->phase, sa->doi->id,
	    sa->flags));
	LOG_DBG((cls, level, "%s: icookie %08x%08x rcookie %08x%08x", header,
	    decode_32(sa->cookies), decode_32(sa->cookies + 4),
	    decode_32(sa->cookies + 8), decode_32(sa->cookies + 12)));
	LOG_DBG((cls, level, "%s: msgid %08x refcnt %d", header,
	    decode_32(sa->message_id), sa->refcnt));
	LOG_DBG((cls, level, "%s: life secs %llu kb %llu", header, sa->seconds,
	    sa->kilobytes));
	for (proto = TAILQ_FIRST(&sa->protos); proto;
	    proto = TAILQ_NEXT(proto, link)) {
		LOG_DBG((cls, level, "%s: suite %d proto %d", header,
		    proto->no, proto->proto));
		LOG_DBG((cls, level,
		    "%s: spi_sz[0] %d spi[0] %p spi_sz[1] %d spi[1] %p",
		    header, proto->spi_sz[0], proto->spi[0], proto->spi_sz[1],
		    proto->spi[1]));
		LOG_DBG((cls, level, "%s: %s, %s", header,
		    !sa->doi ? "<nodoi>" :
		    sa->doi->decode_ids("initiator id: %s, responder id: %s",
		    sa->id_i, sa->id_i_len,
		    sa->id_r, sa->id_r_len, 0),
		    !sa->transport ? "<no transport>" :
		    sa->transport->vtbl->decode_ids(sa->transport)));
		for (i = 0; i < 2; i++)
			if (proto->spi[i]) {
				snprintf(spi_header, sizeof spi_header,
				    "%s: spi[%d]", header, i);
				LOG_DBG_BUF((cls, level, spi_header,
				    proto->spi[i], proto->spi_sz[i]));
			}
	}
}

/*
 * Display the SA's two SPI values.
 */
static void
report_spi(FILE *fd, const u_int8_t *buf, size_t sz, int spi)
{
#define SBUFSZ (2 * 32 + 9)
	char	s[SBUFSZ];
	size_t	i, j;

	for (i = j = 0; i < sz;) {
		snprintf(s + j, sizeof s - j, "%02x", buf[i++]);
		j += strlen(s + j);
		if (i % 4 == 0) {
			if (i % 32 == 0) {
				s[j] = '\0';
				fprintf(fd, "%s", s);
				j = 0;
			} else
				s[j++] = ' ';
		}
	}

	if (j) {
		s[j] = '\0';
		fprintf(fd, "SPI %d: %s\n", spi, s);
	}
}

/*
 * Display the transform names to file.
 * Structure is taken from pf_key_v2.c, pf_key_v2_set_spi.
 * Transform names are taken from /usr/src/sys/crypto/xform.c.
 */
static void
report_proto(FILE *fd, struct proto *proto)
{
	struct ipsec_proto *iproto;
	int	keylen, hashlen;

	switch (proto->proto) {
	case IPSEC_PROTO_IPSEC_ESP:
		keylen = ipsec_esp_enckeylength(proto);
		hashlen = ipsec_esp_authkeylength(proto);
		fprintf(fd, "Transform: IPsec ESP\n");
		fprintf(fd, "Encryption key length: %d\n", keylen);
		fprintf(fd, "Authentication key length: %d\n", hashlen);

		fprintf(fd, "Encryption algorithm: ");
		switch (proto->id) {
		case IPSEC_ESP_3DES:
			fprintf(fd, "3DES\n");
			break;

		case IPSEC_ESP_AES:
			fprintf(fd, "AES (CBC)\n");
			break;

		case IPSEC_ESP_AES_CTR:
			fprintf(fd, "AES (CTR)\n");
			break;

		case IPSEC_ESP_AES_GCM_16:
			fprintf(fd, "AES (GCM)\n");
			break;

		case IPSEC_ESP_AES_GMAC:
			fprintf(fd, "AES (GMAC)\n");
			break;

		case IPSEC_ESP_CAST:
			fprintf(fd, "Cast-128\n");
			break;

		case IPSEC_ESP_BLOWFISH:
			fprintf(fd, "Blowfish\n");
			break;

		default:
			fprintf(fd, "unknown (%d)\n", proto->id);
		}

		fprintf(fd, "Authentication algorithm: ");

		if (!proto->data) {
			fprintf(fd, "none\n");
			break;
		}
		iproto = proto->data;

		switch (iproto->auth) {
		case IPSEC_AUTH_HMAC_MD5:
			fprintf(fd, "HMAC-MD5\n");
			break;

		case IPSEC_AUTH_HMAC_SHA:
			fprintf(fd, "HMAC-SHA1\n");
			break;

		case IPSEC_AUTH_HMAC_RIPEMD:
			fprintf(fd, "HMAC-RIPEMD-160\n");
			break;

		case IPSEC_AUTH_HMAC_SHA2_256:
			fprintf(fd, "HMAC-SHA2-256\n");
			break;

		case IPSEC_AUTH_HMAC_SHA2_384:
			fprintf(fd, "HMAC-SHA2-384\n");
			break;

		case IPSEC_AUTH_HMAC_SHA2_512:
			fprintf(fd, "HMAC-SHA2-512\n");
			break;

		case IPSEC_AUTH_DES_MAC:
		case IPSEC_AUTH_KPDK:
			/* XXX We should be supporting KPDK */
			fprintf(fd, "unknown (%d)", iproto->auth);
			break;

		default:
			fprintf(fd, "none\n");
		}
		break;

	case IPSEC_PROTO_IPSEC_AH:
		hashlen = ipsec_ah_keylength(proto);
		fprintf(fd, "Transform: IPsec AH\n");
		fprintf(fd, "Encryption not used.\n");
		fprintf(fd, "Authentication key length: %d\n", hashlen);

		fprintf(fd, "Authentication algorithm: ");
		switch (proto->id) {
		case IPSEC_AH_MD5:
			fprintf(fd, "HMAC-MD5\n");
			break;

		case IPSEC_AH_SHA:
			fprintf(fd, "HMAC-SHA1\n");
			break;

		case IPSEC_AH_RIPEMD:
			fprintf(fd, "HMAC-RIPEMD-160\n");
			break;

		case IPSEC_AH_SHA2_256:
			fprintf(fd, "HMAC-SHA2-256\n");
			break;

		case IPSEC_AH_SHA2_384:
			fprintf(fd, "HMAC-SHA2-384\n");
			break;

		case IPSEC_AH_SHA2_512:
			fprintf(fd, "HMAC-SHA2-512\n");
			break;

		default:
			fprintf(fd, "unknown (%d)", proto->id);
		}
		break;

	default:
		fprintf(fd, "report_proto: invalid proto %d\n", proto->proto);
	}
}

/*
 * Display SA lifetimes.
 */
static void
report_lifetimes(FILE *fd, struct sa *sa)
{
	long timeout;

	if (sa->seconds)
		fprintf(fd, "Lifetime: %llu seconds\n", sa->seconds);

	if (sa->soft_death) {
		timeout = get_timeout(&sa->soft_death->expiration);
		if (timeout < 0)
			fprintf(fd, "<no soft timeout>\n");
		else
			fprintf(fd, "Soft timeout in %ld seconds\n", timeout);
	}

	if (sa->death) {
		timeout = get_timeout(&sa->death->expiration);
		if (timeout < 0)
			fprintf(fd, "No hard timeout>\n");
		else
			fprintf(fd, "Hard timeout in %ld seconds\n", timeout);
	}

	if (sa->kilobytes)
		fprintf(fd, "Lifetime: %llu kilobytes\n", sa->kilobytes);
}

/*
 * Print phase 1 specific information.
 */
static void
report_phase1(FILE *fd, struct sa *sa)
{
	/* Cookies. */
	fprintf(fd, "icookie %08x%08x rcookie %08x%08x\n",
	    decode_32(sa->cookies), decode_32(sa->cookies + 4),
	    decode_32(sa->cookies + 8), decode_32(sa->cookies + 12));
}

/*
 * Print phase 2 specific information.
 */
static void
report_phase2(FILE *fd, struct sa *sa)
{
	struct proto	*proto;
	int		 i;

	/* Transform information. */
	for (proto = TAILQ_FIRST(&sa->protos); proto;
	    proto = TAILQ_NEXT(proto, link)) {

		/* SPI values. */
		for (i = 0; i < 2; i++)
			if (proto->spi[i])
				report_spi(fd, proto->spi[i],
				    proto->spi_sz[i], i);
			else
				fprintf(fd, "SPI %d not defined.\n", i);

		/* Proto values. */
		report_proto(fd, proto);
	}
}

/* Report all the SAs to the report channel.  */
void
sa_report(void)
{
	struct sa      *sa;
	int             i;

	for (i = 0; i <= bucket_mask; i++)
		for (sa = LIST_FIRST(&sa_tab[i]); sa; sa = LIST_NEXT(sa, link))
			sa_dump(LOG_REPORT, 0, "sa_report", sa);
}

/*
 * Print an SA's connection details to file SA_FILE.
 */
static void
sa_dump_all(FILE *fd, struct sa *sa)
{
	/* SA name and phase. */
	fprintf(fd, "SA name: %s", sa->name ? sa->name : "<unnamed>");
	fprintf(fd, " (Phase %d%s)\n", sa->phase, sa->phase == 1 ?
	    (sa->initiator ? "/Initiator" : "/Responder") : "");

	/* Source and destination IPs. */
	fprintf(fd, "%s", sa->transport == NULL ? "<no transport>" :
	    sa->transport->vtbl->decode_ids(sa->transport));
	fprintf(fd, "\n");

	/* Lifetimes */
	report_lifetimes(fd, sa);

	fprintf(fd, "Flags 0x%08x\n", sa->flags);

	if (sa->phase == 1)
		report_phase1(fd, sa);
	else if (sa->phase == 2)
		report_phase2(fd, sa);
	else {
		/* Should not happen, but... */
		fprintf(fd, "<unknown phase>\n");
	}

	/* SA separator. */
	fprintf(fd, "\n");
}

/* Report info of all SAs to file 'fd'.  */
void
sa_report_all(FILE *fd)
{
	struct sa      *sa;
	int             i;

	for (i = 0; i <= bucket_mask; i++)
		for (sa = LIST_FIRST(&sa_tab[i]); sa; sa = LIST_NEXT(sa, link))
			sa_dump_all(fd, sa);
}

/* Free the protocol structure pointed to by PROTO.  */
void
proto_free(struct proto *proto)
{
	struct proto_attr *pa;
	struct sa      *sa = proto->sa;
	int             i;

	for (i = 0; i < 2; i++)
		if (proto->spi[i]) {
			if (sa->doi->delete_spi)
				sa->doi->delete_spi(sa, proto, i);
			free(proto->spi[i]);
		}
	TAILQ_REMOVE(&sa->protos, proto, link);
	if (proto->data) {
		if (sa->doi && sa->doi->free_proto_data)
			sa->doi->free_proto_data(proto->data);
		free(proto->data);
	}
	if (proto->xf_cnt)
		while ((pa = TAILQ_FIRST(&proto->xfs)) != NULL) {
			free(pa->attrs);
			TAILQ_REMOVE(&proto->xfs, pa, next);
			free(pa);
		}

	LOG_DBG((LOG_SA, 90, "proto_free: freeing %p", proto));
	free(proto);
}

/* Release all resources this SA is using.  */
void
sa_free(struct sa *sa)
{
	if (sa->death) {
		timer_remove_event(sa->death);
		sa->death = 0;
		sa->refcnt--;
	}
	if (sa->soft_death) {
		timer_remove_event(sa->soft_death);
		sa->soft_death = 0;
		sa->refcnt--;
	}
	if (sa->dpd_event) {
		timer_remove_event(sa->dpd_event);
		sa->dpd_event = 0;
	}
	sa_remove(sa);
}

/* Remove the SA from the hash table of live SAs.  */
void
sa_remove(struct sa *sa)
{
	LIST_REMOVE(sa, link);
	LOG_DBG((LOG_SA, 70, "sa_remove: SA %p removed from SA list", sa));
	sa_release(sa);
}

/* Raise the reference count of SA.  */
void
sa_reference(struct sa *sa)
{
	sa->refcnt++;
	LOG_DBG((LOG_SA, 80, "sa_reference: SA %p now has %d references",
	    sa, sa->refcnt));
}

/* Release a reference to SA.  */
void
sa_release(struct sa *sa)
{
	struct cert_handler *handler;
	struct proto   *proto;

	LOG_DBG((LOG_SA, 80, "sa_release: SA %p had %d references",
	    sa, sa->refcnt));

	if (--sa->refcnt)
		return;

	LOG_DBG((LOG_SA, 60, "sa_release: freeing SA %p", sa));

	while ((proto = TAILQ_FIRST(&sa->protos)) != 0)
		proto_free(proto);
	if (sa->data) {
		if (sa->doi && sa->doi->free_sa_data)
			sa->doi->free_sa_data(sa->data);
		free(sa->data);
	}
	free(sa->id_i);
	free(sa->id_r);
	if (sa->recv_cert) {
		handler = cert_get(sa->recv_certtype);
		if (handler)
			handler->cert_free(sa->recv_cert);
	}
	if (sa->sent_cert) {
		handler = cert_get(sa->sent_certtype);
		if (handler)
			handler->cert_free(sa->sent_cert);
	}
	if (sa->recv_key)
		key_free(sa->recv_keytype, ISAKMP_KEYTYPE_PUBLIC,
		    sa->recv_key);
	free(sa->keynote_key);	/* This is just a string */
	if (sa->policy_id != -1)
		kn_close(sa->policy_id);
	free(sa->name);
	free(sa->keystate);
	if (sa->nat_t_keepalive)
		timer_remove_event(sa->nat_t_keepalive);
	if (sa->dpd_event)
		timer_remove_event(sa->dpd_event);
	if (sa->transport)
		transport_release(sa->transport);
	free(sa->tag);
	free(sa);
}

/*
 * Rehash the ISAKMP SA this MSG is negotiating with the responder cookie
 * filled in.
 */
void
sa_isakmp_upgrade(struct message *msg)
{
	struct sa      *sa = TAILQ_FIRST(&msg->exchange->sa_list);

	sa_remove(sa);
	GET_ISAKMP_HDR_RCOOKIE(msg->iov[0].iov_base,
	    sa->cookies + ISAKMP_HDR_ICOOKIE_LEN);

	/*
	 * We don't install a transport in the initiator case as we don't know
	 * what local address will be chosen.  Do it now instead.
	 */
	sa->transport = msg->transport;
	transport_reference(sa->transport);
	sa_enter(sa);
}

#define ATTRS_SIZE (IKE_ATTR_BLOCK_SIZE + 1)	/* XXX Should be dynamic.  */

struct attr_validation_state {
	u_int8_t       *attrp[ATTRS_SIZE];
	u_int8_t        checked[ATTRS_SIZE];
	u_int16_t	len[ATTRS_SIZE];
	int             phase;	/* IKE (1) or IPSEC (2) attrs? */
	int             mode;	/* 0 = 'load', 1 = check */
};

/* Validate an attribute. Return 0 on match.  */
static int
sa_validate_xf_attrs(u_int16_t type, u_int8_t *value, u_int16_t len,
    void *arg)
{
	int val0, val1;

	struct attr_validation_state *avs =
	    (struct attr_validation_state *)arg;

	LOG_DBG((LOG_SA, 95, "sa_validate_xf_attrs: phase %d mode %d type %d "
	    "len %d", avs->phase, avs->mode, type, len));

	/* Make sure the phase and type are valid.  */
	if (avs->phase == 1) {
		if (type < IKE_ATTR_ENCRYPTION_ALGORITHM ||
		    type > IKE_ATTR_BLOCK_SIZE)
			return 1;
	} else if (avs->phase == 2) {
		if (type < IPSEC_ATTR_SA_LIFE_TYPE ||
		    type > IPSEC_ATTR_ECN_TUNNEL)
			return 1;
	} else
		return 1;

	if (avs->mode == 0) {	/* Load attrs.  */
		avs->attrp[type] = value;
		avs->len[type] = len;
		return 0;
	}
	/* Checking for a missing attribute is an immediate failure.  */
	if (!avs->attrp[type])
		return 1;

	/* Match the loaded attribute against this one, mark it as checked.  */
	avs->checked[type]++;
	switch (len) {
	case 2:
		val0 = (int)decode_16(value);
		break;
	case 4:
		val0 = (int)decode_32(value);
		break;
	default:
		return 1;
	}
	switch (avs->len[type]) {
	case 2:
		val1 = (int)decode_16(avs->attrp[type]);
		break;
	case 4:
		val1 = (int)decode_32(avs->attrp[type]);
		break;
	default:
		return 1;
	}
	/* Return 0 when the values are equal. */
	return (val0 != val1);
}

/*
 * This function is used to validate the returned proposal (protection suite)
 * we get from the responder against a proposal we sent. Only run as initiator.
 * We return 0 if a match is found (in any transform of this proposal), 1
 * otherwise. Also see note in sa_add_transform() below.
 */
static int
sa_validate_proto_xf(struct proto *match, struct payload *xf, int phase)
{
	struct attr_validation_state *avs;
	struct proto_attr *pa;
	int             found = 0;
	size_t          i;
	u_int8_t        xf_id;

	if (!match->xf_cnt)
		return 0;

	if (match->proto != GET_ISAKMP_PROP_PROTO(xf->context->p)) {
		LOG_DBG((LOG_SA, 70, "sa_validate_proto_xf: proto %p (#%d) "
		    "protocol mismatch", match, match->no));
		return 1;
	}
	avs = calloc(1, sizeof *avs);
	if (!avs) {
		log_error("sa_validate_proto_xf: calloc (1, %lu)",
		    (unsigned long)sizeof *avs);
		return 1;
	}
	avs->phase = phase;

	/* Load the "proposal candidate" attribute set.  */
	(void)attribute_map(xf->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    GET_ISAKMP_GEN_LENGTH(xf->p) - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
	    sa_validate_xf_attrs, avs);
	xf_id = GET_ISAKMP_TRANSFORM_ID(xf->p);

	/* Check against the transforms we suggested.  */
	avs->mode++;
	for (pa = TAILQ_FIRST(&match->xfs); pa && !found;
	    pa = TAILQ_NEXT(pa, next)) {
		if (xf_id != GET_ISAKMP_TRANSFORM_ID(pa->attrs))
			continue;

		bzero(avs->checked, sizeof avs->checked);
		if (attribute_map(pa->attrs + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		    pa->len - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		    sa_validate_xf_attrs, avs) == 0)
			found++;

		LOG_DBG((LOG_SA, 80, "sa_validate_proto_xf: attr_map "
		    "xf %p proto %p pa %p found %d", xf, match, pa, found));

		if (!found)
			continue;

		/*
		 * Require all attributes present and checked.  XXX perhaps
		 * not?
		 */
		for (i = 0; i < sizeof avs->checked; i++)
			if (avs->attrp[i] && !avs->checked[i])
				found = 0;

		LOG_DBG((LOG_SA, 80, "sa_validate_proto_xf: req_attr "
		    "xf %p proto %p pa %p found %d", xf, match, pa, found));
	}
	free(avs);
	return found ? 0 : 1;
}

/*
 * Register the chosen transform XF into SA.  As a side effect set PROTOP
 * to point at the corresponding proto structure.  INITIATOR is true if we
 * are the initiator.
 */
int
sa_add_transform(struct sa *sa, struct payload *xf, int initiator,
    struct proto **protop)
{
	struct proto   *proto;
	struct payload *prop = xf->context;

	*protop = 0;
	if (!initiator) {
		proto = calloc(1, sizeof *proto);
		if (!proto)
			log_error("sa_add_transform: calloc (1, %lu) failed",
			    (unsigned long)sizeof *proto);
	} else {
		/*
		 * RFC 2408, section 4.2 states the responder SHOULD use the
		 * proposal number from the initiator (i.e us), in it's
		 * selected proposal to make this lookup easier. Most vendors
		 * follow this. One noted exception is the CiscoPIX (and
		 * perhaps other Cisco products).
		 *
		 * We start by matching on the proposal number, as before.
		 */
		for (proto = TAILQ_FIRST(&sa->protos);
		    proto && proto->no != GET_ISAKMP_PROP_NO(prop->p);
		    proto = TAILQ_NEXT(proto, link))
			;
		/*
		 * If we did not find a match, search through all proposals
		 * and xforms.
		 */
		if (!proto || sa_validate_proto_xf(proto, xf, sa->phase) != 0)
			for (proto = TAILQ_FIRST(&sa->protos);
			    proto && sa_validate_proto_xf(proto, xf, sa->phase) != 0;
			    proto = TAILQ_NEXT(proto, link))
				;
	}
	if (!proto)
		return -1;
	*protop = proto;

	/* Allocate DOI-specific part.  */
	if (!initiator) {
		proto->data = calloc(1, sa->doi->proto_size);
		if (!proto->data) {
			log_error("sa_add_transform: calloc (1, %lu) failed",
			    (unsigned long)sa->doi->proto_size);
			goto cleanup;
		}
	}
	proto->no = GET_ISAKMP_PROP_NO(prop->p);
	proto->proto = GET_ISAKMP_PROP_PROTO(prop->p);
	proto->spi_sz[0] = GET_ISAKMP_PROP_SPI_SZ(prop->p);
	if (proto->spi_sz[0]) {
		proto->spi[0] = malloc(proto->spi_sz[0]);
		if (!proto->spi[0])
			goto cleanup;
		memcpy(proto->spi[0], prop->p + ISAKMP_PROP_SPI_OFF,
		    proto->spi_sz[0]);
	}
	proto->chosen = xf;
	proto->sa = sa;
	proto->id = GET_ISAKMP_TRANSFORM_ID(xf->p);
	if (!initiator)
		TAILQ_INSERT_TAIL(&sa->protos, proto, link);

	/* Let the DOI get at proto for initializing its own data.  */
	if (sa->doi->proto_init)
		sa->doi->proto_init(proto, 0);

	LOG_DBG((LOG_SA, 80,
	    "sa_add_transform: "
	    "proto %p no %d proto %d chosen %p sa %p id %d",
	    proto, proto->no, proto->proto, proto->chosen, proto->sa,
	    proto->id));

	return 0;

cleanup:
	if (!initiator) {
		free(proto->data);
		free(proto);
	}
	*protop = 0;
	return -1;
}

/* Delete an SA.  Tell the peer if NOTIFY is set.  */
void
sa_delete(struct sa *sa, int notify)
{
	if (notify)
		message_send_delete(sa);
	sa_free(sa);
}


/* Teardown all SAs.  */
void
sa_teardown_all(void)
{
	int             i;
	struct sa      *sa, *next = 0;

	LOG_DBG((LOG_SA, 70, "sa_teardown_all:"));
	/* Get Phase 2 SAs.  */
	for (i = 0; i <= bucket_mask; i++)
		for (sa = LIST_FIRST(&sa_tab[i]); sa; sa = next) {
			next = LIST_NEXT(sa, link);
			if (sa->phase == 2) {
				/*
				 * Teardown the phase 2 SAs by name, similar
				 * to ui_teardown.
				 */
				LOG_DBG((LOG_SA, 70,
				    "sa_teardown_all: tearing down SA %s",
				    sa->name ? sa->name : "<unnamed>"));
				if (sa->name)
					connection_teardown(sa->name);
				sa_delete(sa, 1);
			}
		}
}

/*
 * This function will get called when we are closing in on the death time of SA
 */
static void
sa_soft_expire(void *v_sa)
{
	struct sa      *sa = v_sa;

	sa->soft_death = 0;
	sa_release(sa);

	if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED)) ==
	    SA_FLAG_STAYALIVE)
		exchange_establish(sa->name, 0, 0, 1);
	else
		/*
		 * Start to watch the use of this SA, so a renegotiation can
		 * happen as soon as it is shown to be alive.
		 */
		sa->flags |= SA_FLAG_FADING;
}

/* SA has passed its best before date.  */
static void
sa_hard_expire(void *v_sa)
{
	struct sa      *sa = v_sa;

	sa->death = 0;
	sa_release(sa);

	if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED)) ==
	    SA_FLAG_STAYALIVE)
		exchange_establish(sa->name, 0, 0, 1);

	sa_delete(sa, 1);
}

void
sa_reinit(void)
{
	struct sa      *sa;
	char           *tag;
	int             i;

	/* For now; only do this if we have the proper tag configured.  */
	tag = conf_get_str("General", "Renegotiate-on-HUP");
	if (!tag)
		return;

	LOG_DBG((LOG_SA, 30, "sa_reinit: renegotiating active connections"));

	/*
	 * Get phase 2 SAs. Soft expire those without active exchanges.  Do
	 * not touch a phase 2 SA where the soft expiration is not set, ie.
	 * the SA is not yet established.
	 */
	for (i = 0; i <= bucket_mask; i++)
		for (sa = LIST_FIRST(&sa_tab[i]); sa; sa = LIST_NEXT(sa, link))
			if (sa->phase == 2)
				if (exchange_lookup_by_name(sa->name,
				    sa->phase) == 0 && sa->soft_death) {
					timer_remove_event(sa->soft_death);
					sa_soft_expire(sa);
				}
}

/*
 * Get an SA attribute's flag value out of textual description.
 */
int
sa_flag(char *attr)
{
	static struct sa_flag_map {
		char           *name;
		int             flag;
	} sa_flag_map[] = {
		{
			"active-only", SA_FLAG_ACTIVE_ONLY
		},

		/*
		 * Below this point are flags that are internal to the
		 * implementation.
		 */
		{
			"__ondemand", SA_FLAG_ONDEMAND
		},
		{
			"ikecfg", SA_FLAG_IKECFG
		},
	};
	size_t	i;

	for (i = 0; i < sizeof sa_flag_map / sizeof sa_flag_map[0]; i++)
		if (strcasecmp(attr, sa_flag_map[i].name) == 0)
			return sa_flag_map[i].flag;
	log_print("sa_flag: attribute \"%s\" unknown", attr);
	return 0;
}

/* Mark SA as replaced.  */
void
sa_mark_replaced(struct sa *sa)
{
	LOG_DBG((LOG_SA, 60, "sa_mark_replaced: SA %p (%s) marked as replaced",
	    sa, sa->name ? sa->name : "unnamed"));
	if (sa->dpd_event) {
		timer_remove_event(sa->dpd_event);
		sa->dpd_event = 0;
	}
	sa->flags |= SA_FLAG_REPLACED;
}

/* Replace SA */
void
sa_replace(struct sa *sa, struct sa *new_sa)
{
	LOG_DBG((LOG_SA, 60, "sa_replace: SA %p (%s) is replaced by SA %p (%s)",
	    sa, sa->name ? sa->name : "unnamed",
	    new_sa, new_sa->name ? new_sa->name : "unnamed"));
	sa_mark_replaced(sa);
	if (new_sa->flags & SA_FLAG_REPLACED) {
		/* enable the dpd */
		if ((new_sa->flags & SA_FLAG_DPD) == SA_FLAG_DPD)
			dpd_start(new_sa);
		new_sa->flags &= ~SA_FLAG_REPLACED;
	}
}

/*
 * Setup expiration timers for SA.  This is used for ISAKMP SAs, but also
 * possible to use for application SAs if the application does not deal
 * with expirations itself.  An example is the Linux FreeS/WAN KLIPS IPsec
 * stack.
 */
int
sa_setup_expirations(struct sa *sa)
{
	struct timeval  expiration;
	u_int64_t       seconds = sa->seconds;

	/*
	 * Set the soft timeout to a random percentage between 85 & 95 of
	 * the negotiated lifetime to break strictly synchronized
	 * renegotiations.  This works better when the randomization is on the
	 * order of processing plus network-roundtrip times, or larger.
	 * I.e. it depends on configuration and negotiated lifetimes.
	 * It is not good to do the decrease on the hard timeout, because then
	 * we may drop our SA before our peer.
	 * XXX Better scheme to come?
	 */
	if (!sa->soft_death) {
		gettimeofday(&expiration, 0);
		/*
		 * XXX This should probably be configuration controlled
		 * somehow.
		 */
		seconds = sa->seconds * (850 + arc4random_uniform(100)) / 1000;
		LOG_DBG((LOG_TIMER, 95,
		    "sa_setup_expirations: SA %p soft timeout in %llu seconds",
		    sa, seconds));
		expiration.tv_sec += seconds;
		sa->soft_death = timer_add_event("sa_soft_expire",
		    sa_soft_expire, sa, &expiration);
		if (!sa->soft_death) {
			/* If we don't give up we might start leaking...  */
			sa_delete(sa, 1);
			return -1;
		}
		sa_reference(sa);
	}
	if (!sa->death) {
		gettimeofday(&expiration, 0);
		LOG_DBG((LOG_TIMER, 95,
		    "sa_setup_expirations: SA %p hard timeout in %llu seconds",
		    sa, sa->seconds));
		expiration.tv_sec += sa->seconds;
		sa->death = timer_add_event("sa_hard_expire", sa_hard_expire,
		    sa, &expiration);
		if (!sa->death) {
			/* If we don't give up we might start leaking...  */
			sa_delete(sa, 1);
			return -1;
		}
		sa_reference(sa);
	}
	return 0;
}
@


1.122
log
@<stdlib.h> is included, so do not need to cast result from
malloc, calloc, realloc*
ok krw millert
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.121 2014/10/09 02:38:56 deraadt Exp $	 */
a552 6
		case IPSEC_ESP_DES:
		case IPSEC_ESP_DES_IV32:
		case IPSEC_ESP_DES_IV64:
			fprintf(fd, "DES\n");
			break;

@


1.121
log
@obvious reallocarray() conversions
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.120 2014/01/23 01:04:28 deraadt Exp $	 */
d1041 1
a1041 1
	avs = (struct attr_validation_state *)calloc(1, sizeof *avs);
@


1.120
log
@Remove a mid-layer which acts like arc4random isn't fairly standard.
ok mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.119 2014/01/22 03:09:31 deraadt Exp $	 */
d111 1
a111 1
	new_tab = realloc(sa_tab, (new_mask + 1) * sizeof(struct sa_list));
@


1.119
log
@improve randomization.  remove some junk debugging features that are
fundamentally broken.
ok jsing mikeb
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.118 2013/11/21 22:25:01 yasuoka Exp $	 */
d1376 1
a1376 1
		seconds = sa->seconds * (850 + rand_32() % 100) / 1000;
@


1.118
log
@Keep the flow until last IPsec SA is deleted, if the flow is shared by
multiple IPsec SAs in NAT-T case.

This fixes a problem that L2TP/IPsec connections are disconnected
improper in case multiple Windows clients are connected from behind
one NAT.

ok markus
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.117 2012/06/30 14:51:31 naddy Exp $	 */
a42 2

#include "sysdep.h"
@


1.117
log
@enable use of AES-{192,256}-CTR, and explicitly of AES-128-CTR, for IPsec ESP
ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.116 2012/01/16 08:45:55 eric Exp $	 */
d51 1
d1332 16
@


1.116
log
@import (and fix) net_addrcmp() from libc as a static function.
It is going to get removed from libc and this file is the only
one using it.

discussed with deraadt@@ guenther@@

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.115 2010/12/09 12:46:11 martinh Exp $	 */
d565 1
a565 1
			fprintf(fd, "AES-128 (CBC)\n");
d568 2
a569 2
		case IPSEC_ESP_AES_128_CTR:
			fprintf(fd, "AES-128 (CTR)\n");
@


1.115
log
@When looking up an SA based on peer address, also check the port
number. Without this, isakmpd deletes SAs from the same IP on an
INITIAL-CONTACT message, possibly deleting unrelated NATed tunnels.

Fixes PR 5562. Verified by Mikolaj Kucharski.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.114 2010/09/22 13:45:16 mikeb Exp $	 */
d35 2
d82 2
d191 35
d241 1
a241 1
	if (net_addrcmp(dst, addr->addr) != 0)
@


1.114
log
@Support for use of AES-GCM-16 (as AESGCM) and ENCR_NULL_AUTH_AES_GMAC
(as AESGMAC) ciphers in the ISAKMP Phase 2 (aka Quick Mode).

Thoroughly tested by me and naddy.  Works fine with Linux.

Requires updated pfkeyv2.h include file.

ok naddy
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.113 2007/09/02 15:19:24 deraadt Exp $	 */
d202 12
a213 1
	return (net_addrcmp(dst, addr->addr) == 0);
@


1.113
log
@use calloc() to avoid malloc(n * m) overflows; checked by djm canacar jsg
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.112 2007/06/02 01:29:12 pvalchev Exp $	 */
d520 8
@


1.112
log
@safer snprintf construct with more paranoid length calculation
ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.111 2007/04/16 13:01:39 moritz Exp $	 */
d91 1
a91 1
	sa_tab = malloc((bucket_mask + 1) * sizeof(struct sa_list));
@


1.111
log
@There's no point in checking ptr for NULL before doing free(ptr)
since free(NULL) is just fine.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.110 2006/11/24 13:52:14 reyk Exp $	 */
d466 1
a466 1
		j += 2;
@


1.110
log
@add support to tag ipsec traffic belonging to specific IKE-initiated
phase 2 traffic. this allows policy-based filtering of encrypted and
unencrypted ipsec traffic with pf(4). see ipsec.conf(5) and
isakmpd.conf(5) for details and examples.

this is work in progress and still needs some testing and feedback,
but it is safe to put it in now.

ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.109 2006/08/30 16:33:31 cloder Exp $	 */
d769 1
a769 2
			if (pa->attrs)
				free(pa->attrs);
d839 2
a840 4
	if (sa->id_i)
		free(sa->id_i);
	if (sa->id_r)
		free(sa->id_r);
d854 1
a854 2
	if (sa->keynote_key)
		free(sa->keynote_key);	/* This is just a string */
d857 2
a858 4
	if (sa->name)
		free(sa->name);
	if (sa->keystate)
		free(sa->keystate);
d865 1
a865 2
	if (sa->tag)
		free(sa->tag);
d1117 1
a1117 2
		if (proto->data)
			free(proto->data);
@


1.109
log
@Back out r1.103, which caused SA's to leak until memory was exhausted.
OK hshoexer, nathanael, mpf, "get that in" deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.103 2006/05/28 17:40:21 hshoexer Exp $	 */
d871 2
@


1.108
log
@Big spelling cleanup, no binary change.  From david@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.107 2006/05/31 04:54:46 hshoexer Exp $	 */
a1167 50
 * This function will get called when the exchange initiated by sa_soft_expire
 * completes. The intent is to support the case where the initiator has a phase
 * 1 SA, but the responder does not, or in the case of a fail-over gateway, the
 * responder SA does not match the one held by the initiator.
 *
 * Note that if sa_soft_expire initiates a phase 1 exchange, then this will be 
 * called at the completion of that.
 */
static void
sa_soft_finalize(struct exchange* exchange, void *v_sa, int fail)
{
	struct sa *sa = v_sa;

	if (sa->phase != 2 || !sa->death ||
	    (sa->flags & SA_FLAG_REPLACED)) {
		sa_release(sa);
		return;
	}

	if (fail) {
		char *peer = conf_get_str(sa->name, "ISAKMP-peer");
		if (peer) {
			struct sa *p1_sa;
			while ((p1_sa = sa_lookup_by_name(peer, 1)))
				sa_free(p1_sa);
		}
	}

	if (exchange)
		exchange_establish(sa->name, sa_soft_finalize, sa,
		    sa->flags & SA_FLAG_STAYALIVE);
	else {
		struct timeval  expiration;
		int 		seconds;

		gettimeofday(&expiration, 0);
		seconds = conf_get_num("General", "Exchange-max-time",
		    EXCHANGE_MAX_TIME);
		LOG_DBG((LOG_TIMER, 95,
	    	    "sa_soft_finalize: SA %p soft timeout in %d seconds",
		    sa, seconds));
		expiration.tv_sec += seconds;
		sa->soft_death = timer_add_event("sa_soft_expire",
		    sa_soft_expire, sa, &expiration);
		if (!sa->soft_death)
			sa_release(sa);
	}
}

/*
d1176 1
d1178 4
a1181 5
	if (sa->death && (sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED))
	    == SA_FLAG_STAYALIVE)
		/* soft_finalize will (eventually) release the sa */
		exchange_establish(sa->name, sa_soft_finalize, sa, 1);
	else {
a1186 2
		sa_release(sa);
	}
@


1.107
log
@Make sure, that phase 1 SAs of active connections stay alive.  Fixes a DPD
breakage noticed and reported by Mitja Muzenic.

ok markus@@ ho@@, testing by Mitja and cloder@@, discussed with Nathanael.
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.106 2006/05/29 14:31:39 hshoexer Exp $	 */
d212 1
a212 1
 * be a finished phaes 1 (ISAKMP) SA.
@


1.106
log
@Do not use C++ comments.  Noticed by markus.
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.105 2006/05/29 07:02:10 mcbride Exp $	 */
d1197 2
a1198 1
		exchange_establish(sa->name, sa_soft_finalize, sa);
d1230 1
a1230 1
		exchange_establish(sa->name, sa_soft_finalize, sa);
d1252 1
a1252 1
		exchange_establish(sa->name, 0, 0);
@


1.105
log
@Oops, return after calling sa_release()
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.104 2006/05/28 19:08:11 mcbride Exp $	 */
d1228 1
a1228 1
		// soft_finalize will (eventually) release the sa
@


1.104
log
@Assign a finalization event to the exchange initiated on soft expiry.
If the exchange fails, the existing phase 1 SA is invalidated and the
exchange is retried at the Exchange-Max-Time interval until the SA hard
timeout expires.

Another sasyncd-related fix from nathanael at polymorpheous dot com

ok ho@@ hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.103 2006/05/28 17:40:21 hshoexer Exp $	 */
d1182 1
a1182 1
	    (sa->flags & SA_FLAG_REPLACED))
d1184 2
@


1.103
log
@also report SA flags.
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.102 2005/09/23 14:44:03 hshoexer Exp $	 */
d1168 47
a1222 1
	sa_release(sa);
d1224 5
a1228 4
	if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED)) ==
	    SA_FLAG_STAYALIVE)
		exchange_establish(sa->name, 0, 0);
	else
d1234 2
@


1.102
log
@Provide UI commands to delete phase 1 SAs.

Looks good mortiz@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.101 2005/08/09 12:50:08 hshoexer Exp $	 */
d719 2
@


1.101
log
@Normalize attribute values before comparison.  Unbreaks interop with netscreen.
Noticed by Sean Knox.  Testing by msf@@, Sean Knox and others.  Thanks!

ok cloder@@ msf@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.100 2005/07/25 14:56:42 hshoexer Exp $	 */
d37 1
d202 1
a202 2
	return SA_LEN(dst) == addr->len &&
	    memcmp(dst, addr->addr, SA_LEN(dst)) == 0;
d253 1
a253 1
sa_lookup_by_peer(struct sockaddr *dst, socklen_t dstlen)
d259 1
a259 1
	arg.phase = 0;
@


1.100
log
@output some more information on UI command "S"

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.99 2005/07/22 11:36:43 hshoexer Exp $	 */
d899 1
d909 2
d931 1
d940 22
a961 1
	return memcmp(avs->attrp[type], value, len);
@


1.99
log
@spacing and tiny knf
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.98 2005/04/08 23:15:26 hshoexer Exp $	 */
d491 1
a491 1
	struct ipsec_proto *iproto = proto->data;
d535 7
d620 69
a700 1

a706 3
	struct proto   *proto;
	int             i;

d709 2
a710 1
	fprintf(fd, " (Phase %d)\n", sa->phase);
d717 2
a718 10
	/* Transform information. */
	for (proto = TAILQ_FIRST(&sa->protos); proto;
	    proto = TAILQ_NEXT(proto, link)) {
		/* SPI values. */
		for (i = 0; i < 2; i++)
			if (proto->spi[i])
				report_spi(fd, proto->spi[i], proto->spi_sz[i],
				    i);
			else
				fprintf(fd, "SPI %d not defined.", i);
d720 8
a727 2
		/* Proto values. */
		report_proto(fd, proto);
d729 2
a730 3
		/* SA separator. */
		fprintf(fd, "\n");
	}
d742 1
a742 4
			if (sa->phase == 1)
				fprintf(fd, "SA name: none (phase 1)\n\n");
			else
				sa_dump_all(fd, sa);
@


1.98
log
@get rid of sysdep_sa_len

ok cloder@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.97 2005/04/08 22:32:10 cloder Exp $	 */
d332 1
a332 1
         */
d365 1
a365 1
         */
d821 1
a821 1
         */
d904 1
a904 1
	(void) attribute_map(xf->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
d1208 1
a1208 1
         */
@


1.97
log
@Make deterministic randomness (only ever used for testing) a compile-time
option.  Reduces chances of somehow setting regrand when it's not supposed
to be set.  Remove "-r" option from man page.  Also xref certpatch(8) while
we are in there.  And remove some include sysdep.h where it is no longer
needed.
OK hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.96 2005/04/08 17:15:01 deraadt Exp $	 */
d201 2
a202 2
	return sysdep_sa_len(dst) == addr->len &&
	    memcmp(dst, addr->addr, sysdep_sa_len(dst)) == 0;
d226 2
a227 2
	if (memcmp(src, arg->dst, sysdep_sa_len(src)) &&
	    memcmp(dst, arg->dst, sysdep_sa_len(dst)))
@


1.96
log
@keynote and policy always compiled in
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.95 2005/04/08 16:52:41 deraadt Exp $	 */
d1215 1
a1215 1
		seconds = sa->seconds * (850 + sysdep_random() % 100) / 1000;
@


1.95
log
@always enable aggressive, dpd, and isakmp_cfg
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.94 2005/04/08 16:37:15 deraadt Exp $	 */
a37 1
#if defined (USE_KEYNOTE) || defined (USE_POLICY)
a39 1
#endif				/* USE_KEYNOTE || USE_POLICY */
a789 1
#if defined (USE_POLICY) || defined (USE_KEYNOTE)
a791 1
#endif
@


1.94
log
@nat-traversal always
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.93 2005/04/06 16:00:20 deraadt Exp $	 */
a725 1
#if defined (USE_DPD)
a729 1
#endif
a801 1
#if defined (USE_DPD)
a803 1
#endif
a1183 1
#if defined (USE_DPD)
a1187 1
#endif
@


1.93
log
@knf, ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.92 2005/04/06 00:02:56 cloder Exp $	 */
a801 1
#if defined (USE_NAT_TRAVERSAL)
a803 1
#endif
@


1.92
log
@Always print transport information correctly.
OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.91 2005/04/04 19:31:11 deraadt Exp $	 */
d348 4
a351 5
	    sa && (memcmp(cookies, sa->cookies, ISAKMP_HDR_COOKIES_LEN) != 0
	    || (message_id && memcmp(message_id, sa->message_id,
		ISAKMP_HDR_MESSAGE_ID_LEN) != 0)
	    || (!message_id && !zero_test(sa->message_id,
		ISAKMP_HDR_MESSAGE_ID_LEN)));
@


1.91
log
@spacing; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.90 2005/02/27 13:12:12 hshoexer Exp $	 */
d643 1
a643 1
	fprintf(fd, sa->transport == NULL ? "<no transport>" :
@


1.90
log
@where possible, use bzero instead of memset

ok cloder henning
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.89 2005/02/24 16:16:46 markus Exp $	 */
d979 1
a979 1
	         *
d981 1
a981 1
	         */
d989 1
a989 1
	         */
d992 3
a994 4
			     proto && sa_validate_proto_xf(proto, xf,
				 sa->phase) != 0;
			     proto = TAILQ_NEXT(proto, link))
			    ;
d1102 1
a1102 1
	         */
@


1.89
log
@disable the SA dpd timer on sa_free(). this avoid a race
between DPD and initial contact (double free); ok hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.88 2005/02/16 22:00:14 hshoexer Exp $	 */
d927 1
a927 1
		memset(avs->checked, 0, sizeof avs->checked);
@


1.88
log
@On shutdown also send delete messages for isakmp SAs.

ok ho
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.87 2005/01/30 12:36:13 hshoexer Exp $	 */
d727 6
d1192 6
@


1.87
log
@Avoid null pointer dereference when deleting not fully established SAs.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.86 2004/08/10 15:59:10 ho Exp $	 */
d1046 1
a1046 2
	/* Don't bother notifying of Phase 1 SA deletes.  */
	if (sa->phase != 1 && notify)
@


1.86
log
@Better implementation of the Dead Peer Detection protocol, RFC 3706.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.85 2004/08/08 19:11:06 deraadt Exp $	 */
d1072 3
a1074 2
				    sa->name));
				connection_teardown(sa->name);
@


1.85
log
@spacing
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.84 2004/08/02 15:48:22 hshoexer Exp $	 */
d802 2
a803 2
	if (sa->dpd_nextev)
		timer_remove_event(sa->dpd_nextev);
@


1.84
log
@Do not expire unestablished phase 2 SAs on SIGHUP.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.83 2004/06/21 23:27:10 ho Exp $	 */
d1131 1
a1131 1
	/* 
d1135 1
a1135 1
	 * */
d1159 1
a1159 1
		
@


1.83
log
@Implement NAT-T keepalive messages.
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.82 2004/05/23 18:17:56 hshoexer Exp $	 */
d1131 5
a1135 1
	/* Get phase 2 SAs. Soft expire those without active exchanges.  */
d1140 1
a1140 1
				    sa->phase) == 0) {
@


1.82
log
@More KNF.  Mainly spaces and line-wraps, no binary change.

ok ho@@
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.81 2004/05/13 06:56:34 ho Exp $	 */
d797 8
@


1.81
log
@Extensions to the FIFO interface:
"C get [section]:tag" fetches a configuration value.
"C add [section]:tag=value" adds 'value' to a list, typically for the
[Phase 2]:Connections tag. FIFO "S" command destination file changed.
Various KNF cleanups. hshoexer@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.80 2004/04/15 18:39:26 deraadt Exp $	 */
d95 1
a95 1
		    (bucket_mask + 1) * (unsigned long) sizeof(struct sa_list));
d105 2
a106 2
	int             new_mask = (bucket_mask + 1) * 2 - 1;
	int             i;
d148 1
a148 1
struct sa      *
d309 1
a309 1
struct sa      *
d347 7
a353 7
	for (sa = LIST_FIRST(&sa_tab[bucket]); sa &&
		 (memcmp(cookies, sa->cookies, ISAKMP_HDR_COOKIES_LEN) != 0 ||
		     (message_id && memcmp(message_id, sa->message_id,
			 ISAKMP_HDR_MESSAGE_ID_LEN) != 0) ||
		     (!message_id && !zero_test(sa->message_id,
			 ISAKMP_HDR_MESSAGE_ID_LEN)));
	     sa = LIST_NEXT(sa, link))
d372 1
a372 1
		    (unsigned long) sizeof *sa);
d393 1
a393 1
			    (unsigned long) sa->doi->sa_size);
d892 1
a892 1
	avs = (struct attr_validation_state *) calloc(1, sizeof *avs);
d895 1
a895 1
		    (unsigned long) sizeof *avs);
d909 1
a909 1
	     pa = TAILQ_NEXT(pa, next)) {
d957 1
a957 1
			    (unsigned long) sizeof *proto);
d992 1
a992 1
			    (unsigned long) sa->doi->proto_size);
d1154 2
a1155 1
		}, {
d1159 1
a1159 1
	size_t          i;
@


1.80
log
@partial move to KNF.  More to come.  This has happened because there
are a raft of source code auditors who are willing to help improve this
code only if this is done, and hey, isakmpd does need our standard
auditing process.  ok ho hshoexer
@
text
@d1 1
a1 1
/* $OpenBSD: sa.c,v 1.79 2004/04/07 22:45:49 ho Exp $	 */
d89 1
a89 1
	int             i;
d96 1
a96 1
	for (i = 0; i <= bucket_mask; i++) {
a97 1
	}
d113 1
a113 1
	for (i = bucket_mask + 1; i <= new_mask; i++) {
a114 1
	}
d131 2
a132 1
				LOG_DBG((LOG_SA, 90, "sa_find: return SA %p", sa));
d143 2
a144 2
	return sa->phase == 1
	&& memcmp(sa->cookies, icookie, ISAKMP_HDR_ICOOKIE_LEN) == 0;
d217 1
a217 1
isakmp_sa_check(struct sa * sa, void *v_arg)
d220 1
a220 1
	struct sockaddr *dst, *src;
d243 1
a243 1
sa_lookup_isakmp_sa(struct sockaddr * dst, u_int8_t * spi)
d255 1
a255 1
sa_lookup_by_peer(struct sockaddr * dst, socklen_t dstlen)
d268 1
a268 1
sa_isakmp_lookup_by_peer(struct sockaddr * dst, socklen_t dstlen)
d310 1
a310 1
sa_lookup_by_header(u_int8_t * msg, int phase2)
d347 7
a353 6
	for (sa = LIST_FIRST(&sa_tab[bucket]);
	     sa && (memcmp(cookies, sa->cookies, ISAKMP_HDR_COOKIES_LEN) != 0 ||
	    (message_id && memcmp(message_id, sa->message_id,
	    ISAKMP_HDR_MESSAGE_ID_LEN) != 0) ||
	    (!message_id && !zero_test(sa->message_id, ISAKMP_HDR_MESSAGE_ID_LEN)));
	    sa = LIST_NEXT(sa, link))
d361 1
a361 1
sa_create(struct exchange * exchange, struct transport * t)
d380 2
a381 1
	memcpy(sa->message_id, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
d416 1
a416 1
sa_dump(int cls, int level, char *header, struct sa * sa)
d422 2
a423 2
	LOG_DBG((cls, level, "%s: %p %s phase %d doi %d flags 0x%x", header, sa,
	    sa->name ? sa->name : "<unnamed>", sa->phase, sa->doi->id,
d434 2
a435 2
		LOG_DBG((cls, level, "%s: suite %d proto %d", header, proto->no,
		    proto->proto));
d437 2
a438 2
		    "%s: spi_sz[0] %d spi[0] %p spi_sz[1] %d spi[1] %p", header,
		    proto->spi_sz[0], proto->spi[0], proto->spi_sz[1],
d451 2
a452 2
				LOG_DBG_BUF((cls, level, spi_header, proto->spi[i],
				    proto->spi_sz[i]));
d464 2
a465 2
	char            s[SBUFSZ];
	size_t          i, j;
a485 1

d487 1
a487 1
 * Display the transform names to file SA_FILE.
d492 1
a492 1
report_proto(FILE * fd, struct proto * proto)
a493 1
	int             keylen, hashlen;
d495 1
d620 1
a621 1
	struct sa      *sa;
d633 1
a633 1
sa_dump_all(FILE * fd, struct sa * sa)
d653 2
a654 1
				report_spi(fd, proto->spi[i], proto->spi_sz[i], i);
d666 1
a666 1
/* Report info of all SAs to file SA_FILE.  */
d668 1
a668 1
sa_report_all(void)
d670 1
a671 2
	FILE           *fd;
	struct sa      *sa;
a672 4
	/* Open SA_FILE. */
	fd = monitor_fopen(SA_FILE, "w");

	/* Start sa_config_report. */
a678 3

	/* End sa_config_report. */
	fclose(fd);
d683 1
a683 1
proto_free(struct proto * proto)
d685 2
a687 2
	struct sa      *sa = proto->sa;
	struct proto_attr *pa;
d741 1
a741 1
sa_reference(struct sa * sa)
d750 1
a750 1
sa_release(struct sa * sa)
d752 1
a753 1
	struct cert_handler *handler;
d785 2
a786 1
		key_free(sa->recv_keytype, ISAKMP_KEYTYPE_PUBLIC, sa->recv_key);
d807 1
a807 1
sa_isakmp_upgrade(struct message * msg)
d835 1
a835 1
sa_validate_xf_attrs(u_int16_t type, u_int8_t * value, u_int16_t len,
d838 2
a839 1
	struct attr_validation_state *avs = (struct attr_validation_state *) arg;
d846 2
a847 1
		if (type < IKE_ATTR_ENCRYPTION_ALGORITHM || type > IKE_ATTR_BLOCK_SIZE)
d850 2
a851 1
		if (type < IPSEC_ATTR_SA_LIFE_TYPE || type > IPSEC_ATTR_ECN_TUNNEL)
d876 1
a876 1
sa_validate_proto_xf(struct proto * match, struct payload * xf, int phase)
d878 1
a879 1
	struct attr_validation_state *avs;
d946 2
a947 2
sa_add_transform(struct sa * sa, struct payload * xf, int initiator,
    struct proto ** protop)
d960 5
a964 4
		 * RFC 2408, section 4.2 states the responder SHOULD use the proposal
		 * number from the initiator (i.e us), in it's selected proposal to make
		 * this lookup easier. Most vendors follow this. One noted exception is
		 * the CiscoPIX (and perhaps other Cisco products).
d973 2
a974 1
		 * If we did not find a match, search through all proposals and xforms.
d978 4
a981 3
			    proto && sa_validate_proto_xf(proto, xf, sa->phase) != 0;
			    proto = TAILQ_NEXT(proto, link))
				;
d1003 2
a1004 1
		memcpy(proto->spi[0], prop->p + ISAKMP_PROP_SPI_OFF, proto->spi_sz[0]);
d1036 1
a1036 1
sa_delete(struct sa * sa, int notify)
d1127 2
a1128 1
				if (exchange_lookup_by_name(sa->name, sa->phase) == 0) {
d1144 4
a1147 4
	    {
		"active-only", SA_FLAG_ACTIVE_ONLY
	    },

d1152 5
a1156 5
	    {
		"__ondemand", SA_FLAG_ONDEMAND
	    }, {
		"ikecfg", SA_FLAG_IKECFG
	    },
d1169 1
a1169 1
sa_mark_replaced(struct sa * sa)
d1183 1
a1183 1
sa_setup_expirations(struct sa * sa)
d1185 1
a1186 1
	struct timeval  expiration;
d1224 2
a1225 2
		sa->death = timer_add_event("sa_hard_expire",
		    sa_hard_expire, sa, &expiration);
@


1.79
log
@-Wsign-compare nits. hshoexer@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.78 2004/04/07 20:04:34 ho Exp $	*/
/*	$EOM: sa.c,v 1.112 2000/12/12 00:22:52 niklas Exp $	*/
d41 1
a41 1
#endif /* USE_KEYNOTE || USE_POLICY */
d76 1
a76 1
static void sa_resize (void);
d78 2
a79 2
static void sa_soft_expire (void *);
static void sa_hard_expire (void *);
d81 1
a81 1
static LIST_HEAD (sa_list, sa) *sa_tab;
d84 1
a84 1
static int bucket_mask;
d87 1
a87 1
sa_init (void)
d89 1
a89 1
  int i;
d91 8
a98 9
  bucket_mask = (1 << INITIAL_BUCKET_BITS) - 1;
  sa_tab = malloc ((bucket_mask + 1) * sizeof (struct sa_list));
  if (!sa_tab)
    log_fatal ("sa_init: malloc (%lu) failed",
	       (bucket_mask + 1) * (unsigned long)sizeof (struct sa_list));
  for (i = 0; i <= bucket_mask; i++)
    {
      LIST_INIT (&sa_tab[i]);
    }
d104 1
a104 1
sa_resize (void)
d106 12
a117 13
  int new_mask = (bucket_mask + 1) * 2 - 1;
  int i;
  struct sa_list *new_tab;

  new_tab = realloc (sa_tab, (new_mask + 1) * sizeof (struct sa_list));
  if (!new_tab)
    return;
  sa_tab = new_tab;
  for (i = bucket_mask + 1; i <= new_mask; i++)
    {
      LIST_INIT (&sa_tab[i]);
    }
  bucket_mask = new_mask;
d119 1
a119 1
  /* XXX Rehash existing entries.  */
d125 1
a125 1
sa_find (int (*check) (struct sa *, void *), void *arg)
d127 2
a128 2
  int i;
  struct sa *sa;
d130 8
a137 9
  for (i = 0; i <= bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      if (check (sa, arg))
      {
	LOG_DBG ((LOG_SA, 90, "sa_find: return SA %p", sa));
	return sa;
      }
  LOG_DBG ((LOG_SA, 90, "sa_find: no SA matched query"));
  return 0;
d142 1
a142 1
sa_check_icookie (struct sa *sa, void *icookie)
d144 2
a145 2
  return sa->phase == 1
    && memcmp (sa->cookies, icookie, ISAKMP_HDR_ICOOKIE_LEN) == 0;
d149 2
a150 2
struct sa *
sa_lookup_from_icookie (u_int8_t *cookie)
d152 1
a152 1
  return sa_find (sa_check_icookie, cookie);
d156 2
a157 2
  char *name;
  u_int8_t phase;
d162 1
a162 1
sa_check_name_phase (struct sa *sa, void *v_arg)
d164 1
a164 1
  struct name_phase_arg *arg = v_arg;
d166 2
a167 2
  return sa->name && strcasecmp (sa->name, arg->name) == 0 &&
    sa->phase == arg->phase && !(sa->flags & SA_FLAG_REPLACED);
d172 1
a172 1
sa_lookup_by_name (char *name, int phase)
d174 1
a174 1
  struct name_phase_arg arg;
d176 3
a178 4
  arg.name = name;
  arg.phase = phase;

  return sa_find (sa_check_name_phase, &arg);
d181 5
a185 6
struct addr_arg
{
  struct sockaddr *addr;
  socklen_t len;
  int phase;
  int flags;
d194 1
a194 1
sa_check_peer (struct sa *sa, void *v_addr)
d196 2
a197 2
  struct addr_arg *addr = v_addr;
  struct sockaddr *dst;
d199 7
a205 7
  if (!sa->transport || (sa->flags & SA_FLAG_READY) == 0
      || (addr->phase && addr->phase != sa->phase))
    return 0;

  sa->transport->vtbl->get_dst (sa->transport, &dst);
  return sysdep_sa_len (dst) == addr->len
    && memcmp (dst, addr->addr, sysdep_sa_len (dst)) == 0;
d209 2
a210 2
  struct sockaddr *dst;
  u_int8_t *spi;			/* must be ISAKMP_SPI_SIZE octets */
d218 1
a218 1
isakmp_sa_check (struct sa *sa, void *v_arg)
d220 2
a221 2
  struct dst_isakmpspi_arg *arg = v_arg;
  struct sockaddr *dst, *src;
d223 2
a224 2
  if (sa->phase != 1 || !(sa->flags & SA_FLAG_READY))
    return 0;
d226 10
a235 10
  /* verify address is either src or dst for this sa */
  sa->transport->vtbl->get_dst (sa->transport, &dst);
  sa->transport->vtbl->get_src (sa->transport, &src);
  if (memcmp (src, arg->dst, sysdep_sa_len (src)) &&
      memcmp (dst, arg->dst, sysdep_sa_len (dst)))
    return 0;

  /* match icookie+rcookie against spi */
  if (memcmp (sa->cookies, arg->spi, ISAKMP_HDR_COOKIES_LEN) == 0)
    return 1;
d237 1
a237 1
  return 0;
d244 1
a244 1
sa_lookup_isakmp_sa (struct sockaddr *dst, u_int8_t *spi)
d246 1
a246 1
  struct dst_isakmpspi_arg arg;
d248 2
a249 2
  arg.dst = dst;
  arg.spi = spi;
d251 1
a251 1
  return sa_find (isakmp_sa_check, &arg);
d256 1
a256 1
sa_lookup_by_peer (struct sockaddr *dst, socklen_t dstlen)
d258 1
a258 1
  struct addr_arg arg;
d260 3
a262 3
  arg.addr = dst;
  arg.len = dstlen;
  arg.phase = 0;
d264 1
a264 1
  return sa_find (sa_check_peer, &arg);
d269 1
a269 1
sa_isakmp_lookup_by_peer (struct sockaddr *dst, socklen_t dstlen)
d271 1
a271 1
  struct addr_arg arg;
d273 3
a275 3
  arg.addr = dst;
  arg.len = dstlen;
  arg.phase = 1;
d277 1
a277 1
  return sa_find (sa_check_peer, &arg);
d281 1
a281 1
sa_enter (struct sa *sa)
d283 21
a303 23
  u_int16_t bucket = 0;
  int i;
  u_int8_t *cp;

  /* XXX We might resize if we are crossing a certain threshold */

  for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2)
    {
      cp = sa->cookies + i;
      /* Doing it this way avoids alignment problems.  */
      bucket ^= cp[0] | cp[1] << 8;
    }
  for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2)
    {
      cp = sa->message_id + i;
      /* Doing it this way avoids alignment problems.  */
      bucket ^= cp[0] | cp[1] << 8;
    }
  bucket &= bucket_mask;
  LIST_INSERT_HEAD (&sa_tab[bucket], sa, link);
  sa_reference (sa);
  LOG_DBG ((LOG_SA, 70, "sa_enter: SA %p added to SA list", sa));
  return 1;
d310 2
a311 2
struct sa *
sa_lookup_by_header (u_int8_t *msg, int phase2)
d313 2
a314 2
  return sa_lookup (msg + ISAKMP_HDR_COOKIES_OFF,
		    phase2 ? msg + ISAKMP_HDR_MESSAGE_ID_OFF : 0);
d322 1
a322 1
sa_lookup (u_int8_t *cookies, u_int8_t *message_id)
d324 31
a354 35
  u_int16_t bucket = 0;
  int i;
  struct sa *sa;
  u_int8_t *cp;

  /*
   * We use the cookies to get bits to use as an index into sa_tab, as at
   * least one (our cookie) is a good hash, xoring all the bits, 16 at a
   * time, and then masking, should do.  Doing it this way means we can
   * validate cookies very fast thus delimiting the effects of "Denial of
   * service"-attacks using packet flooding.
   */
  for (i = 0; i < ISAKMP_HDR_COOKIES_LEN; i += 2)
    {
      cp = cookies + i;
      /* Doing it this way avoids alignment problems.  */
      bucket ^= cp[0] | cp[1] << 8;
    }
  if (message_id)
    for (i = 0; i < ISAKMP_HDR_MESSAGE_ID_LEN; i += 2)
      {
	cp = message_id + i;
	/* Doing it this way avoids alignment problems.  */
	bucket ^= cp[0] | cp[1] << 8;
      }
  bucket &= bucket_mask;
  for (sa = LIST_FIRST (&sa_tab[bucket]);
       sa && (memcmp (cookies, sa->cookies, ISAKMP_HDR_COOKIES_LEN) != 0
	      || (message_id && memcmp (message_id, sa->message_id,
					ISAKMP_HDR_MESSAGE_ID_LEN)
		  != 0)
	      || (!message_id && !zero_test (sa->message_id,
					     ISAKMP_HDR_MESSAGE_ID_LEN)));
       sa = LIST_NEXT (sa, link))
    ;
d356 1
a356 1
  return sa;
d361 1
a361 1
sa_create (struct exchange *exchange, struct transport *t)
d363 1
a363 1
  struct sa *sa;
d365 33
a397 38
  /*
   * We want the SA zeroed for sa_free to be able to find out what fields
   * have been filled-in.
   */
  sa = calloc (1, sizeof *sa);
  if (!sa)
    {
      log_error ("sa_create: calloc (1, %lu) failed",
		 (unsigned long)sizeof *sa);
      return -1;
    }
  sa->transport = t;
  if (t)
    transport_reference (t);
  sa->phase = exchange->phase;
  memcpy (sa->cookies, exchange->cookies, ISAKMP_HDR_COOKIES_LEN);
  memcpy (sa->message_id, exchange->message_id, ISAKMP_HDR_MESSAGE_ID_LEN);
  sa->doi = exchange->doi;
  sa->policy_id = -1;

  if (sa->doi->sa_size)
    {
      /* Allocate the DOI-specific structure and initialize it to zeroes.  */
      sa->data = calloc (1, sa->doi->sa_size);
      if (!sa->data)
	{
	  log_error ("sa_create: calloc (1, %lu) failed",
		     (unsigned long)sa->doi->sa_size);
	  free (sa);
	  return -1;
	}
    }

  TAILQ_INIT (&sa->protos);

  sa_enter (sa);
  TAILQ_INSERT_TAIL (&exchange->sa_list, sa, next);
  sa_reference (sa);
d399 5
a403 1
  LOG_DBG ((LOG_SA, 60,
d407 1
a407 1
  return 0;
d415 1
a415 1
sa_dump (int cls, int level, char *header, struct sa *sa)
d417 3
a419 3
  struct proto *proto;
  char spi_header[80];
  int i;
d421 1
a421 1
  LOG_DBG ((cls, level, "%s: %p %s phase %d doi %d flags 0x%x", header, sa,
d424 6
a429 6
  LOG_DBG ((cls, level, "%s: icookie %08x%08x rcookie %08x%08x", header,
	    decode_32 (sa->cookies), decode_32 (sa->cookies + 4),
	    decode_32 (sa->cookies + 8), decode_32 (sa->cookies + 12)));
  LOG_DBG ((cls, level, "%s: msgid %08x refcnt %d", header,
	    decode_32 (sa->message_id), sa->refcnt));
  LOG_DBG ((cls, level, "%s: life secs %llu kb %llu", header, sa->seconds,
d431 23
a453 24
  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    {
      LOG_DBG ((cls, level, "%s: suite %d proto %d", header, proto->no,
		proto->proto));
      LOG_DBG ((cls, level,
		"%s: spi_sz[0] %d spi[0] %p spi_sz[1] %d spi[1] %p", header,
		proto->spi_sz[0], proto->spi[0], proto->spi_sz[1],
		proto->spi[1]));
      LOG_DBG ((cls, level, "%s: %s, %s", header,
		!sa->doi ? "<nodoi>"
		: sa->doi->decode_ids ("initiator id: %s, responder id: %s",
				     sa->id_i, sa->id_i_len,
				     sa->id_r, sa->id_r_len, 0),
		!sa->transport ? "<no transport>" :
		sa->transport->vtbl->decode_ids (sa->transport)));
      for (i = 0; i < 2; i++)
	if (proto->spi[i])
	  {
	    snprintf (spi_header, sizeof spi_header, "%s: spi[%d]", header, i);
	    LOG_DBG_BUF ((cls, level, spi_header, proto->spi[i],
			  proto->spi_sz[i]));
	  }
    }
d460 1
a460 1
report_spi (FILE *fd, const u_int8_t *buf, size_t sz, int spi)
d463 15
a477 2
  char s[SBUFSZ];
  size_t i, j;
d479 4
a482 22
  for (i = j = 0; i < sz;)
    {
      snprintf (s + j, sizeof s - j, "%02x", buf[i++]);
      j += 2;
      if (i % 4 == 0)
	{
	  if (i % 32 == 0)
	    {
	      s[j] = '\0';
	      fprintf (fd, "%s", s);
	      j = 0;
	    }
	  else
	    s[j++] = ' ';
	}
    }

  if (j)
    {
      s[j] = '\0';
      fprintf (fd, "SPI %d: %s\n", spi, s);
    }
d492 1
a492 1
report_proto (FILE *fd, struct proto *proto)
d494 2
a495 82
  int keylen, hashlen;
  struct ipsec_proto *iproto = proto->data;

  switch (proto->proto)
    {
    case IPSEC_PROTO_IPSEC_ESP:
      keylen = ipsec_esp_enckeylength (proto);
      hashlen = ipsec_esp_authkeylength (proto);
      fprintf (fd, "Transform: IPsec ESP\n");
      fprintf (fd, "Encryption key length: %d\n", keylen);
      fprintf (fd, "Authentication key length: %d\n", hashlen);

      fprintf (fd, "Encryption algorithm: ");
      switch (proto->id)
	{
	case IPSEC_ESP_DES:
	case IPSEC_ESP_DES_IV32:
	case IPSEC_ESP_DES_IV64:
	  fprintf (fd, "DES\n");
	  break;

	case IPSEC_ESP_3DES:
	  fprintf (fd, "3DES\n");
	  break;

	case IPSEC_ESP_AES:
	  fprintf (fd, "AES-128 (CBC)\n");
	  break;

	case IPSEC_ESP_AES_128_CTR:
	  fprintf (fd, "AES-128 (CTR)\n");
	  break;

	case IPSEC_ESP_CAST:
	  fprintf (fd, "Cast-128\n");
	  break;

	case IPSEC_ESP_BLOWFISH:
	  fprintf (fd, "Blowfish\n");
	  break;

	default:
	  fprintf (fd, "unknown (%d)\n", proto->id);
	}

      fprintf (fd, "Authentication algorithm: ");
      switch (iproto->auth)
	{
	case IPSEC_AUTH_HMAC_MD5:
	  fprintf (fd, "HMAC-MD5\n");
	  break;

	case IPSEC_AUTH_HMAC_SHA:
	  fprintf (fd, "HMAC-SHA1\n");
	  break;

        case IPSEC_AUTH_HMAC_RIPEMD:
	  fprintf (fd, "HMAC-RIPEMD-160\n");
	  break;

	case IPSEC_AUTH_HMAC_SHA2_256:
	  fprintf (fd, "HMAC-SHA2-256\n");
	  break;

	case IPSEC_AUTH_HMAC_SHA2_384:
	  fprintf (fd, "HMAC-SHA2-384\n");
	  break;

	case IPSEC_AUTH_HMAC_SHA2_512:
	  fprintf (fd, "HMAC-SHA2-512\n");
	  break;

	case IPSEC_AUTH_DES_MAC:
	case IPSEC_AUTH_KPDK:
	  /* XXX We should be supporting KPDK */
	  fprintf (fd, "unknown (%d)", iproto->auth);
	  break;

	default:
	  fprintf (fd, "none\n");
	}
      break;
d497 113
a609 32
    case IPSEC_PROTO_IPSEC_AH:
      hashlen = ipsec_ah_keylength (proto);
      fprintf (fd, "Transform: IPsec AH\n");
      fprintf (fd, "Encryption not used.\n");
      fprintf (fd, "Authentication key length: %d\n", hashlen);

      fprintf (fd, "Authentication algorithm: ");
      switch (proto->id)
	{
	case IPSEC_AH_MD5:
	  fprintf (fd, "HMAC-MD5\n");
	  break;

	case IPSEC_AH_SHA:
	  fprintf (fd, "HMAC-SHA1\n");
	  break;

	case IPSEC_AH_RIPEMD:
	  fprintf (fd, "HMAC-RIPEMD-160\n");
	  break;

	case IPSEC_AH_SHA2_256:
	  fprintf (fd, "HMAC-SHA2-256\n");
	  break;

	case IPSEC_AH_SHA2_384:
	  fprintf (fd, "HMAC-SHA2-384\n");
	  break;

	case IPSEC_AH_SHA2_512:
	  fprintf (fd, "HMAC-SHA2-512\n");
	  break;
d612 1
a612 1
	  fprintf (fd, "unknown (%d)", proto->id);
a613 5
      break;

    default:
      fprintf (fd, "report_proto: invalid proto %d\n", proto->proto);
    }
d618 1
a618 1
sa_report (void)
d620 2
a621 2
  int i;
  struct sa *sa;
d623 3
a625 3
  for (i = 0; i <= bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      sa_dump (LOG_REPORT, 0, "sa_report", sa);
d633 1
a633 1
sa_dump_all (FILE *fd, struct sa *sa)
d635 2
a636 2
  struct proto *proto;
  int i;
d638 18
a655 19
  /* SA name and phase. */
  fprintf (fd, "SA name: %s", sa->name ? sa->name : "<unnamed>");
  fprintf (fd, " (Phase %d)\n", sa->phase);

  /* Source and destination IPs. */
  fprintf (fd, sa->transport == NULL ? "<no transport>" :
	   sa->transport->vtbl->decode_ids (sa->transport));
  fprintf (fd, "\n");

  /* Transform information. */
  for (proto = TAILQ_FIRST (&sa->protos); proto;
       proto = TAILQ_NEXT (proto, link))
    {
      /* SPI values. */
      for (i = 0; i < 2; i++)
	if (proto->spi[i])
	  report_spi (fd, proto->spi[i], proto->spi_sz[i], i);
	else
	  fprintf (fd, "SPI %d not defined.", i);
d657 2
a658 2
      /* Proto values. */
      report_proto (fd, proto);
d660 3
a662 3
      /* SA separator. */
      fprintf (fd, "\n");
    }
d667 1
a667 1
sa_report_all (void)
d669 14
a682 14
  int i;
  FILE *fd;
  struct sa *sa;

  /* Open SA_FILE. */
  fd = monitor_fopen (SA_FILE, "w");

  /* Start sa_config_report. */
  for (i = 0; i <= bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      if (sa->phase == 1)
	fprintf (fd, "SA name: none (phase 1)\n\n");
      else
	sa_dump_all (fd, sa);
d684 2
a685 2
  /* End sa_config_report. */
  fclose (fd);
d690 1
a690 1
proto_free (struct proto *proto)
d692 23
a714 26
  int i;
  struct sa *sa = proto->sa;
  struct proto_attr *pa;

  for (i = 0; i < 2; i++)
    if (proto->spi[i])
      {
	if (sa->doi->delete_spi)
	  sa->doi->delete_spi (sa, proto, i);
	free (proto->spi[i]);
      }
  TAILQ_REMOVE (&sa->protos, proto, link);
  if (proto->data)
    {
      if (sa->doi && sa->doi->free_proto_data)
	sa->doi->free_proto_data (proto->data);
      free (proto->data);
    }
  if (proto->xf_cnt)
    while ((pa = TAILQ_FIRST (&proto->xfs)) != NULL)
      {
	if (pa->attrs)
	  free (pa->attrs);
	TAILQ_REMOVE (&proto->xfs, pa, next);
	free (pa);
      }
d716 2
a717 2
  LOG_DBG ((LOG_SA, 90, "proto_free: freeing %p", proto));
  free (proto);
d722 1
a722 1
sa_free (struct sa *sa)
d724 11
a734 13
  if (sa->death)
    {
      timer_remove_event (sa->death);
      sa->death = 0;
      sa->refcnt--;
    }
  if (sa->soft_death)
    {
      timer_remove_event (sa->soft_death);
      sa->soft_death = 0;
      sa->refcnt--;
    }
  sa_remove (sa);
d739 1
a739 1
sa_remove (struct sa *sa)
d741 3
a743 3
  LIST_REMOVE (sa, link);
  LOG_DBG ((LOG_SA, 70, "sa_remove: SA %p removed from SA list", sa));
  sa_release (sa);
d748 1
a748 1
sa_reference (struct sa *sa)
d750 2
a751 2
  sa->refcnt++;
  LOG_DBG ((LOG_SA, 80, "sa_reference: SA %p now has %d references",
d757 1
a757 1
sa_release (struct sa *sa)
d759 2
a760 2
  struct proto *proto;
  struct cert_handler *handler;
d762 1
a762 1
  LOG_DBG ((LOG_SA, 80, "sa_release: SA %p had %d references",
d765 2
a766 2
  if (--sa->refcnt)
    return;
d768 1
a768 1
  LOG_DBG ((LOG_SA, 60, "sa_release: freeing SA %p", sa));
d770 25
a794 28
  while ((proto = TAILQ_FIRST (&sa->protos)) != 0)
    proto_free (proto);
  if (sa->data)
    {
      if (sa->doi && sa->doi->free_sa_data)
	sa->doi->free_sa_data (sa->data);
      free (sa->data);
    }
  if (sa->id_i)
    free (sa->id_i);
  if (sa->id_r)
    free (sa->id_r);
  if (sa->recv_cert)
    {
	handler = cert_get (sa->recv_certtype);
	if (handler)
	  handler->cert_free (sa->recv_cert);
    }
  if (sa->sent_cert)
    {
	handler = cert_get (sa->sent_certtype);
	if (handler)
	  handler->cert_free (sa->sent_cert);
    }
  if (sa->recv_key)
    key_free (sa->recv_keytype, ISAKMP_KEYTYPE_PUBLIC, sa->recv_key);
  if (sa->keynote_key)
    free (sa->keynote_key); /* This is just a string */
d796 2
a797 2
  if (sa->policy_id != -1)
    kn_close (sa->policy_id);
d799 7
a805 7
  if (sa->name)
    free (sa->name);
  if (sa->keystate)
    free (sa->keystate);
  if (sa->transport)
    transport_release (sa->transport);
  free (sa);
d813 1
a813 1
sa_isakmp_upgrade (struct message *msg)
d815 1
a815 1
  struct sa *sa = TAILQ_FIRST (&msg->exchange->sa_list);
d817 3
a819 3
  sa_remove (sa);
  GET_ISAKMP_HDR_RCOOKIE (msg->iov[0].iov_base,
			  sa->cookies + ISAKMP_HDR_ICOOKIE_LEN);
d821 7
a827 7
  /*
   * We don't install a transport in the initiator case as we don't know
   * what local address will be chosen.  Do it now instead.
   */
  sa->transport = msg->transport;
  transport_reference (sa->transport);
  sa_enter (sa);
d830 1
a830 1
#define ATTRS_SIZE (IKE_ATTR_BLOCK_SIZE + 1)	 /* XXX Should be dynamic.  */
d833 4
a836 4
  u_int8_t *attrp[ATTRS_SIZE];
  u_int8_t checked[ATTRS_SIZE];
  int phase;				/* IKE (1) or IPSEC (2) attrs? */
  int mode;				/* 0 = 'load', 1 = check */
d841 2
a842 2
sa_validate_xf_attrs (u_int16_t type, u_int8_t *value, u_int16_t len,
		      void *arg)
d844 1
a844 1
  struct attr_validation_state *avs = (struct attr_validation_state *)arg;
d846 1
a846 1
  LOG_DBG ((LOG_SA, 95, "sa_validate_xf_attrs: phase %d mode %d type %d "
d849 21
a869 27
  /* Make sure the phase and type are valid.  */
  if (avs->phase == 1)
    {
      if (type < IKE_ATTR_ENCRYPTION_ALGORITHM || type > IKE_ATTR_BLOCK_SIZE)
	return 1;
    }
  else if (avs->phase == 2)
    {
      if (type < IPSEC_ATTR_SA_LIFE_TYPE || type > IPSEC_ATTR_ECN_TUNNEL)
	return 1;
    }
  else
    return 1;

  if (avs->mode == 0) /* Load attrs.  */
    {
      avs->attrp[type] = value;
      return 0;
    }

  /* Checking for a missing attribute is an immediate failure.  */
  if (!avs->attrp[type])
    return 1;

  /* Match the loaded attribute against this one, mark it as checked.  */
  avs->checked[type]++;
  return memcmp (avs->attrp[type], value, len);
d875 1
a875 1
 * We return 0 if a match is found (in any transform of this proposal), 1 
d879 1
a879 1
sa_validate_proto_xf (struct proto *match, struct payload *xf, int phase)
d881 54
a934 61
  struct proto_attr *pa;
  struct attr_validation_state *avs;
  int found = 0;
  size_t i;
  u_int8_t xf_id;

  if (!match->xf_cnt)
    return 0;

  if (match->proto != GET_ISAKMP_PROP_PROTO (xf->context->p))
    {
      LOG_DBG ((LOG_SA, 70, "sa_validate_proto_xf: proto %p (#%d) "
		"protocol mismatch", match, match->no));
      return 1;
    }

  avs = (struct attr_validation_state *)calloc (1, sizeof *avs);
  if (!avs)
    {
      log_error ("sa_validate_proto_xf: calloc (1, %lu)",
		 (unsigned long)sizeof *avs);
      return 1;
    }
  avs->phase = phase;

  /* Load the "proposal candidate" attribute set.  */
  (void)attribute_map (xf->p + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		       GET_ISAKMP_GEN_LENGTH (xf->p) 
		       - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
		       sa_validate_xf_attrs, avs);
  xf_id = GET_ISAKMP_TRANSFORM_ID (xf->p);

  /* Check against the transforms we suggested.  */
  avs->mode++;
  for (pa = TAILQ_FIRST (&match->xfs); pa && !found;
       pa = TAILQ_NEXT (pa, next))
    {
      if (xf_id != GET_ISAKMP_TRANSFORM_ID (pa->attrs))
	continue;

      memset (avs->checked, 0, sizeof avs->checked);
      if (attribute_map (pa->attrs + ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			 pa->len - ISAKMP_TRANSFORM_SA_ATTRS_OFF,
			 sa_validate_xf_attrs, avs) == 0)
	found++;

      LOG_DBG ((LOG_SA, 80, "sa_validate_proto_xf: attr_map "
		"xf %p proto %p pa %p found %d", xf, match, pa, found));

      if (!found)
	continue;

      /* Require all attributes present and checked.  XXX perhaps not?  */
      for (i = 0; i < sizeof avs->checked; i++)
	if (avs->attrp[i] && !avs->checked[i])
	  found = 0;

      LOG_DBG ((LOG_SA, 80, "sa_validate_proto_xf: req_attr "
		"xf %p proto %p pa %p found %d", xf, match, pa, found));
    }
  free (avs);
d936 5
a940 1
  return found ? 0 : 1;
d949 2
a950 2
sa_add_transform (struct sa *sa, struct payload *xf, int initiator,
		  struct proto **protop)
d952 2
a953 2
  struct proto *proto;
  struct payload *prop = xf->context;
d955 59
a1013 66
  *protop = 0;
  if (!initiator)
    {
      proto = calloc (1, sizeof *proto);
      if (!proto)
	log_error ("sa_add_transform: calloc (1, %lu) failed",
		   (unsigned long)sizeof *proto);
    }
  else
    {
      /*
       * RFC 2408, section 4.2 states the responder SHOULD use the proposal 
       * number from the initiator (i.e us), in it's selected proposal to make
       * this lookup easier. Most vendors follow this. One noted exception is
       * the CiscoPIX (and perhaps other Cisco products).
       *
       * We start by matching on the proposal number, as before.
       */
      for (proto = TAILQ_FIRST (&sa->protos);
	   proto && proto->no != GET_ISAKMP_PROP_NO (prop->p);
	   proto = TAILQ_NEXT (proto, link))
	;
      /*
       * If we did not find a match, search through all proposals and xforms.
       */
      if (!proto || sa_validate_proto_xf (proto, xf, sa->phase) != 0)
	for (proto = TAILQ_FIRST (&sa->protos);
	     proto && sa_validate_proto_xf (proto, xf, sa->phase) != 0;
	     proto = TAILQ_NEXT (proto, link))
	  ;
    }
  if (!proto)
    return -1;
  *protop = proto;

  /* Allocate DOI-specific part.  */
  if (!initiator)
    {
      proto->data = calloc (1, sa->doi->proto_size);
      if (!proto->data)
	{
	  log_error ("sa_add_transform: calloc (1, %lu) failed",
		     (unsigned long)sa->doi->proto_size);
	  goto cleanup;
	}
    }

  proto->no = GET_ISAKMP_PROP_NO (prop->p);
  proto->proto = GET_ISAKMP_PROP_PROTO (prop->p);
  proto->spi_sz[0] = GET_ISAKMP_PROP_SPI_SZ (prop->p);
  if (proto->spi_sz[0])
    {
      proto->spi[0] = malloc (proto->spi_sz[0]);
      if (!proto->spi[0])
	goto cleanup;
      memcpy (proto->spi[0], prop->p + ISAKMP_PROP_SPI_OFF, proto->spi_sz[0]);
    }
  proto->chosen = xf;
  proto->sa = sa;
  proto->id = GET_ISAKMP_TRANSFORM_ID (xf->p);
  if (!initiator)
    TAILQ_INSERT_TAIL (&sa->protos, proto, link);

  /* Let the DOI get at proto for initializing its own data.  */
  if (sa->doi->proto_init)
    sa->doi->proto_init (proto, 0);
d1015 1
a1015 1
  LOG_DBG ((LOG_SA, 80,
d1021 1
a1021 1
  return 0;
d1023 8
a1030 9
 cleanup:
  if (!initiator)
    {
      if (proto->data)
	free (proto->data);
      free (proto);
    }
  *protop = 0;
  return -1;
d1035 1
a1035 1
sa_delete (struct sa *sa, int notify)
d1037 4
a1040 4
  /* Don't bother notifying of Phase 1 SA deletes.  */
  if (sa->phase != 1 && notify)
    message_send_delete (sa);
  sa_free (sa);
d1046 1
a1046 1
sa_teardown_all (void)
d1048 2
a1049 2
  int i;
  struct sa *sa, *next = 0;
d1051 17
a1067 15
  LOG_DBG ((LOG_SA, 70, "sa_teardown_all:"));
  /* Get Phase 2 SAs.  */
  for (i = 0; i <= bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = next)
      {
	next = LIST_NEXT (sa, link);
	if (sa->phase == 2)
	  {
	    /* Teardown the phase 2 SAs by name, similar to ui_teardown.  */
	    LOG_DBG ((LOG_SA, 70, "sa_teardown_all: tearing down SA %s",
		      sa->name));
	    connection_teardown (sa->name);
	    sa_delete (sa, 1);
	  }
      }
d1074 1
a1074 1
sa_soft_expire (void *v_sa)
d1076 1
a1076 1
  struct sa *sa = v_sa;
d1078 2
a1079 2
  sa->soft_death = 0;
  sa_release (sa);
d1081 9
a1089 9
  if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED))
      == SA_FLAG_STAYALIVE)
    exchange_establish (sa->name, 0, 0);
  else
    /*
     * Start to watch the use of this SA, so a renegotiation can
     * happen as soon as it is shown to be alive.
     */
    sa->flags |= SA_FLAG_FADING;
d1094 1
a1094 1
sa_hard_expire (void *v_sa)
d1096 1
a1096 1
  struct sa *sa = v_sa;
d1098 2
a1099 2
  sa->death = 0;
  sa_release (sa);
d1101 3
a1103 3
  if ((sa->flags & (SA_FLAG_STAYALIVE | SA_FLAG_REPLACED))
      == SA_FLAG_STAYALIVE)
    exchange_establish (sa->name, 0, 0);
d1105 1
a1105 1
  sa_delete (sa, 1);
d1109 1
a1109 1
sa_reinit (void)
d1111 19
a1129 20
  struct sa *sa;
  char *tag;
  int i;

  /* For now; only do this if we have the proper tag configured.  */
  tag = conf_get_str ("General", "Renegotiate-on-HUP");
  if (!tag)
    return;

  LOG_DBG ((LOG_SA, 30, "sa_reinit: renegotiating active connections"));

  /* Get phase 2 SAs. Soft expire those without active exchanges.  */
  for (i = 0; i <= bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      if (sa->phase == 2)
	if (exchange_lookup_by_name (sa->name, sa->phase) == 0)
	  {
	    timer_remove_event (sa->soft_death);
	    sa_soft_expire (sa);
	  }
d1136 1
a1136 1
sa_flag (char *attr)
d1138 25
a1162 16
  static struct sa_flag_map {
    char *name;
    int flag;
  } sa_flag_map[] = {
    { "active-only", SA_FLAG_ACTIVE_ONLY },
    /* Below this point are flags that are internal to the implementation.  */
    { "__ondemand", SA_FLAG_ONDEMAND },
    { "ikecfg", SA_FLAG_IKECFG },
  };
  size_t i;

  for (i = 0; i < sizeof sa_flag_map / sizeof sa_flag_map[0]; i++)
    if (strcasecmp (attr, sa_flag_map[i].name) == 0)
      return sa_flag_map[i].flag;
  log_print ("sa_flag: attribute \"%s\" unknown", attr);
  return 0;
d1167 1
a1167 1
sa_mark_replaced (struct sa *sa)
d1169 1
a1169 1
  LOG_DBG ((LOG_SA, 60, "sa_mark_replaced: SA %p (%s) marked as replaced",
d1171 1
a1171 1
  sa->flags |= SA_FLAG_REPLACED;
d1181 1
a1181 1
sa_setup_expirations (struct sa *sa)
d1183 2
a1184 2
  u_int64_t seconds = sa->seconds;
  struct timeval expiration;
d1186 46
a1231 48
  /*
   * Set the soft timeout to a random percentage between 85 & 95 of
   * the negotiated lifetime to break strictly synchronized
   * renegotiations.  This works better when the randomization is on the
   * order of processing plus network-roundtrip times, or larger.
   * I.e. it depends on configuration and negotiated lifetimes.
   * It is not good to do the decrease on the hard timeout, because then
   * we may drop our SA before our peer.
   * XXX Better scheme to come?
   */
  if (!sa->soft_death)
    {
      gettimeofday (&expiration, 0);
      /* XXX This should probably be configuration controlled somehow.  */
      seconds = sa->seconds * (850 + sysdep_random () % 100) / 1000;
      LOG_DBG ((LOG_TIMER, 95,
		"sa_setup_expirations: SA %p soft timeout in %llu seconds",
		sa, seconds));
      expiration.tv_sec += seconds;
      sa->soft_death
	= timer_add_event ("sa_soft_expire", sa_soft_expire, sa, &expiration);
      if (!sa->soft_death)
	{
	  /* If we don't give up we might start leaking...  */
	  sa_delete (sa, 1);
	  return -1;
	}
      sa_reference (sa);
    }

  if (!sa->death)
    {
      gettimeofday (&expiration, 0);
      LOG_DBG ((LOG_TIMER, 95,
		"sa_setup_expirations: SA %p hard timeout in %llu seconds",
		sa, sa->seconds));
      expiration.tv_sec += sa->seconds;
      sa->death
	= timer_add_event ("sa_hard_expire", sa_hard_expire, sa, &expiration);
      if (!sa->death)
	{
	  /* If we don't give up we might start leaking...  */
	  sa_delete (sa, 1);
	  return -1;
	}
      sa_reference (sa);
    }
  return 0;
@


1.78
log
@More careful when walking LIST queues. hshoexer@@, david@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.77 2004/03/19 14:04:43 hshoexer Exp $	*/
d477 1
a477 1
  int i, j;
d920 2
a921 1
  int i, found = 0;
d1194 1
a1194 1
  int i;
@


1.77
log
@Add missing bits to make already present privsep code work.  Enable privsep.

ok ho@@ deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.76 2004/02/27 10:16:26 ho Exp $	*/
d1096 1
a1096 1
  struct sa *sa;
d1101 12
a1112 9
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      if (sa->phase == 2)
	{
	  /* Teardown the phase 2 SAs by name, similar to ui_teardown.  */
	  LOG_DBG ((LOG_SA, 70, "sa_teardown_all: tearing down SA %s",
		    sa->name));
	  connection_teardown (sa->name);
	  sa_delete (sa, 1);
	}
@


1.76
log
@(C)-2004
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.75 2004/02/27 09:01:19 ho Exp $	*/
d54 1
d697 1
a697 1
  fd = fopen (SA_FILE, "w");
@


1.75
log
@Follow RFC 2408 more closely regarding how to better check the proposal
returned by the other peer (the responder). Some implementations (notably
the Cisco PIX) does not follow a SHOULD in section 4.2 of the RFC. With
certain proposal combinations this caused us to setup the wrong SA
resulting in us being unable to process incoming IPsec traffic (over this
tunnel).

Tested against a number of different IKE implementations.
hshoexer@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.74 2004/01/06 00:22:48 hshoexer Exp $	*/
d7 1
@


1.74
log
@small typos fixed.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.73 2003/07/25 08:31:16 markus Exp $	*/
d44 1
d141 1
a141 1
/* Check if SA is an ISAKMP SA with an initiar cookie equal to ICOOKIE.  */
d715 1
d731 8
d740 1
a740 3
  /* XXX Use class LOG_SA instead?  */
  LOG_DBG ((LOG_MISC, 90, "proto_free: freeing %p", proto));

d859 121
d1001 22
a1022 5
    /* Find the protection suite that were chosen.  */
    for (proto = TAILQ_FIRST (&sa->protos);
	 proto && proto->no != GET_ISAKMP_PROP_NO (prop->p);
	 proto = TAILQ_NEXT (proto, link))
      ;
d1096 2
a1097 2
  LOG_DBG((LOG_MISC, 70, "sa_teardown_all:"));
  /* Get Phase 2 SAs. */
d1102 3
a1104 3
	  /* Teardown the phase 2 SAs by name, similar to ui_teardown. */
	  LOG_DBG((LOG_MISC, 70, "sa_teardown_all: tearing down SA %s",
	      sa->name));
@


1.73
log
@add sha2 support; ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.72 2003/06/04 07:31:17 ho Exp $	*/
d950 1
a950 1
  LOG_DBG((LOG_MISC, 70, "sa_teardown_all.a"));
@


1.72
log
@Remove the rest of clauses 3 and 4. Approved by Niklas Hallqvist, Angelos
D. Keromytis and Niels Provos.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.71 2003/06/03 12:51:39 ho Exp $	*/
d569 12
d611 12
@


1.71
log
@Cleanup. Use 'sizeof variable' instead of magic constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.70 2003/05/18 20:39:25 ho Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Ericsson Radio Systems.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.70
log
@Add a debug message to sa_reinit() to indicate when we renegotiate
active connections.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.69 2003/05/16 20:31:16 ho Exp $	*/
d464 1
a464 1
	    snprintf (spi_header, 80, "%s: spi[%d]", header, i);
d483 1
a483 1
      snprintf (s + j, SBUFSZ - j, "%02x", buf[i++]);
@


1.69
log
@If the "Renegotiate-on-HUP" tag is defined in the [General] section, a
HUP signal (or "R" to the FIFO) will also renegotiate all Phase 2 SAs,
i.e all connections.
ok niklas@@, tested and ok kjell@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.68 2003/05/15 02:28:56 ho Exp $	*/
d994 2
@


1.68
log
@Cleanup. Do not store the private key in either the exchange or sa structs.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.67 2003/05/14 17:37:22 ho Exp $	*/
d49 1
d981 23
@


1.67
log
@I did not test this enough. Unbreak.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.66 2003/05/12 21:43:22 ho Exp $	*/
a793 2
  if (sa->sent_key)
    key_free (sa->sent_keytype, ISAKMP_KEYTYPE_PRIVATE, sa->sent_key);
@


1.66
log
@AES -> AES_128_CBC
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.65 2002/11/21 12:09:20 ho Exp $	*/
d538 1
a538 1
	case IPSEC_ESP_AES_128_CBC:
@


1.65
log
@-Wshadow nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.64 2002/09/08 12:38:04 ho Exp $	*/
d538 6
a543 2
	case IPSEC_ESP_AES:
	  fprintf (fd, "Rijndael-128/AES\n");
@


1.64
log
@Fix -pedantic errors.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.63 2002/06/10 18:08:58 ho Exp $	*/
d474 1
a474 1
report_spi (FILE *fd, const u_int8_t *buf, size_t sz, int index)
d500 1
a500 1
      fprintf (fd, "SPI %d: %s\n", index, s);
@


1.63
log
@The dlopen() stuff goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.62 2002/06/09 08:13:07 todd Exp $	*/
d178 4
a181 1
  struct name_phase_arg arg = { name, phase };
d252 4
a255 1
  struct dst_isakmpspi_arg arg = { dst, spi };
d264 5
a268 1
  struct addr_arg arg = { dst, dstlen, 0 };
d277 5
a281 1
  struct addr_arg arg = { dst, dstlen, 1 };
@


1.62
log
@rm trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.61 2002/06/07 15:59:37 ho Exp $	*/
d782 1
a782 1
    LK (kn_close, (sa->policy_id));
@


1.61
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.60 2002/06/07 15:24:22 ho Exp $	*/
d435 1
a435 1
      LOG_DBG ((cls, level, 
d558 1
a558 1
	  fprintf (fd, "unknown (%d)", iproto->auth); 
@


1.60
log
@Add 'ikecfg' as a valid Flags= value.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.59 2002/06/06 15:40:09 ho Exp $	*/
d979 1
a979 1
    { "ikecfg}", SA_FLAG_IKECFG },
@


1.59
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.58 2002/06/06 02:15:27 ho Exp $	*/
d978 2
a979 1
    { "__ondemand", SA_FLAG_ONDEMAND }
@


1.58
log
@Style, and a few additional format/type mods.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.57 2002/06/01 07:44:22 deraadt Exp $	*/
d466 5
a470 18
  {
    for (i = j = 0; i < sz;)
      {
	snprintf (s + j, SBUFSZ - j, "%02x", buf[i++]);
	j += 2;
	if (i % 4 == 0)
	  {
	    if (i % 32 == 0)
	      {
		s[j] = '\0';
		fprintf(fd, "%s", s);
		j = 0;
	      }
	    else
	      s[j++] = ' ';
	  }
      }
      if (j)
d472 8
a479 2
	  s[j] = '\0';
	  fprintf(fd, "SPI %d: %s\n", index, s);
d481 7
a487 1
  }
d507 3
a509 3
      fprintf(fd, "Transform: IPsec ESP\n");
      fprintf(fd, "Encryption key length: %d\n", keylen);
      fprintf(fd, "Authentication key length: %d\n", hashlen);
d511 1
d517 1
a517 1
	  fprintf(fd, "Encryption algorithm: DES\n");
d521 1
a521 1
	  fprintf(fd, "Encryption algorithm: 3DES\n");
d525 1
a525 1
	  fprintf(fd, "Encryption algorithm: Rijndael-128/AES\n");
d529 1
a529 1
	  fprintf(fd, "Encryption algorithm: Cast-128\n");
d533 1
a533 1
	  fprintf(fd, "Encryption algorithm: Blowfish\n");
d537 1
a537 1
	  fprintf(fd, "Unknown encryption algorithm %d\n", proto->id);
d540 1
d544 1
a544 1
	  fprintf(fd, "Authentication algorithm: HMAC-MD5\n");
d548 1
a548 1
	  fprintf(fd, "Authentication algorithm: HMAC-SHA1\n");
d552 1
a552 1
	  fprintf(fd, "Authentication algorithm: HMAC-RIPEMD-160\n");
d558 1
a558 1
	  fprintf(fd, "Unknown authentication algorithm: %d", iproto->auth); 
d562 1
a562 1
	  fprintf(fd, "Authentication algorithm not used.\n");
d568 3
a570 3
      fprintf(fd, "Transform: IPsec AH\n");
      fprintf(fd, "Encryption not used.\n");
      fprintf(fd, "Authentication key length: %d\n", hashlen);
d572 1
d576 1
a576 1
	  fprintf(fd, "Authentication algorithm: HMAC-MD5\n");
d580 1
a580 1
	  fprintf(fd, "Authentication algorithm: HMAC-SHA1\n");
d584 1
a584 1
	  fprintf(fd, "Authentication algorithm: HMAC-RIPEMD-160\n");
d588 1
a588 1
	  fprintf(fd, "Unknown authentication algorithm: %d\n", proto->id);
d593 1
a593 1
      fprintf(fd, "report_proto: invalid proto %d\n", proto->proto);
d620 2
a621 2
  fprintf(fd, "SA name: %s", sa->name ? sa->name : "<unnamed>");
  fprintf(fd, " (Phase %d)\n", sa->phase);
d624 3
a626 3
  fprintf(fd, sa->transport == NULL ? "<no transport>" :
      sa->transport->vtbl->decode_ids (sa->transport));
  fprintf(fd, "\n");
d630 1
a630 1
      proto = TAILQ_NEXT (proto, link))
d635 1
a635 1
	  report_spi(fd, proto->spi[i], proto->spi_sz[i], i);
d637 1
a637 1
	  fprintf(fd, "SPI %d not defined.", i);
d639 2
a640 2
        /* Proto values. */
	report_proto(fd, proto);
d642 2
a643 2
	/* SA separator. */
	fprintf(fd, "\n");
d656 1
a656 1
  fd = fopen(SA_FILE, "w");
d662 1
a662 1
	fprintf(fd, "SA name: none (phase 1)\n\n");
d667 1
a667 1
  fclose(fd);
@


1.57
log
@size_t must be cast to (unsigned long) and printed using %lu
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.56 2002/05/28 10:09:46 ho Exp $	*/
d370 2
a371 1
      log_error ("sa_create: calloc (1, %lu) failed", (unsigned long)sizeof *sa);
d390 1
a390 1
		(unsigned long)sa->doi->sa_size);
d831 1
a831 1
		(unsigned long)sizeof *proto);
@


1.56
log
@Proper types in format strings. From <greg@@nest.cx>
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.55 2002/05/23 13:58:57 ho Exp $	*/
d95 2
a96 2
    log_fatal ("sa_init: malloc (%d) failed",
	       (bucket_mask + 1) * sizeof (struct sa_list));
d370 1
a370 1
      log_error ("sa_create: calloc (1, %d) failed", sizeof *sa);
d388 2
a389 1
	  log_error ("sa_create: calloc (1, %d) failed", sa->doi->sa_size);
d829 2
a830 1
	log_error ("sa_add_transform: calloc (1, %d) failed", sizeof *proto);
d848 2
a849 2
	  log_error ("sa_add_transform: calloc (1, %d) failed",
		     sa->doi->proto_size);
@


1.55
log
@One last sprintf -> snprintf, requested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.54 2002/03/17 21:50:59 angelos Exp $	*/
d95 1
a95 1
    log_fatal ("sa_init: malloc (%s) failed",
@


1.54
log
@Move SA_FILE definition to sa.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.53 2002/03/17 21:48:06 angelos Exp $	*/
d460 2
a461 1
  char s[73];
d467 1
a467 1
	sprintf (s + j, "%02x", buf[i++]);
@


1.53
log
@Add 'T' and 'S' commands (for tearing-down and reporting all Phase 2
SAs), from bdallen@@nps.navy.mil
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.52 2002/01/25 13:46:22 ho Exp $	*/
a64 3

/* Outfile for detailed SA information. */
#define SA_FILE "/var/run/isakmpd_sa"
@


1.52
log
@no static for sa_dump, explicit log cls/level
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.51 2001/11/21 10:01:43 ho Exp $	*/
d49 1
d63 5
d457 138
d607 61
d901 22
@


1.51
log
@%qd -> %llu in a couple of other places
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.50 2001/11/21 09:59:26 ho Exp $	*/
a75 1
static void sa_dump (char *, struct sa *);
d408 2
a409 2
static void
sa_dump (char *header, struct sa *sa)
d415 4
a418 5
  LOG_DBG ((LOG_REPORT, 0, "%s: %p %s phase %d doi %d flags 0x%x",
	    header, sa, sa->name ? sa->name : "<unnamed>", sa->phase,
	    sa->doi->id, sa->flags));
  LOG_DBG ((LOG_REPORT, 0,
	    "%s: icookie %08x%08x rcookie %08x%08x", header,
d421 1
a421 1
  LOG_DBG ((LOG_REPORT, 0, "%s: msgid %08x refcnt %d", header,
d423 2
a424 2
  LOG_DBG ((LOG_REPORT, 0, "%s: life secs %llu kb %llu", header,
	    sa->seconds, sa->kilobytes));
d428 3
a430 3
      LOG_DBG ((LOG_REPORT, 0,
		"%s: suite %d proto %d", header, proto->no, proto->proto));
      LOG_DBG ((LOG_REPORT, 0,
d434 1
a434 1
      LOG_DBG ((LOG_REPORT, 0, "%s: %s, %s", header,
d445 1
a445 1
	    LOG_DBG_BUF ((LOG_REPORT, 0, spi_header, proto->spi[i],
d460 1
a460 1
      sa_dump ("sa_report", sa);
@


1.50
log
@Have sa_dump() also print SA lifetimes (for /var/run/isakmpd.report).
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.49 2001/10/26 13:29:26 ho Exp $	*/
d798 1
a798 1
		"sa_setup_expirations: SA %p soft timeout in %qd seconds",
d816 1
a816 1
		"sa_setup_expirations: SA %p hard timeout in %qd seconds",
@


1.49
log
@Change to use sysdep_sa_len() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.48 2001/08/15 13:06:53 ho Exp $	*/
d425 2
@


1.48
log
@Some more style...
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.47 2001/07/05 12:36:55 ho Exp $	*/
a62 4
#ifndef SA_LEN
#define SA_LEN(x)		(x)->sa_len
#endif

d205 2
a206 2
  return dst->sa_len == addr->len
    && memcmp (dst, addr->addr, dst->sa_len) == 0;
d230 2
a231 2
  if (memcmp (src, arg->dst, SA_LEN(src)) &&
      memcmp (dst, arg->dst, SA_LEN(dst)))
@


1.47
log
@Add prototypes and some other various cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.46 2001/07/01 19:48:44 niklas Exp $	*/
d42 1
a42 1
#if defined(USE_KEYNOTE) || defined(USE_POLICY)
d577 1
a577 1
#if defined(USE_POLICY) || defined(USE_KEYNOTE)
@


1.46
log
@Style
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.45 2001/06/29 18:52:17 ho Exp $	*/
d77 3
d90 1
a90 1
sa_init ()
d105 1
d107 2
a108 2
void
sa_resize ()
d126 1
@


1.45
log
@Change get_src/get_dst API as we get the length with sa_len.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.44 2001/06/29 18:12:07 ho Exp $	*/
a99 1
 
d240 2
a241 2
/* 
 * Find an ISAKMP SA with a "name" of DST & SPI. 
d310 1
a310 1
 * NULL, meaning we are looking for phase 1 SAs.
d415 2
a416 2
  LOG_DBG ((LOG_REPORT, 0, "%s: %p %s phase %d doi %d flags 0x%x", 
	    header, sa, sa->name ? sa->name : "<unnamed>", sa->phase, 
d418 1
a418 1
  LOG_DBG ((LOG_REPORT, 0, 
d422 1
a422 1
  LOG_DBG ((LOG_REPORT, 0, "%s: msgid %08x refcnt %d", header, 
d427 1
a427 1
      LOG_DBG ((LOG_REPORT, 0, 
d429 1
a429 1
      LOG_DBG ((LOG_REPORT, 0, 
d434 3
a436 3
		sa->doi == NULL ? "<nodoi>"
		: sa->doi->decode_ids ("initiator id: %s, responder id: %s", 
				     sa->id_i, sa->id_i_len, 
d438 1
a438 1
		sa->transport == NULL ? "<no transport>" :
d444 1
a444 1
	    LOG_DBG_BUF ((LOG_REPORT, 0, spi_header, proto->spi[i], 
d533 1
a533 1
  
d673 1
a673 1
	     
d779 1
a779 1
  /* 
@


1.44
log
@A few more direct sa_len usages.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.43 2001/06/07 03:20:21 angelos Exp $	*/
a198 1
  socklen_t dstlen;
d204 1
a204 1
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
a222 1
  int dstlen, srclen;
d228 2
a229 2
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
@


1.43
log
@Correctly initialize the policy_id field on SA structures, such that
failed SAs don't cause the default policy context to be free'ed (and
thus cause no end of trouble in establishing further Phase 1 SAs)
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.42 2001/05/31 20:25:37 angelos Exp $	*/
d206 2
a207 1
  return dstlen == addr->len && memcmp (dst, addr->addr, dstlen) == 0;
@


1.42
log
@Appropriately release the cert and key fields in the SA structure on free.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.41 2001/04/24 07:27:37 niklas Exp $	*/
d379 1
@


1.41
log
@Correct SA refcounting.  Fixes a bug where isakmpd could die when a peer was
discovered to have rebooted, and old now invalid SAs had to be garbage-
collected.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.40 2001/04/09 22:09:52 ho Exp $	*/
d61 1
d560 6
a565 2
	else if (sa->recv_certtype == ISAKMP_CERTENC_NONE)
	  free (sa->recv_cert);
d568 5
a572 1
    free (sa->recv_key);
@


1.41.2.1
log
@Pull in patch from current:
Fix (angelos):
Correctly initialize the policy_id field on SA structures, such that
failed SAs don't cause the default policy context to be free'ed (and
thus cause no end of trouble in establishing further Phase 1 SAs)
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.41 2001/04/24 07:27:37 niklas Exp $	*/
a377 1
  sa->policy_id = -1;
@


1.40
log
@More style fixes...
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.39 2001/03/06 22:18:48 angelos Exp $	*/
d293 1
d506 1
a506 1
  sa_free_aux (sa);
d509 1
a509 1
/* Release all resources this SA is using except the death timers.  */
d511 1
a511 1
sa_free_aux (struct sa *sa)
d514 1
a514 1
  LOG_DBG ((LOG_SA, 70, "sa_free_aux: SA %p removed from SA list", sa));
d517 1
d586 1
a586 1
  LIST_REMOVE (sa, link);
d684 1
a684 1
  if (sa->phase != 1)
d696 1
d698 1
a708 2

  sa_release (sa);
d718 1
@


1.39
log
@Print the name of the marked SA (if available).
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.38 2001/02/24 04:42:48 angelos Exp $	*/
d235 1
a235 1
  if(memcmp (sa->cookies, arg->spi, ISAKMP_HDR_COOKIES_LEN) == 0)
d800 1
a800 1
      gettimeofday(&expiration, 0);
@


1.38
log
@Make DES a feature, so isakmpd can compile on Linux (most of the fixed
by newsham@@lava.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.37 2001/01/27 12:03:36 niklas Exp $	*/
d751 2
a752 1
  LOG_DBG ((LOG_SA, 60, "sa_mark_replaced: SA %p marked as replaced", sa));
@


1.37
log
@(c) 2001
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.36 2001/01/26 12:12:52 niklas Exp $	*/
d62 4
d230 2
a231 2
  if (memcmp (src, arg->dst, src->sa_len) &&
      memcmp (dst, arg->dst, dst->sa_len))
@


1.36
log
@Pedantic style police
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.35 2001/01/22 08:14:24 angelos Exp $	*/
d5 2
a6 2
 * Copyright (c) 1998, 1999, 2000 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999 Angelos D. Keromytis.  All rights reserved.
@


1.35
log
@Fix memory leak on exchange free.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.34 2001/01/14 23:40:01 angelos Exp $	*/
d786 1
a786 1
	  /* If we don't give up we might start leaking... */
d804 1
a804 1
	  /* If we don't give up we might start leaking... */
@


1.34
log
@Handling of Phase 1 DELETE and Phase 2 INVALID_SPI messages
(newsham@@lava.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.33 2000/12/12 01:47:12 niklas Exp $	*/
d42 5
d60 1
a511 1

d558 1
a558 1
#if defined(POLICY) || defined(KEYNOTE)
d560 1
a560 1
    LK (kn_close, (sa->policy-id));
@


1.33
log
@Merge with EOM 1.112

author: niklas
style

author: angelos
Don't limit Phase 1 SA establishment -- while this does limit resource
consumption, it's neither foolproof nor entirely correct (it
introduces some synchronization problems).
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.32 2000/10/16 23:27:43 niklas Exp $	*/
d196 44
@


1.32
log
@Merge with EOM 1.110

author: provos
better referencing.  okay niklas@@

author: niklas
Allow new and old style configuration simultaneously
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.31 2000/08/03 07:28:44 niklas Exp $	*/
/*	$EOM: sa.c,v 1.110 2000/10/16 18:16:59 provos Exp $	*/
d628 3
a630 1
  message_send_delete (sa);
@


1.32.2.1
log
@Pull in isakmpd from 2.9 to 2.8 branch.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.41 2001/04/24 07:27:37 niklas Exp $	*/
/*	$EOM: sa.c,v 1.112 2000/12/12 00:22:52 niklas Exp $	*/
d5 2
a6 2
 * Copyright (c) 1998, 1999, 2000, 2001 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 1999, 2001 Angelos D. Keromytis.  All rights reserved.
a41 5
#if defined(USE_KEYNOTE) || defined(USE_POLICY)
#include <regex.h>
#include <keynote.h>
#endif /* USE_KEYNOTE || USE_POLICY */

a54 5
#include "policy.h"

#ifndef SA_LEN
#define SA_LEN(x)		(x)->sa_len
#endif
a197 44
struct dst_isakmpspi_arg {
  struct sockaddr *dst;
  u_int8_t *spi;			/* must be ISAKMP_SPI_SIZE octets */
};

/*
 * Check if SA matches what we are asking for through V_ARG.  It has to
 * be a finished phaes 1 (ISAKMP) SA.
 */
static int
isakmp_sa_check (struct sa *sa, void *v_arg)
{
  struct dst_isakmpspi_arg *arg = v_arg;
  struct sockaddr *dst, *src;
  int dstlen, srclen;

  if (sa->phase != 1 || !(sa->flags & SA_FLAG_READY))
    return 0;

  /* verify address is either src or dst for this sa */
  sa->transport->vtbl->get_dst (sa->transport, &dst, &dstlen);
  sa->transport->vtbl->get_src (sa->transport, &src, &srclen);
  if (memcmp (src, arg->dst, SA_LEN(src)) &&
      memcmp (dst, arg->dst, SA_LEN(dst)))
    return 0;

  /* match icookie+rcookie against spi */
  if (memcmp (sa->cookies, arg->spi, ISAKMP_HDR_COOKIES_LEN) == 0)
    return 1;

  return 0;
}

/* 
 * Find an ISAKMP SA with a "name" of DST & SPI. 
 */
struct sa *
sa_lookup_isakmp_sa (struct sockaddr *dst, u_int8_t *spi)
{
  struct dst_isakmpspi_arg arg = { dst, spi };

  return sa_find (isakmp_sa_check, &arg);
}

a238 1
  sa_reference (sa);
d451 1
a451 1
  sa_remove (sa);
d454 1
a454 1
/* Remove the SA from the hash table of live SAs.  */
d456 1
a456 1
sa_remove (struct sa *sa)
d459 1
a459 1
  LOG_DBG ((LOG_SA, 70, "sa_remove: SA %p removed from SA list", sa));
d509 1
a509 1
#if defined(USE_POLICY) || defined(USE_KEYNOTE)
d511 1
a511 1
    LK (kn_close, (sa->policy_id));
d531 1
a531 1
  sa_remove (sa);
d628 1
a628 3
  /* Don't bother notifying of Phase 1 SA deletes.  */
  if (sa->phase != 1 && notify)
    message_send_delete (sa);
a638 1

a639 1
  sa_release (sa);
d650 2
a660 1
  sa_release (sa);
d696 1
a696 2
  LOG_DBG ((LOG_SA, 60, "sa_mark_replaced: SA %p (%s) marked as replaced",
	    sa, sa->name ? sa->name : "unnamed"));
d735 1
a735 1
	  /* If we don't give up we might start leaking...  */
d744 1
a744 1
      gettimeofday (&expiration, 0);
d753 1
a753 1
	  /* If we don't give up we might start leaking...  */
@


1.32.2.2
log
@Pull in patch from current, requested by angelos@@
Fix (angelos):
Correctly initialize policy ID such that Phase 1 SAs can correctly
operate beyond one hour.
This only affects sessions established with KeyNote credentials.
@
text
@d1 1
a1 1
/*	$OpenBSD: sa.c,v 1.32.2.1 2001/05/08 12:45:25 ho Exp $	*/
a377 1
  sa->policy_id = -1;
@


1.31
log
@Merge with EOM 1.108

author: niklas
remove unnecessary include
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.30 2000/08/03 07:24:23 niklas Exp $	*/
/*	$EOM: sa.c,v 1.108 2000/08/03 07:22:29 niklas Exp $	*/
d440 5
a444 1
    timer_remove_event (sa->death);
d446 5
a450 1
    timer_remove_event (sa->soft_death);
d650 2
d679 3
a681 1
    { "active-only", SA_FLAG_ACTIVE_ONLY }
d739 1
d757 1
@


1.30
log
@Merge with EOM 1.107

author: provos
provide transport dependent ID decoding; hope indentation is right now ;)

author: provos
make a DOI specific decode_ids, but have isakmp doi decode point to
ipsec.

author: provos
introduce ipsec_decode_ids, also decodes FQDN and USER_FQDN now.
new ipsec_clone_id to copy IDs to phase 2 SAs for better status
reports. okay angelos@@
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.29 2000/06/08 20:51:11 niklas Exp $	*/
/*	$EOM: sa.c,v 1.107 2000/07/17 18:57:59 provos Exp $	*/
a46 1
#include "ipsec.h"
@


1.29
log
@Merge with EOM 1.104

author: angelos
Allow exchange of KeyNote credentials over IKE. Multiple credentials
may be passed in a single CERT payload. KeyNote is used if a
directory named as the local ID we use in an exchange exists in the
KeyNote directory (default: /etc/isakmpd/keynote/). Note that
asymmetric credentials are possible (use KeyNote in one direction and
X509 in the other); such authentication is envisioned to be the most
common: the clients will use KeyNote credentials to authenticate and
authorize with a server, whilst the server will just provide an X509
certificate proving its binding to the IP address or ID.

Totally asymmetric authentication (e.g., shared key in one direction,
RSA in the other) is not supported by the IKE protocol.

author: angelos
Cleanup.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.28 2000/05/02 14:36:04 niklas Exp $	*/
/*	$EOM: sa.c,v 1.104 2000/05/19 05:47:52 angelos Exp $	*/
d47 1
d379 7
@


1.28
log
@Merge with EOM 1.102

author: provos
fix arguments in debug message for sa_setup_expirations
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.27 2000/04/07 22:10:30 niklas Exp $	*/
/*	$EOM: sa.c,v 1.102 2000/04/12 03:10:57 provos Exp $	*/
d492 6
@


1.27
log
@conf.c: Merge with EOM 1.22
gmp_util.c: Merge with EOM 1.5
gmp_util.h: Merge with EOM 1.3
math_mp.h: Merge with EOM 1.2
sa.c: Merge with EOM 1.101
ui.c: Merge with EOM 1.40

author: niklas
(c) 2000
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.26 2000/04/07 22:06:44 niklas Exp $	*/
/*	$EOM: sa.c,v 1.101 2000/04/07 22:05:57 niklas Exp $	*/
d704 1
a704 1
		seconds));
d721 1
a721 1
		sa->seconds));
@


1.26
log
@conf.c: Merge with EOM 1.21
isakmpd.c: Merge with EOM 1.46
sa.c: Merge with EOM 1.100
ui.c: Merge with EOM 1.39

author: niklas
error message style
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.25 2000/02/25 17:23:38 niklas Exp $	*/
/*	$EOM: sa.c,v 1.100 2000/04/07 19:05:01 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998, 1999 Niklas Hallqvist.  All rights reserved.
@


1.25
log
@regress/crypto/Makefile: Merge with EOM 1.5
regress/dh/Makefile: Merge with EOM 1.7
regress/group/Makefile: Merge with EOM 1.9
regress/prf/Makefile: Merge with EOM 1.4
regress/rsakeygen/Makefile: Merge with EOM 1.8
regress/x509/Makefile: Merge with EOM 1.10
Makefile: Merge with EOM 1.62
attribute.c: Merge with EOM 1.10
sa.c: Merge with EOM 1.99
conf.c: Merge with EOM 1.20
crypto.c: Merge with EOM 1.28
isakmpd.c: Merge with EOM 1.45
connection.c: Merge with EOM 1.19
doi.h: Merge with EOM 1.28
field.c: Merge with EOM 1.11
exchange.c: Merge with EOM 1.116
ike_auth.c: Merge with EOM 1.44
pf_key_v2.c: Merge with EOM 1.37
ike_phase_1.c: Merge with EOM 1.22
ipsec.c: Merge with EOM 1.118
isakmp_doi.c: Merge with EOM 1.40
log.c: Merge with EOM 1.26
log.h: Merge with EOM 1.18
math_group.c: Merge with EOM 1.23
message.c: Merge with EOM 1.144
pf_encap.c: Merge with EOM 1.70
policy.c: Merge with EOM 1.18
timer.c: Merge with EOM 1.13
transport.c: Merge with EOM 1.41
udp.c: Merge with EOM 1.47
ui.c: Merge with EOM 1.37
x509.c: Merge with EOM 1.36

author: niklas
Made debug logging a compile time selectable feature
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.24 2000/02/01 02:46:18 niklas Exp $	*/
/*	$EOM: sa.c,v 1.99 2000/02/20 19:58:42 niklas Exp $	*/
d83 2
a84 1
    log_fatal ("init_sa: out of memory");
@


1.24
log
@apps/certpatch/certpatch.8: Merge with EOM 1.4
apps/certpatch/certpatch.c: Merge with EOM 1.6
exchange.c: Merge with EOM 1.114
ike_quick_mode.c: Merge with EOM 1.110
ike_phase_1.c: Merge with EOM 1.16
ike_auth.c: Merge with EOM 1.41
ike_aggressive.c: Merge with EOM 1.4
libcrypto.c: Merge with EOM 1.10
libcrypto.h: Merge with EOM 1.10
isakmpd.8: Merge with EOM 1.19
isakmpd.c: Merge with EOM 1.42
ipsec.h: Merge with EOM 1.40
init.c: Merge with EOM 1.22
message.c: Merge with EOM 1.143
message.h: Merge with EOM 1.49
sa.c: Merge with EOM 1.98
sa.h: Merge with EOM 1.54
policy.c: Merge with EOM 1.14
pf_key_v2.c: Merge with EOM 1.36
x509.c: Merge with EOM 1.32
x509.h: Merge with EOM 1.9
udp.c: Merge with EOM 1.46

author: niklas
Angelos copyrights
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.23 1999/08/26 22:27:51 niklas Exp $	*/
/*	$EOM: sa.c,v 1.98 2000/01/31 22:33:48 niklas Exp $	*/
d123 1
a123 1
	log_debug (LOG_SA, 90, "sa_find: return SA %p", sa);
d126 1
a126 1
  log_debug (LOG_SA, 90, "sa_find: no SA matched query");
d238 1
a238 1
  log_debug (LOG_SA, 70, "sa_enter: SA %p added to SA list", sa);
d341 4
a344 4
  log_debug (LOG_SA, 60,
	     "sa_create: sa %p phase %d added to exchange %p (%s)", sa,
	     sa->phase, exchange,
	     exchange->name ? exchange->name : "<unnamed>");
d359 9
a367 9
  log_debug (LOG_REPORT, 0, "%s: %p %s phase %d doi %d flags 0x%x", 
	     header, sa, sa->name ? sa->name : "<unnamed>", sa->phase, 
	     sa->doi->id, sa->flags);
  log_debug (LOG_REPORT, 0, 
	     "%s: icookie %08x%08x rcookie %08x%08x", header,
	     decode_32 (sa->cookies), decode_32 (sa->cookies + 4),
	     decode_32 (sa->cookies + 8), decode_32 (sa->cookies + 12));
  log_debug (LOG_REPORT, 0, "%s: msgid %08x refcnt %d", header, 
	     decode_32 (sa->message_id), sa->refcnt);
d371 6
a376 6
      log_debug (LOG_REPORT, 0, 
		 "%s: suite %d proto %d", header, proto->no, proto->proto);
      log_debug (LOG_REPORT, 0, 
		 "%s: spi_sz[0] %d spi[0] %p spi_sz[1] %d spi[1] %p", header,
		 proto->spi_sz[0], proto->spi[0], proto->spi_sz[1],
		 proto->spi[1]);
d381 2
a382 2
	    log_debug_buf (LOG_REPORT, 0, spi_header, proto->spi[i], 
			   proto->spi_sz[i]);
d422 1
a422 1
  log_debug (LOG_MISC, 90, "proto_free: freeing %p", proto);
d443 1
a443 1
  log_debug (LOG_SA, 70, "sa_free_aux: SA %p removed from SA list", sa);
d452 2
a453 2
  log_debug (LOG_SA, 80, "sa_reference: SA %p now has %d references",
	     sa, sa->refcnt);
d463 2
a464 2
  log_debug (LOG_SA, 80, "sa_release: SA %p had %d references",
	     sa, sa->refcnt);
d469 1
a469 1
  log_debug (LOG_SA, 60, "sa_release: freeing SA %p", sa);
d583 5
a587 4
  log_debug (LOG_SA, 80,
	     "sa_add_transform: proto %p no %d proto %d chosen %p sa %p id %d",
	     proto, proto->no, proto->proto, proto->chosen, proto->sa,
	     proto->id);
d670 1
a670 1
  log_debug (LOG_SA, 60, "sa_mark_replaced: SA %p marked as replaced", sa);
d701 3
a703 3
      log_debug (LOG_TIMER, 95,
		 "sa_setup_expirations: SA %p soft timeout in %qd seconds",
		 seconds);
d718 3
a720 3
      log_debug (LOG_TIMER, 95,
		 "sa_setup_expirations: SA %p hard timeout in %qd seconds",
		 sa->seconds);
@


1.23
log
@ike_phase_1.c: Merge with EOM 1.8
message.c: Merge with EOM 1.135
message.h: Merge with EOM 1.48
sa.c: Merge with EOM 1.97
sa.h: Merge with EOM 1.53

author: angelos
Complete policy work; tested for the shared-key case. Documentation needed.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.22 1999/07/07 22:10:11 niklas Exp $	*/
/*	$EOM: sa.c,v 1.97 1999/08/18 00:44:57 angelos Exp $	*/
d6 1
@


1.22
log
@Merge with EOM 1.96

author: ho
We no longer use flag "Stayalive"
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.21 1999/06/02 06:29:35 niklas Exp $	*/
/*	$EOM: sa.c,v 1.96 1999/06/06 17:12:40 ho Exp $	*/
d53 1
d460 2
a461 1

d477 12
@


1.21
log
@Merge with EOM 1.95

author: niklas
Some extra error checking, documentation and style wrt connections

author: ho
New flag

author: niklas
SA expiration randomization is really only good on the soft timeout, early
hard expires may break more if we have a situation where our peer only
wants to act as initiator, and trusts the negotiated lifetime.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.20 1999/05/14 20:09:50 niklas Exp $	*/
/*	$EOM: sa.c,v 1.95 1999/05/30 14:12:33 niklas Exp $	*/
a638 1
    { "stayalive", SA_FLAG_STAYALIVE },
@


1.20
log
@Merge with EOM 1.92

author: ho
seconds should have initial value
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.19 1999/05/06 22:44:42 niklas Exp $	*/
/*	$EOM: sa.c,v 1.92 1999/05/09 20:26:17 ho Exp $	*/
d630 1
a630 2
 * Get a SA attribute's flag value out of textual description.
 * XXX Kind of overkill for just one attribute, maybe simplify?
d639 2
a640 1
    { "stayalive", SA_FLAG_STAYALIVE }
d672 3
a674 2
   * Decrease lifetime by random 0-5% to break strictly synchronized
   * renegotiations. Works better when the randomization is of the
d676 3
a678 4
   * I.e depends on configuration and negotiated lifetimes.
   * This decrease is only done if we have a name, and thus can act as
   * initiator at the expiry time, otherwise we may drop our SA before
   * our peer, with no possibility to reestablish it.
a680 10
  if (sa->name)
    {
      seconds = sa->seconds * (950 + sysdep_random () % 51) / 1000;

      log_debug (LOG_TIMER, 95,
		 "sa_setup_expirations: "
		 "SA lifetime reset from %qd to %qd seconds",
		 sa->seconds, seconds);
    }

d684 6
a689 1
      expiration.tv_sec += seconds * 9 / 10;
d703 4
a706 1
      expiration.tv_sec += seconds;
@


1.19
log
@Merge with EOM 1.91

author: niklas
Do not decrease SA lifetime if we cannot act as initiator
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.18 1999/05/01 22:58:02 niklas Exp $	*/
/*	$EOM: sa.c,v 1.91 1999/05/06 21:43:12 niklas Exp $	*/
d668 1
a668 1
  u_int64_t seconds;
@


1.18
log
@TO-DO: Merge with EOM 1.36
sa.c: Merge with EOM 1.90
message.c: Merge with EOM 1.131
message.h: Merge with EOM 1.47

author: niklas
Send DELETE payloads in informational exchanges
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.17 1999/04/30 11:46:06 niklas Exp $	*/
/*	$EOM: sa.c,v 1.90 1999/05/01 22:36:31 niklas Exp $	*/
d676 3
d681 3
a683 1
  seconds = sa->seconds * (950 + sysdep_random () % 51) / 1000;
d685 5
a689 3
  log_debug (LOG_TIMER, 95,
	     "sa_setup_expirations: SA lifetime reset from %qd to %qd seconds",
	     sa->seconds, seconds);
@


1.17
log
@Merge with EOM 1.89

author: niklas
Do not put multiple expirations on a single SA
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.16 1999/04/27 20:59:46 niklas Exp $	*/
/*	$EOM: sa.c,v 1.89 1999/04/29 12:08:00 niklas Exp $	*/
d590 1
a590 2
  /* XXX we do not send DELETE payloads just yet.  */

@


1.16
log
@sa.c: Merge with EOM 1.88
sa.h: Merge with EOM 1.51

author: niklas
Handle leftover payloads, esp INITIAL CONTACT notifications.
Factor out SA expiration setting.  Add commentary.

author: ho
Keep track of trailing retransmissions by keeping exchanges around longer.
Removed references to sa->last_sent_in_setup, use last_sent and
last_received in exchange instead. Free setup exchanges by expiration only.

author: ho
Backout last change. (Go with exchange directly instead of sa->msg)

author: ho
Handle phase 2 late retransmissions.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.15 1999/04/20 11:32:21 niklas Exp $	*/
/*	$EOM: sa.c,v 1.88 1999/04/27 09:42:29 niklas Exp $	*/
d620 1
a684 4
  gettimeofday (&expiration, 0);
  expiration.tv_sec += seconds * 9 / 10;
  sa->soft_death
    = timer_add_event ("sa_soft_expire", sa_soft_expire, sa, &expiration);
d687 10
a696 3
      /* If we don't give up we might start leaking... */
      sa_delete (sa, 1);
      return -1;
a698 4
  gettimeofday(&expiration, 0);
  expiration.tv_sec += seconds;
  sa->death
    = timer_add_event ("sa_hard_expire", sa_hard_expire, sa, &expiration);
d701 10
a710 3
      /* If we don't give up we might start leaking... */
      sa_delete (sa, 1);
      return -1;
@


1.15
log
@Merge with EOM 1.84

author: ho
Style
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.14 1999/04/19 20:53:05 niklas Exp $	*/
/*	$EOM: sa.c,v 1.84 1999/04/20 09:49:08 ho Exp $	*/
d65 2
d128 1
d148 1
d167 46
d297 1
a297 1
/* Create a SA.  */
d346 4
d385 1
d397 1
a439 5
  if (sa->last_sent_in_setup)
    {
      exchange_release (sa->last_sent_in_setup->exchange);
      message_free (sa->last_sent_in_setup);
    }
a585 24
/* Lookup an ISAKMP SA given its peer address.  */
struct sa *
sa_isakmp_lookup_by_peer (struct sockaddr *addr, size_t addr_len)
{
  int i;
  struct sa *sa;
  struct sockaddr *taddr;
  int taddr_len;

  for (i = 0; i <= bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      /*
       * XXX We check the transport because it can be NULL until we fix
       * the initiator case to set the transport always.
       */
      if (sa->phase == 1 && (sa->flags & SA_FLAG_READY) && sa->transport)
	{
	  sa->transport->vtbl->get_dst (sa->transport, &taddr, &taddr_len);
	  if (taddr_len == addr_len && memcmp (taddr, addr, addr_len) == 0)
	    return sa;
	}
  return 0;
}

d598 2
a599 2
void
sa_soft_expire (struct sa *sa)
d601 1
d616 2
a617 2
void
sa_hard_expire (struct sa *sa)
d619 1
d657 49
@


1.14
log
@./sa.c: Merge with EOM 1.83

Off by one (< -> <=)

Added classes LOG_SA and LOG_EXCHANGE, converted
many LOG_MISC to new classes, adjusted levels slightly.
More SA logging.

Simplify the checks of existing exchanges by moving it into
exchange_establish.  This means we need to change the finalize API.
Try to make PF_ENCAP support handle multiple connections to a single
security gateway.

Dump the SA refcount when doing sa_dump

Add LOG_REPORT to always go to logchannel regardless of level; misc small fixes

Remove SA_FLAG_REPLACED settings from various parts in preparation of a
grand unified setting in exchange_finalize.  Fix sa_mark_replaced to not
release a referance to the sa, and adjust the API as it won't get called
as a finalize func anymore.

Garbage collect transports via refcounting.  Fix commentary.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.13 1999/04/05 20:59:05 niklas Exp $	*/
/*	$EOM: sa.c,v 1.83 1999/04/16 23:25:30 niklas Exp $	*/
d626 1
a626 1
  log_debug (LOG_SA, 60, "SA %p marked as replaced", sa);
@


1.13
log
@Merge with EOM 1.76
Allocation failure reporting.  Debug printouts.  Typecast correctly.

New finalize API.  Free keystate.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.12 1999/04/02 01:08:51 niklas Exp $	*/
/*	$EOM: sa.c,v 1.76 1999/04/05 18:32:11 niklas Exp $	*/
d87 1
a87 1
/* XXX Ww don't yet resize.  */
d115 1
a115 1
  for (i = 0; i < bucket_mask; i++)
d118 2
d121 2
d186 1
d264 2
d289 1
a289 1
  log_debug (LOG_MISC, 90,
d303 2
a304 2
  log_debug (LOG_MISC, 10, "%s: %p %s phase %d doi %d flags 0x%x",
	     header, sa, sa->name ? sa->name : "<unnamed>", sa->phase,
d306 1
a306 1
  log_debug (LOG_MISC, 10,
d310 2
a311 2
  log_debug (LOG_MISC, 10, "%s: msgid %08x", header,
	     decode_32 (sa->message_id));
d315 1
a315 1
      log_debug (LOG_MISC, 10,
d317 1
a317 1
      log_debug (LOG_MISC, 10,
d325 1
a325 1
	    log_debug_buf (LOG_MISC, 10, spi_header, proto->spi[i],
d337 1
a337 1
  for (i = 0; i < bucket_mask; i++)
d363 1
d390 1
d399 2
d409 3
d415 1
a415 1
  log_debug (LOG_MISC, 80, "sa_release: freeing SA %p", sa);
d429 2
d446 1
d448 1
a448 1
   *  We don't install a transport in the initiator case as we don't know
d452 1
d517 1
a517 1
  log_debug (LOG_MISC, 80,
d544 1
a544 1
  for (i = 0; i < bucket_mask; i++)
d578 1
a578 9
    {
      /* If we are already renegotiating, don't start over.  */
      if (!exchange_lookup_by_name (sa->name, 1))
	{
	  sa_reference (sa);
	  exchange_establish (sa->name,
			      (void (*) (void *, int))sa_mark_replaced, sa);
	}
    }
d580 5
a584 7
    {
      /*
       * Start to watch the use of this SA, so a renegotiation can
       * happen as soon as it is shown to be alive.
       */
      sa->flags |= SA_FLAG_FADING;
    }
d595 1
a595 9
    {
      /* If we are already renegotiating, don't start over.  */
      if (!exchange_lookup_by_name (sa->name, 1))
	{
	  sa_reference (sa);
	  exchange_establish (sa->name,
			      (void (*) (void *, int))sa_mark_replaced, sa);
	}
    }
d618 1
a618 1
  log_print (LOG_MISC, 10, "sa_flag: attribute \"%s\" unknown", attr);
d624 1
a624 1
sa_mark_replaced (struct sa *sa, int fail)
d626 2
a627 6
  if (!fail)
    {
      log_debug (LOG_MISC, 90, "SA %p marked as replaced", sa);
      sa->flags |= SA_FLAG_REPLACED;
    }
  sa_release (sa);
@


1.12
log
@Merge with EOM 1.74
refcounting on exchanges

Do not malloc zero bytes, some implementations dislike

Only find non-replaced SAs when searching by name

resource track exchange->name and sa->name
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.11 1999/03/31 20:31:05 niklas Exp $	*/
/*	$EOM: sa.c,v 1.74 1999/04/02 00:39:59 niklas Exp $	*/
d355 3
d413 2
d452 5
a456 1
    proto = calloc (1, sizeof *proto);
d472 5
a476 1
	goto cleanup;
d495 1
a495 1
  /* Let the DOI get at proto for initializing its own data. */
d499 5
d565 2
a566 2
	  exchange_establish (sa->name, (void (*) (void *))sa_mark_replaced,
			      sa);
d592 2
a593 2
	  exchange_establish (sa->name, (void (*) (void *))sa_mark_replaced,
			      sa);
d622 1
a622 4
/*
 * Mark SA as replaced.  As SA has potentially disappeared before we get
 * called, check if it still exists before marking.
 */
d624 1
a624 1
sa_mark_replaced (struct sa *sa)
d626 5
a630 2
  log_debug (LOG_MISC, 90, "SA %p marked as replaced", sa);
  sa->flags |= SA_FLAG_REPLACED;
@


1.11
log
@Merge with EOM 1.70
Add refcounting to SA's.  Make phase 1 expirations be able to cause
renegotiations if configured to.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.10 1999/03/31 00:52:06 niklas Exp $	*/
/*	$EOM: sa.c,v 1.70 1999/03/31 20:19:56 niklas Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 Niklas Hallqvist.  All rights reserved.
d147 1
a147 1
    sa->phase == arg->phase;
d255 1
a255 1
      log_error ("sa_create: calloc (1, %d) failed", sa->doi->sa_size);
d264 1
a264 3
  /* Allocate the DOI-specific structure and initialize it to zeroes.  */
  sa->data = calloc (1, sa->doi->sa_size);
  if (!sa->data)
d266 8
a273 3
      log_error ("sa_create: calloc (1, %d) failed", sa->doi->sa_size);
      free (sa);
      return -1;
d374 4
a377 1
    message_free (sa->last_sent_in_setup);
d398 2
d408 2
@


1.10
log
@Merge with EOM 1.69
Add debugging.  Provide a way to say an SA has been replaced wrt the flows.
Do not free the flow information before calling the sysdep delete_spi
routine, as it may use it.
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.9 1999/03/24 14:41:17 niklas Exp $	*/
/*	$EOM: sa.c,v 1.69 1999/03/30 21:45:47 niklas Exp $	*/
d277 1
d366 1
a366 1
/* Release all resources this SA is using except the death timer.  */
d370 17
d389 3
a391 2
  if (sa->last_sent_in_setup)
    message_free (sa->last_sent_in_setup);
a399 1
  LIST_REMOVE (sa, link);
d530 19
a548 4
  /*
   * XXX Start to watch the use of this SA, so a renegotiation can
   * happen as soon as it is shown to be alive.
   */
d556 13
a593 7
/* Is SA equal to V_SA?  */
static int
sa_equal (struct sa *sa, void *v_sa)
{
  return sa == v_sa;
}

d601 3
a603 5
  if (sa_find (sa_equal, sa))
    {
      log_debug (LOG_MISC, 90, "SA %p marked as replaced", sa);
      sa->flags |= SA_FLAG_REPLACED;
    }
@


1.9
log
@Merge with EOM 1.68
Stash SPIs in the right slots
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.8 1999/03/02 15:48:23 niklas Exp $	*/
/*	$EOM: sa.c,v 1.68 1999/03/24 11:04:55 niklas Exp $	*/
d254 4
a257 1
    return -1;
d268 1
d270 1
a270 1
      return 0;
d277 5
d305 5
a309 4
		 "%s: suite %d proto %d "
		 "spi_sz[0] %d spi[0] %p spi_sz[1] %d spi[1] %p",
		 header, proto->no, proto->proto, proto->spi_sz[0],
		 proto->spi[0], proto->spi_sz[1], proto->spi[1]);
d371 4
a380 4
  if (sa->last_sent_in_setup)
    message_free (sa->last_sent_in_setup);
  while ((proto = TAILQ_FIRST (&sa->protos)) != 0)
    proto_free (proto);
d546 21
@


1.8
log
@sa.c: Merge with EOM 1.67
Add SA attributes, specifically stayalive

sa.h: Merge with EOM 1.42
Add SA attributes, specifically stayalive

pf_encap.c: Merge with EOM 1.46
Add SA attributes, specifically stayalive

exchange.c: Merge with EOM 1.65
Add SA attributes, specifically stayalive
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.7 1999/02/26 03:50:09 niklas Exp $	*/
/*	$EOM: sa.c,v 1.67 1999/03/02 15:42:57 niklas Exp $	*/
d430 2
a431 2
  proto->spi_sz[!initiator] = GET_ISAKMP_PROP_SPI_SZ (prop->p);
  if (proto->spi_sz[!initiator])
d433 2
a434 2
      proto->spi[!initiator] = malloc (proto->spi_sz[!initiator]);
      if (!proto->spi[!initiator])
d436 1
a436 2
      memcpy (proto->spi[!initiator], prop->p + ISAKMP_PROP_SPI_OFF,
	      proto->spi_sz[!initiator]);
@


1.7
log
@Merge from the Ericsson repository
| revision 1.66
| date: 1999/02/25 11:39:20;  author: niklas;  state: Exp;  lines: +3 -1
| include sysdep.h everywhere
| ----------------------------
| revision 1.65
| date: 1999/02/25 10:21:33;  author: niklas;  state: Exp;  lines: +2 -2
| Replay window changes was done at the wrong level
| ----------------------------
| revision 1.64
| date: 1999/02/25 09:30:30;  author: niklas;  state: Exp;  lines: +6 -1
| Replay protection window configurable
| ----------------------------
| revision 1.63
| date: 1999/02/14 00:11:38;  author: niklas;  state: Exp;  lines: +52 -27
| Generalize how to find SAs with given attributes.  Do SA expiration both hard
| and soft, and do not rekey automatically anymore.  We will revisit this by
| adding some kind of policy what to do at these times.  Improve commentary
| ----------------------------
| revision 1.62
| date: 1999/02/06 15:07:23;  author: niklas;  state: Exp;  lines: +3 -1
| remove referense to rekey event when it has happened
| ----------------------------
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.6 1998/12/21 01:02:27 niklas Exp $	*/
/*	$EOM: sa.c,v 1.66 1999/02/25 11:39:20 niklas Exp $	*/
d515 22
@


1.6
log
@Last months worth of work on isakmpd, lots done
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.5 1998/11/20 07:31:56 niklas Exp $	*/
/*	$EOM: sa.c,v 1.61 1998/12/17 07:57:04 niklas Exp $	*/
d41 2
d108 1
a108 1
/* Lookup an ISAKMP SA out of just the initiator cookie.  */
d110 1
a110 1
sa_lookup_from_icookie (u_int8_t *cookie)
d117 1
a117 2
      if (memcmp (sa->cookies, cookie, ISAKMP_HDR_ICOOKIE_LEN) == 0
	  && sa->phase == 1)
d122 28
d154 1
a154 2
  int i;
  struct sa *sa;
d156 1
a156 6
  for (i = 0; i < bucket_mask; i++)
    for (sa = LIST_FIRST (&sa_tab[i]); sa; sa = LIST_NEXT (sa, link))
      if (sa->name && strcasecmp (sa->name, name) == 0
	  && sa->phase == phase)
	return sa;
  return 0;
d350 2
d396 3
a398 2
 * Register the chosen transform into the SA.  As a side effect set PROTOP
 * to point at the corresponding proto structure.
d444 5
d495 5
a499 2
static void
sa_finalize_rekey_p1 (void *arg)
d501 1
a501 1
  struct sa *sa = arg;
d503 4
a506 1
  sa_delete (sa, 1);
d509 1
a509 4
/*
 * Establish a new ISAKMP SA.
 * XXX Whatif the peer initiated another SA negotiation?
 */
d511 1
a511 1
sa_rekey_p1 (struct sa *sa)
d513 2
a514 2
  exchange_establish_p1 (sa->transport, 0, 0, sa->name, sa_finalize_rekey_p1,
			 sa);
@


1.5
log
@typo
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.4 1998/11/17 22:36:20 niklas Exp $	*/
/*	$EOM: sa.c,v 1.57 1998/11/20 07:10:22 niklas Exp $	*/
d121 15
d210 3
a212 1
		  != 0));
d260 3
a262 3
  log_debug (LOG_MISC, 10, "%s: phase %d doi %d msgid %08x flags 0x%x",
	     header, sa->phase, sa->doi->id, decode_32 (sa->message_id),
	     sa->flags);
d267 2
d464 8
d479 2
a480 5
  /* XXX Fill in the args argument.  */
  exchange_establish_p1 (sa->transport, sa->exch_type, sa->doi->id, 0);

  /* XXX I want this sa_delete deferred until the new SA is ready.  */
  sa_delete (sa, 1);
@


1.4
log
@From the EOM repos: Only find ready ISAKMP SAs in
sa_isakmp_lookup_by_peer
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.56 1998/11/17 21:58:07 niklas Exp $	*/
/*	$EOM: sa.c,v 1.56 1998/11/17 21:58:07 niklas Exp $	*/
d427 1
a427 1
      if (sa->phase == 1 && (sa->flags & SA_READY) && sa->transport)
@


1.3
log
@Add RCS Ids from the EOM repository
@
text
@d1 2
a2 2
/*	$OpenBSD: sa.c,v 1.2 1998/11/15 00:44:02 niklas Exp $	*/
/*	$EOM: sa.c,v 1.55 1998/11/14 23:42:26 niklas Exp $	*/
d427 1
a427 1
      if (sa->phase == 1 && sa->transport)
@


1.2
log
@openBSD RCS IDs
@
text
@d1 2
a2 1
/*	$OpenBSD: sa.c,v 1.1.1.1 1998/11/15 00:03:49 niklas Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$Id: sa.c,v 1.55 1998/11/14 23:42:26 niklas Exp $	*/
@


1.1.1.1
log
@Initial import of isakmpd, an IKE (ISAKMP/Oakley) implementation for the
OpenBSD IPSEC stack by me, Niklas Hallqvist and Niels Provos, funded by
Ericsson Radio Systems.  It is not yet complete or usable in a real scenario
but the missing pieces will soon be there.  The early commit is for people
who wants early access and who are not afraid of looking at source.
isakmpd interops with Cisco, Timestep, SSH & Pluto (Linux FreeS/WAN) so
far, so it is not that incomplete.  It is really mostly configuration that
is lacking.
@
text
@@
