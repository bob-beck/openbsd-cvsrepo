head	1.663;
access;
symbols
	OPENBSD_6_2:1.663.0.4
	OPENBSD_6_2_BASE:1.663
	OPENBSD_6_1:1.657.0.4
	OPENBSD_6_1_BASE:1.657
	OPENBSD_6_0:1.654.0.2
	OPENBSD_6_0_BASE:1.654
	OPENBSD_5_9:1.649.0.2
	OPENBSD_5_9_BASE:1.649
	OPENBSD_5_8:1.648.0.4
	OPENBSD_5_8_BASE:1.648
	OPENBSD_5_7:1.647.0.2
	OPENBSD_5_7_BASE:1.647
	OPENBSD_5_6:1.636.0.4
	OPENBSD_5_6_BASE:1.636
	OPENBSD_5_5:1.631.0.4
	OPENBSD_5_5_BASE:1.631
	OPENBSD_5_4:1.623.0.2
	OPENBSD_5_4_BASE:1.623
	OPENBSD_5_3:1.621.0.2
	OPENBSD_5_3_BASE:1.621
	OPENBSD_5_2:1.618.0.2
	OPENBSD_5_2_BASE:1.618
	OPENBSD_5_1_BASE:1.613
	OPENBSD_5_1:1.613.0.2
	OPENBSD_5_0:1.607.0.2
	OPENBSD_5_0_BASE:1.607
	OPENBSD_4_9:1.597.0.2
	OPENBSD_4_9_BASE:1.597
	OPENBSD_4_8:1.591.0.2
	OPENBSD_4_8_BASE:1.591
	OPENBSD_4_7:1.588.0.2
	OPENBSD_4_7_BASE:1.588
	OPENBSD_4_6:1.559.0.4
	OPENBSD_4_6_BASE:1.559
	OPENBSD_4_5:1.555.0.2
	OPENBSD_4_5_BASE:1.555
	OPENBSD_4_4:1.549.0.2
	OPENBSD_4_4_BASE:1.549
	OPENBSD_4_3:1.536.0.2
	OPENBSD_4_3_BASE:1.536
	OPENBSD_4_2:1.519.0.2
	OPENBSD_4_2_BASE:1.519
	OPENBSD_4_1:1.517.0.2
	OPENBSD_4_1_BASE:1.517
	OPENBSD_4_0:1.503.0.2
	OPENBSD_4_0_BASE:1.503
	OPENBSD_3_9:1.494.0.2
	OPENBSD_3_9_BASE:1.494
	OPENBSD_3_8:1.492.0.2
	OPENBSD_3_8_BASE:1.492
	OPENBSD_3_7:1.482.0.2
	OPENBSD_3_7_BASE:1.482
	OPENBSD_3_6:1.459.0.2
	OPENBSD_3_6_BASE:1.459
	OPENBSD_3_5:1.449.0.2
	OPENBSD_3_5_BASE:1.449
	OPENBSD_3_4:1.415.0.2
	OPENBSD_3_4_BASE:1.415
	OPENBSD_3_3:1.343.0.2
	OPENBSD_3_3_BASE:1.343
	OPENBSD_3_2:1.154.0.2
	OPENBSD_3_2_BASE:1.154
	OPENBSD_3_1:1.57.0.2
	OPENBSD_3_1_BASE:1.57
	OPENBSD_3_0:1.41.0.2
	OPENBSD_3_0_BASE:1.41;
locks; strict;
comment	@ * @;


1.663
date	2017.08.11.22.30.38;	author benno;	state Exp;
branches;
next	1.662;
commitid	y1VyeV9JnotblbHq;

1.662
date	2017.07.19.12.58.31;	author mikeb;	state Exp;
branches;
next	1.661;
commitid	iahjnsaS3YMAv0Za;

1.661
date	2017.07.19.12.51.30;	author mikeb;	state Exp;
branches;
next	1.660;
commitid	acqfpkzv6C7Xn3G8;

1.660
date	2017.05.28.15.15.21;	author akfaew;	state Exp;
branches;
next	1.659;
commitid	iHMv5gf7EK1OZOu2;

1.659
date	2017.05.15.11.23.25;	author mikeb;	state Exp;
branches;
next	1.658;
commitid	MV7SeE82QLGXQJBO;

1.658
date	2017.04.28.14.15.45;	author mikeb;	state Exp;
branches;
next	1.657;
commitid	oX78NyYWUpneTW69;

1.657
date	2017.01.05.12.42.18;	author krw;	state Exp;
branches;
next	1.656;
commitid	uzjOUwLRoN7KbcZI;

1.656
date	2016.11.23.12.13.23;	author bluhm;	state Exp;
branches;
next	1.655;
commitid	Pp3tKF2NLsiC2o7E;

1.655
date	2016.08.26.06.06.58;	author guenther;	state Exp;
branches;
next	1.654;
commitid	uyVadfZnVhGMOzn7;

1.654
date	2016.07.18.15.21.33;	author henning;	state Exp;
branches;
next	1.653;
commitid	5KleJssC0VUcsOjy;

1.653
date	2016.06.22.10.13.14;	author kettenis;	state Exp;
branches;
next	1.652;
commitid	4JmzAVi7iBCZiwzx;

1.652
date	2016.06.21.21.35.24;	author benno;	state Exp;
branches;
next	1.651;
commitid	AL6SnrmnHkmPOpjv;

1.651
date	2016.06.21.13.40.43;	author benno;	state Exp;
branches;
next	1.650;
commitid	LeVD4zDRnP2JzMV0;

1.650
date	2016.06.16.15.46.20;	author henning;	state Exp;
branches;
next	1.649;
commitid	54GdXr5msOmLOXKb;

1.649
date	2015.09.01.19.12.25;	author sashan;	state Exp;
branches;
next	1.648;
commitid	t9mePMusNtbKWnxJ;

1.648
date	2015.04.21.16.34.59;	author mikeb;	state Exp;
branches;
next	1.647;
commitid	MQW0mV7cZ9sfClJi;

1.647
date	2015.02.26.18.27.45;	author sthen;	state Exp;
branches;
next	1.646;
commitid	Sq50ov1m4iNjQZbs;

1.646
date	2015.02.14.23.32.41;	author sthen;	state Exp;
branches;
next	1.645;
commitid	yqzib6o76qMH9qZC;

1.645
date	2015.02.10.06.45.55;	author henning;	state Exp;
branches;
next	1.644;
commitid	eD7tXFa7upGCZ3zN;

1.644
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.643;
commitid	Uu5nFG3wCl0LACBb;

1.643
date	2014.12.19.13.04.07;	author reyk;	state Exp;
branches;
next	1.642;
commitid	ctnssYdFDfym7i2Z;

1.642
date	2014.11.20.05.51.20;	author jsg;	state Exp;
branches;
next	1.641;
commitid	3Z7yItGpFsmshk0c;

1.641
date	2014.10.27.21.51.32;	author mikeb;	state Exp;
branches;
next	1.640;
commitid	a2mU7I61ROTRhch2;

1.640
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.639;
commitid	RKMpGS78lskgSHj4;

1.639
date	2014.09.13.16.06.36;	author doug;	state Exp;
branches;
next	1.638;
commitid	jdBY2kKXhfcoQitp;

1.638
date	2014.08.23.00.11.03;	author pelikan;	state Exp;
branches;
next	1.637;
commitid	YY1Dd1zH9rSATCPx;

1.637
date	2014.08.21.15.09.27;	author mikeb;	state Exp;
branches;
next	1.636;
commitid	T3DyfycwIxguTnZL;

1.636
date	2014.07.02.13.03.41;	author mikeb;	state Exp;
branches
	1.636.4.1;
next	1.635;
commitid	piADshpPT4FI5cLa;

1.635
date	2014.06.30.13.17.17;	author mikeb;	state Exp;
branches;
next	1.634;
commitid	LhjlE8qOD2BkCjtw;

1.634
date	2014.06.25.15.11.20;	author mikeb;	state Exp;
branches;
next	1.633;
commitid	hxjejaYSTgBbKN2c;

1.633
date	2014.05.17.08.12.53;	author bluhm;	state Exp;
branches;
next	1.632;

1.632
date	2014.04.19.14.22.32;	author henning;	state Exp;
branches;
next	1.631;

1.631
date	2014.01.22.00.21.16;	author henning;	state Exp;
branches
	1.631.4.1;
next	1.630;

1.630
date	2014.01.21.01.51.55;	author henning;	state Exp;
branches;
next	1.629;

1.629
date	2014.01.20.02.59.13;	author henning;	state Exp;
branches;
next	1.628;

1.628
date	2013.11.25.12.52.45;	author benno;	state Exp;
branches;
next	1.627;

1.627
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.626;

1.626
date	2013.10.17.19.59.54;	author henning;	state Exp;
branches;
next	1.625;

1.625
date	2013.10.12.12.16.11;	author henning;	state Exp;
branches;
next	1.624;

1.624
date	2013.08.01.19.03.11;	author mikeb;	state Exp;
branches;
next	1.623;

1.623
date	2013.06.01.21.51.54;	author henning;	state Exp;
branches
	1.623.2.1;
next	1.622;

1.622
date	2013.03.02.12.28.13;	author sthen;	state Exp;
branches;
next	1.621;

1.621
date	2013.01.16.01.49.20;	author henning;	state Exp;
branches;
next	1.620;

1.620
date	2012.10.18.15.18.57;	author reyk;	state Exp;
branches;
next	1.619;

1.619
date	2012.09.18.10.11.52;	author henning;	state Exp;
branches;
next	1.618;

1.618
date	2012.07.10.09.29.36;	author bluhm;	state Exp;
branches;
next	1.617;

1.617
date	2012.07.10.09.13.41;	author henning;	state Exp;
branches;
next	1.616;

1.616
date	2012.07.09.14.05.35;	author henning;	state Exp;
branches;
next	1.615;

1.615
date	2012.07.07.18.39.21;	author henning;	state Exp;
branches;
next	1.614;

1.614
date	2012.07.07.16.24.32;	author henning;	state Exp;
branches;
next	1.613;

1.613
date	2011.12.19.23.26.16;	author mikeb;	state Exp;
branches;
next	1.612;

1.612
date	2011.12.12.21.30.27;	author mikeb;	state Exp;
branches;
next	1.611;

1.611
date	2011.12.03.12.46.16;	author mcbride;	state Exp;
branches;
next	1.610;

1.610
date	2011.10.13.18.30.54;	author claudio;	state Exp;
branches;
next	1.609;

1.609
date	2011.09.07.23.40.52;	author haesbaert;	state Exp;
branches;
next	1.608;

1.608
date	2011.08.30.00.43.57;	author mikeb;	state Exp;
branches;
next	1.607;

1.607
date	2011.07.29.10.51.46;	author mcbride;	state Exp;
branches;
next	1.606;

1.606
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.605;

1.605
date	2011.07.13.20.57.10;	author mcbride;	state Exp;
branches;
next	1.604;

1.604
date	2011.07.08.18.52.47;	author henning;	state Exp;
branches;
next	1.603;

1.603
date	2011.07.07.00.47.19;	author mcbride;	state Exp;
branches;
next	1.602;

1.602
date	2011.07.04.03.36.14;	author henning;	state Exp;
branches;
next	1.601;

1.601
date	2011.07.03.23.59.43;	author henning;	state Exp;
branches;
next	1.600;

1.600
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.599;

1.599
date	2011.04.06.13.19.55;	author claudio;	state Exp;
branches;
next	1.598;

1.598
date	2011.04.05.13.48.18;	author mikeb;	state Exp;
branches;
next	1.597;

1.597
date	2010.12.31.12.15.31;	author bluhm;	state Exp;
branches;
next	1.596;

1.596
date	2010.12.15.13.54.50;	author henning;	state Exp;
branches;
next	1.595;

1.595
date	2010.12.01.10.35.18;	author jsg;	state Exp;
branches;
next	1.594;

1.594
date	2010.09.24.09.17.46;	author henning;	state Exp;
branches;
next	1.593;

1.593
date	2010.09.22.06.02.59;	author henning;	state Exp;
branches;
next	1.592;

1.592
date	2010.09.02.14.01.04;	author sobrado;	state Exp;
branches;
next	1.591;

1.591
date	2010.08.03.18.42.40;	author henning;	state Exp;
branches;
next	1.590;

1.590
date	2010.07.03.02.28.57;	author mcbride;	state Exp;
branches;
next	1.589;

1.589
date	2010.03.23.13.31.29;	author henning;	state Exp;
branches;
next	1.588;

1.588
date	2010.01.13.05.20.10;	author deraadt;	state Exp;
branches;
next	1.587;

1.587
date	2010.01.13.00.56.13;	author mcbride;	state Exp;
branches;
next	1.586;

1.586
date	2010.01.12.19.18.55;	author mcbride;	state Exp;
branches;
next	1.585;

1.585
date	2010.01.12.16.22.49;	author mcbride;	state Exp;
branches;
next	1.584;

1.584
date	2010.01.12.15.52.07;	author mcbride;	state Exp;
branches;
next	1.583;

1.583
date	2010.01.12.14.44.26;	author mcbride;	state Exp;
branches;
next	1.582;

1.582
date	2010.01.12.03.33.28;	author mcbride;	state Exp;
branches;
next	1.581;

1.581
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.580;

1.580
date	2010.01.10.23.48.22;	author deraadt;	state Exp;
branches;
next	1.579;

1.579
date	2010.01.10.07.45.41;	author deraadt;	state Exp;
branches;
next	1.578;

1.578
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.577;

1.577
date	2009.12.24.04.24.19;	author dlg;	state Exp;
branches;
next	1.576;

1.576
date	2009.12.10.15.57.20;	author deraadt;	state Exp;
branches;
next	1.575;

1.575
date	2009.11.22.22.34.50;	author henning;	state Exp;
branches;
next	1.574;

1.574
date	2009.11.09.14.31.58;	author jsg;	state Exp;
branches;
next	1.573;

1.573
date	2009.10.28.20.11.01;	author jsg;	state Exp;
branches;
next	1.572;

1.572
date	2009.10.28.12.53.11;	author claudio;	state Exp;
branches;
next	1.571;

1.571
date	2009.10.28.12.41.16;	author claudio;	state Exp;
branches;
next	1.570;

1.570
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.569;

1.569
date	2009.09.08.17.52.17;	author michele;	state Exp;
branches;
next	1.568;

1.568
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.567;

1.567
date	2009.09.07.12.21.09;	author reyk;	state Exp;
branches;
next	1.566;

1.566
date	2009.09.03.12.16.21;	author reyk;	state Exp;
branches;
next	1.565;

1.565
date	2009.09.03.12.12.37;	author reyk;	state Exp;
branches;
next	1.564;

1.564
date	2009.09.02.13.28.03;	author reyk;	state Exp;
branches;
next	1.563;

1.563
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.562;

1.562
date	2009.07.28.13.26.52;	author claudio;	state Exp;
branches;
next	1.561;

1.561
date	2009.07.27.19.00.28;	author deraadt;	state Exp;
branches;
next	1.560;

1.560
date	2009.07.27.12.56.48;	author claudio;	state Exp;
branches;
next	1.559;

1.559
date	2009.05.14.22.56.11;	author sthen;	state Exp;
branches;
next	1.558;

1.558
date	2009.04.26.12.30.20;	author sthen;	state Exp;
branches;
next	1.557;

1.557
date	2009.04.25.19.29.54;	author henning;	state Exp;
branches;
next	1.556;

1.556
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.555;

1.555
date	2009.02.19.17.08.42;	author deraadt;	state Exp;
branches;
next	1.554;

1.554
date	2008.10.17.12.59.53;	author henning;	state Exp;
branches;
next	1.553;

1.553
date	2008.10.02.12.31.18;	author henning;	state Exp;
branches;
next	1.552;

1.552
date	2008.09.10.00.32.03;	author deraadt;	state Exp;
branches;
next	1.551;

1.551
date	2008.09.09.13.56.38;	author henning;	state Exp;
branches;
next	1.550;

1.550
date	2008.08.07.18.29.32;	author henning;	state Exp;
branches;
next	1.549;

1.549
date	2008.07.03.16.09.34;	author deraadt;	state Exp;
branches;
next	1.548;

1.548
date	2008.06.10.20.55.02;	author mcbride;	state Exp;
branches;
next	1.547;

1.547
date	2008.06.10.04.28.54;	author henning;	state Exp;
branches;
next	1.546;

1.546
date	2008.05.09.08.16.07;	author deraadt;	state Exp;
branches;
next	1.545;

1.545
date	2008.05.09.05.41.01;	author markus;	state Exp;
branches;
next	1.544;

1.544
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.543;

1.543
date	2008.05.08.08.08.36;	author deraadt;	state Exp;
branches;
next	1.542;

1.542
date	2008.05.08.07.29.30;	author deraadt;	state Exp;
branches;
next	1.541;

1.541
date	2008.05.08.00.17.26;	author deraadt;	state Exp;
branches;
next	1.540;

1.540
date	2008.05.07.08.08.39;	author deraadt;	state Exp;
branches;
next	1.539;

1.539
date	2008.05.07.07.07.29;	author markus;	state Exp;
branches;
next	1.538;

1.538
date	2008.05.07.06.23.30;	author markus;	state Exp;
branches;
next	1.537;

1.537
date	2008.04.21.01.42.19;	author deraadt;	state Exp;
branches;
next	1.536;

1.536
date	2008.02.01.06.58.45;	author mcbride;	state Exp;
branches;
next	1.535;

1.535
date	2007.11.13.00.47.56;	author mpf;	state Exp;
branches;
next	1.534;

1.534
date	2007.11.12.23.59.41;	author mpf;	state Exp;
branches;
next	1.533;

1.533
date	2007.10.25.21.36.21;	author mpf;	state Exp;
branches;
next	1.532;

1.532
date	2007.10.22.16.35.33;	author pyr;	state Exp;
branches;
next	1.531;

1.531
date	2007.10.22.00.40.46;	author deraadt;	state Exp;
branches;
next	1.530;

1.530
date	2007.10.16.19.20.27;	author mpf;	state Exp;
branches;
next	1.529;

1.529
date	2007.10.16.06.06.49;	author deraadt;	state Exp;
branches;
next	1.528;

1.528
date	2007.10.13.21.49.13;	author deraadt;	state Exp;
branches;
next	1.527;

1.527
date	2007.10.13.16.35.18;	author deraadt;	state Exp;
branches;
next	1.526;

1.526
date	2007.10.11.14.39.16;	author deraadt;	state Exp;
branches;
next	1.525;

1.525
date	2007.10.01.12.37.40;	author mpf;	state Exp;
branches;
next	1.524;

1.524
date	2007.09.27.22.24.05;	author mpf;	state Exp;
branches;
next	1.523;

1.523
date	2007.09.23.20.59.59;	author mpf;	state Exp;
branches;
next	1.522;

1.522
date	2007.09.12.18.49.03;	author deraadt;	state Exp;
branches;
next	1.521;

1.521
date	2007.09.12.15.58.40;	author deraadt;	state Exp;
branches;
next	1.520;

1.520
date	2007.08.30.09.28.49;	author dhartmei;	state Exp;
branches;
next	1.519;

1.519
date	2007.06.21.19.30.03;	author henning;	state Exp;
branches;
next	1.518;

1.518
date	2007.06.20.14.14.17;	author mpf;	state Exp;
branches;
next	1.517;

1.517
date	2007.02.03.23.26.40;	author dhartmei;	state Exp;
branches;
next	1.516;

1.516
date	2006.11.07.01.12.01;	author mcbride;	state Exp;
branches;
next	1.515;

1.515
date	2006.10.31.14.17.44;	author mcbride;	state Exp;
branches;
next	1.514;

1.514
date	2006.10.31.07.02.35;	author mcbride;	state Exp;
branches;
next	1.513;

1.513
date	2006.10.28.14.29.05;	author mcbride;	state Exp;
branches;
next	1.512;

1.512
date	2006.10.25.14.50.30;	author henning;	state Exp;
branches;
next	1.511;

1.511
date	2006.10.25.11.53.46;	author henning;	state Exp;
branches;
next	1.510;

1.510
date	2006.10.25.11.45.48;	author henning;	state Exp;
branches;
next	1.509;

1.509
date	2006.10.25.11.28.36;	author henning;	state Exp;
branches;
next	1.508;

1.508
date	2006.10.17.07.14.28;	author mcbride;	state Exp;
branches;
next	1.507;

1.507
date	2006.10.11.21.04.18;	author deraadt;	state Exp;
branches;
next	1.506;

1.506
date	2006.10.11.08.42.31;	author mcbride;	state Exp;
branches;
next	1.505;

1.505
date	2006.10.06.11.05.30;	author mcbride;	state Exp;
branches;
next	1.504;

1.504
date	2006.10.06.10.45.44;	author mcbride;	state Exp;
branches;
next	1.503;

1.503
date	2006.08.22.15.55.13;	author dhartmei;	state Exp;
branches;
next	1.502;

1.502
date	2006.07.06.13.26.41;	author henning;	state Exp;
branches;
next	1.501;

1.501
date	2006.06.17.11.38.41;	author henning;	state Exp;
branches;
next	1.500;

1.500
date	2006.05.28.03.05.53;	author mcbride;	state Exp;
branches;
next	1.499;

1.499
date	2006.05.26.01.06.12;	author deraadt;	state Exp;
branches;
next	1.498;

1.498
date	2006.05.02.10.08.45;	author dhartmei;	state Exp;
branches;
next	1.497;

1.497
date	2006.05.01.12.24.32;	author dhartmei;	state Exp;
branches;
next	1.496;

1.496
date	2006.04.06.21.54.56;	author henning;	state Exp;
branches;
next	1.495;

1.495
date	2006.03.14.11.09.43;	author djm;	state Exp;
branches;
next	1.494;

1.494
date	2005.11.17.20.52.39;	author dhartmei;	state Exp;
branches;
next	1.493;

1.493
date	2005.10.13.13.27.06;	author henning;	state Exp;
branches;
next	1.492;

1.492
date	2005.06.14.18.15.49;	author henning;	state Exp;
branches;
next	1.491;

1.491
date	2005.05.27.18.52.41;	author dhartmei;	state Exp;
branches;
next	1.490;

1.490
date	2005.05.27.18.41.29;	author dhartmei;	state Exp;
branches;
next	1.489;

1.489
date	2005.05.27.17.22.40;	author dhartmei;	state Exp;
branches;
next	1.488;

1.488
date	2005.05.27.03.54.27;	author dhartmei;	state Exp;
branches;
next	1.487;

1.487
date	2005.05.26.20.20.38;	author camield;	state Exp;
branches;
next	1.486;

1.486
date	2005.05.26.15.29.48;	author dhartmei;	state Exp;
branches;
next	1.485;

1.485
date	2005.05.23.21.29.50;	author camield;	state Exp;
branches;
next	1.484;

1.484
date	2005.05.21.21.03.58;	author henning;	state Exp;
branches;
next	1.483;

1.483
date	2005.04.22.11.05.36;	author camield;	state Exp;
branches;
next	1.482;

1.482
date	2005.03.07.13.20.03;	author henning;	state Exp;
branches;
next	1.481;

1.481
date	2005.03.06.19.11.36;	author henning;	state Exp;
branches;
next	1.480;

1.480
date	2005.03.06.02.40.08;	author dhartmei;	state Exp;
branches;
next	1.479;

1.479
date	2005.02.27.15.08.39;	author dhartmei;	state Exp;
branches;
next	1.478;

1.478
date	2005.02.26.15.14.58;	author henning;	state Exp;
branches;
next	1.477;

1.477
date	2005.02.07.18.18.14;	author david;	state Exp;
branches;
next	1.476;

1.476
date	2005.01.28.17.29.31;	author dhartmei;	state Exp;
branches;
next	1.475;

1.475
date	2005.01.27.15.30.35;	author dhartmei;	state Exp;
branches;
next	1.474;

1.474
date	2005.01.05.18.23.10;	author mcbride;	state Exp;
branches;
next	1.473;

1.473
date	2004.12.29.16.27.05;	author mcbride;	state Exp;
branches;
next	1.472;

1.472
date	2004.12.23.17.21.48;	author dhartmei;	state Exp;
branches;
next	1.471;

1.471
date	2004.12.22.17.17.55;	author dhartmei;	state Exp;
branches;
next	1.470;

1.470
date	2004.12.15.16.11.14;	author henning;	state Exp;
branches;
next	1.469;

1.469
date	2004.12.10.22.13.26;	author henning;	state Exp;
branches;
next	1.468;

1.468
date	2004.12.08.01.27.23;	author mcbride;	state Exp;
branches;
next	1.467;

1.467
date	2004.12.07.10.33.41;	author dhartmei;	state Exp;
branches;
next	1.466;

1.466
date	2004.12.07.09.39.30;	author deraadt;	state Exp;
branches;
next	1.465;

1.465
date	2004.12.07.09.38.04;	author deraadt;	state Exp;
branches;
next	1.464;

1.464
date	2004.12.07.09.36.16;	author deraadt;	state Exp;
branches;
next	1.463;

1.463
date	2004.12.07.05.30.26;	author mcbride;	state Exp;
branches;
next	1.462;

1.462
date	2004.12.05.10.11.29;	author dhartmei;	state Exp;
branches;
next	1.461;

1.461
date	2004.12.04.07.58.51;	author mcbride;	state Exp;
branches;
next	1.460;

1.460
date	2004.09.21.16.59.11;	author aaron;	state Exp;
branches;
next	1.459;

1.459
date	2004.06.29.22.14.13;	author henning;	state Exp;
branches;
next	1.458;

1.458
date	2004.06.29.17.40.18;	author frantzen;	state Exp;
branches;
next	1.457;

1.457
date	2004.06.26.07.25.16;	author david;	state Exp;
branches;
next	1.456;

1.456
date	2004.06.25.05.45.48;	author deraadt;	state Exp;
branches;
next	1.455;

1.455
date	2004.06.10.14.22.54;	author dhartmei;	state Exp;
branches;
next	1.454;

1.454
date	2004.05.21.23.10.48;	author dhartmei;	state Exp;
branches;
next	1.453;

1.453
date	2004.05.19.17.50.50;	author dhartmei;	state Exp;
branches;
next	1.452;

1.452
date	2004.04.24.23.22.54;	author cedric;	state Exp;
branches;
next	1.451;

1.451
date	2004.04.22.08.34.30;	author henning;	state Exp;
branches;
next	1.450;

1.450
date	2004.04.14.11.16.42;	author cedric;	state Exp;
branches;
next	1.449;

1.449
date	2004.03.20.23.20.20;	author david;	state Exp;
branches;
next	1.448;

1.448
date	2004.03.14.21.51.44;	author dhartmei;	state Exp;
branches;
next	1.447;

1.447
date	2004.03.08.16.10.02;	author henning;	state Exp;
branches;
next	1.446;

1.446
date	2004.03.06.21.49.25;	author henning;	state Exp;
branches;
next	1.445;

1.445
date	2004.03.01.17.40.54;	author dhartmei;	state Exp;
branches;
next	1.444;

1.444
date	2004.02.24.20.35.18;	author mcbride;	state Exp;
branches;
next	1.443;

1.443
date	2004.02.24.14.28.45;	author cedric;	state Exp;
branches;
next	1.442;

1.442
date	2004.02.24.11.16.26;	author mcbride;	state Exp;
branches;
next	1.441;

1.441
date	2004.02.11.18.34.51;	author cedric;	state Exp;
branches;
next	1.440;

1.440
date	2004.02.10.21.06.04;	author henning;	state Exp;
branches;
next	1.439;

1.439
date	2004.02.10.17.48.08;	author henning;	state Exp;
branches;
next	1.438;

1.438
date	2004.02.04.17.35.40;	author mcbride;	state Exp;
branches;
next	1.437;

1.437
date	2004.02.03.19.29.50;	author henning;	state Exp;
branches;
next	1.436;

1.436
date	2004.01.05.22.04.24;	author henning;	state Exp;
branches;
next	1.435;

1.435
date	2004.01.04.12.30.29;	author cedric;	state Exp;
branches;
next	1.434;

1.434
date	2003.12.31.22.14.41;	author deraadt;	state Exp;
branches;
next	1.433;

1.433
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.432;

1.432
date	2003.12.30.16.59.38;	author henning;	state Exp;
branches;
next	1.431;

1.431
date	2003.12.19.16.12.43;	author henning;	state Exp;
branches;
next	1.430;

1.430
date	2003.12.19.01.11.14;	author deraadt;	state Exp;
branches;
next	1.429;

1.429
date	2003.12.16.01.10.21;	author mcbride;	state Exp;
branches;
next	1.428;

1.428
date	2003.12.15.09.12.55;	author henning;	state Exp;
branches;
next	1.427;

1.427
date	2003.12.15.07.30.17;	author mcbride;	state Exp;
branches;
next	1.426;

1.426
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.425;

1.425
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.424;

1.424
date	2003.11.29.10.05.55;	author dhartmei;	state Exp;
branches;
next	1.423;

1.423
date	2003.11.22.13.44.20;	author henning;	state Exp;
branches;
next	1.422;

1.422
date	2003.11.14.13.51.09;	author henning;	state Exp;
branches;
next	1.421;

1.421
date	2003.11.08.00.45.34;	author mcbride;	state Exp;
branches;
next	1.420;

1.420
date	2003.11.06.15.16.50;	author henning;	state Exp;
branches;
next	1.419;

1.419
date	2003.11.06.15.13.22;	author henning;	state Exp;
branches;
next	1.418;

1.418
date	2003.11.06.14.02.19;	author henning;	state Exp;
branches;
next	1.417;

1.417
date	2003.10.21.21.09.12;	author itojun;	state Exp;
branches;
next	1.416;

1.416
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.415;

1.415
date	2003.09.01.15.07.40;	author henning;	state Exp;
branches;
next	1.414;

1.414
date	2003.08.28.19.27.32;	author kjell;	state Exp;
branches;
next	1.413;

1.413
date	2003.08.26.18.43.04;	author dhartmei;	state Exp;
branches;
next	1.412;

1.412
date	2003.08.25.17.44.44;	author dhartmei;	state Exp;
branches;
next	1.411;

1.411
date	2003.08.24.13.02.28;	author cedric;	state Exp;
branches;
next	1.410;

1.410
date	2003.08.22.21.50.34;	author david;	state Exp;
branches;
next	1.409;

1.409
date	2003.08.21.19.12.08;	author frantzen;	state Exp;
branches;
next	1.408;

1.408
date	2003.08.20.16.27.36;	author henning;	state Exp;
branches;
next	1.407;

1.407
date	2003.08.20.13.02.52;	author henning;	state Exp;
branches;
next	1.406;

1.406
date	2003.08.18.11.08.10;	author dhartmei;	state Exp;
branches;
next	1.405;

1.405
date	2003.08.09.14.56.48;	author cedric;	state Exp;
branches;
next	1.404;

1.404
date	2003.07.29.18.47.43;	author deraadt;	state Exp;
branches;
next	1.403;

1.403
date	2003.07.19.13.08.58;	author cedric;	state Exp;
branches;
next	1.402;

1.402
date	2003.07.18.06.30.06;	author cedric;	state Exp;
branches;
next	1.401;

1.401
date	2003.07.15.17.12.38;	author cedric;	state Exp;
branches;
next	1.400;

1.400
date	2003.07.14.20.01.07;	author dhartmei;	state Exp;
branches;
next	1.399;

1.399
date	2003.07.11.08.29.34;	author cedric;	state Exp;
branches;
next	1.398;

1.398
date	2003.07.10.05.25.27;	author cedric;	state Exp;
branches;
next	1.397;

1.397
date	2003.07.04.11.05.44;	author henning;	state Exp;
branches;
next	1.396;

1.396
date	2003.07.04.10.42.16;	author henning;	state Exp;
branches;
next	1.395;

1.395
date	2003.07.03.21.09.13;	author cedric;	state Exp;
branches;
next	1.394;

1.394
date	2003.07.03.09.13.05;	author cedric;	state Exp;
branches;
next	1.393;

1.393
date	2003.06.19.22.08.35;	author deraadt;	state Exp;
branches;
next	1.392;

1.392
date	2003.06.18.11.38.19;	author henning;	state Exp;
branches;
next	1.391;

1.391
date	2003.06.18.11.04.14;	author henning;	state Exp;
branches;
next	1.390;

1.390
date	2003.06.09.11.14.46;	author mcbride;	state Exp;
branches;
next	1.389;

1.389
date	2003.05.25.17.07.28;	author henning;	state Exp;
branches;
next	1.388;

1.388
date	2003.05.19.20.21.53;	author henning;	state Exp;
branches;
next	1.387;

1.387
date	2003.05.19.18.31.13;	author henning;	state Exp;
branches;
next	1.386;

1.386
date	2003.05.19.18.18.34;	author henning;	state Exp;
branches;
next	1.385;

1.385
date	2003.05.17.02.04.24;	author henning;	state Exp;
branches;
next	1.384;

1.384
date	2003.05.16.17.15.17;	author dhartmei;	state Exp;
branches;
next	1.383;

1.383
date	2003.05.15.06.22.46;	author henning;	state Exp;
branches;
next	1.382;

1.382
date	2003.05.14.23.51.28;	author frantzen;	state Exp;
branches;
next	1.381;

1.381
date	2003.05.14.22.54.39;	author henning;	state Exp;
branches;
next	1.380;

1.380
date	2003.05.14.22.46.01;	author henning;	state Exp;
branches;
next	1.379;

1.379
date	2003.05.14.05.14.06;	author henning;	state Exp;
branches;
next	1.378;

1.378
date	2003.05.14.05.02.12;	author frantzen;	state Exp;
branches;
next	1.377;

1.377
date	2003.05.14.04.53.04;	author henning;	state Exp;
branches;
next	1.376;

1.376
date	2003.05.13.23.02.15;	author henning;	state Exp;
branches;
next	1.375;

1.375
date	2003.05.13.21.15.07;	author henning;	state Exp;
branches;
next	1.374;

1.374
date	2003.05.11.01.48.50;	author mcbride;	state Exp;
branches;
next	1.373;

1.373
date	2003.05.10.00.45.23;	author henning;	state Exp;
branches;
next	1.372;

1.372
date	2003.05.03.16.50.38;	author henning;	state Exp;
branches;
next	1.371;

1.371
date	2003.05.01.16.22.12;	author henning;	state Exp;
branches;
next	1.370;

1.370
date	2003.05.01.16.16.08;	author henning;	state Exp;
branches;
next	1.369;

1.369
date	2003.04.30.12.30.27;	author cedric;	state Exp;
branches;
next	1.368;

1.368
date	2003.04.25.17.36.33;	author dhartmei;	state Exp;
branches;
next	1.367;

1.367
date	2003.04.15.11.29.24;	author henning;	state Exp;
branches;
next	1.366;

1.366
date	2003.04.14.14.50.46;	author henning;	state Exp;
branches;
next	1.365;

1.365
date	2003.04.13.23.51.51;	author henning;	state Exp;
branches;
next	1.364;

1.364
date	2003.04.13.23.39.18;	author henning;	state Exp;
branches;
next	1.363;

1.363
date	2003.04.13.23.34.31;	author henning;	state Exp;
branches;
next	1.362;

1.362
date	2003.04.13.22.45.28;	author dhartmei;	state Exp;
branches;
next	1.361;

1.361
date	2003.04.13.21.51.10;	author henning;	state Exp;
branches;
next	1.360;

1.360
date	2003.04.13.20.41.37;	author henning;	state Exp;
branches;
next	1.359;

1.359
date	2003.04.13.20.16.06;	author henning;	state Exp;
branches;
next	1.358;

1.358
date	2003.04.13.19.36.00;	author henning;	state Exp;
branches;
next	1.357;

1.357
date	2003.04.13.17.01.12;	author henning;	state Exp;
branches;
next	1.356;

1.356
date	2003.04.12.20.10.32;	author henning;	state Exp;
branches;
next	1.355;

1.355
date	2003.04.11.15.19.10;	author henning;	state Exp;
branches;
next	1.354;

1.354
date	2003.04.11.14.42.32;	author henning;	state Exp;
branches;
next	1.353;

1.353
date	2003.04.07.13.40.48;	author dhartmei;	state Exp;
branches;
next	1.352;

1.352
date	2003.04.05.23.56.32;	author henning;	state Exp;
branches;
next	1.351;

1.351
date	2003.04.05.21.44.45;	author henning;	state Exp;
branches;
next	1.350;

1.350
date	2003.04.05.21.04.53;	author henning;	state Exp;
branches;
next	1.349;

1.349
date	2003.04.04.18.48.11;	author henning;	state Exp;
branches;
next	1.348;

1.348
date	2003.03.27.18.01.57;	author henning;	state Exp;
branches;
next	1.347;

1.347
date	2003.03.27.16.17.37;	author henning;	state Exp;
branches;
next	1.346;

1.346
date	2003.03.27.16.11.55;	author henning;	state Exp;
branches;
next	1.345;

1.345
date	2003.03.27.15.58.11;	author henning;	state Exp;
branches;
next	1.344;

1.344
date	2003.03.27.15.49.47;	author henning;	state Exp;
branches;
next	1.343;

1.343
date	2003.03.19.15.51.40;	author henning;	state Exp;
branches
	1.343.2.1;
next	1.342;

1.342
date	2003.03.10.14.50.29;	author henning;	state Exp;
branches;
next	1.341;

1.341
date	2003.03.10.14.46.09;	author henning;	state Exp;
branches;
next	1.340;

1.340
date	2003.03.09.19.07.21;	author henning;	state Exp;
branches;
next	1.339;

1.339
date	2003.03.09.18.58.25;	author henning;	state Exp;
branches;
next	1.338;

1.338
date	2003.03.08.15.17.34;	author henning;	state Exp;
branches;
next	1.337;

1.337
date	2003.03.08.14.52.17;	author henning;	state Exp;
branches;
next	1.336;

1.336
date	2003.03.06.12.50.40;	author henning;	state Exp;
branches;
next	1.335;

1.335
date	2003.03.02.23.37.24;	author henning;	state Exp;
branches;
next	1.334;

1.334
date	2003.03.02.12.37.49;	author henning;	state Exp;
branches;
next	1.333;

1.333
date	2003.02.27.04.16.28;	author david;	state Exp;
branches;
next	1.332;

1.332
date	2003.02.26.20.27.20;	author henning;	state Exp;
branches;
next	1.331;

1.331
date	2003.02.25.20.59.09;	author henning;	state Exp;
branches;
next	1.330;

1.330
date	2003.02.25.12.22.25;	author cedric;	state Exp;
branches;
next	1.329;

1.329
date	2003.02.24.21.55.51;	author henning;	state Exp;
branches;
next	1.328;

1.328
date	2003.02.21.10.54.57;	author henning;	state Exp;
branches;
next	1.327;

1.327
date	2003.02.21.10.34.52;	author henning;	state Exp;
branches;
next	1.326;

1.326
date	2003.02.20.00.18.19;	author henning;	state Exp;
branches;
next	1.325;

1.325
date	2003.02.19.22.00.20;	author dhartmei;	state Exp;
branches;
next	1.324;

1.324
date	2003.02.19.21.54.46;	author henning;	state Exp;
branches;
next	1.323;

1.323
date	2003.02.18.21.59.34;	author henning;	state Exp;
branches;
next	1.322;

1.322
date	2003.02.17.14.36.46;	author henning;	state Exp;
branches;
next	1.321;

1.321
date	2003.02.17.06.56.04;	author mpech;	state Exp;
branches;
next	1.320;

1.320
date	2003.02.16.15.19.42;	author henning;	state Exp;
branches;
next	1.319;

1.319
date	2003.02.16.15.11.09;	author henning;	state Exp;
branches;
next	1.318;

1.318
date	2003.02.14.14.38.32;	author dhartmei;	state Exp;
branches;
next	1.317;

1.317
date	2003.02.14.13.23.17;	author cedric;	state Exp;
branches;
next	1.316;

1.316
date	2003.02.13.10.26.21;	author henning;	state Exp;
branches;
next	1.315;

1.315
date	2003.02.12.13.03.54;	author henning;	state Exp;
branches;
next	1.314;

1.314
date	2003.02.12.12.48.40;	author mcbride;	state Exp;
branches;
next	1.313;

1.313
date	2003.02.11.20.11.36;	author henning;	state Exp;
branches;
next	1.312;

1.312
date	2003.02.09.15.04.04;	author henning;	state Exp;
branches;
next	1.311;

1.311
date	2003.02.09.13.50.44;	author henning;	state Exp;
branches;
next	1.310;

1.310
date	2003.02.09.12.49.48;	author camield;	state Exp;
branches;
next	1.309;

1.309
date	2003.02.08.20.13.20;	author dhartmei;	state Exp;
branches;
next	1.308;

1.308
date	2003.02.05.16.05.54;	author cedric;	state Exp;
branches;
next	1.307;

1.307
date	2003.02.05.00.46.57;	author mcbride;	state Exp;
branches;
next	1.306;

1.306
date	2003.02.03.16.44.21;	author deraadt;	state Exp;
branches;
next	1.305;

1.305
date	2003.02.03.15.44.52;	author dhartmei;	state Exp;
branches;
next	1.304;

1.304
date	2003.02.03.14.51.36;	author cedric;	state Exp;
branches;
next	1.303;

1.303
date	2003.02.03.13.40.45;	author henning;	state Exp;
branches;
next	1.302;

1.302
date	2003.02.02.23.22.07;	author henning;	state Exp;
branches;
next	1.301;

1.301
date	2003.01.27.19.08.27;	author deraadt;	state Exp;
branches;
next	1.300;

1.300
date	2003.01.25.22.53.45;	author mcbride;	state Exp;
branches;
next	1.299;

1.299
date	2003.01.25.18.16.05;	author cedric;	state Exp;
branches;
next	1.298;

1.298
date	2003.01.25.16.33.19;	author cedric;	state Exp;
branches;
next	1.297;

1.297
date	2003.01.25.15.37.00;	author cedric;	state Exp;
branches;
next	1.296;

1.296
date	2003.01.25.00.51.40;	author henning;	state Exp;
branches;
next	1.295;

1.295
date	2003.01.20.18.37.52;	author camield;	state Exp;
branches;
next	1.294;

1.294
date	2003.01.19.10.19.15;	author camield;	state Exp;
branches;
next	1.293;

1.293
date	2003.01.18.15.06.13;	author henning;	state Exp;
branches;
next	1.292;

1.292
date	2003.01.18.04.45.59;	author mcbride;	state Exp;
branches;
next	1.291;

1.291
date	2003.01.17.12.53.52;	author camield;	state Exp;
branches;
next	1.290;

1.290
date	2003.01.15.15.14.42;	author mpech;	state Exp;
branches;
next	1.289;

1.289
date	2003.01.14.21.58.11;	author henning;	state Exp;
branches;
next	1.288;

1.288
date	2003.01.13.08.17.47;	author camield;	state Exp;
branches;
next	1.287;

1.287
date	2003.01.11.22.00.00;	author mcbride;	state Exp;
branches;
next	1.286;

1.286
date	2003.01.09.19.02.21;	author henning;	state Exp;
branches;
next	1.285;

1.285
date	2003.01.09.18.42.44;	author dhartmei;	state Exp;
branches;
next	1.284;

1.284
date	2003.01.09.17.59.23;	author henning;	state Exp;
branches;
next	1.283;

1.283
date	2003.01.09.10.40.44;	author cedric;	state Exp;
branches;
next	1.282;

1.282
date	2003.01.08.19.47.37;	author deraadt;	state Exp;
branches;
next	1.281;

1.281
date	2003.01.07.04.20.06;	author dhartmei;	state Exp;
branches;
next	1.280;

1.280
date	2003.01.07.00.21.07;	author dhartmei;	state Exp;
branches;
next	1.279;

1.279
date	2003.01.06.11.30.10;	author mcbride;	state Exp;
branches;
next	1.278;

1.278
date	2003.01.05.22.20.34;	author henning;	state Exp;
branches;
next	1.277;

1.277
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.276;

1.276
date	2003.01.04.17.40.51;	author dhartmei;	state Exp;
branches;
next	1.275;

1.275
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.274;

1.274
date	2003.01.03.22.22.18;	author dhartmei;	state Exp;
branches;
next	1.273;

1.273
date	2003.01.03.21.37.44;	author cedric;	state Exp;
branches;
next	1.272;

1.272
date	2003.01.02.11.34.59;	author mcbride;	state Exp;
branches;
next	1.271;

1.271
date	2002.12.30.23.46.54;	author mcbride;	state Exp;
branches;
next	1.270;

1.270
date	2002.12.27.22.13.31;	author mcbride;	state Exp;
branches;
next	1.269;

1.269
date	2002.12.21.18.53.48;	author henning;	state Exp;
branches;
next	1.268;

1.268
date	2002.12.21.18.47.33;	author henning;	state Exp;
branches;
next	1.267;

1.267
date	2002.12.20.19.57.37;	author dhartmei;	state Exp;
branches;
next	1.266;

1.266
date	2002.12.19.10.58.21;	author dhartmei;	state Exp;
branches;
next	1.265;

1.265
date	2002.12.18.18.01.41;	author henning;	state Exp;
branches;
next	1.264;

1.264
date	2002.12.18.10.16.55;	author dhartmei;	state Exp;
branches;
next	1.263;

1.263
date	2002.12.18.10.02.40;	author dhartmei;	state Exp;
branches;
next	1.262;

1.262
date	2002.12.18.08.01.47;	author deraadt;	state Exp;
branches;
next	1.261;

1.261
date	2002.12.17.20.06.05;	author henning;	state Exp;
branches;
next	1.260;

1.260
date	2002.12.17.12.36.59;	author mcbride;	state Exp;
branches;
next	1.259;

1.259
date	2002.12.17.12.05.58;	author henning;	state Exp;
branches;
next	1.258;

1.258
date	2002.12.17.12.01.22;	author henning;	state Exp;
branches;
next	1.257;

1.257
date	2002.12.17.11.29.04;	author henning;	state Exp;
branches;
next	1.256;

1.256
date	2002.12.16.23.36.14;	author henning;	state Exp;
branches;
next	1.255;

1.255
date	2002.12.16.22.50.11;	author henning;	state Exp;
branches;
next	1.254;

1.254
date	2002.12.13.21.51.25;	author henning;	state Exp;
branches;
next	1.253;

1.253
date	2002.12.13.20.02.40;	author henning;	state Exp;
branches;
next	1.252;

1.252
date	2002.12.13.12.06.27;	author deraadt;	state Exp;
branches;
next	1.251;

1.251
date	2002.12.12.15.06.16;	author henning;	state Exp;
branches;
next	1.250;

1.250
date	2002.12.12.14.46.26;	author henning;	state Exp;
branches;
next	1.249;

1.249
date	2002.12.11.13.23.38;	author mcbride;	state Exp;
branches;
next	1.248;

1.248
date	2002.12.09.13.17.48;	author dhartmei;	state Exp;
branches;
next	1.247;

1.247
date	2002.12.09.03.59.59;	author deraadt;	state Exp;
branches;
next	1.246;

1.246
date	2002.12.08.17.00.19;	author henning;	state Exp;
branches;
next	1.245;

1.245
date	2002.12.08.00.19.47;	author henning;	state Exp;
branches;
next	1.244;

1.244
date	2002.12.07.23.15.53;	author dhartmei;	state Exp;
branches;
next	1.243;

1.243
date	2002.12.07.21.20.23;	author henning;	state Exp;
branches;
next	1.242;

1.242
date	2002.12.07.21.16.26;	author henning;	state Exp;
branches;
next	1.241;

1.241
date	2002.12.07.20.25.40;	author henning;	state Exp;
branches;
next	1.240;

1.240
date	2002.12.07.20.09.57;	author henning;	state Exp;
branches;
next	1.239;

1.239
date	2002.12.07.18.16.59;	author mcbride;	state Exp;
branches;
next	1.238;

1.238
date	2002.12.06.12.36.02;	author dhartmei;	state Exp;
branches;
next	1.237;

1.237
date	2002.12.06.00.47.31;	author dhartmei;	state Exp;
branches;
next	1.236;

1.236
date	2002.12.05.15.28.00;	author henning;	state Exp;
branches;
next	1.235;

1.235
date	2002.12.05.13.07.24;	author henning;	state Exp;
branches;
next	1.234;

1.234
date	2002.12.04.12.57.55;	author henning;	state Exp;
branches;
next	1.233;

1.233
date	2002.12.04.08.07.27;	author deraadt;	state Exp;
branches;
next	1.232;

1.232
date	2002.12.02.22.45.37;	author henning;	state Exp;
branches;
next	1.231;

1.231
date	2002.12.02.22.34.33;	author deraadt;	state Exp;
branches;
next	1.230;

1.230
date	2002.12.02.22.18.21;	author henning;	state Exp;
branches;
next	1.229;

1.229
date	2002.11.30.13.53.14;	author mickey;	state Exp;
branches;
next	1.228;

1.228
date	2002.11.29.17.14.18;	author henning;	state Exp;
branches;
next	1.227;

1.227
date	2002.11.29.15.37.23;	author henning;	state Exp;
branches;
next	1.226;

1.226
date	2002.11.29.15.32.14;	author henning;	state Exp;
branches;
next	1.225;

1.225
date	2002.11.28.14.43.39;	author henning;	state Exp;
branches;
next	1.224;

1.224
date	2002.11.28.12.14.24;	author mcbride;	state Exp;
branches;
next	1.223;

1.223
date	2002.11.27.18.50.32;	author henning;	state Exp;
branches;
next	1.222;

1.222
date	2002.11.27.16.23.01;	author henning;	state Exp;
branches;
next	1.221;

1.221
date	2002.11.27.16.06.20;	author henning;	state Exp;
branches;
next	1.220;

1.220
date	2002.11.27.15.49.16;	author henning;	state Exp;
branches;
next	1.219;

1.219
date	2002.11.27.14.39.06;	author henning;	state Exp;
branches;
next	1.218;

1.218
date	2002.11.27.14.33.12;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2002.11.26.21.10.45;	author henning;	state Exp;
branches;
next	1.216;

1.216
date	2002.11.26.19.14.14;	author henning;	state Exp;
branches;
next	1.215;

1.215
date	2002.11.25.18.11.34;	author henning;	state Exp;
branches;
next	1.214;

1.214
date	2002.11.25.17.44.39;	author mickey;	state Exp;
branches;
next	1.213;

1.213
date	2002.11.25.16.30.22;	author henning;	state Exp;
branches;
next	1.212;

1.212
date	2002.11.25.15.50.58;	author henning;	state Exp;
branches;
next	1.211;

1.211
date	2002.11.24.17.33.57;	author pb;	state Exp;
branches;
next	1.210;

1.210
date	2002.11.24.13.12.36;	author dhartmei;	state Exp;
branches;
next	1.209;

1.209
date	2002.11.23.23.00.32;	author deraadt;	state Exp;
branches;
next	1.208;

1.208
date	2002.11.23.22.57.54;	author henning;	state Exp;
branches;
next	1.207;

1.207
date	2002.11.23.18.32.29;	author henning;	state Exp;
branches;
next	1.206;

1.206
date	2002.11.23.18.27.28;	author henning;	state Exp;
branches;
next	1.205;

1.205
date	2002.11.23.18.23.41;	author mcbride;	state Exp;
branches;
next	1.204;

1.204
date	2002.11.23.16.41.43;	author henning;	state Exp;
branches;
next	1.203;

1.203
date	2002.11.23.15.59.57;	author henning;	state Exp;
branches;
next	1.202;

1.202
date	2002.11.23.09.33.54;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2002.11.23.09.30.39;	author dhartmei;	state Exp;
branches;
next	1.200;

1.200
date	2002.11.23.09.15.25;	author mcbride;	state Exp;
branches;
next	1.199;

1.199
date	2002.11.23.05.22.24;	author mcbride;	state Exp;
branches;
next	1.198;

1.198
date	2002.11.22.12.24.30;	author henning;	state Exp;
branches;
next	1.197;

1.197
date	2002.11.19.18.51.09;	author henning;	state Exp;
branches;
next	1.196;

1.196
date	2002.11.19.17.31.24;	author henning;	state Exp;
branches;
next	1.195;

1.195
date	2002.11.19.17.05.19;	author henning;	state Exp;
branches;
next	1.194;

1.194
date	2002.11.19.12.11.36;	author camield;	state Exp;
branches;
next	1.193;

1.193
date	2002.11.19.11.25.45;	author wilfried;	state Exp;
branches;
next	1.192;

1.192
date	2002.11.18.23.38.48;	author deraadt;	state Exp;
branches;
next	1.191;

1.191
date	2002.11.18.23.37.00;	author henning;	state Exp;
branches;
next	1.190;

1.190
date	2002.11.18.23.28.50;	author henning;	state Exp;
branches;
next	1.189;

1.189
date	2002.11.18.23.13.32;	author deraadt;	state Exp;
branches;
next	1.188;

1.188
date	2002.11.18.22.55.39;	author deraadt;	state Exp;
branches;
next	1.187;

1.187
date	2002.11.18.22.49.15;	author henning;	state Exp;
branches;
next	1.186;

1.186
date	2002.11.13.22.44.11;	author henning;	state Exp;
branches;
next	1.185;

1.185
date	2002.11.13.18.24.53;	author dhartmei;	state Exp;
branches;
next	1.184;

1.184
date	2002.11.13.16.51.37;	author dhartmei;	state Exp;
branches;
next	1.183;

1.183
date	2002.11.08.10.50.28;	author henning;	state Exp;
branches;
next	1.182;

1.182
date	2002.11.07.17.47.33;	author henning;	state Exp;
branches;
next	1.181;

1.181
date	2002.11.04.22.46.28;	author henning;	state Exp;
branches;
next	1.180;

1.180
date	2002.11.02.15.29.28;	author dhartmei;	state Exp;
branches;
next	1.179;

1.179
date	2002.11.02.14.13.42;	author dhartmei;	state Exp;
branches;
next	1.178;

1.178
date	2002.10.30.11.55.19;	author henning;	state Exp;
branches;
next	1.177;

1.177
date	2002.10.30.11.52.49;	author henning;	state Exp;
branches;
next	1.176;

1.176
date	2002.10.29.15.23.38;	author henning;	state Exp;
branches;
next	1.175;

1.175
date	2002.10.27.13.53.59;	author henning;	state Exp;
branches;
next	1.174;

1.174
date	2002.10.22.12.55.01;	author mpech;	state Exp;
branches;
next	1.173;

1.173
date	2002.10.22.12.28.08;	author mcbride;	state Exp;
branches;
next	1.172;

1.172
date	2002.10.22.07.07.35;	author camield;	state Exp;
branches;
next	1.171;

1.171
date	2002.10.17.11.22.42;	author mcbride;	state Exp;
branches;
next	1.170;

1.170
date	2002.10.17.10.48.57;	author camield;	state Exp;
branches;
next	1.169;

1.169
date	2002.10.16.09.00.06;	author mpech;	state Exp;
branches;
next	1.168;

1.168
date	2002.10.14.12.58.28;	author henning;	state Exp;
branches;
next	1.167;

1.167
date	2002.10.11.12.57.53;	author camield;	state Exp;
branches;
next	1.166;

1.166
date	2002.10.11.12.46.05;	author camield;	state Exp;
branches;
next	1.165;

1.165
date	2002.10.08.01.17.43;	author vincent;	state Exp;
branches;
next	1.164;

1.164
date	2002.10.07.14.34.40;	author dhartmei;	state Exp;
branches;
next	1.163;

1.163
date	2002.10.07.14.13.48;	author dhartmei;	state Exp;
branches;
next	1.162;

1.162
date	2002.10.07.13.23.46;	author henning;	state Exp;
branches;
next	1.161;

1.161
date	2002.10.07.13.18.40;	author henning;	state Exp;
branches;
next	1.160;

1.160
date	2002.10.07.13.15.02;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2002.10.07.12.59.55;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2002.10.07.12.39.29;	author dhartmei;	state Exp;
branches;
next	1.157;

1.157
date	2002.10.06.16.22.10;	author dhartmei;	state Exp;
branches;
next	1.156;

1.156
date	2002.10.05.22.25.33;	author dhartmei;	state Exp;
branches;
next	1.155;

1.155
date	2002.10.05.21.17.57;	author dhartmei;	state Exp;
branches;
next	1.154;

1.154
date	2002.09.22.15.30.15;	author henning;	state Exp;
branches;
next	1.153;

1.153
date	2002.09.22.15.28.53;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2002.09.22.15.22.20;	author henning;	state Exp;
branches;
next	1.151;

1.151
date	2002.09.17.16.09.49;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2002.09.15.16.56.59;	author henning;	state Exp;
branches;
next	1.149;

1.149
date	2002.09.14.17.50.17;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2002.09.12.12.43.23;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2002.09.12.10.05.08;	author henning;	state Exp;
branches;
next	1.146;

1.146
date	2002.09.12.09.48.57;	author henning;	state Exp;
branches;
next	1.145;

1.145
date	2002.09.08.12.57.35;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2002.09.02.19.42.54;	author dhartmei;	state Exp;
branches;
next	1.143;

1.143
date	2002.09.02.19.40.31;	author dhartmei;	state Exp;
branches;
next	1.142;

1.142
date	2002.08.20.06.32.17;	author dhartmei;	state Exp;
branches;
next	1.141;

1.141
date	2002.08.16.14.14.03;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2002.08.12.19.36.04;	author dhartmei;	state Exp;
branches;
next	1.139;

1.139
date	2002.08.06.13.43.33;	author henning;	state Exp;
branches;
next	1.138;

1.138
date	2002.08.06.11.25.05;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2002.07.31.20.19.14;	author henning;	state Exp;
branches;
next	1.136;

1.136
date	2002.07.30.14.53.48;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2002.07.30.09.31.05;	author henning;	state Exp;
branches;
next	1.134;

1.134
date	2002.07.26.09.54.29;	author henning;	state Exp;
branches;
next	1.133;

1.133
date	2002.07.23.18.01.15;	author henning;	state Exp;
branches;
next	1.132;

1.132
date	2002.07.21.21.28.06;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2002.07.21.01.37.46;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2002.07.21.00.40.00;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2002.07.20.23.43.52;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2002.07.20.18.58.44;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2002.07.19.21.00.25;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2002.07.19.14.30.08;	author dhartmei;	state Exp;
branches;
next	1.125;

1.125
date	2002.07.19.13.23.37;	author henning;	state Exp;
branches;
next	1.124;

1.124
date	2002.07.19.12.36.48;	author dhartmei;	state Exp;
branches;
next	1.123;

1.123
date	2002.07.19.11.12.42;	author henning;	state Exp;
branches;
next	1.122;

1.122
date	2002.07.17.08.32.20;	author henning;	state Exp;
branches;
next	1.121;

1.121
date	2002.07.16.15.46.55;	author dhartmei;	state Exp;
branches;
next	1.120;

1.120
date	2002.07.15.18.13.53;	author henning;	state Exp;
branches;
next	1.119;

1.119
date	2002.07.15.15.44.15;	author pb;	state Exp;
branches;
next	1.118;

1.118
date	2002.07.15.13.36.02;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2002.07.13.18.36.02;	author henning;	state Exp;
branches;
next	1.116;

1.116
date	2002.07.09.11.50.58;	author itojun;	state Exp;
branches;
next	1.115;

1.115
date	2002.07.09.11.49.02;	author itojun;	state Exp;
branches;
next	1.114;

1.114
date	2002.07.09.10.39.08;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2002.07.08.11.46.32;	author dhartmei;	state Exp;
branches;
next	1.112;

1.112
date	2002.07.05.18.09.50;	author henning;	state Exp;
branches;
next	1.111;

1.111
date	2002.07.05.16.48.44;	author henning;	state Exp;
branches;
next	1.110;

1.110
date	2002.07.01.10.07.40;	author espie;	state Exp;
branches;
next	1.109;

1.109
date	2002.07.01.05.28.22;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2002.06.28.19.29.45;	author dhartmei;	state Exp;
branches;
next	1.107;

1.107
date	2002.06.25.08.13.25;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2002.06.24.10.55.08;	author dhartmei;	state Exp;
branches;
next	1.105;

1.105
date	2002.06.23.03.07.21;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2002.06.20.08.47.58;	author dhartmei;	state Exp;
branches;
next	1.103;

1.103
date	2002.06.18.21.05.17;	author frantzen;	state Exp;
branches;
next	1.102;

1.102
date	2002.06.18.20.07.58;	author frantzen;	state Exp;
branches;
next	1.101;

1.101
date	2002.06.16.23.22.18;	author aaron;	state Exp;
branches;
next	1.100;

1.100
date	2002.06.15.19.19.09;	author dhartmei;	state Exp;
branches;
next	1.99;

1.99
date	2002.06.13.04.26.00;	author kjell;	state Exp;
branches;
next	1.98;

1.98
date	2002.06.12.18.35.07;	author kjell;	state Exp;
branches;
next	1.97;

1.97
date	2002.06.11.18.03.25;	author frantzen;	state Exp;
branches;
next	1.96;

1.96
date	2002.06.11.02.27.19;	author frantzen;	state Exp;
branches;
next	1.95;

1.95
date	2002.06.11.02.12.37;	author dhartmei;	state Exp;
branches;
next	1.94;

1.94
date	2002.06.10.23.07.46;	author kjell;	state Exp;
branches;
next	1.93;

1.93
date	2002.06.10.19.31.44;	author dhartmei;	state Exp;
branches;
next	1.92;

1.92
date	2002.06.10.16.51.37;	author dhartmei;	state Exp;
branches;
next	1.91;

1.91
date	2002.06.10.02.09.59;	author kjell;	state Exp;
branches;
next	1.90;

1.90
date	2002.06.09.20.20.58;	author dhartmei;	state Exp;
branches;
next	1.89;

1.89
date	2002.06.09.05.31.25;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2002.06.09.02.47.10;	author kjell;	state Exp;
branches;
next	1.87;

1.87
date	2002.06.08.22.40.32;	author henning;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.08.21.09.59;	author dhartmei;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.08.20.59.52;	author itojun;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.08.09.41.52;	author kjell;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.08.08.44.09;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.08.08.04.02;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.08.07.58.07;	author dhartmei;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.08.01.00.23;	author henning;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.08.00.23.41;	author henning;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.07.23.30.39;	author dhartmei;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.07.23.06.43;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.07.22.53.45;	author pb;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.07.21.25.35;	author dhartmei;	state Exp;
branches;
next	1.74;

1.74
date	2002.06.07.19.33.03;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2002.06.07.18.26.55;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.07.18.24.33;	author itojun;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.01.04.06.47;	author hugh;	state Exp;
branches;
next	1.70;

1.70
date	2002.05.24.13.48.44;	author dhartmei;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.23.09.47.20;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.23.07.47.05;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.19.22.26.27;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2002.05.12.15.02.52;	author dhartmei;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.12.00.54.56;	author dhartmei;	state Exp;
branches;
next	1.64;

1.64
date	2002.05.10.14.09.53;	author dhartmei;	state Exp;
branches;
next	1.63;

1.63
date	2002.05.09.21.58.12;	author jasoni;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.09.19.58.42;	author dhartmei;	state Exp;
branches;
next	1.61;

1.61
date	2002.04.24.18.10.25;	author dhartmei;	state Exp;
branches;
next	1.60;

1.60
date	2002.04.23.14.32.23;	author dhartmei;	state Exp;
branches;
next	1.59;

1.59
date	2002.04.18.06.02.18;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2002.04.17.19.06.18;	author dhartmei;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.27.18.16.22;	author mickey;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.27.18.11.45;	author dhartmei;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.11.22.26.41;	author mickey;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.10.17.02.39;	author hugh;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.09.18.00.57;	author mpech;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.09.12.39.42;	author mpech;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.09.11.30.53;	author dhartmei;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.08.09.31.55;	author dhartmei;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.07.17.23.31;	author mpech;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.23.03.50.03;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.10.18.08.12;	author dhartmei;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.05.17.11.54;	author dhartmei;	state Exp;
branches;
next	1.45;

1.45
date	2001.12.03.21.52.08;	author dhartmei;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.26.16.50.25;	author jasoni;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.05.09.28.00;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2001.10.24.09.18.35;	author dhartmei;	state Exp;
branches;
next	1.41;

1.41
date	2001.10.15.16.22.22;	author dhartmei;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.10.11.22.03.12;	author frantzen;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.07.11.56.57;	author dhartmei;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.01.17.58.16;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.28.14.12.15;	author dhartmei;	state Exp;
branches;
next	1.36;

1.36
date	2001.09.20.18.31.44;	author dhartmei;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.15.23.23.40;	author wilfried;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.15.21.49.19;	author dhartmei;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.15.11.21.50;	author dhartmei;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.12.16.37.14;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.06.22.37.08;	author jasoni;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.06.18.05.46;	author jasoni;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.04.13.47.51;	author dhartmei;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.28.12.17.04;	author markus;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.28.09.54.14;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.28.09.27.16;	author dhartmei;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.26.07.58.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.25.21.54.26;	author frantzen;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.23.05.36.53;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.23.04.14.20;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.19.16.16.41;	author dhartmei;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.16.11.46.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.14.16.25.45;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.11.09.54.59;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.31.09.02.18;	author wilfried;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.19.00.07.36;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.18.09.53.14;	author markus;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.08.48.15;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.18.01.08.43;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.18.00.41.48;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.17.23.52.29;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.17.23.41.01;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.17.23.25.42;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.22.22.16;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.17.21.54.27;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.17.17.39.42;	author marc;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.17.16.07.47;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.16.22.43.19;	author markus;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.16.22.09.55;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	2001.07.16.21.09.37;	author markus;	state Exp;
branches;
next	;

1.41.2.1
date	2001.12.13.20.05.02;	author jason;	state Exp;
branches;
next	;

1.343.2.1
date	2003.05.31.01.00.23;	author margarida;	state Exp;
branches;
next	;

1.623.2.1
date	2014.10.29.15.36.44;	author sthen;	state Exp;
branches;
next	;
commitid	KDltmIoVhxTrRd6T;

1.631.4.1
date	2014.10.29.15.36.15;	author sthen;	state Exp;
branches;
next	;
commitid	HPnolLQ40jcwDio1;

1.636.4.1
date	2014.10.29.15.29.33;	author sthen;	state Exp;
branches;
next	;
commitid	fYdjk1qSZRmnT7ec;


desc
@@


1.663
log
@add option -N (no domain resolution)
manpage wording and reminder about usage() jmc@@
ok florian@@ henning@@
@
text
@/*	$OpenBSD: parse.y,v 1.662 2017/07/19 12:58:31 mikeb Exp $	*/

/*
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 * Copyright (c) 2002 - 2013 Henning Brauer <henning@@openbsd.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
%{
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <net/pfvar.h>
#include <arpa/inet.h>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <netdb.h>
#include <stdarg.h>
#include <errno.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <err.h>
#include <limits.h>
#include <pwd.h>
#include <grp.h>
#include <md5.h>

#include "pfctl_parser.h"
#include "pfctl.h"

static struct pfctl	*pf = NULL;
static int		 debug = 0;
static u_int16_t	 returnicmpdefault =
			    (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
static u_int16_t	 returnicmp6default =
			    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
static int		 blockpolicy = PFRULE_DROP;
static int		 default_statelock;

TAILQ_HEAD(files, file)		 files = TAILQ_HEAD_INITIALIZER(files);
static struct file {
	TAILQ_ENTRY(file)	 entry;
	FILE			*stream;
	char			*name;
	int			 lineno;
	int			 errors;
} *file;
struct file	*pushfile(const char *, int);
int		 popfile(void);
int		 check_file_secrecy(int, const char *);
int		 yyparse(void);
int		 yylex(void);
int		 yyerror(const char *, ...);
int		 kw_cmp(const void *, const void *);
int		 lookup(char *);
int		 lgetc(int);
int		 lungetc(int);
int		 findeol(void);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entry;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};
int		 symset(const char *, const char *, int);
char		*symget(const char *);

int		 atoul(char *, u_long *);

struct node_proto {
	u_int8_t		 proto;
	struct node_proto	*next;
	struct node_proto	*tail;
};

struct node_port {
	u_int16_t		 port[2];
	u_int8_t		 op;
	struct node_port	*next;
	struct node_port	*tail;
};

struct node_uid {
	uid_t			 uid[2];
	u_int8_t		 op;
	struct node_uid		*next;
	struct node_uid		*tail;
};

struct node_gid {
	gid_t			 gid[2];
	u_int8_t		 op;
	struct node_gid		*next;
	struct node_gid		*tail;
};

struct node_icmp {
	u_int8_t		 code;
	u_int8_t		 type;
	u_int8_t		 proto;
	struct node_icmp	*next;
	struct node_icmp	*tail;
};

enum	{ PF_STATE_OPT_MAX, PF_STATE_OPT_NOSYNC, PF_STATE_OPT_SRCTRACK,
	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_CONN,
	    PF_STATE_OPT_MAX_SRC_CONN_RATE, PF_STATE_OPT_MAX_SRC_NODES,
	    PF_STATE_OPT_OVERLOAD, PF_STATE_OPT_STATELOCK,
	    PF_STATE_OPT_TIMEOUT, PF_STATE_OPT_SLOPPY,
	    PF_STATE_OPT_PFLOW };

enum	{ PF_SRCTRACK_NONE, PF_SRCTRACK, PF_SRCTRACK_GLOBAL, PF_SRCTRACK_RULE };

struct node_state_opt {
	int			 type;
	union {
		u_int32_t	 max_states;
		u_int32_t	 max_src_states;
		u_int32_t	 max_src_conn;
		struct {
			u_int32_t	limit;
			u_int32_t	seconds;
		}		 max_src_conn_rate;
		struct {
			u_int8_t	flush;
			char		tblname[PF_TABLE_NAME_SIZE];
		}		 overload;
		u_int32_t	 max_src_nodes;
		u_int8_t	 src_track;
		u_int32_t	 statelock;
		struct {
			int		number;
			u_int32_t	seconds;
		}		 timeout;
	}			 data;
	struct node_state_opt	*next;
	struct node_state_opt	*tail;
};

struct peer {
	struct node_host	*host;
	struct node_port	*port;
};

struct node_queue {
	char			 queue[PF_QNAME_SIZE];
	char			 parent[PF_QNAME_SIZE];
	char			 ifname[IFNAMSIZ];
	int			 scheduler;
	struct node_queue	*next;
	struct node_queue	*tail;
};

struct node_qassign {
	char		*qname;
	char		*pqname;
};

struct range {
	int		 a;
	int		 b;
	int		 t;
};
struct redirection {
	struct node_host	*host;
	struct range		 rport;
};

struct pool_opts {
	int			 marker;
#define POM_TYPE		0x01
#define POM_STICKYADDRESS	0x02
	u_int8_t		 opts;
	int			 type;
	int			 staticport;
	struct pf_poolhashkey	*key;

} pool_opts;

struct divertspec {
	struct node_host	*addr;
	u_int16_t		 port;
};

struct redirspec {
	struct redirection      *rdr;
	struct pool_opts         pool_opts;
	int			 binat;
	int			 af;
};

struct filter_opts {
	int			 marker;
#define FOM_FLAGS	0x0001
#define FOM_ICMP	0x0002
#define FOM_TOS		0x0004
#define FOM_KEEP	0x0008
#define FOM_SRCTRACK	0x0010
#define FOM_MINTTL	0x0020
#define FOM_MAXMSS	0x0040
#define FOM_AFTO	0x0080
#define FOM_SETTOS	0x0100
#define FOM_SCRUB_TCP	0x0200
#define FOM_SETPRIO	0x0400
#define FOM_ONCE	0x1000
#define FOM_PRIO	0x2000
	struct node_uid		*uid;
	struct node_gid		*gid;
	struct node_if		*rcv;
	struct {
		u_int8_t	 b1;
		u_int8_t	 b2;
		u_int16_t	 w;
		u_int16_t	 w2;
	} flags;
	struct node_icmp	*icmpspec;
	u_int32_t		 tos;
	u_int32_t		 prob;
	struct {
		int			 action;
		struct node_state_opt	*options;
	} keep;
	int			 fragment;
	int			 allowopts;
	char			*label;
	struct node_qassign	 queues;
	char			*tag;
	char			*match_tag;
	u_int8_t		 match_tag_not;
	u_int			 rtableid;
	u_int8_t		 prio;
	u_int8_t		 set_prio[2];
	struct divertspec	 divert;
	struct divertspec	 divert_packet;
	struct redirspec	 nat;
	struct redirspec	 rdr;
	struct redirspec	 rroute;

	/* scrub opts */
	int			 nodf;
	int			 minttl;
	int			 settos;
	int			 randomid;
	int			 max_mss;

	/* route opts */
	struct {
		struct node_host	*host;
		u_int8_t		 rt;
		u_int8_t		 pool_opts;
		sa_family_t		 af;
		struct pf_poolhashkey	*key;
	}			 route;
} filter_opts;

struct antispoof_opts {
	char			*label;
	u_int			 rtableid;
} antispoof_opts;

struct scrub_opts {
	int			marker;
	int			nodf;
	int			minttl;
	int			maxmss;
	int			settos;
	int			randomid;
	int			reassemble_tcp;
} scrub_opts;

struct node_sc {
	struct node_queue_bw	m1;
	u_int			d;
	struct node_queue_bw	m2;
};

struct node_fq {
	u_int			flows;
	u_int			quantum;
	u_int			target;
	u_int			interval;
};

struct queue_opts {
	int		 marker;
#define	QOM_BWSPEC	0x01
#define	QOM_PARENT	0x02
#define	QOM_DEFAULT	0x04
#define	QOM_QLIMIT	0x08
#define	QOM_FLOWS	0x10
#define	QOM_QUANTUM	0x20
	struct node_sc	 realtime;
	struct node_sc	 linkshare;
	struct node_sc	 upperlimit;
	struct node_fq	 flowqueue;
	char		*parent;
	int		 flags;
	u_int		 qlimit;
} queue_opts;

struct table_opts {
	int			flags;
	int			init_addr;
	struct node_tinithead	init_nodes;
} table_opts;

struct node_hfsc_opts	 hfsc_opts;
struct node_state_opt	*keep_state_defaults = NULL;

int		 disallow_table(struct node_host *, const char *);
int		 disallow_urpf_failed(struct node_host *, const char *);
int		 disallow_alias(struct node_host *, const char *);
int		 rule_consistent(struct pf_rule *, int);
int		 process_tabledef(char *, struct table_opts *, int);
void		 expand_label_str(char *, size_t, const char *, const char *);
void		 expand_label_if(const char *, char *, size_t, const char *);
void		 expand_label_addr(const char *, char *, size_t, u_int8_t,
		    struct node_host *);
void		 expand_label_port(const char *, char *, size_t,
		    struct node_port *);
void		 expand_label_proto(const char *, char *, size_t, u_int8_t);
void		 expand_label_nr(const char *, char *, size_t);
void		 expand_label(char *, size_t, const char *, u_int8_t,
		    struct node_host *, struct node_port *, struct node_host *,
		    struct node_port *, u_int8_t);
int		 expand_divertspec(struct pf_rule *, struct divertspec *);
int		 collapse_redirspec(struct pf_pool *, struct pf_rule *,
		    struct redirspec *rs, u_int8_t);
int		 apply_redirspec(struct pf_pool *, struct pf_rule *,
		    struct redirspec *, int, struct node_port *);
void		 expand_rule(struct pf_rule *, int, struct node_if *,
		    struct redirspec *, struct redirspec *, struct redirspec *,
		    struct node_proto *,
		    struct node_os *, struct node_host *, struct node_port *,
		    struct node_host *, struct node_port *, struct node_uid *,
		    struct node_gid *, struct node_if *, struct node_icmp *,
		    const char *);
int		 expand_queue(char *, struct node_if *, struct queue_opts *);
int		 expand_skip_interface(struct node_if *);

int	 getservice(char *);
int	 rule_label(struct pf_rule *, char *);

void	 mv_rules(struct pf_ruleset *, struct pf_ruleset *);
void	 decide_address_family(struct node_host *, sa_family_t *);
int	 invalid_redirect(struct node_host *, sa_family_t);
u_int16_t parseicmpspec(char *, sa_family_t);
int	 kw_casecmp(const void *, const void *);
int	 map_tos(char *string, int *);

TAILQ_HEAD(loadanchorshead, loadanchors)
    loadanchorshead = TAILQ_HEAD_INITIALIZER(loadanchorshead);

struct loadanchors {
	TAILQ_ENTRY(loadanchors)	 entries;
	char				*anchorname;
	char				*filename;
};

typedef struct {
	union {
		int64_t			 number;
		double			 probability;
		int			 i;
		char			*string;
		u_int			 rtableid;
		u_int16_t		 weight;
		struct {
			u_int8_t	 b1;
			u_int8_t	 b2;
			u_int16_t	 w;
			u_int16_t	 w2;
		}			 b;
		struct range		 range;
		struct node_if		*interface;
		struct node_proto	*proto;
		struct node_icmp	*icmp;
		struct node_host	*host;
		struct node_os		*os;
		struct node_port	*port;
		struct node_uid		*uid;
		struct node_gid		*gid;
		struct node_state_opt	*state_opt;
		struct peer		 peer;
		struct {
			struct peer	 src, dst;
			struct node_os	*src_os;
		}			 fromto;
		struct redirection	*redirection;
		struct {
			int			 action;
			struct node_state_opt	*options;
		}			 keep_state;
		struct {
			u_int8_t	 log;
			u_int8_t	 logif;
			u_int8_t	 quick;
		}			 logquick;
		struct {
			int		 neg;
			char		*name;
		}			 tagged;
		struct pf_poolhashkey	*hashkey;
		struct node_queue	*queue;
		struct node_queue_opt	 queue_options;
		struct node_queue_bw	 queue_bwspec;
		struct node_qassign	 qassign;
		struct node_sc		 sc;
		struct filter_opts	 filter_opts;
		struct antispoof_opts	 antispoof_opts;
		struct queue_opts	 queue_opts;
		struct scrub_opts	 scrub_opts;
		struct table_opts	 table_opts;
		struct pool_opts	 pool_opts;
		struct node_hfsc_opts	 hfsc_opts;
	} v;
	int lineno;
} YYSTYPE;

#define PPORT_RANGE	1
#define PPORT_STAR	2
int	parseport(char *, struct range *r, int);

#define DYNIF_MULTIADDR(addr) ((addr).type == PF_ADDR_DYNIFTL && \
	(!((addr).iflags & PFI_AFLAG_NOALIAS) ||		 \
	!isdigit((unsigned char)(addr).v.ifname[strlen((addr).v.ifname)-1])))

%}

%token	PASS BLOCK MATCH SCRUB RETURN IN OS OUT LOG QUICK ON FROM TO FLAGS
%token	RETURNRST RETURNICMP RETURNICMP6 PROTO INET INET6 ALL ANY ICMPTYPE
%token	ICMP6TYPE CODE KEEP MODULATE STATE PORT BINATTO NODF
%token	MINTTL ERROR ALLOWOPTS FILENAME ROUTETO DUPTO REPLYTO NO LABEL
%token	NOROUTE URPFFAILED FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP TABLE
%token	REASSEMBLE ANCHOR
%token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE BLOCKPOLICY RANDOMID
%token	SYNPROXY FINGERPRINTS NOSYNC DEBUG SKIP HOSTID
%token	ANTISPOOF FOR INCLUDE MATCHES
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN LEASTSTATES STATICPORT PROBABILITY
%token	WEIGHT BANDWIDTH FLOWS QUANTUM
%token	QUEUE PRIORITY QLIMIT RTABLE RDOMAIN MINIMUM BURST PARENT
%token	LOAD RULESET_OPTIMIZATION RTABLE RDOMAIN PRIO ONCE DEFAULT
%token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
%token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH SLOPPY PFLOW
%token	TAGGED TAG IFBOUND FLOATING STATEPOLICY STATEDEFAULTS ROUTE
%token	DIVERTTO DIVERTREPLY DIVERTPACKET NATTO AFTO RDRTO RECEIVEDON NE LE GE
%token	<v.string>		STRING
%token	<v.number>		NUMBER
%token	<v.i>			PORTBINARY
%type	<v.interface>		interface if_list if_item_not if_item
%type	<v.number>		number icmptype icmp6type uid gid
%type	<v.number>		tos not yesno optnodf
%type	<v.probability>		probability
%type	<v.weight>		optweight
%type	<v.i>			dir af optimizer
%type	<v.i>			sourcetrack flush unaryop statelock
%type	<v.b>			action
%type	<v.b>			flags flag blockspec prio
%type	<v.range>		portplain portstar portrange
%type	<v.hashkey>		hashkey
%type	<v.proto>		proto proto_list proto_item
%type	<v.number>		protoval
%type	<v.icmp>		icmpspec
%type	<v.icmp>		icmp_list icmp_item
%type	<v.icmp>		icmp6_list icmp6_item
%type	<v.number>		reticmpspec reticmp6spec
%type	<v.fromto>		fromto
%type	<v.peer>		ipportspec from to
%type	<v.host>		ipspec xhost host dynaddr host_list
%type	<v.host>		table_host_list tablespec
%type	<v.host>		redir_host_list redirspec
%type	<v.host>		route_host route_host_list routespec
%type	<v.os>			os xos os_list
%type	<v.port>		portspec port_list port_item
%type	<v.uid>			uids uid_list uid_item
%type	<v.gid>			gids gid_list gid_item
%type	<v.redirection>		redirpool
%type	<v.string>		label stringall anchorname
%type	<v.string>		string varstring numberstring
%type	<v.keep_state>		keep
%type	<v.state_opt>		state_opt_spec state_opt_list state_opt_item
%type	<v.logquick>		logquick quick log logopts logopt
%type	<v.interface>		antispoof_ifspc antispoof_iflst antispoof_if
%type	<v.qassign>		qname
%type	<v.queue_bwspec>	bandwidth
%type	<v.filter_opts>		filter_opts filter_opt filter_opts_l
%type	<v.filter_opts>		filter_sets filter_set filter_sets_l
%type	<v.antispoof_opts>	antispoof_opts antispoof_opt antispoof_opts_l
%type	<v.queue_opts>		queue_opts queue_opt queue_opts_l optscs
%type	<v.sc>			scspec
%type	<v.scrub_opts>		scrub_opts scrub_opt scrub_opts_l
%type	<v.table_opts>		table_opts table_opt table_opts_l
%type	<v.pool_opts>		pool_opts pool_opt pool_opts_l
%%

ruleset		: /* empty */
		| ruleset include '\n'
		| ruleset '\n'
		| ruleset option '\n'
		| ruleset pfrule '\n'
		| ruleset anchorrule '\n'
		| ruleset loadrule '\n'
		| ruleset queuespec '\n'
		| ruleset varset '\n'
		| ruleset antispoof '\n'
		| ruleset tabledef '\n'
		| '{' fakeanchor '}' '\n';
		| ruleset error '\n'		{ file->errors++; }
		;

include		: INCLUDE STRING		{
			struct file	*nfile;

			if ((nfile = pushfile($2, 0)) == NULL) {
				yyerror("failed to include file %s", $2);
				free($2);
				YYERROR;
			}
			free($2);

			file = nfile;
			lungetc('\n');
		}
		;

/*
 * apply to previously specified rule: must be careful to note
 * what that is: pf or nat or binat or rdr
 */
fakeanchor	: fakeanchor '\n'
		| fakeanchor anchorrule '\n'
		| fakeanchor pfrule '\n'
		| fakeanchor error '\n'
		;

optimizer	: string	{
			if (!strcmp($1, "none"))
				$$ = 0;
			else if (!strcmp($1, "basic"))
				$$ = PF_OPTIMIZE_BASIC;
			else if (!strcmp($1, "profile"))
				$$ = PF_OPTIMIZE_BASIC | PF_OPTIMIZE_PROFILE;
			else {
				yyerror("unknown ruleset-optimization %s", $1);
				YYERROR;
			}
		}
		;

optnodf		: /* empty */	{ $$ = 0; }
		| NODF		{ $$ = 1; }
		;

option		: SET REASSEMBLE yesno optnodf		{
			pfctl_set_reassembly(pf, $3, $4);
		}
		| SET OPTIMIZATION STRING		{
			if (pfctl_set_optimization(pf, $3) != 0) {
				yyerror("unknown optimization %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET RULESET_OPTIMIZATION optimizer {
			if (!(pf->opts & PF_OPT_OPTIMIZE)) {
				pf->opts |= PF_OPT_OPTIMIZE;
				pf->optimize = $3;
			}
		}
		| SET TIMEOUT timeout_spec
		| SET TIMEOUT '{' optnl timeout_list '}'
		| SET LIMIT limit_spec
		| SET LIMIT '{' optnl limit_list '}'
		| SET LOGINTERFACE stringall		{
			if (pfctl_set_logif(pf, $3) != 0) {
				yyerror("error setting loginterface %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET HOSTID number {
			if ($3 == 0 || $3 > UINT_MAX) {
				yyerror("hostid must be non-zero");
				YYERROR;
			}
			pfctl_set_hostid(pf, $3);
		}
		| SET BLOCKPOLICY DROP	{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set block-policy drop\n");
			blockpolicy = PFRULE_DROP;
		}
		| SET BLOCKPOLICY RETURN {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set block-policy return\n");
			blockpolicy = PFRULE_RETURN;
		}
		| SET FINGERPRINTS STRING {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set fingerprints \"%s\"\n", $3);
			if (!pf->anchor->name[0]) {
				if (pfctl_file_fingerprints(pf->dev,
				    pf->opts, $3)) {
					yyerror("error loading "
					    "fingerprints %s", $3);
					free($3);
					YYERROR;
				}
			}
			free($3);
		}
		| SET STATEPOLICY statelock {
			if (pf->opts & PF_OPT_VERBOSE)
				switch ($3) {
				case 0:
					printf("set state-policy floating\n");
					break;
				case PFRULE_IFBOUND:
					printf("set state-policy if-bound\n");
					break;
				}
			default_statelock = $3;
		}
		| SET DEBUG STRING {
			if (pfctl_set_debug(pf, $3) != 0) {
				yyerror("error setting debuglevel %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET DEBUG DEBUG {
			if (pfctl_set_debug(pf, "debug") != 0) {
				yyerror("error setting debuglevel %s", "debug");
				YYERROR;
			}
		}
		| SET SKIP interface {
			if (expand_skip_interface($3) != 0) {
				yyerror("error setting skip interface(s)");
				YYERROR;
			}
		}
		| SET STATEDEFAULTS state_opt_list {
			if (keep_state_defaults != NULL) {
				yyerror("cannot redefine state-defaults");
				YYERROR;
			}
			keep_state_defaults = $3;
		}
		;

stringall	: STRING	{ $$ = $1; }
		| ALL		{
			if (($$ = strdup("all")) == NULL) {
				err(1, "stringall: strdup");
			}
		}
		;

string		: STRING string				{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				err(1, "string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varstring	: numberstring varstring 		{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				err(1, "string: asprintf");
			free($1);
			free($2);
		}
		| numberstring
		;

numberstring	: NUMBER				{
			char	*s;
			if (asprintf(&s, "%lld", $1) == -1) {
				yyerror("string: asprintf");
				YYERROR;
			}
			$$ = s;
		}
		| STRING
		;

varset		: STRING '=' varstring	{
			char *s = $1;
			if (pf->opts & PF_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			while (*s++) {
				if (isspace((unsigned char)*s)) {
					yyerror("macro name cannot contain "
					    "whitespace");
					YYERROR;
				}
			}
			if (symset($1, $3, 0) == -1)
				err(1, "cannot store variable %s", $1);
			free($1);
			free($3);
		}
		;

anchorname	: STRING			{ $$ = $1; }
		| /* empty */			{ $$ = NULL; }
		;

pfa_anchorlist	: /* empty */
		| pfa_anchorlist '\n'
		| pfa_anchorlist pfrule '\n'
		| pfa_anchorlist anchorrule '\n'
		| pfa_anchorlist include '\n'
		;

pfa_anchor	: '{'
		{
			char ta[PF_ANCHOR_NAME_SIZE];
			struct pf_ruleset *rs;

			/* steping into a brace anchor */
			pf->asd++;
			pf->bn++;
			pf->brace = 1;

			/*
			 * Anchor contents are parsed before the anchor rule
			 * production completes, so we don't know the real
			 * location yet. Create a holding ruleset in the root;
			 * contents will be moved afterwards.
			 */
			snprintf(ta, PF_ANCHOR_NAME_SIZE, "_%d", pf->bn);
			rs = pf_find_or_create_ruleset(ta);
			if (rs == NULL)
				err(1, "pfa_anchor: pf_find_or_create_ruleset");
			pf->astack[pf->asd] = rs->anchor;
			pf->anchor = rs->anchor;
		} '\n' pfa_anchorlist '}'
		{
			pf->alast = pf->anchor;
			pf->asd--;
			pf->anchor = pf->astack[pf->asd];
		}
		| /* empty */
		;

anchorrule	: ANCHOR anchorname dir quick interface af proto fromto
		    filter_opts pfa_anchor
		{
			struct pf_rule	r;
			struct node_proto	*proto;

			if ($2 && ($2[0] == '_' || strstr($2, "/_") != NULL)) {
				free($2);
				yyerror("anchor names beginning with '_' "
				    "are reserved for internal use");
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			if (pf->astack[pf->asd + 1]) {
				if ($2 && strchr($2, '/') != NULL) {
					free($2);
					yyerror("anchor paths containing '/' "
				    	    "cannot be used for inline anchors.");
					YYERROR;
				}

				/* Move inline rules into relative location. */
				pf_anchor_setup(&r,
				    &pf->astack[pf->asd]->ruleset,
				    $2 ? $2 : pf->alast->name);

				if (r.anchor == NULL)
					err(1, "anchorrule: unable to "
					    "create ruleset");

				if (pf->alast != r.anchor) {
					if (r.anchor->match) {
						yyerror("inline anchor '%s' "
						    "already exists",
						    r.anchor->name);
						YYERROR;
					}
					mv_rules(&pf->alast->ruleset,
					    &r.anchor->ruleset);
				}
				pf_remove_if_empty_ruleset(&pf->alast->ruleset);
				pf->alast = r.anchor;
			} else {
				if (!$2) {
					yyerror("anchors without explicit "
					    "rules must specify a name");
					YYERROR;
				}
			}
			r.direction = $3;
			r.quick = $4.quick;
			r.af = $6;
			r.prob = $9.prob;
			r.rtableid = $9.rtableid;

			if ($9.tag)
				if (strlcpy(r.tagname, $9.tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $9.match_tag_not;
			if (rule_label(&r, $9.label))
				YYERROR;
			free($9.label);
			r.flags = $9.flags.b1;
			r.flagset = $9.flags.b2;
			if (($9.flags.b1 & $9.flags.b2) != $9.flags.b1) {
				yyerror("flags always false");
				YYERROR;
			}
			if ($9.flags.b1 || $9.flags.b2 || $8.src_os) {
				for (proto = $7; proto != NULL &&
				    proto->proto != IPPROTO_TCP;
				    proto = proto->next)
					;	/* nothing */
				if (proto == NULL && $7 != NULL) {
					if ($9.flags.b1 || $9.flags.b2)
						yyerror(
						    "flags only apply to tcp");
					if ($8.src_os)
						yyerror(
						    "OS fingerprinting only "
						    "applies to tcp");
					YYERROR;
				}
			}

			r.tos = $9.tos;

			if ($9.keep.action) {
				yyerror("cannot specify state handling "
				    "on anchors");
				YYERROR;
			}

			if ($9.route.rt) {
				yyerror("cannot specify route handling "
				    "on anchors");
				YYERROR;
			}

			if ($9.marker & FOM_ONCE) {
				yyerror("cannot specify 'once' "
				    "on anchors");
				YYERROR;
			}

			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $9.match_tag_not;
			if ($9.marker & FOM_PRIO) {
				if ($9.prio == 0)
					r.prio = PF_PRIO_ZERO;
				else
					r.prio = $9.prio;
			}
			if ($9.marker & FOM_SETPRIO) {
				r.set_prio[0] = $9.set_prio[0];
				r.set_prio[1] = $9.set_prio[1];
				r.scrub_flags |= PFSTATE_SETPRIO;
			}

			decide_address_family($8.src.host, &r.af);
			decide_address_family($8.dst.host, &r.af);

			expand_rule(&r, 0, $5, NULL, NULL, NULL, $7, $8.src_os,
			    $8.src.host, $8.src.port, $8.dst.host, $8.dst.port,
			    $9.uid, $9.gid, $9.rcv, $9.icmpspec,
			    pf->astack[pf->asd + 1] ? pf->alast->name : $2);
			free($2);
			pf->astack[pf->asd + 1] = NULL;
		}
		;

loadrule	: LOAD ANCHOR string FROM string	{
			struct loadanchors	*loadanchor;

			if (strlen(pf->anchor->name) + 1 +
			    strlen($3) >= PATH_MAX) {
				yyerror("anchorname %s too long, max %u\n",
				    $3, PATH_MAX - 1);
				free($3);
				YYERROR;
			}
			loadanchor = calloc(1, sizeof(struct loadanchors));
			if (loadanchor == NULL)
				err(1, "loadrule: calloc");
			if ((loadanchor->anchorname = malloc(PATH_MAX)) ==
			    NULL)
				err(1, "loadrule: malloc");
			if (pf->anchor->name[0])
				snprintf(loadanchor->anchorname, PATH_MAX,
				    "%s/%s", pf->anchor->name, $3);
			else
				strlcpy(loadanchor->anchorname, $3, PATH_MAX);
			if ((loadanchor->filename = strdup($5)) == NULL)
				err(1, "loadrule: strdup");

			TAILQ_INSERT_TAIL(&loadanchorshead, loadanchor,
			    entries);

			free($3);
			free($5);
		};

scrub_opts	:	{
				bzero(&scrub_opts, sizeof scrub_opts);
			}
		    scrub_opts_l
			{ $$ = scrub_opts; }
		;

scrub_opts_l	: scrub_opts_l comma scrub_opt
		| scrub_opt
		;

scrub_opt	: NODF	{
			if (scrub_opts.nodf) {
				yyerror("no-df cannot be respecified");
				YYERROR;
			}
			scrub_opts.nodf = 1;
		}
		| MINTTL NUMBER {
			if (scrub_opts.marker & FOM_MINTTL) {
				yyerror("min-ttl cannot be respecified");
				YYERROR;
			}
			if ($2 < 0 || $2 > 255) {
				yyerror("illegal min-ttl value %d", $2);
				YYERROR;
			}
			scrub_opts.marker |= FOM_MINTTL;
			scrub_opts.minttl = $2;
		}
		| MAXMSS NUMBER {
			if (scrub_opts.marker & FOM_MAXMSS) {
				yyerror("max-mss cannot be respecified");
				YYERROR;
			}
			if ($2 < 0 || $2 > 65535) {
				yyerror("illegal max-mss value %d", $2);
				YYERROR;
			}
			scrub_opts.marker |= FOM_MAXMSS;
			scrub_opts.maxmss = $2;
		}
		| REASSEMBLE STRING {
			if (strcasecmp($2, "tcp") != 0) {
				yyerror("scrub reassemble supports only tcp, "
				    "not '%s'", $2);
				free($2);
				YYERROR;
			}
			free($2);
			if (scrub_opts.reassemble_tcp) {
				yyerror("reassemble tcp cannot be respecified");
				YYERROR;
			}
			scrub_opts.reassemble_tcp = 1;
		}
		| RANDOMID {
			if (scrub_opts.randomid) {
				yyerror("random-id cannot be respecified");
				YYERROR;
			}
			scrub_opts.randomid = 1;
		}
		;

antispoof	: ANTISPOOF logquick antispoof_ifspc af antispoof_opts {
			struct pf_rule		 r;
			struct node_host	*h = NULL, *hh;
			struct node_if		*i, *j;

			for (i = $3; i; i = i->next) {
				bzero(&r, sizeof(r));

				r.action = PF_DROP;
				r.direction = PF_IN;
				r.log = $2.log;
				r.logif = $2.logif;
				r.quick = $2.quick;
				r.af = $4;
				if (rule_label(&r, $5.label))
					YYERROR;
				r.rtableid = $5.rtableid;
				j = calloc(1, sizeof(struct node_if));
				if (j == NULL)
					err(1, "antispoof: calloc");
				if (strlcpy(j->ifname, i->ifname,
				    sizeof(j->ifname)) >= sizeof(j->ifname)) {
					free(j);
					yyerror("interface name too long");
					YYERROR;
				}
				j->not = 1;
				if (i->dynamic) {
					h = calloc(1, sizeof(*h));
					if (h == NULL)
						err(1, "address: calloc");
					h->addr.type = PF_ADDR_DYNIFTL;
					set_ipmask(h, 128);
					if (strlcpy(h->addr.v.ifname, i->ifname,
					    sizeof(h->addr.v.ifname)) >=
					    sizeof(h->addr.v.ifname)) {
						free(h);
						yyerror(
						    "interface name too long");
						YYERROR;
					}
					hh = malloc(sizeof(*hh));
					if (hh == NULL)
						 err(1, "address: malloc");
					bcopy(h, hh, sizeof(*hh));
					h->addr.iflags = PFI_AFLAG_NETWORK;
				} else {
					h = ifa_lookup(j->ifname,
					    PFI_AFLAG_NETWORK);
					hh = NULL;
				}

				if (h != NULL)
					expand_rule(&r, 0, j, NULL, NULL, NULL,
					    NULL, NULL, h, NULL, NULL, NULL,
					    NULL, NULL, NULL, NULL, "");

				if ((i->ifa_flags & IFF_LOOPBACK) == 0) {
					bzero(&r, sizeof(r));

					r.action = PF_DROP;
					r.direction = PF_IN;
					r.log = $2.log;
					r.logif = $2.logif;
					r.quick = $2.quick;
					r.af = $4;
					if (rule_label(&r, $5.label))
						YYERROR;
					r.rtableid = $5.rtableid;
					if (hh != NULL)
						h = hh;
					else
						h = ifa_lookup(i->ifname, 0);
					if (h != NULL)
						expand_rule(&r, 0, NULL, NULL,
						    NULL, NULL, NULL, NULL, h,
						    NULL, NULL, NULL, NULL,
						    NULL, NULL, NULL, "");
				} else
					free(hh);
			}
			free($5.label);
		}
		;

antispoof_ifspc	: FOR antispoof_if			{ $$ = $2; }
		| FOR '{' optnl antispoof_iflst '}'	{ $$ = $4; }
		;

antispoof_iflst	: antispoof_if optnl			{ $$ = $1; }
		| antispoof_iflst comma antispoof_if optnl {
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

antispoof_if	: if_item				{ $$ = $1; }
		| '(' if_item ')'			{
			$2->dynamic = 1;
			$$ = $2;
		}
		;

antispoof_opts	:	{
				bzero(&antispoof_opts, sizeof antispoof_opts);
				antispoof_opts.rtableid = -1;
			}
		    antispoof_opts_l
			{ $$ = antispoof_opts; }
		| /* empty */	{
			bzero(&antispoof_opts, sizeof antispoof_opts);
			antispoof_opts.rtableid = -1;
			$$ = antispoof_opts;
		}
		;

antispoof_opts_l	: antispoof_opts_l antispoof_opt
			| antispoof_opt
			;

antispoof_opt	: LABEL label	{
			if (antispoof_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			antispoof_opts.label = $2;
		}
		| RTABLE NUMBER				{
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rtable id");
				YYERROR;
			}
			antispoof_opts.rtableid = $2;
		}
		;

not		: '!'		{ $$ = 1; }
		| /* empty */	{ $$ = 0; }
		;

tabledef	: TABLE '<' STRING '>' table_opts {
			struct node_host	 *h, *nh;
			struct node_tinit	 *ti, *nti;

			if (strlen($3) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name too long, max %d chars",
				    PF_TABLE_NAME_SIZE - 1);
				free($3);
				YYERROR;
			}
			if (process_tabledef($3, &$5, pf->opts)) {
				free($3);
				YYERROR;
			}
			free($3);
			for (ti = SIMPLEQ_FIRST(&$5.init_nodes); ti != NULL;
			    ti = nti) {
				if (ti->file)
					free(ti->file);
				for (h = ti->host; h != NULL; h = nh) {
					nh = h->next;
					free(h);
				}
				nti = SIMPLEQ_NEXT(ti, entries);
				free(ti);
			}
		}
		;

table_opts	:	{
			bzero(&table_opts, sizeof table_opts);
			SIMPLEQ_INIT(&table_opts.init_nodes);
		}
		    table_opts_l
			{ $$ = table_opts; }
		| /* empty */
			{
			bzero(&table_opts, sizeof table_opts);
			SIMPLEQ_INIT(&table_opts.init_nodes);
			$$ = table_opts;
		}
		;

table_opts_l	: table_opts_l table_opt
		| table_opt
		;

table_opt	: STRING		{
			if (!strcmp($1, "const"))
				table_opts.flags |= PFR_TFLAG_CONST;
			else if (!strcmp($1, "persist"))
				table_opts.flags |= PFR_TFLAG_PERSIST;
			else if (!strcmp($1, "counters"))
				table_opts.flags |= PFR_TFLAG_COUNTERS;
			else {
				yyerror("invalid table option '%s'", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		| '{' optnl '}'		{ table_opts.init_addr = 1; }
		| '{' optnl table_host_list '}'	{
			struct node_host	*n;
			struct node_tinit	*ti;

			for (n = $3; n != NULL; n = n->next) {
				switch (n->addr.type) {
				case PF_ADDR_ADDRMASK:
					continue; /* ok */
				case PF_ADDR_RANGE:
					yyerror("address ranges are not "
					    "permitted inside tables");
					break;
				case PF_ADDR_DYNIFTL:
					yyerror("dynamic addresses are not "
					    "permitted inside tables");
					break;
				case PF_ADDR_TABLE:
					yyerror("tables cannot contain tables");
					break;
				case PF_ADDR_NOROUTE:
					yyerror("\"no-route\" is not permitted "
					    "inside tables");
					break;
				case PF_ADDR_URPFFAILED:
					yyerror("\"urpf-failed\" is not "
					    "permitted inside tables");
					break;
				default:
					yyerror("unknown address type %d",
					    n->addr.type);
				}
				YYERROR;
			}
			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->host = $3;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
		}
		| FILENAME STRING	{
			struct node_tinit	*ti;

			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->file = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
		}
		;

tablespec	: xhost	optweight		{
			if ($2 > 0) {
				struct node_host	*n;
				for (n = $1; n != NULL; n = n->next)
					n->weight = $2;
			}
			$$ = $1;
		}
		| '{' optnl table_host_list '}'	{ $$ = $3; }
		;

table_host_list	: tablespec optnl			{ $$ = $1; }
		| table_host_list comma tablespec optnl {
			$1->tail->next = $3;
			$1->tail = $3->tail;
			$$ = $1;
		}
		;

queuespec	: QUEUE STRING interface queue_opts		{
			if ($3 == NULL && $4.parent == NULL) {
				yyerror("root queue without interface");
				YYERROR;
			}
			expand_queue($2, $3, &$4);
		}
		;

queue_opts	:	{
			bzero(&queue_opts, sizeof queue_opts);
		}
		    queue_opts_l
			{ $$ = queue_opts; }
		;

queue_opts_l	: queue_opts_l queue_opt
		| queue_opt
		;

queue_opt	: BANDWIDTH scspec optscs			{
			if (queue_opts.marker & QOM_BWSPEC) {
				yyerror("bandwidth cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_BWSPEC;
			queue_opts.linkshare = $2;
			queue_opts.realtime= $3.realtime;
			queue_opts.upperlimit = $3.upperlimit;
		}
		| PARENT STRING					{
			if (queue_opts.marker & QOM_PARENT) {
				yyerror("parent cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_PARENT;
			queue_opts.parent = $2;
		}
		| DEFAULT					{
			if (queue_opts.marker & QOM_DEFAULT) {
				yyerror("default cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_DEFAULT;
			queue_opts.flags |= PFQS_DEFAULT;
		}
		| QLIMIT NUMBER					{
			if (queue_opts.marker & QOM_QLIMIT) {
				yyerror("qlimit cannot be respecified");
				YYERROR;
			}
			if ($2 < 0 || $2 > 65535) {
				yyerror("qlimit out of range: max 65535");
				YYERROR;
			}
			queue_opts.marker |= QOM_QLIMIT;
			queue_opts.qlimit = $2;
		}
		| FLOWS NUMBER					{
			if (queue_opts.marker & QOM_FLOWS) {
				yyerror("number of flows cannot be respecified");
				YYERROR;
			}
			if ($2 < 1 || $2 > 32767) {
				yyerror("number of flows out of range: "
				    "max 32767");
				YYERROR;
			}
			queue_opts.marker |= QOM_FLOWS;
			queue_opts.flags |= PFQS_FLOWQUEUE;
			queue_opts.flowqueue.flows = $2;
		}
		| QUANTUM NUMBER				{
			if (queue_opts.marker & QOM_QUANTUM) {
				yyerror("quantum cannot be respecified");
				YYERROR;
			}
			if ($2 < 1 || $2 > 65535) {
				yyerror("quantum out of range: max 65535");
				YYERROR;
			}
			queue_opts.marker |= QOM_QUANTUM;
			queue_opts.flowqueue.quantum = $2;
		}
		;

optscs		: /* nada */					{

		}
		| comma MINIMUM scspec				{
			$$.realtime = $3;
		}
		| comma MAXIMUM scspec				{
			$$.upperlimit = $3;
		}
		| comma MINIMUM scspec comma MAXIMUM scspec	{
			$$.realtime = $3;
			$$.upperlimit = $6;
		}
		| comma MAXIMUM scspec comma MINIMUM scspec	{
			$$.realtime = $6;
			$$.upperlimit = $3;
		}
		;

scspec		: bandwidth					{
			$$.m2 = $1;
			$$.d = 0;
			if ($$.m2.bw_percent) {
				yyerror("no bandwidth in %% yet");
				YYERROR;
			}
		}
		| bandwidth BURST bandwidth FOR STRING	{
			u_long	 ul;
			char	*cp;

			ul = strtoul($5, &cp, 10);
			if (cp == NULL || strcmp(cp, "ms")) {
				yyerror("time in scspec must be in ms");
				YYERROR;
			}

			$$.m1 = $3;
			$$.d = ul;
			$$.m2 = $1;

			if ($$.m1.bw_percent || $$.m2.bw_percent) {
				yyerror("no bandwidth in %% yet");
				YYERROR;
			}
		}
		;

bandwidth	: STRING {
			double	 bps;
			char	*cp;

			$$.bw_percent = 0;

			bps = strtod($1, &cp);
			if (cp != NULL) {
				if (strlen(cp) > 1) {
					char *cu = cp + 1;
					if (!strcmp(cu, "Bit") ||
					    !strcmp(cu, "B") ||
					    !strcmp(cu, "bit") ||
					    !strcmp(cu, "b")) {
						*cu = 0;
					}
				}
				if (!strcmp(cp, "b"))
					; /* nothing */
				else if (!strcmp(cp, "K"))
					bps *= 1000;
				else if (!strcmp(cp, "M"))
					bps *= 1000 * 1000;
				else if (!strcmp(cp, "G"))
					bps *= 1000 * 1000 * 1000;
				else if (!strcmp(cp, "%")) {
					if (bps < 0 || bps > 100) {
						yyerror("bandwidth spec "
						    "out of range");
						free($1);
						YYERROR;
					}
					$$.bw_percent = bps;
					bps = 0;
				} else {
					yyerror("unknown unit \"%s\"", cp);
					free($1);
					YYERROR;
				}
			}
			free($1);
			$$.bw_absolute = (u_int32_t)bps;
		}
		| NUMBER {
			if ($1 < 0 || $1 > UINT_MAX) {
				yyerror("bandwidth number too big");
				YYERROR;
			}
			$$.bw_percent = 0;
			$$.bw_absolute = $1;
		}
		;

pfrule		: action dir logquick interface af proto fromto
		    filter_opts
		{
			struct pf_rule		 r;
			struct node_state_opt	*o;
			struct node_proto	*proto;
			int			 srctrack = 0;
			int			 statelock = 0;
			int			 adaptive = 0;
			int			 defaults = 0;

			memset(&r, 0, sizeof(r));
			r.action = $1.b1;
			switch ($1.b2) {
			case PFRULE_RETURNRST:
				r.rule_flag |= PFRULE_RETURNRST;
				r.return_ttl = $1.w;
				break;
			case PFRULE_RETURNICMP:
				r.rule_flag |= PFRULE_RETURNICMP;
				r.return_icmp = $1.w;
				r.return_icmp6 = $1.w2;
				break;
			case PFRULE_RETURN:
				r.rule_flag |= PFRULE_RETURN;
				r.return_icmp = $1.w;
				r.return_icmp6 = $1.w2;
				break;
			}
			r.direction = $2;
			r.log = $3.log;
			r.logif = $3.logif;
			r.quick = $3.quick;
			r.prob = $8.prob;
			r.rtableid = $8.rtableid;

			if ($8.nodf)
				r.scrub_flags |= PFSTATE_NODF;
			if ($8.randomid)
				r.scrub_flags |= PFSTATE_RANDOMID;
			if ($8.minttl)
				r.min_ttl = $8.minttl;
			if ($8.max_mss)
				r.max_mss = $8.max_mss;
			if ($8.marker & FOM_SETTOS) {
				r.scrub_flags |= PFSTATE_SETTOS;
				r.set_tos = $8.settos;
			}
			if ($8.marker & FOM_SCRUB_TCP)
				r.scrub_flags |= PFSTATE_SCRUB_TCP;
			if ($8.marker & FOM_PRIO) {
				if ($8.prio == 0)
					r.prio = PF_PRIO_ZERO;
				else
					r.prio = $8.prio;
			}
			if ($8.marker & FOM_SETPRIO) {
				r.set_prio[0] = $8.set_prio[0];
				r.set_prio[1] = $8.set_prio[1];
				r.scrub_flags |= PFSTATE_SETPRIO;
			}
			if ($8.marker & FOM_ONCE) {
				if (r.action == PF_MATCH) {
					yyerror("can't specify once for "
					    "match rules");
					YYERROR;
				}
				r.rule_flag |= PFRULE_ONCE;
			}
			if ($8.marker & FOM_AFTO)
				r.rule_flag |= PFRULE_AFTO;
			if (($8.marker & FOM_AFTO) && r.direction != PF_IN) {
				yyerror("af-to can only be used with direction in");
				YYERROR;
			}
			if (($8.marker & FOM_AFTO) && $8.route.rt) {
				yyerror("af-to cannot be used together with "
				    "route-to, reply-to, dup-to");
				YYERROR;
			}
			r.af = $5;

			if ($8.tag)
				if (strlcpy(r.tagname, $8.tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $8.match_tag_not;
			if (rule_label(&r, $8.label))
				YYERROR;
			free($8.label);
			r.flags = $8.flags.b1;
			r.flagset = $8.flags.b2;
			if (($8.flags.b1 & $8.flags.b2) != $8.flags.b1) {
				yyerror("flags always false");
				YYERROR;
			}
			if ($8.flags.b1 || $8.flags.b2 || $7.src_os) {
				for (proto = $6; proto != NULL &&
				    proto->proto != IPPROTO_TCP;
				    proto = proto->next)
					;	/* nothing */
				if (proto == NULL && $6 != NULL) {
					if ($8.flags.b1 || $8.flags.b2)
						yyerror(
						    "flags only apply to tcp");
					if ($7.src_os)
						yyerror(
						    "OS fingerprinting only "
						    "apply to tcp");
					YYERROR;
				}
#if 0
				if (($8.flags.b1 & parse_flags("S")) == 0 &&
				    $7.src_os) {
					yyerror("OS fingerprinting requires "
					    "the SYN TCP flag (flags S/SA)");
					YYERROR;
				}
#endif
			}

			r.tos = $8.tos;
			r.keep_state = $8.keep.action;
			o = $8.keep.options;

			/* 'keep state' by default on pass rules. */
			if (!r.keep_state && !r.action &&
			    !($8.marker & FOM_KEEP)) {
				r.keep_state = PF_STATE_NORMAL;
				o = keep_state_defaults;
				defaults = 1;
			}

			while (o) {
				struct node_state_opt	*p = o;

				switch (o->type) {
				case PF_STATE_OPT_MAX:
					if (r.max_states) {
						yyerror("state option 'max' "
						    "multiple definitions");
						YYERROR;
					}
					r.max_states = o->data.max_states;
					break;
				case PF_STATE_OPT_NOSYNC:
					if (r.rule_flag & PFRULE_NOSYNC) {
						yyerror("state option 'sync' "
						    "multiple definitions");
						YYERROR;
					}
					r.rule_flag |= PFRULE_NOSYNC;
					break;
				case PF_STATE_OPT_SRCTRACK:
					if (srctrack) {
						yyerror("state option "
						    "'source-track' "
						    "multiple definitions");
						YYERROR;
					}
					srctrack =  o->data.src_track;
					r.rule_flag |= PFRULE_SRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_STATES:
					if (r.max_src_states) {
						yyerror("state option "
						    "'max-src-states' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_states == 0) {
						yyerror("'max-src-states' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_states =
					    o->data.max_src_states;
					r.rule_flag |= PFRULE_SRCTRACK;
					break;
				case PF_STATE_OPT_OVERLOAD:
					if (r.overload_tblname[0]) {
						yyerror("multiple 'overload' "
						    "table definitions");
						YYERROR;
					}
					if (strlcpy(r.overload_tblname,
					    o->data.overload.tblname,
					    PF_TABLE_NAME_SIZE) >=
					    PF_TABLE_NAME_SIZE) {
						yyerror("state option: "
						    "strlcpy");
						YYERROR;
					}
					r.flush = o->data.overload.flush;
					break;
				case PF_STATE_OPT_MAX_SRC_CONN:
					if (r.max_src_conn) {
						yyerror("state option "
						    "'max-src-conn' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_conn == 0) {
						yyerror("'max-src-conn' "
						    "must be > 0");
						YYERROR;
					}
					r.max_src_conn =
					    o->data.max_src_conn;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_CONN_RATE:
					if (r.max_src_conn_rate.limit) {
						yyerror("state option "
						    "'max-src-conn-rate' "
						    "multiple definitions");
						YYERROR;
					}
					if (!o->data.max_src_conn_rate.limit ||
					    !o->data.max_src_conn_rate.seconds) {
						yyerror("'max-src-conn-rate' "
						    "values must be > 0");
						YYERROR;
					}
					if (o->data.max_src_conn_rate.limit >
					    PF_THRESHOLD_MAX) {
						yyerror("'max-src-conn-rate' "
						    "maximum rate must be < %u",
						    PF_THRESHOLD_MAX);
						YYERROR;
					}
					r.max_src_conn_rate.limit =
					    o->data.max_src_conn_rate.limit;
					r.max_src_conn_rate.seconds =
					    o->data.max_src_conn_rate.seconds;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_NODES:
					if (r.max_src_nodes) {
						yyerror("state option "
						    "'max-src-nodes' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_nodes == 0) {
						yyerror("'max-src-nodes' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_nodes =
					    o->data.max_src_nodes;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_STATELOCK:
					if (statelock) {
						yyerror("state locking option: "
						    "multiple definitions");
						YYERROR;
					}
					statelock = 1;
					r.rule_flag |= o->data.statelock;
					break;
				case PF_STATE_OPT_SLOPPY:
					if (r.rule_flag & PFRULE_STATESLOPPY) {
						yyerror("state sloppy option: "
						    "multiple definitions");
						YYERROR;
					}
					r.rule_flag |= PFRULE_STATESLOPPY;
					break;
				case PF_STATE_OPT_PFLOW:
					if (r.rule_flag & PFRULE_PFLOW) {
						yyerror("state pflow "
						    "option: multiple "
						    "definitions");
						YYERROR;
					}
					r.rule_flag |= PFRULE_PFLOW;
					break;
				case PF_STATE_OPT_TIMEOUT:
					if (o->data.timeout.number ==
					    PFTM_ADAPTIVE_START ||
					    o->data.timeout.number ==
					    PFTM_ADAPTIVE_END)
						adaptive = 1;
					if (r.timeout[o->data.timeout.number]) {
						yyerror("state timeout %s "
						    "multiple definitions",
						    pf_timeouts[o->data.
						    timeout.number].name);
						YYERROR;
					}
					r.timeout[o->data.timeout.number] =
					    o->data.timeout.seconds;
				}
				o = o->next;
				if (!defaults)
					free(p);
			}

			/* 'flags S/SA' by default on stateful rules */
			if (!r.action && !r.flags && !r.flagset &&
			    !$8.fragment && !($8.marker & FOM_FLAGS) &&
			    r.keep_state) {
				r.flags = parse_flags("S");
				r.flagset =  parse_flags("SA");
			}
			if (!adaptive && r.max_states) {
				r.timeout[PFTM_ADAPTIVE_START] =
				    (r.max_states / 10) * 6;
				r.timeout[PFTM_ADAPTIVE_END] =
				    (r.max_states / 10) * 12;
			}
			if (r.rule_flag & PFRULE_SRCTRACK) {
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_nodes) {
					yyerror("'max-src-nodes' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_conn) {
					yyerror("'max-src-conn' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_conn_rate.seconds) {
					yyerror("'max-src-conn-rate' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				if (r.timeout[PFTM_SRC_NODE] <
				    r.max_src_conn_rate.seconds)
					r.timeout[PFTM_SRC_NODE] =
					    r.max_src_conn_rate.seconds;
				r.rule_flag |= PFRULE_SRCTRACK;
				if (srctrack == PF_SRCTRACK_RULE)
					r.rule_flag |= PFRULE_RULESRCTRACK;
			}
			if (r.keep_state && !statelock)
				r.rule_flag |= default_statelock;

			if ($8.fragment)
				r.rule_flag |= PFRULE_FRAGMENT;
			r.allow_opts = $8.allowopts;

			decide_address_family($7.src.host, &r.af);
			decide_address_family($7.dst.host, &r.af);

			if ($8.route.rt) {
				if (!r.direction) {
					yyerror("direction must be explicit "
					    "with rules that specify routing");
					YYERROR;
				}
				r.rt = $8.route.rt;
				r.route.opts = $8.route.pool_opts;
				if ($8.route.key != NULL)
					memcpy(&r.route.key, $8.route.key,
					    sizeof(struct pf_poolhashkey));
			}
			if (r.rt) {
				decide_address_family($8.route.host, &r.af);
				if ((r.route.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($8.route.host->next != NULL ||
				    $8.route.host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($8.route.host->addr)))
					r.route.opts |= PF_POOL_ROUNDROBIN;
				if ($8.route.host->next != NULL) {
					if (!PF_POOL_DYNTYPE(r.route.opts)) {
						yyerror("address pool option "
						    "not supported by type");
						YYERROR;
					}
				}
				/* fake redirspec */
				if (($8.rroute.rdr = calloc(1,
				    sizeof(*$8.rroute.rdr))) == NULL)
					err(1, "$8.rroute.rdr");
				$8.rroute.rdr->host = $8.route.host;
			}
			if ($8.queues.qname != NULL) {
				if (strlcpy(r.qname, $8.queues.qname,
				    sizeof(r.qname)) >= sizeof(r.qname)) {
					yyerror("rule qname too long (max "
					    "%d chars)", sizeof(r.qname)-1);
					YYERROR;
				}
				free($8.queues.qname);
			}
			if ($8.queues.pqname != NULL) {
				if (strlcpy(r.pqname, $8.queues.pqname,
				    sizeof(r.pqname)) >= sizeof(r.pqname)) {
					yyerror("rule pqname too long (max "
					    "%d chars)", sizeof(r.pqname)-1);
					YYERROR;
				}
				free($8.queues.pqname);
			}
			if (expand_divertspec(&r, &$8.divert))
				YYERROR;
			r.divert_packet.port = $8.divert_packet.port;

			expand_rule(&r, 0, $4, &$8.nat, &$8.rdr, &$8.rroute, $6,
			    $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
			    $8.uid, $8.gid, $8.rcv, $8.icmpspec, "");
		}
		;

filter_opts	:	{
				bzero(&filter_opts, sizeof filter_opts);
				filter_opts.rtableid = -1;
			}
		    filter_opts_l
			{ $$ = filter_opts; }
		| /* empty */	{
			bzero(&filter_opts, sizeof filter_opts);
			filter_opts.rtableid = -1;
			$$ = filter_opts;
		}
		;

filter_opts_l	: filter_opts_l filter_opt
		| filter_opt
		;

filter_opt	: USER uids {
			if (filter_opts.uid)
				$2->tail->next = filter_opts.uid;
			filter_opts.uid = $2;
		}
		| GROUP gids {
			if (filter_opts.gid)
				$2->tail->next = filter_opts.gid;
			filter_opts.gid = $2;
		}
		| flags {
			if (filter_opts.marker & FOM_FLAGS) {
				yyerror("flags cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_FLAGS;
			filter_opts.flags.b1 |= $1.b1;
			filter_opts.flags.b2 |= $1.b2;
			filter_opts.flags.w |= $1.w;
			filter_opts.flags.w2 |= $1.w2;
		}
		| icmpspec {
			if (filter_opts.marker & FOM_ICMP) {
				yyerror("icmp-type cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_ICMP;
			filter_opts.icmpspec = $1;
		}
		| PRIO NUMBER {
			if (filter_opts.marker & FOM_PRIO) {
				yyerror("prio cannot be redefined");
				YYERROR;
			}
			if ($2 < 0 || $2 > IFQ_MAXPRIO) {
				yyerror("prio must be 0 - %u", IFQ_MAXPRIO);
				YYERROR;
			}
			filter_opts.marker |= FOM_PRIO;
			filter_opts.prio = $2;
		}
		| TOS tos {
			if (filter_opts.marker & FOM_TOS) {
				yyerror("tos cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_TOS;
			filter_opts.tos = $2;
		}
		| keep {
			if (filter_opts.marker & FOM_KEEP) {
				yyerror("modulate or keep cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_KEEP;
			filter_opts.keep.action = $1.action;
			filter_opts.keep.options = $1.options;
		}
		| FRAGMENT {
			filter_opts.fragment = 1;
		}
		| ALLOWOPTS {
			filter_opts.allowopts = 1;
		}
		| LABEL label	{
			if (filter_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			filter_opts.label = $2;
		}
		| QUEUE qname	{
			if (filter_opts.queues.qname) {
				yyerror("queue cannot be redefined");
				YYERROR;
			}
			filter_opts.queues = $2;
		}
		| TAG string				{
			filter_opts.tag = $2;
		}
		| not TAGGED string			{
			filter_opts.match_tag = $3;
			filter_opts.match_tag_not = $1;
		}
		| PROBABILITY probability		{
			double	p;

			p = floor($2 * UINT_MAX + 0.5);
			if (p < 0.0 || p > UINT_MAX) {
				yyerror("invalid probability: %g%%", $2 * 100);
				YYERROR;
			}
			filter_opts.prob = (u_int32_t)p;
			if (filter_opts.prob == 0)
				filter_opts.prob = 1;
		}
		| RTABLE NUMBER				{
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rtable id");
				YYERROR;
			}
			filter_opts.rtableid = $2;
		}
		| DIVERTTO STRING PORT portplain {
			if ((filter_opts.divert.addr = host($2, pf->opts)) == NULL) {
				yyerror("could not parse divert address: %s",
				    $2);
				free($2);
				YYERROR;
			}
			free($2);
			filter_opts.divert.port = $4.a;
			if (!filter_opts.divert.port) {
				yyerror("invalid divert port: %u", ntohs($4.a));
				YYERROR;
			}
		}
		| DIVERTREPLY {
			filter_opts.divert.port = 1;	/* some random value */
		}
		| DIVERTPACKET PORT number {
			/*
			 * If IP reassembly was not turned off, also
			 * forcibly enable TCP reassembly by default.
			 */
			if (pf->reassemble & PF_REASS_ENABLED)
				filter_opts.marker |= FOM_SCRUB_TCP;

			if ($3 < 1 || $3 > 65535) {
				yyerror("invalid divert port");
				YYERROR;
			}

			filter_opts.divert_packet.port = htons($3);
		}
		| SCRUB '(' scrub_opts ')' {
			filter_opts.nodf = $3.nodf;
			filter_opts.minttl = $3.minttl;
			filter_opts.randomid = $3.randomid;
			filter_opts.max_mss = $3.maxmss;
			if ($3.reassemble_tcp)
				filter_opts.marker |= FOM_SCRUB_TCP;
			filter_opts.marker |= $3.marker;
		}
		| NATTO redirpool pool_opts {
			if (filter_opts.nat.rdr) {
				yyerror("cannot respecify nat-to/binat-to");
				YYERROR;
			}
			filter_opts.nat.rdr = $2;
			memcpy(&filter_opts.nat.pool_opts, &$3,
			    sizeof(filter_opts.nat.pool_opts));
		}
		| AFTO af FROM redirpool pool_opts {
			if (filter_opts.nat.rdr) {
				yyerror("cannot respecify af-to");
				YYERROR;
			}
			if ($2 == 0) {
				yyerror("no target address family specified");
				YYERROR;
			}
			filter_opts.nat.af = $2;
			filter_opts.nat.rdr = $4;
			memcpy(&filter_opts.nat.pool_opts, &$5,
			    sizeof(filter_opts.nat.pool_opts));
			filter_opts.rdr.rdr =
			    calloc(1, sizeof(struct redirection));
			bzero(&filter_opts.rdr.pool_opts,
			    sizeof(filter_opts.rdr.pool_opts));
			filter_opts.marker |= FOM_AFTO;
		}
		| AFTO af FROM redirpool pool_opts TO redirpool pool_opts {
			if (filter_opts.nat.rdr) {
				yyerror("cannot respecify af-to");
				YYERROR;
			}
			if ($2 == 0) {
				yyerror("no address family specified");
				YYERROR;
			}
			if (($4->host->af && $4->host->af != $2) ||
			    ($7->host->af && $7->host->af != $2)) {
				yyerror("af-to addresses must be in the "
				    "target address family");
				YYERROR;
			}
			filter_opts.nat.af = $2;
			filter_opts.nat.rdr = $4;
			memcpy(&filter_opts.nat.pool_opts, &$5,
			    sizeof(filter_opts.nat.pool_opts));
			filter_opts.rdr.af = $2;
			filter_opts.rdr.rdr = $7;
			memcpy(&filter_opts.nat.pool_opts, &$8,
			    sizeof(filter_opts.nat.pool_opts));
			filter_opts.marker |= FOM_AFTO;
		}
		| RDRTO redirpool pool_opts {
			if (filter_opts.rdr.rdr) {
				yyerror("cannot respecify rdr-to");
				YYERROR;
			}
			filter_opts.rdr.rdr = $2;
			memcpy(&filter_opts.rdr.pool_opts, &$3,
			    sizeof(filter_opts.rdr.pool_opts));
		}
		| BINATTO redirpool pool_opts {
			if (filter_opts.nat.rdr) {
				yyerror("cannot respecify nat-to/binat-to");
				YYERROR;
			}
			filter_opts.nat.rdr = $2;
			filter_opts.nat.binat = 1;
			memcpy(&filter_opts.nat.pool_opts, &$3,
			    sizeof(filter_opts.nat.pool_opts));
			filter_opts.nat.pool_opts.staticport = 1;
		}
		| ROUTETO routespec pool_opts {
			filter_opts.route.host = $2;
			filter_opts.route.rt = PF_ROUTETO;
			filter_opts.route.pool_opts = $3.type | $3.opts;
			memcpy(&filter_opts.rroute.pool_opts, &$3,
			    sizeof(filter_opts.rroute.pool_opts));
			if ($3.key != NULL)
				filter_opts.route.key = $3.key;
		}
		| REPLYTO routespec pool_opts {
			filter_opts.route.host = $2;
			filter_opts.route.rt = PF_REPLYTO;
			filter_opts.route.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				filter_opts.route.key = $3.key;
		}
		| DUPTO routespec pool_opts {
			filter_opts.route.host = $2;
			filter_opts.route.rt = PF_DUPTO;
			filter_opts.route.pool_opts = $3.type | $3.opts;
			memcpy(&filter_opts.rroute.pool_opts, &$3,
			    sizeof(filter_opts.rroute.pool_opts));
			if ($3.key != NULL)
				filter_opts.route.key = $3.key;
		}
		| not RECEIVEDON if_item {
			if (filter_opts.rcv) {
				yyerror("cannot respecify received-on");
				YYERROR;
			}
			filter_opts.rcv = $3;
			filter_opts.rcv->not = $1;
		}
		| ONCE {
			filter_opts.marker |= FOM_ONCE;
		}
		| filter_sets
		;

filter_sets	: SET '(' filter_sets_l ')'	{ $$ = filter_opts; }
		| SET filter_set		{ $$ = filter_opts; }
		;

filter_sets_l	: filter_sets_l comma filter_set
		| filter_set
		;

filter_set	: prio {
			if (filter_opts.marker & FOM_SETPRIO) {
				yyerror("prio cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_SETPRIO;
			filter_opts.set_prio[0] = $1.b1;
			filter_opts.set_prio[1] = $1.b2;
		}
		| QUEUE qname	{
			if (filter_opts.queues.qname) {
				yyerror("queue cannot be redefined");
				YYERROR;
			}
			filter_opts.queues = $2;
		}
		| TOS tos {
			if (filter_opts.marker & FOM_SETTOS) {
				yyerror("tos cannot be respecified");
				YYERROR;
			}
			filter_opts.marker |= FOM_SETTOS;
			filter_opts.settos = $2;
		}
		;

prio		: PRIO NUMBER {
			if ($2 < 0 || $2 > IFQ_MAXPRIO) {
				yyerror("prio must be 0 - %u", IFQ_MAXPRIO);
				YYERROR;
			}
			$$.b1 = $$.b2 = $2;
		}
		| PRIO '(' NUMBER comma NUMBER ')' {
			if ($3 < 0 || $3 > IFQ_MAXPRIO ||
			    $5 < 0 || $5 > IFQ_MAXPRIO) {
				yyerror("prio must be 0 - %u", IFQ_MAXPRIO);
				YYERROR;
			}
			$$.b1 = $3;
			$$.b2 = $5;
		}
		;

probability	: STRING				{
			char	*e;
			double	 p = strtod($1, &e);

			if (*e == '%') {
				p *= 0.01;
				e++;
			}
			if (*e) {
				yyerror("invalid probability: %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = p;
		}
		| NUMBER				{
			$$ = (double)$1;
		}
		;


action		: PASS			{ $$.b1 = PF_PASS; $$.b2 = $$.w = 0; }
		| MATCH			{ $$.b1 = PF_MATCH; $$.b2 = $$.w = 0; }
		| BLOCK blockspec	{ $$ = $2; $$.b1 = PF_DROP; }
		;

blockspec	: /* empty */		{
			$$.b2 = blockpolicy;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| DROP			{
			$$.b2 = PFRULE_DROP;
			$$.w = 0;
			$$.w2 = 0;
		}
		| RETURNRST		{
			$$.b2 = PFRULE_RETURNRST;
			$$.w = 0;
			$$.w2 = 0;
		}
		| RETURNRST '(' TTL NUMBER ')'	{
			if ($4 < 0 || $4 > 255) {
				yyerror("illegal ttl value %d", $4);
				YYERROR;
			}
			$$.b2 = PFRULE_RETURNRST;
			$$.w = $4;
			$$.w2 = 0;
		}
		| RETURNICMP		{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP6		{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP '(' reticmpspec ')'	{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = $3;
			$$.w2 = returnicmpdefault;
		}
		| RETURNICMP6 '(' reticmp6spec ')'	{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = $3;
		}
		| RETURNICMP '(' reticmpspec comma reticmp6spec ')' {
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = $3;
			$$.w2 = $5;
		}
		| RETURN {
			$$.b2 = PFRULE_RETURN;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		;

reticmpspec	: STRING			{
			if (!($$ = parseicmpspec($1, AF_INET))) {
				free($1);
				YYERROR;
			}
			free($1);
		}
		| NUMBER			{
			u_int8_t		icmptype;

			if ($1 < 0 || $1 > 255) {
				yyerror("invalid icmp code %lu", $1);
				YYERROR;
			}
			icmptype = returnicmpdefault >> 8;
			$$ = (icmptype << 8 | $1);
		}
		;

reticmp6spec	: STRING			{
			if (!($$ = parseicmpspec($1, AF_INET6))) {
				free($1);
				YYERROR;
			}
			free($1);
		}
		| NUMBER			{
			u_int8_t		icmptype;

			if ($1 < 0 || $1 > 255) {
				yyerror("invalid icmp code %lu", $1);
				YYERROR;
			}
			icmptype = returnicmp6default >> 8;
			$$ = (icmptype << 8 | $1);
		}
		;

dir		: /* empty */			{ $$ = PF_INOUT; }
		| IN				{ $$ = PF_IN; }
		| OUT				{ $$ = PF_OUT; }
		;

quick		: /* empty */			{ $$.quick = 0; }
		| QUICK				{ $$.quick = 1; }
		;

logquick	: /* empty */	{ $$.log = 0; $$.quick = 0; $$.logif = 0; }
		| log		{ $$ = $1; $$.quick = 0; }
		| QUICK		{ $$.quick = 1; $$.log = 0; $$.logif = 0; }
		| log QUICK	{ $$ = $1; $$.quick = 1; }
		| QUICK log	{ $$ = $2; $$.quick = 1; }
		;

log		: LOG			{ $$.log = PF_LOG; $$.logif = 0; }
		| LOG '(' logopts ')'	{
			$$.log = PF_LOG | $3.log;
			$$.logif = $3.logif;
		}
		;

logopts		: logopt			{ $$ = $1; }
		| logopts comma logopt		{
			$$.log = $1.log | $3.log;
			$$.logif = $3.logif;
			if ($$.logif == 0)
				$$.logif = $1.logif;
		}
		;

logopt		: ALL		{ $$.log = PF_LOG_ALL; $$.logif = 0; }
		| MATCHES	{ $$.log = PF_LOG_MATCHES; $$.logif = 0; }
		| USER		{ $$.log = PF_LOG_SOCKET_LOOKUP; $$.logif = 0; }
		| GROUP		{ $$.log = PF_LOG_SOCKET_LOOKUP; $$.logif = 0; }
		| TO string	{
			const char	*errstr;
			u_int		 i;

			$$.log = 0;
			if (strncmp($2, "pflog", 5)) {
				yyerror("%s: should be a pflog interface", $2);
				free($2);
				YYERROR;
			}
			i = strtonum($2 + 5, 0, 255, &errstr);
			if (errstr) {
				yyerror("%s: %s", $2, errstr);
				free($2);
				YYERROR;
			}
			free($2);
			$$.logif = i;
		}
		;

interface	: /* empty */			{ $$ = NULL; }
		| ON if_item_not		{ $$ = $2; }
		| ON '{' optnl if_list '}'	{ $$ = $4; }
		;

if_list		: if_item_not optnl		{ $$ = $1; }
		| if_list comma if_item_not optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

if_item_not	: not if_item			{ $$ = $2; $$->not = $1; }
		;

if_item		: STRING			{
			struct node_host	*n;

			$$ = calloc(1, sizeof(struct node_if));
			if ($$ == NULL)
				err(1, "if_item: calloc");
			if (strlcpy($$->ifname, $1, sizeof($$->ifname)) >=
			    sizeof($$->ifname)) {
				free($1);
				free($$);
				yyerror("interface name too long");
				YYERROR;
			}

			if ((n = ifa_exists($1)) != NULL)
				$$->ifa_flags = n->ifa_flags;

			free($1);
			$$->not = 0;
			$$->next = NULL;
			$$->tail = $$;
		}
		| ANY				{
			$$ = calloc(1, sizeof(struct node_if));
			if ($$ == NULL)
				err(1, "if_item: calloc");
			strlcpy($$->ifname, "any", sizeof($$->ifname));
			$$->not = 0;
			$$->next = NULL;
			$$->tail = $$;
		}
		| RDOMAIN NUMBER		{
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("rdomain outside range");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_if));
			if ($$ == NULL)
				err(1, "if_item: calloc");
			$$->not = 0;
			$$->use_rdomain = 1;
			$$->rdomain = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

af		: /* empty */			{ $$ = 0; }
		| INET				{ $$ = AF_INET; }
		| INET6				{ $$ = AF_INET6; }
		;

proto		: /* empty */				{ $$ = NULL; }
		| PROTO proto_item			{ $$ = $2; }
		| PROTO '{' optnl proto_list '}'	{ $$ = $4; }
		;

proto_list	: proto_item optnl		{ $$ = $1; }
		| proto_list comma proto_item optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

proto_item	: protoval			{
			u_int8_t	pr;

			pr = (u_int8_t)$1;
			if (pr == 0) {
				yyerror("proto 0 cannot be used");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_proto));
			if ($$ == NULL)
				err(1, "proto_item: calloc");
			$$->proto = pr;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

protoval	: STRING			{
			struct protoent	*p;

			p = getprotobyname($1);
			if (p == NULL) {
				yyerror("unknown protocol %s", $1);
				free($1);
				YYERROR;
			}
			$$ = p->p_proto;
			free($1);
		}
		| NUMBER			{
			if ($1 < 0 || $1 > 255) {
				yyerror("protocol outside range");
				YYERROR;
			}
		}
		;

fromto		: ALL				{
			$$.src.host = NULL;
			$$.src.port = NULL;
			$$.dst.host = NULL;
			$$.dst.port = NULL;
			$$.src_os = NULL;
		}
		| from os to			{
			$$.src = $1;
			$$.src_os = $2;
			$$.dst = $3;
		}
		;

os		: /* empty */			{ $$ = NULL; }
		| OS xos			{ $$ = $2; }
		| OS '{' optnl os_list '}'	{ $$ = $4; }
		;

xos		: STRING {
			$$ = calloc(1, sizeof(struct node_os));
			if ($$ == NULL)
				err(1, "os: calloc");
			$$->os = $1;
			$$->tail = $$;
		}
		;

os_list		: xos optnl 			{ $$ = $1; }
		| os_list comma xos optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

from		: /* empty */			{
			$$.host = NULL;
			$$.port = NULL;
		}
		| FROM ipportspec		{
			$$ = $2;
		}
		;

to		: /* empty */			{
			$$.host = NULL;
			$$.port = NULL;
		}
		| TO ipportspec		{
			if (disallow_urpf_failed($2.host, "\"urpf-failed\" is "
			    "not permitted in a destination address"))
				YYERROR;
			$$ = $2;
		}
		;

ipportspec	: ipspec			{
			$$.host = $1;
			$$.port = NULL;
		}
		| ipspec PORT portspec		{
			$$.host = $1;
			$$.port = $3;
		}
		| PORT portspec			{
			$$.host = NULL;
			$$.port = $2;
		}
		;

optnl		: '\n' optnl
		| /* empty */
		;

ipspec		: ANY				{ $$ = NULL; }
		| xhost				{ $$ = $1; }
		| '{' optnl host_list '}'	{ $$ = $3; }
		;


host_list	: ipspec optnl			{ $$ = $1; }
		| host_list comma ipspec optnl	{
			if ($1 == NULL) {
				freehostlist($3);
				$$ = $1;
			} else if ($3 == NULL) {
				freehostlist($1);
				$$ = $3;
			} else {
				$1->tail->next = $3;
				$1->tail = $3->tail;
				$$ = $1;
			}
		}
		;

xhost		: not host			{
			struct node_host	*n;

			for (n = $2; n != NULL; n = n->next)
				n->not = $1;
			$$ = $2;
		}
		| not NOROUTE			{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "xhost: calloc");
			$$->addr.type = PF_ADDR_NOROUTE;
			$$->next = NULL;
			$$->not = $1;
			$$->tail = $$;
		}
		| not URPFFAILED		{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "xhost: calloc");
			$$->addr.type = PF_ADDR_URPFFAILED;
			$$->next = NULL;
			$$->not = $1;
			$$->tail = $$;
		}
		;
		
optweight	: WEIGHT NUMBER			{
			if ($2 < 1 || $2 > USHRT_MAX) {
				yyerror("weight out of range");
				YYERROR;
			}
			$$ = $2;
		}
		| /* empty */ { $$ = 0; }
		;

host		: STRING			{
			if (($$ = host($1, pf->opts)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free($1);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($1);

		}
		| STRING '-' STRING		{
			struct node_host *b, *e;

			if ((b = host($1, pf->opts)) == NULL ||
			    (e = host($3, pf->opts)) == NULL) {
				free($1);
				free($3);
				yyerror("could not parse host specification");
				YYERROR;
			}
			if (b->af != e->af ||
			    b->addr.type != PF_ADDR_ADDRMASK ||
			    e->addr.type != PF_ADDR_ADDRMASK ||
			    unmask(&b->addr.v.a.mask, b->af) !=
			    (b->af == AF_INET ? 32 : 128) ||
			    unmask(&e->addr.v.a.mask, e->af) !=
			    (e->af == AF_INET ? 32 : 128) ||
			    b->next != NULL || b->not ||
			    e->next != NULL || e->not) {
				free(b);
				free(e);
				free($1);
				free($3);
				yyerror("invalid address range");
				YYERROR;
			}
			memcpy(&b->addr.v.a.mask, &e->addr.v.a.addr,
			    sizeof(b->addr.v.a.mask));
			b->addr.type = PF_ADDR_RANGE;
			$$ = b;
			free(e);
			free($1);
			free($3);
		}
		| STRING '/' NUMBER		{
			char	*buf;

			if (asprintf(&buf, "%s/%lld", $1, $3) == -1)
				err(1, "host: asprintf");
			free($1);
			if (($$ = host(buf, pf->opts)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		| NUMBER '/' NUMBER		{
			char	*buf;

			/* ie. for 10/8 parsing */
			if (asprintf(&buf, "%lld/%lld", $1, $3) == -1)
				err(1, "host: asprintf");
			if (($$ = host(buf, pf->opts)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		| dynaddr
		| dynaddr '/' NUMBER		{
			struct node_host	*n;

			if ($3 < 0 || $3 > 128) {
				yyerror("bit number too big");
				YYERROR;
			}
			$$ = $1;
			for (n = $1; n != NULL; n = n->next)
				set_ipmask(n, $3);
		}
		| '<' STRING '>'	{
			if (strlen($2) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name '%s' too long", $2);
				free($2);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "host: calloc");
			$$->addr.type = PF_ADDR_TABLE;
			if (strlcpy($$->addr.v.tblname, $2,
			    sizeof($$->addr.v.tblname)) >=
			    sizeof($$->addr.v.tblname))
				errx(1, "host: strlcpy");
			free($2);
			$$->next = NULL;
			$$->tail = $$;
		}
		| ROUTE	STRING		{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL) {
				free($2);
				err(1, "host: calloc");
			}
			$$->addr.type = PF_ADDR_RTLABEL;
			if (strlcpy($$->addr.v.rtlabelname, $2,
			    sizeof($$->addr.v.rtlabelname)) >=
			    sizeof($$->addr.v.rtlabelname)) {
				yyerror("route label too long, max %u chars",
				    sizeof($$->addr.v.rtlabelname) - 1);
				free($2);
				free($$);
				YYERROR;
			}
			$$->next = NULL;
			$$->tail = $$;
			free($2);
		}
		;

number		: NUMBER
		| STRING		{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
				free($1);
				YYERROR;
			} else
				$$ = ulval;
			free($1);
		}
		;

dynaddr		: '(' STRING ')'		{
			int	 flags = 0;
			char	*p, *op;

			op = $2;
			if (!isalpha((unsigned char)op[0])) {
				yyerror("invalid interface name '%s'", op);
				free(op);
				YYERROR;
			}
			while ((p = strrchr($2, ':')) != NULL) {
				if (!strcmp(p+1, "network"))
					flags |= PFI_AFLAG_NETWORK;
				else if (!strcmp(p+1, "broadcast"))
					flags |= PFI_AFLAG_BROADCAST;
				else if (!strcmp(p+1, "peer"))
					flags |= PFI_AFLAG_PEER;
				else if (!strcmp(p+1, "0"))
					flags |= PFI_AFLAG_NOALIAS;
				else {
					yyerror("interface %s has bad modifier",
					    $2);
					free(op);
					YYERROR;
				}
				*p = '\0';
			}
			if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) {
				free(op);
				yyerror("illegal combination of "
				    "interface modifiers");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "address: calloc");
			$$->af = 0;
			set_ipmask($$, 128);
			$$->addr.type = PF_ADDR_DYNIFTL;
			$$->addr.iflags = flags;
			if (strlcpy($$->addr.v.ifname, $2,
			    sizeof($$->addr.v.ifname)) >=
			    sizeof($$->addr.v.ifname)) {
				free(op);
				free($$);
				yyerror("interface name too long");
				YYERROR;
			}
			free(op);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

portspec	: port_item			{ $$ = $1; }
		| '{' optnl port_list '}'	{ $$ = $3; }
		;

port_list	: port_item optnl		{ $$ = $1; }
		| port_list comma port_item optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

port_item	: portrange			{
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $1.a;
			$$->port[1] = $1.b;
			if ($1.t)
				$$->op = PF_OP_RRG;
			else
				$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop portrange	{
			if ($2.t) {
				yyerror("':' cannot be used with an other "
				    "port operator");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $2.a;
			$$->port[1] = $2.b;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| portrange PORTBINARY portrange	{
			if ($1.t || $3.t) {
				yyerror("':' cannot be used with an other "
				    "port operator");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $1.a;
			$$->port[1] = $3.a;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

portplain	: numberstring			{
			if (parseport($1, &$$, 0) == -1) {
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

portrange	: numberstring			{
			if (parseport($1, &$$, PPORT_RANGE) == -1) {
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

uids		: uid_item			{ $$ = $1; }
		| '{' optnl uid_list '}'	{ $$ = $3; }
		;

uid_list	: uid_item optnl		{ $$ = $1; }
		| uid_list comma uid_item optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

uid_item	: uid				{
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $1;
			$$->uid[1] = $1;
			$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop uid			{
			if ($2 == UID_MAX && $1 != PF_OP_EQ && $1 != PF_OP_NE) {
				yyerror("user unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $2;
			$$->uid[1] = $2;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| uid PORTBINARY uid		{
			if ($1 == UID_MAX || $3 == UID_MAX) {
				yyerror("user unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $1;
			$$->uid[1] = $3;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

uid		: STRING			{
			if (!strcmp($1, "unknown"))
				$$ = UID_MAX;
			else {
				struct passwd	*pw;

				if ((pw = getpwnam($1)) == NULL) {
					yyerror("unknown user %s", $1);
					free($1);
					YYERROR;
				}
				$$ = pw->pw_uid;
			}
			free($1);
		}
		| NUMBER			{
			if ($1 < 0 || $1 >= UID_MAX) {
				yyerror("illegal uid value %lu", $1);
				YYERROR;
			}
			$$ = $1;
		}
		;

gids		: gid_item			{ $$ = $1; }
		| '{' optnl gid_list '}'	{ $$ = $3; }
		;

gid_list	: gid_item optnl		{ $$ = $1; }
		| gid_list comma gid_item optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

gid_item	: gid				{
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $1;
			$$->gid[1] = $1;
			$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop gid			{
			if ($2 == GID_MAX && $1 != PF_OP_EQ && $1 != PF_OP_NE) {
				yyerror("group unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $2;
			$$->gid[1] = $2;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| gid PORTBINARY gid		{
			if ($1 == GID_MAX || $3 == GID_MAX) {
				yyerror("group unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $1;
			$$->gid[1] = $3;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

gid		: STRING			{
			if (!strcmp($1, "unknown"))
				$$ = GID_MAX;
			else {
				struct group	*grp;

				if ((grp = getgrnam($1)) == NULL) {
					yyerror("unknown group %s", $1);
					free($1);
					YYERROR;
				}
				$$ = grp->gr_gid;
			}
			free($1);
		}
		| NUMBER			{
			if ($1 < 0 || $1 >= GID_MAX) {
				yyerror("illegal gid value %lu", $1);
				YYERROR;
			}
			$$ = $1;
		}
		;

flag		: STRING			{
			int	f;

			if ((f = parse_flags($1)) < 0) {
				yyerror("bad flags %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$.b1 = f;
		}
		;

flags		: FLAGS flag '/' flag	{ $$.b1 = $2.b1; $$.b2 = $4.b1; }
		| FLAGS '/' flag	{ $$.b1 = 0; $$.b2 = $3.b1; }
		| FLAGS ANY		{ $$.b1 = 0; $$.b2 = 0; }
		;

icmpspec	: ICMPTYPE icmp_item			{ $$ = $2; }
		| ICMPTYPE '{' optnl icmp_list '}'	{ $$ = $4; }
		| ICMP6TYPE icmp6_item			{ $$ = $2; }
		| ICMP6TYPE '{' optnl icmp6_list '}'	{ $$ = $4; }
		;

icmp_list	: icmp_item optnl		{ $$ = $1; }
		| icmp_list comma icmp_item optnl {
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

icmp6_list	: icmp6_item optnl		{ $$ = $1; }
		| icmp6_list comma icmp6_item optnl {
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

icmp_item	: icmptype		{
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = 0;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmptype CODE STRING	{
			const struct icmpcodeent	*p;

			if ((p = geticmpcodebyname($1-1, $3, AF_INET)) == NULL) {
				yyerror("unknown icmp-code %s", $3);
				free($3);
				YYERROR;
			}

			free($3);
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = p->code + 1;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmptype CODE NUMBER	{
			if ($3 < 0 || $3 > 255) {
				yyerror("illegal icmp-code %lu", $3);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = $3 + 1;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

icmp6_item	: icmp6type		{
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = 0;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmp6type CODE STRING	{
			const struct icmpcodeent	*p;

			if ((p = geticmpcodebyname($1-1, $3, AF_INET6)) == NULL) {
				yyerror("unknown icmp6-code %s", $3);
				free($3);
				YYERROR;
			}
			free($3);

			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = p->code + 1;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmp6type CODE NUMBER	{
			if ($3 < 0 || $3 > 255) {
				yyerror("illegal icmp-code %lu", $3);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = $3 + 1;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

icmptype	: STRING			{
			const struct icmptypeent	*p;

			if ((p = geticmptypebyname($1, AF_INET)) == NULL) {
				yyerror("unknown icmp-type %s", $1);
				free($1);
				YYERROR;
			}
			$$ = p->type + 1;
			free($1);
		}
		| NUMBER			{
			if ($1 < 0 || $1 > 255) {
				yyerror("illegal icmp-type %lu", $1);
				YYERROR;
			}
			$$ = $1 + 1;
		}
		;

icmp6type	: STRING			{
			const struct icmptypeent	*p;

			if ((p = geticmptypebyname($1, AF_INET6)) ==
			    NULL) {
				yyerror("unknown icmp6-type %s", $1);
				free($1);
				YYERROR;
			}
			$$ = p->type + 1;
			free($1);
		}
		| NUMBER			{
			if ($1 < 0 || $1 > 255) {
				yyerror("illegal icmp6-type %lu", $1);
				YYERROR;
			}
			$$ = $1 + 1;
		}
		;

tos	: STRING			{
			int val;
			char *end;

			if (map_tos($1, &val))
				$$ = val;
			else if ($1[0] == '0' && $1[1] == 'x') {
				errno = 0;
				$$ = strtoul($1, &end, 16);
				if (errno || *end != '\0')
					$$ = 256;
			} else
				$$ = 256;		/* flag bad argument */
			if ($$ < 0 || $$ > 255) {
				yyerror("illegal tos value %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		| NUMBER			{
			$$ = $1;
			if ($$ < 0 || $$ > 255) {
				yyerror("illegal tos value %lld", $1);
				YYERROR;
			}
		}
		;

sourcetrack	: /* empty */		{ $$ = PF_SRCTRACK; }
		| GLOBAL		{ $$ = PF_SRCTRACK_GLOBAL; }
		| RULE			{ $$ = PF_SRCTRACK_RULE; }
		;

statelock	: IFBOUND {
			$$ = PFRULE_IFBOUND;
		}
		| FLOATING {
			$$ = 0;
		}
		;

keep		: NO STATE			{
			$$.action = 0;
			$$.options = NULL;
		}
		| KEEP STATE state_opt_spec	{
			$$.action = PF_STATE_NORMAL;
			$$.options = $3;
		}
		| MODULATE STATE state_opt_spec {
			$$.action = PF_STATE_MODULATE;
			$$.options = $3;
		}
		| SYNPROXY STATE state_opt_spec {
			$$.action = PF_STATE_SYNPROXY;
			$$.options = $3;
		}
		;

flush		: /* empty */			{ $$ = 0; }
		| FLUSH				{ $$ = PF_FLUSH; }
		| FLUSH GLOBAL			{
			$$ = PF_FLUSH | PF_FLUSH_GLOBAL;
		}
		;

state_opt_spec	: '(' state_opt_list ')'	{ $$ = $2; }
		| /* empty */			{ $$ = NULL; }
		;

state_opt_list	: state_opt_item		{ $$ = $1; }
		| state_opt_list comma state_opt_item {
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

state_opt_item	: MAXIMUM NUMBER		{
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX;
			$$->data.max_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| NOSYNC				{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_NOSYNC;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCSTATES NUMBER			{
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_STATES;
			$$->data.max_src_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCCONN NUMBER			{
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_CONN;
			$$->data.max_src_conn = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCCONNRATE NUMBER '/' NUMBER	{
			if ($2 < 0 || $2 > UINT_MAX ||
			    $4 < 0 || $4 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_CONN_RATE;
			$$->data.max_src_conn_rate.limit = $2;
			$$->data.max_src_conn_rate.seconds = $4;
			$$->next = NULL;
			$$->tail = $$;
		}
		| OVERLOAD '<' STRING '>' flush		{
			if (strlen($3) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name '%s' too long", $3);
				free($3);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			if (strlcpy($$->data.overload.tblname, $3,
			    PF_TABLE_NAME_SIZE) >= PF_TABLE_NAME_SIZE)
				errx(1, "state_opt_item: strlcpy");
			free($3);
			$$->type = PF_STATE_OPT_OVERLOAD;
			$$->data.overload.flush = $5;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCNODES NUMBER			{
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_NODES;
			$$->data.max_src_nodes = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| SOURCETRACK sourcetrack {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_SRCTRACK;
			$$->data.src_track = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| statelock {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_STATELOCK;
			$$->data.statelock = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| SLOPPY {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_SLOPPY;
			$$->next = NULL;
			$$->tail = $$;
		}
		| PFLOW {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_PFLOW;
			$$->next = NULL;
			$$->tail = $$;
		}
		| STRING NUMBER			{
			int	i;

			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			for (i = 0; pf_timeouts[i].name &&
			    strcmp(pf_timeouts[i].name, $1); ++i)
				;	/* nothing */
			if (!pf_timeouts[i].name) {
				yyerror("illegal timeout name %s", $1);
				free($1);
				YYERROR;
			}
			if (strchr(pf_timeouts[i].name, '.') == NULL) {
				yyerror("illegal state timeout %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_TIMEOUT;
			$$->data.timeout.number = pf_timeouts[i].timeout;
			$$->data.timeout.seconds = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

label		: STRING			{
			$$ = $1;
		}
		;

qname		: STRING				{
			struct pfctl_qsitem *qsi;

			if ((qsi = pfctl_find_queue($1, &qspecs)) == NULL) {
				yyerror("queue %s is not defined", $1);
				YYERROR;
			}
			$$.qname = $1;
			$$.pqname = NULL;
		}
		| '(' STRING ')'			{
			struct pfctl_qsitem *qsi;

			if ((qsi = pfctl_find_queue($2, &qspecs)) == NULL) {
				yyerror("queue %s is not defined", $2);
				YYERROR;
			}
			$$.qname = $2;
			$$.pqname = NULL;
		}
		| '(' STRING comma STRING ')'	{
			struct pfctl_qsitem *qsi, *pqsi;

			if ((qsi = pfctl_find_queue($2, &qspecs)) == NULL) {
				yyerror("queue %s is not defined", $2);
				YYERROR;
			}
			if ((pqsi = pfctl_find_queue($4, &qspecs)) == NULL) {
				yyerror("queue %s is not defined", $4);
				YYERROR;
			}
			$$.qname = $2;
			$$.pqname = $4;
		}
		;

portstar	: numberstring			{
			if (parseport($1, &$$, PPORT_RANGE|PPORT_STAR) == -1) {
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

redirspec	: host optweight		{ 
			if ($2 > 0) {
				struct node_host	*n;
				for (n = $1; n != NULL; n = n->next)
					n->weight = $2;
			}
			$$ = $1;
		}
		| '{' optnl redir_host_list '}'	{ $$ = $3; }
		;

redir_host_list	: host optweight optnl			{
			if ($1->addr.type != PF_ADDR_ADDRMASK) {
				free($1);
				yyerror("only addresses can be listed for "
				    "redirection pools ");
				YYERROR;
			}
			if ($2 > 0) {
				struct node_host	*n;
				for (n = $1; n != NULL; n = n->next)
					n->weight = $2;
			}
			$$ = $1;
		}
		| redir_host_list comma host optweight optnl {
			$1->tail->next = $3;
			$1->tail = $3->tail;
			if ($4 > 0) {
				struct node_host	*n;
				for (n = $3; n != NULL; n = n->next)
					n->weight = $4;
			}
			$$ = $1;
		}
		;

redirpool	: redirspec		{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $1;
			$$->rport.a = $$->rport.b = $$->rport.t = 0;
		}
		| redirspec PORT portstar	{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $1;
			$$->rport = $3;
		}
		;

hashkey		: /* empty */
		{
			$$ = calloc(1, sizeof(struct pf_poolhashkey));
			if ($$ == NULL)
				err(1, "hashkey: calloc");
			$$->key32[0] = arc4random();
			$$->key32[1] = arc4random();
			$$->key32[2] = arc4random();
			$$->key32[3] = arc4random();
		}
		| string
		{
			if (!strncmp($1, "0x", 2)) {
				if (strlen($1) != 34) {
					free($1);
					yyerror("hex key must be 128 bits "
						"(32 hex digits) long");
					YYERROR;
				}
				$$ = calloc(1, sizeof(struct pf_poolhashkey));
				if ($$ == NULL)
					err(1, "hashkey: calloc");

				if (sscanf($1, "0x%8x%8x%8x%8x",
				    &$$->key32[0], &$$->key32[1],
				    &$$->key32[2], &$$->key32[3]) != 4) {
					free($$);
					free($1);
					yyerror("invalid hex key");
					YYERROR;
				}
			} else {
				MD5_CTX	context;

				$$ = calloc(1, sizeof(struct pf_poolhashkey));
				if ($$ == NULL)
					err(1, "hashkey: calloc");
				MD5Init(&context);
				MD5Update(&context, (unsigned char *)$1,
				    strlen($1));
				MD5Final((unsigned char *)$$, &context);
				HTONL($$->key32[0]);
				HTONL($$->key32[1]);
				HTONL($$->key32[2]);
				HTONL($$->key32[3]);
			}
			free($1);
		}
		;

pool_opts	:	{ bzero(&pool_opts, sizeof pool_opts); }
		    pool_opts_l
			{ $$ = pool_opts; }
		| /* empty */	{
			bzero(&pool_opts, sizeof pool_opts);
			$$ = pool_opts;
		}
		;

pool_opts_l	: pool_opts_l pool_opt
		| pool_opt
		;

pool_opt	: BITMASK	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type =  PF_POOL_BITMASK;
		}
		| RANDOM	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_RANDOM;
		}
		| SOURCEHASH hashkey {
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_SRCHASH;
			pool_opts.key = $2;
		}
		| ROUNDROBIN	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_ROUNDROBIN;
		}
		| LEASTSTATES	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_LEASTSTATES;
		}
		| STATICPORT	{
			if (pool_opts.staticport) {
				yyerror("static-port cannot be redefined");
				YYERROR;
			}
			pool_opts.staticport = 1;
		}
		| STICKYADDRESS	{
			if (filter_opts.marker & POM_STICKYADDRESS) {
				yyerror("sticky-address cannot be redefined");
				YYERROR;
			}
			pool_opts.marker |= POM_STICKYADDRESS;
			pool_opts.opts |= PF_POOL_STICKYADDR;
		}
		;

route_host	: STRING			{
			/* try to find @@if0 address specs */
			if (strrchr($1, '@@') != NULL) {
				if (($$ = host($1, pf->opts)) == NULL)	{
					yyerror("invalid host for route spec");
					YYERROR;
				}
				free($1);
			} else {
				$$ = calloc(1, sizeof(struct node_host));
				if ($$ == NULL)
					err(1, "route_host: calloc");
				$$->ifname = $1;
				$$->addr.type = PF_ADDR_NONE;
				set_ipmask($$, 128);
				$$->next = NULL;
				$$->tail = $$;
			}
		}
		| STRING '/' STRING 		{
			char	*buf;

			if (asprintf(&buf, "%s/%s", $1, $3) == -1)
				err(1, "host: asprintf");
			free($1);
			if (($$ = host(buf, pf->opts)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		| '<' STRING '>'	{
			if (strlen($2) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name '%s' too long", $2);
				free($2);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "host: calloc");
			$$->addr.type = PF_ADDR_TABLE;
			if (strlcpy($$->addr.v.tblname, $2,
			    sizeof($$->addr.v.tblname)) >=
			    sizeof($$->addr.v.tblname))
				errx(1, "host: strlcpy");
			free($2);
			$$->next = NULL;
			$$->tail = $$;
		}
		| dynaddr '/' NUMBER		{
			struct node_host	*n;

			if ($3 < 0 || $3 > 128) {
				yyerror("bit number too big");
				YYERROR;
			}
			$$ = $1;
			for (n = $1; n != NULL; n = n->next)
				set_ipmask(n, $3);
		}
		| '(' STRING host ')'		{
			struct node_host	*n;

			$$ = $3;
			/* XXX check masks, only full mask should be allowed */
			for (n = $3; n != NULL; n = n->next) {
				if ($$->ifname) {
					yyerror("cannot specify interface twice "
					    "in route spec");
					YYERROR;
				}
				if (($$->ifname = strdup($2)) == NULL)
					errx(1, "host: strdup");
			}
			free($2);
		}
		;

route_host_list	: route_host optweight optnl		{ 
			if ($2 > 0) {
				struct node_host	*n;
				for (n = $1; n != NULL; n = n->next)
					n->weight = $2;
			}
			$$ = $1;
		}
		| route_host_list comma route_host optweight optnl {
			if ($1->af == 0)
				$1->af = $3->af;
			if ($1->af != $3->af) {
				yyerror("all pool addresses must be in the "
				    "same address family");
				YYERROR;
			}
			$1->tail->next = $3;
			$1->tail = $3->tail;
			if ($4 > 0) {
				struct node_host	*n;
				for (n = $3; n != NULL; n = n->next)
					n->weight = $4;
			}
			$$ = $1;
		}
		;

routespec	: route_host optweight			{
			if ($2 > 0) {
				struct node_host	*n;
				for (n = $1; n != NULL; n = n->next)
					n->weight = $2;
			}
			$$ = $1;
		}
		| '{' optnl route_host_list '}'	{ $$ = $3; }
		;

timeout_spec	: STRING NUMBER
		{
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			if (pfctl_set_timeout(pf, $1, $2, 0) != 0) {
				yyerror("unknown timeout %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

timeout_list	: timeout_list comma timeout_spec optnl
		| timeout_spec optnl
		;

limit_spec	: STRING NUMBER
		{
			if ($2 < 0 || $2 > UINT_MAX) {
				yyerror("only positive values permitted");
				YYERROR;
			}
			if (pfctl_set_limit(pf, $1, $2) != 0) {
				yyerror("unable to set limit %s %u", $1, $2);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limit_list	: limit_list comma limit_spec optnl
		| limit_spec optnl
		;

comma		: ','
		| /* empty */
		;

yesno		: NO			{ $$ = 0; }
		| STRING		{
			if (!strcmp($1, "yes"))
				$$ = 1;
			else {
				yyerror("invalid value '%s', expected 'yes' "
				    "or 'no'", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

unaryop		: '='		{ $$ = PF_OP_EQ; }
		| NE		{ $$ = PF_OP_NE; }
		| LE		{ $$ = PF_OP_LE; }
		| '<'		{ $$ = PF_OP_LT; }
		| GE		{ $$ = PF_OP_GE; }
		| '>'		{ $$ = PF_OP_GT; }
		;

%%

int
yyerror(const char *fmt, ...)
{
	va_list		 ap;

	file->errors++;
	va_start(ap, fmt);
	fprintf(stderr, "%s:%d: ", file->name, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}

int
disallow_table(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (h->addr.type == PF_ADDR_TABLE) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
		}
	return (0);
}

int
disallow_urpf_failed(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (h->addr.type == PF_ADDR_URPFFAILED) {
			yyerror(fmt);
			return (1);
		}
	return (0);
}

int
disallow_alias(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (DYNIF_MULTIADDR(h->addr)) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
		}
	return (0);
}

int
rule_consistent(struct pf_rule *r, int anchor_call)
{
	int	problems = 0;

	if (r->proto != IPPROTO_TCP && r->os_fingerprint != PF_OSFP_ANY) {
		yyerror("os only applies to tcp");
		problems++;
	}
	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP &&
	    (r->src.port_op || r->dst.port_op)) {
		yyerror("port only applies to tcp/udp");
		problems++;
	}
	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP &&
	    r->uid.op) {
		yyerror("user only applies to tcp/udp");
		problems++;
	}
	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP &&
	    r->gid.op) {
		yyerror("group only applies to tcp/udp");
		problems++;
	}
	if (r->proto != IPPROTO_ICMP && r->proto != IPPROTO_ICMPV6 &&
	    (r->type || r->code)) {
		yyerror("icmp-type/code only applies to icmp");
		problems++;
	}
	if (!r->af && (r->type || r->code)) {
		yyerror("must indicate address family with icmp-type/code");
		problems++;
	}
	if (r->rule_flag & PFRULE_AFTO && r->af == r->naf) {
		yyerror("must indicate different address family with af-to");
		problems++;
	}
	if (r->overload_tblname[0] &&
	    r->max_src_conn == 0 && r->max_src_conn_rate.seconds == 0) {
		yyerror("'overload' requires 'max-src-conn' "
		    "or 'max-src-conn-rate'");
		problems++;
	}
	if ((r->proto == IPPROTO_ICMP && r->af == AF_INET6) ||
	    (r->proto == IPPROTO_ICMPV6 && r->af == AF_INET)) {
		yyerror("proto %s doesn't match address family %s",
		    r->proto == IPPROTO_ICMP ? "icmp" : "icmp6",
		    r->af == AF_INET ? "inet" : "inet6");
		problems++;
	}
	if (r->allow_opts && r->action != PF_PASS) {
		yyerror("allow-opts can only be specified for pass rules");
		problems++;
	}
	if (r->rule_flag & PFRULE_FRAGMENT && (r->src.port_op ||
	    r->dst.port_op || r->flagset || r->type || r->code)) {
		yyerror("fragments can be filtered only on IP header fields");
		problems++;
	}
	if (r->rule_flag & PFRULE_RETURNRST && r->proto != IPPROTO_TCP) {
		yyerror("return-rst can only be applied to TCP rules");
		problems++;
	}
	if (r->max_src_nodes && !(r->rule_flag & PFRULE_RULESRCTRACK)) {
		yyerror("max-src-nodes requires 'source-track rule'");
		problems++;
	}
	if (r->action != PF_PASS && r->keep_state) {
		yyerror("keep state is great, but only for pass rules");
		problems++;
	}
	if (r->rule_flag & PFRULE_STATESLOPPY &&
	    (r->keep_state == PF_STATE_MODULATE ||
	    r->keep_state == PF_STATE_SYNPROXY)) {
		yyerror("sloppy state matching cannot be used with "
		    "synproxy state or modulate state");
		problems++;
	}
	if ((r->nat.addr.type != PF_ADDR_NONE ||
	    r->rdr.addr.type != PF_ADDR_NONE) &&
	    r->action != PF_MATCH && !r->keep_state) {
		yyerror("nat-to and rdr-to require keep state");
		problems++;
	}
	if (r->direction == PF_INOUT && (r->nat.addr.type != PF_ADDR_NONE ||
	    r->rdr.addr.type != PF_ADDR_NONE)) {
		yyerror("nat-to and rdr-to require a direction");
		problems++;
	}
	if (r->af == AF_INET6 && (r->scrub_flags &
	    (PFSTATE_NODF|PFSTATE_RANDOMID))) {
		yyerror("address family inet6 does not support scrub options "
		    "no-df, random-id");
		problems++;
	}

	/* Basic rule sanity check. */
	switch (r->action) {
	case PF_MATCH:
		if (r->divert.port) {
			yyerror("divert is not supported on match rules");
			problems++;
		}
		if (r->divert_packet.port) {
			yyerror("divert is not supported on match rules");
			problems++;
		}
		if (r->rt) {
			yyerror("route-to, reply-to and dup-to "
			   "are not supported on match rules");
			problems++;
		}
		if (r->rule_flag & PFRULE_AFTO) {
			yyerror("af-to is not supported on match rules");
			problems++;
		}
		break;
	case PF_DROP:
		if (r->rt) {
			yyerror("route-to, reply-to and dup-to "
			   "are not supported on block rules");
			problems++;
		}
		break;
	default:;
	}
	return (-problems);
}

int
process_tabledef(char *name, struct table_opts *opts, int popts)
{
	struct pfr_buffer	 ab;
	struct node_tinit	*ti;

	bzero(&ab, sizeof(ab));
	ab.pfrb_type = PFRB_ADDRS;
	SIMPLEQ_FOREACH(ti, &opts->init_nodes, entries) {
		if (ti->file)
			if (pfr_buf_load(&ab, ti->file, 0, popts)) {
				if (errno)
					yyerror("cannot load \"%s\": %s",
					    ti->file, strerror(errno));
				else
					yyerror("file \"%s\" contains bad data",
					    ti->file);
				goto _error;
			}
		if (ti->host)
			if (append_addr_host(&ab, ti->host, 0, 0)) {
				yyerror("cannot create address buffer: %s",
				    strerror(errno));
				goto _error;
			}
	}
	if (pf->opts & PF_OPT_VERBOSE)
		print_tabledef(name, opts->flags, opts->init_addr,
		    &opts->init_nodes);
	if (!(pf->opts & PF_OPT_NOACTION) &&
	    pfctl_define_table(name, opts->flags, opts->init_addr,
	    pf->anchor->name, &ab, pf->anchor->ruleset.tticket)) {
		yyerror("cannot define table %s: %s", name,
		    pfr_strerror(errno));
		goto _error;
	}
	pf->tdirty = 1;
	pfr_buf_clear(&ab);
	return (0);
_error:
	pfr_buf_clear(&ab);
	return (-1);
}

struct keywords {
	const char	*k_name;
	int		 k_val;
};

/* macro gore, but you should've seen the prior indentation nightmare... */

#define FREE_LIST(T,r) \
	do { \
		T *p, *node = r; \
		while (node != NULL) { \
			p = node; \
			node = node->next; \
			free(p); \
		} \
	} while (0)

#define LOOP_THROUGH(T,n,r,C) \
	do { \
		T *n; \
		if (r == NULL) { \
			r = calloc(1, sizeof(T)); \
			if (r == NULL) \
				err(1, "LOOP: calloc"); \
			r->next = NULL; \
		} \
		n = r; \
		while (n != NULL) { \
			do { \
				C; \
			} while (0); \
			n = n->next; \
		} \
	} while (0)

void
expand_label_str(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL)
		err(1, "expand_label_str: calloc");
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len))
			errx(1, "expand_label: label too long");
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len)
		errx(1, "expand_label: label too long");
	strlcpy(label, tmp, len);	/* always fits */
	free(tmp);
}

void
expand_label_if(const char *name, char *label, size_t len, const char *ifname)
{
	if (strstr(label, name) != NULL) {
		if (!*ifname)
			expand_label_str(label, len, name, "any");
		else
			expand_label_str(label, len, name, ifname);
	}
}

void
expand_label_addr(const char *name, char *label, size_t len, sa_family_t af,
    struct node_host *h)
{
	char tmp[64], tmp_not[66];

	if (strstr(label, name) != NULL) {
		switch (h->addr.type) {
		case PF_ADDR_DYNIFTL:
			snprintf(tmp, sizeof(tmp), "(%s)", h->addr.v.ifname);
			break;
		case PF_ADDR_TABLE:
			snprintf(tmp, sizeof(tmp), "<%s>", h->addr.v.tblname);
			break;
		case PF_ADDR_NOROUTE:
			snprintf(tmp, sizeof(tmp), "no-route");
			break;
		case PF_ADDR_URPFFAILED:
			snprintf(tmp, sizeof(tmp), "urpf-failed");
			break;
		case PF_ADDR_ADDRMASK:
			if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
			    PF_AZERO(&h->addr.v.a.mask, af)))
				snprintf(tmp, sizeof(tmp), "any");
			else {
				char	a[48];
				int	bits;

				if (inet_ntop(af, &h->addr.v.a.addr, a,
				    sizeof(a)) == NULL)
					snprintf(tmp, sizeof(tmp), "?");
				else {
					bits = unmask(&h->addr.v.a.mask, af);
					if ((af == AF_INET && bits < 32) ||
					    (af == AF_INET6 && bits < 128))
						snprintf(tmp, sizeof(tmp),
						    "%s/%d", a, bits);
					else
						snprintf(tmp, sizeof(tmp),
						    "%s", a);
				}
			}
			break;
		default:
			snprintf(tmp, sizeof(tmp), "?");
			break;
		}

		if (h->not) {
			snprintf(tmp_not, sizeof(tmp_not), "! %s", tmp);
			expand_label_str(label, len, name, tmp_not);
		} else
			expand_label_str(label, len, name, tmp);
	}
}

void
expand_label_port(const char *name, char *label, size_t len,
    struct node_port *port)
{
	char	 a1[6], a2[6], op[13] = "";

	if (strstr(label, name) != NULL) {
		snprintf(a1, sizeof(a1), "%u", ntohs(port->port[0]));
		snprintf(a2, sizeof(a2), "%u", ntohs(port->port[1]));
		if (!port->op)
			;
		else if (port->op == PF_OP_IRG)
			snprintf(op, sizeof(op), "%s><%s", a1, a2);
		else if (port->op == PF_OP_XRG)
			snprintf(op, sizeof(op), "%s<>%s", a1, a2);
		else if (port->op == PF_OP_EQ)
			snprintf(op, sizeof(op), "%s", a1);
		else if (port->op == PF_OP_NE)
			snprintf(op, sizeof(op), "!=%s", a1);
		else if (port->op == PF_OP_LT)
			snprintf(op, sizeof(op), "<%s", a1);
		else if (port->op == PF_OP_LE)
			snprintf(op, sizeof(op), "<=%s", a1);
		else if (port->op == PF_OP_GT)
			snprintf(op, sizeof(op), ">%s", a1);
		else if (port->op == PF_OP_GE)
			snprintf(op, sizeof(op), ">=%s", a1);
		expand_label_str(label, len, name, op);
	}
}

void
expand_label_proto(const char *name, char *label, size_t len, u_int8_t proto)
{
	struct protoent *pe;
	char n[4];

	if (strstr(label, name) != NULL) {
		pe = getprotobynumber(proto);
		if (pe != NULL)
			expand_label_str(label, len, name, pe->p_name);
		else {
			snprintf(n, sizeof(n), "%u", proto);
			expand_label_str(label, len, name, n);
		}
	}
}

void
expand_label_nr(const char *name, char *label, size_t len)
{
	char n[11];

	if (strstr(label, name) != NULL) {
		snprintf(n, sizeof(n), "%u", pf->anchor->match);
		expand_label_str(label, len, name, n);
	}
}

void
expand_label(char *label, size_t len, const char *ifname, sa_family_t af,
    struct node_host *src_host, struct node_port *src_port,
    struct node_host *dst_host, struct node_port *dst_port,
    u_int8_t proto)
{
	expand_label_if("$if", label, len, ifname);
	expand_label_addr("$srcaddr", label, len, af, src_host);
	expand_label_addr("$dstaddr", label, len, af, dst_host);
	expand_label_port("$srcport", label, len, src_port);
	expand_label_port("$dstport", label, len, dst_port);
	expand_label_proto("$proto", label, len, proto);
	expand_label_nr("$nr", label, len);
}

int
expand_queue(char *qname, struct node_if *interfaces, struct queue_opts *opts)
{
	struct pf_queuespec	qspec;

	LOOP_THROUGH(struct node_if, interface, interfaces,
		bzero(&qspec, sizeof(qspec));
		if (!opts->parent && (opts->marker & QOM_BWSPEC))
			opts->flags |= PFQS_ROOTCLASS;
		if (!(opts->marker & QOM_BWSPEC) &&
		    !(opts->marker & QOM_FLOWS)) {
			yyerror("no bandwidth or flow specification");
			return (1);
		}
		if (strlcpy(qspec.qname, qname, sizeof(qspec.qname)) >=
		    sizeof(qspec.qname)) {
			yyerror("queuename too long");
			return (1);
		}
		if (opts->parent && strlcpy(qspec.parent, opts->parent,
		    sizeof(qspec.parent)) >= sizeof(qspec.parent)) {
			yyerror("parent too long");
			return (1);
		}
		if (strlcpy(qspec.ifname, interface->ifname,
		    sizeof(qspec.ifname)) >= sizeof(qspec.ifname)) {
			yyerror("interface too long");
			return (1);
		}
		qspec.realtime.m1.absolute = opts->realtime.m1.bw_absolute;
		qspec.realtime.m1.percent = opts->realtime.m1.bw_percent;
		qspec.realtime.m2.absolute = opts->realtime.m2.bw_absolute;
		qspec.realtime.m2.percent = opts->realtime.m2.bw_percent;
		qspec.realtime.d = opts->realtime.d;

		qspec.linkshare.m1.absolute = opts->linkshare.m1.bw_absolute;
		qspec.linkshare.m1.percent = opts->linkshare.m1.bw_percent;
		qspec.linkshare.m2.absolute = opts->linkshare.m2.bw_absolute;
		qspec.linkshare.m2.percent = opts->linkshare.m2.bw_percent;
		qspec.linkshare.d = opts->linkshare.d;

		qspec.upperlimit.m1.absolute = opts->upperlimit.m1.bw_absolute;
		qspec.upperlimit.m1.percent = opts->upperlimit.m1.bw_percent;
		qspec.upperlimit.m2.absolute = opts->upperlimit.m2.bw_absolute;
		qspec.upperlimit.m2.percent = opts->upperlimit.m2.bw_percent;
		qspec.upperlimit.d = opts->upperlimit.d;

		qspec.flowqueue.flows = opts->flowqueue.flows;
		qspec.flowqueue.quantum = opts->flowqueue.quantum;
		qspec.flowqueue.interval = opts->flowqueue.interval;
		qspec.flowqueue.target = opts->flowqueue.target;

		qspec.flags = opts->flags;
		qspec.qlimit = opts->qlimit;

		if (pfctl_add_queue(pf, &qspec)) {
			yyerror("cannot add queue");
			return (1);
		}
	);

	FREE_LIST(struct node_if, interfaces);
	return (0);
}

int
expand_divertspec(struct pf_rule *r, struct divertspec *ds)
{
	struct node_host *n;

	if (ds->port == 0)
		return (0);

	r->divert.port = ds->port;

	if (r->direction == PF_OUT) {
		if (ds->addr) {
			yyerror("address specified for outgoing divert");
			return (1);
		}
		bzero(&r->divert.addr, sizeof(r->divert.addr));
		return (0);
	}

	if (!ds->addr) {
		yyerror("no address specified for incoming divert");
		return (1);
	}
	if (r->af) {
		for (n = ds->addr; n != NULL; n = n->next)
			if (n->af == r->af)
				break;
		if (n == NULL) {
			yyerror("address family mismatch for divert");
			return (1);
		}
		r->divert.addr = n->addr.v.a.addr;
	} else {
		r->af = ds->addr->af;
		r->divert.addr = ds->addr->addr.v.a.addr;
	}
	return (0);
}

int
collapse_redirspec(struct pf_pool *rpool, struct pf_rule *r,
    struct redirspec *rs, u_int8_t allow_if)
{
	struct pf_opt_tbl *tbl = NULL;
	struct node_host *h, *hprev = NULL;
	struct pf_rule_addr ra;
	int af = 0, naddr = 0;

	if (!rs || !rs->rdr || rs->rdr->host == NULL) {
		rpool->addr.type = PF_ADDR_NONE;
		return (0);
	}

	if (r->rule_flag & PFRULE_AFTO)
		r->naf = rs->af;

	for (h = rs->rdr->host; h != NULL; h = h->next) {
		/* set rule address family if redirect spec has one */
		if (rs->af && !r->af && !af) {
			/* swap address families for af-to */
			if (r->naf == AF_INET6)
				af = AF_INET;
			else if (r->naf == AF_INET)
				af = AF_INET6;
			else
				af = rs->af;
		}
		if (h->af && !r->naf) {	/* nat-to/rdr-to case */
			/* skip if the rule af doesn't match redirect af */
			if (r->af && r->af != h->af)
				continue;
			/*
			 * fail if the chosen af is not universal for
			 * all addresses in the redirect address pool
			 */
			if (!r->af && af && af != h->af) {
				yyerror("%s spec contains addresses with "
				    "different address families",
				    allow_if ? "routing" : "translation");
				return (1);
			}
		} else if (h->af) {	/* af-to case */
			/*
			 * fail if the redirect spec af is not universal
			 * for all addresses in the redirect address pool
			 */
			if (rs->af && rs->af != h->af) {
				yyerror("%s spec contains addresses that "
				    "don't match target address family",
				    allow_if ? "routing" : "translation");
				return (1);
			}
		}
		/* else if (!h->af):
		 * we silently allow any not af-specific host specs,
		 * e.g. (em0) and let the kernel deal with them
		 */

		/* if we haven't selected the rule af yet, now it's time */
		if (!r->af && !af)
			af = h->af;

		if (naddr == 0) {	/* the first host */
			rpool->addr = h->addr;
			if (!allow_if && h->ifname) {
				yyerror("@@if not permitted for translation");
				return (1);
			}
			if (h->ifname && strlcpy(rpool->ifname, h->ifname,
			    sizeof(rpool->ifname)) >= sizeof(rpool->ifname))
				errx(1, "collapse_redirspec: strlcpy");
			hprev = h; /* in case we need to conver to a table */
		} else {		/* multiple hosts */
			if (rs->pool_opts.type &&
			    !PF_POOL_DYNTYPE(rs->pool_opts.type)) {
				yyerror("pool type is not valid for multiple "
				    "translation or routing addresses");
				return (1);
			}
			if ((hprev && hprev->addr.type != PF_ADDR_ADDRMASK) &&
			    (hprev && hprev->addr.type != PF_ADDR_NONE) &&
			    h->addr.type != PF_ADDR_ADDRMASK &&
			    h->addr.type != PF_ADDR_NONE) {
				yyerror("multiple tables or dynamic interfaces "
				    "not supported for translation or routing");
				return (1);
			}
			if (!allow_if && h->ifname) {
				yyerror("@@if not permitted for translation");
				return (1);
			}
			if (hprev) {
				/*
				 * undo some damage and convert the single
				 * host pool to the table
				 */
				memset(&ra, 0, sizeof(ra));
				memset(rpool->ifname, 0, sizeof(rpool->ifname));
				ra.addr = hprev->addr;
				ra.weight = hprev->weight;
				if (add_opt_table(pf, &tbl,
				    hprev->af, &ra, hprev->ifname))
					return (1);
				hprev = NULL;
			}
			memset(&ra, 0, sizeof(ra));
			ra.addr = h->addr;
			ra.weight = h->weight;
			if (add_opt_table(pf, &tbl,
			    h->af, &ra, h->ifname))
				return (1);
		}
		naddr++;
	}
	/* set rule af to the one chosen above */
	if (!r->af && af)
		r->af = af;
	if (!naddr) {
		yyerror("af mismatch in %s spec",
		    allow_if ? "routing" : "translation");
		return (1);
	}
	if (tbl) {
		if ((pf->opts & PF_OPT_NOACTION) == 0 &&
		     pf_opt_create_table(pf, tbl))
				return (1);

		pf->tdirty = 1;

		if (pf->opts & PF_OPT_VERBOSE)
			print_tabledef(tbl->pt_name,
			    PFR_TFLAG_CONST | tbl->pt_flags,
			    1, &tbl->pt_nodes);

		memset(&rpool->addr, 0, sizeof(rpool->addr));
		rpool->addr.type = PF_ADDR_TABLE;
		strlcpy(rpool->addr.v.tblname, tbl->pt_name,
		    sizeof(rpool->addr.v.tblname));

		pfr_buf_clear(tbl->pt_buf);
		free(tbl->pt_buf);
		tbl->pt_buf = NULL;
		free(tbl);
	}
	return (0);
}


int
apply_redirspec(struct pf_pool *rpool, struct pf_rule *r, struct redirspec *rs,
    int isrdr, struct node_port *np)
{
	if (!rs || !rs->rdr)
		return (0);

	rpool->proxy_port[0] = ntohs(rs->rdr->rport.a);

	if (isrdr) {
		if (!rs->rdr->rport.b && rs->rdr->rport.t) {
			rpool->proxy_port[1] = ntohs(rs->rdr->rport.a) +
			    (ntohs(np->port[1]) - ntohs(np->port[0]));
		} else
			rpool->proxy_port[1] = ntohs(rs->rdr->rport.b);
	} else {
		rpool->proxy_port[1] = ntohs(rs->rdr->rport.b);
		if (!rpool->proxy_port[0] && !rpool->proxy_port[1]) {
			rpool->proxy_port[0] = PF_NAT_PROXY_PORT_LOW;
			rpool->proxy_port[1] = PF_NAT_PROXY_PORT_HIGH;
		} else if (!rpool->proxy_port[1])
			rpool->proxy_port[1] = rpool->proxy_port[0];
	}

	rpool->opts = rs->pool_opts.type;
	if ((rpool->opts & PF_POOL_TYPEMASK) == PF_POOL_NONE &&
	    (rpool->addr.type == PF_ADDR_TABLE ||
	    DYNIF_MULTIADDR(rpool->addr)))
		rpool->opts |= PF_POOL_ROUNDROBIN;

	if (!PF_POOL_DYNTYPE(rpool->opts) &&
	    (disallow_table(rs->rdr->host,
	    "tables are not supported by pool type") ||
	    disallow_alias(rs->rdr->host,
	    "interface (%s) is not supported by pool type")))
		return (1);

	if (rs->pool_opts.key != NULL)
		memcpy(&rpool->key, rs->pool_opts.key,
		    sizeof(struct pf_poolhashkey));

	if (rs->pool_opts.opts)
		rpool->opts |= rs->pool_opts.opts;

	if (rs->pool_opts.staticport) {
		if (isrdr) {
			yyerror("the 'static-port' option is only valid with "
			    "nat rules");
			return (1);
		}
		if (rpool->proxy_port[0] != PF_NAT_PROXY_PORT_LOW &&
		    rpool->proxy_port[1] != PF_NAT_PROXY_PORT_HIGH) {
			yyerror("the 'static-port' option can't be used when "
			    "specifying a port range");
			return (1);
		}
		rpool->proxy_port[0] = 0;
		rpool->proxy_port[1] = 0;
	}

	return (0);
}


void
expand_rule(struct pf_rule *r, int keeprule, struct node_if *interfaces,
    struct redirspec *nat, struct redirspec *rdr, struct redirspec *rroute,
    struct node_proto *protos, struct node_os *src_oses,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_uid *uids, struct node_gid *gids, struct node_if *rcv,
    struct node_icmp *icmp_types, const char *anchor_call)
{
	sa_family_t		 af = r->af;
	int			 added = 0, error = 0;
	char			 ifname[IF_NAMESIZE];
	char			 label[PF_RULE_LABEL_SIZE];
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];
	u_int8_t		 flags, flagset, keep_state;
	struct node_host	*srch, *dsth, *osrch, *odsth;
	struct redirspec	 binat;
	struct pf_rule		 rb;
	int			 dir = r->direction;

	if (strlcpy(label, r->label, sizeof(label)) >= sizeof(label))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(tagname, r->tagname, sizeof(tagname)) >= sizeof(tagname))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(match_tagname, r->match_tagname, sizeof(match_tagname)) >=
	    sizeof(match_tagname))
		errx(1, "expand_rule: strlcpy");
	flags = r->flags;
	flagset = r->flagset;
	keep_state = r->keep_state;

	r->src.addr.type = r->dst.addr.type = PF_ADDR_ADDRMASK;

	LOOP_THROUGH(struct node_if, interface, interfaces,
	LOOP_THROUGH(struct node_proto, proto, protos,
	LOOP_THROUGH(struct node_icmp, icmp_type, icmp_types,
	LOOP_THROUGH(struct node_host, src_host, src_hosts,
	LOOP_THROUGH(struct node_host, dst_host, dst_hosts,
	LOOP_THROUGH(struct node_port, src_port, src_ports,
	LOOP_THROUGH(struct node_port, dst_port, dst_ports,
	LOOP_THROUGH(struct node_os, src_os, src_oses,
	LOOP_THROUGH(struct node_uid, uid, uids,
	LOOP_THROUGH(struct node_gid, gid, gids,

		r->af = af;

		error += collapse_redirspec(&r->rdr, r, rdr, 0);
		error += collapse_redirspec(&r->nat, r, nat, 0);
		error += collapse_redirspec(&r->route, r, rroute, 1);

		/* disallow @@if in from or to for the time being */
		if ((src_host->addr.type == PF_ADDR_ADDRMASK &&
		    src_host->ifname) ||
		    (dst_host->addr.type == PF_ADDR_ADDRMASK &&
		    dst_host->ifname)) {
			yyerror("@@if syntax not permitted in from or to");
			error++;
		}
		/* for link-local IPv6 address, interface must match up */
		if ((r->af && src_host->af && r->af != src_host->af) ||
		    (r->af && dst_host->af && r->af != dst_host->af) ||
		    (src_host->af && dst_host->af &&
		    src_host->af != dst_host->af) ||
		    (src_host->ifindex && dst_host->ifindex &&
		    src_host->ifindex != dst_host->ifindex) ||
		    (src_host->ifindex && *interface->ifname &&
		    src_host->ifindex != ifa_nametoindex(interface->ifname)) ||
		    (dst_host->ifindex && *interface->ifname &&
		    dst_host->ifindex != ifa_nametoindex(interface->ifname)))
			continue;
		if (!r->af && src_host->af)
			r->af = src_host->af;
		else if (!r->af && dst_host->af)
			r->af = dst_host->af;

		if (*interface->ifname)
			strlcpy(r->ifname, interface->ifname,
			    sizeof(r->ifname));
		else if (ifa_indextoname(src_host->ifindex, ifname))
			strlcpy(r->ifname, ifname, sizeof(r->ifname));
		else if (ifa_indextoname(dst_host->ifindex, ifname))
			strlcpy(r->ifname, ifname, sizeof(r->ifname));
		else
			memset(r->ifname, '\0', sizeof(r->ifname));

		if (interface->use_rdomain)
			r->onrdomain = interface->rdomain;
		else
			r->onrdomain = -1;
		if (strlcpy(r->label, label, sizeof(r->label)) >=
		    sizeof(r->label))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->tagname, tagname, sizeof(r->tagname)) >=
		    sizeof(r->tagname))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->match_tagname, match_tagname,
		    sizeof(r->match_tagname)) >= sizeof(r->match_tagname))
			errx(1, "expand_rule: strlcpy");
		expand_label(r->label, PF_RULE_LABEL_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->tagname, PF_TAG_NAME_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->match_tagname, PF_TAG_NAME_SIZE, r->ifname,
		    r->af, src_host, src_port, dst_host, dst_port,
		    proto->proto);

		osrch = odsth = NULL;
		if (src_host->addr.type == PF_ADDR_DYNIFTL) {
			osrch = src_host;
			if ((src_host = gen_dynnode(src_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}
		if (dst_host->addr.type == PF_ADDR_DYNIFTL) {
			odsth = dst_host;
			if ((dst_host = gen_dynnode(dst_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}

		error += check_netmask(src_host, r->af);
		error += check_netmask(dst_host, r->af);

		r->ifnot = interface->not;
		r->proto = proto->proto;
		r->src.addr = src_host->addr;
		r->src.neg = src_host->not;
		r->src.port[0] = src_port->port[0];
		r->src.port[1] = src_port->port[1];
		r->src.port_op = src_port->op;
		r->dst.addr = dst_host->addr;
		r->dst.neg = dst_host->not;
		r->dst.port[0] = dst_port->port[0];
		r->dst.port[1] = dst_port->port[1];
		r->dst.port_op = dst_port->op;
		r->uid.op = uid->op;
		r->uid.uid[0] = uid->uid[0];
		r->uid.uid[1] = uid->uid[1];
		r->gid.op = gid->op;
		r->gid.gid[0] = gid->gid[0];
		r->gid.gid[1] = gid->gid[1];
		if (rcv) {
			strlcpy(r->rcv_ifname, rcv->ifname,
			    sizeof(r->rcv_ifname));
			r->rcvifnot = rcv->not;
		}
		r->type = icmp_type->type;
		r->code = icmp_type->code;

		if ((keep_state == PF_STATE_MODULATE ||
		    keep_state == PF_STATE_SYNPROXY) &&
		    r->proto && r->proto != IPPROTO_TCP)
			r->keep_state = PF_STATE_NORMAL;
		else
			r->keep_state = keep_state;

		if (r->proto && r->proto != IPPROTO_TCP) {
			r->flags = 0;
			r->flagset = 0;
		} else {
			r->flags = flags;
			r->flagset = flagset;
		}
		if (icmp_type->proto && r->proto != icmp_type->proto) {
			yyerror("icmp-type mismatch");
			error++;
		}

		if (src_os && src_os->os) {
			r->os_fingerprint = pfctl_get_fingerprint(src_os->os);
			if ((pf->opts & PF_OPT_VERBOSE2) &&
			    r->os_fingerprint == PF_OSFP_NOMATCH)
				fprintf(stderr,
				    "warning: unknown '%s' OS fingerprint\n",
				    src_os->os);
		} else {
			r->os_fingerprint = PF_OSFP_ANY;
		}

		if (nat && nat->rdr && nat->binat) {
			if (disallow_table(src_host, "invalid use of table "
			    "<%s> as the source address of a binat-to rule") ||
			    disallow_alias(src_host, "invalid use of interface "
			    "(%s) as the source address of a binat-to rule")) {
				error++;
			} else if ((r->src.addr.type != PF_ADDR_ADDRMASK &&
			    r->src.addr.type != PF_ADDR_DYNIFTL) ||
			    (r->nat.addr.type != PF_ADDR_ADDRMASK &&
			    r->nat.addr.type != PF_ADDR_DYNIFTL)) {
				yyerror("binat-to requires a specified "
				    "source and redirect address");
				error++;
			}
			if (DYNIF_MULTIADDR(r->src.addr) ||
			    DYNIF_MULTIADDR(r->nat.addr)) {
				yyerror ("dynamic interfaces must be used with "
				    ":0 in a binat-to rule");
				error++;
			}
			if (PF_AZERO(&r->src.addr.v.a.mask, af) ||
			    PF_AZERO(&r->nat.addr.v.a.mask, af)) {
				yyerror ("source and redir addresess must have "
				    "a matching network mask in binat-rule");
				error++;
			}
			if (r->nat.addr.type == PF_ADDR_TABLE) {
				yyerror ("tables cannot be used as the redirect "
				    "address of a binat-to rule");
				error++;
			}
			if (r->direction != PF_INOUT) {
				yyerror("binat-to cannot be specified "
				    "with a direction");
				error++;
			}

			/* first specify outbound NAT rule */
			r->direction = PF_OUT;
		}

		error += apply_redirspec(&r->nat, r, nat, 0, dst_port);
		error += apply_redirspec(&r->rdr, r, rdr, 1, dst_port);
		error += apply_redirspec(&r->route, r, rroute, 2, dst_port);

		if (rule_consistent(r, anchor_call[0]) < 0 || error)
			yyerror("skipping rule due to errors");
		else {
			r->nr = pf->astack[pf->asd]->match++;
			pfctl_add_rule(pf, r, anchor_call);
			added++;
		}
		r->direction = dir;

		/* Generate binat's matching inbound rule */
		if (!error && nat && nat->rdr && nat->binat) {
			bcopy(r, &rb, sizeof(rb));

			/* now specify inbound rdr rule */
			rb.direction = PF_IN;

			if ((srch = calloc(1, sizeof(*srch))) == NULL)
				err(1, "expand_rule: calloc");
			bcopy(src_host, srch, sizeof(*srch));
			srch->ifname = NULL;
			srch->next = NULL;
			srch->tail = NULL;

			if ((dsth = calloc(1, sizeof(*dsth))) == NULL)
				err(1, "expand_rule: calloc");
			bcopy(&rb.nat.addr, &dsth->addr, sizeof(dsth->addr));
			dsth->ifname = NULL;
			dsth->next = NULL;
			dsth->tail = NULL;

			bzero(&binat, sizeof(binat));
			if ((binat.rdr =
			    calloc(1, sizeof(*binat.rdr))) == NULL)
				err(1, "expand_rule: calloc");
			bcopy(nat->rdr, binat.rdr, sizeof(*binat.rdr));
			bcopy(&nat->pool_opts, &binat.pool_opts,
			    sizeof(binat.pool_opts));
			binat.pool_opts.staticport = 0;
			binat.rdr->host = srch;

			expand_rule(&rb, 1, interface, NULL, &binat, NULL,
			    proto,
			    src_os, dst_host, dst_port, dsth, src_port,
			    uid, gid, rcv, icmp_type, anchor_call);
		}

		if (osrch && src_host->addr.type == PF_ADDR_DYNIFTL) {
			free(src_host);
			src_host = osrch;
		}
		if (odsth && dst_host->addr.type == PF_ADDR_DYNIFTL) {
			free(dst_host);
			dst_host = odsth;
		}
	))))))))));

	if (!keeprule) {
		FREE_LIST(struct node_if, interfaces);
		FREE_LIST(struct node_proto, protos);
		FREE_LIST(struct node_host, src_hosts);
		FREE_LIST(struct node_port, src_ports);
		FREE_LIST(struct node_os, src_oses);
		FREE_LIST(struct node_host, dst_hosts);
		FREE_LIST(struct node_port, dst_ports);
		FREE_LIST(struct node_uid, uids);
		FREE_LIST(struct node_gid, gids);
		FREE_LIST(struct node_icmp, icmp_types);
		if (nat && nat->rdr)
			FREE_LIST(struct node_host, nat->rdr->host);
		if (rdr && rdr->rdr)
			FREE_LIST(struct node_host, rdr->rdr->host);

	}

	if (!added)
		yyerror("rule expands to no valid combination");
}

int
expand_skip_interface(struct node_if *interfaces)
{
	int	errs = 0;

	if (!interfaces || (!interfaces->next && !interfaces->not &&
	    !strcmp(interfaces->ifname, "none"))) {
		if (pf->opts & PF_OPT_VERBOSE)
			printf("set skip on none\n");
		errs = pfctl_set_interface_flags(pf, "", PFI_IFLAG_SKIP, 0);
		return (errs);
	}

	if (pf->opts & PF_OPT_VERBOSE)
		printf("set skip on {");
	LOOP_THROUGH(struct node_if, interface, interfaces,
		if (pf->opts & PF_OPT_VERBOSE)
			printf(" %s", interface->ifname);
		if (interface->not) {
			yyerror("skip on ! <interface> is not supported");
			errs++;
		} else if (interface->use_rdomain) {
			yyerror("skip on rdomain <num> is not supported");
			errs++;
		} else
			errs += pfctl_set_interface_flags(pf,
			    interface->ifname, PFI_IFLAG_SKIP, 1);
	);
	if (pf->opts & PF_OPT_VERBOSE)
		printf(" }\n");

	FREE_LIST(struct node_if, interfaces);

	if (errs)
		return (1);
	else
		return (0);
}

void
freehostlist(struct node_host *h)
{
	struct node_host *n;

	for (n = h; n != NULL; n = n->next)
		if (n->ifname)
			free(n->ifname);
	FREE_LIST(struct node_host, h);
}

#undef FREE_LIST
#undef LOOP_THROUGH

int
kw_cmp(const void *k, const void *e)
{
	return (strcmp(k, ((const struct keywords *)e)->k_name));
}

int
lookup(char *s)
{
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "af-to",		AFTO},
		{ "all",		ALL},
		{ "allow-opts",		ALLOWOPTS},
		{ "anchor",		ANCHOR},
		{ "antispoof",		ANTISPOOF},
		{ "any",		ANY},
		{ "bandwidth",		BANDWIDTH},
		{ "binat-to",		BINATTO},
		{ "bitmask",		BITMASK},
		{ "block",		BLOCK},
		{ "block-policy",	BLOCKPOLICY},
		{ "burst",		BURST},
		{ "code",		CODE},
		{ "debug",		DEBUG},
		{ "default",		DEFAULT},
		{ "divert-packet",	DIVERTPACKET},
		{ "divert-reply",	DIVERTREPLY},
		{ "divert-to",		DIVERTTO},
		{ "drop",		DROP},
		{ "dup-to",		DUPTO},
		{ "file",		FILENAME},
		{ "fingerprints",	FINGERPRINTS},
		{ "flags",		FLAGS},
		{ "floating",		FLOATING},
		{ "flows",		FLOWS},
		{ "flush",		FLUSH},
		{ "for",		FOR},
		{ "fragment",		FRAGMENT},
		{ "from",		FROM},
		{ "global",		GLOBAL},
		{ "group",		GROUP},
		{ "hostid",		HOSTID},
		{ "icmp-type",		ICMPTYPE},
		{ "icmp6-type",		ICMP6TYPE},
		{ "if-bound",		IFBOUND},
		{ "in",			IN},
		{ "include",		INCLUDE},
		{ "inet",		INET},
		{ "inet6",		INET6},
		{ "keep",		KEEP},
		{ "label",		LABEL},
		{ "least-states",	LEASTSTATES},
		{ "limit",		LIMIT},
		{ "load",		LOAD},
		{ "log",		LOG},
		{ "loginterface",	LOGINTERFACE},
		{ "match",		MATCH},
		{ "matches",		MATCHES},
		{ "max",		MAXIMUM},
		{ "max-mss",		MAXMSS},
		{ "max-src-conn",	MAXSRCCONN},
		{ "max-src-conn-rate",	MAXSRCCONNRATE},
		{ "max-src-nodes",	MAXSRCNODES},
		{ "max-src-states",	MAXSRCSTATES},
		{ "min",		MINIMUM},
		{ "min-ttl",		MINTTL},
		{ "modulate",		MODULATE},
		{ "nat-to",		NATTO},
		{ "no",			NO},
		{ "no-df",		NODF},
		{ "no-route",		NOROUTE},
		{ "no-sync",		NOSYNC},
		{ "on",			ON},
		{ "once",		ONCE},
		{ "optimization",	OPTIMIZATION},
		{ "os",			OS},
		{ "out",		OUT},
		{ "overload",		OVERLOAD},
		{ "parent",		PARENT},
		{ "pass",		PASS},
		{ "pflow",		PFLOW},
		{ "port",		PORT},
		{ "prio",		PRIO},
		{ "probability",	PROBABILITY},
		{ "proto",		PROTO},
		{ "qlimit",		QLIMIT},
		{ "quantum",		QUANTUM},
		{ "queue",		QUEUE},
		{ "quick",		QUICK},
		{ "random",		RANDOM},
		{ "random-id",		RANDOMID},
		{ "rdomain",		RDOMAIN},
		{ "rdr-to",		RDRTO},
		{ "reassemble",		REASSEMBLE},
		{ "received-on",	RECEIVEDON},
		{ "reply-to",		REPLYTO},
		{ "return",		RETURN},
		{ "return-icmp",	RETURNICMP},
		{ "return-icmp6",	RETURNICMP6},
		{ "return-rst",		RETURNRST},
		{ "round-robin",	ROUNDROBIN},
		{ "route",		ROUTE},
		{ "route-to",		ROUTETO},
		{ "rtable",		RTABLE},
		{ "rule",		RULE},
		{ "ruleset-optimization",	RULESET_OPTIMIZATION},
		{ "scrub",		SCRUB},
		{ "set",		SET},
		{ "skip",		SKIP},
		{ "sloppy",		SLOPPY},
		{ "source-hash",	SOURCEHASH},
		{ "source-track",	SOURCETRACK},
		{ "state",		STATE},
		{ "state-defaults",	STATEDEFAULTS},
		{ "state-policy",	STATEPOLICY},
		{ "static-port",	STATICPORT},
		{ "sticky-address",	STICKYADDRESS},
		{ "synproxy",		SYNPROXY},
		{ "table",		TABLE},
		{ "tag",		TAG},
		{ "tagged",		TAGGED},
		{ "timeout",		TIMEOUT},
		{ "to",			TO},
		{ "tos",		TOS},
		{ "ttl",		TTL},
		{ "urpf-failed",	URPFFAILED},
		{ "user",		USER},
		{ "weight",		WEIGHT},
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p) {
		if (debug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
		return (p->k_val);
	} else {
		if (debug > 1)
			fprintf(stderr, "string: %s\n", s);
		return (STRING);
	}
}

#define MAXPUSHBACK	128

u_char	*parsebuf;
int	 parseindex;
u_char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;

int
lgetc(int quotec)
{
	int		c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
	}

	if (pushback_index)
		return (pushback_buffer[--pushback_index]);

	if (quotec) {
		if ((c = getc(file->stream)) == EOF) {
			yyerror("reached end of file while parsing quoted string");
			if (popfile() == EOF)
				return (EOF);
			return (quotec);
		}
		return (c);
	}

	while ((c = getc(file->stream)) == '\\') {
		next = getc(file->stream);
		if (next != '\n') {
			c = next;
			break;
		}
		yylval.lineno = file->lineno;
		file->lineno++;
	}

	while (c == EOF) {
		if (popfile() == EOF)
			return (EOF);
		c = getc(file->stream);
	}
	return (c);
}

int
lungetc(int c)
{
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
	}
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
}

int
findeol(void)
{
	int	c;

	parsebuf = NULL;

	/* skip to either EOF or the first real EOL */
	while (1) {
		if (pushback_index)
			c = pushback_buffer[--pushback_index];
		else
			c = lgetc(0);
		if (c == '\n') {
			file->lineno++;
			break;
		}
		if (c == EOF)
			break;
	}
	return (ERROR);
}

int
yylex(void)
{
	u_char	 buf[8096];
	u_char	*p, *val;
	int	 quotec, next, c;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(0)) == ' ' || c == '\t')
		; /* nothing */

	yylval.lineno = file->lineno;
	if (c == '#')
		while ((c = lgetc(0)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(0)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			if (isalnum(c) || c == '_') {
				*p++ = c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
		}
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		quotec = c;
		while (1) {
			if ((c = lgetc(quotec)) == EOF)
				return (0);
			if (c == '\n') {
				file->lineno++;
				continue;
			} else if (c == '\\') {
				if ((next = lgetc(quotec)) == EOF)
					return (0);
				if (next == quotec || c == ' ' || c == '\t')
					c = next;
				else if (next == '\n') {
					file->lineno++;
					continue;
				} else
					lungetc(next);
			} else if (c == quotec) {
				*p = '\0';
				break;
			} else if (c == '\0') {
				yyerror("syntax error");
				return (findeol());
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = c;
		}
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	case '!':
		next = lgetc(0);
		if (next == '=')
			return (NE);
		lungetc(next);
		break;
	case '<':
		next = lgetc(0);
		if (next == '>') {
			yylval.v.i = PF_OP_XRG;
			return (PORTBINARY);
		} else if (next == '=')
			return (LE);
		lungetc(next);
		break;
	case '>':
		next = lgetc(0);
		if (next == '<') {
			yylval.v.i = PF_OP_IRG;
			return (PORTBINARY);
		} else if (next == '=')
			return (GE);
		lungetc(next);
		break;
	}

#define allowed_to_end_number(x) \
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}' || x == '=')

	if (c == '-' || isdigit(c)) {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && isdigit(c));
		lungetc(c);
		if (p == buf + 1 && buf[0] == '-')
			goto nodigits;
		if (c == EOF || allowed_to_end_number(c)) {
			const char *errstr = NULL;

			*p = '\0';
			yylval.v.number = strtonum(buf, LLONG_MIN,
			    LLONG_MAX, &errstr);
			if (errstr) {
				yyerror("\"%s\" invalid number: %s",
				    buf, errstr);
				return (findeol());
			}
			return (NUMBER);
		} else {
nodigits:
			while (p > buf + 1)
				lungetc(*--p);
			c = *--p;
			if (c == '-')
				return (c);
		}
	}

#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(0)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = file->lineno;
		file->lineno++;
	}
	if (c == EOF)
		return (0);
	return (c);
}

int
check_file_secrecy(int fd, const char *fname)
{
	struct stat	st;

	if (fstat(fd, &st)) {
		warn("cannot stat %s", fname);
		return (-1);
	}
	if (st.st_uid != 0 && st.st_uid != getuid()) {
		warnx("%s: owner not root or current user", fname);
		return (-1);
	}
	if (st.st_mode & (S_IWGRP | S_IXGRP | S_IRWXO)) {
		warnx("%s: group writable or world read/writable", fname);
		return (-1);
	}
	return (0);
}

struct file *
pushfile(const char *name, int secret)
{
	struct file	*nfile;

	if ((nfile = calloc(1, sizeof(struct file))) == NULL ||
	    (nfile->name = strdup(name)) == NULL) {
		if (nfile)
			free(nfile);
		warn("malloc");
		return (NULL);
	}
	if (TAILQ_FIRST(&files) == NULL && strcmp(nfile->name, "-") == 0) {
		nfile->stream = stdin;
		free(nfile->name);
		if ((nfile->name = strdup("stdin")) == NULL) {
			warn("strdup");
			free(nfile);
			return (NULL);
		}
	} else if ((nfile->stream = fopen(nfile->name, "r")) == NULL) {
		warn("%s", nfile->name);
		free(nfile->name);
		free(nfile);
		return (NULL);
	} else if (secret &&
	    check_file_secrecy(fileno(nfile->stream), nfile->name)) {
		fclose(nfile->stream);
		free(nfile->name);
		free(nfile);
		return (NULL);
	}
	nfile->lineno = 1;
	TAILQ_INSERT_TAIL(&files, nfile, entry);
	return (nfile);
}

int
popfile(void)
{
	struct file	*prev;

	if ((prev = TAILQ_PREV(file, files, entry)) != NULL) {
		prev->errors += file->errors;
		TAILQ_REMOVE(&files, file, entry);
		fclose(file->stream);
		free(file->name);
		free(file);
		file = prev;
		return (0);
	}
	return (EOF);
}

int
parse_config(char *filename, struct pfctl *xpf)
{
	int		 errors = 0;
	struct sym	*sym;

	pf = xpf;
	returnicmpdefault = (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
	returnicmp6default =
	    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
	blockpolicy = PFRULE_DROP;

	if ((file = pushfile(filename, 0)) == NULL) {
		warn("cannot open the main config file!");
		return (-1);
	}

	yyparse();
	errors = file->errors;
	popfile();

	/* Free macros and check which have not been used. */
	while ((sym = TAILQ_FIRST(&symhead))) {
		if ((pf->opts & PF_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entry);
		free(sym);
	}

	return (errors ? -1 : 0);
}

int
symset(const char *nam, const char *val, int persist)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0)
			break;
	}

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entry);
			free(sym);
		}
	}
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entry);
	return (0);
}

int
pfctl_cmdline_symset(char *s)
{
	char	*sym, *val;
	int	 ret;

	if ((val = strrchr(s, '=')) == NULL)
		return (-1);

	if ((sym = malloc(strlen(s) - strlen(val) + 1)) == NULL)
		err(1, "pfctl_cmdline_symset: malloc");

	strlcpy(sym, s, strlen(s) - strlen(val) + 1);

	ret = symset(sym, val + 1, 1);
	free(sym);

	return (ret);
}

char *
symget(const char *nam)
{
	struct sym	*sym;

	TAILQ_FOREACH(sym, &symhead, entry) {
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
	}
	return (NULL);
}

void
mv_rules(struct pf_ruleset *src, struct pf_ruleset *dst)
{
	struct pf_rule *r;

	while ((r = TAILQ_FIRST(src->rules.active.ptr)) != NULL) {
		TAILQ_REMOVE(src->rules.active.ptr, r, entries);
		TAILQ_INSERT_TAIL(dst->rules.active.ptr, r, entries);
		dst->anchor->match++;
	}
	src->anchor->match = 0;
	while ((r = TAILQ_FIRST(src->rules.inactive.ptr)) != NULL) {
		TAILQ_REMOVE(src->rules.inactive.ptr, r, entries);
		TAILQ_INSERT_TAIL(dst->rules.inactive.ptr, r, entries);
	}
}

void
decide_address_family(struct node_host *n, sa_family_t *af)
{
	if (*af != 0 || n == NULL)
		return;
	*af = n->af;
	while ((n = n->next) != NULL) {
		if (n->af != *af) {
			*af = 0;
			return;
		}
	}
}

int
invalid_redirect(struct node_host *nh, sa_family_t af)
{
	if (!af) {
		struct node_host *n;

		/* tables and dyniftl are ok without an address family */
		for (n = nh; n != NULL; n = n->next) {
			if (n->addr.type != PF_ADDR_TABLE &&
			    n->addr.type != PF_ADDR_DYNIFTL) {
				yyerror("address family not given and "
				    "translation address expands to multiple "
				    "address families");
				return (1);
			}
		}
	}
	if (nh == NULL) {
		yyerror("no translation address with matching address family "
		    "found.");
		return (1);
	}
	return (0);
}

int
atoul(char *s, u_long *ulvalp)
{
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
		return (-1);
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
}

int
getservice(char *n)
{
	struct servent	*s;
	u_long		 ulval;

	if (atoul(n, &ulval) == 0) {
		if (ulval > 65535) {
			yyerror("illegal port value %lu", ulval);
			return (-1);
		}
		return (htons(ulval));
	} else {
		s = getservbyname(n, "tcp");
		if (s == NULL)
			s = getservbyname(n, "udp");
		if (s == NULL) {
			yyerror("unknown port %s", n);
			return (-1);
		}
		return (s->s_port);
	}
}

int
rule_label(struct pf_rule *r, char *s)
{
	if (s) {
		if (strlcpy(r->label, s, sizeof(r->label)) >=
		    sizeof(r->label)) {
			yyerror("rule label too long (max %d chars)",
			    sizeof(r->label)-1);
			return (-1);
		}
	}
	return (0);
}

u_int16_t
parseicmpspec(char *w, sa_family_t af)
{
	const struct icmpcodeent	*p;
	u_long				 ulval;
	u_int8_t			 icmptype;

	if (af == AF_INET)
		icmptype = returnicmpdefault >> 8;
	else
		icmptype = returnicmp6default >> 8;

	if (atoul(w, &ulval) == -1) {
		if ((p = geticmpcodebyname(icmptype, w, af)) == NULL) {
			yyerror("unknown icmp code %s", w);
			return (0);
		}
		ulval = p->code;
	}
	if (ulval > 255) {
		yyerror("invalid icmp code %lu", ulval);
		return (0);
	}
	return (icmptype << 8 | ulval);
}

int
parseport(char *port, struct range *r, int extensions)
{
	char	*p = strchr(port, ':');

	if (p == NULL) {
		if ((r->a = getservice(port)) == -1)
			return (-1);
		r->b = 0;
		r->t = PF_OP_NONE;
		return (0);
	}
	if ((extensions & PPORT_STAR) && !strcmp(p+1, "*")) {
		*p = 0;
		if ((r->a = getservice(port)) == -1)
			return (-1);
		r->b = 0;
		r->t = PF_OP_IRG;
		return (0);
	}
	if ((extensions & PPORT_RANGE)) {
		*p++ = 0;
		if ((r->a = getservice(port)) == -1 ||
		    (r->b = getservice(p)) == -1)
			return (-1);
		if (r->a == r->b) {
			r->b = 0;
			r->t = PF_OP_NONE;
		} else
			r->t = PF_OP_RRG;
		return (0);
	}
	return (-1);
}

int
pfctl_load_anchors(int dev, struct pfctl *pf, struct pfr_buffer *trans)
{
	struct loadanchors	*la;

	TAILQ_FOREACH(la, &loadanchorshead, entries) {
		if (pf->opts & PF_OPT_VERBOSE)
			fprintf(stderr, "\nLoading anchor %s from %s\n",
			    la->anchorname, la->filename);
		if (pfctl_rules(dev, la->filename, pf->opts, pf->optimize,
		    la->anchorname, trans) == -1)
			return (-1);
	}

	return (0);
}

int
kw_casecmp(const void *k, const void *e)
{
	return (strcasecmp(k, ((const struct keywords *)e)->k_name));
}

int
map_tos(char *s, int *val)
{
	/* DiffServ Codepoints and other TOS mappings */
	const struct keywords	 toswords[] = {
		{ "af11",		IPTOS_DSCP_AF11 },
		{ "af12",		IPTOS_DSCP_AF12 },
		{ "af13",		IPTOS_DSCP_AF13 },
		{ "af21",		IPTOS_DSCP_AF21 },
		{ "af22",		IPTOS_DSCP_AF22 },
		{ "af23",		IPTOS_DSCP_AF23 },
		{ "af31",		IPTOS_DSCP_AF31 },
		{ "af32",		IPTOS_DSCP_AF32 },
		{ "af33",		IPTOS_DSCP_AF33 },
		{ "af41",		IPTOS_DSCP_AF41 },
		{ "af42",		IPTOS_DSCP_AF42 },
		{ "af43",		IPTOS_DSCP_AF43 },
		{ "critical",		IPTOS_PREC_CRITIC_ECP },
		{ "cs0",		IPTOS_DSCP_CS0 },
		{ "cs1",		IPTOS_DSCP_CS1 },
		{ "cs2",		IPTOS_DSCP_CS2 },
		{ "cs3",		IPTOS_DSCP_CS3 },
		{ "cs4",		IPTOS_DSCP_CS4 },
		{ "cs5",		IPTOS_DSCP_CS5 },
		{ "cs6",		IPTOS_DSCP_CS6 },
		{ "cs7",		IPTOS_DSCP_CS7 },
		{ "ef",			IPTOS_DSCP_EF },
		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
		{ "lowdelay",		IPTOS_LOWDELAY },
		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
		{ "reliability",	IPTOS_RELIABILITY },
		{ "throughput",		IPTOS_THROUGHPUT }
	};
	const struct keywords	*p;

	p = bsearch(s, toswords, sizeof(toswords)/sizeof(toswords[0]),
	    sizeof(toswords[0]), kw_casecmp);

	if (p) {
		*val = p->k_val;
		return (1);
	}
	return (0);
}
@


1.662
log
@Allow HFSC classes to use flow queues

The FQ-CoDel related configuration (flows, quantum) becomes available
for the regular bandwidth queue.  Internally the kernel will pick the
FQ-CoDel for use as a queue manager for the specified class instead of
the FIFO.

Discussed with and OK henning@@ at d2k17 as a part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.661 2017/07/19 12:51:30 mikeb Exp $	*/
d345 1
a345 1
int		 process_tabledef(char *, struct table_opts *);
d1179 1
a1179 1
			if (process_tabledef($3, &$5)) {
d2038 1
a2038 1
			if ((filter_opts.divert.addr = host($2)) == NULL) {
d2673 1
a2673 1
			if (($$ = host($1)) == NULL)	{
d2685 2
a2686 1
			if ((b = host($1)) == NULL || (e = host($3)) == NULL) {
d2722 1
a2722 1
			if (($$ = host(buf)) == NULL)	{
d2736 1
a2736 1
			if (($$ = host(buf)) == NULL)	{
d3726 1
a3726 1
				if (($$ = host($1)) == NULL)	{
d3748 1
a3748 1
			if (($$ = host(buf)) == NULL)	{
d4084 1
a4084 1
process_tabledef(char *name, struct table_opts *opts)
d4093 1
a4093 1
			if (pfr_buf_load(&ab, ti->file, 0)) {
@


1.661
log
@Rework HFSC vs FQ-CoDel checks

The selection mechanism introduced in pf_ioctl.c -r1.316 suffers
from being too ambiguous and lacks robustness. Instead of relying
on composition of multiple flags in the queue specification, it's
easier to identify the root class (if it exists) and derive all
further checks from it.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.660 2017/05/28 15:15:21 akfaew Exp $	*/
a1326 5
			if (queue_opts.marker & QOM_FLOWS) {
				yyerror("bandwidth cannot be specified for "
				    "a flow queue");
				YYERROR;
			}
a1362 5
				YYERROR;
			}
			if (queue_opts.marker & QOM_BWSPEC) {
				yyerror("bandwidth cannot be specified for "
				    "a flow queue");
@


1.660
log
@Don't check np->port for NULL - it's an array, it's never NULL.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.659 2017/05/15 11:23:25 mikeb Exp $	*/
d398 1
a398 1
		u_int16_t		 weight;		
a1306 4
			if ($2[0] == '_') {
				yyerror("queue names must not start with _");
				YYERROR;
			}
d4342 5
a4346 2
		if ((opts->flags & PFQS_FLOWQUEUE) && opts->parent) {
			yyerror("discipline doesn't support hierarchy");
@


1.659
log
@Hook up FQ-CoDel to the tree and enable configuration in the pfctl(8)

OK sthen, visa
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.658 2017/04/28 14:15:45 mikeb Exp $	*/
d4599 1
a4599 1
		if (!rs->rdr->rport.b && rs->rdr->rport.t && np->port != NULL) {
@


1.658
log
@Remove double assignments
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.657 2017/01/05 12:42:18 krw Exp $	*/
a38 1
#include <net/hfsc.h>
d308 7
d321 2
d326 1
d471 1
a471 1
%token	WEIGHT BANDWIDTH
d1331 5
d1355 1
a1355 1
			queue_opts.flags |= HFSC_DEFAULTCLASS;
d1357 1
a1357 1
		| QLIMIT NUMBER	{
d1369 31
d4346 4
d4383 5
d5042 1
d5094 1
@


1.657
log
@Replace symset()'s hand-rolled for(;;) traversal of 'symhead' TAILQ
with more modern TAILQ_FOREACH(). This what symget() was already
doing.

Add paranoia '{}' around body of symget()'s TAILQ_FOREACH().

No intentional functional change.

ok bluhm@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.656 2016/11/23 12:13:23 bluhm Exp $	*/
a4370 1
		n = ds->addr;
a5443 1
	errors = 0;
@


1.656
log
@Explicitly forbid to combine af-to with route-to in pfctl.  The
parser cannot handle that correctly and is is unclear wether the
kernel code would work.  Remove the feature until someone needs it
and properly implements and tests it.
OK mike@@ sashan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.655 2016/08/26 06:06:58 guenther Exp $	*/
d5479 4
a5482 3
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entry))
		;	/* nothing */
d5539 1
a5539 1
	TAILQ_FOREACH(sym, &symhead, entry)
d5544 1
@


1.655
log
@Add <time.h> for time(); sort <*.h> includes

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.654 2016/07/18 15:21:33 henning Exp $	*/
d1531 5
@


1.654
log
@g/c unused (global!) var: oqueues isn't used any more. ALTQ leftover; not
noticed since struct node_queue stayed. ok claudio benno gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.652 2016/06/21 21:35:24 benno Exp $	*/
d658 1
a658 1
				yyerror("error setting debuglevel debug");
@


1.653
log
@Add curly braces that were missed in rev 1.651.  Add parenthesis to make the
condition in the if statement more readable while I'm there.

ok phessler@@, benno@@, florian@@
@
text
@d184 1
a184 1
}	*oqueues = NULL;
@


1.652
log
@do not allow whitespace in macro names, i.e. "this is" = "a variable".
change this in all config parsers in our tree that support macros.
problem reported by sven falempin.

feedback from henning@@, stsp@@, deraadt@@
ok florian@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.651 2016/06/21 13:40:43 benno Exp $	*/
d1529 1
a1529 1
			if ($8.marker & FOM_AFTO && r.direction != PF_IN)
d1532 1
@


1.651
log
@the manpage documents that af-to does not work on pass out rules, but
the pf.conf parser allows it, which leads a non working configuration
being loaded.
this changes the parser to make pass out .. af-to an error.

ok henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.650 2016/06/16 15:46:20 henning Exp $	*/
d715 1
d718 7
@


1.650
log
@allow include in inline anchors
with this,
anchor foo {
	include "/path/to/rules"
}
works and "load anchor" is obsolete, to be removed somewhen later after
release.
co-production with reky at bsdcan, ok reyk mikeb benno sasha
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.648 2015/04/21 16:34:59 mikeb Exp $	*/
d1521 3
@


1.649
log
@- route-to, dup-to, reply-to should not override the block action

  Spotted by Dilli Paudel <dilli ! paudel at oracle ! com>

ok jung@@, ok mikeb@@
@
text
@d732 1
@


1.648
log
@Improve divert-to specification parsing w.r.t. rule address family.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.647 2015/02/26 18:27:45 sthen Exp $	*/
d4000 3
a4002 2
	/* match rules rules */
	if (r->action == PF_MATCH) {
d4013 1
a4013 1
			   "must not be used on match rules");
d4020 9
@


1.647
log
@%% not % in error message; ok millert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.646 2015/02/14 23:32:41 sthen Exp $	*/
d212 5
d265 2
a266 4
	struct {
		struct node_host	*addr;
		u_int16_t		port;
	}			 divert, divert_packet;
d348 1
d1856 2
a1857 24
			if ((r.divert.port = $8.divert.port)) {
				if (r.direction == PF_OUT) {
					if ($8.divert.addr) {
						yyerror("address specified "
						    "for outgoing divert");
						YYERROR;
					}
					bzero(&r.divert.addr,
					    sizeof(r.divert.addr));
				} else {
					if (!$8.divert.addr) {
						yyerror("no address specified "
						    "for incoming divert");
						YYERROR;
					}
					if ($8.divert.addr->af != r.af) {
						yyerror("address family "
						    "mismatch for divert");
						YYERROR;
					}
					r.divert.addr =
					    $8.divert.addr->addr.v.a.addr;
				}
			}
d4316 40
@


1.646
log
@Rather than using 0xff as a placeholder for "don't check prio", use 0xff to
mean "prio is 0". This avoids the need for code changes in programs which add
pf rules (as was done in pfctl but not other programs) to handle the new
"check prio" functionality. Specifically this unbreaks ftp-proxy.

Use of #define rather than magic 0xff suggested by benno.
ok benno "if henning doesnt like it he can change it when he recovers from jet-lag"
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.645 2015/02/10 06:45:55 henning Exp $	*/
d1367 1
a1367 1
				yyerror("no bandwidth in % yet");
d1386 1
a1386 1
				yyerror("no bandwidth in % yet");
@


1.645
log
@since we inherit prio (as in, the queuing priority) from outside sources,
i. e. on vlan interfaces, it is useful to be able to match on it -
effectively matching on classification done elsewhere.
i thought i had long implemented that, but chrisz@@ asking for it made
me notice that wasn't the case.
tests by chrisz, ok phessler pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.643 2014/12/19 13:04:07 reyk Exp $	*/
d886 6
a891 4
			if ($9.marker & FOM_PRIO)
				r.prio = $9.prio;
			else
				r.prio = 0xff;
d1495 6
a1500 4
			if ($8.marker & FOM_PRIO)
				r.prio = $8.prio;
			else
				r.prio = 0xff;
@


1.644
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d233 1
d258 1
d886 4
d1493 4
d1926 12
@


1.643
log
@Support source-hash and random with tables and dynifs; not just pools.
This finally allows to use source-hash for dynamic loadbalancing, eg.
"rdr-to <hosts> source-hash", instead of just round-robin and least-states.

An older pre-siphash version of this diff was tested by many people.

OK tedu@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.642 2014/11/20 05:51:20 jsg Exp $	*/
d906 1
a906 1
			    strlen($3) >= MAXPATHLEN) {
d908 1
a908 1
				    $3, MAXPATHLEN - 1);
d915 1
a915 1
			if ((loadanchor->anchorname = malloc(MAXPATHLEN)) ==
d919 1
a919 1
				snprintf(loadanchor->anchorname, MAXPATHLEN,
d922 1
a922 1
				strlcpy(loadanchor->anchorname, $3, MAXPATHLEN);
@


1.642
log
@Don't allow embedded nul characters in strings.
Fixes a pfctl crash with an anchor name containing
an embedded nul found with the afl fuzzer.

pfctl parse.y patch from and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.641 2014/10/27 21:51:32 mikeb Exp $	*/
d1808 3
a1810 7
					if (((r.route.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) &&
					    ((r.route.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_LEASTSTATES)) {
						yyerror("r.route.opts must "
						    "be PF_POOL_ROUNDROBIN "
						    "or PF_POOL_LEASTSTATES");
d4386 2
a4387 4
			    (rs->pool_opts.type != PF_POOL_ROUNDROBIN) &&
			    (rs->pool_opts.type != PF_POOL_LEASTSTATES)) {
				yyerror("only round-robin or "
				    "least-states valid for multiple "
d4485 3
a4487 2
	if (rpool->addr.type == PF_ADDR_TABLE ||
	    DYNIF_MULTIADDR(rpool->addr))
d4490 5
a4494 6
	if (((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN) &&
	    ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_LEASTSTATES) &&
	    (disallow_table(rs->rdr->host, "tables are only supported "
	    "in round-robin or least-states address pools") ||
	    disallow_alias(rs->rdr->host, "interface (%s) is only supported "
	    "in round-robin or least-states address pools")))
@


1.641
log
@Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.640 2014/10/25 03:18:13 lteo Exp $	*/
d5188 3
@


1.640
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.639 2014/09/13 16:06:36 doug Exp $	*/
d4546 1
a4546 1
	struct node_host	*srch, *dsth;
d4637 12
d4799 8
@


1.639
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.638 2014/08/23 00:11:03 pelikan Exp $	*/
a34 1
#include <netinet/in_systm.h>
@


1.638
log
@when you specify queues in a rule, make sure they have been defined.

DIOCADDRULE EBUSY turns into an error message that pfctl -n catches.
DIOCXCOMMIT EINVAL after the kernel rejected the rules was reported
to occur, possibly from hfsc.c: this should be fixed as well.

ok henning mikeb sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.637 2014/08/21 15:09:27 mikeb Exp $	*/
d1155 2
a1156 2
			for (ti = SIMPLEQ_FIRST(&$5.init_nodes);
			    ti != SIMPLEQ_END(&$5.init_nodes); ti = nti) {
@


1.637
log
@deny "once" flags for match rules;  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.636 2014/07/02 13:03:41 mikeb Exp $	*/
d3457 6
d3467 6
d3477 10
@


1.636
log
@condition above makes this part of the check useless;
overlooked in the previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.635 2014/06/30 13:17:17 mikeb Exp $	*/
d1493 6
a1498 1
			if ($8.marker & FOM_ONCE)
d1500 1
@


1.636.4.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.641 2014/10/27 21:51:32 mikeb Exp $	*/
d4519 1
a4519 1
	struct node_host	*srch, *dsth, *osrch, *odsth;
a4609 12
		osrch = odsth = NULL;
		if (src_host->addr.type == PF_ADDR_DYNIFTL) {
			osrch = src_host;
			if ((src_host = gen_dynnode(src_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}
		if (dst_host->addr.type == PF_ADDR_DYNIFTL) {
			odsth = dst_host;
			if ((dst_host = gen_dynnode(dst_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}

a4759 8
		if (osrch && src_host->addr.type == PF_ADDR_DYNIFTL) {
			free(src_host);
			src_host = osrch;
		}
		if (odsth && dst_host->addr.type == PF_ADDR_DYNIFTL) {
			free(dst_host);
			dst_host = odsth;
		}
@


1.635
log
@Merge two loops in collapse_redirspec into one

This lets us do the checks only once and also make smarter decisions
about the rule's own address family.  As a result af-to rules no longer
need to specify the address family after 'pass'.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.634 2014/06/25 15:11:20 mikeb Exp $	*/
d4309 1
a4309 1
			if (r->naf == AF_INET6 && rs->af == AF_INET6)
d4311 1
a4311 1
			else if (r->naf == AF_INET && rs->af == AF_INET)
@


1.634
log
@Make stricter decisions when handling translation specifications.

In particular, disallow specifications containing addresses of
different address families when rule doesn't specify one, for
example "pass out nat-to { ::1 1.1.1.1 }" will now produce an
error instead of silently picking one of the addresses.

sthen and deraadt agree
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.633 2014/05/17 08:12:53 bluhm Exp $	*/
d2035 1
a2035 6
				yyerror("no address family specified");
				YYERROR;
			}
			if ($4->host->af && $4->host->af != $2) {
				yyerror("af-to addresses must be in the "
				    "target address family");
d3487 1
a3487 1
				yyerror("only addresses can be listed for"
d4293 1
a4293 1
	struct node_host *h;
d4295 1
a4295 1
	int af = 0, i = 0;
a4304 1
	/* count matching addresses */
d4306 11
a4316 7
		if (h->af) {
			/* check that af-to target address has correct af */
			if (rs->af && rs->af != h->af) {
				yyerror("af mismatch in %s spec",
				    allow_if ? "routing" : "translation");
				return (1);
			}
d4318 1
a4318 2
			if ((r->af && r->af != h->af) && /* exclude af-to */
			    !(r->naf && h->af == r->naf))
d4321 2
a4322 2
			 * fail if the chosen af is not universal for the
			 * whole supplied redirect address pool
d4330 1
a4330 4
			if (!r->af)
				af = h->af;
			i++;
		} else {
d4332 2
a4333 2
			 * we silently allow any not af-specific host specs,
			 * e.g. (em0) and let the kernel deal with them
d4335 6
a4340 1
			i++;
d4342 8
a4349 4
	}
	/* set rule af to one chosen above */
	if (!r->af && af)
		r->af = af;
d4351 22
a4372 32
	if (i == 0) {		/* no pool address */
		yyerror("af mismatch in %s spec",
		    allow_if ? "routing" : "translation");
		return (1);
	} else if (i == 1) {	/* only one address */
		for (h = rs->rdr->host; h != NULL; h = h->next)
			if (!h->af || !r->af || rs->af || r->af == h->af ||
			    (r->naf && r->naf == h->af))
				break;
		rpool->addr = h->addr;
		if (!allow_if && h->ifname) {
			yyerror("@@if not permitted for translation");
			return (1);
		}
		if (h->ifname && strlcpy(rpool->ifname, h->ifname,
		    sizeof(rpool->ifname)) >= sizeof(rpool->ifname))
			errx(1, "collapse_redirspec: strlcpy");

		return (0);
	} else {		/* more than one address */
		if (rs->pool_opts.type &&
		    (rs->pool_opts.type != PF_POOL_ROUNDROBIN) &&
		    (rs->pool_opts.type != PF_POOL_LEASTSTATES)) {
			yyerror("only round-robin or "
			    "least-states valid for multiple "
			    "translation or routing addresses");
			return (1);
		}
		for (h = rs->rdr->host; h != NULL; h = h->next) {
			if (!rs->af && r->af != h->af)
				continue;
			if (h->addr.type != PF_ADDR_ADDRMASK &&
d4382 14
d4403 9
@


1.633
log
@When parsing a numerical value for the TOS bits, make sure that it
is in a valid range.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.632 2014/04/19 14:22:32 henning Exp $	*/
d4300 1
a4300 1
	int	i = 0;
d4312 23
a4334 1
		if (!r->af || !h->af || rs->af || h->af == r->af) {
d4336 5
a4340 3
			if (h->af && !r->af)
				r->af = h->af;
		} else if (r->naf && h->af == r->naf)
d4342 1
d4344 3
d4728 1
@


1.632
log
@remove altq bits here, too
(i was convinced i committed that yesterday already, hrm)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.631 2014/01/22 00:21:16 henning Exp $	*/
d3214 2
d3218 6
a3223 3
			else if ($1[0] == '0' && $1[1] == 'x')
				$$ = strtoul($1, NULL, 16);
			else
d3225 1
a3225 1
			if ($$ > 255) {
d3234 2
a3235 2
			if ($$ > 255) {
				yyerror("illegal tos value %lu", $1);
@


1.631
log
@relax the cfg file secrecy check slightly to allow group readability
default permissions and mtree NOT changed.
prodded by benno, ok phessler benno jmatthew theo pelikan florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.630 2014/01/21 01:51:55 henning Exp $	*/
a41 4
#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>
a318 14
struct oldqueue_opts {
	int			marker;
#define OQOM_BWSPEC	0x01
#define OQOM_SCHEDULER	0x02
#define OQOM_PRIORITY	0x04
#define OQOM_TBRSIZE	0x08
#define OQOM_QLIMIT	0x10
	struct node_queue_bw	queue_bwspec;
	struct node_queue_opt	scheduler;
	int			priority;
	int			tbrsize;
	int			qlimit;
} oldqueue_opts;

a355 6
int		 expand_altq(struct pf_altq *, struct node_if *,
		    struct node_queue *, struct node_queue_bw bwspec,
		    struct node_queue_opt *);
int		 expand_oldqueue(struct pf_altq *, struct node_if *,
		    struct node_queue *, struct node_queue_bw,
		    struct node_queue_opt *);
a428 1
		struct oldqueue_opts	 oldqueue_opts;
d457 2
a458 3
%token	WEIGHT
%token	ALTQ CBQ PRIQ HFSC BANDWIDTH TBRSIZE LINKSHARE REALTIME UPPERLIMIT
%token	QUEUE OLDQUEUE PRIORITY QLIMIT RTABLE RDOMAIN MINIMUM BURST PARENT
a501 5
%type	<v.queue>		qassign qassign_list qassign_item
%type	<v.queue_options>	scheduler
%type	<v.number>		cbqflags_list cbqflags_item
%type	<v.number>		priqflags_list priqflags_item
%type	<v.hfsc_opts>		hfscopts_list hfscopts_item hfsc_opts
a507 1
%type	<v.oldqueue_opts>	oldqueue_opts oldqueue_opt oldqueue_opts_l
a520 2
		| ruleset altqif '\n'
		| ruleset oldqueuespec '\n'
a1384 129
altqif		: ALTQ interface oldqueue_opts QUEUE qassign {
			struct pf_altq	a;

			memset(&a, 0, sizeof(a));
			if ($3.scheduler.qtype == ALTQT_NONE) {
				yyerror("no scheduler specified!");
				YYERROR;
			}
			a.scheduler = $3.scheduler.qtype;
			a.qlimit = $3.qlimit;
			a.tbrsize = $3.tbrsize;
			if ($5 == NULL) {
				yyerror("no child queues specified");
				YYERROR;
			}
			if (expand_altq(&a, $2, $5, $3.queue_bwspec,
			    &$3.scheduler))
				YYERROR;
		}
		;

oldqueuespec	: OLDQUEUE STRING interface oldqueue_opts qassign {
			struct pf_altq	a;

			memset(&a, 0, sizeof(a));
			if (strlcpy(a.qname, $2, sizeof(a.qname)) >=
			    sizeof(a.qname)) {
				yyerror("queue name too long (max "
				    "%d chars)", PF_QNAME_SIZE-1);
				free($2);
				YYERROR;
			}
			free($2);
			if ($4.tbrsize) {
				yyerror("cannot specify tbrsize for queue");
				YYERROR;
			}
			if ($4.priority > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			a.priority = $4.priority;
			a.qlimit = $4.qlimit;
			a.scheduler = $4.scheduler.qtype;
			if (expand_oldqueue(&a, $3, $5, $4.queue_bwspec,
			    &$4.scheduler)) {
				yyerror("errors in queue definition");
				YYERROR;
			}
		}
		;

oldqueue_opts	:	{
			bzero(&oldqueue_opts, sizeof oldqueue_opts);
			oldqueue_opts.priority = DEFAULT_PRIORITY;
			oldqueue_opts.qlimit = DEFAULT_QLIMIT;
			oldqueue_opts.scheduler.qtype = ALTQT_NONE;
			oldqueue_opts.queue_bwspec.bw_percent = 100;
		}
		    oldqueue_opts_l
			{ $$ = oldqueue_opts; }
		| /* empty */ {
			bzero(&oldqueue_opts, sizeof oldqueue_opts);
			oldqueue_opts.priority = DEFAULT_PRIORITY;
			oldqueue_opts.qlimit = DEFAULT_QLIMIT;
			oldqueue_opts.scheduler.qtype = ALTQT_NONE;
			oldqueue_opts.queue_bwspec.bw_percent = 100;
			$$ = oldqueue_opts;
		}
		;

oldqueue_opts_l	: oldqueue_opts_l oldqueue_opt
		| oldqueue_opt
		;

oldqueue_opt	: BANDWIDTH bandwidth	{
			if (oldqueue_opts.marker & OQOM_BWSPEC) {
				yyerror("bandwidth cannot be respecified");
				YYERROR;
			}
			oldqueue_opts.marker |= OQOM_BWSPEC;
			oldqueue_opts.queue_bwspec = $2;
		}
		| PRIORITY NUMBER	{
			if (oldqueue_opts.marker & OQOM_PRIORITY) {
				yyerror("priority cannot be respecified");
				YYERROR;
			}
			if ($2 < 0 || $2 > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			oldqueue_opts.marker |= OQOM_PRIORITY;
			oldqueue_opts.priority = $2;
		}
		| QLIMIT NUMBER	{
			if (oldqueue_opts.marker & OQOM_QLIMIT) {
				yyerror("qlimit cannot be respecified");
				YYERROR;
			}
			if ($2 < 0 || $2 > 65535) {
				yyerror("qlimit out of range: max 65535");
				YYERROR;
			}
			oldqueue_opts.marker |= OQOM_QLIMIT;
			oldqueue_opts.qlimit = $2;
		}
		| scheduler	{
			if (oldqueue_opts.marker & OQOM_SCHEDULER) {
				yyerror("scheduler cannot be respecified");
				YYERROR;
			}
			oldqueue_opts.marker |= OQOM_SCHEDULER;
			oldqueue_opts.scheduler = $1;
		}
		| TBRSIZE NUMBER	{
			if (oldqueue_opts.marker & OQOM_TBRSIZE) {
				yyerror("tbrsize cannot be respecified");
				YYERROR;
			}
			if ($2 < 0 || $2 > 65535) {
				yyerror("tbrsize too big: max 65535");
				YYERROR;
			}
			oldqueue_opts.marker |= OQOM_TBRSIZE;
			oldqueue_opts.tbrsize = $2;
		}
		;

a1437 201
scheduler	: CBQ				{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = 0;
		}
		| CBQ '(' cbqflags_list ')'	{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = $3;
		}
		| PRIQ				{
			$$.qtype = ALTQT_PRIQ;
			$$.data.priq_opts.flags = 0;
		}
		| PRIQ '(' priqflags_list ')'	{
			$$.qtype = ALTQT_PRIQ;
			$$.data.priq_opts.flags = $3;
		}
		| HFSC				{
			$$.qtype = ALTQT_HFSC;
			bzero(&$$.data.hfsc_opts,
			    sizeof(struct node_hfsc_opts));
		}
		| HFSC '(' hfsc_opts ')'	{
			$$.qtype = ALTQT_HFSC;
			$$.data.hfsc_opts = $3;
		}
		;

cbqflags_list	: cbqflags_item				{ $$ |= $1; }
		| cbqflags_list comma cbqflags_item	{ $$ |= $3; }
		;

cbqflags_item	: DEFAULT {
			$$ = CBQCLF_DEFCLASS;
		}
		| STRING	{
			if (!strcmp($1, "borrow"))
				$$ = CBQCLF_BORROW;
			else if (!strcmp($1, "red"))
				$$ = CBQCLF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = CBQCLF_RED|CBQCLF_ECN;
			else {
				yyerror("unknown cbq flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

priqflags_list	: priqflags_item			{ $$ |= $1; }
		| priqflags_list comma priqflags_item	{ $$ |= $3; }
		;

priqflags_item	: DEFAULT {
			$$ = PRCF_DEFAULTCLASS;
		}
		| STRING	{
			 if (!strcmp($1, "red"))
				$$ = PRCF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = PRCF_RED|PRCF_ECN;
			else {
				yyerror("unknown priq flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hfsc_opts	:	{
				bzero(&hfsc_opts,
				    sizeof(struct node_hfsc_opts));
			}
		    hfscopts_list				{
			$$ = hfsc_opts;
		}
		;

hfscopts_list	: hfscopts_item
		| hfscopts_list comma hfscopts_item
		;

hfscopts_item	: LINKSHARE bandwidth				{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m2 = $2;
			hfsc_opts.linkshare.used = 1;
		}
		| LINKSHARE '(' bandwidth comma NUMBER comma bandwidth ')'
		    {
			if ($5 < 0 || $5 > INT_MAX) {
				yyerror("timing in curve out of range");
				YYERROR;
			}
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m1 = $3;
			hfsc_opts.linkshare.d = $5;
			hfsc_opts.linkshare.m2 = $7;
			hfsc_opts.linkshare.used = 1;
		}
		| REALTIME bandwidth				{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m2 = $2;
			hfsc_opts.realtime.used = 1;
		}
		| REALTIME '(' bandwidth comma NUMBER comma bandwidth ')'
		    {
			if ($5 < 0 || $5 > INT_MAX) {
				yyerror("timing in curve out of range");
				YYERROR;
			}
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m1 = $3;
			hfsc_opts.realtime.d = $5;
			hfsc_opts.realtime.m2 = $7;
			hfsc_opts.realtime.used = 1;
		}
		| UPPERLIMIT bandwidth				{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m2 = $2;
			hfsc_opts.upperlimit.used = 1;
		}
		| UPPERLIMIT '(' bandwidth comma NUMBER comma bandwidth ')'
		    {
			if ($5 < 0 || $5 > INT_MAX) {
				yyerror("timing in curve out of range");
				YYERROR;
			}
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m1 = $3;
			hfsc_opts.upperlimit.d = $5;
			hfsc_opts.upperlimit.m2 = $7;
			hfsc_opts.upperlimit.used = 1;
		}
		| DEFAULT	{
			hfsc_opts.flags |= HFCF_DEFAULTCLASS;
		}
		| STRING	{
			if (!strcmp($1, "red"))
				hfsc_opts.flags |= HFCF_RED;
			else if (!strcmp($1, "ecn"))
				hfsc_opts.flags |= HFCF_RED|HFCF_ECN;
			else {
				yyerror("unknown hfsc flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

qassign		: /* empty */		{ $$ = NULL; }
		| qassign_item		{ $$ = $1; }
		| '{' optnl qassign_list '}'	{ $$ = $3; }
		;

qassign_list	: qassign_item optnl		{ $$ = $1; }
		| qassign_list comma qassign_item optnl	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

qassign_item	: STRING			{
			$$ = calloc(1, sizeof(struct node_queue));
			if ($$ == NULL)
				err(1, "qassign_item: calloc");
			if (strlcpy($$->queue, $1, sizeof($$->queue)) >=
			    sizeof($$->queue)) {
				yyerror("queue name '%s' too long (max "
				    "%d chars)", $1, sizeof($$->queue)-1);
				free($1);
				free($$);
				YYERROR;
			}
			free($1);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

a4235 106
expand_altq(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
{
	struct pf_altq		 pa, pb;
	char			 qname[PF_QNAME_SIZE];
	struct node_queue	*n;
	struct node_queue_bw	 bw;
	int			 errs = 0;

	LOOP_THROUGH(struct node_if, interface, interfaces,
		memcpy(&pa, a, sizeof(struct pf_altq));
		if (strlcpy(pa.ifname, interface->ifname,
		    sizeof(pa.ifname)) >= sizeof(pa.ifname))
			errx(1, "expand_altq: strlcpy");

		if (interface->not) {
			yyerror("altq on ! <interface> is not supported");
			errs++;
		} else if (interface->use_rdomain) {
			yyerror("altq on rdomain <num> is not supported");
			errs++;
		} else {
			if (eval_pfaltq(pf, &pa, &bwspec, opts))
				errs++;
			else
				if (pfctl_add_altq(pf, &pa))
					errs++;

			if (pf->opts & PF_OPT_VERBOSE) {
				print_altq(&pf->paltq->altq, 0,
				    &bwspec, opts);
				if (nqueues && nqueues->tail) {
					printf("queue { ");
					LOOP_THROUGH(struct node_queue, queue,
					    nqueues,
						printf("%s ",
						    queue->queue);
					);
					printf("}");
				}
				printf("\n");
			}

			if (pa.scheduler == ALTQT_CBQ ||
			    pa.scheduler == ALTQT_HFSC) {
				/* now create a root queue */
				memset(&pb, 0, sizeof(struct pf_altq));
				if (strlcpy(qname, "root_", sizeof(qname)) >=
				    sizeof(qname))
					errx(1, "expand_altq: strlcpy");
				if (strlcat(qname, interface->ifname,
				    sizeof(qname)) >= sizeof(qname))
					errx(1, "expand_altq: strlcat");
				if (strlcpy(pb.qname, qname,
				    sizeof(pb.qname)) >= sizeof(pb.qname))
					errx(1, "expand_altq: strlcpy");
				if (strlcpy(pb.ifname, interface->ifname,
				    sizeof(pb.ifname)) >= sizeof(pb.ifname))
					errx(1, "expand_altq: strlcpy");
				pb.qlimit = pa.qlimit;
				pb.scheduler = pa.scheduler;
				bw.bw_absolute = pa.ifbandwidth;
				bw.bw_percent = 0;
				if (eval_pfqueue(pf, &pb, &bw, opts))
					errs++;
				else
					if (pfctl_add_altq(pf, &pb))
						errs++;
			}

			LOOP_THROUGH(struct node_queue, queue, nqueues,
				n = calloc(1, sizeof(struct node_queue));
				if (n == NULL)
					err(1, "expand_altq: calloc");
				if (pa.scheduler == ALTQT_CBQ ||
				    pa.scheduler == ALTQT_HFSC)
					if (strlcpy(n->parent, qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_altq: strlcpy");
				if (strlcpy(n->queue, queue->queue,
				    sizeof(n->queue)) >= sizeof(n->queue))
					errx(1, "expand_altq: strlcpy");
				if (strlcpy(n->ifname, interface->ifname,
				    sizeof(n->ifname)) >= sizeof(n->ifname))
					errx(1, "expand_altq: strlcpy");
				n->scheduler = pa.scheduler;
				n->next = NULL;
				n->tail = n;
				if (oqueues == NULL)
					oqueues = n;
				else {
					oqueues->tail->next = n;
					oqueues->tail = n;
				}
			);
		}
	);
	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_queue, nqueues);

	return (errs);
}

int
a4288 137
expand_oldqueue(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
{
	struct node_queue	*n, *nq;
	struct pf_altq		 pa;
	u_int8_t		 found = 0;
	u_int8_t		 errs = 0;

	if (oqueues == NULL) {
		yyerror("queue %s has no parent", a->qname);
		FREE_LIST(struct node_queue, nqueues);
		return (1);
	}

	LOOP_THROUGH(struct node_if, interface, interfaces,
		LOOP_THROUGH(struct node_queue, tqueue, oqueues,
			if (!strncmp(a->qname, tqueue->queue, PF_QNAME_SIZE) &&
			    (interface->ifname[0] == 0 ||
			    (!interface->not && !strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)) ||
			    (interface->not && strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)))) {
				/* found ourself in queues */
				found++;

				memcpy(&pa, a, sizeof(struct pf_altq));

				if (pa.scheduler != ALTQT_NONE &&
				    pa.scheduler != tqueue->scheduler) {
					yyerror("exactly one scheduler type "
					    "per interface allowed");
					return (1);
				}
				pa.scheduler = tqueue->scheduler;

				/* scheduler dependent error checking */
				switch (pa.scheduler) {
				case ALTQT_PRIQ:
					if (nqueues != NULL) {
						yyerror("priq queues cannot "
						    "have child queues");
						return (1);
					}
					if (bwspec.bw_absolute > 0 ||
					    bwspec.bw_percent < 100) {
						yyerror("priq doesn't take "
						    "bandwidth");
						return (1);
					}
					break;
				default:
					break;
				}

				if (strlcpy(pa.ifname, tqueue->ifname,
				    sizeof(pa.ifname)) >= sizeof(pa.ifname))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(pa.parent, tqueue->parent,
				    sizeof(pa.parent)) >= sizeof(pa.parent))
					errx(1, "expand_queue: strlcpy");

				if (eval_pfqueue(pf, &pa, &bwspec, opts))
					errs++;
				else
					if (pfctl_add_altq(pf, &pa))
						errs++;

				for (nq = nqueues; nq != NULL; nq = nq->next) {
					if (!strcmp(a->qname, nq->queue)) {
						yyerror("queue cannot have "
						    "itself as child");
						errs++;
						continue;
					}
					n = calloc(1,
					    sizeof(struct node_queue));
					if (n == NULL)
						err(1, "expand_queue: calloc");
					if (strlcpy(n->parent, a->qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->queue, nq->queue,
					    sizeof(n->queue)) >=
					    sizeof(n->queue))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->ifname, tqueue->ifname,
					    sizeof(n->ifname)) >=
					    sizeof(n->ifname))
						errx(1, "expand_queue strlcpy");
					n->scheduler = tqueue->scheduler;
					n->next = NULL;
					n->tail = n;
					if (oqueues == NULL)
						oqueues = n;
					else {
						oqueues->tail->next = n;
						oqueues->tail = n;
					}
				}
				if ((pf->opts & PF_OPT_VERBOSE) && (
				    (found == 1 && interface->ifname[0] == 0) ||
				    (found > 0 && interface->ifname[0] != 0))) {
					print_queue(&pf->paltq->altq, 0,
					    &bwspec, interface->ifname[0] != 0,
					    opts);
					if (nqueues && nqueues->tail) {
						printf("{ ");
						LOOP_THROUGH(struct node_queue,
						    queue, nqueues,
							printf("%s ",
							    queue->queue);
						);
						printf("}");
					}
					printf("\n");
				}
			}
		);
	);

	FREE_LIST(struct node_queue, nqueues);
	FREE_LIST(struct node_if, interfaces);

	if (!found) {
		yyerror("queue %s has no parent", a->qname);
		errs++;
	}

	if (errs)
		return (1);
	else
		return (0);
}

int
a4800 1
		{ "altq",		ALTQ},
a4809 1
		{ "cbq",		CBQ},
a4827 1
		{ "hfsc",		HFSC},
a4839 1
		{ "linkshare",		LINKSHARE},
a4858 1
		{ "oldqueue",		OLDQUEUE},
a4869 2
		{ "priority",		PRIORITY},
		{ "priq",		PRIQ},
a4878 1
		{ "realtime",		REALTIME},
a4906 1
		{ "tbrsize",		TBRSIZE},
a4910 1
		{ "upperlimit",		UPPERLIMIT},
@


1.631.4.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.641 2014/10/27 21:51:32 mikeb Exp $	*/
d5077 1
a5077 1
	struct node_host	*srch, *dsth, *osrch, *odsth;
a5167 12
		osrch = odsth = NULL;
		if (src_host->addr.type == PF_ADDR_DYNIFTL) {
			osrch = src_host;
			if ((src_host = gen_dynnode(src_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}
		if (dst_host->addr.type == PF_ADDR_DYNIFTL) {
			odsth = dst_host;
			if ((dst_host = gen_dynnode(dst_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}

a5316 8
		if (osrch && src_host->addr.type == PF_ADDR_DYNIFTL) {
			free(src_host);
			src_host = osrch;
		}
		if (odsth && dst_host->addr.type == PF_ADDR_DYNIFTL) {
			free(dst_host);
			dst_host = odsth;
		}
@


1.630
log
@if_item can be "any" now.
allows things like
block out on $someif received-on any
to prevent packets to get forwarded to $someif
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.629 2014/01/20 02:59:13 henning Exp $	*/
d5824 2
a5825 2
	if (st.st_mode & (S_IRWXG | S_IRWXO)) {
		warnx("%s: group/world readable/writeable", fname);
@


1.629
log
@support "!received-on <interface>", ok dlg benno
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.627 2013/11/22 04:12:48 deraadt Exp $	*/
d2765 9
@


1.628
log
@use u_char for buffers in yylex, for ctype calls
found by millert@@, ok deraadt@@
@
text
@d2487 1
a2487 1
		| RECEIVEDON if_item {
d2492 2
a2493 1
			filter_opts.rcv = $2;
d5183 1
@


1.627
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.626 2013/10/17 19:59:54 henning Exp $	*/
d5539 1
a5539 1
char	*parsebuf;
d5541 1
a5541 1
char	 pushback_buffer[MAXPUSHBACK];
d5633 2
a5634 2
	char	 buf[8096];
	char	*p, *val;
d5657 1
a5657 1
				*p++ = (char)c;
d5702 1
a5702 1
			*p++ = (char)c;
@


1.626
log
@cannot have queue definitions inside anchors.
don't attempt to load them and err out if we run into one
ran into by Gregor Best <gbe@@@@ring0.de>, analysis & fix your's truly
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.625 2013/10/12 12:16:11 henning Exp $	*/
d468 1
a468 1
	!isdigit((addr).v.ifname[strlen((addr).v.ifname)-1])))
d3115 1
a3115 1
			if (!isalpha(op[0])) {
@


1.625
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.624 2013/08/01 19:03:11 mikeb Exp $	*/
d4738 4
a4741 1
		pfctl_add_queue(pf, &qspec);
@


1.624
log
@Provide local implementations of if_nametoindex(3) and if_indextoname(3)
that make use of the cache of addresses populated by the ifa_load on
startup to save the trouble of calling expensive getaddrinfo(3) up to
four times per rule.   Performance wise this change provides a speed up
factor of 20 with a 11k line ruleset on a machine with 150 VLANs and 250
IP addresses (20 seconds down to 1 in this case).

"wow!" henning, ok benno, florian
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.623 2013/06/01 21:51:54 henning Exp $	*/
d7 1
a7 1
 * Copyright (c) 2002,2003 Henning Brauer. All rights reserved.
d40 1
d189 1
a189 1
}	*queues = NULL;
d303 6
d310 14
d325 5
a329 5
#define QOM_BWSPEC	0x01
#define QOM_SCHEDULER	0x02
#define QOM_PRIORITY	0x04
#define QOM_TBRSIZE	0x08
#define QOM_QLIMIT	0x10
d335 1
a335 1
} queue_opts;
d373 1
d377 1
a377 1
int		 expand_queue(struct pf_altq *, struct node_if *,
d449 1
d453 1
d484 2
a485 2
%token	QUEUE PRIORITY QLIMIT RTABLE RDOMAIN
%token	LOAD RULESET_OPTIMIZATION RTABLE RDOMAIN PRIO ONCE
d537 3
a539 1
%type	<v.queue_opts>		queue_opts queue_opt queue_opts_l
d552 1
d554 1
a554 1
		| ruleset queuespec '\n'
d1307 113
a1419 1
altqif		: ALTQ interface queue_opts QUEUE qassign {
d1440 1
a1440 1
queuespec	: QUEUE STRING interface queue_opts qassign {
d1463 1
a1463 1
			if (expand_queue(&a, $3, $5, $4.queue_bwspec,
d1471 6
a1476 6
queue_opts	:	{
			bzero(&queue_opts, sizeof queue_opts);
			queue_opts.priority = DEFAULT_PRIORITY;
			queue_opts.qlimit = DEFAULT_QLIMIT;
			queue_opts.scheduler.qtype = ALTQT_NONE;
			queue_opts.queue_bwspec.bw_percent = 100;
d1478 2
a1479 2
		    queue_opts_l
			{ $$ = queue_opts; }
d1481 6
a1486 6
			bzero(&queue_opts, sizeof queue_opts);
			queue_opts.priority = DEFAULT_PRIORITY;
			queue_opts.qlimit = DEFAULT_QLIMIT;
			queue_opts.scheduler.qtype = ALTQT_NONE;
			queue_opts.queue_bwspec.bw_percent = 100;
			$$ = queue_opts;
d1490 2
a1491 2
queue_opts_l	: queue_opts_l queue_opt
		| queue_opt
d1494 2
a1495 2
queue_opt	: BANDWIDTH bandwidth	{
			if (queue_opts.marker & QOM_BWSPEC) {
d1499 2
a1500 2
			queue_opts.marker |= QOM_BWSPEC;
			queue_opts.queue_bwspec = $2;
d1503 1
a1503 1
			if (queue_opts.marker & QOM_PRIORITY) {
d1511 2
a1512 2
			queue_opts.marker |= QOM_PRIORITY;
			queue_opts.priority = $2;
d1515 1
a1515 1
			if (queue_opts.marker & QOM_QLIMIT) {
d1523 2
a1524 2
			queue_opts.marker |= QOM_QLIMIT;
			queue_opts.qlimit = $2;
d1527 1
a1527 1
			if (queue_opts.marker & QOM_SCHEDULER) {
d1531 2
a1532 2
			queue_opts.marker |= QOM_SCHEDULER;
			queue_opts.scheduler = $1;
d1535 1
a1535 1
			if (queue_opts.marker & QOM_TBRSIZE) {
d1543 2
a1544 2
			queue_opts.marker |= QOM_TBRSIZE;
			queue_opts.tbrsize = $2;
d1556 9
d1567 1
a1567 1
				else if (!strcmp(cp, "Kb"))
d1569 1
a1569 1
				else if (!strcmp(cp, "Mb"))
d1571 1
a1571 1
				else if (!strcmp(cp, "Gb"))
d1583 1
a1583 1
					yyerror("unknown unit %s", cp);
d1632 5
a1636 4
cbqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = CBQCLF_DEFCLASS;
			else if (!strcmp($1, "borrow"))
d1655 5
a1659 4
priqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = PRCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
d1754 3
d1758 1
a1758 3
			if (!strcmp($1, "default"))
				hfsc_opts.flags |= HFCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
d4680 2
a4681 2
				if (queues == NULL)
					queues = n;
d4683 2
a4684 2
					queues->tail->next = n;
					queues->tail = n;
d4696 51
a4746 1
expand_queue(struct pf_altq *a, struct node_if *interfaces,
d4755 1
a4755 1
	if (queues == NULL) {
d4762 1
a4762 1
		LOOP_THROUGH(struct node_queue, tqueue, queues,
d4840 2
a4841 2
					if (queues == NULL)
						queues = n;
d4843 2
a4844 2
						queues->tail->next = n;
						queues->tail = n;
d5403 1
d5407 1
d5448 1
d5456 1
d5463 1
@


1.623
log
@remove set-tos backwards compat, moved into the set {} block a year ago
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.621 2013/01/16 01:49:20 henning Exp $	*/
d4914 1
a4914 1
		    src_host->ifindex != if_nametoindex(interface->ifname)) ||
d4916 1
a4916 1
		    dst_host->ifindex != if_nametoindex(interface->ifname)))
d4926 1
a4926 1
		else if (if_indextoname(src_host->ifindex, ifname))
d4928 1
a4928 1
		else if (if_indextoname(dst_host->ifindex, ifname))
@


1.623.2.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.641 2014/10/27 21:51:32 mikeb Exp $	*/
d4863 1
a4863 1
	struct node_host	*srch, *dsth, *osrch, *odsth;
a4953 12
		osrch = odsth = NULL;
		if (src_host->addr.type == PF_ADDR_DYNIFTL) {
			osrch = src_host;
			if ((src_host = gen_dynnode(src_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}
		if (dst_host->addr.type == PF_ADDR_DYNIFTL) {
			odsth = dst_host;
			if ((dst_host = gen_dynnode(dst_host, r->af)) == NULL)
				err(1, "expand_rule: calloc");
		}

a5101 8
		if (osrch && src_host->addr.type == PF_ADDR_DYNIFTL) {
			free(src_host);
			src_host = osrch;
		}
		if (odsth && dst_host->addr.type == PF_ADDR_DYNIFTL) {
			free(dst_host);
			dst_host = odsth;
		}
@


1.622
log
@When a PF rule contains 'set tos' *followed by* a scrub option, the tos
value is changed to 0x00. Left-over from the previous implementation where
set-tos was part of "scrub". Problem reported by Jason Mader, ok henning
@
text
@d464 1
a464 1
%token	TAGGED TAG IFBOUND FLOATING STATEPOLICY STATEDEFAULTS ROUTE SETTOS
a982 8
		| SETTOS tos {	/* XXX remove in 5.3-current */
			if (scrub_opts.marker & FOM_SETTOS) {
				yyerror("set-tos cannot be respecified");
				YYERROR;
			}
			scrub_opts.marker |= FOM_SETTOS;
			scrub_opts.settos = $2;
		}
a5288 1
		{ "set-tos",		SETTOS},
@


1.621
log
@for consistency with prio etc, the queue assignment really belongs
into the set block. so make pfctl accept, print and the manpage document
.  match set queue foo
instead of
.  match queue foo
but keep accepting the old way without the explicit set.
ok bob, man jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.619 2012/09/18 10:11:52 henning Exp $	*/
a2234 1
			filter_opts.settos = $3.settos;
@


1.620
log
@Disallow tables and interface address pools for rdr-to, nat-to and
route-to with any other scheduling algorithms than round-robin or
least-states.  Before this change, pfctl accepted and loaded invalid
address pools, eg. "rdr-to <table> source-hash", but it is not
supported by the kernel and was silently ignored in operation.

Also clarify the manpage a bit by mentioning that tables are only
valid with round-robin or least-states.

ok zinke@@
@
text
@d2375 7
@


1.619
log
@prio 0 is valid, therefore, I chose an "impossible" value for prio meaning
"not set" and used a PF_PRIO_NOTSET define for it. now that means that
everything that creates a struct pf_rule doesn't get away with bzero'ing it,
which turned out to be not so nice. so get rid of PF_PRIO_NOTSET, instead,
make a rule+state flag PFSTATE_SETPRIO which indicates wether the prio
should be set. ok benno claudio mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.617 2012/07/10 09:13:41 henning Exp $	*/
a2022 18
				if (((r.route.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN) &&
				    ((r.route.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_LEASTSTATES) &&
				    disallow_table($8.route.host,
				    "tables are only "
				    "supported in round-robin or "
				    "least-states routing pools"))
					YYERROR;
				if (((r.route.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN) &&
				    ((r.route.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_LEASTSTATES) &&
				    disallow_alias($8.route.host,
				    "interface (%s) "
				    "is only supported in round-robin or "
				    "least-states routing pools"))
					YYERROR;
d4813 8
@


1.618
log
@Allow an implicit address family for af-to rules.  If the address
family can be determined by the "from" or "to" parameter in the
matching part, it is no longer necessary to specify "inet" or "inet6"
there.
OK henning@@ mikeb@@
@
text
@d895 2
a896 2
			} else
				r.set_prio[0] = r.set_prio[1] = PF_PRIO_NOTSET;
a1027 1
				r.set_prio[0] = r.set_prio[1] = PF_PRIO_NOTSET;
d1712 2
a1713 2
			} else
				r.set_prio[0] = r.set_prio[1] = PF_PRIO_NOTSET;
@


1.617
log
@set { ... } -> set ( ... )
brought up by ryan, discussed with him and theo and they convinced me
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.616 2012/07/09 14:05:35 henning Exp $	*/
d1717 1
a1717 12

			if ($8.marker & FOM_AFTO) {
				if (!$5) {
					yyerror("must indicate source address "
					    "family with af-to");
					YYERROR;
				}
				if ($5 == $8.nat.af) {
					yyerror("incorrect address family "
					    "translation");
					YYERROR;
				}
a1718 1
			}
d4128 4
@


1.616
log
@fix some of the confusion we have in pf regarding filter criteria vs
options that "write" to the packet by putting the latter in a set { } block.
for now prio and tos, maintain set-tos backwards compat for the moment.
"match set { prio 6, tos lowdelay }"
"match set prio 6"
from a discussion with ryan in tokyo a while ago, ok ryan phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.615 2012/07/07 18:39:21 henning Exp $	*/
d2389 1
a2389 1
filter_sets	: SET '{' filter_sets_l '}'	{ $$ = filter_opts; }
@


1.615
log
@remove incorrect check in pfctl preventing set-tos for ipvshit.
the kernel has code to deal with set-tos and that crap. don't ask for
details. stuart ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.614 2012/07/07 16:24:32 henning Exp $	*/
d511 1
d983 1
a983 1
		| SETTOS tos {
d2383 15
a2397 1
		| prio {
d2406 7
a2412 2
		| ONCE {
			filter_opts.marker |= FOM_ONCE;
@


1.614
log
@rename prio in struct pf_rule and related structs to set_prio so it is
utterly clear this is not a filter criteria but a packet modification thing.
also preparation for upcoming changes, including one to unscrew this mess
(I should not have to touch half the tree for this - ifixitlater)
not user visible, ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.612 2011/12/12 21:30:27 mikeb Exp $	*/
d4175 1
a4175 1
	    (PFSTATE_NODF|PFSTATE_RANDOMID|PFSTATE_SETTOS))) {
d4177 1
a4177 1
		    "no-df, random-id, set-tos");
@


1.613
log
@unbreak rule optimizer;  ok henning, looks
@
text
@d235 1
a235 1
#define FOM_PRIO	0x0400
d261 1
a261 1
	u_int8_t		 prio[2];
d891 3
a893 3
			if ($9.marker & FOM_PRIO) {
				r.prio[0] = $9.prio[0];
				r.prio[1] = $9.prio[1];
d895 1
a895 1
				r.prio[0] = r.prio[1] = PF_PRIO_NOTSET;
d1027 1
a1027 1
				r.prio[0] = r.prio[1] = PF_PRIO_NOTSET;
d1709 3
a1711 3
			if ($8.marker & FOM_PRIO) {
				r.prio[0] = $8.prio[0];
				r.prio[1] = $8.prio[1];
d1713 1
a1713 1
				r.prio[0] = r.prio[1] = PF_PRIO_NOTSET;
d2383 1
a2383 1
			if (filter_opts.marker & FOM_PRIO) {
d2387 3
a2389 3
			filter_opts.marker |= FOM_PRIO;
			filter_opts.prio[0] = $1.b1;
			filter_opts.prio[1] = $1.b2;
@


1.612
log
@fixup af-to regression with match rules

pfctl should not infer the af-to behavior from the af/naf difference.
instead, we should be clear that this is an af-to rule.  essentially
this change converts FOM_AFTO marker into a rule flag PFRULE_AFTO so
that we don't rely on ambiguous checks (like r->af != r->naf) when
setting things up.

positive review and comments from claudio, ok henning, sperreault
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.611 2011/12/03 12:46:16 mcbride Exp $	*/
d4893 1
a4893 1
		r->af = r->naf = af;
@


1.611
log
@pfctl_set_hostid always returns 0; don't pretend otherwise and make it a
void function instead.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.610 2011/10/13 18:30:54 claudio Exp $	*/
a898 1
			r.naf = r.af;
d1728 1
a2014 1
			r.naf = r.af;
d4196 1
a4196 1
		if (r->nat.addr.type != PF_ADDR_NONE && r->naf != r->af) {
a4698 3
	if (rs && rs->af)
		r->naf = rs->af;

d4704 3
d4713 2
a4714 1
		}
d4723 2
a4724 1
			if (!h->af || !r->af || rs->af || r->af == h->af)
d4893 1
a4893 1
		r->af = af;
@


1.610
log
@pfctl change for af-to / NAT64 support.
The general syntax is:
pass in inet from any to 192.168.1.1 af-to inet6 from 2001::1 to 2001::2
In the NAT64 case the "to" is not needed in af-to and the IP is extraced
from the IPv6 dst (assuming a /64 prefix).
Again most work by sperreault@@, mikeb@@ and reyk@@
OK mcbride@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.609 2011/09/07 23:40:52 haesbaert Exp $	*/
d611 1
a611 4
			if (pfctl_set_hostid(pf, $3) != 0) {
				yyerror("error setting hostid %08x", $3);
				YYERROR;
			}
@


1.609
log
@Avoid possible SIGSEGV when wrong tos option.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.608 2011/08/30 00:43:57 mikeb Exp $	*/
d220 1
d232 1
d465 1
a465 1
%token	DIVERTTO DIVERTREPLY DIVERTPACKET NATTO RDRTO RECEIVEDON NE LE GE
d902 1
d1721 12
d1734 1
d2018 1
d2285 49
d4200 4
d4703 3
d4713 1
a4713 1
		if (!r->af || !h->af || h->af == r->af) {
d4726 1
a4726 1
			if (!h->af || !r->af || r->af == h->af)
d4748 1
a4748 1
			if (r->af != h->af)
d5193 1
@


1.608
log
@One shot rules can be used in pf.conf by specifying a "once" filter option.

ok henning, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.607 2011/07/29 10:51:46 mcbride Exp $	*/
d3384 1
a3384 1
				yyerror("illegal tos value %s", $1);
@


1.607
log
@Remove requirement to quote 'debug' loglevel for the 'debug' option.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.606 2011/07/27 00:26:10 mcbride Exp $	*/
d234 1
d459 1
a459 1
%token	LOAD RULESET_OPTIMIZATION RTABLE RDOMAIN PRIO
d878 6
d1715 2
d2329 3
d5182 1
@


1.606
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.605 2011/07/13 20:57:10 mcbride Exp $	*/
d656 6
@


1.605
log
@Force user to specify protocol when filtering on user, gid, and os
attributes (this is now required by pf_rule_test().

ok sthen henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.604 2011/07/08 18:52:47 henning Exp $	*/
d383 1
d455 1
d470 1
d486 1
a1196 2
			else if (!strcmp($1, "cost"))
				table_opts.flags |= PFR_TFLAG_COST;
d1205 1
a1205 1
		| '{' optnl host_list '}'	{
d1257 19
d2293 2
d2701 1
d2744 10
d3609 8
a3616 1
redirspec	: host				{ $$ = $1; }
d3620 1
a3620 1
redir_host_list	: host optnl			{
d3627 5
d3634 1
a3634 1
		| redir_host_list comma host optnl {
d3637 5
d3858 9
a3866 2
route_host_list	: route_host optnl			{ $$ = $1; }
		| route_host_list comma route_host optnl {
d3876 5
d3885 8
a3892 1
routespec	: route_host			{ $$ = $1; }
d4130 1
a4130 1
			if (pfr_buf_load(&ab, ti->file, 0, append_addr)) {
d4649 2
a4650 2
		     (rs->pool_opts.type != PF_POOL_ROUNDROBIN) &&
		     (rs->pool_opts.type != PF_POOL_LEASTSTATES)) {
d4671 1
d4675 1
a4675 1
                }
a4677 3
		if (rs->pool_opts.type == PF_POOL_LEASTSTATES)
			tbl->pt_flags |= PFR_TFLAG_COST;

d5221 1
@


1.604
log
@allow rules to specify "prio X" or "prio (X, Y)" to assign priority levels
for the new priority queueing implementation. valid range is 0 to 7. the old
trick for priorizing empty ACKs etc remains thru the latter notation
ok ryan mpf sthen plus pea testing and halex and claudio reading
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.603 2011/07/07 00:47:19 mcbride Exp $	*/
d3944 4
d3951 10
@


1.603
log
@Fold pf_test_fragment() into pf_test_rule(), reduce code and fixes
a bunch of bugs with fragment handling not being in sync with the
rest of the ruleset.

Much feedback from mpf, bluhm & markus
Thanks to Tony Sarendal for help with testing

ok bluhm; various previous versions ok henning, claudio, mpf, markus
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.602 2011/07/04 03:36:14 henning Exp $	*/
d233 1
d258 1
d456 1
a456 1
%token	LOAD RULESET_OPTIMIZATION
d471 1
a471 1
%type	<v.b>			flags flag blockspec
d875 5
d1011 1
d1676 5
d2282 27
d5089 1
@


1.602
log
@bye bye require-order.
i added that button many many many years ago since the order (options, scrub,
nat, filter) was enforced back then, which I hated. now we had that turned
off for ages, and with the scrub and nat rulesets being gone, there is very
little reason to enforce an order at all. so let's get rid of it.
introducing this button was one of my very early commits to openbsd... feels
a bit strange to remove it now :)
ok ryan dlg theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.601 2011/07/03 23:59:43 henning Exp $	*/
d4675 1
d4677 1
a4678 2
	LOOP_THROUGH(struct node_host, dst_host, dst_hosts,
	LOOP_THROUGH(struct node_port, dst_port, dst_ports,
@


1.601
log
@g/c RIO traces (aka clean up after tedu :))
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.600 2011/07/03 23:37:55 zinke Exp $	*/
a65 1
static int		 rulestate = 0;
a70 1
static int		 require_order = 0;
a105 8
enum {
	PFCTL_STATE_NONE,
	PFCTL_STATE_OPTION,
	PFCTL_STATE_QUEUE,
	PFCTL_STATE_NAT,
	PFCTL_STATE_FILTER
};

a354 1
int	 check_rulestate(int);
d449 1
a449 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG SKIP HOSTID
a568 2
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
a571 4
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
a589 4
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
a609 2
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
a614 2
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
a616 6
		| SET REQUIREORDER yesno {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set require-order %s\n",
				    $3 == 1 ? "yes" : "no");
			require_order = $3;
		}
a619 4
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
a643 4
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
a759 6
			if (check_rulestate(PFCTL_STATE_FILTER)) {
				if ($2)
					free($2);
				YYERROR;
			}

a994 3
			if (check_rulestate(PFCTL_STATE_FILTER))
				YYERROR;

a1249 3
			if (check_rulestate(PFCTL_STATE_QUEUE))
				YYERROR;

a1270 5
			if (check_rulestate(PFCTL_STATE_QUEUE)) {
				free($2);
				YYERROR;
			}

a1271 1

a1628 3
			if (check_rulestate(PFCTL_STATE_FILTER))
				YYERROR;

a1629 1

a3787 4
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
				YYERROR;
			}
a3806 4
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
				YYERROR;
			}
a4969 12
check_rulestate(int desired_state)
{
	if (require_order && (rulestate > desired_state)) {
		yyerror("Rules must be in order: options, normalization, "
		    "queueing, translation, filtering");
		return (1);
	}
	rulestate = desired_state;
	return (0);
}

int
a5063 1
		{ "require-order",	REQUIREORDER},
a5459 1
	rulestate = PFCTL_STATE_NONE;
a5463 1
	require_order = 0;
@


1.600
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.599 2011/04/06 13:19:55 claudio Exp $	*/
a1516 2
			else if (!strcmp($1, "rio"))
				$$ = CBQCLF_RIO;
a1536 2
			else if (!strcmp($1, "rio"))
				$$ = PRCF_RIO;
a1634 2
			else if (!strcmp($1, "rio"))
				hfsc_opts.flags |= HFCF_RIO;
@


1.599
log
@Userland bits to allow PF to filter on the rdomain a packet belongs to.
This allows to write rules like "pass in on rdomain 1".
Tested by phessler@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.598 2011/04/05 13:48:18 mikeb Exp $	*/
d462 1
a462 1
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT PROBABILITY
d1233 2
d2040 4
a2043 2
				if ((r.route.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
d2046 2
a2047 1
				    "supported in round-robin routing pools"))
d2049 4
a2052 2
				if ((r.route.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
d2055 2
a2056 2
				    "is only supported in round-robin "
				    "routing pools"))
d2059 4
a2062 2
					if ((r.route.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) {
d2064 2
a2065 1
						    "be PF_POOL_ROUNDROBIN");
d2310 2
d3730 7
a4565 1

d4600 4
a4603 2
		     rs->pool_opts.type != PF_POOL_ROUNDROBIN) {
			yyerror("only round-robin valid for multiple "
d4628 3
d4638 2
a4639 1
			print_tabledef(tbl->pt_name, PFR_TFLAG_CONST,
d5107 1
@


1.598
log
@ditch fastroute, an ipf feature that made its way into pf before
route-to and friends were introduced making it obsolete. one even
has to look it up int the ipf manual to get and idea what it's
supposed to do.  reuse some kernel bits for the upcoming nat64
stuff.  "kill it with fire" from mcbride, "what mcbride said"
from mpf, "kill kill kill" and ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.597 2010/12/31 12:15:31 bluhm Exp $	*/
d464 1
a464 1
%token	QUEUE PRIORITY QLIMIT RTABLE
d2542 14
d4315 3
d4774 4
d4988 3
d5120 1
@


1.597
log
@According to pf_scrub_ip6() pf does not support the scrub options
no-df, random-id, set-tos for IPv6 rules.  Check this in pfctl and
document it in pf.conf(5).
ok henning@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.596 2010/12/15 13:54:50 henning Exp $	*/
d456 1
a456 1
%token	MINTTL ERROR ALLOWOPTS FASTROUTE FILENAME ROUTETO DUPTO REPLYTO NO LABEL
d2031 1
a2031 1
			if (r.rt && r.rt != PF_FASTROUTE) {
a2295 5
		| FASTROUTE {
			filter_opts.route.host = NULL;
			filter_opts.route.rt = PF_FASTROUTE;
			filter_opts.route.pool_opts = 0;
		}
d4030 1
a4030 1
			yyerror("route-to, reply-to, dup-to and fastroute "
a5037 1
		{ "fastroute",		FASTROUTE},
@


1.596
log
@make the "invalid probability:" yyerror suck less
From: Thomas Pfaff <tpfaff@@tp76.info>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.595 2010/12/01 10:35:18 jsg Exp $	*/
d4015 6
@


1.595
log
@remove some unused tokens
ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.594 2010/09/24 09:17:46 henning Exp $	*/
d2211 1
a2211 1
				yyerror("invalid probability: %lf", p);
@


1.594
log
@remove the check that enforced rdr-to only inbound and nat-to only outbound.
both now can be used in both directions. the kernel allowed that ever since
we did the great NAT rewrite.
still enforce that a direction is given, a rule with rdr-to and/or nat-to
and no direction is pretty certainly an error (which it would work,
technically)
ok ryan claudio dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.593 2010/09/22 06:02:59 henning Exp $	*/
d455 1
a455 1
%token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINATTO NODF
d458 1
a458 1
%token	REASSEMBLE FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
a5030 1
		{ "crop",		FRAGCROP},
a5035 1
		{ "drop-ovl",		FRAGDROP},
a5073 2
		{ "nat",		NAT},
		{ "nat-anchor",		NATANCHOR},
a5095 2
		{ "rdr",		RDR},
		{ "rdr-anchor",		RDRANCHOR},
@


1.593
log
@new log opt "matches"
awesome for debugging, a rule like
match log(matches) from $testbox
will show you exactly which subsequent rules match on that packet
real ok theo assumed oks ryan & dlg bikeshedding many
implementation time ~1 min bikeshedding about the keyword longish.
i voted for "matches" since i like to play with matches
idea was theo's, actually
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.592 2010/09/02 14:01:04 sobrado Exp $	*/
d4012 3
a4014 6
	if (r->nat.addr.type != PF_ADDR_NONE && r->direction != PF_OUT) {
		yyerror("nat-to can only be used outbound");
		problems++;
	}
	if (r->rdr.addr.type != PF_ADDR_NONE && r->direction != PF_IN) {
		yyerror("rdr-to can only be used inbound");
@


1.592
log
@remove trailing spaces and tabs; no binary change.

written with help from henning@@, who suggested ensuring that there
are no changes in the digests for object files, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.591 2010/08/03 18:42:40 henning Exp $	*/
d461 1
a461 1
%token	ANTISPOOF FOR INCLUDE
d2485 1
d5070 1
@


1.591
log
@fix linecount bug with comments spanning multiple lines
problem reported with the obvious fix for bgpd by Sebastian Benoit
<benoit-lists at fb12.de>, also PR 6432
applied to all the others by yours truly. ok theo
isn't it amazing how far this parser (and more) spread?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.590 2010/07/03 02:28:57 mcbride Exp $	*/
d155 1
a155 1
	    PF_STATE_OPT_TIMEOUT, PF_STATE_OPT_SLOPPY, 
d825 1
a825 1
		
d2063 1
a2063 1
				$8.rroute.rdr->host = $8.route.host;	
d2106 1
a2106 1
			}	
d4552 1
a4552 1
			if (!h->af || !r->af || r->af == h->af) 
d4562 1
a4562 1
		
d4853 1
a4853 1
			if (PF_AZERO(&r->src.addr.v.a.mask, af) || 
d5336 1
a5336 1
		break;		
@


1.590
log
@Fix a couple of problems with printing of anchors, in particular recursive
printing, both of inline anchors and when requested explicitly with a '*'
in the anchor.
- Correct recursive printing of wildcard anchors (recurse into child anchors
  rather than rules, which don't exist)
- Print multi-part anchor paths correctly (pr6065)
- Fix comments and prevent users from specifying multi-component names for
  inline anchors.

tested by phessler
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.589 2010/03/23 13:31:29 henning Exp $	*/
d5312 2
a5313 1
				else if (next == '\n')
d5315 1
a5315 1
				else
@


1.589
log
@remove -A, -O, -R and -T load
the partial loading of a ruleset (leaving ancors aside) is wrong and
conflicts with the general idea of how pf works. last not least it breaks
with the optimizer generating tables automagically.
ok deraadt sthen krw manpage jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.588 2010/01/13 05:20:10 deraadt Exp $	*/
d772 6
a777 1
			/* create a holding ruleset in the root */
d814 8
a821 1
				/* move inline rules into relative location */
@


1.588
log
@Move tokens before productions into more consistant places
ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.587 2010/01/13 00:56:13 mcbride Exp $	*/
d1177 4
a1180 5
			if (pf->loadopt & PFCTL_FLAG_TABLE)
				if (process_tabledef($3, &$5)) {
					free($3);
					YYERROR;
				}
a4280 6
	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
		FREE_LIST(struct node_if, interfaces);
		FREE_LIST(struct node_queue, nqueues);
		return (0);
	}

a4381 5

	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
		FREE_LIST(struct node_queue, nqueues);
		return (0);
	}
@


1.587
log
@Allow /netmask notation in redir spec, fix the rest of the regress
tests for illegal conditions in translation/routing.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.586 2010/01/12 19:18:55 mcbride Exp $	*/
d1147 1
a1147 1
antispoof_opt	: label	{
d1152 1
a1152 1
			antispoof_opts.label = $1;
d2174 1
a2174 1
		| label	{
d2179 1
a2179 1
			filter_opts.label = $1;
d2181 1
a2181 1
		| qname	{
d2186 1
a2186 1
			filter_opts.queues = $1;
d2664 1
a2664 1
		|
d3332 3
a3334 3
sourcetrack	: SOURCETRACK		{ $$ = PF_SRCTRACK; }
		| SOURCETRACK GLOBAL	{ $$ = PF_SRCTRACK_GLOBAL; }
		| SOURCETRACK RULE	{ $$ = PF_SRCTRACK_RULE; }
d3475 1
a3475 1
		| sourcetrack {
d3480 1
a3480 1
			$$->data.src_track = $1;
d3541 2
a3542 2
label		: LABEL STRING			{
			$$ = $2;
d3546 2
a3547 2
qname		: QUEUE STRING				{
			$$.qname = $2;
d3550 2
a3551 2
		| QUEUE '(' STRING ')'			{
			$$.qname = $3;
d3554 3
a3556 3
		| QUEUE '(' STRING comma STRING ')'	{
			$$.qname = $3;
			$$.pqname = $5;
@


1.586
log
@We actually have to keep the translate/route spec addresses around after
collapsing into tables, so that we can handle all possible address family
expansions.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.585 2010/01/12 16:22:49 mcbride Exp $	*/
a2021 5
				if ($8.route.host == NULL) {
					yyerror("no routing address with "
					    "matching address family found.");
					YYERROR;
				}
d3733 14
d3765 7
a3771 1
		| dynaddr			{
d3773 2
d4531 2
a4532 1
	if (!rs || !rs->rdr) {
d4546 5
a4550 3
	if (i == 0)		/* no pool address */
		return (0);
	else if (i == 1) {	/* only one address */
d4839 4
a4842 2
			} else if ((src_host->addr.type != PF_ADDR_ADDRMASK &&
			    src_host->addr.type != PF_ADDR_DYNIFTL)) {
d4851 6
@


1.585
log
@Set roundrobin flag correctly, and don't treat a bare interface
like a dynamic one in the routespec.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.584 2010/01/12 15:52:07 mcbride Exp $	*/
a370 1
void	 remove_invalid_hosts(struct node_host **, sa_family_t *);
a2021 1
				remove_invalid_hosts(&$8.route.host, &r.af);
d4512 1
d4519 6
a4524 14
	h = rs->rdr->host;
	if (r->af)
		remove_invalid_hosts(&h, &r->af);
	if (h == NULL)			/* no pool address */
		return (0);
	else if (h->next == NULL) {	/* only one address */
		if (!r->af)
			r->af = h->af;
		else {
			if (r->af && h->af && r->af != h->af) {
				yyerror("address family mismatch "
				    "on translationh address");
				return (1);
			}
d4526 1
d4528 6
d4544 1
a4544 1
	} else {			/* more than one address */
d4551 3
a4553 1
		while (h != NULL) {
a4568 1
			h = h->next;
a4570 2
	freehostlist(h);
	rs->rdr->host = NULL;
a4683 4
	error += collapse_redirspec(&r->rdr, r, rdr, 0);
	error += collapse_redirspec(&r->nat, r, nat, 0);
	error += collapse_redirspec(&r->route, r, rroute, 1);

d4698 5
d4875 1
a4875 1
			bcopy(nat->rdr->host, dsth, sizeof(*dsth));
d4908 5
a5604 32
		}
	}
}

void
remove_invalid_hosts(struct node_host **nh, sa_family_t *af)
{
	struct node_host	*n = *nh, *prev = NULL;

	while (n != NULL) {
		if (*af && n->af && n->af != *af) {
			/* unlink and free n */
			struct node_host *next = n->next;

			/* adjust tail pointer */
			if (n == (*nh)->tail)
				(*nh)->tail = prev;
			/* adjust previous node's next pointer */
			if (prev == NULL)
				*nh = next;
			else
				prev->next = next;
			/* free node */
			if (n->ifname != NULL)
				free(n->ifname);
			free(n);
			n = next;
		} else {
			if (n->af && !*af)
				*af = n->af;
			prev = n;
			n = n->next;
@


1.584
log
@Add restrictions to make @@if illegal in outside of routing specs;
Fix binat-to sanity checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.583 2010/01/12 14:44:26 mcbride Exp $	*/
d3734 1
a3734 1
				$$->addr.type = PF_ADDR_DYNIFTL;
d4626 1
a4626 1
		rpool->opts = PF_POOL_ROUNDROBIN;
@


1.583
log
@Fix some issues in redir spec handling, discovered thanks to dlg testing
- purge irrelevant addresses from the lists before collapsing
- ensure the lists are freed after they're collapsed
- more careful ifname copying, avoiding double-free / use-after-free traps
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.582 2010/01/12 03:33:28 mcbride Exp $	*/
d347 1
a347 1
		    struct redirspec *rs);
d4508 2
a4509 1
collapse_redirspec(struct pf_pool *rpool, struct pf_rule *r, struct redirspec *rs)
d4537 4
d4554 2
a4555 1
			if (h->addr.type != PF_ADDR_ADDRMASK) {
d4560 4
d4687 3
a4689 3
	error += collapse_redirspec(&r->rdr, r, rdr);
	error += collapse_redirspec(&r->nat, r, nat);
	error += collapse_redirspec(&r->route, r, rroute);
d4705 8
d4821 2
a4822 1
			} else if (src_host->af == AF_UNSPEC) {
d4827 9
a4835 8
			if (disallow_table(src_host, "invalid use of table "
			    "<%s> as the redirect address of a "
			    "binat-to rule") ||
			    disallow_alias(dst_host, "invalid use of interface "
			    "(%s) as the redirect address of a "
			    "binat-to rule") ||
			    disallow_urpf_failed(dst_host, "\"urpf-failed\" "
			    "is not permitted as a binat-to destination")) {
@


1.582
log
@Don't leak @@if0 format routing host names, pointed out by claudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.581 2010/01/12 03:20:51 mcbride Exp $	*/
d3766 10
a3775 2
			for (n = $3; n != NULL; n = n->next)
				$$->ifname = $2;
d4520 2
d4562 2
a4595 3
	if (check_netmask(rs->rdr->host, r->af))
		return (1);

d4614 2
a4615 4
	if ((rpool->opts & PF_POOL_TYPEMASK) == PF_POOL_NONE &&
	    (rs->rdr->host->next != NULL ||
	    rs->rdr->host->addr.type == PF_ADDR_TABLE ||
	    DYNIF_MULTIADDR(rs->rdr->host->addr)))
d4677 3
a4679 3
	collapse_redirspec(&r->rdr, r, rdr);
	collapse_redirspec(&r->nat, r, nat);
	collapse_redirspec(&r->route, r, rroute);
a4889 4
		if (nat && nat->rdr)
			FREE_LIST(struct node_host, nat->rdr->host);
		if (rdr && rdr->rdr)
			FREE_LIST(struct node_host, rdr->rdr->host);
d4935 5
@


1.581
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.580 2010/01/10 23:48:22 deraadt Exp $	*/
d3728 1
@


1.580
log
@lex <=, >=, and != into a single token for correctness and to reduce the
lookahead in the parser
ok henning otto
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.579 2010/01/10 07:45:41 deraadt Exp $	*/
d346 2
d3580 9
a3588 1
redir_host_list	: host optnl			{ $$ = $1; }
d3722 23
d3747 7
a3753 4
				err(1, "route_host: calloc");
			$$->ifname = $1;
			$$->addr.type = PF_ADDR_DYNIFTL;
			set_ipmask($$, 128);
d3757 3
d3761 2
d3764 3
a3766 1
			$$->ifname = $2;
d3970 2
a3971 2
	if ((!TAILQ_EMPTY(&r->nat.list) ||
	    (!r->rt && !TAILQ_EMPTY(&r->rdr.list)))  &&
d3976 1
a3976 1
	if (!TAILQ_EMPTY(&r->nat.list) && r->direction != PF_OUT) {
d3980 1
a3980 1
	if (!r->rt && !TAILQ_EMPTY(&r->rdr.list) && r->direction != PF_IN) {
d4499 78
a4579 3
	struct node_host	*h;
	struct pf_pooladdr	*pa;

a4582 6
	if (!r->af && ! rs->rdr->host->ifindex)
		r->af = rs->rdr->host->af;

	remove_invalid_hosts(&rs->rdr->host, &r->af);
	if (invalid_redirect(rs->rdr->host, r->af))
		return (1);
a4608 15
	if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN &&
	    disallow_table(rs->rdr->host, "tables are only supported in "
	    "round-robin redirection pools"))
		return (1);
	if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN &&
	    disallow_alias(rs->rdr->host, "interface (%s) is only supported in "
	    "round-robin redirection pools"))
		return (1);
	if (rs->rdr->host->next != NULL) {
		if ((rpool->opts & PF_POOL_TYPEMASK) != PF_POOL_ROUNDROBIN) {
			yyerror("only round-robin valid for multiple "
			    "redirection addresses");
			return (1);
		}
	}
a4632 14
	TAILQ_INIT(&rpool->list);
	for (h = rs->rdr->host; h != NULL; h = h->next) {
		if ((pa = calloc(1, sizeof(struct pf_pooladdr))) == NULL)
			err(1, "apply_redirspec: calloc");
		pa->addr = h->addr;
		if (h->ifname != NULL) {
			if (strlcpy(pa->ifname, h->ifname, sizeof pa->ifname) >=
			    sizeof(pa->ifname))
				errx(1, "apply_redirspec: strlcpy");
		} else
			pa->ifname[0] = 0;
		TAILQ_INSERT_TAIL(&rpool->list, pa, entries);
	}

d4668 6
@


1.579
log
@In the non-optimized case, an address list containing "any" (ie. { any 10.0.0.1 })
should be folded in the parser to any, not to 10.0.0.1.  How long this bug has
been with us is unclear.
ok guenther mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.578 2009/12/24 10:06:35 sobrado Exp $	*/
d468 1
a468 1
%token	DIVERTTO DIVERTREPLY DIVERTPACKET NATTO RDRTO RECEIVEDON
d3811 2
a3812 2
		| '!' '='	{ $$ = PF_OP_NE; }
		| '<' '='	{ $$ = PF_OP_LE; }
d3814 1
a3814 1
		| '>' '='	{ $$ = PF_OP_GE; }
d5181 6
d5192 2
a5193 1
		}
d5201 2
a5202 1
		}
@


1.578
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.577 2009/12/24 04:24:19 dlg Exp $	*/
d2679 2
a2680 1
			if ($3 == NULL)
d2682 2
a2683 1
			else if ($1 == NULL)
d2685 1
a2685 1
			else {
d4837 6
@


1.577
log
@add support to pf for filtering a packet by the interface it was received
on. use the received-on IFNAME filter option on a pf.conf rule to restrict
which packet the interface had to be received on. eg:

  pass out on em0 from $foo to $bar received-on fxp0

ive been running this in production for a week now. i find it particularly
usefull with interface groups.

no objections, and a few "i like"s from henning, claudio, deraadt, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.576 2009/12/10 15:57:20 deraadt Exp $	*/
d551 1
a551 1
 * apply to previouslys specified rule: must be careful to note
@


1.576
log
@plug some memory leaks; found by parfait, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.575 2009/11/22 22:34:50 henning Exp $	*/
d245 1
d353 2
a354 1
		    struct node_gid *, struct node_icmp *, const char *);
d468 1
a468 1
%token	DIVERTTO DIVERTREPLY DIVERTPACKET NATTO RDRTO
d911 1
a911 1
			    $9.uid, $9.gid, $9.icmpspec,
d1080 1
a1080 1
					    NULL, NULL, NULL, "");
d1102 1
a1102 1
						    NULL, NULL, "");
d2106 1
a2106 1
			    $8.uid, $8.gid, $8.icmpspec, "");
d2316 7
d4558 2
a4559 2
    struct node_uid *uids, struct node_gid *gids, struct node_icmp *icmp_types,
    const char *anchor_call)
d4661 4
d4775 1
a4775 1
			    uid, gid, icmp_type, anchor_call);
d4949 1
@


1.575
log
@cleanup after the NAT changes. we used to have multiple rulesets (scrub,
NAT, filter). now we only have one. no need for an array any more. simplifies
the code quite a bit.
in the process fix the abuse of PF_RULESET_* by (surprise, isn't it) the
table code.
written at the filesystem hackathon in stockholm, committed from the
hardware hackathon in portugal. ok gcc and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.574 2009/11/09 14:31:58 jsg Exp $	*/
d5270 2
@


1.574
log
@A few more places to be updated for the route pool change.
expanded version of a diff from Vadim Zhukov.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.573 2009/10/28 20:11:01 jsg Exp $	*/
a5427 1
	int i;
d5430 9
a5438 14
	for (i = 0; i < PF_RULESET_MAX; ++i) {
		while ((r = TAILQ_FIRST(src->rules[i].active.ptr))
		    != NULL) {
			TAILQ_REMOVE(src->rules[i].active.ptr, r, entries);
			TAILQ_INSERT_TAIL(dst->rules[i].active.ptr, r, entries);
			dst->anchor->match++;
		}
		src->anchor->match = 0;
		while ((r = TAILQ_FIRST(src->rules[i].inactive.ptr))
		    != NULL) {
			TAILQ_REMOVE(src->rules[i].inactive.ptr, r, entries);
			TAILQ_INSERT_TAIL(dst->rules[i].inactive.ptr,
				r, entries);
		}
@


1.573
log
@Add a dedicated pf pool for route options as suggested by henning,
which unbreaks ie route-to after the recent pf changes.

With much help debugging and pointing out of missing bits from claudio@@

ok claudio@@ "looks good" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.572 2009/10/28 12:53:11 claudio Exp $	*/
d2012 1
a2012 1
				r.rdr.opts = $8.route.pool_opts;
d2014 1
a2014 1
					memcpy(&r.rdr.key, $8.route.key,
d2025 1
a2025 1
				if ((r.rdr.opts & PF_POOL_TYPEMASK) ==
d2029 2
a2030 2
					r.rdr.opts |= PF_POOL_ROUNDROBIN;
				if ((r.rdr.opts & PF_POOL_TYPEMASK) !=
d2036 1
a2036 1
				if ((r.rdr.opts & PF_POOL_TYPEMASK) !=
d2044 1
a2044 1
					if ((r.rdr.opts & PF_POOL_TYPEMASK) !=
d2046 1
a2046 1
						yyerror("r.rpool.opts must "
@


1.572
log
@route_host initializes the netmask to a /128 no matter what af is used so
that the load balancing code does not freak out but because of this
check_netmask() is now complaining. So set the addr.type to PF_ADDR_DYNIFTL
so check_netmask() is fixing up the netmask for IPv4 and stops complaining.
This is a partial fix for the failing regress test 13.
found with jsg, looks good henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.571 2009/10/28 12:41:16 claudio Exp $	*/
d272 1
d348 2
a349 1
		    struct redirspec *, struct redirspec *, struct node_proto *,
d907 1
a907 1
			expand_rule(&r, 0, $5, NULL, NULL, $7, $8.src_os,
d1077 2
a1078 2
					    NULL, h, NULL, NULL, NULL, NULL,
					    NULL, NULL, "");
d1098 1
a1098 1
						    NULL, NULL, NULL, h, NULL,
d1100 1
a1100 1
						    NULL, "");
d2052 4
a2055 4
				if (($8.rdr.rdr = calloc(1,
				    sizeof(*$8.rdr.rdr))) == NULL)
					err(1, "$8.rdr.rdr");
				$8.rdr.rdr->host = $8.route.host;	
d2101 2
a2102 1
			expand_rule(&r, 0, $4, &$8.nat, &$8.rdr, $6, $7.src_os,
d4545 1
a4545 1
    struct redirspec *nat, struct redirspec *rdr,
d4718 1
d4759 2
a4760 1
			expand_rule(&rb, 1, interface, NULL, &binat, proto,
@


1.571
log
@Correct function name in err and errx.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.570 2009/10/04 16:08:37 michele Exp $	*/
d3702 1
@


1.570
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.569 2009/09/08 17:52:17 michele Exp $	*/
d4524 1
a4524 1
			err(1, "expand_rule: calloc");
d4529 1
a4529 1
				errx(1, "expand_rule: strlcpy");
@


1.569
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.567 2009/09/07 12:21:09 reyk Exp $	*/
d269 1
a269 1
	}			 divert;
d464 1
a464 1
%token	DIVERTTO DIVERTREPLY NATTO RDRTO
d2097 1
d2231 15
d3933 4
d4859 1
@


1.568
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@d269 1
a269 1
	}			 divert, divert_packet;
d464 1
a464 1
%token	DIVERTTO DIVERTREPLY DIVERTPACKET NATTO RDRTO
a2096 1
			r.divert_packet.port = $8.divert_packet.port;
a2229 7
		| DIVERTPACKET PORT portplain {
			filter_opts.divert_packet.port = $3.a;
			if (!filter_opts.divert_packet.port) {
				yyerror("invalid divert port: %u", ntohs($3.a));
				YYERROR;
			}
		}
a3916 4
		if (r->divert_packet.port) {
			yyerror("divert is not supported on match rules");
			problems++;
		}
a4838 1
		{ "divert-packet",	DIVERTPACKET},
@


1.567
log
@implement binat-to as a macro-like rule: a rule using the new binat-to
syntax will be expanded by the parser to a nat-to+rdr-to combination
to be loaded into the kernel.  this simplifies the migration from old
binat rules and is less error-prone.

feedback from many, manpage bits from jmc@@
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.566 2009/09/03 12:16:21 reyk Exp $	*/
d269 1
a269 1
	}			 divert;
d464 1
a464 1
%token	DIVERTTO DIVERTREPLY NATTO RDRTO
d2097 1
d2231 7
d3925 4
d4851 1
@


1.566
log
@this time i commit the right diff that was
ok henning@@ (sorry)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.565 2009/09/03 12:12:37 reyk Exp $	*/
d229 1
d346 1
a346 1
void		 expand_rule(struct pf_rule *, struct node_if *,
d450 1
a450 1
%token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT NODF
d905 1
a905 1
			expand_rule(&r, $5, NULL, NULL, $7, $8.src_os,
d1074 1
a1074 1
					expand_rule(&r, j, NULL, NULL, NULL,
d1095 1
a1095 1
						expand_rule(&r, NULL, NULL,
d2098 1
a2098 1
			expand_rule(&r, $4, &$8.nat, &$8.rdr, $6, $7.src_os,
d2242 1
a2242 1
				yyerror("cannot respecify nat-to");
d2258 11
d4520 1
a4520 1
expand_rule(struct pf_rule *r, struct node_if *interfaces,
d4535 4
d4661 31
d4702 36
d4741 16
a4756 14
	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_proto, protos);
	FREE_LIST(struct node_host, src_hosts);
	FREE_LIST(struct node_port, src_ports);
	FREE_LIST(struct node_os, src_oses);
	FREE_LIST(struct node_host, dst_hosts);
	FREE_LIST(struct node_port, dst_ports);
	FREE_LIST(struct node_uid, uids);
	FREE_LIST(struct node_gid, gids);
	FREE_LIST(struct node_icmp, icmp_types);
	if (nat && nat->rdr)
		FREE_LIST(struct node_host, nat->rdr->host);
	if (rdr && rdr->rdr)
		FREE_LIST(struct node_host, rdr->rdr->host);
d4831 1
a4831 2
		{ "binat",		BINAT},
		{ "binat-anchor",	BINATANCHOR},
@


1.565
log
@fix two route-to vs. rdr-to conflicts.

found by sthen@@
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.564 2009/09/02 13:28:03 reyk Exp $	*/
d3885 1
a3885 1
	    !(r->rt || TAILQ_EMPTY(&r->rdr.list)))  &&
@


1.564
log
@all the new *-to options are part of the "filteropts" section at the
end of a pf rule (nat-to, divert-to, rdr-to, ...).  take the
historical chance to upgrade the grammar and move the route options to
the filteropts section as well.

for example,
  pass in on em0 route-to (em1 192.168.1.1) from 10.1.1.1
becomes
  pass in on em0 from 10.1.1.1 route-to (em1 192.168.1.1)

many people like this including pyr@@ mk@@ kettenis@@ todd@@ and others
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.563 2009/09/01 13:42:00 henning Exp $	*/
d3884 2
a3885 1
	if ((!TAILQ_EMPTY(&r->nat.list) || !TAILQ_EMPTY(&r->rdr.list)) &&
d3894 1
a3894 1
	if (!TAILQ_EMPTY(&r->rdr.list) && r->direction != PF_IN) {
@


1.563
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.562 2009/07/28 13:26:52 claudio Exp $	*/
d278 9
a406 7
		struct {
			struct node_host	*host;
			u_int8_t		 rt;
			u_int8_t		 pool_opts;
			sa_family_t		 af;
			struct pf_poolhashkey	*key;
		}			 route;
a491 1
%type	<v.route>		route
d886 6
d1662 1
a1662 1
pfrule		: action dir logquick interface route af proto fromto
d1699 2
a1700 2
			r.prob = $9.prob;
			r.rtableid = $9.rtableid;
d1702 1
a1702 1
			if ($9.nodf)
d1704 1
a1704 1
			if ($9.randomid)
d1706 5
a1710 5
			if ($9.minttl)
				r.min_ttl = $9.minttl;
			if ($9.max_mss)
				r.max_mss = $9.max_mss;
			if ($9.marker & FOM_SETTOS) {
d1712 1
a1712 1
				r.set_tos = $9.settos;
d1714 1
a1714 1
			if ($9.marker & FOM_SCRUB_TCP)
d1717 3
a1719 3
			r.af = $6;
			if ($9.tag)
				if (strlcpy(r.tagname, $9.tag,
d1725 2
a1726 2
			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
d1732 2
a1733 2
			r.match_tag_not = $9.match_tag_not;
			if (rule_label(&r, $9.label))
d1735 4
a1738 4
			free($9.label);
			r.flags = $9.flags.b1;
			r.flagset = $9.flags.b2;
			if (($9.flags.b1 & $9.flags.b2) != $9.flags.b1) {
d1742 2
a1743 2
			if ($9.flags.b1 || $9.flags.b2 || $8.src_os) {
				for (proto = $7; proto != NULL &&
d1747 2
a1748 2
				if (proto == NULL && $7 != NULL) {
					if ($9.flags.b1 || $9.flags.b2)
d1751 1
a1751 1
					if ($8.src_os)
d1758 2
a1759 2
				if (($9.flags.b1 & parse_flags("S")) == 0 &&
				    $8.src_os) {
d1767 3
a1769 3
			r.tos = $9.tos;
			r.keep_state = $9.keep.action;
			o = $9.keep.options;
d1773 1
a1773 1
			    !($9.marker & FOM_KEEP)) {
d1951 1
a1951 1
			    !$9.fragment && !($9.marker & FOM_FLAGS) &&
d1995 1
a1995 1
			if ($9.fragment)
d1997 1
a1997 1
			r.allow_opts = $9.allowopts;
d1999 2
a2000 2
			decide_address_family($8.src.host, &r.af);
			decide_address_family($8.dst.host, &r.af);
d2002 1
a2002 1
			if ($5.rt) {
d2008 4
a2011 4
				r.rt = $5.rt;
				r.rdr.opts = $5.pool_opts;
				if ($5.key != NULL)
					memcpy(&r.rdr.key, $5.key,
d2015 3
a2017 3
				decide_address_family($5.host, &r.af);
				remove_invalid_hosts(&$5.host, &r.af);
				if ($5.host == NULL) {
d2023 3
a2025 3
				    PF_POOL_NONE && ($5.host->next != NULL ||
				    $5.host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($5.host->addr)))
d2029 2
a2030 1
				    disallow_table($5.host, "tables are only "
d2035 2
a2036 1
				    disallow_alias($5.host, "interface (%s) "
d2040 1
a2040 1
				if ($5.host->next != NULL) {
d2049 4
a2052 4
				if (($9.rdr.rdr = calloc(1,
				    sizeof(*$9.rdr.rdr))) == NULL)
					err(1, "$9.rdr.rdr");
				$9.rdr.rdr->host = $5.host;	
d2054 2
a2055 2
			if ($9.queues.qname != NULL) {
				if (strlcpy(r.qname, $9.queues.qname,
d2061 1
a2061 1
				free($9.queues.qname);
d2063 2
a2064 2
			if ($9.queues.pqname != NULL) {
				if (strlcpy(r.pqname, $9.queues.pqname,
d2070 1
a2070 1
				free($9.queues.pqname);
d2072 1
a2072 1
			if ((r.divert.port = $9.divert.port)) {
d2074 1
a2074 1
					if ($9.divert.addr) {
d2082 1
a2082 1
					if (!$9.divert.addr) {
d2087 1
a2087 1
					if ($9.divert.addr->af != r.af) {
d2093 1
a2093 1
					    $9.divert.addr->addr.v.a.addr;
d2097 3
a2099 3
			expand_rule(&r, $4, &$9.nat, &$9.rdr, $7, $8.src_os,
			    $8.src.host, $8.src.port, $8.dst.host, $8.dst.port,
			    $9.uid, $9.gid, $9.icmpspec, "");
d2257 26
a3700 33
		;

route		: /* empty */			{
			$$.host = NULL;
			$$.rt = 0;
			$$.pool_opts = 0;
		}
		| FASTROUTE {
			$$.host = NULL;
			$$.rt = PF_FASTROUTE;
			$$.pool_opts = 0;
		}
		| ROUTETO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_ROUTETO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		| REPLYTO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_REPLYTO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		| DUPTO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_DUPTO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
@


1.562
log
@Bring back rev. 1.560:
Make it possible to use DiffServ Code Point in the TOS fields.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.561 2009/07/27 19:00:28 deraadt Exp $	*/
d205 26
d269 2
a314 12
struct pool_opts {
	int			 marker;
#define POM_TYPE		0x01
#define POM_STICKYADDRESS	0x02
	u_int8_t		 opts;
	int			 type;
	int			 staticport;
	struct pf_poolhashkey	*key;

} pool_opts;


a321 3
int		 filter_consistent(struct pf_rule *, int);
int		 nat_consistent(struct pf_rule *);
int		 rdr_consistent(struct pf_rule *);
d334 2
d337 4
a340 4
		    struct node_host *, struct node_proto *, struct node_os *,
		    struct node_host *, struct node_port *, struct node_host *,
		    struct node_port *, struct node_uid *, struct node_gid *,
		    struct node_icmp *, const char *);
d383 1
a383 5
		struct range {
			int		 a;
			int		 b;
			int		 t;
		}			 range;
d405 1
a405 4
		struct redirection {
			struct node_host	*host;
			struct range		 rport;
		}			*redirection;
d447 1
a447 1
%token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT ARROW NODF
d461 1
a461 1
%token	DIVERTTO DIVERTREPLY
d469 1
a469 1
%type	<v.i>			no dir af optimizer
d471 1
a471 1
%type	<v.b>			action nataction natpasslog
d483 1
a483 1
%type	<v.host>		ipspec toipspec xhost host dynaddr host_list
d491 2
a492 2
%type	<v.redirection>		redirection redirpool
%type	<v.string>		label stringall tag anchorname
a510 2
%type	<v.tagged>		tagged
%type	<v.rtableid>		rtable
a516 2
		| ruleset natrule '\n'
		| ruleset binatrule '\n'
a549 2
		| fakeanchor binatrule '\n'
		| fakeanchor natrule '\n'
d897 1
a897 1
			expand_rule(&r, $5, NULL, $7, $8.src_os,
a903 98
		| NATANCHOR string interface af proto fromto rtable {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.action = PF_NAT;
			r.af = $4;
			r.rtableid = $7;

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			expand_rule(&r, $3, NULL, $5, $6.src_os,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
			    0, 0, 0, $2);
			free($2);
		}
		| RDRANCHOR string interface af proto fromto rtable {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.action = PF_RDR;
			r.af = $4;
			r.rtableid = $7;

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			if ($6.src.port != NULL) {
				yyerror("source port parameter not supported"
				    " in rdr-anchor");
				YYERROR;
			}
			if ($6.dst.port != NULL) {
				if ($6.dst.port->next != NULL) {
					yyerror("destination port list "
					    "expansion not supported in "
					    "rdr-anchor");
					YYERROR;
				} else if ($6.dst.port->op != PF_OP_EQ) {
					yyerror("destination port operators"
					    " not supported in rdr-anchor");
					YYERROR;
				}
				r.dst.port[0] = $6.dst.port->port[0];
				r.dst.port[1] = $6.dst.port->port[1];
				r.dst.port_op = $6.dst.port->op;
			}

			expand_rule(&r, $3, NULL, $5, $6.src_os,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
			    0, 0, 0, $2);
			free($2);
		}
		| BINATANCHOR string interface af proto fromto rtable {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.action = PF_BINAT;
			r.af = $4;
			r.rtableid = $7;
			if ($5 != NULL) {
				if ($5->next != NULL) {
					yyerror("proto list expansion"
					    " not supported in binat-anchor");
					YYERROR;
				}
				r.proto = $5->proto;
				free($5);
			}

			if ($6.src.host != NULL || $6.src.port != NULL ||
			    $6.dst.host != NULL || $6.dst.port != NULL) {
				yyerror("fromto parameter not supported"
				    " in binat-anchor");
				YYERROR;
			}

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			pfctl_add_rule(pf, &r, $2);
			free($2);
		}
d1066 3
a1068 3
					expand_rule(&r, j, NULL, NULL, NULL, h,
					    NULL, NULL, NULL, NULL, NULL,
					    NULL, "");
d1088 3
a1090 2
						    NULL, NULL, h, NULL, NULL,
						    NULL, NULL, NULL, NULL, "");
d2002 1
a2002 1
				r.rpool.opts = $5.pool_opts;
d2004 1
a2004 1
					memcpy(&r.rpool.key, $5.key,
d2015 1
a2015 1
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
d2019 2
a2020 2
					r.rpool.opts |= PF_POOL_ROUNDROBIN;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
d2025 1
a2025 1
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
d2032 1
a2032 1
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
d2039 5
d2088 1
a2088 1
			expand_rule(&r, $4, $5.host, $7, $8.src_os,
d2230 18
a2601 4
toipspec	: TO ipspec			{ $$ = $2; }
		| /* empty */			{ $$ = NULL; }
		;

a3487 4
no		: /* empty */			{ $$ = 0; }
		| NO				{ $$ = 1; }
		;

d3509 1
a3509 2
redirpool	: /* empty */			{ $$ = NULL; }
		| ARROW redirspec		{
d3513 1
a3513 1
			$$->host = $2;
d3516 1
a3516 1
		| ARROW redirspec PORT portstar	{
d3520 2
a3521 2
			$$->host = $2;
			$$->rport = $4;
a3633 395
redirection	: /* empty */			{ $$ = NULL; }
		| ARROW host			{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport.a = $$->rport.b = $$->rport.t = 0;
		}
		| ARROW host PORT portstar	{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport = $4;
		}
		;

natpasslog	: /* empty */	{ $$.b1 = $$.b2 = 0; $$.w2 = 0; }
		| PASS		{ $$.b1 = 1; $$.b2 = 0; $$.w2 = 0; }
		| PASS log	{ $$.b1 = 1; $$.b2 = $2.log; $$.w2 = $2.logif; }
		| log		{ $$.b1 = 0; $$.b2 = $1.log; $$.w2 = $1.logif; }
		;

nataction	: no NAT natpasslog {
			if ($1 && $3.b1) {
				yyerror("\"pass\" not valid with \"no\"");
				YYERROR;
			}
			if ($1)
				$$.b1 = PF_NONAT;
			else
				$$.b1 = PF_NAT;
			$$.b2 = $3.b1;
			$$.w = $3.b2;
			$$.w2 = $3.w2;
		}
		| no RDR natpasslog {
			if ($1 && $3.b1) {
				yyerror("\"pass\" not valid with \"no\"");
				YYERROR;
			}
			if ($1)
				$$.b1 = PF_NORDR;
			else
				$$.b1 = PF_RDR;
			$$.b2 = $3.b1;
			$$.w = $3.b2;
			$$.w2 = $3.w2;
		}
		;

natrule		: nataction interface af proto fromto tag tagged rtable
		    redirpool pool_opts
		{
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			r.natpass = $1.b2;
			r.log = $1.w;
			r.logif = $1.w2;
			r.af = $3;

			if (!r.af) {
				if ($5.src.host && $5.src.host->af &&
				    !$5.src.host->ifindex)
					r.af = $5.src.host->af;
				else if ($5.dst.host && $5.dst.host->af &&
				    !$5.dst.host->ifindex)
					r.af = $5.dst.host->af;
			}

			if ($6 != NULL)
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >=
				    PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

			if ($7.name)
				if (strlcpy(r.match_tagname, $7.name,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $7.neg;
			r.rtableid = $8;

			if (r.action == PF_NONAT || r.action == PF_NORDR) {
				if ($9 != NULL) {
					yyerror("translation rule with 'no' "
					    "does not need '->'");
					YYERROR;
				}
			} else {
				if ($9 == NULL || $9->host == NULL) {
					yyerror("translation rule requires '-> "
					    "address'");
					YYERROR;
				}
				if (!r.af && ! $9->host->ifindex)
					r.af = $9->host->af;

				remove_invalid_hosts(&$9->host, &r.af);
				if (invalid_redirect($9->host, r.af))
					YYERROR;
				if (check_netmask($9->host, r.af))
					YYERROR;

				r.rpool.proxy_port[0] = ntohs($9->rport.a);

				switch (r.action) {
				case PF_RDR:
					if (!$9->rport.b && $9->rport.t &&
					    $5.dst.port != NULL) {
						r.rpool.proxy_port[1] =
						    ntohs($9->rport.a) +
						    (ntohs(
						    $5.dst.port->port[1]) -
						    ntohs(
						    $5.dst.port->port[0]));
					} else
						r.rpool.proxy_port[1] =
						    ntohs($9->rport.b);
					break;
				case PF_NAT:
					r.rpool.proxy_port[1] =
					    ntohs($9->rport.b);
					if (!r.rpool.proxy_port[0] &&
					    !r.rpool.proxy_port[1]) {
						r.rpool.proxy_port[0] =
						    PF_NAT_PROXY_PORT_LOW;
						r.rpool.proxy_port[1] =
						    PF_NAT_PROXY_PORT_HIGH;
					} else if (!r.rpool.proxy_port[1])
						r.rpool.proxy_port[1] =
						    r.rpool.proxy_port[0];
					break;
				default:
					break;
				}

				r.rpool.opts = $10.type;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($9->host->next != NULL ||
				    $9->host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($9->host->addr)))
					r.rpool.opts = PF_POOL_ROUNDROBIN;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($9->host, "tables are only "
				    "supported in round-robin redirection "
				    "pools"))
					YYERROR;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($9->host, "interface (%s) "
				    "is only supported in round-robin "
				    "redirection pools"))
					YYERROR;
				if ($9->host->next != NULL) {
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) {
						yyerror("only round-robin "
						    "valid for multiple "
						    "redirection addresses");
						YYERROR;
					}
				}
			}

			if ($10.key != NULL)
				memcpy(&r.rpool.key, $10.key,
				    sizeof(struct pf_poolhashkey));

			 if ($10.opts)
				r.rpool.opts |= $10.opts;

			if ($10.staticport) {
				if (r.action != PF_NAT) {
					yyerror("the 'static-port' option is "
					    "only valid with nat rules");
					YYERROR;
				}
				if (r.rpool.proxy_port[0] !=
				    PF_NAT_PROXY_PORT_LOW &&
				    r.rpool.proxy_port[1] !=
				    PF_NAT_PROXY_PORT_HIGH) {
					yyerror("the 'static-port' option can't"
					    " be used when specifying a port"
					    " range");
					YYERROR;
				}
				r.rpool.proxy_port[0] = 0;
				r.rpool.proxy_port[1] = 0;
			}

			expand_rule(&r, $2, $9 == NULL ? NULL : $9->host, $4,
			    $5.src_os, $5.src.host, $5.src.port, $5.dst.host,
			    $5.dst.port, 0, 0, 0, "");
			free($9);
		}
		;

binatrule	: no BINAT natpasslog interface af proto FROM host toipspec tag
		    tagged rtable redirection
		{
			struct pf_rule		binat;
			struct pf_pooladdr	*pa;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;
			if (disallow_urpf_failed($9, "\"urpf-failed\" is not "
			    "permitted as a binat destination"))
				YYERROR;

			memset(&binat, 0, sizeof(binat));

			if ($1 && $3.b1) {
				yyerror("\"pass\" not valid with \"no\"");
				YYERROR;
			}
			if ($1)
				binat.action = PF_NOBINAT;
			else
				binat.action = PF_BINAT;
			binat.natpass = $3.b1;
			binat.log = $3.b2;
			binat.logif = $3.w2;
			binat.af = $5;
			if (!binat.af && $8 != NULL && $8->af)
				binat.af = $8->af;
			if (!binat.af && $9 != NULL && $9->af)
				binat.af = $9->af;

			if (!binat.af && $13 != NULL && $13->host)
				binat.af = $13->host->af;
			if (!binat.af) {
				yyerror("address family (inet/inet6) "
				    "undefined");
				YYERROR;
			}

			if ($4 != NULL) {
				memcpy(binat.ifname, $4->ifname,
				    sizeof(binat.ifname));
				binat.ifnot = $4->not;
				free($4);
			}

			if ($10 != NULL)
				if (strlcpy(binat.tagname, $10,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			if ($11.name)
				if (strlcpy(binat.match_tagname, $11.name,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			binat.match_tag_not = $11.neg;
			binat.rtableid = $12;

			if ($6 != NULL) {
				binat.proto = $6->proto;
				free($6);
			}

			if ($8 != NULL && disallow_table($8, "invalid use of "
			    "table <%s> as the source address of a binat rule"))
				YYERROR;
			if ($8 != NULL && disallow_alias($8, "invalid use of "
			    "interface (%s) as the source address of a binat "
			    "rule"))
				YYERROR;
			if ($13 != NULL && $13->host != NULL && disallow_table(
			    $13->host, "invalid use of table <%s> as the "
			    "redirect address of a binat rule"))
				YYERROR;
			if ($13 != NULL && $13->host != NULL && disallow_alias(
			    $13->host, "invalid use of interface (%s) as the "
			    "redirect address of a binat rule"))
				YYERROR;

			if ($8 != NULL) {
				if ($8->next) {
					yyerror("multiple binat ip addresses");
					YYERROR;
				}
				if ($8->addr.type == PF_ADDR_DYNIFTL)
					$8->af = binat.af;
				if ($8->af != binat.af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				if (check_netmask($8, binat.af))
					YYERROR;
				memcpy(&binat.src.addr, &$8->addr,
				    sizeof(binat.src.addr));
				free($8);
			}
			if ($9 != NULL) {
				if ($9->next) {
					yyerror("multiple binat ip addresses");
					YYERROR;
				}
				if ($9->af != binat.af && $9->af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				if (check_netmask($9, binat.af))
					YYERROR;
				memcpy(&binat.dst.addr, &$9->addr,
				    sizeof(binat.dst.addr));
				binat.dst.neg = $9->not;
				free($9);
			}

			if (binat.action == PF_NOBINAT) {
				if ($13 != NULL) {
					yyerror("'no binat' rule does not need"
					    " '->'");
					YYERROR;
				}
			} else {
				if ($13 == NULL || $13->host == NULL) {
					yyerror("'binat' rule requires"
					    " '-> address'");
					YYERROR;
				}

				remove_invalid_hosts(&$13->host, &binat.af);
				if (invalid_redirect($13->host, binat.af))
					YYERROR;
				if ($13->host->next != NULL) {
					yyerror("binat rule must redirect to "
					    "a single address");
					YYERROR;
				}
				if (check_netmask($13->host, binat.af))
					YYERROR;

				if (!PF_AZERO(&binat.src.addr.v.a.mask,
				    binat.af) &&
				    !PF_AEQ(&binat.src.addr.v.a.mask,
				    &$13->host->addr.v.a.mask, binat.af)) {
					yyerror("'binat' source mask and "
					    "redirect mask must be the same");
					YYERROR;
				}

				TAILQ_INIT(&binat.rpool.list);
				pa = calloc(1, sizeof(struct pf_pooladdr));
				if (pa == NULL)
					err(1, "binat: calloc");
				pa->addr = $13->host->addr;
				pa->ifname[0] = 0;
				TAILQ_INSERT_TAIL(&binat.rpool.list,
				    pa, entries);

				free($13);
			}

			pfctl_add_rule(pf, &binat, "");
		}
		;

tag		: /* empty */		{ $$ = NULL; }
		| TAG STRING		{ $$ = $2; }
		;

tagged		: /* empty */		{ $$.neg = 0; $$.name = NULL; }
		| not TAGGED string	{ $$.neg = $1; $$.name = $3; }
		;

rtable		: /* empty */		{ $$ = -1; }
		| RTABLE NUMBER		{
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rtable id");
				YYERROR;
			}
			$$ = $2;
		}
		;

a3826 27
	switch (r->action) {
	case PF_PASS:
	case PF_MATCH:
	case PF_DROP:
		problems = filter_consistent(r, anchor_call);
		break;
	case PF_NAT:
	case PF_NONAT:
		problems = nat_consistent(r);
		break;
	case PF_RDR:
	case PF_NORDR:
		problems = rdr_consistent(r);
		break;
	case PF_BINAT:
	case PF_NOBINAT:
	default:
		break;
	}
	return (problems);
}

int
filter_consistent(struct pf_rule *r, int anchor_call)
{
	int	problems = 0;

d3882 14
a3911 33
nat_consistent(struct pf_rule *r)
{
	return (0);	/* yeah! */
}

int
rdr_consistent(struct pf_rule *r)
{
	int			 problems = 0;

	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP) {
		if (r->src.port_op) {
			yyerror("src port only applies to tcp/udp");
			problems++;
		}
		if (r->dst.port_op) {
			yyerror("dst port only applies to tcp/udp");
			problems++;
		}
		if (r->rpool.proxy_port[0]) {
			yyerror("rpool port only applies to tcp/udp");
			problems++;
		}
	}
	if (r->dst.port_op &&
	    r->dst.port_op != PF_OP_EQ && r->dst.port_op != PF_OP_RRG) {
		yyerror("invalid port operator for rdr destination port");
		problems++;
	}
	return (-problems);
}

int
d4405 99
d4505 2
a4506 2
expand_rule(struct pf_rule *r,
    struct node_if *interfaces, struct node_host *rpool_hosts,
a4518 2
	struct pf_pooladdr	*pa;
	struct node_host	*h;
d4642 2
a4643 15
		TAILQ_INIT(&r->rpool.list);
		for (h = rpool_hosts; h != NULL; h = h->next) {
			pa = calloc(1, sizeof(struct pf_pooladdr));
			if (pa == NULL)
				err(1, "expand_rule: calloc");
			pa->addr = h->addr;
			if (h->ifname != NULL) {
				if (strlcpy(pa->ifname, h->ifname,
				    sizeof(pa->ifname)) >=
				    sizeof(pa->ifname))
					errx(1, "expand_rule: strlcpy");
			} else
				pa->ifname[0] = 0;
			TAILQ_INSERT_TAIL(&r->rpool.list, pa, entries);
		}
d4665 4
a4668 1
	FREE_LIST(struct node_host, rpool_hosts);
d4795 1
d4819 1
a5058 6
		lungetc(next);
		break;
	case '-':
		next = lgetc(0);
		if (next == '>')
			return (ARROW);
@


1.561
log
@When will people learn to commit their .h file changes?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.559 2009/05/14 22:56:11 sthen Exp $	*/
d343 2
d3313 3
a3315 6
			if (!strcmp($1, "lowdelay"))
				$$ = IPTOS_LOWDELAY;
			else if (!strcmp($1, "throughput"))
				$$ = IPTOS_THROUGHPUT;
			else if (!strcmp($1, "reliability"))
				$$ = IPTOS_RELIABILITY;
d3319 2
a3320 2
				$$ = 0;		/* flag bad argument */
			if (!$$ || $$ > 255) {
d3329 1
a3329 1
			if (!$$ || $$ > 255) {
d5973 51
@


1.560
log
@Make it possible to use DiffServ Code Point in the TOS fields. Names like
af11, cs6 and ef will now be mapped to the coresponding TOS value.
OK henning@@, sthen@@, mcbride@@
@
text
@a342 2
int	 kw_casecmp(const void *, const void *);
int	 map_tos(char *string, int *);
d3311 6
a3316 3
			int val;
			if (map_tos($1, &val))
				$$ = val;
d3320 2
a3321 2
				$$ = 256;		/* flag bad argument */
			if ($$ > 255) {
d3330 1
a3330 1
			if ($$ > 255) {
a5973 51
	return (0);
}

int
kw_casecmp(const void *k, const void *e)
{
	return (strcasecmp(k, ((const struct keywords *)e)->k_name));
}

int
map_tos(char *s, int *val)
{
	/* DiffServ Codepoints and other TOS mappings */
	const struct keywords	 toswords[] = {
		{ "af11",		IPTOS_DSCP_AF11 },
		{ "af12",		IPTOS_DSCP_AF12 },
		{ "af13",		IPTOS_DSCP_AF13 },
		{ "af21",		IPTOS_DSCP_AF21 },
		{ "af22",		IPTOS_DSCP_AF22 },
		{ "af23",		IPTOS_DSCP_AF23 },
		{ "af31",		IPTOS_DSCP_AF31 },
		{ "af32",		IPTOS_DSCP_AF32 },
		{ "af33",		IPTOS_DSCP_AF33 },
		{ "af41",		IPTOS_DSCP_AF41 },
		{ "af42",		IPTOS_DSCP_AF42 },
		{ "af43",		IPTOS_DSCP_AF43 },
		{ "critical",		IPTOS_PREC_CRITIC_ECP },
		{ "cs0",		IPTOS_DSCP_CS0 },
		{ "cs1",		IPTOS_DSCP_CS1 },
		{ "cs2",		IPTOS_DSCP_CS2 },
		{ "cs3",		IPTOS_DSCP_CS3 },
		{ "cs4",		IPTOS_DSCP_CS4 },
		{ "cs5",		IPTOS_DSCP_CS5 },
		{ "cs6",		IPTOS_DSCP_CS6 },
		{ "cs7",		IPTOS_DSCP_CS7 },
		{ "ef",			IPTOS_DSCP_EF },
		{ "inetcontrol",	IPTOS_PREC_INTERNETCONTROL },
		{ "lowdelay",		IPTOS_LOWDELAY },
		{ "netcontrol",		IPTOS_PREC_NETCONTROL },
		{ "reliability",	IPTOS_RELIABILITY },
		{ "throughput",		IPTOS_THROUGHPUT }
	};
	const struct keywords	*p;

	p = bsearch(s, toswords, sizeof(toswords)/sizeof(toswords[0]),
	    sizeof(toswords[0]), kw_casecmp);

	if (p) {
		*val = p->k_val;
		return (1);
	}
@


1.559
log
@actually change the require-order default to No; I missed a part with
my last commit.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.558 2009/04/26 12:30:20 sthen Exp $	*/
d343 2
d3313 3
a3315 6
			if (!strcmp($1, "lowdelay"))
				$$ = IPTOS_LOWDELAY;
			else if (!strcmp($1, "throughput"))
				$$ = IPTOS_THROUGHPUT;
			else if (!strcmp($1, "reliability"))
				$$ = IPTOS_RELIABILITY;
d3319 2
a3320 2
				$$ = 0;		/* flag bad argument */
			if (!$$ || $$ > 255) {
d3329 1
a3329 1
			if (!$$ || $$ > 255) {
d5973 51
@


1.558
log
@switch the require-order default to "no". regression tests still pass.
ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.557 2009/04/25 19:29:54 henning Exp $	*/
d5654 1
a5654 1
	require_order = 1;
@


1.557
log
@scrub_opts must not be empty, scrub on its own does nothing.
noticed due to a question from otto@@, ok regress/sbin/pfctl/ ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.556 2009/04/06 12:05:55 henning Exp $	*/
d72 1
a72 1
static int		 require_order = 1;
@


1.556
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.555 2009/02/19 17:08:42 deraadt Exp $	*/
a1035 4
		| /* empty */ {
			bzero(&scrub_opts, sizeof scrub_opts);
			$$ = scrub_opts;
		}
@


1.555
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.554 2008/10/17 12:59:53 henning Exp $	*/
a110 1
	PFCTL_STATE_SCRUB,
d207 9
a215 5
#define FOM_FLAGS	0x01
#define FOM_ICMP	0x02
#define FOM_TOS		0x04
#define FOM_KEEP	0x08
#define FOM_SRCTRACK	0x10
d243 7
a258 4
#define SOM_MINTTL	0x01
#define SOM_MAXMSS	0x02
#define SOM_FRAGCACHE	0x04
#define SOM_SETTOS	0x08
a262 1
	int			fragcache;
a264 3
	char		       *match_tag;
	u_int8_t		match_tag_not;
	u_int			rtableid;
d435 1
a435 1
%token	PASS BLOCK SCRUB RETURN IN OS OUT LOG QUICK ON FROM TO FLAGS
d457 1
a457 1
%type	<v.number>		tos not yesno
d459 1
a459 1
%type	<v.i>			no dir af fragcache optimizer
d461 1
a461 1
%type	<v.b>			action nataction natpasslog scrubaction
a508 1
		| ruleset scrubrule '\n'
d564 10
a573 1
option		: SET OPTIMIZATION STRING		{
a1030 67
scrubaction	: no SCRUB {
			$$.b2 = $$.w = 0;
			if ($1)
				$$.b1 = PF_NOSCRUB;
			else
				$$.b1 = PF_SCRUB;
		}
		;

scrubrule	: scrubaction dir logquick interface af proto fromto scrub_opts
		{
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_SCRUB))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			r.direction = $2;

			r.log = $3.log;
			r.logif = $3.logif;
			if ($3.quick) {
				yyerror("scrub rules do not support 'quick'");
				YYERROR;
			}

			r.af = $5;
			if ($8.nodf)
				r.rule_flag |= PFRULE_NODF;
			if ($8.randomid)
				r.rule_flag |= PFRULE_RANDOMID;
			if ($8.reassemble_tcp) {
				if (r.direction != PF_INOUT) {
					yyerror("reassemble tcp rules can not "
					    "specify direction");
					YYERROR;
				}
				r.rule_flag |= PFRULE_REASSEMBLE_TCP;
			}
			if ($8.minttl)
				r.min_ttl = $8.minttl;
			if ($8.maxmss)
				r.max_mss = $8.maxmss;
			if ($8.marker & SOM_SETTOS) {
				r.rule_flag |= PFRULE_SET_TOS;
				r.set_tos = $8.settos;
			}
			if ($8.fragcache)
				r.rule_flag |= $8.fragcache;
			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $8.match_tag_not;
			r.rtableid = $8.rtableid;

			expand_rule(&r, $4, NULL, $6, $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
			    NULL, NULL, NULL, "");
		}
		;

a1032 1
				scrub_opts.rtableid = -1;
a1037 1
			scrub_opts.rtableid = -1;
d1042 1
a1042 1
scrub_opts_l	: scrub_opts_l scrub_opt
d1054 1
a1054 1
			if (scrub_opts.marker & SOM_MINTTL) {
d1062 1
a1062 1
			scrub_opts.marker |= SOM_MINTTL;
d1066 1
a1066 1
			if (scrub_opts.marker & SOM_MAXMSS) {
d1074 1
a1074 1
			scrub_opts.marker |= SOM_MAXMSS;
d1078 1
a1078 1
			if (scrub_opts.marker & SOM_SETTOS) {
d1082 1
a1082 1
			scrub_opts.marker |= SOM_SETTOS;
a1084 8
		| fragcache {
			if (scrub_opts.marker & SOM_FRAGCACHE) {
				yyerror("fragcache cannot be respecified");
				YYERROR;
			}
			scrub_opts.marker |= SOM_FRAGCACHE;
			scrub_opts.fragcache = $1;
		}
a1105 16
		| RTABLE NUMBER				{
			if ($2 < 0 || $2 > RT_TABLEID_MAX) {
				yyerror("invalid rtable id");
				YYERROR;
			}
			scrub_opts.rtableid = $2;
		}
		| not TAGGED string			{
			scrub_opts.match_tag = $3;
			scrub_opts.match_tag_not = $1;
		}
		;

fragcache	: FRAGMENT REASSEMBLE	{ $$ = 0; /* default */ }
		| FRAGMENT FRAGCROP	{ $$ = PFRULE_FRAGCROP; }
		| FRAGMENT FRAGDROP	{ $$ = PFRULE_FRAGDROP; }
d1792 15
d2312 10
d2347 1
d4310 1
a4311 2
	case PF_SCRUB:
	case PF_NOSCRUB:
d4379 2
a4380 2
	if (r->action == PF_DROP && r->keep_state) {
		yyerror("keep state on block rules doesn't make sense");
d4390 12
d5224 1
@


1.554
log
@in findeol(), do not skip the pushback buffer. fixes PR 5952 by sthen@@ and
should make the pushback buffer really transparent.
diagnosis by me, fix with mpf, some input deraadt, ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.553 2008/10/02 12:31:18 henning Exp $	*/
d1278 1
a1278 1
antispoof_ifspc	: FOR antispoof_if		{ $$ = $2; }
d1290 2
a1291 2
antispoof_if  : if_item				{ $$ = $1; }
		| '(' if_item ')'		{
@


1.553
log
@implement "set state-defaults X", where X is a list of state options as
permitted keep state(X). applies to all rules which do not have keep state
explicitely. e. g. "set state-defaults pflow, no-sync"
ok phessler deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.552 2008/09/10 00:32:03 deraadt Exp $	*/
a5433 1
	pushback_index = 0;
d5437 4
a5440 1
		c = lgetc(0);
@


1.552
log
@do not try to print $$ when it has not been set
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.551 2008/09/09 13:56:38 henning Exp $	*/
d297 2
a298 1
struct node_hfsc_opts	hfsc_opts;
d448 1
a448 1
%token	TAGGED TAG IFBOUND FLOATING STATEPOLICY ROUTE SETTOS
d675 7
d1844 1
d1927 1
d1931 1
a1931 1
			    !($9.marker & FOM_KEEP))
d1933 3
a1936 1
			o = $9.keep.options;
d2103 2
a2104 1
				free(p);
d5325 1
@


1.551
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.550 2008/08/07 18:29:32 henning Exp $	*/
d556 1
a556 1
				yyerror("unknown ruleset-optimization %s", $$);
@


1.550
log
@correctly copy the log interface spec when expanding an antispoof rule that
covers loopback addresses. ok ryan
problem report from Harald Dunkel <harald.dunkel@@aixigo.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.549 2008/07/03 16:09:34 deraadt Exp $	*/
d156 2
a157 1
	    PF_STATE_OPT_TIMEOUT, PF_STATE_OPT_SLOPPY };
d446 1
a446 1
%token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH SLOPPY
d2065 9
d3554 8
d5277 1
@


1.549
log
@do not forget to initialize other member of $$ in qname; noted by mark shroyer
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.548 2008/06/10 20:55:02 mcbride Exp $	*/
d1248 1
@


1.548
log
@Make counters on table addresses optional and disabled by default.
Use the 'counters' table option in pf.conf if you actually need them.
If enabled, memory is not allocated until packets match an address.

This saves about 40% memory if counters are not being used, and paves the way
for some more significant cleanups coming soon.

ok henning mpf deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.547 2008/06/10 04:28:54 henning Exp $	*/
d3582 1
d3586 1
@


1.547
log
@new state option "sloppy" to use the sloppy tcp state tracker instead
of the good one. ok theo ryan reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.546 2008/05/09 08:16:07 deraadt Exp $	*/
d1377 2
@


1.546
log
@Replace a crockpot of semi-cloned productions for handling port
numbers with one, and fix a few other bugs along the way
ok mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.545 2008/05/09 05:41:01 markus Exp $	*/
d156 1
a156 1
	    PF_STATE_OPT_TIMEOUT };
d445 1
a445 1
%token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH
d2053 8
d3533 8
d4405 7
d5284 1
@


1.545
log
@convert port byte order in the production; add port keyword; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.544 2008/05/09 02:44:54 markus Exp $	*/
d421 4
d459 1
a459 1
%type	<v.range>		port rport
d2329 1
a2329 1
		| DIVERTTO STRING PORT number {
d2337 1
a2337 1
			filter_opts.divert.port = htons($4);
d2339 1
a2339 1
				yyerror("invalid divert port: %d", $4);
d2947 1
a2947 1
port_item	: port				{
d2960 1
a2960 1
		| unaryop port		{
d2975 1
a2975 1
		| port PORTBINARY port		{
d2992 4
a2995 21
port		: STRING			{
			char	*p = strchr($1, ':');

			if (p == NULL) {
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = $$.t = 0;
			} else {
				int port[2];

				*p++ = 0;
				if ((port[0] = getservice($1)) == -1 ||
				    (port[1] = getservice(p)) == -1) {
					free($1);
					YYERROR;
				}
				$$.a = port[0];
				$$.b = port[1];
				$$.t = PF_OP_RRG;
d2999 5
a3003 3
		| NUMBER			{
			if ($1 < 0 || $1 > 65535) {
				yyerror("illegal port value %lu", $1);
d3006 1
a3006 2
			$$.a = ntohs($1);
			$$.b = $$.t = 0;
d3578 4
a3581 27
rport		: STRING			{
			char	*p = strchr($1, ':');

			if (p == NULL) {
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = $$.t = 0;
			} else if (!strcmp(p+1, "*")) {
				*p = 0;
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = 0;
				$$.t = 1;
			} else {
				*p++ = 0;
				if (($$.a = getservice($1)) == -1 ||
				    ($$.b = getservice(p)) == -1) {
					free($1);
					YYERROR;
				}
				if ($$.a == $$.b)
					$$.b = 0;
				$$.t = 0;
a3584 8
		| NUMBER			{
			if ($1 < 0 || $1 > 65535) {
				yyerror("illegal port value %ld", $1);
				YYERROR;
			}
			$$.a = ntohs($1);
			$$.b = $$.t = 0;
		}
d3607 1
a3607 1
		| ARROW redirspec PORT rport	{
d3733 1
a3733 1
		| ARROW host PORT rport	{
d5908 35
@


1.544
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.543 2008/05/08 08:08:36 deraadt Exp $	*/
d2185 1
a2185 1
			if ((r.divert.port = htons($9.divert.port))) {
d2325 1
a2325 1
		| DIVERTTO STRING number {
d2333 1
a2333 1
			filter_opts.divert.port = $3;
d2335 1
a2335 1
				yyerror("invalid divert port: %d", $3);
@


1.543
log
@make "to any" optional in binat, or well, the implied default.
requested by reyk, ok reyk mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.542 2008/05/08 07:29:30 deraadt Exp $	*/
d235 4
d443 1
d2185 24
d2325 17
d5222 2
@


1.542
log
@Loosen grammer to permit any number of newlines within most kinds of { }
blocks, as requested by reyk; ok reyk mpf henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.541 2008/05/08 00:17:26 deraadt Exp $	*/
d460 1
a460 1
%type	<v.host>		ipspec xhost host dynaddr host_list
d2649 4
d3932 1
a3932 1
binatrule	: no BINAT natpasslog interface af proto FROM host TO ipspec tag
d3940 1
a3940 1
			if (disallow_urpf_failed($10, "\"urpf-failed\" is not "
d3960 2
a3961 2
			if (!binat.af && $10 != NULL && $10->af)
				binat.af = $10->af;
d3963 2
a3964 2
			if (!binat.af && $14 != NULL && $14->host)
				binat.af = $14->host->af;
d3978 2
a3979 2
			if ($11 != NULL)
				if (strlcpy(binat.tagname, $11,
d3985 2
a3986 2
			if ($12.name)
				if (strlcpy(binat.match_tagname, $12.name,
d3992 2
a3993 2
			binat.match_tag_not = $12.neg;
			binat.rtableid = $13;
d4007 2
a4008 2
			if ($14 != NULL && $14->host != NULL && disallow_table(
			    $14->host, "invalid use of table <%s> as the "
d4011 2
a4012 2
			if ($14 != NULL && $14->host != NULL && disallow_alias(
			    $14->host, "invalid use of interface (%s) as the "
d4033 2
a4034 2
			if ($10 != NULL) {
				if ($10->next) {
d4038 1
a4038 1
				if ($10->af != binat.af && $10->af) {
d4042 1
a4042 1
				if (check_netmask($10, binat.af))
d4044 1
a4044 1
				memcpy(&binat.dst.addr, &$10->addr,
d4046 2
a4047 2
				binat.dst.neg = $10->not;
				free($10);
d4051 1
a4051 1
				if ($14 != NULL) {
d4057 1
a4057 1
				if ($14 == NULL || $14->host == NULL) {
d4063 2
a4064 2
				remove_invalid_hosts(&$14->host, &binat.af);
				if (invalid_redirect($14->host, binat.af))
d4066 1
a4066 1
				if ($14->host->next != NULL) {
d4071 1
a4071 1
				if (check_netmask($14->host, binat.af))
d4077 1
a4077 1
				    &$14->host->addr.v.a.mask, binat.af)) {
d4087 1
a4087 1
				pa->addr = $14->host->addr;
d4092 1
a4092 1
				free($14);
@


1.541
log
@Bring back (in a more yacc friendly way) support for setting variables
to a sequence of strings and numbers, which get folded together into one
string (and later, when used, is re-lexed)
ok mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.540 2008/05/07 08:08:39 deraadt Exp $	*/
d571 1
a571 1
		| SET TIMEOUT '{' timeout_list '}'
d573 1
a573 1
		| SET LIMIT '{' limit_list '}'
d1260 1
a1260 1
		| FOR '{' antispoof_iflst '}'	{ $$ = $3; }
d1263 2
a1264 2
antispoof_iflst	: antispoof_if				{ $$ = $1; }
		| antispoof_iflst comma antispoof_if	{
d1375 2
a1376 2
		| '{' '}'		{ table_opts.init_addr = 1; }
		| '{' host_list '}'	{
d1380 1
a1380 1
			for (n = $2; n != NULL; n = n->next) {
d1411 1
a1411 1
			ti->host = $2;
d1785 1
a1785 1
		| '{' qassign_list '}'	{ $$ = $2; }
d1788 2
a1789 2
qassign_list	: qassign_item			{ $$ = $1; }
		| qassign_list comma qassign_item	{
d2476 1
a2476 1
		| ON '{' if_list '}'		{ $$ = $3; }
d2479 2
a2480 2
if_list		: if_item_not			{ $$ = $1; }
		| if_list comma if_item_not	{
d2519 3
a2521 3
proto		: /* empty */			{ $$ = NULL; }
		| PROTO proto_item		{ $$ = $2; }
		| PROTO '{' proto_list '}'	{ $$ = $3; }
d2524 2
a2525 2
proto_list	: proto_item			{ $$ = $1; }
		| proto_list comma proto_item	{
d2585 1
a2585 1
		| OS '{' os_list '}'		{ $$ = $3; }
d2597 2
a2598 2
os_list		: xos				{ $$ = $1; }
		| os_list comma xos		{
d2640 4
d2646 1
a2646 1
		| '{' host_list '}'		{ $$ = $2; }
d2649 2
a2650 2
host_list	: ipspec			{ $$ = $1; }
		| host_list comma ipspec	{
d2882 1
a2882 1
		| '{' port_list '}'		{ $$ = $2; }
d2885 2
a2886 2
port_list	: port_item			{ $$ = $1; }
		| port_list comma port_item	{
d2973 1
a2973 1
		| '{' uid_list '}'		{ $$ = $2; }
d2976 2
a2977 2
uid_list	: uid_item			{ $$ = $1; }
		| uid_list comma uid_item	{
d3051 1
a3051 1
		| '{' gid_list '}'		{ $$ = $2; }
d3054 2
a3055 2
gid_list	: gid_item			{ $$ = $1; }
		| gid_list comma gid_item	{
d3146 4
a3149 4
icmpspec	: ICMPTYPE icmp_item		{ $$ = $2; }
		| ICMPTYPE '{' icmp_list '}'	{ $$ = $3; }
		| ICMP6TYPE icmp6_item		{ $$ = $2; }
		| ICMP6TYPE '{' icmp6_list '}'	{ $$ = $3; }
d3152 2
a3153 2
icmp_list	: icmp_item			{ $$ = $1; }
		| icmp_list comma icmp_item	{
d3160 2
a3161 2
icmp6_list	: icmp6_item			{ $$ = $1; }
		| icmp6_list comma icmp6_item	{
d3581 1
a3581 1
		| '{' redir_host_list '}'	{ $$ = $2; }
d3584 2
a3585 2
redir_host_list	: host				{ $$ = $1; }
		| redir_host_list comma host	{
d4128 2
a4129 2
route_host_list	: route_host				{ $$ = $1; }
		| route_host_list comma route_host	{
d4144 1
a4144 1
		| '{' route_host_list '}'	{ $$ = $2; }
d4199 2
a4200 2
timeout_list	: timeout_list comma timeout_spec
		| timeout_spec
d4222 2
a4223 2
limit_list	: limit_list comma limit_spec
		| limit_spec
@


1.540
log
@do not assume PF_INOUT is 0 in the enum; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.539 2008/05/07 07:07:29 markus Exp $	*/
d469 2
a470 1
%type	<v.string>		label string stringall tag anchorname
d674 1
a674 1
string		: string STRING				{
d683 3
a685 5
varset		: STRING '=' string		{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			if (symset($1, $3, 0) == -1)
				err(1, "cannot store variable %s", $1);
d687 1
a687 1
			free($3);
d689 4
a692 1
		| STRING '=' NUMBER	{
d694 1
a694 1
			if (asprintf(&s, "%lld", $3) == -1) {
d698 6
d705 2
a706 2
				printf("%s = \"%s\"\n", $1, s);
			if (symset($1, s, 0) == -1)
d709 1
a709 1
			free(s);
@


1.539
log
@scrub packets based on tags; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.538 2008/05/07 06:23:30 markus Exp $	*/
d2410 1
a2410 1
dir		: /* empty */			{ $$ = 0; }
@


1.538
log
@allow setting TOS with scrub; ok mcbride, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.537 2008/04/21 01:42:19 deraadt Exp $	*/
d255 2
d1046 8
d1153 4
@


1.537
log
@optnl is a crutch for those who do not understand yacc.  it
leads to a variety of errors; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.536 2008/02/01 06:58:45 mcbride Exp $	*/
d247 1
d251 1
d436 1
a436 1
%token	TAGGED TAG IFBOUND FLOATING STATEPOLICY ROUTE
d1038 4
d1100 8
d2211 1
a2211 1
		| tos {
d2217 1
a2217 1
			filter_opts.tos = $1;
d3273 2
a3274 2
tos		: TOS STRING			{
			if (!strcmp($2, "lowdelay"))
d3276 1
a3276 1
			else if (!strcmp($2, "throughput"))
d3278 1
a3278 1
			else if (!strcmp($2, "reliability"))
d3280 2
a3281 2
			else if ($2[0] == '0' && $2[1] == 'x')
				$$ = strtoul($2, NULL, 16);
d3285 2
a3286 2
				yyerror("illegal tos value %s", $2);
				free($2);
d3289 1
a3289 1
			free($2);
d3291 2
a3292 2
		| TOS NUMBER			{
			$$ = $2;
d3294 1
a3294 1
				yyerror("illegal tos value %s", $2);
d5224 1
@


1.536
log
@Enable the rest of the filter_opts to be used on anchors. These were accepted
by the parser but not passed to the kernel.  This allows filtering based on
uid, gid, icmp options, tcp flags, os fingerprint, tos, tags, and probability;
It also allows the label to be set. State options and tagging are not
permitted.

ok henning mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.535 2007/11/13 00:47:56 mpf Exp $	*/
d705 4
a708 8
optnl		: optnl '\n'
		|
		;

pfa_anchorlist	: pfrule optnl
		| anchorrule optnl
		| pfa_anchorlist pfrule optnl
		| pfa_anchorlist anchorrule optnl
@


1.535
log
@Bring back the number converter for 'set hostid'.
I forgot to think about hex numbers when I removed it.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.534 2007/11/12 23:59:41 mpf Exp $	*/
d745 1
d796 49
d859 2
a860 2
			    0, 0, 0, pf->astack[pf->asd + 1] ?
			    pf->alast->name : $2);
@


1.534
log
@Remove space/tab compression function from lgetc() and replace
it with a simple filter in the yylex() loop.
The compression in lgetc() didn't happen for quoted strings,
thus creating a regression when tabs were used in variables.
Some testing by todd@@ and pyr@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.533 2007/10/25 21:36:21 mpf Exp $	*/
d439 1
a439 1
%type	<v.number>		icmptype icmp6type uid gid
d581 1
a581 1
		| SET HOSTID NUMBER {
d2724 14
@


1.533
log
@Fix probability rules w/ numbers (e.g probability 0.4).
Add support for probablities of 0% and 100%.
With and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.532 2007/10/22 16:35:33 pyr Exp $	*/
a5230 8
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(file->stream);
		} while (c == '\t' || c == ' ');
		ungetc(c, file->stream);
		c = ' ';
	}
d5287 1
a5287 1
	while ((c = lgetc(0)) == ' ')
@


1.532
log
@sync with daemon parser code.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.531 2007/10/22 00:40:46 deraadt Exp $	*/
d344 1
d441 1
d2195 2
a2196 3
		| PROBABILITY STRING			{
			char	*e;
			double	 p = strtod($2, &e);
d2198 3
a2200 13
			if (*e == '%') {
				p *= 0.01;
				e++;
			}
			if (*e) {
				yyerror("invalid probability: %s", $2);
				free($2);
				YYERROR;
			}
			p = floor(p * (UINT_MAX+1.0) + 0.5);
			if (p < 1.0 || p >= (UINT_MAX+1.0)) {
				yyerror("invalid probability: %s", $2);
				free($2);
d2204 2
a2205 1
			free($2);
d2215 22
@


1.531
log
@pfctl does not need file secrecy
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.530 2007/10/16 19:20:27 mpf Exp $	*/
d5464 2
a5465 1
	    (nfile->name = strdup(name)) == NULL)
d5467 1
d5472 1
d5477 1
@


1.530
log
@Allow unquoted numbers in variables.
Change 'set hostid' to NUMBER and remove unneeded converter.
Add '=' to allowed_to_end_number(x) to make varsets like 4=5 illegal.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.529 2007/10/16 06:06:49 deraadt Exp $	*/
d507 1
a507 1
			if ((nfile = pushfile($2, 1)) == NULL) {
d5521 1
a5521 1
	if ((file = pushfile(filename, 1)) == NULL) {
@


1.529
log
@in the lex... even inside quotes, a \ followed by space or tab should
expand to space or tab, and a \ followed by newline should be ignored
(as a line continuation).  compatible with the needs of hoststated
(which has the most strict quoted string requirements), and ifstated
(where one commonly does line continuations in strings).
pointed out by mpf, discussed with pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.528 2007/10/13 21:49:13 deraadt Exp $	*/
d438 1
a438 1
%type	<v.number>		number icmptype icmp6type uid gid
d579 1
a579 1
		| SET HOSTID number {
d684 13
a2712 14
number		: NUMBER
		| STRING		{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
				free($1);
				YYERROR;
			} else
				$$ = ulval;
			free($1);
		}
		;

d5373 1
a5373 1
	(isspace(x) || x == ')' || x ==',' || x == '/' || x == '}')
@


1.528
log
@support an include directive; file of course must also be "secure" like
the main configuration file; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.527 2007/10/13 16:35:18 deraadt Exp $	*/
d5329 1
a5329 1
				if (next == quotec)
d5331 2
@


1.527
log
@in all these programs using the same pfctl-derived parse.y, re-unify the
yylex implementation and the code which interacts with yylex.  this also
brings the future potential for include support to all of the parsers.
in the future please do not silly modifications to one of these files
without checking if you are de-unifying the code.
checked by developers in all these areas.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.526 2007/10/11 14:39:16 deraadt Exp $	*/
d343 1
a343 1
		int64_t		 	 number;
d426 1
a426 1
%token	ANTISPOOF FOR
d486 1
d504 15
d5079 1
@


1.526
log
@next step in the yylex unification: handle quoted strings in a nicer fashion
as found in hoststated, and make all the code diff as clean as possible. a
few issues remain mostly surrounding include support, which will likely be
added to more of the grammers soon.
ok norby pyr, others
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.525 2007/10/01 12:37:40 mpf Exp $	*/
d32 1
d47 1
a64 1
static FILE		*fin = NULL;
a65 2
static int		 lineno = 1;
static int		 errors = 0;
d75 33
d290 31
a320 30
int	yyerror(const char *, ...);
int	disallow_table(struct node_host *, const char *);
int	disallow_urpf_failed(struct node_host *, const char *);
int	disallow_alias(struct node_host *, const char *);
int	rule_consistent(struct pf_rule *, int);
int	filter_consistent(struct pf_rule *, int);
int	nat_consistent(struct pf_rule *);
int	rdr_consistent(struct pf_rule *);
int	process_tabledef(char *, struct table_opts *);
int	yyparse(void);
void	expand_label_str(char *, size_t, const char *, const char *);
void	expand_label_if(const char *, char *, size_t, const char *);
void	expand_label_addr(const char *, char *, size_t, u_int8_t,
	    struct node_host *);
void	expand_label_port(const char *, char *, size_t, struct node_port *);
void	expand_label_proto(const char *, char *, size_t, u_int8_t);
void	expand_label_nr(const char *, char *, size_t);
void	expand_label(char *, size_t, const char *, u_int8_t, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    u_int8_t);
void	expand_rule(struct pf_rule *, struct node_if *, struct node_host *,
	    struct node_proto *, struct node_os*, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    struct node_uid *, struct node_gid *, struct node_icmp *,
	    const char *);
int	expand_altq(struct pf_altq *, struct node_if *, struct node_queue *,
	    struct node_queue_bw bwspec, struct node_queue_opt *);
int	expand_queue(struct pf_altq *, struct node_if *, struct node_queue *,
	    struct node_queue_bw, struct node_queue_opt *);
int	expand_skip_interface(struct node_if *);
a322 7
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(int);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
int	 atoul(char *, u_long *);
a325 13
TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};


int	 symset(const char *, const char *, int);
char	*symget(const char *);

d500 1
a500 1
		| ruleset error '\n'		{ errors++; }
a4128 1
	extern char	*infile;
d4130 1
a4130 1
	errors = 1;
d4132 1
a4132 1
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
d5164 1
a5164 1
lgetc(int inquot)
d5166 1
a5166 2
	int	c, next;
	FILE *f = fin;
d5182 7
a5188 2
	if (inquot) {
		c = getc(f);
d5192 2
a5193 2
	while ((c = getc(f)) == '\\') {
		next = getc(f);
d5198 2
a5199 2
		yylval.lineno = lineno;
		lineno++;
d5204 1
a5204 1
			c = getc(f);
d5206 1
a5206 1
		ungetc(c, f);
d5210 5
d5246 1
a5246 1
			lineno++;
d5260 1
a5260 1
	int	 endc, next, c;
d5268 1
a5268 1
	yylval.lineno = lineno;
d5302 1
a5302 1
		endc = c;
d5304 1
a5304 1
			if ((c = lgetc(1)) == EOF)
d5307 1
a5307 1
				lineno++;
d5310 1
a5310 1
				if ((next = lgetc(1)) == EOF)
d5312 1
a5312 1
				if (next == endc)
d5316 1
a5316 1
			} else if (c == endc) {
d5412 2
a5413 2
		yylval.lineno = lineno;
		lineno++;
d5421 1
a5421 1
parse_rules(FILE *input, struct pfctl *xpf)
d5423 70
a5492 1
	struct sym	*sym, *next;
a5493 1
	fin = input;
a5494 1
	lineno = 1;
d5503 5
d5509 2
d5513 1
a5513 2
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
d5519 1
a5519 1
		TAILQ_REMOVE(&symhead, sym, entries);
a5525 4
/*
 * Over-designed efficiency is a French and German concept, so how about
 * we wait until they discover this ugliness and make it all fancy.
 */
d5532 1
a5532 1
	    sym = TAILQ_NEXT(sym, entries))
d5541 1
a5541 1
			TAILQ_REMOVE(&symhead, sym, entries);
d5561 1
a5561 1
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d5590 1
a5590 1
	TAILQ_FOREACH(sym, &symhead, entries)
a5775 1
	FILE			*fin;
d5781 1
a5781 5
		if ((fin = pfctl_fopen(la->filename, "r")) == NULL) {
			warn("%s", la->filename);
			continue;
		}
		if (pfctl_rules(dev, la->filename, fin, pf->opts, pf->optimize,
@


1.525
log
@Backout NUMBER to string conversion.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.522 2007/09/12 18:49:03 deraadt Exp $	*/
d292 1
a292 1
int	 lgetc(FILE *);
d5152 1
a5152 1
lgetc(FILE *f)
d5155 1
d5171 5
d5223 1
a5223 1
		c = lgetc(fin);
d5239 1
a5239 1
	int	 endc, c, next;
d5244 1
a5244 1
	while ((c = lgetc(fin)) == ' ')
d5249 1
a5249 1
		while ((c = lgetc(fin)) != '\n' && c != EOF)
d5253 1
a5253 1
			if ((c = lgetc(fin)) == EOF)
d5283 1
a5283 1
			if ((c = lgetc(fin)) == EOF)
a5284 4
			if (c == endc) {
				*p = '\0';
				break;
			}
d5288 10
d5310 1
a5310 1
		next = lgetc(fin);
d5318 1
a5318 1
		next = lgetc(fin);
d5326 1
a5326 1
		next = lgetc(fin);
d5343 1
a5343 1
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
a5344 1

d5382 1
a5382 1
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
@


1.524
log
@Add loginterface support for groups.
Using a group sums up the statistics of all members.
Modify pfctl(1) slightly to allow a groupname "all",
which gives us an overall pf(4) statistic.

OK henning@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.523 2007/09/23 20:59:59 mpf Exp $	*/
d450 1
a450 1
%type	<v.string>		label string strings stringall tag anchorname
d638 1
a638 1
strings		: strings string			{
d644 1
a644 10
		| string
		;

string		: STRING
		| NUMBER				{
			if (asprintf(&$$, "%lld", $1) == -1) {
				yyerror("string: asprintf");
				YYERROR;
			}
		}
d647 1
a647 1
varset		: STRING '=' strings		{
d657 1
a657 1
anchorname	: string			{ $$ = $1; }
d1290 1
a1290 1
		| FILENAME string	{
d1326 1
a1326 1
queuespec	: QUEUE string interface queue_opts qassign {
d1670 1
a1670 1
qassign_item	: string			{
d2631 1
a2631 1
		| '<' string '>'	{
d3296 1
a3296 1
		| OVERLOAD '<' string '>' flush		{
d3377 1
a3377 1
label		: LABEL string			{
d3382 1
a3382 1
qname		: QUEUE string				{
d3385 1
a3385 1
		| QUEUE '(' string ')'			{
d3388 1
a3388 1
		| QUEUE '(' string comma string ')'	{
d3954 1
a3954 1
		| TAG string		{ $$ = $2; }
@


1.523
log
@Allow numbers to be used as unquoted strings again.
While there, also restrict the use of concatenated, unquoted
strings for variable assignments only.

Eyeballed by markus@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.522 2007/09/12 18:49:03 deraadt Exp $	*/
d450 1
a450 1
%type	<v.string>		label string strings tag anchorname
d538 1
a538 1
		| SET LOGINTERFACE STRING		{
d626 8
@


1.522
log
@add a missing range check for rtable ids; ok cloder henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.521 2007/09/12 15:58:40 deraadt Exp $	*/
d450 1
a450 1
%type	<v.string>		label string tag anchorname
d630 1
a630 1
string		: string STRING				{
d636 10
a645 1
		| STRING
d648 1
a648 1
varset		: STRING '=' string		{
d658 1
a658 1
anchorname	: STRING			{ $$ = $1; }
d1291 1
a1291 1
		| FILENAME STRING	{
d1327 1
a1327 1
queuespec	: QUEUE STRING interface queue_opts qassign {
d1671 1
a1671 1
qassign_item	: STRING			{
d2632 1
a2632 1
		| '<' STRING '>'	{
d3297 1
a3297 1
		| OVERLOAD '<' STRING '>' flush		{
d3378 1
a3378 1
label		: LABEL STRING			{
d3383 1
a3383 1
qname		: QUEUE STRING				{
d3386 1
a3386 1
		| QUEUE '(' STRING ')'			{
d3389 1
a3389 1
		| QUEUE '(' STRING comma STRING ')'	{
d3955 1
a3955 1
		| TAG STRING		{ $$ = $2; }
@


1.521
log
@Add support to the lex for parsing number out of the stream.  handle
this in the parser.  because the new numbers are int64_t, many new
range checks for < 0 are needed.  re-check and improve all the
existing rangechecks while at it.  thanks for help by cloder and
dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.520 2007/08/30 09:28:49 dhartmei Exp $	*/
d202 1
a202 1
	int			 rtableid;
d207 1
a207 1
	int			 rtableid;
d221 1
a221 1
	int			rtableid;
d333 1
a333 1
		int			 rtableid;
d1026 4
@


1.520
log
@add support for address ranges ("from 10.1.2.50 - 10.1.3.75") in from/to
criteria. ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.518 2007/06/20 14:14:17 mpf Exp $	*/
d330 1
a330 1
		u_int32_t		 number;
d422 1
d434 1
d438 1
d551 1
a551 1
			if ($3 == 0) {
d972 1
a972 1
		| MINTTL number {
d977 1
a977 1
			if ($2 > 255) {
d984 1
a984 1
		| MAXMSS number {
d989 1
a989 1
			if ($2 > 65535) {
d1025 1
a1025 5
		| RTABLE number				{
			if ($2 > RT_TABLEID_MAX || $2 < 0) {
				yyerror("invalid rtable id");
				YYERROR;
			}
d1164 2
a1165 2
		| RTABLE number				{
			if ($2 > RT_TABLEID_MAX || $2 < 0) {
d1382 1
a1382 1
		| PRIORITY number	{
d1387 1
a1387 1
			if ($2 > 255) {
d1394 1
a1394 1
		| QLIMIT number	{
d1399 1
a1399 1
			if ($2 > 65535) {
d1414 1
a1414 1
		| TBRSIZE number	{
d1419 1
a1419 1
			if ($2 > 65535) {
d1462 8
d1566 1
a1566 1
		| LINKSHARE '(' bandwidth comma number comma bandwidth ')'
d1568 4
d1589 1
a1589 1
		| REALTIME '(' bandwidth comma number comma bandwidth ')'
d1591 4
d1612 1
a1612 1
		| UPPERLIMIT '(' bandwidth comma number comma bandwidth ')'
d1614 4
d2161 2
a2162 2
		| RTABLE number				{
			if ($2 > RT_TABLEID_MAX || $2 < 0) {
d2189 2
a2190 2
		| RETURNRST '(' TTL number ')'	{
			if ($4 > 255) {
d2208 1
a2208 1
		| RETURNICMP '(' STRING ')'	{
d2210 2
a2211 6
			if (!($$.w = parseicmpspec($3, AF_INET))) {
				free($3);
				YYERROR;
			}
			free($3);
			$$.w2 = returnicmp6default;
d2213 1
a2213 1
		| RETURNICMP6 '(' STRING ')'	{
d2216 1
a2216 5
			if (!($$.w2 = parseicmpspec($3, AF_INET6))) {
				free($3);
				YYERROR;
			}
			free($3);
d2218 1
a2218 1
		| RETURNICMP '(' STRING comma STRING ')' {
d2220 2
a2221 8
			if (!($$.w = parseicmpspec($3, AF_INET)) ||
			    !($$.w2 = parseicmpspec($5, AF_INET6))) {
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
d2230 38
d2382 1
a2382 1
proto_item	: STRING			{
a2383 1
			u_long		ulval;
d2385 1
a2385 19
			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("protocol outside range");
					free($1);
					YYERROR;
				}
				pr = (u_int8_t)ulval;
			} else {
				struct protoent	*p;

				p = getprotobyname($1);
				if (p == NULL) {
					yyerror("unknown protocol %s", $1);
					free($1);
					YYERROR;
				}
				pr = p->p_proto;
			}
			free($1);
d2399 20
d2579 1
a2579 1
		| STRING '/' number		{
d2582 1
a2582 1
			if (asprintf(&buf, "%s/%u", $1, $3) == -1)
d2593 14
d2608 1
a2608 1
		| dynaddr '/' number		{
d2611 4
d2659 2
a2660 1
number		: STRING			{
d2808 8
d2873 4
a2876 1
			u_long	ulval;
d2878 2
a2879 15
			if (atoul($1, &ulval) == -1) {
				if (!strcmp($1, "unknown"))
					$$ = UID_MAX;
				else {
					struct passwd	*pw;

					if ((pw = getpwnam($1)) == NULL) {
						yyerror("unknown user %s", $1);
						free($1);
						YYERROR;
					}
					$$ = pw->pw_uid;
				}
			} else {
				if (ulval >= UID_MAX) {
a2880 1
					yyerror("illegal uid value %lu", ulval);
d2883 1
a2883 1
				$$ = ulval;
d2887 7
d2951 4
a2954 7
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				if (!strcmp($1, "unknown"))
					$$ = GID_MAX;
				else {
					struct group	*grp;
d2956 2
a2957 10
					if ((grp = getgrnam($1)) == NULL) {
						yyerror("unknown group %s", $1);
						free($1);
						YYERROR;
					}
					$$ = grp->gr_gid;
				}
			} else {
				if (ulval >= GID_MAX) {
					yyerror("illegal gid value %lu", ulval);
d2961 1
a2961 1
				$$ = ulval;
d2965 7
a3025 1
			u_long				 ulval;
d3027 4
a3030 14
			if (atoul($3, &ulval) == 0) {
				if (ulval > 255) {
					free($3);
					yyerror("illegal icmp-code %lu", ulval);
					YYERROR;
				}
			} else {
				if ((p = geticmpcodebyname($1-1, $3,
				    AF_INET)) == NULL) {
					yyerror("unknown icmp-code %s", $3);
					free($3);
					YYERROR;
				}
				ulval = p->code;
d3032 1
d3038 15
a3052 1
			$$->code = ulval + 1;
a3070 1
			u_long				 ulval;
d3072 4
a3075 15
			if (atoul($3, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp6-code %lu",
					    ulval);
					free($3);
					YYERROR;
				}
			} else {
				if ((p = geticmpcodebyname($1-1, $3,
				    AF_INET6)) == NULL) {
					yyerror("unknown icmp6-code %s", $3);
					free($3);
					YYERROR;
				}
				ulval = p->code;
d3078 15
d3097 1
a3097 1
			$$->code = ulval + 1;
a3105 1
			u_long				 ulval;
d3107 4
a3110 15
			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp-type %lu", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval + 1;
			} else {
				if ((p = geticmptypebyname($1, AF_INET)) ==
				    NULL) {
					yyerror("unknown icmp-type %s", $1);
					free($1);
					YYERROR;
				}
				$$ = p->type + 1;
d3112 1
d3115 7
a3125 1
			u_long				 ulval;
d3127 5
a3131 16
			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp6-type %lu",
					    ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval + 1;
			} else {
				if ((p = geticmptypebyname($1, AF_INET6)) ==
				    NULL) {
					yyerror("unknown icmp6-type %s", $1);
					free($1);
					YYERROR;
				}
				$$ = p->type + 1;
d3133 1
d3136 7
d3155 1
a3155 1
				$$ = strtoul($2, NULL, 10);
d3163 7
d3222 5
a3226 1
state_opt_item	: MAXIMUM number		{
d3243 5
a3247 1
		| MAXSRCSTATES number			{
d3256 5
a3260 1
		| MAXSRCCONN number			{
d3269 6
a3274 1
		| MAXSRCCONNRATE number '/' number	{
d3302 5
a3306 1
		| MAXSRCNODES number			{
d3333 1
a3333 1
		| STRING number			{
d3336 4
d3416 8
d3950 2
a3951 2
		| RTABLE number		{
			if ($2 > RT_TABLEID_MAX || $2 < 0) {
d4026 1
a4026 1
timeout_spec	: STRING number
d4032 4
d4049 1
a4049 1
limit_spec	: STRING number
d4055 4
d5307 37
@


1.519
log
@always initialize logif, from max laier, ok ryan
@
text
@d1247 4
d2501 33
@


1.518
log
@Allow "log" for nat rules without "pass".
OK henning@@, ``passt scho'' markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.517 2007/02/03 23:26:40 dhartmei Exp $	*/
d3442 2
a3443 2
natpasslog	: /* empty */	{ $$.b1 = $$.b2 = 0; }
		| PASS		{ $$.b1 = 1; $$.b2 = 0; }
@


1.517
log
@in decide_address_family(), only limit a rule to a specific address family
when ALL entries have this specific AF (when even just one entry has no
specific AF, use any). found by Maurice Janssen, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.516 2006/11/07 01:12:01 mcbride Exp $	*/
d428 1
a428 1
%type	<v.b>			action nataction natpass scrubaction
d3442 1
a3442 1
natpass		: /* empty */	{ $$.b1 = $$.b2 = 0; }
d3445 1
d3448 1
a3448 1
nataction	: no NAT natpass {
d3461 1
a3461 1
		| no RDR natpass {
d3635 1
a3635 1
binatrule	: no BINAT natpass interface af proto FROM host TO ipspec tag
@


1.516
log
@Unbreak authpf by handling non-inline anchors separately from the { } anchors
as pf_find_or_create_ruleset() will mangle relative anchor names and wildcards.
Also fixes some nits with nesting and printing inline anchors.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.515 2006/10/31 14:17:44 mcbride Exp $	*/
d5326 7
a5332 8
	sa_family_t	target_af = 0;

	while (!*af && n != NULL) {
		if (n->af) {
			if (target_af == 0)
				target_af = n->af;
			if (target_af != n->af)
				return;
a5333 1
		n = n->next;
a5334 2
	if (!*af && target_af)
		*af = target_af;
@


1.515
log
@Allow pfctl ruleset optimizer to be controlled from the ruleset.

"set" "ruleset-optimization" [ "none" | "basic" | "profile" ]

You can optionally control ruleset optimization with these keywords on the
command line with the -o option; the command line setting will override the
pf.conf setting. The existing -o/-oo flags continue to work as expected.

cleanup and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.514 2006/10/31 07:02:35 mcbride Exp $	*/
d662 1
a662 1
			char tmp_anchorname[PF_ANCHOR_NAME_SIZE];
d665 1
d669 4
a672 3
			snprintf(tmp_anchorname, PF_ANCHOR_NAME_SIZE,
			    "_%d", pf->bn);
			rs = pf_find_or_create_ruleset(tmp_anchorname);
d706 14
a719 12
				if ($2) {
					struct pf_ruleset *src =
						&pf->alast->ruleset;
					struct pf_ruleset *dst =
					    pf_find_or_create_ruleset($2);

					if (!dst)
						err(1, "anchorrule: unable to "
						    "create ruleset");
					if (dst->anchor->refcnt) {
						yyerror("inline anchor "
						    "already exists\n");
d722 2
a723 4

					mv_rules(src, dst);
					pf_remove_if_empty_ruleset(src);
					pf->alast = dst->anchor;
d725 2
a726 1
				r.anchor = pf->alast;
d730 1
a730 1
					    "rules must specify a name\n");
d4340 1
a4340 1
		snprintf(n, sizeof(n), "%u", pf->anchor->refcnt);
d4770 1
a4770 1
			r->nr = pf->anchor->refcnt++;
d5311 1
d5313 1
a5320 2
	dst->anchor->refcnt = src->anchor->refcnt;
	src->anchor->refcnt = 0;
@


1.514
log
@- don't allow anchors with _* names to be cleared or loaded from the
  command line (but they can still be viewed)
- don't allow users to specify _* as an anchor name in the ruleset
- don't print _* anchor names with pfctl -sA unless -v is specified

'looks sensible' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.513 2006/10/28 14:29:05 mcbride Exp $	*/
d417 1
a417 1
%token	LOAD
d426 1
a426 1
%type	<v.i>			no dir af fragcache
d499 14
d525 6
d4942 1
d5476 1
a5476 1
pfctl_load_anchors(int dev, int opts, struct pfr_buffer *trans)
d5482 1
a5482 1
		if (opts & PF_OPT_VERBOSE)
d5489 2
a5490 2
		if (pfctl_rules(dev, la->filename, fin, opts, la->anchorname,
		    trans) == -1)
@


1.513
log
@Load all rules into memory before loading into the kernel, and add support
for anchors loaded inline in pf.conf, enclosed in a brace-delimited
block ("{" "}").

anchor on fxp0 {
	pass in proto tcp port 22
}

The anchor name is optional on inline loaded anchors.

testing ckuethe@@
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.512 2006/10/25 14:50:30 henning Exp $	*/
d672 7
@


1.512
log
@make absolutely sure logif is 0 unless set specifically, even if log is 0.
logif is to be considered invalid unless log is set, but we need this to
please the optimizer...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.511 2006/10/25 11:53:46 henning Exp $	*/
d313 1
d447 1
a447 1
%type	<v.string>		label string tag
d483 1
d487 12
d564 1
a564 1
			if (!pf->anchor[0]) {
d626 41
a666 1
anchorrule	: ANCHOR string	dir quick interface af proto fromto filter_opts {
d670 2
a671 1
				free($2);
d676 28
d724 2
a725 1
			    0, 0, 0, $2);
d727 1
d832 2
a833 1
			if (strlen(pf->anchor) + 1 + strlen($3) >= MAXPATHLEN) {
d845 1
a845 1
			if (pf->anchor[0])
d847 1
a847 1
				    "%s/%s", pf->anchor, $3);
d1719 1
a1719 1
		
d3051 1
a3051 1
			$$.options = NULL; 
d4118 1
a4118 1
	    pf->anchor, &ab, pf->tticket)) {
d4310 1
a4310 1
		snprintf(n, sizeof(n), "%u", pf->rule_nr);
d4740 1
a4740 1
			r->nr = pf->rule_nr++;
d5270 23
a5467 1

@


1.511
log
@and another nit, $$.log should be set to 0 explicitely on quick without log
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.510 2006/10/25 11:45:48 henning Exp $	*/
d2114 5
a2118 5
logquick	: /* empty */			{ $$.log = 0; $$.quick = 0; }
		| log				{ $$ = $1; $$.quick = 0; }
		| QUICK				{ $$.quick = 1; $$.log = 0; }
		| log QUICK			{ $$ = $1; $$.quick = 1; }
		| QUICK log			{ $$ = $2; $$.quick = 1; }
@


1.510
log
@urgs, $$.quick needs to be set to 0 explicitely on log (without quick)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.509 2006/10/25 11:28:36 henning Exp $	*/
d2116 1
a2116 1
		| QUICK				{ $$.quick = 1; }
@


1.509
log
@allow the log interface to be selected like
pass log(to pflog5)
block out log(to pflog2)
input & ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.508 2006/10/17 07:14:28 mcbride Exp $	*/
d2115 1
a2115 1
		| log				{ $$ = $1; }
@


1.508
log
@Don't automatically set 'flags S/SA' on stateless rules.

pointed out by david@@

ok mpf@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.507 2006/10/11 21:04:18 deraadt Exp $	*/
d375 1
d425 1
a425 1
%type	<v.i>			no dir log logopts logopt af fragcache
d449 1
a449 1
%type	<v.logquick>		logquick quick
d796 1
d934 1
d1571 1
d2115 4
a2118 4
		| log				{ $$.log = $1; $$.quick = 0; }
		| QUICK				{ $$.log = 0; $$.quick = 1; }
		| log QUICK			{ $$.log = $1; $$.quick = 1; }
		| QUICK log			{ $$.log = $2; $$.quick = 1; }
d2121 5
a2125 2
log		: LOG				{ $$ = PF_LOG; }
		| LOG '(' logopts ')'		{ $$ = PF_LOG | $3; }
d2129 7
a2135 1
		| logopts comma logopt		{ $$ = $1 | $3; }
d2137 23
a2159 3
logopt		: ALL				{ $$ = PF_LOG_ALL; }
		| USER				{ $$ = PF_LOG_SOCKET_LOOKUP; }
		| GROUP				{ $$ = PF_LOG_SOCKET_LOOKUP; }
d3328 1
a3328 1
		| PASS log	{ $$.b1 = 1; $$.b2 = $2; }
d3342 1
d3355 1
d3372 1
d3542 1
@


1.507
log
@quotes around filename, pr 5253, sthen@@zephyr.spacehopper.org
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.506 2006/10/11 08:42:31 mcbride Exp $	*/
d1783 1
a1783 1
			/* 'flags S/SA' by default on pass rules. */
d1785 2
a1786 1
			    !$9.fragment && !($9.marker & FOM_FLAGS)) {
@


1.506
log
@Allow the 'quick' keyword on an anchor. IFF there is a matching rule inside
the anchor, terminate ruleset evaluation when stepping out of the anchor.

This means that if you absolutely want the anchor to be terminal, you
probably want to use a 'block all' or 'pass all' rule at the start of the
anchor.

ok dhartmei@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.505 2006/10/06 11:05:30 mcbride Exp $	*/
d544 1
a544 1
				printf("set fingerprints %s\n", $3);
@


1.505
log
@Oops, flags S/SA doesn't work on fragments.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.504 2006/10/06 10:45:44 mcbride Exp $	*/
d448 1
a448 1
%type	<v.logquick>		logquick
d611 1
a611 1
anchorrule	: ANCHOR string	dir interface af proto fromto filter_opts {
d621 4
a624 3
			r.af = $5;
			r.prob = $8.prob;
			r.rtableid = $8.rtableid;
d626 2
a627 2
			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
d633 1
a633 1
			r.match_tag_not = $8.match_tag_not;
d635 2
a636 2
			decide_address_family($7.src.host, &r.af);
			decide_address_family($7.dst.host, &r.af);
d638 2
a639 2
			expand_rule(&r, $4, NULL, $6, $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
d2103 4
@


1.504
log
@Make 'flags S/SA keep state' the implicit for filter rules, based on
a suggestion from dhartmei@@. Also add 'flags any' and 'no state' options
to disable flag matching and stateful filtering respectively.

IMPORTANT NOTE:
Current rulesets will continue to load, but the behaviour may be slightly
changed as these defaults are more restrictive. If you are purposefully
filtering statelessly ('no state') or have a requirement to create states
on intermediate packets ('flags any') you should update your ruleset to
make use of the new keywords to explicitly request the behaviour.

Note that creation of states from intermediate packets in a connection is
not recommended, and will increasingly cause problems as more OSs enable
window scaling and increase buffer sizes by default.

ok dhartmei@@ deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.503 2006/08/22 15:55:13 dhartmei Exp $	*/
d1784 1
a1784 1
			    !($9.marker & FOM_FLAGS)) {
@


1.503
log
@back out -r1.497 (support for "tagged {}" lists), it broke "tagged" support
for nat rules. sorry, existing functionality trumps syntactic sugar. feel
free to resubmit a complete patch. closes PR 5207.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.502 2006/07/06 13:26:41 henning Exp $	*/
d1623 6
d1781 7
d2734 1
d2924 5
a2928 1
keep		: KEEP STATE state_opt_spec	{
@


1.502
log
@add "rtable" to select alternate routing tables.
with & ok claudio hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.501 2006/06/17 11:38:41 henning Exp $	*/
a119 6
struct node_matchtag {
	char			 tagname[PF_TAG_NAME_SIZE];
	struct node_matchtag	*next;
	struct node_matchtag	*tail;
};

d200 1
a200 1
	struct node_matchtag	*match_tags;
d282 1
a282 1
	    struct node_matchtag *, const char *);
a392 1
		struct node_matchtag	*matchtag_opts;
a462 1
%type	<v.matchtag_opts>       matchtag matchtag_list matchtag_item
d625 7
d639 1
a639 1
			    0, 0, 0, $8.match_tags, $2);
d660 1
a660 1
			    0, 0, 0, 0, $2);
d702 1
a702 1
			    0, 0, 0, 0, $2);
d822 1
a822 1
			    NULL, NULL, NULL, NULL, "");
d974 1
a974 1
					    NULL, NULL, "");
d994 1
a994 2
						    NULL, NULL, NULL, NULL,
						    NULL, "");
d1579 7
d1887 1
a1887 1
			    $9.uid, $9.gid, $9.icmpspec, $9.match_tags, "");
d1977 2
a1978 2
		| not matchtag				{
			filter_opts.match_tags = $2;
a1979 4
			if ($1 && ($2 != $2->tail)) {
				yyerror("cannot negate tag list");
				YYERROR;
			}
a2011 32
matchtag	: TAGGED matchtag_item			{
			$$ = $2;
		}
		| TAGGED '{' matchtag_list '}'		{
			$$ = $3;
		}
		;

matchtag_list	: matchtag_item				{ $$ = $1; }
		| matchtag_list comma matchtag_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

matchtag_item	: STRING				{
			$$ = calloc(1, sizeof (struct node_matchtag));
			if ($$ == NULL)
				err(1, "matchtag_item: calloc");
			if ((strlcpy($$->tagname,$1,PF_TAG_NAME_SIZE)) >=
				 PF_TAG_NAME_SIZE) {
				yyerror("tag too long, max %u chars",
				    PF_TAG_NAME_SIZE - 1);
				YYERROR;
			}
			free($1);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

d3453 1
a3453 1
			    $5.dst.port, 0, 0, 0, 0, "");
d4441 1
a4441 1
    struct node_matchtag *match_tags, const char *anchor_call)
d4448 1
d4457 3
a4473 1
	LOOP_THROUGH(struct node_matchtag, match_tag, match_tags,
d4509 1
a4509 3
		if (!match_tag->tagname)
			errx(1, "expand_rule: no tagname");
		if (strlcpy(r->match_tagname, match_tag->tagname,
d4598 1
a4598 1
	)))))))))));
a4610 1
	FREE_LIST(struct node_matchtag, match_tags);
@


1.501
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.500 2006/05/28 03:05:53 mcbride Exp $	*/
d208 1
d213 1
d227 1
d338 1
d421 1
a421 1
%token	QUEUE PRIORITY QLIMIT
d472 1
d631 1
d643 1
a643 1
		| NATANCHOR string interface af proto fromto {
d654 1
d664 1
a664 1
		| RDRANCHOR string interface af proto fromto {
d675 1
d706 1
a706 1
		| BINATANCHOR string interface af proto fromto {
d717 1
d819 1
d828 3
a830 2
			bzero(&scrub_opts, sizeof scrub_opts);
		}
d835 1
d904 7
d936 1
d987 1
d1023 4
a1026 1
antispoof_opts	:	{ bzero(&antispoof_opts, sizeof antispoof_opts); }
d1031 1
d1047 7
d1571 1
d1886 4
a1889 1
filter_opts	:	{ bzero(&filter_opts, sizeof filter_opts); }
d1894 1
d2002 7
d3331 2
a3332 1
natrule		: nataction interface af proto fromto tag tagged redirpool pool_opts
d3371 1
d3374 1
a3374 1
				if ($8 != NULL) {
d3380 1
a3380 1
				if ($8 == NULL || $8->host == NULL) {
d3385 2
a3386 2
				if (!r.af && ! $8->host->ifindex)
					r.af = $8->host->af;
d3388 2
a3389 2
				remove_invalid_hosts(&$8->host, &r.af);
				if (invalid_redirect($8->host, r.af))
d3391 1
a3391 1
				if (check_netmask($8->host, r.af))
d3394 1
a3394 1
				r.rpool.proxy_port[0] = ntohs($8->rport.a);
d3398 1
a3398 1
					if (!$8->rport.b && $8->rport.t &&
d3401 1
a3401 1
						    ntohs($8->rport.a) +
d3408 1
a3408 1
						    ntohs($8->rport.b);
d3412 1
a3412 1
					    ntohs($8->rport.b);
d3427 1
a3427 1
				r.rpool.opts = $9.type;
d3429 3
a3431 3
				    PF_POOL_NONE && ($8->host->next != NULL ||
				    $8->host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($8->host->addr)))
d3435 1
a3435 1
				    disallow_table($8->host, "tables are only "
d3441 1
a3441 1
				    disallow_alias($8->host, "interface (%s) "
d3445 1
a3445 1
				if ($8->host->next != NULL) {
d3456 2
a3457 2
			if ($9.key != NULL)
				memcpy(&r.rpool.key, $9.key,
d3460 2
a3461 2
			 if ($9.opts)
				r.rpool.opts |= $9.opts;
d3463 1
a3463 1
			if ($9.staticport) {
d3482 1
a3482 1
			expand_rule(&r, $2, $8 == NULL ? NULL : $8->host, $4,
d3485 1
a3485 1
			free($8);
d3489 2
a3490 2
binatrule	: no BINAT natpass interface af proto FROM host TO ipspec tag tagged
		    redirection
d3519 2
a3520 2
			if (!binat.af && $13 != NULL && $13->host)
				binat.af = $13->host->af;
d3549 1
d3563 2
a3564 2
			if ($13 != NULL && $13->host != NULL && disallow_table(
			    $13->host, "invalid use of table <%s> as the "
d3567 2
a3568 2
			if ($13 != NULL && $13->host != NULL && disallow_alias(
			    $13->host, "invalid use of interface (%s) as the "
d3607 1
a3607 1
				if ($13 != NULL) {
d3613 1
a3613 1
				if ($13 == NULL || $13->host == NULL) {
d3619 2
a3620 2
				remove_invalid_hosts(&$13->host, &binat.af);
				if (invalid_redirect($13->host, binat.af))
d3622 1
a3622 1
				if ($13->host->next != NULL) {
d3627 1
a3627 1
				if (check_netmask($13->host, binat.af))
d3633 1
a3633 1
				    &$13->host->addr.v.a.mask, binat.af)) {
d3643 1
a3643 1
				pa->addr = $13->host->addr;
d3648 1
a3648 1
				free($13);
d3663 10
d4797 1
@


1.500
log
@Make per-rule adaptive timeouts behave the same way as the global adaptive
timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.499 2006/05/26 01:06:12 deraadt Exp $	*/
d466 1
a466 1
%type  <v.matchtag_opts>       matchtag matchtag_list matchtag_item
d497 1
a497 1
			free ($3);
d746 2
a747 1
			if ((loadanchor->anchorname = malloc(MAXPATHLEN)) == NULL)
d750 2
a751 2
				snprintf(loadanchor->anchorname, MAXPATHLEN, "%s/%s",
				    pf->anchor, $3);
d1681 2
a1682 2
						   "maximum rate must be < %u",
						   PF_THRESHOLD_MAX);
d1935 2
a1936 2
		| not matchtag 				{ 
			filter_opts.match_tags = $2; 
d1967 2
a1968 2
matchtag	: TAGGED matchtag_item		{ 
			$$ = $2; 
d1970 1
a1970 1
		| TAGGED '{' matchtag_list '}' 		{ 
d1976 1
a1976 1
		| matchtag_list comma matchtag_item 	{
d1983 1
a1983 1
matchtag_item	: STRING 				{
d2845 2
a2846 1
					yyerror("illegal icmp6-type %lu", ulval);
@


1.499
log
@\<char> is <char> except for \<newline> -- no exceptions.  much like how
other things work.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.498 2006/05/02 10:08:45 dhartmei Exp $	*/
d1510 1
d1718 5
d1735 6
@


1.498
log
@fix creation of sub-anchors, e.g. if you create an anchor /foo/bar, create
only bar under foo, not /bar as well.
secondly, when using "load anchor from" from a sub-anchor, the loading
point should be relative to the sub-anchor doing the load (unless absolute
paths are used, of course).
from Boris Polevoy. probably a -stable candidate.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.497 2006/05/01 12:24:32 dhartmei Exp $	*/
d4794 1
a4794 3
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
@


1.497
log
@add support for "tagged {}" lists, from Pierre-Yves Ritschard
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.496 2006/04/06 21:54:56 henning Exp $	*/
d737 1
a737 1
			if (strlen($3) >= MAXPATHLEN) {
d746 7
a752 2
			if ((loadanchor->anchorname = strdup($3)) == NULL)
				err(1, "loadrule: strdup");
@


1.496
log
@allow lists inside lists for address specs, has been in my tree for
quite some time... theo likes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.495 2006/03/14 11:09:43 djm Exp $	*/
d120 6
d206 1
a206 1
	char			*match_tag;
d285 1
a285 1
	    const char *);
d395 1
d466 1
a626 7
			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
d634 1
a634 1
			    0, 0, 0, $2);
d654 1
a654 1
			    0, 0, 0, $2);
d695 1
a695 1
			    0, 0, 0, $2);
d807 1
a807 1
			    NULL, NULL, NULL, "");
d949 1
a949 1
					    NULL, "");
d968 2
a969 1
						    NULL, NULL, NULL, NULL, "");
a1540 7
			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
d1831 1
a1831 1
			    $9.uid, $9.gid, $9.icmpspec, "");
d1917 2
a1918 2
		| not TAGGED string			{
			filter_opts.match_tag = $3;
d1920 4
d1949 32
d3419 1
a3419 1
			    $5.dst.port, 0, 0, 0, "");
d4396 1
a4396 1
    const char *anchor_call)
a4402 1
	char			 match_tagname[PF_TAG_NAME_SIZE];
a4410 3
	if (strlcpy(match_tagname, r->match_tagname, sizeof(match_tagname)) >=
	    sizeof(match_tagname))
		errx(1, "expand_rule: strlcpy");
d4425 1
d4461 3
a4463 1
		if (strlcpy(r->match_tagname, match_tagname,
d4552 1
a4552 1
	))))))))));
d4565 1
@


1.495
log
@implement a Unicast Reverse Path Forwarding (uRPF) check for pf(4)
which optionally verifies that a packet is received on the interface
that holds the route back to the packet's source address. This makes
it an automatic ingress filter, but only when routing is fully
symmetric.

bugfix feedback claudio@@; ok claudio@@ and dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.494 2005/11/17 20:52:39 dhartmei Exp $	*/
d2217 2
a2218 2
host_list	: xhost				{ $$ = $1; }
		| host_list comma xhost		{
@


1.494
log
@for pfctl -f rules, open the file before resetting options. when opening
the file fails, produce only the error message and leave options
unchanged. reported by Tamas TEVESZ, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.493 2005/10/13 13:27:06 henning Exp $	*/
d257 1
d403 1
a403 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP TABLE
d1100 4
d2191 3
d2238 1
a2238 1
		| NOROUTE			{
d2244 10
d3401 3
d3726 11
d3994 3
d4710 1
@


1.493
log
@unused parameters
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.492 2005/06/14 18:15:49 henning Exp $	*/
d5170 1
d5176 5
a5180 1
		if (pfctl_rules(dev, la->filename, opts, la->anchorname,
@


1.492
log
@no need to restrict tagging to stateful rules any more, dhartmei ok
From: "Alexey E. Suslikov" <cruel@@texnika.com.ua>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.491 2005/05/27 18:52:41 dhartmei Exp $	*/
d2072 1
a2072 1
			if ((n = ifa_exists($1, 1)) != NULL)
@


1.491
log
@get rid of 'log-all'. now that we have 'log (options)', make 'all' an
option to log. so, 'log-all' becomes 'log (all)'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.490 2005/05/27 18:41:29 dhartmei Exp $	*/
a3793 5
		problems++;
	}
	if ((r->tagname[0] || r->match_tagname[0]) && !r->keep_state &&
	    r->action == PF_PASS && !anchor_call) {
		yyerror("tags cannot be used without keep state");
@


1.490
log
@get rid of shift/reduce conflicts, don't support empty logopts
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.489 2005/05/27 17:22:40 dhartmei Exp $	*/
d398 1
a398 1
%token	PASS BLOCK SCRUB RETURN IN OS OUT LOG LOGALL QUICK ON FROM TO FLAGS
a2032 2
		| LOGALL			{ $$ = PF_LOG_ALL; }
		| LOGALL '(' logopts ')'	{ $$ = PF_LOG_ALL | $3; }
d2038 2
a2039 1
logopt		: USER				{ $$ = PF_LOG_SOCKET_LOOKUP; }
a4615 1
		{ "log-all",		LOGALL},
@


1.489
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.488 2005/05/27 03:54:27 dhartmei Exp $	*/
d2037 1
a2037 2
logopts		: /* empty */			{ $$ = 0; }
		| logopt			{ $$ = $1; }
@


1.488
log
@allow 'tagged' in 'anchor' rules (without complaining about missing
'keep state'), as a condition to branch into the anchor. suggested
by Bill Marquette.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.487 2005/05/26 20:20:38 camield Exp $	*/
d419 2
a420 2
%type	<v.i>			no dir log af fragcache sourcetrack flush
%type	<v.i>			unaryop statelock
d2032 3
a2034 1
		| LOGALL			{ $$ = PF_LOGALL; }
d2036 7
@


1.487
log
@The illegalness of "no nat log" is already enforced by the grammar.

ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.486 2005/05/26 15:29:48 dhartmei Exp $	*/
d258 2
a259 2
int	rule_consistent(struct pf_rule *);
int	filter_consistent(struct pf_rule *);
d3709 1
a3709 1
rule_consistent(struct pf_rule *r)
d3718 1
a3718 1
		problems = filter_consistent(r);
d3737 1
a3737 1
filter_consistent(struct pf_rule *r)
d3790 1
a3790 1
	    r->action == PF_PASS) {
d4477 1
a4477 1
		if (rule_consistent(r) < 0 || error)
@


1.486
log
@support 'log' and 'log-all' in 'nat/rdr/binat pass' rules. original patch
from camield@@. use #defines PF_LOG, PF_LOGALL instead of magic constants.
ok frantzen@@, camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.485 2005/05/23 21:29:50 camield Exp $	*/
d3187 2
a3188 2
			if ($1 && ($3.b1 || $3.b2)) {
				yyerror("\"pass\" and \"log\" not valid with \"no\"");
d3199 2
a3200 2
			if ($1 && ($3.b1 || $3.b2)) {
				yyerror("\"pass\" and \"log\" not valid with \"no\"");
d3379 2
a3380 2
			if ($1 && ($3.b1 || $3.b2)) {
				yyerror("\"pass\" and \"log\" not valid with \"no\"");
@


1.485
log
@remove code that duplicates getservice()

ok dhartmei mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.484 2005/05/21 21:03:58 henning Exp $	*/
d418 1
a418 1
%type	<v.number>		tos not yesno natpass
d421 1
a421 1
%type	<v.b>			action nataction scrubaction
d2031 2
a2032 2
log		: LOG				{ $$ = 1; }
		| LOGALL			{ $$ = 2; }
d3181 3
a3183 2
natpass		: /* empty */	{ $$ = 0; }
		| PASS		{ $$ = 1; }
d3187 4
a3190 1
			$$.b2 = $$.w = 0;
d3195 2
a3196 1
			$$.b2 = $3;
d3199 4
a3202 1
			$$.b2 = $$.w = 0;
d3207 2
a3208 1
			$$.b2 = $3;
d3223 1
d3379 4
d3387 2
a3388 1
			binat.natpass = $3;
@


1.484
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.483 2005/04/22 11:05:36 camield Exp $	*/
a2430 2
			struct servent	*s = NULL;
			u_long		 ulval;
d2433 3
a2435 18
				if (atoul($1, &ulval) == 0) {
					if (ulval > 65535) {
						free($1);
						yyerror("illegal port value %lu",
						    ulval);
						YYERROR;
					}
					$$.a = htons(ulval);
				} else {
					s = getservbyname($1, "tcp");
					if (s == NULL)
						s = getservbyname($1, "udp");
					if (s == NULL) {
						yyerror("unknown port %s", $1);
						free($1);
						YYERROR;
					}
					$$.a = s->s_port;
d2437 1
a2437 2
				$$.b = 0;
				$$.t = 0;
@


1.483
log
@Catch bad flags, ie. flags that always evaluate to false.  This happens
if there are flags on the lefthandside that are masked off by the
righthand side.

ok mcbride@@ (long time ago) dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.482 2005/03/07 13:20:03 henning Exp $	*/
d413 1
a413 1
%token	TAGGED TAG IFBOUND GRBOUND FLOATING STATEPOLICY ROUTE
a562 4
				case PFRULE_GRBOUND:
					printf("set state-policy "
					    "group-bound\n");
					break;
a2834 3
		| GRBOUND {
			$$ = PFRULE_GRBOUND;
		}
a4597 1
		{ "group-bound",	GRBOUND},
@


1.482
log
@print unsigned long with %lu, not with %d and not with %ld.
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.481 2005/03/06 19:11:36 henning Exp $	*/
d1546 3
d1551 2
a1552 1
			if (rule_label(&r, $9.label))
d1554 1
a1554 1
			free($9.label);
@


1.481
log
@allow commas in the hfsc service curve spec, inconsistency pointed out in
PR4134 / geoff@@collyer.net and a longer mail exhcange with han boetes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.480 2005/03/06 02:40:08 dhartmei Exp $	*/
d2438 1
a2438 1
						yyerror("illegal port value %d",
d2693 1
a2693 1
					yyerror("illegal icmp-code %d", ulval);
d2733 1
a2733 1
					yyerror("illegal icmp6-code %ld",
d2765 1
a2765 1
					yyerror("illegal icmp-type %d", ulval);
d2789 1
a2789 1
					yyerror("illegal icmp6-type %d", ulval);
d5116 1
a5116 1
			yyerror("illegal port value %d", ulval);
d5166 1
a5166 1
		yyerror("invalid icmp code %ld", ulval);
@


1.480
log
@print "set skip on" with -v in such a way that the output is valid input
syntax, instead of the cryptic hex flags output.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.479 2005/02/27 15:08:39 dhartmei Exp $	*/
d1396 2
a1397 1
		| LINKSHARE '(' bandwidth number bandwidth ')'	{
d1403 2
a1404 2
			hfsc_opts.linkshare.d = $4;
			hfsc_opts.linkshare.m2 = $5;
d1415 2
a1416 1
		| REALTIME '(' bandwidth number bandwidth ')'	{
d1422 2
a1423 2
			hfsc_opts.realtime.d = $4;
			hfsc_opts.realtime.m2 = $5;
d1434 2
a1435 1
		| UPPERLIMIT '(' bandwidth number bandwidth ')'	{
d1441 2
a1442 2
			hfsc_opts.upperlimit.d = $4;
			hfsc_opts.upperlimit.m2 = $5;
@


1.479
log
@support 'tagged' in translation rules, non-delayed tag lookup
ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.478 2005/02/26 15:14:58 henning Exp $	*/
d4513 2
d4519 2
d4522 2
d4531 2
@


1.478
log
@ypu sure get the impression the number of memory leaks in error pathes
is infinite... Andrey Matveev <andrushock@@korovino.net> spotted a few again!
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.477 2005/02/07 18:18:14 david Exp $	*/
d372 4
d458 1
d3221 1
a3221 1
natrule		: nataction interface af proto fromto tag redirpool pool_opts
d3251 9
d3261 1
a3261 1
				if ($7 != NULL) {
d3267 1
a3267 1
				if ($7 == NULL || $7->host == NULL) {
d3272 2
a3273 2
				if (!r.af && ! $7->host->ifindex)
					r.af = $7->host->af;
d3275 2
a3276 2
				remove_invalid_hosts(&$7->host, &r.af);
				if (invalid_redirect($7->host, r.af))
d3278 1
a3278 1
				if (check_netmask($7->host, r.af))
d3281 1
a3281 1
				r.rpool.proxy_port[0] = ntohs($7->rport.a);
d3285 1
a3285 1
					if (!$7->rport.b && $7->rport.t &&
d3288 1
a3288 1
						    ntohs($7->rport.a) +
d3295 1
a3295 1
						    ntohs($7->rport.b);
d3299 1
a3299 1
					    ntohs($7->rport.b);
d3314 1
a3314 1
				r.rpool.opts = $8.type;
d3316 3
a3318 3
				    PF_POOL_NONE && ($7->host->next != NULL ||
				    $7->host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($7->host->addr)))
d3322 1
a3322 1
				    disallow_table($7->host, "tables are only "
d3328 1
a3328 1
				    disallow_alias($7->host, "interface (%s) "
d3332 1
a3332 1
				if ($7->host->next != NULL) {
d3343 2
a3344 2
			if ($8.key != NULL)
				memcpy(&r.rpool.key, $8.key,
d3347 2
a3348 2
			 if ($8.opts)
				r.rpool.opts |= $8.opts;
d3350 1
a3350 1
			if ($8.staticport) {
d3369 1
a3369 1
			expand_rule(&r, $2, $7 == NULL ? NULL : $7->host, $4,
d3372 1
a3372 1
			free($7);
d3376 1
a3376 1
binatrule	: no BINAT natpass interface af proto FROM host TO ipspec tag
d3397 3
a3399 2
			if (!binat.af && $12 != NULL && $12->host)
				binat.af = $12->host->af;
d3412 1
d3420 8
d3441 2
a3442 2
			if ($12 != NULL && $12->host != NULL && disallow_table(
			    $12->host, "invalid use of table <%s> as the "
d3445 2
a3446 2
			if ($12 != NULL && $12->host != NULL && disallow_alias(
			    $12->host, "invalid use of interface (%s) as the "
d3485 1
a3485 1
				if ($12 != NULL) {
d3491 1
a3491 1
				if ($12 == NULL || $12->host == NULL) {
d3497 2
a3498 2
				remove_invalid_hosts(&$12->host, &binat.af);
				if (invalid_redirect($12->host, binat.af))
d3500 1
a3500 1
				if ($12->host->next != NULL) {
d3505 1
a3505 1
				if (check_netmask($12->host, binat.af))
d3511 1
a3511 1
				    &$12->host->addr.v.a.mask, binat.af)) {
d3521 1
a3521 1
				pa->addr = $12->host->addr;
d3526 1
a3526 1
				free($12);
d3535 4
@


1.477
log
@KNF; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.476 2005/01/28 17:29:31 dhartmei Exp $	*/
d927 1
d1923 1
d1929 1
@


1.476
log
@add messages for syntax errors that caused silent failure before.
found by Peter Fraser, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.475 2005/01/27 15:30:35 dhartmei Exp $	*/
a136 1
	
d1740 1
a1740 1
					r.timeout[PFTM_SRC_NODE] = 
@


1.475
log
@dynamic interface names must start with a letter. catches the nonsensical
"(10.1.2.3)" that results from a simple typo like "$(ext_ip)" instead of
"$(ext_if)".
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.474 2005/01/05 18:23:10 mcbride Exp $	*/
d865 2
d1072 1
d3625 2
@


1.474
log
@Modify pfctl behaviour so that 'set ...' options are no longer "sticky", ie.
they are reset to default values if omitted from a subsequent ruleset load.
Also:
- make sure 'set ...' options are not loaded in anchors.
- add a -m ("merge") flag to pfctl which allows an individual option to be set
  without reseting the others, eg:
   # echo "set loginterface fxp0" | pfctl -mf -

ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.473 2004/12/29 16:27:05 mcbride Exp $	*/
d2310 5
@


1.473
log
@Print 'set fingerprints' correctly when parsing verbosely.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.472 2004/12/23 17:21:48 dhartmei Exp $	*/
d539 8
a546 4
			if (pfctl_file_fingerprints(pf->dev, pf->opts, $3)) {
				yyerror("error loading fingerprints %s", $3);
				free($3);
				YYERROR;
@


1.472
log
@set rule_flag PFRULE_SRCTRACK when setting srctrack, found by camield@@
using regress test pf84
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.471 2004/12/22 17:17:55 dhartmei Exp $	*/
d534 1
a534 1
				printf("fingerprints %s\n", $3);
@


1.471
log
@Introduce 'set skip on <ifspec>' to support a list of interfaces where no
packet filtering should occur (like loopback, for instance).
Code from Max Laier, with minor improvements based on feedback from
deraadt@@. ok mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.470 2004/12/15 16:11:14 henning Exp $	*/
d1592 1
@


1.470
log
@missing free()s; with pat
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.469 2004/12/10 22:13:26 henning Exp $	*/
d284 1
d402 1
a402 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG HOSTID
d574 6
d4461 28
d4608 1
@


1.469
log
@allow pf to filter on route labels
pass in from route dtag keep state queue reallyslow
tested by Gabriel Kihlman <gk@@stacken.kth.se> and
Michael Knudsen <e@@molioner.dk> and ryan
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.468 2004/12/08 01:27:23 mcbride Exp $	*/
d2260 2
a2261 1
			if ($$ == NULL)
d2263 1
d2270 2
d2276 1
@


1.468
log
@Add "'overload' requires 'max-src-conn' or 'max-src-conn-rate'" sanity check,
fix some cut-n-paste mayhem in other related checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.467 2004/12/07 10:33:41 dhartmei Exp $	*/
d409 1
a409 1
%token	TAGGED TAG IFBOUND GRBOUND FLOATING STATEPOLICY
d2258 15
d4563 1
@


1.467
log
@re-commit mcbride@@'s 'flush global', this time without the breakage in
pfvar.h. builds kernel and userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.466 2004/12/07 09:39:30 deraadt Exp $	*/
d1711 1
a1711 1
				    r.max_src_nodes) {
d1718 1
a1718 1
				    r.max_src_nodes) {
d3684 6
@


1.466
log
@real backout
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.462 2004/12/05 10:11:29 dhartmei Exp $	*/
d1616 1
a1616 3
					if (o->data.overload.flush)
						r.rule_flag |=
						    PFRULE_SRCTRACK_FLUSH;
d2808 4
a2811 1
		| FLUSH				{ $$ = 1; }
@


1.465
log
@oops, incomplete backout
@
text
@@


1.464
log
@tree does not compile, spotted by dlg (not obvious how to fix)
----
Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.208 2004/12/04 07:58:52 mcbride Exp $ */
d4 4
a7 3
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002,2003 Henning Brauer
 * All rights reserved.
d12 5
d18 10
a27 20
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
d29 1
a29 1

a30 1
#include <sys/ioctl.h>
a31 2
#include <sys/param.h>
#include <sys/proc.h>
d40 4
a46 2
#include <string.h>
#include <ctype.h>
d50 3
d54 4
a57 1
#include <ifaddrs.h>
d62 48
a109 41
void		 print_op (u_int8_t, const char *, const char *);
void		 print_port (u_int8_t, u_int16_t, u_int16_t, const char *);
void		 print_ugid (u_int8_t, unsigned, unsigned, const char *, unsigned);
void		 print_flags (u_int8_t);
void		 print_fromto(struct pf_rule_addr *, pf_osfp_t,
		    struct pf_rule_addr *, u_int8_t, u_int8_t, int);
int		 ifa_skip_if(const char *filter, struct node_host *p);

struct node_host	*host_if(const char *, int);
struct node_host	*host_v4(const char *, int);
struct node_host	*host_v6(const char *, int);
struct node_host	*host_dns(const char *, int, int);

const char *tcpflags = "FSRPAUEW";

static const struct icmptypeent icmp_type[] = {
	{ "echoreq",	ICMP_ECHO },
	{ "echorep",	ICMP_ECHOREPLY },
	{ "unreach",	ICMP_UNREACH },
	{ "squench",	ICMP_SOURCEQUENCH },
	{ "redir",	ICMP_REDIRECT },
	{ "althost",	ICMP_ALTHOSTADDR },
	{ "routeradv",	ICMP_ROUTERADVERT },
	{ "routersol",	ICMP_ROUTERSOLICIT },
	{ "timex",	ICMP_TIMXCEED },
	{ "paramprob",	ICMP_PARAMPROB },
	{ "timereq",	ICMP_TSTAMP },
	{ "timerep",	ICMP_TSTAMPREPLY },
	{ "inforeq",	ICMP_IREQ },
	{ "inforep",	ICMP_IREQREPLY },
	{ "maskreq",	ICMP_MASKREQ },
	{ "maskrep",	ICMP_MASKREPLY },
	{ "trace",	ICMP_TRACEROUTE },
	{ "dataconv",	ICMP_DATACONVERR },
	{ "mobredir",	ICMP_MOBILE_REDIRECT },
	{ "ipv6-where",	ICMP_IPV6_WHEREAREYOU },
	{ "ipv6-here",	ICMP_IPV6_IAMHERE },
	{ "mobregreq",	ICMP_MOBILE_REGREQUEST },
	{ "mobregrep",	ICMP_MOBILE_REGREPLY },
	{ "skip",	ICMP_SKIP },
	{ "photuris",	ICMP_PHOTURIS }
d112 6
a117 27
static const struct icmptypeent icmp6_type[] = {
	{ "unreach",	ICMP6_DST_UNREACH },
	{ "toobig",	ICMP6_PACKET_TOO_BIG },
	{ "timex",	ICMP6_TIME_EXCEEDED },
	{ "paramprob",	ICMP6_PARAM_PROB },
	{ "echoreq",	ICMP6_ECHO_REQUEST },
	{ "echorep",	ICMP6_ECHO_REPLY },
	{ "groupqry",	ICMP6_MEMBERSHIP_QUERY },
	{ "listqry",	MLD_LISTENER_QUERY },
	{ "grouprep",	ICMP6_MEMBERSHIP_REPORT },
	{ "listenrep",	MLD_LISTENER_REPORT },
	{ "groupterm",	ICMP6_MEMBERSHIP_REDUCTION },
	{ "listendone", MLD_LISTENER_DONE },
	{ "routersol",	ND_ROUTER_SOLICIT },
	{ "routeradv",	ND_ROUTER_ADVERT },
	{ "neighbrsol", ND_NEIGHBOR_SOLICIT },
	{ "neighbradv", ND_NEIGHBOR_ADVERT },
	{ "redir",	ND_REDIRECT },
	{ "routrrenum", ICMP6_ROUTER_RENUMBERING },
	{ "wrureq",	ICMP6_WRUREQUEST },
	{ "wrurep",	ICMP6_WRUREPLY },
	{ "fqdnreq",	ICMP6_FQDN_QUERY },
	{ "fqdnrep",	ICMP6_FQDN_REPLY },
	{ "niqry",	ICMP6_NI_QUERY },
	{ "nirep",	ICMP6_NI_REPLY },
	{ "mtraceresp",	MLD_MTRACE_RESP },
	{ "mtrace",	MLD_MTRACE }
d120 33
a152 31
static const struct icmpcodeent icmp_code[] = {
	{ "net-unr",		ICMP_UNREACH,	ICMP_UNREACH_NET },
	{ "host-unr",		ICMP_UNREACH,	ICMP_UNREACH_HOST },
	{ "proto-unr",		ICMP_UNREACH,	ICMP_UNREACH_PROTOCOL },
	{ "port-unr",		ICMP_UNREACH,	ICMP_UNREACH_PORT },
	{ "needfrag",		ICMP_UNREACH,	ICMP_UNREACH_NEEDFRAG },
	{ "srcfail",		ICMP_UNREACH,	ICMP_UNREACH_SRCFAIL },
	{ "net-unk",		ICMP_UNREACH,	ICMP_UNREACH_NET_UNKNOWN },
	{ "host-unk",		ICMP_UNREACH,	ICMP_UNREACH_HOST_UNKNOWN },
	{ "isolate",		ICMP_UNREACH,	ICMP_UNREACH_ISOLATED },
	{ "net-prohib",		ICMP_UNREACH,	ICMP_UNREACH_NET_PROHIB },
	{ "host-prohib",	ICMP_UNREACH,	ICMP_UNREACH_HOST_PROHIB },
	{ "net-tos",		ICMP_UNREACH,	ICMP_UNREACH_TOSNET },
	{ "host-tos",		ICMP_UNREACH,	ICMP_UNREACH_TOSHOST },
	{ "filter-prohib",	ICMP_UNREACH,	ICMP_UNREACH_FILTER_PROHIB },
	{ "host-preced",	ICMP_UNREACH,	ICMP_UNREACH_HOST_PRECEDENCE },
	{ "cutoff-preced",	ICMP_UNREACH,	ICMP_UNREACH_PRECEDENCE_CUTOFF },
	{ "redir-net",		ICMP_REDIRECT,	ICMP_REDIRECT_NET },
	{ "redir-host",		ICMP_REDIRECT,	ICMP_REDIRECT_HOST },
	{ "redir-tos-net",	ICMP_REDIRECT,	ICMP_REDIRECT_TOSNET },
	{ "redir-tos-host",	ICMP_REDIRECT,	ICMP_REDIRECT_TOSHOST },
	{ "normal-adv",		ICMP_ROUTERADVERT, ICMP_ROUTERADVERT_NORMAL },
	{ "common-adv",		ICMP_ROUTERADVERT, ICMP_ROUTERADVERT_NOROUTE_COMMON },
	{ "transit",		ICMP_TIMXCEED,	ICMP_TIMXCEED_INTRANS },
	{ "reassemb",		ICMP_TIMXCEED,	ICMP_TIMXCEED_REASS },
	{ "badhead",		ICMP_PARAMPROB,	ICMP_PARAMPROB_ERRATPTR },
	{ "optmiss",		ICMP_PARAMPROB,	ICMP_PARAMPROB_OPTABSENT },
	{ "badlen",		ICMP_PARAMPROB,	ICMP_PARAMPROB_LENGTH },
	{ "unknown-ind",	ICMP_PHOTURIS,	ICMP_PHOTURIS_UNKNOWN_INDEX },
	{ "auth-fail",		ICMP_PHOTURIS,	ICMP_PHOTURIS_AUTH_FAILED },
	{ "decrypt-fail",	ICMP_PHOTURIS,	ICMP_PHOTURIS_DECRYPT_FAILED }
d155 3
a157 13
static const struct icmpcodeent icmp6_code[] = {
	{ "admin-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADMIN },
	{ "noroute-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOROUTE },
	{ "notnbr-unr",	ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOTNEIGHBOR },
	{ "beyond-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_BEYONDSCOPE },
	{ "addr-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADDR },
	{ "port-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT },
	{ "transit", ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_TRANSIT },
	{ "reassemb", ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_REASSEMBLY },
	{ "badhead", ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER },
	{ "nxthdr", ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER },
	{ "redironlink", ND_REDIRECT, ND_REDIRECT_ONLINK },
	{ "redirrouter", ND_REDIRECT, ND_REDIRECT_ROUTER }
d160 12
a171 22
const struct pf_timeout pf_timeouts[] = {
	{ "tcp.first",		PFTM_TCP_FIRST_PACKET },
	{ "tcp.opening",	PFTM_TCP_OPENING },
	{ "tcp.established",	PFTM_TCP_ESTABLISHED },
	{ "tcp.closing",	PFTM_TCP_CLOSING },
	{ "tcp.finwait",	PFTM_TCP_FIN_WAIT },
	{ "tcp.closed",		PFTM_TCP_CLOSED },
	{ "tcp.tsdiff",		PFTM_TS_DIFF },
	{ "udp.first",		PFTM_UDP_FIRST_PACKET },
	{ "udp.single",		PFTM_UDP_SINGLE },
	{ "udp.multiple",	PFTM_UDP_MULTIPLE },
	{ "icmp.first",		PFTM_ICMP_FIRST_PACKET },
	{ "icmp.error",		PFTM_ICMP_ERROR_REPLY },
	{ "other.first",	PFTM_OTHER_FIRST_PACKET },
	{ "other.single",	PFTM_OTHER_SINGLE },
	{ "other.multiple",	PFTM_OTHER_MULTIPLE },
	{ "frag",		PFTM_FRAG },
	{ "interval",		PFTM_INTERVAL },
	{ "adaptive.start",	PFTM_ADAPTIVE_START },
	{ "adaptive.end",	PFTM_ADAPTIVE_END },
	{ "src.track",		PFTM_SRC_NODE },
	{ NULL,			0 }
d174 3444
a3617 2
const struct icmptypeent *
geticmptypebynumber(u_int8_t type, sa_family_t af)
d3619 7
a3625 1
	unsigned int	i;
d3627 7
a3633 5
	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0]));
		    i++) {
			if (type == icmp_type[i].type)
				return (&icmp_type[i]);
d3635 109
a3743 5
	} else {
		for (i=0; i < (sizeof (icmp6_type) /
		    sizeof(icmp6_type[0])); i++) {
			if (type == icmp6_type[i].type)
				 return (&icmp6_type[i]);
d3746 119
a3864 1
	return (NULL);
d3867 3
a3869 2
const struct icmptypeent *
geticmptypebyname(char *w, sa_family_t af)
d3871 1
a3871 1
	unsigned int	i;
d3873 37
a3909 5
	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0]));
		    i++) {
			if (!strcmp(w, icmp_type[i].name))
				return (&icmp_type[i]);
d3911 53
a3963 5
	} else {
		for (i=0; i < (sizeof (icmp6_type) /
		    sizeof(icmp6_type[0])); i++) {
			if (!strcmp(w, icmp6_type[i].name))
				return (&icmp6_type[i]);
a3965 1
	return (NULL);
d3968 285
a4252 2
const struct icmpcodeent *
geticmpcodebynumber(u_int8_t type, u_int8_t code, sa_family_t af)
d4254 107
a4360 1
	unsigned int	i;
d4362 6
a4367 6
	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0]));
		    i++) {
			if (type == icmp_code[i].type &&
			    code == icmp_code[i].code)
				return (&icmp_code[i]);
d4369 3
a4371 6
	} else {
		for (i=0; i < (sizeof (icmp6_code) /
		    sizeof(icmp6_code[0])); i++) {
			if (type == icmp6_code[i].type &&
			    code == icmp6_code[i].code)
				return (&icmp6_code[i]);
a4372 3
	}
	return (NULL);
}
d4374 10
a4383 4
const struct icmpcodeent *
geticmpcodebyname(u_long type, char *w, sa_family_t af)
{
	unsigned int	i;
d4385 14
a4398 6
	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0]));
		    i++) {
			if (type == icmp_code[i].type &&
			    !strcmp(w, icmp_code[i].name))
				return (&icmp_code[i]);
d4400 25
a4424 9
	} else {
		for (i=0; i < (sizeof (icmp6_code) /
		    sizeof(icmp6_code[0])); i++) {
			if (type == icmp6_code[i].type &&
			    !strcmp(w, icmp6_code[i].name))
				return (&icmp6_code[i]);
		}
	}
	return (NULL);
d4427 5
a4431 2
void
print_op(u_int8_t op, const char *a1, const char *a2)
d4433 7
a4439 18
	if (op == PF_OP_IRG)
		printf(" %s >< %s", a1, a2);
	else if (op == PF_OP_XRG)
		printf(" %s <> %s", a1, a2);
	else if (op == PF_OP_EQ)
		printf(" = %s", a1);
	else if (op == PF_OP_NE)
		printf(" != %s", a1);
	else if (op == PF_OP_LT)
		printf(" < %s", a1);
	else if (op == PF_OP_LE)
		printf(" <= %s", a1);
	else if (op == PF_OP_GT)
		printf(" > %s", a1);
	else if (op == PF_OP_GE)
		printf(" >= %s", a1);
	else if (op == PF_OP_RRG)
		printf(" %s:%s", a1, a2);
d4442 2
a4443 2
void
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, const char *proto)
d4445 1
a4445 13
	char		 a1[6], a2[6];
	struct servent	*s;

	s = getservbyport(p1, proto);
	p1 = ntohs(p1);
	p2 = ntohs(p2);
	snprintf(a1, sizeof(a1), "%u", p1);
	snprintf(a2, sizeof(a2), "%u", p2);
	printf(" port");
	if (s != NULL && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, s->s_name, a2);
	else
		print_op(op, a1, a2);
d4448 2
a4449 2
void
print_ugid(u_int8_t op, unsigned u1, unsigned u2, const char *t, unsigned umax)
d4451 126
a4576 9
	char	a1[11], a2[11];

	snprintf(a1, sizeof(a1), "%u", u1);
	snprintf(a2, sizeof(a2), "%u", u2);
	printf(" %s", t);
	if (u1 == umax && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, "unknown", a2);
	else
		print_op(op, a1, a2);
d4579 1
a4579 4
void
print_flags(u_int8_t f)
{
	int	i;
d4581 4
a4584 4
	for (i = 0; tcpflags[i]; ++i)
		if (f & (1 << i))
			printf("%c", tcpflags[i]);
}
d4586 2
a4587 3
void
print_fromto(struct pf_rule_addr *src, pf_osfp_t osfp, struct pf_rule_addr *dst,
    sa_family_t af, u_int8_t proto, int verbose)
d4589 11
a4599 32
	char buf[PF_OSFP_LEN*3];
	if (src->addr.type == PF_ADDR_ADDRMASK &&
	    dst->addr.type == PF_ADDR_ADDRMASK &&
	    PF_AZERO(&src->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&src->addr.v.a.mask, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.mask, AF_INET6) &&
	    !src->neg && !dst->neg &&
	    !src->port_op && !dst->port_op &&
	    osfp == PF_OSFP_ANY)
		printf(" all");
	else {
		printf(" from ");
		if (src->neg)
			printf("! ");
		print_addr(&src->addr, af, verbose);
		if (src->port_op)
			print_port(src->port_op, src->port[0],
			    src->port[1],
			    proto == IPPROTO_TCP ? "tcp" : "udp");
		if (osfp != PF_OSFP_ANY)
			printf(" os \"%s\"", pfctl_lookup_fingerprint(osfp, buf,
			    sizeof(buf)));

		printf(" to ");
		if (dst->neg)
			printf("! ");
		print_addr(&dst->addr, af, verbose);
		if (dst->port_op)
			print_port(dst->port_op, dst->port[0],
			    dst->port[1],
			    proto == IPPROTO_TCP ? "tcp" : "udp");
a4600 1
}
d4602 2
a4603 5
void
print_pool(struct pf_pool *pool, u_int16_t p1, u_int16_t p2,
    sa_family_t af, int id)
{
	struct pf_pooladdr	*pooladdr;
d4605 6
a4610 20
	if ((TAILQ_FIRST(&pool->list) != NULL) &&
	    TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
		printf("{ ");
	TAILQ_FOREACH(pooladdr, &pool->list, entries){
		switch (id) {
		case PF_NAT:
		case PF_RDR:
		case PF_BINAT:
			print_addr(&pooladdr->addr, af, 0);
			break;
		case PF_PASS:
			if (PF_AZERO(&pooladdr->addr.v.a.addr, af))
				printf("%s", pooladdr->ifname);
			else {
				printf("(%s ", pooladdr->ifname);
				print_addr(&pooladdr->addr, af, 0);
				printf(")");
			}
			break;
		default:
d4613 2
a4614 4
		if (TAILQ_NEXT(pooladdr, entries) != NULL)
			printf(", ");
		else if (TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
			printf(" }");
d4616 7
a4622 19
	switch (id) {
	case PF_NAT:
		if ((p1 != PF_NAT_PROXY_PORT_LOW ||
		    p2 != PF_NAT_PROXY_PORT_HIGH) && (p1 != 0 || p2 != 0)) {
			if (p1 == p2)
				printf(" port %u", p1);
			else
				printf(" port %u:%u", p1, p2);
		}
		break;
	case PF_RDR:
		if (p1) {
			printf(" port %u", p1);
			if (p2 && (p2 != p1))
				printf(":%u", p2);
		}
		break;
	default:
		break;
d4624 2
a4625 22
	switch (pool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		break;
	case PF_POOL_BITMASK:
		printf(" bitmask");
		break;
	case PF_POOL_RANDOM:
		printf(" random");
		break;
	case PF_POOL_SRCHASH:
		printf(" source-hash 0x%08x%08x%08x%08x",
		    pool->key.key32[0], pool->key.key32[1],
		    pool->key.key32[2], pool->key.key32[3]);
		break;
	case PF_POOL_ROUNDROBIN:
		printf(" round-robin");
		break;
	}
	if (pool->opts & PF_POOL_STICKYADDR)
		printf(" sticky-address");
	if (id == PF_NAT && p1 == 0 && p2 == 0)
		printf(" static-port");
d4628 2
a4629 7
const char	*pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
const char	*pf_lcounters[LCNT_MAX+1] = LCNT_NAMES;
const char	*pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
const char	*pf_scounters[FCNT_MAX+1] = FCNT_NAMES;

void
print_status(struct pf_status *s, int opts)
d4631 6
a4636 107
	char	statline[80], *running;
	time_t	runtime;
	int	i;

	runtime = time(NULL) - s->since;
	running = s->running ? "Enabled" : "Disabled";

	if (s->since) {
		unsigned	sec, min, hrs, day = runtime;

		sec = day % 60;
		day /= 60;
		min = day % 60;
		day /= 60;
		hrs = day % 24;
		day /= 24;
		snprintf(statline, sizeof(statline),
		    "Status: %s for %u days %.2u:%.2u:%.2u",
		    running, day, hrs, min, sec);
	} else
		snprintf(statline, sizeof(statline), "Status: %s", running);
	printf("%-44s", statline);
	switch (s->debug) {
	case PF_DEBUG_NONE:
		printf("%15s\n\n", "Debug: None");
		break;
	case PF_DEBUG_URGENT:
		printf("%15s\n\n", "Debug: Urgent");
		break;
	case PF_DEBUG_MISC:
		printf("%15s\n\n", "Debug: Misc");
		break;
	case PF_DEBUG_NOISY:
		printf("%15s\n\n", "Debug: Loud");
		break;
	}
	printf("Hostid: 0x%08x\n\n", ntohl(s->hostid));
	if (s->ifname[0] != 0) {
		printf("Interface Stats for %-16s %5s %16s\n",
		    s->ifname, "IPv4", "IPv6");
		printf("  %-25s %14llu %16llu\n", "Bytes In",
		    (unsigned long long)s->bcounters[0][0],
		    (unsigned long long)s->bcounters[1][0]);
		printf("  %-25s %14llu %16llu\n", "Bytes Out",
		    (unsigned long long)s->bcounters[0][1],
		    (unsigned long long)s->bcounters[1][1]);
		printf("  Packets In\n");
		printf("    %-23s %14llu %16llu\n", "Passed",
		    (unsigned long long)s->pcounters[0][0][PF_PASS],
		    (unsigned long long)s->pcounters[1][0][PF_PASS]);
		printf("    %-23s %14llu %16llu\n", "Blocked",
		    (unsigned long long)s->pcounters[0][0][PF_DROP],
		    (unsigned long long)s->pcounters[1][0][PF_DROP]);
		printf("  Packets Out\n");
		printf("    %-23s %14llu %16llu\n", "Passed",
		    (unsigned long long)s->pcounters[0][1][PF_PASS],
		    (unsigned long long)s->pcounters[1][1][PF_PASS]);
		printf("    %-23s %14llu %16llu\n\n", "Blocked",
		    (unsigned long long)s->pcounters[0][1][PF_DROP],
		    (unsigned long long)s->pcounters[1][1][PF_DROP]);
	}
	printf("%-27s %14s %16s\n", "State Table", "Total", "Rate");
	printf("  %-25s %14u %14s\n", "current entries", s->states, "");
	for (i = 0; i < FCNT_MAX; i++) {
		printf("  %-25s %14llu ", pf_fcounters[i],
			    (unsigned long long)s->fcounters[i]);
		if (runtime > 0)
			printf("%14.1f/s\n",
			    (double)s->fcounters[i] / (double)runtime);
		else
			printf("%14s\n", "");
	}
	if (opts & PF_OPT_VERBOSE) {
		printf("Source Tracking Table\n");
		printf("  %-25s %14u %14s\n", "current entries",
		    s->src_nodes, "");
		for (i = 0; i < SCNT_MAX; i++) {
			printf("  %-25s %14lld ", pf_scounters[i],
				    s->scounters[i]);
			if (runtime > 0)
				printf("%14.1f/s\n",
				    (double)s->scounters[i] / (double)runtime);
			else
				printf("%14s\n", "");
		}
	}
	printf("Counters\n");
	for (i = 0; i < PFRES_MAX; i++) {
		printf("  %-25s %14llu ", pf_reasons[i],
		    (unsigned long long)s->counters[i]);
		if (runtime > 0)
			printf("%14.1f/s\n",
			    (double)s->counters[i] / (double)runtime);
		else
			printf("%14s\n", "");
	}
	if (opts & PF_OPT_VERBOSE) {
		printf("Limit Counters\n");
		for (i = 0; i < LCNT_MAX; i++) {
			printf("  %-25s %14lld ", pf_lcounters[i],
				    s->lcounters[i]);
			if (runtime > 0)
				printf("%14.1f/s\n",
				    (double)s->lcounters[i] / (double)runtime);
			else
				printf("%14s\n", "");
		}
d4638 4
d4644 2
a4645 2
void
print_src_node(struct pf_src_node *sn, int opts)
d4647 1
a4647 2
	struct pf_addr_wrap aw;
	int min, sec;
d4649 2
a4650 5
	memset(&aw, 0, sizeof(aw));
	if (sn->af == AF_INET)
		aw.v.a.mask.addr32[0] = 0xffffffff;
	else
		memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));
d4652 5
a4656 27
	aw.v.a.addr = sn->addr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
	printf(" -> ");
	aw.v.a.addr = sn->raddr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
	printf(" ( states %u, connections %u, rate %u.%u/%us )\n", sn->states,
	    sn->conn, sn->conn_rate.count / 1000,
	    (sn->conn_rate.count % 1000) / 100, sn->conn_rate.seconds);
	if (opts & PF_OPT_VERBOSE) {
		sec = sn->creation % 60;
		sn->creation /= 60;
		min = sn->creation % 60;
		sn->creation /= 60;
		printf("   age %.2u:%.2u:%.2u", sn->creation, min, sec);
		if (sn->states == 0) {
			sec = sn->expire % 60;
			sn->expire /= 60;
			min = sn->expire % 60;
			sn->expire /= 60;
			printf(", expires in %.2u:%.2u:%.2u",
			    sn->expire, min, sec);
		}
		printf(", %u pkts, %u bytes", sn->packets, sn->bytes);
		switch (sn->ruletype) {
		case PF_NAT:
			if (sn->rule.nr != -1)
				printf(", nat rule %u", sn->rule.nr);
d4658 2
a4659 3
		case PF_RDR:
			if (sn->rule.nr != -1)
				printf(", rdr rule %u", sn->rule.nr);
a4660 6
		case PF_PASS:
			if (sn->rule.nr != -1)
				printf(", filter rule %u", sn->rule.nr);
			break;
		}
		printf("\n");
d4662 1
d4665 2
a4666 2
void
print_rule(struct pf_rule *r, const char *anchor_call, int verbose)
d4668 26
a4693 61
	static const char *actiontypes[] = { "pass", "block", "scrub",
	    "no scrub", "nat", "no nat", "binat", "no binat", "rdr", "no rdr" };
	static const char *anchortypes[] = { "anchor", "anchor", "anchor",
	    "anchor", "nat-anchor", "nat-anchor", "binat-anchor",
	    "binat-anchor", "rdr-anchor", "rdr-anchor" };
	int	i, opts;

	if (verbose)
		printf("@@%d ", r->nr);
	if (r->action > PF_NORDR)
		printf("action(%d)", r->action);
	else if (anchor_call[0])
		printf("%s \"%s\"", anchortypes[r->action],
		    anchor_call);
	else {
		printf("%s", actiontypes[r->action]);
		if (r->natpass)
			printf(" pass");
	}
	if (r->action == PF_DROP) {
		if (r->rule_flag & PFRULE_RETURN)
			printf(" return");
		else if (r->rule_flag & PFRULE_RETURNRST) {
			if (!r->return_ttl)
				printf(" return-rst");
			else
				printf(" return-rst(ttl %d)", r->return_ttl);
		} else if (r->rule_flag & PFRULE_RETURNICMP) {
			const struct icmpcodeent	*ic, *ic6;

			ic = geticmpcodebynumber(r->return_icmp >> 8,
			    r->return_icmp & 255, AF_INET);
			ic6 = geticmpcodebynumber(r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, AF_INET6);

			switch (r->af) {
			case AF_INET:
				printf(" return-icmp");
				if (ic == NULL)
					printf("(%u)", r->return_icmp & 255);
				else
					printf("(%s)", ic->name);
				break;
			case AF_INET6:
				printf(" return-icmp6");
				if (ic6 == NULL)
					printf("(%u)", r->return_icmp6 & 255);
				else
					printf("(%s)", ic6->name);
				break;
			default:
				printf(" return-icmp");
				if (ic == NULL)
					printf("(%u, ", r->return_icmp & 255);
				else
					printf("(%s, ", ic->name);
				if (ic6 == NULL)
					printf("%u)", r->return_icmp6 & 255);
				else
					printf("%s)", ic6->name);
				break;
d4695 3
a4697 81
		} else
			printf(" drop");
	}
	if (r->direction == PF_IN)
		printf(" in");
	else if (r->direction == PF_OUT)
		printf(" out");
	if (r->log == 1)
		printf(" log");
	else if (r->log == 2)
		printf(" log-all");
	if (r->quick)
		printf(" quick");
	if (r->ifname[0]) {
		if (r->ifnot)
			printf(" on ! %s", r->ifname);
		else
			printf(" on %s", r->ifname);
	}
	if (r->rt) {
		if (r->rt == PF_ROUTETO)
			printf(" route-to");
		else if (r->rt == PF_REPLYTO)
			printf(" reply-to");
		else if (r->rt == PF_DUPTO)
			printf(" dup-to");
		else if (r->rt == PF_FASTROUTE)
			printf(" fastroute");
		if (r->rt != PF_FASTROUTE) {
			printf(" ");
			print_pool(&r->rpool, 0, 0, r->af, PF_PASS);
		}
	}
	if (r->af) {
		if (r->af == AF_INET)
			printf(" inet");
		else
			printf(" inet6");
	}
	if (r->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(r->proto)) != NULL)
			printf(" proto %s", p->p_name);
		else
			printf(" proto %u", r->proto);
	}
	print_fromto(&r->src, r->os_fingerprint, &r->dst, r->af, r->proto,
	    verbose);
	if (r->uid.op)
		print_ugid(r->uid.op, r->uid.uid[0], r->uid.uid[1], "user",
		    UID_MAX);
	if (r->gid.op)
		print_ugid(r->gid.op, r->gid.gid[0], r->gid.gid[1], "group",
		    GID_MAX);
	if (r->flags || r->flagset) {
		printf(" flags ");
		print_flags(r->flags);
		printf("/");
		print_flags(r->flagset);
	}
	if (r->type) {
		const struct icmptypeent	*it;

		it = geticmptypebynumber(r->type-1, r->af);
		if (r->af != AF_INET6)
			printf(" icmp-type");
		else
			printf(" icmp6-type");
		if (it != NULL)
			printf(" %s", it->name);
		else
			printf(" %u", r->type-1);
		if (r->code) {
			const struct icmpcodeent	*ic;

			ic = geticmpcodebynumber(r->type-1, r->code-1, r->af);
			if (ic != NULL)
				printf(" code %s", ic->name);
			else
				printf(" code %u", r->code-1);
d4699 19
a4717 19
	}
	if (r->tos)
		printf(" tos 0x%2.2x", r->tos);
	if (r->keep_state == PF_STATE_NORMAL)
		printf(" keep state");
	else if (r->keep_state == PF_STATE_MODULATE)
		printf(" modulate state");
	else if (r->keep_state == PF_STATE_SYNPROXY)
		printf(" synproxy state");
	if (r->prob) {
		char	buf[20];

		snprintf(buf, sizeof(buf), "%f", r->prob*100.0/(UINT_MAX+1.0));
		for (i = strlen(buf)-1; i > 0; i--) {
			if (buf[i] == '0')
				buf[i] = '\0';
			else {
				if (buf[i] == '.')
					buf[i] = '\0';
d4720 9
d4730 17
a4746 35
		printf(" probability %s%%", buf);
	}
	opts = 0;
	if (r->max_states || r->max_src_nodes || r->max_src_states)
		opts = 1;
	if (r->rule_flag & PFRULE_NOSYNC)
		opts = 1;
	if (r->rule_flag & PFRULE_SRCTRACK)
		opts = 1;
	if (r->rule_flag & (PFRULE_IFBOUND | PFRULE_GRBOUND))
		opts = 1;
	for (i = 0; !opts && i < PFTM_MAX; ++i)
		if (r->timeout[i])
			opts = 1;
	if (opts) {
		printf(" (");
		if (r->max_states) {
			printf("max %u", r->max_states);
			opts = 0;
		}
		if (r->rule_flag & PFRULE_NOSYNC) {
			if (!opts)
				printf(", ");
			printf("no-sync");
			opts = 0;
		}
		if (r->rule_flag & PFRULE_SRCTRACK) {
			if (!opts)
				printf(", ");
			printf("source-track");
			if (r->rule_flag & PFRULE_RULESRCTRACK)
				printf(" rule");
			else
				printf(" global");
			opts = 0;
d4748 8
a4755 102
		if (r->max_src_states) {
			if (!opts)
				printf(", ");
			printf("max-src-states %u", r->max_src_states);
			opts = 0;
		}
		if (r->max_src_conn) {
			if (!opts)
				printf(", ");
			printf("max-src-conn %u", r->max_src_conn);
			opts = 0;
		}
		if (r->max_src_conn_rate.limit) {
			if (!opts)
				printf(", ");
			printf("max-src-conn-rate %u/%u",
			    r->max_src_conn_rate.limit,
			    r->max_src_conn_rate.seconds);
			opts = 0;
		}
		if (r->max_src_nodes) {
			if (!opts)
				printf(", ");
			printf("max-src-nodes %u", r->max_src_nodes);
			opts = 0;
		}
		if (r->overload_tblname[0]) {
			if (!opts)
				printf(", ");
			printf("overload <%s>", r->overload_tblname);
			if (r->rule_flag & PFRULE_SRCTRACK_FLUSH)
				printf(" flush");
		}
		if (r->rule_flag & PFRULE_IFBOUND) {
			if (!opts)
				printf(", ");
			printf("if-bound");
			opts = 0;
		}
		if (r->rule_flag & PFRULE_GRBOUND) {
			if (!opts)
				printf(", ");
			printf("group-bound");
			opts = 0;
		}
		for (i = 0; i < PFTM_MAX; ++i)
			if (r->timeout[i]) {
				int j;

				if (!opts)
					printf(", ");
				opts = 0;
				for (j = 0; j < sizeof(pf_timeouts) /
				    sizeof(pf_timeouts[0]); ++j)
					if (pf_timeouts[j].timeout == i)
						break;
				printf("%s %u", j == PFTM_MAX ?  "inv.timeout" :
				    pf_timeouts[j].name, r->timeout[i]);
			}
		printf(")");
	}
	if (r->rule_flag & PFRULE_FRAGMENT)
		printf(" fragment");
	if (r->rule_flag & PFRULE_NODF)
		printf(" no-df");
	if (r->rule_flag & PFRULE_RANDOMID)
		printf(" random-id");
	if (r->min_ttl)
		printf(" min-ttl %d", r->min_ttl);
	if (r->max_mss)
		printf(" max-mss %d", r->max_mss);
	if (r->allow_opts)
		printf(" allow-opts");
	if (r->action == PF_SCRUB) {
		if (r->rule_flag & PFRULE_REASSEMBLE_TCP)
			printf(" reassemble tcp");

		if (r->rule_flag & PFRULE_FRAGDROP)
			printf(" fragment drop-ovl");
		else if (r->rule_flag & PFRULE_FRAGCROP)
			printf(" fragment crop");
		else
			printf(" fragment reassemble");
	}
	if (r->label[0])
		printf(" label \"%s\"", r->label);
	if (r->qname[0] && r->pqname[0])
		printf(" queue(%s, %s)", r->qname, r->pqname);
	else if (r->qname[0])
		printf(" queue %s", r->qname);
	if (r->tagname[0])
		printf(" tag %s", r->tagname);
	if (r->match_tagname[0]) {
		if (r->match_tag_not)
			printf(" !");
		printf(" tagged %s", r->match_tagname);
	}
	if (!anchor_call[0] && (r->action == PF_NAT ||
	    r->action == PF_BINAT || r->action == PF_RDR)) {
		printf(" -> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, r->action);
a4756 2
	printf("\n");
}
d4758 24
a4781 30
void
print_tabledef(const char *name, int flags, int addrs,
    struct node_tinithead *nodes)
{
	struct node_tinit	*ti, *nti;
	struct node_host	*h;

	printf("table <%s>", name);
	if (flags & PFR_TFLAG_CONST)
		printf(" const");
	if (flags & PFR_TFLAG_PERSIST)
		printf(" persist");
	SIMPLEQ_FOREACH(ti, nodes, entries) {
		if (ti->file) {
			printf(" file \"%s\"", ti->file);
			continue;
		}
		printf(" {");
		for (;;) {
			for (h = ti->host; h != NULL; h = h->next) {
				printf(h->not ? " !" : " ");
				print_addr(&h->addr, h->af, 0);
			}
			nti = SIMPLEQ_NEXT(ti, entries);
			if (nti != NULL && nti->file == NULL)
				ti = nti;	/* merge lists */
			else
				break;
		}
		printf(" }");
d4783 3
a4785 3
	if (addrs && SIMPLEQ_EMPTY(nodes))
		printf(" { }");
	printf("\n");
d4789 1
a4789 16
parse_flags(char *s)
{
	char		*p, *q;
	u_int8_t	 f = 0;

	for (p = s; *p; p++) {
		if ((q = strchr(tcpflags, *p)) == NULL)
			return -1;
		else
			f |= 1 << (q - tcpflags);
	}
	return (f ? f : PF_TH_ALL);
}

void
set_ipmask(struct node_host *h, u_int8_t b)
d4791 1
a4791 2
	struct pf_addr	*m, *n;
	int		 i, j = 0;
d4793 23
a4815 6
	m = &h->addr.v.a.mask;
	memset(m, 0, sizeof(*m));

	while (b >= 32) {
		m->addr32[j++] = 0xffffffff;
		b -= 32;
a4816 4
	for (i = 31; i > 31-b; --i)
		m->addr32[j] |= (1 << i);
	if (b)
		m->addr32[j] = htonl(m->addr32[j]);
d4818 1
a4818 5
	/* Mask off bits of the address that will never be used. */
	n = &h->addr.v.a.addr;
	if (h->addr.type == PF_ADDR_ADDRMASK)
		for (i = 0; i < 4; i++)
			n->addr32[i] = n->addr32[i] & m->addr32[i];
d4821 4
d4826 1
a4826 1
check_netmask(struct node_host *h, sa_family_t af)
d4828 1
a4828 2
	struct node_host	*n = NULL;
	struct pf_addr	*m;
d4830 12
a4841 14
	for (n = h; n != NULL; n = n->next) {
		if (h->addr.type == PF_ADDR_TABLE)
			continue;
		m = &h->addr.v.a.mask;
		/* fix up netmask for dynaddr */
		if (af == AF_INET && h->addr.type == PF_ADDR_DYNIFTL &&
		    unmask(m, AF_INET6) > 32)
			set_ipmask(n, 32);
		/* netmasks > 32 bit are invalid on v4 */
		if (af == AF_INET &&
		    (m->addr32[1] || m->addr32[2] || m->addr32[3])) {
			fprintf(stderr, "netmask %u invalid for IPv4 address\n",
			    unmask(m, AF_INET6));
			return (1);
d4844 17
d4864 5
a4868 1
/* interface lookup routines */
d4870 2
a4871 1
struct node_host	*iftab;
d4873 2
a4874 5
void
ifa_load(void)
{
	struct ifaddrs		*ifap, *ifa;
	struct node_host	*n = NULL, *h = NULL;
d4876 1
a4876 2
	if (getifaddrs(&ifap) < 0)
		err(1, "getifaddrs");
d4878 2
a4879 70
	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (!(ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6 ||
		    ifa->ifa_addr->sa_family == AF_LINK))
				continue;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = ifa->ifa_addr->sa_family;
		n->ifa_flags = ifa->ifa_flags;
#ifdef __KAME__
		if (n->af == AF_INET6 &&
		    IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)
		    ifa->ifa_addr)->sin6_addr) &&
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id ==
		    0) {
			struct sockaddr_in6	*sin6;

			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
			sin6->sin6_scope_id = sin6->sin6_addr.s6_addr[2] << 8 |
			    sin6->sin6_addr.s6_addr[3];
			sin6->sin6_addr.s6_addr[2] = 0;
			sin6->sin6_addr.s6_addr[3] = 0;
		}
#endif
		n->ifindex = 0;
		if (n->af == AF_INET) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in *)
			    ifa->ifa_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in *)
			    ifa->ifa_netmask)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in *)
				    ifa->ifa_broadaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
			if (ifa->ifa_dstaddr != NULL)
				memcpy(&n->peer, &((struct sockaddr_in *)
				    ifa->ifa_dstaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
		} else if (n->af == AF_INET6) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in6 *)
			    ifa->ifa_netmask)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in6 *)
				    ifa->ifa_broadaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			if (ifa->ifa_dstaddr != NULL)
				 memcpy(&n->peer, &((struct sockaddr_in6 *)
				    ifa->ifa_dstaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			n->ifindex = ((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_scope_id;
		}
		if ((n->ifname = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
d4881 1
a4881 2
	iftab = h;
	freeifaddrs(ifap);
d4884 2
a4885 2
struct node_host *
ifa_exists(const char *ifa_name, int group_ok)
d4887 1
a4887 9
	struct node_host	*n;

	if (iftab == NULL)
		ifa_load();

	for (n = iftab; n; n = n->next) {
		if (n->af == AF_LINK && !strncmp(n->ifname, ifa_name, IFNAMSIZ))
			return (n);
	}
d4889 5
d4897 2
a4898 2
struct node_host *
ifa_lookup(const char *ifa_name, int flags)
d4900 1
a4900 3
	struct node_host	*p = NULL, *h = NULL, *n = NULL;
	int			 got4 = 0, got6 = 0;
	const char		 *last_if = NULL;
d4902 12
a4913 2
	if (!strncmp(ifa_name, "self", IFNAMSIZ))
		ifa_name = NULL;
d4915 4
a4918 2
	if (iftab == NULL)
		ifa_load();
d4920 23
a4942 60
	for (p = iftab; p; p = p->next) {
		if (ifa_skip_if(ifa_name, p))
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) && p->af != AF_INET)
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) &&
		    !(p->ifa_flags & IFF_BROADCAST))
			continue;
		if ((flags & PFI_AFLAG_PEER) &&
		    !(p->ifa_flags & IFF_POINTOPOINT))
			continue;
		if ((flags & PFI_AFLAG_NETWORK) && p->ifindex > 0)
			continue;
		if (last_if == NULL || strcmp(last_if, p->ifname))
			got4 = got6 = 0;
		last_if = p->ifname;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET && got4)
			continue;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET6 && got6)
			continue;
		if (p->af == AF_INET)
			got4 = 1;
		else
			got6 = 1;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = p->af;
		if (flags & PFI_AFLAG_BROADCAST)
			memcpy(&n->addr.v.a.addr, &p->bcast,
			    sizeof(struct pf_addr));
		else if (flags & PFI_AFLAG_PEER)
			memcpy(&n->addr.v.a.addr, &p->peer,
			    sizeof(struct pf_addr));
		else
			memcpy(&n->addr.v.a.addr, &p->addr.v.a.addr,
			    sizeof(struct pf_addr));
		if (flags & PFI_AFLAG_NETWORK)
			set_ipmask(n, unmask(&p->addr.v.a.mask, n->af));
		else {
			if (n->af == AF_INET) {
				if (p->ifa_flags & IFF_LOOPBACK &&
				    p->ifa_flags & IFF_LINK1)
					memcpy(&n->addr.v.a.mask,
					    &p->addr.v.a.mask,
					    sizeof(struct pf_addr));
				else
					set_ipmask(n, 32);
			} else
				set_ipmask(n, 128);
		}
		n->ifindex = p->ifindex;

		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
a4944 1
	return (h);
d4948 1
a4948 1
ifa_skip_if(const char *filter, struct node_host *p)
d4950 2
a4951 1
	int	n;
d4953 9
a4961 87
	if (p->af != AF_INET && p->af != AF_INET6)
		return (1);
	if (filter == NULL || !*filter)
		return (0);
	if (!strcmp(p->ifname, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);	/* only do exact match in that case */
	if (strncmp(p->ifname, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->ifname[n] < '0' || p->ifname[n] > '9');
}


struct node_host *
host(const char *s)
{
	struct node_host	*h = NULL;
	int			 mask, v4mask, v6mask, cont = 1;
	char			*p, *q, *ps;

	if ((p = strrchr(s, '/')) != NULL) {
		mask = strtol(p+1, &q, 0);
		if (!q || *q || mask > 128 || q == (p+1)) {
			fprintf(stderr, "invalid netmask '%s'\n", p);
			return (NULL);
		}
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
		v4mask = v6mask = mask;
	} else {
		if ((ps = strdup(s)) == NULL)
			err(1, "host: strdup");
		v4mask = 32;
		v6mask = 128;
		mask = -1;
	}

	/* interface with this name exists? */
	if (cont && (h = host_if(ps, mask)) != NULL)
		cont = 0;

	/* IPv4 address? */
	if (cont && (h = host_v4(s, mask)) != NULL)
		cont = 0;

	/* IPv6 address? */
	if (cont && (h = host_v6(ps, v6mask)) != NULL)
		cont = 0;

	/* dns lookup */
	if (cont && (h = host_dns(ps, v4mask, v6mask)) != NULL)
		cont = 0;
	free(ps);

	if (h == NULL || cont == 1) {
		fprintf(stderr, "no IP address found for %s\n", s);
		return (NULL);
	}
	return (h);
}

struct node_host *
host_if(const char *s, int mask)
{
	struct node_host	*n, *h = NULL;
	char			*p, *ps;
	int			 flags = 0;

	if ((ps = strdup(s)) == NULL)
		err(1, "host_if: strdup");
	while ((p = strrchr(ps, ':')) != NULL) {
		if (!strcmp(p+1, "network"))
			flags |= PFI_AFLAG_NETWORK;
		else if (!strcmp(p+1, "broadcast"))
			flags |= PFI_AFLAG_BROADCAST;
		else if (!strcmp(p+1, "peer"))
			flags |= PFI_AFLAG_PEER;
		else if (!strcmp(p+1, "0"))
			flags |= PFI_AFLAG_NOALIAS;
		else {
			free(ps);
			return (NULL);
a4962 1
		*p = '\0';
d4964 4
a4967 36
	if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) { /* Yep! */
		fprintf(stderr, "illegal combination of interface modifiers\n");
		free(ps);
		return (NULL);
	}
	if ((flags & (PFI_AFLAG_NETWORK|PFI_AFLAG_BROADCAST)) && mask > -1) {
		fprintf(stderr, "network or broadcast lookup, but "
		    "extra netmask given\n");
		free(ps);
		return (NULL);
	}
	if (ifa_exists(ps, 1) || !strncmp(ps, "self", IFNAMSIZ)) {
		/* interface with this name exists */
		h = ifa_lookup(ps, flags);
		for (n = h; n != NULL && mask > -1; n = n->next)
			set_ipmask(n, mask);
	}

	free(ps);
	return (h);
}

struct node_host *
host_v4(const char *s, int mask)
{
	struct node_host	*h = NULL;
	struct in_addr		 ina;
	int			 bits = 32;

	memset(&ina, 0, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
d4969 1
a4969 117

	h = calloc(1, sizeof(struct node_host));
	if (h == NULL)
		err(1, "address: calloc");
	h->ifname = NULL;
	h->af = AF_INET;
	h->addr.v.a.addr.addr32[0] = ina.s_addr;
	set_ipmask(h, bits);
	h->next = NULL;
	h->tail = h;

	return (h);
}

struct node_host *
host_v6(const char *s, int mask)
{
	struct addrinfo		 hints, *res;
	struct node_host	*h = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET6;
		memcpy(&h->addr.v.a.addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(h->addr.v.a.addr));
		h->ifindex =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
		set_ipmask(h, mask);
		freeaddrinfo(res);
		h->next = NULL;
		h->tail = h;
	}

	return (h);
}

struct node_host *
host_dns(const char *s, int v4mask, int v6mask)
{
	struct addrinfo		 hints, *res0, *res;
	struct node_host	*n, *h = NULL;
	int			 error, noalias = 0;
	int			 got4 = 0, got6 = 0;
	char			*p, *ps;

	if ((ps = strdup(s)) == NULL)
		err(1, "host_dns: strdup");
	if ((p = strrchr(ps, ':')) != NULL && !strcmp(p, ":0")) {
		noalias = 1;
		*p = '\0';
	}
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM; /* DUMMY */
	error = getaddrinfo(ps, NULL, &hints, &res0);
	if (error) {
		free(ps);
		return (h);
	}

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if (noalias) {
			if (res->ai_family == AF_INET) {
				if (got4)
					continue;
				got4 = 1;
			} else {
				if (got6)
					continue;
				got6 = 1;
			}
		}
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "host_dns: calloc");
		n->ifname = NULL;
		n->af = res->ai_family;
		if (res->ai_family == AF_INET) {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			set_ipmask(n, v4mask);
		} else {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			n->ifindex =
			    ((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_scope_id;
			set_ipmask(n, v6mask);
		}
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	freeaddrinfo(res0);
	free(ps);

	return (h);
a4971 5
/*
 * convert a hostname to a list of addresses and put them in the given buffer.
 * test:
 *	if set to 1, only simple addresses are accepted (no netblock, no "!").
 */
d4973 1
a4973 1
append_addr(struct pfr_buffer *b, char *s, int test)
d4975 6
a4980 8
	char			 *r;
	struct node_host	*h, *n;
	int			 rv, not = 0;

	for (r = s; *r == '!'; r++)
		not = !not;
	if ((n = host(r)) == NULL) {
		errno = 0;
d4982 4
a4985 8
	}
	rv = append_addr_host(b, n, test, not);
	do {
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);
	return (rv);
a4987 6
/*
 * same as previous function, but with a pre-parsed input and the ability
 * to "negate" the result. Does not free the node_host list.
 * not:
 *      setting it to 1 is equivalent to adding "!" in front of parameter s.
 */
d4989 1
a4989 1
append_addr_host(struct pfr_buffer *b, struct node_host *n, int test, int not)
d4991 2
a4992 2
	int			 bits;
	struct pfr_addr		 addr;
d4994 3
a4996 17
	do {
		bzero(&addr, sizeof(addr));
		addr.pfra_not = n->not ^ not;
		addr.pfra_af = n->af;
		addr.pfra_net = unmask(&n->addr.v.a.mask, n->af);
		switch (n->af) {
		case AF_INET:
			addr.pfra_ip4addr.s_addr = n->addr.v.a.addr.addr32[0];
			bits = 32;
			break;
		case AF_INET6:
			memcpy(&addr.pfra_ip6addr, &n->addr.v.a.addr.v6,
			    sizeof(struct in6_addr));
			bits = 128;
			break;
		default:
			errno = EINVAL;
d4999 7
a5005 3
		if ((test && (not || addr.pfra_net != bits)) ||
		    addr.pfra_net > bits) {
			errno = EINVAL;
d5008 2
a5009 5
		if (pfr_buf_add(b, &addr))
			return (-1);
	} while ((n = n->next) != NULL);

	return (0);
d5013 1
a5013 1
pfctl_add_trans(struct pfr_buffer *buf, int rs_num, const char *anchor)
d5015 9
a5023 9
	struct pfioc_trans_e trans;

	bzero(&trans, sizeof(trans));
	trans.rs_num = rs_num;
	if (strlcpy(trans.anchor, anchor,
	    sizeof(trans.anchor)) >= sizeof(trans.anchor))
		errx(1, "pfctl_add_trans: strlcpy");

	return pfr_buf_add(buf, &trans);
d5026 2
a5027 2
u_int32_t
pfctl_get_ticket(struct pfr_buffer *buf, int rs_num, const char *anchor)
d5029 8
a5036 1
	struct pfioc_trans_e *p;
d5038 12
a5049 4
	PFRB_FOREACH(p, buf)
		if (rs_num == p->rs_num && !strcmp(anchor, p->anchor))
			return (p->ticket);
	errx(1, "pfctl_get_ticket: assertion failed");
d5053 1
a5053 1
pfctl_trans(int dev, struct pfr_buffer *buf, u_long cmd, int from)
d5055 10
a5064 1
	struct pfioc_trans trans;
d5066 1
a5066 5
	bzero(&trans, sizeof(trans));
	trans.size = buf->pfrb_size - from;
	trans.esize = sizeof(struct pfioc_trans_e);
	trans.array = ((struct pfioc_trans_e *)buf->pfrb_caddr) + from;
	return ioctl(dev, cmd, &trans);
d5068 1
@


1.463
log
@Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.462 2004/12/05 10:11:29 dhartmei Exp $	*/
d4 3
a6 4
 * Copyright (c) 2001 Markus Friedl.  All rights reserved.
 * Copyright (c) 2001 Daniel Hartmeier.  All rights reserved.
 * Copyright (c) 2001 Theo de Raadt.  All rights reserved.
 * Copyright (c) 2002,2003 Henning Brauer. All rights reserved.
a10 5
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
d12 20
a31 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d33 1
a33 1
%{
d35 1
d37 2
a46 4
#include <altq/altq.h>
#include <altq/altq_cbq.h>
#include <altq/altq_priq.h>
#include <altq/altq_hfsc.h>
d50 2
a54 3
#include <string.h>
#include <ctype.h>
#include <math.h>
d56 1
a56 4
#include <limits.h>
#include <pwd.h>
#include <grp.h>
#include <md5.h>
d61 41
a101 48
static struct pfctl	*pf = NULL;
static FILE		*fin = NULL;
static int		 debug = 0;
static int		 lineno = 1;
static int		 errors = 0;
static int		 rulestate = 0;
static u_int16_t	 returnicmpdefault =
			    (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
static u_int16_t	 returnicmp6default =
			    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
static int		 blockpolicy = PFRULE_DROP;
static int		 require_order = 1;
static int		 default_statelock;

enum {
	PFCTL_STATE_NONE,
	PFCTL_STATE_OPTION,
	PFCTL_STATE_SCRUB,
	PFCTL_STATE_QUEUE,
	PFCTL_STATE_NAT,
	PFCTL_STATE_FILTER
};

struct node_proto {
	u_int8_t		 proto;
	struct node_proto	*next;
	struct node_proto	*tail;
};

struct node_port {
	u_int16_t		 port[2];
	u_int8_t		 op;
	struct node_port	*next;
	struct node_port	*tail;
};

struct node_uid {
	uid_t			 uid[2];
	u_int8_t		 op;
	struct node_uid		*next;
	struct node_uid		*tail;
};

struct node_gid {
	gid_t			 gid[2];
	u_int8_t		 op;
	struct node_gid		*next;
	struct node_gid		*tail;
d104 27
a130 6
struct node_icmp {
	u_int8_t		 code;
	u_int8_t		 type;
	u_int8_t		 proto;
	struct node_icmp	*next;
	struct node_icmp	*tail;
d133 31
a163 33
enum	{ PF_STATE_OPT_MAX, PF_STATE_OPT_NOSYNC, PF_STATE_OPT_SRCTRACK,
	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_CONN,
	    PF_STATE_OPT_MAX_SRC_CONN_RATE, PF_STATE_OPT_MAX_SRC_NODES,
	    PF_STATE_OPT_OVERLOAD, PF_STATE_OPT_STATELOCK,
	    PF_STATE_OPT_TIMEOUT };

enum	{ PF_SRCTRACK_NONE, PF_SRCTRACK, PF_SRCTRACK_GLOBAL, PF_SRCTRACK_RULE };

struct node_state_opt {
	int			 type;
	union {
		u_int32_t	 max_states;
		u_int32_t	 max_src_states;
		u_int32_t	 max_src_conn;
		struct {
			u_int32_t	limit;
			u_int32_t	seconds;
	
		}		 max_src_conn_rate;
		struct {
			u_int8_t	flush;
			char		tblname[PF_TABLE_NAME_SIZE];
		}		 overload;
		u_int32_t	 max_src_nodes;
		u_int8_t	 src_track;
		u_int32_t	 statelock;
		struct {
			int		number;
			u_int32_t	seconds;
		}		 timeout;
	}			 data;
	struct node_state_opt	*next;
	struct node_state_opt	*tail;
d166 13
a178 3
struct peer {
	struct node_host	*host;
	struct node_port	*port;
d181 22
a202 12
struct node_queue {
	char			 queue[PF_QNAME_SIZE];
	char			 parent[PF_QNAME_SIZE];
	char			 ifname[IFNAMSIZ];
	int			 scheduler;
	struct node_queue	*next;
	struct node_queue	*tail;
}	*queues = NULL;

struct node_qassign {
	char		*qname;
	char		*pqname;
d205 2
a206 3430
struct filter_opts {
	int			 marker;
#define FOM_FLAGS	0x01
#define FOM_ICMP	0x02
#define FOM_TOS		0x04
#define FOM_KEEP	0x08
#define FOM_SRCTRACK	0x10
	struct node_uid		*uid;
	struct node_gid		*gid;
	struct {
		u_int8_t	 b1;
		u_int8_t	 b2;
		u_int16_t	 w;
		u_int16_t	 w2;
	} flags;
	struct node_icmp	*icmpspec;
	u_int32_t		 tos;
	u_int32_t		 prob;
	struct {
		int			 action;
		struct node_state_opt	*options;
	} keep;
	int			 fragment;
	int			 allowopts;
	char			*label;
	struct node_qassign	 queues;
	char			*tag;
	char			*match_tag;
	u_int8_t		 match_tag_not;
} filter_opts;

struct antispoof_opts {
	char			*label;
} antispoof_opts;

struct scrub_opts {
	int			marker;
#define SOM_MINTTL	0x01
#define SOM_MAXMSS	0x02
#define SOM_FRAGCACHE	0x04
	int			nodf;
	int			minttl;
	int			maxmss;
	int			fragcache;
	int			randomid;
	int			reassemble_tcp;
} scrub_opts;

struct queue_opts {
	int			marker;
#define QOM_BWSPEC	0x01
#define QOM_SCHEDULER	0x02
#define QOM_PRIORITY	0x04
#define QOM_TBRSIZE	0x08
#define QOM_QLIMIT	0x10
	struct node_queue_bw	queue_bwspec;
	struct node_queue_opt	scheduler;
	int			priority;
	int			tbrsize;
	int			qlimit;
} queue_opts;

struct table_opts {
	int			flags;
	int			init_addr;
	struct node_tinithead	init_nodes;
} table_opts;

struct pool_opts {
	int			 marker;
#define POM_TYPE		0x01
#define POM_STICKYADDRESS	0x02
	u_int8_t		 opts;
	int			 type;
	int			 staticport;
	struct pf_poolhashkey	*key;

} pool_opts;


struct node_hfsc_opts	hfsc_opts;

int	yyerror(const char *, ...);
int	disallow_table(struct node_host *, const char *);
int	disallow_alias(struct node_host *, const char *);
int	rule_consistent(struct pf_rule *);
int	filter_consistent(struct pf_rule *);
int	nat_consistent(struct pf_rule *);
int	rdr_consistent(struct pf_rule *);
int	process_tabledef(char *, struct table_opts *);
int	yyparse(void);
void	expand_label_str(char *, size_t, const char *, const char *);
void	expand_label_if(const char *, char *, size_t, const char *);
void	expand_label_addr(const char *, char *, size_t, u_int8_t,
	    struct node_host *);
void	expand_label_port(const char *, char *, size_t, struct node_port *);
void	expand_label_proto(const char *, char *, size_t, u_int8_t);
void	expand_label_nr(const char *, char *, size_t);
void	expand_label(char *, size_t, const char *, u_int8_t, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    u_int8_t);
void	expand_rule(struct pf_rule *, struct node_if *, struct node_host *,
	    struct node_proto *, struct node_os*, struct node_host *,
	    struct node_port *, struct node_host *, struct node_port *,
	    struct node_uid *, struct node_gid *, struct node_icmp *,
	    const char *);
int	expand_altq(struct pf_altq *, struct node_if *, struct node_queue *,
	    struct node_queue_bw bwspec, struct node_queue_opt *);
int	expand_queue(struct pf_altq *, struct node_if *, struct node_queue *,
	    struct node_queue_bw, struct node_queue_opt *);

int	 check_rulestate(int);
int	 kw_cmp(const void *, const void *);
int	 lookup(char *);
int	 lgetc(FILE *);
int	 lungetc(int);
int	 findeol(void);
int	 yylex(void);
int	 atoul(char *, u_long *);
int	 getservice(char *);
int	 rule_label(struct pf_rule *, char *);

TAILQ_HEAD(symhead, sym)	 symhead = TAILQ_HEAD_INITIALIZER(symhead);
struct sym {
	TAILQ_ENTRY(sym)	 entries;
	int			 used;
	int			 persist;
	char			*nam;
	char			*val;
};


int	 symset(const char *, const char *, int);
char	*symget(const char *);

void	 decide_address_family(struct node_host *, sa_family_t *);
void	 remove_invalid_hosts(struct node_host **, sa_family_t *);
int	 invalid_redirect(struct node_host *, sa_family_t);
u_int16_t parseicmpspec(char *, sa_family_t);

TAILQ_HEAD(loadanchorshead, loadanchors)
    loadanchorshead = TAILQ_HEAD_INITIALIZER(loadanchorshead);

struct loadanchors {
	TAILQ_ENTRY(loadanchors)	 entries;
	char				*anchorname;
	char				*filename;
};

typedef struct {
	union {
		u_int32_t		 number;
		int			 i;
		char			*string;
		struct {
			u_int8_t	 b1;
			u_int8_t	 b2;
			u_int16_t	 w;
			u_int16_t	 w2;
		}			 b;
		struct range {
			int		 a;
			int		 b;
			int		 t;
		}			 range;
		struct node_if		*interface;
		struct node_proto	*proto;
		struct node_icmp	*icmp;
		struct node_host	*host;
		struct node_os		*os;
		struct node_port	*port;
		struct node_uid		*uid;
		struct node_gid		*gid;
		struct node_state_opt	*state_opt;
		struct peer		 peer;
		struct {
			struct peer	 src, dst;
			struct node_os	*src_os;
		}			 fromto;
		struct {
			struct node_host	*host;
			u_int8_t		 rt;
			u_int8_t		 pool_opts;
			sa_family_t		 af;
			struct pf_poolhashkey	*key;
		}			 route;
		struct redirection {
			struct node_host	*host;
			struct range		 rport;
		}			*redirection;
		struct {
			int			 action;
			struct node_state_opt	*options;
		}			 keep_state;
		struct {
			u_int8_t	 log;
			u_int8_t	 quick;
		}			 logquick;
		struct pf_poolhashkey	*hashkey;
		struct node_queue	*queue;
		struct node_queue_opt	 queue_options;
		struct node_queue_bw	 queue_bwspec;
		struct node_qassign	 qassign;
		struct filter_opts	 filter_opts;
		struct antispoof_opts	 antispoof_opts;
		struct queue_opts	 queue_opts;
		struct scrub_opts	 scrub_opts;
		struct table_opts	 table_opts;
		struct pool_opts	 pool_opts;
		struct node_hfsc_opts	 hfsc_opts;
	} v;
	int lineno;
} YYSTYPE;

#define DYNIF_MULTIADDR(addr) ((addr).type == PF_ADDR_DYNIFTL && \
	(!((addr).iflags & PFI_AFLAG_NOALIAS) ||		 \
	!isdigit((addr).v.ifname[strlen((addr).v.ifname)-1])))

%}

%token	PASS BLOCK SCRUB RETURN IN OS OUT LOG LOGALL QUICK ON FROM TO FLAGS
%token	RETURNRST RETURNICMP RETURNICMP6 PROTO INET INET6 ALL ANY ICMPTYPE
%token	ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT ARROW NODF
%token	MINTTL ERROR ALLOWOPTS FASTROUTE FILENAME ROUTETO DUPTO REPLYTO NO LABEL
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP TABLE
%token	REASSEMBLE FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
%token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE BLOCKPOLICY RANDOMID
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG HOSTID
%token	ANTISPOOF FOR
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT PROBABILITY
%token	ALTQ CBQ PRIQ HFSC BANDWIDTH TBRSIZE LINKSHARE REALTIME UPPERLIMIT
%token	QUEUE PRIORITY QLIMIT
%token	LOAD
%token	STICKYADDRESS MAXSRCSTATES MAXSRCNODES SOURCETRACK GLOBAL RULE
%token	MAXSRCCONN MAXSRCCONNRATE OVERLOAD FLUSH
%token	TAGGED TAG IFBOUND GRBOUND FLOATING STATEPOLICY
%token	<v.string>		STRING
%token	<v.i>			PORTBINARY
%type	<v.interface>		interface if_list if_item_not if_item
%type	<v.number>		number icmptype icmp6type uid gid
%type	<v.number>		tos not yesno natpass
%type	<v.i>			no dir log af fragcache sourcetrack flush
%type	<v.i>			unaryop statelock
%type	<v.b>			action nataction scrubaction
%type	<v.b>			flags flag blockspec
%type	<v.range>		port rport
%type	<v.hashkey>		hashkey
%type	<v.proto>		proto proto_list proto_item
%type	<v.icmp>		icmpspec
%type	<v.icmp>		icmp_list icmp_item
%type	<v.icmp>		icmp6_list icmp6_item
%type	<v.fromto>		fromto
%type	<v.peer>		ipportspec from to
%type	<v.host>		ipspec xhost host dynaddr host_list
%type	<v.host>		redir_host_list redirspec
%type	<v.host>		route_host route_host_list routespec
%type	<v.os>			os xos os_list
%type	<v.port>		portspec port_list port_item
%type	<v.uid>			uids uid_list uid_item
%type	<v.gid>			gids gid_list gid_item
%type	<v.route>		route
%type	<v.redirection>		redirection redirpool
%type	<v.string>		label string tag
%type	<v.keep_state>		keep
%type	<v.state_opt>		state_opt_spec state_opt_list state_opt_item
%type	<v.logquick>		logquick
%type	<v.interface>		antispoof_ifspc antispoof_iflst antispoof_if
%type	<v.qassign>		qname
%type	<v.queue>		qassign qassign_list qassign_item
%type	<v.queue_options>	scheduler
%type	<v.number>		cbqflags_list cbqflags_item
%type	<v.number>		priqflags_list priqflags_item
%type	<v.hfsc_opts>		hfscopts_list hfscopts_item hfsc_opts
%type	<v.queue_bwspec>	bandwidth
%type	<v.filter_opts>		filter_opts filter_opt filter_opts_l
%type	<v.antispoof_opts>	antispoof_opts antispoof_opt antispoof_opts_l
%type	<v.queue_opts>		queue_opts queue_opt queue_opts_l
%type	<v.scrub_opts>		scrub_opts scrub_opt scrub_opts_l
%type	<v.table_opts>		table_opts table_opt table_opts_l
%type	<v.pool_opts>		pool_opts pool_opt pool_opts_l
%%

ruleset		: /* empty */
		| ruleset '\n'
		| ruleset option '\n'
		| ruleset scrubrule '\n'
		| ruleset natrule '\n'
		| ruleset binatrule '\n'
		| ruleset pfrule '\n'
		| ruleset anchorrule '\n'
		| ruleset loadrule '\n'
		| ruleset altqif '\n'
		| ruleset queuespec '\n'
		| ruleset varset '\n'
		| ruleset antispoof '\n'
		| ruleset tabledef '\n'
		| ruleset error '\n'		{ errors++; }
		;

option		: SET OPTIMIZATION STRING		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_set_optimization(pf, $3) != 0) {
				yyerror("unknown optimization %s", $3);
				free($3);
				YYERROR;
			}
			free ($3);
		}
		| SET TIMEOUT timeout_spec
		| SET TIMEOUT '{' timeout_list '}'
		| SET LIMIT limit_spec
		| SET LIMIT '{' limit_list '}'
		| SET LOGINTERFACE STRING		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_set_logif(pf, $3) != 0) {
				yyerror("error setting loginterface %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET HOSTID number {
			if ($3 == 0) {
				yyerror("hostid must be non-zero");
				YYERROR;
			}
			if (pfctl_set_hostid(pf, $3) != 0) {
				yyerror("error setting hostid %08x", $3);
				YYERROR;
			}
		}
		| SET BLOCKPOLICY DROP	{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set block-policy drop\n");
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
			blockpolicy = PFRULE_DROP;
		}
		| SET BLOCKPOLICY RETURN {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set block-policy return\n");
			if (check_rulestate(PFCTL_STATE_OPTION))
				YYERROR;
			blockpolicy = PFRULE_RETURN;
		}
		| SET REQUIREORDER yesno {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set require-order %s\n",
				    $3 == 1 ? "yes" : "no");
			require_order = $3;
		}
		| SET FINGERPRINTS STRING {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("fingerprints %s\n", $3);
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_file_fingerprints(pf->dev, pf->opts, $3)) {
				yyerror("error loading fingerprints %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		| SET STATEPOLICY statelock {
			if (pf->opts & PF_OPT_VERBOSE)
				switch ($3) {
				case 0:
					printf("set state-policy floating\n");
					break;
				case PFRULE_IFBOUND:
					printf("set state-policy if-bound\n");
					break;
				case PFRULE_GRBOUND:
					printf("set state-policy "
					    "group-bound\n");
					break;
				}
			default_statelock = $3;
		}
		| SET DEBUG STRING {
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($3);
				YYERROR;
			}
			if (pfctl_set_debug(pf, $3) != 0) {
				yyerror("error setting debuglevel %s", $3);
				free($3);
				YYERROR;
			}
			free($3);
		}
		;

string		: string STRING				{
			if (asprintf(&$$, "%s %s", $1, $2) == -1)
				err(1, "string: asprintf");
			free($1);
			free($2);
		}
		| STRING
		;

varset		: STRING '=' string		{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("%s = \"%s\"\n", $1, $3);
			if (symset($1, $3, 0) == -1)
				err(1, "cannot store variable %s", $1);
			free($1);
			free($3);
		}
		;

anchorrule	: ANCHOR string	dir interface af proto fromto filter_opts {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_FILTER)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.direction = $3;
			r.af = $5;
			r.prob = $8.prob;

			if ($8.match_tag)
				if (strlcpy(r.match_tagname, $8.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $8.match_tag_not;

			decide_address_family($7.src.host, &r.af);
			decide_address_family($7.dst.host, &r.af);

			expand_rule(&r, $4, NULL, $6, $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
			    0, 0, 0, $2);
			free($2);
		}
		| NATANCHOR string interface af proto fromto {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.action = PF_NAT;
			r.af = $4;

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			expand_rule(&r, $3, NULL, $5, $6.src_os,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
			    0, 0, 0, $2);
			free($2);
		}
		| RDRANCHOR string interface af proto fromto {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.action = PF_RDR;
			r.af = $4;

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			if ($6.src.port != NULL) {
				yyerror("source port parameter not supported"
				    " in rdr-anchor");
				YYERROR;
			}
			if ($6.dst.port != NULL) {
				if ($6.dst.port->next != NULL) {
					yyerror("destination port list "
					    "expansion not supported in "
					    "rdr-anchor");
					YYERROR;
				} else if ($6.dst.port->op != PF_OP_EQ) {
					yyerror("destination port operators"
					    " not supported in rdr-anchor");
					YYERROR;
				}
				r.dst.port[0] = $6.dst.port->port[0];
				r.dst.port[1] = $6.dst.port->port[1];
				r.dst.port_op = $6.dst.port->op;
			}

			expand_rule(&r, $3, NULL, $5, $6.src_os,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
			    0, 0, 0, $2);
			free($2);
		}
		| BINATANCHOR string interface af proto fromto {
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT)) {
				free($2);
				YYERROR;
			}

			memset(&r, 0, sizeof(r));
			r.action = PF_BINAT;
			r.af = $4;
			if ($5 != NULL) {
				if ($5->next != NULL) {
					yyerror("proto list expansion"
					    " not supported in binat-anchor");
					YYERROR;
				}
				r.proto = $5->proto;
				free($5);
			}

			if ($6.src.host != NULL || $6.src.port != NULL ||
			    $6.dst.host != NULL || $6.dst.port != NULL) {
				yyerror("fromto parameter not supported"
				    " in binat-anchor");
				YYERROR;
			}

			decide_address_family($6.src.host, &r.af);
			decide_address_family($6.dst.host, &r.af);

			pfctl_add_rule(pf, &r, $2);
			free($2);
		}
		;

loadrule	: LOAD ANCHOR string FROM string	{
			struct loadanchors	*loadanchor;

			if (strlen($3) >= MAXPATHLEN) {
				yyerror("anchorname %s too long, max %u\n",
				    $3, MAXPATHLEN - 1);
				free($3);
				YYERROR;
			}
			loadanchor = calloc(1, sizeof(struct loadanchors));
			if (loadanchor == NULL)
				err(1, "loadrule: calloc");
			if ((loadanchor->anchorname = strdup($3)) == NULL)
				err(1, "loadrule: strdup");
			if ((loadanchor->filename = strdup($5)) == NULL)
				err(1, "loadrule: strdup");

			TAILQ_INSERT_TAIL(&loadanchorshead, loadanchor,
			    entries);

			free($3);
			free($5);
		};

scrubaction	: no SCRUB {
			$$.b2 = $$.w = 0;
			if ($1)
				$$.b1 = PF_NOSCRUB;
			else
				$$.b1 = PF_SCRUB;
		}
		;

scrubrule	: scrubaction dir logquick interface af proto fromto scrub_opts
		{
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_SCRUB))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			r.direction = $2;

			r.log = $3.log;
			if ($3.quick) {
				yyerror("scrub rules do not support 'quick'");
				YYERROR;
			}

			r.af = $5;
			if ($8.nodf)
				r.rule_flag |= PFRULE_NODF;
			if ($8.randomid)
				r.rule_flag |= PFRULE_RANDOMID;
			if ($8.reassemble_tcp) {
				if (r.direction != PF_INOUT) {
					yyerror("reassemble tcp rules can not "
					    "specify direction");
					YYERROR;
				}
				r.rule_flag |= PFRULE_REASSEMBLE_TCP;
			}
			if ($8.minttl)
				r.min_ttl = $8.minttl;
			if ($8.maxmss)
				r.max_mss = $8.maxmss;
			if ($8.fragcache)
				r.rule_flag |= $8.fragcache;

			expand_rule(&r, $4, NULL, $6, $7.src_os,
			    $7.src.host, $7.src.port, $7.dst.host, $7.dst.port,
			    NULL, NULL, NULL, "");
		}
		;

scrub_opts	:	{
			bzero(&scrub_opts, sizeof scrub_opts);
		}
		    scrub_opts_l
			{ $$ = scrub_opts; }
		| /* empty */ {
			bzero(&scrub_opts, sizeof scrub_opts);
			$$ = scrub_opts;
		}
		;

scrub_opts_l	: scrub_opts_l scrub_opt
		| scrub_opt
		;

scrub_opt	: NODF	{
			if (scrub_opts.nodf) {
				yyerror("no-df cannot be respecified");
				YYERROR;
			}
			scrub_opts.nodf = 1;
		}
		| MINTTL number {
			if (scrub_opts.marker & SOM_MINTTL) {
				yyerror("min-ttl cannot be respecified");
				YYERROR;
			}
			if ($2 > 255) {
				yyerror("illegal min-ttl value %d", $2);
				YYERROR;
			}
			scrub_opts.marker |= SOM_MINTTL;
			scrub_opts.minttl = $2;
		}
		| MAXMSS number {
			if (scrub_opts.marker & SOM_MAXMSS) {
				yyerror("max-mss cannot be respecified");
				YYERROR;
			}
			if ($2 > 65535) {
				yyerror("illegal max-mss value %d", $2);
				YYERROR;
			}
			scrub_opts.marker |= SOM_MAXMSS;
			scrub_opts.maxmss = $2;
		}
		| fragcache {
			if (scrub_opts.marker & SOM_FRAGCACHE) {
				yyerror("fragcache cannot be respecified");
				YYERROR;
			}
			scrub_opts.marker |= SOM_FRAGCACHE;
			scrub_opts.fragcache = $1;
		}
		| REASSEMBLE STRING {
			if (strcasecmp($2, "tcp") != 0) {
				free($2);
				YYERROR;
			}
			free($2);
			if (scrub_opts.reassemble_tcp) {
				yyerror("reassemble tcp cannot be respecified");
				YYERROR;
			}
			scrub_opts.reassemble_tcp = 1;
		}
		| RANDOMID {
			if (scrub_opts.randomid) {
				yyerror("random-id cannot be respecified");
				YYERROR;
			}
			scrub_opts.randomid = 1;
		}
		;

fragcache	: FRAGMENT REASSEMBLE	{ $$ = 0; /* default */ }
		| FRAGMENT FRAGCROP	{ $$ = PFRULE_FRAGCROP; }
		| FRAGMENT FRAGDROP	{ $$ = PFRULE_FRAGDROP; }
		;

antispoof	: ANTISPOOF logquick antispoof_ifspc af antispoof_opts {
			struct pf_rule		 r;
			struct node_host	*h = NULL, *hh;
			struct node_if		*i, *j;

			if (check_rulestate(PFCTL_STATE_FILTER))
				YYERROR;

			for (i = $3; i; i = i->next) {
				bzero(&r, sizeof(r));

				r.action = PF_DROP;
				r.direction = PF_IN;
				r.log = $2.log;
				r.quick = $2.quick;
				r.af = $4;
				if (rule_label(&r, $5.label))
					YYERROR;
				j = calloc(1, sizeof(struct node_if));
				if (j == NULL)
					err(1, "antispoof: calloc");
				if (strlcpy(j->ifname, i->ifname,
				    sizeof(j->ifname)) >= sizeof(j->ifname)) {
					free(j);
					yyerror("interface name too long");
					YYERROR;
				}
				j->not = 1;
				if (i->dynamic) {
					h = calloc(1, sizeof(*h));
					if (h == NULL)
						err(1, "address: calloc");
					h->addr.type = PF_ADDR_DYNIFTL;
					set_ipmask(h, 128);
					if (strlcpy(h->addr.v.ifname, i->ifname,
					    sizeof(h->addr.v.ifname)) >=
					    sizeof(h->addr.v.ifname)) {
						yyerror(
						    "interface name too long");
						YYERROR;
					}
					hh = malloc(sizeof(*hh));
					if (hh == NULL)
						 err(1, "address: malloc");
					bcopy(h, hh, sizeof(*hh));
					h->addr.iflags = PFI_AFLAG_NETWORK;
				} else {
					h = ifa_lookup(j->ifname,
					    PFI_AFLAG_NETWORK);
					hh = NULL;
				}

				if (h != NULL)
					expand_rule(&r, j, NULL, NULL, NULL, h,
					    NULL, NULL, NULL, NULL, NULL,
					    NULL, "");

				if ((i->ifa_flags & IFF_LOOPBACK) == 0) {
					bzero(&r, sizeof(r));

					r.action = PF_DROP;
					r.direction = PF_IN;
					r.log = $2.log;
					r.quick = $2.quick;
					r.af = $4;
					if (rule_label(&r, $5.label))
						YYERROR;
					if (hh != NULL)
						h = hh;
					else
						h = ifa_lookup(i->ifname, 0);
					if (h != NULL)
						expand_rule(&r, NULL, NULL,
						    NULL, NULL, h, NULL, NULL,
						    NULL, NULL, NULL, NULL, "");
				} else
					free(hh);
			}
			free($5.label);
		}
		;

antispoof_ifspc	: FOR antispoof_if		{ $$ = $2; }
		| FOR '{' antispoof_iflst '}'	{ $$ = $3; }
		;

antispoof_iflst	: antispoof_if				{ $$ = $1; }
		| antispoof_iflst comma antispoof_if	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

antispoof_if  : if_item				{ $$ = $1; }
		| '(' if_item ')'		{
			$2->dynamic = 1;
			$$ = $2;
		}
		;

antispoof_opts	:	{ bzero(&antispoof_opts, sizeof antispoof_opts); }
		    antispoof_opts_l
			{ $$ = antispoof_opts; }
		| /* empty */	{
			bzero(&antispoof_opts, sizeof antispoof_opts);
			$$ = antispoof_opts;
		}
		;

antispoof_opts_l	: antispoof_opts_l antispoof_opt
			| antispoof_opt
			;

antispoof_opt	: label	{
			if (antispoof_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			antispoof_opts.label = $1;
		}
		;

not		: '!'		{ $$ = 1; }
		| /* empty */	{ $$ = 0; }
		;

tabledef	: TABLE '<' STRING '>' table_opts {
			struct node_host	 *h, *nh;
			struct node_tinit	 *ti, *nti;

			if (strlen($3) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name too long, max %d chars",
				    PF_TABLE_NAME_SIZE - 1);
				free($3);
				YYERROR;
			}
			if (pf->loadopt & PFCTL_FLAG_TABLE)
				if (process_tabledef($3, &$5)) {
					free($3);
					YYERROR;
				}
			free($3);
			for (ti = SIMPLEQ_FIRST(&$5.init_nodes);
			    ti != SIMPLEQ_END(&$5.init_nodes); ti = nti) {
				if (ti->file)
					free(ti->file);
				for (h = ti->host; h != NULL; h = nh) {
					nh = h->next;
					free(h);
				}
				nti = SIMPLEQ_NEXT(ti, entries);
				free(ti);
			}
		}
		;

table_opts	:	{
			bzero(&table_opts, sizeof table_opts);
			SIMPLEQ_INIT(&table_opts.init_nodes);
		}
		    table_opts_l
			{ $$ = table_opts; }
		| /* empty */
			{
			bzero(&table_opts, sizeof table_opts);
			SIMPLEQ_INIT(&table_opts.init_nodes);
			$$ = table_opts;
		}
		;

table_opts_l	: table_opts_l table_opt
		| table_opt
		;

table_opt	: STRING		{
			if (!strcmp($1, "const"))
				table_opts.flags |= PFR_TFLAG_CONST;
			else if (!strcmp($1, "persist"))
				table_opts.flags |= PFR_TFLAG_PERSIST;
			else {
				free($1);
				YYERROR;
			}
			free($1);
		}
		| '{' '}'		{ table_opts.init_addr = 1; }
		| '{' host_list '}'	{
			struct node_host	*n;
			struct node_tinit	*ti;

			for (n = $2; n != NULL; n = n->next) {
				switch (n->addr.type) {
				case PF_ADDR_ADDRMASK:
					continue; /* ok */
				case PF_ADDR_DYNIFTL:
					yyerror("dynamic addresses are not "
					    "permitted inside tables");
					break;
				case PF_ADDR_TABLE:
					yyerror("tables cannot contain tables");
					break;
				case PF_ADDR_NOROUTE:
					yyerror("\"no-route\" is not permitted "
					    "inside tables");
					break;
				default:
					yyerror("unknown address type %d",
					    n->addr.type);
				}
				YYERROR;
			}
			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->host = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
		}
		| FILENAME STRING	{
			struct node_tinit	*ti;

			if (!(ti = calloc(1, sizeof(*ti))))
				err(1, "table_opt: calloc");
			ti->file = $2;
			SIMPLEQ_INSERT_TAIL(&table_opts.init_nodes, ti,
			    entries);
			table_opts.init_addr = 1;
		}
		;

altqif		: ALTQ interface queue_opts QUEUE qassign {
			struct pf_altq	a;

			if (check_rulestate(PFCTL_STATE_QUEUE))
				YYERROR;

			memset(&a, 0, sizeof(a));
			if ($3.scheduler.qtype == ALTQT_NONE) {
				yyerror("no scheduler specified!");
				YYERROR;
			}
			a.scheduler = $3.scheduler.qtype;
			a.qlimit = $3.qlimit;
			a.tbrsize = $3.tbrsize;
			if ($5 == NULL) {
				yyerror("no child queues specified");
				YYERROR;
			}
			if (expand_altq(&a, $2, $5, $3.queue_bwspec,
			    &$3.scheduler))
				YYERROR;
		}
		;

queuespec	: QUEUE STRING interface queue_opts qassign {
			struct pf_altq	a;

			if (check_rulestate(PFCTL_STATE_QUEUE)) {
				free($2);
				YYERROR;
			}

			memset(&a, 0, sizeof(a));

			if (strlcpy(a.qname, $2, sizeof(a.qname)) >=
			    sizeof(a.qname)) {
				yyerror("queue name too long (max "
				    "%d chars)", PF_QNAME_SIZE-1);
				free($2);
				YYERROR;
			}
			free($2);
			if ($4.tbrsize) {
				yyerror("cannot specify tbrsize for queue");
				YYERROR;
			}
			if ($4.priority > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			a.priority = $4.priority;
			a.qlimit = $4.qlimit;
			a.scheduler = $4.scheduler.qtype;
			if (expand_queue(&a, $3, $5, $4.queue_bwspec,
			    &$4.scheduler)) {
				yyerror("errors in queue definition");
				YYERROR;
			}
		}
		;

queue_opts	:	{
			bzero(&queue_opts, sizeof queue_opts);
			queue_opts.priority = DEFAULT_PRIORITY;
			queue_opts.qlimit = DEFAULT_QLIMIT;
			queue_opts.scheduler.qtype = ALTQT_NONE;
			queue_opts.queue_bwspec.bw_percent = 100;
		}
		    queue_opts_l
			{ $$ = queue_opts; }
		| /* empty */ {
			bzero(&queue_opts, sizeof queue_opts);
			queue_opts.priority = DEFAULT_PRIORITY;
			queue_opts.qlimit = DEFAULT_QLIMIT;
			queue_opts.scheduler.qtype = ALTQT_NONE;
			queue_opts.queue_bwspec.bw_percent = 100;
			$$ = queue_opts;
		}
		;

queue_opts_l	: queue_opts_l queue_opt
		| queue_opt
		;

queue_opt	: BANDWIDTH bandwidth	{
			if (queue_opts.marker & QOM_BWSPEC) {
				yyerror("bandwidth cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_BWSPEC;
			queue_opts.queue_bwspec = $2;
		}
		| PRIORITY number	{
			if (queue_opts.marker & QOM_PRIORITY) {
				yyerror("priority cannot be respecified");
				YYERROR;
			}
			if ($2 > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			queue_opts.marker |= QOM_PRIORITY;
			queue_opts.priority = $2;
		}
		| QLIMIT number	{
			if (queue_opts.marker & QOM_QLIMIT) {
				yyerror("qlimit cannot be respecified");
				YYERROR;
			}
			if ($2 > 65535) {
				yyerror("qlimit out of range: max 65535");
				YYERROR;
			}
			queue_opts.marker |= QOM_QLIMIT;
			queue_opts.qlimit = $2;
		}
		| scheduler	{
			if (queue_opts.marker & QOM_SCHEDULER) {
				yyerror("scheduler cannot be respecified");
				YYERROR;
			}
			queue_opts.marker |= QOM_SCHEDULER;
			queue_opts.scheduler = $1;
		}
		| TBRSIZE number	{
			if (queue_opts.marker & QOM_TBRSIZE) {
				yyerror("tbrsize cannot be respecified");
				YYERROR;
			}
			if ($2 > 65535) {
				yyerror("tbrsize too big: max 65535");
				YYERROR;
			}
			queue_opts.marker |= QOM_TBRSIZE;
			queue_opts.tbrsize = $2;
		}
		;

bandwidth	: STRING {
			double	 bps;
			char	*cp;

			$$.bw_percent = 0;

			bps = strtod($1, &cp);
			if (cp != NULL) {
				if (!strcmp(cp, "b"))
					; /* nothing */
				else if (!strcmp(cp, "Kb"))
					bps *= 1000;
				else if (!strcmp(cp, "Mb"))
					bps *= 1000 * 1000;
				else if (!strcmp(cp, "Gb"))
					bps *= 1000 * 1000 * 1000;
				else if (!strcmp(cp, "%")) {
					if (bps < 0 || bps > 100) {
						yyerror("bandwidth spec "
						    "out of range");
						free($1);
						YYERROR;
					}
					$$.bw_percent = bps;
					bps = 0;
				} else {
					yyerror("unknown unit %s", cp);
					free($1);
					YYERROR;
				}
			}
			free($1);
			$$.bw_absolute = (u_int32_t)bps;
		}
		;

scheduler	: CBQ				{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = 0;
		}
		| CBQ '(' cbqflags_list ')'	{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = $3;
		}
		| PRIQ				{
			$$.qtype = ALTQT_PRIQ;
			$$.data.priq_opts.flags = 0;
		}
		| PRIQ '(' priqflags_list ')'	{
			$$.qtype = ALTQT_PRIQ;
			$$.data.priq_opts.flags = $3;
		}
		| HFSC				{
			$$.qtype = ALTQT_HFSC;
			bzero(&$$.data.hfsc_opts,
			    sizeof(struct node_hfsc_opts));
		}
		| HFSC '(' hfsc_opts ')'	{
			$$.qtype = ALTQT_HFSC;
			$$.data.hfsc_opts = $3;
		}
		;

cbqflags_list	: cbqflags_item				{ $$ |= $1; }
		| cbqflags_list comma cbqflags_item	{ $$ |= $3; }
		;

cbqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = CBQCLF_DEFCLASS;
			else if (!strcmp($1, "borrow"))
				$$ = CBQCLF_BORROW;
			else if (!strcmp($1, "red"))
				$$ = CBQCLF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = CBQCLF_RED|CBQCLF_ECN;
			else if (!strcmp($1, "rio"))
				$$ = CBQCLF_RIO;
			else {
				yyerror("unknown cbq flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

priqflags_list	: priqflags_item			{ $$ |= $1; }
		| priqflags_list comma priqflags_item	{ $$ |= $3; }
		;

priqflags_item	: STRING	{
			if (!strcmp($1, "default"))
				$$ = PRCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
				$$ = PRCF_RED;
			else if (!strcmp($1, "ecn"))
				$$ = PRCF_RED|PRCF_ECN;
			else if (!strcmp($1, "rio"))
				$$ = PRCF_RIO;
			else {
				yyerror("unknown priq flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

hfsc_opts	:	{
				bzero(&hfsc_opts,
				    sizeof(struct node_hfsc_opts));
			}
		    hfscopts_list				{
			$$ = hfsc_opts;
		}
		;

hfscopts_list	: hfscopts_item
		| hfscopts_list comma hfscopts_item
		;

hfscopts_item	: LINKSHARE bandwidth				{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m2 = $2;
			hfsc_opts.linkshare.used = 1;
		}
		| LINKSHARE '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.linkshare.used) {
				yyerror("linkshare already specified");
				YYERROR;
			}
			hfsc_opts.linkshare.m1 = $3;
			hfsc_opts.linkshare.d = $4;
			hfsc_opts.linkshare.m2 = $5;
			hfsc_opts.linkshare.used = 1;
		}
		| REALTIME bandwidth				{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m2 = $2;
			hfsc_opts.realtime.used = 1;
		}
		| REALTIME '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.realtime.used) {
				yyerror("realtime already specified");
				YYERROR;
			}
			hfsc_opts.realtime.m1 = $3;
			hfsc_opts.realtime.d = $4;
			hfsc_opts.realtime.m2 = $5;
			hfsc_opts.realtime.used = 1;
		}
		| UPPERLIMIT bandwidth				{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m2 = $2;
			hfsc_opts.upperlimit.used = 1;
		}
		| UPPERLIMIT '(' bandwidth number bandwidth ')'	{
			if (hfsc_opts.upperlimit.used) {
				yyerror("upperlimit already specified");
				YYERROR;
			}
			hfsc_opts.upperlimit.m1 = $3;
			hfsc_opts.upperlimit.d = $4;
			hfsc_opts.upperlimit.m2 = $5;
			hfsc_opts.upperlimit.used = 1;
		}
		| STRING	{
			if (!strcmp($1, "default"))
				hfsc_opts.flags |= HFCF_DEFAULTCLASS;
			else if (!strcmp($1, "red"))
				hfsc_opts.flags |= HFCF_RED;
			else if (!strcmp($1, "ecn"))
				hfsc_opts.flags |= HFCF_RED|HFCF_ECN;
			else if (!strcmp($1, "rio"))
				hfsc_opts.flags |= HFCF_RIO;
			else {
				yyerror("unknown hfsc flag \"%s\"", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

qassign		: /* empty */		{ $$ = NULL; }
		| qassign_item		{ $$ = $1; }
		| '{' qassign_list '}'	{ $$ = $2; }
		;

qassign_list	: qassign_item			{ $$ = $1; }
		| qassign_list comma qassign_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

qassign_item	: STRING			{
			$$ = calloc(1, sizeof(struct node_queue));
			if ($$ == NULL)
				err(1, "qassign_item: calloc");
			if (strlcpy($$->queue, $1, sizeof($$->queue)) >=
			    sizeof($$->queue)) {
				yyerror("queue name '%s' too long (max "
				    "%d chars)", $1, sizeof($$->queue)-1);
				free($1);
				free($$);
				YYERROR;
			}
			free($1);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

pfrule		: action dir logquick interface route af proto fromto
		    filter_opts
		{
			struct pf_rule		 r;
			struct node_state_opt	*o;
			struct node_proto	*proto;
			int			 srctrack = 0;
			int			 statelock = 0;

			if (check_rulestate(PFCTL_STATE_FILTER))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			switch ($1.b2) {
			case PFRULE_RETURNRST:
				r.rule_flag |= PFRULE_RETURNRST;
				r.return_ttl = $1.w;
				break;
			case PFRULE_RETURNICMP:
				r.rule_flag |= PFRULE_RETURNICMP;
				r.return_icmp = $1.w;
				r.return_icmp6 = $1.w2;
				break;
			case PFRULE_RETURN:
				r.rule_flag |= PFRULE_RETURN;
				r.return_icmp = $1.w;
				r.return_icmp6 = $1.w2;
				break;
			}
			r.direction = $2;
			r.log = $3.log;
			r.quick = $3.quick;
			r.prob = $9.prob;

			r.af = $6;
			if ($9.tag)
				if (strlcpy(r.tagname, $9.tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			if ($9.match_tag)
				if (strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}
			r.match_tag_not = $9.match_tag_not;
			r.flags = $9.flags.b1;
			r.flagset = $9.flags.b2;
			if (rule_label(&r, $9.label))
				YYERROR;
			free($9.label);
			if ($9.flags.b1 || $9.flags.b2 || $8.src_os) {
				for (proto = $7; proto != NULL &&
				    proto->proto != IPPROTO_TCP;
				    proto = proto->next)
					;	/* nothing */
				if (proto == NULL && $7 != NULL) {
					if ($9.flags.b1 || $9.flags.b2)
						yyerror(
						    "flags only apply to tcp");
					if ($8.src_os)
						yyerror(
						    "OS fingerprinting only "
						    "apply to tcp");
					YYERROR;
				}
#if 0
				if (($9.flags.b1 & parse_flags("S")) == 0 &&
				    $8.src_os) {
					yyerror("OS fingerprinting requires "
					    "the SYN TCP flag (flags S/SA)");
					YYERROR;
				}
#endif
			}

			r.tos = $9.tos;
			r.keep_state = $9.keep.action;
			o = $9.keep.options;
			while (o) {
				struct node_state_opt	*p = o;

				switch (o->type) {
				case PF_STATE_OPT_MAX:
					if (r.max_states) {
						yyerror("state option 'max' "
						    "multiple definitions");
						YYERROR;
					}
					r.max_states = o->data.max_states;
					break;
				case PF_STATE_OPT_NOSYNC:
					if (r.rule_flag & PFRULE_NOSYNC) {
						yyerror("state option 'sync' "
						    "multiple definitions");
						YYERROR;
					}
					r.rule_flag |= PFRULE_NOSYNC;
					break;
				case PF_STATE_OPT_SRCTRACK:
					if (srctrack) {
						yyerror("state option "
						    "'source-track' "
						    "multiple definitions");
						YYERROR;
					}
					srctrack =  o->data.src_track;
					break;
				case PF_STATE_OPT_MAX_SRC_STATES:
					if (r.max_src_states) {
						yyerror("state option "
						    "'max-src-states' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_states == 0) {
						yyerror("'max-src-states' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_states =
					    o->data.max_src_states;
					r.rule_flag |= PFRULE_SRCTRACK;
					break;
				case PF_STATE_OPT_OVERLOAD:
					if (r.overload_tblname[0]) {
						yyerror("multiple 'overload' "
						    "table definitions");
						YYERROR;
					}
					if (strlcpy(r.overload_tblname,
					    o->data.overload.tblname,
					    PF_TABLE_NAME_SIZE) >=
					    PF_TABLE_NAME_SIZE) {
						yyerror("state option: "
						    "strlcpy");
						YYERROR;
					}
					r.flush = o->data.overload.flush;
					break;
				case PF_STATE_OPT_MAX_SRC_CONN:
					if (r.max_src_conn) {
						yyerror("state option "
						    "'max-src-conn' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_conn == 0) {
						yyerror("'max-src-conn' "
						    "must be > 0");
						YYERROR;
					}
					r.max_src_conn =
					    o->data.max_src_conn;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_CONN_RATE:
					if (r.max_src_conn_rate.limit) {
						yyerror("state option "
						    "'max-src-conn-rate' "
						    "multiple definitions");
						YYERROR;
					}
					if (!o->data.max_src_conn_rate.limit ||
					    !o->data.max_src_conn_rate.seconds) {
						yyerror("'max-src-conn-rate' "
						    "values must be > 0");
						YYERROR;
					}
					if (o->data.max_src_conn_rate.limit >
					    PF_THRESHOLD_MAX) {
						yyerror("'max-src-conn-rate' "
						   "maximum rate must be < %u",
						   PF_THRESHOLD_MAX);
						YYERROR;
					}
					r.max_src_conn_rate.limit =
					    o->data.max_src_conn_rate.limit;
					r.max_src_conn_rate.seconds =
					    o->data.max_src_conn_rate.seconds;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_MAX_SRC_NODES:
					if (r.max_src_nodes) {
						yyerror("state option "
						    "'max-src-nodes' "
						    "multiple definitions");
						YYERROR;
					}
					if (o->data.max_src_nodes == 0) {
						yyerror("'max-src-nodes' must "
						    "be > 0");
						YYERROR;
					}
					r.max_src_nodes =
					    o->data.max_src_nodes;
					r.rule_flag |= PFRULE_SRCTRACK |
					    PFRULE_RULESRCTRACK;
					break;
				case PF_STATE_OPT_STATELOCK:
					if (statelock) {
						yyerror("state locking option: "
						    "multiple definitions");
						YYERROR;
					}
					statelock = 1;
					r.rule_flag |= o->data.statelock;
					break;
				case PF_STATE_OPT_TIMEOUT:
					if (r.timeout[o->data.timeout.number]) {
						yyerror("state timeout %s "
						    "multiple definitions",
						    pf_timeouts[o->data.
						    timeout.number].name);
						YYERROR;
					}
					r.timeout[o->data.timeout.number] =
					    o->data.timeout.seconds;
				}
				o = o->next;
				free(p);
			}
			if (r.rule_flag & PFRULE_SRCTRACK) {
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_nodes) {
					yyerror("'max-src-nodes' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_nodes) {
					yyerror("'max-src-conn' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				if (srctrack == PF_SRCTRACK_GLOBAL &&
				    r.max_src_nodes) {
					yyerror("'max-src-conn-rate' is "
					    "incompatible with "
					    "'source-track global'");
					YYERROR;
				}
				if (r.timeout[PFTM_SRC_NODE] <
				    r.max_src_conn_rate.seconds)
					r.timeout[PFTM_SRC_NODE] = 
					    r.max_src_conn_rate.seconds;
				r.rule_flag |= PFRULE_SRCTRACK;
				if (srctrack == PF_SRCTRACK_RULE)
					r.rule_flag |= PFRULE_RULESRCTRACK;
			}
			if (r.keep_state && !statelock)
				r.rule_flag |= default_statelock;

			if ($9.fragment)
				r.rule_flag |= PFRULE_FRAGMENT;
			r.allow_opts = $9.allowopts;

			decide_address_family($8.src.host, &r.af);
			decide_address_family($8.dst.host, &r.af);

			if ($5.rt) {
				if (!r.direction) {
					yyerror("direction must be explicit "
					    "with rules that specify routing");
					YYERROR;
				}
				r.rt = $5.rt;
				r.rpool.opts = $5.pool_opts;
				if ($5.key != NULL)
					memcpy(&r.rpool.key, $5.key,
					    sizeof(struct pf_poolhashkey));
			}
			if (r.rt && r.rt != PF_FASTROUTE) {
				decide_address_family($5.host, &r.af);
				remove_invalid_hosts(&$5.host, &r.af);
				if ($5.host == NULL) {
					yyerror("no routing address with "
					    "matching address family found.");
					YYERROR;
				}
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($5.host->next != NULL ||
				    $5.host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($5.host->addr)))
					r.rpool.opts |= PF_POOL_ROUNDROBIN;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($5.host, "tables are only "
				    "supported in round-robin routing pools"))
					YYERROR;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($5.host, "interface (%s) "
				    "is only supported in round-robin "
				    "routing pools"))
					YYERROR;
				if ($5.host->next != NULL) {
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) {
						yyerror("r.rpool.opts must "
						    "be PF_POOL_ROUNDROBIN");
						YYERROR;
					}
				}
			}
			if ($9.queues.qname != NULL) {
				if (strlcpy(r.qname, $9.queues.qname,
				    sizeof(r.qname)) >= sizeof(r.qname)) {
					yyerror("rule qname too long (max "
					    "%d chars)", sizeof(r.qname)-1);
					YYERROR;
				}
				free($9.queues.qname);
			}
			if ($9.queues.pqname != NULL) {
				if (strlcpy(r.pqname, $9.queues.pqname,
				    sizeof(r.pqname)) >= sizeof(r.pqname)) {
					yyerror("rule pqname too long (max "
					    "%d chars)", sizeof(r.pqname)-1);
					YYERROR;
				}
				free($9.queues.pqname);
			}

			expand_rule(&r, $4, $5.host, $7, $8.src_os,
			    $8.src.host, $8.src.port, $8.dst.host, $8.dst.port,
			    $9.uid, $9.gid, $9.icmpspec, "");
		}
		;

filter_opts	:	{ bzero(&filter_opts, sizeof filter_opts); }
		    filter_opts_l
			{ $$ = filter_opts; }
		| /* empty */	{
			bzero(&filter_opts, sizeof filter_opts);
			$$ = filter_opts;
		}
		;

filter_opts_l	: filter_opts_l filter_opt
		| filter_opt
		;

filter_opt	: USER uids {
			if (filter_opts.uid)
				$2->tail->next = filter_opts.uid;
			filter_opts.uid = $2;
		}
		| GROUP gids {
			if (filter_opts.gid)
				$2->tail->next = filter_opts.gid;
			filter_opts.gid = $2;
		}
		| flags {
			if (filter_opts.marker & FOM_FLAGS) {
				yyerror("flags cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_FLAGS;
			filter_opts.flags.b1 |= $1.b1;
			filter_opts.flags.b2 |= $1.b2;
			filter_opts.flags.w |= $1.w;
			filter_opts.flags.w2 |= $1.w2;
		}
		| icmpspec {
			if (filter_opts.marker & FOM_ICMP) {
				yyerror("icmp-type cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_ICMP;
			filter_opts.icmpspec = $1;
		}
		| tos {
			if (filter_opts.marker & FOM_TOS) {
				yyerror("tos cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_TOS;
			filter_opts.tos = $1;
		}
		| keep {
			if (filter_opts.marker & FOM_KEEP) {
				yyerror("modulate or keep cannot be redefined");
				YYERROR;
			}
			filter_opts.marker |= FOM_KEEP;
			filter_opts.keep.action = $1.action;
			filter_opts.keep.options = $1.options;
		}
		| FRAGMENT {
			filter_opts.fragment = 1;
		}
		| ALLOWOPTS {
			filter_opts.allowopts = 1;
		}
		| label	{
			if (filter_opts.label) {
				yyerror("label cannot be redefined");
				YYERROR;
			}
			filter_opts.label = $1;
		}
		| qname	{
			if (filter_opts.queues.qname) {
				yyerror("queue cannot be redefined");
				YYERROR;
			}
			filter_opts.queues = $1;
		}
		| TAG string				{
			filter_opts.tag = $2;
		}
		| not TAGGED string			{
			filter_opts.match_tag = $3;
			filter_opts.match_tag_not = $1;
		}
		| PROBABILITY STRING			{
			char	*e;
			double	 p = strtod($2, &e);

			if (*e == '%') {
				p *= 0.01;
				e++;
			}
			if (*e) {
				yyerror("invalid probability: %s", $2);
				YYERROR;
			}
			p = floor(p * (UINT_MAX+1.0) + 0.5);
			if (p < 1.0 || p >= (UINT_MAX+1.0)) {
				yyerror("invalid probability: %s", $2);
				YYERROR;
			}
			filter_opts.prob = (u_int32_t)p;
			free($2);
		}
		;

action		: PASS			{ $$.b1 = PF_PASS; $$.b2 = $$.w = 0; }
		| BLOCK blockspec	{ $$ = $2; $$.b1 = PF_DROP; }
		;

blockspec	: /* empty */		{
			$$.b2 = blockpolicy;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| DROP			{
			$$.b2 = PFRULE_DROP;
			$$.w = 0;
			$$.w2 = 0;
		}
		| RETURNRST		{
			$$.b2 = PFRULE_RETURNRST;
			$$.w = 0;
			$$.w2 = 0;
		}
		| RETURNRST '(' TTL number ')'	{
			if ($4 > 255) {
				yyerror("illegal ttl value %d", $4);
				YYERROR;
			}
			$$.b2 = PFRULE_RETURNRST;
			$$.w = $4;
			$$.w2 = 0;
		}
		| RETURNICMP		{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP6		{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP '(' STRING ')'	{
			$$.b2 = PFRULE_RETURNICMP;
			if (!($$.w = parseicmpspec($3, AF_INET))) {
				free($3);
				YYERROR;
			}
			free($3);
			$$.w2 = returnicmp6default;
		}
		| RETURNICMP6 '(' STRING ')'	{
			$$.b2 = PFRULE_RETURNICMP;
			$$.w = returnicmpdefault;
			if (!($$.w2 = parseicmpspec($3, AF_INET6))) {
				free($3);
				YYERROR;
			}
			free($3);
		}
		| RETURNICMP '(' STRING comma STRING ')' {
			$$.b2 = PFRULE_RETURNICMP;
			if (!($$.w = parseicmpspec($3, AF_INET)) ||
			    !($$.w2 = parseicmpspec($5, AF_INET6))) {
				free($3);
				free($5);
				YYERROR;
			}
			free($3);
			free($5);
		}
		| RETURN {
			$$.b2 = PFRULE_RETURN;
			$$.w = returnicmpdefault;
			$$.w2 = returnicmp6default;
		}
		;

dir		: /* empty */			{ $$ = 0; }
		| IN				{ $$ = PF_IN; }
		| OUT				{ $$ = PF_OUT; }
		;

logquick	: /* empty */			{ $$.log = 0; $$.quick = 0; }
		| log				{ $$.log = $1; $$.quick = 0; }
		| QUICK				{ $$.log = 0; $$.quick = 1; }
		| log QUICK			{ $$.log = $1; $$.quick = 1; }
		| QUICK log			{ $$.log = $2; $$.quick = 1; }
		;

log		: LOG				{ $$ = 1; }
		| LOGALL			{ $$ = 2; }
		;

interface	: /* empty */			{ $$ = NULL; }
		| ON if_item_not		{ $$ = $2; }
		| ON '{' if_list '}'		{ $$ = $3; }
		;

if_list		: if_item_not			{ $$ = $1; }
		| if_list comma if_item_not	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

if_item_not	: not if_item			{ $$ = $2; $$->not = $1; }
		;

if_item		: STRING			{
			struct node_host	*n;

			$$ = calloc(1, sizeof(struct node_if));
			if ($$ == NULL)
				err(1, "if_item: calloc");
			if (strlcpy($$->ifname, $1, sizeof($$->ifname)) >=
			    sizeof($$->ifname)) {
				free($1);
				free($$);
				yyerror("interface name too long");
				YYERROR;
			}

			if ((n = ifa_exists($1, 1)) != NULL)
				$$->ifa_flags = n->ifa_flags;

			free($1);
			$$->not = 0;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

af		: /* empty */			{ $$ = 0; }
		| INET				{ $$ = AF_INET; }
		| INET6				{ $$ = AF_INET6; }
		;

proto		: /* empty */			{ $$ = NULL; }
		| PROTO proto_item		{ $$ = $2; }
		| PROTO '{' proto_list '}'	{ $$ = $3; }
		;

proto_list	: proto_item			{ $$ = $1; }
		| proto_list comma proto_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

proto_item	: STRING			{
			u_int8_t	pr;
			u_long		ulval;

			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("protocol outside range");
					free($1);
					YYERROR;
				}
				pr = (u_int8_t)ulval;
			} else {
				struct protoent	*p;

				p = getprotobyname($1);
				if (p == NULL) {
					yyerror("unknown protocol %s", $1);
					free($1);
					YYERROR;
				}
				pr = p->p_proto;
			}
			free($1);
			if (pr == 0) {
				yyerror("proto 0 cannot be used");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_proto));
			if ($$ == NULL)
				err(1, "proto_item: calloc");
			$$->proto = pr;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

fromto		: ALL				{
			$$.src.host = NULL;
			$$.src.port = NULL;
			$$.dst.host = NULL;
			$$.dst.port = NULL;
			$$.src_os = NULL;
		}
		| from os to			{
			$$.src = $1;
			$$.src_os = $2;
			$$.dst = $3;
		}
		;

os		: /* empty */			{ $$ = NULL; }
		| OS xos			{ $$ = $2; }
		| OS '{' os_list '}'		{ $$ = $3; }
		;

xos		: STRING {
			$$ = calloc(1, sizeof(struct node_os));
			if ($$ == NULL)
				err(1, "os: calloc");
			$$->os = $1;
			$$->tail = $$;
		}
		;

os_list		: xos				{ $$ = $1; }
		| os_list comma xos		{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

from		: /* empty */			{
			$$.host = NULL;
			$$.port = NULL;
		}
		| FROM ipportspec		{
			$$ = $2;
		}
		;

to		: /* empty */			{
			$$.host = NULL;
			$$.port = NULL;
		}
		| TO ipportspec		{
			$$ = $2;
		}
		;

ipportspec	: ipspec			{
			$$.host = $1;
			$$.port = NULL;
		}
		| ipspec PORT portspec		{
			$$.host = $1;
			$$.port = $3;
		}
		| PORT portspec			{
			$$.host = NULL;
			$$.port = $2;
		}
		;

ipspec		: ANY				{ $$ = NULL; }
		| xhost				{ $$ = $1; }
		| '{' host_list '}'		{ $$ = $2; }
		;

host_list	: xhost				{ $$ = $1; }
		| host_list comma xhost		{
			if ($3 == NULL)
				$$ = $1;
			else if ($1 == NULL)
				$$ = $3;
			else {
				$1->tail->next = $3;
				$1->tail = $3->tail;
				$$ = $1;
			}
		}
		;

xhost		: not host			{
			struct node_host	*n;

			for (n = $2; n != NULL; n = n->next)
				n->not = $1;
			$$ = $2;
		}
		| NOROUTE			{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "xhost: calloc");
			$$->addr.type = PF_ADDR_NOROUTE;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

host		: STRING			{
			if (($$ = host($1)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free($1);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free($1);

		}
		| STRING '/' number		{
			char	*buf;

			if (asprintf(&buf, "%s/%u", $1, $3) == -1)
				err(1, "host: asprintf");
			free($1);
			if (($$ = host(buf)) == NULL)	{
				/* error. "any" is handled elsewhere */
				free(buf);
				yyerror("could not parse host specification");
				YYERROR;
			}
			free(buf);
		}
		| dynaddr
		| dynaddr '/' number		{
			struct node_host	*n;

			$$ = $1;
			for (n = $1; n != NULL; n = n->next)
				set_ipmask(n, $3);
		}
		| '<' STRING '>'	{
			if (strlen($2) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name '%s' too long", $2);
				free($2);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "host: calloc");
			$$->addr.type = PF_ADDR_TABLE;
			if (strlcpy($$->addr.v.tblname, $2,
			    sizeof($$->addr.v.tblname)) >=
			    sizeof($$->addr.v.tblname))
				errx(1, "host: strlcpy");
			free($2);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

number		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				yyerror("%s is not a number", $1);
				free($1);
				YYERROR;
			} else
				$$ = ulval;
			free($1);
		}
		;

dynaddr		: '(' STRING ')'		{
			int	 flags = 0;
			char	*p, *op;

			op = $2;
			while ((p = strrchr($2, ':')) != NULL) {
				if (!strcmp(p+1, "network"))
					flags |= PFI_AFLAG_NETWORK;
				else if (!strcmp(p+1, "broadcast"))
					flags |= PFI_AFLAG_BROADCAST;
				else if (!strcmp(p+1, "peer"))
					flags |= PFI_AFLAG_PEER;
				else if (!strcmp(p+1, "0"))
					flags |= PFI_AFLAG_NOALIAS;
				else {
					yyerror("interface %s has bad modifier",
					    $2);
					free(op);
					YYERROR;
				}
				*p = '\0';
			}
			if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) {
				free(op);
				yyerror("illegal combination of "
				    "interface modifiers");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "address: calloc");
			$$->af = 0;
			set_ipmask($$, 128);
			$$->addr.type = PF_ADDR_DYNIFTL;
			$$->addr.iflags = flags;
			if (strlcpy($$->addr.v.ifname, $2,
			    sizeof($$->addr.v.ifname)) >=
			    sizeof($$->addr.v.ifname)) {
				free(op);
				free($$);
				yyerror("interface name too long");
				YYERROR;
			}
			free(op);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

portspec	: port_item			{ $$ = $1; }
		| '{' port_list '}'		{ $$ = $2; }
		;

port_list	: port_item			{ $$ = $1; }
		| port_list comma port_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

port_item	: port				{
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $1.a;
			$$->port[1] = $1.b;
			if ($1.t)
				$$->op = PF_OP_RRG;
			else
				$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop port		{
			if ($2.t) {
				yyerror("':' cannot be used with an other "
				    "port operator");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $2.a;
			$$->port[1] = $2.b;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| port PORTBINARY port		{
			if ($1.t || $3.t) {
				yyerror("':' cannot be used with an other "
				    "port operator");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_port));
			if ($$ == NULL)
				err(1, "port_item: calloc");
			$$->port[0] = $1.a;
			$$->port[1] = $3.a;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

port		: STRING			{
			char	*p = strchr($1, ':');
			struct servent	*s = NULL;
			u_long		 ulval;

			if (p == NULL) {
				if (atoul($1, &ulval) == 0) {
					if (ulval > 65535) {
						free($1);
						yyerror("illegal port value %d",
						    ulval);
						YYERROR;
					}
					$$.a = htons(ulval);
				} else {
					s = getservbyname($1, "tcp");
					if (s == NULL)
						s = getservbyname($1, "udp");
					if (s == NULL) {
						yyerror("unknown port %s", $1);
						free($1);
						YYERROR;
					}
					$$.a = s->s_port;
				}
				$$.b = 0;
				$$.t = 0;
			} else {
				int port[2];

				*p++ = 0;
				if ((port[0] = getservice($1)) == -1 ||
				    (port[1] = getservice(p)) == -1) {
					free($1);
					YYERROR;
				}
				$$.a = port[0];
				$$.b = port[1];
				$$.t = PF_OP_RRG;
			}
			free($1);
		}
		;

uids		: uid_item			{ $$ = $1; }
		| '{' uid_list '}'		{ $$ = $2; }
		;

uid_list	: uid_item			{ $$ = $1; }
		| uid_list comma uid_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

uid_item	: uid				{
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $1;
			$$->uid[1] = $1;
			$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop uid			{
			if ($2 == UID_MAX && $1 != PF_OP_EQ && $1 != PF_OP_NE) {
				yyerror("user unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $2;
			$$->uid[1] = $2;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| uid PORTBINARY uid		{
			if ($1 == UID_MAX || $3 == UID_MAX) {
				yyerror("user unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_uid));
			if ($$ == NULL)
				err(1, "uid_item: calloc");
			$$->uid[0] = $1;
			$$->uid[1] = $3;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

uid		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				if (!strcmp($1, "unknown"))
					$$ = UID_MAX;
				else {
					struct passwd	*pw;

					if ((pw = getpwnam($1)) == NULL) {
						yyerror("unknown user %s", $1);
						free($1);
						YYERROR;
					}
					$$ = pw->pw_uid;
				}
			} else {
				if (ulval >= UID_MAX) {
					free($1);
					yyerror("illegal uid value %lu", ulval);
					YYERROR;
				}
				$$ = ulval;
			}
			free($1);
		}
		;

gids		: gid_item			{ $$ = $1; }
		| '{' gid_list '}'		{ $$ = $2; }
		;

gid_list	: gid_item			{ $$ = $1; }
		| gid_list comma gid_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

gid_item	: gid				{
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $1;
			$$->gid[1] = $1;
			$$->op = PF_OP_EQ;
			$$->next = NULL;
			$$->tail = $$;
		}
		| unaryop gid			{
			if ($2 == GID_MAX && $1 != PF_OP_EQ && $1 != PF_OP_NE) {
				yyerror("group unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $2;
			$$->gid[1] = $2;
			$$->op = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| gid PORTBINARY gid		{
			if ($1 == GID_MAX || $3 == GID_MAX) {
				yyerror("group unknown requires operator = or "
				    "!=");
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_gid));
			if ($$ == NULL)
				err(1, "gid_item: calloc");
			$$->gid[0] = $1;
			$$->gid[1] = $3;
			$$->op = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

gid		: STRING			{
			u_long	ulval;

			if (atoul($1, &ulval) == -1) {
				if (!strcmp($1, "unknown"))
					$$ = GID_MAX;
				else {
					struct group	*grp;

					if ((grp = getgrnam($1)) == NULL) {
						yyerror("unknown group %s", $1);
						free($1);
						YYERROR;
					}
					$$ = grp->gr_gid;
				}
			} else {
				if (ulval >= GID_MAX) {
					yyerror("illegal gid value %lu", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval;
			}
			free($1);
		}
		;

flag		: STRING			{
			int	f;

			if ((f = parse_flags($1)) < 0) {
				yyerror("bad flags %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$.b1 = f;
		}
		;

flags		: FLAGS flag '/' flag	{ $$.b1 = $2.b1; $$.b2 = $4.b1; }
		| FLAGS '/' flag	{ $$.b1 = 0; $$.b2 = $3.b1; }
		;

icmpspec	: ICMPTYPE icmp_item		{ $$ = $2; }
		| ICMPTYPE '{' icmp_list '}'	{ $$ = $3; }
		| ICMP6TYPE icmp6_item		{ $$ = $2; }
		| ICMP6TYPE '{' icmp6_list '}'	{ $$ = $3; }
		;

icmp_list	: icmp_item			{ $$ = $1; }
		| icmp_list comma icmp_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

icmp6_list	: icmp6_item			{ $$ = $1; }
		| icmp6_list comma icmp6_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

icmp_item	: icmptype		{
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = 0;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmptype CODE STRING	{
			const struct icmpcodeent	*p;
			u_long				 ulval;

			if (atoul($3, &ulval) == 0) {
				if (ulval > 255) {
					free($3);
					yyerror("illegal icmp-code %d", ulval);
					YYERROR;
				}
			} else {
				if ((p = geticmpcodebyname($1-1, $3,
				    AF_INET)) == NULL) {
					yyerror("unknown icmp-code %s", $3);
					free($3);
					YYERROR;
				}
				ulval = p->code;
			}
			free($3);
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = ulval + 1;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

icmp6_item	: icmp6type		{
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = 0;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		| icmp6type CODE STRING	{
			const struct icmpcodeent	*p;
			u_long				 ulval;

			if (atoul($3, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp6-code %ld",
					    ulval);
					free($3);
					YYERROR;
				}
			} else {
				if ((p = geticmpcodebyname($1-1, $3,
				    AF_INET6)) == NULL) {
					yyerror("unknown icmp6-code %s", $3);
					free($3);
					YYERROR;
				}
				ulval = p->code;
			}
			free($3);
			$$ = calloc(1, sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: calloc");
			$$->type = $1;
			$$->code = ulval + 1;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

icmptype	: STRING			{
			const struct icmptypeent	*p;
			u_long				 ulval;

			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp-type %d", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval + 1;
			} else {
				if ((p = geticmptypebyname($1, AF_INET)) ==
				    NULL) {
					yyerror("unknown icmp-type %s", $1);
					free($1);
					YYERROR;
				}
				$$ = p->type + 1;
			}
			free($1);
		}
		;

icmp6type	: STRING			{
			const struct icmptypeent	*p;
			u_long				 ulval;

			if (atoul($1, &ulval) == 0) {
				if (ulval > 255) {
					yyerror("illegal icmp6-type %d", ulval);
					free($1);
					YYERROR;
				}
				$$ = ulval + 1;
			} else {
				if ((p = geticmptypebyname($1, AF_INET6)) ==
				    NULL) {
					yyerror("unknown icmp6-type %s", $1);
					free($1);
					YYERROR;
				}
				$$ = p->type + 1;
			}
			free($1);
		}
		;

tos		: TOS STRING			{
			if (!strcmp($2, "lowdelay"))
				$$ = IPTOS_LOWDELAY;
			else if (!strcmp($2, "throughput"))
				$$ = IPTOS_THROUGHPUT;
			else if (!strcmp($2, "reliability"))
				$$ = IPTOS_RELIABILITY;
			else if ($2[0] == '0' && $2[1] == 'x')
				$$ = strtoul($2, NULL, 16);
			else
				$$ = strtoul($2, NULL, 10);
			if (!$$ || $$ > 255) {
				yyerror("illegal tos value %s", $2);
				free($2);
				YYERROR;
			}
			free($2);
		}
		;

sourcetrack	: SOURCETRACK		{ $$ = PF_SRCTRACK; }
		| SOURCETRACK GLOBAL	{ $$ = PF_SRCTRACK_GLOBAL; }
		| SOURCETRACK RULE	{ $$ = PF_SRCTRACK_RULE; }
		;

statelock	: IFBOUND {
			$$ = PFRULE_IFBOUND;
		}
		| GRBOUND {
			$$ = PFRULE_GRBOUND;
		}
		| FLOATING {
			$$ = 0;
		}
		;

keep		: KEEP STATE state_opt_spec	{
			$$.action = PF_STATE_NORMAL;
			$$.options = $3;
		}
		| MODULATE STATE state_opt_spec {
			$$.action = PF_STATE_MODULATE;
			$$.options = $3;
		}
		| SYNPROXY STATE state_opt_spec {
			$$.action = PF_STATE_SYNPROXY;
			$$.options = $3;
		}
		;

flush		: /* empty */			{ $$ = 0; }
		| FLUSH				{ $$ = PF_FLUSH; }
		| FLUSH	GLOBAL			{
			$$ = PF_FLUSH | PF_FLUSH_GLOBAL;
		}
		;

state_opt_spec	: '(' state_opt_list ')'	{ $$ = $2; }
		| /* empty */			{ $$ = NULL; }
		;

state_opt_list	: state_opt_item		{ $$ = $1; }
		| state_opt_list comma state_opt_item {
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

state_opt_item	: MAXIMUM number		{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX;
			$$->data.max_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| NOSYNC				{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_NOSYNC;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCSTATES number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_STATES;
			$$->data.max_src_states = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCCONN number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_CONN;
			$$->data.max_src_conn = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCCONNRATE number '/' number	{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_CONN_RATE;
			$$->data.max_src_conn_rate.limit = $2;
			$$->data.max_src_conn_rate.seconds = $4;
			$$->next = NULL;
			$$->tail = $$;
		}
		| OVERLOAD '<' STRING '>' flush		{
			if (strlen($3) >= PF_TABLE_NAME_SIZE) {
				yyerror("table name '%s' too long", $3);
				free($3);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			if (strlcpy($$->data.overload.tblname, $3,
			    PF_TABLE_NAME_SIZE) >= PF_TABLE_NAME_SIZE)
				errx(1, "state_opt_item: strlcpy");
			free($3);
			$$->type = PF_STATE_OPT_OVERLOAD;
			$$->data.overload.flush = $5;
			$$->next = NULL;
			$$->tail = $$;
		}
		| MAXSRCNODES number			{
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_MAX_SRC_NODES;
			$$->data.max_src_nodes = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		| sourcetrack {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_SRCTRACK;
			$$->data.src_track = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| statelock {
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_STATELOCK;
			$$->data.statelock = $1;
			$$->next = NULL;
			$$->tail = $$;
		}
		| STRING number			{
			int	i;

			for (i = 0; pf_timeouts[i].name &&
			    strcmp(pf_timeouts[i].name, $1); ++i)
				;	/* nothing */
			if (!pf_timeouts[i].name) {
				yyerror("illegal timeout name %s", $1);
				free($1);
				YYERROR;
			}
			if (strchr(pf_timeouts[i].name, '.') == NULL) {
				yyerror("illegal state timeout %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
			$$ = calloc(1, sizeof(struct node_state_opt));
			if ($$ == NULL)
				err(1, "state_opt_item: calloc");
			$$->type = PF_STATE_OPT_TIMEOUT;
			$$->data.timeout.number = pf_timeouts[i].timeout;
			$$->data.timeout.seconds = $2;
			$$->next = NULL;
			$$->tail = $$;
		}
		;

label		: LABEL STRING			{
			$$ = $2;
		}
		;

qname		: QUEUE STRING				{
			$$.qname = $2;
		}
		| QUEUE '(' STRING ')'			{
			$$.qname = $3;
		}
		| QUEUE '(' STRING comma STRING ')'	{
			$$.qname = $3;
			$$.pqname = $5;
		}
		;

no		: /* empty */			{ $$ = 0; }
		| NO				{ $$ = 1; }
		;

rport		: STRING			{
			char	*p = strchr($1, ':');

			if (p == NULL) {
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = $$.t = 0;
			} else if (!strcmp(p+1, "*")) {
				*p = 0;
				if (($$.a = getservice($1)) == -1) {
					free($1);
					YYERROR;
				}
				$$.b = 0;
				$$.t = 1;
			} else {
				*p++ = 0;
				if (($$.a = getservice($1)) == -1 ||
				    ($$.b = getservice(p)) == -1) {
					free($1);
					YYERROR;
				}
				if ($$.a == $$.b)
					$$.b = 0;
				$$.t = 0;
			}
			free($1);
		}
		;

redirspec	: host				{ $$ = $1; }
		| '{' redir_host_list '}'	{ $$ = $2; }
		;

redir_host_list	: host				{ $$ = $1; }
		| redir_host_list comma host	{
			$1->tail->next = $3;
			$1->tail = $3->tail;
			$$ = $1;
		}
		;

redirpool	: /* empty */			{ $$ = NULL; }
		| ARROW redirspec		{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport.a = $$->rport.b = $$->rport.t = 0;
		}
		| ARROW redirspec PORT rport	{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport = $4;
		}
		;

hashkey		: /* empty */
		{
			$$ = calloc(1, sizeof(struct pf_poolhashkey));
			if ($$ == NULL)
				err(1, "hashkey: calloc");
			$$->key32[0] = arc4random();
			$$->key32[1] = arc4random();
			$$->key32[2] = arc4random();
			$$->key32[3] = arc4random();
		}
		| string
		{
			if (!strncmp($1, "0x", 2)) {
				if (strlen($1) != 34) {
					free($1);
					yyerror("hex key must be 128 bits "
						"(32 hex digits) long");
					YYERROR;
				}
				$$ = calloc(1, sizeof(struct pf_poolhashkey));
				if ($$ == NULL)
					err(1, "hashkey: calloc");

				if (sscanf($1, "0x%8x%8x%8x%8x",
				    &$$->key32[0], &$$->key32[1],
				    &$$->key32[2], &$$->key32[3]) != 4) {
					free($$);
					free($1);
					yyerror("invalid hex key");
					YYERROR;
				}
			} else {
				MD5_CTX	context;

				$$ = calloc(1, sizeof(struct pf_poolhashkey));
				if ($$ == NULL)
					err(1, "hashkey: calloc");
				MD5Init(&context);
				MD5Update(&context, (unsigned char *)$1,
				    strlen($1));
				MD5Final((unsigned char *)$$, &context);
				HTONL($$->key32[0]);
				HTONL($$->key32[1]);
				HTONL($$->key32[2]);
				HTONL($$->key32[3]);
			}
			free($1);
		}
		;

pool_opts	:	{ bzero(&pool_opts, sizeof pool_opts); }
		    pool_opts_l
			{ $$ = pool_opts; }
		| /* empty */	{
			bzero(&pool_opts, sizeof pool_opts);
			$$ = pool_opts;
		}
		;

pool_opts_l	: pool_opts_l pool_opt
		| pool_opt
		;

pool_opt	: BITMASK	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type =  PF_POOL_BITMASK;
		}
		| RANDOM	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_RANDOM;
		}
		| SOURCEHASH hashkey {
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_SRCHASH;
			pool_opts.key = $2;
		}
		| ROUNDROBIN	{
			if (pool_opts.type) {
				yyerror("pool type cannot be redefined");
				YYERROR;
			}
			pool_opts.type = PF_POOL_ROUNDROBIN;
		}
		| STATICPORT	{
			if (pool_opts.staticport) {
				yyerror("static-port cannot be redefined");
				YYERROR;
			}
			pool_opts.staticport = 1;
		}
		| STICKYADDRESS	{
			if (filter_opts.marker & POM_STICKYADDRESS) {
				yyerror("sticky-address cannot be redefined");
				YYERROR;
			}
			pool_opts.marker |= POM_STICKYADDRESS;
			pool_opts.opts |= PF_POOL_STICKYADDR;
		}
		;

redirection	: /* empty */			{ $$ = NULL; }
		| ARROW host			{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport.a = $$->rport.b = $$->rport.t = 0;
		}
		| ARROW host PORT rport	{
			$$ = calloc(1, sizeof(struct redirection));
			if ($$ == NULL)
				err(1, "redirection: calloc");
			$$->host = $2;
			$$->rport = $4;
		}
		;

natpass		: /* empty */	{ $$ = 0; }
		| PASS		{ $$ = 1; }
		;

nataction	: no NAT natpass {
			$$.b2 = $$.w = 0;
			if ($1)
				$$.b1 = PF_NONAT;
			else
				$$.b1 = PF_NAT;
			$$.b2 = $3;
		}
		| no RDR natpass {
			$$.b2 = $$.w = 0;
			if ($1)
				$$.b1 = PF_NORDR;
			else
				$$.b1 = PF_RDR;
			$$.b2 = $3;
		}
		;

natrule		: nataction interface af proto fromto tag redirpool pool_opts
		{
			struct pf_rule	r;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;

			memset(&r, 0, sizeof(r));

			r.action = $1.b1;
			r.natpass = $1.b2;
			r.af = $3;

			if (!r.af) {
				if ($5.src.host && $5.src.host->af &&
				    !$5.src.host->ifindex)
					r.af = $5.src.host->af;
				else if ($5.dst.host && $5.dst.host->af &&
				    !$5.dst.host->ifindex)
					r.af = $5.dst.host->af;
			}

			if ($6 != NULL)
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >=
				    PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

			if (r.action == PF_NONAT || r.action == PF_NORDR) {
				if ($7 != NULL) {
					yyerror("translation rule with 'no' "
					    "does not need '->'");
					YYERROR;
				}
			} else {
				if ($7 == NULL || $7->host == NULL) {
					yyerror("translation rule requires '-> "
					    "address'");
					YYERROR;
				}
				if (!r.af && ! $7->host->ifindex)
					r.af = $7->host->af;

				remove_invalid_hosts(&$7->host, &r.af);
				if (invalid_redirect($7->host, r.af))
					YYERROR;
				if (check_netmask($7->host, r.af))
					YYERROR;

				r.rpool.proxy_port[0] = ntohs($7->rport.a);

				switch (r.action) {
				case PF_RDR:
					if (!$7->rport.b && $7->rport.t &&
					    $5.dst.port != NULL) {
						r.rpool.proxy_port[1] =
						    ntohs($7->rport.a) +
						    (ntohs(
						    $5.dst.port->port[1]) -
						    ntohs(
						    $5.dst.port->port[0]));
					} else
						r.rpool.proxy_port[1] =
						    ntohs($7->rport.b);
					break;
				case PF_NAT:
					r.rpool.proxy_port[1] =
					    ntohs($7->rport.b);
					if (!r.rpool.proxy_port[0] &&
					    !r.rpool.proxy_port[1]) {
						r.rpool.proxy_port[0] =
						    PF_NAT_PROXY_PORT_LOW;
						r.rpool.proxy_port[1] =
						    PF_NAT_PROXY_PORT_HIGH;
					} else if (!r.rpool.proxy_port[1])
						r.rpool.proxy_port[1] =
						    r.rpool.proxy_port[0];
					break;
				default:
					break;
				}

				r.rpool.opts = $8.type;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_NONE && ($7->host->next != NULL ||
				    $7->host->addr.type == PF_ADDR_TABLE ||
				    DYNIF_MULTIADDR($7->host->addr)))
					r.rpool.opts = PF_POOL_ROUNDROBIN;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_table($7->host, "tables are only "
				    "supported in round-robin redirection "
				    "pools"))
					YYERROR;
				if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
				    PF_POOL_ROUNDROBIN &&
				    disallow_alias($7->host, "interface (%s) "
				    "is only supported in round-robin "
				    "redirection pools"))
					YYERROR;
				if ($7->host->next != NULL) {
					if ((r.rpool.opts & PF_POOL_TYPEMASK) !=
					    PF_POOL_ROUNDROBIN) {
						yyerror("only round-robin "
						    "valid for multiple "
						    "redirection addresses");
						YYERROR;
					}
				}
			}

			if ($8.key != NULL)
				memcpy(&r.rpool.key, $8.key,
				    sizeof(struct pf_poolhashkey));

			 if ($8.opts)
				r.rpool.opts |= $8.opts;

			if ($8.staticport) {
				if (r.action != PF_NAT) {
					yyerror("the 'static-port' option is "
					    "only valid with nat rules");
					YYERROR;
				}
				if (r.rpool.proxy_port[0] !=
				    PF_NAT_PROXY_PORT_LOW &&
				    r.rpool.proxy_port[1] !=
				    PF_NAT_PROXY_PORT_HIGH) {
					yyerror("the 'static-port' option can't"
					    " be used when specifying a port"
					    " range");
					YYERROR;
				}
				r.rpool.proxy_port[0] = 0;
				r.rpool.proxy_port[1] = 0;
			}

			expand_rule(&r, $2, $7 == NULL ? NULL : $7->host, $4,
			    $5.src_os, $5.src.host, $5.src.port, $5.dst.host,
			    $5.dst.port, 0, 0, 0, "");
			free($7);
		}
		;

binatrule	: no BINAT natpass interface af proto FROM host TO ipspec tag
		    redirection
		{
			struct pf_rule		binat;
			struct pf_pooladdr	*pa;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;

			memset(&binat, 0, sizeof(binat));

			if ($1)
				binat.action = PF_NOBINAT;
			else
				binat.action = PF_BINAT;
			binat.natpass = $3;
			binat.af = $5;
			if (!binat.af && $8 != NULL && $8->af)
				binat.af = $8->af;
			if (!binat.af && $10 != NULL && $10->af)
				binat.af = $10->af;
			if (!binat.af && $12 != NULL && $12->host)
				binat.af = $12->host->af;
			if (!binat.af) {
				yyerror("address family (inet/inet6) "
				    "undefined");
				YYERROR;
			}

			if ($4 != NULL) {
				memcpy(binat.ifname, $4->ifname,
				    sizeof(binat.ifname));
				binat.ifnot = $4->not;
				free($4);
			}
			if ($11 != NULL)
				if (strlcpy(binat.tagname, $11,
				    PF_TAG_NAME_SIZE) >= PF_TAG_NAME_SIZE) {
					yyerror("tag too long, max %u chars",
					    PF_TAG_NAME_SIZE - 1);
					YYERROR;
				}

			if ($6 != NULL) {
				binat.proto = $6->proto;
				free($6);
			}

			if ($8 != NULL && disallow_table($8, "invalid use of "
			    "table <%s> as the source address of a binat rule"))
				YYERROR;
			if ($8 != NULL && disallow_alias($8, "invalid use of "
			    "interface (%s) as the source address of a binat "
			    "rule"))
				YYERROR;
			if ($12 != NULL && $12->host != NULL && disallow_table(
			    $12->host, "invalid use of table <%s> as the "
			    "redirect address of a binat rule"))
				YYERROR;
			if ($12 != NULL && $12->host != NULL && disallow_alias(
			    $12->host, "invalid use of interface (%s) as the "
			    "redirect address of a binat rule"))
				YYERROR;

			if ($8 != NULL) {
				if ($8->next) {
					yyerror("multiple binat ip addresses");
					YYERROR;
				}
				if ($8->addr.type == PF_ADDR_DYNIFTL)
					$8->af = binat.af;
				if ($8->af != binat.af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				if (check_netmask($8, binat.af))
					YYERROR;
				memcpy(&binat.src.addr, &$8->addr,
				    sizeof(binat.src.addr));
				free($8);
			}
			if ($10 != NULL) {
				if ($10->next) {
					yyerror("multiple binat ip addresses");
					YYERROR;
				}
				if ($10->af != binat.af && $10->af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				if (check_netmask($10, binat.af))
					YYERROR;
				memcpy(&binat.dst.addr, &$10->addr,
				    sizeof(binat.dst.addr));
				binat.dst.neg = $10->not;
				free($10);
			}

			if (binat.action == PF_NOBINAT) {
				if ($12 != NULL) {
					yyerror("'no binat' rule does not need"
					    " '->'");
					YYERROR;
				}
			} else {
				if ($12 == NULL || $12->host == NULL) {
					yyerror("'binat' rule requires"
					    " '-> address'");
					YYERROR;
				}

				remove_invalid_hosts(&$12->host, &binat.af);
				if (invalid_redirect($12->host, binat.af))
					YYERROR;
				if ($12->host->next != NULL) {
					yyerror("binat rule must redirect to "
					    "a single address");
					YYERROR;
				}
				if (check_netmask($12->host, binat.af))
					YYERROR;

				if (!PF_AZERO(&binat.src.addr.v.a.mask,
				    binat.af) &&
				    !PF_AEQ(&binat.src.addr.v.a.mask,
				    &$12->host->addr.v.a.mask, binat.af)) {
					yyerror("'binat' source mask and "
					    "redirect mask must be the same");
					YYERROR;
				}

				TAILQ_INIT(&binat.rpool.list);
				pa = calloc(1, sizeof(struct pf_pooladdr));
				if (pa == NULL)
					err(1, "binat: calloc");
				pa->addr = $12->host->addr;
				pa->ifname[0] = 0;
				TAILQ_INSERT_TAIL(&binat.rpool.list,
				    pa, entries);

				free($12);
			}

			pfctl_add_rule(pf, &binat, "");
		}
		;

tag		: /* empty */		{ $$ = NULL; }
		| TAG STRING		{ $$ = $2; }
		;

route_host	: STRING			{
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "route_host: calloc");
			$$->ifname = $1;
			set_ipmask($$, 128);
			$$->next = NULL;
			$$->tail = $$;
		}
		| '(' STRING host ')'		{
			$$ = $3;
			$$->ifname = $2;
		}
		;

route_host_list	: route_host				{ $$ = $1; }
		| route_host_list comma route_host	{
			if ($1->af == 0)
				$1->af = $3->af;
			if ($1->af != $3->af) {
				yyerror("all pool addresses must be in the "
				    "same address family");
				YYERROR;
			}
			$1->tail->next = $3;
			$1->tail = $3->tail;
			$$ = $1;
		}
		;

routespec	: route_host			{ $$ = $1; }
		| '{' route_host_list '}'	{ $$ = $2; }
		;

route		: /* empty */			{
			$$.host = NULL;
			$$.rt = 0;
			$$.pool_opts = 0;
		}
		| FASTROUTE {
			$$.host = NULL;
			$$.rt = PF_FASTROUTE;
			$$.pool_opts = 0;
		}
		| ROUTETO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_ROUTETO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		| REPLYTO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_REPLYTO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		| DUPTO routespec pool_opts {
			$$.host = $2;
			$$.rt = PF_DUPTO;
			$$.pool_opts = $3.type | $3.opts;
			if ($3.key != NULL)
				$$.key = $3.key;
		}
		;

timeout_spec	: STRING number
		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
				YYERROR;
			}
			if (pfctl_set_timeout(pf, $1, $2, 0) != 0) {
				yyerror("unknown timeout %s", $1);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

timeout_list	: timeout_list comma timeout_spec
		| timeout_spec
		;

limit_spec	: STRING number
		{
			if (check_rulestate(PFCTL_STATE_OPTION)) {
				free($1);
				YYERROR;
			}
			if (pfctl_set_limit(pf, $1, $2) != 0) {
				yyerror("unable to set limit %s %u", $1, $2);
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

limit_list	: limit_list comma limit_spec
		| limit_spec
		;

comma		: ','
		| /* empty */
		;

yesno		: NO			{ $$ = 0; }
		| STRING		{
			if (!strcmp($1, "yes"))
				$$ = 1;
			else {
				free($1);
				YYERROR;
			}
			free($1);
		}
		;

unaryop		: '='		{ $$ = PF_OP_EQ; }
		| '!' '='	{ $$ = PF_OP_NE; }
		| '<' '='	{ $$ = PF_OP_LE; }
		| '<'		{ $$ = PF_OP_LT; }
		| '>' '='	{ $$ = PF_OP_GE; }
		| '>'		{ $$ = PF_OP_GT; }
		;

%%

int
yyerror(const char *fmt, ...)
d208 1
a208 11
	va_list		 ap;
	extern char	*infile;

	errors = 1;
	va_start(ap, fmt);
	fprintf(stderr, "%s:%d: ", infile, yylval.lineno);
	vfprintf(stderr, fmt, ap);
	fprintf(stderr, "\n");
	va_end(ap);
	return (0);
}
d210 5
a214 7
int
disallow_table(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (h->addr.type == PF_ADDR_TABLE) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
d216 5
a220 10
	return (0);
}

int
disallow_alias(struct node_host *h, const char *fmt)
{
	for (; h != NULL; h = h->next)
		if (DYNIF_MULTIADDR(h->addr)) {
			yyerror(fmt, h->addr.v.tblname);
			return (1);
a221 27
	return (0);
}

int
rule_consistent(struct pf_rule *r)
{
	int	problems = 0;

	switch (r->action) {
	case PF_PASS:
	case PF_DROP:
	case PF_SCRUB:
	case PF_NOSCRUB:
		problems = filter_consistent(r);
		break;
	case PF_NAT:
	case PF_NONAT:
		problems = nat_consistent(r);
		break;
	case PF_RDR:
	case PF_NORDR:
		problems = rdr_consistent(r);
		break;
	case PF_BINAT:
	case PF_NOBINAT:
	default:
		break;
d223 1
a223 1
	return (problems);
d226 2
a227 2
int
filter_consistent(struct pf_rule *r)
d229 1
a229 1
	int	problems = 0;
d231 5
a235 65
	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP &&
	    (r->src.port_op || r->dst.port_op)) {
		yyerror("port only applies to tcp/udp");
		problems++;
	}
	if (r->proto != IPPROTO_ICMP && r->proto != IPPROTO_ICMPV6 &&
	    (r->type || r->code)) {
		yyerror("icmp-type/code only applies to icmp");
		problems++;
	}
	if (!r->af && (r->type || r->code)) {
		yyerror("must indicate address family with icmp-type/code");
		problems++;
	}
	if ((r->proto == IPPROTO_ICMP && r->af == AF_INET6) ||
	    (r->proto == IPPROTO_ICMPV6 && r->af == AF_INET)) {
		yyerror("proto %s doesn't match address family %s",
		    r->proto == IPPROTO_ICMP ? "icmp" : "icmp6",
		    r->af == AF_INET ? "inet" : "inet6");
		problems++;
	}
	if (r->allow_opts && r->action != PF_PASS) {
		yyerror("allow-opts can only be specified for pass rules");
		problems++;
	}
	if (r->rule_flag & PFRULE_FRAGMENT && (r->src.port_op ||
	    r->dst.port_op || r->flagset || r->type || r->code)) {
		yyerror("fragments can be filtered only on IP header fields");
		problems++;
	}
	if (r->rule_flag & PFRULE_RETURNRST && r->proto != IPPROTO_TCP) {
		yyerror("return-rst can only be applied to TCP rules");
		problems++;
	}
	if (r->max_src_nodes && !(r->rule_flag & PFRULE_RULESRCTRACK)) {
		yyerror("max-src-nodes requires 'source-track rule'");
		problems++;
	}
	if (r->action == PF_DROP && r->keep_state) {
		yyerror("keep state on block rules doesn't make sense");
		problems++;
	}
	if ((r->tagname[0] || r->match_tagname[0]) && !r->keep_state &&
	    r->action == PF_PASS) {
		yyerror("tags cannot be used without keep state");
		problems++;
	}
	return (-problems);
}

int
nat_consistent(struct pf_rule *r)
{
	return (0);	/* yeah! */
}

int
rdr_consistent(struct pf_rule *r)
{
	int			 problems = 0;

	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP) {
		if (r->src.port_op) {
			yyerror("src port only applies to tcp/udp");
			problems++;
d237 5
a241 7
		if (r->dst.port_op) {
			yyerror("dst port only applies to tcp/udp");
			problems++;
		}
		if (r->rpool.proxy_port[0]) {
			yyerror("rpool port only applies to tcp/udp");
			problems++;
d244 1
a244 172
	if (r->dst.port_op &&
	    r->dst.port_op != PF_OP_EQ && r->dst.port_op != PF_OP_RRG) {
		yyerror("invalid port operator for rdr destination port");
		problems++;
	}
	return (-problems);
}

int
process_tabledef(char *name, struct table_opts *opts)
{
	struct pfr_buffer	 ab;
	struct node_tinit	*ti;

	bzero(&ab, sizeof(ab));
	ab.pfrb_type = PFRB_ADDRS;
	SIMPLEQ_FOREACH(ti, &opts->init_nodes, entries) {
		if (ti->file)
			if (pfr_buf_load(&ab, ti->file, 0, append_addr)) {
				if (errno)
					yyerror("cannot load \"%s\": %s",
					    ti->file, strerror(errno));
				else
					yyerror("file \"%s\" contains bad data",
					    ti->file);
				goto _error;
			}
		if (ti->host)
			if (append_addr_host(&ab, ti->host, 0, 0)) {
				yyerror("cannot create address buffer: %s",
				    strerror(errno));
				goto _error;
			}
	}
	if (pf->opts & PF_OPT_VERBOSE)
		print_tabledef(name, opts->flags, opts->init_addr,
		    &opts->init_nodes);
	if (!(pf->opts & PF_OPT_NOACTION) &&
	    pfctl_define_table(name, opts->flags, opts->init_addr,
	    pf->anchor, &ab, pf->tticket)) {
		yyerror("cannot define table %s: %s", name,
		    pfr_strerror(errno));
		goto _error;
	}
	pf->tdirty = 1;
	pfr_buf_clear(&ab);
	return (0);
_error:
	pfr_buf_clear(&ab);
	return (-1);
}

struct keywords {
	const char	*k_name;
	int		 k_val;
};

/* macro gore, but you should've seen the prior indentation nightmare... */

#define FREE_LIST(T,r) \
	do { \
		T *p, *node = r; \
		while (node != NULL) { \
			p = node; \
			node = node->next; \
			free(p); \
		} \
	} while (0)

#define LOOP_THROUGH(T,n,r,C) \
	do { \
		T *n; \
		if (r == NULL) { \
			r = calloc(1, sizeof(T)); \
			if (r == NULL) \
				err(1, "LOOP: calloc"); \
			r->next = NULL; \
		} \
		n = r; \
		while (n != NULL) { \
			do { \
				C; \
			} while (0); \
			n = n->next; \
		} \
	} while (0)

void
expand_label_str(char *label, size_t len, const char *srch, const char *repl)
{
	char *tmp;
	char *p, *q;

	if ((tmp = calloc(1, len)) == NULL)
		err(1, "expand_label_str: calloc");
	p = q = label;
	while ((q = strstr(p, srch)) != NULL) {
		*q = '\0';
		if ((strlcat(tmp, p, len) >= len) ||
		    (strlcat(tmp, repl, len) >= len))
			errx(1, "expand_label: label too long");
		q += strlen(srch);
		p = q;
	}
	if (strlcat(tmp, p, len) >= len)
		errx(1, "expand_label: label too long");
	strlcpy(label, tmp, len);	/* always fits */
	free(tmp);
}

void
expand_label_if(const char *name, char *label, size_t len, const char *ifname)
{
	if (strstr(label, name) != NULL) {
		if (!*ifname)
			expand_label_str(label, len, name, "any");
		else
			expand_label_str(label, len, name, ifname);
	}
}

void
expand_label_addr(const char *name, char *label, size_t len, sa_family_t af,
    struct node_host *h)
{
	char tmp[64], tmp_not[66];

	if (strstr(label, name) != NULL) {
		switch (h->addr.type) {
		case PF_ADDR_DYNIFTL:
			snprintf(tmp, sizeof(tmp), "(%s)", h->addr.v.ifname);
			break;
		case PF_ADDR_TABLE:
			snprintf(tmp, sizeof(tmp), "<%s>", h->addr.v.tblname);
			break;
		case PF_ADDR_NOROUTE:
			snprintf(tmp, sizeof(tmp), "no-route");
			break;
		case PF_ADDR_ADDRMASK:
			if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
			    PF_AZERO(&h->addr.v.a.mask, af)))
				snprintf(tmp, sizeof(tmp), "any");
			else {
				char	a[48];
				int	bits;

				if (inet_ntop(af, &h->addr.v.a.addr, a,
				    sizeof(a)) == NULL)
					snprintf(tmp, sizeof(tmp), "?");
				else {
					bits = unmask(&h->addr.v.a.mask, af);
					if ((af == AF_INET && bits < 32) ||
					    (af == AF_INET6 && bits < 128))
						snprintf(tmp, sizeof(tmp),
						    "%s/%d", a, bits);
					else
						snprintf(tmp, sizeof(tmp),
						    "%s", a);
				}
			}
			break;
		default:
			snprintf(tmp, sizeof(tmp), "?");
			break;
		}

		if (h->not) {
			snprintf(tmp_not, sizeof(tmp_not), "! %s", tmp);
			expand_label_str(label, len, name, tmp_not);
		} else
			expand_label_str(label, len, name, tmp);
	}
d247 2
a248 3
void
expand_label_port(const char *name, char *label, size_t len,
    struct node_port *port)
d250 1
a250 437
	char	 a1[6], a2[6], op[13] = "";

	if (strstr(label, name) != NULL) {
		snprintf(a1, sizeof(a1), "%u", ntohs(port->port[0]));
		snprintf(a2, sizeof(a2), "%u", ntohs(port->port[1]));
		if (!port->op)
			;
		else if (port->op == PF_OP_IRG)
			snprintf(op, sizeof(op), "%s><%s", a1, a2);
		else if (port->op == PF_OP_XRG)
			snprintf(op, sizeof(op), "%s<>%s", a1, a2);
		else if (port->op == PF_OP_EQ)
			snprintf(op, sizeof(op), "%s", a1);
		else if (port->op == PF_OP_NE)
			snprintf(op, sizeof(op), "!=%s", a1);
		else if (port->op == PF_OP_LT)
			snprintf(op, sizeof(op), "<%s", a1);
		else if (port->op == PF_OP_LE)
			snprintf(op, sizeof(op), "<=%s", a1);
		else if (port->op == PF_OP_GT)
			snprintf(op, sizeof(op), ">%s", a1);
		else if (port->op == PF_OP_GE)
			snprintf(op, sizeof(op), ">=%s", a1);
		expand_label_str(label, len, name, op);
	}
}

void
expand_label_proto(const char *name, char *label, size_t len, u_int8_t proto)
{
	struct protoent *pe;
	char n[4];

	if (strstr(label, name) != NULL) {
		pe = getprotobynumber(proto);
		if (pe != NULL)
			expand_label_str(label, len, name, pe->p_name);
		else {
			snprintf(n, sizeof(n), "%u", proto);
			expand_label_str(label, len, name, n);
		}
	}
}

void
expand_label_nr(const char *name, char *label, size_t len)
{
	char n[11];

	if (strstr(label, name) != NULL) {
		snprintf(n, sizeof(n), "%u", pf->rule_nr);
		expand_label_str(label, len, name, n);
	}
}

void
expand_label(char *label, size_t len, const char *ifname, sa_family_t af,
    struct node_host *src_host, struct node_port *src_port,
    struct node_host *dst_host, struct node_port *dst_port,
    u_int8_t proto)
{
	expand_label_if("$if", label, len, ifname);
	expand_label_addr("$srcaddr", label, len, af, src_host);
	expand_label_addr("$dstaddr", label, len, af, dst_host);
	expand_label_port("$srcport", label, len, src_port);
	expand_label_port("$dstport", label, len, dst_port);
	expand_label_proto("$proto", label, len, proto);
	expand_label_nr("$nr", label, len);
}

int
expand_altq(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
{
	struct pf_altq		 pa, pb;
	char			 qname[PF_QNAME_SIZE];
	struct node_queue	*n;
	struct node_queue_bw	 bw;
	int			 errs = 0;

	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
		FREE_LIST(struct node_if, interfaces);
		FREE_LIST(struct node_queue, nqueues);
		return (0);
	}

	LOOP_THROUGH(struct node_if, interface, interfaces,
		memcpy(&pa, a, sizeof(struct pf_altq));
		if (strlcpy(pa.ifname, interface->ifname,
		    sizeof(pa.ifname)) >= sizeof(pa.ifname))
			errx(1, "expand_altq: strlcpy");

		if (interface->not) {
			yyerror("altq on ! <interface> is not supported");
			errs++;
		} else {
			if (eval_pfaltq(pf, &pa, &bwspec, opts))
				errs++;
			else
				if (pfctl_add_altq(pf, &pa))
					errs++;

			if (pf->opts & PF_OPT_VERBOSE) {
				print_altq(&pf->paltq->altq, 0,
				    &bwspec, opts);
				if (nqueues && nqueues->tail) {
					printf("queue { ");
					LOOP_THROUGH(struct node_queue, queue,
					    nqueues,
						printf("%s ",
						    queue->queue);
					);
					printf("}");
				}
				printf("\n");
			}

			if (pa.scheduler == ALTQT_CBQ ||
			    pa.scheduler == ALTQT_HFSC) {
				/* now create a root queue */
				memset(&pb, 0, sizeof(struct pf_altq));
				if (strlcpy(qname, "root_", sizeof(qname)) >=
				    sizeof(qname))
					errx(1, "expand_altq: strlcpy");
				if (strlcat(qname, interface->ifname,
				    sizeof(qname)) >= sizeof(qname))
					errx(1, "expand_altq: strlcat");
				if (strlcpy(pb.qname, qname,
				    sizeof(pb.qname)) >= sizeof(pb.qname))
					errx(1, "expand_altq: strlcpy");
				if (strlcpy(pb.ifname, interface->ifname,
				    sizeof(pb.ifname)) >= sizeof(pb.ifname))
					errx(1, "expand_altq: strlcpy");
				pb.qlimit = pa.qlimit;
				pb.scheduler = pa.scheduler;
				bw.bw_absolute = pa.ifbandwidth;
				bw.bw_percent = 0;
				if (eval_pfqueue(pf, &pb, &bw, opts))
					errs++;
				else
					if (pfctl_add_altq(pf, &pb))
						errs++;
			}

			LOOP_THROUGH(struct node_queue, queue, nqueues,
				n = calloc(1, sizeof(struct node_queue));
				if (n == NULL)
					err(1, "expand_altq: calloc");
				if (pa.scheduler == ALTQT_CBQ ||
				    pa.scheduler == ALTQT_HFSC)
					if (strlcpy(n->parent, qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_altq: strlcpy");
				if (strlcpy(n->queue, queue->queue,
				    sizeof(n->queue)) >= sizeof(n->queue))
					errx(1, "expand_altq: strlcpy");
				if (strlcpy(n->ifname, interface->ifname,
				    sizeof(n->ifname)) >= sizeof(n->ifname))
					errx(1, "expand_altq: strlcpy");
				n->scheduler = pa.scheduler;
				n->next = NULL;
				n->tail = n;
				if (queues == NULL)
					queues = n;
				else {
					queues->tail->next = n;
					queues->tail = n;
				}
			);
		}
	);
	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_queue, nqueues);

	return (errs);
}

int
expand_queue(struct pf_altq *a, struct node_if *interfaces,
    struct node_queue *nqueues, struct node_queue_bw bwspec,
    struct node_queue_opt *opts)
{
	struct node_queue	*n, *nq;
	struct pf_altq		 pa;
	u_int8_t		 found = 0;
	u_int8_t		 errs = 0;

	if ((pf->loadopt & PFCTL_FLAG_ALTQ) == 0) {
		FREE_LIST(struct node_queue, nqueues);
		return (0);
	}

	if (queues == NULL) {
		yyerror("queue %s has no parent", a->qname);
		FREE_LIST(struct node_queue, nqueues);
		return (1);
	}

	LOOP_THROUGH(struct node_if, interface, interfaces,
		LOOP_THROUGH(struct node_queue, tqueue, queues,
			if (!strncmp(a->qname, tqueue->queue, PF_QNAME_SIZE) &&
			    (interface->ifname[0] == 0 ||
			    (!interface->not && !strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)) ||
			    (interface->not && strncmp(interface->ifname,
			    tqueue->ifname, IFNAMSIZ)))) {
				/* found ourself in queues */
				found++;

				memcpy(&pa, a, sizeof(struct pf_altq));

				if (pa.scheduler != ALTQT_NONE &&
				    pa.scheduler != tqueue->scheduler) {
					yyerror("exactly one scheduler type "
					    "per interface allowed");
					return (1);
				}
				pa.scheduler = tqueue->scheduler;

				/* scheduler dependent error checking */
				switch (pa.scheduler) {
				case ALTQT_PRIQ:
					if (nqueues != NULL) {
						yyerror("priq queues cannot "
						    "have child queues");
						return (1);
					}
					if (bwspec.bw_absolute > 0 ||
					    bwspec.bw_percent < 100) {
						yyerror("priq doesn't take "
						    "bandwidth");
						return (1);
					}
					break;
				default:
					break;
				}

				if (strlcpy(pa.ifname, tqueue->ifname,
				    sizeof(pa.ifname)) >= sizeof(pa.ifname))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(pa.parent, tqueue->parent,
				    sizeof(pa.parent)) >= sizeof(pa.parent))
					errx(1, "expand_queue: strlcpy");

				if (eval_pfqueue(pf, &pa, &bwspec, opts))
					errs++;
				else
					if (pfctl_add_altq(pf, &pa))
						errs++;

				for (nq = nqueues; nq != NULL; nq = nq->next) {
					if (!strcmp(a->qname, nq->queue)) {
						yyerror("queue cannot have "
						    "itself as child");
						errs++;
						continue;
					}
					n = calloc(1,
					    sizeof(struct node_queue));
					if (n == NULL)
						err(1, "expand_queue: calloc");
					if (strlcpy(n->parent, a->qname,
					    sizeof(n->parent)) >=
					    sizeof(n->parent))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->queue, nq->queue,
					    sizeof(n->queue)) >=
					    sizeof(n->queue))
						errx(1, "expand_queue strlcpy");
					if (strlcpy(n->ifname, tqueue->ifname,
					    sizeof(n->ifname)) >=
					    sizeof(n->ifname))
						errx(1, "expand_queue strlcpy");
					n->scheduler = tqueue->scheduler;
					n->next = NULL;
					n->tail = n;
					if (queues == NULL)
						queues = n;
					else {
						queues->tail->next = n;
						queues->tail = n;
					}
				}
				if ((pf->opts & PF_OPT_VERBOSE) && (
				    (found == 1 && interface->ifname[0] == 0) ||
				    (found > 0 && interface->ifname[0] != 0))) {
					print_queue(&pf->paltq->altq, 0,
					    &bwspec, interface->ifname[0] != 0,
					    opts);
					if (nqueues && nqueues->tail) {
						printf("{ ");
						LOOP_THROUGH(struct node_queue,
						    queue, nqueues,
							printf("%s ",
							    queue->queue);
						);
						printf("}");
					}
					printf("\n");
				}
			}
		);
	);

	FREE_LIST(struct node_queue, nqueues);
	FREE_LIST(struct node_if, interfaces);

	if (!found) {
		yyerror("queue %s has no parent", a->qname);
		errs++;
	}

	if (errs)
		return (1);
	else
		return (0);
}

void
expand_rule(struct pf_rule *r,
    struct node_if *interfaces, struct node_host *rpool_hosts,
    struct node_proto *protos, struct node_os *src_oses,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_uid *uids, struct node_gid *gids, struct node_icmp *icmp_types,
    const char *anchor_call)
{
	sa_family_t		 af = r->af;
	int			 added = 0, error = 0;
	char			 ifname[IF_NAMESIZE];
	char			 label[PF_RULE_LABEL_SIZE];
	char			 tagname[PF_TAG_NAME_SIZE];
	char			 match_tagname[PF_TAG_NAME_SIZE];
	struct pf_pooladdr	*pa;
	struct node_host	*h;
	u_int8_t		 flags, flagset, keep_state;

	if (strlcpy(label, r->label, sizeof(label)) >= sizeof(label))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(tagname, r->tagname, sizeof(tagname)) >= sizeof(tagname))
		errx(1, "expand_rule: strlcpy");
	if (strlcpy(match_tagname, r->match_tagname, sizeof(match_tagname)) >=
	    sizeof(match_tagname))
		errx(1, "expand_rule: strlcpy");
	flags = r->flags;
	flagset = r->flagset;
	keep_state = r->keep_state;

	LOOP_THROUGH(struct node_if, interface, interfaces,
	LOOP_THROUGH(struct node_proto, proto, protos,
	LOOP_THROUGH(struct node_icmp, icmp_type, icmp_types,
	LOOP_THROUGH(struct node_host, src_host, src_hosts,
	LOOP_THROUGH(struct node_port, src_port, src_ports,
	LOOP_THROUGH(struct node_os, src_os, src_oses,
	LOOP_THROUGH(struct node_host, dst_host, dst_hosts,
	LOOP_THROUGH(struct node_port, dst_port, dst_ports,
	LOOP_THROUGH(struct node_uid, uid, uids,
	LOOP_THROUGH(struct node_gid, gid, gids,

		r->af = af;
		/* for link-local IPv6 address, interface must match up */
		if ((r->af && src_host->af && r->af != src_host->af) ||
		    (r->af && dst_host->af && r->af != dst_host->af) ||
		    (src_host->af && dst_host->af &&
		    src_host->af != dst_host->af) ||
		    (src_host->ifindex && dst_host->ifindex &&
		    src_host->ifindex != dst_host->ifindex) ||
		    (src_host->ifindex && *interface->ifname &&
		    src_host->ifindex != if_nametoindex(interface->ifname)) ||
		    (dst_host->ifindex && *interface->ifname &&
		    dst_host->ifindex != if_nametoindex(interface->ifname)))
			continue;
		if (!r->af && src_host->af)
			r->af = src_host->af;
		else if (!r->af && dst_host->af)
			r->af = dst_host->af;

		if (*interface->ifname)
			strlcpy(r->ifname, interface->ifname,
			    sizeof(r->ifname));
		else if (if_indextoname(src_host->ifindex, ifname))
			strlcpy(r->ifname, ifname, sizeof(r->ifname));
		else if (if_indextoname(dst_host->ifindex, ifname))
			strlcpy(r->ifname, ifname, sizeof(r->ifname));
		else
			memset(r->ifname, '\0', sizeof(r->ifname));

		if (strlcpy(r->label, label, sizeof(r->label)) >=
		    sizeof(r->label))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->tagname, tagname, sizeof(r->tagname)) >=
		    sizeof(r->tagname))
			errx(1, "expand_rule: strlcpy");
		if (strlcpy(r->match_tagname, match_tagname,
		    sizeof(r->match_tagname)) >= sizeof(r->match_tagname))
			errx(1, "expand_rule: strlcpy");
		expand_label(r->label, PF_RULE_LABEL_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->tagname, PF_TAG_NAME_SIZE, r->ifname, r->af,
		    src_host, src_port, dst_host, dst_port, proto->proto);
		expand_label(r->match_tagname, PF_TAG_NAME_SIZE, r->ifname,
		    r->af, src_host, src_port, dst_host, dst_port,
		    proto->proto);

		error += check_netmask(src_host, r->af);
		error += check_netmask(dst_host, r->af);

		r->ifnot = interface->not;
		r->proto = proto->proto;
		r->src.addr = src_host->addr;
		r->src.neg = src_host->not;
		r->src.port[0] = src_port->port[0];
		r->src.port[1] = src_port->port[1];
		r->src.port_op = src_port->op;
		r->dst.addr = dst_host->addr;
		r->dst.neg = dst_host->not;
		r->dst.port[0] = dst_port->port[0];
		r->dst.port[1] = dst_port->port[1];
		r->dst.port_op = dst_port->op;
		r->uid.op = uid->op;
		r->uid.uid[0] = uid->uid[0];
		r->uid.uid[1] = uid->uid[1];
		r->gid.op = gid->op;
		r->gid.gid[0] = gid->gid[0];
		r->gid.gid[1] = gid->gid[1];
		r->type = icmp_type->type;
		r->code = icmp_type->code;

		if ((keep_state == PF_STATE_MODULATE ||
		    keep_state == PF_STATE_SYNPROXY) &&
		    r->proto && r->proto != IPPROTO_TCP)
			r->keep_state = PF_STATE_NORMAL;
		else
			r->keep_state = keep_state;
d252 6
a257 6
		if (r->proto && r->proto != IPPROTO_TCP) {
			r->flags = 0;
			r->flagset = 0;
		} else {
			r->flags = flags;
			r->flagset = flagset;
d259 6
a264 3
		if (icmp_type->proto && r->proto != icmp_type->proto) {
			yyerror("icmp-type mismatch");
			error++;
d266 8
d275 6
a280 9
		if (src_os && src_os->os) {
			r->os_fingerprint = pfctl_get_fingerprint(src_os->os);
			if ((pf->opts & PF_OPT_VERBOSE2) &&
			    r->os_fingerprint == PF_OSFP_NOMATCH)
				fprintf(stderr,
				    "warning: unknown '%s' OS fingerprint\n",
				    src_os->os);
		} else {
			r->os_fingerprint = PF_OSFP_ANY;
d282 6
a287 15

		TAILQ_INIT(&r->rpool.list);
		for (h = rpool_hosts; h != NULL; h = h->next) {
			pa = calloc(1, sizeof(struct pf_pooladdr));
			if (pa == NULL)
				err(1, "expand_rule: calloc");
			pa->addr = h->addr;
			if (h->ifname != NULL) {
				if (strlcpy(pa->ifname, h->ifname,
				    sizeof(pa->ifname)) >=
				    sizeof(pa->ifname))
					errx(1, "expand_rule: strlcpy");
			} else
				pa->ifname[0] = 0;
			TAILQ_INSERT_TAIL(&r->rpool.list, pa, entries);
d289 2
a290 25

		if (rule_consistent(r) < 0 || error)
			yyerror("skipping rule due to errors");
		else {
			r->nr = pf->rule_nr++;
			pfctl_add_rule(pf, r, anchor_call);
			added++;
		}

	))))))))));

	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_proto, protos);
	FREE_LIST(struct node_host, src_hosts);
	FREE_LIST(struct node_port, src_ports);
	FREE_LIST(struct node_os, src_oses);
	FREE_LIST(struct node_host, dst_hosts);
	FREE_LIST(struct node_port, dst_ports);
	FREE_LIST(struct node_uid, uids);
	FREE_LIST(struct node_gid, gids);
	FREE_LIST(struct node_icmp, icmp_types);
	FREE_LIST(struct node_host, rpool_hosts);

	if (!added)
		yyerror("rule expands to no valid combination");
d293 2
a294 5
#undef FREE_LIST
#undef LOOP_THROUGH

int
check_rulestate(int desired_state)
d296 18
a313 7
	if (require_order && (rulestate > desired_state)) {
		yyerror("Rules must be in order: options, normalization, "
		    "queueing, translation, filtering");
		return (1);
	}
	rulestate = desired_state;
	return (0);
d316 2
a317 2
int
kw_cmp(const void *k, const void *e)
d319 13
a331 1
	return (strcmp(k, ((const struct keywords *)e)->k_name));
d334 2
a335 2
int
lookup(char *s)
d337 9
a345 126
	/* this has to be sorted always */
	static const struct keywords keywords[] = {
		{ "all",		ALL},
		{ "allow-opts",		ALLOWOPTS},
		{ "altq",		ALTQ},
		{ "anchor",		ANCHOR},
		{ "antispoof",		ANTISPOOF},
		{ "any",		ANY},
		{ "bandwidth",		BANDWIDTH},
		{ "binat",		BINAT},
		{ "binat-anchor",	BINATANCHOR},
		{ "bitmask",		BITMASK},
		{ "block",		BLOCK},
		{ "block-policy",	BLOCKPOLICY},
		{ "cbq",		CBQ},
		{ "code",		CODE},
		{ "crop",		FRAGCROP},
		{ "debug",		DEBUG},
		{ "drop",		DROP},
		{ "drop-ovl",		FRAGDROP},
		{ "dup-to",		DUPTO},
		{ "fastroute",		FASTROUTE},
		{ "file",		FILENAME},
		{ "fingerprints",	FINGERPRINTS},
		{ "flags",		FLAGS},
		{ "floating",		FLOATING},
		{ "flush",		FLUSH},
		{ "for",		FOR},
		{ "fragment",		FRAGMENT},
		{ "from",		FROM},
		{ "global",		GLOBAL},
		{ "group",		GROUP},
		{ "group-bound",	GRBOUND},
		{ "hfsc",		HFSC},
		{ "hostid",		HOSTID},
		{ "icmp-type",		ICMPTYPE},
		{ "icmp6-type",		ICMP6TYPE},
		{ "if-bound",		IFBOUND},
		{ "in",			IN},
		{ "inet",		INET},
		{ "inet6",		INET6},
		{ "keep",		KEEP},
		{ "label",		LABEL},
		{ "limit",		LIMIT},
		{ "linkshare",		LINKSHARE},
		{ "load",		LOAD},
		{ "log",		LOG},
		{ "log-all",		LOGALL},
		{ "loginterface",	LOGINTERFACE},
		{ "max",		MAXIMUM},
		{ "max-mss",		MAXMSS},
		{ "max-src-conn",	MAXSRCCONN},
		{ "max-src-conn-rate",	MAXSRCCONNRATE},
		{ "max-src-nodes",	MAXSRCNODES},
		{ "max-src-states",	MAXSRCSTATES},
		{ "min-ttl",		MINTTL},
		{ "modulate",		MODULATE},
		{ "nat",		NAT},
		{ "nat-anchor",		NATANCHOR},
		{ "no",			NO},
		{ "no-df",		NODF},
		{ "no-route",		NOROUTE},
		{ "no-sync",		NOSYNC},
		{ "on",			ON},
		{ "optimization",	OPTIMIZATION},
		{ "os",			OS},
		{ "out",		OUT},
		{ "overload",		OVERLOAD},
		{ "pass",		PASS},
		{ "port",		PORT},
		{ "priority",		PRIORITY},
		{ "priq",		PRIQ},
		{ "probability",	PROBABILITY},
		{ "proto",		PROTO},
		{ "qlimit",		QLIMIT},
		{ "queue",		QUEUE},
		{ "quick",		QUICK},
		{ "random",		RANDOM},
		{ "random-id",		RANDOMID},
		{ "rdr",		RDR},
		{ "rdr-anchor",		RDRANCHOR},
		{ "realtime",		REALTIME},
		{ "reassemble",		REASSEMBLE},
		{ "reply-to",		REPLYTO},
		{ "require-order",	REQUIREORDER},
		{ "return",		RETURN},
		{ "return-icmp",	RETURNICMP},
		{ "return-icmp6",	RETURNICMP6},
		{ "return-rst",		RETURNRST},
		{ "round-robin",	ROUNDROBIN},
		{ "route-to",		ROUTETO},
		{ "rule",		RULE},
		{ "scrub",		SCRUB},
		{ "set",		SET},
		{ "source-hash",	SOURCEHASH},
		{ "source-track",	SOURCETRACK},
		{ "state",		STATE},
		{ "state-policy",	STATEPOLICY},
		{ "static-port",	STATICPORT},
		{ "sticky-address",	STICKYADDRESS},
		{ "synproxy",		SYNPROXY},
		{ "table",		TABLE},
		{ "tag",		TAG},
		{ "tagged",		TAGGED},
		{ "tbrsize",		TBRSIZE},
		{ "timeout",		TIMEOUT},
		{ "to",			TO},
		{ "tos",		TOS},
		{ "ttl",		TTL},
		{ "upperlimit",		UPPERLIMIT},
		{ "user",		USER},
	};
	const struct keywords	*p;

	p = bsearch(s, keywords, sizeof(keywords)/sizeof(keywords[0]),
	    sizeof(keywords[0]), kw_cmp);

	if (p) {
		if (debug > 1)
			fprintf(stderr, "%s: %d\n", s, p->k_val);
		return (p->k_val);
	} else {
		if (debug > 1)
			fprintf(stderr, "string: %s\n", s);
		return (STRING);
	}
d348 4
a351 1
#define MAXPUSHBACK	128
d353 4
a356 4
char	*parsebuf;
int	 parseindex;
char	 pushback_buffer[MAXPUSHBACK];
int	 pushback_index = 0;
d358 3
a360 2
int
lgetc(FILE *f)
d362 32
a393 11
	int	c, next;

	if (parsebuf) {
		/* Read character from the parsebuffer instead of input. */
		if (parseindex >= 0) {
			c = parsebuf[parseindex++];
			if (c != '\0')
				return (c);
			parsebuf = NULL;
		} else
			parseindex++;
d395 1
d397 5
a401 2
	if (pushback_index)
		return (pushback_buffer[--pushback_index]);
d403 20
a422 6
	while ((c = getc(f)) == '\\') {
		next = getc(f);
		if (next != '\n') {
			if (isspace(next))
				yyerror("whitespace after \\");
			ungetc(next, f);
d425 4
a428 2
		yylval.lineno = lineno;
		lineno++;
d430 37
a466 7
	if (c == '\t' || c == ' ') {
		/* Compress blanks to a single space. */
		do {
			c = getc(f);
		} while (c == '\t' || c == ' ');
		ungetc(c, f);
		c = ' ';
d468 5
d474 4
a477 2
	return (c);
}
d479 2
a480 2
int
lungetc(int c)
d482 107
a588 6
	if (c == EOF)
		return (EOF);
	if (parsebuf) {
		parseindex--;
		if (parseindex >= 0)
			return (c);
a589 4
	if (pushback_index < MAXPUSHBACK-1)
		return (pushback_buffer[pushback_index++] = c);
	else
		return (EOF);
d592 2
a593 2
int
findeol(void)
d595 2
a596 1
	int	c;
d598 5
a602 2
	parsebuf = NULL;
	pushback_index = 0;
d604 35
a638 5
	/* skip to either EOF or the first real EOL */
	while (1) {
		c = lgetc(fin);
		if (c == '\n') {
			lineno++;
d641 1
a641 2
		if (c == EOF)
			break;
a642 1
	return (ERROR);
d645 2
a646 2
int
yylex(void)
d648 61
a708 22
	char	 buf[8096];
	char	*p, *val;
	int	 endc, c, next;
	int	 token;

top:
	p = buf;
	while ((c = lgetc(fin)) == ' ')
		; /* nothing */

	yylval.lineno = lineno;
	if (c == '#')
		while ((c = lgetc(fin)) != '\n' && c != EOF)
			; /* nothing */
	if (c == '$' && parsebuf == NULL) {
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);

			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
d710 81
a790 7
			if (isalnum(c) || c == '_') {
				*p++ = (char)c;
				continue;
			}
			*p = '\0';
			lungetc(c);
			break;
d792 19
a810 19
		val = symget(buf);
		if (val == NULL) {
			yyerror("macro '%s' not defined", buf);
			return (findeol());
		}
		parsebuf = val;
		parseindex = 0;
		goto top;
	}

	switch (c) {
	case '\'':
	case '"':
		endc = c;
		while (1) {
			if ((c = lgetc(fin)) == EOF)
				return (0);
			if (c == endc) {
				*p = '\0';
a812 9
			if (c == '\n') {
				lineno++;
				continue;
			}
			if (p + 1 >= buf + sizeof(buf) - 1) {
				yyerror("string too long");
				return (findeol());
			}
			*p++ = (char)c;
d814 158
a971 9
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
		return (STRING);
	case '<':
		next = lgetc(fin);
		if (next == '>') {
			yylval.v.i = PF_OP_XRG;
			return (PORTBINARY);
d973 11
a983 7
		lungetc(next);
		break;
	case '>':
		next = lgetc(fin);
		if (next == '<') {
			yylval.v.i = PF_OP_IRG;
			return (PORTBINARY);
d985 1
a985 8
		lungetc(next);
		break;
	case '-':
		next = lgetc(fin);
		if (next == '>')
			return (ARROW);
		lungetc(next);
		break;
d987 10
d998 5
a1002 24
#define allowed_in_string(x) \
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && \
	x != ','))

	if (isalnum(c) || c == ':' || c == '_') {
		do {
			*p++ = c;
			if ((unsigned)(p-buf) >= sizeof(buf)) {
				yyerror("string too long");
				return (findeol());
			}
		} while ((c = lgetc(fin)) != EOF && (allowed_in_string(c)));
		lungetc(c);
		*p = '\0';
		if ((token = lookup(buf)) == STRING)
			if ((yylval.v.string = strdup(buf)) == NULL)
				err(1, "yylex: strdup");
		return (token);
	}
	if (c == '\n') {
		yylval.lineno = lineno;
		lineno++;
d1004 1
a1004 3
	if (c == EOF)
		return (0);
	return (c);
d1007 2
a1008 2
int
parse_rules(FILE *input, struct pfctl *xpf)
d1010 2
a1011 1
	struct sym	*sym, *next;
d1013 6
a1018 23
	fin = input;
	pf = xpf;
	lineno = 1;
	errors = 0;
	rulestate = PFCTL_STATE_NONE;
	returnicmpdefault = (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
	returnicmp6default =
	    (ICMP6_DST_UNREACH << 8) | ICMP6_DST_UNREACH_NOPORT;
	blockpolicy = PFRULE_DROP;
	require_order = 1;

	yyparse();

	/* Free macros and check which have not been used. */
	for (sym = TAILQ_FIRST(&symhead); sym != NULL; sym = next) {
		next = TAILQ_NEXT(sym, entries);
		if ((pf->opts & PF_OPT_VERBOSE2) && !sym->used)
			fprintf(stderr, "warning: macro '%s' not "
			    "used\n", sym->nam);
		free(sym->nam);
		free(sym->val);
		TAILQ_REMOVE(&symhead, sym, entries);
		free(sym);
d1020 4
d1025 5
a1029 1
	return (errors ? -1 : 0);
a1031 4
/*
 * Over-designed efficiency is a French and German concept, so how about
 * we wait until they discover this ugliness and make it all fancy.
 */
d1033 1
a1033 1
symset(const char *nam, const char *val, int persist)
d1035 2
a1036 1
	struct sym	*sym;
d1038 14
a1051 12
	for (sym = TAILQ_FIRST(&symhead); sym && strcmp(nam, sym->nam);
	    sym = TAILQ_NEXT(sym, entries))
		;	/* nothing */

	if (sym != NULL) {
		if (sym->persist == 1)
			return (0);
		else {
			free(sym->nam);
			free(sym->val);
			TAILQ_REMOVE(&symhead, sym, entries);
			free(sym);
a1053 17
	if ((sym = calloc(1, sizeof(*sym))) == NULL)
		return (-1);

	sym->nam = strdup(nam);
	if (sym->nam == NULL) {
		free(sym);
		return (-1);
	}
	sym->val = strdup(val);
	if (sym->val == NULL) {
		free(sym->nam);
		free(sym);
		return (-1);
	}
	sym->used = 0;
	sym->persist = persist;
	TAILQ_INSERT_TAIL(&symhead, sym, entries);
d1057 1
a1057 5
int
pfctl_cmdline_symset(char *s)
{
	char	*sym, *val;
	int	 ret;
d1059 1
a1059 2
	if ((val = strrchr(s, '=')) == NULL)
		return (-1);
d1061 5
a1065 2
	if ((sym = malloc(strlen(s) - strlen(val) + 1)) == NULL)
		err(1, "pfctl_cmdline_symset: malloc");
d1067 2
a1068 1
	strlcpy(sym, s, strlen(s) - strlen(val) + 1);
d1070 70
a1139 2
	ret = symset(sym, val + 1, 1);
	free(sym);
d1141 2
a1142 1
	return (ret);
d1145 2
a1146 2
char *
symget(const char *nam)
d1148 9
a1156 1
	struct sym	*sym;
a1157 5
	TAILQ_FOREACH(sym, &symhead, entries)
		if (strcmp(nam, sym->nam) == 0) {
			sym->used = 1;
			return (sym->val);
		}
d1161 2
a1162 2
void
decide_address_family(struct node_host *n, sa_family_t *af)
d1164 9
a1172 1
	sa_family_t	target_af = 0;
d1174 60
a1233 6
	while (!*af && n != NULL) {
		if (n->af) {
			if (target_af == 0)
				target_af = n->af;
			if (target_af != n->af)
				return;
a1234 1
		n = n->next;
d1236 1
a1236 2
	if (!*af && target_af)
		*af = target_af;
d1239 2
a1240 2
void
remove_invalid_hosts(struct node_host **nh, sa_family_t *af)
d1242 17
a1258 1
	struct node_host	*n = *nh, *prev = NULL;
d1260 71
a1330 23
	while (n != NULL) {
		if (*af && n->af && n->af != *af) {
			/* unlink and free n */
			struct node_host *next = n->next;

			/* adjust tail pointer */
			if (n == (*nh)->tail)
				(*nh)->tail = prev;
			/* adjust previous node's next pointer */
			if (prev == NULL)
				*nh = next;
			else
				prev->next = next;
			/* free node */
			if (n->ifname != NULL)
				free(n->ifname);
			free(n);
			n = next;
		} else {
			if (n->af && !*af)
				*af = n->af;
			prev = n;
			n = n->next;
d1332 38
a1370 1
}
d1372 66
a1437 5
int
invalid_redirect(struct node_host *nh, sa_family_t af)
{
	if (!af) {
		struct node_host *n;
d1439 43
a1481 9
		/* tables and dyniftl are ok without an address family */
		for (n = nh; n != NULL; n = n->next) {
			if (n->addr.type != PF_ADDR_TABLE &&
			    n->addr.type != PF_ADDR_DYNIFTL) {
				yyerror("address family not given and "
				    "translation address expands to multiple "
				    "address families");
				return (1);
			}
d1484 4
a1487 6
	if (nh == NULL) {
		yyerror("no translation address with matching address family "
		    "found.");
		return (1);
	}
	return (0);
d1490 5
d1496 1
a1496 1
atoul(char *s, u_long *ulvalp)
d1498 8
a1505 6
	u_long	 ulval;
	char	*ep;

	errno = 0;
	ulval = strtoul(s, &ep, 0);
	if (s[0] == '\0' || *ep != '\0')
d1507 8
a1514 4
	if (errno == ERANGE && ulval == ULONG_MAX)
		return (-1);
	*ulvalp = ulval;
	return (0);
d1517 6
d1524 1
a1524 1
getservice(char *n)
d1526 2
a1527 2
	struct servent	*s;
	u_long		 ulval;
d1529 17
a1545 3
	if (atoul(n, &ulval) == 0) {
		if (ulval > 65535) {
			yyerror("illegal port value %d", ulval);
d1548 3
a1550 7
		return (htons(ulval));
	} else {
		s = getservbyname(n, "tcp");
		if (s == NULL)
			s = getservbyname(n, "udp");
		if (s == NULL) {
			yyerror("unknown port %s", n);
d1553 5
a1557 2
		return (s->s_port);
	}
d1561 1
a1561 1
rule_label(struct pf_rule *r, char *s)
d1563 9
a1571 9
	if (s) {
		if (strlcpy(r->label, s, sizeof(r->label)) >=
		    sizeof(r->label)) {
			yyerror("rule label too long (max %d chars)",
			    sizeof(r->label)-1);
			return (-1);
		}
	}
	return (0);
d1574 2
a1575 2
u_int16_t
parseicmpspec(char *w, sa_family_t af)
d1577 1
a1577 8
	const struct icmpcodeent	*p;
	u_long				 ulval;
	u_int8_t			 icmptype;

	if (af == AF_INET)
		icmptype = returnicmpdefault >> 8;
	else
		icmptype = returnicmp6default >> 8;
d1579 4
a1582 12
	if (atoul(w, &ulval) == -1) {
		if ((p = geticmpcodebyname(icmptype, w, af)) == NULL) {
			yyerror("unknown icmp code %s", w);
			return (0);
		}
		ulval = p->code;
	}
	if (ulval > 255) {
		yyerror("invalid icmp code %ld", ulval);
		return (0);
	}
	return (icmptype << 8 | ulval);
d1586 1
a1586 1
pfctl_load_anchors(int dev, int opts, struct pfr_buffer *trans)
d1588 1
a1588 10
	struct loadanchors	*la;

	TAILQ_FOREACH(la, &loadanchorshead, entries) {
		if (opts & PF_OPT_VERBOSE)
			fprintf(stderr, "\nLoading anchor %s from %s\n",
			    la->anchorname, la->filename);
		if (pfctl_rules(dev, la->filename, opts, la->anchorname,
		    trans) == -1)
			return (-1);
	}
d1590 5
a1594 1
	return (0);
a1595 1

@


1.462
log
@initialize $$->tail and $$->next for MAXSRCCONNRATE
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.461 2004/12/04 07:58:51 mcbride Exp $	*/
d1616 1
a1616 3
					if (o->data.overload.flush)
						r.rule_flag |=
						    PFRULE_SRCTRACK_FLUSH;
d2808 4
a2811 1
		| FLUSH				{ $$ = 1; }
@


1.461
log
@Userland support for limiting open tcp connections per source. eg:

keep state (max-src-conn 1000, max-src-conn-rate 100/10, overflow <bad> flush)

allow a maximum of 1000 open connections or 100 new connections in 10 seconds.
The addresses of offenders are added to the <bad> table which can be used in
the ruleset, and existing states from that host are flushed.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.460 2004/09/21 16:59:11 aaron Exp $	*/
d2867 2
@


1.460
log
@Implement "no scrub" to allow exclusion of specific traffic from scrub rules.
First match wins, just like "no {binat,nat,rdr}".  henning@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.459 2004/06/29 22:14:13 henning Exp $	*/
d121 4
a124 2
	    PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_NODES,
	    PF_STATE_OPT_STATELOCK, PF_STATE_OPT_TIMEOUT };
d133 10
d408 1
d415 1
a415 1
%type	<v.i>			no dir log af fragcache sourcetrack
d1593 1
a1593 1
					if (o->data.max_src_nodes == 0) {
d1602 62
d1704 1
a1704 1
			if (srctrack) {
d1712 18
d2809 4
d2851 35
d4475 1
d4500 2
d4516 1
@


1.459
log
@remove cedric's bogus interface name verification code.
this was meant to verify that ne3 is a valid interface that could show
up, but bogus0 is not. while this might sound like a good idea it is
completely broken and causes a shitload of problems. just allow for anything
as interface name, the kernel abstracts that nice enough. if no interface
by that name exists (or shows up) the rule never matches; that matches
pf semantics used everywhere else.
this also fixes the "pfctl always has to run as root" issue that cedric
did not fix over the last 6 months despite being bugged to regularily.
help & ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.458 2004/06/29 17:40:18 frantzen Exp $	*/
d404 2
a405 1
%type	<v.b>			action nataction flags flag blockspec
d732 10
a741 1
scrubrule	: SCRUB dir logquick interface af proto fromto scrub_opts
d750 1
a750 1
			r.action = PF_SCRUB;
d3513 1
@


1.458
log
@convert a few memcpy()s to strlcpy() so we don't copy uninitialized junk into
a interface name's slack space past the \0.  will be needed for the optimizer.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.457 2004/06/26 07:25:16 david Exp $	*/
a479 5
			if ((ifa_exists($3, 0) == NULL) && strcmp($3, "none")) {
				yyerror("interface %s doesn't exist", $3);
				free($3);
				YYERROR;
			}
a1927 5
			if ((n = ifa_exists($1, 1)) == NULL) {
				yyerror("unknown interface %s", $1);
				free($1);
				YYERROR;
			}
d1938 4
a1942 1
			$$->ifa_flags = n->ifa_flags;
a2199 5
			if (ifa_exists($2, 1) == NULL && strcmp($2, "self")) {
				yyerror("interface %s does not exist", $2);
				free(op);
				YYERROR;
			}
a3330 7
			if (ifa_exists($$->ifname, 0) == NULL) {
				yyerror("routeto: unknown interface %s",
				    $$->ifname);
				free($1);
				free($$);
				YYERROR;
			}
a3337 5
			if (ifa_exists($$->ifname, 0) == NULL) {
				yyerror("routeto: unknown interface %s",
				    $$->ifname);
				YYERROR;
			}
@


1.457
log
@add back PF_INOUT, fixes reassemble tcp
ok canacar@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.456 2004/06/25 05:45:48 deraadt Exp $	*/
d4184 2
a4185 1
			memcpy(r->ifname, interface->ifname, sizeof(r->ifname));
d4187 1
a4187 1
			memcpy(r->ifname, ifname, sizeof(r->ifname));
d4189 1
a4189 1
			memcpy(r->ifname, ifname, sizeof(r->ifname));
@


1.456
log
@repair tree nanobreak by the nanobum
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.455 2004/06/10 14:22:54 dhartmei Exp $	*/
d760 1
a760 1
				if (r.direction != PF_FORWARD) {
@


1.455
log
@rename struct pf_rule_addr member 'not' to 'neg', as 'not' is a reserved
keyword in C++. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.454 2004/05/21 23:10:48 dhartmei Exp $	*/
d760 1
a760 1
				if (r.direction != PF_INOUT) {
@


1.454
log
@Use '/' instead of ':' as separator for anchor path components. Note that
the parser now needs quotes around paths containing separators.
ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.453 2004/05/19 17:50:50 dhartmei Exp $	*/
d3281 1
a3281 1
				binat.dst.not = $10->not;
d4215 1
a4215 1
		r->src.not = src_host->not;
d4220 1
a4220 1
		r->dst.not = dst_host->not;
@


1.453
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.452 2004/04/24 23:22:54 cedric Exp $	*/
a307 1
	char				*rulesetname;
d4933 2
a4934 2
			fprintf(stderr, "\nLoading anchor %s:%s from %s\n",
			    la->anchorname, la->rulesetname, la->filename);
@


1.452
log
@Add "probability xxx" rule modifier. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.451 2004/04/22 08:34:30 henning Exp $	*/
d266 2
a267 1
	    struct node_uid *, struct node_gid *, struct node_icmp *);
a376 12
#define PREPARE_ANCHOR_RULE(r, a)				\
	do {							\
		memset(&(r), 0, sizeof(r));			\
		if (strlcpy(r.anchorname, (a),			\
		    sizeof(r.anchorname)) >=			\
		    sizeof(r.anchorname)) {			\
			yyerror("anchor name '%s' too long",	\
			    (a));				\
			YYERROR;				\
		}						\
	} while (0)

d594 1
a594 1
			PREPARE_ANCHOR_RULE(r, $2);
d613 2
a614 1
			    0, 0, 0);
d624 1
a624 2
			PREPARE_ANCHOR_RULE(r, $2);
			free($2);
d633 2
a634 1
			    0, 0, 0);
d644 1
a644 2
			PREPARE_ANCHOR_RULE(r, $2);
			free($2);
d674 2
a675 1
			    0, 0, 0);
d685 1
a685 2
			PREPARE_ANCHOR_RULE(r, $2);
			free($2);
d708 2
a709 1
			pfctl_add_rule(pf, &r);
a713 1
			char			*t;
d716 1
a716 7
			t = strsep(&$3, ":");
			if (*t == '\0' || $3 == NULL || *$3 == '\0') {
				yyerror("anchor '%s' invalid\n", $3);
				free(t);
				YYERROR;
			}
			if (strlen(t) >= PF_ANCHOR_NAME_SIZE) {
d718 2
a719 2
				    t, PF_ANCHOR_NAME_SIZE - 1);
				free(t);
a721 7
			if (strlen($3) >= PF_RULESET_NAME_SIZE) {
				yyerror("rulesetname %s too long, max %u\n",
				    $3, PF_RULESET_NAME_SIZE - 1);
				free(t);
				YYERROR;
			}

d725 1
a725 3
			if ((loadanchor->anchorname = strdup(t)) == NULL)
				err(1, "loadrule: strdup");
			if ((loadanchor->rulesetname = strdup($3)) == NULL)
d733 1
a733 1
			free(t); /* not $3 */
d777 1
a777 1
			    NULL, NULL, NULL);
d915 2
a916 1
					    NULL, NULL, NULL, NULL, NULL, NULL);
d935 1
a935 1
						    NULL, NULL, NULL, NULL);
d1713 1
a1713 1
			    $9.uid, $9.gid, $9.icmpspec);
d3183 1
a3183 1
			    $5.dst.port, 0, 0, 0);
d3331 1
a3331 1
			pfctl_add_rule(pf, &binat);
d3594 1
a3594 1
	    r->action == PF_PASS && !r->anchorname[0]) {
d3665 1
a3665 1
	    pf->anchor, pf->ruleset, &ab, pf->tticket)) {
d4131 2
a4132 1
    struct node_uid *uids, struct node_gid *gids, struct node_icmp *icmp_types)
d4284 1
a4284 1
			pfctl_add_rule(pf, r);
d4937 1
a4937 1
		    la->rulesetname, trans) == -1)
@


1.451
log
@typo, From: Jared Yanovich <jjy2+@@pitt.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.450 2004/04/14 11:16:42 cedric Exp $	*/
d52 1
d179 1
d403 1
a403 1
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN STATICPORT
d608 1
d1514 1
d1828 20
d4422 1
@


1.450
log
@make antispoof work with dynamic addresses. ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.449 2004/03/20 23:20:20 david Exp $	*/
d508 1
a508 1
				yyerror("error setting loginterface %08x", $3);
@


1.449
log
@spelling fix; ok dhartmei@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.448 2004/03/14 21:51:44 dhartmei Exp $	*/
d436 1
a436 1
%type	<v.interface>		antispoof_ifspc antispoof_iflst
d886 1
a886 1
			struct node_host	*h = NULL;
d912 23
a934 1
				h = ifa_lookup(j->ifname, PFI_AFLAG_NETWORK);
d950 4
a953 1
					h = ifa_lookup(i->ifname, 0);
d958 2
a959 1
				}
d965 1
a965 1
antispoof_ifspc	: FOR if_item			{ $$ = $2; }
d969 2
a970 2
antispoof_iflst	: if_item			{ $$ = $1; }
		| antispoof_iflst comma if_item	{
d974 7
@


1.448
log
@#include fixes, from Max Laier, ok beck@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.447 2004/03/08 16:10:02 henning Exp $	*/
d1552 1
a1552 1
						    "multiple definitons");
d1593 1
a1593 1
						    "multiple definitons");
@


1.447
log
@plug 124 memory leaks
ok mcbride@@ pb@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.445 2004/03/01 17:40:54 dhartmei Exp $	*/
d53 1
@


1.446
log
@from bgpd:
plug a memory leak in the lexer.
the issue is this code fragement from yylex():
.		token = lookup(buf);
.		yylval.v.string = strdup(buf);
.		if (yylval.v.string == NULL)
.			err(1, "yylex: strdup");
.		return (token);
lookup() tries to match buf against a list of keywords, and returns the
associated token if it has a match, or the token STRING otherwise.
STRING is the only token that needs (and free()s) yylval.v.string. however,
we assigned memory for it with the strdup in yylex for each and every token.
the fix is obviously only setting yylval.v.string when lookup() returns STRING.
Patrick Latifi noticed that something was leaking with token handling,
analysis and fix by me.
ok deraadt@@
@
text
@d469 2
a470 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d472 1
d475 1
d478 1
d485 2
a486 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d488 1
d491 1
d496 1
d499 1
d534 2
a535 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d537 1
d540 1
d543 1
d562 2
a563 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d565 1
d568 1
d571 1
d589 2
d597 2
a598 1
			if (check_rulestate(PFCTL_STATE_FILTER))
d600 1
d625 2
a626 1
			if (check_rulestate(PFCTL_STATE_NAT))
d628 1
d631 1
d645 2
a646 1
			if (check_rulestate(PFCTL_STATE_NAT))
d648 1
d651 1
d686 2
a687 1
			if (check_rulestate(PFCTL_STATE_NAT))
d689 1
d692 1
d724 1
a724 1
			if (*t == '\0' || *$3 == '\0') {
d726 1
d732 1
d738 1
d858 2
a859 1
			if (strcasecmp($2, "tcp") != 0)
d861 2
d983 1
d987 2
a988 1
				if (process_tabledef($3, &$5))
d990 2
d1029 2
a1030 1
			else
d1032 2
d1107 2
a1108 1
			if (check_rulestate(PFCTL_STATE_QUEUE))
d1110 1
d1118 1
d1121 1
d1238 1
d1245 1
d1249 1
d1298 1
d1301 1
d1320 1
d1323 1
d1405 1
d1408 1
a1430 1
				free($$);
d1433 2
d1437 1
d1832 2
a1833 1
			if (!($$.w = parseicmpspec($3, AF_INET)))
d1835 2
d1842 2
a1843 1
			if (!($$.w2 = parseicmpspec($3, AF_INET6)))
d1845 2
d1850 4
a1853 3
			if (!($$.w = parseicmpspec($3, AF_INET)))
				YYERROR;
			if (!($$.w2 = parseicmpspec($5, AF_INET6)))
d1855 3
d1903 1
d1911 1
d1916 1
d1949 1
d1959 1
d1964 1
d2085 1
d2089 1
d2097 1
d2116 2
a2117 1
				yyerror("table name '%s' too long");
d2128 1
d2139 1
d2143 1
d2149 1
a2149 1
			char	*p;
d2151 1
d2164 1
d2170 1
d2177 1
d2190 1
d2195 1
d2266 1
d2278 1
d2290 2
a2291 1
				    (port[1] = getservice(p)) == -1)
d2293 1
d2298 1
d2367 1
d2374 1
d2380 1
d2449 1
d2457 1
d2462 1
d2471 1
d2474 1
d2521 1
d2529 1
d2534 1
d2564 1
d2571 1
d2576 1
d2595 1
d2603 1
d2608 1
d2619 1
d2627 1
d2632 1
d2649 1
d2652 1
d2759 1
d2764 1
d2767 1
d2780 1
a2780 2
			if (($$ = strdup($2)) == NULL)
				err(1, "rule label strdup() failed");
d2785 1
a2785 2
			if (($$.qname = strdup($2)) == NULL)
				err(1, "qname strdup() failed");
d2788 1
a2788 2
			if (($$.qname = strdup($3)) == NULL)
				err(1, "qname strdup() failed");
d2791 2
a2792 3
			if (($$.qname = strdup($3)) == NULL ||
			    ($$.pqname = strdup($5)) == NULL)
				err(1, "qname strdup() failed");
d2804 2
a2805 1
				if (($$.a = getservice($1)) == -1)
d2807 1
d2811 2
a2812 1
				if (($$.a = getservice($1)) == -1)
d2814 1
d2820 2
a2821 1
				    ($$.b = getservice(p)) == -1)
d2823 1
d2828 1
d2875 1
d2888 1
d2907 1
d3310 1
a3310 2
			if (($$->ifname = strdup($1)) == NULL)
				err(1, "routeto: strdup");
d3314 2
d3324 1
a3324 2
			if (($$->ifname = strdup($2)) == NULL)
				err(1, "routeto: strdup");
d3387 2
a3388 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d3390 1
d3393 1
d3396 1
a3396 1

d3406 2
a3407 1
			if (check_rulestate(PFCTL_STATE_OPTION))
d3409 1
d3412 1
d3415 1
d3431 2
a3432 1
			else
d3434 2
@


1.445
log
@support "tagged <name>" on anchor rules, suggested by vd@@vmunix.lt,
ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.444 2004/02/24 20:35:18 mcbride Exp $	*/
d4481 3
a4483 4
		token = lookup(buf);
		yylval.v.string = strdup(buf);
		if (yylval.v.string == NULL)
			err(1, "yylex: strdup");
@


1.444
log
@'max-src-nodes' requires 'source-track rule'. Set that automatically,
unless 'source-track global' is explicit, in which case error out. Lots of
help from cedric@@.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.443 2004/02/24 14:28:45 cedric Exp $	*/
d575 1
a575 1
anchorrule	: ANCHOR string	dir interface af proto fromto {
d585 9
d3428 1
a3428 1
	    r->action == PF_PASS) {
@


1.443
log
@fixup.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.442 2004/02/24 11:16:26 mcbride Exp $	*/
d122 2
d1487 1
a1487 2
					srctrack = 1;
					r.rule_flag |=  o->data.src_track;
d1519 2
a1520 1
					r.rule_flag |= PFRULE_SRCTRACK;
d1545 12
d2533 3
a2535 9
sourcetrack	: SOURCETRACK {
			$$ = PFRULE_SRCTRACK;
		}
		| SOURCETRACK GLOBAL {
			$$ = PFRULE_SRCTRACK;
		}
		| SOURCETRACK RULE {
			$$ = PFRULE_SRCTRACK ^ PFRULE_RULESRCTRACK;
		}
@


1.442
log
@Check for 'source-track rule' with 'max-src-nodes'.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.441 2004/02/11 18:34:51 cedric Exp $	*/
d3402 1
a3402 1
	if (r->mak_src_nodes && !(r->rule_flag & PFRULE_RULESRCTRACK)) {
@


1.441
log
@Fix interface clobbering for link-local addresses. Found by Pyun YongHyeon.
Fix "antispoof for foo" when foo has no addresses.
ok+help dhartmei@@, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.440 2004/02/10 21:06:04 henning Exp $	*/
d3400 4
@


1.440
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.439 2004/02/10 17:48:08 henning Exp $	*/
d881 4
a884 3
					expand_rule(&r, NULL, NULL, NULL, NULL,
					    h, NULL, NULL, NULL, NULL, NULL,
					    NULL);
d3986 1
a3986 1
		    (src_host->ifindex && if_nametoindex(interface->ifname) &&
d3988 1
a3988 1
		    (dst_host->ifindex && if_nametoindex(interface->ifname) &&
d3996 3
a3998 1
		if (if_indextoname(src_host->ifindex, ifname))
d4003 1
a4003 1
			memcpy(r->ifname, interface->ifname, sizeof(r->ifname));
@


1.439
log
@fix at leats the worst of Cedric "KNF is for everybody but me" Berger's fuckup
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.438 2004/02/04 17:35:40 mcbride Exp $	*/
d119 2
a120 2
	  PF_STATE_OPT_MAX_SRC_STATES, PF_STATE_OPT_MAX_SRC_NODES,
	  PF_STATE_OPT_STATELOCK, PF_STATE_OPT_TIMEOUT };
d296 3
a298 2
TAILQ_HEAD(loadanchorshead, loadanchors)	 loadanchorshead =
   TAILQ_HEAD_INITIALIZER(loadanchorshead);
d762 1
a762 1
		  scrub_opts_l
d903 1
a903 1
		  antispoof_opts_l
d958 1
a958 1
		   table_opts_l
d1089 1
a1089 1
		  queue_opts_l
d1265 1
a1265 1
		  hfscopts_list				{
d1374 1
a1374 1
		  filter_opts
d1448 1
a1448 1
					     "the SYN TCP flag (flags S/SA)");
d1623 1
a1623 1
		  filter_opts_l
d2771 1
a2771 1
		   pool_opts_l
d2927 4
a2930 2
						    (ntohs($5.dst.port->port[1]) -
						    ntohs($5.dst.port->port[0]));
d2936 2
a2937 1
					r.rpool.proxy_port[1] = ntohs($7->rport.b);
d3015 1
a3015 1
		  redirection
d3592 1
a3592 1
						   "%s/%d", a, bits);
@


1.438
log
@Handle rules like 'pass ... proto { tcp udp icmp } ... modulate state'

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.437 2004/02/03 19:29:50 henning Exp $	*/
d531 1
a531 1
				switch($3) {
d948 1
a948 1
				free (ti);
d985 1
a985 1
				switch(n->addr.type) {
d1519 7
a1525 7
                                        if (statelock) {
                                                yyerror("state locking option: "
                                                    "multiple definitons");
                                                YYERROR;
                                        }
                                        statelock = 1;
                                        r.rule_flag |= o->data.statelock;
d4041 1
a4041 1
		    r->proto && r->proto != IPPROTO_TCP) 
d4043 1
a4043 1
		else 
@


1.437
log
@fix PR 3664 / jared r r spiegel
we need to save the unexpanded tag/tagged strings before entering the
expansion loop, and at each loop, start with the unexpanded tag, so that
on subsequent loops the macros are replaced with current values and not
the values from previous loop persist
ryan theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.436 2004/01/05 22:04:24 henning Exp $	*/
a3383 6
	if ((r->keep_state == PF_STATE_MODULATE || r->keep_state ==
	    PF_STATE_SYNPROXY) && r->proto && r->proto != IPPROTO_TCP) {
		yyerror("modulate/synproxy state can only be applied to "
		    "TCP rules");
		problems++;
	}
d3949 1
a3949 1
	u_int8_t		 flags, flagset;
d3960 1
d4038 7
@


1.436
log
@few off by ones in strlcpy overflow check; Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.435 2004/01/04 12:30:29 cedric Exp $	*/
d3951 2
d3959 5
d4005 6
@


1.435
log
@don't ignore "!" on "binat on !foo". ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.434 2003/12/31 22:14:41 deraadt Exp $	*/
d1410 1
a1410 1
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
d1417 1
a1417 1
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
d2890 1
a2890 1
				if (strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE) >
d3047 1
a3047 1
				    PF_TAG_NAME_SIZE) > PF_TAG_NAME_SIZE) {
@


1.434
log
@spacing.  note this, cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.433 2003/12/31 11:18:24 cedric Exp $	*/
d3042 1
@


1.433
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.432 2003/12/30 16:59:38 henning Exp $	*/
d1574 1
a1574 1
				    DYNIF_MULTIADDR($5.host->addr))) 
d2965 1
a2965 1
					YYERROR; 
@


1.432
log
@fix TAILQ abuse.
TAILQ_REMOVE is a no-no within a TAILQ_FOREACH loop.
also free the symbol itself after removal.
all found while hacking bgpd which incorporates pfctl's sym code (macros).

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.431 2003/12/19 16:12:43 henning Exp $	*/
d72 1
d120 1
a120 1
	  PF_STATE_OPT_TIMEOUT };
d129 1
d241 1
d382 4
d402 1
a402 1
%token	TAGGED TAG
d409 1
a409 1
%type	<v.i>			unaryop
d480 1
a480 1
			if ((ifa_exists($3) == NULL) && strcmp($3, "none")) {
d529 16
a731 7
			if ($4) {
				if ($4->not) {
					yyerror("scrub rules do not support "
					    "'! <if>'");
					YYERROR;
				}
			}
d863 1
a863 1
				h = ifa_lookup(j->ifname, PFCTL_IFLOOKUP_NET);
d879 1
a879 2
					h = ifa_lookup(i->ifname,
					    PFCTL_IFLOOKUP_HOST);
d1379 1
d1518 9
d1541 2
d1573 3
a1575 2
				    $5.host->addr.type == PF_ADDR_TABLE))
					r.rpool.opts = PF_POOL_ROUNDROBIN;
d1580 7
a1586 1
						YYERROR;
d1808 1
a1808 1
			if ((n = ifa_exists($1)) == NULL) {
d2042 25
a2066 1
			if (ifa_exists($2) == NULL) {
d2076 1
d2528 11
d2609 9
d2951 2
a2952 1
				    $7->host->addr.type == PF_ADDR_TABLE))
d2957 9
a2965 2
				    "supported in round-robin redirction pools"))
						YYERROR;
a2973 9
				} else {
					if ((r.af == AF_INET &&
					    unmask(&$7->host->addr.v.a.mask,
					    r.af) == 32) ||
					    (r.af == AF_INET6 &&
					    unmask(&$7->host->addr.v.a.mask,
					    r.af) == 128)) {
						r.rpool.opts = PF_POOL_NONE;
					}
d3060 4
d3068 4
a3160 2
			struct node_host	*n;

d3166 1
a3166 1
			if ((n = ifa_exists($$->ifname)) == NULL) {
a3175 2
			struct node_host	*n;

d3179 1
a3179 1
			if ((n = ifa_exists($$->ifname)) == NULL) {
d3320 11
a3392 6
	if (!r->af && (r->src.addr.type == PF_ADDR_DYNIFTL ||
	    r->dst.addr.type == PF_ADDR_DYNIFTL)) {
		yyerror("dynamic addresses require address family "
		    "(inet/inet6)");
		problems++;
	}
d3417 1
a3417 14
	int			 problems = 0;
	struct pf_pooladdr	*pa;

	if (!r->af) {
		TAILQ_FOREACH(pa, &r->rpool.list, entries) {
			if (pa->addr.type == PF_ADDR_DYNIFTL) {
				yyerror("dynamic addresses require "
				    "address family (inet/inet6)");
				problems++;
				break;
			}
		}
	}
	return (-problems);
a3423 1
	struct pf_pooladdr	*pa;
a3443 17
	if (!r->af) {
		if (r->src.addr.type == PF_ADDR_DYNIFTL ||
		    r->dst.addr.type == PF_ADDR_DYNIFTL) {
			yyerror("dynamic addresses require address family "
			    "(inet/inet6)");
			problems++;
		} else {
			TAILQ_FOREACH(pa, &r->rpool.list, entries) {
				if (pa->addr.type == PF_ADDR_DYNIFTL) {
					yyerror("dynamic addresses require "
					    "address family (inet/inet6)");
					problems++;
					break;
				}
			}
		}
	}
d4144 1
d4150 1
d4155 1
d4211 1
d4617 1
a4617 1
		/* only tables are ok without an address family */
d4619 2
a4620 1
			if (n->addr.type != PF_ADDR_TABLE) {
@


1.431
log
@i wrote much of these, assert my copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.430 2003/12/19 01:11:14 deraadt Exp $	*/
d4395 1
a4395 1
	struct sym	*sym;
d4411 2
a4412 1
	TAILQ_FOREACH(sym, &symhead, entries) {
d4419 1
@


1.430
log
@assert copyright.  i rewrite much of this
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.429 2003/12/16 01:10:21 mcbride Exp $	*/
d7 1
@


1.429
log
@Check that max-src-states and max-src-nodes are not being set to 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.428 2003/12/15 09:12:55 henning Exp $	*/
d6 1
@


1.428
log
@KNF here too
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.427 2003/12/15 07:30:17 mcbride Exp $	*/
d1475 5
d1489 5
@


1.427
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.426 2003/12/15 07:11:30 mcbride Exp $	*/
d123 3
a125 3
 		u_int32_t	 max_src_states;
 		u_int32_t	 max_src_nodes;
 		u_int8_t	 src_track;
d2615 1
a2615 1
		| ARROW redirspec 		{
d2622 1
a2622 1
		| ARROW redirspec PORT rport 	{
@


1.426
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.425 2003/12/15 00:02:03 mcbride Exp $	*/
d400 1
a400 1
%type	<v.i>			unaryop 
d2698 1
a2698 1
		| RANDOM	{ 
d2713 1
a2713 1
		| ROUNDROBIN	{ 
d3153 1
a3153 1
		
@


1.425
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.424 2003/11/29 10:05:55 dhartmei Exp $	*/
d386 1
a386 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC DEBUG
d480 10
d4082 1
@


1.424
log
@allow ':' (range including boundaries) to be used whereever '><' (range
excluding boundaries) is legal. already supported by kernel, requires only
removal of three error messages. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.423 2003/11/22 13:44:20 henning Exp $	*/
d115 4
a118 1
enum	{ PF_STATE_OPT_MAX=0, PF_STATE_OPT_NOSYNC=1, PF_STATE_OPT_TIMEOUT=2 };
d123 3
d160 1
d221 12
a329 1
		struct pf_poolhashkey	*hashkey;
a341 4
			int			 type;
			struct pf_poolhashkey	*key;
		}			 pooltype;
		struct {
d349 1
d359 1
d392 1
d399 2
a400 2
%type	<v.i>			no dir log af fragcache
%type	<v.i>			staticport unaryop
a403 1
%type	<v.pooltype>		pooltype
d436 1
d898 1
d1162 1
d1351 1
d1448 32
d1522 2
a1523 2
				if (r.rpool.opts == PF_POOL_NONE && (
				    $5.host->next != NULL ||
d1526 4
a1529 4
				if (r.rpool.opts != PF_POOL_ROUNDROBIN)
					if (disallow_table($5.host, "tables "
					    "are only supported in round-robin "
					    "routing pools"))
d1532 1
a1532 1
					if (r.rpool.opts !=
d1775 1
d2436 11
d2451 1
a2451 1
		| MODULATE STATE state_opt_spec	{
d2490 27
d2605 1
a2605 1
		| ARROW redirspec		{
d2612 1
a2612 1
		| ARROW redirspec PORT rport	{
d2668 26
a2693 4
pooltype	: /* empty */
		{
			$$.type = PF_POOL_NONE;
			$$.key = NULL;
d2695 7
a2701 4
		| BITMASK
		{
			$$.type = PF_POOL_BITMASK;
			$$.key = NULL;
d2703 6
a2708 4
		| RANDOM
		{
			$$.type = PF_POOL_RANDOM;
			$$.key = NULL;
d2710 6
a2715 4
		| SOURCEHASH hashkey
		{
			$$.type = PF_POOL_SRCHASH;
			$$.key = $2;
d2717 7
a2723 4
		| ROUNDROBIN
		{
			$$.type = PF_POOL_ROUNDROBIN;
			$$.key = NULL;
a2726 4
staticport	: /* empty */			{ $$ = 0; }
		| STATICPORT			{ $$ = 1; }
		;

d2766 1
a2766 2
natrule		: nataction interface af proto fromto tag redirpool pooltype
		  staticport
d2848 3
a2850 1
				if (r.rpool.opts == PF_POOL_NONE)
d2852 4
a2855 4
				if (r.rpool.opts != PF_POOL_ROUNDROBIN)
					if (disallow_table($7->host, "tables "
					    "are only supported in round-robin "
					    "redirection pools"))
d2857 2
a2858 2
				if ($7->host->next) {
					if (r.rpool.opts !=
d2881 4
a2884 1
			if ($9 != 0) {
d3050 1
d3112 1
a3112 1
		| ROUTETO routespec pooltype {
d3115 1
a3115 1
			$$.pool_opts = $3.type;
d3119 1
a3119 1
		| REPLYTO routespec pooltype {
d3122 1
a3122 1
			$$.pool_opts = $3.type;
d3126 1
a3126 1
		| DUPTO routespec pooltype {
d3129 1
a3129 1
			$$.pool_opts = $3.type;
d3143 1
d3160 1
d3177 1
d4069 1
d4087 2
d4123 1
d4127 1
d4130 1
@


1.423
log
@daniel stumbled over a broken regress test, and it turned out that I forgot
to commit a diff from 11/6...
do not insert the "block in on ! interface" rule for antispoof statements when
the interface in question does not have any IP address, because that then
expands to
block in on ! interface all
which is obviously bad.
niklas@@ found it, dhartmei@@ ok, and I think some more ppl ok I don't remember
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.422 2003/11/14 13:51:09 henning Exp $	*/
a3124 4
	if (r->src.port_op == PF_OP_RRG || r->dst.port_op == PF_OP_RRG) {
		yyerror("the ':' port operator only applies to rdr");
		problems++;
	}
a3183 4
	if (r->src.port_op == PF_OP_RRG || r->dst.port_op == PF_OP_RRG) {
		yyerror("the ':' port operator only applies to rdr");
		problems++;
	}
a3219 5
		problems++;
	}
	if (r->src.port_op == PF_OP_RRG) {
		yyerror("the ':' port operator only applies to rdr "
		    "destination port");
@


1.422
log
@allow the debuglevel to  be set from pf.conf (set debug)

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.421 2003/11/08 00:45:34 mcbride Exp $	*/
d820 3
a822 2
				expand_rule(&r, j, NULL, NULL, NULL, h, NULL,
				    NULL, NULL, NULL, NULL, NULL);
@


1.421
log
@Add 'no-sync' state option to prevent state transition messages for states
created by this rule from appearing on the pfsync(4) interface. e.g.

pass in proto tcp to self flags S/SA keep state (no-sync)

ok cedric@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.420 2003/11/06 15:16:50 henning Exp $	*/
d370 1
a370 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS NOSYNC
d493 8
d3943 1
@


1.420
log
@and fix two err() that should be errx() while beeing here
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.419 2003/11/06 15:13:22 henning Exp $	*/
d115 1
a115 1
enum	{ PF_STATE_OPT_MAX=0, PF_STATE_OPT_TIMEOUT=1 };
d370 1
a370 1
%token	REQUIREORDER SYNPROXY FINGERPRINTS
d1411 8
d2409 8
d3969 1
@


1.419
log
@need calloc here
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.418 2003/11/06 14:02:19 henning Exp $	*/
d3316 1
a3316 1
		err(1, "expand_label_str");
d3322 1
a3322 1
			err(1, "expand_label: label too long");
d3327 1
a3327 1
		err(1, "expand_label: label too long");
@


1.418
log
@allow the label macros to be used in tags as well.
the idea is not mine and I'dlove to get credit, but I cannot find the mail
any more :-((

ok canacar@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.417 2003/10/21 21:09:12 itojun Exp $	*/
d3315 1
a3315 1
	if ((tmp = malloc(len)) == NULL)
@


1.417
log
@don't use NULL as (int)0.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.416 2003/09/26 21:44:09 cedric Exp $	*/
d224 8
a231 7
void	expand_label_str(char *, const char *, const char *);
void	expand_label_if(const char *, char *, const char *);
void	expand_label_addr(const char *, char *, u_int8_t, struct node_host *);
void	expand_label_port(const char *, char *, struct node_port *);
void	expand_label_proto(const char *, char *, u_int8_t);
void	expand_label_nr(const char *, char *);
void	expand_label(char *, const char *, u_int8_t, struct node_host *,
d3310 1
a3310 1
expand_label_str(char *label, const char *srch, const char *repl)
d3312 1
a3312 1
	char tmp[PF_RULE_LABEL_SIZE] = "";
d3315 2
d3320 2
a3321 2
		if ((strlcat(tmp, p, sizeof(tmp)) >= sizeof(tmp)) ||
		    (strlcat(tmp, repl, sizeof(tmp)) >= sizeof(tmp)))
d3326 1
a3326 1
	if (strlcat(tmp, p, sizeof(tmp)) >= sizeof(tmp))
d3328 2
a3329 1
	strlcpy(label, tmp, PF_RULE_LABEL_SIZE);	/* always fits */
d3333 1
a3333 1
expand_label_if(const char *name, char *label, const char *ifname)
d3337 1
a3337 1
			expand_label_str(label, name, "any");
d3339 1
a3339 1
			expand_label_str(label, name, ifname);
d3344 1
a3344 1
expand_label_addr(const char *name, char *label, sa_family_t af,
d3390 1
a3390 1
			expand_label_str(label, name, tmp_not);
d3392 1
a3392 1
			expand_label_str(label, name, tmp);
d3397 2
a3398 1
expand_label_port(const char *name, char *label, struct node_port *port)
d3423 1
a3423 1
		expand_label_str(label, name, op);
d3428 1
a3428 1
expand_label_proto(const char *name, char *label, u_int8_t proto)
d3436 1
a3436 1
			expand_label_str(label, name, pe->p_name);
d3439 1
a3439 1
			expand_label_str(label, name, n);
d3445 1
a3445 1
expand_label_nr(const char *name, char *label)
d3451 1
a3451 1
		expand_label_str(label, name, n);
d3456 1
a3456 1
expand_label(char *label, const char *ifname, sa_family_t af,
d3461 7
a3467 7
	expand_label_if("$if", label, ifname);
	expand_label_addr("$srcaddr", label, af, src_host);
	expand_label_addr("$dstaddr", label, af, dst_host);
	expand_label_port("$srcport", label, src_port);
	expand_label_port("$dstport", label, dst_port);
	expand_label_proto("$proto", label, proto);
	expand_label_nr("$nr", label);
d3781 7
a3787 2
		expand_label(r->label, r->ifname, r->af, src_host, src_port,
		    dst_host, dst_port, proto->proto);
@


1.416
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.415 2003/09/01 15:07:40 henning Exp $	*/
d2735 1
a2735 1
			if ($9 != NULL) {
@


1.415
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.414 2003/08/28 19:27:32 kjell Exp $	*/
d4474 1
a4474 1
pfctl_load_anchors(int dev, int opts)
d4483 1
a4483 1
		    la->rulesetname) == -1)
@


1.414
log
@This change is busted. what's worse, REGRESSION TESTS WOULD HAVE CAUGHT IT!
You MUST test nework stack changes on BOTH BYTE-ORDERS.
Someone can fix this later, but right now I need to get the damn
firewall up. Grr.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.412 2003/08/25 17:44:44 dhartmei Exp $	*/
d4376 2
a4377 2
		for(n = nh; n != NULL; n = n->next) {
			if(n->addr.type != PF_ADDR_TABLE) {
@


1.413
log
@catch port/user/group a <>/>< b with a >= b, from mpech@@
@
text
@a1982 4
			if ($1.a >= $3.a) {
				yyerror("port arguments invalid");
				YYERROR;
			}
a2075 4
			if ($1 >= $3) {
				yyerror("user arguments invalid");
				YYERROR;
			}
a2152 4
				YYERROR;
			}
			if ($1 >= $3) {
				yyerror("group arguments invalid");
@


1.412
log
@catch return-rst ttl values > 255, from aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.411 2003/08/24 13:02:28 cedric Exp $	*/
d1983 4
d2080 4
d2161 4
@


1.411
log
@Tweaks:
- Make sure we allow only tables in round-robin pools for routing options,
same as what we do for translation rules.
- Don't reject rules like: "nat on sis0 -> <foo>" because
"no address family is given". This is perfectly valid.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.410 2003/08/22 21:50:34 david Exp $	*/
d1603 4
@


1.410
log
@pf spelling police
ok dhartmei@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.409 2003/08/21 19:12:08 frantzen Exp $	*/
d1452 9
a1461 3
					if (r.rpool.opts == PF_POOL_NONE)
						r.rpool.opts =
						    PF_POOL_ROUNDROBIN;
d4369 11
a4379 3
		yyerror("address family not given and translation "
		    "address expands to multiple address families");
		return (1);
@


1.409
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.408 2003/08/20 16:27:36 henning Exp $	*/
d3593 1
a3593 1
				/* found ourselve in queues */
@


1.408
log
@braindeadness police: catch queues which specify itself as child... 'nuff said
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.407 2003/08/20 13:02:52 henning Exp $	*/
d234 3
a236 3
	    struct node_proto *, struct node_host *, struct node_port *,
	    struct node_host *, struct node_port *, struct node_uid *,
	    struct node_gid *, struct node_icmp *);
d300 1
d308 1
d362 1
a362 1
%token	PASS BLOCK SCRUB RETURN IN OUT LOG LOGALL QUICK ON FROM TO FLAGS
d369 1
a369 1
%token	REQUIREORDER SYNPROXY
d396 1
d482 10
d524 1
a524 1
			expand_rule(&r, $4, NULL, $6,
d541 1
a541 1
			expand_rule(&r, $3, NULL, $5,
d579 1
a579 1
			expand_rule(&r, $3, NULL, $5,
d698 1
a698 1
			expand_rule(&r, $4, NULL, $6,
d811 2
a812 2
				expand_rule(&r, j, NULL, NULL, h, NULL, NULL,
				    NULL, NULL, NULL, NULL);
d826 3
a828 2
					expand_rule(&r, NULL, NULL, NULL, h,
					    NULL, NULL, NULL, NULL, NULL, NULL);
d1370 1
a1370 1
			if ($9.flags.b1 || $9.flags.b2) {
d1376 14
a1389 1
					yyerror("flags only apply to tcp");
d1392 1
d1483 1
a1483 1
			expand_rule(&r, $4, $5.host, $7,
d1747 1
d1749 1
a1749 1
		| from to			{
d1751 24
a1774 1
			$$.dst = $2;
d2745 2
a2746 2
			    $5.src.host, $5.src.port, $5.dst.host, $5.dst.port,
			    0, 0, 0);
d3709 4
a3712 4
    struct node_proto *protos, struct node_host *src_hosts,
    struct node_port *src_ports, struct node_host *dst_hosts,
    struct node_port *dst_ports, struct node_uid *uids,
    struct node_gid *gids, struct node_icmp *icmp_types)
d3732 1
d3805 11
d3840 1
a3840 1
	)))))))));
d3846 1
d3904 1
d3935 1
@


1.407
log
@err out nicer on errors in queue def
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.406 2003/08/18 11:08:10 dhartmei Exp $	*/
d3587 6
@


1.406
log
@catch max-mss values > 65535, report by Gregory Steuck
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.405 2003/08/09 14:56:48 cedric Exp $	*/
d1005 2
a1006 1
			    &$4.scheduler))
d1008 1
@


1.405
log
@This patch remove the restriction that tables cannot be used in routing or
redirection rules...

The advantage of using tables in redirection/routing rules is not efficiency,
in fact it will run slower than straight address pools. However, this brings
a lot of flexibility to PF, allowing simple scripts/daemons to add/remove
addresses from redirection/routing pools easily.

This implementation support all table features, including cidr blocks and
negated addresses. So specifying { 10.0.0.0/29 !10.0.0.0 !10.0.0.7 } will
correctly round-robin between the six addresses: .1, .2, .3, .4, .5, .6.

Tables can also be combined with simple addresses, so the following rule
will work as expected: "nat on foo0 -> { 1.1.1.1 <bar> }"

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.404 2003/07/29 18:47:43 deraadt Exp $	*/
d728 4
@


1.404
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.403 2003/07/19 13:08:58 cedric Exp $	*/
a2595 4
				if (disallow_table($7->host, "invalid use of "
				    "table <%s> as the redirection address "
				    "of a translation rule"))
					YYERROR;
d2635 8
a2643 4
					r.rpool.opts = $8.type;
					if (r.rpool.opts == PF_POOL_NONE)
						r.rpool.opts =
						    PF_POOL_ROUNDROBIN;
a2658 7
					} else {
						if ($8.type == PF_POOL_NONE)
							r.rpool.opts =
							    PF_POOL_ROUNDROBIN;
						else
							r.rpool.opts =
							    $8.type;
a2861 3
			if (disallow_table($3, "invalid use of table <%s> in "
			    "a route expression"))
				YYERROR;
@


1.403
log
@Simplify struct pf_pooladdr to include struct pf_addr_wrap directly
instead of indirectly trough struct pf_rule_addr.

Ryan McBride says:
If I'm not mistaken, the code _used_ to use the ports in pf_rule_addr as
well. The code was changed to fix some of the bugs with port ranges, but
it was too late in the release cycle to make kernel API changes, so the
structure was left as is.

Needless to say: KERNEL/USERLAND SYNC REQUIRED.

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.402 2003/07/18 06:30:06 cedric Exp $	*/
d1779 1
a1779 1
		$$ = calloc(1, sizeof(struct node_host));
@


1.402
log
@Simplify handling of flags (-R, -N...). Remove PFCTL_FLAG_ALL.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.401 2003/07/15 17:12:38 cedric Exp $	*/
d2826 1
a2826 1
				pa->addr.addr = $12->host->addr;
d3110 1
a3110 1
			if (pa->addr.addr.type == PF_ADDR_DYNIFTL) {
d3159 1
a3159 1
				if (pa->addr.addr.type == PF_ADDR_DYNIFTL) {
d3755 1
a3755 1
			pa->addr.addr = h->addr;
@


1.401
log
@Repair memory managment in table parsing code.
I need vacations.
Found and verified by Pyun YongHyeon.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.400 2003/07/14 20:01:07 dhartmei Exp $	*/
d863 1
a863 1
			if (pf->loadopt & (PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL))
d3418 1
a3418 1
	if ((pf->loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) == 0) {
d3526 1
a3526 1
	if ((pf->loadopt & (PFCTL_FLAG_ALTQ | PFCTL_FLAG_ALL)) == 0) {
@


1.400
log
@tpo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.399 2003/07/11 08:29:34 cedric Exp $	*/
d855 3
d866 11
@


1.399
log
@Better parsing and -v support for tables:

  - remove the tableaddrs and tableaddr yacc production and reuse
    host_list instead.
  - produce better error messages.
  - do not load addresses from external file when it is not
    required (like with -R option).
  - store initializers in a new node_tinit linked list before
    putting them into the address buffer (see next point).
  - add a new print_tabledef() function, which makes "pfctl -nvf"
    print something useful for table definitions, which in turn
    makes it possible to write better regress tests (see first chunk
    of the diff) and bring table definition consistant with other
    parsed rules.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.398 2003/07/10 05:25:27 cedric Exp $	*/
d672 1
a672 1
					yyerror("reassmble tcp rules can not "
@


1.398
log
@Fix merging of host lists.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.397 2003/07/04 11:05:44 henning Exp $	*/
d211 1
d222 1
d860 3
a862 9
			if (pfctl_define_table($3, $5.flags, $5.init_addr,
			    (pf->opts & PF_OPT_NOACTION) || !(pf->loadopt &
				(PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)),
			    pf->anchor, pf->ruleset, pf->ab, pf->tticket)) {
				yyerror("cannot define table %s: %s", $3,
				    pfr_strerror(errno));
				YYERROR;
			}
			pf->tdirty = 1;
d868 1
d875 1
d884 1
a884 2
table_opt	: STRING
			{
d892 4
a895 11
		| '{' tableaddrs '}'	{ table_opts.init_addr = 1; }
		| FILENAME STRING	{
			if (pfr_buf_load(pf->ab, $2, 0, append_addr)) {
				if (errno)
					yyerror("cannot load %s: %s", $2,
					    pfr_strerror(errno));
					YYERROR;
			}
			table_opts.init_addr = 1;
		}
		;
d897 19
a915 8
tableaddrs	: /* empty */
		| tableaddrs tableaddr comma

tableaddr	: not STRING {
			if (append_addr_not(pf->ab, $2, 0, $1)) {
				if (errno)
					yyerror("cannot add %s: %s", $2,
					    pfr_strerror(errno));
d918 6
d925 2
a926 2
		| not STRING '/' number {
			char *buf = NULL;
d928 6
a933 13
			if (asprintf(&buf, "%s/%d", $2, $4) < 0) {
				if (errno)
					yyerror("cannot add %s/%d: %s", $2, $4,
					    strerror(errno));
                                YYERROR;
			} else if (append_addr_not(pf->ab, buf, 0, $1)) {
				if (errno)
					yyerror("cannot add %s: %s", buf,
					    pfr_strerror(errno));
				free(buf);
				YYERROR;
			}
			free(buf);
d1765 1
a1765 1
			$$ = calloc(1, sizeof(struct node_host));
d3155 44
@


1.397
log
@KNF after cedric (grmpf)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.396 2003/07/04 10:42:16 henning Exp $	*/
a1744 1
			/* $3 may be a list, so use its tail pointer */
d1750 1
a1750 1
				$1->tail->next = $3->tail;
d2399 1
a2399 2
			/* $3 may be a list, so use its tail pointer */
			$1->tail->next = $3->tail;
d2870 1
a2870 2
			/* $3 may be a list, so use its tail pointer */
			$1->tail->next = $3->tail;
@


1.396
log
@allow for a "pass" modifier on translation rules:
nat pass on $ext_if from $a to $b -> $ext_if
when the pass modifier is given, the filter ruleset is _not_ evaluated but
the packets matching this translation rule are passed unconditionally.

ok dhartmei@@ cedric@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.395 2003/07/03 21:09:13 cedric Exp $	*/
d864 1
a864 1
				YYERROR;				
d897 1
a897 1
			if(pfr_buf_load(pf->ab, $2, 0, append_addr)) {
d899 3
a901 3
                        		yyerror("cannot load %s: %s", $2,
                        		    pfr_strerror(errno));
                        	YYERROR;
d920 1
a920 1
                        
@


1.395
log
@Bye bye atexit(), bye bye globals...
The pfctl.c part will probably need some further improvements.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.394 2003/07/03 09:13:05 cedric Exp $	*/
d376 1
a376 1
%type	<v.number>		tos not yesno
d2519 5
a2523 1
nataction	: no NAT {
d2529 1
d2531 1
a2531 1
		| no RDR {
d2537 1
d2552 1
d2688 1
a2688 1
binatrule	: no BINAT interface af proto FROM host TO ipspec tag
d2703 8
a2710 7
			binat.af = $4;
			if (!binat.af && $7 != NULL && $7->af)
				binat.af = $7->af;
			if (!binat.af && $9 != NULL && $9->af)
				binat.af = $9->af;
			if (!binat.af && $11 != NULL && $11->host)
				binat.af = $11->host->af;
d2717 2
a2718 2
			if ($3 != NULL) {
				memcpy(binat.ifname, $3->ifname,
d2720 1
a2720 1
				free($3);
d2722 2
a2723 2
			if ($10 != NULL)
				if (strlcpy(binat.tagname, $10,
d2730 3
a2732 3
			if ($5 != NULL) {
				binat.proto = $5->proto;
				free($5);
d2735 1
a2735 1
			if ($7 != NULL && disallow_table($7, "invalid use of "
d2738 2
a2739 2
			if ($11 != NULL && $11->host != NULL && disallow_table(
			    $11->host, "invalid use of table <%s> as the "
d2743 2
a2744 2
			if ($7 != NULL) {
				if ($7->next) {
d2748 3
a2750 3
				if ($7->addr.type == PF_ADDR_DYNIFTL)
					$7->af = binat.af;
				if ($7->af != binat.af) {
d2754 1
a2754 1
				if (check_netmask($7, binat.af))
d2756 1
a2756 1
				memcpy(&binat.src.addr, &$7->addr,
d2758 1
a2758 1
				free($7);
d2760 2
a2761 2
			if ($9 != NULL) {
				if ($9->next) {
d2765 1
a2765 1
				if ($9->af != binat.af && $9->af) {
d2769 1
a2769 1
				if (check_netmask($9, binat.af))
d2771 1
a2771 1
				memcpy(&binat.dst.addr, &$9->addr,
d2773 2
a2774 2
				binat.dst.not = $9->not;
				free($9);
d2778 1
a2778 1
				if ($11 != NULL) {
d2784 1
a2784 1
				if ($11 == NULL || $11->host == NULL) {
d2790 2
a2791 2
				remove_invalid_hosts(&$11->host, &binat.af);
				if (invalid_redirect($11->host, binat.af))
d2793 1
a2793 1
				if ($11->host->next != NULL) {
d2798 1
a2798 1
				if (check_netmask($11->host, binat.af))
d2804 1
a2804 1
				    &$11->host->addr.v.a.mask, binat.af)) {
d2814 1
a2814 1
				pa->addr.addr = $11->host->addr;
d2819 1
a2819 1
				free($11);
@


1.394
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.393 2003/06/19 22:08:35 deraadt Exp $	*/
d861 1
a861 1
				pf->anchor, pf->ruleset, pf->ab)) {
d866 1
@


1.393
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.392 2003/06/18 11:38:19 henning Exp $	*/
d858 1
a858 1
			pfctl_define_table($3, $5.flags, $5.init_addr,
d861 5
a865 1
				pf->anchor, pf->ruleset);
d896 6
a901 1
			pfctl_append_file($2);
d910 6
a915 1
			pfctl_append_addr($2, -1, $1);
d918 15
a932 1
			pfctl_append_addr($2, $4, $1);
@


1.392
log
@change expand_label_addr() to use a switch (h->addr.type) instead of
if .. else if .. else, and handle PF_ADDR_NOROUTE as well.
inspired by a comment from cedric.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.391 2003/06/18 11:04:14 henning Exp $	*/
d2960 1
@


1.391
log
@when expanding the $srcaddr/$dstaddr label macros and the address is actually
a table refernence, don't print nonsense but the table name.
found by claudio jeker, fix by me, agreement by cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.390 2003/06/09 11:14:46 mcbride Exp $	*/
d3195 2
a3196 1
		if (h->addr.type == PF_ADDR_DYNIFTL)
d3198 2
a3199 1
		else if (h->addr.type == PF_ADDR_TABLE)
d3201 8
a3208 10
		else if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
		    PF_AZERO(&h->addr.v.a.mask, af)))
			snprintf(tmp, sizeof(tmp), "any");
		else {
			char	a[48];
			int	bits;

			if (inet_ntop(af, &h->addr.v.a.addr, a, sizeof(a)) ==
			    NULL)
				snprintf(tmp, sizeof(tmp), "?");
d3210 16
a3225 7
				bits = unmask(&h->addr.v.a.mask, af);
				if ((af == AF_INET && bits < 32) ||
				    (af == AF_INET6 && bits < 128))
					snprintf(tmp, sizeof(tmp), "%s/%d",
					    a, bits);
				else
					snprintf(tmp, sizeof(tmp), "%s", a);
d3227 4
@


1.390
log
@Attempt to resolve byte order confusion in nat code once and for all.

- pf_get_sport() leaves the translated port in the packet in network byte order
- merge code for the p1=0 p2=0 case and static-port case in pr_get_sport()

NOTE: people who use the static-port keyword in their pf.conf need to make sure pfctl is updated along with their kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.389 2003/05/25 17:07:28 henning Exp $	*/
d3197 2
@


1.389
log
@must not run check_netmask() before remove_invalid_hosts() - binat case had it
wrong for the redirection target.
reported by jared r r spiegel <jrrs@@ice-nine.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.388 2003/05/19 20:21:53 henning Exp $	*/
d2470 1
a2470 1
		| STATICPORT			{ $$ = PF_POOL_STATICPORT; }
d2627 1
a2627 3
				if (r.action == PF_NAT)
					r.rpool.opts |= PF_POOL_STATICPORT;
				else {
d2632 11
@


1.388
log
@reject invalid netmasks like 10.0.0.0/68, and fix up the netmask for
dynaddr rules after we know the address family

ok dhartmei@@, inspired by a session with bob
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.387 2003/05/19 18:31:13 henning Exp $	*/
a2695 2
			if ($11 != NULL && check_netmask($11->host, binat.af))
				YYERROR;
d2752 2
@


1.387
log
@all host() receivers have to test for NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.386 2003/05/19 18:18:34 henning Exp $	*/
d2558 2
d2696 2
d2710 2
d2725 2
d3596 4
@


1.386
log
@if host() returns NULL, it is an error, so err the fuck out and don't
load bullshit
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.385 2003/05/17 02:04:24 henning Exp $	*/
a1731 6
			if ($2 == NULL)	{
				/* error. "any" is handled elsewhere */
				yyerror("could not parse host specification");
				YYERROR;
			}

d1746 8
a1753 1
host		: STRING			{ $$ = host($1); }
d1759 6
a1764 1
			$$ = host(buf);
@


1.385
log
@support inverse matching on tags like
block in ! tagged sometag

ok dhartmei@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.384 2003/05/16 17:15:17 dhartmei Exp $	*/
d1731 6
@


1.384
log
@TCP SYN proxy. Instead of 'keep state' or 'modulate state', one can use
'synproxy state' for TCP connections. pf will complete the TCP handshake
with the active endpoint before passing any packets to the passive end-
point, preventing spoofed SYN floods from reaching the passive endpoint.

No additional memory requirements, no cookies needed, random initial
sequence numbers, uses the existing sequence number modulators to translate
packets after the handshakes.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.383 2003/05/15 06:22:46 henning Exp $	*/
d174 1
d1301 1
d1494 3
a1496 2
		| TAGGED string			{
			filter_opts.match_tag = $2;
@


1.383
log
@properly complain about too long tags
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.382 2003/05/14 23:51:28 frantzen Exp $	*/
d364 1
a364 1
%token	REQUIREORDER
d2248 4
d2980 4
a2983 3
	if (r->keep_state == PF_STATE_MODULATE && r->proto &&
	    r->proto != IPPROTO_TCP) {
		yyerror("modulate state can only be applied to TCP rules");
d3751 1
@


1.382
log
@add scrub modifier "reassemble tcp" to turn on stateful TCP normalizations
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.381 2003/05/14 22:54:39 henning Exp $	*/
d1287 6
a1292 1
				strlcpy(r.tagname, $9.tag, PF_TAG_NAME_SIZE);
d1294 6
a1299 2
				strlcpy(r.match_tagname, $9.match_tag,
				    PF_TAG_NAME_SIZE);
d2510 6
a2515 1
				strlcpy(r.tagname, $6, PF_TAG_NAME_SIZE);
d2656 6
a2661 1
				strlcpy(binat.tagname, $10, PF_TAG_NAME_SIZE);
@


1.381
log
@tagging on binat
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.379 2003/05/14 05:14:06 henning Exp $	*/
d190 1
d362 1
a362 1
%token	FRAGNORM FRAGDROP FRAGCROP ANCHOR NATANCHOR RDRANCHOR BINATANCHOR
d667 8
d738 9
d756 1
a756 1
fragcache	: FRAGMENT FRAGNORM	{ $$ = 0; /* default */ }
d3713 1
a3713 1
		{ "reassemble",		FRAGNORM},
@


1.380
log
@enabled tagging on rdr rules
@
text
@d2590 2
a2591 1
binatrule	: no BINAT interface af proto FROM host TO ipspec redirection
d2610 2
a2611 2
			if (!binat.af && $10 != NULL && $10->host)
				binat.af = $10->host->af;
d2623 3
d2634 2
a2635 2
			if ($10 != NULL && $10->host != NULL && disallow_table(
			    $10->host, "invalid use of table <%s> as the "
d2670 1
a2670 1
				if ($10 != NULL) {
d2676 1
a2676 1
				if ($10 == NULL || $10->host == NULL) {
d2682 2
a2683 2
				remove_invalid_hosts(&$10->host, &binat.af);
				if (invalid_redirect($10->host, binat.af))
d2685 1
a2685 1
				if ($10->host->next != NULL) {
d2694 1
a2694 1
				    &$10->host->addr.v.a.mask, binat.af)) {
d2704 1
a2704 1
				pa->addr.addr = $10->host->addr;
d2709 1
a2709 1
				free($10);
@


1.379
log
@with tag/tagged given, only whine about missing keep state on pass rules
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.378 2003/05/14 05:02:12 frantzen Exp $	*/
a3039 4
	}
	if (r->tagname[0]) {
		yyerror("tagging on rdr rules is not supported yet");
		problems++;
@


1.378
log
@allow SCRUB rules to specify protocol again.  broken sometime in the past.
okie dhartmei@@, yay pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.377 2003/05/14 04:53:04 henning Exp $	*/
d2963 2
a2964 1
	if ((r->tagname[0] || r->match_tagname[0]) && !r->keep_state) {
@


1.377
log
@tags on nat rules:
nat on $ext_if all tag humppa -> $ext_if
pass out tagged hummpa keep state
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.376 2003/05/13 23:02:15 henning Exp $	*/
d636 1
a636 1
scrubrule	: SCRUB dir logquick interface af fromto scrub_opts
d662 1
a662 1
			if ($7.nodf)
d664 1
a664 1
			if ($7.randomid)
d666 6
a671 6
			if ($7.minttl)
				r.min_ttl = $7.minttl;
			if ($7.maxmss)
				r.max_mss = $7.maxmss;
			if ($7.fragcache)
				r.rule_flag |= $7.fragcache;
d673 2
a674 2
			expand_rule(&r, $4, NULL, NULL,
			    $6.src.host, $6.src.port, $6.dst.host, $6.dst.port,
@


1.376
log
@make sure tagging is only ever used with stateful filter rules
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.375 2003/05/13 21:15:07 henning Exp $	*/
d395 1
a395 1
%type	<v.string>		label string
d2460 1
a2460 1
natrule		: nataction interface af proto fromto redirpool pooltype
d2482 3
d2486 1
a2486 1
				if ($6 != NULL) {
d2492 1
a2492 1
				if ($6 == NULL || $6->host == NULL) {
d2497 1
a2497 1
				if (disallow_table($6->host, "invalid use of "
d2501 2
a2502 2
				if (!r.af && ! $6->host->ifindex)
					r.af = $6->host->af;
d2504 2
a2505 2
				remove_invalid_hosts(&$6->host, &r.af);
				if (invalid_redirect($6->host, r.af))
d2508 1
a2508 1
				r.rpool.proxy_port[0] = ntohs($6->rport.a);
d2512 1
a2512 1
					if (!$6->rport.b && $6->rport.t &&
d2515 1
a2515 1
						    ntohs($6->rport.a) +
d2520 1
a2520 1
						    ntohs($6->rport.b);
d2523 1
a2523 1
					r.rpool.proxy_port[1] = ntohs($6->rport.b);
d2538 2
a2539 2
				if ($6->host->next) {
					r.rpool.opts = $7.type;
d2552 1
a2552 1
					    unmask(&$6->host->addr.v.a.mask,
d2555 1
a2555 1
					    unmask(&$6->host->addr.v.a.mask,
d2559 1
a2559 1
						if ($7.type == PF_POOL_NONE)
d2564 1
a2564 1
							    $7.type;
d2569 2
a2570 2
			if ($7.key != NULL)
				memcpy(&r.rpool.key, $7.key,
d2573 1
a2573 1
			if ($8 != NULL) {
d2583 1
a2583 1
			expand_rule(&r, $2, $6 == NULL ? NULL : $6->host, $4,
d2586 1
a2586 1
			free($6);
d2712 3
d3039 4
@


1.375
log
@userland part for tagging.
it's now possible to tag packets with an arbitary tag and filter based on
that tag later on other interfaces:
pass in quick on fxp0 keep state tag blah
pass out quick on wi0 keep state with tag blah
can be used to express trust between interfaces, to distinguish between
NATed connections and connection originating from teh firewall itself
and much more

ok dhartmei@@ frantzen@@ pb@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.374 2003/05/11 01:48:50 mcbride Exp $	*/
d2955 4
@


1.374
log
@Don't ntohs() the translation port for nat as it is already in host byte order.
Makes nat ... -> $ext_if port 500 rules work correctly again.

ok henning@@ dhartemi@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.373 2003/05/10 00:45:23 henning Exp $	*/
d172 2
d369 1
d1268 5
d1462 6
d3695 2
@


1.373
log
@support loading of anchors from within the main ruleset via
load anchor anchorname:rulesetname file /path/to/file

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.372 2003/05/03 16:50:38 henning Exp $	*/
d2515 1
a2515 1
						    ntohs(r.rpool.proxy_port[0]);
@


1.372
log
@don't free() the char * carrying the rule label too early
noticed by Mathieu Sauve-Frankel <m.sauve at secureops.net> via silc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.371 2003/05/01 16:22:12 henning Exp $	*/
d265 9
d366 1
d419 1
d596 37
d3637 1
d3925 6
d3933 10
a3942 7
	/* Check which macros have not been used. */
	if (pf->opts & PF_OPT_VERBOSE2)
		for (sym = TAILQ_FIRST(&symhead); sym;
		    sym = TAILQ_NEXT(sym, entries))
			if (!sym->used)
				fprintf(stderr, "warning: macro '%s' not "
				    "used\n", sym->nam);
d4167 18
@


1.371
log
@ease label handling

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.370 2003/05/01 16:16:08 henning Exp $	*/
d741 1
d1221 1
a1221 1

a4077 1
			free(s);
a4079 1
		free(s);
@


1.370
log
@allow label on antispoof; requested by Gregor Binder <gbinder at sysfive.com>

ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.369 2003/04/30 12:30:27 cedric Exp $	*/
d245 1
d708 2
a709 12
				if ($5.label) {
					if (strlcpy(r.label, $5.label,
					    sizeof(r.label)) >=
					    sizeof(r.label)) {
						yyerror("rule label too long "
						    "(max %d chars)",
						    sizeof(r.label)-1);
						YYERROR;
					}
					free($5.label);
				}

d733 2
a734 12
					if ($5.label) {
						if (strlcpy(r.label, $5.label,
						    sizeof(r.label)) >=
						    sizeof(r.label)) {
							yyerror("rule label too"
							    " long (max %d"
							    " chars)",
							    sizeof(r.label)-1);
							YYERROR;
						}
						free($5.label);
					}
d1218 2
a1280 1

a1300 11

			if ($9.label) {
				if (strlcpy(r.label, $9.label,
				    sizeof(r.label)) >= sizeof(r.label)) {
					yyerror("rule label too long (max "
					    "%d chars)", sizeof(r.label)-1);
					YYERROR;
				}
				free($9.label);
			}

d4067 16
@


1.369
log
@Allow tables to be loaded into anchors.
Most pfctl table commands (excluding 'show' and 'flush') support the "-a"
modifier.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.368 2003/04/25 17:36:33 dhartmei Exp $	*/
d174 4
d321 1
d394 1
d691 1
a691 1
antispoof	: ANTISPOOF logquick antispoof_ifspc af {
d700 1
a700 1
				memset(&r, 0, sizeof(r));
d707 11
d735 1
a735 1
					memset(&r, 0, sizeof(r));
d742 12
a753 1

a755 1

d772 22
@


1.368
log
@Properly copy the second part of nat proxy port range, when specified.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.367 2003/04/15 11:29:24 henning Exp $	*/
d759 2
a760 1
				(PFCTL_FLAG_TABLE | PFCTL_FLAG_ALL)));
@


1.367
log
@pass down the unparsed queue opts (struct node_queue_opt) to
print_altq/print_hfsc -> print_hfsc_opts and extract struct node_hfsc_sc
there for each service curve and pass those down to print_hfsc_sc. now
bandwidth specifications in the service curves are printed correct in the
case of a queue belonging to more than one interface/parent queue, the
parent queues having different bandwidths and the bandwith on teh service
curve beeing specified in percent.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.366 2003/04/14 14:50:46 henning Exp $	*/
d2436 1
@


1.366
log
@let print_altq and print_queue take a struct node_queue_bw parameter instead
of dintinct bw_percent
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.365 2003/04/13 23:51:51 henning Exp $	*/
d3160 1
a3160 1
				    &bwspec);
d3339 2
a3340 1
					    &bwspec, interface->ifname[0] != 0);
@


1.365
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.364 2003/04/13 23:39:18 henning Exp $	*/
d3160 1
a3160 1
				    bwspec.bw_percent);
d3339 1
a3339 2
					    bwspec.bw_percent,
					    interface->ifname[0] != 0);
@


1.364
log
@prevent double service curve specification
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.363 2003/04/13 23:34:31 henning Exp $	*/
d1048 1
a1048 1
hfscopts_list	: hfscopts_item	
d1067 1
a1067 1
		 	hfsc_opts.linkshare.m2 = $5;
@


1.363
log
@add support for the HFSC linkshare, realtime, and upperlimit service curves
to be specified.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1071 4
d1079 4
d1089 4
d1097 4
@


1.362
log
@unbreak (missing })
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.361 2003/04/13 21:51:10 henning Exp $	*/
d205 2
d349 1
a349 1
%token	ALTQ CBQ PRIQ HFSC BANDWIDTH TBRSIZE
d386 1
a386 1
%type	<v.hfsc_opts>		hfscopts_list hfscopts_item
d991 1
a991 1
		| HFSC '(' hfscopts_list ')'	{
d993 1
a993 2
			memcpy(&$$.data.hfsc_opts, &$3,
			    sizeof(struct node_hfsc_opts));
d1039 6
a1044 5
hfscopts_list	: hfscopts_item				{
			$$.flags |= $1.flags;
		}
		| hfscopts_list comma hfscopts_item	{
			$$.flags |= $3.flags;
d1048 43
a1090 1
hfscopts_item	: STRING	{
d1092 1
a1092 1
				$$.flags = HFCF_DEFAULTCLASS;
d1094 1
a1094 1
				$$.flags = HFCF_RED;
d1096 1
a1096 1
				$$.flags = HFCF_RED|HFCF_ECN;
d1098 1
a1098 1
				$$.flags = HFCF_RIO;
d3549 1
d3577 1
d3598 1
@


1.361
log
@say bye bye to hfscflags_list and hfscflags_item
welcome hfscopts_list and hfscopts_item, returning a full struct
node_hfsc_opt instead of just an int for the flags. needed because of all
the opts hfsc knows
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.360 2003/04/13 20:41:37 henning Exp $	*/
d1043 1
@


1.360
log
@new struct node_hfsc_opts for, surprise, hfsc options. needed because they
contain bandwidth specifications and we need to carry the unprocessed bw
specs around for quite some time until we can break them down to absolute
values.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.359 2003/04/13 20:16:06 henning Exp $	*/
d318 1
d384 1
a384 1
%type	<v.number>		hfscflags_list hfscflags_item
d989 1
a989 1
		| HFSC '(' hfscflags_list ')'	{
d991 2
a992 1
			$$.data.hfsc_opts.flags = $3;
d1038 5
a1042 2
hfscflags_list	: hfscflags_item			{ $$ |= $1; }
		| hfscflags_list comma hfscflags_item	{ $$ |= $3; }
d1045 1
a1045 1
hfscflags_item	: STRING	{
d1047 1
a1047 1
				$$ = HFCF_DEFAULTCLASS;
d1049 1
a1049 1
				$$ = HFCF_RED;
d1051 1
a1051 1
				$$ = HFCF_RED|HFCF_ECN;
d1053 1
a1053 1
				$$ = HFCF_RIO;
@


1.359
log
@pass down the struct node_queue_opts from the altqif/queuespec yacc targets
to expand_altq/expand_queue -> eval_pfaltq/eval_pfqueue and
further down to the new eval_queue_opts() instead of evaluating them directly
in the yacc grammar.
this will be needed to process the hfsc options which can contain relative
bandwidth specifications, and we can't break them down to an absolute one
earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.358 2003/04/13 19:36:00 henning Exp $	*/
d985 2
a986 1
			$$.data.hfsc_opts.flags = 0;
@


1.358
log
@move the structs node_queue_bw and node_queue_opt to pfctl_parser.h.
let eval_pfqueue() and eval_pfaltq() take a pointer to a struct
node_queue_bw instead of two distince bw_absolute and bw_percent parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.357 2003/04/13 17:01:12 henning Exp $	*/
d226 1
a226 1
	    struct node_queue_bw bwspec);
d228 1
a228 1
	    struct node_queue_bw);
a814 16
			switch (a.scheduler) {
			case ALTQT_CBQ:
				a.pq_u.cbq_opts =
				    $3.scheduler.data.cbq_opts;
				break;
			case ALTQT_PRIQ:
				a.pq_u.priq_opts =
				    $3.scheduler.data.priq_opts;
				break;
			case ALTQT_HFSC:
				a.pq_u.hfsc_opts =
				    $3.scheduler.data.hfsc_opts;
				break;
			default:
				break;
			}
d821 2
a822 1
			if (expand_altq(&a, $2, $5, $3.queue_bwspec))
d852 2
a853 17
			switch (a.scheduler) {
			case ALTQT_CBQ:
				a.pq_u.cbq_opts =
				    $4.scheduler.data.cbq_opts;
				break;
			case ALTQT_PRIQ:
				a.pq_u.priq_opts =
				    $4.scheduler.data.priq_opts;
				break;
			case ALTQT_HFSC:
				a.pq_u.hfsc_opts =
				    $4.scheduler.data.hfsc_opts;
				break;
			default:
				break;
			}
			if (expand_queue(&a, $3, $5, $4.queue_bwspec))
d3060 2
a3061 1
    struct node_queue *nqueues, struct node_queue_bw bwspec)
d3085 1
a3085 1
			if (eval_pfaltq(pf, &pa, &bwspec))
a3123 4
				if (pa.scheduler == ALTQT_CBQ)
					pb.pq_u.cbq_opts = pa.pq_u.cbq_opts;
				if (pa.scheduler == ALTQT_HFSC)
					pb.pq_u.hfsc_opts = pa.pq_u.hfsc_opts;
d3126 1
a3126 1
				if (eval_pfqueue(pf, &pb, &bw))
d3169 2
a3170 1
    struct node_queue *nqueues, struct node_queue_bw bwspec)
d3235 1
a3235 1
				if (eval_pfqueue(pf, &pa, &bwspec))
@


1.357
log
@move the bandwidth keyword from within the bandwidth target up to the
queue_opts target so the bandwidth parser can be used for other things too;
will be needed for hfsc's linkshare etc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.356 2003/04/12 20:10:32 henning Exp $	*/
a142 14
struct node_queue_opt {
	int			 qtype;
	union {
		struct cbq_opts		cbq_opts;
		struct priq_opts	priq_opts;
		struct hfsc_opts	hfsc_opts;
	}			 data;
};

struct node_queue_bw {
	u_int32_t	bw_absolute;
	u_int16_t	bw_percent;
};

d3095 1
d3114 1
a3114 2
			if (eval_pfaltq(pf, &pa, bwspec.bw_absolute,
			    bwspec.bw_percent))
d3157 3
a3159 1
				if (eval_pfqueue(pf, &pb, pa.ifbandwidth, 0))
d3267 1
a3267 2
				if (eval_pfqueue(pf, &pa, bwspec.bw_absolute,
				    bwspec.bw_percent))
@


1.356
log
@initial support for the HFSC scheduler.
whoever uses that for more than toying around is on drugs. it's far from done.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.355 2003/04/11 15:19:10 henning Exp $	*/
d925 1
a925 1
queue_opt	: bandwidth	{
d931 1
a931 1
			queue_opts.queue_bwspec = $1;
d979 1
a979 1
bandwidth	: BANDWIDTH STRING {
d985 1
a985 1
			bps = strtod($2, &cp);
@


1.355
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.354 2003/04/11 14:42:32 henning Exp $	*/
d148 1
d360 1
a360 1
%token	ALTQ CBQ PRIQ BANDWIDTH TBRSIZE
d397 1
d838 4
d890 4
d1027 8
d1079 20
d3149 2
a3150 1
			if (pa.scheduler == ALTQT_CBQ) {
d3167 4
a3170 1
				pb.pq_u.cbq_opts = pa.pq_u.cbq_opts;
d3182 2
a3183 1
				if (pa.scheduler == ALTQT_CBQ)
d3534 1
@


1.354
log
@don't set r->qid and r->pqid in expand_rule any more, queue name -> queue ID
mapping is done in kernel land now
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.353 2003/04/07 13:40:48 dhartmei Exp $	*/
d3243 1
a3243 1
				for(nq = nqueues; nq != NULL; nq = nq->next) {
@


1.353
log
@Catch and refuse invalid icmp codes (> 255). ok pb@@, mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.352 2003/04/05 23:56:32 henning Exp $	*/
a3365 3
		r->qid = qname_to_qid(r->qname);
		if ((r->pqid = qname_to_qid(r->pqname)) == 0)
			r->pqid = r->qid;
@


1.352
log
@ease netmask handling a bit

input theo, ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.351 2003/04/05 21:44:45 henning Exp $	*/
d3999 4
@


1.351
log
@allow queue specs to be limited to certain interfaces.

altq on { $if0 $if1 $if2 $if3 } priq bandwidth 10Mb queue { one two }
queue one priority 1 priq(default)
queue two on $if0 priority 15
queue two on ! $if0 priority 0

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.350 2003/04/05 21:04:53 henning Exp $	*/
d1571 9
a1579 2
host		: STRING			{ $$ = host($1, -1); }
		| STRING '/' number		{ $$ = host($1, $3); }
@


1.350
log
@whitespace KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.349 2003/04/04 18:48:11 henning Exp $	*/
d240 1
a240 1
int	expand_queue(struct pf_altq *, struct node_queue *,
d850 1
a850 1
queuespec	: QUEUE STRING queue_opts qassign {
d864 1
a864 1
			if ($3.tbrsize) {
d868 1
a868 1
			if ($3.priority > 255) {
d872 3
a874 3
			a.priority = $3.priority;
			a.qlimit = $3.qlimit;
			a.scheduler = $3.scheduler.qtype;
d878 1
a878 1
				    $3.scheduler.data.cbq_opts;
d882 1
a882 1
				    $3.scheduler.data.priq_opts;
d887 1
a887 1
			if (expand_queue(&a, $4, $3.queue_bwspec))
d3163 2
a3164 2
expand_queue(struct pf_altq *a, struct node_queue *nqueues,
    struct node_queue_bw bwspec)
d3166 1
a3166 1
	struct node_queue	*n;
d3182 17
a3198 21
	LOOP_THROUGH(struct node_queue, tqueue, queues,
		if (!strncmp(a->qname, tqueue->queue, PF_QNAME_SIZE)) {
			/* found ourselve in queues */
			found++;

			memcpy(&pa, a, sizeof(struct pf_altq));

			if (pa.scheduler != ALTQT_NONE &&
			    pa.scheduler != tqueue->scheduler) {
				yyerror("exactly one scheduler type per "
				    "interface allowed");
				return (1);
			}
			pa.scheduler = tqueue->scheduler;

			/* scheduler dependent error checking */
			switch (pa.scheduler) {
			case ALTQT_PRIQ:
				if (nqueues != NULL) {
					yyerror("priq queues cannot have "
					    "child queues");
d3201 19
a3219 4
				if (bwspec.bw_absolute > 0 ||
				    bwspec.bw_percent < 100) {
					yyerror("priq doesn't take bandwidth");
					return (1);
a3220 4
				break;
			default:
				break;
			}
d3222 6
a3227 6
			if (strlcpy(pa.ifname, tqueue->ifname,
			    sizeof(pa.ifname)) >= sizeof(pa.ifname))
				errx(1, "expand_queue: strlcpy");
			if (strlcpy(pa.parent, tqueue->parent,
			    sizeof(pa.parent)) >= sizeof(pa.parent))
				errx(1, "expand_queue: strlcpy");
d3229 2
a3230 5
			if (eval_pfqueue(pf, &pa, bwspec.bw_absolute,
			    bwspec.bw_percent))
				errs++;
			else
				if (pfctl_add_altq(pf, &pa))
d3232 3
d3236 43
a3278 24
			if (nqueues == NULL)
				continue;

			LOOP_THROUGH(struct node_queue, queue, nqueues,
				n = calloc(1, sizeof(struct node_queue));
				if (n == NULL)
					err(1, "expand_queue: calloc");
				if (strlcpy(n->parent, a->qname,
				    sizeof(n->parent)) >= sizeof(n->parent))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(n->queue, queue->queue,
				    sizeof(n->queue)) >= sizeof(n->queue))
					errx(1, "expand_queue: strlcpy");
				if (strlcpy(n->ifname, tqueue->ifname,
				    sizeof(n->ifname)) >= sizeof(n->ifname))
					errx(1, "expand_queue: strlcpy");
				n->scheduler = tqueue->scheduler;
				n->next = NULL;
				n->tail = n;
				if (queues == NULL)
					queues = n;
				else {
					queues->tail->next = n;
					queues->tail = n;
d3280 2
a3281 2
			);
		}
a3283 13
	if ((pf->opts & PF_OPT_VERBOSE) && found > 0) {
		print_altq(&pf->paltq->altq, 0, bwspec.bw_percent);
		if (nqueues && nqueues->tail) {
			printf("{ ");
			LOOP_THROUGH(struct node_queue, queue,
			    nqueues,
				printf("%s ", queue->queue);
			);
			printf("}");
		}
		printf("\n");
	}

d3285 1
@


1.349
log
@clean up:
instead of letting the lexer interpret '<' '>' '=' '>=' '<=' and return them
as PF_OP_LT, PF_OP_GT etc etc etc in PORTUNARY, just let the lexer return
'<' '>' and  '=' literally, and in the few cases where the old PORTUNARY was
really used like originally intended, replace that by a new unaryop yacc
target. in all other cases that gets rid of quite some checks wether PORTUNARY
is really < and nothing else etc etc etc.

ok cedric@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.348 2003/03/27 18:01:57 henning Exp $	*/
d3706 1
a3706 1
		} 
@


1.348
log
@lotsa const char *
from David Hill <david at phobia.ms> a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.347 2003/03/27 16:17:37 henning Exp $	*/
d362 1
a362 1
%token	<v.i>			PORTUNARY PORTBINARY
d367 1
a367 1
%type	<v.i>			staticport
d474 1
a474 3
varset		: STRING PORTUNARY string		{
			if ($2 != PF_OP_EQ)
				YYERROR;
d760 1
a760 3
tabledef	: TABLE PORTUNARY STRING PORTUNARY table_opts {
			if ($2 != PF_OP_LT || $4 != PF_OP_GT)
				YYERROR;
d1581 1
a1581 3
		| PORTUNARY STRING PORTUNARY	{
			if ($1 != PF_OP_LT || $3 != PF_OP_GT)
				YYERROR;
d1658 1
a1658 1
		| PORTUNARY port		{
d1751 1
a1751 1
		| PORTUNARY uid			{
d1830 1
a1830 1
		| PORTUNARY gid			{
d2684 8
a3700 11
	case '=':
		yylval.v.i = PF_OP_EQ;
		return (PORTUNARY);
	case '!':
		next = lgetc(fin);
		if (next == '=') {
			yylval.v.i = PF_OP_NE;
			return (PORTUNARY);
		}
		lungetc(next);
		break;
d3706 2
a3707 7
		} else if (next == '=') {
			yylval.v.i = PF_OP_LE;
		} else {
			yylval.v.i = PF_OP_LT;
			lungetc(next);
		}
		return (PORTUNARY);
a3713 5
		} else if (next == '=') {
			yylval.v.i = PF_OP_GE;
		} else {
			yylval.v.i = PF_OP_GT;
			lungetc(next);
d3715 1
a3715 1
		return (PORTUNARY);
@


1.347
log
@introduce a "yesno" target. eases code a bit and yes is no keyword any more.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.346 2003/03/27 16:11:55 henning Exp $	*/
d218 2
a219 2
int	yyerror(char *, ...);
int	disallow_table(struct node_host *, char *);
d2693 1
a2693 1
yyerror(char *fmt, ...)
d2708 1
a2708 1
disallow_table(struct node_host *h, char *fmt)
@


1.346
log
@handle invalid priq/cbq flags better and give a nice error message
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.345 2003/03/27 15:58:11 henning Exp $	*/
d356 1
a356 1
%token	REQUIREORDER YES
d365 1
a365 1
%type	<v.number>		tos not
d457 1
a457 1
		| SET REQUIREORDER YES {
d459 3
a461 7
				printf("set require-order yes\n");
			require_order = 1;
		}
		| SET REQUIREORDER NO {
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set require-order no\n");
			require_order = 0;
d2682 8
a3526 1
		{ "yes",		YES},
@


1.345
log
@default, borrow, ecn, red and rio are no keywords any more. use STRING and
strcmp instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.344 2003/03/27 15:49:47 henning Exp $	*/
d1042 4
d1062 4
@


1.344
log
@switch symset/symget to TAILQ instead of using hand baked lists

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.343 2003/03/19 15:51:40 henning Exp $	*/
a360 1
%token	DEFAULT BORROW RED ECN RIO
d1031 12
a1042 5
cbqflags_item	: DEFAULT	{ $$ = CBQCLF_DEFCLASS; }
		| BORROW	{ $$ = CBQCLF_BORROW; }
		| RED		{ $$ = CBQCLF_RED; }
		| ECN		{ $$ = CBQCLF_RED|CBQCLF_ECN; }
		| RIO		{ $$ = CBQCLF_RIO; }
d1049 10
a1058 4
priqflags_item	: DEFAULT	{ $$ = PRCF_DEFAULTCLASS; }
		| RED		{ $$ = PRCF_RED; }
		| ECN		{ $$ = PRCF_RED|PRCF_ECN; }
		| RIO		{ $$ = PRCF_RIO; }
a3445 1
		{ "borrow",		BORROW},
a3448 1
		{ "default",		DEFAULT},
a3451 1
		{ "ecn",		ECN},
a3494 1
		{ "red",		RED},
a3500 1
		{ "rio",		RIO},
@


1.343
log
@kill the address token and move the host() invocation up to the host token,
so that host() always gets the full address to be parsed including the
netmask instead of applying the netmask afterwards. this could break some
edge cases and was broken since the (interface)/24 fix.
new token dynaddr for, well, dynaddr, and apply an eventually given netmask
afterwards in the host token just in this case.

found after bug report From: Julien Bordet <zejames@@greyhats.org> via dhartmei

ok daniel cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.342 2003/03/10 14:50:29 henning Exp $	*/
d253 1
d255 5
a259 5
	struct sym	*next;
	int		 used;
	int		 persist;
	char		*nam;
	char		*val;
d261 1
a261 1
struct sym	*symhead = NULL;
d3771 2
a3772 1
		for (sym = symhead; sym; sym = sym->next)
d3788 2
a3789 1
	for (sym = symhead; sym && strcmp(nam, sym->nam); sym = sym->next)
d3792 10
a3801 3
	if (sym != NULL && sym->persist == 1)
		return (0);

a3815 1
	sym->next = symhead;
d3818 1
a3818 1
	symhead = sym;
d3847 1
a3847 1
	for (sym = symhead; sym; sym = sym->next)
@


1.343.2.1
log
@Pull patch from -current:
Fix by dhartmei@@

Properly copy the second part of nat proxy port range, when specified.

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.343 2003/03/19 15:51:40 henning Exp $	*/
a2356 1
					r.rpool.proxy_port[1] = ntohs($6->rport.b);
@


1.342
log
@correctly cope with errors returned by eval_pfqueue and pfctl_add_altq

ok dhartmei@@ pb@@ (as part of... you know, monsterdiff)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.340 2003/03/09 19:07:21 henning Exp $	*/
d378 1
a378 1
%type	<v.host>		ipspec xhost host address host_list
d1558 4
a1561 2
host		: address
		| address '/' number		{
d1599 1
a1599 1
address		: '(' STRING ')'		{
a1619 1
		| STRING			{ $$ = host($1, -1); }
@


1.341
log
@when complaining about a queue wiwthout parent, include the queue name in
the error message

ok dhartmei@@ pb@@ (as part of a monsterdiff)
@
text
@a3139 1
	u_int8_t		 added = 0;
d3141 1
d3194 1
a3194 1
			if (!eval_pfqueue(pf, &pa, bwspec.bw_absolute,
d3196 4
a3199 2
				if (!pfctl_add_altq(pf, &pa))
					added++;
d3245 6
a3250 2
	if (!added) {
		yyerror("queue has no parent");
d3252 1
a3252 1
	} else
@


1.340
log
@cope with LOOP_THROUGH modifying the lis (queues).
in case of an error in the queue def in question the queues list remains
unmodified, but the LOOP_THROUGH caused a mod anyway, and the list can stay
empty. subsequent checks for NULL which check for a empty list fail then.
fix by adding an explicit check before looping.
fixes regress pfail31
error report by Kamil Andrusz via pb@@, testcase from pb@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.338 2003/03/08 15:17:34 henning Exp $	*/
d3149 1
a3149 1
		yyerror("queue has no parent");
@


1.339
log
@cope with the fact that LOOP_THROUGH loops once even if the list is empty by
moving the addition of child queues a bit down after the successfull
addition of the current queue and an explicit NULL check before looping.
fixes regress pf59
found by kjc@@
ok kjc@@ cedric@@ dhartmei@@
@
text
@d3148 6
@


1.338
log
@fix the obvious:
since we do not modify the struct pf_altq *a any more but our private copy,
we can of course not inherit teh scheduler type from it, since it did not
inherit the scheduler type from the parent.
so just inherit the scheduler type from the parent directly...

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.337 2003/03/08 14:52:17 henning Exp $	*/
d3181 15
a3218 11
			if (strlcpy(pa.ifname, tqueue->ifname,
			    sizeof(pa.ifname)) >= sizeof(pa.ifname))
				errx(1, "expand_queue: strlcpy");
			if (strlcpy(pa.parent, tqueue->parent,
			    sizeof(pa.parent)) >= sizeof(pa.parent))
				errx(1, "expand_queue: strlcpy");

			if (!eval_pfqueue(pf, &pa, bwspec.bw_absolute,
			    bwspec.bw_percent))
				if (!pfctl_add_altq(pf, &pa))
					added++;
@


1.337
log
@in expand_queue, make a private copy of the struct pf_altq before modifying
it. modifying the original one had undesired side effects if a queue was
expanded to more than one because it belonged to more than one interface

ok pb@@ cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.336 2003/03/06 12:50:40 henning Exp $	*/
d3194 1
a3194 1
				n->scheduler = a->scheduler;
@


1.336
log
@fix queue assignment on filter rules which are not bound to an interface.
when looking up the queue IDs using qname_to_qid, we do not need to limit
the matching on the interface in question, as it is guaranteed that same
named queues on different interfaces habe the same queue id. moreover, we
must not limit the matches to the interface if we do not have an interface
given on the filter rule to match on ;-)

found after problems reported by Andre Nathan <andre at v2r dot com dot br>

ok dhartmei@@ pb@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.335 2003/03/02 23:37:24 henning Exp $	*/
d3139 1
d3153 4
a3156 2
			if (a->scheduler != ALTQT_NONE &&
			    a->scheduler != tqueue->scheduler) {
d3161 1
a3161 1
			a->scheduler = tqueue->scheduler;
d3164 1
a3164 1
			switch (a->scheduler) {
d3204 2
a3205 2
			if (strlcpy(a->ifname, tqueue->ifname,
			    sizeof(a->ifname)) >= sizeof(a->ifname))
d3207 2
a3208 2
			if (strlcpy(a->parent, tqueue->parent,
			    sizeof(a->parent)) >= sizeof(a->parent))
d3211 1
a3211 1
			if (!eval_pfqueue(pf, a, bwspec.bw_absolute,
d3213 1
a3213 1
				if (!pfctl_add_altq(pf, a))
@


1.335
log
@when printing queues at load time that have bandwidth specified in percent,
print the bandwidth in percent instead of the calculated absolute value.
if a queue belongs to more than one interface and they have different
bandwidth the calculated absolute is of course different per interface.
previously the first calculated absolute value was shown; what of course is
incorrect on the second interface. note that only the print was wrong, the
correct values were passed to the kernel.

ok theo daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.334 2003/03/02 12:37:49 henning Exp $	*/
d3298 2
a3299 2
		r->qid = qname_to_qid(r->qname, r->ifname);
		if ((r->pqid = qname_to_qid(r->pqname, r->ifname)) == 0)
@


1.334
log
@remove the control keyword for cbq queues.
the control class was a legacy of the original CBQ design by LBL/Sun
to support RSVP.
the control class is not used in openbsd, in the sense that
we don't automatically set filters for ICMP/IGMP/RSVP for the control
class.

ok dhartmei@@ kjc@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.333 2003/02/27 04:16:28 david Exp $	*/
d3062 2
a3063 1
				print_altq(&pf->paltq->altq, 0);
d3212 2
d3215 9
a3223 12
			if ((pf->opts & PF_OPT_VERBOSE) && found == 1) {
				print_altq(&pf->paltq->altq, 0);
				if (nqueues && nqueues->tail) {
					printf("{ ");
					LOOP_THROUGH(struct node_queue, queue,
					    nqueues,
						printf("%s ", queue->queue);
					);
					printf("}");
				}
				printf("\n");
			}
d3225 2
a3226 1
	);
@


1.333
log
@modify error message to match the same 7 sections in pf.conf(5)
ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.332 2003/02/26 20:27:20 henning Exp $	*/
d360 1
a360 1
%token	DEFAULT CONTROL BORROW RED ECN RIO
a1031 1
		| CONTROL	{ $$ = CBQCLF_CTLCLASS; }
a3414 1
		{ "control",		CONTROL},
@


1.332
log
@in expand_rule, correctly set r->pqid if a priority queue was defined, and
reuse the value of r->qid if not.

ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.331 2003/02/25 20:59:09 henning Exp $	*/
d3382 2
a3383 2
		yyerror("Rules must be in order: options, scrub, "
		    "queue, NAT, filter");
@


1.331
log
@some minor KNF my fingers just did...

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.330 2003/02/25 12:22:25 cedric Exp $	*/
d3299 2
@


1.330
log
@repair/simplify/flexify binat userland.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.329 2003/02/24 21:55:51 henning Exp $	*/
d542 3
a544 2
					yyerror("destination port list expansion"
					    " not supported in rdr-anchor");
d1180 2
a1181 2
					yyerror("no routing address with matching address family "
					    "found.");
d1508 4
a1511 1
ipportspec	: ipspec			{ $$.host = $1; $$.port = NULL; }
d1967 2
a1968 1
					yyerror("illegal icmp6-code %ld", ulval);
d2001 2
a2002 1
				if ((p = geticmptypebyname($1, AF_INET)) == NULL) {
d2022 2
a2023 1
				if ((p = geticmptypebyname($1, AF_INET6)) == NULL) {
d2297 2
a2298 1
natrule		: nataction interface af proto fromto redirpool pooltype staticport
d2520 2
a2521 1
				if (!PF_AZERO(&binat.src.addr.v.a.mask, binat.af) &&
@


1.329
log
@when a macro is redefined, don't bother with reusing the existing entry in
symset() but just prepend a new sym entry to symhead like we always did. as
symget searches the list sequentially, the newest one is picked first.
prevents an endless loop introduced when trying to reuse the existing entry
by an invalid setting for the next pointer.
fixes regress test pf57.

found after conversation with Chris Linn, celinn at mtu dot edu

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.328 2003/02/21 10:54:57 henning Exp $	*/
d2430 11
a2459 4
			if ($7 != NULL && $9 != NULL && $7->af != $9->af) {
				yyerror("binat ip versions must match");
				YYERROR;
			}
d2465 1
a2465 6
				if ($7->addr.type == PF_ADDR_DYNIFTL) {
					if (!binat.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
d2467 1
a2467 2
				}
				if (binat.af && $7->af != binat.af) {
d2471 2
a2472 7
				binat.af = $7->af;
				memcpy(&binat.src.addr.v.a.addr,
				    &$7->addr.v.a.addr,
				    sizeof(binat.src.addr.v.a.addr));
				memcpy(&binat.src.addr.v.a.mask,
				    &$7->addr.v.a.mask,
				    sizeof(binat.src.addr.v.a.mask));
d2480 1
a2480 9
				if ($9->addr.type == PF_ADDR_DYNIFTL) {
					if (!binat.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$9->af = binat.af;
				}
				if (binat.af && $9->af != binat.af) {
d2484 2
a2485 7
				binat.af = $9->af;
				memcpy(&binat.dst.addr.v.a.addr,
				    &$9->addr.v.a.addr,
				    sizeof(binat.dst.addr.v.a.addr));
				memcpy(&binat.dst.addr.v.a.mask,
				    &$9->addr.v.a.mask,
				    sizeof(binat.dst.addr.v.a.mask));
@


1.328
log
@re-allow set loginterface none
ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.327 2003/02/21 10:34:52 henning Exp $	*/
d3776 2
a3777 5
	if (sym == NULL)
		sym = calloc(1, sizeof(*sym));
	else
		if (sym->persist == 1)
			return (0);
d3779 1
a3779 1
	if (sym == NULL)
d3781 1
@


1.327
log
@better error message if set loginterface is called with nonexistant
interface, found by krause (who is doing EXCELLENT work. Thank you very
much!), fix by me, ok dhartmei@@ and cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.326 2003/02/20 00:18:19 henning Exp $	*/
d434 1
a434 1
			if (ifa_exists($3) == NULL) {
@


1.326
log
@reject nonexistant interfaces in the dynaddr case, noticed during discussion
with jasondixon at myrealbox dot com

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.325 2003/02/19 22:00:20 dhartmei Exp $	*/
d434 4
@


1.325
log
@Make 'from (kue0)/24' work again (dynamic interface name translation with
a /prefix), reported by Jason Dixon. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.324 2003/02/19 21:54:46 henning Exp $	*/
d1591 4
@


1.324
log
@better error message on icmp version / address family mismatch

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.323 2003/02/18 21:59:34 henning Exp $	*/
d1552 7
a1558 1
		| STRING '/' number		{ $$ = host($1, $3); }
@


1.323
log
@fix load option handling (-A, -N, -R) for options.
due to a bug in the loadopt check options were always loaded no matter which
loadopts where specified.
while beeing there, move the prints for that to where they belong, into the
appropriate pfctl_set_* functions, and thus only print when the options are
actually loaded.
fixes regress tests pfopt3, pfopt4, pfopt5 I added earlier.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.322 2003/02/17 14:36:46 henning Exp $	*/
d2738 3
a2740 1
		yyerror("icmp version does not match address family");
@


1.322
log
@"optarg" was a bad pick for the variable name in pfctl_cmdline_symset, it
shadows a global. rename.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.321 2003/02/17 06:56:04 mpech Exp $	*/
a419 2
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set optimization %s\n", $3);
a431 2
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set loginterface %s\n", $3);
a2627 2
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set timeout %s %u\n", $1, $2);
d2630 1
a2630 1
			if (pfctl_set_timeout(pf, $1, $2) != 0) {
a2642 2
			if (pf->opts & PF_OPT_VERBOSE)
				printf("set limit %s %u\n", $1, $2);
@


1.321
log
@-#include <sys/ioctl.h>

mcbride@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.320 2003/02/16 15:19:42 henning Exp $	*/
d3795 1
a3795 1
pfctl_cmdline_symset(char *optarg)
d3800 1
a3800 1
	if ((val = strrchr(optarg, '=')) == NULL)
d3803 1
a3803 1
	if ((sym = malloc(strlen(optarg) - strlen(val) + 1)) == NULL)
d3806 1
a3806 1
	strlcpy(sym, optarg, strlen(optarg) - strlen(val) + 1);
@


1.320
log
@unneeded {}
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.319 2003/02/16 15:11:09 henning Exp $	*/
a29 1
#include <sys/ioctl.h>
@


1.319
log
@throw a syntax error if the portunary operator in varset is no '='
extif>"whatever"
should not be the same as
extif="whatever"
but a syntax error.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.318 2003/02/14 14:38:32 dhartmei Exp $	*/
d3749 1
a3749 1
	if (pf->opts & PF_OPT_VERBOSE2) {
a3753 1
	}
@


1.318
log
@Allow route-to loopback interfaces again, since Ryan fixed the loops that
might have occured before.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.317 2003/02/14 13:23:17 cedric Exp $	*/
d480 2
@


1.317
log
@Better and more consistent error message.
Ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.316 2003/02/13 10:26:21 henning Exp $	*/
a2553 4
			} else if (n->ifa_flags & IFF_LOOPBACK) {
				yyerror("routeto: loopback interface %s not "
				    "supported", $$->ifname);
				YYERROR;
a2567 4
				YYERROR;
			} else if (n->ifa_flags & IFF_LOOPBACK) {
				yyerror("routeto: loopback interface %s not "
				    "supported", $$->ifname);
@


1.316
log
@ease the yacc a bit by using a "not" rule instead of having two rules w/ and
without '!' everywhere

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.315 2003/02/12 13:03:54 henning Exp $	*/
d2429 1
d2433 5
@


1.315
log
@KNF after ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.314 2003/02/12 12:48:40 mcbride Exp $	*/
d366 1
a366 1
%type	<v.number>		tos
d761 3
d813 2
a814 5
tableaddr	: STRING {
			pfctl_append_addr($1, -1, 0);
		}
		| STRING '/' number {
			pfctl_append_addr($1, $3, 0);
d816 2
a817 5
		| '!' STRING {
			pfctl_append_addr($2, -1, 1);
		}
		| '!' STRING '/' number {
			pfctl_append_addr($2, $4, 1);
d1400 2
a1401 2
if_item_not	: '!' if_item			{ $$ = $2; $$->not = 1; }
		| if_item			{ $$ = $1; }
d1537 1
a1537 1
xhost		: '!' host			{
d1541 1
a1541 1
				n->not = 1;
a1543 1
		| host				{ $$ = $1; }
@


1.314
log
@Simplify the code and make the parser handle the different rule types
more consistently.

- Merge expand_nat and expand_rdr into expand_rule
- Merge rdrrule token into natrule

ok concept henning@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.313 2003/02/11 20:11:36 henning Exp $	*/
d2331 1
a2331 1
				    	if (!$6->rport.b && $6->rport.t &&
d2815 1
a2815 1
	    	if (r->src.port_op) {
d2819 1
a2819 1
	    	if (r->dst.port_op) {
d2823 1
a2823 1
	    	if (r->rpool.proxy_port[0]) {
@


1.313
log
@allow macro definition on the command line:
pfctl -Dextif=wi0 -f /etc/pf.conf
command line macro definitions override the ones made in the file (idea
theo), very handy if your notebook has another NIC at some conference, as
well as for debugging etc.
idea rezine@@mistrusted.net via pb@@
hacked live at FOSDEM

ok pb@@ dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.312 2003/02/09 15:04:04 henning Exp $	*/
d222 1
a225 5
void	expand_rdr(struct pf_rule *, struct node_if *, struct node_proto *,
	    struct node_host *, struct node_host *, struct node_host *);
void	expand_nat(struct pf_rule *, struct node_if *, struct node_proto *,
	    struct node_host *, struct node_port *,
	    struct node_host *, struct node_port *, struct node_host *);
d365 1
a365 1
%type	<v.number>		number port icmptype icmp6type uid gid
d369 2
a370 2
%type	<v.b>			action flags flag blockspec
%type	<v.range>		dport rport
a409 1
		| ruleset rdrrule '\n'
d517 3
a519 2
			expand_nat(&r, $3, $5, $6.src.host, $6.src.port,
			    $6.dst.host, $6.dst.port, NULL);
d554 3
a556 1
			expand_rdr(&r, $3, $5, $6.src.host, $6.dst.host, NULL);
d1627 6
a1632 3
			$$->port[0] = $1;
			$$->port[1] = $1;
			$$->op = PF_OP_EQ;
d1637 5
d1645 2
a1646 2
			$$->port[0] = $2;
			$$->port[1] = $2;
d1652 5
d1660 2
a1661 2
			$$->port[0] = $1;
			$$->port[1] = $3;
d1669 1
d1673 17
a1689 4
			if (atoul($1, &ulval) == 0) {
				if (ulval > 65535) {
					yyerror("illegal port value %d", ulval);
					YYERROR;
d1691 2
a1692 1
				$$ = htons(ulval);
d1694 5
a1698 5
				s = getservbyname($1, "tcp");
				if (s == NULL)
					s = getservbyname($1, "udp");
				if (s == NULL) {
					yyerror("unknown port %s", $1);
d1700 3
a1702 2
				}
				$$ = s->s_port;
d2267 17
a2283 1
natrule		: no NAT interface af proto fromto redirpool pooltype staticport
d2285 1
a2285 1
			struct pf_rule	nat;
d2290 4
a2293 1
			memset(&nat, 0, sizeof(nat));
d2295 8
a2302 5
			if ($1)
				nat.action = PF_NONAT;
			else
				nat.action = PF_NAT;
			nat.af = $4;
d2304 4
a2307 13
			if (!nat.af) {
				if ($6.src.host && $6.src.host->af &&
				    !$6.src.host->ifindex)
					nat.af = $6.src.host->af;
				else if ($6.dst.host && $6.dst.host->af &&
				    !$6.dst.host->ifindex)
					nat.af = $6.dst.host->af;
			}

			if (nat.action == PF_NONAT) {
				if ($7 != NULL) {
					yyerror("'no nat' rule does not need "
					    "'->'");
d2311 2
a2312 2
				if ($7 == NULL || $7->host == NULL) {
					yyerror("'nat' rule requires '-> "
d2316 1
a2316 1
				if (disallow_table($7->host, "invalid use of "
d2318 1
a2318 1
				    "a nat rule"))
d2320 2
a2321 2
				if (!nat.af && ! $7->host->ifindex)
					nat.af = $7->host->af;
d2323 2
a2324 2
				remove_invalid_hosts(&$7->host, &nat.af);
				if (invalid_redirect($7->host, nat.af))
d2326 34
a2359 15
				nat.rpool.proxy_port[0] = ntohs($7->rport.a);
				nat.rpool.proxy_port[1] = ntohs($7->rport.b);
				if (!nat.rpool.proxy_port[0] &&
				    !nat.rpool.proxy_port[1]) {
					nat.rpool.proxy_port[0] =
					    PF_NAT_PROXY_PORT_LOW;
					nat.rpool.proxy_port[1] =
					    PF_NAT_PROXY_PORT_HIGH;
				} else if (!nat.rpool.proxy_port[1])
					nat.rpool.proxy_port[1] =
					    nat.rpool.proxy_port[0];
				if ($7->host->next) {
					nat.rpool.opts = $8.type;
					if (nat.rpool.opts == PF_POOL_NONE)
						nat.rpool.opts =
d2361 1
a2361 1
					if (nat.rpool.opts !=
d2363 1
a2363 1
						yyerror("nat: only round-robin "
d2369 7
a2375 7
					if ((nat.af == AF_INET &&
					    unmask(&$7->host->addr.v.a.mask,
					    nat.af) == 32) ||
					    (nat.af == AF_INET6 &&
					    unmask(&$7->host->addr.v.a.mask,
					    nat.af) == 128)) {
						nat.rpool.opts = PF_POOL_NONE;
d2377 2
a2378 2
						if ($8.type == PF_POOL_NONE)
							nat.rpool.opts =
d2381 2
a2382 2
							nat.rpool.opts =
							    $8.type;
d2387 2
a2388 2
			if ($8.key != NULL)
				memcpy(&nat.rpool.key, $8.key,
d2391 9
a2399 2
			if ($9 != NULL)
				nat.rpool.opts |= PF_POOL_STATICPORT;
d2401 4
a2404 4
			expand_nat(&nat, $3, $5, $6.src.host, $6.src.port,
			    $6.dst.host, $6.dst.port,
			    $7 == NULL ? NULL : $7->host);
			free($7);
a2539 137
rdrrule		: no RDR interface af proto FROM ipspec TO ipspec dport
		  redirpool pooltype
		{
			struct pf_rule	rdr;

			if (check_rulestate(PFCTL_STATE_NAT))
				YYERROR;

			memset(&rdr, 0, sizeof(rdr));

			if ($1)
				rdr.action = PF_NORDR;
			else
				rdr.action = PF_RDR;
			rdr.af = $4;

			if ($7 != NULL) {
				memcpy(&rdr.src.addr.v.a.addr,
				    &$7->addr.v.a.addr,
				    sizeof(rdr.src.addr.v.a.addr));
				memcpy(&rdr.src.addr.v.a.mask,
				    &$7->addr.v.a.mask,
				    sizeof(rdr.src.addr.v.a.mask));
				rdr.src.not = $7->not;
				if (!rdr.af && !$7->ifindex)
					rdr.af = $7->af;
			}
			if ($9 != NULL) {
				memcpy(&rdr.dst.addr.v.a.addr,
				    &$9->addr.v.a.addr,
				    sizeof(rdr.dst.addr.v.a.addr));
				memcpy(&rdr.dst.addr.v.a.mask,
				    &$9->addr.v.a.mask,
				    sizeof(rdr.dst.addr.v.a.mask));
				rdr.dst.not = $9->not;
				if (!rdr.af && !$9->ifindex)
					rdr.af = $9->af;
			}

			rdr.dst.port[0] = $10.a;
			rdr.dst.port[1] = $10.b;
			rdr.dst.port_op |= $10.t;

			if ($12.type == PF_POOL_NONE)
				rdr.rpool.opts = PF_POOL_RANDOM;
			else
				rdr.rpool.opts = $12.type;

			if (rdr.action == PF_NORDR) {
				if ($11 != NULL) {
					yyerror("'no rdr' rule does not need '->'");
					YYERROR;
				}
			} else {
				if ($11 == NULL || $11->host == NULL) {
					yyerror("'rdr' rule requires '-> "
					    "address'");
					YYERROR;
				}
				if (disallow_table($11->host, "invalid use of "
				    "table <%s> as the redirection address "
				    "of a rdr rule"))
					YYERROR;
				if (!rdr.af && !$11->host->ifindex)
					rdr.af = $11->host->af;

				remove_invalid_hosts(&$11->host, &rdr.af);
				if (invalid_redirect($11->host, rdr.af))
					YYERROR;
				rdr.rpool.proxy_port[0] = $11->rport.a;
				if ($11->rport.t && $10.b) {
					rdr.rpool.proxy_port[1] = $11->rport.a +
					    (rdr.dst.port[1] - rdr.dst.port[0]);
				} else
					rdr.rpool.proxy_port[1] = $11->rport.b;

				if ($11->host->next) {
					rdr.rpool.opts = $12.type;
					if (rdr.rpool.opts == PF_POOL_NONE)
						rdr.rpool.opts =
						    PF_POOL_ROUNDROBIN;
					if (rdr.rpool.opts !=
					    PF_POOL_ROUNDROBIN) {
						yyerror("rdr: only round-robin "
						    "valid for multiple "
						    "redirection addresses");
						YYERROR;
					}
				} else {
					if ((rdr.af == AF_INET &&
					    unmask(&$11->host->addr.v.a.mask,
					    rdr.af) == 32) ||
					    (rdr.af == AF_INET6 &&
					    unmask(&$11->host->addr.v.a.mask,
					    rdr.af) == 128)) {
						rdr.rpool.opts = PF_POOL_NONE;
					} else {
						if ($12.type == PF_POOL_NONE)
							rdr.rpool.opts =
							    PF_POOL_ROUNDROBIN;
						else
							rdr.rpool.opts =
							    $12.type;
					}
				}
			}

			if ($12.key != NULL)
				memcpy(&rdr.rpool.key, $12.key,
				    sizeof(struct pf_poolhashkey));

			expand_rdr(&rdr, $3, $5, $7, $9,
			    $11 == NULL ? NULL : $11->host);
		}
		;

dport		: /* empty */			{
			$$.a = $$.b = $$.t = 0;
		}
		| PORT STRING			{
			char	*p = strchr($2, ':');

			if (p == NULL) {
				if (($$.a = getservice($2)) == -1)
					YYERROR;
				$$.b = 0;
				$$.t = PF_OP_EQ;
			} else {
				*p++ = 0;
				if (($$.a = getservice($2)) == -1 ||
				    ($$.b = getservice(p)) == -1)
					YYERROR;
				$$.t = PF_OP_RRG;
			}
		}
		;

d2704 26
d2736 4
d2791 4
d2814 22
a2835 3
	if (r->proto != IPPROTO_TCP && r->proto != IPPROTO_UDP &&
	    (r->dst.port[0] || r->dst.port[1] || r->rpool.proxy_port[0])) {
		yyerror("port only applies to tcp/udp");
d3354 1
a3354 1
			yyerror("skipping filter rule due to errors");
a3375 166
}

void
expand_nat(struct pf_rule *n,
    struct node_if *interfaces, struct node_proto *protos,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_host *rpool_hosts)
{
	char			 ifname[IF_NAMESIZE];
	struct pf_pooladdr	*pa;
	struct node_host	*h;
	sa_family_t		 af = n->af;
	int			 added = 0, error = 0;

	LOOP_THROUGH(struct node_if, interface, interfaces,
	LOOP_THROUGH(struct node_proto, proto, protos,
	LOOP_THROUGH(struct node_host, src_host, src_hosts,
	LOOP_THROUGH(struct node_port, src_port, src_ports,
	LOOP_THROUGH(struct node_host, dst_host, dst_hosts,
	LOOP_THROUGH(struct node_port, dst_port, dst_ports,

		n->af = af;
		/* for link-local IPv6 address, interface must match up */
		if ((n->af && src_host->af && n->af != src_host->af) ||
		    (n->af && dst_host->af && n->af != dst_host->af) ||
		    (src_host->af && dst_host->af &&
		    src_host->af != dst_host->af) ||
		    (src_host->ifindex && dst_host->ifindex &&
		    src_host->ifindex != dst_host->ifindex) ||
		    (src_host->ifindex && if_nametoindex(interface->ifname) &&
		    src_host->ifindex != if_nametoindex(interface->ifname)) ||
		    (dst_host->ifindex && if_nametoindex(interface->ifname) &&
		    dst_host->ifindex != if_nametoindex(interface->ifname)))
			continue;
		if (!n->af && src_host->af)
			n->af = src_host->af;
		else if (!n->af && dst_host->af)
			n->af = dst_host->af;

		if (if_indextoname(src_host->ifindex, ifname))
			memcpy(n->ifname, ifname, sizeof(n->ifname));
		else if (if_indextoname(dst_host->ifindex, ifname))
			memcpy(n->ifname, ifname, sizeof(n->ifname));
		else
			memcpy(n->ifname, interface->ifname, sizeof(n->ifname));

		n->ifnot = interface->not;
		n->proto = proto->proto;
		n->src.addr = src_host->addr;
		n->src.not = src_host->not;
		n->src.port[0] = src_port->port[0];
		n->src.port[1] = src_port->port[1];
		n->src.port_op = src_port->op;
		n->dst.addr = dst_host->addr;
		n->dst.not = dst_host->not;
		n->dst.port[0] = dst_port->port[0];
		n->dst.port[1] = dst_port->port[1];
		n->dst.port_op = dst_port->op;

		TAILQ_INIT(&n->rpool.list);
		for (h = rpool_hosts; h != NULL; h = h->next) {
			pa = calloc(1, sizeof(struct pf_pooladdr));
			if (pa == NULL)
				err(1, "expand_nat: calloc");
			pa->addr.addr = h->addr;
			pa->ifname[0] = 0;
			TAILQ_INSERT_TAIL(&n->rpool.list, pa, entries);
		}

		if (nat_consistent(n) < 0 || error)
			yyerror("skipping nat rule due to errors");
		else {
			pfctl_add_rule(pf, n);
			added++;
		}

	))))));

	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_proto, protos);
	FREE_LIST(struct node_host, src_hosts);
	FREE_LIST(struct node_port, src_ports);
	FREE_LIST(struct node_host, dst_hosts);
	FREE_LIST(struct node_port, dst_ports);
	FREE_LIST(struct node_host, rpool_hosts);

	if (!added)
		yyerror("nat rule expands to no valid combinations");
}

void
expand_rdr(struct pf_rule *r, struct node_if *interfaces,
    struct node_proto *protos, struct node_host *src_hosts,
    struct node_host *dst_hosts, struct node_host *rpool_hosts)
{
	sa_family_t		 af = r->af;
	int			 added = 0, error = 0;
	char			 ifname[IF_NAMESIZE];
	struct pf_pooladdr	*pa;
	struct node_host	*h;

	LOOP_THROUGH(struct node_if, interface, interfaces,
	LOOP_THROUGH(struct node_proto, proto, protos,
	LOOP_THROUGH(struct node_host, src_host, src_hosts,
	LOOP_THROUGH(struct node_host, dst_host, dst_hosts,

		r->af = af;
		if ((r->af && src_host->af && r->af != src_host->af) ||
		    (r->af && dst_host->af && r->af != dst_host->af) ||
		    (src_host->af && dst_host->af &&
		    src_host->af != dst_host->af) ||
		    (src_host->ifindex && dst_host->ifindex &&
		    src_host->ifindex != dst_host->ifindex) ||
		    (src_host->ifindex && if_nametoindex(interface->ifname) &&
		    src_host->ifindex != if_nametoindex(interface->ifname)) ||
		    (dst_host->ifindex && if_nametoindex(interface->ifname) &&
		    dst_host->ifindex != if_nametoindex(interface->ifname)))
			continue;

		if (!r->af && src_host->af)
			r->af = src_host->af;
		else if (!r->af && dst_host->af)
			r->af = dst_host->af;

		if (if_indextoname(src_host->ifindex, ifname))
			memcpy(r->ifname, ifname, sizeof(r->ifname));
		else if (if_indextoname(dst_host->ifindex, ifname))
			memcpy(r->ifname, ifname, sizeof(r->ifname));
		else
			memcpy(r->ifname, interface->ifname, sizeof(r->ifname));

		r->ifnot = interface->not;
		r->proto = proto->proto;
		r->src.addr = src_host->addr;
		r->src.not = src_host->not;
		r->dst.addr = dst_host->addr;
		r->dst.not = dst_host->not;

		TAILQ_INIT(&r->rpool.list);
		for (h = rpool_hosts; h != NULL; h = h->next) {
			pa = calloc(1, sizeof(struct pf_pooladdr));
			if (pa == NULL)
				err(1, "expand_rdr: calloc");
			pa->addr.addr = h->addr;
			pa->ifname[0] = 0;
			TAILQ_INSERT_TAIL(&r->rpool.list, pa, entries);
		}

		if (rdr_consistent(r) < 0 || error)
			yyerror("skipping rdr rule due to errors");
		else {
			pfctl_add_rule(pf, r);
			added++;
		}

	))));

	FREE_LIST(struct node_if, interfaces);
	FREE_LIST(struct node_proto, protos);
	FREE_LIST(struct node_host, src_hosts);
	FREE_LIST(struct node_host, dst_hosts);
	FREE_LIST(struct node_host, rpool_hosts);

	if (!added)
		yyerror("rdr rule expands to no valid combination");
@


1.312
log
@more live code from FOSDEM:
make
pass in proto tcp to port 80
work.
-allow to omit the "any" if you're specifying a port
-allow to omit the from or to part if you want "any" for the other

ok dhartmei@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.311 2003/02/09 13:50:44 henning Exp $	*/
d261 1
d267 1
a267 1
int	 symset(const char *, const char *);
d487 1
a487 1
			if (symset($1, $3) == -1)
d3951 1
a3951 1
symset(const char *nam, const char *val)
d3955 9
a3963 1
	sym = calloc(1, sizeof(*sym));
d3979 1
d3982 20
@


1.311
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.310 2003/02/09 12:49:48 camield Exp $	*/
d381 1
a381 1
%type	<v.peer>		ipportspec
d1480 1
a1480 1
fromto		: /* empty */			{
d1486 18
a1503 5
		| ALL				{
			$$.src.host = NULL;
			$$.src.port = NULL;
			$$.dst.host = NULL;
			$$.dst.port = NULL;
d1505 2
a1506 3
		| FROM ipportspec TO ipportspec	{
			$$.src = $2;
			$$.dst = $4;
d1514 4
@


1.310
log
@Fix a few warnings and remove unnecessary check and cast.

ok dhartmei henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.309 2003/02/08 20:13:20 dhartmei Exp $	*/
d1182 1
a1182 1
 					yyerror("no routing address with matching address family "
@


1.309
log
@Add scrub option 'random-id', which replaces IP IDs with random values
for outgoing packets that are not fragmented (after reassembly), to
compensate for predictable IDs generated by some hosts, and defeat
fingerprinting and NAT detection as described in the Bellovin paper
http://www.research.att.com/~smb/papers/fnat.pdf. ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.308 2003/02/05 16:05:54 cedric Exp $	*/
d652 1
a652 1
				yyerror("nodf cannot be respecified");
d659 1
a659 1
				yyerror("minttl cannot be respecified");
d671 1
a671 1
				yyerror("maxmss cannot be respecified");
a2014 4
			if ($2 <= 0) {
				yyerror("illegal states max value %d", $2);
				YYERROR;
			}
d2140 2
a2141 2
			if (!strncmp((char *)$1, "0x", 2)) {
				if (strlen((char *)$1) != 34) {
@


1.308
log
@Fix "pass out dup-to (tun0 1.1.1.1) inet6 all" error message
Allow "pass out dup-to tun0 all"
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.307 2003/02/05 00:46:57 mcbride Exp $	*/
d197 1
d358 1
a358 1
%token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE BLOCKPOLICY
d620 2
d685 7
d3636 1
@


1.307
log
@Set the network mask to all 1's if no address is specified for a
route-to/dup-to/reply-to rule. Keeps round-robin from incrementing through
the entire address space.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.306 2003/02/03 16:44:21 deraadt Exp $	*/
d270 1
d1172 2
a1173 1
					yyerror("$5.host == NULL");
d2261 1
a2261 1
				if ($7->host == NULL)
d2419 1
a2419 1
				if ($10->host == NULL)
d2518 1
a2518 1
				if ($11->host == NULL)
d4012 1
d4014 4
a4017 1
	if (!*af)
d4020 3
a4022 1
	else if (*nh == NULL)
d4025 3
@


1.306
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.305 2003/02/03 15:44:52 dhartmei Exp $	*/
d2603 1
@


1.305
log
@Don't allow loopback interfaces as route/reply/dup-to targets. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.304 2003/02/03 14:51:36 cedric Exp $	*/
d268 2
a269 4
void	 decide_address_family(struct node_host *,
	    sa_family_t *);
void	 remove_invalid_hosts(struct node_host **,
	    sa_family_t *);
@


1.304
log
@remove loadopt global definition and cleanup a bit.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.303 2003/02/03 13:40:45 henning Exp $	*/
d2589 2
d2596 1
a2596 1
			if (ifa_exists($$->ifname) == NULL) {
d2600 4
d2609 2
d2614 1
a2614 1
			if (ifa_exists($$->ifname) == NULL) {
d2617 4
@


1.303
log
@fix a problem with queue definitions when load options (like -N etc) are
given; they used to check for their parent interface/queue even in this
case.

ok dhartmei@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.302 2003/02/02 23:22:07 henning Exp $	*/
d762 2
a763 1
			    pf->opts & PF_OPT_NOACTION);
@


1.302
log
@there is no need to pass opts to parse_rules explicitely; it's passed as
part of the struct pfctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.301 2003/01/27 19:08:27 deraadt Exp $	*/
d3025 6
d3127 5
@


1.301
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.300 2003/01/25 22:53:45 mcbride Exp $	*/
d3876 1
a3876 1
parse_rules(FILE *input, struct pfctl *xpf, int opts)
d3888 1
a3888 1
	if (opts & PF_OPT_VERBOSE2) {
@


1.300
log
@Match changes for rdr port ranges made to pf.c:
- fixes behaviour of rdr on le0 from foo to bar port 1:20 -> (lo0) port 22
- makes calculated mapping more explicit for the -> (lo0) port 22:* case

testing from dhartmei@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.299 2003/01/25 18:16:05 cedric Exp $	*/
d247 9
a255 9
int			 check_rulestate(int);
int			 kw_cmp(const void *, const void *);
int			 lookup(char *);
int			 lgetc(FILE *);
int			 lungetc(int);
int			 findeol(void);
int			 yylex(void);
int			 atoul(char *, u_long *);
int			 getservice(char *);
d265 2
a266 2
int			 symset(const char *, const char *);
char			*symget(const char *);
d268 5
a272 5
void			 decide_address_family(struct node_host *,
			    sa_family_t *);
void			 remove_invalid_hosts(struct node_host **,
			    sa_family_t *);
u_int16_t		 parseicmpspec(char *, sa_family_t);
@


1.299
log
@Fix NOACTION with table statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.298 2003/01/25 16:33:19 cedric Exp $	*/
d2078 1
a2078 1
				$$.t = PF_OP_RRG;
d2084 3
a2086 1
				$$.t = PF_OP_RRG;
d2520 5
a2524 1
				rdr.rpool.port_op |= $11->rport.t;
@


1.298
log
@Permit initialisation of a table content from a file in pf.conf.
Cleaning up of the table options parsing, more flexible.
idea+cleanup deraadt@@, ok dhartmei@@, pass all regress tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.297 2003/01/25 15:37:00 cedric Exp $	*/
d761 2
a762 1
			pfctl_define_table($3, $5.flags, $5.init_addr);
@


1.297
log
@Correctly check illegal constructs with tables. Better error messages.
ok dhartmei@@ pass all regress tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.296 2003/01/25 00:51:40 henning Exp $	*/
d213 5
d333 1
d355 1
a355 1
%token	MINTTL ERROR ALLOWOPTS FASTROUTE ROUTETO DUPTO REPLYTO NO LABEL
d369 1
a369 1
%type	<v.number>		tos tableopts tableinit
d404 1
d753 1
a753 1
tabledef	: TABLE PORTUNARY STRING PORTUNARY tableopts tableinit {
d761 13
a773 1
			pfctl_define_table($3, $5, $6);
d777 10
a786 7
tableopts	: /* empty */		{ $$ = 0; }
		| tableopts STRING	{
			$$ = $1;
			if (!strcmp($2, "const"))
				$$ |= PFR_TFLAG_CONST;
			else if (!strcmp($2, "persist"))
				$$ |= PFR_TFLAG_PERSIST;
d790 6
a795 3

tableinit	: /* empty */		{ $$ = 0; }
		| '{' tableaddrs '}'	{ $$ = 1; }
d3556 1
@


1.296
log
@if a table name ist too long, it's actually nice to tell so instead of just
aborting with a syntax error
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.295 2003/01/20 18:37:52 camield Exp $	*/
d214 1
d2224 4
d2315 3
d2481 4
d2578 3
d2688 11
@


1.295
log
@Remove unused argument from print_name() and fix two other nits
found by lint.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.294 2003/01/19 10:19:15 camield Exp $	*/
d748 3
a750 1
			if (strlen($3) >= PF_TABLE_NAME_SIZE)
d752 1
@


1.294
log
@Spin off label string expansion into a separate function.  Clarifies
and tightens all expand_label functions.

ok dhartmei henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.293 2003/01/18 15:06:13 henning Exp $	*/
d2125 2
a2126 1
				MD5Update(&context, $1, strlen($1));
@


1.293
log
@KNF after ryan...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.292 2003/01/18 04:45:59 mcbride Exp $	*/
d223 1
d2813 20
d2835 5
a2839 20
	char	 tmp[PF_RULE_LABEL_SIZE];
	char	*p;

	while ((p = strstr(label, name)) != NULL) {
		if (p-label >= sizeof(tmp))
			errx(1, "expand_label_if: label too long");
		memcpy(tmp, label, p-label);
		tmp[p-label] = 0;
		if (!*ifname) {
			if (strlcat(tmp, "any", sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_if: strlcat");
		} else {
			if (strlcat(tmp, ifname, sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_if: strlcat");
		}
		if (strlcat(tmp, p+strlen(name), sizeof(tmp)) >= sizeof(tmp))
			errx(1, "expand_label_if: strlcat");
		if (strlcpy(label, tmp, PF_RULE_LABEL_SIZE) >=
		    PF_RULE_LABEL_SIZE)
			errx(1, "expand_label_if: strlcpy");
d2847 1
a2847 2
	char	 tmp[PF_RULE_LABEL_SIZE];
	char	*p;
d2849 7
a2855 22
	while ((p = strstr(label, name)) != NULL) {
		if (p-label >= sizeof(tmp))
			errx(1, "expand_label_addr: label too long");
		memcpy(tmp, label, p-label);
		tmp[p-label] = 0;
		if (h->not) {
			if (strlcat(tmp, "! ", sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
		}
		if (h->addr.type == PF_ADDR_DYNIFTL) {
			if (strlcat(tmp, "(", sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
			if (strlcat(tmp, h->addr.v.ifname, sizeof(tmp)) >=
			    sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
			if (strlcat(tmp, ")", sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
		} else if (!af || (PF_AZERO(&h->addr.v.a.addr, af) &&
		    PF_AZERO(&h->addr.v.a.mask, af))) {
			if (strlcat(tmp, "any", sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
		} else {
d2859 19
a2877 20
			if (inet_ntop(af, &h->addr.v.a.addr, a,
			    sizeof(a)) == NULL) {
				if (strlcat(a, "?", sizeof(a)) >= sizeof(a))
					errx(1, "expand_label_addr: strlcat");
			}
			if (strlcat(tmp, a, sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
			bits = unmask(&h->addr.v.a.mask, af);
			a[0] = 0;
			if ((af == AF_INET && bits < 32) ||
			    (af == AF_INET6 && bits < 128))
				snprintf(a, sizeof(a), "/%d", bits);
			if (strlcat(tmp, a, sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_addr: strlcat");
		}
		if (strlcat(tmp, p+strlen(name), sizeof(tmp)) >= sizeof(tmp))
			errx(1, "expand_label_addr: strlcat");
		if (strlcpy(label, tmp, PF_RULE_LABEL_SIZE) >=
		    PF_RULE_LABEL_SIZE)
			errx(1, "expand_label_addr: strlcpy");
d2884 3
a2886 9
	char	 tmp[PF_RULE_LABEL_SIZE];
	char	*p;
	char	 a1[6], a2[6], op[13];

	while ((p = strstr(label, name)) != NULL) {
		if (p-label >= sizeof(tmp))
			errx(1, "expand_label_port: label too long");
		memcpy(tmp, label, p-label);
		tmp[p-label] = 0;
d2890 1
a2890 1
			op[0] = 0;
d2907 1
a2907 7
		if (strlcat(tmp, op, sizeof(tmp)) >= sizeof(tmp))
			errx(1, "expand_label_port: strlcat");
		if (strlcat(tmp, p+strlen(name), sizeof(tmp)) >= sizeof(tmp))
			errx(1, "expand_label_port: strlcat");
		if (strlcpy(label, tmp, PF_RULE_LABEL_SIZE) >=
		    PF_RULE_LABEL_SIZE)
			errx(1, "expand_label_port: strlcpy");
d2914 4
a2917 9
	char		 tmp[PF_RULE_LABEL_SIZE];
	char		*p;
	struct protoent	*pe;

	while ((p = strstr(label, name)) != NULL) {
		if (p-label >= sizeof(tmp))
			errx(1, "expand_label_proto: label too long");
		memcpy(tmp, label, p-label);
		tmp[p-label] = 0;
d2919 6
a2924 11
		if (pe != NULL) {
			if (strlcat(tmp, pe->p_name, sizeof(tmp)) >= sizeof(tmp))
				errx(1, "expand_label_proto: strlcat");
		} else
			snprintf(tmp+strlen(tmp), PF_RULE_LABEL_SIZE-strlen(tmp),
			    "%u", proto);
		if (strlcat(tmp, p+strlen(name), sizeof(tmp)) >= sizeof(tmp))
			errx(1, "expand_label_proto: strlcat");
		if (strlcpy(label, tmp, PF_RULE_LABEL_SIZE) >=
		    PF_RULE_LABEL_SIZE)
			errx(1, "expand_label_proto: strlcpy");
d2931 1
a2931 2
	char	 tmp[PF_RULE_LABEL_SIZE];
	char	*p;
d2933 3
a2935 12
	while ((p = strstr(label, name)) != NULL) {
		if (p-label >= sizeof(tmp))
			errx(1, "expand_label_nr: label too long");
		memcpy(tmp, label, p-label);
		tmp[p-label] = 0;
		snprintf(tmp+strlen(tmp), PF_RULE_LABEL_SIZE-strlen(tmp),
		    "%u", pf->rule_nr);
		if (strlcat(tmp, p+strlen(name), sizeof(tmp)) >= sizeof(tmp))
			errx(1, "expand_label_nr: strlcat");
		if (strlcpy(label, tmp, PF_RULE_LABEL_SIZE) >=
		    PF_RULE_LABEL_SIZE)
			errx(1, "expand_label_nr: strlcpy");
@


1.292
log
@Add missing token string and assignment to make static-port work for real.

Diff and report courtesy of mpech@@ and form@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.291 2003/01/17 12:53:52 camield Exp $	*/
d2272 1
a2272 1
			 
@


1.291
log
@bandwith -> bandwidth

YYERROR on failed parseicmpspec()

ok dhartmei mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.290 2003/01/15 15:14:42 mpech Exp $	*/
d2270 3
d3598 1
@


1.290
log
@Typo in yyerror().

henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.289 2003/01/14 21:58:11 henning Exp $	*/
d886 1
a886 1
				yyerror("bandwith cannot be respecified");
d1323 2
a1324 1
			if (!($$.w2 = parseicmpspec($5, AF_INET6)));
@


1.289
log
@unified IP parser:
-move host(), set_ipmask and the ifa_* functions to pfctl_parser.[c|h]
-extend host() to handle /mask itself, plus minor adjustments
-use that in pfctl_table.c instead of coding the same shit again

discussed w/ cedric@@
ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.288 2003/01/13 08:17:47 camield Exp $	*/
d1150 1
a1150 1
						yyerror("r.rt_pool.opts must "
@


1.288
log
@err() on all memory allocation failures

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.287 2003/01/11 22:00:00 mcbride Exp $	*/
a45 1
#include <ifaddrs.h>
a80 14
enum pfctl_iflookup_mode {
	PFCTL_IFLOOKUP_HOST,
	PFCTL_IFLOOKUP_NET,
	PFCTL_IFLOOKUP_BCAST
};

struct node_if {
	char			 ifname[IFNAMSIZ];
	u_int8_t		 not;
	u_int			 ifa_flags;
	struct node_if		*next;
	struct node_if		*tail;
};

a86 12
struct node_host {
	struct pf_addr_wrap	 addr;
	struct pf_addr		 bcast;
	sa_family_t		 af;
	u_int8_t		 not;
	u_int32_t		 ifindex;	/* link-local IPv6 addrs */
	char			*ifname;
	u_int			 ifa_flags;
	struct node_host	*next;
	struct node_host	*tail;
};

a217 1
void	set_ipmask(struct node_host *, u_int8_t);
a246 1
struct node_host	*host(char *, int);
a260 3
void			 ifa_load(void);
struct node_host	*ifa_exists(char *);
struct node_host	*ifa_lookup(char *, enum pfctl_iflookup_mode);
a3871 26
void
set_ipmask(struct node_host *h, u_int8_t b)
{
	struct pf_addr	*m, *n;
	int		 i, j = 0;

	m = &h->addr.v.a.mask;

	for (i = 0; i < 4; i++)
		m->addr32[i] = 0;

	while (b >= 32) {
		m->addr32[j++] = 0xffffffff;
		b -= 32;
	}
	for (i = 31; i > 31-b; --i)
		m->addr32[j] |= (1 << i);
	if (b)
		m->addr32[j] = htonl(m->addr32[j]);

	/* Mask off bits of the address that will never be used. */
	n = &h->addr.v.a.addr;
	for (i = 0; i < 4; i++)
		n->addr32[i] = n->addr32[i] & m->addr32[i];
}

a3913 154
/* interface lookup routines */

struct node_host	*iftab;

void
ifa_load(void)
{
	struct ifaddrs		*ifap, *ifa;
	struct node_host	*n = NULL, *h = NULL;

	if (getifaddrs(&ifap) < 0)
		err(1, "getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (!(ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6 ||
		    ifa->ifa_addr->sa_family == AF_LINK))
				continue;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = ifa->ifa_addr->sa_family;
		n->ifa_flags = ifa->ifa_flags;
#ifdef __KAME__
		if (n->af == AF_INET6 &&
		    IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)
		    ifa->ifa_addr)->sin6_addr) &&
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id == 0) {
			struct sockaddr_in6	*sin6;

			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
			sin6->sin6_scope_id = sin6->sin6_addr.s6_addr[2] << 8 |
			    sin6->sin6_addr.s6_addr[3];
			sin6->sin6_addr.s6_addr[2] = 0;
			sin6->sin6_addr.s6_addr[3] = 0;
		}
#endif
		n->ifindex = 0;
		if (n->af == AF_INET) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in *)
			    ifa->ifa_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in *)
			    ifa->ifa_netmask)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in *)
				    ifa->ifa_broadaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
		} else if (n->af == AF_INET6) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in6 *)
			    ifa->ifa_netmask)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in6 *)
				    ifa->ifa_broadaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			n->ifindex = ((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_scope_id;
		}
		if ((n->ifname = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	iftab = h;
	freeifaddrs(ifap);
}

struct node_host *
ifa_exists(char *ifa_name)
{
	struct node_host	*n;

	if (iftab == NULL)
		ifa_load();

	for (n = iftab; n; n = n->next) {
		if (n->af == AF_LINK && !strncmp(n->ifname, ifa_name, IFNAMSIZ))
			return (n);
	}
	return (NULL);
}

struct node_host *
ifa_lookup(char *ifa_name, enum pfctl_iflookup_mode mode)
{
	struct node_host	*p = NULL, *h = NULL, *n = NULL;
	int			 return_all = 0;

	if (!strncmp(ifa_name, "self", IFNAMSIZ))
		return_all = 1;

	if (iftab == NULL)
		ifa_load();

	for (p = iftab; p; p = p->next) {
		if (!((p->af == AF_INET || p->af == AF_INET6) &&
		    (!strncmp(p->ifname, ifa_name, IFNAMSIZ) || return_all)))
			continue;
		if (mode == PFCTL_IFLOOKUP_BCAST && p->af != AF_INET)
			continue;
		if (mode == PFCTL_IFLOOKUP_NET && p->ifindex > 0)
			continue;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = p->af;
		if (mode == PFCTL_IFLOOKUP_BCAST)
			memcpy(&n->addr.v.a.addr, &p->bcast,
			    sizeof(struct pf_addr));
		else
			memcpy(&n->addr.v.a.addr, &p->addr.v.a.addr,
			    sizeof(struct pf_addr));
		if (mode == PFCTL_IFLOOKUP_NET)
			set_ipmask(n, unmask(&p->addr.v.a.mask, n->af));
		else {
			if (n->af == AF_INET) {
				if (p->ifa_flags & IFF_LOOPBACK &&
				    p->ifa_flags & IFF_LINK1)
					memcpy(&n->addr.v.a.mask,
					    &p->addr.v.a.mask,
					    sizeof(struct pf_addr));
				else
					set_ipmask(n, 32);
			} else
				set_ipmask(n, 128);
		}
		n->ifindex = p->ifindex;

		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	if (h == NULL && mode == PFCTL_IFLOOKUP_HOST) {
		yyerror("no IP address found for %s", ifa_name);
	}
	return (h);
}

a3968 116
}

struct node_host *
host(char *s, int mask)
{
	struct node_host	*h = NULL, *n;
	struct in_addr		 ina;
	struct addrinfo		 hints, *res0, *res;
	int			 bits, error, v4mask, v6mask;
	char			*buf = NULL;

	if (ifa_exists(s) || !strncmp(s, "self", IFNAMSIZ)) {
		/* interface with this name exists */
		h = ifa_lookup(s, PFCTL_IFLOOKUP_HOST);
		for (n = h; n != NULL && mask > -1; n = n->next)
			set_ipmask(n, mask);
		return (h);
	}

	if (mask == -1) {
		if (asprintf(&buf, "%s", s) == -1)
			err(1, "host: asprintf");
		v4mask = 32;
		v6mask = 128;
	} else if (mask <= 128) {
		if (asprintf(&buf, "%s/%d", s, mask) == -1)
			err(1, "host: asprintf");
		v4mask = v6mask = mask;
	} else {
		yyerror("illegal mask");
		return (NULL);
	}

	memset(&ina, 0, sizeof(struct in_addr));
	if ((bits = inet_net_pton(AF_INET, buf, &ina, sizeof(&ina))) > -1) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET;
		h->addr.v.a.addr.addr32[0] = ina.s_addr;
		set_ipmask(h, bits);
		h->next = NULL;
		h->tail = h;
		free(buf);
		return (h);
	}
	free(buf);

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->ifname = NULL;
		n->af = AF_INET6;
		memcpy(&n->addr.v.a.addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(n->addr.v.a.addr));
		n->ifindex = ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
		set_ipmask(n, v6mask);
		freeaddrinfo(res);
		n->next = NULL;
		n->tail = n;
		return (n);
	}

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM; /* DUMMY */
	error = getaddrinfo(s, NULL, &hints, &res0);
	if (error) {
		yyerror("cannot resolve %s: %s",
		    s, gai_strerror(error));
		return (NULL);
	}
	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->ifname = NULL;
		n->af = res->ai_family;
		if (res->ai_family == AF_INET) {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			set_ipmask(n, v4mask);
		} else {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			n->ifindex =
			    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
			set_ipmask(n, v6mask);
		}
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	freeaddrinfo(res0);
	if (h == NULL) {
		yyerror("no IP address found for %s", s);
		return (NULL);
	}
	return (h);
@


1.287
log
@Whitespace KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.286 2003/01/09 19:02:21 henning Exp $	*/
d498 2
a499 4
			if (asprintf(&$$, "%s %s", $1, $2) == -1) {
				yyerror("asprintf failed");
				YYERROR;
			}
d509 2
a510 4
			if (symset($1, $3) == -1) {
				yyerror("cannot store variable %s", $1);
				YYERROR;
			}
d2042 2
a2043 4
			if (($$ = strdup($2)) == NULL) {
				yyerror("rule label strdup() failed");
				YYERROR;
			}
d2121 1
a2121 1
			$$ = malloc(sizeof(struct pf_poolhashkey));
d2123 1
a2123 1
				err(1, "pooltype: malloc");
d2423 2
a2424 4
				if (pa == NULL) {
					yyerror("calloc");
					YYERROR;
				}
d2570 2
a2571 4
			if (($$->ifname = strdup($1)) == NULL) {
				yyerror("routeto: strdup");
				YYERROR;
			}
d2582 2
a2583 4
			if (($$->ifname = strdup($2)) == NULL) {
				yyerror("routeto: strdup");
				YYERROR;
			}
d3319 2
a3320 4
			if (pa == NULL) {
				yyerror("calloc");
				error++;
			}
d3418 2
a3419 4
			if (pa == NULL) {
				yyerror("calloc");
				error++;
			}
d3497 2
a3498 4
			if (pa == NULL) {
				yyerror("calloc");
				error++;
			}
d4035 2
a4036 4
		if ((n->ifname = strdup(ifa->ifa_name)) == NULL) {
			yyerror("strdup failed");
			exit(1);
		}
@


1.286
log
@no need for explicit numbering in enums

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.285 2003/01/09 18:42:44 dhartmei Exp $	*/
d816 1
a816 1
			 pfctl_append_addr($2, $4, 1);
@


1.285
log
@Check return values on the remaining strlcpy/strlcat. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.284 2003/01/09 17:59:23 henning Exp $	*/
d74 6
a79 6
	PFCTL_STATE_NONE = 0,
	PFCTL_STATE_OPTION = 1,
	PFCTL_STATE_SCRUB = 2,
	PFCTL_STATE_QUEUE = 3,
	PFCTL_STATE_NAT = 4,
	PFCTL_STATE_FILTER = 5
d83 3
a85 3
	PFCTL_IFLOOKUP_HOST = 0,
	PFCTL_IFLOOKUP_NET = 1,
	PFCTL_IFLOOKUP_BCAST = 2
@


1.284
log
@minor KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.283 2003/01/09 10:40:44 cedric Exp $	*/
d737 2
a738 2
				if (strlcpy(j->ifname, i->ifname, IFNAMSIZ) >=
				    IFNAMSIZ) {
d864 1
a864 1
			    PF_QNAME_SIZE) {
d1062 3
a1064 3
				err(1, "queue_item: calloc");
			if (strlcpy($$->queue, $1, PF_QNAME_SIZE) >=
			    PF_QNAME_SIZE) {
d1066 2
a1067 1
				yyerror("queue name too long");
d1195 1
a1195 1
				    sizeof(r.label)) >= PF_RULE_LABEL_SIZE) {
d1197 1
a1197 1
					    "%d chars)", PF_RULE_LABEL_SIZE-1);
d1205 1
a1205 1
				    sizeof(r.qname)) >= PF_QNAME_SIZE) {
d1207 1
a1207 1
					    "%d chars)", PF_QNAME_SIZE-1);
d1214 1
a1214 1
				    sizeof(r.pqname)) >= PF_QNAME_SIZE) {
d1216 1
a1216 1
					    "%d chars)", PF_QNAME_SIZE-1);
d1410 2
a1411 2
			if (strlcpy($$->ifname, $1, IFNAMSIZ) >=
			    IFNAMSIZ) {
d1549 4
a1552 1
			strlcpy($$->addr.v.tblname, $2, PF_TABLE_NAME_SIZE);
d2858 16
a2873 8
		tmp[0] = 0;
		strlcat(tmp, label, p-label+1);
		if (!*ifname)
			strlcat(tmp, "any", PF_RULE_LABEL_SIZE);
		else
			strlcat(tmp, ifname, PF_RULE_LABEL_SIZE);
		strlcat(tmp, p+strlen(name), PF_RULE_LABEL_SIZE);
		strlcpy(label, tmp, PF_RULE_LABEL_SIZE);
d2885 8
a2892 6
		tmp[0] = 0;

		strlcat(tmp, label, p-label+1);

		if (h->not)
			strlcat(tmp, "! ", PF_RULE_LABEL_SIZE);
d2894 7
a2900 4
			strlcat(tmp, "(", PF_RULE_LABEL_SIZE);
			strlcat(tmp, h->addr.v.ifname,
			    PF_RULE_LABEL_SIZE);
			strlcat(tmp, ")", PF_RULE_LABEL_SIZE);
d2902 4
a2905 3
		    PF_AZERO(&h->addr.v.a.mask, af)))
			strlcat(tmp, "any", PF_RULE_LABEL_SIZE);
		else {
d2910 6
a2915 3
			    sizeof(a)) == NULL)
				strlcat(a, "?", sizeof(a));
			strlcat(tmp, a, PF_RULE_LABEL_SIZE);
d2921 2
a2922 1
			strlcat(tmp, a, PF_RULE_LABEL_SIZE);
d2924 5
a2928 2
		strlcat(tmp, p+strlen(name), PF_RULE_LABEL_SIZE);
		strlcpy(label, tmp, PF_RULE_LABEL_SIZE);
d2940 4
a2943 4
		tmp[0] = 0;

		strlcat(tmp, label, p-label+1);

d2964 7
a2970 3
		strlcat(tmp, op, PF_RULE_LABEL_SIZE);
		strlcat(tmp, p+strlen(name), PF_RULE_LABEL_SIZE);
		strlcpy(label, tmp, PF_RULE_LABEL_SIZE);
d2982 4
a2985 2
		tmp[0] = 0;
		strlcat(tmp, label, p-label+1);
d2987 11
a2997 7
		if (pe != NULL)
		    strlcat(tmp, pe->p_name, PF_RULE_LABEL_SIZE);
		else
		    snprintf(tmp+strlen(tmp), PF_RULE_LABEL_SIZE-strlen(tmp),
			"%u", proto);
		strlcat(tmp, p+strlen(name), PF_RULE_LABEL_SIZE);
		strlcpy(label, tmp, PF_RULE_LABEL_SIZE);
d3008 4
a3011 2
		tmp[0] = 0;
		strlcat(tmp, label, p-label+1);
d3014 5
a3018 2
		strlcat(tmp, p+strlen(name), PF_RULE_LABEL_SIZE);
		strlcpy(label, tmp, PF_RULE_LABEL_SIZE);
d3048 3
a3050 1
		strlcpy(pa.ifname, interface->ifname, IFNAMSIZ);
d3080 12
a3091 5
				strlcpy(qname, "root_", sizeof(qname));
				strlcat(qname, interface->ifname,
				    sizeof(qname));
				strlcpy(pb.qname, qname, PF_QNAME_SIZE);
				strlcpy(pb.ifname, interface->ifname, IFNAMSIZ);
d3107 10
a3116 4
					strlcpy(n->parent, qname,
					    PF_QNAME_SIZE);
				strlcpy(n->queue, queue->queue, PF_QNAME_SIZE);
				strlcpy(n->ifname, interface->ifname, IFNAMSIZ);
d3178 9
a3186 3
				strlcpy(n->parent, a->qname, PF_QNAME_SIZE);
				strlcpy(n->queue, queue->queue, PF_QNAME_SIZE);
				strlcpy(n->ifname, tqueue->ifname, IFNAMSIZ);
d3197 6
a3202 2
			strlcpy(a->ifname, tqueue->ifname, IFNAMSIZ);
			strlcpy(a->parent, tqueue->parent, PF_QNAME_SIZE);
d3249 2
a3250 1
	strlcpy(label, r->label, sizeof(label));
d3289 3
a3291 1
		strlcpy(r->label, label, PF_RULE_LABEL_SIZE);
d3336 6
a3341 3
			if (h->ifname != NULL)
				strlcpy(pa->ifname, h->ifname, IFNAMSIZ);
			else
@


1.283
log
@Add support for active/inactive tablesets in the kernel.
Add table definition/initialisation construct in pfctl parser.
Add and fix documentation for pf.4 and pf.conf.5.
Tested on i386 and sparc64 by myself, macppc by Daniel.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.282 2003/01/08 19:47:37 deraadt Exp $	*/
d1160 1
a1160 1
				if(!r.direction) {
d3077 1
a3077 1
	return(errs);
d3141 1
a3141 1
				if(!pfctl_add_altq(pf, a))
@


1.282
log
@check more strlcpy; camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.281 2003/01/07 04:20:06 dhartmei Exp $	*/
d380 1
a380 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS DROP
d393 1
a393 1
%type	<v.number>		tos
d443 1
d780 40
d3573 1
@


1.281
log
@Allow underscore at the beginning of strings, fixes
  pass all user _spamd
which was refused as syntax error before. Reported by Joe Nall.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.280 2003/01/07 00:21:07 dhartmei Exp $	*/
d736 6
a741 1
				strlcpy(j->ifname, i->ifname, IFNAMSIZ);
d1022 6
a1027 1
			strlcpy($$->queue, $1, PF_QNAME_SIZE);
d1368 6
a1373 1
			strlcpy($$->ifname, $1, IFNAMSIZ);
d1531 7
a1537 2
			strlcpy($$->addr.v.ifname, $2,
			    sizeof($$->addr.v.ifname));
@


1.280
log
@Remove table name hashing (pass the name in each ioctl instead), and
introduce reference counting for tables, they are now automatically
created and deleted through referencing rules. Diff partly from cedric@@.
ok mcbride@@, henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.279 2003/01/06 11:30:10 mcbride Exp $	*/
d3742 1
a3742 1
	if (isalnum(c) || c == ':') {
@


1.279
log
@Fix some oversights with address pools for route-to/dup-to/reply-to
- copy key for src-hash
- copy pool type (pools were being set to round-robin in all cases)

+ some minor knf.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.278 2003/01/05 22:20:34 henning Exp $	*/
a1481 3
			struct pfr_table tbl;
			int exists = 0;

d1484 4
d1491 4
a1494 9
			$$->af = 0;
			bzero(&tbl, sizeof(tbl));
			strlcpy(tbl.pfrt_name, $2, sizeof(tbl.pfrt_name));
			if (pfr_wrap_table(&tbl, &$$->addr, &exists, 0))
				err(1, "pfr_wrap_table");
			if (!exists)
				fprintf(stderr, "warning: %s "
				    "table is not currently defined\n",
				    tbl.pfrt_name);
@


1.278
log
@err after calloc failure, not errx
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.277 2003/01/05 22:14:23 dhartmei Exp $	*/
d1116 3
d2242 1
a2242 1
			if ($8.key != NULL) {
a2244 1
			}
d2483 1
a2483 1
			if ($12.key != NULL) {
a2485 1
			}
d2576 1
d2583 1
d2590 1
@


1.277
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.276 2003/01/04 17:40:51 dhartmei Exp $	*/
d735 1
a735 1
					errx(1, "antispoof: calloc");
@


1.276
log
@move noroute from flag in pf_rule_addr into type in pf_addr_wrap.
ok henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.275 2003/01/04 00:01:34 deraadt Exp $	*/
d1516 3
a1518 3
			$$->addr.addr_dyn = (struct pf_addr_dyn *)1;
			strlcpy($$->addr.addr.pfa.ifname, $2,
			    sizeof($$->addr.addr.pfa.ifname));
d2222 1
a2222 1
					    unmask(&$7->host->addr.mask,
d2225 1
a2225 1
					    unmask(&$7->host->addr.mask,
d2285 1
a2285 1
				if ($7->addr.addr_dyn != NULL) {
d2298 6
a2303 4
				memcpy(&binat.src.addr.addr, &$7->addr.addr,
				    sizeof(binat.src.addr.addr));
				memcpy(&binat.src.addr.mask, &$7->addr.mask,
				    sizeof(binat.src.addr.mask));
d2311 1
a2311 1
				if ($9->addr.addr_dyn != NULL) {
d2324 6
a2329 4
				memcpy(&binat.dst.addr.addr, &$9->addr.addr,
				    sizeof(binat.dst.addr.addr));
				memcpy(&binat.dst.addr.mask, &$9->addr.mask,
				    sizeof(binat.dst.addr.mask));
d2356 3
a2358 3
				if (!PF_AZERO(&binat.src.addr.mask, binat.af) &&
				    !PF_AEQ(&binat.src.addr.mask,
				    &$10->host->addr.mask, binat.af)) {
d2399 6
a2404 4
				memcpy(&rdr.src.addr.addr, &$7->addr.addr,
				    sizeof(rdr.src.addr.addr));
				memcpy(&rdr.src.addr.mask, &$7->addr.mask,
				    sizeof(rdr.src.addr.mask));
d2410 6
a2415 4
				memcpy(&rdr.dst.addr.addr, &$9->addr.addr,
				    sizeof(rdr.dst.addr.addr));
				memcpy(&rdr.dst.addr.mask, &$9->addr.mask,
				    sizeof(rdr.dst.addr.mask));
d2464 1
a2464 1
					    unmask(&$11->host->addr.mask,
d2467 1
a2467 1
					    unmask(&$11->host->addr.mask,
d2679 2
a2680 2
	if (!r->af && (r->src.addr.addr_dyn != NULL ||
	    r->dst.addr.addr_dyn != NULL)) {
d2709 1
a2709 1
			if (pa->addr.addr.addr_dyn != NULL) {
d2732 2
a2733 2
		if (r->src.addr.addr_dyn != NULL ||
		    r->dst.addr.addr_dyn != NULL) {
d2739 1
a2739 1
				if (pa->addr.addr.addr_dyn != NULL) {
d2818 1
a2818 1
		if (h->addr.addr_dyn != NULL) {
d2820 1
a2820 1
			strlcat(tmp, h->addr.addr.pfa.ifname,
d2823 2
a2824 2
		} else if (!af || (PF_AZERO(&h->addr.addr, af) &&
		    PF_AZERO(&h->addr.mask, af)))
d2830 1
a2830 1
			if (inet_ntop(af, &h->addr.addr, a,
d2834 1
a2834 1
			bits = unmask(&h->addr.mask, af);
d3795 1
a3795 1
	m = &h->addr.mask;
d3810 1
a3810 1
	n = &h->addr.addr;
a3878 1
		n->addr.addr_dyn = NULL;
d3896 1
a3896 1
			memcpy(&n->addr.addr, &((struct sockaddr_in *)
d3899 1
a3899 1
			memcpy(&n->addr.mask, &((struct sockaddr_in *)
d3907 1
a3907 1
			memcpy(&n->addr.addr, &((struct sockaddr_in6 *)
d3910 1
a3910 1
			memcpy(&n->addr.mask, &((struct sockaddr_in6 *)
d3976 5
a3980 6
		n->addr.addr_dyn = NULL;
		if (mode == PFCTL_IFLOOKUP_BCAST) {
				memcpy(&n->addr.addr, &p->bcast,
				    sizeof(struct pf_addr));
		} else
			memcpy(&n->addr.addr, &p->addr.addr,
d3983 1
a3983 1
			set_ipmask(n, unmask(&p->addr.mask, n->af));
d3988 2
a3989 1
					memcpy(&n->addr.mask, &p->addr.mask,
d4108 1
a4108 2
		h->addr.addr_dyn = NULL;
		h->addr.addr.addr32[0] = ina.s_addr;
d4127 1
a4127 2
		n->addr.addr_dyn = NULL;
		memcpy(&n->addr.addr,
d4129 1
a4129 1
		    sizeof(n->addr.addr));
a4155 1
		n->addr.addr_dyn = NULL;
d4157 1
a4157 1
			memcpy(&n->addr.addr,
d4162 1
a4162 1
			memcpy(&n->addr.addr,
@


1.275
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.274 2003/01/03 22:22:18 dhartmei Exp $	*/
a106 1
	u_int8_t		 noroute;
d1470 1
a1470 1
			$$->noroute = 1;
a3160 1
		r->src.noroute = src_host->noroute;
a3165 1
		r->dst.noroute = dst_host->noroute;
a3278 1
		n->src.noroute = src_host->noroute;
a3283 1
		n->dst.noroute = dst_host->noroute;
a3365 1
		r->src.noroute = src_host->noroute;
a3367 1
		r->dst.noroute = dst_host->noroute;
@


1.274
log
@whitespace KNF (no, i don't touch the option inits)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.273 2003/01/03 21:37:44 cedric Exp $	*/
a56 1
#include "pf_print_state.h"
d58 1
a58 2
#include "pfctl_radix.h"
#include "pfctl_altq.h"
@


1.273
log
@Bring in userland code for accessing PF radix tables.
ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.272 2003/01/02 11:34:59 mcbride Exp $	*/
d297 1
a297 1
			     sa_family_t *);
d299 1
a299 1
			     sa_family_t *);
d2329 1
a2329 1
				binat.dst.not  = $9->not;
d2402 1
a2402 1
				rdr.src.not  = $7->not;
d2411 1
a2411 1
				rdr.dst.not  = $9->not;
d2442 2
a2443 2
				rdr.rpool.proxy_port[0]  = $11->rport.a;
				rdr.rpool.port_op  |= $11->rport.t;
d3030 1
a3030 1
				   "interface allowed");
d3708 1
a3708 1
		} else  if (next == '=') {
d3721 1
a3721 1
		} else  if (next == '=') {
d3886 1
a3886 2
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id == 0)
		    {
@


1.272
log
@Require a direction to be specified for rules which do routing.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.271 2002/12/30 23:46:54 mcbride Exp $	*/
d59 1
d1481 19
@


1.271
log
@Change ipv6-icmp-type to icpm6-type. pf.conf files will need to be adjusted
to reflect this.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.270 2002/12/27 22:13:31 mcbride Exp $	*/
d1111 5
@


1.270
log
@Since pf_norm.c looks at rule.log to see if it should log packets being
dropped due to scrub violations, this adds the ability to set this in
pf.conf.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.269 2002/12/21 18:53:48 henning Exp $	*/
d1873 1
a1873 1
					yyerror("unknown ipv6-icmp-type %s", $1);
d3440 1
a3443 1
		{ "ipv6-icmp-type",	ICMP6TYPE},
@


1.269
log
@always initialize rpool.key; diff from Frank Denis; KNF by me
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.268 2002/12/21 18:47:33 henning Exp $	*/
d620 1
a620 1
scrubrule	: SCRUB dir interface af fromto scrub_opts
d632 8
a639 2
			if ($3) {
				if ($3->not) {
d645 2
a646 2
			r.af = $4;
			if ($6.nodf)
d648 6
a653 6
			if ($6.minttl)
				r.min_ttl = $6.minttl;
			if ($6.maxmss)
				r.max_mss = $6.maxmss;
			if ($6.fragcache)
				r.rule_flag |= $6.fragcache;
d655 2
a656 2
			expand_rule(&r, $3, NULL, NULL,
			    $5.src.host, $5.src.port, $5.dst.host, $5.dst.port,
@


1.268
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.267 2002/12/20 19:57:37 dhartmei Exp $	*/
d2079 15
a2093 3
pooltype	: /* empty */			{ $$.type = PF_POOL_NONE; }
		| BITMASK			{ $$.type = PF_POOL_BITMASK; }
		| RANDOM			{ $$.type = PF_POOL_RANDOM; }
d2099 5
a2103 1
		| ROUNDROBIN			{ $$.type = PF_POOL_ROUNDROBIN; }
@


1.267
log
@remove a redundant assignment.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.266 2002/12/19 10:58:21 dhartmei Exp $	*/
d282 4
a285 4
	struct sym *next;
	int used;
	char *nam;
	char *val;
d287 1
a287 1
struct sym *symhead = NULL;
d537 1
a537 1
			struct pf_rule r;
d553 1
a553 1
			struct pf_rule r;
d588 1
a588 1
			struct pf_rule r;
d933 1
a933 1
					;
d1071 1
a1071 1
				struct node_state_opt *p = o;
d1108 1
a1109 1

d1372 2
a1373 2
			u_int8_t pr;
			u_long ulval;
d1382 1
a1382 1
				struct protoent *p;
d1588 2
a1589 1
				yyerror("user unknown requires operator = or !=");
d1603 2
a1604 1
				yyerror("user unknown requires operator = or !=");
d1625 1
a1625 1
					struct passwd *pw;
d1667 2
a1668 1
				yyerror("group unknown requires operator = or !=");
d1682 2
a1683 1
				yyerror("group unknown requires operator = or !=");
d1704 1
a1704 1
					struct group *grp;
d2063 1
a2063 1
				MD5_CTX context;
d2189 2
a2190 1
							nat.rpool.opts = $8.type;
d2303 2
a2304 2
					yyerror("binat rule must redirect to a single "
					    "address");
d2334 2
a2335 1
rdrrule		: no RDR interface af proto FROM ipspec TO ipspec dport redirpool pooltype
d2629 2
a2630 1
		yyerror("dynamic addresses require address family (inet/inet6)");
d2775 2
a2776 2
			char a[48];
			int bits;
d3587 1
a3587 1
		;
d3592 1
a3592 1
			;
d3737 2
a3738 2
				fprintf(stderr, "warning: macro '%s' not used\n",
				    sym->nam);
d3813 1
a3813 1
struct node_host *iftab;
d3837 5
a3841 3
		    IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr) &&
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id == 0) {
			struct sockaddr_in6 *sin6;
@


1.266
log
@fix 'no rdr'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.265 2002/12/18 18:01:41 henning Exp $	*/
a2222 1
			binat.af = $4;
@


1.265
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.264 2002/12/18 10:16:55 dhartmei Exp $	*/
a2344 1
			rdr.action = PF_RDR;
@


1.264
log
@proto list expansion is not supported in binat-anchor yet, print an error
when attempted.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.263 2002/12/18 10:02:40 dhartmei Exp $	*/
d269 11
a279 10
int	check_rulestate(int);
int	kw_cmp(const void *, const void *);
int	lookup(char *);
int	lgetc(FILE *);
int	lungetc(int);
int	findeol(void);
int	yylex(void);
struct	node_host *host(char *, int);
int	atoul(char *, u_long *);
int	getservice(char *);
d289 2
a290 2
int	symset(const char *, const char *);
char *	symget(const char *);
d292 8
a299 6
void	ifa_load(void);
struct	node_host *ifa_exists(char *);
struct	node_host *ifa_lookup(char *, enum pfctl_iflookup_mode);
void	decide_address_family(struct node_host *, sa_family_t *);
void	remove_invalid_hosts(struct node_host **, sa_family_t *);
u_int16_t	parseicmpspec(char *, sa_family_t);
d303 2
a304 2
		u_int32_t		number;
		int			i;
d307 5
a311 5
			u_int8_t	b1;
			u_int8_t	b2;
			u_int16_t	w;
			u_int16_t	w2;
		}			b;
d313 4
a316 4
			int		a;
			int		b;
			int		t;
		}			range;
d325 1
a325 1
		struct peer		peer;
d327 2
a328 2
			struct peer	src, dst;
		}			fromto;
d332 3
a334 3
			u_int8_t	rt;
			u_int8_t	pool_opts;
			sa_family_t	af;
d336 1
a336 1
		}			route;
d342 1
a342 1
			int		type;
d344 1
a344 1
		}			pooltype;
d348 1
a348 1
		}			keep_state;
d350 3
a352 3
			u_int8_t	log;
			u_int8_t	quick;
		}			logquick;
d354 6
a359 6
		struct node_queue_opt	queue_options;
		struct node_queue_bw	queue_bwspec;
		struct node_qassign	qassign;
		struct filter_opts	filter_opts;
		struct queue_opts	queue_opts;
		struct scrub_opts	scrub_opts;
@


1.263
log
@Support (single) destination port in rdr-anchor rules. Print an error
where parameters are not supported (in rdr-anchor and binat-anchor) yet.
If those are needed, we'll have to expand them properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.262 2002/12/18 08:01:47 deraadt Exp $	*/
d594 5
@


1.262
log
@fix some INCREDIBLE new bugs which were introduced
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.261 2002/12/17 20:06:05 henning Exp $	*/
d562 20
d591 1
a591 1
			r.action = PF_NAT;
d593 11
@


1.261
log
@add support for the PRIQ scheduler

partitially from kjc@@

ok kjc@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.260 2002/12/17 12:36:59 mcbride Exp $	*/
a522 1

a535 1
			r.action = PF_NAT;
d540 1
a540 1

a551 2
			r.action = PF_RDR;
			if (check_rulestate(PFCTL_STATE_NAT))
d556 1
a556 1

a566 1
			r.action = PF_NAT;
d571 1
a571 1

@


1.260
log
@Match merge of pf_nat/pf_binat/pf_rdr structs into pf_rule

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.259 2002/12/17 12:05:58 henning Exp $	*/
d168 1
d175 3
a177 2
	union {	/* options for other schedulers will follow */
		struct cbq_opts		 cbq_opts;
d385 1
a385 1
%token	ALTQ CBQ BANDWIDTH TBRSIZE
d422 1
d753 4
d801 4
d930 8
d952 10
d2905 3
a2907 1
				strlcpy(n->parent, qname, PF_QNAME_SIZE);
d2910 1
d2940 27
d2974 1
d3404 1
@


1.259
log
@missing break in switch
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.258 2002/12/17 12:01:22 henning Exp $	*/
d242 2
a243 2
int	nat_consistent(struct pf_nat *);
int	rdr_consistent(struct pf_rdr *);
d246 1
a246 1
void	expand_rdr(struct pf_rdr *, struct node_if *, struct node_proto *,
d248 1
a248 1
void	expand_nat(struct pf_nat *, struct node_if *, struct node_proto *,
d532 1
a532 1
			struct pf_nat r;
d534 1
d549 1
a549 1
			struct pf_rdr r;
d551 2
d566 1
a566 1
			struct pf_binat r;
d568 1
d579 1
a579 1
			pfctl_add_binat(pf, &r);
d1043 1
a1043 1
				r.rt_pool.opts = $5.pool_opts;
d1054 2
a1055 2
					if (r.rt_pool.opts == PF_POOL_NONE)
						r.rt_pool.opts =
d1057 1
a1057 1
					if (r.rt_pool.opts !=
d1925 1
a1925 1
				$$.t = PF_RPORT_RANGE;
d1931 1
a1931 1
				$$.t = PF_RPORT_RANGE;
d2046 1
a2046 1
			struct pf_nat	nat;
d2053 4
a2056 1
			nat.no = $1;
d2068 1
a2068 1
			if (nat.no) {
d2086 5
a2090 4
				nat.proxy_port[0] = ntohs($7->rport.a);
				nat.proxy_port[1] = ntohs($7->rport.b);
				if (!nat.proxy_port[0] && !nat.proxy_port[1]) {
					nat.proxy_port[0] =
d2092 1
a2092 1
					nat.proxy_port[1] =
d2094 3
a2096 3
				} else if (!nat.proxy_port[1])
					nat.proxy_port[1] = nat.proxy_port[0];

d2141 2
a2142 1
			struct pf_binat	binat;
d2149 6
a2154 1
			binat.no = $1;
d2187 4
a2190 4
				memcpy(&binat.saddr.addr, &$7->addr.addr,
				    sizeof(binat.saddr.addr));
				memcpy(&binat.saddr.mask, &$7->addr.mask,
				    sizeof(binat.saddr.mask));
d2211 5
a2215 5
				memcpy(&binat.daddr.addr, &$9->addr.addr,
				    sizeof(binat.daddr.addr));
				memcpy(&binat.daddr.mask, &$9->addr.mask,
				    sizeof(binat.daddr.mask));
				binat.dnot  = $9->not;
d2219 1
a2219 1
			if (binat.no) {
d2240 4
a2243 7
				memcpy(&binat.raddr.addr, &$10->host->addr.addr,
				    sizeof(binat.raddr.addr));
				memcpy(&binat.raddr.mask, &$10->host->addr.mask,
				    sizeof(binat.raddr.mask));
				if (!PF_AZERO(&binat.saddr.mask, binat.af) &&
				    !PF_AEQ(&binat.saddr.mask,
				    &binat.raddr.mask, binat.af)) {
d2248 12
d2263 1
a2263 1
			pfctl_add_binat(pf, &binat);
d2269 1
a2269 1
			struct pf_rdr	rdr;
d2276 4
a2279 1
			rdr.no = $1;
d2281 2
d2284 5
a2288 5
				memcpy(&rdr.saddr.addr, &$7->addr.addr,
				    sizeof(rdr.saddr.addr));
				memcpy(&rdr.saddr.mask, &$7->addr.mask,
				    sizeof(rdr.saddr.mask));
				rdr.snot  = $7->not;
d2293 5
a2297 5
				memcpy(&rdr.daddr.addr, &$9->addr.addr,
				    sizeof(rdr.daddr.addr));
				memcpy(&rdr.daddr.mask, &$9->addr.mask,
				    sizeof(rdr.daddr.mask));
				rdr.dnot  = $9->not;
d2302 3
a2304 3
			rdr.dport  = $10.a;
			rdr.dport2 = $10.b;
			rdr.opts  |= $10.t;
d2311 1
a2311 1
			if (rdr.no) {
d2328 2
a2329 2
				rdr.rport  = $11->rport.a;
				rdr.opts  |= $11->rport.t;
d2381 2
a2382 1
				$$.b = $$.t = 0;
d2388 1
a2388 1
				$$.t = PF_DPORT_RANGE;
d2582 1
a2582 1
nat_consistent(struct pf_nat *r)
d2589 1
a2589 1
			if (pa->addr.addr_dyn != NULL) {
d2601 1
a2601 1
rdr_consistent(struct pf_rdr *r)
d2607 1
a2607 1
	    (r->dport || r->dport2 || r->rport)) {
d2612 2
a2613 1
		if (r->saddr.addr_dyn != NULL || r->daddr.addr_dyn != NULL) {
d2619 1
a2619 1
				if (pa->addr.addr_dyn != NULL) {
d2958 1
a2958 1
    struct node_if *interfaces, struct node_host *rt_pool_hosts,
d3050 2
a3051 2
		TAILQ_INIT(&r->rt_pool.list);
		for (h = rt_pool_hosts; h != NULL; h = h->next) {
d3057 1
a3057 1
			pa->addr = h->addr;
d3062 1
a3062 1
			TAILQ_INSERT_TAIL(&r->rt_pool.list, pa, entries);
d3084 1
a3084 1
	FREE_LIST(struct node_host, rt_pool_hosts);
d3091 1
a3091 1
expand_nat(struct pf_nat *n,
d3157 1
a3157 1
			pa->addr = h->addr;
d3165 1
a3165 1
			pfctl_add_nat(pf, n);
d3184 1
a3184 1
expand_rdr(struct pf_rdr *r, struct node_if *interfaces,
d3224 1
d3226 6
a3231 3
		r->ifnot = interface->not;
		r->saddr = src_host->addr;
		r->daddr = dst_host->addr;
d3240 1
a3240 1
			pa->addr = h->addr;
d3248 1
a3248 1
			pfctl_add_rdr(pf, r);
@


1.258
log
@beautify the %type block
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.257 2002/12/17 11:29:04 henning Exp $	*/
d745 3
@


1.257
log
@PRIQ and HFSC support functions, not yet used.
mostly from kjc@@ with adjustments by me.

ok theo ryan daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.256 2002/12/16 23:36:14 henning Exp $	*/
d386 32
a417 30
%token	<v.string> STRING
%token	<v.i>	PORTUNARY PORTBINARY
%type	<v.interface>	interface if_list if_item_not if_item
%type	<v.number>	number port icmptype icmp6type uid gid
%type	<v.number>	tos
%type	<v.i>	no dir log af fragcache
%type	<v.i>	staticport
%type	<v.b>	action flags flag blockspec
%type	<v.range>	dport rport
%type	<v.hashkey>     hashkey
%type	<v.pooltype>	pooltype
%type	<v.proto>	proto proto_list proto_item
%type	<v.icmp>	icmpspec icmp_list icmp6_list icmp_item icmp6_item
%type	<v.fromto>	fromto
%type	<v.peer>	ipportspec
%type	<v.host>	ipspec xhost host address host_list
%type	<v.host>	redir_host_list redirspec
%type	<v.host>	route_host route_host_list routespec
%type	<v.port>	portspec port_list port_item
%type	<v.uid>		uids uid_list uid_item
%type	<v.gid>		gids gid_list gid_item
%type	<v.route>	route
%type	<v.redirection>	redirection redirpool
%type	<v.string>	label string
%type	<v.keep_state>	keep
%type	<v.state_opt>	state_opt_spec state_opt_list state_opt_item
%type	<v.logquick>	logquick
%type	<v.interface>	antispoof_ifspc antispoof_iflst
%type	<v.qassign>	qname
%type	<v.queue>	qassign qassign_list qassign_item
d419 1
a419 1
%type	<v.number>	cbqflags_list cbqflags_item
@


1.256
log
@only create a root queue if scheduler = cbq
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.255 2002/12/16 22:50:11 henning Exp $	*/
d39 4
@


1.255
log
@get full [scheduler]_opts struct instead of just .flags, and wrap in into a
switch (scheduler) statement in one case

inspired by kjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.254 2002/12/13 21:51:25 henning Exp $	*/
d2815 12
a2826 13
			/* now create a root queue */
			memset(&pb, 0, sizeof(struct pf_altq));
			strlcpy(qname, "root_", sizeof(qname));
			strlcat(qname, interface->ifname, sizeof(qname));
			strlcpy(pb.qname, qname, PF_QNAME_SIZE);
			strlcpy(pb.ifname, interface->ifname, IFNAMSIZ);
			pb.qlimit = pa.qlimit;
			pb.scheduler = pa.scheduler;
			pb.pq_u.cbq_opts = pa.pq_u.cbq_opts;
			if (eval_pfqueue(pf, &pb, pa.ifbandwidth, 0))
				errs++;
			else
				if (pfctl_add_altq(pf, &pb))
d2828 4
@


1.254
log
@allow a second queue for higher priorized (currently: tos=lowdelay) packets
to be specified per rule

queue (qname, priorized_qname)

idea dhartmei
ok dhartmei@@ frantzen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.253 2002/12/13 20:02:40 henning Exp $	*/
d735 5
a739 2
			a.pq_u.cbq_opts.flags =
			    $3.scheduler.data.cbq_opts.flags;
d778 4
a781 2
				a.pq_u.cbq_opts.flags =
				    $3.scheduler.data.cbq_opts.flags;
d2823 1
a2823 1
			pb.pq_u.cbq_opts.flags = pa.pq_u.cbq_opts.flags;
@


1.253
log
@a bit KNF originally part of another diff soon to come; frantzen@@ correctly
pointed out that should be a seperate commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.252 2002/12/13 12:06:27 deraadt Exp $	*/
d180 5
d208 1
a208 1
	char			*qname;
d347 1
d410 1
a410 1
%type	<v.string>	qname
d1058 2
a1059 2
			if ($9.qname) {
				if (strlcpy(r.qname, $9.qname,
d1065 10
a1074 1
				free($9.qname);
d1156 1
a1156 1
			if (filter_opts.qname) {
d1160 1
a1160 1
			filter_opts.qname = $1;
d1876 12
a1887 5
qname		: QUEUE STRING			{
			if (($$ = strdup($2)) == NULL) {
				yyerror("qname strdup() failed");
				YYERROR;
			}
@


1.252
log
@permit re-ordering of some scrub parameters, and also clean up some other
grammer balony; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.251 2002/12/12 15:06:16 henning Exp $	*/
d181 1
a181 1
	int			marker;
d186 2
a187 2
	struct node_uid *uid;
	struct node_gid *gid;
d189 4
a192 4
		u_int8_t	b1;
		u_int8_t	b2;
		u_int16_t	w;
		u_int16_t	w2;
d194 2
a195 2
	struct node_icmp *icmpspec;
	u_int32_t tos;
d200 4
a203 4
	int fragment;
	int allowopts;
	char *label;
	char *qname;
@


1.251
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.250 2002/12/12 14:46:26 henning Exp $	*/
d206 11
d344 1
d379 1
a379 1
%type	<v.number>	number port icmptype icmp6type minttl uid gid maxmss
d381 1
a381 1
%type	<v.i>	no dir log af nodf allowopts fragment fragcache
a403 1
%type	<v.number>	priority qlimit tbrsize
d411 1
d567 1
a567 1
scrubrule	: SCRUB dir interface af fromto nodf minttl maxmss fragcache
d587 1
a587 1
			if ($6)
d589 6
a594 6
			if ($7)
				r.min_ttl = $7;
			if ($8)
				r.max_mss = $8;
			if ($9)
				r.rule_flag |= $9;
d602 57
d809 1
a809 1
		| priority	{
d814 4
d819 1
a819 1
			queue_opts.priority = $1;
d821 1
a821 1
		| qlimit	{
d826 4
d831 1
a831 1
			queue_opts.qlimit = $1;
d841 1
a841 1
		| tbrsize	{
d846 4
d851 1
a851 1
			queue_opts.tbrsize = $1;
a886 9
priority	: PRIORITY number	{
			if ($2 > 255) {
				yyerror("priority out of range: max 255");
				YYERROR;
			}
			$$ = $2;
		}
		;

a908 18
qlimit		: QLIMIT number		{
			if ($2 > 65535) {
				yyerror("qlimit out of range: max 65535");
				YYERROR;
			}
			$$ = $2;
		}
		;

tbrsize		: TBRSIZE number	{
			if ($2 > 65535) {
				yyerror("tbrsize too big: max 65535");
				YYERROR;
			}
			$$ = $2;
		}
		;

d1127 2
a1128 2
		| fragment {
			filter_opts.fragment = $1;
d1130 2
a1131 2
		| allowopts {
			filter_opts.allowopts = $1;
a1207 6
fragcache	: /* empty */		{ $$ = 0; }
		| fragment FRAGNORM	{ $$ = 0; /* default */ }
		| fragment FRAGCROP	{ $$ = PFRULE_FRAGCROP; }
		| fragment FRAGDROP	{ $$ = PFRULE_FRAGDROP; }
		;

a1852 22
fragment	: FRAGMENT			{ $$ = 1; }

minttl		: /* empty */			{ $$ = 0; }
		| MINTTL number			{
			if ($2 > 255) {
				yyerror("illegal min-ttl value %d", $2);
				YYERROR;
			}
			$$ = $2;
		}
		;

nodf		: /* empty */			{ $$ = 0; }
		| NODF				{ $$ = 1; }
		;

maxmss		: /* empty */			{ $$ = 0; }
		| MAXMSS number			{ $$ = $2; }
		;

allowopts	: ALLOWOPTS			{ $$ = 1; }

d1860 1
@


1.250
log
@we don't need to keep a private copy of the queue name in expand_rule,
r->qname is never modified

discussed with dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.249 2002/12/11 13:23:38 mcbride Exp $	*/
d490 1
a490 1
			struct pf_rule r;
d557 1
a557 1
			struct pf_rule r;
d591 3
a593 3
			struct pf_rule r;
			struct node_host *h = NULL;
			struct node_if *i, *j;
d649 1
a649 1
			struct	pf_altq a;
d674 1
a674 1
			struct	pf_altq a;
d775 2
a776 2
			double bps;
			char *cp;
d881 3
a883 3
			struct pf_rule r;
			struct node_state_opt *o;
			struct node_proto *proto;
d977 6
a982 4
						r.rt_pool.opts = PF_POOL_ROUNDROBIN;
					if (r.rt_pool.opts != PF_POOL_ROUNDROBIN) {
						yyerror("r.rt_pool.opts must be "
						    "PF_POOL_ROUNDROBIN");
d989 2
a990 2
				if (strlcpy(r.label, $9.label, sizeof(r.label)) >=
				    PF_RULE_LABEL_SIZE) {
d999 2
a1000 2
				if (strlcpy(r.qname, $9.qname, sizeof(r.qname)) >=
				    PF_QNAME_SIZE) {
d1193 1
a1193 1
			struct node_host *n;
d1306 1
a1306 1
			struct node_host *n;
d1328 1
a1328 1
			u_long ulval;
d1398 2
a1399 2
			struct servent *s = NULL;
			u_long ulval;
d1473 1
a1473 1
			u_long ulval;
d1550 1
a1550 1
			u_long ulval;
d1575 1
a1575 1
			int f;
d1585 2
a1586 2
flags		: FLAGS flag '/' flag		{ $$.b1 = $2.b1; $$.b2 = $4.b1; }
		| FLAGS '/' flag		{ $$.b1 = 0; $$.b2 = $3.b1; }
d1622 2
a1623 2
			const struct icmpcodeent *p;
			u_long ulval;
d1660 2
a1661 2
			const struct icmpcodeent *p;
			u_long ulval;
d1688 2
a1689 2
			const struct icmptypeent *p;
			u_long ulval;
d1708 2
a1709 2
			const struct icmptypeent *p;
			u_long ulval;
d1781 1
a1781 1
			int i;
d1847 1
a1847 1
			char *p = strchr($1, ':');
d1979 1
a1979 1
			struct pf_nat nat;
d2070 1
a2070 1
			struct pf_binat binat;
d2183 1
a2183 1
			struct pf_rdr rdr;
d2285 1
a2285 1
			char *p = strchr($2, ':');
d2423 3
a2425 2
	va_list ap;
	extern char *infile;
a2426 1

d2438 1
a2438 1
	int problems = 0;
d2492 2
a2493 2
	int problems = 0;
	struct pf_pooladdr *pa;
d2511 2
a2512 2
	int problems = 0;
	struct pf_pooladdr *pa;
d2540 1
a2540 1
	int	 k_val;
d2576 2
a2577 2
	char tmp[PF_RULE_LABEL_SIZE];
	char *p;
d2595 2
a2596 2
	char tmp[PF_RULE_LABEL_SIZE];
	char *p;
d2636 3
a2638 3
	char tmp[PF_RULE_LABEL_SIZE];
	char *p;
	char a1[6], a2[6], op[13];
d2674 3
a2676 3
	char tmp[PF_RULE_LABEL_SIZE];
	char *p;
	struct protoent *pe;
d2695 2
a2696 2
	char tmp[PF_RULE_LABEL_SIZE];
	char *p;
d2727 4
a2730 4
	struct	pf_altq pa, pb;
	char	qname[PF_QNAME_SIZE];
	struct	node_queue *n;
	int	errs = 0;
d2804 3
a2806 3
	struct	node_queue *n;
	u_int8_t	added = 0;
	u_int8_t	found = 0;
d2868 7
a2874 7
	sa_family_t	af = r->af;
	int added = 0, error = 0;
	char	ifname[IF_NAMESIZE];
	char	label[PF_RULE_LABEL_SIZE];
	struct pf_pooladdr *pa;
	struct node_host *h;
	u_int8_t flags, flagset;
d3001 5
a3005 5
	char ifname[IF_NAMESIZE];
	struct pf_pooladdr *pa;
	struct node_host *h;
	sa_family_t af = n->af;
	int added = 0, error = 0;
d3092 5
a3096 5
	sa_family_t af = r->af;
	int added = 0, error = 0;
	char ifname[IF_NAMESIZE];
	struct pf_pooladdr *pa;
	struct node_host *h;
d3274 1
a3274 1
	const struct keywords *p;
d3293 3
a3295 3
int	parseindex;
char	pushback_buffer[MAXPUSHBACK];
int	pushback_index = 0;
d3300 1
a3300 1
	int c, next;
d3358 1
a3358 1
	int c;
d3379 4
a3382 3
	char buf[8096], *p, *val;
	int endc, c, next;
	int token;
d3524 1
a3524 1
	struct sym *sym;
d3546 2
a3547 2
	struct pf_addr *m, *n;
	int i, j = 0;
d3576 1
a3576 1
	struct sym *sym;
d3601 1
a3601 1
	struct sym *sym;
d3618 2
a3619 2
	struct ifaddrs *ifap, *ifa;
	struct node_host *n = NULL, *h = NULL;
d3694 1
a3694 1
	struct node_host *n;
d3709 2
a3710 2
	struct node_host *p = NULL, *h = NULL, *n = NULL;
	int return_all = 0;
d3770 1
a3770 1
	sa_family_t target_af = 0;
d3788 1
a3788 1
	struct node_host *n = *nh, *prev = NULL;
d3827 5
a3831 5
	struct node_host *h = NULL, *n;
	struct in_addr ina;
	struct addrinfo hints, *res0, *res;
	int bits, error, v4mask, v6mask;
	char *buf = NULL;
d3946 2
a3947 2
	u_long ulval;
	char *ep;
d3962 2
a3963 2
	struct servent *s;
	u_long ulval;
d3986 3
a3988 3
	const struct icmpcodeent *p;
	u_long ulval;
	u_int8_t icmptype;
@


1.249
log
@Replace strncpy + ugly pointer math with sscanif for reading source-hash keys

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.248 2002/12/09 13:17:48 dhartmei Exp $	*/
a2871 1
	char	qname[PF_QNAME_SIZE];
a2874 1
	strlcpy(qname, r->qname, sizeof(qname));
d2916 1
a2916 2
		strlcpy(r->qname, qname, PF_QNAME_SIZE);
		r->qid = qname_to_qid(qname, r->ifname);
@


1.248
log
@(properly guarded) strcpy() -> strlcpy()
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.247 2002/12/09 03:59:59 deraadt Exp $	*/
a1908 3
			char buf[11] = "0x";
			int i;

d1919 6
a1924 11
				/* convert to binary */
				for (i = 0; i < 4; i++) {
					strncpy((char *)(buf + 2),
					    (char *)($1 + 2 + (i * 8)), 8);
					if (atoul(buf,
					    (u_long *)&$$->key32[i]) == -1) {
						/* not hex */
						free($$);
						yyerror("invalid hex key");
						YYERROR;
					}
@


1.247
log
@do not allow redefinitions in variable option blocks; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.246 2002/12/08 17:00:19 henning Exp $	*/
d339 4
a342 1
		if (strlen(a) >= PF_ANCHOR_NAME_SIZE) {		\
a346 2
		memset(&(r), 0, sizeof(r));			\
		strcpy(r.anchorname, (a));			\
@


1.246
log
@strncpy is evil.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.245 2002/12/08 00:19:47 henning Exp $	*/
d181 5
d207 6
a214 1
	int			bandwidth;
d394 1
a394 1
%type	<v.queue_options>	schedtype
d731 40
a770 5
queue_opt	: bandwidth	{ queue_opts.queue_bwspec = $1; }
		| priority	{ queue_opts.priority = $1; }
		| qlimit	{ queue_opts.qlimit = $1; }
		| schedtype	{ queue_opts.scheduler = $1; }
		| tbrsize	{ queue_opts.tbrsize = $1; }
d814 1
a814 1
schedtype	: CBQ				{
d1035 2
a1036 2
			if (filter_opts.flags.b1 || filter_opts.flags.b2) {
				yyerror("redefining flags");
d1039 1
d1046 2
a1047 2
			if (filter_opts.icmpspec) {
				yyerror("redefining icmpspec");
d1050 1
d1054 2
a1055 2
			if (filter_opts.tos) {
				yyerror("redefining tos");
d1058 1
d1062 2
a1063 2
			if (filter_opts.keep.options) {
				yyerror("redefining keep");
d1066 1
d1078 1
a1078 1
				yyerror("redefining label");
d1085 1
a1085 1
				yyerror("redefining queue");
@


1.245
log
@allow flexible options order like Theo did for rules.

idea, lots of input, motivation and ok deraadt@@

ATTENTION:
this changes the syntax. the "scheduler" keyword is gone now.
old: altq on $interface scheduler cbq ...
new: altq on $interface cbq ...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.244 2002/12/07 23:15:53 dhartmei Exp $	*/
d1293 1
a1293 1
			strncpy($$->addr.addr.pfa.ifname, $2,
d2543 1
a2543 1
		strncpy(label, tmp, PF_RULE_LABEL_SIZE);
d2585 1
a2585 1
		strncpy(label, tmp, PF_RULE_LABEL_SIZE);
d2623 1
a2623 1
		strncpy(label, tmp, PF_RULE_LABEL_SIZE);
d2644 1
a2644 1
		strncpy(label, tmp, PF_RULE_LABEL_SIZE);
d2660 1
a2660 1
		strncpy(label, tmp, PF_RULE_LABEL_SIZE);
d2922 1
a2922 1
				strncpy(pa->ifname, h->ifname, IFNAMSIZ);
@


1.244
log
@Support parameters in anchor rules. Allows conditional evaluation, like:

  anchor spews inet proto tcp from any to any port smtp

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.243 2002/12/07 21:20:23 henning Exp $	*/
d201 9
d322 1
a337 1

d350 1
a350 1
%token	ALTQ SCHEDULER CBQ BANDWIDTH TBRSIZE
d388 1
d637 1
a637 5

/* altq stuff */

altqif		: ALTQ interface SCHEDULER schedtype bandwidth qlimit
		  tbrsize QUEUE qassign	{
d644 1
a644 1
			if ($4.qtype == ALTQT_NONE) {
d648 6
a653 5
			a.scheduler = $4.qtype;
			a.pq_u.cbq_opts.flags = $4.data.cbq_opts.flags;
			a.qlimit = $6;
			a.tbrsize = $7;
			if ($9 == NULL) {
d657 1
a657 1
			if (expand_altq(&a, $2, $9, $5))
d662 1
a662 24
qassign		: /* empty */		{ $$ = NULL; }
		| qassign_item		{ $$ = $1; }
		| '{' qassign_list '}'	{ $$ = $2; }
		;

qassign_list	: qassign_item			{ $$ = $1; }
		| qassign_list comma qassign_item	{
			$1->tail->next = $3;
			$1->tail = $3;
			$$ = $1;
		}
		;

qassign_item	: STRING			{
			$$ = calloc(1, sizeof(struct node_queue));
			if ($$ == NULL)
				err(1, "queue_item: calloc");
			strlcpy($$->queue, $1, PF_QNAME_SIZE);
			$$->next = NULL;
			$$->tail = $$;
		}
		;

queuespec	: QUEUE STRING bandwidth priority qlimit schedtype qassign {
d676 5
a680 1
			if ($4 > 255) {
d684 3
a686 3
			a.priority = $4;
			a.qlimit = $5;
			a.scheduler = $6.qtype;
d689 3
a691 1
				a.pq_u.cbq_opts.flags = $6.data.cbq_opts.flags;
d693 1
a693 1
			if (expand_queue(&a, $7, $3))
a694 1

d698 16
a713 5
schedtype	: /* empty */			{ $$.qtype = ALTQT_NONE; }
		| CBQ				{ $$.qtype = ALTQT_CBQ; }
		| CBQ '(' cbqflags_list ')'	{
			$$.qtype = ALTQT_CBQ;
			$$.data.cbq_opts.flags = $3;
d717 2
a718 2
cbqflags_list	: cbqflags_item				{ $$ |= $1; }
		| cbqflags_list comma cbqflags_item	{ $$ |= $3; }
d721 5
a725 7

cbqflags_item	: DEFAULT	{ $$ = CBQCLF_DEFCLASS; }
		| CONTROL	{ $$ = CBQCLF_CTLCLASS; }
		| BORROW	{ $$ = CBQCLF_BORROW; }
		| RED		{ $$ = CBQCLF_RED; }
		| ECN		{ $$ = CBQCLF_RED|CBQCLF_ECN; }
		| RIO		{ $$ = CBQCLF_RIO; }
d728 1
a728 5
bandwidth	: /* empty */		{
			$$.bw_absolute = 0;
			$$.bw_percent = 100;
		}
		| BANDWIDTH STRING {
a758 1
		;
d760 1
a760 2
priority	: /* empty */		{ $$ = DEFAULT_PRIORITY; }
		| PRIORITY number	{
d769 23
a791 2
qlimit		: /* empty */		{ $$ = DEFAULT_QLIMIT; }
		| QLIMIT number		{
d800 1
a800 3

tbrsize		: /* empty */		{ $$ = 0; }
		| TBRSIZE number	{
d809 23
a1107 1

a2306 1

a3220 1
		{ "scheduler",		SCHEDULER},
@


1.243
log
@more KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.242 2002/12/07 21:16:26 henning Exp $	*/
d468 1
a468 1
anchorrule	: ANCHOR string				{
d471 3
d475 10
a484 2
			r.nr = pf->rule_nr++;
			pfctl_add_rule(pf, &r);
d486 1
a486 1
		| NATANCHOR string			{
d489 3
d493 8
a500 1
			pfctl_add_nat(pf, &r);
d502 1
a502 1
		| RDRANCHOR string			{
d505 3
d509 7
a515 1
			pfctl_add_rdr(pf, &r);
d517 1
a517 1
		| BINATANCHOR string			{
d520 3
d524 6
d1175 7
a1181 1
fromto		: ALL				{
@


1.242
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.241 2002/12/07 20:25:40 henning Exp $	*/
d318 1
a318 1
	do { 							\
d3136 1
a3136 1
		{ "require-order", 	REQUIREORDER},
@


1.241
log
@shadow cleanup

ok mcbride@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.240 2002/12/07 20:09:57 henning Exp $	*/
d57 12
a68 11
static struct pfctl *pf = NULL;
static FILE *fin = NULL;
static int debug = 0;
static int lineno = 1;
static int errors = 0;
static int rulestate = 0;
static u_int16_t returnicmpdefault =  (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
static u_int16_t returnicmp6default = (ICMP6_DST_UNREACH << 8) |
    ICMP6_DST_UNREACH_NOPORT;
static int blockpolicy = PFRULE_DROP;
static int require_order = 1;
@


1.240
log
@kill an unused param to lungetc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.239 2002/12/07 18:16:59 mcbride Exp $	*/
d2425 4
a2428 4
		T *p, *n = r; \
		while (n != NULL) { \
			p = n; \
			n = n->next; \
d2471 1
a2471 1
    struct node_host *host)
d2481 1
a2481 1
		if (host->not)
d2483 1
a2483 1
		if (host->addr.addr_dyn != NULL) {
d2485 1
a2485 1
			strlcat(tmp, host->addr.addr.pfa.ifname,
d2488 2
a2489 2
		} else if (!af || (PF_AZERO(&host->addr.addr, af) &&
		    PF_AZERO(&host->addr.mask, af)))
d2495 1
a2495 1
			if (inet_ntop(af, &host->addr.addr, a,
d2499 1
a2499 1
			bits = unmask(&host->addr.mask, af);
d2608 1
a2608 1
	int	errors = 0;
d2616 1
a2616 1
			errors++;
d2620 1
a2620 1
				errors++;
d2623 1
a2623 1
					errors++;
d2649 1
a2649 1
				errors++;
d2652 1
a2652 1
					errors++;
d2675 1
a2675 1
	return(errors);
d3180 1
a3180 1
lgetc(FILE *fin)
d3198 2
a3199 2
	while ((c = getc(fin)) == '\\') {
		next = getc(fin);
d3203 1
a3203 1
			ungetc(next, fin);
d3212 1
a3212 1
			c = getc(fin);
d3214 1
a3214 1
		ungetc(c, fin);
@


1.239
log
@Convert the hash of a string key to network byte order. Makes regression
work on all platforms.

Bug found by dhartmei@@

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.238 2002/12/06 12:36:02 dhartmei Exp $	*/
d231 1
a231 1
int	lungetc(int, FILE *);
d3222 1
a3222 1
lungetc(int c, FILE *fin)
d3288 1
a3288 1
			lungetc(c, fin);
d3335 1
a3335 1
		lungetc(next, fin);
d3346 1
a3346 1
			lungetc(next, fin);
d3359 1
a3359 1
			lungetc(next, fin);
d3367 1
a3367 1
		lungetc(next, fin);
d3385 1
a3385 1
		lungetc(c, fin);
@


1.238
log
@Remove negated address list check again, doesn't work right yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.237 2002/12/06 00:47:31 dhartmei Exp $	*/
d1814 4
@


1.237
log
@Introduce anchors and named rule sets, allowing to load additional rule
sets with pfctl and evaluate them from the main rule set using a new type
of rule (which will support conditional evaluation soon). Makes
maintenance of sub-rulesets simpler for pfctl and daemons.

Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.236 2002/12/05 15:28:00 henning Exp $	*/
d1175 4
a1178 5
			if ($2->next != NULL) {
				yyerror("negated address list");
				YYERROR;
			} else
				$2->not = 1;
@


1.236
log
@fix a small cosmetic problem. if ifa_lookup was called in LOOKUP_NET mode,
it would return things like 127.0.0.1/8. when 127.0.0.1/8 is passed through
the new selftests, it becomes 127.0.0.0/8.
fix: instead of just copying addr.mask in ifa_lookup, use set_ipmask, so it
is 127.0.0.0/8 from the beginning on.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.235 2002/12/05 13:07:24 henning Exp $	*/
d316 12
d335 1
a335 1
%token	FRAGNORM FRAGDROP FRAGCROP
d388 1
d467 27
d1035 2
a1036 1
dir		: IN				{ $$ = PF_IN; }
d1175 5
a1179 3
			struct node_host *h;
			for (h = $2; h; h = h->next)
				h->not = 1;
d3068 84
a3151 80
		{ "all",	ALL},
		{ "allow-opts",	ALLOWOPTS},
		{ "altq",	ALTQ},
		{ "antispoof",	ANTISPOOF},
		{ "any",	ANY},
		{ "bandwidth",	BANDWIDTH},
		{ "binat",	BINAT},
		{ "bitmask",	BITMASK},
		{ "block",	BLOCK},
		{ "block-policy", BLOCKPOLICY},
		{ "borrow",	BORROW},
		{ "cbq",	CBQ},
		{ "code",	CODE},
		{ "control",	CONTROL},
		{ "crop",	FRAGCROP},
		{ "default",	DEFAULT},
		{ "drop",	DROP},
		{ "drop-ovl",	FRAGDROP},
		{ "dup-to",	DUPTO},
		{ "ecn",	ECN},
		{ "fastroute",	FASTROUTE},
		{ "flags",	FLAGS},
		{ "for",	FOR},
		{ "fragment",	FRAGMENT},
		{ "from",	FROM},
		{ "group",	GROUP},
		{ "icmp-type",	ICMPTYPE},
		{ "in",		IN},
		{ "inet",	INET},
		{ "inet6",	INET6},
		{ "ipv6-icmp-type", ICMP6TYPE},
		{ "keep",	KEEP},
		{ "label",	LABEL},
		{ "limit",	LIMIT},
		{ "log",	LOG},
		{ "log-all",	LOGALL},
		{ "loginterface", LOGINTERFACE},
		{ "max",	MAXIMUM},
		{ "max-mss",	MAXMSS},
		{ "min-ttl",	MINTTL},
		{ "modulate",	MODULATE},
		{ "nat",	NAT},
		{ "no",		NO},
		{ "no-df",	NODF},
		{ "no-route",	NOROUTE},
		{ "on",		ON},
		{ "optimization", OPTIMIZATION},
		{ "out",	OUT},
		{ "pass",	PASS},
		{ "port",	PORT},
		{ "priority",	PRIORITY},
		{ "proto",	PROTO},
		{ "qlimit",	QLIMIT},
		{ "queue",	QUEUE},
		{ "quick",	QUICK},
		{ "random",	RANDOM},
		{ "rdr",	RDR},
		{ "reassemble",	FRAGNORM},
		{ "red",	RED},
		{ "reply-to",	REPLYTO},
		{ "require-order", REQUIREORDER},
		{ "return",	RETURN},
		{ "return-icmp",RETURNICMP},
		{ "return-icmp6",RETURNICMP6},
		{ "return-rst",	RETURNRST},
		{ "rio",	RIO},
		{ "round-robin",ROUNDROBIN},
		{ "route-to",	ROUTETO},
		{ "scheduler",	SCHEDULER},
		{ "scrub",	SCRUB},
		{ "set",	SET},
		{ "source-hash",SOURCEHASH},
		{ "state",	STATE},
		{ "tbrsize",	TBRSIZE},
		{ "timeout",	TIMEOUT},
		{ "to",		TO},
		{ "tos",	TOS},
		{ "ttl",	TTL},
		{ "user",	USER},
		{ "yes",	YES},
@


1.235
log
@-quote varset in -v output
-don't add 's' in set timeout -v output

makes the feedback regression tests succeed.

ok markus@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.234 2002/12/04 12:57:55 henning Exp $	*/
d3569 1
a3569 2
			memcpy(&n->addr.mask, &p->addr.mask,
			    sizeof(struct pf_addr));
@


1.234
log
@in host(), apply a given netmask to all members of the node_host list
returned by ifa_lookup().

reported by Alejandro G. Belluscio

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.233 2002/12/04 08:07:27 deraadt Exp $	*/
d446 1
a446 1
				printf("%s = %s\n", $1, $3);
d2216 1
a2216 1
				printf("set timeout %s %us\n", $1, $2);
@


1.233
log
@do not warn for unused variables except with -v -v; henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.232 2002/12/02 22:45:37 henning Exp $	*/
d3668 2
a3669 2
		if (h != NULL && mask > -1)
			set_ipmask(h, mask);
@


1.232
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.231 2002/12/02 22:34:33 deraadt Exp $	*/
d3353 1
a3353 1
parse_rules(FILE *input, struct pfctl *xpf)
d3365 6
a3370 5
	for (sym = symhead; sym; sym = sym->next)
		if (!sym->used)
			fprintf(stderr, "warning: macro '%s' not used\n",
			    sym->nam);

@


1.231
log
@permit more flexible pass/block lines.  the options giving at the end of
a line can now be placed in any order, and some merging of duplicat options
is also done.  this is easier to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.230 2002/12/02 22:18:21 henning Exp $	*/
a868 1
			
d879 1
a879 1
			} 
d889 1
a889 1
			} 
d896 1
a896 1
			} 
@


1.230
log
@allow for "altq on $interface" without specifying a bandwidth. The
interface's bandwidth is taken then.
as a side-effect, "altq on $interface bandwidth xx%" is also possible now,
it's relative to the interface's bandwidth then.

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.229 2002/11/30 13:53:14 mickey Exp $	*/
d179 21
d311 1
d338 1
a338 1
%type	<v.b>	action flag flags blockspec
d365 1
d719 1
a719 2
		  uids gids flags icmpspec tos keep fragment allowopts label
		  qname
d752 2
a753 2
			r.flags = $11.b1;
			r.flagset = $11.b2;
d755 1
a755 1
			if ($11.b1 || $11.b2) {
d766 3
a768 3
			r.tos = $13;
			r.keep_state = $14.action;
			o = $14.options;
d796 1
a796 1
			if ($15)
d798 1
a798 1
			r.allow_opts = $16;
d826 2
a827 2
			if ($17) {
				if (strlcpy(r.label, $17, sizeof(r.label)) >=
d833 1
a833 1
				free($17);
d836 2
a837 2
			if ($18) {
				if (strlcpy(r.qname, $18, sizeof(r.qname)) >=
d843 1
a843 1
				free($18);
d848 79
a926 1
			    $9, $10, $12);
d1248 2
a1249 3
uids		: /* empty */			{ $$ = NULL; }
		| USER uid_item			{ $$ = $2; }
		| USER '{' uid_list '}'		{ $$ = $3; }
d1325 2
a1326 3
gids		: /* empty */			{ $$ = NULL; }
		| GROUP gid_item		{ $$ = $2; }
		| GROUP '{' gid_list '}'	{ $$ = $3; }
d1413 2
a1414 3
flags		: /* empty */			{ $$.b1 = 0; $$.b2 = 0; }
		| FLAGS flag "/" flag		{ $$.b1 = $2.b1; $$.b2 = $4.b1; }
		| FLAGS "/" flag		{ $$.b1 = 0; $$.b2 = $3.b1; }
d1417 1
a1417 2
icmpspec	: /* empty */			{ $$ = NULL; }
		| ICMPTYPE icmp_item		{ $$ = $2; }
d1555 1
a1555 2
tos		: /* empty */			{ $$ = 0; }
		| TOS STRING			{
d1573 1
a1573 5
keep		: /* empty */			{
			$$.action = 0;
			$$.options = NULL;
		}
		| KEEP STATE state_opt_spec	{
d1583 2
a1584 2
state_opt_spec	: /* empty */			{ $$ = NULL; }
		| '(' state_opt_list ')'	{ $$ = $2; }
d1633 1
a1633 2
fragment	: /* empty */			{ $$ = 0; }
		| FRAGMENT			{ $$ = 1; }
d1653 1
a1653 2
allowopts	: /* empty */			{ $$ = 0; }
		| ALLOWOPTS			{ $$ = 1; }
d1655 1
a1655 2
label		: /* empty */			{ $$ = NULL; }
		| LABEL STRING			{
d1662 1
a1662 2
qname		: /* empty */			{ $$ = NULL; }
		| QUEUE STRING			{
@


1.229
log
@move damn unmask() proto into place as well
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.228 2002/11/29 17:14:18 henning Exp $	*/
d202 2
a203 1
int	expand_altq(struct pf_altq *, struct node_if *, struct node_queue *);
a540 4
			if ((a.ifbandwidth = $5.bw_absolute) == 0) {
				yyerror("interface bandwidth must be absolute");
				YYERROR;
			}
d547 1
a547 1
			if (expand_altq(&a, $2, $9))
d2471 1
a2471 1
    struct node_queue *nqueues)
d2486 2
a2487 1
			if (eval_pfaltq(pf, &pa))
@


1.228
log
@coredumps are not nice.
deal with the fact that when we are merging the lists in host_list both can
be NULL.
found at EuroBSDCon 2002 while I was explaining the expansion process to
Paul de Weerd

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.227 2002/11/29 15:37:23 henning Exp $	*/
d53 1
@


1.227
log
@print queuespec only once in verbose mode, even if referenced more often
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.226 2002/11/29 15:32:14 henning Exp $	*/
d1024 9
a1032 3
			$1->tail->next = $3->tail;
			$1->tail = $3->tail;
			$$ = $1;
@


1.226
log
@FREE_LIST nqueues later; can be used more than once
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.225 2002/11/28 14:43:39 henning Exp $	*/
d2547 1
d2552 1
d2577 1
a2577 1
			if (pf->opts & PF_OPT_VERBOSE) {
@


1.225
log
@allow qlimit on altq spec
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.224 2002/11/28 12:14:24 mcbride Exp $	*/
a2586 1
			FREE_LIST(struct node_queue, nqueues);
d2589 2
@


1.224
log
@- Adjust to match replacement of md5 with pf_hash
- Allow keys to be specified in hex (must be 128 bits, mainly to make
  pfctl -v output paresable by pfctl) or as a string. Randomly generate key
  if one is not specified.

Suggestions and fixes from camield@@

ok mickey@@ camield@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.223 2002/11/27 18:50:32 henning Exp $	*/
d525 2
a526 2
altqif		: ALTQ interface SCHEDULER schedtype bandwidth tbrsize
		  QUEUE qassign	{
d543 3
a545 2
			a.tbrsize = $6;
			if ($8 == NULL) {
d549 1
a549 1
			if (expand_altq(&a, $2, $8))
@


1.223
log
@handle the "no bandwidth specified" case earlier and easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.222 2002/11/27 16:23:01 henning Exp $	*/
d261 1
d303 1
a303 1
%token	BITMASK RANDOM SOURCEHASH ROUNDROBIN KEY STATICPORT
d316 1
d1635 50
d1688 1
a1688 2
		| SOURCEHASH			{ $$.type = PF_POOL_SRCHASH; }
		| SOURCEHASH RANDOM
d1690 2
a1691 20
			$$.key = calloc(1, sizeof(struct pf_poolhashkey));
			if ($$.key == NULL)
				err(1, "pooltype: calloc");
			$$.type = PF_POOL_SRCKEYHASH;
			$$.key->key32[0] = arc4random();
			$$.key->key32[1] = arc4random();
			$$.key->key32[2] = arc4random();
			$$.key->key32[3] = arc4random();
		}
		| SOURCEHASH KEY string
		{
			MD5_CTX context;

			$$.key = calloc(1, sizeof(struct pf_poolhashkey));
			if ($$.key == NULL)
				err(1, "pooltype: calloc");
			$$.type = PF_POOL_SRCKEYHASH;
			MD5Init(&context);
			MD5Update(&context, $3, strlen($3));
			MD5Final((unsigned char *)$$.key, &context);
d1794 5
a1798 5
				if ((nat.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_SRCKEYHASH) {
					memcpy(&nat.rpool.key, $8.key,
					    sizeof(struct pf_poolhashkey));
				}
d2009 5
a2013 5
				if ((rdr.rpool.opts & PF_POOL_TYPEMASK) ==
				    PF_POOL_SRCKEYHASH) {
					memcpy(&rdr.rpool.key, $12.key,
					    sizeof(struct pf_poolhashkey));
				}
d2105 1
a2105 2
			if (($$.pool_opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_SRCKEYHASH)
d2111 1
a2111 2
			if (($$.pool_opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_SRCKEYHASH)
d2117 1
a2117 2
			if (($$.pool_opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_SRCKEYHASH)
a2961 1
		{ "key",	KEY},
@


1.222
log
@-use a #define for default qlimit instead of hardcoding it
-print qlimit in print_queue if it is not the default one
-assign the default qlimit early in the parser instead of using 0
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.221 2002/11/27 16:06:20 henning Exp $	*/
d628 1
a628 1
			$$.bw_percent = 0;
a2515 3

	if (bwspec.bw_absolute == 0 && bwspec.bw_percent == 0)
		bwspec.bw_percent = 100;
@


1.221
log
@next round in print fixes:
-only print priority if it is not equal to the default one
-space handling overhaul
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.220 2002/11/27 15:49:16 henning Exp $	*/
d673 1
a673 1
qlimit		: /* empty */		{ $$ = 0; }
@


1.220
log
@use a #define for default priority instead of hardcoding it
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.219 2002/11/27 14:39:06 henning Exp $	*/
d2460 1
a2460 1
					printf(" queue { ");
d2550 1
a2550 1
					printf(" { ");
@


1.219
log
@fix tbrsize spec
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.218 2002/11/27 14:33:12 henning Exp $	*/
d663 1
a663 1
priority	: /* empty */		{ $$ = 1; }
@


1.218
log
@fix error message for altq ifspec without child queues
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.217 2002/11/26 21:10:45 henning Exp $	*/
d685 2
a686 2
		| number		{
			if ($1 > 65535) {
d690 1
a690 1
			$$ = $1;
@


1.217
log
@make bandwidth specification on queue truly optional
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.216 2002/11/26 19:14:14 henning Exp $	*/
d543 1
a543 1
				yyerror("no child queues?");
@


1.216
log
@queue comes before NAT
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.215 2002/11/25 18:11:34 henning Exp $	*/
d2516 3
@


1.215
log
@repair decide_address_family
you cannot just taked the first address family you meet as rule's address
family... either all are equal, or the rule has no explicit AF.

found by danh@@
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.214 2002/11/25 17:44:39 mickey Exp $	*/
d72 2
a73 2
	PFCTL_STATE_NAT = 3,
	PFCTL_STATE_QUEUE = 4,
d2881 2
a2882 2
		yyerror("Rules must be in order: options, normalization, "
		    "translation, queue, filter");
@


1.214
log
@for loN and link1 translate the iface into address properly; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.213 2002/11/25 16:30:22 henning Exp $	*/
d3477 2
d3480 6
a3485 2
		if (n->af)
			*af = n->af;
d3488 2
@


1.213
log
@1Kb = 1000b, not 1024; as discussed with kjc@@ and theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.212 2002/11/25 15:50:58 henning Exp $	*/
d3447 8
a3454 3
			if (n->af == AF_INET)
				set_ipmask(n, 32);
			else
@


1.212
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.211 2002/11/24 17:33:57 pb Exp $	*/
d641 1
a641 1
					bps *= 1024;
d643 1
a643 1
					bps *= 1024 * 1024;
d645 1
a645 1
					bps *= 1024 * 1024 * 1024;
@


1.211
log
@enforce that queue comes right before filtering
'options, normalization, translation, queue, filter' now

henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.210 2002/11/24 13:12:36 dhartmei Exp $	*/
d230 1
a230 1
void    remove_invalid_hosts(struct node_host **, sa_family_t *);
@


1.210
log
@Cosmetics and removal of a redundant code block.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.209 2002/11/23 23:00:32 deraadt Exp $	*/
d73 2
a74 1
	PFCTL_STATE_FILTER = 4
d527 3
d577 3
d2882 1
a2882 1
		    "translation, filter");
@


1.209
log
@sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.208 2002/11/23 22:57:54 henning Exp $	*/
d407 1
a407 1
				yyerror("malloc failed");
a2768 12
		TAILQ_INIT(&n->rpool.list);
		for (h = rpool_hosts; h; h = h->next) {
			pa = calloc(1, sizeof(struct pf_pooladdr));
			if (pa == NULL) {
				yyerror("calloc");
				error++;
			}
			pa->addr = h->addr;
			pa->ifname[0] = 0;
			TAILQ_INSERT_TAIL(&n->rpool.list, pa, entries);
		}

d3374 1
a3374 1
			yyerror("malloc failed");
d3530 1
a3530 1
			err(1, "host: malloc");
d3535 1
a3535 1
			err(1, "host: malloc");
@


1.208
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.207 2002/11/23 18:32:29 henning Exp $	*/
d440 1
a440 1
					yyerror("scrub rules don't support "
d2771 1
a2771 1
			pa = calloc(1, sizeof(struct pf_pooladdr));	
@


1.207
log
@better error checking in expand_queue
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.206 2002/11/23 18:27:28 henning Exp $	*/
d2658 1
a2658 1
		for (h = rt_pool_hosts; h; h = h->next) {
d2758 1
a2758 1
		for (h = rpool_hosts; h; h = h->next) {
d2771 1
a2771 1
			pa = calloc(1, sizeof(struct pf_pooladdr));
d2849 1
a2849 1
		for (h = rpool_hosts; h; h = h->next) {
@


1.206
log
@easier
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.205 2002/11/23 18:23:41 mcbride Exp $	*/
d2532 5
a2536 3
			eval_pfqueue(pf, a, bwspec.bw_absolute,
			    bwspec.bw_percent);
			pfctl_add_altq(pf, a);
a2548 1
			added++;
@


1.205
log
@Daniel's diff to untangle my mess with ifa_pick_ips like so:

- add decide_address_family() which runs through the list to find hosts
  with the af set
- replace ifa_pick_ips with remove_invalid_hosts() which removes hosts with
  the wrong address family from the list

from/ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.204 2002/11/23 16:41:43 henning Exp $	*/
d3514 1
a3514 1
	if (!*af) {
d3517 1
a3517 3
		return;
	}
	if (*nh == NULL) {
a3519 2
		return;
	}
@


1.204
log
@better error checking, round 1
this time in expand_altq
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.203 2002/11/23 15:59:57 henning Exp $	*/
d228 2
a229 1
struct	node_host *ifa_pick_ips(struct node_host *, sa_family_t);
d770 3
d777 18
a1704 2
				struct node_host *n;

d1710 1
a1710 1
				if (!nat.af && !$7->host->ifindex)
d1713 2
a1714 2
				n = ifa_pick_ips($7->host, nat.af);
				if (n == NULL)
a1715 2
				if (!nat.af)
					nat.af = n->af;
a1724 1
			}
d1726 3
a1728 20
			if ($7->host->next) {
				nat.rpool.opts = $8.type;
				if (nat.rpool.opts == PF_POOL_NONE)
					nat.rpool.opts = PF_POOL_ROUNDROBIN;
				if (nat.rpool.opts != PF_POOL_ROUNDROBIN) {
					yyerror("nat: only round-robin valid "
					    "for multiple redirection "
					    "addresses");
					YYERROR;
				}
			} else {
				if ((nat.af == AF_INET &&
				    unmask(&$7->host->addr.mask,
				    nat.af) == 32) ||
				    (nat.af == AF_INET6 &&
				    unmask(&$7->host->addr.mask,
				    nat.af) == 128)) {
					nat.rpool.opts = PF_POOL_NONE;
				} else {
					if ($8.type == PF_POOL_NONE)
d1731 27
a1757 2
					else
						nat.rpool.opts = $8.type;
a1759 5
			if ((nat.rpool.opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_SRCKEYHASH) {
				memcpy(&nat.rpool.key, $8.key,
				    sizeof(struct pf_poolhashkey));
			}
d1762 2
a1763 1
			    $6.dst.host, $6.dst.port, $7->host);
a1848 2
				struct node_host *n;

d1854 3
a1856 2
				n = ifa_pick_ips($10->host, binat.af);
				if (n == NULL)
d1858 3
a1860 3
				if (n->next != NULL) {
					yyerror("multiple addresses in '-> "
					    "address'");
d1863 1
a1863 14
				if (n->addr.addr_dyn != NULL) {
					if (!binat.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					n->af = binat.af;
				}
				if (binat.af && n->af != binat.af) {
					yyerror("binat ip versions must match");
					YYERROR;
				}
				binat.af = n->af;
				memcpy(&binat.raddr.addr, &n->addr.addr,
d1865 1
a1865 1
				memcpy(&binat.raddr.mask, &n->addr.mask,
a1925 2
				struct node_host *n;

d1934 2
a1935 2
				n = ifa_pick_ips($11->host, rdr.af);
				if (n == NULL)
a1936 2
				if (!rdr.af)
					rdr.af = n->af;
d1939 4
a1942 19
			}
			if ($11->host->next) {
				rdr.rpool.opts = $12.type;
				if (rdr.rpool.opts == PF_POOL_NONE)
					rdr.rpool.opts = PF_POOL_ROUNDROBIN;
				if (rdr.rpool.opts != PF_POOL_ROUNDROBIN) {
					yyerror("nat: only round-robin valid "
					    "for multiple redirection "
					    "addresses");
					YYERROR;
				}
			} else {
				if ((rdr.af == AF_INET &&
				    unmask(&$11->host->addr.mask, rdr.af) == 32) ||
				    (rdr.af == AF_INET6 &&
				    unmask(&$11->host->addr.mask, rdr.af) == 128)) {
					rdr.rpool.opts = PF_POOL_NONE;
				} else {
					if ($12.type == PF_POOL_NONE)
d1945 28
a1972 2
					else
						rdr.rpool.opts = $12.type;
a1974 5
			if ((rdr.rpool.opts & PF_POOL_TYPEMASK) ==
			    PF_POOL_SRCKEYHASH) {
				memcpy(&rdr.rpool.key, $12.key,
				    sizeof(struct pf_poolhashkey));
			}
d1976 2
a1977 1
			expand_rdr(&rdr, $3, $5, $7, $9, $11->host);
a2064 25

			if ($2->next) {
				$$.pool_opts = $3.type;
				if ($$.pool_opts == PF_POOL_NONE)
					$$.pool_opts = PF_POOL_ROUNDROBIN;
				if ($$.pool_opts != PF_POOL_ROUNDROBIN) {
					yyerror("nat: only round-robin valid "
					    "for multiple redirection "
					    "addresses");
					YYERROR;
				}
			} else {
				if (($2->af == AF_INET &&
				    unmask(&$2->addr.mask, $2->af) == 32) ||
				    ($2->af == AF_INET6 &&
				    unmask(&$2->addr.mask, $2->af) == 128)) {
					$$.pool_opts = PF_POOL_NONE;
				} else {
					if ($3.type == PF_POOL_NONE)
						$$.pool_opts =
						    PF_POOL_ROUNDROBIN;
					else
						$$.pool_opts = $3.type;
				}
			}
d2066 1
a2066 1
			    PF_POOL_SRCKEYHASH) {
a2067 1
			}
a2071 25

			if ($2->next) {
				$$.pool_opts = $3.type;
				if ($$.pool_opts == PF_POOL_NONE)
					$$.pool_opts = PF_POOL_ROUNDROBIN;
				if ($$.pool_opts != PF_POOL_ROUNDROBIN) {
					yyerror("nat: only round-robin valid "
					    "for multiple redirection "
					    "addresses");
					YYERROR;
				}
			} else {
				if (($2->af == AF_INET &&
				    unmask(&$2->addr.mask, $2->af) == 32) ||
				    ($2->af == AF_INET6 &&
				    unmask(&$2->addr.mask, $2->af) == 128)) {
					$$.pool_opts = PF_POOL_NONE;
				} else {
					if ($3.type == PF_POOL_NONE)
						$$.pool_opts =
						    PF_POOL_ROUNDROBIN;
					else
						$$.pool_opts = $3.type;
				}
			}
d2073 1
a2073 1
			    PF_POOL_SRCKEYHASH) {
a2074 1
			}
a2078 25

			if ($2->next) {
				$$.pool_opts = $3.type;
				if ($$.pool_opts == PF_POOL_NONE)
					$$.pool_opts = PF_POOL_ROUNDROBIN;
				if ($$.pool_opts != PF_POOL_ROUNDROBIN) {
					yyerror("nat: only round-robin valid "
					    "for multiple redirection "
					    "addresses");
					YYERROR;
				}
			} else {
				if (($2->af == AF_INET &&
				    unmask(&$2->addr.mask, $2->af) == 32) ||
				    ($2->af == AF_INET6 &&
				    unmask(&$2->addr.mask, $2->af) == 128)) {
					$$.pool_opts = PF_POOL_NONE;
				} else {
					if ($3.type == PF_POOL_NONE)
						$$.pool_opts =
						    PF_POOL_ROUNDROBIN;
					else
						$$.pool_opts = $3.type;
				}
			}
d2080 1
a2080 1
			    PF_POOL_SRCKEYHASH) {
a2081 1
			}
d3473 12
a3484 2
struct node_host *
ifa_pick_ips(struct node_host *nh, sa_family_t af)
d3486 1
a3486 1
	struct node_host *d, *h = nh, *n = NULL, *ip = NULL, *ip6 = NULL;
d3488 23
a3510 26
	while (h != NULL) {
		switch (h->af) {
		case AF_INET:
			if (ip == NULL) {
				ip = h;
				ip->tail = ip;
			} else {
				ip->tail->next = h;
				ip->tail = h;
			}
			h = h->next;
			ip->tail->next = NULL;
			n = ip;
			break;
		case AF_INET6:
			if (ip6 == NULL) {
				ip6 = h;
				ip6->tail = ip6;
			} else {
				ip6->tail->next = h;
				ip6->tail = h;
			}
			h = h->next;
			ip6->tail->next = NULL;
			n = ip6;
			break;
d3514 4
a3517 17
	switch (af) {
	case AF_INET:
		n = ip;
		h = ip6;
		break;
	case AF_INET6:
		n = ip6;
		h = ip;
		break;
	default:
		if (ip && ip6) {
			yyerror("address family not given and translation "
			    "address expands to multiple address families");
			return (NULL);
		}
		h = NULL;
		break;
d3519 1
a3519 2

	if (n == NULL)
d3522 1
a3522 5

	while (h != NULL) {
		d = h;
		h = h->next;
		free(d);
a3523 1
	return (n);
@


1.203
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.202 2002/11/23 09:33:54 deraadt Exp $	*/
d200 1
a200 1
void	expand_altq(struct pf_altq *, struct node_if *, struct node_queue *);
d541 2
a542 1
			expand_altq(&a,	$2, $8);
d2495 1
a2495 1
void
d2502 1
d2508 1
a2508 1
		if (interface->not)
d2510 8
a2517 3
		else {
			eval_pfaltq(pf, &pa);
			pfctl_add_altq(pf, &pa);
d2524 2
a2525 1
						printf("%s ", queue->queue);
d2541 5
a2545 2
			eval_pfqueue(pf, &pb, pa.ifbandwidth, 0);
			pfctl_add_altq(pf, &pb);
d2567 2
@


1.202
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.201 2002/11/23 09:30:39 dhartmei Exp $	*/
d196 1
a196 1
void  expand_rule(struct pf_rule *, struct node_if *, struct node_host *,
@


1.201
log
@$$->ifname is NULL, leave it NULL, don't $$->ifname[0] = 0;
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.200 2002/11/23 09:15:25 mcbride Exp $	*/
d273 1
a273 1
		} 			pooltype;
d318 1
a318 1
%type	<v.host>	ipspec xhost host address host_list 
d456 1
a456 1
			    NULL, NULL, NULL); 
d794 1
a794 1
			    $8.src.host, $8.src.port, $8.dst.host, $8.dst.port, 
d1618 1
a1618 1
		| SOURCEHASH KEY string		
d1621 1
a1621 1
			
d1630 1
a1630 1
		| ROUNDROBIN 			{ $$.type = PF_POOL_ROUNDROBIN; }
d1710 1
a1710 1
				if (nat.rpool.opts == PF_POOL_NONE) 
d1717 1
a1717 1
				} 
d1727 1
a1727 1
					if ($8.type == PF_POOL_NONE) 
d1865 1
a1865 1
				} 
d1907 1
a1907 1
			if ($12.type == PF_POOL_NONE) 
d1924 1
a1924 1
				} 
d1938 1
a1938 1
				if (rdr.rpool.opts == PF_POOL_NONE) 
d1945 1
a1945 1
				} 
d1953 1
a1953 1
					if ($12.type == PF_POOL_NONE) 
d1990 1
a1990 1
route_host	: STRING			{ 
d2006 1
a2006 1
		| '(' STRING host ')'		{ 
d2022 1
a2022 1
			if ($1->af == 0) 
d2028 1
a2028 1
			} 
d2054 1
a2054 1
			
d2057 1
a2057 1
				if ($$.pool_opts == PF_POOL_NONE) 
d2064 1
a2064 1
				} 
d2072 1
a2072 1
					if ($3.type == PF_POOL_NONE) 
d2087 1
a2087 1
			
d2090 1
a2090 1
				if ($$.pool_opts == PF_POOL_NONE) 
d2097 1
a2097 1
				} 
d2105 1
a2105 1
					if ($3.type == PF_POOL_NONE) 
d2120 1
a2120 1
			
d2123 1
a2123 1
				if ($$.pool_opts == PF_POOL_NONE) 
d2130 1
a2130 1
				} 
d2138 1
a2138 1
					if ($3.type == PF_POOL_NONE) 
d2266 1
a2266 1
	if (!r->af) { 
d2293 1
a2293 1
			     "(inet/inet6)");
d2837 1
a2837 1
		else {  
d2966 1
a2966 1
		{ "bitmask", 	BITMASK},
d3576 1
a3576 1
		} 
d3580 1
a3580 1
			
d3585 1
a3585 1
	while (h != NULL) {  
@


1.200
log
@Fix brokenness in parse.y, clean up:
- remove requirement for ( ) in route-to ( if )
- calloc route_host
- initialise route_host->next
- globally convert malloc to calloc

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.199 2002/11/23 05:22:24 mcbride Exp $	*/
a1033 1
			$$->ifname[0] = 0;
@


1.199
log
@code to support loading of pf rules with multiple redirection addresses
(in nat, rdr, route-to, dup-to and reply-to)

Syntax looks like this, see pf.conf(5) for details:

nat on wi0 proto { tcp, icmp } from any to 192.168.0.2 -> \
        192.168.0.16/29 source-hash random

rdr on wi0 proto { tcp } from any to 192.168.0.34 port 22 -> \
        { 192.168.0.8/31, 192.168.0.15 } port 22 round-robin

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.198 2002/11/22 12:24:30 henning Exp $	*/
d559 1
a559 1
			$$ = malloc(sizeof(struct node_queue));
d561 1
a561 1
				err(1, "queue_item: malloc");
d903 1
a903 1
			$$ = malloc(sizeof(struct node_if));
d905 1
a905 1
				err(1, "if_item: malloc");
d955 1
a955 1
			$$ = malloc(sizeof(struct node_proto));
d957 1
a957 1
				err(1, "proto_item: malloc");
d1058 1
a1058 1
			$$ = malloc(sizeof(struct node_port));
d1060 1
a1060 1
				err(1, "port_item: malloc");
d1068 1
a1068 1
			$$ = malloc(sizeof(struct node_port));
d1070 1
a1070 1
				err(1, "port_item: malloc");
d1078 1
a1078 1
			$$ = malloc(sizeof(struct node_port));
d1080 1
a1080 1
				err(1, "port_item: malloc");
d1126 1
a1126 1
			$$ = malloc(sizeof(struct node_uid));
d1128 1
a1128 1
				err(1, "uid_item: malloc");
d1140 1
a1140 1
			$$ = malloc(sizeof(struct node_uid));
d1142 1
a1142 1
				err(1, "uid_item: malloc");
d1154 1
a1154 1
			$$ = malloc(sizeof(struct node_uid));
d1156 1
a1156 1
				err(1, "uid_item: malloc");
d1204 1
a1204 1
			$$ = malloc(sizeof(struct node_gid));
d1206 1
a1206 1
				err(1, "gid_item: malloc");
d1218 1
a1218 1
			$$ = malloc(sizeof(struct node_gid));
d1220 1
a1220 1
				err(1, "gid_item: malloc");
d1232 1
a1232 1
			$$ = malloc(sizeof(struct node_gid));
d1234 1
a1234 1
				err(1, "gid_item: malloc");
d1308 1
a1308 1
			$$ = malloc(sizeof(struct node_icmp));
d1310 1
a1310 1
				err(1, "icmp_item: malloc");
d1334 1
a1334 1
			$$ = malloc(sizeof(struct node_icmp));
d1336 1
a1336 1
				err(1, "icmp_item: malloc");
d1346 1
a1346 1
			$$ = malloc(sizeof(struct node_icmp));
d1348 1
a1348 1
				err(1, "icmp_item: malloc");
d1372 1
a1372 1
			$$ = malloc(sizeof(struct node_icmp));
d1374 1
a1374 1
				err(1, "icmp_item: malloc");
d1589 1
a1589 1
			$$ = malloc(sizeof(struct redirection));
d1591 1
a1591 1
				err(1, "redirection: malloc");
d1596 1
a1596 1
			$$ = malloc(sizeof(struct redirection));
d1598 1
a1598 1
				err(1, "redirection: malloc");
d1610 1
a1610 1
			$$.key = malloc(sizeof(struct pf_poolhashkey));
d1612 1
a1612 1
				err(1, "pooltype: malloc");
d1623 1
a1623 1
			$$.key = malloc(sizeof(struct pf_poolhashkey));
d1625 1
a1625 1
				err(1, "pooltype: malloc");
d1640 1
a1640 1
			$$ = malloc(sizeof(struct redirection));
d1642 1
a1642 1
				err(1, "redirection: malloc");
d1647 1
a1647 1
			$$ = malloc(sizeof(struct redirection));
d1649 1
a1649 1
				err(1, "redirection: malloc");
d1991 5
a1995 2
route_host	: '(' STRING ')'		{ 
			if (($$->ifname = strdup($2)) == NULL) {
d2004 2
d2540 1
a2540 1
					err(1, "expand_altq: malloc");
d2570 1
a2570 1
				n = malloc(sizeof(struct node_queue));
d2572 1
a2572 1
					err(1, "expand_queue: malloc");
d2714 1
a2714 1
			pa = malloc(sizeof(struct pf_pooladdr));
d2716 1
a2716 1
				yyerror("malloc");
d2814 1
a2814 1
			pa = malloc(sizeof(struct pf_pooladdr));
d2816 1
a2816 1
				yyerror("malloc");
d2826 1
a2826 1
			pa = malloc(sizeof(struct pf_pooladdr));
d2828 1
a2828 1
				yyerror("malloc");
d2905 1
a2905 1
			pa = malloc(sizeof(struct pf_pooladdr));
d2907 1
a2907 1
				yyerror("malloc");
@


1.198
log
@print altq and queue lines in the pfctl -v case including the child queue
assignment
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.197 2002/11/19 18:51:09 henning Exp $	*/
d51 1
a97 1
	struct pf_addr		 mask;
d184 1
a184 1
	    struct node_host *, struct node_host *);
d187 1
a187 1
	    struct node_host *, struct node_port *);
d196 4
a199 4
void	expand_rule(struct pf_rule *, struct node_if *, struct node_proto *,
	    struct node_host *, struct node_port *, struct node_host *,
	    struct node_port *, struct node_uid *, struct node_gid *,
	    struct node_icmp *);
d228 2
a229 2
struct	node_host *ifa_pick_ip(struct node_host *, u_int8_t);
u_int16_t	parseicmpspec(char *, u_int8_t);
d260 1
a260 2
			char		*string;
			struct pf_addr	*addr;
d262 1
d264 1
d267 1
a267 1
			struct node_host	*address;
d271 4
d300 1
d310 1
d313 1
d318 3
a320 1
%type	<v.host>	ipspec xhost host address host_list
d325 1
a325 1
%type	<v.redirection>	redirection
d454 3
a456 2
			expand_rule(&r, $3, NULL, $5.src.host, $5.src.port,
			    $5.dst.host, $5.dst.port, NULL, NULL, NULL);
d484 2
a485 2
				expand_rule(&r, j, NULL, h, NULL, NULL, NULL,
				    NULL, NULL, NULL);
d499 2
a500 2
					expand_rule(&r, NULL, NULL, h, NULL,
					    NULL, NULL, NULL, NULL, NULL);
d770 1
a770 22
				if ($5.string) {
					strlcpy(r.rt_ifname, $5.string,
					    IFNAMSIZ);
					if (ifa_exists(r.rt_ifname) == NULL) {
						yyerror("unknown interface %s",
						    r.rt_ifname);
						YYERROR;
					}
					free($5.string);
				}
				if ($5.addr) {
					if (!r.af)
						r.af = $5.af;
					else if (r.af != $5.af) {
						yyerror("address family"
						    " mismatch");
						YYERROR;
					}
					memcpy(&r.rt_addr, $5.addr,
					    sizeof(r.rt_addr));
					free($5.addr);
				}
d793 3
a795 2
			expand_rule(&r, $4, $7, $8.src.host, $8.src.port,
			    $8.dst.host, $8.dst.port, $9, $10, $12);
d1034 1
d1574 64
d1643 1
a1643 1
			$$->address = $2;
d1650 1
a1650 1
			$$->address = $2;
d1655 1
a1655 1
natrule		: no NAT interface af proto fromto redirection
d1685 1
a1685 1
				if ($7 == NULL || $7->address == NULL) {
d1690 4
a1693 3
				if (!nat.af && !$7->address->ifindex)
					nat.af = $7->address->af;
				n = ifa_pick_ip($7->address, nat.af);
a1697 2
				memcpy(&nat.raddr, &n->addr,
				    sizeof(nat.raddr));
d1707 32
a1738 2
				free($7->address);
				free($7);
d1742 2
a1743 1
			    $6.dst.host, $6.dst.port);
d1791 2
a1792 2
				memcpy(&binat.smask, &$7->mask,
				    sizeof(binat.smask));
d1815 2
a1816 2
				memcpy(&binat.dmask, &$9->mask,
				    sizeof(binat.dmask));
d1830 1
a1830 1
				if ($10 == NULL || $10->address == NULL) {
d1835 1
a1835 1
				n = ifa_pick_ip($10->address, binat.af);
d1838 5
d1858 5
a1862 3
				memcpy(&binat.rmask, &n->mask,
				    sizeof(binat.rmask));
				if (PF_ANEQ(&binat.smask, &binat.rmask, binat.af)) {
d1866 1
a1866 2
				}
				free($10->address);
d1872 1
d1874 1
a1874 1
rdrrule		: no RDR interface af proto FROM ipspec TO ipspec dport redirection
d1886 4
a1889 4
				memcpy(&rdr.saddr, &$7->addr,
				    sizeof(rdr.saddr));
				memcpy(&rdr.smask, &$7->mask,
				    sizeof(rdr.smask));
d1895 4
a1898 4
				memcpy(&rdr.daddr, &$9->addr,
				    sizeof(rdr.daddr));
				memcpy(&rdr.dmask, &$9->mask,
				    sizeof(rdr.dmask));
d1908 5
d1921 1
a1921 1
				if ($11 == NULL || $11->address == NULL) {
d1925 5
a1929 4
				}
				if (!rdr.af && !$11->address->ifindex)
					rdr.af = $11->address->af;
				n = ifa_pick_ip($11->address, rdr.af);
a1933 3
				memcpy(&rdr.raddr, &n->addr,
				    sizeof(rdr.raddr));
				free($11->address);
d1936 29
a1964 1
				free($11);
d1967 1
a1967 1
			expand_rdr(&rdr, $3, $5, $7, $9);
d1991 2
a1992 13
route		: /* empty */			{
			$$.string = NULL;
			$$.rt = 0;
			$$.addr = NULL;
			$$.af = 0;
		}
		| FASTROUTE {
			$$.string = NULL;
			$$.rt = PF_FASTROUTE;
			$$.addr = NULL;
		}
		| ROUTETO '(' STRING address ')' {
			if (($$.string = strdup($3)) == NULL) {
d1996 3
a1998 4
			$$.rt = PF_ROUTETO;
			if ($4->addr.addr_dyn != NULL) {
				yyerror("route-to does not support"
				    " dynamic addresses");
a2000 6
			if ($4->next) {
				yyerror("multiple route-to ip addresses");
				YYERROR;
			}
			$$.addr = &$4->addr.addr;
			$$.af = $4->af;
d2002 3
a2004 2
		| ROUTETO STRING {
			if (($$.string = strdup($2)) == NULL) {
d2008 3
a2010 6
			$$.rt = PF_ROUTETO;
			$$.addr = NULL;
		}
		| REPLYTO '(' STRING address ')' {
			if (($$.string = strdup($3)) == NULL) {
				yyerror("reply-to: strdup");
d2013 10
a2022 4
			$$.rt = PF_REPLYTO;
			if ($4->addr.addr_dyn != NULL) {
				yyerror("reply-to does not support"
				    " dynamic addresses");
d2024 50
d2075 3
a2077 3
			if ($4->next) {
				yyerror("multiple reply-to ip addresses");
				YYERROR;
a2078 2
			$$.addr = &$4->addr.addr;
			$$.af = $4->af;
d2080 31
a2110 4
		| REPLYTO STRING {
			if (($$.string = strdup($2)) == NULL) {
				yyerror("reply-to: strdup");
				YYERROR;
a2111 2
			$$.rt = PF_REPLYTO;
			$$.addr = NULL;
d2113 2
a2114 5
		| DUPTO '(' STRING address ')' {
			if (($$.string = strdup($3)) == NULL) {
				yyerror("dupto: strdup");
				YYERROR;
			}
d2116 24
a2139 4
			if ($4->addr.addr_dyn != NULL) {
				yyerror("dup-to does not support"
				    " dynamic addresses");
				YYERROR;
d2141 3
a2143 11
			if ($4->next) {
				yyerror("multiple dup-to ip addresses");
				YYERROR;
			}
			$$.addr = &$4->addr.addr;
			$$.af = $4->af;
		}
		| DUPTO STRING {
			if (($$.string = strdup($2)) == NULL) {
				yyerror("dupto: strdup");
				YYERROR;
a2144 2
			$$.rt = PF_DUPTO;
			$$.addr = NULL;
d2260 1
d2262 9
a2270 3
	if (!r->af && (r->raddr.addr_dyn != NULL)) {
		yyerror("dynamic addresses require address family (inet/inet6)");
		problems++;
d2279 1
d2286 15
a2300 4
	if (!r->af && (r->saddr.addr_dyn != NULL ||
	    r->daddr.addr_dyn != NULL || r->raddr.addr_dyn != NULL)) {
		yyerror("dynamic addresses require address family (inet/inet6)");
		problems++;
d2378 1
a2378 1
		    PF_AZERO(&host->mask, af)))
d2388 1
a2388 1
			bits = unmask(&host->mask, af);
d2612 5
a2616 5
    struct node_if *interfaces, struct node_proto *protos,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_uid *uids, struct node_gid *gids,
    struct node_icmp *icmp_types)
d2619 1
a2619 1
	int nomatch = 0, added = 0;
d2622 2
a2674 1
		r->src.mask = src_host->mask;
a2680 1
		r->dst.mask = dst_host->mask;
d2704 16
a2719 1
			nomatch++;
d2722 1
a2722 1
		if (rule_consistent(r) < 0 || nomatch)
d2741 1
d2751 2
a2752 1
    struct node_host *dst_hosts, struct node_port *dst_ports)
d2755 2
d2758 1
a2758 1
	int added = 0;
a2794 1
		n->src.mask = src_host->mask;
a2800 1
		n->dst.mask = dst_host->mask;
d2807 25
a2831 1
		if (nat_consistent(n) < 0)
d2833 1
a2833 1
		else {
d2846 1
d2855 1
a2855 1
    struct node_host *dst_hosts)
d2858 1
a2858 1
	int added = 0;
d2860 2
a2895 1
		r->smask = src_host->mask;
a2896 1
		r->dmask = dst_host->mask;
d2898 13
a2910 1
		if (rdr_consistent(r) < 0)
d2923 1
d2962 1
d2987 1
d3011 1
d3022 1
d3027 1
d3159 1
d3310 1
a3310 1
	m = &h->mask;
d3414 1
a3414 1
			memcpy(&n->mask, &((struct sockaddr_in *)
d3425 1
a3425 1
			memcpy(&n->mask, &((struct sockaddr_in6 *)
d3499 2
a3500 1
			memcpy(&n->mask, &p->mask, sizeof(struct pf_addr));
d3525 1
a3525 1
ifa_pick_ip(struct node_host *nh, sa_family_t af)
d3527 1
a3527 1
	struct node_host *h, *n = NULL;
d3529 21
a3549 11
	if (af == 0 && nh && nh->next) {
		yyerror("address family not given and translation address "
		    "expands to multiple IPs");
		return (NULL);
	}
	for (h = nh; h; h = h->next) {
		if (h->af == af || h->af == 0 || af == 0) {
			if (n != NULL) {
				yyerror("translation address expands to "
				    "multiple IPs of this address family");
				return (NULL);
d3551 4
a3554 1
			n = h;
d3557 20
d3580 5
a3584 3
	else {
		n->next = NULL;
		n->tail = n;
a3585 1

d3625 1
d3645 1
d3675 1
@


1.197
log
@only take cbq opts from schedtype if type=CBQ
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.196 2002/11/19 17:31:24 henning Exp $	*/
d2298 12
a2370 1
			FREE_LIST(struct node_queue, nqueues);
d2377 12
d2390 1
@


1.196
log
@repair queuespec syntax glitch, theo agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.195 2002/11/19 17:05:19 henning Exp $	*/
d575 4
a578 1
			a.pq_u.cbq_opts.flags = $6.data.cbq_opts.flags;
@


1.195
log
@default priority is 1, not 0
found by pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.194 2002/11/19 12:11:36 camield Exp $	*/
d511 1
a511 1
		  qassign	{
d526 5
a530 1
			expand_altq(&a,	$2, $7);
d534 3
a536 3
qassign		: /* empty */			{ $$ = NULL; }
		| QUEUE qassign_item		{ $$ = $2; }
		| QUEUE '{' qassign_list '}'	{ $$ = $3; }
@


1.194
log
@- match 'Gb' case-sensitively
- match "%" unit only, not "%crap"

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.193 2002/11/19 11:25:45 wilfried Exp $	*/
d636 1
a636 1
priority	: /* empty */		{ $$ = 0; }
@


1.193
log
@icmp-type was off by one, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.192 2002/11/18 23:38:48 deraadt Exp $	*/
d611 3
a613 3
				if (!strcmp(cp, "b")) {
					/* nothing */
				} else if (!strcmp(cp, "Kb"))
d617 1
a617 1
				else if (!strcasecmp(cp, "Gb"))
d619 1
a619 1
				else if (*cp == '%') {
@


1.192
log
@no; do not use };
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.191 2002/11/18 23:37:00 henning Exp $	*/
d1328 1
a1328 1
				if ((p = geticmpcodebyname($1, $3,
d1366 1
a1366 1
				if ((p = geticmpcodebyname($1, $3,
@


1.191
log
@more using strl* return values instead of strlen calls
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.190 2002/11/18 23:28:50 henning Exp $	*/
d782 1
a782 1
				};
@


1.190
log
@easier "queue name too long" detection; from theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.189 2002/11/18 23:13:32 deraadt Exp $	*/
d777 2
a778 1
				if (strlen($17) >= PF_RULE_LABEL_SIZE) {
d782 1
a782 2
				}
				strlcpy(r.label, $17, sizeof(r.label));
d787 2
a788 1
				if (strlen($18) >= PF_QNAME_SIZE) {
a792 1
				strlcpy(r.qname, $18, sizeof(r.qname));
@


1.189
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.188 2002/11/18 22:55:39 deraadt Exp $	*/
d558 2
a559 1
			if (strlen($2) >= PF_QNAME_SIZE) {
a563 1
			strlcpy(a.qname, $2, sizeof(a.qname));
@


1.188
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.187 2002/11/18 22:49:15 henning Exp $	*/
d1605 2
a1606 2
				if ($6.src.host && $6.src.host->af
				    && !$6.src.host->ifindex)
d1608 2
a1609 2
				else if ($6.dst.host && $6.dst.host->af
				    && !$6.dst.host->ifindex)
d3179 2
a3180 2
		if (!((p->af == AF_INET || p->af == AF_INET6)
		    && (!strncmp(p->ifname, ifa_name, IFNAMSIZ) || return_all)))
@


1.187
log
@altq and pf merged

this isn't 100% done yet: the print_ stuff isn't finished, some features
will be added later, and there is no documetation yet, but committing now
enables a few more people to work on.

print_altq_node stuff hacked by Daniel at euroBSDcon; lotsa stuff from kjc,
debugging help also pb and camiel. lots of good ideas by theo.

"commit now" theo philipp daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.186 2002/11/13 22:44:11 henning Exp $	*/
d445 1
a445 1
			    $5.dst.host, $5.dst.port, NULL, NULL, NULL); 
d579 1
a579 1
		| CBQ 				{ $$.qtype = ALTQT_CBQ; }
d587 1
a587 1
		| cbqflags_list comma cbqflags_item 	{ $$ |= $3; }
d604 1
a604 1
 			double bps;
d620 1
a620 1
 					if (bps < 0 || bps > 100) {
d642 1
a642 1
			$$ = $2; 
d663 1
a663 1
			$$ = $1; 
d817 2
a818 2
			$$.w = 0; 
			$$.w2 = 0; 
d1766 1
a1766 1
				} 
d2383 1
a2383 1
	u_int8_t 	flags, flagset;
d2681 1
a2681 1
		{ "for", 	FOR},
@


1.186
log
@as scrub rules end up in a struct pf_rule just call expand_rule instead of
handcrufting this.
has quite a few positive side effects:
-interface list expansion works (fries@@ asked for that)
-can specify address family, very helpful with dynamic interface expansion
 (pointed out by daniel)
-src/dst ip/port list expansion works
-fixes a long standing, scary, though never noticed bug:
  scrub out on lo1 from any to 10.0.0.1
expanded to
  scrub out on lo1 all
... this bug was there from day #1.

"sneaky diff of the month award" dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.185 2002/11/13 18:24:53 dhartmei Exp $	*/
d53 1
d157 20
d200 3
a213 1

d277 3
d295 3
d321 6
d337 2
d507 160
d669 1
d786 10
d1539 8
d2275 96
d2382 1
d2386 1
d2428 2
d2662 1
d2665 1
d2669 2
d2672 1
d2674 1
d2678 1
d2709 1
d2711 2
d2716 1
d2723 1
d2725 1
d2729 1
@


1.185
log
@Add label macro $if, as we support {} list expansion for interfaces now.
From David Gwynne. ok henning@@, camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.184 2002/11/13 16:51:37 dhartmei Exp $	*/
d378 1
a378 1
scrubrule	: SCRUB dir interface fromto nodf minttl maxmss fragcache
a394 4
				} else if ($3->next) {
					yyerror("scrub rules don't support "
					    "{} expansion");
					YYERROR;
a395 3
				memcpy(r.ifname, $3->ifname,
				    sizeof(r.ifname));
				free($3);
d397 2
a398 1
			if ($5)
a399 2
			if ($6)
				r.min_ttl = $6;
d401 1
a401 1
				r.max_mss = $7;
d403 3
a405 7
				r.rule_flag |= $8;

			r.nr = pf->rule_nr++;
			if (rule_consistent(&r) < 0)
				yyerror("skipping scrub rule due to errors");
			else
				pfctl_add_rule(pf, &r);
d407 2
@


1.184
log
@Initialize tail pointer to node, found by fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.183 2002/11/08 10:50:28 henning Exp $	*/
d167 1
d172 3
a174 2
void	expand_label(char *, u_int8_t, struct node_host *, struct node_port *,
	    struct node_host *, struct node_port *, u_int8_t);
d1919 18
d2054 1
a2054 1
expand_label(char *label, sa_family_t af,
d2059 1
d2122 1
a2122 1
		expand_label(r->label, r->af, src_host, src_port,
@


1.183
log
@init buf to NULL just in case...
there isn't a single codepath where it can remain uninitialized, but this
might prevent a stupid bug if we change something later
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.182 2002/11/07 17:47:33 henning Exp $	*/
d840 2
@


1.182
log
@move the ifa_exists block a bit up in host()
inspired by mpech@@ pointing out a missing free(buf). so handle the
it-is-an-interface case where we don't need the buf before allocating memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.181 2002/11/04 22:46:28 henning Exp $	*/
d2917 1
a2917 1
	char *buf;
@


1.181
log
@welcome to CIDR world, pfctl!

use inet_net_pton to parse IP adresses.
stuff like
block in from 10/8 to any
works now.

some input camield@@ and dhartmei@@

ok dhartmei@@, camield@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.180 2002/11/02 15:29:28 dhartmei Exp $	*/
d2919 8
a2938 8
	}

	if (ifa_exists(s) || !strncmp(s, "self", IFNAMSIZ)) {
		/* interface with this name exists */
		h = ifa_lookup(s, PFCTL_IFLOOKUP_HOST);
		if (h != NULL && mask > -1)
			set_ipmask(h, mask);
		return (h);
@


1.180
log
@%i -> %d, matches the style of existing code, from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.179 2002/11/02 14:13:42 dhartmei Exp $	*/
d184 1
a184 1
struct	node_host *host(char *);
d817 1
a817 13
		| address '/' number		{
			struct node_host *n;
			for (n = $1; n; n = n->next) {
				if (($1->af == AF_INET && $3 > 32) ||
				    ($1->af == AF_INET6 && $3 > 128)) {
					yyerror("illegal netmask value /%d",
					    $3);
					YYERROR;
				}
				set_ipmask(n, $3);
			}
			$$ = $1;
		}
d841 1
a841 1
		| STRING			{ $$ = host($1); }
d2911 1
a2911 1
host(char *s)
d2916 16
a2931 1
	int error;
d2935 4
a2938 1
		return(ifa_lookup(s, PFCTL_IFLOOKUP_HOST));
d2941 2
a2942 1
	if (inet_aton(s, &ina) == 1) {
d2949 1
a2949 1
		set_ipmask(h, 32);
d2952 1
d2955 1
d2971 1
a2971 1
		set_ipmask(n, 128);
d3000 1
a3000 1
			set_ipmask(n, 32);
d3007 1
a3007 1
			set_ipmask(n, 128);
@


1.179
log
@printf int with %i, not %u. from pilot@@monkey.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.178 2002/10/30 11:55:19 henning Exp $	*/
d1960 1
a1960 1
				snprintf(a, sizeof(a), "/%i", bits);
@


1.178
log
@simplify
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.177 2002/10/30 11:52:49 henning Exp $	*/
d1960 1
a1960 1
				snprintf(a, sizeof(a), "/%u", bits);
@


1.177
log
@fix interface expansion. since the reversed list expansion code was
committed this was broken, only the first IP address was returned.

pointed out by danh@@, who sent an excellent bug report.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.176 2002/10/29 15:23:38 henning Exp $	*/
d2932 1
a2932 4
		if ((h = ifa_lookup(s, PFCTL_IFLOOKUP_HOST)) == NULL)
			return (NULL);
		else
			return (h);
@


1.176
log
@introduce
  set require-order [yes|no]
default is yes.
with set to "no", it isn't required to have the rules in order (options,
scrub, nat, filter) any more, though of course NATing still happens before
filtering and so on, so one has to take care.

ok camield@@ mcbride@@ dhartmei@@
idea discussed with a whole lotta more people and basically ok for everyone ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.175 2002/10/27 13:53:59 henning Exp $	*/
d2934 1
a2934 3
		else {
			h->next = NULL;
			h->tail = h;
a2935 1
		}
@


1.175
log
@remove the "flags X" syntax.
noone who wrote "flags S" meant that, but actually something like "flags
S/SA". with "flags S" changing its actual meaning as more flags got
supported, things got worse.

ok dhartmei@@, pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.174 2002/10/22 12:55:01 mpech Exp $	*/
d64 1
d265 1
d343 10
d2323 1
a2323 1
	if (rulestate > desired_state) {
d2390 1
d2404 1
@


1.174
log
@%ul -> %lu

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.173 2002/10/22 12:28:08 mcbride Exp $	*/
a1078 1
		| FLAGS flag			{ $$.b1 = $2.b1; $$.b2 = PF_TH_ALL; }
@


1.173
log
@More conversion of "int af" and "u_int8_t af" declarations and function
arguments to the more correct and descriptive "sa_family_t af"

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.172 2002/10/22 07:07:35 camield Exp $	*/
d981 1
a981 1
					yyerror("illegal uid value %ul", ulval);
d1059 1
a1059 1
					yyerror("illegal gid value %ul", ulval);
@


1.172
log
@Rename ipmask to set_ipmask and add some functionality: the netmask
is applied immediately to the address.

This way, the parsed rules output shows exactly which bits of an
address are significant for a match and errors due to wrong netmasks
can be spotted more easily.

Example:
$ pfctl -nvf -
pass in on lo0 from 172.17.0.0/12 to any
@@0 pass in on lo0 inet from 172.16.0.0/12 to any

idea refined by dhartmei@@
ok frantzen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.171 2002/10/17 11:22:42 mcbride Exp $	*/
d97 1
a97 1
	u_int8_t		 af;
d237 1
a237 1
			u_int8_t	af;
d1916 1
a1916 1
expand_label_addr(const char *name, char *label, u_int8_t af,
d2033 1
a2033 1
expand_label(char *label, u_int8_t af,
d2054 2
a2055 1
	int	af = r->af, nomatch = 0, added = 0;
d2170 2
a2171 1
	int af = n->af, added = 0;
d2247 2
a2248 1
	int af = r->af, added = 0;
d2879 1
a2879 1
ifa_pick_ip(struct node_host *nh, u_int8_t af)
d3051 1
a3051 1
parseicmpspec(char *w, u_int8_t af)
@


1.171
log
@These checks are also made in nat_consistent() and rdr_consistent().

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.170 2002/10/17 10:48:57 camield Exp $	*/
d160 1
a160 1
void	ipmask(struct pf_addr *, u_int8_t);
d808 5
a812 14
				if ($1->af == AF_INET) {
					if ($3 > 32) {
						yyerror(
						    "illegal netmask value /%d",
						    $3);
						YYERROR;
					}
				} else {
					if ($3 > 128) {
						yyerror(
						    "illegal netmask value /%d",
						    $3);
						YYERROR;
					}
d814 1
a814 1
				ipmask(&n->mask, $3);
d836 1
a836 1
			ipmask(&$$->mask, 128);
d2657 1
a2657 1
ipmask(struct pf_addr *m, u_int8_t b)
d2659 1
d2662 2
d2675 5
d2854 1
a2854 1
				ipmask(&n->mask, 32);
d2856 1
a2856 1
				ipmask(&n->mask, 128);
d2932 1
a2932 1
		ipmask(&h->mask, 32);
d2952 1
a2952 1
		ipmask(&n->mask, 128);
d2981 1
a2981 1
			ipmask(&n->mask, 32);
d2988 1
a2988 1
			ipmask(&n->mask, 128);
@


1.170
log
@- accept all protocols that are specified by number if they are in
  the valid range (also when they're not listed in /etc/protocols)
- explicitly disallow protocol number 0, because it has special meaning
  to pf

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.169 2002/10/16 09:00:06 mpech Exp $	*/
a2211 5
		if (!n->af && n->raddr.addr_dyn != NULL) {
			yyerror("address family (inet/inet6) undefined");
			continue;
		}

a2278 5
		if (!r->af && (r->saddr.addr_dyn != NULL ||
		    r->daddr.addr_dyn != NULL || r->raddr.addr_dyn)) {
			yyerror("address family (inet/inet6) undefined");
			continue;
		}
@


1.169
log
@Fix and improve binat mask comparison.

dhartmei@@, henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.168 2002/10/14 12:58:28 henning Exp $	*/
d722 1
a722 1
			struct protoent *p;
d725 9
a733 3
			if (atoul($1, &ulval) == 0)
				p = getprotobynumber(ulval);
			else
d735 8
a742 3

			if (p == NULL) {
				yyerror("unknown protocol %s", $1);
d748 1
a748 1
			$$->proto = p->p_proto;
@


1.168
log
@Allow one to specify a netblock in a binat rule:

binat on fxp0 from 192.168.0.32/27 to any -> 10.0.7.128/27

Both the network mask on the source and redirect addresses MUST be the
same, and it works by essentially combining the network section of the
redirect address with the host section of the source address.

from ryan

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.167 2002/10/11 12:57:53 camield Exp $	*/
d1551 1
a1551 3
				if (!PF_AZERO(&binat.smask, binat.af) &&
				    !PF_AEQ(&binat.smask,
				    &binat.rmask, binat.af)) {
@


1.167
log
@When a macro cannot be expanded because it is not defined, say so.  Also warn
about unused macros.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.166 2002/10/11 12:46:05 camield Exp $	*/
d1365 1
a1365 1
		| ARROW address			{
d1372 1
a1372 1
		| ARROW address PORT rport	{
d1443 1
a1443 1
binatrule	: no BINAT interface af proto FROM address TO ipspec redirection
d1485 4
a1488 2
				memcpy(&binat.saddr, &$7->addr,
				    sizeof(binat.saddr));
d1509 2
a1510 2
				memcpy(&binat.daddr, &$9->addr,
				    sizeof(binat.daddr));
d1547 11
a1557 2
				memcpy(&binat.raddr, &n->addr,
				    sizeof(binat.raddr));
@


1.166
log
@In lgetc(), compress strings of whitespace to a single space.  This makes
macros come out right in verbose mode and is less functional overhead.

Also err on whitespace after a backslash.  That type of error is hard to
find otherwise.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.165 2002/10/08 01:17:43 vincent Exp $	*/
d190 1
d2524 4
a2527 2
		if (val == NULL)
			return (ERROR);
d2637 2
d2645 7
d2697 1
d2708 2
a2709 1
		if (strcmp(nam, sym->nam) == 0)
d2711 1
@


1.165
log
@ remove <0 checks on unsigned numbers.

 ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.164 2002/10/07 14:34:40 dhartmei Exp $	*/
d2417 1
a2417 1
		/* Reading characters from the parse buffer, instead of input */
d2433 2
d2441 9
d2499 1
a2499 1
	while ((c = lgetc(fin)) == ' ' || c == '\t')
@


1.164
log
@-Wsign-compare clean
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.163 2002/10/07 14:13:48 dhartmei Exp $	*/
d797 1
a797 1
					if ($3 < 0 || $3 > 32) {
d804 1
a804 1
					if ($3 < 0 || $3 > 128) {
d817 1
a817 2
number:		STRING
		{
d890 1
a890 1
				if (ulval < 0 || ulval > 65535) {
d977 1
a977 1
				if (ulval < 0 || ulval >= UID_MAX) {
d1055 1
a1055 1
				if (ulval < 0 || ulval >= GID_MAX) {
d1119 1
a1119 1
				if (ulval < 0 || ulval > 255) {
d1157 1
a1157 1
				if (ulval < 0 || ulval > 255) {
d1185 1
a1185 1
				if (ulval < 0 || ulval > 255) {
d1205 1
a1205 1
				if (ulval < 0 || ulval > 255) {
d1282 2
a1283 1
			    strcmp(pf_timeouts[i].name, $1); ++i);
a1291 4
			if ($2 < 0) {
				yyerror("illegal timeout value %d", $2);
				YYERROR;
			}
d1308 1
a1308 1
			if ($2 < 0 || $2 > 255) {
d1321 1
a1321 7
		| MAXMSS number			{
			if ($2 < 0) {
				yyerror("illegal max-mss value %d", $2);
				YYERROR;
			}
			$$ = $2;
		}
d2995 1
a2995 1
		if (ulval < 0 || ulval > 65535) {
@


1.163
log
@Two cases of const-correctness and make one global local.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.162 2002/10/07 13:23:46 henning Exp $	*/
d2608 1
a2608 1
			if (p-buf >= sizeof(buf)) {
@


1.162
log
@set block-policy [drop|return]
drop is default, same behaviour as before

support
block drop
to override a return policy
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.158 2002/10/07 12:39:29 dhartmei Exp $	*/
d2329 1
a2329 1
	return (strcmp(k, ((struct keywords *)e)->k_name));
@


1.161
log
@support a generic return
block return in|out ...
acts like return-rst on tcp, like return-icmp on udp and like an ordinary
block on anything else

ok dhartmei@@
@
text
@d61 3
a63 2
static u_int16_t returnicmp6default = (ICMP6_DST_UNREACH << 8)
    | ICMP6_DST_UNREACH_NOPORT;
d260 1
a260 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL TOS
d262 1
a262 1
%token	SET OPTIMIZATION TIMEOUT LIMIT LOGINTERFACE
d326 14
d592 10
a601 1
blockspec	: /* empty */		{ $$.b2 = 0; $$.w = 0; $$.w2 = 0; }
d2343 1
d2346 1
@


1.160
log
@make return-icmp work for rules covering both v4 and v6
-new field "return_icmp6" inpf_rule
-parser accepts
block return-icmp(ipv4-icmpcode, ipv6-icmpcode)

ok and some input dhartmei@@
@
text
@d463 2
a464 1
			if ($1.b2) {
d467 2
a468 1
			} else {
d472 6
d578 5
a582 1
		| RETURNRST		{ $$.b2 = 1; $$.w = 0; $$.w2 = 0; }
d584 1
a586 1
			$$.b2 = 1;
d589 1
a589 1
			$$.b2 = 0;
d594 1
a594 1
			$$.b2 = 0;
d599 1
a602 1
			$$.b2 = 0;
d605 1
a608 1
			$$.b2 = 0;
d611 1
d615 5
a619 1
			$$.b2 = 0;
@


1.159
log
@use a new rule_flag PFRULE_RETURNICMP to decide wether to return-icmp or not
instead of just testing return_icmp > 0

ok dhartmei@@
@
text
@d60 3
d201 1
d212 1
d469 1
d569 2
a570 2
blockspec	: /* empty */		{ $$.b2 = 0; $$.w = 0; }
		| RETURNRST		{ $$.b2 = 1; $$.w = 0; }
d573 1
d578 2
a579 1
			$$.w = (ICMP_UNREACH << 8) | ICMP_UNREACH_PORT;
d583 2
a584 2
			$$.w = (ICMP6_DST_UNREACH << 8) |
			    ICMP6_DST_UNREACH_NOPORT;
d587 3
a589 12
			const struct icmpcodeent *p;
			u_long ulval;

			if (atoul($3, &ulval) == -1) {
				if ((p = geticmpcodebyname(ICMP_UNREACH, $3,
				    AF_INET)) == NULL) {
					yyerror("unknown icmp code %s", $3);
					YYERROR;
				}
				ulval = p->code;
			}
			$$.w = (ICMP_UNREACH << 8) | ulval;
d593 9
a601 12
			const struct icmpcodeent *p;
			u_long ulval;

			if (atoul($3, &ulval) == -1) {
				if ((p = geticmpcodebyname(ICMP6_DST_UNREACH, $3,
				    AF_INET6)) == NULL) {
					yyerror("unknown icmp code %s", $3);
					YYERROR;
				}
				ulval = p->code;
			}
			$$.w = (ICMP6_DST_UNREACH << 8) | ulval;
a1776 6
	if (!(r->rule_flag & PFRULE_RETURNRST) && r->return_icmp &&
	    ((r->af != AF_INET6  &&  (r->return_icmp>>8) != ICMP_UNREACH) ||
	    (r->af == AF_INET6 && (r->return_icmp>>8) != ICMP6_DST_UNREACH))) {
		yyerror("return-icmp version does not match address family");
		problems++;
	}
d2977 22
@


1.158
log
@Add 'reply-to' to filter rules, similar to route-to, but applying to
replies (packets that flow in the opposite direction of the packet that
created state), used for symmetric routing enforcement.
Document how route-to and reply-to work in context of stateful filtering.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.157 2002/10/06 16:22:10 dhartmei Exp $	*/
d461 2
a462 1
			} else
d464 1
@


1.157
log
@Move CHECK_ROOT into LOOP_THROUGH, gets rid of one macro and saves
several lines, no functional difference. From Camiel Dobbelaar.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.156 2002/10/05 22:25:33 dhartmei Exp $	*/
d253 1
a253 1
%token	MINTTL ERROR ALLOWOPTS FASTROUTE ROUTETO DUPTO NO LABEL
d1647 26
d2348 1
@


1.156
log
@Expand {} lists from left to right, so 'pass in from { a, b } to any'
becomes '@@0 pass in from a to any @@1 pass in from b to any' instead of
the other way around. Patch from Camiel Dobbelaar.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.155 2002/10/05 21:17:57 dhartmei Exp $	*/
a1825 10
#define CHECK_ROOT(T,r) \
	do { \
		if (r == NULL) { \
			r = malloc(sizeof(T)); \
			if (r == NULL) \
				err(1, "malloc"); \
			memset(r, 0, sizeof(T)); \
		} \
	} while (0)

d1838 8
a1845 1
		T *n = r; \
a2001 10
	CHECK_ROOT(struct node_if, interfaces);
	CHECK_ROOT(struct node_proto, protos);
	CHECK_ROOT(struct node_host, src_hosts);
	CHECK_ROOT(struct node_port, src_ports);
	CHECK_ROOT(struct node_host, dst_hosts);
	CHECK_ROOT(struct node_port, dst_ports);
	CHECK_ROOT(struct node_uid, uids);
	CHECK_ROOT(struct node_gid, gids);
	CHECK_ROOT(struct node_icmp, icmp_types);

a2109 7
	CHECK_ROOT(struct node_if, interfaces);
	CHECK_ROOT(struct node_proto, protos);
	CHECK_ROOT(struct node_host, src_hosts);
	CHECK_ROOT(struct node_port, src_ports);
	CHECK_ROOT(struct node_host, dst_hosts);
	CHECK_ROOT(struct node_port, dst_ports);

a2191 5
	CHECK_ROOT(struct node_if, interfaces);
	CHECK_ROOT(struct node_proto, protos);
	CHECK_ROOT(struct node_host, src_hosts);
	CHECK_ROOT(struct node_host, dst_hosts);

a2252 1
#undef CHECK_ROOT
@


1.155
log
@Allow filtering based on IP header's tos field.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.154 2002/09/22 15:30:15 henning Exp $	*/
d80 1
d86 1
a95 1
	struct node_host	*next;
d99 2
d107 1
d114 1
d121 1
d129 1
d143 1
a436 1

d438 6
a443 1
		| antispoof_iflst comma if_item	{ $3->next = $1; $$ = $3; }
d636 5
a640 1
		| if_list comma if_item_not	{ $3->next = $1; $$ = $3; }
d660 1
d674 5
a678 1
		| proto_list comma proto_item	{ $3->next = $1; $$ = $3; }
d699 1
d729 4
a732 9
			if ($3 == NULL)
				$$ = $1;
			else {
				/* both $1 and $3 may be lists, so join them */
				$$ = $3;
				while ($3->next)
					$3 = $3->next;
				$3->next = $1;
			}
d748 2
d808 5
a812 1
		| port_list comma port_item	{ $3->next = $1; $$ = $3; }
d823 1
d833 1
d843 1
d876 5
a880 1
		| uid_list comma uid_item	{ $3->next = $1; $$ = $3; }
d891 1
d905 1
d919 1
d954 5
a958 1
		| gid_list comma gid_item	{ $3->next = $1; $$ = $3; }
d969 1
d983 1
d997 1
d1051 5
a1055 1
		| icmp_list comma icmp_item	{ $3->next = $1; $$ = $3; }
d1059 5
a1063 1
		| icmp6_list comma icmp6_item	{ $3->next = $1; $$ = $3; }
d1074 1
d1100 1
d1112 1
d1138 1
d1221 2
a1223 3
			while ($1->next)
				$1 = $1->next;
			$1->next = $3;
d1238 1
d1264 1
d2730 8
a2737 2
		n->next = h;
		h = n;
d2798 9
a2806 2
		n->next = h;
		h = n;
d2837 5
d2857 3
a2859 1
		else
d2861 1
d2872 2
d2893 2
d2929 8
a2936 2
		n->next = h;
		h = n;
@


1.154
log
@little KNF: return(something) -> return (something)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.153 2002/09/22 15:28:53 henning Exp $	*/
d246 1
a246 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL
d254 1
d434 1
a434 1
		  uids gids flags icmpspec keep fragment allowopts label
d470 3
a472 2
			r.keep_state = $13.action;
			o = $13.options;
d500 1
a500 1
			if ($14)
d502 1
a502 1
			r.allow_opts = $15;
d530 2
a531 2
			if ($16) {
				if (strlen($16) >= PF_RULE_LABEL_SIZE) {
d536 2
a537 2
				strlcpy(r.label, $16, sizeof(r.label));
				free($16);
d1130 19
d2305 1
@


1.153
log
@fix linenumber counting in findeol, and simplify by ignoring the \ case,
that's already handled earlier.
fast-forward on errnous lines

partitially from camield@@, parts result of a discussion with Mike

ok frantzen@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.152 2002/09/22 15:22:20 henning Exp $	*/
d2672 1
a2672 1
			return(n);
d2734 1
a2734 1
		return(NULL);
d2741 1
a2741 1
				return(NULL);
@


1.152
log
@antispoof, take 2.
also block incoming packets with our own IP as src.

discussion & help frantzen

ok ho@@ dhartmei@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.151 2002/09/17 16:09:49 henning Exp $	*/
d2368 3
a2370 4
		if (c == '\\') {
			c = lgetc(fin);
			if (c == '\n')
				continue;
d2372 1
a2372 1
		if (c == EOF || c == '\n')
d2497 1
a2497 1
			if (p-buf >= sizeof buf) {
d2499 1
a2499 1
				return (ERROR);
@


1.151
log
@easier "self" implementation.
no functional changes

ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.150 2002/09/15 16:56:59 henning Exp $	*/
d78 1
d97 1
d187 1
a187 1
int	ifa_exists(char *);
d404 16
a420 1

d507 2
a508 2
					if (!ifa_exists(r.rt_ifname)) {
						yyerror("unknown interface %s", 
d629 3
a631 1
			if (!ifa_exists($1)) {
d639 1
d2612 1
d2663 1
a2663 1
int
d2673 1
a2673 1
			return(1);
d2675 1
a2675 1
	return(0);
d2707 1
a2707 1
			memcpy(&n->addr.addr, &p->addr.addr, 
@


1.150
log
@set a netmask in the dynaddr case
noticed by <han@@mijncomputer.nl>

ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.149 2002/09/14 17:50:17 henning Exp $	*/
d244 1
a244 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL SELF
a758 8
		| SELF				{
			struct node_host *h = NULL;
				if ((h = ifa_lookup("all", 
				    PFCTL_IFLOOKUP_HOST)) == NULL)
					YYERROR;
				else
					$$ = h;
		}
a2259 1
		{ "self",	SELF},
d2663 1
a2663 1
	if (!strncmp(ifa_name, "all", IFNAMSIZ))
d2740 1
a2740 1
	if (ifa_exists(s)) {
@


1.149
log
@bit more clue in rdr/nat rules wrt address family examination
don't take the af from host_node structs based on interface lookups, most
interfaces will have both IPv4 and IPv6 addresses. Most rdr/nat rules will
at least have one IP address specified from whoch we take the af for the
whole rule. The rare exceptional cases require the user to specify the af.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.148 2002/09/12 12:43:23 henning Exp $	*/
d754 1
@


1.148
log
@check for calloc() failure; ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.147 2002/09/12 10:05:08 henning Exp $	*/
d1277 2
a1278 1
				if ($6.src.host && $6.src.host->af)
d1280 2
a1281 1
				else if ($6.dst.host && $6.dst.host->af)
d1299 2
d1454 1
a1454 1
				if (!rdr.af)
d1463 1
a1463 1
				if (!rdr.af)
d1484 2
@


1.147
log
@antispoof [log] [quick] for [interface|interface_list] [af]

e. g.

antispoof log quick for { dc0, dc1 } inet

docs & regress coming

ok pb@@, frantzen@@, deraadt@@
also looked over kjell@@, markus@@, itojun@@, dhartmei@@
IPv6 help itojun@@

finally, a long story finds its happy end here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.146 2002/09/12 09:48:57 henning Exp $	*/
d394 2
@


1.146
log
@rework netmask handling:
-don't set netmask in host token handler
-clear netmask in ipmask() proper before setting it
-in ifa_load(), also store interface's netmask and broadcast address
-allow ifa_lookup() to return either the interface's IP address(es), network(s)
or broadcast address(es) - not used anywhere yet. This implies that
ifa_lookup() also returns the netmask now.
-host() returns netmasks, too

ok pb@@, frantzen@@, deraadt@@
also looked over kjell@@, markus@@, itojun@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.145 2002/09/08 12:57:35 henning Exp $	*/
d247 1
d269 1
d281 1
d376 37
d2211 1
d2221 1
@


1.145
log
@be more clueful wrt address family in nat/rdr rules.
behaviour noticed by Paul de Weerd, thanks!

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.144 2002/09/02 19:42:54 dhartmei Exp $	*/
d69 6
d89 1
d186 1
a186 1
struct	node_host *ifa_lookup(char *);
d670 1
a670 9
host		: address			{
			struct node_host *n;
			for (n = $1; n; n = n->next)
				if (n->af == AF_INET)
					ipmask(&n->mask, 32);
				else
					ipmask(&n->mask, 128);
			$$ = $1;
		}
d718 2
a719 1
				if ((h = ifa_lookup("all")) == NULL)
d2475 3
d2564 1
a2564 1
		if (n->af == AF_INET)
d2568 8
a2575 1
		else if (n->af == AF_INET6) {
d2579 7
d2616 1
a2616 1
ifa_lookup(char *ifa_name)
d2631 4
d2640 14
a2653 1
		memcpy(&n->addr.addr, &p->addr.addr, sizeof(struct pf_addr));
d2658 1
a2658 1
	if (h == NULL) {
d2700 1
a2700 1
		if ((h = ifa_lookup(s)) == NULL)
d2713 1
d2731 1
d2754 1
a2754 1
		if (res->ai_family == AF_INET)
d2758 2
a2759 1
		else {
d2765 1
@


1.144
log
@Fix parsing of port ranges in translation rules (port a:b -> port c:d).
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.143 2002/09/02 19:40:31 dhartmei Exp $	*/
d1233 8
d1408 2
d1417 2
@


1.143
log
@Make sure the interface specified with route-to/dup-to/fastroute exists
and null-terminate the interface name. Found by Michael Wallis.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.142 2002/08/20 06:32:17 dhartmei Exp $	*/
d164 1
d779 1
a779 1
					yyerror("unknown protocol %s", $1);
d1182 20
a1201 13
rport		: port				{
			$$.a = $1;
			$$.b = $$.t = 0;
		}
		| port ':' port			{
			$$.a = $1;
			$$.b = $3;
			$$.t = PF_RPORT_RANGE;
		}
		| port ':' '*'			{
			$$.a = $1;
			$$.b = 0;
			$$.t = PF_RPORT_RANGE;
d1446 14
a1459 8
		| PORT port			{
			$$.a = $2;
			$$.b = $$.t = 0;
		}
		| PORT port ':' port		{
			$$.a = $2;
			$$.b = $4;
			$$.t = PF_DPORT_RANGE;
d2742 24
@


1.142
log
@Increase lineno on newlines inside multi-line macro definitions, otherwise
errors on subsequent lines are reported with wrong line numbers.
From Paul B. Henson.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.141 2002/08/16 14:14:03 henning Exp $	*/
d438 7
a444 2
					memcpy(r.rt_ifname, $5.string,
					    sizeof(r.rt_ifname));
@


1.141
log
@kill duplicated check for '(' and ')' in allowed_in_string
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.140 2002/08/12 19:36:04 dhartmei Exp $	*/
d2337 2
a2338 1
			if (c == '\n')
d2340 1
@


1.140
log
@Catch null pointer deref (segfault), from wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.139 2002/08/06 13:43:33 henning Exp $	*/
d2398 1
a2398 1
	x != ',' && x != '(' && x != ')'))
@


1.139
log
@missing free(), mpech@@
ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.138 2002/08/06 11:25:05 henning Exp $	*/
d630 9
a638 5
			/* both $1 and $3 may be lists, so join them */
			$$ = $3;
			while ($3->next)
				$3 = $3->next;
			$3->next = $1;
@


1.138
log
@check fo strdup() allocation errors

pointed out by mpech@@
ok pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.137 2002/07/31 20:19:14 henning Exp $	*/
d345 1
@


1.137
log
@KNF, esp. missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.136 2002/07/30 14:53:48 henning Exp $	*/
d1451 4
a1454 1
			$$.string = strdup($3);
d1469 4
a1472 1
			$$.string = strdup($2);
d1477 4
a1480 1
			$$.string = strdup($3);
d1495 4
a1498 1
			$$.string = strdup($2);
@


1.136
log
@grmpf.
in some cases, on non-tcp rules flags weren't resetted. cosmetical only
problem. but, well, checking for r->flags and r->flagset if we could have
assigned them zero just one round ago is just stupid, and it's not needed to
check them at all.

ok pb@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.135 2002/07/30 09:31:05 henning Exp $	*/
d134 1
d156 9
d176 1
a176 1
void	ifa_load();
d178 2
a179 2
struct node_host    *ifa_lookup(char *);
struct node_host    *ifa_pick_ip(struct node_host *, u_int8_t);
d2111 1
a2111 2
kw_cmp(k, e)
	const void *k, *e;
d2248 1
a2248 1
findeol()
@


1.135
log
@allow to specify flags on all rules that include tcp.

these are valid:

pass in from any to any flags S
pass in proto { tcp, udp, icmp } from any to any flags S
pass in proto tcp from any to any flags S

these are invalid:

pass in proto { udp, icmp } from any to any flags S
pass in proto udp from any to any flags S

ok "I've lost my slacker status for at least a week" frantzen@@
ok pb@@, dhartmei@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.134 2002/07/26 09:54:29 henning Exp $	*/
d1885 1
a1885 2
		if (r->proto && r->proto != IPPROTO_TCP &&
		    (r->flags || r->flagset)) {
@


1.134
log
@make the order of log and quick irrelevant. now both
block in log quick all
and
block in quick log all
work.

ok dhartmei@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.133 2002/07/23 18:01:15 henning Exp $	*/
d359 1
d380 11
a1545 4
	if (r->proto != IPPROTO_TCP && (r->flags || r->flagset)) {
		yyerror("flags only applies to tcp");
		problems++;
	}
d1803 4
a1806 3
	int af = r->af, nomatch = 0, added = 0;
	char ifname[IF_NAMESIZE];
	char label[PF_RULE_LABEL_SIZE];
d1809 2
d1885 8
@


1.133
log
@timeout_list/_spec and limit_list/_spec don't return anything -> no %type.

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.132 2002/07/21 21:28:06 deraadt Exp $	*/
d212 4
d233 1
a233 1
%type	<v.i>	no dir log quick af nodf allowopts fragment fragcache
d249 1
d354 1
a354 1
pfrule		: action dir log quick interface route af proto fromto
d372 2
a373 2
			r.log = $3;
			r.quick = $4;
d375 3
a377 3
			r.af = $7;
			r.flags = $12.b1;
			r.flagset = $12.b2;
d379 2
a380 2
			r.keep_state = $14.action;
			o = $14.options;
d408 1
a408 1
			if ($15)
d410 1
a410 1
			r.allow_opts = $16;
d412 4
a415 4
			if ($6.rt) {
				r.rt = $6.rt;
				if ($6.string) {
					memcpy(r.rt_ifname, $6.string,
d417 1
a417 1
					free($6.string);
d419 1
a419 1
				if ($6.addr) {
d421 2
a422 2
						r.af = $6.af;
					else if (r.af != $6.af) {
d427 1
a427 1
					memcpy(&r.rt_addr, $6.addr,
d429 1
a429 1
					free($6.addr);
d433 2
a434 2
			if ($17) {
				if (strlen($17) >= PF_RULE_LABEL_SIZE) {
d439 2
a440 2
				strlcpy(r.label, $17, sizeof(r.label));
				free($17);
d443 2
a444 2
			expand_rule(&r, $5, $8, $9.src.host, $9.src.port,
			    $9.dst.host, $9.dst.port, $10, $11, $13);
d506 1
a506 1
dir		: IN			{ $$ = PF_IN; }
d510 5
a514 3
log		: /* empty */			{ $$ = 0; }
		| LOG				{ $$ = 1; }
		| LOGALL			{ $$ = 2; }
d517 2
a518 2
quick		: /* empty */			{ $$ = 0; }
		| QUICK				{ $$ = 1; }
@


1.132
log
@fix route-to also
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.131 2002/07/21 01:37:46 deraadt Exp $	*/
a244 2
%type	<v.timeout_spec>	timeout_spec timeout_list
%type	<v.limit_spec>	limit_spec limit_list
@


1.131
log
@make the , optional in many places.  This makes string concat a lot more
useful.  Now you can
    in = ssh domain www
    out = $in ftp finger
    pass in proto tcp from any to any port { $in }
    pass out proto tcp from any to any port { $out }
a poor example, but the idea is obvious
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.130 2002/07/21 00:40:00 deraadt Exp $	*/
d1423 2
a1424 2
		| ROUTETO STRING ':' address {
			$$.string = strdup($2);
@


1.130
log
@string concat, ie.
	a=a b
	c=$a $a
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.129 2002/07/20 23:43:52 deraadt Exp $	*/
d522 1
a522 1
		| if_list ',' if_item_not	{ $3->next = $1; $$ = $3; }
d552 1
a552 1
		| proto_list ',' proto_item	{ $3->next = $1; $$ = $3; }
d601 1
a601 1
		| host_list ',' xhost		{
d694 1
a694 1
		| port_list ',' port_item	{ $3->next = $1; $$ = $3; }
d755 1
a755 1
		| uid_list ',' uid_item		{ $3->next = $1; $$ = $3; }
d826 1
a826 1
		| gid_list ',' gid_item		{ $3->next = $1; $$ = $3; }
d916 1
a916 1
		| icmp_list ',' icmp_item	{ $3->next = $1; $$ = $3; }
d920 1
a920 1
		| icmp6_list ',' icmp6_item	{ $3->next = $1; $$ = $3; }
d1054 1
a1054 1
		| state_opt_list ',' state_opt_item {
d1478 1
a1478 1
timeout_list	: timeout_list ',' timeout_spec
d1494 1
a1494 1
limit_list	: limit_list ',' limit_spec
d1496 4
@


1.129
log
@minor indent tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.128 2002/07/20 18:58:44 deraadt Exp $	*/
d242 1
a242 1
%type	<v.string>	label
d287 12
a298 1
varset		: STRING PORTUNARY STRING		{
@


1.128
log
@properly split yacc and lex use
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.127 2002/07/19 21:00:25 deraadt Exp $	*/
d61 7
a67 3
enum {PFCTL_STATE_NONE=0, PFCTL_STATE_OPTION=1,
      PFCTL_STATE_SCRUB=2, PFCTL_STATE_NAT=3,
      PFCTL_STATE_FILTER=4};
d261 1
a261 2
option		: SET OPTIMIZATION STRING
		{
d275 1
a275 2
		| SET LOGINTERFACE STRING
		{
d287 1
a287 2
varset		: STRING PORTUNARY STRING
		{
@


1.127
log
@minor tweaks, sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.126 2002/07/19 14:30:08 dhartmei Exp $	*/
d50 1
d136 1
a136 1
    struct node_host *, struct node_host *);
d138 2
a139 2
    struct node_host *, struct node_port *,
    struct node_host *, struct node_port *);
d145 1
a145 1
    struct node_host *, struct node_port *, u_int8_t);
d147 3
a149 3
    struct node_host *, struct node_port *, struct node_host *,
    struct node_port *, struct node_uid *, struct node_gid *,
    struct node_icmp *);
d217 1
a217 1
%token	MINTTL IPV6ADDR ERROR ALLOWOPTS FASTROUTE ROUTETO DUPTO NO LABEL
a221 1
%token	<v.number> NUMBER
d224 1
a224 1
%type	<v.number>	port icmptype icmp6type minttl uid gid maxmss
d232 1
a232 1
%type	<v.host>	ipspec xhost host address host_list IPV6ADDR
d439 1
a439 1
		| RETURNRST '(' TTL NUMBER ')'	{
a451 4
		| RETURNICMP '(' NUMBER ')'	{
			$$.w = (ICMP_UNREACH << 8) | $3;
			$$.b2 = 0;
		}
d454 1
d456 7
a462 4
			if ((p = geticmpcodebyname(ICMP_UNREACH, $3,
			    AF_INET)) == NULL) {
				yyerror("unknown icmp code %s", $3);
				YYERROR;
d464 1
a464 5
			$$.w = (p->type << 8) | p->code;
			$$.b2 = 0;
		}
		| RETURNICMP6 '(' NUMBER ')'	{
			$$.w = (ICMP6_DST_UNREACH << 8) | $3;
d469 1
d471 7
a477 4
			if ((p = geticmpcodebyname(ICMP6_DST_UNREACH, $3,
			    AF_INET6)) == NULL) {
				yyerror("unknown icmp code %s", $3);
				YYERROR;
d479 1
a479 1
			$$.w = (p->type << 8) | p->code;
d543 1
a543 1
proto_item	: NUMBER			{
d545 1
d547 4
a550 12
			if ((p = getprotobynumber($1)) == NULL) {
				yyerror("unknown protocol %d", $1);
				YYERROR;
			}
			$$ = malloc(sizeof(struct node_proto));
			if ($$ == NULL)
				err(1, "proto_item: malloc");
			$$->proto = p->p_proto;
			$$->next = NULL;
		}
		| STRING			{
			struct protoent *p;
d552 1
a552 1
			if ((p = getprotobyname($1)) == NULL) {
d622 1
a622 1
		| address '/' NUMBER		{
d646 12
d674 1
a674 76
		| STRING			{
			if (ifa_exists($1)) {
				struct node_host *h = NULL;

				/* interface with this name exists */
				if ((h = ifa_lookup($1)) == NULL)
					YYERROR;
				else
					$$ = h;
			} else {
				struct node_host *h = NULL, *n;
				struct addrinfo hints, *res0, *res;
				int error;

				memset(&hints, 0, sizeof(hints));
				hints.ai_family = PF_UNSPEC;
				hints.ai_socktype = SOCK_STREAM; /* DUMMY */
				error = getaddrinfo($1, NULL, &hints, &res0);
				if (error) {
					yyerror("cannot resolve %s: %s",
					    $1, gai_strerror(error));
					YYERROR;
				}
				for (res = res0; res; res = res->ai_next) {
					if (res->ai_family != AF_INET &&
					    res->ai_family != AF_INET6)
						continue;
					n = calloc(1, sizeof(struct node_host));
					if (n == NULL)
						err(1, "address: calloc");
					n->af = res->ai_family;
					n->addr.addr_dyn = NULL;
					if (res->ai_family == AF_INET)
						memcpy(&n->addr.addr,
						&((struct sockaddr_in *)
						    res->ai_addr)
						    ->sin_addr.s_addr,
						sizeof(struct in_addr));
					else {
						memcpy(&n->addr.addr,
						&((struct sockaddr_in6 *)
						    res->ai_addr)
						    ->sin6_addr.s6_addr,
						sizeof(struct in6_addr));
						n->ifindex =
						    ((struct sockaddr_in6 *)
						    res->ai_addr)
						    ->sin6_scope_id;
					}
					n->next = h;
					h = n;
				}
				freeaddrinfo(res0);
				if (h == NULL) {
					yyerror("no IP address found for %s", $1);
					YYERROR;
				}
				$$ = h;
			}
		}
		| NUMBER '.' NUMBER '.' NUMBER '.' NUMBER {
			if ($1 < 0 || $3 < 0 || $5 < 0 || $7 < 0 ||
			    $1 > 255 || $3 > 255 || $5 > 255 || $7 > 255) {
				yyerror("illegal ip address %d.%d.%d.%d",
				    $1, $3, $5, $7);
				YYERROR;
			}
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "address: calloc");
			$$->af = AF_INET;
			$$->addr.addr_dyn = NULL;
			$$->addr.addr.addr32[0] = htonl(($1 << 24) |
			    ($3 << 16) | ($5 << 8) | $7);
		}
		| IPV6ADDR			{ $$ = $1; }
d714 1
a714 8
port		: NUMBER			{
			if ($1 < 0 || $1 > 65535) {
				yyerror("illegal port value %d", $1);
				YYERROR;
			}
			$$ = htons($1);
		}
		| STRING			{
d716 1
d718 15
a732 6
			s = getservbyname($1, "tcp");
			if (s == NULL)
				s = getservbyname($1, "udp");
			if (s == NULL) {
				yyerror("unknown protocol %s", $1);
				YYERROR;
a733 1
			$$ = s->s_port;
d783 8
a790 12
uid		: NUMBER			{
			if ($1 < 0 || $1 >= UID_MAX) {
				yyerror("illegal uid value %u", $1);
				YYERROR;
			}
			$$ = $1;
		}
		| STRING			{
			if (!strcmp($1, "unknown"))
				$$ = UID_MAX;
			else {
				struct passwd *pw;
d792 9
a800 2
				if ((pw = getpwnam($1)) == NULL) {
					yyerror("unknown user %s", $1);
d803 1
a803 1
				$$ = pw->pw_uid;
d854 8
a861 12
gid		: NUMBER			{
			if ($1 < 0 || $1 >= GID_MAX) {
				yyerror("illegal gid value %u", $1);
				YYERROR;
			}
			$$ = $1;
		}
		| STRING			{
			if (!strcmp($1, "unknown"))
				$$ = GID_MAX;
			else {
				struct passwd *pw;
d863 9
a871 2
				if ((pw = getpwnam($1)) == NULL) {
					yyerror("unknown group %s", $1);
d874 1
a874 1
				$$ = pw->pw_uid;
a919 13
		| icmptype CODE NUMBER	{
			$$ = malloc(sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: malloc");
			if ($3 < 0 || $3 > 255) {
				yyerror("illegal icmp-code %d", $3);
				YYERROR;
			}
			$$->type = $1;
			$$->code = $3 + 1;
			$$->proto = IPPROTO_ICMP;
			$$->next = NULL;
		}
d922 1
d924 13
d941 1
a941 6
			if ((p = geticmpcodebyname($1, $3,
			    AF_INET)) == NULL) {
				yyerror("unknown icmp-code %s", $3);
				YYERROR;
			}
			$$->code = p->code + 1;
a955 13
		| icmp6type CODE NUMBER	{
			$$ = malloc(sizeof(struct node_icmp));
			if ($$ == NULL)
				err(1, "icmp_item: malloc");
			if ($3 < 0 || $3 > 255) {
				yyerror("illegal icmp6-code %d", $3);
				YYERROR;
			}
			$$->type = $1;
			$$->code = $3 + 1;
			$$->proto = IPPROTO_ICMPV6;
			$$->next = NULL;
		}
d958 1
d960 13
d977 1
a977 6
			if ((p = geticmpcodebyname($1, $3,
			    AF_INET6)) == NULL) {
				yyerror("unknown icmp6-code %s", $3);
				YYERROR;
			}
			$$->code = p->code + 1;
d985 1
d987 12
a998 3
			if ((p = geticmptypebyname($1, AF_INET)) == NULL) {
				yyerror("unknown icmp-type %s", $1);
				YYERROR;
a999 8
			$$ = p->type + 1;
		}
		| NUMBER			{
			if ($1 < 0 || $1 > 255) {
				yyerror("illegal icmp-type %d", $1);
				YYERROR;
			}
			$$ = $1 + 1;
d1005 1
d1007 12
a1018 10
			if ((p = geticmptypebyname($1, AF_INET6)) == NULL) {
				yyerror("unknown ipv6-icmp-type %s", $1);
				YYERROR;
			}
			$$ = p->type + 1;
		}
		| NUMBER			{
			if ($1 < 0 || $1 > 255) {
				yyerror("illegal icmp6-type %d", $1);
				YYERROR;
a1019 1
			$$ = $1 + 1;
d1050 1
a1050 1
state_opt_item	: MAXIMUM NUMBER		{
d1062 1
a1062 1
		| STRING NUMBER			{
d1093 1
a1093 1
		| MINTTL NUMBER			{
d1107 1
a1107 1
		| MAXMSS NUMBER			{
d1431 2
a1432 2
		| DUPTO STRING ':' address {
			$$.string = strdup($2);
d1453 1
a1453 1
timeout_spec	: STRING NUMBER
d1470 1
a1470 1
limit_spec	: STRING NUMBER
a2328 90
	/* Need to parse v6 addresses before tokenizing numbers. ick */
	if (isxdigit(c) || c == ':') {
		struct node_host *node = NULL;
		u_int32_t addr[4];
		char lookahead[46];
		int i = 0;
		struct addrinfo hints, *res;

		lookahead[i] = c;

		while (i < sizeof(lookahead) &&
		    (isalnum(c) || c == ':' || c == '.' || c == '%')) {
			lookahead[++i] = c = lgetc(fin);
		}

		/* quick check avoids calling inet_pton too often */
		lungetc(lookahead[i], fin);
		lookahead[i] = '\0';

		memset(&hints, 0, sizeof(hints));
		hints.ai_family = AF_INET6;
		hints.ai_socktype = SOCK_DGRAM;	/*dummy*/
		hints.ai_flags = AI_NUMERICHOST;
		if (getaddrinfo(lookahead, "0", &hints, &res) == 0) {
			node = calloc(1, sizeof(struct node_host));
			if (node == NULL)
				err(1, "yylex: calloc");
			node->af = AF_INET6;
			node->addr.addr_dyn = NULL;
			memcpy(&node->addr.addr,
			    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
			    sizeof(addr));
			node->ifindex = ((struct sockaddr_in6 *)res->ai_addr)
			    ->sin6_scope_id;
			yylval.v.host = node;
			return IPV6ADDR;
			freeaddrinfo(res);
		} else {
			free(node);
			while (i > 1)
				lungetc(lookahead[--i], fin);
			c = lookahead[--i];
		}
	}

	if (isdigit(c)) {
		int index = 0, base = 10;
		u_int64_t n = 0;

		yylval.v.number = 0;
		while (1) {
			if (base == 10) {
				if (!isdigit(c))
					break;
				c -= '0';
			} else if (base == 16) {
				if (isdigit(c))
					c -= '0';
				else if (c >= 'a' && c <= 'f')
					c -= 'a' - 10;
				else if (c >= 'A' && c <= 'F')
					c -= 'A' - 10;
				else
					break;
			}
			n = n * base + c;

			if (n > UINT_MAX) {
				yyerror("number is too large");
				return (ERROR);
			}
			c = lgetc(fin);
			if (c == EOF)
				break;
			if (index++ == 0 && n == 0 && c == 'x') {
				base = 16;
				c = lgetc(fin);
				if (c == EOF)
					break;
			}
		}
		yylval.v.number = (u_int32_t)n;

		if (c != EOF)
			lungetc(c, fin);
		if (debug > 1)
			fprintf(stderr, "number: %d\n", yylval.v.number);
		return (NUMBER);
	}

d2333 1
a2333 1
	x != ',' && x != ':' && x != '(' && x != ')'))
d2335 1
a2335 1
	if (isalnum(c)) {
d2556 100
@


1.126
log
@And back out the last change again.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.125 2002/07/19 13:23:37 henning Exp $	*/
d136 1
a136 1
void	expand_nat(struct pf_nat *, struct node_if *, struct node_proto *, 
d2629 1
a2629 1
		} 
d2648 1
a2648 1
	
@


1.125
log
@rework the interface lookup routines internals.
less and easier code than before.
no functional changes.

ok frantzen@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.124 2002/07/19 12:36:48 dhartmei Exp $	*/
d2238 1
a2238 6
		while ((next = getc(fin)) == ' ')
			;
		if (next == '#')
			do
				next = getc(fin);
			while (next != '\n' && next != EOF);
a2337 4
			if (c == '#')
				do
					c = lgetc(fin);
				while (c != '\n' && c != EOF);
@


1.124
log
@Support # comments at the end of lines and inside (multi-line) string
literals, so you can do things like

  macro="{ foo,   # first entry
           bar,   # second entry
           baz }" # last entry

or

  pass in on $ext_if    \ # external interface
    proto tcp           \ # TCP connections
    from any to $ext_if \ # to the gateway itself
    keep state

And sneaking in two minor fixes for KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.123 2002/07/19 11:12:42 henning Exp $	*/
d83 1
d2591 1
a2591 7
struct ifaddrs **ifatab, **ifalist;
int ifatablen, ifalistlen;
int
ifa_comp(const void *p1, const void *p2)
{
	struct ifaddrs *ifa1 = *(struct ifaddrs **)p1;
	struct ifaddrs *ifa2 = *(struct ifaddrs **)p2;
d2593 1
a2593 2
	return strcmp(ifa1->ifa_name, ifa2->ifa_name);
}
d2599 1
a2599 2
	void *p;
	int load_ifalen = 0;
d2603 1
a2603 7
	for (ifa = ifap; ifa; ifa = ifa->ifa_next)
		load_ifalen++;
	/* (over-)allocate tables */
	ifatab = malloc(load_ifalen * sizeof(void *));
	ifalist = malloc(load_ifalen * sizeof(void *));
	if (!ifatab || !ifalist)
		err(1, "malloc");
d2605 9
a2613 7
		if (ifa->ifa_addr->sa_family == AF_LINK) {
			if (bsearch(&ifa, ifalist, ifalistlen, sizeof(void *),
			    ifa_comp))
				continue; /* take only the first LINK address */
			ifalist[ifalistlen++] = ifa;
			qsort(ifalist, ifalistlen, sizeof(void *), ifa_comp);
		}
d2615 1
a2615 1
		if (ifa->ifa_addr->sa_family == AF_INET6 &&
d2627 21
a2647 19
		if (ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6) {
			ifatab[ifatablen++] = ifa;
		}
	}
	/* shrink tables */
	if ((p = realloc(ifatab, ifatablen * sizeof(void *))) == NULL) {
		free(ifatab);
		ifatab = NULL;
	} else
		ifatab = p;
	if ((p = realloc(ifalist, ifalistlen * sizeof(void *))) == NULL) {
		free(ifalist);
		ifalist = NULL;
	} else
		ifalist = p;
	if (!ifatab || !ifalist)
		err(1, "realloc");

d2653 1
a2653 1
	struct ifaddrs ifa, *ifp = &ifa, **ifpp;
d2655 1
a2655 1
	if (!ifalist)
d2657 6
a2662 6
	ifa.ifa_name = ifa_name;
	ifpp = bsearch(&ifp, ifalist, ifalistlen, sizeof(void *), ifa_comp);
	if (ifpp == NULL)
		return(0);
	else
		return(1);
d2668 1
a2668 2
	struct node_host *h = NULL, *n = NULL;
	struct ifaddrs *ifa;
d2671 1
a2671 1
	if (strncmp(ifa_name, "all", IFNAMSIZ) == 0)
d2674 1
a2674 1
	if (!ifatab)
d2676 14
a2689 25
	for (ifa = *ifatab; ifa; ifa = ifa->ifa_next) {
		if (strncmp(ifa->ifa_name, ifa_name, IFNAMSIZ) == 0 || 
		    return_all) {
			if (!(ifa->ifa_addr->sa_family == AF_INET ||
			    ifa->ifa_addr->sa_family == AF_INET6))
				continue;
			n = calloc(1, sizeof(struct node_host));
			if (n == NULL)
				err(1, "address: calloc");
			n->af = ifa->ifa_addr->sa_family;
			n->addr.addr_dyn = NULL;
			if (ifa->ifa_addr->sa_family == AF_INET)
				memcpy(&n->addr.addr, &((struct sockaddr_in *)
				    ifa->ifa_addr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
			else {
				memcpy(&n->addr.addr, &((struct sockaddr_in6 *)
				    ifa->ifa_addr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
				n->ifindex = ((struct sockaddr_in6 *)
				    ifa->ifa_addr)->sin6_scope_id;
			}
			n->next = h;
			h = n;
		}
@


1.123
log
@deal with the fact that the struct node_host ifa_pick_ip gets is not always
the result of an interface expansion. in this case ifa_pick_ip does an
address family check (that's actually a (wanted) side effect). Thus, we need
to spit out a meaningfull error message in case of a mismatch.
also adjust all the other error messages, they were also assuming that nh is
the result of an interface expansion.
after a looooong discussion on icb (dhartmei@@, pb@@, me) we agreed on the term
"translation address" for that.

okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.122 2002/07/17 08:32:20 henning Exp $	*/
d2237 6
a2242 1
		next = getc(fin);
d2342 4
d2728 1
a2728 1
	for(h = nh; h; h = h->next) {
a2737 1

d2741 1
a2741 1
	return n;
a2742 1

@


1.122
log
@support "self" as address. self expands to all IPv4 and IPv6 addresses of
the machine, on all interfaces. I wanted
  block in log on ! lo0 from any to self
for years, and now it's possible.

ok "I may lose my slacking status if I OK it" frantzen@@
ok dhartmei@@

documentation in pf.conf.5 to come with pb@@'s rewrite
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.121 2002/07/16 15:46:55 dhartmei Exp $	*/
d2714 3
a2716 3
	if (af == 0 && nh->next) {
		yyerror("address family not given and interface has multiple "
		    "IPs");
d2722 2
a2723 2
				yyerror("interface has multiple IPs of "
				    "this address family");
d2729 4
@


1.121
log
@Add nat_consistent() and rdr_consistent() for checks that should occur
after rule expansion, similar to rule_consistent(). Fixes the
non-effective test for rdr rules for non-TCP/UDP protocols with ports,
found by mpech@@, ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.120 2002/07/15 18:13:53 henning Exp $	*/
d216 1
a216 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL
d661 7
d2186 1
d2670 4
d2678 2
a2679 1
		if (strncmp(ifa->ifa_name, ifa_name, IFNAMSIZ) == 0) {
@


1.120
log
@add support for
  pass|block on ! $interface ...

ok dhartmei@@

will be documented in pf.conf(5) by "I'm not slacking!" pb@@ who's currently
reworking this manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.119 2002/07/15 15:44:15 pb Exp $	*/
d129 2
d330 4
a333 1
			pfctl_add_rule(pf, &r);
a1439 7
			if (rdr.proto && rdr.proto != IPPROTO_TCP &&
			    rdr.proto != IPPROTO_UDP &&
			    (rdr.dport || rdr.dport2 || rdr.rport)) {
				yyerror("rdr ports are only valid for proto tcp/udp");
				YYERROR;
			}

d1625 30
d1917 1
a1917 1
			yyerror("skipping rule due to errors");
d2010 6
a2015 2
		pfctl_add_nat(pf, n);
		added++;
d2085 7
a2091 2
		pfctl_add_rdr(pf, r);
		added++;
@


1.119
log
@
cosmetics/consolidations to manpage in yyerror()s

ok henning@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.118 2002/07/15 13:36:02 henning Exp $	*/
a353 7
			if ($5 != NULL)
				if ($5->not) {
					yyerror("'pass/block on ! $interface' "
					    "isn't supported.");
					YYERROR;
				}

d1858 1
@


1.118
log
@o complain about keep state on block rules
o complain about return-rst on rules which aren't limited to tcp

pointed out by not-slacking-but-testing pb@@

ok pb@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.117 2002/07/13 18:36:02 henning Exp $	*/
d636 1
a636 1
						    "illegal netmask value %d",
d643 1
a643 1
						    "illegal netmask value %d",
d981 1
a981 1
				yyerror("illegal icmp code %d", $3);
d1021 1
a1021 1
				yyerror("illegal icmp6 code %d", $3);
d1058 1
a1058 1
				yyerror("illegal icmp type %d", $1);
d1076 1
a1076 1
				yyerror("illegal icmp6 type %d", $1);
d1487 1
a1487 1
				yyerror("multiple routeto ip addresses");
d1507 1
a1507 1
				yyerror("multiple dupto ip addresses");
d2080 2
a2081 1
		yyerror("Rules must be in order: options, scrub, nat, filter");
d2672 1
a2672 1
		    "ips");
@


1.117
log
@add list expansion for interface and proto in nat rules and for proto in rdr
rules (interface was already there). since the nat.conf/pf.conf merge the
parser accepted these but didn't expand them. ugh.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.116 2002/07/09 11:50:58 itojun Exp $	*/
d1621 8
@


1.116
log
@check sin6_scope_id field, just in case we change the routing socket API
for scoped address (unlikely due to the deployed codebase...).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.115 2002/07/09 11:49:02 itojun Exp $	*/
d131 4
a134 3
void	expand_rdr(struct pf_rdr *, struct node_if *, struct node_host *,
    struct node_host *);
void	expand_nat(struct pf_nat *, struct node_host *, struct node_port *,
a1234 6
			if ($3 != NULL) {
				memcpy(nat.ifname, $3->ifname,
				    sizeof(nat.ifname));
				nat.ifnot = $3->not;
				free($3);
			}
a1235 4
			if ($5 != NULL) {
				nat.proto = $5->proto;
				free($5);
			}
d1270 1
a1270 1
			expand_nat(&nat, $6.src.host, $6.src.port,
a1395 5
			if ($3 != NULL) {
				memcpy(rdr.ifname, $3->ifname,
				    sizeof(rdr.ifname));
				rdr.ifnot = $3->not;
			}
a1396 4
			if ($5 != NULL) {
				rdr.proto = $5->proto;
				free($5);
			}
d1449 1
a1449 1
			expand_rdr(&rdr, $3, $7, $9);
d1911 4
a1914 3
expand_nat(struct pf_nat *n, struct node_host *src_hosts,
    struct node_port *src_ports, struct node_host *dst_hosts,
    struct node_port *dst_ports)
d1916 1
d1919 2
d1926 2
d1934 1
d1938 7
a1944 1
		    src_host->af != dst_host->af))
d1950 8
d1963 2
d1983 1
a1983 1
	))));
d1985 2
d1998 1
a1998 1
    struct node_host *src_hosts,
d2005 1
d2010 1
d2044 2
d2053 1
a2053 1
	)));
d2056 1
@


1.115
log
@getifaddrs(3) grabs link-local addrs in kernel internal form, convert them
into proper sockaddr_in6.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.114 2002/07/09 10:39:08 henning Exp $	*/
d2558 2
a2559 1
		    IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr)) {
@


1.114
log
@rework the interface-to-IP routines.

you can use interface names instead of an IP in most places. However, until
now, it was only expanded to the interface's first IPv4 address if existant
(and address family unset or inet) and the first IPv6 address otherwise.

this diff changes that.  the interface is proper expanded to all IPs, IPv4
_and_ IPv6, now.

it also cleans up the lookup procedures (well, in fact, they are replaced by
a new one), there's no need for different procedures for IPv4 and IPv6. we
now just have one list of interfaces (AF_LINK) and one list with IPs
(AF_INET and AF_INET6) with corresponding lookup functions, ifa_exists and
ifa_lookup.

nat, rdr & friends now use the new function ifa_pick_ip to get the IP in
rules like

nat on $interface from $whatever to any -> $interface

ifa_pick_ip tries to be smart.
if the interface has only one IP address and the nat rule doesn't specify an
address family (or it matches with this address), take this one.
If the address family is specified in the nat rule and there is only one IP
for the given address family, this one is used. if the address family is not
specified and there is more than one IP pfctl throws an error. The same
applies for multiple IPs per address family.

This causes regression tests 18 and 20 to fail because the address family
isn't specified there; diff for those coming.

also fix some prototypes while I'm here.

pb@@ found another problem while testing that we must have introduced somewhat
after 3.1.

$cat t
nat on ne3 from any to any -> 213.128.133.5
$pfctl -nvf t
nat on ne3 all -> ?

it's only a representation bug as far as I've checked, nontheless it should
be fixed. as a nat/rdr rule always nats/redirects to one IP only we can just
steal its target's IP af and set the rule's af accordingly. then inet_ntop
does play nice.
binat rules already enforce having an address family set always and thus are
not affected.

ok dhartmei@@, pb@@, kjell@@
"It looks good" frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.113 2002/07/08 11:46:32 dhartmei Exp $	*/
d2556 12
@


1.113
log
@Don't allow 'flags' option in non-TCP rules, found by mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.112 2002/07/05 18:09:50 henning Exp $	*/
d154 2
a155 2
int	symset(const char *name, const char *val);
char *	symget(const char *name);
d157 4
a160 3
struct ifaddrs    *ifa0_lookup(char *ifa_name);
struct ifaddrs    *ifa4_lookup(char *ifa_name);
struct ifaddrs    *ifa6_lookup(char *ifa_name);
d517 1
a517 1
			if (ifa0_lookup($1) == 0) {
d663 2
a664 2
			if (ifa0_lookup($1)) {
				struct ifaddrs *ifa;
d666 2
a667 30
				/* an interface with this name exists */
				if ((ifa = ifa4_lookup($1))) {
					struct sockaddr_in *sin =
					    (struct sockaddr_in *)
					    ifa->ifa_addr;

					$$ = calloc(1,
					    sizeof(struct node_host));
					if ($$ == NULL)
						err(1, "address: calloc");
					$$->af = AF_INET;
					$$->addr.addr_dyn = NULL;
					memcpy(&$$->addr.addr, &sin->sin_addr,
					    sizeof(u_int32_t));
				} else if ((ifa = ifa6_lookup($1))) {
					struct sockaddr_in6 *sin6 =
					    (struct sockaddr_in6 *)
					    ifa->ifa_addr;

					$$ = calloc(1,
					    sizeof(struct node_host));
					if ($$ == NULL)
						err(1, "address: calloc");
					$$->af = AF_INET6;
					$$->addr.addr_dyn = NULL;
					memcpy(&$$->addr.addr, &sin6->sin6_addr,
					    sizeof(struct pf_addr));
				} else {
					yyerror("interface %s has no IP "
					    "addresses", $1);
d669 2
a670 1
				}
a1211 4
			if ($2->next) {
				yyerror("multiple ip addresses");
				YYERROR;
			}
a1218 4
			if ($2->next) {
				yyerror("multiple ip addresses");
				YYERROR;
			}
d1247 2
a1248 1
					yyerror("'no nat' rule does not need '->'");
d1252 2
d1255 2
a1256 1
					yyerror("'nat' rule requires '-> address'");
d1259 6
a1264 1
				memcpy(&nat.raddr, &$7->address->addr,
d1363 2
d1370 4
a1373 1
				if ($10->address->addr.addr_dyn != NULL) {
d1379 1
a1379 1
					$10->address->af = binat.af;
d1381 1
a1381 1
				if (binat.af && $10->address->af != binat.af) {
d1385 2
a1386 2
				binat.af = $10->address->af;
				memcpy(&binat.raddr, &$10->address->addr,
d1440 2
d1443 2
a1444 1
					yyerror("'rdr' rule requires '-> address'");
d1447 6
a1452 1
				memcpy(&rdr.raddr, &$11->address->addr,
d2521 2
a2522 3
struct ifaddrs **ifa0tab, **ifa4tab, **ifa6tab;
int ifa0len, ifa4len, ifa6len;

d2537 1
a2537 1
	int ifalen = 0;
d2542 1
a2542 1
		ifalen++;
d2544 3
a2546 4
	ifa0tab = malloc(ifalen * sizeof(void *));
	ifa4tab = malloc(ifalen * sizeof(void *));
	ifa6tab = malloc(ifalen * sizeof(void *));
	if (!ifa0tab || !ifa4tab || !ifa6tab)
d2550 1
a2550 1
			if (bsearch(&ifa, ifa0tab, ifa0len, sizeof(void *),
d2553 2
a2554 2
			ifa0tab[ifa0len++] = ifa;
			qsort(ifa0tab, ifa0len, sizeof(void *), ifa_comp);
d2556 3
a2558 14
		if (ifa->ifa_addr->sa_family == AF_INET) {
			if (bsearch(&ifa, ifa4tab, ifa4len, sizeof(void *),
			    ifa_comp))
				continue; /* take only the first IPv4 address */
			ifa4tab[ifa4len++] = ifa;
			qsort(ifa4tab, ifa4len, sizeof(void *), ifa_comp);
		}
		if (ifa->ifa_addr->sa_family == AF_INET6) {
			/* XXX - better address selection required! */
			if (bsearch(&ifa, ifa6tab, ifa6len, sizeof(void *),
			    ifa_comp))
				continue; /* take only the first IPv6 address */
			ifa6tab[ifa6len++] = ifa;
			qsort(ifa6tab, ifa6len, sizeof(void *), ifa_comp);
d2562 3
a2564 8
	if ((p = realloc(ifa0tab, ifa0len * sizeof(void *))) == NULL) {
		free(ifa0tab);
		ifa0tab = NULL;
	} else
		ifa0tab = p;
	if ((p = realloc(ifa4tab, ifa4len * sizeof(void *))) == NULL) {
		free(ifa4tab);
		ifa4tab = NULL;
d2566 4
a2569 4
		ifa4tab = p;
	if ((p = realloc(ifa6tab, ifa6len * sizeof(void *))) == NULL) {
		free(ifa6tab);
		ifa6tab = NULL;
d2571 2
a2572 2
		ifa6tab = p;
	if (!ifa0tab || !ifa4tab || !ifa6tab)
d2574 1
d2577 2
a2578 2
struct ifaddrs *
ifa0_lookup(char *ifa_name)
d2582 1
a2582 1
	if (!ifa0tab)
d2585 5
a2589 2
	ifpp = bsearch(&ifp, ifa0tab, ifa0len, sizeof(void *), ifa_comp);
	return ifpp ? *ifpp : NULL;
d2592 2
a2593 2
struct ifaddrs *
ifa4_lookup(char *ifa_name)
d2595 2
a2596 1
	struct ifaddrs ifa, *ifp = &ifa, **ifpp;
d2598 1
a2598 1
	if (!ifa4tab)
d2600 29
a2628 3
	ifa.ifa_name = ifa_name;
	ifpp = bsearch(&ifp, ifa4tab, ifa4len, sizeof(void *), ifa_comp);
	return ifpp ? *ifpp : NULL;
d2631 2
a2632 2
struct ifaddrs *
ifa6_lookup(char *ifa_name)
d2634 1
a2634 1
	struct ifaddrs ifa, *ifp = &ifa, **ifpp;
d2636 16
a2651 5
	if (!ifa6tab)
		ifa_load();
	ifa.ifa_name = ifa_name;
	ifpp = bsearch(&ifp, ifa6tab, ifa6len, sizeof(void *), ifa_comp);
	return ifpp ? *ifpp : NULL;
@


1.112
log
@unbreak.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.111 2002/07/05 16:48:44 henning Exp $	*/
d1608 4
@


1.111
log
@another small bug I found while installing a -current pf firewall.
we don't support

pass/block in on ! <interface>

(at least, not yet)
let the parser complain instead of ignoring the '!'

ok pb@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.110 2002/07/01 10:07:40 espie Exp $	*/
d352 6
a357 5
			if ($5->not) {
				yyerror("'pass/block on ! $interface' isn't "
				    "supported.");
				YYERROR;
			}
@


1.110
log
@streamline parse buffer handling (no need to copy value that is not
going to go away).

add explicit pushback buffer, to be able to push IPv6 failed parses back.

handle pushback + parse buffer interactions by using negative indices.

okay dhartmei@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.109 2002/07/01 05:28:22 deraadt Exp $	*/
d352 5
@


1.109
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.108 2002/06/28 19:29:45 dhartmei Exp $	*/
d154 2
a155 2
int	symset(char *name, char *val);
char *	symget(char *name);
d2152 2
d2156 2
a2163 1
restart:
d2166 7
a2172 7
		c = parsebuf[parseindex++];
		if (c != '\0')
			return (c);
		free(parsebuf);
		parsebuf = NULL;
		parseindex = 0;
		goto restart;
d2175 4
a2178 2
	c = getc(fin);
	if (c == '\\') {
d2182 1
a2182 1
			return (c);
a2185 1
		goto restart;
d2193 3
a2195 2
	if (parsebuf && parseindex) {
		/* XXX breaks on index 0 */
d2197 2
a2198 1
		return (c);
d2200 4
a2203 1
	return ungetc(c, fin);
d2211 2
a2212 5
	if (parsebuf) {
		free(parsebuf);
		parsebuf = NULL;
		parseindex = 0;
	}
d2263 1
a2263 3
		parsebuf = strdup(val);
		if (parsebuf == NULL)
			err(1, "parsebuf: strdup");
d2489 1
a2489 1
symset(char *nam, char *val)
d2513 1
a2513 1
symget(char *nam)
@


1.108
log
@Don't check for address family conflicts in nat/rdr before expansion,
rules will expand to all valid combinations, and there's an error when
none is found. Makes "nat on tun0 from 10.0.0.0/8 to any -> (tun0)"
work (again).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.107 2002/06/25 08:13:25 henning Exp $	*/
d63 1
a63 1
 
d277 1
a277 1
		}		
d294 1
a294 1
			
d339 1
a339 1
			
d1258 1
a1258 1
			
d1309 1
a1309 1
			
d1415 1
a1415 1
			
@


1.107
log
@move pfctl options -t, -m, -O and -l to pf.conf. These are set using the
"set" keyword. example rulefile:

set optimization aggressive
set timeout { tcp.closing 6, tcp.opening 6 }
set limit { states 1000, frags 1000 }
set loginterface wi0
pass out all keep state label "$nr:$srcaddr:$srcport:$dstaddr:$dstport"
block in all

fries@@ is working on an updated pf.conf(5)
discussed at c2k2 and on icb
ok dhartmei@@, kjell@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.106 2002/06/24 10:55:08 dhartmei Exp $	*/
a1282 13
				if ($7->address->addr.addr_dyn != NULL) {
					if (!nat.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$7->address->af = nat.af;
				}
				if (nat.af && $7->address->af != nat.af) {
					yyerror("nat ip versions must match");
					YYERROR;
				}
				nat.af = $7->address->af;
a1428 4
			if ($7 != NULL && $9 != NULL && $7->af != $9->af) {
				yyerror("rdr ip versions must match");
				YYERROR;
			}
a1429 13
				if ($7->addr.addr_dyn != NULL) {
					if (!rdr.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$7->af = rdr.af;
				}
				if (rdr.af && $7->af != rdr.af) {
					yyerror("rdr ip versions must match");
					YYERROR;
				}
				rdr.af = $7->af;
a1436 13
				if ($9->addr.addr_dyn != NULL) {
					if (!rdr.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$9->af = rdr.af;
				}
				if (rdr.af && $9->af != rdr.af) {
					yyerror("rdr ip versions must match");
					YYERROR;
				}
				rdr.af = $9->af;
a1457 13
				if ($11->address->addr.addr_dyn != NULL) {
					if (!rdr.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$11->address->af = rdr.af;
				}
				if (rdr.af && $11->address->af != rdr.af) {
					yyerror("rdr ip versions must match");
					YYERROR;
				}
				rdr.af = $11->address->af;
d1957 4
d2024 5
@


1.106
log
@Use interface when specified in scrub rule. No support for ! or {} yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.105 2002/06/23 03:07:21 deraadt Exp $	*/
d60 3
a62 2
enum {PFCTL_STATE_NONE=0, PFCTL_STATE_SCRUB=1,
      PFCTL_STATE_NAT=2, PFCTL_STATE_FILTER=3};
d145 1
d214 1
d236 2
d242 1
d252 28
d295 1
a295 3
			if (rulestate > PFCTL_STATE_SCRUB) {
				yyerror("Rules must be in order: "
				    "scrub, nat, filter");
a296 2
			}
			rulestate = PFCTL_STATE_SCRUB;
a321 1

d337 1
a337 3
			if (rulestate > PFCTL_STATE_FILTER) {
				yyerror("Rules must be in order: "
				    "scrub, nat, filter");
a338 2
			}
			rulestate = PFCTL_STATE_FILTER;
d431 1
a431 1
		| RETURNRST		{ $$.b2 = 1; $$.w = 0;}
d1256 1
a1256 3
			if (rulestate > PFCTL_STATE_NAT) {
				yyerror("Rules must be in order: "
				    "scrub, nat, filter");
a1257 2
			}
			rulestate = PFCTL_STATE_NAT;
d1320 1
a1320 3
			if (rulestate > PFCTL_STATE_NAT) {
				yyerror("Rules must be in order: "
				    "scrub, nat, filter");
a1321 2
			}
			rulestate = PFCTL_STATE_NAT;
d1426 1
a1426 3
			if (rulestate > PFCTL_STATE_NAT) {
				yyerror("Rules must be in order: "
				    "scrub, nat, filter");
a1427 2
			}
			rulestate = PFCTL_STATE_NAT;
d1599 34
d2106 11
d2149 1
d2152 1
d2162 1
d2176 1
d2178 1
@


1.105
log
@uid_t and gid_t are unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.104 2002/06/20 08:47:58 dhartmei Exp $	*/
d273 13
@


1.104
log
@Copy address family from inet/inet6 keyword, if specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.103 2002/06/18 21:05:17 frantzen Exp $	*/
d828 1
a828 1
				yyerror("illegal uid value %d", $1);
d896 1
a896 1
				yyerror("illegal gid value %d", $1);
@


1.103
log
@propogate a '!' when a host resolves to multiple IP addresses
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.102 2002/06/18 20:07:58 frantzen Exp $	*/
d1411 1
@


1.102
log
@don't allow individual keep state rules to specify timeouts for 'interval' and
'frag' -- they aren't applied anyway
ok dhartmei@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.101 2002/06/16 23:22:18 aaron Exp $	*/
d560 6
a565 1
xhost		: '!' host			{ $$ = $2; $$->not = 1; }
@


1.101
log
@Rules must in order -> Rules must be in order
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.100 2002/06/15 19:19:09 dhartmei Exp $	*/
d1105 4
@


1.100
log
@Reset rulestate in parse_rules(), so consecutive calls (like from authpf)
will not fail. Reported by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.99 2002/06/13 04:26:00 kjell Exp $	*/
d262 1
a262 1
				yyerror("Rules must in order: "
d296 1
a296 1
				yyerror("Rules must in order: "
d1210 1
a1210 1
				yyerror("Rules must in order: "
d1278 1
a1278 1
				yyerror("Rules must in order: "
d1388 1
a1388 1
				yyerror("Rules must in order: "
@


1.99
log
@Fix the numbering of scrub rules. pointed out and oked by frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.98 2002/06/12 18:35:07 kjell Exp $	*/
d2421 1
@


1.98
log
@Fix uninitialized access. Spotted by danh@@ This is a good reason to
develop with "ln -s 'J' /etc/malloc.conf" enabled.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.97 2002/06/11 18:03:25 frantzen Exp $	*/
d283 1
@


1.97
log
@split the grammar of scrub(fragcache) into scrub ... 'fragment reassemble',
'fragment crop' or a new 'fragment drop-ovl' which will drop overlapping
fragments and all corresponding ones
ok kjell@@ with feedback from kjell@@ and deraadt@@.  the rest are slacking
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.96 2002/06/11 02:27:19 frantzen Exp $	*/
d1058 4
a1061 1
keep		: /* empty */			{ $$.action = 0; }
@


1.96
log
@SCRUB(fragcache) to do gap tracking and overlap pruning of IPv4 fragments
without the memory overhead of the conventional defrag in SCRUB
ok dhartmei@@, idea by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.95 2002/06/11 02:12:37 dhartmei Exp $	*/
d210 2
a211 1
%token	NOROUTE FRAGCACHE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL
d257 1
a257 1
scrubrule	: SCRUB fragcache dir interface fromto nodf minttl maxmss
d271 1
a271 1
			r.direction = $3;
d273 2
a274 2
			if ($2)
				r.rule_flag |= PFRULE_FRAGCACHE;
d276 1
a276 1
				r.rule_flag |= PFRULE_NODF;
d278 2
a279 1
				r.min_ttl = $7;
d281 1
a281 1
				r.max_mss = $8;
d439 3
a441 1
		| '(' FRAGCACHE ')'	{ $$ = PFRULE_FRAGCACHE; }
d2049 2
a2053 1
		{ "fragcache",	FRAGCACHE},
d2081 1
@


1.95
log
@Make NAT proxy port range configurable per rule, for instance privileged
source ports can mapped to privileged proxy ports, or source port 500
to proxy port 500. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.94 2002/06/10 23:07:46 kjell Exp $	*/
d210 1
a210 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL
d216 1
a216 1
%type	<v.i>	no dir log quick af nodf allowopts fragment
d256 1
a256 1
scrubrule	: SCRUB dir interface fromto nodf minttl maxmss
d270 1
a270 1
			r.direction = $2;
d272 3
a274 1
			if ($5)
a275 2
			if ($6)
				r.min_ttl = $6;
d277 3
a279 1
				r.max_mss = $7;
d436 5
d2048 1
@


1.94
log
@Merge the NAT and rules files into a single rulefile. Rules must be
in this order, to remove any ambiguity about what order things happen in:

scrub rules
nat rules
filter rules

The -N and -R modifiers go away. Rulefiles are now loaded with the
more POSIXly-correct '-f'

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.93 2002/06/10 19:31:44 dhartmei Exp $	*/
d1153 5
d1240 9
@


1.93
log
@Allow ports to be specified in nat rules, useful later on for individual
proxy port ranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.92 2002/06/10 16:51:37 dhartmei Exp $	*/
d58 1
a58 1
static int natmode = 0;
d60 3
a236 1
		| ruleset pfrule '\n'
d240 1
d259 7
d290 3
a292 2
			if (natmode) {
				yyerror("filter rule not permitted in nat mode");
d295 2
d1189 3
a1191 2
			if (!natmode) {
				yyerror("nat rule not permitted in filter mode");
d1194 2
d1248 3
a1250 2
			if (!natmode) {
				yyerror("binat rule not permitted in filter mode");
d1253 2
d1358 3
a1360 2
			if (!natmode) {
				yyerror("rdr rule not permitted in filter mode");
d1363 2
a2384 13
	natmode = 0;
	fin = input;
	pf = xpf;
	lineno = 1;
	errors = 0;
	yyparse();
	return (errors ? -1 : 0);
}

int
parse_nat(FILE *input, struct pfctl *xpf)
{
	natmode = 1;
@


1.92
log
@Move enum out of struct (gcc 3.1 wasn't happy), from David Krause
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.91 2002/06/10 02:09:59 kjell Exp $	*/
d129 2
a130 1
void	expand_nat(struct pf_nat *, struct node_host *, struct node_host *);
d1172 1
a1172 1
natrule		: no NAT interface af proto FROM ipspec TO ipspec redirection
a1193 45
			if ($7 != NULL && $9 != NULL && $7->af != $9->af) {
				yyerror("nat ip versions must match");
				YYERROR;
			}
			if ($7 != NULL) {
				if ($7->addr.addr_dyn != NULL) {
					if (!nat.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$7->af = nat.af;
				}
				if (nat.af && $7->af != nat.af) {
					yyerror("nat ip versions must match");
					YYERROR;
				}
				nat.af = $7->af;
				memcpy(&nat.src.addr, &$7->addr,
				    sizeof(nat.src.addr));
				memcpy(&nat.src.mask, &$7->mask,
				    sizeof(nat.src.mask));
				nat.src.not = $7->not;
			}
			if ($9 != NULL) {
				if ($9->addr.addr_dyn != NULL) {
					if (!nat.af) {
						yyerror("address family (inet/"
						    "inet6) undefined");
						YYERROR;
					}
					$9->af = nat.af;
				}
				if (nat.af && $9->af != nat.af) {
					yyerror("nat ip versions must match");
					YYERROR;
				}
				nat.af = $9->af;
				memcpy(&nat.dst.addr, &$9->addr,
				    sizeof(nat.dst.addr));
				memcpy(&nat.dst.mask, &$9->mask,
				    sizeof(nat.dst.mask));
				nat.dst.not = $9->not;
			}

d1195 1
a1195 1
				if ($10 != NULL) {
d1200 1
a1200 1
				if ($10 == NULL || $10->address == NULL) {
d1204 1
a1204 1
				if ($10->address->addr.addr_dyn != NULL) {
d1210 1
a1210 1
					$10->address->af = nat.af;
d1212 1
a1212 1
				if (nat.af && $10->address->af != nat.af) {
d1216 2
a1217 2
				nat.af = $10->address->af;
				memcpy(&nat.raddr, &$10->address->addr,
d1219 2
a1220 2
				free($10->address);
				free($10);
d1223 2
a1224 1
			expand_nat(&nat, $7, $9);
d1867 2
a1868 1
    struct node_host *dst_hosts)
d1873 1
d1875 1
d1878 1
d1880 1
d1895 5
d1902 5
d1910 2
a1911 1
	));
d1914 1
d1916 1
@


1.91
log
@split scrub rule processing into its own yacc target,
for imminent config file merge. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.90 2002/06/09 20:20:58 dhartmei Exp $	*/
d106 1
a107 1
	enum	{ PF_STATE_OPT_MAX=0, PF_STATE_OPT_TIMEOUT=1 };
@


1.90
log
@Make pf_nat.saddr/daddr a pf_rule_addr instead of pf_addr_wrap, so it
includes ports and operator.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.89 2002/06/09 05:31:25 deraadt Exp $	*/
d232 1
d252 21
d274 1
a274 2
		  uids gids flags icmpspec keep fragment nodf minttl
		  maxmss allowopts label
d331 1
a331 7
			if ($16)
				r.rule_flag |= PFRULE_NODF;
			if ($17)
				r.min_ttl = $17;
			if ($18)
				r.max_mss = $18;
			r.allow_opts = $19;
d354 2
a355 2
			if ($20) {
				if (strlen($20) >= PF_RULE_LABEL_SIZE) {
d360 2
a361 2
				strlcpy(r.label, $20, sizeof(r.label));
				free($20);
a370 1
		| SCRUB			{ $$.b1 = PF_SCRUB; $$.b2 = $$.w = 0; }
a1576 43
	if (r->action == PF_SCRUB) {
		if (r->quick) {
			yyerror("quick does not apply to scrub");
			problems++;
		}
		if (r->keep_state == PF_STATE_MODULATE) {
			yyerror("modulate state does not apply to scrub");
			problems++;
		}
		if (r->keep_state == PF_STATE_NORMAL) {
			yyerror("keep state does not apply to scrub");
			problems++;
		}
		if (r->src.port_op) {
			yyerror("src port does not apply to scrub");
			problems++;
		}
		if (r->dst.port_op) {
			yyerror("dst port does not apply to scrub");
			problems++;
		}
		if (r->type || r->code) {
			yyerror("icmp-type/code does not apply to scrub");
			problems++;
		}
		if (r->rule_flag & PFRULE_FRAGMENT) {
			yyerror("fragment flag does not apply to scrub");
			problems++;
		}
	} else {
		if (r->rule_flag & PFRULE_NODF) {
			yyerror("nodf only applies to scrub");
			problems++;
		}
		if (r->min_ttl) {
			yyerror("min-ttl only applies to scrub");
			problems++;
		}
		if (r->max_mss) {
			yyerror("max-mss only applies to scrub");
			problems++;
		}
	}
@


1.89
log
@spaced out developers...
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.88 2002/06/09 02:47:10 kjell Exp $	*/
d1197 5
a1201 5
				memcpy(&nat.saddr, &$7->addr,
				    sizeof(nat.saddr));
				memcpy(&nat.smask, &$7->mask,
				    sizeof(nat.smask));
				nat.snot = $7->not;
d1217 5
a1221 5
				memcpy(&nat.daddr, &$9->addr,
				    sizeof(nat.daddr));
				memcpy(&nat.dmask, &$9->mask,
				    sizeof(nat.dmask));
				nat.dnot = $9->not;
d1943 2
a1944 2
	CHECK_ROOT(struct node_host, src_hosts)
;	CHECK_ROOT(struct node_host, dst_hosts);
d1960 4
a1963 4
		n->saddr = src_host->addr;
		n->smask = src_host->mask;
		n->daddr = dst_host->addr;
		n->dmask = dst_host->mask;
@


1.88
log
@Add list parsing in RDR rules: e.g.

rdr on $IFLIST proto tcp from $SRC_LIST to $DST_LIST port 21 \
  -> 127.0.0.1 port 8021

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.87 2002/06/08 22:40:32 henning Exp $	*/
d107 1
a107 1
        enum	{ PF_STATE_OPT_MAX=0, PF_STATE_OPT_TIMEOUT=1 };
d112 1
a112 1
			int	 	number;
d1043 1
a1043 1
state_opt_item	: MAXIMUM NUMBER 		{
d1779 1
a1779 1
		tmp[0] = 0; 
d1950 1
a1950 1
	    	if ((n->af && src_host->af && n->af != src_host->af) ||
d1959 2
a1960 2
		    
 	        n->saddr = src_host->addr;
d1962 1
a1962 1
 	        n->daddr = dst_host->addr;
d1993 1
a1993 1
	    	if ((r->af && src_host->af && r->af != src_host->af) ||
d2002 1
a2002 1
  		    dst_host->ifindex != if_nametoindex(interface->ifname)))
d2005 1
a2005 1
 	        if (!r->af && src_host->af)
d2017 1
a2017 1
 	        r->saddr = src_host->addr;
d2019 1
a2019 1
 	        r->daddr = dst_host->addr;
@


1.87
log
@nuke unused parameter af to expand_label_port
ok dhartmei@@, pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.86 2002/06/08 21:09:59 dhartmei Exp $	*/
d127 2
a1378 1
				free($3);
a1388 4
				if ($7->next) {
					yyerror("multiple rdr ip addresses");
					YYERROR;
				}
a1406 1
				free($7);
a1408 4
				if ($9->next) {
					yyerror("multiple rdr ip addresses");
					YYERROR;
				}
a1426 1
				free($9);
d1471 1
a1471 1
			pfctl_add_rdr(pf, &rdr);
d1973 1
a1973 1
		yyerror("nat rule expands to no valid AF combination");
d1976 57
@


1.86
log
@Change remaining read-only lookup tables to const, suggestion drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.85 2002/06/08 20:59:52 itojun Exp $	*/
d129 1
a129 1
void	expand_label_port(const char *, char *, u_int8_t, struct node_port *);
d1743 1
a1743 2
expand_label_port(const char *name, char *label, u_int8_t af,
    struct node_port *port)
d1825 2
a1826 2
	expand_label_port("$srcport", label, af, src_port);
	expand_label_port("$dstport", label, af, dst_port);
@


1.85
log
@comment on IPv6 link-local twists
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.84 2002/06/08 09:41:52 kjell Exp $	*/
d377 1
a377 1
			struct icmpcodeent *p;
d392 1
a392 1
			struct icmpcodeent *p;
d924 1
a924 1
			struct icmpcodeent *p;
d964 1
a964 1
			struct icmpcodeent *p;
d982 1
a982 1
			struct icmptypeent *p;
d1000 1
a1000 1
			struct icmptypeent *p;
@


1.84
log
@add list expansion to src/dest in NAT rules. i.e.

  nat on fxp0 from { 10.0.0.0/24, 10.0.1.0/24 } to \
    { 172.6.1.1, 172.14.1.2/32 } -> fxp0

ok theo, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.83 2002/06/08 08:44:09 henning Exp $	*/
d78 1
a78 1
	u_int32_t		 ifindex;
d1867 1
@


1.83
log
@remove macro concatenation via += per Theo's advice
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.81 2002/06/08 07:58:07 dhartmei Exp $	*/
d127 1
a1181 4
				if ($7->next) {
					yyerror("multiple nat ip addresses");
					YYERROR;
				}
a1199 1
				free($7);
a1201 4
				if ($9->next) {
					yyerror("multiple nat ip addresses");
					YYERROR;
				}
a1219 1
				free($9);
d1251 1
a1251 1
			pfctl_add_nat(pf, &nat);
d1945 40
@


1.82
log
@allow macro concatenation like
    webservers  = "{ 10.0.0.1,  10.0.0.7,  10.0.0.8, "
    webservers += "  10.0.0.17, 10.0.0.25, 10.0.0.37 }"
ok frantzen@@, dhartmei@@
@
text
@a145 1
int	symextend(char *name, char *val);
d203 1
a203 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL PLUSEQUAL
a233 1
		| ruleset varextend '\n'
a247 11
varextend	: STRING PLUSEQUAL STRING
		{
			if (pf->opts & PF_OPT_VERBOSE)
				printf("%s += %s\n", $1, $3);
			if (symextend($1, $3) == -1) {
				yyerror("cannot extend variable %s", $1);
				YYERROR;
			}
		}
		;
		
a2211 6
	case '+':
		next = lgetc(fin);
		if (next == '=')
			return (PLUSEQUAL);
		lungetc(next, fin);
		break;
a2399 18
}

int
symextend(char *nam, char *val)
{
	struct sym *sym;
	char *p;
	
	for (sym = symhead; sym && strcmp(nam, sym->nam); sym = sym->next)
		;	/* nothing */
	if (sym == NULL)
		return -1;
	p = realloc(sym->val, strlen(sym->val) + strlen(val) + 1);
	if (p == NULL)
		return -1;
	sym->val = p;
	strlcat(sym->val, val, strlen(sym->val) + strlen(val) + 1);
	return 0;
@


1.81
log
@Make state timeouts configurable per rule, like

  pass in from any to any port www keep state (tcp.established 60)

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.80 2002/06/08 01:00:23 henning Exp $	*/
d146 1
d202 1
a202 1
%token  ICMP6TYPE CODE KEEP MODULATE STATE PORT RDR NAT BINAT ARROW NODF
d204 1
a204 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM TTL
d235 1
d250 11
d2225 6
d2419 18
@


1.80
log
@expand $nr -> rule number in rule labels
okay dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.79 2002/06/08 00:23:41 henning Exp $	*/
d106 13
d174 1
d190 2
a191 4
			int		action;
			struct {
				u_int32_t	max_states;
			}		options;
d223 2
a224 1
%type	<v.keep_state>	keep keep_opts
d253 1
d277 27
a303 1
			r.max_states = $14.options.max_states;
d1017 1
a1017 1
		| KEEP STATE keep_opts		{
d1019 1
a1019 1
			$$.options = $3.options;
d1021 1
a1021 1
		| MODULATE STATE keep_opts	{
d1023 14
a1036 1
			$$.options = $3.options;
d1040 3
a1042 4
keep_opts	: /* empty */			{ $$.options.max_states = 0; }
		| '(' MAXIMUM NUMBER ')'	{
			if ($3 <= 0) {
				yyerror("illegal keep states max value %d", $3);
d1045 27
a1071 1
			$$.options.max_states = $3;
@


1.79
log
@expand $proto in rule labels
okay frantzen@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.78 2002/06/07 23:30:39 dhartmei Exp $	*/
d117 1
d1733 15
d1760 1
@


1.78
log
@Handle realloc() failure gracefully. Terminates with err() anyway in this
case, but we don't want to trigger "p = realloc(p," grepping causing false
alarms here.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.77 2002/06/07 23:06:43 deraadt Exp $	*/
d116 1
d118 1
a118 1
    struct node_host *, struct node_port *);
d1712 22
d1736 2
a1737 1
    struct node_host *dst_host, struct node_port *dst_port)
d1743 1
d1806 1
a1806 1
		    dst_host, dst_port);
@


1.77
log
@henning, read this to see what i mean by KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.76 2002/06/07 22:53:45 pb Exp $	*/
d2309 1
d2347 15
a2361 3
	ifa0tab = realloc(ifa0tab, ifa0len * sizeof(void *));
	ifa4tab = realloc(ifa4tab, ifa4len * sizeof(void *));
	ifa6tab = realloc(ifa6tab, ifa6len * sizeof(void *));
@


1.76
log
@
add the possibility to configure a TTL while return-rst

ok dhartmei@@, ipv6 part itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.75 2002/06/07 21:25:35 dhartmei Exp $	*/
d1655 1
a1655 1
			if (inet_ntop(af, &host->addr.addr, a, 
d1661 2
a1662 2
			if ((af == AF_INET && bits < 32) || 
			    (af == AF_INET6 && bits < 128)) 
d1680 1
a1680 1
		tmp[0] = 0; 
d1687 1
a1687 1
		    op[0] = 0;
d1689 1
a1689 1
		    snprintf(op, sizeof(op), "%s><%s", a1, a2);
d1691 1
a1691 1
		    snprintf(op, sizeof(op), "%s<>%s", a1, a2);
d1693 1
a1693 1
		    snprintf(op, sizeof(op), "%s", a1);
d1695 1
a1695 1
		    snprintf(op, sizeof(op), "!=%s", a1);
d1697 1
a1697 1
		    snprintf(op, sizeof(op), "<%s", a1);
d1699 1
a1699 1
		    snprintf(op, sizeof(op), "<=%s", a1);
d1701 1
a1701 1
		    snprintf(op, sizeof(op), ">%s", a1);
d1703 1
a1703 1
		    snprintf(op, sizeof(op), ">=%s", a1);
d1761 1
a1761 1
		     src_host->ifindex != dst_host->ifindex) ||
d1763 1
a1763 1
		     src_host->ifindex != if_nametoindex(interface->ifname)) ||
d1765 1
a1765 1
		     dst_host->ifindex != if_nametoindex(interface->ifname)))
d1778 1
a1778 1
			
d1780 1
a1780 1
		expand_label(r->label, r->af, src_host, src_port, 
@


1.75
log
@Add "(max <number>)" option for "keep/modulate state" to limit the number
of concurrent connections a rule can create. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.74 2002/06/07 19:33:03 henning Exp $	*/
d189 1
a189 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS MAXIMUM
d246 1
a246 1
			if ($1.b2)
d248 2
a249 1
			else
d316 4
d1895 1
@


1.74
log
@allow using $srcaddr, $srcport, $dstaddr and $dstport in rule labels,
evaluated at parse time.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.73 2002/06/07 18:26:55 itojun Exp $	*/
d173 6
d189 1
a189 1
%token	NOROUTE FRAGMENT USER GROUP MAXMSS
d195 1
a195 1
%type	<v.i>	no dir log quick af keep nodf allowopts fragment
d209 1
d259 2
a260 1
			r.keep_state = $14;
d969 19
a987 3
keep		: /* empty */			{ $$ = 0; }
		| KEEP STATE			{ $$ = PF_STATE_NORMAL; }
		| MODULATE STATE		{ $$ = PF_STATE_MODULATE; }
d1867 1
@


1.73
log
@make IPv6 scope identification work for dst (from any to fe80::1%lo0)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.72 2002/06/07 18:24:33 itojun Exp $	*/
d114 4
d1601 92
d1702 3
d1749 4
@


1.72
log
@support scoped IPv6 address in from/to portion.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.71 2002/06/01 04:06:47 hugh Exp $	*/
d1635 3
a1637 1
		     src_host->ifindex != if_nametoindex(interface->ifname)))
d1644 5
a1648 1
		if (if_indextoname(src_host->ifindex, ifname) == 0)
a1649 2
		else
			memcpy(r->ifname, ifname, sizeof(r->ifname));
@


1.71
log
@ECN flag support for pf. Committed in consultation with Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.70 2002/05/24 13:48:44 dhartmei Exp $	*/
d78 1
d370 1
a370 1
			if (ifa0_lookup($1) == NULL) {
d575 1
a575 1
					else
d581 5
d1605 1
d1631 5
a1635 1
		    src_host->af != dst_host->af))
d1642 4
a1645 1
		memcpy(r->ifname, interface->ifname, sizeof(r->ifname));
d1696 1
a1696 1
		yyerror("rule expands to no valid address family combination");
d1961 2
a1962 1
		int i = 0, notv6addr = 0;
d1967 1
a1967 1
		    (isxdigit(c) || c == ':' || c == '.')) {
a1971 2
		if (isalnum(c))
			notv6addr++;
d1975 5
a1979 1
		if (!notv6addr && inet_pton(AF_INET6, lookahead, &addr) == 1) {
d1985 5
a1989 1
			memcpy(&node->addr.addr, &addr, sizeof(addr));
d1992 1
@


1.70
log
@Support mixed (IPv4/v6) address lists, expand to all possible and valid
combinations. 'pass in from { 10.1.2.3, ::1 } to { 10.4.5.6, ::2 }' will
expand to two rules, 'from 10.1.2.3 to 10.4.5.6' and 'from ::1 to ::2'.
Also applies to host name resolution (when multiple addresses are returned
for one name). ok frantzen@@, itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.69 2002/05/23 09:47:20 deraadt Exp $	*/
d815 1
a815 1
		| FLAGS flag			{ $$.b1 = $2.b1; $$.b2 = 63; }
@


1.69
log
@tiny KNF, some malloc checks, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.68 2002/05/23 07:47:05 itojun Exp $	*/
a545 2
				struct hostent *hp;
				char **a;
d547 2
d550 13
a562 14
				hp = gethostbyname2($1, AF_INET);
				if (hp == NULL) {
					hp = gethostbyname2($1, AF_INET6);
					if (hp == NULL) {
						yyerror("cannot resolve %s", $1);
						YYERROR;
					}
				}
				for (a = hp->h_addr_list; *a; ++a) {
					if (!((hp->h_addrtype == AF_INET &&
					    hp->h_length == 4) ||
					    (hp->h_addrtype == AF_INET6 &&
					    hp->h_length == 16)))
						err(1, "address: invalid");
d566 1
a566 1
					n->af = hp->h_addrtype;
d568 12
a579 1
					memcpy(&n->addr.addr, *a, hp->h_length);
d583 5
a587 2
				if (h == NULL)
					err(1, "address: empty list");
d1583 3
a1585 1
			C; \
d1598 1
a1598 1
	int nomatch = 0;
d1620 11
a1655 23
		if ((src_host->af && dst_host->af && r->af) &&
		    (src_host->af != dst_host->af || src_host->af != r->af ||
			    dst_host->af != r->af)) {
			yyerror("address family mismatch");
			nomatch++;
		} else if ((src_host->af && dst_host->af) &&
		    (src_host->af != dst_host->af)) {
			yyerror("address family mismatch");
			nomatch++;
		} else if ((src_host->af && r->af) &&
		    (src_host->af != r->af)) {
			yyerror("address family mismatch");
			nomatch++;
		} else if ((dst_host->af && r->af) &&
		    (dst_host->af != r->af)) {
			yyerror("address family mismatch");
			nomatch++;
		} else if (src_host->af && !r->af) {
			r->af = src_host->af;
		} else if (dst_host->af && !r->af) {
			r->af= dst_host->af;
		}

d1666 1
d1680 3
@


1.68
log
@new_addr is not used from anywhere.  daniel@@benzedrine.cx ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.67 2002/05/19 22:26:27 deraadt Exp $	*/
d1955 1
a1955 1
		if(!notv6addr && inet_pton(AF_INET6, lookahead, &addr) == 1) {
d1957 2
d1961 1
a1961 1
			memcpy (&node->addr.addr, &addr, sizeof(addr));
@


1.67
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.66 2002/05/12 15:02:52 dhartmei Exp $	*/
d110 7
a116 10
int			 rule_consistent(struct pf_rule *);
int			 yyparse(void);
struct pf_rule_addr	*new_addr(void);
void			 ipmask(struct pf_addr *, u_int8_t);
void			 expand_rule(struct pf_rule *,
			    struct node_if *, struct node_proto *,
			    struct node_host *, struct node_port *,
			    struct node_host *, struct node_port *,
			    struct node_uid *, struct node_gid *,
			    struct node_icmp *);
a2082 12
}

struct pf_rule_addr *
new_addr(void)
{
	struct pf_rule_addr *ra;

	ra = malloc(sizeof(struct pf_rule_addr));
	if (ra == NULL)
		err(1, "new_addr: malloc failed");
	memset(ra, 0, sizeof(*ra));
	return (ra);
@


1.66
log
@Explain that user/group 'unknown' can only be used with operators = and !=
and refuse other constructs in the parser. Also note that 'user >= 0' does
not match forwarded packets with unknown user ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.65 2002/05/12 00:54:56 dhartmei Exp $	*/
d113 1
a113 1
void		 	 ipmask(struct pf_addr *, u_int8_t);
d215 1
a215 1
			if (pf->opts & PF_OPT_VERBOSE)			
d224 3
a226 1
pfrule		: action dir log quick interface route af proto fromto uids gids flags icmpspec keep fragment nodf minttl maxmss allowopts label
d276 1
a276 1
					}	
d474 1
a474 1
					ipmask(&n->mask, 32); 
d810 1
a810 1
icmpspec	: /* empty */                   { $$ = NULL; }
d825 1
a825 1
icmp_item	: icmptype		{ 
d828 1
a828 1
				err(1, "icmp_item: malloc");	
d1378 2
a1379 2
route		: /* empty */			{ 
			$$.string = NULL; 
d1404 2
a1405 2
		| ROUTETO STRING 		{
			$$.string = strdup($2); 
d1424 2
a1425 2
		| DUPTO STRING 		{ 
			$$.string = strdup($2); 
d1632 1
a1632 1
		
d1634 1
a1634 1
		    (src_host->af != dst_host->af || src_host->af != r->af || 
d1646 1
a1646 1
		} else if ((dst_host->af && r->af) && 
d1655 1
a1655 1
		
d1938 3
a1940 3
        /* Need to parse v6 addresses before tokenizing numbers. ick */
        if (isxdigit(c) || c == ':') {
                struct node_host *node = NULL;
d1943 1
a1943 1
                int i = 0, notv6addr = 0;
d1947 1
a1947 1
		while (i < sizeof(lookahead) && 
d1949 1
a1949 1
			 	lookahead[++i] = c = lgetc(fin);
d1953 1
a1953 1
		if (isalnum(c)) {
a1954 1
		}
d1963 2
a1964 2
                	yylval.v.host = node;
                	return IPV6ADDR;
d1966 3
a1968 4
                	free(node);
                	while (i > 1) {
                        	lungetc(lookahead[--i], fin);
			}
d1971 1
a1971 1
        }
@


1.65
log
@Add gid based filtering, reduce to one (effective) uid, rename parser
keywords to 'user' and 'group'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.64 2002/05/10 14:09:53 dhartmei Exp $	*/
d674 4
d687 4
d742 4
d755 4
@


1.64
log
@Handle host name resolution returning multiple addresses in the rule
parser (expand to every address). ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.63 2002/05/09 21:58:12 jasoni Exp $	*/
d92 6
d118 1
a118 1
			    struct node_uid *, struct node_uid *,
d156 1
d181 1
a181 1
%token	NOROUTE FRAGMENT RUID EUID MAXMSS
d186 1
a186 1
%type	<v.number>	port icmptype icmp6type minttl uid maxmss
d196 2
a197 1
%type	<v.uid>		ruid euid uid_list uid_item
d224 1
a224 1
pfrule		: action dir log quick interface route af proto fromto ruid euid flags icmpspec keep fragment nodf minttl maxmss allowopts label
d655 3
a657 8
ruid		: /* empty */			{ $$ = NULL; }
		| RUID uid_item			{ $$ = $2; }
		| RUID '{' uid_list '}'		{ $$ = $3; }
		;

euid		: /* empty */			{ $$ = NULL; }
		| EUID uid_item			{ $$ = $2; }
		| EUID '{' uid_list '}'		{ $$ = $3; }
d715 60
d1565 1
a1565 1
    struct node_uid *ruids, struct node_uid *euids,
d1576 2
a1577 2
	CHECK_ROOT(struct node_uid, ruids);
	CHECK_ROOT(struct node_uid, euids);
d1587 2
a1588 2
	LOOP_THROUGH(struct node_uid, ruid, ruids,
	LOOP_THROUGH(struct node_uid, euid, euids,
d1606 6
a1611 6
		r->ruid.op = ruid->op;
		r->ruid.uid[0] = ruid->uid[0];
		r->ruid.uid[1] = ruid->uid[1];
		r->euid.op = euid->op;
		r->euid.uid[0] = euid->uid[0];
		r->euid.uid[1] = euid->uid[1];
d1658 2
a1659 2
	FREE_LIST(struct node_uid, ruids);
	FREE_LIST(struct node_uid, euids);
a1685 1
		{ "euid",	EUID},
d1690 1
a1718 1
		{ "ruid",	RUID},
d1722 1
@


1.63
log
@Add a max-mss option to the scrub rule which will enforce a maximum mss
by lowering it to the given value.
- ok dhartmei@@, provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.62 2002/05/09 19:58:42 dhartmei Exp $	*/
d441 7
a447 1
		| host_list ',' xhost		{ $3->next = $1; $$ = $3; }
d461 6
a467 4
			if ($$->af == AF_INET)
				ipmask(&$$->mask, 32); 
			else
				ipmask(&$$->mask, 128);
d470 16
a485 9
			if ($$->af == AF_INET) {
				if ($3 < 0 || $3 > 32) {
					yyerror("illegal netmask value %d", $3);
					YYERROR;
				}
			} else {
				if ($3 < 0 || $3 > 128) {
					yyerror("illegal netmask value %d", $3);
					YYERROR;
d487 1
a489 1
			ipmask(&$$->mask, $3);
d503 2
a504 2
			struct hostent *hp;
			struct ifaddrs *ifa;
a505 1
			if (ifa0_lookup($1)) {
d538 21
a558 9
			}
			else if ((hp = gethostbyname2($1, AF_INET)) == NULL) {
				if ((hp = gethostbyname2($1, AF_INET6))
				    == NULL) {
					yyerror("cannot resolve %s", $1);
					YYERROR;
				} else {
					$$ = calloc(1, sizeof(struct node_host));
					if ($$ == NULL)
d560 9
a568 13
					$$->af = AF_INET6;
					$$->addr.addr_dyn = NULL;
					memcpy(&$$->addr.addr, hp->h_addr,
					    sizeof(struct pf_addr));
				}
			} else {
				$$ = calloc(1, sizeof(struct node_host));
				if ($$ == NULL)
					err(1, "address: calloc");
				$$->af = AF_INET;
				$$->addr.addr_dyn = NULL;
				memcpy(&$$->addr.addr, hp->h_addr,
				    sizeof(u_int32_t));
d924 4
d935 4
d971 4
d996 4
d1080 4
d1102 4
d1187 4
d1212 4
d1316 4
d1334 4
@


1.62
log
@Introduce user based filtering. Rules can specify ruid and euid (real and
effective user ID) much like ports. The user of a packet is either the
user that opens an outgoing connection, the one that listens on a socket,
or 'unknown' if the firewall is not a connection endpoint (for forwarded
connections). Socket uid lookup code from jwk@@bug.it.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.61 2002/04/24 18:10:25 dhartmei Exp $	*/
d174 1
a174 1
%token	NOROUTE FRAGMENT RUID EUID
d179 1
a179 1
%type	<v.number>	port icmptype icmp6type minttl uid
d216 1
a216 1
pfrule		: action dir log quick interface route af proto fromto ruid euid flags icmpspec keep fragment nodf minttl allowopts label
d248 3
a250 1
			r.allow_opts = $18;
d273 2
a274 2
			if ($19) {
				if (strlen($19) >= PF_RULE_LABEL_SIZE) {
d279 2
a280 2
				strlcpy(r.label, $19, sizeof(r.label));
				free($19);
d860 10
d1347 4
d1575 1
@


1.61
log
@Add dynamic (in-kernel) interface name -> address translation. Instead of
using just the interface name instead of an address and reloading the rule
set whenever the interface changes its address, the interface name can be
put in parentheses, and the kernel will keep track of changes and update
rules. There is no additional cost for evaluating rules (per packet),
the cost occurs when an interface changes address (and the rules are
traversed and updated where necessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.60 2002/04/23 14:32:23 dhartmei Exp $	*/
d49 1
d86 6
a107 10
void			 expand_rule_hosts(struct pf_rule *,
			    struct node_if *, struct node_proto *,
			    struct node_host *, struct node_port *,
			    struct node_host *, struct node_port *,
			    struct node_icmp *);
void			 expand_rule_protos(struct pf_rule *,
			    struct node_if *, struct node_proto *,
			    struct node_host *, struct node_port *,
			    struct node_host *, struct node_port *,
			    struct node_icmp *);
d112 1
d149 1
d174 1
a174 1
%token	NOROUTE FRAGMENT
d179 1
a179 1
%type	<v.number>	port icmptype icmp6type minttl
d189 1
d216 1
a216 1
pfrule		: action dir log quick interface route af proto fromto flags icmpspec keep fragment nodf minttl allowopts label
d237 2
a238 2
			r.flags = $10.b1;
			r.flagset = $10.b2;
d240 1
a240 1
			r.keep_state = $12;
d242 1
a242 1
			if ($13)
d244 1
a244 1
			if ($14)
d246 3
a248 3
			if ($15)
				r.min_ttl = $15;
			r.allow_opts = $16;
d271 2
a272 2
			if ($17) {
				if (strlen($17) >= PF_RULE_LABEL_SIZE) {
d277 2
a278 2
				strlcpy(r.label, $17, sizeof(r.label));
				free($17);
d282 1
a282 1
			    $9.dst.host, $9.dst.port, $11);
d623 65
d1388 2
d1410 8
a1417 111
void expand_rule_hosts(struct pf_rule *r,
    struct node_if *interface, struct node_proto *proto,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_icmp *icmp_type)
{
	struct node_host *src_host, *dst_host;
	struct node_port *src_port, *dst_port;
	int nomatch = 0;

	src_host = src_hosts;
	while (src_host != NULL) {
		src_port = src_ports;
		while (src_port != NULL) {
			dst_host = dst_hosts;
			while (dst_host != NULL) {
				dst_port = dst_ports;
				while (dst_port != NULL) {
					memcpy(r->ifname, interface->ifname,
					  sizeof(r->ifname));
					r->proto = proto->proto;
					r->src.addr = src_host->addr;
					r->src.mask = src_host->mask;
					r->src.noroute = src_host->noroute;
					r->src.not = src_host->not;
					r->src.port[0] = src_port->port[0];
					r->src.port[1] = src_port->port[1];
					r->src.port_op = src_port->op;
					r->dst.addr = dst_host->addr;
					r->dst.mask = dst_host->mask;
					r->dst.noroute = dst_host->noroute;
					r->dst.not = dst_host->not;
					r->dst.port[0] = dst_port->port[0];
					r->dst.port[1] = dst_port->port[1];
					r->dst.port_op = dst_port->op;
					r->type = icmp_type->type;
					r->code = icmp_type->code;
					
					if ((src_host->af && dst_host->af && 
						r->af) && (src_host->af != 
						    dst_host->af || 
						    src_host->af != r->af || 
						    dst_host->af != r->af)) {
						yyerror("address family"
						    " mismatch");
						nomatch++;
					} else if ((src_host->af && 
						       dst_host->af) && 
					    (src_host->af != dst_host->af)) {
						yyerror("address family"
						    " mismatch");
						nomatch++;
					} else if ((src_host->af && r->af) && 
					    (src_host->af != r->af)) {
						yyerror("address family"
						    " mismatch");
						nomatch++;
					} else if ((dst_host->af && r->af) && 
					    (dst_host->af != r->af)) {
						yyerror("address family"
						    " mismatch");
						nomatch++;
					} else if (src_host->af && !r->af) {
						r->af = src_host->af;
					} else if (dst_host->af && !r->af) {
						r->af= dst_host->af;
					}
					
					if (icmp_type->proto &&
					    r->proto != icmp_type->proto) {
						yyerror("icmp-type mismatch");
						nomatch++;
					}

					if (rule_consistent(r) < 0 || nomatch)
						yyerror("skipping rule "
						    "due to errors");
					else {
						r->nr = pf->rule_nr++;
						pfctl_add_rule(pf, r);
					}
					dst_port = dst_port->next;
				}
				dst_host = dst_host->next;
			}
			src_port = src_port->next;
		}
		src_host = src_host->next;
	}
}

void expand_rule_protos(struct pf_rule *r,
    struct node_if *interface, struct node_proto *protos,
    struct node_host *src_hosts, struct node_port *src_ports,
    struct node_host *dst_hosts, struct node_port *dst_ports,
    struct node_icmp *icmp_types)
{
	struct node_proto *proto;
	struct node_icmp *icmp_type;

	proto = protos;
	while (proto != NULL) {
		icmp_type = icmp_types;
		while (icmp_type != NULL) {
			expand_rule_hosts(r, interface, proto, src_hosts,
			    src_ports, dst_hosts, dst_ports, icmp_type);
			icmp_type = icmp_type->next;
		}
		proto = proto->next;
	}
}
d1424 1
d1427 1
a1427 1
	struct node_if *interface;
d1435 2
d1439 71
a1509 6
	interface = interfaces;
	while (interface != NULL) {
		expand_rule_protos(r, interface, protos, src_hosts,
		    src_ports, dst_hosts, dst_ports, icmp_types);
		interface = interface->next;
	}
d1517 2
a1519 1
	
d1524 1
d1545 1
d1577 1
@


1.60
log
@Allow explicit filtering of fragments when they are not reassembled.
Document fragment handling in the man page. Short version: if you're
scrubbing everything (as is recommended, in general), nothing changes.
If you want to deal with fragments manually, read the man page.
ok frantzen.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.59 2002/04/18 06:02:18 deraadt Exp $	*/
d71 1
a71 1
	struct pf_addr		 addr;
d476 10
a485 1
address		: STRING			{
d501 2
a502 1
					memcpy(&$$->addr, &sin->sin_addr,
d514 2
a515 1
					memcpy(&$$->addr, &sin6->sin6_addr,
d533 2
a534 1
					memcpy(&$$->addr, hp->h_addr,
d542 3
a544 1
				memcpy(&$$->addr, hp->h_addr, sizeof(u_int32_t));
d558 2
a559 1
			$$->addr.addr32[0] = htonl(($1 << 24) |
d837 1
a837 1
natrule		: no NAT interface proto FROM ipspec TO ipspec redirection
d854 4
a857 3
			if ($4 != NULL) {
				nat.proto = $4->proto;
				free($4);
d859 1
a859 1
			if ($6 != NULL && $8 != NULL && $6->af != $8->af) {
d863 15
a877 3
			if ($6 != NULL) {
				nat.af = $6->af;
				memcpy(&nat.saddr, &$6->addr,
d879 1
a879 1
				memcpy(&nat.smask, &$6->mask,
d881 2
a882 2
				nat.snot = $6->not;
				free($6);
d884 15
a898 3
			if ($8 != NULL) {
				nat.af = $8->af;
				memcpy(&nat.daddr, &$8->addr,
d900 1
a900 1
				memcpy(&nat.dmask, &$8->mask,
d902 2
a903 2
				nat.dnot = $8->not;
				free($8);
d907 1
a907 1
				if ($9 != NULL) {
d912 1
a912 1
				if ($9 == NULL || $9->address == NULL) {
d916 9
a924 1
				if (nat.af && $9->address->af != nat.af) {
d928 2
a929 2
				nat.af = $9->address->af;
				memcpy(&nat.raddr, &$9->address->addr,
d931 2
a932 2
				free($9->address);
				free($9);
d939 1
a939 1
binatrule	: no BINAT interface proto FROM address TO ipspec redirection
d955 4
a958 3
			if ($4 != NULL) {
				binat.proto = $4->proto;
				free($4);
d960 1
a960 1
			if ($6 != NULL && $8 != NULL && $6->af != $8->af) {
d964 15
a978 3
			if ($6 != NULL) {
				binat.af = $6->af;
				memcpy(&binat.saddr, &$6->addr,
d980 1
a980 1
				free($6);
d982 15
a996 3
			if ($8 != NULL) {
				binat.af = $8->af;
				memcpy(&binat.daddr, &$8->addr,
d998 1
a998 1
				memcpy(&binat.dmask, &$8->mask,
d1000 2
a1001 2
				binat.dnot  = $8->not;
				free($8);
d1005 1
a1005 1
				if ($9 != NULL) {
d1011 1
a1011 1
				if ($9 == NULL || $9->address == NULL) {
d1016 9
a1024 1
				if (binat.af && $9->address->af != binat.af) {
d1028 2
a1029 2
				binat.af = $9->address->af;
				memcpy(&binat.raddr, &$9->address->addr,
d1031 2
a1032 2
				free($9->address);
				free($9);
d1038 1
a1038 1
rdrrule		: no RDR interface proto FROM ipspec TO ipspec dport redirection
d1055 3
a1057 3
			if ($4 != NULL) {
				rdr.proto = $4->proto;
				free($4);
d1059 1
a1059 1
			if ($6 != NULL && $8 != NULL && $6->af != $8->af) {
d1063 15
a1077 3
			if ($6 != NULL) {
				rdr.af = $6->af;
				memcpy(&rdr.saddr, &$6->addr,
d1079 1
a1079 1
				memcpy(&rdr.smask, &$6->mask,
d1081 2
a1082 2
				rdr.snot  = $6->not;
				free($6);
d1084 15
a1098 3
			if ($8 != NULL) {
				rdr.af = $8->af;
				memcpy(&rdr.daddr, &$8->addr,
d1100 1
a1100 1
				memcpy(&rdr.dmask, &$8->mask,
d1102 2
a1103 2
				rdr.dnot  = $8->not;
				free($8);
d1106 3
a1108 3
			rdr.dport  = $9.a;
			rdr.dport2 = $9.b;
			rdr.opts  |= $9.t;
d1111 1
a1111 1
				if ($10 != NULL) {
d1116 1
a1116 1
				if ($10 == NULL || $10->address == NULL) {
d1120 9
a1128 1
				if (rdr.af && $10->address->af != rdr.af) {
d1132 2
a1133 2
				rdr.af = $10->address->af;
				memcpy(&rdr.raddr, &$10->address->addr,
d1135 4
a1138 4
				free($10->address);
				rdr.rport  = $10->rport.a;
				rdr.opts  |= $10->rport.t;
				free($10);
d1180 6
a1185 1
			$$.addr = &$4->addr;
d1196 6
a1201 1
			$$.addr = &$4->addr;
d1305 5
d1766 2
a1767 1
			memcpy (&node->addr, &addr, sizeof(addr));
d1827 2
a1828 1
	x != '!' && x != '=' && x != '/' && x != '#' && x != ',' && x != ':'))
@


1.59
log
@use strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.58 2002/04/17 19:06:18 dhartmei Exp $	*/
d175 1
a175 1
%token	NOROUTE
d181 1
a181 1
%type	<v.i>	no dir log quick af keep nodf allowopts
d216 1
a216 1
pfrule		: action dir log quick interface route af proto fromto flags icmpspec keep nodf minttl allowopts label
d243 2
d246 3
a248 3
			if ($14)
				r.min_ttl = $14;
			r.allow_opts = $15;
d271 2
a272 2
			if ($16) {
				if (strlen($16) >= PF_RULE_LABEL_SIZE) {
d277 2
a278 2
				strlcpy(r.label, $16, sizeof(r.label));
				free($16);
d761 3
d1134 4
d1182 5
d1385 1
@


1.58
log
@Reset lineno for each file, so pfctl -R ... -N ... reports the right
line number for non-first files. Reported by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.57 2002/03/27 18:16:22 mickey Exp $	*/
d275 1
a275 1
				strcpy(r.label, $16);
@


1.57
log
@implement a "no-route" keyword.
usage semantics are analogous w/ "any", meaning is
"any ip address for which there is no route in the
current routing table", could be used in both from and to.
typical usage would be (assuming symmetrical routing):
block in from no-route to any
also doc "any" in the pf.conf.5, include in regress, etc.
tested by me on i386 and sparc.
dhartmei@@ and frantzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.56 2002/02/27 18:11:45 dhartmei Exp $	*/
d1716 1
d1728 1
@


1.56
log
@Instead of printing useless @@0 rule numbers from pfctl -vR, increase a
counter. Helps debugging rule sets that are not loaded. Suggested by
John Kerbawy.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.55 2002/01/11 22:26:41 mickey Exp $	*/
d75 1
d175 1
d442 6
d1224 1
d1231 1
d1386 1
@


1.55
log
@use bsearch() for keywords lookup, swap couple of entries to make the keywords array sorted and add a comment to keep it that way; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.54 2002/01/10 17:02:39 hugh Exp $	*/
d1268 2
a1269 1
					else
d1271 1
@


1.54
log
@Let port 0 be specified as it's not special here.
Agreement with Daniel and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.53 2002/01/09 18:00:57 mpech Exp $	*/
d1168 5
d1339 7
d1348 2
a1349 5
	int i;
	struct keywords {
		char	*k_name;
		int	 k_val;
	} keywords[] = {
d1357 1
a1358 1
		{ "fastroute",	FASTROUTE},
a1360 1
		{ "ipv6-icmp-type", ICMP6TYPE},
d1364 1
a1388 1
		{ NULL,		0 },
d1390 1
d1392 11
a1402 7
	for (i = 0; keywords[i].k_name != NULL; i++) {
		if (strcmp(s, keywords[i].k_name) == 0) {
			if (debug > 1)
				fprintf(stderr, "%s: %d\n", s,
				    keywords[i].k_val);
			return (keywords[i].k_val);
		}
a1403 3
	if (debug > 1)
		fprintf(stderr, "string: %s\n", s);
	return (STRING);
@


1.53
log
@Port must be >0 and <=65535. Idea while have fun with ssh.

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.52 2002/01/09 12:39:42 mpech Exp $	*/
d578 1
a578 1
			if ($1 <= 0 || $1 > 65535) {
@


1.52
log
@free() 'interface' in {nat,binat,rdr}rule

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.51 2002/01/09 11:30:53 dhartmei Exp $	*/
d578 1
a578 1
			if (0 > $1 || $1 > 65535) {
@


1.51
log
@Add labels to rules. These are arbitrary names (not to be confused with
tags that will be used to tag packets later on). Add pfctl -z to clear
per-rule counters. Add pfctl -s labels to output per-rule counters in
terse format and only for rules that have labels. Suggested by
Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.50 2002/01/08 09:31:55 dhartmei Exp $	*/
d824 1
d892 1
d959 1
@


1.50
log
@Add "no nat/rdr/binat" to nat.conf. The first matching rule applies.
If it is a "no" rule, no translation occurs. Useful to exclude certain
packets from translation. Suggested by Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.49 2002/01/07 17:23:31 mpech Exp $	*/
d173 1
a173 1
%token	MINTTL IPV6ADDR ERROR ALLOWOPTS FASTROUTE ROUTETO DUPTO NO
d190 1
d214 1
a214 1
pfrule		: action dir log quick interface route af proto fromto flags icmpspec keep nodf minttl allowopts
d267 10
d768 9
d1354 1
@


1.49
log
@remove 3rd argument from ipmask(), not used.

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.48 2001/12/23 03:50:03 deraadt Exp $	*/
d140 1
a140 1
		struct {
d160 4
d173 1
a173 1
%token	MINTTL IPV6ADDR ERROR ALLOWOPTS FASTROUTE ROUTETO DUPTO
d179 1
a179 1
%type	<v.i>	dir log quick af keep nodf allowopts
d189 1
d757 33
a789 1
natrule		: NAT interface proto FROM ipspec TO ipspec ARROW address
d799 3
a801 2
			if ($2 != NULL) {
				memcpy(nat.ifname, $2->ifname,
d803 1
a803 1
				nat.ifnot = $2->not;
d805 3
a807 3
			if ($3 != NULL) {
				nat.proto = $3->proto;
				free($3);
d809 1
a809 1
			if ($5 != NULL && $7 != NULL && $5->af != $7->af) {
d813 3
a815 3
			if ($5 != NULL) {
				nat.af = $5->af;
				memcpy(&nat.saddr, &$5->addr,
d817 1
a817 1
				memcpy(&nat.smask, &$5->mask,
d819 2
a820 2
				nat.snot = $5->not;
				free($5);
d822 3
a824 3
			if ($7 != NULL) {
				nat.af = $7->af;
				memcpy(&nat.daddr, &$7->addr,
d826 1
a826 1
				memcpy(&nat.dmask, &$7->mask,
d828 2
a829 2
				nat.dnot = $7->not;
				free($7);
d832 19
a850 3
			if ($9 == NULL) {
				yyerror("nat rule requires redirection address");
				YYERROR;
d852 1
a852 8
			/* we don't support IPv4 <-> IPv6 nat... yet */
			if (nat.af && $9->af != nat.af) {
				yyerror("nat ip versions must match");
				YYERROR;
			}
			nat.af = $9->af;
			memcpy(&nat.raddr, &$9->addr, sizeof(nat.raddr));
			free($9);
d857 1
a857 1
binatrule	: BINAT interface proto FROM address TO ipspec ARROW address
d867 3
a869 2
			if ($2 != NULL) {
				memcpy(binat.ifname, $2->ifname,
d872 3
a874 3
			if ($3 != NULL) {
				binat.proto = $3->proto;
				free($3);
d876 1
a876 1
			if ($5 != NULL && $7 != NULL && $5->af != $7->af) {
d880 3
a882 3
			if ($5 != NULL) {
				binat.af = $5->af;
				memcpy(&binat.saddr, &$5->addr,
d884 1
a884 1
				free($5);
d886 3
a888 3
			if ($7 != NULL) {
				binat.af = $7->af;
				memcpy(&binat.daddr, &$7->addr,
d890 1
a890 1
				memcpy(&binat.dmask, &$7->mask,
d892 2
a893 2
				binat.dnot  = $7->not;
				free($7);
d896 21
a916 3
			if ($9 == NULL) {
				yyerror("binat rule requires redirection address");
				YYERROR;
d918 1
a918 8
			/* we don't support IPv4 <-> IPv6 binat... yet */
			if (binat.af && $9->af != binat.af) {
				yyerror("binat ip versions must match");
				YYERROR;
			}
			binat.af = $9->af;
			memcpy(&binat.raddr, &$9->addr, sizeof(binat.raddr));
			free($9);
d922 1
a922 1
rdrrule		: RDR interface proto FROM ipspec TO ipspec dport ARROW address rport
d932 3
a934 2
			if ($2 != NULL) {
				memcpy(rdr.ifname, $2->ifname,
d936 1
a936 1
				rdr.ifnot = $2->not;
d938 3
a940 3
			if ($3 != NULL) {
				rdr.proto = $3->proto;
				free($3);
d942 1
a942 1
			if ($5 != NULL && $7 != NULL && $5->af != $7->af) {
d946 3
a948 3
			if ($5 != NULL) {
				rdr.af = $5->af;
				memcpy(&rdr.saddr, &$5->addr,
d950 1
a950 1
				memcpy(&rdr.smask, &$5->mask,
d952 2
a953 2
				rdr.snot  = $5->not;
				free($5);
d955 3
a957 3
			if ($7 != NULL) {
				rdr.af = $7->af;
				memcpy(&rdr.daddr, &$7->addr,
d959 1
a959 1
				memcpy(&rdr.dmask, &$7->mask,
d961 2
a962 2
				rdr.dnot  = $7->not;
				free($7);
d965 3
a967 3
			rdr.dport  = $8.a;
			rdr.dport2 = $8.b;
			rdr.opts  |= $8.t;
d969 21
a989 3
			if ($10 == NULL) {
				yyerror("rdr rule requires redirection address");
				YYERROR;
a990 10
			if (rdr.af && $10->af != rdr.af) {
				yyerror("rdr ip versions must match");
				YYERROR;
			}
			rdr.af = $10->af;
			memcpy(&rdr.raddr, &$10->addr, sizeof(rdr.raddr));
			free($10);

			rdr.rport  = $11.a;
			rdr.opts  |= $11.t;
a1016 14
rport		: /* empty */			{
			$$.a = $$.b = $$.t = 0;
		}
		| PORT port			{
			$$.a = $2;
			$$.b = $$.t = 0;
		}
		| PORT port ':' '*'		{
			$$.a = $2;
			$$.b = 0;
			$$.t = PF_RPORT_RANGE;
		}
		;

d1339 1
@


1.48
log
@find correct line number in lval, instead of val
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.47 2001/12/10 18:08:12 dhartmei Exp $	*/
d99 1
a99 1
void		 	 ipmask(struct pf_addr *, u_int8_t, int);
d429 1
a429 1
				ipmask(&$$->mask, 32, AF_INET); 
d431 1
a431 1
				ipmask(&$$->mask, 128, AF_INET6);
d446 1
a446 1
			ipmask(&$$->mask, $3, $$->af);
d1631 1
a1631 1
ipmask(struct pf_addr *m, u_int8_t b, int af)
@


1.47
log
@Add stateful filtering for other (non-TCP/UDP/ICMP) protocol, based on
source/destination addresses/ports only.
Add RDR for ICMP. Add NAT/RDR/BINAT for other protocols.
Destination and redirection port(s) are now optional for RDR rules.
Not specifying destination port(s) means 'redirect all ports', not
specifying redirection port(s) means 'redirect to the original port'.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.46 2001/12/05 17:11:54 dhartmei Exp $	*/
d1007 1
a1007 1
	fprintf(stderr, "%s:%d: ", infile, yyval.lineno);
@


1.46
log
@Correctly parse hex numbers. Spotted by Claudio Jeker. Closes PR 2234.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.45 2001/12/03 21:52:08 dhartmei Exp $	*/
d924 7
d935 4
a938 1
dport		: PORT port			{
d949 4
a952 1
rport		: PORT port			{
@


1.45
log
@For nat, binat and rdr rules, don't allow different address families in
one rule. pf can't translate IPv4 <-> IPv6 packets. Such rules didn't work,
even if they were falsely accepted before.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.44 2001/11/26 16:50:25 jasoni Exp $	*/
d1534 1
a1534 1
					c -= 'a';
d1536 1
a1536 1
					c -= 'A';
@


1.44
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.43 2001/11/05 09:28:00 deraadt Exp $	*/
d771 3
a773 10
			if ($5 != NULL && $7 != NULL) {
				if ($5->af && $7->af && $5->af != $7->af) {
					yyerror("nat ip versions must match");
					YYERROR;
				} else {
					if ($5->af)
						nat.af = $5->af;
					else if ($7->af)
						nat.af = $7->af;
				}
d776 1
d781 1
a781 1
				nat.snot  = $5->not;
d785 1
d790 1
a790 1
				nat.dnot  = $7->not;
d802 2
a803 2
			} else
				nat.af = $9->af;
d828 3
a830 10
			if ($5 != NULL && $7 != NULL) {
				if ($5->af && $7->af && $5->af != $7->af) {
					yyerror("binat ip versions must match");
					YYERROR;
				} else {
					if ($5->af)
						binat.af = $5->af;
					else if ($7->af)
						binat.af = $7->af;
				}
d833 1
d839 1
d856 2
a857 2
			} else
				binat.af = $9->af;
d882 3
a884 10
			if ($5 != NULL && $7 != NULL) {
				if ($5->af && $7->af && $5->af != $7->af) {
					yyerror("rdr ip versions must match");
					YYERROR; 
				} else {
					if ($5->af)
						rdr.af = $5->af;
					else if ($7->af)
						rdr.af = $7->af;
				}
d887 1
d896 1
d916 2
a917 2
			} else 
				rdr.af = $10->af;
@


1.43
log
@noone responds.
this diff makes } and { not be part of symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.42 2001/10/24 09:18:35 dhartmei Exp $	*/
d154 6
d169 1
a169 1
%token	MINTTL IPV6ADDR ERROR ALLOWOPTS
d184 1
d208 1
a208 1
pfrule		: action dir log quick interface af proto fromto flags icmpspec keep nodf minttl allowopts
a226 3
			r.af = $6;
			r.flags = $9.b1;
			r.flagset = $9.b2;
d228 5
a232 1
			r.keep_state = $11;
d234 1
a234 1
			if ($12)
d236 24
a259 3
			if ($13)
				r.min_ttl = $13;
			r.allow_opts = $14;
d261 2
a262 2
			expand_rule(&r, $5, $7, $8.src.host, $8.src.port,
			    $8.dst.host, $8.dst.port, $10);
d964 35
d1148 22
a1169 5

					if (src_host->af &&
					    dst_host->af && 
					    (src_host->af !=
					    dst_host->af)) {
d1173 1
a1173 1
					} else if (src_host->af)
d1175 4
a1178 3
					else if (dst_host->af)
						r->af = dst_host->af;

d1272 1
d1274 1
d1299 1
d1583 1
a1583 1
	x != '!' && x != '=' && x != '/' && x != '#' && x != ','))
@


1.42
log
@Check interface names using ifa0_lookup() and print error message for
non-existant interfaces (instead of the generic ioctl error returned by
the kernel in this case).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2001/10/15 16:22:22 dhartmei Exp $	*/
d1496 3
a1498 2
	isalnum(x) || (ispunct(x) && x != '(' && x != ')' && x != '<' && \
	x != '>' && x != '!' && x != '=' && x != '/' && x != '#' && x != ',')
@


1.41
log
@Add 'allow-opts' to rules. Packets with IP options will be blocked by
default now, and can be allowed per rule. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.40 2001/10/11 22:03:12 frantzen Exp $	*/
d311 4
@


1.41.2.1
log
@Pull in patches from current:
Fix (dhartmei, deraadt):
-- Correctly parse hex numbers. Spotted by Claudio Jeker. Closes PR 2234.
-- For nat, binat and rdr rules, don't allow different address families in
one rule. pf can't translate IPv4 <-> IPv6 packets. Such rules didn't work,
even if they were falsely accepted before.
-- noone responds.  this diff makes } and { not be part of symbols
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.41 2001/10/15 16:22:22 dhartmei Exp $	*/
d738 10
a747 3
			if ($5 != NULL && $7 != NULL && $5->af != $7->af) {
				yyerror("nat ip versions must match");
				YYERROR;
a749 1
				nat.af = $5->af;
d754 1
a754 1
				nat.snot = $5->not;
a757 1
				nat.af = $7->af;
d762 1
a762 1
				nat.dnot = $7->not;
d774 2
a775 2
			}
			nat.af = $9->af;
d800 10
a809 3
			if ($5 != NULL && $7 != NULL && $5->af != $7->af) {
				yyerror("binat ip versions must match");
				YYERROR;
a811 1
				binat.af = $5->af;
a816 1
				binat.af = $7->af;
d833 2
a834 2
			}
			binat.af = $9->af;
d859 10
a868 3
			if ($5 != NULL && $7 != NULL && $5->af != $7->af) {
				yyerror("rdr ip versions must match");
				YYERROR;
a870 1
				rdr.af = $5->af;
a878 1
				rdr.af = $7->af;
d898 2
a899 2
			}
			rdr.af = $10->af;
d1460 1
a1460 1
					c -= 'a' - 10;
d1462 1
a1462 1
					c -= 'A' - 10;
d1492 2
a1493 3
	(isalnum(x) || (ispunct(x) && x != '(' && x != ')' && \
	x != '{' && x != '}' && x != '<' && x != '>' && \
	x != '!' && x != '=' && x != '/' && x != '#' && x != ','))
@


1.40
log
@Don't htonl() past buffer bounds if ipmask == 128
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.39 2001/10/07 11:56:57 dhartmei Exp $	*/
d163 1
a163 1
%token	MINTTL IPV6ADDR ERROR
d169 1
a169 1
%type	<v.i>	dir log quick af keep nodf
d201 1
a201 1
pfrule		: action dir log quick interface af proto fromto flags icmpspec keep nodf minttl
d230 1
d716 3
d1018 4
d1181 1
@


1.39
log
@Add interface name to address translation to pfctl, document it and add
a regress test. Translation is done on rule set load-time only, so the
rule sets must be reloaded when an interface address changes.
parse.y patch from Cedric Berger. Similar patch from Jonathon Fletcher.
Thanks to both.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.38 2001/10/01 17:58:16 markus Exp $	*/
d1544 2
a1545 1
	m->addr32[j] = htonl(m->addr32[j]);
@


1.38
log
@print variable asignments only if -v is given. ok dhartmei/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.37 2001/09/28 14:12:15 dhartmei Exp $	*/
d41 2
d126 4
d418 20
d439 14
a452 1
			if ((hp = gethostbyname2($1, AF_INET)) == NULL) {
d1597 97
@


1.37
log
@Support underscores in macro names and document it in the man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.36 2001/09/20 18:31:44 dhartmei Exp $	*/
d186 2
a187 1
			printf("%s = %s\n", $1, $3);
@


1.36
log
@Fix uninitialized structure fields. Problem reported by Cedric Berger.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.35 2001/09/15 23:23:40 wilfried Exp $	*/
d1275 1
a1275 1
			if (isalnum(c)) {
@


1.35
log
@Implement return-icmp(number), return-icmp6(number)
Differentiate between return-icmp and return-icmp6,
icmp-type and ipv6-icmp-type. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.34 2001/09/15 21:49:19 dhartmei Exp $	*/
d229 1
a229 1
action		: PASS			{ $$.b1 = PF_PASS; }
d231 1
a231 1
		| SCRUB			{ $$.b1 = PF_SCRUB; }
@


1.34
log
@Fix 'binat ... to any ...' (binat.af wasn't set).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.33 2001/09/15 11:21:50 dhartmei Exp $	*/
d245 4
d253 1
a253 1
			    IPPROTO_ICMP)) == NULL) {
d260 4
d268 1
a268 1
			    IPPROTO_ICMPV6)) == NULL) {
d570 1
a570 1
			    IPPROTO_ICMP)) == NULL) {
d610 1
a610 1
			    IPPROTO_ICMPV6)) == NULL) {
d623 1
a623 1
			if ((p = geticmptypebyname($1, IPPROTO_ICMP)) == NULL) {
d641 1
a641 2
			if ((p = geticmptypebyname($1,
			    IPPROTO_ICMPV6)) == NULL) {
d961 6
@


1.33
log
@Parse bug, found by wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.32 2001/09/15 03:54:40 frantzen Exp $	*/
d751 1
a751 1
					yyerror("nat ip versions must match");
d778 6
@


1.32
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.31 2001/09/12 16:37:14 markus Exp $	*/
d549 2
a550 2
			$$->code = $1;
			$$->type = $3 + 1;
@


1.31
log
@check calloc() return value
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.30 2001/09/06 22:37:08 jasoni Exp $	*/
d36 1
d69 3
a71 2
	u_int32_t		 addr;
	u_int32_t		 mask;
d82 7
d97 1
a97 1
u_int32_t		 ipmask(u_int8_t);
d101 2
a102 1
			    struct node_host *, struct node_port *);
d106 2
a107 1
			    struct node_host *, struct node_port *);
d111 2
a112 1
			    struct node_host *, struct node_port *);
d141 1
d155 5
a159 4
%token	RETURNRST RETURNICMP PROTO ALL ANY ICMPTYPE CODE KEEP MODULATE STATE
%token	PORT RDR NAT ARROW NODF MINTTL ERROR BINAT
%token	<v.string>	STRING
%token	<v.number>	NUMBER
d162 3
a164 3
%type	<v.number>	port icmptype minttl
%type	<v.i>	dir log quick keep nodf
%type	<v.b>	action icmpspec flag flags blockspec
d167 1
d170 1
a170 1
%type	<v.host>	ipspec xhost host address host_list
d194 1
a194 1
pfrule		: action dir log quick interface proto fromto flags icmpspec keep nodf minttl
d213 3
a215 5
			r.flags = $8.b1;
			r.flagset = $8.b2;
			r.type = $9.b1;
			r.code = $9.b2;
			r.keep_state = $10;
d217 3
a219 1
			if ($11)
d221 2
a222 2
			if ($12)
				r.min_ttl = $12;
d224 2
a225 2
			expand_rule(&r, $5, $6, $7.src.host, $7.src.port,
			    $7.dst.host, $7.dst.port);
d240 5
d248 13
a260 1
			if ((p = geticmpcodebyname(ICMP_UNREACH, $3)) == NULL) {
d304 4
d379 4
a382 1
			$$->mask = 0xffffffff;
d385 10
a394 3
			if ($3 < 0 || $3 > 32) {
				yyerror("illegal netmask value %d", $3);
				YYERROR;
d397 1
a397 1
			$$->mask = ipmask($3);
d404 19
a422 3
			if ((hp = gethostbyname($1)) == NULL) {
				yyerror("cannot resolve %s", $1);
				YYERROR;
a423 4
			$$ = calloc(1, sizeof(struct node_host));
			if ($$ == NULL)
				err(1, "address: calloc");
			memcpy(&$$->addr, hp->h_addr, sizeof(u_int32_t));
d435 3
a437 1
			$$->addr = htonl(($1 << 24) | ($3 << 16) | ($5 << 8) | $7);
d439 1
d517 30
a546 5
icmpspec	: /* empty */			{ $$.b1 = 0; $$.b2 = 0; }
		| ICMPTYPE icmptype		{ $$.b1 = $2; $$.b2 = 0; }
		| ICMPTYPE icmptype CODE NUMBER	{
			if ($4 < 0 || $4 > 255) {
				yyerror("illegal icmp code %d", $4);
d549 4
a552 2
			$$.b1 = $2;
			$$.b2 = $4 + 1;
d554 1
a554 1
		| ICMPTYPE icmptype CODE STRING	{
d557 7
a563 3
			$$.b1 = $2;
			if ((p = geticmpcodebyname($2, $4)) == NULL) {
				yyerror("unknown icmp-code %s", $4);
d566 43
a608 1
			$$.b2 = p->code + 1;
d615 1
a615 1
			if ((p = geticmptypebyname($1)) == NULL) {
d630 18
d687 11
d699 4
a702 2
				nat.saddr = $5->addr;
				nat.smask = $5->mask;
d707 4
a710 2
				nat.daddr = $7->addr;
				nat.dmask = $7->mask;
d719 7
a725 1
			nat.raddr = $9->addr;
d749 11
d761 2
a762 1
				binat.saddr = $5->addr;
d766 4
a769 2
				binat.daddr = $7->addr;
				binat.dmask = $7->mask;
d778 1
a778 1
			binat.raddr = $9->addr;
d802 11
d814 4
a817 2
				rdr.saddr = $5->addr;
				rdr.smask = $5->mask;
d822 4
a825 2
				rdr.daddr = $7->addr;
				rdr.dmask = $7->mask;
d838 6
a843 1
			rdr.raddr = $10->addr;
d936 2
a937 1
	if (r->proto != IPPROTO_ICMP && (r->type || r->code)) {
d941 9
d981 2
a982 1
    struct node_host *dst_hosts, struct node_port *dst_ports)
d986 1
d1011 22
a1032 1
					if (rule_consistent(r) < 0)
d1050 2
a1051 1
    struct node_host *dst_hosts, struct node_port *dst_ports)
d1054 1
d1058 6
a1063 2
		expand_rule_hosts(r, interface, proto, src_hosts,
		    src_ports, dst_hosts, dst_ports);
d1072 2
a1073 1
    struct node_host *dst_hosts, struct node_port *dst_ports)
d1083 1
d1088 1
a1088 1
		    src_ports, dst_hosts, dst_ports);
d1098 2
d1121 1
d1123 2
d1141 1
d1342 36
d1474 2
a1475 2
u_int32_t
ipmask(u_int8_t b)
d1477 1
a1477 2
	u_int32_t m = 0;
	int i;
d1479 4
d1484 2
a1485 2
		m |= (1 << i);
	return (htonl(m));
@


1.30
log
@- you can only binat between hosts
- add binat example and description
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.29 2001/09/06 18:05:46 jasoni Exp $	*/
d363 2
d375 2
@


1.29
log
@1:1 bidrectional NAT (binat); ok dhartmei@@ and frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.28 2001/09/04 13:47:51 dhartmei Exp $	*/
d554 1
a554 1
binatrule	: BINAT interface proto FROM ipspec TO ipspec ARROW address
@


1.28
log
@Support parameter lists {} for interfaces in filter rules, like
pass in on { gm0, kue0 } from any to any
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.27 2001/08/28 12:17:04 markus Exp $	*/
d143 1
a143 1
%token	PORT RDR NAT ARROW NODF MINTTL ERROR
d163 1
d554 38
d861 1
@


1.27
log
@move '!' from host_list to host:  "xhost : '!' host | host;"; ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.26 2001/08/28 09:54:14 markus Exp $	*/
d56 6
d89 10
a98 1
void			 expand_rule(struct pf_rule *, struct node_proto *,
a117 4
			char		*string;
			int		not;
		}			iface;
		struct {
d127 1
d144 2
a145 2
%token	<v.string> STRING
%token	<v.number> NUMBER
d147 2
a148 2
%type	<v.iface> iface natiface
%type	<v.number> port icmptype minttl
d178 1
a178 1
pfrule		: action dir log quick iface proto fromto flags icmpspec keep nodf minttl
a195 2
			if ($5.string)
				memcpy(r.ifname, $5.string, sizeof(r.ifname));
d208 1
a208 1
			expand_rule(&r, $6, $7.src.host, $7.src.port,
d249 7
a255 7
natiface	: iface
		| ON '!' STRING			{
			$$.string = strdup($3);
			if ($$.string == NULL)
				err(1, "natiface: strdup");
			$$.not = 1;
		}
d257 11
a267 5
iface		: /* empty */			{ $$.string = NULL; }
		| ON STRING			{
			$$.string = strdup($2);
			if ($$.string == NULL)
				err(1, "iface: strdup");
d511 1
a511 1
natrule		: NAT natiface proto FROM ipspec TO ipspec ARROW address
d521 2
a522 2
			if ($2.string) {
				memcpy(nat.ifname, $2.string,
d524 1
a524 1
				nat.ifnot = $2.not;
d553 1
a553 1
rdrrule		: RDR natiface proto FROM ipspec TO ipspec dport ARROW address rport
d563 2
a564 2
			if ($2.string) {
				memcpy(rdr.ifname, $2.string,
d566 1
a566 1
				rdr.ifnot = $2.not;
d718 2
a719 2
void
expand_rule(struct pf_rule *r, struct node_proto *protos,
a722 1
	struct node_proto *proto;
d726 62
d794 5
a798 37
	proto = protos;
	while (proto != NULL) {
		src_host = src_hosts;
		while (src_host != NULL) {
			src_port = src_ports;
			while (src_port != NULL) {
				dst_host = dst_hosts;
				while (dst_host != NULL) {
					dst_port = dst_ports;
					while (dst_port != NULL) {
						r->proto = proto->proto;
						r->src.addr = src_host->addr;
						r->src.mask = src_host->mask;
						r->src.not = src_host->not;
						r->src.port[0] = src_port->port[0];
						r->src.port[1] = src_port->port[1];
						r->src.port_op = src_port->op;
						r->dst.addr = dst_host->addr;
						r->dst.mask = dst_host->mask;
						r->dst.not = dst_host->not;
						r->dst.port[0] = dst_port->port[0];
						r->dst.port[1] = dst_port->port[1];
						r->dst.port_op = dst_port->op;
						if (rule_consistent(r) < 0)
							yyerror("skipping rule "
							    "due to errors");
						else
							pfctl_add_rule(pf, r);
						dst_port = dst_port->next;
					}
					dst_host = dst_host->next;
				}
				src_port = src_port->next;
			}
			src_host = src_host->next;
		}
		proto = proto->next;
d801 1
@


1.26
log
@check for malloc/strdup == NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.25 2001/08/28 09:27:16 dhartmei Exp $	*/
d143 1
a143 1
%type	<v.host>	ipspec host address host_list
d312 1
a312 2
		| '!' host			{ $$ = $2; $$->not = 1; }
		| host				{ $$ = $1; }
d316 5
a320 1
host_list	: '!' host			{ $$ = $2; $$->not = 1; } 
d322 1
a322 6
		| host_list ',' '!' host	{
			$4->next = $1;
			$4->not = 1;
			$$ = $4;
		}
		| host_list ',' host		{ $3->next = $1; $$ = $3; }
@


1.25
log
@Support ! operator in host parameter lists. Fixes PR system/2030. Reported
by Kamil Andrusz <wizz@@mniam.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.24 2001/08/26 07:58:40 deraadt Exp $	*/
d241 4
a244 1
			$$.string = strdup($3); $$.not = 1;
d248 5
a252 1
		| ON STRING			{ $$.string = strdup($2); }
d272 2
d285 2
d372 2
d381 2
d390 2
d688 2
d926 2
d952 2
d1061 2
@


1.24
log
@sort keywords
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.23 2001/08/25 21:54:26 frantzen Exp $	*/
d302 1
a302 1
		| host				{ $$ = $1; $$->not = 0; }
d306 7
a312 1
host_list	: host				{ $$ = $1; }
@


1.23
log
@PF ISN randomization.  Or in trekkie techno-babble, ISN phase modulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.22 2001/08/23 05:36:53 millert Exp $	*/
d762 1
a763 1
		{ "min-ttl",	MINTTL},
@


1.22
log
@o for a port_item, initialize the "next" pointer to NULL
o for an address, use calloc() instead of malloc() so the struct is zeroed
Fixes a SEGV in pfctl due to uninitialized "next" pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.21 2001/08/23 04:14:20 deraadt Exp $	*/
d130 2
a131 2
%token	RETURNRST RETURNICMP PROTO ALL ANY ICMPTYPE CODE KEEP STATE PORT
%token	RDR NAT ARROW NODF MINTTL ERROR
d456 2
a457 1
		| KEEP STATE			{ $$ = 1; }
d614 5
a618 1
		if (r->keep_state) {
d653 5
d762 1
@


1.21
log
@Support var="string".  Expansion (at lex time) done using $var, for instance:
    okproto="{ssh, smtp, domain, auth}"
    pass in on key0 proto tcp from any to any port $okproto keep state
Can I ask someone else to document this in pf.conf(5)?
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.20 2001/08/19 16:16:41 dhartmei Exp $	*/
d330 1
a330 1
			$$ = malloc(sizeof(struct node_host));
d340 1
a340 1
			$$ = malloc(sizeof(struct node_host));
d358 1
d365 1
d372 1
@


1.20
log
@Add parameter list support to parser. Handles lists for protocol, hosts
and ports in filter rules, like

  block in from { 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 } to any
  pass in proto tcp from any to any port { ssh, 1024 >< 2000, > 65000 }
  block in proto { udp, igmp }

and does rule expansion (generate all needed rule combinations).
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.19 2001/08/16 11:46:56 deraadt Exp $	*/
d87 10
d137 1
a137 1
%type	<v.i>	direction log quick keep nodf
d147 1
a147 1
ruleset:	/* empty */
d152 1
d156 11
a166 1
pfrule:		action direction log quick iface proto fromto flags icmpspec keep nodf minttl
d203 1
a203 1
action:		PASS			{ $$.b1 = PF_PASS; }
d208 1
a208 1
blockspec:				{ $$.b2 = 0; $$.w = 0; }
d226 2
a227 2
direction:	IN			{ $$ = PF_IN; }
		| OUT			{ $$ = PF_OUT; }
d230 3
a232 3
log:					{ $$ = 0; }
		| LOG			{ $$ = 1; }
		| LOGALL		{ $$ = 2; }
d235 2
a236 2
quick:					{ $$ = 0; }
		| QUICK			{ $$ = 1; }
d239 2
a240 2
natiface:	iface
		| ON '!' STRING		{
d244 2
a245 2
iface:					{ $$.string = NULL; }
		| ON STRING		{ $$.string = strdup($2); }
d248 1
a248 1
proto:						{ $$ = NULL; }
d253 1
a253 1
proto_list:	proto_item			{ $$ = $1; }
d257 1
a257 1
proto_item:	NUMBER			{
d268 1
a268 1
		| STRING		{
d281 1
a281 1
fromto:		ALL			{
d293 2
a294 2
ipportspec:	ipspec			{ $$.host = $1; $$.port = NULL; }
		| ipspec PORT portspec	{
d300 4
a303 4
ipspec:		ANY			{ $$ = NULL; }
		| '!' host		{ $$ = $2; $$->not = 1; }
		| host			{ $$ = $1; $$->not = 0; }
		| '{' host_list '}'	{ $$ = $2; }
d306 2
a307 2
host_list:	host			{ $$ = $1; }
		| host_list ',' host	{ $3->next = $1; $$ = $3; }
d309 1
a309 1
host:		address			{
d313 1
a313 1
		| address '/' NUMBER	{
d323 1
a323 1
address:	STRING {
d345 1
a345 1
portspec:	port_item			{ $$ = $1; }
d349 1
a349 1
port_list:	port_item			{ $$ = $1; }
d353 1
a353 1
port_item:	port				{
d373 1
a373 1
port:		NUMBER				{
d380 1
a380 1
		| STRING		{
d394 1
a394 1
flag:		STRING			{
d405 4
a408 4
flags:					{ $$.b1 = 0; $$.b2 = 0; }
		| FLAGS flag		{ $$.b1 = $2.b1; $$.b2 = 63; }
		| FLAGS flag "/" flag	{ $$.b1 = $2.b1; $$.b2 = $4.b1; }
		| FLAGS "/" flag	{ $$.b1 = 0; $$.b2 = $3.b1; }
d411 2
a412 2
icmpspec:				{ $$.b1 = 0; $$.b2 = 0; }
		| ICMPTYPE icmptype	{ $$.b1 = $2; $$.b2 = 0; }
d433 1
a433 1
icmptype:	STRING			{
d442 1
a442 1
		| NUMBER		{
d452 2
a453 2
keep:					{ $$ = 0; }
		| KEEP STATE		{ $$ = 1; }
d456 2
a457 2
minttl:					{ $$ = 0; }
		| MINTTL NUMBER		{
d466 2
a467 2
nodf:					{ $$ = 0; }
		| NODF			{ $$ = 1; }
d470 1
a470 1
natrule:	NAT natiface proto FROM ipspec TO ipspec ARROW address
a477 1

a507 1

d512 1
a512 1
rdrrule:	RDR natiface proto FROM ipspec TO ipspec dport ARROW address rport
a519 1

d562 1
a562 1
dport:		PORT port			{
d573 1
a573 1
rport:		PORT port			{
a582 1

d781 3
d790 11
d816 36
d854 2
a855 2
	char *p, buf[8096];
	int c, next;
d858 2
d862 1
a862 1
	
d867 22
a888 5
	if (c == '-') {
		next = lgetc(fin);
		if (next == '>')
			return (ARROW);
		ungetc(next, fin);
d890 1
d892 20
d921 1
a921 1
		ungetc(next, fin);
d932 1
a932 1
			ungetc(next, fin);
d945 1
a945 1
			ungetc(next, fin);
d949 6
d956 1
d958 3
d962 18
a979 3
		do {
			u_int64_t n = (u_int64_t)yylval.v.number * 10 + c - '0';
			if (n > 0xffffffff) {
d983 14
a996 3
			yylval.v.number = (u_int32_t)n;
		} while ((c = lgetc(fin)) != EOF && isdigit(c));
		ungetc(c, fin);
d1003 2
a1004 2
	isalnum(x) || (ispunct(x) && x != '(' && x != ')' && x != '<' \
	&& x != '>' && x != '!' && x != '=' && x != '/' && x != '#' && x != ',')
a1006 1
		p = buf;
d1014 1
a1014 1
		ungetc(c, fin);
d1072 39
@


1.19
log
@track the line number per-token, so that we can report errors correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.18 2001/08/14 16:25:45 mickey Exp $	*/
d56 22
a77 1
static int proto = 0;	/* this is a synthesized attribute */
d83 3
a91 4
		struct pf_rule_addr	*addr;
		struct {
			struct pf_rule_addr	*src, *dst;
		}			addr2;
d106 7
a124 2
%type	<v.addr>	ipportspec ipspec host portspec
%type	<v.addr2>	fromto
d126 2
a127 2
%type	<v.number> address port icmptype minttl
%type	<v.i>	direction log quick keep proto nodf
d130 5
a164 7
			r.proto = $6;
			proto = 0;	/* reset synthesized attribute */

			memcpy(&r.src, $7.src, sizeof(r.src));
			free($7.src);
			memcpy(&r.dst, $7.dst, sizeof(r.dst));
			free($7.dst);
d177 2
a178 4
			if (rule_consistent(&r) < 0)
				yyerror("skipping rule due to errors");
			else
				pfctl_add_rule(pf, &r);
d227 10
a236 2
proto:					{ $$ = proto; }
		| PROTO NUMBER		{
d239 2
a240 2
			if ((p = getprotobynumber($2)) == NULL) {
				yyerror("unknown protocol %d", $2);
d243 3
a245 1
			proto = $$ = p->p_proto;
d247 1
a247 1
		| PROTO STRING		{
d250 2
a251 2
			if ((p = getprotobyname($2)) == NULL) {
				yyerror("unknown protocol %s", $2);
d254 3
a256 1
			proto = $$ = p->p_proto;
d261 4
a264 2
			$$.src = new_addr();
			$$.dst = new_addr();
d266 1
a266 1
		| FROM ipportspec TO ipportspec {
d272 4
a275 9
ipportspec:	ipspec			{ $$ = $1; }
		| ipspec portspec		{
			$$ = $1;
			if ($2) {
				$$->port[0] = $2->port[0];
				$$->port[1] = $2->port[1];
				$$->port_op = $2->port_op;
				free($2);
			}
d279 1
a279 1
ipspec:		ANY			{ $$ = new_addr(); }
d281 2
a282 1
		| host			{ $$ = $1; }
d285 5
a289 3
host:		address		{
			$$ = new_addr();
			$$->addr = $1;
d292 1
a292 2
		|
		address '/' NUMBER	{
d297 1
a297 2
			$$ = new_addr();
			$$->addr = $1;
d305 3
a307 6
			if (inet_pton(AF_INET, $1, &$$) != 1) {
				if ((hp = gethostbyname($1)) == NULL) {
					yyerror("cannot resolve %s", $1);
					YYERROR;
				}
				memcpy(&$$, hp->h_addr, sizeof(u_int32_t));
d309 2
d319 2
a320 1
			$$ = (htonl(($1 << 24) | ($3 << 16) | ($5 << 8) | $7));
d324 13
a336 5
portspec:	PORT PORTUNARY port	{
			$$ = new_addr();
			$$->port_op = $2;
			$$->port[0] = $3;
			$$->port[1] = $3;
d338 2
a339 2
		| PORT port PORTBINARY port	{
			$$ = new_addr();
d341 8
a348 2
			$$->port_op = $3;
			$$->port[1] = $4;
d352 1
a352 1
port:		NUMBER			{
d362 6
a367 11
			/* use synthesized attribute */
			if (proto) {
				s = getservbyname($1,
				    proto == IPPROTO_TCP ? "tcp" : "udp");
				if (s == NULL) {
					yyerror("unknown protocol %s", $1);
					YYERROR;
				}
				$$ = s->s_port;
			} else {
				$$ = 0;
d369 1
d465 16
a480 2
			nat.proto = $3;
			proto = 0;	/* reset synthesized attribute */
d482 6
a487 11
			nat.saddr = $5->addr;
			nat.smask = $5->mask;
			nat.snot  = $5->not;
			free($5);

			nat.daddr = $7->addr;
			nat.dmask = $7->mask;
			nat.dnot  = $7->not;
			free($7);

			nat.raddr = $9;
d493 1
a493 1
rdrrule:	RDR { proto = IPPROTO_TCP; } natiface proto FROM ipspec TO ipspec dport ARROW address rport
d504 2
a505 2
			if ($3.string) {
				memcpy(rdr.ifname, $3.string,
d507 17
a523 1
				rdr.ifnot = $3.not;
a524 2
			rdr.proto = $4;
			proto = 0;	/* reset synthesized attribute */
d526 3
a528 4
			rdr.saddr = $6->addr;
			rdr.smask = $6->mask;
			rdr.snot  = $6->not;
			free($6);
d530 6
a535 10
			rdr.daddr = $8->addr;
			rdr.dmask = $8->mask;
			rdr.dnot  = $8->not;
			free($8);

			rdr.dport  = $9.a;
			rdr.dport2 = $9.b;
			rdr.opts  |= $9.t;

			rdr.raddr = $11;
d537 2
a538 2
			rdr.rport  = $12.a;
			rdr.opts  |= $12.t;
d631 82
d861 1
a861 1
	&& x != '>' && x != '!' && x != '=' && x != '/' && x != '#')
@


1.18
log
@optimize the flags parsing; markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.17 2001/08/11 09:54:59 deraadt Exp $	*/
d63 27
d91 1
a91 23
%union {
	u_int32_t		number;
	int			i;
	char			*string;
	struct pf_rule_addr	*addr;
	struct {
		struct pf_rule_addr	*src, *dst;
	}			addr2;
	struct {
		char		*string;
		int		not;
	}			iface;
	struct {
		u_int8_t	b1;
		u_int8_t	b2;
		u_int16_t	w;
	}			b;
	struct {
		int		a;
		int		b;
		int		t;
	}			range;
}
d95 10
a104 10
%token	<string> STRING
%token	<number> NUMBER
%token	<i>	PORTUNARY PORTBINARY
%type	<addr>	ipportspec ipspec host portspec
%type	<addr2>	fromto
%type	<iface> iface
%type	<number> address port icmptype minttl
%type	<i>	direction log quick keep proto nodf
%type	<b>	action icmpspec flag flags blockspec
%type	<range>	dport rport
d197 1
a197 2
iface:					{ $$.string = NULL; }
		| ON STRING		{ $$.string = strdup($2); }
a198 4
			if (! natmode) {
				yyerror("can't '!' interface in pf rule");
				YYERROR;
			}
d202 3
d408 1
a408 1
natrule:	NAT iface proto FROM ipspec TO ipspec ARROW address
d443 1
a443 1
rdrrule:	RDR { proto = IPPROTO_TCP; } iface proto FROM ipspec TO ipspec dport ARROW address rport
d517 1
a517 1
	fprintf(stderr, "%s:%d: ", infile, lineno);
d636 1
d653 1
d665 1
a665 1
		yylval.i = PF_OP_EQ;
d670 1
a670 1
			yylval.i = PF_OP_NE;
d678 1
a678 1
			yylval.i = PF_OP_XRG;
d681 1
a681 1
			yylval.i = PF_OP_LE;
d683 1
a683 1
			yylval.i = PF_OP_LT;
d691 1
a691 1
			yylval.i = PF_OP_IRG;
d694 1
a694 1
			yylval.i = PF_OP_GE;
d696 1
a696 1
			yylval.i = PF_OP_GT;
d703 1
a703 1
		yylval.number = 0;
d705 1
a705 1
			u_int64_t n = (u_int64_t)yylval.number * 10 + c - '0';
d710 1
a710 1
			yylval.number = (u_int32_t)n;
d714 1
a714 1
			fprintf(stderr, "number: %d\n", yylval.number);
d734 1
a734 1
		yylval.string = strdup(buf);
d737 2
a738 1
	if (c == '\n')
d740 1
@


1.17
log
@\+\n support, and spit out cc-style error messages.  the parser's line
counting is lex dependent, and will need to be tweaked
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.16 2001/07/31 09:02:18 wilfried Exp $	*/
d98 1
a98 1
%type	<b>	action icmpspec flags blockspec
d329 1
a329 2
flags:					{ $$.b1 = 0; $$.b2 = 0; }
		| FLAGS STRING		{
d332 2
a333 2
			if ((f = parse_flags($2)) < 0) {
				yyerror("bad flags %s", $2);
a336 1
			$$.b2 = 63;
d338 1
a338 2
		| FLAGS STRING "/" STRING	{
			int f;
d340 4
a343 21
			if ((f = parse_flags($2)) < 0) {
				yyerror("bad flags %s", $2);
				YYERROR;
			}
			$$.b1 = f;
			if ((f = parse_flags($4)) < 0) {
				yyerror("bad flags %s", $4);
				YYERROR;
			}
			$$.b2 = f;
		}
		| FLAGS "/" STRING	{
			int f;

			$$.b1 = 0;
			if ((f = parse_flags($3)) < 0) {
				yyerror("bad flags %s", $3);
				YYERROR;
			}
			$$.b2 = f;
		}
@


1.16
log
@allow to test that flags are unset, ok dhartmei@@,  mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.15 2001/07/19 00:07:36 krw Exp $	*/
d41 1
d56 1
a56 1
static int proto = 0;	/* this is a synthesysed attribute */
d114 4
a117 4
			if (natmode)
				errx(1, "line %d: filter rule in nat mode",
				    lineno);

d131 1
a131 1
			proto = 0;	/* reset syntesysed attribute */
d150 1
a150 1
				warnx("skipping rule due to errors");
d171 1
a171 2
				warnx("line %d: unknown icmp code %s",
				    lineno, $3);
d196 1
a196 1
				warnx("can't '!' interface in pf rule");
d208 1
a208 2
				warnx("line %d: unknown protocol %d", lineno,
				    $2);
d217 1
a217 2
				warnx("line %d: unknown protocol %s", lineno,
				    $2);
d259 1
a259 1
				warnx("illegal netmask value %d", $3);
d273 1
a273 2
					warnx("line %d: cannot resolve %s",
					    lineno, $1);
d282 1
a282 1
				warnx("illegal ip address %d.%d.%d.%d",
d306 1
a306 1
				warnx("illegal port value %d", $1);
d314 1
a314 1
			/* use synthesysed attribute */
d319 1
a319 2
					warnx("line %d: unknown protocol %s",
					    lineno, $1);
d334 1
a334 1
				warnx("line %d: bad flags %s", lineno, $2);
d344 1
a344 1
				warnx("line %d: bad flags %s", lineno, $2);
d349 1
a349 1
				warnx("line %d: bad flags %s", lineno, $4);
d359 1
a359 1
				warnx("line %d: bad flags %s", lineno, $3);
d370 1
a370 1
				warnx("illegal icmp code %d", $4);
d381 1
a381 2
				warnx("line %d: unknown icmp-code %s",
				    lineno, $4);
d392 1
a392 2
				warnx("line %d: unknown icmp-type %s",
				    lineno, $1);
d399 1
a399 1
				warnx("illegal icmp type %d", $1);
d414 1
a414 1
				warnx("illegal min-ttl value %d", $2);
d429 4
a432 3
			if (!natmode)
				errx(1, "line %d: nat rule in filter mode",
				    lineno);
d442 1
a442 1
			proto = 0;	/* reset syntesysed attribute */
d465 2
a466 2
				errx(1, "line %d: nat rule in filter mode",
				    lineno);
d477 1
a477 1
			proto = 0;	/* reset syntesysed attribute */
d527 1
a527 1
yyerror(char *s)
d529 2
d532 6
a537 1
	warnx("%s near line %d", s, lineno);
d548 1
a548 1
			warnx("quick does not apply to scrub");
d552 1
a552 1
			warnx("keep state does not apply to scrub");
d556 1
a556 1
			warnx("src port does not apply to scrub");
d560 1
a560 1
			warnx("dst port does not apply to scrub");
d564 1
a564 1
			warnx("icmp-type/code does not apply to scrub");
d569 1
a569 1
			warnx("nodf applies only to scrub");
d573 1
a573 1
			warnx("min-ttl applies only to scrub");
d579 1
a579 1
		warnx("ports do only apply to tcp/udp");
d583 1
a583 1
		warnx("icmp-type/code does only apply to icmp");
d641 19
d666 1
a666 1
	while ((c = getc(fin)) == ' ' || c == '\t')
d668 1
d670 1
a670 1
		while ((c = getc(fin)) != '\n' && c != EOF)
d673 1
a673 1
		next = getc(fin);
d683 1
a683 1
		next = getc(fin);
d691 1
a691 1
		next = getc(fin);
d704 1
a704 1
		next = getc(fin);
d722 1
a722 1
				warnx("line %d: number is too large", lineno);
d726 1
a726 1
		} while ((c = getc(fin)) != EOF && isdigit(c));
d734 2
a735 10
	isalnum(x) || \
	( ispunct(x) && \
	x != '(' && \
	x != ')' && \
	x != '<' && \
	x != '>' && \
	x != '!' && \
	x != '=' && \
	x != '/' && \
	x != '#' )
d742 1
a742 1
				warnx("line %d: string too long", lineno);
d745 1
a745 1
		} while ((c = getc(fin)) != EOF && (allowed_in_string(c)));
@


1.15
log
@Fix/complete the handling of the binary ops >< and <> to behave
like the ipf operators.

The 'n >< m' construct (Include Range = PF_OP_IRG) should match
ports greater than n and less than m, not greater than or equal to
n and less than or equal to m.

The 'n <> m' construct (Exclude Range = PF_OP_XRG) should match
all ports less than n OR greater than m, not be treated as an
alias for ><.

Thus PF_OP_GL, which was used for both <> and >< is replaced with
PF_OP_IRG and PF_OP_XRG with the 'correct' semantics.

OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.14 2001/07/18 09:53:14 markus Exp $	*/
d354 10
@


1.14
log
@new ERROR token, errx() -> warnx() + ERROR; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.13 2001/07/18 08:48:15 markus Exp $	*/
d661 1
a661 1
			yylval.i = PF_OP_GL;
d674 1
a674 1
			yylval.i = PF_OP_GL;
@


1.13
log
@KNF for return
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.12 2001/07/18 01:08:43 mickey Exp $	*/
d88 1
a88 1
%token	RDR NAT ARROW NODF MINTTL
d689 4
a692 3
			if (n > 0xffffffff)
				errx(1, "line %d: number is too large",
				    lineno);
d717 4
a720 2
			if (p-buf >= sizeof buf)
				errx(1, "line %d: string too long", lineno);
@


1.12
log
@check number range to fit in 32 bits
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.11 2001/07/18 00:41:48 mickey Exp $	*/
d526 1
a526 1
	return 0;
d574 1
a574 1
	return -problems;
d620 1
a620 1
			return keywords[i].k_val;
d625 1
a625 1
	return STRING;
d643 1
a643 1
			return ARROW;
d649 1
a649 1
		return PORTUNARY;
d654 1
a654 1
			return PORTUNARY;
d662 1
a662 1
			return PORTBINARY;
d669 1
a669 1
		return PORTUNARY;
d675 1
a675 1
			return PORTBINARY;
d682 1
a682 1
		return PORTUNARY;
d723 1
a723 1
		return token;
d728 2
a729 2
		return 0;
	return c;
@


1.11
log
@put range checks on NUMBER, pointed out by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.10 2001/07/17 23:52:29 mickey Exp $	*/
d688 5
a692 2
			yylval.number *= 10;
			yylval.number += c - '0';
d697 1
a697 1
		return NUMBER;
@


1.10
log
@spaces, parens, err instead of errx+strerror
@
text
@d1 1
a1 1
/*	$OpenBSD: parse.y,v 1.9 2001/07/17 23:41:01 markus Exp $	*/
d260 4
d283 6
d307 7
a313 1
port:		NUMBER			{ $$ = htons($1); }
d363 4
d393 7
a399 1
		| NUMBER		{ $$ = $1 + 1; }
d408 7
a414 1
		| MINTTL NUMBER		{ $$ = $2; }
@


1.9
log
@warnx()/YYERROR instead of errx(); suggested by mickey@@
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.8 2001/07/17 23:25:42 provos Exp $ */
d109 1
a109 1
pfrule: 	action direction log quick iface proto fromto flags icmpspec keep nodf minttl
d147 1
a147 1
			
d155 1
a155 1
action: 	PASS			{ $$.b1 = PF_PASS; }
d253 1
a253 1
host:		address 		{
d279 2
a280 2
                        $$ = (htonl(($1 << 24) | ($3 << 16) | ($5 << 8) | $7));
                }
d503 1
a503 1
                if (r->quick) {
d507 1
a507 1
                if (r->keep_state) {
d553 10
a562 10
		{ "all",	ALL}, 
		{ "any",	ANY}, 
		{ "block",	BLOCK}, 
		{ "code",	CODE}, 
		{ "flags",	FLAGS}, 
		{ "from",	FROM}, 
		{ "icmp-type",	ICMPTYPE}, 
		{ "in",		IN}, 
		{ "keep",	KEEP}, 
		{ "log",	LOG}, 
d567 14
a580 14
		{ "on",		ON}, 
		{ "out",	OUT}, 
		{ "pass",	PASS}, 
		{ "port",	PORT}, 
		{ "proto",	PROTO}, 
		{ "quick",	QUICK}, 
		{ "rdr",	RDR}, 
		{ "return",	RETURN}, 
		{ "return-icmp",RETURNICMP}, 
		{ "return-rst",	RETURNRST}, 
		{ "scrub",	SCRUB}, 
		{ "state",	STATE}, 
		{ "to",		TO}, 
		{ NULL, 0 },
d697 1
a697 1
int	
d705 1
a705 1
	return errors ? -1 : 0;
d716 1
a716 1
	return errors ? -1 : 0;
d737 1
a737 1
		errx(1, "new_addr: malloc failed: %s", strerror(errno));
d739 1
a739 1
	return ra;
@


1.8
log
@markus doesnt like min-ttl =, begone
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.7 2001/07/17 22:22:16 provos Exp $ */
d106 1
d149 1
a149 1
				yyerror("skipping rule due to errors");
d167 1
a167 1
			struct icmpcodeent *ic;
d169 2
a170 3
			ic = geticmpcodebyname(ICMP_UNREACH, $3);
			if (ic == NULL)
				errx(1, "line %d: unknown icmp code %s",
d172 3
a175 1
			$$.w = (ic->type << 8) | ic->code;
d195 4
a198 2
			if (! natmode)
				yyerror("can't '!' interface in pf rule");
d207 2
a208 3
			p = getprotobynumber($2);
			if (p == NULL)
				errx(1, "line %d: unknown protocol %d", lineno,
d210 2
d217 2
a218 3
			p = getprotobyname($2);
			if (p == NULL)
				errx(1, "line %d: unknown protocol %s", lineno,
d220 2
d270 2
a271 2
				if ((hp = gethostbyname($1)) == NULL)
					errx(1, "line %d: cannot resolve %s",
d273 2
d305 2
a306 2
				if (s == NULL)
					errx(1, "line %d: unknown protocol %s",
d308 2
d321 4
a324 2
			if ((f = parse_flags($2)) < 0)
				errx(1, "line %d: bad flags %s", lineno, $2);
d331 4
a334 2
			if ((f = parse_flags($2)) < 0)
				errx(1, "line %d: bad flags %s", lineno, $2);
d336 4
a339 2
			if ((f = parse_flags($4)) < 0)
				errx(1, "line %d: bad flags %s", lineno, $4);
d351 1
a351 1
			struct icmpcodeent *ic;
d354 2
a355 3
			ic = geticmpcodebyname($2, $4);
			if (ic == NULL)
				errx(1, "line %d: unknown icmp-code %s",
d357 3
a359 1
			$$.b2 = ic->code + 1;
d364 1
a364 1
			struct icmptypeent *te;
d366 2
a367 3
			te = geticmptypebyname($1);
			if (te == NULL)
				errx(1, "line %d: unknown icmp-type %s",
d369 3
a371 1
			$$ = te->type + 1;
d427 1
a427 1
			if (!natmode)
d430 1
d504 1
a504 1
			yyerror("quick does not apply to scrub");
d508 1
a508 1
			yyerror("keep state does not apply to scrub");
d512 1
a512 1
			yyerror("src port does not apply to scrub");
d516 1
a516 1
			yyerror("dst port does not apply to scrub");
d520 1
a520 1
			yyerror("icmp-type/code does not apply to scrub");
d525 1
a525 1
			yyerror("nodf applies only to scrub");
d529 1
a529 1
			yyerror("min-ttl applies only to scrub");
d535 1
a535 1
		yyerror("ports do only apply to tcp/udp");
d539 1
a539 1
		yyerror("icmp-type/code does only apply to icmp");
@


1.7
log
@support min-ttl, okay dhartmei@@
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.6 2001/07/17 21:54:27 provos Exp $ */
a364 1
		| MINTTL PORTUNARY NUMBER	{ $$ = $3; }
@


1.6
log
@normalize ip_off, make IP_DF stripping optional, return rst is a flag now.
okay markus@@
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.5 2001/07/17 17:39:42 marc Exp $ */
d88 1
a88 1
%token	RDR NAT ARROW NODF
d95 1
a95 1
%type	<number> address port icmptype
d108 1
a108 1
pfrule: 	action direction log quick iface proto fromto flags icmpspec keep nodf
d144 2
d363 5
d505 2
a506 1
	} else if (r->rule_flag & PFRULE_NODF) {
d509 5
d545 2
a546 1
		{ "log-all",	LOGALL}, 
@


1.5
log
@bitch about ! in pf rule; ok dhartmei@@ and markus@@
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.4 2001/07/17 16:07:47 millert Exp $ */
d88 1
a88 1
%token	RDR NAT ARROW
d96 1
a96 1
%type	<i>	direction log quick keep proto
d108 1
a108 1
pfrule: 	action direction log quick iface proto fromto flags icmpspec keep
d120 1
a120 1
				r.return_rst = 1;
d142 3
d361 4
d498 3
d533 2
a534 1
		{ "nat",	NAT}, 
@


1.4
log
@Only set default proto in the rdr case; markus@@ OK
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.3 2001/07/16 22:43:19 markus Exp $ */
d187 5
a191 1
		| ON '!' STRING		{ $$.string = strdup($3); $$.not = 1;}
@


1.3
log
@errx() if getservbyname() fails
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.2 2001/07/16 22:09:55 markus Exp $ */
d190 1
a190 1
proto:					{ proto = $$ = natmode ? IPPROTO_TCP : 0; }
d388 1
a388 1
rdrrule:	RDR iface proto FROM ipspec TO ipspec dport ARROW address rport
d398 2
a399 2
			if ($2.string) {
				memcpy(rdr.ifname, $2.string,
d401 1
a401 1
				rdr.ifnot = $2.not;
d403 1
a403 1
			rdr.proto = $3;
d406 13
a418 13
			rdr.saddr = $5->addr;
			rdr.smask = $5->mask;
			rdr.snot  = $5->not;
			free($5);

			rdr.daddr = $7->addr;
			rdr.dmask = $7->mask;
			rdr.dnot  = $7->not;
			free($7);

			rdr.dport  = $8.a;
			rdr.dport2 = $8.b;
			rdr.opts  |= $8.t;
d420 1
a420 1
			rdr.raddr = $10;
d422 2
a423 2
			rdr.rport  = $11.a;
			rdr.opts  |= $11.t;
@


1.2
log
@better flags parsing; dhartmei
@
text
@d1 1
a1 1
/*      $OpenBSD: parse.y,v 1.1 2001/07/16 21:09:37 markus Exp $ */
d285 1
a285 1
			if (proto)
d288 7
a294 1
			$$ = (s == NULL) ? 0 : s->s_port;
@


1.1
log
@add a yacc parser for pf.conf and nat.conf, with help from mickey@@,
plus: -n now turns off all operations, and just parses the conf files
ok deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: $ */
d293 8
a300 1
		| FLAGS STRING		{ $$.b1 = parse_flags($2); $$.b2 = 63; }
d302 8
a309 2
			$$.b1 = parse_flags($2);
			$$.b2 = parse_flags($4);
d621 1
@

