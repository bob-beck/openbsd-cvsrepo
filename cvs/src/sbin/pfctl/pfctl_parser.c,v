head	1.313;
access;
symbols
	OPENBSD_6_1:1.309.0.4
	OPENBSD_6_1_BASE:1.309
	OPENBSD_6_0:1.306.0.4
	OPENBSD_6_0_BASE:1.306
	OPENBSD_5_9:1.306.0.2
	OPENBSD_5_9_BASE:1.306
	OPENBSD_5_8:1.305.0.4
	OPENBSD_5_8_BASE:1.305
	OPENBSD_5_7:1.304.0.2
	OPENBSD_5_7_BASE:1.304
	OPENBSD_5_6:1.298.0.6
	OPENBSD_5_6_BASE:1.298
	OPENBSD_5_5:1.298.0.4
	OPENBSD_5_5_BASE:1.298
	OPENBSD_5_4:1.293.0.2
	OPENBSD_5_4_BASE:1.293
	OPENBSD_5_3:1.292.0.2
	OPENBSD_5_3_BASE:1.292
	OPENBSD_5_2:1.289.0.2
	OPENBSD_5_2_BASE:1.289
	OPENBSD_5_1_BASE:1.284
	OPENBSD_5_1:1.284.0.2
	OPENBSD_5_0:1.279.0.2
	OPENBSD_5_0_BASE:1.279
	OPENBSD_4_9:1.273.0.2
	OPENBSD_4_9_BASE:1.273
	OPENBSD_4_8:1.269.0.2
	OPENBSD_4_8_BASE:1.269
	OPENBSD_4_7:1.262.0.2
	OPENBSD_4_7_BASE:1.262
	OPENBSD_4_6:1.244.0.4
	OPENBSD_4_6_BASE:1.244
	OPENBSD_4_5:1.241.0.2
	OPENBSD_4_5_BASE:1.241
	OPENBSD_4_4:1.240.0.2
	OPENBSD_4_4_BASE:1.240
	OPENBSD_4_3:1.235.0.2
	OPENBSD_4_3_BASE:1.235
	OPENBSD_4_2:1.234.0.4
	OPENBSD_4_2_BASE:1.234
	OPENBSD_4_1:1.234.0.2
	OPENBSD_4_1_BASE:1.234
	OPENBSD_4_0:1.227.0.2
	OPENBSD_4_0_BASE:1.227
	OPENBSD_3_9:1.222.0.2
	OPENBSD_3_9_BASE:1.222
	OPENBSD_3_8:1.219.0.2
	OPENBSD_3_8_BASE:1.219
	OPENBSD_3_7:1.211.0.2
	OPENBSD_3_7_BASE:1.211
	OPENBSD_3_6:1.203.0.2
	OPENBSD_3_6_BASE:1.203
	OPENBSD_3_5:1.194.0.2
	OPENBSD_3_5_BASE:1.194
	OPENBSD_3_4:1.174.0.2
	OPENBSD_3_4_BASE:1.174
	OPENBSD_3_3:1.146.0.2
	OPENBSD_3_3_BASE:1.146
	OPENBSD_3_2:1.94.0.2
	OPENBSD_3_2_BASE:1.94
	OPENBSD_3_1:1.63.0.2
	OPENBSD_3_1_BASE:1.63
	OPENBSD_3_0:1.52.0.2
	OPENBSD_3_0_BASE:1.52;
locks; strict;
comment	@ * @;


1.313
date	2017.07.19.12.58.31;	author mikeb;	state Exp;
branches;
next	1.312;
commitid	iahjnsaS3YMAv0Za;

1.312
date	2017.06.01.14.38.28;	author patrick;	state Exp;
branches;
next	1.311;
commitid	Pz82BaXFYwoiyHnm;

1.311
date	2017.05.15.16.56.42;	author mikeb;	state Exp;
branches;
next	1.310;
commitid	aByQge4cYnk2GkpE;

1.310
date	2017.05.15.11.23.25;	author mikeb;	state Exp;
branches;
next	1.309;
commitid	MV7SeE82QLGXQJBO;

1.309
date	2016.10.26.14.15.59;	author bluhm;	state Exp;
branches;
next	1.308;
commitid	iFSUOak9ezFLvqpw;

1.308
date	2016.09.03.17.11.40;	author sashan;	state Exp;
branches;
next	1.307;
commitid	JAk2J5vzbGC5EyfM;

1.307
date	2016.08.26.06.06.58;	author guenther;	state Exp;
branches;
next	1.306;
commitid	uyVadfZnVhGMOzn7;

1.306
date	2015.09.03.12.46.47;	author mikeb;	state Exp;
branches;
next	1.305;
commitid	dKvCbq7i256CHQai;

1.305
date	2015.06.03.02.24.36;	author millert;	state Exp;
branches;
next	1.304;
commitid	GouatFiJVxwlAVIQ;

1.304
date	2015.02.14.23.32.41;	author sthen;	state Exp;
branches;
next	1.303;
commitid	yqzib6o76qMH9qZC;

1.303
date	2015.02.10.06.45.55;	author henning;	state Exp;
branches;
next	1.302;
commitid	eD7tXFa7upGCZ3zN;

1.302
date	2015.02.07.23.35.27;	author tedu;	state Exp;
branches;
next	1.301;
commitid	NM8AiPJaG7WOM8QJ;

1.301
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.300;
commitid	Uu5nFG3wCl0LACBb;

1.300
date	2014.10.27.21.51.32;	author mikeb;	state Exp;
branches;
next	1.299;
commitid	a2mU7I61ROTRhch2;

1.299
date	2014.10.25.03.18.13;	author lteo;	state Exp;
branches;
next	1.298;
commitid	RKMpGS78lskgSHj4;

1.298
date	2014.01.20.02.59.13;	author henning;	state Exp;
branches
	1.298.4.1
	1.298.6.1;
next	1.297;

1.297
date	2013.11.22.04.12.48;	author deraadt;	state Exp;
branches;
next	1.296;

1.296
date	2013.10.28.15.05.35;	author deraadt;	state Exp;
branches;
next	1.295;

1.295
date	2013.10.12.12.16.12;	author henning;	state Exp;
branches;
next	1.294;

1.294
date	2013.08.01.19.03.11;	author mikeb;	state Exp;
branches;
next	1.293;

1.293
date	2013.04.21.23.13.39;	author deraadt;	state Exp;
branches
	1.293.2.1;
next	1.292;

1.292
date	2013.01.16.01.49.20;	author henning;	state Exp;
branches;
next	1.291;

1.291
date	2012.12.04.02.24.46;	author deraadt;	state Exp;
branches;
next	1.290;

1.290
date	2012.09.18.10.11.53;	author henning;	state Exp;
branches;
next	1.289;

1.289
date	2012.07.10.09.39.26;	author henning;	state Exp;
branches;
next	1.288;

1.288
date	2012.07.10.09.23.56;	author henning;	state Exp;
branches;
next	1.287;

1.287
date	2012.07.10.09.13.41;	author henning;	state Exp;
branches;
next	1.286;

1.286
date	2012.07.09.14.05.35;	author henning;	state Exp;
branches;
next	1.285;

1.285
date	2012.07.07.16.24.32;	author henning;	state Exp;
branches;
next	1.284;

1.284
date	2011.12.12.21.30.27;	author mikeb;	state Exp;
branches;
next	1.283;

1.283
date	2011.11.23.10.24.37;	author henning;	state Exp;
branches;
next	1.282;

1.282
date	2011.11.23.10.23.11;	author henning;	state Exp;
branches;
next	1.281;

1.281
date	2011.10.13.18.30.54;	author claudio;	state Exp;
branches;
next	1.280;

1.280
date	2011.08.30.00.43.57;	author mikeb;	state Exp;
branches;
next	1.279;

1.279
date	2011.07.27.00.26.10;	author mcbride;	state Exp;
branches;
next	1.278;

1.278
date	2011.07.08.18.52.47;	author henning;	state Exp;
branches;
next	1.277;

1.277
date	2011.07.07.02.00.25;	author mcbride;	state Exp;
branches;
next	1.276;

1.276
date	2011.07.03.23.37.55;	author zinke;	state Exp;
branches;
next	1.275;

1.275
date	2011.04.06.13.19.55;	author claudio;	state Exp;
branches;
next	1.274;

1.274
date	2011.04.05.13.48.18;	author mikeb;	state Exp;
branches;
next	1.273;

1.273
date	2011.01.23.11.19.55;	author bluhm;	state Exp;
branches;
next	1.272;

1.272
date	2010.10.12.17.45.06;	author bluhm;	state Exp;
branches;
next	1.271;

1.271
date	2010.09.22.06.02.59;	author henning;	state Exp;
branches;
next	1.270;

1.270
date	2010.09.02.14.01.04;	author sobrado;	state Exp;
branches;
next	1.269;

1.269
date	2010.07.13.13.11.57;	author sthen;	state Exp;
branches;
next	1.268;

1.268
date	2010.07.03.02.28.57;	author mcbride;	state Exp;
branches;
next	1.267;

1.267
date	2010.07.03.02.05.17;	author mcbride;	state Exp;
branches;
next	1.266;

1.266
date	2010.06.29.19.28.13;	author chl;	state Exp;
branches;
next	1.265;

1.265
date	2010.05.16.12.23.30;	author zinovik;	state Exp;
branches;
next	1.264;

1.264
date	2010.03.22.17.04.02;	author deraadt;	state Exp;
branches;
next	1.263;

1.263
date	2010.03.18.12.15.22;	author sthen;	state Exp;
branches;
next	1.262;

1.262
date	2010.01.18.23.52.46;	author mcbride;	state Exp;
branches;
next	1.261;

1.261
date	2010.01.13.05.09.07;	author deraadt;	state Exp;
branches;
next	1.260;

1.260
date	2010.01.13.01.41.58;	author jsg;	state Exp;
branches;
next	1.259;

1.259
date	2010.01.12.16.21.24;	author mcbride;	state Exp;
branches;
next	1.258;

1.258
date	2010.01.12.15.49.43;	author mcbride;	state Exp;
branches;
next	1.257;

1.257
date	2010.01.12.14.44.26;	author mcbride;	state Exp;
branches;
next	1.256;

1.256
date	2010.01.12.03.20.51;	author mcbride;	state Exp;
branches;
next	1.255;

1.255
date	2009.12.24.10.06.35;	author sobrado;	state Exp;
branches;
next	1.254;

1.254
date	2009.12.24.04.24.19;	author dlg;	state Exp;
branches;
next	1.253;

1.253
date	2009.12.14.12.31.45;	author henning;	state Exp;
branches;
next	1.252;

1.252
date	2009.11.23.21.29.21;	author henning;	state Exp;
branches;
next	1.251;

1.251
date	2009.11.22.22.34.50;	author henning;	state Exp;
branches;
next	1.250;

1.250
date	2009.10.28.20.11.01;	author jsg;	state Exp;
branches;
next	1.249;

1.249
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.248;

1.248
date	2009.09.08.17.52.17;	author michele;	state Exp;
branches;
next	1.247;

1.247
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.246;

1.246
date	2009.09.02.13.28.03;	author reyk;	state Exp;
branches;
next	1.245;

1.245
date	2009.09.01.13.42.00;	author henning;	state Exp;
branches;
next	1.244;

1.244
date	2009.04.15.05.07.02;	author david;	state Exp;
branches;
next	1.243;

1.243
date	2009.04.06.12.11.52;	author henning;	state Exp;
branches;
next	1.242;

1.242
date	2009.04.06.12.05.55;	author henning;	state Exp;
branches;
next	1.241;

1.241
date	2008.09.09.13.56.38;	author henning;	state Exp;
branches;
next	1.240;

1.240
date	2008.06.10.20.55.02;	author mcbride;	state Exp;
branches;
next	1.239;

1.239
date	2008.06.10.04.28.54;	author henning;	state Exp;
branches;
next	1.238;

1.238
date	2008.05.09.05.41.01;	author markus;	state Exp;
branches;
next	1.237;

1.237
date	2008.05.09.02.44.55;	author markus;	state Exp;
branches;
next	1.236;

1.236
date	2008.05.07.06.23.30;	author markus;	state Exp;
branches;
next	1.235;

1.235
date	2007.10.15.02.16.35;	author deraadt;	state Exp;
branches;
next	1.234;

1.234
date	2006.10.31.23.46.24;	author mcbride;	state Exp;
branches;
next	1.233;

1.233
date	2006.10.28.14.29.05;	author mcbride;	state Exp;
branches;
next	1.232;

1.232
date	2006.10.25.11.28.36;	author henning;	state Exp;
branches;
next	1.231;

1.231
date	2006.10.17.07.14.28;	author mcbride;	state Exp;
branches;
next	1.230;

1.230
date	2006.10.06.17.04.53;	author mcbride;	state Exp;
branches;
next	1.229;

1.229
date	2006.10.06.16.42.03;	author mcbride;	state Exp;
branches;
next	1.228;

1.228
date	2006.10.06.16.27.49;	author mcbride;	state Exp;
branches;
next	1.227;

1.227
date	2006.08.08.20.05.54;	author dhartmei;	state Exp;
branches;
next	1.226;

1.226
date	2006.07.06.13.26.41;	author henning;	state Exp;
branches;
next	1.225;

1.225
date	2006.06.30.16.52.27;	author deraadt;	state Exp;
branches;
next	1.224;

1.224
date	2006.05.23.12.04.28;	author henning;	state Exp;
branches;
next	1.223;

1.223
date	2006.03.21.03.31.09;	author dhartmei;	state Exp;
branches;
next	1.222;

1.222
date	2005.11.04.08.24.15;	author mcbride;	state Exp;
branches;
next	1.221;

1.221
date	2005.10.18.08.59.30;	author henning;	state Exp;
branches;
next	1.220;

1.220
date	2005.10.13.13.27.06;	author henning;	state Exp;
branches;
next	1.219;

1.219
date	2005.06.30.20.52.20;	author sturm;	state Exp;
branches;
next	1.218;

1.218
date	2005.06.13.20.17.26;	author henning;	state Exp;
branches;
next	1.217;

1.217
date	2005.05.27.22.09.06;	author mcbride;	state Exp;
branches;
next	1.216;

1.216
date	2005.05.27.21.41.04;	author mpf;	state Exp;
branches;
next	1.215;

1.215
date	2005.05.27.18.52.42;	author dhartmei;	state Exp;
branches;
next	1.214;

1.214
date	2005.05.27.17.22.40;	author dhartmei;	state Exp;
branches;
next	1.213;

1.213
date	2005.05.26.15.30.39;	author dhartmei;	state Exp;
branches;
next	1.212;

1.212
date	2005.05.21.21.03.58;	author henning;	state Exp;
branches;
next	1.211;

1.211
date	2004.12.07.10.33.41;	author dhartmei;	state Exp;
branches;
next	1.210;

1.210
date	2004.12.07.09.38.04;	author deraadt;	state Exp;
branches;
next	1.209;

1.209
date	2004.12.07.05.30.27;	author mcbride;	state Exp;
branches;
next	1.208;

1.208
date	2004.12.04.07.58.52;	author mcbride;	state Exp;
branches;
next	1.207;

1.207
date	2004.11.09.11.26.04;	author dhartmei;	state Exp;
branches;
next	1.206;

1.206
date	2004.09.30.16.38.01;	author dhartmei;	state Exp;
branches;
next	1.205;

1.205
date	2004.09.27.12.51.12;	author jaredy;	state Exp;
branches;
next	1.204;

1.204
date	2004.09.21.16.59.11;	author aaron;	state Exp;
branches;
next	1.203;

1.203
date	2004.07.16.23.44.25;	author frantzen;	state Exp;
branches
	1.203.2.1;
next	1.202;

1.202
date	2004.06.29.22.14.13;	author henning;	state Exp;
branches;
next	1.201;

1.201
date	2004.06.10.14.22.54;	author dhartmei;	state Exp;
branches;
next	1.200;

1.200
date	2004.05.27.11.48.06;	author henning;	state Exp;
branches;
next	1.199;

1.199
date	2004.05.19.17.50.51;	author dhartmei;	state Exp;
branches;
next	1.198;

1.198
date	2004.05.07.16.54.20;	author henning;	state Exp;
branches;
next	1.197;

1.197
date	2004.05.05.23.16.03;	author frantzen;	state Exp;
branches;
next	1.196;

1.196
date	2004.04.24.23.22.54;	author cedric;	state Exp;
branches;
next	1.195;

1.195
date	2004.04.14.10.51.10;	author cedric;	state Exp;
branches;
next	1.194;

1.194
date	2004.03.15.15.25.44;	author dhartmei;	state Exp;
branches
	1.194.2.1;
next	1.193;

1.193
date	2004.03.10.17.48.48;	author henning;	state Exp;
branches;
next	1.192;

1.192
date	2004.02.10.17.53.37;	author henning;	state Exp;
branches;
next	1.191;

1.191
date	2004.02.10.09.27.01;	author cedric;	state Exp;
branches;
next	1.190;

1.190
date	2004.02.03.17.59.37;	author henning;	state Exp;
branches;
next	1.189;

1.189
date	2004.01.25.18.47.15;	author deraadt;	state Exp;
branches;
next	1.188;

1.188
date	2004.01.22.13.32.00;	author henning;	state Exp;
branches;
next	1.187;

1.187
date	2003.12.31.22.14.41;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2003.12.31.11.18.24;	author cedric;	state Exp;
branches;
next	1.185;

1.185
date	2003.12.19.16.12.43;	author henning;	state Exp;
branches;
next	1.184;

1.184
date	2003.12.17.16.36.30;	author dhartmei;	state Exp;
branches;
next	1.183;

1.183
date	2003.12.15.07.11.30;	author mcbride;	state Exp;
branches;
next	1.182;

1.182
date	2003.12.15.00.02.03;	author mcbride;	state Exp;
branches;
next	1.181;

1.181
date	2003.11.14.15.32.33;	author henning;	state Exp;
branches;
next	1.180;

1.180
date	2003.11.08.00.45.34;	author mcbride;	state Exp;
branches;
next	1.179;

1.179
date	2003.11.06.15.18.12;	author henning;	state Exp;
branches;
next	1.178;

1.178
date	2003.11.06.15.02.11;	author henning;	state Exp;
branches;
next	1.177;

1.177
date	2003.10.08.14.47.57;	author henning;	state Exp;
branches;
next	1.176;

1.176
date	2003.09.26.21.44.09;	author cedric;	state Exp;
branches;
next	1.175;

1.175
date	2003.09.18.20.27.58;	author cedric;	state Exp;
branches;
next	1.174;

1.174
date	2003.08.22.21.52.11;	author itojun;	state Exp;
branches;
next	1.173;

1.173
date	2003.08.21.19.12.08;	author frantzen;	state Exp;
branches;
next	1.172;

1.172
date	2003.07.29.19.47.22;	author cedric;	state Exp;
branches;
next	1.171;

1.171
date	2003.07.21.22.31.36;	author henning;	state Exp;
branches;
next	1.170;

1.170
date	2003.07.19.13.08.58;	author cedric;	state Exp;
branches;
next	1.169;

1.169
date	2003.07.15.17.12.38;	author cedric;	state Exp;
branches;
next	1.168;

1.168
date	2003.07.11.08.29.34;	author cedric;	state Exp;
branches;
next	1.167;

1.167
date	2003.07.04.11.05.44;	author henning;	state Exp;
branches;
next	1.166;

1.166
date	2003.07.04.10.42.17;	author henning;	state Exp;
branches;
next	1.165;

1.165
date	2003.07.03.09.13.06;	author cedric;	state Exp;
branches;
next	1.164;

1.164
date	2003.06.12.09.40.33;	author henning;	state Exp;
branches;
next	1.163;

1.163
date	2003.06.11.02.54.02;	author itojun;	state Exp;
branches;
next	1.162;

1.162
date	2003.06.09.11.14.46;	author mcbride;	state Exp;
branches;
next	1.161;

1.161
date	2003.05.24.19.14.06;	author henning;	state Exp;
branches;
next	1.160;

1.160
date	2003.05.19.20.21.53;	author henning;	state Exp;
branches;
next	1.159;

1.159
date	2003.05.19.18.21.01;	author henning;	state Exp;
branches;
next	1.158;

1.158
date	2003.05.17.02.04.24;	author henning;	state Exp;
branches;
next	1.157;

1.157
date	2003.05.16.17.15.17;	author dhartmei;	state Exp;
branches;
next	1.156;

1.156
date	2003.05.14.23.51.29;	author frantzen;	state Exp;
branches;
next	1.155;

1.155
date	2003.05.14.00.56.38;	author henning;	state Exp;
branches;
next	1.154;

1.154
date	2003.05.13.21.37.42;	author henning;	state Exp;
branches;
next	1.153;

1.153
date	2003.05.13.21.15.07;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2003.05.12.01.25.31;	author dhartmei;	state Exp;
branches;
next	1.151;

1.151
date	2003.04.25.19.44.57;	author henning;	state Exp;
branches;
next	1.150;

1.150
date	2003.04.05.23.56.32;	author henning;	state Exp;
branches;
next	1.149;

1.149
date	2003.04.03.15.52.24;	author cedric;	state Exp;
branches;
next	1.148;

1.148
date	2003.03.28.20.37.29;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2003.03.27.18.01.57;	author henning;	state Exp;
branches;
next	1.146;

1.146
date	2003.03.19.15.56.08;	author henning;	state Exp;
branches
	1.146.2.1;
next	1.145;

1.145
date	2003.02.25.12.22.25;	author cedric;	state Exp;
branches;
next	1.144;

1.144
date	2003.02.19.19.08.19;	author cedric;	state Exp;
branches;
next	1.143;

1.143
date	2003.02.13.10.28.58;	author henning;	state Exp;
branches;
next	1.142;

1.142
date	2003.02.12.12.48.40;	author mcbride;	state Exp;
branches;
next	1.141;

1.141
date	2003.02.09.12.49.48;	author camield;	state Exp;
branches;
next	1.140;

1.140
date	2003.02.08.20.13.20;	author dhartmei;	state Exp;
branches;
next	1.139;

1.139
date	2003.02.02.19.25.06;	author henning;	state Exp;
branches;
next	1.138;

1.138
date	2003.02.02.18.32.35;	author henning;	state Exp;
branches;
next	1.137;

1.137
date	2003.02.02.18.11.43;	author henning;	state Exp;
branches;
next	1.136;

1.136
date	2003.01.30.15.41.35;	author henning;	state Exp;
branches;
next	1.135;

1.135
date	2003.01.30.15.03.49;	author henning;	state Exp;
branches;
next	1.134;

1.134
date	2003.01.25.22.53.45;	author mcbride;	state Exp;
branches;
next	1.133;

1.133
date	2003.01.20.17.16.56;	author cedric;	state Exp;
branches;
next	1.132;

1.132
date	2003.01.19.09.31.34;	author camield;	state Exp;
branches;
next	1.131;

1.131
date	2003.01.18.17.39.37;	author henning;	state Exp;
branches;
next	1.130;

1.130
date	2003.01.18.17.20.41;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2003.01.17.14.01.43;	author markus;	state Exp;
branches;
next	1.128;

1.128
date	2003.01.14.21.58.12;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2003.01.05.22.14.23;	author dhartmei;	state Exp;
branches;
next	1.126;

1.126
date	2003.01.04.17.40.51;	author dhartmei;	state Exp;
branches;
next	1.125;

1.125
date	2003.01.04.00.01.34;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2002.12.30.23.46.54;	author mcbride;	state Exp;
branches;
next	1.123;

1.123
date	2002.12.18.19.40.41;	author dhartmei;	state Exp;
branches;
next	1.122;

1.122
date	2002.12.17.12.36.59;	author mcbride;	state Exp;
branches;
next	1.121;

1.121
date	2002.12.13.21.51.25;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2002.12.07.23.15.53;	author dhartmei;	state Exp;
branches;
next	1.119;

1.119
date	2002.12.07.20.25.40;	author henning;	state Exp;
branches;
next	1.118;

1.118
date	2002.12.06.11.03.36;	author henning;	state Exp;
branches;
next	1.117;

1.117
date	2002.12.06.00.47.32;	author dhartmei;	state Exp;
branches;
next	1.116;

1.116
date	2002.12.05.14.10.45;	author henning;	state Exp;
branches;
next	1.115;

1.115
date	2002.11.30.10.07.51;	author mickey;	state Exp;
branches;
next	1.114;

1.114
date	2002.11.28.13.18.09;	author mcbride;	state Exp;
branches;
next	1.113;

1.113
date	2002.11.28.12.14.25;	author mcbride;	state Exp;
branches;
next	1.112;

1.112
date	2002.11.23.11.58.44;	author dhartmei;	state Exp;
branches;
next	1.111;

1.111
date	2002.11.23.10.03.39;	author mcbride;	state Exp;
branches;
next	1.110;

1.110
date	2002.11.23.09.33.54;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2002.11.23.08.59.54;	author dhartmei;	state Exp;
branches;
next	1.108;

1.108
date	2002.11.23.08.12.56;	author mcbride;	state Exp;
branches;
next	1.107;

1.107
date	2002.11.23.06.18.42;	author mcbride;	state Exp;
branches;
next	1.106;

1.106
date	2002.11.23.05.22.24;	author mcbride;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.19.23.34.02;	author dhartmei;	state Exp;
branches;
next	1.104;

1.104
date	2002.11.18.22.55.39;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2002.11.18.22.49.15;	author henning;	state Exp;
branches;
next	1.102;

1.102
date	2002.10.25.10.40.45;	author camield;	state Exp;
branches;
next	1.101;

1.101
date	2002.10.22.12.28.08;	author mcbride;	state Exp;
branches;
next	1.100;

1.100
date	2002.10.14.12.58.28;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2002.10.07.13.23.46;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.07.13.18.40;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2002.10.07.13.15.02;	author henning;	state Exp;
branches;
next	1.96;

1.96
date	2002.10.07.12.39.29;	author dhartmei;	state Exp;
branches;
next	1.95;

1.95
date	2002.10.05.21.17.57;	author dhartmei;	state Exp;
branches;
next	1.94;

1.94
date	2002.07.20.18.58.44;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2002.07.15.18.13.53;	author henning;	state Exp;
branches;
next	1.92;

1.92
date	2002.07.01.05.28.22;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2002.06.27.10.17.48;	author henning;	state Exp;
branches;
next	1.90;

1.90
date	2002.06.19.17.44.02;	author dhartmei;	state Exp;
branches;
next	1.89;

1.89
date	2002.06.11.18.03.25;	author frantzen;	state Exp;
branches;
next	1.88;

1.88
date	2002.06.11.02.27.19;	author frantzen;	state Exp;
branches;
next	1.87;

1.87
date	2002.06.11.02.12.37;	author dhartmei;	state Exp;
branches;
next	1.86;

1.86
date	2002.06.11.01.58.00;	author henning;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.10.19.31.44;	author dhartmei;	state Exp;
branches;
next	1.84;

1.84
date	2002.06.09.20.20.58;	author dhartmei;	state Exp;
branches;
next	1.83;

1.83
date	2002.06.09.05.31.25;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2002.06.08.21.09.59;	author dhartmei;	state Exp;
branches;
next	1.81;

1.81
date	2002.06.08.16.44.15;	author drahn;	state Exp;
branches;
next	1.80;

1.80
date	2002.06.08.07.58.07;	author dhartmei;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.07.22.53.45;	author pb;	state Exp;
branches;
next	1.78;

1.78
date	2002.06.07.21.25.35;	author dhartmei;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.07.19.30.40;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2002.06.06.22.22.44;	author mickey;	state Exp;
branches;
next	1.75;

1.75
date	2002.06.01.04.06.47;	author hugh;	state Exp;
branches;
next	1.74;

1.74
date	2002.05.27.10.33.32;	author dhartmei;	state Exp;
branches;
next	1.73;

1.73
date	2002.05.23.09.47.20;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2002.05.19.22.26.27;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2002.05.18.13.47.57;	author dhartmei;	state Exp;
branches;
next	1.70;

1.70
date	2002.05.12.00.54.56;	author dhartmei;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.09.21.58.12;	author jasoni;	state Exp;
branches;
next	1.68;

1.68
date	2002.05.09.19.58.42;	author dhartmei;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.05.21.40.22;	author dhartmei;	state Exp;
branches;
next	1.66;

1.66
date	2002.04.24.18.10.25;	author dhartmei;	state Exp;
branches;
next	1.65;

1.65
date	2002.04.23.14.32.23;	author dhartmei;	state Exp;
branches;
next	1.64;

1.64
date	2002.04.15.20.39.58;	author dhartmei;	state Exp;
branches;
next	1.63;

1.63
date	2002.03.27.18.16.23;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.03.12.08.15.03;	author dhartmei;	state Exp;
branches;
next	1.61;

1.61
date	2002.03.11.22.22.57;	author dhartmei;	state Exp;
branches;
next	1.60;

1.60
date	2002.01.09.11.30.53;	author dhartmei;	state Exp;
branches;
next	1.59;

1.59
date	2002.01.08.09.31.55;	author dhartmei;	state Exp;
branches;
next	1.58;

1.58
date	2002.01.07.17.24.43;	author mpech;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.04.12.32.30;	author mpech;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.10.18.08.12;	author dhartmei;	state Exp;
branches;
next	1.55;

1.55
date	2001.12.01.16.44.45;	author frantzen;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.53;

1.53
date	2001.10.24.09.09.32;	author dhartmei;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.15.16.22.22;	author dhartmei;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2001.10.04.21.54.15;	author dhartmei;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.15.23.23.40;	author wilfried;	state Exp;
branches;
next	1.49;

1.49
date	2001.09.15.23.13.40;	author dhartmei;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.06.18.05.46;	author jasoni;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.02.15.15.31;	author dhartmei;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.25.21.54.26;	author frantzen;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.23.04.10.51;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2001.08.19.17.03.00;	author frantzen;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.18.14.05.56;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.16.11.46.56;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.11.12.05.00;	author dhartmei;	state Exp;
branches;
next	1.39;

1.39
date	2001.07.19.00.07.36;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.17.23.25.42;	author provos;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.17.22.22.17;	author provos;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.17.21.54.27;	author provos;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.16.21.09.38;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.11.21.30.14;	author csapuntz;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.10.05.55.57;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.10.03.03.44;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.10.00.07.21;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.09.23.20.45;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.09.10.30.58;	author dhartmei;	state Exp;
branches;
next	1.28;

1.28
date	2001.07.06.21.19.54;	author chris;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.04.23.45.40;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.04.21.10.43;	author wilfried;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.01.23.04.45;	author dhartmei;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.01.17.16.02;	author kjell;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.01.17.04.13;	author kjell;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.29.00.27.48;	author dhartmei;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.28.21.54.43;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.27.20.47.46;	author dhartmei;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.27.04.29.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.27.02.45.58;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.26.22.56.01;	author dugsong;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.26.22.36.28;	author dhartmei;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.26.22.26.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.26.20.50.26;	author dhartmei;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.19.43.15;	author dhartmei;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.18.18.58;	author kjell;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.26.15.29.05;	author wilfried;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.26.12.47.10;	author dhartmei;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.26.12.27.14;	author wilfried;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.10.15.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.25.10.14.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.25.09.44.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.25.05.00.58;	author smart;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.24.23.24.15;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.24.23.16.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.24.21.40.51;	author dhartmei;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.24.21.04.16;	author kjell;	state Exp;
branches;
next	;

1.52.2.1
date	2001.12.13.20.06.18;	author jason;	state Exp;
branches;
next	;

1.146.2.1
date	2003.06.12.19.00.43;	author brad;	state Exp;
branches;
next	;

1.194.2.1
date	2004.05.05.04.00.50;	author brad;	state Exp;
branches;
next	;

1.203.2.1
date	2004.11.13.23.52.14;	author brad;	state Exp;
branches;
next	;

1.293.2.1
date	2014.10.29.15.36.44;	author sthen;	state Exp;
branches;
next	;
commitid	KDltmIoVhxTrRd6T;

1.298.4.1
date	2014.10.29.15.36.15;	author sthen;	state Exp;
branches;
next	;
commitid	HPnolLQ40jcwDio1;

1.298.6.1
date	2014.10.29.15.29.34;	author sthen;	state Exp;
branches;
next	;
commitid	fYdjk1qSZRmnT7ec;


desc
@@


1.313
log
@Allow HFSC classes to use flow queues

The FQ-CoDel related configuration (flows, quantum) becomes available
for the regular bandwidth queue.  Internally the kernel will pick the
FQ-CoDel for use as a queue manager for the specified class instead of
the FIFO.

Discussed with and OK henning@@ at d2k17 as a part of a larger diff.
@
text
@/*	$OpenBSD: pfctl_parser.c,v 1.312 2017/06/01 14:38:28 patrick Exp $ */

/*
 * Copyright (c) 2001 Daniel Hartmeier
 * Copyright (c) 2002 - 2013 Henning Brauer <henning@@openbsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *    - Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    - Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials provided
 *      with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <net/if_dl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_icmp.h>
#include <netinet/icmp6.h>
#include <net/pfvar.h>
#include <arpa/inet.h>

#include <ctype.h>
#include <err.h>
#include <errno.h>
#include <ifaddrs.h>
#include <limits.h>
#include <netdb.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

#define SYSLOG_NAMES
#include <syslog.h>

#include "pfctl_parser.h"
#include "pfctl.h"

void		 print_op (u_int8_t, const char *, const char *);
void		 print_port (u_int8_t, u_int16_t, u_int16_t, const char *, int);
void		 print_ugid (u_int8_t, unsigned, unsigned, const char *, unsigned);
void		 print_flags (u_int8_t);
void		 print_fromto(struct pf_rule_addr *, pf_osfp_t,
		    struct pf_rule_addr *, u_int8_t, u_int8_t, int);
void		 print_bwspec(const char *index, struct pf_queue_bwspec *);
void		 print_scspec(const char *, struct pf_queue_scspec *);
int		 ifa_skip_if(const char *filter, struct node_host *p);

struct node_host	*ifa_grouplookup(const char *, int);
struct node_host	*host_if(const char *, int);
struct node_host	*host_v4(const char *, int);
struct node_host	*host_v6(const char *, int);
struct node_host	*host_dns(const char *, int, int);

const char *tcpflags = "FSRPAUEW";

static const struct icmptypeent icmp_type[] = {
	{ "echoreq",	ICMP_ECHO },
	{ "echorep",	ICMP_ECHOREPLY },
	{ "unreach",	ICMP_UNREACH },
	{ "squench",	ICMP_SOURCEQUENCH },
	{ "redir",	ICMP_REDIRECT },
	{ "althost",	ICMP_ALTHOSTADDR },
	{ "routeradv",	ICMP_ROUTERADVERT },
	{ "routersol",	ICMP_ROUTERSOLICIT },
	{ "timex",	ICMP_TIMXCEED },
	{ "paramprob",	ICMP_PARAMPROB },
	{ "timereq",	ICMP_TSTAMP },
	{ "timerep",	ICMP_TSTAMPREPLY },
	{ "inforeq",	ICMP_IREQ },
	{ "inforep",	ICMP_IREQREPLY },
	{ "maskreq",	ICMP_MASKREQ },
	{ "maskrep",	ICMP_MASKREPLY },
	{ "trace",	ICMP_TRACEROUTE },
	{ "dataconv",	ICMP_DATACONVERR },
	{ "mobredir",	ICMP_MOBILE_REDIRECT },
	{ "ipv6-where",	ICMP_IPV6_WHEREAREYOU },
	{ "ipv6-here",	ICMP_IPV6_IAMHERE },
	{ "mobregreq",	ICMP_MOBILE_REGREQUEST },
	{ "mobregrep",	ICMP_MOBILE_REGREPLY },
	{ "skip",	ICMP_SKIP },
	{ "photuris",	ICMP_PHOTURIS }
};

static const struct icmptypeent icmp6_type[] = {
	{ "unreach",	ICMP6_DST_UNREACH },
	{ "toobig",	ICMP6_PACKET_TOO_BIG },
	{ "timex",	ICMP6_TIME_EXCEEDED },
	{ "paramprob",	ICMP6_PARAM_PROB },
	{ "echoreq",	ICMP6_ECHO_REQUEST },
	{ "echorep",	ICMP6_ECHO_REPLY },
	{ "groupqry",	ICMP6_MEMBERSHIP_QUERY },
	{ "listqry",	MLD_LISTENER_QUERY },
	{ "grouprep",	ICMP6_MEMBERSHIP_REPORT },
	{ "listenrep",	MLD_LISTENER_REPORT },
	{ "groupterm",	ICMP6_MEMBERSHIP_REDUCTION },
	{ "listendone", MLD_LISTENER_DONE },
	{ "routersol",	ND_ROUTER_SOLICIT },
	{ "routeradv",	ND_ROUTER_ADVERT },
	{ "neighbrsol", ND_NEIGHBOR_SOLICIT },
	{ "neighbradv", ND_NEIGHBOR_ADVERT },
	{ "redir",	ND_REDIRECT },
	{ "routrrenum", ICMP6_ROUTER_RENUMBERING },
	{ "wrureq",	ICMP6_WRUREQUEST },
	{ "wrurep",	ICMP6_WRUREPLY },
	{ "fqdnreq",	ICMP6_FQDN_QUERY },
	{ "fqdnrep",	ICMP6_FQDN_REPLY },
	{ "niqry",	ICMP6_NI_QUERY },
	{ "nirep",	ICMP6_NI_REPLY },
	{ "mtraceresp",	MLD_MTRACE_RESP },
	{ "mtrace",	MLD_MTRACE }
};

static const struct icmpcodeent icmp_code[] = {
	{ "net-unr",		ICMP_UNREACH,	ICMP_UNREACH_NET },
	{ "host-unr",		ICMP_UNREACH,	ICMP_UNREACH_HOST },
	{ "proto-unr",		ICMP_UNREACH,	ICMP_UNREACH_PROTOCOL },
	{ "port-unr",		ICMP_UNREACH,	ICMP_UNREACH_PORT },
	{ "needfrag",		ICMP_UNREACH,	ICMP_UNREACH_NEEDFRAG },
	{ "srcfail",		ICMP_UNREACH,	ICMP_UNREACH_SRCFAIL },
	{ "net-unk",		ICMP_UNREACH,	ICMP_UNREACH_NET_UNKNOWN },
	{ "host-unk",		ICMP_UNREACH,	ICMP_UNREACH_HOST_UNKNOWN },
	{ "isolate",		ICMP_UNREACH,	ICMP_UNREACH_ISOLATED },
	{ "net-prohib",		ICMP_UNREACH,	ICMP_UNREACH_NET_PROHIB },
	{ "host-prohib",	ICMP_UNREACH,	ICMP_UNREACH_HOST_PROHIB },
	{ "net-tos",		ICMP_UNREACH,	ICMP_UNREACH_TOSNET },
	{ "host-tos",		ICMP_UNREACH,	ICMP_UNREACH_TOSHOST },
	{ "filter-prohib",	ICMP_UNREACH,	ICMP_UNREACH_FILTER_PROHIB },
	{ "host-preced",	ICMP_UNREACH,	ICMP_UNREACH_HOST_PRECEDENCE },
	{ "cutoff-preced",	ICMP_UNREACH,	ICMP_UNREACH_PRECEDENCE_CUTOFF },
	{ "redir-net",		ICMP_REDIRECT,	ICMP_REDIRECT_NET },
	{ "redir-host",		ICMP_REDIRECT,	ICMP_REDIRECT_HOST },
	{ "redir-tos-net",	ICMP_REDIRECT,	ICMP_REDIRECT_TOSNET },
	{ "redir-tos-host",	ICMP_REDIRECT,	ICMP_REDIRECT_TOSHOST },
	{ "normal-adv",		ICMP_ROUTERADVERT, ICMP_ROUTERADVERT_NORMAL },
	{ "common-adv",		ICMP_ROUTERADVERT, ICMP_ROUTERADVERT_NOROUTE_COMMON },
	{ "transit",		ICMP_TIMXCEED,	ICMP_TIMXCEED_INTRANS },
	{ "reassemb",		ICMP_TIMXCEED,	ICMP_TIMXCEED_REASS },
	{ "badhead",		ICMP_PARAMPROB,	ICMP_PARAMPROB_ERRATPTR },
	{ "optmiss",		ICMP_PARAMPROB,	ICMP_PARAMPROB_OPTABSENT },
	{ "badlen",		ICMP_PARAMPROB,	ICMP_PARAMPROB_LENGTH },
	{ "unknown-ind",	ICMP_PHOTURIS,	ICMP_PHOTURIS_UNKNOWN_INDEX },
	{ "auth-fail",		ICMP_PHOTURIS,	ICMP_PHOTURIS_AUTH_FAILED },
	{ "decrypt-fail",	ICMP_PHOTURIS,	ICMP_PHOTURIS_DECRYPT_FAILED }
};

static const struct icmpcodeent icmp6_code[] = {
	{ "admin-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADMIN },
	{ "noroute-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOROUTE },
	{ "notnbr-unr",	ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOTNEIGHBOR },
	{ "beyond-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_BEYONDSCOPE },
	{ "addr-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADDR },
	{ "port-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOPORT },
	{ "transit", ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_TRANSIT },
	{ "reassemb", ICMP6_TIME_EXCEEDED, ICMP6_TIME_EXCEED_REASSEMBLY },
	{ "badhead", ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER },
	{ "nxthdr", ICMP6_PARAM_PROB, ICMP6_PARAMPROB_NEXTHEADER },
	{ "redironlink", ND_REDIRECT, ND_REDIRECT_ONLINK },
	{ "redirrouter", ND_REDIRECT, ND_REDIRECT_ROUTER }
};

const struct pf_timeout pf_timeouts[] = {
	{ "tcp.first",		PFTM_TCP_FIRST_PACKET },
	{ "tcp.opening",	PFTM_TCP_OPENING },
	{ "tcp.established",	PFTM_TCP_ESTABLISHED },
	{ "tcp.closing",	PFTM_TCP_CLOSING },
	{ "tcp.finwait",	PFTM_TCP_FIN_WAIT },
	{ "tcp.closed",		PFTM_TCP_CLOSED },
	{ "tcp.tsdiff",		PFTM_TS_DIFF },
	{ "udp.first",		PFTM_UDP_FIRST_PACKET },
	{ "udp.single",		PFTM_UDP_SINGLE },
	{ "udp.multiple",	PFTM_UDP_MULTIPLE },
	{ "icmp.first",		PFTM_ICMP_FIRST_PACKET },
	{ "icmp.error",		PFTM_ICMP_ERROR_REPLY },
	{ "other.first",	PFTM_OTHER_FIRST_PACKET },
	{ "other.single",	PFTM_OTHER_SINGLE },
	{ "other.multiple",	PFTM_OTHER_MULTIPLE },
	{ "frag",		PFTM_FRAG },
	{ "interval",		PFTM_INTERVAL },
	{ "adaptive.start",	PFTM_ADAPTIVE_START },
	{ "adaptive.end",	PFTM_ADAPTIVE_END },
	{ "src.track",		PFTM_SRC_NODE },
	{ NULL,			0 }
};

enum { PF_POOL_ROUTE, PF_POOL_NAT, PF_POOL_RDR };

const struct icmptypeent *
geticmptypebynumber(u_int8_t type, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0]));
		    i++) {
			if (type == icmp_type[i].type)
				return (&icmp_type[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_type) /
		    sizeof(icmp6_type[0])); i++) {
			if (type == icmp6_type[i].type)
				 return (&icmp6_type[i]);
		}
	}
	return (NULL);
}

const struct icmptypeent *
geticmptypebyname(char *w, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0]));
		    i++) {
			if (!strcmp(w, icmp_type[i].name))
				return (&icmp_type[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_type) /
		    sizeof(icmp6_type[0])); i++) {
			if (!strcmp(w, icmp6_type[i].name))
				return (&icmp6_type[i]);
		}
	}
	return (NULL);
}

const struct icmpcodeent *
geticmpcodebynumber(u_int8_t type, u_int8_t code, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0]));
		    i++) {
			if (type == icmp_code[i].type &&
			    code == icmp_code[i].code)
				return (&icmp_code[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_code) /
		    sizeof(icmp6_code[0])); i++) {
			if (type == icmp6_code[i].type &&
			    code == icmp6_code[i].code)
				return (&icmp6_code[i]);
		}
	}
	return (NULL);
}

const struct icmpcodeent *
geticmpcodebyname(u_long type, char *w, sa_family_t af)
{
	unsigned int	i;

	if (af != AF_INET6) {
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0]));
		    i++) {
			if (type == icmp_code[i].type &&
			    !strcmp(w, icmp_code[i].name))
				return (&icmp_code[i]);
		}
	} else {
		for (i=0; i < (sizeof (icmp6_code) /
		    sizeof(icmp6_code[0])); i++) {
			if (type == icmp6_code[i].type &&
			    !strcmp(w, icmp6_code[i].name))
				return (&icmp6_code[i]);
		}
	}
	return (NULL);
}

/*
 *  Decode a symbolic name to a numeric value.
 *  From syslogd.
 */
int
string_to_loglevel(const char *name)
{
	CODE *c;
	char *p, buf[40];

	if (isdigit((unsigned char)*name)) {
		const char *errstr;
		int val;

		val = strtonum(name, 0, LOG_DEBUG, &errstr);
		if (errstr)
			return -1;
		return val;
	}

	for (p = buf; *name && p < &buf[sizeof(buf) - 1]; p++, name++) {
		if (isupper((unsigned char)*name))
			*p = tolower((unsigned char)*name);
		else
			*p = *name;
	}
	*p = '\0';
	for (c = prioritynames; c->c_name; c++)
		if (!strcmp(buf, c->c_name) && c->c_val != INTERNAL_NOPRI)
			return (c->c_val);

	return (-1);
}

const char *
loglevel_to_string(int level)
{
	CODE *c;

	for (c = prioritynames; c->c_name; c++)
		if (c->c_val == level)
			return (c->c_name);

	return ("unknown");
}

void
print_op(u_int8_t op, const char *a1, const char *a2)
{
	if (op == PF_OP_IRG)
		printf(" %s >< %s", a1, a2);
	else if (op == PF_OP_XRG)
		printf(" %s <> %s", a1, a2);
	else if (op == PF_OP_EQ)
		printf(" = %s", a1);
	else if (op == PF_OP_NE)
		printf(" != %s", a1);
	else if (op == PF_OP_LT)
		printf(" < %s", a1);
	else if (op == PF_OP_LE)
		printf(" <= %s", a1);
	else if (op == PF_OP_GT)
		printf(" > %s", a1);
	else if (op == PF_OP_GE)
		printf(" >= %s", a1);
	else if (op == PF_OP_RRG)
		printf(" %s:%s", a1, a2);
}

void
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, const char *proto, int opts)
{
	char		 a1[6], a2[6];
	struct servent	*s = NULL;

	if (opts & PF_OPT_PORTNAMES)
		s = getservbyport(p1, proto);
	p1 = ntohs(p1);
	p2 = ntohs(p2);
	snprintf(a1, sizeof(a1), "%u", p1);
	snprintf(a2, sizeof(a2), "%u", p2);
	printf(" port");
	if (s != NULL && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, s->s_name, a2);
	else
		print_op(op, a1, a2);
}

void
print_ugid(u_int8_t op, unsigned u1, unsigned u2, const char *t, unsigned umax)
{
	char	a1[11], a2[11];

	snprintf(a1, sizeof(a1), "%u", u1);
	snprintf(a2, sizeof(a2), "%u", u2);
	printf(" %s", t);
	if (u1 == umax && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, "unknown", a2);
	else
		print_op(op, a1, a2);
}

void
print_flags(u_int8_t f)
{
	int	i;

	for (i = 0; tcpflags[i]; ++i)
		if (f & (1 << i))
			printf("%c", tcpflags[i]);
}

void
print_fromto(struct pf_rule_addr *src, pf_osfp_t osfp, struct pf_rule_addr *dst,
    sa_family_t af, u_int8_t proto, int opts)
{
	char buf[PF_OSFP_LEN*3];
	int verbose = opts & (PF_OPT_VERBOSE2 | PF_OPT_DEBUG);
	if (src->addr.type == PF_ADDR_ADDRMASK &&
	    dst->addr.type == PF_ADDR_ADDRMASK &&
	    PF_AZERO(&src->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&src->addr.v.a.mask, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.mask, AF_INET6) &&
	    !src->neg && !dst->neg &&
	    !src->port_op && !dst->port_op &&
	    osfp == PF_OSFP_ANY)
		printf(" all");
	else {
		printf(" from ");
		if (src->neg)
			printf("! ");
		print_addr(&src->addr, af, verbose);
		if (src->port_op)
			print_port(src->port_op, src->port[0],
			    src->port[1],
			    proto == IPPROTO_TCP ? "tcp" : "udp", opts);
		if (osfp != PF_OSFP_ANY)
			printf(" os \"%s\"", pfctl_lookup_fingerprint(osfp, buf,
			    sizeof(buf)));

		printf(" to ");
		if (dst->neg)
			printf("! ");
		print_addr(&dst->addr, af, verbose);
		if (dst->port_op)
			print_port(dst->port_op, dst->port[0],
			    dst->port[1],
			    proto == IPPROTO_TCP ? "tcp" : "udp", opts);
	}
}

void
print_pool(struct pf_pool *pool, u_int16_t p1, u_int16_t p2,
    sa_family_t af, int id, int verbose)
{
	if (pool->ifname[0]) {
		if (!PF_AZERO(&pool->addr.v.a.addr, af)) {
			print_addr(&pool->addr, af, verbose);
			printf("@@");
		}
		printf("%s", pool->ifname);
	} else
		print_addr(&pool->addr, af, verbose);
	switch (id) {
	case PF_POOL_NAT:
		if ((p1 != PF_NAT_PROXY_PORT_LOW ||
		    p2 != PF_NAT_PROXY_PORT_HIGH) && (p1 != 0 || p2 != 0)) {
			if (p1 == p2)
				printf(" port %u", p1);
			else
				printf(" port %u:%u", p1, p2);
		}
		break;
	case PF_POOL_RDR:
		if (p1) {
			printf(" port %u", p1);
			if (p2 && (p2 != p1))
				printf(":%u", p2);
		}
		break;
	default:
		break;
	}
	switch (pool->opts & PF_POOL_TYPEMASK) {
	case PF_POOL_NONE:
		break;
	case PF_POOL_BITMASK:
		printf(" bitmask");
		break;
	case PF_POOL_RANDOM:
		printf(" random");
		break;
	case PF_POOL_SRCHASH:
		printf(" source-hash 0x%08x%08x%08x%08x",
		    pool->key.key32[0], pool->key.key32[1],
		    pool->key.key32[2], pool->key.key32[3]);
		break;
	case PF_POOL_ROUNDROBIN:
		printf(" round-robin");
		break;
	case PF_POOL_LEASTSTATES:
		printf(" least-states");
		break;
	}
	if (pool->opts & PF_POOL_STICKYADDR)
		printf(" sticky-address");
	if (id == PF_POOL_NAT && p1 == 0 && p2 == 0)
		printf(" static-port");
}

const char	*pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
const char	*pf_lcounters[LCNT_MAX+1] = LCNT_NAMES;
const char	*pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
const char	*pf_scounters[FCNT_MAX+1] = FCNT_NAMES;

void
print_status(struct pf_status *s, int opts)
{
	char			statline[80], *running, *debug;
	time_t			runtime = 0;
	struct timespec		uptime;
	int			i;
	char			buf[PF_MD5_DIGEST_LENGTH * 2 + 1];
	static const char	hex[] = "0123456789abcdef";

	if (!clock_gettime(CLOCK_UPTIME, &uptime))
		runtime = uptime.tv_sec - s->since;
	running = s->running ? "Enabled" : "Disabled";

	if (runtime) {
		unsigned int	sec, min, hrs;
		time_t		day = runtime;

		sec = day % 60;
		day /= 60;
		min = day % 60;
		day /= 60;
		hrs = day % 24;
		day /= 24;
		snprintf(statline, sizeof(statline),
		    "Status: %s for %lld days %.2u:%.2u:%.2u",
		    running, (long long)day, hrs, min, sec);
	} else
		snprintf(statline, sizeof(statline), "Status: %s", running);
	printf("%-44s", statline);
	if (asprintf(&debug, "Debug: %s", loglevel_to_string(s->debug)) != -1) {
		printf("%15s\n\n", debug);
		free(debug);
	}

	if (opts & PF_OPT_VERBOSE) {
		printf("Hostid:   0x%08x\n", ntohl(s->hostid));

		for (i = 0; i < PF_MD5_DIGEST_LENGTH; i++) {
			buf[i + i] = hex[s->pf_chksum[i] >> 4];
			buf[i + i + 1] = hex[s->pf_chksum[i] & 0x0f];
		}
		buf[i + i] = '\0';
		printf("Checksum: 0x%s\n\n", buf);
	}

	if (s->ifname[0] != 0) {
		printf("Interface Stats for %-16s %5s %16s\n",
		    s->ifname, "IPv4", "IPv6");
		printf("  %-25s %14llu %16llu\n", "Bytes In",
		    (unsigned long long)s->bcounters[0][0],
		    (unsigned long long)s->bcounters[1][0]);
		printf("  %-25s %14llu %16llu\n", "Bytes Out",
		    (unsigned long long)s->bcounters[0][1],
		    (unsigned long long)s->bcounters[1][1]);
		printf("  Packets In\n");
		printf("    %-23s %14llu %16llu\n", "Passed",
		    (unsigned long long)s->pcounters[0][0][PF_PASS],
		    (unsigned long long)s->pcounters[1][0][PF_PASS]);
		printf("    %-23s %14llu %16llu\n", "Blocked",
		    (unsigned long long)s->pcounters[0][0][PF_DROP],
		    (unsigned long long)s->pcounters[1][0][PF_DROP]);
		printf("  Packets Out\n");
		printf("    %-23s %14llu %16llu\n", "Passed",
		    (unsigned long long)s->pcounters[0][1][PF_PASS],
		    (unsigned long long)s->pcounters[1][1][PF_PASS]);
		printf("    %-23s %14llu %16llu\n\n", "Blocked",
		    (unsigned long long)s->pcounters[0][1][PF_DROP],
		    (unsigned long long)s->pcounters[1][1][PF_DROP]);
	}
	printf("%-27s %14s %16s\n", "State Table", "Total", "Rate");
	printf("  %-25s %14u %14s\n", "current entries", s->states, "");
	for (i = 0; i < FCNT_MAX; i++) {
		printf("  %-25s %14llu ", pf_fcounters[i],
			    (unsigned long long)s->fcounters[i]);
		if (runtime > 0)
			printf("%14.1f/s\n",
			    (double)s->fcounters[i] / (double)runtime);
		else
			printf("%14s\n", "");
	}
	if (opts & PF_OPT_VERBOSE) {
		printf("Source Tracking Table\n");
		printf("  %-25s %14u %14s\n", "current entries",
		    s->src_nodes, "");
		for (i = 0; i < SCNT_MAX; i++) {
			printf("  %-25s %14lld ", pf_scounters[i],
				    s->scounters[i]);
			if (runtime > 0)
				printf("%14.1f/s\n",
				    (double)s->scounters[i] / (double)runtime);
			else
				printf("%14s\n", "");
		}
	}
	printf("Counters\n");
	for (i = 0; i < PFRES_MAX; i++) {
		printf("  %-25s %14llu ", pf_reasons[i],
		    (unsigned long long)s->counters[i]);
		if (runtime > 0)
			printf("%14.1f/s\n",
			    (double)s->counters[i] / (double)runtime);
		else
			printf("%14s\n", "");
	}
	if (opts & PF_OPT_VERBOSE) {
		printf("Limit Counters\n");
		for (i = 0; i < LCNT_MAX; i++) {
			printf("  %-25s %14lld ", pf_lcounters[i],
				    s->lcounters[i]);
			if (runtime > 0)
				printf("%14.1f/s\n",
				    (double)s->lcounters[i] / (double)runtime);
			else
				printf("%14s\n", "");
		}
	}
}

void
print_src_node(struct pf_src_node *sn, int opts)
{
	struct pf_addr_wrap aw;
	int min, sec;

	memset(&aw, 0, sizeof(aw));
	if (sn->af == AF_INET)
		aw.v.a.mask.addr32[0] = 0xffffffff;
	else
		memset(&aw.v.a.mask, 0xff, sizeof(aw.v.a.mask));

	aw.v.a.addr = sn->addr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);

	if (!PF_AZERO(&sn->raddr, sn->af)) {
		if (sn->type == PF_SN_NAT)
			printf(" nat-to ");
		else if (sn->type == PF_SN_RDR)
			printf(" rdr-to ");
		else if (sn->type == PF_SN_ROUTE)
			printf(" route-to ");
		else
			printf(" ??? (%u) ", sn->type);
		aw.v.a.addr = sn->raddr;
		print_addr(&aw, sn->naf ? sn->naf : sn->af,
		    opts & PF_OPT_VERBOSE2);
	}

	printf(" ( states %u, connections %u, rate %u.%u/%us )\n", sn->states,
	    sn->conn, sn->conn_rate.count / 1000,
	    (sn->conn_rate.count % 1000) / 100, sn->conn_rate.seconds);
	if (opts & PF_OPT_VERBOSE) {
		sec = sn->creation % 60;
		sn->creation /= 60;
		min = sn->creation % 60;
		sn->creation /= 60;
		printf("   age %.2u:%.2u:%.2u", sn->creation, min, sec);
		if (sn->states == 0) {
			sec = sn->expire % 60;
			sn->expire /= 60;
			min = sn->expire % 60;
			sn->expire /= 60;
			printf(", expires in %.2u:%.2u:%.2u",
			    sn->expire, min, sec);
		}
		printf(", %llu pkts, %llu bytes",
		    sn->packets[0] + sn->packets[1],
		    sn->bytes[0] + sn->bytes[1]);
		if (sn->rule.nr != -1)
			printf(", rule %u", sn->rule.nr);
		printf("\n");
	}
}

void
print_rule(struct pf_rule *r, const char *anchor_call, int opts)
{
	static const char *actiontypes[] = { "pass", "block", "scrub",
	    "no scrub", "nat", "no nat", "binat", "no binat", "rdr", "no rdr",
	    "", "", "match"};
	static const char *anchortypes[] = { "anchor", "anchor", "anchor",
	    "anchor", "nat-anchor", "nat-anchor", "binat-anchor",
	    "binat-anchor", "rdr-anchor", "rdr-anchor" };
	int	i, ropts;
	int	verbose = opts & (PF_OPT_VERBOSE2 | PF_OPT_DEBUG);
	char	*p;

	if ((r->rule_flag & PFRULE_EXPIRED) && (!verbose))
		return;

	if (verbose)
		printf("@@%d ", r->nr);

	if (r->action > PF_MATCH)
		printf("action(%d)", r->action);
	else if (anchor_call[0]) {
		p = strrchr(anchor_call, '/');
		if (p ? p[1] == '_' : anchor_call[0] == '_')
			printf("%s", anchortypes[r->action]);
		else
			printf("%s \"%s\"", anchortypes[r->action],
			    anchor_call);
	} else
		printf("%s", actiontypes[r->action]);
	if (r->action == PF_DROP) {
		if (r->rule_flag & PFRULE_RETURN)
			printf(" return");
		else if (r->rule_flag & PFRULE_RETURNRST) {
			if (!r->return_ttl)
				printf(" return-rst");
			else
				printf(" return-rst(ttl %d)", r->return_ttl);
		} else if (r->rule_flag & PFRULE_RETURNICMP) {
			const struct icmpcodeent	*ic, *ic6;

			ic = geticmpcodebynumber(r->return_icmp >> 8,
			    r->return_icmp & 255, AF_INET);
			ic6 = geticmpcodebynumber(r->return_icmp6 >> 8,
			    r->return_icmp6 & 255, AF_INET6);

			switch (r->af) {
			case AF_INET:
				printf(" return-icmp");
				if (ic == NULL)
					printf("(%u)", r->return_icmp & 255);
				else
					printf("(%s)", ic->name);
				break;
			case AF_INET6:
				printf(" return-icmp6");
				if (ic6 == NULL)
					printf("(%u)", r->return_icmp6 & 255);
				else
					printf("(%s)", ic6->name);
				break;
			default:
				printf(" return-icmp");
				if (ic == NULL)
					printf("(%u, ", r->return_icmp & 255);
				else
					printf("(%s, ", ic->name);
				if (ic6 == NULL)
					printf("%u)", r->return_icmp6 & 255);
				else
					printf("%s)", ic6->name);
				break;
			}
		} else
			printf(" drop");
	}
	if (r->direction == PF_IN)
		printf(" in");
	else if (r->direction == PF_OUT)
		printf(" out");
	if (r->log) {
		printf(" log");
		if (r->log & ~PF_LOG || r->logif) {
			int count = 0;

			printf(" (");
			if (r->log & PF_LOG_ALL)
				printf("%sall", count++ ? ", " : "");
			if (r->log & PF_LOG_MATCHES)
				printf("%smatches", count++ ? ", " : "");
			if (r->log & PF_LOG_SOCKET_LOOKUP)
				printf("%suser", count++ ? ", " : "");
			if (r->logif)
				printf("%sto pflog%u", count++ ? ", " : "",
				    r->logif);
			printf(")");
		}
	}
	if (r->quick)
		printf(" quick");
	if (r->ifname[0]) {
		if (r->ifnot)
			printf(" on ! %s", r->ifname);
		else
			printf(" on %s", r->ifname);
	}
	if (r->onrdomain >= 0) {
		if (r->ifnot)
			printf(" on ! rdomain %d", r->onrdomain);
		else
			printf(" on rdomain %d", r->onrdomain);
	}
	if (r->af) {
		if (r->af == AF_INET)
			printf(" inet");
		else
			printf(" inet6");
	}
	if (r->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(r->proto)) != NULL)
			printf(" proto %s", p->p_name);
		else
			printf(" proto %u", r->proto);
	}
	print_fromto(&r->src, r->os_fingerprint, &r->dst, r->af, r->proto,
	    opts);
	if (r->rcv_ifname[0])
		printf(" %sreceived-on %s", r->rcvifnot ? "!" : "",
		    r->rcv_ifname);
	if (r->uid.op)
		print_ugid(r->uid.op, r->uid.uid[0], r->uid.uid[1], "user",
		    UID_MAX);
	if (r->gid.op)
		print_ugid(r->gid.op, r->gid.gid[0], r->gid.gid[1], "group",
		    GID_MAX);
	if (r->flags || r->flagset) {
		printf(" flags ");
		print_flags(r->flags);
		printf("/");
		print_flags(r->flagset);
	} else if ((r->action == PF_PASS || r->action == PF_MATCH) &&
	    (!r->proto || r->proto == IPPROTO_TCP) &&
	    !(r->rule_flag & PFRULE_FRAGMENT) &&
	    !anchor_call[0] && r->keep_state)
		printf(" flags any");
	if (r->type) {
		const struct icmptypeent	*it;

		it = geticmptypebynumber(r->type-1, r->af);
		if (r->af != AF_INET6)
			printf(" icmp-type");
		else
			printf(" icmp6-type");
		if (it != NULL)
			printf(" %s", it->name);
		else
			printf(" %u", r->type-1);
		if (r->code) {
			const struct icmpcodeent	*ic;

			ic = geticmpcodebynumber(r->type-1, r->code-1, r->af);
			if (ic != NULL)
				printf(" code %s", ic->name);
			else
				printf(" code %u", r->code-1);
		}
	}
	if (r->tos)
		printf(" tos 0x%2.2x", r->tos);
	if (r->prio)
		printf(" prio %u", r->prio == PF_PRIO_ZERO ? 0 : r->prio);

	if (r->scrub_flags & PFSTATE_SETMASK || r->qname[0]) {
		char *comma = "";
		printf(" set (");
		if (r->scrub_flags & PFSTATE_SETPRIO) {
			if (r->set_prio[0] == r->set_prio[1])
				printf("%s prio %u", comma, r->set_prio[0]);
			else
				printf("%s prio(%u, %u)", comma, r->set_prio[0],
				    r->set_prio[1]);
			comma = ",";
		}
		if (r->qname[0]) {
			if (r->pqname[0])
				printf("%s queue(%s, %s)", comma, r->qname,
				    r->pqname);
			else
				printf("%s queue %s", comma, r->qname);
			comma = ",";
		}
		if (r->scrub_flags & PFSTATE_SETTOS) {
			printf("%s tos 0x%2.2x", comma, r->set_tos);
			comma = ",";
		}
		printf(" )");
	}

	ropts = 0;
	if (r->max_states || r->max_src_nodes || r->max_src_states)
		ropts = 1;
	if (r->rule_flag & PFRULE_NOSYNC)
		ropts = 1;
	if (r->rule_flag & PFRULE_SRCTRACK)
		ropts = 1;
	if (r->rule_flag & PFRULE_IFBOUND)
		ropts = 1;
	if (r->rule_flag & PFRULE_STATESLOPPY)
		ropts = 1;
	if (r->rule_flag & PFRULE_PFLOW)
		ropts = 1;
	for (i = 0; !ropts && i < PFTM_MAX; ++i)
		if (r->timeout[i])
			ropts = 1;

	if (!r->keep_state && r->action == PF_PASS && !anchor_call[0])
		printf(" no state");
	else if (r->keep_state == PF_STATE_NORMAL && ropts)
		printf(" keep state");
	else if (r->keep_state == PF_STATE_MODULATE)
		printf(" modulate state");
	else if (r->keep_state == PF_STATE_SYNPROXY)
		printf(" synproxy state");
	if (r->prob) {
		char	buf[20];

		snprintf(buf, sizeof(buf), "%f", r->prob*100.0/(UINT_MAX+1.0));
		for (i = strlen(buf)-1; i > 0; i--) {
			if (buf[i] == '0')
				buf[i] = '\0';
			else {
				if (buf[i] == '.')
					buf[i] = '\0';
				break;
			}
		}
		printf(" probability %s%%", buf);
	}
	if (ropts) {
		printf(" (");
		if (r->max_states) {
			printf("max %u", r->max_states);
			ropts = 0;
		}
		if (r->rule_flag & PFRULE_NOSYNC) {
			if (!ropts)
				printf(", ");
			printf("no-sync");
			ropts = 0;
		}
		if (r->rule_flag & PFRULE_SRCTRACK) {
			if (!ropts)
				printf(", ");
			printf("source-track");
			if (r->rule_flag & PFRULE_RULESRCTRACK)
				printf(" rule");
			else
				printf(" global");
			ropts = 0;
		}
		if (r->max_src_states) {
			if (!ropts)
				printf(", ");
			printf("max-src-states %u", r->max_src_states);
			ropts = 0;
		}
		if (r->max_src_conn) {
			if (!ropts)
				printf(", ");
			printf("max-src-conn %u", r->max_src_conn);
			ropts = 0;
		}
		if (r->max_src_conn_rate.limit) {
			if (!ropts)
				printf(", ");
			printf("max-src-conn-rate %u/%u",
			    r->max_src_conn_rate.limit,
			    r->max_src_conn_rate.seconds);
			ropts = 0;
		}
		if (r->max_src_nodes) {
			if (!ropts)
				printf(", ");
			printf("max-src-nodes %u", r->max_src_nodes);
			ropts = 0;
		}
		if (r->overload_tblname[0]) {
			if (!ropts)
				printf(", ");
			printf("overload <%s>", r->overload_tblname);
			if (r->flush)
				printf(" flush");
			if (r->flush & PF_FLUSH_GLOBAL)
				printf(" global");
		}
		if (r->rule_flag & PFRULE_IFBOUND) {
			if (!ropts)
				printf(", ");
			printf("if-bound");
			ropts = 0;
		}
		if (r->rule_flag & PFRULE_STATESLOPPY) {
			if (!ropts)
				printf(", ");
			printf("sloppy");
			ropts = 0;
		}
		if (r->rule_flag & PFRULE_PFLOW) {
			if (!ropts)
				printf(", ");
			printf("pflow");
			ropts = 0;
		}
		for (i = 0; i < PFTM_MAX; ++i)
			if (r->timeout[i]) {
				int j;

				if (!ropts)
					printf(", ");
				ropts = 0;
				for (j = 0; pf_timeouts[j].name != NULL;
				    ++j)
					if (pf_timeouts[j].timeout == i)
						break;
				printf("%s %u", pf_timeouts[j].name == NULL ?
				    "inv.timeout" : pf_timeouts[j].name,
				    r->timeout[i]);
			}
		printf(")");
	}

	if (r->rule_flag & PFRULE_FRAGMENT)
		printf(" fragment");

	if (r->scrub_flags & PFSTATE_SCRUBMASK || r->min_ttl || r->max_mss) {
		printf(" scrub (");
		ropts = 1;
		if (r->scrub_flags & PFSTATE_NODF) {
			printf("no-df");
			ropts = 0;
		}
		if (r->scrub_flags & PFSTATE_RANDOMID) {
			if (!ropts)
				printf(" ");
			printf("random-id");
			ropts = 0;
		}
		if (r->min_ttl) {
			if (!ropts)
				printf(" ");
			printf("min-ttl %d", r->min_ttl);
			ropts = 0;
		}
		if (r->scrub_flags & PFSTATE_SCRUB_TCP) {
			if (!ropts)
				printf(" ");
			printf("reassemble tcp");
			ropts = 0;
		}
		if (r->max_mss) {
			if (!ropts)
				printf(" ");
			printf("max-mss %d", r->max_mss);
			ropts = 0;
		}
		printf(")");
	}

	if (r->allow_opts)
		printf(" allow-opts");
	if (r->label[0])
		printf(" label \"%s\"", r->label);
	if (r->rule_flag & PFRULE_ONCE)
		printf(" once");
	if (r->tagname[0])
		printf(" tag %s", r->tagname);
	if (r->match_tagname[0]) {
		if (r->match_tag_not)
			printf(" !");
		printf(" tagged %s", r->match_tagname);
	}
	if (r->rtableid != -1)
		printf(" rtable %u", r->rtableid);
	if (r->divert.port) {
		if (PF_AZERO(&r->divert.addr, AF_INET6)) {
			printf(" divert-reply");
		} else {
			/* XXX cut&paste from print_addr */
			char buf[48];

			printf(" divert-to ");
			if (inet_ntop(r->af, &r->divert.addr, buf,
			    sizeof(buf)) == NULL)
				printf("?");
			else
				printf("%s", buf);
			printf(" port %u", ntohs(r->divert.port));
		}
	}
	if (r->divert_packet.port)
		printf(" divert-packet port %u", ntohs(r->divert_packet.port));

	if (!anchor_call[0] && r->nat.addr.type != PF_ADDR_NONE &&
	    r->rule_flag & PFRULE_AFTO) {
		printf(" af-to %s from ", r->naf == AF_INET ? "inet" : "inet6");
		print_pool(&r->nat, r->nat.proxy_port[0],
		    r->nat.proxy_port[1], r->naf ? r->naf : r->af,
		    PF_POOL_NAT, verbose);
		if (r->rdr.addr.type != PF_ADDR_NONE) {
			printf(" to ");
			print_pool(&r->rdr, r->rdr.proxy_port[0],
			    r->rdr.proxy_port[1], r->naf ? r->naf : r->af,
			    PF_POOL_RDR, verbose);
		}
	} else if (!anchor_call[0] && r->nat.addr.type != PF_ADDR_NONE) {
		printf (" nat-to ");
		print_pool(&r->nat, r->nat.proxy_port[0],
		    r->nat.proxy_port[1], r->naf ? r->naf : r->af,
		    PF_POOL_NAT, verbose);
	} else if (!anchor_call[0] && r->rdr.addr.type != PF_ADDR_NONE) {
		printf (" rdr-to ");
		print_pool(&r->rdr, r->rdr.proxy_port[0],
		    r->rdr.proxy_port[1], r->af, PF_POOL_RDR, verbose);
	}
	if (r->rt) {
		if (r->rt == PF_ROUTETO)
			printf(" route-to");
		else if (r->rt == PF_REPLYTO)
			printf(" reply-to");
		else if (r->rt == PF_DUPTO)
			printf(" dup-to");
		printf(" ");
		print_pool(&r->route, 0, 0, r->af, PF_POOL_ROUTE, verbose);
	}
}

void
print_tabledef(const char *name, int flags, int addrs,
    struct node_tinithead *nodes)
{
	struct node_tinit	*ti, *nti;
	struct node_host	*h;

	printf("table <%s>", name);
	if (flags & PFR_TFLAG_CONST)
		printf(" const");
	if (flags & PFR_TFLAG_PERSIST)
		printf(" persist");
	if (flags & PFR_TFLAG_COUNTERS)
		printf(" counters");
	SIMPLEQ_FOREACH(ti, nodes, entries) {
		if (ti->file) {
			printf(" file \"%s\"", ti->file);
			continue;
		}
		printf(" {");
		for (;;) {
			for (h = ti->host; h != NULL; h = h->next) {
				printf(h->not ? " !" : " ");
				print_addr(&h->addr, h->af, 0);
				if (h->ifname)
					printf("@@%s", h->ifname);
			}
			nti = SIMPLEQ_NEXT(ti, entries);
			if (nti != NULL && nti->file == NULL)
				ti = nti;	/* merge lists */
			else
				break;
		}
		printf(" }");
	}
	if (addrs && SIMPLEQ_EMPTY(nodes))
		printf(" { }");
	printf("\n");
}

void
print_bwspec(const char *prefix, struct pf_queue_bwspec *bw)
{
	u_int	rate;
	int	i;
	static const char unit[] = " KMG";

	if (bw->percent)
		printf("%s%u%%", prefix, bw->percent);
	else if (bw->absolute) {
		rate = bw->absolute;
		for (i = 0; rate >= 1000 && i <= 3 && (rate % 1000 == 0); i++)
			rate /= 1000;
		printf("%s%u%c", prefix, rate, unit[i]);
	}
}

void
print_scspec(const char *prefix, struct pf_queue_scspec *sc)
{
	print_bwspec(prefix, &sc->m2);
	if (sc->d) {
		printf(" burst ");
		print_bwspec("", &sc->m1);
		printf(" for %ums", sc->d);
	}
}

void
print_queuespec(struct pf_queuespec *q)
{
	printf("queue %s", q->qname);
	if (q->parent[0])
		printf(" parent %s", q->parent);
	else if (q->ifname[0])
		printf(" on %s", q->ifname);
	if (q->flags & PFQS_FLOWQUEUE) {
		printf(" flows %u", q->flowqueue.flows);
		if (q->flowqueue.quantum > 0)
			printf(" quantum %u", q->flowqueue.quantum);
		if (q->flowqueue.interval > 0)
			printf(" interval %ums",
			    q->flowqueue.interval / 1000000);
		if (q->flowqueue.target > 0)
			printf(" target %ums",
			    q->flowqueue.target / 1000000);
	}
	if (q->linkshare.m1.absolute || q->linkshare.m2.absolute) {
		print_scspec(" bandwidth ", &q->linkshare);
		print_scspec(", min ", &q->realtime);
		print_scspec(", max ", &q->upperlimit);
	}
	if (q->flags & PFQS_DEFAULT)
		printf(" default");
	if (q->qlimit)
		printf(" qlimit %u", q->qlimit);
	printf("\n");
}

int
parse_flags(char *s)
{
	char		*p, *q;
	u_int8_t	 f = 0;

	for (p = s; *p; p++) {
		if ((q = strchr(tcpflags, *p)) == NULL)
			return -1;
		else
			f |= 1 << (q - tcpflags);
	}
	return (f ? f : PF_TH_ALL);
}

void
set_ipmask(struct node_host *h, u_int8_t b)
{
	struct pf_addr	*m, *n;
	int		 i, j = 0;

	m = &h->addr.v.a.mask;
	memset(m, 0, sizeof(*m));

	while (b >= 32) {
		m->addr32[j++] = 0xffffffff;
		b -= 32;
	}
	for (i = 31; i > 31-b; --i)
		m->addr32[j] |= (1 << i);
	if (b)
		m->addr32[j] = htonl(m->addr32[j]);

	/* Mask off bits of the address that will never be used. */
	n = &h->addr.v.a.addr;
	if (h->addr.type == PF_ADDR_ADDRMASK)
		for (i = 0; i < 4; i++)
			n->addr32[i] = n->addr32[i] & m->addr32[i];
}

int
check_netmask(struct node_host *h, sa_family_t af)
{
	struct node_host	*n = NULL;
	struct pf_addr		*m;

	for (n = h; n != NULL; n = n->next) {
		if (h->addr.type == PF_ADDR_TABLE)
			continue;
		m = &h->addr.v.a.mask;
		/* netmasks > 32 bit are invalid on v4 */
		if (af == AF_INET &&
		    (m->addr32[1] || m->addr32[2] || m->addr32[3])) {
			fprintf(stderr, "netmask %u invalid for IPv4 address\n",
			    unmask(m, AF_INET6));
			return (1);
		}
	}
	return (0);
}

struct node_host *
gen_dynnode(struct node_host *h, sa_family_t af)
{
	struct node_host	*n;
	struct pf_addr		*m;

	if (h->addr.type != PF_ADDR_DYNIFTL)
		return (NULL);

	if ((n = calloc(1, sizeof(*n))) == NULL)
		return (NULL);
	bcopy(h, n, sizeof(*n));
	n->ifname = NULL;
	n->next = NULL;
	n->tail = NULL;

	/* fix up netmask */
	m = &n->addr.v.a.mask;
	if (af == AF_INET && unmask(m, AF_INET6) > 32)
		set_ipmask(n, 32);

	return (n);
}

/* interface lookup routines */

struct node_host	*iftab;

void
ifa_load(void)
{
	struct ifaddrs		*ifap, *ifa;
	struct node_host	*n = NULL, *h = NULL;

	if (getifaddrs(&ifap) < 0)
		err(1, "getifaddrs");

	for (ifa = ifap; ifa; ifa = ifa->ifa_next) {
		if (!(ifa->ifa_addr->sa_family == AF_INET ||
		    ifa->ifa_addr->sa_family == AF_INET6 ||
		    ifa->ifa_addr->sa_family == AF_LINK))
				continue;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = ifa->ifa_addr->sa_family;
		n->ifa_flags = ifa->ifa_flags;
#ifdef __KAME__
		if (n->af == AF_INET6 &&
		    IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)
		    ifa->ifa_addr)->sin6_addr) &&
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id ==
		    0) {
			struct sockaddr_in6	*sin6;

			sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
			sin6->sin6_scope_id = sin6->sin6_addr.s6_addr[2] << 8 |
			    sin6->sin6_addr.s6_addr[3];
			sin6->sin6_addr.s6_addr[2] = 0;
			sin6->sin6_addr.s6_addr[3] = 0;
		}
#endif
		n->ifindex = 0;
		if (n->af == AF_INET) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in *)
			    ifa->ifa_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in *)
			    ifa->ifa_netmask)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in *)
				    ifa->ifa_broadaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
			if (ifa->ifa_dstaddr != NULL)
				memcpy(&n->peer, &((struct sockaddr_in *)
				    ifa->ifa_dstaddr)->sin_addr.s_addr,
				    sizeof(struct in_addr));
		} else if (n->af == AF_INET6) {
			memcpy(&n->addr.v.a.addr, &((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			memcpy(&n->addr.v.a.mask, &((struct sockaddr_in6 *)
			    ifa->ifa_netmask)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			if (ifa->ifa_broadaddr != NULL)
				memcpy(&n->bcast, &((struct sockaddr_in6 *)
				    ifa->ifa_broadaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			if (ifa->ifa_dstaddr != NULL)
				 memcpy(&n->peer, &((struct sockaddr_in6 *)
				    ifa->ifa_dstaddr)->sin6_addr.s6_addr,
				    sizeof(struct in6_addr));
			n->ifindex = ((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_scope_id;
		} else if (n->af == AF_LINK) {
			n->ifindex = ((struct sockaddr_dl *)
			    ifa->ifa_addr)->sdl_index;
		}
		if ((n->ifname = strdup(ifa->ifa_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

	iftab = h;
	freeifaddrs(ifap);
}

unsigned int
ifa_nametoindex(const char *ifa_name)
{
	struct node_host	*p;

	for (p = iftab; p; p = p->next) {
		if (p->af == AF_LINK && strcmp(p->ifname, ifa_name) == 0)
			return (p->ifindex);
	}
	errno = ENXIO;
	return (0);
}

char *
ifa_indextoname(unsigned int ifindex, char *ifa_name)
{
	struct node_host	*p;

	for (p = iftab; p; p = p->next) {
		if (p->af == AF_LINK && ifindex == p->ifindex) {
			strlcpy(ifa_name, p->ifname, IFNAMSIZ);
			return (ifa_name);
		}
	}
	errno = ENXIO;
	return (NULL);
}

struct node_host *
ifa_exists(const char *ifa_name)
{
	struct node_host	*n;
	struct ifgroupreq	ifgr;
	int			s;

	if (iftab == NULL)
		ifa_load();

	/* check whether this is a group */
	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "socket");
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, ifa_name, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == 0) {
		/* fake a node_host */
		if ((n = calloc(1, sizeof(*n))) == NULL)
			err(1, "calloc");
		if ((n->ifname = strdup(ifa_name)) == NULL)
			err(1, "strdup");
		close(s);
		return (n);
	}
	close(s);

	for (n = iftab; n; n = n->next) {
		if (n->af == AF_LINK && !strncmp(n->ifname, ifa_name, IFNAMSIZ))
			return (n);
	}

	return (NULL);
}

struct node_host *
ifa_grouplookup(const char *ifa_name, int flags)
{
	struct ifg_req		*ifg;
	struct ifgroupreq	 ifgr;
	int			 s, len;
	struct node_host	*n, *h = NULL;

	if ((s = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err(1, "socket");
	bzero(&ifgr, sizeof(ifgr));
	strlcpy(ifgr.ifgr_name, ifa_name, sizeof(ifgr.ifgr_name));
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1) {
		close(s);
		return (NULL);
	}

	len = ifgr.ifgr_len;
	if ((ifgr.ifgr_groups = calloc(1, len)) == NULL)
		err(1, "calloc");
	if (ioctl(s, SIOCGIFGMEMB, (caddr_t)&ifgr) == -1)
		err(1, "SIOCGIFGMEMB");

	for (ifg = ifgr.ifgr_groups; ifg && len >= sizeof(struct ifg_req);
	    ifg++) {
		len -= sizeof(struct ifg_req);
		if ((n = ifa_lookup(ifg->ifgrq_member, flags)) == NULL)
			continue;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n->tail;
		}
	}
	free(ifgr.ifgr_groups);
	close(s);

	return (h);
}

struct node_host *
ifa_lookup(const char *ifa_name, int flags)
{
	struct node_host	*p = NULL, *h = NULL, *n = NULL;
	int			 got4 = 0, got6 = 0;
	const char		 *last_if = NULL;

	if ((h = ifa_grouplookup(ifa_name, flags)) != NULL)
		return (h);

	if (!strncmp(ifa_name, "self", IFNAMSIZ))
		ifa_name = NULL;

	if (iftab == NULL)
		ifa_load();

	for (p = iftab; p; p = p->next) {
		if (ifa_skip_if(ifa_name, p))
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) && p->af != AF_INET)
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) &&
		    !(p->ifa_flags & IFF_BROADCAST))
			continue;
		if ((flags & PFI_AFLAG_BROADCAST) && p->bcast.v4.s_addr == 0)
			continue;
		if ((flags & PFI_AFLAG_PEER) &&
		    !(p->ifa_flags & IFF_POINTOPOINT))
			continue;
		if ((flags & PFI_AFLAG_NETWORK) && p->ifindex > 0)
			continue;
		if (last_if == NULL || strcmp(last_if, p->ifname))
			got4 = got6 = 0;
		last_if = p->ifname;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET && got4)
			continue;
		if ((flags & PFI_AFLAG_NOALIAS) && p->af == AF_INET6 && got6)
			continue;
		if (p->af == AF_INET)
			got4 = 1;
		else
			got6 = 1;
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = p->af;
		if (flags & PFI_AFLAG_BROADCAST)
			memcpy(&n->addr.v.a.addr, &p->bcast,
			    sizeof(struct pf_addr));
		else if (flags & PFI_AFLAG_PEER)
			memcpy(&n->addr.v.a.addr, &p->peer,
			    sizeof(struct pf_addr));
		else
			memcpy(&n->addr.v.a.addr, &p->addr.v.a.addr,
			    sizeof(struct pf_addr));
		if (flags & PFI_AFLAG_NETWORK)
			set_ipmask(n, unmask(&p->addr.v.a.mask, n->af));
		else {
			if (n->af == AF_INET) {
				if (p->ifa_flags & IFF_LOOPBACK &&
				    p->ifa_flags & IFF_LINK1)
					memcpy(&n->addr.v.a.mask,
					    &p->addr.v.a.mask,
					    sizeof(struct pf_addr));
				else
					set_ipmask(n, 32);
			} else
				set_ipmask(n, 128);
		}
		n->ifindex = p->ifindex;

		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	return (h);
}

int
ifa_skip_if(const char *filter, struct node_host *p)
{
	int	n;

	if (p->af != AF_INET && p->af != AF_INET6)
		return (1);
	if (filter == NULL || !*filter)
		return (0);
	if (!strcmp(p->ifname, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);	/* only do exact match in that case */
	if (strncmp(p->ifname, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->ifname[n] < '0' || p->ifname[n] > '9');
}

struct node_host *
host(const char *s)
{
	struct node_host	*h = NULL, *n;
	int			 mask = -1, v4mask = 32, v6mask = 128, cont = 1;
	char			*p, *q, *r, *ps, *if_name;

	if ((ps = strdup(s)) == NULL)
		err(1, "host: strdup");

	if ((if_name = strrchr(ps, '@@')) != NULL) {
		if_name[0] = '\0';
		if_name++;
	}

	if ((p = strrchr(ps, '/')) != NULL) {
		if ((r = strdup(ps)) == NULL)
			err(1, "host: strdup");
		mask = strtol(p+1, &q, 0);
		if (!q || *q || mask > 128 || q == (p+1)) {
			fprintf(stderr, "invalid netmask '%s'\n", p);
			free(r);
			free(ps);
			return (NULL);
		}
		p[0] = '\0';
		v4mask = v6mask = mask;
	} else
		r = ps;

	/* interface with this name exists? */
	if (cont && (h = host_if(ps, mask)) != NULL)
		cont = 0;

	/* IPv4 address? */
	if (cont && (h = host_v4(r, mask)) != NULL)
		cont = 0;
	if (r != ps)
		free(r);

	/* IPv6 address? */
	if (cont && (h = host_v6(ps, v6mask)) != NULL)
		cont = 0;

	/* dns lookup */
	if (cont && (h = host_dns(ps, v4mask, v6mask)) != NULL)
		cont = 0;

	if (if_name && if_name[0])
		for (n = h; n != NULL; n = n->next)
			if ((n->ifname = strdup(if_name)) == NULL)
				err(1, "host: strdup");

	free(ps);	/* after we copy the name out */
	if (h == NULL || cont == 1) {
		fprintf(stderr, "no IP address found for %s\n", s);
		return (NULL);
	}
	for (n = h; n != NULL; n = n->next) {
		n->addr.type = PF_ADDR_ADDRMASK;
		n->weight = 0;
	}	
	return (h);
}

struct node_host *
host_if(const char *s, int mask)
{
	struct node_host	*n, *h = NULL;
	char			*p, *ps;
	int			 flags = 0;

	if ((ps = strdup(s)) == NULL)
		err(1, "host_if: strdup");
	while ((p = strrchr(ps, ':')) != NULL) {
		if (!strcmp(p+1, "network"))
			flags |= PFI_AFLAG_NETWORK;
		else if (!strcmp(p+1, "broadcast"))
			flags |= PFI_AFLAG_BROADCAST;
		else if (!strcmp(p+1, "peer"))
			flags |= PFI_AFLAG_PEER;
		else if (!strcmp(p+1, "0"))
			flags |= PFI_AFLAG_NOALIAS;
		else {
			free(ps);
			return (NULL);
		}
		*p = '\0';
	}
	if (flags & (flags - 1) & PFI_AFLAG_MODEMASK) { /* Yep! */
		fprintf(stderr, "illegal combination of interface modifiers\n");
		free(ps);
		return (NULL);
	}
	if ((flags & (PFI_AFLAG_NETWORK|PFI_AFLAG_BROADCAST)) && mask > -1) {
		fprintf(stderr, "network or broadcast lookup, but "
		    "extra netmask given\n");
		free(ps);
		return (NULL);
	}
	if (ifa_exists(ps) || !strncmp(ps, "self", IFNAMSIZ)) {
		/* interface with this name exists */
		h = ifa_lookup(ps, flags);
		for (n = h; n != NULL && mask > -1; n = n->next)
			set_ipmask(n, mask);
	}

	free(ps);
	return (h);
}

struct node_host *
host_v4(const char *s, int mask)
{
	struct node_host	*h = NULL;
	struct in_addr		 ina;
	int			 bits = 32;

	memset(&ina, 0, sizeof(struct in_addr));
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
	}

	h = calloc(1, sizeof(struct node_host));
	if (h == NULL)
		err(1, "address: calloc");
	h->ifname = NULL;
	h->af = AF_INET;
	h->addr.v.a.addr.addr32[0] = ina.s_addr;
	set_ipmask(h, bits);
	h->next = NULL;
	h->tail = h;

	return (h);
}

struct node_host *
host_v6(const char *s, int mask)
{
	struct addrinfo		 hints, *res;
	struct node_host	*h = NULL;

	memset(&hints, 0, sizeof(hints));
	hints.ai_family = AF_INET6;
	hints.ai_socktype = SOCK_DGRAM; /*dummy*/
	hints.ai_flags = AI_NUMERICHOST;
	if (getaddrinfo(s, "0", &hints, &res) == 0) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET6;
		memcpy(&h->addr.v.a.addr,
		    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr,
		    sizeof(h->addr.v.a.addr));
		h->ifindex =
		    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
		set_ipmask(h, mask);
		freeaddrinfo(res);
		h->next = NULL;
		h->tail = h;
	}

	return (h);
}

struct node_host *
host_dns(const char *s, int v4mask, int v6mask)
{
	struct addrinfo		 hints, *res0, *res;
	struct node_host	*n, *h = NULL;
	int			 error, noalias = 0;
	int			 got4 = 0, got6 = 0;
	char			*p, *ps;

	if ((ps = strdup(s)) == NULL)
		err(1, "host_dns: strdup");
	if ((p = strrchr(ps, ':')) != NULL && !strcmp(p, ":0")) {
		noalias = 1;
		*p = '\0';
	}
	memset(&hints, 0, sizeof(hints));
	hints.ai_family = PF_UNSPEC;
	hints.ai_socktype = SOCK_STREAM; /* DUMMY */
	error = getaddrinfo(ps, NULL, &hints, &res0);
	if (error) {
		free(ps);
		return (h);
	}

	for (res = res0; res; res = res->ai_next) {
		if (res->ai_family != AF_INET &&
		    res->ai_family != AF_INET6)
			continue;
		if (noalias) {
			if (res->ai_family == AF_INET) {
				if (got4)
					continue;
				got4 = 1;
			} else {
				if (got6)
					continue;
				got6 = 1;
			}
		}
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "host_dns: calloc");
		n->ifname = NULL;
		n->af = res->ai_family;
		if (res->ai_family == AF_INET) {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in *)
			    res->ai_addr)->sin_addr.s_addr,
			    sizeof(struct in_addr));
			set_ipmask(n, v4mask);
		} else {
			memcpy(&n->addr.v.a.addr,
			    &((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_addr.s6_addr,
			    sizeof(struct in6_addr));
			n->ifindex =
			    ((struct sockaddr_in6 *)
			    res->ai_addr)->sin6_scope_id;
			set_ipmask(n, v6mask);
		}
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}
	freeaddrinfo(res0);
	free(ps);

	return (h);
}

/*
 * convert a hostname to a list of addresses and put them in the given buffer.
 * test:
 *	if set to 1, only simple addresses are accepted (no netblock, no "!").
 */
int
append_addr(struct pfr_buffer *b, char *s, int test)
{
	static int 		 previous = 0;
	static int		 expect = 0;
	struct pfr_addr		*a;
	struct node_host	*h, *n;
	char			*r;
	const char		*errstr;
	int			 rv, not = 0, i = 0;
	u_int16_t		 weight;
	
	/* skip weight if given */
	if (strcmp(s, "weight") == 0) {
		expect = 1;
		return (1); /* expecting further call */
	}
	
	/* check if previous host is set */
	if (expect) {
		/* parse and append load balancing weight */
		weight = strtonum(s, 1, USHRT_MAX, &errstr);
		if (errstr) {
			fprintf(stderr, "failed to convert weight %s\n", s);
			return (-1);
		}
		if (previous != -1) {
			PFRB_FOREACH(a, b) {
				if (++i >= previous) {
					a->pfra_weight = weight;
					a->pfra_type = PFRKE_COST;
				}
			}
		}
		
		expect = 0;
		return (0);
	}

	for (r = s; *r == '!'; r++)
		not = !not;
	if ((n = host(r)) == NULL) {
		errno = 0;
		return (-1);
	}
	rv = append_addr_host(b, n, test, not);
	previous = b->pfrb_size;
	do {
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);
	return (rv);
}

/*
 * same as previous function, but with a pre-parsed input and the ability
 * to "negate" the result. Does not free the node_host list.
 * not:
 *      setting it to 1 is equivalent to adding "!" in front of parameter s.
 */
int
append_addr_host(struct pfr_buffer *b, struct node_host *n, int test, int not)
{
	int			 bits;
	struct pfr_addr		 addr;

	do {
		bzero(&addr, sizeof(addr));
		addr.pfra_not = n->not ^ not;
		addr.pfra_af = n->af;
		addr.pfra_net = unmask(&n->addr.v.a.mask, n->af);
		if (n->ifname) {
			if (strlcpy(addr.pfra_ifname, n->ifname,
		 	   sizeof(addr.pfra_ifname)) >= sizeof(addr.pfra_ifname))
				errx(1, "append_addr_host: strlcpy");
			addr.pfra_type = PFRKE_ROUTE;
		}
		if (n->weight > 0) {
			addr.pfra_weight = n->weight;
			addr.pfra_type = PFRKE_COST;
		}
		switch (n->af) {
		case AF_INET:
			addr.pfra_ip4addr.s_addr = n->addr.v.a.addr.addr32[0];
			bits = 32;
			break;
		case AF_INET6:
			memcpy(&addr.pfra_ip6addr, &n->addr.v.a.addr.v6,
			    sizeof(struct in6_addr));
			bits = 128;
			break;
		default:
			errno = EINVAL;
			return (-1);
		}
		if ((test && (not || addr.pfra_net != bits)) ||
		    addr.pfra_net > bits) {
			errno = EINVAL;
			return (-1);
		}
		if (pfr_buf_add(b, &addr))
			return (-1);
	} while ((n = n->next) != NULL);

	return (0);
}

int
pfctl_add_trans(struct pfr_buffer *buf, int type, const char *anchor)
{
	struct pfioc_trans_e trans;

	bzero(&trans, sizeof(trans));
	trans.type = type;
	if (strlcpy(trans.anchor, anchor,
	    sizeof(trans.anchor)) >= sizeof(trans.anchor))
		errx(1, "pfctl_add_trans: strlcpy");

	return pfr_buf_add(buf, &trans);
}

u_int32_t
pfctl_get_ticket(struct pfr_buffer *buf, int type, const char *anchor)
{
	struct pfioc_trans_e *p;

	PFRB_FOREACH(p, buf)
		if (type == p->type && !strcmp(anchor, p->anchor))
			return (p->ticket);
	errx(1, "pfctl_get_ticket: assertion failed");
}

int
pfctl_trans(int dev, struct pfr_buffer *buf, u_long cmd, int from)
{
	struct pfioc_trans trans;

	bzero(&trans, sizeof(trans));
	trans.size = buf->pfrb_size - from;
	trans.esize = sizeof(struct pfioc_trans_e);
	trans.array = ((struct pfioc_trans_e *)buf->pfrb_caddr) + from;
	return ioctl(dev, cmd, &trans);
}
@


1.312
log
@Return time_uptime as value for when pf was enabled instead of
time_second.  Since time_second changes depending on the wall-
clock time, time_second is not a reliable source for the status.
We can even end up with a negative time delta.  Thus, use the
monotonically growing time_uptime and export it to userland.

ok bluhm@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.311 2017/05/15 16:56:42 mikeb Exp $ */
d1216 2
a1217 1
	} else {
@


1.311
log
@Fixup printing of queue bandwidth specifications

Reported by Carl Mascott, thanks!  OK sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.310 2017/05/15 11:23:25 mikeb Exp $ */
d522 2
a523 1
	time_t			runtime;
d528 2
a529 1
	runtime = time(NULL) - s->since;
d532 1
a532 1
	if (s->since) {
@


1.310
log
@Hook up FQ-CoDel to the tree and enable configuration in the pfctl(8)

OK sthen, visa
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.309 2016/10/26 14:15:59 bluhm Exp $ */
d1179 1
a1179 1
		for (i = 0; rate >= 1000 && i <= 3; i++)
@


1.309
log
@When using a /32 IPv4 interface address, pfctl(8) reports a 0.0.0.0
as broadcast address.  The kernel does not consider this a broadcast
address and ifconfig(8) has a check to exclude it.  Use the same
check in pfctl(8).
Found by regress/sbin/pfctl pfi2; OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.308 2016/09/03 17:11:40 sashan Exp $ */
a43 1
#include <net/hfsc.h>
a1198 3
	/* hide the _root_ifname queues */
	if (q->qname[0] == '_')
		return;
d1200 1
a1200 1
	if (q->parent[0] && q->parent[0] != '_')
d1204 16
a1219 4
	print_scspec(" bandwidth ", &q->linkshare);
	print_scspec(", min ", &q->realtime);
	print_scspec(", max ", &q->upperlimit);
	if (q->flags & HFSC_DEFAULTCLASS)
@


1.308
log
@Let purge thread to remove once rules, not packets.
Thanks mikeb@@ for idea to add expire time.

OK mpi@@, OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.307 2016/08/26 06:06:58 guenther Exp $ */
d1520 2
@


1.307
log
@Add <time.h> for time(); sort <*.h> includes

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.306 2015/09/03 12:46:47 mikeb Exp $ */
d704 3
d709 1
@


1.306
log
@interface should only be specified for root queues; found by jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.305 2015/06/03 02:24:36 millert Exp $ */
d47 7
d57 1
a57 6
#include <ctype.h>
#include <netdb.h>
#include <stdarg.h>
#include <errno.h>
#include <err.h>
#include <ifaddrs.h>
a58 1
#include <limits.h>
@


1.305
log
@Do not assume that asprintf() clears the pointer on failure, which
is non-portable.  Also add missing asprintf() return value checks.
OK deraadt@@ guenther@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.304 2015/02/14 23:32:41 sthen Exp $ */
d1201 1
a1201 1
	if (q->ifname[0])
@


1.304
log
@Rather than using 0xff as a placeholder for "don't check prio", use 0xff to
mean "prio is 0". This avoids the need for code changes in programs which add
pf rules (as was done in pfctl but not other programs) to handle the new
"check prio" functionality. Specifically this unbreaks ftp-proxy.

Use of #define rather than magic 0xff suggested by benno.
ok benno "if henning doesnt like it he can change it when he recovers from jet-lag"
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.303 2015/02/10 06:45:55 henning Exp $ */
d546 4
a549 3
	asprintf(&debug, "Debug: %s", loglevel_to_string(s->debug));
	printf("%15s\n\n", debug);
	free(debug);
@


1.303
log
@since we inherit prio (as in, the queuing priority) from outside sources,
i. e. on vlan interfaces, it is useful to be able to match on it -
effectively matching on classification done elsewhere.
i thought i had long implemented that, but chrisz@@ asking for it made
me notice that wasn't the case.
tests by chrisz, ok phessler pelikan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.301 2015/01/16 06:40:00 deraadt Exp $ */
d856 2
a857 2
	if (r->prio != 0xff)
		printf(" prio %u", r->prio);
@


1.302
log
@parse debug levels with strtonum, so that debug 1banana doesn't parse.
ok mikeb
@
text
@d856 2
@


1.301
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.300 2014/10/27 21:51:32 mikeb Exp $ */
d312 9
a320 2
	if (isdigit((unsigned char)*name))
		return (atoi(name));
@


1.300
log
@Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.299 2014/10/25 03:18:13 lteo Exp $ */
d57 1
@


1.299
log
@Remove unnecessary netinet/in_systm.h include.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.298 2014/01/20 02:59:13 henning Exp $ */
d1246 1
a1246 1
	struct pf_addr	*m;
a1251 4
		/* fix up netmask for dynaddr */
		if (af == AF_INET && h->addr.type == PF_ADDR_DYNIFTL &&
		    unmask(m, AF_INET6) > 32)
			set_ipmask(n, 32);
d1261 24
@


1.298
log
@support "!received-on <interface>", ok dlg benno
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.296 2013/10/28 15:05:35 deraadt Exp $ */
a39 1
#include <netinet/in_systm.h>
@


1.298.4.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.300 2014/10/27 21:51:32 mikeb Exp $ */
d1247 1
a1247 1
	struct pf_addr		*m;
d1253 4
a1265 24
}

struct node_host *
gen_dynnode(struct node_host *h, sa_family_t af)
{
	struct node_host	*n;
	struct pf_addr		*m;

	if (h->addr.type != PF_ADDR_DYNIFTL)
		return (NULL);

	if ((n = calloc(1, sizeof(*n))) == NULL)
		return (NULL);
	bcopy(h, n, sizeof(*n));
	n->ifname = NULL;
	n->next = NULL;
	n->tail = NULL;

	/* fix up netmask */
	m = &n->addr.v.a.mask;
	if (af == AF_INET && unmask(m, AF_INET6) > 32)
		set_ipmask(n, 32);

	return (n);
@


1.298.6.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.300 2014/10/27 21:51:32 mikeb Exp $ */
d1247 1
a1247 1
	struct pf_addr		*m;
d1253 4
a1265 24
}

struct node_host *
gen_dynnode(struct node_host *h, sa_family_t af)
{
	struct node_host	*n;
	struct pf_addr		*m;

	if (h->addr.type != PF_ADDR_DYNIFTL)
		return (NULL);

	if ((n = calloc(1, sizeof(*n))) == NULL)
		return (NULL);
	bcopy(h, n, sizeof(*n));
	n->ifname = NULL;
	n->next = NULL;
	n->tail = NULL;

	/* fix up netmask */
	m = &n->addr.v.a.mask;
	if (af == AF_INET && unmask(m, AF_INET6) > 32)
		set_ipmask(n, 32);

	return (n);
@


1.297
log
@Whole bunch of (unsigned char) casts carefully added for ctype calls.
Careful second audit by millert
@
text
@d807 2
a808 1
		printf(" received-on %s", r->rcv_ifname);
@


1.296
log
@use %d instead of %i in a few fprintf for clarity
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.295 2013/10/12 12:16:12 henning Exp $ */
d312 1
a312 1
	if (isdigit(*name))
d316 2
a317 2
		if (isupper(*name))
			*p = tolower(*name);
@


1.295
log
@config bits for the bandwidth shaping part of the new queueing subsystem
syntax worked out with many in ljubljana using a whiteboard, testing &
looking over by many, ok phessler sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.294 2013/08/01 19:03:11 mikeb Exp $ */
d786 1
a786 1
			printf(" on ! rdomain %i", r->onrdomain);
d788 1
a788 1
			printf(" on rdomain %i", r->onrdomain);
@


1.294
log
@Provide local implementations of if_nametoindex(3) and if_indextoname(3)
that make use of the cache of addresses populated by the ifa_load on
startup to save the trouble of calling expensive getaddrinfo(3) up to
four times per rule.   Performance wise this change provides a speed up
factor of 20 with a 11k line ruleset on a machine with 150 VLANs and 250
IP addresses (20 seconds down to 1 in this case).

"wow!" henning, ok benno, florian
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.293 2013/04/21 23:13:39 deraadt Exp $ */
d5 1
a5 1
 * Copyright (c) 2002,2003 Henning Brauer
d45 1
d71 2
d1150 49
@


1.293
log
@avoid truncating a time_t division into days
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.292 2013/01/16 01:49:20 henning Exp $ */
d37 1
d1286 3
d1304 28
@


1.293.2.1
log
@MFC pfctl fix (parse.y 1.641, pfctl_parser.c 1.300, pfctl_parser.h 1.104)
-----
Fixup incorrect expansion of the networking mask for dynamic interface
specifications under certain circumstances resulting in potentially
elevated access permissions for IPv6 traffic.  Reported by sthen@@;
ok henning benno sthen
-----
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.300 2014/10/27 21:51:32 mikeb Exp $ */
d1193 1
a1193 1
	struct pf_addr		*m;
d1199 4
a1211 24
}

struct node_host *
gen_dynnode(struct node_host *h, sa_family_t af)
{
	struct node_host	*n;
	struct pf_addr		*m;

	if (h->addr.type != PF_ADDR_DYNIFTL)
		return (NULL);

	if ((n = calloc(1, sizeof(*n))) == NULL)
		return (NULL);
	bcopy(h, n, sizeof(*n));
	n->ifname = NULL;
	n->next = NULL;
	n->tail = NULL;

	/* fix up netmask */
	m = &n->addr.v.a.mask;
	if (af == AF_INET && unmask(m, AF_INET6) > 32)
		set_ipmask(n, 32);

	return (n);
@


1.292
log
@for consistency with prio etc, the queue assignment really belongs
into the set block. so make pfctl accept, print and the manpage document
.  match set queue foo
instead of
.  match queue foo
but keep accepting the old way without the explicit set.
ok bob, man jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.290 2012/09/18 10:11:53 henning Exp $ */
d520 2
a521 1
		unsigned int	sec, min, hrs, day = runtime;
d530 2
a531 2
		    "Status: %s for %u days %.2u:%.2u:%.2u",
		    running, day, hrs, min, sec);
@


1.291
log
@remove some unnecessary sys/param.h inclusions
@
text
@d844 1
a844 1
	if (r->scrub_flags & PFSTATE_SETMASK) {
d855 8
a1045 4
	if (r->qname[0] && r->pqname[0])
		printf(" queue(%s, %s)", r->qname, r->pqname);
	else if (r->qname[0])
		printf(" queue %s", r->qname);
@


1.290
log
@prio 0 is valid, therefore, I chose an "impossible" value for prio meaning
"not set" and used a PF_PRIO_NOTSET define for it. now that means that
everything that creates a struct pf_rule doesn't get away with bzero'ing it,
which turned out to be not so nice. so get rid of PF_PRIO_NOTSET, instead,
make a rule+state flag PFSTATE_SETPRIO which indicates wether the prio
should be set. ok benno claudio mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.288 2012/07/10 09:23:56 henning Exp $ */
a36 2
#include <sys/param.h>
#include <sys/proc.h>
@


1.289
log
@use PFSTATE_SCRUBMASK
whenever you see (flags >= ONE_OF_THE_FLAGS), run. that must break sooner
or later.
@
text
@d846 1
a846 2
	if (r->set_prio[0] != PF_PRIO_NOTSET ||
	    r->scrub_flags & PFSTATE_SETTOS) {
d849 1
a849 1
		if (r->set_prio[0] != PF_PRIO_NOTSET) {
@


1.288
log
@intermediate hack^Wugly "fix" to prevent spurious "scrub ()" prints
+ XXX comment as reminder to clean this up for good
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.287 2012/07/10 09:13:41 henning Exp $ */
d1001 1
a1001 3
	/* XXX the scrub_flags mess needs to be cleaned up */
	if ((r->scrub_flags & ~PFSTATE_SETTOS) >= PFSTATE_NODF ||
	    r->min_ttl || r->max_mss) {
@


1.287
log
@set { ... } -> set ( ... )
brought up by ryan, discussed with him and theo and they convinced me
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.286 2012/07/09 14:05:35 henning Exp $ */
d1001 3
a1003 1
	if (r->scrub_flags >= PFSTATE_NODF || r->min_ttl || r->max_mss) {
@


1.286
log
@fix some of the confusion we have in pf regarding filter criteria vs
options that "write" to the packet by putting the latter in a set { } block.
for now prio and tos, maintain set-tos backwards compat for the moment.
"match set { prio 6, tos lowdelay }"
"match set prio 6"
from a discussion with ryan in tokyo a while ago, ok ryan phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.285 2012/07/07 16:24:32 henning Exp $ */
d849 1
a849 1
		printf(" set {");
d862 1
a862 1
		printf(" }");
@


1.285
log
@rename prio in struct pf_rule and related structs to set_prio so it is
utterly clear this is not a filter criteria but a packet modification thing.
also preparation for upcoming changes, including one to unscrew this mess
(I should not have to touch half the tree for this - ifixitlater)
not user visible, ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.283 2011/11/23 10:24:37 henning Exp $ */
d846 19
a1019 6
		if (r->scrub_flags & PFSTATE_SETTOS) {
			if (!ropts)
				printf(" ");
			printf("set-tos 0x%2.2x", r->set_tos);
			ropts = 0;
		}
a1103 6
	}
	if (r->set_prio[0] != PF_PRIO_NOTSET) {
		if (r->set_prio[0] == r->set_prio[1])
			printf(" prio %u", r->set_prio[0]);
		else
			printf(" prio(%u, %u)", r->set_prio[0], r->set_prio[1]);
@


1.284
log
@fixup af-to regression with match rules

pfctl should not infer the af-to behavior from the af/naf difference.
instead, we should be clear that this is an af-to rule.  essentially
this change converts FOM_AFTO marker into a rule flag PFRULE_AFTO so
that we don't rely on ambiguous checks (like r->af != r->naf) when
setting things up.

positive review and comments from claudio, ok henning, sperreault
@
text
@d1092 3
a1094 3
	if (r->prio[0] != PF_PRIO_NOTSET) {
		if (r->prio[0] == r->prio[1])
			printf(" prio %u", r->prio[0]);
d1096 1
a1096 1
			printf(" prio(%u, %u)", r->prio[0], r->prio[1]);
@


1.283
log
@print ports as numbers by default; -P prints names instead
2/2 from Lawrence Teo <lteo at devio dot us>
ok sthen dlg and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.282 2011/11/23 10:23:11 henning Exp $ */
d1061 1
a1061 1
	    r->naf != r->af) {
@


1.282
log
@print_rule: rename opts -> ropts, no binary change
1/2 from Lawrence Teo <lteo at devio dot us>
ok sthen dlg myself and gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.281 2011/10/13 18:30:54 claudio Exp $ */
d66 1
a66 1
void		 print_port (u_int8_t, u_int16_t, u_int16_t, const char *);
d363 1
a363 1
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, const char *proto)
d366 1
a366 1
	struct servent	*s;
d368 2
a369 1
	s = getservbyport(p1, proto);
d407 1
a407 1
    sa_family_t af, u_int8_t proto, int verbose)
d410 1
d429 1
a429 1
			    proto == IPPROTO_TCP ? "tcp" : "udp");
d441 1
a441 1
			    proto == IPPROTO_TCP ? "tcp" : "udp");
d680 1
a680 1
print_rule(struct pf_rule *r, const char *anchor_call, int verbose)
d689 1
d802 1
a802 1
	    verbose);
@


1.281
log
@pfctl change for af-to / NAT64 support.
The general syntax is:
pass in inet from any to 192.168.1.1 af-to inet6 from 2001::1 to 2001::2
In the NAT64 case the "to" is not needed in af-to and the IP is extraced
from the IPv6 dst (assuming a /64 prefix).
Again most work by sperreault@@, mikeb@@ and reyk@@
OK mcbride@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.280 2011/08/30 00:43:57 mikeb Exp $ */
d686 1
a686 1
	int	i, opts;
d843 1
a843 1
	opts = 0;
d845 1
a845 1
		opts = 1;
d847 1
a847 1
		opts = 1;
d849 1
a849 1
		opts = 1;
d851 1
a851 1
		opts = 1;
d853 1
a853 1
		opts = 1;
d855 2
a856 2
		opts = 1;
	for (i = 0; !opts && i < PFTM_MAX; ++i)
d858 1
a858 1
			opts = 1;
d862 1
a862 1
	else if (r->keep_state == PF_STATE_NORMAL && opts)
d883 1
a883 1
	if (opts) {
d887 1
a887 1
			opts = 0;
d890 1
a890 1
			if (!opts)
d893 1
a893 1
			opts = 0;
d896 1
a896 1
			if (!opts)
d903 1
a903 1
			opts = 0;
d906 1
a906 1
			if (!opts)
d909 1
a909 1
			opts = 0;
d912 1
a912 1
			if (!opts)
d915 1
a915 1
			opts = 0;
d918 1
a918 1
			if (!opts)
d923 1
a923 1
			opts = 0;
d926 1
a926 1
			if (!opts)
d929 1
a929 1
			opts = 0;
d932 1
a932 1
			if (!opts)
d941 1
a941 1
			if (!opts)
d944 1
a944 1
			opts = 0;
d947 1
a947 1
			if (!opts)
d950 1
a950 1
			opts = 0;
d953 1
a953 1
			if (!opts)
d956 1
a956 1
			opts = 0;
d962 1
a962 1
				if (!opts)
d964 1
a964 1
				opts = 0;
d981 1
a981 1
		opts = 1;
d984 1
a984 1
			opts = 0;
d987 1
a987 1
			if (!opts)
d990 1
a990 1
			opts = 0;
d993 1
a993 1
			if (!opts)
d996 1
a996 1
			opts = 0;
d999 1
a999 1
			if (!opts)
d1002 1
a1002 1
			opts = 0;
d1005 1
a1005 1
			if (!opts)
d1008 1
a1008 1
			opts = 0;
d1011 1
a1011 1
			if (!opts)
d1014 1
a1014 1
			opts = 0;
@


1.280
log
@One shot rules can be used in pf.conf by specifying a "once" filter option.

ok henning, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.279 2011/07/27 00:26:10 mcbride Exp $ */
d647 2
a648 1
		print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
d1056 14
a1069 1
	if (!anchor_call[0] && r->nat.addr.type != PF_ADDR_NONE) {
d1072 3
a1074 3
		    r->nat.proxy_port[1], r->af, PF_POOL_NAT, verbose);
	}
	if (!anchor_call[0] && r->rdr.addr.type != PF_ADDR_NONE) {
@


1.279
log
@Add support for weighted round-robin in load balancing pools and tables.
Diff from zinke@@ with a some minor cleanup.
ok henning claudio deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.278 2011/07/08 18:52:47 henning Exp $ */
d1022 2
@


1.278
log
@allow rules to specify "prio X" or "prio (X, Y)" to assign priority levels
for the new priority queueing implementation. valid range is 0 to 7. the old
trick for priorizing empty ACKs etc remains thru the latter notation
ok ryan mpf sthen plus pea testing and halex and claudio reading
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.277 2011/07/07 02:00:25 mcbride Exp $ */
a1094 2
	if (flags & PFR_TFLAG_COST)
		printf(" cost");
a1450 1

d1509 1
a1509 1
	for (n = h; n != NULL; n = n->next)
d1511 2
d1704 3
a1706 1
	char			 *r;
d1708 31
a1738 1
	int			 rv, not = 0;
d1747 1
d1778 4
@


1.277
log
@Don't print 'keep state' anymore unless it's needed for state options, it's
been implicit for years now.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.276 2011/07/03 23:37:55 zinke Exp $ */
d1072 6
@


1.276
log
@bring in least-states load balancing algorithm

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.275 2011/04/06 13:19:55 claudio Exp $ */
d841 18
d861 1
a861 1
	else if (r->keep_state == PF_STATE_NORMAL)
a881 16
	opts = 0;
	if (r->max_states || r->max_src_nodes || r->max_src_states)
		opts = 1;
	if (r->rule_flag & PFRULE_NOSYNC)
		opts = 1;
	if (r->rule_flag & PFRULE_SRCTRACK)
		opts = 1;
	if (r->rule_flag & PFRULE_IFBOUND)
		opts = 1;
	if (r->rule_flag & PFRULE_STATESLOPPY)
		opts = 1;
	if (r->rule_flag & PFRULE_PFLOW)
		opts = 1;
	for (i = 0; !opts && i < PFTM_MAX; ++i)
		if (r->timeout[i])
			opts = 1;
@


1.275
log
@Userland bits to allow PF to filter on the rdomain a packet belongs to.
This allows to write rules like "pass in on rdomain 1".
Tested by phessler@@, OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.274 2011/04/05 13:48:18 mikeb Exp $ */
d492 3
d1087 2
@


1.274
log
@ditch fastroute, an ipf feature that made its way into pf before
route-to and friends were introduced making it obsolete. one even
has to look it up int the ipf manual to get and idea what it's
supposed to do.  reuse some kernel bits for the upcoming nat64
stuff.  "kill it with fire" from mcbride, "what mcbride said"
from mpf, "kill kill kill" and ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.273 2011/01/23 11:19:55 bluhm Exp $ */
d773 6
@


1.273
log
@'pfctl -x none' did not turn debugging off.  Skip the syslog internal
"no priority" priority named "none".  This makes 'pfctl -x none'
equivalent to 'pfctl -x crit'.
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.272 2010/10/12 17:45:06 bluhm Exp $ */
d1059 2
a1060 6
		else if (r->rt == PF_FASTROUTE)
			printf(" fastroute");
		if (r->rt != PF_FASTROUTE) {
			printf(" ");
			print_pool(&r->route, 0, 0, r->af, PF_POOL_ROUTE, verbose);
		}
@


1.272
log
@pfctl -sr did not show divert-reply rules without address family
correctly.  A zero address field is used to identify divert-reply
rules.  If the rule's address family is unspecified, PF_AZERO()
always returns false.  So use AF_INET6 as address family, to check
all bits of the address.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.271 2010/09/22 06:02:59 henning Exp $ */
d321 1
a321 1
		if (!strcmp(buf, c->c_name))
@


1.271
log
@new log opt "matches"
awesome for debugging, a rule like
match log(matches) from $testbox
will show you exactly which subsequent rules match on that packet
real ok theo assumed oks ryan & dlg bikeshedding many
implementation time ~1 min bikeshedding about the keyword longish.
i voted for "matches" since i like to play with matches
idea was theo's, actually
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.270 2010/09/02 14:01:04 sobrado Exp $ */
d1025 1
a1025 1
		if (PF_AZERO(&r->divert.addr, r->af)) {
@


1.270
log
@remove trailing spaces and tabs; no binary change.

written with help from henning@@, who suggested ensuring that there
are no changes in the digests for object files, thanks!

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.269 2010/07/13 13:11:57 sthen Exp $ */
d756 2
@


1.269
log
@Fix (pflow) display in rule printing. Spotted by dhill@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.268 2010/07/03 02:28:57 mcbride Exp $ */
d331 1
a331 1
	
d335 1
a335 1
	
d1450 1
a1450 1
	} 
@


1.268
log
@Fix a couple of problems with printing of anchors, in particular recursive
printing, both of inline anchors and when requested explicitly with a '*'
in the anchor.
- Correct recursive printing of wildcard anchors (recurse into child anchors
  rather than rules, which don't exist)
- Print multi-part anchor paths correctly (pr6065)
- Fix comments and prevent users from specifying multi-component names for
  inline anchors.

tested by phessler
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.267 2010/07/03 02:05:17 mcbride Exp $ */
d863 2
@


1.267
log
@Use our own enum here rather than abusing the PF rule type enums, which
will be getting cleaned up soon.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.266 2010/06/29 19:28:13 chl Exp $ */
d683 1
d690 2
a691 1
		if (anchor_call[0] == '_') {
d693 1
a693 1
		} else
@


1.266
log
@Fix use after free. Found by regress tests.

ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.265 2010/05/16 12:23:30 zinovik Exp $ */
d210 2
d456 1
a456 1
	case PF_NAT:
d465 1
a465 1
	case PF_RDR:
d495 1
a495 1
	if (id == PF_NAT && p1 == 0 && p2 == 0)
d1039 1
a1039 1
		    r->nat.proxy_port[1], r->af, PF_NAT, verbose);
d1044 1
a1044 1
		    r->rdr.proxy_port[1], r->af, PF_RDR, verbose);
d1057 1
a1057 1
			print_pool(&r->route, 0, 0, r->af, PF_PASS, verbose);
@


1.265
log
@plug memory leak.  `ps' was allocated with strdup(3), but on error path
program does not free(3) it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.264 2010/03/22 17:04:02 deraadt Exp $ */
d1451 1
a1453 1
			fprintf(stderr, "invalid netmask '%s'\n", p);
@


1.264
log
@Following diff fixes memory leak.  `debug' is allocated via asprintf(3) so we
need to free it with free(3).
from zinovik
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.263 2010/03/18 12:15:22 sthen Exp $ */
d1452 1
@


1.263
log
@Fix rdr-to printing in pfctl -sr when reply-to is in use.
Found by Marcus Muelbuesch. ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.262 2010/01/18 23:52:46 mcbride Exp $ */
d531 1
@


1.262
log
@Convert pf debug logging to using log()/addlog(), a single standardised
definition of DPFPRINTF(), and log priorities from syslog.h. Old debug
levels will still work for now, but will eventually be phased out.

discussed with henning, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.261 2010/01/13 05:09:07 deraadt Exp $ */
d1038 1
a1038 1
	if (!r->rt && !anchor_call[0] && r->rdr.addr.type != PF_ADDR_NONE) {
@


1.261
log
@repair a double-free suggested by parfait; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.260 2010/01/13 01:41:58 jsg Exp $ */
d59 3
d298 39
d505 1
a505 1
	char			statline[80], *running;
d529 2
a530 14
	switch (s->debug) {
	case PF_DEBUG_NONE:
		printf("%15s\n\n", "Debug: None");
		break;
	case PF_DEBUG_URGENT:
		printf("%15s\n\n", "Debug: Urgent");
		break;
	case PF_DEBUG_MISC:
		printf("%15s\n\n", "Debug: Misc");
		break;
	case PF_DEBUG_NOISY:
		printf("%15s\n\n", "Debug: Loud");
		break;
	}
@


1.260
log
@fix some leaks found by parfait
ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.259 2010/01/12 16:21:24 mcbride Exp $ */
a1419 1
			free(p);
@


1.259
log
@Only print route specs with @@if notation if there is an IP address.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.258 2010/01/12 15:49:43 mcbride Exp $ */
d1420 2
@


1.258
log
@Unbreak 10/8 and friends.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.257 2010/01/12 14:44:26 mcbride Exp $ */
d404 5
a408 2
		print_addr(&pool->addr, af, verbose);
		printf("@@%s", pool->ifname);
@


1.257
log
@Fix some issues in redir spec handling, discovered thanks to dlg testing
- purge irrelevant addresses from the lists before collapsing
- ensure the lists are freed after they're collapsed
- more careful ifname copying, avoiding double-free / use-after-free traps
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.256 2010/01/12 03:20:51 mcbride Exp $ */
d1402 1
a1402 1
	char			*p, *q, *ps, *if_name;
d1411 1
d1413 2
d1422 2
a1423 1
	}
d1430 1
a1430 1
	if (cont && (h = host_v4(ps, mask)) != NULL)
d1432 2
@


1.256
log
@First pass at removing the 'pf_pool' mechanism for translation and routing
actions. Allow interfaces to be specified in special table entries for
the routing actions. Lists of addresses can now only be done using tables,
which pfctl will generate automatically from the existing syntax.

Functionally, this deprecates the use of multiple tables or dynamic
interfaces in a single nat or rdr rule.

ok henning dlg claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.255 2009/12/24 10:06:35 sobrado Exp $ */
d1410 2
a1411 1
	} else if ((p = strrchr(ps, '/')) != NULL) {
d1426 1
a1426 1
	if (cont && (h = host_v4(s, mask)) != NULL)
a1435 1
	free(ps);
d1437 6
d1447 2
a1448 6
	if (if_name)
		for (n = h; n != NULL; n = n->next)
			if ((h->ifname = strdup(if_name)) == NULL)
				err(1, "host: strdup");

	h->addr.type = PF_ADDR_ADDRMASK;
@


1.255
log
@spelling fixes, from Brad Tilley; we will not fix src/sbin/dump/dump.h
as neither arrayified not arrayfied exist -- sanctioned dictionaries
like Merriam-Webster ones suggest a few alternatives (e.g., arrayed),
however these made up words are easy to understand and we are not
certain that current ones are not ok.

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.254 2009/12/24 04:24:19 dlg Exp $ */
d401 1
a401 1
    sa_family_t af, int id)
d403 5
a407 30
	struct pf_pooladdr	*pooladdr;

	if ((TAILQ_FIRST(&pool->list) != NULL) &&
	    TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
		printf("{ ");
	TAILQ_FOREACH(pooladdr, &pool->list, entries){
		switch (id) {
		case PF_NAT:
		case PF_RDR:
		case PF_BINAT:
			print_addr(&pooladdr->addr, af, 0);
			break;
		case PF_PASS:
		case PF_MATCH:
			if (PF_AZERO(&pooladdr->addr.v.a.addr, af))
				printf("%s", pooladdr->ifname);
			else {
				printf("(%s ", pooladdr->ifname);
				print_addr(&pooladdr->addr, af, 0);
				printf(")");
			}
			break;
		default:
			break;
		}
		if (TAILQ_NEXT(pooladdr, entries) != NULL)
			printf(", ");
		else if (TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
			printf(" }");
	}
d1000 1
a1000 1
	if (!anchor_call[0] && !TAILQ_EMPTY(&r->nat.list)) {
d1003 1
a1003 1
		    r->nat.proxy_port[1], r->af, PF_NAT);
d1005 1
a1005 1
	if (!r->rt && !anchor_call[0] && !TAILQ_EMPTY(&r->rdr.list)) {
d1008 1
a1008 1
		    r->rdr.proxy_port[1], r->af, PF_RDR);
d1021 1
a1021 1
			print_pool(&r->route, 0, 0, r->af, PF_PASS);
d1050 2
d1400 6
a1405 3
	struct node_host	*h = NULL;
	int			 mask, v4mask, v6mask, cont = 1;
	char			*p, *q, *ps;
d1407 4
a1410 1
	if ((p = strrchr(s, '/')) != NULL) {
d1416 1
a1416 3
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
a1417 6
	} else {
		if ((ps = strdup(s)) == NULL)
			err(1, "host: strdup");
		v4mask = 32;
		v6mask = 128;
		mask = -1;
d1441 6
d1674 6
@


1.254
log
@add support to pf for filtering a packet by the interface it was received
on. use the received-on IFNAME filter option on a pf.conf rule to restrict
which packet the interface had to be received on. eg:

  pass out on em0 from $foo to $bar received-on fxp0

ive been running this in production for a week now. i find it particularly
usefull with interface groups.

no objections, and a few "i like"s from henning, claudio, deraadt, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.253 2009/12/14 12:31:45 henning Exp $ */
d1252 1
a1252 1
	/* check wether this is a group */
@


1.253
log
@fix sticky-address - by pretty much re-implementing it. still following
the original approach using a source tracking node.
the reimplementation i smore flexible than the original one, we now have an
slist of source tracking nodes per state. that is cheap because more than
one entry will be an absolute exception.
ok beck and jsg, also stress tested by Sebastian Benoit <benoit-lists at fb12.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.252 2009/11/23 21:29:21 henning Exp $ */
d775 2
@


1.252
log
@since "nat/rdr pass" are history natpass can go
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.251 2009/11/22 22:34:50 henning Exp $ */
d622 14
a635 3
	printf(" -> ");
	aw.v.a.addr = sn->raddr;
	print_addr(&aw, sn->af, opts & PF_OPT_VERBOSE2);
d656 2
a657 7
		switch (sn->ruletype) {
		case PF_PASS:
		case PF_MATCH:
			if (sn->rule.nr != -1)
				printf(", filter rule %u", sn->rule.nr);
			break;
		}
@


1.251
log
@cleanup after the NAT changes. we used to have multiple rulesets (scrub,
NAT, filter). now we only have one. no need for an array any more. simplifies
the code quite a bit.
in the process fix the abuse of PF_RULESET_* by (surprise, isn't it) the
table code.
written at the filesystem hackathon in stockholm, committed from the
hardware hackathon in portugal. ok gcc and jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.250 2009/10/28 20:11:01 jsg Exp $ */
d677 1
a677 1
	} else {
a678 3
		if (r->natpass)
			printf(" pass");
	}
@


1.250
log
@Add a dedicated pf pool for route options as suggested by henning,
which unbreaks ie route-to after the recent pf changes.

With much help debugging and pointing out of missing bits from claudio@@

ok claudio@@ "looks good" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.249 2009/10/04 16:08:37 michele Exp $ */
d1715 1
a1715 1
pfctl_add_trans(struct pfr_buffer *buf, int rs_num, const char *anchor)
d1720 1
a1720 1
	trans.rs_num = rs_num;
d1729 1
a1729 1
pfctl_get_ticket(struct pfr_buffer *buf, int rs_num, const char *anchor)
d1734 1
a1734 1
		if (rs_num == p->rs_num && !strcmp(anchor, p->anchor))
@


1.249
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.248 2009/09/08 17:52:17 michele Exp $ */
d1041 1
a1041 1
			print_pool(&r->rdr, 0, 0, r->af, PF_PASS);
@


1.248
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.246 2009/09/02 13:28:03 reyk Exp $ */
d1018 2
@


1.247
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@a1017 2
	if (r->divert_packet.port)
		printf(" divert-packet port %u", ntohs(r->divert_packet.port));
@


1.246
log
@all the new *-to options are part of the "filteropts" section at the
end of a pf rule (nat-to, divert-to, rdr-to, ...).  take the
historical chance to upgrade the grammar and move the route options to
the filteropts section as well.

for example,
  pass in on em0 route-to (em1 192.168.1.1) from 10.1.1.1
becomes
  pass in on em0 from 10.1.1.1 route-to (em1 192.168.1.1)

many people like this including pyr@@ mk@@ kettenis@@ todd@@ and others
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.245 2009/09/01 13:42:00 henning Exp $ */
d1018 2
@


1.245
log
@the diff theo calls me insanae for:
rewrite of the NAT code, basically. nat and rdr become actions on regular
rules, seperate nat/rdr/binat rules do not exist any more.
match in on $intf rdr-to 1.2.3.4
match out on $intf nat-to 5.6.7.8
the code is capable of doing nat and rdr in any direction, but we prevent
this in pfctl for now, there are implications that need to be documented
better.
the address rewrite happens inline, subsequent rules will see the already
changed addresses. nat / rdr can be applied multiple times as well.
match in on $intf rdr-to 1.2.3.4
match in on $intf to 1.2.3.4 rdr-to 5.6.7.8
help and ok dlg sthen claudio, reyk tested too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.244 2009/04/15 05:07:02 david Exp $ */
a755 14
	if (r->rt) {
		if (r->rt == PF_ROUTETO)
			printf(" route-to");
		else if (r->rt == PF_REPLYTO)
			printf(" reply-to");
		else if (r->rt == PF_DUPTO)
			printf(" dup-to");
		else if (r->rt == PF_FASTROUTE)
			printf(" fastroute");
		if (r->rt != PF_FASTROUTE) {
			printf(" ");
			print_pool(&r->rdr, 0, 0, r->af, PF_PASS);
		}
	}
d1027 14
@


1.244
log
@restore printing of the fragment option; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.243 2009/04/06 12:11:52 henning Exp $ */
a645 8
		case PF_NAT:
			if (sn->rule.nr != -1)
				printf(", nat rule %u", sn->rule.nr);
			break;
		case PF_RDR:
			if (sn->rule.nr != -1)
				printf(", rdr rule %u", sn->rule.nr);
			break;
d767 1
a767 1
			print_pool(&r->rpool, 0, 0, r->af, PF_PASS);
d1032 9
a1040 5
	if (!anchor_call[0] && (r->action == PF_NAT ||
	    r->action == PF_BINAT || r->action == PF_RDR)) {
		printf(" -> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, r->action);
@


1.243
log
@print prettier, from sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.242 2009/04/06 12:05:55 henning Exp $ */
d963 3
@


1.242
log
@1) scrub rules are completely gone.
2) packet reassembly: only one method remains, full reassembly. crop
and drop-ovl are gone.
.  set reassemble yes|no [no-df]
if no-df is given fragments (and only fragments!) with the df bit set
have it cleared before entering the fragment cache, and thus the
reassembled packet doesn't have df set either. it does NOT touch
non-fragmented packets.
3) regular rules can have scrub options.
.  pass scrub(no-df, min-ttl 64, max-mss 1400, set-tos lowdelay)
.  match scrub(reassemble tcp, random-id)
of course all options are optional. the individual options still do
what they used to do on scrub rules, but everything is stateful now.
4) match rules
"match" is a new action, just like pass and block are, and can be used
like they do. opposed to pass or block, they do NOT change the
pass/block state of a packet. i. e.
.  pass
.  match
passes the packet, and
.  block
.  match
blocks it.
Every time (!) a match rule matches, i. e. not only when it is the
last matching rule, the following actions are set:
-queue assignment. can be overwritten later, the last rule that set a
queue wins. note how this is different from the last matching rule
wins, if the last matching rule has no queue assignments and the
second last matching rule was a match rule with queue assignments,
these assignments are taken.
-rtable assignments. works the same as queue assignments.
-set-tos, min-ttl, max-mss, no-df, random-id, reassemble tcp, all work
like the above
-logging. every matching rule causes the packet to be logged. this
 means a single packet can get logged more than once (think multiple log
 interfaces with different receivers, like pflogd and spamlogd)
.
almost entirely hacked at n2k9 in basel, could not be committed close to
release. this really should have been multiple diffs, but splitting them
now is not feasible any more. input from mcbride and dlg, and frantzen
about the fragment handling.
speedup around 7% for the common case, the more the more scrub rules
were in use.
manpage not up to date, being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.241 2008/09/09 13:56:38 henning Exp $ */
d964 37
a1000 14
	if (r->scrub_flags & PFSTATE_NODF || r->min_ttl || r->max_mss) {
		printf(" scrub(");
		if (r->scrub_flags & PFSTATE_NODF)
			printf(" no-df");
		if (r->scrub_flags & PFSTATE_RANDOMID)
			printf(" random-id");
		if (r->min_ttl)
			printf(" min-ttl %d", r->min_ttl);
		if (r->scrub_flags & PFSTATE_SETTOS)
			printf(" set-tos 0x%2.2x", r->set_tos);
		if (r->scrub_flags & PFSTATE_SCRUB_TCP)
			printf(" reassemble tcp");
		if (r->max_mss)
			printf(" max-mss %d", r->max_mss);
@


1.241
log
@welcome pflow(4), a netflow v5 compatible flow export interface.
flows export data gathered from pf states.
initial implementation by Joerg Goltermann <jg@@osn.de>, guidance and many
changes by me. 'put it in' theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.240 2008/06/10 20:55:02 mcbride Exp $ */
d416 1
d655 1
d668 2
a669 1
	    "no scrub", "nat", "no nat", "binat", "no binat", "rdr", "no rdr" };
d677 1
a677 1
	if (r->action > PF_NORDR)
d805 1
a805 1
	} else if (r->action == PF_PASS &&
d963 18
a980 12
	if (r->rule_flag & PFRULE_FRAGMENT)
		printf(" fragment");
	if (r->rule_flag & PFRULE_NODF)
		printf(" no-df");
	if (r->rule_flag & PFRULE_RANDOMID)
		printf(" random-id");
	if (r->min_ttl)
		printf(" min-ttl %d", r->min_ttl);
	if (r->max_mss)
		printf(" max-mss %d", r->max_mss);
	if (r->rule_flag & PFRULE_SET_TOS)
		printf(" set-tos 0x%2.2x", r->set_tos);
a982 11
	if (r->action == PF_SCRUB) {
		if (r->rule_flag & PFRULE_REASSEMBLE_TCP)
			printf(" reassemble tcp");

		if (r->rule_flag & PFRULE_FRAGDROP)
			printf(" fragment drop-ovl");
		else if (r->rule_flag & PFRULE_FRAGCROP)
			printf(" fragment crop");
		else
			printf(" fragment reassemble");
	}
@


1.240
log
@Make counters on table addresses optional and disabled by default.
Use the 'counters' table option in pf.conf if you actually need them.
If enabled, memory is not allocated until packets match an address.

This saves about 40% memory if counters are not being used, and paves the way
for some more significant cleanups coming soon.

ok henning mpf deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.239 2008/06/10 04:28:54 henning Exp $ */
d935 6
@


1.239
log
@new state option "sloppy" to use the sloppy tcp state tracker instead
of the good one. ok theo ryan reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.238 2008/05/09 05:41:01 markus Exp $ */
d1030 2
@


1.238
log
@convert port byte order in the production; add port keyword; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.237 2008/05/09 02:44:55 markus Exp $ */
d863 2
d929 6
@


1.237
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.236 2008/05/07 06:23:30 markus Exp $ */
d999 1
a999 1
			printf(" %u", ntohs(r->divert.port));
@


1.236
log
@allow setting TOS with scrub; ok mcbride, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.235 2007/10/15 02:16:35 deraadt Exp $ */
d986 16
@


1.235
log
@specifying int instead of just unsigned is better style
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.234 2006/10/31 23:46:24 mcbride Exp $ */
d956 2
@


1.234
log
@Allow a user to recursively print anchors including those without
reserved names, if a trailing * is specified in the anchor name.
e.g. recursively print the main  ruleset:

	pfctl -a '*' -sr

Recursively print the spam anchor:

	pfctl -a 'spam*'
	pfctl -a 'spam/*'

Also fix a bug which prevented the contents of inline anchors with
explicit names from being loaded into the kernel.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.233 2006/10/28 14:29:05 mcbride Exp $ */
d494 1
a494 1
		unsigned	sec, min, hrs, day = runtime;
@


1.233
log
@Load all rules into memory before loading into the kernel, and add support
for anchors loaded inline in pf.conf, enclosed in a brace-delimited
block ("{" "}").

anchor on fxp0 {
	pass in proto tcp port 22
}

The anchor name is optional on inline loaded anchors.

testing ckuethe@@
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.232 2006/10/25 11:28:36 henning Exp $ */
a670 1
	int	brace = 0;
a677 1
			brace++;
a681 1

a989 3
	if (brace)
		printf(" {");
	printf("\n");
@


1.232
log
@allow the log interface to be selected like
pass log(to pflog5)
block out log(to pflog2)
input & ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.231 2006/10/17 07:14:28 mcbride Exp $ */
d671 1
d677 9
a685 4
	else if (anchor_call[0])
		printf("%s \"%s\"", anchortypes[r->action],
		    anchor_call);
	else {
d993 2
@


1.231
log
@Don't automatically set 'flags S/SA' on stateless rules.

pointed out by david@@

ok mpf@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.230 2006/10/06 17:04:53 mcbride Exp $ */
d736 1
a736 1
		if (r->log & ~PF_LOG) {
d744 3
@


1.230
log
@Print 'flags any' correctly and handle anchors.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.229 2006/10/06 16:42:03 mcbride Exp $ */
d799 1
a799 1
	    !anchor_call[0])
@


1.229
log
@'no state' should only be printed on pass rules, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.228 2006/10/06 16:27:49 mcbride Exp $ */
d796 5
a800 1
	}
d825 1
a825 1
	if (!r->keep_state && r->action == PF_PASS)
@


1.228
log
@Print out 'no state' when the rule is not stateful.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.227 2006/08/08 20:05:54 dhartmei Exp $ */
d821 1
a821 1
	if (!r->keep_state)
@


1.227
log
@properly join host lists in ifa_grouplookup(), closes PR 5195,
reported by andrew fresh
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.226 2006/07/06 13:26:41 henning Exp $ */
d821 3
a823 1
	if (r->keep_state == PF_STATE_NORMAL)
@


1.226
log
@add "rtable" to select alternate routing tables.
with & ok claudio hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.225 2006/06/30 16:52:27 deraadt Exp $ */
d1210 1
a1210 1
	struct node_host	*n, *h = NULL, *hn;
d1235 2
a1236 4
			for (hn = h; hn->next != NULL; hn = hn->next)
				;	/* nothing */
			hn->next = n;
			n->tail = hn;
@


1.225
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.224 2006/05/23 12:04:28 henning Exp $ */
d970 2
@


1.224
log
@member interfaces of groups might have no IPs and ifa_lookup retun NULL,
account for that. fixes PR5130, ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.223 2006/03/21 03:31:09 dhartmei Exp $ */
d488 1
a488 1
	static const char 	hex[] = "0123456789abcdef";
d1239 1
a1239 1
	free(ifgr.ifgr_groups);	
@


1.223
log
@instead of sizeof(array) / sizeof(element) computation, use the existing
end-of-array NULL marker, shuts up source analysis tool, from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.222 2005/11/04 08:24:15 mcbride Exp $ */
d1228 2
a1229 1
		n = ifa_lookup(ifg->ifgrq_member, flags);
@


1.222
log
@crank pf_state and pf_src_node byte and packet counters to u_in64_t, since
we're breaking pfsync compatibility this cycle anyways.

Requested by djm@@, ok henning@@, 'wheee!' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.221 2005/10/18 08:59:30 henning Exp $ */
d924 2
a925 2
				for (j = 0; j < sizeof(pf_timeouts) /
				    sizeof(pf_timeouts[0]); ++j)
d928 3
a930 2
				printf("%s %u", j == PFTM_MAX ?  "inv.timeout" :
				    pf_timeouts[j].name, r->timeout[i]);
@


1.221
log
@add support for static interface group expansion, i. e.
pass to group
ok hshoexer, hacked at linux-kongress last week
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.220 2005/10/13 13:27:06 henning Exp $ */
d641 2
a642 1
		printf(", %u pkts, %u bytes", sn->packets[0] + sn->packets[1],
@


1.220
log
@unused parameters
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.219 2005/06/30 20:52:20 sturm Exp $ */
d57 1
d70 1
d1170 2
d1176 16
d1201 42
d1248 3
@


1.219
log
@in order for pfvar.h not to conflict with openssl's crypto.h, use
PF_MD5_DIGEST_LENGTH instead of including crypto/md5.h

ok markus@@, henning@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.218 2005/06/13 20:17:26 henning Exp $ */
d1165 1
a1165 1
ifa_exists(const char *ifa_name, int group_ok)
d1364 1
a1364 1
	if (ifa_exists(ps, 1) || !strncmp(ps, "self", IFNAMSIZ)) {
@


1.218
log
@make the packet and byte counters on rules and src nodes per direction,
matches the counters on states now. also fix the counting on scrub rules
where we previously did not handle the byte counters at all.
extend pfctl -sl output to include the new seperate in/out counters
hacked on the ferry from Earls Cove to Saltery Bay
ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.217 2005/05/27 22:09:06 mcbride Exp $ */
d485 1
a485 1
	char			buf[MD5_DIGEST_LENGTH * 2 + 1];
d524 1
a524 1
		for (i = 0; i < MD5_DIGEST_LENGTH; i++) {
@


1.217
log
@Hide Hostid and Checksum in pfctl -si output unless the -v flag is used.

Prodded by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.216 2005/05/27 21:41:04 mpf Exp $ */
d639 2
a640 1
		printf(", %u pkts, %u bytes", sn->packets, sn->bytes);
@


1.216
log
@Calculate an MD5 checksum over the main pf ruleset.
This is the basis for further pfsync improvements,
to ensure that pf rules are in sync with the master.

"get it in" mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.215 2005/05/27 18:52:42 dhartmei Exp $ */
a519 1
	printf("Hostid:   0x%08x\n", ntohl(s->hostid));
d521 9
a529 3
	for (i = 0; i < MD5_DIGEST_LENGTH; i++) {
		buf[i + i] = hex[s->pf_chksum[i] >> 4];
		buf[i + i + 1] = hex[s->pf_chksum[i] & 0x0f];
a530 2
	buf[i + i] = '\0';
	printf("Checksum: 0x%s\n\n", buf);
@


1.215
log
@get rid of 'log-all'. now that we have 'log (options)', make 'all' an
option to log. so, 'log-all' becomes 'log (all)'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.214 2005/05/27 17:22:40 dhartmei Exp $ */
d482 5
a486 3
	char	statline[80], *running;
	time_t	runtime;
	int	i;
d520 9
a528 1
	printf("Hostid: 0x%08x\n\n", ntohl(s->hostid));
@


1.214
log
@log two pairs of uid/pid through pflog: the uid/pid of the process that
inserted the rule which causes the logging. secondly, the uid/pid of the
process in case the logged packet is delivered to/from a local socket.
a lookup of the local socket can be forced for logged packets with a new
option, 'log (user)'. make tcpdump print the additional information when
-e and -v is used. note: this changes the pflog header struct, rebuild all
dependancies. ok bob@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.213 2005/05/26 15:30:39 dhartmei Exp $ */
d718 4
a721 5
		if (r->log & PF_LOG_ALL)
			printf(" log-all");
		else
			printf(" log");
		if (r->log & ~(PF_LOG | PF_LOG_ALL)) {
d723 2
d726 1
a726 1
				printf("user");
@


1.213
log
@use PF_LOG, PF_LOGALL instead of numeric constants
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.212 2005/05/21 21:03:58 henning Exp $ */
d717 12
a728 4
	if (r->log == PF_LOG)
		printf(" log");
	else if (r->log == PF_LOGALL)
		printf(" log-all");
@


1.212
log
@clean up and rework the interface absraction code big time, rip out multiple
useless layers of indirection and make the code way cleaner overall.
this is just the start, more to come...
worked very hard on by Ryan and me in Montreal last week, on the airplane to
vancouver and yesterday here in calgary. it hurt.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.211 2004/12/07 10:33:41 dhartmei Exp $ */
d717 1
a717 1
	if (r->log == 1)
d719 1
a719 1
	else if (r->log == 2)
@


1.211
log
@re-commit mcbride@@'s 'flush global', this time without the breakage in
pfvar.h. builds kernel and userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.210 2004/12/07 09:38:04 deraadt Exp $ */
d823 1
a823 1
	if (r->rule_flag & (PFRULE_IFBOUND | PFRULE_GRBOUND))
a888 6
			opts = 0;
		}
		if (r->rule_flag & PFRULE_GRBOUND) {
			if (!opts)
				printf(", ");
			printf("group-bound");
@


1.210
log
@oops, incomplete backout
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.208 2004/12/04 07:58:52 mcbride Exp $ */
d880 1
a880 1
			if (r->rule_flag & PFRULE_SRCTRACK_FLUSH)
d882 2
@


1.209
log
@Change the default for 'overload <table> flush' to flush only states from the
offending source created by the rule. 'flush global' flushes all states
originating from the offending source. ABI change, requires kernel and pfctl
to be in sync.

ok deraadt@@ henning@@ dhartmei@@
@
text
@d880 1
a880 1
			if (r->flush)
a881 2
			if (r->flush & PF_FLUSH_GLOBAL)
				printf(" global");
@


1.208
log
@Userland support for limiting open tcp connections per source. eg:

keep state (max-src-conn 1000, max-src-conn-rate 100/10, overflow <bad> flush)

allow a maximum of 1000 open connections or 100 new connections in 10 seconds.
The addresses of offenders are added to the <bad> table which can be used in
the ruleset, and existing states from that host are flushed.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.207 2004/11/09 11:26:04 dhartmei Exp $ */
d880 1
a880 1
			if (r->rule_flag & PFRULE_SRCTRACK_FLUSH)
d882 2
@


1.207
log
@do not assume entries in pf_timeouts[] are ordererd like PFTM_* in pfvar.h
reported by Alexey E. Suslikov, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.206 2004/09/30 16:38:01 dhartmei Exp $ */
d37 2
d475 1
d578 12
d609 3
a611 1
	printf(" (%d states)\n", sn->states);
d856 14
d875 7
@


1.206
log
@print invalid hostmask when refusing it, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.205 2004/09/27 12:51:12 jaredy Exp $ */
d859 2
d864 6
a869 2
				printf("%s %u", pf_timeouts[i].name,
				    r->timeout[i]);
@


1.205
log
@anchor rules referencing anchors using slashes may need quotes.

ok mcbride henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.204 2004/09/21 16:59:11 aaron Exp $ */
d1227 1
a1227 1
			fprintf(stderr, "invalid netmask\n");
@


1.204
log
@Implement "no scrub" to allow exclusion of specific traffic from scrub rules.
First match wins, just like "no {binat,nat,rdr}".  henning@@, dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.203 2004/07/16 23:44:25 frantzen Exp $ */
d643 2
a644 1
		printf("%s %s", anchortypes[r->action], anchor_call);
@


1.203
log
@'pfctl -o' ruleset optimizer that doesnt change the meaning of the final ruleset
- remove identical and subsetted rules
- when advantageous merge rules w/ similar addresses into a table and one rule
- re-order rules to improve skip step performance (can do better w/ kernel mods)
- 'pfctl -oo' will load the currently running ruleset and use it as a profile
to direct the optimization of quicked rules
ok henning@@ mcbride@@.  man page help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.202 2004/06/29 22:14:13 henning Exp $ */
d631 2
a632 2
	static const char *actiontypes[] = { "pass", "block", "scrub", "nat",
	    "no nat", "binat", "no binat", "rdr", "no rdr" };
d634 2
a635 2
	    "nat-anchor", "nat-anchor", "binat-anchor", "binat-anchor",
	    "rdr-anchor", "rdr-anchor" };
@


1.203.2.1
log
@MFC:
Fix by dhartmei@@

do not assume entries in pf_timeouts[] are ordererd like PFTM_* in pfvar.h
reported by Alexey E. Suslikov

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.203 2004/07/16 23:44:25 frantzen Exp $ */
a857 2
				int j;

d861 2
a862 6
				for (j = 0; j < sizeof(pf_timeouts) /
				    sizeof(pf_timeouts[0]); ++j)
					if (pf_timeouts[j].timeout == i)
						break;
				printf("%s %u", j == PFTM_MAX ?  "inv.timeout" :
				    pf_timeouts[j].name, r->timeout[i]);
@


1.202
log
@remove cedric's bogus interface name verification code.
this was meant to verify that ne3 is a valid interface that could show
up, but bogus0 is not. while this might sound like a good idea it is
completely broken and causes a shitload of problems. just allow for anything
as interface name, the kernel abstracts that nice enough. if no interface
by that name exists (or shows up) the rule never matches; that matches
pf semantics used everywhere else.
this also fixes the "pfctl always has to run as root" issue that cedric
did not fix over the last 6 months despite being bugged to regularily.
help & ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.201 2004/06/10 14:22:54 dhartmei Exp $ */
d969 1
a969 3

	for (i = 0; i < 4; i++)
		m->addr32[i] = 0;
@


1.201
log
@rename struct pf_rule_addr member 'not' to 'neg', as 'not' is a reserved
keyword in C++. ok henning@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.200 2004/05/27 11:48:06 henning Exp $ */
a1022 2
	struct pfr_buffer	 b;
	struct pfi_if		*p;
a1097 37
	/* add interface groups, including clonable and dynamic stuff */
	bzero(&b, sizeof(b));
	b.pfrb_type = PFRB_IFACES;
	for (;;) {
		if (pfr_buf_grow(&b, b.pfrb_size))
			err(1, "ifa_load: pfr_buf_grow");
		b.pfrb_size = b.pfrb_msize;
		if (pfi_get_ifaces(NULL, b.pfrb_caddr, &b.pfrb_size,
		    PFI_FLAG_GROUP))
			err(1, "ifa_load: pfi_get_ifaces");
		if (b.pfrb_size <= b.pfrb_msize)
			break;
	}
	PFRB_FOREACH(p, &b) {
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
			err(1, "address: calloc");
		n->af = AF_LINK;
		n->ifa_flags = PF_IFA_FLAG_GROUP;
		if (p->pfif_flags & PFI_IFLAG_DYNAMIC)
			n->ifa_flags |= PF_IFA_FLAG_DYNAMIC;
		if (p->pfif_flags & PFI_IFLAG_CLONABLE)
			n->ifa_flags |= PF_IFA_FLAG_CLONABLE;
		if (!strcmp(p->pfif_name, "lo"))
			n->ifa_flags |= IFF_LOOPBACK;
		if ((n->ifname = strdup(p->pfif_name)) == NULL)
			err(1, "ifa_load: strdup");
		n->next = NULL;
		n->tail = n;
		if (h == NULL)
			h = n;
		else {
			h->tail->next = n;
			h->tail = n;
		}
	}

a1105 2
	char			*p, buf[IFNAMSIZ];
	int			 group;
a1106 3
	group = !isdigit(ifa_name[strlen(ifa_name) - 1]);
	if (group && !group_ok)
		return (NULL);
d1114 1
a1114 13
	if (!group) {
		/* look for clonable and/or dynamic interface */
		strlcpy(buf, ifa_name, sizeof(buf));
		for (p = buf + strlen(buf) - 1; p > buf && isdigit(*p); p--)
			*p = '\0';
		for (n = iftab; n != NULL; n = n->next)
			if (n->af == AF_LINK &&
			    !strncmp(n->ifname, buf, IFNAMSIZ))
				break;
		if (n != NULL && n->ifa_flags &
		    (PF_IFA_FLAG_DYNAMIC | PF_IFA_FLAG_CLONABLE))
			return (n);	/* XXX */
	}
@


1.200
log
@plug memleak in error path
From: Andrey Matveev <andrushock@@korovino.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.199 2004/05/19 17:50:51 dhartmei Exp $ */
d367 1
a367 1
	    !src->not && !dst->not &&
d373 1
a373 1
		if (src->not)
d385 1
a385 1
		if (dst->not)
@


1.199
log
@Allow recursive anchors (anchors within anchors, up to 64
levels deep). More work required, but this is already
functional. authpf users will need to adjust their anchor
calls, but this will change again soon. ok beck@@, cedric@@,
henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.198 2004/05/07 16:54:20 henning Exp $ */
d1447 2
a1448 1
	if (error)
d1450 1
@


1.198
log
@typos
From: Jared Yanovich <phirerunner@@comcast.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.197 2004/05/05 23:16:03 frantzen Exp $ */
d629 1
a629 1
print_rule(struct pf_rule *r, int verbose)
d642 2
a643 2
	else if (r->anchorname[0])
		printf("%s %s", anchortypes[r->action], r->anchorname);
d902 1
a902 1
	if (!r->anchorname[0] && (r->action == PF_NAT ||
d1572 1
a1572 2
pfctl_add_trans(struct pfr_buffer *buf, int rs_num, const char *anchor,
    const char *ruleset)
d1579 1
a1579 3
	    sizeof(trans.anchor)) >= sizeof(trans.anchor) ||
	    strlcpy(trans.ruleset, ruleset,
	    sizeof(trans.ruleset)) >= sizeof(trans.ruleset))
d1586 1
a1586 2
pfctl_get_ticket(struct pfr_buffer *buf, int rs_num, const char *anchor,
    const char *ruleset)
d1591 1
a1591 2
		if (rs_num == p->rs_num && !strcmp(anchor, p->anchor) &&
		    !strcmp(ruleset, p->ruleset))
@


1.197
log
@Use RFC1323 PAWS timestamps as a logical extension to the conventional TCP
sequence numbers by taking advantage of the maximum 1KHz clock as an upperbound
on the timestamp.  Typically gains 10 to 18 bits of additional security against
blind data insertion attacks.  More if the TS Echo wasn't optional :-(
Enabled with:  scrub on !lo0 all reassemble tcp
ok dhartmei@@.  documentation help from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.196 2004/04/24 23:22:54 cedric Exp $ */
d1438 1
a1438 1
		err(1, "host_if: strdup");
d1598 1
a1598 1
	errx(1, "pfr_get_ticket: assertion failed");
@


1.196
log
@Add "probability xxx" rule modifier. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.195 2004/04/14 10:51:10 cedric Exp $ */
d186 1
@


1.195
log
@Better interface filtering. vlan1 should not match vlan19.
Found by Mike Wolman, ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.194 2004/03/15 15:25:44 dhartmei Exp $ */
d782 15
@


1.194
log
@cast %llu arguments to unsigned long long, from Max Laier,
ok henning@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.193 2004/03/10 17:48:48 henning Exp $ */
d65 1
d1162 1
a1162 1
	int			 return_all = 0, got4 = 0, got6 = 0;
d1166 1
a1166 1
		return_all = 1;
d1172 1
a1172 3
		if (!((p->af == AF_INET || p->af == AF_INET6) &&
		    (!strncmp(p->ifname, ifa_name, strlen(ifa_name)) ||
		    return_all)))
d1235 22
@


1.194.2.1
log
@MFC:
Fix by cedric@@

Better interface filtering. vlan1 should not match vlan19.
Found by Mike Wolman

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.194 2004/03/15 15:25:44 dhartmei Exp $ */
a64 1
int		 ifa_skip_if(const char *filter, struct node_host *p);
d1161 1
a1161 1
	int			 got4 = 0, got6 = 0;
d1165 1
a1165 1
		ifa_name = NULL;
d1171 3
a1173 1
		if (ifa_skip_if(ifa_name, p))
a1235 22

int
ifa_skip_if(const char *filter, struct node_host *p)
{
	int	n;

	if (p->af != AF_INET && p->af != AF_INET6)
		return (1);
	if (filter == NULL || !*filter)
		return (0);
	if (!strcmp(p->ifname, filter))
		return (0);	/* exact match */
	n = strlen(filter);
	if (n < 1 || n >= IFNAMSIZ)
		return (1);	/* sanity check */
	if (filter[n-1] >= '0' && filter[n-1] <= '9')
		return (1);	/* only do exact match in that case */
	if (strncmp(p->ifname, filter, n))
		return (1);	/* prefix doesn't match */
	return (p->ifname[n] < '0' || p->ifname[n] > '9');
}

@


1.193
log
@plug 3 memory leaks; 2 from andrushock, 1 by me
ok pb deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.192 2004/02/10 17:53:37 henning Exp $ */
d518 2
a519 1
		    s->bcounters[0][0], s->bcounters[1][0]);
d521 2
a522 1
		    s->bcounters[0][1], s->bcounters[1][1]);
d525 2
a526 2
		    s->pcounters[0][0][PF_PASS],
		    s->pcounters[1][0][PF_PASS]);
d528 2
a529 2
		    s->pcounters[0][0][PF_DROP],
		    s->pcounters[1][0][PF_DROP]);
d532 2
a533 2
		    s->pcounters[0][1][PF_PASS],
		    s->pcounters[1][1][PF_PASS]);
d535 2
a536 2
		    s->pcounters[0][1][PF_DROP],
		    s->pcounters[1][1][PF_DROP]);
@


1.192
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.191 2004/02/10 09:27:01 cedric Exp $ */
d1302 2
a1303 1
		else
d1305 1
d1310 1
d1316 1
@


1.191
log
@new kernel reports enabled & disabled time - use that info.
ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.190 2004/02/03 17:59:37 henning Exp $ */
d257 1
a257 1
		   sizeof(icmp6_code[0])); i++) {
d661 1
a661 1
			switch(r->af) {
d1024 2
a1025 1
		    ((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_scope_id == 0) {
d1062 1
a1062 1
			if(ifa->ifa_dstaddr != NULL)
@


1.190
log
@bring back this fluffy change, of course without the bug:
==
to parse v4 adresses, only use inet_net_pton when we find a /, otherwise
use inet_pton.
helps bob who likes to type 1.2 3.4 instead of 1.2.3.4 and wonders why this
results in two addresses.
PR3638, bob ok
==
make sure bits is either 32 or what inet_net_pton tells us, and always call
set_ipmask to mask the boring bits away

ok dhartmei@@ mcbride@@ david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.188 2004/01/22 13:32:00 henning Exp $ */
d477 1
a477 1
	char	statline[80];
d482 1
d484 1
a484 1
	if (s->running) {
d494 2
a495 2
		    "Status: Enabled for %u days %.2u:%.2u:%.2u",
		    day, hrs, min, sec);
d497 1
a497 1
		snprintf(statline, sizeof(statline), "Status: Disabled");
@


1.189
log
@This fix was made WITHOUT RUNNING REGRESS.  Henning, you are being
extremely unfluffy, King Bula is coming for your head.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.187 2003/12/31 22:14:41 deraadt Exp $ */
d1329 1
a1329 1
	int			 bits;
d1332 6
a1337 10
	if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) > -1) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET;
		h->addr.v.a.addr.addr32[0] = ina.s_addr;
		set_ipmask(h, bits);
		h->next = NULL;
		h->tail = h;
d1339 10
@


1.188
log
@to parse v4 adresses, only use inet_net_pton when we find a /, otherwise
use inet_pton.
helps bob who likes to type 1.2 3.4 instead of 1.2.3.4 and wonders why this
results in two addresses.
PR3638, bob ok
@
text
@d1329 1
a1329 1
	int			 bits = -1;
d1332 10
a1341 6
	if (strrchr(s, '/') != NULL) {
		if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) == -1)
			return (NULL);
	} else {
		if (inet_pton(AF_INET, s, &ina) != 1)
			return (NULL);
a1342 11

	h = calloc(1, sizeof(struct node_host));
	if (h == NULL)
		err(1, "address: calloc");
	h->ifname = NULL;
	h->af = AF_INET;
	h->addr.v.a.addr.addr32[0] = ina.s_addr;
	if (bits != -1)
		set_ipmask(h, bits);
	h->next = NULL;
	h->tail = h;
@


1.187
log
@spacing.  note this, cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.186 2003/12/31 11:18:24 cedric Exp $ */
d1329 1
a1329 1
	int			 bits;
d1332 15
a1346 7
	if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(ina))) > -1) {
		h = calloc(1, sizeof(struct node_host));
		if (h == NULL)
			err(1, "address: calloc");
		h->ifname = NULL;
		h->af = AF_INET;
		h->addr.v.a.addr.addr32[0] = ina.s_addr;
d1348 2
a1349 3
		h->next = NULL;
		h->tail = h;
	}
@


1.186
log
@Many improvements to the handling of interfaces in PF.

1) PF should do the right thing when unplugging/replugging or cloning/
destroying NICs.

2) Rules can be loaded in the kernel for not-yet-existing devices
(USB, PCMCIA, Cardbus). For example, it is valid to write:
"pass in on kue0" before kue USB is plugged in.

3) It is possible to write rules that apply to group of interfaces
(drivers), like "pass in on ppp all"

4) There is a new ":peer" modifier that completes the ":broadcast"
and ":network" modifiers.

5) There is a new ":0" modifier that will filter out interface aliases.
Can also be applied to DNS names to restore original PF behaviour.

6) The dynamic interface syntax (foo) has been vastly improved, and
now support multiple addresses, v4 and v6 addresses, and all userland
modifiers, like "pass in from (fxp0:network)"

7) Scrub rules now support the !if syntax.

8) States can be bound to the specific interface that created them or
to  a group of interfaces for example:

- pass all keep state (if-bound)
- pass all keep state (group-bound)
- pass all keep state (floating)

9) The default value when only keep state is given can be selected by
using the "set state-policy" statement.

10) "pfctl -ss" will now print the interface scope of the state.

This diff change the pf_state structure slighltly, so you should
recompile your userland tools (pfctl, authpf, pflogd, tcpdump...)

Tested on i386, sparc, sparc64 by Ryan
Tested on macppc, sparc64 by Daniel

ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.185 2003/12/19 16:12:43 henning Exp $ */
d1115 1
a1115 1
		
d1147 2
a1148 2
		    (PF_IFA_FLAG_DYNAMIC | PF_IFA_FLAG_CLONABLE)) 
			return (n); 	/* XXX */
@


1.185
log
@i wrote much of these, assert my copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.184 2003/12/17 16:36:30 dhartmei Exp $ */
d785 2
d824 12
d1003 2
d1045 4
d1060 4
d1078 38
d1121 1
a1121 1
ifa_exists(const char *ifa_name)
d1124 2
d1127 3
d1137 13
d1154 1
a1154 1
ifa_lookup(const char *ifa_name, enum pfctl_iflookup_mode mode)
d1157 2
a1158 1
	int			 return_all = 0;
d1168 7
a1174 1
		    (!strncmp(p->ifname, ifa_name, IFNAMSIZ) || return_all)))
d1176 2
a1177 1
		if (mode == PFCTL_IFLOOKUP_BCAST && p->af != AF_INET)
d1179 1
a1179 1
		if (mode == PFCTL_IFLOOKUP_NET && p->ifindex > 0)
d1181 11
d1196 1
a1196 1
		if (mode == PFCTL_IFLOOKUP_BCAST)
d1199 3
d1205 1
a1205 1
		if (mode == PFCTL_IFLOOKUP_NET)
a1229 3
	if (h == NULL && mode == PFCTL_IFLOOKUP_HOST) {
		fprintf(stderr, "no IP address found for %s\n", ifa_name);
	}
d1287 1
a1287 1
	int			 mode = PFCTL_IFLOOKUP_HOST;
d1289 3
a1291 2
	if ((p = strrchr(s, ':')) != NULL &&
	    (!strcmp(p+1, "network") || !strcmp(p+1, "broadcast"))) {
d1293 8
a1300 6
			mode = PFCTL_IFLOOKUP_NET;
		if (!strcmp(p+1, "broadcast"))
			mode = PFCTL_IFLOOKUP_BCAST;
		if (mask > -1) {
			fprintf(stderr, "network or broadcast lookup, but "
			    "extra netmask given\n");
d1302 12
a1313 9
		}
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
	} else
		if ((ps = strdup(s)) == NULL)
			err(1, "host_if: strdup");

	if (ifa_exists(ps) || !strncmp(ps, "self", IFNAMSIZ)) {
d1315 1
a1315 1
		h = ifa_lookup(ps, mode);
d1382 3
a1384 1
	int			 error;
d1386 6
d1395 1
a1395 1
	error = getaddrinfo(s, NULL, &hints, &res0);
d1403 11
d1445 1
@


1.184
log
@cosmetics, ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.183 2003/12/15 07:11:30 mcbride Exp $ */
d5 1
@


1.183
log
@Add initial support for pf state synchronization over the network.
Implemented as an in-kernel multicast IP protocol.

Turn it on like this:

# ifconfig pfsync0 up syncif fxp0

There is not yet any authentication on this protocol, so the syncif
must be on a trusted network. ie, a crossover cable between the two
firewalls.

NOTABLE CHANGES:
- A new index based on a unique (creatorid, stateid) tuple has been
  added to the state tree.
- Updates now appear on the pfsync(4) interface; multiple updates may
  be compressed into a single update.
- Applications which use bpf on pfsync(4) will need modification;
  packets on pfsync no longer contains regular pf_state structs,
  but pfsync_state structs which contain no pointers.

Much more to come.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.182 2003/12/15 00:02:03 mcbride Exp $ */
d511 1
a511 1
	printf("hostid: 0x%08x\n\n", ntohl(s->hostid));
d537 1
a537 1
		printf("  %-25s %14llu", pf_fcounters[i],
@


1.182
log
@Add support to track stateful connections by source ip. This allows us
to:
- Ensure that clients get a consistent IP mapping with load-balanced
  translation/routing rules
- Limit the number of simultaneous connections a client can make
- Limit the number of clients which can connect through a rule

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.181 2003/11/14 15:32:33 henning Exp $ */
d511 1
@


1.181
log
@in print_status:
-print debuglevel "Loud", this was omitted before (catched by mpech@@)
-use the fine PF_DEBUG_* defines instead of magic numbers

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.180 2003/11/08 00:45:34 mcbride Exp $ */
d196 1
d463 2
d471 1
d474 1
a474 1
print_status(struct pf_status *s)
d544 14
d571 51
d777 1
a777 1
	if (r->max_states)
d781 2
d796 22
@


1.180
log
@Add 'no-sync' state option to prevent state transition messages for states
created by this rule from appearing on the pfsync(4) interface. e.g.

pass in proto tcp to self flags S/SA keep state (no-sync)

ok cedric@@ henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.179 2003/11/06 15:18:12 henning Exp $ */
d494 1
a494 1
	case 0:
d497 1
a497 1
	case 1:
d500 1
a500 1
	case 2:
d502 3
@


1.179
log
@two more KNF violations I missed earlier. who introduces those all the time?
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.178 2003/11/06 15:02:11 henning Exp $ */
d707 2
d716 6
@


1.178
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.177 2003/10/08 14:47:57 henning Exp $ */
d1291 1
a1291 1
    const char *ruleset) 
d1308 1
a1308 1
    const char *ruleset) 
@


1.177
log
@fix cedric's breakage:
int is not the same as u_long
caused an integer overflow on our 64 bit archs and thus made pf not working
there

ok mcbride@@ marc@@ millert@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.176 2003/09/26 21:44:09 cedric Exp $ */
d1311 1
a1311 1
	
@


1.176
log
@Rearchitecture of the userland/kernel IOCTL interface for transactions.
This brings us close to 100% atomicity for a "pfctl -f pf.conf" command.
(some splxxx work remain in the kernel). Basically, improvements are:

   - Anchors/Rulesets cannot disappear unexpectedly anymore.
   - No more leftover in the kernel if "pfctl -f" fail.
   - Commit is now done in a single atomic IOCTL.

WARNING: The kernel code is fully backward compatible, but the new
pfctl/authpf userland utilities will only run on a new kernel.

The following ioctls are deprecated (i.e. will be deleted sooner or
later, depending on how many 3rd party utilities use them and how soon
they can be upgraded):

   - DIOCBEGINRULES
   - DIOCCOMMITRULES
   - DIOCBEGINALTQS
   - DIOCCOMMITALTQS
   - DIOCRINABEGIN
   - DIOCRINADEFINE

They are replaced by the following ioctls (yes, PF(4) will follow)
which operate on a vector of rulesets:

   - DIOCXBEGIN
   - DIOCXCOMMIT
   - DIOCXROLLBACK

Ok dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.175 2003/09/18 20:27:58 cedric Exp $ */
d1320 1
a1320 1
pfctl_trans(int dev, struct pfr_buffer *buf, int cmd, int from)
@


1.175
log
@Not all address types have a mask.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.174 2003/08/22 21:52:11 itojun Exp $ */
d34 1
d1287 42
@


1.174
log
@correct printf arg mismatch (in 64bit arch). dhartmei ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.173 2003/08/21 19:12:08 frantzen Exp $ */
d855 2
@


1.173
log
@Add Michal Zalewski's p0f v2 style passive OS fingerprinting to PF.
Exposes the source IP's operating system to the filter language.
Interesting policy decisions are now enforceable:
.	block proto tcp from any os SCO
.	block proto tcp from any os Windows to any port smtp
.	rdr ... from any os "Windows 98" to port WWW -> 127.0.0.1 port 8001
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.172 2003/07/29 19:47:22 cedric Exp $ */
d528 2
a529 2
		printf("  %-25s %14lld ", pf_fcounters[i],
			    s->fcounters[i]);
d538 2
a539 2
		printf("  %-25s %14lld ", pf_reasons[i],
		    s->counters[i]);
@


1.172
log
@Remove space at end of line.
Ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.171 2003/07/21 22:31:36 henning Exp $ */
d61 2
a62 2
void		 print_fromto(struct pf_rule_addr *, struct pf_rule_addr *,
		    u_int8_t, u_int8_t, int);
d352 1
a352 1
print_fromto(struct pf_rule_addr *src, struct pf_rule_addr *dst,
d355 1
d363 2
a364 1
	    !src->port_op && !dst->port_op)
d375 3
d659 2
a660 1
	print_fromto(&r->src, &r->dst, r->af, r->proto, verbose);
@


1.171
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.170 2003/07/19 13:08:58 cedric Exp $ */
d290 1
a290 1
		printf("%s >< %s ", a1, a2);
d292 1
a292 1
		printf("%s <> %s ", a1, a2);
d294 1
a294 1
		printf("= %s ", a1);
d296 1
a296 1
		printf("!= %s ", a1);
d298 1
a298 1
		printf("< %s ", a1);
d300 1
a300 1
		printf("<= %s ", a1);
d302 1
a302 1
		printf("> %s ", a1);
d304 1
a304 1
		printf(">= %s ", a1);
d306 1
a306 1
		printf("%s:%s ", a1, a2);
d320 1
a320 1
	printf("port ");
d334 1
a334 1
	printf("%s ", t);
d363 1
a363 1
		printf("all ");
d365 1
a365 1
		printf("from ");
a368 1
		printf(" ");
d374 1
a374 1
		printf("to ");
a377 1
		printf(" ");
d556 1
a556 1
		printf("action(%d) ", r->action);
d558 1
a558 1
		printf("%s %s ", anchortypes[r->action], r->anchorname);
d560 1
a560 1
		printf("%s ", actiontypes[r->action]);
d562 1
a562 1
			printf("pass ");
d566 1
a566 1
			printf("return ");
d569 1
a569 1
				printf("return-rst ");
d571 1
a571 1
				printf("return-rst(ttl %d) ", r->return_ttl);
d582 1
a582 1
				printf("return-icmp");
d584 1
a584 1
					printf("(%u) ", r->return_icmp & 255);
d586 1
a586 1
					printf("(%s) ", ic->name);
d589 1
a589 1
				printf("return-icmp6");
d591 1
a591 1
					printf("(%u) ", r->return_icmp6 & 255);
d593 1
a593 1
					printf("(%s) ", ic6->name);
d596 1
a596 1
				printf("return-icmp");
d602 1
a602 1
					printf("%u) ", r->return_icmp6 & 255);
d604 1
a604 1
					printf("%s) ", ic6->name);
d608 1
a608 1
			printf("drop ");
d611 1
a611 1
		printf("in ");
d613 1
a613 1
		printf("out ");
d615 1
a615 1
		printf("log ");
d617 1
a617 1
		printf("log-all ");
d619 1
a619 1
		printf("quick ");
d622 1
a622 1
			printf("on ! %s ", r->ifname);
d624 1
a624 1
			printf("on %s ", r->ifname);
d628 1
a628 1
			printf("route-to ");
d630 1
a630 1
			printf("reply-to ");
d632 1
a632 1
			printf("dup-to ");
d634 1
a634 1
			printf("fastroute ");
d636 1
a637 1
			printf(" ");
d642 1
a642 1
			printf("inet ");
d644 1
a644 1
			printf("inet6 ");
d650 1
a650 1
			printf("proto %s ", p->p_name);
d652 1
a652 1
			printf("proto %u ", r->proto);
d662 1
a662 1
		printf("flags ");
a665 1
		printf(" ");
d672 1
a672 1
			printf("icmp-type");
d674 1
a674 1
			printf("icmp6-type");
d676 1
a676 1
			printf(" %s ", it->name);
d678 1
a678 1
			printf(" %u ", r->type-1);
d684 1
a684 1
				printf("code %s ", ic->name);
d686 1
a686 1
				printf("code %u ", r->code-1);
d690 1
a690 1
		printf("tos 0x%2.2x ", r->tos);
d692 1
a692 1
		printf("keep state ");
d694 1
a694 1
		printf("modulate state ");
d696 1
a696 1
		printf("synproxy state ");
d704 1
a704 1
		printf("(");
d717 1
a717 1
		printf(") ");
d720 1
a720 1
		printf("fragment ");
d722 1
a722 1
		printf("no-df ");
d724 1
a724 1
		printf("random-id ");
d726 1
a726 1
		printf("min-ttl %d ", r->min_ttl);
d728 1
a728 1
		printf("max-mss %d ", r->max_mss);
d730 1
a730 1
		printf("allow-opts ");
d733 1
a733 1
			printf("reassemble tcp ");
d736 1
a736 1
			printf("fragment drop-ovl ");
d738 1
a738 1
			printf("fragment crop ");
d740 1
a740 1
			printf("fragment reassemble ");
d743 1
a743 1
		printf("label \"%s\" ", r->label);
d745 1
a745 1
		printf("queue(%s, %s) ", r->qname, r->pqname);
d747 1
a747 1
		printf("queue %s ", r->qname);
d749 1
a749 1
		printf("tag %s ", r->tagname);
d752 2
a753 2
			printf("! ");
		printf("tagged %s ", r->match_tagname);
d757 1
a757 1
		printf("-> ");
@


1.170
log
@Simplify struct pf_pooladdr to include struct pf_addr_wrap directly
instead of indirectly trough struct pf_rule_addr.

Ryan McBride says:
If I'm not mistaken, the code _used_ to use the ports in pf_rule_addr as
well. The code was changed to fix some of the bugs with port ranges, but
it was too late in the release cycle to make kernel API changes, so the
structure was left as is.

Needless to say: KERNEL/USERLAND SYNC REQUIRED.

ok henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.169 2003/07/15 17:12:38 cedric Exp $ */
d785 1
a785 1
		for(;;) {
@


1.169
log
@Repair memory managment in table parsing code.
I need vacations.
Found and verified by Pyun YongHyeon.
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.168 2003/07/11 08:29:34 cedric Exp $ */
d401 1
a401 1
			print_addr(&pooladdr->addr.addr, af, 0);
d404 1
a404 1
			if (PF_AZERO(&pooladdr->addr.addr.v.a.addr, af))
d408 1
a408 1
				print_addr(&pooladdr->addr.addr, af, 0);
@


1.168
log
@Better parsing and -v support for tables:

  - remove the tableaddrs and tableaddr yacc production and reuse
    host_list instead.
  - produce better error messages.
  - do not load addresses from external file when it is not
    required (like with -R option).
  - store initializers in a new node_tinit linked list before
    putting them into the address buffer (see next point).
  - add a new print_tabledef() function, which makes "pfctl -nvf"
    print something useful for table definitions, which in turn
    makes it possible to write better regress tests (see first chunk
    of the diff) and bring table definition consistant with other
    parsed rules.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.167 2003/07/04 11:05:44 henning Exp $ */
d1222 2
a1223 2
	struct node_host	*n;
	int			 not = 0;
d1231 7
a1237 1
	return append_addr_host(b, n, test, not);
d1242 1
a1242 1
 * to "negate" the result.
a1249 1
	struct node_host	*h;
d1278 1
a1278 4
		h = n;
		n = n->next;
		free(h);
	} while (n != NULL);
@


1.167
log
@KNF after cedric (grmpf)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.166 2003/07/04 10:42:17 henning Exp $ */
d767 36
d1221 11
a1231 1
	return append_addr_not(b, s, test, 0);
d1235 2
a1236 1
 * same as previous function, but with the ability to "negate" the result.
d1238 1
a1238 1
 *	setting it to 1 is equivalent to adding "!" in front of parameter s.
d1241 1
a1241 1
append_addr_not(struct pfr_buffer *b, char *s, int test, int not)
a1242 1
	char			 buf[256], *r;
d1244 1
a1244 1
	struct node_host	*n, *h;
a1246 10
	for (r = s; *r == '!'; r++)
		not = !not;
	if (strlcpy(buf, r, sizeof(buf)) >= sizeof(buf)) {
		errno = EINVAL;
		return (-1);
	}
	if ((n = host(buf)) == NULL) {
		errno = 0;
		return (-1);
	}
d1249 1
a1249 1
		addr.pfra_not = not;
@


1.166
log
@allow for a "pass" modifier on translation rules:
nat pass on $ext_if from $a to $b -> $ext_if
when the pass modifier is given, the filter ruleset is _not_ evaluated but
the packets matching this translation rule are passed unconditionally.

ok dhartmei@@ cedric@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.165 2003/07/03 09:13:06 cedric Exp $ */
d1183 1
a1183 1
append_addr(struct pfr_buffer *b, char *s, int test) 
@


1.165
log
@This patch finally cleanup pfctl_table.c. No more global buffer,
and a couple of parsing functions moved to parse.y or pfctl_parser
where they belong.

I also took the opportunity to replace "void" functions with exit(1)
or err() inside by "int" functions, with the caller checking the
return value for errors (much cleaner and an old request from Theo)

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.164 2003/06/12 09:40:33 henning Exp $ */
d561 1
a561 1
	else
d563 3
@


1.164
log
@in set_ipmask, do not try to mask off irrelevant bits of anything but
PF_ADDRMASK. due to the union this resulted in "masking" interface names in
the dynaddr case...
<henning@@quigon:1>$ echo "pass inet from (le0)/8" | pfctl -nvf -
pass inet from (l)/8 to any
reported by AARON SUEN <ags137 at psu.edu> on misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.163 2003/06/11 02:54:02 itojun Exp $ */
d1172 68
@


1.163
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
  (note: sizeof(ip6_rthdr0) has changed!)
  also, sync up with RFC2460 routing header definition (no "strict" source
  routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.162 2003/06/09 11:14:46 mcbride Exp $ */
d801 3
a803 2
	for (i = 0; i < 4; i++)
		n->addr32[i] = n->addr32[i] & m->addr32[i];
@


1.162
log
@Attempt to resolve byte order confusion in nat code once and for all.

- pf_get_sport() leaves the translated port in the packet in network byte order
- merge code for the p1=0 p2=0 case and static-port case in pr_get_sport()

NOTE: people who use the static-port keyword in their pf.conf need to make sure pfctl is updated along with their kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.161 2003/05/24 19:14:06 henning Exp $ */
d107 1
a107 1
	{ "listqry",	MLD6_LISTENER_QUERY },
d109 1
a109 1
	{ "listenrep",	MLD6_LISTENER_REPORT },
d111 1
a111 1
	{ "listendone", MLD6_LISTENER_DONE },
d124 2
a125 2
	{ "mtraceresp",	MLD6_MTRACE_RESP },
	{ "mtrace",	MLD6_MTRACE }
@


1.161
log
@better netmask check
help canacar@@

ok canacar@@ cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.160 2003/05/19 20:21:53 henning Exp $ */
d422 2
a423 2
		if (p1 != PF_NAT_PROXY_PORT_LOW ||
		    p2 != PF_NAT_PROXY_PORT_HIGH) {
d458 1
a458 1
	if (pool->opts & PF_POOL_STATICPORT)
@


1.160
log
@reject invalid netmasks like 10.0.0.0/68, and fix up the netmask for
dynaddr rules after we know the address family

ok dhartmei@@, inspired by a session with bob
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.159 2003/05/19 18:21:01 henning Exp $ */
d991 1
a991 1
		if (!q || *q || mask > 128) {
@


1.159
log
@err out on obviously wrong netmasks
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.158 2003/05/17 02:04:24 henning Exp $ */
d803 23
@


1.158
log
@support inverse matching on tags like
block in ! tagged sometag

ok dhartmei@@ pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.157 2003/05/16 17:15:17 dhartmei Exp $ */
d968 1
a968 1
		if (!q || *q) {
@


1.157
log
@TCP SYN proxy. Instead of 'keep state' or 'modulate state', one can use
'synproxy state' for TCP connections. pf will complete the TCP handshake
with the active endpoint before passing any packets to the passive end-
point, preventing spoofed SYN floods from reaching the passive endpoint.

No additional memory requirements, no cookies needed, random initial
sequence numbers, uses the existing sequence number modulators to translate
packets after the handshakes.

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.156 2003/05/14 23:51:29 frantzen Exp $ */
d750 3
a752 1
	if (r->match_tagname[0])
d754 1
@


1.156
log
@add scrub modifier "reassemble tcp" to turn on stateful TCP normalizations
ok henning@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.155 2003/05/14 00:56:38 henning Exp $ */
d695 2
@


1.155
log
@print the redirection target for nat/rdr/binat slighly later.
no functional difference (yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.154 2003/05/13 21:37:42 henning Exp $ */
d730 3
@


1.154
log
@correct rule printing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.153 2003/05/13 21:15:07 henning Exp $ */
a653 6
	if (!r->anchorname[0] && (r->action == PF_NAT ||
	    r->action == PF_BINAT || r->action == PF_RDR)) {
		printf("-> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, r->action);
	}
d747 6
@


1.153
log
@userland part for tagging.
it's now possible to tag packets with an arbitary tag and filter based on
that tag later on other interfaces:
pass in quick on fxp0 keep state tag blah
pass out quick on wi0 keep state with tag blah
can be used to express trust between interfaces, to distinguish between
NATed connections and connection originating from teh firewall itself
and much more

ok dhartmei@@ frantzen@@ pb@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.152 2003/05/12 01:25:31 dhartmei Exp $ */
d752 1
a752 1
		printf("with tag %s ", r->match_tagname);
@


1.152
log
@Adaptive timeout value scaling. Allows to reduce timeout values as the
number of state table entries grows, so entries time out faster before
the table fills up. Works both globally and per-rule. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.151 2003/04/25 19:44:57 henning Exp $ */
d749 4
a752 1

@


1.151
log
@kill a workaround now that inet_net_pton acts reasonably
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.150 2003/04/05 23:56:32 henning Exp $ */
d193 2
@


1.150
log
@ease netmask handling a bit

input theo, ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.149 2003/04/03 15:52:24 cedric Exp $ */
a1045 4
		/* inet_net_pton acts strange w/ multicast addresses, RFC1112 */
		if (mask == -1 && h->addr.v.a.addr.addr8[0] >= 224 &&
		    h->addr.v.a.addr.addr8[0] < 240)
			bits = 32;
@


1.149
log
@Simplify pfctl printing code.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.148 2003/03/28 20:37:29 henning Exp $ */
d947 1
a947 1
host(const char *s, int mask)
d950 2
a951 2
	int			 v4mask, v6mask, cont = 1;
	char			*buf = NULL, *p, *q, *ps;
a953 5
		if (mask != -1) {
			fprintf(stderr, "address with netmask specified"
			    " and extra netmask supplied\n");
			return (NULL);
		}
a958 2
		if ((buf = strdup(s)) == NULL)
			err(1, "host: strdup");
d964 5
a968 15
		if (asprintf(&ps, "%s", s) == -1)
			err(1, "host: asprintf");
		if (mask == -1) {
			if (asprintf(&buf, "%s", s) == -1)
				err(1, "host: asprintf");
			v4mask = 32;
			v6mask = 128;
		} else if (mask <= 128) {
			if (asprintf(&buf, "%s/%d", s, mask) == -1)
				err(1, "host: asprintf");
			v4mask = v6mask = mask;
		} else {
			fprintf(stderr, "illegal mask %d\n", mask);
			return (NULL);
		}
d976 1
a976 1
	if (cont && (h = host_v4(buf, mask)) != NULL)
a977 1
	free(buf);
@


1.148
log
@one more const was missing
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.147 2003/03/27 18:01:57 henning Exp $ */
d59 1
a59 2
void		 print_uid (u_int8_t, uid_t, uid_t, const char *);
void		 print_gid (u_int8_t, gid_t, gid_t, const char *);
d326 1
a326 1
print_uid(u_int8_t op, uid_t u1, uid_t u2, const char *t)
d333 1
a333 15
	if (u1 == UID_MAX && (op == PF_OP_EQ || op == PF_OP_NE))
		print_op(op, "unknown", a2);
	else
		print_op(op, a1, a2);
}

void
print_gid(u_int8_t op, gid_t g1, gid_t g2, const char *t)
{
	char	a1[11], a2[11];

	snprintf(a1, sizeof(a1), "%u", g1);
	snprintf(a2, sizeof(a2), "%u", g2);
	printf("%s ", t);
	if (g1 == GID_MAX && (op == PF_OP_EQ || op == PF_OP_NE))
d353 2
a354 2
	if (src->addr.type != PF_ADDR_NOROUTE &&
	    dst->addr.type != PF_ADDR_NOROUTE &&
d357 4
a360 2
	    !src->port_op && PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.v.a.mask, AF_INET6) && !dst->port_op)
d364 4
a367 11
		if (src->addr.type == PF_ADDR_NOROUTE)
			printf("no-route ");
		else if (PF_AZERO(&src->addr.v.a.addr, AF_INET6) &&
		    PF_AZERO(&src->addr.v.a.mask, AF_INET6))
			printf("any ");
		else {
			if (src->not)
				printf("! ");
			print_addr(&src->addr, af, verbose);
			printf(" ");
		}
d374 4
a377 11
		if (dst->addr.type == PF_ADDR_NOROUTE)
			printf("no-route ");
		else if (PF_AZERO(&dst->addr.v.a.addr, AF_INET6) &&
		    PF_AZERO(&dst->addr.v.a.mask, AF_INET6))
			printf("any ");
		else {
			if (dst->not)
				printf("! ");
			print_addr(&dst->addr, af, verbose);
			printf(" ");
		}
a385 25
print_rule(struct pf_rule *r, int verbose)
{
	switch (r->action) {
	case PF_NAT:
	case PF_NONAT:
		print_nat(r, verbose);
		break;
	case PF_BINAT:
	case PF_NOBINAT:
		print_binat(r, verbose);
		break;
	case PF_RDR:
	case PF_NORDR:
		print_rdr(r, verbose);
		break;
	default:
	case PF_PASS:
	case PF_DROP:
	case PF_SCRUB:
		print_filter(r, verbose);
		break;
	}
}

void
a459 120
void
print_nat(struct pf_rule *n, int verbose)
{
	if (verbose)
		printf("@@%d ", n->nr);
	if (n->anchorname[0])
		printf("nat-anchor %s ", n->anchorname);
	else {
		if (n->action == PF_NONAT)
			printf("no ");
		printf("nat ");
	}
	if (n->ifname[0]) {
		printf("on ");
		if (n->ifnot)
			printf("! ");
		printf("%s ", n->ifname);
	}
	if (n->af) {
		if (n->af == AF_INET)
			printf("inet ");
		else
			printf("inet6 ");
	}
	if (n->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(n->proto)) != NULL)
			printf("proto %s ", p->p_name);
		else
			printf("proto %u ", n->proto);
	}
	print_fromto(&n->src, &n->dst, n->af, n->proto, verbose);
	if (!n->anchorname[0] && (n->action == PF_NAT)) {
		printf("-> ");
		print_pool(&n->rpool, n->rpool.proxy_port[0],
		    n->rpool.proxy_port[1], n->af, PF_NAT);
	}
	printf("\n");
}

void
print_binat(struct pf_rule *b, int verbose)
{
	if (verbose)
		printf("@@%d ", b->nr);
	if (b->anchorname[0])
		printf("binat-anchor %s ", b->anchorname);
	else {
		if (b->action == PF_NOBINAT)
			printf("no ");
		printf("binat ");
	}
	if (b->ifname[0]) {
		printf("on ");
		printf("%s ", b->ifname);
	}
	if (b->af) {
		if (b->af == AF_INET)
			printf("inet ");
		else
			printf("inet6 ");
	}
	if (b->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(b->proto)) != NULL)
			printf("proto %s ", p->p_name);
		else
			printf("proto %u ", b->proto);
	}
	print_fromto(&b->src, &b->dst, b->af, b->proto, verbose);
	if (!b->anchorname[0] && (b->action == PF_BINAT)) {
		printf("-> ");
		print_pool(&b->rpool, 0, 0, b->af, PF_BINAT);
	}
	printf("\n");
}

void
print_rdr(struct pf_rule *r, int verbose)
{
	if (verbose)
		printf("@@%d ", r->nr);
	if (r->anchorname[0])
		printf("rdr-anchor %s ", r->anchorname);
	else {
		if (r->action == PF_NORDR)
			printf("no ");
		printf("rdr ");
	}
	if (r->ifname[0]) {
		printf("on ");
		if (r->ifnot)
			printf("! ");
		printf("%s ", r->ifname);
	}
	if (r->af) {
		if (r->af == AF_INET)
			printf("inet ");
		else
			printf("inet6 ");
	}
	if (r->proto) {
		struct protoent	*p;

		if ((p = getprotobynumber(r->proto)) != NULL)
			printf("proto %s ", p->p_name);
		else
			printf("proto %u ", r->proto);
	}
	print_fromto(&r->src, &r->dst, r->af, r->proto, verbose);
	if (!r->anchorname[0] && (r->action == PF_RDR)) {
		printf("-> ");
		print_pool(&r->rpool, r->rpool.proxy_port[0],
		    r->rpool.proxy_port[1], r->af, PF_RDR);
	}
	printf("\n");
}

d544 1
a544 1
print_filter(struct pf_rule *r, int verbose)
d546 5
d555 7
a561 6
	if (r->anchorname[0])
		printf("anchor %s ", r->anchorname);
	else if (r->action == PF_PASS)
		printf("pass ");
	else if (r->action == PF_DROP) {
		printf("block ");
d606 1
a606 2
	} else
		printf("scrub ");
d652 6
d659 2
a660 1
		print_uid(r->uid.op, r->uid.uid[0], r->uid.uid[1], "user");
d662 2
a663 1
		print_gid(r->gid.op, r->gid.gid[0], r->gid.gid[1], "group");
@


1.147
log
@lotsa const char *
from David Hill <david at phobia.ms> a while ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.146 2003/03/19 15:56:08 henning Exp $ */
d70 1
a70 1
char *tcpflags = "FSRPAUEW";
@


1.146
log
@inet_net_pton acts weird when it comes to multicast addresses. so pass the
netmask given by the OP to host_v4(), and in case it wasn't specified, do
not trust inet_net_pton telling is it is a /4 but use /32. otherwise, "pass
in from 224.0.0.6" suddenly became "pass in from 224.0.0.0/4", which is
clearly not the desired result.
inet_net_pton behaviour under investigation, using the least intrusive fix
for now.

found after bug report From: Julien Bordet <zejames@@greyhats.org> via dhartmei

ok daniel cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.145 2003/02/25 12:22:25 cedric Exp $ */
d58 1
a58 1
void		 print_port (u_int8_t, u_int16_t, u_int16_t, char *);
d309 1
a309 1
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, char *proto)
d632 2
a633 2
char	*pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
char	*pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
@


1.146.2.1
log
@MFC:
Fix by henning@@

in set_ipmask, do not try to mask off irrelevant bits of anything but
PF_ADDRMASK. due to the union this resulted in "masking" interface names in
the dynaddr case...
<henning@@quigon:1>$ echo "pass inet from (le0)/8" | pfctl -nvf -
pass inet from (l)/8 to any
reported by AARON SUEN <ags137 at psu.edu> on misc@@

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.164 2003/06/12 09:40:33 henning Exp $ */
d947 2
a948 3
	if (h->addr.type == PF_ADDR_ADDRMASK)
		for (i = 0; i < 4; i++)
			n->addr32[i] = n->addr32[i] & m->addr32[i];
@


1.145
log
@repair/simplify/flexify binat userland.
ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.144 2003/02/19 19:08:19 cedric Exp $ */
d66 1
a66 1
struct node_host	*host_v4(const char *);
d1152 1
a1152 1
	if (cont && (h = host_v4(buf)) != NULL)
d1209 1
a1209 1
host_v4(const char *s)
d1223 4
@


1.144
log
@Fix little buffer overflow on 64-bit platforms.
Produce wrong output on pfr7 regression test, discovered by henning@@.
ok+testing henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.143 2003/02/13 10:28:58 henning Exp $ */
d583 1
a583 16
	printf("from ");
	if (!PF_AZERO(&b->src.addr.v.a.addr, b->af) ||
	    !PF_AZERO(&b->src.addr.v.a.mask, b->af)) {
		print_addr(&b->src.addr, b->af, verbose);
		printf(" ");
	} else
		printf("any ");
	printf("to ");
	if (!PF_AZERO(&b->dst.addr.v.a.addr, b->af) ||
	    !PF_AZERO(&b->dst.addr.v.a.mask, b->af)) {
		if (b->dst.not)
			printf("! ");
		print_addr(&b->dst.addr, b->af, verbose);
		printf(" ");
	} else
		printf("any ");
@


1.143
log
@when complaining about an illegal netmask print the value we're complaining
about
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.142 2003/02/12 12:48:40 mcbride Exp $ */
d1231 1
a1231 1
	if ((bits = inet_net_pton(AF_INET, s, &ina, sizeof(&ina))) > -1) {
@


1.142
log
@Simplify the code and make the parser handle the different rule types
more consistently.

- Merge expand_nat and expand_rdr into expand_rule
- Merge rdrrule token into natrule

ok concept henning@@
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.141 2003/02/09 12:49:48 camield Exp $ */
d1157 1
a1157 1
			fprintf(stderr, "illegal mask\n");
@


1.141
log
@Fix a few warnings and remove unnecessary check and cast.

ok dhartmei henning
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.140 2003/02/08 20:13:20 dhartmei Exp $ */
d304 2
d482 3
a484 3
			printf(" port %u", ntohs(p1));
			if (p2)
				printf(":%u", ntohs(p2));
d638 1
a638 24
	printf("from ");
	if (!PF_AZERO(&r->src.addr.v.a.addr, r->af) ||
	    !PF_AZERO(&r->src.addr.v.a.mask, r->af)) {
		if (r->src.not)
			printf("! ");
		print_addr(&r->src.addr, r->af, verbose);
		printf(" ");
	} else
		printf("any ");
	printf("to ");
	if (!PF_AZERO(&r->dst.addr.v.a.addr, r->af) ||
	    !PF_AZERO(&r->dst.addr.v.a.mask, r->af)) {
		if (r->dst.not)
			printf("! ");
		print_addr(&r->dst.addr, r->af, verbose);
		printf(" ");
	} else
		printf("any ");
	if (r->dst.port[0]) {
		printf("port %u", ntohs(r->dst.port[0]));
		if (r->dst.port_op & PF_OP_RRG)
			printf(":%u", ntohs(r->dst.port[1]));
		printf(" ");
	}
@


1.140
log
@Add scrub option 'random-id', which replaces IP IDs with random values
for outgoing packets that are not fragmented (after reassembly), to
compensate for predictable IDs generated by some hosts, and defeat
fingerprinting and NAT detection as described in the Bellovin paper
http://www.research.att.com/~smb/papers/fnat.pdf. ok theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.139 2003/02/02 19:25:06 henning Exp $ */
d1151 1
a1151 1
			    "and extra netmask supplied\n");
@


1.139
log
@no const for int; cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.138 2003/02/02 18:32:35 henning Exp $ */
d920 2
@


1.138
log
@const'ify params for the host stuff

ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.137 2003/02/02 18:11:43 henning Exp $ */
d65 1
a65 1
struct node_host	*host_if(const char *, const int);
d67 2
a68 2
struct node_host	*host_v6(const char *, const int);
struct node_host	*host_dns(const char *, const int, const int);
d1207 1
a1207 1
host_if(const char *s, const int mask)
d1266 1
a1266 1
host_v6(const char *s, const int mask)
d1296 1
a1296 1
host_dns(const char *s, const int v4mask, const int v6mask)
@


1.137
log
@as correctly pointed out by cedric@@, the :network and :broadcast parsing
code really belongs to host_if() and not host(); I dunno why I did put it in
host()...

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.136 2003/01/30 15:41:35 henning Exp $ */
d65 4
a68 4
struct node_host	*host_if(char *, int);
struct node_host	*host_v4(char *);
struct node_host	*host_v6(char *, int);
struct node_host	*host_dns(char *, int, int);
d1064 1
a1064 1
ifa_exists(char *ifa_name)
d1079 1
a1079 1
ifa_lookup(char *ifa_name, enum pfctl_iflookup_mode mode)
d1140 1
a1140 1
host(char *s, int mask)
d1207 1
a1207 1
host_if(char *s, int mask)
d1243 1
a1243 1
host_v4(char *s)
d1266 1
a1266 1
host_v6(char *s, int mask)
d1296 1
a1296 1
host_dns(char *s, int v4mask, int v6mask)
@


1.136
log
@in these two cases strdup makes more sense than asprintf, pointed out by
camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.135 2003/01/30 15:03:49 henning Exp $ */
d65 1
a65 1
struct node_host	*host_if(char *, int, int);
a1144 1
	int			 mode = PFCTL_IFLOOKUP_HOST;
a1162 18
	} else if ((p = strrchr(s, ':')) != NULL &&
	    (!strcmp(p+1, "network") || !strcmp(p+1, "broadcast"))) {
		if (!strcmp(p+1, "network"))
			mode = PFCTL_IFLOOKUP_NET;
		if (!strcmp(p+1, "broadcast"))
			mode = PFCTL_IFLOOKUP_BCAST;
		if (mask > -1) {
			fprintf(stderr, "network or broadcast lookup, but "
			    "extra netmask given\n");
			return (NULL);
		}
		if ((buf = strdup(s)) == NULL)
			err(1, "host: strdup");
		if ((ps = malloc(strlen(s) - strlen(p) + 1)) == NULL)
			err(1, "host: malloc");
		strlcpy(ps, s, strlen(s) - strlen(p) + 1);
		v4mask = 32;
		v6mask = 128;
d1182 1
a1182 1
	if (cont && (h = host_if(ps, mask, mode)) != NULL)
d1207 1
a1207 1
host_if(char *s, int mask, int mode)
d1210 2
d1213 19
a1231 1
	if (ifa_exists(s) || !strncmp(s, "self", IFNAMSIZ)) {
d1233 1
a1233 1
		h = ifa_lookup(s, mode);
d1237 2
@


1.135
log
@add support for :network and :broadcast modifiers to interface names.
sample:
pass in on dc0 from dc0:network to any keep state
block in on dc0 from any to dc0:broadcast

ok theo daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.134 2003/01/25 22:53:45 mcbride Exp $ */
d1158 2
a1159 2
		if (asprintf(&buf, "%s", s) == -1)
			err(1, "host: asprintf");
d1175 2
a1176 2
		if (asprintf(&buf, "%s", s) == -1)
			err(1, "host: asprintf");
@


1.134
log
@Match changes for rdr port ranges made to pf.c:
- fixes behaviour of rdr on le0 from foo to bar port 1:20 -> (lo0) port 22
- makes calculated mapping more explicit for the -> (lo0) port 22:* case

testing from dhartmei@@

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.133 2003/01/20 17:16:56 cedric Exp $ */
d65 1
a65 1
struct node_host	*host_if(char *, int);
d1145 1
d1160 1
a1160 1
		if ((ps = malloc(strlen(s) + 1)) == NULL)
d1164 18
d1201 1
a1201 1
	if (cont && (h = host_if(ps, mask)) != NULL)
d1226 1
a1226 1
host_if(char *s, int mask)
d1232 1
a1232 1
		h = ifa_lookup(s, PFCTL_IFLOOKUP_HOST);
@


1.133
log
@Improve pfctl -vvs{r,n} output with rule containing tables.
Shows the number of entries in the table or if the table is not active.
ok dhartmei@@, no objections.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.132 2003/01/19 09:31:34 camield Exp $ */
d481 2
a482 2
			if (p2 & PF_OP_RRG)
				printf(":*");
d656 1
a656 1
		if (r->rpool.port_op & PF_OP_RRG)
d663 1
a663 1
		    r->rpool.port_op, r->af, PF_RDR);
@


1.132
log
@Quote label in rule output.

ok henning dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.131 2003/01/18 17:39:37 henning Exp $ */
d63 1
a63 1
		    u_int8_t, u_int8_t);
d364 1
a364 1
    sa_family_t af, u_int8_t proto)
d383 1
a383 1
			print_addr(&src->addr, af);
d400 1
a400 1
			print_addr(&dst->addr, af);
d449 1
a449 1
			print_addr(&pooladdr->addr.addr, af);
d456 1
a456 1
				print_addr(&pooladdr->addr.addr, af);
d542 1
a542 1
	print_fromto(&n->src, &n->dst, n->af, n->proto);
d584 1
a584 1
		print_addr(&b->src.addr, b->af);
d593 1
a593 1
		print_addr(&b->dst.addr, b->af);
d641 1
a641 1
		print_addr(&r->src.addr, r->af);
d650 1
a650 1
		print_addr(&r->dst.addr, r->af);
d854 1
a854 1
	print_fromto(&r->src, &r->dst, r->af, r->proto);
@


1.131
log
@quite some KNF for the older parts
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.130 2003/01/18 17:20:41 henning Exp $ */
d935 1
a935 1
		printf("label %s ", r->label);
@


1.130
log
@host() overhaul:
-split off host_if, host_v4, host_v6, host_dns
-kill the return-everywhere nightmare
-bit better error messages
makes the code more read-, understand- and maintainable; no fucntional
changes.

ok cedric@@ dhartmei@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.129 2003/01/17 14:01:43 markus Exp $ */
d200 1
a200 1
	unsigned int i;
d203 2
a204 1
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0])); i++) {
d221 1
a221 1
	unsigned int i;
d224 2
a225 1
		for (i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0])); i++) {
d242 1
a242 1
	unsigned int i;
d245 2
a246 1
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0])); i++) {
d265 1
a265 1
	unsigned int i;
d268 2
a269 1
		for (i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0])); i++) {
d309 2
a310 2
	char a1[6], a2[6];
	struct servent *s = getservbyport(p1, proto);
d312 1
d327 1
a327 1
	char a1[11], a2[11];
d341 1
a341 1
	char a1[11], a2[11];
d355 1
a355 1
	int i;
d439 1
a439 1
	struct pf_pooladdr *pooladdr;
d535 1
a535 1
		struct protoent *p = getprotobynumber(n->proto);
d537 1
a537 1
		if (p != NULL)
d574 1
a574 1
		struct protoent *p = getprotobynumber(b->proto);
d576 1
a576 1
		if (p != NULL)
d629 1
a629 1
		struct protoent *p = getprotobynumber(r->proto);
d631 1
a631 1
		if (p != NULL)
d668 2
a669 2
char *pf_reasons[PFRES_MAX+1] = PFRES_NAMES;
char *pf_fcounters[FCNT_MAX+1] = FCNT_NAMES;
d674 3
a676 3
	time_t runtime;
	int i;
	char statline[80];
d681 1
a681 1
		unsigned sec, min, hrs, day = runtime;
d754 1
a754 1
	int i, opts;
d772 1
a772 1
			const struct icmpcodeent *ic, *ic6;
d847 1
a847 1
		struct protoent *p = getprotobynumber(r->proto);
d849 1
a849 1
		if (p != NULL)
d867 1
a867 1
		const struct icmptypeent *it;
d879 1
a879 1
			const struct icmpcodeent *ic;
d947 2
a948 2
	char *p, *q;
	u_int8_t f = 0;
@


1.129
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.128 2003/01/14 21:58:12 henning Exp $ */
d65 5
d1137 2
a1138 4
	struct node_host	*h = NULL, *n;
	struct in_addr		 ina;
	struct addrinfo		 hints, *res0, *res;
	int			 bits, error, v4mask, v6mask;
a1140 8
	if (ifa_exists(s) || !strncmp(s, "self", IFNAMSIZ)) {
		/* interface with this name exists */
		h = ifa_lookup(s, PFCTL_IFLOOKUP_HOST);
		for (n = h; n != NULL && mask > -1; n = n->next)
			set_ipmask(n, mask);
		return (h);
	}

d1176 46
d1223 1
a1223 1
	if ((bits = inet_net_pton(AF_INET, buf, &ina, sizeof(&ina))) > -1) {
a1232 8
		free(buf);
		free(ps);
		if (mask > -1 && mask != bits) {
			fprintf(stderr, "illegal netmask %d\n", mask);
			free (h);
			return (NULL);
		}
		return (h);
d1234 9
a1242 1
	free(buf);
d1248 3
a1250 3
	if (getaddrinfo(ps, "0", &hints, &res) == 0) {
		n = calloc(1, sizeof(struct node_host));
		if (n == NULL)
d1252 3
a1254 3
		n->ifname = NULL;
		n->af = AF_INET6;
		memcpy(&n->addr.v.a.addr,
d1256 4
a1259 3
		    sizeof(n->addr.v.a.addr));
		n->ifindex = ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
		set_ipmask(n, v6mask);
d1261 2
a1262 4
		n->next = NULL;
		n->tail = n;
		free(ps);
		return (n);
d1265 10
d1278 4
a1281 7
	error = getaddrinfo(ps, NULL, &hints, &res0);
	if (error) {
		fprintf(stderr, "cannot resolve %s: %s\n",
		    s, gai_strerror(error));
		free(ps);
		return (NULL);
	}
d1288 1
a1288 1
			err(1, "address: calloc");
d1293 2
a1294 1
			    &((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr,
d1299 2
a1300 1
			    &((struct sockaddr_in6 *)res->ai_addr)->sin6_addr.s6_addr,
d1303 2
a1304 1
			    ((struct sockaddr_in6 *)res->ai_addr)->sin6_scope_id;
a1316 1
	free(ps);
a1317 4
	if (h == NULL) {
		fprintf(stderr, "no IP address found for %s\n", s);
		return (NULL);
	}
a1319 1

@


1.128
log
@unified IP parser:
-move host(), set_ipmask and the ifa_* functions to pfctl_parser.[c|h]
-extend host() to handle /mask itself, plus minor adjustments
-use that in pfctl_table.c instead of coding the same shit again

discussed w/ cedric@@
ok cedric@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.127 2003/01/05 22:14:23 dhartmei Exp $ */
d463 1
a463 1
			printf(" port %u", p1);
@


1.127
log
@Move ifname from pf_addr to pf_addr_wrap, prepare pf_addr_wrap for table
name. ok henning@@, mcbride@@, cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.126 2003/01/04 17:40:51 dhartmei Exp $ */
d52 1
d948 328
@


1.126
log
@move noroute from flag in pf_rule_addr into type in pf_addr_wrap.
ok henning@@, mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.125 2003/01/04 00:01:34 deraadt Exp $ */
d357 4
a360 4
	    PF_AZERO(&src->addr.addr, AF_INET6) &&
	    PF_AZERO(&src->addr.mask, AF_INET6) &&
	    !src->port_op && PF_AZERO(&dst->addr.addr, AF_INET6) &&
	    PF_AZERO(&dst->addr.mask, AF_INET6) && !dst->port_op)
d366 2
a367 2
		else if (PF_AZERO(&src->addr.addr, AF_INET6) &&
		    PF_AZERO(&src->addr.mask, AF_INET6))
d383 2
a384 2
		else if (PF_AZERO(&dst->addr.addr, AF_INET6) &&
		    PF_AZERO(&dst->addr.mask, AF_INET6))
d441 1
a441 1
			if (PF_AZERO(&pooladdr->addr.addr.addr, af))
d571 2
a572 2
	if (!PF_AZERO(&b->src.addr.addr, b->af) ||
	    !PF_AZERO(&b->src.addr.mask, b->af)) {
d578 2
a579 2
	if (!PF_AZERO(&b->dst.addr.addr, b->af) ||
	    !PF_AZERO(&b->dst.addr.mask, b->af)) {
d626 2
a627 2
	if (!PF_AZERO(&r->src.addr.addr, r->af) ||
	    !PF_AZERO(&r->src.addr.mask, r->af)) {
d635 2
a636 2
	if (!PF_AZERO(&r->dst.addr.addr, r->af) ||
	    !PF_AZERO(&r->dst.addr.mask, r->af)) {
@


1.125
log
@I do not know where this policy of "one .h file for every .c file" comes
from, but whoever thought of it is stupid.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.124 2002/12/30 23:46:54 mcbride Exp $ */
d355 3
a357 1
	if (PF_AZERO(&src->addr.addr, AF_INET6) &&
a358 1
	    !src->noroute && !dst->noroute &&
d364 1
a364 1
		if (src->noroute)
d381 1
a381 1
		if (dst->noroute)
@


1.124
log
@Change ipv6-icmp-type to icpm6-type. pf.conf files will need to be adjusted
to reflect this.

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.123 2002/12/18 19:40:41 dhartmei Exp $ */
d54 1
a54 1
#include "pf_print_state.h"
@


1.123
log
@Store translation rule pointer in state entries, so pfctl -vsn can print
evaluation, packet, byte and state entry counters similar to -vsr. Helps
verify whether/how often translation rules are evaluated/matched.
ok frantzen@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.122 2002/12/17 12:36:59 mcbride Exp $ */
d861 1
a861 1
			printf("ipv6-icmp-type");
@


1.122
log
@Match merge of pf_nat/pf_binat/pf_rdr structs into pf_rule

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.121 2002/12/13 21:51:25 henning Exp $ */
d404 1
a404 1
		print_nat(r);
d408 1
a408 1
		print_binat(r);
d412 1
a412 1
		print_rdr(r);
d499 1
a499 1
print_nat(struct pf_rule *n)
d501 2
d540 1
a540 1
print_binat(struct pf_rule *b)
d542 2
d593 1
a593 1
print_rdr(struct pf_rule *r)
d595 2
@


1.121
log
@allow a second queue for higher priorized (currently: tos=lowdelay) packets
to be specified per rule

queue (qname, priorized_qname)

idea dhartmei
ok dhartmei@@ frantzen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.120 2002/12/07 23:15:53 dhartmei Exp $ */
d399 25
d434 4
a437 3
		case PF_POOL_NAT_R:
		case PF_POOL_RDR_R:
			print_addr(&pooladdr->addr, af);
d439 2
a440 2
		case PF_POOL_RULE_RT:
			if (PF_AZERO(&pooladdr->addr.addr, af))
d444 1
a444 1
				print_addr(&pooladdr->addr, af);
d448 2
d457 1
a457 1
	case PF_POOL_NAT_R:
d466 1
a466 1
	case PF_POOL_RDR_R:
d469 1
a469 1
			if (p2 & PF_RPORT_RANGE)
a472 1
	case PF_POOL_RULE_RT:
d499 1
a499 1
print_nat(struct pf_nat *n)
d504 1
a504 1
		if (n->no)
d529 1
a529 1
	if (!n->anchorname[0] && !n->no) {
d531 2
a532 2
		print_pool(&n->rpool, n->proxy_port[0], n->proxy_port[1],
		    n->af, PF_POOL_NAT_R);
d538 1
a538 1
print_binat(struct pf_binat *b)
d543 1
a543 1
		if (b->no)
d566 3
a568 3
	if (!PF_AZERO(&b->saddr.addr, b->af) ||
	    !PF_AZERO(&b->saddr.mask, b->af)) {
		print_addr(&b->saddr, b->af);
d573 3
a575 3
	if (!PF_AZERO(&b->daddr.addr, b->af) ||
	    !PF_AZERO(&b->daddr.mask, b->af)) {
		if (b->dnot)
d577 1
a577 1
		print_addr(&b->daddr, b->af);
d581 1
a581 1
	if (!b->anchorname[0] && !b->no) {
d583 1
a583 1
		print_addr(&b->raddr, b->af);
d589 1
a589 1
print_rdr(struct pf_rdr *r)
d594 1
a594 1
		if (r->no)
d619 3
a621 3
	if (!PF_AZERO(&r->saddr.addr, r->af) ||
	    !PF_AZERO(&r->saddr.mask, r->af)) {
		if (r->snot)
d623 1
a623 1
		print_addr(&r->saddr, r->af);
d628 3
a630 3
	if (!PF_AZERO(&r->daddr.addr, r->af) ||
	    !PF_AZERO(&r->daddr.mask, r->af)) {
		if (r->dnot)
d632 1
a632 1
		print_addr(&r->daddr, r->af);
d636 4
a639 4
	if (r->dport) {
		printf("port %u", ntohs(r->dport));
		if (r->opts & PF_DPORT_RANGE)
			printf(":%u", ntohs(r->dport2));
d642 1
a642 1
	if (!r->anchorname[0] && !r->no) {
d644 2
a645 1
		print_pool(&r->rpool, r->rport, r->opts, r->af, PF_POOL_RDR_R);
d734 1
a734 1
print_rule(struct pf_rule *r, int verbose)
d818 1
a818 1
			print_pool(&r->rt_pool, 0, 0, r->af, PF_POOL_RULE_RT);
@


1.120
log
@Support parameters in anchor rules. Allows conditional evaluation, like:

  anchor spews inet proto tcp from any to any port smtp

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.119 2002/12/07 20:25:40 henning Exp $ */
d890 4
a893 2
	if (r->qname[0])
		printf("queue %s", r->qname);
@


1.119
log
@shadow cleanup

ok mcbride@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.118 2002/12/06 11:03:36 henning Exp $ */
d474 7
a480 7
	if (n->anchorname[0]) {
		printf("nat-anchor %s\n", n->anchorname);
		return;
	}
	if (n->no)
		printf("no ");
	printf("nat ");
d502 1
a502 1
	if (!n->no) {
d513 7
a519 7
	if (b->anchorname[0]) {
		printf("binat-anchor %s\n", b->anchorname);
		return;
	}
	if (b->no)
		printf("no ");
	printf("binat ");
d539 6
a544 2
	print_addr(&b->saddr, b->af);
	printf(" ");
d554 1
a554 1
	if (!b->no) {
d564 7
a570 7
	if (r->anchorname[0]) {
		printf("rdr-anchor %s\n", r->anchorname);
		return;
	}
	if (r->no)
		printf("no ");
	printf("rdr ");
d615 1
a615 1
	if (!r->no) {
d712 3
a714 5
	if (r->anchorname[0]) {
		printf("anchor %s\n", r->anchorname);
		return;
	}
	if (r->action == PF_PASS)
d762 1
a762 1
	} else {
a763 1
	}
@


1.118
log
@let pfctl -v print out "block drop" instead of just "block" in the drop
case. fixes the last self-regress test.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.117 2002/12/06 00:47:32 dhartmei Exp $ */
d820 1
a820 1
		const struct icmptypeent *p;
d822 1
a822 1
		p = geticmptypebynumber(r->type-1, r->af);
d827 2
a828 2
		if (p != NULL)
			printf(" %s ", p->name);
d832 1
a832 1
			const struct icmpcodeent *p;
d834 3
a836 3
			p = geticmpcodebynumber(r->type-1, r->code-1, r->af);
			if (p != NULL)
				printf("code %s ", p->name);
@


1.117
log
@Introduce anchors and named rule sets, allowing to load additional rule
sets with pfctl and evaluate them from the main rule set using a new type
of rule (which will support conditional evaluation soon). Makes
maintenance of sub-rulesets simpler for pfctl and daemons.

Idea and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.116 2002/12/05 14:10:45 henning Exp $ */
d758 2
a759 1
		}
@


1.116
log
@one step further to "program output is valid program input" and the related
extra regress testing opportunities (an excellent idea by markus@@).
only print rule numbers in case of pfctl -v -v; but not with pfctl -v.

ok markus@@ frantzen@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.115 2002/11/30 10:07:51 mickey Exp $ */
d474 4
d513 4
d560 4
d660 1
a660 1
		    s->bcounters[0][PF_IN], s->bcounters[1][PF_IN]);
d662 1
a662 1
		    s->bcounters[0][PF_OUT], s->bcounters[1][PF_OUT]);
d665 2
a666 2
		    s->pcounters[0][PF_IN][PF_PASS],
		    s->pcounters[1][PF_IN][PF_PASS]);
d668 2
a669 2
		    s->pcounters[0][PF_IN][PF_DROP],
		    s->pcounters[1][PF_IN][PF_DROP]);
d672 2
a673 2
		    s->pcounters[0][PF_OUT][PF_PASS],
		    s->pcounters[1][PF_OUT][PF_PASS]);
d675 2
a676 2
		    s->pcounters[0][PF_OUT][PF_DROP],
		    s->pcounters[1][PF_OUT][PF_DROP]);
d708 4
d762 1
a762 1
	if (r->direction == 0)
d764 1
a764 1
	else
@


1.115
log
@move unmask back into pf_print_state.c where it was, and please keep it there; henning@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.114 2002/11/28 13:18:09 mcbride Exp $ */
d690 1
a690 1
print_rule(struct pf_rule *r)
d694 2
a695 1
	printf("@@%d ", r->nr);
@


1.114
log
@- Remove extra space before -> in print_rdr
- Print hex keys lowercase

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.113 2002/11/28 12:14:25 mcbride Exp $ */
a889 22
}

int
unmask(struct pf_addr *m, sa_family_t af)
{
	int i = 31, j = 0, b = 0, msize;
	u_int32_t tmp;

	if (af == AF_INET)
		msize = 1;
	else
		msize = 4;
	while (j < msize && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < msize) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
@


1.113
log
@- Adjust to match replacement of md5 with pf_hash
- Allow keys to be specified in hex (must be 128 bits, mainly to make
  pfctl -v output paresable by pfctl) or as a string. Randomly generate key
  if one is not specified.

Suggestions and fixes from camield@@

ok mickey@@ camield@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.112 2002/11/23 11:58:44 dhartmei Exp $ */
d459 1
a459 1
		printf(" source-hash 0x%08X%08X%08X%08X",
d597 1
d600 1
a600 1
		printf(" -> ");
@


1.112
log
@Cosmetic fixes for print_*() functions, so they match the old regress
output (mainly spaces).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.111 2002/11/23 10:03:39 mcbride Exp $ */
d399 2
a400 1
print_pool(struct pf_pool *pool, sa_family_t af, int id)
d428 41
d500 2
a501 30
		print_pool(&n->rpool, n->af, PF_POOL_NAT_R);
		if (n->proxy_port[0] != PF_NAT_PROXY_PORT_LOW ||
		    n->proxy_port[1] != PF_NAT_PROXY_PORT_HIGH) {
			if (n->proxy_port[0] == n->proxy_port[1])
				printf(" port %u", n->proxy_port[0]);
			else
				printf(" port %u:%u", n->proxy_port[0],
				    n->proxy_port[1]);
		}
		switch (n->rpool.opts & 0x0f) {
		case PF_POOL_NONE:
			break;
		case PF_POOL_BITMASK:
			printf(" bitmask");
			break;
		case PF_POOL_RANDOM:
			printf(" random");
			break;
		case PF_POOL_SRCHASH:
			printf(" source-hash");
			break;
		case PF_POOL_SRCKEYHASH:
			printf(" source-hash key");
			break;
		case PF_POOL_ROUNDROBIN:
			printf(" round-robin");
			break;
		}
		if (n->rpool.opts & PF_POOL_STATICPORT)
			printf(" static-port");
d600 1
a600 26
		print_pool(&r->rpool, r->af, PF_POOL_RDR_R);
		printf(" ");
		switch (r->rpool.opts & 0x0f) {
		case PF_POOL_NONE:
			break;
		case PF_POOL_BITMASK:
			printf("bitmask ");
			break;
		case PF_POOL_RANDOM:
			printf("random ");
			break;
		case PF_POOL_SRCHASH:
			printf("source-hash ");
			break;
		case PF_POOL_SRCKEYHASH:
			printf("source-hash key ");
			break;
		case PF_POOL_ROUNDROBIN:
			printf("round-robin ");
			break;
		}
		if (r->rport) {
			printf("port %u", ntohs(r->rport));
			if (r->opts & PF_RPORT_RANGE)
				printf(":*");
		}
d770 1
a770 1
			print_pool(&r->rt_pool, r->af, PF_POOL_RULE_RT);
a771 19
		}
		switch (r->rt_pool.opts & 0x0f) {
		case PF_POOL_NONE:
			break;
		case PF_POOL_BITMASK:
			printf("bitmask ");
			break;
		case PF_POOL_RANDOM:
			printf("random ");
			break;
		case PF_POOL_SRCHASH:
			printf("source-hash ");
			break;
		case PF_POOL_SRCKEYHASH:
			printf("source-hash key ");
			break;
		case PF_POOL_ROUNDROBIN:
			printf("round-robin ");
			break;
@


1.111
log
@fix parens "(" ")" when printing

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.110 2002/11/23 09:33:54 deraadt Exp $ */
d413 4
a416 4
			if (PF_AZERO(&pooladdr->addr.addr, af)) {
				printf("%s ", pooladdr->ifname);
			} else {
				printf("( %s ", pooladdr->ifname);
d418 1
a418 1
				printf(" )");
d587 1
a587 5
		if (r->rport) {
			printf(" port %u", ntohs(r->rport));
			if (r->opts & PF_RPORT_RANGE)
				printf(":*");
		}
d592 1
a592 1
			printf(" bitmask");
d595 1
a595 1
			printf(" random");
d598 1
a598 1
			printf(" source-hash");
d601 1
a601 1
			printf(" source-hash key");
d604 1
a604 1
			printf(" round-robin");
d607 5
d779 2
a780 1
			printf("fastroute");
d782 2
d788 1
a788 1
			printf(" bitmask");
d791 1
a791 1
			printf(" random");
d794 1
a794 1
			printf(" source-hash");
d797 1
a797 1
			printf(" source-hash key");
d800 1
a800 1
			printf(" round-robin");
a802 1
		printf(" ");
@


1.110
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.109 2002/11/23 08:59:54 dhartmei Exp $ */
d413 4
a416 3
			printf("( %s", pooladdr->ifname);
			if (! PF_AZERO(&pooladdr->addr.addr, af)) {
				printf(" ");
d418 1
a419 1
			printf(" )");
@


1.109
log
@Missing {}
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.108 2002/11/23 08:12:56 mcbride Exp $ */
d403 1
a403 1
	if ((TAILQ_FIRST(&pool->list) != NULL) && 
d412 1
a412 1
		case PF_POOL_RULE_RT:	
@


1.108
log
@check to make sure a list item exists before checking to see if the next
one is there.

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.107 2002/11/23 06:18:42 mcbride Exp $ */
d414 1
a414 1
			if (! PF_AZERO(&pooladdr->addr.addr, af))
d417 1
@


1.107
log
@missing prototype, remember to use sa_family_t for af
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.106 2002/11/23 05:22:24 mcbride Exp $ */
d403 2
a404 1
	if (TAILQ_NEXT(TAILQ_FIRST(&pool->list), entries) != NULL)
@


1.106
log
@code to support loading of pf rules with multiple redirection addresses
(in nat, rdr, route-to, dup-to and reply-to)

Syntax looks like this, see pf.conf(5) for details:

nat on wi0 proto { tcp, icmp } from any to 192.168.0.2 -> \
        192.168.0.16/29 source-hash random

rdr on wi0 proto { tcp } from any to 192.168.0.34 port 22 -> \
        { 192.168.0.8/31, 192.168.0.15 } port 22 round-robin

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.105 2002/11/19 23:34:02 dhartmei Exp $ */
d399 1
a399 1
print_pool(struct pf_pool *pool, int af, int id)
@


1.105
log
@minor cosmetics, space after "label %s", in case both label and queue are
specified.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.104 2002/11/18 22:55:39 deraadt Exp $ */
d356 1
a356 1
	    PF_AZERO(&src->mask, AF_INET6) &&
d359 1
a359 1
	    PF_AZERO(&dst->mask, AF_INET6) && !dst->port_op)
d366 1
a366 1
		    PF_AZERO(&src->mask, AF_INET6))
d371 1
a371 1
			print_addr(&src->addr, &src->mask, af);
d383 1
a383 1
		    PF_AZERO(&dst->mask, AF_INET6))
d388 1
a388 1
			print_addr(&dst->addr, &dst->mask, af);
d399 28
d455 1
a455 1
		print_addr(&n->raddr, NULL, n->af);
d464 21
d514 1
a514 1
	print_addr(&b->saddr, &b->smask, b->af);
d517 2
a518 1
	if (!PF_AZERO(&b->daddr.addr, b->af) || !PF_AZERO(&b->dmask, b->af)) {
d521 1
a521 1
		print_addr(&b->daddr, &b->dmask, b->af);
d527 1
a527 1
		print_addr(&b->raddr, &b->rmask, b->af);
d559 2
a560 1
	if (!PF_AZERO(&r->saddr.addr, r->af) || !PF_AZERO(&r->smask, r->af)) {
d563 1
a563 1
		print_addr(&r->saddr, &r->smask, r->af);
d568 2
a569 1
	if (!PF_AZERO(&r->daddr.addr, r->af) || !PF_AZERO(&r->dmask, r->af)) {
d572 1
a572 1
		print_addr(&r->daddr, &r->dmask, r->af);
d583 1
a583 2
		print_addr(&r->raddr, NULL, r->af);
		printf(" ");
d585 1
a585 1
			printf("port %u", ntohs(r->rport));
d589 19
d776 20
a795 10
		if (r->af && !PF_AZERO(&r->rt_addr, r->af)) {
			struct pf_addr_wrap aw;

			printf("(%s ", r->rt_ifname);
			aw.addr = r->rt_addr;
			aw.addr_dyn = NULL;
			print_addr(&aw, NULL, r->af);
			printf(")");
		} else if (r->rt_ifname[0])
			printf("%s", r->rt_ifname);
@


1.104
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.103 2002/11/18 22:49:15 henning Exp $ */
d813 1
a813 1
		printf("label %s", r->label);
@


1.103
log
@altq and pf merged

this isn't 100% done yet: the print_ stuff isn't finished, some features
will be added later, and there is no documetation yet, but committing now
enables a few more people to work on.

print_altq_node stuff hacked by Daniel at euroBSDcon; lotsa stuff from kjc,
debugging help also pb and camiel. lots of good ideas by theo.

"commit now" theo philipp daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.102 2002/10/25 10:40:45 camield Exp $ */
d655 1
a655 1
				else 
d669 1
a669 1
				else 
@


1.102
log
@- more sa_family_t
- move unmask code to correct file
- whitespace

ok mcbride@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.101 2002/10/22 12:28:08 mcbride Exp $ */
d814 2
@


1.101
log
@More conversion of "int af" and "u_int8_t af" declarations and function
arguments to the more correct and descriptive "sa_family_t af"

ok dhartmei@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.100 2002/10/14 12:58:28 henning Exp $ */
d831 22
@


1.100
log
@Allow one to specify a netblock in a binat rule:

binat on fxp0 from 192.168.0.32/27 to any -> 10.0.7.128/27

Both the network mask on the source and redirect addresses MUST be the
same, and it works by essentially combining the network section of the
redirect address with the host section of the source address.

from ryan

ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.99 2002/10/07 13:23:46 henning Exp $ */
d192 1
a192 1
geticmptypebynumber(u_int8_t type, u_int8_t af)
d212 1
a212 1
geticmptypebyname(char *w, u_int8_t af)
d232 1
a232 1
geticmpcodebynumber(u_int8_t type, u_int8_t code, u_int8_t af)
d254 1
a254 1
geticmpcodebyname(u_long type, char *w, u_int8_t af)
d353 1
a353 1
    u_int8_t af, u_int8_t proto)
@


1.99
log
@set block-policy [drop|return]
drop is default, same behaviour as before

support
block drop
to override a return policy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.96 2002/10/07 12:39:29 dhartmei Exp $ */
d465 1
a465 1
	print_addr(&b->saddr, NULL, b->af);
d477 1
a477 1
		print_addr(&b->raddr, NULL, b->af);
@


1.98
log
@support a generic return
block return in|out ...
acts like return-rst on tcp, like return-icmp on udp and like an ordinary
block on anything else

ok dhartmei@@
@
text
@d635 3
a637 1
		if (r->rule_flag & PFRULE_RETURNRST) {
@


1.97
log
@make return-icmp work for rules covering both v4 and v6
-new field "return_icmp6" inpf_rule
-parser accepts
block return-icmp(ipv4-icmpcode, ipv6-icmpcode)

ok and some input dhartmei@@
@
text
@@


1.96
log
@Add 'reply-to' to filter rules, similar to route-to, but applying to
replies (packets that flow in the opposite direction of the packet that
created state), used for symmetric routing enforcement.
Document how route-to and reply-to work in context of stateful filtering.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.95 2002/10/05 21:17:57 dhartmei Exp $ */
d640 2
a641 2
		} else if (r->return_icmp) {
			const struct icmpcodeent *ic;
d643 7
a649 1
			if (r->af != AF_INET6)
d651 6
a656 1
			else
d658 17
a674 12
			ic = geticmpcodebynumber(r->return_icmp >> 8,
			    r->return_icmp & 255, r->af);

			if (ic == NULL)
				printf("(%u) ", r->return_icmp & 255);
			else if ((r->af != AF_INET6 && ic->code !=
			    ICMP_UNREACH_PORT) ||
			    (r->af == AF_INET6 && ic->code !=
			    ICMP6_DST_UNREACH_NOPORT))
				printf("(%s) ", ic->name);
			else
				printf(" ");
@


1.95
log
@Allow filtering based on IP header's tos field.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.94 2002/07/20 18:58:44 deraadt Exp $ */
d682 2
@


1.94
log
@properly split yacc and lex use
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.93 2002/07/15 18:13:53 henning Exp $ */
d746 2
@


1.93
log
@add support for
  pass|block on ! $interface ...

ok dhartmei@@

will be documented in pf.conf(5) by "I'm not slacking!" pb@@ who's currently
reworking this manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.92 2002/07/01 05:28:22 deraadt Exp $ */
a685 2
		if (r->rt_ifname[0])
			printf("%s", r->rt_ifname);
d689 1
a691 1
			printf(":");
d693 3
a695 1
		}
@


1.92
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.91 2002/06/27 10:17:48 henning Exp $ */
d673 6
a678 2
	if (r->ifname[0])
		printf("on %s ", r->ifname);
@


1.91
log
@repair formatting - the new "enabled since" format is longer than the old
one and thus the field lengths need to be adjusted.
ok dhartmei@@, pb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.90 2002/06/19 17:44:02 dhartmei Exp $ */
d587 1
a587 1
		printf("  Packets In\n"); 
d589 1
a589 1
		    s->pcounters[0][PF_IN][PF_PASS], 
d611 1
a611 1
			printf("%14s\n", "");	
d621 1
a621 1
			printf("%14s\n", "");	
@


1.90
log
@"Enabled for Ss" -> "Enabled for D days HH:MM:SS", ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.89 2002/06/11 18:03:25 frantzen Exp $ */
d568 1
a568 1
	printf("%-34s", statline);
d571 1
a571 1
		printf("%25s\n\n", "Debug: None");
d574 1
a574 1
		printf("%25s\n\n", "Debug: Urgent");
d577 1
a577 1
		printf("%25s\n\n", "Debug: Misc");
@


1.89
log
@split the grammar of scrub(fragcache) into scrub ... 'fragment reassemble',
'fragment crop' or a new 'fragment drop-ovl' which will drop overlapping
fragments and all corresponding ones
ok kjell@@ with feedback from kjell@@ and deraadt@@.  the rest are slacking
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.88 2002/06/11 02:27:19 frantzen Exp $ */
d554 13
a566 4
	if ( s->running ) 
		snprintf(statline, sizeof(statline), 
		    "Status: Enabled for %us ", runtime);
	else
d607 1
a607 1
		if ( runtime > 0 )
d617 1
a617 1
		if ( runtime > 0 )
@


1.88
log
@SCRUB(fragcache) to do gap tracking and overlap pruning of IPv4 fragments
without the memory overhead of the conventional defrag in SCRUB
ok dhartmei@@, idea by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.87 2002/06/11 02:12:37 dhartmei Exp $ */
d652 1
a652 4
		if ((r->rule_flag & PFRULE_FRAGCACHE) == 0)
			printf("scrub ");
		else
			printf("scrub(fragcache) ");
d769 8
@


1.87
log
@Make NAT proxy port range configurable per rule, for instance privileged
source ports can mapped to privileged proxy ports, or source port 500
to proxy port 500. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.86 2002/06/11 01:58:00 henning Exp $ */
d651 6
a656 2
	} else
		printf("scrub ");
@


1.86
log
@rework pfctl statistics display
move FCNT_NAMES from pfvar.h to pfctl_parser.h, only used by pfctl
some input by nick@@
ok frantzen@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.85 2002/06/10 19:31:44 dhartmei Exp $ */
d428 8
@


1.85
log
@Allow ports to be specified in nat rules, useful later on for individual
proxy port ranges.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.84 2002/06/09 20:20:58 dhartmei Exp $ */
d540 1
a540 1
	time_t t = time(NULL);
d542 1
d544 8
a551 3
	printf("Status: %s  Time: %u  Since: %u  Debug: ",
	    s->running ? "Enabled" : "Disabled",
	    t, s->since);
d554 1
a554 1
		printf("None");
d557 1
a557 1
		printf("Urgent");
d560 1
a560 1
		printf("Misc");
d563 33
a595 21
	printf("\nBytes In IPv4: %-10llu  Bytes Out: %-10llu\n",
	    s->bcounters[0][PF_IN], s->bcounters[0][PF_OUT]);
	printf("         IPv6: %-10llu  Bytes Out: %-10llu\n",
	    s->bcounters[1][PF_IN], s->bcounters[1][PF_OUT]);
	printf("Inbound Packets IPv4:  Passed: %-10llu  Dropped: %-10llu\n",
	    s->pcounters[0][PF_IN][PF_PASS],
	    s->pcounters[0][PF_IN][PF_DROP]);
	printf("                IPv6:  Passed: %-10llu  Dropped: %-10llu\n",
	    s->pcounters[1][PF_IN][PF_PASS],
	    s->pcounters[1][PF_IN][PF_DROP]);
	printf("Outbound Packets IPv4: Passed: %-10llu  Dropped: %-10llu\n",
	    s->pcounters[0][PF_OUT][PF_PASS],
	    s->pcounters[0][PF_OUT][PF_DROP]);
	printf("                 IPv6: Passed: %-10llu  Dropped: %-10llu\n",
	    s->pcounters[1][PF_OUT][PF_PASS],
	    s->pcounters[1][PF_OUT][PF_DROP]);
	printf("States: %u\n", s->states);
	printf("pf Counters\n");
	for (i = 0; i < FCNT_MAX; i++)
		printf("%-25s %-8lld\n", pf_fcounters[i],
		    s->fcounters[i]);
d597 2
a598 2
	for (i = 0; i < PFRES_MAX; i++)
		printf("%-25s %-8lld\n", pf_reasons[i],
d600 6
@


1.84
log
@Make pf_nat.saddr/daddr a pf_rule_addr instead of pf_addr_wrap, so it
includes ports and operator.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.83 2002/06/09 05:31:25 deraadt Exp $ */
d61 2
d352 47
d424 1
a424 18
	printf("from ");
	if (!PF_AZERO(&n->src.addr.addr, n->af) ||
	    !PF_AZERO(&n->src.mask, n->af)) {
		if (n->src.not)
			printf("! ");
		print_addr(&n->src.addr, &n->src.mask, n->af);
		printf(" ");
	} else
		printf("any ");
	printf("to ");
	if (!PF_AZERO(&n->dst.addr.addr, n->af) ||
	    !PF_AZERO(&n->dst.mask, n->af)) {
		if (n->dst.not)
			printf("! ");
		print_addr(&n->dst.addr, &n->dst.mask, n->af);
		printf(" ");
	} else
		printf("any ");
d666 1
a666 41
	if (PF_AZERO(&r->src.addr.addr, AF_INET6) &&
	    PF_AZERO(&r->src.mask, AF_INET6) &&
	    !r->src.noroute && !r->dst.noroute &&
	    !r->src.port_op && PF_AZERO(&r->dst.addr.addr, AF_INET6) &&
	    PF_AZERO(&r->dst.mask, AF_INET6) && !r->dst.port_op)
		printf("all ");
	else {
		printf("from ");
		if (r->src.noroute)
			printf("no-route ");
		else if (PF_AZERO(&r->src.addr.addr, AF_INET6) &&
		    PF_AZERO(&r->src.mask, AF_INET6))
			printf("any ");
		else {
			if (r->src.not)
				printf("! ");
			print_addr(&r->src.addr, &r->src.mask, r->af);
			printf(" ");
		}
		if (r->src.port_op)
			print_port(r->src.port_op, r->src.port[0],
			    r->src.port[1],
			    r->proto == IPPROTO_TCP ? "tcp" : "udp");

		printf("to ");
		if (r->dst.noroute)
			printf("no-route ");
		else if (PF_AZERO(&r->dst.addr.addr, AF_INET6) &&
		    PF_AZERO(&r->dst.mask, AF_INET6))
			printf("any ");
		else {
			if (r->dst.not)
				printf("! ");
			print_addr(&r->dst.addr, &r->dst.mask, r->af);
			printf(" ");
		}
		if (r->dst.port_op)
			print_port(r->dst.port_op, r->dst.port[0],
			    r->dst.port[1],
			    r->proto == IPPROTO_TCP ? "tcp" : "udp");
	}
@


1.83
log
@spaced out developers...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.82 2002/06/08 21:09:59 dhartmei Exp $ */
d376 3
a378 2
	if (!PF_AZERO(&n->saddr.addr, n->af) || !PF_AZERO(&n->smask, n->af)) {
		if (n->snot)
d380 1
a380 1
		print_addr(&n->saddr, &n->smask, n->af);
d385 3
a387 2
	if (!PF_AZERO(&n->daddr.addr, n->af) || !PF_AZERO(&n->dmask, n->af)) {
		if (n->dnot)
d389 1
a389 1
		print_addr(&n->daddr, &n->dmask, n->af);
@


1.82
log
@Change remaining read-only lookup tables to const, suggestion drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.81 2002/06/08 16:44:15 drahn Exp $ */
d563 1
a563 1
			else 
@


1.81
log
@pf_timeouts is shared between pfctl and authpf, put it in the shared file.
unbreak build.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.80 2002/06/08 07:58:07 dhartmei Exp $ */
d64 1
a64 1
struct icmptypeent icmp_type[] = {
d92 1
a92 1
struct icmptypeent icmp6_type[] = {
d121 1
a121 1
struct icmpcodeent icmp_code[] = {
d154 1
a154 1
struct icmpcodeent icmp6_code[] = {
d189 1
a189 1
struct icmptypeent *
d209 1
a209 1
struct icmptypeent *
d229 1
a229 1
struct icmpcodeent *
d251 1
a251 1
struct icmpcodeent *
d566 1
a566 1
			struct icmpcodeent *ic;
d685 1
a685 1
		struct icmptypeent *p;
d697 1
a697 1
			struct icmpcodeent *p;
@


1.80
log
@Make state timeouts configurable per rule, like

  pass in from any to any port www keep state (tcp.established 60)

ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.79 2002/06/07 22:53:45 pb Exp $ */
d167 20
@


1.79
log
@
add the possibility to configure a TTL while return-rst

ok dhartmei@@, ipv6 part itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.78 2002/06/07 21:25:35 dhartmei Exp $ */
d533 2
d690 1
d692 20
a711 1
		printf("(max %u) ", r->max_states);
@


1.78
log
@Add "(max <number>)" option for "keep/modulate state" to limit the number
of concurrent connections a rule can create. ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.77 2002/06/07 19:30:40 henning Exp $ */
d538 6
a543 3
		if (r->rule_flag & PFRULE_RETURNRST)
			printf("return-rst ");
		else if (r->return_icmp) {
@


1.77
log
@minor KNF while I'm here
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.76 2002/06/06 22:22:44 mickey Exp $ */
d685 2
@


1.76
log
@split out the pf_state printing functions to be used elsewhere, no functional change; dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.75 2002/06/01 04:06:47 hugh Exp $ */
d260 1
a260 1
	else if (op == PF_OP_EQ) {
d262 1
a262 1
	} else if (op == PF_OP_NE) {
d264 1
a264 1
	} else if (op == PF_OP_LT)
@


1.75
log
@ECN flag support for pf. Committed in consultation with Daniel.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.74 2002/05/27 10:33:32 dhartmei Exp $ */
a40 2
#define TCPSTATES
#include <netinet/tcp_fsm.h>
d54 1
a55 4
int		 unmask (struct pf_addr *, u_int8_t);
void		 print_addr (struct pf_addr_wrap *, struct pf_addr *, u_int8_t);
void		 print_host (struct pf_state_host *, u_int8_t, int);
void		 print_seq (struct pf_state_peer *);
a252 94
int
unmask(struct pf_addr *m, u_int8_t af)
{
	int i = 31, j = 0, b = 0, msize;
	u_int32_t tmp;

	if (af == AF_INET)
		msize = 1;
	else
		msize = 4;
	while (j < msize && m->addr32[j] == 0xffffffff) {
		b += 32;
		j++;
	}
	if (j < msize) {
		tmp = ntohl(m->addr32[j]);
		for (i = 31; tmp & (1 << i); --i)
			b++;
	}
	return (b);
}

void
print_addr(struct pf_addr_wrap *addr, struct pf_addr *mask, u_int8_t af)
{
	char buf[48];

	if (addr->addr_dyn != NULL)
		printf("(%s)", addr->addr.pfa.ifname);
	else {
		if (inet_ntop(af, &addr->addr, buf, sizeof(buf)) == NULL)
			printf("?");
		else
			printf("%s", buf);
	}
	if (mask != NULL) {
		int bits = unmask(mask, af);

		if (bits != (af == AF_INET ? 32 : 128))
			printf("/%u", bits);
	}
}

void
print_name(struct pf_addr *addr, struct pf_addr *mask, int af)
{
	char buf[48];
	struct hostent *hp;

	if (inet_ntop(af, addr, buf, sizeof(buf)) == NULL)
		printf("?");
	else {
		hp = getpfhostname(buf);
		printf("%s", hp->h_name);
	}
	if (mask != NULL) {
		if (!PF_AZERO(mask, af))
			printf("/%u", unmask(mask, af));
	}
}

void
print_host(struct pf_state_host *h, u_int8_t af, int opts)
{
	u_int16_t p = ntohs(h->port);

	if (opts & PF_OPT_USEDNS)
		print_name(&h->addr, NULL, af);
	else {
		struct pf_addr_wrap aw;

		aw.addr = h->addr;
		aw.addr_dyn = NULL;
		print_addr(&aw, NULL, af);
	}

	if (p) {
		if (af == AF_INET)
			printf(":%u", p);
		else
			printf("[%u]", p);
	}
}

void
print_seq(struct pf_state_peer *p)
{
	if (p->seqdiff)
		printf("[%u + %u](+%u)", p->seqlo, p->seqhi - p->seqlo,
		    p->seqdiff);
	else
		printf("[%u + %u]", p->seqlo, p->seqhi - p->seqlo);
}

a530 73
print_state(struct pf_state *s, int opts)
{
	struct pf_state_peer *src, *dst;
	struct protoent *p;
	u_int8_t hrs, min, sec;

	if (s->direction == PF_OUT) {
		src = &s->src;
		dst = &s->dst;
	} else {
		src = &s->dst;
		dst = &s->src;
	}
	if ((p = getprotobynumber(s->proto)) != NULL)
		printf("%s ", p->p_name);
	else
		printf("%u ", s->proto);
	if (PF_ANEQ(&s->lan.addr, &s->gwy.addr, s->af) ||
	    (s->lan.port != s->gwy.port)) {
		print_host(&s->lan, s->af, opts);
		if (s->direction == PF_OUT)
			printf(" -> ");
		else
			printf(" <- ");
	}
	print_host(&s->gwy, s->af, opts);
	if (s->direction == PF_OUT)
		printf(" -> ");
	else
		printf(" <- ");
	print_host(&s->ext, s->af, opts);

	printf("    ");
	if (s->proto == IPPROTO_TCP) {
		if (src->state <= TCPS_TIME_WAIT &&
		    dst->state <= TCPS_TIME_WAIT) {
			printf("   %s:%s\n", tcpstates[src->state],
			    tcpstates[dst->state]);
		} else {
			printf("   <BAD STATE LEVELS>\n");
		}
		if (opts & PF_OPT_VERBOSE) {
			printf("   ");
			print_seq(src);
			printf("  ");
			print_seq(dst);
			printf("\n");
		}
	} else {
		printf("   %u:%u\n", src->state, dst->state);
	}

	if (opts & PF_OPT_VERBOSE) {
		sec = s->creation % 60;
		s->creation /= 60;
		min = s->creation % 60;
		s->creation /= 60;
		hrs = s->creation;
		printf("   age %.2u:%.2u:%.2u", hrs, min, sec);
		sec = s->expire % 60;
		s->expire /= 60;
		min = s->expire % 60;
		s->expire /= 60;
		hrs = s->expire;
		printf(", expires in %.2u:%.2u:%.2u", hrs, min, sec);
		printf(", %u pkts, %u bytes", s->packets, s->bytes);
		if (s->rule.nr != USHRT_MAX)
			printf(", rule %u", s->rule.nr);
		printf("\n");
	}
}

void
a713 21
}

struct hostent *
getpfhostname(const char *addr_str)
{
	in_addr_t		 addr_num;
	struct hostent		*hp;
	static struct hostent	 myhp;

	addr_num = inet_addr(addr_str);
	if (addr_num == INADDR_NONE) {
		myhp.h_name = (char *)addr_str;
		hp = &myhp;
		return (hp);
	}
	hp = gethostbyaddr((char *)&addr_num, sizeof(addr_num), AF_INET);
	if (hp == NULL) {
		myhp.h_name = (char *)addr_str;
		hp = &myhp;
	}
	return (hp);
@


1.74
log
@Ports require 6 chars, from Oleg Safiullin
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.73 2002/05/23 09:47:20 deraadt Exp $ */
d67 1
a67 1
char *tcpflags = "FSRPAU";
d423 1
a423 1
	for (i = 0; i < 6; ++i)
d885 1
a885 1
	return (f ? f : 63);
@


1.73
log
@tiny KNF, some malloc checks, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.72 2002/05/19 22:26:27 deraadt Exp $ */
d376 1
a376 1
	char a1[5], a2[5];
@


1.72
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.71 2002/05/18 13:47:57 dhartmei Exp $ */
a94 1

d177 1
a177 1
	unsigned i;
d180 2
a181 2
		for(i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0])); i++) {
			if(type == icmp_type[i].type)
d185 1
a185 1
		for(i=0; i < (sizeof (icmp6_type) /
d187 1
a187 1
			if(type == icmp6_type[i].type)
d197 1
a197 1
	unsigned i;
d200 2
a201 2
		for(i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0])); i++) {
			if(!strcmp(w, icmp_type[i].name))
d205 1
a205 1
		for(i=0; i < (sizeof (icmp6_type) /
d207 1
a207 1
			if(!strcmp(w, icmp6_type[i].name))
d217 1
a217 1
	unsigned i;
d220 1
a220 1
		for(i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0])); i++) {
d226 1
a226 1
		for(i=0; i < (sizeof (icmp6_code) /
d239 1
a239 1
	unsigned i;
d242 1
a242 1
		for(i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0])); i++) {
d248 1
a248 1
		for(i=0; i < (sizeof (icmp6_code) /
d269 2
a270 2
			b += 32;
			j++;
d448 1
d495 1
d539 1
a584 1

d592 9
a600 9
		case 0:
			printf("None");
			break;
		case 1:
			printf("Urgent");
			break;
		case 2:
			printf("Misc");
			break;
d773 1
@


1.71
log
@Handle long (unsigned 32-bit) IDs in print_uid/gid(). From Oleg Safiullin.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.70 2002/05/12 00:54:56 dhartmei Exp $ */
d126 1
a126 1
	
a173 1
	
d270 1
a270 1
			b += 32;	
d299 1
a299 1
	} 
d311 1
a311 1
		hp = getpfhostname(buf); 
a314 1
		
a341 1
		
d442 1
a442 1
		if (n->af == AF_INET) 
d488 1
a488 1
		if (b->af == AF_INET) 
d512 1
a512 1
	 	printf("-> ");
d531 1
a531 1
		if (r->af == AF_INET) 
d765 1
a765 1
		if (r->af == AF_INET) 
@


1.70
log
@Add gid based filtering, reduce to one (effective) uid, rename parser
keywords to 'user' and 'group'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.69 2002/05/09 21:58:12 jasoni Exp $ */
d397 1
a397 1
	char a1[5], a2[5];
d411 1
a411 1
	char a1[5], a2[5];
@


1.69
log
@Add a max-mss option to the scrub rule which will enforce a maximum mss
by lowering it to the given value.
- ok dhartmei@@, provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.68 2002/05/09 19:58:42 dhartmei Exp $ */
d64 1
d409 14
d821 4
a824 6
	if (r->ruid.op) {
		print_uid(r->ruid.op, r->ruid.uid[0], r->ruid.uid[1], "ruid");
	}
	if (r->euid.op) {
		print_uid(r->euid.op, r->euid.uid[0], r->euid.uid[1], "euid");
	}
@


1.68
log
@Introduce user based filtering. Rules can specify ruid and euid (real and
effective user ID) much like ports. The user of a packet is either the
user that opens an outgoing connection, the one that listens on a socket,
or 'unknown' if the firewall is not a connection endpoint (for forwarded
connections). Socket uid lookup code from jwk@@bug.it.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.67 2002/05/05 21:40:22 dhartmei Exp $ */
d851 2
@


1.67
log
@Instead of returning a useless kernel space pointer for the rule that
created the state from DIOCGETSTATE(S), return the integer rule number,
Print rule number (if existant) from pfctl -vss. Suggested by Jeff Nathan.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.66 2002/04/24 18:10:25 dhartmei Exp $ */
d61 1
d63 1
d356 1
a356 1
print_port(u_int8_t op, u_int16_t p1, u_int16_t p2, char *proto)
a357 5
	struct servent *s = getservbyport(p1, proto);

	p1 = ntohs(p1);
	p2 = ntohs(p2);
	printf("port ");
d359 1
a359 1
		printf("%u >< %u ", p1, p2);
d361 1
a361 1
		printf("%u <> %u ", p1, p2);
d363 1
a363 4
		if (s != NULL)
			printf("= %s ", s->s_name);
		else
			printf("= %u ", p1);
d365 1
a365 4
		if (s != NULL)
			printf("!= %s ", s->s_name);
		else
			printf("!= %u ", p1);
d367 1
a367 1
		printf("< %u ", p1);
d369 1
a369 1
		printf("<= %u ", p1);
d371 1
a371 1
		printf("> %u ", p1);
d373 32
a404 1
		printf(">= %u ", p1);
d805 6
@


1.66
log
@Add dynamic (in-kernel) interface name -> address translation. Instead of
using just the interface name instead of an address and reloading the rule
set whenever the interface changes its address, the interface name can be
put in parentheses, and the kernel will keep track of changes and update
rules. There is no additional cost for evaluating rules (per packet),
the cost occurs when an interface changes address (and the rules are
traversed and updated where necessary).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.65 2002/04/23 14:32:23 dhartmei Exp $ */
d660 4
a663 1
		printf(", %u pkts, %u bytes\n", s->packets, s->bytes);
@


1.65
log
@Allow explicit filtering of fragments when they are not reassembled.
Document fragment handling in the man page. Short version: if you're
scrubbing everything (as is recommended, in general), nothing changes.
If you want to deal with fragments manually, read the man page.
ok frantzen.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.64 2002/04/15 20:39:58 dhartmei Exp $ */
d58 1
a58 1
void		 print_addr (struct pf_addr *, struct pf_addr *, u_int8_t);
d280 1
a280 1
print_addr(struct pf_addr *addr, struct pf_addr *mask, u_int8_t af)
d284 8
a291 4
	if (inet_ntop(af, addr, buf, sizeof(buf)) == NULL)
		printf("?");
	else
		printf("%s", buf);
d293 4
a296 2
		if (!PF_AZERO(mask, af))
			printf("/%u", unmask(mask, af));
d313 1
d326 7
a332 2
	else
		print_addr(&h->addr, NULL, af);
d407 6
d421 1
a421 1
	if (!PF_AZERO(&n->saddr, n->af) || !PF_AZERO(&n->smask, n->af)) {
d429 1
a429 1
	if (!PF_AZERO(&n->daddr, n->af) || !PF_AZERO(&n->dmask, n->af)) {
d453 6
d470 1
a470 1
	if (!PF_AZERO(&b->daddr, b->af) || !PF_AZERO(&b->dmask, b->af)) {
d496 6
d510 1
a510 1
	if (!PF_AZERO(&r->saddr, r->af) || !PF_AZERO(&r->smask, r->af)) {
d518 1
a518 1
	if (!PF_AZERO(&r->daddr, r->af) || !PF_AZERO(&r->dmask, r->af)) {
d718 4
d723 1
a723 1
			print_addr(&r->rt_addr, NULL, r->af);
d740 1
a740 1
	if (PF_AZERO(&r->src.addr, AF_INET6) &&
d743 1
a743 1
	    !r->src.port_op && PF_AZERO(&r->dst.addr, AF_INET6) &&
d750 1
a750 1
		else if (PF_AZERO(&r->src.addr, AF_INET6) &&
d767 1
a767 1
		else if (PF_AZERO(&r->dst.addr, AF_INET6) &&
@


1.64
log
@Use in_addr_t instead of unsigned long, which breaks on alpha (64-bit).
Closes PR 2547. Reported by Dries Schellekens. Found by frantzen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.63 2002/03/27 18:16:23 mickey Exp $ */
d780 2
@


1.63
log
@implement a "no-route" keyword.
usage semantics are analogous w/ "any", meaning is
"any ip address for which there is no route in the
current routing table", could be used in both from and to.
typical usage would be (assuming symmetrical routing):
block in from no-route to any
also doc "any" in the pf.conf.5, include in regress, etc.
tested by me on i386 and sparc.
dhartmei@@ and frantzen@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.62 2002/03/12 08:15:03 dhartmei Exp $ */
d810 1
a810 1
	unsigned long		 addr_num;
@


1.62
log
@Handle inet_ntop() returning NULL explicitly. Found by mpech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.61 2002/03/11 22:22:57 dhartmei Exp $ */
d708 1
d714 3
a716 1
		if (PF_AZERO(&r->src.addr, AF_INET6) &&
d731 3
a733 1
		if (PF_AZERO(&r->dst.addr, AF_INET6) &&
@


1.61
log
@Add -r to reverse lookup addresses when displaying states.
From John Kerbawy.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.60 2002/01/09 11:30:53 dhartmei Exp $ */
a282 1
	const char *bf;
d284 4
a287 2
	bf = inet_ntop(af, addr, buf, sizeof(buf));
	printf("%s", bf);
a297 1
	const char *bf;
d300 6
a305 3
	bf = inet_ntop(af, addr, buf, sizeof(buf));
	hp = getpfhostname(bf); 
	printf("%s", hp->h_name);
@


1.60
log
@Add labels to rules. These are arbitrary names (not to be confused with
tags that will be used to tag packets later on). Add pfctl -z to clear
per-rule counters. Add pfctl -s labels to output per-rule counters in
terse format and only for rules that have labels. Suggested by
Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.59 2002/01/08 09:31:55 dhartmei Exp $ */
d59 1
a59 1
void		 print_host (struct pf_state_host *, u_int8_t);
d294 17
a310 1
print_host(struct pf_state_host *h, u_int8_t af)
d314 5
a318 1
	print_addr(&h->addr, NULL, af);
d581 1
a581 1
		print_host(&s->lan, s->af);
d587 1
a587 1
	print_host(&s->gwy, s->af);
d592 1
a592 1
	print_host(&s->ext, s->af);
d653 4
a656 2
			else if ((r->af != AF_INET6 && ic->code != ICMP_UNREACH_PORT) ||
			    (r->af == AF_INET6 && ic->code != ICMP6_DST_UNREACH_NOPORT))
d797 21
@


1.59
log
@Add "no nat/rdr/binat" to nat.conf. The first matching rule applies.
If it is a "no" rule, no translation occurs. Useful to exclude certain
packets from translation. Suggested by Henning Brauer.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.58 2002/01/07 17:24:43 mpech Exp $ */
d756 2
@


1.58
log
@Next issue:
 af is always u_int8_t, not int;

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.57 2002/01/04 12:32:30 mpech Exp $ */
d363 3
a365 1
	printf("@@nat ");
d395 4
a398 2
	printf("-> ");
	print_addr(&n->raddr, NULL, n->af);
d405 3
a407 1
	printf("@@binat ");
d430 4
a433 2
 	printf("-> ");
	print_addr(&b->raddr, NULL, b->af);
d440 3
a442 1
	printf("@@rdr ");
d477 9
a485 7
	printf(" -> ");
	print_addr(&r->raddr, NULL, r->af);
	printf(" ");
	if (r->rport) {
		printf("port %u", ntohs(r->rport));
		if (r->opts & PF_RPORT_RANGE)
			printf(":*");
@


1.57
log
@check (p != NULL), not n.

dhartmei@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.56 2001/12/10 18:08:12 dhartmei Exp $ */
d57 3
a59 3
int		 unmask (struct pf_addr *, int);
void		 print_addr (struct pf_addr *, struct pf_addr *, int);
void		 print_host (struct pf_state_host *, int);
d258 1
a258 1
unmask(struct pf_addr *m, int af)
d280 1
a280 1
print_addr(struct pf_addr *addr, struct pf_addr *mask, int af)
d294 1
a294 1
print_host(struct pf_state_host *h, int af)
@


1.56
log
@Add stateful filtering for other (non-TCP/UDP/ICMP) protocol, based on
source/destination addresses/ports only.
Add RDR for ICMP. Add NAT/RDR/BINAT for other protocols.
Destination and redirection port(s) are now optional for RDR rules.
Not specifying destination port(s) means 'redirect all ports', not
specifying redirection port(s) means 'redirect to the original port'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.55 2001/12/01 16:44:45 frantzen Exp $ */
d372 1
a372 1
		if (n != NULL)
@


1.55
log
@wipe print_nat()'s nose (use dnot correctly instead of snot). i need to start
naming variables 'bugger'.  yes, thats what i'll do
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.54 2001/11/26 16:50:26 jasoni Exp $ */
d299 6
a304 4
	if (af == AF_INET)
		printf(":%u", p);
	else
		printf("[%u]", p);
d370 7
a394 12
	printf(" ");
	switch (n->proto) {
	case IPPROTO_TCP:
		printf("proto tcp");
		break;
	case IPPROTO_UDP:
		printf("proto udp");
		break;
	case IPPROTO_ICMP:
		printf("proto icmp");
		break;
	}
d406 6
a411 10
	switch (b->proto) {
	case IPPROTO_TCP:
		printf("proto tcp ");
		break;
	case IPPROTO_UDP:
		printf("proto udp ");
		break;
	case IPPROTO_ICMP:
		printf("proto icmp ");
		break;
d439 6
a444 7
	switch (r->proto) {
	case IPPROTO_TCP:
		printf("proto tcp ");
		break;
	case IPPROTO_UDP:
		printf("proto udp ");
		break;
d462 5
a466 3
	printf("port %u", ntohs(r->dport));
	if (r->opts & PF_DPORT_RANGE)
		printf(":%u", ntohs(r->dport2));
d470 5
a474 3
	printf("port %u", ntohs(r->rport));
	if (r->opts & PF_RPORT_RANGE)
		printf(":*");
d533 1
d543 4
a546 15
	switch (s->proto) {
	case IPPROTO_TCP:
		printf("TCP  ");
		break;
	case IPPROTO_UDP:
		printf("UDP  ");
		break;
	case IPPROTO_ICMPV6:
	case IPPROTO_ICMP:
		printf("ICMP ");
		break;
	default:
		printf("???? ");
		break;
	}
@


1.54
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.53 2001/10/24 09:09:32 dhartmei Exp $ */
d378 1
a378 1
		if (n->snot)
@


1.53
log
@Use snot/dnot correctly in print_rdr. RDR rules with '!' used on the
destination address were printed incorrectly before (though the rules
worked correctly).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.52 2001/10/15 16:22:22 dhartmei Exp $ */
d655 15
@


1.52
log
@Add 'allow-opts' to rules. Packets with IP options will be blocked by
default now, and can be allowed per rule. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.51 2001/10/04 21:54:15 dhartmei Exp $ */
d464 1
a464 1
		if (r->snot)
@


1.52.2.1
log
@Pull in patches from current:
Fix (frantzen, dhartmei):
-- wipe print_nat()'s nose (use dnot correctly instead of snot). i need to start
naming variables 'bugger'.  yes, thats what i'll do
-- Use snot/dnot correctly in print_rdr. RDR rules with '!' used on the
destination address were printed incorrectly before (though the rules
worked correctly).
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.52 2001/10/15 16:22:22 dhartmei Exp $ */
d378 1
a378 1
		if (n->dnot)
d464 1
a464 1
		if (r->dnot)
@


1.51
log
@Honour -v flag when printing states, print only one line per state when
non-verbose. Suggested by gwyllion@@ace.ulyssis.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.50 2001/09/15 23:23:40 wilfried Exp $ */
d741 2
@


1.50
log
@Implement return-icmp(number), return-icmp6(number)
Differentiate between return-icmp and return-icmp6,
icmp-type and ipv6-icmp-type. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.49 2001/09/15 23:13:40 dhartmei Exp $ */
d534 1
a534 1
print_state(struct pf_state *s)
d585 7
a591 5
		printf("   ");
		print_seq(src);
		printf("  ");
		print_seq(dst);
		printf("\n");
d596 15
a610 13
	sec = s->creation % 60;
	s->creation /= 60;
	min = s->creation % 60;
	s->creation /= 60;
	hrs = s->creation;
	printf("   age %.2u:%.2u:%.2u", hrs, min, sec);
	sec = s->expire % 60;
	s->expire /= 60;
	min = s->expire % 60;
	s->expire /= 60;
	hrs = s->expire;
	printf(", expires in %.2u:%.2u:%.2u", hrs, min, sec);
	printf(", %u pkts, %u bytes\n", s->packets, s->bytes);
@


1.49
log
@ICMP6_DST_UNREACH_NOROUTE <-> _ADMIN, reported by Wouter Coene.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.48 2001/09/15 03:54:40 frantzen Exp $ */
d174 1
a174 1
geticmptypebynumber(u_int8_t type, u_int8_t proto)
d178 1
a178 1
	if (proto == IPPROTO_ICMP) {
d194 1
a194 1
geticmptypebyname(char *w, u_int8_t proto)
d198 1
a198 1
	if (proto == IPPROTO_ICMP) {
d214 1
a214 1
geticmpcodebynumber(u_int8_t type, u_int8_t code, u_int8_t proto)
d218 1
a218 1
	if (proto == IPPROTO_ICMP) {
d236 1
a236 1
geticmpcodebyname(u_long type, char *w, u_int8_t proto)
d240 1
a240 1
	if (proto == IPPROTO_ICMP) {
d622 4
a625 1
			printf("return-icmp");
d627 6
a632 5
			    r->return_icmp & 255, r->proto);
			if ((ic == NULL) || (ic->type != ICMP_UNREACH))
				printf("(%u,%u) ", r->return_icmp >> 8,
				    r->return_icmp & 255);
			else if (ic->code != ICMP_UNREACH_PORT)
d710 5
a714 1
		p = geticmptypebynumber(r->type-1, r->proto);
d716 1
a716 1
			printf("icmp-type %s ", p->name);
d718 1
a718 1
			printf("icmp-type %u ", r->type-1);
d722 1
a722 1
			p = geticmpcodebynumber(r->type-1, r->code-1, r->proto);
@


1.48
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.47 2001/09/06 18:05:46 jasoni Exp $ */
d158 2
a159 2
	{ "admin-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_NOROUTE },
	{ "noroute-unr", ICMP6_DST_UNREACH, ICMP6_DST_UNREACH_ADMIN },
@


1.47
log
@1:1 bidrectional NAT (binat); ok dhartmei@@ and frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.46 2001/09/02 15:15:31 dhartmei Exp $ */
d40 1
d57 3
a59 2
void		 print_addr (u_int32_t);
void		 print_host (struct pf_state_host *);
d95 29
d157 16
d174 1
a174 1
geticmptypebynumber(u_int8_t type)
d178 11
a188 3
	for(i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0])); i++) {
		if(type == icmp_type[i].type)
			return (&icmp_type[i]);
d190 1
a190 1
	return (0);
d194 1
a194 1
geticmptypebyname(char *w)
d198 11
a208 3
	for(i=0; i < (sizeof (icmp_type) / sizeof(icmp_type[0])); i++) {
		if(!strcmp(w, icmp_type[i].name))
			return (&icmp_type[i]);
d210 1
a210 1
	return (0);
d214 1
a214 1
geticmpcodebynumber(u_int8_t type, u_int8_t code)
d218 13
a230 3
	for(i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0])); i++) {
		if (type == icmp_code[i].type && code == icmp_code[i].code)
			return (&icmp_code[i]);
d232 1
a232 1
	return (0);
d236 1
a236 1
geticmpcodebyname(u_long type, char *w)
d240 13
a252 3
	for(i=0; i < (sizeof (icmp_code) / sizeof(icmp_code[0])); i++) {
		if (type == icmp_code[i].type && !strcmp(w, icmp_code[i].name))
			return (&icmp_code[i]);
d254 23
a276 1
	return (0);
d280 1
a280 1
print_addr(u_int32_t a)
d282 9
a290 2
	a = ntohl(a);
	printf("%u.%u.%u.%u", (a>>24)&255, (a>>16)&255, (a>>8)&255, a&255);
d294 1
a294 1
print_host(struct pf_state_host *h)
a295 1
	u_int32_t a = ntohl(h->addr);
d298 5
a302 1
	printf("%u.%u.%u.%u:%u", (a>>24)&255, (a>>16)&255, (a>>8)&255, a&255, p);
d304 1
d369 1
a369 1
	if (n->saddr || n->smask) {
d372 1
a372 5
		print_addr(n->saddr);
		if (n->smask != 0xFFFFFFFF) {
			printf("/");
			print_addr(n->smask);
		}
d377 2
a378 2
	if (n->daddr || n->dmask) {
		if (n->dnot)
d380 1
a380 5
		print_addr(n->daddr);
		if (n->dmask != 0xFFFFFFFF) {
			printf("/");
			print_addr(n->dmask);
		}
d385 1
a385 1
	print_addr(n->raddr);
d421 1
a421 1
	print_addr(b->saddr);
d424 1
a424 1
	if (b->daddr || b->dmask) {
d427 1
a427 5
		print_addr(b->daddr);
		if (b->dmask != 0xFFFFFFFF) {
			printf("/");
			print_addr(b->dmask);
		}
d432 1
a432 1
	print_addr(b->raddr);
d455 1
a455 1
	if (r->saddr || r->smask) {
d458 1
a458 5
		print_addr(r->saddr);
		if (r->smask != 0xFFFFFFFF) {
			printf("/");
			print_addr(r->smask);
		}
d463 2
a464 2
	if (r->daddr || r->dmask) {
		if (r->dnot)
d466 1
a466 5
		print_addr(r->daddr);
		if (r->dmask != 0xFFFFFFFF) {
			printf("/");
			print_addr(r->dmask);
		}
d474 1
a474 1
	print_addr(r->raddr);
d506 16
a521 8
	printf("\nBytes In: %-10llu  Bytes Out: %-10llu\n",
	    s->bcounters[PF_IN], s->bcounters[PF_OUT]);
	printf("Inbound Packets:  Passed: %-10llu  Dropped: %-10llu\n",
	    s->pcounters[PF_IN][PF_PASS],
	    s->pcounters[PF_IN][PF_DROP]);
	printf("Outbound Packets: Passed: %-10llu  Dropped: %-10llu\n",
	    s->pcounters[PF_OUT][PF_PASS],
	    s->pcounters[PF_OUT][PF_DROP]);
d553 1
d561 3
a563 2
	if ((s->lan.addr != s->gwy.addr) || (s->lan.port != s->gwy.port)) {
		print_host(&s->lan);
d569 1
a569 1
	print_host(&s->gwy);
d574 1
a574 1
	print_host(&s->ext);
d624 1
a624 1
			    r->return_icmp & 255);
d647 6
d660 4
a663 1
	if (!r->src.addr && !r->src.mask && !r->src.port_op && !r->dst.addr && ! r->dst.mask && !r->dst.port_op)
d667 2
a668 1
		if (!r->src.addr && !r->src.mask)
d673 1
a673 5
			print_addr(r->src.addr);
			if (r->src.mask != 0xFFFFFFFF) {
				printf("/");
				print_addr(r->src.mask);
			}
d682 2
a683 1
		if (!r->dst.addr && !r->dst.mask)
d688 1
a688 5
			print_addr(r->dst.addr);
			if (r->dst.mask != 0xFFFFFFFF) {
				printf("/");
				print_addr(r->dst.mask);
			}
d706 1
a706 1
		p = geticmptypebynumber(r->type-1);
d714 1
a714 1
			p = geticmpcodebynumber(r->type-1, r->code-1);
d737 1
a737 1
        u_int8_t f = 0;
d739 1
a739 1
        for (p = s; *p; p++) {
d744 2
a745 2
        }
        return (f ? f : 63);
@


1.46
log
@Print rule numbers zero-based. Noted by primus@@gblx.net.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.45 2001/08/25 21:54:26 frantzen Exp $ */
d290 39
@


1.45
log
@PF ISN randomization.  Or in trekkie techno-babble, ISN phase modulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.44 2001/08/23 04:10:51 deraadt Exp $ */
d467 1
a467 1
	printf("@@%d ", r->nr + 1);
@


1.44
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.43 2001/08/19 17:03:00 frantzen Exp $ */
d193 5
a197 1
	printf("[%u + %u]", p->seqlo, p->seqhi - p->seqlo);
a429 1
	printf("\n");
d431 1
d433 8
a440 2
		printf("   %s:%s  ", tcpstates[src->state],
			tcpstates[dst->state]);
d442 1
a442 1
		printf("    ");
d446 1
a446 1
		printf("   %u:%u  ", src->state, dst->state);
d573 1
a573 1
	if (r->keep_state)
d575 2
@


1.43
log
@Unfuck some TCP state stuff that would drop the SYN|ACK.
Enumerated the TCP states.
Here's a mapping new->old tcp states if anyone gives a shit:
TCPS_CLOSED            0
TCPS_SYN_SENT          1
TCPS_ESTABLISHED       2
TCPS_CLOSING           3
TCPS_FIN_WAIT_2        4
TCPS_TIME_WAIT         5
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.42 2001/08/18 14:05:56 deraadt Exp $ */
d4 1
a4 1
 * Copyright (c) 2001, Daniel Hartmeier
d12 1
a12 1
 *      notice, this list of conditions and the following disclaimer. 
d16 1
a16 1
 *      with the distribution. 
d94 16
a109 16
	{ "net-unr",		ICMP_UNREACH, 	ICMP_UNREACH_NET },
	{ "host-unr",		ICMP_UNREACH, 	ICMP_UNREACH_HOST },
	{ "proto-unr",		ICMP_UNREACH, 	ICMP_UNREACH_PROTOCOL },
	{ "port-unr",		ICMP_UNREACH, 	ICMP_UNREACH_PORT },
	{ "needfrag",		ICMP_UNREACH, 	ICMP_UNREACH_NEEDFRAG },
	{ "srcfail",		ICMP_UNREACH, 	ICMP_UNREACH_SRCFAIL },
	{ "net-unk",		ICMP_UNREACH, 	ICMP_UNREACH_NET_UNKNOWN },
	{ "host-unk",		ICMP_UNREACH, 	ICMP_UNREACH_HOST_UNKNOWN },
	{ "isolate",		ICMP_UNREACH, 	ICMP_UNREACH_ISOLATED },
	{ "net-prohib",		ICMP_UNREACH, 	ICMP_UNREACH_NET_PROHIB },
	{ "host-prohib",	ICMP_UNREACH, 	ICMP_UNREACH_HOST_PROHIB },
	{ "net-tos",		ICMP_UNREACH, 	ICMP_UNREACH_TOSNET },
	{ "host-tos",		ICMP_UNREACH, 	ICMP_UNREACH_TOSHOST },
	{ "filter-prohib",	ICMP_UNREACH, 	ICMP_UNREACH_FILTER_PROHIB },
	{ "host-preced",	ICMP_UNREACH, 	ICMP_UNREACH_HOST_PRECEDENCE },
	{ "cutoff-preced",	ICMP_UNREACH, 	ICMP_UNREACH_PRECEDENCE_CUTOFF },
d555 1
a555 1
			
d569 1
a569 1
	
@


1.42
log
@prettier printing of states
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.42 2001/08/18 08:59:12 deraadt Exp $ */
d40 2
a427 1
	printf("\t%u:%u  ", src->state, dst->state);
d429 2
d435 2
d444 1
a444 1
	printf("\tage %.2u:%.2u:%.2u", hrs, min, sec);
@


1.41
log
@track the line number per-token, so that we can report errors correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.40 2001/08/11 12:05:00 dhartmei Exp $ */
d426 1
a426 1
	printf("%u:%u  ", src->state, dst->state);
d431 1
a431 1
		printf("\n     ");
d439 1
a439 1
	printf("age %.2u:%.2u:%.2u", hrs, min, sec);
a446 1
	printf("\n");
@


1.40
log
@Add support for ICMP errors referring to ICMP queries/replies. Fixes
'ICMP error message for bad proto' messages. Reported by Mark Grimes
and Steve Rumble.

Add debugging level with ioctl interface and pfctl switch. Default
is 'None'.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.39 2001/07/19 00:07:36 krw Exp $ */
d239 1
a239 1
	printf("nat ");
d290 1
a290 1
	printf("rdr ");
@


1.39
log
@Fix/complete the handling of the binary ops >< and <> to behave
like the ipf operators.

The 'n >< m' construct (Include Range = PF_OP_IRG) should match
ports greater than n and less than m, not greater than or equal to
n and less than or equal to m.

The 'n <> m' construct (Exclude Range = PF_OP_XRG) should match
all ports less than n OR greater than m, not be treated as an
alias for ><.

Thus PF_OP_GL, which was used for both <> and >< is replaced with
PF_OP_IRG and PF_OP_XRG with the 'correct' semantics.

OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.38 2001/07/17 23:25:42 provos Exp $ */
d351 1
a351 1
	printf("Status: %s  Time: %u  Since: %u\n",
d354 12
a365 1
	printf("Bytes In: %-10llu  Bytes Out: %-10llu\n",
@


1.38
log
@markus doesnt like min-ttl =, begone
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.37 2001/07/17 22:22:17 provos Exp $ */
d202 1
a202 1
	if (op == PF_OP_GL)
d204 2
@


1.37
log
@support min-ttl, okay dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.36 2001/07/17 21:54:27 provos Exp $ */
d551 1
a551 1
		printf("min-ttl = %d ", r->min_ttl);
@


1.36
log
@normalize ip_off, make IP_DF stripping optional, return rst is a flag now.
okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.35 2001/07/16 21:09:38 markus Exp $ */
d549 3
a551 1
		printf("no-df");
@


1.35
log
@add a yacc parser for pf.conf and nat.conf, with help from mickey@@,
plus: -n now turns off all operations, and just parses the conf files
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.34 2001/07/11 21:30:14 csapuntz Exp $ */
d445 1
a445 1
		if (r->return_rst)
d548 3
@


1.34
log
@Error on invalid ports
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.33 2001/07/10 05:55:57 millert Exp $ */
d50 1
a58 6
char		*next_word (char **);
int		 next_addr (char **, u_int32_t *);
u_int16_t	 next_number (char **);
u_int8_t	 next_flags (char **);
int              rule_port (char *, u_int8_t, u_int16_t *);
u_int32_t	 rule_mask (u_int8_t);
a61 11
struct icmptypeent {
	char *name;
	u_int8_t type;
};

struct icmpcodeent {
	char *name;
	u_int8_t type;
	u_int8_t code;
};

a123 13
int
error(int n, char *fmt, ...)
{
	extern char *__progname;
	va_list ap;

	va_start(ap, fmt);
	fprintf(stderr, "%s: line %d ", __progname, n);
	vfprintf(stderr, fmt, ap);
	va_end(ap);
	return (0);
}

a550 46
char *
next_line(char **s)
{
	char *l = *s;

	while (**s && (**s != '\n'))
		(*s)++;
	if (**s) {
		**s = 0;
		(*s)++;
	}
	return (l);
}

char *
next_word(char **s)
{
	char *w;

	while ((**s == ' ') || (**s == '\t') || (**s == '\n'))
		(*s)++;
	w = *s;
	while (**s && (**s != ' ') && (**s != '\t') && (**s != '\n'))
		(*s)++;
	if (**s) {
		**s = 0;
		(*s)++;
	}
	return (w);
}

u_int16_t
next_number(char **s)
{
	u_int16_t n = 0;

	while (**s && !isdigit(**s))
		(*s)++;
	while (**s && isdigit(**s)) {
		n *= 10;
		n += **s - '0';
		(*s)++;
	}
	return (n);
}

d552 1
a552 1
next_addr(char **w, u_int32_t *a)
d554 2
a555 2
	struct hostent *hp;
	char *slash;
d557 7
a563 696
	if ((slash = strchr(*w, '/')))
		*slash = '\0';
	if (inet_pton(AF_INET, *w, a) != 1) {
		if ((hp = gethostbyname(*w)) == NULL)
			return(0);
		memcpy(a, hp->h_addr, sizeof(*a));
	}
	if (slash) {
		*slash = '/';
		*w = slash;
	} else
		*w += strlen(*w);
	return(1);
}

u_int8_t
next_flags(char **s)
{
	u_int8_t f = 0;
	char *p;

	while (**s && !strchr(tcpflags, **s))
		(*s)++;
	while (**s && ((p = strchr(tcpflags, **s)) != NULL)) {
		f |= 1 << (p-tcpflags);
		(*s)++;
	}
	return (f ? f : 63);
}

int
rule_port(char *w, u_int8_t p, u_int16_t *result)
{
	struct servent *s;
	u_long ul;
	char *ep;

	errno = 0;
	ul = strtoul(w, &ep, 10);
	if (*w == '\0' || *ep != '\0') {
		s = getservbyname(w, p == IPPROTO_TCP ? "tcp" : "udp");
		if (s == NULL)
			return (0);
		
		*result = s->s_port;
		return (1);
	}
	if (errno == ERANGE && ul == ULONG_MAX)
		return (0);
	if (ul > USHRT_MAX) {
		errno = ERANGE;
		return (0);
	}

	*result = htons(ul);
	return (1);
}

u_int32_t
rule_mask(u_int8_t b)
{
	u_int32_t m = 0;
	int i;

	for (i = 31; i > 31-b; --i)
		m |= (1 << i);
	return (htonl(m));
}

int
parse_rule(int n, char *l, struct pf_rule *r)
{
	char *w;
	memset(r, 0, sizeof(struct pf_rule));
	w = next_word(&l);

	/* pass / block */
	if (!strcmp(w, "pass" ))
		r->action = PF_PASS;
	else if (!strcmp(w, "block"))
		r->action = PF_DROP;
	else if (!strcmp(w, "scrub"))
		r->action = PF_SCRUB;
	else {
		error(n, "expected pass/block/scrub, got %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* return-rst/return-icmp */
	if (r->action == PF_DROP) {
		if (!strcmp(w, "return-rst")) {
			r->return_rst = 1;
			w = next_word(&l);
		} else if (!strncmp(w, "return-icmp", 11)) {
			w += 11;
			if ((strlen(w) > 2) && (w[0] == '(') &&
			    (w[strlen(w)-1] == ')')) {
				struct icmpcodeent *ic;

				w[strlen(w)-1] = 0;
				w++;
				ic = geticmpcodebyname(ICMP_UNREACH, w);
				if (ic == NULL) {
					error(n, "expected icmp code, got %s\n",
					    w);
					return (0);
				}
				r->return_icmp = ic->type << 8;
				r->return_icmp |= ic->code;
			} else
				r->return_icmp = (ICMP_UNREACH << 8) |
				    ICMP_UNREACH_PORT;
			w = next_word(&l);
		}
	}

	/* in / out */
	if (!strcmp(w, "in" ))
		r->direction = 0;
	else if (!strcmp(w, "out"))
		r->direction = 1;
	else {
		error(n, "expected in/out, got %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* log */
	if (!strcmp(w, "log")) {
		r->log = 1;
		w = next_word(&l);
	} else if (!strcmp(w, "log-all")) {
		r->log = 2;
		w = next_word(&l);
	}

	/* quick */
	if (!strcmp(w, "quick")) {
		if (r->action == PF_SCRUB) {
			error(n, "quick does not apply to scrub\n");
			return (0);
		}
		r->quick = 1;
		w = next_word(&l);
	}

	/* on <if> */
	if (!strcmp(w, "on")) {
		w = next_word(&l);
		strncpy(r->ifname, w, 16);
		w = next_word(&l);
	}

	/* proto tcp/udp/icmp */
	if (!strcmp(w, "proto")) {
		struct protoent *p;
		w = next_word(&l);
		p = getprotobyname(w);
		if (p == NULL) {
			int proto = atoi(w);
			if (proto > 0)
				p = getprotobynumber(proto);
		}
		if (p == NULL) {
			error(n, "unknown protocol %s\n", w);
			return (0);
		}
		r->proto = p->p_proto;
		w = next_word(&l);
	}

	/* all / from src to dst */
	if (!strcmp(w, "all" ))
		w = next_word(&l);
	else if (!strcmp(w, "from")) {
		w = next_word(&l);

		/* source address */
		if (!strcmp(w, "any"))
			w = next_word(&l);
		else {
			if (!strcmp(w, "!")) {
				r->src.not = 1;
				w = next_word(&l);
			}
			if (!next_addr(&w, &r->src.addr)) {
				error(n, "unresolvable host %s\n", w);
				return (0);
			}
			if (!*w)
				r->src.mask = 0xFFFFFFFF;
			else if (*w == '/')
				r->src.mask = rule_mask(next_number(&w));
			else {
				error(n, "expected /, got '%c'\n", *w);
				return (0);
			}
			w = next_word(&l);
		}

		if (r->action == PF_SCRUB)
			goto skip_fromport;
		
		/* source port */
		if (((r->proto == IPPROTO_TCP) || (r->proto == IPPROTO_UDP)) &&
		    !strcmp(w, "port")) {
			w = next_word(&l);
			if (!strcmp(w, "=" ))
				r->src.port_op = PF_OP_EQ;
			else if (!strcmp(w, "!="))
				r->src.port_op = PF_OP_NE;
			else if (!strcmp(w, "<" ))
				r->src.port_op = PF_OP_LT;
			else if (!strcmp(w, "<="))
				r->src.port_op = PF_OP_LE;
			else if (!strcmp(w, ">" ))
				r->src.port_op = PF_OP_GT;
			else if (!strcmp(w, ">="))
				r->src.port_op = PF_OP_GE;
			else
				r->src.port_op = PF_OP_GL;
			if (r->src.port_op != 1)
				w = next_word(&l);
			if (!rule_port(w, r->proto, &r->src.port[0])) {
				error(n, "invalid port '%s'\n", w);
				return (0);
			}
			w = next_word(&l);
			if (r->src.port_op == PF_OP_GL) {
				if (strcmp(w, "<>") && strcmp(w, "><")) {
					error(n, "expected <>/><, got %s\n",
					    w);
					return (0);
				}
				w = next_word(&l);
				if (!rule_port(w, r->proto, &r->src.port[1])) {
					error(n, "invalid port '%s'\n", w);
					return (0);
				}
				w = next_word(&l);
			}
		}

	skip_fromport:
		
		/* destination address */
		if (strcmp(w, "to")) {
			error(n, "expected to, got %s\n", w);
			return (0);
		}
		w = next_word(&l);
		if (!strcmp(w, "any"))
			w = next_word(&l);
		else {
			if (!strcmp(w, "!")) {
				r->dst.not = 1;
				w = next_word(&l);
			}
			if (!next_addr(&w, &r->dst.addr)) {
				error(n, "unresolvable host %s\n", w);
				return (0);
			}
			if (!*w)
				r->dst.mask = 0xFFFFFFFF;
			else if (*w == '/')
				r->dst.mask = rule_mask(next_number(&w));
			else {
				error(n, "expected /, got '%c'\n", *w);
				return (0);
			}
			w = next_word(&l);
		}

		if (r->action == PF_SCRUB)
			goto skip_toport;
		
		/* destination port */
		if (((r->proto == IPPROTO_TCP) || (r->proto == IPPROTO_UDP)) &&
		    !strcmp(w, "port")) {
			w = next_word(&l);
			if (!strcmp(w, "=" ))
				r->dst.port_op = PF_OP_EQ;
			else if (!strcmp(w, "!="))
				r->dst.port_op = PF_OP_NE;
			else if (!strcmp(w, "<" ))
				r->dst.port_op = PF_OP_LT;
			else if (!strcmp(w, "<="))
				r->dst.port_op = PF_OP_LE;
			else if (!strcmp(w, ">" ))
				r->dst.port_op = PF_OP_GT;
			else if (!strcmp(w, ">="))
				r->dst.port_op = PF_OP_GE;
			else
				r->dst.port_op = PF_OP_GL;
			if (r->dst.port_op != PF_OP_GL)
				w = next_word(&l);
 			if (!rule_port(w, r->proto, &r->dst.port[0])) {
 				error(n, "invalid port '%s'\n", w);
				return (0);
			}
			w = next_word(&l);
			if (r->dst.port_op == PF_OP_GL) {
				if (strcmp(w, "<>") && strcmp(w, "><")) {
					error(n, "expected <>/><, got %s\n",
					    w);
					return (0);
				}
				w = next_word(&l);
				if (!rule_port(w, r->proto, &r->dst.port[1])) {
					error(n, "invalid port '%s'\n", w);
					return (0);
				}
				w = next_word(&l);
			}
		}
	skip_toport:

	} else {
		error(n, "expected all/from, got %s\n", w);
		return (0);
	}

	/* flags */
	if (!strcmp(w, "flags")) {
		if (r->proto != IPPROTO_TCP || r->action == PF_SCRUB) {
			error(n, "flags only valid for proto tcp\n");
			return (0);
		} else {
			w = next_word(&l);
			r->flags = next_flags(&w);
			r->flagset = next_flags(&w);
			w = next_word(&l);
		}
	}

	/* icmp type/code */
	if (!strcmp(w, "icmp-type")) {
		if (r->proto != IPPROTO_ICMP || r->action == PF_SCRUB) {
			error(n, "icmp-type only valid for proto icmp\n");
			return (0);
		} else {
			u_long ul;
			char *ep;

			w = next_word(&l);

			errno = 0;
			ul = strtoul(w, &ep, 10);
			if (w[0] == '\0' || *ep != '\0') {
				struct icmptypeent *p;

				p = geticmptypebyname(w);
				if (p == NULL) {
					error(n, "unknown icmp-type %s\n", w);
					return (0);
				}
				ul = p->type;
			} else if ((errno == ERANGE && ul == ULONG_MAX) ||
			    ul > ICMP_MAXTYPE) {
				error(n, "icmp-type type wrong\n");
				return (0);
			}
			r->type = ul+1;

			w = next_word(&l);
			if (!strcmp(w, "code")) {
				w = next_word(&l);

				errno = 0;
				ul = strtoul(w, &ep, 10);
				if (w[0] == '\0' || *ep != '\0') {
					struct icmpcodeent *p;

					p = geticmpcodebyname(r->type-1, w);
					if (p == NULL) {
						error(n, "unknown code %s\n", w);
						return (0);
					}
					ul = p->code;
				} else if ((errno == ERANGE && ul == ULONG_MAX) ||
				    ul > 255) {
					error(n, "icmp-type code wrong\n");
					return (0);
				}
				r->code = ul + 1;

				w = next_word(&l);
			}
		}
	}

	/* keep */
	if (!strcmp(w, "keep") && r->action != PF_SCRUB) {
		w = next_word(&l);
		if (!strcmp(w, "state")) {
			w = next_word(&l);
			r->keep_state = 1;
		} else {
			error(n, "expected state, got %s\n", w);
			return (0);
		}
	}

	/* no further options expected */
	while (*w) {
		error(n, "unexpected %s\n", w);
		w = next_word(&l);
	}

	return (1);
}

int
parse_nat(int n, char *l, struct pf_nat *nat)
{
	char *w;

	memset(nat, 0, sizeof(struct pf_nat));
	w = next_word(&l);

	/* nat */
	if (strcmp(w, "nat" )) {
		error(n, "expected nat, got %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* interface */
	if (!strcmp(w, "on")) {
		w = next_word(&l);
		if (!strcmp(w, "!")) {
			nat->ifnot = 1;
			w = next_word(&l);
		}
		strncpy(nat->ifname, w, 16);
		w = next_word(&l);
	}

	/* proto */
	if (!strcmp(w, "proto")) {
		w = next_word(&l);
		if (!strcmp(w, "tcp"))
			nat->proto = IPPROTO_TCP;
		else if (!strcmp(w, "udp"))
			nat->proto = IPPROTO_UDP;
		else if (!strcmp(w, "icmp"))
			nat->proto = IPPROTO_ICMP;
		else {
			error(n, "expected tcp/udp/icmp, got %s\n", w);
			return (0);
		}
		w = next_word(&l);
	}

	/* source addr/mask */
	if (strcmp(w, "from")) {
		error(n, "expected from, got %s\n", w);
		return (0);
	}
	w = next_word(&l);
	if (!strcmp(w, "any"))
		w = next_word(&l);
	else {
		if (!strcmp(w, "!")) {
			nat->snot = 1;
			w = next_word(&l);
		}
		if (!next_addr(&w, &nat->saddr)) {
			error(n, "unresolvable host %s\n", w);
			return (0);
		}
		if (!*w)
			nat->smask = 0xFFFFFFFF;
		else if (*w == '/')
			nat->smask = rule_mask(next_number(&w));
		else {
			error(n, "expected /, get '%c'\n", *w);
			return (0);
		}
		w = next_word(&l);
	}

	/* destination addr/mask */
	if (strcmp(w, "to")) {
		error(n, "expected to, got %s\n", w);
		return (0);
	}
	w = next_word(&l);
	if (!strcmp(w, "any"))
		w = next_word(&l);
	else {
		if (!strcmp(w, "!")) {
			nat->dnot = 1;
			w = next_word(&l);
		}
		if (!next_addr(&w, &nat->daddr)) {
			error(n, "unresolvable host %s\n", w);
			return (0);
		}
		if (!*w)
			nat->dmask = 0xFFFFFFFF;
		else if (*w == '/')
			nat->dmask = rule_mask(next_number(&w));
		else {
			error(n, "expected /, get '%c'\n", *w);
			return (0);
		}
		w = next_word(&l);
	}

	/* -> */
	if (strcmp(w, "->")) {
		error(n, "expected ->, got %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* external addr */
	if (!next_addr(&w, &nat->raddr)) {
		error(n, "unresolvable host %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* no further options expected */
	while (*w) {
		error(n, "unexpected %s\n", w);
		w = next_word(&l);
	}

	return (1);
}

int
parse_rdr(int n, char *l, struct pf_rdr *rdr)
{
	char *w, *s;

	memset(rdr, 0, sizeof(struct pf_rdr));
	w = next_word(&l);

	/* rdr */
	if (strcmp(w, "rdr" )) {
		error(n, "expected rdr, got %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* interface */
	if (!strcmp(w, "on")) {
		w = next_word(&l);
		if (!strcmp(w, "!")) {
			rdr->ifnot = 1;
			w = next_word(&l);
		}
		strncpy(rdr->ifname, w, 16);
		w = next_word(&l);
	}

	/* source addr/mask */
	if (strcmp(w, "from")) {
		error(n, "expected from, got %s\n", w);
		return (0);
	}
	w = next_word(&l);
	if (!strcmp(w, "any"))
		w = next_word(&l);
	else {
		if (!strcmp(w, "!")) {
			rdr->snot = 1;
			w = next_word(&l);
		}
		if (!next_addr(&w, &rdr->saddr)) {
			error(n, "unresolvable host %s\n", w);
			return (0);
		}
		if (!*w)
			rdr->smask = 0xFFFFFFFF;
		else if (*w == '/')
			rdr->smask = rule_mask(next_number(&w));
		else {
			error(n, "expected /, get '%c'\n", *w);
			return (0);
		}
		w = next_word(&l);
	}

	/* proto (default is tcp) */
	if (!strcmp(w, "proto")) {
		w = next_word(&l);
		if (!strcmp(w, "tcp"))
			rdr->proto = IPPROTO_TCP;
		else if (!strcmp(w, "udp"))
			rdr->proto = IPPROTO_UDP;
		else {
			error(n, "expected tcp/udp, got %s\n", w);
			return (0);
		}
		w = next_word(&l);
	} else
		rdr->proto = IPPROTO_TCP;

	/* external addr/mask */
	if (strcmp(w, "to")) {
		error(n, "expected to, got %s\n", w);
		return (0);
	}
	w = next_word(&l);
	if (!strcmp(w, "any"))
		w = next_word(&l);
	else {
		if (!strcmp(w, "!")) {
			rdr->dnot = 1;
			w = next_word(&l);
		}
		if (!next_addr(&w, &rdr->daddr)) {
			error(n, "unresolvable host %s\n", w);
			return (0);
		}
		if (!*w)
			rdr->dmask = 0xFFFFFFFF;
		else if (*w == '/')
			rdr->dmask = rule_mask(next_number(&w));
		else {
			error(n, "expected /, get '%c'\n", *w);
			return (0);
		}
		w = next_word(&l);
	}

	/* external port (range) */
	if (strcmp(w, "port")) {
		error(n, "expected port, got %s\n", w);
		return (0);
	}
	w = next_word(&l);
	/* check for port range */
	if ((s = strchr(w, ':')) == NULL) {
		if (!rule_port(w, rdr->proto, &rdr->dport)) {
			error(n, "invalid destination port '%s'\n", w);
			return (0);
		}
		rdr->dport2 = rdr->dport;
	} else {
		*s++ = '\0';
		if (!rule_port(w, rdr->proto, &rdr->dport)) {
			error(n, "invalid destination port '%s'\n", w);
			return (0);
		}
		if (!rule_port(s, rdr->proto, &rdr->dport2)) {
			error(n, "invalid destination port '%s'\n", s);
			return (0);
		}
		rdr->opts |= PF_DPORT_RANGE;
	}
	w = next_word(&l);

	/* -> */
	if (strcmp(w, "->")) {
		error(n, "expected ->, got %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* internal addr */
	if (!next_addr(&w, &rdr->raddr)) {
		error(n, "unresolvable host %s\n", w);
		return (0);
	}
	w = next_word(&l);

	/* internal port */
	if (strcmp(w, "port")) {
		error(n, "expected port, got %s\n", w);
		return (0);
	}
	w = next_word(&l);
	/* check if redirected port is a range */
	if ((s = strchr(w, ':')) != NULL) {
	        rdr->opts |= PF_RPORT_RANGE;
	}
		
	if (!rule_port(w, rdr->proto, &rdr->rport)) {
		error(n, "invalid port '%s'\n", w);
		return (0);
	}
	w = next_word(&l);

	/* no further options expected */
	while (*w) {
		error(n, "unexpected %s\n", w);
		w = next_word(&l);
	}

	return (1);
@


1.33
log
@Oops, we can't use 0 as next_addr()'s error return since 0.0.0.0 is
a valid address.  Instead I add a pointer to the result as a parameter
and return 0 on failure and 1 on success.
Also uses inet_pton() instead of inet_aton().
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.32 2001/07/10 03:03:44 millert Exp $ */
d62 1
a62 1
u_int16_t	 rule_port (char *, u_int8_t);
d662 2
a663 2
u_int16_t
rule_port(char *w, u_int8_t p)
d675 3
a677 1
		return (s->s_port);
d685 3
a687 1
	return (htons(ul));
d856 4
a859 1
			r->src.port[0] = rule_port(w, r->proto);
d868 4
a871 1
				r->src.port[1] = rule_port(w, r->proto);
d929 4
a932 1
			r->dst.port[0] = rule_port(w, r->proto);
d941 4
a944 1
				r->dst.port[1] = rule_port(w, r->proto);
d1271 4
a1274 1
		rdr->dport = rule_port(w, rdr->proto);
d1278 8
a1285 2
		rdr->dport = rule_port(w, rdr->proto);
		rdr->dport2 = rule_port(s, rdr->proto);
d1315 4
a1318 1
	rdr->rport = rule_port(w, rdr->proto);
@


1.32
log
@Resolve as a host name if not an IP address; dhartmei@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.31 2001/07/10 00:07:21 millert Exp $ */
d59 1
a60 1
u_int32_t	 next_addr (char **);
d626 2
a627 2
u_int32_t
next_addr(char **w)
a628 1
	struct in_addr ia;
d634 1
a634 1
	if (inet_aton(*w, &ia) != 1) {
d637 1
a637 1
		memcpy(&ia.s_addr, hp->h_addr, sizeof(ia.s_addr));
d644 1
a644 1
	return(ia.s_addr);
d814 1
a814 2
			r->src.addr = next_addr(&w);
			if (r->src.addr == 0) {
d881 1
a881 2
			r->dst.addr = next_addr(&w);
			if (r->dst.addr == 0) {
d1084 1
a1084 2
		nat->saddr = next_addr(&w);
		if (nat->saddr == 0) {
d1112 1
a1112 2
		nat->daddr = next_addr(&w);
		if (nat->daddr == 0) {
d1135 1
a1135 2
	nat->raddr = next_addr(&w);
	if (nat->raddr == 0) {
d1189 1
a1189 2
		rdr->saddr = next_addr(&w);
		if (rdr->saddr == 0) {
d1232 1
a1232 2
		rdr->daddr = next_addr(&w);
		if (rdr->daddr == 0) {
d1273 1
a1273 2
	rdr->raddr = next_addr(&w);
	if (rdr->raddr == 0) {
@


1.31
log
@move "proto" in the nat case as well
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.30 2001/07/09 23:20:45 millert Exp $ */
d41 1
d629 17
a645 6
	u_int8_t a, b, c, d;
	a = next_number(w);
	b = next_number(w);
	c = next_number(w);
	d = next_number(w);
	return (htonl((a << 24) | (b << 16) | (c << 8) | d));
d816 4
d884 4
d1088 4
d1117 4
d1141 4
d1196 4
d1240 4
d1282 4
@


1.30
log
@Move the proto field to be after the "on" argument which is consistent
with pf.conf.  If no proto is specified tcp is assumed.
dhartmei@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.29 2001/07/09 10:30:58 dhartmei Exp $ */
d1038 16
a1113 16

	/* proto */
	if (!strcmp(w, "proto")) {
		w = next_word(&l);
		if (!strcmp(w, "tcp"))
			nat->proto = IPPROTO_TCP;
		else if (!strcmp(w, "udp"))
			nat->proto = IPPROTO_UDP;
		else if (!strcmp(w, "icmp"))
			nat->proto = IPPROTO_ICMP;
		else {
			error(n, "expected tcp/udp/icmp, got %s\n", w);
			return (0);
		}
		w = next_word(&l);
	}
@


1.29
log
@Extend nat/rdr syntax. Add source/destination selection. Make
interface optional. Suggested by rdump@@river.com.

nat [on [!] <ifname>] from (any | [!] <addr>[/<mask>]) to (any |
    [!] <addr>[/<mask>]) -> <addr> [proto (tcp | udp | icmp)]

rdr [on [!] <ifname>] from (any | [!] <addr>[/<mask>]) to (any |
    [!] <addr>[/<mask>]) port <a>[:<b>] -> <addr> port <c>[:*]
    [proto (tcp | udp | icmp)]
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.28 2001/07/06 21:19:54 chris Exp $ */
d323 8
a363 9
	printf(" ");
	switch (r->proto) {
	case IPPROTO_TCP:
		printf("proto tcp");
		break;
	case IPPROTO_UDP:
		printf("proto udp");
		break;
	}
d1175 15
d1223 1
a1223 1
		rdr->dport = htons(next_number(&w));
d1227 2
a1228 2
		rdr->dport = htons(next_number(&w));
		rdr->dport2 = htons(next_number(&s));
d1255 1
a1255 1
	rdr->rport = htons(next_number(&w));
a1256 14

	/* proto */
	if (!strcmp(w, "proto")) {
		w = next_word(&l);
		if (!strcmp(w, "tcp"))
			rdr->proto = IPPROTO_TCP;
		else if (!strcmp(w, "udp"))
			rdr->proto = IPPROTO_UDP;
		else {
			error(n, "expected tcp/udp, got %s\n", w);
			return (0);
		}
		w = next_word(&l);
	}
@


1.28
log
@Allow negative match on interface name for nat and rdr
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.27 2001/07/04 23:45:40 deraadt Exp $ */
d266 33
a298 12
	if (n->ifnot)
		printf("! ");
	printf("%s ", n->ifname);
	if (n->not)
		printf("! ");
	print_addr(n->saddr);
	if (n->smask != 0xFFFFFFFF) {
		printf("/");
		print_addr(n->smask);
	}
	printf(" -> ");
	print_addr(n->daddr);
d301 1
a301 1
		printf(" proto tcp");
d304 1
a304 1
		printf(" proto udp");
d307 1
a307 1
		printf(" proto icmp");
d317 31
a347 11
	if (r->ifnot)
		printf("! ");
	printf("%s ", r->ifname);
	if (r->not)
		printf("! ");
	print_addr(r->daddr);
	if (r->dmask != 0xFFFFFFFF) {
		printf("/");
		print_addr(r->dmask);
	}
	printf(" port %u", ntohs(r->dport));
d352 2
a353 1
	printf(" port %u", ntohs(r->rport));
d356 1
d359 1
a359 1
		printf(" proto tcp");
d362 1
a362 1
		printf(" proto udp");
d1028 8
a1035 3
	/* if */
	if (!strcmp(w, "!")) {
		nat->ifnot = 1;
d1038 6
a1043 1
	strncpy(nat->ifname, w, 16);
d1045 16
a1060 4

	/* internal addr/mask */
	if (!strcmp(w, "!")) {
		nat->not = 1;
d1063 4
a1066 7
	nat->saddr = next_addr(&w);
	if (!*w)
		nat->smask = 0xFFFFFFFF;
	else if (*w == '/')
		nat->smask = rule_mask(next_number(&w));
	else {
		error(n, "expected /, got '%c'\n", *w);
d1070 18
d1097 1
a1097 1
	nat->daddr = next_addr(&w);
d1140 8
a1147 3
	/* if */
	if (!strcmp(w, "!")) {
		rdr->ifnot = 1;
d1150 6
a1155 1
	strncpy(rdr->ifname, w, 16);
d1157 18
d1177 6
a1182 2
	if (!strcmp(w, "!")) {
		rdr->not = 1;
a1183 6
	}
	rdr->daddr = next_addr(&w);
	if (!*w)
		rdr->dmask = 0xFFFFFFFF;
	else if (*w == '/')
		rdr->dmask = rule_mask(next_number(&w));
d1185 14
a1198 2
		error(n, "expected /, got '%c'\n", *w);
		return (0);
a1199 1
	w = next_word(&l);
d1201 1
a1201 1
	/* external port */
a1216 1

@


1.27
log
@cleaner
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.26 2001/07/04 21:10:43 wilfried Exp $ */
d265 4
a268 1
	printf("nat %s ", n->ifname);
d295 4
a298 1
	printf("rdr %s ", r->ifname);
d986 4
d1061 4
@


1.26
log
@add new icmp codes and types as symbolic names, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.25 2001/07/01 23:04:45 dhartmei Exp $ */
d329 11
a339 11
	printf("Status: %s  Time: %u  Since: %u\n", 
	       s->running ? "Enabled" : "Disabled",
	       t, s->since);
	printf("Bytes In: %llu  Bytes Out: %llu\n", 
	       s->bcounters[PF_IN], s->bcounters[PF_OUT]);
	printf("Inbound Packets: Passed: %llu  Dropped: %llu\n", 
	       s->pcounters[PF_IN][PF_PASS], 
	       s->pcounters[PF_IN][PF_DROP]);
	printf("Outbound Packets: Passed: %llu  Dropped: %llu\n", 
	       s->pcounters[PF_OUT][PF_PASS], 
	       s->pcounters[PF_OUT][PF_DROP]);
d343 2
a344 2
		printf("%30s %8lld\n", pf_fcounters[i],
		       s->fcounters[i]);
d347 2
a348 2
		printf("%30s %8lld\n", pf_reasons[i],
		       s->counters[i]);
d1109 1
a1109 1
	} 
@


1.25
log
@tag packets generated by pf (return-rst, return-icmp) so they are not filtered, use existing icmp_error() and ip_output(). ok dugsong@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.24 2001/07/01 17:16:02 kjell Exp $ */
d93 11
a103 1
	{ "maskrep",	ICMP_MASKREPLY }
d127 2
d133 4
a136 1
	{ "badlen",		ICMP_PARAMPROB,	ICMP_PARAMPROB_LENGTH }
@


1.24
log
@Add port ranges to the rdr directive. Connections can be redirected
to either a range of the same size, or a single port. Redirects
between ranges of different sizes are not supported. Eg:

rdr dc0 10.0.0.0/24 port 60000:61000 -> 127.0.0.1 port 65530:* proto udp
rdr xl0 0.0.0.0/0 port 6660:6669 -> 127.0.0.1 port 6667 proto tcp

This replaces the wildcard port patch (when port = 0), as it should no
longer be necessary. ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.23 2001/07/01 17:04:13 kjell Exp $ */
d408 1
a408 1
	else if (r->action == PF_DROP || r->action == PF_DROP_RST)
d410 17
a426 1
	else
a427 2
	if (r->action == 2)
		printf("return-rst ");
d643 26
a668 4
	/* return-rst */
	if ((r->action == PF_DROP) && !strcmp(w, "return-rst")) {
		r->action = PF_DROP_RST;
		w = next_word(&l);
@


1.23
log
@Always print filter statistics, even when the filter is disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.22 2001/06/29 00:27:48 dhartmei Exp $ */
d285 4
a288 1
	printf(" port %u -> ", ntohs(r->dport));
d291 2
d987 1
a987 1
	char *w;
d1025 11
a1035 1
	rdr->dport = htons(next_number(&w));
d1055 5
@


1.22
log
@fix counter/reason array usage
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.21 2001/06/28 21:54:43 provos Exp $ */
d309 20
a328 20
	printf("Time: %u Since: %u Running: %u\n", t, s->since, s->running);
	if (s->running) {
		printf("Bytes In: %llu  Bytes Out: %llu\n", 
		    s->bcounters[PF_IN], s->bcounters[PF_OUT]);
		printf("Inbound Packets: Passed: %llu Dropped: %llu\n", 
		    s->pcounters[PF_IN][PF_PASS], 
		    s->pcounters[PF_IN][PF_DROP]);
		printf("Outbound Packets: Passed: %llu Dropped: %llu\n", 
		    s->pcounters[PF_OUT][PF_PASS], 
		    s->pcounters[PF_OUT][PF_DROP]);
		printf("States: %u\n", s->states);
		printf("pf Counters\n");
		for (i = 0; i < FCNT_MAX; i++)
			printf("%30s %8lld\n", pf_fcounters[i],
			    s->fcounters[i]);
		printf("Counters\n");
		for (i = 0; i < PFRES_MAX; i++)
			printf("%30s %8lld\n", pf_reasons[i],
			    s->counters[i]);
	}
@


1.21
log
@support scrub directive.  somebody please please BNF yaccify this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.20 2001/06/27 20:47:46 dhartmei Exp $ */
d299 2
a300 2
char *pf_reasons[PFRES_MAX+2] = PFRES_NAMES;
char *pf_fcounters[FCNT_MAX+2] = FCNT_NAMES;
d321 1
a321 1
		for (i = 0; i < PFRES_MAX; i++)
@


1.20
log
@print inbound packets passed correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.19 2001/06/27 04:29:21 deraadt Exp $ */
d401 1
a401 1
	if (r->action == 0)
d403 2
d406 1
a406 1
		printf("block ");
d613 1
a613 1
		r->action = 0;
d615 3
a617 1
		r->action = 1;
d619 1
a619 1
		error(n, "expected pass/block, got %s\n", w);
d625 2
a626 2
	if ((r->action == 1) && !strcmp(w, "return-rst")) {
		r->action = 2;
d652 4
d711 3
d748 2
d775 3
d811 1
d820 1
a820 1
		if (r->proto != IPPROTO_TCP) {
d833 1
a833 1
		if (r->proto != IPPROTO_ICMP) {
d888 1
a888 1
	if (!strcmp(w, "keep")) {
@


1.19
log
@state counter changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.18 2001/06/27 02:45:58 provos Exp $ */
d314 1
a314 1
		    s->pcounters[PF_IN][PF_DROP], 
@


1.18
log
@make it understand protocol numbers, too
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.17 2001/06/26 22:56:01 dugsong Exp $ */
d300 1
d311 13
a323 11
		printf("Bytes In: %u  Bytes Out: %u\n", 
		    s->bytes[PF_IN], s->bytes[PF_OUT]);
		printf("Inbound Packets: Passed: %u Dropped: %u\n", 
		    s->packets[PF_IN][PF_DROP], 
		    s->packets[PF_IN][PF_DROP]);
		printf("Outbound Packets: Passed: %u Dropped: %u\n", 
		    s->packets[PF_OUT][PF_PASS], 
		    s->packets[PF_OUT][PF_DROP]);
		printf("States: %u  Inserts: %u Removals: %u Searches: %u\n",
		    s->states, s->state_inserts,
		    s->state_removals, s->state_searches);
@


1.17
log
@name comparison operators
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.16 2001/06/26 22:36:28 dhartmei Exp $ */
d661 5
@


1.16
log
@int -> unsigned, so -Wall is happy
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.15 2001/06/26 22:26:15 deraadt Exp $ */
d215 1
a215 1
	if (op == 1)
d217 1
a217 1
	else if (op == 2) {
d222 1
a222 1
	} else if (op == 3) {
d227 1
a227 1
	} else if (op == 4)
d229 1
a229 1
	else if (op == 5)
d231 1
a231 1
	else if (op == 6)
d233 1
a233 1
	else
d700 1
a700 1
				r->src.port_op = 2;
d702 1
a702 1
				r->src.port_op = 3;
d704 1
a704 1
				r->src.port_op = 4;
d706 1
a706 1
				r->src.port_op = 5;
d708 1
a708 1
				r->src.port_op = 6;
d710 1
a710 1
				r->src.port_op = 7;
d712 1
a712 1
				r->src.port_op = 1;
d717 1
a717 1
			if (r->src.port_op == 1) {
d759 1
a759 1
				r->dst.port_op = 2;
d761 1
a761 1
				r->dst.port_op = 3;
d763 1
a763 1
				r->dst.port_op = 4;
d765 1
a765 1
				r->dst.port_op = 5;
d767 1
a767 1
				r->dst.port_op = 6;
d769 1
a769 1
				r->dst.port_op = 7;
d771 2
a772 2
				r->dst.port_op = 1;
			if (r->dst.port_op != 1)
d776 1
a776 1
			if (r->dst.port_op == 1) {
@


1.15
log
@array of counters indexed by reason codes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.14 2001/06/26 20:50:26 dhartmei Exp $ */
d140 1
a140 1
	int i;
d152 1
a152 1
	int i;
d164 1
a164 1
	int i;
d176 1
a176 1
	int i;
@


1.14
log
@add rule nr for Niels
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.13 2001/06/26 19:43:15 dhartmei Exp $ */
d299 2
d304 1
d306 1
d308 1
a308 1
	printf("Time: %u Since: %u Running: %u", t, s->since, s->running);
d310 15
a324 11
		printf(" Bytes In: %u  Bytes Out: %u\n", 
		       s->bytes[PF_IN], s->bytes[PF_OUT]);
		printf(" Inbound Packets: Passed: %u Dropped: %u\n", 
		       s->packets[PF_IN][PF_DROP], 
		       s->packets[PF_IN][PF_DROP]);
		printf(" Outbound Packets: Passed: %u Dropped: %u\n", 
		       s->packets[PF_OUT][PF_PASS], 
		       s->packets[PF_OUT][PF_DROP]);
		printf(" States: %u  Inserts: %u Removals: %u Searches: %u", 
		       s->states, s->state_inserts,
		       s->state_removals, s->state_searches);
a325 1
	printf("\n");
@


1.13
log
@add rule pointer and log option to states
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.12 2001/06/26 18:18:58 kjell Exp $ */
d390 1
@


1.12
log
@Print statistics in a human readable format. ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.11 2001/06/26 15:29:05 wilfried Exp $ */
d400 1
a400 1
	if (r->log)
d402 2
d629 3
@


1.11
log
@symbolic names for icmp-type and codes, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.10 2001/06/26 12:47:10 dhartmei Exp $ */
d304 1
a304 1
	printf("%u %u %u", t, s->since, s->running);
d306 11
a316 5
		printf(" %u %u", s->bytes[0], s->bytes[1]);
		printf(" %u %u", s->packets[0][0], s->packets[0][1]);
		printf(" %u %u", s->packets[1][0], s->packets[1][1]);
		printf(" %u %u %u %u", s->states, s->state_inserts,
		    s->state_removals, s->state_searches);
@


1.10
log
@add space after line number; wilfried@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.9 2001/06/26 12:27:14 wilfried Exp $ */
d66 58
d137 48
d453 18
a470 4
	if (r->type)
		printf("icmp-type %u ", r->type-1);
	if (r->code)
		printf("code %u ", r->code-1);
d800 10
a809 2
			if (w[0] == '\0' || *ep != '\0' ||
			    (errno == ERANGE && ul == ULONG_MAX) ||
d822 10
a831 2
				if ((w[0] == '\0' || *ep != '\0') ||
				    (errno == ERANGE && ul == ULONG_MAX) ||
d836 1
a837 1
				r->code = ul + 1;
@


1.9
log
@allow 0.0.0.0/x in rules
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.8 2001/06/25 10:15:55 deraadt Exp $ */
d73 1
a73 1
	fprintf(stderr, "%s: line %d", __progname, n);
@


1.8
log
@more sync against kernel changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.7 2001/06/25 10:14:07 deraadt Exp $ */
d301 1
a301 1
	if (!r->src.addr && !r->src.port_op && !r->dst.addr && !r->dst.port_op)
d305 1
a305 1
		if (!r->src.addr)
d323 1
a323 1
		if (!r->dst.addr)
@


1.7
log
@catch up, might have introduced bugs, but there is a next pass...
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.6 2001/06/25 09:44:32 deraadt Exp $ */
d53 2
a54 2
void		 print_host (struct state_host *);
void		 print_seq (struct state_peer *);
d87 1
a87 1
print_host(struct state_host *h)
d96 1
a96 1
print_seq(struct state_peer *p)
d212 1
a212 1
	struct state_peer *src, *dst;
@


1.6
log
@catch up to Art changes in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.5 2001/06/25 05:00:58 smart Exp $ */
d37 3
d47 2
d66 13
d432 2
d435 9
a443 4
	if (isdigit(*w))
		return (htons(atoi(w)));
	s = getservbyname(w, p == IPPROTO_TCP ? "tcp" : "udp");
	if (s == NULL)
d445 5
a449 1
	return (s->s_port);
d476 1
a476 2
		fprintf(stderr, "error on line %d: expected pass/block, got %s\n",
		    n, w);
d493 1
a493 2
		fprintf(stderr, "error on line %d: expected in/out, got %s\n",
		    n, w);
d523 1
a523 2
			fprintf(stderr, "error on line %d: unknown protocol %s\n",
			    n, w);
d550 1
a550 1
				fprintf(stderr, "error on line %d: expected /, got '%c'\n", n, *w);
d580 2
a581 1
					fprintf(stderr, "error on line %d: expected <>/><, got %s\n", n, w);
d592 1
a592 2
			fprintf(stderr, "error on line %d: expected to, got %s\n",
			    n, w);
d609 1
a609 1
				fprintf(stderr, "error on line %d: expected /, got '%c'\n", n, *w);
d639 2
a640 1
					fprintf(stderr, "error on line %d: expected <>/><, got %s\n", n, w);
d649 2
a650 4
	}
	else {
		fprintf(stderr, "error on line %d: expected all/from, got %s\n",
		    n, w);
d657 1
a657 1
			fprintf(stderr, "error on line %d: flags only valid for proto tcp\n", n);
d659 1
a659 2
		}
		else {
d670 1
a670 2
			fprintf(stderr,
			    "error on line %d: icmp-type only valid for proto icmp\n", n);
d672 4
a675 2
		}
		else {
d677 11
a687 1
			r->type = atoi(w)+1;
d691 11
a701 1
				r->code = atoi(w) + 1;
d713 2
a714 3
		}
		else {
			fprintf(stderr, "error on line %d: expected state, got %s\n", n, w);
d721 1
a721 1
		fprintf(stderr, "error on line %d: unexpected %s\n", n, w);
d738 1
a738 2
		fprintf(stderr,
		    "error on line %d: expected nat, got %s\n", n, w);
d758 1
a758 2
		fprintf(stderr,
		    "error on line %d: expected /, got '%c'\n", n, *w);
d765 1
a765 2
		fprintf(stderr,
		    "error on line %d: expected ->, got %s\n", n, w);
d784 1
a784 3
			fprintf(stderr,
			 "error on line %d: expected tcp/udp/icmp, got %s\n",
			    n, w);
d792 1
a792 1
		fprintf(stderr, "error on line %d: unexpected %s\n", n, w);
d809 1
a809 2
		fprintf(stderr,
		    "error on line %d: expected rdr, got %s\n", n, w);
d829 1
a829 2
		fprintf(stderr,
		    "error on line %d: expected /, got '%c'\n", n, *w);
d836 1
a836 1
		fprintf(stderr, "error on line %d: expected port, got %s\n", n, w);
d845 1
a845 2
		fprintf(stderr,
		    "error on line %d: expected ->, got %s\n", n, w);
d856 1
a856 2
		fprintf(stderr,
		    "error on line %d: expected port, got %s\n", n, w);
d871 1
a871 3
			fprintf(stderr,
			 "error on line %d: expected tcp/udp, got %s\n",
			    n, w);
d879 1
a879 1
		fprintf(stderr, "error on line %d: unexpected %s\n", n, w);
@


1.5
log
@Replace magic numbers 1, 6, and 17 with IPPROTO_{ICMP,UDP,TCP}.  deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.4 2001/06/24 23:24:15 provos Exp $ */
d47 11
a57 11
static void		 print_addr (u_int32_t);
static void		 print_host (struct state_host *);
static void		 print_seq (struct state_peer *);
static void		 print_port (u_int8_t, u_int16_t, u_int16_t, char *);
static void		 print_flags (u_int8_t);
static char		*next_word (char **);
static u_int16_t	 next_number (char **);
static u_int32_t	 next_addr (char **);
static u_int8_t		 next_flags (char **);
static u_int16_t	 rule_port (char *, u_int8_t);
static u_int32_t	 rule_mask (u_int8_t);
d59 1
a59 1
static char *tcpflags = "FSRPAU";
d61 1
a61 1
static void
d68 1
a68 1
static void
d73 1
d77 1
a77 1
static void
d83 1
a83 1
static void
d87 1
d98 1
a98 2
	}
	else if (op == 3) {
d103 1
a103 2
	}
	else if (op == 4)
d113 1
a113 1
static void
d117 1
d124 1
a124 1
print_nat(struct nat *n)
d151 1
a151 1
print_rdr(struct rdr *r)
d176 1
a176 1
print_status(struct status *s)
d179 1
d192 1
a192 1
print_state(struct state *s)
d258 1
a258 1
print_rule(struct rule *r)
d341 2
a342 2
	char *l;
	l = *s;
d352 1
a352 1
static char *
d356 1
d369 1
a369 1
static u_int16_t
d373 1
d384 1
a384 1
static u_int32_t
d395 1
a395 1
static u_int8_t
d400 1
d410 1
a410 1
static u_int16_t
d414 1
d423 1
a423 1
static u_int32_t
d428 1
d435 1
a435 1
parse_rule(int n, char *l, struct rule *r)
d438 1
a438 1
	memset(r, 0, sizeof(struct rule));
d447 1
a447 1
		fprintf(stderr, "error on line %i: expected pass/block, got %s\n",
d465 1
a465 1
		fprintf(stderr, "error on line %i: expected in/out, got %s\n",
d496 1
a496 1
			fprintf(stderr, "error on line %i: unknown protocol %s\n",
d524 1
a524 1
				fprintf(stderr, "error on line %i: expected /, got '%c'\n", n, *w);
d554 1
a554 1
					fprintf(stderr, "error on line %i: expected <>/><, got %s\n", n, w);
d565 1
a565 1
			fprintf(stderr, "error on line %i: expected to, got %s\n",
d583 1
a583 1
				fprintf(stderr, "error on line %i: expected /, got '%c'\n", n, *w);
d613 1
a613 1
					fprintf(stderr, "error on line %i: expected <>/><, got %s\n", n, w);
d624 1
a624 1
		fprintf(stderr, "error on line %i: expected all/from, got %s\n",
d632 1
a632 1
			fprintf(stderr, "error on line %i: flags only valid for proto tcp\n", n);
d646 2
a647 1
			fprintf(stderr, "error on line %i: icmp-type only valid for proto icmp\n", n);
d670 1
a670 1
			fprintf(stderr, "error on line %i: expected state, got %s\n", n, w);
d677 1
a677 1
		fprintf(stderr, "error on line %i: unexpected %s\n", n, w);
d685 1
a685 1
parse_nat(int n, char *l, struct nat *nat)
d688 2
a689 1
	memset(nat, 0, sizeof(struct nat));
d694 2
a695 1
		fprintf(stderr, "error on line %i: expected nat, got %s\n", n, w);
d715 2
a716 1
		fprintf(stderr, "error on line %i: expected /, got '%c'\n", n, *w);
d723 2
a724 1
		fprintf(stderr, "error on line %i: expected ->, got %s\n", n, w);
d744 1
a744 1
			 "error on line %i: expected tcp/udp/icmp, got %s\n",
d753 1
a753 1
		fprintf(stderr, "error on line %i: unexpected %s\n", n, w);
d761 1
a761 1
parse_rdr(int n, char *l, struct rdr *rdr)
d764 2
a765 1
	memset(rdr, 0, sizeof(struct rdr));
d770 2
a771 1
		fprintf(stderr, "error on line %i: expected rdr, got %s\n", n, w);
d791 2
a792 1
		fprintf(stderr, "error on line %i: expected /, got '%c'\n", n, *w);
d799 1
a799 1
		fprintf(stderr, "error on line %i: expected port, got %s\n", n, w);
d808 2
a809 1
		fprintf(stderr, "error on line %i: expected ->, got %s\n", n, w);
d820 2
a821 1
		fprintf(stderr, "error on line %i: expected port, got %s\n", n, w);
d837 1
a837 1
			 "error on line %i: expected tcp/udp, got %s\n",
d846 1
a846 1
		fprintf(stderr, "error on line %i: unexpected %s\n", n, w);
a851 1

@


1.4
log
@some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.3 2001/06/24 23:16:36 deraadt Exp $ */
d299 2
a300 1
			    r->src.port[1], r->proto == 6 ? "tcp" : "udp");
d317 2
a318 1
			    r->dst.port[1], r->proto == 6 ? "tcp" : "udp");
d411 1
a411 1
	s = getservbyname(w, p == 6 ? "tcp" : "udp");
d524 2
a525 1
		if (((r->proto == 6) || (r->proto == 17)) && !strcmp(w, "port")) {
d583 2
a584 1
		if (((r->proto == 6) || (r->proto == 17)) && !strcmp(w, "port")) {
d624 1
a624 1
		if (r->proto != 6) {
d638 1
a638 1
		if (r->proto != 1) {
@


1.3
log
@match changes in header files
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.2 2001/06/24 21:40:51 dhartmei Exp $ */
d345 1
a345 1
	return l;
d361 1
a361 1
	return w;
d375 1
a375 1
	return n;
d386 1
a386 1
	return htonl((a << 24) | (b << 16) | (c << 8) | d);
d400 1
a400 1
	return f ? f : 63;
d408 1
a408 1
		return htons(atoi(w));
d411 2
a412 2
		return 0;
	return s->s_port;
d422 1
a422 1
	return htonl(m);
d440 1
a440 1
		return 0;
d458 1
a458 1
		return 0;
d489 1
a489 1
			return 0;
d516 1
a516 1
				return 0;
d545 1
a545 1
					return 0;
d557 1
a557 1
			return 0;
d574 1
a574 1
				return 0;
d603 1
a603 1
					return 0;
d615 1
a615 1
		return 0;
d622 1
a622 1
			return 0;
d636 1
a636 1
			return 0;
d659 1
a659 1
			return 0;
d669 1
a669 1
	return 1;
d682 1
a682 1
		return 0;
d702 1
a702 1
		return 0;
d709 1
a709 1
		return 0;
d730 1
a730 1
			return 0;
d741 1
a741 1
	return 1;
d754 1
a754 1
		return 0;
d774 1
a774 1
		return 0;
d781 1
a781 1
		return 0;
d790 1
a790 1
		return 0;
d801 1
a801 1
		return 0;
d818 1
a818 1
			return 0;
d829 1
a829 1
	return 1;
@


1.2
log
@REGENTS -> COPYRIGHT HOLDERS
@
text
@d1 1
a1 1
/*	$OpenBSD: pfctl_parser.c,v 1.1 2001/06/24 21:04:16 kjell Exp $ */
d33 6
a43 1
#include <netinet/in.h>
d48 2
a49 2
static void		 print_host (struct host *);
static void		 print_seq (struct peer *);
d69 1
a69 1
print_host(struct host *h)
d77 1
a77 1
print_seq(struct peer *p)
d192 1
a192 1
	struct peer *src, *dst;
d194 1
@


1.1
log
@Move and rename packet filter userland.
grr. CVS: making easy things difficult, and directory operations impossible.
@
text
@d1 1
a1 1
/*	$OpenBSD: pfm_parser.c,v 1.1 2001/06/24 20:18:12 kjell Exp $ */
d22 1
a22 1
 * REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
@

