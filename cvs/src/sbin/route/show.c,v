head	1.108;
access;
symbols
	OPENBSD_6_2_BASE:1.108
	OPENBSD_6_1:1.108.0.4
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.104.0.2
	OPENBSD_6_0_BASE:1.104
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.100.0.4
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.98.0.2
	OPENBSD_5_7_BASE:1.98
	OPENBSD_5_6:1.96.0.4
	OPENBSD_5_6_BASE:1.96
	OPENBSD_5_5:1.94.0.6
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.92.0.2
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.91.0.2
	OPENBSD_5_2_BASE:1.91
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.4
	OPENBSD_5_0:1.90.0.2
	OPENBSD_5_0_BASE:1.90
	OPENBSD_4_9:1.89.0.2
	OPENBSD_4_9_BASE:1.89
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.83.0.2
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.80.0.4
	OPENBSD_4_6_BASE:1.80
	OPENBSD_4_5:1.76.0.2
	OPENBSD_4_5_BASE:1.76
	OPENBSD_4_4:1.70.0.2
	OPENBSD_4_4_BASE:1.70
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.60.0.2
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.108
date	2016.12.13.08.40.54;	author mpi;	state Exp;
branches;
next	1.107;
commitid	FpLOfKi5ERXgAXWf;

1.107
date	2016.09.05.14.23.38;	author claudio;	state Exp;
branches;
next	1.106;
commitid	Kb3gZBRBnzStt0EP;

1.106
date	2016.09.03.14.23.14;	author phessler;	state Exp;
branches;
next	1.105;
commitid	rJW7JJ1v8NrTSfc8;

1.105
date	2016.09.01.09.41.34;	author bluhm;	state Exp;
branches;
next	1.104;
commitid	wRPxUwlIhFV2EtnL;

1.104
date	2016.07.13.08.40.46;	author mpi;	state Exp;
branches;
next	1.103;
commitid	VkTTZG0LgjCK3eLa;

1.103
date	2015.11.27.16.26.52;	author benno;	state Exp;
branches;
next	1.102;
commitid	cZfr9cdXdoYfPoYx;

1.102
date	2015.10.23.15.03.25;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	vdJ8Vo9zOOLy1pir;

1.101
date	2015.09.11.20.08.40;	author mpi;	state Exp;
branches;
next	1.100;
commitid	5Sr0XPH2svtKebAw;

1.100
date	2015.07.18.00.05.02;	author phessler;	state Exp;
branches;
next	1.99;
commitid	w4H9LC8cbuDZ9nOJ;

1.99
date	2015.04.27.09.51.58;	author benno;	state Exp;
branches;
next	1.98;
commitid	vluGrLJOODO5Tnu9;

1.98
date	2015.02.06.03.22.00;	author reyk;	state Exp;
branches;
next	1.97;
commitid	2ShTul7wSa8iiu5L;

1.97
date	2015.01.16.06.40.00;	author deraadt;	state Exp;
branches;
next	1.96;
commitid	Uu5nFG3wCl0LACBb;

1.96
date	2014.05.08.09.28.08;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2014.04.17.15.35.35;	author claudio;	state Exp;
branches;
next	1.94;

1.94
date	2013.07.19.20.10.23;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.21.04.43.17;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2012.12.04.02.30.33;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2012.03.17.10.16.40;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2011.07.09.00.45.40;	author henning;	state Exp;
branches;
next	1.89;

1.89
date	2010.10.11.11.45.00;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.21.10.58.23;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.29.16.35.40;	author bluhm;	state Exp;
branches;
next	1.86;

1.86
date	2010.05.19.13.07.15;	author chl;	state Exp;
branches;
next	1.85;

1.85
date	2010.03.23.15.08.51;	author claudio;	state Exp;
branches;
next	1.84;

1.84
date	2010.03.23.15.01.50;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2010.01.13.23.49.06;	author claudio;	state Exp;
branches;
next	1.82;

1.82
date	2010.01.11.08.26.29;	author dlg;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.07.09.09.31;	author martynas;	state Exp;
branches;
next	1.80;

1.80
date	2009.06.27.11.35.57;	author michele;	state Exp;
branches;
next	1.79;

1.79
date	2009.05.31.18.02.28;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2009.05.23.16.44.12;	author chris;	state Exp;
branches;
next	1.77;

1.77
date	2009.04.28.12.09.35;	author michele;	state Exp;
branches;
next	1.76;

1.76
date	2009.02.03.16.44.15;	author michele;	state Exp;
branches;
next	1.75;

1.75
date	2009.01.26.17.18.47;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2009.01.08.12.52.36;	author michele;	state Exp;
branches;
next	1.73;

1.73
date	2008.12.15.16.14.57;	author michele;	state Exp;
branches;
next	1.72;

1.72
date	2008.12.12.20.26.30;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2008.09.15.20.12.11;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2008.05.25.17.57.42;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2008.05.08.07.10.51;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.08.06.13.09;	author norby;	state Exp;
branches;
next	1.67;

1.67
date	2008.05.08.05.41.59;	author norby;	state Exp;
branches;
next	1.66;

1.66
date	2008.05.07.06.06.25;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2008.05.06.03.44.14;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2008.05.06.03.39.09;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2008.04.30.12.43.23;	author norby;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.28.11.36.14;	author norby;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.05.20.30.21;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2007.07.24.20.22.23;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.21.15.43.01;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.04.12.23.44;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2007.03.23.16.02.26;	author pyr;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.29.10.04.36;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2006.06.16.17.46.43;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.30.19.42.58;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.27.18.26.45;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.27.18.20.59;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2006.03.31.15.56.25;	author hshoexer;	state Exp;
branches;
next	1.49;

1.49
date	2006.03.30.13.58.30;	author hshoexer;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.30.12.11.37;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.30.09.57.35;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2006.03.29.20.21.45;	author hshoexer;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.23.13.38.27;	author mcbride;	state Exp;
branches;
next	1.44;

1.44
date	2006.02.01.19.00.22;	author otto;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.27.04.55.27;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.30.05.40.55;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.30.05.34.30;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2005.02.18.04.00.21;	author jaredy;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.17.01.47.20;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.14.15.20.56;	author jaredy;	state Exp;
branches;
next	1.37;

1.37
date	2004.09.24.01.24.30;	author jaredy;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.22.01.07.10;	author jaredy;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.21.02.45.52;	author jaredy;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.15.23.41.42;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.05.02.19.03;	author pvalchev;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.25.01.26.01;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.16.11.47.35;	author cedric;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.15.17.10.32;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.15.16.55.38;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.12.09.40.49;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.06.17.08.23;	author cedric;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.26.08.33.12;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.02.21.44.58;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.26.16.35.21;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.20.06.16;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.13.09.09.27;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.16.21.27.37;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.07.18.26.20;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.15.01.45.48;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.24.01.02.24;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.27.20.12.25;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.14.19.59.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.10.01.35.06;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.10.01.04.20;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.10.00.54.35;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.09.23.00.13;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	99.12.20.07.45.09;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	99.12.08.07.55.54;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	99.09.22.05.10.04;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.02.24.22.56.02;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	98.09.21.08.31.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.07.09.01.32.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.12.08.03.55.25;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.02.02.10.57;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	97.08.26.13.50.44;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.06.24.03.15.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.12.14.17.23.55;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.108
log
@Print the correct netmask instead of /0 when flushing routes to networks.

Issue reported by jsing@@, ok stsp@@
@
text
@/*	$OpenBSD: show.c,v 1.107 2016/09/05 14:23:38 claudio Exp $	*/
/*	$NetBSD: show.c,v 1.1 1996/11/15 18:01:41 gwr Exp $	*/

/*
 * Copyright (c) 1983, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/socket.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netmpls/mpls.h>
#include <arpa/inet.h>

#include <err.h>
#include <errno.h>
#include <netdb.h>
#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <limits.h>

#include "show.h"

char	*any_ntoa(const struct sockaddr *);
char	*link_print(struct sockaddr *);
char	*label_print(struct sockaddr *);

#define ROUNDUP(a) \
	((a) > 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
#define ADVANCE(x, n) (x += ROUNDUP((n)->sa_len))

/*
 * Definitions for showing gateway flags.
 */
struct bits {
	int	b_mask;
	char	b_val;
};
static const struct bits bits[] = {
	{ RTF_UP,	'U' },
	{ RTF_GATEWAY,	'G' },
	{ RTF_HOST,	'H' },
	{ RTF_REJECT,	'R' },
	{ RTF_DYNAMIC,	'D' },
	{ RTF_MODIFIED,	'M' },
	{ RTF_DONE,	'd' }, /* Completed -- for routing messages only */
	{ RTF_CLONING,	'C' },
	{ RTF_MULTICAST,'m' },
	{ RTF_LLINFO,	'L' },
	{ RTF_STATIC,	'S' },
	{ RTF_BLACKHOLE,'B' },
	{ RTF_PROTO3,	'3' },
	{ RTF_PROTO2,	'2' },
	{ RTF_PROTO1,	'1' },
	{ RTF_CLONED,	'c' },
	{ RTF_CACHED,	'h' },
	{ RTF_MPATH,	'P' },
	{ RTF_MPLS,	'T' },
	{ RTF_LOCAL,	'l' },
	{ RTF_BFD,	'F' },
	{ RTF_BROADCAST,'b' },
	{ RTF_CONNECTED,'n' },
	{ 0 }
};

int	 WID_DST(int);
void	 pr_rthdr(int);
void	 p_rtentry(struct rt_msghdr *);
void	 pr_family(int);
void	 p_sockaddr_mpls(struct sockaddr *, struct sockaddr *, int, int);
void	 p_flags(int, char *);
char	*routename4(in_addr_t);
char	*routename6(struct sockaddr_in6 *);
char	*netname4(in_addr_t, struct sockaddr_in *);
char	*netname6(struct sockaddr_in6 *, struct sockaddr_in6 *);

/*
 * Print routing tables.
 */
void
p_rttables(int af, u_int tableid, int hastable, char prio)
{
	struct rt_msghdr *rtm;
	char *buf = NULL, *next, *lim = NULL;
	size_t needed;
	int mib[7], mcnt;
	struct sockaddr *sa;

	mib[0] = CTL_NET;
	mib[1] = PF_ROUTE;
	mib[2] = 0;
	mib[3] = af;
	mib[4] = NET_RT_DUMP;
	mib[5] = prio;
	if (hastable) {
		mib[6] = tableid;
		mcnt = 7;
	} else
		mcnt = 6;

	while (1) {
		if (sysctl(mib, mcnt, NULL, &needed, NULL, 0) == -1)
			err(1, "route-sysctl-estimate");
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, NULL);
		if (sysctl(mib, mcnt, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1, "sysctl of routing table");
		}
		lim = buf + needed;
		break;
	}

	if (pledge("stdio rpath dns", NULL) == -1)
		err(1, "pledge");

	printf("Routing tables\n");

	if (buf) {
		for (next = buf; next < lim; next += rtm->rtm_msglen) {
			rtm = (struct rt_msghdr *)next;
			if (rtm->rtm_version != RTM_VERSION)
				continue;
			sa = (struct sockaddr *)(next + rtm->rtm_hdrlen);
			p_rtentry(rtm);
		}
		free(buf);
		buf = NULL;
	}
}

/*
 * column widths; each followed by one space
 * width of destination/gateway column
 * strlen("fe80::aaaa:bbbb:cccc:dddd@@gif0") == 30, strlen("/128") == 4
 */
#define	WID_GW(af)	((af) == AF_INET6 ? (nflag ? 30 : 18) : 18)

int
WID_DST(int af)
{

	if (nflag)
		switch (af) {
		case AF_MPLS:
			return 9;
		case AF_INET6:
			return 34;
		default:
			return 18;
		}
	else
		switch (af) {
		case AF_MPLS:
			return 9;
 		default:
			return 18;
		}
}

/*
 * Print header for routing table columns.
 */
void
pr_rthdr(int af)
{
	switch (af) {
	case PF_KEY:
		printf("%-18s %-5s %-18s %-5s %-5s %-22s\n",
		    "Source", "Port", "Destination",
		    "Port", "Proto", "SA(Address/Proto/Type/Direction)");
		break;
	case PF_MPLS:
		printf("%-9s %-9s %-6s %-18s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s\n",
		    "In label", "Out label", "Op", "Gateway",
		    "Flags", "Refs", "Use", "Mtu", "Prio", "Interface");
		break;
	default:
		printf("%-*.*s %-*.*s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s",
		    WID_DST(af), WID_DST(af), "Destination",
		    WID_GW(af), WID_GW(af), "Gateway",
		    "Flags", "Refs", "Use", "Mtu", "Prio", "Iface");
		if (verbose)
			printf(" %s", "Label");
		putchar('\n');
		break;
	}
}

void
get_rtaddrs(int addrs, struct sockaddr *sa, struct sockaddr **rti_info)
{
	int	i;

	for (i = 0; i < RTAX_MAX; i++) {
		if (addrs & (1 << i)) {
			rti_info[i] = sa;
			sa = (struct sockaddr *)((char *)(sa) +
			    ROUNDUP(sa->sa_len));
		} else
			rti_info[i] = NULL;
	}
}

/*
 * Print a routing table entry.
 */
void
p_rtentry(struct rt_msghdr *rtm)
{
	static int	 old_af = -1;
	struct sockaddr	*sa = (struct sockaddr *)((char *)rtm + rtm->rtm_hdrlen);
	struct sockaddr	*mask, *rti_info[RTAX_MAX];
	char		 ifbuf[IF_NAMESIZE];
	char		*label;

	if (sa->sa_family == AF_KEY)
		return;

	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);

	if (Fflag && rti_info[RTAX_GATEWAY]->sa_family != sa->sa_family) {
		return;
	}

	if (strlen(so_label.rtlabel.sr_label)) {
		if (!rti_info[RTAX_LABEL])
			return;
		label = ((struct sockaddr_rtlabel *)rti_info[RTAX_LABEL])->
		    sr_label;
		if (strcmp(label, so_label.rtlabel.sr_label))
			return;
	}

	if (old_af != sa->sa_family) {
		old_af = sa->sa_family;
		pr_family(sa->sa_family);
		pr_rthdr(sa->sa_family);
	}

	mask = rti_info[RTAX_NETMASK];
	if ((sa = rti_info[RTAX_DST]) == NULL)
		return;

	p_sockaddr(sa, mask, rtm->rtm_flags, WID_DST(sa->sa_family));
	p_sockaddr_mpls(sa, rti_info[RTAX_SRC], rtm->rtm_mpls,
	    WID_DST(sa->sa_family));

	p_sockaddr(rti_info[RTAX_GATEWAY], NULL, RTF_HOST,
	    WID_GW(sa->sa_family));

	p_flags(rtm->rtm_flags, "%-6.6s ");
	printf("%5u %8llu ", rtm->rtm_rmx.rmx_refcnt,
	    rtm->rtm_rmx.rmx_pksent);
	if (rtm->rtm_rmx.rmx_mtu)
		printf("%5u ", rtm->rtm_rmx.rmx_mtu);
	else
		printf("%5s ", "-");
	putchar((rtm->rtm_rmx.rmx_locks & RTV_MTU) ? 'L' : ' ');
	printf("  %2d %-5.16s", rtm->rtm_priority,
	    if_indextoname(rtm->rtm_index, ifbuf));
	if (verbose && rti_info[RTAX_LABEL])
		printf(" %s", routename(rti_info[RTAX_LABEL]));
	putchar('\n');
}

/*
 * Print address family header before a section of the routing table.
 */
void
pr_family(int af)
{
	char *afname;

	switch (af) {
	case AF_INET:
		afname = "Internet";
		break;
	case AF_INET6:
		afname = "Internet6";
		break;
	case PF_KEY:
		afname = "Encap";
		break;
	case AF_MPLS:
		afname = "MPLS";
		break;
	default:
		afname = NULL;
		break;
	}
	if (afname)
		printf("\n%s:\n", afname);
	else
		printf("\nProtocol Family %d:\n", af);
}

void
p_sockaddr(struct sockaddr *sa, struct sockaddr *mask, int flags, int width)
{
	char *cp;

	switch (sa->sa_family) {
	case AF_INET6:
	    {
		struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;
		struct in6_addr *in6 = &sa6->sin6_addr;

		/*
		 * XXX: This is a special workaround for KAME kernels.
		 * sin6_scope_id field of SA should be set in the future.
		 */
		if (IN6_IS_ADDR_LINKLOCAL(in6) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(in6) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(in6)) {
			/* XXX: override is ok? */
			sa6->sin6_scope_id = (u_int32_t)ntohs(*(u_short *)
			    &in6->s6_addr[2]);
			*(u_short *)&in6->s6_addr[2] = 0;
		}
		if (flags & RTF_HOST)
			cp = routename((struct sockaddr *)sa6);
		else
			cp = netname((struct sockaddr *)sa6, mask);
		break;
	    }
	case AF_MPLS:
		return;
	default:
		if ((flags & RTF_HOST) || mask == NULL)
			cp = routename(sa);
		else
			cp = netname(sa, mask);
		break;
	}
	if (width < 0)
		printf("%s", cp);
	else {
		if (nflag)
			printf("%-*s ", width, cp);
		else
			printf("%-*.*s ", width, width, cp);
	}
}

static char line[HOST_NAME_MAX+1];
static char domain[HOST_NAME_MAX+1];

void
p_sockaddr_mpls(struct sockaddr *in, struct sockaddr *out, int flags, int width)
{
	if (in->sa_family != AF_MPLS)
		return;

	if (flags & MPLS_OP_POP || flags == MPLS_OP_LOCAL) {
		printf("%-*s ", width, label_print(in));
		printf("%-*s ", width, label_print(NULL));
	} else {
		printf("%-*s ", width, label_print(in));
		printf("%-*s ", width, label_print(out));
	}

	printf("%-6s ", mpls_op(flags));
}

void
p_flags(int f, char *format)
{
	char name[33], *flags;
	const struct bits *p = bits;

	for (flags = name; p->b_mask && flags < &name[sizeof(name) - 2]; p++)
		if (p->b_mask & f)
			*flags++ = p->b_val;
	*flags = '\0';
	printf(format, name);
}

char *
routename(struct sockaddr *sa)
{
	char *cp = NULL;
	static int first = 1;

	if (first) {
		first = 0;
		if (gethostname(domain, sizeof(domain)) == 0 &&
		    (cp = strchr(domain, '.')))
			(void)strlcpy(domain, cp + 1, sizeof(domain));
		else
			domain[0] = '\0';
		cp = NULL;
	}

	if (sa->sa_len == 0) {
		(void)strlcpy(line, "default", sizeof(line));
		return (line);
	}

	switch (sa->sa_family) {
	case AF_INET:
		return
		    (routename4(((struct sockaddr_in *)sa)->sin_addr.s_addr));

	case AF_INET6:
	    {
		struct sockaddr_in6 sin6;

		memset(&sin6, 0, sizeof(sin6));
		memcpy(&sin6, sa, sa->sa_len);
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_family = AF_INET6;
		if (sa->sa_len == sizeof(struct sockaddr_in6) &&
		    (IN6_IS_ADDR_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr) ||
		     IN6_IS_ADDR_MC_INTFACELOCAL(&sin6.sin6_addr)) &&
		    sin6.sin6_scope_id == 0) {
			sin6.sin6_scope_id =
			    ntohs(*(u_int16_t *)&sin6.sin6_addr.s6_addr[2]);
			sin6.sin6_addr.s6_addr[2] = 0;
			sin6.sin6_addr.s6_addr[3] = 0;
		}
		return (routename6(&sin6));
	    }

	case AF_LINK:
		return (link_print(sa));
	case AF_MPLS:
		return (label_print(sa));
	case AF_UNSPEC:
		if (sa->sa_len == sizeof(struct sockaddr_rtlabel)) {
			static char name[RTLABEL_LEN + 2];
			struct sockaddr_rtlabel *sr;

			sr = (struct sockaddr_rtlabel *)sa;
			snprintf(name, sizeof(name), "\"%s\"", sr->sr_label);
			return (name);
		}
		/* FALLTHROUGH */
	default:
		(void)snprintf(line, sizeof(line), "(%d) %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

char *
routename4(in_addr_t in)
{
	char		*cp = NULL;
	struct in_addr	 ina;
	struct hostent	*hp;

	if (in == INADDR_ANY)
		cp = "default";
	if (!cp && !nflag) {
		if ((hp = gethostbyaddr((char *)&in,
		    sizeof(in), AF_INET)) != NULL) {
			if ((cp = strchr(hp->h_name, '.')) &&
			    !strcmp(cp + 1, domain))
				*cp = '\0';
			cp = hp->h_name;
		}
	}
	ina.s_addr = in;
	strlcpy(line, cp ? cp : inet_ntoa(ina), sizeof(line));

	return (line);
}

char *
routename6(struct sockaddr_in6 *sin6)
{
	int	 niflags = 0;

	if (nflag)
		niflags |= NI_NUMERICHOST;
	else
		niflags |= NI_NOFQDN;

	if (getnameinfo((struct sockaddr *)sin6, sin6->sin6_len,
	    line, sizeof(line), NULL, 0, niflags) != 0)
		strncpy(line, "invalid", sizeof(line));

	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname4(in_addr_t in, struct sockaddr_in *maskp)
{
	char *cp = NULL;
	struct netent *np = NULL;
	in_addr_t mask;
	int mbits;

	in = ntohl(in);
	mask = maskp && maskp->sin_len != 0 ? ntohl(maskp->sin_addr.s_addr) : 0;
	if (!nflag && in != INADDR_ANY) {
		if ((np = getnetbyaddr(in, AF_INET)) != NULL)
			cp = np->n_name;
	}
	if (in == INADDR_ANY && mask == INADDR_ANY)
		cp = "default";
	mbits = mask ? 33 - ffs(mask) : 0;
	if (cp)
		strlcpy(line, cp, sizeof(line));
#define C(x)	((x) & 0xff)
	else if (mbits < 9)
		snprintf(line, sizeof(line), "%u/%d", C(in >> 24), mbits);
	else if (mbits < 17)
		snprintf(line, sizeof(line), "%u.%u/%d",
		    C(in >> 24) , C(in >> 16), mbits);
	else if (mbits < 25)
		snprintf(line, sizeof(line), "%u.%u.%u/%d",
		    C(in >> 24), C(in >> 16), C(in >> 8), mbits);
	else
		snprintf(line, sizeof(line), "%u.%u.%u.%u/%d", C(in >> 24),
		    C(in >> 16), C(in >> 8), C(in), mbits);
#undef C
	return (line);
}

char *
netname6(struct sockaddr_in6 *sa6, struct sockaddr_in6 *mask)
{
	struct sockaddr_in6 sin6;
	u_char *p;
	int masklen, final = 0, illegal = 0;
	int i, lim, flag, error;
	char hbuf[NI_MAXHOST];

	sin6 = *sa6;

	flag = 0;
	masklen = 0;
	if (mask) {
		lim = mask->sin6_len - offsetof(struct sockaddr_in6, sin6_addr);
		lim = lim < (int)sizeof(struct in6_addr) ?
		    lim : (int)sizeof(struct in6_addr);
		for (p = (u_char *)&mask->sin6_addr, i = 0; i < lim; p++) {
			if (final && *p) {
				illegal++;
				sin6.sin6_addr.s6_addr[i++] = 0x00;
				continue;
			}

			switch (*p & 0xff) {
			case 0xff:
				masklen += 8;
				break;
			case 0xfe:
				masklen += 7;
				final++;
				break;
			case 0xfc:
				masklen += 6;
				final++;
				break;
			case 0xf8:
				masklen += 5;
				final++;
				break;
			case 0xf0:
				masklen += 4;
				final++;
				break;
			case 0xe0:
				masklen += 3;
				final++;
				break;
			case 0xc0:
				masklen += 2;
				final++;
				break;
			case 0x80:
				masklen += 1;
				final++;
				break;
			case 0x00:
				final++;
				break;
			default:
				final++;
				illegal++;
				break;
			}

			if (!illegal)
				sin6.sin6_addr.s6_addr[i++] &= *p;
			else
				sin6.sin6_addr.s6_addr[i++] = 0x00;
		}
		while (i < (int)sizeof(struct in6_addr))
			sin6.sin6_addr.s6_addr[i++] = 0x00;
	} else
		masklen = 128;

	if (masklen == 0 && IN6_IS_ADDR_UNSPECIFIED(&sin6.sin6_addr))
		return ("default");

	if (illegal)
		warnx("illegal prefixlen");

	if (nflag)
		flag |= NI_NUMERICHOST;
	error = getnameinfo((struct sockaddr *)&sin6, sin6.sin6_len,
	    hbuf, sizeof(hbuf), NULL, 0, flag);
	if (error)
		snprintf(hbuf, sizeof(hbuf), "invalid");

	snprintf(line, sizeof(line), "%s/%d", hbuf, masklen);
	return (line);
}

/*
 * Return the name of the network whose address is given.
 * The address is assumed to be that of a net or subnet, not a host.
 */
char *
netname(struct sockaddr *sa, struct sockaddr *mask)
{
	switch (sa->sa_family) {
	case AF_INET:
		return netname4(((struct sockaddr_in *)sa)->sin_addr.s_addr,
		    (struct sockaddr_in *)mask);
	case AF_INET6:
		return netname6((struct sockaddr_in6 *)sa,
		    (struct sockaddr_in6 *)mask);
	case AF_LINK:
		return (link_print(sa));
	case AF_MPLS:
		return (label_print(sa));
	default:
		snprintf(line, sizeof(line), "af %d: %s",
		    sa->sa_family, any_ntoa(sa));
		break;
	}
	return (line);
}

static const char hexlist[] = "0123456789abcdef";

char *
any_ntoa(const struct sockaddr *sa)
{
	static char obuf[240];
	const char *in = sa->sa_data;
	char *out = obuf;
	int len = sa->sa_len - offsetof(struct sockaddr, sa_data);

	*out++ = 'Q';
	do {
		*out++ = hexlist[(*in >> 4) & 15];
		*out++ = hexlist[(*in++)    & 15];
		*out++ = '.';
	} while (--len > 0 && (out + 3) < &obuf[sizeof(obuf) - 1]);
	out[-1] = '\0';
	return (obuf);
}

char *
link_print(struct sockaddr *sa)
{
	struct sockaddr_dl	*sdl = (struct sockaddr_dl *)sa;
	u_char			*lla = (u_char *)sdl->sdl_data + sdl->sdl_nlen;

	if (sdl->sdl_nlen == 0 && sdl->sdl_alen == 0 &&
	    sdl->sdl_slen == 0) {
		(void)snprintf(line, sizeof(line), "link#%d", sdl->sdl_index);
		return (line);
	}
	switch (sdl->sdl_type) {
	case IFT_ETHER:
	case IFT_CARP:
		return (ether_ntoa((struct ether_addr *)lla));
	default:
		return (link_ntoa(sdl));
	}
}

char *
mpls_op(u_int32_t type)
{
	switch (type & (MPLS_OP_PUSH | MPLS_OP_POP | MPLS_OP_SWAP)) {
	case MPLS_OP_LOCAL:
		return ("LOCAL");
	case MPLS_OP_POP:
		return ("POP");
	case MPLS_OP_SWAP:
		return ("SWAP");
	case MPLS_OP_PUSH:
		return ("PUSH");
	default:
		return ("?");
	}
}

char *
label_print(struct sockaddr *sa)
{
	struct sockaddr_mpls	*smpls = (struct sockaddr_mpls *)sa;

	if (smpls)
		(void)snprintf(line, sizeof(line), "%u",
		    ntohl(smpls->smpls_label) >> MPLS_LABEL_OFFSET);
	else
		(void)snprintf(line, sizeof(line), "-");

	return (line);
}
@


1.107
log
@Print route labels in double quotes since they can contain spaces in the name.
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.106 2016/09/03 14:23:14 phessler Exp $	*/
a102 1
void	 p_sockaddr(struct sockaddr *, struct sockaddr *, int, int);
d226 1
a226 1
static void
@


1.106
log
@Add userland parts for BFD.  Can't work if you don't have it enabled in
the kernel.

OK claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.105 2016/09/01 09:41:34 bluhm Exp $	*/
d300 1
a300 2
		printf(" %s", ((struct sockaddr_rtlabel *)
		    rti_info[RTAX_LABEL])->sr_label);
d469 1
a469 1
			static char name[RTLABEL_LEN];
d473 1
a473 1
			(void)strlcpy(name, sr->sr_label, sizeof(name));
@


1.105
log
@Display all route flags in "route get", "route show" and "netstat -r"
output.  Sort them according to the RTF_... defines in route.h.
OK claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.104 2016/07/13 08:40:46 mpi Exp $	*/
d93 1
@


1.104
log
@Introduce RTF_MULTICAST and flag corresponding IPv6 routes as such
instead of abusing RTF_CLONING.

Fix a leak reporeted by Aaron Riekenberg on misc@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.103 2015/11/27 16:26:52 benno Exp $	*/
a76 1
	{ RTF_BLACKHOLE, 'B' },
d84 3
a87 2
	{ RTF_PROTO2,	'2' },
	{ RTF_PROTO3,	'3' },
d89 1
d93 2
a94 1
	{ RTF_BROADCAST, 'b' },
@


1.103
log
@After evaluating patches from Ricardo Mestre, it became obvious that
route needs pledge("stdio rpath dns") in all cases.
Looks best to me deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.102 2015/10/23 15:03:25 deraadt Exp $	*/
a80 1
	{ RTF_MASK,	'm' }, /* Mask Present -- for routing messages only */
d82 1
@


1.102
log
@route has 3 code paths: monitor (listening on route socket); show
(sysctl and then print), change (getsocket, then read/write on that).
Refactor lightly and insert pledge "stdio rpath dns" in each case.
ok claudio benno phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.101 2015/09/11 20:08:40 mpi Exp $	*/
d148 2
a149 7
	if (nflag) {
		if (pledge("stdio rpath dns", NULL) == -1)
			err(1, "pledge");
	} else {
		if (pledge("stdio rpath dns", NULL) == -1)
			err(1, "pledge");
	}
@


1.101
log
@Remove RTF_XRESOLVE support.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.100 2015/07/18 00:05:02 phessler Exp $	*/
d146 8
@


1.100
log
@On systems with a full routing table (550k+), we often want to be able to
look at the routes with a priority, or to display all routes that do not
have a specific priority (normally, don't show bgp).

We are intentionally not updating netstat -r yet, as we do not have a
good flag to use.

first version from, and OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.99 2015/04/27 09:51:58 benno Exp $	*/
a82 1
	{ RTF_XRESOLVE,	'X' },
@


1.99
log
@route show does not need to filter unwanted af itself, the sysctl does
that for us.
approach seems sound deraadt@@
ok claudio@@ mpi@@ henning@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.98 2015/02/06 03:22:00 reyk Exp $	*/
d113 1
a113 1
p_rttables(int af, u_int tableid, int hastable)
d126 1
a126 1
	mib[5] = 0;
@


1.98
log
@Remove route/netstat -f encap in favor of ipsecctl -s flow.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.97 2015/01/16 06:40:00 deraadt Exp $	*/
a156 2
			if (af != AF_UNSPEC && sa->sa_family != af)
				continue;
@


1.97
log
@Replace <sys/param.h> with <limits.h> and other less dirty headers where
possible.  Annotate <sys/param.h> lines with their current reasons.  Switch
to PATH_MAX, NGROUPS_MAX, HOST_NAME_MAX+1, LOGIN_NAME_MAX, etc.  Change
MIN() and MAX() to local definitions of MINIMUM() and MAXIMUM() where
sensible to avoid pulling in the pollution.  These are the files confirmed
through binary verification.
ok guenther, millert, doug (helped with the verification protocol)
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.96 2014/05/08 09:28:08 mpi Exp $	*/
a38 1
#include <net/pfkeyv2.h>
a41 1
#include <netinet/ip_ipsp.h>
a64 2
#define PFKEYV2_CHUNK sizeof(u_int64_t)

a99 1
void	 p_pfkentry(struct sadb_msg *);
a100 3
void	 p_encap(struct sockaddr *, struct sockaddr *, int);
void	 p_protocol(struct sadb_protocol *, struct sockaddr *, struct
	     sadb_protocol *, int);
a107 1
void	 index_pfk(struct sadb_msg *, void **);
a115 1
	struct sadb_msg *msg;
a163 41

	if (af != 0 && af != PF_KEY)
		return;

	mib[0] = CTL_NET;
	mib[1] = PF_KEY;
	mib[2] = PF_KEY_V2;
	mib[3] = NET_KEY_SPD_DUMP;
	mib[4] = mib[5] = 0;
	while (1) {
		if (sysctl(mib, 4, NULL, &needed, NULL, 0) == -1) {
			if (errno == ENOPROTOOPT)
				return;
			err(1, "spd-sysctl-estimate");
		}
		if (needed == 0)
			break;
		if ((buf = realloc(buf, needed)) == NULL)
			err(1, NULL);
		if (sysctl(mib, 4, buf, &needed, NULL, 0) == -1) {
			if (errno == ENOMEM)
				continue;
			err(1,"sysctl of spd");
		}
		lim = buf + needed;
		break;
	}

	if (buf) {
		printf("\nEncap:\n");

		for (next = buf; next < lim; next += msg->sadb_msg_len *
		    PFKEYV2_CHUNK) {
			msg = (struct sadb_msg *)next;
			if (msg->sadb_msg_len == 0)
				break;
			p_pfkentry(msg);
		}
		free(buf);
		buf = NULL;
	}
a302 47
 * Print a pfkey/encap entry.
 */
void
p_pfkentry(struct sadb_msg *msg)
{
	static int		 old = 0;
	struct sadb_address	*saddr;
	struct sadb_protocol	*sap, *saft;
	struct sockaddr		*sa, *mask;
	void			*headers[SADB_EXT_MAX + 1];

	if (!old) {
		pr_rthdr(PF_KEY);
		old++;
	}

	bzero(headers, sizeof(headers));
	index_pfk(msg, headers);

	/* These are always set */
	saddr = headers[SADB_X_EXT_SRC_FLOW];
	sa = (struct sockaddr *)(saddr + 1);
	saddr = headers[SADB_X_EXT_SRC_MASK];
	mask = (struct sockaddr *)(saddr + 1);
	p_encap(sa, mask, WID_DST(sa->sa_family));

	/* These are always set, too. */
	saddr = headers[SADB_X_EXT_DST_FLOW];
	sa = (struct sockaddr *)(saddr + 1);
	saddr = headers[SADB_X_EXT_DST_MASK];
	mask = (struct sockaddr *)(saddr + 1);
	p_encap(sa, mask, WID_DST(sa->sa_family));

	/* Bypass and deny flows do not set SADB_EXT_ADDRESS_DST! */
	sap = headers[SADB_X_EXT_PROTOCOL];
	saft = headers[SADB_X_EXT_FLOW_TYPE];
	saddr = headers[SADB_EXT_ADDRESS_DST];
	if (saddr)
		sa = (struct sockaddr *)(saddr + 1);
	else
		sa = NULL;
	p_protocol(sap, sa, saft, msg->sadb_msg_satype);

	printf("\n");
}

/*
a333 91
p_encap(struct sockaddr *sa, struct sockaddr *mask, int width)
{
	char		*cp;
	unsigned short	 port = 0;

	if (mask)
		cp = netname(sa, mask);
	else
		cp = routename(sa);
	switch (sa->sa_family) {
	case AF_INET:
		port = ntohs(((struct sockaddr_in *)sa)->sin_port);
		break;
	case AF_INET6:
		port = ntohs(((struct sockaddr_in6 *)sa)->sin6_port);
		break;
	}
	if (width < 0)
		printf("%s", cp);
	else {
		if (nflag)
			printf("%-*s %-5u ", width, cp, port);
		else
			printf("%-*.*s %-5u ", width, width, cp, port);
	}
}

void
p_protocol(struct sadb_protocol *sap, struct sockaddr *sa, struct sadb_protocol
    *saft, int proto)
{
	printf("%-6u", sap->sadb_protocol_proto);

	if (sa)
		p_sockaddr(sa, NULL, 0, -1);
	else
		printf("none");

	switch (proto) {
	case SADB_SATYPE_ESP:
		printf("/esp");
		break;
	case SADB_SATYPE_AH:
		printf("/ah");
		break;
	case SADB_X_SATYPE_IPCOMP:
		printf("/ipcomp");
		break;
	case SADB_X_SATYPE_IPIP:
		printf("/ipip");
		break;
	default:
		printf("/<unknown>");
	}

	switch(saft->sadb_protocol_proto) {
	case SADB_X_FLOW_TYPE_USE:
		printf("/use");
		break;
	case SADB_X_FLOW_TYPE_REQUIRE:
		printf("/require");
		break;
	case SADB_X_FLOW_TYPE_ACQUIRE:
		printf("/acquire");
		break;
	case SADB_X_FLOW_TYPE_DENY:
		printf("/deny");
		break;
	case SADB_X_FLOW_TYPE_BYPASS:
		printf("/bypass");
		break;
	case SADB_X_FLOW_TYPE_DONTACQ:
		printf("/dontacq");
		break;
	default:
		printf("/<unknown type>");
	}

	switch(saft->sadb_protocol_direction) {
	case IPSP_DIRECTION_IN:
		printf("/in");
		break;
	case IPSP_DIRECTION_OUT:
		printf("/out");
		break;
	default:
		printf("/<unknown>");
	}
}

void
a749 42
}

void
index_pfk(struct sadb_msg *msg, void **headers)
{
	struct sadb_ext	*ext;

	for (ext = (struct sadb_ext *)(msg + 1);
	    (size_t)((u_int8_t *)ext - (u_int8_t *)msg) <
	    msg->sadb_msg_len * PFKEYV2_CHUNK && ext->sadb_ext_len > 0;
	    ext = (struct sadb_ext *)((u_int8_t *)ext +
	    ext->sadb_ext_len * PFKEYV2_CHUNK)) {
		switch (ext->sadb_ext_type) {
		case SADB_EXT_ADDRESS_SRC:
			headers[SADB_EXT_ADDRESS_SRC] = (void *)ext;
			break;
		case SADB_EXT_ADDRESS_DST:
			headers[SADB_EXT_ADDRESS_DST] = (void *)ext;
			break;
		case SADB_X_EXT_PROTOCOL:
			headers[SADB_X_EXT_PROTOCOL] = (void *)ext;
			break;
		case SADB_X_EXT_SRC_FLOW:
			headers[SADB_X_EXT_SRC_FLOW] = (void *)ext;
			break;
		case SADB_X_EXT_DST_FLOW:
			headers[SADB_X_EXT_DST_FLOW] = (void *)ext;
			break;
		case SADB_X_EXT_SRC_MASK:
			headers[SADB_X_EXT_SRC_MASK] = (void *)ext;
			break;
		case SADB_X_EXT_DST_MASK:
			headers[SADB_X_EXT_DST_MASK] = (void *)ext;
			break;
		case SADB_X_EXT_FLOW_TYPE:
			headers[SADB_X_EXT_FLOW_TYPE] = (void *)ext;
			break;
		default:
			/* Ignore. */
			break;
		}
	}
@


1.96
log
@Introduce two new route flags: RTF_LOCAL and RTF_BROADCAST.

Nothing use them for the moment, but here is the plan:

Since a route lookup is always necessary to output a packet it makes
sense to store all the information regarding how the packet should be
sent in the routing entry.  This will save us some expensive lookups
on address lists.

But once we have all the information about our addresses in the routing
table, we can even use it in the input path with the hope that the number
of lookups in the forwarding case can be reduce to one.

ok henning@@, chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.95 2014/04/17 15:35:35 claudio Exp $	*/
a32 1
#include <sys/param.h>
d55 1
d570 2
a571 2
static char line[MAXHOSTNAMELEN];
static char domain[MAXHOSTNAMELEN];
@


1.95
log
@Sync show.c to what we have in netstat.c (at least steal some good idioms
from there). OK sthen@@ mpi@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.94 2013/07/19 20:10:23 guenther Exp $	*/
d96 2
@


1.94
log
@Prep for WARNINGS=yes: add the prototypes that were missing, silence
a "signed vs unsigned in conditional" warning, and eliminate what
looks like an unintentional variable shadowing.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.93 2013/03/21 04:43:17 deraadt Exp $	*/
a62 7
extern int nflag;
extern int Fflag;
extern int verbose;
extern union sockunion so_label;

#define PLEN  (LONG_BIT / 4 + 2) /* XXX this is also defined in netstat.h */

d147 1
a147 1
			err(1, "realloc");
d181 9
a189 8

	if (sysctl(mib, 4, NULL, &needed, NULL, 0) == -1) {
		if (errno == ENOPROTOOPT)
			return;
		err(1, "spd-sysctl-estimate");
	}
	if (needed > 0) {
		if ((buf = malloc(needed)) == 0)
d191 3
a193 1
		if (sysctl(mib, 4, buf, &needed, NULL, 0) == -1)
d195 1
d197 1
@


1.93
log
@create realloc() loops around sysctl for array-based mibs, in programs
which want a "full" dump
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.92 2012/12/04 02:30:33 deraadt Exp $	*/
d106 1
d119 2
d768 1
a768 1
		    lim : sizeof(struct in6_addr);
d822 1
a822 1
		while (i < sizeof(struct in6_addr))
@


1.92
log
@remove some unnecessary sys/mbuf.h inclusions
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.91 2012/03/17 10:16:40 dlg Exp $	*/
d145 10
a154 6
	if (sysctl(mib, mcnt, NULL, &needed, NULL, 0) < 0)
		err(1, "route-sysctl-estimate");
	if (needed > 0) {
		if ((buf = malloc(needed)) == 0)
			err(1, NULL);
		if (sysctl(mib, mcnt, buf, &needed, NULL, 0) < 0)
d156 1
d158 1
@


1.91
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.90 2011/07/09 00:45:40 henning Exp $	*/
a34 1
#include <sys/mbuf.h>
@


1.90
log
@rmove rotten netatalk bits
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.89 2010/10/11 11:45:00 claudio Exp $	*/
a101 1
	{ RTF_JUMBO,	'J' },
@


1.89
log
@Make route(8) use the ROUTE_TABLEFILTER and change the code so that
route(8) will default to the process rtableid.
route -T 1 exec route add default 192.168.1.1
route -T 1 exec route -n show
These commands will now operate outmatically on rtable 1 and not on
rtable 0 as it was done before.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.88 2010/09/21 10:58:23 krw Exp $	*/
a412 3
		break;
	case AF_APPLETALK:
		afname = "AppleTalk";
@


1.88
log
@Add '-label' to specify that you only want to see routes having the
given label. No change to existing functionality.

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.87 2010/07/29 16:35:40 bluhm Exp $	*/
d126 1
a126 1
p_rttables(int af, u_int tableid)
d132 1
a132 1
	int mib[7];
d141 5
a145 1
	mib[6] = tableid;
d147 1
a147 1
	if (sysctl(mib, 7, NULL, &needed, NULL, 0) < 0)
d152 1
a152 1
		if (sysctl(mib, 7, buf, &needed, NULL, 0) < 0)
@


1.87
log
@Print a column with the routing label if "netstat -vr" or "route
-v show" are called with the -v switch.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.86 2010/05/19 13:07:15 chl Exp $	*/
d67 1
d289 1
d295 1
d299 10
@


1.86
log
@remove unused variables

ok claudio@@ michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.85 2010/03/23 15:08:51 claudio Exp $	*/
d66 1
d252 1
a252 1
		printf("%-*.*s %-*.*s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s\n",
d256 3
d321 1
a321 1
	printf("  %2d %.16s", rtm->rtm_priority,
d323 3
@


1.85
log
@Add missing break, found while syncing with netstat/show.c
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.84 2010/03/23 15:01:50 claudio Exp $	*/
a547 2
	char buf[MAXHOSTNAMELEN], *cp;

@


1.84
log
@Print MPLS information in route -n get and do some cleanup in the show code.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.83 2010/01/13 23:49:06 claudio Exp $	*/
d949 1
@


1.83
log
@netmask sockaddrs for the default route may set sa_len to 0 to indicate
a all zero mask. So check for this condition as well since else we read
garbage that comes after the netmask sockaddr (which is the IFP normaly).
Found by todd@@, OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.82 2010/01/11 08:26:29 dlg Exp $	*/
d62 1
a62 2
char	*label_print_op(u_int32_t);
char	*label_print(struct sockaddr *, struct sockaddr *);
d218 1
a218 1
			return 34;
d227 1
a227 1
			return 34;
d246 1
a246 1
		printf("%-16s %-10s %-6s %-18s %-6.6s %5.5s %8.8s %5.5s  %4.4s %s\n",
d553 7
a559 7
	if (flags & MPLS_OP_POP || flags == MPLS_OP_LOCAL)
		cp = label_print(in, NULL);
	else
		cp = label_print(in, out);

	snprintf(buf, MAXHOSTNAMELEN, "%s %s", cp,
	    label_print_op(flags));
d561 1
a561 1
	printf("%-*s ", width, buf);
d627 1
a627 1
		return (label_print(sa, NULL));
d835 1
a835 1
		return (label_print(sa, NULL));
d885 1
a885 1
label_print_op(u_int32_t type)
d902 1
a902 1
label_print(struct sockaddr *in, struct sockaddr *out)
d904 1
a904 19
	struct sockaddr_mpls	*insmpls = (struct sockaddr_mpls *)in;
	struct sockaddr_mpls	*outsmpls = (struct sockaddr_mpls *)out;
	char			 ifname_in[IF_NAMESIZE];
	char			 ifname_out[IF_NAMESIZE];
	char			*in_label;
	char			*out_label;

	if (asprintf(&in_label, "%u",
	    ntohl(insmpls->smpls_label) >> MPLS_LABEL_OFFSET) == -1)
		err(1, NULL);

	if (outsmpls) {
		if (asprintf(&out_label, "%u",
		    ntohl(outsmpls->smpls_label) >> MPLS_LABEL_OFFSET) == -1)
			err(1, NULL);
	} else {
		if (asprintf(&out_label, "-") == -1)
			err(1, NULL);
	}
d906 5
a910 5
	(void)snprintf(line, sizeof(line), "%-16s %-10s", in_label,
	    out_label);

	free(in_label);
	free(out_label);
@


1.82
log
@"default" routes need a mask of 0 too.

from and ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.80 2009/06/27 11:35:57 michele Exp $	*/
d701 1
a701 1
	mask = maskp ? ntohl(maskp->sin_addr.s_addr) : 0;
@


1.81
log
@if buffers overlap;  result will be undefined.  ok claudio@@, michele@@
@
text
@d706 1
a706 1
	if (in == INADDR_ANY)
@


1.80
log
@Mark MPLS routes with T (tagged) in route output.

suggested by dlg@@, ok claudio@@, laurent@@, blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.79 2009/05/31 18:02:28 claudio Exp $	*/
d549 1
a549 1
	char *cp;
d559 1
a559 1
	snprintf(cp, MAXHOSTNAMELEN, "%s %s", cp,
d562 1
a562 1
	printf("%-*s ", width, cp);
@


1.79
log
@Masking the priority with RTP_MASK is no longer needed in userland.
Kernel will do this now.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.78 2009/05/23 16:44:12 chris Exp $	*/
d103 1
@


1.78
log
@missed rtm_hdrlen conversion in one place

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.77 2009/04/28 12:09:35 michele Exp $	*/
d317 1
a317 1
	printf("  %2d %.16s", rtm->rtm_priority & RTP_MASK,
@


1.77
log
@Sync with kernel changes.
Add support to route(8) for a new dummy operation to allow packets coming in
with a particular label to leave the MPLS cloud and join ipv4/ipv6 stack.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.76 2009/02/03 16:44:15 michele Exp $	*/
d281 1
a281 1
	struct sockaddr	*sa = (struct sockaddr *)(rtm + 1);
@


1.76
log
@Reflect MPLS kernel changes. Operations are stored now in rt_mpls field.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.75 2009/01/26 17:18:47 claudio Exp $	*/
d553 1
a553 1
	if (flags & MPLS_OP_POP)
d888 2
@


1.75
log
@Mark multipath routes with P in the show command flags. Bummer that both
M and m were already taken. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.74 2009/01/08 12:52:36 michele Exp $	*/
d303 1
a303 1
	p_sockaddr_mpls(sa, rti_info[RTAX_SRC], rtm->rtm_flags,
@


1.74
log
@Reflect MPLS kernel changes.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.73 2008/12/15 16:14:57 michele Exp $	*/
d102 1
@


1.73
log
@Reflect kernel changes. Labels are no more per link unique
and operations are now stored in rt_flags.
This also simplify a lot the syntax.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.72 2008/12/12 20:26:30 claudio Exp $	*/
d63 1
a63 1
char	*label_print(struct sockaddr *);
d113 1
d302 3
d523 1
a523 9
		if (flags & RTF_HOST || mask == NULL)
			cp = routename(sa);
		else
			cp = netname(sa, mask);

		snprintf(cp, MAXHOSTNAMELEN, "%s %s", cp,
		    label_print_op(flags));

		break;
d541 22
a575 3
static char line[MAXHOSTNAMELEN];
static char domain[MAXHOSTNAMELEN];

d626 1
a626 1
		return (label_print(sa));
d834 1
a834 1
		return (label_print(sa));
d899 1
a899 1
label_print(struct sockaddr *sa)
d901 2
a902 1
	struct sockaddr_mpls	*smpls = (struct sockaddr_mpls *)sa;
d909 1
a909 1
	    ntohl(smpls->smpls_in_label) >> MPLS_LABEL_OFFSET) == -1)
d912 8
a919 3
	if (asprintf(&out_label, "%u",
	    ntohl(smpls->smpls_out_label) >> MPLS_LABEL_OFFSET) == -1)
		err(1, NULL);
@


1.72
log
@Use the hdrlen to skip over the header and to the sockaddrs instead of the
implied sizeof(struct rt_msghdr). Makes code more robust when userland and
kernel are out of sync.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.71 2008/09/15 20:12:11 claudio Exp $	*/
d62 1
a62 1
char	*label_print_op(u_int8_t);
d303 1
d518 10
d869 1
a869 1
label_print_op(u_int8_t type)
d871 1
a871 1
	switch (type) {
d892 2
a893 3
	if (asprintf(&in_label, "%u%%%s",
	    ntohl(smpls->smpls_in_label) >> MPLS_LABEL_OFFSET,
	    if_indextoname(smpls->smpls_in_ifindex, ifname_in)) == -1)
d900 2
a901 3
	(void)snprintf(line, sizeof(line), "%-16s %-10s %-6s", in_label,
	    smpls->smpls_operation == MPLS_OP_POP ? "-" : out_label,
	    label_print_op(smpls->smpls_operation));
@


1.71
log
@Mask rtm->rtm_priority with RTP_MASK before printing so that the priority is
correctly shown even if the route is flagged RTP_DOWN. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.70 2008/05/25 17:57:42 deraadt Exp $	*/
d156 1
a156 1
			sa = (struct sockaddr *)(rtm + 1);
@


1.70
log
@do not need sys/protosw.h
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.69 2008/05/08 07:10:51 claudio Exp $	*/
d311 1
a311 1
	printf("  %2d %.16s", rtm->rtm_priority,
@


1.69
log
@space
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.68 2008/05/08 06:13:09 norby Exp $	*/
a33 1
#include <sys/protosw.h>
@


1.68
log
@Fix fallout from the route priority thing.

Don't display out label interface in the second column.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.67 2008/05/08 05:41:59 norby Exp $	*/
d203 1
a203 1
/* 
@


1.67
log
@Don't display the outlabel and interface for POP operations.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.66 2008/05/07 06:06:25 claudio Exp $	*/
d217 1
a217 1
			return 48;
d226 1
a226 1
			return 48;
d245 1
a245 1
		printf("%-20s %-20s %-6s %-18s %-6.6s %6.6s %8.8s %6.6s  %s\n",
d247 1
a247 1
		    "Flags", "Refs", "Use", "Mtu", "Interface");
d887 2
a888 3
	if (asprintf(&out_label, "%u%%%s",
	    ntohl(smpls->smpls_out_label) >> MPLS_LABEL_OFFSET,
	    if_indextoname(smpls->smpls_out_ifindex, ifname_out)) == -1)
d891 1
a891 1
	(void)snprintf(line, sizeof(line), "%-20s %-20s %-6s", in_label,
@


1.66
log
@Add support to show and modify rtm_priority.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.65 2008/05/06 03:44:14 claudio Exp $	*/
d893 2
a894 1
	    out_label, label_print_op(smpls->smpls_operation));
@


1.65
log
@Labels in the sockaddr are stored like on the wire so shift and byte swap
them. This makes route lookups work again. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.64 2008/05/06 03:39:09 claudio Exp $	*/
d250 1
a250 1
		printf("%-*.*s %-*.*s %-6.6s %6.6s %8.8s %6.6s  %s\n",
d253 2
a254 1
		    "Flags", "Refs", "Use", "Mtu", "Interface");
d305 1
a305 1
	printf("%6u %8llu ", rtm->rtm_rmx.rmx_refcnt,
d308 1
a308 1
		printf("%6u ", rtm->rtm_rmx.rmx_mtu);
d310 1
a310 1
		printf("%6s ", "-");
d312 2
a313 1
	printf(" %.16s", if_indextoname(rtm->rtm_index, ifbuf));
@


1.64
log
@Minor cleanup. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.63 2008/04/30 12:43:23 norby Exp $	*/
d880 2
a881 1
	if (asprintf(&in_label, "%u%%%s", ntohl(smpls->smpls_in_label),
d885 2
a886 1
	if (asprintf(&out_label, "%u%%%s", ntohl(smpls->smpls_out_label),
@


1.63
log
@Correct MPLS output of route -n show.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.62 2008/04/28 11:36:14 norby Exp $	*/
a237 1

d400 1
a400 1
	unsigned short	 port;
@


1.62
log
@It is now possible to enter static MPLS routes into the kernel.

It is still not possible to set the desired opration for an entry.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.61 2007/09/05 20:30:21 claudio Exp $	*/
a207 1
#define	WID_DST(af)	((af) == AF_INET6 ? (nflag ? 34 : 18) : 18)
d209 22
@


1.61
log
@Correct the format strings after the recent rt_metrics changes.
rmx_pksent is not u_int64_t all others are just u_int.
This is almost the same as in usr.bin/netstat.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.60 2007/07/24 20:22:23 claudio Exp $	*/
d47 1
d63 2
d217 13
a229 1
	if (af != PF_KEY)
d234 1
a234 4
	else
		printf("%-18s %-5s %-18s %-5s %-5s %-22s\n",
		    "Source", "Port", "Destination",
		    "Port", "Proto", "SA(Address/Proto/Type/Direction)");
d301 1
a301 1
	static int	 	 old = 0;
d360 3
d379 1
a379 1
	char 		*cp;
d578 2
a579 1

a777 1

d786 2
d834 41
@


1.60
log
@Sync closer to netstat/show.c this removes also the unneeded variable
noticed by Igor Zinovik.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.59 2007/07/21 15:43:01 claudio Exp $	*/
d272 1
a272 1
	printf("%6d %8ld ", (int)rtm->rtm_rmx.rmx_refcnt,
d275 1
a275 1
		printf("%6ld ", rtm->rtm_rmx.rmx_mtu);
@


1.59
log
@Check the rtm_version before trying to print an entry. If the rtmsg has a
different version skip it and don't try to print it. Solves a SIGSEGV I have
triggered with one of my scarier diffs.  OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.58 2007/06/04 12:23:44 henning Exp $	*/
a289 1
	struct sadb_ext		*ext;
d524 1
a524 1
			strlcpy(domain, cp + 1, sizeof(domain));
d531 1
a531 1
		strlcpy(line, "default", sizeof(line));
d570 1
a570 1
			strlcpy(name, sr->sr_label, sizeof(name));
d575 1
a575 1
		snprintf(line, sizeof(line), "(%d) %s",
a765 1

a768 1

a770 1

d807 1
a807 1
		snprintf(line, sizeof(line), "link#%d", sdl->sdl_index);
@


1.58
log
@remove IPX, agreed by many
libc and kernel side awaiting a libc major bump to piggyback to
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.57 2007/03/23 16:02:26 pyr Exp $	*/
d152 2
@


1.57
log
@Add a new flag -F to netstat restricting route display in conjuction
with -r to routes in the same address family as the destination.
ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.56 2006/12/29 10:04:36 claudio Exp $	*/
a44 1
#include <netipx/ipx.h>
a60 1
char	*ipx_print(struct sockaddr *);
a343 3
	case AF_IPX:
		afname = "IPX";
		break;
a559 3
	case AF_IPX:
		return (ipx_print(sa));

a769 3
	case AF_IPX:
		return (ipx_print(sa));

a798 51
}

short ipx_nullh[] = {0,0,0};
short ipx_bh[] = {-1,-1,-1};

char *
ipx_print(struct sockaddr *sa)
{
	struct sockaddr_ipx *sipx = (struct sockaddr_ipx *)sa;
	struct ipx_addr work;
	union {
		union ipx_net	net_e;
		u_int32_t	long_e;
	} net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN], cport[10], chost[25];
	char *host = "";
	char *p;
	u_char *q;

	work = sipx->sipx_addr;
	port = ntohs(work.ipx_port);
	work.ipx_port = 0;
	net.net_e = work.ipx_net;
	if (ipx_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		snprintf(mybuf, sizeof(mybuf), "*.0x%XH", port);
		return (mybuf);
	}

	if (memcmp(ipx_bh, work.ipx_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ipx_nullh, work.ipx_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.ipx_host.c_host;
		snprintf(chost, sizeof(chost), "%02X%02X%02X%02X%02X%02XH",
		    q[0], q[1], q[2], q[3], q[4], q[5]);
		for (p = chost; *p == '0' && p < chost + 12; p++)
			/* void */;
		host = p;
	}
	if (port)
		snprintf(cport, sizeof(cport), ".%XH", htons(port));
	else
		*cport = '\0';

	snprintf(mybuf, sizeof(mybuf), "%XH.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
@


1.56
log
@Route warns about a illegal prefixlen when a default inet6 route is present.
Need to typecast the sizeof() to int so that the compare works. Having a
negativ lim is OK.  Reported by Bjrn Ketelaars. OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.55 2006/11/17 01:11:23 itojun Exp $	*/
d66 1
d254 4
a262 1
	get_rtaddrs(rtm->rtm_addrs, sa, rti_info);
@


1.55
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.54 2006/06/16 17:46:43 henning Exp $	*/
d680 1
a680 1
		lim = lim < sizeof(struct in6_addr) ?
@


1.54
log
@make route show work on secondary tables, using the just committed
extension to the syctl NET_RT_DUMP interface, claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.53 2006/05/30 19:42:58 todd Exp $	*/
d468 2
a469 1
		    IN6_IS_ADDR_MC_LINKLOCAL(in6)) {
d550 2
a551 1
		     IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr)) &&
@


1.53
log
@this fixes a crash observed by Naddy on amd64, and permits the src/dst ip's to
be visible .. when IPv6 sa flows are present
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.52 2006/05/27 18:26:45 claudio Exp $	*/
d121 1
a121 1
p_rttables(int af)
d127 1
a127 1
	int mib[6];
d136 3
a138 1
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
d143 1
a143 1
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0)
@


1.52
log
@Kill unused Aflag support that sneeked in via netstat code.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.51 2006/05/27 18:20:59 claudio Exp $	*/
d365 4
d370 2
a371 1
	case AF_INET6: {
d373 2
a374 7
	}
	default:
		if (mask)
			cp = netname(sa, mask);
		else
			cp = routename(sa);
		port = ntohs(((struct sockaddr_in *)sa)->sin_port);
d392 1
@


1.51
log
@Do not print an error in case of ENOPROTOOPT. Install medias do not have
IPSec support and so will print a "route: spd-sysctl-estimate: Protocol not
available" on upgrades. Requested and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.50 2006/03/31 15:56:25 hshoexer Exp $	*/
d104 2
a105 2
void	 pr_rthdr(int, int);
void	 p_rtentry(struct rt_msghdr *, int);
d121 1
a121 1
p_rttables(int af, int Aflag)
d154 1
a154 1
			p_rtentry(rtm, Aflag);
d209 1
a209 1
pr_rthdr(int af, int Aflag)
a210 2
	if (Aflag)
		printf("%-*.*s ", PLEN, PLEN, "Address");
d241 1
a241 1
p_rtentry(struct rt_msghdr *rtm, int Aflag)
d254 1
a254 1
		pr_rthdr(sa->sa_family, Aflag);
d291 1
a291 1
		pr_rthdr(PF_KEY, 0);
@


1.50
log
@Be careful when accessing the external destination address, as it is not set
for bypass and deny flows.
Also display acquire/dontacquire flows.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.49 2006/03/30 13:58:30 hshoexer Exp $	*/
d51 1
d169 3
a171 1
	if (sysctl(mib, 4, NULL, &needed, NULL, 0) == -1)
d173 1
@


1.49
log
@Print the "Encap" heading only when the sadb is not empty.
Fix identation (was off by one space).

both requested and ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.48 2006/03/30 12:11:37 claudio Exp $	*/
d296 1
d303 1
d310 1
d314 4
a317 1
	sa = (struct sockaddr *)(saddr + 1);
d390 4
a393 1
	p_sockaddr(sa, NULL, 0, -1);
d419 3
d427 3
@


1.48
log
@If an address family is specified do not print IPSec "routes". Additionally
add a -encap option to show only the IPSec part. OK hshoexer@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.47 2006/03/30 09:57:35 claudio Exp $	*/
a161 2
	printf("\nEncap:\n");

d179 2
d383 1
a383 1
	printf("%-5u", sap->sadb_protocol_proto);
@


1.47
log
@Minor cleanup and start using rmx_refcnt to show the refcount instead of 0.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.46 2006/03/29 20:21:45 hshoexer Exp $	*/
d158 3
@


1.46
log
@Use sysctl to get information about encap routes (aka ipsec).  Now
you see something actually useful...

requested by and ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.45 2006/03/23 13:38:27 mcbride Exp $	*/
a113 1
char	*any_ntoa(const struct sockaddr *);
a115 1

d258 2
a259 1
	p_sockaddr(rti_info[RTAX_GATEWAY], NULL, RTF_HOST, WID_GW(sa->sa_family));
d261 2
a262 1
	printf("%6d %8ld ", 0, rtm->rtm_rmx.rmx_pksent);
d587 1
a587 1
	int	 niflags;
a588 1
	niflags = 0;
a648 2
	flag = 0;

d651 1
d844 8
a851 7
	} else
		switch (sdl->sdl_type) {
		case IFT_ETHER:
		case IFT_CARP:
			return (ether_ntoa((struct ether_addr *)lla));
		}
	return (link_ntoa(sdl));
@


1.45
log
@Fix pretty-print of carp link addresses by making them print like IFT_ETHER.

Diff from jon@@abccomm.com
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.44 2006/02/01 19:00:22 otto Exp $	*/
d42 1
d72 2
d105 1
d107 3
d115 2
d125 1
d158 31
d245 2
d273 42
d349 81
d465 1
a465 1
		printf("%s ", cp);
d853 41
@


1.44
log
@double semicolon; from Daniel Matic in PR 4929
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.43 2005/05/27 04:55:27 mcbride Exp $	*/
d683 1
@


1.43
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.42 2005/03/30 05:40:55 henning Exp $	*/
d295 1
a295 1
			cp = netname(sa, mask);;
@


1.42
log
@more bitrot bites the dust
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.41 2005/03/30 05:34:30 henning Exp $	*/
d96 1
@


1.41
log
@unconditionalize INET6 support, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.40 2005/02/18 04:00:21 jaredy Exp $	*/
a32 8
#ifndef lint
#if 0
static char sccsid[] = "from: @@(#)route.c	8.3 (Berkeley) 3/9/94";
#else
static const char rcsid[] = "$OpenBSD: show.c,v 1.40 2005/02/18 04:00:21 jaredy Exp $";
#endif
#endif /* not lint */

d59 6
a242 3
	case AF_NS:
		afname = "XNS";
		break;
a244 3
		break;
	case AF_CCITT:
		afname = "X.25";
@


1.40
log
@ansi, knf, and other style nits; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.39 2004/11/17 01:47:20 itojun Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.39 2004/11/17 01:47:20 itojun Exp $";
a106 1
#ifdef INET6
a107 1
#endif
d152 5
a156 8
/* column widths; each followed by one space */
#ifndef INET6
#define	WID_DST(af)	18	/* width of destination column */
#define	WID_GW(af)	18	/* width of gateway column */
#else
/* width of destination/gateway column */
#if 1
/* strlen("fe80::aaaa:bbbb:cccc:dddd@@gif0") == 30, strlen("/128") == 4 */
a158 6
#else
/* strlen("fe80::aaaa:bbbb:cccc:dddd") == 25, strlen("/128") == 4 */
#define	WID_DST(af)	((af) == AF_INET6 ? (nflag ? 29 : 18) : 18)
#define	WID_GW(af)	((af) == AF_INET6 ? (nflag ? 25 : 18) : 18)
#endif
#endif /* INET6 */
a241 1
#ifdef INET6
a244 1
#endif /* INET6 */
a275 1
#ifdef INET6
a278 1
#ifdef __KAME__
a291 1
#endif
a297 1
#endif
a356 1
#ifdef INET6
a364 1
#ifdef __KAME__
a373 1
#endif
a375 1
#endif
a424 1
#ifdef INET6
a441 1
#endif
a481 1
#ifdef INET6
a573 1
#endif
d587 1
a587 1
#ifdef INET6
a590 1
#endif
@


1.39
log
@remove NI_WITHSCOPEID (which is not standard)
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.38 2004/10/14 15:20:56 jaredy Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.38 2004/10/14 15:20:56 jaredy Exp $";
d45 1
a56 2
#include <sys/sysctl.h>

d122 1
a122 1
        struct sockaddr *sa;
d137 1
a137 1
		lim  = buf + needed;
d209 1
a209 3
p_rtentry(rtm, Aflag)
	struct rt_msghdr *rtm;
	int		  Aflag;
d227 1
a227 1
	
d229 1
a229 1
	p_sockaddr(rti_info[RTAX_GATEWAY], 0, RTF_HOST, WID_GW(sa->sa_family));
d245 1
a245 2
pr_family(af)
	int af;
d316 1
a316 1
	    	if ((flags & RTF_HOST) || mask == NULL)
d320 1
d322 1
a322 1
	if (width < 0 )
d338 1
a338 1
	for (flags = name; p->b_mask && flags < &name[sizeof name-2]; p++)
d356 1
a356 1
		if (gethostname(domain, sizeof domain) == 0 &&
d358 1
a358 1
			(void) strlcpy(domain, cp + 1, sizeof domain);
d360 1
a360 1
			domain[0] = 0;
d365 1
a365 1
		(void) strlcpy(line, "default", sizeof line);
d410 1
a410 1
			(void) strlcpy(name, sr->sr_label, sizeof name);
d415 1
a415 1
		(void) snprintf(line, sizeof line, "(%d) %s",
d433 1
a433 1
		    sizeof (in), AF_INET)) != NULL) {
d436 1
a436 1
				*cp = 0;
d441 1
a441 1
	strlcpy(line, cp ? cp : inet_ntoa(ina), sizeof line);
d491 1
a491 1
		snprintf(line, sizeof line, "%u/%d", C(in >> 24), mbits);
d493 1
a493 1
		snprintf(line, sizeof line, "%u.%u/%d",
d496 1
a496 1
		snprintf(line, sizeof line, "%u.%u.%u/%d",
d499 1
a499 1
		snprintf(line, sizeof line, "%u.%u.%u.%u/%d", C(in >> 24),
d583 1
a583 1
		return("default");
d596 1
a596 1
	return line;
d625 1
a625 1
		snprintf(line, sizeof line, "af %d: %s",
d647 1
a647 1
	} while (--len > 0 && (out + 3) < &obuf[sizeof obuf-1]);
d660 4
a663 1
	union { union ipx_net net_e; u_int32_t long_e; } net;
d673 1
a673 1
	net.net_e  = work.ipx_net;
d677 1
a677 1
		(void) snprintf(mybuf, sizeof mybuf, "*.0x%XH", port);
d687 2
a688 2
		(void) snprintf(chost, sizeof chost, "%02X%02X%02X%02X%02X%02XH",
			q[0], q[1], q[2], q[3], q[4], q[5]);
d694 1
a694 1
		(void) snprintf(cport, sizeof cport, ".%XH", htons(port));
d696 1
a696 1
		*cport = 0;
d698 1
a698 1
	(void) snprintf(mybuf, sizeof mybuf, "%XH.%s%s",
d711 1
a711 2
		(void) snprintf(line, sizeof line,
				"link#%d", sdl->sdl_index);
d713 5
a717 6
	} else switch (sdl->sdl_type) {
	case IFT_ETHER:
		return (ether_ntoa((struct ether_addr *)lla));
	default:
		break;
	}
a719 1

@


1.38
log
@avoid collision of variable "err" with err()
use errx() after strlcpy if out of space
style nits/knf

ok henning hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.37 2004/09/24 01:24:30 jaredy Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.37 2004/09/24 01:24:30 jaredy Exp $";
a454 3
#ifdef NI_WITHSCOPEID
	niflags = NI_WITHSCOPEID;
#else
a455 1
#endif
a517 3
#ifdef NI_WITHSCOPEID
	flag = NI_WITHSCOPEID;
#else
a518 1
#endif
@


1.37
log
@kill homegrown quit(); use err()/errx() instead
make other error messages consistent
sync usage

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.36 2004/09/22 01:07:10 jaredy Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.36 2004/09/22 01:07:10 jaredy Exp $";
d367 1
a367 1
	if (sa->sa_len == 0)
d369 4
a372 1
	else switch (sa->sa_family) {
d519 1
a519 1
	int i, lim;
d521 1
d523 1
a523 1
	int flag = NI_WITHSCOPEID;
d525 1
a525 1
	int flag = 0;
a526 1
	int error;
@


1.36
log
@remove -S, -src, -srcmask, and other source routing stuff.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.35 2004/09/21 02:45:52 jaredy Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.35 2004/09/21 02:45:52 jaredy Exp $";
d58 1
d131 2
a132 4
	if (sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)	{
		perror("route-sysctl-estimate");
		exit(1);
	}
d134 4
a137 8
		if ((buf = malloc(needed)) == 0) {
			printf("out of space\n");
			exit(1);
		}
		if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
			perror("sysctl of routing table");
			exit(1);
		}
d594 1
a594 1
		fprintf(stderr, "illegal prefixlen\n");
@


1.35
log
@print route labels in monitor mode.  ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.34 2004/09/15 23:41:42 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.34 2004/09/15 23:41:42 deraadt Exp $";
a97 1
	{ RTF_SOURCE,	's' },
d101 2
a102 2
void	 pr_rthdr(int, int, int);
void	 p_rtentry(struct rt_msghdr *, int, int);
d116 1
a116 1
p_rttables(int af, int Aflag, int Sflag)
d154 1
a154 1
			p_rtentry(rtm, Aflag, Sflag);
d181 1
a181 1
pr_rthdr(int af, int Aflag, int Sflag)
d186 4
a189 12
		if (af == AF_INET && Sflag)
			printf("%-*.*s %-*.*s %-*.*s %-6.6s "
			    "%6.6s %8.8s %6.6s  %s\n",
			    WID_DST(af), WID_DST(af), "Source",
			    WID_DST(af), WID_DST(af), "Destination",
			    WID_GW(af), WID_GW(af), "Gateway",
			    "Flags", "Refs", "Use", "Mtu", "Interface");
		else
			printf("%-*.*s %-*.*s %-6.6s %6.6s %8.8s %6.6s  %s\n",
			    WID_DST(af), WID_DST(af), "Destination",
			    WID_GW(af), WID_GW(af), "Gateway",
			    "Flags", "Refs", "Use", "Mtu", "Interface");
d215 1
a215 1
p_rtentry(rtm, Aflag, Sflag)
d217 1
a217 1
	int		  Aflag, Sflag;
d228 1
a228 1
		pr_rthdr(sa->sa_family, Aflag, Sflag);
a235 10
	if (old_af == AF_INET && Sflag) {
		if (rti_info[RTAX_SRC] != NULL)
			p_sockaddr(rti_info[RTAX_SRC],
			    rti_info[RTAX_SRCMASK],
			    rti_info[RTAX_SRCMASK] ? 0 : RTF_HOST,
			    WID_DST(sa->sa_family));
		else
			printf("%-*s ", WID_DST(AF_INET), "default");
	}

@


1.34
log
@unused functions
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.34 2004/09/15 23:34:48 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.34 2004/09/15 23:34:48 deraadt Exp $";
d428 10
@


1.33
log
@fix warning: extra tokens at end of #undef; ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.32 2004/06/25 01:26:01 henning Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.32 2004/06/25 01:26:01 henning Exp $";
a308 12
}

void
p_addr(struct sockaddr *sa, struct sockaddr *mask, int flags)
{
	p_sockaddr(sa, mask, flags, WID_DST(sa->sa_family));
}

void
p_gwaddr(struct sockaddr *sa, int af)
{
	p_sockaddr(sa, 0, RTF_HOST, WID_GW(af));
@


1.32
log
@remove netiso and netns code
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.31 2004/06/16 11:47:35 cedric Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.31 2004/06/16 11:47:35 cedric Exp $";
d531 1
a531 1
#undef C(x)
@


1.31
log
@Fix -S flag with new show code. ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.30 2004/06/15 17:10:32 millert Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.30 2004/06/15 17:10:32 millert Exp $";
a50 1
#include <netns/ns.h>
a51 1
#include <netiso/iso.h>
a291 3
	case AF_ISO:
		afname = "ISO";
		break;
a433 3
	case AF_NS:
		return (ns_print(sa));

a439 5
	case AF_ISO:
		(void) snprintf(line, sizeof line, "iso %s",
		    iso_ntoa(&((struct sockaddr_iso *)sa)->siso_addr));
		break;

a651 3
	case AF_NS:
		return (ns_print(sa));

a657 5
	case AF_ISO:
		(void) snprintf(line, sizeof line, "iso %s",
		    iso_ntoa(&((struct sockaddr_iso *)sa)->siso_addr));
		break;

a683 46
}

short ns_nullh[] = {0,0,0};
short ns_bh[] = {-1,-1,-1};

char *
ns_print(struct sockaddr *sa)
{
	struct sockaddr_ns *sns = (struct sockaddr_ns *)sa;
	struct ns_addr work;
	union { union ns_net net_e; u_int32_t long_e; } net;
	u_short port;
	static char mybuf[50+MAXHOSTNAMELEN];
	char cport[10], chost[25];
	char *host = "";
	u_char *q;

	work = sns->sns_addr;
	port = ntohs(work.x_port);
	work.x_port = 0;
	net.net_e  = work.x_net;
	if (ns_nullhost(work) && net.long_e == 0) {
		if (!port)
			return ("*.*");
		(void) snprintf(mybuf, sizeof mybuf, "*.0x%x", port);
		return (mybuf);
	}

	if (memcmp(ns_bh, work.x_host.c_host, 6) == 0)
		host = "any";
	else if (memcmp(ns_nullh, work.x_host.c_host, 6) == 0)
		host = "*";
	else {
		q = work.x_host.c_host;
		(void) snprintf(chost, sizeof chost, "0x%02x%02x%02x%02x%02x%02x",
			q[0], q[1], q[2], q[3], q[4], q[5]);
		host = chost;
	}
	if (port)
		(void) snprintf(cport, sizeof cport, ".0x%x", htons(port));
	else
		*cport = '\0';

	(void) snprintf(mybuf, sizeof mybuf, "0x%x.%s%s",
	    ntohl(net.long_e), host, cport);
	return (mybuf);
@


1.30
log
@Cleanup last commit here:
- pass netname4() a struct sockaddr_in * and check it for NULL
- netname6() already deals with NULL mask so remove unneeded check in netname()
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.29 2004/06/15 16:55:38 deraadt Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.29 2004/06/15 16:55:38 deraadt Exp $";
d249 1
a249 1
			p_sockaddr(rti_info[RTAX_GATEWAY],
d252 1
a252 1
			    WID_GW(sa->sa_family));
d254 1
a254 1
			printf("%-*s ", 16, "default");
@


1.29
log
@do not crash on 'route flush'
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.28 2004/06/12 09:40:49 claudio Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.28 2004/06/12 09:40:49 claudio Exp $";
d514 1
a514 1
netname4(in_addr_t in, in_addr_t mask)
d518 1
d522 1
a522 1
	mask = ntohl(mask);
d658 1
a658 1
		    mask ? ((struct sockaddr_in *)mask)->sin_addr.s_addr : NULL);
d662 1
a662 1
		    mask ? (struct sockaddr_in6 *)mask : NULL);
@


1.28
log
@Make route show output similar to netstat -r output.
OK cedric@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.27 2004/06/06 17:08:23 cedric Exp $	*/
d37 1
a37 1
static const char rcsid[] = "$OpenBSD: show.c,v 1.27 2004/06/06 17:08:23 cedric Exp $";
d657 1
a657 1
		    ((struct sockaddr_in *)mask)->sin_addr.s_addr);
d661 1
a661 1
		    (struct sockaddr_in6 *)mask);
@


1.27
log
@add new "-src" and "-srcmask" modifiers to make it possible to add a source
selector part to the routing table entry. complements existing "-dst" and
"-dstmask". typical use:

   route add -src 20.20.20.22 20.20.20.21
   route add -src 192.168.1.0/24 -dst 192.168.2.0/24 20.20.20.21

useful for example to implement symetrical routing on multihomed boxes,
or to better select which packets to send to gif/tun/... tunnels.
new '-S' flag similar to netstat one. ok deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.26 2003/08/26 08:33:12 itojun Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: show.c,v 1.26 2003/08/26 08:33:12 itojun Exp $";
d52 3
a59 2
#include "keywords.h"

d62 1
d67 3
a69 5
/* XXX: things from route.c */
extern char *routename(struct sockaddr *);
extern char *netname(struct sockaddr *);
extern char *ns_print(struct sockaddr_ns *);
extern int nflag, Sflag;
d104 10
a113 9
static void p_rtentry(struct rt_msghdr *);
static void p_sockaddr(struct sockaddr *, int, int);
static void p_flags(int, char *);
static void pr_rthdr(int);
static void pr_family(int);

int	keyword(char *);
void	usage(char *);
void	show(int argc, char *argv[]);
d119 1
a119 1
show(int argc, char *argv[])
d124 1
a124 1
	int mib[6], af = 0;
a126 33
        if (argc > 1) {
                argv++;
                if (argc == 2 && **argv == '-')
                    switch (keyword(*argv + 1)) {
                        case K_INET:
                                af = AF_INET;
                                break;
#ifdef INET6
                        case K_INET6:
                                af = AF_INET6;
                                break;
#endif
                        case K_XNS:
                                af = AF_NS;
                                break;
                        case K_IPX:
                                af = AF_IPX;
                                break;
                        case K_LINK:
                                af = AF_LINK;
                                break;
                        case K_ISO:
                        case K_OSI:
                                af = AF_ISO;
                                break;
                        case K_X25:
                                af = AF_CCITT;
                                break;
                        default:
                                goto bad;
                } else
bad:                    usage(*argv);
        }
d130 1
a130 1
	mib[3] = 0;
d155 1
a155 1
			if (af && sa->sa_family != af)
d157 1
a157 1
			p_rtentry(rtm);
d164 15
a178 3
#define	WID_DST		16	/* width of destination column */
#define WID_SRC		16	/* width of source column */
#define	WID_GW		18	/* width of gateway column */
d183 24
d208 1
a208 1
pr_rthdr(int af)
d210 9
a218 11
	if (af == AF_INET && Sflag) {
		printf("%-*.*s %-*.*s %-*.*s %-6.6s\n",
		    WID_SRC, WID_SRC, "Source",
		    WID_DST, WID_DST, "Destination",
		    WID_GW, WID_GW, "Gateway",
		    "Flags");
	} else {
		printf("%-*.*s %-*.*s %-6.6s\n",
		    WID_DST, WID_DST, "Destination",
		    WID_GW, WID_GW, "Gateway",
		    "Flags");
d225 2
a226 2
static void
p_rtentry(rtm)
d228 1
d230 24
a253 35
	struct sockaddr *sa = (struct sockaddr *)(rtm + 1), *sa2;
#ifdef notdef
	static int masks_done, banner_printed;
#endif
	static int old_af;
	int i, af = 0, interesting = RTF_UP | RTF_GATEWAY | RTF_HOST |
	    RTF_MASK | RTF_SOURCE;

#ifdef notdef
	/* for the moment, netmasks are skipped over */
	if (!banner_printed) {
		printf("Netmasks:\n");
		banner_printed = 1;
	}
	if (masks_done == 0) {
		if (rtm->rtm_addrs != RTA_DST ) {
			masks_done = 1;
			af = sa->sa_family;
		}
	} else
#endif
		af = sa->sa_family;
	if (old_af != af) {
		old_af = af;
		pr_family(af);
		pr_rthdr(af);
	}
	if (af == AF_INET && Sflag) {
		if (rtm->rtm_addrs & RTA_SRC) {
			for (sa2 = sa, i = 1; i < RTA_SRC; i <<= 1)
				if (rtm->rtm_addrs & i)
					sa2 = (struct sockaddr *)(ROUNDUP(
					    sa2->sa_len) + (char *)sa2);
			p_sockaddr(sa2, 0, 16);
		} else
d256 11
a266 8
	if (!(rtm->rtm_addrs & RTA_GATEWAY))
		p_sockaddr(sa, 0, 36);
	else {
		p_sockaddr(sa, rtm->rtm_flags, 16);
		sa = (struct sockaddr *)(ROUNDUP(sa->sa_len) + (char *)sa);
		p_sockaddr(sa, 0, 18);
	}
	p_flags(rtm->rtm_flags & interesting, "%-6.6s ");
d273 1
a273 1
static void
d300 3
d316 5
d322 5
a326 8
static void
p_sockaddr(sa, flags, width)
	struct sockaddr *sa;
	int flags, width;
{
	char workbuf[128], *cplim;
	char *cp = workbuf;
	int len = sizeof workbuf;
d328 4
a331 1
	switch(sa->sa_family) {
d333 3
a335 1
	case AF_LINK:
d337 14
a350 30
		struct sockaddr_dl *sdl = (struct sockaddr_dl *)sa;

		if (sdl->sdl_nlen == 0 && sdl->sdl_alen == 0 &&
		    sdl->sdl_slen == 0)
			(void) snprintf(workbuf, sizeof workbuf,
			    "link#%d", sdl->sdl_index);
		else {
			switch (sdl->sdl_type) {
			case IFT_ETHER:
			    {
				int i;
				u_char *lla = (u_char *)sdl->sdl_data +
				    sdl->sdl_nlen;

				cplim = "";
				for (i = 0; i < sdl->sdl_alen; i++, lla++) {
					snprintf(cp, len, "%s%x", cplim, *lla);
					len -= strlen(cp);
					cp += strlen(cp);
					if (len <= 0)
						break;	/* overflow */
					cplim = ":";
				}
				cp = workbuf;
				break;
			    }
			default:
				cp = link_ntoa(sdl);
				break;
			}
d352 5
d359 22
d382 15
a396 3
	case AF_INET:
	    {
		struct sockaddr_in *sin = (struct sockaddr_in *)sa;
d398 5
a402 2
		if (sin->sin_addr.s_addr == 0)
			cp = "default";
d404 10
a413 3
			cp = (flags & RTF_HOST) ? routename(sa) : netname(sa);
		break;
	    }
d418 1
a418 1
		struct sockaddr_in6 *sin = (struct sockaddr_in6 *)sa;
d420 16
a435 7
		cp = IN6_IS_ADDR_UNSPECIFIED(&sin->sin6_addr) ? "default" :
			((flags & RTF_HOST) ?
			routename(sa) :	netname(sa));
		/* make sure numeric address is not truncated */
		if (strchr(cp, ':') != NULL && strlen(cp) > width)
			width = strlen(cp);
		break;
d437 1
a437 1
#endif /* INET6 */
d440 11
a450 1
		cp = ns_print((struct sockaddr_ns *)sa);
d454 6
a459 2
	    {
		u_char *s = (u_char *)sa->sa_data, *slim;
d461 16
a476 8
		slim =  sa->sa_len + (u_char *) sa;
		cplim = cp + sizeof(workbuf) - 6;
		snprintf(cp, len, "(%d)", sa->sa_family);
		len -= strlen(cp);
		cp += strlen(cp);
		if (len <= 0) {
			cp = workbuf;
			break;		/* overflow */
d478 138
a615 12
		while (s < slim && cp < cplim) {
			snprintf(cp, len, " %02x", *s++);
			len -= strlen(cp);
			cp += strlen(cp);
			if (len <= 0)
				break;		/* overflow */
			if (s < slim) {
				snprintf(cp, len, "%02x", *s++);
				len -= strlen(cp);
				cp += strlen(cp);
				if (len <= 0)
					break;		/* overflow */
d617 5
d623 118
a740 2
		cp = workbuf;
	    }
d742 40
a781 2
	if (width < 0 )
		printf("%s ", cp);
d783 6
a788 4
		if (nflag)
			printf("%-*s ", width, cp);
		else
			printf("%-*.*s ", width, width, cp);
d790 8
d800 2
a801 4
static void
p_flags(f, format)
	int f;
	char *format;
d803 2
a804 2
	char name[33], *flags;
	const struct bits *p = bits;
d806 12
a817 5
	for (flags = name; p->b_mask && flags < &name[sizeof name-2]; p++)
		if (p->b_mask & f)
			*flags++ = p->b_val;
	*flags = '\0';
	printf(format, name);
d819 1
@


1.26
log
@mark cloned route with RTF_CLONED.  remove RTF_CLONED route when clone parent
disappers.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.25 2003/07/02 21:44:58 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: show.c,v 1.25 2003/07/02 21:44:58 deraadt Exp $";
d69 1
a69 1
extern int nflag;
d100 1
d107 1
a107 1
static void pr_rthdr(void);
d197 1
d204 1
a204 1
pr_rthdr()
d206 12
a217 4
	printf("%-*.*s %-*.*s %-6.6s\n",
	    WID_DST, WID_DST, "Destination",
	    WID_GW, WID_GW, "Gateway",
	    "Flags");
d227 1
a227 1
	struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
d232 2
a233 1
	int af = 0, interesting = RTF_UP | RTF_GATEWAY | RTF_HOST | RTF_MASK;
d252 11
a262 1
		pr_rthdr();
d264 1
a264 1
	if (rtm->rtm_addrs == RTA_DST)
@


1.25
log
@missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.24 2003/06/26 16:35:21 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: show.c,v 1.24 2003/06/26 16:35:21 deraadt Exp $";
d79 1
a79 1
	short	b_mask;
d98 2
@


1.24
log
@ansi and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.23 2003/06/02 20:06:16 millert Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: show.c,v 1.23 2003/06/02 20:06:16 millert Exp $";
d109 1
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.22 2003/03/13 09:09:27 deraadt Exp $	*/
d37 1
a37 1
static char *rcsid = "$OpenBSD: show.c,v 1.22 2003/03/13 09:09:27 deraadt Exp $";
d114 1
a114 3
show(argc, argv)
	int argc;
	char **argv;
@


1.22
log
@lots of sprintf -> snprintf and strcpy -> strlcpy; checked by tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.21 2002/02/16 21:27:37 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char *rcsid = "$OpenBSD: show.c,v 1.21 2002/02/16 21:27:37 millert Exp $";
@


1.21
log
@Part one of userland __P removal.  Done with a simple regexp with some minor hand editing to make comments line up correctly.  Another pass is forthcoming that handles the cases that could not be done automatically.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.20 2001/07/07 18:26:20 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.20 2001/07/07 18:26:20 deraadt Exp $";
d308 1
d318 25
a342 12
			(void) sprintf(workbuf, "link#%d", sdl->sdl_index);
		else switch (sdl->sdl_type) {
		case IFT_ETHER:
		    {
			int i;
			u_char *lla = (u_char *)sdl->sdl_data +
			    sdl->sdl_nlen;

			cplim = "";
			for (i = 0; i < sdl->sdl_alen; i++, lla++) {
				cp += sprintf(cp, "%s%x", cplim, *lla);
				cplim = ":";
a343 6
			cp = workbuf;
			break;
		    }
		default:
			cp = link_ntoa(sdl);
			break;
d384 7
a390 1
		cp += sprintf(cp, "(%d)", sa->sa_family);
d392 12
a403 3
			cp += sprintf(cp, " %02x", *s++);
			if (s < slim)
				cp += sprintf(cp, "%02x", *s++);
@


1.20
log
@major -Wall cleanup, almost complete
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.19 2000/11/15 01:45:48 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.19 2000/11/15 01:45:48 angelos Exp $";
d70 3
a72 3
extern char *routename __P((struct sockaddr *));
extern char *netname __P((struct sockaddr *));
extern char *ns_print __P((struct sockaddr_ns *));
d105 5
a109 5
static void p_rtentry __P((struct rt_msghdr *));
static void p_sockaddr __P((struct sockaddr *, int, int));
static void p_flags __P((int, char *));
static void pr_rthdr __P((void));
static void pr_family __P((int));
@


1.19
log
@Accept -inet/-inet6 etc. in route show command.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.18 2000/09/24 01:02:24 millert Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.18 2000/09/24 01:02:24 millert Exp $";
d111 3
d123 1
a123 1
	char *buf = NULL, *next, *lim;
@


1.18
log
@If the route add/delete fails exit w/ 1 instead of 0
Remove register decls and make return foo vs. return (foo) consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.17 2000/07/27 20:12:25 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.17 2000/07/27 20:12:25 angelos Exp $";
d61 2
d122 2
a123 1
	int mib[6];
d125 33
d185 3
@


1.17
log
@Don't show or delete IPsec flows with the route command -- this was a
kludge to begin with, and it's about time we get rid of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.16 2000/01/14 19:59:17 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.16 2000/01/14 19:59:17 deraadt Exp $";
d117 1
a117 1
	register struct rt_msghdr *rtm;
d176 1
a176 1
	register struct rt_msghdr *rtm;
d178 1
a178 1
	register struct sockaddr *sa = (struct sockaddr *)(rtm + 1);
d265 1
a265 1
	register char *cp = workbuf;
d271 1
a271 1
		register struct sockaddr_dl *sdl = (struct sockaddr_dl *)sa;
d279 2
a280 2
			register int i;
			register u_char *lla = (u_char *)sdl->sdl_data +
d300 1
a300 1
		register struct sockaddr_in *sin = (struct sockaddr_in *)sa;
d330 1
a330 1
		register u_char *s = (u_char *)sa->sa_data, *slim;
d355 1
a355 1
	register int f;
d359 1
a359 1
	register const struct bits *p = bits;
@


1.16
log
@show blackhole flag; ura@@hiru.aoba.yokohama.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.15 2000/01/10 01:35:06 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.15 2000/01/10 01:35:06 angelos Exp $";
a106 1
static void pr_encaphdr __P((void));
a107 1
static void encap_print __P((struct rt_msghdr *));                   
d202 1
a202 8
		if (af != PF_KEY)
			pr_rthdr();
		else
			pr_encaphdr();
	}
	if (af == PF_KEY) {
		encap_print(rtm);
		return;
a214 13
/*                    
 * Print header for PF_KEY entries.
 */                              
void                  
pr_encaphdr()             
{
/*
        printf("%-40s %-15s %s\n",
               "Source/Destination Networks", "Protocol/Ports",
               "SA(Address/SPI/Proto)");
*/
}

a244 3
	case PF_KEY:
		afname = "IPsec";
		break;
a365 69
}

static void
encap_print(rtm)
        register struct rt_msghdr *rtm;
{
        struct sockaddr_encap *sen1 = (struct sockaddr_encap *)(rtm + 1);
	struct protoent *prnt = NULL;
        struct sockaddr_encap *sen3;
	struct sockaddr_encap *sen2;

        u_char buffer[40];

        bzero(buffer, sizeof(buffer));

	sen3 = (struct sockaddr_encap *) (ROUNDUP(sen1->sen_len) +
					  (char *)sen1);
	sen2 = (struct sockaddr_encap *) (ROUNDUP(sen3->sen_len) +
					  (char *)sen3);

	if (sen1->sen_type == SENT_IP4) {
		inet_ntop(AF_INET, &sen1->sen_ip_src, buffer, sizeof(buffer));
        	printf("%s/", buffer);
		inet_ntop(AF_INET, &sen2->sen_ip_src, buffer, sizeof(buffer));
        	printf("%s:%u -> ", buffer, ntohs(sen1->sen_sport));
		inet_ntop(AF_INET, &sen1->sen_ip_dst, buffer, sizeof(buffer));
        	printf("%s/", buffer);
		inet_ntop(AF_INET, &sen2->sen_ip_dst, buffer, sizeof(buffer));
        	printf("%s:%u ", buffer, ntohs(sen1->sen_dport));

		if (sen1->sen_proto) {
			prnt = getprotobynumber(sen1->sen_proto);
			if (prnt)
				printf("(%s) ", prnt->p_name);
			else
				printf("(%u) ", sen1->sen_proto);
		}
		else
			printf("(all) ");
	}

#ifdef INET6
	if (sen1->sen_type == SENT_IP6) {
		inet_ntop(AF_INET6, &sen1->sen_ip6_src, buffer, sizeof(buffer));
        	printf("%s:%d ->", buffer, ntohs(sen1->sen_ip6_sport));
		inet_ntop(AF_INET6, &sen1->sen_ip6_dst, buffer, sizeof(buffer));
        	printf("%s:%d ", buffer, ntohs(sen1->sen_ip6_dport));

		if (sen1->sen_ip6_proto) {
			prnt = getprotobynumber(sen1->sen_ip6_proto);
			if (prnt)
				printf("(%s) ", prnt->p_name);
			else
				printf("(%u) ", sen1->sen_ip6_proto);
		}
		else
			printf("(all) ");
	}

	if (sen3->sen_type == SENT_IPSP6)
		printf("%s/%08x/%-lu\n",
		       inet_ntop(AF_INET6, &sen3->sen_ipsp6_dst, buffer,
		       sizeof(buffer)),
		       ntohl(sen3->sen_ipsp6_spi), sen3->sen_ipsp6_sproto);
#endif /* INET6 */

	if (sen3->sen_type == SENT_IPSP)
		printf("%s/%08x/%-lu\n", inet_ntoa(sen3->sen_ipsp_dst),
		       ntohl(sen3->sen_ipsp_spi), sen3->sen_ipsp_sproto);
@


1.15
log
@Handle wildcard case better.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.14 2000/01/10 01:04:20 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.14 2000/01/10 01:04:20 angelos Exp $";
d89 1
@


1.14
log
@Change format of IPsec flows (yet again).
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.13 2000/01/10 00:54:35 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.13 2000/01/10 00:54:35 angelos Exp $";
d397 1
a399 1
	struct protoent *prnt;
d420 7
a426 3
		prnt = getprotobynumber(sen1->sen_proto);
		if (prnt)
			printf("(%s) ", prnt->p_name);
d428 1
a428 1
			printf("(%u) ", sen1->sen_proto);
d438 7
a444 3
		prnt = getprotobynumber(sen1->sen_ip6_proto);
		if (prnt)
			printf("(%s) ", prnt->p_name);
d446 1
a446 1
			printf("(%u) ", sen1->sen_ip6_proto);
@


1.13
log
@Fix printing SAs.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.12 2000/01/09 23:00:13 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.12 2000/01/09 23:00:13 angelos Exp $";
d229 1
d233 1
d399 1
d413 2
d416 9
a424 2
        	printf("%-15s %-5u/%-5u/%-5u ", buffer, sen1->sen_proto,
		       ntohs(sen1->sen_sport), ntohs(sen1->sen_dport));
d430 1
a430 1
        	printf("%s/", buffer);
d432 7
a438 2
        	printf("%-39s %-5u/%-5u/%-5u ", buffer, sen1->sen_ip6_proto,
		       ntohs(sen1->sen_ip6_sport), ntohs(sen1->sen_ip6_dport));
@


1.12
log
@Transport ports are in network order.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.11 1999/12/20 07:45:09 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.11 1999/12/20 07:45:09 angelos Exp $";
d395 2
a396 6
        struct sockaddr_encap *sen3 = (struct sockaddr_encap *)
				      ((u_char *)sen1 + sizeof(*sen1));
#if 0
	struct sockaddr_encap *sen2 = (struct sockaddr_encap *)
				      ((u_char *)sen3 + sizeof(*sen3));
#endif /* 0 */
d401 5
@


1.11
log
@Add support for printing IPv6 addresses in IPsec flows. Formatting is
just plain ugly, given the possible length variances of addresses now;
a better display method is needed.

Also, netmasks are no longer printed for either IPv4 or IPv6 IPsec
flows (they are not printed in the other protocols display either).
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.10 1999/12/08 07:55:54 itojun Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.10 1999/12/08 07:55:54 itojun Exp $";
d411 1
a411 1
		       sen1->sen_sport, sen1->sen_dport);
d417 1
a417 1
        	printf("%s/", buffer, sen1->sen_ip6_sport);
d420 1
a420 1
		       sen1->sen_ip6_sport, sen1->sen_ip6_dport);
@


1.10
log
@ipv6 support from KAME (needs no libc upgrade).  regen keywords.[ch].
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.9 1999/09/22 05:10:04 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.9 1999/09/22 05:10:04 deraadt Exp $";
d184 1
a184 1
	int af = 0, interesting = RTF_UP | RTF_GATEWAY | RTF_HOST;
d229 3
a231 3
        printf("%-31s %-5s %-31s %-5s %-5s %-26s\n",
            "Source address/netmask", "Port", "Destination address/netmask",
            "Port", "Proto", "SA(Address/SPI/Proto)");
d397 1
d399 34
a432 23
				      ((u_char *)sen3 + sizeof(*sen1));
        u_char buffer[32];
        int i;

        bzero(buffer, 32);
        strncpy(buffer, inet_ntoa(sen1->sen_ip_src), 15);
        i = strlen(buffer);
        strncpy(buffer + i, "/", 1);
        i++;
        strncpy(buffer + i, inet_ntoa(sen2->sen_ip_src), 15);

        printf("%-31s %-5u ", buffer, sen1->sen_sport);

        bzero(buffer, 32);
        strncpy(buffer, inet_ntoa(sen1->sen_ip_dst), 15);
        i = strlen(buffer);
        strncpy(buffer + i, "/", 1);
        i++;
        strncpy(buffer + i, inet_ntoa(sen2->sen_ip_dst), 15);

        printf("%-31s %-5u %-5u ", buffer, sen1->sen_dport, sen1->sen_proto);
        printf("%s/%08x/%-lu\n", inet_ntoa(sen3->sen_ipsp_dst),
               ntohl(sen3->sen_ipsp_spi), sen3->sen_ipsp_sproto);
@


1.9
log
@routing interface sends aligned to long word boundaries; itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.8 1999/02/24 22:56:02 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.8 1999/02/24 22:56:02 angelos Exp $";
d247 5
d330 15
@


1.8
log
@Grok PF_KEY.
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.7 1998/09/21 08:31:46 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.7 1998/09/21 08:31:46 deraadt Exp $";
d73 4
d216 1
a216 3
		if (sa->sa_len == 0)
			sa->sa_len = sizeof(in_addr_t);
		sa = (struct sockaddr *)(sa->sa_len + (char *)sa);
@


1.7
log
@bad sysctl(), malloc(0), and memory leaks fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.6 1998/07/09 01:32:12 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.6 1998/07/09 01:32:12 deraadt Exp $";
d56 1
a56 1
#include <net/encap.h>
d199 1
a199 1
		if (af != AF_ENCAP)
d204 1
a204 1
	if (af == AF_ENCAP) {
d222 1
a222 1
 * Print header for AF_ENCAP entries.
d257 1
a257 1
	case AF_ENCAP:
@


1.6
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.5 1997/12/08 03:55:25 deraadt Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.5 1997/12/08 03:55:25 deraadt Exp $";
d115 1
a115 1
	char *buf, *next, *lim;
d129 10
a138 7
	if ((buf = malloc(needed)) == 0) {
		printf("out of space\n");
		exit(1);
	}
	if (sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
		perror("sysctl of routing table");
		exit(1);
a139 1
	lim  = buf + needed;
d143 6
a148 3
	for (next = buf; next < lim; next += rtm->rtm_msglen) {
		rtm = (struct rt_msghdr *)next;
		p_rtentry(rtm);
@


1.5
log
@start at appletalk...
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.4 1997/10/02 02:10:57 angelos Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.4 1997/10/02 02:10:57 angelos Exp $";
d195 1
a195 1
		  pr_rthdr();
d197 1
a197 1
		  pr_encaphdr();
d333 1
a333 1
			    cp += sprintf(cp, "%02x", *s++);
@


1.4
log
@Sync "route show" with "netstat -rn".
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.3 1997/08/26 13:50:44 niklas Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.3 1997/08/26 13:50:44 niklas Exp $";
d254 3
@


1.3
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: show.c,v 1.1 1996/11/15 18:01:41 gwr Exp $	*/
d41 1
a41 1
static char *rcsid = "$OpenBSD: show.c,v 1.1 1996/11/15 18:01:41 gwr Exp $";
d56 2
d102 1
d104 1
d194 8
a201 1
		pr_rthdr();
d216 10
d252 3
d360 32
@


1.2
log
@Fix "route show" on alpha.  Some parts from Theo.
@
text
@d1 1
d41 1
a41 1
static char *rcsid = "$NetBSD: show.c,v 1.1 1996/11/15 18:01:41 gwr Exp $";
@


1.1
log
@merge netbsd changes for show command
yet more buf oflows (provided by netbsd!)
an attempt at 64 bit cleanliness
-Wall
@
text
@d196 1
a196 1
			sa->sa_len = sizeof(long);
@
