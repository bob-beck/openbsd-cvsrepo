head	1.31;
access;
symbols
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.8
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.6
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.4
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.6
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.4
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.31
date	2015.05.15.13.32.08;	author jsg;	state Exp;
branches;
next	1.30;
commitid	Kj1U6D4ZSxqF8U53;

1.30
date	2015.05.07.01.55.43;	author jsg;	state Exp;
branches;
next	1.29;
commitid	KhO2CJgSFKm4Q3Hj;

1.29
date	2013.04.16.14.55.23;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.07.15.30.15;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.07.16.21.35;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.30.21.35.55;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.27.05.04.06;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.07.16.34.20;	author drahn;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.25.14.55.44;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.14.06.55.10;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.25.01.49.27;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.24.22.16.14;	author drahn;	state Exp;
branches;
next	1.17;

1.17
date	2007.02.24.22.08.20;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.23.06.12.43;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.15.20.36.03;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.15.18.05.05;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.15.06.28.11;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2007.02.13.20.54.10;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.13.18.32.57;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.12.16.11.11;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.12.15.09.03;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2007.02.07.16.26.49;	author drahn;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.28.15.42.30;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.25.18.10.29;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.30.14.24.39;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.21.07.46.48;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.19.00.45.14;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.18.16.42.09;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2005.02.17.22.10.35;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@add some missing splx() calls
ok deraadt@@ kettenis@@ krw@@
@
text
@/*	$OpenBSD: pxa27x_udc.c,v 1.30 2015/05/07 01:55:43 jsg Exp $ */

/*
 * Copyright (c) 2007 Dale Rahn <drahn@@openbsd.org>
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/timeout.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbf.h>
#include <dev/usb/usbfvar.h>

#include <arm/xscale/pxa2x0reg.h>
#include <arm/xscale/pxa2x0var.h>
#include <arm/xscale/pxa2x0_gpio.h>

#include <arm/xscale/pxa27x_udc.h>

#include "usbf.h"

struct pxaudc_xfer {
	struct usbf_xfer	 xfer;
	u_int16_t		 frmlen;
};

struct pxaudc_pipe {
	struct usbf_pipe	 pipe;
//	LIST_ENTRY(pxaudc_pipe)	 list;
};

void		 pxaudc_enable(struct pxaudc_softc *);
void		 pxaudc_disable(struct pxaudc_softc *);
void		 pxaudc_read_ep0(struct pxaudc_softc *, struct usbf_xfer *);
void		 pxaudc_read_epN(struct pxaudc_softc *sc, int ep);
void		 pxaudc_write_ep0(struct pxaudc_softc *, struct usbf_xfer *);
void		 pxaudc_write(struct pxaudc_softc *, struct usbf_xfer *);
void		 pxaudc_write_epN(struct pxaudc_softc *sc, int ep);

int		 pxaudc_connect_intr(void *);
int		 pxaudc_intr(void *);
void		 pxaudc_intr1(struct pxaudc_softc *);
void		 pxaudc_ep0_intr(struct pxaudc_softc *);
void		 pxaudc_epN_intr(struct pxaudc_softc *sc, int ep, int isr);

usbf_status	 pxaudc_open(struct usbf_pipe *);
void		 pxaudc_softintr(void *);
usbf_status	 pxaudc_allocm(struct usbf_bus *, struct usb_dma *, u_int32_t);
void		 pxaudc_freem(struct usbf_bus *, struct usb_dma *);
struct usbf_xfer *pxaudc_allocx(struct usbf_bus *);
void		 pxaudc_freex(struct usbf_bus *, struct usbf_xfer *);

usbf_status	 pxaudc_ctrl_transfer(struct usbf_xfer *);
usbf_status	 pxaudc_ctrl_start(struct usbf_xfer *);
void		 pxaudc_ctrl_abort(struct usbf_xfer *);
void		 pxaudc_ctrl_done(struct usbf_xfer *);
void		 pxaudc_ctrl_close(struct usbf_pipe *);

usbf_status	 pxaudc_bulk_transfer(struct usbf_xfer *);
usbf_status	 pxaudc_bulk_start(struct usbf_xfer *);
void		 pxaudc_bulk_abort(struct usbf_xfer *);
void		 pxaudc_bulk_done(struct usbf_xfer *);
void		 pxaudc_bulk_close(struct usbf_pipe *);

struct cfdriver pxaudc_cd = {
	NULL, "pxaudc", DV_DULL
};

#if NUSBF > 0

struct usbf_bus_methods pxaudc_bus_methods = {
	pxaudc_open,
	pxaudc_softintr,
	pxaudc_allocm,
	pxaudc_freem,
	pxaudc_allocx,
	pxaudc_freex
};

struct usbf_pipe_methods pxaudc_ctrl_methods = {
	pxaudc_ctrl_transfer,
	pxaudc_ctrl_start,
	pxaudc_ctrl_abort,
	pxaudc_ctrl_done,
	pxaudc_ctrl_close
};

struct usbf_pipe_methods pxaudc_bulk_methods = {
	pxaudc_bulk_transfer,
	pxaudc_bulk_start,
	pxaudc_bulk_abort,
	pxaudc_bulk_done,
	pxaudc_bulk_close
};

#endif /* NUSBF > 0 */

#define DEVNAME(sc)	((sc)->sc_bus.bdev.dv_xname)

#define CSR_READ_4(sc, reg) \
	bus_space_read_4((sc)->sc_iot, (sc)->sc_ioh, (reg))
#define CSR_WRITE_4(sc, reg, val) \
	bus_space_write_4((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define CSR_WRITE_1(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define CSR_SET_4(sc, reg, val) \
	CSR_WRITE_4((sc), (reg), CSR_READ_4((sc), (reg)) | (val))
#define CSR_CLR_4(sc, reg, val) \
	CSR_WRITE_4((sc), (reg), CSR_READ_4((sc), (reg)) & ~(val))

#ifndef PXAUDC_DEBUG
#define DPRINTF(l, x)	do {} while (0)
#else
int pxaudcdebug = 0;
#define DPRINTF(l, x)	if ((l) <= pxaudcdebug) printf x; else {}
#endif

int
pxaudc_match(void)
{
	if ((cputype & ~CPU_ID_XSCALE_COREREV_MASK) != CPU_ID_PXA27X)
		return (0);

	return (1);
}

void
pxaudc_attach(struct pxaudc_softc *sc, void *aux)
{
	struct pxaip_attach_args	*pxa = aux;
#if NUSBF > 0
	int i;
#endif

	sc->sc_iot = pxa->pxa_iot;
	if (bus_space_map(sc->sc_iot, PXA2X0_USBDC_BASE, PXA2X0_USBDC_SIZE, 0,
	    &sc->sc_ioh)) {
		printf(": cannot map mem space\n");
		return;
	}
	sc->sc_size = PXA2X0_USBDC_SIZE;

	printf(": USB Device Controller\n");

	bus_space_barrier(sc->sc_iot, sc->sc_ioh, 0, sc->sc_size,
	    BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE);

	/* Set up GPIO pins and disable the controller. */
	pxaudc_disable(sc);

#if NUSBF > 0
	/* Establish USB device interrupt. */
	sc->sc_ih = pxa2x0_intr_establish(PXA2X0_INT_USB, IPL_USB,
	    pxaudc_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf(": unable to establish interrupt\n");
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_size);
		sc->sc_size = 0;
		return;
	}

	/* Establish device connect interrupt. */
#if 0
	sc->sc_conn_ih = pxa2x0_gpio_intr_establish(PXA_USB_DEVICE_PIN, /* XXX */
	    IST_EDGE_BOTH, IPL_USB, pxaudc_connect_intr, sc, "usbc");
#endif
	sc->sc_conn_ih = pxa2x0_gpio_intr_establish(sc->sc_gpio_detect,
	    IST_EDGE_BOTH, IPL_USB, pxaudc_connect_intr, sc, "usbc");
	if (sc->sc_conn_ih == NULL) {
		printf(": unable to establish connect interrupt\n");
		pxa2x0_intr_disestablish(sc->sc_ih);
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_size);
		sc->sc_ioh = 0;
		sc->sc_size = 0;
		return;
	}

	/* Set up the bus struct. */
	sc->sc_bus.methods = &pxaudc_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct pxaudc_pipe);
	sc->sc_bus.ep0_maxp = PXAUDC_EP0MAXP;
	sc->sc_bus.usbrev = USBREV_1_1;
	sc->sc_bus.dmatag = pxa->pxa_dmat;
	sc->sc_npipe = 0;	/* ep0 is always there. */

	sc->sc_ep_map[0] = 0;
	/* 16 == max logical endpoints */
	for (i = 1; i < 16; i++) {
		sc->sc_ep_map[i] = -1;
	}

	/* Attach logical device and function. */
	(void)config_found((struct device *)sc, &sc->sc_bus, NULL);

	/* Enable the controller unless we're now acting as a host. */
	if (!sc->sc_is_host())
		pxaudc_enable(sc);
#endif
}

int
pxaudc_detach(struct pxaudc_softc *sc, int flags)
{
	if (sc->sc_conn_ih != NULL)
		pxa2x0_gpio_intr_disestablish(sc->sc_conn_ih);

	if (sc->sc_ih != NULL)
		pxa2x0_intr_disestablish(sc->sc_ih);

	if (sc->sc_size) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_size);
		sc->sc_size = 0;
	}

	return (0);
}

int
pxaudc_activate(struct pxaudc_softc *self, int act)
{
	struct pxaudc_softc *sc = (struct pxaudc_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		pxaudc_disable(sc);
		break;
	case DVACT_RESUME:
		pxaudc_enable(sc);
		break;
	}
	return 0;
}

/*
 * Register manipulation
 */

#if 0
static void
pxaudc_dump_regs(struct pxaudc_softc *sc)
{
	printf("UDCCR\t%b\n", CSR_READ_4(sc, USBDC_UDCCR),
	    USBDC_UDCCR_BITS);
	printf("UDCICR0\t%b\n", CSR_READ_4(sc, USBDC_UDCICR0),
	    USBDC_UDCISR0_BITS);
	printf("UDCICR1\t%b\n", CSR_READ_4(sc, USBDC_UDCICR1),
	    USBDC_UDCISR1_BITS);
	printf("OTGICR\t%b\n", CSR_READ_4(sc, USBDC_UDCOTGICR),
	    USBDC_UDCOTGISR_BITS);
}
#endif

void
pxaudc_enable(struct pxaudc_softc *sc)
{
	int i;

	DPRINTF(10,("pxaudc_enable\n"));

	/* Start the clocks. */
	pxa2x0_clkman_config(CKEN_USBDC, 1);

#if 0
	/* Configure Port 2 for USB device. */
	CSR_WRITE_4(sc, USBDC_UP2OCR, USBDC_UP2OCR_DMPUE |
	    USBDC_UP2OCR_DPPUE | USBDC_UP2OCR_HXOE);
#else
	/* Configure Port 2 for USB device. */
	CSR_WRITE_4(sc, USBDC_UP2OCR, USBDC_UP2OCR_DPPUE | USBDC_UP2OCR_HXOE);
#endif

	CSR_SET_4(sc, USBDC_UDCCR, 0);
	sc->sc_icr0 = 0;
	sc->sc_icr1 = 0;

	for (i = 1; i < PXAUDC_NEP; i++) 
		CSR_WRITE_4(sc, USBDC_UDCECR(i), 0); /* disable endpoints */

	for (i = 1; i < sc->sc_npipe; i++) {
		if (sc->sc_pipe[i] != NULL)  {
			struct usbf_endpoint *ep =
			    sc->sc_pipe[i]->pipe.endpoint;
			u_int32_t cr;
			int dir = usbf_endpoint_dir(ep);
			usb_endpoint_descriptor_t *ed = ep->edesc;

			if (i < 16)
				sc->sc_icr0 |= USBDC_UDCICR0_IE(i);
			else
				sc->sc_icr1 |= USBDC_UDCICR1_IE(i-16);

			cr = USBDC_UDCECR_EE | USBDC_UDCECR_DE;
			cr |= USBDC_UDCECR_ENs(
			    UE_GET_ADDR(ed->bEndpointAddress));
			cr |= USBDC_UDCECR_MPSs(UGETW(ed->wMaxPacketSize));
			cr |= USBDC_UDCECR_ETs(ed->bmAttributes & UE_XFERTYPE);
			if (dir == UE_DIR_IN)
				cr |= USBDC_UDCECR_ED;

			/* XXX - until pipe has cn/in/ain */
			cr |=   USBDC_UDCECR_AISNs(0) | USBDC_UDCECR_INs(0) |
			    USBDC_UDCECR_CNs(1);

			CSR_WRITE_4(sc, USBDC_UDCECR(i), cr);

			/* clear old status */
			CSR_WRITE_4(sc, USBDC_UDCCSR(1), 
			    USBDC_UDCCSR_PC | USBDC_UDCCSR_TRN |
			    USBDC_UDCCSR_SST | USBDC_UDCCSR_FEF);
		}
	}

	CSR_WRITE_4(sc, USBDC_UDCISR0, 0xffffffff); /* clear all */
	CSR_WRITE_4(sc, USBDC_UDCISR1, 0xffffffff); /* clear all */
	CSR_SET_4(sc, USBDC_UDCCSR0, USBDC_UDCCSR0_ACM);


	/* Enable interrupts for configured endpoints. */
	CSR_WRITE_4(sc, USBDC_UDCICR0, USBDC_UDCICR0_IE(0) |
	    sc->sc_icr0);

	CSR_WRITE_4(sc, USBDC_UDCICR1, USBDC_UDCICR1_IERS |
	    USBDC_UDCICR1_IESU | USBDC_UDCICR1_IERU |
	    USBDC_UDCICR1_IECC | sc->sc_icr1);

	/* Enable the controller. */
	CSR_CLR_4(sc, USBDC_UDCCR, USBDC_UDCCR_EMCE);
	CSR_SET_4(sc, USBDC_UDCCR, USBDC_UDCCR_UDE);

	/* Enable USB client on port 2. */
	pxa2x0_gpio_clear_bit(37); /* USB_P2_8 */
}

void
pxaudc_disable(struct pxaudc_softc *sc)
{
	DPRINTF(10,("pxaudc_disable\n"));

	/* Disable the controller. */
	CSR_CLR_4(sc, USBDC_UDCCR, USBDC_UDCCR_UDE);

	/* Disable all interrupts. */
	CSR_WRITE_4(sc, USBDC_UDCICR0, 0);
	CSR_WRITE_4(sc, USBDC_UDCICR1, 0);
	CSR_WRITE_4(sc, USBDC_UDCOTGICR, 0);

	/* Set Port 2 output to "Non-OTG Host with Differential Port". */
	CSR_WRITE_4(sc, USBDC_UP2OCR, USBDC_UP2OCR_HXS | USBDC_UP2OCR_HXOE);

	/* Set "Host Port 2 Transceiver D­ Pull Down Enable". */
	CSR_SET_4(sc, USBDC_UP2OCR, USBDC_UP2OCR_DMPDE);

	/* Stop the clocks. */
	pxa2x0_clkman_config(CKEN_USBDC, 0);

	/* Enable USB host on port 2. */
	pxa2x0_gpio_set_bit(37); /* USB_P2_8 */
}

#if NUSBF > 0

/*
 * Endpoint FIFO handling
 */

void
pxaudc_read_ep0(struct pxaudc_softc *sc, struct usbf_xfer *xfer)
{
	size_t len;
	u_int8_t *p;

	xfer->actlen = CSR_READ_4(sc, USBDC_UDCBCR(0));
	len = MIN(xfer->actlen, xfer->length);
	p = xfer->buffer;

	while (CSR_READ_4(sc, USBDC_UDCCSR0) & USBDC_UDCCSR0_RNE) {
		u_int32_t v = CSR_READ_4(sc, USBDC_UDCDR(0));

		if (len > 0) {
			if (((unsigned)p & 0x3) == 0)
				*(u_int32_t *)p = v;
			else {
				*(p+0) = v & 0xff;
				*(p+1) = (v >> 8) & 0xff;
				*(p+2) = (v >> 16) & 0xff;
				*(p+3) = (v >> 24) & 0xff;
			}
			p += 4;
			len -= 4;
		}
	}

	CSR_WRITE_4(sc, USBDC_UDCCSR0, USBDC_UDCCSR0_SA | USBDC_UDCCSR0_OPC);

	xfer->status = USBF_NORMAL_COMPLETION;
	usbf_transfer_complete(xfer);
}

void
pxaudc_read_epN(struct pxaudc_softc *sc, int ep)
{
	size_t len, tlen;
	u_int8_t *p;
	struct pxaudc_pipe *ppipe;
	struct usbf_pipe *pipe = NULL;
	struct usbf_xfer *xfer = NULL;
	int count;
	u_int32_t csr;

	ppipe = sc->sc_pipe[ep];

	if (ppipe == NULL) {
		return;
	}
	pipe = &ppipe->pipe;
again:
	xfer = SIMPLEQ_FIRST(&pipe->queue);

	if (xfer == NULL) {
		printf("pxaudc_read_epN: ep %d, no xfer\n", ep);
		return;
	}

	count = CSR_READ_4(sc, USBDC_UDCBCR(ep));
	tlen = len = MIN(count, xfer->length - xfer->actlen);
	p = xfer->buffer + xfer->actlen;
	csr = CSR_READ_4(sc, USBDC_UDCCSR(ep));

	if ((csr & USBDC_UDCCSR_PC) && count == 0)
	{
#ifdef DEBUG_RX
	        printf("trans1 complete\n");
#endif
		xfer->status = USBF_NORMAL_COMPLETION;
		usbf_transfer_complete(xfer);
		CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_PC);
		return;
	}

#ifdef DEBUG_RX
	printf("reading data from endpoint %x, len %x csr %x",
		ep, count, csr);
#endif

	while (CSR_READ_4(sc, USBDC_UDCCSR(ep)) & USBDC_UDCCSR_BNE) {
		u_int32_t v = CSR_READ_4(sc, USBDC_UDCDR(ep));

		/* double buffering? */
		if (len > 0) {
			if (((unsigned)p & 0x3) == 0)
				*(u_int32_t *)p = v;
			else {
				*(p+0) = v & 0xff;
				*(p+1) = (v >> 8) & 0xff;
				*(p+2) = (v >> 16) & 0xff;
				*(p+3) = (v >> 24) & 0xff;
			}
			p += 4;
			len -= 4;
			xfer->actlen += 4;
		}
		count -= 4;
	}
	CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_PC);


	if (xfer->length == xfer->actlen || (tlen == 0 && xfer->actlen != 0) ||
	    csr & USBDC_UDCCSR_SP) {
#ifdef DEBUG_RX
		printf("trans2 complete\n");
#endif
		xfer->status = USBF_NORMAL_COMPLETION;
		usbf_transfer_complete(xfer);
	}
	csr = CSR_READ_4(sc, USBDC_UDCCSR(ep));
#ifdef DEBUG_RX
	printf("csr now %x len %x\n",
	    csr, CSR_READ_4(sc, USBDC_UDCBCR(ep)));
#endif
	if (csr & USBDC_UDCCSR_PC)
		goto again;
}

void
pxaudc_write_ep0(struct pxaudc_softc *sc, struct usbf_xfer *xfer)
{
	struct pxaudc_xfer *lxfer = (struct pxaudc_xfer *)xfer;
	u_int32_t len;
	u_int8_t *p;

	if (lxfer->frmlen > 0) {
		xfer->actlen += lxfer->frmlen;
		lxfer->frmlen = 0;
	}

	DPRINTF(11,("%s: ep0 ctrl-in, xfer=%p, len=%u, actlen=%u\n",
	    DEVNAME(sc), xfer, xfer->length, xfer->actlen));

	if (xfer->actlen >= xfer->length) {
		sc->sc_ep0state = EP0_SETUP;
		usbf_transfer_complete(xfer);
		return;
	}

	sc->sc_ep0state = EP0_IN;

	p = (u_char *)xfer->buffer + xfer->actlen;
	len = xfer->length - xfer->actlen;
	len = MIN(len, PXAUDC_EP0MAXP);
	lxfer->frmlen = len;

	while (len >= 4) {
		u_int32_t v;

		if (((unsigned)p & 0x3) == 0)
			v = *(u_int32_t *)p;
		else {
			v = *(p+0);
			v |= *(p+1) << 8;
			v |= *(p+2) << 16;
			v |= *(p+3) << 24;
		}

		CSR_WRITE_4(sc, USBDC_UDCDR(0), v);
		len -= 4;
		p += 4;
	}

	while (len > 0) {
		CSR_WRITE_1(sc, USBDC_UDCDR(0), *p);
		len--;
		p++;
	}

	/* (12.6.7) Set IPR only for short packets. */
	if (lxfer->frmlen < PXAUDC_EP0MAXP)
		CSR_SET_4(sc, USBDC_UDCCSR0, USBDC_UDCCSR0_IPR);
}

void
pxaudc_write(struct pxaudc_softc *sc, struct usbf_xfer *xfer)
{
	u_int8_t *p;
	int ep = sc->sc_ep_map[usbf_endpoint_index(xfer->pipe->endpoint)];
	int tlen = 0;
	int maxp = UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
	u_int32_t csr, csr_o;

#ifdef DEBUG_TX_PKT
	if (xfer->actlen == 0)
		printf("new packet len %x\n", xfer->length);
#endif

#ifdef DEBUG_TX
	printf("writing data to endpoint %x, xlen %x xact %x\n",
		ep, xfer->length, xfer->actlen);
#endif


	if (xfer->actlen == xfer->length) {
		/*
		 * If the packet size is wMaxPacketSize byte multiple
		 * send a zero packet to indicate termiation.
		 */
		if ((xfer->actlen % maxp) == 0 &&
		    xfer->status != USBF_NORMAL_COMPLETION &&
		    xfer->flags & USBD_FORCE_SHORT_XFER) {
			if (CSR_READ_4(sc, USBDC_UDCCSR(ep))
			    & USBDC_UDCCSR_BNF) {
				CSR_SET_4(sc, USBDC_UDCCSR(ep),
				    USBDC_UDCCSR_SP);
				/*
				 * if we send a zero packet, we are 'done', but
				 * dont to usbf_transfer_complete() just yet
				 * because the short packet will cause another
				 * interrupt.
				 */
				xfer->status = USBF_NORMAL_COMPLETION;
				return;
			} else  {
				printf("fifo full when trying to set short packet\n");
			}
		}
		xfer->status = USBF_NORMAL_COMPLETION;
#ifdef DEBUG_TX_PKT
		printf("packet complete %x\n", xfer->actlen);
#endif
		usbf_transfer_complete(xfer);
		return;
	}

	p = xfer->buffer + xfer->actlen;



	csr_o = 0;
	csr = CSR_READ_4(sc, USBDC_UDCCSR(ep));
	if (csr & USBDC_UDCCSR_PC)
		csr_o |= USBDC_UDCCSR_PC;
	if (csr & USBDC_UDCCSR_TRN)
		csr_o |= USBDC_UDCCSR_TRN;
	if (csr & USBDC_UDCCSR_SST)
		csr_o |= USBDC_UDCCSR_SST;
	if (csr_o != 0)
		CSR_WRITE_4(sc, USBDC_UDCCSR(ep), csr_o);


	while (CSR_READ_4(sc, USBDC_UDCCSR(ep)) & USBDC_UDCCSR_BNF) {
		u_int32_t v;

		if (xfer->length - xfer->actlen < 4) {
			while (xfer->actlen < xfer->length) {
				CSR_WRITE_1(sc, USBDC_UDCDR(ep), *p);
				p++;
				xfer->actlen++;
				tlen++;
			}
			break;
		}
		if (((unsigned)p & 0x3) == 0)
			v = *(u_int32_t *)p;
		else {
			v = *(p+0);
			v |= *(p+1) << 8;
			v |= *(p+2) << 16;
			v |= *(p+3) << 24;
		}
		CSR_WRITE_4(sc, USBDC_UDCDR(ep), v);

		p += 4;
		xfer->actlen += 4;

		tlen += 4;
	}
#ifdef DEBUG_TX
	printf(" wrote tlen %x %x\n", tlen, xfer->actlen);
	if (xfer->actlen == 0) {
		printf("whoa, write_ep called, but no free space\n");
	}
#endif
	if (xfer->actlen == xfer->length) {
		if ((xfer->actlen % maxp) != 0) {
			if (xfer->flags & USBD_FORCE_SHORT_XFER) {
				CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_SP);
#ifdef DEBUG_TX
				printf("setting short packet on %x csr\n", ep,
				    CSR_READ_4(sc, USBDC_UDCCSR(ep)));
#endif
			} else {
				/* fill buffer to maxpacket size??? */
			}
		}
	}
}

/*
 * Interrupt handling
 */

int
pxaudc_connect_intr(void *v)
{
	struct pxaudc_softc *sc = v;

	DPRINTF(10,("pxaudc_connect_intr: connect=%d\n",
	    pxa2x0_gpio_get_bit(sc->sc_gpio_detect)));

	/* XXX only set a flag here */
	if (sc->sc_is_host()) {
#if 0
		printf("%s:switching to host\n", sc->sc_bus.bdev.dv_xname);
#endif
		pxaudc_disable(sc);
	} else {
#if 0
		printf("%s:switching to client\n", sc->sc_bus.bdev.dv_xname);
#endif
		pxaudc_enable(sc);
	}

	/* Claim this interrupt. */
	return 1;
}

int
pxaudc_intr(void *v)
{
	struct pxaudc_softc *sc = v;
	u_int32_t isr0, isr1, otgisr;

	isr0 = CSR_READ_4(sc, USBDC_UDCISR0);
	isr1 = CSR_READ_4(sc, USBDC_UDCISR1);
	otgisr = CSR_READ_4(sc, USBDC_UDCOTGISR);

	DPRINTF(10,("pxaudc_intr: isr0=%b, isr1=%b, otgisr=%b\n",
	    isr0, USBDC_UDCISR0_BITS, isr1, USBDC_UDCISR1_BITS,
	    otgisr, USBDC_UDCOTGISR_BITS));

	if (isr0 || isr1 || otgisr) {
		sc->sc_isr0 |= isr0;
		sc->sc_isr1 |= isr1;
		sc->sc_otgisr |= otgisr;

		//usbf_schedsoftintr(&sc->sc_bus);
		pxaudc_intr1(sc); /* XXX */
	}

	CSR_WRITE_4(sc, USBDC_UDCISR0, isr0);
	CSR_WRITE_4(sc, USBDC_UDCISR1, isr1);
	CSR_WRITE_4(sc, USBDC_UDCOTGISR, otgisr);

	/* Claim this interrupt. */
	return 1;
}
u_int32_t csr1, csr2;

void
pxaudc_intr1(struct pxaudc_softc *sc)
{
	u_int32_t isr0, isr1, otgisr;
	int i;
	//int s;

	//s = splhardusb();
	isr0 = sc->sc_isr0;
	isr1 = sc->sc_isr1;
	otgisr = sc->sc_otgisr;
	sc->sc_isr0 = 0;
	sc->sc_isr1 = 0;
	sc->sc_otgisr = 0;
	//splx(s);

	sc->sc_bus.intr_context++;

	if (isr1 & USBDC_UDCISR1_IRCC) {
		u_int32_t ccr;
                CSR_SET_4(sc, USBDC_UDCCR, USBDC_UDCCR_SMAC);

		/* wait for reconfig to finish (SMAC auto clears) */
		while (CSR_READ_4(sc, USBDC_UDCCR)  & USBDC_UDCCR_SMAC)
			delay(10);

		ccr = CSR_READ_4(sc, USBDC_UDCCR);
		sc->sc_cn = USBDC_UDCCR_ACNr(ccr);
		sc->sc_in = USBDC_UDCCR_AINr(ccr);
		sc->sc_isn = USBDC_UDCCR_AAISNr(ccr);
		goto ret;
	}
#if 0
	printf("pxaudc_intr: isr0=%b, isr1=%b, otgisr=%b\n",
	    isr0, USBDC_UDCISR0_BITS, isr1, USBDC_UDCISR1_BITS,
	    otgisr, USBDC_UDCOTGISR_BITS);
#endif

	/* Handle USB RESET condition. */
	if (isr1 & USBDC_UDCISR1_IRRS) {
		sc->sc_ep0state = EP0_SETUP;
		usbf_host_reset(&sc->sc_bus);
		/* Discard all other interrupts. */
		goto ret;
	}

	/* Service control pipe interrupts. */
	if (isr0 & USBDC_UDCISR0_IR(0))
		pxaudc_ep0_intr(sc);

	for (i = 1; i < 24; i++) {
		if (i < 16) {
			if (USBDC_UDCISR0_IRs(isr0,i))
				pxaudc_epN_intr(sc, i,
				    USBDC_UDCISR0_IRs(isr0,i));
		} else {
			if (USBDC_UDCISR1_IRs(isr1,i))
				pxaudc_epN_intr(sc, i,
				    USBDC_UDCISR1_IRs(isr1,i));
		}
	}

	if (isr1 & USBDC_UDCISR1_IRSU) {
		/* suspend ?? */
	}
	if (isr1 & USBDC_UDCISR1_IRRU) {
		/* resume ?? */
	}

ret:
	sc->sc_bus.intr_context--;
}

void
pxaudc_epN_intr(struct pxaudc_softc *sc, int ep, int isr)
{
	struct pxaudc_pipe *ppipe;
	struct usbf_pipe *pipe;
	int dir;

	/* should not occur before device is configured */
	if (sc->sc_cn == 0)
		return;
	if (isr &  2)
		printf("ep%d: fifo error\n", ep); /* XXX */

	/* faster method of determining direction? */
	ppipe = sc->sc_pipe[ep];

	if (ppipe == NULL)
		return;
	pipe = &ppipe->pipe;
	dir = usbf_endpoint_dir(pipe->endpoint);

	if (dir == UE_DIR_IN) {
		pxaudc_write_epN(sc, ep);
	} else {
		pxaudc_read_epN(sc, ep);
	}

}

void
pxaudc_write_epN(struct pxaudc_softc *sc, int ep)
{
	struct pxaudc_pipe *ppipe;
	struct usbf_pipe *pipe = NULL;
	struct usbf_xfer *xfer = NULL;

	ppipe = sc->sc_pipe[ep];

	if (ppipe == NULL) {
		return;
	}
	pipe = &ppipe->pipe;
	xfer = SIMPLEQ_FIRST(&pipe->queue);
	if (xfer != NULL)
		pxaudc_write(sc, xfer);
}
void
pxaudc_ep0_intr(struct pxaudc_softc *sc)
{
	struct pxaudc_pipe *ppipe;
	struct usbf_pipe *pipe = NULL;
	struct usbf_xfer *xfer = NULL;
	u_int32_t csr0;

	csr0 = CSR_READ_4(sc, USBDC_UDCCSR0);
	DPRINTF(10,("pxaudc_ep0_intr: csr0=%b\n", csr0, USBDC_UDCCSR0_BITS));
	delay (25);

	ppipe = sc->sc_pipe[0];
	if (ppipe != NULL) {
		pipe = &ppipe->pipe;
		xfer = SIMPLEQ_FIRST(&pipe->queue);
	}

	if (sc->sc_ep0state == EP0_SETUP && (csr0 & USBDC_UDCCSR0_OPC)) {
		if (pipe == NULL) {
			DPRINTF(10,("pxaudc_ep0_intr: no control pipe\n"));
			return;
		}

		if (xfer == NULL) {
			DPRINTF(10,("pxaudc_ep0_intr: no xfer\n"));
			return;
		}

		pxaudc_read_ep0(sc, xfer);
	} else if (sc->sc_ep0state == EP0_IN &&
	    (csr0 & USBDC_UDCCSR0_IPR) == 0 && xfer) {
		pxaudc_write_ep0(sc, xfer);
	}
}

/*
 * Bus methods
 */

usbf_status
pxaudc_open(struct usbf_pipe *pipe)
{
	struct pxaudc_softc *sc = (struct pxaudc_softc *)pipe->device->bus;
	struct pxaudc_pipe *ppipe = (struct pxaudc_pipe *)pipe;
	int ep_idx;
	int s;

	ep_idx = usbf_endpoint_index(pipe->endpoint);
	if (ep_idx >= PXAUDC_NEP)
		return USBF_BAD_ADDRESS;

	DPRINTF(10,("pxaudc_open\n"));
	s = splhardusb();

	switch (usbf_endpoint_type(pipe->endpoint)) {
	case UE_CONTROL:
		pipe->methods = &pxaudc_ctrl_methods;
		break;

	case UE_BULK:
		pipe->methods = &pxaudc_bulk_methods;
		break;

	case UE_ISOCHRONOUS:
	case UE_INTERRUPT:
	default:
		/* XXX */
		splx(s);
		return USBF_BAD_ADDRESS;
	}
	
	if (ep_idx != 0 && sc->sc_ep_map[ep_idx] != -1) {
		printf("endpoint %d already used by %c",
		    ep_idx, '@@'+ sc->sc_ep_map[0]);
		splx(s);
		return USBF_BAD_ADDRESS;
	}
	sc->sc_ep_map[ep_idx] = sc->sc_npipe;

	sc->sc_pipe[sc->sc_npipe] = ppipe;
	sc->sc_npipe++;

	splx(s);
	return USBF_NORMAL_COMPLETION;
}

void
pxaudc_softintr(void *v)
{
	struct pxaudc_softc *sc = v;

	pxaudc_intr1(sc);
}

usbf_status
pxaudc_allocm(struct usbf_bus *bus, struct usb_dma *dmap, u_int32_t size)
{
	return usbf_allocmem(bus, size, 0, dmap);
}

void
pxaudc_freem(struct usbf_bus *bus, struct usb_dma *dmap)
{
	usbf_freemem(bus, dmap);
}

struct usbf_xfer *
pxaudc_allocx(struct usbf_bus *bus)
{
	struct pxaudc_softc *sc = (struct pxaudc_softc *)bus;
	struct usbf_xfer *xfer;

	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL)
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
	else
		xfer = malloc(sizeof(struct pxaudc_xfer), M_USB, M_NOWAIT);
	if (xfer != NULL)
		bzero(xfer, sizeof(struct pxaudc_xfer));
	return xfer;
}

void
pxaudc_freex(struct usbf_bus *bus, struct usbf_xfer *xfer)
{
	struct pxaudc_softc *sc = (struct pxaudc_softc *)bus;

	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
}

/*
 * Control pipe methods
 */

usbf_status
pxaudc_ctrl_transfer(struct usbf_xfer *xfer)
{
	usbf_status err;

	/* Insert last in queue. */
	err = usbf_insert_transfer(xfer);
	if (err)
		return err;

	/*
	 * Pipe isn't running (otherwise err would be USBF_IN_PROGRESS),
	 * so start first.
	 */
	return pxaudc_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

usbf_status
pxaudc_ctrl_start(struct usbf_xfer *xfer)
{
	struct usbf_pipe *pipe = xfer->pipe;
	struct pxaudc_softc *sc = (struct pxaudc_softc *)pipe->device->bus;
	int iswrite = !(xfer->rqflags & URQ_REQUEST);
	int s;

	s = splusb();
	xfer->status = USBF_IN_PROGRESS;
	if (iswrite)
		pxaudc_write_ep0(sc, xfer);
	else {
		/* XXX boring message, this case is normally reached if
		 * XXX the xfer for a device request is being queued. */
		DPRINTF(10,("%s: ep[%x] ctrl-out, xfer=%p, len=%u, "
		    "actlen=%u\n", DEVNAME(sc),
		    usbf_endpoint_address(xfer->pipe->endpoint),
		    xfer, xfer->length,
		    xfer->actlen));
	}
	splx(s);
	return USBF_IN_PROGRESS;
}

/* (also used by bulk pipes) */
void
pxaudc_ctrl_abort(struct usbf_xfer *xfer)
{
	int s;
#ifdef PXAUDC_DEBUG
	struct usbf_pipe *pipe = xfer->pipe;
	struct pxaudc_softc *sc = (struct pxaudc_softc *)pipe->device->bus;
	int index = usbf_endpoint_index(pipe->endpoint);
	int dir = usbf_endpoint_dir(pipe->endpoint);
	int type = usbf_endpoint_type(pipe->endpoint);
#endif

	DPRINTF(10,("%s: ep%d %s-%s abort, xfer=%p\n", DEVNAME(sc), index,
	    type == UE_CONTROL ? "ctrl" : "bulk", dir == UE_DIR_IN ?
	    "in" : "out", xfer));

	/*
	 * Step 1: Make soft interrupt routine and hardware ignore the xfer.
	 */
	s = splusb();
	xfer->status = USBF_CANCELLED;
	timeout_del(&xfer->timeout_handle);
	splx(s);

	/*
	 * Step 2: Make sure hardware has finished any possible use of the
	 * xfer and the soft interrupt routine has run.
	 */
	s = splusb();
	/* XXX this does not seem right, what if there
	 * XXX are two xfers in the FIFO and we only want to
	 * XXX ignore one? */
#ifdef notyet
	pxaudc_flush(sc, usbf_endpoint_address(pipe->endpoint));
#endif
	/* XXX we're not doing DMA and the soft interrupt routine does not
	   XXX need to clean up anything. */
	splx(s);

	/*
	 * Step 3: Execute callback.
	 */
	s = splusb();
	usbf_transfer_complete(xfer);
	splx(s);
}

void
pxaudc_ctrl_done(struct usbf_xfer *xfer)
{
}

void
pxaudc_ctrl_close(struct usbf_pipe *pipe)
{
	/* XXX */
}

/*
 * Bulk pipe methods
 */

usbf_status
pxaudc_bulk_transfer(struct usbf_xfer *xfer)
{
	usbf_status err;

	/* Insert last in queue. */
	err = usbf_insert_transfer(xfer);
	if (err)
		return err;

	/*
	 * Pipe isn't running (otherwise err would be USBF_IN_PROGRESS),
	 * so start first.
	 */
	return pxaudc_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

usbf_status
pxaudc_bulk_start(struct usbf_xfer *xfer)
{
	struct usbf_pipe *pipe = xfer->pipe;
	struct pxaudc_softc *sc = (struct pxaudc_softc *)pipe->device->bus;
	int iswrite = (usbf_endpoint_dir(pipe->endpoint) == UE_DIR_IN);
	int s;

	DPRINTF(0,("%s: ep%d bulk-%s start, xfer=%p, len=%u\n", DEVNAME(sc),
	    usbf_endpoint_index(pipe->endpoint), iswrite ? "in" : "out",
	    xfer, xfer->length));

	s = splusb();
	xfer->status = USBF_IN_PROGRESS;
	if (iswrite)
		pxaudc_write(sc, xfer);
	else {
		/* enable interrupt */
	}
	splx(s);
	return USBF_IN_PROGRESS;
}

void
pxaudc_bulk_abort(struct usbf_xfer *xfer)
{
	pxaudc_ctrl_abort(xfer);
}

void
pxaudc_bulk_done(struct usbf_xfer *xfer)
{
#if 0
	int ep = usbf_endpoint_address(xfer->pipe->endpoint);
	struct usbf_pipe *pipe = xfer->pipe;
	struct pxaudc_softc *sc = (struct pxaudc_softc *)pipe->device->bus;

#endif
}

void
pxaudc_bulk_close(struct usbf_pipe *pipe)
{
	/* XXX */
}

#endif /* NUSBF > 0 */
@


1.30
log
@fix indentation
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.29 2013/04/16 14:55:23 deraadt Exp $ */
d934 1
@


1.29
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.
missed bits from previous change; ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.28 2011/04/07 15:30:15 miod Exp $ */
d628 1
a628 1
	CSR_WRITE_4(sc, USBDC_UDCCSR(ep), csr_o);
@


1.28
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.27 2010/09/07 16:21:35 deraadt Exp $ */
d57 1
a57 1
void		 pxaudc_read_ep0(struct pxaudc_softc *, usbf_xfer_handle);
d59 2
a60 2
void		 pxaudc_write_ep0(struct pxaudc_softc *, usbf_xfer_handle);
void		 pxaudc_write(struct pxaudc_softc *, usbf_xfer_handle);
d71 16
a86 16
usbf_status	 pxaudc_allocm(struct usbf_bus *, usb_dma_t *, u_int32_t);
void		 pxaudc_freem(struct usbf_bus *, usb_dma_t *);
usbf_xfer_handle pxaudc_allocx(struct usbf_bus *);
void		 pxaudc_freex(struct usbf_bus *, usbf_xfer_handle);

usbf_status	 pxaudc_ctrl_transfer(usbf_xfer_handle);
usbf_status	 pxaudc_ctrl_start(usbf_xfer_handle);
void		 pxaudc_ctrl_abort(usbf_xfer_handle);
void		 pxaudc_ctrl_done(usbf_xfer_handle);
void		 pxaudc_ctrl_close(usbf_pipe_handle);

usbf_status	 pxaudc_bulk_transfer(usbf_xfer_handle);
usbf_status	 pxaudc_bulk_start(usbf_xfer_handle);
void		 pxaudc_bulk_abort(usbf_xfer_handle);
void		 pxaudc_bulk_done(usbf_xfer_handle);
void		 pxaudc_bulk_close(usbf_pipe_handle);
d390 1
a390 1
pxaudc_read_ep0(struct pxaudc_softc *sc, usbf_xfer_handle xfer)
d428 2
a429 2
	usbf_pipe_handle pipe = NULL;
	usbf_xfer_handle xfer = NULL;
d508 1
a508 1
pxaudc_write_ep0(struct pxaudc_softc *sc, usbf_xfer_handle xfer)
d564 1
a564 1
pxaudc_write(struct pxaudc_softc *sc, usbf_xfer_handle xfer)
d817 1
a817 1
	usbf_pipe_handle pipe;
d846 2
a847 2
	usbf_pipe_handle pipe = NULL;
	usbf_xfer_handle xfer = NULL;
d863 2
a864 2
	usbf_pipe_handle pipe = NULL;
	usbf_xfer_handle xfer = NULL;
d954 1
a954 1
pxaudc_allocm(struct usbf_bus *bus, usb_dma_t *dmap, u_int32_t size)
d960 1
a960 1
pxaudc_freem(struct usbf_bus *bus, usb_dma_t *dmap)
d965 1
a965 1
usbf_xfer_handle
d969 1
a969 1
	usbf_xfer_handle xfer;
d982 1
a982 1
pxaudc_freex(struct usbf_bus *bus, usbf_xfer_handle xfer)
d994 1
a994 1
pxaudc_ctrl_transfer(usbf_xfer_handle xfer)
d1011 1
a1011 1
pxaudc_ctrl_start(usbf_xfer_handle xfer)
d1037 1
a1037 1
pxaudc_ctrl_abort(usbf_xfer_handle xfer)
d1084 1
a1084 1
pxaudc_ctrl_done(usbf_xfer_handle xfer)
d1089 1
a1089 1
pxaudc_ctrl_close(usbf_pipe_handle pipe)
d1099 1
a1099 1
pxaudc_bulk_transfer(usbf_xfer_handle xfer)
d1116 1
a1116 1
pxaudc_bulk_start(usbf_xfer_handle xfer)
d1139 1
a1139 1
pxaudc_bulk_abort(usbf_xfer_handle xfer)
d1145 1
a1145 1
pxaudc_bulk_done(usbf_xfer_handle xfer)
d1156 1
a1156 1
pxaudc_bulk_close(usbf_pipe_handle pipe)
@


1.27
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.26 2010/08/30 21:35:55 deraadt Exp $ */
d196 1
a196 1
		sc->sc_ioh = NULL;
@


1.26
log
@Convert all powerhooks to activate functions, and provide powerhook stubs.
Of note:  lcd stubs get pulled up to the parent; zts has to keep track of
whether it is in use or not
testing by myself and jakemsr; proof reading by oga
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.25 2010/08/27 05:04:06 deraadt Exp $ */
a54 2
void		 pxaudc_powerhook(int, void *);

a200 2
	sc->sc_powerhook = powerhook_establish(pxaudc_powerhook, sc);

a226 3
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

a254 6
}

void
pxaudc_powerhook(int why, void *arg)
{
	pxaudc_activate(arg, why);
@


1.25
log
@More killing of PWR_STANDBY.  cvs skipped these files
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.24 2010/06/07 16:34:20 drahn Exp $ */
d55 1
a55 1
void		 pxaudc_power(int, void *);
d203 1
a203 1
	sc->sc_powerhook = powerhook_establish(pxaudc_power, sc);
d248 2
a249 2
void
pxaudc_power(int why, void *arg)
d251 1
a251 1
	struct pxaudc_softc		*sc = (struct pxaudc_softc *)arg;
d253 2
a254 2
	switch (why) {
	case PWR_SUSPEND:
d257 1
a257 2

	case PWR_RESUME:
d261 7
@


1.24
log
@Break pxaudc into xscale and MD pieces so that palm and zaurus can correctly
share the driver with different GPIOs/IRQs Diff from marex via jasper.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.23 2008/11/25 14:55:44 drahn Exp $ */
a254 1
	case PWR_STANDBY:
@


1.23
log
@rename zaurus_reg.h to machine_reg and rename some of the internal fields
so that arm/xscale/... is not referring to zaurus specific defines.
ok miod kevlo, with some suggested changes from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.22 2007/06/14 06:55:10 mbalmer Exp $ */
d41 1
a41 5
#include <arm/xscale/pxa27x_udcreg.h>
#define PXAUDC_EP0MAXP	16	/* XXX */
#define PXAUDC_NEP	24	/* total number of endpoints */

#include <machine/machine_reg.h>	/* XXX */
a54 30
struct pxaudc_softc {
	struct usbf_bus		 sc_bus;
	bus_space_tag_t		 sc_iot;
	bus_space_handle_t	 sc_ioh;
	bus_size_t		 sc_size;
	void			*sc_ih;
	void			*sc_conn_ih;
	void 			*sc_powerhook;
	SIMPLEQ_HEAD(,usbf_xfer) sc_free_xfers;	/* recycled xfers */
	u_int32_t		 sc_icr0;	/* enabled EP interrupts */
	u_int32_t		 sc_icr1;	/* enabled EP interrupts */
	enum {
		EP0_SETUP,
		EP0_IN
	}			 sc_ep0state;
	u_int32_t		 sc_isr0;	/* XXX deferred interrupts */
	u_int32_t		 sc_isr1;	/* XXX deferred interrupts */
	u_int32_t		 sc_otgisr;	/* XXX deferred interrupts */
	struct pxaudc_pipe	*sc_pipe[PXAUDC_NEP];
	int			 sc_npipe;

	int			 sc_cn;
	int			 sc_in;
	int			 sc_isn;
	int8_t			 sc_ep_map[16];
};

int		 pxaudc_match(struct device *, void *, void *);
void		 pxaudc_attach(struct device *, struct device *, void *);
int		 pxaudc_detach(struct device *, int);
a56 6
int		 pxaudc_is_host(void);
int		 pxaudc_is_device(void);
void		 pxaudc_setup(struct pxaudc_softc *);
void		 pxaudc_hide(struct pxaudc_softc *);
void		 pxaudc_show(struct pxaudc_softc *);

a89 5
struct cfattach pxaudc_ca = {
	sizeof(struct pxaudc_softc), pxaudc_match, pxaudc_attach,
	pxaudc_detach
};

d144 1
a144 1
pxaudc_match(struct device *parent, void *match, void *aux)
d153 1
a153 1
pxaudc_attach(struct device *parent, struct device *self, void *aux)
a154 1
	struct pxaudc_softc		*sc = (struct pxaudc_softc *)self;
d156 1
d158 1
a173 1
	pxaudc_setup(sc);
d192 1
a192 1
	sc->sc_conn_ih = pxa2x0_gpio_intr_establish(PXA_USB_CONNECT_PIN,
d220 1
a220 1
	(void)config_found(self, &sc->sc_bus, NULL);
d223 1
a223 1
	if (!pxaudc_is_host())
d229 1
a229 1
pxaudc_detach(struct device *self, int flags)
a230 2
	struct pxaudc_softc		*sc = (struct pxaudc_softc *)self;

a265 50
 * Machine-specific functions
 */

/* XXX move to machine-specific file */

int
pxaudc_is_host(void)
{
	return (!pxa2x0_gpio_get_bit(PXA_USB_CONNECT_PIN) &&
		!pxa2x0_gpio_get_bit(PXA_USB_DEVICE_PIN));
}

int
pxaudc_is_device(void)
{
	return (pxa2x0_gpio_get_bit(PXA_USB_CONNECT_PIN) &&
		pxa2x0_gpio_get_bit(PXA_USB_DEVICE_PIN));
}

void
pxaudc_setup(struct pxaudc_softc *sc)
{
	pxa2x0_gpio_set_function(45, GPIO_OUT);
	pxa2x0_gpio_set_function(PXA_USB_CONNECT_PIN, GPIO_IN); /* 41 */
	pxa2x0_gpio_set_function(40, GPIO_OUT);
	pxa2x0_gpio_set_function(39, GPIO_IN);
	pxa2x0_gpio_set_function(38, GPIO_IN);
	pxa2x0_gpio_set_function(37, GPIO_OUT);
	pxa2x0_gpio_set_function(36, GPIO_IN);
	pxa2x0_gpio_set_function(PXA_USB_DEVICE_PIN, GPIO_IN); /* 35 */
	pxa2x0_gpio_set_function(34, GPIO_IN);
	pxa2x0_gpio_set_function(89, GPIO_OUT);
	pxa2x0_gpio_set_function(120, GPIO_OUT);
}

/* Hide us from the host. */
void
pxaudc_hide(struct pxaudc_softc *sc)
{
	pxa2x0_gpio_clear_bit(PXA_USB_PULLUP_PIN);
}

/* Show us to the host. */
void
pxaudc_show(struct pxaudc_softc *sc)
{
	pxa2x0_gpio_set_bit(PXA_USB_PULLUP_PIN);
}

/*
d696 2
a697 3
	DPRINTF(10,("pxaudc_connect_intr: connect=%d device=%d\n",
	    pxa2x0_gpio_get_bit(PXA_USB_CONNECT_PIN),
	    pxa2x0_gpio_get_bit(PXA_USB_DEVICE_PIN)));
d700 1
a700 1
	if (pxaudc_is_host()) {
@


1.22
log
@Move the inclusion of sys/timeout.h from usb_port.h to the drivers that
need it.

If a USB driver uses timeout(9) functions, the header file sys/timeout.h
must be included.

Tested by me (i386, macppc, sparc64), ckuethe (amd64), & todd (sparc, zaurus).

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.21 2007/06/10 14:49:01 mbalmer Exp $ */
d45 1
a45 1
#include <machine/zaurus_reg.h>	/* XXX */
d234 1
a234 1
	sc->sc_conn_ih = pxa2x0_gpio_intr_establish(C3000_USB_DEVICE_PIN, /* XXX */
d237 1
a237 1
	sc->sc_conn_ih = pxa2x0_gpio_intr_establish(C3000_USB_CONNECT_PIN,
d321 2
a322 2
	return (!pxa2x0_gpio_get_bit(C3000_USB_CONNECT_PIN) &&
		!pxa2x0_gpio_get_bit(C3000_USB_DEVICE_PIN));
d328 2
a329 2
	return (pxa2x0_gpio_get_bit(C3000_USB_CONNECT_PIN) &&
		pxa2x0_gpio_get_bit(C3000_USB_DEVICE_PIN));
d336 1
a336 1
	pxa2x0_gpio_set_function(C3000_USB_CONNECT_PIN, GPIO_IN); /* 41 */
d342 1
a342 1
	pxa2x0_gpio_set_function(C3000_USB_DEVICE_PIN, GPIO_IN); /* 35 */
d352 1
a352 1
	pxa2x0_gpio_clear_bit(C3000_USB_PULLUP_PIN);
d359 1
a359 1
	pxa2x0_gpio_set_bit(C3000_USB_PULLUP_PIN);
d794 2
a795 2
	    pxa2x0_gpio_get_bit(C3000_USB_CONNECT_PIN),
	    pxa2x0_gpio_get_bit(C3000_USB_DEVICE_PIN)));
@


1.21
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.20 2007/06/10 10:15:35 mbalmer Exp $ */
d26 1
@


1.20
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.19 2007/02/25 01:49:27 drahn Exp $ */
d167 1
a167 1
#define DEVNAME(sc)	USBDEVNAME((sc)->sc_bus.bdev)
@


1.19
log
@add missing USBD_FORCE_SHORT_XFER checks, put back some code I had for a
while but removed incorrectly, some minor cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.18 2007/02/24 22:16:14 drahn Exp $ */
d1162 1
a1162 1
	usb_uncallout(xfer->timeout_handle, pxaudc_timeout, NULL);
@


1.18
log
@move debug print into debug block.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.17 2007/02/24 22:08:20 drahn Exp $ */
a555 5
#if  0
	if ((csr & (USBDC_UDCCSR_SP|USBDC_UDCCSR_PC)) ==
	    (USBDC_UDCCSR_SP|USBDC_UDCCSR_PC)
	    && count == 0)
#else
a556 1
#endif
d693 14
a706 3
		    xfer->status != USBF_NORMAL_COMPLETION) {
			if (CSR_READ_4(sc, USBDC_UDCCSR(ep)) & USBDC_UDCCSR_BNF) {
				CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_SP);
d768 1
a768 1
	if (xfer->actlen >= xfer->length) {
d770 2
a771 1
			CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_SP);
d773 2
a774 2
			printf("setting short packet on %x csr\n", ep,
			    CSR_READ_4(sc, USBDC_UDCCSR(ep)));
d776 3
a779 1
		xfer->actlen = xfer->length; /* no overflow */
@


1.17
log
@Add my copyright, since I took the skeleton driver and made it complete.
More polishing, appears to be working fine without back-to-back transmits.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.16 2007/02/23 06:12:43 drahn Exp $ */
a758 1
#endif
d762 1
@


1.16
log
@Use the maxpacket len from the pipe, not hardcoded. properly deal
with end of frame when it happens to be at end of usb packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.15 2007/02/15 20:36:03 drahn Exp $ */
d4 2
a6 1
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
d108 1
a108 1
void		 pxaudc_epN_intr(struct pxaudc_softc *sc, int ep);
d546 2
a547 1
	if (xfer == NULL)
d549 1
d680 6
d692 1
d700 5
a704 8
			CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_SP);
			/*
			 * if we send a zero packet, we are 'done', but dont
			 * to usbf_transfer_complete() just yet because the
			 * short packet will cause another interrupt.
			 */
			xfer->status = USBF_NORMAL_COMPLETION;
			return;
d707 3
d717 12
a728 2
	if (CSR_READ_4(sc, USBDC_UDCCSR(ep)) & USBDC_UDCCSR_PC)
		CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_PC);
d760 3
a874 10
	for (i = 1; i < 24; i++) {
		if (i < 16) {
			if (isr0 & USBDC_UDCISR0_IR(i))
				pxaudc_epN_intr(sc, i);
		} else {
			if (isr1 & USBDC_UDCISR1_IR(i-16))
				pxaudc_epN_intr(sc, i);
		}
	}

d887 12
d911 1
a911 1
pxaudc_epN_intr(struct pxaudc_softc *sc, int ep)
d913 4
d920 2
a923 3
	struct pxaudc_pipe *ppipe;
	usbf_pipe_handle pipe = NULL;
	int dir;
d966 1
a966 2

	delay(100);
@


1.15
log
@TX is working fine, turn off debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.14 2007/02/15 18:05:05 drahn Exp $ */
d566 2
d676 1
d685 1
a685 1
		 * If the packet size is 64 byte multiple
a686 1
		 * This should be endpoint maxtransfersize.
d688 2
a689 1
		if ((xfer->actlen % 64) == 0)
d691 8
d741 1
a741 1
		if ((xfer->actlen % 64) != 0) {
@


1.14
log
@Add a mapping for logical to physical endpoints, otherwise data tries to
go out the wrong endpoint. Some debug massage.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.13 2007/02/15 06:28:11 drahn Exp $ */
a674 1
#define DEBUG_TX
@


1.13
log
@Fix transmit packet termination. odd length and 64 byte multiple packets
were not sending the last data correctly before.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.12 2007/02/13 20:54:10 drahn Exp $ */
d81 1
d182 1
a182 1
int pxaudcdebug = 5;
d200 1
d256 6
d672 1
a672 1
	int ep = usbf_endpoint_index(xfer->pipe->endpoint);
d675 6
d683 3
a685 3
		 * if the packet's last bytes are in the 'word'
		 * send a zero packet to indicate termiation
		if ((((xfer->actlen+3)>>2) % (64>>2)) == 0)
a695 4
#if 0
	printf("writing data to endpoint %x, xlen %x xact %x",
		ep, xfer->length, xfer->actlen);
#endif
d727 1
a727 1
#if 0
d733 1
a733 1
#if 0
d757 3
d762 3
d929 1
a929 1
	delay(200);
d964 1
d967 2
a968 1
	if (usbf_endpoint_index(pipe->endpoint) >= PXAUDC_NEP)
d990 7
@


1.12
log
@Add a delay for ep0 handling. Dunno why, but without debug prints it would
not attach properly until a delay was added.  Also some debug quieting.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.11 2007/02/13 18:32:57 drahn Exp $ */
a583 3
#ifdef DEBUG_RX
	printf(" remain %x\n", len);
#endif
d668 6
a673 2
#if 0
		if ((xfer->actlen % 64) != 0)
a674 1
#endif
d693 7
a699 1
		if (xfer->actlen >= xfer->length)
d701 1
a701 1

@


1.11
log
@USB client mode with cdce function driver is coming along, RX and TX kinda work.
Limitations include failing to recieve packets that are a multiple of 64 bytes
and sending packets longer than 128 bytes appears to be messed up.
Work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.10 2007/02/12 16:11:11 drahn Exp $ */
d593 1
a593 1
	    printf("trans2 complete\n");
d599 1
d602 1
d682 1
d685 1
d711 1
d713 1
d717 1
a717 1
			CSR_SET_4(sc, USBDC_UDCCSR(ep), USBDC_UDCCSR_SP);
d719 2
a720 1
			CSR_READ_4(sc, USBDC_UDCCSR(ep)));
d814 1
d818 1
d906 2
@


1.10
log
@Reduce debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.9 2007/02/12 15:09:03 drahn Exp $ */
d77 4
d97 1
d100 1
d106 1
d181 1
a181 1
int pxaudcdebug = 0;
d376 1
a376 1
	DPRINTF(0,("pxaudc_enable\n"));
d455 1
a455 1
	DPRINTF(0,("pxaudc_disable\n"));
d518 88
d617 1
a617 1
	DPRINTF(1,("%s: ep0 ctrl-in, xfer=%p, len=%u, actlen=%u\n",
d664 53
a716 1
	printf("pxaudc_write: XXX\n");
d728 1
a728 1
	DPRINTF(0,("pxaudc_connect_intr: connect=%d device=%d\n",
d753 1
a753 1
	DPRINTF(0,("pxaudc_intr: isr0=%b, isr1=%b, otgisr=%b\n",
d794 1
d797 1
a797 1
		/* wait for reconfig to finish (SMAC auto clears */
d801 5
d807 4
a811 1
		int x;
d814 1
a814 1
				printf("interrupt pending ep[%d]\n", i);
d817 1
a817 1
				printf("interrupt pending ep[%d]\n", i);
a818 3
		x = CSR_READ_4(sc, USBDC_UDCBCR(i));
		if( x != 0)
			printf("data present in ep %d %d\n", i, x);
d845 43
d896 1
a896 1
	DPRINTF(0,("pxaudc_ep0_intr: csr0=%b\n", csr0, USBDC_UDCCSR0_BITS));
d906 1
a906 1
			DPRINTF(0,("pxaudc_ep0_intr: no control pipe\n"));
d911 1
a911 1
			DPRINTF(0,("pxaudc_ep0_intr: no xfer\n"));
d936 1
a936 1
	DPRINTF(0,("pxaudc_open\n"));
d1043 1
a1043 1
		DPRINTF(0,("%s: ep[%x] ctrl-out, xfer=%p, len=%u, "
d1066 1
a1066 1
	DPRINTF(0,("%s: ep%d %s-%s abort, xfer=%p\n", DEVNAME(sc), index,
d1138 1
a1138 1
	int iswrite = usbf_endpoint_dir(pipe->endpoint) == UE_DIR_IN;
d1165 6
@


1.9
log
@If SMAC is set in the correct register, it works much better, also set
the direction bit correctly. More cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.8 2007/02/07 16:26:49 drahn Exp $ */
a402 3
			printf("configuring pipe/ep %x %x\n", i,
			    UE_GET_ADDR(ed->bEndpointAddress));

a415 1
			printf("endpoint %c programed to %x\n", '@@'+i, cr);
a420 1
			printf("csr%d %x\n", i, CSR_READ_4(sc,  USBDC_UDCCSR(1)));
d432 1
a432 1
	printf("icr0 %x\n", CSR_READ_4(sc,  USBDC_UDCICR0));
a435 1
	printf("icr1 %x\n", CSR_READ_4(sc,  USBDC_UDCICR1));
d632 1
d646 7
a652 2
	if (isr0 & USBDC_UDCISR0_IR(1)) {
		printf("interrupt pending ep[1]\n");
d654 8
a661 7
	{
		int i;
		u_int32_t csr;
                csr = CSR_READ_4(sc, USBDC_UDCCSR(1));
		if (csr1 != csr) {
			printf("CSR1 %x\n", csr);
			csr1 = csr;
d663 3
a665 14
                csr = CSR_READ_4(sc, USBDC_UDCCSR(2));
		if (csr2 != csr) {
			printf("CSR1 %x\n", csr);
			csr2 = csr;
		 }
		 for (i = 1; i < 23; i++) {
			int x;
			x = CSR_READ_4(sc, USBDC_UDCBCR(i));
			if( x != 0)
				printf("data present in ep %d %d\n", i, x);
		 }
	}
	if (isr0 & USBDC_UDCISR0_IR(2)) {
		printf("interrupt pending ep[2]\n");
d667 1
a685 24
	if (isr1 & USBDC_UDCISR1_IRCC) {
                u_int32_t ccr;
                ccr = CSR_READ_4(sc, USBDC_UDCCR);
 
                printf("config change isr %x %x ccr0 %b\n acn %x ain %x aaisn %x\n",
                    isr0, isr1,
			ccr, USBDC_UDCCR_BITS,
                        (ccr >> 11)  & 7,
                        (ccr >> 8)  & 7,
                        (ccr >> 5)  & 7);
                CSR_SET_4(sc, USBDC_UDCCR, USBDC_UDCCR_SMAC);

		/* wait for reconfig to finish (SMAC auto clears */
		while (CSR_READ_4(sc, USBDC_UDCCR)  & USBDC_UDCCR_SMAC)
			delay(10);

                ccr = CSR_READ_4(sc, USBDC_UDCCR);
 
                printf("after config change isr %x %x acn %x ain %x aaisn %x ccr0 %x\n",
                    isr0, isr1,
                        (ccr >> 11)  & 7,
                        (ccr >> 8)  & 7,
                        (ccr >> 5)  & 7, ccr);
	}
a761 1
	printf("adding pipe %x\n", usbf_endpoint_index(pipe->endpoint));
@


1.8
log
@Several improvements to the usb client code. Still not working.
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.7 2006/11/28 15:42:30 uwe Exp $ */
d383 1
d387 1
a387 1
	for (i = 0; i < PXAUDC_NEP; i++) 
d403 4
a406 2
			printf("configuring pipe/ep %x\n", i);
			cr = USBDC_UDCECR_EE;
d411 1
a411 1
			if (dir == UE_DIR_OUT)
d429 4
d439 1
a442 2
	CSR_SET_4(sc, USBDC_UDCCSR0, USBDC_UDCCSR0_ACM);

a446 2
	printf("udccr %b\n", CSR_READ_4(sc, USBDC_UDCCR), USBDC_UDCCR_BITS);

d465 1
a465 2
	CSR_WRITE_4(sc, USBDC_UP2OCR, USBDC_UP2OCR_HXS |
	    USBDC_UP2OCR_HXOE);
d689 6
d696 2
a697 2
                u_int32_t csr0;
                csr0 = CSR_READ_4(sc, USBDC_UDCCSR0);
d699 1
a699 1
                printf("config change isr %x %x acn %x ain %x aaisn %x\n",
d701 11
a711 5
                        (csr0 >> 11)  & 7,
                        (csr0 >> 8)  & 7,
                        (csr0 >> 5)  & 7);
                CSR_SET_4(sc, USBDC_UDCCSR0, USBDC_UDCCR_SMAC);
                csr0 = CSR_READ_4(sc, USBDC_UDCCSR0);
d713 1
a713 1
                printf("after config change isr %x %x acn %x ain %x aaisn %x\n",
d715 3
a717 3
                        (csr0 >> 11)  & 7,
                        (csr0 >> 8)  & 7,
                        (csr0 >> 5)  & 7);
@


1.7
log
@add needs-flag to allow pxaudc to compile without usbf (to get the
previous behaviour of just disabling the USB device controller)
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.6 2006/11/25 18:10:29 uwe Exp $ */
d54 1
a54 1
	LIST_ENTRY(pxaudc_pipe)	 list;
d76 1
a170 1
#define PXAUDC_DEBUG
d245 1
d367 2
d374 1
d378 48
d428 1
a428 1
	CSR_SET_4(sc, USBDC_UDCICR0, USBDC_UDCICR0_IE(0) |
d430 2
a431 1
	CSR_SET_4(sc, USBDC_UDCICR1, USBDC_UDCICR1_IERS |
d433 1
d435 1
a435 7
	/* XXX */
	CSR_WRITE_4(sc, USBDC_UDCICR0, 0x00000C3F);
	CSR_WRITE_4(sc, USBDC_UDCECR(1), 0x0200D103);
	CSR_WRITE_4(sc, USBDC_UDCECR(2), 0x02014103);
	CSR_WRITE_4(sc, USBDC_UDCECR(3), 0x0201B403);
	CSR_WRITE_4(sc, USBDC_UDCECR(4), 0x02022403);
	CSR_WRITE_4(sc, USBDC_UDCECR(5), 0x0202F021);
d441 2
d609 1
a609 1
	DPRINTF(1,("pxaudc_intr: isr0=%b, isr1=%b, otgisr=%b\n",
d629 1
d648 26
d686 19
d718 1
a718 1
	DPRINTF(1,("pxaudc_ep0_intr: csr0=%b\n", csr0, USBDC_UDCCSR0_BITS));
d758 1
a758 1
	DPRINTF(1,("pxaudc_open\n"));
d778 3
a780 1
	sc->sc_pipe[usbf_endpoint_index(pipe->endpoint)] = ppipe;
d866 4
a869 2
		DPRINTF(0,("%s: ep0 ctrl-out, xfer=%p, len=%u, "
		    "actlen=%u\n", DEVNAME(sc), xfer, xfer->length,
d880 2
a883 2
	int s;
#ifdef PXAUDC_DEBUG
d964 1
a964 1
	DPRINTF(1,("%s: ep%d bulk-%s start, xfer=%p, len=%u\n", DEVNAME(sc),
d972 3
@


1.6
log
@
Initial USB device controller (UDC) and USB CDC Ethernet function support
for PXA27x/Zaurus, not enabled yet; for dlg and dale :)
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.5 2005/03/30 14:24:39 dlg Exp $ */
d45 2
d128 2
d155 2
d210 1
d252 1
d424 2
d892 2
@


1.5
log
@extra gunk to make ohci suspend and resume work on the zaurus

help from and ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.4 2005/02/21 07:46:48 dlg Exp $ */
d5 1
d24 1
d29 6
d40 4
d45 9
a53 4
int	pxaudc_match(struct device *, void *, void *);
void	pxaudc_attach(struct device *, struct device *, void *);
int	pxaudc_detach(struct device *, int);
void	pxaudc_power(int, void *);
d56 6
a61 5
	struct device		sc_dev;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_size;

d63 11
d76 40
a115 1
void	pxaudc_enable(struct pxaudc_softc *);
d126 46
a187 3
	sc->sc_size = 0;
	sc->sc_powerhook = NULL;

d200 31
a230 5
	pxa2x0_gpio_set_function(35, GPIO_ALT_FN_2_IN); /* USB_P2_1 */
	pxa2x0_gpio_set_function(37, GPIO_ALT_FN_1_OUT); /* USB_P2_8 */
	pxa2x0_gpio_set_function(41, GPIO_ALT_FN_2_IN); /* USB_P2_7 */
	pxa2x0_gpio_set_function(89, GPIO_ALT_FN_2_OUT); /* USBHPEN<1> */
	pxa2x0_gpio_set_function(120, GPIO_ALT_FN_2_OUT); /* USBHPEN<2> */
d232 6
a237 2
	pxa2x0_clkman_config(CKEN_USBDC, 0);
	pxaudc_enable(sc);
d239 2
a240 1
	pxa2x0_gpio_set_bit(37); /* USB_P2_8 */
d242 3
a244 1
	sc->sc_powerhook = powerhook_establish(pxaudc_power, sc);
d255 6
d274 7
a280 1
	if (why == PWR_RESUME)
d282 22
d307 49
d358 211
a568 1
	u_int32_t			hr;
d570 311
a880 19
	/* disable the controller */
	hr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, USBDC_UDCCR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, USBDC_UDCCR,
	    hr & ~USBDC_UDCCR_UDE);

	hr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, USBDC_UDCICR1);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, USBDC_UDCICR1,
	    hr | USBDC_UDCICR1_IERS);

	bus_space_write_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR, 0);
	hr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR,
	    hr | USBDC_UP2OCR_HXS);
	hr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR,
	    hr | USBDC_UP2OCR_HXOE);
	hr = bus_space_read_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR);
	bus_space_write_4(sc->sc_iot, sc->sc_ioh, USBDC_UP2OCR,
	    hr | USBDC_UP2OCR_DPPDE|USBDC_UP2OCR_DMPDE);
@


1.4
log
@remove unused header
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.3 2005/02/19 00:45:14 dlg Exp $ */
d36 1
d43 2
d47 2
a71 1
	u_int32_t			hr;
d75 1
d92 2
d96 36
a151 15

	pxa2x0_gpio_set_bit(37); /* USB_P2_8 */
}

int
pxaudc_detach(struct device *self, int flags)
{
	struct pxaudc_softc		*sc = (struct pxaudc_softc *)self;

	if (sc->sc_size) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, sc->sc_size);
		sc->sc_size = 0;
	}

	return (0);
@


1.3
log
@set the gpios in the right place

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.2 2005/02/18 16:42:09 dlg Exp $ */
a22 1
#include <sys/kthread.h>
@


1.2
log
@remove all the cruft i had in there while trying to figure this stuff out

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pxa27x_udc.c,v 1.1 2005/02/17 22:10:35 dlg Exp $ */
d85 4
d111 1
a111 1
	pxa2x0_gpio_set_bit(37);
@


1.1
log
@a driver for the usb device controller. at the moment it only hardwires the
physical port on a zaurus to the host controller. needs lots of cleanup.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a37 2
void	pxaudc_intr(void *);

a42 2
	void			*sc_ih;
	int			sc_intr;
d46 1
a46 1
        sizeof(struct pxaudc_softc), pxaudc_match, pxaudc_attach,
d51 1
a51 1
        NULL, "pxaudc", DV_DULL
a61 24
int pxaudc_intr2(void *);
int
pxaudc_intr2(void *arg)
{
	printf("thing: %d\n", pxa2x0_gpio_get_bit(41));
	return (1);
}

void pxaudc_intr1(void *);
void
pxaudc_intr1(void *arg)
{
	while (1) {
		printf("thingy: %d\n", pxa2x0_gpio_get_bit(41));
		tsleep(arg, PZERO, "tsleep", hz);
	}
}
void
pxaudc_intr(void *arg)
{
//	struct pxaudc_softc		*sc = (struct pxaudc_softc *)arg;

	kthread_create(pxaudc_intr1, arg, NULL, "pxausb");
}
a66 11

//	pxa2x0_gpio_set_function(41, GPIO_ALT_FN_2_IN);
//	pxa2x0_gpio_set_dir(41, GPIO_OUT);
//	printf("thing: %d\n", pxa2x0_gpio_get_bit(41));
//	pxa2x0_gpio_set_function(41, GPIO_OUT);
//	pxa2x0_gpio_intr_establish(41, IST_EDGE_BOTH, IPL_BIO,
//	    pxaudc_intr2, sc, sc->sc_dev.dv_xname);

//	kthread_create_deferred(pxaudc_intr, sc);


a70 2
	sc->sc_intr = pxa->pxa_intr;
	sc->sc_ih = NULL;
a72 3
	printf(": disabling USB Device Controller\n");

	/* Map I/O space */
d80 2
a107 2

	//pxa2x0_clkman_config(CKEN_USBHC, 0);
@

