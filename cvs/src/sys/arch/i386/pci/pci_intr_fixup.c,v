head	1.62;
access;
symbols
	OPENBSD_6_1_BASE:1.62
	OPENBSD_6_0:1.62.0.32
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.28
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.62.0.30
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.62.0.22
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.62.0.26
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.24
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.62.0.20
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.18
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.16
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.14
	OPENBSD_5_0:1.62.0.12
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.62.0.10
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.8
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.62.0.4
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.62.0.6
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.61.0.2
	OPENBSD_4_4_BASE:1.61
	OPENBSD_4_3:1.59.0.2
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.24
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_9_BASE:1.13
	SMP:1.13.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.62
date	2008.12.07.14.33.26;	author kettenis;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.26.05.42.11;	author ray;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.17.18.35.12;	author jcs;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.17.22.14.41;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.07.15.00.19;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.07.13.52.42;	author grange;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.19.11.06.34;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.06.01.13.22;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.06.01.07.13;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.07.20.50.48;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.12.12.17.02;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.01.18.40.08;	author kettenis;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.24.03.54.45;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.23.09.24.57;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.21.22.28.13;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.26.22.10.00;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.26.21.55.51;	author henning;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.24.22.10.51;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.24.16.02.40;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2005.10.20.15.12.27;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.20.15.09.31;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.17.19.17.24;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.15.11.42.56;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.27.23.02.09;	author beck;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.04.13.57.29;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.09.22.15.44;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.26.20.17.42;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.14.21.46.49;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.22.09.47.01;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.13.21.49.16;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.24.19.30.00;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.13.13.53.16;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.02.13.57.45;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.02.08.38.15;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.07.30.05.26.33;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.07.15.01.48.55;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.03.20.10.32;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.30.15.52.09;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.06.18.44.39;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.33;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.20.19.01.19;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.16.02.10.49;	author mickey;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.11.28.17.28.36;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.28.17.21.07;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.25.19.03.49;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.13.15.33.18;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.12.21.01.53;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.12.19.12.44;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.28.19.56.10;	author mickey;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.01.27.04.59.40;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.25.00.07.40;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.07.18.21.22;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.31.18.56.42;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.27.05.05.28;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.26.21.18.27;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.07.20.50.38;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.08.19.12.48;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.06.18.11.22;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.28.03.37.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.27.08.35.21;	author brad;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.26.22.38.37;	author mickey;	state Exp;
branches;
next	;

1.13.2.1
date	2001.04.18.16.08.27;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.04.10.18.04;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.10.31.03.01.13;	author nate;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.12.05.00.39.10;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.06.01.01.00;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2002.03.28.10.31.05;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2003.03.27.23.26.56;	author niklas;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2003.05.13.19.42.08;	author ho;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2003.06.07.11.11.38;	author ho;	state Exp;
branches;
next	1.13.2.10;

1.13.2.10
date	2004.02.19.10.48.42;	author niklas;	state Exp;
branches;
next	1.13.2.11;

1.13.2.11
date	2004.03.23.08.02.56;	author niklas;	state Exp;
branches;
next	1.13.2.12;

1.13.2.12
date	2004.06.05.23.09.00;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.35.54;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.05.19.21.45.12;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.62
log
@Make acpiprt(4) check whether the current interrupt routing is "possible" and
pick a new one from the list of possible routings if it isn't or if a pin is
currently not routed.  Delay re-routing interrupts until we establish a
handler for it.  This prevents us from messing with unused interrupt pins
which may have fatal consequences (some machines spontaniously reboot).

The heuristics for picking an interrupt from the list of possibe ones
probably needs some tweaking still, but this makes several NVIDIA-based
boards work much better than before.

tested by many, ok marco@@
@
text
@/*	$OpenBSD: pci_intr_fixup.c,v 1.61 2008/06/26 05:42:11 ray Exp $	*/
/*	$NetBSD: pci_intr_fixup.c,v 1.10 2000/08/10 21:18:27 soda Exp $	*/

/*
 * Copyright (c) 2001 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Copyright (c) 1999, by UCHIYAMA Yasushi
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the developer may NOT be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * PCI Interrupt Router support.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/i8259.h>
#include <machine/i82093var.h>

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#include <i386/pci/pcibiosvar.h>

struct pciintr_link_map {
	int link, clink, irq, fixup_stage;
	u_int16_t bitmap;
	SIMPLEQ_ENTRY(pciintr_link_map) list;
};

pciintr_icu_tag_t pciintr_icu_tag = NULL;
pciintr_icu_handle_t pciintr_icu_handle;

#ifdef PCIBIOS_IRQS_HINT
int pcibios_irqs_hint = PCIBIOS_IRQS_HINT;
#endif

struct pciintr_link_map *pciintr_link_lookup(int);
struct pcibios_intr_routing *pciintr_pir_lookup(int, int);
int	pciintr_bitmap_count_irq(int, int *);

SIMPLEQ_HEAD(, pciintr_link_map) pciintr_link_map_list;

const struct pciintr_icu_table {
	pci_vendor_id_t	piit_vendor;
	pci_product_id_t piit_product;
	int (*piit_init)(pci_chipset_tag_t,
		bus_space_tag_t, pcitag_t, pciintr_icu_tag_t *,
		pciintr_icu_handle_t *);
} pciintr_icu_table[] = {
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6300ESB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6321ESB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82371MX,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82371AB_ISA,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82371FB_ISA,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82371SB_ISA,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82440MX_ISA,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801AA_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801AB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801BA_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801BAM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801CA_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801CAM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801DB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801DBM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801E_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801EB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801FB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801FBM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GBM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GH_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801GHM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801IB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801IH_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801IO_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801IR_LPC,
	  piix_init },

	{ PCI_VENDOR_OPTI,	PCI_PRODUCT_OPTI_82C558,
	  opti82c558_init },
	{ PCI_VENDOR_OPTI,	PCI_PRODUCT_OPTI_82C700,
	  opti82c700_init },

	{ PCI_VENDOR_RCC,	PCI_PRODUCT_RCC_OSB4,
	  osb4_init },
	{ PCI_VENDOR_RCC,	PCI_PRODUCT_RCC_CSB5,
	  osb4_init },

	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C586_ISA,
	  via82c586_init, },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C596A,
	  via82c586_init, },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C686A_ISA,
	  via82c586_init },

	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8231_ISA,
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8233_ISA,
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8233A_ISA,
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8235_ISA,
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8237_ISA,
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8237A_ISA,
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8237S_ISA,
	  via8231_init },

	{ PCI_VENDOR_SIS,	PCI_PRODUCT_SIS_85C503,
	  sis85c503_init },
	{ PCI_VENDOR_SIS,	PCI_PRODUCT_SIS_962,
	  sis85c503_init },
	{ PCI_VENDOR_SIS,	PCI_PRODUCT_SIS_963,
	  sis85c503_init },

	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC756_PMC,
	  amd756_init },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_766_PMC,
	  amd756_init },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC768_PMC,
	  amd756_init },

	{ PCI_VENDOR_ALI,	PCI_PRODUCT_ALI_M1533,
	  ali1543_init },

	{ PCI_VENDOR_ALI,	PCI_PRODUCT_ALI_M1543,
	  ali1543_init },

	{ 0,			0,
	  NULL },
};

const struct pciintr_icu_table *pciintr_icu_lookup(pcireg_t);

const struct pciintr_icu_table *
pciintr_icu_lookup(id)
	pcireg_t id;
{
	const struct pciintr_icu_table *piit;

	for (piit = pciintr_icu_table; piit->piit_init != NULL; piit++)
		if (PCI_VENDOR(id) == piit->piit_vendor &&
		    PCI_PRODUCT(id) == piit->piit_product)
			return (piit);

	return (NULL);
}

struct pciintr_link_map *
pciintr_link_lookup(int link)
{
	struct pciintr_link_map *l;

	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list); l != NULL;
	     l = SIMPLEQ_NEXT(l, list))
		if (l->link == link)
			return (l);

	return (NULL);
}

static __inline struct pciintr_link_map *
pciintr_link_alloc(pci_chipset_tag_t pc, struct pcibios_intr_routing *pir, int pin)
{
	int link = pir->linkmap[pin].link, clink, irq;
	struct pciintr_link_map *l, *lstart;

	if (pciintr_icu_tag != NULL) {
		/*
		 * Get the canonical link value for this entry.
		 */
		if (pciintr_icu_getclink(pciintr_icu_tag, pciintr_icu_handle,
		    link, &clink) != 0) {
			/*
			 * ICU doesn't understand the link value.
			 * Just ignore this PIR entry.
			 */
			PCIBIOS_PRINTV(("pciintr_link_alloc: bus %d device %d: "
			    "ignoring link 0x%02x\n", pir->bus,
			    PIR_DEVFUNC_DEVICE(pir->device), link));
			return (NULL);
		}

		/*
		 * Check the link value by asking the ICU for the
		 * canonical link value.
		 * Also, determine if this PIRQ is mapped to an IRQ.
		 */
		if (pciintr_icu_get_intr(pciintr_icu_tag, pciintr_icu_handle,
		    clink, &irq) != 0) {
			/*
			 * ICU doesn't understand the canonical link value.
			 * Just ignore this PIR entry.
			 */
			PCIBIOS_PRINTV(("pciintr_link_alloc: "
			    "bus %d device %d link 0x%02x: "
			    "ignoring PIRQ 0x%02x\n", pir->bus,
			    PIR_DEVFUNC_DEVICE(pir->device), link, clink));
			return (NULL);
		}
	}

	if ((l = malloc(sizeof(*l), M_DEVBUF, M_NOWAIT|M_ZERO)) == NULL)
		return (NULL);

	l->link = link;
	l->bitmap = pir->linkmap[pin].bitmap;
	if (pciintr_icu_tag != NULL) { /* compatible PCI ICU found */
		l->clink = clink;
		l->irq = irq; /* maybe I386_PCI_INTERRUPT_LINE_NO_CONNECTION */
	} else {
		l->clink = link;
		l->irq = I386_PCI_INTERRUPT_LINE_NO_CONNECTION;
	}

	lstart = SIMPLEQ_FIRST(&pciintr_link_map_list);
	if (lstart == NULL || lstart->link < l->link)
		SIMPLEQ_INSERT_TAIL(&pciintr_link_map_list, l, list);
	else
		SIMPLEQ_INSERT_HEAD(&pciintr_link_map_list, l, list);

	return (l);
}

struct pcibios_intr_routing *
pciintr_pir_lookup(int bus, int device)
{
	struct pcibios_intr_routing *pir;
	int entry;

	if (pcibios_pir_table == NULL)
		return (NULL);

	for (entry = 0; entry < pcibios_pir_table_nentries; entry++) {
		pir = &pcibios_pir_table[entry];
		if (pir->bus == bus &&
		    PIR_DEVFUNC_DEVICE(pir->device) == device)
			return (pir);
	}

	return (NULL);
}

int
pciintr_bitmap_count_irq(int irq_bitmap, int *irqp)
{
	int i, bit, count = 0, irq = I386_PCI_INTERRUPT_LINE_NO_CONNECTION;

	if (irq_bitmap != 0)
		for (i = 0, bit = 1; i < 16; i++, bit <<= 1)
			if (irq_bitmap & bit) {
				irq = i;
				count++;
			}

	*irqp = irq;
	return (count);
}

static __inline int
pciintr_link_init(pci_chipset_tag_t pc)
{
	int entry, pin, link;
	struct pcibios_intr_routing *pir;
	struct pciintr_link_map *l;

	if (pcibios_pir_table == NULL) {
		/* No PIR table; can't do anything. */
		printf("pciintr_link_init: no PIR table\n");
		return (1);
	}

	SIMPLEQ_INIT(&pciintr_link_map_list);

	for (entry = 0; entry < pcibios_pir_table_nentries; entry++) {
		pir = &pcibios_pir_table[entry];
		for (pin = 0; pin < PCI_INTERRUPT_PIN_MAX; pin++) {
			if ((link = pir->linkmap[pin].link) == 0)
				/* No connection for this pin. */
				continue;

			/*
			 * Multiple devices may be wired to the same
			 * interrupt; check to see if we've seen this
			 * one already.  If not, allocate a new link
			 * map entry and stuff it in the map.
			 */
			if ((l = pciintr_link_lookup(link)) == NULL)
				pciintr_link_alloc(pc, pir, pin);
			else if (pir->linkmap[pin].bitmap != l->bitmap) {
				/*
				 * violates PCI IRQ Routing Table Specification
				 */
				PCIBIOS_PRINTV(("pciintr_link_init: "
				    "bus %d device %d link 0x%02x: "
				    "bad irq bitmap 0x%04x, "
				    "should be 0x%04x\n", pir->bus,
				    PIR_DEVFUNC_DEVICE(pir->device), link,
				    pir->linkmap[pin].bitmap, l->bitmap));
				/* safer value. */
				l->bitmap &= pir->linkmap[pin].bitmap;
				/* XXX - or, should ignore this entry? */
			}
		}
	}

	return (0);
}

/*
 * No compatible PCI ICU found.
 * Hopes the BIOS already setup the ICU.
 */
static __inline int
pciintr_guess_irq(void)
{
	struct pciintr_link_map *l;
	int irq, guessed = 0;

	/*
	 * Stage 1: If only one IRQ is available for the link, use it.
	 */
	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list); l != NULL;
	     l = SIMPLEQ_NEXT(l, list)) {
		if (l->irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
			continue;
		if (pciintr_bitmap_count_irq(l->bitmap, &irq) == 1) {
			l->irq = irq;
			l->fixup_stage = 1;
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf("pciintr_guess_irq (stage 1): "
				    "guessing PIRQ 0x%02x to be IRQ %d\n",
				    l->clink, l->irq);
			guessed = 1;
		}
	}

	return (guessed ? 0 : -1);
}

static __inline int
pciintr_link_fixup(void)
{
	struct pciintr_link_map *l;
	u_int16_t pciirq = 0;
	int irq;

	/*
	 * First stage: Attempt to connect PIRQs which aren't
	 * yet connected.
	 */
	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list); l != NULL;
	     l = SIMPLEQ_NEXT(l, list)) {
		if (l->irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
			/*
			 * Interrupt is already connected.  Don't do
			 * anything to it.
			 * In this case, l->fixup_stage == 0.
			 */
			pciirq |= 1 << l->irq;
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf("pciintr_link_fixup: PIRQ 0x%02x is "
				    "already connected to IRQ %d\n",
				    l->clink, l->irq);
			continue;
		}
		/*
		 * Interrupt isn't connected.  Attempt to assign it to an IRQ.
		 */
		if (pcibios_flags & PCIBIOS_INTRDEBUG)
			printf("pciintr_link_fixup: PIRQ 0x%02x not connected",
			    l->clink);

		/*
		 * Just do the easy case now; we'll defer the harder ones
		 * to Stage 2.
		 */
		if (pciintr_bitmap_count_irq(l->bitmap, &irq) == 1) {
			l->irq = irq;
			l->fixup_stage = 1;
			pciirq |= 1 << irq;
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf(", assigning IRQ %d", l->irq);
		}
		if (pcibios_flags & PCIBIOS_INTRDEBUG)
			printf("\n");
	}

	/*
	 * Stage 2: Attempt to connect PIRQs which we didn't
	 * connect in Stage 1.
	 */
	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list); l != NULL;
	     l = SIMPLEQ_NEXT(l, list))
		if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION &&
		    (irq = ffs(l->bitmap & pciirq)) > 0) {
			/*
			 * This IRQ is a valid PCI IRQ already
			 * connected to another PIRQ, and also an
			 * IRQ our PIRQ can use; connect it up!
			 */
			l->fixup_stage = 2;
			l->irq = irq - 1;
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf("pciintr_link_fixup (stage 2): "
				       "assigning IRQ %d to PIRQ 0x%02x\n",
				       l->irq, l->clink);
		}

#ifdef PCIBIOS_IRQS_HINT
	/*
	 * Stage 3: The worst case. I need configuration hint that
	 * user supplied a mask for the PCI irqs
	 */
	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list); l != NULL;
	     l = SIMPLEQ_NEXT(l, list)) {
		if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION &&
		    (irq = ffs(l->bitmap & pcibios_irqs_hint)) > 0) {
			l->fixup_stage = 3;
			l->irq = irq - 1;
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf("pciintr_link_fixup (stage 3): "
				    "assigning IRQ %d to PIRQ 0x%02x\n",
				    l->irq, l->clink);
		}
	}
#endif /* PCIBIOS_IRQS_HINT */

	if (pcibios_flags & PCIBIOS_INTRDEBUG)
		printf("pciintr_link_fixup: piirq 0x%04x\n", pciirq);

	return (0);
}

int
pci_intr_route_link(pci_chipset_tag_t pc, pci_intr_handle_t *ihp)
{
	struct pciintr_link_map *l;
	pcireg_t intr;
	int irq, rv = 1;
	char *p = NULL;

	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

	irq = ihp->line & APIC_INT_LINE_MASK;
	if (irq != 0 && irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
		pcibios_pir_header.exclusive_irq |= 1 << irq;

	l = ihp->link;
	if (!l || pciintr_icu_tag == NULL)
		return (1);

	if (l->fixup_stage == 0) {
		if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
			/* Appropriate interrupt was not found. */
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf("pci_intr_route_link: PIRQ 0x%02x: "
				    "no IRQ, try "
				    "\"option PCIBIOS_IRQS_HINT=0x%04x\"\n",
				    l->clink,
				    /* suggest irq 9/10/11, if possible */
				    (l->bitmap & 0x0e00) ? (l->bitmap & 0x0e00)
				    : l->bitmap);
		} else
			p = " preserved BIOS setting";
	} else {

		if (pciintr_icu_set_intr(pciintr_icu_tag, pciintr_icu_handle,
		    l->clink, l->irq) != 0 ||
		    pciintr_icu_set_trigger(pciintr_icu_tag, pciintr_icu_handle,
		    l->irq, IST_LEVEL) != 0) {
			p = " failed";
			rv = 0;
		} else
			p = "";
	}
	if (p && pcibios_flags & PCIBIOS_INTRDEBUG)
		printf("pci_intr_route_link: route PIRQ 0x%02x -> IRQ %d%s\n",
		    l->clink, l->irq, p);

	if (!rv)
		return (0);

	/*
	 * IRQs 14 and 15 are reserved for PCI IDE interrupts; don't muck
	 * with them.
	 */
	if (irq == 14 || irq == 15)
		return (1);

	intr = pci_conf_read(pc, ihp->tag, PCI_INTERRUPT_REG);
	if (irq != PCI_INTERRUPT_LINE(intr)) {
		intr &= ~(PCI_INTERRUPT_LINE_MASK << PCI_INTERRUPT_LINE_SHIFT);
		intr |= irq << PCI_INTERRUPT_LINE_SHIFT;
		pci_conf_write(pc, ihp->tag, PCI_INTERRUPT_REG, intr);
	}

	return (1);
}

int
pci_intr_post_fixup(void)
{
	struct pciintr_link_map *l;
	int i, pciirq;

	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

	if (!pciintr_icu_handle)
		return 0;

	pciirq = pcibios_pir_header.exclusive_irq;
	if (pcibios_flags & PCIBIOS_INTRDEBUG)
		printf("pci_intr_post_fixup: PCI IRQs:");
	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list);
	    l != NULL; l = SIMPLEQ_NEXT(l, list))
		if (l->fixup_stage == 0 && l->irq != 0 &&
		    l->irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf(" %d", l->irq);
			pciirq |= (1 << l->irq);
		}

	if (pcibios_flags & PCIBIOS_INTRDEBUG)
		printf("; ISA IRQs:");
	for (i = 0; i < 16; i++)
		if (!(pciirq & (1 << i))) {
			if (pcibios_flags & PCIBIOS_INTRDEBUG)
				printf(" %d", i);
			pciintr_icu_set_trigger(pciintr_icu_tag,
			    pciintr_icu_handle, i, IST_EDGE);
		}

	if (pcibios_flags & PCIBIOS_INTRDEBUG)
		printf("\n");

	return (0);
}

int
pci_intr_header_fixup(pci_chipset_tag_t pc, pcitag_t tag,
    pci_intr_handle_t *ihp)
{
	struct pcibios_intr_routing *pir;
	struct pciintr_link_map *l;
	int irq, link, bus, device, function;
	char *p = NULL;

	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

	irq = ihp->line & APIC_INT_LINE_MASK;
	ihp->link = NULL;
	pci_decompose_tag(pc, tag, &bus, &device, &function);

	if ((pir = pciintr_pir_lookup(bus, device)) == NULL ||
	    (link = pir->linkmap[ihp->pin - 1].link) == 0) {
		PCIBIOS_PRINTV(("Interrupt not connected; no need to change."));
		return 1;
	}

	if ((l = pciintr_link_lookup(link)) == NULL) {
		/*
		 * No link map entry.
		 * Probably pciintr_icu_getclink() or pciintr_icu_get_intr()
		 * has failed.
		 */
		if (pcibios_flags & PCIBIOS_INTRDEBUG)
			printf("pci_intr_header_fixup: no entry for link "
			    "0x%02x (%d:%d:%d:%c)\n",
			    link, bus, device, function, '@@' + ihp->pin);
		return 1;
	}

	ihp->link = l;
	if (irq == 14 || irq == 15) {
		p = " WARNING: ignored";
		ihp->link = NULL;
	} else if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {

		/* Appropriate interrupt was not found. */
		if (pciintr_icu_tag == NULL && irq != 0 &&
		    irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
			/*
			 * Do not print warning,
			 * if no compatible PCI ICU found,
			 * but the irq is already assigned by BIOS.
			 */
			p = "";
		else
			p = " WARNING: missing";
	} else if (irq == 0 || irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {

		p = " fixed up";
		ihp->line = irq = l->irq;

	} else if (pcibios_flags & PCIBIOS_FIXUP_FORCE) {
		/* routed by BIOS, but inconsistent */
		/* believe PCI IRQ Routing table */
		p = " WARNING: overriding";
		ihp->line = irq = l->irq;
	} else {
		/* believe PCI Interrupt Configuration Register (default) */
		p = " WARNING: preserving";
		ihp->line = (l->irq = irq) | (l->clink & PCI_INT_VIA_ISA);
	}

	if (pcibios_flags & PCIBIOS_INTRDEBUG) {
		pcireg_t id = pci_conf_read(pc, tag, PCI_ID_REG);

		printf("\n%d:%d:%d %04x:%04x pin %c clink 0x%02x irq %d "
		    "stage %d %s irq %d\n", bus, device, function,
		    PCI_VENDOR(id), PCI_PRODUCT(id), '@@' + ihp->pin, l->clink,
		    ((l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION)?
		    -1 : l->irq), l->fixup_stage, p, irq);
	}

	return (1);
}

int
pci_intr_fixup(struct pcibios_softc *sc, pci_chipset_tag_t pc,
    bus_space_tag_t iot)
{
	struct pcibios_pir_header *pirh = &pcibios_pir_header;
	const struct pciintr_icu_table *piit = NULL;
	pcitag_t icutag;

	/*
	 * Attempt to initialize our PCI interrupt router.  If
	 * the PIR Table is present in ROM, use the location
	 * specified by the PIR Table, and use the compat ID,
	 * if present.  Otherwise, we have to look for the router
	 * ourselves (the PCI-ISA bridge).
	 *
	 * A number of buggy BIOS implementations leave the router
	 * entry as 000:00:0, which is typically not the correct
	 * device/function.  If the router device address is set to
	 * this value, and the compatible router entry is undefined
	 * (zero is the correct value to indicate undefined), then we
	 * work on the basis it is most likely an error, and search
	 * the entire device-space of bus 0 (but obviously starting
	 * with 000:00:0, in case that really is the right one).
	 */
	if (pirh->signature != 0 && (pirh->router_bus != 0 ||
	    pirh->router_devfunc != 0 || pirh->compat_router != 0)) {

		icutag = pci_make_tag(pc, pirh->router_bus,
		    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc));
		if (pirh->compat_router == 0 ||
		    (piit = pciintr_icu_lookup(pirh->compat_router)) == NULL) {
			/*
			 * No compat ID, or don't know the compat ID?  Read
			 * it from the configuration header.
			 */
			pirh->compat_router = pci_conf_read(pc, icutag,
			    PCI_ID_REG);
		}
		if (piit == NULL)
			piit = pciintr_icu_lookup(pirh->compat_router);
	} else {
		int device, maxdevs = pci_bus_maxdevs(pc, 0);

		/*
		 * Search configuration space for a known interrupt
		 * router.
		 */
		for (device = 0; device < maxdevs; device++) {
			const struct pci_quirkdata *qd;
			int function, nfuncs;
			pcireg_t icuid;
			pcireg_t bhlcr;

			icutag = pci_make_tag(pc, 0, device, 0);
			icuid = pci_conf_read(pc, icutag, PCI_ID_REG);

			/* Invalid vendor ID value? */
			if (PCI_VENDOR(icuid) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(icuid) == 0)
				continue;

			qd = pci_lookup_quirkdata(PCI_VENDOR(icuid),
			    PCI_PRODUCT(icuid));

			bhlcr = pci_conf_read(pc, icutag, PCI_BHLC_REG);
			if (PCI_HDRTYPE_MULTIFN(bhlcr) || (qd != NULL &&
			    (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
				nfuncs = 8;
			else
				nfuncs = 1;

			for (function = 0; function < nfuncs; function++) {
				icutag = pci_make_tag(pc, 0, device, function);
				icuid = pci_conf_read(pc, icutag, PCI_ID_REG);

				/* Invalid vendor ID value? */
				if (PCI_VENDOR(icuid) == PCI_VENDOR_INVALID)
					continue;
				/* Not invalid, but we've done this ~forever. */
				if (PCI_VENDOR(icuid) == 0)
					continue;

				if ((piit = pciintr_icu_lookup(icuid))) {
					pirh->compat_router = icuid;
					pirh->router_bus = 0;
					pirh->router_devfunc =
					    PIR_DEVFUNC_COMPOSE(device, 0);
					break;
				}
			}

			if (piit != NULL)
				break;
		}
	}

	if (piit == NULL) {
		printf("%s: no compatible PCI ICU found", sc->sc_dev.dv_xname);
		if (pirh->signature != 0 && pirh->compat_router != 0)
			printf(": ICU vendor 0x%04x product 0x%04x",
			    PCI_VENDOR(pirh->compat_router),
			    PCI_PRODUCT(pirh->compat_router));
		printf("\n");
		if (!(pcibios_flags & PCIBIOS_INTR_GUESS)) {
			if (pciintr_link_init(pc))
				return (-1);	/* non-fatal */
			if (pciintr_guess_irq())
				return (-1);	/* non-fatal */
		}
		return (0);
	} else {
		char devinfo[256];

		printf("%s: PCI Interrupt Router at %03d:%02d:%01d",
		    sc->sc_dev.dv_xname, pirh->router_bus,
		    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc));
		if (pirh->compat_router != 0) {
			pci_devinfo(pirh->compat_router, 0, 0, devinfo,
			    sizeof devinfo);
			printf(" (%s)", devinfo);
		}
		printf("\n");
	}

	/*
	 * Initialize the PCI ICU.
	 */
	if ((*piit->piit_init)(pc, iot, icutag, &pciintr_icu_tag,
	    &pciintr_icu_handle) != 0)
		return (-1);		/* non-fatal */

	/*
	 * Initialize the PCI interrupt link map.
	 */
	if (pciintr_link_init(pc))
		return (-1);		/* non-fatal */

	/*
	 * Fix up the link->IRQ mappings.
	 */
	if (pciintr_link_fixup() != 0)
		return (-1);		/* non-fatal */

	return (0);
}
@


1.61
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.60 2008/05/17 18:35:12 jcs Exp $	*/
a664 1
	ihp->tag = tag;
@


1.60
log
@attach to the via vt8237s found on the hp 2133 mini-note
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.59 2007/10/17 22:14:41 brad Exp $	*/
a44 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.59
log
@Add the Intel ICH9 chipset.

Tested by damien@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.58 2007/09/07 15:00:19 art Exp $	*/
d221 2
@


1.58
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.57 2007/07/07 13:52:42 grange Exp $	*/
d183 8
@


1.57
log
@Match VIA VT8237A; from "Christoph Egger" <Christoph_Egger@@gmx.de>.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.56 2006/09/19 11:06:34 jsg Exp $	*/
d309 1
a309 1
	if ((l = malloc(sizeof(*l), M_DEVBUF, M_NOWAIT)) == NULL)
a310 2

	memset(l, 0, sizeof(*l));
@


1.56
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.55 2006/08/06 01:13:22 brad Exp $	*/
d211 2
@


1.55
log
@add the Intel 82801GHM LPC and 6321ESB LPC
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.54 2006/08/06 01:07:13 brad Exp $	*/
d254 1
a254 2
pciintr_link_lookup(link)
	int link;
d332 1
a332 2
pciintr_pir_lookup(bus, device)
	int bus, device;
d351 1
a351 2
pciintr_bitmap_count_irq(irq_bitmap, irqp)
	int irq_bitmap, *irqp;
d542 1
a542 3
pci_intr_route_link(pc, ihp)
	pci_chipset_tag_t pc;
	pci_intr_handle_t *ihp;
d609 1
a609 1
pci_intr_post_fixup()
d649 2
a650 4
pci_intr_header_fixup(pc, tag, ihp)
	pci_chipset_tag_t pc;
	pcitag_t tag;
	pci_intr_handle_t *ihp;
d718 1
a718 1
		register pcireg_t id = pci_conf_read(pc, tag, PCI_ID_REG);
d731 2
a732 4
pci_intr_fixup(sc, pc, iot)
	struct pcibios_softc *sc;
	pci_chipset_tag_t pc;
	bus_space_tag_t iot;
@


1.54
log
@add the Intel 82801DBM LPC.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.53 2006/03/07 20:50:48 brad Exp $	*/
d140 2
d181 2
@


1.53
log
@- Use the correct initialization routine for the VIA VT8233 chipset
  now that kettenis@@ has corrected the PCI id entry.
- Add the SiS 962 chipset.

ok kettenis@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.52 2006/01/12 12:17:02 jsg Exp $	*/
d163 2
@


1.52
log
@Fix up interrupt routing on SiS 963.
From Ian McWilliam ian at dodo.com.au.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.51 2006/01/01 18:40:08 kettenis Exp $	*/
d189 2
a192 2
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C586_ISA,
	  via82c586_init, },
a194 2
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8233_ISA,
	  via82c586_init },
d198 2
d208 2
@


1.51
log
@Adjust for renamed VIA VT8233 PCI ID's.
ok brad@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.50 2005/11/24 03:54:45 brad Exp $	*/
d208 2
@


1.50
log
@add AMD 768 interrupt router PCI id and use the proper id for the AMD 766 chipset.

Thanks to Gordon Willem Klok <gklok at cogeco dot ca> for testing on a 768 based board.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.49 2005/11/23 09:24:57 mickey Exp $	*/
d195 1
a195 1
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8366_ISA,
d200 1
a200 1
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8233_ISA,
@


1.49
log
@resolve a couple of problems in mpbios-mapped interrupts:
- synthesise isa mappings (as 1-1) should those be missing in mpbios;
- for rcc osb* firce "special" ints into isa mappings always.
niklas@@ ok and testing by many since
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.48 2005/11/21 22:28:13 brad Exp $	*/
d212 3
a214 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_766_ISA,
@


1.48
log
@add a handful of Intel PCI interrupt routers to the table.

82440MX_ISA, 82801AB_LPC, 82801E_LPC, 82801FBM_LPC, 82801GBM_LPC and 82801GH_LPC

ok mickey@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.47 2005/10/26 22:10:00 mickey Exp $	*/
d104 1
d539 1
a539 1
	int rv = 1;
d545 3
a547 3
	if (ihp->line != 0 &&
	    ihp->line != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
		pcibios_pir_header.exclusive_irq |= (1 << ihp->line);
d588 1
a588 1
	if (ihp->line == 14 || ihp->line == 15)
d592 1
a592 1
	if (ihp->line != PCI_INTERRUPT_LINE(intr)) {
d594 1
a594 1
		intr |= (ihp->line << PCI_INTERRUPT_LINE_SHIFT);
d655 1
a655 1
	irq = ihp->line;
d670 1
a670 1
		 * was failed.
d686 2
a687 2
		if (pciintr_icu_tag == NULL && ihp->line != 0 &&
		    ihp->line != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
d699 1
a699 1
		ihp->line = l->irq;
d705 1
a705 1
		ihp->line = l->irq;
d709 1
a709 1
		ihp->line = l->irq = irq;
@


1.47
log
@add vt8233 and vt8235 (at least 8235 verified in docs)
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.46 2005/10/26 21:55:51 henning Exp $	*/
d137 2
d147 2
d151 2
d163 2
d169 2
d173 3
a175 1
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_6300ESB_LPC,
@


1.46
log
@add via 8237 back, works now
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.43 2005/10/20 15:12:27 mickey Exp $	*/
d186 4
@


1.45
log
@add Intel 6300ESB

Thanks to Sébastien Taylor <staylor at gridworx dot ca> for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.44 2005/10/24 16:02:40 henning Exp $	*/
d186 2
@


1.44
log
@don't touch via 8237 for now, until it is fixed.
what mickey committed is obviosuly NOT what I tested, since that worked.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.43 2005/10/20 15:12:27 mickey Exp $	*/
d162 2
@


1.43
log
@fix a long-standing bug in "preserving" bios mapped irqs.
in case bios did not provide routing info for those they
would be falsely routed often to wrong pins.
also testing by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.42 2005/10/20 15:09:31 mickey Exp $	*/
a183 2
	  via8231_init },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8237_ISA,
@


1.42
log
@add 8237 support and repair 8231 that was confused very bad; lots of testing help by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.41 2005/10/17 19:17:24 mickey Exp $	*/
d687 1
a687 1
	} else
d690 2
d696 2
a697 2
		printf("%d:%d:%d %04x:%04x pin %c clink 0x%02x irq %d stage %d"
		    "%s irq %d\n", bus, device, function,
@


1.41
log
@don't say no more if there is no driver for icu; lessen noise
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.40 2005/10/15 11:42:56 brad Exp $	*/
d184 2
@


1.40
log
@Tweak names and add entries to the RCC (ServerWorks/Broadcom) PCI ids.

Based on Linux's pci.ids and sata_svw.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.39 2005/09/27 23:02:09 beck Exp $	*/
d815 2
a816 3
			return (0);		/* success! */
		} else
			return (-1);		/* non-fatal */
@


1.39
log
@call the init routine for the Intel 82801_FB LPC so that the interrupt
routing table can be found on such boards.
ok mickey@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.38 2005/08/04 13:57:29 mickey Exp $	*/
d169 1
a169 1
	{ PCI_VENDOR_RCC,	PCI_PRODUCT_RCC_ROSB4,
@


1.38
log
@match on ich7; testing by Mark.Peoples@@asu.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.37 2005/07/09 22:15:44 mickey Exp $	*/
d158 2
@


1.37
log
@also match on 82801CA; from mkoc@@prime.pl
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.36 2004/09/26 20:17:42 mickey Exp $	*/
d158 2
@


1.36
log
@make PCIBIOS_INTR_FIXUP_FORCE into an UKCable flag instead; from Thorsten Glaser <tg@@66h.42h.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.35 2004/07/14 21:46:49 mickey Exp $	*/
d150 2
@


1.35
log
@treat via8366 as via586; from rees@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.34 2004/06/22 09:47:01 mickey Exp $	*/
d674 1
a674 1
	} else {
a675 1
#ifdef PCIBIOS_INTR_FIXUP_FORCE
d679 1
a679 1
#else
a681 2
#endif
	}
@


1.34
log
@support for rcc osb4 and csb5; tested on quad-zion and another box i have
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.33 2004/06/13 21:49:16 niklas Exp $	*/
d173 2
@


1.33
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d162 5
@


1.32
log
@skip _only_ irq 14 and 15; tested by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.31 2004/02/13 13:53:16 mickey Exp $	*/
d103 1
a108 1
#include <i386/isa/icu.h>
@


1.31
log
@avoid routing irqs that we ignore (14 15); from form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.30 2004/01/02 13:57:45 mickey Exp $	*/
d645 2
a646 1
	if (irq == 14 || irq == 15)
d648 2
a649 1
	else if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
a665 1
		ihp->link = l;
a672 1
		ihp->link = l;
@


1.30
log
@attach on two more ICHs
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.29 2004/01/02 08:38:15 millert Exp $	*/
a644 1
	ihp->link = l;
d664 1
d672 1
@


1.29
log
@PCI_PRODUCT_ALI_M1533 should use ali1543_init too.  When the PCI id for
PCI_PRODUCT_ALI_M1543 was fixed machines with an M1533 stopped working.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.28 2003/07/30 05:26:33 mickey Exp $	*/
d150 4
@


1.28
log
@support for vt8231 from netbsd via pr3362 and tested by matthew.gream@@pobox.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.27 2003/07/15 01:48:55 mickey Exp $	*/
d176 3
@


1.27
log
@match on ich5 as piix; from couderc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.26 2003/06/03 20:10:32 mickey Exp $	*/
d164 4
a167 1
	  via82c586_init, },
@


1.26
log
@three four kill
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.25 2003/04/27 11:22:52 ho Exp $	*/
d150 2
@


1.25
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.24 2002/05/30 15:52:09 mickey Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@iff pcibios is enabled, record _every_ established pci interrupt
for it will not get reprogrammed for isa later.
should help lost and hanging pci interrupts.
testing by fries@@, krw@@, mordin@@, philipp@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.23 2002/05/06 18:44:39 mickey Exp $	*/
d808 2
a809 1
			pci_devinfo(pirh->compat_router, 0, 0, devinfo);
@


1.23
log
@drop out of any intr fixup activities if was disabled in the config flags
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.22 2002/03/14 01:26:33 millert Exp $	*/
d504 4
d577 1
a577 1
		if (l->fixup_stage == 0 &&
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.21 2002/02/20 19:01:19 mickey Exp $	*/
d501 3
d562 3
d606 3
@


1.21
log
@support amd766 as amd756; from peter@@ (pr/1948); tested by Henning Brauer <lists-openbsdbugs@@bsws.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.20 2001/12/16 02:10:49 mickey Exp $	*/
d129 3
a131 3
struct pciintr_link_map *pciintr_link_lookup __P((int));
struct pcibios_intr_routing *pciintr_pir_lookup __P((int, int));
int	pciintr_bitmap_count_irq __P((int, int *));
d138 1
a138 1
	int (*piit_init) __P((pci_chipset_tag_t,
d140 1
a140 1
		pciintr_icu_handle_t *));
d184 1
a184 1
const struct pciintr_icu_table *pciintr_icu_lookup __P((pcireg_t));
@


1.20
log
@match piix icu type on 82810ba/m; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.19 2001/11/28 17:28:36 mickey Exp $	*/
d173 2
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.20 2001/12/16 02:10:49 mickey Exp $	*/
d129 3
a131 3
struct pciintr_link_map *pciintr_link_lookup(int);
struct pcibios_intr_routing *pciintr_pir_lookup(int, int);
int	pciintr_bitmap_count_irq(int, int *);
d138 1
a138 1
	int (*piit_init)(pci_chipset_tag_t,
d140 1
a140 1
		pciintr_icu_handle_t *);
a173 2
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_766_ISA,
	  amd756_init },
d182 1
a182 1
const struct pciintr_icu_table *pciintr_icu_lookup(pcireg_t);
a498 7
	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

	if (ihp->line != 0 &&
	    ihp->line != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
		pcibios_pir_header.exclusive_irq |= (1 << ihp->line);

a556 3
	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

d565 1
a565 1
		if (l->fixup_stage == 0 && l->irq != 0 &&
a597 3

	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;
@


1.20.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d808 1
a808 2
			pci_devinfo(pirh->compat_router, 0, 0, devinfo,
			    sizeof devinfo);
@


1.19
log
@somebody forgot something
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.17 2001/10/25 19:03:49 mickey Exp $	*/
d151 4
@


1.18
log
@revert hardware breakage
@
text
@d168 1
a168 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC756_ISA,
@


1.17
log
@add an ali1543 and fix amd756 icu drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.16 2001/05/13 15:33:18 mickey Exp $	*/
d168 1
a168 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC756_PMC,
@


1.16
log
@left tag uninitted in the good case in the last commit; jason@@ pointed it out
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.15 2001/05/12 21:01:53 mickey Exp $	*/
d168 1
a168 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC756_ISA,
d170 3
@


1.15
log
@A number of buggy BIOS implementations leave the router
entry as 000:00:0, which is typically not the correct
device/function.  If the router device address is set to
this value, and the compatible router entry is undefined
(zero is the correct value to indicate undefined), then we
work on the basis it is most likely an error, and search
the entire device-space of bus 0 (but obviously starting
with 000:00:0, in case that really is the right one).
from Dave Sainty <dave@@dtsp.co.nz>
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.14 2001/05/12 19:12:44 mickey Exp $	*/
d691 3
d700 1
a700 4
			pirh->compat_router = pci_conf_read(pc,
			    pci_make_tag(pc, pirh->router_bus,
			    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
			    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc)),
@


1.14
log
@always print the icu we've found
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13 2001/01/28 19:56:10 mickey Exp $	*/
a670 1
	pcireg_t icuid;
d678 9
d688 5
a692 7
	if (pirh->signature != 0) {
		icutag = pci_make_tag(pc, pirh->router_bus,
		    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc));
		icuid = pirh->compat_router;
		if (icuid == 0 ||
		    (piit = pciintr_icu_lookup(icuid)) == NULL) {
d697 5
a701 1
			icuid = pci_conf_read(pc, icutag, PCI_ID_REG);
d704 1
a704 1
			piit = pciintr_icu_lookup(icuid);
d713 5
d728 31
a758 5
			if ((piit = pciintr_icu_lookup(icuid))) {
				pirh->compat_router = icuid;
				pirh->router_bus = 0;
				pirh->router_devfunc =
				    PIR_DEVFUNC_COMPOSE(device, 0);
a759 1
			}
d765 1
a765 1
		if (pirh->signature != 0 && icuid != 0)
d767 2
a768 1
			    PCI_VENDOR(icuid), PCI_PRODUCT(icuid));
@


1.13
log
@better message
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.12 2001/01/27 04:59:40 mickey Exp $	*/
d663 2
a664 1
pci_intr_fixup(pc, iot)
d668 1
d680 5
a684 5
	if (pcibios_pir_header.signature != 0) {
		icutag = pci_make_tag(pc, pcibios_pir_header.router_bus,
		    PIR_DEVFUNC_DEVICE(pcibios_pir_header.router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pcibios_pir_header.router_devfunc));
		icuid = pcibios_pir_header.compat_router;
d713 5
a717 1
			if ((piit = pciintr_icu_lookup(icuid)))
d719 1
d724 2
a725 2
		printf("pcibios: no compatible PCI ICU found");
		if (pcibios_pir_header.signature != 0 && icuid != 0)
d737 12
@


1.13.2.1
log
@Update the SMP branch to -current, this breaks the SMP branch though.
But it will be fixed soonish.  Note, nothing new has happened, this is just
a merge of the trunk into this branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13 2001/01/28 19:56:10 mickey Exp $	*/
@


1.13.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13.2.1 2001/04/18 16:08:27 niklas Exp $	*/
d663 1
a663 2
pci_intr_fixup(sc, pc, iot)
	struct pcibios_softc *sc;
a666 1
	struct pcibios_pir_header *pirh = &pcibios_pir_header;
d669 1
a676 9
	 *
	 * A number of buggy BIOS implementations leave the router
	 * entry as 000:00:0, which is typically not the correct
	 * device/function.  If the router device address is set to
	 * this value, and the compatible router entry is undefined
	 * (zero is the correct value to indicate undefined), then we
	 * work on the basis it is most likely an error, and search
	 * the entire device-space of bus 0 (but obviously starting
	 * with 000:00:0, in case that really is the right one).
d678 7
a684 8
	if (pirh->signature != 0 && (pirh->router_bus != 0 ||
	    pirh->router_devfunc != 0 || pirh->compat_router != 0)) {

		icutag = pci_make_tag(pc, pirh->router_bus,
		    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc));
		if (pirh->compat_router == 0 ||
		    (piit = pciintr_icu_lookup(pirh->compat_router)) == NULL) {
d689 1
a689 2
			pirh->compat_router = pci_conf_read(pc, icutag,
			    PCI_ID_REG);
d692 1
a692 1
			piit = pciintr_icu_lookup(pirh->compat_router);
a700 5
			const struct pci_quirkdata *qd;
			int function, nfuncs;
			pcireg_t icuid;
			pcireg_t bhlcr;

d711 1
a711 31
			qd = pci_lookup_quirkdata(PCI_VENDOR(icuid),
			    PCI_PRODUCT(icuid));

			bhlcr = pci_conf_read(pc, icutag, PCI_BHLC_REG);
			if (PCI_HDRTYPE_MULTIFN(bhlcr) || (qd != NULL &&
			    (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
				nfuncs = 8;
			else
				nfuncs = 1;

			for (function = 0; function < nfuncs; function++) {
				icutag = pci_make_tag(pc, 0, device, function);
				icuid = pci_conf_read(pc, icutag, PCI_ID_REG);

				/* Invalid vendor ID value? */
				if (PCI_VENDOR(icuid) == PCI_VENDOR_INVALID)
					continue;
				/* Not invalid, but we've done this ~forever. */
				if (PCI_VENDOR(icuid) == 0)
					continue;

				if ((piit = pciintr_icu_lookup(icuid))) {
					pirh->compat_router = icuid;
					pirh->router_bus = 0;
					pirh->router_devfunc =
					    PIR_DEVFUNC_COMPOSE(device, 0);
					break;
				}
			}

			if (piit != NULL)
d717 2
a718 2
		printf("%s: no compatible PCI ICU found", sc->sc_dev.dv_xname);
		if (pirh->signature != 0 && pirh->compat_router != 0)
d720 1
a720 2
			    PCI_VENDOR(pirh->compat_router),
			    PCI_PRODUCT(pirh->compat_router));
a729 12
	} else {
		char devinfo[256];

		printf("%s: PCI Interrupt Router at %03d:%02d:%01d",
		    sc->sc_dev.dv_xname, pirh->router_bus,
		    PIR_DEVFUNC_DEVICE(pirh->router_devfunc),
		    PIR_DEVFUNC_FUNCTION(pirh->router_devfunc));
		if (pirh->compat_router != 0) {
			pci_devinfo(pirh->compat_router, 0, 0, devinfo);
			printf(" (%s)", devinfo);
		}
		printf("\n");
@


1.13.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13.2.2 2001/07/04 10:18:04 niklas Exp $	*/
d168 1
a168 1
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_PBC756_PMC,
a169 3

	{ PCI_VENDOR_ALI,	PCI_PRODUCT_ALI_M1543,
	  ali1543_init },
@


1.13.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13.2.3 2001/10/31 03:01:13 nate Exp $	*/
@


1.13.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a151 4
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801BA_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801BAM_LPC,
	  piix_init },
a168 2
	  amd756_init },
	{ PCI_VENDOR_AMD,	PCI_PRODUCT_AMD_766_ISA,
@


1.13.2.6
log
@Merge in -current from about a week ago
@
text
@d129 3
a131 3
struct pciintr_link_map *pciintr_link_lookup(int);
struct pcibios_intr_routing *pciintr_pir_lookup(int, int);
int	pciintr_bitmap_count_irq(int, int *);
d138 1
a138 1
	int (*piit_init)(pci_chipset_tag_t,
d140 1
a140 1
		pciintr_icu_handle_t *);
d184 1
a184 1
const struct pciintr_icu_table *pciintr_icu_lookup(pcireg_t);
@


1.13.2.7
log
@Sync the SMP branch with 3.3
@
text
@a500 7
	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

	if (ihp->line != 0 &&
	    ihp->line != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
		pcibios_pir_header.exclusive_irq |= (1 << ihp->line);

a558 3
	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;

d567 1
a567 1
		if (l->fixup_stage == 0 && l->irq != 0 &&
a599 3

	if (pcibios_flags & PCIBIOS_INTR_FIXUP)
		return 1;
@


1.13.2.8
log
@Sync the SMP branch to -current, plus some ELF-related fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13.2.7 2003/03/27 23:26:56 niklas Exp $	*/
d808 1
a808 2
			pci_devinfo(pirh->compat_router, 0, 0, devinfo,
			    sizeof devinfo);
@


1.13.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13.2.8 2003/05/13 19:42:08 ho Exp $	*/
d16 5
@


1.13.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a150 6
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801CAM_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,     PCI_PRODUCT_INTEL_82801DB_LPC,
	  piix_init },
	{ PCI_VENDOR_INTEL,	PCI_PRODUCT_INTEL_82801EB_LPC,
	  piix_init },
d162 1
a162 4
	  via82c586_init },

	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT8231_ISA,
	  via8231_init },
a170 3

	{ PCI_VENDOR_ALI,	PCI_PRODUCT_ALI_M1533,
	  ali1543_init },
@


1.13.2.11
log
@a small step towards an integrated PIC/APIC system: move isa/icu.h to
include/i8259.h, and adapt the ACK/MASK/UNMASK macros so we can
reuse the API for APICs.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.13.2.10 2004/02/19 10:48:42 niklas Exp $	*/
a102 1
#include <machine/i8259.h>
d108 1
@


1.13.2.12
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d646 1
a646 1
	if (irq == 14 || irq == 15) {
d648 1
a648 2
		ihp->link = NULL;
	} else if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
@


1.12
log
@change interrupt routing strategy from simple
run through the devices and programming the icu
and pci headers before real pci bus autoconf starts
and include all devices present on all pci busses,
to a per attached device routing in pci_intr_map().
this solves several cases of premature interrupts hanging
system due to absent interrupt handlers during autoconf.
10x for testing: millert@@ krw@@ aaron@@ chris@@ tholo@@ brad@@ jason@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.11 2001/01/25 00:07:40 mickey Exp $	*/
d717 1
a717 1
		printf("pci_intr_fixup: no compatible PCI ICU found");
@


1.11
log
@put pci_intr_fixup.h into pcibiosvar.h; billions of tiny headers for nothing
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.10 2000/11/07 18:21:22 mickey Exp $	*/
d4 30
a69 1

d117 1
a117 3
	int link;
	int clink;
	int irq;
a118 1
	int fixup_stage;
a129 2
struct pciintr_link_map *pciintr_link_alloc __P((struct pcibios_intr_routing *,
	int));
d131 1
a131 9
static int pciintr_bitmap_count_irq __P((int, int *));
static int pciintr_bitmap_find_lowest_irq __P((int, int *));
int	pciintr_link_init __P((void));
int	pciintr_guess_irq __P((void));
int	pciintr_link_fixup __P((void));
int	pciintr_link_route __P((u_int16_t *));
int	pciintr_irq_release __P((u_int16_t *));
int	pciintr_header_fixup __P((pci_chipset_tag_t));
void	pciintr_do_header_fixup __P((pci_chipset_tag_t, pcitag_t));
d158 2
d162 2
d183 1
a183 3
	for (piit = pciintr_icu_table;
	     piit->piit_init != NULL;
	     piit++) {
a186 1
	}
d198 1
a198 1
	     l = SIMPLEQ_NEXT(l, list)) {
a200 1
	}
d205 2
a206 4
struct pciintr_link_map *
pciintr_link_alloc(pir, pin)
	struct pcibios_intr_routing *pir;
	int pin;
d221 3
a223 5
#ifdef PCIBIOSVERBOSE
			printf("pciintr_link_alloc: bus %d device %d: "
			    "ignoring link 0x%02x\n",
			    pir->bus, PIR_DEVFUNC_DEVICE(pir->device), link);
#endif
d238 1
a238 2
#ifdef PCIBIOSVERBOSE
			printf("pciintr_link_alloc: "
d241 1
a241 2
			    PIR_DEVFUNC_DEVICE(pir->device), link, clink);
#endif
d246 1
a246 2
	l = malloc(sizeof(*l), M_DEVBUF, M_NOWAIT);
	if (l == NULL)
d257 1
a257 1
		l->clink = link; /* only for PCIBIOSVERBOSE diagnostic */
d290 1
a290 1
static int
d296 2
a297 2
	if (irq_bitmap != 0) {
		for (i = 0, bit = 1; i < 16; i++, bit <<= 1) {
d302 1
a302 2
		}
	}
d307 2
a308 19
static int
pciintr_bitmap_find_lowest_irq(irq_bitmap, irqp)
	int irq_bitmap, *irqp;
{
	int i, bit;

	if (irq_bitmap != 0) {
		for (i = 0, bit = 1; i < 16; i++, bit <<= 1) {
			if (irq_bitmap & bit) {
				*irqp = i;
				return (1); /* found */
			}
		}
	}
	return (0); /* not found */
}

int
pciintr_link_init()
d325 1
a325 2
			link = pir->linkmap[pin].link;
			if (link == 0) {
d328 1
a328 1
			}
d335 3
a337 4
			l = pciintr_link_lookup(link);
			if (l == NULL) {
				(void) pciintr_link_alloc(pir, pin);
			} else if (pir->linkmap[pin].bitmap != l->bitmap) {
d341 1
a341 2
#ifdef PCIBIOSVERBOSE
				printf("pciintr_link_init: "
d344 3
a346 4
				    "should be 0x%04x\n",
				    pir->bus, PIR_DEVFUNC_DEVICE(pir->device),
				    link, pir->linkmap[pin].bitmap, l->bitmap);
#endif
d361 2
a362 2
int
pciintr_guess_irq()
d377 4
a380 5
#ifdef PCIINTR_DEBUG
			printf("pciintr_guess_irq (stage 1): "
			    "guessing PIRQ 0x%02x to be IRQ %d\n",
			    l->clink, l->irq);
#endif
d388 2
a389 2
int
pciintr_link_fixup()
d392 1
a393 1
	u_int16_t pciirq = 0;
d408 4
a411 4
#ifdef PCIINTR_DEBUG
			printf("pciintr_link_fixup: PIRQ 0x%02x already "
			    "connected to IRQ %d\n", l->clink, l->irq);
#endif
d417 4
a420 4
#ifdef PCIINTR_DEBUG
		printf("pciintr_link_fixup: PIRQ 0x%02x not connected",
		    l->clink);
#endif
d429 2
a430 3
#ifdef PCIINTR_DEBUG
			printf(", assigning IRQ %d", l->irq);
#endif
d432 2
a433 3
#ifdef PCIINTR_DEBUG
		printf("\n");
#endif
d441 3
a443 5
	     l = SIMPLEQ_NEXT(l, list)) {
		if (l->irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
			continue;
		if (pciintr_bitmap_find_lowest_irq(l->bitmap & pciirq,
		    &l->irq)) {
d450 5
a454 5
#ifdef PCIINTR_DEBUG
			printf("pciintr_link_fixup (stage 2): "
			       "assigning IRQ %d to PIRQ 0x%02x\n",
			       l->irq, l->clink);
#endif
a455 1
	}
d464 2
a465 4
		if (l->irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
			continue;
		if (pciintr_bitmap_find_lowest_irq(
		    l->bitmap & pcibios_irqs_hint, &l->irq)) {
d467 5
a471 5
#ifdef PCIINTR_DEBUG
			printf("pciintr_link_fixup (stage 3): "
			       "assigning IRQ %d to PIRQ 0x%02x\n",
			       l->irq, l->clink);
#endif
d476 3
d483 3
a485 2
pciintr_link_route(pciirq)
	u_int16_t *pciirq;
d488 3
a490 1
	int rv = 0;
d492 3
a494 1
	*pciirq = 0;
d496 7
a502 9
	for (l = SIMPLEQ_FIRST(&pciintr_link_map_list); l != NULL;
	     l = SIMPLEQ_NEXT(l, list)) {
		if (l->fixup_stage == 0) {
			if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
				/* Appropriate interrupt was not found. */
#ifdef PCIBIOSVERBOSE
				printf("pciintr_link_route: "
				    "PIRQ 0x%02x: no IRQ, try "
				    "\"options PCIBIOS_IRQS_HINT=0x%04x\"\n",
d507 3
a509 13
#endif
			} else {
				/* BIOS setting has no problem */
#ifdef PCIINTR_DEBUG
				printf("pciintr_link_route: "
				    "route of PIRQ 0x%02x -> "
				    "IRQ %d preserved BIOS setting\n",
				    l->clink, l->irq);
#endif
				*pciirq |= (1 << l->irq);
			}
			continue; /* nothing to do. */
		}
d512 7
a518 14
					 l->clink, l->irq) != 0 ||
		    pciintr_icu_set_trigger(pciintr_icu_tag,
					    pciintr_icu_handle,
					    l->irq, IST_LEVEL) != 0) {
			printf("pciintr_link_route: route of PIRQ 0x%02x -> "
			    "IRQ %d failed\n", l->clink, l->irq);
			rv = 1;
		} else {
			/*
			 * Succssfully routed interrupt.  Mark this as
			 * a PCI interrupt.
			 */
			*pciirq |= (1 << l->irq);
		}
d520 3
d524 2
a525 2
	return (rv);
}
d527 6
a532 5
int
pciintr_irq_release(pciirq)
	u_int16_t *pciirq;
{
	int i, bit;
d534 5
a538 4
	for (i = 0, bit = 1; i < 16; i++, bit <<= 1) {
		if ((*pciirq & bit) == 0)
			(void) pciintr_icu_set_trigger(pciintr_icu_tag,
			    pciintr_icu_handle, i, IST_EDGE);
d541 1
a541 1
	return (0);
d545 1
a545 2
pciintr_header_fixup(pc)
	pci_chipset_tag_t pc;
d547 30
a576 5
	PCIBIOS_PRINTV(("------------------------------------------\n"));
	PCIBIOS_PRINTV(("  device vendor product pin PIRQ IRQ stage\n"));
	PCIBIOS_PRINTV(("------------------------------------------\n"));
	pci_device_foreach(pc, pcibios_max_bus, pciintr_do_header_fixup);
	PCIBIOS_PRINTV(("------------------------------------------\n"));
d581 2
a582 2
void
pciintr_do_header_fixup(pc, tag)
d585 1
d589 2
a590 3
	int pin, irq, link;
	int bus, device, function;
	pcireg_t intr, id;
d592 3
a595 1
	id = pci_conf_read(pc, tag, PCI_ID_REG);
d597 4
a600 9
	intr = pci_conf_read(pc, tag, PCI_INTERRUPT_REG);
	pin = PCI_INTERRUPT_PIN(intr);
	irq = PCI_INTERRUPT_LINE(intr);

	if (pin == 0) {
		/*
		 * No interrupt used.
		 */
		return;
d603 1
a603 12
	pir = pciintr_pir_lookup(bus, device);
	if (pir == NULL || (link = pir->linkmap[pin - 1].link) == 0) {
		/*
		 * Interrupt not connected; no
		 * need to change.
		 */
		return;
	}

	l = pciintr_link_lookup(link);
	if (l == NULL) {
#ifdef PCIINTR_DEBUG
d609 5
a613 5
		printf("pciintr_header_fixup: no entry for link 0x%02x "
		       "(%d:%d:%d:%c)\n", link, bus, device, function,
		       '@@' + pin);
#endif
		return;
d616 4
a619 12
#ifdef PCIBIOSVERBOSE
	if (pcibiosverbose) {
		printf("%03d:%02d:%d 0x%04x 0x%04x   %c  0x%02x",
		    bus, device, function, PCI_VENDOR(id), PCI_PRODUCT(id),
		    '@@' + pin, l->clink);
		if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION)
			printf("   -");
		else
			printf(" %3d", l->irq);
		printf("  %d   ", l->fixup_stage);
	}
#endif
a620 10
	/*
	 * IRQs 14 and 15 are reserved for PCI IDE interrupts; don't muck
	 * with them.
	 */
	if (irq == 14 || irq == 15) {
		PCIBIOS_PRINTV((" WARNING: ignored\n"));
		return;
	}

	if (l->irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
d622 2
a623 2
		if (pciintr_icu_tag == NULL &&
		    irq != 0 && irq != I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
d629 4
a632 6
			PCIBIOS_PRINTV(("\n"));
		} else {
			PCIBIOS_PRINTV((" WARNING: missing IRQ\n"));
		}
		return;
	}
d634 2
a635 5
	if (l->irq == irq) {
		/* don't have to reconfigure */
		PCIBIOS_PRINTV((" already assigned\n"));
		return;
	}
a636 2
	if (irq == 0 || irq == I386_PCI_INTERRUPT_LINE_NO_CONNECTION) {
		PCIBIOS_PRINTV((" fixed up\n"));
d641 2
a642 1
		PCIBIOS_PRINTV((" WARNING: overriding irq %d\n", irq));
d645 1
a645 2
		PCIBIOS_PRINTV((" WARNING: preserving irq %d\n", irq));
		return;
d649 11
a659 3
	intr &= ~(PCI_INTERRUPT_LINE_MASK << PCI_INTERRUPT_LINE_SHIFT);
	intr |= (l->irq << PCI_INTERRUPT_LINE_SHIFT);
	pci_conf_write(pc, tag, PCI_INTERRUPT_REG, intr);
d663 1
a663 1
pci_intr_fixup(pc, iot, pciirq)
a665 1
	u_int16_t *pciirq;
d711 1
a711 2
			piit = pciintr_icu_lookup(icuid);
			if (piit != NULL)
d723 1
a723 1
			if (pciintr_link_init())
a726 2
			if (pciintr_header_fixup(pc))
				return (1);	/* fatal */
d742 1
a742 1
	if (pciintr_link_init())
d751 1
a751 24
	/*
	 * Now actually program the PCI ICU with the new
	 * routing information.
	 */
	if (pciintr_link_route(pciirq) != 0)
		return (1);		/* fatal */

	/*
	 * Now that we've routed all of the PIRQs, rewrite the PCI
	 * configuration headers to reflect the new mapping.
	 */
	if (pciintr_header_fixup(pc) != 0)
		return (1);		/* fatal */

	/*
	 * Free any unused PCI IRQs for ISA devices.
	 */
	if (pciintr_irq_release(pciirq) != 0)
		return (-1);		/* non-fatal */

	/*
	 * All done!
	 */
	return (0);			/* success! */
@


1.10
log
@AMD750 Athlon chipset support for PCIBIOS_INTR_FIXUP; from minoura@@jp.netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.9 2000/10/31 18:56:42 deraadt Exp $	*/
a84 1
#include <i386/pci/pci_intr_fixup.h>
@


1.9
log
@rename pcibios.h to pcibiosvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.8 2000/10/27 05:05:28 mickey Exp $	*/
d52 12
a63 12
 * 
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
d149 3
d361 1
a361 1
				/* safer value. */  
d464 1
a464 1
			 * This IRQ is a valid PCI IRQ already 
d646 1
a646 1
	
@


1.8
log
@and angry dwarfs came on to me
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.7 2000/10/26 21:18:27 mickey Exp $	*/
d86 1
a86 1
#include <i386/pci/pcibios.h>
@


1.7
log
@match via82c586 also on other apollo chipsets, such as VT82C585, VT82C596A, VT82C686A; after pondering in linux code; krw@@ testing; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.6 2000/09/07 20:50:38 mickey Exp $	*/
a142 2
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C585,
	  via82c586_init, },
a143 4
	  via82c586_init, },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C596A,
	  via82c586_init, },
	{ PCI_VENDOR_VIATECH,	PCI_PRODUCT_VIATECH_VT82C686A_ISA,
@


1.6
log
@do not call pcibios_pir_init() if intr_fixup was disabled; also, sync w/ latetest netbsd developments
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.5 2000/08/08 19:12:48 mickey Exp $	*/
d143 2
d146 4
@


1.5
log
@sync w/ netbsd almost -current code (;
fixes quite a few problems.
adds new option PCIBIOS_ADDR_FIXUP.
numerous extra fixes by me, also pointed out by other ppl,
such as avoid panics, ifdef on pciverbose, not diagnostic,
some other smaller knits; some have been forwarded back
to netbsd developers, some will go soon too.
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_intr_fixup.c,v 1.4 2000/07/06 18:11:22 ho Exp $	*/
/*	$NetBSD: pci_intr_fixup.c,v 1.9 2000/07/22 17:43:36 soda Exp $	*/
d97 1
a97 1
pciintr_icu_tag_t pciintr_icu_tag;
d111 1
d195 1
a195 5
	/*
	 * Get the canonical link value for this entry.
	 */
	if (pciintr_icu_getclink(pciintr_icu_tag, pciintr_icu_handle, link,
	    &clink) != 0) {
d197 1
a197 2
		 * ICU doesn't understand the link value.
		 * Just ignore this PIR entry.
d199 6
d206 3
a208 3
		printf("pciintr_link_alloc: bus %d device %d: "
		    "ignoring link 0x%02x\n",
		    pir->bus, PIR_DEVFUNC_DEVICE(pir->device), link);
d210 2
a211 2
		return (NULL);
	}
a212 6
	/*
	 * Check the link value by asking the ICU for the canonical link value.
	 * Also, determine if this PIRQ is mapped to an IRQ.
	 */
	if (pciintr_icu_get_intr(pciintr_icu_tag, pciintr_icu_handle, clink,
	    &irq) != 0) {
d214 3
a216 2
		 * ICU doesn't understand the canonical link value.
		 * Just ignore this PIR entry.
d218 6
d225 4
a228 3
		printf("pciintr_link_alloc: bus %d device %d link 0x%02x: "
		    "ignoring PIRQ 0x%02x\n",
		    pir->bus, PIR_DEVFUNC_DEVICE(pir->device), link, clink);
d230 2
a231 1
		return (NULL);
d242 7
a248 2
	l->clink = clink;
	l->irq = irq; /* may be I386_PCI_INTERRUPT_LINE_NO_CONNECTION */
d317 1
a317 1
	int entry, pin, error, link;
a326 1
	error = 0;
d365 33
a397 1
	return (error);
d655 11
a665 1
		PCIBIOS_PRINTV((" WARNING: missing IRQ\n"));
d683 1
a683 1
		/* believe PCI Interrupt Configuration Register (default)  */
d751 15
a765 2
		printf("pci_intr_fixup: no compatible PCI ICU found\n");
		return (-1);		/* non-fatal */
@


1.4
log
@Add ICU 82801AA_LPC (as on the OR840 motherboard).
@
text
@d1 2
a2 2
/*	$OpenBSD: pci_intr_fixup.c,v 1.3 2000/03/28 03:37:59 mickey Exp $	*/
/*	$NetBSD: pci_intr_fixup.c,v 1.4 2000/01/25 17:20:47 augustss Exp $ */
a93 1
	int old_irq;
d100 5
a104 3
struct pciintr_link_map *pciintr_link_lookup_pin
	__P((struct pcibios_intr_routing *, int));
struct pciintr_link_map *pciintr_link_lookup_link __P((int));
d108 2
d115 1
d172 1
a172 10
pciintr_link_lookup_pin(pir, pin)
	struct pcibios_intr_routing *pir;
	int pin;
{

	return (pciintr_link_lookup_link(pir->linkmap[pin].link));
}

struct pciintr_link_map *
pciintr_link_lookup_link(link)
d191 1
d194 35
d231 1
a231 1
		panic("pciintr_link_alloc");
d235 1
a235 1
	l->link = pir->linkmap[pin].link;
d237 2
d261 2
a262 1
		if (pir->bus == bus && ((pir->device >> 3) & 0x1f) == device)
d269 35
d307 1
a307 1
	int entry, pin, error, link, clink;
d322 1
a322 1
		for (pin = 0; pin < 4; pin++) {
a327 18

			/*
			 * Check the link value by asking the ICU for
			 * the canonical link value.
			 */
			if (pciintr_icu_getclink(pciintr_icu_tag,
			    pciintr_icu_handle, link, &clink) != 0) {
				/*
				 * Table entry is bogus.  Just ignore it.
				 */
#ifdef PCIINTR_DEBUG
				printf("pciintr_link_init: bad table entry: "
				    "bus %d device %d link 0x%02x\n",
				    pir->bus, (pir->device >> 3 & 0x1f), link);
#endif
				continue;
			}

d334 2
a335 2
			l = pciintr_link_lookup_pin(pir, pin);
			if (l == NULL)
d337 16
d363 2
a364 2
	u_int16_t pciirq, bitmap;
	int i, j, cnt, irq;
a369 2
	pciirq = 0;

d372 1
a372 5
		/*
		 * Get the canonical link value for this entry.
		 */
		if (pciintr_icu_getclink(pciintr_icu_tag, pciintr_icu_handle,
		    l->link, &l->clink) != 0) {
d374 3
a376 1
			 * ICU doesn't understand this link value.
d378 1
d380 2
a381 2
			printf("pciintr_link_fixup: link 0x%02x invalid\n",
			    l->link);
a382 1
			l->clink = -1;
a384 1

d386 1
a386 1
		 * Determine if this PIRQ is mapped to an IRQ.
a387 6
		if (pciintr_icu_get_intr(pciintr_icu_tag, pciintr_icu_handle,
		    l->clink, &irq) != 0) {
			/*
			 * ICU doesn't understand this PIRQ value.
			 */
			l->clink = -1;
d389 2
a390 2
			printf("pciintr_link_fixup: PIRQ %d invalid\n",
			    l->clink);
d392 5
a396 37
			continue;
		}

		if (irq == 0xff) {
			/*
			 * Interrupt isn't connected.  Attempt to assign
			 * it to an IRQ.
			 */
#ifdef PCIINTR_DEBUG
			printf("pciintr_link_fixup: PIRQ %d not connected",
			    l->clink);
#endif
			bitmap = l->bitmap;
			for (i = 0, j = 0xff, cnt = 0; i < 16; i++)
				if (bitmap & (1 << i))
					j = i, cnt++;
			/*
			 * Just do the easy case now; we'll defer the
			 * harder ones to Stage 2.
			 */
			if (cnt == 1) {
				l->irq = j;
				l->old_irq = irq;
				l->fixup_stage = 1;
				pciirq |= 1 << j;
#ifdef PCIINTR_DEBUG
				printf(", assigning IRQ %d", l->irq);
#endif
			}
#ifdef PCIINTR_DEBUG
			printf("\n");
#endif
		} else {
			/*
			 * Interrupt is already connected.  Don't do
			 * anything to it.
			 */
d398 1
d401 1
a401 2
			printf("pciintr_link_fixup: PIRQ %d already connected "
			    "to IRQ %d\n", l->clink, l->irq);
d404 3
a408 5
#ifdef PCIBIOS_IRQS
	/* In case the user supplied a mask for the PCI irqs we use it. */
	pciirq = PCIBIOS_IRQS;
#endif

d415 10
a424 15
		if (l->irq == 0) {
			bitmap = l->bitmap;
			for (i = 0; i < 16; i++) {
				if ((pciirq & (1 << i)) != 0 &&
				    (bitmap & (1 << i)) != 0) {
					/*
					 * This IRQ is a valid PCI
					 * IRQ already connected to
					 * another PIRQ, and also an
					 * IRQ our PIRQ can use; connect
					 * it up!
					 */
					l->irq = i;
					l->old_irq = 0xff;
					l->fixup_stage = 2;
d426 3
a428 3
					printf("pciintr_link_fixup: assigning "
					    "IRQ %d to PIRQ %d\n", l->irq,
					    l->clink);
a429 3
					break;
				}
			}
d433 1
d435 2
a436 2
	 * Stage 3: Allow the user to specify interrupt routing
	 * information, overriding what we've done above.
d438 15
a452 1
	/* XXX Not implemented. */
d468 25
d495 2
a496 1
		    pciintr_icu_set_trigger(pciintr_icu_tag, pciintr_icu_handle,
d498 2
a499 2
			printf("pciintr_link_route: route of PIRQ %d -> IRQ %d"
			    " failed\n", l->clink, l->irq);
d517 1
a517 1
	int i;
d519 2
a520 2
	for (i = 0; i < 16; i++) {
		if ((*pciirq & (1 << i)) == 0)
d532 14
a545 1
	const struct pci_quirkdata *qd;
d548 10
a557 3
	int pin, bus, device, function, maxdevs, nfuncs, irq, link;
	pcireg_t id, bhlcr, intr;
	pcitag_t tag;
d559 6
a564 5
#ifdef PCIBIOSVERBOSE
	printf("--------------------------------------------\n");
	printf("  device vendor product pin PIRQ   IRQ stage\n");
	printf("--------------------------------------------\n");
#endif
d566 8
a573 5
	for (bus = 0; bus <= pcibios_max_bus; bus++) {
		maxdevs = pci_bus_maxdevs(pc, bus);
		for (device = 0; device < maxdevs; device++) {
			tag = pci_make_tag(pc, bus, device, 0);
			id = pci_conf_read(pc, tag, PCI_ID_REG);
d575 14
a588 73
			/* Invalid vendor ID value? */
			if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
				continue;
			/* XXX Not invalid, but we've done this ~forever. */
			if (PCI_VENDOR(id) == 0)
				continue;

			qd = pci_lookup_quirkdata(PCI_VENDOR(id),
			    PCI_PRODUCT(id));

			bhlcr = pci_conf_read(pc, tag, PCI_BHLC_REG);
			if (PCI_HDRTYPE_MULTIFN(bhlcr) ||
			    (qd != NULL &&
			     (qd->quirks & PCI_QUIRK_MULTIFUNCTION) != 0))
				nfuncs = 8;
			else
				nfuncs = 1;

			for (function = 0; function < nfuncs; function++) {
				tag = pci_make_tag(pc, bus, device, function);
				id = pci_conf_read(pc, tag, PCI_ID_REG);
				intr = pci_conf_read(pc, tag,
				    PCI_INTERRUPT_REG);

				/* Invalid vendor ID value? */
				if (PCI_VENDOR(id) == PCI_VENDOR_INVALID)
					continue;
				/*
				 * XXX Not invalid, but we've done this
				 * ~forever.
				 */
				if (PCI_VENDOR(id) == 0)
					continue;

				pin = PCI_INTERRUPT_PIN(intr);
				irq = PCI_INTERRUPT_LINE(intr);

				if (pin == 0) {
					/*
					 * No interrupt used.
					 */
					continue;
				}

				pir = pciintr_pir_lookup(bus, device);
				if (pir == NULL ||
				    (link = pir->linkmap[pin - 1].link) == 0) {
					/*
					 * Interrupt not connected; no
					 * need to change.
					 */
					continue;
				}

				l = pciintr_link_lookup_link(link);
				if (l == NULL) {
					/*
					 * No link map entry?!
					 */
					printf("pciintr_header_fixup: no entry "
					    "for link 0x%02x (%d:%d:%d:%c)\n",
					    link, bus, device, function,
					    '@@' + pin);
					continue;
				}

				/*
				 * IRQs 14 and 15 are reserved for
				 * PCI IDE interrupts; don't muck
				 * with them.
				 */
				if (irq == 14 || irq == 15)
					continue;
d591 10
a600 6
				printf("%03d:%02d:%d 0x%04x 0x%04x  %c   "
				    "0x%02x   %02d  %d\n",
				    bus, device, function,
				    PCI_VENDOR(id), PCI_PRODUCT(id),
				    '@@' + pin, l->clink, l->irq,
				    l->fixup_stage);
d602 9
d612 10
a621 7
				intr &= ~(PCI_INTERRUPT_LINE_MASK <<
				    PCI_INTERRUPT_LINE_SHIFT);
				intr |= (l->irq << PCI_INTERRUPT_LINE_SHIFT);
				pci_conf_write(pc, tag, PCI_INTERRUPT_REG,
				    intr);
			}
		}
d624 11
a634 2
#ifdef PCIBIOSVERBOSE
	printf("--------------------------------------------\n");
d636 1
d638 3
a640 1
	return (0);
d662 2
a663 2
		    (pcibios_pir_header.router_devfunc >> 3) & 0x1f,
		    pcibios_pir_header.router_devfunc & 7);
@


1.3
log
@fix netbsd rcsids up.
also, from the 3rd try make proper openbsd rcsids, rediculous
3 commits just to add proper openbsd rcsids.
i think someone forgot to _look_ at the diffs before commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pci_intr_fixup.c,v 1.2 2000/03/27 08:35:21 brad Exp $	*/
d129 2
@


1.2
log
@add missing OpenBSD RCS IDs
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: pci_intr_fixup.c,v 1.3 1999/12/13 15:42:05 uch Exp $	*/
@


1.1
log
@from netbsd: pci interrupt routing code.
also, change a few pcidevs names to match netbsd (and more descriptive).
tested on a bunch of laptops, helps resolving 'pin X unmapped'
problems for (usually) usb and cardbus cntrollers.
@
text
@d1 1
@

