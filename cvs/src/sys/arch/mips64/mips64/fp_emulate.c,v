head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.4
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.8
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.4
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2017.09.16.05.04.34;	author visa;	state Exp;
branches;
next	1.18;
commitid	KnapMVZmoKLSavXA;

1.18
date	2017.09.02.15.56.29;	author visa;	state Exp;
branches;
next	1.17;
commitid	1y6OLI6UaecTzk2S;

1.17
date	2017.08.30.15.54.33;	author visa;	state Exp;
branches;
next	1.16;
commitid	eFHqDC2bT1TxESep;

1.16
date	2017.08.26.15.21.48;	author visa;	state Exp;
branches;
next	1.15;
commitid	S6Yyp9OyfdlsuUW2;

1.15
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.14;
commitid	CHRb0fCqa8XxUAMH;

1.14
date	2016.03.06.19.42.27;	author mpi;	state Exp;
branches;
next	1.13;
commitid	cyYKarj4qRTft4gD;

1.13
date	2015.09.10.14.37.20;	author miod;	state Exp;
branches;
next	1.12;
commitid	3fjwotWorS49YHw4;

1.12
date	2015.08.27.18.45.09;	author miod;	state Exp;
branches;
next	1.11;
commitid	hEQgCpvbKjJpVBmZ;

1.11
date	2015.05.05.21.24.58;	author jmatthew;	state Exp;
branches;
next	1.10;
commitid	tbvGKAXiowHNNhkW;

1.10
date	2015.01.02.22.38.46;	author sebastia;	state Exp;
branches;
next	1.9;
commitid	2Ybjy1BIuB1bzzpD;

1.9
date	2014.03.29.18.09.30;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2012.10.03.11.18.23;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2012.09.29.19.24.31;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2010.11.24.21.16.28;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.27.20.05.12;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.21.20.29.17;	author miod;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Make sure that `fsr' is always initialized. Non-DEBUG kernels
have not been affected.

From miod@@
@
text
@/*	$OpenBSD: fp_emulate.c,v 1.18 2017/09/02 15:56:29 visa Exp $	*/

/*
 * Copyright (c) 2010 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Floating Point completion/emulation code (MI softfloat code control engine).
 *
 * Supports all MIPS IV COP1 and COP1X floating-point instructions.
 *
 * Floating-point load and store instructions, as well as branch instructions,
 * are only handled if the kernel is compiled with option FPUEMUL.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/signalvar.h>

#include <machine/cpu.h>
#include <mips64/mips_cpu.h>
#include <machine/fpu.h>
#include <machine/frame.h>
#include <machine/ieee.h>
#include <machine/ieeefp.h>
#include <machine/mips_opcode.h>
#include <machine/regnum.h>

#include <lib/libkern/softfloat.h>
#if defined(DEBUG) && defined(DDB)
#include <machine/db_machdep.h>
#endif

int	fpu_emulate(struct proc *, struct trapframe *, uint32_t,
	    union sigval *);
int	fpu_emulate_cop1(struct proc *, struct trapframe *, uint32_t);
int	fpu_emulate_cop1x(struct proc *, struct trapframe *, uint32_t);
uint64_t
	fpu_load(struct proc *, struct trapframe *, uint, uint);
void	fpu_store(struct proc *, struct trapframe *, uint, uint, uint64_t);
#ifdef FPUEMUL
int	nofpu_emulate_cop1(struct proc *, struct trapframe *, uint32_t,
	    union sigval *);
int	nofpu_emulate_cop1x(struct proc *, struct trapframe *, uint32_t,
	    union sigval *);
int	nofpu_emulate_loadstore(struct proc *, struct trapframe *, uint32_t,
	    union sigval *);
int	nofpu_emulate_movci(struct trapframe *, uint32_t);
#endif

typedef	int (fpu_fn3)(struct proc *, struct trapframe *, uint, uint, uint,
	    uint);
typedef	int (fpu_fn4)(struct proc *, struct trapframe *, uint, uint, uint,
	    uint, uint);
fpu_fn3	fpu_abs;
fpu_fn3	fpu_add;
int	fpu_c(struct proc *, struct trapframe *, uint, uint, uint, uint, uint);
fpu_fn3	fpu_ceil_l;
fpu_fn3	fpu_ceil_w;
fpu_fn3	fpu_cvt_d;
fpu_fn3	fpu_cvt_l;
fpu_fn3	fpu_cvt_s;
fpu_fn3	fpu_cvt_w;
fpu_fn3	fpu_div;
fpu_fn3	fpu_floor_l;
fpu_fn3	fpu_floor_w;
int	fpu_int_l(struct proc *, struct trapframe *, uint, uint, uint, uint,
	    uint);
int	fpu_int_w(struct proc *, struct trapframe *, uint, uint, uint, uint,
	    uint);
fpu_fn4	fpu_madd;
fpu_fn4	fpu_msub;
fpu_fn3	fpu_mov;
fpu_fn3	fpu_movcf;
fpu_fn3	fpu_movn;
fpu_fn3	fpu_movz;
fpu_fn3	fpu_mul;
fpu_fn3	fpu_neg;
fpu_fn4	fpu_nmadd;
fpu_fn4	fpu_nmsub;
fpu_fn3	fpu_recip;
fpu_fn3	fpu_round_l;
fpu_fn3	fpu_round_w;
fpu_fn3	fpu_rsqrt;
fpu_fn3	fpu_sqrt;
fpu_fn3	fpu_sub;
fpu_fn3	fpu_trunc_l;
fpu_fn3	fpu_trunc_w;

/*
 * Encoding of operand format within opcodes `fmt' and `fmt3' fields.
 */
#define	FMT_S	0x00
#define	FMT_D	0x01
#define	FMT_W	0x04
#define	FMT_L	0x05

/*
 * Inlines from softfloat-specialize.h which are not made public, needed
 * for fpu_abs.
 */
#define	float32_is_nan(a) \
	(0xff000000 < (a << 1))
#define	float32_is_signaling_nan(a) \
	((((a >> 22) & 0x1ff) == 0x1fe) && (a & 0x003fffff))

/*
 * Precomputed results of intXX_to_floatXX(1)
 */
#define	ONE_F32	(float32)(SNG_EXP_BIAS << SNG_FRACBITS)
#define	ONE_F64	(float64)((uint64_t)DBL_EXP_BIAS << DBL_FRACBITS)

/*
 * Handle a floating-point exception.
 */
void
MipsFPTrap(struct trapframe *tf)
{
	struct cpu_info *ci = curcpu();
	struct proc *p = ci->ci_curproc;
	union sigval sv;
	vaddr_t pc;
	register_t sr;
	uint32_t fsr, excbits;
	uint32_t branch = 0;
	uint32_t insn;
	InstFmt inst;
	int sig = 0;
	int fault_type = SI_NOINFO;
	int update_pcb = 0;
	int emulate = 0;
	int skip_insn = 1;

	KDASSERT(tf == p->p_md.md_regs);

	pc = (vaddr_t)tf->pc;
	if (tf->cause & CR_BR_DELAY)
		pc += 4;

	if (CPU_HAS_FPU(ci)) {
		/*
		 * Enable FPU, and read its status register.
		 */

		sr = getsr();
		setsr(sr | SR_COP_1_BIT);

		__asm__ volatile ("cfc1 %0, $31" : "=r" (fsr));
		__asm__ volatile ("cfc1 %0, $31" : "=r" (fsr));

		/*
		 * If this is not an unimplemented operation, but a genuine
		 * FPU exception, signal the process.
		 */

		if ((fsr & FPCSR_C_E) == 0) {
			sig = SIGFPE;
			goto deliver;
		}
	} else {
#ifdef CPU_OCTEON
		/*
		 * SR_FR_32 is hardwired to zero on Octeon; make sure it is
		 * set in the emulation view of the FPU state.
		 */
		tf->sr |= SR_FR_32;
#endif
		fsr = tf->fsr;
	}

	/*
	 * Get the faulting instruction.  This should not fail, and
	 * if it does, it's probably not your lucky day.
	 */

	if (copyin32((const void *)pc, &insn) != 0) {
		sig = SIGBUS;
		fault_type = BUS_OBJERR;
		sv.sival_ptr = (void *)pc;
		goto deliver;
	}
	inst = *(InstFmt *)&insn;

	if (tf->cause & CR_BR_DELAY) {
		if (copyin32((const void *)tf->pc, &branch) != 0) {
			sig = SIGBUS;
			fault_type = BUS_OBJERR;
			sv.sival_ptr = (void *)tf->pc;
			goto deliver;
		}
	}

	/*
	 * Emulate the instruction.
	 */

#ifdef DEBUG
#ifdef DDB
	printf("%s: unimplemented FPU completion, fsr 0x%08x\n0x%lx: ",
	    p->p_p->ps_comm, fsr, pc);
	dbmd_print_insn(insn, pc, printf);
#else
	printf("%s: unimplemented FPU completion, insn 0x%08x fsr 0x%08x\n",
	    p->p_p->ps_comm, insn, fsr);
#endif
#endif

	switch (inst.FRType.op) {
	default:
		/*
		 * Not a FPU instruction.
		 */
		break;
#ifdef FPUEMUL
	case OP_SPECIAL:
		switch (inst.FRType.func) {
		default:
			/*
			 * Not a FPU instruction.
			 */
			break;
		case OP_MOVCI:
			/*
			 * This instruction should not require emulation,
			 * unless there is no FPU.
			 */
			if (!CPU_HAS_FPU(ci))
				emulate = 1;
			break;
		}
		break;
	case OP_LDC1:
	case OP_LWC1:
	case OP_SDC1:
	case OP_SWC1:
		/*
		 * These instructions should not require emulation,
		 * unless there is no FPU.
		 */
		if (!CPU_HAS_FPU(ci))
			emulate = 1;
		break;
#endif
	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_BC:
			skip_insn = 0;
			/* FALLTHROUGH */
		case OP_MF:
		case OP_DMF:
		case OP_CF:
		case OP_MT:
		case OP_DMT:
		case OP_CT:
			/*
			 * These instructions should not require emulation,
			 * unless there is no FPU.
			 */
			if (!CPU_HAS_FPU(ci))
				emulate = 1;
			break;
		default:
			emulate = 1;
			break;
		}
		break;
	case OP_COP1X:
		switch (inst.FQType.op4) {
		default:
			switch (inst.FRType.func) {
#ifdef FPUEMUL
			case OP_LDXC1:
			case OP_LWXC1:
			case OP_SDXC1:
			case OP_SWXC1:
			case OP_PREFX:
				/*
				 * These instructions should not require
				 * emulation, unless there is no FPU.
				 */
				if (!CPU_HAS_FPU(ci))
					emulate = 1;
				break;
#endif
			default:
				/*
				 * Not a valid instruction.
				 */
				break;
			}
			break;
		case OP_MADD:
		case OP_MSUB:
		case OP_NMADD:
		case OP_NMSUB:
			emulate = 1;
			break;
		}
		break;
	}

	if (emulate) {
		if (CPU_HAS_FPU(ci)) {
			KASSERT(p == ci->ci_fpuproc);
			save_fpu();
		}

		update_pcb = 1;

		sig = fpu_emulate(p, tf, insn, &sv);
		/* reload fsr, possibly modified by softfloat code */
		fsr = tf->fsr;
		if (sig == 0) {
			/* raise SIGFPE if necessary */
			excbits = (fsr & FPCSR_C_MASK) >> FPCSR_C_SHIFT;
			excbits &= (fsr & FPCSR_E_MASK) >> FPCSR_E_SHIFT;
			if (excbits != 0)
				sig = SIGFPE;
		}
	} else {
		sig = SIGILL;
		fault_type = ILL_ILLOPC;
	}

deliver:
	switch (sig) {
	case SIGFPE:
		excbits = (fsr & FPCSR_C_MASK) >> FPCSR_C_SHIFT;
		excbits &= (fsr & FPCSR_E_MASK) >> FPCSR_E_SHIFT;
		if (excbits & FP_X_INV)
			fault_type = FPE_FLTINV;
		else if (excbits & FP_X_DZ)
			fault_type = FPE_INTDIV;
		else if (excbits & FP_X_OFL)
			fault_type = FPE_FLTUND;
		else if (excbits & FP_X_UFL)
			fault_type = FPE_FLTOVF;
		else /* if (excbits & FP_X_IMP) */
			fault_type = FPE_FLTRES;

		break;
#ifdef FPUEMUL
	case SIGBUS:
		if (fault_type == SI_NOINFO)
			fault_type = BUS_ADRALN;
		break;
	case SIGSEGV:
		if (fault_type == SI_NOINFO)
			fault_type = SEGV_MAPERR;
		break;
#endif
	}

	/*
	 * Skip the instruction, unless we are delivering SIGILL.
	 */
	if (CPU_HAS_FPU(ci) || skip_insn) {
		if (sig != SIGILL) {
			if (tf->cause & CR_BR_DELAY) {
				/*
				 * Note that it doesn't matter, at this point,
				 * that we pass the updated FSR value, as it is
				 * only used to decide whether to branch or not
				 * if the faulting instruction was BC1[FT].
				 */
				tf->pc = MipsEmulateBranch(tf, tf->pc, fsr,
				    branch);
			} else
				tf->pc += 4;
		}
	}

	/*
	 * Update the FPU status register.
	 * We need to make sure that this will not cause an exception
	 * in kernel mode.
	 */

	/* propagate raised exceptions to the sticky bits */
	fsr &= ~FPCSR_C_E;
	excbits = (fsr & FPCSR_C_MASK) >> FPCSR_C_SHIFT;
	fsr |= excbits << FPCSR_F_SHIFT;
	/* clear all exception sources */
	fsr &= ~FPCSR_C_MASK;
	if (update_pcb)
		tf->fsr = fsr;

	if (CPU_HAS_FPU(ci)) {
		__asm__ volatile ("ctc1 %0, $31" :: "r" (fsr));
		/* disable fpu before returning to trap() */
		setsr(sr);
	}

	if (sig != 0) {
		if (sig != SIGBUS && sig != SIGSEGV)
			sv.sival_ptr = (void *)pc;
		KERNEL_LOCK();
		trapsignal(p, sig, 0, fault_type, sv);
		KERNEL_UNLOCK();
	}
}

/*
 * Emulate an FPU instruction.  The FPU register set has been saved in the
 * current PCB, and is pointed to by the trap frame.
 */
int
fpu_emulate(struct proc *p, struct trapframe *tf, uint32_t insn,
    union sigval *sv)
{
	InstFmt inst;

	tf->zero = 0;	/* not written by trap code */

	inst = *(InstFmt *)&insn;

	if (CPU_HAS_FPU(p->p_cpu)) {
		switch (inst.FRType.op) {
		default:
			break;
		case OP_COP1:
			return fpu_emulate_cop1(p, tf, insn);
		case OP_COP1X:
			return fpu_emulate_cop1x(p, tf, insn);
		}

		return SIGILL;
	}

#ifdef FPUEMUL
	switch (inst.FRType.op) {
	default:
		break;
	case OP_SPECIAL:
		return nofpu_emulate_movci(tf, insn);
	case OP_LDC1:
	case OP_LWC1:
	case OP_SDC1:
	case OP_SWC1:
		return nofpu_emulate_loadstore(p, tf, insn, sv);
	case OP_COP1:
		switch (inst.RType.rs) {
		case OP_MF:
		case OP_DMF:
		case OP_CF:
		case OP_MT:
		case OP_DMT:
		case OP_CT:
		case OP_BC:
			return nofpu_emulate_cop1(p, tf, insn, sv);
		default:
			return fpu_emulate_cop1(p, tf, insn);
		}
		break;
	case OP_COP1X:
		switch (inst.FQType.op4) {
		default:
			switch (inst.FRType.func) {
			case OP_LDXC1:
			case OP_LWXC1:
			case OP_SDXC1:
			case OP_SWXC1:
			case OP_PREFX:
				return nofpu_emulate_cop1x(p, tf, insn, sv);
			default:
				break;
			}
			break;
		case OP_MADD:
		case OP_MSUB:
		case OP_NMADD:
		case OP_NMSUB:
			return fpu_emulate_cop1x(p, tf, insn);
		}
	}
#endif

	return SIGILL;
}

/*
 * Emulate a COP1 FPU instruction.
 */
int
fpu_emulate_cop1(struct proc *p, struct trapframe *tf, uint32_t insn)
{
	InstFmt inst;
	uint ft, fs, fd;
	fpu_fn3 *fpu_op;
	static fpu_fn3 *const fpu_ops1[1 << 6] = {
		fpu_add,		/* 0x00 */
		fpu_sub,
		fpu_mul,
		fpu_div,
		fpu_sqrt,
		fpu_abs,
		fpu_mov,
		fpu_neg,
		fpu_round_l,		/* 0x08 */
		fpu_trunc_l,
		fpu_ceil_l,
		fpu_floor_l,
		fpu_round_w,
		fpu_trunc_w,
		fpu_ceil_w,
		fpu_floor_w,
		NULL,			/* 0x10 */
		fpu_movcf,
		fpu_movz,
		fpu_movn,
		NULL,
		fpu_recip,
		fpu_rsqrt,
		NULL,
		NULL,			/* 0x18 */
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		fpu_cvt_s,		/* 0x20 */
		fpu_cvt_d,
		NULL,
		NULL,
		fpu_cvt_w,
		fpu_cvt_l,
		NULL,
		NULL,
		NULL,			/* 0x28 */
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL,
		(fpu_fn3 *)fpu_c,	/* 0x30 */
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,	/* 0x38 */
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c,
		(fpu_fn3 *)fpu_c
	};

	inst = *(InstFmt *)&insn;

	/* 
	 * Check for valid function code.
	 */

	fpu_op = fpu_ops1[inst.FRType.func];
	if (fpu_op == NULL)
		return SIGILL;

	/*
	 * Check for valid format.  FRType assumes bit 25 is always set,
	 * so we need to check for it explicitely.
	 */

	if ((insn & (1 << 25)) == 0)
		return SIGILL;
	switch (inst.FRType.fmt) {
	default:
		return SIGILL;
	case FMT_S:
	case FMT_D:
	case FMT_W:
	case FMT_L:
		break;
	}

	/*
	 * Check for valid register values. Only even-numbered registers
	 * can be used if the FR bit is clear in coprocessor 0 status
	 * register.
	 *
	 * Note that c.cond does not specify a register number in the fd
	 * field, but the fd field must have zero in its low two bits, so
	 * the test will not reject valid c.cond instructions.
	 */

	ft = inst.FRType.ft;
	fs = inst.FRType.fs;
	fd = inst.FRType.fd;
	if ((tf->sr & SR_FR_32) == 0) {
		if ((ft | fs | fd) & 1)
			return SIGILL;
	}

	/*
	 * Finally dispatch to the proper routine.
	 */

	if (fpu_op == (fpu_fn3 *)&fpu_c)
		return
		    fpu_c(p, tf, inst.FRType.fmt, ft, fs, fd, inst.FRType.func);
	else
		return (*fpu_op)(p, tf, inst.FRType.fmt, ft, fs, fd);
}

/*
 * Emulate a COP1X FPU instruction.
 */
int
fpu_emulate_cop1x(struct proc *p, struct trapframe *tf, uint32_t insn)
{
	InstFmt inst;
	uint fr, ft, fs, fd;
	fpu_fn4 *fpu_op;
	static fpu_fn4 *const fpu_ops1x[1 << 3] = {
		NULL,
		NULL,
		NULL,
		NULL,
		fpu_madd,
		fpu_msub,
		fpu_nmadd,
		fpu_nmsub
	};

	inst = *(InstFmt *)&insn;

	/* 
	 * Check for valid function code.
	 */

	fpu_op = fpu_ops1x[inst.FQType.op4];
	if (fpu_op == NULL)
		return SIGILL;

	/*
	 * Check for valid format.
	 */

	switch (inst.FQType.fmt3) {
	default:
		return SIGILL;
	case FMT_S:
	case FMT_D:
	case FMT_W:
	case FMT_L:
		break;
	}

	/*
	 * Check for valid register values. Only even-numbered registers
	 * can be used if the FR bit is clear in coprocessor 0 status
	 * register.
	 */

	fr = inst.FQType.fr;
	ft = inst.FQType.ft;
	fs = inst.FQType.fs;
	fd = inst.FQType.fd;
	if ((tf->sr & SR_FR_32) == 0) {
		if ((fr | ft | fs | fd) & 1)
			return SIGILL;
	}

	/*
	 * Finally dispatch to the proper routine.
	 */

	return (*fpu_op)(p, tf, inst.FRType.fmt, fr, ft, fs, fd);
}

/*
 * Load a floating-point argument according to the specified format.
 */
uint64_t
fpu_load(struct proc *p, struct trapframe *tf, uint fmt, uint regno)
{
	uint64_t tmp, tmp2;

	tmp = ((uint64_t *)p->p_md.md_regs)[FPBASE + regno];
	if (tf->sr & SR_FR_32) {
		switch (fmt) {
		case FMT_D:
		case FMT_L:
			break;
		case FMT_S:
		case FMT_W:
			tmp &= 0xffffffff;
			break;
		}
	} else {
		tmp &= 0xffffffff;
		switch (fmt) {
		case FMT_D:
		case FMT_L:
			/* caller has enforced regno is even */
			tmp2 =
			    ((uint64_t *)p->p_md.md_regs)[FPBASE + regno + 1];
			tmp |= tmp2 << 32;
			break;
		case FMT_S:
		case FMT_W:
			break;
		}
	}

	return tmp;
}

/*
 * Store a floating-point result according to the specified format.
 */
void
fpu_store(struct proc *p, struct trapframe *tf, uint fmt, uint regno,
    uint64_t rslt)
{
	if (tf->sr & SR_FR_32) {
		((uint64_t *)p->p_md.md_regs)[FPBASE + regno] = rslt;
	} else {
		/* caller has enforced regno is even */
		((uint64_t *)p->p_md.md_regs)[FPBASE + regno] =
		    rslt & 0xffffffff;
		((uint64_t *)p->p_md.md_regs)[FPBASE + regno + 1] =
		    (rslt >> 32) & 0xffffffff;
	}
}

/*
 * Integer conversion
 */

int
fpu_int_l(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd, uint rm)
{
	uint64_t raw;
	uint32_t oldrm;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);

	/* round towards required mode */
	oldrm = tf->fsr & FPCSR_RM_MASK;
	tf->fsr = (tf->fsr & ~FPCSR_RM_MASK) | rm;
	if (fmt == FMT_S)
		raw = float32_to_int64((float32)raw);
	else
		raw = float64_to_int64((float64)raw);
	/* restore rounding mode */
	tf->fsr = (tf->fsr & ~FPCSR_RM_MASK) | oldrm;

	if ((tf->fsr & (FPCSR_C_V | FPCSR_E_V)) != (FPCSR_C_V | FPCSR_E_V))
		fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_int_w(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd, uint rm)
{
	uint64_t raw;
	uint32_t oldrm;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);

	/* round towards required mode */
	oldrm = tf->fsr & FPCSR_RM_MASK;
	tf->fsr = (tf->fsr & ~FPCSR_RM_MASK) | rm;
	if (fmt == FMT_S)
		raw = float32_to_int32((float32)raw);
	else
		raw = float64_to_int32((float64)raw);
	/* restore rounding mode */
	tf->fsr = (tf->fsr & ~FPCSR_RM_MASK) | oldrm;

	if ((tf->fsr & (FPCSR_C_V | FPCSR_E_V)) != (FPCSR_C_V | FPCSR_E_V))
		fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

/*
 * FPU Instruction emulation
 */

int
fpu_abs(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	/* clear sign bit unless NaN */
	if (fmt == FMT_S) {
		float32 f32 = (float32)raw;
		if (float32_is_nan(f32)) {
			float_set_invalid();
		} else {
			f32 &= ~(1L << 31);
			raw = (uint64_t)f32;
		}
	} else {
		float64 f64 = (float64)raw;
		if (float64_is_nan(f64)) {
			float_set_invalid();
		} else {
			f64 &= ~(1L << 63);
			raw = (uint64_t)f64;
		}
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_add(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw1, raw2, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	if (fmt == FMT_S) {
		float32 f32 = float32_add((float32)raw1, (float32)raw2);
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_add((float64)raw1, (float64)raw2);
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_c(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd, uint op)
{
	uint64_t raw1, raw2;
	uint cc, lt, eq, uo;

	if ((fd & 0x03) != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	lt = eq = uo = 0;
	cc = fd >> 2;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);

	if (fmt == FMT_S) {
		float32 f32a = (float32)raw1;
		float32 f32b = (float32)raw2;
		if (float32_is_nan(f32a)) {
			uo = 1 << 0;
			if (float32_is_signaling_nan(f32a))
				op |= 0x08;	/* force invalid exception */
		}
		if (float32_is_nan(f32b)) {
			uo = 1 << 0;
			if (float32_is_signaling_nan(f32b))
				op |= 0x08;	/* force invalid exception */
		}
		if (uo == 0) {
			if (float32_eq(f32a, f32b))
				eq = 1 << 1;
			else if (float32_lt(f32a, f32b))
				lt = 1 << 2;
		}
	} else {
		float64 f64a = (float64)raw1;
		float64 f64b = (float64)raw2;
		if (float64_is_nan(f64a)) {
			uo = 1 << 0;
			if (float64_is_signaling_nan(f64a))
				op |= 0x08;	/* force invalid exception */
		}
		if (float64_is_nan(f64b)) {
			uo = 1 << 0;
			if (float64_is_signaling_nan(f64b))
				op |= 0x08;	/* force invalid exception */
		}
		if (uo == 0) {
			if (float64_eq(f64a, f64b))
				eq = 1 << 1;
			else if (float64_lt(f64a, f64b))
				lt = 1 << 2;
		}
	}

	if (uo && (op & 0x08)) {
		float_set_invalid();
		if (tf->fsr & FPCSR_E_V) {
			/* comparison result intentionaly not written */
			goto skip;
		}
	} else {
		if ((uo | eq | lt) & op)
			tf->fsr |= FPCSR_CONDVAL(cc);
		else
			tf->fsr &= ~FPCSR_CONDVAL(cc);
	}
skip:

	return 0;
}

int
fpu_ceil_l(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards positive infinity */
	return fpu_int_l(p, tf, fmt, ft, fs, fd, FP_RP);
}

int
fpu_ceil_w(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards positive infinity */
	return fpu_int_w(p, tf, fmt, ft, fs, fd, FP_RP);
}

int
fpu_cvt_d(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt == FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	switch (fmt) {
	case FMT_L:
		raw = int64_to_float64((int64_t)raw);
		break;
	case FMT_S:
		raw = float32_to_float64((float32)raw);
		break;
	case FMT_W:
		raw = int32_to_float64((int32_t)raw);
		break;
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_cvt_l(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;
	uint32_t rm;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	rm = tf->fsr & FPCSR_RM_MASK;
	raw = fpu_load(p, tf, fmt, fs);
	if (fmt == FMT_D) {
		if (rm == FP_RZ)
			raw = float64_to_int64_round_to_zero((float64)raw);
		else
			raw = float64_to_int64((float64)raw);
	} else {
		if (rm == FP_RZ)
			raw = float32_to_int64_round_to_zero((float32)raw);
		else
			raw = float32_to_int64((float32)raw);
	}
	if ((tf->fsr & (FPCSR_C_V | FPCSR_E_V)) != (FPCSR_C_V | FPCSR_E_V))
		fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_cvt_s(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt == FMT_S)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	switch (fmt) {
	case FMT_D:
		raw = float64_to_float32((float64)raw);
		break;
	case FMT_L:
		raw = int64_to_float32((int64_t)raw);
		break;
	case FMT_W:
		raw = int32_to_float32((int32_t)raw);
		break;
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_cvt_w(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;
	uint32_t rm;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	rm = tf->fsr & FPCSR_RM_MASK;
	raw = fpu_load(p, tf, fmt, fs);
	if (fmt == FMT_D) {
		if (rm == FP_RZ)
			raw = float64_to_int32_round_to_zero((float64)raw);
		else
			raw = float64_to_int32((float64)raw);
	} else {
		if (rm == FP_RZ)
			raw = float32_to_int32_round_to_zero((float32)raw);
		else
			raw = float32_to_int32((float32)raw);
	}
	if ((tf->fsr & (FPCSR_C_V | FPCSR_E_V)) != (FPCSR_C_V | FPCSR_E_V))
		fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_div(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw1, raw2, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	if (fmt == FMT_S) {
		float32 f32 = float32_div((float32)raw1, (float32)raw2);
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_div((float64)raw1, (float64)raw2);
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_floor_l(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards negative infinity */
	return fpu_int_l(p, tf, fmt, ft, fs, fd, FP_RM);
}

int
fpu_floor_w(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards negative infinity */
	return fpu_int_w(p, tf, fmt, ft, fs, fd, FP_RM);
}

int
fpu_madd(struct proc *p, struct trapframe *tf, uint fmt, uint fr, uint ft,
    uint fs, uint fd)
{
	uint64_t raw1, raw2, raw3, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	raw3 = fpu_load(p, tf, fmt, fr);
	if (fmt == FMT_S) {
		float32 f32 = float32_add(
		    float32_mul((float32)raw1, (float32)raw2),
		    (float32)raw3);
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_add(
		    float64_mul((float64)raw1, (float64)raw2),
		    (float64)raw3);
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_mov(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_movcf(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;
	uint cc, istf;
	int condition;

	if ((ft & 0x02) != 0)
		return SIGILL;
	cc = ft >> 2;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	condition = tf->fsr & FPCSR_CONDVAL(cc);
	istf = ft & COPz_BC_TF_MASK;
	if ((!condition && !istf) /*movf*/ || (condition && istf) /*movt*/) {
		raw = fpu_load(p, tf, fmt, fs);
		fpu_store(p, tf, fmt, fd, raw);
	}

	return 0;
}

int
fpu_movn(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	register_t *regs = (register_t *)tf;
	uint64_t raw;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	if (ft != ZERO && regs[ft] != 0) {
		raw = fpu_load(p, tf, fmt, fs);
		fpu_store(p, tf, fmt, fd, raw);
	}

	return 0;
}

int
fpu_movz(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	register_t *regs = (register_t *)tf;
	uint64_t raw;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	if (ft == ZERO || regs[ft] == 0) {
		raw = fpu_load(p, tf, fmt, fs);
		fpu_store(p, tf, fmt, fd, raw);
	}

	return 0;
}

int
fpu_msub(struct proc *p, struct trapframe *tf, uint fmt, uint fr, uint ft,
    uint fs, uint fd)
{
	uint64_t raw1, raw2, raw3, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	raw3 = fpu_load(p, tf, fmt, fr);
	if (fmt == FMT_S) {
		float32 f32 = float32_sub(
		    float32_mul((float32)raw1, (float32)raw2),
		    (float32)raw3);
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_sub(
		    float64_mul((float64)raw1, (float64)raw2),
		    (float64)raw3);
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_mul(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw1, raw2, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	if (fmt == FMT_S) {
		float32 f32 = float32_mul((float32)raw1, (float32)raw2);
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_mul((float64)raw1, (float64)raw2);
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_neg(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	/* flip sign bit unless NaN */
	if (fmt == FMT_S) {
		float32 f32 = (float32)raw;
		if (float32_is_nan(f32)) {
			float_set_invalid();
		} else {
			f32 ^= 1L << 31;
			raw = (uint64_t)f32;
		}
	} else {
		float64 f64 = (float64)raw;
		if (float64_is_nan(f64)) {
			float_set_invalid();
		} else {
			f64 ^= 1L << 63;
			raw = (uint64_t)f64;
		}
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_nmadd(struct proc *p, struct trapframe *tf, uint fmt, uint fr, uint ft,
    uint fs, uint fd)
{
	uint64_t raw1, raw2, raw3, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	raw3 = fpu_load(p, tf, fmt, fr);
	if (fmt == FMT_S) {
		float32 f32 = float32_add(
		    float32_mul((float32)raw1, (float32)raw2),
		    (float32)raw3);
		if (float32_is_nan(f32))
			float_set_invalid();
		else
			f32 ^= 1L << 31;
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_add(
		    float64_mul((float64)raw1, (float64)raw2),
		    (float64)raw3);
		if (float64_is_nan(f64))
			float_set_invalid();
		else
			f64 ^= 1L << 63;
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_nmsub(struct proc *p, struct trapframe *tf, uint fmt, uint fr, uint ft,
    uint fs, uint fd)
{
	uint64_t raw1, raw2, raw3, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	raw3 = fpu_load(p, tf, fmt, fr);
	if (fmt == FMT_S) {
		float32 f32 = float32_sub(
		    float32_mul((float32)raw1, (float32)raw2),
		    (float32)raw3);
		if (float32_is_nan(f32))
			float_set_invalid();
		else
			f32 ^= 1L << 31;
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_sub(
		    float64_mul((float64)raw1, (float64)raw2),
		    (float64)raw3);
		if (float64_is_nan(f64))
			float_set_invalid();
		else
			f64 ^= 1L << 63;
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_recip(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	if (fmt == FMT_S) {
		float32 f32 = float32_div(ONE_F32, (float32)raw);
		raw = (uint64_t)f32;
	} else {
		float64 f64 = float64_div(ONE_F64, (float64)raw);
		raw = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_round_l(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards nearest */
	return fpu_int_l(p, tf, fmt, ft, fs, fd, FP_RN);
}

int
fpu_round_w(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards nearest */
	return fpu_int_w(p, tf, fmt, ft, fs, fd, FP_RN);
}

int
fpu_rsqrt(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	if (fmt == FMT_S) {
		float32 f32 = float32_sqrt((float32)raw);
		if ((tf->fsr & (FPCSR_C_V | FPCSR_E_V)) !=
		    (FPCSR_C_V | FPCSR_E_V))
			f32 = float32_div(ONE_F32, f32);
		raw = (uint64_t)f32;
	} else {
		float64 f64 = float64_sqrt((float64)raw);
		if ((tf->fsr & (FPCSR_C_V | FPCSR_E_V)) !=
		    (FPCSR_C_V | FPCSR_E_V))
			f64 = float64_div(ONE_F64, f64);
		raw = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_sqrt(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw;

	if (ft != 0)
		return SIGILL;
	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw = fpu_load(p, tf, fmt, fs);
	if (fmt == FMT_S) {
		float32 f32 = float32_sqrt((float32)raw);
		raw = (uint64_t)f32;
	} else {
		float64 f64 = float64_sqrt((float64)raw);
		raw = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, raw);

	return 0;
}

int
fpu_sub(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	uint64_t raw1, raw2, rslt;

	if (fmt != FMT_S && fmt != FMT_D)
		return SIGILL;

	raw1 = fpu_load(p, tf, fmt, fs);
	raw2 = fpu_load(p, tf, fmt, ft);
	if (fmt == FMT_S) {
		float32 f32 = float32_sub((float32)raw1, (float32)raw2);
		rslt = (uint64_t)f32;
	} else {
		float64 f64 = float64_sub((float64)raw1, (float64)raw2);
		rslt = (uint64_t)f64;
	}
	fpu_store(p, tf, fmt, fd, rslt);

	return 0;
}

int
fpu_trunc_l(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards zero */
	return fpu_int_l(p, tf, fmt, ft, fs, fd, FP_RZ);
}

int
fpu_trunc_w(struct proc *p, struct trapframe *tf, uint fmt, uint ft, uint fs,
    uint fd)
{
	/* round towards zero */
	return fpu_int_w(p, tf, fmt, ft, fs, fd, FP_RZ);
}

#ifdef FPUEMUL

/*
 * Emulate a COP1 non-FPU instruction.
 */
int
nofpu_emulate_cop1(struct proc *p, struct trapframe *tf, uint32_t insn,
    union sigval *sv)
{
	register_t *regs = (register_t *)tf;
	InstFmt inst;
	int32_t cval;

	inst = *(InstFmt *)&insn;

	switch (inst.RType.rs) {
	case OP_MF:
		if (inst.FRType.fd != 0 || inst.FRType.func != 0)
			return SIGILL;
		if (inst.FRType.ft != ZERO)
			regs[inst.FRType.ft] = (int32_t)
			    ((uint64_t *)p->p_md.md_regs)
			      [FPBASE + inst.FRType.fs];
		break;
	case OP_DMF:
		if (inst.FRType.fd != 0 || inst.FRType.func != 0)
			return SIGILL;
		if ((tf->sr & SR_FR_32) != 0 || (inst.FRType.fs & 1) == 0) {
			if (inst.FRType.ft != ZERO)
				regs[inst.FRType.ft] =
				    fpu_load(p, tf, FMT_L, inst.FRType.fs);
		}
		break;
	case OP_CF:
		if (inst.FRType.fd != 0 || inst.FRType.func != 0)
			return SIGILL;
		if (inst.FRType.ft != ZERO) {
			switch (inst.FRType.fs) {
			case 0:	/* FPC_ID */
				cval = MIPS_SOFT << 8;
				break;
			case 31: /* FPC_CSR */
				cval = (int32_t)tf->fsr;
				break;
			default:
				cval = 0;
				break;
			}
			regs[inst.FRType.ft] = (int64_t)cval;
		}
		break;
	case OP_MT:
		if (inst.FRType.fd != 0 || inst.FRType.func != 0)
			return SIGILL;
		((uint64_t *)p->p_md.md_regs)[FPBASE + inst.FRType.fs] =
		    (int32_t)regs[inst.FRType.ft];
		break;
	case OP_DMT:
		if (inst.FRType.fd != 0 || inst.FRType.func != 0)
			return SIGILL;
		if ((tf->sr & SR_FR_32) != 0 || (inst.FRType.fs & 1) == 0) {
			fpu_store(p, tf, FMT_L, inst.FRType.fs,
			    regs[inst.FRType.ft]);
		}
		break;
	case OP_CT:
		if (inst.FRType.fd != 0 || inst.FRType.func != 0)
			return SIGILL;
		cval = (int32_t)regs[inst.FRType.ft];
		switch (inst.FRType.fs) {
		case 31: /* FPC_CSR */
			cval &= ~FPCSR_C_E;
			tf->fsr = cval;
			break;
		case 0:	/* FPC_ID */
		default:
			break;
		}
		break;
	case OP_BC:
	   {
		uint cc, nd, istf;
		int condition;
		vaddr_t dest;
		uint32_t dinsn;

		cc = (inst.RType.rt & COPz_BC_CC_MASK) >> COPz_BC_CC_SHIFT;
		nd = inst.RType.rt & COPz_BCL_TF_MASK;
		istf = inst.RType.rt & COPz_BC_TF_MASK;
		condition = tf->fsr & FPCSR_CONDVAL(cc);
		if ((!condition && !istf) /*bc1f*/ ||
		    (condition && istf) /*bc1t*/) {
			/*
			 * Branch taken: if the delay slot is not a nop,
			 * copy the delay slot instruction to the dedicated
			 * relocation page, in order to be able to have the
			 * cpu process it and give control back to the
			 * kernel, for us to redirect to the branch
			 * destination.
			 */
			/* inline MipsEmulateBranch(tf, tf->pc, tf->fsr, insn)*/
			dest = tf->pc + 4 + ((short)inst.IType.imm << 2);
			if (copyin32((const void *)(tf->pc + 4), &dinsn) != 0) {
				sv->sival_ptr = (void *)(tf->pc + 4);
				return SIGSEGV;
			}
			if (dinsn == 0x00000000 /* nop */ ||
			    dinsn == 0x00000040 /* ssnop */) {
				tf->pc = dest;
			} else {
				if (fpe_branch_emulate(curproc, tf, dinsn,
				    dest) != 0)
					return SIGILL;
			}
		} else {
			/*
			 * Branch not taken: skip the instruction, and
			 * skip the delay slot if it was a `branch likely'
			 * instruction.
			 */
			tf->pc += 4;
			if (nd)
				tf->pc += 4;
		}
	    }
		break;
	}

	return 0;
}

/*
 * Emulate a COP1X non-FPU instruction.
 */
int
nofpu_emulate_cop1x(struct proc *p, struct trapframe *tf, uint32_t insn,
    union sigval *sv)
{
	register_t *regs = (register_t *)tf;
	InstFmt inst;
	vaddr_t va;
	uint64_t ddata;
	uint32_t wdata;

	inst = *(InstFmt *)&insn;
	switch (inst.FRType.func) {
	case OP_LDXC1:
		if (inst.FQType.fs != 0)
			return SIGILL;
		va = (vaddr_t)regs[inst.FQType.fr] +
		    (vaddr_t)regs[inst.FQType.ft];
		if ((va & 0x07) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		if (copyin((const void *)va, &ddata, sizeof ddata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		if ((tf->sr & SR_FR_32) != 0 || (inst.FQType.fd & 1) == 0)
			fpu_store(p, tf, FMT_L, inst.FQType.fd, ddata);
		break;
	case OP_LWXC1:
		if (inst.FQType.fs != 0)
			return SIGILL;
		va = (vaddr_t)regs[inst.FQType.fr] +
		    (vaddr_t)regs[inst.FQType.ft];
		if ((va & 0x03) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		if (copyin((const void *)va, &wdata, sizeof wdata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		((uint64_t *)p->p_md.md_regs)[FPBASE + inst.FQType.fd] = wdata;
		break;
	case OP_SDXC1:
		if (inst.FQType.fd != 0)
			return SIGILL;
		va = (vaddr_t)regs[inst.FQType.fr] +
		    (vaddr_t)regs[inst.FQType.ft];
		if ((va & 0x07) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		if ((tf->sr & SR_FR_32) != 0 || (inst.FQType.fs & 1) == 0)
			ddata = fpu_load(p, tf, FMT_L, inst.FQType.fs);
		else {
			/* undefined behaviour, don't expose stack content */
			ddata = 0;
		}
		if (copyout(&ddata, (void *)va, sizeof ddata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		break;
	case OP_SWXC1:
		if (inst.FQType.fd != 0)
			return SIGILL;
		va = (vaddr_t)regs[inst.FQType.fr] +
		    (vaddr_t)regs[inst.FQType.ft];
		if ((va & 0x03) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		wdata = ((uint64_t *)p->p_md.md_regs)[FPBASE + inst.FQType.fs];
		if (copyout(&wdata, (void *)va, sizeof wdata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		break;
	case OP_PREFX:
		/* nothing to do */
		break;
	}

	return 0;
}

/*
 * Emulate a load/store instruction on FPU registers.
 */
int
nofpu_emulate_loadstore(struct proc *p, struct trapframe *tf, uint32_t insn,
    union sigval *sv)
{
	register_t *regs = (register_t *)tf;
	InstFmt inst;
	vaddr_t va;
	uint64_t ddata;
	uint32_t wdata;

	inst = *(InstFmt *)&insn;
	switch (inst.IType.op) {
	case OP_LDC1:
		va = (vaddr_t)regs[inst.IType.rs] + (int16_t)inst.IType.imm;
		if ((va & 0x07) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		if (copyin((const void *)va, &ddata, sizeof ddata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		if ((tf->sr & SR_FR_32) != 0 || (inst.IType.rt & 1) == 0)
			fpu_store(p, tf, FMT_L, inst.IType.rt, ddata);
		break;
	case OP_LWC1:
		va = (vaddr_t)regs[inst.IType.rs] + (int16_t)inst.IType.imm;
		if ((va & 0x03) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		if (copyin((const void *)va, &wdata, sizeof wdata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		((uint64_t *)p->p_md.md_regs)[FPBASE + inst.IType.rt] = wdata;
		break;
	case OP_SDC1:
		va = (vaddr_t)regs[inst.IType.rs] + (int16_t)inst.IType.imm;
		if ((va & 0x07) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		if ((tf->sr & SR_FR_32) != 0 || (inst.IType.rt & 1) == 0)
			ddata = fpu_load(p, tf, FMT_L, inst.IType.rt);
		else {
			/* undefined behaviour, don't expose stack content */
			ddata = 0;
		}
		if (copyout(&ddata, (void *)va, sizeof ddata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		break;
	case OP_SWC1:
		va = (vaddr_t)regs[inst.IType.rs] + (int16_t)inst.IType.imm;
		if ((va & 0x03) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGBUS;
		}
		wdata = ((uint64_t *)p->p_md.md_regs)[FPBASE + inst.IType.rt];
		if (copyout(&wdata, (void *)va, sizeof wdata) != 0) {
			sv->sival_ptr = (void *)va;
			return SIGSEGV;
		}
		break;
	}

	return 0;
}

/*
 * Emulate MOVF and MOVT.
 */
int
nofpu_emulate_movci(struct trapframe *tf, uint32_t insn)
{
	register_t *regs = (register_t *)tf;
	InstFmt inst;
	uint cc, istf;
	int condition;

	inst = *(InstFmt *)&insn;
	if ((inst.RType.rt & 0x02) != 0 || inst.RType.shamt != 0)
		return SIGILL;

	cc = inst.RType.rt >> 2;
	istf = inst.RType.rt & COPz_BC_TF_MASK;
	condition = tf->fsr & FPCSR_CONDVAL(cc);
	if ((!condition && !istf) /*movf*/ || (condition && istf) /*movt*/) {
		if (inst.RType.rd != ZERO)
			regs[inst.RType.rd] = regs[inst.RType.rs];
	}

	return 0;
}

#endif	/* FPUEMUL */
@


1.18
log
@Let the kernel utilize the FPU if one is available, even when the
FPUEMUL option is enabled. This benefits OCTEON III systems which can
run floating-point operations natively.

Feedback from and OK miod@@; he also helped with testing.

Tested on octeon without FPU (CN5020, CN6120) and with FPU (CN7130),
as well as on sgi/IP27 (MP R16000), sgi/IP32 (R5000), and
loongson (3A1000).
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.17 2017/08/30 15:54:33 visa Exp $	*/
d181 1
@


1.17
log
@Prefer copyin32() to copyin() when fetching instructions
from user space. This improves performance slightly.

Discussed with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.16 2017/08/26 15:21:48 visa Exp $	*/
d136 1
a144 1
#ifdef FPUEMUL
a145 3
#else
	register_t sr;
#endif
d153 4
a156 4
#ifndef FPUEMUL
	/*
	 * Enable FPU, and read its status register.
	 */
d158 2
a159 2
	sr = getsr();
	setsr(sr | SR_COP_1_BIT);
d161 2
a162 2
	__asm__ volatile ("cfc1 %0, $31" : "=r" (fsr));
	__asm__ volatile ("cfc1 %0, $31" : "=r" (fsr));
d164 4
a167 4
	/*
	 * If this is not an unimplemented operation, but a genuine
	 * FPU exception, signal the process.
	 */
d169 5
a173 5
	if ((fsr & FPCSR_C_E) == 0) {
		sig = SIGFPE;
		goto deliver;
	}
#else
d175 5
a179 5
	/*
	 * SR_FR_32 is hardwired to zero on Octeon; make sure it is
	 * set in the emulation view of the FPU state.
	 */
	tf->sr |= SR_FR_32;
d181 1
a181 1
#endif	/* FPUEMUL */
d191 1
d239 2
a240 1
			emulate = 1;
d252 2
a253 1
		emulate = 1;
a258 1
#ifdef FPUEMUL
a259 1
#endif
d271 2
a272 3
#ifdef FPUEMUL
			emulate = 1;
#endif
d293 2
a294 1
				emulate = 1;
d315 5
a319 4
#ifndef FPUEMUL
		KASSERT(p == ci->ci_fpuproc);
		save_fpu();
#endif
d356 2
a357 1
		fault_type = BUS_ADRALN;
d360 2
a361 1
		fault_type = SEGV_MAPERR;
d369 1
a369 3
#ifdef FPUEMUL
	if (skip_insn) {
#endif
a382 1
#ifdef FPUEMUL
a383 1
#endif
d399 6
a404 5
#ifndef FPUEMUL
	__asm__ volatile ("ctc1 %0, $31" :: "r" (fsr));
	/* disable fpu before returning to trap() */
	setsr(sr);
#endif
a406 1
#ifdef FPUEMUL
a407 1
#endif
d428 15
a445 1
#ifdef FPUEMUL
a452 1
#endif
a454 1
#ifdef FPUEMUL
a462 1
#endif
a468 1
#ifdef FPUEMUL
a485 4
#else
		default:
			return fpu_emulate_cop1x(p, tf, insn);
#endif
d488 1
@


1.16
log
@Use copyin32() instead of a direct memory load when fetching a branch
instruction for branch emulation. This ensures the userspace memory
access is properly guarded and that TLB faults are handled.

In order not to complicate the interface of MipsEmulateBranch(), each
caller now has to provide the branch instruction for the function.

Feedback from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.15 2017/01/21 05:42:03 guenther Exp $	*/
d191 1
a191 1
	if (copyin((void *)pc, &insn, sizeof insn) != 0) {
d1616 1
a1616 2
			if (copyin((const void *)(tf->pc + 4), &dinsn,
			    sizeof dinsn)) {
@


1.15
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.14 2016/03/06 19:42:27 mpi Exp $	*/
d137 1
d198 9
d379 2
a380 1
				tf->pc = MipsEmulateBranch(tf, tf->pc, fsr, 0);
@


1.14
log
@Rename mips64's trap_frame into trapframe.

For coherency with other archs and in order to use it in MI code.

ok visa@@, tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.13 2015/09/10 14:37:20 miod Exp $	*/
d204 1
a204 1
	    p->p_comm, fsr, pc);
d208 1
a208 1
	    p->p_comm, insn, fsr);
@


1.13
log
@Initialize `pc' earlier so that the siginfo pc value is correct in case of
genuine FPU exception.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.12 2015/08/27 18:45:09 miod Exp $	*/
d47 1
a47 1
int	fpu_emulate(struct proc *, struct trap_frame *, uint32_t,
d49 2
a50 2
int	fpu_emulate_cop1(struct proc *, struct trap_frame *, uint32_t);
int	fpu_emulate_cop1x(struct proc *, struct trap_frame *, uint32_t);
d52 2
a53 2
	fpu_load(struct proc *, struct trap_frame *, uint, uint);
void	fpu_store(struct proc *, struct trap_frame *, uint, uint, uint64_t);
d55 1
a55 1
int	nofpu_emulate_cop1(struct proc *, struct trap_frame *, uint32_t,
d57 1
a57 1
int	nofpu_emulate_cop1x(struct proc *, struct trap_frame *, uint32_t,
d59 1
a59 1
int	nofpu_emulate_loadstore(struct proc *, struct trap_frame *, uint32_t,
d61 1
a61 1
int	nofpu_emulate_movci(struct trap_frame *, uint32_t);
d64 1
a64 1
typedef	int (fpu_fn3)(struct proc *, struct trap_frame *, uint, uint, uint,
d66 1
a66 1
typedef	int (fpu_fn4)(struct proc *, struct trap_frame *, uint, uint, uint,
d70 1
a70 1
int	fpu_c(struct proc *, struct trap_frame *, uint, uint, uint, uint, uint);
d80 1
a80 1
int	fpu_int_l(struct proc *, struct trap_frame *, uint, uint, uint, uint,
d82 1
a82 1
int	fpu_int_w(struct proc *, struct trap_frame *, uint, uint, uint, uint,
d130 1
a130 1
MipsFPTrap(struct trap_frame *tf)
d413 1
a413 1
fpu_emulate(struct proc *p, struct trap_frame *tf, uint32_t insn,
d483 1
a483 1
fpu_emulate_cop1(struct proc *p, struct trap_frame *tf, uint32_t insn)
d615 1
a615 1
fpu_emulate_cop1x(struct proc *p, struct trap_frame *tf, uint32_t insn)
d681 1
a681 1
fpu_load(struct proc *p, struct trap_frame *tf, uint fmt, uint regno)
d719 1
a719 1
fpu_store(struct proc *p, struct trap_frame *tf, uint fmt, uint regno,
d738 1
a738 1
fpu_int_l(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d768 1
a768 1
fpu_int_w(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d802 1
a802 1
fpu_abs(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d837 1
a837 1
fpu_add(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d860 1
a860 1
fpu_c(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d935 1
a935 1
fpu_ceil_l(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d943 1
a943 1
fpu_ceil_w(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d951 1
a951 1
fpu_cvt_d(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d979 1
a979 1
fpu_cvt_l(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1010 1
a1010 1
fpu_cvt_s(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1038 1
a1038 1
fpu_cvt_w(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1069 1
a1069 1
fpu_div(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1092 1
a1092 1
fpu_floor_l(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1100 1
a1100 1
fpu_floor_w(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1108 1
a1108 1
fpu_madd(struct proc *p, struct trap_frame *tf, uint fmt, uint fr, uint ft,
d1136 1
a1136 1
fpu_mov(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1153 1
a1153 1
fpu_movcf(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1177 1
a1177 1
fpu_movn(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1195 1
a1195 1
fpu_movz(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1213 1
a1213 1
fpu_msub(struct proc *p, struct trap_frame *tf, uint fmt, uint fr, uint ft,
d1241 1
a1241 1
fpu_mul(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1264 1
a1264 1
fpu_neg(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1299 1
a1299 1
fpu_nmadd(struct proc *p, struct trap_frame *tf, uint fmt, uint fr, uint ft,
d1335 1
a1335 1
fpu_nmsub(struct proc *p, struct trap_frame *tf, uint fmt, uint fr, uint ft,
d1371 1
a1371 1
fpu_recip(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1395 1
a1395 1
fpu_round_l(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1403 1
a1403 1
fpu_round_w(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1411 1
a1411 1
fpu_rsqrt(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1441 1
a1441 1
fpu_sqrt(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1465 1
a1465 1
fpu_sub(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1488 1
a1488 1
fpu_trunc_l(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1496 1
a1496 1
fpu_trunc_w(struct proc *p, struct trap_frame *tf, uint fmt, uint ft, uint fs,
d1509 1
a1509 1
nofpu_emulate_cop1(struct proc *p, struct trap_frame *tf, uint32_t insn,
d1639 1
a1639 1
nofpu_emulate_cop1x(struct proc *p, struct trap_frame *tf, uint32_t insn,
d1728 1
a1728 1
nofpu_emulate_loadstore(struct proc *p, struct trap_frame *tf, uint32_t insn,
d1802 1
a1802 1
nofpu_emulate_movci(struct trap_frame *tf, uint32_t insn)
@


1.12
log
@Access the image of the floating point registers via p_md.md_regs, instead of
directly on the frame, or any updates will get lost. This went unnoticed for
so long because FPU emulation traps usually use the first frame of the U area,
so values kind of stick.

This fixes a rare occurrence of wrong floating-point values with MP kernels
on Octeon.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.11 2015/05/05 21:24:58 jmatthew Exp $	*/
d151 4
a189 3
	pc = (vaddr_t)tf->pc;
	if (tf->cause & CR_BR_DELAY)
		pc += 4;
@


1.11
log
@no need to swizzle load/store addresses for 32bit values on big endian systems

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.10 2015/01/02 22:38:46 sebastia Exp $	*/
d47 4
a50 3
int	fpu_emulate(struct trap_frame *, uint32_t, union sigval *);
int	fpu_emulate_cop1(struct trap_frame *, uint32_t);
int	fpu_emulate_cop1x(struct trap_frame *, uint32_t);
d52 2
a53 2
	fpu_load(struct trap_frame *, uint, uint);
void	fpu_store(struct trap_frame *, uint, uint, uint64_t);
d55 6
a60 3
int	nofpu_emulate_cop1(struct trap_frame *, uint32_t, union sigval *);
int	nofpu_emulate_cop1x(struct trap_frame *, uint32_t, union sigval *);
int	nofpu_emulate_loadstore(struct trap_frame *, uint32_t, union sigval *);
d64 4
a67 2
typedef	int (fpu_fn3)(struct trap_frame *, uint, uint, uint, uint);
typedef	int (fpu_fn4)(struct trap_frame *, uint, uint, uint, uint, uint);
d70 1
a70 1
int	fpu_c(struct trap_frame *, uint, uint, uint, uint, uint);
d80 4
a83 2
int	fpu_int_l(struct trap_frame *, uint, uint, uint, uint, uint);
int	fpu_int_w(struct trap_frame *, uint, uint, uint, uint, uint);
d312 1
a312 1
		sig = fpu_emulate(tf, insn, &sv);
d412 2
a413 1
fpu_emulate(struct trap_frame *tf, uint32_t insn, union sigval *sv)
d430 1
a430 1
		return nofpu_emulate_loadstore(tf, insn, sv);
d442 1
a442 1
			return nofpu_emulate_cop1(tf, insn, sv);
d445 1
a445 1
			return fpu_emulate_cop1(tf, insn);
d458 1
a458 1
				return nofpu_emulate_cop1x(tf, insn, sv);
d467 1
a467 1
			return fpu_emulate_cop1x(tf, insn);
d470 1
a470 1
			return fpu_emulate_cop1x(tf, insn);
d482 1
a482 1
fpu_emulate_cop1(struct trap_frame *tf, uint32_t insn)
d604 2
a605 1
		return fpu_c(tf, inst.FRType.fmt, ft, fs, fd, inst.FRType.func);
d607 1
a607 1
		return (*fpu_op)(tf, inst.FRType.fmt, ft, fs, fd);
d614 1
a614 1
fpu_emulate_cop1x(struct trap_frame *tf, uint32_t insn)
d673 1
a673 1
	return (*fpu_op)(tf, inst.FRType.fmt, fr, ft, fs, fd);
d680 1
a680 1
fpu_load(struct trap_frame *tf, uint fmt, uint regno)
a681 1
	register_t *regs = (register_t *)tf;
d684 1
a684 1
	tmp = (uint64_t)regs[FPBASE + regno];
d701 2
a702 1
			tmp2 = (uint64_t)regs[FPBASE + regno + 1];
d718 2
a719 1
fpu_store(struct trap_frame *tf, uint fmt, uint regno, uint64_t rslt)
a720 2
	register_t *regs = (register_t *)tf;

d722 1
a722 1
		regs[FPBASE + regno] = rslt;
d725 4
a728 2
		regs[FPBASE + regno] = rslt & 0xffffffff;
		regs[FPBASE + regno + 1] = (rslt >> 32) & 0xffffffff;
d737 2
a738 1
fpu_int_l(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd, uint rm)
d748 1
a748 1
	raw = fpu_load(tf, fmt, fs);
d761 1
a761 1
		fpu_store(tf, fmt, fd, raw);
d767 2
a768 1
fpu_int_w(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd, uint rm)
d778 1
a778 1
	raw = fpu_load(tf, fmt, fs);
d791 1
a791 1
		fpu_store(tf, fmt, fd, raw);
d801 2
a802 1
fpu_abs(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d811 1
a811 1
	raw = fpu_load(tf, fmt, fs);
d830 1
a830 1
	fpu_store(tf, fmt, fd, raw);
d836 2
a837 1
fpu_add(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d844 2
a845 2
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
d853 1
a853 1
	fpu_store(tf, fmt, fd, rslt);
d859 2
a860 1
fpu_c(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd, uint op)
d873 2
a874 2
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
d934 2
a935 1
fpu_ceil_l(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d938 1
a938 1
	return fpu_int_l(tf, fmt, ft, fs, fd, FP_RP);
d942 2
a943 1
fpu_ceil_w(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d946 1
a946 1
	return fpu_int_w(tf, fmt, ft, fs, fd, FP_RP);
d950 2
a951 1
fpu_cvt_d(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d960 1
a960 1
	raw = fpu_load(tf, fmt, fs);
d972 1
a972 1
	fpu_store(tf, fmt, fd, raw);
d978 2
a979 1
fpu_cvt_l(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d990 1
a990 1
	raw = fpu_load(tf, fmt, fs);
d1003 1
a1003 1
		fpu_store(tf, fmt, fd, raw);
d1009 2
a1010 1
fpu_cvt_s(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1019 1
a1019 1
	raw = fpu_load(tf, fmt, fs);
d1031 1
a1031 1
	fpu_store(tf, fmt, fd, raw);
d1037 2
a1038 1
fpu_cvt_w(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1049 1
a1049 1
	raw = fpu_load(tf, fmt, fs);
d1062 1
a1062 1
		fpu_store(tf, fmt, fd, raw);
d1068 2
a1069 1
fpu_div(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1076 2
a1077 2
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
d1085 1
a1085 1
	fpu_store(tf, fmt, fd, rslt);
d1091 2
a1092 1
fpu_floor_l(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1095 1
a1095 1
	return fpu_int_l(tf, fmt, ft, fs, fd, FP_RM);
d1099 2
a1100 1
fpu_floor_w(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1103 1
a1103 1
	return fpu_int_w(tf, fmt, ft, fs, fd, FP_RM);
d1107 2
a1108 1
fpu_madd(struct trap_frame *tf, uint fmt, uint fr, uint ft, uint fs, uint fd)
d1115 3
a1117 3
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
	raw3 = fpu_load(tf, fmt, fr);
d1129 1
a1129 1
	fpu_store(tf, fmt, fd, rslt);
d1135 2
a1136 1
fpu_mov(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1145 2
a1146 2
	raw = fpu_load(tf, fmt, fs);
	fpu_store(tf, fmt, fd, raw);
d1152 2
a1153 1
fpu_movcf(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1168 2
a1169 2
		raw = fpu_load(tf, fmt, fs);
		fpu_store(tf, fmt, fd, raw);
d1176 2
a1177 1
fpu_movn(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1186 2
a1187 2
		raw = fpu_load(tf, fmt, fs);
		fpu_store(tf, fmt, fd, raw);
d1194 2
a1195 1
fpu_movz(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1204 2
a1205 2
		raw = fpu_load(tf, fmt, fs);
		fpu_store(tf, fmt, fd, raw);
d1212 2
a1213 1
fpu_msub(struct trap_frame *tf, uint fmt, uint fr, uint ft, uint fs, uint fd)
d1220 3
a1222 3
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
	raw3 = fpu_load(tf, fmt, fr);
d1234 1
a1234 1
	fpu_store(tf, fmt, fd, rslt);
d1240 2
a1241 1
fpu_mul(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1248 2
a1249 2
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
d1257 1
a1257 1
	fpu_store(tf, fmt, fd, rslt);
d1263 2
a1264 1
fpu_neg(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1273 1
a1273 1
	raw = fpu_load(tf, fmt, fs);
d1292 1
a1292 1
	fpu_store(tf, fmt, fd, raw);
d1298 2
a1299 1
fpu_nmadd(struct trap_frame *tf, uint fmt, uint fr, uint ft, uint fs, uint fd)
d1306 3
a1308 3
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
	raw3 = fpu_load(tf, fmt, fr);
d1328 1
a1328 1
	fpu_store(tf, fmt, fd, rslt);
d1334 2
a1335 1
fpu_nmsub(struct trap_frame *tf, uint fmt, uint fr, uint ft, uint fs, uint fd)
d1342 3
a1344 3
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
	raw3 = fpu_load(tf, fmt, fr);
d1364 1
a1364 1
	fpu_store(tf, fmt, fd, rslt);
d1370 2
a1371 1
fpu_recip(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1380 1
a1380 1
	raw = fpu_load(tf, fmt, fs);
d1388 1
a1388 1
	fpu_store(tf, fmt, fd, raw);
d1394 2
a1395 1
fpu_round_l(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1398 1
a1398 1
	return fpu_int_l(tf, fmt, ft, fs, fd, FP_RN);
d1402 2
a1403 1
fpu_round_w(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1406 1
a1406 1
	return fpu_int_w(tf, fmt, ft, fs, fd, FP_RN);
d1410 2
a1411 1
fpu_rsqrt(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1420 1
a1420 1
	raw = fpu_load(tf, fmt, fs);
d1434 1
a1434 1
	fpu_store(tf, fmt, fd, raw);
d1440 2
a1441 1
fpu_sqrt(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1450 1
a1450 1
	raw = fpu_load(tf, fmt, fs);
d1458 1
a1458 1
	fpu_store(tf, fmt, fd, raw);
d1464 2
a1465 1
fpu_sub(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1472 2
a1473 2
	raw1 = fpu_load(tf, fmt, fs);
	raw2 = fpu_load(tf, fmt, ft);
d1481 1
a1481 1
	fpu_store(tf, fmt, fd, rslt);
d1487 2
a1488 1
fpu_trunc_l(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1491 1
a1491 1
	return fpu_int_l(tf, fmt, ft, fs, fd, FP_RZ);
d1495 2
a1496 1
fpu_trunc_w(struct trap_frame *tf, uint fmt, uint ft, uint fs, uint fd)
d1499 1
a1499 1
	return fpu_int_w(tf, fmt, ft, fs, fd, FP_RZ);
d1508 2
a1509 1
nofpu_emulate_cop1(struct trap_frame *tf, uint32_t insn, union sigval *sv)
d1522 3
a1524 2
			regs[inst.FRType.ft] = 
			    (int32_t)regs[FPBASE + inst.FRType.fs];
d1532 1
a1532 1
				    fpu_load(tf, FMT_L, inst.FRType.fs);
d1556 2
a1557 1
		regs[FPBASE + inst.FRType.fs] = (int32_t)regs[inst.FRType.ft];
d1563 1
a1563 1
			fpu_store(tf, FMT_L, inst.FRType.fs,
d1638 2
a1639 1
nofpu_emulate_cop1x(struct trap_frame *tf, uint32_t insn, union sigval *sv)
d1663 1
a1663 1
			fpu_store(tf, FMT_L, inst.FQType.fd, ddata);
d1678 1
a1678 1
		regs[FPBASE + inst.FQType.fd] = wdata;
d1690 1
a1690 1
			ddata = fpu_load(tf, FMT_L, inst.FQType.fs);
d1709 1
a1709 1
		wdata = regs[FPBASE + inst.FQType.fs];
d1727 2
a1728 1
nofpu_emulate_loadstore(struct trap_frame *tf, uint32_t insn, union sigval *sv)
d1749 1
a1749 1
			fpu_store(tf, FMT_L, inst.IType.rt, ddata);
d1761 1
a1761 1
		regs[FPBASE + inst.IType.rt] = wdata;
d1770 1
a1770 1
			ddata = fpu_load(tf, FMT_L, inst.IType.rt);
d1786 1
a1786 1
		wdata = regs[FPBASE + inst.IType.rt];
@


1.10
log
@Fix a few format string warnings, allow to build DEBUG kernel on sgi

OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.9 2014/03/29 18:09:30 guenther Exp $	*/
a1626 3
#ifdef __MIPSEB__
		va ^= 4;
#endif
a1661 3
#ifdef __MIPSEB__
		va ^= 4;
#endif
a1708 3
#ifdef __MIPSEB__
		va ^= 4;
#endif
a1737 3
#ifdef __MIPSEB__
		va ^= 4;
#endif
@


1.9
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.8 2012/10/03 11:18:23 miod Exp $	*/
d194 1
a194 1
	printf("%s: unimplemented FPU completion, fsr 0x%08x\n%p: ",
@


1.8
log
@Split ever-growing mips <machine/cpu.h> into what 99% of the kernel needs,
which will remain in <machine/cpu.h>, and a new mips_cpu.h containing only the
goriest md details, which are only of interest to a handful set of files; this
is similar in spirit to what alpha does, but here <machine/cpu.h> does not
include the new file.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.7 2012/09/29 19:24:31 miod Exp $	*/
d151 2
a152 2
	__asm__ __volatile__ ("cfc1 %0, $31" : "=r" (fsr));
	__asm__ __volatile__ ("cfc1 %0, $31" : "=r" (fsr));
d383 1
a383 1
	__asm__ __volatile__ ("ctc1 %0, $31" :: "r" (fsr));
@


1.7
log
@Handle the coprocessor 0 cause and status registers as a 64 bit value now,
as some odd mips designs need moro than 32 bits in there. This causes a lot
of mechanical changes everywhere getsr() is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.6 2011/07/11 15:40:47 guenther Exp $	*/
d23 3
d34 1
d74 2
a94 3
int	fpu_int_l(struct trap_frame *, uint, uint, uint, uint, uint);
int	fpu_int_w(struct trap_frame *, uint, uint, uint, uint, uint);

d243 1
d278 1
@


1.6
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.4 2011/07/06 21:41:37 art Exp $	*/
d135 1
a135 1
	uint32_t sr;
@


1.5
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d388 1
d390 1
@


1.4
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.3 2010/11/24 21:16:28 miod Exp $	*/
a387 1
		KERNEL_LOCK();
a388 1
		KERNEL_UNLOCK();
@


1.3
log
@Floating-point emulation code for systems lacking proper FPU (i.e. Octeon),
enabled by option FPUEMUL.

This is pretty straightforward, except for conditional branch on FPU condition
codes emulation (bc1f/bc1fl/bc1t/bc1tl instructions): unlike most
RISC-with-delay-slots designs (m88k, sparc), the branch pipeline is not exposed
to the kernel on Mips, therefore we can not resume a branch without losing the
delay slot instruction.

Some other operating systems work around this issue by emulating the delay
slot instruction, but this is error-prone (and requires the kernel code to
be aware of all supported instructions of the processor it is currently running
on), some use dedicated breakpoints to single-step through the delay slot and
then resume the branch as expected, but this causes a lot of copy-on-write
allocations.

This code chooses a third path, of copying the delay slot instructions to run toa special `magic' page, followed by a special trap instruction to give control
back to the kernel. This makes sure the instruction will actually be run by the
processor, and that no more than one page per process is wasted, regardless of
the number of branches to emulate.

Tested on octeon (big-endian) by syuu@@ and on loongson (little-endian) by me.
Note that enabling option FPUEMUL in the kernel will completely disable the
hardware FPU, if there is one; there is currently no way to build a kernel
supporting both hardware and software FPU, and there is no reason to change
this until there is a strong need to support both.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.2 2010/10/27 20:05:12 miod Exp $	*/
d388 1
a388 1
		KERNEL_PROC_LOCK(p);
d390 1
a390 1
		KERNEL_PROC_UNLOCK(p);
@


1.2
log
@Fix a few logic errors in comparison instruction emulation: make sure the
less than relation is correctly computed, and check for both operands being
signaling NaNs, instead of only the first NaN found, to decide whether to
raise an invalid exception or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: fp_emulate.c,v 1.1 2010/09/21 20:29:17 miod Exp $	*/
d20 1
a20 1
 * Floating Point completion code (MI softfloat code control engine).
a22 2
 * Floating-point load and store instructions, as well as branch instructions,
 * are not handled, as they should not require completion code.
d49 6
d132 3
d136 1
d140 1
d160 9
d206 28
d237 3
d250 3
d262 19
d293 1
d296 1
d329 8
d338 1
d344 16
a359 12

	if (sig != SIGILL) {
		if (tf->cause & CR_BR_DELAY) {
			/*
			 * Note that it doesn't matter, at this point,
			 * that we pass the updated FSR value, as it is
			 * only used to decide whether to branch or not
			 * if the faulting instruction was BC1[FT].
			 */
			tf->pc = MipsEmulateBranch(tf, tf->pc, fsr, 0);
		} else
			tf->pc += 4;
d361 1
d377 1
d381 1
d384 4
a387 1
		sv.sival_ptr = (void *)pc;
d409 9
d419 15
a433 1
		return fpu_emulate_cop1(tf, insn);
d435 24
a458 1
		return fpu_emulate_cop1x(tf, insn);
d1453 330
@


1.1
log
@Replace the old floating point completion code with a C interface to the
MI softfloat code, implementing all MIPS IV specified floating point
operations.
Tested on R5000, R10000, R14000 and Loongson2F.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
a112 1
* Handle a floating-point exception.
d714 2
a715 2
	raw1 = fpu_load(tf, fmt, ft);
	raw2 = fpu_load(tf, fmt, fs);
d724 2
a725 1
		} else if (float32_is_nan(f32b)) {
d729 2
a730 1
		} else {
d743 2
a744 1
		} else if (float64_is_nan(f64b)) {
d748 2
a749 1
		} else {
@

