head	1.22;
access;
symbols
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.6
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.18
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.16
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.14
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.12
	OPENBSD_5_0:1.19.0.10
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.8
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.12
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.10.0.6
	OPENBSD_3_5_BASE:1.10
	SMP:1.10.0.4
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10;
locks; strict;
comment	@ * @;


1.22
date	2016.09.01.09.23.42;	author tedu;	state dead;
branches;
next	1.21;
commitid	Q2PxaFNhqAe0Wmla;

1.21
date	2015.03.28.19.07.08;	author miod;	state Exp;
branches;
next	1.20;
commitid	nwbHy4sQv9NnJnmZ;

1.20
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.10.20.54.57;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.11.18.57.35;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.02.20.00.54;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.23.11.39.36;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.29.11.37.33;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.29.07.35.11;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.09.22.02.38;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.04.16.59.31;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.02.21.32.48;	author todd;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2003.06.28.16.40.52;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.28.16.23.54;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.28.13.30.17;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.25.21.46.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.25.19.21.19;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.25.17.39.00;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.24.22.55.43;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.24.22.54.54;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.23.09.29.55;	author miod;	state Exp;
branches;
next	;

1.10.4.1
date	2004.06.05.23.10.58;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Celebrate OpenBSD 6.0 release by retiring the sparc port.
You've served us well, good friend, but now it's time to rest.
ok deraadt
@
text
@/*	$OpenBSD: ts102.c,v 1.21 2015/03/28 19:07:08 miod Exp $	*/
/*
 * Copyright (c) 2003, 2004, Miodrag Vallat.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Driver for the PCMCIA controller found in Tadpole SPARCbook 3 series
 * notebooks.
 *
 * Based on the information provided in the SPARCbook 3 Technical Reference
 * Manual (s3gxtrmb.pdf), chapter 7.  A few ramblings against this document
 * and/or the chip itself are scattered across this file.
 *
 * Implementation notes:
 *
 * - The TS102 exports its PCMCIA windows as SBus memory ranges: 64MB for
 *   the common memory window, and 16MB for the attribute and I/O windows.
 *
 *   Mapping the whole windows would consume 192MB of address space, which
 *   is much more that what the iospace can offer.
 *
 *   A best-effort solution would be to map the windows on demand. However,
 *   due to the way mapdev() works, the va used for the mappings would be
 *   lost after unmapping (although using an extent to register iospace memory
 *   usage would fix this). So, instead, we will do a fixed mapping of a subset
 *   of each window upon attach - this is similar to what the stp4020 driver
 *   does.
 *
 * - IPL for the cards interrupt handlers are not respected. See the stp4020
 *   driver source for comments about this.
 * 
 * Endianness farce:
 *
 * - The documentation pretends that the endianness settings only affect the
 *   common memory window. Gee, thanks a lot. What about other windows, then?
 *   As a result, this driver runs with endianness conversions turned off.
 *
 * - One of the little-endian SBus and big-endian PCMCIA flags has the reverse
 *   meaning, actually. To achieve a ``no endianness conversion'' status,
 *   one has to be set and the other unset. It does not matter which one,
 *   though.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/kthread.h>
#include <sys/proc.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <uvm/uvm_extern.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>

#include <sparc/dev/tctrlvar.h>
#include <sparc/dev/ts102reg.h>

#define	TS102_NUM_SLOTS		2

/*
 * Memory ranges
 */
#define	TS102_RANGE_COMMON	0
#define	TS102_RANGE_ATTR	1
#define	TS102_RANGE_IO		2

#define	TS102_RANGE_CNT		3
#define	TS102_NUM_RANGES	(TS102_RANGE_CNT * TS102_NUM_SLOTS)

#define	TS102_ARBITRARY_MAP_SIZE	(1 * 1024 * 1024)

struct	tslot_softc;

/*
 * Per-slot data
 */
struct	tslot_data {
	struct tslot_softc	*td_parent;
	struct device		*td_pcmcia;

	volatile u_int8_t	*td_regs;
	struct rom_reg		td_rr;
	vaddr_t			td_space[TS102_RANGE_CNT];

	/* Interrupt handler */
	int			(*td_intr)(void *);
	void			*td_intrarg;
	void			*td_softintr;

	/* Socket status */
	int			td_slot;
	int			td_status;
#define	TS_CARD			0x0001
};

struct	tslot_softc {
	struct device	sc_dev;

	struct intrhand	sc_ih;
	
	pcmcia_chipset_tag_t sc_pct;

	struct proc	*sc_thread;			/* event thread */
	unsigned int	sc_events;	/* sockets with pending events */

	struct tslot_data sc_slot[TS102_NUM_SLOTS];
};

void	tslot_attach(struct device *, struct device *, void *);
void	tslot_create_event_thread(void *);
void	tslot_event_thread(void *);
int	tslot_intr(void *);
void	tslot_intr_disestablish(pcmcia_chipset_handle_t, void *);
void	tslot_intr_dispatch(void *);
void	*tslot_intr_establish(pcmcia_chipset_handle_t, struct pcmcia_function *,
	    int, int (*)(void *), void *, char *);
const char *tslot_intr_string(pcmcia_chipset_handle_t, void *);
int	tslot_io_alloc(pcmcia_chipset_handle_t, bus_addr_t, bus_size_t,
	    bus_size_t, struct pcmcia_io_handle *);
void	tslot_io_free(pcmcia_chipset_handle_t, struct pcmcia_io_handle *);
int	tslot_io_map(pcmcia_chipset_handle_t, int, bus_addr_t, bus_size_t,
	    struct pcmcia_io_handle *, int *);
void	tslot_io_unmap(pcmcia_chipset_handle_t, int);
int	tslot_match(struct device *, void *, void *);
int	tslot_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *);
void	tslot_mem_free(pcmcia_chipset_handle_t, struct pcmcia_mem_handle *);
int	tslot_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t, bus_size_t,
	    struct pcmcia_mem_handle *, bus_size_t *, int *);
void	tslot_mem_unmap(pcmcia_chipset_handle_t, int);
int	tslot_print(void *, const char *);
void	tslot_queue_event(struct tslot_softc *, int);
void	tslot_reset(struct tslot_data *, u_int32_t);
void	tslot_slot_disable(pcmcia_chipset_handle_t);
void	tslot_slot_enable(pcmcia_chipset_handle_t);
void	tslot_slot_intr(struct tslot_data *, int);

struct	cfattach tslot_ca = {
	sizeof(struct tslot_softc), tslot_match, tslot_attach
};

struct	cfdriver tslot_cd = {
	NULL, "tslot", DV_DULL
};

/*
 * PCMCIA chipset methods
 */
struct	pcmcia_chip_functions tslot_functions = {
	tslot_mem_alloc,
	tslot_mem_free,
	tslot_mem_map,
	tslot_mem_unmap,

	tslot_io_alloc,
	tslot_io_free,
	tslot_io_map,
	tslot_io_unmap,

	tslot_intr_establish,
	tslot_intr_disestablish,
	tslot_intr_string,

	tslot_slot_enable,
	tslot_slot_disable
};

#define	TSLOT_READ(slot, offset) \
	*(volatile u_int16_t *)((slot)->td_regs + (offset))
#define	TSLOT_WRITE(slot, offset, value) \
	*(volatile u_int16_t *)((slot)->td_regs + (offset)) = (value)

/*
 * Attachment and initialization
 */

int
tslot_match(struct device *parent, void *vcf, void *aux)
{
	struct confargs *ca = aux;

	return (strcmp("ts102", ca->ca_ra.ra_name) == 0);
}

void
tslot_attach(struct device *parent, struct device *self, void *args)
{
	struct confargs *ca = args;
	struct tslot_softc *sc = (struct tslot_softc *)self;
	struct romaux *ra;
	struct rom_range ranges[TS102_NUM_RANGES], *range;
	struct tslot_data *td;
	volatile u_int8_t *regs;
	int node, nranges, slot, rnum;

	ra = &ca->ca_ra;
	node = ra->ra_node;
	regs = mapiodev(&ra->ra_reg[0], 0, ra->ra_len);

	/*
	 * Find memory ranges
	 */
	nranges = getproplen(node, "ranges") / sizeof(struct rom_range);
	if (nranges < TS102_NUM_RANGES) {
		printf(": expected %d memory ranges, got %d\n",
		    TS102_NUM_RANGES, nranges);
		return;
	}
	getprop(node, "ranges", ranges, sizeof ranges);

	/*
	 * Ranges being relative to this sbus slot, turn them into absolute
	 * addresses.
	 */
	for (rnum = 0; rnum < TS102_NUM_RANGES; rnum++) {
		ranges[rnum].poffset -= TS102_OFFSET_REGISTERS;
	}

	sc->sc_ih.ih_fun = tslot_intr;
	sc->sc_ih.ih_arg = sc;
	intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, -1, self->dv_xname);
	printf(" pri %d", ra->ra_intr[0].int_pri);

	printf(": %d slots\n", TS102_NUM_SLOTS);

	/*
	 * Setup asynchronous event handler
	 */
	sc->sc_events = 0;
	kthread_create_deferred(tslot_create_event_thread, sc);

	sc->sc_pct = (pcmcia_chipset_tag_t)&tslot_functions;

	/*
	 * Setup slots
	 */
	for (slot = 0; slot < TS102_NUM_SLOTS; slot++) {
		td = &sc->sc_slot[slot];
		for (rnum = 0; rnum < TS102_RANGE_CNT; rnum++) {
			range = ranges + (slot * TS102_RANGE_CNT + rnum);
			td->td_rr = ra->ra_reg[0];
			td->td_rr.rr_iospace = range->pspace;
			td->td_rr.rr_paddr = (void *)
			   ((u_int32_t)td->td_rr.rr_paddr + range->poffset);
			td->td_space[rnum] = (vaddr_t)mapiodev(&td->td_rr, 0,
			    TS102_ARBITRARY_MAP_SIZE);
		}
		td->td_parent = sc;
		td->td_regs = regs +
		    slot * (TS102_REG_CARD_B_INT - TS102_REG_CARD_A_INT);
		td->td_slot = slot;
		SET_TAG_LITTLE_ENDIAN(&td->td_rr);
		tslot_reset(td, TS102_ARBITRARY_MAP_SIZE);
	}
}

void
tslot_reset(struct tslot_data *td, u_int32_t iosize)
{
	struct pcmciabus_attach_args paa;
	int ctl, status;

	paa.paa_busname = "pcmcia";
	paa.pct = (pcmcia_chipset_tag_t)td->td_parent->sc_pct;
	paa.pch = (pcmcia_chipset_handle_t)td;
	paa.iobase = 0;
	paa.iosize = iosize;

	td->td_pcmcia = config_found(&td->td_parent->sc_dev, &paa, tslot_print);

	if (td->td_pcmcia == NULL) {
		/*
		 * If no pcmcia attachment, power down the slot.
		 */
		tslot_slot_disable((pcmcia_chipset_handle_t)td);
		return;
	}

	/*
	 * Initialize the slot
	 */

	ctl = TSLOT_READ(td, TS102_REG_CARD_A_CTL);
	/* force low addresses */
	ctl &= ~(TS102_CARD_CTL_AA_MASK | TS102_CARD_CTL_IA_MASK);
	/* Put SBus and PCMCIA in their respective endian mode */
	ctl |= TS102_CARD_CTL_SBLE;	/* this is not what it looks like! */
	ctl &= ~TS102_CARD_CTL_PCMBE;
	/* disable read ahead and address increment */
	ctl &= ~TS102_CARD_CTL_RAHD;
	ctl |= TS102_CARD_CTL_INCDIS;
	/* power on */
	ctl &= ~TS102_CARD_CTL_PWRD;
	TSLOT_WRITE(td, TS102_REG_CARD_A_CTL, ctl);

	/*
	 * Enable interrupt upon insertion/removal
	 */

	TSLOT_WRITE(td, TS102_REG_CARD_A_INT,
	    TS102_CARD_INT_MASK_CARDDETECT_STATUS);

	status = TSLOT_READ(td, TS102_REG_CARD_A_STS);
	if (status & TS102_CARD_STS_PRES) {
		tadpole_set_pcmcia(td->td_slot, 1);
		td->td_status = TS_CARD;
		pcmcia_card_attach(td->td_pcmcia);
	} else {
		tadpole_set_pcmcia(td->td_slot, 0);
		td->td_status = 0;
	}
}

/* XXX there ought to be a common function for this... */
int
tslot_print(void *aux, const char *description)
{
	struct pcmciabus_attach_args *paa = aux;
	struct tslot_data *td = (struct tslot_data *)paa->pch;

	printf(" socket %d", td->td_slot);
	return (UNCONF);
}

/*
 * PCMCIA Helpers
 */

int
tslot_io_alloc(pcmcia_chipset_handle_t pch, bus_addr_t start, bus_size_t size,
    bus_size_t align, struct pcmcia_io_handle *pih)
{
	struct tslot_data *td = (struct tslot_data *)pch;

#ifdef TSLOT_DEBUG
	printf("[io alloc %x-%x]", start, size);
#endif

	pih->iot = &td->td_rr;
	pih->ioh = (bus_space_handle_t)(td->td_space[TS102_RANGE_IO]);
	pih->addr = start;
	pih->size = size;
	pih->flags = 0;

	return (0);
}

void
tslot_io_free(pcmcia_chipset_handle_t pch, struct pcmcia_io_handle *pih)
{
#ifdef TSLOT_DEBUG
	printf("[io free %x-%x]", pih->start, pih->size);
#endif
}

int
tslot_io_map(pcmcia_chipset_handle_t pch, int width, bus_addr_t offset,
    bus_size_t size, struct pcmcia_io_handle *pih, int *windowp)
{
	struct tslot_data *td = (struct tslot_data *)pch;

#ifdef TSLOT_DEBUG
	printf("[io map %x-%x", offset, size);
#endif

	pih->iot = &td->td_rr;
	bus_space_subregion(&td->td_rr, td->td_space[TS102_RANGE_IO],
	    offset, size, &pih->ioh);
	*windowp = TS102_RANGE_IO;

#ifdef TSLOT_DEBUG
	printf("->%p/%x]", pih->ioh, size);
#endif

	return (0);
}

void
tslot_io_unmap(pcmcia_chipset_handle_t pch, int win)
{
#ifdef TSLOT_DEBUG
	printf("[io unmap]");
#endif
}

int
tslot_mem_alloc(pcmcia_chipset_handle_t pch, bus_size_t size,
    struct pcmcia_mem_handle *pmh)
{
	struct tslot_data *td = (struct tslot_data *)pch;

#ifdef TSLOT_DEBUG
	printf("[mem alloc %x]", size);
#endif
	pmh->memt = &td->td_rr;
	pmh->size = round_page(size);
	pmh->addr = 0;
	pmh->mhandle = 0;
	pmh->realsize = 0;	/* nothing so far! */

	return (0);
}

void
tslot_mem_free(pcmcia_chipset_handle_t pch, struct pcmcia_mem_handle *pmh)
{
#ifdef TSLOT_DEBUG
	printf("[mem free %x]", pmh->size);
#endif
}

int
tslot_mem_map(pcmcia_chipset_handle_t pch, int kind, bus_addr_t addr,
    bus_size_t size, struct pcmcia_mem_handle *pmh, bus_size_t *offsetp,
    int *windowp)
{
	struct tslot_data *td = (struct tslot_data *)pch;
	int slot;

	slot = kind & PCMCIA_MEM_ATTR ? TS102_RANGE_ATTR : TS102_RANGE_COMMON;
#ifdef TSLOT_DEBUG
	printf("[mem map %d %x-%x", slot, addr, size);
#endif

	addr += pmh->addr;

	pmh->memt = &td->td_rr;
	bus_space_subregion(&td->td_rr, td->td_space[slot],
	    addr, size, &pmh->memh);
	pmh->realsize = TS102_ARBITRARY_MAP_SIZE - addr;
	*offsetp = 0;
	*windowp = slot;

#ifdef TSLOT_DEBUG
	printf("->%p/%x]", pmh->memh, size);
#endif

	return (0);
}

void
tslot_mem_unmap(pcmcia_chipset_handle_t pch, int win)
{
#ifdef TSLOT_DEBUG
	printf("[mem unmap %d]", win);
#endif
}

void
tslot_slot_disable(pcmcia_chipset_handle_t pch)
{
	struct tslot_data *td = (struct tslot_data *)pch;

#ifdef TSLOT_DEBUG
	printf("%s: disable slot %d\n",
	    td->td_parent->sc_dev.dv_xname, td->td_slot);
#endif

	/*
	 * Disable card access.
	 */
	TSLOT_WRITE(td, TS102_REG_CARD_A_STS,
	    TSLOT_READ(td, TS102_REG_CARD_A_STS) & ~TS102_CARD_STS_ACEN);

	/*
	 * Disable interrupts, except for insertion.
	 */
	TSLOT_WRITE(td, TS102_REG_CARD_A_INT,
	    TS102_CARD_INT_MASK_CARDDETECT_STATUS);
}

void
tslot_slot_enable(pcmcia_chipset_handle_t pch)
{
	struct tslot_data *td = (struct tslot_data *)pch;
	int status, intr, i;

#ifdef TSLOT_DEBUG
	printf("%s: enable slot %d\n",
	    td->td_parent->sc_dev.dv_xname, td->td_slot);
#endif

	/* Power down the socket to reset it */
	status = TSLOT_READ(td, TS102_REG_CARD_A_STS);
	TSLOT_WRITE(td, TS102_REG_CARD_A_STS, status | TS102_CARD_STS_VCCEN);

	/*
	 * wait 300ms until power fails (Tpf).  Then, wait 100ms since we
	 * are changing Vcc (Toff).
	 */
	DELAY((300 + 100) * 1000);

	/*
	 * Power on the card if not already done, and enable card access
	 */
	status |= TS102_CARD_STS_ACEN;
	status &= ~TS102_CARD_STS_VCCEN;
	TSLOT_WRITE(td, TS102_REG_CARD_A_STS, status);

	/*
	 * wait 100ms until power raise (Tpr) and 20ms to become
	 * stable (Tsu(Vcc)).
	 */
	DELAY((100 + 20) * 1000);

	status &= ~TS102_CARD_STS_VPP1_MASK;
	status |= TS102_CARD_STS_VPP1_VCC;
	TSLOT_WRITE(td, TS102_REG_CARD_A_STS, status);

	/*
	 * hold RESET at least 20us.
	 */
	intr = TSLOT_READ(td, TS102_REG_CARD_A_INT);
	TSLOT_WRITE(td, TS102_REG_CARD_A_INT, TS102_CARD_INT_SOFT_RESET);
	DELAY(20);
	TSLOT_WRITE(td, TS102_REG_CARD_A_INT, intr);

	/* wait 20ms as per pc card standard (r2.01) section 4.3.6 */
	DELAY(20 * 1000);

	/* We need level-triggered interrupts for PC Card hardware */
	TSLOT_WRITE(td, TS102_REG_CARD_A_STS,
		TSLOT_READ(td, TS102_REG_CARD_A_STS) | TS102_CARD_STS_LVL);

	/*
	 * Wait until the card is unbusy. If it is still busy after 3 seconds,
	 * give up. We could enable card interrupts and wait for the interrupt
	 * to happen when BUSY is released, but the interrupt could also be
	 * triggered by the card itself if it's an I/O card, so better poll
	 * here.
	 */
	for (i = 30000; i != 0; i--) {
		status = TSLOT_READ(td, TS102_REG_CARD_A_STS);
		/* If the card has been removed, abort */
		if ((status & TS102_CARD_STS_PRES) == 0) {
			tslot_slot_disable(pch);
			return;
		}
		if (status & TS102_CARD_STS_RDY)
			break;
		else
			DELAY(100);
	}

	if (i == 0) {
		printf("%s: slot %d still busy after 3 seconds, status 0x%x\n",
		    td->td_parent->sc_dev.dv_xname, td->td_slot,
		    TSLOT_READ(td, TS102_REG_CARD_A_STS));
		return;
	}

	/*
	 * Enable the card interrupts if this is an I/O card.
	 * Note that the TS102_CARD_STS_IO bit in the status register will
	 * never get set, despite what the documentation says!
	 */
	if (pcmcia_card_gettype(td->td_pcmcia) == PCMCIA_IFTYPE_IO) {
		TSLOT_WRITE(td, TS102_REG_CARD_A_STS,
		    TSLOT_READ(td, TS102_REG_CARD_A_STS) | TS102_CARD_STS_IO);
		TSLOT_WRITE(td, TS102_REG_CARD_A_INT,
		    TS102_CARD_INT_MASK_CARDDETECT_STATUS |
		    TS102_CARD_INT_MASK_IRQ);
	}
}

/*
 * Event management
 */
void
tslot_create_event_thread(void *v)
{
	struct tslot_softc *sc = v;
	const char *name = sc->sc_dev.dv_xname;

	if (kthread_create(tslot_event_thread, sc, &sc->sc_thread,
	    name) != 0) {
		panic("%s: unable to create event kthread", name);
	}
}

void
tslot_event_thread(void *v)
{
	struct tslot_softc *sc = v;
	struct tslot_data *td;
	int s, status;
	unsigned int socket;

	for (;;) {
		s = splhigh();

		if ((socket = ffs(sc->sc_events)) == 0) {
			splx(s);
			tsleep(&sc->sc_events, PWAIT, "tslot_event", 0);
			continue;
		}
		socket--;
		sc->sc_events &= ~(1 << socket);
		splx(s);

		if (socket >= TS102_NUM_SLOTS) {
#ifdef DEBUG
			printf("%s: invalid slot number %d\n",
			    sc->sc_dev.dv_xname, te->te_slot);
#endif
			continue;
		}

		td = &sc->sc_slot[socket];
		status = TSLOT_READ(td, TS102_REG_CARD_A_STS);

		if (status & TS102_CARD_STS_PRES) {
			/* Card insertion */
			if ((td->td_status & TS_CARD) == 0) {
				td->td_status |= TS_CARD;
				tadpole_set_pcmcia(td->td_slot, 1);
				pcmcia_card_attach(td->td_pcmcia);
			}
		} else {
			/* Card removal */
			if ((td->td_status & TS_CARD) != 0) {
				td->td_status &= ~TS_CARD;
				tadpole_set_pcmcia(td->td_slot, 0);
				pcmcia_card_detach(td->td_pcmcia,
				    DETACH_FORCE);
			}
		}
	}
}

/*
 * Interrupt handling
 */

int
tslot_intr(void *v)
{
	struct tslot_softc *sc = v;
	struct tslot_data *td;
	int intregs[TS102_NUM_SLOTS], *intreg;
	int i, rc = 0;
	int s;

	/* protect hardware access against soft interrupts */
	s = splhigh();

	/*
	 * Scan slots, and acknowledge the interrupt if necessary first
	 */
	for (i = 0; i < TS102_NUM_SLOTS; i++) {
		td = &sc->sc_slot[i];
		intreg = &intregs[i];
		*intreg = TSLOT_READ(td, TS102_REG_CARD_A_INT);

		/*
		 * Acknowledge all interrupt situations at once, even if they
		 * did not occur.
		 */
		if ((*intreg & (TS102_CARD_INT_STATUS_IRQ |
		    TS102_CARD_INT_STATUS_WP_STATUS_CHANGED |
		    TS102_CARD_INT_STATUS_BATTERY_STATUS_CHANGED |
		    TS102_CARD_INT_STATUS_CARDDETECT_STATUS_CHANGED)) != 0) {
			rc = 1;
			TSLOT_WRITE(td, TS102_REG_CARD_A_INT, *intreg |
			    TS102_CARD_INT_RQST_IRQ |
			    TS102_CARD_INT_RQST_WP_STATUS_CHANGED |
			    TS102_CARD_INT_RQST_BATTERY_STATUS_CHANGED |
			    TS102_CARD_INT_RQST_CARDDETECT_STATUS_CHANGED);
		}
	}

	/*
	 * Invoke the interrupt handler for each slot
	 */
	for (i = 0; i < TS102_NUM_SLOTS; i++) {
		td = &sc->sc_slot[i];
		intreg = &intregs[i];

		if ((*intreg & (TS102_CARD_INT_STATUS_IRQ |
		    TS102_CARD_INT_STATUS_WP_STATUS_CHANGED |
		    TS102_CARD_INT_STATUS_BATTERY_STATUS_CHANGED |
		    TS102_CARD_INT_STATUS_CARDDETECT_STATUS_CHANGED)) != 0)
			tslot_slot_intr(td, *intreg);
	}

	splx(s);
	return (rc);
}

void
tslot_queue_event(struct tslot_softc *sc, int slot)
{
	int s;

	s = splhigh();
	sc->sc_events |= (1 << slot);
	splx(s);
	wakeup(&sc->sc_events);
}

void
tslot_slot_intr(struct tslot_data *td, int intreg)
{
	struct tslot_softc *sc = td->td_parent;
	int status, sockstat;

	status = TSLOT_READ(td, TS102_REG_CARD_A_STS);
#ifdef TSLOT_DEBUG
	printf("%s: interrupt on socket %d ir %x sts %x\n",
	    sc->sc_dev.dv_xname, td->td_slot, intreg, status);
#endif

	sockstat = td->td_status;

	/*
	 * The TS102 queues interrupt requests, and may trigger an interrupt
	 * for a condition the driver does not want to receive anymore (for
	 * example, after a card gets removed).
	 * Thus, only proceed if the driver is currently allowing a particular
	 * condition.
	 */

	if ((intreg & TS102_CARD_INT_STATUS_CARDDETECT_STATUS_CHANGED) != 0 &&
	    (intreg & TS102_CARD_INT_MASK_CARDDETECT_STATUS) != 0) {
		tslot_queue_event(sc, td->td_slot);
#ifdef TSLOT_DEBUG
		printf("%s: slot %d status changed from %d to %d\n",
		    sc->sc_dev.dv_xname, td->td_slot, sockstat, td->td_status);
#endif
		/*
		 * Ignore extra interrupt bits, they are part of the change.
		 */
		return;
	}

	if ((intreg & TS102_CARD_INT_STATUS_IRQ) != 0 &&
	    (intreg & TS102_CARD_INT_MASK_IRQ) != 0) {
		/* ignore interrupts if we have a pending state change */
		if (sc->sc_events & (1 << td->td_slot))
			return;

		if ((sockstat & TS_CARD) == 0) {
			printf("%s: spurious interrupt on slot %d isr %x\n",
			    sc->sc_dev.dv_xname, td->td_slot, intreg);
			return;
		}

		if (td->td_softintr != NULL) {
			/*
			 * Disable this sbus interrupt, until the
			 * softintr handler had a chance to run.
			 */
			TSLOT_WRITE(td, TS102_REG_CARD_A_INT,
			    TSLOT_READ(td, TS102_REG_CARD_A_INT) &
			    ~TS102_CARD_INT_MASK_IRQ);

			softintr_schedule(td->td_softintr);
		}
	}
}

/*
 * Software interrupt called to invoke the real driver interrupt handler.
 */
void
tslot_intr_dispatch(void *arg)
{
	struct tslot_data *td = (struct tslot_data *)arg;
	int s;

	/* invoke driver handler */
	td->td_intr(td->td_intrarg);

	/* enable SBUS interrupts for PCMCIA interrupts again */
	s = splhigh();
	TSLOT_WRITE(td, TS102_REG_CARD_A_INT,
	    TSLOT_READ(td, TS102_REG_CARD_A_INT) | TS102_CARD_INT_MASK_IRQ);
	splx(s);
}

void
tslot_intr_disestablish(pcmcia_chipset_handle_t pch, void *ih)
{
	struct tslot_data *td = (struct tslot_data *)pch;

	if (td->td_softintr != NULL) {
		softintr_disestablish(td->td_softintr);
		td->td_softintr = NULL;
	}
	td->td_intr = NULL;
	td->td_intrarg = NULL;
}

const char *
tslot_intr_string(pcmcia_chipset_handle_t pch, void *ih)
{
	if (ih == NULL)
		return ("couldn't establish interrupt");
	else
		return ("");	/* nothing for now */
}


void *
tslot_intr_establish(pcmcia_chipset_handle_t pch, struct pcmcia_function *pf,
    int ipl, int (*handler)(void *), void *arg, char *xname)
{
	struct tslot_data *td = (struct tslot_data *)pch;

	/*
	 * Note that this code relies on softintr_establish() to be
	 * used with real, hardware ipl values. All platforms with
	 * SBus support support this.
	 */
	td->td_intr = handler;
	td->td_intrarg = arg;
	td->td_softintr = softintr_establish(ipl, tslot_intr_dispatch, td);

	return td->td_softintr != NULL ? td : NULL;
}
@


1.21
log
@Don't include sbusvar.h if you need neither sbus_translate() nor sbus_testdma().
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.20 2013/11/18 20:21:51 deraadt Exp $	*/
@


1.20
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.19 2009/04/10 20:54:57 miod Exp $	*/
a80 1
#include <sparc/dev/sbusvar.h>
@


1.19
log
@Use soft interrupts to dispatch pcmcia device interrupts; this ensures the
driver handlers get invoked at the right level. Parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.18 2006/08/11 18:57:35 miod Exp $	*/
d602 1
a602 1
	if (kthread_create(tslot_event_thread, sc, &sc->sc_thread, "%s",
@


1.18
log
@An old dvorak typo was lurking here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.17 2006/06/02 20:00:54 miod Exp $	*/
d115 1
d141 1
d669 4
d713 1
d775 1
a775 1
		if (td->td_intr != NULL) {
d777 2
a778 2
			 * XXX There is no way to honour the interrupt handler
			 * requested IPL level...
d780 5
a784 1
			(*td->td_intr)(td->td_intrarg);
d789 19
d813 4
d837 5
d844 1
d846 1
a846 1
	return (td);
@


1.17
log
@sbus_establish() and the associated linked list in the sbus softc is now only
used to store a per-device reset callback, for use in sbusreset(). Except
sbusreset() has never, ever, been used since Torek's sbus code went in.
Time to recycle those wasted bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.16 2005/11/23 11:39:36 mickey Exp $	*/
d44 1
a44 1
 *   due to the wap mapdev() works, the va used for the mappings would be
@


1.16
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.15 2005/03/29 11:37:33 miod Exp $	*/
a123 1
	struct sbusdev	sc_sd;
a247 2

	sbus_establish(&sc->sc_sd, self);
@


1.15
log
@Display the PCMCIA icon when cards are plugged.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.14 2005/01/27 17:03:23 millert Exp $	*/
d155 1
a155 1
	    struct pcmcia_mem_handle *, bus_addr_t *, int *);
d442 1
a442 1
    bus_size_t size, struct pcmcia_mem_handle *pmh, bus_addr_t *offsetp,
@


1.14
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.13 2004/09/29 07:35:11 miod Exp $	*/
d50 1
a50 1
 * - IPL for the cards interrupt handles are not respected. See the stp4020
d82 1
d142 1
a142 1
    int, int (*)(void *), void *, char *);
d145 1
a145 1
    bus_size_t, struct pcmcia_io_handle *);
d148 1
a148 1
    struct pcmcia_io_handle *, int *);
d152 1
a152 1
    struct pcmcia_mem_handle *);
d155 1
a155 1
    struct pcmcia_mem_handle *, bus_addr_t *, int *);
d333 1
d336 2
a337 1
	} else
d339 1
d364 1
a364 1
	printf("[io alloc %x]", size);
d380 1
a380 1
	printf("[io free]");
d436 1
a436 1
	printf("[mem free]");
d481 1
d644 1
d651 1
d739 1
a739 1
	 * The TS102 queues interrupt request, and may trigger an interrupt
@


1.13
log
@Switch sparc to evcount; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.12 2004/05/09 22:02:38 miod Exp $	*/
d142 1
d187 1
d782 10
@


1.12
log
@Replace the event queue with a bit mask of slots needing attention, as
done in stp(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.11 2004/05/04 16:59:31 grange Exp $	*/
d244 1
a244 1
	intr_establish(ra->ra_intr[0].int_pri, &sc->sc_ih, -1);
@


1.11
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.10 2003/07/02 21:32:48 todd Exp $	*/
d3 1
a3 1
 * Copyright (c) 2003, Miodrag Vallat.
a69 1
#include <sys/malloc.h>
a100 17
 * Slot event structure
 */
struct	tslot_event {
	SIMPLEQ_ENTRY(tslot_event) te_q;
	int	te_what;
	int	te_slot;
};

#define	TSLOT_EVENT_INSERT	0
#define	TSLOT_EVENT_REMOVE	1

const char *tslot_event_descr[] = {
	"insertion",
	"removal"
};

/*
d130 1
a130 1
	SIMPLEQ_HEAD(, tslot_event) sc_events;
d156 1
a156 1
int	tslot_queue_event(struct tslot_softc *, int, int);
d254 1
a254 1
	SIMPLEQ_INIT(&sc->sc_events);
d389 2
a390 1
	pih->ioh = (bus_space_handle_t)(td->td_space[TS102_RANGE_IO]);
d450 2
a451 1
	pmh->memh = (bus_space_handle_t)(td->td_space[slot] + addr);
d504 1
a504 1
	/* Pover down the socket to reset it */
d555 1
d607 2
a608 2
	struct tslot_event *te;
	int s;
d613 1
a613 1
		if ((te = SIMPLEQ_FIRST(&sc->sc_events)) == NULL) {
d618 2
a619 2

		SIMPLEQ_REMOVE_HEAD(&sc->sc_events, te_q);
d622 2
a623 1
		if (te->te_slot >= TS102_NUM_SLOTS) {
d626 13
d640 5
a644 19
			td = &sc->sc_slot[te->te_slot];
			switch (te->te_what) {
			case TSLOT_EVENT_INSERT:
				if ((td->td_status & TS_CARD) == 0) {
					td->td_status |= TS_CARD;
					pcmcia_card_attach(td->td_pcmcia);
				}
				break;
			case TSLOT_EVENT_REMOVE:
				if ((td->td_status & TS_CARD) != 0) {
					td->td_status &= ~TS_CARD;
					pcmcia_card_detach(td->td_pcmcia,
					    DETACH_FORCE);
				}
				break;
			default:
				printf("%s: invalid event type %d on slot %d\n",
				    sc->sc_dev.dv_xname,
				    te->te_slot, te->te_what);
a646 1
		free(te, M_TEMP);
d704 2
a705 2
int
tslot_queue_event(struct tslot_softc *sc, int slot, int what)
a706 1
	struct tslot_event *te;
a708 9
	te = malloc(sizeof(*te), M_TEMP, M_NOWAIT);
	if (te == NULL) {
		printf("%s: %s event lost on slot %d\n",
		    sc->sc_dev.dv_xname, tslot_event_descr[what], slot);
		return (ENOMEM);
	}

	te->te_what = what;
	te->te_slot = slot;
d710 1
a710 1
	SIMPLEQ_INSERT_TAIL(&sc->sc_events, te, te_q);
a712 2

	return (0);
d718 1
d724 1
a724 1
	    td->td_parent->sc_dev.dv_xname, td->td_slot, intreg, status);
d739 1
a739 7
		if (status & TS102_CARD_STS_PRES) {
			tslot_queue_event(td->td_parent,
			    td->td_slot, TSLOT_EVENT_INSERT);
		} else {
			tslot_queue_event(td->td_parent, td->td_slot,
			    TSLOT_EVENT_REMOVE);
		}
d742 1
a742 2
		    td->td_parent->sc_dev.dv_xname,
		    td->td_slot, sockstat, td->td_status);
d752 5
a756 1
		if (sockstat != TS_CARD) {
d758 1
a758 1
			    td->td_parent->sc_dev.dv_xname, td->td_slot, intreg);
@


1.10
log
@fix tslot issues (need level-triggered interrupts); from miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.9 2003/06/28 16:40:52 miod Exp $	*/
d634 1
a634 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_events, te, te_q);
@


1.10.4.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * Copyright (c) 2003, 2004, Miodrag Vallat.
d70 1
d102 17
d148 1
a148 1
	unsigned int	sc_events;	/* sockets with pending events */
d174 1
a174 1
void	tslot_queue_event(struct tslot_softc *, int);
d272 1
a272 1
	sc->sc_events = 0;
d407 1
a407 2
	bus_space_subregion(&td->td_rr, td->td_space[TS102_RANGE_IO],
	    offset, size, &pih->ioh);
d467 1
a467 2
	bus_space_subregion(&td->td_rr, td->td_space[slot],
	    addr, size, &pmh->memh);
d520 1
a520 1
	/* Power down the socket to reset it */
a570 1
		/* If the card has been removed, abort */
d622 2
a623 2
	int s, status;
	unsigned int socket;
d628 1
a628 1
		if ((socket = ffs(sc->sc_events)) == 0) {
d633 2
a634 2
		socket--;
		sc->sc_events &= ~(1 << socket);
d637 1
a637 2
		if (socket >= TS102_NUM_SLOTS) {
#ifdef DEBUG
a639 13
#endif
			continue;
		}

		td = &sc->sc_slot[socket];
		status = TSLOT_READ(td, TS102_REG_CARD_A_STS);

		if (status & TS102_CARD_STS_PRES) {
			/* Card insertion */
			if ((td->td_status & TS_CARD) == 0) {
				td->td_status |= TS_CARD;
				pcmcia_card_attach(td->td_pcmcia);
			}
d641 19
a659 5
			/* Card removal */
			if ((td->td_status & TS_CARD) != 0) {
				td->td_status &= ~TS_CARD;
				pcmcia_card_detach(td->td_pcmcia,
				    DETACH_FORCE);
d662 1
d720 2
a721 2
void
tslot_queue_event(struct tslot_softc *sc, int slot)
d723 1
d726 9
d736 1
a736 1
	sc->sc_events |= (1 << slot);
d739 2
a745 1
	struct tslot_softc *sc = td->td_parent;
d751 1
a751 1
	    sc->sc_dev.dv_xname, td->td_slot, intreg, status);
d766 7
a772 1
		tslot_queue_event(sc, td->td_slot);
d775 2
a776 1
		    sc->sc_dev.dv_xname, td->td_slot, sockstat, td->td_status);
d786 1
a786 5
		/* ignore interrupts if we have a pending state change */
		if (sc->sc_events & (1 << td->td_slot))
			return;

		if ((sockstat & TS_CARD) == 0) {
d788 1
a788 1
			    sc->sc_dev.dv_xname, td->td_slot, intreg);
@


1.9
log
@Be more careful when processing interrupts - the TS102 queues them, and we
might get fed an interrupt for a particular condition at a time we are not
expecting this condition anymore...
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.7 2003/06/28 13:30:17 miod Exp $	*/
d557 4
@


1.8
log
@Be prepared to the fact that the user may unplug a card before it was
fully initialized.
@
text
@d752 10
a761 1
	if (intreg & TS102_CARD_INT_STATUS_CARDDETECT_STATUS_CHANGED) {
d780 2
a781 1
	if (intreg & TS102_CARD_INT_STATUS_IRQ) {
d783 2
a784 2
			printf("%s: spurious interrupt on slot %d\n",
			    td->td_parent->sc_dev.dv_xname, td->td_slot);
@


1.7
log
@A better reset sequence; also, probe slots immediately rather than waiting
for the worker thread to be set up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.6 2003/06/25 21:46:25 miod Exp $	*/
d566 6
a571 1
		if (TSLOT_READ(td, TS102_REG_CARD_A_STS) & TS102_CARD_STS_RDY)
@


1.6
log
@We want address incrementation disabled, so correctly ask for it...
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.5 2003/06/25 19:21:19 miod Exp $	*/
d136 1
a136 3
#define	TS_UNKNOWN	-1
#define	TS_EMPTY	0
#define	TS_CARD		1
d304 1
a304 1
	int ctl;
d323 1
a323 1
	 * Reset slot and initialize it
a325 2
	TSLOT_WRITE(td, TS102_REG_CARD_A_INT, TS102_CARD_INT_SOFT_RESET);

d346 6
a351 7
	/*
	 * Force immediate probe - this will depend on the worker
	 * thread, so will not really happen until interrupts are enabled,
	 * which is exactly what we need.
	 */
	td->td_status = TS_UNKNOWN;
	tslot_slot_intr(td, TS102_CARD_INT_STATUS_CARDDETECT_STATUS_CHANGED);
d513 2
a514 1
	int status, i;
d520 10
a532 1
	status = TSLOT_READ(td, TS102_REG_CARD_A_STS);
d536 21
a556 1
	DELAY(200 * 1000);
d585 2
d635 4
a638 1
				pcmcia_card_attach(td->td_pcmcia);
d641 5
a645 1
				pcmcia_card_detach(td->td_pcmcia, DETACH_FORCE);
d749 2
a750 5
			if (sockstat != TS_CARD) {
				if (tslot_queue_event(td->td_parent,
				    td->td_slot, TSLOT_EVENT_INSERT) == 0)
					td->td_status = TS_CARD;
			}
d752 2
a753 4
			if (sockstat != TS_EMPTY &&
			    tslot_queue_event(td->td_parent, td->td_slot,
			      TSLOT_EVENT_REMOVE) == 0)
				td->td_status = TS_EMPTY;
@


1.5
log
@Oops, put back iot/memt affectations in io_alloc/mem_alloc; spotted by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.4 2003/06/25 17:39:00 miod Exp $	*/
d338 1
a338 1
	ctl &= ~TS102_CARD_CTL_INCDIS;
@


1.4
log
@Extend the sparc bus_space_tag_t to store access endianness in it, and
adapt all bus_space functions to do proper endianness conversion whenever
necessary, except for the raw ones.

This allows us to remove the forced endianness conversions in if_wi.

with help from and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.3 2003/06/24 22:55:43 miod Exp $	*/
d384 1
a384 1
	pih->iot = 0;
d434 2
d439 1
a439 1
	pmh->memt = 0;
@


1.3
log
@... and it must compile, too. Doh.
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.2 2003/06/24 22:54:54 miod Exp $	*/
d126 1
a233 1
	struct rom_reg reg;
d286 5
a290 5
			reg = ra->ra_reg[0];
			reg.rr_iospace = range->pspace;
			reg.rr_paddr = (void *)
			   ((u_int32_t)reg.rr_paddr + range->poffset);
			td->td_space[rnum] = (vaddr_t)mapiodev(&reg, 0,
d297 1
d411 1
a411 1
	pih->iot = 0;
d469 1
a469 1
	pmh->memt = 0;
@


1.2
log
@io_alloc must provide working bus_space tag and handles...
@
text
@d1 1
a1 1
/*	$OpenBSD: ts102.c,v 1.1 2003/06/23 09:29:55 miod Exp $	*/
d377 2
@


1.1
log
@Driver for the pcmcia slots in the Tadpole SPARCbook machines.
Currently only tested with wi(4), and there are still some sporadic
"device timeout" issues left - your mileage may vary.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d382 1
a382 1
	pih->ioh = 0;
@

