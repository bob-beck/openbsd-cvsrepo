head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.4
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.4
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.20.0.16
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.14
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.10
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.24
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.23;
commitid	5gdEnqVoJuTuwdTu;

1.23
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.21;
commitid	yM2VFFhpDTeFQlve;

1.21
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.20;
commitid	LS2TNeCue5R9L67C;

1.20
date	2011.04.02.17.47.04;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.03.27.21.40.13;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2010.03.27.20.04.03;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2010.03.22.22.28.27;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.12.16.35.52;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.21.11.27.03;	author fkr;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.24.09.09.15;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.08.12.44.56;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.08.05.36.33;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.27.18.57.19;	author robert;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.16.01.36.25;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.07.21.16.59;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.04.01.05.54;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.28.13.12.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.25.13.50.49;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.25.13.44.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.15.15.39.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.23.55.23;	author millert;	state Exp;
branches;
next	;


desc
@@


1.24
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_atw_cardbus.c,v 1.23 2015/03/14 03:38:47 jsg Exp $	*/
/*	$NetBSD: if_atw_cardbus.c,v 1.9 2004/07/23 07:07:55 dyoung Exp $	*/

/*-
 * Copyright (c) 1999, 2000, 2003 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.  This code was adapted for the ADMtek ADM8211
 * by David Young.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * CardBus bus front-end for the ADMtek ADM8211 802.11 MAC/BBP driver.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h> 
#include <sys/mbuf.h>   
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>
 
#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_radiotap.h>
#include <net80211/ieee80211_var.h>

#if NBPFILTER > 0 
#include <net/bpf.h>
#endif 

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/atwreg.h>
#include <dev/ic/si4136reg.h>
#include <dev/ic/atwvar.h>

#include <dev/pci/pcivar.h>
#include <dev/pci/pcireg.h>
#include <dev/pci/pcidevs.h>

#include <dev/cardbus/cardbusvar.h>

/*
 * PCI configuration space registers used by the ADM8211.
 */
#define	ATW_PCI_IOBA		0x10	/* i/o mapped base */
#define	ATW_PCI_MMBA		0x14	/* memory mapped base */

struct atw_cardbus_softc {
	struct atw_softc sc_atw;	/* real ADM8211 softc */

	/* CardBus-specific goo. */
	void	*sc_ih;			/* interrupt handle */
	cardbus_devfunc_t sc_ct;	/* our CardBus devfuncs */
	pcitag_t sc_tag;		/* our CardBus tag */
	int	sc_csr;			/* CSR bits */
	bus_size_t sc_mapsize;		/* the size of mapped bus space
					   region */

	int	sc_cben;		/* CardBus enables */
	int	sc_bar_reg;		/* which BAR to use */
	pcireg_t sc_bar_val;		/* value of the BAR */

	int	sc_intrline;		/* interrupt line */
	pci_chipset_tag_t sc_pc;
};

int	atw_cardbus_match(struct device *, void *, void *);
void	atw_cardbus_attach(struct device *, struct device *, void *);
int	atw_cardbus_detach(struct device *, int);

struct cfattach atw_cardbus_ca = {
	sizeof(struct atw_cardbus_softc), atw_cardbus_match, atw_cardbus_attach,
	    atw_cardbus_detach
};

void	atw_cardbus_setup(struct atw_cardbus_softc *);

int	atw_cardbus_enable(struct atw_softc *);
void	atw_cardbus_disable(struct atw_softc *);
void	atw_cardbus_power(struct atw_softc *, int);

const struct pci_matchid atw_cardbus_devices[] = {
	{ PCI_VENDOR_ADMTEK, PCI_PRODUCT_ADMTEK_ADM8211 },
	{ PCI_VENDOR_3COM, PCI_PRODUCT_3COM_3CRSHPW796 },
};

int
atw_cardbus_match(struct device *parent, void *match, void *aux)
{
	return (cardbus_matchbyid((struct cardbus_attach_args *)aux,
	    atw_cardbus_devices, nitems(atw_cardbus_devices)));
}

void
atw_cardbus_attach(struct device *parent, struct device *self, void *aux)
{
	struct atw_cardbus_softc *csc = (void *)self;
	struct atw_softc *sc = &csc->sc_atw;
	struct cardbus_attach_args *ca = aux;
	cardbus_devfunc_t ct = ca->ca_ct;
	bus_addr_t adr;

	sc->sc_dmat = ca->ca_dmat;
	csc->sc_ct = ct;
	csc->sc_tag = ca->ca_tag;
	csc->sc_pc = ca->ca_pc;

	/*
	 * Power management hooks.
	 */
	sc->sc_enable = atw_cardbus_enable;
	sc->sc_disable = atw_cardbus_disable;
	sc->sc_power = atw_cardbus_power;

	/* Get revision info. */
	sc->sc_rev = PCI_REVISION(ca->ca_class);

#if 0
	printf(": signature %08x\n%s",
	    pci_conf_read(ca->ca_pc, csc->sc_tag, 0x80),
	    sc->sc_dev.dv_xname);
#endif

	/*
	 * Map the device.
	 */
	csc->sc_csr = PCI_COMMAND_MASTER_ENABLE;
	if (Cardbus_mapreg_map(ct, ATW_PCI_MMBA,
	    PCI_MAPREG_TYPE_MEM, 0, &sc->sc_st, &sc->sc_sh, &adr,
	    &csc->sc_mapsize) == 0) {
#if 0
		printf(": atw_cardbus_attach mapped %d bytes mem space\n%s",
		    csc->sc_mapsize, sc->sc_dev.dv_xname);
#endif
		csc->sc_cben = CARDBUS_MEM_ENABLE;
		csc->sc_csr |= PCI_COMMAND_MEM_ENABLE;
		csc->sc_bar_reg = ATW_PCI_MMBA;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_MEM;
	} else if (Cardbus_mapreg_map(ct, ATW_PCI_IOBA,
	    PCI_MAPREG_TYPE_IO, 0, &sc->sc_st, &sc->sc_sh, &adr,
	    &csc->sc_mapsize) == 0) {
#if 0
		printf(": atw_cardbus_attach mapped %d bytes I/O space\n%s",
		    csc->sc_mapsize, sc->sc_dev.dv_xname);
#endif
		csc->sc_cben = CARDBUS_IO_ENABLE;
		csc->sc_csr |= PCI_COMMAND_IO_ENABLE;
		csc->sc_bar_reg = ATW_PCI_IOBA;
		csc->sc_bar_val = adr | PCI_MAPREG_TYPE_IO;
	} else {
		printf(": unable to map device registers\n");
		return;
	}

	/*
	 * Bring the chip out of powersave mode and initialize the
	 * configuration registers.
	 */
	atw_cardbus_setup(csc);

	/* Remember which interrupt line. */
	csc->sc_intrline = ca->ca_intrline;

	printf(": revision %d.%d: irq %d\n",
	    (sc->sc_rev >> 4) & 0xf, sc->sc_rev & 0xf, csc->sc_intrline);
#if 0
	/*
	 * The CardBus cards will make it to store-and-forward mode as
	 * soon as you put them under any kind of load, so just start
	 * out there.
	 */
	sc->sc_txthresh = 3; /* TBD name constant */
#endif

	/*
	 * Finish off the attach.
	 */
	atw_attach(sc);

	ATW_WRITE(sc, ATW_FER, ATW_FER_INTR);

	/*
	 * Power down the socket.
	 */
	Cardbus_function_disable(csc->sc_ct);
}

int
atw_cardbus_detach(struct device *self, int flags)
{
	struct atw_cardbus_softc *csc = (void *)self;
	struct atw_softc *sc = &csc->sc_atw;
	struct cardbus_devfunc *ct = csc->sc_ct;
	int rv;

#if defined(DIAGNOSTIC)
	if (ct == NULL)
		panic("%s: data structure lacks", sc->sc_dev.dv_xname);
#endif

	rv = atw_detach(sc);
	if (rv)
		return (rv);

	/*
	 * Unhook the interrupt handler.
	 */
	if (csc->sc_ih != NULL)
		cardbus_intr_disestablish(ct->ct_cc, ct->ct_cf, csc->sc_ih);

	/*
	 * Release bus space and close window.
	 */
	if (csc->sc_bar_reg != 0)
		Cardbus_mapreg_unmap(ct, csc->sc_bar_reg,
		    sc->sc_st, sc->sc_sh, csc->sc_mapsize);

	return (0);
}

int
atw_cardbus_enable(struct atw_softc *sc)
{
	struct atw_cardbus_softc *csc = (void *) sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/*
	 * Power on the socket.
	 */
	Cardbus_function_enable(ct);

	/*
	 * Set up the PCI configuration registers.
	 */
	atw_cardbus_setup(csc);

	/*
	 * Map and establish the interrupt.
	 */
	csc->sc_ih = cardbus_intr_establish(cc, cf, csc->sc_intrline, IPL_NET,
	    atw_intr, sc, sc->sc_dev.dv_xname);
	if (csc->sc_ih == NULL) {
		printf("%s: unable to establish interrupt at %d\n",
		    sc->sc_dev.dv_xname, csc->sc_intrline);
		Cardbus_function_disable(csc->sc_ct);
		return (1);
	}

	return (0);
}

void
atw_cardbus_disable(struct atw_softc *sc)
{
	struct atw_cardbus_softc *csc = (void *) sc;
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	cardbus_function_tag_t cf = ct->ct_cf;

	/* Unhook the interrupt handler. */
	cardbus_intr_disestablish(cc, cf, csc->sc_ih);
	csc->sc_ih = NULL;

	/* Power down the socket. */
	Cardbus_function_disable(ct);
}

void
atw_cardbus_power(struct atw_softc *sc, int why)
{
	if (why == DVACT_RESUME)
		atw_enable(sc);
}

void
atw_cardbus_setup(struct atw_cardbus_softc *csc)
{
#ifdef notyet
	struct atw_softc *sc = &csc->sc_atw;
#endif
	cardbus_devfunc_t ct = csc->sc_ct;
	cardbus_chipset_tag_t cc = ct->ct_cc;
	pci_chipset_tag_t pc = csc->sc_pc;
	pcireg_t reg;

#ifdef notyet
	(void)cardbus_setpowerstate(sc->sc_dev.dv_xname, ct, csc->sc_tag,
	    PCI_PWR_D0);
#endif

	/* Program the BAR. */
	pci_conf_write(pc, csc->sc_tag, csc->sc_bar_reg,
	    csc->sc_bar_val);

	/* Make sure the right access type is on the CardBus bridge. */
	(*ct->ct_cf->cardbus_ctrl)(cc, csc->sc_cben);
	(*ct->ct_cf->cardbus_ctrl)(cc, CARDBUS_BM_ENABLE);

	/* Enable the appropriate bits in the PCI CSR. */
	reg = pci_conf_read(pc, csc->sc_tag,
	    PCI_COMMAND_STATUS_REG);
	reg &= ~(PCI_COMMAND_IO_ENABLE|PCI_COMMAND_MEM_ENABLE);
	reg |= csc->sc_csr;
	pci_conf_write(pc, csc->sc_tag, PCI_COMMAND_STATUS_REG,
	    reg);

	/*
	 * Make sure the latency timer is set to some reasonable
	 * value.
	 */
	reg = pci_conf_read(pc, csc->sc_tag, PCI_BHLC_REG);
	if (PCI_LATTIMER(reg) < 0x20) {
		reg &= ~(PCI_LATTIMER_MASK << PCI_LATTIMER_SHIFT);
		reg |= (0x20 << PCI_LATTIMER_SHIFT);
		pci_conf_write(pc, csc->sc_tag, PCI_BHLC_REG, reg);
	}
}
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.22 2014/12/22 02:28:51 tedu Exp $	*/
a52 1
#include <net/if_dl.h>
@


1.22
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.21 2014/12/19 22:44:58 guenther Exp $	*/
a69 1
#include <dev/ic/rf3000reg.h>
@


1.21
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.20 2011/04/02 17:47:04 jasper Exp $	*/
a55 1
#ifdef INET
a57 1
#endif
@


1.20
log
@- use nitems(); no binary change@@

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.19 2010/09/06 19:20:21 deraadt Exp $	*/
d50 1
a50 2

#include <machine/endian.h>
@


1.19
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.18 2010/03/27 21:40:13 jsg Exp $	*/
d132 1
a132 2
	    atw_cardbus_devices,
	    sizeof(atw_cardbus_devices)/sizeof(atw_cardbus_devices[0])));
@


1.18
log
@Give cardbus the pci_chipset_tag_t from pccbb and push it out through
cardbus_attach_args so we can switch to using proper pci config
space functions instead of callback based wrappers.

ok oga@@ krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.17 2010/03/27 20:04:03 jsg Exp $	*/
d315 1
a315 1
	if (why == PWR_RESUME)
@


1.17
log
@Bring back cardbus_chipset_tag_t which is in practice a
pointer to the pccbb softc, to distinguish it from a pci_chipset_tag_t
which can be passed to the normal pci functions.

Suggested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.16 2010/03/22 22:28:27 jsg Exp $	*/
d105 1
d148 1
d162 1
a162 1
	    cardbus_conf_read(ct->ct_cc, ct->ct_cf, csc->sc_tag, 0x80),
d327 1
a327 1
	cardbus_function_tag_t cf = ct->ct_cf;
d336 1
a336 1
	cardbus_conf_write(cc, cf, csc->sc_tag, csc->sc_bar_reg,
d344 1
a344 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag,
d348 1
a348 1
	cardbus_conf_write(cc, cf, csc->sc_tag, PCI_COMMAND_STATUS_REG,
d355 1
a355 1
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, PCI_BHLC_REG);
d359 1
a359 1
		cardbus_conf_write(cc, cf, csc->sc_tag, PCI_BHLC_REG, reg);
@


1.16
log
@Remove some cardbus defines and types which are identical to
their pci counterparts, similar to recent changes in NetBSD.

ok oga@@ deraadt@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.15 2008/06/26 05:42:14 ray Exp $	*/
d266 1
a266 1
	pci_chipset_tag_t cc = ct->ct_cc;
d299 1
a299 1
	pci_chipset_tag_t cc = ct->ct_cc;
d324 1
a324 1
	pci_chipset_tag_t cc = ct->ct_cc;
@


1.15
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.14 2006/10/12 16:35:52 grange Exp $	*/
d95 1
a95 1
	cardbustag_t sc_tag;		/* our CardBus tag */
d122 1
a122 1
const struct cardbus_matchid atw_cardbus_devices[] = {
d167 1
a167 1
	csc->sc_csr = CARDBUS_COMMAND_MASTER_ENABLE;
d169 1
a169 1
	    CARDBUS_MAPREG_TYPE_MEM, 0, &sc->sc_st, &sc->sc_sh, &adr,
d176 1
a176 1
		csc->sc_csr |= CARDBUS_COMMAND_MEM_ENABLE;
d178 1
a178 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_MEM;
d180 1
a180 1
	    CARDBUS_MAPREG_TYPE_IO, 0, &sc->sc_st, &sc->sc_sh, &adr,
d187 1
a187 1
		csc->sc_csr |= CARDBUS_COMMAND_IO_ENABLE;
d189 1
a189 1
		csc->sc_bar_val = adr | CARDBUS_MAPREG_TYPE_IO;
d266 1
a266 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d299 1
a299 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d324 1
a324 1
	cardbus_chipset_tag_t cc = ct->ct_cc;
d343 2
a344 2
	    CARDBUS_COMMAND_STATUS_REG);
	reg &= ~(CARDBUS_COMMAND_IO_ENABLE|CARDBUS_COMMAND_MEM_ENABLE);
d346 1
a346 1
	cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_COMMAND_STATUS_REG,
d353 5
a357 5
	reg = cardbus_conf_read(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG);
	if (CARDBUS_LATTIMER(reg) < 0x20) {
		reg &= ~(CARDBUS_LATTIMER_MASK << CARDBUS_LATTIMER_SHIFT);
		reg |= (0x20 << CARDBUS_LATTIMER_SHIFT);
		cardbus_conf_write(cc, cf, csc->sc_tag, CARDBUS_BHLC_REG, reg);
@


1.14
log
@Add a symbolic name parameter to cardbus_intr_establish().
Count cardbus devices interrupts in cbb(4) using evcount(9).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.13 2006/06/21 11:27:03 fkr Exp $	*/
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.13
log
@removal of '#ifdef rbus ... #else ...' directives, we use rbus in all
cases anyways, so we might as well remove code (the !rbus case) thats been
dead throughout the last years and just use the rbus code without ifdefs.

brad, miod "I am all for this diff"
ok deraadt, mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.12 2005/09/24 09:09:15 jsg Exp $	*/
d290 1
a290 1
	    atw_intr, sc);
@


1.12
log
@Make atw_cardbus_power() not tell us its name every time it is called...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.11 2005/09/08 12:44:56 jsg Exp $	*/
a181 4
#if rbus
#else
		(*ct->ct_cf->cardbus_mem_open)(cc, 0, adr, adr+csc->sc_mapsize);
#endif
a191 4
#endif
#if rbus
#else
		(*ct->ct_cf->cardbus_io_open)(cc, 0, adr, adr+csc->sc_mapsize);
@


1.11
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.10 2005/06/08 05:36:33 henning Exp $	*/
a327 2
	printf("%s: atw_cardbus_power\n", sc->sc_dev.dv_xname);

@


1.10
log
@useless netns includes; there was no NS stuff ever here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.9 2005/05/27 18:57:19 robert Exp $	*/
a68 1
#include <net80211/ieee80211_compat.h>
@


1.9
log
@make sure to enable socket on resume.
in order for the enable to work disable the socket on suspend.
lot of help from mickey@@

ok jsg@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.8 2005/05/16 01:36:25 brad Exp $	*/
a75 5

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif
@


1.8
log
@Use cardbus_matchbyid().

ok millert@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.7 2004/10/07 21:16:59 brad Exp $	*/
a333 2
	struct atw_cardbus_softc *csc = (void *) sc;

d336 2
a337 11
	if (why == PWR_RESUME) {
		/*
		 * Give the PCI configuration registers a kick
		 * in the head.
		 */
#ifdef DIAGNOSTIC
		if (ATW_IS_ENABLED(sc) == 0)
			panic("atw_cardbus_power");
#endif
		atw_cardbus_setup(csc);
	}
@


1.7
log
@cardbusdevs -> pcidevs

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.6 2004/08/04 01:05:54 millert Exp $	*/
d135 3
a137 15
const struct atw_cardbus_product *atw_cardbus_lookup
   (const struct cardbus_attach_args *);

const struct atw_cardbus_product {
	u_int32_t	 acp_vendor;	/* PCI vendor ID */
	u_int32_t	 acp_product;	/* PCI product ID */
	const char	*acp_product_name;
} atw_cardbus_products[] = {
	{ PCI_VENDOR_ADMTEK,		PCI_PRODUCT_ADMTEK_ADM8211,
	  "ADMtek ADM8211 802.11 MAC/BBP" },

	{ PCI_VENDOR_3COM,		PCI_PRODUCT_3COM_3CRSHPW796,
	  "3Com 3CRSHPW796 802.11b" },

	{ 0,				0,	NULL },
a139 15
const struct atw_cardbus_product *
atw_cardbus_lookup(const struct cardbus_attach_args *ca)
{
	const struct atw_cardbus_product *acp;

	for (acp = atw_cardbus_products;
	     acp->acp_product_name != NULL;
	     acp++) {
		if (PCI_VENDOR(ca->ca_id) == acp->acp_vendor &&
		    PCI_PRODUCT(ca->ca_id) == acp->acp_product)
			return (acp);
	}
	return (NULL);
}

d143 3
a145 6
	struct cardbus_attach_args *ca = aux;

	if (atw_cardbus_lookup(ca) != NULL)
		return (1);

	return (0);
a154 1
	const struct atw_cardbus_product *acp;
a160 6
	acp = atw_cardbus_lookup(ca);
	if (acp == NULL) {
		printf("\n");
		panic("atw_cardbus_attach: impossible");
	}

d225 1
a225 1
	printf(": %s, revision %d.%d: irq %d\n", acp->acp_product_name,
@


1.6
log
@Fix printing of revision string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.5 2004/07/28 13:12:29 millert Exp $	*/
a94 1
#include <dev/cardbus/cardbusdevs.h>
@


1.5
log
@3Com OfficeConnect 3CRSHPW796 Cardbus card is atw(4) rev 1.5.
Patch based on info from Sigfred Håversen and David Young.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.4 2004/07/25 13:50:49 millert Exp $	*/
a208 3
	printf(": %s, revision %d.%d\n", acp->acp_product_name,
	    (sc->sc_rev >> 4) & 0xf, sc->sc_rev & 0xf);

d263 2
a264 1
	printf(": %s: irq %d\n", acp->acp_product_name, csc->sc_intrline);
@


1.4
log
@Store pci/cardbus revision number.  From NetBSD (dyoung)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atw_cardbus.c,v 1.3 2004/07/25 13:44:22 millert Exp $	*/
d146 3
@


1.3
log
@Program BARs before enabling memory or I/O access.  From NetBSD (mycroft).
@
text
@d1 2
a2 2
/*	$OpenBSD: if_atw_cardbus.c,v 1.2 2004/07/15 15:39:41 millert Exp $	*/
/*	$NetBSD: if_atw_cardbus.c,v 1.8 2004/07/22 15:50:50 dyoung Exp $	*/
a184 1
	int rev;
d204 4
a207 1
	rev = PCI_REVISION(ca->ca_class);
d210 1
a210 1
	printf(": pass %d.%d signature %08x\n%s", (rev >> 4) & 0xf, rev & 0xf,
@


1.2
log
@kill sc_intr_ack
@
text
@d1 2
a2 2
/*	$OpenBSD: if_atw_cardbus.c,v 1.1 2004/06/22 23:55:23 millert Exp $	*/
/*	$NetBSD: if_atw_cardbus.c,v 1.7 2004/05/08 23:40:01 dyoung Exp $	*/
d402 4
a408 4

	/* Program the BAR. */
	cardbus_conf_write(cc, cf, csc->sc_tag, csc->sc_bar_reg,
	    csc->sc_bar_val);
@


1.1
log
@atw(4) driver from NetBSD (dyoung).  Based in part on a port by
Matthew Gream.

Unfortunately, the adm8211 card I have with me does not work correctly
with the driver yet so real testing will have to wait until I get
my hands on an adm8211-based DWL-650 or something similar.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a135 2
void	atw_cardbus_intr_ack(struct atw_softc *);

a203 2
	sc->sc_intr_ack = atw_cardbus_intr_ack;

a281 6
}

void
atw_cardbus_intr_ack(struct atw_softc *sc)
{
	ATW_WRITE(sc, ATW_FER, ATW_FER_INTR);
@

