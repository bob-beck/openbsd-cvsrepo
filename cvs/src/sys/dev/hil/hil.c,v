head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.10
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.6
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.26.0.4
	OPENBSD_5_8_BASE:1.26
	OPENBSD_5_7:1.25.0.8
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.12
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.10
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.8
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.23.0.16
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.12
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.14
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.10
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.8
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC:1.9.0.4
	UBC_SYNC_A:1.9
	SMP:1.9.0.2
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.26
date	2015.05.15.13.32.08;	author jsg;	state Exp;
branches;
next	1.25;
commitid	Kj1U6D4ZSxqF8U53;

1.25
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.11.20.16.45.46;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.16.20.07.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.05.14.39.32;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.22.07.09.52;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.13.15.22.37;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.08.11.38.09;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.08.04.39.40;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.15.19.48.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.11.00.11.05;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.09.23.49.35;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.10.05.18.53;	author jolan;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.12.20.29.12;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.21.10.29.44;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.27.07.01.55;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.28.00.20.03;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2003.03.16.02.01.15;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.26.20.22.03;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.19.00.03.30;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.18.02.40.51;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.15.23.45.52;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.15.23.42.48;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.15.23.38.46;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.11.19.40.20;	author miod;	state Exp;
branches;
next	;

1.9.2.1
date	2003.04.19.19.17.49;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.26
log
@add some missing splx() calls
ok deraadt@@ kettenis@@ krw@@
@
text
@/*	$OpenBSD: hil.c,v 1.25 2013/11/18 20:21:51 deraadt Exp $	*/
/*
 * Copyright (c) 2003, 2004, Miodrag Vallat.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: hil.c 1.38 92/01/21$
 *
 *	@@(#)hil.c	8.2 (Berkeley) 1/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/kthread.h>

#include <machine/autoconf.h>
#include <machine/bus.h>
#include <machine/cpu.h>

#include <dev/hil/hilreg.h>
#include <dev/hil/hilvar.h>
#include <dev/hil/hildevs.h>
#include <dev/hil/hildevs_data.h>

#include "hilkbd.h"

/*
 * splhigh is extremely conservative but insures atomic operation,
 * splvm (clock only interrupts) seems to be good enough in practice.
 */
#define	splhil	splvm

struct cfdriver hil_cd = {
	NULL, "hil", DV_DULL
};

void	hilconfig(struct hil_softc *, u_int);
void	hilempty(struct hil_softc *);
int	hilsubmatch(struct device *, void *, void *);
void	hil_process_int(struct hil_softc *, u_int8_t, u_int8_t);
int	hil_process_poll(struct hil_softc *, u_int8_t, u_int8_t);
void	hil_thread(void *);
int	send_device_cmd(struct hil_softc *sc, u_int device, u_int cmd);
void	polloff(struct hil_softc *);
void	pollon(struct hil_softc *);

static int hilwait(struct hil_softc *);
static int hildatawait(struct hil_softc *);

#define	hil_process_pending(sc)	wakeup(&(sc)->sc_pending)

static __inline int
hilwait(struct hil_softc *sc)
{
	int cnt;

	for (cnt = 50000; cnt != 0; cnt--) {
		DELAY(1);
		if ((bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) &
		    HIL_BUSY) == 0)
			break;
	}

	return (cnt);
}

static __inline int
hildatawait(struct hil_softc *sc)
{
	int cnt;

	for (cnt = 50000; cnt != 0; cnt--) {
		DELAY(1);
		if ((bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) &
		    HIL_DATA_RDY) != 0)
			break;
	}

	return (cnt);
}

/*
 * Common HIL bus attachment
 */

void
hil_attach(struct hil_softc *sc, int *hil_is_console)
{
	printf("\n");

	/*
	 * Initialize loop information
	 */
	sc->sc_cmdending = 0;
	sc->sc_actdev = sc->sc_cmddev = 0;
	sc->sc_cmddone = 0;
	sc->sc_cmdbp = sc->sc_cmdbuf;
	sc->sc_pollbp = sc->sc_pollbuf;
	sc->sc_console = hil_is_console;
}

/*
 * HIL subdevice attachment
 */

int
hildevprint(void *aux, const char *pnp)
{
	struct hil_attach_args *ha = aux;

	if (pnp != NULL) {
		printf("\"%s\" at %s id %x",
		    ha->ha_descr, pnp, ha->ha_id);
	}
	printf(" code %d", ha->ha_code);
	if (pnp == NULL) {
		printf(": %s", ha->ha_descr);
	}

	return (UNCONF);
}

int
hilsubmatch(struct device *parent, void *vcf, void *aux)
{
	struct hil_attach_args *ha = aux;
	struct cfdata *cf = vcf;

	if (cf->cf_loc[0] != -1 &&
	    cf->cf_loc[0] != ha->ha_code)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, vcf, aux));
}

void
hil_attach_deferred(void *v)
{
	struct hil_softc *sc = v;
	int tries;
	u_int8_t db;

	sc->sc_status = HIL_STATUS_BUSY;

	/*
	 * Initialize the loop: reconfigure, don't report errors,
	 * put keyboard in cooked mode, and enable autopolling.
	 */
	db = LPC_RECONF | LPC_KBDCOOK | LPC_NOERROR | LPC_AUTOPOLL;
	send_hil_cmd(sc, HIL_WRITELPCTRL, &db, 1, NULL);

	/*
	 * Delay one second for reconfiguration and then read the
	 * data to clear the interrupt (if the loop reconfigured).
	 */
	DELAY(1000000);
	if (bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) &
	    HIL_DATA_RDY) {
		db = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
		DELAY(1);
	}

	/*
	 * The HIL loop may have reconfigured.  If so we proceed on,
	 * if not we loop a few times until a successful reconfiguration
	 * is reported back to us. If the HIL loop is still lost after a
	 * few seconds, give up.
	 */
	for (tries = 10; tries != 0; tries--) {
		if (send_hil_cmd(sc, HIL_READLPSTAT, NULL, 0, &db) == 0) {
			if (db & (LPS_CONFFAIL | LPS_CONFGOOD))
				break;
		}

#ifdef HILDEBUG
		printf("%s: loop not ready, retrying...\n",
		    sc->sc_dev.dv_xname);
#endif

		DELAY(1000000);
        }

	if (tries == 0 || (db & LPS_CONFFAIL)) {
		printf("%s: no devices\n", sc->sc_dev.dv_xname);
		sc->sc_pending = 0;
		if (tries == 0)
			return;
	}

	/*
	 * Create asynchronous loop event handler thread.
	 */
	if (kthread_create(hil_thread, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname) != 0) {
		printf("%s: unable to create event thread\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Enable loop interrupts.
	 */
	send_hil_cmd(sc, HIL_INTON, NULL, 0, NULL);

	/*
	 * Reconfigure if necessary
	 */
	sc->sc_status = HIL_STATUS_READY;
	hil_process_pending(sc);
}

/*
 * Asynchronous event processing
 */

int
hil_intr(void *v)
{
	struct hil_softc *sc = v;
	u_int8_t c, stat;

	if (cold)
		return (0);

	stat = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT);

	/*
	 * This should never happen if the interrupt comes from the
	 * loop.
	 */
	if ((stat & HIL_DATA_RDY) == 0)
		return (0);	/* not for us */

	c = bus_space_read_1(sc->sc_bst, sc->sc_bsh,
	    HILP_DATA);	/* clears interrupt */
	DELAY(1);

	hil_process_int(sc, stat, c);

	if (sc->sc_status != HIL_STATUS_BUSY)
		hil_process_pending(sc);

	return (1);
}

void
hil_process_int(struct hil_softc *sc, u_int8_t stat, u_int8_t c)
{
	struct hildev_softc *dev;

	switch ((stat >> HIL_SSHIFT) & HIL_SMASK) {
	case HIL_STATUS:
		if (c & HIL_ERROR) {
		  	sc->sc_cmddone = 1;
			switch (c) {
			case HIL_RECONFIG:
				sc->sc_pending = HIL_PENDING_RECONFIG;
				break;
			case HIL_UNPLUGGED:
				sc->sc_pending = HIL_PENDING_UNPLUGGED;
				break;
			}
			break;
		}
		if (c & HIL_COMMAND) {
		  	if (c & HIL_POLLDATA) {	/* End of data */
				dev = sc->sc_devices[sc->sc_actdev];
				if (dev != NULL && dev->sc_fn != NULL)
					dev->sc_fn(dev,
					    sc->sc_pollbp - sc->sc_pollbuf,
					    sc->sc_pollbuf);
			} else {		/* End of command */
			  	sc->sc_cmdending = 1;
			}
			sc->sc_actdev = 0;
		} else {
		  	if (c & HIL_POLLDATA) {	/* Start of polled data */
				sc->sc_actdev = (c & HIL_DEVMASK);
				sc->sc_pollbp = sc->sc_pollbuf;
			} else {		/* Start of command */
				if (sc->sc_cmddev == (c & HIL_DEVMASK)) {
					sc->sc_cmdbp = sc->sc_cmdbuf;
					sc->sc_actdev = 0;
				}
			}
		}
	        break;
	case HIL_DATA:
		if (sc->sc_actdev != 0)	/* Collecting poll data */
			*sc->sc_pollbp++ = c;
		else {
			if (sc->sc_cmddev != 0) {  /* Collecting cmd data */
				if (sc->sc_cmdending) {
					sc->sc_cmddone = 1;
					sc->sc_cmdending = 0;
				} else  
					*sc->sc_cmdbp++ = c;
		        }
		}
		break;
	}
}

/*
 * Same as above, but in polled mode: return data as it gets seen, instead
 * of buffering it.
 */
int
hil_process_poll(struct hil_softc *sc, u_int8_t stat, u_int8_t c)
{
	u_int8_t db;

	switch ((stat >> HIL_SSHIFT) & HIL_SMASK) {
	case HIL_STATUS:
		if (c & HIL_ERROR) {
		  	sc->sc_cmddone = 1;
			switch (c) {
			case HIL_RECONFIG:
				/*
				 * Remember that a configuration event
				 * occurred; it will be processed upon
				 * leaving polled mode...
				 */
				sc->sc_pending = HIL_PENDING_RECONFIG;
				/*
				 * However, the keyboard will come back as
				 * cooked, and we rely on it being in raw
				 * mode. So, put it back in raw mode right
				 * now.
				 */
				db = 0;
				send_hil_cmd(sc, HIL_WRITEKBDSADR, &db,
				    1, NULL);
				break;
			case HIL_UNPLUGGED:
				/*
				 * Remember that an unplugged event
				 * occured; it will be processed upon
				 * leaving polled mode...
				 */
				sc->sc_pending = HIL_PENDING_UNPLUGGED;
				break;
			}
			break;
		}
		if (c & HIL_COMMAND) {
		  	if (!(c & HIL_POLLDATA)) {
				/* End of command */
			  	sc->sc_cmdending = 1;
			}
			sc->sc_actdev = 0;
		} else {
		  	if (c & HIL_POLLDATA) {
				/* Start of polled data */
				sc->sc_actdev = (c & HIL_DEVMASK);
				sc->sc_pollbp = sc->sc_pollbuf;
			} else {
				/* Start of command - should not happen */
				if (sc->sc_cmddev == (c & HIL_DEVMASK)) {
					sc->sc_cmdbp = sc->sc_cmdbuf;
					sc->sc_actdev = 0;
				}
			}
		}
	        break;
	case HIL_DATA:
		if (sc->sc_actdev != 0)	/* Collecting poll data */
			return 1;
		else {
			if (sc->sc_cmddev != 0) {  /* Discarding cmd data */
				if (sc->sc_cmdending) {
					sc->sc_cmddone = 1;
					sc->sc_cmdending = 0;
				}
		        }
		}
		break;
	}

	return 0;
}

void
hil_thread(void *arg)
{
	struct hil_softc *sc = arg;
	int s;

	for (;;) {
		s = splhil();
		if (sc->sc_pending == 0) {
			splx(s);
			(void)tsleep(&sc->sc_pending, PWAIT, "hil_event", 0);
			continue;
		}

		switch (sc->sc_pending) {
		case HIL_PENDING_RECONFIG:
			sc->sc_pending = 0;
			hilconfig(sc, sc->sc_maxdev);
			break;
		case HIL_PENDING_UNPLUGGED:
			sc->sc_pending = 0;
			hilempty(sc);
			break;
		}
		splx(s);
	}
}

/*
 * Called after the loop has reconfigured.  Here we need to:
 *	- determine how many devices are on the loop
 *	  (some may have been added or removed)
 *	- make sure all keyboards are in raw mode
 *
 * Note that our device state is now potentially invalid as
 * devices may no longer be where they were.  What we should
 * do here is either track where the devices went and move
 * state around accordingly...
 *
 * Note that it is necessary that we operate the loop with the keyboards
 * in raw mode: they won't cause the loop to generate an NMI if the
 * ``reset'' key combination is pressed, and we do not handle the hil
 * NMI interrupt...
 */
void
hilconfig(struct hil_softc *sc, u_int knowndevs)
{
	struct hil_attach_args ha;
	u_int8_t db;
	int id, s;

	s = splhil();

	/*
	 * Determine how many devices are on the loop.
	 */
	db = 0;
	send_hil_cmd(sc, HIL_READLPSTAT, NULL, 0, &db);
	sc->sc_maxdev = db & LPS_DEVMASK;
#ifdef HILDEBUG
	printf("%s: %d device(s)\n", sc->sc_dev.dv_xname, sc->sc_maxdev);
#endif

	/*
	 * Put all keyboards in raw mode now.
	 */
	db = 0;
	send_hil_cmd(sc, HIL_WRITEKBDSADR, &db, 1, NULL);

	/*
	 * If the loop grew, attach new devices.
	 */
	for (id = knowndevs + 1; id <= sc->sc_maxdev; id++) {
		int len;
		const struct hildevice *hd;
		
		if (send_device_cmd(sc, id, HIL_IDENTIFY) != 0) {
			printf("%s: no answer from device %d\n",
			    sc->sc_dev.dv_xname, id);
			continue;
		}

		len = sc->sc_cmdbp - sc->sc_cmdbuf;
		if (len == 0) {
#ifdef HILDEBUG
			printf("%s: no device at code %d\n",
			    sc->sc_dev.dv_xname, id);
#endif
			continue;
		}

		/* Identify and attach device */
		for (hd = hildevs; hd->minid >= 0; hd++)
			if (sc->sc_cmdbuf[0] >= hd->minid &&
			    sc->sc_cmdbuf[0] <= hd->maxid) {

			ha.ha_console = *sc->sc_console;
			ha.ha_code = id;
			ha.ha_type = hd->type;
			ha.ha_descr = hd->descr;
			ha.ha_infolen = len;
			bcopy(sc->sc_cmdbuf, ha.ha_info, len);

			sc->sc_devices[id] = (struct hildev_softc *)
			    config_found_sm(&sc->sc_dev, &ha, hildevprint,
			        hilsubmatch);

#if NHILKBD > 0
			/*
			 * If we just attached a keyboard as console,
			 * console choice is not indeterminate anymore.
			 */
			if (sc->sc_devices[id] != NULL &&
			    ha.ha_type == HIL_DEVICE_KEYBOARD &&
			    ha.ha_console != 0)
				*sc->sc_console = 1;
#endif
		}
	}

	/*
	 * Detach remaining devices, if the loop has shrunk.
	 */
	for (id = sc->sc_maxdev + 1; id < NHILD; id++) {
		if (sc->sc_devices[id] != NULL)
			config_detach((struct device *)sc->sc_devices[id],
			    DETACH_FORCE);
		sc->sc_devices[id] = NULL;
	}

	sc->sc_cmdbp = sc->sc_cmdbuf;

	splx(s);
}

/*
 * Called after the loop has been unplugged. We simply force detach of
 * all our children.
 */
void
hilempty(struct hil_softc *sc)
{
	u_int8_t db;
	int id, s;
	u_int oldmaxdev;

	s = splhil();

	/*
	 * Wait for the loop to be stable.
	 */
	for (;;) {
		if (send_hil_cmd(sc, HIL_READLPSTAT, NULL, 0, &db) == 0) {
			if (db & (LPS_CONFFAIL | LPS_CONFGOOD))
				break;
		} else {
			db = LPS_CONFFAIL;
			break;
		}
	}

	if (db & LPS_CONFFAIL) {
		sc->sc_maxdev = 0;
	} else {
		db = 0;
		send_hil_cmd(sc, HIL_READLPSTAT, NULL, 0, &db);
		oldmaxdev = sc->sc_maxdev;
		sc->sc_maxdev = db & LPS_DEVMASK;

		if (sc->sc_maxdev != 0) {
			/*
			 * The loop was not unplugged after all, but its
			 * configuration has changed.
			 */
			hilconfig(sc, oldmaxdev);
			splx(s);
			return;
		}
	}

	/*
	 * Now detach all hil devices.
	 */
	for (id = sc->sc_maxdev + 1; id < NHILD; id++) {
		if (sc->sc_devices[id] != NULL)
			config_detach((struct device *)sc->sc_devices[id],
			    DETACH_FORCE);
		sc->sc_devices[id] = NULL;
	}

	sc->sc_cmdbp = sc->sc_cmdbuf;

	splx(s);
}

/*
 * Low level routines which actually talk to the 8042 chip.
 */

/*
 * Send a command to the 8042 with zero or more bytes of data.
 * If rdata is non-null, wait for and return a byte of data.
 */
int
send_hil_cmd(struct hil_softc *sc, u_int cmd, u_int8_t *data, u_int dlen,
    u_int8_t *rdata)
{
	u_int8_t status;
	int s;
	
	s = splhil();

	if (hilwait(sc) == 0) {
#ifdef HILDEBUG
		printf("%s: no answer from the loop\n", sc->sc_dev.dv_xname);
#endif
		splx(s);
		return (EBUSY);
	}

	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, cmd);
	while (dlen--) {
	  	hilwait(sc);
		bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, *data++);
		DELAY(1);
	}
	if (rdata) {
		do {
			if (hildatawait(sc) == 0) {
#ifdef HILDEBUG
				printf("%s: no answer from the loop\n",
				    sc->sc_dev.dv_xname);
#endif
				break;
			}
			status = bus_space_read_1(sc->sc_bst, sc->sc_bsh,
			    HILP_STAT);
			*rdata = bus_space_read_1(sc->sc_bst, sc->sc_bsh,
			    HILP_DATA);
			DELAY(1);
		} while (((status >> HIL_SSHIFT) & HIL_SMASK) != HIL_68K);
	}
	splx(s);
	return (0);
}

/*
 * Send a command to a device on the loop.
 * Since only one command can be active on the loop at any time,
 * we must ensure that we are not interrupted during this process.
 * Hence we mask interrupts to prevent potential access from most
 * interrupt routines and turn off auto-polling to disable the
 * internally generated poll commands.
 * Needs to be called at splhil().
 */
int
send_device_cmd(struct hil_softc *sc, u_int device, u_int cmd)
{
	u_int8_t status, c;
	int rc = 0;

	polloff(sc);

	sc->sc_cmdbp = sc->sc_cmdbuf;
	sc->sc_cmddev = device;

	if (hilwait(sc) == 0) {
#ifdef HILDEBUG
		printf("%s: no answer from device %d\n",
		    sc->sc_dev.dv_xname, device);
#endif
		rc = EBUSY;
		goto out;
	}

	/*
	 * Transfer the command and device info to the chip
	 */
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_STARTCMD);
  	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, 8 + device);
  	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, cmd);
  	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, HIL_TIMEOUT);

	/*
	 * Trigger the command and wait for completion
	 */
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_TRIGGER);
	sc->sc_cmddone = 0;
	do {
		if (hildatawait(sc) == 0) {
#ifdef HILDEBUG
			printf("%s: no answer from device %d\n",
			    sc->sc_dev.dv_xname, device);
#endif
			rc = EBUSY;
			break;
		}
		status = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT);
		c = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
		DELAY(1);
		hil_process_int(sc, status, c);
	} while (sc->sc_cmddone == 0);
out:
	sc->sc_cmddev = 0;

	pollon(sc);
	return (rc);
}

int
send_hildev_cmd(struct hildev_softc *dev, u_int cmd,
    u_int8_t *outbuf, u_int *outlen)
{
	struct hil_softc *sc = (struct hil_softc *)dev->sc_dev.dv_parent;
	int s, rc;
       
	s = splhil();

	if ((rc = send_device_cmd(sc, dev->sc_code, cmd)) == 0) {
		/*
		 * Return the command response in the buffer if necessary
	 	*/
		if (outbuf != NULL && outlen != NULL) {
			*outlen = min(*outlen, sc->sc_cmdbp - sc->sc_cmdbuf);
			bcopy(sc->sc_cmdbuf, outbuf, *outlen);
		}
	}

	splx(s);
	return (rc);
}

/*
 * Turn auto-polling off and on.
 */
void
polloff(struct hil_softc *sc)
{
	u_int8_t db;

	if (hilwait(sc) == 0)
		return;

	/*
	 * Turn off auto repeat
	 */
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_SETARR);
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, 0);

	/*
	 * Turn off auto-polling
	 */
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_READLPCTRL);
	hildatawait(sc);
	db = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
	db &= ~LPC_AUTOPOLL;
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_WRITELPCTRL);
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, db);

	/*
	 * Must wait until polling is really stopped
	 */
	do {	
		hilwait(sc);
		bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_READBUSY);
		hildatawait(sc);
		db = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
	} while (db & BSY_LOOPBUSY);

	sc->sc_cmddone = 0;
	sc->sc_cmddev = 0;
}

void
pollon(struct hil_softc *sc)
{
	u_int8_t db;

	if (hilwait(sc) == 0)
		return;

	/*
	 * Turn on auto polling
	 */
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_READLPCTRL);
	hildatawait(sc);
	db = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
	db |= LPC_AUTOPOLL;
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_WRITELPCTRL);
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, db);

	/*
	 * Turn off auto repeat - we emulate this through wscons
	 */
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_CMD, HIL_SETARR);
	hilwait(sc);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, HILP_DATA, 0);
	DELAY(1);
}

void
hil_set_poll(struct hil_softc *sc, int on)
{
	if (on) {
		pollon(sc);
	} else {
		hil_process_pending(sc);
		send_hil_cmd(sc, HIL_INTON, NULL, 0, NULL);
	}
}

int
hil_poll_data(struct hildev_softc *dev, u_int8_t *stat, u_int8_t *data)
{
	struct hil_softc *sc = (struct hil_softc *)dev->sc_dev.dv_parent;
	u_int8_t s, c;

	s = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT);
	if ((s & HIL_DATA_RDY) == 0)
		return -1;

	c = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
	DELAY(1);

	if (hil_process_poll(sc, s, c)) {
		/* Discard any data not for us */
		if (sc->sc_actdev == dev->sc_code) {
			*stat = s;
			*data = c;
			return 0;
		}
	}

	return -1;
}
@


1.25
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.24 2010/11/20 16:45:46 miod Exp $	*/
d619 1
@


1.24
log
@Missing splx() in hil_thread(). This turned out to be harmless due to the
way this code works (always ends up in tsleep eventually), but it never hurts
to be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.23 2006/12/16 20:07:13 miod Exp $	*/
d255 1
a255 1
	    "%s", sc->sc_dev.dv_xname) != 0) {
@


1.23
log
@Make hil(4) shared interrupts aware, by exiting early if the stat register
does not indicate data being available; for some reason on hppa hil_intr()
gets invoked when serial ports interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.22 2006/11/05 14:39:32 miod Exp $	*/
d468 1
@


1.22
log
@Handle loop reconfiguration in a kernel thread, instead of doing it from
interrupt context.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.21 2005/12/22 07:09:52 miod Exp $	*/
d287 8
d298 1
@


1.21
log
@Postpone the hil console detection logic to the first detection of a keyboard.

On hp300, hil would claim console against dnkbd if no dnkbd was found at
the time the loop is probed, even if the loop is empty. Because of this,
plugging dnkbd later would not select it as console keyboard, which is
really annoying on kernels without wsmux, such as hp300 RAMDISK.
Now the first keyboard plugged will become the console keyboard, whatever
its type.

No functional change on hppa, since the console path gives a definite console
device setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.20 2005/05/13 15:22:37 miod Exp $	*/
d75 1
a101 1
void	hil_process_pending(struct hil_softc *);
d103 1
d111 2
d252 10
d436 1
a436 1
hil_process_pending(struct hil_softc *sc)
d438 21
a458 9
	switch (sc->sc_pending) {
	case HIL_PENDING_RECONFIG:
		sc->sc_pending = 0;
		hilconfig(sc, sc->sc_maxdev);
		break;
	case HIL_PENDING_UNPLUGGED:
		sc->sc_pending = 0;
		hilempty(sc);
		break;
@


1.20
log
@Do not invoke hil_process_pendinc() from the interrupt handler if the loop
is marked as busy.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.19 2005/05/08 11:38:09 miod Exp $	*/
d85 2
d145 1
a145 1
hil_attach(struct hil_softc *sc, int hil_is_console)
d505 1
a505 1
			ha.ha_console = sc->sc_console;
d515 11
@


1.19
log
@When receiving an unplugged notification from the loop, do not take action
until the loop has reconfigured into a stable state. This can save up
unnecessary detach/attach cycles for the low ids in the loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.18 2005/05/08 04:39:40 miod Exp $	*/
d255 1
a255 5
	if (sc->sc_pending == HIL_PENDING_RECONFIG) {
		sc->sc_pending = 0;
		hilconfig(sc, 0);
	} else
		sc->sc_pending = 0;
d277 2
a278 1
	hil_process_pending(sc);
a455 1
	u_int oldmax;
a464 1
	oldmax = sc->sc_maxdev;
@


1.18
log
@Simplify loop reconfiguration code.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.17 2005/01/15 19:48:15 miod Exp $	*/
d95 1
a95 1
void	hilconfig(struct hil_softc *);
d257 1
a257 1
		hilconfig(sc);
d429 1
a429 1
		hilconfig(sc);
d455 1
a455 1
hilconfig(struct hil_softc *sc)
d484 1
a484 1
	for (id = oldmax + 1; id <= sc->sc_maxdev; id++) {
d545 1
d550 1
a550 1
	 * Check that the loop is really empty.
d552 9
a560 3
	db = 0;
	send_hil_cmd(sc, HIL_READLPSTAT, NULL, 0, &db);
	sc->sc_maxdev = db & LPS_DEVMASK;
d562 16
a577 5
	if (sc->sc_maxdev != 0) {
		printf("%s: unplugged loop finds %d devices???\n",
		    sc->sc_dev.dv_xname, sc->sc_maxdev);
		hilconfig(sc);
		return;
@


1.17
log
@If the loop is empty when we probe it, enable the interrupt anyways, so that
we can react on post-boot device plugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.16 2005/01/11 00:11:05 miod Exp $	*/
d99 1
d281 2
d297 1
a297 4
				if (sc->sc_status == HIL_STATUS_BUSY)
					sc->sc_pending = HIL_PENDING_RECONFIG;
				else
					hilconfig(sc);
d300 1
a300 4
				if (sc->sc_status == HIL_STATUS_BUSY)
					sc->sc_pending = HIL_PENDING_UNPLUGGED;
				else
					hilempty(sc);
a341 1

d423 15
d459 1
d469 1
d482 1
a482 1
	 * Now attach hil devices as they are found.
d484 1
a484 1
	for (id = 1; id <= sc->sc_maxdev; id++) {
a502 19
		/*
		 * If we already have a device configured at this position,
		 * then either it is still the same, or there has been some
		 * removal or insertion in the chain that made it change
		 * its position on the loop.
		 *
		 * Rather than trying to play smart and find where the
		 * device has gone, detach it, it will get reattached at
		 * its new address...
		 */
		if (sc->sc_devices[id] != NULL) {
			if (len == sc->sc_devices[id]->sc_infolen &&
			    bcmp(sc->sc_cmdbuf, sc->sc_devices[id]->sc_info,
			      len) == 0)
				continue;

			config_detach((struct device *)sc->sc_devices[id], 0);
		}

d522 1
a522 1
	 * Detach remaining devices, if they have been removed
d799 1
a799 10
		switch (sc->sc_pending) {
		case HIL_PENDING_RECONFIG:
			sc->sc_pending = 0;
			hilconfig(sc);
			break;
		case HIL_PENDING_UNPLUGGED:
			sc->sc_pending = 0;
			hilempty(sc);
			break;
		}
@


1.16
log
@Reliability fixes:
- Let the loop initialize completely before attempting to probe its devices.
  Fixes the "no answer from device 1" problem.
- Handle ``loop unplugged'' events and force detach of all children in this
  case.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.15 2005/01/09 23:49:35 miod Exp $	*/
d240 3
a242 1
		return;
@


1.15
log
@Allow send_hil{,dev}_cmd to return failure, and handle this where
applicable.

During device probe, if a device does not answer commands, display a warning
message. This apparently happens on hp300 when the console is configured
as remote (i.e. serial console). Unplugging and replugging the device works
fine afterwards...
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.14 2004/05/10 05:18:53 jolan Exp $	*/
d96 1
d198 2
d244 1
a244 2
	 * At this point, the loop should have reconfigured.
	 * The reconfiguration interrupt has already called hilconfig().
d247 10
d290 14
a303 2
			if (c == HIL_RECONFIG)
				hilconfig(sc);
d359 2
a360 1
			if (c == HIL_RECONFIG) {
d366 1
a366 1
				sc->sc_cpending = 1;
d376 9
d541 41
d803 3
a805 2
		if (sc->sc_cpending) {
			sc->sc_cpending = 0;
d807 5
@


1.14
log
@obliterate undef, ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.13 2004/03/12 20:29:12 miod Exp $	*/
d99 1
a99 1
void	send_device_cmd(struct hil_softc *sc, u_int device, u_int cmd);
d222 4
a225 4
		send_hil_cmd(sc, HIL_READLPSTAT, NULL, 0, &db);
		
		if (db & (LPS_CONFFAIL | LPS_CONFGOOD))
			break;
d439 5
a443 1
		send_device_cmd(sc, id, HIL_IDENTIFY);
d514 1
a514 1
void
d528 1
a528 1
		return;
d554 1
d566 1
a566 1
void
d570 1
d582 1
d609 1
d621 1
d624 1
a624 1
void
d629 1
a629 1
	int s;
d633 8
a640 8
	send_device_cmd(sc, dev->sc_code, cmd);

	/*
	 * Return the command response in the buffer if necessary
	 */
	if (outbuf != NULL && outlen != NULL) {
		*outlen = min(*outlen, sc->sc_cmdbp - sc->sc_cmdbuf);
		bcopy(sc->sc_cmdbuf, outbuf, *outlen);
d644 1
@


1.13
log
@Allow busy wait loops to fail, so that we don't spin if the hil loop does not
behave correctly for some reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.12 2003/10/21 10:29:44 jmc Exp $	*/
a65 2

#undef	HILDEBUG
@


1.12
log
@typo from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.11 2003/06/02 23:28:01 millert Exp $	*/
d3 1
a3 1
 * Copyright (c) 2003, Miodrag Vallat.
d105 2
a106 2
static void hilwait(struct hil_softc *);
static void hildatawait(struct hil_softc *);
d108 1
a108 1
static __inline void
d111 3
a113 2
	DELAY(1);
	while (bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) & HIL_BUSY) {
d115 3
d119 2
d123 1
a123 1
static __inline void
d126 3
a128 3
	DELAY(1);
	while (!(bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) &
	    HIL_DATA_RDY)) {
d130 3
d134 2
d521 8
a528 1
	hilwait(sc);
d537 7
a543 1
			hildatawait(sc);
d573 8
a583 1
	hilwait(sc);
d599 7
a605 1
		hildatawait(sc);
d611 1
a611 1

d647 3
a652 1
	hilwait(sc);
d689 3
a694 1
	hilwait(sc);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.10 2003/05/27 07:01:55 mickey Exp $	*/
d329 1
a329 1
				 * occured; it will be processed upon
@


1.10
log
@as mentioned in hardball ers a few delays are needed; mios@@ testing on hp300 and ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.9 2003/03/28 00:20:03 miod Exp $	*/
d46 1
a46 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Better message to report an empty loop during probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.8 2003/03/16 02:01:15 miod Exp $	*/
d115 1
d117 1
a117 1
		/* nothing */
d124 1
d127 1
a127 1
		/* nothing */
d207 1
d258 1
d519 1
d528 1
d575 1
d674 1
d702 1
@


1.9.2.1
log
@A sweep to fix remaining files not in sync with the SMP_SYNC_B point.
@
text
@d228 1
a228 1
		printf("%s: loop failed to reconfigure\n", sc->sc_dev.dv_xname);
@


1.9.2.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.9.2.1 2003/04/19 19:17:49 niklas Exp $	*/
d228 1
a228 1
		printf("%s: no devices\n", sc->sc_dev.dv_xname);
@


1.9.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.9.2.2 2003/05/13 19:34:57 ho Exp $	*/
d46 5
a50 1
 * 3. Neither the name of the University nor the names of its contributors
a114 1
	DELAY(1);
d116 1
a116 1
		DELAY(1);
a122 1
	DELAY(1);
d125 1
a125 1
		DELAY(1);
a204 1
		DELAY(1);
a254 1
	DELAY(1);
a514 1
		DELAY(1);
a522 1
			DELAY(1);
a568 1
		DELAY(1);
a666 1
	DELAY(1);
a693 1
	DELAY(1);
@


1.9.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d329 1
a329 1
				 * occurred; it will be processed upon
@


1.9.2.5
log
@Merge with the trunk
@
text
@d3 1
a3 1
 * Copyright (c) 2003, 2004, Miodrag Vallat.
d67 2
d105 2
a106 2
static int hilwait(struct hil_softc *);
static int hildatawait(struct hil_softc *);
d108 1
a108 1
static __inline int
d111 2
a112 3
	int cnt;

	for (cnt = 50000; cnt != 0; cnt--) {
a113 3
		if ((bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) &
		    HIL_BUSY) == 0)
			break;
a114 2

	return (cnt);
d117 1
a117 1
static __inline int
d120 3
a122 3
	int cnt;

	for (cnt = 50000; cnt != 0; cnt--) {
a123 3
		if ((bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_STAT) &
		    HIL_DATA_RDY) != 0)
			break;
a124 2

	return (cnt);
d510 1
a510 8
	if (hilwait(sc) == 0) {
#ifdef HILDEBUG
		printf("%s: no answer from the loop\n", sc->sc_dev.dv_xname);
#endif
		splx(s);
		return;
	}

d519 1
a519 7
			if (hildatawait(sc) == 0) {
#ifdef HILDEBUG
				printf("%s: no answer from the loop\n",
				    sc->sc_dev.dv_xname);
#endif
				break;
			}
a548 8
	if (hilwait(sc) == 0) {
#ifdef HILDEBUG
		printf("%s: no answer from device %d\n",
		    sc->sc_dev.dv_xname, device);
#endif
		goto out;
	}

d552 1
d568 1
a568 7
		if (hildatawait(sc) == 0) {
#ifdef HILDEBUG
			printf("%s: no answer from device %d\n",
			    sc->sc_dev.dv_xname, device);
#endif
			break;
		}
d574 1
a574 1
out:
a609 3
	if (hilwait(sc) == 0)
		return;

d613 1
a649 3
	if (hilwait(sc) == 0)
		return;

d653 1
@


1.8
log
@A better explanation of why we need to operate hil keyboards in raw mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.7 2003/02/26 20:22:03 miod Exp $	*/
d228 1
a228 1
		printf("%s: loop failed to reconfigure\n", sc->sc_dev.dv_xname);
@


1.7
log
@New hil child devices attachment framework, that allow them to be detached
at runtime.

Handle reconfiguration notices from the loop, and do the necessary
detach/attach work so that our vision of the loop is in sync with reality.

Adapt all hil child devices to the above changes.

"This is not as plug'n'play as usb, but you get the same feeling anyways..."
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.6 2003/02/19 00:03:30 miod Exp $	*/
d386 2
a387 2
 *	- make sure all keyboards are in raw mode (hilkbd depends
 *	  on this)
d392 5
@


1.6
log
@Leaving console polling mode works now, and workaround boot -a slow response
glitch.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.5 2003/02/18 02:40:51 miod Exp $	*/
d91 5
a95 1
#define	splhil	spltty
d105 1
d128 1
a128 1

d187 1
a187 2
	struct hil_attach_args ha;
	int id, s, tries;
a236 43

	/*
	 * Now attach hil devices as they are found.
	 */

	s = splhil();

	/* Attach the remaining devices */
	for (id = 1; id <= sc->sc_maxdev; id++) {
		int len;
		const struct hildevice *hd;
		
		send_hildev_cmd(sc, id, HIL_IDENTIFY, NULL, NULL);

		len = sc->sc_cmdbp - sc->sc_cmdbuf;
		if (len == 0) {
#ifdef HILDEBUG
			printf("%s: no device at code %d\n",
			    sc->sc_dev.dv_xname, id);
#endif
			continue;
		}

		/* Attach found devices */
		for (hd = hildevs; hd->minid >= 0; hd++)
			if (sc->sc_cmdbuf[0] >= hd->minid &&
			    sc->sc_cmdbuf[0] <= hd->maxid) {

			ha.ha_console = sc->sc_console;
			ha.ha_code = id;
			ha.ha_type = hd->type;
			ha.ha_descr = hd->descr;
			ha.ha_infolen = len;
			bcopy(sc->sc_cmdbuf, ha.ha_info, len);

			config_found_sm(&sc->sc_dev, &ha, hildevprint,
			    hilsubmatch);
		}
	}

	sc->sc_cmdbp = sc->sc_cmdbuf;

	splx(s);
a238 17
void
hil_callback_register(struct hil_softc *sc, u_int hilid,
    void (*handler)(void *, u_int, u_int8_t *), void *arg)
{
#ifdef HILDEBUG
	if (hilid < 0 || hilid >= NHILD)
		panic("hil_callback_register invoked with hilid %d", hilid);
#endif

	if (sc->sc_cb[hilid].cb_fn != NULL)
		panic("hil_callback_register: invoked twice for hilid %d",
		   hilid);

	sc->sc_cb[hilid].cb_fn = handler;
	sc->sc_cb[hilid].cb_arg = arg;
}

d263 2
d275 3
a277 3
				if (sc->sc_cb[sc->sc_actdev].cb_fn != NULL)
					sc->sc_cb[sc->sc_actdev].cb_fn
					    (sc->sc_cb[sc->sc_actdev].cb_arg,
d320 2
d328 2
a329 2
				 * XXX We should remember if a configuration
				 * event occured and invoke hilconfig() upon
d332 10
d396 1
d398 1
a398 1
	int s;
d409 1
a409 1
	printf("%s: %d devices\n", sc->sc_dev.dv_xname, sc->sc_maxdev);
d418 67
d487 1
a487 1

a494 2
 * We run at splvm() to make the transaction as atomic as
 * possible without blocking the clock (is this necessary?)
d501 3
a503 1
	int s = splvm();
d530 1
a530 3
 *
 * splhigh is extremely conservative but insures atomic operation,
 * splvm (clock only interrupts) seems to be good enough in practice.
d533 1
a533 2
send_hildev_cmd(struct hil_softc *sc, u_int device, u_int cmd,
    u_int8_t *outbuf, u_int *outlen)
a535 1
	int s = splvm();
d569 14
a590 2
	pollon(sc);

d667 9
a675 2
	/* Always work in auto polled mode... */
	pollon(sc);
d679 1
a679 1
hil_poll_data(struct hil_softc *sc, u_int code, u_int8_t *stat, u_int8_t *data)
d681 1
d692 1
a692 1
		if (sc->sc_actdev == code) {
@


1.5
log
@Real polled mode console support, enough to play hangman in ddb.
Still a minor issue left for tomorrow.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.4 2003/02/15 23:45:52 miod Exp $	*/
d305 3
d633 2
a634 4
	if (on)
		pollon(sc);
	else
		polloff(sc);
@


1.4
log
@Provide a "code" locator for hil devices. This will let people ask their
kernels to attach hilkbd0 (console keyboard) or hilms0 (main mouse) to
a specific device in the loop, by using UKC or compiling a new kernel.

Using this and the previous console changes, it is now possible on a loop
with multiple keyboards, to choose which keyboard will be the console
keyboard.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.3 2003/02/15 23:42:48 miod Exp $	*/
d100 1
d365 57
d595 3
d637 1
a637 1
hil_poll_data(struct hil_softc *sc, u_int8_t *stat, u_int8_t *data)
d639 1
a639 1
	u_int8_t s;
d645 1
a645 2
	*stat = s;
	*data = bus_space_read_1(sc->sc_bst, sc->sc_bsh, HILP_DATA);
d647 10
a656 1
	return 0;
@


1.3
log
@Rework the console management on hppa:
- only attach a keyboard as a console if it matches the PDC keyboard path
- on hil, as there can be multiple keyboards on the loop, attach only the
  first hilkbd device configured as console keyboard. Right now this means
  the one with the lowest hil code, which was the existing behaviour so far.
- do not try to switch to the wscons consdev structure early at all in
  wscons_machdep, but rather wait for the console to be completely
  configured (i.e. both wskbd and wsdisplay are attached) to switch.

With feedback and help from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.2 2003/02/15 23:38:46 miod Exp $	*/
d98 1
a98 1

d164 13
d267 2
a268 1
			config_found(&sc->sc_dev, &ha, hildevprint);
@


1.2
log
@- Better type usage in the various hil code: prefer u_int8_t to u_char, but
do not stick to u_int8_t when native word size can do the job better.
- Allow send_hildev_cmd() to return the command response buffer to its
caller, rather than forcing it to look at the guts of its parent device
softc... this will be needed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: hil.c,v 1.1 2003/02/11 19:40:20 miod Exp $	*/
d128 1
a128 1
hil_attach(struct hil_softc *sc)
d140 1
a140 1
	sc->sc_kbddev = 0;
d247 1
a253 12
			if (ha.ha_type == HIL_DEVICE_KEYBOARD) {
				/*
				 * Currently, the first found hil keyboard will
				 * be attached as a console keyboard.
				 * This will change when we have hil at wax
				 * attachment.
				 */
				ha.ha_flags = id == sc->sc_kbddev;
			} else {
				ha.ha_flags = 0;
			}

d379 1
a379 9
	 * Locate the main keyboard device, if present.
	 */
	db = 0;
	send_hil_cmd(sc, HIL_READKBDSADR, NULL, 0, &db);
	sc->sc_kbddev = ffs((int)db);

	/*
	 * Put all keyboards in raw mode, in case we ended there after
	 * a reconfigure event.
@


1.1
log
@Oops, forgot to commit the most important file...
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d231 1
a231 1
		send_hildev_cmd(sc, id, HIL_IDENTIFY);
d275 1
a275 1
hil_callback_register(struct hil_softc *sc, int hilid,
d417 1
a417 1
send_hil_cmd(struct hil_softc *sc, u_int8_t cmd, u_int8_t *data, u_int8_t dlen,
d453 2
a454 3
send_hildev_cmd(sc, device, cmd)
	struct hil_softc *sc;
	char device, cmd;
d491 8
d510 1
a510 1
	char db;
d547 1
a547 1
	char db;
@

