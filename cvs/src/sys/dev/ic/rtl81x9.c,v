head	1.96;
access;
symbols
	OPENBSD_6_1:1.96.0.4
	OPENBSD_6_1_BASE:1.96
	OPENBSD_6_0:1.95.0.4
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.94.0.2
	OPENBSD_5_9_BASE:1.94
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.87.0.2
	OPENBSD_5_7_BASE:1.87
	OPENBSD_5_6:1.82.0.4
	OPENBSD_5_6_BASE:1.82
	OPENBSD_5_5:1.81.0.4
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.77.0.2
	OPENBSD_5_4_BASE:1.77
	OPENBSD_5_3:1.76.0.2
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.75.0.4
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.75
	OPENBSD_5_1:1.75.0.6
	OPENBSD_5_0:1.75.0.2
	OPENBSD_5_0_BASE:1.75
	OPENBSD_4_9:1.74.0.2
	OPENBSD_4_9_BASE:1.74
	OPENBSD_4_8:1.71.0.2
	OPENBSD_4_8_BASE:1.71
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.64.0.4
	OPENBSD_4_6_BASE:1.64
	OPENBSD_4_5:1.63.0.2
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.57.0.2
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.55.0.2
	OPENBSD_4_1_BASE:1.55
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.45.0.2
	OPENBSD_3_8_BASE:1.45
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.20.0.4
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.19
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.96
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.95;
commitid	VyLWTsbepAOk7VQM;

1.95
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.94;
commitid	QHiEhS9DHyE6oiIr;

1.94
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.93;
commitid	B0kwmVGiD5DVx4kv;

1.93
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.92;
commitid	5DvsamK0GblTp8ww;

1.92
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.91;
commitid	p0v5tuE1Ch6fY0Nj;

1.91
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.90;
commitid	MVWrtktB46JRxFWT;

1.90
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.89;
commitid	aiRvgNOa4qke9vft;

1.89
date	2015.03.30.10.04.11;	author mpi;	state Exp;
branches;
next	1.88;
commitid	vuysUy6vx4zNlffv;

1.88
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.87;
commitid	p4LJxGKbi0BU2cG6;

1.87
date	2015.01.08.00.49.18;	author brad;	state Exp;
branches;
next	1.86;
commitid	VH7cwj1b7ZDYWwH1;

1.86
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.85;
commitid	yM2VFFhpDTeFQlve;

1.85
date	2014.12.08.10.58.45;	author brad;	state Exp;
branches;
next	1.84;
commitid	2lOR2VAGPukFfE5p;

1.84
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.83;
commitid	Wmnzf8bGQILqXRTG;

1.83
date	2014.09.06.05.41.35;	author jsg;	state Exp;
branches;
next	1.82;
commitid	TZ6gfz2Iz0CRv2Rz;

1.82
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.81;
commitid	TGHgrLxu6sxZoiFt;

1.81
date	2013.12.28.03.35.00;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2013.08.21.05.21.43;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2013.08.07.01.06.31;	author bluhm;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.07.01.03.57;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.29.21.10.32;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2011.06.21.16.52.45;	author tedu;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.31.17.13.47;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2010.08.27.20.22.13;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.69;

1.69
date	2009.12.21.18.14.51;	author naddy;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.23.23.49.45;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.21.07.30.18;	author sthen;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.18.11.24.39;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.02.17.27.39;	author jsg;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.04.19.54.44;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.60;

1.60
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.58;

1.58
date	2008.04.20.00.23.28;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.22.09.19.11;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.08.18.49.32;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.02.02.04.21.40;	author jason;	state Exp;
branches;
next	1.54;

1.54
date	2006.10.15.19.06.38;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2006.09.29.22.22.33;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2006.09.29.16.04.06;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.29.02.40.38;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.20.20.31.12;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.03.25.22.41.43;	author djm;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.07.03.20.00;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.10.24.00.35.57;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.08.03.16.27.39;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2005.07.20.23.02.41;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.07.20.22.59.52;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.02.23.20.05;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.02.23.17.36;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.06.09.03.14.43;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.04.19.30.43;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.22.08.09.23;	author pefo;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.20.00.41.36;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2004.11.21.18.50.43;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.13.22.49.24;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.30.17.59.23;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.30.17.41.58;	author jason;	state Exp;
branches;
next	1.31;

1.31
date	2004.09.30.17.37.54;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2004.09.30.14.58.02;	author jason;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.28.07.05.50;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2004.09.28.05.14.44;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.06.17.56.36;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.19.11.36.59;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.07.01.42.48;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.07.15.47.52;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.01.23.37.12;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.15.16.02.10;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.08.00.10.54;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.07.18.32.51;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.15.20.45.31;	author nordin;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.08.05.38.53;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.10.24.16.56.56;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.12.20.12.12;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.03.23.26.04;	author chris;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.08.23.38.06;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.27.06.34.43;	author kjc;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.23.23.17.35;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.22.11.35.16;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.13.15.58.43;	author aaron;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.04.10.22.52.00;	author aaron;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.24.10;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.07.04.10.41.06;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2001.11.13.21.10.00;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.2.4.7;

1.2.4.7
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.2.4.8;

1.2.4.8
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.2.4.9;

1.2.4.9
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	1.2.4.10;

1.2.4.10
date	2004.06.07.20.41.22;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.96
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: rtl81x9.c,v 1.95 2016/04/13 10:49:26 mpi Exp $ */

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Realtek 8129/8139 PCI NIC driver
 *
 * Supports several extremely cheap PCI 10/100 adapters based on
 * the Realtek chipset. Datasheets can be obtained from
 * www.realtek.com.tw.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The Realtek 8139 PCI NIC redefines the meaning of 'low end.' This is
 * probably the worst PCI ethernet controller ever made, with the possible
 * exception of the FEAST chip made by SMC. The 8139 supports bus-master
 * DMA, but it has a terrible interface that nullifies any performance
 * gains that bus-master DMA usually offers.
 *
 * For transmission, the chip offers a series of four TX descriptor
 * registers. Each transmit frame must be in a contiguous buffer, aligned
 * on a longword (32-bit) boundary. This means we almost always have to
 * do mbuf copies in order to transmit a frame, except in the unlikely
 * case where a) the packet fits into a single mbuf, and b) the packet
 * is 32-bit aligned within the mbuf's data area. The presence of only
 * four descriptor registers means that we can never have more than four
 * packets queued for transmission at any one time.
 *
 * Reception is not much better. The driver has to allocate a single large
 * buffer area (up to 64K in size) into which the chip will DMA received
 * frames. Because we don't know where within this region received packets
 * will begin or end, we have no choice but to copy data from the buffer
 * area into mbufs in order to pass the packets up to the higher protocol
 * levels.
 *
 * It's impossible given this rotten design to really achieve decent
 * performance at 100Mbps, unless you happen to have a 400MHz PII or
 * some equally overmuscled CPU to drive it.
 *
 * On the bright side, the 8139 does have a built-in PHY, although
 * rather than using an MDIO serial interface like most other NICs, the
 * PHY registers are directly accessible through the 8139's register
 * space. The 8139 supports autonegotiation, as well as a 64-bit multicast
 * filter.
 *
 * The 8129 chip is an older version of the 8139 that uses an external PHY
 * chip. The 8129 has a serial MDIO interface for accessing the MII where
 * the 8139 lets you directly access the on-board PHY registers. We need
 * to select which interface to use depending on the chip type.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/timeout.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/ic/rtl81x9reg.h>

/*
 * Various supported PHY vendors/types and their names. Note that
 * this driver will work with pretty much any MII-compliant PHY,
 * so failure to positively identify the chip is not a fatal error.
 */

void rl_tick(void *);

int rl_encap(struct rl_softc *, struct mbuf * );

void rl_rxeof(struct rl_softc *);
void rl_txeof(struct rl_softc *);
void rl_start(struct ifnet *);
int rl_ioctl(struct ifnet *, u_long, caddr_t);
void rl_init(void *);
void rl_stop(struct rl_softc *);
void rl_watchdog(struct ifnet *);
int rl_ifmedia_upd(struct ifnet *);
void rl_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void rl_eeprom_getword(struct rl_softc *, int, int, u_int16_t *);
void rl_eeprom_putbyte(struct rl_softc *, int, int);
void rl_read_eeprom(struct rl_softc *, caddr_t, int, int, int, int);

void rl_mii_sync(struct rl_softc *);
void rl_mii_send(struct rl_softc *, u_int32_t, int);
int rl_mii_readreg(struct rl_softc *, struct rl_mii_frame *);
int rl_mii_writereg(struct rl_softc *, struct rl_mii_frame *);

int rl_miibus_readreg(struct device *, int, int);
void rl_miibus_writereg(struct device *, int, int, int);
void rl_miibus_statchg(struct device *);

void rl_iff(struct rl_softc *);
void rl_reset(struct rl_softc *);
int rl_list_tx_init(struct rl_softc *);

#define EE_SET(x)					\
	CSR_WRITE_1(sc, RL_EECMD,			\
		CSR_READ_1(sc, RL_EECMD) | x)

#define EE_CLR(x)					\
	CSR_WRITE_1(sc, RL_EECMD,			\
		CSR_READ_1(sc, RL_EECMD) & ~x)

/*
 * Send a read command and address to the EEPROM, check for ACK.
 */
void
rl_eeprom_putbyte(struct rl_softc *sc, int addr, int addr_len)
{
	int	d, i;

	d = (RL_EECMD_READ << addr_len) | addr;

	/*
	 * Feed in each bit and strobe the clock.
	 */
	for (i = RL_EECMD_LEN + addr_len; i; i--) {
		if (d & (1 << (i - 1)))
			EE_SET(RL_EE_DATAIN);
		else
			EE_CLR(RL_EE_DATAIN);

		DELAY(100);
		EE_SET(RL_EE_CLK);
		DELAY(150);
		EE_CLR(RL_EE_CLK);
		DELAY(100);
	}
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
void
rl_eeprom_getword(struct rl_softc *sc, int addr, int addr_len,
    u_int16_t *dest)
{
	int		i;
	u_int16_t	word = 0;

	/* Enter EEPROM access mode. */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);

	/*
	 * Send address of word we want to read.
	 */
	rl_eeprom_putbyte(sc, addr, addr_len);

	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_PROGRAM|RL_EE_SEL);

	/*
	 * Start reading bits from EEPROM.
	 */
	for (i = 16; i > 0; i--) {
		EE_SET(RL_EE_CLK);
		DELAY(100);
		if (CSR_READ_1(sc, RL_EECMD) & RL_EE_DATAOUT)
			word |= 1 << (i - 1);
		EE_CLR(RL_EE_CLK);
		DELAY(100);
	}

	/* Turn off EEPROM access mode. */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);

	*dest = word;
}

/*
 * Read a sequence of words from the EEPROM.
 */
void
rl_read_eeprom(struct rl_softc *sc, caddr_t dest, int off, int addr_len,
    int cnt, int swap)
{
	int		i;
	u_int16_t	word = 0, *ptr;

	for (i = 0; i < cnt; i++) {
		rl_eeprom_getword(sc, off + i, addr_len, &word);
		ptr = (u_int16_t *)(dest + (i * 2));
		if (swap)
			*ptr = letoh16(word);
		else
			*ptr = word;
	}
}

/*
 * MII access routines are provided for the 8129, which
 * doesn't have a built-in PHY. For the 8139, we fake things
 * up by diverting rl_phy_readreg()/rl_phy_writereg() to the
 * direct access PHY registers.
 */
#define MII_SET(x)					\
	CSR_WRITE_1(sc, RL_MII,				\
		CSR_READ_1(sc, RL_MII) | x)

#define MII_CLR(x)					\
	CSR_WRITE_1(sc, RL_MII,				\
		CSR_READ_1(sc, RL_MII) & ~x)

/*
 * Sync the PHYs by setting data bit and strobing the clock 32 times.
 */
void
rl_mii_sync(struct rl_softc *sc)
{
	int	i;

	MII_SET(RL_MII_DIR|RL_MII_DATAOUT);

	for (i = 0; i < 32; i++) {
		MII_SET(RL_MII_CLK);
		DELAY(1);
		MII_CLR(RL_MII_CLK);
		DELAY(1);
	}
}

/*
 * Clock a series of bits through the MII.
 */
void
rl_mii_send(struct rl_softc *sc, u_int32_t bits, int cnt)
{
	int	i;

	MII_CLR(RL_MII_CLK);

	for (i = (0x1 << (cnt - 1)); i; i >>= 1) {
		if (bits & i)
			MII_SET(RL_MII_DATAOUT);
		else
			MII_CLR(RL_MII_DATAOUT);
		DELAY(1);
		MII_CLR(RL_MII_CLK);
		DELAY(1);
		MII_SET(RL_MII_CLK);
	}
}

/*
 * Read an PHY register through the MII.
 */
int
rl_mii_readreg(struct rl_softc *sc, struct rl_mii_frame *frame)
{
	int	i, ack, s;

	s = splnet();

	/*
	 * Set up frame for RX.
	 */
	frame->mii_stdelim = RL_MII_STARTDELIM;
	frame->mii_opcode = RL_MII_READOP;
	frame->mii_turnaround = 0;
	frame->mii_data = 0;

	CSR_WRITE_2(sc, RL_MII, 0);

	/*
	 * Turn on data xmit.
	 */
	MII_SET(RL_MII_DIR);

	rl_mii_sync(sc);

	/*
	 * Send command/address info.
	 */
	rl_mii_send(sc, frame->mii_stdelim, 2);
	rl_mii_send(sc, frame->mii_opcode, 2);
	rl_mii_send(sc, frame->mii_phyaddr, 5);
	rl_mii_send(sc, frame->mii_regaddr, 5);

	/* Idle bit */
	MII_CLR((RL_MII_CLK|RL_MII_DATAOUT));
	DELAY(1);
	MII_SET(RL_MII_CLK);
	DELAY(1);

	/* Turn off xmit. */
	MII_CLR(RL_MII_DIR);

	/* Check for ack */
	MII_CLR(RL_MII_CLK);
	DELAY(1);
	ack = CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN;
	MII_SET(RL_MII_CLK);
	DELAY(1);

	/*
	 * Now try reading data bits. If the ack failed, we still
	 * need to clock through 16 cycles to keep the PHY(s) in sync.
	 */
	if (ack) {
		for(i = 0; i < 16; i++) {
			MII_CLR(RL_MII_CLK);
			DELAY(1);
			MII_SET(RL_MII_CLK);
			DELAY(1);
		}
		goto fail;
	}

	for (i = 0x8000; i; i >>= 1) {
		MII_CLR(RL_MII_CLK);
		DELAY(1);
		if (!ack) {
			if (CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN)
				frame->mii_data |= i;
			DELAY(1);
		}
		MII_SET(RL_MII_CLK);
		DELAY(1);
	}

fail:

	MII_CLR(RL_MII_CLK);
	DELAY(1);
	MII_SET(RL_MII_CLK);
	DELAY(1);

	splx(s);

	if (ack)
		return(1);
	return(0);
}

/*
 * Write to a PHY register through the MII.
 */
int
rl_mii_writereg(struct rl_softc *sc, struct rl_mii_frame *frame)
{
	int	s;

	s = splnet();
	/*
	 * Set up frame for TX.
	 */

	frame->mii_stdelim = RL_MII_STARTDELIM;
	frame->mii_opcode = RL_MII_WRITEOP;
	frame->mii_turnaround = RL_MII_TURNAROUND;

	/*
	 * Turn on data output.
	 */
	MII_SET(RL_MII_DIR);

	rl_mii_sync(sc);

	rl_mii_send(sc, frame->mii_stdelim, 2);
	rl_mii_send(sc, frame->mii_opcode, 2);
	rl_mii_send(sc, frame->mii_phyaddr, 5);
	rl_mii_send(sc, frame->mii_regaddr, 5);
	rl_mii_send(sc, frame->mii_turnaround, 2);
	rl_mii_send(sc, frame->mii_data, 16);

	/* Idle bit. */
	MII_SET(RL_MII_CLK);
	DELAY(1);
	MII_CLR(RL_MII_CLK);
	DELAY(1);

	/*
	 * Turn off xmit.
	 */
	MII_CLR(RL_MII_DIR);

	splx(s);

	return(0);
}

void
rl_iff(struct rl_softc *sc)
{
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
	int			h = 0;
	u_int32_t		hashes[2];
	struct arpcom		*ac = &sc->sc_arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		rxfilt;

	rxfilt = CSR_READ_4(sc, RL_RXCFG);
	rxfilt &= ~(RL_RXCFG_RX_ALLPHYS | RL_RXCFG_RX_BROAD |
	    RL_RXCFG_RX_INDIV | RL_RXCFG_RX_MULTI);
	ifp->if_flags &= ~IFF_ALLMULTI;

	/*
	 * Always accept frames destined to our station address.
	 * Always accept broadcast frames.
	 */
	rxfilt |= RL_RXCFG_RX_INDIV | RL_RXCFG_RX_BROAD;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp ->if_flags |= IFF_ALLMULTI;
		rxfilt |= RL_RXCFG_RX_MULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxfilt |= RL_RXCFG_RX_ALLPHYS;
		hashes[0] = hashes[1] = 0xFFFFFFFF;
	} else {
		rxfilt |= RL_RXCFG_RX_MULTI;
		/* Program new filter. */
		bzero(hashes, sizeof(hashes));

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo,
			    ETHER_ADDR_LEN) >> 26;

			if (h < 32)
				hashes[0] |= (1 << h);
			else
				hashes[1] |= (1 << (h - 32));

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	CSR_WRITE_4(sc, RL_MAR0, hashes[0]);
	CSR_WRITE_4(sc, RL_MAR4, hashes[1]);
	CSR_WRITE_4(sc, RL_RXCFG, rxfilt);
}

void
rl_reset(struct rl_softc *sc)
{
	int	i;

	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_RESET);

	for (i = 0; i < RL_TIMEOUT; i++) {
		DELAY(10);
		if (!(CSR_READ_1(sc, RL_COMMAND) & RL_CMD_RESET))
			break;
	}
	if (i == RL_TIMEOUT)
		printf("%s: reset never completed!\n", sc->sc_dev.dv_xname);

}

/*
 * Initialize the transmit descriptors.
 */
int
rl_list_tx_init(struct rl_softc *sc)
{
	struct rl_chain_data	*cd = &sc->rl_cdata;
	int			i;

	for (i = 0; i < RL_TX_LIST_CNT; i++) {
		cd->rl_tx_chain[i] = NULL;
		CSR_WRITE_4(sc,
		    RL_TXADDR0 + (i * sizeof(u_int32_t)), 0x0000000);
	}

	sc->rl_cdata.cur_tx = 0;
	sc->rl_cdata.last_tx = 0;

	return(0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 *
 * You know there's something wrong with a PCI bus-master chip design
 * when you have to use m_devget().
 *
 * The receive operation is badly documented in the datasheet, so I'll
 * attempt to document it here. The driver provides a buffer area and
 * places its base address in the RX buffer start address register.
 * The chip then begins copying frames into the RX buffer. Each frame
 * is preceded by a 32-bit RX status word which specifies the length
 * of the frame and certain other status bits. Each frame (starting with
 * the status word) is also 32-bit aligned. The frame length is in the
 * first 16 bits of the status word; the lower 15 bits correspond with
 * the 'rx status register' mentioned in the datasheet.
 *
 * Note: to make the Alpha happy, the frame payload needs to be aligned
 * on a 32-bit boundary. To achieve this, we cheat a bit by copying from
 * the ring buffer starting at an address two bytes before the actual
 * data location. We can then shave off the first two bytes using m_adj().
 * The reason we do this is because m_devget() doesn't let us specify an
 * offset into the mbuf storage space, so we have to artificially create
 * one. The ring is allocated in such a way that there are a few unused
 * bytes of space preceding it so that it will be safe for us to do the
 * 2-byte backstep even if reading from the ring at offset 0.
 */
void
rl_rxeof(struct rl_softc *sc)
{
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	struct mbuf	*m;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	int		total_len;
	u_int32_t	rxstat;
	caddr_t		rxbufpos;
	int		wrap = 0;
	u_int16_t	cur_rx;
	u_int16_t	limit;
	u_int16_t	rx_bytes = 0, max_bytes;

	cur_rx = (CSR_READ_2(sc, RL_CURRXADDR) + 16) % RL_RXBUFLEN;

	/* Do not try to read past this point. */
	limit = CSR_READ_2(sc, RL_CURRXBUF) % RL_RXBUFLEN;

	if (limit < cur_rx)
		max_bytes = (RL_RXBUFLEN - cur_rx) + limit;
	else
		max_bytes = limit - cur_rx;

	while ((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
		    0, sc->sc_rx_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
		rxbufpos = sc->rl_cdata.rl_rx_buf + cur_rx;
		rxstat = *(u_int32_t *)rxbufpos;

		/*
		 * Here's a totally undocumented fact for you. When the
		 * Realtek chip is in the process of copying a packet into
		 * RAM for you, the length will be 0xfff0. If you spot a
		 * packet header with this value, you need to stop. The
		 * datasheet makes absolutely no mention of this and
		 * Realtek should be shot for this.
		 */
		rxstat = htole32(rxstat);
		total_len = rxstat >> 16;
		if (total_len == RL_RXSTAT_UNFINISHED) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
			    0, sc->sc_rx_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD);
			break;
		}

		if (!(rxstat & RL_RXSTAT_RXOK) ||
		    total_len < ETHER_MIN_LEN ||
		    total_len > ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN) {
			ifp->if_ierrors++;
			rl_init(sc);
			bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
			    0, sc->sc_rx_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD);
			return;
		}

		/* No errors; receive the packet. */
		rx_bytes += total_len + 4;

		/*
		 * XXX The Realtek chip includes the CRC with every
		 * received frame, and there's no way to turn this
		 * behavior off (at least, I can't find anything in
		 * the manual that explains how to do it) so we have
		 * to trim off the CRC manually.
		 */
		total_len -= ETHER_CRC_LEN;

		/*
		 * Avoid trying to read more bytes than we know
		 * the chip has prepared for us.
		 */
		if (rx_bytes > max_bytes) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
			    0, sc->sc_rx_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD);
			break;
		}

		rxbufpos = sc->rl_cdata.rl_rx_buf +
			((cur_rx + sizeof(u_int32_t)) % RL_RXBUFLEN);

		if (rxbufpos == (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN))
			rxbufpos = sc->rl_cdata.rl_rx_buf;

		wrap = (sc->rl_cdata.rl_rx_buf + RL_RXBUFLEN) - rxbufpos;

		if (total_len > wrap) {
			m = m_devget(rxbufpos, wrap, ETHER_ALIGN);
			if (m != NULL) {
				m_copyback(m, wrap, total_len - wrap,
				    sc->rl_cdata.rl_rx_buf, M_NOWAIT);
				if (m->m_pkthdr.len < total_len) {
					m_freem(m);
					m = NULL;
				}
			}
			cur_rx = (total_len - wrap + ETHER_CRC_LEN);
		} else {
			m = m_devget(rxbufpos, total_len, ETHER_ALIGN);
			cur_rx += total_len + 4 + ETHER_CRC_LEN;
		}

		/*
		 * Round up to 32-bit boundary.
		 */
		cur_rx = (cur_rx + 3) & ~3;
		CSR_WRITE_2(sc, RL_CURRXADDR, cur_rx - 16);

		if (m == NULL) {
			bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
			    0, sc->sc_rx_dmamap->dm_mapsize,
			    BUS_DMASYNC_PREREAD);
			ifp->if_ierrors++;
			continue;
		}

		ml_enqueue(&ml, m);

		bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
		    0, sc->sc_rx_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
	}

	if_input(ifp, &ml);
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */
void
rl_txeof(struct rl_softc *sc)
{
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	u_int32_t	txstat;

	/*
	 * Go through our tx list and free mbufs for those
	 * frames that have been uploaded.
	 */
	do {
		if (RL_LAST_TXMBUF(sc) == NULL)
			break;
		txstat = CSR_READ_4(sc, RL_LAST_TXSTAT(sc));
		if (!(txstat & (RL_TXSTAT_TX_OK|
		    RL_TXSTAT_TX_UNDERRUN|RL_TXSTAT_TXABRT)))
			break;

		ifp->if_collisions += (txstat & RL_TXSTAT_COLLCNT) >> 24;

		bus_dmamap_sync(sc->sc_dmat, RL_LAST_TXMAP(sc),
		    0, RL_LAST_TXMAP(sc)->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, RL_LAST_TXMAP(sc));
		m_freem(RL_LAST_TXMBUF(sc));
		RL_LAST_TXMBUF(sc) = NULL;
		/*
		 * If there was a transmit underrun, bump the TX threshold.
		 * Make sure not to overflow the 63 * 32byte we can address
		 * with the 6 available bit.
		 */
		if ((txstat & RL_TXSTAT_TX_UNDERRUN) &&
		    (sc->rl_txthresh < 2016))
			sc->rl_txthresh += 32;
		if (!ISSET(txstat, RL_TXSTAT_TX_OK)) {
			int oldthresh;

			ifp->if_oerrors++;
			if ((txstat & RL_TXSTAT_TXABRT) ||
			    (txstat & RL_TXSTAT_OUTOFWIN))
				CSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);
			oldthresh = sc->rl_txthresh;
			/* error recovery */
			rl_init(sc);
			/* restore original threshold */
			sc->rl_txthresh = oldthresh;
			return;
		}
		RL_INC(sc->rl_cdata.last_tx);
		ifq_clr_oactive(&ifp->if_snd);
	} while (sc->rl_cdata.last_tx != sc->rl_cdata.cur_tx);

	if (RL_LAST_TXMBUF(sc) == NULL)
		ifp->if_timer = 0;
	else if (ifp->if_timer == 0)
		ifp->if_timer = 5;
}

int
rl_intr(void *arg)
{
	struct rl_softc	*sc = arg;
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	int		claimed = 0;
	u_int16_t	status;

	/* Disable interrupts. */
	CSR_WRITE_2(sc, RL_IMR, 0x0000);

	for (;;) {
		status = CSR_READ_2(sc, RL_ISR);
		/* If the card has gone away, the read returns 0xffff. */
		if (status == 0xffff)
			break;
		if (status != 0)
			CSR_WRITE_2(sc, RL_ISR, status);
		if ((status & RL_INTRS) == 0)
			break;
		if ((status & RL_ISR_RX_OK) || (status & RL_ISR_RX_ERR))
			rl_rxeof(sc);
		if ((status & RL_ISR_TX_OK) || (status & RL_ISR_TX_ERR))
			rl_txeof(sc);
		if (status & RL_ISR_SYSTEM_ERR)
			rl_init(sc);
		claimed = 1;
	}

	/* Re-enable interrupts. */
	CSR_WRITE_2(sc, RL_IMR, RL_INTRS);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		rl_start(ifp);

	return (claimed);
}

/*
 * Encapsulate an mbuf chain in a descriptor by coupling the mbuf data
 * pointers to the fragment pointers.
 */
int
rl_encap(struct rl_softc *sc, struct mbuf *m_head)
{
	struct mbuf	*m_new;

	/*
	 * The Realtek is brain damaged and wants longword-aligned
	 * TX buffers, plus we can only have one fragment buffer
	 * per packet. We have to copy pretty much all the time.
	 */
	MGETHDR(m_new, M_DONTWAIT, MT_DATA);
	if (m_new == NULL) {
		m_freem(m_head);
		return(1);
	}
	if (m_head->m_pkthdr.len > MHLEN) {
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			m_freem(m_new);
			m_freem(m_head);
			return(1);
		}
	}
	m_copydata(m_head, 0, m_head->m_pkthdr.len, mtod(m_new, caddr_t));
	m_new->m_pkthdr.len = m_new->m_len = m_head->m_pkthdr.len;

	/* Pad frames to at least 60 bytes. */
	if (m_new->m_pkthdr.len < RL_MIN_FRAMELEN) {
		/*
		 * Make security-conscious people happy: zero out the
		 * bytes in the pad area, since we don't know what
		 * this mbuf cluster buffer's previous user might
		 * have left in it.
		 */
		bzero(mtod(m_new, char *) + m_new->m_pkthdr.len,
		    RL_MIN_FRAMELEN - m_new->m_pkthdr.len);
		m_new->m_pkthdr.len +=
		    (RL_MIN_FRAMELEN - m_new->m_pkthdr.len);
		m_new->m_len = m_new->m_pkthdr.len;
	}

	if (bus_dmamap_load_mbuf(sc->sc_dmat, RL_CUR_TXMAP(sc),
	    m_new, BUS_DMA_NOWAIT) != 0) {
		m_freem(m_new);
		m_freem(m_head);
		return (1);
	}
	m_freem(m_head);

	RL_CUR_TXMBUF(sc) = m_new;
	bus_dmamap_sync(sc->sc_dmat, RL_CUR_TXMAP(sc), 0,
	    RL_CUR_TXMAP(sc)->dm_mapsize, BUS_DMASYNC_PREWRITE);
	return(0);
}

/*
 * Main transmit routine.
 */
void
rl_start(struct ifnet *ifp)
{
	struct rl_softc	*sc = ifp->if_softc;
	struct mbuf	*m_head = NULL;
	int		pkts = 0;

	while (RL_CUR_TXMBUF(sc) == NULL) {
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL)
			break;

		/* Pack the data into the descriptor. */
		if (rl_encap(sc, m_head))
			break;
		pkts++;

#if NBPFILTER > 0
		/*
		 * If there's a BPF listener, bounce a copy of this frame
		 * to him.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, RL_CUR_TXMBUF(sc),
			    BPF_DIRECTION_OUT);
#endif
		/*
		 * Transmit the frame.
		 */
		CSR_WRITE_4(sc, RL_CUR_TXADDR(sc),
		    RL_CUR_TXMAP(sc)->dm_segs[0].ds_addr);
		CSR_WRITE_4(sc, RL_CUR_TXSTAT(sc),
		    RL_TXTHRESH(sc->rl_txthresh) |
		    RL_CUR_TXMAP(sc)->dm_segs[0].ds_len);

		RL_INC(sc->rl_cdata.cur_tx);

		/*
		 * Set a timeout in case the chip goes out to lunch.
		 */
		ifp->if_timer = 5;
	}

	if (pkts == 0)
		return;

	/*
	 * We broke out of the loop because all our TX slots are
	 * full. Mark the NIC as busy until it drains some of the
	 * packets from the queue.
	 */
	if (RL_CUR_TXMBUF(sc) != NULL)
		ifq_set_oactive(&ifp->if_snd);
}

void
rl_init(void *xsc)
{
	struct rl_softc	*sc = xsc;
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	int		s;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	rl_stop(sc);

	/* Put controller into known state. */
	rl_reset(sc);

	/*
	 * Init our MAC address.  Even though the chipset
	 * documentation doesn't mention it, we need to enter "Config
	 * register write enable" mode to modify the ID registers.
	 */
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_WRITECFG);
	CSR_WRITE_RAW_4(sc, RL_IDR0,
	    (u_int8_t *)(&sc->sc_arpcom.ac_enaddr[0]));
	CSR_WRITE_RAW_4(sc, RL_IDR4,
	    (u_int8_t *)(&sc->sc_arpcom.ac_enaddr[4]));
	CSR_WRITE_1(sc, RL_EECMD, RL_EEMODE_OFF);

	/* Init the RX buffer pointer register. */
	CSR_WRITE_4(sc, RL_RXADDR, sc->rl_cdata.rl_rx_buf_pa);

	/* Init TX descriptors. */
	rl_list_tx_init(sc);

	/*
	 * Enable transmit and receive.
	 */
	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);

	/*
	 * Set the initial TX and RX configuration.
	 */
	CSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);
	CSR_WRITE_4(sc, RL_RXCFG, RL_RXCFG_CONFIG);

	/*
	 * Program promiscuous mode and multicast filters.
	 */
	rl_iff(sc);

	/*
	 * Enable interrupts.
	 */
	CSR_WRITE_2(sc, RL_IMR, RL_INTRS);

	/* Set initial TX threshold */
	sc->rl_txthresh = RL_TX_THRESH_INIT;

	/* Start RX/TX process. */
	CSR_WRITE_4(sc, RL_MISSEDPKT, 0);

	/* Enable receiver and transmitter. */
	CSR_WRITE_1(sc, RL_COMMAND, RL_CMD_TX_ENB|RL_CMD_RX_ENB);

	mii_mediachg(&sc->sc_mii);

	CSR_WRITE_1(sc, sc->rl_cfg1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->sc_tick_tmo, 1);
}

/*
 * Set media options.
 */
int
rl_ifmedia_upd(struct ifnet *ifp)
{
	struct rl_softc *sc = (struct rl_softc *)ifp->if_softc;

	mii_mediachg(&sc->sc_mii);
	return (0);
}

/*
 * Report current media status.
 */
void
rl_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct rl_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

int
rl_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct rl_softc	*sc = ifp->if_softc;
	struct ifreq	*ifr = (struct ifreq *) data;
	int		s, error = 0;

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			rl_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				rl_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				rl_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			rl_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
rl_watchdog(struct ifnet *ifp)
{
	struct rl_softc	*sc = ifp->if_softc;

	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);
	ifp->if_oerrors++;
	rl_txeof(sc);
	rl_rxeof(sc);
	rl_init(sc);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
rl_stop(struct rl_softc *sc)
{
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	int		i;

	ifp->if_timer = 0;

	timeout_del(&sc->sc_tick_tmo);

	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	CSR_WRITE_1(sc, RL_COMMAND, 0x00);
	CSR_WRITE_2(sc, RL_IMR, 0x0000);

	/*
	 * Free the TX list buffers.
	 */
	for (i = 0; i < RL_TX_LIST_CNT; i++) {
		if (sc->rl_cdata.rl_tx_chain[i] != NULL) {
			bus_dmamap_sync(sc->sc_dmat,
			    sc->rl_cdata.rl_tx_dmamap[i], 0,
			    sc->rl_cdata.rl_tx_dmamap[i]->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat,
			    sc->rl_cdata.rl_tx_dmamap[i]);
			m_freem(sc->rl_cdata.rl_tx_chain[i]);
			sc->rl_cdata.rl_tx_chain[i] = NULL;
			CSR_WRITE_4(sc, RL_TXADDR0 + (i * sizeof(u_int32_t)),
				0x00000000);
		}
	}
}

int
rl_attach(struct rl_softc *sc)
{
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;
	int		rseg, i;
	u_int16_t	rl_id;
	caddr_t		kva;
	int		addr_len;

	sc->rl_cfg0 = RL_8139_CFG0;
	sc->rl_cfg1 = RL_8139_CFG1;
	sc->rl_cfg2 = 0;
	sc->rl_cfg3 = RL_8139_CFG3;
	sc->rl_cfg4 = RL_8139_CFG4;
	sc->rl_cfg5 = RL_8139_CFG5;

	rl_reset(sc);

	/*
	 * Check EEPROM type 9346 or 9356.
	 */
	rl_read_eeprom(sc, (caddr_t)&rl_id, RL_EE_ID, RL_EEADDR_LEN1, 1, 0);
	if (rl_id == 0x8129)
		addr_len = RL_EEADDR_LEN1;
	else
		addr_len = RL_EEADDR_LEN0;

	/*
	 * Get station address.
	 */
	rl_read_eeprom(sc, (caddr_t)sc->sc_arpcom.ac_enaddr, RL_EE_EADDR,
	    addr_len, 3, 1);

	printf(", address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	if (bus_dmamem_alloc(sc->sc_dmat, RL_RXBUFLEN + 32, PAGE_SIZE, 0,
	    &sc->sc_rx_seg, 1, &rseg, BUS_DMA_NOWAIT | BUS_DMA_ZERO)) {
		printf("\n%s: can't alloc rx buffers\n", sc->sc_dev.dv_xname);
		return (1);
	}
	if (bus_dmamem_map(sc->sc_dmat, &sc->sc_rx_seg, rseg,
	    RL_RXBUFLEN + 32, &kva, BUS_DMA_NOWAIT)) {
		printf("%s: can't map dma buffers (%d bytes)\n",
		    sc->sc_dev.dv_xname, RL_RXBUFLEN + 32);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_rx_seg, rseg);
		return (1);
	}
	if (bus_dmamap_create(sc->sc_dmat, RL_RXBUFLEN + 32, 1,
	    RL_RXBUFLEN + 32, 0, BUS_DMA_NOWAIT, &sc->sc_rx_dmamap)) {
		printf("%s: can't create dma map\n", sc->sc_dev.dv_xname);
		bus_dmamem_unmap(sc->sc_dmat, kva, RL_RXBUFLEN + 32);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_rx_seg, rseg);
		return (1);
	}
	if (bus_dmamap_load(sc->sc_dmat, sc->sc_rx_dmamap, kva,
	    RL_RXBUFLEN + 32, NULL, BUS_DMA_NOWAIT)) {
		printf("%s: can't load dma map\n", sc->sc_dev.dv_xname);
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_rx_dmamap);
		bus_dmamem_unmap(sc->sc_dmat, kva, RL_RXBUFLEN + 32);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_rx_seg, rseg);
		return (1);
	}
	sc->rl_cdata.rl_rx_buf = kva;
	sc->rl_cdata.rl_rx_buf_pa = sc->sc_rx_dmamap->dm_segs[0].ds_addr;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_rx_dmamap,
	    0, sc->sc_rx_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	for (i = 0; i < RL_TX_LIST_CNT; i++) {
		if (bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES, 0,
		    BUS_DMA_NOWAIT, &sc->rl_cdata.rl_tx_dmamap[i]) != 0) {
			printf("%s: can't create tx maps\n",
			    sc->sc_dev.dv_xname);
			/* XXX free any allocated... */
			return (1);
		}
	}

	/* Leave a few bytes before the start of the RX ring buffer. */
	sc->rl_cdata.rl_rx_buf_ptr = sc->rl_cdata.rl_rx_buf;
	sc->rl_cdata.rl_rx_buf += sizeof(u_int64_t);
	sc->rl_cdata.rl_rx_buf_pa += sizeof(u_int64_t);

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = rl_ioctl;
	ifp->if_start = rl_start;
	ifp->if_watchdog = rl_watchdog;

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	timeout_set(&sc->sc_tick_tmo, rl_tick, sc);

	/*
	 * Initialize our media structures and probe the MII.
	 */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = rl_miibus_readreg;
	sc->sc_mii.mii_writereg = rl_miibus_writereg;
	sc->sc_mii.mii_statchg = rl_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, rl_ifmedia_upd, rl_ifmedia_sts);
	mii_attach(&sc->sc_dev, &sc->sc_mii, 0xffffffff, MII_PHY_ANY,
	    MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	/*
	 * Attach us everywhere
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	return (0);
}

int
rl_activate(struct device *self, int act)
{
	struct rl_softc	*sc = (struct rl_softc *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			rl_stop(sc);
		rv = config_activate_children(self, act);
		break;
	case DVACT_RESUME:
		if (ifp->if_flags & IFF_UP)
			rl_init(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

int
rl_miibus_readreg(struct device *self, int phy, int reg)
{
	struct rl_softc		*sc = (struct rl_softc *)self;
	struct rl_mii_frame	frame;
	u_int16_t		rl8139_reg;

	if (sc->rl_type == RL_8139) {
		/*
		* The RTL8139 PHY is mapped into PCI registers, unfortunately
		* it has no phyid, or phyaddr, so assume it is phyaddr 0.
		*/
		if (phy != 0)
			return(0);

		switch (reg) {
		case MII_BMCR:
			rl8139_reg = RL_BMCR;
			break;
		case MII_BMSR:
			rl8139_reg = RL_BMSR;
			break;
		case MII_ANAR:
			rl8139_reg = RL_ANAR;
			break;
		case MII_ANER:
			rl8139_reg = RL_ANER;
			break;
		case MII_ANLPAR:
			rl8139_reg = RL_LPAR;
			break;
		case RL_MEDIASTAT:
			return (CSR_READ_1(sc, RL_MEDIASTAT));
		case MII_PHYIDR1:
		case MII_PHYIDR2:
		default:
			return (0);
		}
		return (CSR_READ_2(sc, rl8139_reg));
	}

	bzero(&frame, sizeof(frame));

	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	rl_mii_readreg(sc, &frame);

	return(frame.mii_data);
}

void
rl_miibus_writereg(struct device *self, int phy, int reg, int val)
{
	struct rl_softc		*sc = (struct rl_softc *)self;
	struct rl_mii_frame	frame;
	u_int16_t		rl8139_reg = 0;

	if (sc->rl_type == RL_8139) {
		if (phy)
			return;

		switch (reg) {
		case MII_BMCR:
			rl8139_reg = RL_BMCR;
			break;
		case MII_BMSR:
			rl8139_reg = RL_BMSR;
			break;
		case MII_ANAR:
			rl8139_reg = RL_ANAR;
			break;
		case MII_ANER:
			rl8139_reg = RL_ANER;
			break;
		case MII_ANLPAR:
			rl8139_reg = RL_LPAR;
			break;
		case MII_PHYIDR1:
		case MII_PHYIDR2:
			return;
		}
		CSR_WRITE_2(sc, rl8139_reg, val);
		return;
	}

	bzero(&frame, sizeof(frame));
	frame.mii_phyaddr = phy;
	frame.mii_regaddr = reg;
	frame.mii_data = val;
	rl_mii_writereg(sc, &frame);
}

void
rl_miibus_statchg(struct device *self)
{
}

void
rl_tick(void *v)
{
	struct rl_softc	*sc = v;
	int		s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);

	timeout_add_sec(&sc->sc_tick_tmo, 1);
}

int
rl_detach(struct rl_softc *sc)
{
	struct ifnet	*ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->sc_tick_tmo);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (0);
}

struct cfdriver rl_cd = {
	0, "rl", DV_IFNET
};
@


1.95
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.94 2015/11/25 03:09:58 dlg Exp $ */
d721 1
a721 3
		if (txstat & RL_TXSTAT_TX_OK)
			ifp->if_opackets++;
		else {
@


1.94
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.93 2015/11/24 13:33:17 mpi Exp $ */
a1189 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.93
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.92 2015/10/25 12:48:46 mpi Exp $ */
d738 1
a738 1
		ifp->if_flags &= ~IFF_OACTIVE;
d899 1
a899 1
		ifp->if_flags |= IFF_OACTIVE;
d972 1
a972 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1077 2
a1078 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.92
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.91 2015/06/24 09:40:54 mpi Exp $ */
a98 1
#include <net/if_types.h>
@


1.91
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.90 2015/04/13 08:45:48 mpi Exp $ */
a1009 1
	struct ifaddr	*ifa = (struct ifaddr *) data;
a1018 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.90
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.89 2015/03/30 10:04:11 mpi Exp $ */
a673 2

		ifp->if_ipackets++;
@


1.89
log
@Convert, convert, convert 'em all to if_input(), tralalalala...

Tested by sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.88 2015/03/14 03:38:47 jsg Exp $ */
d646 1
a646 1
			m = m_devget(rxbufpos, wrap, ETHER_ALIGN, ifp);
d657 1
a657 1
			m = m_devget(rxbufpos, total_len, ETHER_ALIGN, ifp);
@


1.88
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.87 2015/01/08 00:49:18 brad Exp $ */
d561 1
d677 1
a677 8
#if NBPFILTER > 0
		/*
		 * Handle BPF listeners. Let the BPF user see the packet.
		 */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		ether_input_mbuf(ifp, m);
d682 2
@


1.87
log
@Use the correct config registers for the RTL8139 family. Unlike the RTL8169
and RTL8168 family, the RTL8139 has different register map for config registers.

From FreeBSD

WoL bits reviewed and tested by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.86 2014/12/22 02:28:51 tedu Exp $ */
a98 1
#include <net/if_dl.h>
@


1.86
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.85 2014/12/08 10:58:45 brad Exp $ */
d977 1
a977 1
	CSR_WRITE_1(sc, RL_CFG1, RL_CFG1_DRVLOAD|RL_CFG1_FULLDUPLEX);
d1120 7
@


1.85
log
@Have foo_init() call foo_reset() to reset the chip to a known state
as is the case for a lot of the other drivers. Remove some redundant
calls to foo_stop() and foo_reset() before foo_init().

Tested with DP83815, 3c905C, 8139 and ST201.
Mostly from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.84 2014/11/24 02:03:37 brad Exp $ */
a101 1
#ifdef INET
a103 1
#endif
a1026 1
#ifdef INET
a1028 1
#endif
@


1.84
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.83 2014/09/06 05:41:35 jsg Exp $ */
a741 1
			rl_reset(sc);
d781 1
a781 2
		if (status & RL_ISR_SYSTEM_ERR) {
			rl_reset(sc);
a782 1
		}
d925 3
@


1.83
log
@reduce the amount of pci includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.82 2014/07/22 13:12:12 mpi Exp $ */
d36 1
a36 1
 * RealTek 8129/8139 PCI NIC driver
d39 1
a39 1
 * the RealTek chipset. Datasheets can be obtained from
d48 1
a48 1
 * The RealTek 8139 PCI NIC redefines the meaning of 'low end.' This is
d590 1
a590 1
		 * RealTek chip is in the process of copying a packet into
d594 1
a594 1
		 * RealTek should be shot for this.
d620 1
a620 1
		 * XXX The RealTek chip includes the CRC with every
d808 1
a808 1
	 * The RealTek is brain damaged and wants longword-aligned
@


1.82
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.81 2013/12/28 03:35:00 deraadt Exp $ */
a116 3
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
@


1.81
log
@The few network drivers that called their children's (ie. mii PHY
drivers) activate functions at DVACT_RESUME time do not need to do
so, since their PHYs are repaired by IFF_UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.80 2013/12/06 21:03:03 deraadt Exp $ */
a103 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.80
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.79 2013/08/21 05:21:43 dlg Exp $ */
a1248 1
		rv = config_activate_children(self, act);
@


1.79
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.78 2013/08/07 01:06:31 bluhm Exp $ */
a1242 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d1252 3
@


1.78
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.77 2013/03/07 01:03:57 brad Exp $ */
d653 1
a653 1
			m = m_devget(rxbufpos, wrap, ETHER_ALIGN, ifp, NULL);
d664 1
a664 2
			m = m_devget(rxbufpos, total_len, ETHER_ALIGN, ifp,
			    NULL);
@


1.77
log
@Fix and simplify determining whether we're using a 8129 or 8139 chipset. Only
the 8129 PCI id is a 8129, everything else is a 8139.

Allows the D-Link DFE-520TX board to work and would ensure proper determination
of the chipset for at least the 8138 based boards (PCI/CardBus).

Tested by kirby@@
Ok kirby@@ sthen@@ chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.76 2012/11/29 21:10:32 brad Exp $ */
a104 1
#include <netinet/in_var.h>
@


1.76
log
@Remove setting an initial assumed baudrate upon driver attach which is not
necessarily correct, there might not even be a link when attaching.

ok mikeb@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.75 2011/06/21 16:52:45 tedu Exp $ */
d1128 1
a1128 1
	u_int16_t	rl_id, rl_did;
a1149 12

	rl_read_eeprom(sc, (caddr_t)&rl_did, RL_EE_PCI_DID, addr_len, 1, 0);

	if (rl_did == RT_DEVICEID_8139 || rl_did == ACCTON_DEVICEID_5030 ||
	    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139 ||
	    rl_did == DLINK_DEVICEID_8139 || rl_did == DLINK_DEVICEID_8139_2 ||
	    rl_did == ABOCOM_DEVICEID_8139)
		sc->rl_type = RL_8139;
	else if (rl_did == RT_DEVICEID_8129)
		sc->rl_type = RL_8129;
	else
		sc->rl_type = RL_UNKNOWN;	/* could be 8138 or other */
@


1.75
log
@remove some unnecessary casts.  ok blambert deraadt kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.74 2010/09/07 16:21:42 deraadt Exp $ */
a1215 1
	ifp->if_baudrate = 10000000;
@


1.74
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.73 2010/08/31 17:13:47 deraadt Exp $ */
d1316 1
a1316 1
	bzero((char *)&frame, sizeof(frame));
d1360 1
a1360 1
	bzero((char *)&frame, sizeof(frame));
@


1.73
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.72 2010/08/27 20:22:13 deraadt Exp $ */
a132 1
void rl_powerhook(int, void *);
a1246 2
	sc->sc_pwrhook = powerhook_establish(rl_powerhook, sc);

a1274 6
void
rl_powerhook(int why, void *arg)
{
	rl_activate(arg, why);
}

a1391 3

	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);
@


1.72
log
@Move the activate function from pci to the the main driver, so that the
powerhook can use it
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.71 2010/07/02 02:40:16 blambert Exp $ */
d1261 3
d1275 1
a1275 1
	return rv;
@


1.71
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.70 2010/05/19 15:27:35 oga Exp $ */
d1253 22
d1278 1
a1278 2
	if (why == PWR_RESUME)
		rl_init(arg);
@


1.70
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.69 2009/12/21 18:14:51 naddy Exp $ */
d658 1
a658 1
				    sc->rl_cdata.rl_rx_buf);
@


1.69
log
@Some cleaning for the rl(4) driver:
- ANSI
- KNF
- remove the use of register

from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.68 2009/11/23 23:49:45 deraadt Exp $ */
d1165 1
a1165 1
	    &sc->sc_rx_seg, 1, &rseg, BUS_DMA_NOWAIT)) {
a1192 2

	bzero(sc->rl_cdata.rl_rx_buf, RL_RXBUFLEN + 32);
@


1.68
log
@in detach, get rid of powerhook before doing sleeping operations
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.67 2009/08/10 20:29:54 deraadt Exp $ */
d175 2
a176 3
void rl_eeprom_putbyte(sc, addr, addr_len)
	struct rl_softc		*sc;
	int			addr, addr_len;
d178 1
a178 1
	register int		d, i;
d202 3
a204 4
void rl_eeprom_getword(sc, addr, addr_len, dest)
	struct rl_softc		*sc;
	int			addr, addr_len;
	u_int16_t		*dest;
d206 2
a207 2
	register int		i;
	u_int16_t		word = 0;
d240 3
a242 7
void rl_read_eeprom(sc, dest, off, addr_len, cnt, swap)
	struct rl_softc		*sc;
	caddr_t			dest;
	int			off;
	int			addr_len;
	int			cnt;
	int			swap;
d244 2
a245 2
	int			i;
	u_int16_t		word = 0, *ptr;
d274 2
a275 2
void rl_mii_sync(sc)
	struct rl_softc		*sc;
d277 1
a277 1
	register int		i;
d292 2
a293 4
void rl_mii_send(sc, bits, cnt)
	struct rl_softc		*sc;
	u_int32_t		bits;
	int			cnt;
d295 1
a295 1
	int			i;
d314 2
a315 3
int rl_mii_readreg(sc, frame)
	struct rl_softc		*sc;
	struct rl_mii_frame	*frame;
d317 1
a317 1
	int			i, ack, s;
d405 2
a406 3
int rl_mii_writereg(sc, frame)
	struct rl_softc		*sc;
	struct rl_mii_frame	*frame;
d408 1
a408 1
	int			s;
d449 2
a450 2
void rl_iff(sc)
	struct rl_softc		*sc;
d502 1
a502 2
rl_reset(sc)
	struct rl_softc		*sc;
d504 1
a504 1
	register int		i;
d522 1
a522 2
rl_list_tx_init(sc)
	struct rl_softc		*sc;
d524 1
a524 1
	struct rl_chain_data	*cd;
a526 1
	cd = &sc->rl_cdata;
d567 1
a567 2
rl_rxeof(sc)
	struct rl_softc		*sc;
d569 9
a577 11
	struct mbuf		*m;
	struct ifnet		*ifp;
	int			total_len;
	u_int32_t		rxstat;
	caddr_t			rxbufpos;
	int			wrap = 0;
	u_int16_t		cur_rx;
	u_int16_t		limit;
	u_int16_t		rx_bytes = 0, max_bytes;

	ifp = &sc->sc_arpcom.ac_if;
d589 1
a589 1
	while((CSR_READ_1(sc, RL_COMMAND) & RL_CMD_EMPTY_RXBUF) == 0) {
d705 2
a706 2
void rl_txeof(sc)
	struct rl_softc		*sc;
d708 2
a709 4
	struct ifnet		*ifp;
	u_int32_t		txstat;

	ifp = &sc->sc_arpcom.ac_if;
d766 2
a767 2
int rl_intr(arg)
	void			*arg;
d769 4
a772 7
	struct rl_softc		*sc;
	struct ifnet		*ifp;
	int			claimed = 0;
	u_int16_t		status;

	sc = arg;
	ifp = &sc->sc_arpcom.ac_if;
d810 2
a811 3
int rl_encap(sc, m_head)
	struct rl_softc		*sc;
	struct mbuf		*m_head;
d813 1
a813 1
	struct mbuf		*m_new;
d868 2
a869 3

void rl_start(ifp)
	struct ifnet		*ifp;
d871 3
a873 5
	struct rl_softc		*sc;
	struct mbuf		*m_head = NULL;
	int			pkts = 0;

	sc = ifp->if_softc;
d875 1
a875 1
	while(RL_CUR_TXMBUF(sc) == NULL) {
d910 1
d923 2
a924 2
void rl_init(xsc)
	void			*xsc;
d926 3
a928 3
	struct rl_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
	int			s;
d1000 2
a1001 2
int rl_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1012 2
a1013 3
void rl_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1022 7
a1028 9
int rl_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
{
	struct rl_softc		*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *) data;
	struct ifaddr		*ifa = (struct ifaddr *) data;
	int			s, error = 0;
d1040 1
a1040 1
#endif /* INET */
d1074 2
a1075 2
void rl_watchdog(ifp)
	struct ifnet		*ifp;
d1077 1
a1077 3
	struct rl_softc		*sc;

	sc = ifp->if_softc;
d1090 2
a1091 2
void rl_stop(sc)
	struct rl_softc		*sc;
d1093 2
a1094 2
	register int		i;
	struct ifnet		*ifp;
a1095 1
	ifp = &sc->sc_arpcom.ac_if;
d1125 1
a1125 2
rl_attach(sc)
	struct rl_softc *sc;
d1127 5
a1131 5
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rseg, i;
	u_int16_t rl_id, rl_did;
	caddr_t kva;
	int addr_len;
d1256 1
a1256 3
rl_powerhook(why, arg)
	int why;
	void *arg;
d1263 5
a1267 7
rl_miibus_readreg(self, phy, reg)
	struct device *self;
	int phy, reg;
{
	struct rl_softc *sc = (struct rl_softc *)self;
	struct rl_mii_frame frame;
	u_int16_t rl8139_reg;
d1313 5
a1317 7
rl_miibus_writereg(self, phy, reg, val)
	struct device *self;
	int phy, reg, val;
{
	struct rl_softc *sc = (struct rl_softc *)self;
	struct rl_mii_frame frame;
	u_int16_t rl8139_reg = 0;
d1355 1
a1355 2
rl_miibus_statchg(self)
	struct device *self;
d1360 1
a1360 2
rl_tick(v)
	void *v;
d1362 2
a1363 2
	struct rl_softc *sc = v;
	int s;
d1368 1
d1375 1
a1375 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.67
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.66 2009/07/21 07:30:18 sthen Exp $ */
d1418 3
a1429 3

	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);
@


1.66
log
@Call timeout_set() from rl_attach, not rl_init(). From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.65 2009/07/18 11:24:39 sthen Exp $ */
a132 1
void rl_shutdown(void *);
a1280 1
	sc->sc_sdhook = shutdownhook_establish(rl_shutdown, sc);
a1286 9
rl_shutdown(arg)
	void			*arg;
{
	struct rl_softc		*sc = (struct rl_softc *)arg;

	rl_stop(sc);
}

void
a1427 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
@


1.65
log
@Rewrite the ioctl handling code and the receive filter
handling to clean up the code and eliminate unnecessary
resets. From Brad, promisc tested by Olivier Cherrier,
promisc/multicast by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.64 2009/06/02 17:27:39 jsg Exp $ */
a1018 1
	timeout_set(&sc->sc_tick_tmo, rl_tick, sc);
d1257 2
@


1.64
log
@make rl at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.63 2009/02/04 19:54:44 claudio Exp $ */
d161 1
a161 1
void rl_setmulti(struct rl_softc *);
d460 1
a460 4
/*
 * Program the 64-bit multicast hash filter.
 */
void rl_setmulti(sc)
d463 1
a463 1
	struct ifnet		*ifp;
d465 1
a465 1
	u_int32_t		hashes[2] = { 0, 0 };
a469 1
	int			mcnt = 0;
d471 4
a474 1
	ifp = &sc->sc_arpcom.ac_if;
d476 5
a480 1
	rxfilt = CSR_READ_4(sc, RL_RXCFG);
d482 2
a483 2
allmulti:
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
d485 17
a501 5
		CSR_WRITE_4(sc, RL_RXCFG, rxfilt);
		CSR_WRITE_4(sc, RL_MAR0, 0xFFFFFFFF);
		CSR_WRITE_4(sc, RL_MAR4, 0xFFFFFFFF);
		return;
	}
d503 1
a503 10
	/* first, zot all the existing hash bits */
	CSR_WRITE_4(sc, RL_MAR0, 0);
	CSR_WRITE_4(sc, RL_MAR4, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
a504 8
		mcnt++;
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
		if (h < 32)
			hashes[0] |= (1 << h);
		else
			hashes[1] |= (1 << (h - 32));
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
a506 6
	if (mcnt)
		rxfilt |= RL_RXCFG_RX_MULTI;
	else
		rxfilt &= ~RL_RXCFG_RX_MULTI;

	CSR_WRITE_4(sc, RL_RXCFG, rxfilt);
d509 1
a953 1
	u_int32_t		rxcfg = 0;
a990 11
	/* Set the individual bit to receive frames for this host only. */
	rxcfg = CSR_READ_4(sc, RL_RXCFG);
	rxcfg |= RL_RXCFG_RX_INDIV;

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		rxcfg |= RL_RXCFG_RX_ALLPHYS;
	else
		rxcfg &= ~RL_RXCFG_RX_ALLPHYS;
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);

d992 1
a992 1
	 * Set capture broadcast bit to capture broadcast frames.
d994 1
a994 10
	if (ifp->if_flags & IFF_BROADCAST)
		rxcfg |= RL_RXCFG_RX_BROAD;
	else
		rxcfg &= ~RL_RXCFG_RX_BROAD;
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);

	/*
	 * Program the multicast filter, if necessary.
	 */
	rl_setmulti(sc);
d1064 2
a1065 1
		switch (ifa->ifa_addr->sa_family) {
d1067 1
a1067 2
		case AF_INET:
			rl_init(sc);
a1068 1
			break;
a1069 4
		default:
			rl_init(sc);
			break;
		}
d1071 1
d1074 4
a1077 1
			rl_init(sc);
a1081 1
		error = 0;
d1083 1
d1088 1
d1095 1
a1095 1
			rl_setmulti(sc);
@


1.63
log
@Do not use m_pullup() because it aligns the data to a word boundary
resulting in unaligned IP headers (because it aligns the ethernet header).
Found the hard way by landry@@ on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.62 2008/11/28 02:44:17 brad Exp $ */
d1446 26
@


1.62
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.61 2008/10/14 18:01:53 naddy Exp $ */
d680 1
a680 3
			if (m == NULL)
				ifp->if_ierrors++;
			else {
d683 4
a686 3
				m = m_pullup(m, sizeof(struct ip));
				if (m == NULL)
					ifp->if_ierrors++;
a691 2
			if (m == NULL)
				ifp->if_ierrors++;
d705 1
@


1.61
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.60 2008/10/02 20:21:13 brad Exp $ */
d1086 1
a1086 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1105 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;
a1114 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				rl_setmulti(sc);
			error = 0;
		}
		break;
d1121 6
@


1.60
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.59 2008/09/10 14:01:22 blambert Exp $ */
d679 1
a679 2
			m = m_devget(rxbufpos - ETHER_ALIGN,
			    wrap + ETHER_ALIGN, 0, ifp, NULL);
d683 3
a685 3
				m_copyback(m, wrap + ETHER_ALIGN,
				     total_len - wrap, sc->rl_cdata.rl_rx_buf);
				m = m_pullup(m, sizeof(struct ip) +ETHER_ALIGN);
a687 2
				else
					m_adj(m, ETHER_ALIGN);
d691 2
a692 2
			m = m_devget(rxbufpos - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
a694 2
			else
				m_adj(m, ETHER_ALIGN);
@


1.59
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.58 2008/04/20 00:23:28 brad Exp $ */
a1095 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

d1148 1
a1148 2
		error = EINVAL;
		break;
a1151 1

@


1.58
log
@Don't bother to call rl_rxeof() twice if both the RX Ok and Err bits are set.

Based on the same change to re(4) quite some time ago.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.57 2008/01/22 09:19:11 brad Exp $ */
d1055 1
a1055 1
	timeout_add(&sc->sc_tick_tmo, hz);
d1476 1
a1476 1
	timeout_add(&sc->sc_tick_tmo, hz);
@


1.57
log
@Add splnet around mii_tick() in rl_tick().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.56 2007/05/08 18:49:32 deraadt Exp $ */
d822 1
a822 3
		if (status & RL_ISR_RX_OK)
			rl_rxeof(sc);
		if (status & RL_ISR_RX_ERR)
@


1.56
log
@rl_detach() is only used for cardbus case
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.55 2007/02/02 04:21:40 jason Exp $ */
d1473 1
d1475 1
d1477 1
@


1.55
log
@up the accepted length to ETHER_MAX_LEN + ETHER_VLAN_ENCAP_LEN on rx; from brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.54 2006/10/15 19:06:38 deraadt Exp $ */
a1343 27

	return (0);
}

int
rl_detach(sc)
	struct rl_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->sc_tick_tmo);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
	if (sc->sc_pwrhook != NULL)
		powerhook_disestablish(sc->sc_pwrhook);
@


1.54
log
@Yet another example of a non-OK'd diff by brad breaking someone's machine.
Brad's bullshit process stops NOW.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.52 2006/09/29 16:04:06 brad Exp $ */
d638 1
a638 1
		    total_len > ETHER_MAX_LEN) {
@


1.53
log
@cosmetic tweaking of the interrupt handler code.
no functional change.
@
text
@a819 1

d822 1
a822 3

		if ((status & RL_ISR_RX_OK) ||
		    (status & RL_ISR_RX_ERR)) {
d824 3
a826 4
			claimed = 1;
		}
		if ((status & RL_ISR_TX_OK) ||
		    (status & RL_ISR_TX_ERR)) {
a827 2
			claimed = 1;
		}
a830 1
			claimed = 1;
d832 1
@


1.52
log
@Discard packets in the receieve handler which are either too short
or too large.

From tsutsui@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.51 2006/09/29 02:40:38 brad Exp $ */
d820 1
d823 3
a825 1
		if (status & RL_ISR_RX_OK)
d827 4
a830 3
		if (status & RL_ISR_RX_ERR)
			rl_rxeof(sc);
		if ((status & RL_ISR_TX_OK) || (status & RL_ISR_TX_ERR))
d832 2
d837 1
a838 1
		claimed = 1;
@


1.51
log
@free the mbuf chain in rl_encap() if MGETHDR, MCLGET or
bus_dmamap_load_mbuf() fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.50 2006/05/22 20:35:12 krw Exp $ */
d636 3
a638 1
		if (!(rxstat & RL_RXSTAT_RXOK)) {
@


1.50
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.49 2006/04/20 20:31:12 miod Exp $ */
a856 1

d858 2
a859 1
	if (m_new == NULL)
d861 1
a863 1

d866 1
d891 1
@


1.49
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.48 2006/03/25 22:41:43 djm Exp $ */
d1363 4
a1366 2
	shutdownhook_disestablish(sc->sc_sdhook);
	powerhook_disestablish(sc->sc_pwrhook);
@


1.48
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.47 2005/11/07 03:20:00 brad Exp $ */
d1292 2
a1293 1
			printf("%s: can't create tx maps\n");
@


1.47
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.46 2005/10/24 00:35:57 brad Exp $ */
d721 1
a721 1
			bpf_mtap(ifp->if_bpf, m);
d929 2
a930 1
			bpf_mtap(ifp->if_bpf, RL_CUR_TXMBUF(sc));
@


1.46
log
@add a comma here.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.45 2005/08/03 16:27:39 brad Exp $ */
d329 1
a329 1
	s = splimp();
d421 1
a421 1
	s = splimp();
d967 1
a967 1
	s = splimp();
d1091 1
a1091 1
	s = splimp();
@


1.45
log
@This commit was derived from a commit to FreeBSD..

Use stream bus space accesses to program the ID (station address)
registers; otherwise, the byte order of the address is changed on
big-endian machines.

Though our bus_space API is different.

Tested by form at pdp-11 dotorg dot ru and robert@@

ok mickey@@ robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.44 2005/07/20 23:02:41 brad Exp $ */
d1239 1
a1239 1
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.44
log
@add a comment explaining why we set the MAC address as we do.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.43 2005/07/20 22:59:52 brad Exp $ */
d980 4
a983 2
	CSR_WRITE_4(sc, RL_IDR0, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[0]));
	CSR_WRITE_4(sc, RL_IDR4, *(u_int32_t *)(&sc->sc_arpcom.ac_enaddr[4]));
@


1.43
log
@fix setting the MAC address in rl_init() so that "ifconfig lladdr" works
as expected.

From form@@ via mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.42 2005/07/02 23:20:05 brad Exp $ */
d974 5
a978 1
	/* Init our MAC address */
@


1.42
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.41 2005/07/02 23:17:36 brad Exp $ */
d964 1
a964 1
	int			s, i;
d975 4
a978 3
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		CSR_WRITE_1(sc, RL_IDR0 + i, sc->sc_arpcom.ac_enaddr[i]);
	}
@


1.41
log
@clear IFF_RUNNING & IFF_OACTIVE in rl_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.40 2005/06/09 03:14:43 brad Exp $ */
d1181 1
a1181 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE)
@


1.40
log
@don't need vlan.h here
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.39 2005/03/04 19:30:43 brad Exp $ */
d1181 2
a1202 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.39
log
@Bring in a number of reliability fixes from FreeBSD' rl(4) driver.
rev's 1.147, 1.134, 1.93, 1.81, 1.72, 1.71

Tested by uwe@@ robert@@ jsg@@ and a few others
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.38 2005/02/22 08:09:23 pefo Exp $ */
a86 1
#include "vlan.h"
@


1.38
log
@Fix a bug causing arches not able to load unaligned to crash in ip input.
m_pullup must be done with a size >= ip header and m_adj must be called
after the pullup so pullup does not kill the header alignment.

Makes mips64, alpha, sparc64 and possibly others happy.

ok from martin, brad and a bunch of others who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.37 2005/02/20 00:41:36 brad Exp $ */
d369 1
a371 1
	ack = CSR_READ_2(sc, RL_MII) & RL_MII_DATAIN;
a742 3
	/* Clear the timeout timer. */
	ifp->if_timer = 0;

d748 2
d757 14
a770 8
		if (RL_LAST_TXMBUF(sc) != NULL) {
			bus_dmamap_sync(sc->sc_dmat, RL_LAST_TXMAP(sc),
			    0, RL_LAST_TXMAP(sc)->dm_mapsize,
			    BUS_DMASYNC_POSTWRITE);
			bus_dmamap_unload(sc->sc_dmat, RL_LAST_TXMAP(sc));
			m_freem(RL_LAST_TXMBUF(sc));
			RL_LAST_TXMBUF(sc) = NULL;
		}
d784 2
a785 6
			/*
			 * If there was a transmit underrun,
			 * bump the TX threshold.
			 */
			if (txstat & RL_TXSTAT_TX_UNDERRUN)
				sc->rl_txthresh = oldthresh + 32;
d791 5
a812 1

d814 4
a817 1
		if (status)
a818 1

a820 1

a822 1

a824 1

a826 1

d942 5
a957 5

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
@


1.37
log
@Don't calculate 'total_len' twice.

Inspired by NetBSD' rtk(4) driver.

From: Mike Pechkin <mpech at mail dot ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.36 2005/01/15 05:24:11 brad Exp $ */
d683 3
a685 4
				m_adj(m, ETHER_ALIGN);
				m_copyback(m, wrap, total_len - wrap,
					sc->rl_cdata.rl_rx_buf);
				m = m_pullup(m, sizeof(struct ether_header));
d688 2
@


1.36
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.35 2004/11/21 18:50:43 brad Exp $ */
d594 1
a594 1
	int			total_len = 0;
d629 2
a630 1
		if ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED) {
a646 1
		total_len = rxstat >> 16;
@


1.35
log
@revert part of rev 1.29 which caused a severe performance drop.

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.34 2004/10/13 22:49:24 miod Exp $ */
d1130 2
a1131 1
			rl_setmulti(sc);
@


1.34
log
@Let the generic rtl code work if the bus-dependent code has decided to attach;
this lets the 8138-based cardbus devices to really attach.

8138-specific mii differences will need to be investigated; right now,
recognizing the 8138 as either 8139 or non-8139 causes it to lose the link
after a while, but nothing ifconfig can not reset...

From a discussion with and tested by Benot Izac, who owns a 8138-based
cardbus device.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.33 2004/09/30 17:59:23 jason Exp $ */
d683 1
a688 2
				else
					m_adj(m, ETHER_ALIGN);
@


1.33
log
@get the MAC address correct on big endian
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.32 2004/09/30 17:41:58 jason Exp $ */
d1240 2
a1241 5
	else {
		printf("\n%s: unknown device id: %x\n", sc->sc_dev.dv_xname,
		    rl_did);
		return (1);
	}
@


1.32
log
@don't need uvm_extern.h for vtophys (no vtophys!)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.31 2004/09/30 17:37:54 jason Exp $ */
d259 1
a259 1
			*ptr = ntohs(word);
d1227 1
a1227 1
	    addr_len, 3, 0);
@


1.31
log
@bus_dma-ify... thanks to robert, jgs, and grange for testing
still borked on sparc64, but hey, one step at a time
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.30 2004/09/30 14:58:02 jason Exp $ */
a116 1
#include <uvm/uvm_extern.h>
@


1.30
log
@rtl8139 doesn't setup ANLPAR if the other side is not NWay compatible,
to try to deduce what the link partner is the hardway.  Based on FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.29 2004/09/28 07:05:50 brad Exp $ */
d117 1
a117 1
#include <uvm/uvm_extern.h>	/* for vtophys */
d616 2
d629 5
a633 1
		if ((u_int16_t)(rxstat >> 16) == RL_RXSTAT_UNFINISHED)
d635 1
d640 3
d663 4
a666 1
		if (rx_bytes > max_bytes)
d668 1
d709 4
a712 1
		if (m == NULL)
d714 1
d726 3
d760 4
d849 1
a849 1
	struct mbuf		*m_new = NULL;
a869 2
	m_freem(m_head);
	m_head = m_new;
d872 1
a872 1
	if (m_head->m_pkthdr.len < RL_MIN_FRAMELEN) {
d879 5
a883 5
		bzero(mtod(m_head, char *) + m_head->m_pkthdr.len,
		    RL_MIN_FRAMELEN - m_head->m_pkthdr.len);
		m_head->m_pkthdr.len +=
		    (RL_MIN_FRAMELEN - m_head->m_pkthdr.len);
		m_head->m_len = m_head->m_pkthdr.len;
d886 6
a891 1
	RL_CUR_TXMBUF(sc) = m_head;
d893 3
d934 1
a934 1
		    vtophys(mtod(RL_CUR_TXMBUF(sc), vaddr_t)));
d937 1
a937 1
		    RL_CUR_TXMBUF(sc)->m_pkthdr.len);
d979 1
a979 1
	CSR_WRITE_4(sc, RL_RXADDR, vtophys((vaddr_t)sc->rl_cdata.rl_rx_buf));
d1187 6
d1208 1
a1208 3
	bus_dma_segment_t seg;
	bus_dmamap_t dmamap;
	int rseg;
d1248 1
a1248 1
	    &seg, 1, &rseg, BUS_DMA_NOWAIT)) {
d1252 2
a1253 2
	if (bus_dmamem_map(sc->sc_dmat, &seg, rseg, RL_RXBUFLEN + 32, &kva,
	    BUS_DMA_NOWAIT)) {
d1256 1
a1256 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d1260 1
a1260 1
	    RL_RXBUFLEN + 32, 0, BUS_DMA_NOWAIT, &dmamap)) {
d1263 1
a1263 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d1266 2
a1267 2
	if (bus_dmamap_load(sc->sc_dmat, dmamap, kva, RL_RXBUFLEN + 32,
	    NULL, BUS_DMA_NOWAIT)) {
d1269 1
a1269 1
		bus_dmamap_destroy(sc->sc_dmat, dmamap);
d1271 1
a1271 1
		bus_dmamem_free(sc->sc_dmat, &seg, rseg);
d1275 2
d1279 12
d1294 1
@


1.29
log
@fixes for 2 cases of unaligned memory access on alpha which
would result in panics.

PR 3795

ok tedu@@
"looks ok" mcbride@@ & dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.27 2004/09/23 17:45:16 brad Exp $ */
d1362 2
d1366 1
a1367 1
			break;
@


1.28
log
@remove if NVLAN around IFCAP_VLAN_MTU
@
text
@a669 1
				m_adj(m, ETHER_ALIGN);
d675 2
d1158 2
a1159 1
			CSR_WRITE_4(sc, RL_TXADDR0 + i, 0x00000000);
@


1.27
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.26 2004/06/06 17:56:36 mcbride Exp $ */
d1254 1
a1254 3
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif
@


1.26
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.25 2004/05/19 11:36:59 brad Exp $ */
a1244 1
	ifp->if_mtu = ETHERMTU;
a1246 1
	ifp->if_output = ether_output;
@


1.25
log
@remove duplication, use ETHER_ALIGN from if_ether.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.24 2004/05/07 01:42:48 tedu Exp $ */
a162 1
u_int8_t rl_calchash(caddr_t);
a462 28
 * Calculate CRC of a multicast group address, return the upper 6 bits.
 */
u_int8_t rl_calchash(addr)
	caddr_t			addr;
{
	u_int32_t		crc, carry;
	int			i, j;
	u_int8_t		c;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (i = 0; i < 6; i++) {
		c = *(addr + i);
		for (j = 0; j < 8; j++) {
			carry = ((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01);
			crc <<= 1;
			c >>= 1;
			if (carry)
				crc = (crc ^ 0x04c11db6) | carry;
		}
	}

	/* return the filter bit position */
	return(crc >> 26);
}

/*
d481 1
d497 4
d502 1
a502 1
		h = rl_calchash(enm->enm_addrlo);
@


1.24
log
@proper casts for vtophys.  looked at by grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.23 2004/04/07 15:47:52 mickey Exp $ */
d689 2
a690 2
			m = m_devget(rxbufpos - RL_ETHER_ALIGN,
			    wrap + RL_ETHER_ALIGN, 0, ifp, NULL);
d694 1
a694 1
				m_adj(m, RL_ETHER_ALIGN);
d703 2
a704 2
			m = m_devget(rxbufpos - RL_ETHER_ALIGN,
			    total_len + RL_ETHER_ALIGN, 0, ifp, NULL);
d708 1
a708 1
				m_adj(m, RL_ETHER_ALIGN);
@


1.23
log
@attach on abocom's 8139; from Kimmo Sinkko <kimmo@@sinkko.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.22 2003/10/21 18:58:49 jmc Exp $ */
d926 1
a926 1
		    vtophys(mtod(RL_CUR_TXMBUF(sc), caddr_t)));
d971 1
a971 1
	CSR_WRITE_4(sc, RL_RXADDR, vtophys(sc->rl_cdata.rl_rx_buf));
@


1.22
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.21 2003/10/01 23:37:12 fgsch Exp $ */
d1223 2
a1224 1
	    rl_did == DLINK_DEVICEID_8139 || rl_did == DLINK_DEVICEID_8139_2)
@


1.21
log
@it turned that only adding the cardbus part was not enough to have
D-Link DFE690 working. add the missing bits here.
from Joshua Johnson <joshua.johnson at charter dot net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.20 2003/02/11 19:20:27 mickey Exp $ */
d597 1
a597 1
 * is preceeded by a 32-bit RX status word which specifies the length
d610 1
a610 1
 * bytes of space preceecing it so that it will be safe for us to do the
d874 1
a874 1
		 * Make security concious people happy: zero out the
d1365 1
a1365 1
		* The RTL8139 PHY is mapped into PCI registers, unforunately
@


1.20
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.19 2002/10/15 16:02:10 mickey Exp $ */
d1222 2
a1223 2
	    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139
	    || rl_did == DLINK_DEVICEID_8139)
@


1.19
log
@re-init the hw on resume, from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.18 2002/07/02 19:38:55 nate Exp $ */
d71 1
a71 1
 * performance at 100Mbps, unless you happen to have a 400Mhz PII or
@


1.18
log
@inital -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.17 2002/06/09 03:14:18 todd Exp $ */
d136 1
d1306 1
d1331 1
d1336 2
a1337 1
void rl_shutdown(arg)
d1343 9
@


1.17
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.16 2002/06/08 00:10:54 aaron Exp $ */
d981 1
a981 1
	 * Set the inital TX and RX configuration.
@


1.16
log
@Add support for RealTek 8129/8139-based CardBus cards; mostly from NetBSD.
deraadt@@, jasoni@@ ok. Thanks to niklas@@ for donating a card for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.15 2002/06/07 18:32:51 art Exp $ */
d499 1
a499 1
	struct arpcom		*ac = &sc->arpcom;
d505 1
a505 1
	ifp = &sc->arpcom.ac_if;
d626 1
a626 1
	ifp = &sc->arpcom.ac_if;
d743 1
a743 1
	ifp = &sc->arpcom.ac_if;
d799 1
a799 1
	ifp = &sc->arpcom.ac_if;
d953 1
a953 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d966 1
a966 1
		CSR_WRITE_1(sc, RL_IDR0 + i, sc->arpcom.ac_enaddr[i]);
d1076 1
a1076 1
	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
d1088 1
a1088 1
			arp_ifinit(&sc->arpcom, ifa);
d1115 2
a1116 2
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
d1165 1
a1165 1
	ifp = &sc->arpcom.ac_if;
d1191 1
a1191 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d1213 1
a1213 1
	rl_read_eeprom(sc, (caddr_t)sc->arpcom.ac_enaddr, RL_EE_EADDR,
d1216 1
a1216 1
	printf(" address %s\n", ether_sprintf(sc->arpcom.ac_enaddr));
d1313 1
a1313 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
@


1.15
log
@Don't try to send a packet we don't have if rl_encap fails.
Tested by noone, the bug reporter didn't respond. could fix kernel/2731
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.14 2002/03/14 01:26:55 millert Exp $ */
d149 3
a151 3
void rl_eeprom_putbyte(struct rl_softc *, int);
void rl_eeprom_getword(struct rl_softc *, int, u_int16_t *);
void rl_read_eeprom(struct rl_softc *, caddr_t, int, int, int);
d178 1
a178 1
void rl_eeprom_putbyte(sc, addr)
d180 1
a180 1
	int			addr;
d184 1
a184 1
	d = addr | RL_EECMD_READ;
d189 2
a190 2
	for (i = 0x400; i; i >>= 1) {
		if (d & i)
d206 1
a206 1
void rl_eeprom_getword(sc, addr, dest)
d208 1
a208 1
	int			addr;
d220 1
a220 1
	rl_eeprom_putbyte(sc, addr);
d227 1
a227 1
	for (i = 0x8000; i; i >>= 1) {
d231 1
a231 1
			word |= i;
d245 1
a245 1
void rl_read_eeprom(sc, dest, off, cnt, swap)
d249 1
d257 1
a257 1
		rl_eeprom_getword(sc, off + i, &word);
a265 1

d1195 1
a1195 1
	u_int16_t rl_did;
d1197 1
d1201 15
a1215 1
	rl_read_eeprom(sc, (caddr_t)sc->arpcom.ac_enaddr, RL_EE_EADDR, 3, 0);
d1218 1
a1218 1
	rl_read_eeprom(sc, (caddr_t)&rl_did, RL_EE_PCI_DID, 1, 0);
d1304 25
a1328 1
	shutdownhook_establish(rl_shutdown, sc);
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.13 2002/02/15 20:45:31 nordin Exp $ */
d909 2
a910 1
		rl_encap(sc, m_head);
@


1.13
log
@Don't cast nonexistent return value from splx to (void). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.12 2002/01/08 05:38:53 fgsch Exp $ */
d134 2
a135 2
void rl_tick		__P((void *));
void rl_shutdown	__P((void *));
d137 1
a137 1
int rl_encap		__P((struct rl_softc *, struct mbuf * ));
d139 27
a165 27
void rl_rxeof		__P((struct rl_softc *));
void rl_txeof		__P((struct rl_softc *));
void rl_start		__P((struct ifnet *));
int rl_ioctl		__P((struct ifnet *, u_long, caddr_t));
void rl_init		__P((void *));
void rl_stop		__P((struct rl_softc *));
void rl_watchdog	__P((struct ifnet *));
int rl_ifmedia_upd	__P((struct ifnet *));
void rl_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

void rl_eeprom_putbyte	__P((struct rl_softc *, int));
void rl_eeprom_getword	__P((struct rl_softc *, int, u_int16_t *));
void rl_read_eeprom	__P((struct rl_softc *, caddr_t, int, int, int));

void rl_mii_sync	__P((struct rl_softc *));
void rl_mii_send	__P((struct rl_softc *, u_int32_t, int));
int rl_mii_readreg	__P((struct rl_softc *, struct rl_mii_frame *));
int rl_mii_writereg	__P((struct rl_softc *, struct rl_mii_frame *));

int rl_miibus_readreg	__P((struct device *, int, int));
void rl_miibus_writereg	__P((struct device *, int, int, int));
void rl_miibus_statchg	__P((struct device *));

u_int8_t rl_calchash	__P((caddr_t));
void rl_setmulti	__P((struct rl_softc *));
void rl_reset		__P((struct rl_softc *));
int rl_list_tx_init	__P((struct rl_softc *));
@


1.12
log
@SIOCSIFMTU support; patches by Claudio Castiglia <ccastig@@softhome.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.11 2001/11/06 19:53:18 miod Exp $ */
d1031 1
a1031 1
	(void)splx(s);
d1135 1
a1135 1
	(void)splx(s);
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.10 2001/10/24 16:56:56 mickey Exp $ */
d1093 7
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.12 2002/01/08 05:38:53 fgsch Exp $ */
a1092 7
		}
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.11.2.1 2002/01/31 22:55:32 niklas Exp $ */
d134 2
a135 2
void rl_tick(void *);
void rl_shutdown(void *);
d137 1
a137 1
int rl_encap(struct rl_softc *, struct mbuf * );
d139 27
a165 27
void rl_rxeof(struct rl_softc *);
void rl_txeof(struct rl_softc *);
void rl_start(struct ifnet *);
int rl_ioctl(struct ifnet *, u_long, caddr_t);
void rl_init(void *);
void rl_stop(struct rl_softc *);
void rl_watchdog(struct ifnet *);
int rl_ifmedia_upd(struct ifnet *);
void rl_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void rl_eeprom_getword(struct rl_softc *, int, int, u_int16_t *);
void rl_eeprom_putbyte(struct rl_softc *, int, int);
void rl_read_eeprom(struct rl_softc *, caddr_t, int, int, int, int);

void rl_mii_sync(struct rl_softc *);
void rl_mii_send(struct rl_softc *, u_int32_t, int);
int rl_mii_readreg(struct rl_softc *, struct rl_mii_frame *);
int rl_mii_writereg(struct rl_softc *, struct rl_mii_frame *);

int rl_miibus_readreg(struct device *, int, int);
void rl_miibus_writereg(struct device *, int, int, int);
void rl_miibus_statchg(struct device *);

u_int8_t rl_calchash(caddr_t);
void rl_setmulti(struct rl_softc *);
void rl_reset(struct rl_softc *);
int rl_list_tx_init(struct rl_softc *);
d178 1
a178 1
void rl_eeprom_putbyte(sc, addr, addr_len)
d180 1
a180 1
	int			addr, addr_len;
d184 1
a184 1
	d = (RL_EECMD_READ << addr_len) | addr;
d189 2
a190 2
	for (i = RL_EECMD_LEN + addr_len; i; i--) {
		if (d & (1 << (i - 1)))
d206 1
a206 1
void rl_eeprom_getword(sc, addr, addr_len, dest)
d208 1
a208 1
	int			addr, addr_len;
d220 1
a220 1
	rl_eeprom_putbyte(sc, addr, addr_len);
d227 1
a227 1
	for (i = 16; i > 0; i--) {
d231 1
a231 1
			word |= 1 << (i - 1);
d245 1
a245 1
void rl_read_eeprom(sc, dest, off, addr_len, cnt, swap)
a248 1
	int			addr_len;
d256 1
a256 1
		rl_eeprom_getword(sc, off + i, addr_len, &word);
d265 1
d499 1
a499 1
	struct arpcom		*ac = &sc->sc_arpcom;
d505 1
a505 1
	ifp = &sc->sc_arpcom.ac_if;
d626 1
a626 1
	ifp = &sc->sc_arpcom.ac_if;
d743 1
a743 1
	ifp = &sc->sc_arpcom.ac_if;
d799 1
a799 1
	ifp = &sc->sc_arpcom.ac_if;
d909 1
a909 2
		if (rl_encap(sc, m_head))
			break;
d952 1
a952 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d965 1
a965 1
		CSR_WRITE_1(sc, RL_IDR0 + i, sc->sc_arpcom.ac_enaddr[i]);
d1031 1
a1031 1
	splx(s);
d1075 1
a1075 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1087 1
a1087 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1114 2
a1115 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1135 1
a1135 1
	splx(s);
d1164 1
a1164 1
	ifp = &sc->sc_arpcom.ac_if;
d1190 1
a1190 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1194 1
a1194 1
	u_int16_t rl_id, rl_did;
a1195 1
	int addr_len;
d1199 2
a1200 16
	/*
	 * Check EEPROM type 9346 or 9356.
	 */
	rl_read_eeprom(sc, (caddr_t)&rl_id, RL_EE_ID, RL_EEADDR_LEN1, 1, 0);
	if (rl_id == 0x8129)
		addr_len = RL_EEADDR_LEN1;
	else
		addr_len = RL_EEADDR_LEN0;

	/*
	 * Get station address.
	 */
	rl_read_eeprom(sc, (caddr_t)sc->sc_arpcom.ac_enaddr, RL_EE_EADDR,
	    addr_len, 3, 0);

	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d1202 1
a1202 1
	rl_read_eeprom(sc, (caddr_t)&rl_did, RL_EE_PCI_DID, addr_len, 1, 0);
d1288 1
a1288 25
	sc->sc_sdhook = shutdownhook_establish(rl_shutdown, sc);

	return (0);
}

int
rl_detach(sc)
	struct rl_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->sc_tick_tmo);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	shutdownhook_disestablish(sc->sc_sdhook);
@


1.11.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.11.2.2 2002/06/11 03:42:20 art Exp $ */
a135 1
void rl_powerhook(int, void *);
d981 1
a981 1
	 * Set the initial TX and RX configuration.
a1304 1
	sc->sc_pwrhook = powerhook_establish(rl_powerhook, sc);
a1328 1
	powerhook_disestablish(sc->sc_pwrhook);
d1333 1
a1333 2
void
rl_shutdown(arg)
a1338 9
}

void
rl_powerhook(why, arg)
	int why;
	void *arg;
{
	if (why == PWR_RESUME)
		rl_init(arg);
@


1.11.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d71 1
a71 1
 * performance at 100Mbps, unless you happen to have a 400MHz PII or
@


1.10
log
@cleanup, such as spaces and dangling return;s
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.9 2001/09/11 20:05:25 miod Exp $ */
d117 1
a117 1
#include <vm/vm.h>	/* for vtophys */
@


1.9
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.8 2001/08/12 20:12:12 mickey Exp $ */
d117 1
a117 1
#include <vm/vm.h>              /* for vtophys */
d190 1
a190 1
		if (d & i) {
d192 1
a192 1
		} else {
d194 1
a194 1
		}
a200 2

	return;
a239 2

	return;
a262 2

	return;
a295 2

	return;
d311 1
a311 1
                if (bits & i) {
d313 1
a313 1
                } else {
a314 1
                }
a327 1
	
d340 1
a340 1
	
d344 1
a344 1
 	 * Turn on data xmit.
a419 1
	
d431 1
a431 1
	
d433 1
a433 1
 	 * Turn on data output.
a541 2

	return;
d544 2
a545 1
void rl_reset(sc)
a559 1
        return;
d565 2
a566 1
int rl_list_tx_init(sc)
d612 2
a613 1
void rl_rxeof(sc)
d616 2
a617 2
        struct mbuf		*m;
        struct ifnet		*ifp;
d652 1
a652 1
	
d659 1
a659 1
		/* No errors; receive the packet. */	
d667 1
a667 1
	 	 * the manual that explains how to do it) so we have
a730 2

	return;
d922 1
a922 1
	 	 */
a945 2

	return;
d990 1
a990 1
	if (ifp->if_flags & IFF_PROMISC) {
d992 1
a992 2
		CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
	} else {
d994 1
a994 2
		CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
	}
d999 1
a999 1
	if (ifp->if_flags & IFF_BROADCAST) {
d1001 1
a1001 2
		CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
	} else {
d1003 1
a1003 2
		CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
	}
a1034 2

	return;
a1144 2

	return;
a1176 2

	return;
d1256 1
a1256 1
	ifp->if_capabilities |= IFCAP_VLAN_MTU; 
d1305 3
a1307 3
	 	* The RTL8139 PHY is mapped into PCI registers, unforunately
	 	* it has no phyid, or phyaddr, so assume it is phyaddr 0.
	 	*/
a1391 1
	return;
@


1.8
log
@remove some of the redundant vm includes
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.7 2001/08/03 23:26:04 chris Exp $ */
a117 1
#include <vm/vm_kern.h>
@


1.7
log
@Set IFCAP_VLAN_MTU, the Realtek chip does not discard/truncate large frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.6 2001/07/08 23:38:06 fgsch Exp $ */
a117 1
#include <vm/pmap.h>            /* for vtophys */
a118 1
#include <vm/vm_extern.h>
@


1.6
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.5 2001/06/27 06:34:43 kjc Exp $ */
d87 1
d1282 4
@


1.5
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.4 2001/06/23 23:17:35 fgsch Exp $ */
a1277 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.4
log
@ether_input_mbuf().
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.3 2001/05/22 11:35:16 mickey Exp $ */
d847 1
a847 1
	if (ifp->if_snd.ifq_head != NULL)
d914 1
d919 1
a919 1
		IF_DEQUEUE(&ifp->if_snd, m_head);
d925 1
d946 2
d1278 2
a1279 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
@


1.3
log
@support for D-Link DFE-530TX and DFE-530TX+; from Maxim Tsyplakov <tm@@oganer.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.2 2001/04/13 15:58:43 aaron Exp $ */
a628 1
        struct ether_header	*eh;
a732 1
		eh = mtod(m, struct ether_header *);
d742 1
a742 3
		/* Remove header from mbuf and pass it on. */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.2
log
@Define RL_USEIOSPACE in the PCI bus piece, not the common piece; thanks jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.1 2001/04/10 22:52:00 aaron Exp $ */
d1225 2
a1226 1
	    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139)
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.2 2001/04/13 15:58:43 aaron Exp $ */
@


1.2.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.2.4.1 2001/05/14 22:24:10 niklas Exp $ */
d629 1
d734 1
d744 3
a746 1
		ether_input_mbuf(ifp, m);
d851 1
a851 1
	if (!IFQ_IS_EMPTY(&ifp->if_snd))
a917 1
	int			pkts = 0;
d922 1
a922 1
		IFQ_DEQUEUE(&ifp->if_snd, m_head);
a927 1
		pkts++;
a947 2
	if (pkts == 0)
		return;
d1225 1
a1225 2
	    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139
	    || rl_did == DLINK_DEVICEID_8139)
d1277 1
a1277 2
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);
@


1.2.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9.c,v 1.2.4.2 2001/07/04 10:41:06 niklas Exp $ */
a86 1
#include "vlan.h"
d116 4
a119 1
#include <vm/vm.h>	/* for vtophys */
d192 1
a192 1
		if (d & i)
d194 1
a194 1
		else
d196 1
a196 1

d203 2
d244 2
d269 2
d304 2
d321 1
a321 1
		if (bits & i)
d323 1
a323 1
		else
d325 1
d339 1
d352 1
a352 1

d356 1
a356 1
	 * Turn on data xmit.
d432 1
d444 1
a444 1

d446 1
a446 1
	 * Turn on data output.
d555 2
d559 1
a559 2
void
rl_reset(sc)
d574 1
d580 1
a580 2
int
rl_list_tx_init(sc)
d626 1
a626 2
void
rl_rxeof(sc)
d629 2
a630 2
	struct mbuf		*m;
	struct ifnet		*ifp;
d665 1
a665 1

d672 1
a672 1
		/* No errors; receive the packet. */
d680 1
a680 1
		 * the manual that explains how to do it) so we have
d744 2
d937 1
a937 1
		 */
d961 2
d1007 1
a1007 1
	if (ifp->if_flags & IFF_PROMISC)
d1009 2
a1010 1
	else
d1012 2
a1013 1
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
d1018 1
a1018 1
	if (ifp->if_flags & IFF_BROADCAST)
d1020 2
a1021 1
	else
d1023 2
a1024 1
	CSR_WRITE_4(sc, RL_RXCFG, rxcfg);
d1056 2
d1168 2
d1202 2
d1278 1
a1282 4
#if NVLAN > 0
	ifp->if_capabilities |= IFCAP_VLAN_MTU;
#endif

d1329 3
a1331 3
		* The RTL8139 PHY is mapped into PCI registers, unforunately
		* it has no phyid, or phyaddr, so assume it is phyaddr 0.
		*/
d1416 1
@


1.2.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d117 1
a117 1
#include <uvm/uvm_extern.h>	/* for vtophys */
@


1.2.4.5
log
@Merge in trunk
@
text
@d1031 1
a1031 1
	splx(s);
a1094 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;
d1128 1
a1128 1
	splx(s);
@


1.2.4.6
log
@Merge in -current from about a week ago
@
text
@d134 2
a135 2
void rl_tick(void *);
void rl_shutdown(void *);
d137 1
a137 1
int rl_encap(struct rl_softc *, struct mbuf * );
d139 27
a165 27
void rl_rxeof(struct rl_softc *);
void rl_txeof(struct rl_softc *);
void rl_start(struct ifnet *);
int rl_ioctl(struct ifnet *, u_long, caddr_t);
void rl_init(void *);
void rl_stop(struct rl_softc *);
void rl_watchdog(struct ifnet *);
int rl_ifmedia_upd(struct ifnet *);
void rl_ifmedia_sts(struct ifnet *, struct ifmediareq *);

void rl_eeprom_putbyte(struct rl_softc *, int);
void rl_eeprom_getword(struct rl_softc *, int, u_int16_t *);
void rl_read_eeprom(struct rl_softc *, caddr_t, int, int, int);

void rl_mii_sync(struct rl_softc *);
void rl_mii_send(struct rl_softc *, u_int32_t, int);
int rl_mii_readreg(struct rl_softc *, struct rl_mii_frame *);
int rl_mii_writereg(struct rl_softc *, struct rl_mii_frame *);

int rl_miibus_readreg(struct device *, int, int);
void rl_miibus_writereg(struct device *, int, int, int);
void rl_miibus_statchg(struct device *);

u_int8_t rl_calchash(caddr_t);
void rl_setmulti(struct rl_softc *);
void rl_reset(struct rl_softc *);
int rl_list_tx_init(struct rl_softc *);
@


1.2.4.7
log
@Sync the SMP branch with 3.3
@
text
@d71 1
a71 1
 * performance at 100Mbps, unless you happen to have a 400MHz PII or
a135 1
void rl_powerhook(int, void *);
d149 3
a151 3
void rl_eeprom_getword(struct rl_softc *, int, int, u_int16_t *);
void rl_eeprom_putbyte(struct rl_softc *, int, int);
void rl_read_eeprom(struct rl_softc *, caddr_t, int, int, int, int);
d178 1
a178 1
void rl_eeprom_putbyte(sc, addr, addr_len)
d180 1
a180 1
	int			addr, addr_len;
d184 1
a184 1
	d = (RL_EECMD_READ << addr_len) | addr;
d189 2
a190 2
	for (i = RL_EECMD_LEN + addr_len; i; i--) {
		if (d & (1 << (i - 1)))
d206 1
a206 1
void rl_eeprom_getword(sc, addr, addr_len, dest)
d208 1
a208 1
	int			addr, addr_len;
d220 1
a220 1
	rl_eeprom_putbyte(sc, addr, addr_len);
d227 1
a227 1
	for (i = 16; i > 0; i--) {
d231 1
a231 1
			word |= 1 << (i - 1);
d245 1
a245 1
void rl_read_eeprom(sc, dest, off, addr_len, cnt, swap)
a248 1
	int			addr_len;
d256 1
a256 1
		rl_eeprom_getword(sc, off + i, addr_len, &word);
d265 1
d499 1
a499 1
	struct arpcom		*ac = &sc->sc_arpcom;
d505 1
a505 1
	ifp = &sc->sc_arpcom.ac_if;
d626 1
a626 1
	ifp = &sc->sc_arpcom.ac_if;
d743 1
a743 1
	ifp = &sc->sc_arpcom.ac_if;
d799 1
a799 1
	ifp = &sc->sc_arpcom.ac_if;
d909 1
a909 2
		if (rl_encap(sc, m_head))
			break;
d952 1
a952 1
	struct ifnet		*ifp = &sc->sc_arpcom.ac_if;
d965 1
a965 1
		CSR_WRITE_1(sc, RL_IDR0 + i, sc->sc_arpcom.ac_enaddr[i]);
d980 1
a980 1
	 * Set the initial TX and RX configuration.
d1075 1
a1075 1
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, command, data)) > 0) {
d1087 1
a1087 1
			arp_ifinit(&sc->sc_arpcom, ifa);
d1114 2
a1115 2
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);
d1164 1
a1164 1
	ifp = &sc->sc_arpcom.ac_if;
d1190 1
a1190 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d1194 1
a1194 1
	u_int16_t rl_id, rl_did;
a1195 1
	int addr_len;
d1199 2
a1200 14
	/*
	 * Check EEPROM type 9346 or 9356.
	 */
	rl_read_eeprom(sc, (caddr_t)&rl_id, RL_EE_ID, RL_EEADDR_LEN1, 1, 0);
	if (rl_id == 0x8129)
		addr_len = RL_EEADDR_LEN1;
	else
		addr_len = RL_EEADDR_LEN0;

	/*
	 * Get station address.
	 */
	rl_read_eeprom(sc, (caddr_t)sc->sc_arpcom.ac_enaddr, RL_EE_EADDR,
	    addr_len, 3, 0);
d1202 1
a1202 3
	printf(" address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	rl_read_eeprom(sc, (caddr_t)&rl_did, RL_EE_PCI_DID, addr_len, 1, 0);
d1288 1
a1288 27
	sc->sc_sdhook = shutdownhook_establish(rl_shutdown, sc);
	sc->sc_pwrhook = powerhook_establish(rl_powerhook, sc);

	return (0);
}

int
rl_detach(sc)
	struct rl_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* Unhook our tick handler. */
	timeout_del(&sc->sc_tick_tmo);

	/* Detach any PHYs we might have. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys) != NULL)
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);

	/* Delete any remaining media. */
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	ether_ifdetach(ifp);
	if_detach(ifp);

	shutdownhook_disestablish(sc->sc_sdhook);
	powerhook_disestablish(sc->sc_pwrhook);
d1293 1
a1293 2
void
rl_shutdown(arg)
a1298 9
}

void
rl_powerhook(why, arg)
	int why;
	void *arg;
{
	if (why == PWR_RESUME)
		rl_init(arg);
@


1.2.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d597 1
a597 1
 * is preceded by a 32-bit RX status word which specifies the length
d610 1
a610 1
 * bytes of space preceding it so that it will be safe for us to do the
d874 1
a874 1
		 * Make security-conscious people happy: zero out the
d1222 2
a1223 2
	    rl_did == DELTA_DEVICEID_8139 || rl_did == ADDTRON_DEVICEID_8139 ||
	    rl_did == DLINK_DEVICEID_8139 || rl_did == DLINK_DEVICEID_8139_2)
d1365 1
a1365 1
		* The RTL8139 PHY is mapped into PCI registers, unfortunately
@


1.2.4.9
log
@Merge with the trunk
@
text
@d689 2
a690 2
			m = m_devget(rxbufpos - ETHER_ALIGN,
			    wrap + ETHER_ALIGN, 0, ifp, NULL);
d694 1
a694 1
				m_adj(m, ETHER_ALIGN);
d703 2
a704 2
			m = m_devget(rxbufpos - ETHER_ALIGN,
			    total_len + ETHER_ALIGN, 0, ifp, NULL);
d708 1
a708 1
				m_adj(m, ETHER_ALIGN);
d926 1
a926 1
		    vtophys(mtod(RL_CUR_TXMBUF(sc), vaddr_t)));
d971 1
a971 1
	CSR_WRITE_4(sc, RL_RXADDR, vtophys((vaddr_t)sc->rl_cdata.rl_rx_buf));
d1223 1
a1223 2
	    rl_did == DLINK_DEVICEID_8139 || rl_did == DLINK_DEVICEID_8139_2 ||
	    rl_did == ABOCOM_DEVICEID_8139)
@


1.2.4.10
log
@sync to head
@
text
@d163 1
d464 28
a509 1
allmulti:
a524 4
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi, ETHER_ADDR_LEN)) {
			ifp->if_flags |= IFF_ALLMULTI;
			goto allmulti;
		}
d526 1
a526 1
		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
@


1.1
log
@Split RealTek 8129/8139 driver into bus-dependent and bus-independent parts;
prep for an rl CardBus attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a126 10

/*
 * Default to using PIO access for this driver. On SMP systems,
 * there appear to be problems with memory mapped mode: it looks like
 * doing too many memory mapped access back to back in rapid succession
 * can hang the bus. I'm inclined to blame this on crummy design/construction
 * on the part of RealTek. Memory mapped mode does appear to work on
 * uniprocessor systems though.
 */
#define RL_USEIOSPACE
@

