head	1.100;
access;
symbols
	OPENBSD_6_2:1.100.0.2
	OPENBSD_6_2_BASE:1.100
	OPENBSD_6_1:1.100.0.4
	OPENBSD_6_1_BASE:1.100
	OPENBSD_6_0:1.98.0.4
	OPENBSD_6_0_BASE:1.98
	OPENBSD_5_9:1.97.0.2
	OPENBSD_5_9_BASE:1.97
	OPENBSD_5_8:1.94.0.4
	OPENBSD_5_8_BASE:1.94
	OPENBSD_5_7:1.92.0.4
	OPENBSD_5_7_BASE:1.92
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.76.0.2
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.75.0.4
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.75.0.2
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.6
	OPENBSD_5_0:1.74.0.2
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.68.0.2
	OPENBSD_4_8_BASE:1.68
	OPENBSD_4_7:1.67.0.2
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.43.0.2
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.7
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.100
date	2016.11.16.01.27.45;	author dlg;	state Exp;
branches;
next	1.99;
commitid	xQXfkZeR3MsQw2Wf;

1.99
date	2016.11.16.01.15.37;	author dlg;	state Exp;
branches;
next	1.98;
commitid	CSqqHhDNt5fB7T3p;

1.98
date	2016.04.20.12.15.24;	author sthen;	state Exp;
branches;
next	1.97;
commitid	z2wRR15tm4E4bguy;

1.97
date	2015.12.28.05.49.15;	author jmatthew;	state Exp;
branches;
next	1.96;
commitid	3iekWyKLzVgfNIj7;

1.96
date	2015.11.02.00.08.50;	author dlg;	state Exp;
branches;
next	1.95;
commitid	3h4FftdbNE7umRAE;

1.95
date	2015.09.04.07.05.44;	author jsg;	state Exp;
branches;
next	1.94;
commitid	v8PHprKwtlUtXJqB;

1.94
date	2015.04.09.02.08.55;	author dlg;	state Exp;
branches;
next	1.93;
commitid	ax027k1jgfLvG0Jy;

1.93
date	2015.03.20.12.04.09;	author dlg;	state Exp;
branches;
next	1.92;
commitid	VrV6I9fEf1yjTS3Y;

1.92
date	2015.03.08.01.54.04;	author tobiasu;	state Exp;
branches;
next	1.91;
commitid	id3E1oxJP4q7yqir;

1.91
date	2015.01.26.09.58.47;	author brad;	state Exp;
branches;
next	1.90;
commitid	AppNYocFYbD7Hqgj;

1.90
date	2015.01.20.04.33.06;	author brad;	state Exp;
branches;
next	1.89;
commitid	PR9rT5rnaoFwMdGp;

1.89
date	2015.01.08.00.49.18;	author brad;	state Exp;
branches;
next	1.88;
commitid	VH7cwj1b7ZDYWwH1;

1.88
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.87;
commitid	Wmnzf8bGQILqXRTG;

1.87
date	2014.11.19.02.37.41;	author brad;	state Exp;
branches;
next	1.86;
commitid	WKJHAIeAQjfthtO9;

1.86
date	2014.09.06.04.46.58;	author brad;	state Exp;
branches;
next	1.85;
commitid	NjpaYKN1EE5jORe8;

1.85
date	2014.07.08.05.35.18;	author dlg;	state Exp;
branches;
next	1.84;
commitid	0QJleeeWqZmC5anF;

1.84
date	2014.04.23.03.37.29;	author jsg;	state Exp;
branches;
next	1.83;

1.83
date	2014.04.23.03.20.55;	author jsg;	state Exp;
branches;
next	1.82;

1.82
date	2014.04.23.02.58.06;	author jsg;	state Exp;
branches;
next	1.81;

1.81
date	2014.04.23.02.39.28;	author jsg;	state Exp;
branches;
next	1.80;

1.80
date	2014.03.13.13.11.30;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2014.03.08.22.37.32;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2013.11.18.22.21.27;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2013.10.11.14.00.18;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.17.20.47.23;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2012.04.08.08.34.55;	author jsg;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.14.21.06.38;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2011.03.13.15.35.20;	author stsp;	state Exp;
branches;
next	1.72;

1.72
date	2010.11.28.22.08.59;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2010.11.12.22.17.30;	author sthen;	state Exp;
branches;
next	1.70;

1.70
date	2010.09.07.16.21.43;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2010.08.27.20.22.13;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2010.06.28.16.04.09;	author sthen;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2009.07.23.20.15.32;	author kettenis;	state Exp;
branches;
next	1.65;

1.65
date	2009.07.11.16.51.58;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2009.07.10.21.27.49;	author sthen;	state Exp;
branches;
next	1.63;

1.63
date	2009.07.03.16.55.27;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.03.00.11.19;	author sthen;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.02.17.27.39;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.12.11.55.29;	author martynas;	state Exp;
branches;
next	1.59;

1.59
date	2008.11.30.06.01.45;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.08.06.52.49;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.08.03.49.27;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.11.23.49.05;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.06.00.34.10;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.05.22.43.40;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.05.22.32.11;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.27.20.38.59;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.13.03.59.16;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.11.22.42.19;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.15.13.21.17;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.13.05.24.05;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2008.04.20.01.18.02;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2008.04.20.01.15.40;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2008.04.20.00.42.27;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2008.04.20.00.34.39;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2008.02.17.05.29.25;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.01.16.09.52.34;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.07.12.19.19;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.16.19.15.01;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.06.22.02.31;	author pvalchev;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.06.18.51.19;	author pvalchev;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.08.18.49.32;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.12.12.10.24.38;	author reyk;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.01.01.13.01;	author todd;	state Exp;
branches;
next	1.34;

1.34
date	2006.11.26.10.58.16;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.24.04.27.17;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.18.15.54.29;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.01.23.25.18;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.31.22.45.15;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.31.07.04.25;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.16.19.38.34;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.05.21.38.20;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.05.21.03.22;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.03.02.28.39;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.01.23.39.36;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.27.07.29.23;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.27.05.53.37;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.09.17.00.45.44;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.03.16.27.39;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2005.04.15.03.13.03;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.15.03.03.21;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.13.22.49.24;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.30.17.37.54;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2004.08.05.21.17.20;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.05.20.51.30;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.05.19.57.16;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.05.07.39.54;	author pvalchev;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.05.06.00.46;	author pvalchev;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.19.11.36.59;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.15.47.52;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.01.23.37.12;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.15.16.02.10;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.08.00.10.54;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.23.22.03.08;	author fgsch;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.05.22.11.35.16;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.10.22.52.00;	author aaron;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.24.10;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.41.06;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	1.1.4.6;

1.1.4.6
date	2004.06.05.23.12.43;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.100
log
@move toward having the a tx packet descriptor per tx ring entry.

previously you could have 64 packets on a ring with up to 1024
descriptors. this mismatch makes the accounting for free space
complicated and allows for a data race with OACTIVE being set.
it will also let us push more packets.
@
text
@/*	$OpenBSD: rtl81x9reg.h,v 1.99 2016/11/16 01:15:37 dlg Exp $	*/

/*
 * Copyright (c) 1997, 1998
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/pci/if_rlreg.h,v 1.14 1999/10/21 19:42:03 wpaul Exp $
 */

/*
 * Realtek 8129/8139 register offsets
 */
#define	RL_IDR0		0x0000		/* ID register 0 (station addr) */
#define RL_IDR1		0x0001		/* Must use 32-bit accesses (?) */
#define RL_IDR2		0x0002
#define RL_IDR3		0x0003
#define RL_IDR4		0x0004
#define RL_IDR5		0x0005
					/* 0006-0007 reserved */
#define RL_MAR0		0x0008		/* Multicast hash table */
#define RL_MAR1		0x0009
#define RL_MAR2		0x000A
#define RL_MAR3		0x000B
#define RL_MAR4		0x000C
#define RL_MAR5		0x000D
#define RL_MAR6		0x000E
#define RL_MAR7		0x000F

#define RL_TXSTAT0	0x0010		/* status of TX descriptor 0 */
#define RL_TXSTAT1	0x0014		/* status of TX descriptor 1 */
#define RL_TXSTAT2	0x0018		/* status of TX descriptor 2 */
#define RL_TXSTAT3	0x001C		/* status of TX descriptor 3 */

#define RL_TXADDR0	0x0020		/* address of TX descriptor 0 */
#define RL_TXADDR1	0x0024		/* address of TX descriptor 1 */
#define RL_TXADDR2	0x0028		/* address of TX descriptor 2 */
#define RL_TXADDR3	0x002C		/* address of TX descriptor 3 */

#define RL_RXADDR		0x0030	/* RX ring start address */
#define RL_RX_EARLY_BYTES	0x0034	/* RX early byte count */
#define RL_RX_EARLY_STAT	0x0036	/* RX early status */
#define RL_COMMAND	0x0037		/* command register */
#define RL_CURRXADDR	0x0038		/* current address of packet read */
#define RL_CURRXBUF	0x003A		/* current RX buffer address */
#define RL_IMR		0x003C		/* interrupt mask register */
#define RL_ISR		0x003E		/* interrupt status register */
#define RL_TXCFG	0x0040		/* transmit config */
#define RL_RXCFG	0x0044		/* receive config */
#define RL_TIMERCNT	0x0048		/* timer count register */
#define RL_MISSEDPKT	0x004C		/* missed packet counter */
#define RL_EECMD	0x0050		/* EEPROM command register */

/* RTL8139/RTL8139C+ only */
#define RL_8139_CFG0	0x0051		/* config register #0 */
#define RL_8139_CFG1	0x0052		/* config register #1 */
#define RL_8139_CFG3	0x0059		/* config register #3 */
#define RL_8139_CFG4	0x005A		/* config register #4 */
#define RL_8139_CFG5	0x00D8		/* config register #5 */

#define RL_CFG0		0x0051		/* config register #0 */
#define RL_CFG1		0x0052		/* config register #1 */
#define RL_CFG2		0x0053		/* config register #2 */
#define RL_CFG3		0x0054		/* config register #3 */
#define RL_CFG4		0x0055		/* config register #4 */
#define RL_CFG5		0x0056		/* config register #5 */
					/* 0057 reserved */
#define RL_MEDIASTAT	0x0058		/* media status register (8139) */
					/* 0059-005A reserved */
#define RL_MII		0x005A		/* 8129 chip only */
#define RL_HALTCLK	0x005B
#define RL_MULTIINTR	0x005C		/* multiple interrupt */
#define RL_PCIREV	0x005E		/* PCI revision value */
					/* 005F reserved */
#define RL_TXSTAT_ALL	0x0060		/* TX status of all descriptors */

#define RL_CSIDR	0x0064
#define RL_CSIAR	0x0068

/* Direct PHY access registers only available on 8139 */
#define RL_BMCR		0x0062		/* PHY basic mode control */
#define RL_BMSR		0x0064		/* PHY basic mode status */
#define RL_ANAR		0x0066		/* PHY autoneg advert */
#define RL_LPAR		0x0068		/* PHY link partner ability */
#define RL_ANER		0x006A		/* PHY autoneg expansion */

#define RL_DISCCNT	0x006C		/* disconnect counter */
#define RL_FALSECAR	0x006E		/* false carrier counter */
#define RL_NWAYTST	0x0070		/* NWAY test register */
#define RL_RX_ER	0x0072		/* RX_ER counter */
#define RL_CSCFG	0x0074		/* CS configuration register */

/*
 * When operating in special C+ mode, some of the registers in an
 * 8139C+ chip have different definitions. These are also used for
 * the 8169 gigE chip.
 */
#define RL_DUMPSTATS_LO	0x0010	/* counter dump command register */
#define RL_DUMPSTATS_HI	0x0014	/* counter dump command register */
#define RL_TXLIST_ADDR_LO	0x0020	/* 64 bits, 256 byte alignment */
#define RL_TXLIST_ADDR_HI	0x0024	/* 64 bits, 256 byte alignment */
#define RL_TXLIST_ADDR_HPRIO_LO	0x0028	/* 64 bits, 256 byte aligned */
#define RL_TXLIST_ADDR_HPRIO_HI	0x002C	/* 64 bits, 256 byte aligned */
#define RL_TIMERINT		0x0054	/* interrupt on timer expire */
#define RL_TXSTART		0x00D9	/* 8 bits */
#define RL_CPLUS_CMD		0x00E0	/* 16 bits */
#define RL_RXLIST_ADDR_LO	0x00E4	/* 64 bits, 256 byte alignment */
#define RL_RXLIST_ADDR_HI	0x00E8	/* 64 bits, 256 byte alignment */
#define RL_EARLY_TX_THRESH	0x00EC	/* 8 bits */

/*
 * Registers specific to the 8169 gigE chip
 */
#define RL_GTXSTART		0x0038	/* 8 bits */
#define RL_TIMERINT_8169	0x0058	/* different offset than 8139 */
#define RL_PHYAR		0x0060
#define RL_TBICSR		0x0064
#define RL_TBI_ANAR		0x0068
#define RL_TBI_LPAR		0x006A
#define RL_GMEDIASTAT		0x006C	/* 8 bits */
#define RL_MACDBG		0x006D	/* 8 bits */
#define RL_GPIO			0x006E	/* 8 bits */
#define RL_PMCH			0x006F	/* 8 bits */
#define RL_LDPS			0x0082	/* Link Down Power Saving */
#define RL_MAXRXPKTLEN		0x00DA	/* 16 bits, chip multiplies by 8 */
#define RL_IM			0x00E2
#define RL_MISC			0x00F0

/*
 * Register used on RTL8111E
 */
#define RL_LEDSEL		0x0018
#define RL_LED_LINK		0x7		/* link at any speed */
#define RL_LED_ACT		0x8

/*
 * TX config register bits
 */
#define RL_TXCFG_CLRABRT	0x00000001	/* retransmit aborted pkt */
#define RL_TXCFG_MAXDMA		0x00000700	/* max DMA burst size */
#define RL_TXCFG_QUEUE_EMPTY	0x00000800	/* 8168E-VL or higher */
#define RL_TXCFG_CRCAPPEND	0x00010000	/* CRC append (0 = yes) */
#define RL_TXCFG_LOOPBKTST	0x00060000	/* loopback test */
#define RL_TXCFG_IFG2		0x00080000	/* 8169 only */
#define RL_TXCFG_IFG		0x03000000	/* interframe gap */
#define RL_TXCFG_HWREV		0x7C800000

#define RL_LOOPTEST_OFF		0x00000000
#define RL_LOOPTEST_ON		0x00020000
#define RL_LOOPTEST_ON_CPLUS	0x00060000

/* Known revision codes. */

#define RL_HWREV_8169		0x00000000
#define RL_HWREV_8169S		0x00800000
#define RL_HWREV_8110S		0x04000000
#define RL_HWREV_8169_8110SB	0x10000000
#define RL_HWREV_8169_8110SCd	0x18000000
#define RL_HWREV_8401E		0x24000000
#define RL_HWREV_8102EL		0x24800000
#define RL_HWREV_8102EL_SPIN1	0x24C00000
#define RL_HWREV_8168D		0x28000000
#define RL_HWREV_8168DP		0x28800000
#define RL_HWREV_8168E		0x2C000000
#define RL_HWREV_8168E_VL	0x2C800000
#define RL_HWREV_8168B_SPIN1	0x30000000
#define RL_HWREV_8100E		0x30800000
#define RL_HWREV_8101E		0x34000000
#define RL_HWREV_8102E		0x34800000
#define	RL_HWREV_8103E		0x34C00000
#define RL_HWREV_8168B_SPIN2	0x38000000
#define RL_HWREV_8168B_SPIN3	0x38400000
#define RL_HWREV_8100E_SPIN2	0x38800000
#define RL_HWREV_8168C		0x3c000000
#define RL_HWREV_8168C_SPIN2	0x3c400000
#define RL_HWREV_8168CP		0x3c800000
#define RL_HWREV_8105E		0x40800000
#define RL_HWREV_8105E_SPIN1	0x40C00000
#define RL_HWREV_8402		0x44000000
#define RL_HWREV_8106E		0x44800000
#define RL_HWREV_8168F		0x48000000
#define RL_HWREV_8411		0x48800000
#define RL_HWREV_8168G		0x4c000000
#define RL_HWREV_8168EP		0x50000000
#define RL_HWREV_8168GU		0x50800000
#define RL_HWREV_8168H		0x54000000
#define RL_HWREV_8411B		0x5c800000	
#define RL_HWREV_8139		0x60000000
#define RL_HWREV_8139A		0x70000000
#define RL_HWREV_8139AG		0x70800000
#define RL_HWREV_8139B		0x78000000
#define RL_HWREV_8130		0x7C000000
#define RL_HWREV_8139C		0x74000000
#define RL_HWREV_8139D		0x74400000
#define RL_HWREV_8139CPLUS	0x74800000
#define RL_HWREV_8101		0x74c00000
#define RL_HWREV_8100		0x78800000
#define RL_HWREV_8169_8110SBL	0x7cc00000
#define RL_HWREV_8169_8110SCe	0x98000000

#define RL_TXDMA_16BYTES	0x00000000
#define RL_TXDMA_32BYTES	0x00000100
#define RL_TXDMA_64BYTES	0x00000200
#define RL_TXDMA_128BYTES	0x00000300
#define RL_TXDMA_256BYTES	0x00000400
#define RL_TXDMA_512BYTES	0x00000500
#define RL_TXDMA_1024BYTES	0x00000600
#define RL_TXDMA_2048BYTES	0x00000700

/*
 * Transmit descriptor status register bits.
 */
#define RL_TXSTAT_LENMASK	0x00001FFF
#define RL_TXSTAT_OWN		0x00002000
#define RL_TXSTAT_TX_UNDERRUN	0x00004000
#define RL_TXSTAT_TX_OK		0x00008000
#define RL_TXSTAT_EARLY_THRESH	0x003F0000
#define RL_TXSTAT_COLLCNT	0x0F000000
#define RL_TXSTAT_CARR_HBEAT	0x10000000
#define RL_TXSTAT_OUTOFWIN	0x20000000
#define RL_TXSTAT_TXABRT	0x40000000
#define RL_TXSTAT_CARRLOSS	0x80000000

/*
 * Interrupt status register bits.
 */
#define RL_ISR_RX_OK		0x0001
#define RL_ISR_RX_ERR		0x0002
#define RL_ISR_TX_OK		0x0004
#define RL_ISR_TX_ERR		0x0008
#define RL_ISR_RX_OVERRUN	0x0010
#define RL_ISR_PKT_UNDERRUN	0x0020
#define RL_ISR_LINKCHG		0x0020	/* 8169 only */
#define RL_ISR_FIFO_OFLOW	0x0040
#define RL_ISR_TX_DESC_UNAVAIL	0x0080	/* C+ only */
#define RL_ISR_SWI		0x0100	/* C+ only */
#define RL_ISR_CABLE_LEN_CHGD	0x2000
#define RL_ISR_PCS_TIMEOUT	0x4000	/* 8129 only */
#define RL_ISR_TIMEOUT_EXPIRED	0x4000
#define RL_ISR_SYSTEM_ERR	0x8000

#define RL_INTRS	\
	(RL_ISR_TX_OK|RL_ISR_RX_OK|RL_ISR_RX_ERR|RL_ISR_TX_ERR|		\
	RL_ISR_RX_OVERRUN|RL_ISR_PKT_UNDERRUN|RL_ISR_FIFO_OFLOW|	\
	RL_ISR_PCS_TIMEOUT|RL_ISR_SYSTEM_ERR)

#define RL_INTRS_CPLUS	\
	(RL_ISR_RX_OK|RL_ISR_RX_ERR|RL_ISR_TX_ERR|			\
	RL_ISR_RX_OVERRUN|RL_ISR_FIFO_OFLOW|				\
	RL_ISR_SYSTEM_ERR|RL_ISR_TX_OK)

#define RL_INTRS_TIMER	\
	(RL_ISR_RX_ERR|RL_ISR_TX_ERR|RL_ISR_SYSTEM_ERR|			\
	RL_ISR_TIMEOUT_EXPIRED)

/*
 * Media status register. (8139 only)
 */
#define RL_MEDIASTAT_RXPAUSE	0x01
#define RL_MEDIASTAT_TXPAUSE	0x02
#define RL_MEDIASTAT_LINK	0x04
#define RL_MEDIASTAT_SPEED10	0x08
#define RL_MEDIASTAT_RXFLOWCTL	0x40	/* duplex mode */
#define RL_MEDIASTAT_TXFLOWCTL	0x80	/* duplex mode */

/*
 * Receive config register.
 */
#define RL_RXCFG_RX_ALLPHYS	0x00000001	/* accept all nodes */
#define RL_RXCFG_RX_INDIV	0x00000002	/* match filter */
#define RL_RXCFG_RX_MULTI	0x00000004	/* accept all multicast */
#define RL_RXCFG_RX_BROAD	0x00000008	/* accept all broadcast */
#define RL_RXCFG_RX_RUNT	0x00000010
#define RL_RXCFG_RX_ERRPKT	0x00000020
#define RL_RXCFG_WRAP		0x00000080
#define RL_RXCFG_EARLYOFFV2	0x00000800
#define RL_RXCFG_MAXDMA		0x00000700
#define RL_RXCFG_BURSZ		0x00001800
#define RL_RXCFG_EARLYOFF	0x00003800
#define RL_RXCFG_FIFOTHRESH	0x0000E000
#define RL_RXCFG_EARLYTHRESH	0x07000000

#define RL_RXDMA_16BYTES	0x00000000
#define RL_RXDMA_32BYTES	0x00000100
#define RL_RXDMA_64BYTES	0x00000200
#define RL_RXDMA_128BYTES	0x00000300
#define RL_RXDMA_256BYTES	0x00000400
#define RL_RXDMA_512BYTES	0x00000500
#define RL_RXDMA_1024BYTES	0x00000600
#define RL_RXDMA_UNLIMITED	0x00000700

#define RL_RXBUF_8		0x00000000
#define RL_RXBUF_16		0x00000800
#define RL_RXBUF_32		0x00001000
#define RL_RXBUF_64		0x00001800

#define RL_RXFIFO_16BYTES	0x00000000
#define RL_RXFIFO_32BYTES	0x00002000
#define RL_RXFIFO_64BYTES	0x00004000
#define RL_RXFIFO_128BYTES	0x00006000
#define RL_RXFIFO_256BYTES	0x00008000
#define RL_RXFIFO_512BYTES	0x0000A000
#define RL_RXFIFO_1024BYTES	0x0000C000
#define RL_RXFIFO_NOTHRESH	0x0000E000

/*
 * Bits in RX status header (included with RX'ed packet
 * in ring buffer).
 */
#define RL_RXSTAT_RXOK		0x00000001
#define RL_RXSTAT_ALIGNERR	0x00000002
#define RL_RXSTAT_CRCERR	0x00000004
#define RL_RXSTAT_GIANT		0x00000008
#define RL_RXSTAT_RUNT		0x00000010
#define RL_RXSTAT_BADSYM	0x00000020
#define RL_RXSTAT_BROAD		0x00002000
#define RL_RXSTAT_INDIV		0x00004000
#define RL_RXSTAT_MULTI		0x00008000
#define RL_RXSTAT_LENMASK	0xFFFF0000

#define RL_RXSTAT_UNFINISHED	0xFFF0		/* DMA still in progress */
/*
 * Command register.
 */
#define RL_CMD_EMPTY_RXBUF	0x0001
#define RL_CMD_TX_ENB		0x0004
#define RL_CMD_RX_ENB		0x0008
#define RL_CMD_RESET		0x0010
#define RL_CMD_STOPREQ		0x0080

/*
 * EEPROM control register
 */
#define RL_EE_DATAOUT		0x01	/* Data out */
#define RL_EE_DATAIN		0x02	/* Data in */
#define RL_EE_CLK		0x04	/* clock */
#define RL_EE_SEL		0x08	/* chip select */
#define RL_EE_MODE		(0x40|0x80)

#define RL_EEMODE_OFF		0x00
#define RL_EEMODE_AUTOLOAD	0x40
#define RL_EEMODE_PROGRAM	0x80
#define RL_EEMODE_WRITECFG	(0x80|0x40)

/* 9346/9356 EEPROM commands */

#define RL_9346_ADDR_LEN	6	/* 93C46 1K: 128x16 */
#define RL_9356_ADDR_LEN	8	/* 93C56 2K: 256x16 */
 
#define RL_9346_WRITE		0x5
#define RL_9346_READ		0x6
#define RL_9346_ERASE		0x7
#define RL_9346_EWEN		0x4
#define RL_9346_EWEN_ADDR	0x30
#define RL_9456_EWDS		0x4
#define RL_9346_EWDS_ADDR	0x00

#define RL_EECMD_WRITE		0x5	/* 0101b */
#define RL_EECMD_READ		0x6	/* 0110b */
#define RL_EECMD_ERASE		0x7	/* 0111b */
#define RL_EECMD_LEN		4

#define RL_EEADDR_LEN0		6	/* 9346 */
#define RL_EEADDR_LEN1		8	/* 9356 */

#define RL_EECMD_READ_6BIT	0x180	/* XXX  */
#define RL_EECMD_READ_8BIT	0x600	/* EECMD_READ above maybe wrong? */

#define RL_EE_ID		0x00
#define RL_EE_PCI_VID		0x01
#define RL_EE_PCI_DID		0x02
/* Location of station address inside EEPROM */
#define RL_EE_EADDR		0x07

/*
 * MII register (8129 only)
 */
#define RL_MII_CLK		0x01
#define RL_MII_DATAIN		0x02
#define RL_MII_DATAOUT		0x04
#define RL_MII_DIR		0x80	/* 0 == input, 1 == output */

/*
 * Config 0 register
 */
#define RL_CFG0_ROM0		0x01
#define RL_CFG0_ROM1		0x02
#define RL_CFG0_ROM2		0x04
#define RL_CFG0_PL0		0x08
#define RL_CFG0_PL1		0x10
#define RL_CFG0_10MBPS		0x20	/* 10 Mbps internal mode */
#define RL_CFG0_PCS		0x40
#define RL_CFG0_SCR		0x80

/*
 * Config 1 register
 */
#define RL_CFG1_PWRDWN		0x01
#define RL_CFG1_PME		0x01
#define RL_CFG1_SLEEP		0x02
#define RL_CFG1_VPDEN		0x02
#define RL_CFG1_IOMAP		0x04
#define RL_CFG1_MEMMAP		0x08
#define RL_CFG1_RSVD		0x10
#define RL_CFG1_LWACT		0x10
#define RL_CFG1_DRVLOAD		0x20
#define RL_CFG1_LED0		0x40
#define RL_CFG1_FULLDUPLEX	0x40	/* 8129 only */
#define RL_CFG1_LED1		0x80

/*
 * Config 2 register
 */
#define RL_CFG2_PCI_MASK	0x07
#define RL_CFG2_PCI_33MHZ	0x00
#define RL_CFG2_PCI_66MHZ	0x01
#define RL_CFG2_PCI_64BIT	0x08
#define RL_CFG2_AUXPWR		0x10
#define RL_CFG2_MSI		0x20

/*
 * Config 3 register
 */
#define RL_CFG3_GRANTSEL	0x80
#define RL_CFG3_WOL_MAGIC	0x20
#define RL_CFG3_WOL_LINK	0x10
#define RL_CFG3_JUMBO_EN0	0x04
#define RL_CFG3_FAST_B2B	0x01

/*
 * Config 4 register
 */
#define RL_CFG4_CUSTOM_LED	0x40
#define RL_CFG4_LWPTN		0x04
#define RL_CFG4_LWPME		0x10
#define RL_CFG4_JUMBO_EN1	0x02
#define RL_CFG4_8168E_JUMBO_EN1 0x01

/*
 * Config 5 register
 */
#define RL_CFG5_WOL_BCAST	0x40
#define RL_CFG5_WOL_MCAST	0x20
#define RL_CFG5_WOL_UCAST	0x10
#define RL_CFG5_WOL_LANWAKE	0x02
#define RL_CFG5_PME_STS		0x01

/*
 * 8139C+ register definitions
 */

/* RL_DUMPSTATS_LO register */

#define RL_DUMPSTATS_START	0x00000008

/* Transmit start register */

#define RL_TXSTART_SWI		0x01	/* generate TX interrupt */
#define RL_TXSTART_START	0x40	/* start normal queue transmit */
#define RL_TXSTART_HPRIO_START	0x80	/* start hi prio queue transmit */

/*
 * Config 2 register, 8139C+/8169/8169S/8110S only
 */
#define RL_CFG2_BUSFREQ		0x07
#define RL_CFG2_BUSWIDTH	0x08
#define RL_CFG2_AUXPWRSTS	0x10

#define RL_BUSFREQ_33MHZ	0x00
#define RL_BUSFREQ_66MHZ	0x01
                                        
#define RL_BUSWIDTH_32BITS	0x00
#define RL_BUSWIDTH_64BITS	0x08

/* C+ mode command register */

#define RL_CPLUSCMD_TXENB	0x0001	/* enable C+ transmit mode */
#define RL_CPLUSCMD_RXENB	0x0002	/* enable C+ receive mode */
#define RL_CPLUSCMD_PCI_MRW	0x0008	/* enable PCI multi-read/write */
#define RL_CPLUSCMD_PCI_DAC	0x0010	/* PCI dual-address cycle only */
#define RL_CPLUSCMD_RXCSUM_ENB	0x0020	/* enable RX checksum offload */
#define RL_CPLUSCMD_VLANSTRIP	0x0040	/* enable VLAN tag stripping */
#define	RL_CPLUSCMD_MACSTAT_DIS	0x0080	/* 8168B/C/CP */
#define	RL_CPLUSCMD_ASF		0x0100	/* 8168C/CP */
#define	RL_CPLUSCMD_DBG_SEL	0x0200	/* 8168C/CP */
#define	RL_CPLUSCMD_FORCE_TXFC	0x0400	/* 8168C/CP */
#define	RL_CPLUSCMD_FORCE_RXFC	0x0800	/* 8168C/CP */
#define	RL_CPLUSCMD_FORCE_HDPX	0x1000	/* 8168C/CP */
#define	RL_CPLUSCMD_NORMAL_MODE	0x2000	/* 8168C/CP */
#define	RL_CPLUSCMD_DBG_ENB	0x4000	/* 8168C/CP */
#define	RL_CPLUSCMD_BIST_ENB	0x8000	/* 8168C/CP */

/* C+ early transmit threshold */

#define RL_EARLYTXTHRESH_CNT	0x003F	/* byte count times 8 */ 

/*
 * Gigabit PHY access register (8169 only)
 */

#define RL_PHYAR_PHYDATA	0x0000FFFF
#define RL_PHYAR_PHYREG		0x001F0000
#define RL_PHYAR_BUSY		0x80000000

/*
 * Gigabit media status (8169 only)
 */
#define RL_GMEDIASTAT_FDX	0x01	/* full duplex */
#define RL_GMEDIASTAT_LINK	0x02	/* link up */
#define RL_GMEDIASTAT_10MBPS	0x04	/* 10mps link */
#define RL_GMEDIASTAT_100MBPS	0x08	/* 100mbps link */
#define RL_GMEDIASTAT_1000MBPS	0x10	/* gigE link */
#define RL_GMEDIASTAT_RXFLOW	0x20	/* RX flow control on */
#define RL_GMEDIASTAT_TXFLOW	0x40	/* TX flow control on */
#define RL_GMEDIASTAT_TBI	0x80	/* TBI enabled */

/*
 * The Realtek doesn't use a fragment-based descriptor mechanism.
 * Instead, there are only four register sets, each of which represents
 * one 'descriptor.' Basically, each TX descriptor is just a contiguous
 * packet buffer (32-bit aligned!) and we place the buffer addresses in
 * the registers so the chip knows where they are.
 *
 * We can sort of kludge together the same kind of buffer management
 * used in previous drivers, but we have to do buffer copies almost all
 * the time, so it doesn't really buy us much.
 *
 * For reception, there's just one large buffer where the chip stores
 * all received packets.
 */

#define RL_RX_BUF_SZ		RL_RXBUF_64
#define RL_RXBUFLEN		(1 << ((RL_RX_BUF_SZ >> 11) + 13))
#define RL_TX_LIST_CNT		4
#define RL_MIN_FRAMELEN		60
#define RL_TXTHRESH(x)		((x) << 11)
#define RL_TX_THRESH_INIT	96
#define RL_RX_FIFOTHRESH	RL_RXFIFO_NOTHRESH
#define RL_RX_MAXDMA		RL_RXDMA_UNLIMITED
#define RL_TX_MAXDMA		RL_TXDMA_2048BYTES

#define RL_RXCFG_CONFIG		(RL_RX_FIFOTHRESH|RL_RX_MAXDMA|RL_RX_BUF_SZ)
#define RL_TXCFG_CONFIG		(RL_TXCFG_IFG|RL_TX_MAXDMA)

#define RL_IM_MAGIC		0x5050
#define RL_IM_RXTIME(t)		((t) & 0xf)
#define RL_IM_TXTIME(t)		(((t) & 0xf) << 8)

struct rl_chain_data {
	u_int16_t		cur_rx;
	caddr_t			rl_rx_buf;
	caddr_t			rl_rx_buf_ptr;
	bus_addr_t		rl_rx_buf_pa;

	struct mbuf		*rl_tx_chain[RL_TX_LIST_CNT];
	bus_dmamap_t		rl_tx_dmamap[RL_TX_LIST_CNT];
	u_int8_t		last_tx;
	u_int8_t		cur_tx;
};


/*
 * The 8139C+ and 8160 gigE chips support descriptor-based TX
 * and RX. In fact, they even support TCP large send. Descriptors
 * must be allocated in contiguous blocks that are aligned on a
 * 256-byte boundary. The rings can hold a maximum of 64 descriptors.
 */

/*
 * RX/TX descriptor definition. When large send mode is enabled, the
 * lower 11 bits of the TX rl_cmd word are used to hold the MSS, and
 * the checksum offload bits are disabled. The structure layout is
 * the same for RX and TX descriptors
 */

struct rl_desc {
	volatile u_int32_t	rl_cmdstat;
	volatile u_int32_t	rl_vlanctl;
	volatile u_int32_t	rl_bufaddr_lo;
	volatile u_int32_t	rl_bufaddr_hi;
};

#define RL_TDESC_CMD_FRAGLEN	0x0000FFFF
#define RL_TDESC_CMD_TCPCSUM	0x00010000	/* TCP checksum enable */
#define RL_TDESC_CMD_UDPCSUM	0x00020000	/* UDP checksum enable */
#define RL_TDESC_CMD_IPCSUM	0x00040000	/* IP header checksum enable */
#define RL_TDESC_CMD_MSSVAL	0x07FF0000	/* Large send MSS value */
#define RL_TDESC_CMD_LGSEND	0x08000000	/* TCP large send enb */
#define RL_TDESC_CMD_EOF	0x10000000	/* end of frame marker */
#define RL_TDESC_CMD_SOF	0x20000000	/* start of frame marker */
#define RL_TDESC_CMD_EOR	0x40000000	/* end of ring marker */
#define RL_TDESC_CMD_OWN	0x80000000	/* chip owns descriptor */

#define RL_TDESC_VLANCTL_TAG	0x00020000	/* Insert VLAN tag */
#define RL_TDESC_VLANCTL_DATA	0x0000FFFF	/* TAG data */
/* RTL8168C/RTL8168CP/RTL8111C/RTL8111CP */
#define	RL_TDESC_CMD_IPCSUMV2	0x20000000
#define	RL_TDESC_CMD_TCPCSUMV2	0x40000000
#define	RL_TDESC_CMD_UDPCSUMV2	0x80000000

/*
 * Error bits are valid only on the last descriptor of a frame
 * (i.e. RL_TDESC_CMD_EOF == 1)
 */

#define RL_TDESC_STAT_COLCNT	0x000F0000	/* collision count */
#define RL_TDESC_STAT_EXCESSCOL	0x00100000	/* excessive collisions */
#define RL_TDESC_STAT_LINKFAIL	0x00200000	/* link faulure */
#define RL_TDESC_STAT_OWINCOL	0x00400000	/* out-of-window collision */
#define RL_TDESC_STAT_TXERRSUM	0x00800000	/* transmit error summary */
#define RL_TDESC_STAT_UNDERRUN	0x02000000	/* TX underrun occured */
#define RL_TDESC_STAT_OWN	0x80000000

/*
 * RX descriptor cmd/vlan definitions
 */

#define RL_RDESC_CMD_EOR	0x40000000
#define RL_RDESC_CMD_OWN	0x80000000
#define RL_RDESC_CMD_BUFLEN	0x00001FFF

#define RL_RDESC_STAT_OWN	0x80000000
#define RL_RDESC_STAT_EOR	0x40000000
#define RL_RDESC_STAT_SOF	0x20000000
#define RL_RDESC_STAT_EOF	0x10000000
#define RL_RDESC_STAT_FRALIGN	0x08000000	/* frame alignment error */
#define RL_RDESC_STAT_MCAST	0x04000000	/* multicast pkt received */
#define RL_RDESC_STAT_UCAST	0x02000000	/* unicast pkt received */
#define RL_RDESC_STAT_BCAST	0x01000000	/* broadcast pkt received */
#define RL_RDESC_STAT_BUFOFLOW	0x00800000	/* out of buffer space */
#define RL_RDESC_STAT_FIFOOFLOW	0x00400000	/* FIFO overrun */
#define RL_RDESC_STAT_GIANT	0x00200000	/* pkt > 4096 bytes */
#define RL_RDESC_STAT_RXERRSUM	0x00100000	/* RX error summary */
#define RL_RDESC_STAT_RUNT	0x00080000	/* runt packet received */
#define RL_RDESC_STAT_CRCERR	0x00040000	/* CRC error */
#define RL_RDESC_STAT_PROTOID	0x00030000	/* Protocol type */
#define	RL_RDESC_STAT_UDP	0x00020000	/* UDP, 8168C/CP, 8111C/CP */
#define	RL_RDESC_STAT_TCP	0x00010000	/* TCP, 8168C/CP, 8111C/CP */
#define RL_RDESC_STAT_IPSUMBAD	0x00008000	/* IP header checksum bad */
#define RL_RDESC_STAT_UDPSUMBAD	0x00004000	/* UDP checksum bad */
#define RL_RDESC_STAT_TCPSUMBAD	0x00002000	/* TCP checksum bad */
#define RL_RDESC_STAT_FRAGLEN	0x00001FFF	/* RX'ed frame/frag len */
#define RL_RDESC_STAT_GFRAGLEN	0x00003FFF	/* RX'ed frame/frag len */
#define RL_RDESC_STAT_ERRS	(RL_RDESC_STAT_GIANT|RL_RDESC_STAT_RUNT| \
				 RL_RDESC_STAT_CRCERR)

#define RL_RDESC_VLANCTL_TAG	0x00010000	/* VLAN tag available
						   (rl_vlandata valid)*/
#define RL_RDESC_VLANCTL_DATA	0x0000FFFF	/* TAG data */
/* RTL8168C/RTL8168CP/RTL8111C/RTL8111CP */
#define	RL_RDESC_IPV6		0x80000000
#define	RL_RDESC_IPV4		0x40000000

#define RL_PROTOID_NONIP	0x00000000
#define RL_PROTOID_TCPIP	0x00010000
#define RL_PROTOID_UDPIP	0x00020000
#define RL_PROTOID_IP		0x00030000
#define RL_TCPPKT(x)		(((x) & RL_RDESC_STAT_PROTOID) == \
				 RL_PROTOID_TCPIP)
#define RL_UDPPKT(x)		(((x) & RL_RDESC_STAT_PROTOID) == \
				 RL_PROTOID_UDPIP)

/*
 * Statistics counter structure (8139C+ and 8169 only)
 */
struct rl_stats {
	u_int32_t		rl_tx_pkts_lo;
	u_int32_t		rl_tx_pkts_hi;
	u_int32_t		rl_tx_errs_lo;
	u_int32_t		rl_tx_errs_hi;
	u_int32_t		rl_tx_errs;
	u_int16_t		rl_missed_pkts;
	u_int16_t		rl_rx_framealign_errs;
	u_int32_t		rl_tx_onecoll;
	u_int32_t		rl_tx_multicolls;
	u_int32_t		rl_rx_ucasts_hi;
	u_int32_t		rl_rx_ucasts_lo;
	u_int32_t		rl_rx_bcasts_lo;
	u_int32_t		rl_rx_bcasts_hi;
	u_int32_t		rl_rx_mcasts;
	u_int16_t		rl_tx_aborts;
	u_int16_t		rl_rx_underruns;
};

/*
 * Rx/Tx descriptor parameters (8139C+ and 8169 only)
 *
 * 8139C+
 *  Number of descriptors supported : up to 64
 *  Descriptor alignment : 256 bytes
 *  Tx buffer : At least 4 bytes in length.
 *  Rx buffer : At least 8 bytes in length and 8 bytes alignment required.
 *
 * 8169
 *  Number of descriptors supported : up to 1024
 *  Descriptor alignment : 256 bytes
 *  Tx buffer : At least 4 bytes in length.
 *  Rx buffer : At least 8 bytes in length and 8 bytes alignment required.
 */
#define RL_8169_TX_DESC_CNT	1024
#define RL_8169_RX_DESC_CNT	1024
#define RL_8139_TX_DESC_CNT	64
#define RL_8139_RX_DESC_CNT	64
#define RL_TX_DESC_CNT		RL_8169_TX_DESC_CNT
#define RL_RX_DESC_CNT		RL_8169_RX_DESC_CNT
#define RL_8169_NTXSEGS		32
#define RL_8139_NTXSEGS		8

#define RL_TX_QLEN		64

#define RL_RING_ALIGN		256
#define RL_PKTSZ(x)		((x)/* >> 3*/)
#ifdef __STRICT_ALIGNMENT
#define RE_ETHER_ALIGN		2
#define RE_RX_DESC_BUFLEN	(MCLBYTES - RE_ETHER_ALIGN)
#else
#define RE_ETHER_ALIGN		0
#define RE_RX_DESC_BUFLEN	MCLBYTES
#endif

#define RL_TX_LIST_SZ(sc)	\
	((sc)->rl_ldata.rl_tx_desc_cnt * sizeof(struct rl_desc))
#define RL_RX_LIST_SZ(sc)	\
	((sc)->rl_ldata.rl_rx_desc_cnt * sizeof(struct rl_desc))
#define RL_NEXT_TX_DESC(sc, x)	\
	(((x) + 1) % (sc)->rl_ldata.rl_tx_desc_cnt)
#define RL_NEXT_RX_DESC(sc, x)	\
	(((x) + 1) % (sc)->rl_ldata.rl_rx_desc_cnt)
#define RL_NEXT_TXQ(sc, x)	\
	(((x) + 1) % RL_TX_QLEN)

#define RL_TXDESCSYNC(sc, idx, ops)		\
	bus_dmamap_sync((sc)->sc_dmat,		\
	    (sc)->rl_ldata.rl_tx_list_map,	\
	    sizeof(struct rl_desc) * (idx),	\
	    sizeof(struct rl_desc),		\
	    (ops))
#define RL_RXDESCSYNC(sc, idx, ops)		\
	bus_dmamap_sync((sc)->sc_dmat,		\
	    (sc)->rl_ldata.rl_rx_list_map,	\
	    sizeof(struct rl_desc) * (idx),	\
	    sizeof(struct rl_desc),		\
	    (ops))

#define RL_ADDR_LO(y)	((u_int64_t) (y) & 0xFFFFFFFF)
#define RL_ADDR_HI(y)	((u_int64_t) (y) >> 32)

#define RL_JUMBO_FRAMELEN 	(9 * 1024)	
#define RL_JUMBO_MTU_4K		\
	((4 * 1024) - ETHER_HDR_LEN - ETHER_CRC_LEN - ETHER_VLAN_ENCAP_LEN)
#define RL_JUMBO_MTU_6K		\
	((6 * 1024) - ETHER_HDR_LEN - ETHER_CRC_LEN - ETHER_VLAN_ENCAP_LEN)
#define RL_JUMBO_MTU_7K		\
	((7 * 1024) - ETHER_HDR_LEN - ETHER_CRC_LEN - ETHER_VLAN_ENCAP_LEN)
#define RL_JUMBO_MTU_9K		\
	((9 * 1024) - ETHER_HDR_LEN - ETHER_CRC_LEN - ETHER_VLAN_ENCAP_LEN)
#define RL_MTU			ETHERMTU

#define MAX_NUM_MULTICAST_ADDRESSES	128

#define RL_INC(x)		(x = (x + 1) % RL_TX_LIST_CNT)
#define RL_CUR_TXADDR(x)	((x->rl_cdata.cur_tx * 4) + RL_TXADDR0)
#define RL_CUR_TXSTAT(x)	((x->rl_cdata.cur_tx * 4) + RL_TXSTAT0)
#define RL_CUR_TXMBUF(x)	(x->rl_cdata.rl_tx_chain[x->rl_cdata.cur_tx])
#define RL_CUR_TXMAP(x)		(x->rl_cdata.rl_tx_dmamap[x->rl_cdata.cur_tx])
#define RL_LAST_TXADDR(x)	((x->rl_cdata.last_tx * 4) + RL_TXADDR0)
#define RL_LAST_TXSTAT(x)	((x->rl_cdata.last_tx * 4) + RL_TXSTAT0)
#define RL_LAST_TXMBUF(x)	(x->rl_cdata.rl_tx_chain[x->rl_cdata.last_tx])
#define RL_LAST_TXMAP(x)	(x->rl_cdata.rl_tx_dmamap[x->rl_cdata.last_tx])

struct rl_type {
	u_int16_t		rl_vid;
	u_int16_t		rl_did;
};

struct rl_mii_frame {
	u_int8_t		mii_stdelim;
	u_int8_t		mii_opcode;
	u_int8_t		mii_phyaddr;
	u_int8_t		mii_regaddr;
	u_int8_t		mii_turnaround;
	u_int16_t		mii_data;
};

/*
 * MII constants
 */
#define RL_MII_STARTDELIM	0x01
#define RL_MII_READOP		0x02
#define RL_MII_WRITEOP		0x01
#define RL_MII_TURNAROUND	0x02

#define	RL_UNKNOWN		0
#define RL_8129			1
#define RL_8139			2

struct rl_rxsoft {
	struct mbuf		*rxs_mbuf;
	bus_dmamap_t		rxs_dmamap;
};

struct rl_txq {
	struct mbuf *txq_mbuf;
	bus_dmamap_t txq_dmamap;
	int txq_descidx;
	int txq_nsegs;
};

struct rl_list_data {
	struct rl_txq		rl_txq[RL_TX_DESC_CNT];
	int			rl_txq_considx;
	int			rl_txq_prodidx;

	bus_dmamap_t		rl_tx_list_map;
	struct rl_desc		*rl_tx_list;
	int			rl_tx_free;	/* # of free descriptors */
	int			rl_tx_nextfree; /* next descriptor to use */
	int			rl_tx_desc_cnt; /* # of descriptors */
	int			rl_tx_ndescs;	/* descs per tx packet */
	bus_dma_segment_t	rl_tx_listseg;
	int			rl_tx_listnseg;

	struct rl_rxsoft	rl_rxsoft[RL_RX_DESC_CNT];
	bus_dmamap_t		rl_rx_list_map;
	struct rl_desc		*rl_rx_list;
	int			rl_rx_considx;
	int			rl_rx_prodidx;
	int			rl_rx_desc_cnt;	/* # of descriptors */
	struct if_rxring	rl_rx_ring;
	bus_dma_segment_t	rl_rx_listseg;
	int			rl_rx_listnseg;
};

struct rl_softc {
	struct device		sc_dev;		/* us, as a device */
	void *			sc_ih;		/* interrupt vectoring */
	bus_space_handle_t	rl_bhandle;	/* bus space handle */
	bus_space_tag_t		rl_btag;	/* bus space tag */
	bus_dma_tag_t		sc_dmat;
	bus_dma_segment_t 	sc_rx_seg;
	bus_dmamap_t		sc_rx_dmamap;
	struct arpcom		sc_arpcom;	/* interface info */
	struct mii_data		sc_mii;		/* MII information */
	u_int8_t		rl_type;
	u_int32_t		sc_hwrev;
	u_int16_t		sc_product;
	int			rl_max_mtu;
	int			rl_eecmd_read;
	int			rl_eewidth;
	int			rl_bus_speed;
	int			rl_txthresh;
	bus_size_t		rl_cfg0;
	bus_size_t		rl_cfg1;
	bus_size_t		rl_cfg2;
	bus_size_t		rl_cfg3;
	bus_size_t		rl_cfg4;
	bus_size_t		rl_cfg5;
	struct rl_chain_data	rl_cdata;
	struct timeout		sc_tick_tmo;

	struct rl_list_data	rl_ldata;
	struct mbuf		*rl_head;
	struct mbuf		*rl_tail;
	u_int32_t		rl_rxlenmask;
	struct timeout		timer_handle;
	struct task		rl_start;

	int			rl_txstart;
	u_int32_t		rl_flags;
#define	RL_FLAG_MSI		0x00000001
#define	RL_FLAG_PCI64		0x00000002
#define	RL_FLAG_PCIE		0x00000004
#define	RL_FLAG_PHYWAKE		0x00000008
#define	RL_FLAG_PAR		0x00000010
#define	RL_FLAG_DESCV2		0x00000020
#define	RL_FLAG_MACSTAT		0x00000040
#define	RL_FLAG_HWIM		0x00000080
#define	RL_FLAG_TIMERINTR	0x00000100
#define	RL_FLAG_MACRESET	0x00000200
#define	RL_FLAG_CMDSTOP		0x00000400
#define	RL_FLAG_MACSLEEP	0x00000800
#define	RL_FLAG_AUTOPAD		0x00001000
#define	RL_FLAG_LINK		0x00002000
#define	RL_FLAG_PHYWAKE_PM	0x00004000
#define	RL_FLAG_EARLYOFF	0x00008000
#define	RL_FLAG_EARLYOFFV2	0x00010000
#define	RL_FLAG_RXDV_GATED	0x00020000
#define	RL_FLAG_FASTETHER	0x00040000
#define	RL_FLAG_CMDSTOP_WAIT_TXQ 0x00080000
#define	RL_FLAG_JUMBOV2		0x00100000
#define	RL_FLAG_WOL_MANLINK	0x00200000
#define	RL_FLAG_WAIT_TXPOLL	0x00400000
#define	RL_FLAG_WOLRXENB	0x00800000

	u_int16_t		rl_intrs;
	u_int16_t		rl_tx_ack;
	u_int16_t		rl_rx_ack;
	int			rl_tx_time;
	int			rl_rx_time;
	int			rl_sim_time;
	int			rl_imtype;
#define	RL_IMTYPE_NONE		0
#define	RL_IMTYPE_SIM		1	/* simulated */
#define	RL_IMTYPE_HW		2	/* hardware based */
	int			rl_timerintr;
};

/*
 * re(4) hardware ip4csum-tx could be mangled with 28 byte or less IP packets
 */
#define RL_IP4CSUMTX_MINLEN	28
#define RL_IP4CSUMTX_PADLEN	(ETHER_HDR_LEN + RL_IP4CSUMTX_MINLEN)
/*
 * XXX
 * We are allocating pad DMA buffer after RX DMA descs for now
 * because RL_TX_LIST_SZ(sc) always occupies whole page but
 * RL_RX_LIST_SZ is less than PAGE_SIZE so there is some unused region.
 */
#define RL_RX_DMAMEM_SZ(sc)	(RL_RX_LIST_SZ(sc) + RL_IP4CSUMTX_PADLEN)
#define RL_TXPADOFF(sc)		RL_RX_LIST_SZ(sc)
#define RL_TXPADDADDR(sc)	\
	((sc)->rl_ldata.rl_rx_list_map->dm_segs[0].ds_addr + RL_TXPADOFF(sc))

/*
 * register space access macros
 */
#define CSR_WRITE_RAW_4(sc, csr, val) \
	bus_space_write_raw_region_4(sc->rl_btag, sc->rl_bhandle, csr, val, 4)
#define CSR_WRITE_4(sc, csr, val) \
	bus_space_write_4(sc->rl_btag, sc->rl_bhandle, csr, val)
#define CSR_WRITE_2(sc, csr, val) \
	bus_space_write_2(sc->rl_btag, sc->rl_bhandle, csr, val)
#define CSR_WRITE_1(sc, csr, val) \
	bus_space_write_1(sc->rl_btag, sc->rl_bhandle, csr, val)

#define CSR_READ_4(sc, csr) \
	bus_space_read_4(sc->rl_btag, sc->rl_bhandle, csr)
#define CSR_READ_2(sc, csr) \
	bus_space_read_2(sc->rl_btag, sc->rl_bhandle, csr)
#define CSR_READ_1(sc, csr) \
	bus_space_read_1(sc->rl_btag, sc->rl_bhandle, csr)

#define CSR_SETBIT_1(sc, offset, val)		\
	CSR_WRITE_1(sc, offset, CSR_READ_1(sc, offset) | (val))

#define CSR_CLRBIT_1(sc, offset, val)		\
	CSR_WRITE_1(sc, offset, CSR_READ_1(sc, offset) & ~(val))

#define CSR_SETBIT_2(sc, offset, val)		\
	CSR_WRITE_2(sc, offset, CSR_READ_2(sc, offset) | (val))

#define CSR_CLRBIT_2(sc, offset, val)		\
	CSR_WRITE_2(sc, offset, CSR_READ_2(sc, offset) & ~(val))

#define CSR_SETBIT_4(sc, offset, val)		\
	CSR_WRITE_4(sc, offset, CSR_READ_4(sc, offset) | (val))

#define CSR_CLRBIT_4(sc, offset, val)		\
	CSR_WRITE_4(sc, offset, CSR_READ_4(sc, offset) & ~(val))

#define RL_TIMEOUT		1000
#define RL_PHY_TIMEOUT		20

/*
 * General constants that are fun to know.
 *
 * Realtek PCI vendor ID
 */
#define	RT_VENDORID				0x10EC

/*
 * Realtek chip device IDs.
 */
#define RT_DEVICEID_8129			0x8129
#define RT_DEVICEID_8101E			0x8136
#define RT_DEVICEID_8138			0x8138
#define RT_DEVICEID_8139			0x8139
#define RT_DEVICEID_8169SC			0x8167
#define RT_DEVICEID_8168			0x8168
#define RT_DEVICEID_8169			0x8169
#define RT_DEVICEID_8100			0x8100

/*
 * Accton PCI vendor ID
 */
#define ACCTON_VENDORID				0x1113

/*
 * Accton MPX 5030/5038 device ID.
 */
#define ACCTON_DEVICEID_5030			0x1211

/*
 * Delta Electronics Vendor ID.
 */
#define DELTA_VENDORID				0x1500

/*
 * Delta device IDs.
 */
#define DELTA_DEVICEID_8139			0x1360

/*
 * Addtron vendor ID.
 */
#define ADDTRON_VENDORID			0x4033

/*
 * Addtron device IDs.
 */
#define ADDTRON_DEVICEID_8139			0x1360

/* D-Link Vendor ID */
#define DLINK_VENDORID				0x1186

/* D-Link device IDs */
#define DLINK_DEVICEID_8139			0x1300
#define DLINK_DEVICEID_8139_2			0x1340

/* Abocom device IDs */
#define ABOCOM_DEVICEID_8139			0xab06

/*
 * PCI low memory base and low I/O base register, and
 * other PCI registers. Note: some are only available on
 * the 3c905B, in particular those that related to power management.
 */

#define RL_PCI_VENDOR_ID	0x00
#define RL_PCI_DEVICE_ID	0x02
#define RL_PCI_COMMAND		0x04
#define RL_PCI_STATUS		0x06
#define RL_PCI_CLASSCODE	0x09
#define RL_PCI_LATENCY_TIMER	0x0D
#define RL_PCI_HEADER_TYPE	0x0E
#define RL_PCI_LOIO		0x10
#define RL_PCI_LOMEM		0x14
#define RL_PCI_BIOSROM		0x30
#define RL_PCI_INTLINE		0x3C
#define RL_PCI_INTPIN		0x3D
#define RL_PCI_MINGNT		0x3E
#define RL_PCI_MINLAT		0x0F
#define RL_PCI_PMCSR		0x44
#define RL_PCI_RESETOPT		0x48
#define RL_PCI_EEPROM_DATA	0x4C

#define RL_PCI_CAPID		0x50 /* 8 bits */
#define RL_PCI_NEXTPTR		0x51 /* 8 bits */
#define RL_PCI_PWRMGMTCAP	0x52 /* 16 bits */
#define RL_PCI_PWRMGMTCTRL	0x54 /* 16 bits */

#define RL_PSTATE_MASK		0x0003
#define RL_PSTATE_D0		0x0000
#define RL_PSTATE_D1		0x0001
#define RL_PSTATE_D2		0x0002
#define RL_PSTATE_D3		0x0003
#define RL_PME_EN		0x0100
#define RL_PME_STATUS		0x8000

extern int rl_attach(struct rl_softc *);
extern int rl_intr(void *);
extern void rl_setmulti(struct rl_softc *);
int rl_detach(struct rl_softc *);
int rl_activate(struct device *, int);
@


1.99
log
@serialise posts to the txstart register.

without this it is possible for re_txeof to let the chip look at
and complete tx descriptors that re_start has written to the ring
but not accounted for in the software producer index. in this
situation no future interrupts may be generated for packets on the
ring, and tx will stall.

the serialisation is implemented by only doing the writes from tasks
via ifq_serialize.

this is part of a bigger diff that fixes lockups reported by haesbaert.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.98 2016/04/20 12:15:24 sthen Exp $	*/
d836 1
a836 1
	struct rl_txq		rl_txq[RL_TX_QLEN];
d845 1
@


1.98
log
@If RTL8111E on PC Engines APU is detected, configure NIC LEDs to display link.
Normally this would be setup in the vendor-programmed eeprom, but in this case
it hasn't been done and the rather unfortunate default results in *only* a
normally-off light for network activity, nothing for ethernet link, so it's
too easy to mistake the machine for being powered down. hw.vendor/hw.machine
idea from naddy@@, testing jasper@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.97 2015/12/28 05:49:15 jmatthew Exp $	*/
d891 1
@


1.97
log
@Rework re_start and re_txeof to only check the producer/consumer ring
positions when deciding how much work to do, and to adjust rl_tx_free with
atomic operations; split the flag that indicates whether we're using
timer based interrupts or not out into a separate field so it can be
changed from interrupt context without needing a lock; take the kernel
lock when calling re_init and re_start from interrupt context; add an
interrupt barrier in re_stop; and finally mark the interrupt handler
as mpsafe.

started by Jim Smith a while ago, mostly finished up at n2k15
tested by dlg@@, chris@@ and Dimitris Papastamos on various hardware
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.96 2015/11/02 00:08:50 dlg Exp $	*/
d156 7
d459 1
@


1.96
log
@later variants of these chips can support bigger rx and tx rings. this
diff expands them so devices that need more packets per interrupt can
use them.

this is all from brad@@
tested by jim smith and benjamin perrault on APUs
tested by me on 8139s (which dont support bit rings) on landisk, and
8169s
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.95 2015/09/04 07:05:44 jsg Exp $	*/
d921 1
@


1.95
log
@add support for RTL8168H

tedu tested an almost identical diff from brad that set the same flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.94 2015/04/09 02:08:55 dlg Exp $	*/
d703 23
a725 3
#define RL_RX_DESC_CNT		64
#define RL_TX_DESC_CNT_8139	64
#define RL_TX_DESC_CNT_8169	512
a728 3
#define RL_NTXSEGS		32

#define RL_RX_LIST_SZ		(RL_RX_DESC_CNT * sizeof(struct rl_desc))
a738 2
#define RL_TX_DESC_CNT(sc)	\
	((sc)->rl_ldata.rl_tx_desc_cnt)
d740 3
a742 1
	(RL_TX_DESC_CNT(sc) * sizeof(struct rl_desc))
d744 1
a744 1
	(((x) + 1) % RL_TX_DESC_CNT(sc))
d746 1
a746 1
	(((x) + 1) % RL_RX_DESC_CNT)
d845 1
d934 2
a935 2
#define RL_RX_DMAMEM_SZ		(RL_RX_LIST_SZ + RL_IP4CSUMTX_PADLEN)
#define RL_TXPADOFF		RL_RX_LIST_SZ
d937 1
a937 1
	((sc)->rl_ldata.rl_rx_list_map->dm_segs[0].ds_addr + RL_TXPADOFF)
@


1.94
log
@to quote jim smith:

> fix a regression on re chips which have
> 7k jumbo support (RL_JUMBO_MTU_7K) as reported by daniel jakots
> and emilio perea. the regression was caused because RL_JUMBO_FRAMELEN
> was changed to 9k and i missed fixing up the RL_JUMBO_MTU_7K macro.

nice of him to fix the thing he broke ;)
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.93 2015/03/20 12:04:09 dlg Exp $	*/
d205 1
@


1.93
log
@add support for jumbos on re(4).

this uses hints from the freebsd driver, but the implementation
differs.

freebsd manages two lists of rx descriptors. one for "normal" packets
and the other for jumbos. this continues to use a single list and
uses a per softc variable and MCLGETI to always allocate what the
chip is capable and uses it unconditionally.

other than that, we just need to enable some bits in some registers
to be able to do jumbos.

this relies on the previous commit to properly deal with checksum
offload for packets of different sizes.

from jim smith
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.92 2015/03/08 01:54:04 tobiasu Exp $	*/
d754 1
a754 1
	(RL_JUMBO_FRAMELEN - ETHER_HDR_LEN - ETHER_CRC_LEN - ETHER_VLAN_ENCAP_LEN)
@


1.92
log
@Revert patch responsible for locking up machines with
"Realtek 8168" rev 0x01: RTL8168 2 (0x3800).
You will never guess who commited it without OK ;)

ok deraadt



revision 1.45
date: 2015/01/26 09:58:47;  author: brad;  state: Exp;  lines: +22 -2;  commitid: AppNYocFYbD7Hqgj;
Set PCIe max read request size to 2K to help with TX performance.

From FreeBSD

Tested with 8168C, 8168D and 8168G.

revision 1.46
date: 2015/02/19 04:58:34;  author: dlg;  state: Exp;  lines: +2 -2;  commitid: GSWXECXQW0LeGFmq;
when reading the max packet size in the pcie device config and
status register, correctly mask things so we're left with the mps
field instead of everything but the mps field.

tested by bcallah@@ and jim smith
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.90 2015/01/20 04:33:06 brad Exp $	*/
d445 1
d453 2
d748 1
a748 2
/* see comment in dev/ic/re.c */
#define RL_JUMBO_FRAMELEN	7440
@


1.91
log
@Set PCIe max read request size to 2K to help with TX performance.

From FreeBSD

Tested with 8168C, 8168D and 8168G.
@
text
@a835 1
	u_int32_t		rl_expcap;
@


1.90
log
@Remove use of the link change interrupt handling, not all controllers
support this interrupt. Link state changes are noticed via the PHY
status change callback or via the timeout for re_tick().

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.89 2015/01/08 00:49:18 brad Exp $	*/
d836 1
@


1.89
log
@Use the correct config registers for the RTL8139 family. Unlike the RTL8169
and RTL8168 family, the RTL8139 has different register map for config registers.

From FreeBSD

WoL bits reviewed and tested by stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.88 2014/11/24 02:03:37 brad Exp $	*/
d267 1
a267 1
	RL_ISR_RX_OVERRUN|RL_ISR_FIFO_OFLOW|RL_ISR_LINKCHG|		\
d270 2
a271 3
#define RL_INTRS_TIMER							\
	(RL_ISR_RX_ERR|RL_ISR_TX_ERR|					\
	RL_ISR_LINKCHG|RL_ISR_SYSTEM_ERR|				\
@


1.88
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.87 2014/11/19 02:37:41 brad Exp $	*/
d79 8
d849 6
@


1.87
log
@Add support for stopping the operation of the chipset within re_stop()
for newer generations of chipsets.

From FreeBSD

Tested with 8169, 8168C, 8168D, 8168G and by stsp@@ with WOL.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.86 2014/09/06 04:46:58 brad Exp $	*/
d38 1
a38 1
 * RealTek 8129/8139 register offsets
d525 1
a525 1
 * The RealTek doesn't use a fragment-based descriptor mechanism.
d948 1
a948 1
 * RealTek PCI vendor ID
d953 1
a953 1
 * RealTek chip device IDs.
@


1.86
log
@Various changes to the re(4) feature flags..

Changed RL_FLAG_MACLDPS to RL_FLAG_MACRESET.
Removed RL_FLAG_INVMAR and RL_FLAG_NOJUMBO.
Added RL_FLAG_FASTETHER, RL_FLAG_CMDSTOP_WAIT_TXQ, RL_FLAG_JUMBOV2, RL_FLAG_WOL_MANLINK,
      RL_FLAG_WAIT_TXPOLL, RL_FLAG_WOLRXENB.

Also set in the softc the maximum MTU for the various generations of chips.

Input from and Ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.85 2014/07/08 05:35:18 dlg Exp $	*/
d152 1
@


1.85
log
@cut things that relied on mclgeti for rx ring accounting/restriction over
to using if_rxr.

cut the reporting systat did over to the rxr ioctl.

tested as much as i can on alpha, amd64, and sparc64.
mpi@@ has run it on macppc.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.84 2014/04/23 03:37:29 jsg Exp $	*/
d739 9
a747 1
#define RL_JUMBO_MTU		(RL_JUMBO_FRAMELEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
d834 2
d854 21
a874 17
#define	RL_FLAG_INVMAR		0x00000008
#define	RL_FLAG_PHYWAKE		0x00000010
#define	RL_FLAG_NOJUMBO		0x00000020
#define	RL_FLAG_PAR		0x00000040
#define	RL_FLAG_DESCV2		0x00000080
#define	RL_FLAG_MACSTAT		0x00000100
#define	RL_FLAG_HWIM		0x00000200
#define	RL_FLAG_TIMERINTR	0x00000400
#define	RL_FLAG_MACLDPS		0x00000800
#define	RL_FLAG_CMDSTOP		0x00001000
#define	RL_FLAG_MACSLEEP	0x00002000
#define	RL_FLAG_AUTOPAD		0x00004000
#define	RL_FLAG_LINK		0x00008000
#define	RL_FLAG_PHYWAKE_PM	0x00010000
#define	RL_FLAG_EARLYOFF	0x00020000
#define	RL_FLAG_EARLYOFFV2	0x00040000
#define	RL_FLAG_RXDV_GATED	0x00080000
@


1.84
log
@rename some hardware revisions to match FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.83 2014/04/23 03:20:55 jsg Exp $	*/
d809 1
a809 1
	int			rl_rx_cnt;
@


1.83
log
@add support for RTL8168EP
From Edward O'Callaghan via FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.82 2014/04/23 02:58:06 jsg Exp $	*/
d176 2
a177 2
#define RL_HWREV_8168_SPIN1	0x30000000
#define RL_HWREV_8100E_SPIN1	0x30800000
d181 2
a182 2
#define RL_HWREV_8168_SPIN2	0x38000000
#define RL_HWREV_8168_SPIN3	0x38400000
d196 1
a196 1
#define RL_HWREV_8168G_SPIN4	0x5c800000	
@


1.82
log
@While we always mask the revision with 0x7c800000 linux uses a table
that masks with either 0x7c800000 or 0x7cf00000 depending on the chip.

Some of the hardware revisions I previously added can't be matched with
the current mask, these are already handled by other revision defines
so remove them.

When masking the revision defines with 0x7c800000:

RL_HWREV_8106E_SPIN1 is the same as RL_HWREV_8106E
RL_HWREV_8168G_SPIN1 is the same as RL_HWREV_8168G
RL_HWREV_8168G_SPIN2 is the same as RL_HWREV_8168GU
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.81 2014/04/23 02:39:28 jsg Exp $	*/
d194 1
@


1.81
log
@Add support for RTL8168GU
from Rafael Neves
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.80 2014/03/13 13:11:30 brad Exp $	*/
a190 1
#define RL_HWREV_8106E_SPIN1	0x44900000
a193 1
#define RL_HWREV_8168G_SPIN1	0x4c100000
a194 1
#define RL_HWREV_8168G_SPIN2	0x50900000
@


1.80
log
@Missed removing some bits with rev 1.147.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.79 2014/03/08 22:37:32 brad Exp $	*/
d196 1
@


1.79
log
@Add the RX earlyoff support for older chips (8168{E-VL,EP, F}) and RXDV GATED
bits for the 8168G controller. This fixes operation of the 8168G controllers.
This makes reception of packets work with the 8168G controllers in the Shuttle
DS47 and other systems.

From FreeBSD, based on the Realtek Linux driver.

ok sthen@@ giovani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.78 2013/11/18 22:21:27 brad Exp $	*/
a837 1
	int			rl_testmode;
@


1.78
log
@Enable MSI on the remaining chipsets.

ok naddy@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.77 2013/10/11 14:00:18 jsg Exp $	*/
d145 1
d287 1
a287 1
#define RL_RXCFG_EARLYOFF	0x00000100
d290 2
a291 1
#define	RL_RXCFG_FIFOTHRESH	0x0000E000
d861 2
@


1.77
log
@Add initial RTL8106E and RTL8168G/8111G support.
An earlier version didn't seem to work on a machine bmercer@@
had access to a few months ago but this seems to work
with the onboard Ethernet in an ASUS Z87 board RD Thrush has.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.76 2013/03/17 20:47:23 brad Exp $	*/
d428 1
@


1.76
log
@- Remove the reserved number of TX descriptors. No limitation is mentioned in
  the 8139C+/8169/8110/8168/8101/8111 datasheets and it seems to work ok
  without reserving the descriptors.
- Change allowable number of TX DMA segments to 32.

From FreeBSD

ok chris@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.75 2012/04/08 08:34:55 jsg Exp $	*/
d189 2
d193 4
d286 1
d857 1
@


1.75
log
@additional adapter types from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.74 2011/04/14 21:06:38 jsg Exp $	*/
d688 1
a688 1
#define RL_NTXDESC_RSVD		4
@


1.74
log
@Add several additional adapter types and correct definition of
RTL8103E, from FreeBSD.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.73 2011/03/13 15:35:20 stsp Exp $	*/
d187 4
@


1.73
log
@Wake On LAN support for re(4).
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.72 2010/11/28 22:08:59 kettenis Exp $	*/
d168 1
d170 1
a170 1
#define RL_HWREV_8103E		0x24C00000
d174 1
d179 1
d186 1
@


1.72
log
@Bring back MCLGETI; a fix for the issue that was the reason for its previous
backout will be committed shortly.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.71 2010/11/12 22:17:30 sthen Exp $	*/
d990 1
d1004 1
a1004 1
#define RL_PME_EN		0x0010
@


1.71
log
@revert MCLGETI for re(4) for now, it is causing hangs (in some cases
temporary, in others apparently permanent) with high rates of input
packets.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.65 2009/07/11 16:51:58 sthen Exp $	*/
d790 1
d792 1
@


1.70
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.69 2010/08/27 20:22:13 deraadt Exp $	*/
a789 1
	int			rl_rx_considx;
a790 1
	int			rl_rx_cnt;
@


1.69
log
@Move the activate function from pci to the the main driver, so that the
powerhook can use it
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.68 2010/06/28 16:04:09 sthen Exp $	*/
a811 1
	void			*sc_pwrhook;
@


1.68
log
@Add initial support for RTL8168E, brokenness reported by Joe Gidi.
With help from Brad, ok jsg@@, closes system/6402
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.67 2009/08/10 20:29:54 deraadt Exp $	*/
d1011 1
@


1.67
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.66 2009/07/23 20:15:32 kettenis Exp $	*/
d141 1
d172 1
d826 17
a842 16
#define	RL_FLAG_MSI		0x0001
#define	RL_FLAG_PCI64		0x0002
#define	RL_FLAG_PCIE		0x0004
#define	RL_FLAG_INVMAR		0x0008
#define	RL_FLAG_PHYWAKE		0x0010
#define	RL_FLAG_NOJUMBO		0x0020
#define	RL_FLAG_PAR		0x0040
#define	RL_FLAG_DESCV2		0x0080
#define	RL_FLAG_MACSTAT		0x0100
#define	RL_FLAG_HWIM		0x0200
#define	RL_FLAG_TIMERINTR	0x0400
#define	RL_FLAG_MACLDPS		0x0800
#define	RL_FLAG_CMDSTOP		0x1000
#define	RL_FLAG_MACSLEEP	0x2000
#define	RL_FLAG_AUTOPAD		0x4000
#define	RL_FLAG_LINK		0x8000
@


1.66
log
@Switch re(4) over to MCLGETI.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.65 2009/07/11 16:51:58 sthen Exp $	*/
a809 1
	void			*sc_sdhook;	/* shutdownhook */
@


1.65
log
@- Add some new feature flags
- Add defines for newer chipsets

From FreeBSD via Brad. No functional change, needed for future work.
ok naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.64 2009/07/10 21:27:49 sthen Exp $	*/
d788 1
d790 1
@


1.64
log
@Swap the hardware revision IDs for 8169S and 8110S. Agrees with the
labelling on naddy@@'s PCI cards. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.63 2009/07/03 16:55:27 deraadt Exp $	*/
d139 2
d321 1
d835 3
@


1.63
log
@Support RTL8103E and RTL8168DP which are starting to show up, from brad.
OK from kettenis and sthen after the diff was minimized to have no
potential impact on other chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.62 2009/06/03 00:11:19 sthen Exp $	*/
d161 2
a162 2
#define RL_HWREV_8110S		0x00800000
#define RL_HWREV_8169S		0x04000000
@


1.62
log
@from Brad; I've read and tested it, also reads ok to dlg@@.

- Further simplify the re(4) receive filter handling and
  have everything taken care of in re_iff(), eliminating
  a bit of code from re_init().
- Remove unused if_flags field.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.61 2009/06/02 17:27:39 jsg Exp $	*/
d166 1
d168 1
@


1.61
log
@make rl at pci detachable; untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.60 2009/02/12 11:55:29 martynas Exp $	*/
a807 1
	int			if_flags;
@


1.60
log
@don't access undocumented register 0x82 for <= MAC06, since newer
realteks start to behave badly if we do.  this should fix the widely
reported re(4) issue.  makes my RTL8101E usable, fixes Thomas'
RTL8168C, and PR6023.  tested by many
this is a more conservative version of my diff from kettenis@@ (does
not clear PHY register 0x0b)
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.59 2008/11/30 06:01:45 brad Exp $	*/
d999 1
@


1.59
log
@Add initial 8168D/8111D support.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.58 2008/11/08 06:52:49 brad Exp $	*/
d830 1
@


1.58
log
@Reduce the delay's a bit in the miibus read/write routines.

Based on the Linux r8169 driver.

Tested on PCI/CardBus and PCIe adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.57 2008/11/08 03:49:27 brad Exp $	*/
d166 1
@


1.57
log
@Reduce the number of TX descriptors to 512, such a large number is not
necessary without TSO.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.56 2008/10/11 23:49:05 brad Exp $	*/
d897 1
@


1.56
log
@Use hardware timer to simulate interrupt moderation.  Old devices will no
longer be livelocked when they are receiving on GigE line.  Newer devices
also gain well controlled interrupt rate.

If hardware supports interrupt moderation (e.g. 8168B, 8168C), you could
also use hardware based interrupt moderation, however, due to lack of
necessary information it does not work as reliably as simulated interrupt
moderation.  It is _not_ recommended currently.

By default, PCIe devices' simulated interrupt moderation timer is set to
75us, while PCI devices' is set to 125us.

From sephe@@DragonFly
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.55 2008/10/06 00:34:10 brad Exp $	*/
d668 1
a668 1
#define RL_TX_DESC_CNT_8169	1024
@


1.55
log
@Detect and store the PCI/PCIe bus speed.

From DragonFly
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.54 2008/10/05 22:43:40 brad Exp $	*/
d237 2
a238 2
	RL_ISR_RX_OVERRUN|RL_ISR_PKT_UNDERRUN|RL_ISR_FIFO_OFLOW|	\
	RL_ISR_PCS_TIMEOUT|RL_ISR_SYSTEM_ERR|RL_ISR_TIMEOUT_EXPIRED)
d240 4
d526 4
d827 2
d830 11
@


1.54
log
@Add a flag to indicate a 64-bit PCI bus is present.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.53 2008/10/05 22:32:11 brad Exp $	*/
d396 4
a399 3
#define RL_CFG2_PCI33MHZ	0x00
#define RL_CFG2_PCI66MHZ	0x01
#define RL_CFG2_PCI64BIT	0x08
d793 1
@


1.53
log
@Detect if the adapter is a PCIe adapter and set the RL_FLAG_PCIE flag
if so.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.52 2008/08/27 20:38:59 brad Exp $	*/
d809 8
a816 7
#define	RL_FLAG_PCIE		0x0002
#define	RL_FLAG_INVMAR		0x0004
#define	RL_FLAG_PHYWAKE		0x0008
#define	RL_FLAG_NOJUMBO		0x0010
#define	RL_FLAG_PAR		0x0020
#define	RL_FLAG_DESCV2		0x0040
#define	RL_FLAG_MACSTAT		0x0080
@


1.52
log
@Remove a redundant define for RL_CFG2 and remove an incorrect comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.51 2008/08/13 03:59:16 brad Exp $	*/
d809 1
@


1.51
log
@Add more Config mode registers.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.50 2008/08/11 22:42:19 brad Exp $	*/
a121 1
#define RL_CFG2		0x0053
d222 1
a222 1
#define RL_ISR_FIFO_OFLOW	0x0040	/* 8139 only */
@


1.50
log
@Add support for TX/RX checksum offload for newer re(4) chipsets.

Tested by naddy@@

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.49 2008/07/15 13:21:17 jsg Exp $	*/
d81 5
a85 1
					/* 0053-0057 reserved */
d382 1
d384 1
d388 1
d395 31
a816 1
	int			rl_link;
@


1.49
log
@Adapt some code from the FreeBSD driver required to make
newer PCI Express adapters (ie 8168C*/8102*) work.

V2 Checksum offload format in RTL8102 devices not yet supported.

No objections from brad@@. Thanks to everyone who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.48 2008/07/13 05:24:05 jsg Exp $	*/
d531 4
d572 2
d585 3
@


1.48
log
@Add some additional hardware revisions from FreeBSD needed for
upcoming changes and sort list.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.47 2008/04/20 01:18:02 brad Exp $	*/
d422 9
d761 9
@


1.47
log
@Move the threshold fix from the re(4) code back into the header as
it was going to be before the release. No functional change.

prodded by kettenis@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.46 2008/04/20 01:15:40 brad Exp $	*/
d162 1
d166 1
d170 3
a172 1
#define RL_HWREV_8168C		0x3C000000
d183 1
@


1.46
log
@- Recognize the 8168C chipset.
- Add some more defines for the 8168C chipset.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.45 2008/04/20 00:42:27 brad Exp $	*/
d463 1
a463 1
#define RL_RX_FIFOTHRESH	RL_RXFIFO_256BYTES
@


1.45
log
@- Add some more defines.
- Use one of the new defines in the re(4) code to remove a magic number.
- Correct a comment.
- Fix a typo.

Most of this is from NetBSD.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.44 2008/04/20 00:34:39 brad Exp $	*/
d91 3
d168 1
@


1.44
log
@Remove unused flags.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.43 2008/02/17 05:29:25 brad Exp $	*/
d126 1
d133 1
d135 2
a136 1
#define RL_GTXSTART		0x0038	/* 16 bits */
d440 1
a440 1
 * Instead, there are only four register sets, each or which represents
@


1.43
log
@Simplify the hw revision handling by removing the use of the
rl_type softc field and only relying on the sc_hwrev softc
field thoughout the driver.

Tested by a number of users from tech@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.42 2008/01/16 09:52:34 brad Exp $	*/
a727 1
	int			sc_flags;	/* misc flags */
a757 5


#define RL_ATTACHED	0x00000001	/* attach has succeeded */
#define RL_ENABLED	0x00000002	/* chip is enabled      */
#define RL_IS_ENABLED(sc)	((sc)->sc_flags & RL_ENABLED)
@


1.42
log
@- Store the hw revision into a new softc field in re_attach() and reference
the softc field wherever it is necessary.
- Use a switch case in re_setmulti() to make things a bit easier to read.

ok henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.41 2007/08/07 12:19:19 jsg Exp $	*/
a676 5
#define RL_8139CPLUS		3
#define RL_8169			4

#define RL_ISCPLUS(x)	((x)->rl_type == RL_8139CPLUS || \
			 (x)->rl_type == RL_8169)
@


1.41
log
@Correct value for power state D1.
While this duplicates the values specified in the PCI headers
and is currently unused, correcting this arguably makes more
sense than breaking diffability with FreeBSD.

Invalid value pointed out by Maxim Bourmistrov <maxim@@unixconn.com>

API change discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.40 2007/07/16 19:15:01 millert Exp $	*/
d727 1
@


1.40
log
@The logic determining the value of rl_eewidth for the 9346 and 9356
eeproms was backwards.  This resulted in a bogus MAC address being
read from the eeprom on certain cards.  From FreeBSD.  OK pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.39 2007/06/06 22:02:31 pvalchev Exp $	*/
d897 1
a897 1
#define RL_PSTATE_D1		0x0002
@


1.39
log
@add another revision "RTL8168 3"; from NetBSD via Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.38 2007/06/06 18:51:19 pvalchev Exp $	*/
d314 3
@


1.38
log
@- Recognize the 8110SCe 8169 revision in re(4)
- Rename the existing 8110SC revision to 8110SCd to be consistent
info from the linux driver via Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.37 2007/05/08 18:49:32 deraadt Exp $	*/
d160 1
@


1.37
log
@rl_detach() is only used for cardbus case
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.36 2006/12/12 10:24:38 reyk Exp $	*/
d155 1
a155 1
#define RL_HWREV_8169_8110SC	0x18000000
d171 1
@


1.36
log
@add a workaround for hardware ip4csum-tx bug on re(4) chips. the
hardware checksum could be mangled with 28 byte or less IP packets.

>From tsutsui@@NetBSD
Tested by otto@@ brad@@ and Han Boetes <han at mijncomputer dot nl>
Tested by maja@@ with the 8139C+ chipset
Tested on amd64/i386/sparc64

ok mglocker@@ brad@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.35 2006/12/01 01:13:01 todd Exp $	*/
a898 1
extern int rl_detach(struct rl_softc *);
@


1.35
log
@rename 8100E id to spin 1 and add the 8100E second spin chip id
chip id from Linux r8169 driver
from brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.34 2006/11/26 10:58:16 jsg Exp $	*/
d687 1
d742 17
@


1.34
log
@correct hardware revision mask.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.33 2006/11/24 04:27:17 brad Exp $	*/
d157 1
a157 1
#define RL_HWREV_8100E		0x30800000
d160 1
@


1.33
log
@replace a magic number (reserved TX descs?) with macro

From tsutsui@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.32 2006/11/18 15:54:29 brad Exp $	*/
d143 1
a143 1
#define RL_TXCFG_HWREV		0x7CC00000
@


1.32
log
@- set descriptor DMA addresses before enabling TX and RX
- set RL_EARLY_TX_THRESH before starting TX and RX
- clear a TX timeout only if all queued packets are handled
- declare struct rl_txq separately
- minor style tweaks in re_txeof()

From tsutsui@@NetBSD

Tested by brad@@, maja@@ and kettenis@@
Tested on amd64/armish/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.31 2006/11/01 23:25:18 brad Exp $	*/
d589 2
@


1.31
log
@Put common data for each RX DMA descriptor into a new rxsoft structure.

From tsutsui@@NetBSD

Tested by brad@@ otto@@
Tested on amd64/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.30 2006/10/31 22:45:15 brad Exp $	*/
d680 6
d687 1
a687 5
	struct rl_txq {
		struct mbuf *txq_mbuf;
		bus_dmamap_t txq_dmamap;
		int txq_descidx;
	} rl_txq[RL_TX_QLEN];
d690 1
a692 1
	bus_dma_segment_t 	rl_tx_listseg;
d696 1
d702 1
a703 1
	int			rl_rx_prodidx;
@


1.30
log
@- Rename a variable to clarify meaning of index.
- Rename RL_[TR]X_DESC_INC() macro to RL_NEXT_[TR]X_DESC() and
change them to return rvalues to avoid possible side effects.
- Also define RL_NEXT_TXQ() for rl_txq index and use it as well.

From tsutsui@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.29 2006/10/31 07:04:25 brad Exp $	*/
d675 5
d696 1
a696 2
	struct mbuf		*rl_rx_mbuf[RL_RX_DESC_CNT];
	bus_dmamap_t		rl_rx_dmamap[RL_RX_DESC_CNT];
@


1.29
log
@- Make DMA descripter members volatile
- Remove usage of BUS_DMA_ALLOCNOW with bus_dmamap_create
- Use BUS_DMA_COHERENT on mapping DMA memory for TX/RX descriptors
- Adjust m_data and m_len directly rather than calling m_adj
- Proper use of bus_dmamap_sync against DMA descriptors

From tsutsui@@NetBSD

Tested by kettenis@@ brad@@ otto@@
Tested on armish/amd64/i386/sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.28 2006/08/16 19:38:34 brad Exp $	*/
d605 6
a610 4
#define RL_TX_DESC_INC(sc, x)	\
	((x) = ((x) + 1) % RL_TX_DESC_CNT(sc))
#define RL_RX_DESC_INC(sc, x)	\
	((x) = ((x) + 1) % RL_RX_DESC_CNT)
@


1.28
log
@Not a bug, but change the ID strings for devices with hardware rev
0x30000000 and 0x38000000 to both be 8168B/8111B. According to RealTek,
they're both the same device, but 0x30000000 is an earlier silicon spin.

From wpaul@@FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.27 2006/08/05 21:38:20 brad Exp $	*/
d485 4
a488 4
	u_int32_t		rl_cmdstat;
	u_int32_t		rl_vlanctl;
	u_int32_t		rl_bufaddr_lo;
	u_int32_t		rl_bufaddr_hi;
a591 2
#define RL_OWN(x)		(letoh32((x)->rl_cmdstat) & RL_RDESC_STAT_OWN)
#define RL_RXBYTES(x)		(letoh32((x)->rl_cmdstat) & sc->rl_rxlenmask)
d594 1
a594 1
#define RE_ETHER_ALIGN	sizeof(uint64_t)
d597 1
a597 1
#define RE_ETHER_ALIGN	0
d609 13
@


1.27
log
@- move the promiscuous mode handling code into re_setpromisc().
- have the NIC track the state and only set the promisc filter
if IFF_PROMISC is adjusted, otherwise only init the NIC if it
is not already running.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.26 2006/08/05 21:03:22 brad Exp $	*/
d156 1
a156 1
#define RL_HWREV_8168		0x30000000
d159 1
a159 1
#define RL_HWREV_8111		0x38000000
@


1.26
log
@- restructure the TX descriptor handling code to decouple the
  number of TX descriptors, the number of RX descriptors, and
  the number of mbufs.
- bump the number of TX descriptors for the rtl8169 chipset.

From yamt@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.25 2006/07/03 02:28:39 brad Exp $	*/
d706 1
@


1.25
log
@- re_attach(): Use bus_dma* directly instead of calling re_allocmem().
- re_attach(): Free bus_dma* resources if attach fails.
- re_newbuf(): Remove unnecessary error check.
- re_encap(): Better error handling.
- re_start(): Drop the packet if there are not enough TX descriptors.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.24 2006/07/01 23:39:36 brad Exp $	*/
d585 4
a588 1
#define RL_TX_DESC_CNT		64
a590 1
#define RL_TX_LIST_SZ		(RL_TX_DESC_CNT * sizeof(struct rl_desc))
a591 2
#define RL_IFQ_MAXLEN		512
#define RL_DESC_INC(x)		(x = (x + 1) % RL_TX_DESC_CNT)
d603 9
a618 2
#define RL_NTXSEGS		32

d663 15
a677 1
	struct mbuf		*rl_tx_mbuf[RL_TX_DESC_CNT];
a678 5
	int			rl_tx_prodidx;
	int			rl_rx_prodidx;
	int			rl_tx_considx;
	int			rl_tx_free;
	bus_dmamap_t		rl_tx_dmamap[RL_TX_DESC_CNT];
d683 1
a684 4
	bus_dmamap_t		rl_tx_list_map;
	struct rl_desc		*rl_tx_list;
	bus_dma_segment_t	rl_tx_listseg;
	int			rl_tx_listnseg;
@


1.24
log
@fix the hw rev id for the 8168 and add the id for the 8111

From wpaul FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.23 2006/06/27 07:29:23 brad Exp $	*/
d610 3
a612 1
#define	MAX_NUM_MULTICAST_ADDRESSES	128
d667 1
d671 1
@


1.23
log
@new HW revs, EEPROM commands, softc fields, some macros and device ids.

From wpaul FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.22 2006/06/27 05:53:37 brad Exp $	*/
d156 1
d159 1
a159 1
#define RL_HWREV_8168		0x38000000
@


1.22
log
@- add fixup code in the RX path for strict alignment architectures.
- add a workaround for reception of Jumbo frames.
- don't try to adjust alignment on non-strict alignment architectures,
  this resolves an issue with the PCI Express adapters.

From FreeBSD

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.21 2005/09/17 00:45:44 brad Exp $	*/
d149 2
d152 1
d154 5
a158 2
#define RL_HWREV_8169SB		0x10000000
#define RL_HWREV_8110S		0x00800000
d161 1
a161 1
#define RL_HWREV_8139AG	0x70800000
d309 9
d585 1
d681 1
d695 3
d723 18
d753 8
a760 5
#define	RT_DEVICEID_8129			0x8129
#define	RT_DEVICEID_8138			0x8138
#define	RT_DEVICEID_8139			0x8139
#define	RT_DEVICEID_8169			0x8169
#define	RT_DEVICEID_8100			0x8100
@


1.21
log
@add some Realtek chip ids
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.20 2005/08/03 16:27:39 brad Exp $	*/
d530 2
d578 7
@


1.20
log
@This commit was derived from a commit to FreeBSD..

Use stream bus space accesses to program the ID (station address)
registers; otherwise, the byte order of the address is changed on
big-endian machines.

Though our bus_space API is different.

Tested by form at pdp-11 dotorg dot ru and robert@@

ok mickey@@ robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.19 2005/04/15 03:13:03 brad Exp $	*/
d707 1
d709 2
@


1.19
log
@re-add RL_JUMBO_FRAMELEN/RL_JUMBO_MTU but this time use the right values
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.18 2005/04/15 03:03:21 brad Exp $	*/
d678 2
@


1.18
log
@add another 8169 rev and remove vtophys() hack for alpha now that the driver
has been bus_dma-ified
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.17 2004/10/13 22:49:24 miod Exp $	*/
d579 4
@


1.17
log
@Let the generic rtl code work if the bus-dependent code has decided to attach;
this lets the 8138-based cardbus devices to really attach.

8138-specific mii differences will need to be investigated; right now,
recognizing the 8138 as either 8139 or non-8139 causes it to lose the link
after a while, but nothing ifconfig can not reset...

From a discussion with and tested by Benot Izac, who owns a 8138-based
cardbus device.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.16 2004/09/30 17:37:54 jason Exp $	*/
d151 1
a777 5

#ifdef __alpha__
#undef vtophys
#define vtophys(va)	alpha_XXX_dmamap((vm_offset_t)va)
#endif
@


1.16
log
@bus_dma-ify... thanks to robert, jgs, and grange for testing
still borked on sparc64, but hey, one step at a time
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.15 2004/08/05 21:17:20 brad Exp $	*/
d613 1
@


1.15
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.14 2004/08/05 20:51:30 deraadt Exp $	*/
d444 1
d447 1
d585 1
d589 1
d644 3
a646 1
	struct arpcom		sc_arpcom;		/* interface info */
@


1.14
log
@compile before you commit damnit
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.12 2004/06/05 07:39:54 pvalchev Exp $	*/
a575 3

#define RL_JUMBO_FRAMELEN	9018
#define RL_JUMBO_MTU		(RL_JUMBO_FRAMELEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
@


1.13
log
@remove some separate per driver constants and use
ETHER_MAX_LEN_JUMBO/ETHERMTU_JUMBO where appropriate.

ok mcbride@@ henning@@ mickey@@
@
text
@d577 3
@


1.12
log
@add multicast support
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.11 2004/06/05 06:00:46 pvalchev Exp $	*/
a575 3

#define RL_JUMBO_FRAMELEN	9018
#define RL_JUMBO_MTU		(RL_JUMBO_FRAMELEN-ETHER_HDR_LEN-ETHER_CRC_LEN)
@


1.11
log
@Add defines for RealTek 8139C+/8169/8169S/8110S; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.10 2004/05/19 11:36:59 brad Exp $	*/
d579 2
@


1.10
log
@remove duplication, use ETHER_ALIGN from if_ether.h
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.9 2004/04/07 15:47:52 mickey Exp $	*/
d104 30
a133 1

d141 1
d143 19
d195 1
d197 3
d201 1
d209 6
d310 3
d353 60
d450 130
d612 22
d644 1
d648 1
d651 7
d660 4
d780 1
@


1.9
log
@attach on abocom's 8139; from Kimmo Sinkko <kimmo@@sinkko.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.8 2003/10/01 23:37:12 fgsch Exp $	*/
a315 2

#define RL_ETHER_ALIGN		2
@


1.8
log
@it turned that only adding the cardbus part was not enough to have
D-Link DFE690 working. add the missing bits here.
from Joshua Johnson <joshua.johnson at charter dot net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.7 2002/10/15 16:02:10 mickey Exp $	*/
d446 3
@


1.7
log
@re-init the hw on resume, from grendel@@zeitbombe.org
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.6 2002/06/09 03:14:18 todd Exp $	*/
d445 1
@


1.6
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.5 2002/06/08 00:10:54 aaron Exp $	*/
d372 1
@


1.5
log
@Add support for RealTek 8129/8139-based CardBus cards; mostly from NetBSD.
deraadt@@, jasoni@@ ok. Thanks to niklas@@ for donating a card for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.4 2002/03/14 01:26:55 millert Exp $	*/
d368 1
a368 1
	struct arpcom		arpcom;		/* interface info */
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.3 2001/06/23 22:03:08 fgsch Exp $	*/
d241 8
a248 4
/* 9346 EEPROM commands */
#define RL_EECMD_WRITE		0x140
#define RL_EECMD_READ		0x180
#define RL_EECMD_ERASE		0x1c0
d371 1
d487 1
@


1.3
log
@More constants cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.2 2001/05/22 11:35:16 mickey Exp $	*/
d481 2
a482 2
extern int rl_attach	__P((struct rl_softc *));
extern int rl_intr	__P((void *));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.3 2001/06/23 22:03:08 fgsch Exp $	*/
d241 4
a244 8
/* 9346/9356 EEPROM commands */
#define RL_EECMD_WRITE		0x5	/* 0101b */
#define RL_EECMD_READ		0x6	/* 0110b */
#define RL_EECMD_ERASE		0x7	/* 0111b */
#define RL_EECMD_LEN		4

#define RL_EEADDR_LEN0		6	/* 9346 */
#define RL_EEADDR_LEN1		8	/* 9356 */
d364 1
a364 1
	struct arpcom		sc_arpcom;		/* interface info */
a366 1
	void			*sc_sdhook;	/* shutdownhook */
d481 2
a482 3
extern int rl_attach(struct rl_softc *);
extern int rl_detach(struct rl_softc *);
extern int rl_intr(void *);
@


1.3.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.3.4.1 2002/06/11 03:42:20 art Exp $	*/
a371 1
	void			*sc_pwrhook;
@


1.2
log
@support for D-Link DFE-530TX and DFE-530TX+; from Maxim Tsyplakov <tm@@oganer.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.1 2001/04/10 22:52:00 aaron Exp $	*/
a474 7

/*
 * FreeBSDism
 */
#ifndef	ETHER_CRC_LEN
#define	ETHER_CRC_LEN		4
#endif
@


1.1
log
@Split RealTek 8129/8139 driver into bus-dependent and bus-independent parts;
prep for an rl CardBus attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rlreg.h,v 1.12 2001/02/20 19:10:14 jason Exp $	*/
d433 6
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.1 2001/04/10 22:52:00 aaron Exp $	*/
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtl81x9reg.h,v 1.1.4.1 2001/05/14 22:24:10 niklas Exp $	*/
a433 6
/* D-Link Vendor ID */
#define DLINK_VENDORID				0x1186

/* D-Link device IDs */
#define DLINK_DEVICEID_8139			0x1300

d469 7
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d481 2
a482 2
extern int rl_attach(struct rl_softc *);
extern int rl_intr(void *);
@


1.1.4.4
log
@Sync the SMP branch with 3.3
@
text
@d241 4
a244 8
/* 9346/9356 EEPROM commands */
#define RL_EECMD_WRITE		0x5	/* 0101b */
#define RL_EECMD_READ		0x6	/* 0110b */
#define RL_EECMD_ERASE		0x7	/* 0111b */
#define RL_EECMD_LEN		4

#define RL_EEADDR_LEN0		6	/* 9346 */
#define RL_EEADDR_LEN1		8	/* 9356 */
d364 1
a364 1
	struct arpcom		sc_arpcom;		/* interface info */
a366 2
	void			*sc_sdhook;	/* shutdownhook */
	void			*sc_pwrhook;
a481 1
extern int rl_detach(struct rl_softc *);
@


1.1.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a444 1
#define DLINK_DEVICEID_8139_2			0x1340
@


1.1.4.6
log
@Merge with the trunk
@
text
@d104 1
a104 30
/*
 * When operating in special C+ mode, some of the registers in an
 * 8139C+ chip have different definitions. These are also used for
 * the 8169 gigE chip.
 */
#define RL_DUMPSTATS_LO	0x0010	/* counter dump command register */
#define RL_DUMPSTATS_HI	0x0014	/* counter dump command register */
#define RL_TXLIST_ADDR_LO	0x0020	/* 64 bits, 256 byte alignment */
#define RL_TXLIST_ADDR_HI	0x0024	/* 64 bits, 256 byte alignment */
#define RL_TXLIST_ADDR_HPRIO_LO	0x0028	/* 64 bits, 256 byte aligned */
#define RL_TXLIST_ADDR_HPRIO_HI	0x002C	/* 64 bits, 256 byte aligned */
#define RL_CFG2		0x0053
#define RL_TIMERINT		0x0054	/* interrupt on timer expire */
#define RL_TXSTART		0x00D9	/* 8 bits */
#define RL_CPLUS_CMD		0x00E0	/* 16 bits */
#define RL_RXLIST_ADDR_LO	0x00E4	/* 64 bits, 256 byte alignment */
#define RL_RXLIST_ADDR_HI	0x00E8	/* 64 bits, 256 byte alignment */
#define RL_EARLY_TX_THRESH	0x00EC	/* 8 bits */

/*
 * Registers specific to the 8169 gigE chip
 */
#define RL_TIMERINT_8169	0x0058	/* different offset than 8139 */
#define RL_PHYAR		0x0060
#define RL_TBICSR		0x0064
#define RL_TBI_ANAR		0x0068
#define RL_TBI_LPAR		0x006A
#define RL_GMEDIASTAT		0x006C	/* 8 bits */
#define RL_MAXRXPKTLEN		0x00DA	/* 16 bits, chip multiplies by 8 */
#define RL_GTXSTART		0x0038	/* 16 bits */
a111 1
#define RL_TXCFG_IFG2		0x00080000	/* 8169 only */
a112 19
#define RL_TXCFG_HWREV		0x7CC00000

#define RL_LOOPTEST_OFF		0x00000000
#define RL_LOOPTEST_ON		0x00020000
#define RL_LOOPTEST_ON_CPLUS	0x00060000

#define RL_HWREV_8169		0x00000000
#define RL_HWREV_8169S		0x04000000
#define RL_HWREV_8110S		0x00800000
#define RL_HWREV_8139		0x60000000
#define RL_HWREV_8139A		0x70000000
#define RL_HWREV_8139AG	0x70800000
#define RL_HWREV_8139B		0x78000000
#define RL_HWREV_8130		0x7C000000
#define RL_HWREV_8139C		0x74000000
#define RL_HWREV_8139D		0x74400000
#define RL_HWREV_8139CPLUS	0x74800000
#define RL_HWREV_8101		0x74c00000
#define RL_HWREV_8100		0x78800000
a145 1
#define RL_ISR_LINKCHG		0x0020	/* 8169 only */
a146 3
#define RL_ISR_TX_DESC_UNAVAIL	0x0080	/* C+ only */
#define RL_ISR_SWI		0x0100	/* C+ only */
#define RL_ISR_CABLE_LEN_CHGD	0x2000
a147 1
#define RL_ISR_TIMEOUT_EXPIRED	0x4000
a154 6
#define RL_INTRS_CPLUS	\
	(RL_ISR_RX_OK|RL_ISR_RX_ERR|RL_ISR_TX_ERR|			\
	RL_ISR_RX_OVERRUN|RL_ISR_PKT_UNDERRUN|RL_ISR_FIFO_OFLOW|	\
	RL_ISR_PCS_TIMEOUT|RL_ISR_SYSTEM_ERR|RL_ISR_TIMEOUT_EXPIRED)


a249 3
#define RL_EECMD_READ_6BIT	0x180	/* XXX  */
#define RL_EECMD_READ_8BIT	0x600	/* EECMD_READ above maybe wrong? */

a289 60
 * 8139C+ register definitions
 */

/* RL_DUMPSTATS_LO register */

#define RL_DUMPSTATS_START	0x00000008

/* Transmit start register */

#define RL_TXSTART_SWI		0x01	/* generate TX interrupt */
#define RL_TXSTART_START	0x40	/* start normal queue transmit */
#define RL_TXSTART_HPRIO_START	0x80	/* start hi prio queue transmit */

/*
 * Config 2 register, 8139C+/8169/8169S/8110S only
 */
#define RL_CFG2_BUSFREQ		0x07
#define RL_CFG2_BUSWIDTH	0x08
#define RL_CFG2_AUXPWRSTS	0x10

#define RL_BUSFREQ_33MHZ	0x00
#define RL_BUSFREQ_66MHZ	0x01
                                        
#define RL_BUSWIDTH_32BITS	0x00
#define RL_BUSWIDTH_64BITS	0x08

/* C+ mode command register */

#define RL_CPLUSCMD_TXENB	0x0001	/* enable C+ transmit mode */
#define RL_CPLUSCMD_RXENB	0x0002	/* enable C+ receive mode */
#define RL_CPLUSCMD_PCI_MRW	0x0008	/* enable PCI multi-read/write */
#define RL_CPLUSCMD_PCI_DAC	0x0010	/* PCI dual-address cycle only */
#define RL_CPLUSCMD_RXCSUM_ENB	0x0020	/* enable RX checksum offload */
#define RL_CPLUSCMD_VLANSTRIP	0x0040	/* enable VLAN tag stripping */

/* C+ early transmit threshold */

#define RL_EARLYTXTHRESH_CNT	0x003F	/* byte count times 8 */ 

/*
 * Gigabit PHY access register (8169 only)
 */

#define RL_PHYAR_PHYDATA	0x0000FFFF
#define RL_PHYAR_PHYREG		0x001F0000
#define RL_PHYAR_BUSY		0x80000000

/*
 * Gigabit media status (8169 only)
 */
#define RL_GMEDIASTAT_FDX	0x01	/* full duplex */
#define RL_GMEDIASTAT_LINK	0x02	/* link up */
#define RL_GMEDIASTAT_10MBPS	0x04	/* 10mps link */
#define RL_GMEDIASTAT_100MBPS	0x08	/* 100mbps link */
#define RL_GMEDIASTAT_1000MBPS	0x10	/* gigE link */
#define RL_GMEDIASTAT_RXFLOW	0x20	/* RX flow control on */
#define RL_GMEDIASTAT_TXFLOW	0x40	/* TX flow control on */
#define RL_GMEDIASTAT_TBI	0x80	/* TBI enabled */

/*
d317 2
a328 132

/*
 * The 8139C+ and 8160 gigE chips support descriptor-based TX
 * and RX. In fact, they even support TCP large send. Descriptors
 * must be allocated in contiguous blocks that are aligned on a
 * 256-byte boundary. The rings can hold a maximum of 64 descriptors.
 */

/*
 * RX/TX descriptor definition. When large send mode is enabled, the
 * lower 11 bits of the TX rl_cmd word are used to hold the MSS, and
 * the checksum offload bits are disabled. The structure layout is
 * the same for RX and TX descriptors
 */

struct rl_desc {
	u_int32_t		rl_cmdstat;
	u_int32_t		rl_vlanctl;
	u_int32_t		rl_bufaddr_lo;
	u_int32_t		rl_bufaddr_hi;
};

#define RL_TDESC_CMD_FRAGLEN	0x0000FFFF
#define RL_TDESC_CMD_TCPCSUM	0x00010000	/* TCP checksum enable */
#define RL_TDESC_CMD_UDPCSUM	0x00020000	/* UDP checksum enable */
#define RL_TDESC_CMD_IPCSUM	0x00040000	/* IP header checksum enable */
#define RL_TDESC_CMD_MSSVAL	0x07FF0000	/* Large send MSS value */
#define RL_TDESC_CMD_LGSEND	0x08000000	/* TCP large send enb */
#define RL_TDESC_CMD_EOF	0x10000000	/* end of frame marker */
#define RL_TDESC_CMD_SOF	0x20000000	/* start of frame marker */
#define RL_TDESC_CMD_EOR	0x40000000	/* end of ring marker */
#define RL_TDESC_CMD_OWN	0x80000000	/* chip owns descriptor */

#define RL_TDESC_VLANCTL_TAG	0x00020000	/* Insert VLAN tag */
#define RL_TDESC_VLANCTL_DATA	0x0000FFFF	/* TAG data */

/*
 * Error bits are valid only on the last descriptor of a frame
 * (i.e. RL_TDESC_CMD_EOF == 1)
 */

#define RL_TDESC_STAT_COLCNT	0x000F0000	/* collision count */
#define RL_TDESC_STAT_EXCESSCOL	0x00100000	/* excessive collisions */
#define RL_TDESC_STAT_LINKFAIL	0x00200000	/* link faulure */
#define RL_TDESC_STAT_OWINCOL	0x00400000	/* out-of-window collision */
#define RL_TDESC_STAT_TXERRSUM	0x00800000	/* transmit error summary */
#define RL_TDESC_STAT_UNDERRUN	0x02000000	/* TX underrun occured */
#define RL_TDESC_STAT_OWN	0x80000000

/*
 * RX descriptor cmd/vlan definitions
 */

#define RL_RDESC_CMD_EOR	0x40000000
#define RL_RDESC_CMD_OWN	0x80000000
#define RL_RDESC_CMD_BUFLEN	0x00001FFF

#define RL_RDESC_STAT_OWN	0x80000000
#define RL_RDESC_STAT_EOR	0x40000000
#define RL_RDESC_STAT_SOF	0x20000000
#define RL_RDESC_STAT_EOF	0x10000000
#define RL_RDESC_STAT_FRALIGN	0x08000000	/* frame alignment error */
#define RL_RDESC_STAT_MCAST	0x04000000	/* multicast pkt received */
#define RL_RDESC_STAT_UCAST	0x02000000	/* unicast pkt received */
#define RL_RDESC_STAT_BCAST	0x01000000	/* broadcast pkt received */
#define RL_RDESC_STAT_BUFOFLOW	0x00800000	/* out of buffer space */
#define RL_RDESC_STAT_FIFOOFLOW	0x00400000	/* FIFO overrun */
#define RL_RDESC_STAT_GIANT	0x00200000	/* pkt > 4096 bytes */
#define RL_RDESC_STAT_RXERRSUM	0x00100000	/* RX error summary */
#define RL_RDESC_STAT_RUNT	0x00080000	/* runt packet received */
#define RL_RDESC_STAT_CRCERR	0x00040000	/* CRC error */
#define RL_RDESC_STAT_PROTOID	0x00030000	/* Protocol type */
#define RL_RDESC_STAT_IPSUMBAD	0x00008000	/* IP header checksum bad */
#define RL_RDESC_STAT_UDPSUMBAD	0x00004000	/* UDP checksum bad */
#define RL_RDESC_STAT_TCPSUMBAD	0x00002000	/* TCP checksum bad */
#define RL_RDESC_STAT_FRAGLEN	0x00001FFF	/* RX'ed frame/frag len */
#define RL_RDESC_STAT_GFRAGLEN	0x00003FFF	/* RX'ed frame/frag len */

#define RL_RDESC_VLANCTL_TAG	0x00010000	/* VLAN tag available
						   (rl_vlandata valid)*/
#define RL_RDESC_VLANCTL_DATA	0x0000FFFF	/* TAG data */

#define RL_PROTOID_NONIP	0x00000000
#define RL_PROTOID_TCPIP	0x00010000
#define RL_PROTOID_UDPIP	0x00020000
#define RL_PROTOID_IP		0x00030000
#define RL_TCPPKT(x)		(((x) & RL_RDESC_STAT_PROTOID) == \
				 RL_PROTOID_TCPIP)
#define RL_UDPPKT(x)		(((x) & RL_RDESC_STAT_PROTOID) == \
				 RL_PROTOID_UDPIP)

/*
 * Statistics counter structure (8139C+ and 8169 only)
 */
struct rl_stats {
	u_int32_t		rl_tx_pkts_lo;
	u_int32_t		rl_tx_pkts_hi;
	u_int32_t		rl_tx_errs_lo;
	u_int32_t		rl_tx_errs_hi;
	u_int32_t		rl_tx_errs;
	u_int16_t		rl_missed_pkts;
	u_int16_t		rl_rx_framealign_errs;
	u_int32_t		rl_tx_onecoll;
	u_int32_t		rl_tx_multicolls;
	u_int32_t		rl_rx_ucasts_hi;
	u_int32_t		rl_rx_ucasts_lo;
	u_int32_t		rl_rx_bcasts_lo;
	u_int32_t		rl_rx_bcasts_hi;
	u_int32_t		rl_rx_mcasts;
	u_int16_t		rl_tx_aborts;
	u_int16_t		rl_rx_underruns;
};

#define RL_RX_DESC_CNT		64
#define RL_TX_DESC_CNT		64
#define RL_RX_LIST_SZ		(RL_RX_DESC_CNT * sizeof(struct rl_desc))
#define RL_TX_LIST_SZ		(RL_TX_DESC_CNT * sizeof(struct rl_desc))
#define RL_RING_ALIGN		256
#define RL_IFQ_MAXLEN		512
#define RL_DESC_INC(x)		(x = (x + 1) % RL_TX_DESC_CNT)
#define RL_OWN(x)		(letoh32((x)->rl_cmdstat) & RL_RDESC_STAT_OWN)
#define RL_RXBYTES(x)		(letoh32((x)->rl_cmdstat) & sc->rl_rxlenmask)
#define RL_PKTSZ(x)		((x)/* >> 3*/)

#define RL_ADDR_LO(y)	((u_int64_t) (y) & 0xFFFFFFFF)
#define RL_ADDR_HI(y)	((u_int64_t) (y) >> 32)

#define RL_JUMBO_FRAMELEN	9018
#define RL_JUMBO_MTU		(RL_JUMBO_FRAMELEN-ETHER_HDR_LEN-ETHER_CRC_LEN)

#define	MAX_NUM_MULTICAST_ADDRESSES	128

a360 22
#define RL_8139CPLUS		3
#define RL_8169			4

#define RL_ISCPLUS(x)	((x)->rl_type == RL_8139CPLUS || \
			 (x)->rl_type == RL_8169)

struct rl_list_data {
	struct mbuf		*rl_tx_mbuf[RL_TX_DESC_CNT];
	struct mbuf		*rl_rx_mbuf[RL_RX_DESC_CNT];
	int			rl_tx_prodidx;
	int			rl_rx_prodidx;
	int			rl_tx_considx;
	int			rl_tx_free;
	bus_dmamap_t		rl_tx_dmamap[RL_TX_DESC_CNT];
	bus_dmamap_t		rl_rx_dmamap[RL_RX_DESC_CNT];
	bus_dmamap_t		rl_rx_list_map;
	struct rl_desc		*rl_rx_list;
	bus_dma_segment_t	rl_rx_listseg;
	bus_dmamap_t		rl_tx_list_map;
	struct rl_desc		*rl_tx_list;
	bus_dma_segment_t	rl_tx_listseg;
};
a370 1
	int			rl_eecmd_read;
a373 1
	int			sc_flags;	/* misc flags */
a375 7

	struct rl_list_data	rl_ldata;
	struct mbuf		*rl_head;
	struct mbuf		*rl_tail;
	u_int32_t		rl_rxlenmask;
	int			rl_testmode;
	struct timeout		timer_handle;
a377 4
#define RL_ATTACHED	0x00000001	/* attach has succeeded */
#define RL_ENABLED	0x00000002	/* chip is enabled      */
#define RL_IS_ENABLED(sc)	((sc)->sc_flags & RL_ENABLED)

a446 3
/* Abocom device IDs */
#define ABOCOM_DEVICEID_8139			0xab06

a490 1
extern void rl_setmulti(struct rl_softc *);
@


