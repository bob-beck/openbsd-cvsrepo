head	1.13;
access;
symbols
	OPENBSD_6_0:1.13.0.32
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.22
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.30
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.28
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.26
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.24
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.20
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.18
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.14
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.13
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.01.21.30.31;	author cnst;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.26.17.47.34;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.10.00.57.54;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.05.15.32.46;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.17.16.53.05;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.05.14.47.59;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.03.18.28.02;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.12.14.10.53;	author grange;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2004.01.05.17.27.29;	author markus;	state Exp;
branches;
next	;

1.2.2.1
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.12.46;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@/* $OpenBSD: nsclpcsio_isa.c,v 1.12 2007/06/01 21:30:31 cnst Exp $ */
/* $NetBSD: nsclpcsio_isa.c,v 1.5 2002/10/22 16:18:26 drochner Exp $ */

/*
 * Copyright (c) 2002 Matthias Drochner.  All rights reserved.
 * Copyright (c) 2004 Markus Friedl.  All rights reserved.
 * Copyright (c) 2004 Alexander Yurchenko.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * National Semiconductor PC87366 LPC Super I/O.
 * Supported logical devices: GPIO, TMS, VLM.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/gpio.h>
#include <sys/kernel.h>
#include <sys/sensors.h>
#include <sys/timeout.h>

#include <machine/bus.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/gpio/gpiovar.h>

#if defined(NSC_LPC_SIO_DEBUG)
#define DPRINTF(x)              do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

#define SIO_REG_SID	0x20	/* Super I/O ID */
#define SIO_SID_PC87366	0xE9 	/* PC87366 is identified by 0xE9.*/

#define SIO_REG_SRID	0x27	/* Super I/O Revision */

#define SIO_REG_LDN	0x07	/* Logical Device Number */
#define SIO_LDN_FDC	0x00	/* Floppy Disk Controller (FDC) */
#define SIO_LDN_PP	0x01	/* Parallel Port (PP) */
#define SIO_LDN_SP2	0x02	/* Serial Port 2 with IR (SP2) */
#define SIO_LDN_SP1	0x03	/* Serial Port 1 (SP1) */
#define SIO_LDN_SWC	0x04	/* System Wake-Up Control (SWC) */
#define SIO_LDN_KBCM	0x05	/* Mouse Controller (KBC) */
#define SIO_LDN_KBCK	0x06	/* Keyboard Controller (KBC) */
#define SIO_LDN_GPIO	0x07	/* General-Purpose I/O (GPIO) Ports */
#define SIO_LDN_ACB	0x08	/* ACCESS.bus Interface (ACB) */
#define SIO_LDN_FSCM	0x09	/* Fan Speed Control and Monitor (FSCM) */
#define SIO_LDN_WDT	0x0A	/* WATCHDOG Timer (WDT) */
#define SIO_LDN_GMP	0x0B	/* Game Port (GMP) */
#define SIO_LDN_MIDI	0x0C	/* Musical Instrument Digital Interface */
#define SIO_LDN_VLM	0x0D	/* Voltage Level Monitor (VLM) */
#define SIO_LDN_TMS	0x0E	/* Temperature Sensor (TMS) */

#define SIO_REG_ACTIVE	0x30	/* Logical Device Activate Register */
#define SIO_ACTIVE_EN		0x01	/* enabled */

#define SIO_REG_IO_MSB	0x60	/* I/O Port Base, bits 15-8 */
#define SIO_REG_IO_LSB	0x61	/* I/O Port Base, bits 7-0 */

#define SIO_LDNUM	15	/* total number of logical devices */

/* Supported logical devices description */
static const struct {
	const char *ld_name;
	int ld_num;
	int ld_iosize;
} sio_ld[] = {
	{ "GPIO", SIO_LDN_GPIO, 16 },
	{ "VLM", SIO_LDN_VLM, 16 },
	{ "TMS", SIO_LDN_TMS, 16 },
};

/* GPIO */
#define SIO_GPIO_PINSEL	0xf0
#define SIO_GPIO_PINCFG	0xf1
#define SIO_GPIO_PINEV	0xf2

#define SIO_GPIO_CONF_OUTPUTEN	(1 << 0)
#define SIO_GPIO_CONF_PUSHPULL	(1 << 1)
#define SIO_GPIO_CONF_PULLUP	(1 << 2)

#define SIO_GPDO0	0x00
#define SIO_GPDI0	0x01
#define SIO_GPEVEN0	0x02
#define SIO_GPEVST0	0x03
#define SIO_GPDO1	0x04
#define SIO_GPDI1	0x05
#define SIO_GPEVEN1	0x06
#define SIO_GPEVST1	0x07
#define SIO_GPDO2	0x08
#define SIO_GPDI2	0x09
#define SIO_GPDO3	0x0a
#define SIO_GPDI3	0x0b

#define SIO_GPIO_NPINS	29

/* TMS */
#define SIO_TEVSTS	0x00	/* Temperature Event Status */
#define SIO_TEVSMI	0x02	/* Temperature Event to SMI */
#define SIO_TEVIRQ	0x04	/* Temperature Event to IRQ */
#define SIO_TMSCFG	0x08	/* TMS Configuration */
#define SIO_TMSBS	0x09	/* TMS Bank Select */
#define SIO_TCHCFST	0x0A	/* Temperature Channel Config and Status */
#define SIO_RDCHT	0x0B	/* Read Channel Temperature */
#define SIO_CHTH	0x0C	/* Channel Temperature High Limit */
#define SIO_CHTL	0x0D	/* Channel Temperature Low Limit */
#define SIO_CHOTL	0x0E	/* Channel Overtemperature Limit */

/* VLM */
#define SIO_VEVSTS0	0x00	/* Voltage Event Status 0 */
#define SIO_VEVSTS1	0x01	/* Voltage Event Status 1 */
#define SIO_VEVSMI0	0x02	/* Voltage Event to SMI 0 */
#define SIO_VEVSMI1	0x03	/* Voltage Event to SMI 1 */
#define SIO_VEVIRQ0	0x04	/* Voltage Event to IRQ 0 */
#define SIO_VEVIRQ1	0x05	/* Voltage Event to IRQ 1 */
#define SIO_VID		0x06	/* Voltage ID */
#define SIO_VCNVR	0x07	/* Voltage Conversion Rate */
#define SIO_VLMCFG	0x08	/* VLM Configuration */
#define SIO_VLMBS	0x09	/* VLM Bank Select */
#define SIO_VCHCFST	0x0A	/* Voltage Channel Config and Status */
#define SIO_RDCHV	0x0B	/* Read Channel Voltage */
#define SIO_CHVH	0x0C	/* Channel Voltage High Limit */
#define SIO_CHVL	0x0D	/* Channel Voltage Low Limit */
#define SIO_OTSL	0x0E	/* Overtemperature Shutdown Limit */

#define SIO_REG_SIOCF1	0x21
#define SIO_REG_SIOCF2	0x22
#define SIO_REG_SIOCF3	0x23
#define SIO_REG_SIOCF4	0x24
#define SIO_REG_SIOCF5	0x25
#define SIO_REG_SIOCF8	0x28
#define SIO_REG_SIOCFA	0x2A
#define SIO_REG_SIOCFB	0x2B
#define SIO_REG_SIOCFC	0x2C
#define SIO_REG_SIOCFD	0x2D

#define	SIO_NUM_SENSORS	(3+14)
#define SIO_VLM_OFF	3
#define SIO_VREF	1235	/* 1000.0 * VREF */

struct nsclpcsio_softc {
	struct device sc_dev;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;

	bus_space_handle_t sc_ld_ioh[SIO_LDNUM];
	int sc_ld_en[SIO_LDNUM];

	/* GPIO */
	struct gpio_chipset_tag sc_gpio_gc;
	struct gpio_pin sc_gpio_pins[SIO_GPIO_NPINS];

	/* TMS and VLM */
	struct ksensor sensors[SIO_NUM_SENSORS];
	struct ksensordev sensordev;
};

#define GPIO_READ(sc, reg) \
	bus_space_read_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_GPIO], (reg))
#define GPIO_WRITE(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_GPIO], (reg), (val))
#define TMS_WRITE(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_TMS], (reg), (val))
#define TMS_READ(sc, reg) \
	bus_space_read_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_TMS], (reg))
#define VLM_WRITE(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_VLM], (reg), (val))
#define VLM_READ(sc, reg) \
	bus_space_read_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_VLM], (reg))

int	 nsclpcsio_isa_match(struct device *, void *, void *);
void	 nsclpcsio_isa_attach(struct device *, struct device *, void *);

struct cfattach nsclpcsio_isa_ca = {
	sizeof(struct nsclpcsio_softc),
	nsclpcsio_isa_match,
	nsclpcsio_isa_attach
};

struct cfdriver nsclpcsio_cd = {
	NULL, "nsclpcsio", DV_DULL
};

struct timeout  nsclpcsio_timeout;

static u_int8_t	nsread(bus_space_tag_t, bus_space_handle_t, int);
static void	nswrite(bus_space_tag_t, bus_space_handle_t, int, u_int8_t);

void	nsclpcsio_gpio_init(struct nsclpcsio_softc *);
int	nsclpcsio_gpio_pin_read(void *, int);
void	nsclpcsio_gpio_pin_write(void *, int, int);
void	nsclpcsio_gpio_pin_ctl(void *, int, int);

void	nsclpcsio_tms_init(struct nsclpcsio_softc *);
void	nsclpcsio_vlm_init(struct nsclpcsio_softc *);
void	nsclpcsio_tms_update(struct nsclpcsio_softc *);
void	nsclpcsio_vlm_update(struct nsclpcsio_softc *);
void	nsclpcsio_refresh(void *);

static u_int8_t
nsread(bus_space_tag_t iot, bus_space_handle_t ioh, int idx)
{
	bus_space_write_1(iot, ioh, 0, idx);
	return (bus_space_read_1(iot, ioh, 1));
}

static void
nswrite(bus_space_tag_t iot, bus_space_handle_t ioh, int idx, u_int8_t data)
{
	bus_space_write_1(iot, ioh, 0, idx);
	bus_space_write_1(iot, ioh, 1, data);
}

int
nsclpcsio_isa_match(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int iobase;
	int rv = 0;

	iot = ia->ia_iot;
	iobase = ia->ipa_io[0].base;
	if (bus_space_map(iot, iobase, 2, 0, &ioh))
		return (0);

	if (nsread(iot, ioh, SIO_REG_SID) == SIO_SID_PC87366)
		rv = 1;

	bus_space_unmap(iot, ioh, 2);

	if (rv) {
		ia->ipa_nio = 1;
		ia->ipa_io[0].length = 2;

		ia->ipa_nmem = 0;
		ia->ipa_nirq = 0;
		ia->ipa_ndrq = 0;
	}

	return (rv);
}

void
nsclpcsio_isa_attach(struct device *parent, struct device *self, void *aux)
{
	struct nsclpcsio_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	struct gpiobus_attach_args gba;
	bus_space_tag_t iot;
	int iobase;
	int i;

	iobase = ia->ipa_io[0].base;
	sc->sc_iot = iot = ia->ia_iot;
	if (bus_space_map(ia->ia_iot, iobase, 2, 0, &sc->sc_ioh)) {
		printf(": can't map i/o space\n");
		return;
	}
	printf(": NSC PC87366 rev %d:",
	    nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_SRID));

	/* Configure all supported logical devices */
	for (i = 0; i < sizeof(sio_ld) / sizeof(sio_ld[0]); i++) {
		sc->sc_ld_en[sio_ld[i].ld_num] = 0;

		/* Select the device and check if it's activated */
		nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, sio_ld[i].ld_num);
		if ((nsread(sc->sc_iot, sc->sc_ioh,
		    SIO_REG_ACTIVE) & SIO_ACTIVE_EN) == 0)
			continue;

		/* Map I/O space if necessary */
		if (sio_ld[i].ld_iosize != 0) {
			iobase = (nsread(sc->sc_iot, sc->sc_ioh,
			    SIO_REG_IO_MSB) << 8);
			iobase |= nsread(sc->sc_iot, sc->sc_ioh,
			    SIO_REG_IO_LSB);
			if (bus_space_map(sc->sc_iot, iobase,
			    sio_ld[i].ld_iosize, 0,
			    &sc->sc_ld_ioh[sio_ld[i].ld_num]))
				continue;
		}

		sc->sc_ld_en[sio_ld[i].ld_num] = 1;
		printf(" %s", sio_ld[i].ld_name);
	}

	printf("\n");

	nsclpcsio_gpio_init(sc);
	nsclpcsio_tms_init(sc);
	nsclpcsio_vlm_init(sc);

	/* Hook into hw.sensors sysctl */
	strlcpy(sc->sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sensordev.xname));
	for (i = 0; i < SIO_NUM_SENSORS; i++) {
		if (i < SIO_VLM_OFF && !sc->sc_ld_en[SIO_LDN_TMS])
			continue;
		if (i >= SIO_VLM_OFF && !sc->sc_ld_en[SIO_LDN_VLM])
			continue;
		sensor_attach(&sc->sensordev, &sc->sensors[i]);
	}
	sensordev_install(&sc->sensordev);
	if (sc->sc_ld_en[SIO_LDN_TMS] || sc->sc_ld_en[SIO_LDN_VLM]) {
		timeout_set(&nsclpcsio_timeout, nsclpcsio_refresh, sc);
		timeout_add_sec(&nsclpcsio_timeout, 2);
	}

	/* Attach GPIO framework */
	if (sc->sc_ld_en[SIO_LDN_GPIO]) {
		gba.gba_name = "gpio";
		gba.gba_gc = &sc->sc_gpio_gc;
		gba.gba_pins = sc->sc_gpio_pins;
		gba.gba_npins = SIO_GPIO_NPINS;
		config_found(&sc->sc_dev, &gba, NULL);
	}
}

void
nsclpcsio_refresh(void *arg)
{
	struct nsclpcsio_softc *sc = (struct nsclpcsio_softc *)arg;

	if (sc->sc_ld_en[SIO_LDN_TMS])
		nsclpcsio_tms_update(sc);
	if (sc->sc_ld_en[SIO_LDN_VLM])
		nsclpcsio_vlm_update(sc);
	timeout_add_sec(&nsclpcsio_timeout, 2);
}

void
nsclpcsio_tms_init(struct nsclpcsio_softc *sc)
{
	int i;

	/* Initialisation, PC87366.pdf, page 208 */
	TMS_WRITE(sc, 0x08, 0x00);
	TMS_WRITE(sc, 0x09, 0x0f);
	TMS_WRITE(sc, 0x0a, 0x08);
	TMS_WRITE(sc, 0x0b, 0x04);
	TMS_WRITE(sc, 0x0c, 0x35);
	TMS_WRITE(sc, 0x0d, 0x05);
	TMS_WRITE(sc, 0x0e, 0x05);

	TMS_WRITE(sc, SIO_TMSCFG, 0x00);

	/* Enable the sensors */
	for (i = 0; i < 3; i++) {
		TMS_WRITE(sc, SIO_TMSBS, i);
		TMS_WRITE(sc, SIO_TCHCFST, 0x01);

		sc->sensors[i].type = SENSOR_TEMP;
	}

	strlcpy(sc->sensors[0].desc, "Remote", sizeof(sc->sensors[0].desc));
	strlcpy(sc->sensors[1].desc, "Remote", sizeof(sc->sensors[1].desc));
	strlcpy(sc->sensors[2].desc, "Local", sizeof(sc->sensors[2].desc));

	nsclpcsio_tms_update(sc);
}

void
nsclpcsio_tms_update(struct nsclpcsio_softc *sc)
{
	u_int8_t status;
	int8_t sdata;
	int i;

	for (i = 0; i < 3; i++) {
		TMS_WRITE(sc, SIO_TMSBS, i);
		status = TMS_READ(sc, SIO_TCHCFST);
		if (!(status & 0x01)) {
			DPRINTF(("%s: status %d: disabled\n",
			    sc->sensors[i].desc, status));
			sc->sensors[i].value = 0;
			continue;
		}
		sdata = TMS_READ(sc, SIO_RDCHT);
		DPRINTF(("%s: status %d C %d\n", sc->sensors[i].desc,
		    status, sdata));
		sc->sensors[i].value = sdata * 1000000 + 273150000;
	}
}

void
nsclpcsio_vlm_init(struct nsclpcsio_softc *sc)
{
	int i;
	char *desc = NULL;

	VLM_WRITE(sc, SIO_VLMCFG, 0x00);

	/* Enable the sensors */
	for (i = 0; i < 14; i++) {
		VLM_WRITE(sc, SIO_VLMBS, i);
		VLM_WRITE(sc, SIO_VCHCFST, 0x01);

		desc = NULL;
		switch (i) {
		case 7:
			desc = "VSB";
			break;
		case 8:
			desc = "VDD";
			break;
		case 9:
			desc = "VBAT";
			break;
		case 10:
			desc = "AVDD";
			break;
		case 11:
			desc = "TS1";
			break;
		case 12:
			desc = "TS2";
			break;
		case 13:
			desc = "TS3";
			break;
		}
		/* only init .desc if we have something meaningful to say */
		if (desc != NULL)
			strlcpy(sc->sensors[SIO_VLM_OFF + i].desc, desc,
			    sizeof(sc->sensors[SIO_VLM_OFF + i].desc));
		sc->sensors[SIO_VLM_OFF + i].type = SENSOR_VOLTS_DC;

	}
	nsclpcsio_vlm_update(sc);
}

void
nsclpcsio_vlm_update(struct nsclpcsio_softc *sc)
{
	u_int8_t status;
	u_int8_t data;
	int scale, rfact, i;

	for (i = 0; i < 14; i++) {
		VLM_WRITE(sc, SIO_VLMBS, i);
		status = VLM_READ(sc, SIO_VCHCFST);
		if (!(status & 0x01)) {
			DPRINTF(("%s: status %d: disabled\n",
			    sc->sensors[SIO_VLM_OFF + i].desc, status));
			sc->sensors[SIO_VLM_OFF + i].value = 0;
			continue;
		}
		data = VLM_READ(sc, SIO_RDCHV);
		DPRINTF(("%s: status %d V %d\n",
		    sc->sensors[SIO_VLM_OFF + i].desc, status, data));

		scale = 1;
		switch (i) {
		case 7:
		case 8:
		case 10:
			scale = 2;
		}

		/* Vi = (2.45±0.05)*VREF *RDCHVi / 256 */
		rfact = 10 * scale * ((245 * SIO_VREF) >> 8);
		sc->sensors[SIO_VLM_OFF + i].value = data * rfact;
	}
}

static __inline void
nsclpcsio_gpio_pin_select(struct nsclpcsio_softc *sc, int pin)
{
	int port, shift;
	u_int8_t data;

	port = pin / 8;
	shift = pin % 8;
	data = (port << 4) | shift;

	nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, SIO_LDN_GPIO);
	nswrite(sc->sc_iot, sc->sc_ioh, SIO_GPIO_PINSEL, data);
}

void
nsclpcsio_gpio_init(struct nsclpcsio_softc *sc)
{
	int i;

	for (i = 0; i < SIO_GPIO_NPINS; i++) {
		sc->sc_gpio_pins[i].pin_num = i;
		sc->sc_gpio_pins[i].pin_caps = GPIO_PIN_INPUT |
		    GPIO_PIN_OUTPUT | GPIO_PIN_OPENDRAIN |
		    GPIO_PIN_PUSHPULL | GPIO_PIN_TRISTATE |
		    GPIO_PIN_PULLUP;

		/* Read initial state */
		sc->sc_gpio_pins[i].pin_state = nsclpcsio_gpio_pin_read(sc,
		    i) ? GPIO_PIN_HIGH : GPIO_PIN_LOW;
	}

	/* Create controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = nsclpcsio_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = nsclpcsio_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = nsclpcsio_gpio_pin_ctl;
}

int
nsclpcsio_gpio_pin_read(void *arg, int pin)
{
	struct nsclpcsio_softc *sc = arg;
	int port, shift, reg;
	u_int8_t data;

	port = pin / 8;
	shift = pin % 8;

	switch (port) {
	case 0:
		reg = SIO_GPDI0;
		break;
	case 1:
		reg = SIO_GPDI1;
		break;
	case 2:
		reg = SIO_GPDI2;
		break;
	case 3:
		reg = SIO_GPDI3;
		break;
	}

	data = GPIO_READ(sc, reg);

	return ((data >> shift) & 0x1);
}

void
nsclpcsio_gpio_pin_write(void *arg, int pin, int value)
{
	struct nsclpcsio_softc *sc = arg;
	int port, shift, reg;
	u_int8_t data;

	port = pin / 8;
	shift = pin % 8;

	switch (port) {
	case 0:
		reg = SIO_GPDO0;
		break;
	case 1:
		reg = SIO_GPDO1;
		break;
	case 2:
		reg = SIO_GPDO2;
		break;
	case 3:
		reg = SIO_GPDO3;
		break;
	}

	data = GPIO_READ(sc, reg);
	if (value == 0)
		data &= ~(1 << shift);
	else if (value == 1)
		data |= (1 << shift);

	GPIO_WRITE(sc, reg, data);
}

void
nsclpcsio_gpio_pin_ctl(void *arg, int pin, int flags)
{
	struct nsclpcsio_softc *sc = arg;
	u_int8_t conf = 1;

	nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, SIO_LDN_GPIO);
	nsclpcsio_gpio_pin_select(sc, pin);
	conf = nsread(sc->sc_iot, sc->sc_ioh, SIO_GPIO_PINCFG);

	conf &= ~(SIO_GPIO_CONF_OUTPUTEN | SIO_GPIO_CONF_PUSHPULL |
	    SIO_GPIO_CONF_PULLUP);
	if ((flags & GPIO_PIN_TRISTATE) == 0)
		conf |= SIO_GPIO_CONF_OUTPUTEN;
	if (flags & GPIO_PIN_PUSHPULL)
		conf |= SIO_GPIO_CONF_PUSHPULL;
	if (flags & GPIO_PIN_PULLUP)
		conf |= SIO_GPIO_CONF_PULLUP;

	nswrite(sc->sc_iot, sc->sc_ioh, SIO_GPIO_PINCFG, conf);
}
@


1.12
log
@remove strings from sensor.desc which are now present in sysctl variable names; ok grange@@
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.11 2007/03/22 16:55:31 deraadt Exp $ */
d340 1
a340 1
		timeout_add(&nsclpcsio_timeout, (20 * hz) / 10);
d362 1
a362 1
	timeout_add(&nsclpcsio_timeout, (20 * hz) / 10);
@


1.11
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.10 2006/12/23 17:46:39 deraadt Exp $ */
d389 3
a391 3
	strlcpy(sc->sensors[0].desc, "Remote Temp 1", sizeof(sc->sensors[0].desc));
	strlcpy(sc->sensors[1].desc, "Remote Temp 2", sizeof(sc->sensors[0].desc));
	strlcpy(sc->sensors[2].desc, "Local Temp", sizeof(sc->sensors[0].desc));
d456 1
a459 3
		else
			snprintf(sc->sensors[SIO_VLM_OFF + i].desc,
			    sizeof(sc->sensors[SIO_VLM_OFF].desc), "VSENS%d", i);
@


1.10
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.9 2006/06/26 17:47:34 kettenis Exp $ */
d179 2
a180 2
	struct sensor sensors[SIO_NUM_SENSORS];
	struct sensordev sensordev;
@


1.9
log
@Avoid using the rfact member of 'struct sensor' which is on its way out.
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.8 2006/04/10 00:57:54 deraadt Exp $ */
d180 1
d328 2
d335 1
a335 3
		strlcpy(sc->sensors[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sensors[i].device));
		sensor_add(&sc->sensors[i]);
d337 1
@


1.8
log
@unify temperature sensor names much more
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.7 2006/01/19 17:08:40 grange Exp $ */
d420 1
a420 1
	int scale, i;
a430 1
		scale = 1;
a433 1
			scale = 2;
a436 1
			scale = 2;
a442 1
			scale = 2;
a461 3
		/* Vi = (2.45±0.05)*VREF *RDCHVi / 256 */
		sc->sensors[SIO_VLM_OFF + i].rfact = 
		    10 * scale * ((245 * SIO_VREF) >> 8);
d471 1
a471 1
	int i;
d485 12
a496 2
		sc->sensors[SIO_VLM_OFF + i].value = 
		    data * sc->sensors[SIO_VLM_OFF + i].rfact;
@


1.7
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.6 2006/01/05 15:32:46 grange Exp $ */
d387 3
a389 3
	strlcpy(sc->sensors[0].desc, "TSENS1", sizeof(sc->sensors[0].desc));
	strlcpy(sc->sensors[1].desc, "TSENS2", sizeof(sc->sensors[0].desc));
	strlcpy(sc->sensors[2].desc, "TNSC", sizeof(sc->sensors[0].desc));
@


1.6
log
@Don't change pins state on attach.
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.5 2004/11/17 16:53:05 mickey Exp $ */
d334 1
a334 1
		SENSOR_ADD(&sc->sensors[i]);
@


1.5
log
@proper autoconf attachments; grange@@ testing; markus@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.4 2004/06/05 14:47:59 grange Exp $ */
d523 3
a525 5
		/* safe defaults */
		sc->sc_gpio_pins[i].pin_flags = GPIO_PIN_TRISTATE;
		sc->sc_gpio_pins[i].pin_state = GPIO_PIN_LOW;
		nsclpcsio_gpio_pin_ctl(sc, i, sc->sc_gpio_pins[i].pin_flags);
		nsclpcsio_gpio_pin_write(sc, i, sc->sc_gpio_pins[i].pin_state);
@


1.4
log
@Remove NGPIO button.
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.3 2004/06/03 18:28:02 grange Exp $ */
a56 3
#define SIO_BADDR0	0x2e
#define SIO_BADDR1	0x4e

a217 1
static int	nscheck(bus_space_tag_t, int);
d244 2
a245 2
static int
nscheck(bus_space_tag_t iot, int base)
d247 2
d250 1
d253 3
a255 1
	if (bus_space_map(iot, base, 2, 0, &ioh))
d257 1
d260 1
a261 2
	return (rv);
}
d263 8
a270 5
int
nsclpcsio_isa_match(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	int iobase;
d272 1
a272 17
	/* PC87366 has two possible locations depending on wiring */
	iobase = SIO_BADDR0;
	if (nscheck(ia->ia_iot, iobase))
		goto found;
	iobase = SIO_BADDR1;
	if (nscheck(ia->ia_iot, iobase))
		goto found;
	return (0);

found:
	ia->ipa_nio = 1;
	ia->ipa_io[0].base = iobase;
	ia->ipa_io[0].length = 2;
	ia->ipa_nmem = 0;
	ia->ipa_nirq = 0;
	ia->ipa_ndrq = 0;
	return (1);
@


1.3
log
@Add support for the GPIO logical device.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.2 2004/01/12 14:10:53 grange Exp $ */
a50 2
#include "gpio.h"

d292 1
a295 3
#if NGPIO > 0
	struct gpiobus_attach_args gba;
#endif
a333 1
#if NGPIO > 0
a334 1
#endif
a352 1
#if NGPIO > 0
a360 1
#endif
a508 1
#if NGPIO > 0
a633 1
#endif
@


1.2
log
@Move sensors externs to sys/sensors.h and introduce a macro
SENSOR_ADD to hide all operations with these externs.

ok markus@@
@
text
@d1 1
a1 1
/* $OpenBSD: nsclpcsio_isa.c,v 1.1 2004/01/05 17:27:29 markus Exp $ */
d7 1
d31 5
d39 1
d43 1
d49 4
d59 2
a60 2
#define SIO_BADDR0 0x2e
#define SIO_BADDR1 0x4e
d85 2
d90 37
d173 5
a177 3
	bus_space_tag_t sc_iot, sc_tms_iot, sc_vlm_iot;
	bus_space_handle_t sc_ioh, sc_tms_ioh, sc_vlm_ioh;
	int sc_tms, sc_vlm;
d179 5
d187 6
d194 2
a195 1
	bus_space_write_1((sc)->sc_tms_iot, (sc)->sc_tms_ioh, (reg), (val))
d197 2
a198 1
	bus_space_read_1((sc)->sc_tms_iot, (sc)->sc_tms_ioh, (reg))
d200 2
a201 1
	bus_space_write_1((sc)->sc_vlm_iot, (sc)->sc_vlm_ioh, (reg), (val))
d203 2
a204 1
	bus_space_read_1((sc)->sc_vlm_iot, (sc)->sc_vlm_ioh, (reg))
d221 14
a234 9
static u_int8_t	 nsread(bus_space_tag_t, bus_space_handle_t, int);
static void	 nswrite(bus_space_tag_t, bus_space_handle_t, int, u_int8_t);
static int	 nscheck(bus_space_tag_t, int);

void	 nsclpcsio_tms_init(struct nsclpcsio_softc *);
void	 nsclpcsio_vlm_init(struct nsclpcsio_softc *);
void	 nsclpcsio_tms_update(struct nsclpcsio_softc *);
void	 nsclpcsio_vlm_update(struct nsclpcsio_softc *);
void	 nsclpcsio_refresh(void *);
a238 1

a245 1

d290 1
a290 3
nsclpcsio_isa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d297 3
d307 1
a307 1
	printf(": NSC PC87366 rev %d",
d310 31
d344 1
a344 2
	printf("\n");

d346 1
a346 1
		if (i < SIO_VLM_OFF && !sc->sc_tms)
d348 1
a348 1
		if (i >= SIO_VLM_OFF && !sc->sc_vlm)
d354 1
a354 1
	if (sc->sc_tms || sc->sc_vlm) {
d358 11
d376 1
a376 1
	if (sc->sc_tms)
d378 1
a378 1
	if (sc->sc_vlm)
d386 1
a386 19
	u_int8_t val;
	int iobase, i;

	sc->sc_tms = 0;
	nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, SIO_LDN_TMS);
	val = nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_ACTIVE);
	if (!(val & 1)) {
		printf(", TMS disabled");
		return;
	}
	iobase = (nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_IO_MSB) << 8);
	iobase |= nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_IO_LSB);
	sc->sc_tms_iot = sc->sc_iot;
	if (bus_space_map(sc->sc_tms_iot, iobase, 16, 0, &sc->sc_tms_ioh)) {
		printf(", can't map TMS i/o space");
		return;
	}
	printf(", TMS at 0x%x", iobase);
	sc->sc_tms = 1;
d440 1
a440 2
	u_int8_t val;
	int iobase, scale, i;
a442 17
	sc->sc_vlm = 0;
	nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, SIO_LDN_VLM);
	val = nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_ACTIVE);
	if (!(val & 1)) {
		printf(", VLM disabled");
		return;
	}
	iobase = (nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_IO_MSB) << 8);
	iobase |= nsread(sc->sc_iot, sc->sc_ioh, SIO_REG_IO_LSB);
	sc->sc_vlm_iot = sc->sc_iot;
	if (bus_space_map(sc->sc_vlm_iot, iobase, 16, 0, &sc->sc_vlm_ioh)) {
		printf(", can't map VLM i/o space");
		return;
	}
	printf(", VLM at 0x%x", iobase);
	sc->sc_vlm = 1;

d516 128
@


1.2.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.2.2.2
log
@Merge with the trunk
@
text
@a6 1
 * Copyright (c) 2004 Alexander Yurchenko.  All rights reserved.
a29 5
/*
 * National Semiconductor PC87366 LPC Super I/O.
 * Supported logical devices: GPIO, TMS, VLM.
 */

a32 1
#include <sys/gpio.h>
a35 1

a40 2
#include <dev/gpio/gpiovar.h>

d47 2
a48 2
#define SIO_BADDR0	0x2e
#define SIO_BADDR1	0x4e
a72 2
#define SIO_ACTIVE_EN		0x01	/* enabled */

a75 37
#define SIO_LDNUM	15	/* total number of logical devices */

/* Supported logical devices description */
static const struct {
	const char *ld_name;
	int ld_num;
	int ld_iosize;
} sio_ld[] = {
	{ "GPIO", SIO_LDN_GPIO, 16 },
	{ "VLM", SIO_LDN_VLM, 16 },
	{ "TMS", SIO_LDN_TMS, 16 },
};

/* GPIO */
#define SIO_GPIO_PINSEL	0xf0
#define SIO_GPIO_PINCFG	0xf1
#define SIO_GPIO_PINEV	0xf2

#define SIO_GPIO_CONF_OUTPUTEN	(1 << 0)
#define SIO_GPIO_CONF_PUSHPULL	(1 << 1)
#define SIO_GPIO_CONF_PULLUP	(1 << 2)

#define SIO_GPDO0	0x00
#define SIO_GPDI0	0x01
#define SIO_GPEVEN0	0x02
#define SIO_GPEVST0	0x03
#define SIO_GPDO1	0x04
#define SIO_GPDI1	0x05
#define SIO_GPEVEN1	0x06
#define SIO_GPEVST1	0x07
#define SIO_GPDO2	0x08
#define SIO_GPDI2	0x09
#define SIO_GPDO3	0x0a
#define SIO_GPDI3	0x0b

#define SIO_GPIO_NPINS	29

d122 3
a124 2
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
a125 8
	bus_space_handle_t sc_ld_ioh[SIO_LDNUM];
	int sc_ld_en[SIO_LDNUM];

	/* GPIO */
	struct gpio_chipset_tag sc_gpio_gc;
	struct gpio_pin sc_gpio_pins[SIO_GPIO_NPINS];

	/* TMS and VLM */
a128 6
#define GPIO_READ(sc, reg) \
	bus_space_read_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_GPIO], (reg))
#define GPIO_WRITE(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_GPIO], (reg), (val))
d130 1
a130 2
	bus_space_write_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_TMS], (reg), (val))
d132 1
a132 2
	bus_space_read_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_TMS], (reg))
d134 1
a134 2
	bus_space_write_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_VLM], (reg), (val))
d136 1
a136 2
	bus_space_read_1((sc)->sc_iot,				\
	    (sc)->sc_ld_ioh[SIO_LDN_VLM], (reg))
d153 9
a161 14
static u_int8_t	nsread(bus_space_tag_t, bus_space_handle_t, int);
static void	nswrite(bus_space_tag_t, bus_space_handle_t, int, u_int8_t);
static int	nscheck(bus_space_tag_t, int);

void	nsclpcsio_gpio_init(struct nsclpcsio_softc *);
int	nsclpcsio_gpio_pin_read(void *, int);
void	nsclpcsio_gpio_pin_write(void *, int, int);
void	nsclpcsio_gpio_pin_ctl(void *, int, int);

void	nsclpcsio_tms_init(struct nsclpcsio_softc *);
void	nsclpcsio_vlm_init(struct nsclpcsio_softc *);
void	nsclpcsio_tms_update(struct nsclpcsio_softc *);
void	nsclpcsio_vlm_update(struct nsclpcsio_softc *);
void	nsclpcsio_refresh(void *);
d166 1
d174 1
d219 3
a221 1
nsclpcsio_isa_attach(struct device *parent, struct device *self, void *aux)
a224 1
	struct gpiobus_attach_args gba;
d235 1
a235 1
	printf(": NSC PC87366 rev %d:",
d238 2
a239 25
	/* Configure all supported logical devices */
	for (i = 0; i < sizeof(sio_ld) / sizeof(sio_ld[0]); i++) {
		sc->sc_ld_en[sio_ld[i].ld_num] = 0;

		/* Select the device and check if it's activated */
		nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, sio_ld[i].ld_num);
		if ((nsread(sc->sc_iot, sc->sc_ioh,
		    SIO_REG_ACTIVE) & SIO_ACTIVE_EN) == 0)
			continue;

		/* Map I/O space if necessary */
		if (sio_ld[i].ld_iosize != 0) {
			iobase = (nsread(sc->sc_iot, sc->sc_ioh,
			    SIO_REG_IO_MSB) << 8);
			iobase |= nsread(sc->sc_iot, sc->sc_ioh,
			    SIO_REG_IO_LSB);
			if (bus_space_map(sc->sc_iot, iobase,
			    sio_ld[i].ld_iosize, 0,
			    &sc->sc_ld_ioh[sio_ld[i].ld_num]))
				continue;
		}

		sc->sc_ld_en[sio_ld[i].ld_num] = 1;
		printf(" %s", sio_ld[i].ld_name);
	}
a242 5
	nsclpcsio_gpio_init(sc);
	nsclpcsio_tms_init(sc);
	nsclpcsio_vlm_init(sc);

	/* Hook into hw.sensors sysctl */
d244 1
a244 1
		if (i < SIO_VLM_OFF && !sc->sc_ld_en[SIO_LDN_TMS])
d246 1
a246 1
		if (i >= SIO_VLM_OFF && !sc->sc_ld_en[SIO_LDN_VLM])
d252 1
a252 1
	if (sc->sc_ld_en[SIO_LDN_TMS] || sc->sc_ld_en[SIO_LDN_VLM]) {
a255 9

	/* Attach GPIO framework */
	if (sc->sc_ld_en[SIO_LDN_GPIO]) {
		gba.gba_name = "gpio";
		gba.gba_gc = &sc->sc_gpio_gc;
		gba.gba_pins = sc->sc_gpio_pins;
		gba.gba_npins = SIO_GPIO_NPINS;
		config_found(&sc->sc_dev, &gba, NULL);
	}
d263 1
a263 1
	if (sc->sc_ld_en[SIO_LDN_TMS])
d265 1
a265 1
	if (sc->sc_ld_en[SIO_LDN_VLM])
d273 19
a291 1
	int i;
d345 2
a346 1
	int scale, i;
d349 17
a437 126
}

static __inline void
nsclpcsio_gpio_pin_select(struct nsclpcsio_softc *sc, int pin)
{
	int port, shift;
	u_int8_t data;

	port = pin / 8;
	shift = pin % 8;
	data = (port << 4) | shift;

	nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, SIO_LDN_GPIO);
	nswrite(sc->sc_iot, sc->sc_ioh, SIO_GPIO_PINSEL, data);
}

void
nsclpcsio_gpio_init(struct nsclpcsio_softc *sc)
{
	int i;

	for (i = 0; i < SIO_GPIO_NPINS; i++) {
		sc->sc_gpio_pins[i].pin_num = i;
		sc->sc_gpio_pins[i].pin_caps = GPIO_PIN_INPUT |
		    GPIO_PIN_OUTPUT | GPIO_PIN_OPENDRAIN |
		    GPIO_PIN_PUSHPULL | GPIO_PIN_TRISTATE |
		    GPIO_PIN_PULLUP;

		/* safe defaults */
		sc->sc_gpio_pins[i].pin_flags = GPIO_PIN_TRISTATE;
		sc->sc_gpio_pins[i].pin_state = GPIO_PIN_LOW;
		nsclpcsio_gpio_pin_ctl(sc, i, sc->sc_gpio_pins[i].pin_flags);
		nsclpcsio_gpio_pin_write(sc, i, sc->sc_gpio_pins[i].pin_state);
	}

	/* Create controller tag */
	sc->sc_gpio_gc.gp_cookie = sc;
	sc->sc_gpio_gc.gp_pin_read = nsclpcsio_gpio_pin_read;
	sc->sc_gpio_gc.gp_pin_write = nsclpcsio_gpio_pin_write;
	sc->sc_gpio_gc.gp_pin_ctl = nsclpcsio_gpio_pin_ctl;
}

int
nsclpcsio_gpio_pin_read(void *arg, int pin)
{
	struct nsclpcsio_softc *sc = arg;
	int port, shift, reg;
	u_int8_t data;

	port = pin / 8;
	shift = pin % 8;

	switch (port) {
	case 0:
		reg = SIO_GPDI0;
		break;
	case 1:
		reg = SIO_GPDI1;
		break;
	case 2:
		reg = SIO_GPDI2;
		break;
	case 3:
		reg = SIO_GPDI3;
		break;
	}

	data = GPIO_READ(sc, reg);

	return ((data >> shift) & 0x1);
}

void
nsclpcsio_gpio_pin_write(void *arg, int pin, int value)
{
	struct nsclpcsio_softc *sc = arg;
	int port, shift, reg;
	u_int8_t data;

	port = pin / 8;
	shift = pin % 8;

	switch (port) {
	case 0:
		reg = SIO_GPDO0;
		break;
	case 1:
		reg = SIO_GPDO1;
		break;
	case 2:
		reg = SIO_GPDO2;
		break;
	case 3:
		reg = SIO_GPDO3;
		break;
	}

	data = GPIO_READ(sc, reg);
	if (value == 0)
		data &= ~(1 << shift);
	else if (value == 1)
		data |= (1 << shift);

	GPIO_WRITE(sc, reg, data);
}

void
nsclpcsio_gpio_pin_ctl(void *arg, int pin, int flags)
{
	struct nsclpcsio_softc *sc = arg;
	u_int8_t conf = 1;

	nswrite(sc->sc_iot, sc->sc_ioh, SIO_REG_LDN, SIO_LDN_GPIO);
	nsclpcsio_gpio_pin_select(sc, pin);
	conf = nsread(sc->sc_iot, sc->sc_ioh, SIO_GPIO_PINCFG);

	conf &= ~(SIO_GPIO_CONF_OUTPUTEN | SIO_GPIO_CONF_PUSHPULL |
	    SIO_GPIO_CONF_PULLUP);
	if ((flags & GPIO_PIN_TRISTATE) == 0)
		conf |= SIO_GPIO_CONF_OUTPUTEN;
	if (flags & GPIO_PIN_PUSHPULL)
		conf |= SIO_GPIO_CONF_PUSHPULL;
	if (flags & GPIO_PIN_PULLUP)
		conf |= SIO_GPIO_CONF_PULLUP;

	nswrite(sc->sc_iot, sc->sc_ioh, SIO_GPIO_PINCFG, conf);
@


1.1
log
@temp/volt sensor for NS PC87366 LPC Super I/O; based on netbsd version; ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD:$ */
a228 3
	extern int nsensors;
	extern struct sensors_head sensors;

d250 1
a250 2
		sc->sensors[i].num = nsensors++;
		SLIST_INSERT_HEAD(&sensors, &sc->sensors[i], list);
@

