head	1.105;
access;
symbols
	OPENBSD_6_0:1.105.0.6
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.105.0.2
	OPENBSD_5_9_BASE:1.105
	OPENBSD_5_8:1.105.0.4
	OPENBSD_5_8_BASE:1.105
	OPENBSD_5_7:1.104.0.8
	OPENBSD_5_7_BASE:1.104
	OPENBSD_5_6:1.104.0.6
	OPENBSD_5_6_BASE:1.104
	OPENBSD_5_5:1.104.0.4
	OPENBSD_5_5_BASE:1.104
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.100.0.2
	OPENBSD_5_3_BASE:1.100
	OPENBSD_5_2:1.95.0.2
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.94
	OPENBSD_5_1:1.94.0.2
	OPENBSD_5_0:1.93.0.6
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.93.0.4
	OPENBSD_4_9_BASE:1.93
	OPENBSD_4_8:1.93.0.2
	OPENBSD_4_8_BASE:1.93
	OPENBSD_4_7:1.90.0.2
	OPENBSD_4_7_BASE:1.90
	OPENBSD_4_6:1.87.0.4
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.81.0.2
	OPENBSD_4_4_BASE:1.81
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.71.0.4
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.71.0.2
	OPENBSD_4_1_BASE:1.71
	OPENBSD_4_0:1.52.0.2
	OPENBSD_4_0_BASE:1.52
	OPENBSD_3_9:1.46.0.2
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.28.0.2
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.105
date	2015.07.19.06.28.12;	author yuo;	state Exp;
branches;
next	1.104;
commitid	vzHDNxGG1slGlZhk;

1.104
date	2014.02.01.01.51.27;	author brad;	state Exp;
branches;
next	1.103;

1.103
date	2013.12.28.03.30.40;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2013.05.28.09.46.06;	author mikeb;	state Exp;
branches;
next	1.101;

1.101
date	2013.03.17.00.23.44;	author brad;	state Exp;
branches;
next	1.100;

1.100
date	2013.01.13.05.40.05;	author brad;	state Exp;
branches;
next	1.99;

1.99
date	2013.01.10.00.37.24;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2013.01.10.00.24.11;	author dlg;	state Exp;
branches;
next	1.97;

1.97
date	2013.01.09.02.00.04;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2012.08.09.10.18.45;	author kettenis;	state Exp;
branches;
next	1.95;

1.95
date	2012.07.05.15.23.55;	author sthen;	state Exp;
branches;
next	1.94;

1.94
date	2011.12.19.13.21.01;	author sthen;	state Exp;
branches;
next	1.93;

1.93
date	2010.05.24.21.23.23;	author sthen;	state Exp;
branches;
next	1.92;

1.92
date	2010.04.09.22.01.37;	author sthen;	state Exp;
branches;
next	1.91;

1.91
date	2010.04.06.20.20.52;	author naddy;	state Exp;
branches;
next	1.90;

1.90
date	2010.02.16.09.12.33;	author sthen;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.08.19.07.03;	author naddy;	state Exp;
branches;
next	1.88;

1.88
date	2009.07.30.09.08.32;	author sthen;	state Exp;
branches;
next	1.87;

1.87
date	2009.07.03.04.54.05;	author dlg;	state Exp;
branches;
next	1.86;

1.86
date	2009.06.04.00.59.21;	author naddy;	state Exp;
branches;
next	1.85;

1.85
date	2009.05.21.23.04.20;	author sthen;	state Exp;
branches;
next	1.84;

1.84
date	2008.11.08.03.03.50;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2008.11.08.01.50.48;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.30.08.16.13;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.13.22.23.08;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.11.23.53.49;	author brad;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.10.21.18.41;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.10.21.15.14;	author brad;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.26.21.26.42;	author brad;	state Exp;
branches;
next	1.76;

1.76
date	2008.04.20.01.32.43;	author brad;	state Exp;
branches;
next	1.75;

1.75
date	2008.03.02.16.05.26;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.28.01.34.37;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2008.01.31.03.39.22;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.13.16.29.52;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.30.02.35.16;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.10.23.04.53;	author kettenis;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.31.15.04.33;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2006.12.30.23.04.39;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2006.12.22.14.11.03;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.22.22.33.49;	author brad;	state Exp;
branches;
next	1.65;

1.65
date	2006.10.20.03.52.22;	author brad;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.20.03.30.24;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2006.10.20.01.08.24;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2006.10.19.19.46.06;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2006.10.19.19.35.06;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.15.21.17.31;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.15.21.12.41;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2006.10.11.23.25.56;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2006.10.09.00.29.25;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.08.01.01.06;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2006.10.08.00.28.35;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2006.10.08.00.06.20;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2006.10.01.17.29.48;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.28.03.06.47;	author brad;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.27.21.06.16;	author brad;	state Exp;
branches;
next	1.50;

1.50
date	2006.07.23.06.34.03;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.26.04.59.26;	author brad;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.20.23.03.53;	author brad;	state Exp;
branches;
next	1.47;

1.47
date	2006.03.04.09.19.13;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.10.22.17.04;	author brad;	state Exp;
branches;
next	1.45;

1.45
date	2005.12.08.00.45.34;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2005.11.25.01.28.00;	author brad;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.20.01.36.43;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.15.21.46.25;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.06.21.51.55;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.06.07.25.05;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.06.03.49.28;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.06.03.22.28;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.06.01.41.02;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.05.09.42.44;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.05.09.19.00;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.01.17.22.26;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.01.03.04.35;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.01.02.47.30;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.17.20.16.31;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.17.20.09.55;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.17.20.05.47;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.27.14.15.47;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.22.00.22.10;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2005.06.29.04.37.07;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.11.06.12.14;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.11.06.08.33;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.26.04.40.09;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.05.22.30.52;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.05.19.11.34;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.24.02.27.12;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.12.22.41.31;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.31.06.59.25;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.27.18.25.48;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.26.00.59.58;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.13.16.18.56;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.26.06.01.28;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.26.04.37.47;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.20.14.14.21;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.04.11.30.06;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.08.20.55.29;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.02.17.24.24;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.05.18.30.54;	author nate;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.10.05.18.26.48;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.12.04.51.27;	author deraadt;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2001.04.11.05.47.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.29.19.00.36;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.28.05.22.25;	author jason;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.25.20;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.22.44;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.03.28.00.38.19;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2004.02.19.10.56.24;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.42.23;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.22.20.35;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.105
log
@use standardized register definition in mii.h rather than each
specific driver definition.

no logical change.

ok deraadt@@
@
text
@/*	$OpenBSD: brgphy.c,v 1.104 2014/02/01 01:51:27 brad Exp $	*/

/*
 * Copyright (c) 2000
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: brgphy.c,v 1.8 2002/03/22 06:38:52 wpaul Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/errno.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/pci/pcivar.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/mii/miidevs.h>

#include <dev/mii/brgphyreg.h>

#include <dev/pci/if_bgereg.h>
#include <dev/pci/if_bnxreg.h>

int brgphy_probe(struct device *, void *, void *);
void brgphy_attach(struct device *, struct device *, void *);

struct cfattach brgphy_ca = {
	sizeof(struct mii_softc), brgphy_probe, brgphy_attach, mii_phy_detach
};

struct cfdriver brgphy_cd = {
	NULL, "brgphy", DV_DULL
};

int	brgphy_service(struct mii_softc *, struct mii_data *, int);
void	brgphy_copper_status(struct mii_softc *);
void	brgphy_fiber_status(struct mii_softc *);
void	brgphy_5708s_status(struct mii_softc *);
void	brgphy_5709s_status(struct mii_softc *);
int	brgphy_mii_phy_auto(struct mii_softc *);
void	brgphy_loop(struct mii_softc *);
void	brgphy_reset(struct mii_softc *);
void	brgphy_reset_bge(struct mii_softc *);
void	brgphy_reset_bnx(struct mii_softc *);
void	brgphy_bcm5401_dspcode(struct mii_softc *);
void	brgphy_bcm5411_dspcode(struct mii_softc *);
void	brgphy_bcm5421_dspcode(struct mii_softc *);
void	brgphy_bcm54k2_dspcode(struct mii_softc *);
void	brgphy_adc_bug(struct mii_softc *);
void	brgphy_5704_a0_bug(struct mii_softc *);
void	brgphy_ber_bug(struct mii_softc *);
void	brgphy_crc_bug(struct mii_softc *);
void	brgphy_disable_early_dac(struct mii_softc *sc);
void	brgphy_jumbo_settings(struct mii_softc *);
void	brgphy_eth_wirespeed(struct mii_softc *);

const struct mii_phy_funcs brgphy_copper_funcs = {            
	brgphy_service, brgphy_copper_status, brgphy_reset,          
};

const struct mii_phy_funcs brgphy_fiber_funcs = {
	brgphy_service, brgphy_fiber_status, brgphy_reset,
};

const struct mii_phy_funcs brgphy_5708s_funcs = {
	brgphy_service, brgphy_5708s_status, brgphy_reset,
};

const struct mii_phy_funcs brgphy_5709s_funcs = {
	brgphy_service, brgphy_5709s_status, brgphy_reset,
};

static const struct mii_phydesc brgphys[] = {
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5400,
	  MII_STR_xxBROADCOM_BCM5400 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5401,
	  MII_STR_xxBROADCOM_BCM5401 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5411,
	  MII_STR_xxBROADCOM_BCM5411 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5421,
	  MII_STR_xxBROADCOM_BCM5421 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM54K2,
	  MII_STR_xxBROADCOM_BCM54K2 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5461,
	  MII_STR_xxBROADCOM_BCM5461 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5462,
	  MII_STR_xxBROADCOM_BCM5462 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5464,
	  MII_STR_xxBROADCOM_BCM5464 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5701,
	  MII_STR_xxBROADCOM_BCM5701 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5703,
	  MII_STR_xxBROADCOM_BCM5703 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5704,
	  MII_STR_xxBROADCOM_BCM5704 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5705,
	  MII_STR_xxBROADCOM_BCM5705 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5714,
	  MII_STR_xxBROADCOM_BCM5714 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5750,
	  MII_STR_xxBROADCOM_BCM5750 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5752,
	  MII_STR_xxBROADCOM_BCM5752 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5780,
	  MII_STR_xxBROADCOM_BCM5780 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM54XX,
	  MII_STR_xxBROADCOM2_BCM54XX },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5481,
	  MII_STR_xxBROADCOM2_BCM5481 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5482,
	  MII_STR_xxBROADCOM2_BCM5482 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5722,
	  MII_STR_xxBROADCOM2_BCM5722 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5755,
	  MII_STR_xxBROADCOM2_BCM5755 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5761,
	  MII_STR_xxBROADCOM2_BCM5761 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5784,
	  MII_STR_xxBROADCOM2_BCM5784 },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5787,
	  MII_STR_xxBROADCOM2_BCM5787 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5706,
	  MII_STR_xxBROADCOM_BCM5706 },
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5708C,
	  MII_STR_xxBROADCOM_BCM5708C },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5708S,
	  MII_STR_xxBROADCOM2_BCM5708S },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5709C,
	  MII_STR_xxBROADCOM2_BCM5709C },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5709S,
	  MII_STR_xxBROADCOM2_BCM5709S },
	{ MII_OUI_xxBROADCOM2,		MII_MODEL_xxBROADCOM2_BCM5709CAX,
	  MII_STR_xxBROADCOM2_BCM5709CAX },
	{ MII_OUI_xxBROADCOM3,		MII_MODEL_xxBROADCOM3_BCM5717C,
	  MII_STR_xxBROADCOM3_BCM5717C },
	{ MII_OUI_xxBROADCOM3,		MII_MODEL_xxBROADCOM3_BCM5719C,
	  MII_STR_xxBROADCOM3_BCM5719C },
	{ MII_OUI_xxBROADCOM3,		MII_MODEL_xxBROADCOM3_BCM5720C,
	  MII_STR_xxBROADCOM3_BCM5720C },
	{ MII_OUI_xxBROADCOM3,		MII_MODEL_xxBROADCOM3_BCM57765,
	  MII_STR_xxBROADCOM3_BCM57765 },
	{ MII_OUI_xxBROADCOM3,		MII_MODEL_xxBROADCOM3_BCM57780,
	  MII_STR_xxBROADCOM3_BCM57780 },
	{ MII_OUI_BROADCOM2,		MII_MODEL_BROADCOM2_BCM5906,
	  MII_STR_BROADCOM2_BCM5906 },

	{ 0,				0,
	  NULL },
};

int
brgphy_probe(struct device *parent, void *match, void *aux)
{
	struct mii_attach_args *ma = aux;

	if (mii_phy_match(ma, brgphys) != NULL)
		return (10);

	return (0);
}

void
brgphy_attach(struct device *parent, struct device *self, void *aux)
{
	struct mii_softc *sc = (struct mii_softc *)self;
	struct bge_softc *bge_sc = NULL;
	struct bnx_softc *bnx_sc = NULL;
	struct mii_attach_args *ma = aux;
	struct mii_data *mii = ma->mii_data;
	const struct mii_phydesc *mpd;
	char *devname;
	int fast_ether = 0;

	devname = sc->mii_dev.dv_parent->dv_cfdata->cf_driver->cd_name;

	if (strcmp(devname, "bge") == 0) {
		bge_sc = mii->mii_ifp->if_softc;

		if (bge_sc->bge_phy_flags & BGE_PHY_10_100_ONLY)
			fast_ether = 1;
	} else if (strcmp(devname, "bnx") == 0)
		bnx_sc = mii->mii_ifp->if_softc;

	mpd = mii_phy_match(ma, brgphys);
	printf(": %s, rev. %d\n", mpd->mpd_name, MII_REV(ma->mii_id2));

	sc->mii_inst = mii->mii_instance;
	sc->mii_phy = ma->mii_phyno;
	sc->mii_oui = MII_OUI(ma->mii_id1, ma->mii_id2);
	sc->mii_model = MII_MODEL(ma->mii_id2);
	sc->mii_rev = MII_REV(ma->mii_id2);
	sc->mii_pdata = mii;
	sc->mii_flags = ma->mii_flags;

	if (sc->mii_flags & MIIF_HAVEFIBER) {
		if (strcmp(devname, "bnx") == 0) {
			if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5708)
				sc->mii_funcs = &brgphy_5708s_funcs;
			else if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5709)
				sc->mii_funcs = &brgphy_5709s_funcs;
			else
				sc->mii_funcs = &brgphy_fiber_funcs;
		} else
			sc->mii_funcs = &brgphy_fiber_funcs;
	} else
		sc->mii_funcs = &brgphy_copper_funcs;

	if (fast_ether == 1)
		sc->mii_anegticks = MII_ANEGTICKS;
	else
		sc->mii_anegticks = MII_ANEGTICKS_GIGE;

	sc->mii_flags |= MIIF_NOISOLATE | MIIF_NOLOOP;

	PHY_RESET(sc);

	sc->mii_capabilities = PHY_READ(sc, MII_BMSR) & ma->mii_capmask;
	if (sc->mii_capabilities & BMSR_EXTSTAT)
		sc->mii_extcapabilities = PHY_READ(sc, MII_EXTSR);

#define ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	/* Create an instance of Ethernet media. */
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst), BMCR_ISO);

	/* Add the supported media types */
	if (sc->mii_flags & MIIF_HAVEFIBER) {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_SX, IFM_FDX, sc->mii_inst),
		    BMCR_S1000 | BMCR_FDX);

		/*
		 * 2.5Gb support is a software enabled feature on the
		 * BCM5708S and BCM5709S controllers.
		 */
		if (strcmp(devname, "bnx") == 0) {
			if (bnx_sc->bnx_phy_flags & BNX_PHY_2_5G_CAPABLE_FLAG)
				ADD(IFM_MAKEWORD(IFM_ETHER, IFM_2500_SX,
				    IFM_FDX, sc->mii_inst), 0);
		}
	} else {
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, 0, sc->mii_inst),
		    BMCR_S10);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_10_T, IFM_FDX, sc->mii_inst),
		    BMCR_S10 | BMCR_FDX);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, 0, sc->mii_inst),
		    BMCR_S100);
		ADD(IFM_MAKEWORD(IFM_ETHER, IFM_100_TX, IFM_FDX, sc->mii_inst),
		    BMCR_S100 | BMCR_FDX);

		if (fast_ether == 0) {
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, 0,
			    sc->mii_inst), BMCR_S1000);
			ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_T, IFM_FDX,
			    sc->mii_inst), BMCR_S1000 | BMCR_FDX);
		}
	}

	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst), 0);

#undef ADD
}

int
brgphy_service(struct mii_softc *sc, struct mii_data *mii, int cmd)
{
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int reg, speed = 0, gig;

	if ((sc->mii_dev.dv_flags & DVF_ACTIVE) == 0)
		return (ENXIO);

	switch (cmd) {
	case MII_POLLSTAT:
		/*
		 * If we're not polling our PHY instance, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);
		break;

	case MII_MEDIACHG:
		/*
		 * If the media indicates a different PHY instance,
		 * isolate ourselves.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst) {
			reg = PHY_READ(sc, MII_BMCR);
			PHY_WRITE(sc, MII_BMCR, reg | BMCR_ISO);
			return (0);
		}

		/*
		 * If the interface is not up, don't do anything.
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			break;

		PHY_RESET(sc); /* XXX hardware bug work-around */

		switch (IFM_SUBTYPE(ife->ifm_media)) {
		case IFM_AUTO:
			(void) brgphy_mii_phy_auto(sc);
			break;
		case IFM_2500_SX:
			speed = BRGPHY_5708S_BMCR_2500;
			goto setit;
		case IFM_1000_T:
			speed = BMCR_S1000;
			goto setit;
		case IFM_100_TX:
			speed = BMCR_S100;
			goto setit;
		case IFM_10_T:
			speed = BMCR_S10;
setit:
			brgphy_loop(sc);
			if ((ife->ifm_media & IFM_GMASK) == IFM_FDX) {
				speed |= BMCR_FDX;
				gig = GTCR_ADV_1000TFDX;
			} else {
				gig = GTCR_ADV_1000THDX;
			}

			PHY_WRITE(sc, MII_100T2CR, 0);
			PHY_WRITE(sc, MII_ANAR, ANAR_CSMA);
			PHY_WRITE(sc, MII_BMCR, speed);

			if ((IFM_SUBTYPE(ife->ifm_media) != IFM_1000_T) &&
			    (IFM_SUBTYPE(ife->ifm_media) != IFM_1000_SX) &&
			    (IFM_SUBTYPE(ife->ifm_media) != IFM_2500_SX))
				break;

			PHY_WRITE(sc, MII_100T2CR, gig);
			PHY_WRITE(sc, MII_BMCR,
			    speed|BMCR_AUTOEN|BMCR_STARTNEG);

			if (sc->mii_oui != MII_OUI_xxBROADCOM ||
			    sc->mii_model != MII_MODEL_xxBROADCOM_BCM5701)
 				break;

			if (mii->mii_media.ifm_media & IFM_ETH_MASTER)
				gig |= GTCR_MAN_MS|GTCR_ADV_MS;
			PHY_WRITE(sc, MII_100T2CR, gig);
			break;
		default:
			return (EINVAL);
		}
		break;

	case MII_TICK:
		/*
		 * If we're not currently selected, just return.
		 */
		if (IFM_INST(ife->ifm_media) != sc->mii_inst)
			return (0);

		/*
		 * Is the interface even up?
		 */
		if ((mii->mii_ifp->if_flags & IFF_UP) == 0)
			return (0);

		/*
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			break;

		/*
		 * Check to see if we have link.  If we do, we don't
		 * need to restart the autonegotiation process.  Read
		 * the BMSR twice in case it's latched.
		 */
		reg = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
		if (reg & BMSR_LINK) {
			sc->mii_ticks = 0;	/* Reset autoneg timer. */
			break;
		}

		/*
		 * Only retry autonegotiation every mii_anegticks seconds.
		 */
		if (++sc->mii_ticks <= sc->mii_anegticks)
			break;

		sc->mii_ticks = 0;
		brgphy_mii_phy_auto(sc);
		break;
	}

	/* Update the media status. */
	mii_phy_status(sc);

	/*
	 * Callback if something changed. Note that we need to poke the DSP on
	 * the Broadcom PHYs if the media changes.
	 */
	if (sc->mii_media_active != mii->mii_media_active || 
	    sc->mii_media_status != mii->mii_media_status ||
	    cmd == MII_MEDIACHG) {
		switch (sc->mii_oui) {
		case MII_OUI_BROADCOM:
			switch (sc->mii_model) {
			case MII_MODEL_BROADCOM_BCM5400:
				brgphy_bcm5401_dspcode(sc);
				break;
			}
			break;
		case MII_OUI_xxBROADCOM:
			switch (sc->mii_model) {
			case MII_MODEL_xxBROADCOM_BCM5401:
				if (sc->mii_rev == 1 || sc->mii_rev == 3)
					brgphy_bcm5401_dspcode(sc);
				break;
			case MII_MODEL_xxBROADCOM_BCM5411:
				brgphy_bcm5411_dspcode(sc);
				break;
			}
			break;
		}
	}

	/* Callback if something changed. */
	mii_phy_update(sc, cmd);

	return (0);
}

void
brgphy_copper_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr, bmsr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (bmsr & BMSR_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	bmcr = PHY_READ(sc, MII_BMCR);
	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		int auxsts;

		if ((bmsr & BMSR_ACOMP) == 0) {
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		auxsts = PHY_READ(sc, BRGPHY_MII_AUXSTS);

		switch (auxsts & BRGPHY_AUXSTS_AN_RES) {
		case BRGPHY_RES_1000FD:
			mii->mii_media_active |= IFM_1000_T | IFM_FDX;
			break;
		case BRGPHY_RES_1000HD:
			mii->mii_media_active |= IFM_1000_T | IFM_HDX;
			break;
		case BRGPHY_RES_100FD:
			mii->mii_media_active |= IFM_100_TX | IFM_FDX;
			break;
		case BRGPHY_RES_100T4:
			mii->mii_media_active |= IFM_100_T4 | IFM_HDX;
			break;
		case BRGPHY_RES_100HD:
			mii->mii_media_active |= IFM_100_TX | IFM_HDX;
			break;
		case BRGPHY_RES_10FD:
			mii->mii_media_active |= IFM_10_T | IFM_FDX;
			break;
		case BRGPHY_RES_10HD:
			mii->mii_media_active |= IFM_10_T | IFM_HDX;
			break;
		default:
			if (sc->mii_oui == MII_OUI_BROADCOM2 &&
			    sc->mii_model == MII_MODEL_BROADCOM2_BCM5906) {
				mii->mii_media_active |= (auxsts &
				    BRGPHY_RES_100) ? IFM_100_TX : IFM_10_T;
				mii->mii_media_active |= (auxsts &
				    BRGPHY_RES_FULL) ? IFM_FDX : IFM_HDX;
				break;
			}
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		if (mii->mii_media_active & IFM_FDX)
			mii->mii_media_active |= mii_phy_flowstatus(sc);

		if (IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) {
			if (PHY_READ(sc, MII_100T2SR) & GTSR_MS_RES)
				mii->mii_media_active |= IFM_ETH_MASTER;
		}
	} else
		mii->mii_media_active = ife->ifm_media;
}

void
brgphy_fiber_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr, bmsr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (bmsr & BMSR_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	bmcr = PHY_READ(sc, MII_BMCR);
	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		int val;

		if ((bmsr & BMSR_ACOMP) == 0) {
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		mii->mii_media_active |= IFM_1000_SX;

		val = PHY_READ(sc, MII_ANAR) & PHY_READ(sc, MII_ANLPAR);

		if (val & ANAR_X_FD)
			mii->mii_media_active |= IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;

		if (mii->mii_media_active & IFM_FDX)
			mii->mii_media_active |= mii_phy_flowstatus(sc);
	} else
		mii->mii_media_active = ife->ifm_media;
}

void
brgphy_5708s_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr, bmsr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

	bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
	if (bmsr & BMSR_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

	bmcr = PHY_READ(sc, MII_BMCR);
	if (bmcr & BMCR_LOOP)
		mii->mii_media_active |= IFM_LOOP;

	if (bmcr & BMCR_AUTOEN) {
		int xstat;

		if ((bmsr & BMSR_ACOMP) == 0) {
			/* Erg, still trying, I guess... */
			mii->mii_media_active |= IFM_NONE;
			return;
		}

		PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR,
		    BRGPHY_5708S_DIG_PG0);

		xstat = PHY_READ(sc, BRGPHY_5708S_PG0_1000X_STAT1);

		switch (xstat & BRGPHY_5708S_PG0_1000X_STAT1_SPEED_MASK) {
		case BRGPHY_5708S_PG0_1000X_STAT1_SPEED_10:
			mii->mii_media_active |= IFM_10_FL;
			break;
		case BRGPHY_5708S_PG0_1000X_STAT1_SPEED_100:
			mii->mii_media_active |= IFM_100_FX;
			break;
		case BRGPHY_5708S_PG0_1000X_STAT1_SPEED_1G:
			mii->mii_media_active |= IFM_1000_SX;
			break;
		case BRGPHY_5708S_PG0_1000X_STAT1_SPEED_25G:
			mii->mii_media_active |= IFM_2500_SX;
			break;
		}

		if (xstat & BRGPHY_5708S_PG0_1000X_STAT1_FDX)
			mii->mii_media_active |= IFM_FDX;
		else
			mii->mii_media_active |= IFM_HDX;

		if (mii->mii_media_active & IFM_FDX) {
			if (xstat & BRGPHY_5708S_PG0_1000X_STAT1_TX_PAUSE)
				mii->mii_media_active |= IFM_FLOW | IFM_ETH_TXPAUSE;
			if (xstat & BRGPHY_5708S_PG0_1000X_STAT1_RX_PAUSE)
				mii->mii_media_active |= IFM_FLOW | IFM_ETH_RXPAUSE;
		}
	} else
		mii->mii_media_active = ife->ifm_media;
}

void
brgphy_5709s_status(struct mii_softc *sc)
{
	struct mii_data *mii = sc->mii_pdata;
	struct ifmedia_entry *ife = mii->mii_media.ifm_cur;
	int bmcr, bmsr;

	mii->mii_media_status = IFM_AVALID;
	mii->mii_media_active = IFM_ETHER;

        bmsr = PHY_READ(sc, MII_BMSR) | PHY_READ(sc, MII_BMSR);
        if (bmsr & BMSR_LINK)
                mii->mii_media_status |= IFM_ACTIVE;

        bmcr = PHY_READ(sc, MII_BMCR);
        if (bmcr & BMCR_LOOP)
                mii->mii_media_active |= IFM_LOOP;

        if (bmcr & BMCR_AUTOEN) {
                int xstat;

                if ((bmsr & BMSR_ACOMP) == 0) {
                        /* Erg, still trying, I guess... */
                        mii->mii_media_active |= IFM_NONE;
                        return;
                }

                PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
                    BRGPHY_BLOCK_ADDR_GP_STATUS);

                xstat = PHY_READ(sc, BRGPHY_GP_STATUS_TOP_ANEG_STATUS);

                PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
                    BRGPHY_BLOCK_ADDR_COMBO_IEEE0);

                switch (xstat & BRGPHY_GP_STATUS_TOP_ANEG_SPEED_MASK) {
                case BRGPHY_GP_STATUS_TOP_ANEG_SPEED_10:
                        mii->mii_media_active |= IFM_10_FL;
                        break;
                case BRGPHY_GP_STATUS_TOP_ANEG_SPEED_100:
                        mii->mii_media_active |= IFM_100_FX;
                        break;
                case BRGPHY_GP_STATUS_TOP_ANEG_SPEED_1G:
                        mii->mii_media_active |= IFM_1000_SX;
                        break;
                case BRGPHY_GP_STATUS_TOP_ANEG_SPEED_25G:
                        mii->mii_media_active |= IFM_2500_SX;
                        break;
                }

                if (xstat & BRGPHY_GP_STATUS_TOP_ANEG_FDX)
                        mii->mii_media_active |= IFM_FDX;
                else
                        mii->mii_media_active |= IFM_HDX;

		if (mii->mii_media_active & IFM_FDX)
			mii->mii_media_active |= mii_phy_flowstatus(sc);
	} else
		mii->mii_media_active = ife->ifm_media;
}

int
brgphy_mii_phy_auto(struct mii_softc *sc)
{
	int anar, ktcr = 0;

	PHY_RESET(sc);

	if (sc->mii_flags & MIIF_HAVEFIBER) {
		anar = ANAR_X_FD | ANAR_X_HD;
		if (sc->mii_flags & MIIF_DOPAUSE)
			anar |= ANAR_X_PAUSE_TOWARDS;
		PHY_WRITE(sc, MII_ANAR, anar);
	} else {
		anar = BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA;
		if (sc->mii_flags & MIIF_DOPAUSE)
			anar |= ANAR_PAUSE_ASYM | ANAR_FC;
		PHY_WRITE(sc, MII_ANAR, anar);
	}

	/* Enable speed in the 1000baseT control register */
	ktcr = GTCR_ADV_1000TFDX | GTCR_ADV_1000THDX;
	if (sc->mii_oui == MII_OUI_xxBROADCOM &&
	    sc->mii_model == MII_MODEL_xxBROADCOM_BCM5701)
		ktcr |= GTCR_MAN_MS | GTCR_ADV_MS;
	PHY_WRITE(sc, MII_100T2CR, ktcr);
	ktcr = PHY_READ(sc, MII_100T2CR);

	/* Start autonegotiation */
	PHY_WRITE(sc, MII_BMCR, BMCR_AUTOEN | BMCR_STARTNEG);
	PHY_WRITE(sc, BRGPHY_MII_IMR, 0xFF00);

	return (EJUSTRETURN);
}

/* Enable loopback to force the link down. */
void
brgphy_loop(struct mii_softc *sc)
{
	u_int32_t bmsr;
	int i;

	PHY_WRITE(sc, MII_BMCR, BMCR_LOOP);
	for (i = 0; i < 15000; i++) {
		bmsr = PHY_READ(sc, MII_BMSR);
		if (!(bmsr & BMSR_LINK))
			break;
		DELAY(10);
	}
}

void
brgphy_reset(struct mii_softc *sc)
{
	char *devname;

	devname = sc->mii_dev.dv_parent->dv_cfdata->cf_driver->cd_name;

	mii_phy_reset(sc);

	switch (sc->mii_oui) {
	case MII_OUI_BROADCOM:
		switch (sc->mii_model) {
		case MII_MODEL_BROADCOM_BCM5400:
			brgphy_bcm5401_dspcode(sc);
			break;
		case MII_MODEL_BROADCOM_BCM5401:
			if (sc->mii_rev == 1 || sc->mii_rev == 3)
				brgphy_bcm5401_dspcode(sc);
			break;
		case MII_MODEL_BROADCOM_BCM5411:
			brgphy_bcm5411_dspcode(sc);
			break;
		}
		break;
	case MII_OUI_xxBROADCOM:
		switch (sc->mii_model) {
		case MII_MODEL_xxBROADCOM_BCM5421:
			brgphy_bcm5421_dspcode(sc);
			break;
		case MII_MODEL_xxBROADCOM_BCM54K2:
			brgphy_bcm54k2_dspcode(sc);
			break;
		}
		break;
	}

	/* Handle any bge (NetXtreme/NetLink) workarounds. */
	if (strcmp(devname, "bge") == 0)
		brgphy_reset_bge(sc);
	/* Handle any bnx (NetXtreme II) workarounds. */
	else if (strcmp(devname, "bnx") == 0)
		brgphy_reset_bnx(sc);
}

void
brgphy_reset_bge(struct mii_softc *sc)
{
	struct bge_softc *bge_sc = sc->mii_pdata->mii_ifp->if_softc;

	if (sc->mii_flags & MIIF_HAVEFIBER)
		return;

	switch (sc->mii_oui) {
	case MII_OUI_xxBROADCOM3:
		switch (sc->mii_model) {
		case MII_MODEL_xxBROADCOM3_BCM5717C:
		case MII_MODEL_xxBROADCOM3_BCM5719C:
		case MII_MODEL_xxBROADCOM3_BCM5720C:
		case MII_MODEL_xxBROADCOM3_BCM57765:
			return;
		}
	}

	if (bge_sc->bge_phy_flags & BGE_PHY_ADC_BUG)
		brgphy_adc_bug(sc);
	if (bge_sc->bge_phy_flags & BGE_PHY_5704_A0_BUG)
		brgphy_5704_a0_bug(sc);
	if (bge_sc->bge_phy_flags & BGE_PHY_BER_BUG)
		brgphy_ber_bug(sc);
	else if (bge_sc->bge_phy_flags & BGE_PHY_JITTER_BUG) {
	    PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0c00);
		PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG, 0x000a);

		if (bge_sc->bge_phy_flags & BGE_PHY_ADJUST_TRIM) {
			PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT, 0x110b);
			PHY_WRITE(sc, BRGPHY_TEST1, BRGPHY_TEST1_TRIM_EN |
			    0x4);
		} else
			PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT, 0x010b);

		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0400);
	}

	if (bge_sc->bge_phy_flags & BGE_PHY_CRC_BUG)
		brgphy_crc_bug(sc);

	/* Set Jumbo frame settings in the PHY. */
	if (bge_sc->bge_flags & BGE_JUMBO_CAPABLE)
		brgphy_jumbo_settings(sc);

	/* Adjust output voltage */
	if (sc->mii_oui == MII_OUI_BROADCOM2 &&
	    sc->mii_model == MII_MODEL_BROADCOM2_BCM5906)
		PHY_WRITE(sc, BRGPHY_MII_EPHY_PTEST, 0x12);

	/* Enable Ethernet@@Wirespeed */
	if (!(bge_sc->bge_phy_flags & BGE_PHY_NO_WIRESPEED))
		brgphy_eth_wirespeed(sc);

	/* Enable Link LED on Dell boxes */
	if (bge_sc->bge_phy_flags & BGE_PHY_NO_3LED) {
		PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL,
		    PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL)
		    & ~BRGPHY_PHY_EXTCTL_3_LED);
	}
}

void
brgphy_reset_bnx(struct mii_softc *sc)
{
	struct bnx_softc *bnx_sc = sc->mii_pdata->mii_ifp->if_softc;

	if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5708 &&
	    sc->mii_flags & MIIF_HAVEFIBER) {
		/* Store autoneg capabilities/results in digital block (Page 0) */
		PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, BRGPHY_5708S_DIG3_PG2);
		PHY_WRITE(sc, BRGPHY_5708S_PG2_DIGCTL_3_0,
		    BRGPHY_5708S_PG2_DIGCTL_3_0_USE_IEEE);
		PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, BRGPHY_5708S_DIG_PG0);

		/* Enable fiber mode and autodetection */
		PHY_WRITE(sc, BRGPHY_5708S_PG0_1000X_CTL1,
		    PHY_READ(sc, BRGPHY_5708S_PG0_1000X_CTL1) |
		    BRGPHY_5708S_PG0_1000X_CTL1_AUTODET_EN |
		    BRGPHY_5708S_PG0_1000X_CTL1_FIBER_MODE);

		/* Enable parallel detection */
		PHY_WRITE(sc, BRGPHY_5708S_PG0_1000X_CTL2,
		    PHY_READ(sc, BRGPHY_5708S_PG0_1000X_CTL2) |
		    BRGPHY_5708S_PG0_1000X_CTL2_PAR_DET_EN);

		/* Advertise 2.5G support through next page during autoneg */
		if (bnx_sc->bnx_phy_flags & BNX_PHY_2_5G_CAPABLE_FLAG) {
			PHY_WRITE(sc, BRGPHY_5708S_ANEG_NXT_PG_XMIT1,
			    PHY_READ(sc, BRGPHY_5708S_ANEG_NXT_PG_XMIT1) |
			    BRGPHY_5708S_ANEG_NXT_PG_XMIT1_25G);
		}

		/* Increase TX signal amplitude */
		if ((BNX_CHIP_ID(bnx_sc) == BNX_CHIP_ID_5708_A0) ||
		    (BNX_CHIP_ID(bnx_sc) == BNX_CHIP_ID_5708_B0) ||
		    (BNX_CHIP_ID(bnx_sc) == BNX_CHIP_ID_5708_B1)) {
			PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR,
			    BRGPHY_5708S_TX_MISC_PG5);
			PHY_WRITE(sc, BRGPHY_5708S_PG5_TXACTL1,
			    PHY_READ(sc, BRGPHY_5708S_PG5_TXACTL1) &
			    ~BRGPHY_5708S_PG5_TXACTL1_VCM);
			PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR,
			    BRGPHY_5708S_DIG_PG0);
		}

		/* Backplanes use special driver/pre-driver/pre-emphasis values. */
		if ((bnx_sc->bnx_shared_hw_cfg & BNX_SHARED_HW_CFG_PHY_BACKPLANE) &&
		    (bnx_sc->bnx_port_hw_cfg & BNX_PORT_HW_CFG_CFG_TXCTL3_MASK)) {
			PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR,
			    BRGPHY_5708S_TX_MISC_PG5);
			PHY_WRITE(sc, BRGPHY_5708S_PG5_TXACTL3,
			    bnx_sc->bnx_port_hw_cfg &
			    BNX_PORT_HW_CFG_CFG_TXCTL3_MASK);
			    PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR,
			    BRGPHY_5708S_DIG_PG0);
		}
	} else if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5709 &&
	    sc->mii_flags & MIIF_HAVEFIBER) {
		/* Select the SerDes Digital block of the AN MMD. */
		PHY_WRITE(sc, BRGPHY_BLOCK_ADDR, BRGPHY_BLOCK_ADDR_SERDES_DIG);

		PHY_WRITE(sc, BRGPHY_SERDES_DIG_1000X_CTL1,
		    (PHY_READ(sc, BRGPHY_SERDES_DIG_1000X_CTL1) &
		    ~BRGPHY_SD_DIG_1000X_CTL1_AUTODET) |
		    BRGPHY_SD_DIG_1000X_CTL1_FIBER);

		if (bnx_sc->bnx_phy_flags & BNX_PHY_2_5G_CAPABLE_FLAG) {
			/* Select the Over 1G block of the AN MMD. */
			PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
			    BRGPHY_BLOCK_ADDR_OVER_1G);

			/*
			 * Enable autoneg "Next Page" to advertise
			 * 2.5G support.
			 */
			PHY_WRITE(sc, BRGPHY_OVER_1G_UNFORMAT_PG1,
			    PHY_READ(sc, BRGPHY_OVER_1G_UNFORMAT_PG1) |
			    BRGPHY_5708S_ANEG_NXT_PG_XMIT1_25G);
		}

		/*
		 * Select the Multi-Rate Backplane Ethernet block of
		 * the AN MMD.
		 */
		PHY_WRITE(sc, BRGPHY_BLOCK_ADDR, BRGPHY_BLOCK_ADDR_MRBE);

		/* Enable MRBE speed autoneg. */
		PHY_WRITE(sc, BRGPHY_MRBE_MSG_PG5_NP,
		    PHY_READ(sc, BRGPHY_MRBE_MSG_PG5_NP) |
		    BRGPHY_MRBE_MSG_PG5_NP_MBRE |
		    BRGPHY_MRBE_MSG_PG5_NP_T2);

		/* Select the Clause 73 User B0 block of the AN MMD. */
		PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
		    BRGPHY_BLOCK_ADDR_CL73_USER_B0);

		/* Enable MRBE speed autoneg. */
		PHY_WRITE(sc, BRGPHY_CL73_USER_B0_MBRE_CTL1,
		    BRGPHY_CL73_USER_B0_MBRE_CTL1_NP_AFT_BP |
		    BRGPHY_CL73_USER_B0_MBRE_CTL1_STA_MGR |
		    BRGPHY_CL73_USER_B0_MBRE_CTL1_ANEG);

		PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
		    BRGPHY_BLOCK_ADDR_COMBO_IEEE0);
	} else if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5709) {
		if (BNX_CHIP_REV(bnx_sc) == BNX_CHIP_REV_Ax ||
		    BNX_CHIP_REV(bnx_sc) == BNX_CHIP_REV_Bx)
			brgphy_disable_early_dac(sc);

		/* Set Jumbo frame settings in the PHY. */
		brgphy_jumbo_settings(sc);  

		/* Enable Ethernet@@Wirespeed */
		brgphy_eth_wirespeed(sc);   
	} else if ((sc->mii_flags & MIIF_HAVEFIBER) == 0) {
		brgphy_ber_bug(sc);

		/* Set Jumbo frame settings in the PHY. */
		brgphy_jumbo_settings(sc);

		/* Enable Ethernet@@Wirespeed */
		brgphy_eth_wirespeed(sc);
	}
}

/* Disable tap power management */
void
brgphy_bcm5401_dspcode(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ BRGPHY_MII_AUXCTL,		0x0c20 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x0012 },
		{ BRGPHY_MII_DSP_RW_PORT,	0x1804 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x0013 },
		{ BRGPHY_MII_DSP_RW_PORT,	0x1204 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x8006 },
		{ BRGPHY_MII_DSP_RW_PORT,	0x0132 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x8006 },
		{ BRGPHY_MII_DSP_RW_PORT,	0x0232 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x201f },
		{ BRGPHY_MII_DSP_RW_PORT,	0x0a20 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
	DELAY(40);
}

/* Setting some undocumented voltage */
void
brgphy_bcm5411_dspcode(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ 0x1c,				0x8c23 },
		{ 0x1c,				0x8ca3 },
		{ 0x1c,				0x8c23 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

void
brgphy_bcm5421_dspcode(struct mii_softc *sc)
{
	uint16_t data;

	/* Set Class A mode */
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x1007);
	data = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, data | 0x0400);

	/* Set FFE gamma override to -0.125 */
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0007);
	data = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, data | 0x0800);
	PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG, 0x000a);
	data = PHY_READ(sc, BRGPHY_MII_DSP_RW_PORT);
	PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT, data | 0x0200);
}

void
brgphy_bcm54k2_dspcode(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ 4,				0x01e1 },
		{ 9,				0x0300 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

void
brgphy_adc_bug(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ BRGPHY_MII_AUXCTL,		0x0c00 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x201f },
		{ BRGPHY_MII_DSP_RW_PORT,	0x2aaa },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x000a },
		{ BRGPHY_MII_DSP_RW_PORT,	0x0323 },
		{ BRGPHY_MII_AUXCTL,		0x0400 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

void
brgphy_5704_a0_bug(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ 0x1c,				0x8d68 },
		{ 0x1c,				0x8d68 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

void
brgphy_ber_bug(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ BRGPHY_MII_AUXCTL,		0x0c00 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x000a },
		{ BRGPHY_MII_DSP_RW_PORT,	0x310b },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x201f },
		{ BRGPHY_MII_DSP_RW_PORT,	0x9506 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x401f },
		{ BRGPHY_MII_DSP_RW_PORT,	0x14e2 },
		{ BRGPHY_MII_AUXCTL,		0x0400 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

/* BCM5701 A0/B0 CRC bug workaround */
void
brgphy_crc_bug(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ BRGPHY_MII_DSP_ADDR_REG,	0x0a75 },
		{ 0x1c,				0x8c68 },
		{ 0x1c,				0x8d68 },
		{ 0x1c,				0x8c68 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

void
brgphy_disable_early_dac(struct mii_softc *sc)
{
	uint32_t val;

	PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG, 0x0f08);
	val = PHY_READ(sc, BRGPHY_MII_DSP_RW_PORT);
	val &= ~(1 << 8);
	PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT, val);

}

void
brgphy_jumbo_settings(struct mii_softc *sc)
{
	u_int32_t val;

	/* Set Jumbo frame settings in the PHY. */
	if (sc->mii_oui == MII_OUI_BROADCOM &&
	    sc->mii_model == MII_MODEL_BROADCOM_BCM5401) {
		/* Cannot do read-modify-write on the BCM5401 */
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x4c20);
	} else {
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7);
		val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
			val | BRGPHY_AUXCTL_LONG_PKT);
	}

	val = PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL);
	PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL,
		val | BRGPHY_PHY_EXTCTL_HIGH_LA);
}

void
brgphy_eth_wirespeed(struct mii_softc *sc)
{
	u_int32_t val;

	/* Enable Ethernet@@Wirespeed */
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
	val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
		(val | (1 << 15) | (1 << 4)));
}
@


1.104
log
@Split bge(4)'s feature flags into bge_flags and bge_phy_flags.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.103 2013/12/28 03:30:40 deraadt Exp $	*/
d268 1
a268 1
		    BRGPHY_S1000 | BRGPHY_BMCR_FDX);
d281 1
a281 1
		    BRGPHY_S10);
d283 1
a283 1
		    BRGPHY_S10 | BRGPHY_BMCR_FDX);
d285 1
a285 1
		    BRGPHY_S100);
d287 1
a287 1
		    BRGPHY_S100 | BRGPHY_BMCR_FDX);
d291 1
a291 1
			    sc->mii_inst), BRGPHY_S1000);
d293 1
a293 1
			    sc->mii_inst), BRGPHY_S1000 | BRGPHY_BMCR_FDX);
d347 1
a347 1
			speed = BRGPHY_S1000;
d350 1
a350 1
			speed = BRGPHY_S100;
d353 1
a353 1
			speed = BRGPHY_S10;
d357 2
a358 2
				speed |= BRGPHY_BMCR_FDX;
				gig = BRGPHY_1000CTL_AFD;
d360 1
a360 1
				gig = BRGPHY_1000CTL_AHD;
d363 3
a365 3
			PHY_WRITE(sc, BRGPHY_MII_1000CTL, 0);
			PHY_WRITE(sc, BRGPHY_MII_ANAR, BRGPHY_SEL_TYPE);
			PHY_WRITE(sc, BRGPHY_MII_BMCR, speed);
d372 3
a374 3
			PHY_WRITE(sc, BRGPHY_MII_1000CTL, gig);
			PHY_WRITE(sc, BRGPHY_MII_BMCR,
			    speed|BRGPHY_BMCR_AUTOEN|BRGPHY_BMCR_STARTNEG);
d381 2
a382 2
				gig |= BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC;
			PHY_WRITE(sc, BRGPHY_MII_1000CTL, gig);
d478 2
a479 2
	bmsr = PHY_READ(sc, BRGPHY_MII_BMSR) | PHY_READ(sc, BRGPHY_MII_BMSR);
	if (bmsr & BRGPHY_BMSR_LINK)
d482 2
a483 2
	bmcr = PHY_READ(sc, BRGPHY_MII_BMCR);
	if (bmcr & BRGPHY_BMCR_LOOP)
d486 1
a486 1
	if (bmcr & BRGPHY_BMCR_AUTOEN) {
d489 1
a489 1
		if ((bmsr & BRGPHY_BMSR_ACOMP) == 0) {
d536 1
a536 2
			if (PHY_READ(sc, BRGPHY_MII_1000STS) &
			    BRGPHY_1000STS_MSR)
d553 2
a554 2
	bmsr = PHY_READ(sc, BRGPHY_MII_BMSR) | PHY_READ(sc, BRGPHY_MII_BMSR);
	if (bmsr & BRGPHY_BMSR_LINK)
d557 2
a558 2
	bmcr = PHY_READ(sc, BRGPHY_MII_BMCR);
	if (bmcr & BRGPHY_BMCR_LOOP)
d561 1
a561 1
	if (bmcr & BRGPHY_BMCR_AUTOEN) {
d564 1
a564 1
		if ((bmsr & BRGPHY_BMSR_ACOMP) == 0) {
d572 1
a572 2
		val = PHY_READ(sc, BRGPHY_SERDES_ANAR) &
		      PHY_READ(sc, BRGPHY_SERDES_ANLPAR);
d574 1
a574 1
		if (val & BRGPHY_SERDES_ANAR_FDX)
d595 2
a596 2
	bmsr = PHY_READ(sc, BRGPHY_MII_BMSR) | PHY_READ(sc, BRGPHY_MII_BMSR);
	if (bmsr & BRGPHY_BMSR_LINK)
d599 2
a600 2
	bmcr = PHY_READ(sc, BRGPHY_MII_BMCR);
	if (bmcr & BRGPHY_BMCR_LOOP)
d603 1
a603 1
	if (bmcr & BRGPHY_BMCR_AUTOEN) {
d606 1
a606 1
		if ((bmsr & BRGPHY_BMSR_ACOMP) == 0) {
d657 2
a658 2
        bmsr = PHY_READ(sc, BRGPHY_MII_BMSR) | PHY_READ(sc, BRGPHY_MII_BMSR);
        if (bmsr & BRGPHY_BMSR_LINK)
d661 2
a662 2
        bmcr = PHY_READ(sc, BRGPHY_MII_BMCR);
        if (bmcr & BRGPHY_BMCR_LOOP)
d665 1
a665 1
        if (bmcr & BRGPHY_BMCR_AUTOEN) {
d668 1
a668 1
                if ((bmsr & BRGPHY_BMSR_ACOMP) == 0) {
d716 1
a716 1
		anar = BRGPHY_SERDES_ANAR_FDX | BRGPHY_SERDES_ANAR_HDX;
d718 2
a719 2
			anar |= BRGPHY_SERDES_ANAR_BOTH_PAUSE;
		PHY_WRITE(sc, BRGPHY_SERDES_ANAR, anar);
d723 2
a724 2
			anar |= BRGPHY_ANAR_ASP | BRGPHY_ANAR_PC;
		PHY_WRITE(sc, BRGPHY_MII_ANAR, anar);
d728 1
a728 1
	ktcr = BRGPHY_1000CTL_AFD | BRGPHY_1000CTL_AHD;
d731 3
a733 3
		ktcr |= BRGPHY_1000CTL_MSE | BRGPHY_1000CTL_MSC;
	PHY_WRITE(sc, BRGPHY_MII_1000CTL, ktcr);
	ktcr = PHY_READ(sc, BRGPHY_MII_1000CTL);
d736 1
a736 2
	PHY_WRITE(sc, BRGPHY_MII_BMCR,
	    BRGPHY_BMCR_AUTOEN | BRGPHY_BMCR_STARTNEG);
d749 1
a749 1
	PHY_WRITE(sc, BRGPHY_MII_BMCR, BRGPHY_BMCR_LOOP);
d751 2
a752 2
		bmsr = PHY_READ(sc, BRGPHY_MII_BMSR);
		if (!(bmsr & BRGPHY_BMSR_LINK))
@


1.103
log
@mii drivers no longer need activate functions.  Repair of the PHY
configuration setting is done at resume time because all networks
drivers which were previously up, do an IFF_UP operation which
hits PHY_RESET.
This was in snapshots for about 2 weeks.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.102 2013/05/28 09:46:06 mikeb Exp $	*/
d218 1
a218 1
		if (bge_sc->bge_flags & BGE_10_100_ONLY)
d824 1
a824 1
	if (bge_sc->bge_flags & BGE_PHY_ADC_BUG)
d826 1
a826 1
	if (bge_sc->bge_flags & BGE_PHY_5704_A0_BUG)
d828 1
a828 1
	if (bge_sc->bge_flags & BGE_PHY_BER_BUG)
d830 1
a830 1
	else if (bge_sc->bge_flags & BGE_PHY_JITTER_BUG) {
d834 1
a834 1
		if (bge_sc->bge_flags & BGE_PHY_ADJUST_TRIM) {
d844 1
a844 1
	if (bge_sc->bge_flags & BGE_PHY_CRC_BUG)
d857 1
a857 1
	if (!(bge_sc->bge_flags & BGE_NO_ETH_WIRE_SPEED))
d861 1
a861 1
	if (bge_sc->bge_flags & BGE_NO_3LED) {
@


1.102
log
@Fix a common issue across different PHY drivers to reset the
autonegotiation timer when PHY gets the link so that if we
restart the timer the mii_ticks value would be sane.

Lifted originally from FreeBSD, tested by a few on re(4) and
bge(4), ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.101 2013/03/17 00:23:44 brad Exp $	*/
d67 1
a67 2
	sizeof(struct mii_softc), brgphy_probe, brgphy_attach, mii_phy_detach,
	    mii_phy_activate
@


1.101
log
@Split out bge / bnx reset code into a separate set of functions.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.100 2013/01/13 05:40:05 brad Exp $	*/
d415 2
a416 1
		if (reg & BMSR_LINK)
d418 1
@


1.100
log
@Add support for reporting flow control status for 5708S/5709S fibre PHY.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.99 2013/01/10 00:37:24 dlg Exp $	*/
d83 2
a762 2
	struct bge_softc *bge_sc = NULL;
	struct bnx_softc *bnx_sc = NULL;
d794 19
d823 16
a838 4
	/* Handle any bge (NetXtreme/NetLink) workarounds. */
	if (strcmp(devname, "bge") == 0) {
		if (!(sc->mii_flags & MIIF_HAVEFIBER)) {
			bge_sc = sc->mii_pdata->mii_ifp->if_softc;
d840 2
a841 20
			if (bge_sc->bge_flags & BGE_PHY_ADC_BUG)
				brgphy_adc_bug(sc);
			if (bge_sc->bge_flags & BGE_PHY_5704_A0_BUG)
				brgphy_5704_a0_bug(sc);
			if (bge_sc->bge_flags & BGE_PHY_BER_BUG)
				brgphy_ber_bug(sc);
			else if (bge_sc->bge_flags & BGE_PHY_JITTER_BUG) {
				PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0c00);
				PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG,
				    0x000a);

				if (bge_sc->bge_flags & BGE_PHY_ADJUST_TRIM) {
					PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT,
					    0x110b);
					PHY_WRITE(sc, BRGPHY_TEST1,
					    BRGPHY_TEST1_TRIM_EN | 0x4);
				} else {
					PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT,
					    0x010b);
				}
d843 2
a844 4
				PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0400);
			}
			if (bge_sc->bge_flags & BGE_PHY_CRC_BUG)
				brgphy_crc_bug(sc);
d846 20
a865 3
			/* Set Jumbo frame settings in the PHY. */
			if (bge_sc->bge_flags & BGE_JUMBO_CAPABLE)
				brgphy_jumbo_settings(sc);
d867 4
a870 4
			/* Adjust output voltage */
			if (sc->mii_oui == MII_OUI_BROADCOM2 &&
			    sc->mii_model == MII_MODEL_BROADCOM2_BCM5906)
				PHY_WRITE(sc, BRGPHY_MII_EPHY_PTEST, 0x12);
d872 59
a930 14
			/* Enable Ethernet@@Wirespeed */
			if (!(bge_sc->bge_flags & BGE_NO_ETH_WIRE_SPEED))
				brgphy_eth_wirespeed(sc);

			/* Enable Link LED on Dell boxes */
			if (bge_sc->bge_flags & BGE_NO_3LED) {
				PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL, 
				PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL)
					& ~BRGPHY_PHY_EXTCTL_3_LED);
			}
		}
	/* Handle any bnx (NetXtreme II) workarounds. */
	} else if (strcmp(devname, "bnx") == 0) {
		bnx_sc = sc->mii_pdata->mii_ifp->if_softc;
d932 4
a935 18
		if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5708 &&
		    sc->mii_flags & MIIF_HAVEFIBER) {
			/* Store autoneg capabilities/results in digital block (Page 0) */
			PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, BRGPHY_5708S_DIG3_PG2);
			PHY_WRITE(sc, BRGPHY_5708S_PG2_DIGCTL_3_0, 
				BRGPHY_5708S_PG2_DIGCTL_3_0_USE_IEEE);
			PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, BRGPHY_5708S_DIG_PG0);

			/* Enable fiber mode and autodetection */
			PHY_WRITE(sc, BRGPHY_5708S_PG0_1000X_CTL1, 
				PHY_READ(sc, BRGPHY_5708S_PG0_1000X_CTL1) | 
				BRGPHY_5708S_PG0_1000X_CTL1_AUTODET_EN | 
				BRGPHY_5708S_PG0_1000X_CTL1_FIBER_MODE);

			/* Enable parallel detection */
			PHY_WRITE(sc, BRGPHY_5708S_PG0_1000X_CTL2, 
				PHY_READ(sc, BRGPHY_5708S_PG0_1000X_CTL2) | 
				BRGPHY_5708S_PG0_1000X_CTL2_PAR_DET_EN);
d937 8
a944 18
			/* Advertise 2.5G support through next page during autoneg */
			if (bnx_sc->bnx_phy_flags & BNX_PHY_2_5G_CAPABLE_FLAG)
				PHY_WRITE(sc, BRGPHY_5708S_ANEG_NXT_PG_XMIT1, 
					PHY_READ(sc, BRGPHY_5708S_ANEG_NXT_PG_XMIT1) | 
					BRGPHY_5708S_ANEG_NXT_PG_XMIT1_25G);

			/* Increase TX signal amplitude */
			if ((BNX_CHIP_ID(bnx_sc) == BNX_CHIP_ID_5708_A0) ||
			    (BNX_CHIP_ID(bnx_sc) == BNX_CHIP_ID_5708_B0) ||
			    (BNX_CHIP_ID(bnx_sc) == BNX_CHIP_ID_5708_B1)) {
				PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, 
					BRGPHY_5708S_TX_MISC_PG5);
				PHY_WRITE(sc, BRGPHY_5708S_PG5_TXACTL1, 
					PHY_READ(sc, BRGPHY_5708S_PG5_TXACTL1) &
					~BRGPHY_5708S_PG5_TXACTL1_VCM);
				PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, 
					BRGPHY_5708S_DIG_PG0);
			}
d946 5
a950 16
			/* Backplanes use special driver/pre-driver/pre-emphasis values. */
			if ((bnx_sc->bnx_shared_hw_cfg & BNX_SHARED_HW_CFG_PHY_BACKPLANE) &&
			    (bnx_sc->bnx_port_hw_cfg & BNX_PORT_HW_CFG_CFG_TXCTL3_MASK)) {
					PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR, 
						BRGPHY_5708S_TX_MISC_PG5);
					PHY_WRITE(sc, BRGPHY_5708S_PG5_TXACTL3, 
						bnx_sc->bnx_port_hw_cfg & 
						BNX_PORT_HW_CFG_CFG_TXCTL3_MASK);
					PHY_WRITE(sc, BRGPHY_5708S_BLOCK_ADDR,
						BRGPHY_5708S_DIG_PG0);
			}
		} else if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5709 &&
		    sc->mii_flags & MIIF_HAVEFIBER) {
			/* Select the SerDes Digital block of the AN MMD. */
			PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
			    BRGPHY_BLOCK_ADDR_SERDES_DIG);
d952 30
a981 57
			PHY_WRITE(sc, BRGPHY_SERDES_DIG_1000X_CTL1,
			    (PHY_READ(sc, BRGPHY_SERDES_DIG_1000X_CTL1) &
			    ~BRGPHY_SD_DIG_1000X_CTL1_AUTODET) |
			    BRGPHY_SD_DIG_1000X_CTL1_FIBER);

			if (bnx_sc->bnx_phy_flags & BNX_PHY_2_5G_CAPABLE_FLAG) {
				/* Select the Over 1G block of the AN MMD. */
				PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
				    BRGPHY_BLOCK_ADDR_OVER_1G);

				/*
				 * Enable autoneg "Next Page" to advertise
				 * 2.5G support.
				 */
				PHY_WRITE(sc, BRGPHY_OVER_1G_UNFORMAT_PG1,
				    PHY_READ(sc, BRGPHY_OVER_1G_UNFORMAT_PG1) |
				    BRGPHY_5708S_ANEG_NXT_PG_XMIT1_25G);
			}

                        /*
                         * Select the Multi-Rate Backplane Ethernet block of
                         * the AN MMD.
                         */
                        PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
                            BRGPHY_BLOCK_ADDR_MRBE);

                        /* Enable MRBE speed autoneg. */
                        PHY_WRITE(sc, BRGPHY_MRBE_MSG_PG5_NP,
                            PHY_READ(sc, BRGPHY_MRBE_MSG_PG5_NP) |
                            BRGPHY_MRBE_MSG_PG5_NP_MBRE |
                            BRGPHY_MRBE_MSG_PG5_NP_T2);

                        /* Select the Clause 73 User B0 block of the AN MMD. */
                        PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
                            BRGPHY_BLOCK_ADDR_CL73_USER_B0);

                        /* Enable MRBE speed autoneg. */
                        PHY_WRITE(sc, BRGPHY_CL73_USER_B0_MBRE_CTL1,
                            BRGPHY_CL73_USER_B0_MBRE_CTL1_NP_AFT_BP |
                            BRGPHY_CL73_USER_B0_MBRE_CTL1_STA_MGR |
                            BRGPHY_CL73_USER_B0_MBRE_CTL1_ANEG);

                        PHY_WRITE(sc, BRGPHY_BLOCK_ADDR,
                            BRGPHY_BLOCK_ADDR_COMBO_IEEE0);
		} else if (BNX_CHIP_NUM(bnx_sc) == BNX_CHIP_NUM_5709) {
			if (BNX_CHIP_REV(bnx_sc) == BNX_CHIP_REV_Ax ||
			    BNX_CHIP_REV(bnx_sc) == BNX_CHIP_REV_Bx)
				brgphy_disable_early_dac(sc);

			/* Set Jumbo frame settings in the PHY. */
			brgphy_jumbo_settings(sc);

			/* Enable Ethernet@@Wirespeed */
			brgphy_eth_wirespeed(sc);
		} else {
			if (!(sc->mii_flags & MIIF_HAVEFIBER)) {
				brgphy_ber_bug(sc);
d983 2
a984 2
				/* Set Jumbo frame settings in the PHY. */
				brgphy_jumbo_settings(sc);
d986 2
a987 4
				/* Enable Ethernet@@Wirespeed */
				brgphy_eth_wirespeed(sc);
			}
		}
@


1.99
log
@apparently broadcom finally made a series of phys that done need a bunch
of workarounds in the 5718 family and up.

we dont attach bge to those chips yet, so this cant break anything that
isnt already broken.

from freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.97 2013/01/09 02:00:04 dlg Exp $	*/
d635 7
d700 3
@


1.98
log
@when checking if a particular phy has a particular model number,
make sure we check the oui as well. broadcom has 4 or 5 ouis with
overlapping model numbers, so they should be scoped when you look
them up.

tested on at least:

bge0 at pci3 dev 4 function 0 "Broadcom BCM5714" rev 0xa3, BCM5715 A3 (0x9003): ivec 0x795, address 00:14:4f:a9:34:90
brgphy0 at bge0 phy 1: BCM5714 10/100/1000baseT/SX PHY, rev. 0

bnx0 at pci7 dev 0 function 0 "Broadcom BCM5709" rev 0x20: apic 0 int 6
bnx0: address 1c:c1:de:e4:5e:b0
brgphy0 at bnx0 phy 1: BCM5709 10/100/1000baseT PHY, rev. 8

bge0 at pci0 dev 5 function 0 "Broadcom BCM5702X" rev 0x02, BCM5702/5703 A2 (0x1002): eb164 irq 2, address 00:10:18:00:98:e9
brgphy0 at bge0 phy 1: BCM5703 10/100/1000baseT PHY, rev. 2

bge0 at pci2 dev 0 function 0 "Broadcom BCM5761" rev 0x10, BCM5761 A1 (0x5761100): apic 2 int 18, address 00:10:18:4b:23:b4
brgphy0 at bge0 phy 1: BCM5761 10/100/1000baseT PHY, rev. 0

some tests by and ok mikeb@@ and naddy@@
@
text
@d784 8
@


1.97
log
@comments are lies. brgphy definitely supports more thant the BCR5400.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.96 2012/08/09 10:18:45 kettenis Exp $	*/
d227 1
d375 2
a376 1
			if (sc->mii_model != MII_MODEL_xxBROADCOM_BCM5701)
d437 4
a440 6
		switch (sc->mii_model) {
		case MII_MODEL_BROADCOM_BCM5400:
			brgphy_bcm5401_dspcode(sc);
			break;
		case MII_MODEL_xxBROADCOM_BCM5401:
			if (sc->mii_rev == 1 || sc->mii_rev == 3)
d442 2
d445 10
a454 2
		case MII_MODEL_xxBROADCOM_BCM5411:
			brgphy_bcm5411_dspcode(sc);
d517 2
a518 1
			if (sc->mii_model == MII_MODEL_BROADCOM2_BCM5906) {
d718 2
a719 1
	if (sc->mii_model == MII_MODEL_xxBROADCOM_BCM5701)
d759 4
a762 6
	switch (sc->mii_model) {
	case MII_MODEL_BROADCOM_BCM5400:
		brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5401:
		if (sc->mii_rev == 1 || sc->mii_rev == 3)
d764 9
d774 9
a782 8
	case MII_MODEL_BROADCOM_BCM5411:
		brgphy_bcm5411_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5421:
		brgphy_bcm5421_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM54K2:
		brgphy_bcm54k2_dspcode(sc);
d822 2
a823 1
			if (sc->mii_model == MII_MODEL_BROADCOM2_BCM5906)
d1146 2
a1147 1
	if (sc->mii_model == MII_MODEL_BROADCOM_BCM5401) {
@


1.96
log
@Add support for BCM5717/19/20C PHYs.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.95 2012/07/05 15:23:55 sthen Exp $	*/
a34 5
 */

/*
 * Driver for the Broadcom BCR5400 1000baseTX PHY. Speed is always
 * 1000mbps; all we need to negotiate here is full or half duplex.
@


1.95
log
@Correct the jumbo setup code within brgphy(4). The code had a mistake
and was actually disabling the jumbo settings for the PHY. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.94 2011/12/19 13:21:01 sthen Exp $	*/
d177 6
@


1.94
log
@add BCM57765, same diff jsg@@ ok kettenis@@

- vendor id is listed in Broadcom docs so kettenis suggests removing xx
however it's not listed in IEEE OUI list yet, this can be done later following
bikeshedding ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.93 2010/05/24 21:23:23 sthen Exp $	*/
d1131 1
a1131 1
			val & ~(BRGPHY_AUXCTL_LONG_PKT | 0x7));
d1136 1
a1136 1
		val & ~BRGPHY_PHY_EXTCTL_HIGH_LA);
@


1.93
log
@Support fibre PHY on BCM5709S. From FreeBSD via Brad.
Tested by Brad on: BCM5706, BCM5708C
Tested by me on: BCM5716 (BCM5709 PHY)
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.92 2010/04/09 22:01:37 sthen Exp $	*/
d177 2
@


1.92
log
@Attach to BCM5481, BCM5482. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.91 2010/04/06 20:20:52 naddy Exp $	*/
d84 1
d112 4
d173 2
d233 2
d625 58
d866 50
@


1.91
log
@Correct setting the autoneg ticks for GigE PHY, corrects what media
is presented for some of the Broadcom bge(4) FastE adapters.  From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.90 2010/02/16 09:12:33 sthen Exp $	*/
d146 4
@


1.90
log
@Recognize the BCM57780 PHY, tested by bruce on tech@@.
From Brad, ok jsg@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.89 2009/08/08 19:07:03 naddy Exp $	*/
d190 1
d196 1
d200 8
d217 1
d219 6
a224 5
		if (MII_OUI(ma->mii_id1, ma->mii_id2) ==
		    MII_OUI_xxBROADCOM &&
		    (sc->mii_model == MII_MODEL_xxBROADCOM_BCM5706 ||
		     sc->mii_model == MII_MODEL_xxBROADCOM_BCM5714 ||
		     sc->mii_model == MII_MODEL_xxBROADCOM_BCM5780))
a225 4
		else if (MII_OUI(ma->mii_id1, ma->mii_id2) ==
		    MII_OUI_xxBROADCOM2 && sc->mii_model ==
		    MII_MODEL_xxBROADCOM2_BCM5708S)
			sc->mii_funcs = &brgphy_5708s_funcs;
d228 5
a232 1
	sc->mii_anegticks = MII_ANEGTICKS;
a235 3
	if (strcmp(devname, "bnx") == 0)
		bnx_sc = sc->mii_pdata->mii_ifp->if_softc;

d242 4
a245 1
	mii_phy_add_media(sc);
d247 30
a276 6
	if (sc->mii_flags & MIIF_HAVEFIBER && bnx_sc &&
	   (bnx_sc->bnx_phy_flags & BNX_PHY_2_5G_CAPABLE_FLAG)) {
		sc->mii_anegticks = MII_ANEGTICKS_GIGE;
		ifmedia_add(&mii->mii_media,
		    IFM_MAKEWORD(IFM_ETHER, IFM_2500_SX, IFM_FDX,
		    sc->mii_inst), 0, NULL);
d278 4
d747 1
a747 2
		    ISSET(BNX_CHIP_BOND_ID(bnx_sc),
		     BNX_CHIP_BOND_ID_SERDES_BIT)) {
@


1.89
log
@match 5464 / 5461 IDs found in the Linux broadcom PHY driver and unknown
Broadcom GigE PHY found in the dmesglog; from Brad
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.88 2009/07/30 09:08:32 sthen Exp $	*/
d166 2
@


1.88
log
@Attach to BCM5761. From Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.87 2009/07/03 04:54:05 dlg Exp $	*/
d122 2
d126 2
d144 2
@


1.87
log
@this is a rather large change to add support for the BCM5709.

the 5709s use a the b09 firmwares, which is different to the b06 used by
all the other chips supported by bnx. the majority of the diff comes from
special handling for some indirect reads and writes, and because it needs
more host memory to operate with.

ive tried to keep the cosmetic changes to a minimum.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.85 2009/05/21 23:04:20 sthen Exp $	*/
d144 2
@


1.86
log
@replace the cumbersome macros that check for chip revisions with quirk flags
set at attach; from Brad
@
text
@d95 1
d154 4
d296 1
a297 1
			PHY_WRITE(sc, BRGPHY_MII_ANAR, BRGPHY_SEL_TYPE);
d696 3
a698 1
		if (sc->mii_model == MII_MODEL_xxBROADCOM2_BCM5708S) {
d746 10
d932 12
@


1.85
log
@add support for BCM576x, 577xx, and some new 572x/578x devices.
from Brad; testing by phessler, naddy, myself and others on a range
of older and newer devices. ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.84 2008/11/08 03:03:50 brad Exp $	*/
d669 1
a669 1
			if (bge_sc->bge_flags & BGE_JUMBO_CAP)
@


1.84
log
@Add additional link status checking for for the BCM5906 PHY.

Based on info from the Linux tg3 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.83 2008/11/08 01:50:48 brad Exp $	*/
d143 2
@


1.83
log
@Only read the Gig status register if Gig media status is detected.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.82 2008/08/30 08:16:13 brad Exp $	*/
d401 2
d409 3
a411 2
		switch (PHY_READ(sc, BRGPHY_MII_AUXSTS) &
			BRGPHY_AUXSTS_AN_RES) {
d434 7
@


1.82
log
@Move the link state check back up to the top of the various status
functions right after reading the BMSR as it was before the addition
of the fiber support and simplify brgphy_fiber_status() a bit.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.81 2008/06/13 22:23:08 brad Exp $	*/
a400 2
		int gsr;

d438 5
a442 4
		gsr = PHY_READ(sc, BRGPHY_MII_1000STS);
		if ((IFM_SUBTYPE(mii->mii_media_active) == IFM_1000_T) &&
		    gsr & BRGPHY_1000STS_MSR)
			mii->mii_media_active |= IFM_ETH_MASTER;
@


1.81
log
@Add support for fiber PHY on bge(4) (BCM5714/BCM5780) and
bnx(4) (BCM5706/BCM5708) adapters.

Thanks to Balzs Nagy <bnagy at thenewpush dot com> for
providing remote access to a Inventec IB4220 blade with
fiber BCM5780 interfaces and David Christensen at Broadcom
for providing BCM5708 2.5Gbps adapters.

Tested with various existing copper adapters and the above
mentioned adapters.

Some inspiration from similar changes to FreeBSD's brgphy(4)
driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.80 2008/06/11 23:53:49 brad Exp $	*/
d393 3
a396 1

d401 2
a407 6
	}

	if (bmsr & BRGPHY_BMSR_LINK) {
		int gsr;

		mii->mii_media_status |= IFM_ACTIVE;
d459 3
a462 1

d467 2
a473 1
	}
a474 2
	if (bmsr & BRGPHY_BMSR_LINK) {
		mii->mii_media_status |= IFM_ACTIVE;
d477 2
a478 6
		/*
		 * If autoneg enabled, read negotiated
		 * duplex settings
		 */
		if (bmcr & BRGPHY_BMCR_AUTOEN) {
			int val;
d480 4
a483 2
			val = PHY_READ(sc, BRGPHY_SERDES_ANAR) &
			      PHY_READ(sc, BRGPHY_SERDES_ANLPAR);
d485 2
a486 10
			if (val & BRGPHY_SERDES_ANAR_FDX)
				mii->mii_media_active |= IFM_FDX;
			else
				mii->mii_media_active |= IFM_HDX;

			if (mii->mii_media_active & IFM_FDX)
				mii->mii_media_active |=
				    mii_phy_flowstatus(sc);
		}
			mii->mii_media_active |= IFM_FDX;
d502 3
a505 1

d510 2
a516 6
	}

	if (bmsr & BRGPHY_BMSR_LINK) {
		int xstat;

		mii->mii_media_status |= IFM_ACTIVE;
a522 1
		/* Todo: Create #defines for hard coded values */
@


1.80
log
@Add a few comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.79 2008/06/10 21:18:41 brad Exp $	*/
d66 1
d81 3
a83 1
void	brgphy_status(struct mii_softc *);
d98 10
a107 2
const struct mii_phy_funcs brgphy_funcs = {            
	brgphy_service, brgphy_status, brgphy_reset,          
d149 2
d173 1
d177 3
a185 1
	sc->mii_funcs = &brgphy_funcs;
d190 13
d205 4
a208 1
	sc->mii_flags |= MIIF_NOISOLATE;
d215 10
a224 3
	if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
	    (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
		mii_phy_add_media(sc);
d231 1
a231 1
	int reg, speed, gig;
d268 3
d292 3
a294 1
			if (IFM_SUBTYPE(ife->ifm_media) != IFM_1000_T)
d337 2
a338 2
		reg = PHY_READ(sc, BRGPHY_MII_AUXSTS);
		if (reg & BRGPHY_AUXSTS_LINK)
d383 1
a383 1
brgphy_status(struct mii_softc *sc)
d387 1
a387 1
	int bmsr, bmcr, gsr;
d392 1
a392 4
	bmsr = PHY_READ(sc, BRGPHY_MII_BMSR);
	if (PHY_READ(sc, BRGPHY_MII_AUXSTS) & BRGPHY_AUXSTS_LINK)
		mii->mii_media_status |= IFM_ACTIVE;

d404 6
d436 1
a436 1
			break;
d446 3
d450 22
a471 1
		return;
d474 26
a499 1
	mii->mii_media_active = ife->ifm_media;
d502 57
a564 1
	brgphy_loop(sc);
d566 13
d580 1
a580 1
	ktcr = BRGPHY_1000CTL_AFD|BRGPHY_1000CTL_AHD;
d582 1
a582 1
		ktcr |= BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC;
a584 4
	DELAY(1000);
	anar = BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA;
	if (sc->mii_flags & MIIF_DOPAUSE)
		anar |= BRGPHY_ANAR_PC | BRGPHY_ANAR_ASP;
a585 2
	PHY_WRITE(sc, BRGPHY_MII_ANAR, anar);
	DELAY(1000);
d614 1
d642 2
a643 1
		bge_sc = sc->mii_pdata->mii_ifp->if_softc;
d645 22
a666 18
		if (bge_sc->bge_flags & BGE_PHY_ADC_BUG)
			brgphy_adc_bug(sc);
		if (bge_sc->bge_flags & BGE_PHY_5704_A0_BUG)
			brgphy_5704_a0_bug(sc);
		if (bge_sc->bge_flags & BGE_PHY_BER_BUG)
			brgphy_ber_bug(sc);
		else if (bge_sc->bge_flags & BGE_PHY_JITTER_BUG) {
			PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0c00);
			PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG, 0x000a);

			if (bge_sc->bge_flags & BGE_PHY_ADJUST_TRIM) {
				PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT,
				    0x110b);
				PHY_WRITE(sc, BRGPHY_TEST1,
				    BRGPHY_TEST1_TRIM_EN | 0x4);
			} else {
				PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT,
				    0x010b);
d668 2
d671 18
a688 22
			PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0400);
		}
		if (bge_sc->bge_flags & BGE_PHY_CRC_BUG)
			brgphy_crc_bug(sc);

		/* Set Jumbo frame settings in the PHY. */
		if (bge_sc->bge_flags & BGE_JUMBO_CAP)
			brgphy_jumbo_settings(sc);

		/* Adjust output voltage */
		if (sc->mii_model == MII_MODEL_BROADCOM2_BCM5906)
			PHY_WRITE(sc, BRGPHY_MII_EPHY_PTEST, 0x12);

		/* Enable Ethernet@@Wirespeed */
		if (!(bge_sc->bge_flags & BGE_NO_ETH_WIRE_SPEED))
			brgphy_eth_wirespeed(sc);

		/* Enable Link LED on Dell boxes */
		if (bge_sc->bge_flags & BGE_NO_3LED) {
			PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL, 
			PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL)
				& ~BRGPHY_PHY_EXTCTL_3_LED);
d692 1
a692 1
		brgphy_ber_bug(sc);
d694 36
a729 2
		/* Set Jumbo frame settings in the PHY. */
		brgphy_jumbo_settings(sc);
d731 22
a752 2
		/* Enable Ethernet@@Wirespeed */
		brgphy_eth_wirespeed(sc);
@


1.79
log
@formatting knits.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.78 2008/06/10 21:15:14 brad Exp $	*/
d414 1
d427 1
d435 1
d480 1
d527 1
@


1.78
log
@Some header cleanup. Remove some unused headers and shuffle some around
for consistency between drivers.

"looks good" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.77 2008/04/26 21:26:42 brad Exp $	*/
d461 1
a461 1
			break;
@


1.77
log
@Adjust the output voltage for BCM5906 PHY otherwise it might not be
possible to obtain a link under some circumstances which are unknown
at the moment.

From the Linux tg3 driver.

Issue reported by Kamil Andrusz <wizz at mniam dot net>

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.76 2008/04/20 01:32:43 brad Exp $	*/
a46 1
#include <sys/timeout.h>
a53 1
#ifdef INET
a55 1
#endif
@


1.76
log
@Add a workaround for a CRC bug errata with BCM5701 A0 and B0 chipset
revisions.

From Linux via FreeBSD.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.75 2008/03/02 16:05:26 brad Exp $	*/
d511 4
@


1.75
log
@Add missing half duplex flag for 100baseT4.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.74 2008/02/28 01:34:37 brad Exp $	*/
d94 1
d505 2
d669 20
@


1.74
log
@Update for the BCM5706 miidevs entry change.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.73 2008/01/31 03:39:22 brad Exp $	*/
d378 1
a378 1
			mii->mii_media_active |= IFM_100_T4;
@


1.73
log
@recognize the BCM5722 PHY.

tested by Rodolfo Gouveia and marco@@

ok kettenis@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.72 2007/10/13 16:29:52 kettenis Exp $	*/
d136 2
a137 2
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5706C,
	  MII_STR_xxBROADCOM_BCM5706C },
@


1.72
log
@Add support for BCM5906.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.71 2007/01/30 02:35:16 krw Exp $	*/
d130 2
@


1.71
log
@Rough in more support for 5787/5755 chips so far known to not work or
unreported in the wild. In this case add a PHY workaround for an eventual
mobile version of the chipset. No change to existing functionality.

From Michael Chan (mchan@@broadcom), via Linux tg3 and brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.70 2007/01/10 23:04:53 kettenis Exp $	*/
d138 2
@


1.70
log
@Flow control support for bge(4)/brgphy(4).  From brad@@ based on code from
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.69 2006/12/31 15:04:33 krw Exp $	*/
a93 1
void	brgphy_jitter_bug(struct mii_softc *);
d484 16
a499 2
		if (bge_sc->bge_flags & BGE_PHY_JITTER_BUG)
			brgphy_jitter_bug(sc);
a660 19
		{ BRGPHY_MII_AUXCTL,		0x0400 },
		{ 0,				0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
}

void
brgphy_jitter_bug(struct mii_softc *sc)
{
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ BRGPHY_MII_AUXCTL,		0x0c00 },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x000a },
		{ BRGPHY_MII_DSP_RW_PORT,	0x010b },
@


1.69
log
@Bring last few phys into line by calling their XXX_status() functions
through mii_phy_status() rather than directly. No functional change.

from brad@@ ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.68 2006/12/30 23:04:39 kettenis Exp $	*/
d391 3
d409 1
a409 1
	int ktcr = 0;
d419 5
a423 2
	PHY_WRITE(sc, BRGPHY_MII_ANAR,
	    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
@


1.68
log
@Set MASTER based on IFM_ETH_MASTER instead of LINK0.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.67 2006/12/22 14:11:03 kettenis Exp $	*/
d308 1
a308 1
	brgphy_status(sc);
@


1.67
log
@Set IFM_ETH_MASTER if local PHY configuration resolved to MASTER.

Based on a diff by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.66 2006/10/22 22:33:49 brad Exp $	*/
d259 3
a261 15
			/*
			 * When setting the link manually, one side must
			 * be the master and the other the slave. However
			 * ifmedia doesn't give us a good way to specify
			 * this, so we fake it by using one of the LINK
			 * flags. If LINK0 is set, we program the PHY to
			 * be a master, otherwise it's a slave.
			 */
			if ((mii->mii_ifp->if_flags & IFF_LINK0)) {
				PHY_WRITE(sc, BRGPHY_MII_1000CTL,
				    gig|BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC);
			} else {
				PHY_WRITE(sc, BRGPHY_MII_1000CTL,
				    gig|BRGPHY_1000CTL_MSE);
			}
@


1.66
log
@Set Jumbo frame settings for Jumbo capable bge(4) adapters.

Tested with BCM5700, BCM5703 and some BCM5704's.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.65 2006/10/20 03:52:22 brad Exp $	*/
d354 1
a354 1
	int bmsr, bmcr;
d402 6
@


1.65
log
@remove the IFM_100_T4 switch case for the manual media code, brgphy(4)
does not actually support 100baseT4.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.64 2006/10/20 03:30:24 brad Exp $	*/
d487 4
@


1.64
log
@attach for the Broadcom BCM5755 ASIC based chipsets as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.63 2006/10/20 01:08:24 brad Exp $	*/
a229 3
			goto setit;
		case IFM_100_T4:
			speed = BRGPHY_S100;
@


1.63
log
@move the Jumbo frame settings and Ethernet@@Wirespeed code into separate
functions. no-op change.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.62 2006/10/19 19:46:06 brad Exp $	*/
d131 2
@


1.62
log
@add a PHY workaround for the 5787 ASIC based chipsets.

Tested by Benjamin Black <ben at layer8 dot net>
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.61 2006/10/19 19:35:06 brad Exp $	*/
d95 2
a451 1
	u_int32_t val;
d489 3
a491 9
		/*
		 * Enable Ethernet@@WireSpeed.
		 */
		if (!(bge_sc->bge_flags & BGE_NO_ETH_WIRE_SPEED)) {
			PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
			val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
			PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
				(val | (1 << 15) | (1 << 4)));
		}
d503 1
a503 8
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7);
		val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 
			val & ~(BRGPHY_AUXCTL_LONG_PKT | 0x7));

		val = PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL);
		PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL, 
			val & ~BRGPHY_PHY_EXTCTL_HIGH_LA);
d506 1
a506 4
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
		val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
			(val | (1 << 15) | (1 << 4)));
d671 33
@


1.61
log
@Rearrange the code a bit, rename a few functions and make brgphy(4) use
the bge(4) PHY flags, to ensure errata workarounds are being applied to
the PHY on the appropriate chipsets.

Tested on bnx/gem/sk and a wide range of bge's.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.60 2006/10/15 21:17:31 brad Exp $	*/
d94 1
d485 2
d660 19
@


1.60
log
@fix parent driver match in brgphy_reset(), simplify code a bit as well, don't
need to bring in the bnx(4) softc.

Tested on bge, bnx, gem, sk

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.59 2006/10/15 21:12:41 brad Exp $	*/
a86 1
void	brgphy_load_dspcode(struct mii_softc *);
d91 3
a93 3
void	brgphy_bcm5703_dspcode(struct mii_softc *);
void	brgphy_bcm5704_dspcode(struct mii_softc *);
void	brgphy_bcm5750_dspcode(struct mii_softc *);
d329 2
d332 3
d336 1
a336 1
			brgphy_load_dspcode(sc);
d456 18
a473 1
	brgphy_load_dspcode(sc);
d478 7
d486 1
a486 4
		 * Don't enable Ethernet@@WireSpeed for the 5700 or 5705
		 * other than A0 and A1 chips. Make sure we only do this
		 * test on "bge" NICs, since other drivers may use this
		 * same PHY subdriver.
d488 6
a493 11
		if (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
		   (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
		    (bge_sc->bge_chipid != BGE_CHIPID_BCM5705_A0 &&
		     bge_sc->bge_chipid != BGE_CHIPID_BCM5705_A1)))
			return;
 
		/* Enable Ethernet@@WireSpeed. */
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
		val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
			(val | (1 << 15) | (1 << 4)));
d502 2
d606 1
a606 1
brgphy_bcm5703_dspcode(struct mii_softc *sc)
d627 1
a627 1
brgphy_bcm5704_dspcode(struct mii_softc *sc)
a632 6
		{ BRGPHY_MII_AUXCTL,		0x0c00 },
		{ BRGPHY_MII_DSP_ADDR_REG, 	0x201f },
		{ BRGPHY_MII_DSP_RW_PORT,	0x2aaa },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x000a },
		{ BRGPHY_MII_DSP_RW_PORT,	0x0323 },
		{ BRGPHY_MII_AUXCTL,		0x0400 },
d644 1
a644 1
brgphy_bcm5750_dspcode(struct mii_softc *sc)
a663 38
}

void
brgphy_load_dspcode(struct mii_softc *sc)
{
	switch (sc->mii_model) {
	case MII_MODEL_BROADCOM_BCM5400:
		brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5401:
		if (sc->mii_rev == 1 || sc->mii_rev == 3)
			brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5411:
		brgphy_bcm5411_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5421:
		brgphy_bcm5421_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM54K2:
		brgphy_bcm54k2_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5703:
		brgphy_bcm5703_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5704:
		brgphy_bcm5704_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5705:
	case MII_MODEL_xxBROADCOM_BCM5750:
	case MII_MODEL_xxBROADCOM_BCM5714:
	case MII_MODEL_xxBROADCOM_BCM5780:
	case MII_MODEL_xxBROADCOM_BCM5752:
	case MII_MODEL_xxBROADCOM_BCM5706C:
	case MII_MODEL_xxBROADCOM_BCM5708C:
		brgphy_bcm5750_dspcode(sc);
		break;
	}
@


1.59
log
@attach to the Broadcom BCM5787 PHY.

Tested by Benjamin Black <ben at layer8 dot net>
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.58 2006/10/11 23:25:56 brad Exp $	*/
a68 1
#include <dev/pci/if_bnxreg.h>
a444 2
	struct bnx_softc *bnx_sc = NULL;
	struct ifnet *ifp;
d446 3
d452 1
a452 1
	ifp = sc->mii_pdata->mii_ifp;
d454 2
a455 7
	/* Find the driver associated with this PHY. */
	if (strcmp(ifp->if_xname, "bge") == 0)
		bge_sc = ifp->if_softc;
	else if (strcmp(ifp->if_xname, "bnx") == 0)
		bnx_sc = ifp->if_softc;

	brgphy_load_dspcode(sc);
a456 1
	if (bge_sc) {
d472 2
a473 1
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, val | (1 << 15) | (1 << 4));
d479 1
a479 1
			    & ~BRGPHY_PHY_EXTCTL_3_LED);
d481 1
a481 1
	} else if (bnx_sc) {
d495 2
a496 1
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, (val | (1 << 15) | (1 << 4)));
@


1.58
log
@revert rev 1.54. This causes breakage with the PHY on a 5704 A3 chipset;
the link comes up, there is activity with tcpdump, but it doesn't work
as expected.

Issue reported by kettenis. ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.57 2006/10/09 00:29:25 brad Exp $	*/
d130 2
@


1.57
log
@revert the last two changes. the changes were causing brgphy@@gem to panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.54 2006/10/08 00:06:20 brad Exp $	*/
d217 2
a220 1
			PHY_RESET(sc); /* XXX hardware bug work-around */
a234 1
			PHY_RESET(sc); /* XXX hardware bug work-around */
@


1.56
log
@set Jumbo frame settings for Jumbo capable bge(4) adapters.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.55 2006/10/08 00:28:35 brad Exp $	*/
d88 1
d93 3
a95 4
void	brgphy_adc_bug(struct mii_softc *);
void	brgphy_5704_a0_bug(struct mii_softc *);
void	brgphy_ber_bug(struct mii_softc *);
void	brgphy_jitter_bug(struct mii_softc *);
a155 2
	struct bge_softc *bge_sc = NULL;
	struct ifnet *ifp;
a157 6
	ifp = sc->mii_pdata->mii_ifp;

	/* Find the driver associated with this PHY. */
	if (strcmp(ifp->if_xname, "bge") == 0)
		bge_sc = ifp->if_softc;

a328 2
			brgphy_bcm5401_dspcode(sc);
			break;
a329 3
			if (sc->mii_rev == 1 || sc->mii_rev == 3)
				brgphy_bcm5401_dspcode(sc);
			break;
d331 1
a331 1
			brgphy_bcm5411_dspcode(sc);
d458 1
a458 18
	switch (sc->mii_model) {
	case MII_MODEL_BROADCOM_BCM5400:
		brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5401:   
		if (sc->mii_rev == 1 || sc->mii_rev == 3)
			brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5411:   
		brgphy_bcm5411_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5421:
		brgphy_bcm5421_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM54K2:
		brgphy_bcm54k2_dspcode(sc);
		break;
	}
a460 25
		if (bge_sc->bge_flags & BGE_PHY_ADC_BUG)
			brgphy_adc_bug(sc);
		if (bge_sc->bge_flags & BGE_PHY_5704_A0_BUG)
			brgphy_5704_a0_bug(sc);
		if (bge_sc->bge_flags & BGE_PHY_BER_BUG)
			brgphy_ber_bug(sc);
		if (bge_sc->bge_flags & BGE_PHY_JITTER_BUG)
			brgphy_jitter_bug(sc);
		if (bge_sc->bge_flags & BGE_JUMBO_CAP) {
			/* Set Jumbo frame settings in the PHY. */
			if (sc->mii_model == MII_MODEL_BROADCOM_BCM5401) {
				/* Cannot do read-modify-write on the BCM5401 */
				PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x4c20);
			} else {
				PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7); 
				val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
				PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
				    val & ~(BRGPHY_AUXCTL_LONG_PKT | 0x7));
			}

			val = PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL);
			PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL,
			    val & ~BRGPHY_PHY_EXTCTL_HIGH_LA);
		}

d462 4
a465 1
		 * Enable Ethernet@@WireSpeed.
d467 10
a476 6
		if (!(bge_sc->bge_flags & BGE_NO_ETH_WIRE_SPEED)) {
			PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
			val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
			PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
			    (val | (1 << 15) | (1 << 4)));
		}
a484 2
		brgphy_ber_bug(sc);

d498 1
a498 2
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
		    (val | (1 << 15) | (1 << 4)));
d586 1
a586 1
brgphy_adc_bug(struct mii_softc *sc)
d607 1
a607 1
brgphy_5704_a0_bug(struct mii_softc *sc)
d613 6
d630 1
a630 1
brgphy_ber_bug(struct mii_softc *sc)
d653 1
a653 1
brgphy_jitter_bug(struct mii_softc *sc)
d655 33
a687 14
	static const struct {
		int		reg;
		uint16_t	val;
	} dspcode[] = {
		{ BRGPHY_MII_AUXCTL,            0x0c00 },
		{ BRGPHY_MII_DSP_ADDR_REG,      0x000a },
		{ BRGPHY_MII_DSP_RW_PORT,       0x010b },
		{ BRGPHY_MII_AUXCTL,            0x0400 },
		{ 0,                            0 },
	};
	int i;

	for (i = 0; dspcode[i].reg != 0; i++)
		PHY_WRITE(sc, dspcode[i].reg, dspcode[i].val);
@


1.55
log
@refactor the code a bit, use the bge(4) PHY flags and add another
PHY workaround from the Linux tg3 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.54 2006/10/08 00:06:20 brad Exp $	*/
d499 16
@


1.54
log
@- g/c unused code.
- only call PHY_RESET if trying to set a valid media type.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.53 2006/10/01 17:29:48 brad Exp $	*/
a87 1
void	brgphy_load_dspcode(struct mii_softc *);
d92 4
a95 3
void	brgphy_bcm5703_dspcode(struct mii_softc *);
void	brgphy_bcm5704_dspcode(struct mii_softc *);
void	brgphy_bcm5750_dspcode(struct mii_softc *);
d156 2
d160 6
d337 2
d340 3
d344 1
a344 1
			brgphy_load_dspcode(sc);
d471 18
a488 1
	brgphy_load_dspcode(sc);
d491 9
d501 1
a501 4
		 * Don't enable Ethernet@@WireSpeed for the 5700 or 5705
		 * other than A0 and A1 chips. Make sure we only do this
		 * test on "bge" NICs, since other drivers may use this
		 * same PHY subdriver.
d503 6
a508 10
		if (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
		   (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
		    (bge_sc->bge_chipid != BGE_CHIPID_BCM5705_A0 &&
		     bge_sc->bge_chipid != BGE_CHIPID_BCM5705_A1)))
			return;
 
		/* Enable Ethernet@@WireSpeed. */
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
		val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, val | (1 << 15) | (1 << 4));
d517 2
d532 2
a533 1
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL, (val | (1 << 15) | (1 << 4)));
d621 1
a621 1
brgphy_bcm5703_dspcode(struct mii_softc *sc)
d642 1
a642 1
brgphy_bcm5704_dspcode(struct mii_softc *sc)
a647 6
		{ BRGPHY_MII_AUXCTL,		0x0c00 },
		{ BRGPHY_MII_DSP_ADDR_REG, 	0x201f },
		{ BRGPHY_MII_DSP_RW_PORT,	0x2aaa },
		{ BRGPHY_MII_DSP_ADDR_REG,	0x000a },
		{ BRGPHY_MII_DSP_RW_PORT,	0x0323 },
		{ BRGPHY_MII_AUXCTL,		0x0400 },
d659 1
a659 1
brgphy_bcm5750_dspcode(struct mii_softc *sc)
d682 1
a682 1
brgphy_load_dspcode(struct mii_softc *sc)
d684 14
a697 33
	switch (sc->mii_model) {
	case MII_MODEL_BROADCOM_BCM5400:
		brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5401:
		if (sc->mii_rev == 1 || sc->mii_rev == 3)
			brgphy_bcm5401_dspcode(sc);
		break;
	case MII_MODEL_BROADCOM_BCM5411:
		brgphy_bcm5411_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5421:
		brgphy_bcm5421_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM54K2:
		brgphy_bcm54k2_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5703:
		brgphy_bcm5703_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5704:
		brgphy_bcm5704_dspcode(sc);
		break;
	case MII_MODEL_xxBROADCOM_BCM5705:
	case MII_MODEL_xxBROADCOM_BCM5750:
	case MII_MODEL_xxBROADCOM_BCM5714:
	case MII_MODEL_xxBROADCOM_BCM5780:
	case MII_MODEL_xxBROADCOM_BCM5752:
	case MII_MODEL_xxBROADCOM_BCM5706C:
	case MII_MODEL_xxBROADCOM_BCM5708C:
		brgphy_bcm5750_dspcode(sc);
		break;
	}
@


1.53
log
@pack several boolean fields into the existing bge_flags field.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.52 2006/08/28 03:06:47 brad Exp $	*/
a216 2
		PHY_RESET(sc); /* XXX hardware bug work-around */

d219 1
a219 7
#ifdef foo
			/*
			 * If we're already in auto mode, just return.
			 */
			if (PHY_READ(sc, BRGPHY_MII_BMCR) & BRGPHY_BMCR_AUTOEN)
				return (0);
#endif
d234 1
d434 1
a434 1
		if (!(bmsr & BRGPHY_BMSR_LINK)) {
a435 1
		}
@


1.52
log
@revert flags usage commits. too close to release. will go in post release instead.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.50 2006/07/23 06:34:03 brad Exp $	*/
d487 1
a487 1
		if (bge_sc->bge_no_3_led) {
@


1.51
log
@pack several boolean fields into the existing bge_flags field.
@
text
@d487 1
a487 1
		if (bge_sc->bge_flags & BGE_NO3LED) {
@


1.50
log
@revert back to the old brgphy_mii_phy_auto() which simplifies the autoneg code.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.49 2006/06/26 04:59:26 brad Exp $	*/
d342 2
d487 1
a487 1
		if (bge_sc->bge_no_3_led) {
@


1.49
log
@Add support for bnx(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.48 2006/05/20 23:03:53 brad Exp $	*/
d47 1
d85 1
a85 1
int	brgphy_mii_phy_auto(struct mii_softc *, int);
d228 1
a228 1
			(void) brgphy_mii_phy_auto(sc, 1);
d320 1
a320 2
		if (brgphy_mii_phy_auto(sc, 0) == EJUSTRETURN)
			return (0);
d408 1
a408 1
brgphy_mii_phy_auto(struct mii_softc *sc, int waitfor)
d410 1
a410 1
	int bmsr, ktcr = 0, i;
d412 14
a425 44
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		brgphy_loop(sc);
		PHY_RESET(sc);
		ktcr = BRGPHY_1000CTL_AFD|BRGPHY_1000CTL_AHD;
		if (sc->mii_model == MII_MODEL_xxBROADCOM_BCM5701)
			ktcr |= BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC;
		PHY_WRITE(sc, BRGPHY_MII_1000CTL, ktcr);
		ktcr = PHY_READ(sc, BRGPHY_MII_1000CTL);
		DELAY(1000);
		PHY_WRITE(sc, BRGPHY_MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
		DELAY(1000);
		PHY_WRITE(sc, BRGPHY_MII_BMCR,
		    BRGPHY_BMCR_AUTOEN | BRGPHY_BMCR_STARTNEG);
		PHY_WRITE(sc, BRGPHY_MII_IMR, 0xFF00);
	}

	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			if ((bmsr = PHY_READ(sc, BRGPHY_MII_BMSR)) &
			    BRGPHY_BMSR_ACOMP)
				return (0);
			DELAY(1000);
		}

		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag.
		 */
		return (EIO);
	}

	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if ((sc->mii_flags & MIIF_DOINGAUTO) == 0) {
		sc->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&sc->mii_phy_timo, mii_phy_auto_timeout, sc);
		timeout_add(&sc->mii_phy_timo, hz / 2);
	}
@


1.48
log
@also attach to Broadcom BCM5706C and BCM5708C PHY.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.47 2006/03/04 09:19:13 brad Exp $	*/
d68 1
d479 2
a480 1
	struct bge_softc *bge_sc;
d487 6
a492 1
	bge_sc = ifp->if_softc;
d496 12
a507 12
	/*
	 * Don't enable Ethernet@@WireSpeed for the 5700 or 5705
	 * other than A0 and A1 chips. Make sure we only do this
	 * test on "bge" NICs, since other drivers may use this
	 * same PHY subdriver.
	 */
	if (strncmp(ifp->if_xname, "bge", 3) == 0 &&
	    (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5700 ||
	    (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5705 &&
	     (bge_sc->bge_chipid != BGE_CHIPID_BCM5705_A0 &&
	      bge_sc->bge_chipid != BGE_CHIPID_BCM5705_A1))))
		return;
d509 17
a525 4
	/* Enable Ethernet@@WireSpeed. */
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
	val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, val | (1 << 15) | (1 << 4));
d527 1
a527 2
	/* Enable Link LED on Dell boxes */
	if (bge_sc->bge_no_3_led) {
d529 6
a534 2
		    PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL)
		    & ~BRGPHY_PHY_EXTCTL_3_LED);
@


1.47
log
@Do not enable the Ethernet@@WireSpeed PHY feature on 5705's and not 5750's
as the comment says.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.46 2005/12/10 22:17:04 brad Exp $	*/
d128 4
d696 2
@


1.46
log
@use the 5750 DSP code with the BCM5714 and BCM5780 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.45 2005/12/08 00:45:34 brad Exp $	*/
d493 1
a493 1
	    (BGE_ASICREV(bge_sc->bge_chipid) == BGE_ASICREV_BCM5750 &&
@


1.45
log
@BCM5715 -> BCM5780
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.44 2005/11/25 01:28:00 brad Exp $	*/
d689 2
@


1.44
log
@load the 5750 DSP code on the 5705 PHY too.

Based on Broadcom's Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.43 2005/11/20 01:36:43 brad Exp $	*/
a121 2
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5715,
	  MII_STR_xxBROADCOM_BCM5715 },
d126 2
@


1.43
log
@treat the BCM5715 like the 5714
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.42 2005/11/15 21:46:25 brad Exp $	*/
d687 1
a687 2
	case MII_MODEL_xxBROADCOM_BCM5714:
	case MII_MODEL_xxBROADCOM_BCM5715:
@


1.42
log
@- Addition of more DSP init code for brgphy models that come with BCM5703 and
BCM5703 bge(4) copper NICs.
- Do not enable Ethernet@@WireSpeed for 5705 chips other than A0 and A1.

Derived from Linux's tg3 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.41 2005/11/06 21:51:55 brad Exp $	*/
d122 2
d688 1
@


1.41
log
@load DSP code on all 5421's for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.40 2005/11/06 07:25:05 brad Exp $	*/
d484 4
a487 4
	 * Don't enable Ethernet@@WireSpeed for the 5700 or the
	 * 5705 A1 and A2 chips. Make sure we only do this test
	 * on "bge" NICs, since other drivers may use this same
	 * PHY subdriver.
d491 3
a493 2
	    bge_sc->bge_chipid == BGE_CHIPID_BCM5705_A1 ||
	    bge_sc->bge_chipid == BGE_CHIPID_BCM5705_A2))
d602 3
d620 6
@


1.40
log
@re-merge old brgphy_mii_phy_auto().
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.39 2005/11/06 03:49:28 brad Exp $	*/
d558 1
a558 1
	u_int16_t data;
d560 12
a571 14
        if (sc->mii_rev == 1) {
            /* Set Class A mode */
            PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x1007);
            data = PHY_READ(sc, BRGPHY_MII_AUXCTL);
            PHY_WRITE(sc, BRGPHY_MII_AUXCTL, data | 0x0400);

            /* Set FFE gamma override to -0.125 */
            PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0007);
            data = PHY_READ(sc, BRGPHY_MII_AUXCTL);
            PHY_WRITE(sc, BRGPHY_MII_AUXCTL, data | 0x0800);
            PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG, 0x000a);
            data = PHY_READ(sc, BRGPHY_MII_DSP_RW_PORT);
            PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT, data | 0x0200);
	}
@


1.39
log
@add DSP init code for BCM54K2.

values derived from Linux's sungem_phy driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.38 2005/11/06 03:22:28 brad Exp $	*/
d83 1
a83 1
int	brgphy_mii_phy_auto(struct mii_softc *);
d220 1
a220 1
			(void) brgphy_mii_phy_auto(sc);
d312 3
a314 2
		brgphy_mii_phy_auto(sc);
		return (0);
d401 1
a401 1
brgphy_mii_phy_auto(struct mii_softc *sc)
d403 18
a420 1
	int ktcr = 0;
d422 27
a448 14
	brgphy_loop(sc);
	PHY_RESET(sc);
	ktcr = BRGPHY_1000CTL_AFD|BRGPHY_1000CTL_AHD;
	if (sc->mii_model == MII_MODEL_xxBROADCOM_BCM5701)
		ktcr |= BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC;
	PHY_WRITE(sc, BRGPHY_MII_1000CTL, ktcr);
	ktcr = PHY_READ(sc, BRGPHY_MII_1000CTL);
	DELAY(1000);
	PHY_WRITE(sc, BRGPHY_MII_ANAR,
	    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
	DELAY(1000);
	PHY_WRITE(sc, BRGPHY_MII_BMCR,
	    BRGPHY_BMCR_AUTOEN | BRGPHY_BMCR_STARTNEG);
	PHY_WRITE(sc, BRGPHY_MII_IMR, 0xFF00);
@


1.38
log
@split the DSP code into separate functions as done in
the FreeBSD brgphy driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.37 2005/11/06 01:41:02 brad Exp $	*/
d90 1
d546 17
d636 3
@


1.37
log
@add a comment explaining what the 5401 DSP code does.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.36 2005/11/05 09:42:44 brad Exp $	*/
d87 6
a92 1
void	brgphy_bcm5421_init(struct mii_softc *);
a450 3
	if (sc->mii_model == MII_MODEL_xxBROADCOM_BCM5421)
		brgphy_bcm5421_init(sc);

d476 22
a497 4
struct bcm_dspcode {
	int		reg;
	u_int16_t	val;
};
d499 4
a502 15
/* Disable tap power management */
static const struct bcm_dspcode bcm5401_dspcode[] = {
	{ BRGPHY_MII_AUXCTL,            0x0c20 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x0012 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x1804 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x0013 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x1204 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0132 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0232 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x201f },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0a20 },
	{ 0,                            0 },
};
d505 69
a573 6
static const struct bcm_dspcode bcm5411_dspcode[] = {
	{ 0x1c,                         0x8c23 },
	{ 0x1c,                         0x8ca3 },
	{ 0x1c,                         0x8c23 },
	{ 0,                            0 },
};
d575 3
a577 6
static const struct bcm_dspcode bcm5703_dspcode[] = {
	{ BRGPHY_MII_AUXCTL,		0x0c00 },
	{ BRGPHY_MII_DSP_ADDR_REG,	0x201f },
	{ BRGPHY_MII_DSP_RW_PORT,	0x2aaa },
	{ 0,				0 },
};
d579 18
a596 5
static const struct bcm_dspcode bcm5704_dspcode[] = {
	{ 0x1c,				0x8d68 },
	{ 0x1c,				0x8d68 },
	{ 0,				0 },
};
d598 3
a600 11
static const struct bcm_dspcode bcm5750_dspcode[] = {
	{ BRGPHY_MII_AUXCTL,		0x0c00 },
	{ BRGPHY_MII_DSP_ADDR_REG,	0x000a },
	{ BRGPHY_MII_DSP_RW_PORT,	0x310b },
	{ BRGPHY_MII_DSP_ADDR_REG,	0x201f },
	{ BRGPHY_MII_DSP_RW_PORT,	0x9506 },
	{ BRGPHY_MII_DSP_ADDR_REG,	0x401f },
	{ BRGPHY_MII_DSP_RW_PORT,	0x14e2 },
	{ BRGPHY_MII_AUXCTL,		0x0400 },
	{ 0,				0 },
};
a604 3
	const struct bcm_dspcode *dsp = NULL;
	int wait=0, i;

d607 1
a607 2
		dsp = bcm5401_dspcode;
		wait=40;
d610 2
a611 4
		if (sc->mii_rev == 1 || sc->mii_rev == 3) {
			dsp = bcm5401_dspcode;
			wait=40;
		}
d614 4
a617 1
		dsp = bcm5411_dspcode;
d620 1
a620 1
		dsp = bcm5703_dspcode;
d623 1
a623 1
		dsp = bcm5704_dspcode;
d628 1
a628 1
		dsp = bcm5750_dspcode;
a629 30
	}

	if (dsp == NULL)
		return;

	for (i = 0; dsp[i].reg != 0; i++)
		PHY_WRITE(sc, dsp[i].reg, dsp[i].val);

	if (wait > 0)
		DELAY(wait);
}

void
brgphy_bcm5421_init(struct mii_softc *sc)
{
	u_int16_t data;

	if (sc->mii_rev == 1) {
	    /* Set Class A mode */
	    PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x1007);
	    data = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	    PHY_WRITE(sc, BRGPHY_MII_AUXCTL, data | 0x0400);

	    /* Set FFE gamma override to -0.125 */
	    PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x0007);
	    data = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	    PHY_WRITE(sc, BRGPHY_MII_AUXCTL, data | 0x0800);
	    PHY_WRITE(sc, BRGPHY_MII_DSP_ADDR_REG, 0x000a);
	    data = PHY_READ(sc, BRGPHY_MII_DSP_RW_PORT);
	    PHY_WRITE(sc, BRGPHY_MII_DSP_RW_PORT, data | 0x0200);
@


1.36
log
@add init code for BCM5421.

values derived from Linux's sungem_phy driver, same init
code also exists in Apple's GMAC driver too.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.35 2005/11/05 09:19:00 brad Exp $	*/
d479 1
d495 1
a495 1
/* setting some undocumented voltage */
@


1.35
log
@BCM5421K2 -> BCM54K2
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.34 2005/10/01 17:22:26 brad Exp $	*/
d87 1
d446 3
d494 1
d539 1
a539 1
		if (sc->mii_rev == 0 || sc->mii_rev == 3) {
d568 21
@


1.34
log
@add Broadcom BCM5421K2
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.33 2005/10/01 03:04:35 brad Exp $	*/
d101 2
a102 2
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5421K2,
	  MII_STR_xxBROADCOM_BCM5421K2 },
@


1.33
log
@load the BCM5401 DSP code for rev 0 and not rev 1.

From: Linux sungem_phy driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.32 2005/10/01 02:47:30 brad Exp $	*/
d99 4
a102 2
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCM5421S,
	  MII_STR_xxBROADCOM_BCM5421S },
@


1.32
log
@add Broadcom BCM5462
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.31 2005/09/17 20:16:31 brad Exp $	*/
d532 1
a532 1
		if (sc->mii_rev == 1 || sc->mii_rev == 3) {
@


1.31
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.30 2005/09/17 20:09:55 brad Exp $	*/
d101 2
@


1.30
log
@re-add code which allows setting master/slave flag for links with
manually set speed/duplex.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.29 2005/09/17 20:05:47 brad Exp $	*/
d126 1
a126 1
		return(10);
d128 1
a128 1
	return(0);
d148 1
a148 1
	sc->mii_flags = ma->mii_flags | MIIF_NOISOLATE;
d150 2
@


1.29
log
@- use PHY_RESET() on all models in brgphy_service()
- use PHY_RESET() in brgphy_mii_phy_auto()
- always use mii_phy_update() in brgphy_service()

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.28 2005/08/27 14:15:47 brad Exp $	*/
d242 16
@


1.28
log
@BCMunknown -> BCM5752

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.27 2005/08/22 00:22:10 brad Exp $	*/
d196 1
a196 2
		if (sc->mii_model != MII_MODEL_xxBROADCOM_BCM5701)
			PHY_RESET(sc); /* XXX hardware bug work-around */
d280 1
a280 1
			return (0);
a296 1
		mii_phy_update(sc, cmd);
d305 1
d376 1
a376 1
	/* XXX need 'PHY_RESET(sc);'? Was done before getting here ... */
@


1.27
log
@add a unknown Broadcom Gig PHY. This is just a placeholder for now until
we find out what model this is. a dmesg might help from that slacker niklas!

From: niklas@@

ok deraaadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.26 2005/06/29 04:37:07 brad Exp $	*/
a100 2
	{ MII_OUI_xxBROADCOM,		MII_MODEL_xxBROADCOM_BCMunknown,
	  MII_STR_xxBROADCOM_BCMunknown },
d113 2
d529 1
@


1.26
log
@remove unused FreeBSD printf
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.25 2005/06/11 06:12:14 brad Exp $	*/
d101 2
@


1.25
log
@need this too
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.24 2005/06/11 06:08:33 brad Exp $	*/
a401 3
#if 0
			device_printf(sc->mii_dev, "looped %d\n", i);
#endif
a416 2
	brgphy_load_dspcode(sc);

d419 2
@


1.24
log
@BCM5714
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.23 2005/03/26 04:40:09 krw Exp $	*/
d528 1
@


1.23
log
@Cleanup. Use defines, standard names, consistant comparison operators, etc.
for auto negotiation ticks code. No functional change.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.22 2005/02/05 22:30:52 brad Exp $	*/
d109 2
@


1.22
log
@better
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.21 2005/02/05 19:11:34 brad Exp $	*/
d145 1
a145 2
	sc->mii_ticks = 0; /* XXX Should be zero. Should 0 in brgphy_reset?*/
	sc->mii_anegticks = 5;
d276 1
a276 1
		if (++sc->mii_ticks < sc->mii_anegticks)
@


1.21
log
@use mii_phy_match()
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.20 2005/01/24 02:27:12 brad Exp $	*/
d121 1
a121 1
	if(mii_phy_match(ma, brgphys) != NULL)
@


1.20
log
@more constants
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.19 2004/12/12 22:41:31 brad Exp $	*/
d92 24
d121 1
a121 10
	if (MII_OUI(ma->mii_id1, ma->mii_id2) == MII_OUI_xxBROADCOM &&
	    (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5400 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5401 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5411 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5704 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5705 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5750))
d133 1
a133 21
	char *model;

	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5400 ||
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5400)
		model = MII_STR_BROADCOM_BCM5400;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5401)
		model = MII_STR_BROADCOM_BCM5401;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5411)
		model = MII_STR_BROADCOM_BCM5411;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S)
		model = MII_STR_xxBROADCOM_BCM5421S;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701)
		model = MII_STR_xxBROADCOM_BCM5701;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703)
		model = MII_STR_xxBROADCOM_BCM5703;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5704)
		model = MII_STR_xxBROADCOM_BCM5704;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5705)
		model = MII_STR_xxBROADCOM_BCM5705;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5750)
		model = MII_STR_xxBROADCOM_BCM5750;
d135 2
a136 1
	printf(": %s, rev. %d\n", model, MII_REV(ma->mii_id2));
@


1.19
log
@unbreak after last commit to bge(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.18 2004/10/31 06:59:25 brad Exp $	*/
d494 8
a501 8
	{ 0x18,				0x0c00 },
	{ 0x17,				0x000a },
	{ 0x15,				0x310b },
	{ 0x17,				0x201f },
	{ 0x15,				0x9506 },
	{ 0x17,				0x401f },
	{ 0x15,				0x14e2 },
	{ 0x18,				0x0400 },
@


1.18
log
@rev 1.68

Add support for BCM5705K

rev 1.74

Add support for the BCM5750/5751.  Unfortunately the documentation
I have from Broadcom does not give much information on these devices,
so the Broadcom Linux driver was used for clues to what these chips
support.  It turns out they are similar to the 5705 with the 5751
being the PCI-Express version and needing special work-arounds and
settings.

From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.17 2004/09/27 18:25:48 brad Exp $	*/
d435 1
a435 1
	    (bge_sc->bge_asicrev == BGE_ASICREV_BCM5700 ||
@


1.17
log
@ANSI protos and some minor cleanup

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.16 2004/09/26 00:59:58 brad Exp $	*/
d105 2
a106 1
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5705))
d137 2
a243 17

			/*
			 * On IFM_1000_X only,
			 * when setting the link manually, one side must
			 * be the master and the other the slave. However
			 * ifmedia doesn't give us a good way to specify
			 * this, so we fake it by using one of the LINK
			 * flags. If LINK0 is set, we program the PHY to
			 * be a master, otherwise it's a slave.
			 */
			if ((mii->mii_ifp->if_flags & IFF_LINK0)) {
				PHY_WRITE(sc, BRGPHY_MII_1000CTL,
				    gig|BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC);
			} else {
				PHY_WRITE(sc, BRGPHY_MII_1000CTL,
				    gig|BRGPHY_1000CTL_MSE);
			}
d493 12
d530 3
@


1.16
log
@Restructure the PHY entry points to use a structure of
entry points instead of descrete function pointers, and
extend this to include a "reset" entry point. Make sure
any PHY-specific reset routine is always used.

From NetBSD

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.15 2003/10/13 16:18:56 krw Exp $	*/
d93 1
a93 3
brgphy_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d112 1
a112 3
brgphy_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d160 1
a160 4
brgphy_service(sc, mii, cmd)
	struct mii_softc *sc;
	struct mii_data *mii;
	int cmd;
d327 1
a327 2
brgphy_status(sc)
	struct mii_softc *sc;
d387 1
a387 2
brgphy_mii_phy_auto(sc)
	struct mii_softc *sc;
d429 1
a429 2
brgphy_reset(sc)
	struct mii_softc *sc;
d508 1
a508 2
brgphy_load_dspcode(sc)
	struct mii_softc *sc;
@


1.15
log
@Bring bge and brgphy more up to date with changes from FreeBSD and NetBSD.

Some bug fixes, support for new hardware like the 5704 and 5705.

Testing by deraadt@@, danh@@, and drahn@@ amoung others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.14 2002/11/26 06:01:28 nate Exp $	*/
d88 4
d145 1
a147 2
	sc->mii_service = brgphy_service;
	sc->mii_status = brgphy_status;
d153 1
a153 1
	brgphy_reset(sc);
d202 1
a202 1
			brgphy_reset(sc); /* XXX hardware bug work-around */
d401 1
a401 1
	/* XXX need 'brgphy_reset(sc);'? Was done before getting here ... */
@


1.14
log
@1000baseTX -> 1000baseT
- More technically correct
- Matches FreeBSD and NetBSD
- Preserved #define for 1000baseTX for backwards compatibility
ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.13 2002/11/26 04:37:47 jason Exp $	*/
a45 1
#include <sys/malloc.h>
d49 2
d54 7
d67 2
d83 2
a84 3

int	brgphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
d101 3
a103 1
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703))
d132 4
d141 2
d146 3
a148 2
	sc->mii_flags |= MIIF_NOISOLATE;
	sc->mii_anegticks = 10;
d152 2
a153 3
	sc->mii_capabilities =
	    PHY_READ(sc, MII_BMSR) & ma->mii_capmask;
        if (sc->mii_capabilities & BMSR_EXTSTAT)
d155 3
a157 3
        if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
            (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
                mii_phy_add_media(sc);
d167 1
a167 1
	int reg, speed;
d198 2
a199 5
		PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL,
		    BRGPHY_PHY_EXTCTL_HIGH_LA|BRGPHY_PHY_EXTCTL_EN_LTR);
		PHY_WRITE(sc, BRGPHY_MII_AUXCTL,
		    BRGPHY_AUXCTL_LONG_PKT|BRGPHY_AUXCTL_TX_TST);
		PHY_WRITE(sc, BRGPHY_MII_IMR, 0xFF00);
d210 1
a210 1
			(void) brgphy_mii_phy_auto(sc, 1);
d223 2
a224 1
		setit:
d226 2
a227 2
				PHY_WRITE(sc, BRGPHY_MII_BMCR,
				    BRGPHY_BMCR_FDX|speed);
d229 1
a229 1
				PHY_WRITE(sc, BRGPHY_MII_BMCR, speed);
d231 3
d239 7
d257 1
a257 1
				    BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC);
d260 1
a260 1
				    BRGPHY_1000CTL_MSE);
a275 6
		 * Only used for autonegotiation.
		 */
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			return (0);

		/*
d282 1
a282 1
		 * Only retry autonegotiation every 5 seconds.
d284 2
a285 4
		if (++sc->mii_ticks != sc->mii_anegticks)
			return (0);

		sc->mii_ticks = 0;
d296 9
a304 4
		brgphy_reset(sc);
		if (brgphy_mii_phy_auto(sc, 0) == EJUSTRETURN)
			return(0);
		break;
d310 17
a326 2
	/* Callback if something changed. */
	mii_phy_update(sc, cmd);
d380 3
d392 2
a393 3
brgphy_mii_phy_auto(mii, waitfor)
	struct mii_softc *mii;
	int waitfor;
d395 1
a395 1
	int bmsr, ktcr = 0, i;
d397 23
a419 16
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		brgphy_reset(mii);
		PHY_WRITE(mii, BRGPHY_MII_BMCR, 0);
		DELAY(1000);
		ktcr = PHY_READ(mii, BRGPHY_MII_1000CTL);
		PHY_WRITE(mii, BRGPHY_MII_1000CTL, ktcr |
		    BRGPHY_1000CTL_AFD|BRGPHY_1000CTL_AHD);
		ktcr = PHY_READ(mii, BRGPHY_MII_1000CTL);
		DELAY(1000);
		PHY_WRITE(mii, BRGPHY_MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(mii->mii_capabilities) | ANAR_CSMA);
		DELAY(1000);
		PHY_WRITE(mii, BRGPHY_MII_BMCR,
		    BRGPHY_BMCR_AUTOEN | BRGPHY_BMCR_STARTNEG);
		PHY_WRITE(mii, BRGPHY_MII_IMR, 0xFF00);
	}
d421 4
a424 7
	if (waitfor) {
		/* Wait 500ms for it to complete. */
		for (i = 0; i < 500; i++) {
			if ((bmsr = PHY_READ(mii, BRGPHY_MII_BMSR)) &
			    BRGPHY_BMSR_ACOMP)
				return (0);
			DELAY(1000);
d426 1
a426 3
		if ((bmsr & BMSR_ACOMP) == 0)
			printf("%s: autonegotiation failed to complete\n",
			    mii->mii_dev.dv_xname);
d428 1
d430 1
a430 7

		/*
		 * Don't need to worry about clearing MIIF_DOINGAUTO.
		 * If that's set, a timeout is pending, and it will
		 * clear the flag.
		 */
		return (EIO);
a431 12

	/*
	 * Just let it finish asynchronously.  This is for the benefit of
	 * the tick handler driving autonegotiation.  Don't want 500ms
	 * delays all the time while the system is running!
	 */
	if ((mii->mii_flags & MIIF_DOINGAUTO) == 0) {
		mii->mii_flags |= MIIF_DOINGAUTO;
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz >> 1);
	}
	return (EJUSTRETURN);
d438 6
d445 27
d480 1
a480 1
	{ BRGPHY_MII_AUXCTL,            0x4c20 },
d501 13
d519 1
a519 1
	int id2, i;
d521 1
a521 5
	id2 = PHY_READ(sc, MII_PHYIDR2);

	mii_phy_reset(sc);
	
	switch (MII_MODEL(id2)) {
d524 1
d527 1
a527 1
		if (MII_REV(id2) == 1 || MII_REV(id2) == 3)
d529 2
d535 6
d548 3
@


1.13
log
@Pull in DSP patches for the BCM5400, BCM5401, and BCM5411; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.12 2002/11/20 14:14:21 nate Exp $	*/
d198 1
a198 1
		case IFM_1000_TX:
d218 1
a218 1
			if (IFM_SUBTYPE(ife->ifm_media) != IFM_1000_TX)
d323 1
a323 1
			mii->mii_media_active |= IFM_1000_TX | IFM_FDX;
d326 1
a326 1
			mii->mii_media_active |= IFM_1000_TX | IFM_HDX;
@


1.12
log
@Add another model
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.11 2002/05/04 11:30:06 fgsch Exp $	*/
d76 2
d79 2
a80 1
int brgphy_probe(parent, match, aux)
d132 1
a132 1
	mii_phy_reset(sc);
d279 1
a279 1
		mii_phy_reset(sc);
d359 1
a359 1
		mii_phy_reset(mii);
d408 65
@


1.11
log
@some space and tab cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.10 2002/04/08 20:55:29 nate Exp $	*/
d88 2
a89 1
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701))
d116 2
@


1.10
log
@Match on phy model found internally on the BCM5701 chips (3c996B-T)
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.9 2002/04/02 17:24:24 drahn Exp $	*/
d261 1
a261 1
		
@


1.9
log
@match on BCM5421S. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.8 2002/03/14 01:26:57 millert Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/mii/brgphy.c,v 1.5 2001/09/18 00:31:19 wpaul Exp $
d85 4
a88 4
	    MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S ||
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5400 ||
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5401 ||
	    MII_MODEL(ma->mii_id2) == MII_MODEL_BROADCOM_BCM5411))
d113 2
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.7 2001/10/05 18:30:54 nate Exp $	*/
d85 1
d111 2
@


1.7
log
@autodetect modes, clean up, sync autoneg code with freebsd.  Fixes problems
that I had with bge
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.6 2001/10/05 18:26:48 nate Exp $	*/
d59 2
a60 2
int brgphy_probe __P((struct device *, void *, void *));
void brgphy_attach __P((struct device *, struct device *, void *));
d71 2
a72 2
int	brgphy_service __P((struct mii_softc *, struct mii_data *, int));
void	brgphy_status __P((struct mii_softc *));
d74 2
a75 2
int	brgphy_mii_phy_auto __P((struct mii_softc *, int));
extern void	mii_phy_auto_timeout __P((void *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.7 2001/10/05 18:30:54 nate Exp $	*/
d34 1
a34 1
 * $FreeBSD: brgphy.c,v 1.8 2002/03/22 06:38:52 wpaul Exp $
d59 2
a60 2
int brgphy_probe(struct device *, void *, void *);
void brgphy_attach(struct device *, struct device *, void *);
d71 2
a72 2
int	brgphy_service(struct mii_softc *, struct mii_data *, int);
void	brgphy_status(struct mii_softc *);
d74 2
a75 2
int	brgphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
d85 3
a87 4
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5401 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5411 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701))
a109 4
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S)
		model = MII_STR_xxBROADCOM_BCM5421S;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701)
		model = MII_STR_xxBROADCOM_BCM5701;
d256 1
a256 1

@


1.7.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a75 2
void	brgphy_reset(struct mii_softc *);
void	brgphy_load_dspcode(struct mii_softc *);
d77 1
a77 2
int
brgphy_probe(parent, match, aux)
d88 1
a88 2
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703))
a114 2
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703)
		model = MII_STR_xxBROADCOM_BCM5703;
d126 1
a126 1
	brgphy_reset(sc);
d192 1
a192 1
		case IFM_1000_T:
d212 1
a212 1
			if (IFM_SUBTYPE(ife->ifm_media) != IFM_1000_T)
d273 1
a273 1
		brgphy_reset(sc);
d317 1
a317 1
			mii->mii_media_active |= IFM_1000_T | IFM_FDX;
d320 1
a320 1
			mii->mii_media_active |= IFM_1000_T | IFM_HDX;
d353 1
a353 1
		brgphy_reset(mii);
a401 65
}

void
brgphy_reset(sc)
	struct mii_softc *sc;
{
	brgphy_load_dspcode(sc);
}

struct bcm_dspcode {
	int		reg;
	u_int16_t	val;
};

static const struct bcm_dspcode bcm5401_dspcode[] = {
	{ BRGPHY_MII_AUXCTL,            0x4c20 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x0012 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x1804 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x0013 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x1204 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0132 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0232 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x201f },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0a20 },
	{ 0,                            0 },
};

static const struct bcm_dspcode bcm5411_dspcode[] = {
	{ 0x1c,                         0x8c23 },
	{ 0x1c,                         0x8ca3 },
	{ 0x1c,                         0x8c23 },
	{ 0,                            0 },
};

void
brgphy_load_dspcode(sc)
	struct mii_softc *sc;
{
	const struct bcm_dspcode *dsp = NULL;
	int id2, i;

	id2 = PHY_READ(sc, MII_PHYIDR2);

	mii_phy_reset(sc);
	
	switch (MII_MODEL(id2)) {
	case MII_MODEL_BROADCOM_BCM5400:
		dsp = bcm5401_dspcode;
		break;
	case MII_MODEL_BROADCOM_BCM5401:
		if (MII_REV(id2) == 1 || MII_REV(id2) == 3)
			dsp = bcm5401_dspcode;
		break;
	case MII_MODEL_BROADCOM_BCM5411:
		dsp = bcm5411_dspcode;
		break;
	}

	if (dsp == NULL)
		return;

	for (i = 0; dsp[i].reg != 0; i++)
		PHY_WRITE(sc, dsp[i].reg, dsp[i].val);
@


1.6
log
@use anegticks for phys that do their own autonegotiation timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.5 2001/08/19 15:07:34 miod Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/mii/brgphy.c,v 1.1 2000/04/22 01:58:17 wpaul Exp $
d125 5
a129 10
	if (sc->mii_capabilities & BMSR_MEDIAMASK)
		mii_phy_add_media(sc);

#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)

	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, 0, sc->mii_inst),
	    BRGPHY_BMCR_FDX);
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_1000_TX, IFM_FDX, sc->mii_inst), 0);

#undef ADD
d309 2
a310 1
		switch (PHY_READ(sc, BRGPHY_MII_AUXSTS) & BRGPHY_AUXSTS_AN_RES) {
d345 1
a345 1
	int bmsr, i;
d348 5
a352 1
		PHY_WRITE(mii, BRGPHY_MII_1000CTL,
d354 5
a358 1
		PHY_WRITE(mii, BRGPHY_MII_ANAR, BRGPHY_SEL_TYPE);
@


1.5
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.4 2001/04/12 04:51:27 deraadt Exp $	*/
d119 1
d259 1
a259 1
		if (++sc->mii_ticks != 5)
@


1.4
log
@print phy model at startup
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.3 2001/04/11 05:47:51 deraadt Exp $	*/
d388 2
a389 1
		timeout(mii_phy_auto_timeout, mii, hz >> 1);
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.4 2001/04/12 04:51:27 deraadt Exp $	*/
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.4.4.1 2001/05/14 22:25:20 niklas Exp $	*/
d34 1
a34 1
 * $FreeBSD: src/sys/dev/mii/brgphy.c,v 1.5 2001/09/18 00:31:19 wpaul Exp $
a118 1
	sc->mii_anegticks = 10;
d124 10
a133 5
        if (sc->mii_capabilities & BMSR_EXTSTAT)
		sc->mii_extcapabilities = PHY_READ(sc, MII_EXTSR);
        if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
            (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
                mii_phy_add_media(sc);
d258 1
a258 1
		if (++sc->mii_ticks != sc->mii_anegticks)
d313 1
a313 2
		switch (PHY_READ(sc, BRGPHY_MII_AUXSTS) &
			BRGPHY_AUXSTS_AN_RES) {
d348 1
a348 1
	int bmsr, ktcr = 0, i;
d351 1
a351 5
		mii_phy_reset(mii);
		PHY_WRITE(mii, BRGPHY_MII_BMCR, 0);
		DELAY(1000);
		ktcr = PHY_READ(mii, BRGPHY_MII_1000CTL);
		PHY_WRITE(mii, BRGPHY_MII_1000CTL, ktcr |
d353 1
a353 5
		ktcr = PHY_READ(mii, BRGPHY_MII_1000CTL);
		DELAY(1000);
		PHY_WRITE(mii, BRGPHY_MII_ANAR,
		    BMSR_MEDIA_TO_ANAR(mii->mii_capabilities) | ANAR_CSMA);
		DELAY(1000);
d388 1
a388 2
		timeout_set(&mii->mii_phy_timo, mii_phy_auto_timeout, mii);
		timeout_add(&mii->mii_phy_timo, hz >> 1);
@


1.4.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 2
a60 2
int brgphy_probe(struct device *, void *, void *);
void brgphy_attach(struct device *, struct device *, void *);
d71 2
a72 2
int	brgphy_service(struct mii_softc *, struct mii_data *, int);
void	brgphy_status(struct mii_softc *);
d74 2
a75 2
int	brgphy_mii_phy_auto(struct mii_softc *, int);
extern void	mii_phy_auto_timeout(void *);
@


1.4.4.4
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 1
 * $FreeBSD: brgphy.c,v 1.8 2002/03/22 06:38:52 wpaul Exp $
a75 2
void	brgphy_reset(struct mii_softc *);
void	brgphy_load_dspcode(struct mii_softc *);
d77 1
a77 2
int
brgphy_probe(parent, match, aux)
d85 3
a87 5
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5401 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5411 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703))
a109 6
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5421S)
		model = MII_STR_xxBROADCOM_BCM5421S;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5701)
		model = MII_STR_xxBROADCOM_BCM5701;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703)
		model = MII_STR_xxBROADCOM_BCM5703;
d121 1
a121 1
	brgphy_reset(sc);
d187 1
a187 1
		case IFM_1000_T:
d207 1
a207 1
			if (IFM_SUBTYPE(ife->ifm_media) != IFM_1000_T)
d256 1
a256 1

d268 1
a268 1
		brgphy_reset(sc);
d312 1
a312 1
			mii->mii_media_active |= IFM_1000_T | IFM_FDX;
d315 1
a315 1
			mii->mii_media_active |= IFM_1000_T | IFM_HDX;
d348 1
a348 1
		brgphy_reset(mii);
a396 65
}

void
brgphy_reset(sc)
	struct mii_softc *sc;
{
	brgphy_load_dspcode(sc);
}

struct bcm_dspcode {
	int		reg;
	u_int16_t	val;
};

static const struct bcm_dspcode bcm5401_dspcode[] = {
	{ BRGPHY_MII_AUXCTL,            0x4c20 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x0012 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x1804 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x0013 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x1204 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0132 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x8006 },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0232 },
	{ BRGPHY_MII_DSP_ADDR_REG,      0x201f },
	{ BRGPHY_MII_DSP_RW_PORT,       0x0a20 },
	{ 0,                            0 },
};

static const struct bcm_dspcode bcm5411_dspcode[] = {
	{ 0x1c,                         0x8c23 },
	{ 0x1c,                         0x8ca3 },
	{ 0x1c,                         0x8c23 },
	{ 0,                            0 },
};

void
brgphy_load_dspcode(sc)
	struct mii_softc *sc;
{
	const struct bcm_dspcode *dsp = NULL;
	int id2, i;

	id2 = PHY_READ(sc, MII_PHYIDR2);

	mii_phy_reset(sc);
	
	switch (MII_MODEL(id2)) {
	case MII_MODEL_BROADCOM_BCM5400:
		dsp = bcm5401_dspcode;
		break;
	case MII_MODEL_BROADCOM_BCM5401:
		if (MII_REV(id2) == 1 || MII_REV(id2) == 3)
			dsp = bcm5401_dspcode;
		break;
	case MII_MODEL_BROADCOM_BCM5411:
		dsp = bcm5411_dspcode;
		break;
	}

	if (dsp == NULL)
		return;

	for (i = 0; dsp[i].reg != 0; i++)
		PHY_WRITE(sc, dsp[i].reg, dsp[i].val);
@


1.4.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d46 1
a49 2
#include <machine/bus.h>

a52 7
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <dev/pci/pcivar.h>

a58 2
#include <dev/pci/if_bgereg.h>

d73 3
a75 2
int	brgphy_mii_phy_auto(struct mii_softc *);
void	brgphy_loop(struct mii_softc *);
d92 1
a92 3
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5703 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5704 ||
	     MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5705))
a120 4
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5704)
		model = MII_STR_xxBROADCOM_BCM5704;
	if (MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5705)
		model = MII_STR_xxBROADCOM_BCM5705;
a125 2
	sc->mii_model = MII_MODEL(ma->mii_id2);
	sc->mii_rev = MII_REV(ma->mii_id2);
d129 2
a130 3
	sc->mii_flags = ma->mii_flags | MIIF_NOISOLATE;
	sc->mii_ticks = 0; /* XXX Should be zero. Should 0 in brgphy_reset?*/
	sc->mii_anegticks = 5;
d134 3
a136 2
	sc->mii_capabilities = PHY_READ(sc, MII_BMSR) & ma->mii_capmask;
	if (sc->mii_capabilities & BMSR_EXTSTAT)
d138 3
a140 3
	if ((sc->mii_capabilities & BMSR_MEDIAMASK) ||
	    (sc->mii_extcapabilities & EXTSR_MEDIAMASK))
		mii_phy_add_media(sc);
d150 1
a150 1
	int reg, speed, gig;
d181 5
a185 2
		if (sc->mii_model != MII_MODEL_xxBROADCOM_BCM5701)
			brgphy_reset(sc); /* XXX hardware bug work-around */
d196 1
a196 1
			(void) brgphy_mii_phy_auto(sc);
d209 1
a209 2
setit:
			brgphy_loop(sc);
d211 2
a212 2
				speed |= BRGPHY_BMCR_FDX;
				gig = BRGPHY_1000CTL_AFD;
d214 1
a214 1
				gig = BRGPHY_1000CTL_AHD;
a215 3

			PHY_WRITE(sc, BRGPHY_MII_1000CTL, 0);
			PHY_WRITE(sc, BRGPHY_MII_BMCR, speed);
a220 7
			PHY_WRITE(sc, BRGPHY_MII_1000CTL, gig);
			PHY_WRITE(sc, BRGPHY_MII_BMCR,
			    speed|BRGPHY_BMCR_AUTOEN|BRGPHY_BMCR_STARTNEG);

			if (sc->mii_model != MII_MODEL_xxBROADCOM_BCM5701)
 				break;

d232 1
a232 1
				    gig|BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC);
d235 1
a235 1
				    gig|BRGPHY_1000CTL_MSE);
d251 6
d263 1
a263 1
		 * Only used for autonegotiation.
d265 4
a268 2
		if (IFM_SUBTYPE(ife->ifm_media) != IFM_AUTO)
			break;
d279 4
a282 9
		/*
		 * Only retry autonegotiation every mii_anegticks seconds.
		 */
		if (++sc->mii_ticks < sc->mii_anegticks)
			return (0);

		sc->mii_ticks = 0;
		brgphy_mii_phy_auto(sc);
		return (0);
d288 2
a289 17
	/*
	 * Callback if something changed. Note that we need to poke the DSP on
	 * the Broadcom PHYs if the media changes.
	 */
	if (sc->mii_media_active != mii->mii_media_active || 
	    sc->mii_media_status != mii->mii_media_status ||
	    cmd == MII_MEDIACHG) {
		mii_phy_update(sc, cmd);
		switch (sc->mii_model) {
		case MII_MODEL_BROADCOM_BCM5400:
		case MII_MODEL_xxBROADCOM_BCM5401:
		case MII_MODEL_xxBROADCOM_BCM5411:
			brgphy_load_dspcode(sc);
			break;
		}
	}

a342 3
		default:
			mii->mii_media_active |= IFM_NONE;
			break;
d352 3
a354 2
brgphy_mii_phy_auto(sc)
	struct mii_softc *sc;
d356 1
a356 1
	int ktcr = 0;
d358 16
a373 14
	brgphy_loop(sc);
	/* XXX need 'brgphy_reset(sc);'? Was done before getting here ... */
	ktcr = BRGPHY_1000CTL_AFD|BRGPHY_1000CTL_AHD;
	if (sc->mii_model == MII_MODEL_xxBROADCOM_BCM5701)
		ktcr |= BRGPHY_1000CTL_MSE|BRGPHY_1000CTL_MSC;
	PHY_WRITE(sc, BRGPHY_MII_1000CTL, ktcr);
	ktcr = PHY_READ(sc, BRGPHY_MII_1000CTL);
	DELAY(1000);
	PHY_WRITE(sc, BRGPHY_MII_ANAR,
	    BMSR_MEDIA_TO_ANAR(sc->mii_capabilities) | ANAR_CSMA);
	DELAY(1000);
	PHY_WRITE(sc, BRGPHY_MII_BMCR,
	    BRGPHY_BMCR_AUTOEN | BRGPHY_BMCR_STARTNEG);
	PHY_WRITE(sc, BRGPHY_MII_IMR, 0xFF00);
d375 7
a381 13
	return (EJUSTRETURN);
}

void
brgphy_loop(struct mii_softc *sc)
{
	u_int32_t bmsr;
	int i;

	PHY_WRITE(sc, BRGPHY_MII_BMCR, BRGPHY_BMCR_LOOP);
	for (i = 0; i < 15000; i++) {
		bmsr = PHY_READ(sc, BRGPHY_MII_BMSR);
		if (!(bmsr & BRGPHY_BMSR_LINK)) {
d383 3
a385 1
			device_printf(sc->mii_dev, "looped %d\n", i);
a386 1
			break;
d388 7
a394 1
		DELAY(10);
d396 12
a413 6
	struct bge_softc *bge_sc;
	struct ifnet *ifp;
	u_int32_t val;

	mii_phy_reset(sc);

a414 27

	ifp = sc->mii_pdata->mii_ifp;
	bge_sc = ifp->if_softc;

	/*
	 * Don't enable Ethernet@@WireSpeed for the 5700 or the
	 * 5705 A1 and A2 chips. Make sure we only do this test
	 * on "bge" NICs, since other drivers may use this same
	 * PHY subdriver.
	 */
	if (strncmp(ifp->if_xname, "bge", 3) == 0 &&
	    (bge_sc->bge_asicrev == BGE_ASICREV_BCM5700 ||
	    bge_sc->bge_chipid == BGE_CHIPID_BCM5705_A1 ||
	    bge_sc->bge_chipid == BGE_CHIPID_BCM5705_A2))
		return;
 
	/* Enable Ethernet@@WireSpeed. */
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, 0x7007);
	val = PHY_READ(sc, BRGPHY_MII_AUXCTL);
	PHY_WRITE(sc, BRGPHY_MII_AUXCTL, val | (1 << 15) | (1 << 4));

	/* Enable Link LED on Dell boxes */
	if (bge_sc->bge_no_3_led) {
		PHY_WRITE(sc, BRGPHY_MII_PHY_EXTCTL, 
		    PHY_READ(sc, BRGPHY_MII_PHY_EXTCTL)
		    & ~BRGPHY_PHY_EXTCTL_3_LED);
	}
d423 1
a423 1
	{ BRGPHY_MII_AUXCTL,            0x0c20 },
a443 13
static const struct bcm_dspcode bcm5703_dspcode[] = {
	{ BRGPHY_MII_AUXCTL,		0x0c00 },
	{ BRGPHY_MII_DSP_ADDR_REG,	0x201f },
	{ BRGPHY_MII_DSP_RW_PORT,	0x2aaa },
	{ 0,				0 },
};

static const struct bcm_dspcode bcm5704_dspcode[] = {
	{ 0x1c,				0x8d68 },
	{ 0x1c,				0x8d68 },
	{ 0,				0 },
};

d449 1
a449 1
	int wait=0, i;
d451 5
a455 1
	switch (sc->mii_model) {
a457 1
		wait=40;
d460 1
a460 1
		if (sc->mii_rev == 1 || sc->mii_rev == 3) {
a461 2
			wait=40;
		}
a465 6
	case MII_MODEL_xxBROADCOM_BCM5703:
		dsp = bcm5703_dspcode;
		break;
	case MII_MODEL_xxBROADCOM_BCM5704:
		dsp = bcm5704_dspcode;
		break;
a472 3

	if (wait > 0)
		DELAY(wait);
@


1.3
log
@BCM5401/5411 support
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.2 2000/08/29 19:00:36 jason Exp $	*/
d101 11
@


1.2
log
@openbsdisms
@
text
@d1 1
a1 1
/*	$OpenBSD: brgphy.c,v 1.1 2000/08/28 05:22:25 jason Exp $	*/
d84 4
a87 1
	    MII_MODEL(ma->mii_id2) == MII_MODEL_xxBROADCOM_BCM5400)
d109 1
a109 1
#define	ADD(m, c)	ifmedia_add(&mii->mii_media, (m), (c), NULL)
d111 4
a114 2
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_NONE, 0, sc->mii_inst),
	    BMCR_ISO);
d116 1
a116 1
	mii_phy_reset(sc);
a120 1
	ADD(IFM_MAKEWORD(IFM_ETHER, IFM_AUTO, 0, sc->mii_inst), 0);
d132 1
a132 1
	int reg;
d181 11
d194 1
a194 1
				    BRGPHY_BMCR_FDX|BRGPHY_BMCR_SPD1);
d196 1
a196 2
				PHY_WRITE(sc, BRGPHY_MII_BMCR,
				    BRGPHY_BMCR_SPD1);
d200 3
d204 2
a205 1
			 * When settning the link manually, one side must
a219 3
		case IFM_100_T4:
		case IFM_100_TX:
		case IFM_10_T:
d280 2
a281 1
	int bmsr, bmcr, anlpar;
d302 23
a324 6
		mii->mii_media_active |= IFM_1000_TX;
		anlpar = PHY_READ(sc, BRGPHY_MII_AUXSTS);
		if ((anlpar & BRGPHY_AUXSTS_AN_RES) == BRGPHY_RES_1000FD)
			mii->mii_media_active |= IFM_FDX;
		if ((anlpar & BRGPHY_AUXSTS_AN_RES) == BRGPHY_RES_1000HD)
			mii->mii_media_active |= IFM_HDX;
d328 1
a328 7
	mii->mii_media_active |= IFM_1000_TX;
	if (bmcr & BRGPHY_BMCR_FDX)
		mii->mii_media_active |= IFM_FDX;
	else
		mii->mii_media_active |= IFM_HDX;

	return;
@


1.1
log
@driver for broadcom 5400 from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d129 3
@

